{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012053000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 9346974, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 153, "INMDSNAM": "CBT.V500.FILE454.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 9346974, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 9346974, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE454.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x9b\\x0e'", "DS1TRBAL": "b'(`'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03=\\x00\\x07\\x03G\\x00\\x0c\\x00\\x9c'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$DOC": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x945\\x0f\\x00\\x945\\x0f\\x14!\\x01\\x13\\x01\\x13\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-16T00:00:00", "modifydate": "1994-12-16T14:21:00", "lines": 275, "newlines": 275, "modlines": 0, "user": "SYSPAJA"}, "text": "1   16.12.94                                            DOC - Page 1/6.\n\n          ***************************************************\n          ***     P R E L I M I N A R Y     N O T E S     ***\n          ***************************************************\n\n Files author : MOINIL P.A.\n -------------- Computing Centre (TP361)\n                J.R.C. - Ispra establishment\n                21020 ISPRA (VA), Italy\n                Phone : (0332) 789442 (direct in my office), or for\n                        external state calling nnnn-332-789442 (i.e.,\n                        nnnn is 0039 from Belgium or Germany).\n                Any comments, suggestions or complaints are welcome to\n                maintain and update this material.\n                THANK YOU and GOOD LUCK.\n                Other contact : Mr. COLOMBO Antonio\n                                AMDAHL ITALIA s.p.a.\n                                Viale BRENTA, 16/18\n                                20139 MILANO, Italy\n                        Phone : +39-332-780309\n                             or +39-332-780182\n                             or +39-332-574741 AMDAHL office\n                Antonio can also be reached easily via electronic mail\n                at the following addresses :\n                   antonio.colombo@cen.jrc.it    <- Ispra site\n                   azc10@amail.amdahl.com        <- Amdahl Corporation\n\n     Many products in these files have been extracted from the CBT\n     tapes (JUN 84, FEB 85, FEB 86, FEB 87, FEB 88, FEB 89, MAY 90,\n     MAR 91, MAR92, ...), adapted and/or enhanced to our installation\n     needs or facilities. The material provided in these files run on\n     system MVS 3.8 SP 2.2.3 (MVS/XA).\n\n Products installation requirement :\n -----------------------------------\n     See to the member $$$PROCS which contains a job to store the\n     procedures used for products installation.\n     Notes : 1. I normally use the assembler H, so I can't guarantee\n                against possible errors with the assembler F.\n             2. AMODE and RMODE 24 is indicated for modules having\n                control blocks containing 24-bit addresses (i.e. DCB).\n\n Data-set members structure :\n ----------------------------\n     The members names ending by a dollar sign ($) are the JCL to\n     install (assembly + link-edit) the modules, and the members\n     names ending by a paragraph sign (@) are the corresponding\n     assembler macros or modules documentation.\n1   17.11.94                                            DOC - Page 2/6.\n\n ATTENTION : we have installed the C.J.S. (Chained Jobs Scheduling,\n ----------- product 5785-GAK) which requires the change of the JES2\n     standard dollar sign ($) for local operator and instream command\n     identifier (JES2PARM allows it). We have choiced the period (.),\n     so be carefull and checks modules involving operators commands to\n     your needs (i.e., DIDOCS and SCHEDRUN).\n\n IOF product : some procedures (i.e. PAJCSHWM) use IOFSPF which is\n ------------- the Interactive Output Facility from Triangle Systems,\n               Inc. P.O. box 12752, Research Triangle Park, NC 27709.\n\n ADVICE - US and European characters differences :\n -------------------------------------------------\n          Sorry, but working on European terminals, some differences\n     may occur in special characters use. A well known one to us is the\n     exclamation mark which is X'5A' hexadecimal value in US, but this\n     value corresponds to a small letter e with acute accent at our\n     installation. Consequently, in a lot of members in these files,\n     we have replaced it by the X'4F' hexadecimal value which is the\n     one representing the exclamation mark on our terminals.\n          Unfortunately, you can't apply automatically a change from\n     X'4F' to X'5A' or vive versa, because i.e., an ISPF Edit macro\n     is recognized only if invoked with an X'5A' character.\n          In some products, I have supplied the selection through the\n     Assembler SYSPARM option.\n\n                   *********************************\n                   ***     INFORMATION NOTES     ***\n                   *********************************\n\n     If you install the LISTNO program, you may then SUBMIT the job\n below to obtain a copy of this document :\n         //...      JOB ...\n         //DOC     EXEC PGM=LISTNO,PARM='M=DOC'\n         //SYSPDS    DD DSN=->.SOURCE.FILE0,DISP=SHR\n         //SYSPRINT  DD SYSOUT=A\n     A complete information notes list (about 8000 lines) may be also\n obtained by this job if you specify M=INFO as parameter.\n     If you omit the PARM field or specify M=MANUAL, you will receive\n an example of how to build a manual of notes.\n1   17.11.94                                            DOC - Page 3/6.\n\n  *******************************************************************\n  ***     D A T A - S E T ->.SOURCE.FILE0     C O N T E N T S     ***\n  *******************************************************************\n\n ---------  ----------------------------------------------------------\n   Name       Function\n ---------  ----------------------------------------------------------\n\n $DEFREG    Registers definition (registers equates) assembler macro.\n $FS        Generate full screen orders and fields (IBM 3270 display)\n            assembler macros.\n $HEDIT     Header edit (blocks letters in assembly) assembler macro.\n $SORT      Generate in-line sort assembler macro.\n $TEW$..    TSO Easy-Way of coding (macros faciltity).\n $TSWXA     Test and switch addressing mode macro.\n $XENT      Enter program control assembler macro.\n $XRET      Return program control assembler macro.\n ALLOCGDG   GDG data-set dynamic allocation TSO command.\n AUTHC      Command Authorization interface (TSO).\n AUTHCTL    Euratom Authority Control module.\n AUTHSVC    Authorization SVC for MVS (IGC00###).\n BIG        Create block characters ISPF/PDF EDIT command.\n BIGS       Create slanted block characters ISPF/PDF EDIT command.\n BLOCK      Create multiple block characters ISPF/PDF EDIT command.\n CATS       Read sequentially an O.S. catalog routine.\n CENTER     Center ISPF/PDF EDIT command.\n CNVCLIST   Convert CLISTs from VB-255 to FB-80 and vice versa.\n COMPRESS   Compress ISPF/PDF EDIT command.\n CONCAT     CONCAT TSO command.\n CONT       Set continuation ISPF/PDF EDIT command.\n CONTROL    Add CONTROL statements in CLISTs ISPF/PDF EDIT command.\n CP         TSO : CP commands (VM).\n CRY        Encrypt/Decrypt ISPF/PDF EDIT command.\n CUT        Cut data lines ISPF/PDF EDIT command.\n DASCAN     Direct-access UCB's lookup routine.\n DAUNTY     Direct-access unit type routine.\n DAVALL     Direct-access volume allocation routine.\n DECONCAT   DECONCAT TSO command.\n DECRYPT    Decrypt ISPF/PDF EDIT command.\n DTSO       Display some control blocks TSO command.\n DTUR       Dsect's tables use routine (DTUSE).\n DVTYUN     Device type to unit name routine.\n DYNALL     Dynamic data-set allocation routine.\n DYNCC      Dynamic concatenation-deconcatenation routine.\n EDITH      Edit Header routine.\n EDITMACS   List of additional local ISPF/PDF EDIT commands.\n EDMODE     Verify and set Edit modes ISPF/PDF EDIT command.\n EDVIO      ISPF Edit in a VIO data-set.\n1   17.11.94                                            DOC - Page 4/6.\n\n ---------  ----------------------------------------------------------\n   Name       Function\n ---------  ----------------------------------------------------------\n\n ENCRYPT    Encrypt ISPF/PDF EDIT command.\n EOL        Position cursor at end line ISPF/PDF EDIT command.\n ERASE      Terminal erase screen routine (TSO command).\n EURACFT    RACF data-set access test TSO command.\n EUSID      System variables CLIST TSO command.\n EUSMF      SMF variables CLIST TSO command.\n EUSUB      EURATOM Submit program.\n FC         FIND pending Edit line commands ISPF/PDF EDIT command.\n FILEINFO   FILEINFO TSO command.\n FILSPACE   FILSPACE routine.\n FINDMEM    FINDMEM routine.\n FIXJCL     FixJCL ISPF/PDF EDIT command.\n FLOWJCL    FlowJCL ISPF/PDF EDIT command.\n FSPACE     Display free extents on volume(s) TSO command.\n FSRTN      Full-screen service routines.\n GACTN      Obtain accounting number / programmer's number routine.\n GDGALLR    GDGALLR routine.\n GDGRESET   GDG Utility program.\n GETPAN     Copy an ISPF-panel ISPF/PDF EDIT command.\n GFDATE     Generate dates routines.\n GGUR       Get GROUP's USERIDs from RACF - routine.\n GPARM      Obtain parm. field routine.\n GUAR       Get USERID account from SYS1.UADS (TSO) - routine.\n ICFS       Read sequentially an ICF catalog routine.\n INSORT     Incore SORT subroutine.\n INTRDR     Allocate an internal reader TSO command.\n ISPCDSN    Data-set selection by cursor from ISPF display.\n IXTOFMT5   Indexed VTOC format-5 interface routine.\n JB         Display CPU - SRB (I/O) time.\n JOBCARD    JOBcard ISPF/PDF EDIT command.\n JOBS       Display jobs running in the system TSO command.\n KUMX       ISPF Edit macro (used with LOCK).\n LISTAX     LISTAX TSO command.\n LISTENQ    List ENQ's for a Job or Userid TSO command.\n LISTNO     List manual's members.\n LJUST      Left justify ISPF/PDF EDIT command.\n LOCK       TSO command to LOCK terminal.\n LOGALLOC   LOGALLOC TSO command.\n MOVECOLS   Move columns within data lines ISPF/PDF EDIT command.\n MREAD      Read PO-members routine.\n OPCOM      Operators Communications routine.\n PARA       Paragraph reformatter ISPF/PDF EDIT command.\n PDREAD     Read partitioned directory routine.\n PDSW       Partitioned data-set where function TSO command.\n1   17.11.94                                            DOC - Page 5/6.\n\n ---------  ----------------------------------------------------------\n   Name       Function\n ---------  ----------------------------------------------------------\n\n PEDIT      Print editing data ISPF/PDF EDIT command.\n PLREAD     Read partitioned load module routine.\n PLUG       Plug data into a range of lines ISPF/PDF EDIT command.\n PSWR       Obtain RACF password TSO command.\n RDCHK      Read tape data-check routine.\n RESUME     Restore ISPF/PDF EDIT command.\n RGROUP     Change current RACF connect group.\n RJUST      Right justify ISPF/PDF EDIT command.\n RPROT      RACF protection TSO command.\n RSVENQ     Display resources ENQ's RESERVE TSO command.\n R050A90    Encipher-Decipher routine.\n SCRSZ      Get current screen size TSO command.\n SKEL       Insert JCL skeletons ISPF/PDF EDIT command.\n SKELCHK    Identify )SEL-)ENDSEL mismatches ISPF/PDF EDIT command.\n SLINE      Set separation line ISPF/PDF EDIT command.\n SRCHRPI    Search a reply pending IDentification routine.\n SSCMD      Send a system command subroutine.\n SUM        Sum a column of numbers ISPF/PDF EDIT command.\n TRAP       Insert TSO command output ISPF/PDF EDIT command.\n TSODSN     Display data-set ENQ's TSO command.\n TSOENQ     Display data-set ENQ's conflicts TSO command.\n TXPRINT    Print routine.\n TXPUNCH    Punch routine.\n TXREAD     Read routine.\n TXSNAP     Snap Dump routine.\n UADS       List SYS1.UADS TSO command.\n UNIT       Display information about physical devices of system.\n UNITS      Display unit names of system device name table.\n UPDTMACS   Update list of additional local ISPF/PDF EDIT commands.\n USERS      Display users TSO command.\n VGPSUB     ISPF VGET-VPUT subroutine.\n VREAD      Variable read routine.\n VTOCD      VTOC direct read-write routine.\n VTOCQ      VTOC quick sequential read routine.\n VTOCS      VTOC sequential read routine.\n VTTCAM     Test TCAM or VTAM running routine.\n WAITR      Display ENQ's conflicts for a Job or Userid TSO command.\n WPC        WPC TSO command.\n XTC        Execute TSO commands and/or CLISTs.\n ZOOM       Browse JCL procedure ISPF/PDF EDIT command.\n1   17.11.94                                            DOC - Page 6/6.\n\n                     ******************************\n                     ***     I S P F  world     ***\n                     ******************************\n\n     All members names starting by PAJ... are ISPF members which allow\n you an easy way to execute many of distributed commands and functions\n (actual ISPF version at J.R.C. is 2.3.0), as i.e. :\n         PAJPALL  : display data-sets allocated to TSO user.\n         PAJPBLK  : disk block-sizes computations.\n         PAJPBUMU : broadcast user messages unload.\n         PAJPPOF  : VTAM secondary program operator facility.\n         PAJPVQ   : GRS/ENQ display.\n     The members named CBOOK000, MBKS00, SBOOK0 and all PBOOK... are\n part of an ISPF application example giving you a facility to maintain\n a set of IBM manuals lists.\n     To install it, here follows the list of members which must be\n placed in the following ISPF target libraries :\n         1. In the ISPF Link library :\n                   Execute members PAJ$BLK1, PAJ$BLK2, PAJ$BUMU,\n                   ISPCDSN$ and CRY$.\n         2. In the ISPF Panels library :\n                   Execute member PAJ$$ICP.\n         3. In the ISPF CLISTs library :\n                   Execute member PAJ$$ICC.\n         4. In the ISPF Messages library :\n                   Execute member PAJ$$ICM.\n         5. In the ISPF Tables library :\n                   Execute member PAJ$$ICT.\n                   (members names are TMTH... and TWKD...)\n         6. In the ISPF Skeletons library :\n                   Execute member PAJ$$ICS.\n     Then modify the ISPF primary panel (ISR@PRIM) with a selection\n call to the PAJMENU panel for these \"PRIVATE\" functions. Distributed\n example panels NEW@PRIM-NEW@MENU shows how to do it with colours too.\n     Obviously, you may tailor and reorganize all these ISPF members\n as well as you need, they may give you ideas for further developments.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$PROCS": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x11\\x16\\x00\\xc5\\x00\\xc5\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T11:16:00", "lines": 197, "newlines": 197, "modlines": 0, "user": "SYSPAJA"}, "text": "//ADDPROCS JOB (........),'INSTALL  PROCEDURES',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=2\n//*----------- ADD PRODUCTS INSTALLATION PROCEDURES -------------------\n//*            ADJUSTMENTS MUST BE DONE BEFORE YOU RUN THIS JOB (SCAN\n//*            ALL \"->\" OCCURENCES AND SET RIGHT DATA-SETS NAMES).\n//* NOTES  1 - I NORMALLY USE THE ASSEMBLER H (DON'T USE ASSEMBLER F,\n//*            THERE IS A GOOD PROBABILITY TO HAVE ERRORS).\n//*        2 - ALL PROCEDURES ASSUME THE FOLLOWING UNIT NAMES :\n//*                     DU=SYSDA : DISK UNIT\n//*                     VU=VIO   : VIRTUAL UNIT\n//*        3 - THE DATA-SET NAMED \"->.TARGET.RTNLIB\" IN THE PROCEDURES\n//*            HERE BELOW IS A LIBRARY OF ROUTINES LOAD MODULES (THESE\n//*            ARE THEN USED IN LINK-EDIT INCLUDE STATEMENTS).\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//*      ASSEMBLER H PROCEDURES.                                      *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//PROCH   EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSUT2    DD DSN=->.TARGET.PROCLIB,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DATA,DLM=ZZ\n./     ADD     NAME=PAJIAS2        <------------- ASSEMBLY / 2 MACLIBS\n./     NUMBER  NEW1=100,INCR=100\n//PAJIAS2 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSS='->.SOURCE.FILE0',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSS,DISP=&DS\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJIAS3        <------------- ASSEMBLY / 3 MACLIBS\n./     NUMBER  NEW1=100,INCR=100\n//PAJIAS3 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSS='->.SOURCE.FILE0',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSS,DISP=&DS\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJIAS4        <------------- ASSEMBLY / 4 MACLIBS\n./     NUMBER  NEW1=100,INCR=100\n//PAJIAS4 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSS='->.SOURCE.FILE0',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSS,DISP=&DS\n//          DD DSN=SYS1.HASPSRC,DISP=SHR\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ENDUP\nZZ\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//*      LINK-EDIT AND MOVE/COPY PROCEDURES.                          *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//PROCL   EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSUT2    DD DSN=->.TARGET.PROCLIB,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DATA,DLM=ZZ\n./     ADD     NAME=PAJILKR        <------------- LINK-EDIT / ROUTINES\n./     NUMBER  NEW1=100,INCR=100\n//PAJILKR PROC OPT=,VU=VIO,\n//             DSR='->.TARGET.RTNLIB',DR=OLD\n//LK      EXEC PGM=HEWL,\n//             PARM='XREF,LIST&OPT',\n//             COND=(4,LT)\n//SYSLMOD   DD DSN=&DSR,DISP=&DR\n//SYSUT1    DD UNIT=&VU,SPACE=(CYL,(1,1))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&LOADSET,DISP=(OLD,DELETE,DELETE)\n//          DD DDNAME=SYSIN\n./     ADD     NAME=PAJILKA        <--------------- LINK-EDIT / LPALIB\n./     NUMBER  NEW1=100,INCR=100\n//PAJILKA PROC OPT=,VU=VIO,\n//             DSA='->.TARGET.LPALIB',DA=OLD\n//LK      EXEC PGM=HEWL,\n//             PARM='XREF,LIST&OPT',\n//             COND=(4,LT)\n//SYSLMOD   DD DSN=&DSA,DISP=&DA\n//SYSUT1    DD UNIT=&VU,SPACE=(CYL,(1,1))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&LOADSET,DISP=(OLD,DELETE,DELETE)\n//          DD DDNAME=SYSIN\n./     ADD     NAME=PAJILKL        <-------------- LINK-EDIT / LINKLIB\n./     NUMBER  NEW1=100,INCR=100\n//PAJILKL PROC OPT=,VU=VIO,\n//             DSL='->.TARGET.LINKLIB',DL=OLD,\n//             DSR='->.TARGET.RTNLIB',DR=SHR\n//LK      EXEC PGM=HEWL,\n//             PARM='XREF,LIST&OPT',\n//             COND=(4,LT)\n//SYSLMOD   DD DSN=&DSL,DISP=&DL\n//SYSADD    DD DSN=&DSR,DISP=&DR\n//SYSUT1    DD UNIT=&VU,SPACE=(CYL,(1,1))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&LOADSET,DISP=(OLD,DELETE,DELETE)\n//          DD DDNAME=SYSIN\n./     ADD     NAME=PAJILKC        <--------------- LINK-EDIT / CMDLIB\n./     NUMBER  NEW1=100,INCR=100\n//PAJILKC PROC OPT=,VU=VIO,\n//             DSC='->.TARGET.CMDLIB',DC=OLD,\n//             DSR='->.TARGET.RTNLIB',DR=SHR\n//LK      EXEC PGM=HEWL,\n//             PARM='XREF,LIST&OPT',\n//             COND=(4,LT)\n//SYSLMOD   DD DSN=&DSC,DISP=&DC\n//SYSADD    DD DSN=&DSR,DISP=&DR\n//SYSUT1    DD UNIT=&VU,SPACE=(CYL,(1,1))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&LOADSET,DISP=(OLD,DELETE,DELETE)\n//          DD DDNAME=SYSIN\n./     ADD     NAME=PAJILKI        <----------------- LINK-EDIT / ISPF\n./     NUMBER  NEW1=100,INCR=100\n//PAJILKI PROC OPT=,VU=VIO,\n//             DSL='->.ISPF.LINKLIB',DL=OLD,\n//             DSI='->.ISPF.LOADLIB',DI=SHR,\n//             DSR='->.TARGET.RTNLIB',DR=SHR\n//LK      EXEC PGM=HEWL,\n//             PARM='XREF,LIST&OPT',\n//             COND=(4,LT)\n//SYSLMOD   DD DSN=&DSL,DISP=&DL\n//SYSISP    DD DSN=&DSI,DISP=&DI\n//SYSADD    DD DSN=&DSR,DISP=&DR\n//SYSUT1    DD UNIT=&VU,SPACE=(CYL,(1,1))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&LOADSET,DISP=(OLD,DELETE,DELETE)\n//          DD DDNAME=SYSIN\n./     ADD     NAME=PAJHELP        <-------------------- MOVE TSO HELP\n./     NUMBER  NEW1=100,INCR=100\n//PAJHELP PROC MBR=,DSS='->.SOURCE.FILE0',DS=SHR,\n//             DSH='->.TARGET.HELPLIB',DH=OLD\n//HL      EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSUT2    DD DSN=&DSH,DISP=&DH\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJPROC        <------------------- MOVE PROCEDURE\n./     NUMBER  NEW1=100,INCR=100\n//PAJPROC PROC MBR=,DSS='->.SOURCE.FILE0',DS=SHR,\n//             DSP='->.TARGET.PROCLIB',DP=OLD\n//PR      EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSUT2    DD DSN=&DSP,DISP=&DP\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJPROV        <----------- MOVE-CONVERT PROCEDURE\n./     NUMBER  NEW1=100,INCR=100\n//PAJPROV PROC DU=SYSDA,MBR=,DSS='->.SOURCE.FILE0',DS=SHR,\n//             DSP='->.TARGET.PROCLIB',DP=OLD\n//PR      EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSUT2    DD UNIT=&DU,SPACE=(CYL,(1,1,7)),DSN=&&PASS,\n//             DCB=(RECFM=FB,BLKSIZE=3120,LRECL=80),DISP=(,PASS)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n/*\n//CV      EXEC PGM=CNVCLIST,COND=(4,LT)\n//STEPLIB   DD DSN=->.TARGET.LINKLIB,DISP=SHR              (IF NEEDED)\n//SYSUT1    DD DSN=&&PASS,DISP=(SHR,DELETE)\n//SYSUT2    DD DSN=&DSP,DISP=&DP\n//SYSPRINT  DD SYSOUT=*\n./     ADD     NAME=PAJISPF        <---------------- COPY ISPF MEMBERS\n./     NUMBER  NEW1=100,INCR=100\n//PAJISPF PROC DU=SYSDA,DST=,DT=OLD,\n//             DSS='->.SOURCE.FILE0',DS=SHR\n//CM      EXEC PGM=IEBCOPY,PARM='SIZE=100K'\n//TARGET    DD DSN=&DST,DISP=&DT\n//SOURCE    DD DSN=&DSS,DISP=&DS\n//SYSUT3    DD UNIT=&DU,SPACE=(CYL,(1,1))\n//SYSPRINT  DD SYSOUT=*\n./     ADD     NAME=PAJISPV        <-------- COPY-CONVERT ISPF MEMBERS\n./     NUMBER  NEW1=100,INCR=100\n//PAJISPV PROC DU=SYSDA,DST=,DT=OLD,\n//             DSS='->.SOURCE.FILE0',DS=SHR\n//CM      EXEC PGM=IEBCOPY,PARM='SIZE=100K'\n//TARGET    DD UNIT=&DU,SPACE=(CYL,(1,1,7)),DSN=&&PASS,\n//             DCB=(RECFM=FB,BLKSIZE=3120,LRECL=80),DISP=(,PASS)\n//SOURCE    DD DSN=&DSS,DISP=&DS\n//SYSUT3    DD UNIT=&DU,SPACE=(CYL,(1,1))\n//SYSPRINT  DD SYSOUT=*\n//CV      EXEC PGM=CNVCLIST,COND=(4,LT)\n//STEPLIB   DD DSN=->.TARGET.LINKLIB,DISP=SHR              (IF NEEDED)\n//SYSUT1    DD DSN=&&PASS,DISP=(SHR,DELETE)\n//SYSUT2    DD DSN=&DST,DISP=&DT\n//SYSPRINT  DD SYSOUT=*\n./     ENDUP\nZZ\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$AIRD": {"ttr": 784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x915\\x1f\\x00\\x915\\x1f\\x14\\x05\\x00W\\x00W\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-12-17T00:00:00", "modifydate": "1991-12-17T14:05:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           AIRD FORMAT.\n        $AIRD  &PRI=YES,&SEC=NO,&STA=NO,&R=YES,&DSECT=YES\n         AIF   ('&PRI' EQ 'YES').A\n         AIF   ('&SEC' EQ 'YES').A\n         AIF   ('&STA' EQ 'YES').A\n         MNOTE 8,'---- NONE OF PRI= OR SEC= OR STA= SELECTED ----'\n         AGO   .END\n.A       SPACE 1\n*        ACCOUNTING INFORMATION RECORD DESCRIPTION.\n*        ------------------------------------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n.* NOTE :      WHEN YOU MODIFY THE 'AUTDSECT' OR THE 'PRGDSECT',\n.* ------      TAKE CARE TO MAINTAIN EQUAL THEIR LENGTHS.\n.*\n         AIF   ('&PRI' NE 'YES').C\n         AIF   ('&DSECT' NE 'YES').B\n         SPACE 1\nAUTDSECT DSECT\n.B       SPACE 1\nAUTNPNF  EQU   25 .                NUMBER OF PROGRAMMERS NO. FIELDS.\n         SPACE 1\nAUTANO   DS    H .                 AUTHORIZATION NUMBER (- INVALID).\nAUTACNO  DS    CL10 .              ACTIVITY/CONTRACT NUMBER.\n         DS    XL8 .               UNUSED (RESERVED).\nAUTPI    DS    XL1 .               PRIORITY INCREMENT (IEFUJV USE).\nAUTVSD   DS    XL3 .               VALIDITY START (YYYYDDD IN BINARY).\n         DS    XL1 .               UNUSED (RESERVED).\nAUTVED   DS    XL3 .               VALIDITY END (YYYYDDD IN BINARY).\nAUTPMNO  DS    H .                 PROJECT MANAGER NO. (NEVER SET -).\nAUTTA    DS    4H .                TIME ACCOUNT. (NOT USED)\nAUTPNO   DS    (AUTNPNF)H .        PROGRAMMERS NO. ... (- INVALID).\n         SPACE 1\n         DS    0H .                HALFWORD BOUNDARY.\nAUTLGTH  EQU   *-AUTDSECT .        RECORD LENGTH.\n.C       AIF   ('&SEC' NE 'YES').E\n         AIF   ('&DSECT' NE 'YES').D\n         SPACE 1\nPRGDSECT DSECT\n.D       SPACE 1\nPRGPNO   DS    H .                 PROGRAMMER'S NUMBER (- INVALID).\nPRGMNO   DS    CL6 .               MATRICULE NUMBER.\n         DS    XL2 .               UNUSED (RESERVED).\nPRGBXNO  DS    CL3 .               BOX NUMBER.\nPRGPNME  DS    CL40 .              PROGRAMMER'S NAME.\nPRGBDNO  DS    CL6 .               BUILDING NUMBER.\nPRGPHNO  DS    CL9 .               PHONE NUMBER.\nPRGSVNO  DS    CL8 .               SERVICE NUMBER.\n         DS    XL12 .              UNUSED.\n         SPACE 1\n         DS    0H .                HALFWORD BOUNDARY.\nPRGLGTH  EQU   *-PRGDSECT .        RECORD LENGTH.\n.E       AIF   ('&STA' NE 'YES').G\n         AIF   ('&DSECT' NE 'YES').F\n         SPACE 1\nSTADSECT DSECT\n.F       SPACE 1\nSTANAUT  DS    F .                 CAPACITIES - NUMBER OF AUT.\nSTANPRG  DS    F .                              NUMBER OF PRG.\nSTANARG  DS    F .                              NUMBER OF ARG.\nSTANATB  DS    F .                              NUMBER OF ARG. TB REC.\nSTANMTB  DS    F .                              NUMBER OF MAP TB REC.\nSTATOTL  DS    F .                 TOTAL NUMBER OF RECORDS.\nSTAUAUT  DS    F .                 NUMBER OF USED AUT. RECORDS.\nSTAUPRG  DS    F .                 NUMBER OF USED PRG. RECORDS.\nSTAUARG  DS    F .                 NUMBER OF USED ARG. RECORDS.\nSTADSNM  DS    CL44 .              CURRENT DATA-SET NAME.\nSTAVLSR  DS    CL6 .               CURRENT DATA-SET VOLUME SERIAL.\nSTADSOR  DS    CL2 .               CURRENT DATA-SET ORGANIZATION.\nSTARECL  DS    H .                 CURRENT DATA-SET RECORD LENGTH.\n         SPACE 1\nSTALGTH  EQU   *-STADSECT .        RECORD LENGTH.\n.G       AIF   ('&DSECT' NE 'YES').H\n         AIF   ('&R' EQ 'NO').H\n         SPACE 1\n&SYSECT  CSECT  .                  RESTORE ORIGINAL CSECT.\n.H       SPACE 1\n*        AUTHORIZATIONS/PROGRAMMERS NUMBERS LIMITS.\n         SPACE 1\nNAUTNO   EQU   9999                AUT.NO. FROM 1 TO 9999.\nNPRGNO   EQU   9999                PRG.NO. FROM 1 TO 9999.\n.END     SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CATSC": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL CATSC SUPPLY.\n&NAME   $CATSC      &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $CATSC MACRO : CALL CATSC SUPPLY (SEE CATS).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(CATSC)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(CATSC)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(CATSC)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CATSO": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL CATSO SUPPLY.\n&NAME   $CATSO      &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $CATSO MACRO : CALL CATSO SUPPLY (SEE CATS).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(CATSO)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(CATSO)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CATSR": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL CATSR SUPPLY.\n&NAME   $CATSR      &A,&B,&C,&D,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $CATSR MACRO : CALL CATSR SUPPLY (SEE CATS).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 4).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0,0)            P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(CATSR)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(CATSR)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CEPA": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x19?\\x00\\x89\\x19?\\x168\\x00t\\x00t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-07-12T00:00:00", "modifydate": "1989-07-12T16:38:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           SMF - COMMON EXIT PARAMETER AREA.\n        $CEPA       &DUMMY\n         SPACE 2\n*        ==========================\n*        COMMON EXIT PARAMETER AREA\n*        ==========================\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         SPACE 2\n*        WHEN A USER-WRITTEN EXIT ROUTINE RECEIVES CONTROL, REGISTER\n* 1 POINTS TO A LIST OF FOUR BYTE ADDRESSES. THE FIRST ENTRY IN THIS\n* LIST IS COMMON TO ALL EXIT ROUTINES EXCEPT IEFU83, IEFU84, AND\n* IEFU29. THE FIRST ENTRY POINTS TO A PARAMETER AREA THAT IS 36 BYTES\n* LONG. EACH JOB HAS ITS OWN COMMON EXIT PARAMETER AREA. NOTE THAT\n* THE FIELDS IN THIS PARAMETER AREA ARE FILLED CHRONOLOGICALLY,\n* THEREFORE, NOT ALL FIELDS ARE MEANINGFUL FOR ALL USER-WRITTEN EXIT\n* ROUTINES.\n         SPACE 2\nCEPA     DSECT             COMMON EXIT PARAMETER AREA DESCRIPTION.\n         SPACE 2\nCEPAJOBN DS    CL8 .       JOB NAME.\n         SPACE 1\nCEPATIME DS    F .         TIME, IN HUNDREDTHS OF A SECOND, READER\n*                          RECOGNIZED THE JOB CARD FOR THIS JOB.\n         SPACE 1\nCEPADATE DS    PL4 .       DATE READER RECOGNIZED THE JOB CARD FOR\n*                          THE JOB, IN THE FORM 00YYDDDF WHERE F IS\n*                          THE SIGN.\n         SPACE 1\nCEPASID  DS    CL4 .       SYSTEM IDENTIFICATION (TAKEN FROM SID\n*                          PARAMETER).\n         SPACE 1\nCEPAUSER DS    CL8 .       USER IDENTIFICATION. SMF PLACES THIS DATA\n*                          IN ALL SUBSEQUENT RECORDS FOR THIS JOB.\n*                          THIS FIELD IS INITIALIZED TO EBCDIC BLANKS\n*                          WHEN EACH JOB IS READ.\n         SPACE 1\nCEPASTPN DS    XL1 .       NUMBER OF THE STEP BEING PROCESSED.\n         EJECT\nCEPAIND  DS    XL1 .       INDICATOR OF SMF OPTIONS SELECTED BY THE\n*                          USER :\n*                            BIT  MEANING WHEN SET\n*                            ---  -----------------------------------\n*                            0-2  RESERVED.\n*                             3   DATA SET ACCOUNTING. IF ONE OF THE\n*                                 RECORDS TYPES 14, 15, 17, 18, 62,\n*                                 63, 64, 67 OR 68 IS SELECTED, THIS\n*                                 BIT IS SET ON.\n*                             4   VOLUME ACCOUNTING. RECORD TYPES 19\n*                                 OR 69 SELECTED.\n*                             5   RESERVED.\n*                             6   TYPE 17 RECORDS WILL BE WRITTEN\n*                                 FOR TEMPORARY DATA SET (REC(ALL)).\n*                             7   IF 0, BACKGROUND JOB.\n*                                 IF 1, FOREGROUND JOB.\n         SPACE 1\nCEPARES  DS    XL1 .       RESTART INDICATOR :\n*                            BIT  MEANING WHEN SET\n*                            ---  -----------------------------------\n*                             0   STEP RESTART.\n*                             1   CHECKPOINT/RESTART.\n*                             2   CONTINUE RESTART.\n*                             3   RESERVED.\n*                             4   WARM RESTART.\n*                            5-7  RESERVED.\n         SPACE 1\nCEPAJC   DS    CL1 .       JOB CLASS.\n         SPACE 1\nCEPAUCOM DS    XL4 .       USER-COMMUNICATION FIELD. THIS FIELD IS\n*                          INTENDED FOR COMMUNICATION AMONG USER-\n*                          WRITTEN EXIT ROUTINES WITHIN A UNIQUE JOB.\n*                          THE FIELD IS INITIALIZED TO ZEROS BY THE\n*                          JOB ENTRY SUBSYSTEM WHEN A JOB BEGINS\n*                          EXECUTION.\n         EJECT\n* COMMUNICATING BETWEEN EXIT ROUTINES :\n* -------------------------------------\n*\n*        USER-WRITTEN EXIT ROUTINES CAN COMMUNICATE WITH EACH OTHER,\n*        EXECUTING WITHIN THE SAME JOB, IN TWO WAYS : BY USING THE\n*        THE USER-COMMUNICATION FIELD ('CEPAUCOM') OR BY USING THE\n*        USER-IDENTIFICATION FIELD ('CEPAUSER'). BOTH OF THESE FIELDS\n*        ARE CONTAINED IN THE COMMON EXIT PARAMETER AREA, WHICH IS\n*        PASSED TO ALL USER-WRITTEN EXIT ROUTINES EXCEPT 'IEFU83',\n*        'IEFU84' AND 'IEFU29'. EITHER DATA OR THE ADDRESS OF A DATA\n*        AREA CAN BE PLACED IN THE COMMUNICATION FIELD. HOWEVER,\n*        PASSING THE ADDRESS OF A DATA AREA CAN CAUSE A PROBLEM.\n*        FOR EXAMPLE, ASSUME THE USER EXIT 'IEFUJV' RUNS ON THE GLOBAL\n*        PROCESSOR WITH JES3. THE EXIT ISSUES A GETMAIN, AND STORES\n*        THE ADDRESS OF THE DATA AREA IN THE USER COMMUNICATION FIELD.\n*        UNLESS THE RELATED JOB RUNS ON THE SAME PROCESSOR, IT WILL\n*        TERMINATE ABNORMALLY. THE SAME PROBLEM CAN OCCUR IF A SYSTEM\n*        RESTART OCCURS AFTER 'IEFUJV' SETS THE ADDRESS BUT BEFORE THE\n*        RELATED JOB TRIES TO USE THE ADDRESS. ADDITIONALLY, JOBS THAT\n*        ARE REQUEUED FOR EXECUTION OR WARM START THROUGH THE $E\n*        COMMAND ALSO CONTAIN INVALID DATA.\n         SPACE 2\n* IBM REFERENCE MANUAL : SYSTEM MANAGEMENT FACILITIES (SMF).\n* ----------------------\n         AIF   ('&SYSECT' EQ 'IEFUJV').SKIP\n         SPACE 1\n* USER-COMMUNICATION FIELD USE DESCRIPTION :\n* ------------------------------------------\n*\n* CEPAUCOM +0-1 - NOT USED.\n*          +2-3 - JOB I/O REQUEST IN 1/1000 :\n*                 0 (X'0000') = NO I/O NUMBER LIMIT,\n*                 2 HOURS IN SEC. (X'1C20') = MAXIMUM.\n.SKIP    SPACE 2\n&SYSECT  CSECT  .                  RESTORE ORIGINAL CSECT.\n         SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CRS": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x12O\\x00\\x95\\x12O\\x11 \\x002\\x002\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-05-04T00:00:00", "modifydate": "1995-05-04T11:20:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL CURESTA SUPPLY.\n&NAME   $CRS   &ID,&GO,&DEBUG\n         LCLA  &Y\n         LCLC  &X\n.*\n.* $CRS MACRO : CALL CURESTA SUPPLY (SEE CURESTA).\n.* ------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&NAME    XR    1,1                 NO PARM. LIST.\n         L     15,=V(CURESTA)      LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         AIF   (N'&SYSLIST EQ 0).Z\n         AIF   ('&GO' EQ '').A2\n         AIF   ('&GO'(1,1) EQ '(').A1\n         B     &GO\n         AGO   .B1\n.A1      ANOP\n&Y       SETA  K'&GO-2\n&X       SETC  '&GO'(2,&Y)\n         BR    &X\n         AGO   .B1\n.A2      ANOP\n&Y       SETA  0\n         AIF   ('&DEBUG' EQ '').A3\n&Y       SETA  6\n         AIF   ('&DEBUG' EQ 'DEBUG').A3\n         AIF   ('&DEBUG' NE 'D').INV\n&Y       SETA  2\n.A3      AIF   ('&ID' EQ '').A4\n&Y       SETA  &Y+2\n.A4      B     *+L'*+&Y\n.B1      AIF   ('&DEBUG' EQ '').B3\n         AIF   ('&DEBUG' NE 'DEBUG').B2\n         DC    AL1(5),CL5'DEBUG'\n         AGO   .B3\n.B2      AIF   ('&DEBUG' NE 'D').INV\n         DC    AL1(1),CL1'D'\n.B3      AIF   ('&ID' EQ '').Z\n         DC    AL1(255),AL1(&ID)\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.INV     MNOTE 8,' 3RD OPERAND INVALID (NOT \"D\" OR \"DEBUG\") ********* '\n.Z       MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CTLGD": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x19?\\x00\\x89\\x19?\\x168\\x01G\\x01G\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-07-12T00:00:00", "modifydate": "1989-07-12T16:38:00", "lines": 327, "newlines": 327, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           SYSCTLG ENTRY FORMATS.\n        $CTLGD     &DUMMY\n         SPACE 1\n*        O.S. CATALOG CONTROL BLOCKS DESCRIPTION.\n*        ----------------------------------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         SPACE 1\nCTLDSECT DSECT  .                  CATALOG ENTRIES DESCRIPTION.\n         SPACE 2\n*        COMMON DEFINITION TO ALL ENTRIES.\n         SPACE 1\nENAME    DS    CL8 .               NAME.\nETTR     DS    XL3 .               ADDRESS.\nETYPE    DS    XL1 .               TYPE.\n         SPACE 2\nELENGTH  EQU   *-CTLDSECT .        COMMON ENTRIES LENGTH.\n         SPACE 5\n         ORG   CTLDSECT .          ALIAS ENTRY (AE).\n         SPACE 1\n*        AN ALIAS ENTRY DEFINES AN ALTERNATE NAME FOR THE\n*        HIGH-LEVEL QUALIFIER OF A DATA SET NAME.\n         SPACE 1\n         DS    CL8 .               CONTAINS THE ALIAS OF THE HIGH-LEVEL\n*                                  INDEX WHOSE RELATIVE TRACK ADDRESS\n*                                  IS FOUND AT OFFSET 8 OF THIS ENTRY.\n         DS    XL3 .               CONTAINS THE RELATIVE TRACK ADDRESS\n*                                  (TTR) OF THE FIRST BLOCK OF THE\n*                                  INDEX NAMED AT OFFSET 12 OF THIS\n*                                  ENTRY.\n         DC    XL1'04' .           INDICATES THAT THIS IS AN ALIAS\n*                                  ENTRY, ALSO THAT FOUR HALFWORDS\n*                                  FOLLOW IN THE REMAINDER OF THE\n*                                  ENTRY.\nETRUEN   DS    CL8 .               TRUE NAME - CONTAINS THE NAME OF THE\n*                                  INDEX WHOSE ALIAS APPEARS AT THE\n*                                  BEGINNING OF THIS ENTRY.\n         EJECT\n         ORG   CTLDSECT .          CONTROL VOLUME POINTER ENTRY (CVPE).\n         SPACE 1\n*        A CONTROL VOLUME POINTER ENTRY CAN APPEAR ONLY IN\n*        VOLUME INDEXES. TWO FORMS ARE POSSIBLE, THE OLD FORM,\n*        CREATED PRIOR TO RELEASE 17, AND THE NEW FORM, CREATED\n*        SINCE RELEASE 17. BOTH FORMS ARE SHOWN HERE.\n         SPACE 1\n*                        OLD CVOL POINTER ENTRY.\n         DS    CL8 .               CONTAINS A HIGH-LEVEL NAME THAT\n*                                  APPEARS IN THE VOLUME INDEX OF THE\n*                                  CONTROL VOLUME IDENTIFIED AT OFFSET\n*                                  12 OF THIS ENTRY.\n         DC    XL3'00' .           ZERO FIELD.\n         DC    XL1'03' .           INDICATES THAT THIS IS EITHER AN OLD\n*                                  CVOL POINTER ENTRY (CVPE), OR AN\n*                                  INDEX CONTROL ENTRY (ICE). AN ICE\n*                                  ALWAYS APPEARS AS THE FIRST RECORD\n*                                  OF AN INDEX LEVEL, A CVOL POINTER\n*                                  ENTRY ALWAYS APPEARS IN THE VOLUME\n*                                  INDEX. THIS IS ALSO THE NUMBER OF\n*                                  HALFWORDS THAT FOLLOW IN THE\n*                                  REMAINDER OF THE ENTRY.\nEVOLIDO  DS    CL6 .               SERIAL NUMBER OF THE CONTROL VOLUME\n*                                  WHOSE VOLUME INDEX CONTAINS AN ENTRY\n*                                  FOR THE NAME FOUND AT THE BEGINNING\n*                                  OF THIS ENTRY.\n         SPACE 1\n         ORG   CTLDSECT .          CONTROL VOLUME POINTER ENTRY (CVPE).\n         SPACE 1\n*                        NEW CVOL POINTER ENTRY.\n         DS    CL8 .               CONTAINS A HIGH-LEVEL NAME THAT\n*                                  APPEARS IN THE VOLUME INDEX OF THE\n*                                  CONTROL VOLUME IDENTIFIED AT OFFSET\n*                                  12 OF THIS ENTRY.\n         DC    XL3'00' .           ZERO FIELD.\n         DC    XL1'05' .           INDICATES THAT THIS IS A NEW CVOL\n*                                  POINTER (CVPE) OR THE VOLUME INDEX\n*                                  CONTROL ENTRY. THE VOLUME INDEX\n*                                  CONTROL ENTRY ALWAYS APPEARS AS THE\n*                                  FIRST ENTRY IN THE FIRST BLOCK OF\n*                                  SYSCTLG. A CVOL POINTER NEVER\n*                                  APPEARS AS THE FIRST ENTRY OF THE\n*                                  FIRST BLOCK. ALSO INDICATES THAT\n*                                  FIVE HALFWORDS FOLLOW IN THE\n*                                  REMAINDER OF THE ENTRY.\nEDEVTYP  DS    XL4 .               CONTAINS THE BINARY DEVICE CODE OF\n*                                  THE CONTROL VOLUME WHOSE VOLUME\n*                                  INDEX CONTAINS AN ENTRY FOR THE NAME\n*                                  FOUND AT THE BEGINNING OF THIS\n*                                  ENTRY.\nEVOLID   DS    CL6 .               SERIAL NUMBER OF THE CONTROL VOLUME\n*                                  WHOSE VOLUME INDEX CONTAINS AN ENTRY\n*                                  FOR THE NAME FOUND AT THE BEGINNING\n*                                  OF THIS ENTRY.\n         EJECT\n         ORG   CTLDSECT .          DATA SET POINTER ENTRY (DSPE).\n         SPACE 1\n*        A DATA SET POINTER ENTRY CAN APPEAR IN ANY INDEX LEVEL.\n*        IT CONTAINS THE SIMPLE NAME OF A DATA SET AND FROM\n*        ONE TO FIVE 12-BYTE FIELDS THAT EACH IDENTIFY A VOLUME\n*        ON WHICH THE NAMED DATA SET RESIDES.\n         SPACE 1\n         DS    CL8 .               CONTAINS THE SIMPLE NAME OF THE DATA\n*                                  SET WHOSE VOLUMES ARE IDENTIFIED AT\n*                                  OFFSET 12 OF THIS ENTRY.\nEDSCBTTR DS    XL3 .               CONTAINS EITHER BINARY ZERO OR, WHEN\n*                                  THE DATA SET RESIDES ON ONLY ONE\n*                                  VOLUME, THE RELATIVE TRACK ADDRESS\n*                                  (TTR) OF THE DATA SET CONTROL BLOCK\n*                                  (DSCB) FOR THIS DATA SET IN THE\n*                                  VOLUME TABLE OF CONTENTS (VTOC).\n         DC    0XL1'07' .          INDICATES THAT THIS IS A DATA SET\n         DC    0XL1'0D' .          POINTER ENTRY (DSPE). ALSO INDICATES\n         DC    0XL1'13' .          THE NUMBER OF HALFWORDS THAT FOLLOW\n         DC    0XL1'19' .          IN THE REMAINDER OF THIS ENTRY.\n         DC    XL1'1F'\nEVOLCNT  DS    XL2 .               CONTAINS THE BINARY COUNT OF THE\n*                                  NUMBER OF VOLUMES IDENTIFIED\n*                                  BEGINNING AT OFFSET 14.\nEDATA    DS    5XL12 .             CONTAINS FROM ONE TO FIVE 12-BYTE\n*                                  ENTRIES, EACH OF WHICH IDENTIFIES\n*                                  ONE VOLUME ON WHICH THE DATA SET\n*                                  RESIDES. CATALOG MANAGEMENT NEITHER\n*                                  USES NOR CHECKS THE CONTENTS OF THIS\n*                                  FIELD.\n         EJECT\n         ORG   CTLDSECT .          GENERATION INDEX PTR ENTRY (GIPE).\n         SPACE 1\n*        A GENERATION INDEX POINTER ENTRY CAN APPEAR IN ANY\n*        INDEX EXCEPT A GENERATION INDEX. IT CORRESPONDS TO THE\n*        SIMPLE NAME USED IN THE RELATIVE NAME FOR A GDG DATA SET.\n         SPACE 1\n         DS    CL8 .               CONTAINS THE NAME OF THE GENERATION\n*                                  INDEX TO WHICH THIS ENTRY POINTS.\n         DS    XL3 .               CONTAINS THE RELATIVE TRACK ADDRESS\n*                                  OF THE FIRST BLOCK OF THE GENERATION\n*                                  INDEX NAMED IN THIS ENTRY, IN THE\n*                                  FORM TTR.\n         DC    XL1'02' .           INDICATES THAT THIS IS A GENERATION\n*                                  INDEX POINTER ENTRY (GIPE). ALSO\n*                                  INDICATES THAT TWO HALFWORDS FOLLOW\n*                                  IN THE REMAINDER OF THIS ENTRY.\nEGFLAGS  DS    XL1 .               CONTAINS THE OPTIONS SPECIFIED BY\n*                                  THE CREATOR OF THE GENERATION DATA\n*                                  GROUP.\nGIPEDEL  EQU   X'02' .             DELETE OPTION.\nGIPEEMP  EQU   X'01' .             EMPTY OPTION.\nEGMAXSIZ DS    XL1 .               CONTAINS A BINARY NUMBER SPECIFYING\n*                                  THE MAXIMUM NUMBER OF GENERATIONS\n*                                  ALLOWED IN THE GENERATION INDEX AT\n*                                  ONE TIME.\nEGCURSIZ DS    XL2 .               CONTAINS THE BINARY NUMBER OF\n*                                  GENERATIONS CURRENTLY CATALOGED IN\n*                                  THE INDEX.\n         EJECT\n         ORG   CTLDSECT .          INDEX CONTROL ENTRY (ICE).\n         SPACE 1\n*        THE INDEX CONTROL ENTRY IS THE FIRST ENTRY IN ALL\n*        INDEXES EXCEPT THE VOLUME INDEX.\n         SPACE 1\nINAME    DS    0XL8 .              LOW VALUE OF BINARY ONE ENSURES THAT\n         DC    7X'00',X'01' .      THIS IS THE FIRST ENTRY IN THE\n*                                  INDEX.\nILSTBLK  DS    XL3 .               CONTAINS THE RELATIVE TRACK ADDRESS\n*                                  OF THE LAST BLOCK ASSIGNED TO THE\n*                                  INDEX, IN THE FORM TTR.\nITYPE    DC    XL1'03' .           INDICATES THAT THIS IS EITHER AN ICE\n*                                  OR AN OLD CVOL POINTER. AN ICE\n*                                  ALWAYS APPEARS AS THE FIRST ENTRY OF\n*                                  AN INDEX. AN OLD CVOL POINTER ALWAYS\n*                                  APPEARS IN THE VOLUME INDEX. ALSO\n*                                  INDICATES THE NUMBER OF HALFWORDS\n*                                  THAT FOLLOW IN THE REMAINDER OF THE\n*                                  ENTRY.\nIFSTBLK  DS    XL3 .               CONTAINS THE RELATIVE ADDRESS OF THE\n*                                  BLOCK IN WHICH THIS ENTRY APPEARS,\n*                                  IN THE FORM TTR.\nILIASCNT DS    XL1 .               CONTAINS A BINARY COUNT OF ALIASES\n*                                  ASSIGNED TO THE INDEX. THIS COUNT IS\n*                                  ALWAYS ZERO FOR INDEXES THAT ARE NOT\n*                                  HIGH-LEVEL. AN INDEX CANNOT BE\n*                                  DELETED IF THIS COUNT IS NON-ZERO.\n         DS    XL2 .               RESERVED.\n         EJECT\n         ORG   CTLDSECT .          INDEX LINK ENTRY (ILE).\n         SPACE 1\n*        AN INDEX LINK ENTRY IS ALWAYS THE LAST ENTRY IN ANY\n*        INDEX BLOCK. IT IS USED TO LINK BLOCKS OF ONE INDEX\n*        INTO A CHAIN.\n         SPACE 1\n         DC    0XL8'00',8X'FF' .   HIGH VALUE (ALL BITS ON) ENSURES\n*                                  THAT THIS IS THE LAST ENTRY IN THE\n*                                  INDEX.\n         DS    XL3 .               CONTAINS THE RELATIVE TRACK ADDRESS\n*                                  OF THE NEXT BLOCK OF THE SAME INDEX,\n*                                  IF THERE IS ONE, IN THE FORM TTR.\n*                                  WHEN THIS IS THE LAST (OR ONLY)\n*                                  BLOCK, THIS FIELD CONTAINS BINARY\n*                                  ZERO.\n         DC    XL1'00' .           INDICATES THAT THIS IS EITHER AN ILE\n*                                  OR AN IPE. THE NAME FIELD OF AN ILE\n*                                  ALWAYS CONTAINS X'FF...FF', THE NAME\n*                                  FIELD OF AN IPE NEVER DOES. ALSO\n*                                  INDICATES THAT THERE ARE NO MORE\n*                                  HALFWORDS IN THE ENTRY.\n         SPACE 2\n         ORG   CTLDSECT .          INDEX POINTER ENTRY (IPE).\n         SPACE 1\n*        THE INDEX POINTER ENTRY CAN APPEAR IN ANY INDEX EXCEPT\n*        A GENERATION INDEX. IT POINTS TO A LOWER INDEX.\n         SPACE 1\n         DS    CL8 .               CONTAINS THE NAME OF THE INDEX TO\n*                                  WHICH THIS ENTRY POINTS.\n         DS    XL3 .               CONTAINS THE RELATIVE TRACK ADDRESS\n*                                  OF THE FIRST BLOCK OF THE INDEX\n*                                  NAMED IN THIS ENTRY, IN THE FORM\n*                                  TTR.\n         DC    XL1'00' .           INDICATES THAT THIS IS EITHER AN IPE\n*                                  OR AN ILE. THE NAME FIELD OF AN ILE\n*                                  ALWAYS CONTAINS X'FF...FF', THE NAME\n*                                  FIELD OF AN IPE NEVER DOES. ALSO\n*                                  INDICATES THAT THERE ARE NO MORE\n*                                  BYTES IN THE ENTRY.\n         EJECT\n         ORG   CTLDSECT .          VOLUME CONTROL BLOCK (VCB).\n         SPACE 1\n*        A VOLUME LIST CAN BE RECORDED IN ONE OR MORE VOLUME\n*        CONTROL BLOCKS. EACH VOLUME CONTROL BLOCK IS ONE BLOCK\n*        OF THE SYSCTLG DATA SET, AND CAN IDENTIFY UP TO 20\n*        VOLUMES ON WHICH ONE DATA SET IS RECORDED.\n         SPACE 1\n* NOTE - THIS BLOCK IS DIFFERENT FROM OTHER BLOCKS OF SYSCTLG.\n*        THE FIRST HALFWORD DOES NOT CONTAIN THE NUMBER OF BYTES\n*        USED IN THE BLOCK AS DO OTHER SYSCTLG BLOCKS. THE FIELD\n*        VCBVOLCT, SHOWN BELOW, IS THE FIRST HALFWORD OF THE\n*        VCB BLOCK.\n         SPACE 1\nVCBVOLCT DS    XL2 .               CONTAINS THE NUMBER OF VOLUMES\n*                                  IDENTIFIED IN THIS AND SUBSEQUENT\n*                                  VOLUME CONTROL BLOCKS. THIS NUMBER\n*                                  IS REDUCED BY 20 FOR EACH SUBSEQUENT\n*                                  VOLUME CONTROL BLOCK. FOR EXAMPLE,\n*                                  IF A DATA SET RESIDES ON 61 VOLUMES,\n*                                  IT USES FOUR VOLUME CONTROL BLOCKS.\n*                                  THIS FIELD OF EACH BLOCK CONTAINS\n*                                  61, 41, 21 AND 1, RESPECTIVELY.\nVCBVOLS  DS    20XL12 .            CONTAINS FROM 1 TO 20 12-BYTE\n*                                  ENTRIES, EACH OF WHICH IDENTIFIES\n*                                  ONE OF THE VOLUMES ON WHICH THE DATA\n*                                  SET RESIDES. CATALOG MANAGEMENT\n*                                  NEITHER USES NOR INSPECTS THE\n*                                  CONTENT OF THESE ENTRIES. EACH\n*                                  12-BYTE ENTRY CONTAINS A 4-BYTE\n*                                  DEVICE CODE, A 6-BYTE VOLUME SERIAL\n*                                  NUMBER, AND A 2-BYTE DATA SET\n*                                  SEQUENCE NUMBER.\n         DC    XL10'00' .          ZERO FIELD.\n         DS    XL3 .               CONTAINS THE RELATIVE TRACK ADDRESS\n*                                  OF THE NEXT VOLUME CONTROL BLOCK, IF\n*                                  THERE IS ONE, IN THE FORM TTR. IF\n*                                  THIS IS THE LAST (OR ONLY) BLOCK OF\n*                                  THE VOLUME CONTROL BLOCK, THIS FIELD\n*                                  CONTAINS BINARY ZERO.\n         DC    XL1'00' .           ZERO FIELD.\n         EJECT\n         ORG   CTLDSECT .          VOLUME CTR BLOCK PTR ENTRY (VCBPE).\n         SPACE 1\n*        A VOLUME CONTROL BLOCK POINTER ENTRY CAN APPEAR IN ANY\n*        INDEX. IT IS USED WHEN A DATA SET RESIDES ON MORE\n*        THAN FIVE VOLUMES.\n         SPACE 1\n         DS    CL8 .               CONTAINS THE SIMPLE NAME OF THE\n*                                  DATA SET WHOSE VOLUMES ARE\n*                                  IDENTIFIED IN THE VOLUME CONTROL\n*                                  BLOCK THAT IS POINTED TO BY THIS\n*                                  ENTRY.\n         DS    XL3 .               CONTAINS THE RELATIVE TRACK ADDRESS\n*                                  OF THE VOLUME CONTROL BLOCK\n*                                  IDENTIFIYING THE VOLUMES CONTAINING\n*                                  THE DATA SET NAMED IN THIS ENTRY,\n*                                  IN THE FORM TTR.\n         DC    XL1'01' .           INDICATES THAT THIS IS A VOLUME\n*                                  CONTROL BLOCK POINTER ENTRY. ALSO\n*                                  INDICATES THAT ONE HALFWORD FOLLOWS\n*                                  IN THE REMAINDER OF THIS ENTRY.\n         DC    XL2'00' .           ZERO FIELD.\n         EJECT\n         ORG   CTLDSECT .          VOLUME INDEX CONTROL ENTRY (VICE).\n         SPACE 1\n*        THE VOLUME INDEX CONTROL ENTRY IS ALWAYS THE FIRST\n*        ENTRY IN THE FIRST BLOCK OF DATA SET SYSCTLG.\n*        IT IS THE CONTROL RECORD FOR THE ENTIRE DATA SET, AND\n*        ACTS AS AN ICE FOR THE VOLUME INDEX.\n         SPACE 1\nVNAME    DS    0XL8 .              ALWAYS CONTAINS A BINARY ONE TO\n         DC    7X'00',X'01' .      ENSURE THAT THIS IS THE FIRST ENTRY\n*                                  OF THE VOLUME INDEX.\nVLSTBLK  DS    XL3 .               CONTAINS THE RELATIVE TRACK ADDRESS\n*                                  OF THE LAST BLOCK OF THE VOLUME\n*                                  INDEX, IN THE FORM TTR.\nVTYPE    DC    XL1'05' .           INDICATES THAT THIS IS THE VOLUME\n*                                  INDEX CONTROL ENTRY OR A NEW CVOL\n*                                  POINTER ENTRY. THE VOLUME INDEX\n*                                  CONTROL ENTRY IS ALWAYS THE FIRST\n*                                  ENTRY OF THE FIRST BLOCK OF SYSCTLG,\n*                                  A CVOL POINTER IS NEVER THE FIRST\n*                                  ENTRY. ALSO INDICATES THAT FIVE\n*                                  HALFWORDS FOLLOW IN THE REMAINDER\n*                                  OF THE ENTRY.\nVCLSTBLK DS    0XL3 .              CONTAINS THE RELATIVE TRACK ADDRESS\n         DS    XL2 .               OF THE LAST BLOCK IN SYSCTLG, IN THE\n*                                  FORM TTR.\nVHIREC   DS    XL1 .               RECORD NUMBER OF TTR IN VCLSTBLK.\n*                                  NOTE THAT THIS FIELD IS THE LAST\n*                                  BYTE OF VCLSTBLK (OFFSET 12).\n         DC    XL1'00' .           ZERO FIELD.\nVFHOLE   DS    XL3 .               CONTAINS THE RELATIVE TRACK ADDRESS\n*                                  OF THE FIRST UNUSED BLOCK IN\n*                                  SYSCTLG, IN THE FORM TTR.\n         DC    XL1'00' .           ZERO FIELD.\n         DS    XL2 .               RESERVED.\n         SPACE 2\n&SYSECT  CSECT  .                  RESTORE ORIGINAL CSECT.\n         SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DARSCA": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL DARSCA SUPPLY.\n&NAME   $DARSCA     &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $DARSCA MACRO : CALL DARSCA SUPPLY (SEE DASCAN).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(DARSCA)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(DARSCA)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DASCAN": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL DASCAN SUPPLY.\n&NAME   $DASCAN     &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $DASCAN MACRO : CALL DASCAN SUPPLY (SEE DASCAN).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(DASCAN)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(DASCAN)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DAUNTY": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL DAUNTY SUPPLY.\n&NAME   $DAUNTY     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $DAUNTY MACRO : CALL DAUNTY SUPPLY (SEE DAUNTY).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 2).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 2).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(DAUNTY)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(DAUNTY)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DAVALL": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x85\\x00\\x85\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 133, "newlines": 133, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL DAVALL SUPPLY.\n&NAME   $DAVALL     &A,&B,&C,&D,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $DAVALL MACRO : CALL DAVALL SUPPLY (SEE DAVALL).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 4).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 3).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0,0)            P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 3).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(DAVALL)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 3).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n         AIF   (T'&C EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(DAVALL)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DAVFR": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL DAVFR SUPPLY.\n&NAME   $DAVFR      &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $DAVFR MACRO : CALL DAVFR SUPPLY (SEE DAVALL).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(DAVFR)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(DAVFR)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DEFREG": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x13\\x1f\\x00\\x87\\x13\\x1f\\x15\\x06\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-05-11T00:00:00", "modifydate": "1987-05-11T15:06:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           DEFINE REGISTERS.\n        $DEFREG     &DUMMY\n         SPACE 1\n         GBLA  &REGS     SEE YREGS MACRO IN SYS1.MACLIB.\n         AIF   (&REGS).END\n&REGS    SETA  1\n*                        ABSOLUTE REGISTERS DEFINITION.\n*                        ------------------------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DEFREG@": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x12\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:12:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      $DEFREG   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        REGISTERS DEFINITION.        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Assembler macro : $DEFREG\n  -----------------\n\n      This macro may be used in an assembly source in order to\n      obtain registers equates as follows :\n\n         R0       EQU   0\n         R1       EQU   1\n         R2       EQU   2\n         R3       EQU   3\n         R4       EQU   4\n         R5       EQU   5\n         R6       EQU   6\n         R7       EQU   7\n         R8       EQU   8\n         R9       EQU   9\n         R10      EQU   10\n         R11      EQU   11\n         R12      EQU   12\n         R13      EQU   13\n         R14      EQU   14\n         R15      EQU   15\n\n  Operand : none.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DVTYUN": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL DVTYUN SUPPLY.\n&NAME   $DVTYUN     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $DVTYUN MACRO : CALL DVTYUN SUPPLY (SEE DVTYUN).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 2).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 2).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(DVTYUN)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(DVTYUN)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DYNALL": {"ttr": 1794, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL DYNALL SUPPLY.\n&NAME   $DYNALL     &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $DYNALL MACRO : CALL DYNALL SUPPLY (SEE DYNALL).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(DYNALL)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(DYNALL)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DYNCC": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL DYNCC SUPPLY.\n&NAME   $DYNCC      &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $DYNCC MACRO : CALL DYNCC SUPPLY (SEE DYNCC).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(DYNCC)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(DYNCC)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DYNDC": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL DYNDC SUPPLY.\n&NAME   $DYNDC      &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $DYNDC MACRO : CALL DYNDC SUPPLY (SEE DYNCC).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(DYNDC)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(DYNDC)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DYNLIST": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x07\\x0f\\x00\\x92\\x07\\x0f\\x15\\x12\\x01\"\\x01\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-03-10T00:00:00", "modifydate": "1992-03-10T15:12:00", "lines": 290, "newlines": 290, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           DYNAMIC ALLOCATION PARM. LIST.\n        $DYNLIST    &L=YES,&R=YES\n         AIF   ('&L' NE 'NO').A\n*       $DYNLIST\n        PRINT  NOGEN\n.A       SPACE 1\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\nDYNLIST  DSECT                     DYNAMIC ALLOCATION PARM. LIST.\n         SPACE 1\n* DYNAMIC ALLOCATION PARAMETER LIST :\n* -----------------------------------\n*\n*        UNLESS OTHERWISE NOTED, THE FOLLOWING IS TRUE FOR ALL\n*        INFORMATION YOU PLACE IN THE PARAMETER LIST.\n*\n*        1.    CODING A PARAMETER IN THE PARAMETER LIST HAS THE SAME\n*              EFFECT AS CODING THE SAME PARAMETER IN A JCL DDCARD.\n*\n*        2.    IF A PARAMETER IS TO BE OMITTED, ITS CORRESPONDING\n*              FIELD SHOULD BE LEFT BLANK.\n*\n*        3.    OMITTING A PARAMETER FROM THE LIST HAS THE SAME EFFECT\n*              AS OMITTING THE SAME PARAMETER FROM A JCL DDCARD. IN\n*              PARTICULAR, IF OMITTING A PARAMETER FROM A JCL DDCARD\n*              WOULD CAUSE A DEFAULT TO BE TAKEN, THEN OMITTING THE\n*              PARAMETER FROM THE LIST WILL CAUSE THE SAME DEFAULT TO\n*              BE TAKEN.\n*\n*        4.    ALL PARAMETERS SHOULD BE LEFT JUSTIFIED AND PADDED\n*              WITH BLANKS. NUMERIC VALUES MAY CONTAIN LEADING\n*              ZEROS.\n*\n*        5.    FIELDS WITHIN THE PARAMETER LIST WILL BE UNCHANGED\n*              BY THIS MODULE.\n         EJECT\n* FIELD NAME   LENGTH      DESCRIPTION AND COMMENTS\n* ----------   ------      ------------------------------------------\n*\nDDNAME   DS    CL8         REQUIRED FOR ALL FUNCTIONS. THIS MUST BE\n*                          THE SAME AS THE DDNAME PARAMETER OF THE\n*                          ACB OR DCB THAT WILL BE USED TO PROCESS\n*                          THE DATA-SET.\n*\nDSNAME   DS    CL44        THIS FIELD MUST BE FILLED IN WITH THE\n*                          CORRECT DSNAME WHEN ALLOCATING AN EXISTING\n*                          DATA-SET OR WHEN CREATING A NEW PERMANENT\n*                          DATA-SET. WHEN ALLOCATING A NEW TEMPORARY\n*                          DATA-SET IT MAY BE LEFT BLANK OR FILLED IN\n*                          WITH AN '&&DSNAME' IN A MANNER IDENTICAL\n*                          TO REQUESTING A TEMPORARY DATA-SET IN JCL.\n*                          IF 'NULLFILE' IS USED AS A DSNAME, A DUMMY\n*                          DATA-SET IS ALLOCATED. IF THIS FIELD IS\n*                          FILLED IN WITH ALL X'00', A PREVIOUSLY\n*                          ALLOCATED DATA-SET WITH THE SAME DDNAME\n*                          WILL BE DE-ALLOCATED. THE DATA-SET NAME\n*                          SPECIFIED IN THIS FIELD MUST NOT BE A\n*                          'BACKWARD REFERENCE' (IE. MUST NOT BE\n*                          *.DDNAME, *.STEPNAME.DDNAME OR\n*                          *.STEPNAME.PROCSTEPNAME.DDNAME). THIS\n*                          FIELD SHOULD NOT CONTAIN A MEMBER NAME OR\n*                          A GENERATION NUMBER. USE THE 'DSMEMBER'\n*                          FIELD TO SPECIFY THAT INFORMATION.\n*\n*                          NOTE : WHEN ALLOCATION IS FOR A DUMMY FILE\n*                                (IE. WHEN DSNAME IS 'NULLFILE') ONLY\n*                                THE 'DDNAME', 'DSNAME', 'DSFREE' AND\n*                                DCB INFORMATION IS USED BY THIS\n*                                MODULE. ANY OTHER INFORMATION IS\n*                                IGNORED.\n*                                WHEN DE-ALLOCATION IS REQUESTED (IE.\n*                                WHEN DSNAME IS ALL X'00') ONLY THE\n*                                'DDNAME', 'DSNAME' AND 'DSUFORCE'\n*                                INFORMATION ARE USED BY THIS MODULE.\n*                                ANY OTHER INFORMATION ARE IGNORED.\n*\nDSMEMBER DS    CL8         USE THIS FIELD TO SPECIFY A MEMBER OF A\n*                          PDS OR TO SPECIFY THE GENERATION NUMBER\n*                          OF A GENERATION DATA-SET GROUP. DO NOT\n*                          USE PARENTHESES (EG. SPECIFY +1 NOT\n*                          (+1) ).\n*\nPASSWORD DS    CL8         USE THIS FIELD TO SPECIFY THE PASSWORD FOR\n*                          AN EXISTING PASSWORD PROTECTED DATA-SET.\n*                          THERE IS NO JCL EQUIVALENT FOR THIS\n*                          PARAMETER.\n         EJECT\n* FIELD NAME   LENGTH      DESCRIPTION AND COMMENTS\n* ----------   ------      ------------------------------------------\n*\nDSUFORCE DS    0CL8        THIS FIELD IS USED ONLY BY DE-ALLOCATION.\n*                          VALID VALUE IS 'FORCE' AND MEANS FREE EVEN\n*                          IF PERMANENTLY ALLOCATED.\n*\nDSSTATUS DS    CL8         THIS FIELD IS EQUIVALENT TO THE STATUS\n*                          SUBPARAMETER OF THE JCL 'DISP' PARAMETER.\n*                          VALID VALUES ARE 'NEW', 'OLD', 'SHR' AND\n*                          'MOD'.\n*\nDSNDISP  DS    CL8         THIS FIELD IS EQUIVALENT TO THE NORMAL\n*                          TERMINATION DISPOSITION SUBPARAMETER OF\n*                          THE JCL 'DISP' PARAMETER EXCEPT THAT\n*                          'PASS' MAY NOT BE SPECIFIED FOR THIS\n*                          FIELD. VALID VALUES ARE 'KEEP', 'CATLG',\n*                          'UNCATLG' AND 'DELETE'.\n*\nDSADISP  DS    CL8         THIS FIELD IS EQUIVALENT TO THE ABNORMAL\n*                          TERMINATION DISPOSITION SUBPARAMETER OF\n*                          THE JCL 'DISP' PARMETER. VALID VALUES ARE\n*                          'KEEP', 'CATLG', 'UNCATLG' AND 'DELETE'.\n*\nDSUNIT   DS    CL8         USE THIS FIELD TO SPECIFY THE UNIT\n*                          ADDRESS, GENERIC NAME OR ESOTERIC NAME.\n*                          (EG. '450', '3330-1', 'SYSDA').\n*\n$RESERV1 DS    CL8         THIS FIELD IS RESERVED FOR FUTURE USE. IT\n*                          MUST BE LEFT BLANK.\n*\nDSVOLSER DS    CL6         USE THIS FIELD TO SPECIFY THE VOLUME\n*                          SERIAL NUMBER (EG. 'FCITS6'). THIS\n*                          FIELD MAY ALSO BE SET TO ALL X'00'. IN\n*                          THAT CASE THIS MODULE WILL SET THIS FIELD\n*                          TO THE DATA-SET VOLUME SERIAL NUMBER.\n*\n$RESERV2 DS    CL40        THIS FIELD IS RESERVED FOR FUTURE USE. IT\n*                          MUST BE LEFT BLANK.\n         EJECT\n* FIELD NAME   LENGTH      DESCRIPTION AND COMMENTS\n* ----------   ------      ------------------------------------------\n*\nDSVOLREF DS    CL44        SPECIFYING A DSNAME IN THIS FIELD IS\n*                          EQUIVALENT TO CODING 'VOL=REF=DSNAME' IN\n*                          A JCL DDCARD. NOTE THAT THE VALUE GIVEN\n*                          HERE MUST ALWAYS BE A CATALOGUED DATA-SET\n*                          (IE. IT CANNOT BE A 'PASSED' DATA-SET NOR\n*                          CAN IT BE A BACKWARD REFERENCE SUCH AS\n*                          *.DDNAME, *.STEPNAME.DDNAME OR\n*                          *.STEPNAME.PROCSTEPNAME.DDNAME).\n*\n*                          NOTE THAT THE DSVOLSER AND DSVOLREF FIELDS\n*                          ARE MUTUALLY EXCLUSIVE EXCEPT WHEN\n*                          DSVOLSER HAS BEEN CODED AS ALL X'00'.\n*\nDSFREE   DS    CL8         THIS FIELD IS EQUIVALENT TO THE 'FREE'\n*                          PARAMETER OF A JCL DDCARD. VALID VALUES\n*                          ARE 'END' AND 'CLOSE'.\n*\nDSLABEL  DS    CL4         USE THIS TO SPECIFY A VALID DISK LABEL\n*                          TYPE. VALID VALUES ARE 'SL' AND 'SUL'.\n*\nDSINOUT  DS    CL4         THIS FIELD SHOULD BE CODED WHERE\n*                          'LABEL=(,,,IN)' OR 'LABEL=(,,,OUT)' WOULD\n*                          BE CODED IN A JCL DDCARD. VALID VALUES\n*                          ARE 'IN' AND 'OUT'.\n*\n$RESERV3 DS    CL16        THIS FIELD IS RESERVED FOR FUTURE USE. IT\n*                          MUST BE LEFT BLANK.\n         EJECT\n*    .... THE NEXT GROUP OF FIELDS ARE APPLICABLE TO 'NEW' DATA-SETS\n*         ONLY. INFORMATION IN THESE FIELDS WILL BE IGNORED IF THEY\n*         HAVE BEEN CODED FOR OTHER THAN 'NEW' DATA-SETS.\n*\n* FIELD NAME   LENGTH      DESCRIPTION AND COMMENTS\n* ----------   ------      ------------------------------------------\n*\nDSPWDLBL DS    CL8         SPECIFYING THIS FIELD IS EQUIVALENT TO\n*                          CODING EITHER 'LABEL=(,,PASSWORD)' OR\n*                          'LABEL=(,,NOPWREAD)' IN YOUR JCL. VALID\n*                          VALUES ARE 'PASSWORD' AND 'NOPWREAD'.\n*\nDSDATE   DS    CL12        SPECIFYING THIS FIELD IS EQUIVALENT TO\n*                          CODING EITHER 'LABEL=EXPDT=YYDDD' OR\n*                          'LABEL=RETPD=NNNN' IN YOUR JCL. VALID\n*                          VALUES ARE 'EXPDT=YYDDD' AND 'RETPD=NNNN'.\n*\nDSALLOC  DS    CL5         THIS FIELD SPECIFIES HOW SPACE IS TO BE\n*                          ALLOCATED. VALID VALUES ARE 'TRK', 'CYL'\n*                          AND 'NNNNN' WHERE THE VALUE OF 'NNNNN' IS\n*                          THE AVERAGE BLOCK LENGTH.\n*\nDSPRI    DS    CL6         THIS FIELD SPECIFIES THE PRIMARY\n*                          ALLOCATION QUANTITY.\n*\nDSSEC    DS    CL6         THIS FIELD SPECIFIES THE SECONDARY\n*                          ALLOCATION QUANTITY.\n*\nDSDIR    DS    CL5         THIS FIELD SPECIFIES THE NUMBER OF\n*                          DIRECTORY BLOCKS FOR A PDS.\n*\nDSRLSE   DS    CL8         SPECIFYING THIS PARAMETER HAS THE SAME\n*                          EFFECT AS SPECIFYING THE 'RLSE'\n*                          SUBPARAMETER OF THE JCL 'SPACE' PARAMETER.\n*                          THE VALID VALUE IS 'RLSE'.\n*\nDSCONTIG DS    CL8         SPECIFYING THIS PARAMETER HAS THE SAME\n*                          EFFECT AS SPECIFYING THE 'CONTIG'\n*                          SUBPARAMETER OF THE JCL 'SPACE' PARAMETER.\n*                          THE VALID VALUE IS 'CONTIG'.\n*\nDSROUND  DS    CL8         SPECIFYING THIS PARAMETER HAS THE SAME\n*                          EFFECT AS SPECIFYING THE 'ROUND'\n*                          SUBPARAMETER OF THE JCL 'SPACE' PARAMETER.\n*                          THE VALID VALUE IS 'ROUND'.\n*\n$RESERV4 DS    CL24        THIS FIELD IS RESERVED FOR FUTURE USE. IT\n*                          MUST BE LEFT BLANK.\n         EJECT\n*    .... EXCEPT AS NOTED, THE FOLLOWING INFORMATION IS THE SAME AS\n*         THAT CONTAINED IN THE JCL 'DCB' PARAMETER.\n*\n* FIELD NAME   LENGTH      DESCRIPTION AND COMMENTS\n* ----------   ------      ------------------------------------------\n*\nDSBLKSI  DS    CL5         BLOCK SIZE VALUE (MUST BE NUMERIC).\n*\nDSORG    DS    CL8         FOR NEW DATA-SETS, THIS FIELD SPECIFIES\n*                          THE DESIRED DATA ORGANIZATION. VALID\n*                          VALUES ARE 'DA', 'DAU', 'PO', 'POU', 'PS',\n*                          'PSU' AND 'VSAM'. EXCEPT FOR 'VSAM', THIS\n*                          FIELD IS EQUIVALENT TO THE 'DSORG' JCL\n*                          SUBPARAMETER. SPECIFYING 'VSAM' IS\n*                          EQUIVALENT TO CODING  AMP='AMORG' IN THE\n*                          DDCARD. NOTE THAT ISAM DATA-SETS MAY NOT\n*                          BE ALLOCATED NEW.\n*\n*                          FOR EXISTING DATA-SETS, THIS FIELD MAY BE\n*                          SPECIFIED AS ALL X'00'. IN THAT CASE THE\n*                          ORGANIZATION OF THE DATA-SET WILL BE\n*                          PLACED IN THIS FIELD BY THIS MODULE. THE\n*                          VALUE THAT WILL BE RETURNED WILL BE ONE OF\n*                          THE FOLLOWING: 'DA', 'DAU', 'IS', 'ISU',\n*                          'PO', 'POU', 'PS', 'PSU' OR 'VSAM'. IF\n*                          THIS MODULE CANNOT DETERMINE THE DATA-SET\n*                          ORGANIZATION, IT WILL NOT CHANGE THE\n*                          FIELD.\n*\nDSKEYLEN DS    CL3         THE DATA-SET KEYLENGTH. THE VALUE MUST BE\n*                          NUMERIC.\n*\nDSLRECL  DS    CL5         THE DATA-SET LOGICAL RECORD LENGTH. VALID\n*                          VALUES ARE THE NUMERIC VALUE FOR LRECL\n*                          AND 'X'.\n*\nDSRECFM  DS    0CL8\nDSRECFM1 DS    CL1         THE RECORD FORMAT. VALID VALUES ARE 'F',\n*                          'V' AND 'U'.\n*\nDSRECFM2 DS    CL1         SPECIFIES DATA-SET BLOCKING. THE VALID\n*                          VALUE IS 'B'.\n*\nDSRECFM3 DS    CL1         SPECIFIES STANDARD BLOCKS (IF DSRECFM1=F)\n*                          OR SPANNED RECORDS (IF DSRECFM1=V). THE\n*                          VALID VALUE IS 'S'.\n*\nDSRECFM4 DS    CL1         SPECIFIES TRACK OVERFLOW. THE VALID VALUE\n*                          IS 'T'.\n         EJECT\n* FIELD NAME   LENGTH      DESCRIPTION AND COMMENTS\n* ----------   ------      ------------------------------------------\n*\nDSRECFM5 DS    CL1         SPECIFIES THE CARRIAGE CONTROL CHARACTER.\n*                          VALID VALUES ARE 'A' AND 'M'.\n*\nDSRECFM6 DS    CL1         RESERVED FOR FUTURE USE. MUST BE BLANK.\n*\nDSRECFM7 DS    CL1         RESERVED FOR FUTURE USE. MUST BE BLANK.\n*\nDSRECFM8 DS    CL1         RESERVED FOR FUTURE USE. MUST BE BLANK.\n*\nDSDCBDS  DS    CL44        SPECIFYING A DATA-SET NAME HERE IS\n*                          EQUIVALENT TO CODING 'DCB=DSNAME' IN THE\n*                          JCL. NOTE THAT A BACKWARD REFERENCE\n*                          CANNOT BE CODED.\n*\n$RESERV5 DS    CL24        THIS FIELD IS RESERVED FOR FUTURE USE. IT\n*                          MUST BE LEFT BLANK.\n         SPACE 1\nDYNEND   EQU   *\nDYNLGTH  EQU   (((DYNEND-DYNLIST)+7)/8)*8    PARM. LIST LENGTH.\n         SPACE 1\n         AIF   ('&L' NE 'NO').B\n        PRINT  GEN\n.B       AIF   ('&R' EQ 'NO').C\n&SYSECT  CSECT  .                  RESTORE ORIGINAL CSECT.\n.C       SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$EACM": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x13\\x1f\\x00\\x87\\x13\\x1f\\x15\\x06\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-05-11T00:00:00", "modifydate": "1987-05-11T15:06:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL EURATOM AUTHORITY CONTROL MODULE SUPPLY.\n&NAME   $EACM  &A\n         LCLC  &NM\n.*\n.* $EACM MACRO : SEE EURATOM AUTHORITY CONTROL MODULE (AUTHCTL).\n.* -------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (N'&SYSLIST GT 1).BAD\n&NM      SETC  '&NAME'\n         AIF   ('&A'(1,1) EQ '(').A\n&NM      LA    1,&A\n         AGO   .B\n.A       AIF   ('&A(1)' EQ '1').C\n&NM      LR    1,&A(1,1)\n.B       ANOP\n&NM      SETC  ''\n.C       ANOP\n&NM      LINK  EP=AUTHCTL\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$EDITH": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL EDITH SUPPLY.\n&NAME   $EDITH      &A,&B,&C,&D,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $EDITH MACRO : CALL EDITH SUPPLY (SEE EDITH).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 4).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0,0)            P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(EDITH)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(EDITH)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FS": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93(\\x7f\\x00\\x93(\\x7f\\x15D\\x01\\x98\\x01\\x98\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-10-14T00:00:00", "modifydate": "1993-10-14T15:44:00", "lines": 408, "newlines": 408, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL  $FS    &CC=,&WCC=,&SBA=,&SA=,&SFE=,&MFE=,&SF=,&TEXT=,&RA=,     X\n               &SET=,&M=,&DOC=,&MF=\n         GBLA  &FSMDLN,&GMFCI\n         GBLB  &GFUSW,&GFESW,&GFISW\n         GBLC  &GFSMF,&GFSMI,&GFSOP\n.* GLOBALS USE :\n.* -------------\n.*       &FSMDLN - SCREEN SIZE : 1 - 12 X 40\n.*                               2 - 24 X 80 (DEFAULT)\n.*                               3 - 32 X 80\n.*                               4 - 43 X 80\n.*                               5 - 27 X 132\n.*       &GFUSW  - INTERNAL MACRO'S USE SWITCH : 0 - INVALID USE\n.*                                               1 - VALID USE\n.*       &GFESW  - MACRO FORMAT : 0 - LIST FORM (MF=L)\n.*                                1 - EXECUTE FORM (MF=E)\n.*       &GFISW  - MACRO FORMAT : 0 - SEE &GFESW\n.*                                1 - IMMEDIATE FORM (MF=I)\n.*       &GMFCI  - POSITION POINTER FOR IMMEDIATE FORM (MF=I)\n.*       &GFSMF  - REGISTER VALUE USED BY EXECUTE FORM (MF=E)\n.*       &GFSMI  - LABEL USED BY IMMEDIATE FORM (MF=I)\n.*       &GFSOP  - INTERNAL MACRO'S USE 3270 DISPLAY ORDER VALUE\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n         LCLA  &W\n         LCLB  &AM,&DL,&SP\n         LCLC  &LAB\n         AIF   (N'&SYSLIST EQ 0).OK\n         MNOTE 8,'--- $FS : MACRO HAS NO POSITIONAL OPERAND'\n         MEXIT\n.OK      AIF   ('&DOC' EQ '').ND\n         AIF   (N'&DOC EQ 1).SCD\n         AIF   (N'&DOC NE 2).ERD\n         AIF   ('&DOC(2)' NE 'ALL').ERD\n&AM      SETB  1\n         AIF   ('&DOC(1)' EQ 'EJECT').EJ\n         AIF   ('&DOC(1)' NE 'YES').ND\n&SP      SETB  1\n         AGO   .SPN\n.SCD     AIF   ('&DOC' EQ 'EJECT').EJ\n         AIF   ('&DOC' NE 'YES').ND\n&SP      SETB  1\n.SPN     SPACE 1\n         AGO   .DOC\n.EJ      EJECT\n.DOC     ANOP\n&DL      SETB  1\n* $FS MACRO : GENERATE FULL SCREEN 3270 DISPLAY ORDERS AND FIELDS.\n* -----------\n*\n* SKELETON : LABEL  $FS   CC=...,WCC=...,SBA=...,SA=...,SFE=...,\n* ----------              MFE=...,SF=...,TEXT=...,RA=...,SET=...,\n*                         M=...,DOC=...,MF=...\n*\n* WHERE : CC NOT CODED ----> NO COMMAND CODE\n* ------- CC=... ----------> COMMAND CODE, WHERE ... IS A KEYWORD\n*                            OPTION SELECTED IN THE FOLLOWING LIST :\n*                            W    ---> WRITE\n*                            EW   ---> ERASE/WRITE\n*                            EWA  ---> ERASE/WRITE ALTERNATE\n*                            EAU  ---> ERASE ALL UNPROTECTED\n*                            WSF  ---> WRITE STRUCTURED FIELD\n*\n*         WCC NOT CODED ---> NO WRITE CONTROL CHARACTER BYTE\n*         WCC=(...) -------> WRITE CONTROL CHARACTER BYTE, WHERE ...\n*                            IS ONE OR MORE KEYWORDS OPTION SELECTED\n*                            IN THE FOLLOWING LIST :\n*                            NE   ---> NL AND EM DETEMINES PRINT LINE\n*                            P40  ---> 40C./PRINT LINE\n*                            P64  ---> 64C./PRINT LINE\n*                            P80  ---> 80C./PRINT LINE\n*                            SP   ---> START PRINTER\n*                            AL   ---> SOUND AUDIBLE ALARM\n*                            KBR  ---> KEYBOARD RESTORE\n*                            RMDT ---> RESET MDT BITS (IT ALSO RESETS\n*                                      THE AID)\n*         WCC=CLEAR -------> GENERATE A FULL SCREEN CLEAR SEQUENCE\n*         WCC=(CLEAR,...) -> GENERATE A FULL SCREEN CLEAR SEQUENCE,\n*                            WHERE ... MAY BE ONE OR MORE KEYWORDS\n*                            OPTION SELECTED IN THE FOLLOWING LIST :\n*                            AL   ---> SOUND AUDIBLE ALARM\n*                            KBR  ---> KEYBOARD RESTORE\n*                            RMDT ---> RESET MDT BITS (IT ALSO RESETS\n*                                      THE AID)\n*         WCC=OFF ---------> GENERATE A FULL SCREEN EXIT SEQUENCE\n*         WCC=(OFF,AL) ----> GENERATE A FULL SCREEN EXIT SEQUENCE WITH\n*                            THE SOUND AUDIBLE ALARM\n         AIF   (&SP).SP1\n         EJECT\n         AGO   .EJ1\n.SP1     SPACE 1\n.EJ1     ANOP\n*         SBA NOT CODED ---> NO SET BUFFER ADDRESS\n*         SBA=(R,C) -------> ROW AND COLUMN OF SBA ADDRESS :\n*                            R ---> ROW NUMBER (SCREEN LINE)\n*                            C ---> COLUMN NUMBER (LINE POSITION)\n*\n*         SA NOT CODED ----> NO SET ATTRIBUTE ORDER\n*         SA=RESET   ------> CHARACTER ATTRIBUTE RESET\n*         SA=(...) --------> ... IS A PAIR OF \"TYPE,VALUE\" AS BELOW :\n*                            ---> (HILITE,BLINK)\n*                                 (  \"   ,REVERSE)\n*                                 (  \"   ,USCORE)\n*                                 (  \"   ,DEFAULT)\n*                            ---> (COLOUR,BLUE)\n*                                 (  \"   ,RED)\n*                                 (  \"   ,PINK)\n*                                 (  \"   ,GREEN)\n*                                 (  \"   ,TURQ)\n*                                 (  \"   ,YELLOW)\n*                                 (  \"   ,WHITE)\n*                                 (  \"   ,DEFAULT)\n*                            ---> (PGSYM,HH) / HH = HEXADECIMAL\n*                                 (  \"   ,DEFAULT)\n         AIF   (&SP).SP2\n         EJECT\n         AGO   .EJ2\n.SP2     SPACE 1\n.EJ2     ANOP\n*         SFE NOT CODED ---> NO START FIELD EXTENDED ORDER\n*         MFE NOT CODED ---> NO MODIFIED FIELD EXTENDED ORDER\n*         SFE=(...) -------> ... IS ONE OR MORE PAIR(S) OF \"TYPE,VALUE\"\n*         MFE=(...)          AS FOLLOWS :\n*                            ---> (ATTR,NORMAL)\n*                                 (  \" ,...) WHERE ... IS ONE OR\n*                                 (  \" ,(...)) WHERE (...) ARE MORE\n*                                      KEYWORDS OPTION SELECTED IN\n*                                      THE FOLLOWING LIST :\n*                            PROT ---> PROTECTED FIELD\n*                            NUM  ---> NUMERIC FIELD (CAUSE AUTOMATIC\n*                                      UPSHIFT OF DATA ENTRY KEYBOARD)\n*                            SKIP ---> AUTOMATIC SKIP FIELD (THIS IS\n*                                      OBVIOUSLY A PROTECTED FIELD)\n*                            INT  ---> INTENSIFIED DISPLAY FIELD\n*                            HIGH ---> HIGH INTENSITY DISPLAY FIELD\n*                                      (THIS IS AN ALIAS OF \"INT\")\n*                            PEN  ---> SELECTOR PEN DETECTABLE FIELD\n*                            MED  ---> MEDIUM INTENSITY DISPLAY FIELD\n*                                      (THIS IS AN ALIAS OF \"PEN\")\n*                            DARK ---> NON-DISPLAY FIELD\n*                            MDT  ---> TO IDENTIFY MODIFIED FIELDS\n*                            ---> (HILITE,BLINK)\n*                                 (  \"   ,REVERSE)\n*                                 (  \"   ,USCORE)\n*                                 (  \"   ,DEFAULT)\n*                            ---> (COLOUR,BLUE)\n*                                 (  \"   ,RED)\n*                                 (  \"   ,PINK)\n*                                 (  \"   ,GREEN)\n*                                 (  \"   ,TURQ)\n*                                 (  \"   ,YELLOW)\n*                                 (  \"   ,WHITE)\n*                                 (  \"   ,DEFAULT)\n*                            ---> (PGSYM,HH) / HH = HEXADECIMAL\n*                                 (  \"  ,DEFAULT)\n         AIF   (&SP).SP3\n         EJECT\n         AGO   .EJ3\n.SP3     SPACE 1\n.EJ3     ANOP\n*         SF NOT CODED ----> NO START FIELD. DEFAULT FIELD (SF=NORMAL)\n*                            IS ASSUMED IF CC, WCC, SBA, SA, SFE, MFE,\n*                            TEXT, RA AND SET OPERANDS ARE NOT CODED\n*         SF=NORMAL -------> NORMAL ALPHAMERIC DISPLAY\n*         SF=IC -----------> INSERT CURSOR ONLY\n*         SF=PT -----------> PROGRAM TABULATE ONLY\n*         SF=(PT,IC) ------> PROGRAM TABULATE AND INSERT CURSOR\n*         SF=(...) --------> SF WITH SPECIFIED ATTRIBUTE\n*         SF=(...,IC) -----> SF, ATTRIBUTE AND IC OR PT OR PT AND IC\n*         SF=(...,PT)        WHERE ... IS ONE OR MORE KEYWORDS OPTION\n*         SF=(...,PT,IC)     SELECTED IN THE FOLLOWING LIST :\n*                            PROT ---> PROTECTED FIELD\n*                            NUM  ---> NUMERIC FIELD (CAUSE AUTOMATIC\n*                                      UPSHIFT OF DATA ENTRY KEYBOARD)\n*                            SKIP ---> AUTOMATIC SKIP FIELD (THIS IS\n*                                      OBVIOUSLY A PROTECTED FIELD)\n*                            INT  ---> INTENSIFIED DISPLAY FIELD\n*                            HIGH ---> HIGH INTENSITY DISPLAY FIELD\n*                                      (THIS IS AN ALIAS OF \"INT\")\n*                            PEN  ---> SELECTOR PEN DETECTABLE FIELD\n*                            MED  ---> MEDIUM INTENSITY DISPLAY FIELD\n*                                      (THIS IS AN ALIAS OF \"PEN\")\n*                            DARK ---> NON-DISPLAY FIELD\n*                            MDT  ---> TO IDENTIFY MODIFIED FIELDS\n*\n*         TEXT NOT CODED --> NO TEXT FIELD\n*         TEXT='...' ------> THE DESIRED TEXT : A CHARACTERS STRING\n*                            ENCLOSED WITHIN QUOTES (IF ANY QUOTE OR\n*                            AMPERSAND NEEDED IN TEXT, DOUBLE IT)\n*         TEXT=('...',N) --> THE TEXT FOLLOWED BY THE DESIRED LENGTH.\n*                            N MUST BE AN ABSOLUTE NUMERIC TEXT LENGTH\n*                            VALUE (RANGE : 1 TO 256)\n         AIF   (&SP).SP4\n         EJECT\n         AGO   .EJ4\n.SP4     SPACE 1\n.EJ4     ANOP\n*         RA NOT CODED ----> NO REPEAT ORDER\n*         RA=(R,C,EUA) ----> ROW AND COLUMN OF EUA ADDRESS :\n*                            R  ---> ROW NUMBER (SCREEN LINE)\n*                            C  ---> COLUMN NUMBER (LINE POSITION)\n*         RA=(R,C,E) ------> ROW AND COLUMN OF RA ADDRESS :\n*         RA=(R,C,'E')       R  ---> ROW NUMBER (SCREEN LINE)\n*         RA=(R,C,HH)        C  ---> COLUMN NUMBER (LINE POSITION)\n*         RA=(R,C,GE,HH)     E  ---> IS THE REPEAT CHARACTER EXPRESSED\n*         RA=(R,C,GE,FILL)           IN EBCDIC (IF QUOTE OR AMPERSAND\n*                                    REQUESTED, DOUBLE IT OR USE THE\n*                                    HEXADECIMAL FORM)\n*                            GE ---> MEANS GRAPHIC ESCAPE CHARACTER, IT\n*                                    FOLLOWS EXPRESSED IN HEXADECIMAL\n*                            HH ---> IS THE REPEAT CHARACTER EXPRESSED\n*                                    IN HEXADECIMAL (X'40' TO X'FE')\n*                            FILL -> 00, CHARACTER STORED DYNAMICALLY\n*\n*         SET NOT CODED ---> NO SET (SPECIAL ACTION) TO DO\n*         SET=...       ---> SET AN HEXADECIMAL STRING\n*         SET=(GE,HH)   ---> SET A GRAPHIC ESCAPE\n*         SET=(GE,FILL)      GE ---> MEANS GRAPHIC ESCAPE CHARACTER, IT\n*                                    FOLLOWS EXPRESSED IN HEXADECIMAL\n*                            HH ---> IS THE CHARACTER EXPRESSED IN\n*                                    HEXADECIMAL (X'40' TO X'FE')\n*                            FILL -> 00, CHARACTER STORED DYNAMICALLY\n*\n*         M NOT CODED -----> DEFAULT M= OF PREVIOUS $FS MACRO OR M=2\n*                            IF FIRST $FS MACRO\n*         M=1 -------------> 12 X 40 SCREEN SIZE\n*         M=2 -------------> 24 X 80 SCREEN SIZE\n*         M=3 -------------> 32 X 80 SCREEN SIZE\n*         M=4 -------------> 43 X 80 SCREEN SIZE\n*         M=5 -------------> 27 X 132 SCREEN SIZE\n*\n*         DOC NOT CODED ---> NO INLINE DOCUMENTATION\n*         DOC=YES ---------> OBTAIN INLINE DOCUMENTATION\n*         DOC=EJECT -------> OBTAIN INLINE DOCUMENTATION ON PAGES\n*         DOC=(YES,ALL) ---> OBTAIN INLINE ALL DOCUMENTATION\n*         DOC=(EJECT,ALL) -> OBTAIN INLINE ALL DOCUMENTATION ON PAGES\n         AIF   (&SP).SP5\n         EJECT\n         AGO   .EJ5\n.SP5     SPACE 1\n.EJ5     ANOP\n*         MF=L ------------> GENERATE LIST FORM\n*         MF=(I,...) ------> GENERATE EXECUTE FORM, ... IS THE LABEL\n*                            OF THE STARTING ADDRESS FOR GENERATED\n*                            ORDERS AND FIELDS MOVE, SEE NOTE 3\n*         MF=(I,(...)) ----> GENERATE EXECUTE FORM, ... IS A REGISTER\n*                            WHICH CONTAIN THE STARTING ADDRESS FOR\n*                            GENERATED ORDERS AND FIELDS MOVE, SEE\n*                            NOTE 3\n*         MF=I ------------> GENERATE EXECUTE FORM USING THE LABEL OR\n*         MF=(I,)            THE REGISTER SPECIFIED IN THE MF= OPERAND\n*                            OF A PREVIOUS $FS MACRO USE, SEE NOTE 3\n*         MF=(E,...) ------> GENERATE EXECUTE FORM, ... IS THE LABEL\n*                            RX-TYPE STARTING ADDRESS FOR GENERATED\n*                            ORDERS AND FIELDS MOVE (REGISTER 1 USED),\n*                            SEE NOTE 2\n*         MF=(E,(...)) ----> GENERATE EXECUTE FORM, ... IS A REGISTER\n*                            WHICH CONTAIN THE STARTING ADDRESS FOR\n*                            GENERATED ORDERS AND FIELDS MOVE, SEE\n*                            NOTE 2\n*         MF NOT CODED ----> GENERATE EXECUTE FORM USING THE REGISTER\n*         MF=E               SPECIFIED IN THE MF= OPERAND OF A PREVIOUS\n*         MF=(E,)            $FS MACRO USE, OR ASSUME MF=(E,(1)) IF THE\n*                            FIRST $FS MACRO OCCURANCE, SEE NOTE 2\n*\n* NOTES : 1. COMBINATIONS OF ORDERS AND FIELDS ARE GENERATED IN THE\n* -------    FOLLOWING SEQUENCE :\n*            CC, WCC, SBA, SA, SFE, MFE, SF, TEXT, RA AND SET.\n*         2. WHEN USING THE EXECUTE FORM, AT END OF MACRO GENERATION\n*            THE REGISTER 1 OR THAT SPECIFIED IN THE MF= OPERAND\n*            POINTS TO THE LAST BYTE+1 ADDRESS OF THE GENERATED\n*            ORDERS AND FIELDS.\n*         3. WHEN USING THE IMMEDIATE FORM, AT END OF MACRO GENERATION\n*            THE POSITION POINTER OF THE GENERATED ORDERS AND FIELDS\n*            IS RETAINED.\n*\n* WARNING :  1. USER MUST KNOW HOW A SCREEN IS BUILDED BEFORE HE USES\n* ---------     THIS MACRO.\n*            2. BEWARE THAT THE LENGTH ATTRIBUTE OF AN EVENTUAL LABEL\n*               IS NOT NECESSARILY THE LENGTH OF ALL THE DATA (ORDERS\n*               AND FIELDS) GENERATED BY THE MACRO.\n         AIF   (&SP).SPC\n         EJECT\n         AGO   .EJA\n.SPC     SPACE 1\n.EJA     AIF   (NOT &AM).ND\n        $FSDOT DOC=(&DOC(1),SKIP)\n.ND      ANOP\n&LAB     SETC  '&LABEL'\n         AIF   ('&M' EQ '').MF\n         AIF   ('&M' EQ '1').M1\n         AIF   ('&M' EQ '2').M2\n         AIF   ('&M' EQ '3').M3\n         AIF   ('&M' EQ '4').M4\n         AIF   ('&M' EQ '5').M5\n         MNOTE 0,'--- M= INVALID - PREVIOUS M OR DEFAULT ASSUMED'\n         AGO   .MF\n.M1      ANOP\n&FSMDLN  SETA  1\n         AGO   .MF\n.M2      ANOP\n&FSMDLN  SETA  2\n         AGO   .MF\n.M3      ANOP\n&FSMDLN  SETA  3\n         AGO   .MF\n.M4      ANOP\n&FSMDLN  SETA  4\n         AGO   .MF\n.M5      ANOP\n&FSMDLN  SETA  5\n.MF      ANOP\n&GFESW   SETB  0\n&GFISW   SETB  0\n         AIF   ('&MF' EQ 'L').TDL\n         AIF   ('&MF' EQ 'I').TIM\n&GFESW   SETB  1\n         AIF   ('&MF' EQ '').PRV\n         AIF   ('&MF' EQ 'E').PRV\n         AIF   ('&MF(1)' EQ 'I').TIF\n         AIF   ('&MF(1)' NE 'E').ERM\n         AIF   ('&MF(2)' NE '').TLB\n.PRV     AIF   ('&GFSMF' NE '').TDL\n&GFSMF   SETC  '1'\n         AGO   .TDL\n.TLB     AIF   ('&MF(2)'(1,1) EQ '(').RGN\n&LAB     LA    1,&MF(2)\n&LAB     SETC  ''\n&GFSMF   SETC  '1'\n         AGO   .TDL\n.RGN     AIF   ('&MF(2)' EQ '(1)').TDL\n&W       SETA  K'&MF(2)-2\n&GFSMF   SETC  '&MF(2)'(2,&W)\n         AGO   .TDL\n.TIF     AIF   ('&MF(2)' EQ '').TIM\n&GFSMI   SETC  '&MF(2)'\n&GMFCI   SETA  0\n         AGO   .TIO\n.TIM     AIF   ('&GFSMI' EQ '').ERM\n.TIO     ANOP\n&GFISW   SETB  1\n.TDL     AIF   (NOT &DL).CC\n         AIF   ('&CC' NE '').CC\n         AIF   ('&WCC' NE '').CC\n         AIF   ('&SBA' NE '').CC\n         AIF   ('&SA' NE '').CC\n         AIF   ('&SFE' NE '').CC\n         AIF   ('&MFE' NE '').CC\n         AIF   ('&SF' NE '').CC\n         AIF   ('&TEXT' NE '').CC\n         AIF   ('&RA' NE '').CC\n         AIF   ('&SET' NE '').CC\n         MEXIT\n.CC     ANOP\n&GFUSW   SETB  1\n         AIF   ('&CC' EQ '').WCC\n&LAB    $FSCC  &CC\n&LAB     SETC  ''\n.WCC     AIF   ('&WCC' EQ '').SBA\n&LAB    $FSWCC &WCC\n&LAB     SETC  ''\n.SBA     AIF   ('&SBA' EQ '').SA\n&LAB    $FSSBA &SBA\n&LAB     SETC  ''\n.SA      AIF   ('&SA' EQ '').SFE\n&LAB    $FSSA  &SA\n&LAB     SETC  ''\n.SFE     AIF   ('&SFE' EQ '').MFE\n&GFSOP   SETC  '29'\n&LAB    $FSSFE &SFE\n&LAB     SETC  ''\n.MFE     AIF   ('&MFE' EQ '').SF\n&GFSOP   SETC  '2C'\n&LAB    $FSSFE &MFE\n&LAB     SETC  ''\n         AIF   ('&SF' EQ '').TXT\n         AGO   .SFG\n.SF      AIF   ('&SF' NE '').SFG\n         AIF   ('&CC' NE '').TXT\n         AIF   ('&WCC' NE '').TXT\n         AIF   ('&SBA' NE '').TXT\n         AIF   ('&SA' NE '').TXT\n         AIF   ('&SFE' NE '').TXT\n         AIF   ('&TEXT' NE '').TXT\n         AIF   ('&RA' NE '').RA\n         AIF   ('&SET' NE '').SET\n.SFG     ANOP\n&LAB    $FSSF  &SF\n&LAB     SETC  ''\n.TXT     AIF   ('&TEXT' EQ '').RA\n&LAB    $FSTXT &TEXT\n&LAB     SETC  ''\n.RA      AIF   ('&RA' EQ '').SET\n&LAB    $FSRA  &RA\n&LAB     SETC  ''\n.SET     AIF   ('&SET' EQ '').END\n&LAB    $FSSET &SET\n.END     ANOP\n&GFUSW   SETB  0\n         MEXIT\n.ERD     MNOTE 8,'--- DOC= INVALID CODING'\n         MEXIT\n.ERM     MNOTE 8,'--- MF= INVALID CODING'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FS$TV": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x18o\\x00\\x91\\x18o\\x11F\\x00\\xa1\\x00\\xa1\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-07-05T00:00:00", "modifydate": "1991-07-05T11:46:00", "lines": 161, "newlines": 161, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n        $FS$TV\n.*\n.* MACRO : INTERNALLY USED BY $FSSA AND $FSSFE MACROS.\n.* -------\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         GBLB  &GFWSW\n         GBLC  &GFSOP,&GFWTY,&GFWVA\n         LCLA  &ATT,&I,&L,&M1,&M2,&M3,&M4,&N\n         LCLC  &TY,&VA,&VC\n&GFWSW   SETB  0\n&N       SETA  N'&SYSLIST\n         AIF   (&N EQ 2).STV\n         MNOTE 8,'--- \"TYPE,VALUE\" : PAIR INCOMPLETE'\n         AGO   .ERX\n.STV     ANOP\n&TY      SETC  '&SYSLIST(1)'\n&VA      SETC  '&SYSLIST(2)'\n         AIF   ('&VA'(1,1) NE '(').NXT\n&L       SETA  K'&VA-2\n&VA      SETC  '&VA'(2,&L)\n.NXT     AIF   ('&TY' EQ 'HILITE').HLT\n         AIF   ('&TY' EQ 'COLOUR').CLR\n         AIF   ('&TY' EQ 'COLOR').CLR\n         AIF   ('&TY' EQ 'PGSYM').PGS\n         AIF   ('&TY' EQ 'PGRSYM').PGS\n         AIF   ('&TY' EQ 'PGMSYM').PGS\n         AIF   ('&GFSOP' EQ '28').UNK\n         AIF   ('&TY' EQ 'ATTR').ATT\n         AIF   ('&TY' EQ 'ATTRB').ATT\n.UNK     MNOTE 8,'--- TYPE : \"&TY\" UNKNOWN OR WRONGLY CODED'\n         AGO   .ERX\n.HLT     AIF   ('&VA' EQ 'BLINK').BLK\n         AIF   ('&VA' EQ 'REVERSE').RVS\n         AIF   ('&VA' EQ 'USCORE').USC\n         AIF   ('&VA' NE 'DEFAULT').IVA\n&GFWVA   SETC  '00'\n         AGO   .SHL\n.BLK     ANOP\n&GFWVA   SETC  'F1'\n         AGO   .SHL\n.RVS     ANOP\n&GFWVA   SETC  'F2'\n         AGO   .SHL\n.USC     ANOP\n&GFWVA   SETC  'F4'\n.SHL     ANOP\n&GFWTY   SETC  '41'\n         MEXIT\n.CLR     AIF   ('&VA' EQ 'BLUE').BLU\n         AIF   ('&VA' EQ 'RED').RED\n         AIF   ('&VA' EQ 'PINK').PNK\n         AIF   ('&VA' EQ 'GREEN').GRN\n         AIF   ('&VA' EQ 'TURQ').TRQ\n         AIF   ('&VA' EQ 'YELLOW').YLW\n         AIF   ('&VA' EQ 'WHITE').WHT\n         AIF   ('&VA' NE 'DEFAULT').IVA\n&GFWVA   SETC  '00'\n         AGO   .SCL\n.BLU     ANOP\n&GFWVA   SETC  'F1'\n         AGO   .SCL\n.RED     ANOP\n&GFWVA   SETC  'F2'\n         AGO   .SCL\n.PNK     ANOP\n&GFWVA   SETC  'F3'\n         AGO   .SCL\n.GRN     ANOP\n&GFWVA   SETC  'F4'\n         AGO   .SCL\n.TRQ     ANOP\n&GFWVA   SETC  'F5'\n         AGO   .SCL\n.YLW     ANOP\n&GFWVA   SETC  'F6'\n         AGO   .SCL\n.WHT     ANOP\n&GFWVA   SETC  'F7'\n.SCL     ANOP\n&GFWTY   SETC  '42'\n         MEXIT\n.PGS     AIF   ('&VA' EQ 'DEFAULT').DFL\n         AIF   (K'&VA EQ 2).HEX\n.IVA     MNOTE 8,'--- VALUE : \"&VA\" UNKNOWN OR WRONGLY CODED'\n.ERX     ANOP\n&GFWSW   SETB  1\n         MEXIT\n.HEX     ANOP\n&GFWVA   SETC  '&VA'\n         AGO   .SPG\n.DFL     ANOP\n&GFWVA   SETC  '00'\n.SPG     ANOP\n&GFWTY   SETC  '43'\n         MEXIT\n.ATT     ANOP\n&M1      SETA  0\n&M2      SETA  0\n&M3      SETA  0\n&M4      SETA  0\n         AIF   ('&VA' EQ 'NORMAL').GFA\n&N       SETA  K'&VA\n         AIF   (&N EQ 0).GFA\n&J       SETA  1\n.CNT     ANOP\n&I       SETA  &J\n.LSC     AIF   ('&VA'(&I,1) EQ ',').PRC\n&I       SETA  &I+1\n         AIF   (&I LE &N).LSC\n.PRC     ANOP\n&L       SETA  &I-&J\n         AIF   (&L EQ 0).SCAN\n&VC      SETC  '&VA'(&J,&L)\n         AIF   ('&VC' EQ 'SKIP').SKIP\n         AIF   ('&VC' EQ 'PROT').PROT\n         AIF   ('&VC' EQ 'NUM').NUM\n         AIF   ('&VC' EQ 'DARK').DARK\n         AIF   ('&VC' EQ 'INT').INT\n         AIF   ('&VC' EQ 'HIGH').INT\n         AIF   ('&VC' EQ 'PEN').PEN\n         AIF   ('&VC' EQ 'MED').PEN\n         AIF   ('&VC' EQ 'MDT').MDT\n         MNOTE 4,'--- UNKNOWN KEYWORD \"&VC\" - IGNORED'\n         AGO   .SCAN\n.SKIP    ANOP\n&M4      SETA  32\n&M3      SETA  16\n         AGO   .SCAN\n.PROT    ANOP\n&M4      SETA  32\n         AGO   .SCAN\n.NUM     ANOP\n&M3      SETA  16\n         AGO   .SCAN\n.DARK    ANOP\n&M2      SETA  12\n         AGO   .SCAN\n.INT     ANOP\n&M2      SETA  8\n         AGO   .SCAN\n.PEN     ANOP\n&M1      SETA  4\n         AGO   .SCAN\n.MDT     ANOP\n&M1      SETA  1\n.SCAN    ANOP\n&J       SETA  &I+1\n         AIF   (&J LE &N).CNT\n.GFA     ANOP\n&ATT     SETA  2*(&M1+&M2+&M3+&M4)+1\n&GFWVA   SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5X\n               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6FX\n               7F8F97A7B7C7D7E7F'(&ATT,2)\n&GFWTY   SETC  'C0'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FS@": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91!O\\x00\\x91!O\\x11A\\x01e\\x01e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-02T00:00:00", "modifydate": "1991-08-02T11:41:00", "lines": 357, "newlines": 357, "modlines": 0, "user": "SYSPAJA"}, "text": "1   19/07/91\n                                                      $FS       1/8.\n\n             -------------------------------------------\n               3 2 7 0    D I S P L A Y    M A C R O S\n             -------------------------------------------\n\n $FS      : Generate full screen 3270 display orders and fields.\n ----------\n\n  Skeleton : LABEL  $FS   CC=...,WCC=...,SBA=...,SA=...,SFE=...,\n                          MFE=...,SF=...,TEXT=...,RA=...,SET=...,\n                          M=...,DOC=...,MF=...\n\n  Where : CC not coded ----> no Command Code\n          CC=... ----------> Command Code, where ... is a keyword\n                             option selected in the following list :\n                             W    ---> write\n                             EW   ---> erase/write\n                             EWA  ---> erase/write alternate\n                             EAU  ---> erase all unprotected\n                             WSF  ---> write structured field\n\n          WCC not coded ---> no Write Control Character byte\n          WCC=(...) -------> Write Control Character byte, where ...\n                             is one or more keywords option selected\n                             in the following list :\n                             NE   ---> NL and EM determine print line\n                             P40  ---> 40c./print line\n                             P64  ---> 64c./print line\n                             P80  ---> 80c./print line\n                             SP   ---> start printer\n                             AL   ---> sound audible alarm\n                             KBR  ---> keyboard restore\n                             RMDT ---> reset MDT bits (it also resets\n                                       the AID)\n          WCC=CLEAR -------> generate a full screen clear sequence\n          WCC=(CLEAR,...) -> generate a full screen clear sequence,\n                             where ... may be one or more keywords\n                             option selected in the following list :\n                             AL   ---> sound audible alarm\n                             KBR  ---> keyboard restore\n                             RMDT ---> reset MDT bits (it also resets\n                                       the AID)\n          WCC=OFF ---------> generate a full screen exit sequence\n          WCC=(OFF,AL) ----> generate a full screen exit sequence with\n                             the sound audible alarm\n\n          SBA not coded ---> no Set Buffer Address\n          SBA=(R,C) -------> row and column of SBA address :\n                             R ---> row number (screen line)\n                             C ---> column number (line position)\n1   19/07/91\n                                                      $FS       2/8.\n\n          SA not coded ----> no Set Attribute order\n          SA=RESET   ------> Character Attribute reset\n          SA=(...) --------> ... is a pair of \"type,value\" as below :\n                             ---> (HILITE,BLINK)\n                                  (  \"   ,REVERSE)\n                                  (  \"   ,USCORE)\n                                  (  \"   ,DEFAULT)\n                             ---> (COLOUR,BLUE)\n                                  (  \"   ,RED)\n                                  (  \"   ,PINK)\n                                  (  \"   ,GREEN)\n                                  (  \"   ,TURQ)\n                                  (  \"   ,YELLOW)\n                                  (  \"   ,WHITE)\n                                  (  \"   ,DEFAULT)\n                             ---> (PGSYM,HH) / HH = hexadecimal\n                                  (  \"   ,DEFAULT)\n\n          SFE not coded ---> no Start Field Extended order\n          MFE not coded ---> no Modified Field Extended order\n          SFE=(...) -------> ... is one or more pair(s) of \"type,value\"\n          MFE=(...)          as follows :\n                             ---> (ATTR,NORMAL)\n                                  (  \" ,...) where ... is one or\n                                  (  \" ,(...)) where (...) are more\n                                       keywords option selected in\n                                       the following list :\n                             PROT ---> protected field\n                             NUM  ---> numeric field (cause automatic\n                                       upshift of data entry keyboard)\n                             SKIP ---> automatic skip field (this is\n                                       obviously a protected field)\n                             INT  ---> intensified display field\n                             HIGH ---> high intensity display field\n                                       (this is an alias of \"INT\")\n                             PEN  ---> selector pen detectable field\n                             MED  ---> medium intensity display field\n                                       (this is an alias of \"PEN\")\n                             DARK ---> non-display field\n                             MDT  ---> to identify modified fields\n                             ---> (HILITE,BLINK)\n                                  (  \"   ,REVERSE)\n                                  (  \"   ,USCORE)\n                                  (  \"   ,DEFAULT)\n                             ---> (COLOUR,BLUE)\n                                  (  \"   ,RED)\n                                  (  \"   ,PINK)\n                                  (  \"   ,GREEN)\n                                  (  \"   ,TURQ)\n                                  (  \"   ,YELLOW)\n                                  (  \"   ,WHITE)\n                                  (  \"   ,DEFAULT)\n                             ---> (PGSYM,HH) / HH = hexadecimal\n                                  (  \"  ,DEFAULT)\n1   19/07/91\n                                                      $FS       3/8.\n\n          SF not coded ----> no start field. Default field (SF=NORMAL)\n                             is assumed if CC, WCC, SBA, SA, SFE, MFE,\n                             TEXT, RA and SET operands are not coded\n          SF=NORMAL -------> normal alphameric display\n          SF=IC -----------> Insert Cursor only\n          SF=PT -----------> Program Tabulate only\n          SF=(PT,IC) ------> Program Tabulate and Insert Cursor\n          SF=(...) --------> SF with specified attribute\n          SF=(...,IC) -----> SF, attribute and IC, PT or PT and IC\n          SF=(...,PT)        where ... is one or more keywords option\n          SF=(...,PT,IC)     selected in the following list :\n                             PROT ---> protected field\n                             NUM  ---> numeric field (cause automatic\n                                       upshift of data entry keyboard)\n                             SKIP ---> automatic skip field (this is\n                                       obviously a protected field)\n                             INT  ---> intensified display field\n                             HIGH ---> high intensity display field\n                                       (this is an alias of \"INT\")\n                             PEN  ---> selector pen detectable field\n                             MED  ---> medium intensity display field\n                                       (this is an alias of \"PEN\")\n                             DARK ---> non-display field\n                             MDT  ---> to identify modified fields\n\n          TEXT not coded --> no text field\n          TEXT='...' ------> the desired text : a characters string\n                             enclosed within quotes (if any quote or\n                             ampersand needed in text, double it)\n          TEXT=('...',N) --> the text followed by the desired length.\n                             N must be an absolute numeric text length\n                             value (range : 1 to 256)\n\n          RA not coded ----> no Repeat order\n          RA=(R,C,EUA) ----> row and column of EUA address :\n                             R  ---> row number (screen line)\n                             C  ---> column number (line position)\n          RA=(R,C,E) ------> row and column of RA address :\n          RA=(R,C,'E')       R  ---> row number (screen line)\n          RA=(R,C,HH)        C  ---> column number (line position)\n          RA=(R,C,GE,HH)     E  ---> is the Repeat character expressed\n          RA=(R,C,GE,FILL)           in EBCDIC (if quote or ampersand\n                                     requested, double it or use the\n                                     hexadecimal form)\n                             GE ---> means Graphic Escape character, it\n                                     follows expressed in hexadecimal\n                             HH ---> is the Repeat character expressed\n                                     in hexadecimal (X'40' to X'FE')\n                             FILL -> 00, character stored dynamically\n1   01/08/91\n                                                      $FS       4/8.\n\n          SET not coded ---> no Set (special action) to do\n          SET=...       ---> set an hexadecimal string\n          SET=(GE,HH)   ---> set a Graphic Escape\n          SET=(GE,FILL)      GE ---> means Graphic Escape character, it\n                                     follows expressed in hexadecimal\n                             HH ---> is the character expressed in\n                                     hexadecimal (X'40' to X'FE')\n                             FILL -> 00, character stored dynamically\n\n          M not coded -----> default M= of previous $FS macro or M=2\n                             if first $FS macro\n          M=1 -------------> 12 x 40 screen size\n          M=2 -------------> 24 x 80 screen size (default)\n          M=3 -------------> 32 x 80 screen size\n          M=4 -------------> 43 x 80 screen size\n          M=5 -------------> 27 x 132 screen size\n\n          DOC not coded ---> no inline documentation\n          DOC=YES ---------> obtain inline documentation\n          DOC=EJECT -------> obtain inline documentation on pages\n          DOC=(YES,ALL) ---> obtain inline all documentation\n          DOC=(EJECT,ALL) -> obtain inline all documentation on pages\n\n          MF=L ------------> generate list form\n          MF=(I,...) ------> generate execute form, ... is the label\n                             of the starting address for generated\n                             orders and fields move, see note 3\n          MF=(I,(...)) ----> generate execute form, ... is a register\n                             which contain the starting address for\n                             generated orders and fields move, see\n                             note 3\n          MF=I ------------> generate execute form using the label or\n          MF=(I,)            the register specified in the MF= operand\n                             of a previous $FS macro use, see note 3\n          MF=(E,...) ------> generate execute form, ... is the label\n                             Rx-type starting address for generated\n                             orders and fields move (register 1 used),\n                             see note 2\n          MF=(E,(...)) ----> generate execute form, ... is a register\n                             which contain the starting address for\n                             generated orders and fields move, see\n                             note 2\n          MF not coded ----> generate execute form using the register\n          MF=E               specified in the MF= operand of a previous\n          MF=(E,)            $FS macro use, or assume MF=(E,(1)) if the\n                             first $FS macro occurance, see note 2\n1   19/07/91\n                                                      $FS       5/8.\n\n  Notes : 1. Combinations of orders and fields are generated in the\n             following sequence :\n             CC, WCC, SBA, SA, SFE, MFE, SF, TEXT, RA and SET.\n          2. When using the execute form, at end of macro generation\n             the register 1 or that specified in the MF= operand\n             points to the last byte+1 address of the generated\n             orders and fields.\n          3. When using the immediate form, at end of macro generation\n             the position pointer of the generated orders and fields\n             is retained.\n\n  Warning :  1. User must know how a screen is builded before he uses\n                this macro.\n             2. Beware that the length attribute of an eventual label\n                is not necessarily the length of all the data (orders\n                and fields) generated by the macro.\n1   19/07/91\n                                                      $FS       6/8.\n\n $FSDOT   : Generate the DOT pattern encoded of binary bits\n ---------- corresponding to vertical and horizontal slicing of a\n            character cell (Data Type 1).\n\n  Vertical/Horizontal slicing of a character cell :\n  -------------------------------------------------\n\n         An uncompressed symbol definition is created by dividing the\n  character cell within which a symbol is formed into bytes (slices) as\n  shown below. The symbol is defined by encoding the bits (dots) in\n  each byte (slices) as a B'1' if the dot is to be on, and a B'0' if\n  off. Once the character cell has been sliced, the slices are now\n  forming a data string, the DOT pattern representing the symbol is\n  thus formed.\n\n                       0 1 2 3 4 5 6 7 <- Bits\n                 I---I-----------------I <---*-------*\n       Bits -> 0 I   I    Slice   3    I     I       I\n                 I   I-----------------I     I       I\n               1 I   I    Slice   4    I     I       I\n                 I   I-----------------I     I       I\n               2 I S I    Slice   5    I     I       I\n                 I l I-----------------I     I       I\n               3 I i I    Slice   6    I     I       I\n                 I c I-----------------I     I       I\n               4 I e I    Slice   7    I     I       I\n                 I   I-----------------I     I       I\n               5 I 1 I    Slice   8    I     I       I\n                 I   I-----------------I    H=12     I\n               6 I   I    Slice   9    I     I       I     Slot\n                 I   I-----------------I     I       I    height\n               7 I   I    Slice  10    I     I       I\n                 I---I-----------------I     I      H=16\n               0 I   I    Slice  11    I     I       I\n                 I   I-----------------I     I       I\n               1 I   I    Slice  12    I     I       I\n                 I   I-----------------I     I       I\n               2 I S I    Slice  13    I     I       I\n                 I l I-----------------I     I       I\n               3 I i I    Slice  14    I     I       I\n                 I c I-----------------I <---*       I\n               4 I e I    Slice  15    I             I\n                 I   I-----------------I             I\n               5 I 2 I    Slice  16    I             I\n                 I   I-----------------I             I\n               6 I   I    Slice  17    I             I\n                 I   I-----------------I             I\n               7 I   I    Slice  18    I             I\n                 I---I-----------------I <-----------*\n\n                 <-------- W=9 -------->\n                        Slot width\n1   19/07/91\n                                                      $FS       7/8.\n\n  Triple-plane symbol sets :\n  --------------------------\n\n         Triple-plane symbol sets contain a separate plane for each\n  primary colour : BLUE, RED and GREEN. Corresponding locations in each\n  plane may be loaded with a different pattern of active bits, so the\n  active primary colours combine to produce secondary colours, as\n  indicated below\n\n              ----------------------------------------\n              I Primary colours       I              I\n              I-----------------------I    Video     I\n              I BLUE  I  RED  I GREEN I              I\n              I-------I-------I-------I--------------I\n              I  no   I  no   I  no   I  no display  I\n              I  no   I  no   I  yes  I  Green       I\n              I  no   I  yes  I  no   I  Red         I\n              I  no   I  yes  I  yes  I  Yellow      I\n              I  yes  I  no   I  no   I  Blue        I\n              I  yes  I  no   I  yes  I  Turquoise   I\n              I  yes  I  yes  I  no   I  Pink        I\n              I  yes  I  yes  I  yes  I  White       I\n              ----------------------------------------\n\n  Skeleton : LABEL  $FSDOT   -P-,-P-,-P-,...,-P-,-P-,-P-,W=...,H=...,\n                             PL=...,DOC=...\n\n  Where : -P- -------------> strings of bits 0 and/or 1 defining the\n                             active dots of the character matrix\n                             (length of string = slot width, number\n                             of strings = slot height)\n                             See also note 2 for triple-plane facility\n\n          W=... -----------> character slot width = horizontal size\n                             of the character matrix (default is 9,\n                             and only W=9 is accepted)\n\n          H=... -----------> character slot height = vertical size\n                             of the character matrix (default is 16,\n                             and only H=12 or 16 are accepted)\n\n          PL not coded ----> default PL= of previous $FSDOT macro or\n                             PL=SINGLE if first $FSDOT macro\n          PL=SINGLE -------> single-plane\n                             May be also coded PL=S\n          PL=BLUE ---------> specific plane of a triple-plane\n          PL=RED             May be also coded PL=B, PL=R and PL=G\n          PL=GREEN\n\n          DOC not coded ---> no inline documentation\n          DOC=YES ---------> obtain inline documentation\n          DOC=EJECT -------> obtain inline documentation on pages\n1   19/07/91\n                                                      $FS       8/8.\n\n  Notes : 1. The length attribute of an eventual label is the length\n             of all the data (complete DOT pattern) generated by the\n             $FSDOT macro.\n          2. When defining a triple-plane (PL=B, PL=R or PL=G), the\n             string (-P-) of active dots can indicate the desired\n             colour (used in place of bit 1) as follows\n                   G = Green\n                   R = Red\n                   Y = Yellow\n                   B = Blue\n                   T = Turquoise\n                   P = Pink\n                   W = White\n             Then, the macro will automatically set the bit 1 in the\n             current requested plane if needed to generate that colour.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FSCC": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x18?\\x00\\x91\\x18?\\x16\\x03\\x00U\\x00U\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-07-02T00:00:00", "modifydate": "1991-07-02T16:03:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL  $FSCC\n.*\n.* MACRO : INTERNALLY USED BY $FS MACRO.\n.* -------\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         GBLA  &GMFCI\n         GBLB  &GFUSW,&GFESW,&GFISW\n         GBLC  &GFSMF,&GFSMI\n         LCLA  &NR\n         LCLB  &SW\n         LCLC  &CC,&OP,&RG\n         AIF   (NOT &GFUSW).USEERR\n         AIF   (N'&SYSLIST NE 1).ARGERR\n         AIF   ('&SYSLIST(1)'(1,1) NE '(').NMRL\n&NR      SETA  K'&SYSLIST(1)-2\n&CC      SETC  '&SYSLIST(1)'(2,&NR)\n&SW      SETB  1\n         AGO   .TSTC\n.NMRL    ANOP\n&CC      SETC  '&SYSLIST(1)'\n&SW      SETB  0\n.TSTC    AIF   ('&CC' EQ 'W').W\n         AIF   ('&CC' EQ 'EW').EW\n         AIF   ('&CC' EQ 'EWA').EWA\n         AIF   ('&CC' EQ 'EAU').EAU\n         AIF   ('&CC' NE 'WSF').ARGERR\n&OP      SETC  'F3'\n.TGS     AIF   (&GFISW).SMVI\n         AIF   (&GFESW).SMVL\n&LABEL   DC    XL1'&OP'\n         MEXIT\n.SMVL    ANOP\n&LABEL   MVI   0(&GFSMF),X'&OP'\n         LA    &GFSMF,1(,&GFSMF)\n         MEXIT\n.SMVI    AIF   ('&GFSMI'(1,1) EQ '(').SMVIR\n&LABEL   MVI   &GFSMI+&GMFCI,X'&OP'\n&GMFCI   SETA  &GMFCI+1\n         MEXIT\n.SMVIR   ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVI   &GMFCI.(&RG),X'&OP'\n&GMFCI   SETA  &GMFCI+1\n         MEXIT\n.W       ANOP\n&OP      SETC  'F1'\n         AGO   .TGX\n.EW      ANOP\n&OP      SETC  'F5'\n         AGO   .TGX\n.EWA     ANOP\n&OP      SETC  '7E'\n         AGO   .TGX\n.EAU     ANOP\n&OP      SETC  '6F'\n.TGX     AIF   (&SW).TGS\n         AIF   (&GFISW).MVI\n         AIF   (&GFESW).MVL\n&LABEL   DC    XL2'27&OP'\n         MEXIT\n.MVL     ANOP\n&LABEL   MVC   0(2,&GFSMF),=XL2'27&OP'\n         LA    &GFSMF,2(,&GFSMF)\n         MEXIT\n.MVI     AIF   ('&GFSMI'(1,1) EQ '(').MVIR\n&LABEL   MVC   &GFSMI+&GMFCI.(2),=XL2'27&OP'\n&GMFCI   SETA  &GMFCI+2\n         MEXIT\n.MVIR    ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVC   &GMFCI.(2,&RG),=XL2'27&OP'\n&GMFCI   SETA  &GMFCI+2\n         MEXIT\n.USEERR  MNOTE 8,'--- MACRO USAGE INVALID'\n         MEXIT\n.ARGERR  MNOTE 8,'--- CC=... INVALID CODING'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FSDOT": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91 \\x0f\\x00\\x91 \\x0f\\x13I\\x01H\\x01H\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-07-19T00:00:00", "modifydate": "1991-07-19T13:49:00", "lines": 328, "newlines": 328, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL  $FSDOT &W=9,&H=16,&PL=,&DOC=\n         GBLA  &FSDPL\n.* GLOBALS USE :\n.* -------------\n.*       &FSDPL - PLANE : (S)INGLE = SINGLE-PLANE\n.*                        (B)LUE   = BLUE-PLANE OF A TRIPLE-PLANE\n.*                        (R)ED    = RED-PLANE OF A TRIPLE-PLANE\n.*                        (G)REEN  = GREEN-PLANE OF A TRIPLE-PLANE\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         LCLA  &I,&L,&M,&N\n         LCLB  &DL,&SK,&SP\n         LCLC  &B,&C\n         AIF   ('&DOC' EQ '').ND\n         AIF   (N'&DOC EQ 1).SCD\n         AIF   (N'&DOC NE 2).ERD\n         AIF   ('&DOC(2)' NE 'SKIP').ERD\n&SK      SETB  1\n         AIF   ('&DOC(1)' EQ 'EJECT').EJ\n         AIF   ('&DOC(1)' NE 'YES').ND\n&SP      SETB  1\n         AGO   .SPN\n.SCD     AIF   ('&DOC' EQ 'EJECT').EJ\n         AIF   ('&DOC' NE 'YES').ND\n&SP      SETB  1\n.SPN     AIF   (&SK).DOC\n         SPACE 1\n         AGO   .DOC\n.EJ      AIF   (&SK).DOC\n         EJECT\n.DOC     ANOP\n&DL      SETB  1\n* $FSDOT MACRO : GENERATE THE DOT PATTERN ENCODED OF BINARY BITS\n* -------------- CORRESPONDING TO VERTICAL AND HORIZONTAL SLICING OF\n*                A CHARACTER CELL (DATA TYPE 1).\n*\n* VERTICAL/HORIZONTAL SLICING OF A CHARACTER CELL :\n* -------------------------------------------------\n*\n*        AN UNCOMPRESSED SYMBOL DEFINITION IS CREATED BY DIVIDING THE\n* CHARACTER CELL WITHIN WHICH A SYMBOL IS FORMED INTO BYTES (SLICES) AS\n* SHOWN BELOW. THE SYMBOL IS DEFINED BY ENCODING THE BITS (DOTS) IN\n* EACH BYTE (SLICES) AS A B'1' IF THE DOT IS TO BE ON, AND A B'0' IF\n* OFF. ONCE THE CHARACTER CELL HAS BEEN SLICED, THE SLICES ARE NOW\n* FORMING A DATA STRING, THE DOT PATTERN REPRESENTING THE SYMBOL IS\n* THUS FORMED.\n*\n*                      0 1 2 3 4 5 6 7 <- BITS\n*                I---I-----------------I <---*-------*\n*      BITS -> 0 I   I    SLICE   3    I     I       I\n*                I   I-----------------I     I       I\n*              1 I   I    SLICE   4    I     I       I\n*                I   I-----------------I     I       I\n*              2 I S I    SLICE   5    I     I       I\n*                I L I-----------------I     I       I\n*              3 I I I    SLICE   6    I     I       I\n*                I C I-----------------I     I       I\n*              4 I E I    SLICE   7    I     I       I\n*                I   I-----------------I     I       I\n*              5 I 1 I    SLICE   8    I     I       I\n*                I   I-----------------I    H=12     I\n*              6 I   I    SLICE   9    I     I       I     SLOT\n*                I   I-----------------I     I       I    HEIGHT\n*              7 I   I    SLICE  10    I     I       I\n*                I---I-----------------I     I      H=16\n*              0 I   I    SLICE  11    I     I       I\n*                I   I-----------------I     I       I\n*              1 I   I    SLICE  12    I     I       I\n*                I   I-----------------I     I       I\n*              2 I S I    SLICE  13    I     I       I\n*                I L I-----------------I     I       I\n*              3 I I I    SLICE  14    I     I       I\n*                I C I-----------------I <---*       I\n*              4 I E I    SLICE  15    I             I\n*                I   I-----------------I             I\n*              5 I 2 I    SLICE  16    I             I\n*                I   I-----------------I             I\n*              6 I   I    SLICE  17    I             I\n*                I   I-----------------I             I\n*              7 I   I    SLICE  18    I             I\n*                I---I-----------------I <-----------*\n*\n*                <-------- W=9 -------->\n*                       SLOT WIDTH\n         AIF   (&SP).SP1\n         EJECT\n         AGO   .EJ1\n.SP1     ANOP\n         SPACE 1\n.EJ1     ANOP\n* TRIPLE-PLANE SYMBOL SETS :\n* --------------------------\n*\n*        TRIPLE-PLANE SYMBOL SETS CONTAIN A SEPARATE PLANE FOR EACH\n* PRIMARY COLOUR : BLUE, RED AND GREEN. CORRESPONDING LOCATIONS IN EACH\n* PLANE MAY BE LOADED WITH A DIFFERENT PATTERN OF ACTIVE BITS, SO THE\n* ACTIVE PRIMARY COLOURS COMBINE TO PRODUCE SECONDARY COLOURS, AS\n* INDICATED BELOW\n*\n*             ----------------------------------------\n*             I PRIMARY COLOURS       I              I\n*             I-----------------------I    VIDEO     I\n*             I BLUE  I  RED  I GREEN I              I\n*             I-------I-------I-------I--------------I\n*             I  NO   I  NO   I  NO   I  NO DISPLAY  I\n*             I  NO   I  NO   I  YES  I  GREEN       I\n*             I  NO   I  YES  I  NO   I  RED         I\n*             I  NO   I  YES  I  YES  I  YELLOW      I\n*             I  YES  I  NO   I  NO   I  BLUE        I\n*             I  YES  I  NO   I  YES  I  TURQUOISE   I\n*             I  YES  I  YES  I  NO   I  PINK        I\n*             I  YES  I  YES  I  YES  I  WHITE       I\n*             ----------------------------------------\n*\n* SKELETON : LABEL  $FSDOT   -P-,-P-,-P-,...,-P-,-P-,-P-,W=...,H=...,\n* ----------                 PL=...,DOC=...\n*\n* WHERE : -P- -------------> STRINGS OF BITS 0 AND/OR 1 DEFINING THE\n* -------                    ACTIVE DOTS OF THE CHARACTER MATRIX\n*                            (LENGTH OF STRING = SLOT WIDTH, NUMBER\n*                            OF STRINGS = SLOT HEIGHT)\n*                            SEE ALSO NOTE 2 FOR TRIPLE-PLANE FACILITY\n*\n*         W=... -----------> CHARACTER SLOT WIDTH = HORIZONTAL SIZE\n*                            OF THE CHARACTER MATRIX (DEFAULT IS 9,\n*                            AND ONLY W=9 IS ACCEPTED)\n*\n*         H=... -----------> CHARACTER SLOT HEIGHT = VERTICAL SIZE\n*                            OF THE CHARACTER MATRIX (DEFAULT IS 16,\n*                            AND ONLY H=12 OR 16 ARE ACCEPTED)\n*\n*         PL NOT CODED ----> DEFAULT PL= OF PREVIOUS $FSDOT MACRO OR\n*                            PL=S IF FIRST $FSDOT MACRO\n*         PL=SINGLE -------> SINGLE-PLANE\n*                            MAY BE ALSO CODED PL=S\n*         PL=BLUE ---------> SPECIFIC PLANE OF A TRIPLE-PLANE\n*         PL=RED             MAY BE ALSO CODED PL=B, PL=R AND PL=G\n*         PL=GREEN\n*\n*         DOC NOT CODED ---> NO INLINE DOCUMENTATION\n*         DOC=YES ---------> OBTAIN INLINE DOCUMENTATION\n*         DOC=EJECT -------> OBTAIN INLINE DOCUMENTATION ON PAGES\n         AIF   (&SP).SP2\n         EJECT\n         AGO   .EJ2\n.SP2     ANOP\n         SPACE 1\n.EJ2     ANOP\n* NOTES : 1. THE LENGTH ATTRIBUTE OF AN EVENTUAL LABEL IS THE LENGTH\n* -------    OF ALL THE DATA (COMPLETE DOT PATTERN) GENERATED BY THE\n*            $FSDOT MACRO.\n*         2. WHEN DEFINING A TRIPLE-PLANE (PL=B, PL=R OR PL=G), THE\n*            STRING (-P-) OF ACTIVE DOTS CAN INDICATE THE DESIRED\n*            COLOUR (USED IN PLACE OF BIT 1) AS FOLLOWS\n*                  G = GREEN\n*                  R = RED\n*                  Y = YELLOW\n*                  B = BLUE\n*                  T = TURQUOISE\n*                  P = PINK\n*                  W = WHITE\n*            THEN, THE MACRO WILL AUTOMATICALLY SET THE BIT 1 IN THE\n*            CURRENT REQUESTED PLANE IF NEEDED TO GENERATE THAT COLOUR.\n         AIF   (&SP).SPC\n         EJECT\n         AGO   .ND\n.SPC     SPACE 1\n.ND      AIF   ('&W' NE '9').USWERR\n         AIF   ('&H' EQ '12').OKH\n         AIF   ('&H' NE '16').USHERR\n.OKH     AIF   ('&PL' EQ '').OKP\n         AIF   ('&PL' EQ 'S').OKS\n         AIF   ('&PL' EQ 'SINGLE').OKS\n         AIF   ('&PL' EQ 'B').OKB\n         AIF   ('&PL' EQ 'BLUE').OKB\n         AIF   ('&PL' EQ 'R').OKR\n         AIF   ('&PL' EQ 'RED').OKR\n         AIF   ('&PL' EQ 'G').OKG\n         AIF   ('&PL' EQ 'GREEN').OKG\n         MNOTE 0,'--- PL= INVALID - PREVIOUS PL OR DEFAULT ASSUMED'\n         AGO   .OKP\n.OKS     ANOP\n&FSDPL   SETA  0\n         AGO   .OKP\n.OKB     ANOP\n&FSDPL   SETA  1\n         AGO   .OKP\n.OKR     ANOP\n&FSDPL   SETA  2\n         AGO   .OKP\n.OKG     ANOP\n&FSDPL   SETA  3\n.OKP     ANOP\n&N       SETA  N'&SYSLIST\n         AIF   (NOT &DL).NDL\n         AIF   (&N EQ 0).END\n.NDL     AIF   (&N NE &H).NPDERR\n&I       SETA  1\n.LCP     ANOP\n&L       SETA  K'&SYSLIST(&I)\n         AIF   (&L NE &W).LPDERR\n&M       SETA  1\n.LCB     ANOP\n&B       SETC  '&SYSLIST(&I)'(&M,1)\n         AIF   ('&B' EQ '0').CNT\n         AIF   (&FSDPL EQ 0).TBO\n         AIF   ('&B' EQ 'G').CNT\n         AIF   ('&B' EQ 'R').CNT\n         AIF   ('&B' EQ 'Y').CNT\n         AIF   ('&B' EQ 'B').CNT\n         AIF   ('&B' EQ 'T').CNT\n         AIF   ('&B' EQ 'P').CNT\n         AIF   ('&B' EQ 'W').CNT\n.TBO     AIF   ('&B' NE '1').NBTERR\n.CNT     AIF   (&M EQ &W).CNP\n&M       SETA  &M+1\n         AGO   .LCB\n.CNP     AIF   (&I EQ &H).GEN\n&I       SETA  &I+1\n         AGO   .LCP\n.GEN     AIF   ('&LABEL' EQ '').SGN\n&LABEL   DS    0XL18\n.SGN     ANOP\n&I       SETA  1\n&C       SETC  ''\n.GNL     ANOP\n&B       SETC  '&SYSLIST(&I)'(1,1)\n         AIF   (&FSDPL EQ 0).SET\n         AIF   ('&B' EQ '0').SET\n         AIF   ('&B' EQ '1').SET\n         AIF   (&FSDPL NE 1).TPR\n         AIF   ('&B' EQ 'B').STO\n         AIF   ('&B' EQ 'T').STO\n         AIF   ('&B' EQ 'P').STO\n         AIF   ('&B' EQ 'W').STO\n         AGO   .STZ\n.TPR     AIF   (&FSDPL NE 2).TPG\n         AIF   ('&B' EQ 'R').STO\n         AIF   ('&B' EQ 'Y').STO\n         AIF   ('&B' EQ 'P').STO\n         AIF   ('&B' EQ 'W').STO\n         AGO   .STZ\n.TPG     AIF   ('&B' EQ 'G').STO\n         AIF   ('&B' EQ 'Y').STO\n         AIF   ('&B' EQ 'T').STO\n         AIF   ('&B' EQ 'W').STO\n.STZ     ANOP\n&B       SETC  '0'\n         AGO   .SET\n.STO     ANOP\n&B       SETC  '1'\n.SET     ANOP\n&C       SETC  '&C&B'\n         AIF   (&I EQ 8).SL1\n         AIF   (&I EQ &H).TSL\n.GNN     ANOP\n&I       SETA  &I+1\n         AGO   .GNL\n.SL1     ANOP\n         DC    B'&C'\n&C       SETC  ''\n         AGO   .GNN\n.TSL     AIF   (&I EQ 16).SL2\n&I       SETA  &I+1\n&C       SETC  '&C.0'\n         AGO   .TSL\n.SL2     ANOP\n         DC    B'&C'\n&I       SETA  1\n.SLN     AIF   (&FSDPL EQ 0).SAB\n&L       SETA  2\n&C       SETC  ''\n.LLP     ANOP\n&B       SETC  '&SYSLIST(&I)'(&L,1)\n         AIF   (&FSDPL NE 1).TTR\n         AIF   ('&B' EQ 'B').SSO\n         AIF   ('&B' EQ 'T').SSO\n         AIF   ('&B' EQ 'P').SSO\n         AIF   ('&B' EQ 'W').SSO\n         AGO   .SSZ\n.TTR     AIF   (&FSDPL NE 2).TTG\n         AIF   ('&B' EQ 'R').SSO\n         AIF   ('&B' EQ 'Y').SSO\n         AIF   ('&B' EQ 'P').SSO\n         AIF   ('&B' EQ 'W').SSO\n         AGO   .SSZ\n.TTG     AIF   ('&B' EQ 'G').SSO\n         AIF   ('&B' EQ 'Y').SSO\n         AIF   ('&B' EQ 'T').SSO\n         AIF   ('&B' EQ 'W').SSO\n.SSZ     ANOP\n&B       SETC  '0'\n         AGO   .SST\n.SSO     ANOP\n&B       SETC  '1'\n.SST     ANOP\n&C       SETC  '&C&B'\n         AIF   (&L EQ 9).STT\n&L       SETA  &L+1\n         AGO   .LLP\n.SAB     ANOP\n&C       SETC  '&SYSLIST(&I)'(2,8)\n.STT     DC    B'&C'\n         AIF   (&I EQ &H).TLL\n&I       SETA  &I+1\n         AGO   .SLN\n.TLL     AIF   (&I EQ 16).END\n         DC    B'00000000'\n&I       SETA  &I+1\n         AGO   .TLL\n.END     MEXIT\n.ERD     MNOTE 8,'--- DOC= INVALID CODING'\n         MEXIT\n.USWERR  MNOTE 8,'--- ONLY W=9 IS SUPPORTED'\n         MEXIT\n.USHERR  MNOTE 8,'--- ONLY H=12 OR H=16 ARE SUPPORTED'\n         MEXIT\n.NPDERR  MNOTE 8,'--- &N PATTERNS DEFINED, MUST BE &H DEFINED'\n         MEXIT\n.LPDERR  MNOTE 8,'--- PATTERN &I INVALID, MUST BE &W BITS'\n         MEXIT\n.NBTERR  MNOTE 8,'--- PATTERN &I, BIT &M INVALID CODING'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FSRA": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91!?\\x00\\x91!?\\x177\\x00\\xc7\\x00\\xc7\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-01T00:00:00", "modifydate": "1991-08-01T17:37:00", "lines": 199, "newlines": 199, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL  $FSRA\n.*\n.* MACRO : INTERNALLY USED BY $FS MACRO.\n.* -------\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         GBLA  &FSMDLN,&GMFCI\n         GBLB  &GFUSW,&GFESW,&GFISW\n         GBLC  &GFSMF,&GFSMI\n         LCLA  &BS,&I1,&I2,&R,&C,&LSZ,&L,&NR\n         LCLC  &B1,&B2,&O,&RCH,&RG,&T1,&T2\n         AIF   (NOT &GFUSW).USEERR\n         AIF   (N'&SYSLIST(1) EQ 4).M0\n         AIF   (N'&SYSLIST(1) NE 3).ARGERR\n.M0      AIF   (&FSMDLN EQ 1).M1\n         AIF   (&FSMDLN EQ 2).M2\n         AIF   (&FSMDLN EQ 3).M3\n         AIF   (&FSMDLN EQ 4).M4\n         AIF   (&FSMDLN EQ 5).M5\n         AGO   .DFLT\n.M1      AIF   (&SYSLIST(1,1) GT 12).M1RERR\n         AIF   (&SYSLIST(1,2) GT 40).M1CERR\n&LSZ     SETA  40\n         AGO   .SROW\n.M3      AIF   (&SYSLIST(1,1) GT 32).M3RERR\n         AIF   (&SYSLIST(1,2) GT 80).M3CERR\n         AGO   .SLNL\n.M4      AIF   (&SYSLIST(1,1) GT 43).M4RERR\n         AIF   (&SYSLIST(1,2) GT 80).M4CERR\n         AGO   .SLNL\n.M5      AIF   (&SYSLIST(1,1) GT 27).M5RERR\n         AIF   (&SYSLIST(1,2) GT 132).M5CERR\n&LSZ     SETA  132\n         AGO   .SROW\n.DFLT    ANOP\n.M2      AIF   (&SYSLIST(1,1) GT 24).M2RERR\n         AIF   (&SYSLIST(1,2) GT 80).M2CERR\n.SLNL    ANOP\n&LSZ     SETA  80\n.SROW    ANOP\n&R       SETA  1\n         AIF   (&SYSLIST(1,1) LE 1).SCOL\n&R       SETA  &SYSLIST(1,1)\n.SCOL    ANOP\n&C       SETA  1\n         AIF   (&SYSLIST(1,2) LE 1).CMPTE\n&C       SETA  &SYSLIST(1,2)\n.CMPTE   ANOP\n&BS      SETA  &LSZ*(&R-1)+&C-1\n&I1      SETA  &BS/64\n&I2      SETA  2*(&BS-(64*&I1)+1)-1\n&I1      SETA  2*(&I1+1)-1\n&B1      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5X\n               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6FX\n               7F8F97A7B7C7D7E7F'(&I1,2)\n&B2      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5X\n               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6FX\n               7F8F97A7B7C7D7E7F'(&I2,2)\n         AIF   (K'&SYSLIST(1,3) NE 3).CNT\n         AIF   (N'&SYSLIST(1) NE 3).ARGERR\n         AIF   ('&SYSLIST(1,3)' EQ 'EUA').EUA\n         AIF   ('&SYSLIST(1,3)'(1,1) NE '''').ARGERR\n         AIF   ('&SYSLIST(1,3)'(3,1) NE '''').ARGERR\n&RCH     SETC  '&SYSLIST(1,3)'(2,1)\n         AGO   .CH\n.CNT     AIF   (K'&SYSLIST(1,3) NE 2).NGE\n         AIF   ('&SYSLIST(1,3)' NE 'GE').NGE\n         AIF   (N'&SYSLIST(1) NE 4).ARGERR\n&RCH     SETC  '&SYSLIST(1,4)'\n         AIF   (K'&RCH NE 4).NF\n         AIF   ('&RCH' NE 'FILL').ARGERR\n&RCH     SETC  '00'\n         AGO   .STC\n.NF      AIF   (K'&RCH NE 2).ARGERR\n&T1      SETC  '&RCH'(1,1)\n&T2      SETC  '&RCH'(2,1)\n         AIF   ('&T1' EQ '4').TSN\n         AIF   ('&T1' EQ '5').TSN\n         AIF   ('&T1' EQ '6').TSN\n         AIF   ('&T1' EQ '7').TSN\n         AIF   ('&T1' EQ '8').TSN\n         AIF   ('&T1' EQ '9').TSN\n         AIF   ('&T1' EQ 'A').TSN\n         AIF   ('&T1' EQ 'B').TSN\n         AIF   ('&T1' EQ 'C').TSN\n         AIF   ('&T1' EQ 'D').TSN\n         AIF   ('&T1' EQ 'E').TSN\n         AIF   ('&T1' NE 'F').ARGERR\n.TSN     AIF   ('&T2' EQ '0').STC\n         AIF   ('&T2' EQ '1').STC\n         AIF   ('&T2' EQ '2').STC\n         AIF   ('&T2' EQ '3').STC\n         AIF   ('&T2' EQ '4').STC\n         AIF   ('&T2' EQ '5').STC\n         AIF   ('&T2' EQ '6').STC\n         AIF   ('&T2' EQ '7').STC\n         AIF   ('&T2' EQ '8').STC\n         AIF   ('&T2' EQ '9').STC\n         AIF   ('&T2' EQ 'A').STC\n         AIF   ('&T2' EQ 'B').STC\n         AIF   ('&T2' EQ 'C').STC\n         AIF   ('&T2' EQ 'D').STC\n         AIF   ('&T2' EQ 'E').STC\n         AIF   ('&T1' EQ 'F').ARGERR\n         AIF   ('&T2' NE 'F').ARGERR\n.STC     ANOP\n&RCH     SETC  '08&RCH'\n&L       SETA  5\n&O       SETC  '3C'\n         AGO   .GRA\n.NGE     AIF   (N'&SYSLIST(1) EQ 4).ARGERR\n&RCH     SETC  '&SYSLIST(1,3)'\n         AIF   (K'&RCH EQ 1).CH\n         AIF   (K'&RCH NE 2).ARGERR\n         AIF   ('&RCH' EQ '&&').CH\n         AIF   ('&RCH' NE '''''').HEX\n.CH      AIF   (&GFISW).GXI\n         AIF   (&GFESW).GXQ\n&LABEL   DC    XL3'3C&B1&B2',C'&RCH'\n         MEXIT\n.GXQ     ANOP\n&LABEL   MVC   0(3,&GFSMF),=XL3'3C&B1&B2'\n         MVI   3(&GFSMF),C'&RCH'\n         LA    &GFSMF,4(,&GFSMF)\n         MEXIT\n.GXI     AIF   ('&GFSMI'(1,1) EQ '(').GXIR\n&LABEL   MVC   &GFSMI+&GMFCI.(3),=XL3'3C&B1&B2'\n&GMFCI   SETA  &GMFCI+3\n         MVI   &GFSMI+&GMFCI,C'&RCH'\n&GMFCI   SETA  &GMFCI+1\n         MEXIT\n.GXIR    ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVC   &GMFCI.(3,&RG),=XL3'3C&B1&B2'\n&GMFCI   SETA  &GMFCI+3\n         MVI   &GMFCI.(&RG),C'&RCH'\n&GMFCI   SETA  &GMFCI+1\n         MEXIT\n.HEX     ANOP\n&L       SETA  4\n&O       SETC  '3C'\n         AGO   .GRA\n.EUA     ANOP\n&L       SETA  3\n&O       SETC  '12'\n.GRA     AIF   (&GFISW).GIX\n         AIF   (&GFESW).GEX\n&LABEL   DC    XL&L.'&O&B1&B2&RCH'\n         MEXIT\n.GEX     ANOP\n&LABEL   MVC   0(&L,&GFSMF),=XL&L.'&O&B1&B2&RCH'\n         LA    &GFSMF,&L.(,&GFSMF)\n         MEXIT\n.GIX     AIF   ('&GFSMI'(1,1) EQ '(').GIXR\n&LABEL   MVC   &GFSMI+&GMFCI.(&L),=XL&L.'&O&B1&B2&RCH'\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.GIXR    ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVC   &GMFCI.(&L,&RG),=XL&L.'&O&B1&B2&RCH'\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.USEERR  MNOTE 8,'--- INVALID MACRO USAGE'\n         MEXIT\n.ARGERR  MNOTE 8,'--- RA=(...) INVALID CODING'\n         MEXIT\n.M1RERR  MNOTE 8,'--- RA - ROW NOT 1 THRU 12 FOR M=1'\n         AGO   .DUMMY\n.M1CERR  MNOTE 8,'--- RA - COLUMN NOT 1 THRU 40 FOR M=1'\n         AGO   .DUMMY\n.M2RERR  MNOTE 8,'--- RA - ROW NOT 1 THRU 24 FOR M=2'\n         AGO   .DUMMY\n.M2CERR  MNOTE 8,'--- RA - COLUMN NOT 1 THRU 80 FOR M=2'\n         AGO   .DUMMY\n.M3RERR  MNOTE 8,'--- RA - ROW NOT 1 THRU 32 FOR M=3'\n         AGO   .DUMMY\n.M3CERR  MNOTE 8,'--- RA - COLUMN NOT 1 THRU 80 FOR M=3'\n         AGO   .DUMMY\n.M4RERR  MNOTE 8,'--- RA - ROW NOT 1 THRU 43 FOR M=4'\n         AGO   .DUMMY\n.M4CERR  MNOTE 8,'--- RA - COLUMN NOT 1 THRU 80 FOR M=4'\n         AGO   .DUMMY\n.M5RERR  MNOTE 8,'--- RA - ROW NOT 1 THRU 27 FOR M=5'\n         AGO   .DUMMY\n.M5CERR  MNOTE 8,'--- RA - COLUMN NOT 1 THRU 132 FOR M=5'\n.DUMMY   AIF   (&GFESW).GXD\n&LABEL   DC    XL4'3C000000'\n         MEXIT\n.GXD     ANOP\n&LABEL   MVC   0(4,&GFSMF),=XL4'3C000000'\n         LA    &GFSMF,4(,&GFSMF)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FSSA": {"ttr": 2818, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x17\\x1f\\x00\\x91\\x17\\x1f\\x14(\\x002\\x002\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-06-20T00:00:00", "modifydate": "1991-06-20T14:28:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL  $FSSA\n.*\n.* MACRO : INTERNALLY USED BY $FS MACRO.\n.* -------\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         GBLA  &GMFCI\n         GBLB  &GFUSW,&GFESW,&GFISW,&GFWSW\n         GBLC  &GFSMF,&GFSMI,&GFSOP,&GFWTY,&GFWVA\n         LCLA  &NR\n         LCLC  &RG,&TY,&VA\n         AIF   (NOT &GFUSW).USEERR\n&GFSOP   SETC  '28'\n         AIF   ('&SYSLIST(1)' EQ 'RESET').RST\n         AIF   (N'&SYSLIST(1) NE 2).ARGERR\n&TY      SETC  '&SYSLIST(1,1)'\n&VA      SETC  '&SYSLIST(1,2)'\n        $FS$TV &TY,&VA\n         AIF   (NOT &GFWSW).TGX\n         MEXIT\n.RST     ANOP\n&GFWTY   SETC  '00'\n&GFWVA   SETC  '00'\n.TGX     AIF   (&GFISW).MVI\n         AIF   (&GFESW).MVL\n&LABEL   DC    XL3'&GFSOP&GFWTY&GFWVA'\n         MEXIT\n.MVL     ANOP\n&LABEL   MVC   0(3,&GFSMF),=XL3'&GFSOP&GFWTY&GFWVA'\n         LA    &GFSMF,3(,&GFSMF)\n         MEXIT\n.MVI     AIF   ('&GFSMI'(1,1) EQ '(').MVIR\n&LABEL   MVC   &GFSMI+&GMFCI.(3),=XL3'&GFSOP&GFWTY&GFWVA'\n&GMFCI   SETA  &GMFCI+3\n         MEXIT\n.MVIR    ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVC   &GMFCI.(3,&RG),=XL3'&GFSOP&GFWTY&GFWVA'\n&GMFCI   SETA  &GMFCI+3\n         MEXIT\n.ARGERR  MNOTE 8,'--- SA=(...) INVALID CODING'\n         MEXIT\n.USEERR  MNOTE 8,'--- INVALID MACRO USAGE'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FSSBA": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91!?\\x00\\x91!?\\x177\\x00y\\x00y\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-01T00:00:00", "modifydate": "1991-08-01T17:37:00", "lines": 121, "newlines": 121, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL  $FSSBA\n.*\n.* MACRO : INTERNALLY USED BY $FS MACRO.\n.* -------\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         GBLA  &FSMDLN,&GMFCI\n         GBLB  &GFUSW,&GFESW,&GFISW\n         GBLC  &GFSMF,&GFSMI\n         LCLA  &BS,&I1,&I2,&R,&C,&LSZ,&NR\n         LCLC  &B1,&B2,&RG\n         AIF   (NOT &GFUSW).USEERR\n         AIF   (N'&SYSLIST(1) NE 2).ARGERR\n         AIF   (&FSMDLN EQ 1).M1\n         AIF   (&FSMDLN EQ 2).M2\n         AIF   (&FSMDLN EQ 3).M3\n         AIF   (&FSMDLN EQ 4).M4\n         AIF   (&FSMDLN EQ 5).M5\n         AGO   .DFLT\n.M1      AIF   (&SYSLIST(1,1) GT 12).M1RERR\n         AIF   (&SYSLIST(1,2) GT 40).M1CERR\n&LSZ     SETA  40\n         AGO   .SROW\n.M3      AIF   (&SYSLIST(1,1) GT 32).M3RERR\n         AIF   (&SYSLIST(1,2) GT 80).M3CERR\n         AGO   .SLNL\n.M4      AIF   (&SYSLIST(1,1) GT 43).M4RERR\n         AIF   (&SYSLIST(1,2) GT 80).M4CERR\n         AGO   .SLNL\n.M5      AIF   (&SYSLIST(1,1) GT 27).M5RERR\n         AIF   (&SYSLIST(1,2) GT 132).M5CERR\n&LSZ     SETA  132\n         AGO   .SROW\n.DFLT    ANOP\n.M2      AIF   (&SYSLIST(1,1) GT 24).M2RERR\n         AIF   (&SYSLIST(1,2) GT 80).M2CERR\n.SLNL    ANOP\n&LSZ     SETA  80\n.SROW    ANOP\n&R       SETA  1\n         AIF   (&SYSLIST(1,1) LE 1).SCOL\n&R       SETA  &SYSLIST(1,1)\n.SCOL    ANOP\n&C       SETA  1\n         AIF   (&SYSLIST(1,2) LE 1).CMPTE\n&C       SETA  &SYSLIST(1,2)\n.CMPTE   ANOP\n&BS      SETA  &LSZ*(&R-1)+&C-1\n&I1      SETA  &BS/64\n&I2      SETA  2*(&BS-(64*&I1)+1)-1\n&I1      SETA  2*(&I1+1)-1\n&B1      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5X\n               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6FX\n               7F8F97A7B7C7D7E7F'(&I1,2)\n&B2      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5X\n               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6FX\n               7F8F97A7B7C7D7E7F'(&I2,2)\n         AIF   (&GFISW).GIX\n         AIF   (&GFESW).GEX\n&LABEL   DC    XL3'11&B1&B2'\n         MEXIT\n.GEX     ANOP\n&LABEL   MVC   0(3,&GFSMF),=XL3'11&B1&B2'\n         LA    &GFSMF,3(,&GFSMF)\n         MEXIT\n.GIX     AIF   ('&GFSMI'(1,1) EQ '(').GIXR\n&LABEL   MVC   &GFSMI+&GMFCI.(3),=XL3'11&B1&B2'\n&GMFCI   SETA  &GMFCI+3\n         MEXIT\n.GIXR    ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVC   &GMFCI.(3,&RG),=XL3'11&B1&B2'\n&GMFCI   SETA  &GMFCI+3\n         MEXIT\n.USEERR  MNOTE 8,'--- INVALID MACRO USAGE'\n         MEXIT\n.ARGERR  MNOTE 8,'--- SBA=(...) INVALID CODING'\n         MEXIT\n.M1RERR  MNOTE 8,'--- SBA - ROW NOT 1 THRU 12 FOR M=1'\n         AGO   .DUMMY\n.M1CERR  MNOTE 8,'--- SBA - COLUMN NOT 1 THRU 40 FOR M=1'\n         AGO   .DUMMY\n.M2RERR  MNOTE 8,'--- SBA - ROW NOT 1 THRU 24 FOR M=2'\n         AGO   .DUMMY\n.M2CERR  MNOTE 8,'--- SBA - COLUMN NOT 1 THRU 80 FOR M=2'\n         AGO   .DUMMY\n.M3RERR  MNOTE 8,'--- SBA - ROW NOT 1 THRU 32 FOR M=3'\n         AGO   .DUMMY\n.M3CERR  MNOTE 8,'--- SBA - COLUMN NOT 1 THRU 80 FOR M=3'\n         AGO   .DUMMY\n.M4RERR  MNOTE 8,'--- SBA - ROW NOT 1 THRU 43 FOR M=4'\n         AGO   .DUMMY\n.M4CERR  MNOTE 8,'--- SBA - COLUMN NOT 1 THRU 80 FOR M=4'\n         AGO   .DUMMY\n.M5RERR  MNOTE 8,'--- SBA - ROW NOT 1 THRU 27 FOR M=5'\n         AGO   .DUMMY\n.M5CERR  MNOTE 8,'--- SBA - COLUMN NOT 1 THRU 132 FOR M=5'\n.DUMMY   AIF   (&GFISW).GXI\n         AIF   (&GFESW).GXQ\n&LABEL   DC    XL3'110000'\n         MEXIT\n.GXQ     ANOP\n&LABEL   MVC   0(3,&GFSMF),=XL3'110000'\n         LA    &GFSMF,3(,&GFSMF)\n         MEXIT\n.GXI     AIF   ('&GFSMI'(1,1) EQ '(').GXIR\n&LABEL   MVC   &GFSMI+&GMFCI.(3),=XL3'110000'\n&GMFCI   SETA  &GMFCI+3\n         MEXIT\n.GXIR    ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVC   &GMFCI.(3,&RG),=XL3'110000'\n&GMFCI   SETA  &GMFCI+3\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FSSET": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x19\\x1f\\x00\\x91\\x19\\x1f\\x16\\x08\\x00{\\x00{\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-07-10T00:00:00", "modifydate": "1991-07-10T16:08:00", "lines": 123, "newlines": 123, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL  $FSSET\n.*\n.* MACRO : INTERNALLY USED BY $FS MACRO.\n.* -------\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         GBLA  &GMFCI\n         GBLB  &GFUSW,&GFESW,&GFISW\n         GBLC  &GFSMF,&GFSMI\n         LCLA  &L,&N,&NR\n         LCLC  &O,&RG,&SCH,&T1,&T2\n         AIF   (NOT &GFUSW).USEERR\n         AIF   (N'&SYSLIST(1) EQ 1).HEX\n         AIF   (N'&SYSLIST(1) NE 2).ARGERR\n         AIF   (K'&SYSLIST(1,1) NE 2).ARGERR\n         AIF   ('&SYSLIST(1,1)' NE 'GE').ARGERR\n&SCH     SETC  '&SYSLIST(1,2)'\n         AIF   (K'&SCH NE 4).NF\n         AIF   ('&SCH' NE 'FILL').ARGERR\n&SCH     SETC  '00'\n         AGO   .STC\n.NF      AIF   (K'&SCH NE 2).ARGERR\n&T1      SETC  '&SCH'(1,1)\n&T2      SETC  '&SCH'(2,1)\n         AIF   ('&T1' EQ '4').TSN\n         AIF   ('&T1' EQ '5').TSN\n         AIF   ('&T1' EQ '6').TSN\n         AIF   ('&T1' EQ '7').TSN\n         AIF   ('&T1' EQ '8').TSN\n         AIF   ('&T1' EQ '9').TSN\n         AIF   ('&T1' EQ 'A').TSN\n         AIF   ('&T1' EQ 'B').TSN\n         AIF   ('&T1' EQ 'C').TSN\n         AIF   ('&T1' EQ 'D').TSN\n         AIF   ('&T1' EQ 'E').TSN\n         AIF   ('&T1' NE 'F').ARGERR\n.TSN     AIF   ('&T2' EQ '0').STC\n         AIF   ('&T2' EQ '1').STC\n         AIF   ('&T2' EQ '2').STC\n         AIF   ('&T2' EQ '3').STC\n         AIF   ('&T2' EQ '4').STC\n         AIF   ('&T2' EQ '5').STC\n         AIF   ('&T2' EQ '6').STC\n         AIF   ('&T2' EQ '7').STC\n         AIF   ('&T2' EQ '8').STC\n         AIF   ('&T2' EQ '9').STC\n         AIF   ('&T2' EQ 'A').STC\n         AIF   ('&T2' EQ 'B').STC\n         AIF   ('&T2' EQ 'C').STC\n         AIF   ('&T2' EQ 'D').STC\n         AIF   ('&T2' EQ 'E').STC\n         AIF   ('&T1' EQ 'F').ARGERR\n         AIF   ('&T2' NE 'F').ARGERR\n.STC     ANOP\n&O       SETC  '08'\n&L       SETA  2\n         AIF   (&GFISW).GIX\n         AIF   (&GFESW).GEX\n&LABEL   DC    XL&L.'&O&SCH'\n         MEXIT\n.GEX     ANOP\n&LABEL   MVC   0(&L,&GFSMF),=XL&L.'&O&SCH'\n         LA    &GFSMF,&L.(,&GFSMF)\n         MEXIT\n.GIX     AIF   ('&GFSMI'(1,1) EQ '(').GIXR\n&LABEL   MVC   &GFSMI+&GMFCI.(&L),=XL&L.'&O&SCH'\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.GIXR    ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVC   &GMFCI.(&L,&RG),=XL&L.'&O&SCH'\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.HEX     AIF   ('&SYSLIST(1)'(1,1) NE '(').APS\n&N       SETA  K'&SYSLIST(1)\n         AIF   ('&SYSLIST(1)'(&N,1) NE ')').ARGERR\n         AGO   .SST\n.APS     AIF   ('&SYSLIST(1)'(1,1) NE '''').STR\n&N       SETA  K'&SYSLIST(1)\n         AIF   ('&SYSLIST(1)'(&N,1) NE '''').APSERR\n.SST     ANOP\n&N       SETA  K'&SYSLIST(1)-2\n&SCH     SETC  '&SYSLIST(1)'(2,&N)\n         AGO   .THX\n.STR     ANOP\n&SCH     SETC  '&SYSLIST(1)'\n.THX     ANOP\n&N       SETA  K'&SCH\n&L       SETA  &N/2\n&NR      SETA  &L*2\n         AIF   (&NR NE &N).HEXERR\n         AIF   (&GFISW).GHIX\n         AIF   (&GFESW).GHEX\n&LABEL   DC    XL&L.'&SCH'\n         MEXIT\n.GHEX    ANOP\n&LABEL   MVC   0(&L,&GFSMF),=XL&L.'&SCH'\n         LA    &GFSMF,&L.(,&GFSMF)\n         MEXIT\n.GHIX    AIF   ('&GFSMI'(1,1) EQ '(').GHIXR\n&LABEL   MVC   &GFSMI+&GMFCI.(&L),=XL&L.'&SCH'\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.GHIXR   ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVC   &GMFCI.(&L,&RG),=XL&L.'&SCH'\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.USEERR  MNOTE 8,'--- INVALID MACRO USAGE'\n         MEXIT\n.ARGERR  MNOTE 8,'--- SET=(...) INVALID CODING'\n         MEXIT\n.APSERR  MNOTE 8,'--- SET=''...'' INVALID CODING'\n         MEXIT\n.HEXERR  MNOTE 8,'--- SET=... INVALID HEXADECIMAL LENGTH CODING'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FSSF": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x18o\\x00\\x91\\x18o\\x11D\\x00{\\x00{\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-07-05T00:00:00", "modifydate": "1991-07-05T11:44:00", "lines": 123, "newlines": 123, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL  $FSSF\n.*\n.* MACRO : INTERNALLY USED BY $FS MACRO.\n.* -------\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         GBLA  &GMFCI\n         GBLB  &GFUSW,&GFESW,&GFISW\n         GBLC  &GFSMF,&GFSMI\n         LCLA  &ATT,&N,&I,&L,&M1,&M2,&M3,&M4,&NR\n         LCLC  &ATTRB,&PT,&IC,&SF,&RG\n         AIF   (NOT &GFUSW).USEERR\n&N       SETA  N'&SYSLIST(1)\n         AIF   (&N EQ 0).GSF\n         AIF   ('&SYSLIST(1)' EQ 'NORMAL').GSF\n         AIF   ('&SYSLIST(1)' EQ 'PT').SPT\n         AIF   ('&SYSLIST(1)' EQ 'IC').SIC\n         AIF   ('&SYSLIST(1,1)' EQ 'IC').SIC\n         AIF   ('&SYSLIST(1,1)' NE 'PT').SCAN\n.SPT     ANOP\n&L       SETA  &L+1\n&PT      SETC  '05'\n         AIF   (&N EQ 1).GPI\n&I       SETA  &I+1\n         AIF   ('&SYSLIST(1,2)' NE 'IC').TPI\n.SIC     ANOP\n&L       SETA  &L+1\n&IC      SETC  '13'\n         AIF   (&N EQ 2).GPI\n&I       SETA  &I+1\n.TPI     ANOP\n&I       SETA  &I+1\n         AIF   (&I GT &N).GPI\n&ATTRB   SETC  '&SYSLIST(1,&I)'\n         MNOTE 4,'--- REMAINING KEYWORD &ATTRB - IGNORED'\n         AGO   .TPI\n.SCAN    ANOP\n&I       SETA  &I+1\n         AIF   (&I GT &N).GSF\n         AIF   ('&SYSLIST(1,&I)' EQ 'SKIP').SKIP\n         AIF   ('&SYSLIST(1,&I)' EQ 'PROT').PROT\n         AIF   ('&SYSLIST(1,&I)' EQ 'NUM').NUM\n         AIF   ('&SYSLIST(1,&I)' EQ 'DARK').DARK\n         AIF   ('&SYSLIST(1,&I)' EQ 'INT').INT\n         AIF   ('&SYSLIST(1,&I)' EQ 'HIGH').INT\n         AIF   ('&SYSLIST(1,&I)' EQ 'PEN').PEN\n         AIF   ('&SYSLIST(1,&I)' EQ 'MED').PEN\n         AIF   ('&SYSLIST(1,&I)' EQ 'MDT').MDT\n         AIF   ('&SYSLIST(1,&I)' EQ 'PT').FPT\n         AIF   ('&SYSLIST(1,&I)' EQ 'IC').FIC\n&ATTRB   SETC  '&SYSLIST(1,&I)'\n         MNOTE 4,'--- UNKNOWN KEYWORD &ATTRB - IGNORED'\n         AGO   .SCAN\n.SKIP    ANOP\n&M4      SETA  32\n&M3      SETA  16\n         AGO   .SCAN\n.PROT    ANOP\n&M4      SETA  32\n         AGO   .SCAN\n.NUM     ANOP\n&M3      SETA  16\n         AGO   .SCAN\n.DARK    ANOP\n&M2      SETA  12\n         AGO   .SCAN\n.INT     ANOP\n&M2      SETA  8\n         AGO   .SCAN\n.PEN     ANOP\n&M2      SETA  4\n         AGO   .SCAN\n.MDT     ANOP\n&M1      SETA  1\n         AGO   .SCAN\n.FPT     ANOP\n&L       SETA  &L+1\n&PT      SETC  '05'\n&I       SETA  &I+1\n         AIF   (&I GT &N).GSF\n         AIF   ('&SYSLIST(1,&I)' NE 'IC').RKI\n.FIC     ANOP\n&L       SETA  &L+1\n&IC      SETC  '13'\n.TEL     ANOP\n&I       SETA  &I+1\n         AIF   (&I GT &N).GSF\n.RKI     ANOP\n&ATTRB   SETC  '&SYSLIST(1,&I)'\n         MNOTE 4,'--- REMAINING KEYWORD &ATTRB - IGNORED'\n         AGO   .TEL\n.GSF     ANOP\n&ATT     SETA  2*(&M1+&M2+&M3+&M4)+1\n&ATTRB   SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5X\n               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6FX\n               7F8F97A7B7C7D7E7F'(&ATT,2)\n&L       SETA   &L+2\n&SF      SETC  '1D'\n.GPI     AIF   (&GFISW).GIX\n         AIF   (&GFESW).GEX\n&LABEL   DC    XL&L'&SF&ATTRB&PT&IC'\n         MEXIT\n.GEX     ANOP\n&LABEL   MVC   0(&L,&GFSMF),=XL&L'&SF&ATTRB&PT&IC'\n         LA    &GFSMF,&L.(,&GFSMF)\n         MEXIT\n.GIX     AIF   ('&GFSMI'(1,1) EQ '(').GIXR\n&LABEL   MVC   &GFSMI+&GMFCI.(&L),=XL&L'&SF&ATTRB&PT&IC'\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.GIXR    ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVC   &GMFCI.(&L,&RG),=XL&L'&SF&ATTRB&PT&IC'\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.USEERR  MNOTE 8,'--- INVALID MACRO USAGE'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FSSFE": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x17\\x1f\\x00\\x91\\x17\\x1f\\x14(\\x00K\\x00K\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-06-20T00:00:00", "modifydate": "1991-06-20T14:28:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL  $FSSFE\n.*\n.* MACRO : INTERNALLY USED BY $FS MACRO.\n.* -------\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         GBLA  &GMFCI\n         GBLB  &GFUSW,&GFESW,&GFISW,&GFWSW\n         GBLC  &GFSMF,&GFSMI,&GFSOP,&GFWTY,&GFWVA\n         LCLA  &I,&L,&N,&NA,&NR,&T,&U\n         LCLC  &CC,&CT,&CU,&RG,&TY,&VA\n         AIF   (NOT &GFUSW).USEERR\n&N       SETA  N'&SYSLIST(1)\n         AIF   (&N LE 1).ARGERR\n&NA      SETA  &N/2\n         AIF   (&NA GT 255).ARGERR\n&L       SETA  &NA*2\n         AIF   (&N NE &L).ARGERR\n&T       SETA  1+(&NA/16)\n&U       SETA  1+(&NA-((&NA/16)*16))\n&CT      SETC  '0123456789ABCDEF'(&T,1)\n&CU      SETC  '0123456789ABCDEF'(&U,1)\n&CC      SETC  '&CT&CU'\n&I       SETA  1\n.LOOP    ANOP\n&N       SETA  &I+1\n&TY      SETC  '&SYSLIST(1,&I)'\n&VA      SETC  '&SYSLIST(1,&N)'\n        $FS$TV &TY,&VA\n         AIF   (NOT &GFWSW).TGX\n         MEXIT\n.TGX     AIF   (&GFISW).MVI\n         AIF   (&GFESW).MVL\n         AIF   (&I NE 1).CNT\n&LABEL   DC    XL4'&GFSOP&CC&GFWTY&GFWVA'\n         AGO   .NXT\n.CNT     DC    XL2'&GFWTY&GFWVA'\n         AGO   .NXT\n.MVL     AIF   (&I NE 1).MVLC\n&LABEL   MVC   0(4,&GFSMF),=XL4'&GFSOP&CC&GFWTY&GFWVA'\n         LA    &GFSMF,4(,&GFSMF)\n         AGO   .NXT\n.MVLC    MVC   0(2,&GFSMF),=XL2'&GFWTY&GFWVA'\n         LA    &GFSMF,2(,&GFSMF)\n         AGO   .NXT\n.MVI     AIF   ('&GFSMI'(1,1) EQ '(').MVIR\n         AIF   (&I NE 1).MVIC\n&LABEL   MVC   &GFSMI+&GMFCI.(4),=XL4'&GFSOP&CC&GFWTY&GFWVA'\n&GMFCI   SETA  &GMFCI+4\n         AGO   .NXT\n.MVIC    MVC   &GFSMI+&GMFCI.(2),=XL2'&GFWTY&GFWVA'\n&GMFCI   SETA  &GMFCI+2\n         AGO   .NXT\n.MVIR    ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n         AIF   (&I NE 1).MVIRC\n&LABEL   MVC   &GMFCI.(4,&RG),=XL4'&GFSOP&CC&GFWTY&GFWVA'\n&GMFCI   SETA  &GMFCI+4\n         AGO   .NXT\n.MVIRC   MVC   &GMFCI.(2,&RG),=XL2'&GFWTY&GFWVA'\n&GMFCI   SETA  &GMFCI+2\n.NXT     ANOP\n&I       SETA  &I+2\n         AIF   (&I LT &L).LOOP\n         MEXIT\n.ARGERR  MNOTE 8,'--- SFE=(...) INVALID CODING'\n         MEXIT\n.USEERR  MNOTE 8,'--- INVALID MACRO USAGE'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FSTXT": {"ttr": 2832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x16O\\x00\\x91\\x16O\\x14\\x00\\x00U\\x00U\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-06-13T00:00:00", "modifydate": "1991-06-13T14:00:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL  $FSTXT &TXT\n.*\n.* MACRO : INTERNALLY USED BY $FS MACRO.\n.* -------\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         GBLA  &GMFCI\n         GBLB  &GFUSW,&GFESW,&GFISW\n         GBLC  &GFSMF,&GFSMI\n         LCLA  &N,&I,&L,&W,&NR\n         LCLC  &RG\n         AIF   (NOT &GFUSW).USEERR\n         AIF   ('&TXT'(1,1) NE '(').NLG\n         AIF   ('&TXT(2)'(1,1) LT '0').NUMERR\n         AIF   (&GFISW).MVI\n         AIF   (&GFESW).MVL\n&LABEL   DC    CL&TXT(2)&TXT(1)\n         MEXIT\n.MVL     ANOP\n&LABEL   MVC   0(&TXT(2),&GFSMF),=CL&TXT(2)&TXT(1)\n         LA    &GFSMF,&TXT(2).(,&GFSMF)\n         MEXIT\n.MVI     AIF   ('&GFSMI'(1,1) EQ '(').MVIR\n&LABEL   MVC   &GFSMI+&GMFCI.(&TXT(2)),=CL&TXT(2)&TXT(1)\n&N       SETA  &TXT(2)\n&GMFCI   SETA  &GMFCI+&N\n         MEXIT\n.MVIR    ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVC   &GMFCI.(&TXT(2),&RG),=CL&TXT(2)&TXT(1)\n&N       SETA  &TXT(2)\n&GMFCI   SETA  &GMFCI+&N\n         MEXIT\n.NLG     ANOP\n&N       SETA  K'&TXT\n         AIF   ('&TXT'(1,1) NE '''').ARGERR\n         AIF   ('&TXT'(&N,1) NE '''').ARGERR\n&I       SETA  2\n&N       SETA  &N-1\n.SCAN    AIF   (&I GT &N).CNTL\n         AIF   ('&TXT'(&I,1) NE '''').TAM\n&I       SETA  &I+1\n         AIF   (&I GT &N).ARGERR\n         AIF   ('&TXT'(&I,1) NE '''').ARGERR\n         AGO   .ADD\n.TAM     ANOP\n&W       SETA  &I+1\n         AIF   (&W GT &N).ADD\n         AIF   ('&TXT'(&I,2) NE '&&').ADD\n&I       SETA  &W\n.ADD     ANOP\n&L       SETA  &L+1\n&I       SETA  &I+1\n         AGO   .SCAN\n.CNTL    AIF   (&L EQ 0).ARGERR\n         AIF   (&GFISW).MI\n         AIF   (&GFESW).MV\n&LABEL   DC    CL&L&TXT\n         MEXIT\n.MV      ANOP\n&LABEL   MVC   0(&L,&GFSMF),=CL&L&TXT\n         LA    &GFSMF,&L.(,&GFSMF)\n         MEXIT\n.MI      AIF   ('&GFSMI'(1,1) EQ '(').MIR\n&LABEL   MVC   &GFSMI+&GMFCI.(&L),=CL&L&TXT\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.MIR     ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n&LABEL   MVC   &GMFCI.(&L,&RG),=CL&L&TXT\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.USEERR  MNOTE 8,'--- MACRO USAGE INVALID'\n         MEXIT\n.NUMERR  MNOTE 8,'--- NOT ABSOLUTE NUMERIC TEXT LENGTH VALUE'\n         MEXIT\n.ARGERR  MNOTE 8,'--- TEXT=... INVALID CODING'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FSWCC": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x16O\\x00\\x91\\x16O\\x14\\x00\\x00\\x7f\\x00\\x7f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-06-13T00:00:00", "modifydate": "1991-06-13T14:00:00", "lines": 127, "newlines": 127, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&LABEL  $FSWCC\n.*\n.* MACRO : INTERNALLY USED BY $FS MACRO.\n.* -------\n.*\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         GBLA  &GMFCI\n         GBLB  &GFUSW,&GFESW,&GFISW\n         GBLC  &GFSMF,&GFSMI\n         LCLA  &ATT,&N,&I,&L,&M1,&M2,&M3,&M4,&M5,&NR\n         LCLB  &CLRSW\n         LCLC  &ATTRB,&OFF,&RG\n         AIF   (NOT &GFUSW).USEERR\n&N       SETA  N'&SYSLIST(1)\n         AIF   (&N EQ 0).ARGERR\n         AIF   ('&SYSLIST(1)' EQ 'OFF').OFF\n         AIF   ('&SYSLIST(1)' EQ 'CLEAR').CLR\n         AIF   ('&SYSLIST(1,1)' NE 'OFF').TSC\n.OFF     ANOP\n         AIF   (&N GT 2).ARGERR\n&CLRSW   SETB  1\n&M1      SETA  1\n&M2      SETA  2\n&L       SETA  12\n&OFF     SETC  '11404013'\n         AIF   (&N EQ 1).GWCC\n         AIF   ('&SYSLIST(1,2)' NE 'AL').NAL\n&M3      SETA  4\n         AGO   .GWCC\n.NAL     ANOP\n&ATTRB   SETC  '&SYSLIST(1,2)'\n         MNOTE 4,'--- UNKNOWN KEYWORD &ATTRB - IGNORED'\n         AGO   .GWCC\n.TSC     AIF   ('&SYSLIST(1,1)' NE 'CLEAR').SCAN\n.CLR     ANOP\n&CLRSW   SETB  1\n&L       SETA  8\n&I       SETA  1\n.SCAN    ANOP\n&I       SETA  &I+1\n         AIF   (&I GT &N).GWCC\n         AIF   (&CLRSW).SKIP\n         AIF   ('&SYSLIST(1,&I)' EQ 'NE').NE\n         AIF   ('&SYSLIST(1,&I)' EQ 'P40').P40\n         AIF   ('&SYSLIST(1,&I)' EQ 'P64').P64\n         AIF   ('&SYSLIST(1,&I)' EQ 'P80').P80\n         AIF   ('&SYSLIST(1,&I)' EQ 'SP').SP\n.SKIP    AIF   ('&SYSLIST(1,&I)' EQ 'AL').AL\n         AIF   ('&SYSLIST(1,&I)' EQ 'KBR').KBR\n         AIF   ('&SYSLIST(1,&I)' EQ 'RMDT').RMDT\n&ATTRB   SETC  '&SYSLIST(1,&I)'\n         MNOTE 4,'--- UNKNOWN KEYWORD &ATTRB - IGNORED'\n         AGO   .SCAN\n.NE      ANOP\n&M5      SETA  0\n         AGO   .SCAN\n.P40     ANOP\n&M5      SETA  16\n         AGO   .SCAN\n.P64     ANOP\n&M5      SETA  32\n         AGO   .SCAN\n.P80     ANOP\n&M5      SETA  48\n         AGO   .SCAN\n.SP      ANOP\n&M4      SETA  8\n         AGO   .SCAN\n.AL      ANOP\n&M3      SETA  4\n         AGO   .SCAN\n.KBR     ANOP\n&M2      SETA  2\n         AGO   .SCAN\n.RMDT    ANOP\n&M1      SETA  1\n         AGO   .SCAN\n.GWCC    ANOP\n&ATT     SETA  2*(&M1+&M2+&M3+&M4+&M5)+1\n&ATTRB   SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5X\n               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6FX\n               7F8F97A7B7C7D7E7F'(&ATT,2)\n         AIF   (&GFISW).GIX\n         AIF   (&GFESW).GEX\n         AIF   (&CLRSW).GCLR\n&LABEL   DC    XL1'&ATTRB'\n         MEXIT\n.GCLR    ANOP\n&LABEL   DC    XL&L'&ATTRB.1140403C404000&OFF'\n         MEXIT\n.GEX     AIF   (&CLRSW).GCLM\n&LABEL   MVI   0(&GFSMF),X'&ATTRB'\n         LA    &GFSMF,1(,&GFSMF)\n         MEXIT\n.GCLM    ANOP\n&LABEL   MVC   0(&L,&GFSMF),=XL&L'&ATTRB.1140403C404000&OFF'\n         LA    &GFSMF,&L.(,&GFSMF)\n         MEXIT\n.GIX     AIF   ('&GFSMI'(1,1) EQ '(').GIXR\n         AIF   (&CLRSW).GCLI\n&LABEL   MVI   &GFSMI+&GMFCI,X'&ATTRB'\n&GMFCI   SETA  &GMFCI+1\n         MEXIT\n.GCLI    ANOP\n&LABEL   MVC   &GFSMI+&GMFCI.(&L),=XL&L'&ATTRB.1140403C404000&OFF'\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.GIXR    ANOP\n&NR      SETA  K'&GFSMI-2\n&RG      SETC  '&GFSMI'(2,&NR)\n         AIF   (&CLRSW).GCLIR\n&LABEL   MVI   &GMFCI.(&RG),X'&ATTRB'\n&GMFCI   SETA  &GMFCI+1\n         MEXIT\n.GCLIR   ANOP\n&LABEL   MVC   &GMFCI.(&L,&RG),=XL&L'&ATTRB.1140403C404000&OFF'\n&GMFCI   SETA  &GMFCI+&L\n         MEXIT\n.USEERR  MNOTE 8,'--- INVALID MACRO USAGE'\n         MEXIT\n.ARGERR  MNOTE 8,'--- WCC=(...) INVALID CODING'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GDATE": {"ttr": 3078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x80\\x00\\x80\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL GDATE SUPPLY.\n&NAME   $GDATE      &A,&B,&C,&D,&E,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $GDATE MACRO : CALL GDATE SUPPLY (SEE GDATE).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 5).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0,0,0)          P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(GDATE)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(GDATE)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GFDATE": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89#?\\x00\\x89#?\\x11S\\x00\\x80\\x00\\x80\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-21T00:00:00", "modifydate": "1989-08-21T11:53:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL GFDATE SUPPLY.\n&NAME   $GFDATE     &A,&B,&C,&D,&E,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $GFDATE MACRO : CALL GFDATE SUPPLY (SEE GFDATE).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 5).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0,0,0)          P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(GFDATE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(GFDATE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GGUCL": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00[\\x00[\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL GGUCL SUPPLY.\n&NAME   $GGUCL      &A,&MF=\n         LCLA  &Y\n         LCLB  &W\n         LCLC  &X\n.*\n.* $GGUCL MACRO : CALL GGUCL SUPPLY (SEE GGUCL/GGUR).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 1).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS1\n         AIF   (T'&A EQ 'O').LS1\n         AIF   ('&A'(1,1) EQ '(').REG\n&NAME    DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.LS1     ANOP\n&NAME    DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n         AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL13\n         AIF   (T'&A EQ 'O').XL13\n         AIF   ('&A'(1,1) EQ '(').XL11\n         LA    15,&A\n         ST    15,0(1)             STORE INTO PARM. LIST.\n         AGO   .XL12\n.XL11    ST    &A(1,1),0(1)        STORE INTO PARM. LIST.\n.XL12    OI    0(1),X'80'          SET LAST WORD BIT ON.\n.XL13    AIF   (&W).XL14\n         L     15,=V(GGUCL)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL14    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O').NL1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   ('&A'(1,1) NE '(').XI3\n         ST    &A(1,1),&X          STORE INTO PARM. LIST.\n         OI    &X,X'80'            SET LAST WORD BIT ON.\n.XI3     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n         AIF   ('&A'(1,1) EQ '(').XI4\n         DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         AGO   .XI5\n.XI4     DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n.XI5     ANOP\n&X.A     L     15,=V(GGUCL)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(GGUCL)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GGUR": {"ttr": 3087, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL GGUR SUPPLY.\n&NAME   $GGUR       &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $GGUR MACRO : CALL GGUR SUPPLY (SEE GGUR).\n.* -------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 2).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 2).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(GGUR)         LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(GGUR)         LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GSDATE": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89#?\\x00\\x89#?\\x15D\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-21T00:00:00", "modifydate": "1989-08-21T15:44:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL GSDATE SUPPLY.\n&NAME   $GSDATE     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $GSDATE MACRO : CALL GSDATE SUPPLY (SEE GSDATE).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 2).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 2).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(GSDATE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(GSDATE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GUACL": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00[\\x00[\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL GUACL SUPPLY.\n&NAME   $GUACL      &A,&MF=\n         LCLA  &Y\n         LCLB  &W\n         LCLC  &X\n.*\n.* $GUACL MACRO : CALL GUACL SUPPLY (SEE GUACL/GUAR).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 1).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS1\n         AIF   (T'&A EQ 'O').LS1\n         AIF   ('&A'(1,1) EQ '(').REG\n&NAME    DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.LS1     ANOP\n&NAME    DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n         AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL13\n         AIF   (T'&A EQ 'O').XL13\n         AIF   ('&A'(1,1) EQ '(').XL11\n         LA    15,&A\n         ST    15,0(1)             STORE INTO PARM. LIST.\n         AGO   .XL12\n.XL11    ST    &A(1,1),0(1)        STORE INTO PARM. LIST.\n.XL12    OI    0(1),X'80'          SET LAST WORD BIT ON.\n.XL13    AIF   (&W).XL14\n         L     15,=V(GUACL)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL14    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O').NL1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   ('&A'(1,1) NE '(').XI3\n         ST    &A(1,1),&X          STORE INTO PARM. LIST.\n         OI    &X,X'80'            SET LAST WORD BIT ON.\n.XI3     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n         AIF   ('&A'(1,1) EQ '(').XI4\n         DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         AGO   .XI5\n.XI4     DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n.XI5     ANOP\n&X.A     L     15,=V(GUACL)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(GUACL)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GUAR": {"ttr": 3337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL GUAR SUPPLY.\n&NAME   $GUAR       &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $GUAR MACRO : CALL GUAR SUPPLY (SEE GUAR).\n.* -------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 2).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 2).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(GUAR)         LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(GUAR)         LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$HEDIT": {"ttr": 3340, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16&\\x02\\xe2\\x02\\xe2\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:26:00", "lines": 738, "newlines": 738, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           HEADER EDIT.\n&NAME   $HEDIT &STRING\n.*\n.* $HEDIT MACRO : HEADER EDIT.\n.* --------------\n.*\n.* STRING OPERAND - TEXT WHICH IS EXPANDED AND BLOCKS PRINTED\n.*                  BY GROUP OF 8 CHARACTERS (THE MAXIMUM STRING\n.*                  LENGTH IS 40 CHARACTERS). IF THIS OPERAND IS\n.*                  OMITTED, THE NAME ENTRY OF THE STATEMENT (THIS\n.*                  NAME CAN BE REFERENCED AS LABEL IN THE ASSEMBLY),\n.*                  IF PRESENT, OR THE CURRENT CSECT NAME, IS USED.\n.*\n.*                  NOTE - IF A BLANK AND/OR A COMMA MUST BE USED,\n.*                         THE CHARACTER STRING MUST BE ENCLOSED\n.*                         WITHIN APOSTROPHES. A DOUBLE APOSTROPHE\n.*                         AND/OR AMPERSAND MUST BE USED TO GENERATE A\n.*                         SINGLE ONE AS PART OF THE CHARACTER STRING.\n.*\n.* AUTHOR :    ORIGINAL 'HEDIT' MACRO EXTRACTED FROM 'MIM#3' PROGRAM.\n.* --------    C.J. GOELZ\n.*             GILBERT/COMMONWEALTH COS., INC.\n.*             P.O. BOX 1498\n.*             READING, PA 19603\n.*             PHONE (215) 775-2600 EXT 2252\n.*             SHARE CODE GAI\n.*\n.*             MODIFIED BY : P.A. MOINIL\n.*                           COMPUTING CENTRE\n.*                           J.R.C. - ISPRA ESTABLISHMENT\n.*                           21020 ISPRA (VA), ITALY\n.*\n         LCLA  &I\n         LCLA  &J\n         LCLA  &K\n         LCLA  &L\n         LCLA  &M\n         LCLA  &N\n         LCLC  &NCS\n         LCLC  &IM(50)\n         LCLC  &FLD(64)\n         LCLC  &STR(55)\n         LCLC  &C(513)\n.*\n.*       BLOCK CHARACTERS TABLES.\n.*\n&IM(1)   SETC  '    *   '\n&IM(2)   SETC  '   ***  '\n&IM(3)   SETC  '  ** ** '\n&IM(4)   SETC  ' **   **'\n&IM(5)   SETC  ' *******'\n&IM(6)   SETC  ' ****** '\n&IM(7)   SETC  '  ***** '\n&IM(8)   SETC  ' **     '\n&IM(9)   SETC  ' ****   '\n&IM(10)  SETC  ' *****  '\n&IM(11)  SETC  '   *    '\n&IM(12)  SETC  '  ****  '\n&IM(13)  SETC  '   **   '\n&IM(14)  SETC  '      **'\n&IM(15)  SETC  ' **  ** '\n&IM(16)  SETC  ' ** **  '\n&IM(17)  SETC  ' *     *'\n&IM(18)  SETC  ' *** ***'\n&IM(19)  SETC  ' ** * **'\n&IM(20)  SETC  ' ***  **'\n&IM(21)  SETC  ' **** **'\n&IM(22)  SETC  ' ** ****'\n&IM(23)  SETC  ' **  ***'\n&IM(24)  SETC  ' *  *  *'\n&IM(25)  SETC  '  *   * '\n&IM(26)  SETC  '     ** '\n&IM(27)  SETC  '    **  '\n&IM(28)  SETC  '  **    '\n&IM(29)  SETC  '      * '\n&IM(30)  SETC  '  *     '\n&IM(31)  SETC  '     *  '\n&IM(32)  SETC  '   * *  '\n&IM(33)  SETC  '  *  *  '\n&IM(34)  SETC  '   **** '\n&IM(35)  SETC  ' *  *   '\n&IM(36)  SETC  '    *  *'\n&IM(37)  SETC  '  * * * '\n&IM(38)  SETC  '   ** * '\n&IM(39)  SETC  '       *'\n&IM(40)  SETC  ' *      '\n&IM(41)  SETC  '  ******'\n&IM(42)  SETC  '   *  * '\n&IM(43)  SETC  '  **   *'\n&IM(44)  SETC  '  **  * '\n&IM(45)  SETC  '  *  ** '\n&IM(46)  SETC  ' *   ** '\n&IM(47)  SETC  '  ** ** '\n&IM(48)  SETC  '        '\n&IM(49)  SETC  '        '\n&IM(50)  SETC  '        '\n.*\n&C(1)    SETC  ' '\n&C(2)    SETC  '&IM(50)'\n&C(3)    SETC  '&IM(50)'\n&C(4)    SETC  '&IM(50)'\n&C(5)    SETC  '&IM(50)'\n&C(6)    SETC  '&IM(50)'\n&C(7)    SETC  '&IM(50)'\n&C(8)    SETC  '&IM(50)'\n&C(9)    SETC  '&IM(50)'\n&C(10)   SETC  'A'\n&C(11)   SETC  '&IM(1)'\n&C(12)   SETC  '&IM(2)'\n&C(13)   SETC  '&IM(3)'\n&C(14)   SETC  '&IM(4)'\n&C(15)   SETC  '&IM(4)'\n&C(16)   SETC  '&IM(5)'\n&C(17)   SETC  '&IM(4)'\n&C(18)   SETC  '&IM(4)'\n&C(19)   SETC  'B'\n&C(20)   SETC  '&IM(6)'\n&C(21)   SETC  '&IM(4)'\n&C(22)   SETC  '&IM(4)'\n&C(23)   SETC  '&IM(6)'\n&C(24)   SETC  '&IM(4)'\n&C(25)   SETC  '&IM(4)'\n&C(26)   SETC  '&IM(4)'\n&C(27)   SETC  '&IM(6)'\n&C(28)   SETC  'C'\n&C(29)   SETC  '&IM(41)'\n&C(30)   SETC  '&IM(8)'\n&C(31)   SETC  '&IM(8)'\n&C(32)   SETC  '&IM(8)'\n&C(33)   SETC  '&IM(8)'\n&C(34)   SETC  '&IM(8)'\n&C(35)   SETC  '&IM(8)'\n&C(36)   SETC  '&IM(41)'\n&C(37)   SETC  'D'\n&C(38)   SETC  '&IM(6)'\n&C(39)   SETC  '&IM(4)'\n&C(40)   SETC  '&IM(4)'\n&C(41)   SETC  '&IM(4)'\n&C(42)   SETC  '&IM(4)'\n&C(43)   SETC  '&IM(4)'\n&C(44)   SETC  '&IM(4)'\n&C(45)   SETC  '&IM(6)'\n&C(46)   SETC  'E'\n&C(47)   SETC  '&IM(6)'\n&C(48)   SETC  '&IM(8)'\n&C(49)   SETC  '&IM(8)'\n&C(50)   SETC  '&IM(9)'\n&C(51)   SETC  '&IM(8)'\n&C(52)   SETC  '&IM(8)'\n&C(53)   SETC  '&IM(8)'\n&C(54)   SETC  '&IM(5)'\n&C(55)   SETC  'F'\n&C(56)   SETC  '&IM(5)'\n&C(57)   SETC  '&IM(8)'\n&C(58)   SETC  '&IM(8)'\n&C(59)   SETC  '&IM(10)'\n&C(60)   SETC  '&IM(8)'\n&C(61)   SETC  '&IM(8)'\n&C(62)   SETC  '&IM(8)'\n&C(63)   SETC  '&IM(8)'\n&C(64)   SETC  'G'\n&C(65)   SETC  '&IM(7)'\n&C(66)   SETC  '&IM(4)'\n&C(67)   SETC  '&IM(8)'\n&C(68)   SETC  '&IM(8)'\n&C(69)   SETC  '&IM(23)'\n&C(70)   SETC  '&IM(4)'\n&C(71)   SETC  '&IM(4)'\n&C(72)   SETC  '&IM(7)'\n&C(73)   SETC  'H'\n&C(74)   SETC  '&IM(4)'\n&C(75)   SETC  '&IM(4)'\n&C(76)   SETC  '&IM(4)'\n&C(77)   SETC  '&IM(5)'\n&C(78)   SETC  '&IM(4)'\n&C(79)   SETC  '&IM(4)'\n&C(80)   SETC  '&IM(4)'\n&C(81)   SETC  '&IM(4)'\n&C(82)   SETC  'I'\n&C(83)   SETC  '&IM(12)'\n&C(84)   SETC  '&IM(13)'\n&C(85)   SETC  '&IM(13)'\n&C(86)   SETC  '&IM(13)'\n&C(87)   SETC  '&IM(13)'\n&C(88)   SETC  '&IM(13)'\n&C(89)   SETC  '&IM(13)'\n&C(90)   SETC  '&IM(12)'\n&C(91)   SETC  'J'\n&C(92)   SETC  '&IM(14)'\n&C(93)   SETC  '&IM(14)'\n&C(94)   SETC  '&IM(14)'\n&C(95)   SETC  '&IM(14)'\n&C(96)   SETC  '&IM(14)'\n&C(97)   SETC  '&IM(4)'\n&C(98)   SETC  '&IM(4)'\n&C(99)   SETC  '&IM(7)'\n&C(100)  SETC  'K'\n&C(101)  SETC  '&IM(4)'\n&C(102)  SETC  '&IM(15)'\n&C(103)  SETC  '&IM(16)'\n&C(104)  SETC  '&IM(9)'\n&C(105)  SETC  '&IM(9)'\n&C(106)  SETC  '&IM(16)'\n&C(107)  SETC  '&IM(15)'\n&C(108)  SETC  '&IM(4)'\n&C(109)  SETC  'L'\n&C(110)  SETC  '&IM(8)'\n&C(111)  SETC  '&IM(8)'\n&C(112)  SETC  '&IM(8)'\n&C(113)  SETC  '&IM(8)'\n&C(114)  SETC  '&IM(8)'\n&C(115)  SETC  '&IM(8)'\n&C(116)  SETC  '&IM(8)'\n&C(117)  SETC  '&IM(5)'\n&C(118)  SETC  'M'\n&C(119)  SETC  '&IM(17)'\n&C(120)  SETC  '&IM(4)'\n&C(121)  SETC  '&IM(18)'\n&C(122)  SETC  '&IM(5)'\n&C(123)  SETC  '&IM(19)'\n&C(124)  SETC  '&IM(4)'\n&C(125)  SETC  '&IM(4)'\n&C(126)  SETC  '&IM(4)'\n&C(127)  SETC  'N'\n&C(128)  SETC  '&IM(4)'\n&C(129)  SETC  '&IM(20)'\n&C(130)  SETC  '&IM(20)'\n&C(131)  SETC  '&IM(21)'\n&C(132)  SETC  '&IM(22)'\n&C(133)  SETC  '&IM(23)'\n&C(134)  SETC  '&IM(23)'\n&C(135)  SETC  '&IM(4)'\n&C(136)  SETC  'O'\n&C(137)  SETC  '&IM(7)'\n&C(138)  SETC  '&IM(4)'\n&C(139)  SETC  '&IM(4)'\n&C(140)  SETC  '&IM(4)'\n&C(141)  SETC  '&IM(4)'\n&C(142)  SETC  '&IM(4)'\n&C(143)  SETC  '&IM(4)'\n&C(144)  SETC  '&IM(7)'\n&C(145)  SETC  'P'\n&C(146)  SETC  '&IM(6)'\n&C(147)  SETC  '&IM(4)'\n&C(148)  SETC  '&IM(4)'\n&C(149)  SETC  '&IM(4)'\n&C(150)  SETC  '&IM(6)'\n&C(151)  SETC  '&IM(8)'\n&C(152)  SETC  '&IM(8)'\n&C(153)  SETC  '&IM(8)'\n&C(154)  SETC  'Q'\n&C(155)  SETC  '&IM(7)'\n&C(156)  SETC  '&IM(4)'\n&C(157)  SETC  '&IM(4)'\n&C(158)  SETC  '&IM(4)'\n&C(159)  SETC  '&IM(4)'\n&C(160)  SETC  '&IM(22)'\n&C(161)  SETC  '&IM(23)'\n&C(162)  SETC  '&IM(7)'\n&C(163)  SETC  'R'\n&C(164)  SETC  '&IM(6)'\n&C(165)  SETC  '&IM(4)'\n&C(166)  SETC  '&IM(4)'\n&C(167)  SETC  '&IM(4)'\n&C(168)  SETC  '&IM(6)'\n&C(169)  SETC  '&IM(16)'\n&C(170)  SETC  '&IM(15)'\n&C(171)  SETC  '&IM(4)'\n&C(172)  SETC  'S'\n&C(173)  SETC  '&IM(7)'\n&C(174)  SETC  '&IM(4)'\n&C(175)  SETC  '&IM(8)'\n&C(176)  SETC  '&IM(7)'\n&C(177)  SETC  '&IM(14)'\n&C(178)  SETC  '&IM(14)'\n&C(179)  SETC  '&IM(4)'\n&C(180)  SETC  '&IM(7)'\n&C(181)  SETC  'T'\n&C(182)  SETC  '&IM(5)'\n&C(183)  SETC  '&IM(13)'\n&C(184)  SETC  '&IM(13)'\n&C(185)  SETC  '&IM(13)'\n&C(186)  SETC  '&IM(13)'\n&C(187)  SETC  '&IM(13)'\n&C(188)  SETC  '&IM(13)'\n&C(189)  SETC  '&IM(13)'\n&C(190)  SETC  'U'\n&C(191)  SETC  '&IM(4)'\n&C(192)  SETC  '&IM(4)'\n&C(193)  SETC  '&IM(4)'\n&C(194)  SETC  '&IM(4)'\n&C(195)  SETC  '&IM(4)'\n&C(196)  SETC  '&IM(4)'\n&C(197)  SETC  '&IM(4)'\n&C(198)  SETC  '&IM(7)'\n&C(199)  SETC  'V'\n&C(200)  SETC  '&IM(4)'\n&C(201)  SETC  '&IM(4)'\n&C(202)  SETC  '&IM(4)'\n&C(203)  SETC  '&IM(4)'\n&C(204)  SETC  '&IM(4)'\n&C(205)  SETC  '&IM(3)'\n&C(206)  SETC  '&IM(2)'\n&C(207)  SETC  '&IM(1)'\n&C(208)  SETC  'W'\n&C(209)  SETC  '&IM(4)'\n&C(210)  SETC  '&IM(4)'\n&C(211)  SETC  '&IM(4)'\n&C(212)  SETC  '&IM(4)'\n&C(213)  SETC  '&IM(19)'\n&C(214)  SETC  '&IM(5)'\n&C(215)  SETC  '&IM(18)'\n&C(216)  SETC  '&IM(25)'\n&C(217)  SETC  'X'\n&C(218)  SETC  '&IM(4)'\n&C(219)  SETC  '&IM(4)'\n&C(220)  SETC  '&IM(3)'\n&C(221)  SETC  '&IM(2)'\n&C(222)  SETC  '&IM(2)'\n&C(223)  SETC  '&IM(3)'\n&C(224)  SETC  '&IM(4)'\n&C(225)  SETC  '&IM(4)'\n&C(226)  SETC  'Y'\n&C(227)  SETC  '&IM(4)'\n&C(228)  SETC  '&IM(4)'\n&C(229)  SETC  '&IM(4)'\n&C(230)  SETC  '&IM(3)'\n&C(231)  SETC  '&IM(2)'\n&C(232)  SETC  '&IM(13)'\n&C(233)  SETC  '&IM(13)'\n&C(234)  SETC  '&IM(13)'\n&C(235)  SETC  'Z'\n&C(236)  SETC  '&IM(5)'\n&C(237)  SETC  '&IM(14)'\n&C(238)  SETC  '&IM(26)'\n&C(239)  SETC  '&IM(27)'\n&C(240)  SETC  '&IM(13)'\n&C(241)  SETC  '&IM(28)'\n&C(242)  SETC  '&IM(8)'\n&C(243)  SETC  '&IM(5)'\n&C(244)  SETC  '1'\n&C(245)  SETC  '&IM(1)'\n&C(246)  SETC  '&IM(13)'\n&C(247)  SETC  '&IM(1)'\n&C(248)  SETC  '&IM(1)'\n&C(249)  SETC  '&IM(1)'\n&C(250)  SETC  '&IM(1)'\n&C(251)  SETC  '&IM(1)'\n&C(252)  SETC  '&IM(2)'\n&C(253)  SETC  '2'\n&C(254)  SETC  '&IM(2)'\n&C(255)  SETC  '&IM(25)'\n&C(256)  SETC  '&IM(29)'\n&C(257)  SETC  '&IM(29)'\n&C(258)  SETC  '&IM(2)'\n&C(259)  SETC  '&IM(30)'\n&C(260)  SETC  '&IM(30)'\n&C(261)  SETC  '&IM(7)'\n&C(262)  SETC  '3'\n&C(263)  SETC  '&IM(2)'\n&C(264)  SETC  '&IM(25)'\n&C(265)  SETC  '&IM(29)'\n&C(266)  SETC  '&IM(27)'\n&C(267)  SETC  '&IM(29)'\n&C(268)  SETC  '&IM(25)'\n&C(269)  SETC  '&IM(25)'\n&C(270)  SETC  '&IM(2)'\n&C(271)  SETC  '4'\n&C(272)  SETC  '&IM(31)'\n&C(273)  SETC  '&IM(27)'\n&C(274)  SETC  '&IM(32)'\n&C(275)  SETC  '&IM(33)'\n&C(276)  SETC  '&IM(6)'\n&C(277)  SETC  '&IM(31)'\n&C(278)  SETC  '&IM(31)'\n&C(279)  SETC  '&IM(31)'\n&C(280)  SETC  '5'\n&C(281)  SETC  '&IM(12)'\n&C(282)  SETC  '&IM(30)'\n&C(283)  SETC  '&IM(30)'\n&C(284)  SETC  '&IM(12)'\n&C(285)  SETC  '&IM(29)'\n&C(286)  SETC  '&IM(25)'\n&C(287)  SETC  '&IM(25)'\n&C(288)  SETC  '&IM(2)'\n&C(289)  SETC  '6'\n&C(290)  SETC  '&IM(2)'\n&C(291)  SETC  '&IM(25)'\n&C(292)  SETC  '&IM(30)'\n&C(293)  SETC  '&IM(12)'\n&C(294)  SETC  '&IM(25)'\n&C(295)  SETC  '&IM(25)'\n&C(296)  SETC  '&IM(25)'\n&C(297)  SETC  '&IM(2)'\n&C(298)  SETC  '7'\n&C(299)  SETC  '&IM(7)'\n&C(300)  SETC  '&IM(29)'\n&C(301)  SETC  '&IM(29)'\n&C(302)  SETC  '&IM(31)'\n&C(303)  SETC  '&IM(1)'\n&C(304)  SETC  '&IM(1)'\n&C(305)  SETC  '&IM(1)'\n&C(306)  SETC  '&IM(1)'\n&C(307)  SETC  '8'\n&C(308)  SETC  '&IM(2)'\n&C(309)  SETC  '&IM(25)'\n&C(310)  SETC  '&IM(25)'\n&C(311)  SETC  '&IM(2)'\n&C(312)  SETC  '&IM(25)'\n&C(313)  SETC  '&IM(25)'\n&C(314)  SETC  '&IM(25)'\n&C(315)  SETC  '&IM(2)'\n&C(316)  SETC  '9'\n&C(317)  SETC  '&IM(2)'\n&C(318)  SETC  '&IM(25)'\n&C(319)  SETC  '&IM(25)'\n&C(320)  SETC  '&IM(25)'\n&C(321)  SETC  '&IM(34)'\n&C(322)  SETC  '&IM(29)'\n&C(323)  SETC  '&IM(25)'\n&C(324)  SETC  '&IM(2)'\n&C(325)  SETC  '0'\n&C(326)  SETC  '&IM(2)'\n&C(327)  SETC  '&IM(25)'\n&C(328)  SETC  '&IM(25)'\n&C(329)  SETC  '&IM(25)'\n&C(330)  SETC  '&IM(25)'\n&C(331)  SETC  '&IM(25)'\n&C(332)  SETC  '&IM(25)'\n&C(333)  SETC  '&IM(2)'\n&C(334)  SETC  '$'\n&C(335)  SETC  '&IM(1)'\n&C(336)  SETC  '&IM(7)'\n&C(337)  SETC  '&IM(24)'\n&C(338)  SETC  '&IM(35)'\n&C(339)  SETC  '&IM(7)'\n&C(340)  SETC  '&IM(36)'\n&C(341)  SETC  '&IM(24)'\n&C(342)  SETC  '&IM(7)'\n&C(343)  SETC  '#'\n&C(344)  SETC  '&IM(50)'\n&C(345)  SETC  '&IM(42)'\n&C(346)  SETC  '&IM(41)'\n&C(347)  SETC  '&IM(42)'\n&C(348)  SETC  '&IM(42)'\n&C(349)  SETC  '&IM(41)'\n&C(350)  SETC  '&IM(42)'\n&C(351)  SETC  '&IM(50)'\n&C(352)  SETC  '@'\n&C(353)  SETC  '&IM(50)'\n&C(354)  SETC  '&IM(50)'\n&C(355)  SETC  '&IM(2)'\n&C(356)  SETC  '&IM(25)'\n&C(357)  SETC  '&IM(29)'\n&C(358)  SETC  '&IM(38)'\n&C(359)  SETC  '&IM(37)'\n&C(360)  SETC  '&IM(32)'\n&C(361)  SETC  ','\n&C(362)  SETC  '&IM(50)'\n&C(363)  SETC  '&IM(50)'\n&C(364)  SETC  '&IM(50)'\n&C(365)  SETC  '&IM(50)'\n&C(366)  SETC  '&IM(13)'\n&C(367)  SETC  '&IM(13)'\n&C(368)  SETC  '&IM(1)'\n&C(369)  SETC  '&IM(11)'\n&C(370)  SETC  '.'\n&C(371)  SETC  '&IM(50)'\n&C(372)  SETC  '&IM(50)'\n&C(373)  SETC  '&IM(50)'\n&C(374)  SETC  '&IM(50)'\n&C(375)  SETC  '&IM(50)'\n&C(376)  SETC  '&IM(50)'\n&C(377)  SETC  '&IM(13)'\n&C(378)  SETC  '&IM(13)'\n&C(379)  SETC  '('\n&C(380)  SETC  '&IM(1)'\n&C(381)  SETC  '&IM(11)'\n&C(382)  SETC  '&IM(30)'\n&C(383)  SETC  '&IM(30)'\n&C(384)  SETC  '&IM(30)'\n&C(385)  SETC  '&IM(30)'\n&C(386)  SETC  '&IM(11)'\n&C(387)  SETC  '&IM(1)'\n&C(388)  SETC  ')'\n&C(389)  SETC  '&IM(11)'\n&C(390)  SETC  '&IM(1)'\n&C(391)  SETC  '&IM(31)'\n&C(392)  SETC  '&IM(31)'\n&C(393)  SETC  '&IM(31)'\n&C(394)  SETC  '&IM(31)'\n&C(395)  SETC  '&IM(1)'\n&C(396)  SETC  '&IM(11)'\n&C(397)  SETC  '+'\n&C(398)  SETC  '&IM(50)'\n&C(399)  SETC  '&IM(50)'\n&C(400)  SETC  '&IM(1)'\n&C(401)  SETC  '&IM(1)'\n&C(402)  SETC  '&IM(7)'\n&C(403)  SETC  '&IM(1)'\n&C(404)  SETC  '&IM(1)'\n&C(405)  SETC  '&IM(50)'\n&C(406)  SETC  '/'\n&C(407)  SETC  '&IM(50)'\n&C(408)  SETC  '&IM(39)'\n&C(409)  SETC  '&IM(29)'\n&C(410)  SETC  '&IM(31)'\n&C(411)  SETC  '&IM(1)'\n&C(412)  SETC  '&IM(11)'\n&C(413)  SETC  '&IM(30)'\n&C(414)  SETC  '&IM(40)'\n&C(415)  SETC  ''''\n&C(416)  SETC  '&IM(13)'\n&C(417)  SETC  '&IM(13)'\n&C(418)  SETC  '&IM(1)'\n&C(419)  SETC  '&IM(11)'\n&C(420)  SETC  '&IM(50)'\n&C(421)  SETC  '&IM(50)'\n&C(422)  SETC  '&IM(50)'\n&C(423)  SETC  '&IM(50)'\n&C(424)  SETC  '*'\n&C(425)  SETC  '&IM(50)'\n&C(426)  SETC  '&IM(50)'\n&C(427)  SETC  '&IM(37)'\n&C(428)  SETC  '&IM(2)'\n&C(429)  SETC  '&IM(7)'\n&C(430)  SETC  '&IM(2)'\n&C(431)  SETC  '&IM(37)'\n&C(432)  SETC  '&IM(50)'\n&C(433)  SETC  '='\n&C(434)  SETC  '&IM(50)'\n&C(435)  SETC  '&IM(50)'\n&C(436)  SETC  '&IM(50)'\n&C(437)  SETC  '&IM(7)'\n&C(438)  SETC  '&IM(50)'\n&C(439)  SETC  '&IM(7)'\n&C(440)  SETC  '&IM(50)'\n&C(441)  SETC  '&IM(50)'\n&C(442)  SETC  ':'\n&C(443)  SETC  '&IM(50)'\n&C(444)  SETC  '&IM(50)'\n&C(445)  SETC  '&IM(13)'\n&C(446)  SETC  '&IM(13)'\n&C(447)  SETC  '&IM(50)'\n&C(448)  SETC  '&IM(13)'\n&C(449)  SETC  '&IM(13)'\n&C(450)  SETC  '&IM(50)'\n&C(451)  SETC  ';'\n&C(452)  SETC  '&IM(50)'\n&C(453)  SETC  '&IM(13)'\n&C(454)  SETC  '&IM(13)'\n&C(455)  SETC  '&IM(50)'\n&C(456)  SETC  '&IM(13)'\n&C(457)  SETC  '&IM(13)'\n&C(458)  SETC  '&IM(1)'\n&C(459)  SETC  '&IM(11)'\n&C(460)  SETC  '-'\n&C(461)  SETC  '&IM(50)'\n&C(462)  SETC  '&IM(50)'\n&C(463)  SETC  '&IM(50)'\n&C(464)  SETC  '&IM(50)'\n&C(465)  SETC  '&IM(7)'\n&C(466)  SETC  '&IM(50)'\n&C(467)  SETC  '&IM(50)'\n&C(468)  SETC  '&IM(50)'\n&C(469)  SETC  '?'\n&C(470)  SETC  '&IM(2)'\n&C(471)  SETC  '&IM(25)'\n&C(472)  SETC  '&IM(29)'\n&C(473)  SETC  '&IM(31)'\n&C(474)  SETC  '&IM(1)'\n&C(475)  SETC  '&IM(1)'\n&C(476)  SETC  '&IM(50)'\n&C(477)  SETC  '&IM(1)'\n&C(478)  SETC  '%'\n&C(479)  SETC  '&IM(50)'\n&C(480)  SETC  '&IM(43)'\n&C(481)  SETC  '&IM(44)'\n&C(482)  SETC  '&IM(31)'\n&C(483)  SETC  '&IM(1)'\n&C(484)  SETC  '&IM(11)'\n&C(485)  SETC  '&IM(45)'\n&C(486)  SETC  '&IM(46)'\n&C(487)  SETC  '|'\n&C(488)  SETC  '&IM(1)'\n&C(489)  SETC  '&IM(1)'\n&C(490)  SETC  '&IM(1)'\n&C(491)  SETC  '&IM(1)'\n&C(492)  SETC  '&IM(1)'\n&C(493)  SETC  '&IM(1)'\n&C(494)  SETC  '&IM(50)'\n&C(495)  SETC  '&IM(1)'\n&C(496)  SETC  '&&'\n&C(497)  SETC  '&IM(50)'\n&C(498)  SETC  '&IM(13)'\n&C(499)  SETC  '&IM(33)'\n&C(500)  SETC  '&IM(33)'\n&C(501)  SETC  '&IM(13)'\n&C(502)  SETC  '&IM(37)'\n&C(503)  SETC  '&IM(33)'\n&C(504)  SETC  '&IM(38)'\n&C(505)  SETC  '\"'\n&C(506)  SETC  '&IM(47)'\n&C(507)  SETC  '&IM(47)'\n&C(508)  SETC  '&IM(42)'\n&C(509)  SETC  '&IM(33)'\n&C(510)  SETC  '&IM(50)'\n&C(511)  SETC  '&IM(50)'\n&C(512)  SETC  '&IM(50)'\n&C(513)  SETC  '&IM(50)'\n.*\n         AIF   ('&NAME' EQ '').NONM\n         SPACE 1\n&NAME    DS    0H\n.NONM    ANOP\n&K       SETA  K'&STRING\n         AIF   (&K GT 55).LERR\n&M       SETA  1\n         AIF   (&K GT 0).COPY3\n&K       SETA  K'&NAME\n         AIF   (&K GT 0).COPY2\n&NCS     SETC  '&SYSECT'\n&K       SETA  K'&NCS\n.COPY1   ANOP\n&STR(&M) SETC  '&NCS'(&M,1)\n&M       SETA  &M+1\n         AIF   (&M LE &K).COPY1\n         AGO   .COPYD\n.COPY2   ANOP\n&STR(&M) SETC  '&NAME'(&M,1)\n&M       SETA  &M+1\n         AIF   (&M LE &K).COPY2\n         AGO   .COPYD\n.COPY3   ANOP\n&STR(&M) SETC  '&STRING'(&M,1)\n&M       SETA  &M+1\n         AIF   (&M LE &K).COPY3\n.COPYD   ANOP\n&M       SETA  0\n         AIF   ('&STR(1)' NE '''').EDIT\n         AIF   (&K EQ 1).IERR\n&M       SETA  1\n&I       SETA  &M\n         AGO   .COMP\n.EDIT    AIF   (&M EQ &K).CNTL\n&M       SETA  &M+1\n&I       SETA  &M\n         AIF   ('&STR(&M)' EQ '&&'(1,1)).TEST\n         AIF   ('&STR(&M)' NE '''').EDIT\n         AIF   (&M EQ &K).ELIM\n         AIF   ('&STR(&M+1)' NE '''').PERR\n         AGO   .PACK\n.TEST    AIF   (&M EQ &K).MERR\n         AIF   ('&STR(&M+1)' NE '&&'(1,1)).MERR\n.PACK    ANOP\n&M       SETA  &M+1\n&I       SETA  &M\n.COMP    ANOP\n&STR(&I) SETC  '&STR(&I+1)'\n&I       SETA  &I+1\n         AIF   (&I LT &K).COMP\n&STR(&K) SETC  ' '\n&K       SETA  &K-1\n&M       SETA  &M-1\n         AGO   .EDIT\n.ELIM    ANOP\n&STR(&K) SETC  ' '\n&K       SETA  &K-1\n.CNTL    AIF   (&K EQ 0).IERR\n         AIF   (&K GT 40).TERR\n&M       SETA  0\n.AGIN    ANOP\n&I       SETA  1\n&L       SETA  &K-&M\n         AIF   (&L LE 0).DONE\n         AIF   (&L LE 8).CKL\n&L       SETA  8\n.CKL     AIF   (&L GT 6).SETL\n&J       SETA  8\n         AIF   (&L GT 4).FILT\n&J       SETA  16\n         AIF   (&L GT 2).FILT\n&J       SETA  24\n.FILT    AIF   (&I GT &J).SETL\n&FLD(&I) SETC  '&C(2)'\n&I       SETA  &I+1\n         AGO   .FILT\n.SETL    ANOP\n&L       SETA  &L+&M\n.LOOP    AIF   (&M EQ &L).FINI\n&M       SETA  &M+1\n&J       SETA  1\n&N       SETA  9\n.MTCH    AIF   ('&STR(&M)' EQ '&C(&J)'(1,1)).GO\n&J       SETA  &J+9\n&N       SETA  &J+8\n         AIF   (&J LT 513).MTCH\n&J       SETA  1\n&N       SETA  9\n.GO      AIF   (&J EQ &N).LOOP\n&J       SETA  &J+1\n&FLD(&I) SETC  '&C(&J)'\n&I       SETA  &I+1\n         AGO   .GO\n.FINI    AIF   (&I GT 64).DOIT\n&FLD(&I) SETC  ' '\n&I       SETA  &I+1\n         AGO   .FINI\n.DOIT    ANOP\n         SPACE 2\n         MNOTE *,'    &FLD(1)&FLD(9)&FLD(17)&FLD(25)&FLD(33)&FLD(41)&FL1\n               D(49)&FLD(57)'\n         MNOTE *,'    &FLD(2)&FLD(10)&FLD(18)&FLD(26)&FLD(34)&FLD(42)&F1\n               LD(50)&FLD(58)'\n         MNOTE *,'    &FLD(3)&FLD(11)&FLD(19)&FLD(27)&FLD(35)&FLD(43)&F1\n               LD(51)&FLD(59)'\n         MNOTE *,'    &FLD(4)&FLD(12)&FLD(20)&FLD(28)&FLD(36)&FLD(44)&F1\n               LD(52)&FLD(60)'\n         MNOTE *,'    &FLD(5)&FLD(13)&FLD(21)&FLD(29)&FLD(37)&FLD(45)&F1\n               LD(53)&FLD(61)'\n         MNOTE *,'    &FLD(6)&FLD(14)&FLD(22)&FLD(30)&FLD(38)&FLD(46)&F1\n               LD(54)&FLD(62)'\n         MNOTE *,'    &FLD(7)&FLD(15)&FLD(23)&FLD(31)&FLD(39)&FLD(47)&F1\n               LD(55)&FLD(63)'\n         MNOTE *,'    &FLD(8)&FLD(16)&FLD(24)&FLD(32)&FLD(40)&FLD(48)&F1\n               LD(56)&FLD(64)'\n         AGO   .AGIN\n.LERR    MNOTE 8,' OPERAND TOO LONG (MAX. = 55 CARD COLUMNS) ******** '\n         AGO   .DONE\n.MERR    MNOTE 8,' ODD NUMBER OF AMPERSANDS IN OPERAND ************** '\n         AGO   .DONE\n.PERR    MNOTE 8,' ODD NUMBER OF APOSTROPHES IN OPERAND ************* '\n         AGO   .DONE\n.IERR    MNOTE 8,' INVALID (NULL) OPERAND *************************** '\n         AGO   .DONE\n.TERR    MNOTE 8,' TEXT TOO LONG (MAX. = 40 CHATACTERS) ************* '\n.DONE    SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$HEDIT@": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x12\\x00'\\x00'\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:12:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      $HEDIT    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *             HEADER EDIT             * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n   Assembler macro : $HEDIT STRING\n   -----------------\n\n   STRING operand - text which is expanded and blocks printed\n                    by group of 8 characters (the maximum string\n                    length is 40 characters). If this operand is\n                    omitted, the name entry of the statement (this\n                    name can be referenced as label in the assembly),\n                    if present, or the current CSECT name, is used.\n\n                    Note - If a blank and/or a comma must be used,\n                           the character string must be enclosed\n                           within apostrophes. A double apostrophe\n                           and/or ampersand must be used to generate a\n                           single one as part of the character string.\n\n   Example :        Coding the macro\n   ---------\n                            $HEDIT ABC\n\n                    Result as below :\n\n                            *    ******   ******\n                           ***   **   ** **\n                          ** **  **   ** **\n                         **   ** ******  **\n                         **   ** **   ** **\n                         ******* **   ** **\n                         **   ** **   ** **\n                         **   ** ******   ******\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ICFCD": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x14_\\x00\\x87\\x14_\\x14\\t\\x02\\x02\\x02\\x02\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-05-25T00:00:00", "modifydate": "1987-05-25T14:09:00", "lines": 514, "newlines": 514, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           ICF CATALOG RECORD DESCRIPTIONS.\n        $ICFCD &BCS=YES,&VVDS=NO\n         SPACE 1\n*        ICF CATALOG RECORD DESCRIPTIONS.\n*        --------------------------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         SPACE 1\nICFDSECT DSECT  .                  ICF CATALOG RECORD FORMATS.\n         SPACE 1\n*        COMMON DEFINITION TO ALL RECORDS.\n         SPACE 1\nICFRLN   DS    XL2 .               LENGTH OF RECORD INCLUDING ITSELF\nICFRTY   DS    CL1 .               TYPE OF RECORD\n         AIF   ('&BCS' NE 'NO').A\n         AIF   ('&VVDS' EQ 'NO').C\n         SPACE 2\n         AGO   .B\n.A       SPACE 2\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES A VSAM BASE CLUSTER.\n         SPACE 1\nVCNC     DS    0XL52 .             VSAM CLUSTER NAME CELL\nCLCELLN  DS    XL2 .               LENGTH OF VCNC INCLUDING ITSELF\nCLTYPE   DS    CL1 .               TYPE 'C' FOR CLUSTER\nCLCOMPLN DS    XL2 .               LENGTH OF THE CLUSTER COMPONENT\nCLNOEXT  DS    XL1 .               NUMBER OF EXTENSION RECORDS\nCLNMLEN  DS    XL1 .               LENGTH OF THE CLUSTER KEY (45)\nCLNAME   DS    CL44 .              CLUSTER NAME PART OF KEY\nCLNMPAD  DS    XL1 .               PAD VALUE, SET TO BINARY ZERO\nCLNPEND  EQU   *,0 .               END VSAM CLUSTER NAME CELL\n         SPACE 2\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES A DATA COMPONENT OF A BASE CLUSTER\n*        OR AIX.\n         SPACE 1\nDINC     DS    0XL7 .              DATA OR INDEX NAME CELL\nDIDLEN   DS    XL2 .               LENGTH OF DINC\nDIDTYPE  DS    CL1 .               TYPE 'D' OR 'I' FOR DATA OR INDEX\nDIDCMPLN DS    XL2 .               LENGTH OF DINC COMPONENT\nDIDIRFLG DS    XL1 .               INTERRUPT RECOGNITION FLAGS\nDIDELETE EQU   B'10000000' .       DELETE IN PROGRESS\nDIDUPDAT EQU   B'01000000' .       UPDATE-EXTEND IN PROGRESS\nDIDSRMU  EQU   B'00100000' .       SUB-RECORD MOVE/UPDATE IN PROGRESS\nDIDKEYLN DS    XL1 .               CONDENSED KEY LENGTH\nDIDKEY   DS    0XL1 .              CONDENSED KEY\n         EJECT\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES AN INDEX COMPONENT OF A BASE CLUSTER\n*        OR AIX.\n         SPACE 1\nANC      DS    0XL7 .              ALTERNATE INDEX NAME CELL\nAIXCELN  DS    XL2 .               LENGTH OF ANC INCLUDING ITSELF\nAIXTYPE  DS    CL1 .               TYPE 'G' FOR ANC\nAIXCMPLN DS    XL2 .               LENGTH OF AIX COMPONENT\nAIXFLAG  DS    XL1 .               FLAG BYTE\nAIXUPG   EQU   B'10000000' .       AIX IS MEMBER OF UPGRADE SET\nAIXKYLEN DS    XL1 .               LENGTH OF CONDENSED AIX KEY\nAIXKEY   DS    0XL1 .              2-45 BYTE AIX CONDENSED KEY\n         SPACE 2\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES A PATH OF A BASE CLUSTER OR AIX.\n         SPACE 1\nPNC      DS    0XL52 .             PATH NAME CELL\nPATHCELN DS    XL2 .               LENGTH OF PNC INCLUDING ITSELF\nPATHTYPE DS    CL1 .               TYPE 'R' FOR PATH\nPATHRESV DS    XL2 .               RESERVED\nPATHATTR DS    XL1 .               PATH ATTRIBUTES\nPATHUPG  EQU   B'10000000' .       UPGRADE IF RELATED TO AIX\nPATHUPD  EQU   B'10000000' .       UPDATE IF RELATED TO CLUSTER\nPATHREL  EQU   B'00100000' .       0 RELATED TO AIX\n*                                  1 RELATED TO CLUSTER\nPATHKYLN DS    XL1 .               LENGTH OF PATH KEY\nPATHNAME DS    CL44 .              PATH NAME PART OF KEY\nPATHPAD  DS    XL1 .               PAD VALUE (BINARY ZEROS)\nPATHEND  EQU   *,0 .               END PATH CELL\n         EJECT\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES A NON-VSAM DATA SET.\n         SPACE 1\nNVNC     DS    0XL52 .             NON-VSAM NAME CELL\nNVCELEN  DS    XL2 .               LENGTH OF NVNC INCLUDING ITSELF\nNVTYPE   DS    CL1 .               TYPE 'A' FOR NONVSAM\nNVRESV   DS    XL1 .               RESERVED\nNVOLCNT  DS    XL2 .               NUMBER OF VOLUME CELLS - UP TO 255\nNVKEYLN  DS    XL1 .               LENGTH OF NONVSAM KEY\nNVNAME   DS    CL44 .              NONVSAM NAME\nNVPAD    DS    XL1 .               PAD VALUE (BINARY ZEROS)\nNVEND    EQU   *,0 .               END NONVSAM CELL\n         SPACE 2\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES A GENERATION DATA GROUP.\n         SPACE 1\nGDGNC    DS    0XL52 .             GENERATION DATA GROUP BASE NAME CELL\nGDGCELLN DS    XL2 .               LENGTH OF GDGNC INCLUDING ITSELF\nGDGTYPE  DS    CL1 .               TYPE 'B' FOR GDG\nGDGCMPLN DS    XL2 .               LENGTH OF GDG COMPONENT\nGDGNOEXT DS    XL1 .               NUMBER OF EXTENSION RECORDS\nGDGKYLEN DS    XL1 .               LENGTH OF GDG KEY\nGDGKEY   DS    0CL45 .             NAME AND PAD CHARACTER\nGDGNAME  DS    CL44 .              1-35 BYTE NAME PADDED WITH BLANKS\nGDGPAD   DS    XL1 .               PAD VALUE (BINARY ZEROS)\nGDGNCEND EQU   *,0 .               END GDG NAME CELL\n         EJECT\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES A NON-VSAM DATA-SET WHICH IS PART\n*        OF A GENERATION DATA GROUP.\n         SPACE 1\nGDSNC    DS    0XL10 .             GENERATION DATA SET NAME CELL\nGDSCELEN DS    XL2 .               LENGTH OF GDSNC INCLUDING ITSELF\nGDSTYPE  DS    CL1 .               TYPE 'H' FOR GDS\nGDSCMPLN DS    XL2 .               LENGTH OF GDS COMPONENT\nGDSGENO  DS    XL2 .               GENERATION NUMBER OF GDS\nGDSVERNO DS    XL1 .               VERSION NUMBER OF GDS\nGDSVOLCT DS    XL2 .               NUMBER OF VOLUME CELLS IN GDS\n         SPACE 2\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES A D, I, OR G COMPONENT THAT IS NOT\n*        THE FIRST COMPONENT OF A RECORD.\n         SPACE 1\nTNC      DS    0XL52 .             TRUENAME NAME CELL\nTRUCELN  DS    XL2 .               LENGTH OF TNC INCLUDING ITSELF\nTRUTYPE  DS    CL1 .               TYPE 'T' FOR TRUENAME\nTRURESV  DS    XL2 .               RESERVED\nTRUNTYPE DS    CL1 .               TRUENAME RECORD FOR 'G', 'D', 'I'\nTRUEKEYL DS    XL1 .               TRUENAME KEY LENGTH\nTRUENAME DS    CL44 .              DATA, INDEX OR AIX NAME\nTRUPAD   DS    XL1 .               PAD VALUE (BINARY ZEROS)\nTRUEND   EQU   *,0 .               END TRUENAME CELL\n         EJECT\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES AN EXTENSION RECORD FOR A VSAM CLUSTER\n*        AND FOR A GENERATION DATA GROUP (SAME FORMAT).\n         SPACE 1\nENC      DS    0XL52 .             VSAM EXTENSION NAME CELL AND\n*                                  GENERATION DATA GROUP EXTENSION\n*                                  NAME CELL\nEXTCELN  DS    XL2 .               LENGTH OF ENC INCLUDING ITSELF\nEXTTYPE  DS    CL1 .               TYPE 'E' FOR VSAM, 'J' FOR GDS\nEXTRESV  DS    XL3 .               RESERVED\nEXTNMLEN DS    XL1 .               EXTENSION KEY LENGTH\nEXTKEY   DS    0CL45 .             EXTENSION KEY\nEXTNAME  DS    CL44 .              SPHERE NAME PADDED WITH BLANKS\nEXTPAD   DS    XL1 .               PAD VALUE STARTING WITH '01'X AND\n*                                  CONTINUING TO 'FF'X FOR A MAXIMUM\n*                                  OF 255 EXTENSIONS\n         SPACE 2\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES A VSAM OR ICF USER CATALOG\n*        CONNECTOR RECORD.\n         SPACE 1\nICFCNC   DS    0XL52 .             ICF CONNECTOR NAME CELL\nCOCELN   DS    XL2 .               LENGTH OF ICFCNC INCLUDING ITSELF\nCOTYPE   DS    CL1 .               TYPE 'U' FOR ICF CONNECTOR\nCORESV   DS    XL2 .               RESERVED\nCOFLAG   DS    XL1 .               FLAG BYTE\nCOCATYPE EQU   B'10000000' .       CATALOG TYPE 0 VSAM CATALOG\n*                                               1 ICF CATALOG\nCOKEYLN  DS    XL1 .               CATALOG KEY LENGTH\nCONAME   DS    CL44 .              CATALOG NAME PART OF KEY\nCOPAD    DS    XL1 .               PAD VALUE (BINARY ZEROS)\nCOEND    EQU   *,0 .               END CONNECTOR\n         EJECT\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES AN ALIAS OF A NON-VSAM DATA SET\n*        (OR GDG BASE).\n         SPACE 1\nALNC     DS    0XL52 .             ALIAS NAME CELL\nALICELN  DS    XL2 .               LENGTH OF ALNC INCLUDING ITSELF\nALITYPE  DS    CL1 .               TYPE 'X' FOR ALIAS\nALIRESV  DS    XL2 .               RESERVED\nALIRTYP  DS    XL1 .               TYPE OF RELATED NAME\nALIKYLEN DS    XL1 .               LENGTH OF ALIAS KEY\nALINAME  DS    CL44 .              ALIAS NAME PART OF KEY\nALIPAD   DS    XL1 .               PAD VALUE (BINARY ZEROS)\nALIEND   EQU   *,0 .               END ALIAS CELL\n         SPACE 2\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES THE OWNERSHIP INFORMATION FOR A\n*        COMPONENT.\n         SPACE 1\nOWNERC   DS    0XL18 .             OWNERSHIP CELL\nOWNCELLN DS    XL2 .               LENGTH OF OWNERC CELL + ITSELF\nOWNTYPE  DS    XL1 .               TYPE X'01' FOR OWNERC\nOWNID    DS    XL8 .               OWNER IDENTIFICATION\nOWNFLAG  DS    XL1 .               FLAG BYTE\nOWNRACF  EQU   B'10000000' .       RACF PROTECTION\nOWNKSDS  EQU   B'01000000' .       INDEX COMPONENT DATA SET\nOWNREUS  EQU   B'00100000' .       REUSABLE DATA SET\nOWNERASE EQU   B'00010000' .       ERASE SPECIFIED (CLUSTER ONLY)\nOWNSWAP  EQU   B'00000010' .       SWAPSPACE (CLUSTER ONLY)\nOWNPAGE  EQU   B'00000001' .       PAGESPACE (CLUSTER ONLY)\nOWNCREDT DS    XL3 .               CREATION DATE\nOWNEXPDT DS    XL3 .               EXPIRATION DATE\nOWNEND   EQU   *,0 .               END OWNER CELL\n         EJECT\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES SECURITY INFORMATION FOR A VSAM\n*        COMPONENT.\n         SPACE 1\nSECURITY DS    0XL55 .             SECURITY CELL\nSECELLN  DS    XL2 .               LENGTH OF SECURITY CELL + ITSELF\nSECTYPE  DS    XL1 .               TYPE X'02' FOR SECURITY\nSECPSWD  DS    0CL32 .             PASSWORDS\nSECMSTR  DS    CL8 .               MASTER PASSWORD\nSECCI    DS    CL8 .               CONTROL INTERVAL PASSWORD\nSECUPDTE DS    CL8 .               UPDATE PASSWORD\nSECREAD  DS    CL8 .               READ PASSWORD\nSECPMTCD DS    CL8 .               PASSWORD PROMPTING CODE\nSECATMP  DS    XL2 .               MAXIMUM NUMBER OF ATTEMPTS\nSECVRMOD DS    CL8 .               USER SECURITY VERIFICATION MOD\nSECRCDLN DS    XL2 .               USER AUTHORIZATION RECORD LENGTH.\nSECRCD   DS    0XL1 .              1-256 BYTE USER AUTH. RECORD\n         SPACE 2\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES PATHS ASSOCIATED WITH A CLUSTER OR\n*        AIX, CLUSTER AND/OR AIX ASSOCIATED WITH A PATH, ALIASES\n*        ASSOCIATED WITH A NON-VSAM DATA SET, DATA SET ASSOCIATED\n*        WITH AN ALIAS, AND BASE CLUSTER, AND AIX IF ANY, ASSOCIATED\n*        WITH A TRUENAME.\n         SPACE 1\nASSOCC   DS    0XL5 .              ASSOCIATION CELL\nASCLEN   DS    XL2 .               LENGTH OF ASSOCIATION CELL + ITSELF\nASCTYPE  DS    XL1 .               TYPE X'03' FOR ASSOCC\nASCOUNT  DS    XL2 .               COUNT OF ASSOCIATIONS - MAX 64K\n         ORG   ASSOCC .            THE FOLLOWING FIELDS MAY BE REPEATED\n*                                  AS INDICATED IN ASCOUNT, ABOVE.\nASCKEYS  DS    0XL2\nASCFLAG  DS    XL1 .               FLAG\nASCREUS  EQU   B'10000000' .       USED IN RELATION CELL ONLY\nASCKYLEN DS    XL1 .               LENGTH OF CONDENSED ASSOC KEY\nASCKEY   DS    0XL1 .              2-45 BYTE CONDENSED ASSOC KEY\n         EJECT\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES VOLUME INFORMATION FOR A VSAM OR\n*        NON-VSAM DATA SET.\n         SPACE 1\nVOLCELL  DS    0XL28 .             VOLUME CELL\nVOLLEN   DS    XL2 .               LENGTH OF VOLCELL INCLUDING ITSELF\nVOLTYPE  DS    XL1 .               TYPE X'04' FOR VOLUME CELL\nVOLOFSET DS    XL1 .               NOT USED\nVOLSERN  DS    CL6 .               VOLUME SERIAL NUMBER\nVOLDEVTP DS    XL4 .               DEVICE TYPE\nVOLFLAG1 DS    XL1 .               VOLUME FLAG 1\nVOLPRIME EQU   B'10000000' .       PRIME VOLUME-ALLOCATED SPACE\nVOLCANDI EQU   B'01000000' .       CANDIDATE VOLUME NO SPACE\nVOLOFLOW EQU   B'00100000' .       OVERFLOW KEYRANGE ONLY\nVOLCONV  EQU   B'00010000' .       CONVERTED VSAM DATA SET VOLUME\nVOLNVSAM EQU   B'00001000' .       NONVSAM VOLUME CELL\nVOLKYRNG EQU   B'00000100' .       KEYRANGE QUALIFIER PRESENT\nVOLVPCI  EQU   B'00000010' .       PRIMARY VVR CI\nVOLSSQWD EQU   B'00000001' .       SEQUENCE SET WITH DATA\nVOLFLAG2 DS    XL1 .               RESERVED\nVOLVVRBA DS    0XL4 .              RELATIVE BYTE ADDRESS OF VVR\nVOLDSTTR DS    XL3 .               NONVSAM FORMAT 1 DSCB TTR\n         DS    XL1 .               RESERVED\nVOLFLSEQ DS    XL2 .               NONVSAM FILE SEQUENCE NO. (TAPE)\nVOLKRQL  DS    0XL4 .              KEYRANGE QUALIFIER (VSAM ONLY)\n         DS    XL4 .               RESERVED FOR NONVSAM\nVOLLKYLN DS    XL2 .               LENGTH OF LOW KEY RANGE KEY\nVOLLOWKY DS    0XL1 .              1-64 BYTE LOW KEY\n         ORG   VOLCELL\nVOLHKYLN DS    XL2 .               LENGTH OF HIGH KEY RANGE KEY\nVOLHIKY  DS    0XL1 .              1-64 BYTE HIGH KEY\n         EJECT\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES THE GENERATION AND VERSION NUMBERS\n*        OF THE DATA SETS IN A GENERATION DATA GROUP.\n         SPACE 1\nGATC     DS    0XL6 .              GENERATION AGING TABLE CELL\nGATCELN  DS    XL2 .               LENGTH OF GATC\nGATYPE   DS    XL1 .               TYPE '05' FOR GATC\nGATATTR  DS    XL1 .               ATTRIBUTES\nGATDELET EQU   B'10000000' .       INDICATES HOW MANY GDS ENTRIES TO\n*                                  REMOVE WHEN THE GDSLIMIT HAS BEEN\n*                                  EXCEEDED. 0 DELETE THE OLDEST GDS\n*                                            1 DELETE ALL GDS\nGATSCRTH EQU   B'01000000' .       INDICATES WHETHER TO SCRATCH THE\n*                                  FORMAT 1 DSCB OF THE DASD GDS.\n*                                  0 DO NOT SCRATCH\n*                                  1 SCRATCH IF MOUNTED\nGATLIMIT DS    XL1 .               MAXIMUM GDS ENTRIES IN GDG BASE\nGATCNT   DS    XL1 .               CURRENT NUMBER OF ENTRIES IN GAT\nGAT      EQU   *,0 .               4-BYTE ENTRY FOR EACH GDS\nGATENT   EQU   *,0 .               GAT ENTRY\nGATEXTNO DS    XL1 .               EXTENSION RECORD SEQUENCE NUMBER\nGATGEN   DS    XL2 .               GENERATION NUMBER OF GDS\nGATWRAP  EQU   B'10000000' .       GENERATION EXCEEDED 9999\nGATVER   DS    XL1 .               VERSION NUMBER OF GDS\n         SPACE 2\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES AIXS ASSOCIATED WITH A BASE CLUSTER.\n         SPACE 1\nRELCELL  DS    0XL5 .              RELATIONSHIP CELL\nRELLEN   DS    XL2 .               RELCELL LENGTH INCLUDING ITSELF\nRELTYPE  DS    XL1 .               TYPE X'06' FOR RELATIONSHIP\nRELRESV  DS    XL1 .               RESERVED\nRELCNT   DS    XL1 .               COUNT OF RELKEYS\n         ORG   ASSOCC .            THE FOLLOWING FIELDS MAY BE REPEATED\n*                                  AS INDICATED IN RELCNT, ABOVE.\nRELKEYS  DS    0XL2\nRELFLAG  DS    XL1 .               FLAG BYTE\nRELUPG   EQU   B'10000000' .       UPGRADE AIX\nRELGLEN  DS    XL1 .               LENGTH OF AIX CONDENSED KEY\nRELGKEY  DS    0XL1 .              AIX CONDENSED KEY\n         AIF   ('&VVDS' EQ 'NO').C\n         EJECT\n.B       ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES A PRIMARY VVR, IT HAS TYPE 'Z'.\n*        IF THIS CELL IDENTIFIES A SECONDARY VVR, IT HAS TYPE 'Q'.\n         SPACE 1\nVVR      DS    0XL11 .             VVR HEADER CELL\nVVRLEN   DS    XL2 .               LENGTH OF ENTIRE VVR\nVVRHDR   DS    0XL9\nVVRHDLEN DS    XL2 .               LENGTH OF HEADER CELL\nVVRTYPE  DS    CL1 .               TYPE IS C'Z' OR C'Q'\nVVRFLAG  DS    XL1 .               HEADER FLAG\nVVRSELFD EQU   B'01000000' .       SELF DESCRIBING VVR FOR VVDS\nVVRCATDS EQU   B'00100000' .       CATALOG SELF-DESCRIBING VVR\nVVRCOMTP EQU   B'00001000' .       COMPONENT TYPE 'D' (0) OR 'I' (1)\nVVRKRQ   DS    XL4 .               KEY RANGE QUALIFIER\nVVRV1    DS    0XL1\nVVRCMPNL DS    XL1 .               COMPONENT NAME LENGTH\nVVRCMPNM DS    0XL1 .              COMPONENT NAME\n         ORG   VVR\nVVRKEYL  DS    XL1 .               LENGTH OF KEY (<= 45)\nVVRKEY   DS    0XL1 .              KEY (CLUSTER NAME + PAD)\n         ORG   VVR\nVVRCATNL DS    XL1 .               CATALOG NAME LENGTH\nVVRCATNM DS    0XL1 .              CATALOG NAME\n         ORG   VVR\nVVRBSENL DS    XL1 .               LENGTH OF AIX NAME\nVVRBSENM DS    0XL1 .              AIX NAME\n         EJECT\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES ATTRIBUTES OF A VSAM DATA COMPONENT\n*        OR INDEX COMPONENT.\n         SPACE 1\nVVRDSINF DS    0XL53 .             VVR DATA SET INFORMATION CELL\nVVRDSLEN DS    XL2 .               DATA SET CELL LENGTH\nVVRDSTYP DS    XL1 .               TYPE CODE IS X'21'\nVVRDSATR DS    0XL2\nVVRATTR1 DS    XL1 .               DATA SET ATTRIBUTES\nVVRA1SPD EQU   B'10000000' .       SPEED\nVVRA1UNQ EQU   B'01000000' .       UNIQUE\nVVRA1REU EQU   B'00100000' .       REUSABLE\nVVRA1ERS EQU   B'00010000' .       ERASE\nVVRA1IUP EQU   B'00000100' .       INHIBIT UPDATE\nVVRA1TEX EQU   B'00000010' .       TEMPORARY EXPORT\nVVRA1TKO EQU   B'00000001' .       TRACK OVERFLOW\nVVRATTR2 DS    XL1 .               SHARE ATTRIBUTES\nVVRA2REG EQU   B'11000000' .       REGIONAL SHARING ATTRIBUTES\nVVRA2SYS EQU   B'00110000' .       SYSTEM SHARING ATTRIBUTES\nVVRA2INT EQU   B'00000010' .       INTERNAL SYSTEM DATA SET\nVVRA2NUS EQU   B'00000001' .       COMPONENT IS NOT USABLE\nVVROPIND DS    XL1 .               OPEN INDICATOR\nVVRBUFSZ DS    XL4 .               MINIMUM BUFFER SIZE\nVVRSPACE DS    0XL7\nVVRPRISP DS    XL3 .               PRIMARY SPACE ALLOCATION\nVVRSECSP DS    XL3 .               SECONDARY SPACE ALLOCATION\nVVRSPCFG DS    XL1 .               SPACE FLAGS\nVVRSPCOP EQU   B'11000000' .       SPACE OPTIONS\nVVRDSHU  DS    XL4 .               DATA SET HI USED RBA\nVVRDSHA  DS    XL4 .               DATA SET HI ALLOCATED RBA\nVVRLRECL DS    XL4 .               AVERAGE LOGICAL RECORD LENGTH\n         DS    XL2 .               RESERVED\nVVREXCPX DS    CL8 .               EXCEPTION EXIT\nVVRDSHK  DS    XL4 .               DATA SET HI KEY RBA\nVVRCLSFG DS    XL1 .               CLUSTER ATTRIBUTE FLAG\nVVRCFSWS EQU   B'00000010' .       CLUSTER DESCRIBES SWAPSPACE\nVVRCFPGS EQU   B'00000001' .       CLUSTER DESCRIBES PAGESPACE\nVVRAIXFG DS    XL1 .               AIX ATTRIBUTE FLAG\nVVRAIUPG EQU   B'10000000' .       UPGRADE AIX\nVVRTMSTP DS    XL8 .               TIMESTAMP (CATALOGUE ONLY)\nVVRDSEND EQU   *,0\n         EJECT\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES INFORMATION FOR A PARTICULAR VOLUME\n*        FOR A VSAM DATA COMPONENT OR INDEX COMPONENT. THE VARIABLE-\n*        LENGTH FIELD VVRLOKYV IS IMMEDIATELY FOLLOWED BY THE EXTENT\n*        SECTION, WHICH CONTAINS A 2-BYTE LENGTH FIELD AND ONE OR\n*        MORE 20-BYTE EXTENT DESCRIPTIONS.\n         SPACE 1\nVVRVOLIN DS    0XL38 .             VVR VOLUME INFORMATION CELL\nVVRVOLLN DS    XL2 .               LENGTH OF VOLUME CELL\nVVRVOLTP DS    XL1 .               TYPE CODE IS X'23'\nVVRVOLFG DS    XL1 .               VOLUME FLAGS\nVVRPRIME EQU   B'10000000' .       PRIME VOLUME\nVVROVFLW EQU   B'00100000' .       OVERFLOW VOLUME\nVVRNOEXT DS    XL1 .               NO OF EXTENTS ON VOLUME FOR DATA SET\nVVRHKRBA DS    XL4 .               HIGH KEY RBA\nVVRHURBA DS    XL4 .               HIGH USED RBA\nVVRHARBA DS    XL4 .               HIGH ALLOCATED RBA\nVVRBLKSZ DS    XL4 .               BLOCK SIZE\nVVRBLKTK DS    XL2 .               NUMBER OF BLOCKS PER TRACK\nVVRTRKAU DS    XL2 .               TRACKS PER ALLOCATION UNIT\nVVRTPEXT DS    XL1 .               EXTENT TYPE FLAG\nVVRSSDAT EQU   B'10000000' .       SEQUENCE SET WITH DATA\nVVRNOPFM EQU   B'01000000' .       EXTENTS NOT PREFORMATTED\nVVRCONV  EQU   B'00100000' .       CONVERTED VSAM DATA SET VOLUME\nVVRTKCYL DS    XL2 .               TRACKS PER CYLINDER\nVVRBYTTK DS    XL4 .               BYTES PER TRACK\nVVRBYTAU DS    XL4 .               BYTES PER ALLOCATION UNIT\nVVRLOKYL DS    XL2 .               LOW KEY LENGTH\nVVRLOKYV DS    0XL1 .              LOW KEY ON VOLUME\n         ORG   VVRVOLIN\nVVRXTENT DS    0XL1 .              EXTENT SECTION\nVVRXTNTL DS    XL2 .               LENGTH OF TOTAL EXTENT SECTION\nVVRXTNT  EQU   *,0 .               EXTENTS (ONE OR MORE 20 BYTE SETS)\nVVRX     EQU   *,0 .               INDIVIDUAL EXTENTS\nVVRXSEQN DS    XL2 .               SEQUENCE NUMBER\nVVRXSCH  DS    0XL4 .              STARTING CCHH\nVVRXSC   DS    XL2 .               STARTING CC\nVVRXSH   DS    XL2 .               STARTING HH\nVVRXECH  DS    0XL4 .              ENDING CCHH\nVVRXEC   DS    XL2 .               ENDING CC\nVVRXEH   DS    XL2 .               ENDING HH\nVVRXNTRK DS    XL2 .               NUMBER OF TRACKS\nVVRXSRBA DS    XL4 .               STARTING RBA\nVVRXERBA DS    XL4 .               ENDING RBA\n         EJECT\n         ORG   ICFDSECT\n         SPACE 1\n*        THIS CELL IDENTIFIES THE ACCESS METHOD DATA STATISTICS BLOCK\n*        OF A VSAM DATA COMPONENT OR INDEX COMPONENT.\n         SPACE 1\nVVRAMDCL DS    0XL98 .             VVR AMDSB CELL\nVVRAMDCN DS    XL2 .               LENGTH OF ENTIRE AMDSB CELL\n* NOTE : THE FOLLOWING MAPPING OF THE AMDSB MUST BE KEPT IN\n*        SYNCHRONIZATION WITH THE MAPPING IN IDAAMDSB.\nVVRAMCAT DS    0XL96\nVVRAMSB1 DS    0XL6\nVVRAMID  DS    XL1 .               TYPE CODE IS X'60'\nVVRAMATR DS    XL1 .               ATTRIBUTES\nVVRAMDST EQU   B'10000000' .       1 KEY SEQUENCED, 0 ENTRY SEQUENCED\nVVRAMWCK EQU   B'01000000' .       WRITE CHECK\nVVRAMSDT EQU   B'00100000' .       SEQUENCE SET WITH DATA\nVVRAMREP EQU   B'00010000' .       REPLICATION\nVVRAMORD EQU   B'00001000' .       USE VOLUMES IN LIST ORDER\nVVRAMRGE EQU   B'00000100' .       KEY RANGE DATA SET\nVVRAMRDS EQU   B'00000010' .       RELATIVE RECORD DATA SET\nVVRAMSPN EQU   B'00000001' .       SPANNED RECORDS ARE ALLOWED\nVVRAMLEN DS    XL2 .               LENGTH OF AMDSB\nVVRAMNST DS    0XL2 .              NUMBER OF ENTRIES IN INDEX SECTION\nVVRAMAKP DS    XL2 .               ALTERNATE KEY RKP\nVVRAMKEY DS    0XL4\nVVRAMRKP DS    XL2 .               RELATIVE KEY POSITION\nVVRAMKNL DS    XL2 .               KEY LENGTH\nVVRAMSB2 DS    0XL10\nVVRAMPCA DS    XL1 .               % FREE CI IN CA\nVVRAMPCI DS    XL1 .               % FREE BYTES IN CI\nVVRAMCCA DS    XL2 .               NUMBER OF CI'S PER CA\nVVRAMFCA DS    XL2 .               FREE CI'S PER CA\nVVRAMFCI DS    XL4 .               FREE BYTES PER CI\nVVRAMCIR DS    0XL8\nVVRAMCIV DS    XL4 .               CONTROL INTERVAL SIZE\nVVRAMLCL DS    XL4 .               MAXIMUM RECORD SIZE\nVVRAMSB3 DS    0XL68\nVVRAMHLR DS    0XL4 .              RBA OF HI LEVEL INDEX RECORD\nVVRAMSLT DS    XL4 .               RECORD SLOTS PER CI\nVVRAMSSR DS    0XL4 .              RBA OF FIRST SEQUENCE SET RECORD\nVVRAMMRR DS    XL4 .               MAX RELATIVE RECORD NUMBER\nVVRAMARD DS    XL4 .               POINTER TO FIRST ARDB\nVVRAMAT3 DS    XL1 .               ATTRIBUTES\nVVRAMUNQ EQU   B'10000000' .       NON-UNIQUE OR UNIQUE KEYS\nVVRAMFLT EQU   B'01000000' .       CYLINDER FAULT MSS OR STAGE\nVVRAMBND EQU   B'00100000' .       BIND OR DO NOT BIND ON MSS\nVVRAMWAT EQU   B'00010000' .       WAIT OR NOT WAIT ON RELINQUISH\nVVRAMLM  EQU   B'00001000' .       LOAD MODE OR DATA SET LOADED\nVVRAMSNO DS    XL1 .               NUMBER OF CONCURRENT REQUESTS\n         DS    XL4 .               RESERVED\nVVRAMBFI DS    0XL2 .              NUMBER OF INDEX BUFFERS\nVVRAMBFD DS    XL2 .               NUMBER OF DATA BUFFERS\nVVRAMSTS DS    XL8 .               SYSTEM TIME STAMP\nVVRAMNIL DS    XL2 .               NUMBER OF INDEX LEVELS\nVVRAMNXT DS    XL2 .               NUMBER OF EXTENTS\nVVRAMNLR DS    XL4 .               NUMBER OF LOGICAL RECORDS\nVVRAMDLR DS    XL4 .               NUMBER OF DELETED RECORDS\nVVRAMINR DS    XL4 .               NUMBER OF INSERTED RECORDS\nVVRAMUPR DS    XL4 .               NUMBER OF UPDATED RECORDS\nVVRAMRTR DS    XL4 .               NUMBER OF RETRIEVED RECORDS\nVVRAMASP DS    XL4 .               BYTES OF FREE SPACE IN DATA SET\nVVRAMCIS DS    XL4 .               NUMBER OF CI SPLITS\nVVRAMCAS DS    XL4 .               NUMBER OF CA SPLITS\nVVRAMEXC DS    XL4 .               NUMBER OF EXCP'S\nVVRAMEND EQU   *,0\n.C       SPACE 2\n&SYSECT  CSECT  .                  RESTORE ORIGINAL CSECT.\n         SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ICFSC": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL ICFSC SUPPLY.\n&NAME   $ICFSC      &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $ICFSC MACRO : CALL ICFSC SUPPLY (SEE ICFS).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(ICFSC)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(ICFSC)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(ICFSC)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ICFSO": {"ttr": 4100, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL ICFSO SUPPLY.\n&NAME   $ICFSO      &A,&B,&C,&D,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $ICFSO MACRO : CALL ICFSO SUPPLY (SEE ICFS).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 4).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0,0)            P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(ICFSO)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(ICFSO)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ICFSR": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL ICFSR SUPPLY.\n&NAME   $ICFSR      &A,&B,&C,&D,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $ICFSR MACRO : CALL ICFSR SUPPLY (SEE ICFS).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 4).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0,0)            P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(ICFSR)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(ICFSR)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ICFSW": {"ttr": 4106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87!\\x1f\\x00\\x87!\\x1f\\x08R\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-07-30T00:00:00", "modifydate": "1987-07-30T08:52:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           ICFS PROCESSING INDICATORS.\n&NAME   $ICFSW &FL\n         LCLC  &NCS\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   ('&NAME' EQ '').A\n&NCS     SETC  '&NAME'\n         AGO   .B\n.A       ANOP\n&NCS     SETC  'ICFSW'\n.B       AIF   (T'&FL EQ 'O').C\n&NCS     DC    AL1(&FL) .          ICFS - PROCESSING INDICATORS\n         AGO   .D\n.C       ANOP\n&NCS     DC    XL1'0' .            ICFS - PROCESSING INDICATORS\n.D       ANOP\nICFKEY0  EQU   X'80' .             ALREADY SUPERVISOR MODE, KEY 0\nICFAUTH  EQU   X'40' .             ALREADY AUTHORIZED\nICFMSPW  EQU   X'01' .             CATALOG MASTER PASSWORD REQUEST\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$IDENT": {"ttr": 4108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x87\\x13\\x1f\\x00\\x87\\x13\\x1f\\x15\\x05\\x00'\\x00'\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-05-11T00:00:00", "modifydate": "1987-05-11T15:05:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           MODULE IDENTIFICATION.\n&NAME   $IDENT &ID=,&DT=YES\n         LCLC  &NCS\n         SPACE 1\n.*\n.* $IDENT MACRO : MODULE IDENTIFICATION.\n.* --------------\n.*\n.*       - GENERATE THE IDENTIFIER NAME.\n.*       - GENERATE THE ASSEMBLY DATE AND TIME (DT OPERAND).\n.*\n.* ID OPERAND         - IDENTIFIER NAME (8 CHARACTERS LENGTH MAXIMUM).\n.*                      IF OMITTED, THE LABEL NAME IS USED IF SUPPLIED,\n.*                      OR THE CURRENT CONTROL SECTION NAME.\n.*\n.* DT OPERAND         - CAN BE USED TO SUPPRESS THE ASSEMBLY DATE AND\n.*                      TIME GENERATION (I.E. - DT=NO).\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   ('&NAME' EQ '').N1\n&NCS     SETC  '&NAME'\n         AGO   .N2\n.N1      ANOP\n&NCS     SETC  '&SYSECT'\n.N2      SPACE 1\n         AIF   ('&ID' EQ '').N3\n         DC    CL8'&ID' IDENTIFIER.\n         AGO   .N4\n.N3      DC    CL8'&NCS' IDENTIFIER.\n.N4      AIF   ('&DT' NE 'YES').N5\n         DC    CL8'&SYSDATE' ASSEMBLY DATE (MM/DD/YY).\n         DC    C'-'\n         DC    CL5'&SYSTIME' ASSEMBLY TIME (HH.MM).\n.N5      SPACE 1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$INSORT": {"ttr": 4110, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x01\\t\\x01\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 265, "newlines": 265, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL INSORT SUPPLY.\n&NAME   $INSORT     &A,&B,&C,&PARM=\n         LCLA  &Y,&Z,&WA\n         LCLB  &VA,&VB,&VC\n         LCLB  &SWL,&SWN,&SWP,&SWF\n         LCLC  &X,&XB,&WC,&TX(6)\n         SPACE 1\n.*\n.* $INSORT MACRO : CALL INSORT SUPPLY (SEE INSORT).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&VA      SETB  1\n&VB      SETB  1\n&VC      SETB  1\n&SWL     SETB  0\n&SWN     SETB  0\n&SWP     SETB  0\n&SWF     SETB  0\n&XB      SETC  ' '\n&TX(1)   SETC  '     NUMBER OF ELEMENTS.'\n&TX(2)   SETC  '     KEY DISPLACEMENT.'\n&TX(3)   SETC  '     KEY LENGTH.'\n&TX(4)   SETC  '     LENGTH OF AN ELEMENT.'\n&TX(5)   SETC  '     SORT ORDER OPTION (A/D).'\n&TX(6)   SETC  '     SORT COMPARE OPTION (B/P).'\n         AIF   (T'&A EQ 'O').T1\n         AIF   ('&A' NE '').T2\n.T1      ANOP\n&VA      SETB  0\n.T2      AIF   (T'&B EQ 'O').T3\n         AIF   ('&B' NE '').T4\n.T3      ANOP\n&VB      SETB  0\n.T4      AIF   (T'&C EQ 'O').T5\n         AIF   ('&C' NE '').T6\n.T5      ANOP\n&VC      SETB  0\n.T6      AIF   (&VA).P1\n         AIF   (&VC).MIS\n         AIF   (&VB).S0\n         AIF   ('&PARM' EQ '').M1\n.*\n.* MACRO : ...   $INSORT  PARM=(P1,P2,P3,P4,P5,P6)\n.*         ---> GENERATE LIST\n.*\n&Z       SETA  1\n&NAME    DS    0H     'INSORT' PARAMETERS FIELD.\n.L1      AIF   (T'&PARM(&Z) EQ 'O').L3\n         AIF   ('&PARM(&Z)' EQ '').L3\n         AIF   ('&PARM(&Z)'(1,1) EQ '(').INV\n         AIF   (&Z GT 4).L2\n         DC    AL2(&PARM(&Z))&TX(&Z)\n         AGO   .L5\n.L2      DC    C'&PARM(&Z)'&TX(&Z)\n         AGO   .L5\n.L3      AIF   (&Z GT 4).L4\n         DC    H'0'&TX(&Z)\n         AGO   .L5\n.L4      DC    C' '&TX(&Z)\n.L5      AIF   (&Z EQ 6).END\n&Z       SETA  &Z+1\n         AGO   .L1\n.*\n.* MACRO : ...   $INSORT\n.*         ---> GENERATE LIST\n.*\n.M1      ANOP\n&NAME    DS    0H     'INSORT' PARAMETERS FIELD.\n         DC    H'0'&TX(1)\n         DC    H'0'&TX(2)\n         DC    H'0'&TX(3)\n         DC    H'0'&TX(4)\n         DC    C' '&TX(5)\n         DC    C' '&TX(6)\n         AGO   .END\n.*\n.* MACRO : ...   $INSORT  A,PARM=(P1,P2,P3,P4,P5,P6)\n.*         ---> GENERATE LIST + CALL\n.*\n.P1      AIF   (&VB).S1\n         AIF   ('&PARM' EQ '').MSP\n&Y       SETA  0\n&Z       SETA  1\n&SWN     SETB  1\n&SWF     SETB  1\n&X       SETC  'IHA'.'&SYSNDX'\n&XB      SETC  'IHA'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').P2\n&NAME    DS    0H\n.P2      AIF   (T'&PARM(&Z) EQ 'O').P4\n         AIF   ('&PARM(&Z)' EQ '').P4\n         AIF   ('&PARM(&Z)'(1,1) NE '(').P4\n&WA      SETA  K'&PARM(&Z)-2\n&WC      SETC  '&PARM(&Z)'(2,&WA)\n         AIF   (&Z GT 4).P3\n         STH   &WC,&X+&Y           STORE INTO PARM. FIELD.\n         AGO   .P4\n.P3      STC   &WC,&X+&Y           STORE INTO PARM. FIELD.\n.P4      AIF   (&Z EQ 6).P6\n         AIF   (&Z GT 4).P5\n&Y       SETA  &Y+1\n.P5      ANOP\n&Y       SETA  &Y+1\n&Z       SETA  &Z+1\n         AGO   .P2\n.P6      B     &X.A\n&Z       SETA  1\n         SPACE 1\n&X       DS    0H     'INSORT' PARAMETERS FIELD.\n.P7      AIF   (T'&PARM(&Z) EQ 'O').P9\n         AIF   ('&PARM(&Z)' EQ '').P9\n         AIF   ('&PARM(&Z)'(1,1) EQ '(').P9\n         AIF   (&Z GT 4).P8\n         DC    AL2(&PARM(&Z))&TX(&Z)\n         AGO   .P11\n.P8      DC    C'&PARM(&Z)'&TX(&Z)\n         AGO   .P11\n.P9      AIF   (&Z GT 4).P10\n         DC    H'0'&TX(&Z)\n         AGO   .P11\n.P10     DC    C' '&TX(&Z)\n.P11     AIF   (&Z EQ 6).P12\n&Z       SETA  &Z+1\n         AGO   .P7\n.P12     SPACE 1\n&X.A     DS    0H\n         AGO   .C1\n.*\n.* MACRO : ...   $INSORT  ,B,PARM=(P1,P2,P3,P4,P5,P6)\n.*         ---> BUILD LIST\n.*\n.S0      AIF   ('&PARM' EQ '').MSP\n&SWP     SETB  1\n.*\n.* MACRO : ...   $INSORT  A,B,PARM=(P1,P2,P3,P4,P5,P6)\n.*         ---> BUILD LIST + GENERATE CALL\n.*\n.S1      AIF   ('&PARM' EQ '').C1\n&Y       SETA  0\n&Z       SETA  1\n&SWN     SETB  1\n         AIF   ('&NAME' EQ '').S2\n&NAME    DS    0H\n.S2      AIF   ('&B'(1,1) NE '(').S9\n&X       SETC  '&B(1)'\n.S3      AIF   (T'&PARM(&Z) EQ 'O').S7\n         AIF   ('&PARM(&Z)' EQ '').S7\n         AIF   ('&PARM(&Z)'(1,1) NE '(').S5\n&WA      SETA  K'&PARM(&Z)-2\n&WC      SETC  '&PARM(&Z)'(2,&WA)\n         AIF   (&Z GT 4).S4\n         STH   &WC,&Y.(&X)         STORE INTO PARM. FIELD.\n         AGO   .S7\n.S4      STC   &WC,&Y.(&X)         STORE INTO PARM. FIELD.\n         AGO   .S7\n.S5      AIF   (&Z GT 4).S6\n         MVC   &Y.(2,&X),=AL2(&PARM(&Z))     MOVE INTO PARM. FIELD.\n         AGO   .S7\n.S6      MVC   &Y.(1,&X),=C'&PARM(&Z)'  MOVE INTO PARM. FIELD.\n.S7      AIF   (&Z EQ 6).C1\n         AIF   (&Z GT 4).S8\n&Y       SETA  &Y+1\n.S8      ANOP\n&Y       SETA  &Y+1\n&Z       SETA  &Z+1\n         AGO   .S3\n.S9      AIF   (T'&PARM(&Z) EQ 'O').S13\n         AIF   ('&PARM(&Z)' EQ '').S13\n         AIF   ('&PARM(&Z)'(1,1) NE '(').S11\n&WA      SETA  K'&PARM(&Z)-2\n&WC      SETC  '&PARM(&Z)'(2,&WA)\n         AIF   (&Z GT 4).S10\n         STH   &WC,&B+&Y           STORE INTO PARM. FIELD.\n         AGO   .S13\n.S10     STC   &WC,&B+&Y           STORE INTO PARM. FIELD.\n         AGO   .S13\n.S11     AIF   (&Z GT 4).S12\n         MVC   &B+&Y(2),=AL2(&PARM(&Z)) MOVE INTO PARM. FIELD.\n         AGO   .S13\n.S12     MVC   &B+&Y(1),=C'&PARM(&Z)'   MOVE INTO PARM. FIELD.\n.S13     AIF   (&Z EQ 6).C1\n         AIF   (&Z GT 4).S14\n&Y       SETA  &Y+1\n.S14     ANOP\n&Y       SETA  &Y+1\n&Z       SETA  &Z+1\n         AGO   .S9\n.*\n.* MACRO : ...   $INSORT  A,B\n.*         ---> GENERATE CALL\n.*\n.C1      AIF   (&SWP).END\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   (&SWN).C2\n         AIF   ('&NAME' EQ '').C2\n&NAME    DS    0H\n.C2      AIF   (T'&SYSLIST(&Z) EQ 'O').C4\n         AIF   ('&SYSLIST(&Z)' EQ '').C4\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').C3\n         AIF   (N'&SYSLIST EQ &Z).C6\n         AGO   .C4\n.C3      ST    &SYSLIST(&Z,1),&X+&Y STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).C5\n.C4      ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .C2\n.C5      AIF   (&SWF).C6\n         OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.C6      LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n         AIF   ('&XB' EQ ' ').C7\n         AIF   (N'&SYSLIST NE 1).C7\n&SWL     SETB  1\n         AGO   .C8\n.C7      AIF   (N'&SYSLIST EQ &Z).C12\n.C8      AIF   (T'&SYSLIST(&Z) EQ 'O').C9\n         AIF   ('&SYSLIST(&Z)' EQ '').C9\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').C10\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .C11\n.C9      AIF   (&Z NE 2).C10\n         AIF   ('&XB' EQ ' ').C10\n         DC    A(&XB)              P.P. PARAMETER.\n         AGO   .C11\n.C10     DC    A(0)                P.P. PARAMETER.\n.C11     AIF   (&SWL).C14\n&Z       SETA  &Z+1\n         AGO   .C7\n.C12     AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').C16\n         AIF   (T'&SYSLIST(&Z) EQ 'O').C13\n         AIF   ('&SYSLIST(&Z)' EQ '').C13\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .C17\n.C13     AIF   (&Z NE 2).C15\n         AIF   ('&XB' EQ ' ').C15\n.C14     DC    A(&XB+X'80000000')  LAST P.P. PARAMETER.\n         AGO   .C17\n.C15     DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .C17\n.C16     DC    A(0)                LAST P.P. PARAMETER.\n.C17     ANOP\n&X.A     L     15,=V(INSORT)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         AGO   .END\n.INV     MNOTE 8,' INVALID SUBFIELD IN PARM OPERAND ***************** '\n         AGO   .END\n.MSP     MNOTE 8,' MISSING PARM OPERAND ***************************** '\n         AGO   .END\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         AGO   .END\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n.END     SPACE 1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ISPF": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91)O\\x00\\x91)O\\x16W\\x00\\xbf\\x00\\xbf\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-21T00:00:00", "modifydate": "1991-10-21T16:57:00", "lines": 191, "newlines": 191, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL ISPF VGET-VPUT SUPPLY.\n&NAME   $ISPF  &TYPE,&ID,&DATA,&POOL,&MF=\n         LCLA  &Y\n         LCLB  &W\n         LCLC  &X,&Z\n.*\n.* $ISPF MACRO : CALL ISPF VGET-VPUT SUPPLY (SEE VGPSUB).\n.* -------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 4).OPND\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   ('&TYPE' NE '').INVT\n         AIF   ('&POOL' NE '').INVT\n         AIF   ('&ID' EQ '').LS1\n         AIF   (K'&ID GT 8).BADI\n&NAME    DC    0H'0',CL8'&ID'\n         AGO   .LS2\n.LS1     ANOP\n&NAME    DC    0H'0',CL8' '\n.LS2     AIF   ('&DATA' EQ '').LS6\n         AIF   ('&DATA'(1,1) EQ '(').LS3\n         DC    AL2(L'&DATA),AL4(&DATA)\n         MEXIT\n.LS3     AIF   ('&DATA(1)' EQ '').LS5\n         AIF   ('&DATA(2)' EQ '').LS4\n         DC    AL2(&DATA(2)),AL4(&DATA(1))\n         MEXIT\n.LS4     DC    AL2(*-*),AL4(&DATA(1))\n         MEXIT\n.LS5     AIF   ('&DATA(2)' EQ '').LS6\n         DC    AL2(&DATA(2)),AL4(*-*)\n         MEXIT\n.LS6     DC    AL2(*-*),AL4(*-*)\n         MEXIT\n.XL1     AIF   ('&MF(1)' EQ 'L').XL2\n         AIF   ('&MF(1)' NE 'E').INVM\n         AIF   ('&MF(2)' EQ '').XI1\n         AIF   ('&TYPE' EQ '').MIST\n         AGO   .XL3\n.XL2     AIF   ('&TYPE' NE '').INVT\n         AIF   ('&MF(2)' EQ '').INVM\n&W       SETB  1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL6\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL6\n&NAME    DS    0H\n         AGO   .XL6\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&Z       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&Z\n.XL6     AIF   ('&ID' EQ '').XL10\n         AIF   ('&ID'(1,1) EQ '(').XL7\n         MVC   0(L'&ID,1),&ID\n         AGO   .XL10\n.XL7     AIF   ('&ID(1)' EQ '').XL9\n         AIF   ('&ID(2)' EQ '').XL8\n         MVC   0(&ID(2),1),&ID(1)\n         AGO   .XL10\n.XL8     MVC   0(8,1),&ID(1)\n         AGO   .XL10\n.XL9     AIF   ('&ID(2)' NE '').INVI\n.XL10    AIF   ('&DATA' EQ '').XL15\n         AIF   ('&DATA'(1,1) EQ '(').XL11\n         MVC   8(2,1),=AL2(L'&DATA)\n         MVC   10(4,1),=A(&DATA)\n         AGO   .XL15\n.XL11    AIF   ('&DATA(2)' EQ '').XL13\n         AIF   ('&DATA(2)'(1,1) EQ '(').XL12\n         MVC   8(2,1),=AL2(&DATA(2))\n         AGO   .XL13\n.XL12    ANOP\n&Y       SETA  K'&DATA(2)-2\n&Z       SETC  '&DATA(2)'(2,&Y)\n         AIF   ('&Z' EQ '(1)').IRDL\n         STCM  &Z,B'0011',8(1)\n.XL13    AIF   ('&DATA(1)' EQ '').XL15\n         AIF   ('&DATA(1)'(1,1) EQ '(').XL14\n         MVC   10(4,1),=A(&DATA(1))\n         AGO   .XL15\n.XL14    ANOP\n&Y       SETA  K'&DATA(1)-2\n&Z       SETC  '&DATA(1)'(2,&Y)\n         AIF   ('&Z' EQ '(1)').IRDA\n         STCM  &Z,B'1111',10(1)\n.XL15    AIF   (&W).ENDX\n         AIF   ('&TYPE' NE 'VGET').LX1\n         XR    0,0                 VGET\n         AGO   .LX2\n.LX1     AIF   ('&TYPE' NE 'VPUT').ERRT\n         LA    0,1                 VPUT\n.LX2     AIF   ('&POOL' EQ '').LX3\n         AIF   ('&POOL' EQ 'SHARED').LX3\n         AIF   ('&POOL' NE 'PROFILE').INVP\n         O     0,=A(X'80000000')\n.LX3     L     15,=V(VGPSUB)\n         BASR  14,15\n         AGO   .ENDX\n.XI1     AIF   ('&TYPE' EQ '').MIST\n         AIF   ('&ID' EQ '').MISI\n         AIF   ('&DATA' EQ '').MISD\n&X       SETC  'IHB'.'&SYSNDX'\n&NAME    LA    1,&X\n         AIF   ('&ID'(1,1) NE '(').XI2\n         AIF   ('&ID' EQ '(1)').IRID\n&Y       SETA  K'&ID-2\n&Z       SETC  '&ID'(2,&Y)\n         MVC   0(8,1),0(&Z)\n.XI2     AIF   ('&DATA'(1,1) NE '(').XI4\n         AIF   ('&DATA(1)' EQ '').INVD\n         AIF   ('&DATA(2)' EQ '').INVD\n         AIF   ('&DATA(2)'(1,1) NE '(').XI3\n&Y       SETA  K'&DATA(2)-2\n&Z       SETC  '&DATA(2)'(2,&Y)\n         AIF   ('&Z' EQ '(1)').IRDL\n         STCM  &Z,B'0011',8(1)\n.XI3     AIF   ('&DATA(1)'(1,1) NE '(').XI4\n&Y       SETA  K'&DATA(1)-2\n&Z       SETC  '&DATA(1)'(2,&Y)\n         AIF   ('&Z' EQ '(1)').IRDL\n         STCM  &Z,B'1111',10(1)\n.XI4     AIF   ('&TYPE' NE 'VGET').XI5\n         XR    0,0                 VGET\n         AGO   .XI6\n.XI5     AIF   ('&TYPE' NE 'VPUT').ERRT\n         LR    0,1                 VPUT\n.XI6     AIF   ('&POOL' EQ '').XI7\n         AIF   ('&POOL' EQ 'SHARED').XI7\n         AIF   ('&POOL' NE 'PROFILE').INVP\n         O     0,=A(X'80000000')\n.XI7     B     &X.A\n         AIF   ('&ID'(1,1) EQ '(').XI8\n         AIF   (K'&ID GT 8).BADI\n&X       DC    0H'0',CL8'&ID'\n         AGO   .XI9\n.XI8     ANOP\n&X       DC    0H'0',CL8' '\n.XI9     AIF   ('&DATA'(1,1) EQ '(').XI10\n         DC    AL2(L'&DATA),AL4(&DATA)\n         AGO   .XI14\n.XI10    AIF   ('&DATA(2)'(1,1) EQ '(').XI11\n         AIF   ('&DATA(1)'(1,1) EQ '(').XI12\n         DC    AL2(&DATA(2)),AL4(&DATA(1))\n         AGO   .XI14\n.XI11    AIF   ('&DATA(1)'(1,1) EQ '(').XI13\n         DC    AL2(*-*),AL4(&DATA(1))\n         AGO   .XI14\n.XI12    DC    AL2(&DATA(2)),AL4(*-*)\n         AGO   .XI14\n.XI13    DC    AL2(*-*),AL4(*-*)\n.XI14    ANOP\n&X.A     L     15,=V(VGPSUB)\n         BASR  14,15\n         MEXIT\n.OPND    MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.INVM    MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEXIT\n.INVT    MNOTE 8,' TYPE OPERAND INVALID IN LIST FORM **************** '\n         MEXIT\n.INVI    MNOTE 8,' ID OPERAND INVALID CODING ************************ '\n         MEXIT\n.INVD    MNOTE 8,' DATA OPERAND INVALID CODING ********************** '\n         MEXIT\n.INVP    MNOTE 8,' POOL OPERAND INVALID CODING ********************** '\n         MEXIT\n.MIST    MNOTE 8,' MISSING TYPE OPERAND ***************************** '\n         MEXIT\n.MISI    MNOTE 8,' MISSING ID OPERAND ******************************* '\n         MEXIT\n.MISD    MNOTE 8,' MISSING DATA OPERAND ***************************** '\n         MEXIT\n.IRID    MNOTE 8,' ID OPERAND INVALID REGISTER ********************** '\n         MEXIT\n.IRDL    MNOTE 8,' DATA (LENGTH) OPERAND INVALID REGISTER *********** '\n         MEXIT\n.IRDA    MNOTE 8,' DATA (ADDRESS) OPERAND INVALID REGISTER ********** '\n         MEXIT\n.BADI    MNOTE 8,' ID OPERAND TOO LONG ****************************** '\n         MEXIT\n.ERRT    MNOTE 8,' INVALID TYPE OPERAND ***************************** '\n.ENDX    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MCLOSE": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11R\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:52:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL MCLOSE SUPPLY.\n&NAME   $MCLOSE     &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $MCLOSE MACRO : CALL MCLOSE SUPPLY (SEE MCLOSE/MREAD).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(MCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(MCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(MCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MDL@IX": {"ttr": 4364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x891\\x1f\\x00\\x891\\x1f\\x11@\\x00\\xe6\\x00\\xe6\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-07T00:00:00", "modifydate": "1989-11-07T11:40:00", "lines": 230, "newlines": 230, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           EURATOM ASSIGNED MODULES INDEXES.\n&LABEL  $MDL@IX     &USE=\n.*\n.* $MDL@IX MACRO : SEE EURATOM AUTHORITY CONTROL MODULE (AUTHUGT).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         LCLA  &I,&LA,&LS,&LV,&M,&MC,&N,&TMX\n         LCLB  &SA\n         LCLC  &NMLV,&WK,&ZT\n         LCLA  &L(26)         MODULES LEVELS NUMBERS.\n         LCLB  &S(26)         MODULES SWITCHES.\n         LCLC  &T(26)         MODULES NAMES TABLE.\n         LCLC  &D(26)         MODULES DESCRIPTIONS TABLE.\n&TMX     SETA  26             TABLES DIMENSION (ONE EMPTY = LAST).\n&T(1)    SETC  'DIDOCS  '\n&D(1)    SETC  'SIMULATE OS CONSOLE AT TERMINAL.'\n&T(2)    SETC  'QSP     '\n&D(2)    SETC  'QUEUE/SPOOL.'\n&T(3)    SETC  'PSWR    '\n&D(3)    SETC  'RACF PASSWORD READ.'\n&T(4)    SETC  'AUTOCI  '\n&D(4)    SETC  'AUTOMATIC OPERATORS COMMANDS ISSUER.'\n&T(5)    SETC  'EUSUB   '\n&D(5)    SETC  'EURATOM SUBMIT.'\n&T(6)    SETC  'SCHEDULE'\n&D(6)    SETC  'AUTOMATIC OPERATORS COMMANDS SCHEDULER.'\n&T(7)    SETC  'CP      '\n&D(7)    SETC  'ENTER VM COMMANDS.'\n&T(8)    SETC  'AUTHC   '\n&D(8)    SETC  'COMMAND AUTHORIZATION INTERFACE.'\n&T(9)    SETC  'UNIT    '\n&D(9)    SETC  'PHYSICAL DEVICES INQUIRY.'\n&T(10)   SETC  'PUSE    '\n&D(10)   SETC  'PAGEING UTILIZATION PROGRAM.'\n&T(11)   SETC  'POF     '\n&D(11)   SETC  'VTAM SECONDARY PROGRAM OPERATOR.'\n&T(12)   SETC  'TSOENQ  '\n&D(12)   SETC  'DATA-SETS ENQUE''''S CONFLICTS.'\n&T(13)   SETC  'RSVENQ  '\n&D(13)   SETC  'RESOURCES ENQUE''''S RESERVE.'\n&T(14)   SETC  'VSM     '\n&D(14)   SETC  'VIRTUAL STORAGE MONITOR.'\n&T(15)   SETC  'INCORZAP'\n&D(15)   SETC  'MODIFY IN CORE STORAGE.'\n&T(16)   SETC  'CDSCB   '\n&D(16)   SETC  'VTOC FORMAT-1 DSCB.'\n&T(17)   SETC  'UNITS   '\n&D(17)   SETC  'UNIT NAMES OF DEVICE NAME TABLE.'\n&T(18)   SETC  'ZAP     '\n&D(18)   SETC  'DISPLAY AND MODIFY DATA-SETS.'\n&T(19)   SETC  'UJVD    '\n&D(19)   SETC  'IEFUJV COMPUTATIONS.'\n&T(20)   SETC  'FSPACE  '\n&D(20)   SETC  'DASD VOLUMES FREE SPACE.'\n&T(21)   SETC  'CONAN   '\n&D(21)   SETC  'OPERATOR CONSOLE ANALYSIS FACILITY.'\n&T(22)   SETC  'VCOREZAP'\n&D(22)   SETC  'VIRTUAL CORE ZAP.'\n&T(23)   SETC  'AUT98   '\n&D(23)   SETC  'AUT.-PRG. CONTROL CALLER SERVICE.'\n&T(24)   SETC  'PSWSAMP '\n&D(24)   SETC  'PACKLIST - SAMPLE TAKER.'\n&T(25)   SETC  'NOTICE  '\n&D(25)   SETC  'TSO - BROADCAST NOTICES.'\n         SPACE 1\n         AIF   ('&USE' NE '').D1\n&N       SETA  1\n         AIF   ('&LABEL' EQ '').A1\n&WK      SETC  '&LABEL         '\n         AGO   .A2\n.A1      ANOP\n&WK      SETC  '&SYSECT        '\n.A2      AIF   ('&WK'(1,8) NE 'AUTHUGT ').C1\n*        ASSIGNED MODULES INDEXES.\n*        -------------------------\n         SPACE 1\n.B1      AIF   ('&T(&N)' EQ '').B5\n&M       SETA  &N-1\n         AIF   (&M GT 9).B2\n         MNOTE *,'   &M - &T(&N)   : &D(&N) '\n         AGO   .B4\n.B2      AIF   (&M GT 99).B3\n         MNOTE *,'  &M - &T(&N)   : &D(&N) '\n         AGO   .B4\n.B3      MNOTE *,' &M - &T(&N)   : &D(&N) '\n.B4      ANOP\n&N       SETA  &N+1\n         AGO   .B1\n.B5      AIF   (&M EQ 0).TBLERR\n         SPACE 1\nMAXGN    EQU   &M             MAX. MODULE'S INDEX.\n         EJECT\n         MEXIT\n.C1      AIF   ('&T(&N)' EQ '').MODERR\n         AIF   ('&WK'(1,8) EQ '&T(&N)').C2\n&N       SETA  &N+1\n         AGO   .C1\n.C2      ANOP\n&M       SETA  &N-1\nMDL@IX   EQU   &M        MODULE INDEX.\n         MEXIT\n.D1      AIF   ('&USE' EQ 'USER').D2\n         AIF   ('&USE' EQ 'GROUP').D2\n         AIF   ('&USE' EQ 'DEFAULT').D3\n         AGO   .USEERR\n.D2      AIF   ('&LABEL' EQ '').UGLERR\n.D3      ANOP\n&SA      SETB  0\n&N       SETA  1\n.D4      ANOP\n&L(&N)   SETA  0\n&S(&N)   SETB  0\n         AIF   (&N EQ &TMX).D5\n&N       SETA  &N+1\n         AGO   .D4\n.D5      ANOP\n&LS      SETA  N'&SYSLIST\n         AIF   (&LS EQ 0).H2\n&MC      SETA  1\n.E1      ANOP\n&WK      SETC  '&SYSLIST(&MC)'\n&LA      SETA  K'&WK\n&N       SETA  1\n.E2      AIF   ('&WK'(&N,1) EQ '-').E3\n         AIF   ('&WK'(&N,1) EQ '.').E3\n         AIF   ('&WK'(&N,1) EQ ':').E3\n         AIF   ('&WK'(&N,1) EQ '/').E3\n         AIF   (&N EQ &LA).SYNERR\n&N       SETA  &N+1\n         AGO   .E2\n.E3      AIF   (&N EQ 1).SYNERR\n&M       SETA  &N-1\n         AIF   (&M GT 8).MNSERR\n&NMLV    SETC  '&WK'(1,&M)\n&ZT      SETC  '&NMLV         '\n         AIF   ('&ZT'(1,8) NE 'ALL     ').G1\n         AIF   (&SA).ALLERR\n&SA      SETB  1\n&M       SETA  &LA-&N\n&N       SETA  &N+1\n&ZT      SETC  '&WK'(&N,&M)\n&LV      SETA  &ZT\n         AIF   (&LV EQ 0).H1\n         AIF   (&LV GT 15).LVLERR\n&N       SETA  1\n.F1      AIF   (&S(&N)).F2\n&L(&N)   SETA  &LV\n.F2      AIF   (&N EQ &TMX).H1\n&N       SETA  &N+1\n         AGO   .F1\n.G1      ANOP\n&I       SETA  1\n.G2      AIF   ('&T(&I)' EQ '').MODERR\n         AIF   ('&ZT'(1,8) EQ '&T(&I)').G3\n&I       SETA  &I+1\n         AGO   .G2\n.G3      AIF   (&S(&I)).DUPERR\n&S(&I)   SETB  1\n&M       SETA  &LA-&N\n&N       SETA  &N+1\n&ZT      SETC  '&WK'(&N,&M)\n&LV      SETA  &ZT\n&L(&I)   SETA  &LV\n.H1      AIF   (&MC EQ &LS).H2\n&MC      SETA  &MC+1\n         AGO   .E1\n.H2      SPACE 1\n         AIF   ('&USE' EQ 'DEFAULT').H4\n         AIF   ('&USE' EQ 'GROUP').H3\n         DC    CL8'&LABEL'         USER NAME.\n         AGO   .H6\n.H3      DC    CL8'&LABEL'         GROUP NAME.\n         AGO   .H6\n.H4      AIF   ('&LABEL' EQ '').H5\n&LABEL   DS    0AL1                EVERY BODY LEVELS.\n         AGO   .H6\n.H5      ANOP\nDEFAULT  DS    0AL1                EVERY BODY LEVELS.\n.H6      ANOP\n&N       SETA  1\n.I1      AIF   ('&T(&N)' EQ '').I8\n&M       SETA  &N-1\n         AIF   (&M GT 9).I2\n         AIF   (&L(&N) GT 9).I3\n&ZT      SETC  '                &M - &T(&N)'\n         AGO   .I7\n.I2      AIF   (&M GT 99).I4\n         AIF   (&L(&N) GT 9).I5\n.I3      ANOP\n&ZT      SETC  '               &M - &T(&N)'\n         AGO   .I7\n.I4      AIF   (&L(&N) GT 9).I6\n.I5      ANOP\n&ZT      SETC  '              &M - &T(&N)'\n         AGO   .I7\n.I6      ANOP\n&ZT      SETC  '             &M - &T(&N)'\n.I7      DC    AL1(&L(&N))&ZT\n&N       SETA  &N+1\n         AGO   .I1\n.I8      AIF   ('&USE' EQ 'DEFAULT').I9\n         EJECT\n         MEXIT\n.I9      SPACE 2\n         MEXIT\n.TBLERR  MNOTE 8,' NO MODULES NAMES IN TABLE ************************ '\n         MEXIT\n.MODERR  MNOTE 8,' MODULE NAME NOT IN TABLE ************************* '\n         MEXIT\n.LBLERR  MNOTE 8,' MODULE NAME MISSING ****************************** '\n         MEXIT\n.USEERR  MNOTE 8,' USE= KEYWORD SYNTAX ERROR ************************ '\n         MEXIT\n.UGLERR  MNOTE 8,' USER OR GROUP NAME MISSING *********************** '\n         MEXIT\n.MNSERR  MNOTE 8,' MODULE NAME SYNTAX ERROR ************************* '\n         MEXIT\n.SYNERR  MNOTE 8,' LEVEL SPECIFICATION SYNTAX ERROR ***************** '\n         MEXIT\n.ALLERR  MNOTE 8,' ALL= KEYWORD ALREADY SPECIFIED ******************* '\n         MEXIT\n.LVLERR  MNOTE 8,' LEVEL NUMBER (0-15) ERROR ************************ '\n         MEXIT\n.DUPERR  MNOTE 8,' MODULE NAME ALREADY SPECIFIED ******************** '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MFIND": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL MFIND SUPPLY.\n&NAME   $MFIND      &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $MFIND MACRO : CALL MFIND SUPPLY (SEE MFIND/MREAD).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(MFIND)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(MFIND)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MOPEN": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL MOPEN SUPPLY.\n&NAME   $MOPEN      &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $MOPEN MACRO : CALL MOPEN SUPPLY (SEE MOPEN/MREAD).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(MOPEN)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(MOPEN)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MREAD": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL MREAD SUPPLY.\n&NAME   $MREAD      &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $MREAD MACRO : CALL MREAD SUPPLY (SEE MREAD).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(MREAD)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(MREAD)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$NOSWAP": {"ttr": 4622, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x19\\x7f\\x00\\x87\\x19\\x7f\\x16S\\x00+\\x00+\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-07-16T00:00:00", "modifydate": "1987-07-16T16:53:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           DO'NT SWAP REQUEST TO SRM.\n&NAME   $NOSWAP     &A\n         LCLC  &L\n&L       SETC  '&NAME'\n.*\n.* $NOSWAP MACRO : ISSUED TO NOTIFY SRM THAT THE ISSUING ADDRESS\n.* --------------- SPACE MUST NOT BE SWAPPED OUT UNTIL A $OKSWAP\n.*                 HAS OCCURED.\n.*\n.* OPERAND - OMITTED : SYSEVENT CODE AND ASID ARE ASSUMED IN THE\n.*                 REGISTER 0.\n.*           ADDRESS : THE ADDRESS OF THE ASID (HALFWORD).\n.*           (REGISTER) : THE INDICATED REGISTER CONTAINS THE ASID\n.*                 (BITS 16-31).\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST EQ 0).NL\n         AIF   (T'&A EQ 'O').NL\n         AIF   ('&A' EQ '').NL\n         AIF   ('&A' EQ '(0)').ST\n         AIF   ('&A'(1,1) EQ '(').SR\n&L       LA    0,X'29'             SET SYSEVENT CODE.\n&L       SETC  ''\n         ICM   0,B'1100',&A        INSERT THE ASID.\n         AGO   .NL\n.SR      ANOP\n&L       LA    0,0(&A(1))          SET THE ASID.\n&L       SETC  ''\n.ST      ANOP\n&L       SLL   0,16                SHIFT INTO PROPER POSITION.\n&L       SETC  ''\n         LA    1,X'29'             SYSEVENT CODE.\n         OR    0,1                 PUT CODE INTO.\n.NL      ANOP\n&L       SR    1,1                 CLEAR SRM RETURNS INFORMATION.\n         SVC   95                  NOTIFY SRM.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$OKSWAP": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16&\\x00*\\x00*\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:26:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           SWAP AGAIN REQUEST TO SRM.\n&NAME   $OKSWAP     &A\n         LCLC  &L\n&L       SETC  '&NAME'\n.*\n.* $OKSWAP MACRO : ISSUED TO NOTIFY SRM THAT THE ISSUING ADDRESS\n.* --------------- SPACE MAY AGAIN BE CONSIDERD FOR SWAPPING.\n.*\n.* OPERAND - OMITTED : SYSEVENT CODE AND ASID ARE ASSUMED IN THE\n.*                 REGISTER 0.\n.*           ADDRESS : THE ADDRESS OF THE ASID (HALFWORD).\n.*           (REGISTER) : THE INDICATED REGISTER CONTAINS THE ASID\n.*                 (BITS 16-31).\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST EQ 0).NL\n         AIF   (T'&A EQ 'O').NL\n         AIF   ('&A' EQ '').NL\n         AIF   ('&A' EQ '(0)').ST\n         AIF   ('&A'(1,1) EQ '(').SR\n&L       LA    0,X'2A'             SET SYSEVENT CODE.\n&L       SETC  ''\n         ICM   0,B'1100',&A        INSERT THE ASID.\n         AGO   .NL\n.SR      ANOP\n&L       LA    0,0(&A(1))          SET THE ASID.\n&L       SETC  ''\n.ST      ANOP\n&L       SLL   0,16                SHIFT INTO PROPER POSITION.\n&L       SETC  ''\n         LA    1,X'2A'             SYSEVENT CODE.\n         OR    0,1                 PUT CODE INTO.\n.NL      ANOP\n&L       SR    1,1                 CLEAR SRM RETURNS INFORMATION.\n         SVC   95                  NOTIFY SRM.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$OPCOM": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL OPCOM SUPPLY.\n&NAME   $OPCOM      &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $OPCOM MACRO : CALL OPCOM SUPPLY (SEE OPCOM).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(OPCOM)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(OPCOM)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(OPCOM)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PCLOSE": {"ttr": 4870, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x01\\x8f\\x00\\x89\\x01\\x8f\\t5\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-01-18T00:00:00", "modifydate": "1989-01-18T09:35:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL PCLOSE SUPPLY.\n&NAME   $PCLOSE     &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $PCLOSE MACRO : CALL PCLOSE SUPPLY (SEE PCLOSE/PRINT).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(PCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(PCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(PCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PDCLOSE": {"ttr": 4873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x04\\x8f\\x00\\x93\\x04\\x8f\\x16!\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-17T00:00:00", "modifydate": "1993-02-17T16:21:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL PDCLOSE SUPPLY.\n&NAME   $PDCLOSE    &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $PDCLOSE MACRO : CALL PDCLOSE SUPPLY (SEE PDCLOSE/PDREAD).\n.* ----------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(PDCLOSE)      LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(PDCLOSE)      LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(PDCLOSE)      LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PDOPEN": {"ttr": 4876, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x04\\x9f\\x00\\x93\\x04\\x9f\\x10S\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-18T00:00:00", "modifydate": "1993-02-18T10:53:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL PDOPEN SUPPLY.\n&NAME   $PDOPEN     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $PDOPEN MACRO : CALL PDOPEN SUPPLY (SEE PDOPEN/PDREAD).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(PDOPEN)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(PDOPEN)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(PDOPEN)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PDREAD": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x04\\x8f\\x00\\x93\\x04\\x8f\\x16 \\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-17T00:00:00", "modifydate": "1993-02-17T16:20:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL PDREAD SUPPLY.\n&NAME   $PDREAD     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $PDREAD MACRO : CALL PDREAD SUPPLY (SEE PDREAD).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(PDREAD)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(PDREAD)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PLCLOSE": {"ttr": 5124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x08/\\x00\\x93\\x08/\\x11Q\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-23T00:00:00", "modifydate": "1993-03-23T11:51:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL PLCLOSE SUPPLY.\n&NAME   $PLCLOSE    &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $PLCLOSE MACRO : CALL PLCLOSE SUPPLY (SEE PLCLOSE/PLREAD).\n.* ----------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(PLCLOSE)      LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(PLCLOSE)      LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    XR    1,1                 NO PARM. LIST.\n         L     15,=V(PLCLOSE)      LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PLOPEN": {"ttr": 5127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x08/\\x00\\x93\\x08/\\x11P\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-23T00:00:00", "modifydate": "1993-03-23T11:50:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL PLOPEN SUPPLY.\n&NAME   $PLOPEN     &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $PLOPEN MACRO : CALL PLOPEN SUPPLY (SEE PLOPEN/PLREAD).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(PLOPEN)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(PLOPEN)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    XR    1,1                 NO PARM. LIST.\n         L     15,=V(PLOPEN)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PLPOINT": {"ttr": 5130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x08/\\x00\\x93\\x08/\\x11C\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-23T00:00:00", "modifydate": "1993-03-23T11:43:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL PLPOINT SUPPLY.\n&NAME   $PLPOINT    &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $PLPOINT MACRO : CALL PLPOINT SUPPLY (SEE PLPOINT/PLREAD).\n.* ----------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(PLPOINT)      LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(PLPOINT)      LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PLREAD": {"ttr": 5133, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x08/\\x00\\x93\\x08/\\x11B\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-23T00:00:00", "modifydate": "1993-03-23T11:42:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL PLREAD SUPPLY.\n&NAME   $PLREAD     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $PLREAD MACRO : CALL PLREAD SUPPLY (SEE PLREAD).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(PLREAD)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(PLREAD)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PRINT": {"ttr": 5379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL PRINT SUPPLY.\n&NAME   $PRINT      &A,&B,&C,&D,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $PRINT MACRO : CALL PRINT SUPPLY (SEE PRINT).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 4).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0,0)            P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(PRINT)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(PRINT)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PUNCH": {"ttr": 5382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL PUNCH SUPPLY.\n&NAME   $PUNCH      &A,&B,&C,&D,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $PUNCH MACRO : CALL PUNCH SUPPLY (SEE PUNCH).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 4).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0,0)            P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(PUNCH)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(PUNCH)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$RCLOSE": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x01\\x8f\\x00\\x89\\x01\\x8f\\t5\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-01-18T00:00:00", "modifydate": "1989-01-18T09:35:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL RCLOSE SUPPLY.\n&NAME   $RCLOSE     &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $RCLOSE MACRO : CALL RCLOSE SUPPLY (SEE RCLOSE/READ).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(RCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(RCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(RCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$RDCHK": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL RDCHK SUPPLY.\n&NAME   $RDCHK      &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $RDCHK MACRO : CALL RDCHK SUPPLY (SEE RDCHK).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 2).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 2).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(RDCHK)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(RDCHK)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$READ": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL READ SUPPLY.\n&NAME   $READ       &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $READ MACRO : CALL READ SUPPLY (SEE READ).\n.* -------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(READ)         LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(READ)         LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SDATE": {"ttr": 5636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL SDATE SUPPLY.\n&NAME   $SDATE      &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $SDATE MACRO : CALL SDATE SUPPLY (SEE SDATE).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 2).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 2).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(SDATE)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(SDATE)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SETOPC": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL SETOPC SUPPLY.\n&NAME   $SETOPC     &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $SETOPC MACRO : CALL SETOPC SUPPLY (SEE SETOPC/OPCOM).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(SETOPC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(SETOPC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(SETOPC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SIDTB": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x07\\x8f\\x00\\x87\\x07\\x8f\\x11\\x11\\x00T\\x00T\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-03-19T00:00:00", "modifydate": "1987-03-19T11:11:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           SMF - SYSTEM ID'S FACTOR TABLE.\n&NAME   $SIDTB      &TYPE=\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         LCLC  &NM\n         AIF   ('&TYPE' EQ '').MISS\n         AIF   ('&TYPE' EQ 'I/O').A\n         AIF   ('&TYPE' EQ 'CPU').C\n         MNOTE 8,' INVALID TYPE= OPERAND SPECIFIED ****************** '\n         MEXIT\n.MISS    MNOTE 8,' TYPE= OPERAND MISSING **************************** '\n         MEXIT\n.A       SPACE 1\n* I/O TO SRB TIME EVALUATION :\n* ----------------------------\n*\n*        ONE (1) SECOND OF SRB TIME IS EQUIVALENT TO THE EXECUTION OF\n*        THOUSAND (1000) I/O OPERATIONS (IN THE WORST CASE), BUT THIS\n*        IS CPU DEPENDENT, AND THE REAL SRB TIME MAY VARY WITH TRACE\n*        ON OR OFF, ACCESS METHOD AND/OR PROGRAMMING LANGUAGE USED\n*        (I.E., THE ASSEMBLER IS NORMALLY MORE THAN TWICE FASTER).\n*        IN A COMPLEX OF COMPUTERS, OFTEN ALL OF THESE ARE NOT THE\n*        SAME MODEL AND THUS NOT SAME CPU SPEED. TO REFLECT THIS\n*        SITUATION, A SYSTEM SPEED FACTOR IS APPLIED TO THE JOB SRB\n*        TIME (I/O) IN ORDER TO EXTEND IT IN CORRESPONDENCE TO THE\n*        FASTEST SYSTEM IN THE COMPLEX.\n*        I.E.- IF A SYSTEM-A IS THE FASTEST SYSTEM AND A SYSTEM-B\n*              NEEDS TWICE THE CPU-TIME THAN THE SYSTEM-A FOR A JOB\n*              EXECUTION, THEN SET THE SYSTEM-A SPEED FACTOR TO 1000000\n*              AND THE SYSTEM-B SPEED FACTOR TO 2000000.\n&NM      SETC  'SIDIO'\n         AIF   ('&NAME' EQ '').B\n&NM      SETC  '&NAME'\n.B       SPACE 1\n         DS    0F                  SET ALIGNMENT.\n&NM      DS    0XL8                SYSTEM-ID'S / FACTOR TABLE.\n         DC    CL4'SYSA'           SYSTEM ID.\n         DC    F'1000000'          APPLY FACTOR.\n         DC    CL4'SYSB'           SYSTEM ID.\n         DC    F'1000000'          APPLY FACTOR.\n*              HERE FOLLOWS THE LAST ELEMENT OF THE TABLE, USED AS\n*              DEFAULT. IT LOOKS LIKE THE FASTER CPU IN THE COMPLEX,\n*              WHICH MEANS NO CHANGE.\n         DC    XL4'0'              LAST ELEMENT (DEFAULT).\n         DC    F'1000000'          ONE MILLION MICRO-SECOND.\n         MEXIT\n.C       SPACE 1\n* CPU-TIME SYSTEM SPEED EVALUATION :\n* ----------------------------------\n*\n*        IN A COMPLEX OF COMPUTERS, OFTEN ALL OF THESE ARE NOT THE\n*        SAME MODEL AND THUS NOT SAME CPU SPEED. TO REFLECT THIS\n*        SITUATION, A SYSTEM SPEED FACTOR IS APPLIED TO THE JOB\n*        CPU TIME IN ORDER TO EXTEND IT IN CORRESPONDENCE TO THE\n*        FASTEST SYSTEM IN THE COMPLEX.\n*        I.E.- IF A SYSTEM-A IS THE FASTEST SYSTEM AND A SYSTEM-B\n*              NEEDS TWICE THE CPU-TIME THAN THE SYSTEM-A FOR A JOB\n*              EXECUTION, THEN SET THE SYSTEM-A SPEED FACTOR TO 100\n*              AND THE SYSTEM-B SPEED FACTOR TO 200.\n&NM      SETC  'SIDCPU'\n         AIF   ('&NAME' EQ '').D\n&NM      SETC  '&NAME'\n.D       SPACE 1\n*        THE VALUE OF SYMBOL HERE AFTER DEFINES IN MINUTES THE LEVEL\n*        FROM WHICH ANY RE-EVALUATED JOB OR STEP TIME LIMIT WILL BE\n*        SIGNALED TO THE OPERATOR (INFORMATIONAL MESSAGE).\n@OPSGLV  EQU   30                  OPERATOR SIGNAL LEVEL (IN MINUTES).\n         SPACE 1\n         DS    0F                  SET ALIGNMENT.\n&NM      DS    0XL8                SYSTEM-ID'S / FACTOR TABLE.\n         DC    CL4'SYSA'           SYSTEM ID.\n         DC    F'100'              APPLY FACTOR.\n         DC    CL4'SYSB'           SYSTEM ID.\n         DC    F'100'              APPLY FACTOR.\n*              HERE FOLLOWS THE LAST ELEMENT OF THE TABLE, WHICH LOOKS\n*              LIKE THE FASTER CPU IN THE COMPLEX, AND IS USED TO SEE\n*              IF ANY RE-EVALUATION MUST BE DONE.\n         DC    XL4'0'              LAST ELEMENT.\n         DC    F'100'              HUNDRED OF SECONDS.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SNAP": {"ttr": 5645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL SNAP SUPPLY.\n&NAME   $SNAP       &A,&B,&C,&D,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $SNAP MACRO : CALL SNAP SUPPLY (SEE SNAP).\n.* -------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 4).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 2).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0,0)            P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 2).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(SNAP)         LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(SNAP)         LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SORT": {"ttr": 5891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16'\\x00j\\x00j\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:27:00", "lines": 106, "newlines": 106, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&NAME   $SORT  &TB,&NE,&LE,&SF,&LF,&NOTES=\n         LCLC  &X\n.* AUTHOR :    EXTRACTED FROM \"STATDS\" PROGRAM (A. BRUCE LELAND)\n.* --------    AND ADAPTED AS MACRO (P.A. MOINIL).\n         AIF   ('&NOTES' NE 'YES').A1\n         SPACE 1\n* PURPOSE :    SORT IN ASCENDING ORDER (ONE CONTROL FIELD ONLY) AN\n* ---------    ARRAY OF FIXED ELEMENTS (USES A SHELL SORT).\n*\n* SYNTAX :     $SORT TB,NE,LE,SF,LF,NOTES=YES\n* --------\n*\n* OPERANDS :   TB - ARRAY STARTING ADDRESS (REGISTER USE MAY BE\n* ----------        CODED WITHIN PARENTHESES).\n*              NE - NUMBER OF ELEMENTS IN THE ARRAY TO BE SORTED\n*                   (REGISTER USE MAY BE CODED WITHIN PARENTHESES).\n*              LE - LENGTH OF AN ELEMENT. THE VALUE MUST BE IN THE\n*                   RANGE 1 TO 256 INCLUDED.\n*              SF - STARTING POSITION OF THE CONTROL FIELD IN THE\n*                   ARRAY'S ELEMENTS, ASSUMING THE FIRST POSITION\n*                   OF AN ELEMENT KNOWN AS 0 (ZERO). THE VALUE\n*                   MUST BE IN THE RANGE 0 TO 255 INCLUDED.\n*              LF - LENGTH IN CHARACTERS OF THE CONTROL FIELD. THE\n*                   VALUE MUST BE IN THE RANGE 1 TO 256 INCLUDED.\n*\n* CONTROL :    IT IS USER RESPONSABILITY TO VERIFY THE FOLLOWING\n* ---------    EXPRESSIONS (UNLESS THE RESULTS ARE UNPREDICTABLES) :\n*                   1.  1 <= \"LE\" <= 256\n*                   2.  0 <= \"SF\" <= 255\n*                   3.  1 <= \"LF\" <= 256\n*                   4.  \"SF\" + \"LF\" <= \"LE\"\n*\n* NOTE :       THE INLINE GENERATED CODING SAVES AND RESTORES THE\n* ------       NEEDED REGISTERS CONTENTS (0, 1, 2, 3, 4, 14 AND 15)\n*              IN THE CURRENT SAVE AREA (POINTED BY REGISTER 13), AND\n*              ASSUMES THAT THE BASE REGISTER IS NOT ONE OF THESE.\n.A1      SPACE 1\n         AIF   (N'&SYSLIST GT 5).BAD\n         AIF   (T'&TB EQ 'O').MIS\n         AIF   (T'&NE EQ 'O').MIS\n         AIF   (T'&LE EQ 'O').MIS\n         AIF   (T'&SF EQ 'O').MIS\n         AIF   (T'&LF EQ 'O').MIS\n         AIF   ('&LE'(1,1) EQ '(').INV\n         AIF   ('&SF'(1,1) EQ '(').INV\n         AIF   ('&LF'(1,1) EQ '(').INV\n&X       SETC  'IHS'.'&SYSNDX'\n&NAME    STM   14,4,12(13)         SAVE REGISTERS AROUND SORT\n         AIF   ('&TB'(1,1) NE '(').B1\n         LA    &TB(1),0(,&TB(1))\n         S     &TB(1),&X.K\n         ST    &TB(1),&X.J         SET ARRAY BASE ADDRESS\n.B1      AIF   ('&NE'(1,1) EQ '(').C1\n         L     3,&X.L              NUMBER OF ELEMENTS TO SORT\n         AGO   .C2\n.C1      AIF   ('&NE' EQ '(3)').C2\n         LTR   3,&NE(1,1)          NUMBER OF ELEMENTS TO SORT\n         AGO   .C3\n.C2      LTR   3,3\n.C3      BNP   &X\n         MH    3,&X.K+2            GAP IS LENGTH * NO. OF ELEMENTS\n         LR    0,3                 N=GAP\n&X.A     SR    2,2                 GAP=GAP/2  (DROP FRACTION BITS)\n         D     2,&X.K\n         SRL   3,1\n         LTR   3,3                 GAP LESS THAN ONE?\n         BZ    &X                  YES, DONE\n         MH    3,&X.K+2\n         L     2,&X.J              ARRAY BASE ADDRESS\n         LR    4,3                 I=GAP\n&X.B     LA    4,&LE.(,4)          I=I+1 (ELEMENT WIDTH)\n         CR    4,0                 I<=N?\n         BH    &X.A                NO, HALVE THE GAP\n         LR    1,4                 YES, J=I\n&X.C     SR    1,3                 J=J-GAP\n         BNP   &X.B                IF J<=0, INCREMENT I\n         LA    15,0(2,1)           ADDRESS OF ELEMENT(J)\n         LA    14,0(3,1)           JG=J+GAP\n         LA    14,0(2,14)          ADDRESS OF ELEMENT(JG)\n         CLC   &SF.(&LF,15),&SF.(14)    ELEMENT(J) <= ELEMENT(JG)\n         BNH   &X.B                YES, INCREMENT I\n         XC    0(&LE,14),0(15)     INTERCHANGE\n         XC    0(&LE,15),0(14)          ELEMENT ENTRIES\n         XC    0(&LE,14),0(15)               J AND JG\n         B     &X.C                INCREMENT J\n         SPACE 1\n         AIF   ('&TB'(1,1) EQ '(').J1\n&X.J     DC    A(&TB-&LE)\n         AGO   .J2\n.J1      ANOP\n&X.J     DC    A(0)\n.J2      ANOP\n&X.K     DC    A(&LE)\n         AIF   ('&NE'(1,1) EQ '(').J3\n&X.L     DC    A(&NE)\n.J3      SPACE 1\n&X       LM    14,4,12(13)         RESTORE REGISTERS\n         AGO   .END\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         AGO   .END\n.MIS     MNOTE 8,' MISSING OPERAND(S) ******************************* '\n         AGO   .END\n.INV     MNOTE 8,' INVALID OPERAND(S) ******************************* '\n.END     SPACE 1\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SORT@": {"ttr": 5894, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x12\\x00)\\x00)\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:12:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      $SORT     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     GENERATE INLINE SORT MACRO      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :   Sort in ascending order (one control field only) an\n  ---------   array of fixed elements (uses a SHELL SORT).\n\n  Syntax :    $SORT TB,NE,LE,SF,LF,NOTES=YES\n  --------\n\n  Operands :  TB - array starting address (register use may be\n  ----------       coded within parentheses).\n              NE - number of elements in the array to be sorted\n                   (register use may be coded within parentheses).\n              LE - length of an element. The value must be in the\n                   range 1 to 256 included.\n              SF - starting position of the control field in the\n                   array's elements, assuming the first position\n                   of an element known as 0 (zero). The value\n                   must be in the range 0 to 255 included.\n              LF - length in characters of the control field. The\n                   value must be in the range 1 to 256 included.\n              NOTES=YES - generate inline this text. default is NO.\n\n  Control :   It is user responsability to verify the following\n  ---------   expressions (unless the results are unpredictables) :\n\n                      1.  1 <= \"LE\" <= 256\n                      2.  0 <= \"SF\" <= 255\n                      3.  1 <= \"LF\" <= 256\n                      4.  \"SF\" + \"LF\" <= \"LE\"\n\n  Note :      The inline generated coding saves and restores the\n  ------      needed registers contents (0, 1, 2, 3, 4, 14 and 15)\n              in the current save area (pointed by register 13), and\n              assumes that the base register is not one of these.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SRPI": {"ttr": 5896, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18/\\x00\\x88\\x18/\\x119\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-30T00:00:00", "modifydate": "1988-06-30T11:39:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL SRCHRPI SUPPLY.\n&NAME   $SRPI  &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $SRPI MACRO : CALL SRCHRPI SUPPLY (SEE SRCHRPI).\n.* -------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 2).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 2).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(SRCHRPI)      LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(SRCHRPI)      LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SSCMD": {"ttr": 5899, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL SSCMD SUPPLY.\n&NAME   $SSCMD      &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $SSCMD MACRO : CALL SSCMD SUPPLY (SEE SSCMD).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(SSCMD)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(SSCMD)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(SSCMD)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$TEW$DS": {"ttr": 5902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x13\\x1f\\x00\\x94\\x13\\x1f\\x15P\\x000\\x000\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-11T00:00:00", "modifydate": "1994-05-11T15:50:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO      TSO EASY-WAY OF CODING - DSECT'S\n&NAME   $TEW$DS     &CVT=NO,&TIOT=NO,&VCPL=NO\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE (TP 361)\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n         GBLB  &TEWECSC,&TEWECST\n         GBLB  &TEWPGSW,&TEWPGSG,&TEWPGSP\n         GBLB  &TEWPPSW,&TEWPPUW\n         AIF   ('&NAME' EQ '').A\n         MNOTE 4,' LABEL (NAME) NOT EXPECTED ************************ '\n.A       IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         IKJPSCB\nPSCBLEN  EQU   *-PSCB\n         IKJEBECA\n         AIF   (NOT &TEWECSC).B\nCIBDSECT DSECT\nCIB     IEZCIB\n.B       AIF   (&TEWECST).B1\n         AIF   ('&TIOT' NE 'YES').C\n.B1      ANOP\nTIODSECT DSECT\n        IEFTIOT1\n.C       AIF   (NOT &TEWPGSW).E\n        IKJIOPL\nIOPLLEN  EQU   *-IOPL\n         AIF   (NOT &TEWPGSP).D\n        IKJPTPB\nPTPBLEN  EQU   *-PTPB\n.D       AIF   (NOT &TEWPGSG).E\n        IKJGTPB\nGTPBLEN  EQU   *-GTPB\n.E       AIF   (&TEWPPSW).E1\n         AIF   ('&CVT' NE 'YES').E2\n.E1     CVT    DSECT=YES,LIST=YES\n         AIF   (NOT &TEWPPSW).E2\n        IKJPPL\nPPLLEN   EQU   *-PPL\n         AIF   (&TEWPPUW).E3\n.E2      AIF   ('&VCPL' NE 'YES').END\n.E3      SPACE 1\nVCPL     DSECT ,              VALIDITY CHECK PARAMETER LIST\nPDEADR   DS    A                   --> PDE BUILT BY IKJPARS\nUSERWORD DS    A                   USER SUPPLIED VALUE (FROM PPLUWA)\nVALMSG   DC    X'FF000000'         2ND-LVL MSG PTR (FEEDBACK FIELD)\nVCPLLEN  EQU   *-VCPL              LENGTH\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$TEW$EC": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94%/\\x00\\x94%/\\x142\\x01\\x8d\\x01\\x8d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-09-09T00:00:00", "modifydate": "1994-09-09T14:32:00", "lines": 397, "newlines": 397, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO      TSO EASY-WAY OF CODING - ENTRY CHECKS\n&NAME   $TEW$EC     &REG=R1,&TIOT=NO,&COMM=NO,&NOTTSO=,&NOTCMD=,       X\n               &MSG=,&ERR=,&PUT=,&GET=,&REL=,&SCAN=NO,&DOC=NO\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE (TP 361)\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n         GBLB  &TEWECSC,&TEWECST\n         GBLB  &TEWMRSW\n         GBLB  &TEWPGSW,&TEWPGSG,&TEWPGSP\n         GBLB  &TEWSCSW\n         GBLC  &TEWMRNM,&TEWMRNE\n         LCLB  &SW,&NT\n         LCLC  &NTV,&R,&W,&X,&Y,&Z\n&SW      SETB  0\n&NT      SETB  0\n&NTV     SETC  ''\n         AIF   ('&NAME' EQ '').A\n&NAME    EQU   *\n.A       AIF   ('&NOTTSO' EQ '').A3\n         AIF   ('&NOTTSO'(1,1) EQ '(').A1\n&NTV     SETC  '&NOTTSO'\n         AGO   .A3\n.A1      AIF   (T'&NOTTSO(1) EQ 'O').A2\n         AIF   ('&NOTTSO(1)' EQ '').A2\n&NTV     SETC  '&NOTTSO(1)'\n.A2      AIF   (T'&NOTTSO(2) EQ 'O').A3\n         AIF   ('&NOTTSO(2)' EQ '').A3\n         AIF   ('&NOTTSO(2)' NE 'ONLY').ERR1\n&NT      SETB  1\n.A3      AIF   ('&NTV' EQ '').A4\n         AIF   ('&NOTCMD' NE '').A5\n.A4      AIF   ('&MSG' EQ '').ERR2\n         AIF   ('&ERR' EQ '').ERR3\n         AGO   .A9\n.A5      AIF   ('&PUT' EQ '').A7\n         AIF   ('&MSG' EQ '').ERR4\n         AIF   ('&GET' EQ '').A6\n         AIF   ('&REL' EQ '').ERR5\n         AGO   .A9\n.A6      AIF   ('&REL' NE '').ERR6\n         AGO   .A9\n.A7      AIF   ('&GET' EQ '').A8\n         AIF   ('&MSG' EQ '').ERR7\n         AIF   ('&REL' EQ '').ERR5\n         AGO   .A9\n.A8      AIF   ('&REL' NE '').ERR6\n         AIF   ('&MSG' NE '').A9\n&SW      SETB  1\n.A9      ANOP\n&X       SETC  'GIB'.'&SYSNDX'\n&Y       SETC  'GIC'.'&SYSNDX'\n&Z       SETC  'GIW'.'&SYSNDX'\n&TEWMRNM SETC  '&MSG'\n&TEWMRNE SETC  '&ERR'\n&W       SETC  'TSO,PSB'\n         AIF   ('&COMM' NE 'YES').B\n&TEWECSC SETB  1\n&W       SETC  'COMM,'.'&W'\n.B       AIF   ('&TIOT' NE 'YES').B1\n&TEWECST SETB  1\n&W       SETC  'TIOT,'.'&W'\n.B1      SPACE 1\n*------- TSO entry checks\n         SPACE 1\n         AIF   ('&REG' EQ '0').C\n         AIF   ('&REG' EQ 'R0').C\n         AIF   ('&REG' EQ '1').C\n         AIF   ('&REG' EQ 'R1').C\n         AIF   ('&REG' EQ '13').C\n         AIF   ('&REG' EQ 'R13').C\n         AIF   ('&REG' EQ '14').C\n         AIF   ('&REG' EQ 'R14').C\n         AIF   ('&REG' EQ '15').C\n         AIF   ('&REG' EQ 'R15').C\n&R       SETC  '&REG'\n         AGO   .C1\n.C       ANOP\n&R       SETC  'R2'\n         LR    &R,&REG           . GET ENTRY REGISTER\n.C1      XC    #TSXLS(#TSXLSL),#TSXLS\n        EXTRACT #TSXLSA,'S',FIELDS=(&W.),MF=(E,#TSXLS)\n         AIF   ('&DOC' NE 'YES').D\n         SPACE 1\n* After EXTRACT execution, results are :\n*             + Batch-Exec     + TSO-Background + TSO-Foreground +\n*        -----+----------------+----------------+----------------+\n*         TSO +     A.flag     +     A.flag     +     A.flag     +\n*        flag +     X'00'      +     X'00'      +     X'80'      +\n*         PSB +     0          +     A.PSCB     +     A.PSCB     +\n*        -----+----------------+----------------+----------------+\n         SPACE 1\n.D       L     R1,#TSTSOF        . TSO-FLAG ADDRESS\n         MVC   #TSFLAG,0(R1)     . MOVE IN THE ANSWER TO OUR FLAG\n         AIF   (NOT &NT).D2\n         TM    #TSFLAG,#TSFRUN   . TSO FOREGROUND RUNNING ?\n         AIF   ('&NTV' EQ '').D1\n         BZ    &NTV              . NO\n         L     R1,#TSPSCB        . PSCB ADDRESS\n         AGO   .D3\n.D1      BO    &X.A              . YES\n         LA    R1,&Z.A           . NO, REJECT\n         BAS   R14,&MSG\n         B     &ERR\n&Z.A    WTO    ' => Only TSO foreground run allowed',                  X\n               ROUTCDE=11,DESC=7,MF=L\n&X.A     L     R1,#TSPSCB        . PSCB ADDRESS\n         AGO   .D3\n.D2      L     R1,#TSPSCB        . PSCB ADDRESS\n         LTR   R1,R1             . TSO RUNNING ?\n         AIF   ('&NTV' EQ '').D4\n         BZ    &NTV              . NO\n.D3      USING CPPL,&R           . SET CPPL ADDRESSABILITY\n         BAS   R14,&X.B          . CHECK TSO COMMAND\n         AGO   .D5\n.D4      BNZ   &X.A              . YES\n         LA    R1,&Z.A           . NO, REJECT\n         BAS   R14,&MSG\n         B     &ERR\n&Z.A    WTO    ' => not TSO environment running',                      X\n               ROUTCDE=11,DESC=7,MF=L\n         USING CPPL,&R           . SET CPPL ADDRESSABILITY\n&X.A     BAS   R14,&X.B          . CHECK TSO COMMAND\n.D5      LR    R1,&R\n         USING IKJEBECA,R1\n         L     &R,CAPTTMP        . CPPL ADDRESS (EDIT)\n         DROP  R1\n         BAS   R14,&X.B          . CHECK TSO SUB-COMMAND\n         AIF   ('&NOTCMD' EQ '').D6\n         B     &NOTCMD           . NO, REJECT\n         USING PSCB,R1\n&X.B     CLC   PSCBUPT,CPPLUPT   . CPPL+4 = UPT ADDRESS ?\n         BNER  R14               . NO\n         CL    R1,CPPLPSCB       . CPPL+8 = PSCB ADDRESS ?\n         BNER  R14               . NO\n         DROP  R1,&R\n         AIF   (NOT &SW).D7\n         AIF   ('&SCAN' NE 'YES').H\n         B     &X.I\n         AGO   .H\n.D6      LA    R1,&Z.B           . NO, REJECT\n         BAS   R14,&MSG\n         B     &ERR\n&Z.B    WTO    ' => not TSO command (or subcommand)',                  X\n               ROUTCDE=11,DESC=7,MF=L\n         USING PSCB,R1\n&X.B     CLC   PSCBUPT,CPPLUPT   . CPPL+4 = UPT ADDRESS ?\n         BNER  R14               . NO\n         CL    R1,CPPLPSCB       . CPPL+8 = PSCB ADDRESS ?\n         BNER  R14               . NO\n         DROP  R1,&R\n.D7      B     &X.I\n         AIF   ('&MSG' EQ '').F\n&TEWMRSW SETB  1\n         EJECT\n         AIF   ('&DOC' NE 'YES').E\n*------- TSO MESSAGE - Routine\n* On entry --- R1  = address of message WTO list form\n*              R14 = link register\n*        Work-registers : R0, R1, R14 and R15\n         SPACE 1\n.E       ANOP\n&MSG     ST    R14,#TSSREGM      . SAVE CALLER'S RETURN\n         TM    #TSFLAG,#TSFRUN   . IS IT TSO?\n         BO    &X.C              . YES, GO DO \"TPUT\"\n        WTO    MF=(E,(1))        . NO, USE \"WTO\"\n         B     &X.D\n&X.C     LH    R0,0(,R1)         . GET LENGTH OF \"WTO\" MESSAGE\n         SH    R0,&Y.A           . SUBTRACT OFF \"WTO\" HEADER\n         AH    R1,&Y.A           . BUMP MESSAGE ADDRESS PAST HEADER\n        TPUT   (1),(0),R         . DO THE \"TPUT\"\n&X.D     L     R14,#TSSREGM      . RESTORE CALLER'S RETURN\n         BR    R14               . RETURN TO CALLER\n.F       AIF   ('&PUT' EQ '').G\n&TEWMRSW SETB  1\n&TEWPGSP SETB  1\n&TEWPGSW SETB  1\n         EJECT\n         AIF   ('&DOC' NE 'YES').F1\n*------- TSO PUTLINE - Routine\n*        (R2 and R14 saved/restored, R3-R13 not used by routine)\n*              R14 : link register\n* On entry --- R0 : message text length\n*              R1 : points to the message text\n*        Work-registers : R0, R1, R2, R14 and R15\n* On exit ---- R15 : return code, value may be\n*                    0 = PUTLINE complete normally\n*                    4 = PUTLINE error (error message sent)\n         SPACE 1\n.F1      ANOP\n&PUT     ST    R2,#TSSREGS       . SAVE CALLER'S REGISTER\n         ST    R14,#TSSREGR      . SAVE CALLER'S RETURN\n         XC    #TSMCTL,#TSMCTL\n         MVI   #TSMOUT,C' '      . CLEAR BUFFER TO SPACES\n         MVC   #TSMOUT+1(L'#TSMOUT-1),#TSMOUT\n         LTR   R0,R0\n         BNP   &X.E              . MESSAGE LENGTH ERROR\n         LA    R2,L'#TSMOUT\n         CLR   R0,R2\n         BNL   *+L'*+2\n         LR    R2,R0\n         BCT   R2,*+L'*+6\n         MVC   #TSMOUT(*-*),0(R1)\n         EX    R2,*-6\n         LA    R2,L'#TSMCTL+1(R2)\n         STH   R2,#TSMCTL        . SET IN PUTLINE LINE LENGTH\n         LA    R0,#TSMWRK        . ADDRESS OF MSG BUFFER\n         L     R2,#TSCPPL        . ADDRESS OF CPPL\n         USING CPPL,R2\n         L     R14,CPPLUPT       . UPT ADDRESS\n         L     R15,CPPLECT       . ECT ADDRESS\n         DROP  R2\n         XC    #TSECB,#TSECB     . CLEAR ECB TO ZEROS\n         XC    #TSPTPB(PTPBLEN),#TSPTPB CLEAR PUT PARMLIST TO ZEROS\n         XC    #TSIOPL(IOPLLEN),#TSIOPL CLEAR PARM LIST TO ZEROS\n         LA    R1,#TSIOPL        . ADDRESS OF LIST\n        PUTLINE PARM=#TSPTPB,UPT=(R14),ECT=(R15),ECB=#TSECB,           X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               OUTPUT=((R0),TERM,SINGLE,DATA),                         X\n               MF=(E,(1))\n         LTR   R15,R15           . HOW COMPLETE?\n         BZ    &X.F              . NORMALLY (RETURN CODE = 0)\n         MVC   #TSMCTL(L'&Y.B),&Y.B\n         MVC   #TSMCTL+2(L'&Z.D),&Z.D\n         MVC   #TSMOUT(L'&Y.D),&Y.D\n         MVC   #TSMOUT+L'&Y.D(L'&Z.E),&Z.E\n         MVC   #TSMOUT+L'&Y.D-L'&Y.C(L'&Y.C),&Y.C\n         LA    R1,#TSMOUT+L'#TSMOUT-15\n         SRL   R1,3\n         SLL   R1,3\n         CVD   R15,0(R1)\n         ED    #TSMOUT+L'&Y.D-L'&Y.C(L'&Y.C),5(R1)\n         LA    R1,#TSMCTL\n         B     &X.E+L'&X.E\n&Z.C    WTO    ' => PUTLINE error - Invalid message length',           X\n               ROUTCDE=11,DESC=7,MF=L\n&Z.D     EQU   &Z.C+2,2\n&Z.E     EQU   *-4,4\n&X.E     LA    R1,&Z.C\n         BAS   R14,&MSG\n         LA    R15,4             . SET RETURN CODE = 4 (ERROR)\n&X.F     L     R2,#TSSREGS       . RESTORE CALLER'S REGISTER\n         L     R14,#TSSREGR      . RESTORE CALLER'S RETURN\n         BR    R14               . RETURN TO CALLER\n         AIF   ('&GET' EQ '').H\n         AGO   .G1\n.G       AIF   ('&GET' EQ '').H\n&TEWMRSW SETB  1\n&TEWPGSW SETB  1\n.G1      EJECT\n&TEWPGSG SETB  1\n         AIF   ('&DOC' NE 'YES').G2\n*------- TSO GETLINE - Routine\n*        (R2 and R14 saved/restored, R3-R13 not used by routine)\n*              R14 : link register\n*        Work-registers : R0, R1, R2, R14 and R15\n* On exit ---- R15 : return code, value may be\n*                    0 = GETLINE complete normally, #TSIBSP contain\n*                        Input Buffer Scan Pointers for BXLE ... as\n*                        follows (three full-words) :\n*                            +0 = 1\n*                            +4 = END address of text\n*                            +8 = START address of text\n*                    4 = none (no input text), all the three #TSIBSP\n*                        full-words are zero's\n*                    8 = GETLINE error (error message sent)\n         SPACE 1\n.G2      ANOP\n&GET     ST    R2,#TSSREGS       . SAVE CALLER'S REGISTER\n         ST    R14,#TSSREGR      . SAVE CALLER'S RETURN\n         L     R2,#TSCPPL        . ADDRESS OF CPPL\n         USING CPPL,R2\n         L     R14,CPPLUPT       . UPT ADDRESS\n         L     R15,CPPLECT       . ECT ADDRESS\n         DROP  R2\n         XC    #TSECB,#TSECB     . CLEAR ECB TO ZEROS\n         XC    #TSGTPB(GTPBLEN),#TSGTPB CLEAR GET PARMLIST TO ZEROS\n         XC    #TSIOPL(IOPLLEN),#TSIOPL CLEAR PARM LIST TO ZEROS\n         XC    #TSIBSP(3*L'#TSIBSP),#TSIBSP ZERO'S INPUT SCAN POINTERS\n         LA    R1,#TSIOPL        . ADDRESS OF LIST\n        GETLINE PARM=#TSGTPB,UPT=(R14),ECT=(R15),ECB=#TSECB,           X\n               TERMGET=(EDIT,WAIT),                                    X\n               INPUT=(TERM,LOGICAL),                                   X\n               MF=(E,(1))\n         CH    R15,&Y.A          . HOW COMPLETE ?\n         BNH   &X.G              . SUCCESSFULLY ...\n         MVC   #TSMCTL(L'&Y.B),&Y.B\n         MVC   #TSMCTL+2(L'&Z.D),&Z.D\n         MVC   #TSMOUT(L'&Y.D),&Y.D\n         MVC   #TSMOUT+4(L'&Y.F),&Y.F\n         MVC   #TSMOUT+L'&Y.D(L'&Z.E),&Z.E\n         MVC   #TSMOUT+L'&Y.D-L'&Y.C(L'&Y.C),&Y.C\n         LA    R1,#TSMOUT+L'#TSMOUT-15\n         SRL   R1,3\n         SLL   R1,3\n         CVD   R15,0(R1)\n         ED    #TSMOUT+L'&Y.D-L'&Y.C(L'&Y.C),5(R1)\n         LA    R1,#TSMCTL\n         BAS   R14,&MSG\n         LA    R15,8             . SET RETURN CODE = 8 (ERROR)\n         B     &X.H\n&X.G     XR    R15,R15           . SET RETURN CODE = 0\n         LA    R2,#TSGTPB        . ADDRESSABILITY FOR THE GTPB\n         USING GTPB,R2\n         L     R14,GTPBIBUF      . GET ADDRESS OF INPUT BUFFER\n         DROP  R2\n         LH    R0,0(R14)         . BUFFER LENGTH\n         SH    R0,&Y.A           . PREFIX LENGTH\n         LH    R2,2(R14)         . OFFSET TO FIRST OPERAND\n         SR    R0,R2             . OPERANDS LENGTH\n         BP    *+L'*+8\n         LA    R15,4             . SET RETURN CODE = 4 (NONE)\n         B     &X.H\n         LA    R1,4(R14,R2)      . START ADDRESS OF OPERANDS\n         ALR   R0,R1\n         BCTR  R0,0              . END ADDRESS OF OPERANDS\n         MVI   #TSIBSP+L'#TSIBSP-1,1 SET INPUT SCAN STEP\n         STM   R0,R1,#TSIBSP+L'#TSIBSP SET SCAN END-START POINTERS\n&X.H     L     R2,#TSSREGS       . RESTORE CALLER'S REGISTER\n         L     R14,#TSSREGR      . RESTORE CALLER'S RETURN\n         BR    R14               . RETURN TO CALLER\n         AIF   ('&DOC' NE 'YES').G3\n         EJECT\n*------- TSO GETLINE Release Input Buffer after process - Routine\n*        (R14 saved/restored, R2-R13 not used by routine)\n*              R14 : link register\n*        Work-registers : R0, R1, R14 and R15\n* On exit ---- R15 : FREEMAIN return code\n.G3      SPACE 1\n&REL     ST    R14,#TSSREGR      . SAVE CALLER'S RETURN\n         LA    R15,#TSGTPB       . ADDRESSABILITY FOR THE GTPB\n         USING GTPB,R15\n         L     R1,GTPBIBUF       . GET ADDRESS OF INPUT BUFFER\n         DROP  R15\n         LH    R0,0(R1)          . INPUT BUFFER LENGTH\n         AH    R0,&Y.E           . ROUND UP TO 8\n         SRL   R0,3\n         SLL   R0,3\n        FREEMAIN RC,LV=(0),A=(1),SP=1\n         L     R14,#TSSREGR      . RESTORE CALLER'S RETURN\n         BR    R14               . RETURN TO CALLER\n.H       EJECT\n         AIF   ('&MSG' NE '').H1\n         AIF   ('&GET' NE '').H1\n         AIF   ('&SCAN' NE 'YES').H2\n.H1      ANOP\n&Y.A     DC    H'4'\n.H2      AIF   ('&PUT' EQ '').H3\n&Y.B     DC    AL2(L'&Y.D+4)\n&Y.C     DC    XL6'402020202120'\n&Y.D     DC    C' => PUTLINE error - Return Code = .....'\n.H3      AIF   ('&GET' EQ '').H4\n&Y.E     DC    H'7'\n&Y.F     DC    CL2'GE'\n.H4      SPACE 1\n&X.I     ST    &R,#TSCPPL        . RETAIN CPPL ADDRESS\n         AIF   ('&SCAN' NE 'YES').END\n&TEWSCSW SETB  1\n         XC    #TSIBSP(3*L'#TSIBSP),#TSIBSP ZERO'S INPUT SCAN POINTERS\n         USING CPPL,&R           . SET CPPL ADDRESSABILITY\n         L     R1,CPPLCBUF       . COMMAND BUFFER ADDRESS\n         DROP  &R\n         LH    R15,0(R1)         . BUFFER LENGTH\n         SH    R15,&Y.A          . PREFIX LENGTH\n         LH    R14,2(R1)         . OFFSET TO FIRST OPERAND\n         SR    R15,R14           . OPERANDS LENGTH\n         BNP   *+L'*+16\n         LA    R0,4(R1,R14)      . START ADDRESS OF OPERANDS\n         ALR   R15,R0\n         BCTR  R15,0             . END ADDRESS OF OPERANDS\n         MVI   #TSIBSP+L'#TSIBSP-1,1 SET INPUT SCAN STEP\n         STM   R15,R0,#TSIBSP+L'#TSIBSP SET SCAN END-START POINTERS\n         AIF   ('&DOC' NE 'YES').END\n         SPACE 1\n*------- At this point, #TSIBSP contains Input Buffer Scan Pointers\n*        for BXLE ... as below :\n*              +0 = 1\n*              +4 = END address of text\n*              +8 = START address of text\n*        or, if none, #TSIBSP are all zero's\n         SPACE 1\n         MEXIT\n.ERR1    MNOTE 8,' NOTTSO=(...,...) OPERAND(2) INVALID ************** '\n         MEXIT\n.ERR2    MNOTE 8,' MSG=... OPERAND MISSING ************************** '\n         AIF   ('&ERR' EQ '').ERR3\n         MEXIT\n.ERR3    MNOTE 8,' ERR=... OPERAND MISSING ************************** '\n         MEXIT\n.ERR4    MNOTE 8,' MSG=... OPERAND MISSING (PUT=... NEED IT) ******** '\n         MEXIT\n.ERR5    MNOTE 8,' REL=... OPERAND MISSING ************************** '\n         MEXIT\n.ERR6    MNOTE 8,' REL=... OPERAND ? (GET=... MISSING ?) ************ '\n         MEXIT\n.ERR7    MNOTE 8,' MSG=... OPERAND MISSING (GET=... NEED IT) ******** '\n.END     MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$TEW$PP": {"ttr": 6152, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x13\\x1f\\x00\\x94\\x13\\x1f\\x15P\\x00j\\x00j\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-11T00:00:00", "modifydate": "1994-05-11T15:50:00", "lines": 106, "newlines": 106, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO      TSO EASY-WAY OF CODING - PARSE PROCESS\n&NAME   $TEW$PP     &PARM=,&REG=R2,&MSG=,&ERR=,&ATT=,&UWA=\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE (TP 361)\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n         GBLB  &TEWPPSW,&TEWPPUW\n         GBLC  &TEWMRNM,&TEWMRNE\n         LCLC  &U,&V,&W,&X,&Y,&Z\n         AIF   ('&PARM' EQ '').ERR1\n&U       SETC  '&MSG'\n&V       SETC  '&ERR'\n         AIF   ('&U' NE '').A\n&U       SETC  '&TEWMRNM'\n.A       AIF   ('&V' NE '').A1\n&V       SETC  '&TEWMRNE'\n.A1      AIF   ('&U' EQ '').ERR2\n         AIF   ('&V' EQ '').ERR3\n&W       SETC  '&ATT'\n         AIF   ('&W' NE '').A2\n&W       SETC  '&V'\n.A2      SPACE 1\n*------- Set up PARSE Parameter Block\n         SPACE 1\n&TEWPPSW SETB  1\n&X       SETC  'GIB'.'&SYSNDX'\n&Y       SETC  'GIM'.'&SYSNDX'\n&Z       SETC  'GIW'.'&SYSNDX'\n&NAME    L     R1,#TSCPPL\n         USING CPPL,R1           . SET CPPL ADDRESSABILITY\n         LA    R14,#TSPPL\n         USING PPL,R14           . SET PPL ADDRESSABILITY\n         XC    PPLUPT(#TSPPLL),PPLUPT\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         LA    R0,#TSECBS\n         ST    R0,PPLECB\n         MVC   PPLPCL,&Y.A\n         LA    R0,#TSANSW\n         ST    R0,PPLANS\n         MVC   PPLCBUF,CPPLCBUF\n         AIF   ('&UWA' EQ '').B2\n&TEWPPUW SETB  1\n         AIF   ('&UWA'(1,1) EQ '(').B1\n         LA    R0,&UWA\n         ST    R0,PPLUWA\n         AGO   .B2\n.B1      ST    &UWA(1),PPLUWA\n.B2      DROP  R1,R14\n         SPACE 1\n*------- PARSE - Check syntax of command operands\n         SPACE 1\n        CALLTSSR EP=IKJPARS,MF=(E,#TSPPL)\n         B     *+L'*(R15)        . BRANCH ON RETURN CODE\n         B     &X.B              .  0 - SUCCESSFULL\n         B     &Y.1              .  4 - UNABLE TO PROMPT\n         B     &W                .  8 - USER ATTENTION OCCURRED\n         B     &Y.2              . 12 - PROGRAM BUG\n         B     &Y.3              . 16 - SPACE UNAVAILABLE IN REGION\n         B     &Y.4              . 20 - INVALID PARAMETERS\n         B     &Y.5              . 24 - PARAMETERS CONFLICT\n         B     &Y.6              . 28 - TERMINAL DISCONNECTED\n         SPACE 1\n&Y.1     LA    R1,&Z.1\n         B     &X.A\n&Y.2     LA    R1,&Z.2\n         B     &X.A\n&Y.3     LA    R1,&Z.3\n         B     &X.A\n&Y.4     LA    R1,&Z.3\n         B     &X.A\n&Y.5     LA    R1,&Z.5\n         B     &X.A\n&Y.6     LA    R1,&Z.6\n         B     &X.A\n&Y.7     LA    R1,&Z.7\n&X.A     BAS   R14,&U\n         B     &V\n&Y.A     DC    A(&PARM)\n&Z.1    WTO    ' => incomplete parameters and unable to prompt',       X\n               ROUTCDE=11,DESC=7,MF=L\n&Z.2    WTO    ' => PARSE Parameter Block invalid',                    X\n               ROUTCDE=11,DESC=7,MF=L\n&Z.3    WTO    ' => not enough space in region',                       X\n               ROUTCDE=11,DESC=7,MF=L\n&Z.4    WTO    ' => invalid parameters',                               X\n               ROUTCDE=11,DESC=7,MF=L\n&Z.5    WTO    ' => parameters conflict',                              X\n               ROUTCDE=11,DESC=7,MF=L\n&Z.6    WTO    ' => terminal has been disconnected',                   X\n               ROUTCDE=11,DESC=7,MF=L\n&Z.7    WTO    ' => PARSE Answer Address error',                       X\n               ROUTCDE=11,DESC=7,MF=L\n         SPACE 1\n&X.B     L     &REG,#TSANSW      . CHECK ANSWER ADDRESS\n         LA    &REG,0(&REG)\n         LTR   &REG,&REG\n         BZ    &Y.7              . PARSE ERROR\n         USING IKJPARMD,&REG     . SET PARSE PARM LIST ADDRESSABILITY\n         MEXIT\n.ERR1    MNOTE 8,' PARM=... OPERAND MISSING ************************* '\n         MEXIT\n.ERR2    MNOTE 8,' MSG=... OPERAND MISSING ************************** '\n         MEXIT\n.ERR3    MNOTE 8,' ERR=... OPERAND MISSING ************************** '\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$TEW$WA": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x13\\x1f\\x00\\x94\\x13\\x1f\\x15P\\x008\\x008\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-11T00:00:00", "modifydate": "1994-05-11T15:50:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO      TSO EASY-WAY OF CODING - WORK-AREAS\n&NAME   $TEW$WA     &DUMMY\n.* AUTHOR :    MOINIL P.A.\n.* --------    COMPUTING CENTRE (TP 361)\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n         GBLB  &TEWECSC,&TEWECST\n         GBLB  &TEWMRSW\n         GBLB  &TEWPGSW,&TEWPGSG,&TEWPGSP\n         GBLB  &TEWSCSW\n         GBLB  &TEWPPSW\n*- - - - - - - - - - - - - - - - - - - - - - --> Work-Areas Start <--*\n         AIF   ('&NAME' EQ '').A\n&NAME    EQU   *\n.A       ANOP\n#TSCPPL  DC    A(*-*)            . CPPL address\n*                                . TSO flag from EXTRACT\n#TSFLAG  DC    XL1'0'            .      X'00' = not TSO\n#TSFRUN  EQU   X'80'             .      X'80' = TSO\n#TSXLS  EXTRACT *-*,'S',MF=L     .      EXTRACT List\n#TSXLSA  DS    0F                .      EXTRACT responses\n         AIF   (NOT &TEWECST).A1\n#TSTIOT  DC    A(*-*)            .      TIOT address\n.A1      AIF   (NOT &TEWECSC).A2\n#TSCOMM  DC    A(*-*)            .      COMMunication address\n.A2      ANOP\n#TSTSOF  DC    A(*-*)            .      TSO-flag address\n#TSPSCB  DC    A(*-*)            .      PSCB address\n#TSXLSL  EQU   *-#TSXLS          . Length\n         AIF   (NOT &TEWMRSW).B\n#TSSREGM DC    F'0'              . Save R14 for MSG\n.B       AIF   (NOT &TEWPGSW).C\n#TSSREGR DC    F'0'              . Save R14 for PUTLINE/GETLINE\n#TSSREGS DC    F'0'              . Save R2 for PUTLINE/GETLINE\n#TSECB   DC    F'0'              . ECB for PUTLINE/GETLINE\n#TSIOPL  DC    0F'0',(IOPLLEN)X'0' I-O Parm List for PUTLINE/GETLINE\n         AIF   (NOT &TEWPGSG).B1\n&TEWSCSW SETB  0\n#TSIBSP  DC    3F'0'             . GETLINE Input Buffer Scan Pointers\n#TSGTPB  DC    0F'0',(GTPBLEN)X'0' GETLINE Parm Block\n.B1      AIF   (NOT &TEWPGSP).B2\n#TSPTPB  DC    0F'0',(PTPBLEN)X'0' PUTLINE Parm Block\n.B2      ANOP\n#TSMWRK  EQU   #TSMCTL,84        . PUTLINE/GETLINE work use\n#TSMCTL  DC    F'0'              .      Control word\n#TSMOUT  DC    CL80' '           .      Text\n.C       AIF   (NOT &TEWSCSW).D\n#TSIBSP  DC    3F'0'             . COMMAND Input Buffer Scan Pointers\n.D       AIF   (NOT &TEWPPSW).E\n#TSPPL   DC    0F'0',(PPLLEN)X'0'  PARSE Parm Block\n#TSECBS  DC    F'0'\n#TSANSW  DC    A(0)              . PDL address\n#TSPPLL  EQU   *-#TSPPL          . Length\n.E       ANOP\n*- - - - - - - - - - - - - - - - - - - - - - - --> Work-Areas End <--*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$TEW@": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x04_\\x00\\x95\\x04_\\x16\\x04\\x00\\xf7\\x00\\xf7\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-02-14T00:00:00", "modifydate": "1995-02-14T16:04:00", "lines": 247, "newlines": 247, "modlines": 0, "user": "SYSPAJA"}, "text": "1   20/04/94\n                                                      $TEW$     1/5.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       TSO EASY-WAY OF CODING        * * * * * * * *\n  * * * * * * * *          (macros facility)          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose : Some macros to help programmers when coding TSO commands\n  ========= (Assembler H).\n\n  Macros description :\n  ====================\n    1. $TEW$EC - TSO Easy-Way of Coding - Entry Checks.\n         Generate Assembler code to :\n              a) verify at entry if module has been invoked as TSO\n                 command or subcommand. The addresses of CPPL, TSO\n                 flag and PSCB are retrieved and thus available to\n                 the following processing (optionally you may ask also\n                 the TIOT and/or COMM addresses).\n              b) eventually generate the following routines :\n                 - a TSO message routine\n                 - a TSO PUTLINE routine\n                 - a TSO GETLINE and GETLINE RELEASE routines\n         Syntax :  $TEW$EC  REG=...,TIOT=...,COMM=...,\n                            NOTTSO=...,NOTCMD=...,MSG=...,ERR=...,\n                            PUT=...,GET=...,REL=...,SCAN=...,DOC=...\n              At the end of $TEW$EC macro development, the CPPL address\n              is in the register indicated by REG=..., unless you code\n              one of the registers 0, 1, 13, 14 or 15, or none, then\n              the CPPL address is placed in the register 2.\n         Operands :\n              REG=... indicate the register of the entry PARM address\n                      (default is R1).\n              TIOT=... say YES to retrieve also the address of the\n                      TIOT (default is NO).\n              COMM=... say YES to retrieve also the address of the\n                      Communication Area (default is NO).\n              NOTTSO=... is the label where you want branch if the\n                      module is not running in a TSO environment (no\n                      default, this is an \"error detection\" case).\n                      Specify NOTTSO=(...,ONLY) or NOTTSO=(,ONLY) if\n                      you want test to be in TSO foreground run only.\n              NOTCMD=... is the label where you want branch if the\n                      module is not a TSO command or subcommand (no\n                      default, this is an \"error detection\" case).\n              MSG=... is the label for a TSO message (use TPUT or\n                      WTO to send the message) routine to be\n                      generated (routine is mandatory in case of\n                      \"error detection\" when NOTTSO=... and/or\n                      NOTCMD=... are not specified or when PUT=...\n                      and/or GET=... are specified).\n1   20/04/94\n                                                      $TEW$     2/5.\n\n              ERR=... is the label where you want branch, after\n                      message sent, in case of an \"error detection\"\n                      (mandatory when NOTTSO=... and/or NOTCMD=...\n                      are not specified).\n              PUT=... is the label of a TSO PUTLINE routine you want\n                      to be generated.\n              GET=... is the label of a TSO GETLINE routine you want\n                      to be generated.\n              REL=... is the label of a TSO GETLINE RELEASE Input\n                      Buffer after process routine to be generated\n                      (mandatory when you specify GET=...).\n              SCAN=... say YES if you intend to analyze the command\n                      operands yourself, in other words, you will not\n                      use IKJPARS or $TEW$PP macros (default is NO).\n              DOC=... say YES to have a short information included\n                      in your Assembly list (default is NO).\n         Notes about macro coding :\n              1. You may set NOTTSO=... and/or NOTCMD=... to process\n                 \"errors detection\" yourself. If any one of these two\n                 operands is not specified, you must supply MSG=... and\n                 ERR=... to allows the \"errors detection\" be signaled\n                 and then go to correctly terminate execution.\n              2. If NOTTSO=... and NOTCMD=... are specified and if\n                 MSG=..., PUT=... and GET=... are not specified, it\n                 means you want only retrieve the System addresses.\n              3. When SCAN=YES is specified, then just after the\n                 $TEW$EC macro development, you can get at label\n                 #TSIBSP the command operands buffer scan pointers for\n                 a BXLE ... instruction use as below :\n                     +0 = 1\n                     +4 = END address of text\n                     +8 = START address of text\n                 or if none, at label #TSIBSP all pointers are zero's.\n              4. The $TEW$EC macro is normally coded at the beginning\n                 of the source program, just after the $XENT macro.\n                 Mandatory : the $TEW$EC macro must be the first one\n                 of coded $TEW$.. macros in the source program, unless\n                 you may have Assembly errors.\n\n    2. $TEW$PP - TSO Easy-Way of coding - PARSE Process.\n         Generate Assembler code to execute the IKJPARS which sets the\n              command operands parameters list ready for use.\n         Syntax :  $TEW$PP  PARM=...,REG=...,ATT=...,MSG=...,ERR=...\n         Operands :\n              PARM=... is the label of the Parameter Control List\n                      (PCL), macros IKJPARM, ..., IKJENDP.\n              REG=... indicate the register you want use as pointer to\n                      the Parameter Descriptor List (PDL), DSECT name\n                      is IKJPARMD (default is R2).\n              MSG=... is the label of the TSO message routine you want\n                      use in case of \"error detection\", but, if it is\n                      the same as that defined with MSG=... in the\n                      $TEW$EC macro, you may omit it here.\n1   20/04/94\n                                                      $TEW$     3/5.\n\n              ERR=... is the label where you want branch in case of an\n                      \"error detection\" (after message sent), but as\n                      for MSG=..., if it is the same as that defined\n                      with ERR=... in the $TEW$EC macro, you may omit\n                      it also.\n              ATT=... is the label where you want branch if PARSE did\n                      not complete because an interruption occurred\n                      during the processing (you may omit it when it\n                      will be the same as that defined for ERR=...).\n              UWA=... is the label of the User Work Area (address is\n                      stored in PPLUWA) you eventually needs be provided\n                      to validity checking routines (VALIDCK= operand\n                      in IKJPOSIT, IKJTERM, IKJOPER or IKJIDENT macros).\n                      Note : if the address is in a register, you may\n                      use the register notation, as i.e., UWA=(R9).\n\n    3. $TEW$WA - TSO Easy-Way of coding - Work-Areas.\n         Generate Assembler code defining the work-areas needed by the\n              above $TEW$EC and $TEW$PP macros.\n         Syntax :  $TEW$WA\n         Operands : none.\n         Note about macro coding :\n              The $TEW$WA macro must be coded as constants definitions\n              (NORENT Assembly) or somewhere in the dynamic array\n              work-areas definitions (RENT Assembly).\n\n\n    4. $TEW$DS - TSO Easy-Way of coding - DSECT's.\n         Generate Assembler code defining the DSECTs needed by or\n              requested through the other macros named $TEW$...\n         Syntax :  $TEW$DS  CVT=...,TIOT=...,VCPL=...\n         Operands :\n              CVT=... say YES to force the insertion of the statement\n                               CVT    DSECT=YES,LIST=YES\n                      in your Assembly program if you want to have it\n                      (default is NO). You may omit CVT=YES if you use\n                      the $TEW$PP macro in your source program (it is\n                      included automatically).\n              TIOT=... say YES to force the insertion of the statements\n                       TIODSECT DSECT\n                               IEFTIOT1\n                      in your Assembly program if you want to have it\n                      (default is NO). You may omit TIOT=YES if you use\n                      the $TEW$EC macro with TIOT=YES in your source\n                      program (it is included automatically).\n              VCPL=... say YES to force the insertion of the VCPL dsect\n                      (Validity Check Parameter List) in your Assembly\n                      program if you want to have it (default is NO).\n                      You may omit VCPL=YES if you use the $TEW$PP\n                      macro with UWA=... coded in your source program\n                      (it is included automatically).\n         Note about macro coding :\n              The $TEW$DS macro must be coded at the end of your source\n              program, just before the END statement.\n1   20/04/94\n                                                      $TEW$     4/5.\n\n  How to use (CALL) :\n  ===================\n\n    1. The TSO message routine :\n                ... LA    R1,...(address of message \"WTO\" list form)\n                    BAS   R14,...(label specified in MSG=...)\n       Message example :\n                ... WTO   '...message text...',ROUTCDE=11,DESC=7,MF=L\n       Work-registers : R0, R1, R14 and R15\n\n    2. The PUTLINE routine (registers R2 and R14 saved/restored,\n       registers R3-R13 not used by routine) :\n                ... LA    R0,...(line text length)\n                    LA    R1,...(address of line text)\n                    BAS   R14,...(label specified in PUT=...)\n       Line text example :\n                ... DC    C'...line text...'\n       Work-registers : R0, R1, R2, R14 and R15\n       At exit, R15 = return code, value may be :\n            0 = PUTLINE complete normally\n            4 = PUTLINE error (error message sent)\n\n    3. The GETLINE routine (registers R2 and R14 saved/restored,\n       registers R3-R13 not used by routine) :\n                ... BAS   R14,...(label specified in GET=...)\n       Work-registers : R0, R1, R2, R14 and R15\n       At exit, R15 = return code, value may be :\n            0 = GETLINE complete normally, at label #TSIBSP, there is\n                the Input Buffer Scan Pointers which may be used by a\n                BXLE ... instruction as follows (three full-words) :\n                    +0 = 1\n                    +4 = END address of text\n                    +8 = START address of text\n            4 = none (no input text), all the three #TSIBSP full-words\n                are zero's\n            8 = GETLINE error (error message sent)\n\n    4. The GETLINE RELEASE routine :\n                ... BAS   R14,...(label specified in REL=...)\n       Work-registers : R0, R1, R14 and R15\n       At exit, R15 = FREEMAIN return code\n1   20/04/94\n                                                      $TEW$     5/5.\n\n  Information at your disposal in the work-areas :\n  ================================================\n    Label     Type  Contents\n    --------  ----  ---------------------------------------------------\n    #TSCPPL   F     CPPL address\n    #TSFLAG   X     TSO flag - X'00' = NOT TSO\n    #TSFRUN   EQU              X'80' = TSO\n    #TSTIOT   F     TIOT address (if TIOT=YES coded in $TEW$EC macro or\n                    in $TEW$DS macro)\n    #TSCOMM   F     COMMUNICATION address (if COMM=YES coded in\n                    $TEW$EC macro)\n    #TSPSCB   F     PSCB address\n    #TSIBSP   3F    Command Operands Scan Pointers (if SCAN=YES coded\n                    in $TEW$EC macro) and/or GETLINE Input Buffer Scan\n                    Pointers (if GET=... coded in $TEW$EC macro)\n    #TSANSW   F     Parameter Descriptor List (PDL) address (if $TEW$PP\n                    macro coded)\n\n  DSECTs at your disposal :\n  =========================\n    Label     Description\n    --------  ---------------------------------------------------------\n    CPPL      Command Processor Parameter List\n    PSCB      Protected Step Control Block\n    TIODSECT  Task Input/Output Table (if TIOT=YES coded in $TEW$EC\n              macro or in $TEW$DS macro)\n    CIBDSECT  Command Input Buffer (if COMM=YES coded in $TEW$EC\n              macro)\n    CVT       Communication Vector Table (if $TEW$PP macro coded or\n              CVT=YES coded in $TEW$DS macro)\n    PPL       PARSE Parameters List (if $TEW$PP macro coded)\n    VCPL      Validity Check Parameter List (if UWA=... coded in\n              $TEW$PP macro or VCPL=YES coded in $TEW$DS macro)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$TREQ": {"ttr": 6406, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x884?\\x00\\x884?\\x11#\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-08T00:00:00", "modifydate": "1988-12-08T11:23:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           EURATOM AUTHORIZED SVC.\n&NAME   $TREQ  &R=\n.*\n.* $TREQ MACRO : EURATOM TIMES REQUESTS.\n.* -------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n&NAME    XR    0,0\n         AIF   ('&R' NE 'CL').A\n         LA    1,1\n         AGO   .E\n.A       AIF   ('&R' NE 'CU').B\n         LA    1,2\n         AGO   .E\n.B       AIF   ('&R' NE 'SL').C\n         LA    1,3\n         AGO   .E\n.C       AIF   ('&R' NE 'SU').D\n         LA    1,4\n         AGO   .E\n.D       LR    1,0\n.E       BCTR  0,0\n         SVC   ###                 SEND REQUEST.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$TSWXA": {"ttr": 6408, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x13\\x1f\\x00\\x87\\x13\\x1f\\x15\\x07\\x00h\\x00h\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-05-11T00:00:00", "modifydate": "1987-05-11T15:07:00", "lines": 104, "newlines": 104, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           TEST AND SWITCH ADDRESSING MODE.\n&NAME   $TSWXA      &MODE,&EXPAND=ALL,&ASS=H,&CVT=YES\n         LCLC  &X\n.*\n.* $TSWXA MACRO : MACRO TO TEST THE CURRENT ADDRESSING MODE OR TO\n.* -------------- SWITCH BETWEEN 24-BIT AND 31-BIT ADDRESSING MODE.\n.*                IT ALLOWS PROGRAMS TO RUN ON MVS/370 AND MVS/XA.\n.*\n.* MODE OPERAND : THE DESIRED ADDRESSING MODE TO ENTER (24 OR 31).\n.*                IF SYSTEM IS SPECIFIED, ONLY THE TEST OF THE\n.*                CURRENT MVS VERSION IS EXECUTED. THE CONDITION\n.*                CODE IS SET AS FOLLOWS :\n.*                     - 0 (ZERO) = MVS/370 VERSION,\n.*                     - 3 (ONE) = MVS/XA VERSION.\n.*                IF OMITED, THAN THE TEST OF CURRENT MVS VERSION\n.*                AND ADDRESSING MODE IS EXECUTED. THE CONDITION\n.*                CODE IS SET AS FOLLOWS :\n.*                     - 0 (ZERO) = MVS/370 MODE,\n.*                     - 1 (MINUS) = MVS/XA 31-BIT ADDRESSING MODE,\n.*                     - 2 (PLUS) = MVS/XA 24-BIT ADDRESSING MODE,\n.*                AND THE REGISTER 14 CONTAINS THE CURRENT MVS VERSION\n.*                AND AMODE INDICATORS AS BELOW :\n.*                     - BIT 0 : OFF = 24-BIT AMODE,\n.*                               ON = 31-BIT AMODE,\n.*                     - BIT 1 : OFF = MVS/370,\n.*                               ON = MVS/XA,\n.*                     - THE REMAINING BITS (2-31) ARE BINARY ZEROES.\n.*\n.* EXPAND OPERAND : ONLY USED WITH MODE OPERAND 24 OR 31 TO REQUEST\n.*                THE FULL EXPANSION (EXPAND=ALL, DEFAULT) OR ONLY\n.*                THE ENTER SPECIFIC MODE INSTRUCTIONS (EXPAND=ONLY).\n.*\n.* ASS OPERAND :  NORMALLY THIS MACRO NEEDS ASSEMBLER H (IEV90) FOR\n.*                BSM INSTRUCTION, BUT THE ASSEMBLER F MAY BE USED\n.*                SPECIFYING ASS=F.\n.*\n.* CVT OPERAND :  NORMALLY THIS MACRO REFERS TO FIELDS MAPPED BY THE\n.*                CVT MACRO (CVT=YES), BUT IT MAY BE SUPPRESSED WHEN\n.*                SPECIFYING CVT=NO (ABSOLUTE LOCATIONS ARE USED).\n.*\n.* NOTES - REGISTER 14 IS ALWAYS ALTERED.\n.*       - IF THE OPERATING SYSTEM DON'T SUPPORT 31-BIT ADDRESSING,\n.*         OR THE CURRENT ADDRESSING MODE IS ALREADY THAT REQUESTED,\n.*         NO MODE SWITCH OCCURS.\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&ASS' NE 'H' AND '&ASS' NE 'F').INVA\n         AIF   ('&CVT' NE 'YES' AND '&CVT' NE 'NO').INVC\n         AIF   (T'&MODE EQ 'O').OMIT\n         AIF   ('&MODE' EQ 'SYSTEM').OMIT\n         AIF   ('&MODE' NE '24' AND '&MODE' NE '31').INVM\n         AIF   ('&EXPAND' EQ 'ALL').OMIT\n         AIF   ('&EXPAND' NE 'ONLY').INVE\n&NAME    LA    14,&X+L'&X          REG. 14 = AMODE AFTER BSM\n         AIF   ('&MODE' EQ '31').ENXA\n         AGO   .STMD\n.OMIT    AIF   ('&CVT' EQ 'YES').OKCVT\n&NAME    L     14,16               REG. 14 ---> CVT\n         TM    116(14),X'80'       XA (CVTDCB, BIT 0) ON?\n         AGO   .TSMD\n.OKCVT   ANOP\n&NAME    L     14,CVTPTR           REG. 14 ---> CVT\n         USING CVTMAP,14\n         TM    CVTDCB,CVTMVSE      XA (BIT 0) ON?\n         DROP  14\n.TSMD    AIF   ('&MODE' EQ 'SYSTEM').TSYS\n         LA    14,0                CLEAR REG. 14\n         BZ    &X+L'&X             NO, LET'S GO (MVS/370)\n         AIF   (T'&MODE NE 'O').NORM\n         ICM   14,B'1000',=X'40'   INDICATE MVS/XA RUNNING\n.NORM    AIF   ('&ASS' EQ 'F').ASSF\n         BSM   14,0                GET CURRENT AMODE\n         AGO   .TSTM\n.ASSF    DC    XL2'0BE0'           BSM 14,0 TO GET CURRENT AMODE\n.TSTM    AIF   (T'&MODE EQ 'O').TEND\n         LTR   14,14               CURRENT MODE IS?\n         LA    14,&X+L'&X          REG. 14 = AMODE AFTER BSM\n         AIF   ('&MODE' EQ '31').STXA\n         BZ    &X+L'&X             24-BIT, ALREADY IN\n         AGO   .STMD\n.STXA    BM    &X+L'&X             31-BIT, ALREADY IN\n.ENXA    O     14,=A(X'80000000')  SET ADDRESSING TO 31-BIT MODE\n.STMD    AIF   ('&ASS' EQ 'F').ASMF\n&X       BSM   0,14                ENTER NEW AMODE\n         MEXIT\n.ASMF    ANOP\n&X       DC    XL2'0B0E'           BSM 0,14 TO ENTER NEW AMODE\n         MEXIT\n.TEND    ANOP\n&X       LTR   14,14               SET CC TO CURRENT MODE\n         MEXIT\n.INVA    MNOTE 8,' INVALID ASS OPERAND ****************************** '\n         MEXIT\n.INVC    MNOTE 8,' INVALID CVT OPERAND ****************************** '\n         MEXIT\n.INVM    MNOTE 8,' INVALID MODE OPERAND ***************************** '\n         MEXIT\n.INVE    MNOTE 8,' INVALID EXPAND OPERAND *************************** '\n.TSYS    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$TSWXA@": {"ttr": 6411, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x7f\\x00\\x88\\t\\x7f\\x10\\t\\x004\\x004\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-06T00:00:00", "modifydate": "1988-04-06T10:09:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "SYSPAJA"}, "text": "1   06/08/86\n                                                      $TSWXA    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *  TEST/SWITCH ADDRESSING MODE MACRO  * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Assembler macro : $TSWXA MODE,EXPAND=ALL,ASS=H,CVT=YES\n  -----------------                    ONLY    F     NO\n\n   Purpose : macro to test the current addressing mode or to switch\n             between 24-bit and 31-bit addressing mode.\n             It allows programs to run on MVS/370 and MVS/XA.\n\n   MODE operand : the desired addressing mode to enter (24 or 31).\n                  If SYSTEM is specified, only the test of the\n                  current MVS version is executed. The condition\n                  code is set as follows :\n                       - 0 (ZERO) = MVS/370 version,\n                       - 3 (ONE) = MVS/XA version.\n                  If omited, than the test of current MVS version\n                  and addressing mode is executed. The condition\n                  code is set as follows :\n                       - 0 (ZERO) = MVS/370 mode,\n                       - 1 (MINUS) = MVS/XA 31-bit addressing mode,\n                       - 2 (PLUS) = MVS/XA 24-bit addressing mode,\n                  and the register 14 contains the current MVS version\n                  and AMODE indicators as below :\n                       - bit 0 : off = 24-bit AMODE,\n                                 on = 31-bit AMODE,\n                       - bit 1 : off = MVS/370,\n                                 on = MVS/XA,\n                       - the remaining bits (2-31) are binary zeroes.\n\n   EXPAND operand : only used with MODE operand 24 or 31 to request\n                  the full expansion (EXPAND=ALL, default) or only\n                  the enter specific mode instructions (EXPAND=ONLY).\n\n   ASS operand :  normally this macro needs assembler H (IEV90) for\n                  BSM instruction (ASS=H), but the assembler F may\n                  be used specifying ASS=F.\n\n   CVT operand :  normally this macro refers to fields mapped by the\n                  CVT macro (CVT=YES), but it may be suppressed when\n                  specifying CVT=NO (absolute locations are used).\n\n   NOTES - Register 14 is always altered.\n         - If the Operating System does not support 31-bit addressing,\n           or the current addressing mode is already that requested,\n           no mode switch occurs.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$UCLOSE": {"ttr": 6413, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL UCLOSE SUPPLY.\n&NAME   $UCLOSE     &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $UCLOSE MACRO : CALL UCLOSE SUPPLY (SEE UCLOSE/PUNCH).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(UCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(UCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(UCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$UJVT": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x10/\\x00\\x90\\x10/\\x08E\\x00T\\x00T\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-04-12T00:00:00", "modifydate": "1990-04-12T08:45:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           SMF - IEFUJV TABLES VECTOR.\n        $UJVT\n         SPACE 1\n*  ---------------------------------------------------------------\n*    S M F   J O B   V A L I D A T I O N   E X I T   T A B L E S\n*  ---------------------------------------------------------------\n         SPACE 1\n         AIF   ('&SYSECT' NE 'UJVTABLE').N0\n         SPACE 1\n* HOW TO USE : IEFUJV REFERENCES THESE TABLES THROUGH THE FOLLOWING\n* ------------ VECTOR (USING $UJVT MACRO).\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n         DC    A(SYSAUT)           AUTHORIZATIONS TABLE.\n         DC    A(SYSBOX)           BOXES TABLE.\n         DC    A(SYSIOS)           TIME AND/OR I/O CONTROL TABLE.\n         DC    A(SYSPST)           SPECIAL TASKS/CLASS TABLE.\n         DC    A(SYSEXC)           CLASS/EXEMPTIONS/PG TABLE.\n         DC    A(SCHPRT)           SCHEDULING PRIORITY TABLE.\n         DC    A(SCHPRN)           NO. OF EL. IN SCHED. PRIORITY TABLE.\n         DC    A(IOCT)             LAST EL. OF I/O INDEX TABLE.\n         DC    A(IOCN)             NO. OF EL. IN I/O INDEX TABLE.\n         DC    A(MEMCT)            REGION TABLE.\n         DC    A(MEMCN)            NUMBER OF EL. IN REGION TABLE.\n         DC    A(JWGHT)            JOB WEIGHT TABLE.\n         DC    A(JWGHN)            NO. OF EL. IN JOB WEIGHT TABLE.\n         DC    A(SCHCLT)           JOB CLASSES TABLE.\n         DC    A(SCHCLTS)          SETUP JOB CLASSES TABLE.\n         DC    A(L'SCHCLT)         JOB CLASSES TABLE EL. LENGTH.\n         DC    A(SCHCLTLG)         JOB CLASSES BLOCK TABLE EL. LENGTH.\n         DC    A(JPGNT)            JOB PERFORMANCE GROUP TABLE.\n         DC    A(L'JPGNT)          JOB PERF. GROUP TABLE EL. LENGTH.\n         DC    A(SDSNTB)           SPECIAL JOB CLASSES TABLE.\n         SPACE 1\nDEFTIME  DC    F'60'               DEFAULT CPU TIME IN SEC.\nDEFREG   DC    F'1024'             DEFAULT REGION SIZE IN K.\nPCOEFF   DC    F'25'               SCHED. PRIORITY COMPUTATION COEFF.\n         SPACE 1\n         DC    A(UJVFSW)           IEFUJV - CONTROL SUPPRESS.\n         DC    A(ACCNME)           ACCOUNTING DATA-SET DEFAULT NAME.\n         AGO   .N99\n.N0      SPACE 1\nUVTDSECT DSECT                     UJVTABLE VECTOR.\n         SPACE 1\nSYSAUT   DS    A                   AUTHORIZATIONS TABLE.\nSYSBOX   DS    A                   BOXES TABLE.\nSYSIOS   DS    A                   TIME AND/OR I/O CONTROL TABLE.\nSYSPST   DS    A                   SPECIAL TASKS/CLASS TABLE.\nSYSEXC   DS    A                   CLASS/EXEMPTIONS/PG TABLE.\nSCHPRT   DS    A                   SCHEDULING PRIORITY TABLE.\nSCHPRN   DS    F                   NO. OF EL. IN SCHED. PRIORITY TABLE.\nIOCT     DS    A                   LAST EL. OF I/O INDEX TABLE.\nIOCN     DS    F                   NO. OF EL. IN I/O INDEX TABLE.\nMEMCT    DS    A                   REGION TABLE.\nMEMCN    DS    F                   NUMBER OF EL. IN REGION TABLE.\nJWGHT    DS    A                   JOB WEIGHT TABLE.\nJWGHN    DS    F                   NO. OF EL. IN JOB WEIGHT TABLE.\nSCHCLT   DS    A                   JOB CLASSES TABLE.\nSCHCLTS  DS    A                   SETUP JOB CLASSES TABLE.\nSCHCLTL  DS    F                   JOB CLASSES TABLE EL. LENGTH.\nSCHCLTLG DS    F                   JOB CLASSES BLOCK TABLE EL. LENGTH.\nJPGNT    DS    A                   JOB PERFORMANCE GROUP TABLE.\nJPGNTL   DS    F                   JOB PERF. GROUP TABLE EL. LENGTH.\nSDSNTB   DS    A                   SPECIAL JOB CLASSES TABLE.\n         SPACE 1\nDEFTIME  DS    F                   DEFAULT CPU TIME IN SEC.\nDEFREG   DS    F                   DEFAULT REGION SIZE IN K.\nPCOEFF   DS    F                   SCHED. PRIORITY COMPUTATION COEFF.\n         SPACE 1\nUJVFSW   DS    A                   IEFUJV - CONTROL SUPPRESS.\nACCNME   DS    A                   ACCOUNTING DATA-SET DEFAULT NAME.\n         SPACE 1\n&SYSECT  CSECT  .                  RESTORE ORIGINAL CSECT.\n.N99     SPACE 1\n*                        CLASS/EXEMPTIONS FLAGS.\nIOXC     EQU   X'01'               NO I/O CONTROL.\nPYSL     EQU   X'02'               PRIORITY SELECT.\nXCMN     EQU   X'04'               CLASS RETAIN.\nXSTF     EQU   X'08'               SETUP ACCEPT.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VCLOSE": {"ttr": 6660, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VCLOSE SUPPLY.\n&NAME   $VCLOSE     &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VCLOSE MACRO : CALL VCLOSE SUPPLY (SEE VCLOSE/VREAD).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(VCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(VCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(VCLOSE)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VOPEN": {"ttr": 6663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VOPEN SUPPLY.\n&NAME   $VOPEN      &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VOPEN MACRO : CALL VOPEN SUPPLY (SEE VOPEN/VREAD).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(VOPEN)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(VOPEN)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VREAD": {"ttr": 6666, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VREAD SUPPLY.\n&NAME   $VREAD      &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VREAD MACRO : CALL VREAD SUPPLY (SEE VREAD).\n.* --------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(VREAD)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(VREAD)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VTOCDC": {"ttr": 6669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00[\\x00[\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VTOCDC SUPPLY.\n&NAME   $VTOCDC     &A,&MF=\n         LCLA  &Y\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VTOCDC MACRO : CALL VTOCDC SUPPLY (SEE VTOCD).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 1).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS1\n         AIF   (T'&A EQ 'O').LS1\n         AIF   ('&A'(1,1) EQ '(').REG\n&NAME    DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.LS1     ANOP\n&NAME    DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n         AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL13\n         AIF   (T'&A EQ 'O').XL13\n         AIF   ('&A'(1,1) EQ '(').XL11\n         LA    15,&A\n         ST    15,0(1)             STORE INTO PARM. LIST.\n         AGO   .XL12\n.XL11    ST    &A(1,1),0(1)        STORE INTO PARM. LIST.\n.XL12    OI    0(1),X'80'          SET LAST WORD BIT ON.\n.XL13    AIF   (&W).XL14\n         L     15,=V(VTOCDC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL14    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O').NL1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   ('&A'(1,1) NE '(').XI3\n         ST    &A(1,1),&X          STORE INTO PARM. LIST.\n         OI    &X,X'80'            SET LAST WORD BIT ON.\n.XI3     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n         AIF   ('&A'(1,1) EQ '(').XI4\n         DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         AGO   .XI5\n.XI4     DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n.XI5     ANOP\n&X.A     L     15,=V(VTOCDC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(VTOCDC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VTOCDO": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VTOCDO SUPPLY.\n&NAME   $VTOCDO     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VTOCDO MACRO : CALL VTOCDO SUPPLY (SEE VTOCD).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(VTOCDO)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(VTOCDO)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VTOCDR": {"ttr": 6916, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VTOCDR SUPPLY.\n&NAME   $VTOCDR     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VTOCDR MACRO : CALL VTOCDR SUPPLY (SEE VTOCD).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 2).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 2).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(VTOCDR)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(VTOCDR)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VTOCDW": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VTOCDW SUPPLY.\n&NAME   $VTOCDW     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VTOCDW MACRO : CALL VTOCDW SUPPLY (SEE VTOCD).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST LT 2).MIS\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST LT 2).MIS\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(VTOCDW)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST LT 2).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(VTOCDW)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VTOCQC": {"ttr": 6922, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00[\\x00[\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VTOCQC SUPPLY.\n&NAME   $VTOCQC     &A,&MF=\n         LCLA  &Y\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VTOCQC MACRO : CALL VTOCQC SUPPLY (SEE VTOCQ).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 1).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS1\n         AIF   (T'&A EQ 'O').LS1\n         AIF   ('&A'(1,1) EQ '(').REG\n&NAME    DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.LS1     ANOP\n&NAME    DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n         AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL13\n         AIF   (T'&A EQ 'O').XL13\n         AIF   ('&A'(1,1) EQ '(').XL11\n         LA    15,&A\n         ST    15,0(1)             STORE INTO PARM. LIST.\n         AGO   .XL12\n.XL11    ST    &A(1,1),0(1)        STORE INTO PARM. LIST.\n.XL12    OI    0(1),X'80'          SET LAST WORD BIT ON.\n.XL13    AIF   (&W).XL14\n         L     15,=V(VTOCQC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL14    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O').NL1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   ('&A'(1,1) NE '(').XI3\n         ST    &A(1,1),&X          STORE INTO PARM. LIST.\n         OI    &X,X'80'            SET LAST WORD BIT ON.\n.XI3     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n         AIF   ('&A'(1,1) EQ '(').XI4\n         DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         AGO   .XI5\n.XI4     DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n.XI5     ANOP\n&X.A     L     15,=V(VTOCQC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(VTOCQC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VTOCQO": {"ttr": 6925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VTOCQO SUPPLY.\n&NAME   $VTOCQO     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VTOCQO MACRO : CALL VTOCQO SUPPLY (SEE VTOCQ).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(VTOCQO)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(VTOCQO)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VTOCQR": {"ttr": 7171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VTOCQR SUPPLY.\n&NAME   $VTOCQR     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VTOCQR MACRO : CALL VTOCQR SUPPLY (SEE VTOCQ).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(VTOCQR)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(VTOCQR)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VTOCSC": {"ttr": 7174, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00[\\x00[\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VTOCSC SUPPLY.\n&NAME   $VTOCSC     &A,&MF=\n         LCLA  &Y\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VTOCSC MACRO : CALL VTOCSC SUPPLY (SEE VTOCS).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 1).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS1\n         AIF   (T'&A EQ 'O').LS1\n         AIF   ('&A'(1,1) EQ '(').REG\n&NAME    DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.LS1     ANOP\n&NAME    DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n         AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL13\n         AIF   (T'&A EQ 'O').XL13\n         AIF   ('&A'(1,1) EQ '(').XL11\n         LA    15,&A\n         ST    15,0(1)             STORE INTO PARM. LIST.\n         AGO   .XL12\n.XL11    ST    &A(1,1),0(1)        STORE INTO PARM. LIST.\n.XL12    OI    0(1),X'80'          SET LAST WORD BIT ON.\n.XL13    AIF   (&W).XL14\n         L     15,=V(VTOCSC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL14    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O').NL1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   ('&A'(1,1) NE '(').XI3\n         ST    &A(1,1),&X          STORE INTO PARM. LIST.\n         OI    &X,X'80'            SET LAST WORD BIT ON.\n.XI3     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n         AIF   ('&A'(1,1) EQ '(').XI4\n         DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         AGO   .XI5\n.XI4     DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n.XI5     ANOP\n&X.A     L     15,=V(VTOCSC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    SR    1,1                 NO PARM. LIST.\n         L     15,=V(VTOCSC)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VTOCSO": {"ttr": 7177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VTOCSO SUPPLY.\n&NAME   $VTOCSO     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VTOCSO MACRO : CALL VTOCSO SUPPLY (SEE VTOCS).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(VTOCSO)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(VTOCSO)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VTOCSR": {"ttr": 7180, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VTOCSR SUPPLY.\n&NAME   $VTOCSR     &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* $VTOCSR MACRO : CALL VTOCSR SUPPLY (SEE VTOCS).\n.* ---------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(VTOCSR)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(VTOCSR)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$VTTCAM": {"ttr": 7183, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL VTTCAM SUPPLY.\n&NAME   $VTTCAM     &DUMMY\n.*\n.* $VTTCAM MACRO : CALL VTTCAM SUPPLY (SEE VTTCAM).\n.* -------------\n.*\n.* AUTHOR :    N. RAVARANI\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n&NAME    L     15,=V(VTTCAM)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$XENT": {"ttr": 7425, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x13\\x1f\\x00\\x87\\x13\\x1f\\x15\\x08\\x00\\xb2\\x00\\xb2\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-05-11T00:00:00", "modifydate": "1987-05-11T15:08:00", "lines": 178, "newlines": 178, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           ENTER EXECUTION.\n&NAME   $XENT  &TYPE=NORENT,&BASE=(11,12),&B1=,&B2=,                   1\n               &ID=,&DT=YES,&LV=72,&SP=0\n         LCLA  &SN,&ST\n         LCLC  &NCS,&R1,&R2,&BS\n         SPACE 1\n.*\n.* $XENT MACRO : ENTER CONTROL.\n.* -------------\n.*\n.*    1. TYPE=NORENT (NOT REENTERABLE)\n.*\n.*       - STORE THE REGISTERS IN THE CALLER'S SAVE AREA (REGISTER 13).\n.*       - SET ONE OR MORE BASE REGISTERS (BASE OR B1 AND B2 OPERANDS).\n.*       - GENERATE THE IDENTIFIER NAME.\n.*       - GENERATE THE ASSEMBLY DATE AND TIME (DT OPERAND).\n.*       - LINK A NEW SAVE AREA (NEW REGISTER 13), WHICH IS\n.*         LOCATED AT THE ENTRY POINT ADDRESS + 32 (X'20').\n.*\n.*    2. TYPE=RENT (REENTERABLE)\n.*\n.*       - STORE THE REGISTERS IN THE CALLER'S SAVE AREA (REGISTER 13).\n.*       - SET ONE OR MORE BASE REGISTERS (BASE OR B1 AND B2 OPERANDS).\n.*       - GENERATE THE IDENTIFIER NAME.\n.*       - GENERATE THE ASSEMBLY DATE AND TIME (DT OPERAND).\n.*       - ACQUIRE (GETMAIN) MAIN STORAGE AREA (L AND S OPERAND) INTO\n.*         WHICH IS CREATED, AT THE STARTING ADDRESS, THE NEW SAVE\n.*         AREA (NEW REGISTER 13).\n.*\n.* TYPE OPERAND       - RENT OR NORENT (DEFAULT).\n.*\n.* BASE OPERAND       - CAN BE USED TO DEFINE THE DESIRED BASE\n.*                      REGISTERS (DEFAULT VALUES ARE 11 AND 12).\n.*                      MORE REGISTERS VALUES SEPARATED BY COMMAS\n.*                      AND ENCLOSED WITHIN PARENTHESES MAY BE\n.*                      SPECIFIED. THE FIRST BASE REGISTER POINTS\n.*                      TO THE ENTRY ADDRESS, AND THE SUCCESSIVE\n.*                      ARE INCREMENTED BY A DISPLACEMENT OF +4096.\n.*                      THIS OPERAND SUPERSEDES B1 AND B2 OPERANDS.\n.*                      DO NOT SPECIFY REGISTER 0, 1, 13, 14 OR 15\n.*                      TO ANY VALUE OF THIS OPERAND.\n.*\n.* B1 AND B2 OPERANDS - THESE OPERANDS ARE SUPERSEDED BY THE BASE\n.*                      OPERAND. THEY ARE MAINTAINED FOR OLD\n.*                      SOURCE COMPATIBILITY ONLY.\n.*                      CAN BE USED TO DEFINE THE DESIRED BASE\n.*                      REGISTERS (DEFAULT VALUES ARE 11 AND 12,\n.*                      WHICH RESPECTIVELY POINT TO THE ENTRY\n.*                      ADDRESS AND THE ENTRY ADDRESS + 4096).\n.*                      DO NOT SPECIFY REGISTER 0, 1, 13, 14 OR 15\n.*                      TO ANY ONE OF THESE OPERANDS.\n.*\n.* ID OPERAND         - IDENTIFIER NAME (8 CHARACTERS LENGTH MAXIMUM).\n.*                      IF OMITTED, THE LABEL NAME IS USED IF SUPPLIED,\n.*                      OR THE CURRENT CONTROL SECTION NAME.\n.*\n.* DT OPERAND         - CAN BE USED TO SUPPRESS THE ASSEMBLY DATE AND\n.*                      TIME GENERATION (I.E. - DT=NO).\n.*\n.* LV OPERAND         - IS THE LENGTH OF THE MAIN STORAGE AREA TO BE\n.*                      ACQUIRED (LV OPERAND OF THE GETMAIN R-TYPE\n.*                      MACRO). DEFAULT VALUE IS 72 (18*4 IS EQUAL\n.*                      TO A SAVE AREA).\n.*\n.* SP OPERAND         - IS THE SUBPOOL NUMBER OF THE MAIN STORAGE TO\n.*                      BE ALLOCATED (SP OPERAND OF THE GETMAIN R-TYPE\n.*                      MACRO). DEFAULT VALUE IS 0 (ZERO).\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   ('&B1' EQ '').T1\n&R1      SETC  '&B1'\n&R2      SETC  '&B2'\n&ST      SETA  0\n         AGO   .T3\n.T1      AIF   ('&B2' NE '').ERR1\n         AIF   ('&BASE' EQ '').ERR1\n&R1      SETC  '&BASE(1)'\n&R2      SETC  '&BASE(2)'\n&ST      SETA  1\n         AIF   ('&BASE'(1,1) EQ '(').T2\n&BS      SETC  '&BASE'\n         AGO   .T3\n.T2      ANOP\n&SN      SETA  K'&BASE-2\n&BS      SETC  '&BASE'(2,&SN)\n.T3      AIF   ('&R1' EQ '&R2').ERR2\n         AIF   ('&NAME' EQ '').N0\n&NCS     SETC  '&NAME'\n         AGO   .N1\n.N0      ANOP\n&NCS     SETC  '&SYSECT'\n.N1      AIF   (&ST EQ 0).N2\n         USING &NCS,&BS SET ADDRESSABILITY.\n         AGO   .N4\n.N2      AIF   ('&R2' NE '').N3\n         USING &NCS,&R1 SET ADDRESSABILITY.\n         AGO   .N4\n.N3      USING &NCS,&R1,&R2 SET ADDRESSABILITY.\n.N4      SPACE 1\n         CNOP  0,8\n&NAME    STM   14,12,12(13) SAVE REGISTERS.\n         AIF   ('&TYPE' EQ 'NORENT').N10\n         AIF   ('&TYPE' NE 'RENT').ERR3\n         AIF   ('&DT' EQ 'YES').N5\n         B     16(,15) BRANCH AROUND ID.\n         AGO   .N6\n.N5      B     30(,15) BRANCH AROUND ID, DATE AND TIME.\n.N6      SPACE 1\n         AIF   ('&ID' EQ '').N7\n         DC    CL8'&ID' IDENTIFIER.\n         AGO   .N8\n.N7      DC    CL8'&NCS' IDENTIFIER.\n.N8      AIF   ('&DT' NE 'YES').N9\n         DC    CL8'&SYSDATE' ASSEMBLY DATE (MM/DD/YY).\n         DC    C'-'\n         DC    CL5'&SYSTIME' ASSEMBLY TIME (HH.MM).\n.N9      SPACE 1\n         LR    &R1,15 SET BASE REGISTER.\n        GETMAIN R,LV=&LV,SP=&SP\n         LR    15,13 PREVIOUS SAVE AREA.\n         LR    13,1 CURRENT SAVE AREA.\n         XC    0(18*4,13),0(13) CLEAR SAVE AREA.\n         ST    13,8(15) LINK SAVE AREAS.\n         ST    15,4(13)\n         LM    14,1,12(15) RESTORE ENTRY REGISTERS.\n         AGO   .N17\n.N10     LR    &R1,15 SET BASE REGISTER.\n         AIF   ('&DT' EQ 'YES').N11\n         LR    15,13 PREVIOUS SAVE AREA.\n         LA    13,32(&R1) CURRENT SAVE AREA.\n         ST    13,8(15) LINK SAVE AREAS.\n         ST    15,4(13)\n         B     *+L'*+(18*4)+8 BRANCH AROUND ID AND SAVE AREA.\n         AGO   .N12\n.N11     B     *+L'*+(18*4)+22 BRANCH AROUND ID, DATE, TIME AND S.A.\n.N12     SPACE 1\n         AIF   ('&ID' EQ '').N13\n         DC    CL8'&ID' IDENTIFIER.\n         AGO   .N14\n.N13     DC    CL8'&NCS' IDENTIFIER.\n.N14     AIF   ('&DT' NE 'YES').N15\n         DC    CL8'&SYSDATE' ASSEMBLY DATE (MM/DD/YY).\n         DC    C'-'\n         DC    CL5'&SYSTIME' ASSEMBLY TIME (HH.MM).\n.N15     DC    18F'0' . . . . . . . . . . SAVE AREA.\n         SPACE 1\n         AIF   ('&DT' EQ 'YES').N16\n         AIF   ('&R2' EQ '').END\n         AGO   .N18\n.N16     LR    15,13 PREVIOUS SAVE AREA.\n         LA    13,32(&R1) CURRENT SAVE AREA.\n         ST    13,8(15) LINK SAVE AREAS.\n         ST    15,4(13)\n.N17     AIF   ('&R2' EQ '').END\n.N18     LA    &R2,2048(0,&R1)\n         LA    &R2,2048(0,&R2)\n         AIF   (&ST EQ 0).END\n&SN      SETA  3\n.N19     AIF   ('&BASE(&SN)' EQ '').END\n&ST      SETA  1\n.N20     AIF   ('&BASE(&SN)' EQ '&BASE(&ST)').ERR2\n&ST      SETA  &ST+1\n         AIF   (&ST LT &SN).N20\n         LA    &BASE(&SN),2048(0,&BASE(&SN-1))\n         LA    &BASE(&SN),2048(0,&BASE(&SN))\n&SN      SETA  &SN+1\n         AGO   .N19\n.ERR1    MNOTE 8,' FIRST BASE REGISTER UNDEFINED ******************** '\n         AGO   .END\n.ERR2    MNOTE 8,' IDENTICAL BASE REGISTERS ************************* '\n         AGO   .END\n.ERR3    MNOTE 8,' INVALID TYPE OPERAND SPECIFIED ******************* '\n.END     SPACE 1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$XENT@": {"ttr": 7429, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x12\\x00G\\x00G\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:12:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      $XENT     1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         ENTER CONTROL MACRO         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Assembler macro : $XENT BASE=,ID=,DT=,TYPE=,LV=,SP=\n  ----------------- $XENT B1=,B2=,ID=,DT=,TYPE=,LV=,SP=  (old version)\n\n      1. TYPE=NORENT (not reenterable)\n\n         - store the registers in the caller's save area (register 13).\n         - set one or more base registers (BASE or B1 and B2 operands).\n         - generate the identifier name.\n         - generate the assembly date and time (DT operand).\n         - link a new save area (new register 13), which is\n           located at the entry point address + 32 (X'20').\n\n      2. TYPE=RENT (reenterable)\n\n         - store the registers in the caller's save area (register 13).\n         - set one or more base registers (BASE or B1 and B2 operands).\n         - generate the identifier name.\n         - generate the assembly date and time (DT operand).\n         - acquire (GETMAIN) main storage area (L and S operands into\n           which is created, at the starting address, the new save\n           area (new register 13).\n\n   TYPE operand       - RENT or NORENT (default).\n\n   BASE operand       - can be used to define the desired base\n                        registers (default values are 11 and 12).\n                        more registers values separated by commas\n                        and enclosed within parentheses may be\n                        specified. The first base register points\n                        to the entry address, and the successives\n                        are incremented by a displacement of +4096.\n                        This operand supersedes B1 and B2 operands.\n                        Do not specify register 0, 1, 13, 14 or 15\n                        to any value of this operand.\n\n   B1 and B2 operands - these operands are superseded by the BASE\n                        operand. They are maintained for old\n                        source compatibility only.\n                        Can be used to define the desired base\n                        registers (default values are 11 and 12,\n                        which respectively point to the entry\n                        address and the entry address + 4096).\n                        Do not specify register 0, 1, 13, 14 or 15\n                        to any one of these operands.\n1   23/09/85\n                                                      $XENT     2/2.\n\n   ID operand         - identifier name (8 characters length maximum).\n                        If omitted, the label name is used if supplied,\n                        or the current control section name.\n\n   DT operand         - can be used to suppress the assembly date and\n                        time generation (i.e. - DT=NO).\n\n   LV operand         - is the length of the main storage area to be\n                        acquired (LV operand of the GETMAIN R-type\n                        macro). Default value is 72 (18*4 is equal\n                        to a save area).\n\n   SP operand         - Is the subpool number of the main storage to\n                        be allocated (SP operand of the GETMAIN R-type\n                        macro). Default value is 0 (zero).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$XRET": {"ttr": 7432, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16(\\x00[\\x00[\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:28:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           END EXECUTION.\n&NAME   $XRET       &TYPE=NORENT,&CC=,&LV=72,&SP=0\n         LCLA  &SW\n&SW      SETA  0\n         SPACE 1\n.*\n.* $XRET MACRO : RETURN CONTROL.\n.* -------------\n.*\n.*    1. TYPE=NORENT (NOT REENTERABLE)\n.*\n.*       - RESTORE REGISTER 13 WITH THE PREVIOUS SAVE AREA ADDRESS.\n.*       - SET A RETURN CODE IN THE REGISTER 15 (CC OPERAND).\n.*       - RESTORE ALL THE OTHER REGISTERS FROM THE PREVIOUS\n.*         SAVE AREA.\n.*       - FLAG THE SAVE AREA USED BY THE RETURNING PROGRAM.\n.*       - RETURN CONTROL TO THE CALLING PROGRAM (REGISTER 14).\n.*\n.*    2. TYPE=RENT (REENTERABLE)\n.*\n.*       - RESTORE REGISTER 13 WITH THE PREVIOUS SAVE AREA ADDRESS.\n.*       - RELEASE (FREEMAIN) AN AREA OF MAIN STORAGE (LV AND SP\n.*         OPERANDS) WHICH IS POINTED TO BY REGISTER 13 (CURRENT\n.*         SAVE AREA ADDRESS).\n.*       - SET A RETURN CODE IN THE REGISTER 15 (CC OPERAND).\n.*       - RESTORE ALL THE OTHER REGISTERS FROM THE PREVIOUS\n.*         SAVE AREA.\n.*       - FLAG THE SAVE AREA USED BY THE RETURNING PROGRAM.\n.*       - RETURN CONTROL TO THE CALLING PROGRAM (REGISTER 14).\n.*\n.* TYPE OPERAND - RENT OR NORENT (DEFAULT).\n.*\n.* CC OPERAND - OMITTED : EQUIVALENT TO CC=0 CODING.\n.*              CC=VALUE : A NUMBER (FROM 0 TO 4095).\n.*              CC=SYMBOL : A SYMBOL (VALUE MUST RANGE FROM 0 TO 4095).\n.*              CC=(REGISTER) : VALUE PREVIOUSLY LOADED INTO A\n.*                              REGISTER (0 TO 4095). DO NOT SPECIFY\n.*                              REGISTER 13 WHEN NORENT TYPE, AND\n.*                              REGISTER 0, 1, 13, 14 OR 15 WHEN RENT\n.*                              TYPE.\n.*\n.* LV OPERAND - IS THE LENGTH OF THE MAIN STORAGE AREA TO BE RELEASED\n.*              (LV OPERAND OF THE FREEMAIN R-TYPE MACRO). DEFAULT\n.*              VALUE IS 72 (18*4 IS EQUAL TO A SAVE AREA).\n.*\n.* SP OPERAND - IS THE SUBPOOL NUMBER OF THE MAIN STORAGE TO BE\n.*              FREED (SP OPERAND OF THE FREEMAIN R-TYPE MACRO).\n.*              DEFAULT VALUE IS 0 (ZERO).\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   ('&TYPE' EQ 'NORENT').N1\n         AIF   ('&TYPE' NE 'RENT').ERR1\n&NAME    LR    1,13 MAIN STORAGE AREA TO BE RELEASED.\n         L     13,4(13) PREVIOUS SAVE AREA.\n         AGO   .N2\n.N1      ANOP\n&NAME    L     13,4(13) PREVIOUS SAVE AREA.\n.N2      AIF   ('&CC' EQ '').N3\n         AIF   ('&CC'(1,1) EQ '(').N4\n         AIF   ('&CC' NE '0').N5\n.N3      SR    15,15 SET RETURN CODE ZERO.\n         ST    15,16(13) SET RETURN CODE.\n         AIF   ('&TYPE' NE 'RENT').N8\n         AGO   .N7\n.N4      ST    &CC(1),16(13) SET RETURN CODE.\n         AIF   ('&TYPE' NE 'RENT').N8\n         AGO   .N7\n.N5      AIF   ('&TYPE' EQ 'RENT').N6\n         MVC   16(4,13),*+L'*+10 SET RETURN CODE.\n&SW      SETA  1\n         AGO   .N8\n.N6      MVC   16(4,13),*+L'*+4 SET RETURN CODE.\n         B     *+L'*+4 SKIP RETURN CODE.\n         SPACE 1\n         DC    AL4(&CC) RETURN CODE.\n         SPACE 1\n.N7     FREEMAIN R,LV=&LV,A=(1),SP=&SP\n.N8      LM    14,12,12(13) RESTORE REGISTERS.\n         MVI   12(13),X'FF' SET RETURN INDICATOR.\n         BR    14 RETURN.\n         AIF   (&SW EQ 0).END\n         SPACE 1\n         DC    AL4(&CC) RETURN CODE.\n         AGO   .END\n.ERR1    MNOTE 8,' INVALID TYPE OPERAND SPECIFIED ******************* '\n.END     SPACE 1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$XRET@": {"ttr": 7435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x12\\x003\\x003\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:12:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      $XRET     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        RETURN CONTROL MACRO         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Assembler macro : $XRET CC=,TYPE=,LV=,SP=\n  -----------------\n\n      1. TYPE=NORENT (not reenterable)\n\n         - restore register 13 with the previous save area address.\n         - set a return code in the register 15 (CC operand).\n         - restore all the other registers from the previous\n           save area.\n         - flag the save area used by the returning program.\n         - return control to the calling program (register 14).\n\n      2. TYPE=RENT (reenterable)\n\n         - restore register 13 with the previous save area address.\n         - release (FREEMAIN) an area of main storage (LV and SP\n           operands) which is pointed to by register 13 (current\n           save area address).\n         - set a return code in the register 15 (CC operand).\n         - restore all the other registers from the previous\n           save area.\n         - flag the save area used by the returning program.\n         - return control to the calling program (register 14).\n\n   TYPE operand - RENT or NORENT (default).\n\n   CC operand - omitted : equivalent to CC=0 coding.\n                CC=value : a number (from 0 to 4095).\n                CC=symbol : a symbol (value must range from 0 to 4095).\n                CC=(register) : value previously loaded into a\n                                register (0 to 4095). Do not specify\n                                register 13 when NORENT type, and\n                                register 0, 1, 13, 14 or 15 when RENT\n                                type.\n\n   LV operand - is the length of the main storage area to be released\n                (LV operand of the FREEMAIN R-type macro). Default\n                value is 72 (18*4 is equal to a save area).\n\n   SP operand - is the subpool number of the main storage to be\n                freed (SP operand of the FREEMAIN R-type macro).\n                Default value is 0 (zero).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$XTC": {"ttr": 7437, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x11S\\x00\\x87\\x00\\x87\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T11:53:00", "lines": 135, "newlines": 135, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL XTC/XTCE SUPPLY.\n&NAME   $XTC   &A,&B,&C,&D,&MSG=,&MF=,&TSO=E\n         LCLA  &Y,&Z\n         LCLC  &X,&NME\n.*\n.* $XTC MACRO : CALL XTC/XTCE SUPPLY (SEE XTC/XTCE).\n.* ------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 4).BAD\n&NME     SETC  '&NAME'\n         AIF   ('&MF' NE 'L').XQ\n         AIF   ('&MSG' EQ '').A1\n         MNOTE 0,' MSG= IS ONLY EXECUTE FORM OPERAND **************** '\n.A1      ANOP\n&Z       SETA  1\n.B1      AIF   (N'&SYSLIST EQ &Z).F1\n         AIF   (T'&SYSLIST(&Z) EQ 'O').C1\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').INV\n&NME     DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .D1\n.C1      ANOP\n&NME     DC    A(0)                P.P. PARAMETER.\n.D1      AIF   ('&NME' EQ '').E1\n&NME     SETC  ''\n.E1      ANOP\n&Z       SETA  &Z+1\n         AGO   .B1\n.F1      AIF   (T'&SYSLIST(&Z) EQ 'O').G1\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').INV\n&NME     DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.G1      ANOP\n&NME     DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XQ      AIF   ('&MF' EQ '').IL\n         AIF   ('&MF' NE 'E').OL\n.IL      ANOP\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n.A2      AIF   (T'&SYSLIST(&Z) EQ 'O').B2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').D2\n.B2      AIF   (N'&SYSLIST EQ &Z).E2\n.C2      ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .A2\n.D2      ANOP\n&NME     ST    &SYSLIST(&Z,1),&X+&Y STORE INTO PARM. LIST.\n&NME     SETC  ''\n         AIF   (N'&SYSLIST NE &Z).C2\n         OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.E2      ANOP\n&NME     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n&NME     SETC  ''\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.F2      AIF   (N'&SYSLIST EQ &Z).I2\n         AIF   (T'&SYSLIST(&Z) EQ 'O').G2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').G2\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .H2\n.G2      DC    A(0)                P.P. PARAMETER.\n.H2      ANOP\n&Z       SETA  &Z+1\n         AGO   .F2\n.I2      AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').K2\n         AIF   (T'&SYSLIST(&Z) EQ 'O').J2\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .L2\n.J2      DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .L2\n.K2      DC    A(0)                LAST P.P. PARAMETER.\n.L2      ANOP\n&X.A     SR    0,0                 SET MSG OPTION\n         AGO   .CA\n.OL      AIF   ('&MF(1)' NE 'E').MFE\n         AIF   ('&MF(2)'(1,1) EQ '(').A3\n&NME     LA    1,&MF(2)            LOAD LIST ADDRESS IN REG. 1.\n         AGO   .B3\n.A3      AIF   ('&MF(2)' EQ '(1)').C3\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NME     LR    1,&X                LOAD LIST ADDRESS IN REG. 1.\n.B3      ANOP\n&NME     SETC  ''\n.C3      ANOP\n&Y       SETA  0\n&Z       SETA  1\n.D3      ANOP\n&X       SETC  '&Y'.'(1)'\n         AIF   (T'&SYSLIST(&Z) NE 'O').F3\n         AIF   (N'&SYSLIST EQ &Z).J3\n.E3      ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .D3\n.F3      AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').G3\n&NME     LA    15,&SYSLIST(&Z,1)\n         ST    15,&X               STORE INTO PARM. LIST.\n         AGO   .H3\n.G3      ANOP\n&NME     ST    &SYSLIST(&Z,1),&X   STORE INTO PARM. LIST.\n.H3      AIF   ('&NME' EQ '').I3\n&NME     SETC  ''\n.I3      AIF   (N'&SYSLIST NE &Z).E3\n         OI    &X,X'80'            SET LAST WORD BIT ON.\n.J3      ANOP\n&NME     SR    0,0                 SET MSG OPTION\n.CA      AIF   ('&MSG' EQ 'NO').L3\n         AIF   ('&MSG' EQ 'ALL').K3\n         ICM   0,B'1000',=X'0F'\n         AGO   .L3\n.K3      ICM   0,B'1000',=X'F0'\n.L3      AIF   ('&TSO' EQ 'E').M3\n         AIF   ('&TSO' EQ '').N3\n         MNOTE 0,' TSO= INVALID CODING, TSO=E ASSUMED *************** '\n.M3      L     15,=V(XTCE)         LOAD REG. 15 WITH ENTRY.\n         AGO   .O3\n.N3      L     15,=V(XTC)          LOAD REG. 15 WITH ENTRY.\n.O3      BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.INV     MNOTE 8,' INVALID OPERAND ********************************** '\n         MEXIT\n.MFE     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DOC#": {"ttr": 7440, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x11\\x7f\\x00\\x90\\x11\\x7f\\x13W\\x00&\\x00&\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-04-27T00:00:00", "modifydate": "1990-04-27T13:57:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SYSPAJA"}, "text": "1   27/04/90\n\n\n\n\n\n\n\n\n\n\n\n\n\n                DDDDDDD          OOOOOOO         CCCCCCCC\n                DDDDDDDD        OOOOOOOOO       CCCCCCCCC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DDDDDDDD        OOOOOOOOO       CCCCCCCCC\n                DDDDDDD          OOOOOOO         CCCCCCCC\n\n\n\n\n\n\n\n\n\n\n\n\n\n=/MB     $$$DOC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#INFO#": {"ttr": 7681, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943?\\x00\\x943?\\x122\\x00\\x9d\\x00\\x9d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-29T00:00:00", "modifydate": "1994-11-29T12:32:00", "lines": 157, "newlines": 157, "modlines": 0, "user": "SYSPAJA"}, "text": "1   27/04/90\n\n\n\n\n\n\n\n\n\n\n\n\n\n          IIII       NN     NN       FFFFFFFFF        OOOOOOO\n           II        NNN    NN       FFFFFFFFF       OOOOOOOOO\n           II        NNNN   NN       FF              OO     OO\n           II        NN NN  NN       FF              OO     OO\n           II        NN  NN NN       FFFFFF          OO     OO\n           II        NN   NNNN       FFFFFF          OO     OO\n           II        NN    NNN       FF              OO     OO\n           II        NN     NN       FF              OO     OO\n           II        NN     NN       FF              OOOOOOOOO\n          IIII       NN     NN       FF               OOOOOOO\n\n\n\n\n1   17/11/94\n                                                      INDEX     1/3.\n\n=/MB     $DEFREG@  Registers definition macro.\n=/MB     $FS@      IBM 3270 display macros.\n=/MB     $HEDIT@   Header edit macro.\n=/MB     $SORT@    Generate inline SORT macro.\n=/MB     $TEW@     TSO Easy-Way of coding (macros facility).\n=/MB     $TSWXA@   Test/switch addressing mode macro.\n=/MB     $XENT@    Enter control macro.\n=/MB     $XRET@    Return control macro.\n=/MB     ALLOCGD@  GDG data-set dynamic allocation TSO command.\n=/MB     AUTHC@    Command authorization interface.\n=/MB     AUTHCTL@  Euratom authority control.\n=/MB     AUTHSVC@  Authorization SVC for MVS.\n=/MB     BIG@      Create block characters ISPF/PDF EDIT command.\n=/MB     BIGS@     Create slanted block char. ISPF/PDF EDIT command.\n=/MB     BLOCK@    Create multiple block char. ISPF/PDF EDIT command.\n=/MB     CATS@     Read sequentially an O.S. catalog routine.\n=/MB     CENTER@   Center ISPF/PDF EDIT command.\n=/MB     CNVCLIS@  Convert CLISTs from VB-255 to FB-80 and vice versa.\n=/MB     COMPRES@  Compress ISPF/PDF EDIT command.\n=/MB     CONCAT@   CONCAT TSO command.\n=/MB     CONT@     Set continuation ISPF/PDF EDIT command.\n=/MB     CONTROL@  Add CONTROL statements ISPF/PDF EDIT command.\n=/MB     CP@       CP commands (VM/370).\n=/MB     CRY@      Encrypt/Decrypt ISPF/PDF EDIT command.\n=/MB     CUT@      Cut data lines ISPF/PDF EDIT command.\n=/MB     DASCAN@   Direct-access UCB's lookup subroutine.\n=/MB     DAUNTY@   Direct-access unit type subroutine.\n=/MB     DAVALL@   Direct-access volume allocation subroutine.\n=/MB     DECONCA@  DECONCAT TSO command.\n=/MB     DTSO@     Dispaly some control blocks TSO command.\n=/MB     DTUR@     Dsect's tables use routine (DTUSE).\n=/MB     DVTYUN@   Device type to unit name routine.\n=/MB     DYNALL@   Dynamic data-set allocation routine.\n=/MB     DYNCC@    Dynamic concatenation-deconcatenation routine.\n=/MB     EDITH@    Edit header routine.\n=/MB     EDMODE@   Verify and set Edit modes ISPF/PDF EDIT command.\n=/MB     ENDECR@   Encrypt/Decrypt ISPF/PDF EDIT command.\n=/MB     EOL@      Position cursor at end line ISPF/PDF EDIT command.\n=/MB     ERASE@    Terminal erase screen subroutine / TSO command.\n=/MB     EURACFT@  RACF data-set access test TSO command.\n=/MB     EUSID@    System variables CLIST TSO command.\n=/MB     EUSMF@    SMF variables CLIST TSO command.\n=/MB     EUSUB@    Euratom SUBMIT program.\n=/MB     FC@       Find pending Edit line ISPF/PDF EDIT command.\n=/MB     FILEINF@  FILEINFO TSO command.\n=/MB     FILSPAC@  FILSPACE routine.\n=/MB     FINDMEM@  FINDMEM routine.\n=/MB     FIXJCL@   FixJCL ISPF/PDF EDIT command.\n1   17/11/94\n                                                      INDEX     2/3.\n\n=/MB     FLOWJCL@  FlowJCL ISPF/PDF EDIT command.\n=/MB     FSRTN@    Full-screen service routines.\n=/MB     GACTN@    Obtain accounting number and/or programmer's name.\n=/MB     GDGALLR@  GDGALLR routine.\n=/MB     GDGRESE@  GDG Utility program.\n=/MB     GETPAN@   Copy an ISPF-panel image ISPF/PDF EDIT command.\n=/MB     GFDATE@   Generate dates subroutines.\n=/MB     GGUR@     Get GROUP's USERIDs from RACF - routine.\n=/MB     GPARM@    Obtain parm. field.\n=/MB     GUAR@     Get USERID account from SYS1.UADS (TSO) - routine.\n=/MB     ICFS@     Read sequentially an ICF catalog routine.\n=/MB     INSORT@   Incore SORT subroutine.\n=/MB     INTRDR@   Allocate an internal reader.\n=/MB     ISPCDSN@  Data-set selection by cursor from ISPF display.\n=/MB     IXTOFMT@  Indexed VTOC format-5 interface routine.\n=/MB     JB@       Display CPU - SRB (I/O) time.\n=/MB     JOBCARD@  JOBcard ISPF/PDF EDIT command.\n=/MB     JOBS@     Display jobs running in the system.\n=/MB     LISTAX@   LISTAX TSO command.\n=/MB     LISTENQ@  List ENQue's for a JOB/USERID.\n=/MB     LISTNO@   List manual's members (NOTES).\n=/MB     LJUST@    Left justify ISPF/PDF EDIT command.\n=/MB     LOCK@     TSO command to LOCK terminal.\n=/MB     LOGALLO@  LOGALLOC TSO command.\n=/MB     MOVECOL@  Move columns within data lines ISPF/PDF EDIT.\n=/MB     MREAD@    Read PO-members routines.\n=/MB     OPCOM@    Operators communications (alias INIFIN, VERFIN).\n=/MB     PARA@     Paragraph reformatter ISPF/PDF EDIT command.\n=/MB     PDREAD@   Read partitioned directory routine.\n=/MB     PDSW@     Partitioned data-set - where function.\n=/MB     PEDIT@    Print editing data ISPF/PDF EDIT command.\n=/MB     PLREAD@   Read partitioned load module routine.\n=/MB     PLUG@     Plug data into lines ISPF/PDF EDIT command.\n=/MB     PSWR@     Obtain RACF password.\n=/MB     RDCHK@    Read tape data-check routine.\n=/MB     RESUME@   Restore ISPF/PDF EDIT command.\n=/MB     RGROUP@   Change current RACF connect group.\n=/MB     RJUST@    Right justify ISPF/PDF EDIT command.\n=/MB     RPROT@    RACF protection TSO command.\n=/MB     RSVENQ@   Display resources ENQue's reserve.\n=/MB     RTIME@    Get remaining CPU-SRB time routine.\n=/MB     SCRSZ@    Get current screen size.\n=/MB     SKEL@     Insert JCL skeletons ISPF/PDF EDIT command.\n=/MB     SKELCHK@  Identify \")SEL-)ENDSEL\" ISPF/PDF EDIT command.\n=/MB     SLINE@    Set separation line ISPF/PDF EDIT command.\n=/MB     SRCHRPI@  Search a reply pending identification routine.\n=/MB     SSCMD@    Send a system command subroutine.\n=/MB     STCLOK@   Clock measurement routine.\n1   17/11/94\n                                                      INDEX     3/3.\n\n=/MB     SUM@      Sum a column of numbers ISPF/PDF EDIT command.\n=/MB     SYSMAC@   Special system macros.\n=/MB     TRAP@     Insert TSO command output ISPF/PDF EDIT command.\n=/MB     TSODSN@   Display data-set's ENQue's.\n=/MB     TSOENQ@   Display data-sets ENQue's conflicts.\n=/MB     TXPRINT@  Text PRINT routine.\n=/MB     TXPUNCH@  Text PUNCH routine.\n=/MB     TXREAD@   Text READ routine.\n=/MB     TXSNAP@   Snap dump routine.\n=/MB     UADS@     List SYS1.UADS TSO command.\n=/MB     UNIT@     Devices inquiry.\n=/MB     UNITS@    Display unit names.\n=/MB     USERS@    Display TSO users.\n=/MB     VGPSUB@   ISPF VGET-VPUT subroutine.\n=/MB     VREAD@    Variable READ routine.\n=/MB     VTOCD@    VTOC direct read - write routine.\n=/MB     VTOCQ@    VTOC quick sequential read routine.\n=/MB     VTOCS@    VTOC sequential read routine.\n=/MB     VTTCAM@   Test TCAM or VTAM running subroutine.\n=/MB     WAITR@    ENQue's conflicts for a JOB/USERID.\n=/MB     WPC@      Display what profile covers a data-set.\n=/MB     XTC@      Execute TSO commands and/or CLISTs.\n=/MB     XTCE@     - idem ---> IF TSO/E INSTALLED\n=/MB     ZOOM@     Browse JCL procedure ISPF/PDF EDIT.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#MANUAL#": {"ttr": 7685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x11\\x7f\\x00\\x90\\x11\\x7f\\x13W\\x00;\\x00;\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-04-27T00:00:00", "modifydate": "1990-04-27T13:57:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "SYSPAJA"}, "text": "1   27/04/90\n\n\n\n\n\n\n\n\n\n                 IIII                 EEEEEEEE\n                  II                 EEEEEEEEE\n                  II                 EE\n                  II                 EE\n                  II                 EEEEEE\n                  II                 EEEEEE\n                  II                 EE\n                  II                 EE\n                  II        **       EEEEEEEEE       **\n                 IIII       **        EEEEEEEE       **\n\n\n\n\n\n\n\n\n\n    M       M   AAAAAAA   NN     NN  UU     UU   AAAAAAA   LL\n    MM     MM  AAAAAAAAA  NNN    NN  UU     UU  AAAAAAAAA  LL\n    MMM   MMM  AA     AA  NNNN   NN  UU     UU  AA     AA  LL\n    MMMM MMMM  AA     AA  NN NN  NN  UU     UU  AA     AA  LL\n    MM MMM MM  AAAAAAAAA  NN  NN NN  UU     UU  AAAAAAAAA  LL\n    MM  M  MM  AAAAAAAAA  NN   NNNN  UU     UU  AAAAAAAAA  LL\n    MM     MM  AA     AA  NN    NNN  UU     UU  AA     AA  LL\n    MM     MM  AA     AA  NN     NN  UU     UU  AA     AA  LL\n    MM     MM  AA     AA  NN     NN  UUUUUUUUU  AA     AA  LLLLLLLLL\n    MM     MM  AA     AA  NN     NN   UUUUUUU   AA     AA  LLLLLLLLL\n\n\n\n\n\n\n         PURPOSE : this is only an example of how to build a manual.\n                   (see LISTNO information notes)\n1   31/03/88\n                                                      INDEX     1/1.\n\n\n=/MB     $DEFREG@  Registers definition macro.\n=/MB     $FS@      IBM 3270 display full screen macro.\n=/MB     $HEDIT@   Header edit macro.\n=/MB     $SORT@    Generate inline SORT macro.\n=/MB     $TSWXA@   Test and switch addressing mode macro.\n=/MB     $XENT@    Enter control macro.\n=/MB     $XRET@    Return control macro.\n=/MB     SYSMAC@   Special system macros.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FS": {"ttr": 7687, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x16?\\x00\\x91\\x16?\\x15\\x17\\x00\\x8d\\x00\\x8d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-06-12T00:00:00", "modifydate": "1991-06-12T15:17:00", "lines": 141, "newlines": 141, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL FSRTN SUPPLY.\n&NAME   @FS    &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.*\n.* @FS MACRO : CALL FSRTN SUPPLY (SEE FSRTN).\n.* -----------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n         AIF   (N'&SYSLIST EQ 1).LS1\n         AIF   (N'&SYSLIST NE 3).MIS\n.LS1     ANOP\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS2\n&NAME    DS    0F\n.LS2     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS4\n.LS3     DC    A(0)                P.P. PARAMETER.\n.LS4     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS2\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0,0)              P.P. PARAMETERS.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n         AIF   (N'&SYSLIST EQ 1).XL11\n         AIF   (N'&SYSLIST NE 3).MIS\n.XL11    ANOP\n&Y       SETA  0\n&Z       SETA  1\n.XL12    AIF   (T'&SYSLIST(&Z) EQ 'O').XL15\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL13\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL14\n.XL13    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL16\n.XL15    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL16    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL12\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(FSRTN)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST NE 1).XI2\n         AIF   (T'&A EQ 'O').MIS\n         AGO   .XI3\n.XI2     AIF   (N'&SYSLIST NE 3).MIS\n         AIF   (T'&A EQ 'O').MIS\n         AIF   (T'&B EQ 'O').MIS\n         AIF   (T'&C EQ 'O').MIS\n.XI3     ANOP\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI4\n&NAME    DS    0H\n.XI4     AIF   (T'&SYSLIST(&Z) EQ 'O').XI5\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI6\n.XI5     AIF   (N'&SYSLIST EQ &Z).XI9\n         AGO   .XI7\n.XI6     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI8\n.XI7     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI4\n.XI8     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI9     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(FSRTN)        LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND(S) ******************************* '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FSBA": {"ttr": 7691, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x934/\\x00\\x934/\\x16)\\x00\\x83\\x00\\x83\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-12-08T00:00:00", "modifydate": "1993-12-08T16:29:00", "lines": 131, "newlines": 131, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL FSRTNB SUPPLY.\n&NAME   @FSBA  &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.* @FSBA MACRO : CALL FSRTNB SUPPLY (SEE FSRTN).\n.* -------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(FSRTNB)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(FSRTNB)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    XR    1,1                 NO PARM. LIST.\n         L     15,=V(FSRTNB)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FSI": {"ttr": 7694, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x934\\x1f\\x00\\x934\\x1f\\x155\\x00\\x83\\x00\\x83\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-12-07T00:00:00", "modifydate": "1993-12-07T15:35:00", "lines": 131, "newlines": 131, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL FSRTNI SUPPLY.\n&NAME   @FSI   &A,&B,&C,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.* @FSI MACRO : CALL FSRTNI SUPPLY (SEE FSRTN).\n.* ------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 3).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(FSRTNI)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O' AND T'&C EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(FSRTNI)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    XR    1,1                 NO PARM. LIST.\n         L     15,=V(FSRTNI)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FSO": {"ttr": 7939, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x19\\x7f\\x00\\x91\\x19\\x7f\\x10)\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-07-16T00:00:00", "modifydate": "1991-07-16T10:29:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           DEFINE FSRTN OPTIONS SUPPLY.\n&NAME   @FSO   &DUMMY\n.*\n.* @FSO MACRO : DEFINE FSRTN OPTIONS SUPPLY (SEE FSRTN).\n.* ------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n&NAME    DC    XL1'0'\nFSFULL   EQU   X'00'               TPUT/TGET\nFSSKIP   EQU   X'01'               SKIP TGET, ONLY TPUT\nFSSNAP   EQU   X'80'               SNAP TGET REPLY\nFSEXIT   EQU   X'FF'               EXIT/TERMINATE FULLSCREEN\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FSQ": {"ttr": 7941, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x19\\x7f\\x00\\x91\\x19\\x7f\\x12F\\x00_\\x00_\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-07-16T00:00:00", "modifydate": "1991-07-16T12:46:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL FSRTNQ SUPPLY.\n&NAME   @FSQ   &A,&MF=\n         LCLA  &Y\n         LCLB  &W\n         LCLC  &X\n.*\n.* @FSQ MACRO : CALL FSRTNQ SUPPLY (SEE FSRTN).\n.* ------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST LE 1).WHT\n         AIF   (N'&SYSLIST GT 2).BAD\n         AIF   (N'&SYSLIST(1) NE 0).BAD\n         AIF   (N'&SYSLIST(2) NE 0).BAD\n.NL1     ANOP\n&NAME    XR    1,1                 NO PARM. LIST.\n         L     15,=V(FSRTNQ)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.WHT     ANOP\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS1\n         AIF   (T'&A EQ 'O').LS1\n         AIF   ('&A'(1,1) EQ '(').REG\n&NAME    DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.LS1     ANOP\n&NAME    DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n         AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&A EQ 'O').MIS\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL13\n         AIF   (T'&A EQ 'O').XL13\n         AIF   ('&A'(1,1) EQ '(').XL11\n         LA    15,&A\n         ST    15,0(1)             STORE INTO PARM. LIST.\n         AGO   .XL12\n.XL11    ST    &A(1,1),0(1)        STORE INTO PARM. LIST.\n.XL12    OI    0(1),X'80'          SET LAST WORD BIT ON.\n.XL13    AIF   (&W).XL14\n         L     15,=V(FSRTNQ)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL14    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O').NL1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   ('&A'(1,1) NE '(').XI3\n         ST    &A(1,1),&X          STORE INTO PARM. LIST.\n         OI    &X,X'80'            SET LAST WORD BIT ON.\n.XI3     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n         AIF   ('&A'(1,1) EQ '(').XI4\n         DC    A(&A+X'80000000')   LAST AND ONLY P.P. PARAMETER.\n         AGO   .XI5\n.XI4     DC    A(X'80000000')      LAST AND ONLY P.P. PARAMETER.\n.XI5     ANOP\n&X.A     L     15,=V(FSRTNQ)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.MIS     MNOTE 8,' MISSING OPERAND ********************************** '\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FSR": {"ttr": 7944, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x17\\x1f\\x00\\x91\\x17\\x1f\\x161\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-06-20T00:00:00", "modifydate": "1991-06-20T16:31:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL FSRTNR SUPPLY.\n&NAME   @FSR   &DUMMY\n.*\n.* @FSR MACRO : CALL FSRTNR SUPPLY (SEE FSRTN).\n.* ------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n&NAME    L     15,=V(FSRTNR)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FSRC": {"ttr": 7946, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x934/\\x00\\x934/\\x165\\x00\\x83\\x00\\x83\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-12-08T00:00:00", "modifydate": "1993-12-08T16:35:00", "lines": 131, "newlines": 131, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           CALL FSRTNA SUPPLY.\n&NAME   @FSRC  &A,&B,&MF=\n         LCLA  &Y,&Z\n         LCLB  &W\n         LCLC  &X\n.* @FSRC MACRO : CALL FSRTNA SUPPLY (SEE FSRTN).\n.* -------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n         AIF   (N'&SYSLIST GT 2).BAD\n&W       SETB  0\n         AIF   ('&MF' EQ '').XI1\n         AIF   ('&MF' EQ 'E').XI1\n         AIF   ('&MF' NE 'L').XL1\n         AIF   (N'&SYSLIST EQ 0).LS11\n&Z       SETA  1\n         AIF   ('&NAME' EQ '').LS1\n&NAME    DS    0F\n.LS1     AIF   (N'&SYSLIST EQ &Z).LS10\n         AIF   (T'&SYSLIST(&Z) EQ 'O').LS2\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .LS3\n.LS2     DC    A(0)                P.P. PARAMETER.\n.LS3     ANOP\n&Z       SETA  &Z+1\n         AGO   .LS1\n.LS10    AIF   (T'&SYSLIST(&Z) EQ 'O').LS12\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').REG\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         MEXIT\n.LS11    ANOP\n&NAME    DC    A(0)                P.P. PARAMETER.\n.LS12    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         MEXIT\n.XL1     AIF   ('&MF(1)' NE 'L').XL2\n         AIF   ('&MF(2)' EQ '').ERR\n&W       SETB  1\n         AGO   .XL3\n.XL2     AIF   ('&MF(1)' NE 'E').ERR\n         AIF   ('&MF(2)' EQ '').XI1\n.XL3     AIF   ('&MF(2)'(1,1) EQ '(').XL4\n&NAME    LA    1,&MF(2)\n         AGO   .XL10\n.XL4     AIF   ('&MF(2)' NE '(1)').XL5\n         AIF   ('&NAME' EQ '').XL10\n&NAME    DS    0H\n         AGO   .XL10\n.XL5     ANOP\n&Y       SETA  K'&MF(2)-2\n&X       SETC  '&MF(2)'(2,&Y)\n&NAME    LR    1,&X\n.XL10    AIF   (N'&SYSLIST EQ 0).XL21\n&Y       SETA  0\n&Z       SETA  1\n.XL11    AIF   (T'&SYSLIST(&Z) EQ 'O').XL14\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XL12\n         LA    15,&SYSLIST(&Z)\n         ST    15,&Y.(1)           STORE INTO PARM. LIST.\n         AGO   .XL13\n.XL12    ST    &SYSLIST(&Z,1),&Y.(1)    STORE INTO PARM. LIST.\n.XL13    AIF   (N'&SYSLIST EQ &Z).XL20\n         AGO   .XL15\n.XL14    AIF   (N'&SYSLIST EQ &Z).XL21\n.XL15    ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XL11\n.XL20    OI    &Y.(1),X'80'        SET LAST WORD BIT ON.\n.XL21    AIF   (&W).XL22\n         L     15,=V(FSRTNA)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n.XL22    MEXIT\n.XI1     AIF   (N'&SYSLIST EQ 0).NL1\n         AIF   (T'&A EQ 'O' AND T'&B EQ 'O').NL1\n&Y       SETA  0\n&Z       SETA  1\n&X       SETC  'IHB'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').XI2\n&NAME    DS    0H\n.XI2     AIF   (T'&SYSLIST(&Z) EQ 'O').XI3\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI4\n.XI3     AIF   (N'&SYSLIST EQ &Z).XI7\n         AGO   .XI5\n.XI4     ST    &SYSLIST(&Z,1),&X+&Y     STORE INTO PARM. LIST.\n         AIF   (N'&SYSLIST EQ &Z).XI6\n.XI5     ANOP\n&Y       SETA  &Y+4\n&Z       SETA  &Z+1\n         AGO   .XI2\n.XI6     OI    &X+&Y,X'80'         SET LAST WORD BIT ON.\n.XI7     LA    1,&X                LOAD LIST ADDRESS IN REG. 1.\n         B     &X.A                BYPASS LIST.\n         CNOP  0,4\n&X       DS    0F\n&Z       SETA  1\n.XI10    AIF   (N'&SYSLIST EQ &Z).XI13\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI11\n         AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI11\n         DC    A(&SYSLIST(&Z))     P.P. PARAMETER.\n         AGO   .XI12\n.XI11    DC    A(0)                P.P. PARAMETER.\n.XI12    ANOP\n&Z       SETA  &Z+1\n         AGO   .XI10\n.XI13    AIF   ('&SYSLIST(&Z)'(1,1) EQ '(').XI15\n         AIF   (T'&SYSLIST(&Z) EQ 'O').XI14\n         DC    A(&SYSLIST(&Z)+X'80000000')   LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI14    DC    A(X'80000000')      LAST P.P. PARAMETER.\n         AGO   .XI16\n.XI15    DC    A(0)                LAST P.P. PARAMETER.\n.XI16    ANOP\n&X.A     L     15,=V(FSRTNA)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.NL1     ANOP\n&NAME    XR    1,1                 NO PARM. LIST.\n         L     15,=V(FSRTNA)       LOAD REG. 15 WITH ENTRY.\n         BASR  14,15               BRANCH TO ENTRY POINT.\n         MEXIT\n.BAD     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.REG     MNOTE 8,' REGISTER NOTATION INVALID ************************ '\n         MEXIT\n.ERR     MNOTE 8,' MF= INVALID CODING ******************************* '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FST": {"ttr": 7949, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x934\\x0f\\x00\\x934\\x0f\\x12$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-12-06T00:00:00", "modifydate": "1993-12-06T12:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           DEFINE FSRTN TERMINAL ATTRIBUTES SUPPLY.\n&NAME   @FST   &DUMMY\n.*\n.* @FST MACRO : DEFINE FSRTN TERMINAL ATTRIBUTES SUPPLY (SEE FSRTN).\n.* ------------\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n&NAME    DC    XL8'0'\nFSPRMSZE EQU   &NAME+0,2           PRIMARY (DEFAULT) SCREEN SIZE\nFSPRMROW EQU   &NAME+0,1                ROWS\nFSPRMCOL EQU   &NAME+1,1                COLUMNS\nFSALTSZE EQU   &NAME+2,2           ALTERNATE SCREEN SIZE\nFSALTROW EQU   &NAME+2,1                ROWS\nFSALTCOL EQU   &NAME+3,1                COLUMNS\nFSATTRIB EQU   &NAME+4,4           TERMINAL ATTRIBUTES\nFSATTRB0 EQU   &NAME+4,1                BYTE 0 - RESERVED\nFSATTRB1 EQU   &NAME+5,1                BYTE 1 - RESERVED\nFSATTRB2 EQU   &NAME+6,1                BYTE 2 - RESERVED\nFSATTRB3 EQU   &NAME+7,1                BYTE 3\nFSTASCII EQU   X'02'               DEVICE SUPPORTS : 1=ASCII, 0=EBCDIC\nFSTQUERY EQU   X'01'               READ PARTITION (QUERY) IS SUPPORTED\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALLOCGD$": {"ttr": 7951, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14!\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:21:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//ALLOCGDG JOB (........),'INSTALL - ALLOCGDG -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                GDGALLR                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=ALLOCGDG\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  INCLUDE SYSADD(GDGALLR)\n  ENTRY   ALLOCGDG\n  NAME    ALLOCGDG(R)\n/*\n//HLP     EXEC PAJHELP,MBR=ALLOCGDH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALLOCGD@": {"ttr": 7953, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12_\\x00\\x94\\x12_\\x166\\x007\\x007\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-05T00:00:00", "modifydate": "1994-05-05T16:36:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "SYSPAJA"}, "text": "1   05/10/90\n                                                      ALLOCGDG  1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        ALLOCGDG TSO command         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Command name :      ALLOCGDG\n  Function :          GDG data-set dynamic allocation TSO-command.\n                      This TSO command processor allocates dynamically\n                      a generation data group member expressed with the\n                      the relative generation data-set number to a\n                      specified DDNAME (the data-set is allocated with\n                      DISP=SHR).\n\n  Syntax :\n  --------------------------------------------------------------------\n  Command    Operands\n  --------------------------------------------------------------------\n  ALLOCGDG   FILE('DDNAME')  DSNAME('GDG DATA-SET NAME')  NOLIST/LIST\n  --------------------------------------------------------------------\n\n  Operands :\n     Required - FILE and DSNAME (user prompted if omited)\n     Optional - LIST or NOLIST\n     Default  - NOLIST\n\n     FILE('DDNAME') = 'DDNAME' is the DDname to which you wish allocate\n                        the 'GDG DATA-SET NAME'.\n                   Aliases : FI, F, DDNAME, DDN or DD\n\n     DSNAME('GDG DATA-SET NAME') = 'GDG DATA-SET NAME' is the generation\n                        data group member expressed with the relative\n                        generation number.\n                        E.g. : DSNAME('ZULU.TEST.DATA(+0)')\n                        If the 'GDG DATA-SET NAME' is not quoted, then\n                        the profile prefix will be appended.\n                        E.g. : DSNAME(TEST.DATA(-1))\n                   Aliases : DSN, DATASET, DS or DA.\n                        Note : the data-set is always allocated with\n                               DISP=SHR.\n\n     Option = the messages option :\n                   NOLIST = no error message(s) will be displayed, only\n                        the return code (&LASTCC) is set.\n                        Aliases : NL, NOMSG, NM or N.\n                   LIST = full error message(s) will be displayed.\n                        Aliases : L, MSG or M.\n\n  Return codes :   0 - GDG successfully allocated\n                   8 - Syntax error or missing operand\n                  12 - GDG allocation failed\n                  16 - All other errors (message sent)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALLOCGDG": {"ttr": 7955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x11\\x1f\\x00\\x94\\x11\\x1f\\x16V\\x02\\x05\\x02\\x05\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-21T00:00:00", "modifydate": "1994-04-21T16:56:00", "lines": 517, "newlines": 517, "modlines": 0, "user": "SYSPAJA"}, "text": "AGDG     TITLE 'ALLOCGDG -- GDG DYNAMIC ALLOCATION TSO-COMMAND.'\nALLOCGDG START 0\n         SPACE 1\n*--------------------------------------------------------------------*\n*                          A L L O C G D G                           *\n*--------------------------------------------------------------------*\n* NAME :       ALLOCGDG                                              *\n* ATTRIBUTES : RENT                                                  *\n* AUTHOR :     MOINIL P.A.                                           *\n*              COMPUTING CENTRE (TP 361)                             *\n*              J.R.C. - ISPRA ESTABLISHMENT                          *\n*              21020 ISPRA (VA), ITALY                               *\n*--------------------------------------------------------------------*\n         SPACE 1\n*  COMMAND     OPERANDS\n*  --------    ------------------------------------------------------\n*  ALLOCGDG    FILE('DDNAME')  DSNAME('GDG DATA-SET NAME') NOLIST\n*                                                          LIST\n*  OPERANDS :\n*  ----------\n*  1. REQUIRED :\n*        FILE('DDNAME') = 'DDNAME' IS THE DDNAME TO WHICH YOU WISH\n*                  ALLOCATE THE 'GDG DATA-SET NAME'.\n*             ALIASES : FI, F, DDNAME, DDN OR DD.\n*        DSNAME('GDG DATA-SET NAME') = 'GDG DATA-SET NAME' IS THE\n*                  GENERATION DATA GROUP MEMBER EXPRESSED WITH THE\n*                  RELATIVE GENERATION NUMBER.\n*                  I.E. : DA('ZULU.TEST.DATA(+0)')\n*                  IF THE 'GDG DATA-SET NAME' IS NOT QUOTED, THEN THE\n*                  PROFILE PREFIX WILL BE APPENDED.\n*                  I.E. : DA(TEST.DATA(-1))\n*             ALIASES : DSN, DATASET, DS OR DA.\n*             NOTE : THE DATA-SET IS ALWAYS ALLOCATED WITH DISP=SHR.\n*  2. OPTIONAL (KEYWORDS) :\n*        NOLIST = NO ERROR MESSAGE(S) WILL BE DISPLAYED, ONLY THE\n*                  RETURN CODE (&LASTCC) IS SET.\n*             ALIASES : NL, NOMSG, NM OR N.\n*        LIST = FULL ERROR MESSAGE(S) WILL BE DISPLAYED.\n*             ALIASES : L, MSG OR M.\n*\n*  RETURN CODES :   0 - GDG SUCCESSFULLY ALLOCATED\n*  --------------   8 - SYNTAX ERROR OR MISSING OPERAND\n*                  12 - GDG ALLOCATION FAILED\n*                  16 - ALL OTHER ERRORS (MESSAGE SENT)\n         SPACE 1\nALLOCGDG AMODE 24\nALLOCGDG RMODE 24\n         PRINT NOGEN\n         SPACE 1\n        $DEFREG\n        $XENT  BASE=(R11,R12),LV=WKLEN,TYPE=RENT\n         EJECT\n         LR    R9,R13\n         USING WKAREA,R9\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE,                       X\n               GET=GETLNE,REL=RELGIB,SCAN=YES\n         MVI   SWITCH,0\n         USING CPPL,R2             CPPL ADDRESSABILITY\n         L     R3,CPPLUPT          UPT ADDRESS\n         USING UPT,R3\n         TM    UPTSWS,UPTNPRM      NOPROMPT ?\n         BZ    *+L'*+4             NO\n         OI    SWITCH,SWNPRM       YES, RETAIN INFO\n         MVI   PRFXL,0             GET CURRENT PREFIX IF ANY\n         MVC   PRFX,=CL8' '          ELSE GET THE CURRENT USER-ID\n         XR    R1,R1\n         IC    R1,UPTPREFL\n         LTR   R1,R1\n         BNP   GTUSID\n         STC   R1,PRFXL            PREFIX LENGTH\n         BCT   R1,*+L'*+6\n         MVC   PRFX(*-*),UPTPREFX  <<EXECUTED>>\n         EX    R1,*-6              PREFIX\n         DROP  R3\n         B     HCOPNDS\nGTUSID   L     R3,CPPLPSCB         PSCB ADDRESS\n         USING PSCB,R3\n         MVC   PRFXL,PSCBUSRL      USER-ID LENGTH\n         MVC   PRFX(L'PSCBUSER),PSCBUSER USER-ID\n         DROP  R2,R3\nHCOPNDS  MVC   DDNME,=CL8' '\n         MVI   DSNME,C' '\n         MVC   DSNME+1(L'DSNME-1),DSNME\n         OC    #TSIBSP(3*L'#TSIBSP),#TSIBSP COMMAND SCAN POINTERS ?\n         BZ    NOPNDS              +0 - NO OPERANDS\nNXTOPND  TM    SWITCH,SWRENT       +4 - REENTERED OPERAND ?\n         BO    FRIBF               YES\n         BAS   R14,GTOPND          GET AN OPERAND\n         B     EORTLO              +0 - END OR TOO LONG\n         LR    R6,R1               +4 - RETAIN LAST POSITION\n         LA    R1,WKLINE           OPERAND IS IN WKLINE\n         CLC   0(5,R1),=CL5'FILE(' SO NOW CHECK WHICH ONE\n         BE    FIDD5\n         CLC   0(3,R1),=CL3'FI('\n         BE    FIDD3\n         CLC   0(2,R1),=CL2'F('\n         BE    FIDD2\n         CLC   0(7,R1),=CL7'DDNAME('\n         BE    FIDD7\n         CLC   0(4,R1),=CL4'DDN('\n         BE    FIDD4\n         CLC   0(3,R1),=CL3'DD('\n         BE    FIDD3\n         CLC   0(7,R1),=CL7'DSNAME('\n         BE    DSDA7\n         CLC   0(4,R1),=CL4'DSN('\n         BE    DSDA4\n         CLC   0(3,R1),=CL3'DS('\n         BE    DSDA3\n         CLC   0(8,R1),=CL8'DATASET('\n         BE    DSDA8\n         CLC   0(3,R1),=CL3'DA('\n         BE    DSDA3\n         CLC   0(7,R1),=CL7'NOLIST '\n         BE    NLNM7\n         CLC   0(3,R1),=CL3'NL '\n         BE    NLNM3\n         CLC   0(6,R1),=CL6'NOMSG '\n         BE    NLNM6\n         CLC   0(3,R1),=CL3'NM '\n         BE    NLNM3\n         CLC   0(2,R1),=CL2'N '\n         BE    NLNM2\n         CLC   0(5,R1),=CL5'LIST '\n         BE    LSMS5\n         CLC   0(2,R1),=CL2'L '\n         BE    LSMS2\n         CLC   0(4,R1),=CL4'MSG '\n         BE    LSMS4\n         CLC   0(2,R1),=CL2'M '\n         BE    LSMS2\n         MVC   2(11,R6),=CL11'??? UNKNOWN'\n         LA    R0,L'WKLINE+L'WKLREQ\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     NXTOPND             +0 - CONTINUE\n         B     SETRC               +4 - INVALID OR ERROR\nDUPLOP   MVC   2(12,R6),=CL12'??? REPEATED'\n         LA    R0,L'WKLINE+L'WKLREQ\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     NXTOPND             +0 - CONTINUE\n         B     SETRC               +4 - INVALID OR ERROR\nERRSOP   LR    R6,R1               RETAIN POSITION\n         LA    R0,L'WKLINE+L'WKLREQ\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     *+L'*+4             +0 - CONTINUE\n         B     SETRC               +4 - INVALID OR ERROR\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE+L'WKLREQ-1),WKLINE\n         MVC   0(18,R6),=CL18'$---> SYNTAX ERROR'\n         LA    R0,L'WKLINE+L'WKLREQ\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     NXTOPND             +0 - CONTINUE\n         B     SETRC               +4 - INVALID OR ERROR\nFIDD7    LA    R1,2(R1)            FILE OPERAND PROCESS\nFIDD5    LA    R1,1(R1)\nFIDD4    LA    R1,1(R1)\nFIDD3    LA    R1,1(R1)\nFIDD2    LA    R1,2(R1)\n         CLI   DDNME,C' '\n         BNE   DUPLOP              ALREADY SPECIFIED OPERAND\nFIDDS    LR    R5,R1               RETAIN START ADDRESS OF DDNAME\n         LA    R0,1\n         LA    R2,L'TCHARS1\n         LA    R3,TCHARS1\n         BAS   R14,CHKCHRS         CHECK FIRST CHARACTER OF DDNAME\n         B     ERRSOP              +0 = ERROR, SYNTAX ERROR\n         LA    R0,7                +4 = OK FIRST\n         LA    R2,L'TCHARS1+L'TCHARS2+L'TCHARS3\n         BAS   R14,CHKCHRS         CHECK NEXT CHARACTERS OF DDNAME\n         NOP   0                   +0 = ERROR OR END\n         TM    SWITCH,SWRENT       +4 = OK ALL NEXT, REENTERED ?\n         BZ    *+L'*+6             NO\n         LR    R2,R1\n         B     *+L'*+14\n         CLI   0(R1),C')'          CHECK FOR )\n         BNE   ERRSOP              NO, SYNTAX ERROR\n         LR    R2,R1\n         LA    R1,1(R1)\n         CLI   0(R1),C' '          CHECK FOR BLANK\n         BNE   ERRSOP              NO, SYNTAX ERROR\n         SLR   R2,R5\n         BCT   R2,*+L'*+6\n         MVC   DDNME(*-*),0(R5)    <<EXECUTED>>\n         EX    R2,*-6\n         B     NXTOPND\nDSDA8    LA    R1,1(R1)            DSNAME OPERAND PROCESS\nDSDA7    LA    R1,3(R1)\nDSDA4    LA    R1,1(R1)\nDSDA3    LA    R1,3(R1)\n         CLI   DSNME,C' '\n         BNE   DUPLOP              ALREADY SPECIFIED OPERAND\nDSDAS    NI    SWITCH,255-SWPNRQ   SET PREFIX REQUESTED\n         CLI   0(R1),C''''         QUOTED DSNAME ?\n         BNE   *+L'*+8             NO\n         OI    SWITCH,SWPNRQ       YES, SET PREFIX NOT REQUESTED\n         LA    R1,1(R1)\n         LR    R5,R1               RETAIN START ADDRESS OF DSNAME\nDSDAL    LA    R0,1\n         LA    R2,L'TCHARS1+L'TCHARS2\n         LA    R3,TCHARS1\n         BAS   R14,CHKCHRS         CHECK FIRST CHARACTER OF DSNAME\n         B     ERRSOP              +0 = ERROR, SYNTAX ERROR\n         LA    R0,7                +4 = OK FIRST\n         LA    R2,L'TCHARS1+L'TCHARS2+L'TCHARS3\n         BAS   R14,CHKCHRS         CHECK NEXT CHARACTERS OF DSNAME\n         NOP   0                   +0 = ERROR OR END\n         CLI   0(R1),C'('          +4 = OK ALL NEXT, CHECK FOR (\n         BE    DSDAG               YES, IT IS\n         CLI   0(R1),C'.'          IS IT A PERIOD ?\n         BNE   ERRSOP              NO, SYNTAX ERROR\n         LA    R1,1(R1)            YES, BUMP POINTER AND LOOP\n         B     DSDAL\nDSDAG    LA    R1,1(R1)\n         CLI   0(R1),C'+'\n         BE    *+L'*+8\n         CLI   0(R1),C'-'\n         BNE   *+L'*+4\n         LA    R1,1(R1)\n         LA    R0,1\n         LA    R2,L'TCHARS3\n         LA    R3,TCHARS3\n         BAS   R14,CHKCHRS         CHECK FIRST OF GENERATION NUMBER\n         B     ERRSOP              +0 = ERROR, SYNTAX ERROR\n         LA    R0,7                +4 = OK FIRST\n         BAS   R14,CHKCHRS         CHECK NEXT OF GENERATION NUMBER\n         NOP   0                   +0 = ERROR OR END\n         CLI   0(R1),C')'          +4 = OK ALL NEXT, CHECK FOR )\n         BNE   ERRSOP              NO, SYNTAX ERROR\n         LA    R1,1(R1)\n         LR    R2,R1\n         TM    SWITCH,SWPNRQ       PREFIX REQUESTED ?\n         BZ    *+L'*+12            YES\n         CLI   0(R1),C''''         NO, CHECK QUOTED DSNAME ?\n         BNE   ERRSOP              NO, SYNTAX ERROR\n         LA    R1,1(R1)\n         TM    SWITCH,SWRENT       REENTERED OPERAND ?\n         BO    *+L'*+12            YES\n         CLI   0(R1),C')'          NO, CHECK FOR )\n         BNE   ERRSOP              NO, SYNTAX ERROR\n         LA    R1,1(R1)\n         CLI   0(R1),C' '          CHECK FOR BLANK\n         BNE   ERRSOP              NO, SYNTAX ERROR\n         LA    R4,DSNME\n         TM    SWITCH,SWPNRQ       PREFIX NOT REQUESTED ?\n         BZ    *+L'*+8             NO, ADD IT\n         SLR   R2,R5               YES\n         LR    R0,R2\n         B     DSDAN\n         XR    R3,R3\n         IC    R3,PRFXL\n         BCT   R3,*+L'*+6\n         MVC   0(*-*,R4),PRFX      <<EXECUTED>>\n         EX    R3,*-6\n         LA    R4,1(R3,R4)\n         MVI   0(R4),C'.'\n         LA    R4,1(,R4)\n         SLR   R2,R5\n         LA    R0,2(R3,R2)\nDSDAN    CH    R0,=Y(L'DSNME)\n         BNH   DSDAM\nOPNTL    MVC   2(12,R6),=CL12'??? TOO LONG'\n         LA    R0,L'WKLINE+L'WKLREQ\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     NXTOPND             +0 - CONTINUE\n         B     SETRC               +4 - INVALID OR ERROR\nDSDAM    BCT   R2,*+L'*+6\n         MVC   0(*-*,R4),0(R5)     <<EXECUTED>>\n         EX    R2,*-6\n         B     NXTOPND\nNLNM7    LA    R1,1(R1)            NOLIST OPERAND PROCESS\nNLNM6    LA    R1,3(R1)\nNLNM3    LA    R1,1(R1)\nNLNM2    LA    R1,2(R1)\n         TM    SWITCH,SWOPTK       OPTION ALREADY ENCOUNTERED ?\n         BO    OPTCFL              YES\n         NI    SWITCH,255-SWLSMS   RESET LIST/MSG\n         OI    SWITCH,SWOPTK       SET OPTION ENCOUNTERED\n         B     NXTOPND\nLSMS5    LA    R1,1(R1)            LIST OPERAND PROCESS\nLSMS4    LA    R1,2(R1)\nLSMS2    LA    R1,2(R1)\n         TM    SWITCH,SWOPTK       OPTION ALREADY ENCOUNTERED ?\n         BO    OPTCFL              YES\n         OI    SWITCH,SWLSMS+SWOPTK SET LIST/MSG + OPTION ENCOUNTERED\n         B     NXTOPND\nOPTCFL   MVC   2(28,R6),=CL28'??? OPTION CONFLICT, IGNORED'\n         LA    R0,L'WKLINE+L'WKLREQ\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     NXTOPND             +0 - CONTINUE\n         B     SETRC               +4 - INVALID OR ERROR\nNOPNDS   MVC   WKLINE(25),=CL25'NO OPERANDS (ALL MISSING)'\n         LA    R0,25\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     CHKDDN              +0 - CONTINUE\n         B     SETRC               +4 - INVALID OR ERROR\nEORTLO   LR    R6,R1               RETAIN LAST POSITION\n         LTR   R0,R0\n         BZ    OPNTL               OPERAND TOO LONG\nFRIBF    TM    SWITCH,SWRENT       REENTERED OPERAND ?\n         BZ    CHKDDN              NO\n         NI    SWITCH,255-SWRENT   RESET\n         BAS   R14,RELGIB          RELEASE BUFFER\n         LTR   R15,R15\n         BZ    CHKDDN\n         TM    SWITCH,SWLSMS       LIST/MSG REQUESTED ?\n         BZ    CHKDDN              NO\n         MVC   WKLINE(33),=CL33'NOT ALL VIRTUAL STORAGE IS FREED'\n         MVC   WKLINE+33(14),=CL14'(FREEMAIN R15='\n         ST    R15,DBLWRD\n         UNPK  WKLINE+47(9),DBLWRD(5)\n         TR    WKLINE+47(8),TBHEX\n         MVI   WKLINE+55,C')'\n         LA    R0,56\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     CHKDDN              +0 - CONTINUE\n         B     SETRC               +4 - INVALID OR ERROR\nCHKDDN   CLI   DDNME,C' '          DDNAME OK ?\n         BNE   CHKDSN              YES\n         TM    SWITCH,SWNPRM       NO, PROMPTING ALLOWED ?\n         BO    XRC08               NO, EXIT\n         MVC   WKLINE(20),=CL20' -- ENTER DDNAME OR'\n         MVC   WKLINE+20(20),=CL20'JUST ENTER TO EXIT :'\n         LA    R0,40\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     *+L'*+4             +0 - CONTINUE\n         B     SETRC               +4 - INVALID OR ERROR\n         BAS   R14,GETLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     *+L'*+8             +0 - CONTINUE\n         B     XRC08               +4 - NONE, EXIT\n         B     SETRC               +8 - ERROR\n         BAS   R14,GTOPND          GET OPERAND\n         NOP   0                   +0 - TOO LONG\n         LA    R1,WKLINE           +4 - OPERAND IS IN WKLINE\n         OI    SWITCH,SWRENT       SET REENTERED OPERAND\n         B     FIDDS\nCHKDSN   CLI   DSNME,C' '          DSNAME OK ?\n         BNE   XGDGAL              YES\n         TM    SWITCH,SWNPRM       NO, PROMPTING ALLOWED ?\n         BO    XRC08               NO, EXIT\n         MVC   WKLINE(31),=CL31' -- ENTER GDG DATA-SET NAME OR'\n         MVC   WKLINE+31(20),=CL20'JUST ENTER TO EXIT :'\n         LA    R0,51\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     *+L'*+4             +0 - CONTINUE\n         B     SETRC               +4 - INVALID OR ERROR\n         BAS   R14,GETLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     *+L'*+8             +0 - CONTINUE\n         B     XRC08               +4 - NONE, EXIT\n         B     SETRC               +8 - ERROR\n         BAS   R14,GTOPND          GET OPERAND\n         NOP   0                   +0 - TOO LONG\n         LA    R1,WKLINE           +4 - OPERAND IS IN WKLINE\n         OI    SWITCH,SWRENT       SET REENTERED OPERAND\n         B     DSDAS\nXGDGAL   LA    R1,PARMLST          ALLOCATE GDG\n         LA    R15,DDNME\n         ST    R15,0(R1)\n         LA    R15,DSNME\n         ST    R15,4(R1)\n         OI    4(R1),X'80'         SET VL\n         L     R15,=V(GDGALLR)\n         BASR  R14,R15\n         TM    SWITCH,SWLSMS       LIST/MSG REQUESTED ?\n         BZ    TSTRC               NO\n         STM   R15,R0,DBLWRD\n         BCTR  R1,0\n         XR    R14,R14\n         IC    R14,0(R1)\n         BCT   R14,*+L'*+6\n         MVC   WKLINE(*-*),1(R1)   <<EXECUTED>>\n         EX    R14,*-6\n         LTR   R0,R0\n         BZ    NOSCC\n         LA    R15,WKLINE+1(R14)\n         MVC   0(5,R15),=CL5' (R0='\n         UNPK  5(9,R15),DBLWRD+4(5)\n         TR    5(8,R15),TBHEX\n         MVI   13(R15),C')'\n         LA    R14,14(R14)\nNOSCC    LA    R0,1(R14)\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     *+L'*+4             +0 - CONTINUE\n         B     SETRC               +4 - INVALID OR ERROR\n         L     R15,DBLWRD\nTSTRC    LTR   R15,R15\n         BZ    LEAVE               SET RC=0 ----------------------   0\n         LA    R15,12              SET RC=12 ---------------------  12\n         B     LEAVE\nXRC08    LA    R15,8               SET RC=8 ----------------------   8\n         B     LEAVE\nSETRC    LA    R15,16              SET RC=16 ---------------------  16\nLEAVE   $XRET  CC=(R15),LV=WKLEN,TYPE=RENT\n         EJECT\n*------- GTOPND - GET AN OPERAND ROUTINE.\n*              R0-R4 : WORK REGISTERS.\n*              R14 : LINK REGISTER.\n* ON ENTRY --- #TSIBSP = SCAN BUFFER POINTERS.\n* ON EXIT ---- #TSIBSP = CURRENT SCAN BUFFER POINTERS ARE SAVED.\n*              RETURN = +0 - NO OPERAND IF R0 IS NON-ZERO, OR\n*                            OPERAND TOO LONG IF R0 IS ZERO (REST OF\n*                            OPERAND IS SKIPED)\n*              RETURN = +4 - NORMAL.\n*                            WKLINE = OPERAND IS UPPER-CASE.\n*                            R1 : POINTS TO LAST CHARACTER OF OPERAND\n*                                 IN WKLINE.\n         SPACE 1\nGTOPND   MVI   WKLINE,C' '         RESET TO BLANKS\n         MVC   WKLINE+1(L'WKLINE+L'WKLREQ-1),WKLINE\n         LA    R1,WKLINE\n         LA    R0,L'WKLINE\n         LM    R2,R4,#TSIBSP       GET SCAN POINTERS\n         CLR   R4,R3\n         BHR   R14                 NONE OR EXHAUSTED, RETURN TO CALLER\n         CLI   0(R4),C' '\n         BNE   GTOPNDL\n         BXLE  R4,R2,*-8\n         B     GTOPNDX+L'GTOPNDX   NONE, RETURN TO CALLER\nGTOPNDN  BCT   R0,GTOPNDC\n         CLI   0(R4),C' '          TOO LONG, SKIP REST OF OPERAND\n         BE    GTOPNDX+L'GTOPNDX     AND RETURN TO CALLER\n         BXLE  R4,R2,*-8\n         B     GTOPNDX+L'GTOPNDX\nGTOPNDC  CLI   0(R4),C' '\n         BE    GTOPNDX\n         LA    R1,1(R1)\nGTOPNDL  OC    0(1,R1),0(R4)\n         BXLE  R4,R2,GTOPNDN\nGTOPNDX  LA    R14,4(R14)          SET NORMAL RETURN\n         STM   R2,R4,#TSIBSP       SET SCAN POINTERS\n         BR    R14                 RETURN TO CALLER\n         EJECT\n*------- CHKCHRS - CHECK CHARACTERS ROUTINE.\n*              R0-R4 : WORK REGISTER.\n*              R15 : WORK REGISTER.\n*              R14 : LINK REGISTER.\n* ON ENTRY --- R0 : NUMBER OF CHRACTERS TO TEST.\n*              R1 : START STRING ADDRESS.\n*              R2 : CHARACTERS TABLE LENGTH.\n*              R3 : CHARACTERS TABLE ADDRESS.\n* ON EXIT ---- RETURN = +0 - ERROR, STRING NOT EXHAUSTED.\n*                            R1 : POINTS TO THE WRONG CHARACTER.\n*              RETURN = +4 - NORMAL, ALL OK, STRING EXHAUSTED.\n*                            R1 : POINTS TO THE NEXT CHARACTER.\n         SPACE 1\nCHKCHRS  LR    R4,R3\n         LR    R15,R2\nCHKCHRST CLC   0(1,R1),0(R4)       CHECK CHARACTERS\n         BE    CHKCHRSN\n         BCT   R15,*+L'*+2\n         BR    R14                 ERROR, RETURN TO CALLER\n         LA    R4,1(R4)\n         B     CHKCHRST\nCHKCHRSN LA    R1,1(R1)\n         BCT   R0,CHKCHRS\n         B     4(R14)              ALL OK, RETURN TO CALLER\n         EJECT\n*------- CONSTANTS, DSECT'S, ETC...\n         SPACE 1\nTCHARS1  DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nTCHARS2  DC    C'$#@'\nTCHARS3  DC    C'0123456789',C'ABCDEF'\nTBHEX    EQU   TCHARS3-X'F0'\n         SPACE 1\n        LTORG\n         EJECT\nWKAREA   DSECT\n         DS    18F            FIRST S.A.\n         SPACE 1\nDBLWRD   DS    D\n         SPACE 1\n        $TEW$WA\n         SPACE 1\nPARMLST  DS    2F             GDGALLR PARM LIST\nDDNME    DS    CL8\nDSNME    DS    CL54\n         SPACE 1\nPRFX     DS    CL8\nWKLINE   DS    CL60\nWKLREQ   DS    CL18\nPRFXL    DS    XL1\nSWITCH   DS    XL1\nSWNPRM   EQU   X'80'               NOPROMPT STATUS (PROFILE)\nSWLSMS   EQU   X'40'               LIST/MSG REQUESTED\nSWPNRQ   EQU   X'20'               PREFIX NOT REQUESTED\nSWOPTK   EQU   X'10'               OPTION KEY PROCESSED\nSWRENT   EQU   X'08'               REENTER PROCESS\n         SPACE 1\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8\n         SPACE 1\n        $TEW$DS\n        IKJUPT\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALLOCGDH": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12_\\x00\\x94\\x12_\\x166\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-05T00:00:00", "modifydate": "1994-05-05T16:36:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=ALLOCGDG\n./     NUMBER  NEW1=100,INCR=100\n)F Function :  GDG data-set dynamic allocation TSO-command.\n               This TSO command processor allocates dynamically a\n               generation data group member expressed with the relative\n               generation data-set number to a specified DDNAME (the\n               data-set is allocated with DISP=SHR).\n)X Syntax :    ALLOCGDG  FILE('DDNAME')  DSNAME('GDG DATA-SET NAME')\n                        NOLIST/LIST\n               Required : FILE and DSNAME (user prompted if omited)\n               Optional : LIST or NOLIST (default is NOLIST)\n               Return codes (&LASTCC value) :\n                   0 - GDG successfully allocated\n                   8 - Syntax error or missing operand\n                  12 - GDG allocation failed\n                  16 - All other errors (message sent)\n)O Operands :\n))FILE('DDNAME') : 'DDNAME' is the DDname to which you wish allocate\n               the 'GDG DATA-SET NAME'.\n               Aliases : FI, F, DDNAME, DDN or DD\n))DSNAME('GDG DATA-SET NAME') = 'GDG DATA-SET NAME' is the generation\n               data group member expressed with the relative generation\n               number.\n               E.g. : DSNAME('ZULU.TEST.DATA(+0)')\n               If the 'GDG DATA-SET NAME' is not quoted, then the\n               profile prefix will be appended.\n               E.g. : DSNAME(TEST.DATA(-1))\n               Aliases : DSN, DATASET, DS or DA.\n               Note : the data-set is always allocated with DISP=SHR.\n))Option :     The messages option :\n               NOLIST = no error message(s) will be displayed, only the\n                        return code (&LASTCC) is set.\n                        Aliases : NL, NOMSG, NM or N.\n               LIST = full error message(s) will be displayed.\n                        Aliases : L, MSG or M.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AUTHC": {"ttr": 8203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x11/\\x00\\x94\\x11/\\tQ\\x00\\x8d\\x00\\x8d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-22T00:00:00", "modifydate": "1994-04-22T09:51:00", "lines": 141, "newlines": 141, "modlines": 0, "user": "SYSPAJA"}, "text": "AUTH     TITLE 'TSO - COMMAND AUTHORIZATION INTERFACE.'\nAUTHC    START 0\n         SPACE 1\n* PURPOSE :    EXECUTE AN AUTHORIZED TSO-COMMAND (ONLY SYSTEM GROUP\n* ---------    USER-ID'S ALLOWED).\n*\n* COMMAND SYNTAX : AUTHC ...COMMAND...\n* ---------------- I.E. - AUTHC  CALL  'SYS1.LINKLIB(IEHDASDR)'\n*\n* AUTHOR :     RAVARANI N. - MOINIL P.A.\n* --------     COMPUTING CENTRE (TP 361)\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nLV0      EQU   0         REJECT LEVEL.\n         SPACE 1\n        $MDL@IX\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R11,R13             SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R11\n         XR    R10,R10             C.C. = 0.\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE,SCAN=YES\n         USING CPPL,R2             SET CPPL ADDRESSABILITY.\n         XC    REQAUT(REQAUTL),REQAUT\n         MVC   REQAUT+1(3),=AL3(MDL@IX)\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n        $EACM  REQAUT\n         CLI   AUTH,LV0            AUTHORIZED?\n         BE    NOTAUT              NO.\n         SPACE 1\n*------- HANDLE COMMAND.\n         SPACE 1\n         OC    #TSIBSP(3*L'#TSIBSP),#TSIBSP OPERAND MISSING?\n         BZ    OPMISS              YES.\n         MVI   TEXT,C' '           INITIALIZE NEW BUFFER.\n         MVC   TEXT+1(L'TEXT-1),TEXT\n         MVC   COMMAND(L'COMMAND),TEXT\n         LM    R4,R6,#TSIBSP       GET SCAN POINTERS\n         LR    R1,R5\n         SLR   R1,R6\n         EX    R1,MOVETXT          MOVE NEW CBUF TEXT.\n         ALR   R1,R4\n         STH   R1,CBUF             SET NEW CBUF LENGTH.\n         LR    R1,R6\n         CLI   0(R6),C' '          END OF NEW COMMAND?\n         BE    *+L'*+4             YES.\n         BXLE  R6,R4,*-8\n         LR    R15,R6              COMPUTE NEW COMMAND LENGTH.\n         SR    R15,R1\n         LA    R0,L'COMMAND\n         CLR   R15,R0              NEW COMMAND TOO LONG?\n         BH    NCLERR              YES.\n         BCTR  R15,0               - 1 (MOVE).\n         EX    R15,UPCASE          UPPERCASE COMMAND NAME.\n         EX    R15,MOVECMD         MOVE NEW COMMAND NAME FOR LINK.\n         CLR   R6,R5               ANY OPERAND OF NEW COMMAND?\n         BH    FNDOP               NO.\nSCHSO    BXLE  R6,R4,*+L'*+4\n         B     FNDOP\n         CLI   0(R6),C' '          START OF OPERAND?\n         BE    SCHSO               NO.\nFNDOP    SR    R6,R1               COMPUTE OFFSET OF OPERAND.\n         STH   R6,OFFSET           STORE IT IN NEW CBUF.\n         MVC   CBUFOA,CPPLCBUF     SAVE ORIGINAL CBUF ADDRESS.\n         LA    R1,NEWBUF           NEW BUFFER ADDRESS.\n         ST    R1,CPPLCBUF         SET IT IN CPPL.\n        SETAUTH\n         MVC   LINK(LLINK),LINKP\n         LR    R1,R2               SET CPPL ADDRESS.\n        LINK   EPLOC=COMMAND,SF=(E,LINK)     LINK TO REQUESTED COMMAND.\n         LR    R10,R15             RETAIN RETURN CODE.\n        RESAUTH\n         MVC   CPPLCBUF,CBUFOA     RESTORE ORIGINAL CBUF ADDRESS.\n         DROP  R2\nRETURN  $XRET  CC=(R10),LV=WRKL,TYPE=RENT\nSETRC    LA    R10,16              C.C. = 16.\n         B     RETURN\nMOVETXT  MVC   TEXT(*-*),0(R6)     << EXECUTED >>\nUPCASE   OC    TEXT(*-*),COMMAND   << EXECUTED >>\nMOVECMD  MVC   COMMAND(*-*),TEXT   << EXECUTED >>\n         SPACE 1\n*------- DIAGNOSTIC'S MESSAGES.\n         SPACE 1\nNOTAUT   LA    R0,L'AUTMSG\n         LA    R1,AUTMSG\n         B     SHOWIT\nOPMISS   LA    R0,L'OPMMSG\n         LA    R1,OPMMSG\n         B     SHOWIT\nNCLERR   LA    R0,L'NCLMSG\n         LA    R1,NCLMSG\nSHOWIT   BAS   R14,PUTLNE\n         B     SETRC\n         EJECT\n*------- CONSTANTS.\n         SPACE 1\nLINKP   LINK   SF=L\n         SPACE 1\nAUTMSG   DC    C' -> UNAUTHORIZED COMMAND'\nOPMMSG   DC    C' -> OPERAND (AUTH. COMMAND) MISSING'\nNCLMSG   DC    C' -> OPERAND (AUTH. COMMAND) SYNTAX ERROR'\n         SPACE 1\n        LTORG\n         SPACE 1\n*------- WORK AREAS.\n         SPACE 1\nWRKDSECT DSECT                     WORK AREAS DESCRIPTION.\n         SPACE 1\nSVA      DS    18F                 SAVE AREA.\n         SPACE 1\n        $TEW$WA\n         SPACE 1\nLINK    LINK   SF=L                LINK PARAMETER LIST.\nLLINK    EQU   *-LINK\n         SPACE 1\nCBUFOA   DC    A(*-*)\nCOMMAND  DC    CL8' '              COMMAND NAME.\nNEWBUF   DS    0D             ---> NEW COMMAND BUFFER.\nCBUF     DC    H'0'                BUFFER LENGTH.\nOFFSET   DC    H'0'                OFFSET TO OPERANDS.\nTEXT     DC    CL256' '            COMMAND TEXT.\n         SPACE 1\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)\nAUTH     DC    XL1'0'\nREQAUTL  EQU   *-REQAUT\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AUTHC$": {"ttr": 8452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14!\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:21:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//AUTHC    JOB (........),'INSTALL  - AUTHC -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=3\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=AUTHC\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   AUTHC\n  SETCODE AC(1)\n  NAME    AUTHC(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AUTHC@": {"ttr": 8454, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x12\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:12:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      AUTHC     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *   COMMAND AUTHORIZATION INTERFACE   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Execute an authorized TSO-command.\n  ---------\n\n  Command :    Syntax : AUTHC ...command...\n  ---------\n                        i.e. - AUTHC CALL 'SYS1.LINKLIB(IEHDASDR)'\n\n  Authority :  This command is restricted to systems support persons\n  -----------  only.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AUTHCTL": {"ttr": 8456, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10o\\x00\\x88\\x10o\\x14 \\x01R\\x01R\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-15T00:00:00", "modifydate": "1988-04-15T14:20:00", "lines": 338, "newlines": 338, "modlines": 0, "user": "SYSPAJA"}, "text": "EACM     TITLE 'EURATOM AUTHORITY CONTROL MODULE.'\nAUTHCTL  START 0\n         SPACE 1\n* HOW TO ACCESS : ONLY USING THE ASSEMBLER MACRO, AS FOLLOWS\n* ---------------              ...\n*                             $EACM   PARM-LIST\n*                              ...\n*                  PARM-LIST  DC  BL1'A00R000U' ---> BIT U=0\n*                             DC  AL3(ENTRY-NUMBER)\n*                             DC  AL4(AUTH-BYTE)\n*               OR PARM-LIST  DC  XL1'A00R000U' ---> BIT U=1\n*                             DC  AL3(ENTRY-NUMBER)\n*                             DC  AL4(AUTH-BYTE)\n*                             DC  CL8'USER-ID'\n*                              ...\n*             WITH AUTH-BYTE  DC  AL1(*-*) IF BIT R=0\n*                         OR  DC  AL1(*-*),CL16' ' IF BIT R=1, TO ASK\n*                                        BACK USER-ID AND GROUP-NAME.\n*   AND 1. ENTRY-NUMBER : RELATIVE INDEX IN USERS-GROUPS TABLE.\n*                         SEE MODULE 'AUTHUGT' AND MACRO $MDL@IX.\n*       2. BIT A MAY BE : 0 - NOT RACF AUTHORIZED CALLING MODULE.\n*                         1 - ALREADY RACF AUTHORIZED CALLING MODULE.\n*\n* GENERAL NOTICE : THIS MODULE IS REENTRANT.\n* ================ IT IS LINK-EDITED IN A LIBRARY DEFINED IN LNKLST00,\n*                  SO IT MAY BE CHANGED WITHOUT INVOLVING USERS, AND\n*                  THIS LIBRARY IS RACF PROTECTED AGAINST ANY USERS\n*                  READ OR WRITE (ONLY SYSTEM GROUP MAY ACCESS IT).\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        PRINT  OFF\n         LCLB  &SW1\n&SW1     SETB  0\n         AIF   ('&SYSPARM' EQ '').O0S0\n         AIF   ('&SYSPARM'(1,6) NE 'NORACF').O0S0\n&SW1     SETB  1\n.O0S0   PRINT  ON\n         SPACE 2\n        $DEFREG\nAUTHCTL  AMODE 24\nAUTHCTL  RMODE 24\n         SPACE 2\n*        MISCELLANEOUS DEFINITIONS.\n*        --------------------------\n         SPACE 1\nFLEXIT   EQU   X'01'       FLAGS - EXIT SCHEDULED.\nSWUSER   EQU   X'01'      SWITCH - USER-ID SUPPLIED IN LIST.\nSWBACK   EQU   X'10'               USER-ID AND GROUP-NAME BACK REQ.\n         AIF   (&SW1).O1S1\nSWAUTH   EQU   X'80'               CALLING MODULE ALREADY RACF AUTH.\n.O1S1    EJECT\n         USING *,R12               SET ADDRESSABILITY.\n         STM   R14,R12,12(R13)     SAVE REGISTERS.\n         LR    R12,R15             SET BASE REGISTER.\n         B     BEGIN               BRANCH AROUND ID, DATE AND TIME.\n         SPACE 1\n         DC    CL8'AUTHCTL'        MODULE IDENTIFIER.\n         DC    CL8'&SYSDATE'       ASSEMBLY DATE (MM/DD/YY).\n         DC    C'-',CL5'&SYSTIME'  ASSEMBLY TIME (HH.MM).\n         SPACE 1\nBEGIN   GETMAIN R,LV=AREAL,SP=1\n         LR    R15,R13             PREVIOUS SAVE AREA.\n         LR    R13,R1              NEW SAVE AREA.\n         LR    R6,R1               WORK AREAS.\n         USING AREA,R6\n         XC    SVA(18*4),SVA       CLEAR NEW SAVE AREA.\n         ST    R13,8(R15)          LINK SAVE AREAS.\n         ST    R15,4(R13)\n         L     R2,24(R15)          RESTORE PARM'S POINTER.\n         MVI   FLAGS,0             RESET FLAGS.\n         MVC   USERID,=CL8' '\n         MVC   GROUP,=CL8' '\n         MVC   SWITCH(1),0(R2)     GET INDICATORS.\n         SR    R7,R7               SET DEFAULT LEVEL NUMBER.\n         LR    R8,R7\n         LR    R9,R7\n         ST    R7,16(R15)          SET RC=0 (REG 15).\n         ICM   R9,B'0111',1(R2)    GET ENTRY-NUMBER.\n         ICM   R10,B'1111',4(R2)   GET AUTH-BYTE ADDRESS.\n         TM    SWITCH,SWUSER       USER-ID SUPPLIED?\n         BZ    *+L'*+4             NO.\n         LA    R8,8(R2)            POINT TO USER-ID.\n         SPACE 1\n         MVC   EXTR(EXTRL),EXTRSK\n         XC    APSCB,APSCB\n        EXTRACT APSCB,'S',FIELDS=(PSB),MF=(E,EXTR)\n         L     R3,APSCB\n         LTR   R3,R3\n         BZ    NOTTSO\n         SPACE 1\n         MVC   SPIELST(SPIELSL),SPIELSK\n        SPIE   SPIEXIT,(4),MF=(E,SPIELST)\n         ST    R1,PRVSPIE          SAVE PREVIOUS.\n         USING CPPL,R2\n         USING PSCB,R3\n         CLC   PSCBUPT,CPPLUPT     CPPL+4 = UPT ADDRESS?\n         BNE   *+L'*+10            NO.\n         DROP  R3\n         CLC   APSCB,CPPLPSCB      TSO COMMAND USED?\n         BE    SETEX               YES.\n         LR    R1,R2\n         USING IKJEBECA,R1\n         L     R2,CAPTTMP\n         CLC   APSCB,CPPLPSCB      TSO SUB-COMMAND USED?\n         BNE   RSTSPIE             NO.\n         DROP  R1,R2\nSETEX    OI    FLAGS,FLEXIT        SET EXIT REQUEST.\nRSTSPIE  L     R1,PRVSPIE          OLD PICA ADDRESS.\n        SPIE   MF=(E,(1))\n         TM    FLAGS,FLEXIT        EXIT SCHEDULED?\n         BO    EXIT                YES.\nNOTTSO   STC   R7,0(R10)           RESET AUTHORITY LEVEL NUMBER.\n         SPACE 1\n         AIF   (&SW1).O2S1\n        RACSTAT ,                  TEST FOR RACF.\n         LTR   R15,R15             ACTIVE?\n         BNZ   TDFLT               NO.\n         LTR   R8,R8               USER-ID SUPPLIED?\n         BNZ   GETGRP              YES, CHECK REQUEST.\n         L     R1,CVTPTR           GET CVT ADDRESS.\n         USING CVT,R1\n         L     R2,CVTTCBP          GET ASCB ADDRESS.\n         DROP  R1\n         L     R2,12(R2)\n         USING ASCB,R2\n         L     R2,ASCBASXB         GET ASXB ADDRESS.\n         DROP  R2\n         USING ASXB,R2\n         L     R2,ASXBSENV         GET ACEE ADDRESS.\n         DROP  R2\n         LA    R2,0(,R2)\n         LTR   R2,R2               ANY ADDRESS?\n         BZ    TDFLT               NOT A RACF USER.\n         USING ACEE,R2\n         CLC   ACEEACEE,=CL4'ACEE' VALID ACRONYM?\n         BNE   TDFLT               NO.\n         TM    ACEEFLG1,ACEERACF   RACF DEFINED USER?\n         BZ    TDFLT               NO.\n         SR    R1,R1\n         IC    R1,ACEEUSRL         GET USER-ID LENGTH.\n         BCTR  R1,0\n         EX    R1,MVUSID           SET CURRENT USER-ID.\n         IC    R1,ACEEGRPL         GET GROUP-NAME LENGTH.\n         BCTR  R1,0\n         EX    R1,MVGRPN           SET CURRENT GROUP-NAME.\n         B     ANAL\nMVUSID   MVC   USERID(*-*),ACEEUSRI     << EXECUTED >>\nMVGRPN   MVC   GROUP(*-*),ACEEGRPN << EXECUTED >>\n         DROP  R2\n         SPACE 1\nGETGRP   MVC   USERID(L'USERID),0(R8)\n         LA    R2,L'USERID\n         LA    R3,USERID+L'USERID-1\n         CLI   0(R3),C' '\n         BNE   *+L'*+6\n         BCTR  R3,0\n         BCT   R2,*-10\n         STC   R2,RUSIDL\n         MVC   RUSID,USERID\n         XC    LRGP(LRGPL),LRGP    REQUEST DEFAULT GROUP-NAME.\n         MVC   RGP(RGPL),RGPA\n         XC    WA(WAL),WA\n         LA    R1,WAL\n         ST    R1,WA\n         TM    SWITCH,SWAUTH       CALLER ALREADY RACF AUTHORIZED?\n         BO    LOCUSR              YES.\n        SETAUTH ,\nLOCUSR  ICHEINTY LOCATE,TYPE='USR',ENTRY=RUSIDL,ACTIONS=(RGP),         X\n               WKAREA=WA,OPTIONS=(FLDEF,ACTION),MF=(E,LRGP)\n         LR    R2,R15\n         TM    SWITCH,SWAUTH       CALLER ALREADY RACF AUTHORIZED?\n         BO    NORES               YES.\n        RESAUTH ,\nNORES    LTR   R2,R2\n         BNZ   TDFLT\n         CLC   DFGL,=XL2'0008'\n         BE    SETGRP\nTDFLT    CLC   USERID(3),=CL3'SYS' SYSTEM GROUP USER?\n         BE    SYSLVL              YES.\n         CLC   GROUP(3),=CL3'SYS'  SYSTEM GROUP?\n         BNE   LEAVE               NO.\nSYSLVL   LA    R7,15               SET HIGHER LEVEL.\n         B     LEAVE\nSETGRP   MVC   GROUP(L'GROUP),DFG  GET GROUP-NAME.\n         AGO   .O2S2\n.O2S1    LTR   R8,R8               USER-ID SUPPLIED?\n         BNZ   SETIT               YES, CHECK REQUEST.\n         L     R1,CVTPTR           GET CVT ADDRESS.\n         USING CVT,R1\n         L     R2,CVTTCBP          GET ASCB ADDRESS.\n         DROP  R1\n         L     R2,12(R2)\n         USING ASCB,R2\n         L     R1,ASCBJBNS         GET PTR TO STARTED/MOUNT/LOGON'ID.\n         LTR   R1,R1\n         BZ    NOTSML\n         MVC   USERID(L'USERID),0(R1)   SET STARTED/MOUNT/LOGON'ID.\n         B     ANAL\nNOTSML   L     R1,ASCBJBNI         GET PTR TO JOB NAME.\n         LTR   R1,R1\n         BZ    LEAVE\n         MVC   GROUP(L'GROUP),0(R1)     SET JOB NAME.\n         DROP  R2\n         SPACE 1\nSETIT    MVC   USERID(L'USERID),0(R8)   SET AS STARTED/MOUNT/LOGON'ID.\n         MVC   GROUP(L'GROUP),0(R8)     SET AS JOB NAME.\n.O2S2    SPACE 1\nANAL     L     R2,=V(AUTHUGT)      AUTHORITY USER-GROUP TABLE.\n         USING VECTOR,R2\n         CL    R9,MAXGN            VALID ENTRY-NUMBER?\n         BH    LEAVE               NO.\n         L     R1,MAXGN            MAX. MODULE'S INDEX VALUE.\n         L     R3,USERS            USER LIST.\nSCUT     CLI   0(R3),0             END OF LIST?\n         BE    SCGP                YES.\n         CLC   0(L'USERID,R3),USERID    THIS USER-ID?\n         BE    SLVL                YES.\n         LA    R3,L'USERID+1(R1,R3)     BUMP TO NEXT.\n         B     SCUT\nSCGP     L     R3,GROUPS           GROUP LIST.\nSCGT     CLI   0(R3),0             END OF LIST?\n         BE    GTDF                YES.\n         CLC   0(L'GROUP,R3),GROUP THIS GROUP-NAME?\n         BE    SLVL                YES.\n         LA    R3,L'GROUP+1(R1,R3) BUMP TO NEXT.\n         B     SCGT\nGTDF     L     R3,DEFAULT          GET DEFAULT VALUE.\n         DROP  R2\n         IC    R7,0(R9,R3)         GET AUTHORITY LEVEL NUMBER.\n         B     LEAVE\nSLVL     IC    R7,8(R9,R3)         GET AUTHORITY LEVEL NUMBER.\n         SPACE 1\nLEAVE    LA    R0,15               FORCE 0 TO 15.\n         NR    R7,R0\n         STC   R7,0(R10)           STORE AUTHORITY LEVEL NUMBER.\n         TM    SWITCH,SWBACK       BACK USER-ID AND GROUP REQUESTED?\n         BZ    EXIT                NO.\n         MVC   1(L'USERID+L'GROUP,R10),USERID\nEXIT     LR    R1,R6               MAIN STORAGE AREA TO BE RELEASED.\n         DROP  R6\n         L     R13,4(R13)          PREVIOUS SAVE AREA.\n        FREEMAIN R,LV=AREAL,A=(1),SP=1\n         LM    R14,R15,12(R13)     RESTORE REGISTERS 14-15.\n         SR    R15,R15             CC = 0.\n         LM    R0,R12,20(R13)      RESTORE REGISTERS 0-12.\n         MVI   12(R13),X'FF'       SET RETURN INDICATOR.\n         BR    R14                 RETURN.\n         SPACE 2\n*        INTERCEPT 0C4 EXIT ROUTINE.\n*        ---------------------------\n*              R1 ---> PROGRAM INTERRUPTION ELEMENT.\n         SPACE 1\n         CNOP  0,8\n         USING *,R15\n         USING PIE,R1\nSPIEXIT  MVC   PIEPSW+5(3),=AL3(RSTSPIE)     SET RETURN ADDRESS.\n         BR    R14                 BACK TO CONTROL PROGRAM.\n         DROP  R1,R15\n         EJECT\n*        CONSTANTS AND SKELETONS.\n*        ------------------------\n         SPACE 1\nEXTRSK  EXTRACT *-*,'S',MF=L\nSPIELSK SPIE   *-*,,MF=L\n         AIF   (&SW1).O10S1\nRGPA    ICHEACTN FIELD=DFLTGRP,MF=L\n.O10S1   SPACE 2\n        LTORG\n         SPACE 1\n         DROP  R12\n         EJECT\n*        AREA'S DESCRIPTION.\n*        -------------------\n         SPACE 1\nAREA     DSECT\nSVA      DC    18F'0'              SAVE AREA.\n         SPACE 1\nEXTR    EXTRACT *-*,'S',MF=L\nEXTRL   EQU    *-EXTR\nSPIELST SPIE   *-*,,MF=L\nSPIELSL EQU    *-SPIELST\nPRVSPIE  DS    F                   PREVIOUS PICA ADDRESS.\n         AIF   (&SW1).O20S1\nLRGP    ICHEINTY LOCATE,TYPE='USR',ACTIONS=(*-*),MF=L\nLRGPL    EQU   *-LRGP\nRGP     ICHEACTN FIELD=DFLTGRP,MF=L\nRGPL     EQU   *-RGP\n         SPACE 1\nWA       DS    F                   WORK AREA LENGTH.\n         DS    XL20                RESERVED.\n         DS    F                   ACTION RESPONSE LENGTH.\nDFGL     DS    XL2                 DEFAULT GROUP LENGTH (8).\nDFG      DS    CL8                 DEFAULT GROUP.\n         DS    H\nWAL      EQU   *-WA\n.O20S1   SPACE 1\nAPSCB    DC    A(0)\nUSERID   DC    CL8' '              USER-ID.\nGROUP    DC    CL8' '              GROUP-NAME.\nFLAGS    DC    XL1'0'              PROCESSING FLAGS.\nSWITCH   DC    XL1'0'              PROCESSING SWITCHES.\n         AIF   (&SW1).O20S2\nRUSIDL   DC    XL1'0'              USER-ID LENGTH.\nRUSID    DC    CL8' '              USER-ID NAME.\n.O20S2   SPACE 1\n         CNOP  0,8\nAREAL    EQU   *-AREA              TOTAL LENGTH.\n         EJECT\n*        VECTOR TABLE DESCRIPTION (AUTHUGT).\n*        -----------------------------------\n         SPACE 1\nVECTOR   DSECT\n         SPACE 1\nMAXGN    DS    F\nUSERS    DS    A\nGROUPS   DS    A\nDEFAULT  DS    A\n         SPACE 2\n        PRINT  NOGEN\n         SPACE 1\n        CVT    DSECT=YES,TSO=YES,RPS=YES,LIST=YES\n         SPACE 1\n        IKJCPPL\n        IKJPSCB\n        IKJEBECA\n        IHAASCB\n        IHAPIE\n         AIF   (&SW1).O30S1\n         SPACE 1\n        IHAASXB\n         SPACE 1\n        IHAACEE\n.O30S1   SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AUTHCTL$": {"ttr": 8462, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14!\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:21:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": "//AUTHCTL  JOB (........),'INSTALL - AUTHCTL -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=6\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* NOTE : SPECIFY SYSPARM(NORACF) AT ASSEMBLY STEP 'ASC' IF RACF     *\n//*        IS NOT INSTALLED IN THE YOUR SYSTEM.                       *\n//*                 I.E. : OPT=',RENT,SYSPARM(NORACF)'                *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASC     EXEC PAJIAS3,OPT=',RENT',MBR=AUTHCTL\n//ASU     EXEC PAJIAS2,OPT=',RENT',MBR=AUTHUGT\n//LNK     EXEC PAJILKL,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   AUTHCTL\n  NAME    AUTHCTL(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AUTHCTL@": {"ttr": 8464, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x1f\\x00\\x88\\x15\\x1f\\x12\\x02\\x00P\\x00P\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-30T00:00:00", "modifydate": "1988-05-30T12:02:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "SYSPAJA"}, "text": "1   24/05/88\n                                                      AUTHCTL   1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      EURATOM AUTHORITY CONTROL      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Control the access authority of a user (RACF) at the\n  ---------    execute time for a specific module (program or command).\n               This module allows access/permit to be restricted on\n               programs or commands called through the LINKLIST, member\n               LNKLST00 of SYS1.PARMLIB (no RACF control).\n\n  How to update : follows in sequence the steps described below when\n  =============== some changes or updates are to be operative.\n\n  1. Apply changes and/or adds to the USERs-GROUPs table in the\n     module AUTHUGT or to the modules names list in the macro $MDL@IX\n     (in the source library).\n     Remark : don't forget to eventually adjust the assigned module's\n     -------- index lists in order to reflect the current situation.\n\n  2. Re-execute the job AUTHCTL$ (in the source library) to set\n     effective the new USERs-GROUPs table.\n\n  Module name : AUTHCTL (EURATOM authority control module).\n  ============= This module must be link-edited in a library defined\n                in LINKLIST, member LNKLST00 of SYS1.PARMLIB.\n\n  How to access : only using the assembler macro, as follows\n  ---------------              ...\n                              $EACM   PARM-LIST\n                               ...\n                   PARM-LIST  DC  BL1'A00R000U' ---> bit U=0\n                              DC  AL3(ENTRY-NUMBER)\n                              DC  AL4(AUTH-BYTE)\n                or PARM-LIST  DC  XL1'A00R000U' ---> bit U=1\n                              DC  AL3(ENTRY-NUMBER)\n                              DC  AL4(AUTH-BYTE)\n                              DC  CL8'USER-ID'\n                               ...\n              with AUTH-BYTE  DC  AL1(*-*) if bit R=0\n                          OR  DC  AL1(*-*),CL16' ' if bit R=1, to ask\n                                         back USER-id and GROUP-name.\n    and 1. ENTRY-NUMBER : relative index in users-groups table.\n                          see module AUTHUGT and macro $MDL@IX.\n        2. Bit A may be : 0 - not RACF authorized calling module.\n                          1 - already RACF authorized calling module.\n=/EJ26/05/88\n                                                      AUTHCTL   2/2.\n\n  Module name : AUTHUGT (EURATOM authority control USERs-GROUPs table).\n  =============\n\n  Tables organization : accessed only by module AUTHCTL.\n  ---------------------\n\n            VECTOR TABLE DC  A(MAX.-INDEX)\n                         DC  A(USER-LIST)\n                         DC  A(GROUP-LIST)\n                         DC  A(DEFAULT)\n                         ...\n              USER-LIST  EQU *\n                         ...     defined USER-IDs (using macro $MDL@IX)\n                         ...     with their AUTH-LEVELs for modules\n                         ...     accesses\n                         DC  XL1'0'   END OF LIST INDICATOR.\n             GROUP-LIST  EQU *\n                         ...     defined GROUPs (using macro $MDL@IX)\n                         ...     with their AUTH-LEVELs for modules\n                         ...     accesses\n                         DC  XL1'0'   END OF LIST INDICATOR.\n                         ...\n                        $MDL@IX ...,USE=DEFAULT\n\n  Remark : the value of AUTH-LEVEL may be from 0 to 15 only.\n  -------- Each AUTH-LEVEL specified for a USER-id or GROUP-name\n           corresponds to the relative module index.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AUTHSVC": {"ttr": 8705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x884?\\x00\\x884?\\x11#\\x00+\\x00+\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-08T00:00:00", "modifydate": "1988-12-08T11:23:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "SYSPAJA"}, "text": "AUTH     TITLE 'AUTHORIZATION SVC FOR MVS.'\nIGC00### START 0                   AUTHORIZATION ON/OFF SVC.\n         SPACE 1\n        $DEFREG\n         SPACE 1\n         USING *,R6                SET LOCAL ADDRESSABILITY.\n         SPACE 1\n         LTR   R0,R0               TIME CALL?\n         BNM   AUTHCALL            NO.\n         BCT   R1,*+L'*+6\n         USING ASCB,R7\n         L     R0,ASCBJSTL         1 = STEP TIME LIMIT.\n         BR    R14                 RETURN.\n         BCT   R1,*+L'*+6\n         LM    R0,R1,ASCBEJST      2 = CPU TIME USED IN THIS STEP.\n         BR    R14                 RETURN.\n         BCT   R1,*+L'*+6\n         L     R0,ASCBR15C         3 = SRB TIME LIMIT.\n         BR    R14                 RETURN.\n         BCT   R1,*+L'*+4\n         LM    R0,R1,ASCBSRBT      4 = SRB TIME USED IN THIS STEP.\n         DROP  R7\n         BR    R14                 RETURN.\n         SPACE 1\n         USING TCB,R4              SET TCB ADDRESSABILITY.\nAUTHCALL L     R2,TCBJSCB          POINTER TO JSCB IN REGISTER 2.\n         DROP  R4\n         USING IEZJSCB,R2          SET JSCB ADDRESSABILITY.\n         BCT   R0,AUTHOFF          IF R0 NOT = 1, AUTH OFF.\n* ------ INSERT HERE ANY CONTROL YOU WANT DO ON CALLER ----------------\n         OI    JSCBOPTS,JSCBAUTH   SET JSCB AUTH BIT.\n         BR    R14                 RETURN.\nAUTHOFF  NI    JSCBOPTS,255-JSCBAUTH    CLEAR JSCB AUTH BIT.\n         BR    R14                 RETURN.\n         DROP  R2\n         SPACE 1\n        PRINT  OFF\n        IHAASCB LIST=YES\n        IKJTCB\n        IECDSECS (JSCB),EXPAND=YES\n        PRINT  ON\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AUTHSVC$": {"ttr": 8707, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x12\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:12:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//AUTHSVC  JOB (........),'INSTALL  - SVC ### -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=AUTHSVC\n//LNK     EXEC PAJILKA,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY  IGC00###\n  NAME   IGC00###(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AUTHSVC@": {"ttr": 8709, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x884?\\x00\\x884?\\x11#\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-08T00:00:00", "modifydate": "1988-12-08T11:23:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "1   08/12/88\n                                                      AUTHSVC   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      Authorization SVC for MVS      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Local SVC to turn ON/OFF the authorized mode, or to get\n  ---------    some TIME values requests.\n\n  How used :   only through the assembler macros SETAUTH, RESAUTH and\n  ----------   $TREQ.\n\n  SVC number : replace the characters ### by the selected SVC number\n  ------------ in the AUTHSVC source, the AUTHSVC$ JCL and the macros\n               SETAUTH/RESAUTH/$TREQ.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AUTHUGT": {"ttr": 8711, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x892_\\x00\\x892_\\x12\"\\x00o\\x00o\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-21T00:00:00", "modifydate": "1989-11-21T12:22:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "SYSPAJA"}, "text": "EACT     TITLE 'EURATOM AUTHORITY CONTROL USERS-GROUPS TABLE.'\nAUTHUGT  START 0\n         SPACE 2\n* TABLES ORGANIZATION : ACCESSED ONLY BY MODULE 'AUTHCTL'.\n* ---------------------\n*\n*           VECTOR TABLE DC  A(MAX.-INDEX)\n*                        DC  A(USER-LIST)\n*                        DC  A(GROUP-LIST)\n*                        DC  A(DEFAULT)\n*                        ...\n*             USER-LIST  EQU *\n*             USER-NAME $MDL@IX ...,USE=USER\n*                        ... DEFINED USER-IDS (USING MACRO $MDL@IX)\n*                        ... WITH THEIR AUTH-LEVELS FOR MODULES\n*                        ... ACCESSES\n*                        DC  XL1'0'   END OF LIST INDICATOR.\n*            GROUP-LIST  EQU *\n*            GROUP-NAME $MDL@IX ...,USE=GROUP\n*                        ... DEFINED GROUPS (USING MACRO $MDL@IX)\n*                        ... WITH THEIR AUTH-LEVELS FOR MODULES\n*                        ... ACCESSES\n*                        DC  XL1'0'   END OF LIST INDICATOR.\n*                       $MDL@IX ...,USE=DEFAULT\n*\n* REMARK : THE VALUE OF AUTH-LEVEL MAY BE FROM 0 TO 15 ONLY.\n* -------- EACH AUTH-LEVEL SPECIFIED FOR A USER-ID OR GROUP-NAME\n*          CORRESPONDS TO THE RELATIVE MODULE INDEX.\n*\n* GENERAL NOTICE : THIS MODULE IS REENTRANT.\n* ================\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $MDL@IX\n*        VECTOR TABLE.\n*        -------------\n         SPACE 1\n         DC    A(MAXGN)            MAX. MODULE'S INDEX.\n         DC    A(USERS)            START ADDRESS OF USERS LIST.\n         DC    A(GROUPS)           START ADDRESS OF GROUPS LIST.\n         DC    A(DEFAULT)          ADDRESS OF DEFAULTS VALUES.\n         SPACE 2\n         DC    CL8'AUTHUGT'        IDENTIFIER.\n         DC    CL8'&SYSDATE',C'-'  ASSEMBLY DATE (MM/DD/YY).\n         DC    CL5'&SYSTIME'       ASSEMBLY TIME (HH.MM).\n         EJECT\n*        USER-ID'S LIST. (OR START/MOUNT/LOGON'ID IF NO RACF)\n*        ---------------\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        THIS LIST DEFINES THE PRIVILEGES FOR SINGLE USERS.           *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nUSERS    EQU   *\n         SPACE 1\nSYSSP1  $MDL@IX CP-0,ALL-15,USE=USER\nSYSSP2  $MDL@IX CP-0,AUT98-10,ALL-15,USE=USER\nSYSSP3  $MDL@IX CP-0,AUT98-10,ALL-15,USE=USER\nSYSUS1  $MDL@IX AUTOCI-10,EUSUB-10,SCHEDULE-10,TSOENQ-12,RSVENQ-12,    1\n               INCORZAP-12,CONAN-15,VCOREZAP-15,PSWSAMP-15,            2\n               NOTICE-15,USE=USER\nSYSUS2  $MDL@IX DIDOCS-15,AUTOCI-10,EUSUB-10,SCHEDULE-10,CP-0,         1\n               CONAN-14,AUT98-0,ALL-12,USE=USER\nOPERMS  $MDL@IX DIDOCS-10,QSP-12,PSWR-14,AUTOCI-10,EUSUB-10,           1\n               SCHEDULE-10,UNIT-10,POF-10,TSOENQ-10,RSVENQ-10,         2\n               VSM-10,FSPACE-12,NOTICE-12,USE=USER\nSYSADM  $MDL@IX AUT98-12,USE=USER\nGR1US1  $MDL@IX DIDOCS-9,QSP-10,PSWR-8,EUSUB-8,FSPACE-10,USE=USER\nGR1US2  $MDL@IX DIDOCS-9,QSP-10,PSWR-8,FSPACE-10,USE=USER\nGR1US3  $MDL@IX DIDOCS-9,QSP-10,PSWR-8,CDSCB-10,FSPACE-10,USE=USER\nGR1US4  $MDL@IX DIDOCS-9,QSP-10,PSWR-8,FSPACE-10,USE=USER\nGR1US5  $MDL@IX DIDOCS-9,QSP-10,PSWR-8,FSPACE-10,USE=USER\nGR1US6  $MDL@IX DIDOCS-9,QSP-10,PSWR-8,FSPACE-10,USE=USER\nGR1US7  $MDL@IX DIDOCS-9,QSP-10,PSWR-8,FSPACE-10,USE=USER\nGR1US8  $MDL@IX DIDOCS-9,QSP-10,PSWR-8,FSPACE-10,USE=USER\nGR2US1  $MDL@IX DIDOCS-10,POF-10,FSPACE-10,USE=USER\nGR2US2  $MDL@IX DIDOCS-10,POF-10,FSPACE-10,USE=USER\nGR2US3  $MDL@IX DIDOCS-10,POF-10,FSPACE-10,USE=USER\n         DC    XL1'0'              END OF LIST INDICATOR.\n         SPACE 1\n*        GROUP-NAME'S LIST. (OR JOB NAME IF NO RACF)\n*        ------------------\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        THIS LIST DEFINES THE PRIVILEGES FOR GROUP OF USERS.         *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nGROUPS   EQU   *\n         SPACE 1\nSYS1    $MDL@IX DIDOCS-10,AUTOCI-10,EUSUB-10,SCHEDULE-10,CP-0,         1\n               FSPACE-14,AUT98-10,ALL-12,USE=GROUP\nDMS     $MDL@IX DIDOCS-10,PSWR-10,AUTOCI-10,EUSUB-10,SCHEDULE-10,      1\n               CP-0,FSPACE-14,AUT98-0,ALL-12,USE=GROUP\nOPER    $MDL@IX DIDOCS-10,QSP-12,PSWR-10,AUTOCI-10,EUSUB-10,           1\n               SCHEDULE-10,UNIT-10,POF-10,TSOENQ-10,RSVENQ-10,         2\n               VSM-10,FSPACE-12,NOTICE-12,USE=GROUP\n         DC    XL1'0'              END OF LIST INDICATOR.\n         SPACE 1\n*        DEFAULTS VALUES.\n*        ----------------\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        HERE IS DEFINED THE PRIVILEGES FOR THE REST OF THE WORLD.    *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n        $MDL@IX DIDOCS-1,EUSUB-1,USE=DEFAULT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BIG": {"ttr": 8714, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x179\\x02Z\\x02Z\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T17:39:00", "lines": 602, "newlines": 602, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM,BPARM)\n/*  MACRO NAME : BIG                                                */\n/*    FUNCTION : CREATE BLOCK CHARACTERS IN TEXT                    */\n/*      SYNTAX : BIG CHARACTER                                      */\n/*               BIG HELP OR HE                                     */\n/*       DEBUG : BIG ... LIST                                       */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n  IF &STR(&BPARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n  SET &TL = &LENGTH(&STR(&APARM))\n  IF &TL \u00ac= 1 THEN DO\n    IF &STR(&APARM) = &STR(HELP) OR +\n      &STR(&APARM) = &STR(HE) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTBIG)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    ELSE DO\nERRX: SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = ENTER \"BIG HELP\" COMMAND FOR OPERAND SYNTAX\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  IF &APARM = $ THEN GOTO OK\n  IF &APARM = # THEN GOTO OK\n  IF &APARM = @ THEN GOTO OK\n  IF &APARM < A THEN GOTO ERRX\n  IF &APARM > 9 THEN GOTO ERRX\n  IF &APARM > Z AND &APARM < 0 THEN GOTO ERRX\nOK: +\n  ISREDIT (ROW,COL) = CURSOR\n  ISPEXEC CONTROL ERRORS RETURN\n  IF &APARM = 1 THEN SET &APARM = &STR(N1)\n  IF &APARM = 2 THEN SET &APARM = &STR(N2)\n  IF &APARM = 3 THEN SET &APARM = &STR(N3)\n  IF &APARM = 4 THEN SET &APARM = &STR(N4)\n  IF &APARM = 5 THEN SET &APARM = &STR(N5)\n  IF &APARM = 6 THEN SET &APARM = &STR(N6)\n  IF &APARM = 7 THEN SET &APARM = &STR(N7)\n  IF &APARM = 8 THEN SET &APARM = &STR(N8)\n  IF &APARM = 9 THEN SET &APARM = &STR(N9)\n  IF &APARM = 0 THEN SET &APARM = &STR(N0)\n  IF &APARM = $ THEN SET &APARM = &STR(NS1)\n  IF &APARM = # THEN SET &APARM = &STR(NS2)\n  IF &APARM = @ THEN SET &APARM = &STR(NS3)\n  GOTO &APARM\nA: +\nISREDIT LINE &ROW           = LINE + < &COL '  AAAAAAAAAA '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' AAAAAAAAAAAA'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' AAAAAAAAAAAA'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' AAAAAAAAAAAA'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' AA        AA'>\nGOTO PROCESS\nB: +\nISREDIT LINE &ROW           = LINE + < &COL ' BBBBBBBBB   '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' BBBBBBBBBB  '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' BB       BB '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' BB       BB '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' BB       BB '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' BBBBBBBBBB  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' BBBBBBBBBBB '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' BB        BB'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' BB        BB'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' BB        BB'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' BBBBBBBBBBB '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' BBBBBBBBBB  '>\nGOTO PROCESS\nC: +\nISREDIT LINE &ROW           = LINE + < &COL '   CCCCCCCC  '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL '  CCCCCCCCCC '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' CC        CC'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' CC          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' CC          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' CC          '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' CC          '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' CC          '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' CC          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' CC        CC'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '  CCCCCCCCCC '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '   CCCCCCCC  '>\nGOTO PROCESS\nD: +\nISREDIT LINE &ROW           = LINE + < &COL ' DDDDDDDDD   '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' DDDDDDDDDD  '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' DD       DD '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' DDDDDDDDDDD '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' DDDDDDDDDD  '>\nGOTO PROCESS\nE: +\nISREDIT LINE &ROW           = LINE + < &COL ' EEEEEEEEEEEE'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' EEEEEEEEEEEE'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' EE          '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' EE          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' EE          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' EEEEEEEE    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' EEEEEEEE    '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' EE          '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' EE          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' EE          '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' EEEEEEEEEEEE'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' EEEEEEEEEEEE'>\nGOTO PROCESS\nF: +\nISREDIT LINE &ROW           = LINE + < &COL ' FFFFFFFFFFFF'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' FFFFFFFFFFFF'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' FF          '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' FF          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' FF          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' FFFFFFFF    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' FFFFFFFF    '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' FF          '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' FF          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' FF          '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' FF          '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' FF          '>\nGOTO PROCESS\nG: +\nISREDIT LINE &ROW           = LINE + < &COL '  GGGGGGGGGG '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' GGGGGGGGGGGG'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' GG        GG'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' GG          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' GG          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' GG          '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' GG    GGGGGG'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' GG    GGGGGG'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' GG        GG'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' GG        GG'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' GGGGGGGGGGGG'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  GGGGGGGGGG '>\nGOTO PROCESS\nH: +\nISREDIT LINE &ROW           = LINE + < &COL ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' HHHHHHHHHHHH'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' HHHHHHHHHHHH'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' HH        HH'>\nGOTO PROCESS\nI: +\nISREDIT LINE &ROW           = LINE + < &COL '  IIIIIIIIII '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL '  IIIIIIIIII '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL '      II     '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL '      II     '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '      II     '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '      II     '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '      II     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '      II     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '      II     '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL '      II     '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '  IIIIIIIIII '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  IIIIIIIIII '>\nGOTO PROCESS\nJ: +\nISREDIT LINE &ROW           = LINE + < &COL '   JJJJJJJJJJ'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL '   JJJJJJJJJJ'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL '       JJ    '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL '       JJ    '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '       JJ    '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '       JJ    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '       JJ    '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '       JJ    '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' JJ    JJ    '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' JJ    JJ    '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' JJJJJJJJ    '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  JJJJJJ     '>\nGOTO PROCESS\nK: +\nISREDIT LINE &ROW           = LINE + < &COL ' KK        KK'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' KK       KK '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' KK      KK  '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' KK     KK   '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' KK    KK    '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' KKKKKK      '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' KKKKKK      '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' KK    KK    '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' KK     KK   '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' KK      KK  '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' KK       KK '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' KK        KK'>\nGOTO PROCESS\nL: +\nISREDIT LINE &ROW           = LINE + < &COL ' LL          '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' LL          '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' LL          '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' LL          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' LL          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' LL          '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' LL          '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' LL          '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' LL          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' LL          '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' LLLLLLLLLLLL'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' LLLLLLLLLLLL'>\nGOTO PROCESS\nM: +\nISREDIT LINE &ROW           = LINE + < &COL ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' MMM      MMM'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' MMMM    MMMM'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' MM MM  MM MM'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' MM  MMMM  MM'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' MM   MM   MM'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' MM        MM'>\nGOTO PROCESS\nN: +\nISREDIT LINE &ROW           = LINE + < &COL ' NN        NN'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' NNN       NN'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' NNNN      NN'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' NN NN     NN'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' NN  NN    NN'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' NN   NN   NN'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' NN    NN  NN'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' NN     NN NN'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' NN      NNNN'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' NN       NNN'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' NN        NN'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' NN        NN'>\nGOTO PROCESS\nO: +\nISREDIT LINE &ROW           = LINE + < &COL ' OOOOOOOOOOOO'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' OOOOOOOOOOOO'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' OOOOOOOOOOOO'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' OOOOOOOOOOOO'>\nGOTO PROCESS\nP: +\nISREDIT LINE &ROW           = LINE + < &COL ' PPPPPPPPPPP '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' PPPPPPPPPPPP'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' PP        PP'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' PP        PP'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' PP        PP'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' PPPPPPPPPPPP'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' PPPPPPPPPPP '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' PP          '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' PP          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' PP          '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' PP          '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' PP          '>\nGOTO PROCESS\nQ: +\nISREDIT LINE &ROW           = LINE + < &COL '  QQQQQQQQQQ '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' QQQQQQQQQQQQ'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' QQ        QQ'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' QQ        QQ'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' QQ        QQ'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' QQ        QQ'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' QQ        QQ'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' QQ    QQ  QQ'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' QQ     QQ QQ'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' QQ      QQQQ'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' QQQQQQQQQQQ '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  QQQQQQQQ QQ'>\nGOTO PROCESS\nR: +\nISREDIT LINE &ROW           = LINE + < &COL ' RRRRRRRRRR  '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' RRRRRRRRRRR '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' RR        RR'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' RR        RR'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' RR        RR'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' RRRRRRRRRRRR'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' RRRRRRRRRRR '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' RR    RR    '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' RR     RR   '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' RR      RR  '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' RR       RR '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' RR        RR'>\nGOTO PROCESS\nS: +\nISREDIT LINE &ROW           = LINE + < &COL '  SSSSSSSSSS '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' SSSSSSSSSSSS'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' SS        SS'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' SS          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' SSS         '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '  SSSSSSSSS  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '   SSSSSSSSS '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '          SSS'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '           SS'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' SS        SS'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' SSSSSSSSSSSS'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  SSSSSSSSSS '>\nGOTO PROCESS\nT: +\nISREDIT LINE &ROW           = LINE + < &COL ' TTTTTTTTTTTT'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' TTTTTTTTTTTT'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL '      TT     '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL '      TT     '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '      TT     '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '      TT     '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '      TT     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '      TT     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '      TT     '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL '      TT     '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '      TT     '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '      TT     '>\nGOTO PROCESS\nU: +\nISREDIT LINE &ROW           = LINE + < &COL ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' UUUUUUUUUUUU'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  UUUUUUUUUU '>\nGOTO PROCESS\nV: +\nISREDIT LINE &ROW           = LINE + < &COL ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '  VV      VV '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '   VV    VV  '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL '    VV  VV   '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '     VVVV    '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '      VV     '>\nGOTO PROCESS\nW: +\nISREDIT LINE &ROW           = LINE + < &COL ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' WW   WW   WW'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' WW  WWWW  WW'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' WW WW  WW WW'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' WWWW    WWWW'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' WWW      WWW'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' WW        WW'>\nGOTO PROCESS\nX: +\nISREDIT LINE &ROW           = LINE + < &COL ' XX        XX'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' XX        XX'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL '  XX      XX '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL '   XX    XX  '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '    XX  XX   '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '     XXXX    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '     XXXX    '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '    XX  XX   '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '   XX    XX  '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL '  XX      XX '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' XX        XX'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' XX        XX'>\nGOTO PROCESS\nY: +\nISREDIT LINE &ROW           = LINE + < &COL ' YY        YY'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' YY        YY'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL '  YY      YY '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL '   YY    YY  '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '    YY  YY   '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '     YYYY    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '      YY     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '      YY     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '      YY     '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL '      YY     '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '      YY     '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '      YY     '>\nGOTO PROCESS\nZ: +\nISREDIT LINE &ROW           = LINE + < &COL '  ZZZZZZZZZZZ'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL '  ZZZZZZZZZZ '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL '         ZZ  '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL '        ZZ   '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '       ZZ    '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '      ZZ     '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '     ZZ      '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '    ZZ       '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '   ZZ        '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL '  ZZ         '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' ZZZZZZZZZZZZ'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' ZZZZZZZZZZZZ'>\nGOTO PROCESS\nN1: +\nISREDIT LINE &ROW           = LINE + < &COL '      11     '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL '     111     '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL '    1111     '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL '      11     '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '      11     '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '      11     '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '      11     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '      11     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '      11     '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL '      11     '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '  1111111111 '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  1111111111 '>\nGOTO PROCESS\nN2: +\nISREDIT LINE &ROW           = LINE + < &COL '  2222222222 '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' 222222222222'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' 22        22'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL '           22'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '           22'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '          22 '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '        22   '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '      22     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '    22       '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL '  22         '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' 222222222222'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' 222222222222'>\nGOTO PROCESS\nN3: +\nISREDIT LINE &ROW           = LINE + < &COL '  3333333333 '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' 333333333333'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' 33        33'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL '           33'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '           33'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '      333333 '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '      333333 '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '           33'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '           33'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' 33        33'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' 333333333333'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  3333333333 '>\nGOTO PROCESS\nN4: +\nISREDIT LINE &ROW           = LINE + < &COL '       444   '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL '      4444   '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL '     44 44   '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL '    44  44   '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '   44   44   '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '  44444444444'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' 444444444444'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '        44   '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '        44   '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL '        44   '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '        44   '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '        44   '>\nGOTO PROCESS\nN5: +\nISREDIT LINE &ROW           = LINE + < &COL ' 555555555555'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' 555555555555'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' 55          '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' 55          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' 55          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' 555555555   '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' 5555555555  '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '          55 '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '           55'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL '           55'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' 555555555555'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  5555555555 '>\nGOTO PROCESS\nN6: +\nISREDIT LINE &ROW           = LINE + < &COL '  6666666666 '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' 666666666666'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' 66        66'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' 66          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' 66          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' 6666666666  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' 66666666666 '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' 66        66'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' 66        66'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' 66        66'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' 666666666666'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  6666666666 '>\nGOTO PROCESS\nN7: +\nISREDIT LINE &ROW           = LINE + < &COL ' 777777777777'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' 777777777777'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' 77       77 '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL '         77  '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '        77   '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '       77    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '      77     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '      77     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '      77     '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL '      77     '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '      77     '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '      77     '>\nGOTO PROCESS\nN8: +\nISREDIT LINE &ROW           = LINE + < &COL '  8888888888 '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' 888888888888'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' 88        88'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' 88        88'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '  88      88 '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '   88888888  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '  8888888888 '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' 88        88'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' 88        88'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' 88        88'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' 888888888888'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  8888888888 '>\nGOTO PROCESS\nN9: +\nISREDIT LINE &ROW           = LINE + < &COL '  9999999999 '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL ' 999999999999'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' 99        99'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' 99        99'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' 99        99'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' 999999999999'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '  99999999999'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '           99'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL '           99'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' 99        99'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL ' 999999999999'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  9999999999 '>\nGOTO PROCESS\nN0: +\nISREDIT LINE &ROW           = LINE + < &COL '    000000   '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL '  0000000000 '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' 00        00'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' 00        00'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' 00        00'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' 00        00'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' 00        00'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' 00        00'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' 00        00'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' 00        00'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '  0000000000 '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '    000000   '>\nGOTO PROCESS\nNS1: +\nISREDIT LINE &ROW           = LINE + < &COL '      $$     '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL '  $$$$$$$$$$ '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' $$$$$$$$$$$$'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' $$   $$   $$'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' $$   $$     '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '  $$$$$$$$$  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '   $$$$$$$$$ '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '      $$   $$'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' $$   $$   $$'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' $$$$$$$$$$$$'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '  $$$$$$$$$$ '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '      $$     '>\nGOTO PROCESS\nNS2: +\nISREDIT LINE &ROW           = LINE + < &COL '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' ############'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' ############'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' ############'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' ############'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '   ##    ##  '>\nGOTO PROCESS\nNS3: +\nISREDIT LINE &ROW           = LINE + < &COL '   @@@@@@@@  '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL '  @@@@@@@@@@ '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL ' @@        @@'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL ' @@        @@'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL ' @@  @@@@  @@'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL ' @@ @@  @@ @@'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL ' @@ @@  @@ @@'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL ' @@  @@@@@@@ '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL ' @@          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL ' @@        @@'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL '  @@@@@@@@@@ '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '   @@@@@@@@  '>\nPROCESS: +\n  IF &MAXCC  > 0 THEN DO\n    SET ZEDSMSG = INCOMPLETE BOX\n    SET ZEDLMSG = &STR(NOT ENOUGH LINES/COLUMNS TO DRAW COMPLETE BOX)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    END\n  SET &COL = &COL + 13\n  ISREDIT CURSOR = (ROW,COL)\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BIG@": {"ttr": 8966, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89!O\\x00\\x89!O\\x144\\x00*\\x00*\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-02T00:00:00", "modifydate": "1989-08-02T14:34:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SYSPAJA"}, "text": "1   02/08/89\n                                                      BIG       1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      BIG ISPF/PDF EDIT command      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to create block characters\n  ----------   in text.\n\n  Command syntax : BIG character\n  ---------------- BIG HELP or HE\n\n  Use :        Type BIG on the COMMAND line followed by a character\n  -----        (A-Z, 0-9, $, # or @), set the cursor in the text where\n               you want the block character, and press ENTER, as i.e. :\n               COMMAND ===> BIG A\n               001100   Data ...   - <===\n               001200   Data ...  (CURSOR)\n               001300   Data ...\n               001400   Data ...\n               001500   Data ...\n               001600   Data ...\n               001700   Data ...\n               001800   Data ...\n               001900   Data ...\n               002000   Data ...\n               002100   Data ...\n               Result :\n               001100   Data ...     AAAAAAAAAA\n               001200   Data ...    AAAAAAAAAAAA\n               001300   Data ...    AA        AA\n               001400   Data ...    AA        AA\n               001500   Data ...    AA        AA\n               001600   Data ...    AAAAAAAAAAAA\n               001700   Data ...    AAAAAAAAAAAA\n               001800   Data ...    AA        AA\n               001900   Data ...    AA        AA\n               002000   Data ...    AA        AA\n               002100   Data ...    AA        AA\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BIGS": {"ttr": 8968, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x179\\x02e\\x02e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T17:39:00", "lines": 613, "newlines": 613, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM,BPARM)\n/*  MACRO NAME : BIGS                                               */\n/*    FUNCTION : CREATE SLANTED BLOCK CHARACTERS IN TEXT            */\n/*      SYNTAX : BIGS CHARACTER                                     */\n/*               BIGS HELP OR HE                                    */\n/*       DEBUG : BIGS ... LIST                                      */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n  IF &STR(&BPARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n  SET &TL = &LENGTH(&STR(&APARM))\n  IF &TL \u00ac= 1 THEN DO\n    IF &STR(&APARM) = &STR(HELP) OR +\n      &STR(&APARM) = &STR(HE) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTBIGS)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    ELSE DO\nERRX: SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = ENTER \"BIGS HELP\" COMMAND FOR OPERAND SYNTAX\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  IF &APARM = $ THEN GOTO OK\n  IF &APARM = # THEN GOTO OK\n  IF &APARM = @ THEN GOTO OK\n  IF &APARM < A THEN GOTO ERRX\n  IF &APARM > 9 THEN GOTO ERRX\n  IF &APARM > Z AND &APARM < 0 THEN GOTO ERRX\nOK: +\n  ISREDIT (ROW,COL) = CURSOR\n  SET &COL1 = &COL + 1\n  SET &COL2 = &COL + 2\n  SET &COL3 = &COL + 3\n  SET &COL4 = &COL + 4\n  SET &COL5 = &COL + 5\n  SET &COL6 = &COL + 6\n  SET &COL7 = &COL + 7\n  SET &COL8 = &COL + 8\n  SET &COL9 = &COL + 9\n  SET &COL10 = &COL + 10\n  SET &COL11 = &COL + 11\n  ISPEXEC CONTROL ERRORS RETURN\n  IF &APARM = 1 THEN SET &APARM = &STR(N1)\n  IF &APARM = 2 THEN SET &APARM = &STR(N2)\n  IF &APARM = 3 THEN SET &APARM = &STR(N3)\n  IF &APARM = 4 THEN SET &APARM = &STR(N4)\n  IF &APARM = 5 THEN SET &APARM = &STR(N5)\n  IF &APARM = 6 THEN SET &APARM = &STR(N6)\n  IF &APARM = 7 THEN SET &APARM = &STR(N7)\n  IF &APARM = 8 THEN SET &APARM = &STR(N8)\n  IF &APARM = 9 THEN SET &APARM = &STR(N9)\n  IF &APARM = 0 THEN SET &APARM = &STR(N0)\n  IF &APARM = $ THEN SET &APARM = &STR(NS1)\n  IF &APARM = # THEN SET &APARM = &STR(NS2)\n  IF &APARM = @ THEN SET &APARM = &STR(NS3)\n  GOTO &APARM\nA: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  AAAAAAAAAA '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' AAAAAAAAAAAA'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' AAAAAAAAAAAA'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' AAAAAAAAAAAA'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' AA        AA'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' AA        AA'>\nGOTO PROCESS\nB: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' BBBBBBBBBBB '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' BBBBBBBBBBBB'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' BB        BB'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' BB        BB'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' BB       BB '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' BBBBBBBBBB  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' BBBBBBBBBB  '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' BB       BB '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' BB        BB'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' BB        BB'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' BBBBBBBBBBBB'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' BBBBBBBBBBB '>\nGOTO PROCESS\nC: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  CCCCCCCCCC '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' CCCCCCCCCCCC'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' CC        CC'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' CC          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' CC          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' CC          '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' CC          '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' CC          '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' CC          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' CC        CC'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' CCCCCCCCCCCC'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  CCCCCCCCCC '>\nGOTO PROCESS\nD: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' DDDDDDDDD   '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' DDDDDDDDDD  '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' DD       DD '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' DD        DD'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' DD       DD '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' DDDDDDDDDD  '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' DDDDDDDDD   '>\nGOTO PROCESS\nE: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' EEEEEEEEEEEE'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' EEEEEEEEEEEE'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' EE          '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' EE          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' EE          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' EEEEEEEE    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' EEEEEEEE    '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' EE          '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' EE          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' EE          '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' EEEEEEEEEEEE'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' EEEEEEEEEEEE'>\nGOTO PROCESS\nF: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' FFFFFFFFFFFF'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' FFFFFFFFFFFF'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' FF          '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' FF          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' FF          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' FFFFFFFF    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' FFFFFFFF    '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' FF          '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' FF          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' FF          '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' FF          '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' FF          '>\nGOTO PROCESS\nG: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  GGGGGGGGGG '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' GGGGGGGGGGGG'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' GG        GG'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' GG          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' GG          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' GG          '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' GG     GGGGG'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' GG     GGGGG'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' GG        GG'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' GG        GG'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' GGGGGGGGGGGG'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  GGGGGGGGGG '>\nGOTO PROCESS\nH: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' HHHHHHHHHHHH'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' HHHHHHHHHHHH'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' HH        HH'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' HH        HH'>\nGOTO PROCESS\nI: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  IIIIIIIIII '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         '  IIIIIIIIII '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         '      II     '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        '      II     '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '      II     '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '      II     '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '      II     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '      II     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '      II     '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  '      II     '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '  IIIIIIIIII '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  IIIIIIIIII '>\nGOTO PROCESS\nJ: +\nISREDIT LINE &ROW           = LINE + < &COL11          '   JJJJJJJJJJ'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         '   JJJJJJJJJJ'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         '       JJ    '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        '       JJ    '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '       JJ    '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '       JJ    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '       JJ    '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '       JJ    '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' JJ    JJ    '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' JJ    JJ    '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' JJJJJJJJ    '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  JJJJJJ     '>\nGOTO PROCESS\nK: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' KK        KK'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' KK       KK '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' KK      KK  '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' KK     KK   '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' KK    KK    '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' KKKKKKK     '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' KKKKKKK     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' KK    KK    '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' KK     KK   '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' KK      KK  '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' KK       KK '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' KK        KK'>\nGOTO PROCESS\nL: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' LL          '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' LL          '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' LL          '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' LL          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' LL          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' LL          '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' LL          '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' LL          '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' LL          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' LL          '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' LLLLLLLLLLLL'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' LLLLLLLLLLLL'>\nGOTO PROCESS\nM: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' MMM      MMM'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' MMMM    MMMM'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' MM MM  MM MM'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' MM  MMMM  MM'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' MM   MM   MM'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' MM        MM'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' MM        MM'>\nGOTO PROCESS\nN: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' NN        NN'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' NNN       NN'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' NNNN      NN'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' NN NN     NN'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' NN  NN    NN'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' NN   NN   NN'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' NN    NN  NN'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' NN     NN NN'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' NN      NNNN'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' NN       NNN'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' NN        NN'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' NN         N'>\nGOTO PROCESS\nO: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' OOOOOOOOOOOO'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' OOOOOOOOOOOO'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' OO        OO'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' OOOOOOOOOOOO'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' OOOOOOOOOOOO'>\nGOTO PROCESS\nP: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' PPPPPPPPPPP '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' PPPPPPPPPPPP'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' PP        PP'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' PP        PP'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' PP        PP'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' PPPPPPPPPPPP'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' PPPPPPPPPPP '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' PP          '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' PP          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' PP          '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' PP          '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' PP          '>\nGOTO PROCESS\nQ: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  QQQQQQQQQQ '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' QQQQQQQQQQQQ'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' QQ        QQ'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' QQ        QQ'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' QQ        QQ'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' QQ        QQ'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' QQ        QQ'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' QQ    QQ  QQ'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' QQ     QQ QQ'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' QQ      QQQQ'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' QQQQQQQQQQQ '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  QQQQQQQQ QQ'>\nGOTO PROCESS\nR: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' RRRRRRRRRRR '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' RRRRRRRRRRRR'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' RR        RR'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' RR        RR'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' RR        RR'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' RRRRRRRRRRRR'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' RRRRRRRRRRR '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' RR    RR    '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' RR     RR   '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' RR      RR  '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' RR       RR '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' RR        RR'>\nGOTO PROCESS\nS: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  SSSSSSSSSS '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' SSSSSSSSSSSS'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' SS        SS'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' SS          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' SSS         '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '  SSSSSSSSS  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '   SSSSSSSSS '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '          SSS'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '           SS'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' SS        SS'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' SSSSSSSSSSSS'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  SSSSSSSSSS '>\nGOTO PROCESS\nT: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' TTTTTTTTTTTT'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' TTTTTTTTTTTT'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         '      TT     '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        '      TT     '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '      TT     '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '      TT     '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '      TT     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '      TT     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '      TT     '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  '      TT     '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '      TT     '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '      TT     '>\nGOTO PROCESS\nU: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' UU        UU'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' UUUUUUUUUUUU'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  UUUUUUUUUU '>\nGOTO PROCESS\nV: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' VV        VV'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '  VV      VV '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '   VV    VV  '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  '    VV  VV   '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '     VVVV    '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '      VV     '>\nGOTO PROCESS\nW: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' WW        WW'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' WW   WW   WW'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' WW  WWWW  WW'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' WW WW  WW WW'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' WWWW    WWWW'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' WWW      WWW'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' WW        WW'>\nGOTO PROCESS\nX: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' XX        XX'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' XX        XX'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         '  XX      XX '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        '   XX    XX  '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '    XX  XX   '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '     XXXX    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '     XXXX    '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '    XX  XX   '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '   XX    XX  '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  '  XX      XX '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' XX        XX'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' XX        XX'>\nGOTO PROCESS\nY: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' YY        YY'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' YY        YY'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         '  YY      YY '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        '   YY    YY  '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '    YY  YY   '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '     YYYY    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '      YY     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '      YY     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '      YY     '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  '      YY     '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '      YY     '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '      YY     '>\nGOTO PROCESS\nZ: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' ZZZZZZZZZZZZ'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' ZZZZZZZZZZZZ'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         '          ZZ '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        '         ZZ  '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '        ZZ   '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '       ZZ    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '      ZZ     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '     ZZ      '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '    ZZ       '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  '   ZZ        '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '  ZZZZZZZZZZZ'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' ZZZZZZZZZZZZ'>\nGOTO PROCESS\nN1: +\nISREDIT LINE &ROW           = LINE + < &COL11          '      11     '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         '     111     '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         '    1111     '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        '      11     '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '      11     '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '      11     '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '      11     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '      11     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '      11     '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  '      11     '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '  1111111111 '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  1111111111 '>\nGOTO PROCESS\nN2: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  22222222   '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' 22222222222 '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         '  22       22'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        '           22'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '           22'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '          22 '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '        22   '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '      22     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '    22       '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  '  22         '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' 222222222222'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' 222222222222'>\nGOTO PROCESS\nN3: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  33333333   '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         '  3333333333 '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         '  33       33'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        '           33'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '           33'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '       333333'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '       333333'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '           33'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '           33'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' 33        33'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' 333333333333'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  3333333333 '>\nGOTO PROCESS\nN4: +\nISREDIT LINE &ROW           = LINE + < &COL11          '        444  '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         '       4444  '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         '      44 44  '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        '     44  44  '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '    44   44  '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '   4444444444'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '  44444444444'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '         44  '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '         44  '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  '         44  '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '         44  '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '         44  '>\nGOTO PROCESS\nN5: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' 555555555555'>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' 555555555555'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' 55          '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' 55          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' 55          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' 55555555    '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' 5555555555  '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '          55 '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '           55'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  '           55'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' 555555555555'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL ' 55555555555 '>\nGOTO PROCESS\nN6: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  666666666  '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' 666666666666'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' 66        66'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' 66          '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' 66          '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' 6666666666  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' 666666666666'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' 66        66'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' 66        66'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' 66        66'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' 666666666666'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  6666666666 '>\nGOTO PROCESS\nN7: +\nISREDIT LINE &ROW           = LINE + < &COL11          ' 77777777777 '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' 77777777777 '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' 77      77  '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        '        77   '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '       77    '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '      77     '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '      77     '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '      77     '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '      77     '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  '      77     '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '      77     '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '      77     '>\nGOTO PROCESS\nN8: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  888888888  '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' 888888888888'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' 88        88'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' 88        88'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '  88      88 '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '   88888888  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '   88888888  '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '  88      88 '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' 88        88'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' 88        88'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' 888888888888'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  8888888888 '>\nGOTO PROCESS\nN9: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  999999999  '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' 999999999999'>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' 99        99'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' 99        99'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' 99        99'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' 999999999999'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '   9999999999'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '           99'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   '           99'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' 99        99'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 ' 999999999999'>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '  99999999999'>\nGOTO PROCESS\nN0: +\nISREDIT LINE &ROW           = LINE + < &COL11          '   00000     '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         '  00000000   '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' 00       00 '>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' 00       00 '>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' 00       00 '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' 00       00 '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' 00       00 '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' 00       00 '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' 00       00 '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' 00       00 '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '  000000000  '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '    000000   '>\nGOTO PROCESS\nNS1: +\nISREDIT LINE &ROW           = LINE + < &COL11          '      $$     '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         '   $$$$$$$$$ '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         '  $$$$$$$$$$$'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' $$   $$   $$'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' $$   $$     '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' $$$$$$$$$$  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '   $$$$$$$$$$'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '      $$   $$'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' $$   $$   $$'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' $$$$$$$$$$$ '>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '  $$$$$$$$$  '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '      $$     '>\nGOTO PROCESS\nNS2: +\nISREDIT LINE &ROW           = LINE + < &COL11          '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' ############'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' ############'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' ############'>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' ############'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '   ##    ##  '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '   ##    ##  '>\nGOTO PROCESS\nNS3: +\nISREDIT LINE &ROW           = LINE + < &COL11          '  @@@@@@@@   '>\nISREDIT LINE &EVAL(&ROW+1)  = LINE + < &COL10         ' @@@@@@@@@@@ '>\nISREDIT LINE &EVAL(&ROW+2)  = LINE + < &COL9         ' @@        @@'>\nISREDIT LINE &EVAL(&ROW+3)  = LINE + < &COL8        ' @@        @@'>\nISREDIT LINE &EVAL(&ROW+4)  = LINE + < &COL7       ' @@  @@@@  @@'>\nISREDIT LINE &EVAL(&ROW+5)  = LINE + < &COL6      ' @@ @@  @@ @@'>\nISREDIT LINE &EVAL(&ROW+6)  = LINE + < &COL5     ' @@ @@  @@ @@'>\nISREDIT LINE &EVAL(&ROW+7)  = LINE + < &COL4    ' @@   @@@@@@@'>\nISREDIT LINE &EVAL(&ROW+8)  = LINE + < &COL3   ' @@          '>\nISREDIT LINE &EVAL(&ROW+9)  = LINE + < &COL2  ' @@        @@'>\nISREDIT LINE &EVAL(&ROW+10) = LINE + < &COL1 '  @@@@@@@@@@ '>\nISREDIT LINE &EVAL(&ROW+11) = LINE + < &COL '    @@@@@@@  '>\nPROCESS: +\n  IF &MAXCC  > 0 THEN DO\n    SET ZEDSMSG = INCOMPLETE BOX\n    SET ZEDLMSG = &STR(NOT ENOUGH LINES/COLUMNS TO DRAW COMPLETE BOX)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    END\n  SET &COL = &COL + 13\n  ISREDIT CURSOR = (ROW,COL)\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BIGS@": {"ttr": 9223, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89!O\\x00\\x89!O\\x145\\x00*\\x00*\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-02T00:00:00", "modifydate": "1989-08-02T14:35:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SYSPAJA"}, "text": "1   02/08/89\n                                                      BIGS      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     BIGS ISPF/PDF EDIT command      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to create slanted block\n  ----------   characters in text.\n\n  Command syntax : BIGS character\n  ---------------- BIGS HELP or HE\n\n  Use :        Type BIGS on the COMMAND line followed by a character\n  -----        (A-Z, 0-9, $, # or @), set the cursor in the text where\n               you want the block character, and press ENTER, as i.e. :\n               COMMAND ===> BIGS A\n               001100   Data ...   - <===\n               001200   Data ...  (CURSOR)\n               001300   Data ...\n               001400   Data ...\n               001500   Data ...\n               001600   Data ...\n               001700   Data ...\n               001800   Data ...\n               001900   Data ...\n               002000   Data ...\n               002100   Data ...\n               Result :\n               001100   Data ...               AAAAAAAAAA\n               001200   Data ...             AAAAAAAAAAAA\n               001300   Data ...            AA        AA\n               001400   Data ...           AA        AA\n               001500   Data ...          AA        AA\n               001600   Data ...         AAAAAAAAAAAA\n               001700   Data ...        AAAAAAAAAAAA\n               001800   Data ...       AA        AA\n               001900   Data ...      AA        AA\n               002000   Data ...     AA        AA\n               002100   Data ...    AA        AA\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BLOCK": {"ttr": 9225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x179\\x02\\xa1\\x02\\xa1\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T17:39:00", "lines": 673, "newlines": 673, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM)\n/*  MACRO NAME : BLOCK                                              */\n/*    FUNCTION : CREATE MULTIPLE BLOCK CHARACTERS IN TEXT           */\n/*               (SUPER-TYPE-TEXT)                                  */\n/*      SYNTAX : BLOCK T=STRING TO GENERATE AFTER POINTED LINE      */\n/*               BLOCK OR BLOCK T=                                  */\n/*                   AND STRING TO GENERATE READ FROM POINTED LINE  */\n/*               BLOCK HELP OR H                                    */\n/*       DEBUG : USE L= IN PLACE OF T=                              */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n/*      UPDATE : SOME CHANGED FROM ORIGINAL (MOINIL P.A.)           */\n  SET &AMPSD = &STR(&&)\n  SET &TL = &LENGTH(&NRSTR(&APARM))\n  IF &TL = 1 AND &NRSTR(&APARM) = &STR(H) OR +\n    &TL = 4 AND &NRSTR(&APARM) = &STR(HELP) THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTSTT1)\n      SET &RCX = &LASTCC\n      ISPEXEC CONTROL DISPLAY RESTORE\n      EXIT CODE(&RCX)\n      END\n  CONTROL MSG\n  IF &TL > 2 THEN DO\n    SET &TC = &SUBSTR(1:2,&NRSTR(&APARM))\n    IF &STR(&TC) = &STR(L=) THEN CONTROL LIST SYMLIST CONLIST\n    IF &STR(&TC) = &STR(T=) OR +\n      &STR(&TC) = &STR(L=) THEN +\n      SET &CHARS = &SUBSTR(3:&TL,&NRSTR(&APARM))\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = ENTER \"BLOCK HELP\" COMMAND FOR OPERAND SYNTAX\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  IF &TL < 3 THEN DO\n    IF &TL = 2 AND &NRSTR(&APARM) = &NRSTR(L=) THEN +\n      CONTROL LIST SYMLIST CONLIST\n    IF &NRSTR(&APARM.) = &STR() OR +\n      &TL = 2 AND ( &NRSTR(&APARM) = &NRSTR(T=) OR +\n      &NRSTR(&APARM) = &NRSTR(L=) ) THEN DO\n        ISREDIT (ROW,COL) = CURSOR\n        ISPEXEC CONTROL ERRORS RETURN\n        ISREDIT (CHARS) = LINE &ROW\n        IF &LASTCC = 12 THEN DO\n          SET ZEDSMSG = OPERAND MISSING\n          SET ZEDLMSG = ENTER \"BLOCK HELP\" COMMAND FOR OPERAND SYNTAX\n          ISPEXEC SETMSG MSG(ISRZ000)\n          EXIT CODE(0)\n          END\n        ISPEXEC CONTROL ERRORS CANCEL\n        SET &CHARS = &CHARS\n        SET &ROW = &ROW + 1\n        END\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = ENTER \"BLOCK HELP\" COMMAND FOR OPERAND SYNTAX\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  SET &X = &LENGTH(&NRSTR(&CHARS))\n  IF &X = 0 THEN EXIT\n  ISREDIT (XLB,XRB) = BOUNDS\n  SET &XNCL = (&XRB-&XLB) + 1\n  SET &XNC = &XNCL / 6\n  SET &XNL = &X / &XNC\n  SET &XW = &XNL * &XNC\n  IF &XW \u00ac= &X THEN SET &XNL = &XNL + 1\n  SET &XNL = &XNL * 6\n  IF &X < &XNC THEN SET &XSC = 1\n  ELSE SET &XSC = (((&XNCL - (&XNC*6)) + 1) / 2) + 1\n  ISREDIT LOCATE 1\n  IF &LASTCC = 8 THEN DO\n    ISREDIT NONUM\n    SET &XN = 0\n    ISREDIT MASKLINE = 'X'\n    DO WHILE &XN < &XNL\n      ISREDIT LINE_AFTER &XN = MASKLINE\n      SET &XN = &XN + 1\n      END\n    ISREDIT C 'X' ' ' ALL\n    END\n  ELSE DO\n    ISREDIT LOCATE .ZCSR\n    ISREDIT MASKLINE = '{'\n    ISREDIT LINE_AFTER .ZCSR = MASKLINE\n    SET &XN = 1\n    DO WHILE &XN < &XNL\n      ISREDIT (LINEPTR) = LINENUM .ZCSR\n      SET &LINEPTR = &LINEPTR + &XN\n      ISREDIT LINE_AFTER &LINEPTR = MASKLINE\n      SET &XN = &XN + 1\n      END\n    ISREDIT C '{' ' ' ALL\n    END\n  ISREDIT MASKLINE = ' '\n  ISREDIT RESET\n  ISPEXEC CONTROL ERRORS RETURN\n  ISREDIT (ROW,COL) = CURSOR\n  SET &ROW = &ROW + 1\n  SET ROWX = &ROW\n  SET ROWN = &ROW\n  ISREDIT (REC) = LINE &ROW\n  SET &XN = 0\n  SET &XROW = &XNC + 1\n  SET &XCOL = 1\nLOOP: +\n  SET &XN = &XN + 1\n  IF &XN LE &X THEN DO\n    SET &LTR = &SUBSTR(&XN:&XN,&NRSTR(&CHARS))\n    IF &XN = &XROW THEN DO\n      SET &ROW = &ROW + 6\n      SET &XROW = &XROW + &XNC\n      END\n    IF &XN = &XCOL THEN DO\n      SET &COL = &XSC\n      SET &XCOL = &XCOL + &XNC\n      END\n    ELSE DO\n      SET &COL = &COL + 6\n      IF &SPA = Y THEN SET &COL = &COL - 3\n      END\n    SET &SPA =\n    END\n  IF &XN > &X THEN DO\n    IF &X < &XNC THEN DO\n      SET &D = &EVAL((&XNCL-(&X*6))+1)\n      SET &OVER = &EVAL(&D/2)\n      ISREDIT (BOUNDS) 1 &XNCL\n      SET &ROW = &ROWX\n      ISREDIT NULLS ON\n      ISREDIT (CURSOR) = &ROW 1\n      ISREDIT SHIFT ) &ROW &OVER\n      ISREDIT SHIFT ) &EVAL(&ROW + 1) &OVER\n      ISREDIT SHIFT ) &EVAL(&ROW + 2) &OVER\n      ISREDIT SHIFT ) &EVAL(&ROW + 3) &OVER\n      ISREDIT SHIFT ) &EVAL(&ROW + 4) &OVER\n      ISREDIT NULLS OFF\n      END\n    ISREDIT LOCATE &ROWN\n    EXIT\n    END\n  IF &NRSTR(&LTR) = &STR(A) THEN GOTO C01\n  IF &NRSTR(&LTR) = &STR(B) THEN GOTO C02\n  IF &NRSTR(&LTR) = &STR(C) THEN GOTO C03\n  IF &NRSTR(&LTR) = &STR(D) THEN GOTO C04\n  IF &NRSTR(&LTR) = &STR(E) THEN GOTO C05\n  IF &NRSTR(&LTR) = &STR(F) THEN GOTO C06\n  IF &NRSTR(&LTR) = &STR(G) THEN GOTO C07\n  IF &NRSTR(&LTR) = &STR(H) THEN GOTO C08\n  IF &NRSTR(&LTR) = &STR(I) THEN GOTO C09\n  IF &NRSTR(&LTR) = &STR(J) THEN GOTO C10\n  IF &NRSTR(&LTR) = &STR(K) THEN GOTO C11\n  IF &NRSTR(&LTR) = &STR(L) THEN GOTO C12\n  IF &NRSTR(&LTR) = &STR(M) THEN GOTO C13\n  IF &NRSTR(&LTR) = &STR(N) THEN GOTO C14\n  IF &NRSTR(&LTR) = &STR(O) THEN GOTO C15\n  IF &NRSTR(&LTR) = &STR(P) THEN GOTO C16\n  IF &NRSTR(&LTR) = &STR(Q) THEN GOTO C17\n  IF &NRSTR(&LTR) = &STR(R) THEN GOTO C18\n  IF &NRSTR(&LTR) = &STR(S) THEN GOTO C19\n  IF &NRSTR(&LTR) = &STR(T) THEN GOTO C20\n  IF &NRSTR(&LTR) = &STR(U) THEN GOTO C21\n  IF &NRSTR(&LTR) = &STR(V) THEN GOTO C22\n  IF &NRSTR(&LTR) = &STR(W) THEN GOTO C23\n  IF &NRSTR(&LTR) = &STR(X) THEN GOTO C24\n  IF &NRSTR(&LTR) = &STR(Y) THEN GOTO C25\n  IF &NRSTR(&LTR) = &STR(Z) THEN GOTO C26\n  IF &NRSTR(&LTR) = &STR(#) THEN GOTO C27\n  IF &NRSTR(&LTR) = &STR(,) THEN GOTO C28\n  IF &NRSTR(&LTR) = &STR($) THEN GOTO C29\n  IF &NRSTR(&LTR) = &STR(0) THEN GOTO C30\n  IF &NRSTR(&LTR) = &STR(1) THEN GOTO C31\n  IF &NRSTR(&LTR) = &STR(2) THEN GOTO C32\n  IF &NRSTR(&LTR) = &STR(3) THEN GOTO C33\n  IF &NRSTR(&LTR) = &STR(4) THEN GOTO C34\n  IF &NRSTR(&LTR) = &STR(5) THEN GOTO C35\n  IF &NRSTR(&LTR) = &STR(6) THEN GOTO C36\n  IF &NRSTR(&LTR) = &STR(7) THEN GOTO C37\n  IF &NRSTR(&LTR) = &STR(8) THEN GOTO C38\n  IF &NRSTR(&LTR) = &STR(9) THEN GOTO C39\n  IF &NRSTR(&LTR) = &STR(@) THEN GOTO C40\n  IF &NRSTR(&LTR) = &STR(%) THEN GOTO C41\n  IF &NRSTR(&LTR) = &STR(*) THEN GOTO C42\n  IF &NRSTR(&LTR) = &STR(/) THEN GOTO C43\n  IF &NRSTR(&LTR) = &STR(-) THEN GOTO C44\n  IF &NRSTR(&LTR) = &STR(( THEN GOTO C45\n  IF &NRSTR(&LTR) = &STR()) THEN GOTO C46\n  IF &NRSTR(&LTR) = &NRSTR(&AMPSD) THEN GOTO C47\n  IF &NRSTR(&LTR) = &STR(+) THEN GOTO C48\n  IF &NRSTR(&LTR) = &STR(_) THEN GOTO C49\n  IF &NRSTR(&LTR) = &STR(\u00a2) THEN GOTO C50\n  IF &NRSTR(&LTR) = &STR(|) THEN GOTO C51\n  IF &NRSTR(&LTR) = &STR(>) THEN GOTO C52\n  IF &NRSTR(&LTR) = &STR(:) THEN GOTO C53\n  IF &NRSTR(&LTR) = &STR(;) THEN GOTO C54\n  IF &NRSTR(&LTR) = &STR(.) THEN GOTO C55\n  IF &NRSTR(&LTR) = &STR(?) THEN GOTO C56\n  IF &NRSTR(&LTR) = &STR(') THEN GOTO C57\n  IF &NRSTR(&LTR) = &STR(=) THEN GOTO C58\n  IF &NRSTR(&LTR) = &STR(!) THEN GOTO C59\n  IF &NRSTR(&LTR) = &STR(<) THEN GOTO C60\n  IF &NRSTR(&LTR) = &STR(\u00ac) THEN GOTO C61\n  IF &NRSTR(&LTR) = &STR( ) THEN GOTO C62\n  IF &NRSTR(&LTR) = &STR(\\) THEN GOTO C63\n  IF &NRSTR(&LTR) = &STR(\u00a6) THEN GOTO C64\n  IF &NRSTR(&LTR) = &STR(\") THEN GOTO C65\n  ISREDIT LINE &ROW          = LINE + < &COL  '*===*'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '*---*'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '*???*'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '*---*'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '*===*'>\n  GOTO LOOP\nC01: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' AAA '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'A   A'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'AAAAA'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'A   A'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'A   A'>\n  GOTO LOOP\nC02: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'BBBB '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'B   B'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'BBBB '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'B   B'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'BBBB '>\n  GOTO LOOP\nC03: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' CCCC'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'C    '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'C    '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'C    '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' CCCC'>\n  GOTO LOOP\nC04: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'DDDD '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'D   D'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'D   D'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'D   D'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'DDDD '>\n  GOTO LOOP\nC05: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'EEEEE'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'E    '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'EEEE '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'E    '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'EEEEE'>\n  GOTO LOOP\nC06: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'FFFFF'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'F    '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'FFFF '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'F    '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'F    '>\n  GOTO LOOP\nC07: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' GGGG'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'G    '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'G  GG'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'G   G'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' GGGG'>\n  GOTO LOOP\nC08: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'H   H'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'H   H'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'HHHHH'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'H   H'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'H   H'>\n  GOTO LOOP\nC09: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' III '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '  I  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  I  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  I  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' III '>\n  GOTO LOOP\nC10: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '  JJJ'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '   J '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '   J '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'J  J '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' JJ  '>\n  GOTO LOOP\nC11: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'K  K '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'K K  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'KK   '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'K K  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'K  K '>\n  GOTO LOOP\nC12: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'L    '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'L    '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'L    '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'L    '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'LLLLL'>\n  GOTO LOOP\nC13: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'M   M'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'MM MM'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'M M M'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'M   M'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'M   M'>\n  GOTO LOOP\nC14: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'N   N'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'NN  N'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'N N N'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'N  NN'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'N   N'>\n  GOTO LOOP\nC15: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'OOOOO'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'O   O'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'O   O'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'O   O'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'OOOOO'>\n  GOTO LOOP\nC16: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'PPPP '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'P   P'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'PPPP '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'P    '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'P    '>\n  GOTO LOOP\nC17: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' QQQ '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'Q   Q'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'Q   Q'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'Q Q Q'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' QQQQ'>\n  GOTO LOOP\nC18: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'RRRR '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'R   R'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'RRRR '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'R  R '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'R   R'>\n  GOTO LOOP\nC19: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' SSSS'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'S    '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  ' SSS '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '    S'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'SSSS '>\n  GOTO LOOP\nC20: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'TTTTT'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '  T  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  T  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  T  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '  T  '>\n  GOTO LOOP\nC21: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'U   U'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'U   U'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'U   U'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'U   U'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' UUU '>\n  GOTO LOOP\nC22: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'V   V'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'V   V'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'V   V'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  ' V V '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '  V  '>\n  GOTO LOOP\nC23: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'W   W'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'W   W'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'W W W'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  'WW WW'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'W   W'>\n  GOTO LOOP\nC24: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'X   X'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  ' X X '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  X  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  ' X X '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'X   X'>\n  GOTO LOOP\nC25: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'Y   Y'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  ' Y Y '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  Y  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  Y  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '  Y  '>\n  GOTO LOOP\nC26: +\n  ISREDIT LINE &ROW          = LINE + < &COL  'ZZZZZ'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '   Z '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  Z  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  ' Z   '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  'ZZZZZ'>\n  GOTO LOOP\nC27: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' # # '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '#####'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  ' # # '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '#####'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' # # '>\n  GOTO LOOP\nC28: +\n  ISREDIT LINE &ROW          = LINE + < &COL  \"     \">\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  \"     \">\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  \"     \">\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  \"  ,, \">\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  \"  ,  \">\n  GOTO LOOP\nC29: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' $$$$'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '$ $  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  ' $$$ '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  $ $'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '$$$$ '>\n  GOTO LOOP\nC30: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' 000 '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '0   0'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '0   0'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '0   0'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' 000 '>\n  GOTO LOOP\nC31: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '  1  '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  ' 11  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  1  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  1  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' 111 '>\n  GOTO LOOP\nC32: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' 222 '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '2   2'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '   2 '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  ' 22  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '22222'>\n  GOTO LOOP\nC33: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '3333 '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '    3'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  ' 333 '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '    3'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '3333 '>\n  GOTO LOOP\nC34: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '  44 '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  ' 4 4 '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '44444'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '   4 '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '   4 '>\n  GOTO LOOP\nC35: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '55555'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '5    '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '5555 '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '    5'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '5555 '>\n  GOTO LOOP\nC36: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' 666 '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '6    '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '6666 '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '6   6'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' 666 '>\n  GOTO LOOP\nC37: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '77777'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '   7 '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  7  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  7  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '  7  '>\n  GOTO LOOP\nC38: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' 888 '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '8   8'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  ' 888 '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '8   8'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' 888 '>\n  GOTO LOOP\nC39: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' 999 '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '9   9'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  ' 9999'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '    9'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' 999 '>\n  GOTO LOOP\nC40: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '@@@@@'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '@   @'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '@ @ @'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '@ @@@'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '@@@@ '>\n  GOTO LOOP\nC41: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '%%  %'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '   % '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  %  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  ' %   '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '%  %%'>\n  GOTO LOOP\nC42: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '*   *'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  ' *** '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '*****'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  ' *** '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '*   *'>\n  GOTO LOOP\nC43: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '    /'>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '   / '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  /  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  ' /   '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '/    '>\n  GOTO LOOP\nC44: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  ' --- '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '     '>\n  GOTO LOOP\nC45: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '   ( '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '  (  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  (  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  (  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '   ( '>\n  GOTO LOOP\nC46: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' )   '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '  )  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  )  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  )  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' )   '>\n  GOTO LOOP\nC47: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' &&&&&&&&&& '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '&&    '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  ' &&&&&&  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '&&   &&'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' &&&&&&&&&&&&&&'>\n  GOTO LOOP\nC48: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '  +  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  ' +++ '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  +  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '     '>\n  GOTO LOOP\nC49: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '_____'>\n  GOTO LOOP\nC50: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' CCC '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  'C    '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  'C    '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  ' CCCC'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '  C  '>\n  GOTO LOOP\nC51: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '  |  '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '  |  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  |  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  |  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '  |  '>\n  GOTO LOOP\nC52: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' >   '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '  >  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '   > '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  >  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' >   '>\n  GOTO LOOP\nC53: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' ..  '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  ' ..  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  ' ..  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' ..  '>\n  GOTO LOOP\nC54: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' ..  '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  ' ..  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  ' ,,  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '  ,  '>\n  GOTO LOOP\nC55: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  ' ..  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' ..  '>\n  GOTO LOOP\nC56: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' ??? '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '?   ?'>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '   ? '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  ?  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '  ?  '>\n  GOTO LOOP\nC57: +\n  ISREDIT LINE &ROW          = LINE + < &COL  \"  '' \">\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  \" ''  \">\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  \"     \">\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  \"     \">\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  \"     \">\n  GOTO LOOP\nC58: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '====='>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '====='>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '     '>\n  GOTO LOOP\nC59: +\n  ISREDIT LINE &ROW          = LINE + < &COL  ' ||  '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  ' ||  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  ' ||  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  ' ..  '>\n  GOTO LOOP\nC60: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '   < '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '  <  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  ' <   '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  <  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '   < '>\n  GOTO LOOP\nC61: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '\u00ac\u00ac\u00ac\u00ac\u00ac'>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '    \u00ac'>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '     '>\n  GOTO LOOP\nC62: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '     '>\n  GOTO LOOP\nC63: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '\\    '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  ' \\   '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '  \\  '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '   \\ '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '    \\'>\n  GOTO LOOP\nC64: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '  \u00a6  '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '  \u00a6  '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '  \u00a6  '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '  \u00a6  '>\n  GOTO LOOP\nC65: +\n  ISREDIT LINE &ROW          = LINE + < &COL  '  \"\" '>\n  ISREDIT LINE &EVAL(&ROW+1) = LINE + < &COL  '  \"\" '>\n  ISREDIT LINE &EVAL(&ROW+2) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+3) = LINE + < &COL  '     '>\n  ISREDIT LINE &EVAL(&ROW+4) = LINE + < &COL  '     '>\n  SET &SPA = Y\n  GOTO LOOP\nERROR OFF\n  ISREDIT CURSOR = (ROW,NEXT)\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BLOCK@": {"ttr": 9481, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\"\\x0f\\x00\\x89\"\\x0f\\x16\\x06\\x00M\\x00M\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-08T00:00:00", "modifydate": "1989-08-08T16:06:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "SYSPAJA"}, "text": "1   08/08/89\n                                                      BLOCK     1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     BLOCK ISPF/PDF EDIT command     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to create multiple block\n  ----------   characters in your text (Super-Type Text macro).\n\n  Syntax :     BLOCK T=string of characters to generate after pointed\n  --------     line.\n               Warning : If the string of characters must contain any\n                         command delimiter character (special character\n                         for command stacking, see ISPF option 0.1),\n                         you must use the next way of entering the\n                         command, otherwise the string will be truncated\n                         at first encountered delimiter character, and\n                         the rest will be handled as another command,\n                         which probably would be invalid.\n               BLOCK or BLOCK T= and string of characters to generate\n                                     read from pointed line\n               BLOCK HELP or H\n\n  Use :        Type BLOCK on the command line followed by T= string of\n  -----        characters that you wish to have in block letters in\n               your text. Then place the cursor on the line where you\n               want the text is to be inserted. The block characters\n               text will be created starting at line after where the\n               cursor is (if it is not within a data line, the first\n               line is assumed as cursor position). An attempt will\n               be made to center the text if only one line of block\n               characters is created. If more than one block-line\n               (requires five data lines) is needed, the starting\n               characters (including spaces) will be on the first\n               indicated block-line, a line is skipped and the next\n               group is created. If more than two block-lines are\n               needed, the next are created after skipping another\n               line, and so on.\n               Warning : Remember no command delimiter character in\n                         the string.\n1   08/08/89\n                                                      BLOCK     1/2.\n\n   Example : COMMAND ===> BLOCK T=HI THERE\n   ****** ***************************** TOP OF DATA *****************...\n   000100 ...\n   000200 ...\n   Result :\n   ****** ***************************** TOP OF DATA *****************...\n   000100 ...\n   000110\n   000120             H   H  III        TTTTT H   H EEEEE RRRR  EEEEE\n   000130             H   H   I           T   H   H E     R   R E\n   000140             HHHHH   I           T   HHHHH EEEE  RRRR  EEEE\n   000150             H   H   I           T   H   H E     R  R  E\n   000160             H   H  III          T   H   H EEEEE R   R EEEEE\n   000200 ...\n\n               To enter a string of characters containing any command\n               delimiter character(s) or to type very long strings, as\n               many as you can get on a line of data, enter the string\n               of characters on a data line within the text. Type BLOCK\n               on the command line, move the cursor to the line with\n               the string typed on it, and press enter. The entire line\n               pointed by the cursor will be read, all leading blanks\n               eliminated, and then used as string of characters.\n               Spacing is up to you, thus you must plan your text so\n               that it appears the way you want it. The line with the\n               string of characters text is preserved.\n\n   Example : COMMAND ===> BLOCK\n   002000 ...\n   002100 ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\n   002200 ...     (The cursor can be placed anywhere on the line above)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CATS": {"ttr": 9484, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x0f\\x00\\x882\\x0f\\x15@\\x04\\xa9\\x04\\xa9\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-15T00:00:00", "modifydate": "1988-11-15T15:40:00", "lines": 1193, "newlines": 1193, "modlines": 0, "user": "SYSPAJA"}, "text": "CTSR     TITLE 'O.S. CATALOG SEQUENTIAL READ SUBROUTINE.'\nCATSR    START 0\n         SPACE 2\n* PURPOSE :    ROUTINE TO READ SEQUENTIALLY AN ENTIRE O.S. CATALOG.\n* ---------    A DD-CARD, WRITTEN AS BELOW, IS NEEDED TO DEFINE\n*              THE DESIRED VOLUME ON WHICH THE O.S. CATALOG RESIDES :\n*\n*              //...     DD  UNIT=...,VOLUME=SER=...,DISP=OLD\n*\n*              OR THE DESIRED O.S. CATALOG :\n*\n*              //...     DD  UNIT=...,VOLUME=SER=...,\n*              //            DSNAME=SYSCTLG,DISP=SHR\n*\n* CALLING SEQUENCE : CALL CATSO,(A,B,C),VL\n* ------------------            (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8).\n*\n*                B - IS THE ADDRESS OF THE DEVICE CHARACTERISTICS\n*                    (FORMAT FULLWORD - F BOUNDARY) RETURNED BY THE\n*                    ROUTINE IF SUPPLIED (OPTIONAL). IT WILL RECEIVE\n*                    FIVE FULLWORDS INFORMATION AS DESCRIBED IN DEVTYPE\n*                    MACRO (SEE OS/VS2 SYSTEM PROGRAMMING LIBRARY :\n*                    DATA MANAGEMENT), FOLLOWED BY ONE HALFWORD\n*                    CONTAINING THE NUMBER OF ALTERNATE TRACKS FOR\n*                    THE DEVICE, FOLLOWED BY A SIX CHARACTERS FIELD\n*                    CONTAINING THE VOLUME SERIAL NUMBER OF THE\n*                    DEVICE. THIS ARGUMENT IS OPTIONAL AND MAY BE\n*                    OMITTED OR HIS ADDRESS MAY BE SET TO ZERO IN THE\n*                    PARAMETERS LIST.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - OPEN CORRECTLY EXECUTED.\n*                     1 - FILE ALREADY OPENED.\n*                     2 - OPEN ERROR.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - NOT OS/VS2 SYSTEM.\n*                     5 - DD-CARD MISSING.\n*                     6 - NOT DIRECT-ACCESS STORAGE DEVICE.\n*                     7 - READ JFCB ERROR.\n*                     8 - DD-CARD INCORRECTLY CODED.\n         EJECT\n* CALLING SEQUENCE : CALL CATSR,(A,B,C,D),VL\n* ------------------            (A,B,C)\n*                               (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF A FIELD (FORMAT XL1,CL44) WHICH\n*                    RECEIVES, AFTER EACH READ OPERATION, UNLESS WHEN\n*                    THE END-OF-FILE IS DETECTED, ONE OF THE FOLLOWING\n*                    INFORMATION :\n*                     - A CVOL POINTER NAME(FORMAT AL1(1),CL8).\n*                     - A DATA-SET NAME (FORMAT AL1(2),CL44).\n*                     - AN ALIAS NAME, FOLLOWED BY THE TRUE NAME INDEX\n*                       (FORMAT AL1(3),CL8,CL8).\n*                     - A NULL INDEX NAME (FORMAT AL1(128),CL8).\n*                     - AN INFORMATION CONTINUATION OF A PREVIOUS NAME\n*                       (FORMAT AL1(255),CL44).\n*\n*                B - IS THE ADDRESS OF A FIELD (FORMAT CL6) WHICH\n*                    RECEIVES THE VOLUME SERIAL NUMBER RELATIVE\n*                    TO THE FIRST ARGUMENT IF PERTINENT, OTHERWISE\n*                    IT IS CLEARED TO BLANKS. THIS ARGUMENT IS\n*                    OPTIONAL AND MAY BE OMITTED OR HIS ADDRESS MAY\n*                    BE SET TO ZERO IN THE PARAMETERS LIST.\n*\n*                C - IS THE ADDRESS OF A FIELD (FORMAT XL4) WHICH\n*                    RECEIVES THE DEVICE TYPE RELATIVE TO THE SECOND\n*                    ARGUMENT IF PERTINENT, OTHERWISE IT IS CLEARED\n*                    TO BLANKS. THIS ARGUMENT IS OPTIONAL AND MAY BE\n*                    OMITTED OR HIS ADDRESS MAY BE SET TO ZERO IN THE\n*                    PARAMETERS LIST.\n*\n*                D - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                    -1 - END-OF-FILE DETECTED.\n*                     0 - READ OPERATION CORRECTLY EXECUTED.\n*                     1 - READ ERROR.\n*                     2 - FILE NOT OPENED.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - INSUFFICIENT CORE STORAGE AT DISPOSAL.\n*                     5 - NO VOLUME INDEX CONTROL ENTRY IN CATALOG.\n*                     6 - UNEXPECTED CATALOG ENTRY ENCOUNTERED.\n*                     7 - INVALID TERMINATION OF A CATALOG BLOCK.\n*                     8 - INDEX WITH WRONG OR NO INDEX CONTROL ENTRY.\n*\n*        NOTE : REGISTER 1 IS ALWAYS 0 (ZERO) AT RETURN, UNLESS WHEN\n*               A GENERATION DATA GROUP NAME HAS BEEN BUILDED, IT IS\n*               SET TO 1 (ONE). BE CAREFULL THAT THE CONDITION IS NOT\n*               MAINTAINED ON EVENTUAL CONTINUATIONS.\n         EJECT\n* CALLING SEQUENCE : CALL CATSC,(A,B),VL\n* ------------------            (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE CATALOG CONTROL INFORMATION\n*                    (FORMAT FULLWORD - F BOUNDARY) RETURNED BY THE\n*                    ROUTINE IF SUPPLIED (OPTIONAL : ARGUMENT MAY BE\n*                    OMITTED PASSING A ZERO PARAMETERS LIST POINTER,\n*                    REGISTER 1, WHEN THE NEXT IS ALSO OMITTED, OR HIS\n*                    ADDRESS MAY BE ZERO IN THE PARAMETERS LIST).\n*                    IT WILL RECEIVE FOUR FULLWORDS INFORMATION AS\n*                    DESCRIBED BELOW :\n*                     - THE RELATIVE TRACK ADDRESS OF THE LAST BLOCK\n*                       OF THE VOLUME INDEX (FORMAT F'0TTR').\n*                     - THE RELATIVE TRACK ADDRESS OF THE LAST BLOCK\n*                       IN SYSCTLG (FORMAT F'0TTR').\n*                     - THE RELATIVE TRACK ADDRESS OF THE FIRST UNUSED\n*                       BLOCK IN SYSCTLG (FORMAT F'0TTR').\n*                     - THE RELATIVE TRACK ADDRESS OF THE UPPER USED\n*                       BLOCK IN SYSCTLG (FORMAT F'0TTR').\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*\n* GENERAL NOTICE : MVS/XA : MUST BE AMODE AND RMODE 24.\n* ================\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n         SPACE 2\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               SET SWITCH NOP OPERATION.\nON       EQU   X'F0'               SET SWITCH BRANCH OPERATION.\n         EJECT\n*        EXECUTE DIRECT ACCESS PROGRAM CONTROL BLOCKS (XDAP).\n*        ----------------------------------------------------\n         SPACE 1\nXDSECT   DSECT\n         SPACE 1\nECB      DS    XL1                 EVENT CONTROL BLOCK.\nECBCC    DS    XL3\n         SPACE 1\nIOB      DS    0F                  INPUT/OUTPUT BLOCK.\nIOBFLAG1 DS    XL1                 I/O FLAGS.\nIOBFLAG2 DS    XL1                 I/O FLAGS.\nIOBSENS0 DS    XL1                 FIRST SENSE BYTE.\nIOBSENS1 DS    XL1                 SECOND SENSE BYTE.\nIOBECBCC DS    XL1                 COMPLETION CODE.\nIOBECBPT DS    AL3                 ADDRESS OF ECB.\nIOBFLAG3 DS    XL1                 I/O ERROR FLAGS.\nIOBCSW   DS    XL7                 SEVEN LOW-ORDER BYTES OF LAST CSW.\nIOBSIOCC DS    XL1                 SIO CONDITION CODE.\nIOBSTART DS    AL3                 ADDRESS OF CHANNEL PROGRAM.\n         DS    XL1\nIOBDCBPT DS    AL3                 ADDRESS OF DCB.\nIOBRESTR DS    2F                  IOBINCAM, IOBERRCT.\nIOBSEEK  DS    2F                  NO. OF DEB EXT. AND SEEK ADDRESS.\n         SPACE 2\nCATSR    CSECT                     RESTORE ORIGINAL CSECT.\n         EJECT\n        PRINT  NOGEN\n         SPACE 2\nTIODSECT DSECT\n         SPACE 1\n        IEFTIOT1\n         SPACE 1\nCATSR    CSECT                     RESTORE ORIGINAL CSECT.\n         SPACE 2\n        CVT    DSECT=YES,LIST=YES\n         SPACE 1\nCATSR    CSECT                     RESTORE ORIGINAL CSECT.\n         SPACE 2\nJFCDSECT DSECT\n         SPACE 1\n        IEFJFCBN LIST=YES\n         SPACE 1\nCATSR    CSECT                     RESTORE ORIGINAL CSECT.\n         SPACE 2\n        DCBD   DSORG=PS,DEVD=DA\n         SPACE 1\nCATSR    CSECT                     RESTORE ORIGINAL CSECT.\n         SPACE 2\n        PRINT  GEN\n         EJECT\n        $CTLGD\n         EJECT\n*        ----------------------------\n*        CATALOG'S BLOCK AREAS CHAIN.\n*        ----------------------------\n         SPACE 1\n*        /BLOCKMA/    +0  = ADDRESS OF /1/ (START OF CHAIN).\n*\n*        /1/          +0  = FLAG BYTE.\n*                     +1  = CURRENT TTR.\n*                     +4  = ADDRESS OF /2/.\n*                     +8  = 0 (ZERO).\n*                     +12 = DATA START/CURRENT ADDRESS.\n*                     +16 = DATA END ADDRESS.\n*                     +20 = KEY, COUNT AND DATA (CATALOG RECORD).\n*\n*        /2/          +0  = FLAG BYTE.\n*                     +1  = CURRENT TTR.\n*                     +4  = ADDRESS OF /3/.\n*                     +8  = ADDRESS OF /1/.\n*                     +12 = DATA START/CURRENT ADDRESS.\n*                     +16 = DATA END ADDRESS.\n*                     +20 = KEY, COUNT AND DATA (CATALOG RECORD).\n*        ...\n*        ...   ETC...\n*        ...\n*\n*        /N-1/        +0  = FLAG BYTE.\n*                     +1  = CURRENT TTR.\n*                     +4  = ADDRESS OF /N/.\n*                     +8  = ADDRESS OF /N-2/.\n*                     +12 = DATA START/CURRENT ADDRESS.\n*                     +16 = DATA END ADDRESS.\n*                     +20 = KEY, COUNT AND DATA (CATALOG RECORD).\n*\n*        /N/          +0  = FLAG BYTE.\n*                     +1  = CURRENT TTR.\n*                     +4  = 0 (ZERO).\n*                     +8  = ADDRESS OF /N-1/.\n*                     +12 = DATA START/CURRENT ADDRESS.\n*                     +16 = DATA END ADDRESS.\n*                     +20 = KEY, COUNT AND DATA (CATALOG RECORD).\n         EJECT\n*        CATALOG'S BLOCK AREAS DEFINITIONS.\n*        ----------------------------------\n         SPACE 1\nFLAG     EQU   0                   FLAG BYTE DISPLACEMENT.\nFREE     EQU   X'10'               FREE CATALOG'S BLOCK AREA FLAG.\nRTTR     EQU   1                   CURRENT TTR DISPLACEMENT.\nNXA      EQU   4                   NEXT BLOCK AREA IN CHAIN DISPL.\nNXP      EQU   8                   PREVIOUS BLOCK AREA IN CHAIN DISPL.\nDSCA     EQU   12                  DATA START/CURRENT ADDRESS DISPL.\nDEA      EQU   16                  DATA END ADDRESS DISPLACEMENT.\n         SPACE 1\nPRFX     EQU   20                  CATALOG'S BLOCK PREFIX LENGTH.\nKLG      EQU   8                   CATALOG'S RECORD KEY LENGTH.\nRLG      EQU   KLG+256             CATALOG'S RECORD LENGTH.\nBLG      EQU   ((PRFX+RLG+7)/8)*8  GETMAIN - FREEMAIN BLOCKS LENGTH.\n         EJECT\n         ENTRY CATSO\n         ENTRY CATSC\n         SPACE 1\n         USING *,R15\n         MVI   WTGO+3,CATS-*       SET ENTRY DISPLACEMENT (READ).\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nCATSO    MVI   WTGO+3,CATS-*       SET ENTRY DISPLACEMENT (OPEN).\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nCATSC    MVI   WTGO+3,CATS-*       SET ENTRY DISPLACEMENT (CLOSE).\n         DROP  R15\n         SPACE 1\nWTGO     LA    R15,*-*(R15)        SET COMMON ENTRY ADDRESS.\n         SPACE 1\nCATS    $XENT BASE=(R11,R12)\n         OI    GDGSW+1,ON\n         LR    R15,R11             COMPUTE WHERE TO GO?\n         BCTR  R15,0\n         SR    R14,R14\n         IC    R14,0(R15)\n         SRL   R14,1\n         B     *+L'*-(CATS-WTGO)+0(R14) ENTER SELECTED ROUTINE.\n         SPACE 1\n         B     CTCLOSE             BRANCH ENTRIES VECTOR.\n         B     CTOPEN\n         EJECT\n         SR    R9,R9\n         SR    R8,R8\n         SR    R7,R7\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    RD3\n         TM    4(R1),X'80'\n         BO    RD2\n         TM    8(R1),X'80'\n         BO    RD1\n         TM    12(R1),X'80'\n         BZ    ERR3\n         TM    15(R1),X'03'\n         BNZ   ERR3\n         L     R9,12(R1)\n         LA    R9,0(R9)\nRD1      L     R8,8(R1)\n         LA    R8,0(R8)\n         LTR   R8,R8\n         BZ    RD2\n         XC    0(4,R8),0(R8)\nRD2      L     R7,4(R1)\n         LA    R7,0(R7)\n         LTR   R7,R7\n         BZ    RD3\n         MVI   0(R7),C' '\n         MVC   1(5,R7),0(R7)\nRD3      L     R6,0(R1)\n         LA    R6,0(R6)\n         LTR   R6,R6\n         BZ    ERR3\n         MVI   0(R6),0\n         MVI   1(R6),C' '\n         MVC   2(L'DSNAME-1,R6),1(R6)\n         LA    R1,DCBSR\n         USING IHADCB,R1\n         TM    DCBOFLGS,DCBOFOPN   TEST IF OPENED?\n         BZ    ERR2                BRANCH IF NOT.\n         DROP  R1\n         STM   R6,R8,SVPARM\nSWFIRST  B     GETFCBA\n         LM    R6,R8,SVBACK        RESTORE ALL REGISTERS.\n         L     R14,SVLINK\n         BR    R14                 CONTINUE PROCESSING.\n         SPACE 2\nGETFCBA  NI    SWFIRST+1,OFF\n         BAL   R14,GETAR           GET FIRST CATALOG'S BLOCK AREA.\n         ST    R1,BLOCKMA\n         OI    FLAG(R1),FREE\n         LA    R0,1\n         ST    R0,HIGHTTR\n         BAL   R14,XREAD           READ STARTING CATALOG'S BLOCK.\n         ST    R1,CATMA\n         LM    R7,R8,DSCA(R1)      GET BLOCK POINTERS.\n         USING CTLDSECT,R7\n         CLI   VTYPE,X'05'         TEST VICE ENTRY.\n         BNE   ERR5\n         SPACE 2\n*        VOLUME INDEX CONTROL ENTRY (VICE).\n         SPACE 1\n         CLC   VNAME,ONE\n         BNE   ERR5\n         MVC   TTRLVI+L'TTRLVI-L'VLSTBLK(L'VLSTBLK),VLSTBLK\n         MVC   TTRL+L'TTRL-L'VCLSTBLK(L'VCLSTBLK),VCLSTBLK\n         MVC   TTRFU+L'TTRFU-L'VFHOLE(L'VFHOLE),VFHOLE\n         LA    R7,ELENGTH+5*2(R7)  VICE LENGTH.\n         CLR   R7,R8\n         BNL   ENDSR               ONLY VICE IN CATALOG.\n         SPACE 2\nNEXT     CLI   ETYPE,X'05'         TEST CVPE ENTRY.\n         BE    CVPE\n         CLI   ETYPE,X'03'\n         BE    CVPE\n         CLI   ETYPE,X'00'         TEST ILE OR IPE ENTRY.\n         BE    ILEIPE\n         CLI   ETYPE,X'02'         TEST GIPE ENTRY.\n         BE    GIPE\n         CLI   ETYPE,X'07'         TEST DSPE ENTRY.\n         BE    DSPE\n         CLI   ETYPE,X'0D'\n         BE    DSPE\n         CLI   ETYPE,X'13'\n         BE    DSPE\n         CLI   ETYPE,X'19'\n         BE    DSPE\n         CLI   ETYPE,X'1F'\n         BE    DSPE\n         CLI   ETYPE,X'01'         TEST VCBPE ENTRY.\n         BE    VCBPE\n         CLI   ETYPE,X'04'         TEST AE ENTRY.\n         BE    AE\n         B     ERR6\n         SPACE 2\n*        CONTROL VOLUME POINTER ENTRY (CVPE).\n         SPACE 1\nCVPE     L     R1,SVPARM\n         MVI   0(R1),1\n         MVC   1(L'ENAME,R1),ENAME\n         L     R1,SVPARM+4\n         CLI   ETYPE,X'03'\n         BNE   CVPEN               BRANCH IF CVPE NEW FORMAT.\n         LTR   R1,R1\n         BZ    CVPEP\n         MVC   0(L'EVOLIDO,R1),EVOLIDO\n         B     CVPEP\nCVPEN    LTR   R1,R1\n         BZ    *+L'*+6\n         MVC   0(L'EVOLID,R1),EVOLID\n         L     R1,SVPARM+8\n         LTR   R1,R1\n         BZ    CVPEP\n         MVC   0(L'EDEVTYP,R1),EDEVTYP\nCVPEP    BAL   R14,EXRET\n         CLI   ETYPE,X'03'\n         LA    R7,ELENGTH+3*2(R7)  OLD CVPE LENGTH.\n         BE    *+L'*+4\n         LA    R7,2*2(R7)          NEW CVPE LENGTH.\n         CLR   R7,R8\n         BL    NEXT\n         B     ERR7\n         SPACE 2\n*        DATA SET POINTER ENTRY (DSPE).\n         SPACE 1\nDSPE     BAL   R14,GDGN\n         L     R1,SVPARM\n         MVI   0(R1),2\n         MVC   1(L'ENAME,R1),ENAME\n         LH    R6,EVOLCNT\n         B     DSPE2\nDSPE1    L     R1,SVPARM\n         MVI   0(R1),255\nDSPE2    L     R1,SVPARM+4\n         LTR   R1,R1\n         BZ    *+L'*+6\n         MVC   0(6,R1),EDATA+4\n         L     R1,SVPARM+8\n         LTR   R1,R1\n         BZ    *+L'*+6\n         MVC   0(4,R1),EDATA\n         BAL   R14,EXRET\n         LA    R7,L'EDATA(R7)\n         BCT   R6,DSPE1\n         LA    R7,ELENGTH+1*2(R7)  DSPE LENGTH.\n         CLR   R7,R8\n         BNL   ERR7                INVALID BLOCK TERMINATION.\n         B     NEXT\n         SPACE 2\n*        VOLUME CONTROL BLOCK POINTER ENTRY (VCBPE).\n         SPACE 1\nVCBPE    BAL   R14,GDGN\n         L     R1,SVPARM\n         MVI   0(R1),2\n         MVC   1(L'ENAME,R1),ENAME\n         MVC   WORK+1(L'ETTR),ETTR SET TTR FOR READ.\n         STM   R7,R8,VCBPTR\n         OI    SWVCB+1,ON          SET BRANCH OPERATION.\n         B     VCBPE2\nVCBPE1   L     R1,SVPARM\n         MVI   0(R1),255\nVCBPE2   NI    SWNXV+1,OFF         SET NOP OPERATION.\n         L     R0,WORK\n         BAL   R14,XREAD           READ A VCB.\n         ST    R1,VCBBA\n         L     R7,DSCA(R1)         GET BLOCK POINTER.\n         SPACE 2\n*        VOLUME CONTROL BLOCK (VCB).\n         SPACE 1\n         LH    R2,VCBVOLCT\n         LA    R6,20\n         CLR   R2,R6\n         BH    VCBPE4\n         LR    R6,R2\n         OI    SWNXV+1,ON          SET BRANCH OPERATION.\n         B     VCBPE4\nVCBPE3   L     R1,SVPARM\n         MVI   0(R1),255\nVCBPE4   L     R1,SVPARM+4\n         LTR   R1,R1\n         BZ    *+L'*+6\n         MVC   0(6,R1),VCBVOLS+4\n         L     R1,SVPARM+8\n         LTR   R1,R1\n         BZ    *+L'*+6\n         MVC   0(4,R1),VCBVOLS\n         BAL   R14,EXRET\n         LA    R7,L'VCBVOLS(R7)\n         BCT   R6,VCBPE3\n         L     R1,VCBBA\n         OI    FLAG(R1),FREE       RELEASE BLOCK AREA.\nSWNXV    NOP   VCBPE5\n         L     R7,DSCA(R1)\n         MVC   WORK+1(L'ETTR),VCBVOLS+(20*L'VCBVOLS)+10\n         B     VCBPE1\nVCBPE5   NI    SWVCB+1,OFF         SET NOP OPERATION.\n         LM    R7,R8,VCBPTR\n         LA    R7,ELENGTH+1*2(R7)  VCBPE LENGTH.\n         CLR   R7,R8\n         BNL   ERR7                INVALID BLOCK TERMINATION.\n         B     NEXT\n         SPACE 2\n*        ALIAS ENTRY (AE).\n         SPACE 1\nAE       L     R1,SVPARM\n         MVI   0(R1),3\n         MVC   1(L'ENAME,R1),ENAME\n         MVC   1+L'ENAME(L'ETRUEN,R1),ETRUEN\n         BAL   R14,EXRET\n         LA    R7,ELENGTH+4*2(R7)  AE LENGTH.\n         CLR   R7,R8\n         BNL   ERR7                INVALID BLOCK TERMINATION.\n         B     NEXT\n         SPACE 2\nILEIPE   CLC   ENAME,MONE          TEST ILE ENTRY.\n         BNE   IPE\n         SPACE 2\n*        INDEX LINK ENTRY (ILE).\n         SPACE 1\n         CLC   ETTR(L'ETTR),ZEROS  ANY OTHER BLOCK?\n         BE    ENDSR               BRANCH IF END.\n         MVC   WORK+1(L'ETTR),ETTR SET TTR FOR READ.\n         L     R1,CATMA\n         OI    FLAG(R1),FREE       RELEASE BLOCK AREA.\n         L     R0,WORK\n         BAL   R14,XREAD           READ NEXT BLOCK.\n         ST    R1,CATMA\n         LM    R7,R8,DSCA(R1)      GET BLOCK POINTERS.\n         B     NEXT\n         SPACE 2\n*        GENERATION INDEX POINTER ENTRY (GIPE).\n         SPACE 1\nGIPE     LA    R14,ELENGTH+2*2(R7) GIPE LENGTH.\n         NI    GDGSW+1,OFF\n         B     IPE+L'IPE\n         SPACE 2\n*        INDEX POINTER ENTRY (IPE).\n         SPACE 1\nIPE      LA    R14,ELENGTH(R7)     IPE LENGTH.\n         L     R1,CATMA\n         ST    R14,DSCA(R1)        SAVE CURRENT POINTER.\n         SR    R2,R2               START LEVEL(S).\nIPELP    ST    R2,INDEX\n         SLL   R2,3\n         LA    R1,NAMEDS(R2)\n         MVC   0(L'ENAME,R1),ENAME STORE INDEX NAME.\n         MVC   WORK+1(L'ETTR),ETTR SET TTR FOR READ.\n         L     R0,WORK\n         BAL   R14,XREAD           READ BLOCK CONTINUATION.\n         SRL   R2,1\n         ST    R1,CATNX(R2)\n         LM    R7,R8,DSCA(R1)      GET BLOCK POINTERS.\n         CLI   ETYPE,X'03'         TEST ICE ENTRY.\n         BNE   ERR8\n         SPACE 2\n*        INDEX CONTROL ENTRY (ICE).\n         SPACE 1\n         CLC   INAME,ONE\n         BNE   ERR8\n         LA    R7,ELENGTH+3*2(R7)  ICE LENGTH.\n         CLR   R7,R8\n         BNL   ERR7                INVALID BLOCK TERMINATION.\n         NI    SWETY+1,OFF         SET NOP OPERATION.\n         SPACE 2\nNXT      CLI   ETYPE,X'00'         TEST ILE OR IPE ENTRY.\n         BE    ILPE\n         CLI   ETYPE,X'02'         TEST GIPE ENTRY.\n         BE    GIPEN\n         CLI   ETYPE,X'07'         TEST DSPE ENTRY.\n         BE    DSPEN\n         CLI   ETYPE,X'0D'\n         BE    DSPEN\n         CLI   ETYPE,X'13'\n         BE    DSPEN\n         CLI   ETYPE,X'19'\n         BE    DSPEN\n         CLI   ETYPE,X'1F'\n         BE    DSPEN\n         CLI   ETYPE,X'01'         TEST VCBPE ENTRY.\n         BE    VCBPEN\n         B     ERR6\n         SPACE 2\n*        DATA SET POINTER ENTRY (DSPE).\n         SPACE 1\nDSPEN    OI    SWETY+1,ON          SET BRANCH OPERATION.\n         BAL   R14,GDGN\n         BAL   R14,BDSN\n         L     R1,SVPARM\n         MVI   0(R1),2\n         MVC   1(L'DSNAME,R1),DSNAME\n         LH    R6,EVOLCNT\n         B     DSPEN2\nDSPEN1   L     R1,SVPARM\n         MVI   0(R1),255\nDSPEN2   L     R1,SVPARM+4\n         LTR   R1,R1\n         BZ    *+L'*+6\n         MVC   0(6,R1),EDATA+4\n         L     R1,SVPARM+8\n         LTR   R1,R1\n         BZ    *+L'*+6\n         MVC   0(4,R1),EDATA\n         BAL   R14,EXRET\n         LA    R7,L'EDATA(R7)\n         BCT   R6,DSPEN1\n         LA    R7,ELENGTH+2(R7)    DSPE LENGTH.\n         CLR   R7,R8\n         BNL   ERR7                INVALID BLOCK TERMINATION.\n         B     NXT\n         SPACE 2\n*        VOLUME CONTROL BLOCK POINTER ENTRY (VCBPE).\n         SPACE 1\nVCBPEN   OI    SWETY+1,ON          SET BRANCH OPERATION.\n         BAL   R14,GDGN\n         BAL   R14,BDSN\n         L     R1,SVPARM\n         MVI   0(R1),2\n         MVC   1(L'DSNAME,R1),DSNAME\n         MVC   WORK+1(L'ETTR),ETTR SET TTR FOR READ.\n         STM   R7,R8,VCBPTR\n         OI    SWVCB+1,ON          SET BRANCH OPERATION.\n         B     VCBPEN2\nVCBPEN1  L     R1,SVPARM\n         MVI   0(R1),255\nVCBPEN2  NI    SWNXN+1,OFF         SET NOP OPERATION.\n         L     R0,WORK\n         BAL   R14,XREAD           READ A VCB.\n         ST    R1,VCBBA\n         L     R7,DSCA(R1)         GET BLOCK POINTER.\n         SPACE 2\n*        VOLUME CONTROL BLOCK (VCB).\n         SPACE 1\n         LH    R2,VCBVOLCT\n         LA    R6,20\n         CLR   R2,R6\n         BH    VCBPEN4\n         LR    R6,R2\n         OI    SWNXN+1,ON          SET BRANCH OPERATION.\n         B     VCBPEN4\nVCBPEN3  L     R1,SVPARM\n         MVI   0(R1),255\nVCBPEN4  L     R1,SVPARM+4\n         LTR   R1,R1\n         BZ    *+L'*+6\n         MVC   0(6,R1),VCBVOLS+4\n         L     R1,SVPARM+8\n         LTR   R1,R1\n         BZ    *+L'*+6\n         MVC   0(4,R1),VCBVOLS\n         BAL   R14,EXRET\n         LA    R7,L'VCBVOLS(R7)\n         BCT   R6,VCBPEN3\n         L     R1,VCBBA\n         OI    FLAG(R1),FREE       RELEASE BLOCK AREA.\nSWNXN    NOP   VCBPEN5\n         L     R7,DSCA(R1)\n         MVC   WORK+1(L'ETTR),VCBVOLS+(20*L'VCBVOLS)+10\n         B     VCBPEN1\nVCBPEN5  NI    SWVCB+1,OFF         SET NOP OPERATION.\n         LM    R7,R8,VCBPTR\n         LA    R7,ELENGTH+1*2(R7)  VCBPE LENGTH.\n         CLR   R7,R8\n         BNL   ERR7                INVALID BLOCK TERMINATION.\n         B     NXT\n         SPACE 2\nILPE     CLC   ENAME,MONE          TEST ILE ENTRY.\n         BNE   IPENX\n         SPACE 2\n*        INDEX LINK ENTRY (ILE).\n         SPACE 1\n         CLC   ETTR(L'ETTR),ZEROS  TEST IF ANY OTHER BLOCK.\n         BNE   ILENX\nSWETY    B     NOTETY\n         OI    SWBDS+1,ON          SET BRANCH OPERATION.\n         BAL   R14,BDSN\n         NI    SWBDS+1,OFF         SET NOP OPERATION.\n         L     R1,SVPARM           EMPTY INDEX LEVEL(S).\n         MVI   0(R1),128\n         MVC   1(L'DSNAME,R1),DSNAME\n         BAL   R14,EXRET\nNOTETY   L     R2,INDEX            GET LEVEL.\n         SLL   R2,3\n         LA    R1,NAMEDS(R2)\n         MVI   0(R1),C' '          CLEAR CURRENT INDEX NAME.\n         MVC   1(L'ENAME-1,R1),0(R1)\n         SRL   R2,1\n         L     R1,CATNX(R2)        FREE CURRENT BLOCK AREA.\n         SR    R0,R0\n         ST    R0,CATNX(R2)\n         OI    FLAG(R1),FREE\n         SRL   R2,2\n         LTR   R2,R2               TEST LAST LEVEL.\n         BNZ   PLEV\n         L     R1,CATMA\n         LM    R7,R8,DSCA(R1)\n         CLR   R7,R8\n         BNL   ERR7                INVALID BLOCK TERMINATION.\n         B     NEXT\nPLEV     BCTR  R2,0                PREVIOUS LEVEL.\n         ST    R2,INDEX\n         SLL   R2,2\n         L     R1,CATNX(R2)\n         LM    R7,R8,DSCA(R1)\n         CLR   R7,R8\n         BNL   ERR7                INVALID BLOCK TERMINATION.\n         B     NXT\nILENX    MVC   WORK+1(L'ETTR),ETTR SET TTR FOR READ.\n         L     R2,INDEX\n         SLL   R2,2\n         L     R1,CATNX(R2)\n         OI    FLAG(R1),FREE       RELEASE BLOCK AREA.\n         L     R0,WORK\n         BAL   R14,XREAD           READ NEXT BLOCK.\n         ST    R1,CATNX(R2)\n         LM    R7,R8,DSCA(R1)      GET BLOCK POINTERS.\n         B     NXT\n         SPACE 2\n*        GENERATION INDEX POINTER ENTRY (GIPE).\n         SPACE 1\nGIPEN    LA    R14,ELENGTH+2*2(R7) GIPE LENGTH.\n         NI    GDGSW+1,OFF\n         B     IPENX+L'IPENX\n         SPACE 2\n*        INDEX POINTER ENTRY (IPE).\n         SPACE 1\nIPENX    LA    R14,ELENGTH(R7)     IPE LENGTH.\n         L     R2,INDEX\n         SLL   R2,2\n         L     R1,CATNX(R2)\n         ST    R14,DSCA(R1)        SAVE CURRENT POINTER.\n         SRL   R2,2\n         LA    R2,1(R2)            BUMP LEVEL.\n         B     IPELP\n         SPACE 2\n         DROP  R7\n         SPACE 2\nEXRET    STM   R6,R8,SVBACK        SAVE REGISTERS.\n         ST    R14,SVLINK\n         SR    R10,R10\n         B     EXIT\n         SPACE 1\nENDSR    SR    R10,R10\n         BCT   R10,LEAVE\n         SPACE 2\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nERR4     BCTR  R10,0\nERR5     BCTR  R10,0\nERR6     BCTR  R10,0\nERR7     BCTR  R10,0\nERR8     BCTR  R10,0\nMAXERR   EQU   ((*-ERR1)/2)+1\nLEAVE    BAL   R14,XCLOSE\n         B     EXIT\n         EJECT\nCTOPEN   SR    R9,R9\n         SR    R8,R8\n         LA    R10,MAXERO\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    OP2\n         TM    4(R1),X'80'\n         BO    OP1\n         TM    8(R1),X'80'\n         BZ    ERO3\n         TM    11(R1),X'03'\n         BNZ   ERO3\n         L     R9,8(R1)\n         LA    R9,0(R9)\nOP1      TM    7(R1),X'03'\n         BNZ   ERO3\n         L     R8,4(R1)\n         LA    R8,0(R8)\nOP2      L     R7,0(R1)\n         LA    R7,0(R7)\n         SPACE 1\n         OC    ATIOT(L'ATIOT),ATIOT FISRT TIME?\n         BNZ   GOT                 BRANCH IF NOT.\n         L     R2,CVTPTR           GET CVT ADDRESS.\n         USING CVT,R2\n         TM    CVTDCB,CVT4MS1      TEST IF OS/VS2?\n         BZ    ERO4                BRANCH IF NOT.\n         MVC   ACRTAA(L'CVTPCNVT),CVTPCNVT   GET USEFULL ADDRESSES.\n         MVC   ARPSSC(L'CVT0SCR1),CVT0SCR1\n         DROP  R2\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\n         L     R2,ATIOT\n         USING TIODSECT,R2\n         MVC   GN4+1(L'TIOCNJOB),TIOCNJOB\n         DROP  R2\n         LA    R2,GN4+L'GN4-3\n         LA    R3,L'GN4-1\nDSOL     CLI   0(R2),C' '\n         BNE   DSOLF\n         BCTR  R2,0\n         BCT   R3,DSOL\nDSOLF    MVC   1(2,R2),GN3\n         SPACE 1\nGOT      L     R2,ATIOT            GET TIOT ADDRESS.\n         USING TIODSECT,R2\n         LA    R5,DCBSR            SEARCH DD-CARD.\n         USING IHADCB,R5\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED?\n         BO    ERO1                BRANCH IF YES.\n         MVC   DCBDDNAM(L'DCBDDNAM),0(R7)\nSRCH     CLC   TIOELNGH(L'ZEROS),ZEROS END OF TIOT?\n         BE    ERO5                YES.\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM DD-NAME FOR US?\n         BE    DDFND               YES.\n         SR    R1,R1\n         IC    R1,TIOELNGH\n         AR    R2,R1               NEXT DD ENTRY.\n         B     SRCH\n         DROP  R2\nDDFND   DEVTYPE  DCBDDNAM,DVTYP,DEVTAB\n         CLI   DVTYP+2,X'20'       TEST IF DIRECT-ACCESS STORAGE.\n         BNE   ERO6                BRANCH IF NOT.\n         LTR   R8,R8\n         BZ    RDJ\n         MVC   0(5*4,R8),DVTYP\n         L     R4,CVTPTR           GET CVT POINTER.\n         USING CVT,R4\n         L     R15,CVTZDTAB        ADDRESS OF IECZDTAB.\n         DROP  R4\n         LA    R15,0(0,R15)        IECZDTAB IS THE RESIDENT DIRECT\n         SR    R4,R4                    ACCESSS DEVICE CONSTANT TABLE\n         LR    R14,R4                   (SEE ASSEMBLY OF IECZDTAB).\n         IC    R14,DVTYP+3         GET DIRECT-ACCESS TYPE.\n         IC    R4,0(R14,R15)       PICK UP TABLE DISPLACEMENT.\n         ALR   R4,R15              DEVICE CONSTANT TABLE ADDRESS.\n         MVC   20(2,R8),12(R4)     MOVE NR. OF ALT. TRACKS.\nRDJ      TM    DVTYP+1,X'10'       TEST IF RPS DEVICE,\n         BZ    *+L'*+6             BRANCH IF NOT.\n         MVC   RPSR2(1),DVTYP+3\n        RDJFCB  (DCBSR)\n         LTR   R15,R15             TEST COMPLETION CODE.\n         BNZ   ERO7                JFCB ERROR.\n         LA    R4,JF\n         USING JFCDSECT,R4\n         CLC   JFCBDSNM(L'DSCTLG),DSCTLG     TEST CATALOG DSNAME.\n         BNE   *+L'*+12\n         CLI   JFCBIND2,JFCOLD+JFCSHARE TEST DISP=SHR CODED,\n         BNE   ERO8                BRANCH IF NOT.\n         B     DSJF\n         CLC   JFCBDSNM(L'GN1),GN1 TEST O.S. GENERATED DSNAME.\n         BNE   ERO8\n         CLC   JFCBDSNM+8(L'GN2),GN2\n         BNE   ERO8\n         CLC   JFCBDSNM+16(L'GN3),GN3\n         BNE   ERO8\n         LA    R2,GN4+L'GN4-1\n         LA    R3,L'GN4-1\nDSCL     CLI   0(R2),C' '\n         BNE   DSCLF\n         BCTR  R2,0\n         BCT   R3,DSCL\nDSCLF    EX    R3,DSCC\n         BE    *+L'*+10\n         B     ERO8\nDSCC     CLC   JFCBDSNM+22(*-*),GN4\n         CLI   JFCBIND2,JFCOLD     TEST DISP=OLD CODED,\n         BNE   ERO8                BRANCH IF NOT.\nJL1      EQU   JFCBLTYP-JFCBTSDM\nDSJF     OC    JFCBTSDM(JL1),JFCBTSDM   CONTROL DD-CARD CODE.\n         BNZ   ERO8\nJL2      EQU   JFCBCRDT-JFCBOTTR\n         OC    JFCBOTTR(JL2),JFCBOTTR\n         BNZ   ERO8\nJL3      EQU   JFCBIND2-JFCBXPDT\n         OC    JFCBXPDT(JL3),JFCBXPDT\n         BNZ   ERO8\nJL4      EQU   JFCBNVOL-JFCBUFNO\n         OC    JFCBUFNO(JL4),JFCBUFNO\n         BNZ   ERO8\nJL5      EQU   JFCBVLCT-JFCBPQTY\n         OC    JFCBPQTY(JL5),JFCBPQTY\n         BNZ   ERO8\n         CLI   JFCBVLCT,X'01'\n         BNE   ERO8\n         CLI   JFCBLTYP,JFCSL\n         BNE   ERO8\n         CLI   JFCBNVOL,X'01'\n         BNE   ERO8\n         CLI   JFCBSPTN,X'00'\n         BNE   ERO8\n         LTR   R8,R8\n         BZ    *+L'*+6\n         MVC   22(6,R8),JFCBVOLS\n         SPACE 1\n         OI    JFCBTSDM,JFCNWRIT   INHIBIT WRITE BACK.\n         CLC   JFCBDSNM(L'DSCTLG),DSCTLG\n         BE    *+L'*+12\n         MVC   JFCBDSNM(L'DSCTLG),DSCTLG     SET CATALOG NAME.\n         MVC   JFCBDSNM+L'DSCTLG(L'JFCBDSNM-L'DSCTLG),JFCBDSNM+L'DSCTLG1\n               -1\n         DROP  R4\n        OPEN   (DCBSR,(INPUT)),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULLY?\n         BZ    ERO2                BRANCH IF NOT.\n         DROP  R5\n         OI    SWFIRST+1,ON\n         SR    R10,R10\n         B     EXIT\n         SPACE 1\nERO1     BCTR  R10,0\nERO2     BCTR  R10,0\nERO3     BCTR  R10,0\nERO4     BCTR  R10,0\nERO5     BCTR  R10,0\nERO6     BCTR  R10,0\nERO7     BCTR  R10,0\nERO8     BCTR  R10,0\nMAXERO   EQU   ((*-ERO1)/2)+1\n         B     EXIT\n         EJECT\nCTCLOSE  SR    R9,R9\n         SR    R8,R8\n         LTR   R1,R1\n         BZ    CL2\n         LA    R10,MAXERC\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    CL1\n         TM    4(R1),X'80'\n         BZ    ERC1\n         TM    7(R1),X'03'\n         BNZ   ERC1\n         L     R9,4(R1)\n         LA    R9,0(R9)\nCL1      TM    3(R1),X'03'\n         BNZ   ERC1\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         SPACE 1\nCL2      BAL   R14,XCLOSE\n         LTR   R8,R8\n         BZ    CL3\n         MVC   0(LDATA,R8),TTRLVI\nCL3      XC    TTRLVI(LDATA),TTRLVI\n         SR    R10,R10\n         B     EXIT\n         SPACE 1\nERC1     BCTR  R10,0\nMAXERC   EQU   ((*-ERC1)/2)+1\n         SPACE 1\nEXIT     L     R1,4(R13)\n         XC    24(4,R1),24(R1)\nGDGSW    B     NOTGDG\n         OI    GDGSW+1,ON\n         MVI   27(R1),1\nNOTGDG   LTR   R9,R9\n         BZ    XLEAVE\n         ST    R10,0(R9)\nXLEAVE  $XRET  CC=(R10)\n         EJECT\n*        EXECUTE DIRECT ACCESS PROGRAM READ ROUTINE.\n*\n*              R0  = RELATIVE TRACK ADDRESS (TTR).\n*              R1  = AT EXIT, IT WILL CONTAIN THE ADDRESS OF THE\n*                    CATALOG'S BLOCK AREA.\n*              R14 = LINK REGISTER.\n*              R15 = WORK REGISTER.\n*\n*              R2 TO R13 REMAIN UNCHANGED.\n*\n*        NOTE. TTR IS THE RELATIVE TRACK ADDRESS OF THE RECORD\n*              TO BE READ, AND IT MUST BE RIGHT JUSTIFIED IN\n*              REGISTER 0.\n         SPACE 1\nXREAD    STM   R0,R15,XSAVE        SAVE AROUND SYSTEM ROUTINES.\n         CL    R0,HIGHTTR          RETAIN HIGHEST TTR USED.\n         BNH   *+L'*+4\n         ST    R0,HIGHTTR\n         SLL   R0,8                ADJUST TTR TO TTRN.\n         ST    R0,TTR\n         L     R1,DCBSR+(DCBDEBAD-IHADCB)    GET DEB ADDRESS.\n         LA    R2,ADDREC           SET ADDRESS OF MBBCCHHR RESULT.\n         L     R15,ACRTAA          GET ENTRY POINT ADDRESS (IECPCNVT).\n         BALR  R14,R15             CONVERT TTRN TO MBBCCHHR.\n         USING *,R14\n         LM    R0,R15,XSAVE        RESTORE ORIGINAL REGISTERS.\n         DROP  R14\n         LA    R3,ECBSRR\n         TM    DVTYP+1,X'10'       TEST IF RPS DEVICE,\n         BZ    NORPS               BRANCH IF NOT.\n         STC   R0,RPSR0+3          SET RECORD NUMBER.\n         L     R0,RPSR0            GET RPS SECTOR ARGUMENTS.\n         L     R2,RPSR2\n         L     R15,ARPSSC          GET ENTRY POINT ADDRESS (IEC0SCR1).\n         BALR  R14,R15             COMPUTE SECTOR NUMBER OF THE BLOCK.\n         USING *,R14\n         LM    R0,R15,XSAVE        RESTORE ORIGINAL REGISTERS.\n         DROP  R14\n         LA    R3,ECBSRP\n         B     NORPS\n         SPACE 1\n        CNOP   0,4\nXSAVE    DC    16F'0'              LOCAL SAVE AREA.\n         SPACE 1\nNORPS    LA    R2,BLOCKMA-NXA      FIND A FREE CATALOG'S BLOCK AREA.\n         L     R2,NXA(R2)\n         TM    FLAG(R2),FREE\n         BO    FOUND\n         OC    NXA(4,R2),NXA(R2)\n         BNZ   NORPS+L'NORPS\n         BAL   R14,GETAR           GET A CATALOG'S BLOCK AREA.\n         ST    R1,NXA(R2)          BUILD CHAIN.\n         ST    R2,NXP(R1)\n         LR    R2,R1\n         B     FOUND+L'FOUND\nFOUND    NI    FLAG(R2),255-FREE   SET BUSY.\n         ST    R2,XSAVE+(R1*4)     SET REGISTER READY TO RETURN.\n         LA    R2,PRFX(R2)         POINTS TO READ DATA.\n         XC    0(KLG,R2),0(R2)     CLEAR AREA.\n         XC    KLG(RLG-KLG,R2),KLG(R2)\n         USING XDSECT,R3\n         XC    ECB(L'ECB+L'ECBCC),ECB   CLEAR ECB.\n         XC    IOBCSW(L'IOBCSW),IOBCSW  CLEAR CSW.\n         TM    DVTYP+1,X'10'       TEST IF RPS DEVICE,\n         BO    RPS                 BRANCH IF YES.\n        XDAP   ECBSRR,RI,DCBSR,(2),RLG,,ADDREC\n         B     WT\nRPS     XDAP   ECBSRP,RI,DCBSR,(2),RLG,,ADDREC,SECTOR\nWT      WAIT   ECB=ECB\n         LR    R7,R3               ECB ADDRESS.\n         USING XDSECT,R7\n         LR    R8,R2               READ AREA ADDRESS.\n         CLI   ECB,X'7F'           READ SUCCESSFULL?\n         BNE   ERR1                BRANCH IF NOT.\n         DROP  R3\n         SPACE 1\n         L     R2,XSAVE+(R1*4)     GET BLOCK AREA ADDRESS.\n         LR    R1,R2\nSWVCB    NOP   ALTRET\n         LH    R3,PRFX+KLG(R2)     GET DATA COUNT.\n         LA    R3,PRFX+KLG(R2,R3)  DATA END ADDRESS.\n         LA    R2,PRFX+KLG+2(R2)   DATA START ADDRESS.\n         STM   R2,R3,DSCA(R1)\nCOMRET   MVC   RTTR(3,R1),TTR      SET TTR.\n         LM    R0,R14,XSAVE        RESTORE ORIGINAL REGISTERS.\n         BR    R14                 RETURN.\nALTRET   LA    R2,PRFX+KLG(R2)     DATA START ADDRESS IN VCB.\n         ST    R2,DSCA(R1)\n         B     COMRET\n         DROP  R7\n         EJECT\n*        GET AN AREA TO READ A CATALOG'S BLOCK.\n*\n*              R0  = WORK REGISTER.\n*              R1  = AT EXIT, IT WILL CONTAIN THE ADDRESS OF THE MAIN\n*                    STORAGE AREA ALLOCATED (ALSO IN THE FULLWORD\n*                    NAMED 'WORK').\n*              R14 = LINK REGISTER.\n*              R15 = WORK REGISTER.\n         SPACE 1\nGETAR    ST    R14,SVLINK          SAVE LINK REGISTER.\n        GETMAIN  EC,LV=BLG,A=WORK\n         LTR   R15,R15\n         BNZ   ERR4                BRANCH IF NO STORAGE AVAILABLE.\n         L     R1,WORK\n         XC    FLAG(PRFX,R1),FLAG(R1)   RESET CHAIN FIELDS.\n         L     R14,SVLINK          RESTORE LINK REGISTER.\n         BR    R14                 RETURN.\n         EJECT\n*        GENERATION DATA GROUP NAME BUILD ROUTINE.\n*\n*              R7  = ADDRESS OF DSPE OR VCBPE.\n*              R14 = LINK REGISTER.\n*\n*        NOTE. AT EXIT, THE EVENTUAL GDG NAME IS COMPLEMENTED IN THE\n*              'ENAME' FIELD OF DSPE OR VCBPE.\n         SPACE 1\n         USING CTLDSECT,R7\nGDGN     CLI   ENAME,C'G'          CONTROL IF GDG NAME.\n         BNER  R14\n         CLI   ENAME+5,C'V'\n         BNER  R14\n         MVZ   ZONE1(L'ZONE1),ENAME+6\n         CLC   ZONE1(L'ZONE1),ZONE1+L'ZONE1\n         BNER  R14\n         MVZ   ZONE2(L'ZONE2),ENAME+1\n         CLC   ZONE2(L'ZONE2),ZEROS\n         BNER  R14\n         XC    ENAME+1(L'ZONE2),MONE    COMPLEMENT GDG NUMBER.\n         NI    GDGSW+1,OFF\n         BR    R14                 RETURN.\n         EJECT\n*        DSNAME BUILD ROUTINE.\n*\n*              R0  = WORK REGISTER.\n*              R1  = WORK REGISTER.\n*              R2  = WORK REGISTER.\n*              R7  = ADDRESS OF DSPE OR VCBPE.\n*              R14 = LINK REGISTER.\n*              R15 = WORK REGISTER.\n*\n*        NOTE. AT EXIT, THE COMPLETE DATA-SET NAME IS IN THE FIELD\n*              NAMED 'DSNAME'.\n         SPACE 1\nBDSN     MVI   DSNAME,C' '         PREPARE DSNAME FIELD.\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         LA    R15,DSNAME\n         SR    R2,R2\n         LA    R1,NAMEDS\nBDSN0    LA    R0,L'NAMEDS\nBDSN1    CLI   0(R1),C' '          BUILD THE DATA SET NAME.\n         BE    BDSN2\n         MVC   0(1,R15),0(R1)\n         LA    R15,1(R15)\n         LA    R1,1(R1)\n         BCT   R0,BDSN1\nBDSN2    AR    R1,R0\n         MVI   0(R15),C'.'\n         LA    R15,1(R15)\n         CL    R2,INDEX\n         BNL   SWBDS\n         LA    R2,1(R2)\n         B     BDSN0\nSWBDS    NOPR  R14                 OPTIONAL RETURN.\n         LA    R0,L'ENAME\n         LA    R1,ENAME-CTLDSECT(R7)\nBDSN3    CLI   0(R1),C' '\n         BER   R14                 RETURN.\n         MVC   0(1,R15),0(R1)\n         LA    R15,1(R15)\n         LA    R1,1(R1)\n         BCT   R0,BDSN3\n         BR    R14                 RETURN.\n         EJECT\n*        FREE ALL DYNAMIC BLOCKS AREAS AND CLOSE.\n*\n*              R0  = WORK REGISTER.\n*              R1  = WORK REGISTER.\n*              R2  = WORK REGISTER.\n*              R3  = WORK REGISTER.\n*              R4  = WORK REGISTER.\n*              R14 = LINK REGISTER.\n         SPACE 1\nXCLOSE   ST    R14,SVLINK          SAVE LINK REGISTER.\n         L     R2,BLOCKMA          FREE ALL CATALOG'S BLOCK AREAS.\n         LTR   R2,R2\n         BZ    DELN                NOTHING TO FREE.\nDELS     LR    R3,R2               FIND THE LAST IN CHAIN.\n         L     R2,NXA(R3)\n         LTR   R2,R2\n         BNZ   DELS\nDELP     L     R2,NXP(R3)          GET PREVIOUS IN CHAIN.\n         LTR   R2,R2\n         BZ    DELL\n         LA    R4,NXA(R2)\n        FREEMAIN A=(4),MF=(E,FREAR)\n         LR    R3,R2\n         B     DELP\nDELL     LA    R4,BLOCKMA          FREE FIRST CATALOG'S BLOCK AREA.\n        FREEMAIN A=(4),MF=(E,FREAR)\n         XC    BLOCKMA,BLOCKMA\nDELN     LA    R2,DCBSR\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST IF OPENED?\n         BZ    XCLRET              BRANCH IF NOT.\n         DROP  R2\n        CLOSE  (DCBSR)\nXCLRET   L     R14,SVLINK          RESTORE LINK REGISTER.\n         BR    R14                 RETURN.\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nATIOT    DC    A(*-*)\nACRTAA   DC    A(*-*)\nARPSSC   DC    A(*-*)\nBLOCKMA  DC    A(*-*)\nVCBPTR   DC    A(*-*,*-*)\nVCBBA    DC    A(*-*)\nSVBACK   DC    A(*-*,*-*,*-*)\nSVLINK   DC    A(*-*)\nSVPARM   DC    A(*-*,*-*,*-*)\nDVTYP    DC    5F'0'\nZEROS    DC    F'0'\nTTR      DC    F'0'\nWORK     DC    F'0'\nRPSR0    DC    0F'0',AL2(RLG),AL1(KLG,*-*)\nRPSR2    DC    0F'0',AL1(*-*),AL3(SECTOR)\nADDREC   DC    0F'0',XL8'0'\n         SPACE 1\nTTRLVI   DC    F'0'\nTTRL     DC    F'0'\nTTRFU    DC    F'0'\nHIGHTTR  DC    F'0'\nLDATA    EQU   *-TTRLVI\n         SPACE 1\nCATMA    DC    A(*-*)\nINDEX    DC    F'0'\nCATNX    DC    22A(*-*)\nNAMEDS   DC    22CL8' '\n         SPACE 1\nONE      DC    XL8'0000000000000001'\nMONE     DC    XL8'FFFFFFFFFFFFFFFF'\nSECTOR   DC    XL1'0'\nZONE1    DC    2C'00'\nZONE2    DC    XL4'00'\nDSCTLG   DC    CL8'SYSCTLG '\nGN1      DC    C'SYS'\nGN2      DC    C'.T'\nGN3      DC    C'.RA'\nGN4      DC    CL11'.'\nDSNAME   DC    CL44' '\n         SPACE 1\nJOBFILE  DC    0F'0',XL1'87',AL3(JF)\nJF       DC    0F'0',XL176'00'\n         EJECT\nFREAR   FREEMAIN E,LV=BLG,MF=L\n         SPACE 2\nDCBSR    DCB   DSORG=DA,MACRF=E,DEVD=DA,RECFM=F,                       1\n               EXLST=JOBFILE,DDNAME=XXXXXXXX\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CATS$": {"ttr": 9994, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x12\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:12:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//CATS     JOB (........),'INSTALL  - C A T S -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS3,MBR=CATS\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   CATSO\n  ALIAS   CATSC\n  NAME    CATSR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CATS@": {"ttr": 9996, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14Q\\x00\\x9c\\x00\\x9c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:51:00", "lines": 156, "newlines": 156, "modlines": 0, "user": "SYSPAJA"}, "text": "1   27/07/87\n                                                      CATS      1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *  READ SEQUENTIALLY AN O.S. CATALOG  * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Routine to read sequentially an entire O.S. catalog.\n  ---------    A DD-card, written as below, is needed to define\n               the desired volume on which the O.S. catalog resides :\n\n               //...     DD  UNIT=...,VOLUME=SER=...,DISP=OLD\n\n               or the desired O.S. catalog :\n\n               //...     DD  UNIT=...,VOLUME=SER=...,\n               //            DSN=SYSCTLG,DISP=SHR\n\n  Calling sequence : CALL CATSR,(A,B,C,D),VL\n  ------------------            (A,B,C)\n                                (A,B)\n                                (A)\n\n         Where : A - is the address of a field (format XL1,CL44) which\n                     receives, after each read operation, unless when\n                     the END-OF-FILE is detected, one of the following\n                     information :\n\n                      - a CVOL pointer name(format AL1(1),CL8).\n                      - a DATA-SET name (format AL1(2),CL44).\n                      - an ALIAS name, followed by the true name index\n                        (format AL1(3),CL8,CL8).\n                      - a null INDEX name (format AL1(128),CL8).\n                      - an information continuation of a previous name\n                        (format AL1(255),CL44).\n\n                 B - is the address of a field (format CL6) which\n                     receives the VOLUME SERIAL NUMBER relative\n                     to the first argument if pertinent, otherwise\n                     it is cleared to blanks. This argument is\n                     optional and may be omitted or his address may\n                     be set to zero in the parameters list.\n\n                 C - is the address of a field (format XL4) which\n                     receives the DEVICE TYPE relative to the second\n                     argument if pertinent, otherwise it is cleared\n                     to blanks. This argument is optional and may be\n                     omitted or his address may be set to zero in the\n                     parameters list.\n\n         Note : the register 1 is always 0 (zero) at return, unless\n                when a GENERATION DATA GROUP name has been builded,\n                it is set to 1 (one). Be carefull that the condition\n                is not maintained on eventual continuations.\n1   23/09/85\n                                                      CATS      2/3.\n\n                 D - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional). Value is always\n                     placed in register 15 and can be :\n\n                     -1 - END-OF-FILE detected.\n                      0 - READ operation correctly executed.\n                      1 - READ error.\n                      2 - file not opened.\n                      3 - calling sequence or argument alignment error.\n                      4 - insufficient core storage at disposal.\n                      5 - no VOLUME INDEX CONTROL entry in catalog.\n                      6 - unexpected catalog entry encountered.\n                      7 - invalid termination of a catalog block.\n                      8 - INDEX with wrong or no INDEX CONTROL entry.\n\n  Assembler macro : $CATSR A,B,C,D\n  -----------------\n\n         Where B, C and/or D are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  Calling sequence : CALL CATSO,(A,B,C),VL\n  ------------------            (A,B)\n                                (A)\n\n         Where : A - is the address of the DD-name (format CL8).\n\n                 B - is the address of the device characteristics\n                     (format FULLWORD - F boundary) returned by the\n                     routine if supplied (optional). It will receive\n                     five fullwords information as described in DEVTYPE\n                     macro (see OS/VS2 System Programming Library :\n                     Data Management), followed by one halfword\n                     containing the number of alternate tracks for\n                     the device, followed by a six characters field\n                     containing the VOLUME SERIAL NUMBER of the\n                     device. This argument is optional and may be\n                     omitted or his address may be set to zero in the\n                     parameters list.\n\n                 C - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional). Value is always\n                     placed in register 15 and can be :\n\n                      0 - OPEN correctly executed.\n                      1 - file already opened.\n                      2 - OPEN error.\n                      3 - calling sequence or argument alignment error.\n                      4 - not OS/VS2 System.\n                      5 - DD-card missing.\n                      6 - not direct-access storage device.\n                      7 - read JFCB error.\n                      8 - DD-card incorrectly coded.\n1   30/07/86\n                                                      CATS      3/3.\n\n  Assembler macro : $CATSO A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  Calling sequence : CALL CATSC,(A,B),VL\n  ------------------            (A)\n\n         Where : A - is the address of the CATALOG CONTROL INFORMATION\n                     (format FULLWORD - F boundary) returned by the\n                     routine if supplied (optional : argument may be\n                     omitted passing a zero parameters list pointer,\n                     register 1, when the next is also omitted, or his\n                     address may be zero in the parameters list).\n                     It will receive four fullwords information as\n                     described below :\n                      - the relative track address of the last block\n                        of the volume index (format F'0TTR').\n                      - the relative track address of the last block\n                        in SYSCTLG (format F'0TTR').\n                      - the relative track address of the first unused\n                        block in SYSCTLG (format F'0TTR').\n                      - the relative track address of the upper used\n                        block in SYSCTLG (format F'0TTR').\n\n                 B - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional). Value is always\n                     placed in register 15 and can be :\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence or argument alignment error.\n\n  Assembler macro : $CATSC A,B\n  -----------------\n\n         Where A and/or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  General notice : this routine is only serially volumes usable.\n  ================\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CBOOK000": {"ttr": 10244, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07?\\x00\\x95\\x07?\\x11\\x18\\x04A\\x04A\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-14T00:00:00", "modifydate": "1995-03-14T11:18:00", "lines": 1089, "newlines": 1089, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n/* * --- DELETE FROM HERE ****************************************** */\n/* * YOU MUST ADJUST THE VARIOUS LEVELS ACCESSES (WIZARD, MASTER   * */\n/* *               AND PUPIL) DEFINED HERE BELOW BEFORE YOU MAY    * */\n/* *               EXECUTE THIS PROCEDURE (REPLACE THESE NAMES BY  * */\n/* *               THE DESIRED USER-IDS).                          * */\n/* * THEN, DELETE ALL INDICATED STATEMENTS, GOOD LUCK.             * */\n/* ***************************************************************** */\n/* * PRE-REQUISITE : \"PRINTO\" TSO COMMAND (AVAILABLE IN CBT FILES  * */\n/* *                 433 AND 437).                             (PM)* */\n/* *---------------------------------------------------------------* */\nWRITE *** MANDATORY - ISPF CLIST \"CBOOK000\" INTERVENTION REQUIRED ***\nEXIT\n/* * --- UP TO HERE WHEN ADJUSTMENT IS DONE ************************ */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n/*       PURPOSE : IBM MANUALS MAINTENANCE DRIVER.               (PM)*/\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\nCONTROL MAIN NOMSG\nIF &SYSISPF EQ &STR(NOT ACTIVE) THEN EXIT\nISPEXEC VGET ZUSER\nSET &CBAVL = NO\n/* - - - HERE FOLLOWS THE \"WIZARD\" LEVEL ACCESS  - - - - - - - - - - */\n/*       \"WIZARD\" CAN DO - TEST AND MODIFY THIS PROCEDURE            */\n/*                       - CREATE NEW DATA-SETS                      */\n/*                       - CREATE NEW TABLES                         */\n/*                       - UPDATE ALL TABLES                         */\nIF &ZUSER = WIZARD THEN DO\n  SET &CBAVL = YES\n  ISPEXEC CONTROL ERRORS RETURN\n  ISPEXEC DISPLAY PANEL(PBOOK000)\n  IF &LASTCC NE 0 THEN EXIT\n  ISPEXEC CONTROL ERRORS CANCEL\n  IF &CBTPRO = &Z THEN SET &CBTPRO = &STR(SYS)\n  IF &CBTLIB = &Z THEN SET &CBTLIB = &STR(BOOKS)\n  IF &CBTTYP = &Z THEN SET &CBTTYP = &STR(DATA)\n  IF &CBVOL = &Z THEN SET &CBVOL = &STR(USER00)\n  IF &CBUNIT = &Z THEN SET &CBUNIT = &STR(DISK)\n  IF &CBALLU = &Z THEN SET &CBALLU = &STR(CYLINDERS)\n  IF &CBSPA1 = &Z THEN SET &CBSPA1 = &STR(1)\n  IF &CBSPA2 = &Z THEN SET &CBSPA2 = &STR(1)\n  IF &CBNDIR = &Z THEN SET &CBNDIR = &STR(1)\n  IF &CBLIST = &Z THEN SET &CBLIST = &STR(CBLIST)\n  END\n/* - - - HERE FOLLOWS THE \"MASTER\" LEVEL ACCESS  - - - - - - - - - - */\n/*       \"MASTER\" CAN DO - CREATE NEW DATA-SETS                      */\n/*                       - CREATE NEW TABLES                         */\n/*                       - UPDATE ALL TABLES                         */\nELSE IF &ZUSER = MASTER THEN DO\n  SET &CBAVL = YES\n  ISPEXEC CONTROL ERRORS RETURN\n  ISPEXEC DISPLAY PANEL(PBOOK00)\n  IF &LASTCC NE 0 THEN EXIT\n  ISPEXEC CONTROL ERRORS CANCEL\n  IF &CBTPRO = &Z THEN SET &CBTPRO = &STR(SYS)\n  IF &CBTLIB = &Z THEN SET &CBTLIB = &STR(BOOKS)\n  IF &CBTTYP = &Z THEN SET &CBTTYP = &STR(DATA)\n  IF &CBVOL = &Z THEN SET &CBVOL = &STR(USER00)\n  IF &CBALLU = &Z THEN SET &CBALLU = &STR(CYLINDERS)\n  IF &CBSPA1 = &Z THEN SET &CBSPA1 = &STR(1)\n  IF &CBSPA2 = &Z THEN SET &CBSPA2 = &STR(1)\n  IF &CBNDIR = &Z THEN SET &CBNDIR = &STR(1)\n  IF &CBLIST = &Z THEN SET &CBLIST = &STR(CBLIST)\n  SET &CBTEST = NO\n  END\n/* - - - HERE FOLLOWS THE \"PUPIL\" LEVEL ACCESS - - - - - - - - - - - */\n/*       \"PUPIL\" CAN DO - UPDATE ONLY A PREDEFINED TABLE             */\nELSE IF &ZUSER = PUPIL THEN DO\n  SET &CBAVL = YES\n  ISPEXEC CONTROL ERRORS RETURN\n  ISPEXEC DISPLAY PANEL(PBOOK0)\n  IF &LASTCC NE 0 THEN EXIT\n  ISPEXEC CONTROL ERRORS CANCEL\n  SET &CBTPRO = &STR(SYS)\n  SET &CBTLIB = &STR(BOOKS)\n  SET &CBTTYP = &STR(DATA)\n  SET &CBVOL = &STR(******)\n  SET &CBALLU =\n  SET &CBSPA1 =\n  SET &CBSPA2 =\n  SET &CBNDIR =\n  SET &CBLIST = &STR(CBLIST)\n  SET &CBTEST = NO\n  END\n/* - - - HERE FOLLOWS THE \"LOOK-ONLY\" LEVEL ACCESS - - - - - - - - - */\n/*       \"LOOK-ONLY\" CAN DO - READ ONLY A PREDEFINED TABLE           */\nELSE DO\n  SET &CBUPDT = NO\n  SET &CBTPRO = &STR(SYS)\n  SET &CBTLIB = &STR(BOOKS)\n  SET &CBTTYP = &STR(DATA)\n  SET &CBVOL = &STR(******)\n  SET &CBALLU =\n  SET &CBSPA1 =\n  SET &CBSPA2 =\n  SET &CBNDIR =\n  SET &CBLIST = &STR(CBLIST)\n  SET &CBTEST = NO\n  END\nIF &CBTEST EQ YES THEN CONTROL LIST SYMLIST CONLIST MSG\n/* - - - SET IBM MANUALS TABLE (DDNAME = CBTABL).  - - - - - - - - - */\nERROR DO\n  ERROR DO\n    ERROR OFF\n    WRITE  *** UNABLE TO ALLOCATE \"TABLE\" LIBRARY DATA-SET ***\n    EXIT\n    END\n  IF &CBVOL EQ &STR(******) THEN DO\n    WRITE  *** UNEXISTANT \"TABLE\" LIBRARY DATA-SET ***\n    EXIT\n    END\n  ALLOC F(CBTABL) DSN('&CBTPRO..&CBTLIB..&CBTTYP') NEW CATALOG +\n    UNIT(&CBUNIT) VOLUME(&CBVOL) +\n    SP(&CBSPA1 &CBSPA2) &CBALLU DIR(&CBNDIR) +\n    RECFM(F B) LRECL(80) BLKSIZE(9040)\n  FREE F(CBTABL)\n  ERROR OFF\n  END\nALLOC F(CBTABL) DSN('&CBTPRO..&CBTLIB..&CBTTYP') SHR\nERROR OFF\nISPEXEC LIBDEF ISPTLIB LIBRARY ID(CBTABL)\nISPEXEC LIBDEF ISPTABL LIBRARY ID(CBTABL)\nISPEXEC CONTROL ERRORS RETURN\nIF &CBUPDT EQ YES THEN ISPEXEC TBOPEN &CBLIST WRITE SHARE\nELSE ISPEXEC TBOPEN &CBLIST NOWRITE SHARE\nSET &RC = &LASTCC\nISPEXEC CONTROL ERRORS CANCEL\nIF &RC EQ 12 THEN DO\n  ISPEXEC SETMSG MSG(MBKS001R)\n  GOTO QUIT\n  END\nIF &RC GT 12 THEN DO\n  ISPEXEC SETMSG MSG(MBKS001S)\n  GOTO QUIT\n  END\nIF &RC EQ 8 THEN DO\n  IF &CBUPDT EQ YES THEN DO\n    ISPEXEC TBCREATE &CBLIST WRITE SHARE +\n      NAMES(CBKW1  CBKW2  CBMNO  CBLOC  CBDTE  +\n            CBSORT CBROOM CBTMN  CBUSR  CBNW0  +\n            CBNW1  CBNW2  CBNW3  CBNW4  CBNW5  +\n            CBNW6  CBNW7  CBNW8  CBNW9  CBNW10 +\n            CBNW11 CBNW12 CBNW13 CBNW14 CBNW15 +\n            CBNW16 CBNW17 CBNW18 CBNW19 CBNW20 +\n            CBNW21 CBNW22 CBNW23 CBNW24 CBNW25 +\n            CBNW26 CBNW27 CBNW28 CBNW29 CBNW30)\n    SET &RC = &LASTCC\n    IF &RC NE 0 THEN DO\n      ISPEXEC SETMSG MSG(MBKS001S)\n      GOTO QUIT\n      END\n    ISPEXEC SETMSG MSG(MBKS001T)\n    END\n  ELSE DO\n    ISPEXEC SETMSG MSG(MBKS001N)\n    GOTO QUIT\n    END\n  END\nISPEXEC TBSORT &CBLIST +\n  FIELDS(CBKW1,C,A CBKW2,C,A CBMNO,C,A CBLOC,C,A)\nSET &CBSRTF = &STR( KEY-1 KEY-2 MANUAL LOCATION)\nISPEXEC VPUT (CBSRTF)\nSET &CBC = &STR(&&)\nSET &CBPDEL =\nSET &RC = 0\nSET &ZTDTOP = 0\nSET &CBUPF =\nSET &CBFND = NO\nSET &CBSRCH = K1A\nSET &CBALW = NO\n/* - - - DISPLAY IBM MANUALS TABLE.  - - - - - - - - - - - - - - - - */\nLOOP: IF &RC EQ 4 THEN ISPEXEC TBDISPL &CBLIST POSITION(CRP)\nELSE DO\n  IF &CBFND EQ NO THEN DO\n    ISPEXEC TBTOP &CBLIST\n    ISPEXEC TBSKIP &CBLIST NUMBER(&ZTDTOP)\n    ISPEXEC VGET (ZVERB ZSCROLLN)\n    IF &ZVERB EQ UP THEN ISPEXEC TBSKIP &CBLIST NUMBER(-&ZSCROLLN)\n    ELSE IF &ZVERB EQ DOWN THEN ISPEXEC TBSKIP &CBLIST +\n      NUMBER(&ZSCROLLN)\n    ELSE SET &CBFND = NO\n    END\n  ISPEXEC TBDISPL &CBLIST PANEL(PBOOK1) POSITION(CRP)\n  END\nSET &RC = &LASTCC\nIF &CMD NE CONT THEN SET &CBALW = NO\nIF &CMD EQ CANCEL OR &RC GT 4 THEN GOTO LEAVE\n/* - - - CONT COMMAND. - - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ CONT THEN DO\n  IF &CBALW = YES THEN DO\n    ISPEXEC TBTOP &CBLIST\n    ISPEXEC TBSKIP &CBLIST NUMBER(&CBFCRP) POSITION(CRP)\n    DO WHILE &CBFRC EQ 0\n      ISPEXEC TBSKIP &CBLIST POSITION(CRP)\n      SET &CBFRC = &LASTCC\n      IF &CBFRC EQ 0 THEN DO\n        IF &SYSINDEX(&NRSTR(&CBFT),&NRSTR(&CBTMN)) NE 0 THEN -\n          SET &CBFRC = 1\n        END\n      END\n    IF &CBFRC EQ 1 THEN DO\n      SET &CBFRC = 0\n      SET &CBALW = YES\n      SET &CBFCRP = &CRP\n      END\n    ELSE DO\n      SET &CBFRC = 8\n      ISPEXEC SETMSG MSG(MBKS006Z)\n      SET &CBALW = NO\n      END\n    END\n  ELSE ISPEXEC SETMSG MSG(MBKS006X)\n  END\n/* - - - FIND COMMAND. - - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ FIND THEN DO\n  ISPEXEC CONTROL DISPLAY SAVE\n  ISPEXEC DISPLAY PANEL(PBOOK5)\n  SET &CBFRC = &LASTCC\n  ISPEXEC CONTROL DISPLAY RESTORE\n  IF &CBFRC EQ 0 THEN DO\n    SET &CBFND = YES\n    IF &CBF1 NE &Z OR &STR(&CBFN) NE &Z THEN DO\n      IF &CBF1 NE &Z THEN DO\n        SET &CBGL = &LENGTH(&NW)\n        IF &CBGL NE 0 THEN DO\n          IF &CBGL EQ 1 THEN SET &CBF3 = &STR( &NW)\n          ELSE SET &CBF3 = &STR(&NW)\n          SET &CBMNO = &STR(&CBF1-&CBF2-&CBF3)\n          END\n        ELSE IF &CBF2 NE &Z THEN SET &CBMNO = &STR(&CBF1-&CBF2)\n        ELSE SET &CBMNO = &STR(&CBF1)\n        END\n      ELSE SET &CBMNO = &STR(&CBFN)\n      IF &SUBSTR(1:1,&CBSRCH) NE M THEN DO\n        SET &CBSRCH = MA\n        SET &CBSFLD = &STR( CBMNO,C,A)\n        SET &CBSRTF = &STR( MANUAL)\n        ISPEXEC VPUT (CBSRTF)\n        ISPEXEC TBSORT &CBLIST FIELDS(&CBSFLD)\n        END\n      ISPEXEC TBTOP &CBLIST\n      IF &CBSRCH EQ MA THEN DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBMNO) NOREAD +\n          POSITION(CRP) CONDLIST(GE)\n        SET &CBFRC = &LASTCC\n        END\n      ELSE DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBMNO) NOREAD +\n          POSITION(CRP) CONDLIST(LE)\n        SET &CBFRC = &LASTCC\n        END\n      IF &CBFRC EQ 8 THEN ISPEXEC SETMSG MSG(MBKS006M)\n      END\n    ELSE IF &NRSTR(&CBFT) NE &Z THEN DO\n      ISPEXEC TBTOP &CBLIST\n      SET &CBFRC = &LASTCC\n      DO WHILE &CBFRC EQ 0\n        ISPEXEC TBSKIP &CBLIST POSITION(CRP)\n        SET &CBFRC = &LASTCC\n        IF &CBFRC EQ 0 THEN DO\n          IF &SYSINDEX(&NRSTR(&CBFT),&NRSTR(&CBTMN)) NE 0 THEN -\n            SET &CBFRC = 1\n          END\n        END\n      IF &CBFRC EQ 1 THEN DO\n        SET &CBFRC = 0\n        SET &CBALW = YES\n        SET &CBFCRP = &CRP\n        END\n      ELSE DO\n        SET &CBFRC = 8\n        ISPEXEC SETMSG MSG(MBKS006N)\n        SET &CBALW = NO\n        END\n      END\n    ELSE IF &STR(&CBFK1) NE &Z THEN DO\n      SET &CBKW1 = &STR(&CBFK1)\n      IF &SUBSTR(1:2,&CBSRCH) NE K1 THEN DO\n        SET &CBSRCH = K1A\n        SET &CBSFLD = &STR( CBKW1,C,A CBKW2,C,A CBMNO,C,A)\n        SET &CBSRTF = &STR( KEY-1 KEY-2 MANUAL)\n        ISPEXEC VPUT (CBSRTF)\n        ISPEXEC TBSORT &CBLIST FIELDS(&CBSFLD)\n        END\n      ISPEXEC TBTOP &CBLIST\n      IF &CBSRCH EQ K1A THEN DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBKW1) NOREAD +\n          POSITION(CRP) CONDLIST(GE)\n        SET &CBFRC = &LASTCC\n        END\n      ELSE DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBKW1) NOREAD +\n          POSITION(CRP) CONDLIST(LE)\n        SET &CBFRC = &LASTCC\n        END\n      IF &CBFRC EQ 8 THEN ISPEXEC SETMSG MSG(MBKS0061)\n      END\n    ELSE IF &STR(&CBFK2) NE &Z THEN DO\n      SET &CBKW2 = &STR(&CBFK2)\n      IF &SUBSTR(1:2,&CBSRCH) NE K2 THEN DO\n        SET &CBSRCH = K2A\n        SET &CBSFLD = &STR( CBKW2,C,A CBMNO,C,A)\n        SET &CBSRTF = &STR( KEY-2 MANUAL)\n        ISPEXEC VPUT (CBSRTF)\n        ISPEXEC TBSORT &CBLIST FIELDS(&CBSFLD)\n        END\n      ISPEXEC TBTOP &CBLIST\n      IF &CBSRCH EQ K2A THEN DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBKW2) NOREAD +\n          POSITION(CRP) CONDLIST(GE)\n        SET &CBFRC = &LASTCC\n        END\n      ELSE DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBKW2) NOREAD +\n          POSITION(CRP) CONDLIST(LE)\n        SET &CBFRC = &LASTCC\n        END\n      IF &CBFRC EQ 8 THEN ISPEXEC SETMSG MSG(MBKS0062)\n      END\n    ELSE IF &CBV NE &Z THEN DO\n      SET &CBGL = &LENGTH(&CBV)\n      SET &CBGT = &STR(   &CBV)\n      SET &CBGI = &CBGL\n      SET &CBGE = &CBGI + 3\n      SET &CBG1 = &SUBSTR(&CBGI:&CBGE,&CBGT)\n      SET &CBGL = &LENGTH(&CBW)\n      SET &CBGT = &STR(  &CBW)\n      SET &CBGI = &CBGL\n      SET &CBGE = &CBGI + 2\n      SET &CBG2 = &SUBSTR(&CBGI:&CBGE,&CBGT)\n      SET &CBLOC = &STR(&CBG1 &CBG2)\n      IF &SUBSTR(1:1,&CBSRCH) NE L THEN DO\n        SET &CBSRCH = LA\n        SET &CBSFLD = &STR( CBLOC,C,A CBMNO)\n        SET &CBSRTF = &STR( LOCATION MANUAL)\n        ISPEXEC VPUT (CBSRTF)\n        ISPEXEC TBSORT &CBLIST FIELDS(&CBSFLD)\n        END\n      ISPEXEC TBTOP &CBLIST\n      IF &CBSRCH EQ LA THEN DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBLOC) NOREAD +\n          POSITION(CRP) CONDLIST(GE)\n        SET &CBFRC = &LASTCC\n        END\n      ELSE DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBLOC) NOREAD +\n          POSITION(CRP) CONDLIST(LE)\n        SET &CBFRC = &LASTCC\n        END\n      IF &CBFRC EQ 8 THEN ISPEXEC SETMSG MSG(MBKS006L)\n      END\n    ELSE IF &STR(&CBFR) NE &Z THEN DO\n      SET &CBROOM = &STR(&CBFR)\n      IF &SUBSTR(1:1,&CBSRCH) NE R THEN DO\n        SET &CBSRCH = RA\n        SET &CBSFLD = &STR( CBROOM,C,A CBMNO,C,A)\n        SET &CBSRTF = &STR( ROOM MANUAL)\n        ISPEXEC VPUT (CBSRTF)\n        ISPEXEC TBSORT &CBLIST FIELDS(&CBSFLD)\n        END\n      ISPEXEC TBTOP &CBLIST\n      IF &CBSRCH EQ RA THEN DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBROOM) NOREAD +\n          POSITION(CRP) CONDLIST(GE)\n        SET &CBFRC = &LASTCC\n        END\n      ELSE DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBROOM) NOREAD +\n          POSITION(CRP) CONDLIST(LE)\n        SET &CBFRC = &LASTCC\n        END\n      IF &CBFRC EQ 8 THEN ISPEXEC SETMSG MSG(MBKS006R)\n      END\n    ELSE IF &CBFD NE &Z THEN DO\n      SET &CBDTE = &CBFD\n      SET &CBSORT = &CBFDS\n      IF &SUBSTR(1:1,&CBSRCH) NE D THEN DO\n        SET &CBSRCH = DA\n        SET &CBSFLD = &STR( CBSORT,N,A CBMNO,C,A)\n        SET &CBSRTF = &STR( DATE MANUAL)\n        ISPEXEC VPUT (CBSRTF)\n        ISPEXEC TBSORT &CBLIST FIELDS(&CBSFLD)\n        END\n      ISPEXEC TBTOP &CBLIST\n      IF &CBSRCH EQ DA THEN DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBSORT) NOREAD +\n          POSITION(CRP) CONDLIST(GE)\n        SET &CBFRC = &LASTCC\n        END\n      ELSE DO\n        ISPEXEC TBSCAN &CBLIST ARGLIST(CBSORT) NOREAD +\n          POSITION(CRP) CONDLIST(LE)\n        SET &CBFRC = &LASTCC\n        END\n      IF &CBFRC EQ 8 THEN ISPEXEC SETMSG MSG(MBKS006S)\n      END\n    ELSE IF &CBFX NE &Z THEN DO\n      IF &CBFY NE &Z THEN SET &CBNWT = &STR(&CBFX-&CBFY)\n      ELSE SET &CBNWT = &STR(&CBFX)\n      ISPEXEC TBTOP &CBLIST\n      SET &CBFRC = &LASTCC\n      DO WHILE &CBFRC EQ 0\n        ISPEXEC TBSKIP &CBLIST POSITION(CRP)\n        SET &CBFRC = &LASTCC\n        IF &CBNW0 NE 0 THEN DO\n          SET &I = 1\n          DO WHILE &I LE &CBNW0\n            IF &SYSINDEX(&CBNWT,&CBC.CBNW&I) NE 0 THEN DO\n              SET &CBFRC = 1\n              SET &I = &CBNW0 + 1\n              END\n            ELSE SET &I = &I + 1\n            END\n          END\n        END\n      IF &CBFRC EQ 1 THEN SET &CBFRC = 0\n      ELSE DO\n        SET &CBFRC = 8\n        ISPEXEC SETMSG MSG(MBKS006T)\n        END\n      END\n    IF &CBFRC EQ 8 THEN ISPEXEC TBBOTTOM &CBLIST NOREAD POSITION(CRP)\n    END\n  END\n/* - - - SORT COMMAND. - - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ SORT THEN DO\n  IF &SFCB1 EQ &Z THEN DO\n    SET &SFCB1 = K1\n    SET &SFCB2 = K2\n    SET &SFCB3 = M\n    SET &SFCB4 = L\n    SET &SFCB5 =\n    SET &SFCB6 =\n    END\n  SET &CBSFLD =\n  SET &CBSRTF =\n  SET &CBSRCH = K1A\n  SET &I = 1\n  DO WHILE &I LE 6\n    SET &SFCB = SFCB&I\n    SET &S = &&&SFCB\n    IF &S EQ K1 THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = K1A\n      SET &CBSFLD = &STR(&CBSFLD CBKW1,C,A)\n      SET &CBSRTF = &STR(&CBSRTF KEY-1)\n      END\n    ELSE IF &S EQ K1I THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = K1D\n      SET &CBSFLD = &STR(&CBSFLD CBKW1,C,D)\n      SET &CBSRTF = &STR(&CBSRTF KEY-1(D))\n      END\n    ELSE IF &S EQ K2 THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = K2A\n      SET &CBSFLD = &STR(&CBSFLD CBKW2,C,A)\n      SET &CBSRTF = &STR(&CBSRTF KEY-2)\n      END\n    ELSE IF &S EQ K2I THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = K2D\n      SET &CBSFLD = &STR(&CBSFLD CBKW2,C,D)\n      SET &CBSRTF = &STR(&CBSRTF KEY-2(D))\n      END\n    ELSE IF &S EQ M THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = MA\n      SET &CBSFLD = &STR(&CBSFLD CBMNO,C,A)\n      SET &CBSRTF = &STR(&CBSRTF MANUAL)\n      END\n    ELSE IF &S EQ MI THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = MD\n      SET &CBSFLD = &STR(&CBSFLD CBMNO,C,D)\n      SET &CBSRTF = &STR(&CBSRTF MANUAL(D))\n      END\n    ELSE IF &S EQ L THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = LA\n      SET &CBSFLD = &STR(&CBSFLD CBLOC,C,A)\n      SET &CBSRTF = &STR(&CBSRTF LOCATION)\n      END\n    ELSE IF &S EQ LI THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = LD\n      SET &CBSFLD = &STR(&CBSFLD CBLOC,C,D)\n      SET &CBSRTF = &STR(&CBSRTF LOCATION(D))\n      END\n    ELSE IF &S EQ D THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = DA\n      SET &CBSFLD = &STR(&CBSFLD CBSORT,N,A)\n      SET &CBSRTF = &STR(&CBSRTF DATE)\n      END\n    ELSE IF &S EQ DI THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = DD\n      SET &CBSFLD = &STR(&CBSFLD CBSORT,N,D)\n      SET &CBSRTF = &STR(&CBSRTF DATE(D))\n      END\n    ELSE IF &S EQ R THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = RA\n      SET &CBSFLD = &STR(&CBSFLD CBROOM,C,A)\n      SET &CBSRTF = &STR(&CBSRTF ROOM)\n      END\n    ELSE IF &S EQ RI THEN DO\n      IF &I EQ 1 THEN SET &CBSRCH = RD\n      SET &CBSFLD = &STR(&CBSFLD CBROOM,C,D)\n      SET &CBSRTF = &STR(&CBSRTF ROOM(D))\n      END\n    SET &I = &I + 1\n    END\n  ISPEXEC VPUT (CBSRTF)\n  ISPEXEC TBSORT &CBLIST FIELDS(&CBSFLD)\n  ISPEXEC SETMSG MSG(MBKS005R)\n  END\n/* - - - SAVE COMMAND. - - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ SAVE THEN DO\n  IF &CBUPDT EQ YES THEN DO\n    ISPEXEC TBSORT &CBLIST +\n      FIELDS(CBKW1,C,A CBKW2,C,A CBMNO,C,A CBLOC,C,A)\n    ISPEXEC TBSAVE &CBLIST REPLCOPY PAD(15)\n    SET &CBUPF =\n    ISPEXEC TBSORT &CBLIST FIELDS(&CBSFLD)\n    ISPEXEC SETMSG MSG(MBKS005S)\n    END\n  ELSE IF &CBAVL = YES THEN ISPEXEC SETMSG MSG(MBKS003U)\n  ELSE ISPEXEC SETMSG MSG(MBKS003T)\n  END\n/* - - - INPUT COMMAND.  - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ INPUT THEN DO\n  IF &CBUPDT EQ YES THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    DO WHILE &CBIN GE 1\n      ISPEXEC TBVCLEAR &CBLIST\n      SET &CBN1 =\n      SET &CBN2 =\n      SET &NW =\n      SET &CBGNS =\n      SET &CBX =\n      SET &CBY =\n      SET &CBNW0 = 0\n      SET &I = 1\n      DO WHILE &I LE 30\n        SET CBNW&I =\n        SET &I = &I + 1\n        END\n      ISPEXEC DISPLAY PANEL(PBOOK2)\n      IF &LASTCC EQ 0 THEN DO\n        IF &STR(&CBGNS) NE &Z THEN SET &CBMNO = &STR(&CBGNS)\n        ELSE DO\n          SET &CBGL = &LENGTH(&NW)\n          IF &CBGL EQ 1 THEN SET &CBN3 = &STR( &NW)\n          ELSE SET &CBN3 = &STR(&NW)\n          SET &CBMNO = &STR(&CBN1-&CBN2-&CBN3)\n          END\n        SET &CBGL = &LENGTH(&CBX)\n        SET &CBGT = &STR(   &CBX)\n        SET &CBGI = &CBGL\n        SET &CBGE = &CBGI + 3\n        SET &CBG1 = &SUBSTR(&CBGI:&CBGE,&CBGT)\n        SET &CBGL = &LENGTH(&CBY)\n        SET &CBGT = &STR(  &CBY)\n        SET &CBGI = &CBGL\n        SET &CBGE = &CBGI + 2\n        SET &CBG2 = &SUBSTR(&CBGI:&CBGE,&CBGT)\n        SET &CBLOC = &STR(&CBG1 &CBG2)\n        IF &CBZ = YES THEN DO\n          SET &I = 1\n          DO WHILE &I LE 30\n            IF &I LE 9 THEN SET &SSS = &STR(0&I)\n            ELSE SET &SSS = &STR(&I)\n            SET T&SSS =\n            SET T&SSS.1 =\n            SET T&SSS.2 =\n            SET &I = &I + 1\n            END\n          ISPEXEC DISPLAY PANEL(PBOOK3)\n          IF &LASTCC EQ 0 THEN DO\n            SET &I = 1\n            SET &IP = 1\n            DO WHILE &I LE 30\n              IF &I LE 9 THEN SET &SSS = &STR(0&I)\n              ELSE SET &SSS = &STR(&I)\n              SET &SST = &STR(&CBC.T&SSS)\n              SET &SSG = &STR(&CBC.T&SSS.1)\n              SET &SSN = &STR(&CBC.T&SSS.2)\n              IF &SSG \u00ac= &Z THEN DO\n                SET &CBNW0 = &CBNW0 + 1\n                IF &SST = &Z THEN SET &SST = &STR(P)\n                SET CBNW&IP = &STR(&SSG-&SSN &SST)\n                SET &IP = &IP + 1\n                END\n              SET &I = &I + 1\n              END\n            IF &CBNW0 GT 1 THEN DO\n              SET &I = 1\n              DO WHILE &I LT &CBNW0\n                SET &IP = &I\n                SET &IN = &IP + 1\n                DO WHILE &IN LE &CBNW0\n                  IF &STR(&CBC.CBNW&IP) GT &STR(&CBC.CBNW&IN) THEN DO\n                    SET CBPASS = &STR(&CBC.CBNW&IN)\n                    SET CBNW&IN = &STR(&CBC.CBNW&IP)\n                    SET CBNW&IP = &STR(&CBPASS)\n                    END\n                  SET &IN = &IN + 1\n                  END\n                SET &I = &I + 1\n                END\n              END\n            END\n          END\n        SET &CBUSR = &ZUSER\n        ISPEXEC TBADD &CBLIST ORDER\n        SET &CBUPF = YES\n        END\n      SET &CBIN = &CBIN - 1\n      END\n    ISPEXEC CONTROL DISPLAY RESTORE\n    END\n  ELSE IF &CBAVL = YES THEN ISPEXEC SETMSG MSG(MBKS003U)\n  ELSE ISPEXEC SETMSG MSG(MBKS003T)\n  END\n/* - - - TNL COMMAND.  - - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ TNL THEN DO\n  IF &CBUPDT EQ YES THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    DO WHILE &CBIN GE 1\n      ISPEXEC TBVCLEAR &CBLIST\n      SET &CBN1 =\n      SET &CBN2 =\n      SET &NW =\n      SET &CBGNS =\n      SET &CBX =\n      SET &CBY =\n      SET &CBNW0 = 0\n      SET &I = 1\n      DO WHILE &I LE 30\n        SET CBNW&I =\n        IF &I LE 9 THEN SET &SSS = &STR(0&I)\n        ELSE SET &SSS = &STR(&I)\n        SET T&SSS.1 =\n        SET T&SSS.2 =\n        SET &I = &I + 1\n        END\n      ISPEXEC DISPLAY PANEL(PBOOK6)\n      IF &LASTCC EQ 0 THEN DO\n        IF &STR(&CBGNS) NE &Z THEN SET &CBMNO = &STR(&CBGNS)\n        ELSE DO\n          SET &CBGL = &LENGTH(&NW)\n          IF &CBGL EQ 1 THEN SET &CBN3 = &STR( &NW)\n          ELSE SET &CBN3 = &STR(&NW)\n          SET &CBMNO = &STR(&CBN1-&CBN2-&CBN3)\n          END\n        SET &CBGL = &LENGTH(&CBX)\n        SET &CBGT = &STR(   &CBX)\n        SET &CBGI = &CBGL\n        SET &CBGE = &CBGI + 3\n        SET &CBG1 = &SUBSTR(&CBGI:&CBGE,&CBGT)\n        SET &CBGL = &LENGTH(&CBY)\n        SET &CBGT = &STR(  &CBY)\n        SET &CBGI = &CBGL\n        SET &CBGE = &CBGI + 2\n        SET &CBG2 = &SUBSTR(&CBGI:&CBGE,&CBGT)\n        SET &CBLOC = &STR(&CBG1 &CBG2)\n        SET &I = 1\n        SET &IP = 1\n        DO WHILE &I LE 30\n          IF &I LE 9 THEN SET &SSS = &STR(0&I)\n          ELSE SET &SSS = &STR(&I)\n          SET &SSG = &STR(&CBC.T&SSS.1)\n          SET &SSN = &STR(&CBC.T&SSS.2)\n          IF &SSG \u00ac= &Z THEN DO\n            SET &CBNW0 = &CBNW0 + 1\n            SET CBNW&IP = &STR(&SSG-&SSN P)\n            SET &IP = &IP + 1\n            END\n          SET &I = &I + 1\n          END\n        IF &CBNW0 GT 1 THEN DO\n          SET &I = 1\n          DO WHILE &I LT &CBNW0\n            SET &IP = &I\n            SET &IN = &IP + 1\n            DO WHILE &IN LE &CBNW0\n              IF &STR(&CBC.CBNW&IP) GT &STR(&CBC.CBNW&IN) THEN DO\n                SET CBPASS = &STR(&CBC.CBNW&IN)\n                SET CBNW&IN = &STR(&CBC.CBNW&IP)\n                SET CBNW&IP = &STR(&CBPASS)\n                END\n              SET &IN = &IN + 1\n              END\n            SET &I = &I + 1\n            END\n          END\n        SET &CBTMN = &STR(*** MANUAL NOT RECEIVED ***)\n        SET &CBKW1 =\n        SET &CBKW2 =\n        SET &CBUSR = &ZUSER\n        ISPEXEC TBADD &CBLIST ORDER\n        SET &CBUPF = YES\n        END\n      SET &CBIN = &CBIN - 1\n      END\n    ISPEXEC CONTROL DISPLAY RESTORE\n    END\n  ELSE IF &CBAVL = YES THEN ISPEXEC SETMSG MSG(MBKS003U)\n  ELSE ISPEXEC SETMSG MSG(MBKS003T)\n  END\n/* - - - LIST COMMAND. - - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ LIST OR &CMD EQ FULL THEN DO\n  ERROR DO\n    ERROR OFF\n    FREE ATTR(VBA)\n    ATTR VBA RECFM(V B A) LRECL(137) BLKSIZE(6356) DSORG(PS)\n    ALLOC F(ISPFILE) DSN(BKTEMP.LISTING) REUSE CATALOG +\n      USING(VBA) SP(5 5) TRACKS\n    SET &CBPDEL = DELETE\n    END\n  ALLOC F(ISPFILE) DSN(BKTEMP.LISTING) OLD REUSE\n  ERROR OFF\n  IF &CMD EQ FULL THEN SET &CBPFULL = YES\n  ELSE SET &CBPFULL = NO\n  ISPEXEC FTOPEN\n  ISPEXEC FTINCL SBOOK0\n  ISPEXEC FTCLOSE\n  SET &CBPOPT =\n  IF &CBPDEST NE &Z THEN SET &CBPOPT = &STR(DEST(&CBPDEST))\n  IF &CBPCLAS NE &Z THEN SET &CBPOPT = &STR(&CBPOPT CLASS(&CBPCLAS))\n  PRINTO BKTEMP.LISTING &CBPOPT NOHEADING\n  ISPEXEC SETMSG MSG(MBKS003P)\n  END\n/* - - - D LINE-COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &ZTDSELS GE 1 THEN DO\n  IF &ACT EQ D THEN DO\n    IF &CBUPDT EQ YES THEN -\n      DO WHILE &N GE 1\n        ISPEXEC TBDELETE &CBLIST\n        ISPEXEC TBSKIP &CBLIST\n        IF &LASTCC NE 0 THEN SET &N = 0\n        ELSE SET &N = &N - 1\n        SET &CBUPF = YES\n        END\n    ELSE IF &CBAVL = YES THEN ISPEXEC SETMSG MSG(MBKS003U)\n    ELSE ISPEXEC SETMSG MSG(MBKS003T)\n    END\n/* - - - R LINE-COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\n  ELSE IF &ACT EQ R THEN DO\n    IF &CBUPDT EQ YES THEN -\n      DO WHILE &N GE 1\n        ISPEXEC TBADD &CBLIST ORDER\n        SET &N = &N - 1\n        SET &CBUPF = YES\n        END\n    ELSE IF &CBAVL = YES THEN ISPEXEC SETMSG MSG(MBKS003U)\n    ELSE ISPEXEC SETMSG MSG(MBKS003T)\n    END\n/* - - - S LINE-COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\n  ELSE IF &ACT EQ S THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    DO WHILE &N GE 1\n      ISPEXEC DISPLAY PANEL(PBOOK4)\n      IF &LASTCC NE 0 THEN SET &N = 0\n      ELSE SET &N = &N - 1\n      IF &N NE 0 THEN DO\n        ISPEXEC TBSKIP &CBLIST\n        IF &LASTCC NE 0 THEN SET &N = 0\n        END\n      END\n    ISPEXEC CONTROL DISPLAY RESTORE\n    END\n/* - - - U LINE-COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\n  ELSE IF &ACT EQ U THEN DO\n    IF &CBUPDT EQ YES THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      DO WHILE &N GE 1\n        SET CBKW1X = &STR(&CBKW1)\n        SET CBKW2X = &STR(&CBKW2)\n        SET CBMNOX = &STR(&CBMNO)\n        SET CBLOCX = &STR(&CBLOC)\n        SET CBROOMX = &STR(&CBROOM)\n        SET CBTMNX = &NRSTR(&CBTMN)\n        SET CBNW0X = &CBNW0\n        SET &I = 1\n        DO WHILE &I LE 30\n          SET CBNW&I.X = &STR(&CBC.CBNW&I)\n          SET &I = &I + 1\n          END\n        SET &CBGT = &SUBSTR(5:5,&CBMNO)\n        IF &STR(&CBGT) = &STR(-) THEN DO\n          SET &CBN1 = &SUBSTR(1:4,&CBMNO)\n          SET &CBN2 = &SUBSTR(6:9,&CBMNO)\n          SET &CBGV = &SUBSTR(11:11,&CBMNO)\n          IF &CBGV = &STR( ) THEN SET &NW = &SUBSTR(12:12,&CBMNO)\n          ELSE SET &NW = &SUBSTR(11:12,&CBMNO)\n          SET &CBGNS =\n          END\n        ELSE DO\n          SET &CBN1 =\n          SET &CBN2 =\n          SET &NW =\n          SET &CBGNS = &STR(&CBMNO)\n          END\n        SET &CBGV = &SUBSTR(1:4,&CBLOC)\n        SET &CBX = &CBGV\n        SET &CBGV = &SUBSTR(6:8,&CBLOC)\n        SET &CBY = &CBGV\n        ISPEXEC DISPLAY PANEL(PBOOK2)\n        SET &RCLC = &LASTCC\n        IF &RCLC EQ 0 THEN DO\n          IF &STR(&CBGNS) NE &Z THEN SET &CBMNO = &STR(&CBGNS)\n          ELSE DO\n            SET &CBGL = &LENGTH(&NW)\n            IF &CBGL EQ 1 THEN SET &CBN3 = &STR( &NW)\n            ELSE SET &CBN3 = &STR(&NW)\n            SET &CBMNO = &STR(&CBN1-&CBN2-&CBN3)\n            END\n          SET &CBGL = &LENGTH(&CBX)\n          SET &CBGT = &STR(   &CBX)\n          SET &CBGI = &CBGL\n          SET &CBGE = &CBGI + 3\n          SET &CBG1 = &SUBSTR(&CBGI:&CBGE,&CBGT)\n          SET &CBGL = &LENGTH(&CBY)\n          SET &CBGT = &STR(  &CBY)\n          SET &CBGI = &CBGL\n          SET &CBGE = &CBGI + 2\n          SET &CBG2 = &SUBSTR(&CBGI:&CBGE,&CBGT)\n          SET &CBLOC = &STR(&CBG1 &CBG2)\n          IF &CBZ = YES THEN DO\n            SET &I = 1\n            DO WHILE &I LE 30\n              IF &I LE 9 THEN SET &SSS = &STR(0&I)\n              ELSE SET &SSS = &STR(&I)\n              SET T&SSS =\n              SET T&SSS.1 =\n              SET T&SSS.2 =\n              SET &I = &I + 1\n              END\n            IF &CBNW0 NE 0 THEN DO\n              SET &I = 1\n              DO WHILE &I LE &CBNW0\n                IF &I LE 9 THEN SET &SSS = &STR(0&I)\n                ELSE SET &SSS = &STR(&I)\n                SET T&SSS.1 = &SUBSTR(1:4,&CBC.CBNW&I)\n                SET T&SSS.2 = &SUBSTR(6:9,&CBC.CBNW&I)\n                SET T&SSS = &SUBSTR(11:11,&CBC.CBNW&I)\n                SET &I = &I + 1\n                END\n              END\n            ISPEXEC DISPLAY PANEL(PBOOK3)\n            SET &RCNC = &LASTCC\n            IF &RCNC EQ 0 THEN DO\n              SET &CBNW0 = 0\n              SET &I = 1\n              DO WHILE &I LE 30\n                SET CBNW&I =\n                SET &I = &I + 1\n                END\n              SET &I = 1\n              SET &IP = 1\n              DO WHILE &I LE 30\n                IF &I LE 9 THEN SET &SSS = &STR(0&I)\n                ELSE SET &SSS = &STR(&I)\n                SET &SST = &STR(&CBC.T&SSS)\n                SET &SSG = &STR(&CBC.T&SSS.1)\n                SET &SSN = &STR(&CBC.T&SSS.2)\n                IF &SSG \u00ac= &Z THEN DO\n                  SET &CBNW0 = &CBNW0 + 1\n                  IF &SST = &Z THEN SET &SST = &STR(P)\n                  SET CBNW&IP = &STR(&SSG-&SSN &SST)\n                  SET &IP = &IP + 1\n                  END\n                SET &I = &I + 1\n                END\n              IF &CBNW0 GT 1 THEN DO\n                SET &I = 1\n                DO WHILE &I LT &CBNW0\n                  SET &IP = &I\n                  SET &IN = &IP + 1\n                  DO WHILE &IN LE &CBNW0\n                    IF &STR(&CBC.CBNW&IP) GT &STR(&CBC.CBNW&IN) THEN DO\n                      SET CBPASS = &STR(&CBC.CBNW&IN)\n                      SET CBNW&IN = &STR(&CBC.CBNW&IP)\n                      SET CBNW&IP = &STR(&CBPASS)\n                      END\n                    SET &IN = &IN + 1\n                    END\n                  SET &I = &I + 1\n                  END\n                END\n              END\n            ELSE IF &RCNC GT 8 THEN GOTO UPDX\n            ELSE ISPEXEC SETMSG MSG(MBKS004U)\n            END\n          IF &STR(&CBMNOX) \u00ac= &STR(&CBMNO) THEN DO\n            SET &CBNW0 = 0\n            SET &I = 1\n            DO WHILE &I LE 30\n              SET CBNW&I =\n              SET &I = &I + 1\n              END\n            GOTO UPDU\n            END\n          IF &STR(&CBKW1X) \u00ac= &STR(&CBKW1) THEN GOTO UPDU\n          IF &STR(&CBKW2X) \u00ac= &STR(&CBKW2) THEN GOTO UPDU\n          IF &STR(&CBLOCX) \u00ac= &STR(&CBLOC) THEN GOTO UPDU\n          IF &STR(&CBROOMX) \u00ac= &STR(&CBROOM) THEN GOTO UPDU\n          IF &NRSTR(&CBTMNX) \u00ac= &NRSTR(&CBTMN) THEN GOTO UPDU\n          IF &CBNW0X \u00ac= &CBNW0 THEN GOTO UPDU\n          SET &I = 1\n          DO WHILE &I LE 30\n            IF &STR(&CBC.CBNW&I.X) \u00ac= &STR(&CBC.CBNW&I) THEN GOTO UPDU\n            SET &I = &I + 1\n            END\n          ISPEXEC SETMSG MSG(MBKS004M)\n          GOTO UPDN\nUPDU:     SET &CBUSR = &ZUSER\n          ISPEXEC TBPUT &CBLIST ORDER\n          ISPEXEC SETMSG MSG(MBKS004S)\n          SET &CBUPF = YES\n          END\n        ELSE IF &RCLC GT 8 THEN GOTO UPDX\n        ELSE ISPEXEC SETMSG MSG(MBKS004N)\nUPDN:   IF &N EQ 1 THEN GOTO UPDX\n        ISPEXEC TBSKIP &CBLIST\n        IF &LASTCC NE 0 THEN SET &N = 0\n        ELSE SET &N = &N - 1\n        END\nUPDX: ISPEXEC CONTROL DISPLAY RESTORE\n      END\n    ELSE IF &CBAVL = YES THEN ISPEXEC SETMSG MSG(MBKS003U)\n    ELSE ISPEXEC SETMSG MSG(MBKS003T)\n    END\n/* - - - T LINE-COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\n  ELSE IF &ACT EQ T THEN DO\n    IF &CBUPDT EQ YES THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      DO WHILE &N GE 1\n        IF &NRSTR(&CBTMN) NE &STR(*** MANUAL NOT RECEIVED ***) THEN -\n          GOTO TNLN\n        SET CBMNOX = &STR(&CBMNO)\n        SET CBLOCX = &STR(&CBLOC)\n        SET CBROOMX = &STR(&CBROOM)\n        SET CBNW0X = &CBNW0\n        SET &I = 1\n        DO WHILE &I LE 30\n          SET CBNW&I.X = &STR(&CBC.CBNW&I)\n          SET &I = &I + 1\n          END\n        SET &CBGT = &SUBSTR(5:5,&CBMNO)\n        IF &STR(&CBGT) = &STR(-) THEN DO\n          SET &CBN1 = &SUBSTR(1:4,&CBMNO)\n          SET &CBN2 = &SUBSTR(6:9,&CBMNO)\n          SET &CBGV = &SUBSTR(11:11,&CBMNO)\n          IF &CBGV = &STR( ) THEN SET &NW = &SUBSTR(12:12,&CBMNO)\n          ELSE SET &NW = &SUBSTR(11:12,&CBMNO)\n          SET &CBGNS =\n          END\n        ELSE DO\n          SET &CBN1 =\n          SET &CBN2 =\n          SET &NW =\n          SET &CBGNS = &STR(&CBMNO)\n          END\n        SET &CBGV = &SUBSTR(1:4,&CBLOC)\n        SET &CBX = &CBGV\n        SET &CBGV = &SUBSTR(6:8,&CBLOC)\n        SET &CBY = &CBGV\n        SET &I = 1\n        DO WHILE &I LE 30\n          IF &I LE 9 THEN SET &SSS = &STR(0&I)\n          ELSE SET &SSS = &STR(&I)\n          SET T&SSS.1 =\n          SET T&SSS.2 =\n          SET &I = &I + 1\n          END\n        IF &CBNW0 NE 0 THEN DO\n          SET &I = 1\n          DO WHILE &I LE &CBNW0\n            IF &I LE 9 THEN SET &SSS = &STR(0&I)\n            ELSE SET &SSS = &STR(&I)\n            SET T&SSS.1 = &SUBSTR(1:4,&CBC.CBNW&I)\n            SET T&SSS.2 = &SUBSTR(6:9,&CBC.CBNW&I)\n            SET &I = &I + 1\n            END\n          END\n        ISPEXEC DISPLAY PANEL(PBOOK6)\n        SET &RCLC = &LASTCC\n        IF &RCLC EQ 0 THEN DO\n          IF &STR(&CBGNS) NE &Z THEN SET &CBMNO = &STR(&CBGNS)\n          ELSE DO\n            SET &CBGL = &LENGTH(&NW)\n            IF &CBGL EQ 1 THEN SET &CBN3 = &STR( &NW)\n            ELSE SET &CBN3 = &STR(&NW)\n            SET &CBMNO = &STR(&CBN1-&CBN2-&CBN3)\n            END\n          SET &CBGL = &LENGTH(&CBX)\n          SET &CBGT = &STR(   &CBX)\n          SET &CBGI = &CBGL\n          SET &CBGE = &CBGI + 3\n          SET &CBG1 = &SUBSTR(&CBGI:&CBGE,&CBGT)\n          SET &CBGL = &LENGTH(&CBY)\n          SET &CBGT = &STR(  &CBY)\n          SET &CBGI = &CBGL\n          SET &CBGE = &CBGI + 2\n          SET &CBG2 = &SUBSTR(&CBGI:&CBGE,&CBGT)\n          SET &CBLOC = &STR(&CBG1 &CBG2)\n          SET &CBNW0 = 0\n          SET &I = 1\n          DO WHILE &I LE 30\n            SET CBNW&I =\n            SET &I = &I + 1\n            END\n          SET &I = 1\n          SET &IP = 1\n          DO WHILE &I LE 30\n            IF &I LE 9 THEN SET &SSS = &STR(0&I)\n            ELSE SET &SSS = &STR(&I)\n            SET &SSG = &STR(&CBC.T&SSS.1)\n            SET &SSN = &STR(&CBC.T&SSS.2)\n            IF &SSG \u00ac= &Z THEN DO\n              SET &CBNW0 = &CBNW0 + 1\n              SET CBNW&IP = &STR(&SSG-&SSN P)\n              SET &IP = &IP + 1\n              END\n            SET &I = &I + 1\n            END\n          IF &CBNW0 GT 1 THEN DO\n            SET &I = 1\n            DO WHILE &I LT &CBNW0\n              SET &IP = &I\n              SET &IN = &IP + 1\n              DO WHILE &IN LE &CBNW0\n                IF &STR(&CBC.CBNW&IP) GT &STR(&CBC.CBNW&IN) THEN DO\n                  SET CBPASS = &STR(&CBC.CBNW&IN)\n                  SET CBNW&IN = &STR(&CBC.CBNW&IP)\n                  SET CBNW&IP = &STR(&CBPASS)\n                  END\n                SET &IN = &IN + 1\n                END\n              SET &I = &I + 1\n              END\n            END\n          IF &STR(&CBMNOX) \u00ac= &STR(&CBMNO) THEN GOTO TNLU\n          IF &STR(&CBLOCX) \u00ac= &STR(&CBLOC) THEN GOTO TNLU\n          IF &STR(&CBROOMX) \u00ac= &STR(&CBROOM) THEN GOTO TNLU\n          IF &CBNW0X \u00ac= &CBNW0 THEN GOTO TNLU\n          SET &I = 1\n          DO WHILE &I LE 30\n            IF &STR(&CBC.CBNW&I.X) \u00ac= &STR(&CBC.CBNW&I) THEN GOTO TNLU\n            SET &I = &I + 1\n            END\n          ISPEXEC SETMSG MSG(MBKS004M)\n          GOTO TNLN\nTNLU:     SET &CBUSR = &ZUSER\n          ISPEXEC TBPUT &CBLIST ORDER\n          ISPEXEC SETMSG MSG(MBKS004S)\n          SET &CBUPF = YES\n          END\n        ELSE IF &RCLC GT 8 THEN GOTO TNLX\n        ELSE ISPEXEC SETMSG MSG(MBKS004N)\nTNLN:   IF &N EQ 1 THEN GOTO TNLX\n        ISPEXEC TBSKIP &CBLIST\n        IF &LASTCC NE 0 THEN SET &N = 0\n        ELSE SET &N = &N - 1\n        END\nTNLX: ISPEXEC CONTROL DISPLAY RESTORE\n      END\n    ELSE IF &CBAVL = YES THEN ISPEXEC SETMSG MSG(MBKS003U)\n    ELSE ISPEXEC SETMSG MSG(MBKS003T)\n    END\n  END\nGOTO LOOP\n/* - - - END-CANCEL COMMANDS.  - - - - - - - - - - - - - - - - - - - */\nLEAVE: FREE F(ISPFILE) ATTR(VBA) &CBPDEL\nIF &CMD EQ CANCEL THEN DO\n  ISPEXEC TBEND &CBLIST\n  ISPEXEC SETMSG MSG(MBKS002C)\n  END\nELSE IF &CBUPF EQ &Z THEN DO\n  ISPEXEC TBEND &CBLIST\n  ISPEXEC SETMSG MSG(MBKS002N)\n  END\nELSE DO\n  ISPEXEC TBSORT &CBLIST +\n    FIELDS(CBKW1,C,A CBKW2,C,A CBMNO,C,A CBLOC,C,A)\n  IF &CBUPDT EQ YES THEN DO\n    ISPEXEC TBCLOSE &CBLIST REPLCOPY PAD(15)\n    ISPEXEC SETMSG MSG(MBKS002S)\n    END\n  ELSE DO\n    ISPEXEC TBCLOSE &CBLIST\n    ISPEXEC SETMSG MSG(MBKS002N)\n    END\n  END\nQUIT: ISPEXEC LIBDEF ISPTLIB LIBRARY\nISPEXEC LIBDEF ISPTABL LIBRARY\nFREE F(CBTABL)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CENTER": {"ttr": 10753, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x179\\x00T\\x00T\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T17:39:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM) NOPROCESS\n/*  MACRO NAME : CENTER                                             */\n/*    FUNCTION : CENTER TEXT WITHIN DATA LINE(S)                    */\n/*      SYNTAX : CENTER                                             */\n/*               CENTER HELP OR H                                   */\n/*       DEBUG : CENTER LIST                                        */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(HELP) OR +\n      &STR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTCNTR)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ISPEXEC CONTROL ERRORS RETURN\n  CONTROL ASIS\n/*               PROCESS LINE COMMANDS, CHECK IF C WAS SPECIFIED    */\n  ISREDIT PROCESS RANGE C\n  SET LCC = &LASTCC\n  ISREDIT (RC) = RANGE_CMD\n  SET RCC = &LASTCC\n  IF &LCC \u00ac=0 OR &RCC \u00ac=0 THEN DO\n    IF &RCC = 4 THEN DO\n      IF &STR(&RC) \u00ac= &STR(C) THEN DO\n        IF &LCC = 4 THEN SET &ZEDSMSG = &STR(NO RANGE)\n        ELSE SET &ZEDSMSG = &STR(INVALID RANGE)\n        SET &ZEDLMSG = &STR(YOU MUST SPECIFY A TARGET RANGE OF +\n                            LINES, USING \"CN\" OR \"CC\")\n        END\n      ELSE DO\n        SET &ZEDSMSG = &STR(RANGE INCOMPLETE)\n        SET &ZEDLMSG = &STR(ENTER A MATCHING \"CC\" TO COMPLETE +\n                            THE BLOCK COMMAND PAIR)\n        END\n      END\n    ELSE IF &RCC = 8 THEN DO\n      SET &ZEDSMSG = &STR(NOT ACCEPTABLE)\n      SET &ZEDLMSG = &STR(AN UNACCEPTABLE TARGET RANGE OF LINES +\n                          HAS BEEN SPECIFIED)\n      END\n    ELSE DO\n      SET &ZEDSMSG = &STR(SEVERE ERROR)\n      SET &ZEDLMSG = &STR(SEVERE ERROR OCCURED, RETURN CODES ARE +\n                          &LCC AND &RCC)\n      END\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n    END\n  ISREDIT (FR) = LINENUM .ZFRANGE\n  ISREDIT (LR) = LINENUM .ZLRANGE\n  ISREDIT (LB,RB) = BOUNDS\n  SET I = &FR\n  DO WHILE (&I <= &LR)\n    ISREDIT\n    ISREDIT LABEL &I = .LJ\n    ISREDIT SEEK P'\u00ac' .LJ .LJ &LB &RB FIRST\n    ISREDIT (LLINE,LCOL) = CURSOR\n    ISREDIT SEEK P'\u00ac' .LJ .LJ &LB &RB LAST\n    ISREDIT (RLINE,RCOL) = CURSOR\n    SET MIDPT = &EVAL(&RB - &LB) / 2\n    SET MIDPT = &MIDPT + &LB\n    SET LEFT = &MIDPT - &LCOL\n    SET RIGHT = &RCOL - &MIDPT\n    SET COUNT = &EVAL(&LEFT - &RIGHT + 1) / 2\n    IF &COUNT > 0 THEN ISREDIT SHIFT ) &I &COUNT\n    ELSE IF &COUNT < 0 THEN DO\n      SET COUNT = -1 * &COUNT\n      ISREDIT SHIFT ( &I &COUNT\n      END\n    IF &I = &FR THEN ISREDIT LABEL &I = .LJX\n    SET I = &I + 1\n  END\n  ISREDIT SEEK P'=' .LJX .LJX FIRST\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CENTER@": {"ttr": 10756, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11W\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:57:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "1   21/07/89\n                                                      CENTER    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    CENTER ISPF/PDF EDIT command     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to center text within data\n  ----------   line(s).\n\n  Command syntax : CENTER\n  ---------------- CENTER HELP or H\n\n  Use :        Type CENTER on the COMMAND line and mark the range of\n  -----        lines text with the \"C\" range command on the line\n               numbers, as i.e. :\n               COMMAND ===> CENTER\n          ---> CC 500   --------------\n               000600   |  TITLE ... |\n          ---> CC 700   --------------\n               000800   Subtitle : ...\n               Result : the text of lines numbered 500, 600 and 700\n                        will be centered. Identical process is obtained\n                        with :\n          ---> C3 500   --------------\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CNVCLIS$": {"ttr": 10758, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x1f\\x00\\x88\\x15\\x1f\\x12\\x02\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-30T00:00:00", "modifydate": "1988-05-30T12:02:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//CNVCLIST JOB (........),'INSTALL - CNVCLIST -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS2,MBR=CNVCLIST\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  ENTRY   CNVCLIST\n  NAME    CNVCLIST(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CNVCLIS@": {"ttr": 10760, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x1f\\x00\\x88\\x15\\x1f\\x12\\x02\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-30T00:00:00", "modifydate": "1988-05-30T12:02:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SYSPAJA"}, "text": "1   26/05/88\n                                                      CNVCLIST  1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    C O N V E R T     C L I S T S    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : extracted from CBT tape 88 FEB, file 187.\n  ------------\n\n  FUNCTION : program to convert CLISTs from 255 LRECL VB to 80 LRECL FB\n             or vice versa.\n\n  I/O :  SYSUT1 = input CLISTs.\n         SYSUT2 = output CLISTs.\n         SYSPRINT = listing.\n\n  NOTES : - VB CLISTs have sequence numbers in pos. 1-8, FB in 73-80.\n          - All input members (CLISTs) are added to output data-set\n            unless duplicate names.\n\n  RETURN CODE :  0 = job terminated successfully.\n                 8 = job terminated before start of copy.\n                12 = job terminated after start of copy.\n\n  JCL :  //...      EXEC PGM=CNVCLIST\n         //SYSUT1     DD DSN=...input data-set...,DISP=SHR\n         //SYSUT2     DD DSN=...output data-set...,DISP=OLD\n         //SYSPRINT   DD SYSOUT=A\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CNVCLIST": {"ttr": 10762, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882o\\x00\\x882o\\x12\\x19\\x01\\xc6\\x01\\xc6\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-21T00:00:00", "modifydate": "1988-11-21T12:19:00", "lines": 454, "newlines": 454, "modlines": 0, "user": "SYSPAJA"}, "text": "CNVC     TITLE 'CONVERT CLISTS FROM 255 LRECL VB TO 80 LRECL FB.'\nCNVCLIST START 0\n         SPACE 1\n*   FUNCTION : CONVERT CLISTS FROM 255 LRECL VB TO 80 LRECL FB OR VICE\n*              VERSA.\n*\n*        I/O : SYSUT1 = INPUT CLISTS\n*              SYSUT2 = OUTPUT CLISTS\n*              SYSPRINT = LISTING\n*\n*    NOTES : - VB CLISTS HAVE SEQUENCE NUMBERS IN POS 1-8, FB IN 73-80.\n*            - ALL INPUT MEMBERS (CLISTS) ARE ADDED TO OUTPUT DATA-SET\n*              UNLESS DUPLICATE NAMES.\n*\n* RETURN CODE :  0 = JOB TERMINATED SUCCESSFULLY.\n*                8 = JOB TERMINATED BEFORE START OF COPY.\n*               12 = JOB TERMINATED AFTER START OF COPY.\n*\n* REGISTERS USE :  R3 = OUTPUT START OF BLOCK.\n*                  R4 = INPUT START OF BLOCK.\n*                  R5 = LENGTH CODE.\n*                  R6 = INPUT POINTER.\n*                  R7 = OUTPUT POINTER.\n*                 R10 = DCB TEMPLATE.\n*                 R11 = LINK REGISTER.\n*\n*     ORIGIN : EXTRACTED FROM CBT TAPE 88 FEB, FILE 187.\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12\n        OPEN   (CLISTIN,(INPUT))\n         SPACE 1\n        OPEN   (CLISTOUT,(OUTPUT))\n         SPACE 1\n         USING IHADCB,R10\n         LA    R10,CLISTIN         USE DCB NAME FOR INPUT DCB\n         MVI   MSG0+5,C'1'\n         BAS   R11,TESTVORF\n         BAS   R11,GETMAIN         GET CORE FOR INPUT BLOCK\n         LR    R4,R1               SAVE INPUT BLOCK ADDRESS\n         LA    R10,CLISTOUT        USE DCB NAME FOR OUTPUT DCB\n         MVI   MSG0+5,C'2'\n         BAS   R11,TESTVORF\n         BAS   R11,GETMAIN         GETMAIN FOR OUTPUT BLOCK\n         LR    R3,R1               SAVE OUTPUT BLOCK ADDRESS\n         TM    SWITCH,T80          IF ONE FILE IS F AND ONE V\n         BO    SAVEOUT             CONTINUE\n         LA    R1,MSG3\n         B     ERR8\n         EJECT\nTESTVORF TM    DCBOFLGS,DCBOFOPN   CHECK OPEN SUCCESSFULL\n         BO    TESTVF\n         LA    R1,MSG0\n         B     ERR8\nTESTVF   TM    DCBRECFM,DCBRECU    CHECK FOR V OR F\n         BM    CONTVF              IF NOT V OR F ERROR\n         MVC   MSG1+5(1),MSG0+5\n         LA    R1,MSG1\n         B     ERR8\nCONTVF   TM    DCBRECFM,DCBRECF    IF V\n         BZR   R11                 RETURN\n         XI    SWITCH,T80          FIRST F TURNS ON-SECOND OFF\n         CLC   DCBLRECL,=H'80'     IF F AND LRECL NOT = 80\n         BER   R11                 THEN ERROR, RETURN\n         MVC   MSG2+5(1),MSG0+5\n         LA    R1,MSG2\n         B     ERR8\n         SPACE 1\nGETMAIN  LH    R0,DCBBLKSI         GET CORE FOR PROCESSING AN\n        GETMAIN R,LV=(0)           INPUT BLOCK\n         BR    R11\n         EJECT\nSAVEOUT  MVC   OUTBLKSI,DCBBLKSI   SAVE DATA FOR MAINLINE\n         LR    R7,R3               INITIALIZE OUTPUT POINTER\n         TM    DCBRECFM,DCBRECF    IF OUTPUT IS V\n         BZ    SAVEIN              SAVE INPUT END OF BLOCK\n         OI    SWITCH,T20          ELSE SET INPUT SWITCH TO V\n         LH    R2,DCBBLKSI\n         LA    R2,0(R2,R3)         SAVE OUTPUT END OF FIXED BLOCK\n         ST    R2,ENDF\n         LA    R10,CLISTIN\n         B     INITRD\n         SPACE 1\nSAVEIN   LA    R10,CLISTIN\n         LH    R2,DCBBLKSI         SAVE INPUT END OF FIXED BLOCK\n         LA    R2,0(R2,R4)\n         ST    R2,ENDF\n         LH    R2,OUTBLKSI         SAVE MAXIMUM END OF OUTPUT\n         LA    R2,0(R2,R3)         VARIABLE BLOCK\n         ST    R2,ENDV\n         LA    R7,4(R7)            POINT PAST BLK COUNT FOR V\n         SPACE 1\nINITRD  CLOSE  (CLISTIN)\n         MVI   DCBRECFM,DCBRECU    SET INPUT RECFM TO U\n         MVI   CLISTOUT+(DCBRECFM-IHADCB),DCBRECU SET OUTPUT RECFM TO U\n        OPEN   (CLISTIN,(INPUT))\n         SPACE 1\nREADDIR  OI    SWITCH,T40          SET DIRECTORY READ ON\n        READ   DECB1,SF,CLISTIN,DIRIN,256\n        CHECK  DECB1\n        NOTE   CLISTIN\n         XI    DIRSW,ALLON         SINCE SAVETTR POINTS TO\n         CLI   DIRSW,ALLOFF        BEGINNING OF DIRECTORY, READ\n         BE    READDIR             TWICE AFTER FIRST READ.\n         ST    R1,SAVETTR          SAVE POINTER TO DIRECTORY\n         LH    R9,DIRIN\n         STH   R9,DIRLEFT          SAVE DIRECTORY LENGTH\n         LA    R9,DIRIN+2\n         ST    R9,NEXTMEM\n         SPACE 1\nGETMEM   ZAP   SEQCOUNT,=P'0'      ZERO OUT SEQUENCE COUNT FOR MEM\n         L     R8,NEXTMEM          LOAD ADDRESS OF MEMBER NAME\n         CLC   0(8,R8),=XL8'FFFFFFFFFFFFFFFF'     IF MEMBER NAME EQUAL\n         BE    EOJ                 HI-VALUES, GO TO END OF JOB\n         MVC   NAME,0(R8)          PUT NAME IN OUTPUT DIRECTORY LIST\n         XC    TTR,TTR\n         MVC   C(L'C+L'USERDATA),11(R8) MOVE C/USERDATA TO DIR LIST\n         NI    C,X'1F'             NUMBER OF HALFWORDS OF USER DATA\n         XR    R2,R2               CLEAR REGISTER\n         IC    R2,C                LOAD # OF HALFWORDS OF USER DATA\n         LA    R2,12(R2,R2)        DOUBLE AND ADD 12\n         LA    R9,0(R2,R8)         COMPUTE NEXT MEMBER DIR ADDRESS\n         ST    R9,NEXTMEM          SAVE ADDRESS OF NEXT MEMBER\n         LH    R9,DIRLEFT          COMPUTE BYTES LEFT IN\n         SR    R9,R2               DIRECTORY\n         STH   R9,DIRLEFT\n         MVI   11(R8),0            CLEAR C OF TTRC\n         LA    R8,8(R8)            SET ADDRESS OF TTR\n         NI    SWITCH,255-T40      TURN DIRECTORY READ SW OFF\n         MVC   BLDLNM,NAME\n         XC    BLDLNM+L'BLDLNM(50),BLDLNM+L'BLDLNM\n        BLDL   CLISTOUT,BLDLLIST\n         B     *+L'*(R15)\n         B     MDUP                0 - SUCCESFULLY COMPLETE\n         B     CPYM                4 - NOT FOUND\n         LR    R15,R0              8 - BLDL ERROR\n         B     *+L'*(R15)\n         B     ERR0                0 - I/O ERROR\n         B     ERR4                4 - NO REGION SPACE\n         LA    R1,MSGL             8 - INVALID DEB\n         B     ERRMBN\nERR0     LA    R1,MSGJ\n         B     ERRMBN\nERR4     LA    R1,MSGK\n         B     ERRMBN\nMDUP     MVC   DUPNAME,NAME        DUPLICATE NAME\n         MVC   PRTLINE,DUPLINE\n         BAS   R11,PUTPRNT\n         MVI   DUPCC,C' '          SET SINGLE SPACE AFTER FIRST\n         B     CHECKDIR            SKIP THIS MEMBER (CLIST)\nCPYM    POINT  CLISTIN,(R8)\n         LH    R8,DCBBLKSI         LOAD INPUT BLKSIZE\nREADBLK READ   DECB2,SF,CLISTIN,(R4),(R8)\n        CHECK  DECB2\n         TM    SWITCH,T20          IF INPUT IS F\n         BZ    FTOV                CONVERT FIXED TO VARIABLE\nVTOF     LH    R2,0(R4)            ADD BLKSIZE AND STARTING\n         AR    R2,R4               ADDRESS\n         ST    R2,ENDV             GIVING ENDING ADDRESS\n         LR    R6,R4               LOAD POINTER TO V INPUT\n         LA    R6,4(R6)            POINT TO FIRST LRECL\n         SPACE 1\nGETREC   MVC   HALFWORD,0(R6)\n         LH    R5,HALFWORD\n         CH    R5,=H'255'          IF LRECL IS GREATER THAN 255\n         BNH   *+L'*+8\n         LA    R1,MSG4             ERROR MESSAGE\n         B     ERR12\n         SH    R5,=H'12'           POINT PAST 4 BYTE LRECL AND\n         LA    R6,12(R6)           8 BYTE LINE SEQUENCE FIELD\nLOOPREC  STH   R5,LRECL            SAVE LRECL\n         CH    R5,=H'71'           IF LRECL GREATER THAN 71\n         BH    SPLITREC            SPLIT RECORD\n         BCTR  R5,0                MAKE LENGTH CODE\n         LA    R2,0(R5,R6)         POINT TO LAST BYTE OF REC\n         MVC   REC80,REC80-1       CLEAR RECORD AREA\n         CLI   0(R2),C'-'          IF LAST BYTE = '-'\n         BNE   SKIPLOOP            MOVE '-' TO COLUMN 72\n         MVI   REC80+71,C'-'\n         MVI   0(R2),C' '          BLANK OUT OLD '-'\n         LA    R9,REC80+71         LOAD ADDRESS COLUMN 72\nBACKLOOP BCTR  R9,0\n         BCTR  R2,0\n         CLI   0(R2),C' '          IF LAST BYTE IS SPACE\n         BE    SKIPLOOP            EXIT\n         CR    R6,R2               IF AT START OF RECORD\n         BH    SKIPLOOP            DONT MOVE ANYMORE\n         MVC   0(1,R9),0(R2)       MOVE CONT WORD TO END OF OUTREC\n         MVI   0(R2),C' '          BLANK OUT CONT INPUT WORD\n         B     BACKLOOP\nSKIPLOOP EX    R5,MOVE80           MOVE RECORD\n         BAS   R11,WRITEF\n         LA    R5,1(R5)\n         LA    R6,0(R5,R6)         INCREMENT CURRET POINTER BY LENG\n         C     R6,ENDV             IF ADDRESS POINTER IS LESS THAN\n         BL    GETREC              END ADDRESS GO TO GETREC\n         B     READBLK             ELSE READ A BLOCK\nSPLITREC LH    R5,=H'70'\nSPLTLOOP LA    R2,0(R5,R6)         ADDRESS OF END OF REC TO BE MOVE\n         CLI   0(R2),C' '          FIND A BLANK SO WORD IS NOT\n         BE    CONTSPLT            SPLIT\n         BCTR  R5,0\n         B     SPLTLOOP\nCONTSPLT MVC   REC80,REC80-1       CLEAR OUTPUT RECORD\n         MVI   REC80+71,C'-'       MOVE IN CONTUATION CHARACTER\n         EX    R5,MOVE80           MOVE TO WRITE AREA\n         BAS   R11,WRITEF\n         LA    R2,1(R5)            ADD 1 REC LENGTH OF RECORD\n         LH    R5,LRECL            WRITTEN\n         SR    R5,R2               SUBTRACT FROM LRECL\n         LA    R6,0(R2,R6)         INCREMENT IPOINTER BY LENGTH\n         B     LOOPREC             FINISH RECORD\nFTOV     LA    R2,0(R8,R4)         FIND END OF BLOCK ADRESS\n         L     R9,DECB2+16         LOAD IOB ADDRESS\n         LH    R9,14(R9)           LOAD LENGTH BLOCK IS SHORT\n         SR    R2,R9               SUBTRACT FROM END OF FULL BLK\n         ST    R2,ENDF             GIVING REAL END OF BLOCK\n         LR    R6,R4               POINT TO START OF INPUT BLOCK\nNEXTFREC LA    R5,70(R6)           POINT TO LAST CHAR BEFORE CONT\nLOOPFV   CLI   0(R5),C' '          FIND LAST NON BLANK CHARACTER\n         BNE   FOUNDATA\n         BCTR  R5,0\n         B     LOOPFV\nFOUNDATA SR    R5,R6               SUBTRACT START FROM END GIV LENG\n         CH    R5,=H'10'\n         BH    *+L'*+4             IF LENGTH CODE IS LESS THAN 10\n         LA    R5,10               USE 10\n         CLI   71(R6),C'-'         IF THERE IS  NO CONTINUATION\n         BNE   WRITEV              GO TO WRITEV\n         CLI   70(R6),C' '         IF POS 71 IS BLANK\n         BNE   *+L'*+4             PUT 1 BLANK BEFORE CONTINUATON\n         LA    R5,1(R5)            ELSE NONE\n         LA    R5,1(R5)\n         LA    R2,0(R5,R6)         PUT - IN LAST BYTE OF\n         MVI   0(R2),C'-'          INPUT RECORD TO BE MOVED\nWRITEV   LA    R2,13(R5,R7)        LOAD ADDRESS END OF OUTPUT REC\n         C     R2,ENDV             IF ENDOFREC IS LESS THAN ENDOFBL\n         BNH   EXMOVEV             MOVE DATA\n         SR    R7,R3               ELSE FIND BLK LENGTH\n         STH   R7,0(R3)            STORE IN OUTPUT BLOCK\n         BAS   R11,WRITOUT         WRITE BLOCK\n         LA    R7,4(R7)            POINT PAST OUTPUT BLK COUNT\nEXMOVEV  EX    R5,MOVEV            MOVE DATA TO OUTPUT BLOCK\n         AP    SEQCOUNT,=P'10'     PUT SEQUENCE NUMBER\n         UNPK  4(8,R7),SEQCOUNT    IN OUTPUT DATA SET\n         MVI   11(R7),C'0'         MAKE LAST DIGIT CHARACTER 0\n         LA    R5,13(R5)           ADD 13 TO LEN CNT GIVING LRECL\n         STH   R5,HALFWORD\n         MVC   0(4,R7),HALFWORD    STORE LRECL IN OUTPUT BLOCK\n         LA    R7,0(R5,R7)         INCREMENT OUTPUT POINTER\n         LA    R6,80(R6)           INCREMENT  INPUT POINTER\n         C     R6,ENDF             IF LESS THAN END OF BLOCK\n         BL    NEXTFREC            GET NEXT RECORD\n         B     READBLK             ELSE GET NEXT BLOCK\n         SPACE 1\nWRITEF   AP    SEQCOUNT,=P'10'     PLACE SEQUENCE NUMBER IN\n         UNPK  REC80+72(8),SEQCOUNT     POSITIONS 73-80\n         MVI   REC80+79,C'0'       MAKE LAST POS CHAR ZERO\n         MVC   0(80,R7),REC80      MOVE RECORD TO OUTPUT\n         LA    R7,80(R7)           INCREMENT POINTER\n         C     R7,ENDF             IF POINTER IS LESS THAN ENDOFBLK\n         BCR   4,R11               RETURN\n         SR    R7,R3               LOAD BLKSIZE\nWRITOUT WRITE  DECBA,SF,CLISTOUT,(R3),(R7)   WRITE OUT BLOCK\n        CHECK  DECBA\n         LR    R7,R3               SET POINTER TO START OF BLOCK\n         BR    R11\n         SPACE 1\nSTOWOUT  TM    SWITCH,T20          IF V TO F\n         BO    STOWVTOF            CHECK FOR SHORT BLOCK\n         SR    R7,R3               FIND BLOCK LENGTH\n         STH   R7,0(R3)            STORE IN BDW\n         MVC   2(2,R3),=H'0'       ZERO OUT REST OF BDW\n         B     SHORTBLK            WRITE OUT BLOCK\nSTOWVTOF CR    R3,R7               IF OUTPUT BLOCK IS EMPTY\n         BE    SHORTBLK+L'SHORTBLK SKIP WRITING SHORT BLOCK\n         SR    R7,R3               LOAD BLOCK LENGTH\nSHORTBLK BAS   R11,WRITOUT         WRITE SHORT BLOCK\n         TM    SWITCH,T40          IF DIRECTORY READ\n         BO    EOJ                 GO TO END OF JOB\n        STOW   CLISTOUT,DIRLIST,A\n         B     *+L'*(R15)\n         B     CHECKEND            0 - SUCCESFULLY COMPLETE\n         B     ERRA                4 - DUPLICATE NAME\n         NOP   0                   8 - ... NOT APPLICABLE\n         B     ERRB                12 - NO DIR SPACE\n         B     ERRC                16 - I/O ERROR\n         NOP   0                   20 - ... NOT OR INPUT OPENED\n         LA    R1,MSGD             24 - NO REGION SPACE\n         B     ERRMBN\nERRC     LA    R1,MSGC\n         B     ERRMBN\nERRB     LA    R1,MSGB\n         B     ERRMBN\nERRA     LA    R1,MSGA\nERRMBN   MVC   ERRMEM(8),=C'MEMBER :'\n         MVC   ERRMEM+9(L'NAME),NAME\nERR12    LH    R0,=H'12'\n         B     ERRMSG\nERR8     LH    R0,=H'8'\nERRMSG   STH   R0,RC\n         XR    R15,R15\n         IC    R15,0(R1)\n         EX    R15,MOVEMSG\n         B     WRITERR\n         SPACE 1\nCHECKEND AP    OUTCOUNT,=P'1'      COUNT MEMBERS MOVED\n         TM    SWITCH,T20          IF V TO F\n         BO    *+L'*+4             CHECK DIRECTORY\n         LA    R7,4(R7)            ELSE ADD 4 BYTES FOR OUTPUT BDW\nCHECKDIR LA    R2,2\n         CH    R2,DIRLEFT          IF DIRECTORY BLOCK IS NOT EMPTY\n         BL    GETMEM              GET NEXT MEMBER\n        POINT  CLISTIN,SAVETTR     ELSE READ NEW DIRECTORY\n         B     READDIR\n         SPACE 1\nWRITERR  BAS   R11,PRTRC\n         CLC   RC,=H'12'           IF COPY STARTED\n         BE    PRTCNT              PRINT TOTALS\n         B     EXIT\n         SPACE 1\nEOJ      MVC   ERRORMSG(13),=C'COPY COMPLETE'\n         BAS   R11,PRTRC\nPRTCNT   BAS   R11,COUNTP\n         SPACE 1\nEXIT    CLOSE  (CLISTIN,,CLISTOUT,,PRINT)\n         LH    R15,RC              LOAD RETURN CODE\n        $XRET  CC=(R15)\nPRTRC    LH    R1,RC\n         CVD   R1,WORK\n         UNPK  RCP,WORK\n         OI    RCP+1,C'0'\n         MVC   PRTLINE,ERRLINE\n         B     PUTPRNT\nCOUNTP   ED    OUTP,OUTCOUNT       MOVE NO OF MEMBERS MOVED\n         MVC   PRTLINE,COUNTLN\nPUTPRNT  TM    PRINT+(DCBOFLGS-IHADCB),DCBOFOPN\n         BO    PRTOPN\n        OPEN   (PRINT,(OUTPUT))\n        PUT    PRINT,TITLE\nPRTOPN  PUT    PRINT,PRTLINE\n         BR    R11\n         SPACE 1\nMOVEV    MVC   12(1,R7),0(R6)      <<EXECUTED>>\nMOVE80   MVC   REC80(1),0(R6)      <<EXECUTED>>\nMOVEMSG  MVC   ERRORMSG(*-*),1(R1)\n         EJECT\n*        DCB'S DEFINITIONS\n*        -----------------\n         SPACE 1\n        PRINT  NOGEN\nCLISTIN  DCB   DSORG=PO,MACRF=R,DDNAME=SYSUT1,EODAD=STOWOUT\nCLISTOUT DCB   DSORG=PO,MACRF=W,DDNAME=SYSUT2\nPRINT    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,            X\n               LRECL=121,BLKSIZE=605\n        PRINT  GEN\n         SPACE 1\n*        WORK FIELDS\n*        -----------\n         SPACE 1\nWORK     DC    D'0'\nHALFWORD DC    H'0',H'0'\nSAVETTR  DC    F'0'\nREADADD  DC    F'0'\nENDV     DC    F'0'\nENDF     DC    F'0'\nSAVERTN  DC    F'0'\nNEXTMEM  DC    F'0'\nOUTBLKSI DC    H'0'\nDIRLEFT  DC    H'0'\nBLKIN    DC    H'0'\nRECIN    DC    H'0'\nRC       DC    H'0'\nLRECL    DC    H'0'\nSEQCOUNT DC    PL4'0'\nOUTCOUNT DC    PL3'0'\nDIRSW    DC    XL1'0'\nALLON    EQU   X'FF'\nALLOFF   EQU   X'00'\nSWITCH   DC    XL1'0'\nT80      EQU   X'80'\nT40      EQU   X'40'\nT20      EQU   X'20'\n         SPACE 1\n         DC    CL1' '\nREC80    DC    CL80' '\n         SPACE 1\nBLDLLIST DC    0F'0',AL2(1,L'BLDLNM+50) BLDL LIST\nBLDLNM   DC    CL8' ',XL50'0'\n         SPACE 1\nDIRIN    DC    0F'0',XL256'0'      DIRECTORY BLOCK\n         SPACE 1\n         DS    0F\nDIRLIST  DS    0XL74               DIRECTORY RECORD\nNAME     DC    CL8' '\nTTR      DC    XL3'0'\nC        DC    XL1'0'\nUSERDATA DC    XL62'0'\n         EJECT\n*        PRINT DATA\n*        ----------\n         SPACE 1\nTITLE    DC    CL121'1   CLIST CONVERSION DIAGNOSE'\n         SPACE 1\nDUPLINE  DS    0CL121\nDUPCC    DC    CL8'0'\nDUPNAME  DC    CL8' ',CL39' = DUPLICATE NAME (SYSUT2) - NOT COPIED'\n         DC    CL66' '\n         SPACE 1\nERRLINE  DS    0CL121\n         DC    CL8'0',CL3'RC='\nRCP      DC    CL2' ',CL3' - '\nERRORMSG DC    CL60' ',CL2' '\nERRMEM   DC    CL40' ',CL3' '\n         SPACE 1\nCOUNTLN  DS    0CL121\n         DC    CL7'0'\nOUTP     DC    XL6'402020202120'\n         DC    CL108' MEMBERS COPIED'\n         SPACE 1\nPRTLINE  DC    CL121' '\n         EJECT\nMSG0     DC    AL1(L'MSG0T-1)\nMSG0T    DC    C'SYSUT  - FILE OPEN ERROR'\nMSG1     DC    AL1(L'MSG1T-1)\nMSG1T    DC    C'SYSUT  - FILE NOT V OR F'\nMSG2     DC    AL1(L'MSG2T-1)\nMSG2T    DC    C'SYSUT  - F FORMAT MUST BE LRECL=80'\nMSG3     DC    AL1(L'MSG3T-1)\nMSG3T    DC    C'SYSUT1 AND SYSUT2 CANNOT BE SAME RECFM'\nMSG4     DC    AL1(L'MSG4T-1)\nMSG4T    DC    C'V RECORD WITH LRECL OVER 255'\nMSGA     DC    AL1(L'MSGAT-1)\nMSGAT    DC    C'SYSUT2 - DUPLICATE NAME ON DIRECTORY'\nMSGB     DC    AL1(L'MSGBT-1)\nMSGBT    DC    C'SYSUT2 - DIRECTORY OUT OF SPACE'\nMSGC     DC    AL1(L'MSGCT-1)\nMSGCT    DC    C'SYSUT2 - I/O ERROR ON DIRECTORY'\nMSGD     DC    AL1(L'MSGDT-1)\nMSGDT    DC    C'SYSUT2 - STOW : REGION TOO SMALL'\nMSGJ     DC    AL1(L'MSGJT-1)\nMSGJT    DC    C'SYSUT2 - BLDL : I/O ERROR'\nMSGK     DC    AL1(L'MSGKT-1)\nMSGKT    DC    C'SYSUT2 - BLDL : REGION TOO SMALL'\nMSGL     DC    AL1(L'MSGLT-1)\nMSGLT    DC    C'SYSUT2 - BLDL : INVALID DEB'\n         SPACE 1\n         LTORG\n         SPACE 1\n        PRINT  NOGEN\n        DCBD   DSORG=PO,DEVD=DA\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMPRES@": {"ttr": 11011, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89 /\\x00\\x89 /\\x11D\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-07-21T00:00:00", "modifydate": "1989-07-21T11:44:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": "1   27/06/89\n                                                      COMPRESS  1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *   COMPRESS ISPF/PDF EDIT command    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro allows a user to compress in place the\n  ----------   current partitioned data-set.\n\n  Command syntax : COMPRESS\n  ---------------- COMPRESS HELP or H\n\n  Note :       If the condition code is other than 0 type in HELP for\n  ------       additional information.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COMPRESS": {"ttr": 11013, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x179\\x00=\\x00=\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T17:39:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM)\n/*  MACRO NAME : COMPRESS                                           */\n/*    FUNCTION : COMPRESS IN PLACE CURRENT PDS DATA-SET             */\n/*      SYNTAX : COMPRESS                                           */\n/*               COMPRESS HELP OR H                                 */\n/*       DEBUG : COMPRESS LIST                                      */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(HELP) OR +\n      &STR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTCOMP)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    ELSE IF &STR(&APARM.) \u00ac= &STR(LIST) THEN DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ISREDIT (WORKDSN) = DATASET\n  LISTDSI '&WORKDSN'\n  SET &DSORG = &SYSDSORG\n  IF &DSORG NE PO THEN DO\n    SET ZEDSMSG = &STR(INVALID DSORG)\n    SET ZEDLMSG = &STR('&WORKDSN' DSORG IS &DSORG, ONLY PO IS ALLOWED)\n    END\n  ELSE DO\n    SET  PDSDSN = &WORKDSN\n    IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n    ISPEXEC LMINIT DATAID(PDSID) DATASET('&PDSDSN') +\n                   ENQ(EXCLU) ORG(PDSORG)\n    SET &INITCC = &LASTCC\n    IF &INITCC \u00ac= 0 THEN DO\n      SET ZEDSMSG = &STR(LMINIT RC=&INITCC)\n      SET ZEDLMSG = &STR('&PDSDSN' ALLOCATION FAILED OR DSORG NOT PO)\n      END\n    ELSE DO\n      ISPEXEC LMCOMP DATAID(&PDSID)\n      SET &COMPCC = &LASTCC\n      SET ZEDSMSG = &STR(LMCOMP RC=&COMPCC)\n      IF &COMPCC = 0 THEN +\n        SET ZEDLMSG = &STR('&PDSDSN' SUCCESSFULLY COMPRESSED)\n      ELSE IF &COMPCC = 10 THEN +\n        SET ZEDLMSG = &STR('&PDSDSN' NOT ASSOCIATED WITH THE DATA-ID)\n      ELSE IF &COMPCC = 12 THEN +\n        SET ZEDLMSG = &STR('&PDSDSN' IS NOT A PARTITIONED DATA-SET)\n      ELSE IF &COMPCC = 20 THEN +\n        SET ZEDLMSG = &STR(UNABLE TO COMPRESS '&PDSDSN')\n      ELSE SET ZEDLMSG = &STR(UNKNOWN RC FROM COMPRESS '&PDSDSN')\n      END\n    END\n  ISPEXEC SETMSG MSG(ISRZ001)\n  IF &DSORG NE PO THEN EXIT\n  IF &INITCC \u00ac= 0 THEN EXIT\n  ISPEXEC LMCLOSE DATAID(&PDSID)\n  ISPEXEC LMFREE DATAID(&PDSID)\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONCAT": {"ttr": 11015, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\x11\\x14\\x00\\xbe\\x00\\xbe\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T11:14:00", "lines": 190, "newlines": 190, "modlines": 0, "user": "SYSPAJA"}, "text": "CCAT     TITLE 'NASA/GSFC -- CONCAT (TSO) COMMAND PROCESSOR.'\nCONCAT   START 0\n         SPACE 1\n* PURPOSE :    THIS IS A TSO COMMAND PROCESSOR WHICH CONCATENATES\n* ---------    SPECIFIED FILES.\n*              'IKJDAIR' IS INVOKED TO PERFORM THE ACTUAL\n*              CONCATENATION.\n* ORIGIN :     EXTRACTED FROM TAPE CBT 89 FEB, FILE 300.\n* --------     GSFTSOCC, VERSION 1.0, GENE CZARCINSKI, 09JUN73\n*              CONCAT, VERSION 1.1, GENE CZARCINSKI, 10APR77 ...\n*              - RENAME CSECT FROM 'GSFTSOCC' TO 'CONCAT'\n*                (MORE CONSISTANT AND CLEANER CMDLIB)\n*              - ADAPTED BY MOINIL P.A.\n* ATTRIBUTES : RENT\n* ------------\n         SPACE 1\nCONCAT  AMODE  24\nCONCAT  RMODE  24\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=@SIZE,SP=1,TYPE=RENT\n         LR    R11,R13\n         USING @STORAGE,R11        STORAGE BASE REGISTER\n         LR    R9,R1\n        $TEW$EC REG=R9,MSG=PUTMSG,ERR=QUIT\n         USING CPPL,R9             SET CPPL ADDRESSABILITY\n         XC    RCODE,RCODE         RC=0 -------------------------------\n         XC    ECB,ECB\n         LA    R1,PL1\n         USING IOPL,R1             INIT FOR TERM I/O\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         LA    R0,ECB\n         ST    R0,IOPLECB\n         DROP  R1\n*------- PARSE THE COMMAND OPERANDS\n         LA    R1,PL2\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         LA    R0,ECB\n         ST    R0,PPLECB\n         MVC   PPLPCL,=A($PARSECC)\n         LA    R0,APDL\n         ST    R0,PPLANS\n         MVC   PPLCBUF,CPPLCBUF\n         XC    PPLUWA,PPLUWA\n         DROP  R1\n        CALLTSSR EP=IKJPARS,MF=(E,PL2)\n         LTR   R15,R15             CHECK THE RC\n         BZ    PARSE1              OK\n*------- PARSE ERROR\n         LA    R2,MSG0\n         B     PUTLNE\n*------- PARSE SUCCESSFUL\nPARSE1   L     R2,APDL\n         USING @PDL,R2\n         LA    R3,PL4\n         USING DAPB0C,R3\n         XC    DAPB0C(DDNAMES-DAPB0C),DAPB0C\n         MVI   DA0CCD+1,X'0C'      CONCATENATE CODE\n         LA    R4,DDNAMES\n         XR    R15,R15             COUNT\n         LA    R14,#NAMES\nPARSE2   L     R5,0(R14)\n         LTR   R5,R5\n         BZ    PARSE6              NULL\n         LH    R1,4(R14)\n         LTR   R1,R1\n         BZ    PARSE6              NULL\n         MVI   0(R4),C' '          CLEAR DDN SPACE\n         MVC   1(7,R4),0(R4)\n         BCT   R1,*+L'*+6          FOR EX\n         MVC   0(*-*,R4),0(R5)     <<EXECUTED>>\n         EX    R1,*-6\n         LA    R6,DDNAMES          CHECK FOR DUP DDNAMES\n         LTR   R7,R15\n         BNP   PARSE5\nPARSE3   CLC   0(8,R4),0(R6)\n         BNE   PARSE4\n         LA    R2,MSG3\n         B     PUTLNE\nPARSE4   LA    R6,8(R6)\n         BCT   R7,PARSE3\nPARSE5   LA    R4,8(R4)            BUMP DDN PNTR\n         LA    R15,1(R15)          BUMP DDN COUNT\n         CH    R15,=H'16'          ONLY SPACE FOR 16\n         BH    PARSE7              OUT OF SPACE\nPARSE6   CLI   8(R14),X'FF'        END OF LIST?\n         BE    PARSE7              YES\n         L     R14,8(R14)          NEXT ENTRY\n         B     PARSE2\nPARSE7   CH    R15,=H'2'           2 OR MORE MUST BE SPEC\n         BNL   PARSE8              OK\n         LA    R2,MSG2\n         B     PUTLNE\nPARSE8   STH   R15,DA0CNUMB\n*------- CONCATENATE FILES\n         LA    R1,PL3\n         USING DAPL,R1\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         MVC   DAPLPSCB,CPPLPSCB\n         LA    R0,ECB\n         ST    R0,DAPLECB\n         LA    R0,PL4\n         ST    R0,DAPLDAPB\n         DROP  R1\n        CALLTSSR EP=IKJDAIR,MF=(E,PL3)\n         LTR   R15,R15\n         BZ    DONE1               CONCATENATION SUCCESSFUL\n         CVD   R15,WORK            REPORT ERROR\n         OI    WORK+7,X'0F'\n         MVC   MSGA(MSG1L),MSG1\n         UNPK  MSGA+(MSG1A-MSG1)(L'MSG1A),WORK\n         UNPK  WORK(5),DA0CDARC(3)\n         MVZ   WORK(4),=XL4'0'\n         TR    WORK(4),=C'0123456789ABCDEF'\n         MVC   MSGA+(MSG1B-MSG1)(L'MSG1B),WORK\n         LA    R2,MSGA\n*------- OUTPUT ERROR MSG\nPUTLNE  PUTLINE PARM=PTPB,OUTPUT=(0(R2),TERM,SINGLE,DATA),             X\n               TERMPUT=(EDIT,WAIT,HOLD),MF=(E,PL1)\n         MVI   RCODE+1,12          RC=12 ------------------------------\nDONE1    CLI   PL2+(PPLANS-PPL),X'FF'\n         BE    DONE2               NO CORE TO FREE\n         L     R1,PL2+(PPLANS-PPL)\n        IKJRLSA (1)\nDONE2    CLI   RCODE+1,12\n         BNE   DONE3\n        STACK  PARM=STPB,DELETE=ALL,MF=(E,PL1)\n        TCLEARQ INPUT\nDONE3    LH    R2,RCODE\n         B     LEAVE\nQUIT     LA    R2,12               RC=12 ------------------------------\nLEAVE   $XRET  CC=(R2),LV=@SIZE,SP=1,TYPE=RENT\n         EJECT\n*------- CONSTANTS\n         SPACE 1\nMSG0     DC    0F'0',Y(MSG0L,0),C'  ERROR PARSING COMMAND'\n         DC    C' OPERAND, EXECUTION SUPPRESSED.'\nMSG0L    EQU   *-MSG0\nMSG1     DC    0F'0',Y(MSG1L,0),C'  CONCATENATION ERROR, DAIR RC='\nMSG1A    DC    CL2' ',C', DARC='\nMSG1B    DC    CL4' ',C'.'\nMSG1L    EQU   *-MSG1\nMSG2     DC    0F'0',Y(MSG2L,0),C'  TWO OR MORE FILENAMES MUST'\n         DC    C' BE SPECIFIED, EXECUTION SUPPRESSED.'\nMSG2L    EQU   *-MSG2\nMSG3     DC    0F'0',Y(MSG3L,0),C'  DUPLICATE FILENAMES'\n         DC    C' SPECIFIED, EXECUTION SUPPRESSED.'\nMSG3L    EQU   *-MSG3\n         SPACE 1\n        LTORG\n         SPACE 1\n        PRINT  NOGEN\n$PARSECC IKJPARM  DSECT=@PDL\n#NAMES   IKJIDENT 'FILENAMES',LIST,MAXLNTH=8,FIRST=ALPHA,              X\n               OTHER=ALPHANUM,PROMPT='CONCAT (FILENAME/DDNAME LIST)'\n         IKJENDP\n        PRINT  GEN\n         EJECT\n@STORAGE DSECT\n         DS    18F                 S.A.\nWORK     DS    D\n        $TEW$WA\nECB      DS    F\nAPDL     DS    A\nPTPB    PUTLINE MF=L\nSTPB    STACK  MF=L\nPL1      DS    4F                  IOPL\nPL2      DS    7F                  PPL\nPL3      DS    5F                  DAPL\nPL4      DS    36F                 DAPB0C\nMSGA     DS    0F,H,H,CL100\nRCODE    DS    H\n         SPACE 1\n@SIZE    EQU   (((*-@STORAGE)+7)/8)*8\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS CVT=YES\n        IKJIOPL\n        IKJPPL\n        IKJDAPL\n        IKJDAP0C\nDDNAMES  EQU   *\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONCAT$": {"ttr": 11019, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14\\x01\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:01:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//CONCAT   JOB (........),'INSTALL  - CONCAT -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=3\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=CONCAT\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   CONCAT\n  NAME    CONCAT(R)\n/*\n//HLP     EXEC PAJHELP,MBR=CONCATH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONCAT@": {"ttr": 11021, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x12$\\x00)\\x00)\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T12:24:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/07/90\n                                                      CONCAT    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         CONCAT TSO command          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Command name :      CONCAT\n  Author :            GSFTSOCC, Version 1.0, Gene Czarcinski, 09 JUN 73\n                      CONCAT, Version 1.1, Gene Czarcinski, 10 APR 77\n                      Rename CSECT from GSFTSOCC to CONCAT (more\n                      consistant and cleaner CMDLIB).\n  Origin :            Extracted from tape CBT 89 FEB, file 300\n                      Adapted by MOINIL P.A.\n  Function :          The CONCAT command dynamically concatenates a\n                      list of previously defined data-sets.\n                      The DECONCAT or FREE commands can be used to\n                      deconcatenate files.\n\n  Syntax :\n  --------------------------------------------------------------------\n  Command    Operands\n  --------------------------------------------------------------------\n  CONCAT     'filelist'\n  --------------------------------------------------------------------\n\n  Operands :\n     Required - 'filelist'\n     Default  - None\n\n     'filelist' = The list of file names (DDNAMEs) to be concatenated.\n                           The list must have two or more entries.\n                           The first name specified will be the PRIME\n                           name to which other files are concatenated.\n              Example :\n                 CONCAT (DD1 DD2 DD3 DD4 DD5)\n\n  Return codes :  0 - concatenation successfully done.\n                 12 - severe error encountered.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONCATH": {"ttr": 11023, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x11Y\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T11:59:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=CONCAT\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  the CONCAT command dynamically concatenates a list of\n               previously defined data-sets. The DECONCAT or FREE\n               commands can be used to deconcatenate files.\n)X SYNTAX :    CONCAT 'FILELIST'\n               Example : CONCAT (DD1 DD2 DD3 DD4 DD5)\n)O OPERANDS :  Required - 'FILELIST'\n               Default  - None\n))FILELIST :   The list of file names (DDNAMEs) to be concatenated.\n               The list must have two or more entries. The first name\n               specified will be the PRIME name to which other files\n               are concatenated.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONT": {"ttr": 11025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x179\\x00O\\x00O\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T17:39:00", "lines": 79, "newlines": 79, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM) NOPROCESS\n/*  MACRO NAME : CONT                                               */\n/*    FUNCTION : PLACE A CONTINUATION CHARACTER IN COLUMN 72        */\n/*      SYNTAX : CONT                                               */\n/*               CONT HELP OR H                                     */\n/*       DEBUG : CONT LIST                                          */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(HELP) OR +\n      &STR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTCONT)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ISPEXEC CONTROL ERRORS RETURN\n  CONTROL ASIS\n/*               PROCESS LINE COMMANDS, CHECK IF C WAS SPECIFIED    */\n  ISREDIT PROCESS RANGE C\n  SET LCC = &LASTCC\n  ISREDIT (RC) = RANGE_CMD\n  SET RCC = &LASTCC\n  IF &LCC \u00ac=0 OR &RCC \u00ac=0 THEN DO\n    IF &RCC = 4 THEN DO\n      IF &STR(&RC) \u00ac= &STR(C) THEN DO\n        IF &LCC = 4 THEN SET &ZEDSMSG = &STR(NO RANGE)\n        ELSE SET &ZEDSMSG = &STR(INVALID RANGE)\n        SET &ZEDLMSG = &STR(YOU MUST SPECIFY A TARGET RANGE OF +\n                            LINES, USING \"CN\" OR \"CC\")\n        END\n      ELSE DO\n        SET &ZEDSMSG = &STR(RANGE INCOMPLETE)\n        SET &ZEDLMSG = &STR(ENTER A MATCHING \"CC\" TO COMPLETE +\n                            THE BLOCK COMMAND PAIR)\n        END\n      END\n    ELSE IF &RCC = 8 THEN DO\n      SET &ZEDSMSG = &STR(NOT ACCEPTABLE)\n      SET &ZEDLMSG = &STR(AN UNACCEPTABLE TARGET RANGE OF LINES +\n                          HAS BEEN SPECIFIED)\n      END\n    ELSE DO\n      SET &ZEDSMSG = &STR(SEVERE ERROR)\n      SET &ZEDLMSG = &STR(SEVERE ERROR OCCURED, RETURN CODES ARE +\n                          &LCC AND &RCC)\n      END\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n    END\n  ISREDIT (FR) = LINENUM .ZFRANGE\n  ISREDIT (LR) = LINENUM .ZLRANGE\n  ISREDIT (LB,RB) = BOUNDS\n  SET I = &FR\n  DO WHILE (&I <= &LR)\n    ISREDIT\n    ISREDIT LABEL &I = .LJ\n    ISREDIT SEEK P'\u00ac' .LJ .LJ &LB &RB FIRST\n    ISREDIT SEEK P'\u00ac' .LJ .LJ &LB &RB LAST\n    ISREDIT CHANGE ' ' 'X' 72\n    SET COUNT = &EVAL(&LEFT - &RIGHT + 1) / 2\n    IF &COUNT > 0 THEN ISREDIT SHIFT ) &I &COUNT\n    ELSE IF &COUNT < 0 THEN DO\n      SET COUNT = -1*&COUNT\n      ISREDIT SHIFT ( &I &COUNT\n      END\n    IF &I = &FR THEN ISREDIT LABEL &I = .LJX\n    SET I = &I + 1\n    END\n  ISREDIT SEEK P'=' .LJX .LJX FIRST\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONT@": {"ttr": 11028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11W\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:57:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "1   19/07/89\n                                                      CONT      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     CONT ISPF/PDF EDIT command      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to place a continuation\n  ----------   character in column 72 of data line(s).\n\n  Command syntax : CONT\n  ---------------- CONT HELP or H\n\n  Use :        Type CONT on the COMMAND line and mark the range of\n  -----        continuation with the \"C\" range command on the line\n               numbers, as i.e. :\n               COMMAND ===> CONT\n          ---> CC 500           MYMAC PARM1,\n               000600             PARM2,\n          ---> CC 700             PARM3,\n               000800             LASTPARM\n               Result : a \"X\" is placed in column 72 of lines numbered\n                      500, 600 and 700. Identical process is obtained\n                      with :\n          ---> C3 500           MYMAC PARM1,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONTROL": {"ttr": 11030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93%o\\x00\\x93%o\\x15\\x17\\x009\\x009\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-13T00:00:00", "modifydate": "1993-09-13T15:17:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM,BPARM) NOPROCESS\n/*  MACRO NAME : CONTROL                                            */\n/*    FUNCTION : ADD CONTROL STATEMENT IN CLIST                     */\n/*      SYNTAX : CONTROL OR CONTROL ON                              */\n/*               CONTROL OFF                                        */\n/*               CONTROL H(ELP)                                     */\n/*       DEBUG : CONTROL L(IST)                                     */\n/*               CONTROL ON/OFF L(IST)                              */\n/*      ORIGIN : CBT TAPE 93 FEB, FILE 95                           */\n  IF ((&STR(&BPARM.) = &STR(LIST)) OR +\n    (&STR(&BPARM.) = &STR(L))) THEN DO\n    CONTROL LIST CONLIST SYMLIST\n    SET &BPARM = &Z\n    END\n  IF ((&STR(&APARM.) = &STR(LIST)) OR +\n    (&STR(&APARM.) = &STR(L))) THEN DO\n    CONTROL LIST CONLIST SYMLIST\n    SET &APARM = &Z\n    END\n  IF &STR(&APARM.) = &STR(HELP) OR +\n    &STR(&APARM.) = &STR(H) THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTCTRL)\n      SET &CNCC = &LASTCC\n      ISPEXEC CONTROL DISPLAY RESTORE\n      EXIT CODE(&CNCC)\n      END\n  IF &STR(&APARM.) = &Z THEN SET &APARM = &STR(ON)\n  IF ((&STR(&APARM.) \u00ac= &STR(ON)) AND +\n    (&STR(&APARM.) \u00ac= &STR(OFF))) THEN DO\n    SET ZEDSMSG = &STR(INVALID OPERAND)\n    SET ZEDLMSG = ENTER \"CONTROL HELP\" COMMAND FOR OPERAND SYNTAX\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  IF &STR(&APARM.) = ON THEN +\n    SET &CNTL = &STR(     CONTROL MSG LIST SYMLIST CONLIST)\n  ELSE SET &CNTL = &STR(     CONTROL NOMSG NOLIST NOSYMLIST NOCONLIST)\n  ISREDIT PROCESS DEST\n  SET &CNCC = &LASTCC\n  IF ((&CNCC = 0) OR (&CNCC = 8)) THEN DO\n    ISREDIT LOCATE .ZDEST\n    SET &CNCC = &LASTCC\n    IF &CNCC <= 8 THEN DO\n      IF &CNCC = 0 THEN DO\n        ISREDIT MASKLINE = \"&CNTL\"\n        ISREDIT LINE_AFTER .ZDEST = MASKLINE\n        END\n      ELSE DO\n        ISREDIT MASKLINE = \"&CNTL\"\n        ISREDIT LINE_AFTER 0 = MASKLINE\n        END\n      ISREDIT MASKLINE = \" \"\n      SET &CNCC = 0\n      END\n    END\n  EXIT CODE(&CNCC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONTROL@": {"ttr": 11266, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\x109\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T10:39:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "1   13/09/93\n                                                      CONTROL   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    CONTROL ISPF/PDF EDIT command    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to insert CONTROL statements\n  ----------   in CLISTs. An optional parameter OFF will insert a CLIST\n               statement to turn OFF previously set control.\n               The control CLIST can be used for debugging select lines\n               of a problem CLIST.\n\n  Command syntax : CONTROL or CONTROL ON, and CONTROL OFF\n  ---------------- CONTROL HELP or H\n\n  Use :        Type CONTROL on the COMMAND line and use the \"A\" or \"B\"\n  -----        range command to indicate where the CONTROL statement\n               is to be inserted.\n               Example :\n               COMMAND ===> CONTROL\n          ---> A 0500      SET TYPE = COMMAND\n               000600      SET I = 1\n               Result :\n               000500      SET TYPE = COMMAND\n          ---> 000510      CONTROL MSG LIST CONLIST SYMLIST\n               000600      SET I = 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CP": {"ttr": 11268, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12O\\x00\\x94\\x12O\\x110\\x01\\x02\\x01\\x02\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-04T00:00:00", "modifydate": "1994-05-04T11:30:00", "lines": 258, "newlines": 258, "modlines": 0, "user": "SYSPAJA"}, "text": "CP       TITLE 'TSO CP COMMAND - ENTER VM COMMANDS.'\nCP       START 0\n         SPACE 1\n* PURPOSE :    SOLVE A PARTICULAR PROBLEM IN RUNNING TSO UNDER MVS\n* ---------    UNDER VM. NAMELY, WHEN A TERMINAL IS DIALED TO A\n*              VIRTUAL MACHINE, IT CAN ONLY BE RELEASED BY ISSUING\n*              A 'DETACH' OR 'RESET' COMMAND FROM THE VM CONSOLE.\n*              IF ONE CONSOLE IS BEING USED FOR BOTH ROLES, THIS\n*              POSES A PROBLEM. THE INSTALLATION OF THIS TSO COMMAND\n*              ALLOWS CP COMMANDS SUCH AS 'DETACH' AND 'RESET' TO\n*              BE ISSUED FROM A TSO CONSOLE. THE CONSOLE CAN THEN\n*              RELEASE ITSELF FROM TSO AND BE DIALED IN AS THE VM\n*              MASTER CONSOLE.\n*\n* AUTHOR:      REFER TO AMDAHL MVS INSTALLATION (EDUCATION COURSE)\n* -------                 AND AMDAHL MVS-VM/PE (TCAM MCP).\n*              SUNNYVALE (USA)\n*              ADAPTED BY P.A. MOINIL, COMPUTING CENTRE,\n*              J.R.C. - ISPRA ESTABLISHMENT, 21020 ISPRA (VA), ITALY\n         SPACE 1\n        $DEFREG\n         EJECT\n*------- MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nDISPLAY  EQU   X'01'               DISPLAY REGISTERS.\nNATIVE   EQU   X'10'               NATIVE OPERATING SYSTEM.\nACTIVE   EQU   X'20'               VM/PE ACTIVE.\nDOWN     EQU   X'40'               VM/PE DOWN.\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nLV0      EQU   0         REJECT LEVEL.\n         SPACE 1\n        $MDL@IX\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R11,R13               SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R11\n        $TEW$EC NOTTSO=(,ONLY),MSG=PUTMSG,ERR=SETRC\n         XC    REQAUT(REQAUTL),REQAUT\n         MVC   REQAUT+1(3),=AL3(MDL@IX)\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n        $EACM  REQAUT\n         CLI   AUTH,LV0              AUTHORIZED?\n         BNE   STACC                 YES.\n        TPUT   ERM,L'ERM\n         B     SETRC\nSETDSP   OI    SWITCH,DISPLAY\n         B     ACCEPT\nRSTDSP   NI    SWITCH,255-DISPLAY\n         B     ACCEPT\nSTACC    MVI   SWITCH,0\nACCEPT  TPUT   SMG,L'SMG             SEND ENTER MSG.\n         MVC   BUF(L'BLK),BLK        CLEAR BUFFER.\n         L     R2,LGRES              CLEAR RESPONSE.\n         BCTR  R2,0\n         SRDL  R2,8\n         SRL   R3,24\n         LA    R4,RES\n         EX    R3,CLEAR\n         LTR   R2,R2\n         BZ    READ\nLOOP     LA    R4,1(R3,R4)\n         LA    R3,255\n         EX    R3,CLEAR\n         BCT   R2,LOOP\n         B     READ\nCLEAR    XC    0(*-*,R4),0(R4)\nREAD    TGET   BUF,L'BUF             READ VM COMMAND FROM TERMINAL.\n         OC    BUF(L'BLK),BLK        UPPERCASE TEXT.\n         CLC   BUF(L'END),END\n         BE    EXIT                  EXIT TAKEN ON END FROM KEYBOARD.\n         CLC   BUF(L'DSP),DSP\n         BE    SETDSP                DISPLAY REGISTERS REQUEST.\n         CLC   BUF(L'RST),RST\n         BE    RSTDSP                RESET DISPLAY.\n         LA    R4,L'BUF              MAX LENGTH OF COMMAND.\n         O     R4,FLAGS\n         L     R5,LGRES              MAX LENGTH OF RESPONSE.\n         XC    WORK,WORK\n         SR    R10,R10               RESPONSE INDICATOR.\n        ZEROKEY\n         STIDP WORK                  STORE CPU ID.\n         CLI   WORK,X'FF'            ARE WE UNDER NORMAL VM/370?\n         BE    GDGN                  YES, GO DO DIAGNOSE.\n         TM    X'A0',X'40'           ARE WE HYPERVISOR (VM/PE)?\n         BZ    NDGN                  NO.\n         TM    X'A0',X'01'           IS VM/PE DOWN?\n         BZ    VMPE                  NO, GO ISSUE VM/PE SVC.\n         OI    SWITCH,DOWN           SET VM/PE DOWN.\n         B     NTVM\nNDGN     OI    SWITCH,NATIVE         SET NATIVE OPERATING SYSTEM.\n         B     NTVM\nVMPE     OI    SWITCH,ACTIVE         WE ARE UNDER VM/PE.\nGDGN     LRA   R2,BUF                ADDRESS OF VM COMMAND.\n         LRA   R3,RES                ADDRESS OF VM RESPONSE.\n         TM    SWITCH,ACTIVE         ARE WE UNDER VM/PE(HYPERVISOR)?\n         BZ    SDGN                  NO, NORMAL VM/370, SKIP SVC.\n        CNOP   0,8                   ASSURE DIAG & SVC IN ONE PAGE.\n         SVC   209                   ISSUE VM/PE SVC.\nSDGN     DC    X'83',X'24',XL2'0008' DIAGNOSE : ISSUE COMMAND TO VM.\n         BZ    *+L'*+4\n         LA    R10,255               SET CONDITION CODE INDICATOR.\nNTVM     TM    SWITCH,DISPLAY\n         BZ    *+L'*+4\n         STM   R0,R15,SVREGS\n        RESETKEY\n         TM    SWITCH,DISPLAY\n         BZ    ANAL\n         MVC   BUF(L'CPUMSG),CPUMSG  DISPLAY CPU ID.\n         LA    R1,L'WORK\n         LA    R2,WORK\n         LA    R3,BUF+L'CPUMSG-(2*L'WORK)-2\n         BAL   R14,EDIT\n        TPUT   BUF,L'CPUMSG\n         TM    SWITCH,NATIVE+DOWN\n         BNZ   ANAL\n        TPUT   DMSG,L'DMSG           DISPLAY REGISTERS.\n         MVC   BUF(L'BLK),BLK\n         LA    R8,4\n         LA    R2,SVREGS\n         LR    R7,R8\nSRG1     LA    R3,BUF+2\n         LR    R6,R8\nSRG2     LR    R1,R8\n         BAL   R14,EDIT\n         LA    R3,2(R3)\n         BCT   R6,SRG2\n        TPUT   BUF,L'BUF\n         BCT   R7,SRG1\n         LM    R0,R10,SVREGS\nANAL     TM    SWITCH,NATIVE\n         BO    SNMVS\n         TM    SWITCH,DOWN\n         BZ    LOOK\n        TPUT   DVMPE,L'DVMPE\n         B     SETRC\nSNMVS   TPUT   NMVS,L'NMVS\n         B     SETRC\nLOOK     LTR   R10,R10\n         BZ    TEST\n         LR    R10,R5                SAVE EXCESSION.\n         L     R5,LGRES\nTEST     LTR   R5,R5\n         BNP   LAST\n         CLI   RES,0                 NO RESPONSE?\n         BE    LAST                  YES.\n         LA    R2,RES\n         LR    R3,R2\nSCAN     CLI   0(R3),X'15'           LINE SEPARATOR?\n         BNE   NEXT                  NO.\n         LR    R4,R3\n         SR    R4,R2\n         LTR   R4,R4\n         BNP   SKIP\n        TPUT   (R2),(R4)             SEND RESPONSE BACK TO TERMINAL.\nSKIP     LA    R2,1(R3)\nNEXT     LA    R3,1(R3)\n         BCT   R5,SCAN\n         CLR   R2,R3\n         BE    LAST\n         SR    R3,R2\n        TPUT   (R2),(R3)\nLAST     LTR   R10,R10               ANY EXCESSION?\n         BZ    ACCEPT                NO, READ NEXT VM COMMAND.\n         CVD   R10,WORK\n         MVC   BUF(LMGL),LMG\n         MVC   BUF+L'LMG(L'MASK),MASK\n         ED    BUF+L'LMG(L'MASK),WORK+5\n        TPUT   LMG,LMGL\n         B     ACCEPT                READ NEXT VM COMMAND.\nSETRC    LA    R15,16\n         B     EXIT+L'EXIT\nEXIT     XR    R15,R15\n        $XRET  CC=(R15),LV=WRKL,TYPE=RENT\n         EJECT\n*------- HEXADECIMAL OUTPUT ROUTINE.\n*              R0  = WORK REGISTER.\n*              R1  = INPUT FIELD LENGTH.\n*              R2  = INPUT FIELD ADDRESS.\n*              R3  = OUTPUT FIELD ADDRESS.\n*              R4  = WORK REGISTER.\n*              R14 = LINK REGISTER.\n*              R15 = WORK REGISTER.\n*        NOTE. AT EXIT :\n*              R2  = POINTS TO THE NEXT BYTE OF THE INPUT FIELD.\n*              R3  = POINTS TO THE NEXT BYTE OF THE OUTPUT FIELD.\n         SPACE 1\nEDIT     LR    R15,R1\n         LR    R4,R3\n         SR    R0,R0\nED1      IC    R0,0(R2)\n         STC   R0,1(R3)\n         NI    1(R3),X'0F'\n         SRL   R0,4\n         STC   R0,0(R3)\n         LA    R2,1(R2)\n         LA    R3,2(R3)\n         BCT   R1,ED1\n         SLL   R15,1\n         BCTR  R15,0\n         EX    R15,ED2\n         BR    R14\nED2      TR    0(*-*,R4),TRTAB\n         EJECT\n*------- CONSTANTS.\n         SPACE 1\nLGRES    DC    A(LRES)\nNRES     DC    A(LRES/L'RES)\nFLAGS    DC    0F'0',XL4'40000000'\nSMG      DC    C'ENTER VM-COMMAND OR END :'\nLMG      DC    C'...ETC... (EXCESSION :'\n         DC    CL6' '\n         DC    C' BYTES)'\nLMGL     EQU   *-LMG\nCPUMSG   DC    C'CPU ID = X''                ''.'\nDMSG     DC    C'REGISTERS (0-15) :'\nERM      DC    C' -> UNAUTHORIZED COMMAND.'\nNMVS     DC    C' -> CP COMMAND NOT AVAILABLE (NATIVE MVS).'\nDVMPE    DC    C' -> CP COMMAND NOT AVAILABLE (VM/PE DOWN).'\nTRTAB    DC    C'0123456789ABCDEF'\nMASK     DC    XL6'402020202120'\nDSP      DC    C'FUNGULA'\nRST      DC    C'FUNGA'\nEND      DC    C'END'\nASYS     DC    C'SYS'\nBLK      DC    CL80' '\n         SPACE 1\n        LTORG\n         EJECT\n*------- WORK-AREAS.\n         SPACE 1\nWRKDSECT DSECT\n         SPACE 1\nSVA      DS    18F\nSVREGS   DS    16F\nWORK     DS    D\n         SPACE 1\n        $TEW$WA\n         SPACE 1\nBUF      DS    CL80\nRES      DS    20CL80\nLRES     EQU   *-RES\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)\nAUTH     DC    XL1'0'\nREQAUTL  EQU   *-REQAUT\nSWITCH   DS    XL1\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         SPACE 1\n        PRINT  NOGEN\n       $TEW$DS\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CP$": {"ttr": 11273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14!\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:21:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "//CP       JOB (........),'INSTALL  - C P -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,OPT=',RENT',MBR=CP\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  SETCODE AC(1)\n  NAME    CP(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CP@": {"ttr": 11275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x12\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:12:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      CP        1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          TSO : CP COMMANDS          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Solve a particular problem in running TSO under MVS\n  ---------    under VM. Namely, when a terminal is dialed to a\n               virtual machine, it can only be released by issuing\n               a DETACH or RESET command from the VM console.\n               If one console is being used for both roles, this\n               poses a problem. The installation of this TSO command\n               allows CP commands such as DETACH and RESET to be\n               issued from a TSO console. The console can then\n               release itself from TSO and be dialed in as the VM\n               master console.\n\n  Authority :  Only System Group USER-id's are authorized to issue\n  -----------  this command.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CRY": {"ttr": 11277, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x921\\x7f\\x00\\x921\\x7f\\x16\\x04\\x02\\x11\\x02\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-11-12T00:00:00", "modifydate": "1992-11-12T16:04:00", "lines": 529, "newlines": 529, "modlines": 0, "user": "SYSPAJA"}, "text": "CRY      TITLE 'ENCRYPT-DECRYPT ISPF/PDF EDIT COMMAND.'\nCRY      START 0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* AUTHOR :    D.L.SCHWARZ                                             *\n*                                                                     *\n* DATE :      OCT. 17, 1985 - VERSION 2, MOD. 0                       *\n*                                                                     *\n* FUNCTION :  THIS MODULE PERFORMS THE FUNCTION OF ENCRYPTION AND     *\n*             DECRYPTION OF DATA OPERATING AS A PRIMARY COMMAND       *\n*             UNDER ISPF/PDF EDIT. THE MODULE IS LINKED INTO THE      *\n*             COMMAND LIBRARY UNDER THE NAME 'CRY'.                   *\n*                                                                     *\n* OPERATION : THE ENCRYPTION IS PERFORMED BY UTILIZING A KEY VALUE    *\n*             SUPPLIED AS AN OPERAND OF THE PRIMARY COMMAND. THIS     *\n*             VALUE IS PASSED TO PROGRAM R050A90 AT ENTRY 'SETKEY',   *\n*             FOLLOWED BY RECURSIVE CALLS TO THE PROGRAM AT ENTRY     *\n*             POINTS 'ENCIPH' OR 'DECIPH', DEPENDING ON THE FUNCTION  *\n*             DESIRED.                                                *\n*                                                                     *\n* EXAMPLES OF USE :     !CRY ENCRYPT,KEYVALUE                         *\n*                       !CRY DECRYPT,KEYVALUE                         *\n*             THE 'KEYVALUE' IS A USER SUPPLIED KEYWORD WHICH IS      *\n*             MESSAGED AND USED AS THE ENCRYPT/DECRYPT CODE VALUE.    *\n*             THE KEYWORD IS LIMITED TO EIGHT (8) BYTES IN LENGTH,    *\n*             BUT MAY BE SHORTER, THIS PROGRAM WILL PAD IT TO THE     *\n*             CORRECT LENGTH.                                         *\n*                                                                     *\n* CHANGES/UPDATES :                                                   *\n*  10/17/85 - VERSION 2, MODIFICATION 0.                              *\n*             EXTRACTED FROM CBT TAPE 88/FEB, FILE 270.           -EU-*\n*  05/16/89 - ACCEPT SHORT FORMS COMMAND :           (MOINIL P.A.)-EU-*\n*                       !CRY EN,KEYVALUE                          -EU-*\n*                       !CRY E,KEYVALUE                           -EU-*\n*                       !CRY DE,KEYVALUE                          -EU-*\n*                       !CRY D,KEYVALUE                           -EU-*\n*  05/19/89 - DISPLAY ERROR MESSAGES.                (MOINIL P.A.)-EU-*\n*  05/23/89 - WHEN KEYVALUE IS OMITED, PROMPT THE    (MOINIL P.A.)-EU-*\n*             USER TO SUPPLY IT UNVIEWABLE.                       -EU-*\n*  21/06/89 - ACCEPT NEW COMMAND :                   (MOINIL P.A.)-EU-*\n*                       !CRY HELP                                 -EU-*\n*                       !CRY H                                    -EU-*\n*  05/09/89 - ACCEPT RANGE COMMAND INDICATED BY      (MOINIL P.A.)-EU-*\n*             \"CN\" OR \"CC\".                                       -EU-*\n*  12/11/92 - CHECK LRECL NOT GREATER THAN BUFFER    (MOINIL P.A.)-EU-*\n*             AND SET CRYPT LENGTH = MULTIPLE OF 8.               -EU-*\n*                                                                     *\n***********************************************************************\n         EJECT\n         PRINT NOGEN\n        $DEFREG\n        $XENT  BASE=(R11,R12)\n         SPACE 1\n*-------------------  I N I T I A L I Z A T I O N  --------------------\n*        THE FOLLOWING CALLS TO ISPLINK ARE TO OBTAIN THE VALUES\n*        NECESSARY FOR THE OPERATION OF THE PROGRAM.\n*----------------------------------------------------------------------\n         SPACE 1\n* ------ CALL TO OBTAIN THE FUNCTION (ENCRYPT/DECRYPT/HELP)\n*        DESIRED, AND THE KEY VALUE.\n         SPACE 1\n         CALL  ISPLINK,(VDEF,NL,FCDE,TYPEC,LEN8),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR1                NOT ZERO, ERROR\n         SPACE 1\n* ------ CALL TO DEFINE THE BUFFER AREA THAT WE WILL BE USING.\n         SPACE 1\n         CALL  ISPLINK,(VDEF,LL,BUFFER,TYPEC,LEN256),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR2                NOT ZERO, ERROR\n         SPACE 1\n* ------ CALL TO DEFINE THE VARIABLES USED TO OBTAIN THE LOGICAL\n*        RECORD LENGTH (LRECL) OF THE DATA WE ARE OPERATING ON,\n*        AND THE EVENTUAL RANGE OF DATA LINES TO BE PROCESSED.\n         SPACE 1\n         CALL  ISPLINK,(VDEF,DL,LRECL,TYPEF,LEN4),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR3                NOT ZERO, ERROR\n         CALL  ISPLINK,(VDEF,RL,LRC,TYPEC,LEN1),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR4                NOT ZERO, ERROR\n         SPACE 1\n* ------ CALL TO DEFINE THIS PROGRAM AS AN EDIT MACRO.\n         SPACE 1\n         CALL  ISPLINK,(EDIT,LEN0,EDMAC),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR5                NOT ZERO, ERROR\n         SPACE 1\n* ------ CALL TO CONTROL DATA LINES TO BE PROCESSED.\n         SPACE 1\n         CALL  ISPLINK,(EDIT,LEN0,EDPRC),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    CHKRG               0 = NORMAL COMPLETION\n         CL    R15,LEN4\n         BE    NORNG               4 = NO RANGE\n         B     ERR6                OTHER, ERROR\n         SPACE 1\n* ------ CALL TO CHECK RANGE OF DATA LINES TO BE PROCESSED.\n         SPACE 1\nCHKRG    CALL  ISPLINK,(EDIT,LEN0,EDQUE),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    GTRNG               0 = RANGE INDICATED\n         CL    R15,LEN4\n         BE    NORNG               4 = NO RANGE\n         CL    R15,LEN8\n         BE    RGERR               8 = RANGE ERROR\n         B     ERR7                OTHER, ERROR\nGTRNG    CLI   LRC,C'C'            RANGE CHARACTER = C?\n         BNE   RGINV               NO, ERROR\n         CALL  ISPLINK,(EDIT,LEN0,EDFRG),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR8                NOT ZERO, ERROR\n         CALL  ISPLINK,(EDIT,LEN0,EDLRG),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR9                NOT ZERO, ERROR\n         L     R1,LINENO           ADJUST FIRST LINE NUMBER TO LOOP\n         LTR   R1,R1\n         BP    *+L'*+6\n         XR    R1,R1\n         B     *+L'*+2\n         BCTR  R1,0\n         ST    R1,LINENO\n         B     GTLRL\n         SPACE 1\n* ------ CALL TO OBTAIN THE LINE NUMBER OF THE LAST RECORD IN\n*        THE CURRENT DATA-SET.\n         SPACE 1\nNORNG    XC    LINENO,LINENO       SET LINE NUMBER TO ZERO\n         CALL  ISPLINK,(EDIT,LEN0,EDLLR),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR10               NOT ZERO, ERROR\n         SPACE 1\n* ------ CALL TO DEFINE THE LOGICAL RECORD LENGTH (LRECL) TO EDIT.\n         SPACE 1\nGTLRL    CALL  ISPLINK,(EDIT,LEN0,EDLRL),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR11               NOT ZERO, ERROR\n         SPACE 1\n* ------ CHECK THE LOGICAL RECORD LENGTH (LRECL) TO EDIT\n*        (ENCRYPT/DECRYPT MAXIMUM = BUFFER LENGTH), AND\n*        SET THE LOGICAL RECORD LENGTH MULTIPLE OF 8 BYTES\n*        (DON'T CHANGE EXTRA BYTES, BECAUSE THEY CANNOT BE\n*        CORRECTLY DECRYPTED AFTER AN ENCRYPT OPERATION).\n         SPACE 1\n         L     R1,LRECL\n         CL    R1,=A(BUFLEN)\n         BH    ERMLG\n         SRL   R1,3\n         SLL   R1,3\n         ST    R1,BUFLVA\n         SPACE 1\n* ------ CALL TO SET THE CURRENT PROFILE TO 'CAPS OFF' TO ASSURE\n*        THAT SPF WILL NOT FOLD THE ENCRYPTED DATA TO UPPER CASE.\n         SPACE 1\n         CALL  ISPLINK,(EDIT,LEN0,EDOFF),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR12               NOT ZERO, ERROR\n         SPACE 1\n*--------------------------  R E Q U E S T  ---------------------------\n*        ALL NECESSARY PARAMETERS HAVE NOW BEEN OBTAINED AND DEFINED.\n*        NOW CHECK THE FUNCTION CODE FOR VALIDITY (E/D/H).\n*----------------------------------------------------------------------\n         SPACE 1\n         OC    FCDE,=CL8' '        FOLD THE CODE TO UPPER CASE\n         CLC   FCDE,=CL8'HELP    ' LOOK IF REQUEST IS HELP ONLY\n         BE    DSHELP\n         CLC   FCDE,=CL8'H       '\n         BE    DSHELP\n         CLC   FCDE,=CL8'ENCRYPT ' COMPARE FOR OURS\n         BE    SETFEN\n         CLC   FCDE,=CL8'EN      '\n         BE    SETFEN\n         CLC   FCDE,=CL8'E       '\n         BE    SETFEN\n         CLC   FCDE,=CL8'DECRYPT '\n         BE    SETFDE\n         CLC   FCDE,=CL8'DE      '\n         BE    SETFDE\n         CLC   FCDE,=CL8'D       '\n         BNE   EXIT                NOT US, EXIT\nSETFDE   MVI   FUNC+3,4            SET FUNCTION FOR DECRYPT\n         B     SETFEN+L'SETFEN     GO PROCESS\nSETFEN   MVI   FUNC+3,0            SET FUNCTION FOR ENCRYPT\n         SPACE 1\n*------------------------  K E Y - V A L U E  -------------------------\n*        CHECK AND SET THE SPECIFIED KEY VALUE.\n*----------------------------------------------------------------------\n         SPACE 1\n* ------ CHECK IF THE KEY VALUE HAS BEEN SPECIFIED.\n         SPACE 1\n         OC    KEY,=CL8' '         FOLD TO UPPER CASE\n         CLC   KEY,=CL8' '         ANY DATA?\n         BNE   EDRUN               YES\n         SPACE 1\n* ------ CALL ISPLINK TO PROMPT FOR A KEY VALUE.\n         SPACE 1\n         CALL  ISPLINK,(DSPL,PNLN),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR13               NOT ZERO, ERROR\n         CALL  ISPLINK,(VCPY,CL,LEN8,KEY,MVM),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR14               NOT ZERO, ERROR\n         SPACE 1\n* ------ NOW CHECK AGAIN THE KEY VALUE SPECIFIED.\n         SPACE 1\n         OC    KEY,=CL8' '         FOLD TO UPPER CASE\n         CLC   KEY,=CL8' '         ANY DATA?\n         BE    EXIT                NO (AGAIN), EXIT\n         SPACE 1\n* ------ LINK TO THE EN/DECIPH PROGRAM AT ENTRY POINT 'SETKEY'\n*        TO ESTABLISH THE KEY VALUE.\n         SPACE 1\nEDRUN    LA    R1,KEYADD           SET UP PARM REG\n         L     R15,SETADD          ADDRESS OF SETKEY ENTRY\n         BASR  R14,R15             GO TO SETKEY\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR15               NOT ZERO, ERROR\n         SPACE 1\n*--------------------------  P R O C E S S  ---------------------------\n*        PROCESS THE DATA LINES.\n*----------------------------------------------------------------------\n         SPACE 1\nLOOP     L     R1,LINENO           GET LINE NUMBER\n         LA    R1,1(,R1)           INCREMENT\n         ST    R1,LINENO           STORE BACK\n         CLC   LINENO,LLINE        LAST LINE DONE?\n         BH    LSTMSG              YES, DONE\n         SPACE 1\n* ------ CALL ISPLINK TO READ IN THE DESIGNATED LINE FROM THE\n*        DATA-SET.\n         SPACE 1\n         CALL  ISPLINK,(EDIT,LEN0,EDRLN),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR16               NOT ZERO, ERROR\n         SPACE 1\n* ------ CALL THE EN/DECIPH ROUTINE TO PERFORM THE EN/DECRYPTION\n*        ON THE CURRENT LINE.\n         SPACE 1\n         L     R1,FUNC             GET FUNCTION\n         L     R15,CIPHADD(R1)     GET ENTRY POINT REQUESTED\n         LA    R1,PARMLIST         SET R1 FOR CIPH ROUTINE\n         BASR  R14,R15             GO DO THE DESIRED FUNCTION\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   ERR17               NOT ZERO, ERROR\n         SPACE 1\n* ------ CALL ISPLINK TO WRITE BACK THE NEWLY EN/DECRYPTED LINE.\n         SPACE 1\n         CALL  ISPLINK,(EDIT,LEN0,EDWLN),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    LOOP                ZERO, GET THE NEXT RECORD\n         CL    R15,LEN4            DATA TRUNCATED?\n         BE    LOOP                YES, GET THE NEXT RECORD\n         B     ERR18               NO, ERROR\n         SPACE 1\n* ------ SET MESSAGE IF ENCRYPT/DECRYPT TRUNCATION OCCURED.\n         SPACE 1\nLSTMSG   CLC   LRECL,BUFLVA\n         BE    EXIT\n         MVC   MLTLV+5(1),LRECL+L'LRECL-1\n         NI    MLTLV+5,X'07'\n         OI    MLTLV+5,C'0'\n         CALL  ISPLINK,(VREP,MLTM,MLTML,MLTMV),VL\n         LR    R10,R15\n         CALL  ISPLINK,(VREP,MLTL,MLTLL,MLTLV),VL\n         B     QUIT\n         SPACE 1\n*-----------------------------  H E L P  ------------------------------\n*        DISPLAY THE HELP PANELS.\n*----------------------------------------------------------------------\n         SPACE 1\n* ------ CALL ISPLINK TO DISPLAY THE HELP PANELS.\n         SPACE 1\nDSHELP   CALL  ISPLINK,(DSPL,PNLH),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   DSHXIT              NOT ZERO\n         CALL  ISPLINK,(DSPL,PNLH1),VL\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    EXIT                OK\nDSHXIT   CL    R15,LEN8            CHECK IF END\n         BNE   ERR19               NOT END, ERROR\n         SPACE 1\n*------------------------------  E N D  -------------------------------\n*        PROCESSING TERMINATION.\n*----------------------------------------------------------------------\n         SPACE 1\n* ------ EXIT CODE FOLLOWS.\n         SPACE 1\nEXIT     XR    R10,R10             SET RETURN CODE\nLEAVE   $XRET  CC=(R10)            RETURN\n         SPACE 1\n*-------------------------  D I A G N O S E  --------------------------\n*        GENERATE ERROR MESSAGES.\n*----------------------------------------------------------------------\n         SPACE 1\n* ------ SET LONG MESSAGE SPECIFIC TEXT FOR ERROR DIAGNOSE.\n         SPACE 1\nERR1     MVC   MLOP,=CL8'FCDE    '\nERRA     MVC   MLFU,VDEF\n         B     ERWTO\nERR2     MVC   MLOP,=CL8'BUFFER  '\n         B     ERRA\nERR3     MVC   MLOP,=CL8'LRECL   '\n         B     ERRA\nERR4     MVC   MLOP,=CL8'LRC     '\n         B     ERRA\nERR5     MVC   MLOP,=CL8'EDMAC   '\n         MVC   MLFU,EDIT\n         B     ERWTO\nERR6     MVC   MLOP,=CL8'EDPRC   '\nERRB     MVC   MLFU,EDIT\n         B     ERRB\nERR7     MVC   MLOP,=CL8'EDQUE   '\n         B     ERRB\nERR8     MVC   MLOP,=CL8'EDFRG   '\n         B     ERRB\nERR9     MVC   MLOP,=CL8'EDLRG   '\n         B     ERRB\nERR10    MVC   MLOP,=CL8'EDLLR   '\n         B     ERRB\nERR11    MVC   MLOP,=CL8'EDLRL   '\n         B     ERRB\nERR12    MVC   MLOP,=CL8'EDOFF   '\n         B     ERRB\nERR13    MVC   MLOP,PNLN\nERRC     MVC   MLFU,DSPL\n         B     ERRET\nERR14    MVC   MLOP,CL\n         MVC   MLFU,VCPY\n         B     ERRET\nERR15    MVC   MLFU,=CL8'SETKEY  '\n         MVC   MLOP,=CL8'KEYVALUE'\n         B     ERRET\nERR16    MVC   MLOP,=CL8'EDRLN   '\n         B     ERRB\nERR17    MVC   MLFU+2(6),=CL6'CRYPT'\n         L     R1,FUNC             GET FUNCTION\n         B     *+L'*(R1)\n         B     *+L'*+10\n         MVC   MLFU(2),=CL2'DE'\n         B     *+L'*+6\n         MVC   MLFU(2),=CL2'EN'\n         MVC   MLOP(2),=CL2'AT'\n         MVC   MLOP+2(6),=XL6'402020202120'\n         L     R1,LINENO           GET LINE NUMBER\n         CVD   R1,WORKD\n         ED    MLOP+2(6),WORKD+5\n         B     ERRET\nERR18    MVC   MLOP,=CL8'EDWLN   '\n         B     ERRB\nERR19    MVC   MLOP,=CL8'HELP    '\n         B     ERRC\n         SPACE 1\n* ------ CALL ISPLINK TO SET SHORT/LONG MESSAGES.\n         SPACE 1\nERRET    CVD   R15,WORKD           EDIT RETURN CODE RECEIVED\n         MVC   MSRC,=XL4'40202120'\n         ED    MSRC,WORKD+6\n         CALL  ISPLINK,(VREP,MS,MSL,MSV),VL\n         LR    R10,R15\n         CALL  ISPLINK,(VREP,ML,MLL,MLV),VL\nQUIT     LTR   R10,R10\n         BZ    *+L'*+6\n         SLL   R15,8\n         OR    R10,R15\n         CALL  ISPLINK,(SETM,MSGID),VL\n         LTR   R10,R10\n         BZ    LEAVE\n         SLL   R15,16\n         OR    R10,R15\n         B     LEAVE\n         SPACE 1\nRGERR    CALL  ISPLINK,(VREP,RGM,RGML,RGMV),VL\n         LR    R10,R15\n         CALL  ISPLINK,(VREP,RGL,RGLL,RGLV),VL\n         B     QUIT\nRGINV    CALL  ISPLINK,(VREP,RIM,RIML,RIMV),VL\n         LR    R10,R15\n         CALL  ISPLINK,(VREP,RIL,RILL,RILV),VL\n         B     QUIT\nERMLG    CALL  ISPLINK,(VREP,MLGM,MLGML,MLGMV),VL\n         LR    R10,R15\n         CALL  ISPLINK,(VREP,MLGL,MLGLL,MLGLV),VL\n         B     QUIT\n         SPACE 1\n* ------ WTO SHORT/LONG MESSAGES (WE ARE NOT YET EDIT MACRO).\n         SPACE 1\nERWTO    CVD   R15,WORKD           EDIT RETURN CODE RECEIVED\n         MVC   MSRC,=XL4'40202120'\n         ED    MSRC,WORKD+6\n         MVC   WTOLST+4(MSVL),MSV\n        WTO    MF=(E,WTOLST)\n         MVC   WTOLST+4(MLVL),MLV\n        WTO    MF=(E,WTOLST)\n         LA    R10,16\n         B     LEAVE\n         PRINT GEN\n         EJECT\n* ------ CONSTANTS AND WORK-AREAS.\n         SPACE 1\nWORKD    DC    D'0'\nSETADD   DC    V(SETKEY)           VCON OF SETKEY ROUTINE\nCIPHADD  DC    V(ENCIPH)           VCON OF ENCIPH ROUTINE\n         DC    V(DECIPH)           VCON OF DECIPH ROUTINE\nFUNC     DC    F'0'                FUNCTION SAVE\n         SPACE 1\nNL       DC    C'(FCDE,KEY)'\n         DS    0F                  ALIGN\nFCDE     DC    CL8' '              AREA FOR THE FUNCTION\nKEY      DC    CL8' '              AREA FOR THE KEY VALUE\n         SPACE 1\nLL       DC    C'(BUFFER)'\n         DS    0F                  ALIGN\n         SPACE 1\nDL       DC    C'(LRECL,LLINE,LINENO)'\n         DS    0F                  ALIGN\nLRECL    DC    F'0'                AREA FOR THE DATA LENGTH\nLLINE    DC    F'0'                AREA FOR THE LAST LINE NUMBER\nLINENO   DC    F'0'                CURRENT LINE NUMBER\n         SPACE 1\nRL       DC    C'(LRC)'\n         DS    0F                  ALIGN\nLRC      DC    CL1' '              AREA FOR THE LINE COMMAND SETTING\n         SPACE 1\nCL       DC    C'(CRYKEY)'\n         DS    0F                  ALIGN\n         SPACE 1\nMS       DC    C'(ZEDSMSG)'\n         DS    0F                  ALIGN\nMSL      DC    A(MSVL)\nMSV      DC    C'RC ='\nMSRC     DC    CL4' '\nMSVL     EQU   *-MSV\nML       DC    C'(ZEDLMSG)'\n         DS    0F                  ALIGN\nMLL      DC    A(MLVL)\nMLV      DC    C'-- ERROR AT FUNCTION : '\nMLFU     DC    CL8' ',C' / OPERATION : '\nMLOP     DC    CL8' ',C' --'\nMLVL     EQU   *-MLV\n         SPACE 1\nRGM      DC    C'(ZEDSMSG)'\n         DS    0F                  ALIGN\nRGML     DC    A(L'RGMV)\nRGMV     DC    C'RANGE INCOMPLETE'\nRGL      DC    C'(ZEDLMSG)'\n         DS    0F                  ALIGN\nRGLL     DC    A(L'RGLV)\nRGLV     DC    C'ENTER A MATCHING \"CC\" TO COMPLETE THE BLOCK COMMAND PA1\n               IR'\n         SPACE 1\nRIM      DC    C'(ZEDSMSG)'\n         DS    0F                  ALIGN\nRIML     DC    A(L'RIMV)\nRIMV     DC    C'INVALID RANGE'\nRIL      DC    C'(ZEDLMSG)'\n         DS    0F                  ALIGN\nRILL     DC    A(L'RILV)\nRILV     DC    C'YOU MUST SPECIFY THE TARGET RANGE OF LINES USING \"CN\" 1\n               OR \"CC\"'\n         SPACE 1\nMLGM     DC    C'(ZEDSMSG)'\n         DS    0F                  ALIGN\nMLGML    DC    A(L'MLGMV)\nMLGMV    DC    C'LRECL GT 256'\nMLGL     DC    C'(ZEDLMSG)'\n         DS    0F                  ALIGN\nMLGLL    DC    A(L'MLGLV)\nMLGLV    DC    C'AN \"LRECL\" GREATER THAN 256 IS NOT SUPPORTED, SORRY'\n         SPACE 1\nMLTM     DC    C'(ZEDSMSG)'\n         DS    0F                  ALIGN\nMLTML    DC    A(L'MLTMV)\nMLTMV    DC    C'TRUNCATION'\nMLTL     DC    C'(ZEDLMSG)'\n         DS    0F                  ALIGN\nMLTLL    DC    A(L'MLTLV)\nMLTLV    DC    C'LAST   BYTES SKIPPED (\"LRECL\" NOT MULTIPLE OF 8)'\n         SPACE 1\nVDEF     DC    CL8'VDEFINE '\nEDIT     DC    CL8'ISREDIT '\nDSPL     DC    CL8'DISPLAY '\nVCPY     DC    CL8'VCOPY   '\nVREP     DC    CL8'VREPLACE'\nSETM     DC    CL8'SETMSG  '\nTYPEC    DC    CL8'CHAR    '\nTYPEF    DC    CL8'FIXED   '\nMVM      DC    CL8'MOVE    '\nPNLN     DC    CL8'PAJCRY  '\nPNLH     DC    CL8'PAJTCRY '\nPNLH1    DC    CL8'PAJTCRY1'\nMSGID    DC    CL8'ISRZ001 '\nLEN0     DC    F'0'\nLEN1     DC    F'1'\nLEN4     DC    F'4'\nLEN8     DC    F'8'\nLEN256   DC    F'256'\n         SPACE 1\nEDMAC    DC    C'\u00a2MACRO (FCDE,KEY) NOPROCESS\u00a2'\nEDPRC    DC    C'\u00a2PROCESS RANGE C\u00a2'\nEDQUE    DC    C'\u00a2(LRC) = RANGE_CMD\u00a2'\nEDFRG    DC    C'\u00a2(LINENO) = LINENUM .ZFRANGE\u00a2'\nEDLRG    DC    C'\u00a2(LLINE) = LINENUM .ZLRANGE\u00a2'\nEDLLR    DC    C'\u00a2(LLINE) = LINENUM .ZLAST\u00a2'\nEDLRL    DC    C'\u00a2(LRECL) = LRECL\u00a2'\nEDOFF    DC    C'\u00a2CAPS OFF\u00a2'\nEDRLN    DC    C'\u00a2(BUFFER) = LINE &&LINENO\u00a2'\nEDWLN    DC    C'\u00a2LINE &&LINENO =(BUFFER)\u00a2'\n         SPACE 1\n         DS    0F                  ALIGN\nKEYADD   DC    A(KEY)              KEY ADDRESS\nPARMLIST DC    A(BUFFER)           BUFFER ADDRESS\n         DC    A(BUFLVA)           BUFFER LENGTH VALUE ADDRESS\nBUFLVA   DC    A(*-*)              BUFFER LENGTH VALUE\n         SPACE 1\n*               ----+----1----+----2----+----3----+----4----+----5----+\n*              ----6----+----7----+---\nWTOLST  WTO    '                                                       1\n                                      ',ROUTCDE=11,DESC=7,MF=L\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R11,R12 - - - - - - END OF BASE REGISTER ADDRESSABILITY\n         SPACE 1\n         DS    0F\nBUFFER   DC    CL256' '            ENCRYPT/DECRYPT BUFFER\nBUFLEN   EQU   *-BUFFER            BUFFER LENGTH\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CRY$": {"ttr": 11527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x11\\x07\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T11:07:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//CRY      JOB (........),'INSTALL  - C R Y -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=3\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                R050A90                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,MBR=CRY\n//LNK     EXEC PAJILKI\n//SYSIN     DD *\n  INCLUDE SYSISP(ISPLINK)\n  INCLUDE SYSADD(R050A90)\n  ENTRY   CRY\n  NAME    CRY(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CRY@": {"ttr": 11529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89$\\x9f\\x00\\x89$\\x9f\\x16\\x17\\x004\\x004\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-06T00:00:00", "modifydate": "1989-09-06T16:17:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "SYSPAJA"}, "text": "1   06/09/89\n                                                      CRY       1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      ENCRYPT-DECRYPT ISPF/PDF       * * * * * * * *\n  * * * * * * * *            EDIT command             * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   performs the ENCRYPTION or DECRYPTION of data operating\n  ----------   as a primary command under ISPF/PDF EDIT.\n\n  Operation :  the ENCRYPTION or DECRYPTION is performed by utilizing a\n  -----------  key value supplied as an operand of the primary command.\n\n  Command syntax :      !CRY ENCRYPT,KEYVALUE         !CRY HELP\n  ----------------           or EN                      or H\n                                E\n                        !CRY DECRYPT,KEYVALUE\n                             or DE\n                                D\n               the KEYVALUE is a user supplied keyword which is used\n               as ENCRYPT/DECRYPT code value. The keyword is limited\n               to eight (8) bytes in length, but may be shorter.\n               When the KEYVALUE operand of the primary command is\n               omited, you are prompted to supply it unviewable (i.e.\n               when entering \"!CRY E\" only).\n\n  Warning :  If you forget the KEYVALUE that you used to encipher the\n  ---------  data, KISS THE DATA GOOD-BYE because there is no way of\n             deciphering the data again.\n             If you are hopelessly paranoid, you can encipher the\n             enciphered data with a different KEYVALUE to really grunge\n             up the data. The decipherion process must be the exact\n             inverse of the encipher process in order to recover the\n             original data again.\n\n  Examples : 1) to encipher the data with the key of ALPHA, type :\n  ----------                 !CRY E,ALPHA\n                and to get it back to clear text again, type :\n                             !CRY D,ALPHA\n             2) to really garbage up the data with keys of ALPHA and\n                BRAVO, type : !CRY E,ALPHA\n                             and then after !CRY E,BRAVO\n                and to decipher the text, just reverse the order as\n                follows, type : !CRY D,BRAVO\n                             and then after !CRY D,ALPHA\n\n  Range :    You may also limit the encryption-decryption by marking a\n  -------    range of lines of text with the \"C\" range command on the\n             line numbers.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CUT": {"ttr": 11531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x973O\\x00\\x973O\\tF\\x01`\\x01`\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-11-30T00:00:00", "modifydate": "1997-11-30T09:46:00", "lines": 352, "newlines": 352, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM,BPARM,CPARM) NOPROCESS\n/*  MACRO NAME : CUT                                                */\n/*    FUNCTION : 1. WRITE LINES FROM A FILE TO THE USER PROFILE     */\n/*                  POOL FOR LATER INCLUSION BY THE INSERT OPTION.  */\n/*               2. WRITE LINES FROM THE USER PROFILE POOL INTO THE */\n/*                  CURRENT FILE (INSERT OPTION).                   */\n/*               3. DELETE CUT DATA IN THE VARIOUS LEVELS OF CUT.   */\n/*               4. SHOWS DATA IN VARIOUS LEVELS OF CUT.            */\n/*               5. SHOWS FIRST LINE OF ALL CUT LEVELS.             */\n/*      SYNTAX : CUT LEVEL-NUMBER                                   */\n/*               CUT LEVEL-NUMBER SHOW                              */\n/*               CUT LEVEL-NUMBER DELETE                            */\n/*               CUT SHOW OR SHOW TERSE                             */\n/*               CUT HELP OR H                                      */\n/*       DEBUG   CUT ... LIST OR CUT ... ... LIST                   */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n/*        FROM : 5 MACROS (CUT PASTE DELCUT SHOWCUT SHOCUT2)        */\n  ISPEXEC CONTROL ERRORS RETURN\n  IF &STR(&CPARM.) = &STR(L) THEN SET &CPARM = &STR(LIST)\n  IF &STR(&BPARM.) = &STR(L) THEN SET &BPARM = &STR(LIST)\n  IF &STR(&BPARM.) = &STR(T) THEN SET &BPARM = &STR(TERSE)\n  IF &STR(&BPARM.) = &STR(D) THEN SET &BPARM = &STR(DELETE)\n  IF &STR(&BPARM.) = &STR(I) THEN SET &BPARM = &STR(INSERT)\n  IF &STR(&BPARM.) = &STR(S) THEN SET &BPARM = &STR(SHOW)\n  IF &STR(&APARM.) = &STR(H) THEN SET &APARM = &STR(HELP)\n  IF &STR(&APARM.) = &STR(S) THEN SET &APARM = &STR(SHOW)\n  IF &STR(&BPARM.) = &STR(LIST) THEN DO\n    SET &CPARM = &STR(LIST)\n    SET &BPARM =\n    END\n  IF &STR(&CPARM.) = &STR(LIST) THEN CONTROL LIST SYMLIST CONLIST\n/*  LIMITS : THE MAXIMUM UPPER VALUES ACCEPTABLE ARE 99 LEVELS      */\n/*           AND 1000 LINES PER LEVEL (TROUBLES RESULTS IF ANY      */\n/*           GREATER VALUE IS SPECIFIED).                           */\n  SET &MAXLV = 99\n  SET &MAXLN = 1000\n  IF &APARM ^= &Z THEN DO\n/*  PROCESSING : CUT HELP   - - - - - - - - - - - - - - - - - - - - */\n    IF &APARM = HELP THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTCUT)\n      SET &RCX = &LASTCC\n      ISPEXEC CONTROL DISPLAY RESTORE\n      EXIT CODE(&RCX)\n      END\n/*  PROCESSING : CUT SHOW   - - - - - - - - - - - - - - - - - - - - */\n    IF &APARM = SHOW THEN DO\n      SET &LEVELX = 1\n      SET &MAXLVT = &MAXLV + 1\n      SET INDEX = 0\n      ISREDIT (ROW,COL) = CURSOR\n      IF &ROW NE 1 THEN DO\n        ISREDIT (LAST) = LINENUM .ZLAST\n        IF &ROW > &LAST THEN SET &ROW = &LAST + 1\n        END\n      SET &NTC = &STR(FIRST LINE OF EACH LEVEL OF CUT WILL BE SHOWN)\n      ISREDIT LINE_BEFORE &ROW = MSGLINE \"&NTC\"\n      IF &BPARM = TERSE THEN SET &LEVELZ = 0\n      DO WHILE &LEVELX < &MAXLVT\n        SET LEVEL = &LEVELX\n        ISPEXEC VGET (RCUTLM&LEVEL,RCUTLB&LEVEL,RCUTRB&LEVEL) PROFILE\n        IF &LASTCC = 0 THEN DO\n          SET LINES = &&RCUTLM&LEVEL\n          SET &NTC = &STR(CUT LEVEL &LEVEL HAS &LINES LINE(S))\n          ISREDIT LINE_BEFORE &ROW = MSGLINE \"&NTC\"\n          ISPEXEC VGET CL&LEVEL.L&EVAL(&INDEX+1) PROFILE\n          ISREDIT LINE_BEFORE &ROW = MSGLINE +\n            < 1 (CL&LEVEL.L&EVAL(&INDEX+1)) >\n          SET &LEVELZ = &LEVELZ + 1\n          END\n        ELSE IF &BPARM ^= TERSE THEN DO\n          SET &CUTX = &STR(NO CUT LINE(S) FOR LEVEL &LEVELX)\n          ISREDIT LINE_BEFORE &ROW = MSGLINE \"&CUTX\"\n          END\n        SET &LEVELX = &LEVELX + 1\n        END\n      SET &NTC = &STR(&LEVELZ LEVEL(S) OF CUT HAS BEEN FOUND)\n      ISREDIT LINE_BEFORE &ROW = MSGLINE \"&NTC\"\n      ISREDIT LOCATE FIRST SPE\n      EXIT CODE(0)\n      END\n    ELSE DO\n      IF &DATATYPE(&APARM) = NUM THEN DO\n        SET LEVEL = &APARM\n        IF &LEVEL < 0 OR &LEVEL > &MAXLV THEN DO\n          SET &ZEDSMSG = &STR(INVALID LEVEL)\n          SET &ZEDLMSG = &STR(LEVEL-NUMBER MUST BE FROM 1 UP TO &MAXLV)\n          ISPEXEC SETMSG MSG(ISRZ001)\n          EXIT CODE(12)\n          END\n        END\n      ELSE DO\n        SET &ZEDSMSG = &STR(LEVEL ERROR)\n        SET &ZEDLMSG = &STR(LEVEL-NUMBER SPECIFIED IS NOT NUMERIC)\n        ISPEXEC SETMSG MSG(ISRZ001)\n        EXIT CODE(12)\n        END\n      IF &BPARM ^= &Z THEN DO\n/*  PROCESSING : CUT ... DELETE   - - - - - - - - - - - - - - - - - */\n        IF &BPARM = DELETE THEN DO\n          ISPEXEC VGET (RCUTLM&LEVEL,RCUTLB&LEVEL,RCUTRB&LEVEL) PROFILE\n          IF &LASTCC > 0 THEN DO\n            SET &ZEDSMSG = &STR(NONE LEVEL &LEVEL)\n            SET &ZEDLMSG = +\n              &STR(THERE ARE NO CUT LINES FOR LEVEL &LEVEL)\n            ISPEXEC SETMSG MSG(ISRZ001)\n            EXIT CODE(12)\n            END\n          SET LINES = &&RCUTLM&LEVEL\n          SET LINESTOPASTE = &LINES\n          SET INDEX = 0\n          DO WHILE &INDEX < &LINESTOPASTE\n            ISPEXEC VERASE CL&LEVEL.L&EVAL(&INDEX+1) PROFILE\n            ISPEXEC +\n              VERASE (RCUTLM&LEVEL,RCUTLB&LEVEL,RCUTRB&LEVEL) PROFILE\n            SET INDEX  = &INDEX + 1\n            END\n          SET &ZEDSMSG = &STR(LEVEL &LEVEL DELETED)\n          SET &ZEDLMSG = +\n            &STR(&INDEX LINES FOR CUT LEVEL &LEVEL DELETED)\n          ISPEXEC SETMSG MSG(ISRZ001)\n          EXIT CODE(0)\n          END\n/*  PROCESSING : CUT ... INSERT   - - - - - - - - - - - - - - - - - */\n        IF &BPARM = INSERT THEN DO\n          ISREDIT PROCESS DEST RANGE 0\n          SET RC = &LASTCC\n          IF &RC > 8 THEN DO\n            ISREDIT (EMP1) = LINENUM .ZFIRST\n            ISREDIT (EMP2) = LINENUM .ZLAST\n              IF &EMP1 = &EMP2 THEN DO\n              SET RC = 4\n              SET EMPTY = YES\n              END\n            ELSE DO\n              SET &ZEDSMSG = &STR(SAY WHERE)\n              SET &ZEDLMSG = +\n                &STR(USE \"A\" OR \"B\" TO INDICATE WHERE LINE(S) +\n                     SHOULD BE INSERTED)\n              ISPEXEC SETMSG MSG(ISRZ001)\n              EXIT CODE(12)\n              END\n            END\n          ISPEXEC VGET (RCUTLM&LEVEL,RCUTLB&LEVEL,RCUTRB&LEVEL) PROFILE\n          IF &LASTCC > 0 THEN DO\n            SET &ZEDSMSG = &STR(NONE LEVEL &LEVEL)\n            SET &ZEDLMSG = +\n              &STR(THERE ARE NO CUT LINES FOR LEVEL &LEVEL)\n            ISPEXEC SETMSG MSG(ISRZ001)\n            EXIT CODE(12)\n            END\n          SET LINES = &&RCUTLM&LEVEL\n          SET LINESTOPASTE = &LINES\n          SET LBND = &&RCUTLB&LEVEL\n          SET LBND = &LBND\n          SET RBND = &&RCUTRB&LEVEL\n          SET RBND = &RBND\n          ISREDIT (LHBND,RHBND) = BOUNDS\n          IF &RC > 8 THEN DO\n            SET &ZEDSMSG = &STR(NO PLACE)\n            SET &ZEDLMSG = &STR(YOU MUST USE \"A\" OR \"B\" LINE COMMANDS)\n            ISPEXEC SETMSG MSG(ISRZ001)\n            EXIT CODE(12)\n            END\n          CONTROL ASIS\n          IF &RC = 4 THEN DO\n            ISREDIT (ILINE) = LINENUM .ZDEST\n            IF &EMPTY = YES THEN SET ILINE = 0\n            SET INDEX = 0\n            DO WHILE &INDEX < &LINESTOPASTE\n              ISPEXEC VGET CL&LEVEL.L&EVAL(&INDEX+1) PROFILE\n              ISREDIT LINE_AFTER &ILINE = +\n                < (LBND) (CL&LEVEL.L&EVAL(&INDEX+1)) >\n              SET INDEX = &INDEX + 1\n              SET ILINE = &ILINE + 1\n              END\n            END\n          ELSE DO\n            ISREDIT (CROW,CPOS) = CURSOR\n            IF &CPOS > 0 THEN DO\n              SET LPOS = &CPOS\n              SET RPOS = &RBND - &LBND + 1\n              END\n            ELSE DO\n              SET LPOS = &LBND\n              SET RPOS = &RBND\n              END\n            IF &LHBND > &LPOS THEN DO\n              SET &ZEDSMSG = &STR(ILLEGAL BOUNDS)\n              SET &ZEDLMSG = +\n                &STR(CURRENT LEFT BOUND IS GREATER THAN THE +\n                     RELATIVE LEFT BOUND )F &LPOS TO BE PASTED)\n              ISPEXEC SETMSG MSG(ISRZ001)\n              EXIT CODE(12)\n              END\n            ISREDIT (FIRST) = LINENUM .ZFRANGE\n            ISREDIT (LAST) = LINENUM .ZLRANGE\n            SET RANGE = &EVAL(&LAST-&FIRST+1)\n            IF &RANGE < &LINESTOPASTE THEN SET LINESTOPASTE = &RANGE\n            SET PLACE = 0\n            SET RINDEX = 0\n            DO WHILE &RINDEX < &RANGE\n              SET &INDEX = 0\n              DO WHILE &INDEX < &LINESTOPASTE\n                ISPEXEC VGET CL&LEVEL.L&EVAL(&INDEX+1) PROFILE\n                SET CUT = &&CL&LEVEL.L&EVAL(&INDEX+1)\n                SET CUT = &SYSNSUB(2,&CUT)\n                ISREDIT (LINE) = LINE &EVAL(&FIRST+&PLACE)\n                IF &LHBND < &LPOS THEN +\n                  SET NULINE = &SUBSTR(1:&LPOS-1,&NRSTR(&LINE))\n                ELSE SET NULINE = &Z\n                SET NULINE = &NRSTR(&NULINE)&NRSTR(&CUT)\n                IF &RHBND > &RPOS THEN SET NULINE = &NRSTR(&NULINE)+\n                  &SUBSTR(&LENGTH(&NRSTR(&NULINE))+1:&RHBND,+\n                  &NRSTR(&LINE))\n                ISREDIT LINE &EVAL(&FIRST+&PLACE) = (NULINE)\n                SET INDEX = &INDEX + 1\n                SET PLACE = &PLACE + 1\n                END\n              SET RINDEX = &RINDEX + &LINESTOPASTE\n              IF &RINDEX + &LINESTOPASTE > &RANGE THEN +\n                SET LINESTOPASTE = &RANGE - &RINDEX\n              END\n            END\n          EXIT CODE (0)\n          END\n/*  PROCESSING : CUT ... SHOW   - - - - - - - - - - - - - - - - - - */\n        IF &BPARM = SHOW THEN DO\n          ISPEXEC VGET (RCUTLM&LEVEL,RCUTLB&LEVEL,RCUTRB&LEVEL) PROFILE\n          IF &LASTCC > 0 THEN DO\n            SET &ZEDSMSG = &STR(NONE LEVEL &LEVEL)\n            SET &ZEDLMSG = +\n              &STR(THERE ARE NO CUT LINES FOR LEVEL &LEVEL)\n            ISPEXEC SETMSG MSG(ISRZ001)\n            EXIT CODE(12)\n            END\n          SET LINES = &&RCUTLM&LEVEL\n          SET LINESTOPASTE = &LINES\n          SET INDEX = 0\n          ISREDIT (ROW,COL) = CURSOR\n          IF &ROW NE 1 THEN DO\n            ISREDIT (LAST) = LINENUM .ZLAST\n            IF &ROW > &LAST THEN SET &ROW = &LAST + 1\n            END\n          SET &CUTX = &STR(CUT LEVEL &LEVEL HAS &LINES LINE(S))\n          ISREDIT LINE_BEFORE &ROW = MSGLINE \"&CUTX\"\n          DO WHILE &INDEX < &LINESTOPASTE\n            ISPEXEC VGET CL&LEVEL.L&EVAL(&INDEX+1) PROFILE\n            ISREDIT LINE_BEFORE &ROW = MSGLINE +\n              < 1 (CL&LEVEL.L&EVAL(&INDEX+1)) >\n            SET INDEX = &INDEX + 1\n            END\n          ISREDIT LOCATE FIRST SPE\n          EXIT CODE(0)\n          END\n        ELSE DO\n          SET &ZEDSMSG = &STR(INVALID OPTION)\n          SET &ZEDLMSG = +\n            &STR(OPTION CAN BE ONLY \"DELETE\", \"INSERT\" OR \"SHOW\")\n          ISPEXEC SETMSG MSG(ISRZ001)\n          EXIT CODE(12)\n          END\n        END\n      END\n    END\n/*  PROCESSING : CUT ...  - - - - - - - - - - - - - - - - - - - - - */\n  ELSE SET LEVEL = 1\n  ISREDIT PROCESS RANGE C M\n  SET LCC = &LASTCC\n  ISREDIT (RC) = RANGE_CMD\n  SET RCC = &LASTCC\n  IF &LCC ^=0 OR &RCC ^=0 THEN DO\n    IF &RCC = 4 THEN DO\n      IF &STR(&RC) = &STR(C) OR &STR(&RC) = &STR(M) THEN DO\n        SET &ZEDSMSG = &STR(RANGE INCOMPLETE)\n        SET &ZEDLMSG = &STR(ENTER A MATCHING \"CC\" OR \"MM\" TO +\n                            COMPLETE THE BLOCK COMMAND PAIR)\n        END\n      ELSE DO\n        IF &LCC = 4 THEN SET &ZEDSMSG = &STR(NO RANGE)\n        ELSE SET &ZEDSMSG = &STR(INVALID RANGE)\n        SET &ZEDLMSG = &STR(YOU MUST SPECIFY A RANGE USING \"CN\", +\n                           \"CC\", \"MN\" OR \"MM\")\n        END\n      END\n    ELSE IF &RCC = 8 THEN DO\n      SET &ZEDSMSG = &STR(NOT ACCEPTABLE)\n      SET &ZEDLMSG = &STR(AN UNACCEPTABLE TARGET RANGE OF LINES +\n                          HAS BEEN SPECIFIED)\n      END\n    ELSE DO\n      SET &ZEDSMSG = &STR(SEVERE ERROR)\n      SET &ZEDLMSG = &STR(SEVERE ERROR OCCURED, RETURN CODES ARE +\n                          &LCC AND &RCC)\n      END\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n    END\n  ISREDIT (FIRST) = LINENUM .ZFRANGE\n  ISREDIT (LAST) = LINENUM .ZLRANGE\n  SET LINESTOCUT = &EVAL(&LAST-&FIRST+1)\n  IF &LINESTOCUT > &MAXLN THEN DO\n    SET &ZEDSMSG = &STR(LINES OVERFLOW)\n    SET &ZEDLMSG = &STR(NUMBER OF LINES PER LEVEL EXCEEDS MAXIMUM +\n                        OF &MAXLN ALLOWED)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n    END\n  SET RCUTLM&LEVEL = &LINESTOCUT\n  SET &TCUT = &LINESTOCUT\n  ISREDIT (LBND,RBND) = BOUNDS\n  SET RCUTLB&LEVEL = &LBND\n  SET RCUTRB&LEVEL = &RBND\n  ISPEXEC VPUT (RCUTLM&LEVEL,RCUTLB&LEVEL,RCUTRB&LEVEL) PROFILE\n  SET INDEX = 0\n  CONTROL ASIS\n  DO WHILE &INDEX < &LINESTOCUT\n    ISREDIT (WKLINE) = LINE &EVAL(&FIRST+&INDEX)\n    SET CL&LEVEL.L&EVAL(&INDEX+1) = -\n      &SUBSTR(&LBND:&RBND,&NRSTR(&WKLINE))\n    ISPEXEC VPUT (CL&LEVEL.L&EVAL(&INDEX+1)) PROFILE\n    SET INDEX = &INDEX + 1\n    END\n  IF &RC = M THEN DO\n    ISREDIT (WIDTH) = DATA_WIDTH\n    IF &RBND-&LBND+1 = &WIDTH THEN ISREDIT DELETE &FIRST &LAST\n    ELSE DO\n      SET INDEX = 0\n      SET BLANK = &STR(                                                -\n                                                                       -\n                                                                       -\n                                                               )\n      DO WHILE &INDEX < &LINESTOCUT\n        ISREDIT (WKLINE) = LINE &EVAL(&FIRST+&INDEX)\n        IF &LBND > 1 THEN -\n          SET NULINE = &SUBSTR(1:&LBND-1,&NRSTR(&WKLINE))\n        ELSE SET NULINE = &Z\n        SET BLINE = &NRSTR(&NULINE)+\n          &SUBSTR(1:&RBND-&LBND+1,&STR(&BLANK))\n        IF &RBND < &WIDTH THEN -\n          SET NULINE = &NRSTR(&BLINE)&SUBSTR(&RBND+1:&WIDTH,+\n            &NRSTR(&WKLINE))\n        ELSE SET NULINE = &NRSTR(&BLINE)\n        ISREDIT LINE &EVAL(&FIRST+&INDEX) = (NULINE)\n        SET INDEX = &INDEX + 1\n        END\n      END\n    END\n  SET &ZEDSMSG = &STR(&TCUT LINE(S) LEVEL &LEVEL)\n  SET &ZEDLMSG = &STR(CUT LEVEL &LEVEL HAS NOW &TCUT LINE(S) STORED)\n  ISPEXEC SETMSG MSG(ISRZ001)\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CUT#": {"ttr": 11781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x973O\\x00\\x973O\\tV\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-11-30T00:00:00", "modifydate": "1997-11-30T09:56:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SBGOLOB"}, "text": "  To : Mr. Sam GOLOB                           Ispra, the 25 Nov. 1997.\n  From : Mr. Paul MOINIL\n\n         Sam,\n\n         Yesterday, I have detected an error using the CUT macro in an\n  ISPF/PDF Edit session. The symptoms I saw were i.e. :\n         a) the data lines 11, 12, 13, ... of a previous stored CUT 1\n            level are replaced by the data lines 1, 2, 3, ... of a new\n            stored CUT 11 level, or\n         b) the data lines 1, 2, 3, ... of a previous stored CUT 11\n            level are canceled by the Deletion of a CUT 1 level.\n         Now, I don't send you back all the files of my last version of\n  1996, March 15, but just the corrected CUT macro (352 cards instead\n  of 341 old version) which must replace that one in the SOURCE.FILE0\n  (Basic Material) actually CBT tape version # 414, file 454.\n\n\n                                       Sincerely,\n\n                                          Paul\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CUT@": {"ttr": 11783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x14X\\x00r\\x00r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T14:58:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "SYSPAJA"}, "text": "1   12/09/89\n                                                      CUT       1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      CUT ISPF/PDF EDIT command      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to\n  ----------   1 - write lines from a file to the user profile POOL\n                   for later inclusion by the INSERT option, or\n               2 - write lines from the user profile POOL into the\n                   current file (INSERT option), or\n               3 - delete CUT data in the various levels of CUT in the\n                   user profile POOL, or\n               4 - show CUT data in the various levels of CUT in the\n                   user profile POOL, or\n               5 - show the first line of all levels of CUT in the user\n                   profile POOL.\n\n  Command syntax : CUT (default level is 1) or\n  ---------------- CUT LN (level-number) or\n                   CUT LN INSERT or\n                   CUT LN DELETE or\n                   CUT LN SHOW or\n                   CUT SHOW or CUT SHOW TERSE\n                   CUT HELP or H\n\n  Use :  1 - write lines from a file to the user profile POOL for later\n  -----      inclusion by the INSERT option.\n             Syntax : CUT (default level is 1) or CUT LN (level-number)\n             Restriction : the level-number may range between 1 and 99\n                           included only.\n             Enter CUT on the command line and use the C or M line\n             commands (in any form) to select the lines to be cut.\n             If the M line command is used, the indicated lines are\n             deleted (reset to blanks) after they have been copied.\n             A level-number may be used to separate different levels of\n             CUT. This way you can make many CUTs before you INSERT.\n             If the level-number is omited, level 1 is assumed and\n             anything in the level 1 will be overlayed.\n             CUT 3 (or any number) will CUT the indicated line(s) into\n             level 3 (or level indicated) and can be INSERTed using\n             the level-number.\n1   12/09/89\n                                                      CUT       2/3.\n\n         2 - write lines from the user profile POOL into the current\n             file (INSERT option).\n             Syntax : CUT LN (level-number) INSERT or I\n             Enter CUT on the command line followed by the level-number\n             and the keyword INSERT, and use the A or B line command\n             to specify where the lines are to be inserted.\n             The level-number may be used to separate different levels\n             of CUTs.\n             CUT 3 (or any number) INSERT will add all the lines of the\n             CUT level 3 (or level indicated) where the A or B line\n             command (after or before) is pointing in the current file.\n\n         3 - delete CUT data in the various levels of CUT in the user\n             profile POOL.\n             Syntax : CUT LN (level-number) DELETE or D\n             Type CUT on the COMMAND line followed by the level-number\n             and the keyword DELETE.\n             In example :\n               COMMAND ===> CUT 2 DELETE\n               *********...********* TOP OF DATA *********...*********\n               Result :\n               COMMAND ===>                        CUT LEVEL 2 DELETED\n               *********...********* TOP OF DATA *********...*********\n\n         4 - show CUT data in the various levels of CUT in the user\n             profile POOL.\n             Syntax : CUT LN (level-number) SHOW or S\n             Type CUT on the COMMAND line followed by the level-number\n             and the keyword SHOW.\n             In example :\n               COMMAND ===> CUT 2 SHOW\n               *********...********* TOP OF DATA *********...*********\n               Result :\n               ==MSG> CUT LEVEL 1 HAS 4 LINE(S)\n               ==MSG> ... DATA LINE 1 ...\n               ==MSG> ... DATA LINE 2 ...\n               ==MSG> ... DATA LINE 3 ...\n               ==MSG> ... DATA LINE 4 ...\n             Remark : you may place the cursor on a data line to\n                      indicate where the MSG lines must be inserted\n                      (before), then press ENTER (by default it is\n                      before data line 1).\n1   12/09/89\n                                                      CUT       3/3.\n\n         5 - show the first line of all levels of CUT in the user\n             profile POOL. An optional keyword TERSE will prevent\n             display for CUT levels with no lines.\n             Syntax : CUT SHOW or CUT SHOW TERSE (CUT S or CUT S T)\n             Type CUT on the COMMAND line followed by the keyword SHOW\n             and the optional TERSE keyword.\n             In example :\n               COMMAND ===> CUT SHOW TERSE\n               *********...********* TOP OF DATA *********...*********\n               Result :\n               ==MSG> FIRST LINE OF EACH LEVEL OF CUT WILL BE SHOWN\n               ==MSG> CUT LEVEL 1 HAS 4 LINE(S)\n               ==MSG> ... DATA LINE 1 ...\n               ==MSG> CUT LEVEL 3 HAS 9 LINE(S)\n               ==MSG> ... DATA LINE 1 ...\n               ... and so on ...\n               (the scan is done until level 99)\n             Remark : you may place the cursor on a data line to\n                      indicate where the MSG lines must be inserted\n                      (before), then press ENTER (by default it is\n                      before data line 1).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DASCAN": {"ttr": 11786, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x0f\\x00\\x882\\x0f\\x15D\\x00t\\x00t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-15T00:00:00", "modifydate": "1988-11-15T15:44:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "SYSPAJA"}, "text": "DASC     TITLE 'DIRECT-ACCESS UCB-S LOOKUP SUBROUTINE.'\nDASCAN   START 0\n         SPACE 1\n         ENTRY DARSCA\n         SPACE 1\n* CALLING SEQUENCE : CALL DASCAN,(A,B),VL\n* ------------------ CALL DARSCA,(A,B),VL\n*                                (A)\n*\n*        WHERE : A - RECEIVES THE ADDRESS OF AN ONLINE (DASCAN) OR\n*                    AN ONLINE AND READY (DARSCA) DIRECT-ACCESS UCB\n*                    (FORMAT FULLWORD - F BOUNDARY).\n*\n*                B - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                    F BOUNDARY) IF SUPPLIED (OPTIONAL).\n*\n*        RETURN CODES (REGISTER 15) :\n*\n*                        0 = NORMAL.\n*                        4 = END OF UCB'S LOOK UP TABLE.\n*                        8 = CALLING SEQUENCE OR PARAMETER ALIGNMENT\n*                            ERROR.\n*\n* GENERAL NOTICE : THIS ROUTINE IS SERIALLY REUSABLE.\n* ================\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 2\n        $DEFREG\n         EJECT\n         USING *,R15\n         MVI   WTGO+3,COMMON-*     SET DASCAN ENTRY ---------- 1.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nDARSCA   MVI   WTGO+3,COMMON-*     SET DARSCA ENTRY ---------- 0.\n         DROP  R15\nWTGO     LA    R15,*-*(R15)        SET COMMON ENTRY ADDRESS.\n         SPACE 1\nCOMMON  $XENT  BASE=R12,ID=DASCAN\n         LR    R15,R12             COMPUTE ENTRY SWITCH.\n         BCTR  R15,0\n         SR    R7,R7\n         IC    R7,0(R15)\n         SRL   R7,4\n         EJECT\n         SR    R8,R8\n         SR    R9,R9\n         SR    R10,R10\n         TM    3(R1),X'03'\n         BNZ   ERSA\n         TM    0(R1),X'80'\n         BO    GADD\n         TM    4(R1),X'80'\n         BZ    ERSA\n         TM    7(R1),X'03'\n         BNZ   ERSA\n         L     R9,4(R1)\n         LA    R9,0(R9)\nGADD     L     R8,0(R1)\n         LA    R8,0(R8)\n         L     R2,CVTPTR           GET CVT POINTER.\n         USING CVT,R2\n         BALR  R6,0                ESTABLISH LOOP ADDRESS.\n         LA    R1,PARMLIST         SET PARAMETER LIST ADDRESS.\n         L     R15,CVTUCBSC        GET SCAN SERVICE ADDRESS.\n         DROP  R2\n         BALR  R14,R15             GO TO SCAN SERVICE (R13=SA).\n         LTR   R15,R15             HAS A UCB BEEN RETURNED?\n         BNZ   ENDSRC              BRANCH IF END, NOT FOUND.\n         L     R3,ADDRUCB          GET UCB ADDRESS.\n         USING UCBDSECT,R3\n         TM    UCBSTAT,UCBONLI     IS DEVICE ONLINE?\n         BZR   R6                  IF NOT, GO TO NEXT.\n         LTR   R7,R7               WHAT REQUESTED?\n         BNZ   STORE               ONLY ONLINE, SKIP NEXT TEST.\n         TM    UCBFLA,UCBNOTRD     IS DEVICE NOT READY?\n         BOR   R6                  IF YES, GO TO NEXT.\n         DROP  R3\n         SPACE 1\nSTORE    ST    R3,0(R8)            PASS THIS UCB ADDRESS.\n         B     LEAVE\n         EJECT\nENDSRC   LA    R10,4\n         B     CLEAR\nERSA     LA    R10,8\nCLEAR    XC    ADDRUCB,ADDRUCB\n         XC    WRKTAB,WRKTAB       CLEAR WORK AREA.\nLEAVE    LTR   R9,R9\n         BZ    EXIT\n         ST    R10,0(R9)           STORE INDICATOR.\nEXIT    $XRET  CC=(R10)\n         SPACE 2\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\n         DS    0D                  ALIGNMENT NEEDED.\nWRKTAB   DC    XL100'0'\nPARMLIST DC    A(WRKTAB,DEVCL),A(X'80000000'+ADDRUCB)\nADDRUCB  DC    F'0'\nDEVCL    DC    AL1(UCB3DACC)       DIRECT ACCESS DEVICE CLASS.\n         SPACE 2\n        PRINT  NOGEN\n         SPACE 1\n        CVT    DSECT=YES,LIST=YES\n         SPACE 1\nUCBDSECT DSECT\n         SPACE 1\n        IEFUCBOB\n         SPACE 1\n        PRINT  GEN\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DASCAN$": {"ttr": 11789, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//DASCAN   JOB (........),'INSTALL  - DASCAN -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS3,MBR=DASCAN\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   DARSCA\n  NAME    DASCAN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DASCAN@": {"ttr": 11791, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00%\\x00%\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      DASCAN    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     DIRECT-ACCESS UCB'S LOOKUP.     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n  Calling sequence : CALL DASCAN,(A,B),VL\n  ------------------ CALL DARSCA,(A,B),VL\n                                 (A)\n\n         Where : A - receives the address of an on-line (DASCAN) or\n                     an on-line and ready (DARSCA) direct-access UCB\n                     (format FULLWORD - F boundary).\n\n                 B - receives the return code (format FULLWORD -\n                     F boundary) if supplied (optional).\n\n         Return codes (register 15) :\n\n                         0 = normal.\n                         4 = end of UCB's look up table.\n                         8 = calling sequence or parameter alignment\n                             error.\n\n  Assembler macro : $DASCAN A,B\n  ----------------- $DARSCA A,B\n\n         Where B is optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  General notice : 1. This routine is serially reusable.\n  ---------------- 2. The UCB's scan restart after any non-zero\n                      return code.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAUNTY": {"ttr": 11793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x1f\\x00\\x88\\t\\x1f\\x146\\x00_\\x00_\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-31T00:00:00", "modifydate": "1988-03-31T14:36:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "SYSPAJA"}, "text": "DAUN     TITLE 'DIRECT-ACCESS UNIT TYPE SUBROUTINE.'\nDAUNTY   START 0\n         SPACE 1\n* CALLING SEQUENCE : CALL DAUNTY,(A,B,C),VL\n* ------------------             (A,B)\n*\n*        WHERE : A - IS THE ADDRESS OF A ONE BYTE FIELD CONTAINING\n*                    A DIRECT-ACCESS TYPE (HEXADECIMAL FORMAT, LIKE\n*                    IN UCBTBYT4).\n*\n*                B - IS THE ADDRESS OF AN EIGTH BYTES FIELD RECEIVING\n*                    THE CORRESPONDING UNIT TYPE RIGHT PADDED WITH\n*                    BLANKS (THE TRUE LENGTH IS PASSED BACK IN THE\n*                    REGISTER 0).\n*\n*                C - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                    F BOUNDARY) IF SUPPLIED (OPTIONAL).\n*\n*        RETURN CODES (REGISTER 15) :\n*\n*                        0 = NORMAL.\n*                        4 = INVALID DIRECT-ACCESS TYPE.\n*                        8 = CALLING SEQUENCE OR PARAMETER ALIGNMENT\n*                            ERROR.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 2\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12\n         SR    R0,R0\n         LR    R7,R0\n         LR    R8,R0\n         LR    R9,R0\n         LR    R10,R0\n         TM    0(R1),X'80'\n         BO    ERSA\n         TM    4(R1),X'80'\n         BO    GADD\n         TM    8(R1),X'80'\n         BZ    ERSA\n         TM    11(R1),X'03'\n         BNZ   ERSA\n         L     R9,8(R1)\n         LA    R9,0(R9)\nGADD     L     R8,4(R1)\n         LA    R8,0(R8)\n         L     R7,0(R1)\n         LA    R7,0(R7)\n         MVC   0(8,R8),=CL8' '\n         L     R2,=A(DAUTTB)       GET UNIT TYPE TABLE ADDRESS.\nLOOP     CLI   0(R2),X'FF'         END OF TABLE?\n         BE    NOTFND              YES.\n         CLC   0(1,R7),0(R2)       IS THIS TYPE?\n         BE    FOUND               YES.\n         LA    R2,10(R2)           POINT TO NEXT.\n         B     LOOP\nFOUND    IC    R0,1(R2)            GET TRUE LENGTH.\n         MVC   0(8,R8),2(R2)       SET UNIT TYPE.\n         B     LEAVE\nNOTFND   LA    R10,4\n         B     LEAVE\nERSA     LA    R10,8\nLEAVE    L     R7,4(R13)\n         ST    R0,20(R7)           SET REGISTER 0.\n         LTR   R9,R9\n         BZ    EXIT\n         ST    R10,0(R9)           STORE INDICATOR.\nEXIT    $XRET  CC=(R10)\n         SPACE 2\n        LTORG\n         SPACE 2\n         ENTRY DAUTTB\n         SPACE 1\nDAUTTB   DS    0F                  UNIT TYPES TABLE.\n         DC    XL1'01',AL1(4),CL8'2311'\n         DC    XL1'02',AL1(4),CL8'2301'\n         DC    XL1'03',AL1(4),CL8'2303'\n         DC    XL1'04',AL1(4),CL8'2302'\n         DC    XL1'05',AL1(4),CL8'2321'\n         DC    XL1'06',AL1(6),CL8'2305-1'\n         DC    XL1'07',AL1(6),CL8'2305-2'\n         DC    XL1'08',AL1(4),CL8'2314'\n         DC    XL1'09',AL1(4),CL8'3330'\n         DC    XL1'0A',AL1(4),CL8'3340'\n         DC    XL1'0B',AL1(4),CL8'3350'\n         DC    XL1'0C',AL1(4),CL8'3375'\n         DC    XL1'0D',AL1(6),CL8'3330-1'\n         DC    XL1'0E',AL1(4),CL8'3380'\n         DC    X'FF',AL1(0)        END OF TABLE.\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DAUNTY$": {"ttr": 11796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//DAUNTY   JOB (........),'INSTALL  - DAUNTY -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS3,MBR=DAUNTY\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ENTRY   DAUNTY\n  ALIAS   DAUTTB\n  NAME    DAUNTY(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DAUNTY@": {"ttr": 12034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      DAUNTY    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       DIRECT-ACCESS UNIT TYPE.      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL DAUNTY,(A,B,C),VL\n  ------------------             (A,B)\n\n         Where : A - is the address of a one byte field containing\n                     a direct-access type (hexadecimal format, like\n                     in UCBTBYT4).\n\n                 B - is the address of an eigth bytes field receiving\n                     the corresponding unit type right padded with\n                     blanks (the true length is passed back in the\n                     register 0).\n\n                 C - receives the return code (format FULLWORD -\n                     F boundary) if supplied (optional).\n\n         Return codes (register 15) :\n\n                         0 = normal.\n                         4 = invalid direct-access type.\n                         8 = calling sequence or parameter alignment\n                             error.\n\n  Assembler macro : $DAUNTY A,B,C\n  -----------------\n\n         Where C is optional and may be omitted.\n         Register use may be coded within parentheses.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAVALL": {"ttr": 12036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x1f\\x00\\x88\\t\\x1f\\x146\\x01\\x08\\x01\\x08\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-31T00:00:00", "modifydate": "1988-03-31T14:36:00", "lines": 264, "newlines": 264, "modlines": 0, "user": "SYSPAJA"}, "text": "DAVA     TITLE 'DIRECT ACCESS VOLUME ALLOCATION SUBROUTINE.'\nDAVALL   START 0\n         SPACE 1\n         ENTRY DAVFR\n         SPACE 1\n* CALLING SEQUENCE : CALL DAVALL,(A,B,C,D),VL\n* ------------------             (A,B,C)\n*\n*        WHERE : A - IS THE ADDRESS OF A FIELD CONTAINING IN THE FIRST\n*                    BYTE THE TRUE LENGTH OF THE FOLLOWING ITEM WHICH\n*                    MUST BE THE DESIRED DD-NAME TO BE USED FOR\n*                    ALLOCATION (FORMAT XL1,CL...).\n*\n*                B - IS THE ADDRESS OF A FIELD CONTAINING THE VOLUME\n*                    SERIAL NUMBER OF AN ONLINE AND READY DIRECT-ACCESS\n*                    UNIT TO BE ALLOCATED (FORMAT CL6).\n*\n*                C - IS THE ADDRESS OF A FIELD CONTAINING IN THE FIRST\n*                    BYTE THE TRUE LENGTH OF THE FOLLOWING ITEM WHICH\n*                    MUST BE THE VOLUME DIRECT-ACCESS UNIT TYPE\n*                    (FORMAT XL1,CL...).\n*\n*                D - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                    F BOUNDARY) IF SUPPLIED (OPTIONAL).\n*\n* CALLING SEQUENCE : CALL DAVFR,(A,B),VL\n* ------------------            (A)\n*\n*        WHERE : A - IS THE ADDRESS OF A FIELD CONTAINING IN THE FIRST\n*                    BYTE THE TRUE LENGTH OF THE FOLLOWING ITEM WHICH\n*                    MUST BE THE DESIRED DD-NAME TO BE USED FOR\n*                    ALLOCATION (FORMAT XL1,CL...).\n*\n*                B - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                    F BOUNDARY) IF SUPPLIED (OPTIONAL).\n         EJECT\n* RETURN CODES (REGISTER 15) :\n* ----------------------------\n*\n*                 0 = NORMAL.\n*                 4 = A TRUE LENGTH IS IN ERROR.\n*                 8 = CALLING SEQUENCE OR PARAMETER ALIGNMENT ERROR.\n*                12 = DYNAM (SVC 99) ERROR. REGISTER 1 POINTS TO A\n*                     DIAGNOSE MESSAGE AS BELOW :\n*                                     ...\n*                                     LA    R1,DIAGMSG\n*                                     ...\n*                                     DC    AL1(L'DIAGMSG)\n*                            DIAGMSG  DC    C'0     ... '\n*                                     ...\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 2\n        $DEFREG\n         EJECT\n         USING *,R15\n         MVI   WTGO+3,COMMON-*     SET DAVALL ENTRY ---------- 1.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nDAVFR    MVI   WTGO+3,COMMON-*     SET DAVFR ENTRY ----------- 0.\n         DROP  R15\nWTGO     LA    R15,*-*(R15)        SET COMMON ENTRY ADDRESS.\n         SPACE 1\nCOMMON  $XENT  BASE=R12,ID=DAVALL\n         LR    R15,R12             COMPUTE ENTRY SWITCH.\n         BCTR  R15,0\n         SR    R5,R5\n         IC    R5,0(R15)\n         SRL   R5,4\n         EJECT\n         SR    R6,R6               CONTROL PARAMETERS.\n         SR    R7,R7\n         SR    R8,R8\n         SR    R9,R9\n         SR    R10,R10\n         LTR   R5,R5               WHICH ENTRY?\n         BNZ   GAVA                BRANCH IF ALLOCATE.\n         TM    0(R1),X'80'\n         BO    GAFR\n         TM    4(R1),X'80'\n         BZ    ERSA\n         TM    7(R1),X'03'\n         BNZ   ERSA\n         L     R9,4(R1)\n         LA    R9,0(R9)\n         B     GAFR\nGAVA     TM    0(R1),X'80'\n         BO    ERSA\n         TM    4(R1),X'80'\n         BO    ERSA\n         TM    8(R1),X'80'\n         BO    GADD\n         TM    12(R1),X'80'\n         BZ    ERSA\n         TM    15(R1),X'03'\n         BNZ   ERSA\n         L     R9,12(R1)\n         LA    R9,0(R9)\nGADD     L     R8,8(R1)\n         LA    R8,0(R8)\n         L     R7,4(R1)\n         LA    R7,0(R7)\nGAFR     L     R6,0(R1)\n         LA    R6,0(R6)\n         SR    R1,R1               PICK UP PARAMETERS.\n         IC    R1,0(R6)\n         LTR   R1,R1\n         BZ    ERTR\n         CH    R1,=H'8'\n         BH    ERTR\n         STCM  R1,B'0011',DDLN     SET DDNAME LENGTH.\n         BCTR  R1,0\n         EX    R1,DDNMOVE          SET DDNAME.\n         LTR   R5,R5               WHICH ENTRY?\n         BZ    CFREE               BRANCH IF FREE.\n         MVC   VOLSER(L'VOLSER),0(R7)   SET VOLUME SERIAL.\n         SR    R1,R1\n         IC    R1,0(R8)\n         LTR   R1,R1\n         BZ    ERTR\n         CH    R1,=H'8'\n         BH    ERTR\n         STCM  R1,B'0011',UNLN     SET UNIT NAME LENGTH.\n         BCTR  R1,0\n         EX    R1,UNMOVE           SET UNIT NAME.\n         EJECT\nCFREE    XC    FREEERC(L'FREEERC+L'FREEINFO),FREEERC\n         LA    R1,FREEPTR\n        DYNALLOC                   FREE DDNAME.\n         LTR   R5,R5               WHICH ENTRY?\n         BNZ   CALLOC              BRANCH IF ALLOCATE.\n         LTR   R15,R15             ANY PROBLEMS?\n         BNZ   ERFREE              YES, GO REPORT IT.\n         B     LEAVE\nCALLOC   LTR   R15,R15             ANY PROBLEMS?\n         BZ    OKFREE              NO, CONTINUE.\n         CH    R15,=H'4'           ENVIRONMENTAL ERROR?\n         BNE   ERFREE              NO, GO REPORT PROBLEMS.\n         CLC   FREEERC(L'FREEERC+L'FREEINFO),=XL4'04380000'\n         BNE   ERFREE              REPORT IF NOT 'DDNAME NOT FOUND'.\nOKFREE   XC    ALLERC(L'ALLERC+L'ALLINFO),ALLERC\n         LA    R1,ALLPTR\n        DYNALLOC                   ALLOCATE VOLUME.\n         LTR   R15,R15             ANY PROBLEMS?\n         BNZ   ERALLOC             YES, GO REPORT IT.\n         B     LEAVE\nDDNMOVE  MVC   DDNM(*-*),1(R6)\nUNMOVE   MVC   UNNM(*-*),1(R8)\n         EJECT\nERTR     LA    R10,4\n         B     LEAVE\nERSA     LA    R10,8\n         B     LEAVE\nERFREE   MVC   NAME,FREEM\n         ICM   R1,B'1111',FREEERC\n         B     SETRC\nERALLOC  MVC   NAME,ALLOCM\n         ICM   R1,B'1111',ALLERC\nSETRC    LA    R0,L'RC15\n         LA    R2,RC15+L'RC15-1\nLRC15    STC   R15,0(R2)\n         SRL   R15,4\n         BCTR  R2,0\n         BCT   R0,LRC15\n         NC    RC15(L'RC15),=XL8'0F0F0F0F0F0F0F0F'\n         TR    RC15(L'RC15),=C'0123456789ABCDEF'\n         LA    R0,L'INFO\n         LA    R2,INFO+L'INFO-1\nLINFO    STC   R1,0(R2)\n         SRL   R1,4\n         BCTR  R2,0\n         BCT   R0,LINFO\n         NC    INFO(L'INFO),=XL8'0F0F0F0F0F0F0F0F'\n         TR    INFO(L'INFO),=C'0123456789ABCDEF'\n         LA    R0,L'ERC\n         LA    R2,ERC+L'ERC-1\nLERC     STC   R1,0(R2)\n         SRL   R1,4\n         BCTR  R2,0\n         BCT   R0,LERC\n         NC    ERC(L'ERC),=XL8'0F0F0F0F0F0F0F0F'\n         TR    ERC(L'ERC),=C'0123456789ABCDEF'\n         LA    R1,ERMSG\n         L     R2,4(R13)\n         ST    R1,24(R2)           GIVE BACK MESSAGE ADDRESS.\n         LA    R10,12\nLEAVE    LTR   R9,R9\n         BZ    EXIT\n         ST    R10,0(R9)           STORE INDICATOR.\nEXIT    $XRET  CC=(R10)\n         EJECT\n*        DYNAMIC ALLOCATION REQUEST BLOCK TO ALLOCATE VOLUME.\n         SPACE 1\nALLPTR   DC    A(X'80000000'+ALLRB)     RB POINTER.\nALLRB    DC    AL1(ALLRBL)         LENGTH OF RB.\n         DC    AL1(S99VRBAL)       VERB CODE - ALLOCATION.\n         DC    AL1(S99NOMNT,0)     FLAGS.\nALLERC   DC    XL2'0'              ERROR REASON CODE.\nALLINFO  DC    XL2'0'              INFORMATION REASON CODE.\n         DC    A(ALLTXP)           ADDR OF LIST OF TEXT UNIT PTRS.\n         DC    F'0'                RESERVED.\n         DC    F'0'                FLAGS.\nALLRBL   EQU   *-ALLRB             RB LENGTH.\n         SPACE 1\n*        DYNAMIC ALLOCATION REQUEST BLOCK TO FREE DDNAME.\n         SPACE 1\nFREEPTR  DC    A(X'80000000'+FREERB)    RB POINTER.\nFREERB   DC    AL1(FREERBL)        LENGTH OF RB.\n         DC    AL1(S99VRBUN)       VERB CODE - UNALLOCATION.\n         DC    AL1(0,0)            FLAGS.\nFREEERC  DC    XL2'0'              ERROR REASON CODE.\nFREEINFO DC    XL2'0'              INFORMATION REASON CODE.\n         DC    A(FREETXP)          ADDR OF LIST OF TEXT UNIT PTRS.\n         DC    F'0'                RESERVED.\n         DC    F'0'                FLAGS.\nFREERBL  EQU   *-FREERB            RB LENGTH.\n         SPACE 1\n*        SVC 99 TEXT UNIT POINTER LISTS.\n         SPACE 1\nALLTXP   DC    A(DDTU)             ADDRESS OF DDNAME TEXT UNIT.\n         DC    A(VOLTU)            ADDRESS OF VOLSER TEXT UNIT.\n         DC    A(UNITTU)           ADDRESS OF UNIT NAME TEXT UNIT.\n         DC    A(X'80000000'+DISPTU) ADDRESS OF DISP TEXT UNIT (LAST).\n         SPACE 1\nFREETXP  DC    A(DDTU)             ADDRESS OF DDNAME TEXT UNIT.\n         DC    A(X'80000000'+UNALTU) ADDR. OF UNALL. TEXT UNIT (LAST).\n         SPACE 1\n*        SVC 99 TEXT UNITS.\n         SPACE 1\nDDTU     DC    0H'0',AL2(DALDDNAM,1)    (= DUNDDNAM).\nDDLN     DC    H'8'                LENGTH OF DDNAME.\nDDNM     DC    CL8' '              DDNAME.\nVOLTU    DC    0H'0',AL2(DALVLSER,1,6)\nVOLSER   DC    CL6' '              VOLUME SERIAL.\nUNITTU   DC    0H'0',AL2(DALUNIT,1)\nUNLN     DC    H'8'                LENGTH OF UNIT NAME.\nUNNM     DC    CL8' '              UNIT NAME.\nDISPTU   DC    0H'0',AL2(DALSTATS,1,1),X'01' OLD.\nUNALTU   DC    0H'0',AL2(DUNUNALC,0)    UNALLOC EVEN IF PERM ALLOC.\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\n         DC    AL1(ERMSGL)\nERMSG    DC    CL6'0 ',C'DYNAM '\nNAME     DC    CL4' ',C' FAILED : R15 = X'''\nRC15     DC    CL8' ',C''', ERC = X'''\nERC      DC    CL4' ',C''', INFO = X'''\nINFO     DC    CL4' ',C'''.'\nERMSGL   EQU   *-ERMSG\nALLOCM   DC    CL4'ALL.'\nFREEM    DC    CL4'FREE'\n         SPACE 1\n        LTORG\n         SPACE 2\n        PRINT  NOGEN\n        IEFZB4D0\n        IEFZB4D2\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DAVALL$": {"ttr": 12041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x1f\\x00\\x88\\t\\x1f\\x14E\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-31T00:00:00", "modifydate": "1988-03-31T14:45:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//DAVALL   JOB (........),'INSTALL  - DAVALL -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS3,MBR=DAVALL\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   DAVFR\n  NAME    DAVALL(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DAVALL@": {"ttr": 12043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00D\\x00D\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      DAVALL    1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *  DIRECT-ACCESS VOLUME ALLOCATION.   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL DAVALL,(A,B,C,D),VL\n  ------------------             (A,B,C)\n\n         Where : A - is the address of a field containing in the fisrt\n                     byte the true length of the following item which\n                     must be the desired DD-name to be used for DD\n                     allocation (format XL1,CL...).\n\n                 B - is the address of a field containing the volume\n                     serial number of an online and ready direct-access\n                     unit to be allocated (format CL6).\n\n                 C - is the address of a field containing in the fisrt\n                     byte the true length of the following item which\n                     must be the volume direct-access unit type\n                     (format XL1,CL...).\n\n                 D - receives the return code (format FULLWORD -\n                     F boundary) if supplied (optional).\n\n  Assembler macro : $DAVALL A,B,C,D\n  -----------------\n\n         Where D is optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  Calling sequence : CALL DAVFR,(A,B),VL\n  ------------------            (A)\n\n         Where : A - is the address of a field containing in the first\n                     byte the true length of the following item which\n                     must be the desired DD-name to be used to free DD\n                     allocation (format XL1,CL...).\n\n                 B - receives the return code (format FULLWORD -\n                     F boundary) if supplied (optional).\n\n  Assembler macro : $DAVFR A,B\n  -----------------\n\n         Where B is optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/09/85\n                                                      DAVALL    2/2.\n\n  Return codes (register 15) :\n  ----------------------------\n\n                  0 = normal.\n                  4 = a true length is in error.\n                  8 = calling sequence or parameter alignment error.\n                 12 = DYNAM (svc 99) error. Register 1 points to a\n                      diagnose message as below :\n                                      ...\n                                      LA    R1,DIAGMSG\n                                      ...\n                                      DC    AL1(L'DIAGMSG)\n                             DIAGMSG  DC    C'0     ... '\n                                      ...\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DECONCA$": {"ttr": 12045, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14\\x01\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:01:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "//DECONCAT JOB (........),'INSTALL - DECONCAT -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=3\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=DECONCAT\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   DECONCAT\n  ALIAS   DECAT\n  NAME    DECONCAT(R)\n/*\n//HLP     EXEC PAJHELP,MBR=DECONCAH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DECONCA@": {"ttr": 12047, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x12$\\x00)\\x00)\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T12:24:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/07/90\n                                                      DECONCAT  1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        DECONCAT TSO command         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Command name :      DECONCAT\n  Author :            GSFTSOCC, Version 1.0, Gene Czarcinski, 09 JUN 73\n                      DECONCAT, Version 1.1, Gene Czarcinski, 10 APR 77\n                      Rename CSECT from GSFTSODC to DECONCAT (more\n                      consistancy and cleaner CMDLIB).\n  Origin :            Extracted from tape CBT 89 FEB, file 300\n                      Adapted by MOINIL P.A.\n  Function :          The DECONCAT command deconcatenates files which\n                      were previously dynamically concatenated.\n                      Dynamic concatenation can be performed by the\n                      CONCAT command.\n\n  Syntax :\n  --------------------------------------------------------------------\n  Command    Operands\n  --------------------------------------------------------------------\n  DECONCAT   'filename'\n  DECAT\n  --------------------------------------------------------------------\n  Command alias : DECAT\n\n  Operands :\n     Required - 'filename'\n     Default  - None\n\n     'filename' = The (PRIME) name previously specified on a CONCAT\n                           command.\n              Example :\n                 DECONCAT DD1\n\n  Return codes :  0 - deconcatenation successfully done.\n                 12 - severe error encountered.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DECONCAH": {"ttr": 12049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x11Y\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T11:59:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=DECONCAT\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  the DECONCAT command deconcatenates files which were\n               previously dynamically concatenated. Dynamic\n               concatenation can be performed by the CONCAT command.\n)X SYNTAX :    DECONCAT 'FILENAME'\n               Alias    - DECAT\n               Example : DECONCAT DD1\n)O OPERANDS :  Required - 'FILENAME'\n               Default  - None\n))FILENAME  :  The (PRIME) name previously specified on a CONCAT\n               command.\n./     ALIAS   NAME=DECAT\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DECONCAT": {"ttr": 12051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\x11)\\x00\\x9e\\x00\\x9e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T11:29:00", "lines": 158, "newlines": 158, "modlines": 0, "user": "SYSPAJA"}, "text": "DCAT     TITLE 'NASA/GSFC -- DECONCAT (TSO) COMMAND PROCESSOR.'\nDECONCAT START 0\n         SPACE 1\n* PURPOSE :    THIS IS A TSO COMMAND PROCESSOR DESIGNED TO PERFORM\n* ---------    DECONCATENATION OF DYNAMICALLY CONCATENTATED FILES.\n*              'IKJDAIR' IS USED TO PERFORM ACTUAL DECONCATENATION.\n*              TO EXECUTE THIS CP, ONLY THE PRIME FILENAME/DDNAME\n*              CAN AND SHOULD BE SPECIFIED. ONCE DECONCATENATED, THE\n*              ORIGINAL FILENAMES ARE RESTORED AND AGAIN AVAILABLE.\n* ORIGIN :     EXTRACTED FROM TAPE CBT 89 FEB, FILE 300.\n* --------     GSFTSODC, VERSION 1.0, GENE CZARCINSKI, 09JUN73\n*              DECONCAT, VERSION 1.1, GENE CZARCINSKI, 10APR77\n*              - RENAME CSECT FROM 'GSFTSODC' TO 'DECONCAT'\n*                (MORE CONSISTANCY AND CLEANER CMDLIB)\n*              - ADAPTED BY MOINIL P.A.\n* ATTRIBUTES : RENT\n* ------------\n* ALIAS :      DECAT\n* -------\n         SPACE 1\nDECONCAT AMODE 24\nDECONCAT RMODE 24\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=@SIZE,SP=1,TYPE=RENT\n         LR    R11,R13\n         USING @STORAGE,R11        STORAGE BASE REGISTER\n         LR    R9,R1\n        $TEW$EC REG=R9,MSG=PUTMSG,ERR=QUIT\n         USING CPPL,R9             SET CPPL ADDRESSABILITY\n         XC    RCODE,RCODE         RC=0 -------------------------------\n         XC    ECB,ECB\n         LA    R1,PL1              INIT FOR TERM I/O\n         USING IOPL,R1\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         LA    R0,ECB\n         ST    R0,IOPLECB\n         LA    R1,PL2              INIT FOR COMMAND PARSE\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         LA    R0,ECB\n         ST    R0,PPLECB\n         MVC   PPLPCL,=A($PARSEDC)\n         LA    R0,APDL\n         ST    R0,PPLANS\n         MVC   PPLCBUF,CPPLCBUF\n         XC    PPLUWA,PPLUWA\n         LA    R1,PL3              INIT PL FOR DAIR\n         USING DAPL,R1\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         MVC   DAPLPSCB,CPPLPSCB\n         LA    R0,ECB\n         ST    R0,ECB\n         LA    R5,PL4              A(DAPB)\n         ST    R5,DAPLDAPB\n         DROP  R1\n         USING DAPB10,R5\n         XC    PL4(16),PL4\n         MVI   DA10CD+1,X'10'      FOR DECONCATENATE\n*------- PARSE THE COMMAND OPERANDS\n        CALLTSSR EP=IKJPARS,MF=(E,PL2)\n         LTR   R15,R15             PARSE OK?\n         BZ    PARSE1              YES.\nPARSE0   LA    R2,MSG0             BAD PARSE... ISSUE MSG & ABORT\n         B     PUTLNE\nPARSE1   L     R2,APDL             GOOD PARSE\n         USING @PDL,R2\n         MVI   DA10DDN,C' '        CLEAR DDNAME AREA\n         MVC   DA10DDN+1(7),DA10DDN\n         L     R15,#NAME           PNTR TO DDNAME\n         LTR   R15,R15             SPECIFIED?\n         BZ    PARSE0              NO, BAD\n         LH    R1,#NAME+4          LENGTH OF DDNAME\n         LTR   R1,R1\n         BZ    PARSE0\n         LA    R14,DA10DDN\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R14),0(R15)   <<EXECUTED>>\n         EX    R1,*-6\n*------- INVOKE DAIR TO DECONCATENATE\n        CALLTSSR EP=IKJDAIR,MF=(E,PL3)\n         LTR   R15,R15             OK?\n         BZ    DONE1               RC=0, YES.\n         CVD   R15,WORK            RC\u00ac=0, BAD\n         OI    WORK+7,X'0F'\n         MVC   MSGA(MSG1L),MSG1\n         UNPK  MSGA+(MSG1A-MSG1)(L'MSG1A),WORK\n         UNPK  WORK(5),DA10DARC(3)\n         MVZ   WORK(4),=XL4'0'\n         TR    WORK(4),=C'0123456789ABCDEF'\n         MVC   MSGA+(MSG1B-MSG1)(L'MSG1B),WORK\n         LA    R2,MSGA\n*------- OUTPUT ERROR MSG\nPUTLNE  PUTLINE PARM=PTPB,OUTPUT=(0(R2),TERM,SINGLE,DATA),             X\n               TERMPUT=(EDIT,WAIT,NOHOLD),MF=(E,PL1)\n         MVI   RCODE+1,12          RC=12 ------------------------------\nDONE1    CLI   PL2+(PPLANS-PPL),X'FF'\n         BE    DONE2\n         L     R1,PL2+(PPLANS-PPL)\n        IKJRLSA (1)\nDONE2    CLI   RCODE+1,12\n         BNE   DONE3\n        STACK  PARM=STPB,DELETE=ALL,MF=(E,PL1)\n        TCLEARQ INPUT\nDONE3    LH    R2,RCODE\n         B     LEAVE\nQUIT     LA    R2,12               RC=12 ------------------------------\nLEAVE   $XRET  CC=(R2),LV=@SIZE,SP=1,TYPE=RENT\n         EJECT\n*------- CONSTANTS\n         SPACE 1\nMSG0     DC    0F'0',Y(MSG0L,0),C'  ERROR PARSING COMMAND'\n         DC    C' OPERAND, EXECUTION SUPPRESSED.'\nMSG0L    EQU   *-MSG0\nMSG1     DC    0F'0',Y(MSG1L,0),C'  DECONCATENATION ERROR, DAIR RC='\nMSG1A    DC    CL2' ',C', DARC='\nMSG1B    DC    CL4' ',C'.'\nMSG1L    EQU   *-MSG1\n         SPACE 1\n        LTORG\n         SPACE 1\n        PRINT  NOGEN\n$PARSEDC IKJPARM DSECT=@PDL\n#NAME    IKJIDENT 'FILENAME',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM,     X\n               PROMPT='FILENAME/DDNAME FOR DECONCATENATION'\n         IKJENDP\n        PRINT  GEN\n         EJECT\n@STORAGE DSECT\n         DS    18F                 S.A.\nWORK     DS    D\n        $TEW$WA\nECB      DS    F\nAPDL     DS    A\nPTPB    PUTLINE MF=L\nSTPB    STACK  MF=L\nPL1      DS    7F                  IOPL\nPL2      DS    7F                  PPL\nPL3      DS    5F                  DAPL\nPL4      DS    4F                  DAPB10\nMSGA     DS    0F,H,H,CL100\nRCODE    DS    H\n         SPACE 1\n@SIZE    EQU   (((*-@STORAGE)+7)/8)*8\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS CVT=YES\n        IKJIOPL\n        IKJPPL\n        IKJDAPL\n        IKJDAP10\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DECRYPT": {"ttr": 12292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x10!\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T10:21:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM) NOPROCESS\n/*  MACRO NAME : DECRYPT                                            */\n/*    FUNCTION : DATA DECRYPTION (CRY INVOKER)                      */\n/*      SYNTAX : DECRYPT                                            */\n/*               DECRYPT HELP OR H                                  */\n/*      AUTHOR : MOINIL P.A                                         */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(HELP) OR +\n      &STR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTEDCR)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ISREDIT !CRY D\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DTSO": {"ttr": 12294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07O\\x00\\x95\\x07O\\x16\\x15\\x02\\xf2\\x02\\xf2\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-15T00:00:00", "modifydate": "1995-03-15T16:15:00", "lines": 754, "newlines": 754, "modlines": 0, "user": "SYSPAJA"}, "text": "DTSO     TITLE 'DTSO -- DISPLAY SOME CONTROL BLOCKS TSO-COMMAND.'\nDTSO     START 0\n         SPACE 1\n*--------------------------------------------------------------------*\n*                              D T S O                               *\n*--------------------------------------------------------------------*\n* COMMAND :    DTSO                                                  *\n* OPERANDS :   UPT ECT PSCB                                          *\n*              REQUIRED : NONE                                       *\n*              DEFAULT  : UPT IF NONE IS SPECIFIED                   *\n* RETURN CODES :  0 - SUCCESSFULL                                    *\n*                16 - ERROR                                          *\n* ATTRIBUTES : RENT                                                  *\n* AUTHOR :     MOINIL P.A.                                           *\n*              COMPUTING CENTRE (TP361)                              *\n*              J.R.C. - ISPRA ESTABLISHMENT                          *\n*              21020 ISPRA (VA), ITALY                               *\n*--------------------------------------------------------------------*\n         SPACE 1\nDTSO     AMODE 24\nDTSO     RMODE 24\n         PRINT NOGEN\n         SPACE 1\n        $DEFREG\n*------- REGISTERS USE :\n*        R8  = COMMAND RETURN CODE\n*        R9  = LOCAL LINK RETURN ADDRESS\n*        R10 = LOCAL LINK ADDRESS / LOCAL BASE REGISTER\n*        R11 = WORK AREAS POINTER\n*        R12 = GENERAL BASE REGISTER\n*        R13 = SAVE AREA POINTER\n*        R14 = LINK RETURN ADDRESS\n*        R15 = LINK ADDRESS / RETURN CODE\n         SPACE 1\nWASIZE   EQU   512            CONTROL BLOCKS WORK-AREA SIZE IN BYTES\n*                             (MUST BE LARGE ENOUGH TO HANDLE ALL\n*                              DSECT'S THE LIST IS DONE BELOW)\n         EJECT\n        $XENT  BASE=R12,LV=WKLEN,TYPE=RENT\n         LR    R11,R13\n         USING WKAREA,R11\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n         MVI   SWREQS,0\n        $TEW$PP PARM=PARMLST,REG=R3\n         CLC   KWUPT(2),=H'2'\n         BNE   *+L'*+4\n         OI    SWREQS,RQUPT\n         CLC   KWECT(2),=H'2'\n         BNE   *+L'*+4\n         OI    SWREQS,RQECT\n         CLC   KWPSCB(2),=H'2'\n         BNE   *+L'*+4\n         OI    SWREQS,RQPSCB\n         DROP  R3\n        IKJRLSA #TSANSW            RELEASE PDL'S SPACE\n         CLI   SWREQS,0            ANY REQUESTS ?\n         BNE   *+L'*+4             YES\n         OI    SWREQS,RQUPT        NO, SET DEFAULT TO UPT\n         TM    SWREQS,RQUPT\n         BZ    *+L'*+6\n         L     R10,=A(PUPTL)\n         BASR  R9,R10              LIST UPT\n         TM    SWREQS,RQECT\n         BZ    *+L'*+6\n         L     R10,=A(PECTL)\n         BASR  R9,R10              LIST ECT\n         TM    SWREQS,RQPSCB\n         BZ    *+L'*+6\n         L     R10,=A(PPSCBL)\n         BASR  R9,R10              LIST ECT\n         XR    R8,R8               SET RC=0 ----------------------   0\nLEAVE   $XRET  CC=(R8),LV=WKLEN,TYPE=RENT\nSETRC    LA    R8,16               SET RC=16 ---------------------  16\n         B     LEAVE\n         EJECT\n*------- OVRFLW - WORK-AREA OVERFLOW ROUTINE.\n*              R9 : RETURN ADDRESS.\n* ON ENTRY --- R0 : IDENTIFIER NUMBER.\n*              R1 : CONTROL BLOCK LENGTH.\n         SPACE 1\nOVRFLW   LTR   R0,R0\n         BM    *+L'*+12\n         BZ    *+L'*+14\n         CH    R0,TBIDN\n         BNH   *+L'*+2\n         XR    R0,R0\n         SLL   R0,2\n         CVD   R1,DBLWRD\n         LA    R1,TBID\n         ALR   R1,R0\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE(4),0(R1)\n         MVC   WKLINE+5(9),=CL9'(LENGTH :'\n         MVC   WKLINE+14(8),=XL8'4020202020202120'\n         ED    WKLINE+14(8),DBLWRD+4\n         MVC   WKLINE+22(26),=CL26') -- WORK-AREA OVERFLOW --'\n         LA    R0,48\n         LA    R1,WKLINE\nGOBACK   BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     0(R9)               +0 - RETURN\n         B     SETRC               +4 - ERROR\nCHECK    B     *+L'*(R15)          HOW COMPLETE ?\n         B     0(R14)              +0 - RETURN\n         B     SETRC               +4 - ERROR\n         SPACE 1\nWALTSZ   DC    A(WASIZE)\nTBHEX    DC    CL16'0123456789ABCDEF'\nTBID     DC    CL4'????',C'UPT ECT PSCB'\nTBIDN    DC    Y(((*-TBID)-4)/4)\n         SPACE 1\n        LTORG\n         EJECT\n*------- DISPLAY USER PROFILE TABLE (UPT)\n         SPACE 1\n         CNOP  0,4\n         USING *,R10\nPUPTL    LM    R0,R1,=A(1,UPTLEN)  CHECK UPT LENGTH\n         CL    R1,WALTSZ\n         BH    OVRFLW              WORK-AREA TOO SMALL\n         L     R2,#TSCPPL          CPPL ADDRESS\n         USING CPPL,R2\n         L     R0,CPPLUPT          UPT ADDRESS\n         LA    R4,CTLBWA           WORK-AREA ADDRESS\n         LR    R5,R1\n         MVCL  R4,R0\n         L     R3,CPPLPSCB         PSCB ADDRESS\n         DROP  R2\n         USING PSCB,R3\n         XR    R1,R1\n         IC    R1,PSCBUSRL         USER-ID LENGTH\n         BCT   R1,*+L'*+6\n         MVC   WKLINE(*-*),PSCBUSER USER-ID\n         EX    R1,*-6\n         DROP  R3\n         LA    R1,WKLINE+1(R1)\n         MVC   0(27,R1),=CL27' USER PROFILE TABLE (UPT) :'\n         LA    R1,27(R1)\n         LA    R0,WKLINE\n         SLR   R1,R0\n         XR    R0,R1\n         XR    R1,R0\n         XR    R0,R1\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         LA    R4,CTLBWA           WORK-AREA ADDRESS\n         USING UPT,R4\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         UNPK  WKLINE+2(5),0(3,R4)\n         TR    WKLINE+2(4),TBHEX-X'F0'\n         MVI   WKLINE+6,C' '\n         XR    R15,R15\n         LA    R0,L'UPTUSER\n         LA    R1,UPTUSER\n         LA    R2,WKLINE+7\nPUPTP    IC    R15,0(R1)\n         STC   R15,1(R2)\n         NI    1(R2),X'0F'\n         SRL   R15,4\n         STC   R15,0(R2)\n         LA    R2,2(R2)\n         LA    R1,1(R1)\n         BCT   R0,PUPTP\n         TR    WKLINE+7(2*L'UPTUSER),TBHEX\n         UNPK  WKLINE+(2*L'UPTUSER)+8(3),UPTSWS(2)\n         TR    WKLINE+(2*L'UPTUSER)+8(2),TBHEX-X'F0'\n         MVI   WKLINE+(2*L'UPTUSER)+10,C' '\n         UNPK  WKLINE+(2*L'UPTUSER)+11(3),UPTCDEL(2)\n         TR    WKLINE+(2*L'UPTUSER)+11(2),TBHEX-X'F0'\n         MVI   WKLINE+(2*L'UPTUSER)+13,C' '\n         UNPK  WKLINE+(2*L'UPTUSER)+14(3),UPTLDEL(2)\n         TR    WKLINE+(2*L'UPTUSER)+14(2),TBHEX-X'F0'\n         MVI   WKLINE+(2*L'UPTUSER)+16,C' '\n         UNPK  WKLINE+(2*L'UPTUSER)+17(3),UPTLDEL+1(2)\n         TR    WKLINE+(2*L'UPTUSER)+17(2),TBHEX-X'F0'\n         MVI   WKLINE+(2*L'UPTUSER)+19,C' '\n         UNPK  WKLINE+(2*L'UPTUSER)+20((2*L'UPTPREFX)+1),UPTPREFX(L'UPTX\n               PREFX+1)\n         TR    WKLINE+(2*L'UPTUSER)+20(2*L'UPTPREFX),TBHEX-X'F0'\n         MVI   WKLINE+(2*L'UPTUSER)+(2*L'UPTPREFX)+20,C' '\n         UNPK  WKLINE+(2*L'UPTUSER)+(2*L'UPTPREFX)+21(3),UPTPREFL(2)\n         TR    WKLINE+(2*L'UPTUSER)+(2*L'UPTPREFX)+21(2),TBHEX-X'F0'\n         MVI   WKLINE+(2*L'UPTUSER)+(2*L'UPTPREFX)+23,C' '\n         LA    R0,L'WKLINE\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(4),=CL4'++++'\n         MVC   WKLINE+7(2*L'UPTUSER),=CL20'<<INSTALLATION-USE>>'\n         MVC   WKLINE+(2*L'UPTUSER)+8(12),=CL12'SW DC LD ++'\n         MVC   WKLINE+(2*L'UPTUSER)+20(17),=CL17'<<<<PREFIX>>>> L'''\n         LA    R0,L'WKLINE\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(21),=CL21'(NOTE : + = RESERVED)'\n         XR    R1,R1\n         IC    R1,UPTPREFL\n         LTR   R1,R1\n         BP    *+L'*+10\n         MVC   WKLINE+40(8),=CL8'NOPREFIX'\n         B     PUPTN\n         MVC   WKLINE+40(8),=CL8'PREFIX('''\n         BCT   R1,*+L'*+6\n         MVC   WKLINE+48(*-*),UPTPREFX <<EXECUTED>>\n         EX    R1,*-6              PREFIX\n         LA    R1,WKLINE+49(R1)\n         MVC   0(2,R1),=CL2''')'\nPUPTN    LA    R0,L'WKLINE\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(14),=CL14'ENV.SW : BIT-0'\n         MVC   WKLINE+26(5),=CL5'BIT-1'\n         MVC   WKLINE+41(5),=CL5'BIT-2'\n         MVC   WKLINE+56(5),=CL5'BIT-3'\n         LA    R0,L'WKLINE\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         TM    UPTSWS,UPTRCVR      EDIT RECOVER ?\n         BO    *+L'*+10\n         MVC   WKLINE+11(L'KNREC),KNREC\n         B     *+L'*+6\n         MVC   WKLINE+11(L'KNREC-2),KNREC+2\n         TM    UPTSWS,UPTNPRM      NOPROMPT ?\n         BO    *+L'*+10\n         MVC   WKLINE+26(L'KNPRP-2),KNPRP+2\n         B     *+L'*+6\n         MVC   WKLINE+26(L'KNPRP),KNPRP\n         TM    UPTSWS,UPTMID       MSG-ID ?\n         BO    *+L'*+10\n         MVC   WKLINE+41(L'KNMSG),KNMSG\n         B     *+L'*+6\n         MVC   WKLINE+41(L'KNMSG-2),KNMSG+2\n         TM    UPTSWS,UPTNCOM      COMMUNICATION ?\n         BO    *+L'*+10\n         MVC   WKLINE+56(L'KNICM-2),KNICM+2\n         B     *+L'*+6\n         MVC   WKLINE+56(L'KNICM),KNICM\n         LA    R0,L'WKLINE\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+11(5),=CL5'BIT-4'\n         MVC   WKLINE+26(5),=CL5'BIT-5'\n         MVC   WKLINE+41(5),=CL5'BIT-6'\n         MVC   WKLINE+56(5),=CL5'BIT-7'\n         LA    R0,L'WKLINE\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         TM    UPTSWS,UPTPAUS      PAUSE ?\n         BO    *+L'*+10\n         MVC   WKLINE+11(L'KNPSE),KNPSE\n         B     *+L'*+6\n         MVC   WKLINE+11(L'KNPSE-2),KNPSE+2\n         TM    UPTSWS,UPTALD       ATTN ?\n         BO    *+L'*+10\n         MVC   WKLINE+26(9),=CL9'ATTN=ATTN'\n         B     *+L'*+6\n         MVC   WKLINE+26(13),=CL13'ATTN=LINE DEL'\n         TM    UPTSWS,UPTMODE      MODE ?\n         BO    *+L'*+10\n         MVC   WKLINE+41(L'KNMDE),KNMDE\n         B     *+L'*+6\n         MVC   WKLINE+41(L'KNMDE-2),KNMDE+2\n         TM    UPTSWS,UPTWTP       WTP ?\n         BO    *+L'*+10\n         MVC   WKLINE+56(L'KNWTP),KNWTP\n         B     *+L'*+6\n         MVC   WKLINE+56(L'KNWTP-2),KNWTP+2\n         LA    R0,L'WKLINE\n         LA    R1,WKLINE\n         B     GOBACK\n         DROP  R4\n         SPACE 1\nKNREC    DC    C'NORECOVER'\nKNPRP    DC    C'NOPROMPT'\nKNMSG    DC    C'NOMSGID'\nKNICM    DC    C'NOINTERCOM'\nKNPSE    DC    C'NOPAUSE'\nKNMDE    DC    C'NOMODE'\nKNWTP    DC    C'NOWTPMSG'\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         EJECT\n*------- DISPLAY ENVIRONMENT CONTROL TABLE (ECT)\n         SPACE 1\n         CNOP  0,4\n         USING *,R10\nPECTL    LM    R0,R1,=A(2,ECTLEN)  CHECK ECT LENGTH\n         CL    R1,WALTSZ\n         BH    OVRFLW              WORK-AREA TOO SMALL\n         L     R2,#TSCPPL          CPPL ADDRESS\n         USING CPPL,R2\n         L     R0,CPPLECT          ECT ADDRESS\n         LA    R4,CTLBWA           WORK-AREA ADDRESS\n         LR    R5,R1\n         MVCL  R4,R0\n         L     R3,CPPLPSCB         PSCB ADDRESS\n         DROP  R2\n         USING PSCB,R3\n         XR    R1,R1\n         IC    R1,PSCBUSRL         USER-ID LENGTH\n         BCT   R1,*+L'*+6\n         MVC   WKLINE(*-*),PSCBUSER USER-ID\n         EX    R1,*-6\n         DROP  R3\n         LA    R1,WKLINE+1(R1)\n         MVC   0(34,R1),=CL34' ENVIRONMENT CONTROL TABLE (ECT) :'\n         LA    R1,34(R1)\n         LA    R0,WKLINE\n         SLR   R1,R0\n         XR    R0,R1\n         XR    R1,R0\n         XR    R0,R1\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         LA    R4,CTLBWA           WORK-AREA ADDRESS\n         USING ECT,R4\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'ECTRCDF :'\n         UNPK  WKLINE+11(3),ECTRCDF(2)\n         TR    WKLINE+11(2),TBHEX-X'F0'\n         MVI   WKLINE+13,C' '\n         MVC   WKLINE+42(9),=CL9'ECTRTCD :'\n         UNPK  WKLINE+51(7),ECTRTCD(4)\n         TR    WKLINE+51(6),TBHEX-X'F0'\n         LA    R0,57\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'ECTIOWA :'\n         UNPK  WKLINE+11(9),ECTIOWA(5)\n         TR    WKLINE+11(8),TBHEX-X'F0'\n         MVI   WKLINE+19,C' '\n         MVC   WKLINE+42(9),=CL9'ECTMSGF :'\n         UNPK  WKLINE+51(3),ECTMSGF(2)\n         TR    WKLINE+51(2),TBHEX-X'F0'\n         LA    R0,53\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'ECTSMSG :'\n         UNPK  WKLINE+11(7),ECTSMSG(4)\n         TR    WKLINE+11(6),TBHEX-X'F0'\n         MVI   WKLINE+17,C' '\n         MVC   WKLINE+42(9),=CL9'ECTPCMD :'\n         UNPK  WKLINE+51(9),ECTPCMD(5)\n         UNPK  WKLINE+59(9),ECTPCMD+4(5)\n         TR    WKLINE+51(16),TBHEX-X'F0'\n         CLC   ECTPCMD,=CL8' '\n         BNE   *+L'*+8\n         MVI   WKLINE+67,C' '\n         B     *+L'*+10\n         MVI   WKLINE+67,C'='\n         MVC   WKLINE+68(8),ECTPCMD\n         LA    R0,76\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'ECTSCMD :'\n         UNPK  WKLINE+11(9),ECTSCMD(5)\n         UNPK  WKLINE+19(9),ECTSCMD+4(5)\n         TR    WKLINE+11(16),TBHEX-X'F0'\n         CLC   ECTSCMD,=CL8' '\n         BNE   *+L'*+8\n         MVI   WKLINE+27,C' '\n         B     *+L'*+10\n         MVI   WKLINE+27,C'='\n         MVC   WKLINE+28(8),ECTSCMD\n         MVC   WKLINE+42(9),=CL9'ECTSWS  :'\n         UNPK  WKLINE+51(3),ECTSWS(2)\n         TR    WKLINE+51(2),TBHEX-X'F0'\n         LA    R0,53\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'ECTDDNUM:'\n         UNPK  WKLINE+11(7),ECTDDNUM(4)\n         TR    WKLINE+11(6),TBHEX-X'F0'\n         MVI   WKLINE+17,C' '\n         MVC   WKLINE+42(9),=CL9'ECTUSER :'\n         UNPK  WKLINE+51(9),ECTUSER(5)\n         TR    WKLINE+51(8),TBHEX-X'F0'\n         LA    R0,59\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'ECTBKPB :'\n         UNPK  WKLINE+11(9),ECTBKPB(5)\n         TR    WKLINE+11(8),TBHEX-X'F0'\n         MVI   WKLINE+19,C' '\n         MVC   WKLINE+42(9),=CL9'ECTSWS2 :'\n         UNPK  WKLINE+51(3),ECTSWS2(2)\n         TR    WKLINE+51(2),TBHEX-X'F0'\n         LA    R0,53\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'ECTSWS22:'\n         UNPK  WKLINE+11(3),ECTSWS22(4)\n         TR    WKLINE+11(2),TBHEX-X'F0'\n         MVI   WKLINE+13,C' '\n         MVC   WKLINE+42(9),=CL9'RESERVED:'\n         UNPK  WKLINE+51(5),42(3,R4)\n         TR    WKLINE+51(4),TBHEX-X'F0'\n         LA    R0,55\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'ECTHELP :'\n         UNPK  WKLINE+11(9),ECTHELP(5)\n         TR    WKLINE+11(8),TBHEX-X'F0'\n         MVC   WKLINE+19(12),=CL12' (OR ECTNUM)'\n         LA    R0,31\n         LA    R1,WKLINE\n         B     GOBACK\n         DROP  R4\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         EJECT\n*------- DISPLAY PROTECTED STEP CONTROL BLOCK (PSCB)\n         SPACE 1\n         CNOP  0,4\n         USING *,R10\nPPSCBL   LM    R0,R1,=A(3,PSCBLEN) CHECK PSCB LENGTH\n         CL    R1,WALTSZ\n         BH    OVRFLW              WORK-AREA TOO SMALL\n         L     R2,#TSCPPL          CPPL ADDRESS\n         USING CPPL,R2\n         L     R0,CPPLPSCB         PSCB ADDRESS\n         DROP  R2\n         LA    R4,CTLBWA           WORK-AREA ADDRESS\n         LR    R5,R1\n         MVCL  R4,R0\n         LA    R4,CTLBWA           WORK-AREA ADDRESS\n         USING PSCB,R4\n         XR    R1,R1\n         IC    R1,PSCBUSRL         USER-ID LENGTH\n         BCT   R1,*+L'*+6\n         MVC   WKLINE(*-*),PSCBUSER USER-ID\n         EX    R1,*-6\n         LA    R1,WKLINE+1(R1)\n         MVC   0(38,R1),=CL38' PROTECTED STEP CONTROL BLOCK (PSCB) :'\n         LA    R1,38(R1)\n         LA    R0,WKLINE\n         SLR   R1,R0\n         XR    R0,R1\n         XR    R1,R0\n         XR    R0,R1\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'PSCBUSER:'\n         UNPK  WKLINE+11(9),PSCBUSER(5)\n         UNPK  WKLINE+19(7),PSCBUSER+4(4)\n         TR    WKLINE+11(14),TBHEX-X'F0'\n         MVI   WKLINE+25,C'='\n         MVC   WKLINE+26(7),PSCBUSER\n         MVC   WKLINE+42(9),=CL9'PSCBUSRL:'\n         UNPK  WKLINE+51(3),PSCBUSRL(2)\n         TR    WKLINE+51(2),TBHEX-X'F0'\n         LA    R0,53\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'PSCBGPNM:'\n         UNPK  WKLINE+11(9),PSCBGPNM(5)\n         UNPK  WKLINE+19(9),PSCBGPNM+4(5)\n         TR    WKLINE+11(16),TBHEX-X'F0'\n         CLC   PSCBGPNM,=CL8' '\n         BNE   *+L'*+8\n         MVI   WKLINE+27,C' '\n         B     *+L'*+10\n         MVI   WKLINE+27,C'='\n         MVC   WKLINE+28(8),PSCBGPNM\n         MVC   WKLINE+42(9),=CL9'PSCBATR1:'\n         UNPK  WKLINE+51(5),PSCBATR1(3)\n         TR    WKLINE+51(4),TBHEX-X'F0'\n         LA    R0,55\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'PSCBATR2:'\n         UNPK  WKLINE+11(5),PSCBATR2(3)\n         TR    WKLINE+11(4),TBHEX-X'F0'\n         MVI   WKLINE+15,C' '\n         MVC   WKLINE+42(9),=CL9'PSCBLTIM:'\n         UNPK  WKLINE+51(9),PSCBLTIM(5)\n         UNPK  WKLINE+59(9),PSCBLTI2(5)\n         TR    WKLINE+51(16),TBHEX-X'F0'\n         LA    R0,67\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'PSCBSUBH:'\n         UNPK  WKLINE+11(3),PSCBSUBH(2)\n         TR    WKLINE+11(2),TBHEX-X'F0'\n         XR    R1,R1\n         IC    R1,PSCBSUBH\n         LTR   R1,R1\n         BNZ   *+L'*+8\n         MVI   WKLINE+13,C' '\n         B     *+L'*+8\n         MVI   WKLINE+13,C'='\n         STC   R1,WKLINE+14\n         MVC   WKLINE+42(9),=CL9'PSCBSUBC:'\n         UNPK  WKLINE+51(3),PSCBSUBC(2)\n         TR    WKLINE+51(2),TBHEX-X'F0'\n         XR    R1,R1\n         IC    R1,PSCBSUBC\n         LTR   R1,R1\n         BNZ   *+L'*+8\n         MVI   WKLINE+53,C' '\n         B     *+L'*+8\n         MVI   WKLINE+53,C'='\n         STC   R1,WKLINE+54\n         LA    R0,55\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'PSCBSUBM:'\n         UNPK  WKLINE+11(3),PSCBSUBM(2)\n         TR    WKLINE+11(2),TBHEX-X'F0'\n         XR    R1,R1\n         IC    R1,PSCBSUBM\n         LTR   R1,R1\n         BNZ   *+L'*+8\n         MVI   WKLINE+13,C' '\n         B     *+L'*+8\n         MVI   WKLINE+13,C'='\n         STC   R1,WKLINE+14\n         MVC   WKLINE+42(9),=CL9'PSCBSOUT:'\n         UNPK  WKLINE+51(3),PSCBSOUT(2)\n         TR    WKLINE+51(2),TBHEX-X'F0'\n         XR    R1,R1\n         IC    R1,PSCBSOUT\n         LTR   R1,R1\n         BNZ   *+L'*+8\n         MVI   WKLINE+53,C' '\n         B     *+L'*+8\n         MVI   WKLINE+53,C'='\n         STC   R1,WKLINE+54\n         LA    R0,55\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'RESERVED:'\n         UNPK  WKLINE+11(3),32(2,R4)\n         TR    WKLINE+11(2),TBHEX-X'F0'\n         MVI   WKLINE+13,C' '\n         MVC   WKLINE+42(9),=CL9'PSCBDRBA:'\n         UNPK  WKLINE+51(7),PSCBDRBA(4)\n         TR    WKLINE+51(6),TBHEX-X'F0'\n         LA    R0,53\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'RESERVED:'\n         UNPK  WKLINE+11(9),36(5,R4)\n         TR    WKLINE+11(8),TBHEX-X'F0'\n         MVI   WKLINE+19,C' '\n         MVC   WKLINE+42(9),=CL9'PSCBDEST:'\n         UNPK  WKLINE+51(9),PSCBDEST(5)\n         UNPK  WKLINE+59(9),PSCBDEST+4(5)\n         TR    WKLINE+51(16),TBHEX-X'F0'\n         OC    PSCBDEST,PSCBDEST\n         BNZ   *+L'*+8\n         MVI   WKLINE+67,C' '\n         B     *+L'*+10\n         MVI   WKLINE+67,C'='\n         MVC   WKLINE+68(8),PSCBDEST\n         LA    R0,76\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'PSCBRLGB:'\n         UNPK  WKLINE+11(9),PSCBRLGB(5)\n         TR    WKLINE+11(8),TBHEX-X'F0'\n         MVI   WKLINE+19,C' '\n         MVC   WKLINE+42(9),=CL9'PSCBUPT :'\n         UNPK  WKLINE+51(9),PSCBUPT(5)\n         TR    WKLINE+51(8),TBHEX-X'F0'\n         LA    R0,59\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'PSCBUPTL:'\n         UNPK  WKLINE+11(5),PSCBUPTL(3)\n         TR    WKLINE+11(4),TBHEX-X'F0'\n         MVI   WKLINE+15,C' '\n         MVC   WKLINE+42(9),=CL9'PSCBCHAR:'\n         UNPK  WKLINE+51(3),PSCBCHAR(2)\n         TR    WKLINE+51(2),TBHEX-X'F0'\n         XR    R1,R1\n         IC    R1,PSCBCHAR\n         LTR   R1,R1\n         BNZ   *+L'*+8\n         MVI   WKLINE+53,C' '\n         B     *+L'*+8\n         MVI   WKLINE+53,C'='\n         STC   R1,WKLINE+54\n         LA    R0,55\n         LA    R1,WKLINE\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'PSCBLINE:'\n         UNPK  WKLINE+11(3),PSCBLINE(2)\n         TR    WKLINE+11(2),TBHEX-X'F0'\n         XR    R1,R1\n         IC    R1,PSCBLINE\n         LTR   R1,R1\n         BNZ   *+L'*+8\n         MVI   WKLINE+13,C' '\n         B     *+L'*+8\n         MVI   WKLINE+13,C'='\n         STC   R1,WKLINE+14\n         MVC   WKLINE+42(9),=CL9'PSCBRSZ :'\n         UNPK  WKLINE+51(9),PSCBRSZ(5)\n         TR    WKLINE+51(8),TBHEX-X'F0'\n         MVI   WKLINE+59,C'='\n         ICM   R1,B'1111',PSCBRSZ\n         SLL   R1,1\n         CVD   R1,DBLWRD\n         MVC   WKEDIT,=XL8'4020202020202120'\n         ED    WKEDIT,DBLWRD+4\n         LA    R0,L'WKEDIT-1\n         LA    R14,WKEDIT+1\n         LA    R1,WKLINE+60\n         CLI   0(R14),C' '\n         BE    *+L'*+10\n         MVC   0(1,R1),0(R14)\n         LA    R1,1(R1)\n         LA    R14,1(R14)\n         BCT   R0,*-22\n         MVI   0(R1),C'K'\n         LA    R0,1(R1)\n         LA    R1,WKLINE\n         SLR   R0,R1\n         BAS   R14,PUTLNE\n         BAS   R14,CHECK           SEE HOW COMPLETE\n         MVI   WKLINE,C' '\n         MVC   WKLINE+1(L'WKLINE-1),WKLINE\n         MVC   WKLINE+2(9),=CL9'PSCBU   :'\n         UNPK  WKLINE+11(9),PSCBU(5)\n         UNPK  WKLINE+19(9),PSCBU+4(5)\n         TR    WKLINE+11(16),TBHEX-X'F0'\n         MVC   WKLINE+27(32),=CL32' (RESERVED FOR INSTALLATION USE)'\n         LA    R0,59\n         LA    R1,WKLINE\n         B     GOBACK\n         DROP  R4\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         EJECT\n*------- PARSE PARAMETERS LIST\n         SPACE 1\nPARMLST  IKJPARM  DSECT=IKJPARMD\nKWUPT    IKJKEYWD DEFAULT='NOUPT'\n         IKJNAME  'NOUPT'\n         IKJNAME  'UPT'\nKWECT    IKJKEYWD DEFAULT='NOECT'\n         IKJNAME  'NOECT'\n         IKJNAME  'ECT'\nKWPSCB   IKJKEYWD DEFAULT='NOPSCB'\n         IKJNAME  'NOPSCB'\n         IKJNAME  'PSCB'\n         IKJENDP\n         EJECT\n*------- WORK-AREAS - DSECT'S.\n         SPACE 1\nWKAREA   DSECT\n         DS    18F            FIRST S.A.\nDBLWRD   DS    D\n         SPACE 1\n        $TEW$WA\n         SPACE 1\nWKEDIT   DS    CL8\nWKLINE   DS    CL78\n         SPACE 1\nSWREQS   DS    XL1'0'         REQUESTS INDICATORS\nRQUPT    EQU   X'80'               DISPLAY UPT\nRQECT    EQU   X'40'               DISPLAY ECT\nRQPSCB   EQU   X'20'               DISPLAY PSCB\n         SPACE 1\nWALT     EQU   WASIZE+8\nWALEN    EQU   ((WALT+7)/8)*8\nCTLBWA   DS    0D,(WALEN)X    CONTROL BLOCKS WORK-AREA\n         SPACE 1\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8\n         SPACE 1\n        $TEW$DS\n        IKJUPT\nUPTLEN   EQU   *-UPT\n        IKJECT\nECTLEN   EQU   *-ECT\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DTSO$": {"ttr": 12550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x15\\x15\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T15:15:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//DTSO     JOB (........),'INSTALL  - DTSO -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=DTSO\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   DTSO\n  NAME    DTSO(R)\n/*\n//HLP     EXEC PAJHELP,MBR=DTSOH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DTSO@": {"ttr": 12552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12_\\x00\\x94\\x12_\\x166\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-05T00:00:00", "modifydate": "1994-05-05T16:36:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "1   05/10/90\n                                                      DTSO      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          DTSO TSO command           * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Command name :      DTSO\n  Function :          This TSO command processor displays some control\n                      blocks of the user session.\n\n  Syntax :\n  --------------------------------------------------------------------\n  Command    Operands\n  --------------------------------------------------------------------\n  DTSO       UPT  ECT  PSCB\n  --------------------------------------------------------------------\n\n  Operands :\n     Required - None\n     Optional - UPT, ECT and PSCB\n     Default  - UPT if no operand has been specified\n\n     UPT = display the User Profile Table (it's another PROFILE LIST\n                        command).\n\n     ECT = display the Environment Control Table.\n\n     PSCB = display the Protected Step Control Block.\n\n  Return codes :   0 - Successfull display\n                  16 - Error\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DTSOH": {"ttr": 12554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12_\\x00\\x94\\x12_\\x16I\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-05T00:00:00", "modifydate": "1994-05-05T16:49:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=DTSO\n./     NUMBER  NEW1=100,INCR=100\n)F Function :  This TSO command processor displays some control blocks\n               of the user session.\n)X Syntax :    DTSO  UPT  ECT  PSCB\n               Required : none\n               Optional : UPT, ECT and PSCB\n               Defaults : UPT if no operand has been specified\n               Return codes (&LASTCC value) :\n                   0 - Successfull display\n                   16 - Error\n)O Operands :\n))UPT :        display the User Profile Table (it's another PROFILE\n               LIST command).\n))ECT :        display the Environment Control Table.\n))PSCB :       display the Protected Step Control Block.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DTUR": {"ttr": 12556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x06o\\x00\\x89\\x06o\\x15\\x05\\x04P\\x04P\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-03-07T00:00:00", "modifydate": "1989-03-07T15:05:00", "lines": 1104, "newlines": 1104, "modlines": 0, "user": "SYSPAJA"}, "text": "DTUR     TITLE 'DSECT''S TABLES USE ROUTINE.'\nDTUSE    START 0\n         SPACE 1\n* PURPOSE :    THIS ROUTINE ALLOWS AN EASIER WAY TO USE THE DSECT'S\n* ---------    TABLES WHICH ARE CREATED BY THE 'GDTUTIL' PROGRAM.\n*              NOTE : THE ROUTINE IS SERIALLY REUSABLE.\n*\n* AUTHOR :     MOINIL P.A. - COMPUTING CENTRE\n* --------     J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n*\n* CALLING SEQUENCE : CALL DTUSE,(A,B),VL\n* ------------------            (A)\n*\n*        WHERE : A - IS THE ADDRESS OF A VARIABLE NUMBER OF CONSECUTIVE\n*                    FIELDS (NUMBERED BY @) INFORMATION AS BELOW\n*                      @-1 (AL1) = A FUNCTION CODE WHICH\n*                        IF = 0 (START), THEN\n*                          @-2 (AL1) = DATA-SET NAME LENGTH\n*                          @-3 (CL...) = DATA-SET NAME\n*                        IF = 1 (SEARCH) OR 2 (LIST), THEN\n*                          @-2 (CL8) = DSECT TABLE NAME\n*                          @-3 (CL8) = DSECT FIELD NAME\n*                          @-4 (XL2) = FIELD DISPLACEMENT VALUE\n*                          @-5 (XL2) = FIELD NAME LENGTH VALUE\n*                          @-6 (CL8) = FLAG NAME\n*                          @-7 (XL2) = FLAG VALUE\n*                          @-8 (XL2) = FLAG NAME LENGTH VALUE\n*                        IF = 64 (RD-DIR), THEN\n*                          @-2 (CL8) = DSECT NAME\n*                          @-3 (CL8) = ALIAS OF NAME\n*                        IF = 127 (MOD-ID), THEN\n*                          @-2 (CL8) = DSECT TABLE NAME\n*                          @-3 (CL8) = DSECT MACRO NAME\n*                          @-4 (CL16) = DATE AND TIME OF ASSEMBLY\n*                                       (FORMAT IS ' MM/DD/YY HH.MM ')\n*                        IF = 128 (STATS), THEN\n*                          @-2 (XL4) = TOTAL NUMBER OF LOADS\n*                          @-3 (XL4) = TOTAL LOAD-MODULES LENGTH\n*                                          IN DOUBLE-WORDS\n*                          NOTE : COUNTERS ARE RESET AT END\n*                        IF = 255 (END), THEN NONE\n*                    (NO ALIGNMENT REQUIRED)\n         EJECT\n*                B - IS THE ADDRESS OF THE INDICATOR RESPONSE (FORMAT\n*                    XL4, NO ALIGNMENT) IF SUPPLIED (OPTIONAL).\n*                    VALUE IS ALWAYS PLACED IN REGISTER 15 AND CAN BE :\n*                     0 - OPERATION CORRECTLY ENDED.\n*                     4 - OPERATION MAY CONTINUE WHEN SEARCH FUNCTION\n*                         (BY FIELD NAME OR DISPLACEMENT, FLAG VALUE),\n*                         RD-DIR FUNCTION OR LIST FUNCTION.\n*                     8 - A WARNING ERROR HAS BEEN DETECTED.\n*                    12 - A SEVERE ERROR HAS BEEN DETECTED.\n*                    AT EXIT AND ONLY WHEN AN ERROR IS DETECTED (RC 8\n*                    OR 12), THE REGISTER 1 CONTAINS A POINTER TO A\n*                    MESSAGE TEXT AS FOLLOWS\n*                    R1 --->     DC AL1(L'MSG)\n*                            MSG DC C'...ERROR MESSAGE TEXT...'\n*\n* HOW-TO-USE THE VARIOUS FUNCTIONS OF THIS ROUTINE :\n* --------------------------------------------------\n*   A - AS FISRT OPERATION YOU MUST CALL THE START FUNCTION, THEN\n*   B - USE THE SEARCH FUNCTION TO OBTAIN INFORMATION ABOUT A FIELD\n*       NAME, A FIELD DISPLACEMENT, A FLAG NAME OR A FLAG VALUE IN A\n*       DSECT. THE REQUEST CAN BE DONE AS FOLLOWS :\n*       1. SPECIFY THE DSECT NAME AND A FIELD NAME (@-2 AND @-3, @-6\n*          MUST BE BLANK) TO RECEIVE BACK THE FIELD VALUES (@-4 AND\n*          @-5). IF RC=0, THE FIELD HAS NO FLAGS DEFINED, BUT IF RC=4,\n*          THEN YOU MAY CONTINUE (RETAIN @-2 TO @-8 AS THEY ARE) TO\n*          RECEIVE BACK THE FLAGS NAME AND VALUES (@-6, @-7 AND @-8)\n*          UNTIL RC=0 WHICH SAY YOU NO MORE.\n*       2. SPECIFY THE DSECT NAME AND A FIELD DISPLACEMENT VALUE (@-2\n*          AND @-4, @-3 AND @-6 MUST BE BLANK) TO RECEIVE BACK THE\n*          FIELD NAME AND LENGTH (@-3 AND @-5). AS LONG AS RC=4, YOU\n*          MAY CONTINUE TO GET ALL FIELDS NAMES (RETAIN @-2 TO @-8 AS\n*          THEY ARE) HAVING THE SAME DISPLACEMENT IN THE DSECT, UNTIL\n*          RC=0 WHICH SAY YOU NO MORE.\n*       3. SPECIFY THE DSECT NAME AND A FLAG NAME (@-2 AND @-6, @-3\n*          MUST BE BLANK) TO RECEIVE BACK THE FIELD NAME, VALUES AND\n*          THE FLAG VALUES (@-3, @-4, @-5, @-7 AND @-8).\n*       4. SPECIFY THE DSECT NAME, A FIELD NAME AND A FLAG VALUE (@-2,\n*          @-3 AND @-7, @-6 MUST BE ANYTHING BUT NOT BLANK) TO RECEIVE\n*          THE FLAG NAMES (@-6, ALSO PASSED BACK @-4, @-5 AND @-8).\n*          AS LONG AS RC=4, YOU MAY CONTINUE TO GET ALL FLAGS NAMES\n*          (RETAIN @-2 TO @-8 AS THEY ARE) HAVING THE SAME VALUE IN\n*          THE FIELD OF THE DSECT, UNTIL RC=0 WHICH SAY YOU NO MORE.\n*          NOTE : THE FIELD NAME WHERE THE FLAG VALUE IS SEARCHED\n*                 MUST BE KNOWN.\n         EJECT\n*   C - OR USE THE LIST FUNCTION FOR A DSECT (@-2) TO RECEIVE BACK\n*       SEQUENTIALLY ALL THE FIELDS (FLAG NAME, @-6 IS BLANK, AND\n*       VALUES, @-7 AND @-8 ARE ZERO) AND FLAGS (FIELD NAME, @-3 IS\n*       BLANK, AND VALUES, @-4 AND @-5 ARE ZERO) WHICH ARE DEFINED\n*       IN THE DSECT. THE LIST MAY CONTINUE UNTIL RC=4 (RETAIN @-2 TO\n*       @-8 AS THEY ARE) AND IS TERMINATED WHEN RC=0.\n*   D - OR USE THE READ-DIR FUNCTION TO RECEIVE BACK SEQUENTIALLY ALL\n*       THE DSECT NAMES (@-2, @-3 IS BLANK) OR THE ALIAS NAMES (@-2)\n*       OF A DSECT NAME (@-3). THE READ-DIR MAY CONTINUE UNTIL RC=4\n*       (RETAIN @-2 AND @-3AS THEY ARE) AND IS TERMINATED WHEN RC=0.\n*   E - OR USE THE MODULE-ID FUNCTION TO OBTAIN THE DSECT MACRO NAME\n*       (@-3) AND THE DATE/TIME (@-4) OF THE MODULE ASSEMBLY FOR A\n*       SPECIFIC DSECT NAME (@-2).\n*   F - AT ANY TIME, YOU MAY USE THE STATS FUNCTION TO CONTROL HOW THE\n*       SPACE NEEDED FOR TABLES HAS GROWN.\n*   G - FINALLY CALL THE END FUNCTION TO TERMINATE THE PROCESSING. AT\n*       THIS POINT, IF DESIRED, YOU MAY RECALL THE ROUTINE TO START A\n*       NEW PROCESS AGAIN. NOTE, THIS IS THE WAY TO FREE ALL CORE\n*       STORAGE SPACE AND START AGAIN WITH THE SAME OR ANOTHER DSECTS\n*       TABLES DATA-SET.\n         EJECT\n*        ARRAYS SPACE DEFINITIONS.\n         SPACE 1\nNDE      EQU   100                 NO. OF BLDL-LOAD LIST ELEMENTS\n*                                  (TOTAL NO. OF DSECTS TABLES)\nNDI      EQU   500                 NO. OF DICTIONARY ELEMENTS\n*                                  (TOTAL NO. OF EXTERNAL NAMES)\n         SPACE 1\n*        FUNCTION VARIABLE FIELDS DEFINITIONS.\n         SPACE 1\nVFUN     EQU   0,1                 FUNCTION CODE\nVFT      EQU   0                      0 = START\nVFS      EQU   1                      1 = SEARCH\nVFL      EQU   2                      2 = LIST\nVFD      EQU   64                    64 = RD-DIR\nVFM      EQU   127                  127 = MOD-ID\nVFZ      EQU   128                  128 = STATS\nVFE      EQU   255                  255 = END\n         SPACE 1\nVFTL     EQU   1,1                   0 - START FIELDS\nVFTN     EQU   2,44                      .\nVFSN     EQU   1,8                   1 - SEARCH FIELDS\nVFSF     EQU   9,8                       .\nVFSD     EQU   17,2                      .\nVFSL     EQU   19,2                      .\nVFSX     EQU   21,8                      .\nVFSY     EQU   29,2                      .\nVFSZ     EQU   31,2                      .\nVFLN     EQU   1,8                   2 - LIST FIELDS\nVFLF     EQU   9,8                       .\nVFLD     EQU   17,2                      .\nVFLL     EQU   19,2                      .\nVFLX     EQU   21,8                      .\nVFLY     EQU   29,2                      .\nVFLZ     EQU   31,2                      .\nVFDN     EQU   1,8                  64 - RD-DIR FIELDS\nVFDA     EQU   9,8                       .\nVFMN     EQU   1,8                 127 - MOD-ID FIELDS\nVFMI     EQU   9,8                       .\nVFMD     EQU   17,16                     .\nVFZN     EQU   1,4                 128 - STATS FIELDS\nVFZL     EQU   5,4                       .\n         SPACE 1\nCHKCSQL  EQU   L'VFSN+L'VFSF+L'VFSD+L'VFSL+L'VFSX+L'VFSY+L'VFSZ\nCHKCSQR  EQU   L'VFDN+L'VFDA\n         EJECT\n*        DSECTS TABLE MODULE DEFINITIONS.\n         SPACE 1\nTBID     EQU   0,24                MODULE-ID LENGTH\nTBET     EQU   0,1                 ENTRY TYPE\nTBNTY    EQU   0                   DSECT NAME ENTRY\nTBFTY    EQU   1                   FIELD NAME ENTRY\nTBBTY    EQU   2                   FLAG NAME ENTRY\nTBENM    EQU   255                 END MARKER\n         SPACE 1\nTBNNM    EQU   1,8                 DSECT NAME ENTRY\nTBNRL    EQU   9,4                  .\nTBNNX    EQU   13,4                 .\nTBNLEN   EQU   17                   .\n         SPACE 1\nTBFNM    EQU   1,8                 FIELD NAME ENTRY\nTBFDS    EQU   9,2                  .\nTBFLG    EQU   11,2                 .\nTBFLEN   EQU   13                   .\n         SPACE 1\nTBBNM    EQU   1,8                 FLAG NAME ENTRY\nTBBVL    EQU   9,2                  .\nTBBLG    EQU   11,2                 .\nTBBLEN   EQU   13                   .\n         EJECT\n        $DEFREG\n        $XENT  BASE=(R11,R12)\n         EJECT\n*        SELECT ENTRY.\n*        -------------\n         SPACE 1\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         XR    R9,R9\n         TM    0(R1),X'80'         CONTROL ARGUMENTS\n         BO    *+L'*+8\n         L     R9,4(R1)\n         LA    R9,0(R9)\n         TM    SWRTN,SWRD          SELECT FUNCTION CODE\n         BO    DISABLE\n         CLI   VFUN(R8),VFT\n         BE    STRFUN\n         CLI   VFUN(R8),VFS\n         BE    SRCFUN\n         CLI   VFUN(R8),VFL\n         BE    LSTFUN\n         CLI   VFUN(R8),VFD\n         BE    DIRFUN\n         CLI   VFUN(R8),VFM\n         BE    MIDFUN\n         CLI   VFUN(R8),VFZ\n         BE    STSFUN\n         CLI   VFUN(R8),VFE\n         BE    ENDFUN\n         LA    R1,FCNMSG-1\n         B     SETRC12\n         EJECT\n*        START FUNCTION (CODE 0).\n*        ------------------------\n         SPACE 1\nSTRFUN   MVI   SWSRC,0\n         MVI   SWLST,0\n         BAS   R7,RDTRTN\n         CLI   ALLDSN,C' '         GET DATA-SET NAME\n         BE    *+L'*+8\n         LA    R1,STRMSG-1\n         B     SETRC12\n         XR    R1,R1\n         ICM   R1,B'0001',VFTL(R8)\n         BZ    STRINV\n         CLI   VFTN(R8),C'A'\n         BL    STRINV\n         LA    R0,L'ALLDSN\n         CLR   R1,R0\n         BNH   *+L'*+8\nSTRINV   LA    R1,DSNMSG-1\n         B     SETRC12\n         BCT   R1,*+L'*+6\n         MVC   ALLDSN(*-*),VFTN(R8)\n         EX    R1,*-6\n         LA    R1,ALLDSN+L'ALLDSN-1\n         CLI   0(R1),C' '\n         BNE   *+L'*+10\n         BCTR  R1,0\n         BCT   R0,*-10\n         B     STRINV\n         STCM  R0,B'0011',ALLDSNL\n         LA    R1,ALLRBPTR         ALLOCATION PARM. LIST\n        DYNALLOC\n         LTR   R15,R15\n         BZ    STRDONE\n         CVD   R15,WORKD\n         MVC   ALLMSGR,=XL4'40202020'\n         ED    ALLMSGR,WORKD+6\n         UNPK  ALLMSGD,ALLERROR(L'ALLERROR+1)\n         TR    ALLMSGD(L'ALLMSGD-1),HEXTB-C'0'\n         MVI   ALLMSGD+L'ALLMSGD-1,C' '\n         UNPK  ALLMSGI,ALLINFO(L'ALLINFO+1)\n         TR    ALLMSGI(L'ALLMSGI-1),HEXTB-C'0'\n         MVI   ALLMSGI+L'ALLMSGI-1,C' '\n         LA    R1,ALLMSG-1\n         OI    SWRTN,SWRD\n         B     SETRC12\nSTRDONE  CLC   ALLDSORG(L'ALLDSORG),=AL1(DCBDSGPO,0)\n         BE    STROK\n         LA    R1,DSOMSG-1\n         OI    SWRTN,SWRD\n         B     SETRC12\nSTROK    LA    R2,DSTLIB           OPEN DATA-SET\n         USING IHADCB,R2\n         MVC   DCBDDNAM,ALLDDN\n        OPEN   (DSTLIB,(INPUT))\n         TM    DCBOFLGS,DCBOFOPN\n         BO    STROPN\n         DROP  R2\n         LA    R1,OPNMSG-1\n         OI    SWRTN,SWRD\n         B     SETRC12\nSTROPN   L     R3,=A(TALEN)        GET WORK-AREAS\n         LR    R0,R3\n        GETMAIN R,LV=(0)\n         ST    R1,DESCN\n         LR    R2,R1\n         XR    R3,R3\n         LR    R4,R3\n         MVCL  R2,R4\n         AL    R1,=A(TDELEN)\n         LR    R2,R1\n         SL    R1,DESCN+4\n         ST    R1,DESCN+8\n         ST    R2,DISCN\n         AL    R2,=A(DILEN*(NDI-1))\n         ST    R2,DISCN+8\n         B     EXIT\n         EJECT\n*        SEARCH FUNCTION (CODE 1).\n*        -------------------------\n         SPACE 1\nSRCFUN   MVI   SWLST,0\n         BAS   R7,RDTRTN\n         LA    R2,DSTLIB\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN\n         BO    SRCTST\n         DROP  R2\n         MVI   SWSRC,0\n         MVC   DNOMSGF,=CL6'SEARCH'\n         LA    R1,DNOMSG-1\n         B     SETRC12\nSRCTST   TM    SWSRC,SWSC\n         BZ    SRCNEW\n         CLC   CHKCSQ(CHKCSQL),VFSN(R8)\n         BNE   SRCNEW\n         L     R3,SVRA\n         TM    SWSRC,SWSD\n         BZ    *+L'*+8\n         L     R6,SVRB\n         B     SRCCNX\n         TM    SWSRC,SWSV\n         BZ    SRCCNF\n         B     SRCFVC\nSRCNEW   MVI   SWSRC,0\n         CLI   VFSN(R8),C' '\n         BNE   *+L'*+14\n         MVC   MDTMSGF,=CL6'SEARCH'\n         LA    R1,MDTMSG-1\n         B     SETRC8\n         MVC   DSSVF,=CL6'SEARCH'\n         BAS   R14,DSSRTN\n         XC    WORKD,WORKD\n         CLI   VFSX(R8),C' '\n         BE    *+L'*+16\n         CLI   VFSF(R8),C' '\n         BE    SRCFCN\n         OI    SWSRC,SWSV\n         B     *+L'*+8\n         CLI   VFSF(R8),C' '\n         BE    *+L'*+10\n         MVC   WORKS(L'VFSF),VFSF(R8)\n         B     SRCCNT\n         MVC   WORKS(L'VFSD),VFSD(R8)\n         MVC   WORKS+L'WORKS-L'VFSD(L'VFSD),WORKS\n         MVC   WORKD+L'WORKD-L'VFSD(L'VFSD),VFSD(R8)\n         OI    SWSRC,SWSD\nSRCCNT   LA    R3,TBNLEN(R3)\n         CLI   TBET(R3),TBNTY\n         BE    SRCCNT\nSRCNXT   CLI   TBET(R3),TBFTY\n         BNE   SRCCNX\n         TM    SWSRC,SWSD\n         BO    *+L'*+10\n         CLC   WORKS(L'TBFNM),TBFNM(R3)\n         B     *+L'*+6\n         CLC   WORKS(L'TBFDS),TBFDS(R3)\n         BE    SRCFND\nSRCCNX   LA    R3,TBFLEN(R3)\n         CLI   TBET(R3),TBENM\n         BNE   SRCNXT\n         ICM   R3,B'1111',TBNNX(R6)\n         BZ    SRCFNF\n         ICM   R0,B'1111',TBNRL(R3)\n         BZ    SRCFNF\n         LR    R6,R3\n         L     R1,WORKD\n         AR    R1,R0\n         ST    R1,WORKD\n         TM    SWSRC,SWSD\n         BZ    SRCCNT\n         L     R1,WORKD+4\n         SR    R1,R0\n         ST    R1,WORKD+4\n         MVC   WORKS(L'VFSD),WORKD+L'WORKD-L'VFSD\n         B     SRCCNT\nSRCFND   TM    SWSRC,SWSD\n         BO    SRCDSF\n         MVC   WORKD+L'WORKD-L'TBFDS(L'TBFDS),TBFDS(R3)\n         L     R1,WORKD+4\n         A     R1,WORKD\n         ST    R1,WORKD+4\n         MVC   VFSD(L'VFSD,R8),WORKD+L'WORKD-L'VFSD\n         MVC   VFSL(L'TBFLG,R8),TBFLG(R3)\n         TM    SWSRC,SWSV\n         BO    SRCFVL\n         CLI   TBET+TBFLEN(R3),TBBTY\n         BNE   SRCEND\n         OI    SWSRC,SWSC\nSRCCHK   ST    R3,SVRA\n         MVC   CHKCSQ(CHKCSQL),VFSN(R8)\n         B     SETRC4\nSRCCNF   LA    R3,TBFLEN(R3)\n         CLI   TBET(R3),TBBTY\n         BNE   SRCEND\n         MVC   VFSX(L'TBBNM+L'TBBVL+L'TBBLG,R8),TBBNM(R3)\n         B     SRCCHK\nSRCDSF   MVC   VFSF(L'TBFNM,R8),TBFNM(R3)\n         MVC   VFSL(L'TBFLG,R8),TBFLG(R3)\n         OI    SWSRC,SWSC\n         ST    R6,SVRB\n         B     SRCCHK\nSRCFNF   TM    SWSRC,SWSD\n         BO    SRCDNF\n         MVC   DSFMSG(L'VFSF),VFSF(R8)\n         MVC   DSFMSGT(5),=CL5'FIELD'\n         MVC   DSFMSGF,=CL6'SEARCH'\n         LA    R1,DSFMSG-1\n         B     SETRC8\nSRCDNF   TM    SWSRC,SWSC\n         BO    SRCEND\n         UNPK  DPNMSGD(L'DPNMSGD+1),VFSD(L'VFSD+1,R8)\n         TR    DPNMSGD(L'DPNMSGD),HEXTB-C'0'\n         MVI   DPNMSGD+L'DPNMSGD,C''''\n         LA    R1,DPNMSG-1\n         B     SETRC8\nSRCFCN   MVC   WORKS(L'VFSX),VFSX(R8)\n         LR    R2,R3\n         LA    R3,TBNLEN(R3)\n         CLI   TBET(R3),TBNTY\n         BE    SRCFCN+L'SRCFCN\nSRCFNX   CLI   TBET(R3),TBFTY\n         BNE   *+L'*+6\n         LR    R2,R3\n         B     SRCFCX\n         CLI   TBET(R3),TBBTY\n         BNE   SRCFCX\n         CLC   WORKS(L'TBBNM),TBBNM(R3)\n         BE    SRCFFD\nSRCFCX   LA    R3,TBBLEN(R3)\n         CLI   TBET(R3),TBENM\n         BNE   SRCFNX\n         ICM   R3,B'1111',TBNNX(R6)\n         BZ    SRCFLN\n         ICM   R0,B'1111',TBNRL(R6)\n         BZ    SRCFLN\n         LR    R6,R3\n         L     R1,WORKD\n         AR    R1,R0\n         ST    R1,WORKD\n         B     SRCFCN+L'SRCFCN\nSRCFFD   MVC   VFSY(L'TBBVL+L'TBBLG,R8),TBBVL(R3)\n         CLI   TBET(R2),TBFTY\n         BE    *+L'*+16\n         MVC   VFSF(L'TBNNM,R8),TBNNM(R2)\n         XC    VFSD(L'VFSD+L'VFSL,R8),VFSD(R8)\n         B     SRCEND\n         MVC   VFSF(L'TBFNM,R8),TBFNM(R2)\n         MVC   WORKD+L'WORKD-L'TBFDS(L'TBFDS),TBFDS(R2)\n         L     R1,WORKD+4\n         A     R1,WORKD\n         ST    R1,WORKD+4\n         MVC   VFSD(L'VFSD,R8),WORKD+L'WORKD-L'VFSD\n         MVC   VFSL(L'TBFLG,R8),TBFLG(R2)\n         B     SRCEND\nSRCFLN   MVC   DSFMSG(L'VFSX),VFSX(R8)\n         MVC   DSFMSGT(5),=CL5'FLAG '\n         MVC   DSFMSGF,=CL6'SEARCH'\n         LA    R1,DSFMSG-1\n         B     SETRC8\nSRCFVL   LA    R3,TBBLEN(R3)\n         CLI   TBET(R3),TBBTY\n         BNE   SRCFVN\n         CLC   VFSY(L'TBBVL,R8),TBBVL(R3)\n         BNE   SRCFVL\n         OI    SWSRC,SWSC\nSRCFVM   MVC   VFSX(L'TBBNM,R8),TBBNM(R3)\n         MVC   VFSZ(L'TBBLG,R8),TBBLG(R3)\n         B     SRCCHK\nSRCFVT   CLC   VFSY(L'TBBVL,R8),TBBVL(R3)\n         BE    SRCFVM\nSRCFVC   LA    R3,TBBLEN(R3)\n         CLI   TBET(R3),TBBTY\n         BE    SRCFVT\nSRCEND   MVI   SWSRC,0\n         XC    CHKCSQ(CHKCSQL),CHKCSQ\n         B     EXIT\nSRCFVN   UNPK  DVNMSGV(L'DVNMSGV+1),VFSY(L'VFSY+1,R8)\n         TR    DVNMSGV(L'DVNMSGV),HEXTB-C'0'\n         MVI   DVNMSGV+L'DVNMSGV,C''''\n         LA    R1,DVNMSG-1\n         B     SETRC8\n         EJECT\n*        LIST FUNCTION (CODE 2).\n*        -----------------------\n         SPACE 1\nLSTFUN   MVI   SWSRC,0\n         BAS   R7,RDTRTN\n         LA    R2,DSTLIB\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN\n         BO    LSTTST\n         DROP  R2\n         MVI   SWLST,0\n         MVC   DNOMSGF,=CL6'LIST  '\n         LA    R1,DNOMSG-1\n         B     SETRC12\nLSTTST   TM    SWLST,SWLS+SWLC\n         BNO   LSTNEW\n         CLC   CHKCSQ(CHKCSQL),VFSN(R8)\n         BNE   LSTNEW\n         L     R3,SVRA\n         L     R6,SVRB\n         B     LSTCNX\nLSTNEW   MVI   SWLST,0\n         CLI   VFLN(R8),C' '\n         BNE   *+L'*+14\n         MVC   MDTMSGF,=CL6'LIST  '\n         LA    R1,MDTMSG-1\n         B     SETRC8\n         OI    SWLST,SWLS\n         MVC   DSSVF,=CL6'LIST  '\n         BAS   R14,DSSRTN\n         XC    WORKD,WORKD\nLSTCNT   LA    R3,TBNLEN(R3)\n         CLI   TBET(R3),TBNTY\n         BE    LSTCNT\nLSTNXT   CLI   TBET(R3),TBFTY\n         BNE   LSTFLG\n         MVC   VFLF(L'TBFNM,R8),TBFNM(R3)\n         MVC   WORKD+L'WORKD-L'TBFDS(L'TBFDS),TBFDS(R3)\n         L     R1,WORKD+4\n         A     R1,WORKD\n         ST    R1,WORKD+4\n         MVC   VFLD(L'VFLD,R8),WORKD+L'WORKD-L'VFLD\n         MVC   VFLL(L'TBFLG,R8),TBFLG(R3)\n         MVC   VFLX(L'VFLX,R8),=CL8' '\n         XC    VFLY(L'VFLY+L'VFLZ,R8),VFLY(R8)\n         B     LSTBCK\nLSTFLG   MVC   VFLX(L'TBBNM+L'TBBVL+L'TBBLG,R8),TBBNM(R3)\n         MVC   VFLF(L'VFLF,R8),=CL8' '\n         XC    VFLD(L'VFLD+L'VFLL,R8),VFLD(R8)\nLSTBCK   OI    SWLST,SWLC\n         ST    R3,SVRA\n         ST    R6,SVRB\n         MVC   CHKCSQ(CHKCSQL),VFLN(R8)\n         B     SETRC4\nLSTCNX   LA    R3,TBFLEN(R3)\n         CLI   TBET(R3),TBENM\n         BNE   LSTNXT\n         ICM   R3,B'1111',TBNNX(R6)\n         BZ    LSTEND\n         ICM   R0,B'1111',TBNRL(R3)\n         BZ    LSTEND\n         LR    R6,R3\n         L     R1,WORKD\n         AR    R1,R0\n         ST    R1,WORKD\n         B     LSTCNT\nLSTEND   MVI   SWLST,0\n         XC    CHKCSQ(CHKCSQL),CHKCSQ\n         B     EXIT\n         EJECT\n*        READ-DIR FUNCTION (CODE 64).\n*        ----------------------------\n         SPACE 1\nDIRFUN   TM    SWRTN,SWDD\n         BZ    *+L'*+8\n         LA    R1,DSBMSG\n         B     SETRC12\n         MVI   SWSRC,0\n         MVI   SWLST,0\nDIRRST   LA    R2,DSTLIB\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN\n         BO    DIRTST\n         DROP  R2\n         MVI   SWDIR,0\n         MVC   DNOMSGF,=CL6'RD-DIR'\n         LA    R1,DNOMSG-1\n         B     SETRC12\nDIRTST   TM    SWDIR,SWDS\n         BO    DIROK\n         XC    ALDERROR(L'ALDERROR+L'ALDINFO),ALDERROR\n         MVC   ALDDSNL(L'ALDDSNL+L'ALDDSN),ALLDSNL\n         MVC   ALDDDN,=CL8' '\n         LA    R1,ALDRBPTR         ALLOCATION PARM. LIST\n        DYNALLOC\n         LTR   R15,R15\n         BZ    DIRDONE\n         CVD   R15,WORKD\n         MVC   ALLMSGR,=XL4'40202020'\n         ED    ALLMSGR,WORKD+6\n         UNPK  ALLMSGD,ALDERROR(L'ALDERROR+1)\n         TR    ALLMSGD(L'ALLMSGD-1),HEXTB-C'0'\n         MVI   ALLMSGD+L'ALLMSGD-1,C' '\n         UNPK  ALLMSGI,ALDINFO(L'ALDINFO+1)\n         TR    ALLMSGI(L'ALLMSGI-1),HEXTB-C'0'\n         MVI   ALLMSGI+L'ALLMSGI-1,C' '\n         LA    R1,ALLMSG-1\n         OI    SWRTN,SWDD\n         B     SETRC12\nDIRDONE  LA    R2,DIRLIB           OPEN DIRECTORY OF DATA-SET\n         USING IHADCB,R2\n         MVC   DCBDDNAM,ALDDDN\n        OPEN   (DIRLIB,(INPUT))\n         TM    DCBOFLGS,DCBOFOPN\n         BO    DIROPN\n         DROP  R2\n         LA    R1,DOPMSG-1\n         OI    SWRTN,SWDD\n         B     SETRC12\nDIROPN   OI    SWDIR,SWDS\nDIROK    TM    SWDIR,SWDC\n         BZ    DIRRBLK\n         CLC   CHKCSQ(CHKCSQR),VFDN(R8)\n         BE    *+L'*+8\n         BAS   R7,RDTRTN\n         B     DIRRST\n         L     R2,SVRA\n         B     DIRCNT\nDIRRBLK  XC    DIRECB,DIRECB\n        READ   DIRECB,SF,MF=E\n        CHECK  DIRECB\n         TM    SWDIR,SWDE\n         BZ    DIRSTRT\n         BAS   R7,RDTRTN\n         CLI   DERMSG-1,0\n         BNE   *+L'*+8\n         LA    R1,DREMSG-1\n         B     SETRC8\n         LA    R1,DERMSG-1\n         B     SETRC8\nDIRSTRT  LA    R2,DIRWA+10         FIRST ENTRY\nDIRLOOP  CLC   0(8,R2),ALLFFS\n         BE    DIRCNT\n         MVC   VFDN(L'VFDN,R8),0(R2)\n         MVC   VFDA(L'VFDA,R8),=CL8' '\n         CLI   11(R2),X'B1'\n         BNE   *+L'*+6\n         MVC   VFDA(L'VFDA,R8),36(R2)\n         OI    SWDIR,SWDC\n         ST    R2,SVRA\n         MVC   CHKCSQ(CHKCSQR),VFDN(R8)\n         B     SETRC4\nDIRCNT   CLC   0(8,R2),DIRWA\n         BE    DIRNXT\n         NI    11(R2),X'1F'\n         XR    R1,R1\n         IC    R1,11(R2)\n         SLL   R1,1\n         LA    R2,12(R1,R2)\n         B     DIRLOOP\nDIRNXT   CLC   DIRWA(8),ALLFFS\n         BNE   DIRRBLK\nDIREOD   BAS   R7,RDTRTN\n         MVC   VFDN(L'VFDN,R8),=CL8' '\n         MVC   VFDA(L'VFDA,R8),=CL8' '\n         XC    CHKCSQ(CHKCSQL),CHKCSQ\n         B     EXIT\n         SPACE 2\n*        MODULE-ID FUNCTION (CODE 127).\n*        ------------------------------\n         SPACE 1\nMIDFUN   MVI   SWSRC,0\n         MVI   SWLST,0\n         BAS   R7,RDTRTN\n         LA    R2,DSTLIB\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN\n         BO    *+L'*+14\n         DROP  R2\n         MVC   DNOMSGF,=CL6'MOD-ID'\n         LA    R1,DNOMSG-1\n         B     SETRC12\n         CLI   VFMN(R8),C' '\n         BNE   *+L'*+14\n         MVC   MDTMSGF,=CL6'MOD-ID'\n         LA    R1,MDTMSG-1\n         B     SETRC8\n         MVC   DSSVF,=CL6'MOD-ID'\n         BAS   R14,DSSRTN\n         MVC   VFMI(L'VFMI+L'VFMD,R8),TBID(R1)\n         B     EXIT\n         SPACE 2\n*        STATISTICS FUNCTION (CODE 128).\n*        -------------------------------\n         SPACE 1\nSTSFUN   LA    R2,DSTLIB\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN\n         BO    *+L'*+14\n         DROP  R2\n         MVC   DNOMSGF,=CL6'STATS '\n         LA    R1,DNOMSG-1\n         B     SETRC12\n         MVC   VFZN(L'VFZN+L'VFZL,R8),TOTLD\n         B     EXIT\n         EJECT\n*        END FUNCTION (CODE 255).\n*        ------------------------\n         SPACE 1\nENDFUN   MVI   SWSRC,0\n         MVI   SWLST,0\n         BAS   R7,RDTRTN\n         LA    R2,DSTLIB           CLOSE/FREE DATA-SET\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN\n         BO    *+L'*+8\n         DROP  R2\n         LA    R1,CLSMSG-1\n         B     SETRC12\n         LM    R3,R5,DESCN         GET A FREE BLDL-LOAD LIST\n         USING DELIST,R3\nENDBLL   CLI   BLDLNME,0\n         BE    ENDBNX\n         LA    R0,BLDLNME\n        DELETE DE=(0)\nENDBNX   BXLE  R3,R4,ENDBLL\n         DROP  R3\n         L     R0,=A(TALEN)        FREE WORK-AREAS\n         L     R1,DESCN\n        FREEMAIN R,A=(1),LV=(0)\n        CLOSE  (DSTLIB)            CLOSE/FREE DATA-SET\n         MVI   ALLDSN,C' '\n         MVC   ALLDSN+1(L'ALLDSN-1),ALLDSN\n         MVC   ALLDDN(L'ALLDDN),ALLDSN\n         MVC   ALLDDNL,=Y(L'ALLDDN)\n         XC    ALLDSORG,ALLDSORG\n         XC    TOTLD,TOTLD\n         XC    TOTLN,TOTLN\n         EJECT\n*        NORMAL / ABNORMAL RETURN.\n*        -------------------------\nEXIT     XR    R10,R10             R.C. = 0\n         B     QUIT\nSETRC4   LA    R10,4               R.C. = 4\n         B     QUIT\nSETRC8   LA    R10,8               R.C. = 8\n         B     LEAVE\nDISABLE  LA    R1,DSBMSG\nSETRC12  LA    R10,12              R.C. = 12\nLEAVE    MVI   SWSRC,0\n         MVI   SWLST,0\n         MVI   SWDIR,0\n         L     R15,4(R13)\n         ST    R1,24(R15)\nQUIT     LTR   R9,R9\n         BZ    *+L'*+4\n         STCM  R10,B'1111',0(R9)\n        $XRET  CC=(R10)\n         EJECT\n******** DSECT SEARCH ROUTINE. ***************************************\n         SPACE 1\nDSSRTN   ST    R14,DSRET\n         LM    R3,R5,DISCN         LOOK IF IN DICTIONARY\n         BAS   R7,DISRCH\n         B     *+L'*+4\n         B     DSSDIF\n         LM    R3,R5,DESCN         GET A FREE BLDL-LOAD LIST\n         USING DELIST,R3\n         CLI   BLDLNME,0\n         BE    DSSDEL\n         BXLE  R3,R4,*-8\n         DROP  R3\n         MVC   BLTMSGF,DSSVF\n         LA    R1,BLTMSG-1\n         B     SETRC8\nDSSDEL   LR    R6,R3\n         USING DELIST,R6\n         MVC   BLDLLIST(L'BLDLLIST),=AL2(1,BLDLLEN)\n         MVC   BLDLNME(L'BLDLNME),VFSN(R8)\n        BLDL   DSTLIB,(R6)         LOCATE DSECT TABLE\n         LTR   R15,R15\n         BZ    DSSFND\n         LA    R0,4\n         CLR   R15,R0\n         BNE   DSSBERR\n         MVC   NTFMSG(L'BLDLNME),BLDLNME\n         XC    BLDLLIST(DELEN),BLDLLIST\n         LA    R1,NTFMSG-1\n         B     SETRC8\nDSSBERR  CVD   R15,WORKD\n         MVC   BLMMSGR,=XL4'40202020'\n         ED    BLMMSGR,WORKD+6\n         CVD   R0,WORKD\n         MVC   BLMMSGC,=XL4'40202020'\n         ED    BLMMSGC,WORKD+6\n         XC    BLDLLIST(DELEN),BLDLLIST\n         LA    R1,BLMMSG-1\n         B     SETRC12\nDSSDERR  ST    R15,WORKD\n         ST    R1,WORKD+4\n         LA    R0,BLDLNME\n        DELETE DE=(0)\n         XC    BLDLLIST(DELEN),BLDLLIST\n         UNPK  DSEMSGR,WORKD(5)\n         TR    DSEMSGR(L'DSEMSGR-1),HEXTB-C'0'\n         MVI   DSEMSGR+L'DSEMSGR-1,C' '\n         UNPK  DSEMSGA,WORKD+4(5)\n         TR    DSEMSGA(L'DSEMSGA-1),HEXTB-C'0'\n         MVI   DSEMSGA+L'DSEMSGA-1,C' '\n         LA    R1,DSEMSG-1\n         B     SETRC8\nDSSFND   LA    R0,BLDLNME\n        LOAD   DE=(0),DCB=DSTLIB,ERRET=DSSDERR\n         STM   R0,R1,BLLDEP        DSECT TABLE LOADED\n         SLL   R1,8\n         SRL   R1,8\n         AL    R1,TOTLN\n         ST    R1,TOTLN\n         LA    R1,1\n         AL    R1,TOTLD\n         ST    R1,TOTLD\n         LR    R1,R0               GET MODULE START ADDRESS\n         LA    R2,L'TBID(R1)       SKIP OVER MODULE-ID\n         LM    R3,R5,DISCN         ADD NEW DICTIONARY ELEMENTS\n         USING DILIST,R3\n         CLI   DINME,0\n         BE    DSSFDI\n         BXLE  R3,R4,*-8\n         B     DSSFULL\nDSSFDI   LR    R7,R3\n         MVC   DINME(L'DINME),TBNNM(R2)\n         ST    R2,DIPTR\n         ST    R0,DIMID\n         CLI   TBET+TBNLEN(R2),TBNTY\n         BNE   *+L'*+8\n         LA    R2,TBNLEN(R2)\n         B     *+L'*+8\n         ICM   R2,B'1111',TBNNX(R2)\n         BZ    DSSEND\n         BXLE  R3,R4,DSSFDI+L'DSSFDI\n         LR    R3,R7\n         XC    DINME(DILEN),DINME\n         BXLE  R3,R4,*-6\nDSSFULL  LA    R0,BLDLNME\n        DELETE DE=(0)\n         XC    BLDLLIST(DELEN),BLDLLIST\n         MVC   DITMSGF,DSSVF\n         LA    R1,DITMSG-1\n         B     SETRC8\n         DROP  R6\nDSSEND   LR    R3,R7\n         BAS   R7,DISRCH\n         B     DSSNOTF\nDSSDIF   L     R1,DIMID\n         L     R6,DIPTR\n         DROP  R3\n         LR    R3,R6\n         L     R14,DSRET\n         BR    R14\nDSSNOTF  MVC   DSFMSG(L'VFSN),VFSN(R8)\n         MVC   DSFMSGT(5),=CL5'DSECT'\n         MVC   DSFMSGF,DSSVF\n         LA    R1,DSFMSG-1\n         B     SETRC8\n         SPACE 1\n         USING DILIST,R3\nDISRCH   CLI   DINME,0\n         BER   R7\n         CLC   DINME(L'DINME),VFSN(R8)\n         BE    4(R7)\n         BXLE  R3,R4,DISRCH\n         BR    R7\n         DROP  R3\n         SPACE 1\n******** READ DIRECTORY TEST ROUTINE. ********************************\n         SPACE 1\nRDTRTN   TM    SWDIR,SWDS\n         BZR   R7\n         MVI   SWDIR,0\n        CLOSE  (DIRLIB)\n         BR    R7\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n*        -------------------------\n         SPACE 1\nWORKD    DC    D'0'\nDESCN    DC    A(*-*,DELEN,*-*)\nDISCN    DC    A(*-*,DILEN,*-*)\nWORKS    DC    CL8' '\nTOTLD    DC    F'0'\nTOTLN    DC    F'0'\nDSRET    DC    F'0'\nSVRA     DC    F'0'\nSVRB     DC    F'0'\nDIRWA    DC    264X'0'\n         SPACE 1\nCHKCSQ   DC    XL(CHKCSQL)'0'\nHEXTB    DC    C'0123456789ABCDEF'\nALLFFS   DC    8X'FF'\nDSSVF    DC    CL6' '\nSWRTN    DC    XL1'0'\nSWRD     EQU   X'80'               ROUTINE DISABLED - SEVERE ERROR\nSWDD     EQU   X'40'               DIRECTORY DISABLED - SEVERE ERROR\nSWSRC    DC    XL1'0'\nSWSD     EQU   X'80'               SEARCH BY DISPLACEMENT\nSWSC     EQU   X'40'               CONTINUE SEARCH BY DISPLACEMENT\nSWSV     EQU   X'20'               SEARCH BY FLAG VALUE\nSWLST    DC    XL1'0'\nSWLS     EQU   X'80'               LIST REQUESTED\nSWLC     EQU   X'40'               CONTINUE LIST\nSWDIR    DC    XL1'0'\nSWDS     EQU   X'80'               RD-DIR REQUESTED\nSWDC     EQU   X'40'               CONTINUE RD-DIR\nSWDE     EQU   X'20'               RD-DIR ERROR DETECTED\n         EJECT\nALLRBPTR DC    A(X'80000000'+ALLRB)     SVC 99 REQUEST BLOCK POINTER\nALLRB    DS    0F                  SVC 99 REQUEST BLOCK\n         DC    AL1(ALLRBLN)             RB LENGTH IN BYTES\n         DC    AL1(S99VRBAL)            VERB CODE (DSNAME ALLOC.)\n         DC    AL1(S99NOCNV+S99NOMNT,0) FLAGS 1\nALLERROR DC    XL2'0'                   ERROR CODE\nALLINFO  DC    XL2'0'                   INFO CODE\n         DC    A(ALLTUP)                POINTER TO TEXT UNIT POINTERS\n         DC    XL4'0'                   RESERVED\n         DC    XL4'0'                   FLAGS 2\nALLRBLN  EQU   *-ALLRB             RB LENGTH\nALLTUP   DS    0F                  TEXT UNIT POINTERS\n         DC    A(ALLTUKY1)\n         DC    A(ALLTUKY2)\n         DC    A(ALLTUKY3)\n         DC    A(ALLTUKY4)\n         DC    A(X'80000000'+ALLTUKY5)\nALLTUKY1 DC    AL2(DALDSNAM),AL2(1)     DSNAME\nALLDSNL  DC    AL2(*-*)                 LENGTH OF DSNAME\nALLDSN   DC    CL44' '                  DSNAME\nALLTUKY2 DC    AL2(DALSTATS),AL2(1,1),XL1'08'    SHR STATUS\nALLTUKY3 DC    AL2(DALCLOSE),AL2(0)     UNALLOC AT CLOSE\nALLTUKY4 DC    AL2(DALRTDDN),AL2(1)     DDNAME RETURN\nALLDDNL  DC    AL2(L'ALLDDN)            LENGTH OF DDNAME\nALLDDN   DC    CL8' '                   DDNAME\nALLTUKY5 DC    AL2(DALRTORG),AL2(1,2)   DSORG RETURN\nALLDSORG DC    XL2'0'                   DSORG\n         SPACE 1\nALDRBPTR DC    A(X'80000000'+ALDRB)     SVC 99 REQUEST BLOCK POINTER\nALDRB    DS    0F                  SVC 99 REQUEST BLOCK\n         DC    AL1(ALDRBLN)             RB LENGTH IN BYTES\n         DC    AL1(S99VRBAL)            VERB CODE (DSNAME ALLOC.)\n         DC    AL1(S99NOCNV+S99NOMNT,0) FLAGS 1\nALDERROR DC    XL2'0'                   ERROR CODE\nALDINFO  DC    XL2'0'                   INFO CODE\n         DC    A(ALDTUP)                POINTER TO TEXT UNIT POINTERS\n         DC    XL4'0'                   RESERVED\n         DC    XL4'0'                   FLAGS 2\nALDRBLN  EQU   *-ALDRB             RB LENGTH\nALDTUP   DS    0F                  TEXT UNIT POINTERS\n         DC    A(ALDTUKY1)\n         DC    A(ALDTUKY2)\n         DC    A(ALDTUKY3)\n         DC    A(X'80000000'+ALDTUKY4)\nALDTUKY1 DC    AL2(DALDSNAM),AL2(1)     DSNAME\nALDDSNL  DC    AL2(*-*)                 LENGTH OF DSNAME\nALDDSN   DC    CL44' '                  DSNAME\nALDTUKY2 DC    AL2(DALSTATS),AL2(1,1),XL1'08'    SHR STATUS\nALDTUKY3 DC    AL2(DALCLOSE),AL2(0)     UNALLOC AT CLOSE\nALDTUKY4 DC    AL2(DALRTDDN),AL2(1)     DDNAME RETURN\nALDDDNL  DC    AL2(L'ALLDDN)            LENGTH OF DDNAME\nALDDDN   DC    CL8' '                   DDNAME\n         EJECT\n         DC    AL1(L'FCNMSG)\nFCNMSG   DC    C'INVALID FUNCTION CODE REQUESTED'\n         DC    AL1(L'STRMSG)\nSTRMSG   DC    C'DATA-SET ALREADY STARTED ONCE - START REJECTED'\n         DC    AL1(L'DSNMSG)\nDSNMSG   DC    C'INVALID DATA-SET NAME REQUESTED'\n         DC    AL1(LALLMSG)\nALLMSG   DC    C'ALL. ERR. : DARC='\nALLMSGD  DC    CL5' ',C'INFO='\nALLMSGI  DC    CL5' ',C'R15='\nALLMSGR  DC    CL4' '\nLALLMSG  EQU   *-ALLMSG\n         DC    AL1(L'DSOMSG)\nDSOMSG   DC    C'INVALID DATA-SET ORGANIZATION (NOT PO)'\n         DC    AL1(L'OPNMSG)\nOPNMSG   DC    C'ERROR AT OPEN OF DATA-SET'\n         DC    AL1(L'DOPMSG)\nDOPMSG   DC    C'DATA-SET DIRECTORY OPEN ERROR'\n         DC    AL1(LDNOMSG)\nDNOMSG   DC    C'DATA-SET IS NOT OPENED - '\nDNOMSGF  DC    CL6' ',C' REJECTED'\nLDNOMSG  EQU   *-DNOMSG\n         DC    AL1(LMDTMSG)\nMDTMSG   DC    C'NO DSECT TABLE NAME - '\nMDTMSGF  DC    CL6' ',C' REJECTED'\nLMDTMSG  EQU   *-MDTMSG\n         DC    AL1(LBLTMSG)\nBLTMSG   DC    C'BLDL-LOAD TABLE FULL - '\nBLTMSGF  DC    CL6' ',C' REJECTED'\nLBLTMSG  EQU   *-BLTMSG\n         DC    AL1(L'NTFMSG)\nNTFMSG   DC    C'         : DSECT TABLE NAME NOT FOUND'\n         DC    AL1(LBLMMSG)\nBLMMSG   DC    C'BLDL ERROR : R15='\nBLMMSGR  DC    CL4' ',C' R0='\nBLMMSGC  DC    CL4' '\nLBLMMSG  EQU   *-BLMMSG\n         DC    AL1(LDSEMSG)\nDSEMSG   DC    C'LOAD ERROR : R15='\nDSEMSGR  DC    CL9' ',C'R1='\nDSEMSGA  DC    CL9' '\nLDSEMSG  EQU   *-DSEMSG\n         DC    AL1(LDITMSG)\nDITMSG   DC    C'DICTIONARY TABLE FULL - '\nDITMSGF  DC    CL6' ',C' REJECTED'\nLDITMSG  EQU   *-DITMSG\n         DC    AL1(LDSFMSG)\nDSFMSG   DC    C'         : '\nDSFMSGT  DC    C'      NAME NOT FOUND - '\nDSFMSGF  DC    CL6' ',C' REJECTED'\nLDSFMSG  EQU   *-DSFMSG\n         DC    AL1(LDPNMSG)\nDPNMSG   DC    C'X'''\nDPNMSGD  DC    CL4' '\n         DC    C'  : DISPLACEMENT NOT FOUND - SEARCH REJECTED'\nLDPNMSG  EQU   *-DPNMSG\n         DC    AL1(LDVNMSG)\nDVNMSG   DC    C'X'''\nDVNMSGV  DC    CL4' '\n         DC    C'  : FLAG VALUE NOT FOUND - SEARCH REJECTED'\nLDVNMSG  EQU   *-DVNMSG\n         DC    AL1(L'CLSMSG)\nCLSMSG   DC    C'DATA-SET IS NOT OPENED - CLOSE REJECTED'\n         DC    AL1(L'DSBMSG)\nDSBMSG   DC    C'ROUTINE IS DISABLED DUE TO PREVIOUS ERROR'\n         DC    AL1(L'DIRMSG)\nDIRMSG   DC    C'READ DIRECTORY IS DISABLED DUE TO PREVIOUS ERROR'\n         DC    AL1(L'DERMSG)\nDERMSG   DC    CL72' '\n         DC    AL1(L'DREMSG)\nDREMSG   DC    C'READ DIRECTORY ERROR - RD-DIR TRUNCATED'\n         SPACE 2\n        PRINT  NOGEN\nDSTLIB  DCB    DDNAME=XXXXXXXX,DSORG=PO,MACRF=(R)\nDIRLIB  DCB    DDNAME=XXXXXXXX,DSORG=PS,MACRF=(R),                     1\n               EODAD=DIREOD,SYNAD=DIRERR,                              2\n               KEYLEN=8,RECFM=F,BLKSIZE=256,LRECL=256\n        READ   DIRECB,SF,DIRLIB,DIRWA,'S',MF=L\n        PRINT  GEN\n         SPACE 2\n        LTORG\n         EJECT\n******** READ DIRECTORY ERROR EXIT ROUTINE. **************************\n         SPACE 1\n         CNOP  0,4\n         USING *,R15\nDIRERR   STM   R10,R12,SVREG\n         LR    R10,R15\n         DROP  R15\n         USING DIRERR,R10\n         L     R15,=A(SWDIR)\n         OI    0(R15),SWDE\n         L     R11,=A(DERMSG-1)\n         MVI   0(R11),0\n         MVI   1(R11),C' '\n         MVC   2(L'DERMSG-1,R11),1(R11)\n        SYNADAF ACSMETH=BSAM\n         CLI   69(R1),C'*'\n         BE    DIRERR3             UNSIGNIFICANT MESSAGE\n         CLI   8(R1),C' '\n         BE    DIRERR1\n         UNPK  56(7,R1),9(4,R1)    BINARY INFORMATION\n         L     R12,=A(HEXTB-C'0')\n         TR    56(6,R1),0(R12)\n         MVI   62(R1),C' '\n         UNPK  63(5,R1),12(3,R1)\n         TR    63(4,R1),0(R12)\n         MVI   67(R1),C','\n         B     DIRERR2\nDIRERR1  MVC   56(12,R1),8(R1)\nDIRERR2  LA    R12,56(R1)\n         LA    R15,71(R12)\n         CLI   0(R15),C' '\n         BNE   *+L'*+12\n         BCTR  R15,0\n         CLR   R15,R12\n         BH    *-12\n         B     DIRERR3\n         CLI   0(R12),C' '\n         BNE   *+L'*+14\n         LA    R12,1(R12)\n         B     *-12\n         MVC   1(*-*,R11),0(R12)\n         SLR   R15,R12\n         EX    R15,*-8\n         LA    R15,1(R15)\n         STC   R15,0(R11)\nDIRERR3 SYNADRLS\n         LM    R10,R12,SVREG\n         DROP  R10\n         BR    R14\n         SPACE 1\nSVREG    DC    3F'0'\n         SPACE 1\n        LTORG\n         EJECT\n        PRINT  NOGEN\n        IEFZB4D0\n        IEFZB4D2\n        DCBD   DSORG=PO,DEVD=DA\n         SPACE 1\nDELIST   DSECT ,                   BLDL-LOAD LIST ELEMENT\nBLDLLIST DS    F\nBLDLNME  DS    CL8\n         DS    XL6\n         DS    XL62\nBLDLLEN  EQU   *-BLDLNME\nBLLDEP   DS    F\nBLLDLG   DS    F\nDELEN    EQU   (((*-BLDLLIST)+7)/8)*8\n         SPACE 1\nDILIST   DSECT ,                   DICTIONARY ELEMENT\nDINME    DS    CL8\nDIPTR    DS    A\nDIMID    DS    A\nDILEN    EQU   *-DINME\n         SPACE 2\nTDELEN   EQU   NDE*DELEN\nTDILEN   EQU   (((DILEN*NDI)+7)/8)*8\nTALEN    EQU   TDELEN+TDILEN\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DTUR$": {"ttr": 13062, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x05O\\x00\\x89\\x05O\\x14#\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-02-23T00:00:00", "modifydate": "1989-02-23T14:23:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//DTUR     JOB (........),'INSTALL  - DTUSE -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS2,MBR=DTUR\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ENTRY   DTUSE\n  NAME    DTUSE(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DTUR@": {"ttr": 13064, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x06\\x8f\\x00\\x89\\x06\\x8f\\x15A\\x00s\\x00s\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-03-09T00:00:00", "modifydate": "1989-03-09T15:41:00", "lines": 115, "newlines": 115, "modlines": 0, "user": "SYSPAJA"}, "text": "1   07/03/89\n                                                      DTUR      1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     DSECT'S TABLES USE ROUTINE      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    This routine allows an easier way to use the dsect's\n  ---------    tables which are created by the \"GDTUTIL\" program.\n               Note : the routine is serially reusable.\n\n  Calling sequence : CALL DTUSE,(A,B),VL\n  ------------------            (A)\n\n         Where : A - is the address of a variable number of consecutive\n                     fields (numbered by @) information as below\n                       @-1 (AL1) = a function code which\n                         if = 0 (START), then\n                           @-2 (AL1) = data-set name length\n                           @-3 (CL...) = data-set name\n                         if = 1 (SEARCH) or 2 (LIST), then\n                           @-2 (CL8) = dsect table name\n                           @-3 (CL8) = dsect field name\n                           @-4 (XL2) = field displacement value\n                           @-5 (XL2) = field name length value\n                           @-6 (CL8) = flag name\n                           @-7 (XL2) = flag value\n                           @-8 (XL2) = flag name length value\n                         if = 64 (RD-DIR), then\n                           @-2 (CL8) = dsect name\n                           @-3 (cl8) = alias of name\n                         if = 127 (MOD-ID), then\n                           @-2 (CL8) = dsect table name\n                           @-3 (CL8) = dsect macro name\n                           @-4 (CL16) = date and time of assembly\n                                        (format is ' MM/DD/YY HH.MM ')\n                         if = 128 (STATS), then\n                           @-2 (XL4) = total number of loads\n                           @-3 (XL4) = total load-modules length\n                                           in double-words\n                           Note : counters are reset at END\n                         if = 255 (END), then none\n                     (no alignment required)\n1   07/03/89\n                                                      DTUR      2/3.\n\n                 B - is the address of the indicator response (format\n                     XL4, no alignment) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n                      0 - operation correctly ended.\n                      4 - operation may continue when SEARCH function\n                          (by field name or displacement, flag value),\n                          RD-DIR function or LIST function.\n                      8 - a warning error has been detected.\n                     12 - a severe error has been detected.\n                     At exit and only when an error is detected (RC 8\n                     or 12), the register 1 contains a pointer to a\n                     message text as follows\n                     R1 --->     DC AL1(L'MSG)\n                             MSG DC C'...error message text...'\n\n  How-to-use the various functions of this routine :\n  --------------------------------------------------\n    A. - as first operation you must call the START function, then\n    B. - use the SEARCH function to obtain information about a field\n         name, a field displacement, a flag name or a flag value in a\n         dsect. The request can be done as follows :\n         1. specify the dsect name and a field name (@-2 and @-3, @-6\n            must be blank) to receive back the field values (@-4 and\n            @-5). If RC=0, the field has no flags defined, but if RC=4,\n            then you may continue (retain @-2 to @-8 as they are) to\n            receive back the flags name and values (@-6, @-7 and @-8)\n            until RC=0 which say you no more.\n         2. specify the dsect name and a field displacement value (@-2\n            and @-4, @-3 and @-6 must be blank) to receive back the\n            field name and length (@-3 and @-5). As long as RC=4, you\n            may continue to get all fields names (retain @-2 to @-8 as\n            they are) having the same displacement in the dsect, until\n            RC=0 which say you no more.\n         3. specify the dsect name and a flag name (@-2 and @-6, @-3\n            must be blank) to receive back the field name, values and\n            the flag values (@-3, @-4, @-5, @-7 and @-8).\n         4. specify the dsect name, a field name and a flag value (@-2,\n            @-3 and @-7, @-6 must be anything but not blank) to receive\n            the flag names (@-6, also passed back @-4, @-5 and @-8).\n            As long as RC=4, you may continue to get all flags names\n            (retain @-2 to @-8 as they are) having the same value in\n            the field of the dsect, until RC=0 which say you no more.\n            Note : the field name where the flag value is searched must\n                   be known.\n1   07/03/89\n                                                      DTUR      3/3.\n\n    C. - or use the LIST function for a dsect (@-2) to receive back\n         sequentially all the fields (flag name, @-6 is blank, and\n         values, @-7 and @-8 are zero) and flags (field name, @-3 is\n         blank, and values, @-4 and @-5 are zero) which are defined\n         in the dsect. The LIST may continue until RC=4 (retain @-2 to\n         @-8 as they are) and is terminated when RC=0.\n    D. - or use the READ-DIR function to receive back sequentially all\n         the dsect names (@-2, @-3 is blank) or the alias names (@-2)\n         of a dsect name (@-3). The READ-DIR may continue until RC=4\n         (retain @-2 and @-3 as they are) and is terminated when RC=0.\n    E. - or use the MODULE-ID function to obtain the dsect macro name\n         (@-3) and the date/time (@-4) of the module assembly for a\n         specific dsect name(@-2).\n    F. - at any time, you may use the STATS function to control how the\n         space needed for tables has grown.\n    G. - finally call the END function to terminate the processing. At\n         this point, if desired, you may recall the routine to START a\n         new process again. Note, this is the way to free all core\n         storage space and start again with the same or another dsects\n         tables data-set.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DVTYUN": {"ttr": 13067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x884/\\x00\\x884/\\x15\\x16\\x00z\\x00z\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-07T00:00:00", "modifydate": "1988-12-07T15:16:00", "lines": 122, "newlines": 122, "modlines": 0, "user": "SYSPAJA"}, "text": "DTUN     TITLE 'DEVICE TYPE TO UNIT NAME SUBROUTINE.'\nDVTYUN   START 0\n         SPACE 1\n* CALLING SEQUENCE : CALL DVTYUN,(A,B,C),VL\n* ------------------             (A,B)\n*\n*        WHERE : A - IS THE ADDRESS OF THE FOUR BYTES FIELD CONTAINING\n*                    THE DEVICE TYPE (HEXADECIMAL FORMAT, EXACTLY AS\n*                    UCBTYP FIELD OF THE UCB).\n*\n*                B - IS THE ADDRESS OF AN EIGTH BYTES FIELD RECEIVING\n*                    THE CORRESPONDING UNIT NAME RIGHT PADDED WITH\n*                    BLANKS.\n*\n*                C - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                    F BOUNDARY) IF SUPPLIED (OPTIONAL).\n*\n*        RETURN CODES (REGISTER 15) :\n*\n*                        0 = UNIT NAME SUPPLIED.\n*                        4 = INVALID DEVICE TYPE.\n*                        8 = UNIT NAMES TABLE SPACE OVERFLOW.\n*                       12 = CALLING SEQUENCE OR PARAMETER ALIGNMENT\n*                            ERROR.\n*\n* ORIGIN :     ROUTINE 'DTYP2UNT' (CONVERT UCB-TYPE HEX DEVICE CODE\n* --------     TO UNIT NAME - JOHN A SHELL) FROM FILE 360 OF THE CBT\n*              86 FEB TAPE.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\nDVTYUN  AMODE  24\nDVTYUN  RMODE  24\n         SPACE 1\n        $DEFREG\nNTBL     EQU   200                 MAXIMUM UNIT NAMES IN TABLE SPACE\n         EJECT\n        $XENT  BASE=R12\n         XR    R7,R7\n         LR    R8,R7\n         LR    R9,R7\n         LR    R10,R7\n         TM    0(R1),X'80'\n         BO    ERSA\n         TM    4(R1),X'80'\n         BO    GADD\n         TM    8(R1),X'80'\n         BZ    ERSA\n         TM    11(R1),X'03'\n         BNZ   ERSA\n         L     R9,8(R1)\n         LA    R9,0(R9)\nGADD     L     R8,4(R1)\n         LA    R8,0(R8)\n         L     R7,0(R1)\n         LA    R7,0(R7)\n         MVC   0(8,R8),=CL8' '\n         LM    R3,R5,SCAN          UNIT NAMES TABLE SCAN ADDRESSES\n         CLI   0(R3),C' '          ALREADY EXISTS?\n         BNE   LOOP                YES\n        $TSWXA 31,EXPAND=ONLY      ENTER 31-BIT MODE\n         L     R1,CVTPTR           CVT ADDRESS\n         USING CVTMAP,R1\n         L     R1,CVTJESCT         JES CONTROL TABLE\n         DROP  R1\n         USING JESCT,R1            ADDRESS TO DSECT\n         L     R1,JESEDT           EDT POINTER\n         DROP  R1\n         L     R5,EDTLUVSP(,R1)    LOOK-UP SECTION\n         L     R2,LUVENTNO(,R5)    NUMBER OF UNIT NAMES\n         CH    R2,=Y(NTBL)         TABLE LARGE ENOUGH?\n         BH    OVERFL              NO\n         LA    R0,L'LUVENTRY       YES, LENGTH OF AN ENTRY\n         LA    R1,LUVENTRY(,R5)    FIRST ENTRY\n         B     CPYUN\nBUMP     ALR   R3,R4\n         ALR   R1,R0\nCPYUN    MVC   0(12,R3),LUVUNAME(R1)    COPY UNIT NAME AND DEVICE TYPE\n         BCT   R2,BUMP\nOVERFL  $TSWXA 24,EXPAND=ONLY      BACK 24-BIT MODE\n         LTR   R2,R2\n         BNZ   EROV\n         ST    R3,SCAN+8           SET END OF TABLE SCAN ADDRESS\n         LM    R3,R5,SCAN          SET SCAN ADDRESSES\nLOOP     CLC   0(4,R7),8(R3)       IS THIS DEVICE TYPE?\n         BE    FOUND               YES\n         BXLE  R3,R4,LOOP          POINT TO NEXT IF ANY\n         LA    R10,4\n         B     LEAVE\nEROV     LA    R10,8\n         B     LEAVE\nERSA     LA    R10,12\n         B     LEAVE\nFOUND    MVC   0(8,R8),0(R3)       SET UNIT NAME\nLEAVE    LTR   R9,R9\n         BZ    EXIT\n         ST    R10,0(R9)           STORE INDICATOR\nEXIT    $XRET  CC=(R10)\n         EJECT\nSCAN     DC    A(UNTB,L'UNTB,*-*)\n         SPACE 1\n        LTORG\n         SPACE 2\nUNTB     DC    (NTBL)CL12' '       UNIT NAMES TABLE SPACE\n         SPACE 1\n*        ----------------------------------------------------\n*        DSECT IEFZB421 SHOULD BE SUBSTITUTED WHEN AVAILABLE.\n*        ----------------------------------------------------\n         SPACE 1\nEDTLUVSP EQU   28,4           POINTER TO LOOK UP VALUE SECTION\nLUVENTNO EQU   8,4            NUMBER OF ENTRIES IN THIS SECTION\nLUVENTRY EQU   16,32          TABLE OF LOOK UP ENTRIES\nLUVUNAME EQU   0,8            UNIT NAME IN EBCDIC\n         SPACE 1\n        PRINT  NOGEN\n        CVT    DSECT=YES,LIST=YES\n        IEFJESCT\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DVTYUN$": {"ttr": 13070, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x1f\\x00\\x88\\t\\x1f\\x14E\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-31T00:00:00", "modifydate": "1988-03-31T14:45:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//DVTYUN   JOB (........),'INSTALL  - DVTYUN -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS3,MBR=DVTYUN\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ENTRY   DVTYUN\n  NAME    DVTYUN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DVTYUN@": {"ttr": 13072, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x87\\x11\\x7f\\x00\\x87\\x11\\x7f\\x15D\\x00'\\x00'\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-04-27T00:00:00", "modifydate": "1987-04-27T15:44:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SYSPAJA"}, "text": "1   24/04/87\n                                                      DVTYUN    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      DEVICE TYPE TO UNIT NAME.      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL DVTYUN,(A,B,C),VL\n  ------------------             (A,B)\n         Where : A - is the address of the four bytes field containing\n                     the device type (hexadecimal format, exactly as\n                     UCBTYP field of the UCB).\n\n                 B - is the address of an eigth bytes field receiving\n                     the corresponding unit name right padded with\n                     blanks.\n\n                 C - receives the return code (format FULLWORD -\n                     F boundary) if supplied (optional).\n\n         Return codes (register 15) :\n\n                         0 = unit name supplied.\n                         4 = invalid device type.\n                         8 = unit names table space overflow.\n                        12 = calling sequence or parameter alignment\n                             error.\n\n  Assembler macro : $DVTYUN A,B,C\n  -----------------\n\n         Where C is optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  Origin :     Routine DTYP2UNT (convert UCB-type hex device code\n  --------     to unit name - John A SHELL) from file 360 of the CBT\n               86 FEB tape.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DYNALL": {"ttr": 13313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x07\\x0f\\x00\\x92\\x07\\x0f\\x14W\\x04\\x1f\\x04\\x1f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-03-10T00:00:00", "modifydate": "1992-03-10T14:57:00", "lines": 1055, "newlines": 1055, "modlines": 0, "user": "SYSPAJA"}, "text": "DYAL     TITLE 'DYNAMIC DATA-SET ALLOCATION ROUTINE.'\n*        DATA SET S062A10 : AT LEVEL 001 AS OF 03/09/77.\n*        DATA SET S062A10 : AT LEVEL 002 AS OF 10/22/76.\n         SPACE 1\nDYNALL   START 0\n         SPACE 1\n* PURPOSE :\n* ---------\n*\n* THIS MODULE WILL FUNCTION ONLY IN OS/VS2 RELEASE 2 AND LATER\n* RELEASES (IE. MVS). IT ALLOWS THE USER TO PERFORM ANY ONE OF THE\n* FOLLOWING OPERATIONS :\n*\n*        1.    DYNAMICALLY ALLOCATE AN EXISTING DISK DATA SET. ANY\n*                          DISK DATA SET, INCLUDING AN ISAM DATA SET,\n*                          MAY BE ALLOCATED.\n*        2.    DYNAMICALLY ALLOCATE A NEW DISK DATA SET. ANY VALID\n*                          DISK DATA SET ORGANIZATION EXCEPT ISAM\n*                          MAY BE SPECIFIED.\n*        3.    DYNAMICALLY ALLOCATE A 'DD DUMMY' DATA SET.\n*        4.    DYNAMICALLY DE-ALLOCATE A PREVIOUS ALLOCATION.\n*\n* IT IS ASSUMED THAT THE USER OF THIS MODULE HAS A GOOD WORKING\n* KNOWLEDGE OF OS/VS2 JCL AS DESCRIBED IN THE OS/VS2 JCL MANUAL\n* (GC28-0692). THE USER OF THIS MODULE WILL BUILD A LIST OF\n* PARAMETERS IN MUCH THE SAME WAY AS HE WOULD FILL OUT A 'DD CARD'.\n* THE INFORMATION IN THE PARAMETER LIST WILL BE USED TO DO THE\n* REQUESTED FUNCTION.\n*\n* THE LINKAGE TO THIS MODULE CAN BE MADE WITH A STANDARD OS 'CALL',\n* 'LINK' OR 'ATTACH'. THE ADDRESS LIST SPECIFIED IN THE 'CALL' (OR\n* 'LINK' OR 'ATTACH') MUST ALWAYS INCLUDE THE ADDRESS OF THE\n* PARAMETER LIST (DESCRIBED BELOW) AS ITS FIRST OR ONLY ENTRY. THE\n* SECOND (OPTIONAL) ADDRESS IN THE LIST MUST BE THE ADDRESS OF 2\n* CONSECUTIVE FULLWORDS IN THE CALLER'S PROGRAM. R13 MUST CONTAIN\n* THE ADDRESS OF A STANDARD OS SAVE AREA. EXAMPLES OF CALL'S ARE\n* SHOWN BELOW.\n*\n*        CALL  DYNALL,(DYNLIST),VL\n*        CALL  DYNALL,(DYNLIST,RCODES),VL\n*\n* UPON RETURN FROM THIS MODULE, R0 AND R15 WILL CONTAIN CODES\n* INDICATING HOW THE REQUEST COMPLETED. IF THE SECOND ITEM IS NAMED\n* IN THE ADDRESS LIST, THEN THE VALUES PLACED IN R0 AND R15 WILL\n* ALSO BE STORED IN ITS FIRST AND SECOND WORDS, RESPECTIVELY. THIS\n* WILL ALLOW PROGRAMS WRITTEN IN COBOL OR OTHER HIGH LEVEL LANGUAGES\n* TO USE THIS MODULE. DETAILED INFORMATION ABOUT THE RETURN CODES IS\n* GIVEN FOLLOWING THE INFORMATION ABOUT THE PARAMETER LIST.\n*\n* THIS MODULE IS RE-ENTERABLE.\n         EJECT\n        $DYNLIST\n         EJECT\n* RETURN CODES :\n* --------------\n*\n* THIS MODULE USES THE DYNAMIC ALLOCATION ROUTINE DESCRIBED IN THE\n* OS/VS2 SYSTEMS PROGRAMMING LIBRARY : JOB MANAGEMENT MANUAL\n* (GC28-0627). THIS MODULE DOES SOME PRELIMINARY EDITING PRIOR TO\n* REQUESTING DYNAMIC ALLOCATION. IF IT FINDS SOME ERROR WHICH\n* PREVENTS COMPLETION OF THE REQUEST, IT WILL PLACE 15 (DECIMAL) IN\n* R15. R0 WILL CONTAIN AN OFFSET FROM THE BEGINNING OF THE PARAMETER\n* LIST TO SHOW WHICH FIELD IS IN ERROR. FOR EXAMPLE, IF THE\n* 'DSNDISP' FIELD CONTAINS 'PASS' (WHICH IS INVALID), R0 WILL CONTAIN\n* 76 (DECIMAL) AND R15 WILL CONTAIN 15 (DECIMAL).\n*\n* UNLESS THIS MODULE DETECTS AN ERROR, IT WILL MAKE A REQUEST TO THE\n* DYNAMIC ALLOCATION ROUTINE. THE DYNAMIC ALLOCATION ROUTINE ISSUES\n* A RETURN CODE IN R15 AND ALSO GIVES AN 'ERROR REASON CODE' AND AN\n* 'INFORMATIONAL REASON CODE'. EACH OF THE TWO 'REASON CODES' IS 2\n* BYTES LONG. THIS MODULE WILL PLACE THE 'ERROR REASON CODE' IN THE\n* FIRST 2 BYTES OF R0 AND THE 'INFORMATIONAL REASON CODE' IN THE\n* SECOND 2 BYTES OF R0. THIS MODULE WILL LEAVE THE DYNAMIC\n* ALLOCATION RETURN CODE IN R15. THE MEANING OF THESE CODES CAN BE\n* FOUND IN THE MANUAL (GC28-0627) MENTIONED ABOVE.\n*\n* IT WILL ALWAYS BE POSSIBLE TO KNOW THE MEANING OF AN R0 RETURN CODE\n* (IE. DOES IT CONTAIN AN OFFSET OR DOES IT CONTAIN 'REASON CODES'),\n* SINCE THE DYNAMIC ALLOCATION ROUTINE NEVER ISSUES A 15 (DECIMAL)\n* RETURN CODE. THEREFORE, WHEN R15 CONTAINS 15 (DECIMAL), R0 MUST\n* CONTAIN AN OFFSET.\n*\n* IF THE PROGRAM THAT INVOKES THIS MODULE PASSES 2 ADDRESSES IN ITS\n* ADDRESS LIST, THIS MODULE WILL PLACE THE CONTENTS OF R0 AND R15 IN\n* THE FIRST AND SECOND FULLWORDS, RESPECTIVELY, OF THE SECOND ITEM IN\n* THE ADDRESS LIST.\n         SPACE 2\n        PRINT  NOGEN\n        IEFZB4D0\n        IEFZB4D2\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 1\nDYNALL   CSECT                     RESTORE ORIGINAL CSECT.\n         EJECT\nWRKDSECT DSECT                     WORK AREAS DESCRIPTION.\n         SPACE 1\nSVA      DS    18F                 SAVE AREA.\nREQBKPTR DS    F\nWKRTNVOL DS    F\nWKRTDSRG DS    F\n         DS    F\nDBLWORD  DS    D\n         DS    4F\n         SPACE 1\nWRKL     EQU   1024                WORK AREAS LENGTH.\nDYNWRKL  EQU   (WRKL-(*-SVA))\nDYNWORK  DS    (DYNWRKL)X\n         SPACE 2\nDYNALL   CSECT                     RESTORE ORIGINAL CSECT.\n         SPACE 2\n        $DEFREG\n         EJECT\n*        REGISTERS USE :\n         SPACE 1\n*              R6  : ADDRESS OF REQUEST BLOCK.\n*              R7  : HAS OFFSET OF CURRENT ENTRY IN PARAMETER LIST\n*                    FOR DYNAMIC ALLOCATION.\n*              R8  : ADDRESS OF CURRENT TEXT POINTER.\n*              R9  : ADDRESS OF CURRENT TEXT UNIT.\n*              R10 : ADDRESS OF CALLER'S PARAMETER LIST.\n*              R11 : BASE REGISTER.\n*              R13 : WORK AREA ADDRESS (SAVE AREA IS FIRST 72 BYTES).\n         SPACE 2\n        $XENT  BASE=R11,LV=WRKL,TYPE=RENT\n         EJECT\n         USING WRKDSECT,R13\n         L     R10,0(0,R1)         PICK UP PARAMETER LIST ADDRESS.\n         USING DYNLIST,R10\n         LR    R14,R13             SET UP FOR CLEAR OF WORK AREA.\n         L     R15,WORKLEN\n         LA    R0,18*4\n         AR    R14,R0\n         SR    R15,R0\n         SR    R0,R0\n         LR    R1,R0\n         MVCL  R14,R0              CLEAR WORK AREA TO ALL X'00'.\n         LA    R6,DYNWORK\n         USING S99RB,R6\n         ST    R6,REQBKPTR         POINT TO REQUEST BLOCK.\n         OI    REQBKPTR,X'80'\n         LA    R1,S99RBEND-S99RB   LENGTH OF REQUEST BLOCK.\n         STC   R1,S99RBLN\n         CLC   DSNAME,=XL44'0'     CHECK FOR UNALLOCATION REQUEST.\n         BNE   *+L'*+8\n         MVI   S99VERB,S99VRBUN    REQUEST UNALLOCATION.\n         B     *+L'*+8\n         MVI   S99VERB,S99VRBAL    REQUEST ALLOCATION.\n         OI    S99FLG11,S99NOCNV+S99NOMNT\n         LA    R8,S99RBEND         PICK UP ADDRESS FOR TEXT POINTERS.\n         ST    R8,S99TXTPP\n         L     R9,TXPTRSPC         PICK UP SPACE FOR TEXT POINTERS.\n         ALR   R9,R8               POINT TO FIRST TEXT UNIT.\n         USING S99TUNIT,R9\n         EJECT\n* DDNAME **************************\n         SPACE 1\n         LA    R7,DDNAME-DYNLIST   INIT 'OFFSET' REGISTER.\n         CLI   S99VERB,S99VRBUN    HAS UNALLOCATION BEEN REQUESTED?\n         BNE   *+L'*+8\n         LA    R1,DUNDDNAM\n         B     *+L'*+4\n         LA    R1,DALDDNAM\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         LA    R14,DDNAME          FIND OUT ACTUAL LENGTH OF DDNAME.\n         LA    R15,L'DDNAME\n         BAL   R1,PP1\n         LTR   R15,R15\n         BNP   QQ1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE DDNAME.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT.\n         CLI   S99VERB,S99VRBUN    HAS UNALLOCATION BEEN REQUESTED?\n         BNE   AA1                 GO DO OTHER REQUEST.\n         SPACE 1\n* DSUFORCE ************************\n         SPACE 1\n         LA    R7,DSUFORCE-DYNLIST\n         LA    R14,DSUFORCE\n         LA    R15,L'DSUFORCE\n         BAL   R1,PP1              GET DSUFORCE LENGTH.\n         LTR   R15,R15\n         BNP   MM1\n         CLC   DSUFORCE,=CL8'FORCE '\n         BNE   MM1\n         LA    R1,DUNUNALC         S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY              CLEAR.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         B     MM1                 GO DO REQUEST.\n         SPACE 1\n* DSNAME **************************\n         SPACE 1\nAA1      LA    R7,DSNAME-DYNLIST   OFFSET.\n         CLC   DSNAME,=CL44'NULLFILE '  CHECK FOR DUMMY ALLOCATION.\n         BNE   AA1A\n         LA    R1,DALDUMMY         S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY              CLEAR.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUENT         NEXT TEXT UNIT.\n         B     AA10\nAA1A     LA    R14,DSNAME\n         LA    R15,L'DSNAME\n         BAL   R1,PP1              GET DSNAME LENGTH.\n         LTR   R15,R15\n         BNP   AA2\n         LA    R1,DALDSNAM\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE DSNAME.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT.\n         SPACE 1\n* DSMEMBER ************************\n         SPACE 1\nAA2      LA    R7,DSMEMBER-DYNLIST\n         LA    R14,DSMEMBER\n         LA    R15,L'DSMEMBER\n         BAL   R1,PP1              GET DSMEMBER LENGTH.\n         LTR   R15,R15\n         BNP   AA3\n         LA    R1,DALMEMBR\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE DSMEMBER.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT.\n         SPACE 1\n* PASSWORD ************************\n         SPACE 1\nAA3      LA    R7,PASSWORD-DYNLIST\n         LA    R14,PASSWORD\n         LA    R15,L'PASSWORD\n         BAL   R1,PP1              GET PASSWORD LENGTH.\n         LTR   R15,R15\n         BNP   AA4\n         LA    R1,DALPASSW\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE PASSWORD.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT.\n         SPACE 1\n* DSSTATUS ************************\n         SPACE 1\nAA4      LA    R7,DSSTATUS-DYNLIST\n         LA    R14,DSSTATUS\n         LA    R15,L'DSSTATUS\n         BAL   R1,PP1              GET DSSTATUS LENGTH.\n         LTR   R15,R15\n         BNP   AA5\n         LA    R1,DALSTATS\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSSTATUS,=CL8'OLD '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'01'\n         B     AA4A\n         CLC   DSSTATUS,=CL8'MOD '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'02'\n         B     AA4A\n         CLC   DSSTATUS,=CL8'NEW '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'04'\n         B     AA4A\n         CLC   DSSTATUS,=CL8'SHR '\n         BNE   QQ1\n         MVI   S99TUPAR,X'08'\nAA4A     ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT.\n         SPACE 1\n* DSNDISP *************************\n         SPACE 1\nAA5      LA    R7,DSNDISP-DYNLIST\n         LA    R14,DSNDISP\n         LA    R15,L'DSNDISP\n         BAL   R1,PP1              GET DSNDISP LENGTH.\n         LTR   R15,R15\n         BNP   AA6\n         LA    R1,DALNDISP\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSNDISP,=CL8'UNCATLG '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'01'\n         B     AA5A\n         CLC   DSNDISP,=CL8'CATLG   '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'02'\n         B     AA5A\n         CLC   DSNDISP,=CL8'DELETE  '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'04'\n         B     AA5A\n         CLC   DSNDISP,=CL8'KEEP    '\n         BNE   QQ1\n         MVI   S99TUPAR,X'08'\nAA5A     ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT.\n         SPACE 1\n* DSADISP *************************\n         SPACE 1\nAA6      LA    R7,DSADISP-DYNLIST\n         LA    R14,DSADISP\n         LA    R15,L'DSADISP\n         BAL   R1,PP1              GET DSADISP LENGTH.\n         LTR   R15,R15\n         BNP   AA7\n         LA    R1,DALCDISP\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSADISP,=CL8'UNCATLG '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'01'\n         B     AA6A\n         CLC   DSADISP,=CL8'CATLG   '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'02'\n         B     AA6A\n         CLC   DSADISP,=CL8'DELETE  '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'04'\n         B     AA6A\n         CLC   DSADISP,=CL8'KEEP    '\n         BNE   QQ1\n         MVI   S99TUPAR,X'08'\nAA6A     ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT.\n         SPACE 1\n* DSUNIT **************************\n         SPACE 1\nAA7      LA    R7,DSUNIT-DYNLIST\n         LA    R14,DSUNIT\n         LA    R15,L'DSUNIT\n         BAL   R1,PP1              GET DSUNIT LENGTH.\n         LTR   R15,R15\n         BNP   AA8\n         LA    R1,DALUNIT\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE DSUNIT.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT.\n         SPACE 1\n* $RESERV1 ************************\n         SPACE 1\nAA8      LA    R7,$RESERV1-DYNLIST\n         CLC   $RESERV1,=CL44' '\n         BNE   QQ1\n         SPACE 1\n* DSVOLSER ************************\n         SPACE 1\n         LA    R7,DSVOLSER-DYNLIST\n         CLC   DSVOLSER,=XL44'0'\n         BNE   AA8A\n         LA    R1,DALRTVOL         SET UP TO HAVE VOLSER RETURNED\n         STH   R1,S99TUKEY              BACK TO US.\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,6\n         MVC   S99TUPAR(6),=CL44' '\n         LA    R1,S99TUPAR\n         ST    R1,WKRTNVOL         SAVE ADDRESS OF PARAMETER FIELD.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+6       NEXT TEXT UNIT.\n         B     AA9\nAA8A     LA    R14,DSVOLSER\n         LA    R15,L'DSVOLSER\n         BAL   R1,PP1              GET DSVOLSER LENGTH.\n         LTR   R15,R15\n         BNP   AA9\n         LA    R1,DALVLSER\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE DSVOLSER.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT.\n         SPACE 1\n* $RESERV2 ************************\n         SPACE 1\nAA9      LA    R7,$RESERV2-DYNLIST\n         CLC   $RESERV2,=CL44' '\n         BNE   QQ1\n         SPACE 1\n* DSVOLREF ************************\n         SPACE 1\n         LA    R7,DSVOLREF-DYNLIST\n         LA    R14,DSVOLREF\n         LA    R15,L'DSVOLREF\n         BAL   R1,PP1              GET DSVOLREF LENGTH.\n         LTR   R15,R15\n         BNP   AA10\n         CLC   DSVOLSER,=CL44' '   CHECK TO SEE THAT DSVOLREF DOES NOT\n         BE    *+L'*+10                 CONFLICT WITH DSVOLSER.\n         CLC   DSVOLSER,=XL44'0'\n         BNE   QQ1\n         LA    R1,DALVLRDS\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE DSVOLREF.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT.\n         SPACE 1\n* DSFREE **************************\n         SPACE 1\nAA10     LA    R7,DSFREE-DYNLIST\n         LA    R14,DSFREE\n         LA    R15,L'DSFREE\n         BAL   R1,PP1              GET DSFREE LENGTH.\n         LTR   R15,R15\n         BNP   AA10A\n         CLC   DSFREE,=CL8'END   '\n         BE    AA10A\n         CLC   DSFREE,=CL8'CLOSE '\n         BNE   QQ1\n         LA    R1,DALCLOSE         S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY              CLEAR.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUENT         NEXT TEXT UNIT.\nAA10A    CLC   DSNAME,=CL44'NULLFILE '  CHECK FOR DUMMY ALLOCATION.\n         BE    CC1                 GO DO DCB PARAMETERS.\n         SPACE 1\n* DSLABEL *************************\n         SPACE 1\n         LA    R7,DSLABEL-DYNLIST\n         LA    R14,DSLABEL\n         LA    R15,L'DSLABEL\n         BAL   R1,PP1              GET DSLABEL LENGTH.\n         LTR   R15,R15\n         BNP   AA11\n         LA    R1,DALLABEL\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSLABEL,=CL4'SL  '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'02'\n         B     *+L'*+14\n         CLC   DSLABEL,=CL4'SUL '\n         BNE   QQ1\n         MVI   S99TUPAR,X'08'\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT.\n         SPACE 1\n* DSINOUT *************************\n         SPACE 1\nAA11     LA    R7,DSINOUT-DYNLIST\n         LA    R14,DSINOUT\n         LA    R15,L'DSINOUT\n         BAL   R1,PP1              GET DSINOUT LENGTH.\n         LTR   R15,R15\n         BNP   AA12\n         LA    R1,DALINOUT\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSINOUT,=CL4'IN  '\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'80'\n         B     *+L'*+14\n         CLC   DSINOUT,=CL4'OUT '\n         BNE   QQ1\n         MVI   S99TUPAR,X'40'\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT.\n         SPACE 1\n* $RESERV3 ************************\n         SPACE 1\nAA12     LA    R7,$RESERV3-DYNLIST\n         CLC   $RESERV3,=CL44' '\n         BNE   QQ1\n         SPACE 5\n         CLC   DSSTATUS,=CL44' '   CHECK FOR NEW ALLOCATION.\n         BE    BB1\n         CLC   DSSTATUS,=CL8'NEW '\n         BNE   CC1                 GO DO DCB PARAMETERS.\n         EJECT\n* DSPWDLBL ************************\n         SPACE 1\nBB1      LA    R7,DSPWDLBL-DYNLIST\n         LA    R14,DSPWDLBL\n         LA    R15,L'DSPWDLBL\n         BAL   R1,PP1              GET DSPWDLBL LENGTH.\n         LTR   R15,R15\n         BNP   BB2\n         LA    R1,DALPASPR\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSPWDLBL,=CL8'PASSWORD'\n         BNE   *+L'*+8\n         MVI   S99TUPAR,X'10'\n         B     *+L'*+14\n         CLC   DSPWDLBL,=CL8'NOPWREAD'\n         BNE   QQ1\n         MVI   S99TUPAR,X'30'\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT.\n         SPACE 1\n* DSDATE **************************\n         SPACE 1\nBB2      LA    R7,DSDATE-DYNLIST\n         LA    R14,DSDATE\n         LA    R15,L'DSDATE\n         BAL   R1,PP1              GET DSDATE LENGTH.\n         LTR   R15,R15\n         BNP   BB3\n         CLC   DSDATE(6),=C'EXPDT='     CHECK FOR DATE TYPE.\n         BNE   BB2A\n         SH    R15,=H'6'\n         CH    R15,=H'5'           CHECK FOR VALID LENGTH.\n         BNE   QQ1\n         LA    R14,6(0,R14)        BUMP POINTER FOR MVCPARM.\n         LA    R1,DALEXPDT\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM         MOVE EXPDT DATE.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT.\n         B     BB3\nBB2A     CLC   DSDATE(6),=C'RETPD='\n         BNE   QQ1                 ERROR.\n         SH    R15,=H'6'\n         BNP   QQ1\n         CH    R15,=H'4'\n         BH    QQ1\n         LA    R14,6(0,R14)        BUMP POINTER TO START OF NUMBER.\n         BAL   R1,PP2              EDIT AND CONVERT RETPD.\n         LA    R1,DALRETPD\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,2\n         STH   R15,S99TUPAR        PLACE RETPD VALUE IN TEXT UNIT.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+2       NEXT TEXT UNIT.\n         SPACE 1\n* DSALLOC *************************\n         SPACE 1\nBB3      LA    R7,DSALLOC-DYNLIST\n         LA    R14,DSALLOC\n         LA    R15,L'DSALLOC\n         BAL   R1,PP1              GET DSALLOC LENGTH.\n         LTR   R15,R15\n         BNP   QQ1                 ERROR.\n         CLC   DSALLOC,=CL5'TRK '  CHECK FOR TRACK ALLOCATION.\n         BNE   BB3A\n         LA    R1,DALTRK           S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY              CLEAR.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUENT         NEXT TEXT UNIT.\n         B     BB4\nBB3A     CLC   DSALLOC,=CL5'CYL '  CHECK FOR CYLINDER ALLOCATION.\n         BNE   BB3B\n         LA    R1,DALCYL           S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY              CLEAR.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUENT         NEXT TEXT UNIT.\n         B     BB4\nBB3B     BAL   R1,PP2              CHECK FOR AVERAGE BLOCK ALLOCATION.\n         LA    R1,DALBLKLN\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,3\n         STCM  R15,B'0111',S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+3       NEXT TEXT UNIT.\n         SPACE 1\n* DSPRI ***************************\n         SPACE 1\nBB4      LA    R7,DSPRI-DYNLIST\n         LA    R14,DSPRI\n         LA    R15,L'DSPRI\n         BAL   R1,PP1              GET DSPRI LENGTH.\n         LTR   R15,R15\n         BNP   QQ1\n         BAL   R1,PP2              CHECK FOR PRIMARY QUANTITY.\n         LA    R1,DALPRIME\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,3\n         STCM  R15,B'0111',S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+3       NEXT TEXT UNIT.\n         SPACE 1\n* DSSEC ***************************\n         SPACE 1\n         LA    R7,DSSEC-DYNLIST\n         LA    R14,DSSEC\n         LA    R15,L'DSSEC\n         BAL   R1,PP1              GET DSSEC LENGTH.\n         LTR   R15,R15\n         BNP   BB5\n         BAL   R1,PP2              CHECK FOR SECONDARY QUANTITY.\n         LA    R1,DALSECND\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,3\n         STCM  R15,B'0111',S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+3       NEXT TEXT UNIT.\n         SPACE 1\n* DSDIR ***************************\n         SPACE 1\nBB5      LA    R7,DSDIR-DYNLIST\n         LA    R14,DSDIR\n         LA    R15,L'DSDIR\n         BAL   R1,PP1              GET DSDIR LENGTH.\n         LTR   R15,R15\n         BNP   BB6\n         BAL   R1,PP2              CHECK FOR DIRECTORY QUANTITY.\n         LA    R1,DALDIR\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,3\n         STCM  R15,B'0111',S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+3       NEXT TEXT UNIT.\n         SPACE 1\n* DSRLSE **************************\n         SPACE 1\nBB6      LA    R7,DSRLSE-DYNLIST\n         LA    R14,DSRLSE\n         LA    R15,L'DSRLSE\n         BAL   R1,PP1              GET DSRLSE LENGTH.\n         LTR   R15,R15\n         BNP   BB7\n         CLC   DSRLSE,=CL8'RLSE '\n         BNE   QQ1\n         LA    R1,DALRLSE          S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY              CLEAR.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUENT         NEXT TEXT UNIT.\n         SPACE 1\n* DSCONTIG ************************\n         SPACE 1\nBB7      LA    R7,DSCONTIG-DYNLIST\n         LA    R14,DSCONTIG\n         LA    R15,L'DSCONTIG\n         BAL   R1,PP1              GET DSCONTIG LENGTH.\n         LTR   R15,R15\n         BNP   BB8\n         LA    R1,DALSPFRM\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLC   DSCONTIG,=CL8'CONTIG '\n         BNE   QQ1\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT.\n         SPACE 1\n* DSROUND *************************\n         SPACE 1\nBB8      LA    R7,DSROUND-DYNLIST\n         LA    R14,DSROUND\n         LA    R15,L'DSROUND\n         BAL   R1,PP1              GET DSROUND LENGTH.\n         LTR   R15,R15\n         BNP   BB9\n         CLC   DSROUND,=CL8'ROUND '\n         BNE   QQ1\n         LA    R1,DALROUND         S99TUNUM SET TO X'0000' BY WORKAREA\n         STH   R1,S99TUKEY              CLEAR.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUENT         NEXT TEXT UNIT.\n         SPACE 1\n* $RESERV4 ************************\n         SPACE 1\nBB9      LA    R7,$RESERV4-DYNLIST\n         CLC   $RESERV4,=CL44' '\n         BNE   QQ1\n         EJECT\n* DSBLKSI *************************\n         SPACE 1\nCC1      LA    R7,DSBLKSI-DYNLIST\n         LA    R14,DSBLKSI\n         LA    R15,L'DSBLKSI\n         BAL   R1,PP1              GET DSBLKSI LENGTH.\n         LTR   R15,R15\n         BNP   CC2\n         BAL   R1,PP2              CHECK FOR BLKSIZE VALUE.\n         CH    R15,=H'32767'       CHECK FOR MAXIMUM BLOCKSIZE.\n         BH    QQ1                 ERROR.\n         LA    R1,DALBLKSZ\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,2\n         STH   R15,S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+2       NEXT TEXT UNIT.\n         SPACE 1\n* DSORG ***************************\n         SPACE 1\nCC2      LA    R7,DSORG-DYNLIST\n         CLC   DSORG,=XL44'0'\n         BNE   CC2A\n         LA    R1,DALRTORG         SET UP TO HAVE DSORG RETURNED\n         STH   R1,S99TUKEY              BACK TO US.\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,2\n         MVC   S99TUPAR(2),=XL44'0'\n         LA    R1,S99TUPAR\n         ST    R1,WKRTDSRG         SAVE ADDRESS OF PARAMETER FIELD.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+2       NEXT TEXT UNIT.\n         B     CC3\nCC2A     LA    R14,DSORG\n         LA    R15,L'DSORG\n         BAL   R1,PP1              GET DSORG LENGTH.\n         LTR   R15,R15\n         BNP   CC3\n         LA    R1,DALDSORG\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,2\n         CLC   DSORG,=CL8'VSAM '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(0,DCBACBM)\n         B     CC2B\n         CLC   DSORG,=CL8'PO   '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(DCBDSGPO,0)\n         B     CC2B\n         CLC   DSORG,=CL8'POU  '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(DCBDSGPO+DCBDSGU,0)\n         B     CC2B\n         CLC   DSORG,=CL8'DA   '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(DCBDSGDA,0)\n         B     CC2B\n         CLC   DSORG,=CL8'DAU  '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(DCBDSGDA+DCBDSGU,0)\n         B     CC2B\n         CLC   DSORG,=CL8'PS   '\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL1(DCBDSGPS,0)\n         B     CC2B\n         CLC   DSORG,=CL8'PSU  '\n         BNE   QQ1                 ERROR.\n         MVC   S99TUPAR(2),=AL1(DCBDSGPS+DCBDSGU,0)\nCC2B     ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+2       NEXT TEXT UNIT.\n         SPACE 1\n* DSKEYLEN ************************\n         SPACE 1\nCC3      LA    R7,DSKEYLEN-DYNLIST\n         LA    R14,DSKEYLEN\n         LA    R15,L'DSKEYLEN\n         BAL   R1,PP1              GET DSKEYLEN LENGTH.\n         LTR   R15,R15\n         BNP   CC4\n         BAL   R1,PP2              CHECK FOR KEYLENGTH QUANTITY.\n         CH    R15,=H'255'         CHECK FOR MAX KEYLENGTH.\n         BH    QQ1                 ERROR.\n         LA    R1,DALKYLEN\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         STC   R15,S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT.\n         SPACE 1\n* DSLRECL *************************\n         SPACE 1\nCC4      LA    R7,DSLRECL-DYNLIST\n         LA    R14,DSLRECL\n         LA    R15,L'DSLRECL\n         BAL   R1,PP1              GET DSLRECL LENGTH.\n         LTR   R15,R15\n         BNP   CC5\n         LA    R1,DALLRECL\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,2\n         CLC   DSLRECL,=CL5'X '    CHECK FOR SPANNED RECORDS.\n         BNE   *+L'*+10\n         MVC   S99TUPAR(2),=AL2(32768)\n         B     *+L'*+16\n         BAL   R1,PP2              CHECK FOR LRECL QUANTITY.\n         CH    R15,=H'32767'\n         BH    QQ1\n         STH   R15,S99TUPAR\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+2       NEXT TEXT UNIT.\n         SPACE 1\n* DSRECFM1 THRU DSRECFM8 **********\n         SPACE 1\nCC5      LA    R7,DSRECFM1-DYNLIST\n         CLC   DSRECFM,=CL44' '    CHECK FOR NO INFORMATION.\n         BE    CC6\n         LA    R1,DALRECFM\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         MVI   S99TULNG+1,1\n         CLI   DSRECFM1,C' '\n         BE    CC5A\n         CLI   DSRECFM1,C'V'\n         BNE   *+L'*+8\n         OI    S99TUPAR,DCBRECV\n         B     CC5A\n         CLI   DSRECFM1,C'F'\n         BNE   *+L'*+8\n         OI    S99TUPAR,DCBRECF\n         B     CC5A\n         CLI   DSRECFM1,C'U'\n         BNE   QQ1                 ERROR.\n         OI    S99TUPAR,DCBRECU\nCC5A     LA    R7,DSRECFM2-DYNLIST\n         CLI   DSRECFM2,C' '\n         BE    *+L'*+12\n         CLI   DSRECFM2,C'B'\n         BNE   QQ1                 ERROR.\n         OI    S99TUPAR,DCBRECBR\n         LA    R7,DSRECFM3-DYNLIST\n         CLI   DSRECFM3,C' '\n         BE    *+L'*+12\n         CLI   DSRECFM3,C'S'\n         BNE   QQ1                 ERROR.\n         OI    S99TUPAR,DCBRECSB\n         LA    R7,DSRECFM4-DYNLIST\n         CLI   DSRECFM4,C' '\n         BE    *+L'*+12\n         CLI   DSRECFM4,C'T'\n         BNE   QQ1                 ERROR.\n         OI    S99TUPAR,DCBRECTO\n         LA    R7,DSRECFM5-DYNLIST\n         CLI   DSRECFM5,C' '\n         BE    CC5B\n         CLI   DSRECFM5,C'M'\n         BNE   *+L'*+8\n         OI    S99TUPAR,DCBRECCM\n         B     CC5B\n         CLI   DSRECFM5,C'A'\n         BNE   QQ1                 ERROR.\n         OI    S99TUPAR,DCBRECCA\nCC5B     LA    R7,DSRECFM6-DYNLIST\n         CLI   DSRECFM6,C' '\n         BNE   QQ1                 ERROR.\n         LA    R7,DSRECFM7-DYNLIST\n         CLI   DSRECFM7,C' '\n         BNE   QQ1                 ERROR.\n         LA    R7,DSRECFM8-DYNLIST\n         CLI   DSRECFM8,C' '\n         BNE   QQ1                 ERROR.\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1       NEXT TEXT UNIT.\n         SPACE 1\n* DSDCBDS *************************\n         SPACE 1\nCC6      LA    R7,DSDCBDS-DYNLIST\n         LA    R14,DSDCBDS\n         LA    R15,L'DSDCBDS\n         BAL   R1,PP1              GET DSDCBDS LENGTH.\n         LTR   R15,R15\n         BNP   CC7\n         LA    R1,DALDCBDS\n         STH   R1,S99TUKEY\n         MVI   S99TUNUM+1,1\n         STH   R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVCPARM\n         ST    R9,0(0,R8)          SAVE THIS TEXT UNIT ADDRESS.\n         LA    R8,4(0,R8)          NEXT TEXT POINTER.\n         LA    R9,S99TUPAR+1(R15)  NEXT TEXT UNIT.\n         SPACE 1\n* $RESERV5 ************************\n         SPACE 1\nCC7      LA    R7,$RESERV5-DYNLIST\n         CLC   $RESERV5,=CL44' '\n         BNE   QQ1\n         EJECT\nMM1      SH    R8,=H'4'            BACK UP TO LAST USED TEXT POINTER.\n         OI    0(R8),X'80'         INDICATE END OF LIST.\n         LA    R1,REQBKPTR         GET THE BEGINNING OF THIS MESS.\n        DYNALLOC\n         L     R0,S99RSC           PICK UP REASON CODES.\n         LTR   R15,R15             CHECK FOR ERRORS.\n         BNZ   ZZ1\n         L     R1,WKRTNVOL         CHECK FOR VOLSER RETURN REQUEST.\n         LTR   R1,R1\n         BZ    *+L'*+6\n         MVC   DSVOLSER,0(R1)      GIVE CALLER INFO.\n         L     R1,WKRTDSRG         CHECK FOR DSORG RETURN REQUEST.\n         LTR   R1,R1\n         BZ    ZZ1\n         CLC   0(2,R1),=AL1(0,DCBACBM)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'VSAM '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DCBDSGPO,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'PO   '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DCBDSGPO+DCBDSGU,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'POU  '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DCBDSGDA,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'DA   '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DCBDSGDA+DCBDSGU,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'DAU  '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DCBDSGPS,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'PS   '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DCBDSGPS+DCBDSGU,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'PSU  '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DCBDSGIS,0)\n         BNE   *+L'*+10\n         MVC   DSORG,=CL8'IS   '\n         B     ZZ1\n         CLC   0(2,R1),=AL1(DCBDSGIS+DCBDSGU,0)\n         BNE   ZZ1\n         MVC   DSORG,=CL8'ISU  '\n         B     ZZ1\n         EJECT\nQQ1      LR    R0,R7               SET UP RETURN CODES.\n         LA    R15,15\n         SPACE 2\nZZ1      L     R3,4(R13)           PREPARE TO RETURN.\n         LTR   R10,R10             CHECK TO SEE IF PARAMETER LIST IS\n         BNP   ZZ1A                     ONLY ENTRY IN CALLER'S ADDRESS\n         L     R2,24(0,R3)              LIST.\n         L     R2,4(0,R2)          GET SECOND ADDRESS IN LIST.\n         LA    R2,0(R2)\n         LTR   R2,R2\n         BZ    ZZ1A\n         ST    R0,0(0,R2)          PUT REGISTERS INFORMATION IN LIST.\n         ST    R15,4(0,R2)\nZZ1A     ST    R0,20(R3)           SET ERROR AND INFORMATIONAL R.C.\n        $XRET  CC=(R15),LV=WRKL,TYPE=RENT\n         EJECT\n*        ROUTINE TO DETERMINE LENGTH OF NON-BLANK CHARACTERS IN FIELD.\n*\n*        AT ENTRY : R1 CONTAINS THE RETURN ADDRESS.\n*                   R14 CONTAINS THE FIELD ADDRESS.\n*                   R15 CONTAINS THE LENGTH OF FIELD.\n*\n*        AT EXIT  : R15 WILL BE ALTERED TO CONTAIN LENGTH OF\n*                   NON-BLANK CHARACTERS IN FIELD.\n         SPACE 1\nPP1      LTR   R15,R15\n         BNPR  R1\n         ALR   R15,R14\nPP1A     BCTR  R15,0\n         CLI   0(R15),C' '\n         BNE   PP1B\n         CLR   R15,R14\n         BH    PP1A\n         SR    R15,R15\n         BR    R1\nPP1B     SLR   R15,R14\n         LA    R15,1(0,R15)\n         BR    R1\n         EJECT\n*        ROUTINE TO EDIT EBCDIC NUMERIC DATA AND, IF VALID, TO\n*        CONVERT IT TO BINARY.\n*\n*        AT ENTRY : R1 CONTAINS THE RETURN ADDRESS.\n*                   R14 CONTAINS DATA ADDRESS.\n*                   R15 CONTAINS LENGTH OF DATA.\n*\n*        AT EXIT  : R15 WILL BE ALTERED TO CONTAIN THE BINARY\n*                   EQUIVALENT OF THE NUMBER.\n         SPACE 1\nPP2      LTR   R15,R15\n         BNPR  R1\n         ST    R15,DBLWORD\n         ALR   R15,R14\nPP2A     BCTR  R15,0\n         CLI   0(R15),C'0'\n         BL    QQ1                     AN ABNORMAL EXIT WILL BE TAKEN\n         CLI   0(R15),C'9'             TO THE COMMON ERROR ROUTINE IF\n         BH    QQ1                     DATA IS NOT NUMERIC.\n         CLR   R15,R14\n         BH    PP2A\n         L     R15,DBLWORD\n         BCTR  R15,0\n         EX    R15,PACKNUM\n         CVB   R15,DBLWORD\n         BR    R1\n         SPACE 2\n*        SOME EXECUTED INSTRUCTIONS.\n         SPACE 1\nMVCPARM  MVC   S99TUPAR(0),0(R14)\nPACKNUM  PACK  DBLWORD,0(0,R14)\n         SPACE 2\n*        CONSTANTS.\n         SPACE 1\nWORKLEN  DC    A(WRKL)\nTXPTRSPC DC    A(4*40)             RESERVE SPACE FOR 40 TEXT POINTERS.\n         EJECT\n        LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNALL$": {"ttr": 13577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//DYNALL   JOB (........),'INSTALL  - DYNALL -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=DYNALL\n//LNK     EXEC PAJILKR,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   DYNALL\n  NAME    DYNALL(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNALL@": {"ttr": 13579, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x07\\x0f\\x00\\x92\\x07\\x0f\\x15V\\x01~\\x01~\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-03-10T00:00:00", "modifydate": "1992-03-10T15:56:00", "lines": 382, "newlines": 382, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      DYNALL    1/9.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     DYNAMIC DATA-SET ALLOCATION     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :\n  ---------\n\n     This routine will function only in OS/VS2 Release 2 and later\n  releases (i.e. MVS). It allows the user to perform any one of the\n  following operations :\n\n         1.    Dynamically allocate an existing disk data-set. Any\n                           disk data-set, including an ISAM data-set,\n                           may be allocated.\n\n         2.    Dynamically allocate a new disk data-set. Any valid\n                           disk data-set organization except ISAM\n                           may be specified.\n\n         3.    Dynamically allocate a DD DUMMY data-set.\n\n         4.    Dynamically de-allocate a previous allocation.\n\n     It is assumed that the user of this routine has a good working\n  knowledge of OS/VS2 JCL as described in the OS/VS2 JCL manual\n  (GC28-1300). The user of this routine will build a list of\n  parameters in much the same way as he would fill out a DD-card.\n     The information in the parameter list will be used to do the\n  requested function.\n\n     The linkage to this routine can be made with a standard OS\n  CALL; LINK or ATTACH. The address list specified in the CALL\n  (or LINK or ATTACH) must always include the address of the\n  parameter list (described below) as its first or only entry.\n  The second (optional) address in the list must be the address\n  of 2 consecutive fullwords in the caller's program. Register 13\n  must contain the address of a standard OS save area. Examples\n  of CALL's are shown below.\n\n         CALL  DYNALL,(DYNLIST),VL\n         CALL  DYNALL,(DYNLIST,RCODES),VL\n\n  Assembler macro : $DYNALL A,B\n\n         Where B is optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/09/85\n                                                      DYNALL    2/9.\n\n     Upon return from this routine, R0 and R15 will contain codes\n  indicating how the request completed. If the second item is named\n  in the address list, then the values placed in R0 and R15 will\n  also be stored in its first and second words, respectively. This\n  will allow programs written in cobol or other high level languages\n  to use this routine. Detailed information about the return codes is\n  given following the information about the parameter list.\n\n     This routine is re-enterable.\n\n  Dynamic allocation parameter list :\n  -----------------------------------\n\n         Unless otherwise noted, the following is true for all\n         information you place in the parameter list.\n\n         1.    Coding a parameter in the parameter list has the same\n               effect as coding the same parameter in a JCL DD-card.\n\n         2.    If a parameter is to be omitted, its corresponding\n               field should be left blank.\n\n         3.    Omitting a parameter from the list has the same effect\n               as omitting the same parameter from a JCL DD-card. In\n               particular, if omitting a parameter from a JCL DD-card\n               would cause a default to be taken, then omitting the\n               parameter from the list will cause the same default to\n               be taken.\n\n         4.    All parameters should be left justified and padded\n               with blanks. Numeric values may contain leading\n               zeros.\n\n         5.    Fields within the parameter list will be unchanged\n               by this routine.\n\n  Assembler macro : $DYNLIST\n\n         Use this macro to obtain the dynamic allocation parameter\n         list dummy section as described below.\n1   10/03/92\n                                                      DYNALL    3/9.\n\n  Field name   Length      Description and comments\n  ----------   ------      ------------------------------------------\n\n  DDNAME          8        Required for all functions. This must be\n                           the same as the DDNAME parameter of the\n                           ACB or DCB that will be used to process\n                           the data-set.\n\n  DSNAME         44        This field must be filled in with the\n                           correct DSNAME when allocating an existing\n                           data-set or when creating a new permanent\n                           data-set. When allocating a new temporary\n                           data-set it may be left blank or filled in\n                           with an &&DSNAME in a manner identical\n                           to requesting a temporary data-set in JCL.\n                           If NULLFILE is used as a DSNAME, a dummy\n                           data-set is allocated. If this field is\n                           filled in with all X'00', a previously\n                           allocated data-set with the same DDNAME\n                           will be de-allocated. The data-set name\n                           specified in this field must not be a\n                           backward reference (i.e. must not be\n                           *.DDNAME, *.STEPNAME.DDNAME or\n                           *.STEPNAME.PROCSTEPNAME.DDNAME). This\n                           field should not contain a member name or\n                           a generation number. Use the DSMEMBER\n                           field to specify that information.\n\n                           Note : when allocation is for a dummy file\n                                 (i.e. when DSNAME is NULLFILE) only\n                                 the DDNAME, DSNAME, DSFREE and\n                                 DCB information is used by this\n                                 module. Any other information is\n                                 ignored.\n                                 When de-allocation is requested (i.e.\n                                 when DSNAME is all X'00') only the\n                                 DDNAME, DSNAME and DSUFORCE\n                                 information are used by this module.\n                                 Any other information is ignored.\n\n  DSMEMBER        8        Use this field to specify a member of a\n                           PDS or to specify the generation number\n                           of a generation data-set group. Do not\n                           use parentheses (e.g. specify +1 not\n                           (+1) ).\n\n  PASSWORD        8        Use this field to specify the password for\n                           an existing password protected data-set.\n                           There is no JCL equivalent for this\n                           parameter.\n1   10/03/92\n                                                      DYNALL    4/9.\n\n  Field name   Length      Description and comments\n  ----------   ------      ------------------------------------------\n\n  DSUFORCE        8        This field is used only by de-allocation.\n  (or next                 Valid value is FORCE and means free even\n   field,                  if permanently allocated.\n    alias)\n  DSSTATUS        8        This field is equivalent to the status\n                           subparameter of the JCL DISP parameter.\n                           Valid values are NEW, OLD, SHR and MOD.\n\n  DSNDISP         8        This field is equivalent to the normal\n                           termination disposition subparameter of\n                           the JCL DISP parameter except that\n                           PASS may not be specified for this\n                           field. Valid values are KEEP, CATLG,\n                           UNCATLG and DELETE.\n\n  DSADISP         8        This field is equivalent to the abnormal\n                           termination disposition subparameter of\n                           the JCL DISP parameter. Valid values are\n                           KEEP, CATLG, UNCATLG and DELETE.\n\n  DSUNIT          8        Use this field to specify the UNIT\n                           ADDRESS, GENERIC NAME or ESOTERIC NAME\n                           (e.g. 450, 3330-1, SYSDA).\n\n    **            8        This field is reserved for future use. It\n                           must be left blank.\n\n  DSVOLSER        6        Use this field to specify the VOLUME\n                           SERIAL NUMBER (e.g. USER00). This\n                           field may also be set to all X'00', in\n                           that case this routine will SET this field\n                           to the data-set VOLUME SERIAL NUMBER.\n\n    **           40        This field is reserved for future use. It\n                           must be left blank.\n1   10/03/92\n                                                      DYNALL    5/9.\n\n  Field name   Length      Description and comments\n  ----------   ------      ------------------------------------------\n\n  DSVOLREF       44        Specifying a DSNAME in this field is\n                           equivalent to coding VOL=REF=DSNAME in\n                           a JCL DD-card. Note thst the value given\n                           here must always be a catalogued data-set\n                           (i.e. it cannot be a PASSed data-set nor\n                           can it be a backward reference such as\n                           *.DDNAME, *.STEPNAME.DDNAME or\n                           *.STEPNAME.PROCSTEPNAME.DDNAME).\n\n                           Note that the DSVOLSER and DSVOLREF\n                           fields are mutually exclusive except when\n                           DSVOLSER has been coded as all X'00'.\n\n  DSFREE          8        This field is equivalent to the FREE\n                           parameter of a JCL DD-card. Valid values\n                           are END and CLOSE.\n\n  DSLABEL         4        Use this to specify a valid disk label\n                           type. Valid values are SL and SUL.\n\n  DSINOUT         4        This field should be coded where\n                           LABEL=(,,,IN) or LABEL=(,,,OUT) would\n                           be coded in a JCL DD-card. Valid values\n                           are IN and OUT.\n\n    **           16        This field is reserved for future use. It\n                           must be left blank.\n1   23/09/85\n                                                      DYNALL    6/9.\n\n  ... ... The next group of fields are applicable to NEW data-sets\n          only. Information in these fields will be ignored if they\n          have been coded for other than NEW data-sets.\n\n  Field name   Length      Description and comments\n  ----------   ------      ------------------------------------------\n\n  DSPWDLBL        8        Specifying this field is equivalent to\n                           coding either LABEL=(,,PASSWORD) or\n                           LABEL=(,,NOPWREAD) in your JCL. Valid\n                           values are PASSWORD and NOPWREAD.\n\n  DSDATE         12        Specifying this field is equivalent to\n                           coding either LABEL=EXPDT=YYDDD or\n                           LABEL=RETPD=NNNN in your JCL. Valid\n                           values are EXPDT=YYDDD and RETPD=NNNN.\n\n  DSALLOC         5        This field specifies how space is to be\n                           allocated. Valid values are TRK, CYL\n                           and NNNNN where the value of NNNNN is\n                           the average block length.\n\n  DSPRI           6        This field specifies the primary\n                           allocation quantity.\n\n  DSSEC           6        This field specifies the secondary\n                           allocation quantity.\n\n  DSDIR           5        This field specifies the number of\n                           directory blocks for a PDS.\n\n  DSRLSE          8        Specifying this parameter has the same\n                           effect as specifying the RLSE\n                           subparameter of the JCL SPACE parameter.\n                           The valid value is RLSE.\n\n  DSCONTIG        8        Specifying this parameter has the same\n                           effect as specifying the CONTIG\n                           subparameter of the JCL SPACE parameter.\n                           The valid value is CONTIG.\n\n  DSROUND         8        Specifying this parameter has the same\n                           effect as specifying the ROUND\n                           subparameter of the JCL SPACE parameter.\n                           The valid value is ROUND.\n\n    **           24        This field is reserved for future use. It\n                           must be left blank.\n1   23/09/85\n                                                      DYNALL    7/9.\n\n  ... ... Except as noted, the following information is the same as\n          that contained in the JCL DCB parameter.\n\n  Field name   Length      Description and comments\n  ----------   ------      ------------------------------------------\n\n  DSBLKSI         5        BLOCK SIZE value (must be numeric).\n\n  DSORG           8        For NEW data-sets, this field specifies\n                           the desired DATA ORGANIZATION. Valid\n                           values are DA, DAU, PO, POU, PS, PSU\n                           and VSAM. Except for VSAM, this field\n                           is equivalent to the DSORG JCL\n                           subparameter. Specifying VSAM is\n                           equivalent to coding AMP=AMORG in the\n                           DD-card. Note that ISAM data-sets may\n                           not be allocated NEW.\n\n                           For existing data-sets, this field may be\n                           specified as all X'00', in that case the\n                           organization of the data-set will be\n                           placed in this field by this routine. The\n                           value that will be returned will be one of\n                           the following : DA, DAU, IS, ISU, PO,\n                           POU, PS, PSU or VSAM. If this module\n                           cannot determine the data-set organization,\n                           it will not change the field.\n\n  DSKEYLEN        3        The data-set KEY LENGTH. The value must be\n                           numeric.\n\n  DSLRECL         5        The data-set LOGICAL RECORD LENGTH. Valid\n                           values are the numeric value for LRECL\n                           and X.\n\n  DSRECFM1        1        The RECORD FORMAT. Valid values are F,\n                           V and U.\n\n  DSRECFM2        1        Specifies data-set BLOCKING. The valid\n                           value is B.\n\n  DSRECFM3        1        Specifies STANDARD BLOCKS (if DSRECFM1=F)\n                           or SPANNED RECORDS (if DSRECFM1=V). The\n                           valid value is S.\n\n  DSRECFM4        1        Specifies TRACK OVERFLOW. The valid value\n                           is T.\n1   23/09/85\n                                                      DYNALL    8/9.\n\n  Field name   Length      Description and comments\n  ----------   ------      ------------------------------------------\n\n  DSRECFM5        1        Specifies the CARRIAGE CONTROL CHARACTER.\n                           Valid values are A and M.\n\n  DSRECFM6        1        Reserved for future use. Must be blank.\n\n  DSRECFM7        1        Reserved for future use. Must be blank.\n\n  DSRECFM8        1        Reserved for future use. Must be blank.\n\n  DSDCBDS        44        Specifying a data-set name here is\n                           equivalent to coding DCB=DSNAME in the\n                           JCL. Note that a backward reference\n                           cannot be coded.\n\n    **           24        This field is reserved for future use. It\n                           must be left blank.\n1   23/09/85\n                                                      DYNALL    9/9.\n\n  Return codes :\n  --------------\n\n     This routine uses the dynamic allocation routine described in\n  the OS/VS2 Systems Programming Library : JOB MANAGEMENT manual\n  (GC28-1303), and in MVS/XA Systems Programming Library: System\n  Macros and Facilieties, Volume 1 (GC28-1150).\n     This routine does some preliminary editing prior\n  to requesting dynamic allocation. If it finds some error which\n  prevents completion of the request, it will place 15 (decimal)\n  in R15. R0 will contain an offset from the beginning of the\n  parameter list to show which field is in error. For example,\n  if the DSNDISP field contains PASS (which is invalid), R0 will\n  contain 76 (decimal) and R15 will contain 15 (decimal).\n\n     Unless this routine detects an error, it will make a request\n  to the dynamic allocation routine. The dynamic allocation routine\n  issues a return code in R15 and also gives an ERROR REASON CODE\n  and an INFORMATIONAL REASON CODE. Each of the two REASON CODES\n  is 2 bytes long. This routine will place the ERROR REASON CODE\n  in the first 2 bytes of R0 and the INFORMATIONAL REASON CODE in\n  the second 2 bytes of R0. This routine will leave the dynamic\n  allocation return code in R15. The meaning of these codes can be\n  found in the manual (GC28-1303) mentioned above.\n\n     It will always be possible to know the meaning of an R0 return\n  code (i.e. does it contain an offset or does it contain reason\n  codes), since the dynamic allocation routine never issues a 15\n  (decimal) return code. Therefore, when R15 contains 15 (decimal),\n  R0 must contain an offset.\n\n     If the program that invokes this routine passes 2 addresses in\n  its address list, this routine will place the contents of R0 and R15\n  in the first and second fullwords, respectively, of the second item\n  in the address list.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DYNCC": {"ttr": 13830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x16X\\x00\\xba\\x00\\xba\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T16:58:00", "lines": 186, "newlines": 186, "modlines": 0, "user": "SYSPAJA"}, "text": "DYCC     TITLE 'DYNAMIC CONCATENATION-DECONCATENATION ROUTINE.'\nDYNCC    START 0\n         SPACE 1\n         ENTRY DYNDC\n         SPACE 1\n* CALLING SEQUENCE : CALL DYNCC,(A,B),VL\n* ------------------ CALL DYNDC,(A,B),VL\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE LIST OF THE DDNAMES TO BE\n*                    CONCATENATED (DYNCC) OR THE DDNAME OF THE GROUP\n*                    TO BE DECONCATENATED (DYNDC).\n*                    DYNCC : A ===> DC CL8'DD1'\n*                                   DC CL8'DD2'\n*                                   ...\n*                                   DC CL8'DDN'\n*                                   DC XL1'0' OR CL1' ' = END OF LIST.\n*                    DYNDC : A ===> DC CL8'DDG'\n*\n*                B - RECEIVES THE RETURN CODES (FORMAT FULLWORDS -\n*                    F BOUNDARIES) IF SUPPLIED (OPTIONAL).\n*                            B ===> DC 2F'0'\n*                    IN ANY CASE, THE RETURN CODES ARE ALWAYS GIVEN\n*                    BACK IN REGISTERS 15 AND 0.\n*\n*        RETURN CODES (REGISTER 15) :\n*                 0-4-8-12 = SVC 99 RETURN CODES. R0 = REASON CODE\n*                            FIELDS = 0-1 - ERROR CODE\n*                                     2-3 - INFORMATION CODE\n*                       16 = CALLING SEQUENCE OR PARAMETER ALIGNMENT\n*                            ERROR (R0 = 0).\n*                       20 = DDNAME CODING ERROR. R0 = RELATIVE DDNAME\n*                            POSITION FROM THE BEGINNING OF THE LIST\n*                            (0 = 1ST, 1 = 2ND, ...).\n*\n* MODULE ATTRIBUTE : THIS ROUTINE IS RE-ENTERABLE.\n* ------------------\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\nWRKDSECT DSECT                     WORK AREAS DESCRIPTION\n         SPACE 1\nSVA      DS    18F                 SAVE AREA\nRCODES   DS    2F                  RETURN CODES (R15-R0)\nRBKPTR   DS    F\n         SPACE 1\nWRKL     EQU   512                 WORK AREAS LENGTH\nDYNWRKL  EQU   (WRKL-(*-SVA))\nDYNWORK  DS    (DYNWRKL)X\n         SPACE 1\nDYNCC    CSECT                     RESTORE ORIGINAL CSECT\n         SPACE 2\n        $DEFREG\n         EJECT\n         USING *,R15\n         N     R1,SETOFF           SAY DYNCC ENTRY\n         B     COMMON              GO COMMON ENTRY\nSETOFF   DC    0F'0',XL4'7FFFFFFF'\n         DROP  R15\n         SPACE 1\n         USING *,R15\nDYNDC    O     R1,SETON            SAY DYNDC ENTRY\n         B     COMMON              GO COMMON ENTRY\nSETON    DC    0F'0',XL4'80000000'\n         DROP  R15\n        CNOP   6,8\nCOMMON   BALR  R15,0               SET COMMON ENTRY ADDRESS\n         SPACE 1\nDYNCOM  $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R10,R13\n         USING WRKDSECT,R10\n         LA    R2,0(R1)            SAVE PARM. POINTER\n         STCM  R1,B'1000',SVA      SAVE ENTRY SWITCH\n         EJECT\n         LA    R14,RCODES          CLEAR WORK AREA\n         L     R15,=A(WRKL-(18*4))\n         XR    R0,R0\n         LR    R1,R0\n         MVCL  R14,R0\n         SPACE 1\n         XR    R8,R8               GET ARGUMENTS ADDRESSES\n         XR    R9,R9\n         TM    0(R2),X'80'\n         BO    GADD\n         TM    4(R2),X'80'\n         BZ    ERSA\n         TM    7(R2),X'03'\n         BNZ   ERSA\n         L     R9,4(R2)\n         LA    R9,0(R9)\nGADD     L     R8,0(R2)\n         LA    R8,0(R8)\n         SPACE 1\n         LA    R2,DYNWORK\n         USING S99RB,R2\n         ST    R2,RBKPTR           POINT TO REQUEST BLOCK\n         OI    RBKPTR,S99RBPND\n         LA    R1,S99RBEND-S99RB   LENGTH OF REQUEST BLOCK\n         STC   R1,S99RBLN\n         LA    R1,S99RBEND         PICK UP ADDRESS FOR TEXT POINTERS\n         ST    R1,S99TXTPP\n         LA    R3,4(R1)            TEXT UNIT POINTER\n         USING S99TUPL,R1\n         ST    R3,S99TUPTR\n         OI    S99TUPTR,S99TUPLN   INDICATE END OF LIST\n         DROP  R1\n         USING S99TUNIT,R3\n         MVC   S99TUKEY,=H'1'      SET KEY\n         TM    SVA,X'80'           GO TO SPECIFIC REQUEST\n         BO    DDC\n         MVI   S99VERB,S99VRBCC    REQUEST IS CONCATENATION\n         LA    R4,S99TUENT\n         USING S99TUFLD,R4\n         CLI   0(R8),C' '\n         BE    ERDD\n         CLI   0(R8),0\n         BE    ERDD\n         XR    R7,R7\nDCC1     LA    R14,8\n         LA    R15,7(R8)\n         CLI   0(R15),C' '\n         BNE   DCC3\n         BCTR  R15,0\n         BCT   R14,*-10\nDCC2     ST    R7,RCODES+4\n         B     ERDD\nDCCMNM   MVC   S99TUPRM(*-*),0(R8) <<EXECUTED>>\nDCC3     STCM  R14,B'0011',S99TULEN\n         BCTR  R14,0\n         EX    R14,DCCMNM\n         LA    R4,S99TUPRM+1(R14)\n         AH    R7,=H'1'\n         LA    R8,8(R8)\n         CLI   0(R8),C' '\n         BE    *+L'*+8\n         CLI   0(R8),0\n         BNE   DCC1\n         DROP  R4\n         CH    R7,=H'2'\n         BL    DCC2\n         STCM  R7,B'0011',S99TUNUM\n         B     REQCD\nDDC      MVI   S99VERB,S99VRBDC    REQUEST IS DECONCATENATION\n         MVC   S99TUNUM,=H'1'\n         LA    R14,8\n         LA    R15,7(R8)\n         CLI   0(R15),C' '\n         BNE   DDC1\n         BCTR  R15,0\n         BCT   R14,*-10\n         B     ERDD\nDDCMNM   MVC   S99TUPAR(*-*),0(R8) <<EXECUTED>>\nDDC1     STCM  R14,B'0011',S99TULNG\n         BCTR  R14,0\n         EX    R14,DDCMNM\n         DROP  R3\n         SPACE 1\nREQCD    LA    R1,RBKPTR\n        DYNALLOC\n         ST    R15,RCODES          SET RETURN CODE\n         MVC   RCODES+4(L'S99RSC),S99RSC     PASS REASON CODES\n         DROP  R2\n         EJECT\nLEAVE    LTR   R9,R9\n         BZ    EXIT\n         MVC   0(8,R9),RCODES      PASS RETURN CODES\nEXIT     L     R1,4(R13)\n         MVC   20(4,R1),RCODES+4   SET R0\n         L     R15,RCODES          GET R15\n        $XRET  CC=(R15),LV=WRKL,TYPE=RENT\nERSA     MVI   RCODES+3,16         SET R.C. = 16\n         B     LEAVE\nERDD     MVI   RCODES+3,20         SET R.C. = 20\n         B     LEAVE\n         DROP  R10\n         SPACE 2\n        LTORG\n         SPACE 2\n        PRINT  NOGEN\n        IEFZB4D0\n        IEFZB4D2\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNCC$": {"ttr": 13834, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x15O\\x00\\x87\\x15O\\x11P\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-06-03T00:00:00", "modifydate": "1987-06-03T11:50:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//DYNCC    JOB (........),'INSTALL  - DYNCC -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=1\n//ASS     EXEC PAJIAS2,OPT=',RENT',MBR=DYNCC\n//LNK     EXEC PAJILKR,OPT=',RENT'\n//SYSIN     DD *\n  ALIAS   DYNDC\n  NAME    DYNCC(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNCC@": {"ttr": 13836, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x15O\\x00\\x87\\x15O\\x12\\x04\\x00\\\\\\x00\\\\\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-06-03T00:00:00", "modifydate": "1987-06-03T12:04:00", "lines": 92, "newlines": 92, "modlines": 0, "user": "SYSPAJA"}, "text": "1   03/06/87\n                                                      DYNCC     1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *            D Y N A M I C            * * * * * * * *\n  * * * * * * * *    CONCATENATION-DECONCATENATION    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Routine to dynamically concatenate and deconcatenate\n  ---------    allocated data sets.\n\n  Calling sequence : CALL DYNCC,(A,B),VL\n  ------------------ CALL DYNDC,(A,B),VL\n                                (A)\n\n         Where : A - is the address of the list of the DDnames to be\n                     concatenated (DYNCC) or the DDname of the group\n                     to be deconcatenated (DYNDC).\n                     DYNCC : A ===> DC CL8'DD1'\n                                    DC CL8'DD2'\n                                    ...\n                                    DC CL8'DDN'\n                                    DC XL1'0' or CL1' ' = end of list.\n                     DYNDC : A ===> DC CL8'DDG'\n\n                 B - receives the return codes (format fullwords -\n                     F boundaries) if supplied (optional).\n                             B ===> DC 2F'0'\n                     In any case, the return codes are always given\n                     back in registers 15 and 0.\n\n         Return codes (register 15) :\n                  0-4-8-12 = SVC 99 return codes. R0 = REASON code\n                             fields = 0-1 - ERROR code\n                                      2-3 - INFORMATION code\n                        16 = calling sequence or parameter alignment\n                             error (R0 = 0).\n                        20 = DDname coding error. R0 = relative DDname\n                             position from the beginning of the list\n                             (0 = 1st, 1 = 2nd, ...).\n\n  Module attribute : this routine is re-enterable.\n  ------------------\n\n  Assembler macro : $DYNCC A,B\n  ----------------- $DYNDC A,B\n\n         Where B is optional and may be omitted.\n         Register use may be coded within parentheses.\n1   03/06/87\n                                                      DYNCC     2/2.\n\n  Dynamic concatenation :\n  -----------------------\n         Dynamic concatenation logically connects allocated data sets\n  into a concatenated group. You can only identify data sets to be\n  concatenated by their associated DDnames. These data sets must not\n  be open, if they are, the request for dynamic concatenation fails.\n         The order in which you specify the DDnames is the order in\n  which the routine will concatenate their associated data sets. The\n  name associated with the concatenated group is the DDname that was\n  specified first, the other DDnames are no longer associated with\n  any data set. If a DDname you specify is already associated with a\n  concatenated group, that entire group will be included in the new\n  concatenation.\n         After the request for dynamic concatenation is satisfied,\n  all members of the dynamically-concatenated group are assigned the\n  in-use attribute.\n\n  Dynamic deconcatenation :\n  -------------------------\n         Dynamic deconcatenation logically disconnects the members of\n  a concatenated group. You identify the concatenated group to be\n  deconcatenated by specifying the DDname of the group. The request\n  for dynamic deconcatenation fails if the concatenated group is open.\n  A permanently concatenated group, or members of a concatenated group\n  that are permanently concatenated, remain concatenated.\n         When a concatenated group is dynamically deconcatenated, the\n  DDnames that were associated with the data sets before they were\n  concatenated are restored unless this would result in duplicate\n  DDnames. This situation could arise if a dynamic allocation with the\n  DDname to be restored occurred after a dynamic concatenation. In this\n  case, the deconcatenation request fails.\n         Dynamic deconcatenation has no effect on the in-use attributes\n  associated with the members of the group.\n\n  Reference : for more details, look to the section Dynamic Allocation\n  ----------- in the IBM manual GC28-1150 (MVS/Extended Architecture\n              System Programming Library : System Macros and Facilities\n              Volume 1).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EDITH": {"ttr": 14081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x16X\\x01$\\x01$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T16:58:00", "lines": 292, "newlines": 292, "modlines": 0, "user": "SYSPAJA"}, "text": "EDTH     TITLE 'EDIT HEADER SUBROUTINE.'\nEDITH    START 0\n         SPACE 2\n* CALLING SEQUENCE : CALL EDITH,(A,B,C,D),VL\n* ------------------            (A,B,C)\n*                               (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE TEXT TO BE EXPANDED AND\n*                    BLOCKS PRINTED BY GROUP OF 16 CHARACTERS.\n*\n*                B - IS THE ADDRESS OF TEXT LENGTH (NO. OF CHARACTERS :\n*                    FORMAT FULLWORD - F BOUNDARY). WHEN THIS ARGUMENT\n*                    IS OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS\n*                    SET TO ZERO IN THE PARAMETERS LIST, THE LENGTH OF\n*                    THE TEXT IS SUPPOSED TO BE IN FRONT OF THE TEXT,\n*                    AT THE ADDRESS OF A-1 (FORMAT XL1).\n*\n*                C - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSPRINT'.\n*\n*                D - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - PRINT CORRECTLY EXECUTED.\n*                     1 - DD-CARD MISSING.\n*                     2 - OPEN ERROR.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - LENGTH IS NEGATIVE, ZERO OR GREATER THAN THE\n*                         LOGICAL RECORD LENGTH (MAXIMUM ALLOWABLE IS\n*                         145). THE LINE IS PRINTED, BUT TRUNCATED.\n*                     5 - PRINT ERROR.\n*\n* GENERAL NOTICE : THIS SUBROUTINE USES THE \"PRINT\" SUBROUTINE, AND\n* ---------------- THUS IT IS NECESSARY TO CALL \"PCLOSE\" IN ORDER TO\n*                  TERMINATE THE HEADER EDIT FILE.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12\n         EJECT\n         SR    R6,R6               SET DEFAULTS.\n         SR    R8,R8\n         SR    R9,R9\n         SR    R10,R10             R10 = RETURN CODE.\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    ED1\n         TM    7(R1),X'03'\n         BNZ   ERR3\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         TM    4(R1),X'80'\n         BO    ED1\n         L     R7,8(R1)\n         LA    R7,0(R7)\n         LTR   R7,R7\n         BZ    *+L'*+2\n         LR    R6,R7               R6 = DDNAME ADDRESS.\n         TM    8(R1),X'80'\n         BO    ED1\n         TM    12(R1),X'80'\n         BZ    ERR3\n         TM    15(R1),X'03'\n         BNZ   ERR3\n         L     R9,12(R1)\n         LA    R9,0(R9)            R9 = IND. RESPONSE ADDRESS.\nED1      L     R7,0(R1)\n         LA    R7,0(R7)            R7 = TEXT ADDRESS.\n         LTR   R8,R8\n         BZ    ED2\n         L     R8,0(R8)\n         B     ED3\nED2      BCTR  R7,0\n         IC    R8,0(R7)\n         LA    R7,1(R7)\nED3      LTR   R8,R8               R8 = TEXT LENGTH.\n         BNP   ERR4\n         SPACE 2\nNEXTG    LA    R1,16\n         SR    R8,R1\n         BNM   *+L'*+4\n         AR    R1,R8               R1 = NUMBER OF CHARACTERS.\n         SR    R8,R8               SET END OF TEXT.\n         SR    R2,R2               R2 = LINES STARTING INDEX.\n         CL    R1,=F'14'\n         BH    EXPD\n         LA    R2,8(R2)\n         CL    R1,=F'12'\n         BH    EXPD\n         LA    R2,8(R2)\n         CL    R1,=F'10'\n         BH    EXPD\n         LA    R2,8(R2)\n         CL    R1,=F'8'\n         BH    EXPD\n         LA    R2,8(R2)\n         CL    R1,=F'6'\n         BH    EXPD\n         LA    R2,8(R2)\n         CL    R1,=F'4'\n         BH    EXPD\n         LA    R2,8(R2)\n         CL    R1,=F'2'\n         BH    EXPD\n         LA    R2,8(R2)\nEXPD     MVC   LINE1+2(128),LINE1+1\n         MVC   LINE2+2(128),LINE2+1\n         MVC   LINE3+2(128),LINE3+1\n         MVC   LINE4+2(128),LINE4+1\n         MVC   LINE5+2(128),LINE5+1\n         MVC   LINE6+2(128),LINE6+1\n         MVC   LINE7+2(128),LINE7+1\n         MVC   LINE8+2(128),LINE8+1\nNEXTC    CLI   0(R7),C' '\n         BE    SKIP\n         LM    R3,R5,SCAN\nLOOP     CLC   0(1,R7),0(R3)\n         BE    SET\n         BXLE  R3,R4,LOOP\n         B     SKIP\nSET      LA    R4,LINE1+2(R2)\n         BAL   R14,BUILD\n         LA    R4,LINE2+2(R2)\n         BAL   R14,BUILD\n         LA    R4,LINE3+2(R2)\n         BAL   R14,BUILD\n         LA    R4,LINE4+2(R2)\n         BAL   R14,BUILD\n         LA    R4,LINE5+2(R2)\n         BAL   R14,BUILD\n         LA    R4,LINE6+2(R2)\n         BAL   R14,BUILD\n         LA    R4,LINE7+2(R2)\n         BAL   R14,BUILD\n         LA    R4,LINE8+2(R2)\n         BAL   R14,BUILD\nSKIP     LA    R2,8(R2)\n         LA    R7,1(R7)\n         BCT   R1,NEXTC\n        $PRINT SPCE\n         LTR   R10,R15\n         BNZ   EDRET\n        $PRINT LINE1,,(R6)\n         LTR   R10,R15\n         BNZ   EDRET\n        $PRINT LINE2,,(R6)\n         LTR   R10,R15\n         BNZ   EDRET\n        $PRINT LINE3,,(R6)\n         LTR   R10,R15\n         BNZ   EDRET\n        $PRINT LINE4,,(R6)\n         LTR   R10,R15\n         BNZ   EDRET\n        $PRINT LINE5,,(R6)\n         LTR   R10,R15\n         BNZ   EDRET\n        $PRINT LINE6,,(R6)\n         LTR   R10,R15\n         BNZ   EDRET\n        $PRINT LINE7,,(R6)\n         LTR   R10,R15\n         BNZ   EDRET\n        $PRINT LINE8,,(R6)\n         LTR   R10,R15\n         BNZ   EDRET\n        $PRINT SPCE\n         LTR   R10,R15\n         BNZ   EDRET\n         LTR   R8,R8\n         BNZ   NEXTG\n         B     EDRET\n         SPACE 2\nERR3     LA    R10,3\n         B     EDRET\nERR4     LA    R10,4\nEDRET    LTR   R9,R9\n         BZ    *+L'*+4\n         ST    R10,0(R9)           STORE INDICATOR.\n        $XRET  CC=(R10)\n         SPACE 2\nBUILD    LA    R0,8\n         LA    R3,1(R3)\n         TM    0(R3),X'FF'\n         BZR   R14\n         LA    R15,X'80'\nBUILDL   EX    R15,BUILDT\n         BZ    *+L'*+4\n         MVI   0(R4),C'*'\n         LA    R4,1(R4)\n         SRL   R15,1\n         BCT   R0,BUILDL\n         BR    R14\nBUILDT   TM    0(R3),*-*\n         SPACE 1\n         DROP  R12\n         SPACE 2\n         LTORG\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nSCAN     DC    A(CHTAB,L'CHTAB,CHTABE-L'CHTAB)\n         SPACE 1\n         DC    AL1(L'SPCE)\nSPCE     DC    CL5'     '\n         DC    AL1(L'LINE1)\nLINE1    DC    CL133' '\n         DC    AL1(L'LINE2)\nLINE2    DC    CL133' '\n         DC    AL1(L'LINE3)\nLINE3    DC    CL133' '\n         DC    AL1(L'LINE4)\nLINE4    DC    CL133' '\n         DC    AL1(L'LINE5)\nLINE5    DC    CL133' '\n         DC    AL1(L'LINE6)\nLINE6    DC    CL133' '\n         DC    AL1(L'LINE7)\nLINE7    DC    CL133' '\n         DC    AL1(L'LINE8)\nLINE8    DC    CL133' '\n         SPACE 2\n*        BLOCK CHARACTERS TABLE.\n         SPACE 1\nCHTAB    DS    0XL9\n         DC    C'A',XL8'081C3663637F6363'\n         DC    C'B',XL8'7E63637E6363637E'\n         DC    C'C',XL8'3F6060606060603F'\n         DC    C'D',XL8'7E6363636363637E'\n         DC    C'E',XL8'7E6060786060607F'\n         DC    C'F',XL8'7F60607C60606060'\n         DC    C'G',XL8'3E6360606763633E'\n         DC    C'H',XL8'6363637F63636363'\n         DC    C'I',XL8'3C1818181818183C'\n         DC    C'J',XL8'030303030363633E'\n         DC    C'K',XL8'63666C78786C6663'\n         DC    C'L',XL8'606060606060607F'\n         DC    C'M',XL8'4163777F6D636363'\n         DC    C'N',XL8'6373737D6F676763'\n         DC    C'O',XL8'3E6363636363633E'\n         DC    C'P',XL8'7E6363637E606060'\n         DC    C'Q',XL8'3E636363636F673E'\n         DC    C'R',XL8'7E6363637E6C6663'\n         DC    C'S',XL8'3E63603E0303633E'\n         DC    C'T',XL8'7F18181818181818'\n         DC    C'U',XL8'636363636363633E'\n         DC    C'V',XL8'6363636363361C08'\n         DC    C'W',XL8'636363636D7F7722'\n         DC    C'X',XL8'6363361C1C366363'\n         DC    C'Y',XL8'636363361C181818'\n         DC    C'Z',XL8'7F03060C1830607F'\n         DC    C'1',XL8'081808080808081C'\n         DC    C'2',XL8'1C2202021C20203E'\n         DC    C'3',XL8'1C22020C0222221C'\n         DC    C'4',XL8'040C14247E040404'\n         DC    C'5',XL8'3C20203C0222221C'\n         DC    C'6',XL8'1C22203C2222221C'\n         DC    C'7',XL8'3E02020408080808'\n         DC    C'8',XL8'1C22221C2222221C'\n         DC    C'9',XL8'1C2222221E02221C'\n         DC    C'0',XL8'1C2222222222221C'\n         DC    C'$',XL8'083E49483E09493E'\n         DC    C'#',XL8'00123F12123F1200'\n         DC    C'@',XL8'00001C22021A2A14'\n         DC    C',',XL8'0000000018180810'\n         DC    C'.',XL8'0000000000001818'\n         DC    C'(',XL8'0810202020201008'\n         DC    C')',XL8'1008040404040810'\n         DC    C'+',XL8'000008083E080800'\n         DC    C'/',XL8'0001020408102040'\n         DC    C'''',XL8'1818081000000000'\n         DC    C'*',XL8'00002A1C3E1C2A00'\n         DC    C'=',XL8'0000003E003E0000'\n         DC    C':',XL8'0000181800181800'\n         DC    C';',XL8'0018180018180810'\n         DC    C'-',XL8'000000003E000000'\n         DC    C'?',XL8'1C22020408080008'\n         DC    C'%',XL8'0031320408102646'\n         DC    C'|',XL8'0808080808080008'\n         DC    C'&&',XL8'00182424182A241A'\n         DC    C'\"',XL8'3636122400000000'\nCHTABE   EQU   *\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITH$": {"ttr": 14087, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14!\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:21:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//EDITH    JOB (........),'INSTALL  - EDITH -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION FOR USE :                      *\n//*                TXPRINT                                            *\n//* NOTE : AT LINK-EDIT YOU WILL RECEIVE A RETURN CODE 4 WHICH IS     *\n//*        ONLY A NORMAL WARNING MESSAGE DUE TO NCAL SPECIFIED.       *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,MBR=EDITH\n//LNK     EXEC PAJILKR,OPT=',NCAL'\n//SYSIN     DD *\n  NAME    EDITH(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EDITH@": {"ttr": 14089, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x16/\\x00\\x87\\x16/\\x14(\\x00U\\x00U\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-06-11T00:00:00", "modifydate": "1987-06-11T14:28:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      EDITH     1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         EDIT HEADER ROUTINE         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL EDITH,(A,B,C,D),VL\n  ------------------            (A,B,C)\n                                (A,B)\n                                (A)\n\n         Where : A - is the address of the text to be expanded and\n                     blocks printed by group of 16 characters (if the\n                     last group is less than 16, it is centered).\n                     The block characters are printed using 8 lines\n                     (length 132), preceeded and followed by a blank\n                     line. Unknown characters are left blank.\n\n                 B - is the address of text length (no. of characters :\n                     format FULLWORD - F boundary). When this argument\n                     is omitted, or the address of this argument is\n                     set to zero in the parameters list, the length of\n                     the text is supposed to be in front of the text,\n                     at the address of A-1 (format XL1).\n\n                 C - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSPRINT.\n\n                 D - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - PRINT correctly executed.\n                      1 - DD-card missing.\n                      2 - OPEN error.\n                      3 - Calling sequence or argument alignment error.\n                      4 - Length is negative, zero or greater than the\n                          logical record length (maximum allowable is\n                          145). The line is printed, but truncated.\n                      5 - PRINT error.\n\n\n  Assembler macro : $EDITH A,B,C,D\n  -----------------\n\n         Where B, C and/or D are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/09/85\n                                                      EDITH     2/2.\n\n\n  General notice : this subroutine uses the PRINT subroutine, and\n  ---------------- thus it is necessary to CALL PCLOSE in order to\n                   terminate the header edit files.\n                   This routine is multi-files usable, that means\n                   multi-files opened concurrently (using the DD-name\n                   argument).\n\n  Example :   coding in a program :\n  ---------\n                   ... ... ...\n                           $EDITH HT\n                   ... ... ...\n                           DC     AL1(L'HT)\n                   HT      DC     C'ABC'\n                   ... ... ...\n\n              result on SYSPRINT file :\n\n              Line  1 :\n              Line  2 :        *    ******   ******\n              Line  3 :       ***   **   ** **\n              Line  4 :      ** **  **   ** **\n              Line  5 :     **   ** ******  **\n              Line  6 :     **   ** **   ** **\n              Line  7 :     ******* **   ** **\n              Line  8 :     **   ** **   ** **\n              Line  9 :     **   ** ******   ******\n              Line 10 :\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EDITMACS": {"ttr": 14092, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x14\\x1f\\x00\\x90\\x14\\x1f\\x13Y\\x00R\\x00R\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-05-21T00:00:00", "modifydate": "1990-05-21T13:59:00", "lines": 82, "newlines": 82, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM)\n/*  MACRO NAME : EDITMACS                             (MOINIL P.A.) */\n/*    FUNCTION : DISPLAY AVAILABLE ADDITIONAL LOCAL EDIT MACROS     */\n/*      SYNTAX : EDITMACS                                           */\n/*       DEBUG : EDITMACS LIST                                      */\n  IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST SYMLIST CONLIST\nSTART: +\n  ISPEXEC CONTROL ERRORS RETURN\n  ISPEXEC TBOPEN EDITMACS NOWRITE SHARE\n  SET &EMRCC = &LASTCC\n  IF &EMRCC = 8 THEN DO\n    SET &ZEDSMSG = NO MACROS\n    SET &ZEDLMSG = THE TABLE \"EDITMACS\" DOES NOT EXIST\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  IF &EMRCC = 12 THEN DO\n    SET &ZEDSMSG = TABLE IN USE\n    SET &ZEDLMSG = ENQ FAILED DUE TO TABLE IN USE BY ANOTHER USER OR +\n                   CURRENT USER\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  IF &EMRCC = 16 OR &EMRCC = 20 THEN DO\n    SET &ZEDSMSG = TBOPEN ERROR\n    SET &ZEDLMSG = TBOPEN RETURN CODE &EMRCC ... ABORT\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\nLOOP: +\n  ISPEXEC TBDISPL EDITMACS PANEL(PAJEML) POSITION(EMCRP)\n  SET &EMTRC = &LASTCC\n  IF &EMTRC = 8 THEN GOTO LEAVE\n  IF &EMTRC = 12 OR &EMTRC = 20 THEN DO\n    SET &ZEDSMSG = TBDISPL ERROR\n    SET &ZEDLMSG = TBDISPL RETURN CODE &EMTRC ... ABORT\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  IF &ZCMD = CANCEL THEN GOTO QUIT\n  IF &ZTDSELS = 0 THEN GOTO LOOP\n  IF &EMOPTN = S THEN DO\n    ISREDIT &MACNAME HELP\n    SET &EMTRC = &LASTCC\n    IF &EMTRC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = HELP ERROR\n      SET &ZEDLMSG = DISPLAY HELP HAS GIVEN BACK A &EMTRC RETURN CODE\n      ISPEXEC SETMSG MSG(ISRZ000)\n      END\n    END\n  ELSE DO\n    SET &ZEDSMSG = INVALID OPTION\n    SET &ZEDLMSG = ONLY VALID OPTION IS \"S\" TO GET HELP OF MACRO\n    ISPEXEC SETMSG MSG(ISRZ000)\n    END\n  GOTO LOOP\nLEAVE: +\n  ISPEXEC TBEND EDITMACS\n  SET &EMTRC = &LASTCC\n  IF &EMTRC \u00ac= 0 THEN DO\n    SET &ZEDSMSG = TBEND ERROR\n    SET &ZEDLMSG = TBEND RETURN CODE &EMTRC ... ABORT\n    END\n  ELSE DO\n    SET &ZEDSMSG = HELP DONE\n    SET &ZEDLMSG = PROCESSING ENDED NORMALLY\n    END\n  ISPEXEC SETMSG MSG(ISRZ000)\n  EXIT CODE(0)\nQUIT: +\n  ISPEXEC TBEND EDITMACS\n  SET &EMTRC = &LASTCC\n  IF &EMTRC \u00ac= 0 THEN DO\n    SET &ZEDSMSG = TBEND ERROR\n    SET &ZEDLMSG = TBEND RETURN CODE &EMTRC ... ABORT\n    END\n  ELSE DO\n    SET &ZEDSMSG = CANCEL DONE\n    SET &ZEDLMSG = IMMEDIATE STOP HAS BEEN REQUESTED\n    END\n  ISPEXEC SETMSG MSG(ISRZ000)\n  EXIT CODE(12)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITMACT": {"ttr": 14095, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "EDMODE": {"ttr": 14097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x915\\x1f\\x00\\x915\\x1f\\x14\\x06\\x00\\xc2\\x00\\xc2\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-12-17T00:00:00", "modifydate": "1991-12-17T14:06:00", "lines": 194, "newlines": 194, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM)\n/*  MACRO NAME : EDMODE                                             */\n/*    FUNCTION : VERIFY/SET EDIT MODES                              */\n/*      SYNTAX : EDMODE                                             */\n/*               EDMODE HELP OR H                                   */\n/*       DEBUG : EDMODE LIST                                        */\n/*      AUTHOR : MOINIL P.A.                                        */\n  ISPEXEC CONTROL ERRORS RETURN\n  IF &STR(&APARM.) = &STR(HELP) OR +\n    &STR(&APARM.) = &STR(H) THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTEM)\n      SET &EMCC = &LASTCC\n      ISPEXEC CONTROL DISPLAY RESTORE\n      EXIT CODE(&EMCC)\n      END\n  ELSE IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n  ELSE IF &STR(&APARM.) \u00ac= &Z THEN DO\n    SET ZEDSMSG = &STR(INVALID OPERAND)\n    SET ZEDLMSG = &STR(ONLY HELP OR H IS ACCEPTED AS OPERAND)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  ISREDIT (EMDSNM) = DATASET\n  ISREDIT (EMBLKS) = BLKSIZE\n  ISREDIT (EMLRCL) = LRECL\n  ISREDIT (EMRCFM) = RECFM\n  ISREDIT (EMCTL1,EMCTL2) = CTL_LIBRARY\n  ISREDIT (EMMEMB) = MEMBER\n  IF &EMMEMB = &Z THEN DO\n    SET &EMSTAT = &Z\n    SET &EMVRSN = &Z\n    SET &EMLEVL = &Z\n    END\n  ELSE DO\n    ISREDIT (EMSTAT) = STATS\n    IF &EMSTAT = ON THEN DO\n      ISREDIT (EMVRSN) = VERSION\n      ISREDIT (EMLEVL) = LEVEL\n      END\n    END\n  ISREDIT (EMRCVR) = RECOVERY\n  ISREDIT (EMCAPS) = CAPS\n  ISREDIT (EMNBR1,EMNBR2) = NUMBER\n  ISREDIT (EMNLS1,EMNLS2) = NULLS\n  ISREDIT (EMHEX1,EMHEX2) = HEX\n  ISREDIT (EMWDTH) = DATA_WIDTH\n  ISREDIT (EMLEFT,EMRGHT) = BOUNDS\n  ISREDIT (EMASV1,EMASV2) = AUTOSAVE\n  ISREDIT (EMANUM) = AUTONUM\n  ISREDIT (EMALST) = AUTOLIST\n  SET &EMSTAT1 = &STR(&EMSTAT)\n  SET &EMVRSN1 = &STR(&EMVRSN)\n  SET &EMLEVL1 = &STR(&EMLEVL)\n  SET &EMRCVR1 = &EMRCVR\n  SET &EMCAPS1 = &STR(&EMCAPS)\n  SET &EMNBR11 = &STR(&EMNBR1)\n  SET &EMWORK = &SUBSTR(1:8,&STR(&EMNBR2))\n  SET &EMNBRA = &EMWORK\n  SET &EMWORK = &SUBSTR(9:16,&STR(&EMNBR2))\n  SET &EMNBRB = &EMWORK\n  SET &EMWORK = &SUBSTR(17:24,&STR(&EMNBR2))\n  SET &EMNBRC = &EMWORK\n  SET &EMNBR21 = &STR(&EMNBRA &EMNBRB &EMNBRC)\n  SET &EMNLS11 = &STR(&EMNLS1)\n  SET &EMNLS21 = &STR(&EMNLS2)\n  SET &EMHEX11 = &STR(&EMHEX1)\n  SET &EMHEX21 = &STR(&EMHEX2)\n  SET &EMLEFT1 = &EMLEFT\n  SET &EMRGHT1 = &EMRGHT\n  SET &EMASV11 = &STR(&EMASV1)\n  SET &EMASV21 = &STR(&EMASV2)\n  SET &EMANUM1 = &STR(&EMANUM)\n  SET &EMALST1 = &STR(&EMALST)\n  ISPEXEC DISPLAY PANEL(PAJEM)\n  SET &EMCC = &LASTCC\n  IF &EMCC > 4 THEN DO\n    IF &EMCC = 8 THEN DO\n      SET ZEDSMSG = &STR(EXIT REQUEST)\n      SET ZEDLMSG = &STR(EXIT \"EDMODE\" FACILITY HAS BEEN REQUESTED)\n      END\n    ELSE DO\n      SET ZEDSMSG = &STR(ERROR RC=&EMCC)\n      SET ZEDLMSG = &STR(EXIT DUE TO DISPLAY ERROR ENCOUNTERED)\n      END\n    END\n  ELSE DO\n    SET &EMSW = NO\n    SET &EMBSW = NO\n    SET &EMSTAT2 = &STR(&EMSTAT)\n    SET &EMVRSN2 = &STR(&EMVRSN)\n    SET &EMLEVL2 = &STR(&EMLEVL)\n    SET &EMRCVR2 = &EMRCVR\n    SET &EMCAPS2 = &STR(&EMCAPS)\n    SET &EMNBR12 = &STR(&EMNBR1)\n    SET &EMNBR22 = &STR(&EMNBR2)\n    SET &EMNLS12 = &STR(&EMNLS1)\n    SET &EMNLS22 = &STR(&EMNLS2)\n    SET &EMHEX12 = &STR(&EMHEX1)\n    SET &EMHEX22 = &STR(&EMHEX2)\n    SET &EMLEFT2 = &EMLEFT\n    SET &EMRGHT2 = &EMRGHT\n    SET &EMASV12 = &STR(&EMASV1)\n    SET &EMASV22 = &STR(&EMASV2)\n    SET &EMANUM2 = &STR(&EMANUM)\n    SET &EMALST2 = &STR(&EMALST)\n    IF &EMSTAT1 \u00ac= &EMSTAT2 THEN DO\n      ISREDIT STATS &EMSTAT\n      SET &EMSW = YES\n      END\n    IF &EMSTAT = ON THEN DO\n      IF &EMVRSN1 \u00ac= &EMVRSN2 THEN DO\n        ISREDIT VERSION &EMVRSN\n        SET &EMSW = YES\n        END\n      IF &EMLEVL1 \u00ac= &EMLEVL2 THEN DO\n        ISREDIT LEVEL &EMLEVL\n        SET &EMSW = YES\n        END\n      END\n    IF &EMRCVR1 \u00ac= &EMRCVR2 THEN DO\n      ISREDIT RECOVERY &EMRCVR\n      SET &EMSW = YES\n      END\n    IF &EMCAPS1 \u00ac= &EMCAPS2 THEN DO\n      ISREDIT CAPS &EMCAPS\n      SET &EMSW = YES\n      END\n    IF (&EMNBR11 \u00ac= &EMNBR12 OR &EMNBR21 \u00ac= &EMNBR22) THEN DO\n      IF (&EMNBR11 \u00ac= &EMNBR12 AND &EMNBR12 = OFF) THEN ISREDIT UNNUM\n      ISREDIT NUMBER = (EMNBR1 EMNBR2)\n      SET &EMSW = YES\n      END\n    IF (&EMNLS11 \u00ac= &EMNLS12 OR &EMNLS21 \u00ac= &EMNLS22) THEN DO\n      ISREDIT NULLS = (EMNLS1 EMNLS2)\n      SET &EMSW = YES\n      END\n    IF &EMHEX11 \u00ac= &EMHEX12 THEN DO\n      IF &EMHEX1 = OFF THEN ISREDIT HEX &EMHEX1\n      ELSE ISREDIT HEX &EMHEX1 &EMHEX2\n      SET &EMSW = YES\n      END\n    ELSE IF (&EMHEX21 \u00ac= &EMHEX22 AND &EMHEX1 = ON) THEN DO\n      ISREDIT HEX &EMHEX1 &EMHEX2\n      SET &EMSW = YES\n      END\n    IF &EMASV11 \u00ac= &EMASV12 THEN DO\n      IF &EMASV1 = ON THEN ISREDIT AUTOSAVE &EMASV1\n      ELSE ISREDIT AUTOSAVE &EMASV1 &EMASV2\n      SET &EMSW = YES\n      END\n    ELSE IF (&EMASV21 \u00ac= &EMASV22 AND &EMASV1 = OFF) THEN DO\n      ISREDIT AUTOSAVE &EMASV1 &EMASV2\n      SET &EMSW = YES\n      END\n    IF &EMANUM1 \u00ac= &EMANUM2 THEN DO\n      ISREDIT AUTONUM &EMANUM\n      SET &EMSW = YES\n      END\n    IF &EMALST1 \u00ac= &EMALST2 THEN DO\n      ISREDIT AUTOLIST &EMALST\n      SET &EMSW = YES\n      END\n    IF (&EMLEFT1 \u00ac= &EMLEFT2 OR &EMRGHT1 \u00ac= &EMRGHT2) THEN DO\n      ISREDIT (EMWDTH) = DATA_WIDTH\n      IF &EMLEFT >= &EMRGHT THEN DO\n        SET ZEDSMSG = &STR(BOUNDS ERROR)\n        SET ZEDLMSG = &STR(LEFT BOUNDARY .GE. RIGHT BOUNDARY)\n        SET &EMBSW = YES\n        END\n      ELSE IF &EMRGHT > &EMWDTH THEN DO\n        SET ZEDSMSG = &STR(BOUNDS ERROR)\n        SET ZEDLMSG = &STR(RIGHT BOUNDARY .GT. LOGICAL DATA WIDTH)\n        SET &EMBSW = YES\n        END\n      ELSE DO\n        ISREDIT BOUNDS = (EMLEFT EMRGHT)\n        SET &EMSW = YES\n        END\n      END\n    IF &EMBSW = NO THEN DO\n      IF &EMSW = YES THEN DO\n        SET ZEDSMSG = &STR(MODES DONE)\n        SET ZEDLMSG = &STR(EDIT MODES HAS BEEN SET AS DEFINED)\n        END\n      ELSE DO\n        SET ZEDSMSG = &STR(MODES LEFT)\n        SET ZEDLMSG = &STR(EDIT MODES HAS BEEN LEFT AS DEFINED)\n        ISREDIT RESET\n        END\n      END\n    END\n  ISPEXEC SETMSG MSG(ISRZ000)\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDMODE@": {"ttr": 14340, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"o\\x00\\x91\"o\\x10\\x06\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-14T00:00:00", "modifydate": "1991-08-14T10:06:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "1   15/06/90\n                                                      EDMODE    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     EDMODE ISPF/PDF EDIT command    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to verify and set the EDIT\n  ----------   modes for the current edit file.\n\n  Command syntax : EDMODE\n  ---------------- EDMODE HELP or H\n\n  Use :        Type EDMODE on the COMMAND line, and you will be\n  -----        prompted to verify and eventually change the EDIT modes\n               for the data you are currently editing.\n               The EDIT modes you may control are :\n                   STATS               NUMBER              AUTONUM\n                   VERSION/LEVEL       NULLS               AUTOLIST\n                   RECOVERY            HEX                 AUTOSAVE\n                   CAPS                BOUNDS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EDVIO": {"ttr": 14342, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"?\\x00\\x94\"?\\x14\\x07\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-11T00:00:00", "modifydate": "1994-08-11T14:07:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n/*********************************************************************/\n/*       PURPOSE : ISPF EDIT IN A VIO DATA-SET (TEMPORARY DATA-SET   */\n/*                 IS ALLOCATED TO DDNAME=EDFVIO)                    */\n/*       ORIGIN :  EXTRACTED FROM CBT 93 AUG TAPE, FILE 134.         */\n/*       ADAPTED : BY MOINIL P.A.                                    */\n/*********************************************************************/\n         CONTROL MAIN NOMSG\n         ISPEXEC CONTROL ERRORS RETURN\n         FREE F(EDFVIO) DELETE\n         ALLOC F(EDFVIO) UNIT(VIO) SPACE(1 1) CYLINDERS +\n           DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(4080) NEW\n         SET &RCC = &LASTCC\n         IF &RCC NE 0 THEN DO\n           SET ZERRSM = &STR(ALLOC RC=&RCC)\n           SET ZERRLM = &STR(ALLOCATION OF FILE \"EDVIO\" FAILED)\n           ISPEXEC SETMSG MSG(ISRZ002)\n           END\n         ELSE DO\n           ISPEXEC LMINIT DATAID(TEMPF) DDNAME(EDFVIO) ENQ(EXCLU)\n           SET &RCC = &LASTCC\n           IF &RCC NE 0 THEN DO\n             SET ZERRSM = &STR(LMINIT RC=&RCC)\n             SET ZERRLM = &STR(INITIALIZATION OF FILE \"EDVIO\" FAILED)\n             ISPEXEC SETMSG MSG(ISRZ002)\n             END\n           ELSE DO\n             ISPEXEC EDIT DATAID(&TEMPF)\n             ISPEXEC LMFREE DATAID(&TEMPF)\n             END\n           END\n         FREE F(EDFVIO) DELETE\n         ISPEXEC CONTROL ERRORS CANCEL\n         EXIT CODE(&RCC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENCRYPT": {"ttr": 14344, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x10!\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T10:21:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM) NOPROCESS\n/*  MACRO NAME : ENCRYPT                                            */\n/*    FUNCTION : DATA ENCRYPTION (CRY INVOKER)                      */\n/*      SYNTAX : ENCRYPT                                            */\n/*               ENCRYPT HELP OR H                                  */\n/*      AUTHOR : MOINIL P.A                                         */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(HELP) OR +\n      &STR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTEDCR)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ISREDIT !CRY E\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDECR@": {"ttr": 14346, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89$\\x9f\\x00\\x89$\\x9f\\x16\\x17\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-06T00:00:00", "modifydate": "1989-09-06T16:17:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "1   06/09/89\n                                                      ENDECR    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      ENCRYPT-DECRYPT ISPF/PDF       * * * * * * * *\n  * * * * * * * *            EDIT command             * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   performs the ENCRYPTION or DECRYPTION of data operating\n  ----------   as a primary command under ISPF/PDF EDIT.\n\n  Operation :  the ENCRYPTION or DECRYPTION is performed by utilizing a\n  -----------  KEY-VALUE you are prompted to supply it unviewable.\n               The KEY-VALUE is a user supplied keyword which is used\n               as ENCRYPT/DECRYPT code value. The keyword is limited\n               to eight (8) bytes in length, but may be shorter.\n\n  Command syntax :      ENCRYPT or               DECRYPT or\n  ----------------      ENCRYPT HELP or H        DECRYPT HELP or H\n\n  Warning :  If you forget the KEY-VALUE that you used to encipher the\n  ---------  data, KISS THE DATA GOOD-BYE because there is no way of\n             deciphering the data again.\n             If you are hopelessly paranoid, you can encipher the\n             enciphered data with a different KEY-VALUE to really grunge\n             up the data. The decipherion process must be the exact\n             inverse of the encipher process in order to recover the\n             original data again.\n\n  Range :    You may also limit the encryption-decryption by marking a\n  -------    range of lines of text with the \"C\" range command on the\n             line numbers.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EOL": {"ttr": 14348, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\t\\x18\\x00:\\x00:\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T09:18:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (WHAT)\n/*  MACRO NAME : PLUG                                               */\n/* DESCRIPTION : EDIT MACRO TO SET CURSOR AT END OF CURRENT         */\n/*               SCREEN LINE                                        */\n/*      AUTHOR : J. KALINICH, X4521                                 */\n/*  CBT ORIGIN : EXTRACTED FROM CBT TAPE 94 APR, FILE 078           */\n/*  ADAPTED BY : MOINIL P.A.                                        */\n  IF (&STR(&WHAT) EQ &STR(HELP)) OR +\n    (&STR(&WHAT) EQ &STR(H)) THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJEOL)\n    SET &EOLCC = &LASTCC\n    ISPEXEC CONTROL DISPLAY RESTORE\n    EXIT CODE(&EOLCC)\n    END\n  ISREDIT (CROW,CCOL) = CURSOR\n  SET SCCOL = &CCOL\n  ISREDIT (WDTH) = DATA_WIDTH\n  ISPEXEC CONTROL ERRORS RETURN\n  ISREDIT (LINE) = LINE &CROW\n  IF &LASTCC NE 0 THEN DO\n    SET CROW = &CROW - 1\n    END\n  ELSE DO\n    SET I = &WDTH\n    SET CCOL = 0\n    DO WHILE &I GE 1\n      IF &SUBSTR(&I:&I,&NRSTR(&LINE)) NE &Z THEN DO\n        SET CCOL = &I\n        SET I = 1\n        END\n      SET I = &I - 1\n      END\n    IF &CCOL NE &WDTH THEN SET CCOL = &CCOL + 1\n/*       IF ALREADY AT EOL, THEN JUMP TO NEXT LINE AND GO TO EOL.   */\n/*       NOTE : THIS CAN NOT JUMP OVER MORE THAN 1 EXCLUDED LINE.   */\n    IF &SCCOL EQ &CCOL THEN DO\n      SET CROW = &CROW + 1\n      ISREDIT (LINE) = LINE &CROW\n      IF &LASTCC NE 0 THEN DO\n        SET CROW = &CROW - 1\n        END\n      ELSE DO\n        SET I = &WDTH\n        SET CCOL = 0\n        DO WHILE &I GE 1\n          IF &SUBSTR(&I:&I,&NRSTR(&LINE)) NE &Z THEN DO\n            SET CCOL = &I\n            SET I = 1\n            END\n          SET I = &I - 1\n          END\n        IF &CCOL NE &WDTH THEN SET CCOL = &CCOL + 1\n        END\n      END\n    END\n  ISREDIT CURSOR = &CROW &CCOL\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EOL@": {"ttr": 14350, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"?\\x00\\x94\"?\\x12(\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-11T00:00:00", "modifydate": "1994-08-11T12:28:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": "1   11/08/94\n                                                      EOL       1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      EOL ISPF/PDF EDIT command      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to position the cursor at\n  ----------   the end ofthe current screen line (like most PC editors\n               do when you press the \"End\" scroll key). Yes, it takes\n               some interrupts and a PF key definition, but that is the\n               price you have to pay for PC-like features on a 3270.\n               By pressing the EOL PF key repeatedly, you can jump to\n               end of line (EOL) on successive lines.\n               Note : This can not jump over more than 1 excluded line.\n\n  Use :        Assume cursor was on word IN on line 000020 and press\n  -----        the appropriate PF key (the one assigned to EOL).\n               COMMAND ===> <PFn>\n               Before ************** TOP OF DATA **********************\n               000020 D:  IN A858SES FIND ALL RECORDS FOR WHICH\n               000021       REC-TY = 'SESC'\n               000022     END FIND\n                                       (cursor is now here) ---|\n               After *************** TOP OF DATA ************* v ******\n               000020 D:  IN A858SES FIND ALL RECORDS FOR WHICH\n               000021       REC-TY = 'SESC'\n               000022     END FIND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ERASE$": {"ttr": 14352, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14!\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:21:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//ERASE    JOB (........),'INSTALL  -ERASE-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=ERASESYM\n//LNK     EXEC PAJILKR,OPT=',RENT'     (ALSO PAJILKA PROBABLY NEEDED)\n//SYSIN     DD *\n  ENTRY   ERASE\n  NAME    ERASE(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ERASE@": {"ttr": 14354, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      ERASE     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *  TERMINAL ERASE SCREEN SUBROUTINE   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *            (TSO COMMAND)            * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Erase the screen of a terminal and set cursor at the\n  ---------    top (row 1 - column 1).\n\n  Calling sequence : CALL ERASE\n  ------------------\n\n  Note :       Being also link-edited into the SYS1.LPALIB, it can\n  ------       be used as a TSO command.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ERASESYM": {"ttr": 14356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x16X\\x00?\\x00?\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T16:58:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "SYSPAJA"}, "text": "TESR     TITLE 'TERMINAL ERASE SCREEN SUBROUTINE/TSO COMMAND.'\nERASE    START 0\n         SPACE 1\n* PURPOSE :    ERASE THE SCREEN OF A TERMINAL AND SET CURSOR AT THE\n* ---------    TOP (ROW 1 - COLUMN 1).\n*\n* CALLING SEQUENCE : CALL ERASE\n* ------------------\n*\n* AUTHOR :     RAVARANI N. - MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 2\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,TYPE=RENT\n        GTSIZE\n         LTR   R4,R0               IS IT A SCREEN TERMINAL?\n         BZ    EXIT                NO, BYPASS\n         USING PSA,R0              WE HAVE TO GET IT FROM ASXB\n         L     R3,PSAAOLD          GET OUR ASCB ADDRESS\n         DROP  R0\n         USING ASCB,R3\n         L     R3,ASCBASXB         GET ASXB ADDRESS\n         DROP  R3\n         USING ASXB,R3\n         L     R2,ASXBMPST         VTAM MEMORY PROCESS SCHED. TABLE\n         DROP  R3\n         LTR   R2,R2               CHECK IF VTAM OR TCAM?\n         BZ    TCAM                ADDRESS DOESN'T EXIST : TCAM\n         CLM   R4,B'0001',SZ24     NORMAL SCREEN SIZE?\n         BNE   ALTSZ               NO\n         LA    R0,CLERNL           NORMAL SIZE\n         LA    R1,CLERN            NORMAL CLEAR\n         B     SEND\nALTSZ    LA    R0,CLERAL           ALTERNATE SIZE\n         LA    R1,CLERA            ALTERNATE CLEAR\nSEND     ICM   R1,B'1000',FUSCR\n        TPUT   (1),(0),R\n        STLINENO LINE=1\n        STTMPMD OFF\n         B     EXIT\nTCAM    TPUT   ERBUF,ERBUFL,ASIS   ERASE SCREEN AND SET CURSOR\nEXIT    $XRET  TYPE=RENT\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nERBUF   $FS    WCC=CLEAR,SF=IC,MF=L\nERBUFL   EQU   *-ERBUF\nCLERN   $FS    CC=EW,WCC=(RMDT),SBA=(1,1),SF=IC,MF=L\nCLERNL   EQU   *-CLERN\nCLERA   $FS    CC=EWA,WCC=(RMDT),SBA=(1,1),SF=IC,MF=L\nCLERAL   EQU   *-CLERA\nSZ24     DC    AL1(24)             24 LINES SCREEN\nFUSCR    DC    XL1'03'\n         SPACE 1\n        PRINT  NOGEN\n        IHAPSA\n        IHAASCB\n        IHAASXB\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EURACFT": {"ttr": 14358, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07O\\x00\\x95\\x07O\\x16!\\x01R\\x01R\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-15T00:00:00", "modifydate": "1995-03-15T16:21:00", "lines": 338, "newlines": 338, "modlines": 0, "user": "SYSPAJA"}, "text": "EURT     TITLE 'EURACFT -- RACF DATA-SET ACCESS TEST - TSO COMMAND.'\nEURACFT  START 0\n         SPACE 1\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*                           E U R A C F T                             *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*\n* FUNCTION :   THIS TSO COMMAND PROCESSOR CHECKS IF A GIVEN RACF ACCESS\n*              IS ALLOWED TO THE CURRENT USER FOR A NON-VSAM DATA-SET.\n*\n* SYNTAX :     EURACFT  DSNAME  VOLUME(......)\n*                       ACCESS(READ/UPDATE/CONTROL/ALTER)\n*                       NOLIST/NOMSG/LIST/MSG/TEST\n*\n* OPERANDS :   REQUIRED - DSNAME\n*              OPTIONAL - VOLUME, ACCESS AND OPTION\n*                         DEFAULTS = ACCESS(READ) NOLIST\n*                                    VOLUME IS RETRIEVED BY CATALOG\n*\n* ATTRIBUTES : RENT\n* LKED OPTIONS : RENT,AC=1\n* RETURN CODES :   0 - ACCESS ALLOWED\n*                  4 - RESOURCE NOT PROTECTED\n*                  8 - ACCESS REJECTED\n*                 12 - PARSE ERROR\n*                 16 - LOCATE ERROR\n*                 20 - RACHECK ERROR\n*                 24 - OTHER (MESSAGE SENT)\n*                 28 - ATTENTION INTERRUPT\n*                 32 - PUTLINE ERROR\n*\n* AUTHOR :     MOINIL P.A.\n*              COMPUTING CENTRE (TP 361)\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\nEURACFT  AMODE 24\nEURACFT  RMODE 24\n         EJECT\n        $DEFREG\n* REGISTER USAGE :\n*              R0-R1 - LINKAGE CONVENTIONS, MACROS\n*              R2-R5 - WORK\n*                 R6 - (UNUSED)\n*                 R7 - LOCAL LINKAGE REGISTER\n*                 R8 - COMPLETION CODE\n*                 R9 - IKJPARMD DSECT\n*                R10 - WKAREA DSECT\n*                R11 - (UNUSED)\n*                R12 - BASE REGISTER\n*                R13 - SAVE AREA POINTER\n*                R14 - LINKAGE CONVENTIONS, RETURN ADDRESS\n*                R15 - LINKAGE CONVENTIONS, RETURN CODE\n         EJECT\n        $XENT  BASE=R12,LV=WKLEN,TYPE=RENT\n         LR    R10,R13             GET WORK-AREA ADDRESS\n         USING WKAREA,R10          ADDRESSABILITY OF WORK-AREA\n         LA    R2,18*4(R10)\n         L     R3,=A(WKLEN-(18*4))\n         LR    R4,R2\n         XR    R5,R5\n         MVCL  R2,R4\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n        $TEW$PP PARM=PARMLST,REG=R9,ATT=ATTINT,ERR=PARSERR\n         SPACE 1\n*------- GET DATA-SET NAME\n         SPACE 1\n         MVI   DSNTF,C' '          CLEAR DSN + TRAILING SPACE\n         MVC   DSNTF+1(L'DSNTF-1),DSNTF\n         LH    R3,PDSN+4           R3 IS LENGTH OF DSN\n         L     R2,PDSN             R2 POINTS TO DSN\n         BCT   R3,*+L'*+6\n         MVC   DSNTF(*-*),0(R2)    GET DSN\n         EX    R3,*-6\n         SPACE 1\n*------- GET VOLUME SERIAL NUMBER IF SPECIFIED\n         SPACE 1\n         MVC   VOLTF,=CL6' '\n         TM    KVOL+6,X'80'        VOLUME SPECIFIED?\n         BZ    *+L'*+22            NO\n         LH    R3,KVOL+4           R3 IS LENGTH OF VOL\n         L     R2,KVOL             R2 POINTS TO VOL\n         BCT   R3,*+L'*+6\n         MVC   VOLTF(*-*),0(R2)    GET VOL\n         EX    R3,*-6\n         SPACE 1\n*------- GET ACCESS-NAME IF SPECIFIED\n         SPACE 1\n         LH    R2,KACC\n         XR    R0,R0\n         IC    R0,ACCNT(R2)\n         STC   R0,ACCTF\n         SPACE 1\n*------- SET OPTION IF SPECIFIED\n         SPACE 1\n         CLC   KLIST(2),=H'2'\n         BL    *+L'*+12\n         BE    *+L'*+4\n         OI    SWITCH,SWTEST       SAY TEST MESSAGES\n         OI    SWITCH,SWLMSG       SAY LIST MESSAGES\n         SPACE 1\n*------- RETRIEVE ON VOLUME\n         SPACE 1\n         MVC   CAMLIST(CAMLLEN),CAMSKEL\n         LA    R1,DSNTF\n         ST    R1,CAMLIST+4\n         LA    R1,LOCAREA\n         ST    R1,CAMLIST+12\n         XC    LOCAREA(256),LOCAREA\n         XC    LOCAREA+256(LLOCAREA-256),LOCAREA+256\n        LOCATE CAMLIST\n         LTR   R15,R15             CATALOGED ?\n         BZ    CTLGOK              YES\n         CH    R15,=H'8'\n         BNE   CTLERR\n         CH    R0,=H'8'\n         BNE   CTLERR\n         TM    SWITCH,SWTEST+SWLMSG TEST OR LIST MESSAGES ?\n         BZ    NOLMLO              NONE\n         MVC   MSGAREA(12),=CL12' DATA-SET :'\n         MVC   MSGAREA+12(L'DSNTF),DSNTF\n         LA    R1,MSGAREA+12+L'DSNTF-1\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         MVC   1(13,R1),=CL13' - NOT FOUND.'\n         LA    R0,MSGAREA\n         SLR   R1,R0\n         LA    R0,14(R1)\n         LA    R1,MSGAREA\n         BAS   R7,SNDLNE\n         TM    SWITCH,SWTEST       TEST MESSAGES ?\n         BO    NOLMLO              YES\n         MVC   MSGAREA(37),=CL37' YOU MAY RETRY SPECIFYING THE VOLUME.'\n         LA    R0,37\n         LA    R1,MSGAREA\n         BAS   R7,SNDLNE\n         B     NOLMLO\nCTLERR   TM    SWITCH,SWTEST       TEST MESSAGES ?\n         BZ    NOTSLO              NO\n         STM   R15,R1,DIAGR\n         MVC   MSGAREA(17),=CL17' LOCATE R15-R1 :'\n         UNPK  MSGAREA+17(9),DIAGR(5)\n         TR    MSGAREA+17(8),TRHEX-X'F0'\n         MVI   MSGAREA+25,C'-'\n         UNPK  MSGAREA+26(9),DIAGR+4(5)\n         TR    MSGAREA+26(8),TRHEX-X'F0'\n         MVI   MSGAREA+34,C'-'\n         UNPK  MSGAREA+35(9),DIAGR+4(5)\n         TR    MSGAREA+35(8),TRHEX-X'F0'\n         MVI   MSGAREA+43,C'.'\n         LA    R0,44\n         LA    R1,MSGAREA\n         BAS   R7,SNDLNE\n         L     R15,DIAGR\nNOTSLO   TM    SWITCH,SWLMSG       LIST MESSAGES ?\n         BZ    NOLMLO              NO\n         MVC   MSGAREA(35),=CL35' CATALOG (LOCATE) ERROR (RC =    ).'\n         CVD   R15,DBLWRD\n         MVC   DBLWRD(4),=CL4'40202120'\n         ED    DBLWRD(4),DBLWRD+L'DBLWRD-2\n         MVC   MSGAREA+29(4),DBLWRD+1\n         LA    R0,35\n         LA    R1,MSGAREA\n         BAS   R7,SNDLNE\n         B     NOLMLO\nCTLGOK   MVC   OLDVSN,=CL6' '\n         CLI   VOLTF,C' '          VOLUME SPECIFIED ?\n         BE    GOVOLS              NO, GO SUPPLY IT\n         CLC   VOLTF(L'VOLTF),LOCAREA+6 IS IT THE FIRST ONE ?\n         BE    GOCHKR              YES\n         LH    R0,LOCAREA          NO, CHECK IF MULTI-VOLUMES\n* NOTE - AT OUR INSTALLATION WE HAVE VERY FEW NUMBER OF MULTI-VOLUMES\n*        DATA-SETS, AND THEY NEVER HAVE MORE THAN TWO OR THREE VOLUMES.\n*        SO, HERE AFTER, WE CHECK ONLY FOR THE FIRST TWENTY VOLUMES,\n*        AND IF NO MATCH IS FOUND, IT MEANS A NOT CATALOGED DATA-SET.\n         LA    R1,20\n         CLR   R0,R1\n         BNH   *+L'*+2\n         LR    R0,R2\n         LA    R2,LOCAREA+2\nMVCHKL   CLC   VOLTF(L'VOLTF),4(R2)\n         BE    *+L'*+12\n         LA    R2,12(,R2)\n         BCT   R0,MVCHKL\n         B     GOCHKR\n         MVC   OLDVSN,VOLTF\nGOVOLS   MVC   VOLTF(L'VOLTF),LOCAREA+6\n         SPACE 1\n*------- CHECK THE RESOURCE (RACHECK)\n         SPACE 1\nGOCHKR   LA    R2,DSNTF\n         LA    R3,VOLTF\n         XR    R4,R4\n         IC    R4,ACCTF\n         MVC   RPLIST(RPLLEN),RPSKEL\n         XR    R5,R5\n         CLI   OLDVSN,C' '\n         BE    *+L'*+4\n         LA    R5,OLDVSN\n        ZEROKEY\n        RACHECK ENTITY=((R2)),VOLSER=(R3),ATTR=(R4),OLDVOL=(R5),       X\n               MF=(E,RPLIST)\n         STM   R15,R0,DIAGR\n        RESETKEY\n         TM    SWITCH,SWTEST       TEST MESSAGES ?\n         BZ    NOTSRA              NO\n         MVC   MSGAREA(25),=CL25' RACHECK - RETURN CODE :'\n         UNPK  MSGAREA+25(3),DIAGR+3(2)\n         TR    MSGAREA+25(2),TRHEX-X'F0'\n         CH    R15,=H'8'\n         BH    NORSC\n         MVC   MSGAREA+27(17),=CL17' / REASON CODE :'\n         UNPK  MSGAREA+44(3),DIAGR+7(2)\n         TR    MSGAREA+44(2),TRHEX-X'F0'\n         MVI   MSGAREA+46,C'.'\n         B     NORSC+L'NORSC\nNORSC    MVC   MSGAREA+27(20),=CL20' / NO REASON CODE.'\n         LA    R0,47\n         LA    R1,MSGAREA\n         BAS   R7,SNDLNE\nNOTSRA   TM    SWITCH,SWLMSG       LIST MESSAGES ?\n         BZ    NOLMRA              NO\n         L     R15,DIAGR\n         CH    R15,=H'8'\n         BNH   *+L'*+10\n         MVC   MSGAREA(32),=CL32' UNEXPECTED RACHECK RETURN CODE.'\n         B     RCMSG\n         MVC   MSGAREA(13),=CL13' RESOURCE IS'\n         CH    R15,=H'4'\n         BH    RC08\n         BE    RC04\n         MVC   MSGAREA+13(19),=CL19'RACF AUTHORIZED.'\n         B     RCMSG\nRC04     MVC   MSGAREA+13(19),=CL19'NOT RACF PROTECTED.'\n         B     RCMSG\nRC08     MVC   MSGAREA+13(19),=CL19'RACF UNAUTHORIZED.'\nRCMSG    LA    R0,32\n         LA    R1,MSGAREA\n         BAS   R7,SNDLNE\nNOLMRA   L     R8,DIAGR            SET RETURN CODE(S) ----------- 0 4 8\n         CH    R8,=H'8'\n         BNH   LEAVE\n         LA    R8,20               SET RETURN CODE ----------------- 20\n         B     LEAVE\n         SPACE 1\n*------- TERMINATION\n         SPACE 1\nSETRC    LA    R8,24               SET RETURN CODE ----------------- 24\n         B     QUIT\nATTINT   LA    R8,28               SET RETURN CODE ----------------- 28\n         B     QUIT\nPUTERR   LA    R8,32               SET RETURN CODE ----------------- 32\n         B     LEAVE\nNOLMLO   LA    R8,16               SET RETURN CODE ----------------- 16\n         B     LEAVE\nPARSERR  LA    R8,12               SET RETURN CODE ----------------- 12\nLEAVE   IKJRLSA #TSANSW            RELEASE PDL\nQUIT    $XRET  CC=(R8),LV=WKLEN,TYPE=RENT\n         SPACE 1\n*------- SEND LINE TO TERMINAL ROUTINE\n*              R7 = LINK REGISTER\n         SPACE 1\nSNDLNE   BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     0(R7)               +0 - NORMAL COMPLETION\n         B     PUTERR              +4 - ERROR\n         DROP  R9,R10\n         EJECT\n*------- DATA CONSTANTS\n         SPACE 1\nCAMSKEL CAMLST NAME,*-*,,*-*\nCAMLLEN  EQU   *-CAMSKEL\nRPSKEL  RACHECK ENTITY=(*-*),VOLSER=*-*,CLASS='DATASET',ATTR=READ,     X\n               OLDVOL=*-*,RELEASE=1.8,LOG=NOSTAT,MF=L\nRPLLEN   EQU   *-RPSKEL\nTRHEX    DC    CL16'0123456789ABCDEF'\nACCNT    DC    AL1(X'02',X'02',X'04',X'08',X'80')\n         SPACE 1\n        LTORG\n         EJECT\n*------- PARSE PARAMETERS LIST\n         SPACE 1\n         PRINT NOGEN\nPARMLST  IKJPARM  DSECT=IKJPARMD\nPDSN     IKJPOSIT DSNAME,USID,PROMPT='NAME OF DATA-SET TO BE CHECKED'\nVOLKW    IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VOLSUB,ALIAS=('VOL','V')\nACCKW    IKJKEYWD\n         IKJNAME 'ACCESS',SUBFLD=ACCSUB,ALIAS=('ACC','A')\nKLIST    IKJKEYWD DEFAULT='NOLIST'\n         IKJNAME  'NOLIST',ALIAS=('NOMSG','NL','NM','N')\n         IKJNAME  'LIST',ALIAS=('MSG','L','M')\n         IKJNAME  'TEST',ALIAS=('T')\nVOLSUB   IKJSUBF\nKVOL     IKJIDENT 'VOLUME',FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6,    X\n               PROMPT='VOLUME SERIAL NUMBER'\nACCSUB   IKJSUBF\nKACC     IKJKEYWD DEFAULT='READ'\n         IKJNAME 'READ',ALIAS=('R')\n         IKJNAME 'UPDATE',ALIAS=('U')\n         IKJNAME 'CONTROL',ALIAS=('C')\n         IKJNAME 'ALTER',ALIAS=('A')\n         IKJENDP\n         PRINT GEN\n         EJECT\n*------- DATA WORK-AREA\n         SPACE 1\nWKAREA   DSECT\n         DS    18F                 REGISTER SAVE AREA\n         SPACE 1\nCAMLIST  DS    0F,(CAMLLEN)X\nLOCAREA  DS    0D,XL268\nLLOCAREA EQU   *-LOCAREA\nRPLIST   DS    0F,(RPLLEN)X\n         SPACE 1\n        $TEW$WA\n         SPACE 1\nDBLWRD   DS    D\nDIAGR    DS    3F\nMSGAREA  DS    CL80                OUTPUT MESSAGE LINE\n         SPACE 1\nDSNTF    DS    CL45                DSNAME + A TRAILING SPACE\nACCTF    DS    XL1                 ACCESS\nVOLTF    DS    CL6                 VOLUME SERIAL NUMBER\nOLDVSN   DS    CL6                 VOLUME SERIAL NUMBER\nSWITCH   DS    XL1\nSWLMSG   EQU   X'80'               LIST MESSAGES\nSWTEST   EQU   X'40'               TEST MESSAGES\n         SPACE 1\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8     LENGTH OF WKAREA DATA AREA\n         SPACE 1\n*------- MAPPING MACROS\n         SPACE 1\n         PRINT NOGEN\n       $TEW$DS\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EURACFT$": {"ttr": 14598, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14!\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:21:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//EURACFT  JOB (........),'INSTALL  - EURACFT -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=EURACFT\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   EURACFT\n  NAME    EURACFT(R)\n/*\n//HLP     EXEC PAJHELP,MBR=EURACFTH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EURACFT@": {"ttr": 14600, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12_\\x00\\x94\\x12_\\x16I\\x004\\x004\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-05T00:00:00", "modifydate": "1994-05-05T16:49:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/10/90\n                                                      EURACFT   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         EURACFT TSO command         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :    RACF data-set access test TSO-command.\n  ----------    This TSO command processor checks if a given RACF\n                access is allowed to the current user for a non-VSAM\n                data-set (RACF class DATASET).\n  Syntax :      EURACFT  DSNAME  VOLUME(......)\n  --------               ACCESS(READ/UPDATE/CONTROL/ALTER)\n                         NOLIST/NOMSG/LIST/MSG/TEST\n                Notes : - if DSNAME is omited, the user will be\n                          prompted to supply it.\n                        - if VOLUME is omited, the command try to\n                          locate the data-set through the catalog.\n                Required : DSNAME\n                Optional : VOLUME, ACCESS and Option\n                           Defaults : ACCESS(READ) NOLIST\n                Return codes (&LASTCC value) :\n                    0 - ACCESS allowed\n                    4 - Resource not protected\n                    8 - ACCESS rejected\n                   12 - TSO command scan error\n                   16 - CATALOG search error\n                   20 - RACF search error\n                   24 - All other errors (message sent)\n                   28 - Attention interrupt\n                   32 - PUTLINE error\n  Operands :\n  ----------\n  DSNAME :      Data-set name (TSO data-set naming convention applied).\n                E.g. : TEST.DATA or 'User-ID.TEST.DATA'\n  VOLUME :      Volume serial number if the data-set is not cataloged\n                or is not the first volume of a multi-volumes data-set.\n                Aliases : VOL or V\n                E.g. : VOLUME(USER00) or VOL(USER00) or V(USER00)\n  ACCESS :      The RACF access you want test for availability.\n                Aliases : ACC or A\n                Access request may be : READ    - Alias : R\n                                        UPDATE  - Alias : U\n                                        CONTROL - Alias : C\n                                        ALTER   - Alias : A\n                E.g. : ACCESS(UPDATE) or ACC(U) or A(U)\n  Option :      The messages option :\n                   NOLIST - Aliases : NOMSG, NL, NM or N\n                   LIST   - Aliases : MSG, L or M\n                E.g. : LIST or MSG or L or M\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EURACFTH": {"ttr": 14602, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943o\\x00\\x943o\\t\\x05\\x00-\\x00-\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-02T00:00:00", "modifydate": "1994-12-02T09:05:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=EURACFT\n./     NUMBER  NEW1=100,INCR=100\n)F Function :  RACF data-set access test TSO-command.\n               This TSO command processor checks if a given RACF access\n               is allowed to the current user for a non-VSAM data-set\n               (RACF class DATASET).\n)X Syntax :    EURACFT  DSNAME  VOLUME(......)\n                        ACCESS(READ/UPDATE/CONTROL/ALTER)\n                        NOLIST/NOMSG/LIST/MSG/TEST\n               Notes : - if DSNAME is omited, the user will be prompted\n                         to supply it.\n                       - if VOLUME is omited, the command try to locate\n                         the data-set through the catalog.\n               Required : DSNAME\n               Optional : VOLUME, ACCESS and Option\n                          Defaults : ACCESS(READ) NOLIST\n               Return codes (&LASTCC value) :\n                   0 - ACCESS allowed\n                   4 - Resource not protected\n                   8 - ACCESS rejected\n                  12 - TSO command scan error\n                  16 - CATALOG search error\n                  20 - RACF search error\n                  24 - All other errors (message sent)\n                  28 - Attention interrupt\n                  32 - PUTLINE error\n)O Operands :\n))DSNAME :     Data-set name (TSO data-set naming convention applied).\n               E.g. : TEST.DATA or 'User-ID.TEST.DATA'\n))VOLUME :     Volume serial number if the data-set is not cataloged\n               or is not the first volume of a multi-volumes data-set.\n               Aliases : VOL or V\n               E.g. : VOLUME(USER00) or VOL(USER00) or V(USER00)\n))ACCESS :     The RACF access you want test for availability.\n               Aliases : ACC or A\n               Access request may be : READ    - Alias : R\n                                       UPDATE  - Alias : U\n                                       CONTROL - Alias : C\n                                       ALTER   - Alias : A\n               E.g. : ACCESS(UPDATE) or ACC(U) or A(U)\n))Option :     The messages option :\n                  NOLIST - Aliases : NOMSG, NL, NM or N\n                  LIST   - Aliases : MSG, L or M\n               E.g. : LIST or MSG or L or M\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EUSID": {"ttr": 14604, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x934\\x7f\\x00\\x934\\x7f\\x10\\x08\\x02B\\x02B\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-12-13T00:00:00", "modifydate": "1993-12-13T10:08:00", "lines": 578, "newlines": 578, "modlines": 0, "user": "SYSPAJA"}, "text": "EUID     TITLE 'EUSID - SET CURRENT ENVIRONMENT TSO CLIST VARIABLES.'\nEUSID    START 0\n         SPACE 1\n*--------------------------------------------------------------------*\n* NAME :       EUSID                                                 *\n* PURPOSE :    THIS MODULE WILL ESTABLISH A SERIES OF TSO CLIST      *\n*              VARIABLES DESCRIBING THE CURRENT ENVIRONMENT          *\n* INPUT :      NONE                                                  *\n* OUTPUT :     TSO CLIST VARIABLES                                   *\n*                  EUACCNO - CURRENT ACCOUNT NUMBER FIELD (ACT)      *\n*                  EUASID - THE CURRENT ASID NUMBER                  *\n*                  EUCPUID - 5 DIGIT CPU SERIAL NUMBER               *\n*                  EUCPUTY - 4 DIGIT CPU MODEL DESIGNATION           *\n*                  EUCPUV - 2 CHAR. CPUID VERSION CODE FIELD         *\n*                  EUDOUTD - DEFAULT SYSOUT DESTINATION              *\n*                  EUDUNIT - DEFAULT ALLOCATION UNIT NAME            *\n*                  EUJOBID - CURRENT SESSION JES JOB ID              *\n*                  EUPIEI - UNDER PIE INDICATOR (YES OR NO)          *\n*                  EUPIESC - PIE SWITCH CHARACTER                    *\n*                  EUPIESK - PIE SWITCH KEY VALUE (ENTER, PF1-PF24)  *\n*                  EUPIESN - PIE SESSION NUMBER (0-9,A,B)            *\n*                  EUPNAME - CURRENT PROGRAMMER NAME FIELD (ACT)     *\n*                  EUREGSZ - TSO USER'S REGION SIZE IN K             *\n*                  EURGRNM - GROUP NAME (ACEE)                       *\n*                  EURTERM - TERMINAL ID (ACEE)                      *\n*                  EURUSID - USER ID (ACEE)                          *\n*                  EURUSNM - USER NAME (ACEE)                        *\n*                  EUSESSM - UNDER SESSION MANAGER (YES OR NO)       *\n*                  EUSFMID - THE SYSTEM FMID (I.E., JBB2220)         *\n*                  EUSMFID - THE SMF SYSTEM ID                       *\n*                  EUSNAME - THE IEASYSXX SYSTEM NAME                *\n*                  EUSNODE - JES2 NJE NODE NAME                      *\n*                  EUSPFI - UNDER SPF INDICATOR (YES OR NO)          *\n*                  EUSRLNO - THE SYSTEM RELEASE NUMBER (I.E., 038)   *\n*                  EUSTYPE - THE SYSTEM TYPE (XA OR 370)             *\n*                  EUSUBSY - NAME OF LIFE OF JOB SUBSYSTEM           *\n*                  EUSWAL - LOCATION OF SWA (I.E., ABOVE OR BELOW)   *\n*                  EUSYVER - THE SYSTEM VERSION (I.E., SP2.2.0)      *\n* RETURN :     (IN REGISTER 15)                                      *\n*              0 = OK, DONE                                          *\n*              8 = ERROR, MESSAGE OUTPUTED                           *\n* MODULE :     RE-ENTRANT AND REFRESHABLE                            *\n* MODE :       RESIDENCY : ANY                                       *\n*              ADDRESSING : 31                                       *\n*--------------------------------------------------------------------*\n         EJECT\n        PRINT  OFF\n         MACRO\n&NAME   @STV   &VN,&VV\n.* STORE VARIABLE MACRO :\n.*            VN = VARIABLE NAME FIELD\n.*            VV = VARIABLE VALUE FIELD\n         LA    R2,&VN\n         LA    R3,L'&VN\n         LA    R1,&VV\n         LA    R0,L'&VV\n         BAS   R14,STOVAR\n         MEND\n        PRINT  ON\n         SPACE 1\nEUSID   AMODE  31\nEUSID   RMODE  ANY\n         SPACE 1\n        $DEFREG\n         EJECT\n*--------------------------------------------------------------------*\n*        REGISTERS GENERAL USE :                                     *\n*              R0  = PSA DUMMY POINTER                               *\n*              R7  = TCB POINTER                                     *\n*              R8  = TSVT POINTER                                    *\n*              R9  = CVT POINTER                                     *\n*              R10 = RETURN CODE                                     *\n*              R11 = WORK AREA POINTER                               *\n*              R12 = BASE REGISTER                                   *\n*--------------------------------------------------------------------*\n         SPACE 1\n*--------------------------------------------------------------------*\n*        ENTRY.                                                      *\n*--------------------------------------------------------------------*\n         SPACE 1\n        $XENT  BASE=R12,LV=WORKLENG,TYPE=RENT\n         LR    R11,R13\n         USING WORKAREA,R11\n         XR    R10,R10\n         XC    ATSO,ATSO\n         EJECT\n*--------------------------------------------------------------------*\n*        RETRIEVE VARIABLES VALUES.                                  *\n*--------------------------------------------------------------------*\n         SPACE 1\n         USING PSA,R0\n         L     R9,CVTPTR           FIND CVT\n         USING CVTMAP,R9\n         L     R8,CVTTVT           FIND THE TSVT\n         USING TSVT,R8\n         SPACE 1\n         L     R2,CVTSMCA          FIND SMCA\n         USING SMCABASE,R2\n         MVC   SMFID,SMCASID       GET SYS-ID\n         DROP  R2\n         LR    R2,R9               COPY THE CVT ADDRESS\n         SL    R2,=A(CVTMAP-CVTFIX)     GET THE PREFIX ADDRESS\n         USING CVTFIX,R2\n         MVC   SNAME,CVTSNAME      CVT SYSTEM NAME\n         MVC   TYPE,=CL3'XA '      SET THE SYSTEM TYPE\n         TM    CVTDCB,CVTMVSE      TEST FOR MVS/XA\n         BO    *+L'*+6             BRANCH IF AT LEAST MVS/XA\n         MVC   TYPE,=CL3'370'      SET THE OLD SYSTEM TYPE\n         TM    CVTDCB,X'08'        TEST FOR CVTOSLVL PRESENT (CVTOSEXT)\n         BZ    *+L'*+14            BRANCH IF NOT PRESENT\n         TM    CVTNUCLU+L'CVTNUCLU,X'80' TEST FOR ESA (CVTOSLVL,CVTXAX)\n         BZ    *+L'*+6             BRANCH IF NOT PRESENT\n         MVC   TYPE,=CL3'ESA'      SET FOR MVS/ESA\n         MVC   VERSION,CVTPRODN    SET THE SYSTEM VERSION\n         MVC   FMID,CVTPRODI       SET THE SYSTEM FUNCTION ID\n         MVC   RELEASE,CVTRELNO    SET THE SYSTEM RELEASE NUMBER\n         DROP  R2\n         MVC   NJENODE,=CL8' '     RESET THE BASE NODE NAME\n         L     R1,CVTJESCT         JES COMM TABLE\n         USING JESCT,R1\n         ICM   R2,B'1111',JESSSCT  SSCT POINTER\n         BZ    JES2END             NONE\n         USING SSCT,R2\nJES2SLP  CLC   SSCTID,=CL4'SSCT'   RIGHT ID?\n         BNE   JES2END             NO, JUMP\n         CLC   SSCTSNAM,=CL4'JES2' JES2 SSCT?\n         BE    JES2SCN             YES\n         ICM   R2,B'1111',SSCTSCTA NO, GET NEXT SSCT\n         BNZ   JES2SLP             AND LOOP IF MORE\n         B     JES2END             ELSE JES2 NOT FOUND\n         DROP  R1\nJES2SCN  ICM   R7,B'1111',SSCTSSVT SSVT POINTER\n         BZ    JES2END             NONE\n         DROP  R2\n         ICM   R5,B'1111',SVTRDT(R7) RMT DESTINATION TABLE\n         BZ    JES2END             NONE, JUMP\n         ICM   R6,B'1111',SVTRDTE(R7) LAST RDT ELEMENT ADDRESS\n         BZ    JES2END             NONE, JUMP\n         CLR   R5,R6\n         BH    JES2END             NONE, JUMP\n         USING RDT,R5\nJES2TST  TM    RDTFLAG,RDTFLAGN    N NUMBER?\n         BZ    JES2NXT             NO\n         CLC   RDTNODE,SVTTONOD(R7) YES, OWN NODE ID?\n         BNE   JES2NXT             NO\n         MVC   NJENODE,RDTNAME     YES, SET OWN NODE NAME\n         B     JES2END\nJES2NXT  LA    R5,RDTSIZ(R5)       NEXT ELEMENT\n         CLR   R5,R6               LAST DONE?\n         BNH   JES2TST             NO, CONTINUE SEARCH\n         DROP  R5\nJES2END  L     R2,PSAAOLD          LOAD THE ASCB ADDRESS\n         USING ASCB,R2\n         LH    R0,ASCBASID         LOAD THE ASID NUMBER\n         DROP  R2\n         CVD   R0,DOUBLE           DECIMALIZE IT\n         OI    DOUBLE+7,X'0F'      FIX THE SIGN\n         UNPK  ASID,DOUBLE+5(3)    STICK IT\n         L     R7,PSATOLD          LOAD THE CURRENT TCB ADDRESS\n         USING TCB,R7\n         L     R5,TCBJSCB          LOAD THE JSCB ADDRESS\n         USING IEZJSCB,R5\n         L     R5,JSCBACT          LOAD THE CURRENT JSCB ADDRESS\n         L     R1,JSCBSSIB         LOAD THE SSIB ADDRESS\n         USING SSIB,R1\n         MVC   JESJOBID,SSIBJBID   MOVE THE JOB ID\n         MVC   SUBSYSTM,SSIBSSNM   MOVE THE SUBSYSTEM NAME\n         DROP  R1\n         L     R1,CVTPCCAT         LOAD ADDRESS OF PCCA VECTOR TABLE\n         USING PCCAVT,R1\n         LA    R0,16               SET MAXIMUM NUMBER OF CPUS\nLOOPPCCA ICM   R15,B'1111',PCCAT00P     LOAD THE PCCA POINTER\n         BNZ   GOTPCCA             BRANCH IF WE FOUND ONE\n         LA    R1,4(,R1)           INCREMENT TO NEXT PCCA POINTER\n         BCT   R0,LOOPPCCA         LOOP THROUGH THE PCCA\n         DROP  R1\n         MVC   CPUVERSN(L'CPUVERSN),=CL8' '  NO CPU VERSION CODE\n         MVC   CPUID(L'CPUID),=CL8' '   NO CPU SERIAL NUMBER\n         MVC   CPUTYPE(L'CPUTYPE),=CL8' '    NO MODEL TYPE\n         B     NOPCCA              OOPS ...\n         USING PCCA,R15\nGOTPCCA  MVC   CPUVERSN,PCCACPID+0 MOVE THE CPU VERSION CODE\n         MVC   CPUID,PCCACPID+3    MOVE THE CPU SERIAL NUMBER\n         MVC   CPUTYPE,PCCACPID+8  MOVE THE MODEL TYPE\n         DROP  R15\nNOPCCA   L     R1,JSCBPSCB         LOAD THE ADDRESS OF THE PSCB\n         USING PSCB,R1\n         MVC   SYSOUTD,PSCBDEST    GET DEFAULT SYSOUT DEST. NAME\n         OC    SYSOUTD,SYSOUTD\n         BNZ   *+L'*+6\n         MVC   SYSOUTD,=CL8' '\n         MVC   UNITNAME,PSCBGPNM   GET ALLOCATION UNIT NAME\n         L     R0,PSCBRSZ          LOAD THE TSO REGION SIZE (IN 2K)\n         SLL   R0,1                DOUBLE IT TO GET K\n         CVD   R0,DOUBLE           CONVERT IT TO DECIMAL\n         OI    DOUBLE+7,X'0F'      FIX THE SIGN\n         UNPK  REGIONSZ,DOUBLE+5(3)     STICK IT\nREGIONLP CLI   REGIONSZ,C'0'       CHECK FOR A LEADING ZERO\n         BNE   REGIONDN            BRANCH IF NOT\n         MVC   REGIONSZ(L'REGIONSZ-1),REGIONSZ+1 SHIFT LEFT\n         MVI   REGIONSZ+L'REGIONSZ-1,C' ' BLANK OUT RIGHT HAND SIDE\n         B     REGIONLP            AND TRY AGAIN\n         DROP  R1                  DONE WITH THE PSCB\nREGIONDN ICM   R5,B'0111',JSCBJCTA LOAD THE JOB CONTROL TABLE ADDRESS\n         DROP  R5\n         LA    R5,ZB502L(,R5)      INCREMENT PAST HEADER\n         USING INJMJCT,R5\n         MVC   SWALOCTN,=CL5'ABOVE'     SET THE SWA LOCATION\n         TM    JCTSTAT2,JCTSWAUP   TEST IF SWA IS REALLY ABOVE THE LINE\n         BO    *+L'*+6\n         MVC   SWALOCTN,=CL5'BELOW'     INDICATE SWA IS BELOW THE LINE\n         XR    R4,R4\n         ICM   R4,B'0111',JCTACTAD LOAD THE ACCOUNTING CONTROL TABLE\n         DROP  R5\n         LA    R4,ZB502L(,R4)\n         USING IEFAACTB,R4\n         MVC   PGRNAME,ACTPRGNM    COPY THE PROGRAMMER NAME FIELD\n         MVI   ACCTNUM,C' '\n         MVC   ACCTNUM+1(L'ACCTNUM-1),ACCTNUM\n         CLI   ACTJNFLD,1          CHECK FOR AT LEAST ONE FIELD\n         BL    NOACCTNO\n         XR    R1,R1               CLEAR FOR INSERT\n         LA    R15,ACTACCNT        POINT AT FIRST FIELD\n         IC    R1,0(,R15)          INSERT THE ACCT NUMBER LENGTH\n         LA    R0,L'ACCTNUM\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         BCT   R1,*+L'*+6          DECREMENT FOR MVC\n         MVC   ACCTNUM(*-*),1(R15)\n         EX    R1,*-6\n         DROP  R4\nNOACCTNO MVC   SPFSTAT,=CL3'YES'   ASSUME SPF IS ACTIVE\nFSALOOP  L     R1,TCBFSA           LOAD THE SAVE AREA ADDRESS\n         LTR   R1,R1               IS THERE NO SAVE AREA\n         BE    NEXTTCB             BRANCH IF NOT\n         L     R1,24(,R1)          LOAD THE SAVE AREA'S REG 1\n         LTR   R1,R1               TEST FOR NO ADDRESS IN REG 1\n         BE    NEXTTCB             BRANCH IF NOT\n         CLM   R1,B'1000',=X'00'   CHECK FOR 24 BIT ADDRESS\n         BNE   NEXTTCB             BRANCH IF NOT\n         L     R2,0(,R1)           LOAD THE ADDRESS OF THE TLD\n         CLC   0(3,R2),=CL3'TLD'   IS THIS REALLY THE TLD\n         BE    SPFHERE             BRANCH IF SO\nNEXTTCB  L     R7,TCBOTC           LOAD PREVIOUS TCB\n         CL    R7,TCBJSTCB         HAVE WE REACHED THE TOP\n         BNE   FSALOOP             LOOP IF NOT\n         MVC   SPFSTAT,=CL3'NO '   SO WE WERE WRONG ...\nSPFHERE  MVC   SESSTAT,=CL3'NO '   ASSUME SESS MNGR IS INACTIVE\n         L     R2,PSAAOLD          LOAD THE ASCB ADDRESS\n         USING ASCB,R2\n         L     R3,ASCBASXB         LOAD THE ASXB ADDRESS\n         DROP  R2\n         USING ASXB,R3\n         ICM   R2,B'1111',ASXBLWA  LOAD THE LWA ADDRESS\n         DROP  R3\n         BZ    SESSNOT             BRANCH IF NONE - NO SESS MNGR\n         USING LWA,R2\n         ICM   R0,B'1111',LWAXXXX  LOAD THE SESSION MANAGER POINTER\n         DROP  R2\n         BZ    SESSNOT             BRANCH IF NOT PRESENT\n         MVC   SESSTAT,=CL3'YES'   SO WE WERE WRONG ...\nSESSNOT  MVC   PIESTAT,=CL3'NO '   ASSUME PIE IS NOT ACTIVE\n         MVI   PIESESSN,C'0'       SESSION ZERO NOT ACTIVE\n         MVC   PIESWKEY,=CL5'NONE '     SET NO SWITCH KEY\n         MVI   PIESWCHR,C' '       SET NO SWITCH CHARACTER\n         L     R7,PSATOLD          LOAD THE CURRENT TCB ADDRESS\n         L     R7,TCBJSTCB         LOAD THE JOB STEP TCB ADDRESS\n         L     R7,TCBOTC           LOAD THE OWNING TCB ADDRESS\n         CLC   TCBGRS7,=CL4'PIE1'  CHECK FOR THE PIE TCB\n         BNE   NOTPIE              BRANCH IF NOT\n         L     R15,TCBRBP          LOAD THE RB ADDRESS\n         USING RBBASIC,R15\n         TM    RBOPSWB2,RBOPSWPS+X'F0'  TEST THE PSW IN THIS RB\n         BNZ   NOTPIE              BRANCH IF NOT ALL ZEROS\n         DROP  R15\n         L     R15,TCBGRS9         LOAD THE PIE SCVT ADDRESS\n         CLC   0(4,R15),=CL4'SCVT' IS IT REALLY THE SCVT?\n         BNE   NOTPIE              BRANCH IF NOT\n         L     R14,8(,R15)         LOAD THE PIE STCB ADDRESS\n         CLC   0(4,R14),=CL4'STCB' IS IT REALLY THE STCB\n         BNE   NOTPIE              BRANCH IF NOT\n         MVC   PIESTAT,=CL3'YES'   SET PIE ACTIVE TO YES\n         MVC   PIESWCHR,X'A7'(R15) GET THE SWITCH CHARACTER\n         MVC   PIESWKEY(4),X'A2'(R15)   GET THE SWITCH KEY\n         CLI   PIESWKEY,C'E'       COULD IT BE 'ENTER'\n         BNE   *+L'*+6\n         MVC   PIESWKEY,=CL5'ENTER'     SET ENTER IF SO\n         MVC   PIESESSN,X'84'(R14) PICK UP THE SESSION NUMBER\nNOTPIE   L     R2,PSAAOLD\n         USING ASCB,R2\n         L     R3,ASCBASXB\n         DROP  R2\n         USING ASXB,R3\n         L     R2,ASXBSENV\n         DROP  R3\n         USING ACEE,R2\n         MVC   TERMNAME,ACEETRID   SET TERMINAL ID\n         MVC   USERID,ACEEUSRI     SET USER ID\n         MVC   GROUPN,ACEEGRPN     SET GROUP NAME\n         MVI   USERNAME,C' '\n         MVC   USERNAME+1(L'USERNAME-1),USERNAME\n         L     R3,ACEEUNAM\n         XR    R1,R1\n         IC    R1,0(R3)\n         BCT   R1,*+L'*+4\n         B     NOUSNM\n         LA    R0,L'USERNAME\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         BCT   R1,*+L'*+6\n         MVC   USERNAME(*-*),1(R3)\n         EX    R1,*-6              SET USER NAME\n         DROP  R2\nNOUSNM   CLC   PGRNAME(8),=CL8' '  PROGRAMMER NAME FIELD EXIST?\n         BNE   *+L'*+6             YES\n         MVC   PGRNAME,USERNAME    NO, COPY TO PROGRAMMER NAME FIELD\n         EJECT\n*--------------------------------------------------------------------*\n*        CONSTRUCT PARM.LIST FOR IKJCT441.                           *\n*--------------------------------------------------------------------*\n         SPACE 1\n         LA    R0,TSVEUPDT\n         ST    R0,ENTRYCDE\n         LA    R0,ENTRYCDE\n         ST    R0,CT441PRM+0\n         LA    R0,VARINAME\n         ST    R0,NAMEADDR\n         LA    R0,NAMEADDR\n         ST    R0,CT441PRM+4\n         LA    R0,NAMELENG\n         ST    R0,CT441PRM+8\n         LA    R0,DATAADDR\n         ST    R0,CT441PRM+12\n         LA    R0,DATALENG\n         ST    R0,CT441PRM+16\n         LA    R0,TOKENPRM\n         ST    R0,CT441PRM+20\n         OI    CT441PRM+20,X'80'   SET VL=1\n         SPACE 1\n*--------------------------------------------------------------------*\n*        STORE TSO CLIST VARIABLES.                                  *\n*--------------------------------------------------------------------*\n         SPACE 1\n         PRINT NOGEN\n        @STV   EUACCNO,ACCTNUM\n        @STV   EUASID,ASID\n        @STV   EUCPUID,CPUID\n        @STV   EUCPUTY,CPUTYPE\n        @STV   EUCPUV,CPUVERSN\n        @STV   EUDOUTD,SYSOUTD\n        @STV   EUDUNIT,UNITNAME\n        @STV   EUJOBID,JESJOBID\n        @STV   EUPIEI,PIESTAT\n        @STV   EUPIESC,PIESWCHR\n        @STV   EUPIESK,PIESWKEY\n        @STV   EUPIESN,PIESESSN\n        @STV   EUPNAME,PGRNAME\n        @STV   EUREGSZ,REGIONSZ\n        @STV   EURGRNM,GROUPN\n        @STV   EURTERM,TERMNAME\n        @STV   EURUSID,USERID\n        @STV   EURUSNM,USERNAME\n        @STV   EUSESSM,SESSTAT\n        @STV   EUSFMID,FMID\n        @STV   EUSMFID,SMFID\n        @STV   EUSNAME,SNAME\n        @STV   EUSNODE,NJENODE\n        @STV   EUSPFI,SPFSTAT\n        @STV   EUSRLNO,RELEASE\n        @STV   EUSTYPE,TYPE\n        @STV   EUSUBSY,SUBSYSTM\n        @STV   EUSWAL,SWALOCTN\n        @STV   EUSYVER,VERSION\n         PRINT GEN\n         SPACE 1\n*--------------------------------------------------------------------*\n*        EXIT.                                                       *\n*--------------------------------------------------------------------*\n         SPACE 1\n        $XRET  CC=(R10),LV=WORKLENG,TYPE=RENT\n         EJECT\n*--------------------------------------------------------------------*\n*                                                                    *\n* 'STOVAR' ROUTINE : STORE A VARIABLE.                               *\n*        FILL IKJCT441 PARM.LIST, THEN                               *\n*        CHECK IKJCT441 SERVICE FOR ERROR, THEN                      *\n*        EVENTUALLY SEND MESSAGE AND SET RETURN CODE (R10).          *\n* CALLED THROUGH @STV MACRO.                                         *\n* REGISTERS USED : R0, R1, R2, R3, R14 AND R15.                      *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nSTOVAR   ST    R14,SVR14\n         LR    R15,R3\n         BCT   R15,*+L'*+6         COMPUTE MOVE LENGTH\n         MVC   VARINAME(*-*),0(R2)\n         EX    R15,*-6             MOVE VARIABLE NAME\n         ST    R3,NAMELENG         SET VARIABLE NAME LENGTH\n         ST    R1,DATAADDR         SET VARIABLE VALUE ADDRESS\n         AR    R1,R0               POINT PAST END OF STRING\n         BCTR  R1,0                BACK UP TO THE PREVIOUS CHARACTER\n         CLI   0(R1),C' '\n         BNE   *+L'*+8\n         BCT   R0,*-10\n         LA    R0,1\n         ST    R0,DATALENG         SET VARIABLE VALUE LENGTH\n         LA    R1,CT441PRM         POINT AT PARM LIST\n         L     R15,TSVTVACC        LOAD THE VARIABLE ACCESS RTN\n         BASR  R14,R15             CALL IT\n         LTR   R15,R15             ANY ERROR?\n         BZ    STORET              NO, OK\n         MVC   ERRMSG(26),=CL26'---> IKJCT441 : RC =    / '\n         CVD   R15,DOUBLE\n         OI    DOUBLE+L'DOUBLE-1,X'0F'\n         UNPK  ERRMSG+20(3),DOUBLE+L'DOUBLE-2(2)\n         MVI   ERRMSG+20,C' '\n         MVC   ERRMSG+26(L'ERRMSG-26),ERRMSG+25\n         L     R1,NAMELENG\n         BCT   R1,*+L'*+6\n         MVC   ERRMSG+26(*-*),VARINAME\n         EX    R1,*-6\n         LA    R10,8\n         ICM   R1,B'1111',ATSO\n         BNZ   STOMSG\n         MVC   EXTR(LEXTR),ESKEL\n        EXTRACT ATSO,'S',FIELDS=(TSO),MF=(E,EXTR)\n         MVC   WTOMSG(2),WSKEL\n         LA    R1,L'ERRMSG+4\n         STCM  R1,B'0011',WTOMSG+2\n         MVC   DCRC(4),WSKEL+6\n         ICM   R1,B'1111',ATSO\nSTOMSG   TM    0(R1),X'80'\n         BZ    STOLOG\n        TPUT   ERRMSG,L'ERRMSG\n         B     STORET\nSTOLOG  WTO    MF=(E,WTOMSG)\nSTORET   L     R14,SVR14\n         BR    R14\n         EJECT\n*--------------------------------------------------------------------*\n*        CONSTANTS.                                                  *\n*--------------------------------------------------------------------*\n         SPACE 1\nESKEL   EXTRACT *-*,'S',MF=L\nWSKEL   WTO    'XX',ROUTCDE=11,DESC=7,MF=L\n         SPACE 1\nEUACCNO  DC    C'EUACCNO'          CURRENT ACCOUNT NUMBER (ACT)\nEUASID   DC    C'EUASID'           CURRENT ASID NUMBER\nEUCPUID  DC    C'EUCPUID'          CPU SERIAL NUMBER\nEUCPUTY  DC    C'EUCPUTY'          CPU MODEL DESIGNATION\nEUCPUV   DC    C'EUCPUV'           CPU VERSION CODE\nEUDOUTD  DC    C'EUDOUTD'          DEFAULT SYSOUT DESTINATION\nEUDUNIT  DC    C'EUDUNIT'          DEFAULT ALLOCATION UNIT NAME\nEUJOBID  DC    C'EUJOBID'          CURRENT SESSION JES JOB ID\nEUPIEI   DC    C'EUPIEI'           PIE ACTIVE VARIABLE NAME\nEUPIESC  DC    C'EUPIESC'          PIE SESSION SWITCH CHARACTER\nEUPIESK  DC    C'EUPIESK'          PIE SESSION SWITCH KEY\nEUPIESN  DC    C'EUPIESN'          PIE SESSION NUMBER VARIABLE NAME\nEUPNAME  DC    C'EUPNAME'          CURRENT PROGRAMMER NAME (ACT)\nEUREGSZ  DC    C'EUREGSZ'          TSO REGION SIZE\nEURGRNM  DC    C'EURGRNM'          GROUP NAME (ACEE)\nEURTERM  DC    C'EURTERM'          TERMINAL ID (ACEE)\nEURUSID  DC    C'EURUSID'          USER ID (ACEE)\nEURUSNM  DC    C'EURUSNM'          USER NAME (ACEE)\nEUSESSM  DC    C'EUSESSM'          SESSION MNGR ACTIVE VARIABLE NAME\nEUSFMID  DC    C'EUSFMID'          SYSTEM FMID VARIABLE NAME\nEUSMFID  DC    C'EUSMFID'          SMF ID VARIABLE NAME\nEUSNAME  DC    C'EUSNAME'          IEASYSXX SYSTEM NAME\nEUSNODE  DC    C'EUSNODE'          JES2 NJE NODE NAME\nEUSPFI   DC    C'EUSPFI'           SPF ACTIVE VARIABLE NAME\nEUSRLNO  DC    C'EUSRLNO'          SYSTEM RELEASE NUMBER VARIABLE NAME\nEUSTYPE  DC    C'EUSTYPE'          SYSTEM TYPE VARIABLE NAME\nEUSUBSY  DC    C'EUSUBSY'          CURRENT LIFE OF JOB SUBSYSTEM\nEUSWAL   DC    C'EUSWAL'           SWA LOCATION\nEUSYVER  DC    C'EUSYVER'          SYSTEM VERSION VARIABLE NAME\n         EJECT\n*--------------------------------------------------------------------*\n*        LITERALS POOL.                                              *\n*--------------------------------------------------------------------*\n         SPACE 1\n        LTORG\n         EJECT\n*--------------------------------------------------------------------*\n*        DSECTS DEFINITIONS.                                         *\n*--------------------------------------------------------------------*\n         SPACE 1\nWORKAREA DSECT\n         SPACE 1\nSAVEAREA DS    18F                 SAVE AREA\nDOUBLE   DS    D\nEXTR    EXTRACT *-*,'S',MF=L\nLEXTR    EQU   *-EXTR\nATSO     DS    A\n         SPACE 1\nCT441PRM DS    6F                  IKJCT441 PARM.LIST\nENTRYCDE DS    F                   ENTRY CODE\nNAMEADDR DS    A                   ADDRESS OF VARIABLE NAME\nNAMELENG DS    F                   LENGTH OF VARIABLE NAME\nDATAADDR DS    A                   ADDRESS OF VARIABLE DATA\nDATALENG DS    F                   LENGTH OF DATA\nTOKENPRM DS    F                   TOKEN TO VARIABLE ACCESS SERVICE\nVARINAME DS    CL32                VARIABLE NAME FIELD\n         SPACE 1\nSVR14    DS    F\nWTOMSG   DS    F                   WTO - TEXT LENGTH, MCSFLAGS\nERRMSG   DS    CL72                ERROR MESSAGE AREA\nDCRC     DS    CL4                 WTO - DESCRIPTOR AND ROUTING CODES\n         SPACE 1\nUSERNAME DS    CL60\nACCTNUM  DS    CL20\nPGRNAME  DS    CL20\nFMID     DS    CL8\nGROUPN   DS    CL8\nJESJOBID DS    CL8\nNJENODE  DS    CL8\nREGIONSZ DS    CL8\nSNAME    DS    CL8\nSYSOUTD  DS    CL8\nTERMNAME DS    CL8\nUNITNAME DS    CL8\nUSERID   DS    CL8\nVERSION  DS    CL8\nCPUID    DS    CL5\nPIESWKEY DS    CL5\nSWALOCTN DS    CL5\nASID     DS    CL4\nCPUTYPE  DS    CL4\nRELEASE  DS    CL4\nSMFID    DS    CL4\nSUBSYSTM DS    CL4\nPIESTAT  DS    CL3\nSESSTAT  DS    CL3\nSPFSTAT  DS    CL3\nTYPE     DS    CL3\nCPUVERSN DS    CL2\nPIESESSN DS    CL1\nPIESWCHR DS    CL1\n         SPACE 1\nWORKLENG EQU   (((*-WORKAREA)+7)/8)*8\n         SPACE 1\n         PRINT NOGEN\n         SPACE 1\n        CVT    DSECT=YES,PREFIX=YES\n        IEESMCA\n        IKJTSVT\n        IKJTCB\n        IKJPSCB\n        IKJRB\n        IHAPSA\n        IHAPCCA\n        IHAPCCAT\n        IHAASCB\n        IHAASXB\n        IEZJSCB\n        IEFJSSIB\n        IKJEFLWA\n        IEFZB502\nZB502L   EQU   *-ZB502\nJCT      DSECT\n        IEFAJCTB\n        IHAACEE\n        IEFJESCT ,                 JES VECTOR TABLE\n        IEFJSCVT ,                 SUB-SYSTEM COMM. VECTOR TABLE\n        IEFJSSVT ,                 SUB-SYSTEM VECTOR TABLE\n* HERE FOLLOWS THOSE DSECT'S NEEDED FOR JES2 DATA ASSEMBLY.\n*        NOTE : WHEN THE ORIGINAL DSECT CONTAINS A TITLE CARD, THEN\n*               JUST THE NEEDED FIELDS ONLY ARE DEFINED BELOW.\n* FROM : $SVT - HASP SUB-SYSTEM VECTOR TABLE DSECT\nSVTTO    EQU   X'01F8',3           OWN NODE INFORMATION            @130\nSVTTONOD EQU   X'01F8',2            OWN NODE ID        (BINARY)    @130\nSVTTOQUL EQU   X'01FA',1            OWN NODE SYSTEM ID (EBCDIC)    @130\nSVTRDT   EQU   X'0208',4           ADDRESS OF REMOTE DESTINATION TABLE\nSVTRDTE  EQU   X'020C',4           ADDRESS OF LAST RDT ELEMENT\n        $RDT  ,                    HASP REMOTE DESTINATION TABLE\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EUSID$": {"ttr": 14856, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93%/\\x00\\x93%/\\x17%\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-09T00:00:00", "modifydate": "1993-09-09T17:25:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//EUSID    JOB (........),'INSTALL  - EUSID -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS4,OPT=',RENT',MBR=EUSID\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   EUSID\n  NAME    EUSID(R)\n/*\n//HLP     EXEC PAJHELP,MBR=EUSIDH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EUSID@": {"ttr": 14858, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x16\\x07\\x000\\x000\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T16:07:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/10/90\n                                                      EUSID     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       EUSID CLIST TSO command       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :    This CLIST command will establish a series of TSO\n  ----------    CLIST variables describing the current environment.\n                The CLIST variables names and contents are listed below\n                    EUACCNO = account number field\n                    EUASID  = ASid number\n                    EUCPUID = 5 digits CPU serial number\n                    EUCPUTY = 4 digits CPU model designation\n                    EUCPUV  = 2 char. CPUid version code\n                    EUDOUTD = default SYSOUT destination\n                    EUDUNIT = default allocation UNIT name\n                    EUJOBID = session JES job id\n                    EUPIEI  = PIE indicator (YES or NO)\n                    EUPIESC = PIE switch character\n                    EUPIESK = PIE switch key value (ENTER, PF1-PF24)\n                    EUPIESN = PIE session number (0-9,A,B)\n                    EUPNAME = programmer name field (JOB card)\n                    EUREGSZ = TSO user's region size in K\n                    EURGRNM = GROUP name\n                    EURTERM = TERMINAL id\n                    EURUSID = USER id\n                    EURUSNM = USER name\n                    EUSESSM = session manager (YES or NO)\n                    EUSFMID = system FMID (i.e., JBB2220)\n                    EUSMFID = SMF system id\n                    EUSNAME = IEASYSXX system name\n                    EUSNODE = JES2 NJE node name\n                    EUSPFI  = SPF indicator (YES or NO)\n                    EUSRLNO = system release number (i.e., 038)\n                    EUSTYPE = system type (XA or 370)\n                    EUSUBSY = name of life of JOB subsystem\n                    EUSWAL  = location of SWA (i.e., ABOVE or BELOW)\n                    EUSYVER = system version (i.e., SP2.2.0)\n  Syntax :      EUSID\n  --------      Alias : none.\n                Return : (in variable &LASTCC)\n                         0 = ok, done.\n                         8 = error, message outputed.\n  Operands :    none.\n  ----------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EUSIDH": {"ttr": 14860, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x16\\x07\\x00)\\x00)\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T16:07:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=EUSID\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  This CLIST command will establish a series of TSO\n               CLIST variables describing the current environment.\n               The CLIST variables names and contents are listed below\n                   EUACCNO = account number field\n                   EUASID  = ASid number\n                   EUCPUID = 5 digits CPU serial number\n                   EUCPUTY = 4 digits CPU model designation\n                   EUCPUV  = 2 char. CPUid version code\n                   EUDOUTD = default SYSOUT destination\n                   EUDUNIT = default allocation UNIT name\n                   EUJOBID = session JES job id\n                   EUPIEI  = PIE indicator (YES or NO)\n                   EUPIESC = PIE switch character\n                   EUPIESK = PIE switch key value (ENTER, PF1-PF24)\n                   EUPIESN = PIE session number (0-9,A,B)\n                   EUPNAME = programmer name field (JOB card)\n                   EUREGSZ = TSO user's region size in K\n                   EURGRNM = GROUP name\n                   EURTERM = TERMINAL id\n                   EURUSID = USER id\n                   EURUSNM = USER name\n                   EUSESSM = session manager (YES or NO)\n                   EUSFMID = system FMID (i.e., JBB2220)\n                   EUSMFID = SMF system id\n                   EUSNAME = IEASYSXX system name\n                   EUSNODE = JES2 NJE node name\n                   EUSPFI  = SPF indicator (YES or NO)\n                   EUSRLNO = system release number (i.e., 038)\n                   EUSTYPE = system type (XA or 370)\n                   EUSUBSY = name of life of JOB subsystem\n                   EUSWAL  = location of SWA (i.e., ABOVE or BELOW)\n                   EUSYVER = system version (i.e., SP2.2.0)\n)X SYNTAX :    EUSID\n               Alias : none.\n               Return : (in variable LASTCC)\n                        0 = ok, done.\n                        8 = error, message outputed.\n)O OPERANDS :  none.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EUSMF": {"ttr": 14862, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x02O\\x00\\x90\\x02O\\x12D\\x00\\xed\\x00\\xed\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-24T00:00:00", "modifydate": "1990-01-24T12:44:00", "lines": 237, "newlines": 237, "modlines": 0, "user": "SYSPAJA"}, "text": "EUSM     TITLE 'EUSMF - SET CURRENT SMF TSO CLIST VARIABLES.'\nEUSMF    START 0\n         SPACE 1\n*--------------------------------------------------------------------*\n* NAME :       EUSMF                                                 *\n* PURPOSE :    THIS MODULE WILL ESTABLISH TSO CLIST VARIABLES        *\n*              DESCRIBING THE CURRENT SMF ENVIRONMENT                *\n* INPUT :      NONE                                                  *\n* OUTPUT :     TSO CLIST VARIABLES                                   *\n*                  EUSMFRS - SMF RECORDING STATUS,                   *\n*                            VALUE MAY BE 'YES' OR 'NO'              *\n*                  EUSMFDS - CURRENT SMF DATA-SET NAME SUFFIX,       *\n*                            VALUE MAY BE 'X', 'Y', 'Z' OR ' '       *\n* RETURN :     (IN REGISTER 15)                                      *\n*              0 = OK, DONE                                          *\n*              8 = ERROR, MESSAGE OUTPUTED                           *\n* MODULE :     RE-ENTRANT AND REFRESHABLE                            *\n* MODE :       RESIDENCY : ANY                                       *\n*              ADDRESSING : 31                                       *\n* NOTE :       RDS IS DESCRIBED IN FICHE FOR IEECB916                *\n*--------------------------------------------------------------------*\n         SPACE 1\n        PRINT  OFF\n         MACRO\n&NAME   @STV   &VN,&VV\n.* STORE VARIABLE MACRO :\n.*            VN = VARIABLE NAME FIELD\n.*            VV = VARIABLE VALUE FIELD\n         LA    R2,&VN\n         LA    R3,L'&VN\n         LA    R1,&VV\n         LA    R0,L'&VV\n         BAS   R14,STOVAR\n         MEND\n        PRINT  ON\n         SPACE 1\nEUSMF   AMODE  31\nEUSMF   RMODE  ANY\n         SPACE 1\n        $DEFREG\n         EJECT\n*--------------------------------------------------------------------*\n*        GENERAL REGISTERS USE :                                     *\n*              R7  = SMCA POINTER                                    *\n*              R8  = TSVT POINTER                                    *\n*              R9  = CVT POINTER                                     *\n*              R10 = RETURN CODE                                     *\n*              R11 = WORK AREA POINTER                               *\n*              R12 = BASE REGISTER                                   *\n*--------------------------------------------------------------------*\n         SPACE 1\n*--------------------------------------------------------------------*\n*        ENTRY.                                                      *\n*--------------------------------------------------------------------*\n         SPACE 1\n        $XENT  BASE=R12,LV=WORKLENG,TYPE=RENT\n         LR    R11,R13\n         USING WORKAREA,R11\n         XR    R10,R10\n         XC    ATSO,ATSO\n         EJECT\n*--------------------------------------------------------------------*\n*        RETRIEVE VARIABLES VALUES.                                  *\n*              R2  = SCAN RDS POINTER                                *\n*              R3  = SCAN RDS POINTER                                *\n*--------------------------------------------------------------------*\n         SPACE 1\n         MVC   EUSMFRS,=C'NO '     ASSUME SMF NOT RECORDING\n         MVI   EUSMFDS,C' '        ASSUME NO SMF DATA-SET NAME SUFFIX\n         L     R9,CVTPTR           FIND CVT\n         USING CVTMAP,R9\n         L     R8,CVTTVT           FIND THE TSVT\n         USING TSVT,R8\n         SPACE 1\n         L     R7,CVTSMCA          FIND SMCA\n         USING SMCABASE,R7\n         TM    SMCAMISC,SMCAUSER   SMF RECORDING REQUESTED?\n         BZ    STVAR               NO\n         LM    R2,R3,SMCAFRDS      GET RDS CHAIN FIRST-LAST\nLOOP     TM    12(R2),X'04'        DS ACIVE?\n         BZ    GETDS               YES\n         L     R2,4(R2)            NO, NEXT RDS ON CHAIN\n         CLR   R2,R3               END OF CHAIN?\n         BNE   LOOP                NOT YET\n         B     STVAR\nGETDS    MVC   EUSMFDS(1),24(R2)   SMF DSN ID\n         MVC   EUSMFRS,=C'YES'     SMF IS RECORDING\n         EJECT\n*--------------------------------------------------------------------*\n*        CONSTRUCT PARM.LIST FOR IKJCT441.                           *\n*--------------------------------------------------------------------*\n         SPACE 1\nSTVAR    LA    R1,TSVEUPDT\n         ST    R1,ENTRYCDE\n         LA    R1,ENTRYCDE\n         ST    R1,CT441PRM+0\n         LA    R1,VARINAME\n         ST    R1,NAMEADDR\n         LA    R1,NAMEADDR\n         ST    R1,CT441PRM+4\n         LA    R1,NAMELENG\n         ST    R1,CT441PRM+8\n         LA    R1,DATAADDR\n         ST    R1,CT441PRM+12\n         LA    R1,DATALENG\n         ST    R1,CT441PRM+16\n         LA    R1,TOKENPRM\n         ST    R1,CT441PRM+20\n         OI    CT441PRM+20,X'80'   SET VL=1\n         SPACE 1\n*--------------------------------------------------------------------*\n*        STORE TSO CLIST VARIABLES.                                  *\n*--------------------------------------------------------------------*\n         SPACE 1\n         PRINT NOGEN\n        @STV   VEURS,EUSMFRS\n        @STV   VEUDS,EUSMFDS\n         PRINT GEN\n         SPACE 1\n*--------------------------------------------------------------------*\n*        EXIT.                                                       *\n*--------------------------------------------------------------------*\n         SPACE 1\n        $XRET  CC=(R10),LV=WORKLENG,TYPE=RENT\n         EJECT\n*--------------------------------------------------------------------*\n*                                                                    *\n* 'STOVAR' ROUTINE : STORE A VARIABLE.                               *\n*        FILL IKJCT441 PARM.LIST, THEN                               *\n*        CHECK IKJCT441 SERVICE FOR ERROR, THEN                      *\n*        EVENTUALLY SEND MESSAGE AND SET RETURN CODE (R10).          *\n* CALLED THROUGH @STV MACRO.                                         *\n* REGISTERS USED : R0, R1, R2, R3, R14 AND R15.                      *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nSTOVAR   ST    R14,SVR14\n         LR    R15,R3\n         BCT   R15,*+L'*+6         COMPUTE MOVE LENGTH\n         MVC   VARINAME(*-*),0(R2)\n         EX    R15,*-6             MOVE VARIABLE NAME\n         ST    R3,NAMELENG         SET VARIABLE NAME LENGTH\n         ST    R1,DATAADDR         SET VARIABLE VALUE ADDRESS\n         AR    R1,R0               POINT PAST END OF STRING\n         BCTR  R1,0                BACK UP TO THE PREVIOUS CHARACTER\n         CLI   0(R1),C' '\n         BNE   *+L'*+8\n         BCT   R0,*-10\n         LA    R0,1\n         ST    R0,DATALENG         SET VARIABLE VALUE LENGTH\n         LA    R1,CT441PRM         POINT AT PARM LIST\n         L     R15,TSVTVACC        LOAD THE VARIABLE ACCESS RTN\n         BASR  R14,R15             CALL IT\n         LTR   R15,R15             ANY ERROR?\n         BZ    STORET              NO, OK\n         MVC   ERRMSG(26),=CL26'---> IKJCT441 : RC =    / '\n         CVD   R15,DOUBLE\n         OI    DOUBLE+L'DOUBLE-1,X'0F'\n         UNPK  ERRMSG+20(3),DOUBLE+L'DOUBLE-2(2)\n         MVI   ERRMSG+20,C' '\n         MVC   ERRMSG+26(L'ERRMSG-26),ERRMSG+25\n         L     R1,NAMELENG\n         BCT   R1,*+L'*+6\n         MVC   ERRMSG+26(*-*),VARINAME\n         EX    R1,*-6\n         LA    R10,8\n         ICM   R1,B'1111',ATSO\n         BNZ   STOMSG\n         MVC   EXTR(LEXTR),ESKEL\n        EXTRACT ATSO,'S',FIELDS=(TSO),MF=(E,EXTR)\n         MVC   WTOMSG(2),WSKEL\n         LA    R1,L'ERRMSG+4\n         STCM  R1,B'0011',WTOMSG+2\n         MVC   DCRC(4),WSKEL+6\n         ICM   R1,B'1111',ATSO\nSTOMSG   TM    0(R1),X'80'\n         BZ    STOLOG\n        TPUT   ERRMSG,L'ERRMSG\n         B     STORET\nSTOLOG  WTO    MF=(E,WTOMSG)\nSTORET   L     R14,SVR14\n         BR    R14\n         EJECT\n*--------------------------------------------------------------------*\n*        CONSTANTS.                                                  *\n*--------------------------------------------------------------------*\n         SPACE 1\nESKEL   EXTRACT *-*,'S',MF=L\nWSKEL   WTO    'XX',ROUTCDE=11,DESC=7,MF=L\n         SPACE 1\nVEURS    DC    C'EUSMFRS'          SMF RECORDING STATUS\nVEUDS    DC    C'EUSMFDS'          SMF RECORDING STATUS\n         SPACE 1\n*--------------------------------------------------------------------*\n*        LITERALS POOL.                                              *\n*--------------------------------------------------------------------*\n         SPACE 1\n        LTORG\n         EJECT\n*--------------------------------------------------------------------*\n*        DSECTS DEFINITIONS.                                         *\n*--------------------------------------------------------------------*\n         SPACE 1\nWORKAREA DSECT\n         SPACE 1\nSAVEAREA DS    18F                 SAVE AREA\nDOUBLE   DS    D\nEXTR    EXTRACT *-*,'S',MF=L\nLEXTR    EQU   *-EXTR\nATSO     DS    A\n         SPACE 1\nCT441PRM DS    6F                  IKJCT441 PARM.LIST\nENTRYCDE DS    F                   ENTRY CODE\nNAMEADDR DS    A                   ADDRESS OF VARIABLE NAME\nNAMELENG DS    F                   LENGTH OF VARIABLE NAME\nDATAADDR DS    A                   ADDRESS OF VARIABLE DATA\nDATALENG DS    F                   LENGTH OF VARIABLE DATA\nTOKENPRM DS    F                   TOKEN TO VARIABLE ACCESS SERVICE\nVARINAME DS    CL32                VARIABLE NAME FIELD\n         SPACE 1\nSVR14    DS    F\nWTOMSG   DS    F                   WTO - TEXT LENGTH, MCSFLAGS\nERRMSG   DS    CL72                ERROR MESSAGE AREA\nDCRC     DS    CL4                 WTO - DESCRIPTOR AND ROUTING CODES\n         SPACE 1\nEUSMFRS  DS    CL3\nEUSMFDS  DS    CL1\n         SPACE 1\nWORKLENG EQU   (((*-WORKAREA)+7)/8)*8\n         SPACE 1\n         PRINT NOGEN\n         SPACE 1\n        CVT    DSECT=YES\n        IEESMCA\n        IKJTSVT\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EUSMF$": {"ttr": 15109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x16\\x06\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T16:06:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//EUSMF    JOB (........),'INSTALL  - EUSMF -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=EUSMF\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   EUSMF\n  NAME    EUSMF(R)\n/*\n//HLP     EXEC PAJHELP,MBR=EUSMFH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EUSMF@": {"ttr": 15111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x16\\x07\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T16:07:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/10/90\n                                                      EUSMF     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       EUSMF CLIST TSO command       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :    This CLIST command will establish TSO CLIST variables\n  ----------    describing the current SMF environment.\n                The CLIST variables names and contents are listed below\n                    EUSMFRS = SMF recording status (YES or NO)\n                    EUSMFDS - current SMF data-set name suffix (X, Y,\n                              Z or null).\n  Syntax :      EUSMF\n  --------      Alias : none.\n                Return : (in variable &LASTCC)\n                         0 = ok, done.\n                         8 = error, message outputed.\n  Operands :    none.\n  ----------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EUSMFH": {"ttr": 15113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x16\\x07\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T16:07:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=EUSMF\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  This CLIST command will establish TSO CLIST variables\n               describing the current SMF environment.\n               The CLIST variables names and contents are listed below\n                   EUSMFRS = SMF recording status (YES or NO)\n                   EUSMFDS - current SMF data-set name suffix (X, Y,\n                             Z or null).\n)X SYNTAX :    EUSMF\n               Alias : none.\n               Return : (in variable LASTCC)\n                        0 = ok, done.\n                        8 = error, message outputed.\n)O OPERANDS :  none.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EUSUB": {"ttr": 15115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15\\x13\\x01\\xc9\\x01\\xc9\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:13:00", "lines": 457, "newlines": 457, "modlines": 0, "user": "SYSPAJA"}, "text": "SBMT     TITLE 'J.R.C. - EURATOM SUBMIT PROGRAM.'\nEUSUB    START 0\n         SPACE 1\n* PURPOSE :    ALLOWS THE SUBMIT OF A BATCH JOB FOR CONVENTIONAL\n* ---------    PROCESSING. THE JOB SUBMITTED MAY RESIDE IN A SEQUENTIAL\n*              DATA-SET OR IN A MEMBER OF A PARTITIONED DATA-SET (FIXED\n*              80-BYTES RECORDS, BLOCKED OR UNBLOCKED), BUT THE DD-NAME\n*              TO ACCESS IT MUST BE 'SYSPO'.\n*\n*       NOTE - JCL JOB STATEMENT CODING : MUST BE THE FIRST AND MAY\n*              CONTAIN ALL THE NEEDED INFORMATION. THE SUBMIT FUNCTION\n*              WILL SUPPLY THE PASSWORD ONLY WHEN THE USER=... KEYWORD\n*              IS CODED AND THE PASSWORD=... KEYWORD IS NOT CODED (THIS\n*              ASSUMES THE JOB STATEMENT IS MORE THAN ONE CARD CODED).\n* - SUPPRESS - IF YOU DON'T WANT SUPPLY THE PASSWORD AS DESCRIBED\n*              ABOVE, YOU MAY BYPASS THIS PROCESS BY SETTING THE BIT\n*              'SWJS' PERMANENTLY ON IN THE SWITCH BYTE 'SWJBSC'.\n*\n* INVOKED BY : CONSOLE START COMMAND :\n* ------------      S R1,FROM='...PO-DSNAME...',\n*                          M=...MEMBER-NAME...\n*\n*              WHERE R1 IS THE FOLLOWING PROCEDURE :\n*                   //R1       PROC FROM='->.OPER.PDS.CNTL',M=\n*                   //R1       EXEC PGM=EUSUB\n*                   //SYSPO    DSN=&FROM(&M),DISP=SHR\n*                   //SYSSU    DD SYSOUT=(,INTRDR)\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nLV1      EQU   1         OWNER LEVEL, IN TSO ONLY.\nLV0      EQU   0         REJECT LEVEL.\n         SPACE 1\n        $MDL@IX\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12\n         EJECT\n*        VERIFY AUTHORITY.\n*        -----------------\n         SPACE 1\n        $EACM  REQAUT\n         CLI   AUTH,LV0            AUTHORIZED?\n         BNE   ENVRT               YES.\n         LA    R9,16               C.C. = 16.\n         B     LEAVE\n         SPACE 1\n*        FIND ENVIRONMENT.\n*        -----------------\n         SPACE 1\nENVRT   EXTRACT ANSWER,'S',FIELDS=(COMM,TSO,PSB)\n         L     R2,ACOMM            COMMUNICATION AREA ADDRESS.\n         L     R3,4(R2)            CIB ADDRESS.\n         LA    R3,0(R3)            CLEAR HIGH BYTE.\n         LTR   R3,R3               CURRENT CIB SET UP?\n         BZ    NOTST               NO.\n         USING CIBDSECT,R3\n         CLI   CIBVERB,CIBSTART    START COMMAND (SYSTEM TASK)?\n         BNE   NOTST               NO.\n         DROP  R3\n         OI    SWITCH,SWST         SET STARTED TASK.\n         B     INIT\nNOTST    L     R2,ATSO             TSO INDICATOR ADDRESS.\n         LTR   R2,R2\n         BZ    INIT\n         TM    0(R2),X'80'         ARE WE IN TSO?\n         BZ    INIT                NO.\n         OI    SWITCH,SWTS         SET TSO TASK.\n         EJECT\n*        SUBMIT PROCESSING.\n*        ------------------\n         SPACE 1\nINIT     ZAP   CCJB,=PL1'+0'       INITIALIZE PROCESSING.\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O1S1\n        OPEN   (INRDR)             OPEN JES2 ACB.\n         LTR   R15,R15\n         BZ    READ\n         MVC   MSEIR+8(15),=CL15'IN.RDR ACB OPEN'\n         BAS   R8,SETRC\n         XR    R9,R9               C.C. = 0.\n         B     LEAVE\n.O1S1    ANOP\nREAD    $READ  TEXT,SBDDN\n         LTR   R15,R15\n         BM    ENDS\n         BZ    READOK\n         MVC   MSEIR+8(15),=CL15'SUBMIT DATA-SET'\n         B     JSUC\nREADOK   TM    SWJBSC,SWJS         BYPASS REQUESTED?\n         BO    JPR                 YES.\n         TM    SWJBSC,SWJB         JOB STATEMENT PROCESSED?\n         BO    JPR                 YES.\n         AP    CCJB,=PL1'+1'\n         LM    R3,R5,SCTXT\n         CLC   0(2,R3),=CL2'//'\n         BNE   JERR\n         LA    R3,2(R3)\n         TM    SWJBSC,SWJN         JOB STATEMENT CONTINUATION?\n         BZ    JNC                 NO.\n         CLI   0(R3),C' '\n         BE    JCN\nJERR     SL    R3,SCTXT            RELATIVE POSITION IN CARD.\n         LA    R3,1(R3)\n         CVD   R3,WORK\n         BAS   R14,EDIT\n         MVC   MSEJB+31(2),WORK+2\n         MVC   WORK+6(2),CCJB      JOB RELATIVE CARD.\n         BAS   R14,EDIT\n         MVC   MSEJB+26(2),WORK+2\n         LA    R2,MSEJB\n         BAS   R8,SMSG\n         B     JPURGE\nJNC      CLI   0(R3),C' '          SCAN JOB STATEMENT FOR :\n         BE    JERR                     USER=...\n         BXLE  R3,R4,*+L'*+4            PASSWORD=...\n         B     JERR\n         CLI   0(R3),C' '\n         BNE   *-12\n         BXLE  R3,R4,*+L'*+4\n         B     JERR\n         CLI   0(R3),C' '\n         BE    *-12\n         CLC   0(4,R3),=CL4'JOB '\n         BNE   JERR\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O2S1\n         LA    R0,TEXT+3\n         LR    R1,R3\n         SLR   R1,R0\n         LA    R0,7\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         MVC   MSJNN+16(*-*),TEXT+2\n         EX    R1,*-6              SET JOB-NAME IN MESSAGE.\n.O2S1    LA    R3,3(R3)\nJCN      BXLE  R3,R4,*+L'*+4\n         B     JERR\n         CLI   0(R3),C' '\n         BE    JCN\n         TM    SWJBSC,SWJN\n         BZ    JCNT\n         LR    R0,R3\n         S     R0,=A(TEXT+15)\n         BP    JERR\nJCNT     OI    SWJBSC,SWJN\nJCNQS    CLI   0(R3),C''''\n         BE    JCNQF\n         TM    SWJBSC,SWJA\n         BO    JCNSS\n         CLC   0(2,R3),=CL2', '\n         BE    JPR\n         CLI   0(R3),C' '\n         BE    JTPS\n         CLC   0(9,R3),=CL9'PASSWORD='  PASSWORD CODED?\n         BE    JPSW                YES.\n         TM    SWJBSC,SWJU\n         BO    JCNSS\n         CLC   0(5,R3),=CL5'USER='\n         BE    JUSR\nJCNSS    BXLE  R3,R4,*+L'*+4\n         B     JERR\n         CLR   R3,R5\n         BL    JCNQS\n         CLI   0(R3),C','\n         BNE   JCNQS\n         B     JPR\nJCNQF    TM    SWJBSC,SWJA\n         BO    JQFF\n         OI    SWJBSC,SWJA\n         B     JCNSS\nJQFF     NI    SWJBSC,255-SWJA\n         B     JCNSS\nJUSR     LA    R3,4(R3)            EXTRACT USER-ID.\n         BXLE  R3,R4,*+L'*+4\n         B     JERR\n         CLI   0(R3),C' '\n         BE    JPR\n         CLI   0(R3),C','\n         BE    JPR\n         LR    R6,R3\nJUSL     BXLE  R3,R4,*+L'*+4\n         B     JUSF\n         CLI   0(R3),C' '\n         BE    JUSF\n         CLI   0(R3),C','\n         BNE   JUSL\nJUSF     LR    R1,R3\n         SR    R1,R6\n         STC   R1,JUSERL\n         MVC   JUSER,=CL8' '\n         BCTR  R1,0\n         EX    R1,SBMMVUS\n         CLI   AUTH,LV1            OWNER LEVEL?\n         BNE   JSCN                NO.\n         TM    SWITCH,SWTS         YES, TSO?\n         BZ    JPSW                NO, IGNORE.\n         L     R1,APSCB\n         USING PSCB,R1\n         CLC   PSCBUSER(L'PSCBUSER),JUSER    OWNER?\n         BE    JSCN                YES.\n         B     JPSW                NO, IGNORE.\n         DROP  R1\nJSCN     CLR   R3,R5\n         BH    JTUS\n         CLI   0(R3),C' '\n         BE    JTUS\n         OI    SWJBSC,SWJU\n         B     JCNQS\nSBMMVUS  MVC   JUSER(*-*),0(R6)    << EXECUTED >>\nJTPS     TM    SWJBSC,SWJU\n         BZ    JPSW\nJTUS     CP    CCJB,=PL1'+1'       JOB STATEMENT IN ONLY ONE CARD?\n         BE    JPSW                YES.\n         XC    GPWAR(GPWAL-L'GPWA),GPWAR     GET PASSWORD FROM RACF.\n        SETAUTH\n        ICHEINTY LOCATE,TYPE='USR',ENTRY=JUSERL,                       1\n               ACTIONS=(GPSW),WKAREA=GPWA\n         LR    R6,R15\n        RESAUTH\n         LTR   R6,R6\n         BZ    PSWCTL\n         CVD   R6,WORK\n         BAS   R14,EDIT\n         MVC   MSEPL+32(2),WORK+2\n         LA    R2,MSEPL\n         BAS   R8,SMSG\n         B     JPSW\nPSWCTL   CLC   GPPL,=XL2'0008'\n         BNE   JPSW\n         MVI   INSTXTP,C' '        DECODE RACF PASSWORD.\n         MVC   INSTXTP+1(10),INSTXTP\n        CALL   PSWREST,(GPPW,INSTXTP,LGPPW),VL\n         LTR   R15,R15\n         BNZ   JPSW\n         CLI   INSTXTP,C' '\n         BE    JPSW\n         LA    R1,INSTXTP+8        ADD JOB PASSWORD KEYWORD.\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         MVC   1(2,R1),=CL2'),'\n         LA    R2,INSTXT\n         BAS   R8,SUBMT\n         LTR   R15,R15\n         BNZ   JSUE\nJPSW     OI    SWJBSC,SWJB\nJPR      LA    R2,TEXT\n         BAS   R8,SUBMT\n         LTR   R15,R15\n         BZ    READ\nJSUE     MVC   MSEIR+8(15),=CL15'INTERNAL READER'\n         OI    SWITCH,SWEI         SET ERROR.\n         AIF   ('&SYSPARM' NE 'NOVSAM').O4S1\nJSUC     CVD   R15,WORK            SET R.C. IN MESSAGE.\n         BAS   R14,EDIT\n         MVC   MSEIR+35(2),WORK+2\n         LA    R2,MSEIR\n         BAS   R8,SMSG\n         AGO   .O4S2\n.O4S1    ANOP\nJSUC     BAS   R8,SETRC\n.O4S2    ANOP\nJPURGE   MVI   TEXT,C' '           PURGE JOB.\n         MVC   TEXT+1(L'TEXT-1),TEXT\n         LA    R2,TEXT\n         MVC   TEXT(7),=CL7'/*PURGE'    JES2 PURGE.\n         TM    SWITCH,SWSI         STARTED?\n         BO    SCLS                YES.\n         OI    SWITCH,SWEI         NO, BYPASS.\n         B     SCLS\n         EJECT\n*        END OF PROCESSING.\n*        ------------------\n         SPACE 1\nENDS     MVI   TEXT,C' '           CLOSE JOB.\n         MVC   TEXT+1(L'TEXT-1),TEXT\n         LA    R2,TEXT\n         MVC   TEXT(2),INSTXT      NULL JCL.\nSCLS     BAS   R8,SUBMT\n        $RCLOSE SBDDN\n         MVC   TEXT(7),=CL7'/*EOF  '    JES2 END-OF-FILE.\n         BAS   R8,SUBMT\n         AIF   ('&SYSPARM' NE 'NOVSAM').O5S1\n        $UCLOSE TXTDDN\n         XR    R9,R9               C.C. = 0.\n         AGO   .O5S2\n.O5S1    TM    SWITCH,SWEI         IN ERROR?\n         BO    CLINR               YES.\n        ENDREQ RPL=REQPL           GET JOB NUMBER.\n         LTR   R15,R15             ENDREQ OK?\n         BZ    SETJN               YES.\n         MVC   MSEIR+8(15),=CL15'IN.RDR - ENQREQ'\n         BAS   R8,SETRC\n         B     CLINR\nSETJN    MVC   MSJNN+26(8),REQPL+(RPLRBAR-IFGRPL) MOVE JOB NUMBER.\n         LA    R2,MSJNN+29\n         CLI   0(R2),C'0'\n         BNE   *+L'*+12\n         MVI   0(R2),C' '\n         LA    R2,1(R2)\n         B     *-16\n         LA    R2,MSJNN\n         BAS   R8,SMSG\nCLINR   CLOSE  (INRDR)             CLOSE JES2 ACB.\n         LR    R9,R15              SET R.C. OF CLOSE AS C.C.\n.O5S2    ANOP\nLEAVE   $XRET  CC=(R9)\n         SPACE 1\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O5S3\n*        SET R.C IN MESSAGE ROUTINE.\n*        ---------------------------\n*              R15 = R.C.\n         SPACE 1\nSETRC    CVD   R15,WORK            SET R.C. IN MESSAGE.\n         BAS   R14,EDIT\n         MVC   MSEIR+35(2),WORK+2\n         LA    R2,MSEIR\n.O5S3    SPACE 1\n*        SEND MESSAGE ROUTINE.\n*        ---------------------\n*              R0, R1, R14, R15 = WORK REGISTERS.\n*              R2 = MESSAGE ADDRESS (WTO).\n*              R8 = LINK REGISTER.\n         SPACE 1\nSMSG     TM    SWITCH,SWST         STARTED TASK?\n         BO    SMSG1               YES.\n         LH    R0,0(R2)\n         TM    SWITCH,SWTS         TSO?\n         BO    SMSG2               YES.\n         LR    R1,R2\n         AR    R1,R0\n         MVC   0(4,R1),MSSKEL+6\nSMSG1   WTO    MF=(E,(R2))\n         BR    R8\nSMSG2    SH    R0,=H'4'\n         LA    R1,4(R2)\n        TPUT   (1),(0)\n         BR    R8\n         SPACE 2\n*        EDIT 'WORK' ROUTINE.\n*        --------------------\n*              R14 = LINK REGISTER.\n         SPACE 1\nEDIT     MVC   WORK(4),=XL4'40202120'\n         ED    WORK(4),WORK+6\n         BR    R14\n         EJECT\n*        SUBMIT CARD ROUTINE.\n*        --------------------\n*              R0, R1, R14, R15 = WORK REGISTERS.\n*              R2 = CARD IMAGE ADDRESS.\n*              R8 = LINK REGISTER.\n*        AT EXIT, R15 = CC, UNLESS PREVIOUS ERROR DETECTED.\n         SPACE 1\nSUBMT    TM    SWITCH,SWEI         IN ERROR?\n         BOR   R8                  YES, BYPASS.\n         OI    SWITCH,SWSI         SAY STARTED.\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O7S1\n        MODCB  RPL=REQPL,AREA=(R2)\n         LTR   R15,R15\n         BNZR  R8\n        PUT    RPL=REQPL\n         AGO   .O7S2\n.O7S1   $PUNCH (R2),,TXTDDN\n.O7S2    BR    R8\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n*        -------------------------\n         SPACE 1\nWORK     DC    D'0'\nANSWER   DS    0F                  EXTRACT RESPONSES.\nACOMM    DC    A(*-*)\nATSO     DC    A(*-*)\nAPSCB    DC    A(*-*)\nSCTXT    DC    A(TEXT,1,TEXT+70)\nLGPPW    DC    A(L'GPPW)\n         SPACE 1\n        PRINT  NOGEN\nMSEIR   WTO    '---                 ERROR (R15=  ) - SUBMIT FAILED -', 1\n               ROUTCDE=1,DESC=3,MF=L\nMSEJB   WTO    '--- JOB CARD ERROR (C=  ,P=  ) - SUBMIT FAILED -',     1\n               ROUTCDE=1,DESC=3,MF=L\nMSEPL   WTO    '--- RACF-ICHEINTY ERROR (RC=  ) - SUBMIT FAILED -',    1\n               ROUTCDE=1,DESC=3,MF=L\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O10S1\nMSJNN   WTO    '--- EU-S00I          (        ) SUBMITTED.',           1\n               ROUTCDE=1,DESC=3,MF=L\n.O10S1   ANOP\nMSSKEL  WTO    '  ',ROUTCDE=11,DESC=7,MF=L\n        PRINT  GEN\n         EJECT\nGPSW    ICHEACTN FIELD=PASSWORD,MF=L\nGPWA     DC    A(GPWAL)            WORK AREA LENGTH.\nGPWAR    DC    XL20'0'             RESERVED.\n         DC    F'0'                ACTION RESPONSE LENGTH.\nGPPL     DC    XL2'0'              PASSWORD LENGTH (8).\nGPPW     DC    XL8'0'              PASSWORD.\n         DC    XL2'0'\nGPWAL    EQU   *-GPWA\n         SPACE 1\nSWJBSC   DC    AL1(SWJS)\nSWJB     EQU   X'01'               JOB STATEMENT PROCESSED.\nSWJA     EQU   X'02'               START-STOP TEXT QUOTES.\nSWJN     EQU   X'04'               JOB STATEMENT CONTINUATION.\nSWJU     EQU   X'08'               USER= KEYWORD PROCESSED.\nSWJS     EQU   X'80'               BYPASS JOB CARD PROCESSING.\n         SPACE 1\n         DC    AL1(L'TEXT)\nTEXT     DC    CL80' '\n         DC    AL1(L'INSTXT+L'INSTXTT+L'INSTXTP)\nINSTXT   DC    CL15'// '\nINSTXTT  DC    CL10'PASSWORD=('\nINSTXTP  DC    CL35'               * SUBMIT SUPPLIED * '\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O10S2\n         DC    CL20' '\n         AGO   .O10S3\n.O10S2   ANOP\nTXTDDN   DC    CL8'SYSSU'\n.O10S3   ANOP\nSBDDN    DC    CL8'SYSPO'\nSWITCH   DC    XL1'0'\nSWST     EQU   X'80'               STARTED TASK.\nSWTS     EQU   X'40'               TSO TASK.\nSWSI     EQU   X'02'               INTERNAL READER STARTED.\nSWEI     EQU   X'01'               INTERNAL READER ERROR.\nJUSERL   DC    AL1(*-*)\nJUSER    DC    CL8' '\nCCJB     DC    PL2'+0'\nAUTH     DC    XL1'0'\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(AUTH)\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O15S1\n         EJECT\nINRDR   ACB    MACRF=(ADR,SEQ,OUT),DDNAME=SYSSU\n         EJECT\nREQPL   RPL    ACB=INRDR,RECLEN=80,AREALEN=80,OPTCD=(ADR,SEQ,SYN,NUP)\n.O15S1   EJECT\n        LTORG\n         SPACE 2\n*        DSECT DEFINITIONS.\n*        ------------------\n         SPACE 1\n        PRINT  NOGEN\n         SPACE 1\n        IKJPSCB\nCIBDSECT DSECT\nCIB     IEZCIB\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O20S1\n        IFGRPL\n.O20S1   SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EUSUB$": {"ttr": 15364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10&\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:26:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "//EUSUB    JOB (........),'INSTALL - EUSUB -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL   TXREAD                                   *\n//* NOTES : 1. SPECIFY SYSPARM(NOVSAM) AT ASSEMBLY STEP 'ASS' IF      *\n//*            YOU WANT A NON-VSAM VERSION.                           *\n//*                 I.E. : OPT=',SYSPARM(NOVSAM)'                     *\n//*         2. FOR NON-VSAM VERSION :                                 *\n//*            A. TXPUNCH IS A PRE-REQUISITE.                         *\n//*            B. CHANGE THE INCLUDE CARD AT STEP 'LNK' AS FOLLOWS :  *\n//*                    INLUDE SYSADD(READ,PUNCH)                      *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=EUSUB\n//ASP     EXEC PAJIAS2,OPT=',SYSPARM(CALL)',MBR=PSWREST\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  INCLUDE SYSADD(READ)\n  ENTRY   EUSUB\n  SETCODE AC(1)\n  NAME    EUSUB(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EUSUB@": {"ttr": 15366, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15\\x13\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:13:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SYSPAJA"}, "text": "1   30/03/87\n                                                      EUSUB     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       EURATOM SUBMIT PROGRAM.       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Allows the SUBMIT of a batch job for conventional\n  ---------    processing. The job submitted may reside in a sequential\n               data-set or in a member of a partitioned data-set (fixed\n               80-bytes records, blocked or unblocked), but the DD-name\n               to access it must be SYSPO.\n\n               Note - JCL JOB statement coding : must be the first and\n                      may contain all the needed information. The\n                      submit function will supply the password only\n                      when the USER=... keyword is coded and the\n                      PASSWORD=... keyword is not coded (this assumes\n                      the JOB statement is more than one card coded).\n\n  Invoked by : Console START command :\n  ------------      S R1,FROM='...PO-dsname...',\n                           M=...member-name...\n\n               Where R1 is the following procedure :\n                    //R1       PROC FROM='->.OPER.PDS.CNTL',M=\n                    //R1       EXEC PGM=EUSUB\n                    //SYSPO    DSN=&FROM(&M),DISP=SHR\n                    //SYSSU    DD SYSOUT=(,INTRDR)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FC": {"ttr": 15368, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93%o\\x00\\x93%o\\x15\\x17\\x00(\\x00(\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-13T00:00:00", "modifydate": "1993-09-13T15:17:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM,BPARM) NOPROCESS\n/*  MACRO NAME : FC                                                 */\n/*    FUNCTION : FIND PENDING EDIT LINE COMMANDS                    */\n/*      SYNTAX : FC OR FC F(IRST) OR FC N(EXT) OR FC P(REV)         */\n/*               FC H(ELP)                                          */\n/*       DEBUG : FC L(IST)                                          */\n/*               FC F(IRST)/N(EXT)/P(REV) L(IST)                    */\n/*      ORIGIN : CBT TAPE 93 FEB, FILE 95                           */\n  IF ((&STR(&BPARM.) = &STR(LIST)) OR +\n     (&STR(&BPARM.) = &STR(L))) THEN CONTROL LIST CONLIST SYMLIST\n  ELSE IF ((&STR(&APARM.) = &STR(LIST)) OR +\n    (&STR(&APARM.) = &STR(L))) THEN DO\n    CONTROL LIST CONLIST SYMLIST\n    SET &APARM = &Z\n    END\n  IF &STR(&APARM.) = &STR(HELP) OR +\n    &STR(&APARM.) = &STR(H) THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTFC)\n    SET &FCCC = &LASTCC\n    ISPEXEC CONTROL DISPLAY RESTORE\n    EXIT CODE(&FCCC)\n    END\n  SET &PTR = &Z\n  IF &STR(&APARM.) = &Z THEN SET &PTR = &STR(FIRST)\n  IF ((&STR(&APARM.) = &STR(FIRST)) OR +\n     (&STR(&APARM.) = &STR(F))) THEN SET &PTR = &STR(FIRST)\n  IF ((&STR(&APARM.) = &STR(NEXT)) OR +\n     (&STR(&APARM.) = &STR(N))) THEN SET &PTR = &STR(NEXT)\n  IF ((&STR(&APARM.) = &STR(PREV)) OR +\n     (&STR(&APARM.) = &STR(P))) THEN SET &PTR = &STR(PREV)\n  IF &PTR = &Z THEN DO\n    SET ZEDSMSG = &STR(INVALID OPERAND)\n    SET ZEDLMSG = ENTER \"FC HELP\" COMMAND FOR OPERAND SYNTAX\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  ISREDIT LOCATE COM &PTR\n  SET &FCCC = &LASTCC\n  EXIT CODE(&FCCC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FC@": {"ttr": 15370, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\x109\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T10:39:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": "1   13/09/93\n                                                      FC        1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       FC ISPF/PDF EDIT command      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to find pending Edit line\n  ----------   commands.\n\n  Command syntax : FC or FC F(IRST) or FC N(EXT) or FC P(REV)\n  ---------------- FC HELP or H\n\n  Use :        Type FC on the COMMAND line.\n  -----        Example :\n               EDIT -- CURRENT.DATASET(JCL1)      MOVE/COPY IS PENDING\n               COMMAND ===> FC\n               ********************* TOP OF DATA *********************\n               000001 //JOBEX1   JOB (11112222),'E X A M P L E',\n               000002 //             MSGLEVEL=(1,1),MSGCLASS=X,\n               000003 //             REGION=1M,TIME=(,20),\n               000004 //             NOTIFY=EXAMPLE\n               Result :\n               EDIT -- CURRENT.DATASET(JCL1)      MOVE/COPY IS PENDING\n               COMMAND ===>\n          ---> C 0043 //STEP4   EXEC PGM=IEBCOPY\n               000044 //DISPDD    DD SYSOUT=A\n               000045 //COPYDD    DD SYSOUT=A\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FILEINF$": {"ttr": 15372, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14\"\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:22:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SYSPAJA"}, "text": "//FILEINFO JOB (........),'INSTALL - FILEINFO -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                FILSPACE  FINDMEM                                  *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=FILEINFO\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  INCLUDE SYSADD(FILSPACE,FINDMEM)\n  ENTRY   FILEINFO\n  ALIAS   FINFO\n  NAME    FILEINFO(R)\n/*\n//HLP     EXEC PAJHELP,MBR=FILEINFH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILEINF@": {"ttr": 15374, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14\"\\x00\\xb1\\x00\\xb1\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:22:00", "lines": 177, "newlines": 177, "modlines": 0, "user": "SYSPAJA"}, "text": "1   01/08/90\n                                                      FILEINFO  1/4.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        FILEINFO TSO command         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Command name :      FILEINFO\n  Author :            Jeff Sprehn\n  Agency :            WDPSC\n  Origin :            Extracted from tape CBT 89 FEB, file 270\n  Function :          The FILEINFO command is intended for use in\n                      command procedures. This command returns to\n                      the CLIST (thru CLIST variables) information\n                      about that file such as LRECL, BLKSIZE, RECFM,\n                      DSORG, volume serial number, device type,\n                      number of used tracks and extents.\n  Syntax :\n  --------------------------------------------------------------------\n  Command    Operands\n  --------------------------------------------------------------------\n  FILEINFO   DSN('dataset name') VOL('vol ser') MEM('member name')\n  FINFO\n  --------------------------------------------------------------------\n  Command alias : FINFO\n\n  Operands :\n\n  1. Required :\n\n     DSN('dataset name') = 'dataset name' is the data-set name of the\n                           data-set that you wish to receive file\n                           information about. If the data-set name is\n                           not quoted, then the PROFILE PREFIX will be\n                           appended. You may provide a member name of\n                           a PDS if you wish. This command will return\n                           in CLIST variable MEMFND 'YES' if the member\n                           is found in the directory and 'NO' if it is\n                           not found in the directory.\n                 Aliases : DSNAME, DATASET, DA or D.\n\n  2. Optional :\n\n     VOL('vol ser') = 'vol ser' is to be used if your file is not\n                           cataloged.\n                 Aliases : VOLUME, VOLSER or V.\n\n     MEM('member name') = 'member name' is the member name of the PDS\n                           named by 'dataset name'. This command will\n                           return in CLIST variable MEMFND 'YES' if\n                           the member is found in the directory and\n                           'NO' if it is not found in the directory.\n                 Aliases : MEMBER or M.\n1   01/08/90\n                                                      FILEINFO  2/4.\n\n  After execution of this command, the following CLIST variables are\n  set. Their names and contents are as follows :\n\n   CLIST\n  Variable                         Contents\n  --------       ----------------------------------------------------\n  &FULLDSN       Your data-set name as follows :\n                 a. PROFILE PREFIX added if data-set name in DSN\n                    keyword was not quoted.\n                 b. Quotes now stripped off.\n                 c. Member name included, if and only if, member\n                    name was provided in the DSN keyword, otherwise\n                    &FULLDSN will not include this member name.\n  &LRECL         Logical record length of data-set.\n  &BLKSIZE       Blocksize of data-set.\n  &RECFM         Will contain one of the following three values :\n                 'F' for fixed length records,\n                 'V' for variable length records,\n                 'U' for undefined records.\n  &CNTLCHAR      Will contain one of the following three values :\n                 'A' data-set contains ANSI control characters,\n                 'M' data-set contains machine control characters,\n                 'N' data-set contains no control characters.\n  &DEVTYPE       Will contain one of the following two values :\n                 'T' data-set is on tape,\n                 'D' data-set is on disk.\n  &VOLSER        Volume serial number where data-set resides.\n  &DSORG         Will contain one of the following values :\n                 'IS' for indexed sequential organization,\n                 'PS' for physical sequential organization,\n                 'DA' for direct organization,\n                 'CX' for BTAM or QTAM line group,\n                 'PO' for partitioned,\n                 'U ' for unmovable (the data contains location\n                                     dependent information),\n                 'VS' for VSAM data-set.\n  &ISITCAT       Will contain one of the following three values :\n                 'YES' if data-set is cataloged,\n                 'NO ' if data-set is not cataloged,\n                 '   ' if n/a (higher level error was detected prior\n                               to LOCATE).\n  &MEMFND        Will contain one of the following three values :\n                 'YES' if member of PDS was found,\n                 'NO ' if member of PDS was not found,\n                 '   ' if n/a (user didn't request this command to\n                               locate a member)\n1   01/08/90\n                                                      FILEINFO  3/4.\n\n  &MEMCNTL       Will contain one of the following two values :\n                 'YES' if member name was included with the data-set\n                       name in the DSN keyword\n                 'NO ' if member name was not included with the\n                       data-set name in the DSN keyword\n  &EXTENTNO      Number of used extents. This field is significant\n                 only for disk sequential and partitioned data-sets.\n  &TRKSUSED      Number of used tracks. This field is significant\n                 only for disk sequential and partitioned data-sets.\n\n  This command will also make available two other variables that the\n  invoking CLIST may interrogate. Below is a table of values after\n  execution of this command for these two variables &OUTMSG and\n  &LASTCC (return code).\n\n       &LASTCC   &OUTMSG\n\n          0      Successful completion\n          4      Data-set not cataloged\n          8      File is on more than 1 volume\n         12      Required volume not mounted\n         16      FORMAT-1 DSCB not found on vol\n         20      OBTAIN - Return Code 12/16/20\n         24      Member name not found\n         28      Unsuccessful dynamic allocation\n         32      I/O error reading directory\n         36      FINDMEM - Return code 24\n         40      File is on a tape volume\n         44      Data-set not partitioned\n         48      Invalid syntax of member name\n         52      FILSPACE - Return Code 16\n         96      Invalid syntax of operand(s)\n\n  Remark : if this command is invoked outside a CLIST, the contents of\n  -------- all variables are displayed to the terminal, and no CLIST\n           variables are set.\n1   01/08/90\n                                                      FILEINFO  4/4.\n\n  Example of use :\n\n                 CONTROL NOMSG NOFLUSH\n       START:    WRITE ... LISTING A DATA-SET ...\n                 WRITENR ENTER DATASET NAME ===>\n                 READ\n                 SET &DSN = &STR(&SYSDVAL)\n                 FILEINFO DSN(&STR(&DSN))\n                 SET &MYCC = &LASTCC\n                 IF &MYCC EQ 96 THEN DO\n                   WRITE ERROR *** INVALID SYNTAX OF DSNAME\n                   GOTO START\n                   END\n                 IF &MYCC NE 0 THEN DO\n                   WRITE ERROR *** &OUTMSG\n                   GOTO START\n                   END\n                 IF &DSORG = PS THEN GOTO LISTIT\n                 IF &DSORG NE PO THEN DO\n                   WRITE *** &FULLDSN IS NOT A SEQUENTIAL DATASET\n                   WRITE   * OR A PARTITIONED DATASET\n                   GOTO START\n                   END\n                 IF &MEMCNTL NE YES THEN DO\n                   WRITE *** &FULLDSN IS A PARTITIONED DATASET\n                   WRITE   * HENCE; YOU MUST PROVIDE A MEMBER NAME\n                   GOTO START\n                   END\n       LISTIT:   CONTROL MSG\n                 PRINTO '&FULLDSN'\n                 EXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FILEINFH": {"ttr": 15378, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14\"\\x00q\\x00q\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:22:00", "lines": 113, "newlines": 113, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=FILEINFO\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  the FILEINFO command is intended for use in command\n               procedures. This command returns to the CLIST (thru\n               CLIST variables) information about that file such as\n               LRECL, BLKSIZE, RECFM, DSORG, volume serial number,\n               device type, number of used tracks and extents.\n               After execution of this command, the following CLIST\n               variables are set. Their names and contents are as\n               follows :\n  CLIST Var.   Contents\n  ----------   ------------------------------------------------------\n  &FULLDSN     Your data-set name as follows :\n               a. PROFILE PREFIX added if data-set name in DSN\n                  keyword was not quoted.\n               b. Quotes now stripped off.\n               c. Member name included, if and only if, member name\n                  was provided in the DSN keyword, otherwise &FULLDSN\n                  will not include this member name.\n  &LRECL       Logical record length of data-set.\n  &BLKSIZE     Blocksize of data-set.\n  &RECFM       Will contain one of the following three values :\n                 'F' for fixed length records,\n                 'V' for variable length records,\n                 'U' for undefined records.\n  &CNTLCHAR    Will contain one of the following three values :\n                 'A' data-set contains ANSI control characters,\n                 'M' data-set contains machine control characters,\n                 'N' data-set contains no control characters.\n  &DEVTYPE     Will contain one of the following two values :\n                 'T' data-set is on tape,\n                 'D' data-set is on disk.\n  &VOLSER      Volume serial number where data-set resides.\n  &DSORG       Will contain one of the following values :\n                 'IS' for indexed sequential organization,\n                 'PS' for physical sequential organization,\n                 'DA' for direct organization,\n                 'CX' for BTAM or QTAM line group,\n                 'PO' for partitioned,\n                 'U ' for unmovable (the data contains location\n                                     dependent information),\n                 'VS' for VSAM data-set.\n  &ISITCAT     Will contain one of the following three values :\n                 'YES' if data-set is cataloged,\n                 'NO ' if data-set is not cataloged,\n                 '   ' if n/a (higher level error was detected prior\n                               to LOCATE).\n  &MEMFND      Will contain one of the following three values :\n                 'YES' if member of PDS was found,\n                 'NO ' if member of PDS was not found,\n                 '   ' if n/a (user didn't request this command to\n                               locate a member)\n  &MEMCNTL     Will contain one of the following two values :\n                 'YES' if member name was included with the data-set\n                       name in the DSN keyword\n                 'NO ' if member name was not included with the\n                       data-set name in the DSN keyword\n  &EXTENTNO    Number of used extents. This field is significant\n               only for disk sequential and partitioned data-sets.\n  &TRKSUSED    Number of used tracks. This field is significant\n               only for disk sequential and partitioned data-sets.\n  This command will also make available two other variables that the\n  invoking CLIST may interrogate. Below is a table of values after\n  execution of this command for these two variables &OUTMSG and\n  &LASTCC (return code) :\n       &LASTCC   &OUTMSG\n          0      Successful completion\n          4      Data-set not cataloged\n          8      File is on more than 1 volume\n         12      Required volume not mounted\n         16      FORMAT-1 DSCB not found on vol\n         20      OBTAIN - Return Code 12/16/20\n         24      Member name not found\n         28      Unsuccessful dynamic allocation\n         32      I/O error reading directory\n         36      FINDMEM - Return code 24\n         40      File is on a tape volume\n         44      Data-set not partitioned\n         48      Invalid syntax of member name\n         52      FILSPACE - Return Code 16\n         96      Invalid syntax of operand(s)\n  Remark : if this command is invoked outside a CLIST, the contents of\n  -------- all variables are displayed to the terminal, and no CLIST\n           variables are set.\n)X SYNTAX :    FILEINFO DSN('dataset name') -\n               FINFO    VOL('vol ser') -\n                        MEM('member name')\n               Example : FILEINFO DSN(TEST.DATA)\n               Command alias : FINFO\n)O OPERANDS :  Required - DSN('dataset name')\n               Optional - VOL('vol ser')\n                          MEM('member name')\n               Default  - None\n))DSN('dataset name') : 'dataset name' is the data-set name of the\n               data-set that you wish to receive file information\n               about. If the data-set name is not quoted, then the\n               PROFILE PREFIX will be appended. You may provide a\n               member name of a PDS if you wish. This command will\n               return in CLIST variable MEMFND 'YES' if the member is\n               found in the directory and 'NO' if it is not found in\n               the directory.\n               Aliases : DSNAME, DATASET, DA or D.\n))VOL('vol ser') : 'vol ser' is to be used if your file is not\n               cataloged.\n               Aliases : VOLUME, VOLSER or V.\n))MEM('member name') : 'member name' is the member name of the PDS\n               named by 'dataset name'. This command will return in\n               CLIST variable MEMFND 'YES' if the member is found\n               in the directory and 'NO' if it is not found in the\n               directory.\n               Aliases : MEMBER or M.\n./     ALIAS   NAME=FINFO\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FILEINFO": {"ttr": 15617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x13?\\x00\\x94\\x13?\\x113\\x03\\xb8\\x03\\xb8\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-13T00:00:00", "modifydate": "1994-05-13T11:33:00", "lines": 952, "newlines": 952, "modlines": 0, "user": "SYSPAJA"}, "text": "FLNF     TITLE 'FILEINFO -- FILE INFORMATION CLIST TSO-COMMAND.'\nFILEINFO START 0\n         SPACE 1\n*--------------------------------------------------------------------*\n*                          F I L E I N F O                           *\n*--------------------------------------------------------------------*\n*\n*  ORIGIN :    EXTRACTED FROM TAPE CBT 89 FEB, FILE 270.\n*  --------    ADAPTED BY MOINIL P.A.\n*\n*  COMMAND     OPERANDS\n*  --------    -------------------------------------------------------\n*  FILEINFO    DSN('DATASET NAME') VOL('VOL SER') MEM('MEMBER NAME')\n*  FINFO\n*\n*  OPERANDS :\n*  ----------\n*  1. REQUIRED :\n*\n*        DSN('DATASET NAME') = 'DATASET NAME' IS THE DATA-SET NAME OF\n*                  THE DATA-SET THAT YOU WISH TO RECEIVE THE FILE\n*                  INFORMATION ABOUT. IF THE DATA-SET IS NOT QUOTED,\n*                  THEN THE PROFILE PREFIX WILL BE APPENDED. YOU MAY\n*                  PROVIDE A MEMBER NAME OF A PDS IF YOU WISH. THIS\n*                  COMMAND WILL RETURN IN CLIST VARIABLE MEMFND 'YES'\n*                  IF THE MEMBER IS FOUND IN THE DIRECTORY AND 'NO'\n*                  IF IT IS NOT FOUND IN THE DIRECTORY.\n*        ALIASES : DSNAME, DATASET, DA OR D.\n*  2. OPTIONAL :\n*\n*        VOL('VOL SER') = 'VOL SER' IS TO BE USED IF YOUR FILE IS NOT\n*                  CATALOGUED.\n*        ALIASES : VOLUME, VOLSER OR V.\n*\n*        MEM('MEMBER NAME') = 'MEMBER NAME' IS THE MEMBER NAME OF THE\n*                  PDS NAMED BY 'DATASET NAME'. THIS COMMAND WILL\n*                  RETURN IN CLIST VARIABLE MEMFND 'YES' IF THE\n*                  MEMBER IS FOUND IN THE DIRECTORY AND 'NO' IF IT IS\n*                  NOT FOUND IN THE DIRECTORY.\n*        ALIASES : MEMBER OR M.\n         EJECT\n*  AFTER EXECUTION OF THIS COMMAND, THE FOLLOWING CLIST VARIABLES ARE\n*  SET. THERE NAMES AND CONTENTS ARE AS FOLLOWS :\n*   CLIST\n*  VARIABLE   CONTENTS\n*  --------   --------------------------------------------------------\n*  &FULLDSN   YOUR DATA-SET NAME AS FOLLOWS :\n*             A. PROFILE PREFIX ADDED IF DATA-SET NAME IS DSN KEYWORD\n*                WAS NOT QUOTED\n*             B. QUOTES NOW STRIPPED OFF\n*             C. MEMBER NAME INCLUDED IF AND ONLY IF MEMBER NAME WAS\n*                PROVIDED IN THE DSN KEYWORD TO THE COMMAND. THUS,\n*                IF A MEMBER NAME WAS PROVIDED IN THE MEM KEYWORD,\n*                THEN &FULLDSN WILL NOT INCLUDE THIS MEMBER NAME\n*  &LRECL     LOGICAL RECORD LENGTH OF DATA-SET\n*  &BLKSIZE   BLOCK SIZE OF DATA-SET\n*  &RECFM     WILL CONTAIN ONE OF THE FOLLOWING 3 VALUES :\n*             'F' FOR FIXED LENGTH RECORDS\n*             'V' FOR VARIABLE LENGTH RECORDS\n*             'U' FOR UNDEFINED RECORDS\n*  &CNTLCHAR  WILL CONTAIN ONE OF THE FOLLOWING 3 VALUES :\n*             'A' FOR ANSI CONTROL CHARACTERS\n*             'M' FOR MACHINE CONTROL CHARACTERS\n*             'N' FOR NO CONTROL CHARACTERS\n*  &DEVTYPE   WILL CONTAIN ONE OF THE FOLLOWING 2 VALUES :\n*             'T' DATA-SET IS ON TAPE\n*             'D' DATA-SET IS ON DISK\n*  &VOLSER    VOLUME SERIAL NUMBER WHERE DATA-SET RESIDES\n*  &DSORG     WILL CONTAIN ONE OF THE FOLLOWING 9 VALUES :\n*             'IS' FOR INDEXED SEQUENTIAL ORGANIZATION\n*             'PS' FOR PHYSICAL SEQUENTIAL ORGANIZATION\n*             'DA' FOR DIRECT ORGANIZATION\n*             'CX' FOR BTAM OR QTAM LINE GROUP\n*             'CQ' FOR QTAM DIRECT ACCESS MESSAGE QUEUE\n*             'MQ' FOR QTAM PROBLEM PGM MESSAGE QUEUE\n*             'PO' FOR PARTITIONED\n*             'U ' FOR UNMOVABLE - THE DATA CONTAINS LOCATION\n*                                  DEPENDENT INFORMATION\n*             'VS' FOR VSAM DATA-SET\n*  &ISITCAT   WILL CONTAIN ONE OF THE FOLLOWING 3 VALUES :\n*             'YES' IF DATA-SET IS CATALOGUED\n*             'NO ' IF DATA-SET IS NOT CATALOGUED\n*             '   ' IF N/A (HIGHER LEVEL ERROR WAS DETECTED PRIOR TO\n*                           LOCATE)\n*  &MEMFND    WILL CONTAIN ONE OF THE FOLLOWING 3 VALUES :\n*             'YES' IF MEMBER OF PDS WAS FOUND\n*             'NO ' IF MEMBER OF PDS WAS NOT FOUND\n*             '   ' IF N/A (USER DIDN'T REQUEST THIS COMMAND TO LOCATE\n*                           A MEMBER)\n*  &MEMCNTL   WILL CONTAIN ONE OF THE FOLLOWING 2 VALUES :\n*             'YES' IF MEMBER NAME WAS INCLUDED WITH THE DATA-SET NAME\n*                            IN THE DSN KEYWORD\n*             'NO ' IF MEMBER NAME WAS NOT INCLUDED WITH THE DATA-SET\n*                            IN THE DSN KEYWORD\n*  &TRKSUSED  NUMBER OF USED TRACKS\n*  &EXTENTNO  NUMBER OF USED EXTENTS\n         EJECT\n*  THIS COMMAND WILL ALSO MAKE AVAILABLE TWO OTHER VARIABLES THAT THE\n*  INVOKING CLIST MAY INTERROGATE. BELOW IS A TABLE OF VALUES AFTER\n*  EXECUTION OF THIS COMMAND FOR THESE TWO VARIABLE &OUTMSG AND\n*  &LASTCC (RETURN CODE) :\n*\n*        -----------------------------------------------------------\n*        | &LASTCC |                 &OUTMSG                       |\n*        |---------|-----------------------------------------------|\n*        |     0   | SUCCESSFUL COMPLETION                         |\n*        |---------|-----------------------------------------------|\n*        |     4   | DATA-SET NOT CATALOGUED                       |\n*        |---------|-----------------------------------------------|\n*        |     8   | FILE IS ON MORE THAN 1 VOLUME                 |\n*        |---------|-----------------------------------------------|\n*        |    12   | REQUIRED VOLUME NOT MOUNTED                   |\n*        |---------|-----------------------------------------------|\n*        |    16   | FORMAT-1 DSCB NOT FOUND ON VOL                |\n*        |---------|-----------------------------------------------|\n*        |    20   | OBTAIN - RETURN CODE 12/16/20                 |\n*        |---------|-----------------------------------------------|\n*        |    24   | MEMBER NAME NOT FOUND                         |\n*        |---------|-----------------------------------------------|\n*        |    28   | UNSUCCESSFUL DYNAMIC ALLOCATION               |\n*        |---------|-----------------------------------------------|\n*        |    32   | I/O ERROR READING DIRECTORY                   |\n*        |---------|-----------------------------------------------|\n*        |    36   | FINDMEM - RETURN CODE 24                      |\n*        |---------|-----------------------------------------------|\n*        |    40   | FILE IS ON A TAPE VOLUME                      |\n*        |---------|-----------------------------------------------|\n*        |    44   | DATA-SET NOT PARTITIONED                      |\n*        |---------|-----------------------------------------------|\n*        |    48   | INVALID SYNTAX OF MEMBER NAME                 |\n*        |---------|-----------------------------------------------|\n*        |    52   | FILSPACE - RETURN CODE 16                     |\n*        |---------|-----------------------------------------------|\n*        |    96   | INVALID SYNTAX OF OPERAND(S)                  |\n*        -----------------------------------------------------------\n*\n*  ERROR RETURN CODE (&LASTCC) WITH NO OTHER CLIST VARIABLES SET :\n*            100 = PARSE ERROR OR INTERRUPT\n*            104 = RUN ERROR\n         EJECT\nFILEINFO AMODE 24\nFILEINFO RMODE 24\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=(R11,R12),LV=WORKLEN,TYPE=RENT\n         LR    R10,R13\n         USING WORKAREA,R10\n         LA    R2,18*4(R10)\n         L     R3,=A(WORKLEN-(18*4))\n         LR    R4,R2\n         XR    R5,R5\n         MVCL  R2,R4\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n        $TEW$PP PARM=PARMLST,REG=R6,ERR=PARSERR,ATT=PARSERR\n         SPACE 1\n*------- LOAD THE PARSED FIELDS INTO THE DATA FIELDS\n*        QUALDSN, INVOL, AND QUALMEM FOR FURTHER PROCESS\n*        (ALSO LOADS DATA FIELD MEMCNTL)\n         SPACE 1\n         TM    DSTRING+6,X'80'     IS DSNAME PRESENT ?\n         BO    *+L'*+14            BRANCH IF YES\nOPNDERR  LA    R4,96               RC=96 ------------------------------\n         MVC   OUTMSG,MESS96\n         B     INITL\n         MVI   QUALDSN,C' '        A BLANK\n         MVC   QUALDSN+1(43),QUALDSN SPREAD IT AROUND\n         MVI   FULLDSN,C' '        A BLANK\n         MVC   FULLDSN+1(53),FULLDSN SPREAD IT AROUND\n         LA    R1,QUALDSN          R1 ==> ADDRESS OF QUALDSN\n         L     R3,DSTRING          R3 ==> ADDRESS OF THE DSN\n         LH    R5,DSTRING+4        R5 ==> LENGTH OF THE DSN\n         BCT   R5,*+L'*+6          SUBTRACT 1 FOR EXECUTE\n         MVC   0(*-*,R1),0(R3)     MOVE THE DSN TO QUALDSN\n         EX    R5,*-6\n         LA    R1,FULLDSN\n         EX    R5,*-14\n         TM    DSTRING+14,X'80'    IS MEMBER NAME PRESENT ?\n         BZ    MOVE89S             BRANCH IF NOT\n         MVC   MEMCNTL,=CL3'YES'   MOVE 'YES' TO MEMCNTL\n         MVC   CPMEM1(L'CPMEM1),=CL10' ' MOVE 8 SPACES TO CPMEM1\n         LA    R1,CPMEM1           R1 ==> ADDRESS OF CPMEM1\n         L     R3,DSTRING+8        R3 ==> ADDRESS OF THE MEMBER\n         LH    R5,DSTRING+12       R5 ==> LENGTH OF THE MEMBER\n         BCT   R5,*+L'*+6          SUBTRACT 1 FOR EXECUTE\n         MVC   0(*-*,R1),0(R3)     MOVE THE MEMBER TO CPMEM1\n         EX    R5,*-6\n         B     DOMKYWD\nMOVE89S  MVC   CPMEM1,=CL8'99999999' MOVE '99999999' TO CPMEM1\n         MVC   MEMCNTL,=CL3'NO '   MOVE 'NO ' TO MEMCNTL\nDOMKYWD  MVC   CPMEM2(L'CPMEM2),=CL10' ' MOVE 8 SPACES TO CPMEM2\n         LA    R1,CPMEM2           R1 ==> ADDRESS OF CPMEM2\n         L     R3,MSTRING          R3 ==> ADDRESS OF THE MEMBER\n         LH    R5,MSTRING+4        R5 ==> LENGTH OF THE MEMBER\n         BCT   R5,*+L'*+6          SUBTRACT 1 FOR EXEXCUTE\n         MVC   0(*-*,R1),0(R3)     MOVE THE MEMBER TO CPMEM2\n         EX    R5,*-6\n         CLC   CPMEM1,=CL8'99999999' IS CPMEM1 = ALL NINES ?\n         BE    M1IS999             BRANCH IF YES\n         CLC   CPMEM2,=CL8'99999999' IS CPMEM2 = ALL NINES ?\n         BE    M2IS999             BRANCH IF YES\n         CLC   CPMEM1,CPMEM2       IS CPMEM1 = CPMEM2 ?\n         BNE   OPNDERR             BRANCH IF NOT\n         MVC   QUALMEM,CPMEM1      MOVE CPMEM1 TO QUALMEM\n         B     CHEKMEM\nM1IS999  MVC   QUALMEM,CPMEM2      MOVE CPMEM2 TO QUALMEM\n         B     CHEKMEM\nM2IS999  MVC   QUALMEM,CPMEM1      MOVE CPMEM2 TO QUALMEM\nCHEKMEM  CLC   QUALMEM,=CL8'99999999' IS QUALMEM = '99999999' ?\n         BE    DOVOLSR             BRANCH IF YES\n         SPACE 1\n*------- EDIT THE MEMBER NAME WHICH IS IN QUALMEM.\n         SPACE 1\n         LA    R2,OKCHARS1         R2==> ADDRESS OF OKCHARS1\nEDIT1    CLI   0(R2),C'+'          AT END OF TABLE OKCHARS1 ?\n         BE    NOGOOD              BRANCH IF YES\n         CLC   QUALMEM(1),0(R2)    HIGH ORDER BYTE OF QUALMEM\n*                                    MATCH ON TABLE ELEMENT ?\n         BE    *+L'*+8             BRANCH IF YES\n         LA    R2,1(,R2)           ADD 1 TO REGISTER 2\n         B     EDIT1\n         LA    R3,QUALMEM+1        R3==> ADDRESS OF QUALMEM + 1\n         LA    R5,8                R5==> VALIDATED BYTES OF QUALMEM\nEDIT2    LA    R2,OKCHARS2         R2==> ADDRESS OF OKCHARS2\nEDIT3    CLI   0(R2),C'+'          AT END OF TABLE OKCHARS2 ?\n         BE    NOGOOD              BRANCH IF YES\n         CLC   0(1,R3),0(R2)       QUALMEM AS INDEXED BY REG 3\n*                                    MATCH TO TABLE ELEMENT ?\n         BE    *+L'*+8             BRANCH IF YES\n         LA    R2,1(,R2)           ADD 1 TO REGISTER 2\n         B     EDIT3\n         LA    R3,1(,R3)           ADD 1 TO REGISTER 3\n         BCT   R5,EDIT2            ALL 8 BYTES OF QUALMEM VALIDATED ?\n*                                  BRANCH IF NOT\n         B     DOVOLSR\nNOGOOD   LA    R4,48               RC=48 ------------------------------\n         MVC   OUTMSG,MESS48       SET MESSAGE\n         B     INITL\nDOVOLSR  TM    VSTRING+6,X'80'     IS VOL SER PRESENT ?\n         BZ    MOVE69S             BRANCH IF NOT\n         MVC   INVOL(L'INVOL),=CL10' ' MOVE 6 SPACES TO INVOL\n         LA    R1,INVOL            R1 ==> ADDRESS OF INVOL\n         L     R3,VSTRING          R3 ==> ADDRESS OF THE VOL SER\n         LH    R5,VSTRING+4        R5 ==> LENGTH OF THE VOL SER\n         BCT   R5,*+L'*+6          SUBTRACT 1 FOR EXEXUTE\n         MVC   0(*-*,R1),0(R3)     MOVE THE VOL SER TO INVOL\n         EX    R5,*-6\n         B     MOVE69S+L'MOVE69S\nMOVE69S  MVC   INVOL(L'INVOL),=CL8'99999999' MOVE '999999' TO INVOL\n         DROP  R6\n         SPACE 1\n*------- BUILD CAMLIST1 AND CAMLIST2 FROM THE CAMLIST PATTERNS\n*        FOR LOCATE AND OBTAIN\n         SPACE 1\n         MVC   CAMLIST1,PATCAML1\n         MVC   CAMLIST2,PATCAML2\n         LA    R1,QUALDSN\n         ST    R1,CAMLIST1+4\n         ST    R1,CAMLIST2+4\n         LA    R1,LOCAREA\n         ST    R1,CAMLIST1+12\n         LA    R1,OBTAREA\n         ST    R1,CAMLIST2+12\n         LA    R1,OBTVOL\n         ST    R1,CAMLIST2+8\n         SPACE 1\n*------- PROCESS QUALDSN, INVOL, AND QUALMEM\n*        (I.E. DO LOCATE AND OBTAIN ON QUALDSN)\n*        AS AN OVERVIEW, WHAT DOES THE FOLLOWING :\n*        1. WAS VOLUME SERIAL NUMBER PROVIDED BY INVOKER ?\n*        2. IF YES, GO TO 10\n*        3. SEARCH CATALOG FOR QUALDSN (LOCATE)\n*        4. IF NOT FOUND, LOAD OUTMSG\n*                 SET UP RETURN CODE\n*                 MOVE 'NO ' TO ISITCAT\n*                 EXIT\n*        5. IF FOUND, MOVE 'YES' TO ISITCAT\n*        6. STORE VOL SER\n*        7. IS DATA-SET ON TAPE ?\n*        8. IF YES, MOVE 'T' TO DEVTYPE\n*                 LOAD OUTMSG\n*                 SET UP RETURN CODE\n*                 EXIT\n*        9. MOVE 'D' TO DEVTYPE\n*       10. OBTAIN FORMAT-1 DSCB FOR DATA-SET\n*       11. RETURN CODE OF OBTAIN = 0 ?\n*       12. IF NOT, LOAD OUTMSG\n*                 SET UP RETURN CODE\n*                 EXIT\n*       13. PERFORM ROUTINE TO GENERATE LRECL\n*       14. PERFORM ROUTINE TO GENERATE BLKSIZE\n*       15. PERFORM ROUTINE TO GENERATE DSORG\n*       16. PERFORM ROUTINE TO GENERATE RECFM\n*      16A. PERFORM ROUTINE TO GENERATE CNTLCHAR\n*      16B. PERFORM ROUTINE TO GENERATE TRKSUSED AND EXTENTNO\n*       17. IS DATA-SET A PARTITIONED DATA-SET ?\n*       18. IF YES, GO TO 24\n*       19. WAS MEMBER NAME PROVIDED ?\n*       20. IF YES, LOAD OUTMSG\n*                 SET UP RETURN CODE\n*                 EXIT\n*       21. SET RETURN CODE REG TO 0\n*       22. LOAD OUTMSG WITH 'SUCCESSFUL COMPLETION'\n*       23. EXIT\n*       24. WAS MEMBER NAME PROVIDED ?\n*       25. IF YES, GO TO 29\n*       26. SET RETURN CODE REG TO 0\n*       27. LOAD OUTMSG WITH 'SUCCESSFUL COMPLETION'\n*       28. EXIT\n*       29. CALL ROUTINE 'FINDMEM' TO DETERMINE WHETHER\n*                 MEMBER DOES EXIST IN THE DIRECTORY ?\n*       30. MEMBER FOUND ?\n*       31. IF NOT, LOAD OUTMSG\n*                 SET UP RETURN CODE\n*                 EXIT\n*       32. SET RETURN CODE REG TO 0\n*       33. LOAD OUTMSG WITH 'SUCCESSFUL COMPLETION'\n*       34. EXIT\n         SPACE 1\n         CLC   INVOL(L'INVOL),=CL8'99999999' IS INVOL = '999999' ?\n         BE    LOKAYT              BRANCH IF YES\n         MVC   OBTVOL,INVOL        MOVE INVOL TO OBTVOL\n         B     OBTANE\nLOKAYT  LOCATE CAMLIST1\n         LTR   R15,R15             COMPARE REG 15 TO BE = 0\n         BZ    RC0                 BRANCH IF REG 15=0\n         MVC   ISITCAT,=CL3'NO '   MOVE 'NO ' TO ISITCAT\n         LA    R4,4                RC=4 -------------------------------\n         MVC   OUTMSG,MESS4        SET MESSAGE\n         B     INITL\nRC0      MVC   ISITCAT,=CL3'YES'   MOVE 'YES' TO ISITCAT\n         MVC   FULLDSN(44),QUALDSN MOVE QUALDSN TO FULLDSN\n         MVC   FULLDSN+44(10),=CL10'          '\n         CLC   MEMCNTL,=CL3'YES'   WAS A MEMBER NAME GIVEN ?\n         BNE   RC0CONT             BRANCH IF NOT\n         BAS   R14,GENFULDS        PERFORM ROUTINE TO SUFFIX (MNAME)\n*                                    TO FULLDSN\nRC0CONT  CLC   LOCAREA(2),=XL2'0001' VERIFY THAT THE NUMBER OF\n*                                    VOLUMES COUNT IS 1\n         BE    MATCH               BRANCH IF YES\n         LA    R4,8                RC=8 -------------------------------\n         MVC   OUTMSG,MESS8        SET MESSAGE\n         B     INITL\nMATCH    MVC   VOLSER(6),LOCAREA+6 LOAD VOLSER FROM CAMLST WORKAREA\n         MVC   OBTVOL(6),VOLSER    MOVE VOLSER TO OBTVOL\n         CLI   LOCAREA+4,X'80'     IS DATA-SET ON TAPE ?\n         BE    ONTAPE              BRANCH IF YES\n         MVI   DEVTYPE,C'D'        MOVE 'D' (FOR DISK) TO DEVTYPE\n         B     OBTANE\nONTAPE   MVI   DEVTYPE,C'T'        MOVE 'T' (FOR TAPE) TO DEVTYPE\n         LA    R4,40               RC=40 ------------------------------\n         MVC   OUTMSG,MESS40       SET MESSAGE\n         B     INITL\nOBTANE  OBTAIN CAMLIST2\n         LTR   R15,R15             COMPARE REG 15 TO BE = 0\n         BZ    RCODE0              BRANCH IF REG 15=0\n         CH    R15,=H'4'           COMPARE REG 15 TO BE = 4\n         BE    RCODE4              BRANCH IF REG 15=4\n         CH    R15,=H'8'           COMPARE REG 15 TO BE = 8\n         BE    RCODE8              BRANCH IF REG 15=8\nRCODEH   LA    R4,20               RC=20 ------------------------------\n         MVC   OUTMSG,MESS20       SET MESSAGE\n         B     INITL\nRCODE4   LA    R4,12               RC=12 ------------------------------\n         MVC   OUTMSG,MESS12       SET MESSAGE\n         B     INITL\nRCODE8   LA    R4,16               RC=16 ------------------------------\n         MVC   OUTMSG,MESS16       SET MESSAGE\n         MVC   VOLSER(L'VOLSER),=CL10' ' MOVE SPACES TO VOLSER\n         B     INITL\nRCODE0   MVC   VOLSER,OBTVOL       MOVE OBTVOL TO VOLSER\n         MVI   DEVTYPE,C'D'        MOVE 'D' (FOR DISK) TO DEVTYPE\n         MVC   FULLDSN(44),QUALDSN MOVE QUALDSN TO FULLDSN\n         MVC   FULLDSN+44(10),=CL10'          '\n         CLC   MEMCNTL,=CL3'YES'   WAS A MEMBER NAME GIVEN ?\n         BNE   GENLRECL            BRANCH IF NOT\n         BAS   R14,GENFULDS        PERFORM ROUTINE TO SUFFIX (MNAME)\n*                                    TO FULLDSN\n         SPACE 1\n*------- CREATE THE PARAMETER LRECL THAT IS MADE AVAILABLE\n*        TO THE CALLING CLIST\n         SPACE 1\nGENLRECL MVI   FULLWURD,X'00'      MOVE ALL BINARY ZEROS\n         MVC   FULLWURD+1(3),FULLWURD TO FULLWURD\n         MVC   FULLWURD+2(2),OBTAREA+44 MOVE LRECL WHICH IS 2 BYTES\n*                                    IN LENGTH BINARY TO LOW\n*                                    ORDER 2 BYTES OF FULLWURD\n         L     R2,FULLWURD         LOAD REG 2 WITH FULLWURD\n         CVD   R2,DUBLWURD         CONVERT REG 2 CONTENTS TO\n*                                    PACKED DECIMAL AND\n*                                    PLACE INTO DUBLWURD\n         UNPK  LRECL(5),DUBLWURD+5(3) CONVERT PACKED DECIMAL IN\n*                                    DUBLWURD+5 (FOR A LENGTH\n*                                    OF 3 BYTES) AND PLACE\n*                                    INTO LRECL (FOR A LENGTH\n*                                    OF 5 BYTES)\n         OI    LRECL+4,X'F0'       GET RID OF THE SIGN OF\n*                                    LRECL (I.E. CHANGE HIGH\n*                                    ORDER 4 BITS OF LOW ORDER\n*                                    BYTE OF LRECL TO ALL ONES\n         SPACE 1\n*------- CREATE THE PARAMETER BLKSIZE THAT IS MADE AVAILABLE\n*        TO THE CALLING CLIST\n         SPACE 1\n         MVI   FULLWURD,X'00'      MOVE ALL BINARY ZEROS\n         MVC   FULLWURD+1(3),FULLWURD TO FULLWURD\n         MVC   FULLWURD+2(2),OBTAREA+42 MOVE BLKSIZE WHICH IS\n*                                    2 BYTES BINARY TO LOW\n*                                    ORDER 2 BYTES OF FULLWURD\n         L     R2,FULLWURD         LOAD REG 2 WITH FULLWURD\n         CVD   R2,DUBLWURD         CONVERT REG 2 CONTENTS TO\n*                                    PACKED DECIMAL AND\n*                                    PLACE INTO DUBLWURD\n         UNPK  BLKSIZE(5),DUBLWURD+5(3) CONVERT PACKED DECIMAL IN\n*                                    DUBLWURD+5 (FOR A LENGTH\n*                                    OF 3 BYTES) AND PLACE\n*                                    INTO BLKSIZE (FOR A\n*                                    LENGTH OF 5 BYTES)\n         OI    BLKSIZE+4,X'F0'     GET RID OF THE SIGN OF\n*                                    BLKSIZE (I.E. CHANGE HIGH\n*                                    ORDER 4 BITS OF LOW ORDER\n*                                    BYTE OF BLKSIZE TO ALL\n*                                    ONES)\n         SPACE 1\n*------- CREATE THE PARAMETER DSORG THAT IS MADE AVAILABLE\n*        TO THE CALLING CLIST\n         SPACE 1\n         TM    OBTAREA+38,B'10000000'\n         BO    MOVEIT1\n         TM    OBTAREA+38,B'01000000'\n         BO    MOVEIT2\n         TM    OBTAREA+38,B'00100000'\n         BO    MOVEIT3\n         TM    OBTAREA+38,B'00010000'\n         BO    MOVEIT4\n         TM    OBTAREA+38,B'00001000'\n         BO    MOVEIT5\n         TM    OBTAREA+38,B'00000100'\n         BO    MOVEIT6\n         TM    OBTAREA+38,B'00000010'\n         BO    MOVEIT7\n         B     MOVEIT8\nMOVEIT1  MVC   DSORG(2),ORGTABLE   MOVE 'IS' TO DSORG\n         B     DSRGX\nMOVEIT2  MVC   DSORG(2),ORGTABLE+2 MOVE 'PS' TO DSORG\n         B     DSRGX\nMOVEIT3  MVC   DSORG(2),ORGTABLE+4 MOVE 'DA' TO DSORG\n         B     DSRGX\nMOVEIT4  MVC   DSORG(2),ORGTABLE+6 MOVE 'CX' TO DSORG\n         B     DSRGX\nMOVEIT5  MVC   DSORG(2),ORGTABLE+8 MOVE 'CQ' TO DSORG\n         B     DSRGX\nMOVEIT6  MVC   DSORG(2),ORGTABLE+10 MOVE 'MQ' TO DSORG\n         B     DSRGX\nMOVEIT7  MVC   DSORG(2),ORGTABLE+12 MOVE 'PO' TO DSORG\n         B     DSRGX\nMOVEIT8  CLI   OBTAREA+38,X'00'\n         BNE   DSORGU\n         CLC   OBTAREA+96(5),=XL5'0'\n         BNE   DSORGU\n         MVC   DSORG(2),ORGTABLE+16 MOVE 'VS' TO DSORG\n         B     DSRGX\nDSORGU   MVC   DSORG(2),ORGTABLE+14 MOVE 'U ' TO DSORG\n         SPACE 1\n*------- CREATE THE PARAMETER RECFM THAT IS MADE AVAILABLE\n*        TO THE CALLING CLIST\n         SPACE 1\nDSRGX    TM    OBTAREA+40,B'11000000'\n         BO    RECFMU\n         TM    OBTAREA+40,B'01000000'\n         BO    RECFMV\n         MVI   RECFM,C'F'\n         B     RECFMX\nRECFMU   MVI   RECFM,C'U'\n         B     RECFMX\nRECFMV   MVI   RECFM,C'V'\n         SPACE 1\n*------- CREATE THE PARAMETER CNTLCHAR THAT IS MADE AVAILABLE\n*        TO THE CALLING CLIST\n         SPACE 1\nRECFMX   TM    OBTAREA+40,B'00000100'\n         BO    ANSICNTL\n         TM    OBTAREA+40,B'00000010'\n         BO    MACHCNTL\n         MVI   CNTLCHAR,C'N'\n         B     CCHRX\nANSICNTL MVI   CNTLCHAR,C'A'\n         B     CCHRX\nMACHCNTL MVI   CNTLCHAR,C'M'\n         SPACE 1\n*------- CREATE THE PARAMETERS TRKSUSED AND EXTENTNO\n         SPACE 1\nCCHRX    MVC   EXTENTNO,=CL2'00'   MOVE 00 TO EXTENTNO\n         MVC   TRKSUSED,=CL5'00000' MOVE 00000 TO TRKSUSED\n         CLC   DSORG,=CL2'PS'      DSORG = 'PS' ?\n         BE    *+L'*+10            BRANCH IF SO\n         CLC   DSORG,=CL2'PO'      DSORG = 'PO' ?\n         BNE   SPACEX              BRANCH IF NOT SO\n         CLI   DEVTYPE,C'D'        IS DATA-SET ON DISK ?\n         BNE   SPACEX              BRANCH IF NOT\n         MVC   FLSPDSN,QUALDSN\n         MVC   FLSPVOL,VOLSER\n         LA    R1,FLPL             CALL 'FILSPACE' IN ORDER TO\n         LA    R15,FLSPAREA          OBTAIN NUMBER OF USED EXTENTS\n         ST    R15,0(R1)             AND NUMBER OF USED TRACKS\n         OI    0(R1),X'80'\n         L     R15,=V(FILSPACE)\n         BASR  R14,R15\n         LTR   R15,R15             RETURN CODE = 0 ?\n         BZ    GNSPINFO            BRANCH IF SO\n         CH    R15,=H'4'           RETURN CODE = 4 ?\n         BE    RCODE4              BRANCH IF SO\n         CH    R15,=H'8'           RETURN CODE = 8 ?\n         BE    RCODE8              BRANCH IF SO\n         CH    R15,=H'12'          RETURN CODE = 12 ?\n         BE    RCODEH              BRANCH IF SO\n         LA    R4,52               RC=52 ------------------------------\n         MVC   OUTMSG,MESS52       SET MESSAGE\n         B     INITL\nGNSPINFO MVC   EXTENTNO,OUTEXTNO   LOAD EXTENTNO\n         MVC   TRKSUSED,OUTTRKNO   LOAD TRKSUSED\nSPACEX   CLC   DSORG(2),=CL2'PO'   COMPARE DSORG = 'PO'\n         BE    PDS                 BRANCH IF YES\n         CLC   QUALMEM,=CL8'99999999' IS QUALMEM = '99999999' ?\n         BE    NOMEM               BRANCH IF YES\n         LA    R4,44               RC=44 ------------------------------\n         MVC   OUTMSG,MESS44       SET MESSAGE\n         B     INITL\nPDS      CLC   QUALMEM,=CL8'99999999' IS QUALMEM = '99999999' ?\n         BE    NOMEM               BRANCH IF YES\n         MVC   FNDDSN,QUALDSN      MOVE QUALDSN TO FNDDSN\n         MVC   FNDMEMBR,QUALMEM    MOVE QUALMEM TO FNDMEMBR\n         SPACE 1\n*------  CALL THE SUBROUTINE FINDMEM WHICH DYNAMICALLY FREES AND\n*        ALLOCATES THE FILE WITH DSN = FNDDSN TO DDNAME FINDMEDD AND\n*        THEN SEARCHES THE DIRECTORY FOR MEMBER NAME = FNDMEMBR\n*        (THE TWO BYTE FIELD INDICATR RETURNS VALUES WHICH\n*        RELATE TO THE SUCCESS OR NON SUCCESS OF THAT SEARCH)\n         SPACE 1\n         MVC   FNDVOL,VOLSER\n         LA    R1,FMPL\n         LA    R15,IOAREA\n         ST    R15,0(R1)\n         LA    R15,FNDVOL\n         ST    R15,4(R1)\n         OI    4(R1),X'80'\n         L     R15,=V(FINDMEM)\n         BASR  R14,R15\n         CLC   INDICATR,=CL2'00'   INDICATR = '00'?\n         BE    FINDX               BRANCH IF YES\n         CLC   INDICATR,=CL2'04'   INDICATR = '04'?\n         BE    INDIC04             BRANCH IF YES\n         CLC   INDICATR,=CL2'08'   INDICATR = '08'?\n         BE    INDIC08             BRANCH IF YES\n         CLC   INDICATR,=CL2'20'   INDICATR = '20'?\n         BE    INDIC20             BRANCH IF YES\n         CLC   INDICATR,=CL2'24'   INDICATR = '24'?\n         BE    INDIC24             BRANCH IF YES\nINDIC04  LA    R4,24               RC=24 ------------------------------\n         MVC   OUTMSG(30),MESS24   SET MESSAGE\n         B     FINDX\nINDIC08  LA    R4,28               RC=28 ------------------------------\n         MVC   OUTMSG(30),MESS28   SET MESSAGE\n         B     FINDX\nINDIC20  LA    R4,32               RC=32 ------------------------------\n         MVC   OUTMSG(30),MESS32   SET MESSAGE\n         B     FINDX\nINDIC24  LA    R4,36               RC=36 ------------------------------\n         MVC   OUTMSG(30),MESS36   SET MESSAGE\nFINDX    CLC   INDICATR,=CL2'00'   IS INDICATR = '00' ?\n         BE    *+L'*+10            BRANCH IF YES\n         MVC   MEMFND,=CL3'NO '    MOVE 'NO ' TO MEMFND\n         B     INITL\n         MVC   MEMFND,=CL3'YES'    MOVE 'YES' TO MEMFND\nNOMEM    XR    R4,R4               RC=0 -------------------------------\n         MVC   OUTMSG,MESS0        SET MESSAGE\n         SPACE 1\n*------- CONSTRUCT PARM.LIST FOR IKJCT441\n         SPACE 1\nINITL    L     R1,CVTPTR           FIND CVT\n         USING CVTMAP,R1\n         L     R8,CVTTVT           FIND THE TSVT\n         DROP  R1\n         LA    R1,TSVEUPDT\n         ST    R1,ENTRYCDE\n         LA    R1,ENTRYCDE\n         ST    R1,CT441PRM+0\n         LA    R1,VARINAME\n         ST    R1,NAMEADDR\n         LA    R1,NAMEADDR\n         ST    R1,CT441PRM+4\n         LA    R1,NAMELENG\n         ST    R1,CT441PRM+8\n         LA    R1,DATAADDR\n         ST    R1,CT441PRM+12\n         LA    R1,DATALENG\n         ST    R1,CT441PRM+16\n         LA    R1,TOKENPRM\n         ST    R1,CT441PRM+20\n         OI    CT441PRM+20,X'80'   SET VL=1\n         SPACE 1\n*------- STORE TSO CLIST VARIABLES\n         SPACE 1\n         LA    R2,=C'FULLDSN'      R2 ==> ADDRESS OF VAR NAME\n         LA    R3,7                R3 = LENGTH OF VAR NAME\n         LA    R1,FULLDSN          R1 ==> ADDRESS OF VAR VALUE\n         LR    R5,R2               R5 ==> ADDRESS OF VARIABLE\n         XR    R0,R0               R0 = 0\nCMPGT53  CL    R0,=F'53'           IS REG 0 GREATER THAN 53 ?\n         BH    DSNGT53             BRANCH IF YES\n         CLI   0(R5),C' '          IS FULLDSN AS INDEXED BY REG 5\n*                                    EQUAL TO SPACE ?\n         BE    HITASPAC            BRANCH IF YES\n         LA    R5,1(,R5)           ADD 1 TO REGISTER 5\n         AH    R0,=H'1'            ADD 1 TO REGISTER 0\n         B     CMPGT53\nDSNGT53  LA    R0,54               R0 = 54\nHITASPAC BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'LRECL'        R2 ==> ADDRESS OF VAR NAME\n         LA    R3,5                R3 = LENGTH OF VAR NAME\n         LA    R1,LRECL            R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,5                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'BLKSIZE'      R2 ==> ADDRESS OF VAR NAME\n         LA    R3,7                R3 = LENGTH OF VAR NAME\n         LA    R1,BLKSIZE          R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,5                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'RECFM'        R2 ==> ADDRESS OF VAR NAME\n         LA    R3,5                R3 = LENGTH OF VAR NAME\n         LA    R1,RECFM            R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,1                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'CNTLCHAR'     R2 ==> ADDRESS OF VAR NAME\n         LA    R3,8                R3 = LENGTH OF VAR NAME\n         LA    R1,CNTLCHAR         R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,1                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'DEVTYPE'      R2 ==> ADDRESS OF VAR NAME\n         LA    R3,7                R3 = LENGTH OF VAR NAME\n         LA    R1,DEVTYPE          R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,1                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'VOLSER'       R2 ==> ADDRESS OF VAR NAME\n         LA    R3,6                R3 = LENGTH OF VAR NAME\n         LA    R1,VOLSER           R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,6                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'DSORG'        R2 ==> ADDRESS OF VAR NAME\n         LA    R3,5                R3 = LENGTH OF VAR NAME\n         LA    R1,DSORG            R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,2                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'ISITCAT'      R2 ==> ADDRESS OF VAR NAME\n         LA    R3,7                R3 = LENGTH OF VAR NAME\n         LA    R1,ISITCAT          R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,3                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'MEMFND'       R2 ==> ADDRESS OF VAR NAME\n         LA    R3,6                R3 = LENGTH OF VAR NAME\n         LA    R1,MEMFND           R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,3                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'MEMCNTL'      R2 ==> ADDRESS OF VAR NAME\n         LA    R3,7                R3 = LENGTH OF VAR NAME\n         LA    R1,MEMCNTL          R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,3                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'TRKSUSED'     R2 ==> ADDRESS OF VAR NAME\n         LA    R3,8                R3 = LENGTH OF VAR NAME\n         LA    R1,TRKSUSED         R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,5                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'EXTENTNO'     R2 ==> ADDRESS OF VAR NAME\n         LA    R3,8                R3 = LENGTH OF VAR NAME\n         LA    R1,EXTENTNO         R1 ==> ADDRESS OF VAR VALUE\n         LA    R0,2                R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n         LA    R2,=C'OUTMSG'       R2 ==> ADDRESS OF VAR NAME\n         LA    R3,6                R3 = LENGTH OF VAR NAME\n         LA    R1,OUTMSG           R1 ==> ADDRESS OF VARIABLE\n         LA    R0,30               R0 = LENGTH OF DATA FIELD\n         BAS   R9,STOVAR\n         SPACE 1\n*------- END OF PROCESSING\n         SPACE 1\nQUIT    IKJRLSA #TSANSW\n        $XRET CC=(R4),LV=WORKLEN,TYPE=RENT\nPARSERR  LA    R4,100              RC=100 -----------------------------\n         B     QUIT\nSETRC    LA    R4,104              RC=104 -----------------------------\n         B     QUIT\n         EJECT\n*------- THIS ROUTINE IS RESPONSIBLE FOR GENERATING THE\n*        DATA FIELD FULLDSN IF A MEMBER NAME WAS PROVIDED\n*        WITHIN THE DATA-SET NAME.\n*        FULLDSN = X(Y)\n*            WHERE X IS THE SIGNIFICANT PORTION OF THE\n*                    OS CATALOG NAME (THE INPUT DSNAME\n*                    COULD HAVE BEEN AN ALIAS NAME)\n*              AND Y IS THE SIGNIFICANT PORTION OF THE\n*                    MEMBER NAME (FOUND IN QUALMEM)\n*        R14 = LINK REGISTER\n         SPACE 1\nGENFULDS LA    R5,FULLDSN\n         LA    R3,1\nGENLOOP1 CL    R3,=F'44'\n         BH    GENHIT1\n         CLI   0(R5),C' '\n         BE    GENHIT1\n         LA    R5,1(,R5)\n         AH    R3,=H'1'\n         B     GENLOOP1\nGENHIT1  MVI   0(R5),C'('\n         LA    R5,1(,R5)\n         LA    R3,1\n         LA    R1,QUALMEM\nGENLOOP2 CH    R3,=H'8'\n         BH    GENHIT2\n         CLI   0(R1),C' '\n         BE    GENHIT2\n         MVC   0(1,R5),0(R1)\n         LA    R5,1(,R5)\n         AH    R3,=H'1'\n         LA    R1,1(,R1)\n         B     GENLOOP2\nGENHIT2  MVI   0(R5),C')'\n         BR    R14\n         EJECT\n* ------ 'STOVAR' ROUTINE : STORE A VARIABLE.\n*        FILL IKJCT441 PARM.LIST, THEN CHECK\n*        IKJCT441 SERVICE FOR ERROR AND SEND MESSAGE.\n*        CALLING SEQUENCE :\n*              LA   R0,VARIABLE VALUE LENGTH\n*              LA   R1,VARIABLE VALUE ADDRESS\n*              LA   R2,VARIABLE NAME ADDRESS\n*              LA   R3,VARIABLE NAME LENGTH\n*              BAS  R9,STOVAR\n*        REGISTERS USED : R0, R1, R2, R3, R14 AND R15.\n*                         R8 = ADDRESS OF TSVT.\n*                         R9 = LINK REGISTER.\n         SPACE 1\nSTOVAR   LR    R15,R3\n         BCT   R15,*+L'*+6         COMPUTE MOVE LENGTH\n         MVC   VARINAME(*-*),0(R2)\n         EX    R15,*-6             MOVE VARIABLE NAME\n         ST    R3,NAMELENG         SET VARIABLE NAME LENGTH\n         ST    R1,DATAADDR         SET VARIABLE VALUE ADDRESS\n         AR    R1,R0               POINT PAST END OF STRING\n         BCTR  R1,0                BACK UP TO THE PREVIOUS CHARACTER\n         CLI   0(R1),C' '\n         BNE   *+L'*+8\n         BCT   R0,*-10\n         LA    R0,1\n         ST    R0,DATALENG         SET VARIABLE VALUE LENGTH\n         TM    SWITCH,NCLIST       ARE WE IN CLIST ?\n         BO    STOLST+L'STOLST     NO, GO LIST\n         LA    R1,CT441PRM         POINT AT PARM LIST\n         USING TSVT,R8\n         L     R15,TSVTVACC        LOAD THE VARIABLE ACCESS RTN\n         BASR  R14,R15             CALL IT\n         DROP  R8\n         LTR   R15,R15             ANY ERROR ?\n         BZR   R9                  NO, OK\n         CH    R15,=H'40'          YES, IS IT 'NOT CLIST' RC ?\n         BE    STOLST              YES, GO LIST\n         MVC   MSGBUF(25),=CL25' -> IKJCT441 : RC =    / '\n         CVD   R15,DUBLWURD\n         OI    DUBLWURD+L'DUBLWURD-1,X'0F'\n         UNPK  MSGBUF+19(3),DUBLWURD+L'DUBLWURD-2(2)\n         MVI   MSGBUF+19,C' '\n         MVC   MSGBUF+25(L'MSGBUF-25),MSGBUF+24\n         L     R1,NAMELENG\n         BCT   R1,*+L'*+6\n         MVC   MSGBUF+25(*-*),VARINAME\n         EX    R1,*-6\n         MVC   WTOMSG(2),WSKEL\n         LA    R1,L'MSGBUF+4\n         STCM  R1,B'0011',WTOMSG+2\n         MVC   DCRC(4),WSKEL+6\n         LA    R1,WTOMSG\n         BAS   R14,PUTMSG\n         BR    R9\nSTOLST   OI    SWITCH,NCLIST       SET 'NOT CLIST' INDICATOR\n         MVI   MSGBUF,C' '         CLEAR BUFFER TO SPACES\n         MVC   MSGBUF+1(L'MSGBUF-1),MSGBUF\n         L     R1,NAMELENG\n         BCT   R1,*+L'*+6\n         MVC   MSGBUF+1(*-*),VARINAME\n         EX    R1,*-6\n         MVI   MSGBUF+10,C':'\n         L     R1,DATALENG\n         L     R14,DATAADDR\n         BCT   R1,*+L'*+6\n         MVC   MSGBUF+12(*-*),0(R14)\n         EX    R1,*-6\n         LA    R0,L'MSGBUF\n         LA    R1,MSGBUF\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     0(R9)               +0 - OK\n         B     SETRC               +4 - ERROR\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*             D A T A     A R E A     C O N S T A N T S             *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nPATCAML1 CAMLST NAME,*-*,,*-*\nPATCAML2 CAMLST SEARCH,*-*,*-*,*-*\nWSKEL   WTO    'XX',ROUTCDE=11,DESC=7,MF=L\n         SPACE 1\nMESS0    DC    C'SUCCESSFUL COMPLETION         '\nMESS4    DC    C'DATASET NOT CATALOGED         '\nMESS8    DC    C'FILE IS ON MORE THAN 1 VOLUME '\nMESS12   DC    C'REQUIRED VOLUME NOT MOUNTED   '\nMESS16   DC    C'FORMAT-1 DSCB NOT FOUND ON VOL'\nMESS20   DC    C'OBTAIN - RETURN CODE 12/16/20 '\nMESS24   DC    C'MEMBER NAME NOT FOUND         '\nMESS28   DC    C'UNSUCCESFUL DYNAMIC ALLOCATION'\nMESS32   DC    C'I/O ERROR READING DIRECTORY   '\nMESS36   DC    C'FINDMEM - RETURN CODE 24      '\nMESS40   DC    C'FILE IS ON A TAPE VOLUME      '\nMESS44   DC    C'DATASET NOT PARTITIONED       '\nMESS48   DC    C'INVALID SYNTAX OF MEMBER NAME '\nMESS52   DC    C'FILSPACE - RETURN CODE 16     '\nMESS96   DC    C'INVALID SYNTAX OF OPERAND(S)  '\nORGTABLE DC    C'ISPSDACXCQMQPOU VS'\nOKCHARS1 DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ@$#+'\nOKCHARS2 DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@$# +'\n         SPACE 1\n         LTORG\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*                     P A R S E     M A C R O S                     *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n        PRINT  NOGEN\nPARMLST  IKJPARM\nDSN      IKJKEYWD DEFAULT='DSN'\n         IKJNAME 'DSNAME',SUBFLD=DSNAM,ALIAS=('DATASET','DA','D')\nVOL      IKJKEYWD DEFAULT='VOL(999999)'\n         IKJNAME 'VOLUME',SUBFLD=VOLSR,ALIAS=('VOLSER','V')\nMEM      IKJKEYWD DEFAULT='MEM'\n         IKJNAME 'MEMBER',SUBFLD=MEMBR,ALIAS=('M')\nDSNAM    IKJSUBF\nDSTRING  IKJPOSIT DSNAME,USID\nVOLSR    IKJSUBF\nVSTRING  IKJPOSIT DSNAME,VOLSER\nMEMBR    IKJSUBF\nMSTRING  IKJIDENT 'MEM NAME',MAXLNTH=13,DEFAULT='99999999',CHAR\n         IKJENDP\n        PRINT  GEN\n         SPACE 1\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*               D Y N A M I C     W O R K     A R E A               *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nWORKAREA DSECT\n         DS    18F                 SAVE AREA\n        $TEW$WA\n         SPACE 1\nQUALDSN  DS    CL44\nINVOL    DS    CL6\nQUALMEM  DS    CL8\nCPMEM1   DS    CL8\nCPMEM2   DS    CL8\n         SPACE 1\nCAMLIST1 CAMLST NAME,QUALDSN,,LOCAREA\nLOCAREA  DS    0D\n         DS    265C\n         SPACE 1\nCAMLIST2 CAMLST SEARCH,QUALDSN,OBTVOL,OBTAREA\nOBTAREA  DS    0D\n         DS    140C\n         DS    0D\nOBTVOL   DS    CL6\n         SPACE 1\n* THESE FIELDS ARE TO BECOME THE CLIST VARIABLE FIELDS BY SAME NAME\n         SPACE 1\nFULLDSN  DS    CL54\nLRECL    DS    CL5\nBLKSIZE  DS    CL5\nRECFM    DS    CL1\nCNTLCHAR DS    CL1\nDEVTYPE  DS    CL1\nVOLSER   DS    CL6\nDSORG    DS    CL2\nISITCAT  DS    CL3\nMEMFND   DS    CL3\nMEMCNTL  DS    CL3\nTRKSUSED DS    CL5\nEXTENTNO DS    CL2\nOUTMSG   DS    CL30\nSWITCH   DS    XL1\nNCLIST   EQU   X'80'\n         SPACE 1\nDUBLWURD DS    D\nFULLWURD DS    F\nSAVEIT   DS    F\n         SPACE 1\nCT441PRM DS    6F                  IKJCT441 PARM.LIST\nENTRYCDE DS    F                   ENTRY CODE\nNAMEADDR DS    A                   ADDRESS OF VARIABLE NAME\nNAMELENG DS    F                   LENGTH OF VARIABLE NAME\nDATAADDR DS    A                   ADDRESS OF VARIABLE DATA\nDATALENG DS    F                   LENGTH OF VARIABLE DATA\nTOKENPRM DS    F                   TOKEN TO VARIABLE ACCESS SERVICE\nVARINAME DS    CL32                VARIABLE NAME FIELD\n         SPACE 1\nWTOMSG   DS    F                   WTO - TEXT LENGTH, MCSFLAGS\nMSGBUF   DS    CL72                MESSAGE AREA\nDCRC     DS    CL4                 WTO - DESCRIPTOR AND ROUTING CODES\n         SPACE 1\nFMPL     DS    2A\nIOAREA   DS    0CL56 - - - - - - --+\n         DS    XL2                 +\nFNDMEMBR DS    CL8                 +\nFNDDSN   DS    CL44                +\nINDICATR DS    CL2                 +-- IOAREA\nFNDVOL   DS    CL6\n         SPACE 1\nFLPL     DS    A\nFLSPAREA DS    0CL59 - - - - - - --+\n         DS    XL2                 +\nFLSPDSN  DS    CL44                +\nFLSPVOL  DS    CL6                 +\nOUTEXTNO DS    XL2                 +\nOUTTRKNO DS    XL5                 +-- FLSPAREA\n         SPACE 1\nWORKLEN  EQU   (((*-WORKAREA)+7)/8)*8\n         SPACE 1\n*------- OTHER DSECT'S\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS\n        IKJTSVT\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILSPAC$": {"ttr": 15879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14\\x18\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:18:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//FILSPACE JOB (........),'INSTALL - FILSPACE -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=FILSPACE\n//LNK     EXEC PAJILKR,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   FILSPACE\n  NAME    FILSPACE(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILSPAC@": {"ttr": 15881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14\"\\x00@\\x00@\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:22:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/07/90\n                                                      FILSPACE  1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          FILSPACE ROUTINE           * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n  Routine :      FILSPACE\n  Author :       Jeff Sprehn\n  Agency :       WDPSC\n  Origin :       Extracted from tape CBT 89 FEB, file 270\n  Language :     Assembler\n  Run mode :     Batch or Interactive\n  Attributes :   Re-enterable\n  Function :     Subroutine that accepts a data-set name and volume\n                 serial number and returns the number of used extents\n                 and the number of used tracks.\n\n  This is a subroutine that accepts a data-set name and the volume\n  serial number that is passed to it and returns to the invoker the\n  number of used extents and the number of used tracks.\n\n  To use this routine from a COBOL program, do the following :\n       1. Place the following data area in the WORKING-STORAGE :\n          01  FILSPACE-I-O-AREA.\n              05  FILLER                    PIC X(02).\n              05  IN-DSN                    PIC X(44).\n              05  IN-VOL-SER                PIC X(06).\n              05  OUT-NO-OF-USED-EXTENTS    PIC 9(2).\n              05  OUT-NO-OF-USED-TRACKS     PIC 9(5).\n       2. Place the following code in the PROCEDURE DIVISION :\n          MOVE the data-set name\n            TO IN-DSN OF FILSPACE-I-O-AREA.\n          MOVE the volume serial number\n            TO IN-VOL-SER OF FILSPACE-I-O-AREA.\n          CALL 'FILSPACE' USING FILSPACE-I-O-AREA.\n\n  To use this routine from an ASSEMBLER program, do the following :\n                ...\n                CALL  FILSPACE,(IOAREA),VL\n                LTR   R15,R15            Test completion code\n                ...\n                DS    0F\n       IOAREA   DS    0XL59\n                DC    XL2'0'             Filler\n       INDSN    DC    CL44'...'          The data-set name\n       INVOL    DC    CL6'...'           The volume serial number\n       OUTUEXT  DC    CL2' '             No of used extents\n       OUTUTRK  DC    CL5' '             No of used tracks\n                ...\n1   10/07/90\n                                                      FILSPACE  2/2.\n\n  Return code   Meaning\n  -----------   ------------------------------------------------------\n\n       0        Successful completion\n       4        Required volume is not mounted\n       8        Data-set is not found on volume indicated\n      12        OBTAIN macro returned with RC = 12, 16, or 20\n      16        Unknown unit type was encountered\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FILSPACE": {"ttr": 15883, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x19O\\x00\\x90\\x19O\\tA\\x01S\\x01S\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-07-13T00:00:00", "modifydate": "1990-07-13T09:41:00", "lines": 339, "newlines": 339, "modlines": 0, "user": "SYSPAJA"}, "text": "FLSP     TITLE 'FILSPACE -- DATA-SET SPACE INFORMATION.'\nFILSPACE START 0\n         SPACE 1\n* ORIGIN :     EXTRACTED FROM TAPE CBT 89 FEB, FILE 270.\n* --------     ADAPTED BY MOINIL P.A.\n*              ATTRIBUTES : RE-ENTERABLE\n*\n* PURPOSE :    THIS IS A SUBROUTINE THAT ACCEPTS A DATA-SET NAME AND\n* ---------    THE VOLUME SERIAL NUMBER THAT IS PASSED TO IT AND\n*              RETURNS TO THE INVOKER THE NUMBER OF USED EXTENTS AND\n*              THE NUMBER OF USED TRACKS.\n*\n* TO USE THIS ROUTINE FROM A COBOL PROGRAM, DO THE FOLLOWING :\n*            1. PLACE THE FOLLOWING DATA AREA IN THE WORKING-STORAGE :\n*                 01  FILSPACE-I-O-AREA.\n*                     05  FILLER                    PIC X(02).\n*                     05  IN-DSN                    PIC X(44).\n*                     05  IN-VOL-SER                PIC X(06).\n*                     05  OUT-NO-OF-USED-EXTENTS    PIC 9(2).\n*                     05  OUT-NO-OF-USED-TRACKS     PIC 9(5).\n*            2. PLACE THE FOLLOWING CODE IN THE PROCEDURE DIVISION :\n*                 MOVE DATA-SET NAME\n*                   TO IN-DSN OF FILSPACE-I-O-AREA.\n*                 MOVE VOLUME SERIAL NUMBER\n*                   TO IN-VOL-SER OF FILSPACE-I-O-AREA.\n*                 CALL 'FILSPACE' USING FILSPACE-I-O-AREA.\n*\n* RETURN CODE        MEANING\n* -----------        -------------------------------------------------\n*      0             SUCCESSFUL COMPLETION\n*      4             REQUIRED VOLUME IS NOT MOUNTED\n*      8             DATA-SET IS NOT FOUND ON VOLUME INDICATED\n*     12             OBTAIN MACRO RETURNED WITH RC = 12, 16, OR 20\n*     16             UNKNOWN UNIT TYPE WAS ENCOUNTERED\n         EJECT\n        $DEFREG\n         EJECT\n*------- INITIALIZATION.\n         SPACE 1\n        $XENT  BASE=R12,LV=WKLEN,TYPE=RENT\n         LR    R2,R1\n         LR    R9,R13\n         USING WKAREA,R9\n         L     R3,0(R2)\n         MVC   FLSPAREA(L'FLSPAREA),0(R3)\n         SPACE 1\n*------- DO AN OBTAIN ON THE DATA-SET NAME.\n         SPACE 1\n         MVC   CAMLST2(CMLIST2L),CMLIST2\n         LA    R1,INDSN\n         STCM  R1,B'1111',CAMLST2+4\n         LA    R1,INVOL\n         STCM  R1,B'1111',CAMLST2+8\n         LA    R1,OBTAREA\n         STCM  R1,B'1111',CAMLST2+12\n        OBTAIN CAMLST2\n         LTR   R10,R15             TEST OBTAIN RC\n         BZ    OBTOK               BRANCH IF REG 15 = 0\nOBTERR   CH    R10,=H'8'           TEST IF OBTAIN RC IS .GT. 8\n         BNH   LEAVE               BRANCH IF NOT\n         LA    R10,12              R10 ==> 12\n         B     LEAVE\n         SPACE 1\n*------- PROCESS THE DSCB1.\n*        IF AN ERROR IS ENCOUNTERED, REGISTER 10 IS SET TO THE\n*        APPROPRIATE VALUE WHICH IDENTIFIES THE REASON FOR THE ERROR.\n*        IF NO ERROR IS ENCOUNTERED AND THE USED EXTENTS DOES NOT\n*        EXCEED 3 (HENCE THERE IS NO DSCB3), THEN APPROPRIATE VALUES\n*        ARE MOVED TO OUTTRKNO AND OUTEXTNO (I.E. 1, 2 OR 3).\n*        IF NO ERROR IS ENCOUNTERED AND AND THE USED EXTENTS DOES\n*        DOES EXCEED 3 AND THUS IT NEEDS TO PROCESS THE DSCB3, THEN\n*        THE APPROPRIATE VALUE IS MOVED TO OUTTRKNO.\n         SPACE 1\nOBTOK    ZAP   RUNTOT,=PL1'+0'     RUNTOT = 0\n         MVC   DS1LSTAR,OBTAREA+54\n         CLC   DS1LSTAR,=XL3'0'\n         BNE   NOTEMPTY\n         MVC   OUTEXTNO(L'OUTEXTNO),=CL5'00000'\n         MVC   OUTTRKNO,=CL5'00000'\n         B     DSCB1X\nNOTEMPTY MVC   HALFWORD(2),DS1LSTAR\n         LH    R3,HALFWORD\n         AH    R3,=H'1'\n         CVD   R3,CONVDEC\n         MVC   LSTRTRKS(3),CONVDEC+5\n         UNPK  OUTTRKNO(5),LSTRTRKS(3)\n         OI    OUTTRKNO+4,X'F0'\n         CLI   OBTAREA+61,X'00'    IS 1ST EXTENT DESC INSIGNIFICANT ?\n         BE    DSCB1X              BRANCH IF SO\n         MVC   OUTEXTNO,=CL2'01'   MOVE 01 TO OUTEXTNO\n         MVC   BGNCCHH(4),OBTAREA+63\n         MVC   ENDCCHH(4),OBTAREA+67\n         BAL   R8,CALCTRKS         PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         TM    SWITCH,PRSKIP       WERE ANY ERRORS ENCOUNTERED ?\n         BO    LEAVE               BRANCH IF SO\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                    TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                    DS1LSTAR VALUE ?\n         BNH   DSCB1X              BRANCH IF SO\n         CLI   OBTAREA+71,X'00'    IS 2ND EXTENT DESC INSIGNIFICANT ?\n         BE    DSCB1X              BRANCH IF SO\n         MVC   OUTEXTNO,=CL2'02'   MOVE 02 TO OUTEXTNO\n         MVC   BGNCCHH(4),OBTAREA+73\n         MVC   ENDCCHH(4),OBTAREA+77\n         BAL   R8,CALCTRKS         PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         TM    SWITCH,PRSKIP       WERE ANY ERRORS ENCOUNTERED ?\n         BO    LEAVE               BRANCH IF SO\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                    TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                    DS1LSTAR VALUE ?\n         BNH   DSCB1X              BRANCH IF SO\n         CLI   OBTAREA+81,X'00'    IS 3RD EXTENT DESC INSIGNIFICANT ?\n         BE    DSCB1X              BRANCH IF SO\n         MVC   OUTEXTNO,=CL2'03'   MOVE 03 TO OUTEXTNO\n         MVC   BGNCCHH(4),OBTAREA+83\n         MVC   ENDCCHH(4),OBTAREA+87\n         BAL   R8,CALCTRKS         PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         TM    SWITCH,PRSKIP       WERE ANY ERRORS ENCOUNTERED ?\n         BO    LEAVE               BRANCH IF SO\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                    TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                    DS1LSTAR VALUE ?\n         BNH   DSCB1X              BRANCH IF SO\n         OI    SWITCH,PRDSCB3      SAY DSCB3 TO BE PROCESSED\n         MVC   CCHHR,OBTAREA+91    MOVE CCHHR PTR FOR DSCB3 TO CCHHR\nDSCB1X   TM    SWITCH,PRDSCB3      DO WE NEED TO PROCESS THE DSCB3 ?\n         BZ    LEAVE               BRANCH IF NOT\n         SPACE 1\n*------- PROCESS THE DSCB3 AND THEN GENERATE THE EXTENT NUMBER.\n         SPACE 1\n         MVC   CAMLST3(CMLIST3L),CMLIST3\n         LA    R1,CCHHR\n         STCM  R1,B'1111',CAMLST3+4\n         LA    R1,INVOL\n         STCM  R1,B'1111',CAMLST3+8\n         LA    R1,DCB3AREA\n         STCM  R1,B'1111',CAMLST3+12\n        OBTAIN CAMLST3\n         LTR   R10,R15             TEST OBTAIN RC\n         BNZ   OBTERR              BRANCH IF REG 15 NOT 0\n         ZAP   PACKEXT#,=PL1'+3'\n         LA    R3,DCB3AREA         R3 ==> ADDRESS OF DSCB3\n         LA    R3,4(R3)            OFFSET TO DS3EXTNT\n         LA    R4,4\nLOOP3A   CLI   0(R3),X'00'\n         BE    UNPKEXT#\n         AP    PACKEXT#,=PL1'+1'\n         MVC   BGNCCHH(4),2(R3)\n         MVC   ENDCCHH(4),6(R3)\n         BAL   R8,CALCTRKS         PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         TM    SWITCH,PRSKIP       WERE ANY ERRORS ENCOUNTERED ?\n         BO    LEAVE               BRANCH IF SO\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                    TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                    DS1LSTAR VALUE ?\n         BNH   UNPKEXT#            BRANCH IF SO\n         LA    R3,10(R3)\n         BCT   R4,LOOP3A\n         LA    R3,1(R3)            OFFSET TO DS3ADEXT\n         LA    R4,9\nLOOP3B   CLI   0(R3),X'00'\n         BE    UNPKEXT#\n         AP    PACKEXT#,=PL1'+1'\n         MVC   BGNCCHH(4),2(R3)\n         MVC   ENDCCHH(4),6(R3)\n         BAL   R8,CALCTRKS         PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         TM    SWITCH,PRSKIP       WERE ANY ERRORS ENCOUNTERED ?\n         BO    LEAVE               BRANCH IF SO\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                    TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                    DS1LSTAR VALUE ?\n         BNH   UNPKEXT#            BRANCH IF SO\n         LA    R3,10(R3)\n         BCT   R4,LOOP3B\nUNPKEXT# UNPK  OUTEXTNO(2),PACKEXT#(3)\n         OI    OUTEXTNO+1,X'F0'\n         SPACE 1\n*------- END OF PROCESSING.\n         SPACE 1\nLEAVE    L     R3,0(R2)\n         MVC   0(L'FLSPAREA,R3),FLSPAREA\n        $XRET  CC=(R10),LV=WKLEN,TYPE=RENT\n         EJECT\n*------- THIS ROUTINE CALCULATES THE NUMBER OF TRACKS GIVEN A\n*        BEGINNING CCHH AND AN ENDING CCHH.\n*        BEFORE PERFORMING THIS ROUTINE, DO THE FOLLOWING :\n*            MOVE THE BEGINNING CCHH TO BGNCCHH,\n*            AND MOVE THE ENDING CCHH TO ENDCCHH.\n*        AFTER PERFORMING THIS ROUTINE, THE NUMBER OF USED\n*        TRACKS WILL BE IN TOTRACKS.\n*        LINK REGISTER = R8.\n         SPACE 1\nCALCTRKS LH    R0,BGNCCHH\n         CVD   R0,CONVDEC          PACK BEGINNING CYL\n         MVC   BEGINCYL(3),CONVDEC+5\n         LH    R0,ENDCCHH\n         CVD   R0,CONVDEC          PACK ENDING CYL\n         MVC   ENDCYL(3),CONVDEC+5\n         LH    R0,BGNCCHH+2\n         CVD   R0,CONVDEC          PACK BEGINNING TRK\n         MVC   BEGINTRK(3),CONVDEC+5\n         LH    R0,ENDCCHH+2\n         CVD   R0,CONVDEC          PACK ENDING TRK\n         MVC   ENDTRK(3),CONVDEC+5\n         ZAP   CYLDIFF,ENDCYL      CYLDIFF = ENDING CYL #\n         SP    CYLDIFF,BEGINCYL    CYLDIFF = ENDING CYL - BEGIN CYL\n         SPACE 1\n*------- EXAMINES VOL SER TO DETERMINE THE # OF TRACKS PER\n*        CYLINDER AND PLACES THE ANSWER IN TRKPRCYL.\n*        IF AN ERROR IS ENCOUNTERED, THE REGISTER 10 IS\n*        LOADED WITH 16 AND CONTROL GO BACK.\n         SPACE 1\n         LA    R1,UCBWA\n         ST    R1,PLIST\n         LA    R1,DEVCL\n         ST    R1,PLIST+4\n         LA    R1,UCBADDR\n         ST    R1,PLIST+8\n         OI    PLIST+8,X'80'\n         MVI   DEVCL,UCB3DACC\n         XC    UCBWA,UCBWA         UCB LOOKUP LIST FROM CVT\n         L     R5,CVTPTR           ADDRESS OF CVT INTO R9\n         USING CVT,R5\nSCANUCB  L     R15,CVTUCBSC\n         LA    R1,PLIST\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   DETRERR             BRANCH IF END, NOT FOUND\n         L     R1,UCBADDR          GET ADDRESS OF A UCB\n         USING UCBDSECT,R1\n         TM    UCBJBNR,UCBVRDEV    IS IT VIO?\n         BO    SCANUCB             BRANCH IF YES\n         TM    UCBSTAT,UCBONLI     IS IT ONLINE?\n         BZ    SCANUCB             BRANCH IF NOT\n         CLC   UCBVOLI,INVOL       TABLE ENTRY VS VOL IN UCB\n         BNE   SCANUCB             BRANCH IF NOT EQUAL\n         L     R7,CVTZDTAB         CVTZDTAB.\n         DROP  R5\n         XR    R0,R0\n         LR    R5,R0\n         LR    R6,R0\n         IC    R6,UCBTBYT1         GET DEVICE TYPE.\n         IC    R5,0(R6,R7)         GET DISPL. OF SINGLE DEV. TABLE.\n         LA    R5,0(R5,R7)         COMPUTE DEV. TABLE ADDRESS.\n         ICM   R0,B'0011',2(R5)    NO. OF TRKS PER CYL.\n         CVD   R0,CONVDEC\n         MVC   TRKPRCYL,CONVDEC+5\n         DROP  R1\n         CP    ENDTRK,BEGINTRK     IF ENDING TRK # > BEGINNING TRK\n         BH    ENDISGT             BRANCH IF YES\n         ZAP   TRKDIFF,ENDTRK      TRKDIFF = ENDING TRACK #\n         SP    TRKDIFF,BEGINTRK    TRKDIFF = ENDING TRK - BEGIN TRK\n         AP    TRKDIFF,=PL1'+1'    ADD 1 TO TRKDIFF\n         B     DOCALC\nENDISGT  SP    CYLDIFF,=PL1'+1'    SUBTRACT 1 FROM CYLDIFF\n         ZAP   REMANTRK,TRKPRCYL   REMANTRK = TRKPRCYL\n         SP    REMANTRK,BEGINTRK   REMANTRK = TRKPRCYL - BEGINTRK\n         ZAP   TRKDIFF,REMANTRK    TRKDIFF = REMANTRK\n         AP    TRKDIFF,ENDTRK      TRKDIFF = REMANTRK + ENDTRK\n         AP    TRKDIFF,=PL1'+1'    ADD 1 TO TRKDIFF\nDOCALC   ZAP   TOTRACKS,TRKPRCYL   TOTRACKS = TRKPRCYL\n         MP    TOTRACKS,CYLDIFF    TOTRACKS = TRKPRCYL * CYLDIFF\n         AP    TOTRACKS,TRKDIFF    ADD TRKDIFF TO TOTRACKS\n         BR    R8                  RETURN\nDETRERR  OI    SWITCH,PRSKIP       UNKNOWN UNIT TYPE, SAY SKIP PROCESS\n         LA    R10,16              R10 ==> 16\n         BR    R8                  RETURN\n         EJECT\n*------- DATA CONSTANTS.\nCMLIST2 CAMLST SEARCH,*-*,*-*,*-*\nCMLIST2L EQU   *-CMLIST2\nCMLIST3 CAMLST SEEK,*-*,*-*,*-*\nCMLIST3L EQU   *-CMLIST3\n         SPACE 1\n        LTORG\n         EJECT\nWKAREA   DSECT\n         DS    18F                 SAVE AREA\nCONVDEC  DS    D\nUCBWA    DS    XL100\n         SPACE 1\nCAMLST2 CAMLST SEARCH,*-*,*-*,*-*\nCAMLST3 CAMLST SEEK,*-*,*-*,*-*\nOBTAREA  DS    0D\n         DS    XL140\nDCB3AREA DS    0D\n         DS    XL140\n         SPACE 1\n         DS    0F\nFLSPAREA DS    0CL59 - - - - - - - +\n         DS    CL2                 +\nINDSN    DS    CL44                +\nINVOL    DS    CL6                 +\nOUTEXTNO DS    CL2                 +\nOUTTRKNO DS    CL5                 + - BREAKDOWN OF FLSPAREA\n         SPACE 1\nPLIST    DS    3F\nUCBADDR  DS    A\n         SPACE 1\nBGNCCHH  DS    F\nENDCCHH  DS    F\nHALFWORD DS    H\nRUNTOT   DS    PL6\nTOTRACKS DS    PL6\nCCHHR    DS    CL5\nBEGINCYL DS    PL3\nBEGINTRK DS    PL3\nCYLDIFF  DS    PL3\nDS1LSTAR DS    CL3\nENDCYL   DS    PL3\nENDTRK   DS    PL3\nLSTRTRKS DS    PL3\nPACKEXT# DS    PL3\nREMANTRK DS    PL3\nTRKDIFF  DS    PL3\nTRKPRCYL DS    PL3\nDEVCL    DS    XL1\nSWITCH   DS    XL1\nPRSKIP   EQU   X'80'\nPRDSCB3  EQU   X'40'\n         SPACE 1\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8\n         SPACE 2\n        PRINT  NOGEN\n        CVT    DSECT=YES,LIST=YES\nUCBDSECT DSECT\n        IEFUCBOB\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDMEM": {"ttr": 16132, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x19\\x0f\\x00\\x90\\x19\\x0f\\x15A\\x01w\\x01w\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-07-09T00:00:00", "modifydate": "1990-07-09T15:41:00", "lines": 375, "newlines": 375, "modlines": 0, "user": "SYSPAJA"}, "text": "FNDM     TITLE 'FINDMEM -- SEARCH PDS FOR A PARTICULAR MEMBER.'\nFINDMEM  START 0\n         SPACE 1\n* ORIGIN :     EXTRACTED FROM TAPE CBT 89 FEB, FILE 270.\n* --------     ADAPTED BY MOINIL P.A.\n*              ATTRIBUTES : RE-ENTERABLE\n*\n* PURPOSE :    THIS IS A SUBROUTINE WHICH DYNAMICALLY ALLOCATES THE\n* ---------    FILE WITH DSN PASSED TO THIS ROUTINE AND THEN SEARCHES\n*              THE DIRECTORY TO DETERMINE WHETHER THE MEMBER NAME\n*              PASSED TO THIS ROUTINE EXISTS.\n*\n* TO CALL THIS ROUTINE FROM A COBOL PROGRAM, DO THE FOLLOWING :\n*              1. IF YOUR PDS IS CATALOGUED,\n*                   MOVE YOUR DSN TO DSNAME OF FINDMEM-I-O-AREA.\n*                   MOVE YOUR MEMBER NAME\n*                       TO MEMBER-NAME OF FINDMEM-I-O-AREA.\n*                   CALL 'FINDMEM' USING FINDMEM-I-O-AREA.\n*                 WHERE :  01  FINDMEM-I-O-AREA.\n*                              05  OP-SYS VALUE 'VS'  PIC X(2).\n*                              05  MEMBER-NAME        PIC X(8).\n*                              05  DSNAME             PIC X(44).\n*                              05  SUCCESS-INDICATOR  PIC 99.\n*              2. IF YOUR PDS IS NOT CATALOGUED,\n*                   MOVE YOUR DSN TO DSNAME OF FINDMEM-I-O-AREA.\n*                   MOVE YOUR MEMBER NAME\n*                       TO MEMBER-NAME OF FINDMEM-I-O-AREA.\n*                   MOVE THE VOLUME SERIAL NUMBER TO VOL-SER-NO.\n*                   CALL 'FINDMEM' USING FINDMEM-I-O-AREA, VOL-SER-NO.\n*                 WHERE :  01  FINDMEM-I-O-AREA (SEE ABOVE)\n*                          01  VOL-SER-NO             PIC X(6).\n*\n* SUCCESS-INDICATOR   MEANING\n* -----------------   ------------------------------------------------\n*        00           SUCCESSFUL ALLOCATION AND FIND\n*        04           SUCCESSFULLY ALLOCATED FILE BUT COULDN'T FIND\n*                       MEMBER IN DIRECTORY\n*        08           UNSUCCESSFUL ALLOCATION\n*        12           DSN PASSED TO THIS ROUTINE IS SPACES\n*        16           MEMBER NAME PASSED IS SPACES\n*        20           I/O ERROR READING DIRECTORY\n*        24           UNSUCCESSFUL FREE OF DDNAME FINDMEDD\n*        28           INVALID VOL SER PASSED TO THIS ROUTINE\n         EJECT\n* ASSIGNMENT OF REGISTERS :\n* -------------------------\n*\n*        REGISTER      USAGE\n*        --------      -------------------------------------------\n*            1         ADDRESS OF PARAMETER LIST\n*            2         SAVE REGISTER 1\n*            3         WORK REGISTER\n*            4         WORK REGISTER\n*            5         WORK REGISTER\n*            6         NOT USED\n*            7         NOT USED\n*            8         NOT USED\n*            9         NOT USED\n*           10         SAVE RETURN CODE VALUE\n*           11         NOT USED\n*           12         BASE REGISTER\n*           13         ADDRESS OF SAVE AREA\n*           14         RETURN ADDRESS, LINK REGISTER\n*           15         ENTRY POINT ADDRESS\n         SPACE 1\n        $DEFREG\n         EJECT\n*------- INITIALIZATION.\n         SPACE 1\n        $XENT  BASE=R12,LV=WKLEN,TYPE=RENT\n         LR    R2,R1\n         LR    R9,R13\n         USING WKAREA,R9\n         MVI   SWITCH,0\n         MVC   FREEPARM(FREELL),FREELST\n         MVC   DD1PARM(DD1LL),DD1LST\n         L     R5,0(R2)\n         MVC   IOAREA(L'IOAREA),0(R5)\n         TM    0(R2),X'80'         IS FINDMEM BEING CALLED WITH ONLY\n*                                    ONE PARMERATOR ?\n         BO    NOINVOL             BRANCH IF SO\n         L     R5,4(R2)            R5 ==> ADDRESS OF VOL SER NO\n         MVC   INVOL(L'INVOL),0(R5) PUT VOL SER NO INTO INVOL\n         B     LOADSN\nNOINVOL  MVC   INVOL,=CL6'ABSENT'\n         SPACE 1\n*------- LOAD THE 2 DATA AREAS DSNLEN AND DSNAME.\n*        THE DSN THAT IS PASSED TO THIS ROUTINE IS MOVED TO DSNAME,\n*        THEN CALCULATES THE SIGNIFICANT LENGTH OF DSNAME AND MOVE\n*        THAT VALUE TO DSNLEN (EXPRESSED IN BINARY).\n         SPACE 1\nLOADSN   MVC   DSNAME,DSN          MOVE DSN THAT IS PASSED TO THIS\n*                                    ROUTINE TO DSNAME\n         LA    R4,44               LOAD REG 4 WITH 44\n         LA    R3,DSNAME+43\nCOMPR1   CL    R4,=F'1'            COMPARE REG 4 TO 1\n         BNL   COMPR2              BRANCH IF NOT LOW\n         MVC   INDICATR,=CL2'12'   MOVE 12 TO SUCCESS-INDICATOR\n         LA    R10,12              MOVE 12 TO REGISTER 10\n         B     QUIT\nCOMPR2   CLI   0(R3),C' '          IS DSNAME AS INDEXED BY REG 3\n*                                    EQUAL TO A SPACE?\n         BNE   LOADLEN             BRANCH IF NOT\n         SL    R3,=F'1'            SUBTRACT 1 FROM REGISTER 3\n         SL    R4,=F'1'            SUBTRACT 1 FROM REGISTER 4\n         B     COMPR1\nLOADLEN  STCM  R4,B'0011',DSNLEN   STORE R4 LOW ORDER 2 BYTES TO DSNLEN\nLOADX    CLC   INVOL,=CL6'ABSENT'  WAS VOL SER PROVIDED ?\n         BE    ALLOCT              BRANCH IF NOT\n         SPACE 1\n*------- EDIT INVOL.\n*        IF INVOL MEETS THE CRITERIA FOR BEING A VALID\n*        VOLUME SERIAL NUMBER (6 BYTES LONG, ALL NUMERICS\n*        AND ALPHABETICS).\n         SPACE 1\n         LA    R3,INVOL\n         LA    R4,6\nEDIT1BYT MVC   EDITBYTE(1),0(R3)\n         CLI   EDITBYTE,C'0'\n         BL    NEXTEST\n         CLI   EDITBYTE,C'9'\n         BNH   NEXTBYT\nBADINVOL MVC   INDICATR,=CL2'28'    MOVE 28 TO SUCCESS-INDICATOR\n         LA    R10,28               MOVE 28 TO REGISTER 10\n         B     QUIT\nNEXTEST  CLI   EDITBYTE,C'A'\n         BL    BADINVOL\n         CLI   EDITBYTE,C'Z'\n         BH    BADINVOL\nNEXTBYT  LA    R3,1(R3)\n         BCT   R4,EDIT1BYT\n         SPACE 1\n*------- DYNAMIC ALLOCATION FIRST ATTEMPTS TO FREE DDNAME FINDMEDD.\n*        IF DDNAME FINDMEDD WAS SUCCESSFULLY FREED, THEN IT\n*        BRANCHES TO THE DYNAMIC ALLOCATION MACRO DYNALLOC.\n*        IF DDNAME FINDMEDD WAS NOT SUCCESSFULLY FREED, THEN IT\n*        CHECKS FOR ERROR REASON CODE 0438 (DDNAME NOT FOUND).\n*        IF THE ERROR REASON CODE IS 0438, THEN IT BRANCHES TO THE\n*        DYNAMIC ALLOCATION MACRO DYNALLOC, ELSE IT PRODUCES AN\n*        ERROR CONDITION (SUCCESS-INDICATOR = '24')\n         SPACE 1\nALLOCT   LA    R1,FREEPARM\n         LA    R3,FREERB\n         STCM  R3,B'0111',FREEARB\n         LA    R3,FREETUPL\n         STCM  R3,B'1111',FREATUPL\n         LA    R3,FREEUNT1\n         STCM  R3,B'1111',FREETUPL\n         LA    R3,FREEUNT2\n         STCM  R3,B'0111',FREEUNT0\n        DYNALLOC ,                 FREE F(FINDMEDD)\n         LTR   R15,R15             TEST REGISTER 15 FOR ZERO\n         BZ    DODYNAM             BRANCH IF ZERO\n         CLC   ERCODE,=XL2'0438'   COMPARE ERROR REASON CODE\n*                                    AGAINST HEXADECIMAL 0438\n         BE    DODYNAM             BRANCH IF EQUAL\n         MVC   INDICATR,=CL2'24'   MOVE '24' TO SUCCESS-INDICATOR\n         LA    R10,24              MOVE 24 TO REGISTER 10\n         B     QUIT\nDODYNAM  LA    R1,DD1PARM\n         LA    R3,DD1RB\n         STCM  R3,B'0111',DD1ARB\n         LA    R3,DD1TUPL\n         STCM  R3,B'1111',DD1ATUPL\n         LA    R3,DD1UNIT1\n         STCM  R3,B'1111',DD1TUPL\n         LA    R3,DD1UNIT2\n         STCM  R3,B'1111',DD1TUPL+4\n         LA    R3,DD1UNIT3\n         STCM  R3,B'0111',DD1HIGH3+1\n         LA    R3,DD1UNIT4\n         STCM  R3,B'0111',DD1HIGH4+1\n         LA    R3,DD1UNIT5\n         STCM  R3,B'0111',DD1HIGH5+1\n         CLC   INVOL,=CL6'ABSENT'  WAS VOL SER PROVIDED ?\n         BE    DODYNAM1            BRANCH IF NOT\n         MVI   DD1HIGH3,X'00'\n         MVI   DD1HIGH4,X'00'\n         MVI   DD1HIGH5,X'80'\n         MVC   DD1VOLSR,INVOL\n         B     DODYNAM2\nDODYNAM1 MVI   DD1HIGH3,X'80'\n         MVI   DD1HIGH4,X'00'\n         MVI   DD1HIGH5,X'00'\nDODYNAM2 DYNALLOC ,                ALLOC F(FINDMEDD) DA(DSN) SHR\n         LTR   R15,R15             TEST REGISTER 15 FOR ZERO\n         BZ    DODYNX              BRANCH IF ZERO\n         MVC   INDICATR,=CL2'08'   MOVE '08' TO SUCCESS-INDICATOR\n         LA    R10,8               MOVE 8 TO REGISTER 10\n         B     QUIT\nDODYNX   LA    R3,PDSFILE\n         MVC   0(PDSFILL,R3),PDSFIL\n         LA    R1,OPNFILE\n         MVC   0(OPNFILL,R1),OPNFIL\n        OPEN   ((R3),(INPUT)),MF=(E,(1)) OPEN PDSFILE\n         USING IHADCB,R3\n         TM    DCBOFLGS,DCBOFOPN\n         BZ    OPNERR\n         DROP  R3\n         OI    SWITCH,FILOPEN      SAY FILE OPENED\n         SPACE 1\n*------- SEARCH THE DYNAMICALLY ALLOCATED PDS FOR THE GIVEN MEMBER.\n         SPACE 1\n         CLC   MEMBER,=CL8' '      IS MEMBER EQUAL TO 8 SPACES?\n         BNE   SRCHIT              BRANCH IF NOT\n         MVC   INDICATR,=CL2'16'   MOVE 16 TO SUCCESS-INDICATOR\n         LA    R10,16              MOVE 16 TO REGISTER 10\n         B     QUIT\nSRCHIT  FIND   PDSFILE,MEMBER,D    SEARCH DIRECTORY FOR MEMBER\n         ST    R15,SAVER15         PUT REG 15 CONTENTS INTO SAVER15\n         CLI   SAVER15+3,X'00'     CONDITION CODE 00?\n         BE    RC00                BRANCH IF YES\n         CLI   SAVER15+3,X'04'     CONDITION CODE 04?\n         BE    RC04                BRANCH IF YES\nOPNERR   MVC   INDICATR,=CL2'20'   MOVE 20 TO SUCCESS-INDICATOR\n         LA    R10,20              MOVE 20 TO REGISTER 10\n         B     QUIT\nRC04     MVC   INDICATR,=CL2'04'   MOVE 04 TO SUCCESS-INDICATOR\n         LA    R10,4               MOVE 4 TO REGISTER 10\n         B     QUIT\nRC00     MVC   INDICATR,=CL2'00'   MOVE 00 TO SUCCESS-INDICATOR\n         XR    R10,R10             MOVE 0 TO REGISTER 10\n         SPACE 1\n*------- END OF PROCESSING.\n         SPACE 1\nQUIT     L     R5,0(R2)\n         MVC   0(L'IOAREA,R5),IOAREA\n         TM    SWITCH,FILOPEN      WAS FILE OPENED?\n         BZ    LEAVE               BRANCH IF NOT\n         LA    R3,PDSFILE\n         LA    R1,CLSFILE\n         MVC   0(CLSFILL,R1),CLSFIL\n        CLOSE  ((R3)),MF=(E,(1))   CLOSE FILE\n         LA    R1,FREEPARM\n        DYNALLOC ,                 FREE F(FINDMEDD)\n         LTR   R15,R15             TEST REGISTER 15 FOR ZERO\n         BZ    LEAVE               BRANCH IF ZERO\n         MVC   INDICATR,=CL2'24'   MOVE '24' TO SUCCESS-INDICATOR\n         LA    R10,24              MOVE 24 TO REGISTER 10\nLEAVE   $XRET  CC=(R10),LV=WKLEN,TYPE=RENT\n         EJECT\n*------- DATA CONSTANTS.\n         SPACE 1\n        PRINT  NOGEN\nOPNFIL  OPEN   (*-*,(INPUT)),MF=L\nOPNFILL  EQU   *-OPNFIL\nCLSFIL  CLOSE  (*-*),MF=L\nCLSFILL  EQU   *-CLSFIL\nPDSFIL  DCB    DDNAME=FINDMEDD,DSORG=PO,MACRF=(R)\nPDSFILL  EQU   *-PDSFIL\n        PRINT  GEN\nFREELST  DS    0F\n         DC    XL1'80'       TURN ON HIGH ORDER BIT\n         DC    AL3(*-*)      ADDRESS OF REQUEST BLOCK\n         DC    AL1(S99RBEND-S99RB) S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    AL1(S99VRBUN) S99VERB (REQUEST FOR UNALLOCATION)\n         DC    AL1(S99NOMNT,0) S99FLG11 (DO NOT MOUNT VOLUMES)\n         DC    XL2'0'        S99ERROR (ERROR REASON CODE)\n         DC    XL2'0'        S99INFO (INFORMATION REASON CODE)\n         DC    A(*-*)        S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DC    XL4'0'        RESERVED\n         DC    XL4'0'        S99FLAG2\n         DC    A(*-*)        ADDRESS OF TEXT UNIT #1\n         DC    XL1'80'       TURN ON HIGH ORDER BIT\n         DC    AL3(*-*)      ADDRESS OF TEXT UNIT #2\n         DC    AL2(DUNDDNAM),XL2'0001',XL2'0008',CL8'FINDMEDD'\n         DC    AL2(DUNUNALC),XL2'0'\nFREELL   EQU   *-FREELST\nDD1LST   DS    0F\n         DC    XL1'80'       TURN ON HIGH ORDER BIT\n         DC    AL3(*-*)      ADDRESS OF REQUEST BLOCK\n         DC    AL1(S99RBEND-S99RB) S99RBLN (LENGTH OF REQUEST BLOCK)\n         DC    AL1(S99VRBAL) S99VERB (REQUEST FOR DSNAME ALLOC)\n         DC    AL1(S99NOMNT,0) S99FLG11 (DO NOT MOUNT VOLUMES)\n         DC    XL2'0'        S99ERROR (ERROR REASON CODE)\n         DC    XL2'0'        S99INFO (INFORMATION REASON CODE)\n         DC    A(*-*)        S99TXTPP (ADDR OF POINTERS TO TEXT UNITS\n         DC    XL4'0'        RESERVED\n         DC    XL4'0'        S99FLAG2\n         DC    A(*-*)        ADDRESS OF TEXT UNIT #1\n         DC    A(*-*)        ADDRESS OF TEXT UNIT #2\n         DC    XL1'0'\n         DC    AL3(*-*)      ADDRESS OF TEXT UNIT #3\n         DC    XL1'0'\n         DC    AL3(*-*)      ADDRESS OF TEXT UNIT #4\n         DC    XL1'0'\n         DC    AL3(*-*)      ADDRESS OF TEXT UNIT #5\n         DC    AL2(DALDDNAM),XL2'0001',XL2'0008',CL8'FINDMEDD'\n         DC    AL2(DALDSNAM),XL2'0001',BL2'0',CL44' '\n         DC    AL2(DALSTATS),XL2'0001',XL2'0001',XL1'08'\n         DC    AL2(DALUNIT),XL2'0001',XL2'0008',CL8'SYSALLDA'\n         DC    AL2(DALVLSER),XL2'0001',XL2'0006',CL6' '\nDD1LL    EQU   *-DD1LST\n         SPACE 1\n        LTORG\n         EJECT\nWKAREA   DSECT\n         DS    18F                 SAVE AREA\nSAVER15  DS    F\n         SPACE 1\n        PRINT  NOGEN\nOPNFILE OPEN   (*-*,(INPUT)),MF=L\nCLSFILE CLOSE  (*-*),MF=L\n        PRINT  GEN\nPDSFILE  DS    (PDSFILL)X          DCB FOR DYNAMICALLY ALLOCATED PDS\n         SPACE 1\n*------- DATA STRUCTURE FOR FREEING OF DDNAME FINDMEDD.\n         SPACE 1\n         DS    0F\nFREEPARM DS    XL1\nFREEARB  DS    AL3           ADDRESS OF REQUEST BLOCK\nFREERB   DS    XL1           S99RBLN (LENGTH OF REQUEST BLOCK)\n         DS    XL1           S99VERB (REQUEST FOR UNALLOCATION)\n         DS    XL2           S99FLAG1 (DO NOT MOUNT VOLUMES)\nERCODE   DS    XL2           S99ERROR (ERROR REASON CODE)\n         DS    XL2           S99INFO (INFORMATION REASON CODE)\nFREATUPL DS    A             S99TXTPP (ADDR OF POINTER TO TEXT UNIT)\n         DS    XL4           RESERVED\n         DS    XL4           S99FLAG2\nFREETUPL DS    A             ADDRESS OF TEXT UNIT #1\n         DS    XL1\nFREEUNT0 DS    AL3           ADDRESS OF TEXT UNIT #2\nFREEUNT1 DS    XL2,XL2,XL2,CL8\nFREEUNT2 DS    XL2,XL2\n         SPACE 1\n*------- DATA STRUCTURE FOR DYNAMIC ALLOCATION.\n         SPACE 1\n         DS    0F\nDD1PARM  DS    XL1\nDD1ARB   DS    AL3           ADDRESS OF REQUEST BLOCK\nDD1RB    DS    XL1           S99RBLN (LENGTH OF REQUEST BLOCK)\n         DS    XL1           S99VERB (REQUEST FOR DSNAME ALLOC)\n         DS    XL2           S99FLAG1 (DO NOT MOUNT VOLUMES)\n         DS    XL2           S99ERROR (ERROR REASON CODE)\n         DS    XL2           S99INFO (INFORMATION REASON CODE)\nDD1ATUPL DS    A             S99TXTPP (ADDR OF POINTERS TO TEXT UNITS\n         DS    XL4           RESERVED\n         DS    XL4           S99FLAG2\nDD1TUPL  DS    A             ADDRESS OF TEXT UNIT #1\n         DS    A             ADDRESS OF TEXT UNIT #2\nDD1HIGH3 DS    XL1\n         DS    AL3           ADDRESS OF TEXT UNIT #3\nDD1HIGH4 DS    XL1\n         DS    AL3           ADDRESS OF TEXT UNIT #4\nDD1HIGH5 DS    XL1\n         DS    AL3           ADDRESS OF TEXT UNIT #5\nDD1UNIT1 DS    XL2,XL2,XL2,CL8\nDD1UNIT2 DS    XL2,XL2\nDSNLEN   DS    BL2\nDSNAME   DS    CL44\nDD1UNIT3 DS    XL2,XL2,XL2,XL1\nDD1UNIT4 DS    XL2,XL2,XL2,CL8\nDD1UNIT5 DS    XL2,XL2,XL2\nDD1VOLSR DS    CL6\n         SPACE 1\n         DS    0F\nIOAREA   DS    0CL56 - - - - - - - +\n         DS    XL2                 +\nMEMBER   DS    CL8                 +\nDSN      DS    CL44                +\nINDICATR DS    CL2                 + - BREAKDOWN OF IOAREA\n         SPACE 1\nINVOL    DS    CL6\nEDITBYTE DS    CL1\nSWITCH   DS    XL1\nFILOPEN  EQU   X'80'\n         SPACE 1\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8\n         SPACE 1\n        PRINT  NOGEN\n        DCBD   DEVD=DA,DSORG=PO\n        IEFZB4D0\n        IEFZB4D2\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDMEM$": {"ttr": 16139, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14\\x17\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:17:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//FINDMEM  JOB (........),'INSTALL  - FINDMEM -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=FINDMEM\n//LNK     EXEC PAJILKR,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   FINDMEM\n  NAME    FINDMEM(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDMEM@": {"ttr": 16141, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14\"\\x00?\\x00?\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:22:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/07/90\n                                                      FINDMEM   1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           FINDMEM ROUTINE           * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n  Routine :      FINDMEM\n  Author :       Jeff Sprehn\n  Agency :       WDPSC\n  Origin :       Extracted from tape CBT 89 FEB, file 270\n  Language :     Assembler\n  Run mode :     Batch or Interactive\n  Attributes :   Re-enterable\n  Function :     Subroutine to be called by high level language\n                 program to determine whether a specified member\n                 exists in a given PDS data-set.\n\n  This is a subroutine which dynamically allocates the DSN passed to\n  it and then searches the directory to determine whether the member\n  name passed to it exists or not.\n\n  To call this routine from a COBOL program, do the following :\n       1. If your data-set is cataloged :\n          MOVE your data-set name\n               TO DSNAME OF FINDMEM-I-O-AREA.\n          MOVE your member name\n               TO MEMBER-NAME OF FINDMEM-I-O-AREA.\n          CALL 'FINDMEM' USING FINDMEM-I-O-AREA.\n       2. If your data-set is NOT cataloged :\n          MOVE your data-set name\n               TO DSNAME OF FINDMEM-I-O-AREA.\n          MOVE your member name\n               TO MEMBER-NAME OF FINDMEM-I-O-AREA.\n          MOVE your volume serial number\n               TO VOL-SER-NO.\n          CALL 'FINDMEM' USING FINDMEM-I-O-AREA\n                               VOL-SER-NO.\n       Place the following data areas in WORKING STORAGE :\n          01  FINDMEM-I-O-AREA.\n              05  OP-SYS VALUE 'VS'   PIC X(2).\n              05  MEMBER-NAME         PIC X(8).\n              05  DSNAME              PIC X(44).\n              05  SUCCESS-INDICATOR   PIC 99.\n          01  VOL-SER-NO     PIC X(6).\n1   10/07/90\n                                                      FINDMEM   2/2.\n\n  SUCCESS-INDICATOR   MEANING\n  -----------------   -----------------------------------------\n         00           Successful allocation and find\n         04           Successfully allocated file but couldn't\n                        find member in directory\n         08           Unsuccessful allocation\n         12           DSN passed to this routine is spaces\n         16           Member name passed is spaces\n         20           I/O error reading directory\n         24           Unsuccessful free of DDNAME FINDMEDD\n         28           Invalid volume serial number passed to\n                        this routine\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FIXJCL": {"ttr": 16385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x179\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T17:39:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM) NOPROCESS\n/*  MACRO NAME : FIXJCL                                             */\n/*    FUNCTION : ALIGN JCL JOB, EXEC, AND DD STATEMENTS ON          */\n/*               STANDARD BOUNDARIES.                               */\n/*               T. M. HANES, ASYST INC. 02/01/88                   */\n/*               D.E.M.I., 03/01/88                                 */\n/*      SYNTAX : FIXJCL                                             */\n/*               FIXJCL HELP OR H                                   */\n/*       DEBUG : FIXJCL LIST                                        */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n/*      UPDATE : SOME CHANGED FROM ORIGINAL (MOINIL P.A.)           */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(H) OR +\n      &STR(&APARM.) = &STR(HELP) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTFJCL)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    ELSE IF &STR(&APARM.) \u00ac= &STR(LIST) THEN DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n/*               SITE DEPENDENT DEFINITIONS :                       */\n/*               ALIGNMENT COLUMNS FOR CARD TYPES                   */\n  SET &JOBC = 12\n  SET &PROCC = 11\n  SET &PENDC = 11\n  SET &DDC = 13\n  SET &EXECC = 11\n  SET &CONTC = 16\n  IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST SYMLIST CONLIST\n/*               PRESERVE CONTINUATION CHARACTERS IN 72             */\n  ISREDIT PROCESS RANGE C\n  IF &LASTCC = 0 THEN DO\n     ISREDIT (RCMD) = RANGE_CMD\n     ISREDIT (JZF) = LINENUM .ZFRANGE\n     ISREDIT (JZL) = LINENUM .ZLRANGE\n     END\n  ELSE DO\n     ISREDIT (JZF) = LINENUM .ZFIRST\n     ISREDIT (JZL) = LINENUM .ZLAST\n     END\n  ISREDIT LABEL &JZF = .JZF\n  ISREDIT LABEL &JZL = .JZL\n  SET &LJZF = &STR(.JZF)\n  SET &LJZL = &STR(.JZL)\n  IF &JZF  = &JZL THEN SET &LJZF = &STR(.JZL)\n  ISREDIT (CL,CR) = CURSOR\n  ISREDIT (LB,RB) = BOUNDS\n  ISREDIT BOUNDS    = 1 71\n  ISREDIT X ALL\n  ISREDIT F '//'  1 ALL &LJZF &LJZL\n  ISREDIT X '//*' 1 ALL &LJZF &LJZL\n  ISREDIT X '/*'  1 ALL &LJZF &LJZL\n/*               REMOVE EXTRA SPACES                                */\n  ISREDIT C ' ' '{'      3 71 ALL NX  &LJZF &LJZL\n  ISREDIT C '{{{{{{' '{' 3 71 ALL NX  &LJZF &LJZL\n  ISREDIT C '{{{{{' '{'  3 71 ALL NX  &LJZF &LJZL\n  ISREDIT C '{{{{' '{'   3 71 ALL NX  &LJZF &LJZL\n  ISREDIT C '{{{' '{'    3 71 ALL NX  &LJZF &LJZL\n  ISREDIT C '{{' '{'     3 71 ALL NX  &LJZF &LJZL\n  ISREDIT C '{' ' '      3 71 ALL NX  &LJZF &LJZL\n/*               JOB, PROC, EXEC, DD AND PEND CONVERSION            */\n  SET &KEYWD = &STR(JOB)\n  SET &FLD=&JOBC-2\n  DO WHILE &KEYWD NE &STR()\n    ISREDIT X ALL\n    ISREDIT F ' &STR(&KEYWD) ' 3 25 ALL                &LJZF &LJZL\n    IF &LASTCC=4 THEN GOTO BYEDT\n    ISREDIT X '//*' 1 ALL                              &LJZF &LJZL\n    ISREDIT C ' &STR(&KEYWD) ' '{&STR(&KEYWD)}' ALL NX &LJZF &LJZL\n    ISREDIT C '{' '{{' 3 25 ALL NX                     &LJZF &LJZL\n    ISREDIT C '{' '{{' 3 25 ALL NX                     &LJZF &LJZL\n    ISREDIT C '{' '{{' 3 25 ALL NX                     &LJZF &LJZL\n    ISREDIT C '{' '{{' 3 25 ALL NX                     &LJZF &LJZL\n    ISREDIT C '{&STR(&KEYWD)}' '_&STR(&KEYWD)_' ALL NX &LJZF &LJZL\n    ISREDIT C ' ' '\u00ac' ALL NX                           &LJZF &LJZL\n    ISREDIT C '{' ' ' 3 &FLD ALL NX                    &LJZF &LJZL\n    ISREDIT C '{' '' ALL NX                            &LJZF &LJZL\n    ISREDIT C '_&STR(&KEYWD)_' ' &STR(&KEYWD) ' ALL    &LJZF &LJZL\n    ISREDIT C '\u00ac' ' ' ALL NX                           &LJZF &LJZL\nBYEDT: IF &KEYWD = DD   THEN DO\n          SET &KEYWD = &STR()\n          END\n    IF &KEYWD = PEND THEN DO\n       SET &KEYWD = &STR(DD)\n       SET &FLD=&DDC-2\n       END\n    IF &KEYWD = EXEC THEN DO\n       SET &KEYWD = &STR(PEND)\n       SET &FLD=&PENDC-2\n       END\n    IF &KEYWD = PROC THEN DO\n       SET &KEYWD = &STR(EXEC)\n       SET &FLD=&EXECC-2\n       END\n    IF &KEYWD = JOB  THEN DO\n       SET &KEYWD = &STR(PROC)\n       SET &FLD=&PROCC-2\n       END\n    END\n/*               CONTINUATION CARD CONVERSION                       */\n  SET &FLD=&CONTC-1\n  ISREDIT X ALL\n  ISREDIT F '// '  1 ALL                             &LJZF &LJZL\n  ISREDIT X ' EXEC ' 3 20 ALL                        &LJZF &LJZL\n  ISREDIT X ' DD '   3 20 ALL                        &LJZF &LJZL\n  ISREDIT X ' PEND ' 3 20 ALL                        &LJZF &LJZL\n  ISREDIT C ' ' '}'  3 ALL NX                        &LJZF &LJZL\n  ISREDIT C '}' '}}' 3 25 ALL NX                     &LJZF &LJZL\n  ISREDIT C '}' '}}' 3 25 ALL NX                     &LJZF &LJZL\n  ISREDIT C '}' '}}' 3 25 ALL NX                     &LJZF &LJZL\n  ISREDIT C '}' '}}' 3 25 ALL NX                     &LJZF &LJZL\n  ISREDIT C '}' '}}' 3 25 ALL NX                     &LJZF &LJZL\n  ISREDIT C ' ' '\u00ac'  3 70 ALL NX                     &LJZF &LJZL\n  ISREDIT C '}\u00ac' '}' 3 70 ALL NX                     &LJZF &LJZL\n  ISREDIT C '}' ' '  3 &FLD ALL NX                   &LJZF &LJZL\n  ISREDIT C '}' ''        ALL NX                     &LJZF &LJZL\n  ISREDIT C '\u00ac' ' '       ALL NX                     &LJZF &LJZL\n  ISREDIT BOUNDS =  &LB &RB\n  ISREDIT LEFT MAX\n  ISREDIT RESET\n  ISREDIT CURSOR = &CL &CR\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FIXJCL@": {"ttr": 16388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11W\\x00+\\x00+\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:57:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "SYSPAJA"}, "text": "1   07/08/89\n                                                      FIXJCL    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    FIXJCL ISPF/PDF EDIT command     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to tidy up JCL (standard\n  ----------   columns).\n\n  Command syntax : FIXJCL (with eventual use of \"C\" range command on\n  ----------------        line numbers)\n                   FIXJCL HELP or H\n\n  Use :        Type FIXJCL on the COMMAND line.\n  -----        In example, the following JCL statements :\n                 000100 //SAMPLE JOB (12341234),'SAMPLE TEST',\n                 000200 //       MSGCLASS=X,REGION=2048K\n                 000300 //TEST EXEC PGM=IEFBR14\n                 000400 //DD1    DD   DSN=USER.DATASET,DISP=OLD\n               will be changed as follows :\n                 000100 //SAMPLE   JOB (12341234),'SAMPLE TEST',\n                 000200 //             MSGCLASS=X,REGION=2048K\n                 000300 //TEST    EXEC PGM=IEFBR14\n                 000400 //DD1       DD DSN=USER.DATASET,DISP=OLD\n\n Range use :   Type FIXJCL on the COMMAND line and mark a range of\n -----------   process with the \"C\" range command on the line numbers,\n               as i.e. :\n               COMMAND ===> FIXJCL\n                 000100 //SAMPLE JOB (12341234),'SAMPLE TEST',\n                 000200 //       MSGCLASS=X,REGION=2048K\n            ---> C2 300 //TEST EXEC PGM=IEFBR14\n                 000400 //DD1    DD   DSN=USER.DATASET,DISP=OLD\n                 000500 //DD2 DD DSN=OTHER.DATASET,DISP=OLD\n               will be changed as follows :\n                 000100 //SAMPLE JOB (12341234),'SAMPLE TEST',\n                 000200 //       MSGCLASS=X,REGION=2048K\n                 000300 //TEST    EXEC PGM=IEFBR14\n                 000400 //DD1       DD DSN=USER.DATASET,DISP=OLD\n                 000500 //DD2 DD DSN=OTHER.DATASET,DISP=OLD\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLOWJCL": {"ttr": 16390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x10!\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T10:21:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM)\n/*  MACRO NAME : FLOWJCL                                            */\n/*    FUNCTION : REFORMAT ALL JCL DD STATEMENTS WITH ONE PARAMETER  */\n/*               BY LINE                                            */\n/*      SYNTAX : FLOWJCL                                            */\n/*               FLOWJCL HELP OR H                                  */\n/*      AUTHOR : MOINIL P.A                                         */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(HELP) OR +\n      &STR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTFLWJ)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ISREDIT !JCLFLOW\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FLOWJCL@": {"ttr": 16392, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\"\\x1f\\x00\\x89\"\\x1f\\x117\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-09T00:00:00", "modifydate": "1989-08-09T11:37:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "1   09/08/89\n                                                      FLOWJCL   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    FLOWJCL ISPF/PDF EDIT command    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro allows all the JCL DD statements to be\n  ----------   reformatted with one parameter by line.\n\n  Operation :  starting at the top of the data, all DD statements are\n  -----------  reformatted by beeing copied one parameter at a time\n               (new lines are inserted into the data to contain all\n               the reformatted DD statements). Anything other than\n               part of a DD statement is left as is.\n\n  Command syntax : FLOWJCL\n  ---------------- FLOWJCL HELP or H\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FSPACE": {"ttr": 16394, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07O\\x00\\x95\\x07O\\x16$\\x02H\\x02H\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-15T00:00:00", "modifydate": "1995-03-15T16:24:00", "lines": 584, "newlines": 584, "modlines": 0, "user": "SYSPAJA"}, "text": "TFSC     TITLE 'TSO FREE SPACE COMMAND.'\nFSPACE   START 0\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* * * * * * * * * * *                             * * * * * * * * * * *\n* * * * * * * * * * *   FREE SPACE INFORMATIONS   * * * * * * * * * * *\n* * * * * * * * * * *                             * * * * * * * * * * *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* PURPOSE :    THIS COMMAND INFORMS ABOUT THE FREE SPACE EXTENTS\n* ---------    ON ANY VOLUME(S) ATTACHED TO THE SYSTEM.\n*\n* COMMAND :    SYNTAX : FSPACE VOLUME OPTION\n* ---------    DEFAULT : VOLUME - ONLY COMMON VOLUME(S).\n*                        OPTION - NOLIST (LIST : UNDER REQUEST).\n*                                 SHORT FORM : NL OR L.\n*\n* AUTHOR :     DAOLIO C. AND MOINIL P.A.\n* --------     COMPUTING CENTRE (TP 361)\n*              J.R.C. - ISPRA ESTABLISHMENT.\n*              21020 ISPRA (VA), ITALY\n*\n*              12.01.1993 : ADAPTED TO INDEXED VTOC (MOINIL P.A.)\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nLV14     EQU   14        SYSTEM LEVEL.\nLV12     EQU   12        OPERATORS LEVEL.\nLV10     EQU   10        SUPPORT LEVEL.\nLV8      EQU   8         SELECTED USERS LEVEL.\nLV0      EQU   0         COMMON USERS LEVEL.\n         SPACE 1\n        $MDL@IX\n         EJECT\n        $DEFREG\n        $XENT  BASE=(R11,R12),LV=WRKL,TYPE=RENT\n         EJECT\n*------- RECOGNIZE ENVIRONMENT.\n         SPACE 1\n         LR    R10,R13             SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R10\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n         XC    AUTH(REQAUTL),AUTH\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n         MVC   REQAUT+1(3),=AL3(MDL@IX)\n        $EACM  REQAUT\n         SPACE 1\n*------- SET INDEXED VTOC LIST.\n         SPACE 1\n         MVC   CVPL(CVPLNGTH),CVPLP\n         LA    R0,KF5+1            NUMBER OF EXTENTS IN TABLE.\n         STC   R0,EXTABL\n         LA    R0,EXTABL           EXTENT TABLE ADDRESS.\n         ST    R0,CVEXTS\n         SPACE 1\n*------- SET CAMLST PARAMETER LIST FOR OBTAIN.\n         SPACE 1\n         MVC   CAMSR(LCAMSR),CAMSRP\n         MVC   CAMSK(LCAMSK),CAMSKP\n         LA    R1,VOLUME\n         ST    R1,CAMSR+8\n         ST    R1,CAMSK+8\n         LA    R1,DATAAREA\n         ST    R1,CAMSR+12\n         ST    R1,CAMSK+12\n         LA    R1,VTDSNM\n         ST    R1,CAMSR+4\n         LA    R1,CCHHR\n         ST    R1,CAMSK+4\n         SPACE 1\n*------- SET DEFAULTS.\n         SPACE 1\n         MVC   VOLNUM(L'DEFLT),DEFLT\n         MVI   VOLSL,L'DEFLT-1\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVI   SWOP,0\n         SPACE 1\n*------- SET UCB LOOK-UP PARAMETER LIST.\n         SPACE 1\n         XC    WRKTAB,WRKTAB\n         XC    ADDRUCB,ADDRUCB\n         LA    R1,WRKTAB\n         ST    R1,PARMLIST\n         LA    R1,DEVCL\n         ST    R1,PARMLIST+4\n         LA    R1,ADDRUCB\n         ST    R1,PARMLIST+8\n         OI    PARMLIST+8,X'80'\n         MVI   DEVCL,UCB3DACC\n         SPACE 1\n        $TEW$PP PARM=PARMLST,REG=R3\n         TM    VOLSER+6,X'80'      IS VOLUME SUPPLIED ?\n         BZ    NOVOL               NO, USE DEFAULT.\n         L     R1,VOLSER           GET POINTER TO VOLUME.\n         LH    R2,VOLSER+4         GET LENGTH.\n         BCTR  R2,0                REDUCE BY ONE FOR MACHINE INSTR.\n         STC   R2,VOLSL\n         EX    R2,*+L'*+4          VOLUME SERIAL NUMBER.\n         B     TLST\n         MVC   VOLNUM(*-*),0(R1)   <<EXECUTED>>\nNOVOL    MVI   AUTH,LV0            SET COMMON LEVEL.\nTLST     LH    R1,OPLIST           LIST/NOLIST OPTION.\n         LTR   R1,R1\n         BZ    NOOPT\n         BCT   R1,NOOPT\n         OI    SWOP,LIST\n         DROP  R3\nNOOPT   IKJRLSA #TSANSW\n         EJECT\n*------- SEARCH VOLUME(S).\n         SPACE 1\nNEXT     XR    R5,R5\n         IC    R5,VOLSL\n         L     R4,CVTPTR           GET CVT POINTER.\n         USING CVT,R4\n         BASR  R3,0                ESTABLISH LOOP ADDRESS.\n         LA    R1,PARMLIST         SET PARAMETER LIST ADDRESS.\n         L     R15,CVTUCBSC        GET SCAN SERVICE ADDRESS.\n         BASR  R14,R15             GO TO SCAN SERVICE (R13=SA).\n         LTR   R15,R15             HAS A UCB BEEN RETURNED ?\n         BNZ   ENDSRC              BRANCH IF END, NOT FOUND.\n         L     R2,ADDRUCB          GET UCB ADDRESS.\n         USING UCBDSECT,R2\n         TM    UCBSTAT,UCBONLI     IS DEVICE ONLINE ?\n         BZR   R3                  IF NOT, GO TO NEXT.\n         TM    UCBFLA,UCBNOTRD     IS DEVICE NOT READY ?\n         BOR   R3                  IF YES, GO TO NEXT.\n         EX    R5,COMPV            LOOK VOLUME SERIAL NUMBER ?\n         BNER  R3                  IF NOT, GO TO NEXT.\n         SPACE 1\n*------- CONTROL REQUEST VALIDITY CHECK.\n         SPACE 1\n         L     R15,=A(RESTAB)\n         XR    R14,R14\nNXRES    CLI   0(R15),255          END OF TABLE ?\n         BE    CAUTH               YES, GO TO CHECK.\n         IC    R14,0(R15)\n         EX    R14,CHECK           IS IT THIS VOLUME SERIAL NUMBER ?\n         BE    CAUTH               YES, GO TO CHECK.\n         LA    R15,3(R14,R15)\n         B     NXRES\nCOMPV    CLC   VOLNUM(*-*),SRTEVOLI <<EXECUTED>>\nCHECK    CLC   2(*-*,R15),SRTEVOLI <<EXECUTED>>\nCAUTH    CLC   AUTH(1),1(R15)      AUTHORIZED ?\n         BLR   R3                  NO, GO TO NEXT.\n         EJECT\n*------- VOLUME INFORMATION.\n         SPACE 1\n         MVC   VOLUME,SRTEVOLI     SET VOLUME SERIAL NUMBER.\n         OI    SWOP,FOUND\n         L     R3,CVTZDTAB         ADDRESS OF IECZDTAB.\n         DROP  R4\n         LA    R3,0(0,R3)          IECZDTAB IS THE RESIDENT DIRECT\n         XR    R4,R4                    ACCESS DEVICE CONSTANT TABLE\n         LR    R1,R4                    (SEE ASSEMBLY OF IECZDTAB).\n         IC    R1,UCBTBYT4         GET DEVICE CODE.\n         DROP  R2\n         IC    R4,0(R1,R3)         PICK UP TABLE DISPLACEMENT.\n         ALR   R4,R3               DEVICE CONSTANT TABLE ADDRESS.\n         MVC   NTRCY(2),2(R4)      MOVE NUMBER OF TRACKS PER CYLINDER.\n         MVC   LINE(TITVL),TITM\n         MVC   LINE(L'VOLUME),VOLUME\n         LH    R7,NTRCY\n         CVD   R7,WORK\n         ED    LINE+L'TITM(L'TITV1),WORK+6\n         BAS   R9,SENDL\n         LA    R8,DATAAREA\n         USING DSCDSECT,R8\n         XC    DATAAREA(LDATA),DATAAREA\n         MVI   SWIX,0\n         LA    R1,PARMIX\n         MVC   0(4,R1),ADDRUCB\n         ST    R8,4(R1)\n         BAS   R14,IXF5            CHECK FOR INDEXED VTOC.\n         B     *+L'*(R15)          HOW COMPLETED ?\n         B     *+L'*+8                  0 = FMT5 OK.\n         B     *+L'*+12                 4 = NOT INDEXED VTOC.\n         B     IXERR                    8 = INDEXED VTOC ERROR.\n         OI    SWIX,IXVT                SAY INDEXED VTOC PRESENT.\n         B     TFMT5\n        OBTAIN CAMSR\n         LTR   R15,R15\n         BNZ   OBTERRV\n         MVC   CCHHR(L'CCHHR),DS4END    FORMAT 4 CCHHR.\n         XR    R1,R1\n         IC    R1,CCHHR+L'CCHHR-1\n         LA    R1,1(R1)            FORMAT 5 IS NEXT RECORD.\n         STC   R1,CCHHR+L'CCHHR-1\n         XC    DATAAREA(LDATA),DATAAREA\n        OBTAIN CAMSK\n         LTR   R15,R15\n         BNZ   OBTERRT\nTFMT5    CLI   DS5FMTID,C'5'       TEST IF DSCB'S FORMAT 5 ?\n         BNE   NOFMT5              BRANCH IF NOT.\n         CLC   DS5AVEXT(5),=XL5'0'\n         BE    NOSPVL              EMPTY FORMAT 5.\n         XC    TOTAL,TOTAL\n         XC    GREAT,GREAT\n         EJECT\n*------- FREE SPACE EXTENTS INFORMATION.\n         SPACE 1\nFMT5     LA    R2,DS5AVEXT         FORMAT 5 - FREE SPACE DSCB.\n         LA    R3,8                SET FIRST 8 EXTENTS POINTER.\nFMT5A    CLC   0(5,R2),=XL5'0'\n         BE    ENDFM5\n         BAS   R9,DECODE\n         LA    R2,L'DS5AVEXT(R2)\n         BCT   R3,FMT5A\n         LA    R2,DS5MAVET\n         LA    R3,18               SET LAST 18 EXTENTS POINTER.\nFMT5B    CLC   0(5,R2),=XL5'0'\n         BE    ENDFM5\n         BAS   R9,DECODE\n         LA    R2,L'DS5AVEXT(R2)\n         BCT   R3,FMT5B\n         OC    DS5PTRDS(L'DS5PTRDS),DS5PTRDS TEST IF NEXT F5 DSCB,\n         BZ    ENDFM5              BRANCH IF NOT.\n         TM    SWIX,IXVT           INDEXED VTOC PROCESS ?\n         BZ    FMT5C               NO\n         LA    R1,PARMIX           YES\n         BAS   R14,IXF5            GET NEXT FROM INDEXED VTOC.\n         B     *+L'*(R15)          HOW COMPLETED ?\n         B     FMT5T                    0 = FMT5 OK.\n         B     IXERR                    4 = NOT INDEXED VTOC.\n         B     IXERR                    8 = INDEXED VTOC ERROR.\nFMT5C    MVC   CCHHR(L'DS5PTRDS),DS5PTRDS    MOVE ADDRESS OF NEXT DSCB.\n         XC    DATAAREA(LDATA),DATAAREA\n        OBTAIN CAMSK\n         LTR   R15,R15             TEST CONDITION CODE,\n         BNZ   OBTERRT             BRANCH IF ERROR.\nFMT5T    CLI   DS5FMTID,C'5'       TEST IF DSCB'S FORMAT 5 ?\n         BNE   NOTFM5              BRANCH IF NOT.\n         CLC   DS5AVEXT(5),=XL5'0'\n         BNE   FMT5                BRANCH OK.\n         B     EMPFM5              EMPTY FORMAT 5.\n         DROP  R8\n         SPACE 1\nOBTERRT  LA    R1,=CL4'FMT5'\n         B     OBTERR\nOBTERRV  LA    R1,=CL4'VTOC'\nOBTERR   MVC   LINE(L'OBTM+L'OBTT+L'OBTCC),OBTM\n         MVC   LINE+L'OBTM(4),0(R1)\n         CVD   R15,WORK\n         UNPK  LINE+L'OBTM+L'OBTT(2),WORK+6(2)\n         OI    LINE+L'OBTM+L'OBTT+1,C'0'\n         BAS   R9,SENDL\n         B     NEXT\nIXERR    MVC   LINE(2),=CL2'--'\n         B     *(R15)\n         B     *+L'*+10                 = 4\n         MVC   LINE+2(7),=CL7'CVAFTST'  = 8\n         B     *+L'*+6\n         MVC   LINE+2(7),=CL7'CVAFDSM'\n         MVC   LINE+9(13),=CL13' error (SRC ='\n         UNPK  LINE+22(9),PARMIX+8(5)\n         TR    LINE+22(9),HXTAB-X'F0'\n         MVC   LINE+30(2),=CL2').'\n         BAS   R9,SENDL\n         B     NEXT\n         EJECT\n*------- FINAL INFORMATION.\n         SPACE 1\nENDFM5   MVC   LINE(L'GCEM+GCEVL),GCEM\n         L     R0,GREAT\n         CVD   R0,WORK             LARGEST EXTENT.\n         ED    LINE+L'GCEM(L'GCEV1),WORK+4\n         LH    R1,LAREXTC\n         CVD   R1,WORK\n         ED    LINE+L'GCEM+L'GCEV1+L'GCEV2(L'GCEV3),WORK+5\n         XR    R0,R0\n         IC    R0,LAREXTT\n         CVD   R0,WORK\n         ED    LINE+L'GCEM+GCEVL-L'GCEV6-L'GCEV5(L'GCEV5),WORK+6\n         BAS   R9,SENDL\n         MVC   LINE(L'TFSM+TFSVL),TFSM\n         L     R0,TOTAL\n         CVD   R0,WORK             TOTAL FREE SPACE FOR A VOLUME.\n         ED    LINE+L'TFSM(L'TFSV),WORK+4\n         BAS   R9,SENDL\n         B     NEXT\n         SPACE 1\nENDSRC   TM    SWOP,FOUND\n         BZ    NOTFND              BRANCH NO VOLUME(S) PROCESSED.\n         XR    R15,R15             SET RC=0 ---------------------------\nQUIT    $XRET  CC=(R15),LV=WRKL,TYPE=RENT\nSETRC    LA    R15,16              SET RC=16 --------------------------\n         B     QUIT\n         EJECT\n*------- IXF5 - SUPPLY FORMAT 5 FROM INDEXED VTOC ROUTINE.\n*        (REGISTERS R2-R9 AND R14 ARE SAVED/RESTORED BY ROUTINE)\n*              R14 : LINK REGISTER.\n*        PURPOSE : BUILD A FORMAT 5 DSCB IF AN INDEXED VTOC.\n* ON ENTRY --- R1 ---> A(PARM. ADDRESSES)\n*              PARM. +0 = UCB ADDRESS ---> R3\n*                    +4 = FORMAT 5 DSCB BUFFER ADDRESS ---> R4\n*                    +8 = SRC (SERVICE RETURN CODE)\n*              THE BUFFER CONTAINS THE LAST FORMAT 5 DSCB BUILT OR\n*                   ZERO'S IF FIRST CALL\n*              IF THE FORMAT 5 DSCB BUFFER RETURNED TO THE CALLER\n*                   HAS A NON-ZERO VALUE IN \"DS5PTRDS\", THIS ROUTINE\n*                   MUST BE CALLED AGAIN TO OBTAIN THE NEXT FORMAT\n*                   5 DSCB\n* ON EXIT ---- R15 = RETURN CODE\n*                    0 = OK, FORMAT 5 DSCB FROM INDEXED VTOC BUILDED\n*                    4 = TEST VTOC RESPONSE ERROR (SEE SRC)\n*                    8 = OBTAIN VTOC RESPONSE ERROR (SEE SRC)\n         SPACE 1\nKF5      EQU   26                  NUMBER OF FORMAT 5 EXTENTS.\n         SPACE 1\nIXF5     STM   R2,R9,SAVEREGS      SAVE CALLER'S REGS.\n         ST    R14,SAVEREGR\n         LR    R2,R1               RETAIN POINTER TO PARM.\n         LM    R3,R4,0(R2)         GET PARM. ADDRESS.\n         XC    8(4,R2),8(R2)       RESET SRC.\n         USING IECSDSF5,R4         ADDRESSABILITY TO FORMAT 5 BUFFER.\n        ZEROKEY ,                  ENTER SUPERVISOR MODE\n         SPACE 1\n*------- TEST VTOC.\n         SPACE 1\n        CVAFTST UCB=(R3)\n         CH    R15,=H'8'\n         BE    *+L'*+12\n         ST    R15,8(R2)           SET SRC (= 0, 4, 12 OR 16).\n         LA    R9,4                C.C. = 4.\n         B     XIXF5\n         SPACE 1\n*------- ASSUME INDEXED VTOC UNLESS NOT TRUE.\n*        MOVE LAST EXTENT FROM FORMAT 5 TO ENTRY IN THE EXTENT TABLE.\n         SPACE 1\n         MVC   EXTS(L'DS5AVEXT),DS5MAVET+L'DS5MAVET-L'DS5AVEXT\n        CVAFDSM MF=(E,CVPL),       GET 27 EXTENTS FROM CVPL.           X\n               UCB=(R3),           UCB ADDRESS.                        X\n               BRANCH=YES          BRANCH ENTRY CALL.\n         TM    CVFL1,CV1IVT        IS THIS INDEXED VTOC ?\n         BNZ   *+L'*+16            YES.\n         ICM   R15,B'1000',=XL1'0F' NO, SET SRC (= X'0F0000XX').\nUNERR    ST    R15,8(R2)           SET SRC.\n         LA    R9,8                C.C. = 8.\n         B     XIXF5\n         LTR   R15,R15             YES, ANY ERROR ?\n         BZ    *+L'*+16            NO, OK.\n         CH    R15,=H'4'\n         BNE   UNERR               UNEXPECTED, SRC = 8, 12 OR 16.\n         CLI   CVSTAT,STAT032      END OF DATA ?\n         BNE   UNERR               NO, UNEXPECTED, SRC = 4.\n         MVC   DS5KEYID,=XL4'05050505' YES, BUILD FORMAT 5.\n         MVC   DS5AVEXT(L'DS5AVEXT+L'DS5EXTAV),EXTS\n         MVI   DS5FMTID,C'5'\n         MVC   DS5MAVET,EXTS+L'DS5AVEXT+L'DS5EXTAV\n         XC    DS5PTRDS,DS5PTRDS   ZERO CHAIN POINTER.\n         NC    EXTS+L'EXTS-L'DS5AVEXT(L'DS5AVEXT),EXTS+L'EXTS-L'DS5AVEXX\n               T                   LAST(27TH) EXTENT FROM CVAF ZERO ?\n         BZ    *+L'*+4             YES, LEAVE DS5PTRDS ZERO.\n         MVI   DS5PTRDS+L'DS5PTRDS-1,1 SET NON-ZERO TO SAY ANOTHER.\n         DROP  R4\n         SPACE 1\n         XR    R9,R9               C.C. = 0.\nXIXF5   RESETKEY ,                 ENTER SUPERVISOR MODE\n         LR    R15,R9              SET IN PLACE C.C.\n         LM    R2,R9,SAVEREGS      RESTORE CALLER'S REGS.\n         L     R14,SAVEREGR\n         BR    R14                 RETURN TO CALLER.\n         EJECT\n*------- EXTENT FREE SPACE DISPLAY ROUTINE.\n*        THIS ROUTINE BUILDS IN 'LINE' AREA THE FREE SPACE\n*        INFORMATION WHICH IS DISPLAYED BY 'SENDL' ROUTINE,\n*        COMPUTES THE GREATEST CONTIGUOUS EXTENT AND THE\n*        TOTAL FREE SPACE.\n*              WORK REGISTERS = R0, R1.\n*              EXTENT POINTER = R2.\n*              LINK REGISTER = R9.\n         SPACE 1\nDECODE   MVC   LINE+L'EXTM(EXTVL),EXTV1\n         MVC   EXTENTC(L'EXTENTC+L'EXTENTT),2(R2)\n         XR    R0,R0\n         LH    R1,EXTENTC\n         CVD   R1,WORK\n         ED    LINE+L'EXTM+L'EXTV1+L'EXTV2(L'EXTV3),WORK+5\n         MR    R0,R7\n         XR    R0,R0\n         IC    R0,EXTENTT\n         CVD   R0,WORK\n         ED    LINE+L'EXTM+EXTVL-L'EXTV6-L'EXTV5(L'EXTV5),WORK+6\n         AR    R1,R0\n         CVD   R1,WORK\n         ED    LINE+L'EXTM(L'EXTV1),WORK+4\n         C     R1,GREAT\n         BNH   *+L'*+10\n         ST    R1,GREAT\n         MVC   LAREXTC(L'EXTENTC+L'EXTENTT),EXTENTC\n         A     R1,TOTAL\n         ST    R1,TOTAL\n         TM    SWOP,LIST           LIST OPTION REQUESTED ?\n         BZ    CLEAR               BRANCH IF NOT.\n         EJECT\n*------- COMMUNICATION WITH USER ROUTINE.\n*        AT ENTRY : THE MESSAGE TEXT IS PLACED IN 'LINE' AREA.\n*        AT EXIT : THE 'LINE' AREA IS BLANKS RESET.\n*              WORK REGISTERS = R0, R1, R14, R15.\n*              LINK REGISTER = R9.\n         SPACE 1\nSENDL    LA    R1,LINE\n         LA    R15,L'LINE-1(R1)\n         CLI   0(R15),C' '\n         BNE   *+L'*+10\n         CLR   R1,R15\n         BE    *+L'*+4\n         BCT   R15,*-14\n         SR    R15,R1\n         BZR   R9\n         LA    R0,1(,R15)\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     CLEAR               +0 - CONTINUE\n         B     SETRC               +4 - ERROR\nCLEAR    MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         BR    R9\n         EJECT\n*------- DIAGNOSTIC'S MESSAGES.\n         SPACE 1\nNOTFND   LA    R1,=CL34' -> Requested Volume(s) not found.'\n         LA    R0,34\n         BAS   R14,PUTLNE\n         B     SETRC\nNOFMT5   LA    R1,=CL29' -> No Format 5 DSCB in VTOC.'\n         LA    R0,29\n         B     SENDM\nNOSPVL   LA    R1,=CL33' -> No space available on Volume.'\n         LA    R0,33\n         B     SENDM\nNOTFM5   LA    R1,=CL24' -> Wrong Format 5 DSCB.'\n         LA    R0,24\n         B     SENDM\nEMPFM5   LA    R1,=CL24' -> Empty Format 5 DSCB.'\n         LA    R0,24\nSENDM    BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     NEXT                +0 - CONTINUE\n         B     SETRC               +4 - ERROR\n         EJECT\n*------- INTERNAL LOCAL CONSTANTS.\n         SPACE 1\nCAMSRP  CAMLST SEARCH,*-*,*-*,*-*\n         SPACE 1\nCAMSKP  CAMLST SEEK,*-*,*-*,*-*\n         SPACE 1\nCVPLP   CVAFDSM ACCESS=MAPDATA,                                        X\n               COUNT=NO,           DO NOT COUNT EXTENTS.               X\n               MAP=VOLUME,         ACCESS VOLUME SPACE MAP.            X\n               EXTENTS=*-*,        EXTENT TABLE ADDRESS.               X\n               MF=L\n         EJECT\nVTDSNM   DC    0XL44'0',44X'04'\nDEFLT    DC    C'USER'\nHXTAB    DC    CL16'0123456789ABCDEF'\n         SPACE 1\nOBTM     DC    C' -> OBTAIN ('\nOBTT     DC    C'    ) error(CC='\nOBTCC    DC    C'  ).'\n         SPACE 1\nTITM     DC    C'       : 1 cyl ='\nTITV1    DC    X'40202120',C' trks.'\nTITVL    EQU   *-TITM\nEXTM     DC    C'         Extent(s) :'\nEXTV1    DC    X'4020202020202120'\nEXTV2    DC    C' tracks ('\nEXTV3    DC    X'402020202120'\nEXTV4    DC    C' cyls,'\nEXTV5    DC    X'40202120'\nEXTV6    DC    C' trks)'\nEXTVL    EQU   *-EXTV1\nTFSM     DC    C'         Total free space ='\nTFSV     DC    X'4020202020202120',C' tracks'\nTFSVL    EQU   *-TFSV\nGCEM     DC    C'         Largest continuous extent ='\nGCEV1    DC    X'4020202020202120'\nGCEV2    DC    C' tracks ('\nGCEV3    DC    X'402020202120'\nGCEV4    DC    C' cyls,'\nGCEV5    DC    X'40202120'\nGCEV6    DC    C' trks)'\nGCEVL    EQU   *-GCEV1\n         SPACE 1\n        LTORG\n         EJECT\n*------- VOLUME SERIAL NUMBERS AUTHORITY TABLE.\n*        (MUST BE ORDERED BY ASCENDING LEVELS)\n         SPACE 1\nRESTAB   EQU   *                   START OF TABLE.\n         DC    AL1(L'VSN1-1,LV0)\nVSN1     DC    C'USER00'\n         DC    AL1(L'VSN2-1,LV0)\nVSN2     DC    C'USER01'\n         DC    AL1(L'VSN3-1,LV8)\nVSN3     DC    C'CLIB'\n         DC    AL1(L'VSN4-1,LV8)\nVSN4     DC    C'USER'\n         DC    AL1(255,LV14)       END OF TABLE INDICATOR.\n         EJECT\nPARMLST IKJPARM\nVOLSER  IKJIDENT 'VOLUME',MAXLNTH=6,FIRST=ALPHA,OTHER=ALPHANUM\nOPLIST  IKJKEYWD\n        IKJNAME  'LIST',ALIAS=('L')\n        IKJNAME  'NOLIST',ALIAS=('NL')\n        IKJENDP\n         EJECT\nWRKDSECT DSECT                     WORK AREAS DESCRIPTION.\n         SPACE 1\nSVA      DS    18F                 SAVE AREA.\nSAVEREGS DS    9F                  SAVE REGS R2-R9 FOR IXF5.\nSAVEREGR DS    F                   SAVE REG R14 FOR IXF5.\n         SPACE 1\nCAMSR   CAMLST SEARCH,*-*,*-*,*-*  CAMLST PARAMETER LISTS FOR OBTAIN.\nLCAMSR   EQU   *-CAMSR\n         SPACE 1\nCAMSK   CAMLST SEEK,*-*,*-*,*-*\nLCAMSK   EQU   *-CAMSK\n         SPACE 1\nWORK     DS    D\nDATAAREA DS    XL150\nLDATA    EQU   *-DATAAREA\nVOLUME   DS    CL6\n         SPACE 1\n         DS    0D                  DOUBLE WORD BOUNDARY NEEDED.\nWRKTAB   DS    XL100\nADDRUCB  DS    F\nPARMLIST DS    3F\n         SPACE 1\nTOTAL    DS    F\nGREAT    DS    F\nNTRCY    DS    H\n         SPACE 1\nVOLNUM   DS    CL6\nCCHHR    DS    XL5\nSWOP     DS    XL1\nLIST     EQU   X'01'               LIST/NOLIST OPTION.\nFOUND    EQU   X'02'               AT LEAST ONE VOLUME PROCESSED.\nEXTENTC  DS    H\nEXTENTT  DS    XL1\nSWIX     DS    XL1\nIXVT     EQU   X'01'               VOLUME HAS INDEXED VTOC.\nLAREXTC  DS    H\nLAREXTT  DS    XL1\nVOLSL    DS    XL1\nDEVCL    DS    XL1\nAUTH     DS    XL1\nREQAUT   DS    2F\nREQAUTL  EQU   *-AUTH\n         SPACE 1\n        $TEW$WA\n         SPACE 1\nLINE     DS    CL80\n         SPACE 1\nPARMIX   DS    A                   UCB ADDRESS\n         DS    A                   FORMAT 5 DSCB BUFFER ADDRESS\n         DS    A                   SRC (SERVICE RETURN CODE)\nEXTABL   DS    0CL(1+(KF5+1)*L'DS5AVEXT) EXTENT TABLE.\n         DS    AL1                 NUMBER OF EXTENTS IN TABLE.\nEXTS     DS    CL((KF5+1)*L'DS5AVEXT) EXTENTS\nCVPL    CVAFDSM ACCESS=MAPDATA,                                        X\n               COUNT=NO,           DO NOT COUNT EXTENTS.               X\n               MAP=VOLUME,         ACCESS VOLUME SPACE MAP.            X\n               EXTENTS=*-*,        EXTENT TABLE ADDRESS.               X\n               MF=L\n         ORG   CVPL                OVERLAY CVPL WITH EXPANSION OF MAP.\nCVPLMAP ICVAFPL DSECT=NO\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         EJECT\n        PRINT  NOGEN\nUCBDSECT DSECT\n        IEFUCBOB\nDSCDSECT DSECT\n        IECSDSL1 (4)\n         ORG   DSCDSECT\n        IECSDSL1 (5)\n       $TEW$DS\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FSPACE$": {"ttr": 16646, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14\"\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:22:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//FSPACE   JOB (........),'INSTALL  -FSPACE-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=FSPACE\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   FSPACE\n  ALIAS   FS\n  NAME    FSPACE(R)\n/*\n//HLP     EXEC PAJHELP,MBR=FSPACEH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FSPACEH": {"ttr": 16648, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=FSPACE\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : DISPLAY INFORMATION ABOUT THE FREE-SPACE EXTENTS ON ANY\n              VOLUME(S) ATTACHED TO THE SYSTEM.\n)X SYNTAX :   FREESPA 'VOLUME' 'NOLIST/LIST'\n              REQUIRED : NONE.\n              DEFAULTS : ONLY COMMON VOLUME(S), NOLIST\n              ALIAS : FS\n)O OPERANDS :\n))'VOLUME' :  IS THE VOLUME SERIAL NUMBER(S) IDENTIFIER. MAY BE 1 TO 6\n              ALPHAMERICS CHARACTERS SPECIFIED.\n              - IF THE PARAMETER IS SUPPLIED, USER RECEIVES INFORMATION\n                ABOUT THE FREE-SPACE ON THE GIVEN VOLUME(S).\n              - IF THE PARAMETER IS NOT SUPPLIED, USER RECEIVES ONLY\n                INFORMATION ABOUT THE FREE-SPACE ON COMMON VOLUME(S).\n))'NOLIST' :  DISPLAY ONLY THE TOTAL FREE-SPACE AVAILABLE AND THE\n              LARGEST CONTIGUOUS FREE-SPACE EXTENT (IN TRACKS) ON\n              THE GIVEN VOLUME(S) OR COMMON VOLUME(S) ,DEFAULT OPTION.\n              SHORT FORM : 'NL'.\n))'LIST' :    DISPLAY THE SAME INFORMATION AS FOR 'NOLIST' BUT FOR ALL\n              FREE-SPACE EXTENTS, WITH ALSO THE NUMBER OF TRACKS IN\n              EACH EXTENT. SHORT FORM : 'L'.\n./     ALIAS   NAME=FS\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FSRTN": {"ttr": 16650, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\t\\x7f\\x00\\x94\\t\\x7f\\x14F\\x04\\x0e\\x04\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-07T00:00:00", "modifydate": "1994-04-07T14:46:00", "lines": 1038, "newlines": 1038, "modlines": 0, "user": "SYSPAJA"}, "text": "FSRT     TITLE '-- ROUTINE FSRTN - FULL-SCREEN SERVICE --'\nFSRTN    START 0\n         SPACE 1\n**********************************************************************\n***      A SET OF ROUTINES TO MANAGE MORE EASILY THE FULL-SCREEN   ***\n***      DISPLAY OPERATIONS ON AN IBM 3270 TERMINAL.               ***\n***      EXTENDED VERSION            (MOINIL P.A. - 14 MARCH 1994) ***\n**********************************************************************\n         SPACE 1\n         PRINT NOGEN\n        $DEFREG\n         PRINT GEN\n         SPACE 1\n         ENTRY FSRTNR\n         ENTRY FSRTNI\n         ENTRY FSRTNQ\n         ENTRY FSRTNB\n         ENTRY FSRTNA\n         SPACE 1\n         USING *,R15\n         MVI   WTGO+3,FSPACK-*     SET FSRTN ENTRY ------- 1\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nFSRTNR   MVI   WTGO+3,FSPACK-*     SET FSRTNR ENTRY ------ 2\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nFSRTNI   MVI   WTGO+3,FSPACK-*     SET FSRTNI ENTRY ------ 3\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nFSRTNQ   MVI   WTGO+3,FSPACK-*     SET FSRTNQ ENTRY ------ 4\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nFSRTNB   MVI   WTGO+3,FSPACK-*     SET FSRTNB ENTRY ------ 5\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nFSRTNA   MVI   WTGO+3,FSPACK-*     SET FSRTNA ENTRY ------ 6\n         DROP  R15\n         SPACE 1\nWTGO     LA    R15,*-*(R15)        SET COMMON ENTRY ADDRESS\nMAXENT   EQU   ((*-FSRTN)/8)+1\n         EJECT\nFSPACK  $XENT  BASE=(R10,R11)\n         LR    R15,R10             COMPUTE WHERE TO GO\n         BCTR  R15,0\n         XR    R0,R0\n         IC    R0,0(R15)\n         SRL   R0,3\n         LA    R14,MAXENT\n         SR    R14,R0\n         BCTR  R14,0\n         SLL   R14,2\n         B     *+L'*(R14)          ENTER SELECTED ROUTINE\n         B     @FSRTN              1\n         B     @FSRTNR             2\n         B     @FSRTNI             3\n         B     @FSRTNQ             4\n         B     @FSRTNB             5\n         B     @FSRTNA             6\n         EJECT\n*--------------------------------------------------------------------*\n* CALL FSRTN,(A,B,C),VL ---> MACROS : @FS AND @FSO                   *\n*            (A)                                                     *\n*        FUNCTION : WRITE A SCREEN VIA TPUT, AND GET A REPLY VIA     *\n*                   TGET.                                            *\n*        AT ENTRY : A = ADDRESS OF A 1-BYTE CONTAINING THE REQUESTS  *\n*                       X'00' = TPUT/TGET OPERATION                  *\n*                       X'01' = TGET SUPPRESS (NO REPLY), ONLY TPUT  *\n*                       X'80' = SNAP INPUT BUFFER WHEN RECEIVED      *\n*                               (NEEDS A PRE-DEFINED DATA-SET WITH   *\n*                               RECFM=VBA,BLKSIZE=1632,LRECL=125 AND *\n*                               PRE-ALLOCATED TO 'SYSSNAP' DD-NAME)  *\n*                       X'FF' = TERMINATE/EXIT FULL-SCREEN MODE      *\n*                   B = START ADDRESS OF THE SCREEN IMAGE            *\n*                   C = ADDRESS OF A FULLWORD CONTAINING THE SCREEN  *\n*                       IMAGE LENGTH                                 *\n*         AT EXIT : R15 = 0 - NORMAL COMPLETION (TEXT AT DISPOSAL)   *\n*                             WITH R0 = ADDRESS OF AID-BYTE OF       *\n*                                     STRUCTURED FIELD, OR R0 = 0,   *\n*                              AND R1 = ADDRESS OF AID-BYTE          *\n*                                     FOLLOWED BY THE 2-BYTES CURSOR *\n*                                     ADDRESS, OR R1 = 0.            *\n*                       = 4 - BUFFER SHORTAGE (INPUT TRUNCATED, BUT  *\n*                             R0-R1 ARE SET AS WHEN R15 = 0)         *\n*                       = 8 - END REQUESTED (KEYS : PA1, PA2 OR PA3, *\n*                             AND R0-R1 ARE SET AS WHEN R15 = 0)     *\n*                       = 16 - ERROR DETECTED (MESSAGE SENT)         *\n*--------------------------------------------------------------------*\n         SPACE 1\n@FSRTN   L     R2,4(R13)\n         XC    24(4,R2),24(R2)     SET R1 = 0 FOR RETURN\n         XC    AREPLY(L'AREPLY+L'LREPLY),AREPLY\n         L     R2,0(R1)            TEST AND SET PARAMETERS\n         LTR   R2,R2\n         BZ    SMS1\n         BP    STPRMS\n         LA    R2,0(R2)\n         CLI   0(R2),FSEXIT\n         BE    QUIT                BRANCH IF EXIT FULL-SCREEN REQ.\n         B     SMS1\nSTPRMS   TM    0(R2),255-FSSNAP-FSSKIP\n         BNZ   SMS1\n         MVC   SWOPT(1),0(R2)\n         L     R2,4(R1)\n         LTR   R2,R2\n         BNP   SMS1\n         ST    R2,SCIMAD\n         L     R2,8(R1)\n         LTR   R2,R2\n         BNM   SMS1\n         LA    R2,0(R2)\n         L     R0,0(R2)\n         LTR   R0,R0\n         BNP   SMS1\n         ST    R0,SCIMLG\n         TM    SWITCH,SCRFT        WAS FIRST TIME ENTRY DONE?\n         BO    GODONE              BRANCH IF YES\n         SPACE 1\n*------- CHECK CALLER TERMINAL.\n         SPACE 1\n         TM    SWITCH,SCRGT        TEMINAL ATTRIBUTES AVAILABLE?\n         BO    CHKRQ               YES\n         XC    FSTAB,FSTAB         NO, GET TERMINAL ATTRIBUTES\n        GTTERM MF=(E,GTPARM)\n         LTR   R15,R15\n         BNZ   SMS13\n         OI    SWITCH,SCRGT        INDICATE GOTTEN\n         CLC   FSALTSZE,=F'0'\n         BNE   CHKRQ\n         MVC   FSALTSZE,FSPRMSZE\nCHKRQ    CLC   REQSZ,=F'0'\n         BNE   CHKCT\n         MVC   REQSZ,=AL1(24,80)   SET DEFAULT\n         CLC   REQSZ,FSPRMSZE\n         BE    CHKCT\n         CLC   REQSZ,FSALTSZE\n         BNE   SMS4\nCHKCT   GTSIZE ,                   GET CURRENT LOGICAL SCREEN SIZE\n         LTR   R15,R15\n         BNZ   SMS2\n         LTR   R0,R0               IS IT A SCREEN?\n         BZ    SMS3                IF ZERO, NOT A SCREEN\n         STC   R0,CURROW           SAVE CURRENT SCREEN SIZE\n         STC   R1,CURCOL\n         CLC   REQSZ,CURSZ\n         BE    *+L'*+4             MATCH WITH REQUESTED?\n         OI    SWITCH,SCRSR        NO, INDICATE SCREEN SIZE TO BE SET\n        STCOM  NO                  TURN OFF INTERCOM.\n         LTR   R15,R15\n         BNZ   SMS5\n        STTMPMD ON,KEYS=ALL        DISABLE SESSION MANAGER\n         LTR   R15,R15\n         BNZ   SMS6\n        STFSMODE ON,INITIAL=YES    TURN ON VTAM FULL-SCREEN MODE\n         LTR   R15,R15\n         BNZ   SMS7\n         TM    SWITCH,SCRSR        SCREEN SIZE TO BE SET?\n         BZ    NOCHNG              BRANCH IF NOT\n         XC    DBLWRD,DBLWRD\n         MVC   DBLWRD+3(L'CURCOL),REQCOL\n         MVC   DBLWRD+7(L'CURROW),REQROW\n        STSIZE SIZELOC=DBLWRD,LINELOC=DBLWRD+4 SET REQUESTED SIZE\n         LTR   R15,R15\n         BNZ   SMS8\nNOCHNG   OI    SWITCH,SCRFT        SET FIRST TIME ENTRY DONE\n         CLC   REQSZ,FSPRMSZE      USE CORRECT ERASE ORDER\n         BNE   SETALT\n        $FS    CC=EW,MF=(I,CLSCR)\n         B     DOCLRS\nSETALT  $FS    CC=EWA,MF=(I,CLSCR)\nDOCLRS   LA    R15,REQSZ           SET CORRECT SBA\n         BAS   R14,SCLSBA\n         LA    R1,CLSCR\n         LA    R0,LCLSCR\n         ICM   R1,B'1000',TPUTFLG  INDICATE FULL-SCREEN\n        TPUT   (1),(0),R\n         LTR   R15,R15\n         BNZ   SMS9\n         SPACE 1\n*------- EXECUTE FULL-SCREEN PROCESSING.\n         SPACE 1\nGODONE   LM    R0,R1,SCIMLG        GET IMAGE INFO'S\n         CLC   0(L'ASKQ,R1),ASKQ   WHICH TPUT ...\n         BE    TNOEW\n         ICM   R1,B'1000',TPUTFLG  INDICATE FULL-SCREEN\n        TPUT   (1),(0),R\n         B     TSTTP\nTNOEW    LM    R8,R9,SCIMLG        GET IMAGE INFO'S\n        TPUT   (R9),(R8),NOEDIT,WAIT\nTSTTP    LTR   R15,R15\n         BNZ   SMS10\n         TM    SWOPT,FSSKIP        NO REPLY REQUESTED ?\n         BO    RETOK               YES, EXIT\n         L     R9,ABFFR\n         LTR   R9,R9\n         BNZ   *+L'*+4\n         BAS   R8,SETBUF           CREATE BUFFER (NOT DONE PREVIOUSLY)\n         USING TRBUF,R9\n         LM    R4,R7,CLRRP         CLEAR REPLY AREA\n         LR    R0,R5\n         BCTR  R0,0\n         MVCL  R4,R6\n         NI    SWITCH,255-BFFSH\n        TGET   SREPLY,(0),ASIS\n         ST    R1,LREPLY           TRUE LENGTH REPLY\n         LTR   R15,R15             IS INPUT OK?\n         BZ    SKCLRQ              YES\n         CH    R15,=H'20'          TERMINAL DISCONNECTED?\n         BE    ENDIT               YES,... SPLIT\n         CH    R15,=H'8'           ATTENTION?\n         BE    ENDIT               YES,... SPLIT\n         CH    R15,=H'12'          IS INPUT LONGER THAN BUFFER?\n         BNE   SMS11               NO,... ERROR\n         OI    SWITCH,BFFSH        YES, SET BUFFER SHORTAGE\n        TCLEARQ INPUT              FLUSH THE TRASH\nSKCLRQ   TM    SWITCH,CLSNP        SNAP CLOSED?\n         BO    NOSNAP              YES\n         TM    SWOPT,FSSNAP        NO, SNAP WANTED?\n         BZ    NOSNAP              NO\n         TM    SWITCH,OPSNP        YES, SNAP OPENED?\n         BO    DOSNAP              YES\n         LA    R2,SNAPDCB          NO, SEARCH DD AND OPEN IT IF ANY\n         USING IHADCB,R2\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\n         L     R3,ATIOT\n         USING TIODSECT,R3\nSCSNAP   CLC   TIOELNGH(4),=F'0'\n         BE    OSERR\n         CLC   TIOEDDNM,DCBDDNAM\n         BE    OPSNAP\n         SR    R1,R1\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     SCSNAP\n         DROP  R3\nOPSNAP  OPEN   (SNAPDCB,OUTPUT)\n         TM    DCBOFLGS,DCBOFOPN\n         BZ    OSERR               SNAP OPEN ERROR\n         DROP  R2\n         OI    SWITCH,OPSNP        SNAP IS NOW OPENED\nDOSNAP   LA    R15,SREPLY\n         ST    R15,AFTRB\n         AL    R15,LREPLY\n         BCTR  R15,0\n         ST    R15,ALTRB\n         MVC   TNTRB,LREPLY\n         LA    R8,REPLY+SFXL-1\n         AL    R8,MXBSZ\n        SNAP   TCB='S',STORAGE=((R9),(R8)),MF=(E,SNAPLST)\n         LTR   R15,R15\n         BZ    NOSNAP\n        CLOSE  (SNAPDCB)           SNAP ERROR\nOSERR    OI    SWITCH,CLSNP\nNOSNAP   XR    R2,R2\n         LR    R3,R2\n         LR    R4,R2\n         LR    R5,R2\n         L     R0,LREPLY\n         LTR   R0,R0\n         BNP   STNRET\n         LA    R1,SREPLY\n         CLI   0(R1),X'88'         AID OF S.F. (STRUCTURED FIELD)?\n         BNE   CHKPAK              NO\n         LR    R2,R1               YES, SET S.F. START\n         XR    R14,R14\n         ICM   R14,B'0011',1(R1)\n         LA    R14,5(R14)          S.F. LENGTH\n         SR    R0,R14\n         BNP   STNRET\n         AR    R1,R14              A REPLY FOLLOWS, POINT AFTER S.F.\nCHKPAK   CLI   0(R1),X'6C'         PA 1 ENTERED?\n         BE    ENDREQ              YES,... SPLIT\n         CLI   0(R1),X'6E'         PA 2 ENTERED?\n         BE    ENDREQ              YES,... SPLIT\n         CLI   0(R1),X'6B'         PA 3 ENTERED?\n         BE    ENDREQ              YES,... SPLIT\n         B     STNRET              NO\nENDIT    XR    R2,R2\n         LR    R3,R2\n         LR    R4,R2\n         LR    R5,R2\nENDREQ   LA    R15,8               END REQUESTED\n         B     SNXTGT\nSTNRET   XR    R15,R15\nSNXTGT   LR    R3,R1\n         LA    R14,L'SREPLY\n         SR    R0,R14\n         BNP   *+L'*+6\n         LR    R5,R0\n         LA    R4,0(R1,R14)\n         STM   R4,R5,AREPLY        REPLY LENGTH AND START ADDRESS\n         L     R14,4(R13)\n         STM   R2,R3,20(R14)       PASS AID'S ADDRESSES ...\n         LTR   R15,R15\n         BZ    RETOK\n         B     LEAVE\n         DROP  R9\n         EJECT\n*--------------------------------------------------------------------*\n* CALL FSRTNR ---> MACRO : @FSR                                      *\n*        FUNCTION : PROCESS THE REPLY TEXT OBTAINED VIA TGET         *\n*                   (THIS IS MANDATORY AS LAST CALL).                *\n*                   IT PASSES INPUT TO CALLER (FIELD BY FIELD).      *\n*        AT ENTRY : NONE                                             *\n*         AT EXIT : R15 = 0 - COMPLETION OF REPLY TEXT (NO MORE),    *\n*                         AND R1 = 0                                 *\n*              OR : R15 = ADDRESS OF SBA (SET BUFFER ADDRESS ORDER,  *\n*                         1-BYTE) FOLLOWED BY THE BUFFER ADDRESS     *\n*                         (2-BYTES), FOLLOWED BY THE TEXT READ,      *\n*                         AND R1 = LENGTH OF TEXT                    *\n*--------------------------------------------------------------------*\n         SPACE 1\n@FSRTNR  L     R2,4(R13)\n         XC    24(4,R2),24(R2)     SET R1 = 0 FOR RETURN\n         LM    R15,R0,AREPLY\n         LTR   R0,R0               ANYTHING TO PASS?\n         BNP   RETOK               NO MORE ...\n         CLI   0(R15),X'11'        SBA ORDER?\n         BE    *+L'*+10            YES\nRESALL   XC    LREPLY,LREPLY       NO, RESET ALL ...\n         B     RETOK               SAY END ...\n         LA    R14,3(R15)          POINT TO TEXT\n         XR    R1,R1\n         SH    R0,=H'3'            MINUS SBA + BUFFER ADDR.\n         BM    RESALL              BRANCH IF NO MORE, END\n         BZ    LSTNLL              BRANCH IF LAST IS NULL\nSRCSBA   CLI   0(R14),X'11'        SEARCH END OR NEXT SBA\n         BE    NXTSBA\n         LA    R1,1(R1)\n         LA    R14,1(R14)\n         BCT   R0,SRCSBA\n         B     LSTNLL\nNXTSBA   ST    R14,AREPLY\nLSTNLL   ST    R1,24(R2)           SET R1 = LENGTH FOR RETURN\n         ST    R0,LREPLY           SET R0 = REMAINING LENGTH\n         B     LEAVE\n         EJECT\n*--------------------------------------------------------------------*\n* CALL FSRTNI,(A,B,C),VL ---> MACROS : @FSI AND @FST                 *\n*             (A,B)                                                  *\n*             (A)                                                    *\n*        FUNCTION : SET MAXIMUM REPLY TEXT LENGTH (BUFFER) FOR TGET  *\n*                   (DEFAULT BUFFER SIZE IS 1K, MAXIMUM IS 30K).     *\n*                   IT OBTAINS THE BUFFER FOR REPLY TEXT.            *\n*                   ALSO, EVENTUALLY GET TERMINAL ATTRIBUTES AND/OR  *\n*                   DECLARE THE DESIRED WORKING SCREEN SIZE (BY      *\n*                   DEFAULT IT IS 24 * 80).                          *\n*        AT ENTRY : A = ADDRESS OF A FULLWORD CONTAINING THE MAXIMUM *\n*                       REPLY TEXT LENGTH (BUFFER LENGTH)            *\n*                       IF R1 IS ZERO, OR THE ADDRESS IS ZERO, OR    *\n*                       THE LENGTH IS ZERO OR NEGATIVE, THEN DEFAULT *\n*                       SIZE IS USED                                 *\n*                   B = ADDRESS OF AN 8-BYTES FIELD TO RECEIVE BACK  *\n*                       THE TERMINAL ATTRIBUTES                      *\n*                   C = ADDRESS OF A 2-BYTES FIELD CONTAINING THE    *\n*                       DESIRED WORKING SCREEN SIZE AS BELOW :       *\n*                            1ST-BYTE = ROWS VALUE, AND              *\n*                            2ND-BYTE = COLUMNS VALUE.               *\n*         AT EXIT : R15 = 0 - NORMAL COMPLETION                      *\n*                       = 16 - ERROR DETECTED (MESSAGE SENT)         *\n*--------------------------------------------------------------------*\n         SPACE 1\n@FSRTNI  XC    AREPLY(L'AREPLY+L'LREPLY),AREPLY\n         XC    REQSZ,REQSZ\n         LTR   R1,R1\n         BZ    STIDEF\n         L     R2,0(R1)\n         LA    R2,0(R2)\n         TM    0(R1),X'80'\n         BO    SKSGTA\n         TM    4(R1),X'80'\n         BO    GETTA\n         TM    SWITCH,SCRFT        WAS FIRST TIME ENTRY DONE?\n         BO    SMS22               BRANCH IF YES\n         TM    8(R1),X'80'\n         BZ    SMS1\n         L     R3,8(R1)\n         LA    R3,0(R3)\n         LTR   R3,R3\n         BZ    GETTA\n         MVC   REQSZ,0(R3)         COPY REQUESTED SCREEN SIZE\nGETTA    L     R3,4(R1)\n         LA    R3,0(R3)\n         LTR   R3,R3\n         BZ    SKSGTA\n         TM    SWITCH,SCRGT        TEMINAL ATTRIBUTES AVAILABLE?\n         BO    SETTA               YES\n         XC    FSTAB,FSTAB         NO, GET TERMINAL ATTRIBUTES\n        GTTERM MF=(E,GTPARM)\n         LTR   R15,R15\n         BNZ   SMS13\n         OI    SWITCH,SCRGT        INDICATE GOTTEN\n         CLC   FSALTSZE,=F'0'\n         BNE   SETTA\n         MVC   FSALTSZE,FSPRMSZE\nSETTA    MVC   0(L'FSTAB,R3),FSTAB PASS BACK TO CALLER\n         CLC   REQSZ,=F'0'\n         BE    SKSGTA\n         CLC   REQSZ,FSPRMSZE\n         BE    SKSGTA\n         CLC   REQSZ,FSALTSZE\n         BNE   SMS21\nSKSGTA   LTR   R2,R2\n         BZ    STIDEF\n         L     R0,0(R2)\n         LTR   R0,R0\n         BP    *+L'*+10\nSTIDEF   MVC   MXBSZ,=A(1*KBYTES)\n         B     GETBUF\n         AH    R0,=H'7'\n         SRL   R0,3\n         SLL   R0,3\n         CL    R0,=A(30*KBYTES)\n         BH    SMS1\n         ST    R0,MXBSZ\nGETBUF   LM    R0,R1,LBFFR\n         LTR   R1,R1\n         BZ    NOBUF\n        FREEMAIN R,LV=(0),A=(1)\n         XC    LBFFR(L'LBFFR+L'ABFFR),LBFFR\nNOBUF    BAS   R8,SETBUF           CREATE BUFFER\n         B     RETOK\n         EJECT\n*--------------------------------------------------------------------*\n* CALL FSRTNQ,(A),VL ---> MACRO : @FSQ                               *\n*        FUNCTION : GET QUERY REPLY INFORMATION.                     *\n*                   (DEFAULT BUFFER SIZE IS 1K, MAXIMUM IS 30K)      *\n*        AT ENTRY : A = ADDRESS OF A FULLWORD CONTAINING THE MAXIMUM *\n*                       QUERY REPLY LENGTH (BUFFER LENGTH)           *\n*                       IF R1 IS ZERO, OR THE ADDRESS IS ZERO, OR    *\n*                       THE LENGTH IS ZERO OR NEGATIVE, THEN DEFAULT *\n*                       SIZE IS USED                                 *\n*         AT EXIT : R15 = 0 - NORMAL COMPLETION (QUERY AT DISPOSAL,  *\n*                             R1 = ADDRESS OF QUERY REPLY BUFFER     *\n*                             INFORMATION AND R0 = LENGTH)           *\n*                       = 16 - ERROR DETECTED (MESSAGE SENT)         *\n*--------------------------------------------------------------------*\n         SPACE 1\n@FSRTNQ  L     R7,4(R13)\n         XC    20(2*4,R7),20(R7)   SET R0 AND R1 = 0 FOR RETURN\n         TM    SWITCH,SCRFT        WAS FIRST TIME ENTRY DONE?\n         BZ    SMS12               BRANCH IF NOT\n         LR    R5,R1\n         TM    FSATTRB3,FSTASCII\n         BO    SMS14\n         TM    FSATTRB3,FSTQUERY\n         BZ    SMS15\n         OC    QLBFR,QLBFR\n         BNZ   GTQBUF\n         LTR   R5,R5\n         BZ    STQDEF\n         L     R2,0(R5)\n         LTR   R2,R2\n         BNM   SMS1\n         LA    R2,0(R2)\n         LTR   R2,R2\n         BZ    STQDEF\n         L     R0,0(R2)\n         LTR   R0,R0\n         BP    *+L'*+10\nSTQDEF   MVC   QLBFR,=A(1*KBYTES)\n         B     GTQBUF\n         AH    R0,=H'7'\n         SRL   R0,3\n         SLL   R0,3\n         CL    R0,=A(30*KBYTES)\n         BH    SMS1\n         ST    R0,QLBFR\nGTQBUF   LM    R0,R1,QLBFR\n         LR    R3,R0\n         LTR   R1,R1\n         BNZ   ZQBUF\n        GETMAIN R,LV=(0)\n         ST    R1,QABFR\nZQBUF    LR    R2,R1\n         XR    R15,R15\n         BASR  R14,0\n         MVCL  R2,R14\n         LR    R2,R1\n         CLC   REQSZ,FSPRMSZE      USE CORRECT ERASE ORDER\n         BNE   ALTST\n        $FS    CC=EW,MF=(I,RSTAID)\n         B     DORST\nALTST   $FS    CC=EWA,MF=(I,RSTAID)\nDORST    LA    R0,RSTAIDL\n         LA    R1,RSTAID\n         ICM   R1,B'1000',TPUTFLH\n        TPUT   (1),(0),R           RESET ATTENTION IDENTIFIER (1)\n         LTR   R15,R15\n         BNZ   SMS16A\n        TCLEARQ INPUT              FLUSH THE TRASH\n        TPG    ASKQ,ASKQL,NOEDIT,WAIT\n         LTR   R15,R15\n         BNZ   SMS17\n         LM    R0,R1,QLBFR\n         ICM   R1,B'1000',TGETFLG\n        TGET   (1),(0),R           READ QUERY RESPONSE\n         LTR   R15,R15\n         BNZ   SMS18\n         LR    R5,R1\n         LA    R0,RSTAIDL\n         LA    R1,RSTAID\n         ICM   R1,B'1000',TPUTFLH\n        TPUT   (1),(0),R           RESET ATTENTION IDENTIFIER (2)\n         LTR   R15,R15\n         BNZ   SMS16B\n         LR    R6,R2\n         ALR   R2,R5\n         BCTR  R2,0\n         CLR   R6,R2\n         BH    SMS19               AID FROM QUERY REPLY NOT RECEIVED\n         CLI   0(R6),X'88'\n         BNE   SMS20               NOT AID FROM QUERY REPLY\n         STM   R5,R6,20(R7)        SET R0 AND R1 = 0 FOR RETURN\n         B     RETOK\n         EJECT\n*--------------------------------------------------------------------*\n* CALL FSRTNB,(A,B),VL ---> MACRO : @FSBA                            *\n*        FUNCTION : COMPUTE ROW/COLUMN TO BUFFER ADDRESS FOR THE     *\n*                   CURRENT WORKING SCREEN SIZE                      *\n*        AT ENTRY : A = ADDRESS OF A 2-BYTES FIELD CONTAINING THE    *\n*                       DESIRED ROW/COLUMN AS BELOW :                *\n*                             1ST-BYTE = ROW VALUE, AND              *\n*                             2ND-BYTE = COLUMN VALUE                *\n*                   B = ADDRESS OF A 2-BYTES FIELD TO RECEIVE BACK   *\n*                       THE CORRESPONDING BUFFER ADDRESS             *\n*         AT EXIT : R15 = 0 - NORMAL COMPLETION                      *\n*                       = 16 - ERROR DETECTED (MESSAGE SENT)         *\n*--------------------------------------------------------------------*\n         SPACE 1\n@FSRTNB  BAS   R14,CKSTPL          CHECK-SET PARAMETERS\n         CLC   REQROW,0(R2)        VALID ROW?\n         BL    SMS1                NO\n         CLC   REQCOL,1(R2)        VALID COLUMN?\n         BL    SMS1                NO\n         XR    R0,R0\n         LR    R1,R0\n         IC    R0,0(R2)            POS = ((ROW-1) * MAXCOL) + (COL-1)\n         BCT   R0,*+L'*+4\n         B     *+L'*+8\n         IC    R1,REQCOL\n         MR    R0,R0\n         XR    R0,R0\n         IC    R0,1(R2)\n         BCTR  R0,0\n         AR    R1,R0\n         LR    R15,R1\n         SRL   R15,6\n         IC    R0,TBSBA(R15)\n         STC   R0,0(R3)\n         N     R1,=A(X'0000003F')\n         IC    R0,TBSBA(R1)\n         STC   R0,1(R3)\n         B     RETOK\n         EJECT\n*--------------------------------------------------------------------*\n* CALL FSRTNA,(A,B),VL ---> MACRO : @FSRC                            *\n*        FUNCTION : COMPUTE BUFFER ADDRESS TO ROW/COLUMN FOR THE     *\n*                   CURRENT WORKING SCREEN SIZE                      *\n*        AT ENTRY : A = ADDRESS OF A 2-BYTES FIELD CONTAINING THE    *\n*                       BUFFER ADDRESS                               *\n*                   B = ADDRESS OF A 2-BYTES FIELD TO RECEIVE BACK   *\n*                       THE CORRESPONDING ROW/COLUMN AS BELOW :      *\n*                             1ST-BYTE = ROW VALUE, AND              *\n*                             2ND-BYTE = COLUMN VALUE                *\n*         AT EXIT : R15 = 0 - NORMAL COMPLETION                      *\n*                       = 16 - ERROR DETECTED (MESSAGE SENT)         *\n*--------------------------------------------------------------------*\n         SPACE 1\n@FSRTNA  BAS   R14,CKSTPL          CHECK-SET PARAMETERS\n         LA    R4,1\n         LA    R5,TBSBAL\n         LA    R6,TBSBA            CHECK VALID HEX BUFFER ADDRESS\n         LR    R0,R6\n         CLC   0(1,R2),0(R6)\n         BE    *+L'*+8\n         BXLE  R6,R4,*-10\n         B     SMS1\n         SR    R6,R0\n         LR    R1,R6\n         SLL   R1,6\n         LR    R6,R0\n         CLC   1(1,R2),0(R6)\n         BE    *+L'*+8\n         BXLE  R6,R4,*-10\n         B     SMS1\n         SR    R6,R0\n         AR    R1,R6\n         AR    R1,R4\n         XR    R0,R0\n         LR    R2,R0\n         IC    R2,REQCOL\n         LR    R4,R2\n         LR    R5,R0\n         IC    R5,REQROW\n         MR    R4,R4\n         CLR   R1,R5               CHECK VALID BUFFER ADDRESS\n         BNL   SMS1\n         AR    R1,R2               TO GET THE RIGHT (ROW,COL)\n         DR    R0,R2               POS / MAXCOL\n         STC   R0,1(R3)            REMAINDER = COL\n         STC   R1,0(R3)            QUOTIENT = ROW\n         B     RETOK\n         EJECT\n*------- ERROR MESSAGES - TERMINATION.\n         SPACE 1\nSMS1     BAS   R8,FSOFF\n         LA    R0,L'ERROR1         WRONG CALL PARM'S\n         LA    R1,ERROR1\n         B     SEVERR\nSMS2     LA    R7,ERROR2+17\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR2         GTSIZE ERROR\n         LA    R1,ERROR2\n         B     SEVERR\nSMS3     BAS   R8,FSOFF\n         LA    R0,L'ERROR3         NOT SCREEN TERMINAL\n         LA    R1,ERROR3\n         B     SEVERR\nSMS4     BAS   R8,FSOFF\n         LA    R0,L'ERROR4         NOT SIZED 24 * 80\n         LA    R1,ERROR4\n         B     SEVERR\nSMS5     LA    R7,ERROR5+19\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR5         STCOM NO ERROR\n         LA    R1,ERROR5\n         B     SEVERR\nSMS6     LA    R7,ERROR6+30\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR6         STTMPMD ON,KEYS=ALL ERROR\n         LA    R1,ERROR6\n         B     SEVERR\nSMS7     LA    R7,ERROR7+34\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR7         STFSMODE ON,INITIAL=YES ERROR\n         LA    R1,ERROR7\n         B     SEVERR\nSMS8     LA    R7,ERROR8+20\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR8         STSIZE SIZE=80,LINE=24 ERROR\n         LA    R1,ERROR8\n         B     SEVERR\nSMS9     LA    R7,ERROR9+31\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR9         INITIAL CLEAR ERROR\n         LA    R1,ERROR9\n         B     SEVERR\nSMS10    LA    R7,ERROR10+28\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR10        TPUT SCREEN ERROR\n         LA    R1,ERROR10\n         B     SEVERR\nSMS11    LA    R7,ERROR11+28\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR11        TGET SCREEN ERROR\n         LA    R1,ERROR11\n         B     SEVERR\nSMS12    BAS   R8,FSOFF\n         LA    R0,L'ERROR12        FS MODE OFF FAILED\n         LA    R1,ERROR12\n         B     SEVERR\nSMS13    CH    R15,=H'8'\n         BE    SMS3\n         LA    R7,ERROR13+17\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR13        GTTERM FAILED\n         LA    R1,ERROR13\n         B     SEVERR\nSMS14    BAS   R8,FSOFF\n         LA    R0,L'ERROR14        ASCII NOT SUPPORTED\n         LA    R1,ERROR14\n         B     SEVERR\nSMS15    BAS   R8,FSOFF\n         LA    R0,L'ERROR15        CAN'T DO QUERY\n         LA    R1,ERROR15\n         B     SEVERR\nSMS16A   MVI   ERROR16+15,C'1'\n         B     SMS16\nSMS16B   MVI   ERROR16+15,C'2'\nSMS16    LA    R7,ERROR16+24\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR16        RESET AID (N) FAILED\n         LA    R1,ERROR16\n         B     SEVERR\nSMS17    LA    R7,ERROR17+29\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR17        ASK QUERY RESPONSE FAILED\n         LA    R1,ERROR17\n         B     SEVERR\nSMS18    LA    R7,ERROR18+30\n         BAS   R14,SMSRC\n         BAS   R8,FSOFF\n         LA    R0,L'ERROR18        READ QUERY REPONSE FAILED\n         LA    R1,ERROR18\n         B     SEVERR\nSMS19    BAS   R8,FSOFF\n         LA    R0,L'ERROR19        QUERY AID NOT RECEIVED\n         LA    R1,ERROR19\n         B     SEVERR\nSMS20    BAS   R8,FSOFF\n         LA    R0,L'ERROR20        WRONG QUERY AID\n         LA    R1,ERROR20\n         B     SEVERR\nSMS21    BAS   R8,FSOFF\n         LA    R0,L'ERROR21        INVALID SCREEN SIZE\n         LA    R1,ERROR21\n         B     SEVERR\nSMS22    BAS   R8,FSOFF\n         LA    R0,L'ERROR22        CAN'T CHANGE SCREEN SIZE NOW\n         LA    R1,ERROR22\nSEVERR  TPUT   (1),(0),R\n         LA    R15,16              SEVERE ERROR\n         B     LEAVE\n         SPACE 1\n*------- TURN OFF FULL-SCREEN (SPF),\n*        CLEAR AND RESET CURSOR TO ROW1, COL1.\n         SPACE 1\nQUIT     LA    R8,RETOK\n*              R8 = LINK REGISTER\nFSOFF    TM    SWITCH,SCRFT        WAS FIRST TIME ENTRY DONE?\n         BZ    GOEXIT              BRANCH IF NOT\n         TM    SWITCH,SCRSR        WAS SCREEN SIZE CHANGED?\n         BZ    ENDCL               BRANCH IF NOT\n         XC    DBLWRD,DBLWRD\n         MVC   DBLWRD+3(L'CURCOL),CURCOL\n         MVC   DBLWRD+7(L'CURROW),CURROW\n        STSIZE SIZELOC=DBLWRD,LINELOC=DBLWRD+4 RESTORE ORIGINAL SIZE\n         ST    R15,LSOPRC+0*4\n         CLC   CURSZ,FSPRMSZE      USE CORRECT ERASE ORDER\n         BNE   STALT\n        $FS    CC=EW,MF=(I,CLSCR)\n         B     ENDCL\nSTALT   $FS    CC=EWA,MF=(I,CLSCR)\nENDCL    LA    R15,CURSZ           SET CORRECT SBA\n         BAS   R14,SCLSBA\n         LA    R1,CLSCR\n         LA    R0,LCLSCR\n         ICM   R1,B'1000',TPUTFLG  INDICATE FULL-SCREEN\n        TPUT   (1),(0),R\n         ST    R15,LSOPRC+1*4\n        STFSMODE OFF               TURN OFF FULL-SCREEN MODE\n         ST    R15,LSOPRC+2*4\n        STTMPMD OFF                MAY BE ENABLE SESSION MANAGER\n         ST    R15,LSOPRC+3*4\n        STCOM  YES                 TURN ON INTERCOM.\n         ST    R15,LSOPRC+4*4\n         SPACE 1\n*------- THAT'S ALL FOLKS.\n         SPACE 1\nGOEXIT   NI    SWITCH,255-SCRFT-SCRGT-SCRSR RESET ALL\n         XC    FSTAB,FSTAB\n         XC    REQSZ,REQSZ\n         TM    SWITCH,CLSNP        SNAP CLOSED?\n         BO    QFBUF               YES\n         TM    SWITCH,OPSNP        NO,... SNAP OPENED?\n         BZ    QFBUF               NO\n        CLOSE  (SNAPDCB)           CLOSE SNAP\n         OI    SWITCH,CLSNP        CLOSE SNAP WAY\nQFBUF    LM    R0,R1,QLBFR\n         LTR   R1,R1\n         BZ    FRBUF\n        FREEMAIN R,LV=(0),A=(1)\n         XC    QLBFR(L'QLBFR+L'QABFR),QLBFR\nFRBUF    LM    R0,R1,LBFFR\n         LTR   R1,R1\n         BZR   R8\n        FREEMAIN R,LV=(0),A=(1)\n         XC    LBFFR(L'LBFFR+L'ABFFR),LBFFR\n         BR    R8\n         SPACE 1\n*------- BACK TO CALLER.\n         SPACE 1\nRETOK    XR    R15,R15\n         TM    SWITCH,BFFSH\n         BZ    LEAVE+L'LEAVE\n         LA    R15,4               INPUT TRUNCATED\nLEAVE    NI    SWITCH,255-BFFSH\n         OC    LSOPRC(5*4),LSOPRC\n         BZ    EXRET\n         LR    R2,R15\n         ICM   R15,B'1111',LSOPRC+0*4\n         BZ    NXMS1\n         XC    LSOPRC+0*4(4),LSOPRC+0*4\n         LA    R7,MSGA+27\n         BAS   R14,SMSRC\n        TPUT   MSGA,L'MSGA\nNXMS1    ICM   R15,B'1111',LSOPRC+1*4\n         BZ    NXMS2\n         XC    LSOPRC+1*4(4),LSOPRC+1*4\n         LA    R7,MSGB+23\n         BAS   R14,SMSRC\n        TPUT   MSGB,L'MSGB\nNXMS2    ICM   R15,B'1111',LSOPRC+2*4\n         BZ    NXMS3\n         XC    LSOPRC+2*4(4),LSOPRC+2*4\n         LA    R7,MSGC+23\n         BAS   R14,SMSRC\n        TPUT   MSGC,L'MSGC\nNXMS3    ICM   R15,B'1111',LSOPRC+3*4\n         BZ    NXMS4\n         XC    LSOPRC+3*4(4),LSOPRC+3*4\n         LA    R7,MSGD+22\n         BAS   R14,SMSRC\n        TPUT   MSGD,L'MSGD\nNXMS4    ICM   R15,B'1111',LSOPRC+4*4\n         BZ    NXMSX\n         XC    LSOPRC+4*4(4),LSOPRC+4*4\n         LA    R7,MSGE+20\n         BAS   R14,SMSRC\n        TPUT   MSGE,L'MSGE\nNXMSX    LR    R15,R2\nEXRET   $XRET  CC=(R15)\n         SPACE 1\n*------- EDIT RC IN MESSAGE ROUTINE.\n*              R15 = RC TO BE EDITED IN MESSAGE\n*              R14 = LINK REGISTER\n         SPACE 1\nSMSRC    CVD   R15,DBLWRD\n         MVC   0(4,R7),=XL4'40202120'\n         ED    0(4,R7),DBLWRD+L'DBLWRD-2\n         BR    R14\n         SPACE 1\n*------- CREATE BUFFER ROUTINE.\n*              R8 = LINK REGISTER\n         SPACE 1\nSETBUF   L     R0,MXBSZ\n         AL    R0,=A(PFXL+SFXL)\n         ST    R0,LBFFR\n        GETMAIN R,LV=(0)\n         ST    R1,ABFFR\n         USING TRBUF,R1\n         MVC   FILLSD,=CL4'SNAP'\n         LA    R2,SREPLY\n         ST    R2,CLRRP\n         LA    R2,L'SREPLY+1\n         AL    R2,MXBSZ\n         ST    R2,CLRRP+4\n         LA    R2,REPLY\n         AL    R2,MXBSZ\n         MVC   1(4,R2),=CL4'SNAP'\n         DROP  R1\n         BR    R8\n         SPACE 1\n*------- SET CORRECT SBA ROUTINE.\n*              R0-R1 = WORK REGISTERS\n*              R14 = LINK REGISTER\n*              R15 = AT ENTRY, SCREEN SIZE POINTER\n         SPACE 1\nSCLSBA   XR    R0,R0\n         LR    R1,R0\n         IC    R0,0(R15)\n         IC    R1,1(R15)\n         MR    R0,R0\n         BCTR  R1,0\n         BCTR  R1,0\n         LR    R15,R1\n         SRL   R15,6\n         IC    R0,TBSBA(R15)\n         STC   R0,CLSBA+1\n         N     R1,=A(X'0000003F')\n         IC    R0,TBSBA(R1)\n         STC   R0,CLSBA+2\n         BR    R14\n         SPACE 1\n*------- CHECK-SET PARAMETERS ROUTINE.\n*              R1 = PARAMETERS LIST POINTER\n*              R2-R3 = AT EXIT, PARAMETERS POINTERS\n*              R14 = LINK REGISTER\n         SPACE 1\nCKSTPL   TM    SWITCH,SCRFT        WAS FIRST TIME ENTRY DONE?\n         BZ    SMS12               BRANCH IF NOT\n         LTR   R1,R1\n         BZ    SMS1\n         TM    0(R1),X'80'\n         BO    SMS1\n         TM    4(R1),X'80'\n         BZ    SMS1\n         LM    R2,R3,0(R1)\n         LTR   R2,R2\n         BZ    SMS1\n         CLC   0(2,R2),=F'0'\n         BE    SMS1\n         LA    R3,0(R3)\n         LTR   R3,R3\n         BZ    SMS1\n         BR    R14\n         SPACE 1\n         DROP  R10,R11\n         EJECT\n*--------------------------------------------------------------------*\n*        CONSTANTS AND WORK-AREAS.                                   *\n*--------------------------------------------------------------------*\n         SPACE 1\nDBLWRD   DC    D'0'\nFSTAB   @FST   ,\nGTPARM  GTTERM PRMSZE=FSPRMSZE,ALTSZE=FSALTSZE,ATTRIB=FSATTRIB,MF=L\nATIOT    DC    A(*-*)\nKBYTES   EQU   1024\nMXBSZ    DC    A(1*KBYTES)\nSCIMLG   DC    A(*-*)        SCREEN IMAGE LENGTH\nSCIMAD   DC    A(*-*)        SCREEN IMAGE ADDRESS\nLBFFR    DC    A(*-*)        TGET - BUFFER LENGTH\nABFFR    DC    A(*-*)        TGET - BUFFER ADDRESS\nQLBFR    DC    A(*-*)        QUERY TGET - BUFFER LENGTH\nQABFR    DC    A(*-*)        QUERY TGET - BUFFER ADDRESS\nAREPLY   DC    F'0'          TGET - REPLY CURRENT ADDRESS\nLREPLY   DC    F'0'          TGET - REPLY LENGTH\nCLRRP    DC    A(*-*,*-*,*+4,0)\nLSOPRC   DC    5F'0'\nREQSZ    DC    0H'0'         REQUESTED WORKING SCREEN SIZE\nREQROW   DC    AL1(*-*)            ROWS VALUE\nREQCOL   DC    AL1(*-*)            COLUMNS VALUE\nCURSZ    DC    0H'0'         CURRENT (ORIGINAL) SCREEN SIZE\nCURROW   DC    AL1(*-*)            ROWS VALUE\nCURCOL   DC    AL1(*-*)            COLUMNS VALUE\nTBSBA    DC    XL16'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'  00-0F\n         DC    XL16'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'  10-1F\n         DC    XL16'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'  20-2F\n         DC    XL16'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'  30-3F\nTBSBAL   EQU   *-1\n         SPACE 1\nSWITCH   DC    XL1'0'\nSCRFT    EQU   X'80'         FIRST TIME ENTRY DONE\nSCRGT    EQU   X'40'         TERMINAL ATTRIBUTES GOTTEN\nSCRSR    EQU   X'20'         SCREEN SIZE TO BE SET/RESET\nBFFSH    EQU   X'10'         BUFFER SHORTAGE\nOPSNP    EQU   X'02'         SNAP OPENED\nCLSNP    EQU   X'01'         SNAP CLOSED\nSWOPT   @FSO   ,\n         SPACE 1\nTGETFLG  DC    XL1'81'       TGET ASIS,WAIT\nTPUTFLG  DC    XL1'03'       TPUT FULLSCR,WAIT\nTPUTFLH  DC    XL1'0B'       TPUT FULLSCR,WAIT,HOLD\n         SPACE 1\nERROR1   DC    C'*** Wrong CALL parameter(s) detected ***'\nERROR2   DC    C'*** \"GTSIZE\" RC =     ***'\nERROR3   DC    C'*** I run only on a screen terminal ***'\nERROR4   DC    C'*** I want to be screen sized 24 x 80 ***'\nERROR5   DC    C'*** \"STCOM NO\" RC =     ***'\nERROR6   DC    C'*** \"STTMPMD ON,KEYS=ALL\" RC =     ***'\nERROR7   DC    C'*** \"STFSMODE ON,INITIAL=YES\" RC =     ***'\nERROR8   DC    C'*** \"STSIZE set RC =     ***'\nERROR9   DC    C'*** Initial clear screen - RC =     ***'\nERROR10  DC    C'*** TPUT screen error - RC =     ***'\nERROR11  DC    C'*** TGET screen error - RC =     ***'\nERROR12  DC    C'*** VTAM full-screen mode is OFF ***'\nERROR13  DC    C'*** \"GTTERM\" RC =     ***'\nERROR14  DC    C'*** I don''t support ASCII terminal ***'\nERROR15  DC    C'*** Can''t do QUERY at terminal ***'\nERROR16  DC    C'*** Reset AID ( ) - RC =     ***'\nERROR17  DC    C'*** Ask QUERY response - RC =     ***'\nERROR18  DC    C'*** Read QUERY response - RC =     ***'\nERROR19  DC    C'*** AID form QUERY reply not received ***'\nERROR20  DC    C'*** Wrong AID from QUERY reply ***'\nERROR21  DC    C'*** Invalid working screen size ***'\nERROR22  DC    C'*** Can''t change working screen size now ***'\nMSGA     DC    C'*** \"STSIZE\" restore - RC =     ***'\nMSGB     DC    C'*** Clear screen - RC =     ***'\nMSGC     DC    C'*** \"STFSMODE OFF\" RC =     ***'\nMSGD     DC    C'*** \"STTMPMD OFF\" RC =     ***'\nMSGE     DC    C'*** \"STCOM YES\" RC =     ***'\n         SPACE 1\nCLSCR    $FS   CC=EW,WCC=(AL,KBR,RMDT),MF=L\nCLSBA    $FS   SBA=(24,79),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(IC),MF=L\nLCLSCR   EQU   *-CLSCR\n         SPACE 1\nRSTAID   $FS   CC=EW,WCC=(KBR,RMDT),MF=L\nRSTAIDL  EQU   *-RSTAID\n         SPACE 1\nASKQ     $FS   CC=WSF,SET=(000501FF02),MF=L\nASKQL    EQU   *-ASKQ\n         EJECT\n*--------------------------------------------------------------------*\n*        SNAP CONTROL BLOCKS.                                        *\n*--------------------------------------------------------------------*\n         SPACE 1\n        PRINT  NOGEN\nSNAPDCB DCB    DSORG=PS,RECFM=VBA,MACRF=(W),BLKSIZE=1632,LRECL=125,    X\n               DDNAME=SYSSNAP\n        PRINT  GEN\nSNAPLST SNAP   DCB=SNAPDCB,ID=1,STORAGE=(*-*,*-*),STRHDR=SNAPHD,MF=L\nSNAPHD   DC    AL1(L'HDT)\nHDT      DC    C'F S R T N - DUMP OF TERMINAL INPUT BUFFER.'\n         EJECT\n*--------------------------------------------------------------------*\n*        LITERAL POOL.                                               *\n*--------------------------------------------------------------------*\n         SPACE 1\n        LTORG\n         SPACE 1\n*--------------------------------------------------------------------*\n*        TGET REPLY BUFFER DUMMY SECTION.                            *\n*--------------------------------------------------------------------*\n         SPACE 1\nTRBUF    DSECT\nAFTRB    DS    F             ADDRESS OF FIRST TGET REPLY BYTE\nALTRB    DS    F             ADDRESS OF LAST TGET REPLY BYTE\nTNTRB    DS    F             TOTAL NUMBER OF TGET REPLY BYTES\nFILLSD   DS    CL4           FILLER FOR SNAP DUMP\nSREPLY   DS    XL3           AID + JUNK (CURSOR ADDRESS)\nPFXL     EQU   *-TRBUF\nREPLY    DS    X             START OF REPLY TEXT\nSFXL     EQU   5\n         SPACE 1\n*--------------------------------------------------------------------*\n*        GENERAL DUMMY SECTIONS.                                     *\n*--------------------------------------------------------------------*\n         SPACE 1\n        PRINT  NOGEN\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FSRTN$": {"ttr": 17156, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91!O\\x00\\x91!O\\x11%\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-02T00:00:00", "modifydate": "1991-08-02T11:25:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//FSRTN    JOB (........),'INSTALL  - FSRTN -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,MBR=FSRTN\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ENTRY   FSRTN\n  NAME    FSRTN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FSRTN@": {"ttr": 17158, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x08/\\x00\\x94\\x08/\\x128\\x00\\x88\\x00\\x88\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-23T00:00:00", "modifydate": "1994-03-23T12:38:00", "lines": 136, "newlines": 136, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/03/94\n                                                      FSRTN     1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     FULL-SCREEN SERVICE ROUTINES    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    A set of routines to manage more easily the full-screen\n  ---------    display of IBM 3270 terminal.\n               (see $FS and $FSDOT assembler macros also)\n\n  Calling sequence : CALL FSRTN,(A,B,C),VL\n  ------------------            (A)\n          Function : write a screen via TPUT, and get a reply via TGET.\n          At entry : A = address of a byte containing the requests\n                         X'00' = TPUT/TGET operation\n                         X'01' = TGET suppress (no reply), only TPUT\n                         X'80' = snap input buffer when received (needs\n                                 a pre-defined data-set with format\n                                 RECFM=VBA,BLKSIZE=1632,LRECL=125\n                                 and pre-allocated to SYSSNAP DD-name)\n                         X'FF' = terminate/exit full-screen mode\n                     B = start address of the screen image\n                     C = address of a fullword containing the screen\n                         image length\n           At exit : R15 = 0 - normal completion (text at disposal)\n                               with R0 = address of AID-byte of\n                                       structured field, or R0 = 0,\n                                and R1 = address of AID-byte\n                                       followed by the 2-bytes cursor\n                                       address, or R1 = 0.\n                         = 4 - buffer shortage (input truncated, but\n                               R0-R1 are set as when R15 = 0)\n                         = 8 - end requested (keys : PA1, PA2 or PA3,\n                               and R0-R1 are set as when R15 = 0)\n                         = 16 - error detected (message sent)\n\n  Assembler macro : @FS A,B,C or @FS A\n  ----------------- @FSO (to define the requests byte)\n\n  Calling sequence : CALL FSRTNR\n  ------------------\n          Function : process the reply text obtained via TGET (it is\n                     mandatory as last call). It pass input to caller\n                     (field by field).\n          At entry : none\n           At exit : R15 = 0 - completion of reply text (no more),\n                           and R1 = 0\n                or : R15 = address of SBA (Set Buffer Address order,\n                           1-byte) followed by the buffer address\n                           (2-bytes), followed by the text read,\n                           and R1 = length of text\n\n  Assembler macro : @FSR\n  -----------------\n1   07/12/93\n                                                      FSRTN     2/3.\n\n  Calling sequence : CALL FSRTNI,(A,B,C),VL\n  ------------------             (A,B)\n                                 (A)\n          Function : set maximum reply text length (buffer) for TGET\n                     (default buffer size is 1K, maximum is 30K).\n                     It obtains the buffer for reply text.\n                     Also, eventually get terminal attributes and/or\n                     declare the desired working screen size (by\n                     default it is 24 x 80).\n          At entry : A = address of a fullword containing the maximum\n                         reply text length (buffer length)\n                         If R1 is zero, or the address is zero, or\n                         the length is zero or negative, then default\n                         size is used\n                     B = address of an 8-bytes field to receive back\n                         the terminal attributes (GTTERM response)\n                     C = address of a 2-bytes field containing the\n                         desired working screen size as below :\n                              1st-byte = rows value, and\n                              2nd-byte = columns value\n           At exit : R15 = 0 - normal completion\n                         = 16 - error detected (message sent)\n\n  Assembler macro : @FSI A,B,C (where A, B and C are optional)\n  ----------------- @FST (to define the terminal attributes response)\n\n  Calling sequence : CALL FSRTNQ,(A),VL\n  ------------------\n          Function : get QUERY reply information (default buffer size\n                     is 1K, maximum is 30K).\n          At entry : A = address of a fullword containing the maximum\n                         QUERY reply length (buffer length)\n                         If R1 is zero, or the address is zero, or\n                         the length is zero or negative, then default\n                         size is used\n           At exit : R15 = 0 - normal completion (QUERY at disposal,\n                               R1 = address of QUERY reply buffer\n                               information and R0 = length)\n                         = 16 - error detected (message sent)\n\n  Assembler macro : @FSQ A or @FSQ\n  -----------------\n1   08/12/93\n                                                      FSRTN     3/3.\n\n  Calling sequence : CALL FSRTNB,(A,B),VL\n  ------------------\n          Function : compute ROW/COLUMN to BUFFER ADDRESS for the\n                     current working screen size\n          At entry : A = address of a 2-bytes field containing the\n                         desired ROW/COLUMN as below :\n                               1st-byte = ROW value, and\n                               2nd-byte = COLUMN value\n                     B = address of a 2-bytes field to receive back\n                         the corresponding BUFFER ADDRESS\n           At exit : R15 = 0 - normal completion\n                         = 16 - error detected (message sent)\n\n  Assembler macro : @FSBA A,B\n  -----------------\n\n  Calling sequence : CALL FSRTNA,(A,B),VL\n  ------------------\n          Function : compute BUFFER ADDRESS to ROW/COLUMN for the\n                     current working screen size\n          At entry : A = address of a 2-bytes field containing the\n                         BUFFER ADDRESS\n                     B = address of a 2-bytes field to receive back\n                         the corresponding ROW/COLUMN as below :\n                               1st-byte = ROW value, and\n                               2nd-byte = COLUMN value\n           At exit : R15 = 0 - normal completion\n                         = 16 - error detected (message sent)\n\n  Assembler macro : @FSRC A,B\n  -----------------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GACTN": {"ttr": 17161, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x0f\\x00\\x882\\x0f\\x164\\x00\\xb0\\x00\\xb0\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-15T00:00:00", "modifydate": "1988-11-15T16:34:00", "lines": 176, "newlines": 176, "modlines": 0, "user": "SYSPAJA"}, "text": "GACT     TITLE 'GET ACCOUNTING INFORMATION SUBROUTINE.'\nGACTN    START 0\n         SPACE 1\n* CALLING SEQUENCE : CALL GACTN,(A,B),VL\n* ------------------            (A)\n*\n*        WHERE : A - IS THE ADDRESS OF A FIELD (FORMAT CL8) INTO\n*                    WHICH THE ACCOUNTING NUMBER INFORMATION FOR\n*                    THE CURRENT JOB IS PLACED. THIS ARGUMENT IS\n*                    MANDATORY BECAUSE INFORMATION IS RETURNED TO\n*                    THE CALLER.\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - ACCOUNTING NUMBER IS RETURNED BACK.\n*                     1 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     2 - JOB CONTROL TABLE (SWA/JCT) NOT FOUND.\n*                     3 - ACCOUNTING CONTROL TABLE (SWA/ACT) NOT FOUND.\n*                     4 - INVALID OR NO ACCOUNTING NUMBER IN ACT.\n*\n* CALLING SEQUENCE : CALL GNAME,(A,B),VL\n* ------------------            (A)\n*\n*        WHERE : A - IS THE ADDRESS OF A FIELD (FORMAT CL20) INTO\n*                    WHICH THE PROGRAMMER'S NAME OF THE CURRENT JOB\n*                    IS PLACED. THIS ARGUMENT IS MANDATORY BECAUSE\n*                    INFORMATION IS RETURNED TO THE CALLER.\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - PROGRAMMER'S NAME IS RETURNED BACK.\n*                     1 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     2 - JOB CONTROL TABLE (SWA/JCT) NOT FOUND.\n*                     3 - ACCOUNTING CONTROL TABLE (SWA/ACT) NOT FOUND.\n*\n* GENERAL NOTICE : THESE ROUTINES ARE REENTRANT.\n* ================\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\nGACTN   AMODE  ANY\nGACTN   RMODE  ANY\n         SPACE 1\n        PRINT  NOGEN\n         SPACE 1\n        CVT    DSECT=YES,LIST=YES\n         SPACE 1\n        IKJTCB LIST=YES\n         SPACE 1\n        IECDSECS (JSCB),EXPAND=YES\n         SPACE 1\n        IEFZB502\nZB502L   EQU   *-ZB502\n         SPACE 1\nJCT      DSECT\n        IEFAJCTB\n         SPACE 1\nGACTN    CSECT                     RESTORE ORIGINAL CSECT.\n         SPACE 1\n        PRINT  GEN\n         EJECT\n        $DEFREG\n         SPACE 2\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\n         EJECT\n         ENTRY GNAME\n         SPACE 1\n         USING *,R15\n         LA    R14,0(R14)          SET GETACT ENTRY.\n         LA    R15,GNAME-GACTN(R15)\n         DROP  R15\n         SPACE 1\nGNAME   $XENT   BASE=R12,ID=GACTN,TYPE=RENT\n         EJECT\n         LR    R7,R14\n         SRL   R7,24\n         LA    R10,MAXERR\n         XR    R8,R8\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    GAR\n         TM    7(R1),X'03'\n         BNZ   ERR1\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         TM    4(R1),X'80'\n         BZ    ERR1\nGAR      L     R9,0(R1)\n         LA    R9,0(R9)\n         XC    0(8,R9),0(R9)\n         L     R2,CVTPTR           GET CVT ADDRESS.\n         USING CVT,R2\n         L     R3,CVTTCBP          POINTS TO IEATCBP.\n         DROP  R2\n         L     R2,4(R3)            CURRENT TCB ADDRESS.\n         USING TCB,R2\n         XR    R3,R3\n         ICM   R3,B'0111',TCBJSCBB JSCB ADDRESS.\n         DROP  R2\n         BZ    ERR2\n         USING IEZJSCB,R3\n         XR    R2,R2\n         ICM   R2,B'0111',JSCBJCTA SWA-BLOCK FOR JCT.\n         DROP  R3\n         BZ    ERR2\n         USING ZB502,R2\n         CLI   SWPID,JCTID         JCT BLOCK ID?\n         BNE   ERR2                NO.\n         CLC   SWPLNGTH,BLKL       BLOCK LENGTH?\n         BNE   ERR2                NO.\n         CLC   SWPACRO,ACROJCT     BLOCK ACRONYM?\n         BNE   ERR2                NO.\n         DROP  R2\n         LA    R2,ZB502L(R2)       JCT.\n         USING INJMJCT,R2\n         CLI   JCTIDENT,JCTID      JCT CONTROL TABLE?\n         BNE   ERR2                NO.\n         L     R3,JCTACTAD         SWA-BLOCK FOR ACT.\n         DROP  R2\n         SRL   R3,8\n         LTR   R3,R3\n         BZ    ERR3\n         USING ZB502,R3\n         CLI   SWPID,ACTID         ACT BLOCK ID?\n         BNE   ERR3                NO.\n         CLC   SWPLNGTH,BLKL       BLOCK LENGTH?\n         BNE   ERR3                NO.\n         CLC   SWPACRO,ACROACT     BLOCK ACRONYM?\n         BNE   ERR3                NO.\n         DROP  R3\n         LA    R3,ZB502L(R3)       ACT.\n         USING IEFAACTB,R3\n         CLI   ACTIDENT,ACTID      ACCOUNTING CONTROL TABLE?\n         BNE   ERR3                NO.\n         LTR   R7,R7\n         BNZ   GNM\n         CLI   ACTJNFLD,1          NUMBER OF ACC. FIELDS?          -EU-\n         BNE   ERR4                NOT SUPPLIED OR MORE THAN ONE.  -EU-\n         CLI   ACTJNFLD+1,8        ACC. NO. FIELD LENGTH?          -EU-\n         BNE   ERR4                INVALID.                        -EU-\n         MVC   0(8,R9),ACTJNFLD+2  GET BACK ACC. NO.               -EU-\n         B     GEX\nGNM      MVC   0(L'ACTPRGNM,R9),ACTPRGNM     GET BACK PRG. NAME.\n         DROP  R3\n         SPACE 1\nGEX      XR    R10,R10             C.C. = 0.\n         B     LEAVE\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nERR4     BCTR  R10,0\n         SPACE 1\nMAXERR   EQU   ((*-ERR1)/2)+1\n         EJECT\nLEAVE    LTR   R8,R8\n         BZ    EXIT\n         ST    R10,0(R8)           STORE INDICATOR.\nEXIT    $XRET  CC=(R10),TYPE=RENT\n         SPACE 2\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\nACROJCT  DC    CL4'JCT '\nACROACT  DC    CL4'ACT '\nBLKL     DC    AL3(JCTLNGTH)\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GACTN$": {"ttr": 17165, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x17\\x06\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T17:06:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//GACTN    JOB (........),'INSTALL  - GACTN -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=GACTN\n//LNK     EXEC PAJILKR,OPT=',RENT'\n//SYSIN     DD *\n  ALIAS   GNAME\n  NAME    GACTN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GACTN@": {"ttr": 17167, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x001\\x001\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      GACTN     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      OBTAIN ACCOUNTING NUMBER       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      OBTAIN PROGRAMMER'S NAME       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL GACTN,(A,B),VL\n  ------------------            (A)\n\n         Where : A - is the address of a field (format CL8) into\n                     which the accounting number information for\n                     the current job is placed. This argument is\n                     mandatory because information is returned to\n                     the caller.\n\n                 B - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - Accounting number is returned back.\n                      1 - Calling sequence or argument alignment error.\n                      2 - Job Control Table (SWA/JCT) not found.\n                      3 - Accounting Control Table (SWA/ACT) not found.\n                      4 - Invalid or no accounting number in ACT.\n\n  Calling sequence : CALL GNAME,(A,B),VL\n  ------------------            (A)\n\n         Where : A - is the address of a field (format CL20) into\n                     which the programmer's name of the current job\n                     is placed. This argument is mandatory because\n                     information is returned to the caller.\n\n                 B - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - Programmer's name is returned back.\n                      1 - Calling sequence or argument alignment error.\n                      2 - Job Control Table (SWA/JCT) not found.\n                      3 - Accounting Control Table (SWA/ACT) not found.\n\n  General notice : These routines are written in reenterable code.\n  ================\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GDGALLR": {"ttr": 17409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x90'\\x8f\\x00\\x90'\\x8f\\x14(\\x01M\\x01M\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-05T00:00:00", "modifydate": "1990-10-05T14:28:00", "lines": 333, "newlines": 333, "modlines": 0, "user": "SYSPAJA"}, "text": "GDGA     TITLE 'GDGALLR -- GDG DYNAMIC ALLOCATION ROUTINE.'\nGDGALLR  START 0\n         SPACE 1\n* PURPOSE :    THIS IS A ROUTINE WHICH DYNAMICALLY ALLOCATES A\n* ---------    GENERATION DATA GROUP MEMBER EXPRESSED WITH THE\n*              RELATIVE GENERATION NUMBER TO THE PROVIDED DDNAME\n*              AND DSNAME (THE DATA-SET IS ALLOCATED WITH DISP=SHR).\n*              CALLING SEQUENCE : CALL GDGALLR,(A,B,C),VL\n*                                              (A,B)\n*              WHERE : A - IS THE ADDRESS OF THE DDNAME (FORMAT CL8).\n*                      B - IS THE ADDRESS OF THE GDG-DSNAME (FORMAT\n*                          CL54). I.E. : ZULU.TEST.DATA(+0)\n*                      C - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                          F BOUNDARY) IF SUPPLIED (OPTIONAL).\n*              AFTER THE CALL, THE RETURN CODE (REGISTER R15) WILL\n*              CONTAIN ONE OF THE FOLLOWING VALUES :\n*                     0 - DATA-SET SUCCESSFULLY ALLOCATED\n*                     4 - DDNAME MISSING OR INVALID\n*                     8 - DSNAME MISSING OR INVALID\n*                    12 - DSNAME IS NOT GDG FORMAT\n*                    16 - DATA-SET IS NOT CATALOGUED\n*                    20 - FREE FILE(DDNAME) HAS FAILED\n*                    24 - DATA-SET ALLOCATION FAILED\n* ORIGIN :     EXTRACTED FROM TAPE CBT 90 MAY, FILE 270.\n* --------     ADAPTED BY MOINIL P.A.\n*              ATTRIBUTES : RE-ENTERABLE\n         SPACE 1\n* ASSIGNMENT OF REGISTERS :\n* =========================\n*        REGISTER  USAGE\n*        --------  -----------------------------------------------\n*               0  AT EXIT, VALUE IS ZERO, UNLESS WHEN\n*                  R15 = 16 - CATALOG RETURN CODE\n*                  R15 = 20 - FREE ERROR/INFO CODES\n*                  R15 = 24 - ALLOCATE ERROR/INFO CODES\n*               1  AT ENTRY, ADDRESS OF PARAMETER LIST / WORK /\n*                  AT EXIT, ADDRESS OF MESSAGE TEXT PRECEEDED BY\n*                  A ONE BYTE MESSAGE TEXT LENGTH\n*          2 -  5  WORK REGISTERS\n*          6 -  8  NOT USED\n*               9  ADDRESS (IF ANY) TO STORE RETURN CODE\n*              10  RETURN CODE VALUE\n*              11  ADDRESS OF WORK AREA\n*              12  BASE REGISTER\n*              13  ADDRESS OF SAVE AREA\n*              14  RETURN ADDRESS\n*              15  ENTRY POINT ADDRESS / RETURN CODE\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12,LV=WKLEN,TYPE=RENT\n         LR    R11,R13\n         USING WKAREA,R11\n         EJECT\n*------- GET PARAMETERS FIELDS ADDRESSES\n         SPACE 1\n         XR    R9,R9\n         LA    R10,MAXERR\n         L     R2,0(R1)            GET DDNAME ADDRESS\n         LTR   R2,R2\n         BZ    EXIT04\n         BM    EXIT08\n         L     R3,4(R1)            GET DSNAME ADDRESS\n         LTR   R3,R3\n         BZ    EXIT08\n         BM    *+L'*+4\n         L     R9,8(R1)            GET RC ADDRESS\n         SPACE 1\n*------- SET THE FOLLOWING DATA FIELDS :\n*        INDDNME  ===> DDNAME PASSED TO THIS ROUTINE\n*        INDSN    ===> DSNAME PASSED TO THIS ROUTINE\n*        FREEUT1A ===> BINARY LENGTH OF DDNAME\n*        FREEUT1B ===> DDNAME PASSED TO THIS ROUTINE\n*        DDAUNT1A ===> BINARY LENGTH OF DDNAME\n*        DDAUNT1B ===> DDNAME PASSED TO THIS ROUTINE\n         SPACE 1\n         CLI   0(R2),C' '\n         BE    EXIT04\n         CLI   0(R3),C' '\n         BE    EXIT08\n         MVC   INDDNME(L'INDDNME),0(R2)\n         MVC   INDSN(L'INDSN),0(R3)\n         LA    R2,INDDNME+L'INDDNME-1\n         LA    R1,L'INDDNME\n         CLI   0(R2),C' '\n         BNE   *+L'*+10\n         BCTR  R2,0\n         BCT   R1,*-10\n         B     EXIT04\n         STCM  R1,B'0011',FREEUT1A\n         MVC   DDAUNT1A,FREEUT1A\n         MVC   FREEUT1B,INDDNME\n         MVC   DDAUNT1B,FREEUT1B\n         LA    R2,INDSN+L'INDSN-1\n         LA    R1,L'INDSN\n         CLI   0(R2),C' '\n         BNE   *+L'*+10\n         BCTR  R2,0\n         BCT   R1,*-10\n         B     EXIT08\n         CLI   0(R2),C')'          CHECK GDG DSNAME\n         BNE   EXIT12\n         BCTR  R2,0\n         BCT   R1,*+L'*+4\n         B     EXIT12\n         CLI   0(R2),C'0'\n         BL    EXIT12\n         BE    CHKNX\n         CLI   0(R2),C'9'\n         BH    EXIT12\nCHKNX    BCTR  R2,0\n         BCT   R1,*+L'*+4\n         B     EXIT12\n         CLI   0(R2),C'0'\n         BL    *+L'*+12\n         CLI   0(R2),C'9'\n         BNH   CHKNX\n         B     EXIT12\n         CLI   0(R2),C'+'\n         BE    *+L'*+8\n         CLI   0(R2),C'-'\n         BNE   *+L'*+10\n         BCTR  R2,0\n         BCT   R1,*+L'*+4\n         B     EXIT12\n         CLI   0(R2),C'('\n         BNE   EXIT12\n         SPACE 1\n*------- RETRIEVE TRUE GDG NAME\n         SPACE 1\n         MVC   CAMLIST(CAMLNGH),CAMSKEL\n         LA    R1,INDSN\n         ST    R1,CAMLIST+4\n         LA    R1,LOCAREA\n         ST    R1,CAMLIST+12\n         XC    LOCAREA(256),LOCAREA\n         XC    LOCAREA+256(L'LOCAREA-256),LOCAREA+256\n        LOCATE CAMLIST\n         LTR   R0,R15              TEST RC=0 ?\n         BNZ   EXIT16              IF NOT ZERO, ERROR\n         SPACE 1\n*------- GENERATE THE FOLLOWING DATA FIELDS :\n*        DSNLEN   ===> LENGTH OF DSN WITH ABSOLUTE GEN NUMBER\n*        DSNME    ===> DSN WITH ABSOLUTE GENERATION NUMBER\n         SPACE 1\n         MVC   DSNME,INDSN\n         LA    R2,DSNME+L'DSNME-1\n         LA    R1,L'DSNME\n         CLI   0(R2),C' '\n         BNE   *+L'*+10\n         BCTR  R2,0\n         BCT   R1,*-10\n         B     EXIT08\n         STCM  R1,B'0011',DSNLEN\n         EJECT\n*------- DYNAMIC ALLOCATION FIRST ATTEMPTS TO FREE THE GIVEN DDNAME.\n*        IF THE DDNAME IS SUCCESSFULLY FREED, THEN IT EXECUTES THE\n*        DYNAMIC ALLOCATION (MACRO DYNALLOC).\n*        HOWEVER, IF THE DDNAME IS NOT SUCCESSFULLY FREED, IT CHECKS\n*        FOR ERROR REASON CODE 0438 (DDNAME NOT FOUND). IF THE ERROR\n*        REASON CODE IS 0438, THEN IT EXECUTES THE DYNAMIC ALLOCATION\n*        (MACRO DYNALLOC), ELSE IT EXITS WITH ERROR.\n         SPACE 1\n         LA    R2,FREEPARM\n         USING S99RBP,R2\n         LA    R3,FREERB\n         ST    R3,S99RBPTR\n         OI    S99RBPTR,S99RBPND\n         USING S99RB,R3\n         XC    S99RB(S99RBEND-S99RB),S99RB\n         MVI   S99RBLN,S99RBEND-S99RB\n         MVI   S99VERB,S99VRBUN    UNALLOCATION\n         MVI   S99FLG11,S99NOMNT\n         LA    R4,FREETUPL\n         ST    R4,S99TXTPP\n         USING S99TUPL,R4\n         LA    R5,FREEUNT1\n         ST    R5,S99TUPTR\n         USING S99TUNIT,R5\n         MVC   S99TUKEY,=AL2(DUNDDNAM)\n         MVC   S99TUNUM,=AL2(1)\n         LA    R4,L'S99TUPTR(R4)\n         LA    R5,FREEUNT2\n         ST    R5,S99TUPTR\n         OI    S99TUPTR,S99TUPLN\n         MVC   S99TUKEY,=AL2(DUNUNALC)\n         MVC   S99TUNUM,=AL2(0)\n         DROP  R2,R4,R5\n         LR    R1,R2\n        DYNALLOC ,                 FREE DDNAME\n         LTR   R15,R15             TEST RC=0 ?\n         BZ    *+L'*+18            IF ZERO, OK\n         CLC   S99ERROR,=XL2'0438' COMPARE ERROR REASON CODE = 0438 ?\n         BE    *+L'*+8             IF YES, OK\n         ICM   R0,B'1111',S99ERROR IF NOT EQUAL, GET ERROR/INFO CODES\n         B     EXIT20\n         DROP  R3\n         LA    R2,DDAPARM\n         USING S99RBP,R2\n         LA    R3,DDARB\n         ST    R3,S99RBPTR\n         OI    S99RBPTR,S99RBPND\n         USING S99RB,R3\n         XC    S99RB(S99RBEND-S99RB),S99RB\n         MVI   S99RBLN,S99RBEND-S99RB\n         MVI   S99VERB,S99VRBAL    ALLOCATION\n         MVI   S99FLG11,S99NOMNT\n         LA    R4,DDATUPL\n         ST    R4,S99TXTPP\n         USING S99TUPL,R4\n         LA    R5,DDAUNIT1\n         ST    R5,S99TUPTR\n         USING S99TUNIT,R5\n         MVC   S99TUKEY,=AL2(DALDDNAM)\n         MVC   S99TUNUM,=AL2(1)\n         LA    R4,L'S99TUPTR(R4)\n         LA    R5,DDAUNIT2\n         ST    R5,S99TUPTR\n         MVC   S99TUKEY,=AL2(DALDSNAM)\n         MVC   S99TUNUM,=AL2(1)\n         LA    R4,L'S99TUPTR(R4)\n         LA    R5,DDAUNIT3\n         ST    R5,S99TUPTR\n         MVC   S99TUKEY,=AL2(DALSTATS)\n         MVC   S99TUNUM,=AL2(1)\n         MVC   S99TULNG,=AL2(1)\n         MVI   S99TUPAR,X'08'      STATUS SHR\n         LA    R4,L'S99TUPTR(R4)\n         LA    R5,DDAUNIT4\n         ST    R5,S99TUPTR\n         OI    S99TUPTR,S99TUPLN\n         MVC   S99TUKEY,=AL2(DALPERMA)\n         MVC   S99TUNUM,=AL2(0)\n         DROP  R2,R4,R5\n         LR    R1,R2\n        DYNALLOC ,                 ALLOC F(DDNAME) DA(DSN) SHR\n         LTR   R15,R15             TEST RC=0 ?\n         BZ    *+L'*+8             IF ZERO, OK\n         ICM   R0,B'1111',S99ERROR IF NOT ZERO, GET ERROR/INFO CODES\n         B     EXIT24\n         DROP  R3\n         EJECT\n*------- NORMAL END OF PROCESSING\n         SPACE 1\n         XR    R10,R10             SET RC 0, OK\nLEAVE    XR    R0,R0\n         LTR   R9,R9\n         BZ    *+L'*+4\n         ST    R10,0(R9)           STORE RC VALUE\n         L     R2,4(R13)\n         L     R1,MSGTXT(R10)\n         STM   R0,R1,20(R2)        SET R0 AND R1\n        $XRET  CC=(R10),LV=WKLEN,TYPE=RENT\n         SPACE 1\n*------- ERROR END OF PROCESSING\n         SPACE 1\nERRNO    EQU   *\nEXIT04   BCTR  R10,0\nEXIT08   BCTR  R10,0\nEXIT12   BCTR  R10,0\nEXIT16   BCTR  R10,0\nEXIT20   BCTR  R10,0\nEXIT24   BCTR  R10,0\nMAXERR   EQU   ((*-ERRNO)/2)+1\n         SLL   R10,2\n         CH    R10,=H'12'\n         BNH   LEAVE\n         B     LEAVE+L'LEAVE\n         EJECT\n*------- DATA CONSTANTS\n         SPACE 1\nCAMSKEL CAMLST NAME,*-*,,*-*\nCAMLNGH  EQU   *-CAMSKEL\nMSGTXT   DC    A(MSG0,MSG4,MSG8,MSG12,MSG16,MSG20,MSG24)\n         DC    AL1(L'MSG0)\nMSG0     DC    C'DATA-SET SUCCESSFULLY ALLOCATED'\n         DC    AL1(L'MSG4)\nMSG4     DC    C'DDNAME MISSING OR INVALID'\n         DC    AL1(L'MSG8)\nMSG8     DC    C'DSNAME MISSING OR INVALID'\n         DC    AL1(L'MSG12)\nMSG12    DC    C'DSNAME IS NOT GDG FORMAT'\n         DC    AL1(L'MSG16)\nMSG16    DC    C'DATA-SET IS NOT CATALOGUED'\n         DC    AL1(L'MSG20)\nMSG20    DC    C'FREE FILE(DDNAME) HAS FAILED'\n         DC    AL1(L'MSG24)\nMSG24    DC    C'DATA-SET ALLOCATION FAILED'\n         SPACE 1\n        LTORG\n         EJECT\n*------- W O R K     A R E A S\n         SPACE 1\nWKAREA   DSECT\n         SPACE 1\n         DS    18F                 SAVE AREA\n         SPACE 1\nCAMLIST  DS    (CAMLNGH)X\n         DS    0D\nLOCAREA  DS    XL268\nINDDNME  DS    CL8\nINDSN    DS    CL54\n         SPACE 1\n*------- DATA STRUCTURE FOR FREE OF DDNAME\n         SPACE 1\nFREEPARM DS    F                   REQUEST BLOCKS FOR SVC 99\nFREERB   DS    0F,((((S99RBEND-S99RB)+3)/4)*4)X\nFREETUPL DS    2F                  TEXT UNITS POINTERS LIST\nFREEUNT1 DS    2H                  TEXT UNITS\nFREEUT1A DS    H\nFREEUT1B DS    CL8\nFREEUNT2 DS    2H\n         SPACE 1\n*------- DATA STRUCTURE FOR DYNAMIC ALLOCATION\n         SPACE 1\nDDAPARM  DS    F                   REQUEST BLOCKS FOR SVC 99\nDDARB    DS    0F,((((S99RBEND-S99RB)+3)/4)*4)X\nDDATUPL  DS    4F                  TEXT UNITS POINTERS LIST\nDDAUNIT1 DS    2H                  TEXT UNITS\nDDAUNT1A DS    XL2\nDDAUNT1B DS    CL8\nDDAUNIT2 DS    2H\nDSNLEN   DS    XL2\nDSNME    DS    CL44\nDDAUNIT3 DS    3H,XL1\nDDAUNIT4 DS    2H\n         SPACE 1\nWKLEN    EQU   (((*-WKAREA)+7)/8)*8\n         SPACE 2\n        PRINT  NOGEN\n        IEFZB4D0 ,                 MAPS SVC-99 BLOCKS\n        IEFZB4D2\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GDGALLR$": {"ttr": 17415, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x145\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:35:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//GDGALLR  JOB (........),'INSTALL  - GDGALLR -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=6\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=GDGALLR\n//LNK     EXEC PAJILKR,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   GDGALLR\n  NAME    GDGALLR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GDGALLR@": {"ttr": 17417, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14U\\x00I\\x00I\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:55:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "SYSPAJA"}, "text": "1   25/09/90\n                                                      GDGALLR   1/2\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           GDGALLR ROUTINE           * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Routine :      GDGALLR\n  Origin :       Extracted from tape CBT 90 MAY, file 270\n  Language :     Assembler\n  Attributes :   Re-enterable\n  Function :     GDG dynamic allocation routine.\n  Purpose :      This is a routine which dynamically allocates a\n                 generation data group member expressed with the\n                 relative generation number to the provided DDNAME\n                 and DSNAME (the data-set is allocated with DISP=SHR).\n\n  Calling sequence : CALL GDGALLR,(A,B,C),VL\n                                  (A,B)\n             where : A - is the address of the DDNAME (format CL8).\n                     B - is the address of the GDG-DSNAME (format\n                         CL54). I.e. : ZULU.TEST.DATA(+0)\n                     C - receives the return code (format fullword -\n                           F boundary) if supplied (optional).\n\n  After the CALL, the return code (register 15) will contain one of the\n             following values :\n             Return code   Meaning\n             -----------   --------------------------------------------\n                  0        Data-set successfully allocated\n                  4        DDNAME missing or invalid\n                  8        DSNAME missing or invalid\n                 12        DSNAME is not GDG format\n                 16        Data-set is not catalogued\n                 20        FREE FILE(DDNAME) has failed\n                 24        Data-set allocation failed\n             the register 1 always contain the address of a message\n             text as below :\n                           DC   AL1(L'MSG)\n             R1 ---> MSG   DC   C'...message text...'\n             and the register 0 always contain a value zero, unless\n             when the register 15 is :\n             16 then it contains the CATALOG return code\n             20 then it contains the FREE error/info codes\n             24 then it contains the ALLOCATE error/info codes\n1   25/09/90\n                                                      GDGALLR   2/2\n\n  To use this routine from an ASSEMBLER program, you may do the\n  following, i.e. :\n                ...\n                CALL  GDGALLR,(DDNAME,DSNAME),VL\n                BCTR  R1,0                To display message\n                XR    R14,R14\n                IC    R14,0(R1)\n                BCT   R14,*+L'*+6\n                MVC   MSG1+1(*-*),1(R1)\n                EX    R14,*-6\n                ST    R0,FULLWRD          To display R0 just in case\n                UNPK  MSG2+4(9),FULLWRD(5)\n                TR    MSG2+4(8),TRTBL-C'0'\n                MVI   MSG2+12,C' '\n                LTR   R15,R15             Test completion code\n                ...\n       FULLWRD  DC    F'0'                A work word\n       DDNAME   DC    CL8'...'            The DDname\n       DSNAME   DC    CL54'...'           The GDG-DSname\n       MSG1     DC    CL60' '             The first line message\n       MSG2     DC    CL60' R0= '         The second line message\n       TRTBL    DC    C'0123456789ABCDEF' HEX-print translate table\n                ...\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GDGRESE$": {"ttr": 17420, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10&\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:26:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//GDGRESET JOB (........),'INSTALL - GDGRESET -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                TXREAD    TXPRINT                                  *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=GDGRESET\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  INCLUDE SYSADD(READ,PRINT)\n  ENTRY   GDGRESET\n  NAME    GDGRESET(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GDGRESE@": {"ttr": 17422, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x915\\x1f\\x00\\x915\\x1f\\x14\\x06\\x003\\x003\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-12-17T00:00:00", "modifydate": "1991-12-17T14:06:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "SYSPAJA"}, "text": "1   16/10/91\n                                                      GDGRESET  1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       GDG   RESET   PROGRAM.        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT tape 91 MAR, file 124.\n  ------------ (RESETGDG program, GDGUTIL ISPF procedure and GDGUTILP\n               ISPF panel)\n               Modified by : MOINIL P.A. (8 OCT 1991)\n               (members were renamed : PAJCGDG, PAJGDG and GDGRESET)\n\n  Purpose :    This program is used with the GDGUTIL (PAJCGDG) CLIST\n  ---------    and the GDGUTILP (PAJGDG) ISPF panel to modify the\n               number of entries being kept for a GDG Index.\n\n  Function :   Reset number of entries in a GDG (MVS version operates\n  ----------       on both CVOLS and VSAM/ICF catalogs).\n               Input existing GDG name at SYSIN (DD-name=GDGIN) :\n                   GDG name (maximum 44 characters long) followed by\n                     the new number of entries (maximum 3 digits long),\n                     eventually followed by the EM/NE (EMPTY/NOEMPTY)\n                     and/or SC/NS (SCRATCH/NOSCRATCH) option(s).\n                   These must be separated by one space at least, and\n                     in the range of columns 1 - 72 included.\n               Entries must be > 2 and < 255.\n               Multiple records may be input.\n               Default options are \"NOEMPTY\" and \"SCRATCH\".\n               Any error will cause further records not be processed.\n               Entering DLX in entries field will cause Index deletion.\n               ** WARNING ** As of yet, this program will not handle\n                   data-sets reseding on more than 20 volumes.\n                   Only the first 20 volumes will be recataloged.\n                   So, for security reasons, you should first list\n                   the GDG you are planning to reset.\n               This program always scratches DISK data-sets as it\n                   uncataloges them, unless specifically requested by\n                   the use of option NS (NOSCRATCH).\n\n  Execution JCL :  //...      JOB ...\n                   //RESET   EXEC PGM=GDGRESET\n                   //GDGIN     DD *\n                     ABC.TEST.GDG  255 SC NE\n                   /*\n                   //GDGOUT    DD SYSOUT=*\n                   //SYSSNAP   DD SYSOUT=* (optional, if SNAP desired)\n                   //SYSTEST   DD SYSOUT=* (optional, if TEST desired)\n                   //SYSUDUMP  DD SYSOUT=* (optional, if DUMP desired)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDGRESET": {"ttr": 17424, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91(\\x9f\\x00\\x91(\\x9f\\x13@\\x03\\x89\\x03\\x89\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-16T00:00:00", "modifydate": "1991-10-16T13:40:00", "lines": 905, "newlines": 905, "modlines": 0, "user": "SYSPAJA"}, "text": "GDGR     TITLE '--- GDG RESET PROGRAM ---'\n        PRINT  OFF\n         MACRO\n&NAME   @TEST  &WNO\n&NAME    TM    SWITCH,SWTST\n         BZ    *+L'*+6\n         BAS   R8,TRTEST\n         DC    H'&WNO'\n         MEND\n        PRINT  ON\nGDGRESET START 0\n         SPACE 1\n* PURPOSE :    THIS PROGRAM IS USED WITH THE GDGUTIL CLIST AND THE\n*              GDGUTILP ISPF PANEL TO MODIFY THE NUMBER OF ENTRIES\n*              BEING KEPT FOR A GDG INDEX.\n* AUTHOR(S) :  THIS CODE WAS DOWNLOADED FROM THE NASPA BULLETIN BOARD\n*              AND MODIFIED SLIGHTLY (DDNAMES AND WTO MSG) FOR USE\n*              AT THE WILSON STREET REGIONAL COMPUTING CENTER\n*                  P.O. BOX 7850 - ROOM B174\n*                  ONE WEST WILSON STREET\n*                  MADISON, WI 53707-7850\n*              - J.MARTIN 4/26/89(608) 266-9525\n*\n* FUNCTION :   RESET NUMBER OF ENTRIES IN A GDG (MVS VERSION OPERATES\n*                  ON BOTH CVOLS AND VSAM/ICF CATALOGS).\n*              INPUT EXISTING GDG NAME AT SYSIN (DD-NAME=GDGIN) :\n*                  GDG NAME (MAXIMUM 44 CHARACTERS LONG) FOLLOWED BY\n*                    THE NEW NUMBER OF ENTRIES (MAXIMUM 3 DIGITS LONG),\n*                    EVENTUALLY FOLLOWED BY THE EM/NE (EMPTY/NOEMPTY)\n*                    AND/OR SC/NS (SCRATCH/NOSCRATCH) OPTION(S).\n*                  THESE MUST BE SEPARATED BY ONE SPACE AT LEAST, AND\n*                    IN THE RANGE OF COLUMNS 1 - 72 INCLUDED.\n*              ENTRIES MUST BE > 2 AND < 255.\n*              MULTIPLE RECORDS MAY BE INPUT.\n*              DEFAULT OPTIONS ARE \"NOEMPTY\" AND \"SCRATCH\".\n*              ANY ERROR WILL CAUSE FURTHER RECORDS NOT BE PROCESSED.\n*              ENTERING DLX IN ENTRIES FIELD WILL CAUSE INDEX DELETION.\n*              ** WARNING ** AS OF YET, THIS PROGRAM WILL NOT HANDLE\n*                  DATA-SETS RESIDING ON MORE THAN 20 VOLUMES.\n*                  ONLY THE FIRST 20 VOLUMES WILL BE RECATALOGED.\n*                  SO, FOR SECURITY REASONS, YOU SHOULD FIRST LIST\n*                  THE GDG YOU ARE PLANNING TO RESET.\n*              THIS PROGRAM ALWAYS SCRATCHES DISK DATA-SETS AS IT\n*                  UNCATALOGES THEM, UNLESS SPECIFICALLY REQUESTED BY\n*                  THE USE OF OPTION NS (NOSCRATCH).\n*\n* EXECUTION JCL :  //...      JOB ...\n*                  //RESET   EXEC PGM=GDGRESET\n*                  //GDGIN     DD *\n*                    ABC.TEST.GDG  255 SC NE\n*                  /*\n*                  //GDGOUT    DD SYSOUT=*\n*                  //SYSSNAP   DD SYSOUT=* (OPTIONAL, IF SNAP DESIRED)\n*                  //SYSTEST   DD SYSOUT=* (OPTIONAL, IF TEST DESIRED)\n*                  //SYSUDUMP  DD SYSOUT=* (OPTIONAL, IF DUMP DESIRED)\n*\n* ORIGIN :     EXTRACTED FROM TAPE CBT 91 MAR, FILE 124.\n*              (GDGUTIL, GDGUTILP AND RESETGDG)\n*              MODIFIED BY : MOINIL P.A. (8 OCT 1991)\n*              (MEMBERS WERE RENAMED : PAJCGDG, PAJGDG AND GDGRESET)\n         EJECT\n        $DEFREG\n        $XENT  BASE=(R11,R12)\n         EJECT\n*------- INITIALIZATION\n         SPACE 1\n         USING PSA,R0\n         L     R2,PSAAOLD\n         DROP  R0\n         USING ASCB,R2\n         L     R3,ASCBASXB\n         DROP  R2\n         USING ASXB,R3\n         L     R2,ASXBSENV\n         DROP  R3\n         USING ACEE,R2\n         MVC   DEFCOW,ACEEUSRI     SET USER ID\n         DROP  R2\n         L     R0,TABLEN           GET WORK AREA\n        GETMAIN R,LV=(0)\n         ST    R1,TABADDR          SET THE WORKAREA ADDRESS\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\n         L     R1,ATIOT            SEARCH SNAP DD\n         USING TIODSECT,R1\nLOOPSSN  CLC   TIOELNGH(4),=XL4'0'\n         BE    RDREC\n         CLC   TIOEDDNM(L'DCBDDNAM),SNAPPER+(DCBDDNAM-IHADCB)\n         BNE   *+L'*+8\n         OI    SWITCH,SWSNP\n         B     NEXTSSN\n         CLC   TIOEDDNM(L'DCBDDNAM),DDTEST\n         BNE   NEXTSSN\n         OI    SWITCH,SWTST\nNEXTSSN  XR    R0,R0\n         IC    R0,TIOELNGH\n         ALR   R1,R0\n         B     LOOPSSN\n         DROP  R1\n         SPACE 1\n*------- GET AND SCAN AN INPUT REQUEST\n         SPACE 1\nRDREC   $READ  INAREA,DDIN         READ INPUT REC\n         LTR   R15,R15\n         BM    BYE\n         BP    RDERR\n         LM    R1,R3,=A(INREQ,1,INREQ+L'INREQ-1)\n         CLI   0(R1),C' '\n         BNE   *+L'*+8\n         BXLE  R1,R2,*-8\n         B     RDREC               NONE, SKIP\n         MVI   GDGNAME,C' '\n         MVC   GDGNAME+1(L'GDGNAME-1),GDGNAME\n         MVC   ENTRIES(L'ENTRIES),GDGNAME\n         MVI   ONEMP,C'N'          SET DEFAULT OPTIONS\n         MVI   ONSCR,C' '\n         NI    SWITCH,255-SWDLX-SWNOS\n         LA    R0,L'GDGNAME\n         LA    R15,GDGNAME\nLOOPGDG  MVC   0(1,R15),0(R1)\n         BXLE  R1,R2,*+L'*+4\n         B     NOMORE\n         CLI   0(R1),C' '\n         BE    *+L'*+20\n         LA    R15,1(R15)\n         BCT   R0,LOOPGDG\n         B     GDGTLG\n         CLI   0(R1),C' '\n         BNE   *+L'*+8\n         BXLE  R1,R2,*-8\n         B     NOMORE\n         LA    R0,L'ENTRIES\n         XR    R15,R15\n         ICM   R15,B'0011',=CL2'00'\nLOOPENT  SLL   R15,8\n         IC    R15,0(R1)\n         BXLE  R1,R2,*+L'*+4\n         B     NOMORE\n         CLI   0(R1),C' '\n         BE    *+L'*+8\n         BCT   R0,LOOPENT\n         B     ENTTLG\n         STCM  R15,B'0111',ENTRIES\nLOOPCNT  BXLE  R1,R2,*+L'*+4\n         B     NOMORE\n         CLI   0(R1),C' '\n         BE    *-12\n         CLC   0(2,R1),=CL2'EM'\n         BE    OPTEMP\n         CLC   0(2,R1),=CL2'NE'\n         BE    OPTNEMP\n         CLC   0(2,R1),=CL2'SC'\n         BE    OPTSCR\n         CLC   0(2,R1),=CL2'NS'\n         BNE   OPTINV\n         CLI   ONSCR,C' '\n         BNE   OPTINV\n         MVI   ONSCR,C'N'\n         B     SKPFLD\nOPTSCR   CLI   ONSCR,C' '\n         BE    SKPFLD\n         B     OPTINV\nOPTNEMP  CLI   ONEMP,C'N'\n         BE    SKPFLD\n         B     OPTINV\nOPTEMP   CLI   ONEMP,C'N'\n         BNE   OPTINV\n         MVI   ONEMP,C' '\nSKPFLD   LA    R1,1(R1)\n         B     LOOPCNT\nNOMORE   CLI   ONSCR,C'N'\n         BNE   *+L'*+4\n         OI    SWITCH,SWNOS\n         MVC   MSGNAME(L'INREQ),INREQ MOVE THE RECORD TO OUTAREA\n         MVI   MSGCC,C'0'\n         BAS   R8,WRITPRT          WRITE THE RECORD TO REPORT\n         CLC   ENTRIES,=C'DLX'     IS THIS A DELETE REQUEST ?\n         BNE   *+L'*+8             NO\n         OI    SWITCH,SWDLX        YES, SAY IT\n         B     *+L'*+20\n         CLC   ENTRIES,=C'001'     IS ENTRIES LESS THAN 1 ?\n         BL    BADENT              YES, TERMINATE\n         CLC   ENTRIES,=C'255'     IS ENTRIES GREATER THAN 255 ?\n         BH    BADENT              YES, TERMINATE\n         SPACE 1\n*------- DELETE ALL THE GDG'S WITH RETAIN IF MODIFY REQUEST\n         SPACE 1\n         TM    SWITCH,SWDLX        IS THIS A DELETE REQUEST ?\n         BO    DELREQ              YES, SKIP\n         PACK  PWORK,ENTRIES       CONVERT ENTRIES TO BINARY\n         CVB   R9,PWORK\n         STC   R9,BGDG+3           STORE # ENTRIES IN BLDG LIST\nDELREQ   MVC   GSVNAME,GDGNAME     SAVE NAME FOR LATER BLDG\n         MVC   GRLNAME,GDGNAME     COPY NAME\n         TRT   GRLNAME,BLANKTBL    FIND ADDRESS OF BLANK\n         MVC   0(3,R1),=C'(0)'     INSERT RELATIVE GENERATION REF\n        LOCATE LOCNAME             FIND OUT WHAT KIND OF CATALOG\n        @TEST  0\n         STCM  R1,B'1000',CATYPE   STORE THE HIGH ORDER BYTE\n         L     R2,CVTPTR           GET ADDRESS OF CVT\n         USING CVT,R2\n         TM    CVTDCB,CVT2SPS      IS THIS VS1 ?\n         BZ    *+L'*+4             NO, SKIP\n         MVI   CATYPE,CVOLTYPE     IF VS1 THIS MUST BE CVOL\n         DROP  R2\n         TM    SWITCH,SWDLX        IS THIS A DELETE REQUEST ?\n         BO    UNCREST             YES, GO DELETE\n         L     R10,TABADDR         GET THE WORKAREA ADDRESS\n         USING TBENTRY,R10\nLOCLOOP  MVC   GDGNAME,GRLNAME     SET RELATIVE GENERATION REF\n        LOCATE LOCNAME             LOCATE GENERATION(0)\n        @TEST  1\n         LTR   R15,R15             WAS LOCATE SUCCESSFULL ?\n         BZ    *+L'*+10            YES, UNCATALOG IT\nSETLRL   MVC   TNAME(4),=XL4'FFFFFFFF' WRITE FF'S TO INDICATE END TABLE\n         B     LASTRL              MUST HAVE BEEN THE LAST ONE\n        CATALOG UNCAT              UNCAT THE DATA-SET\n        @TEST  2\n         LA    R8,UNCAT-8          SET ADDRESS OF TAG FOR ERROR MSG\n         LTR   R15,R15             WAS UNCAT SUCCESSFULL ?\n         BNZ   ERRSNP              NO, ERROR\n         MVC   MSGNAME,GDGNAME     SET UP MSG LINE\n         MVC   MSGAREA(L'UNCATMSG),UNCATMSG\n         BAS   R8,WRITPRT          GO WRITE MSG TO REPORT\n         LA    R4,TCATBLK          GET READY FOR MVCL\n         LA    R5,265              LENGTH IS 265\n         LA    R6,CATBLK\n         LA    R7,265\n         MVCL  R4,R6               MOVE BLK INTO TABLE\n         MVC   TNAME,GDGNAME       MOVE NAME INTO TABLE\n         LA    R10,TBLENTRY(,R10)  INCREMENT TABLE ADDRESS\n         BCT   R9,LOCLOOP          LOOP\n         MVC   TNAME(4),=XL4'FFFFFFFF' WRITE FF'S TO INDICATE END TABLE\n         DROP  R10\nUNCREST  MVC   GDGNAME,GRLNAME     SET RELATIVE GENERATION REF\n        LOCATE LOCNAME             GET THE ABSOLUTE GEN NUMBER\n        @TEST  3\n         LTR   R15,R15             WAS LOCATE SUCCESSFULL ?\n         BNZ   LASTRL              NO, MUST HAVE BEEN THE LAST ONE\n        CATALOG UNCAT              GO UNCAT THIS GEN\n        @TEST  4\n         LA    R8,UNCAT-8          SET ADDRESS OF TAG FOR ERROR MSG\n         LTR   R15,R15             WAS UNCAT SUCCESSFULL ?\n         BNZ   ERROR               NO, ERROR\n         MVC   MSGNAME,GDGNAME     SET UP MSG LINE\n         MVC   MSGAREA(L'UNCATMSG),UNCATMSG\n         BAS   R8,WRITPRT          GO WRITE MSG TO REPORT\n         TM    SWITCH,SWNOS        NO SCRATCH REQUESTED ?\n         BO    UNCREST             YES, NEXT GEN\n         LH    R3,CATBLK\n         LA    R4,CATBLK+2\nLOOPSCR  CLI   2(R4),UCB3DACC      DIRECT ACCESS DEVICE CLASS ?\n         BNE   DONTSCR             NO, DON'T SCRATCH THIS\n         MVC   SCRDC(L'SCRDC+L'SCRVSN),0(R4)\n         XC    SCRSC,SCRSC\n         XR    R0,R0\n        SCRATCH SCRNAME            GO SCRATCH THIS GEN\n        @TEST  5\n         LA    R8,SCRNAME-8        SET ADDRESS OF TAG FOR ERROR MSG\n         LTR   R15,R15             WAS SCRATCH SUCCESSFULL ?\n         BNZ   ERROR               NO, ERROR\n         MVC   MSGNAME,GDGNAME     SET UP MSG LINE\n         MVC   MSGAREA(L'SCRMSG),SCRMSG\n         MVC   MSGAREA+L'SCRMSG+1(L'SCRVSN),SCRVSN\n         BAS   R8,WRITPRT          GO WRITE MSG TO REPORT\nDONTSCR  LA    R4,L'SCRDC+L'SCRVSN(R4)\n         BCT   R3,LOOPSCR          LOOP\n         B     UNCREST             NEXT GEN\nLASTRL   TM    CATYPE,CVOLTYPE     IS THIS A CVOL ?\n         BZ    ICFDEL              NO, USE IDCAMS\n        INDEX  DELIDX              DELETE THE INDEX\n        @TEST  6\n         LA    R8,DELIDX-8         SET ADDRESS OF TAG FOR ERROR MSG\n         LTR   R15,R15             WAS DELETE SUCCESSFULL ?\n         BNZ   ERROR               NO, ERROR\n         B     DELOK\nICFDEL   MVC   DELCNM(L'DELCNM),GSVNAME MOVE THE GDG NAME INTO STMT\n         LA    R1,IDCDEL           POINT R1 TO THE PARM LIST\n         L     R15,=V(IDCAMSX)     GET THE ADDR OF THE IDCAMS INTERFACE\n         BASR  R14,R15             GO UNCAT\n         LTR   R15,R15             SUCCESSFULL ?\n         BNZ   IDCERROR            NO, BRANCH TO HANDLE IDCAMS ERROR\nDELOK    MVC   MSGNAME,GSVNAME     SET UP MSG LINE\n         MVC   MSGAREA(L'DELXMSG),DELXMSG\n         BAS   R8,WRITPRT          GO WRITE MSG TO REPORT\n         TM    SWITCH,SWDLX        IS THIS A DELETE REQUEST ?\n         BO    RDREC               YES, END\n         SPACE 1\n*------- RECATALOG THE NEEDED GDG'S\n         SPACE 1\n         TM    CATYPE,CVOLTYPE     IS THIS A CVOL ?\n         BZ    ICFDEF              NO, USE IDCAMS\n         LA    R1,64               SCRATCH (DELETE) OPTION\n         TM    SWITCH,SWNOS        NO SCRATCH REQUESTED ?\n         BZ    *+L'*+2             NO\n         XR    R1,R1               YES, SET THE NOSCRATCH OPTION\n         STC   R1,BGDG+2\n        INDEX  BGDG                GO BUILD NEW INDEX USING NEW ENTRIES\n        @TEST  7\n         LA    R8,BGDG-8           SET ADDRESS OF TAG FOR ERROR MSG\n         LTR   R15,R15             SUCCESSFULL ?\n         BNZ   ERROR               NO, ERROR\n         B     INDEXOK\nICFDEF   MVC   DEFCNM(L'DEFCNM),GSVNAME MOVE IN THE GDG NAME\n         MVC   DEFCLM,ENTRIES      MOVE IN THE LIMIT\n         MVC   DEFCEM,ONEMP        MOVE IN THE EMPTY OPTION\n         MVC   DEFCSC,ONSCR        MOVE IN THE SCRATCH OPTION\n         LA    R1,IDCDEF           POINT R1 TO THE PARM LIST\n         L     R15,=V(IDCAMSX)     GET THE ADDR OF THE IDCAMS INTERFACE\n         BASR  R14,R15             GO UNCAT\n         LTR   R15,R15             SUCCESSFULL ?\n         BNZ   IDCERROR            NO, BRANCH TO HANDLE IDCAMS ERROR\nINDEXOK  MVC   MSGNAME,GSVNAME     SET UP MSG LINE\n         MVC   MSGAREA(L'BLDGMSG),BLDGMSG\n         MVC   MSGAREA+L'BLDGMSG(L'ENTRIES),ENTRIES\n         BAS   R8,WRITPRT          GO WRITE MSG TO REPORT\n         L     R10,TABADDR         LOAD START ADDRESS OF SAVE TABLE\n         USING TBENTRY,R10\n         CLC   TNAME(4),=XL4'FFFFFFFF' IS THERE ANYTHING TO RECATALOG ?\n         BE    RDREC               NO, END\nCATLOOP  MVC   GDGNAME,TNAME       MOVE IN NAME\n         MVC   CATBLK(242),TVOLLIST MOVE IN VOLUME LIST\n        CATALOG CATNAME            GO CATALOG THE DATA-SET\n        @TEST  8\n         LA    R8,CATNAME-8        SET ADDRESS OF TAG FOR ERROR MSG\n         LTR   R15,R15             SUCCESSFULL ?\n         BNZ   ERRSNP              NO, ERROR\n         MVC   MSGNAME,GDGNAME     SET UP MSG LINE\n         MVC   MSGAREA(L'CATMSG),CATMSG\n         BAS   R8,WRITPRT          GO WRITE MSG TO REPORT\n         LA    R10,TBLENTRY(,R10)  INCREMENT TABLE ADDRESS\n         CLC   TNAME(4),=XL4'FFFFFFFF' IS THIS THE LAST ENTRY ?\n         BNE   CATLOOP             NO, LOOP\n         B     RDREC               YES, END\n         DROP  R10\n         SPACE 1\n        PRINT  NOGEN\nRDERR    MVC   MSGNAME(L'RDRMSG),RDRMSG READ INPUT RECORDS MSG\n         B     WERRMSG\nGDGTLG   MVC   MSGNAME(L'GDGMSG),GDGMSG GDG NAME TOO LONG MSG\n         B     WERRMSG\nENTTLG   MVC   MSGNAME(L'ENTMSG),ENTMSG ENTRIES TOO LONG MSG\n         B     WERRMSG\nOPTINV   MVC   MSGNAME(L'OPTMSG),OPTMSG INVALID OPTION MSG\n         B     WERRMSG\nBADENT   MVC   MSGNAME(L'INVMSG),INVMSG WRITE INVALID ENTRIES MSG\nWERRMSG  BAS   R8,WRITPRT\n         MVC   CCODE,=F'99'\n         B     TERM\nERRSNP   OI    SWITCH,SWSNR        SET SNAP REQUEST\nERROR    ST    R15,CCODE           STORE RETURN CODE FROM CAMLST\n         MVC   MSGNAME(L'CAMLMSG),CAMLMSG\n         MVC   MSGNAME+L'CAMLMSG+1(8),0(R8) MOVE IN THE TAG\n         MVC   MSGNAME+L'CAMLMSG+10(6),=CL6'- RC ='\n         CVD   R15,PWORK\n         MVC   MSGNAME+L'CAMLMSG+16(4),=XL4'40202120'\n         ED    MSGNAME+L'CAMLMSG+16(4),PWORK+L'PWORK-2\n         BAS   R8,WRITPRT\n         B     SNAPIT\nIDCERROR ST    R15,CCODE           SAVE RETURN CODE FROM IDCAMS\n         MVC   MSGNAME(L'IDCSMSG),IDCSMSG\n         CVD   R15,PWORK\n         MVC   MSGNAME+L'IDCSMSG(4),=XL4'40202120'\n         ED    MSGNAME+L'IDCSMSG(4),PWORK+L'PWORK-2\n         BAS   R8,WRITPRT\nSNAPIT   TM    SWITCH,SWSNP+SWSNR\n         BNO   TERM\n         LA    R9,TBBL(,R10)\n        OPEN   (SNAPPER,OUTPUT)\n         TM    SNAPPER+(DCBOFLGS-IHADCB),DCBOFOPN\n         BO    EXSNP\n         MVC   MSGNAME(L'SNPOMSG),SNPOMSG\n         B     PSNP\nEXSNP   SNAP   DCB=SNAPPER,PDATA=(PSW,REGS),STORAGE=(CATBLK,BLANKTBL)\n         LTR   R15,R15\n         BNZ   ESNP\n        SNAP   DCB=SNAPPER,STORAGE=((R10),(R9))\n         LTR   R15,R15\n         BZ    CLSNP\nESNP     OI    SWITCH,SWSNE\n         MVC   MSGNAME(L'SNPEMSG),SNPEMSG\n         CVD   R15,PWORK\n         MVC   MSGNAME+L'SNPEMSG(4),=XL4'40202120'\n         ED    MSGNAME+L'SNPEMSG(4),PWORK+L'PWORK-2\n         BAS   R8,WRITPRT\nCLSNP   CLOSE  (SNAPPER)\n         LTR   R15,R15\n         BZ    TSNP\n         MVC   MSGNAME(L'SNPCMSG),SNPCMSG\n         B     PSNP\nTSNP     TM    SWITCH,SWSNE\n         BO    TERM\n         MVC   MSGNAME(L'SNPTMSG),SNPTMSG\nPSNP     BAS   R8,WRITPRT\nTERM     MVC   MSGNAME(L'TERMMSG),TERMMSG WRITE TERMINATION MESSAGE\n         MVI   MSGCC,C'0'\n         BAS   R8,WRITPRT\n        PRINT  GEN\n         SPACE 1\nBYE     $RCLOSE\n         OC    CCODE,CCODE\n         BNZ   *+L'*+4\n         ST    R15,CCODE\n        $PCLOSE\n         OC    CCODE,CCODE\n         BNZ   *+L'*+4\n         ST    R15,CCODE\n         ICM   R1,B'1111',TABADDR  FREE THE WORK AREA\n         BZ    LEAVE\n         L     R0,TABLEN\n        FREEMAIN R,LV=(0),A=(1)\nLEAVE    L     R15,CCODE\n        $XRET  CC=(R15)\n         SPACE 1\n*------- OUTPUT PRINT ROUTINE\n*              \"OUTAREA\" = ADDRESS OF LINE TO BE PRINTED\n*              R8 = LINK REGISTER\n         SPACE 1\nWRITPRT  CP    NLN,=PL2'+56'\n         BL    WRTPN\n         AP    NPG,=PL1'+1'\n         MVC   TIT1A,=XL6'402020202120'\n         ED    TIT1A,NPG\n        $PRINT TIT1,,DDOUT\n         LTR   R15,R15\n         BNZ   WRTPX\n         ZAP   NLN,=PL1'+1'\n         MVI   MSGCC,C'0'\nWRTPN   $PRINT OUTAREA,,DDOUT\n         LTR   R15,R15\n         BNZ   WRTPX\n         AP    NLN,=PL1'+1'\n         CLI   MSGCC,C'0'\n         BNE   *+L'*+6\n         AP    NLN,=PL1'+1'\n         MVI   OUTAREA,C' '        CLEAR OUTAREA\n         MVC   OUTAREA+1(OUTAL-1),OUTAREA\n         BR    R8                  RETURN\nWRTPX    TM    SWITCH,SWIDC        IDCAMS I/O ROUTINE CALL\n         BO    *+L'*+8             YES, RETURN TO IT\n         ST    R15,CCODE           NO, WRITE OUTPUT ERROR\n         B     BYE\n         NI    SWITCH,255-SWIDC    SAY ERROR OCCURED\n         BR    R8\n         SPACE 1\n*------- OUTPUT TRACE TEST ROUTINE\n*              R8 = LINK REGISTER\n         SPACE 1\nTRTEST   STM   R14,R1,SVREGS\n         LH    R1,0(R8)\n         LTR   R1,R1\n         BM    TRNONE\n         CH    R1,=H'8'\n         BH    TRNONE\n         CVD   R1,PWORK\n         MVC   LTR1A,=XL4'40202120'\n         ED    LTR1A,PWORK+L'PWORK-2\n         UNPK  LTR1B(L'LTR1B+1),SVREGS(5)\n         TR    LTR1B(L'LTR1B),TRTAB-C'0'\n         MVI   LTR1B+L'LTR1B,C' '\n         UNPK  LTR1C(L'LTR1C+1),SVREGS+4(5)\n         TR    LTR1C(L'LTR1C),TRTAB-C'0'\n         MVI   LTR1C+L'LTR1C,C' '\n         UNPK  LTR1D(L'LTR1D+1),SVREGS+8(5)\n         TR    LTR1D(L'LTR1D),TRTAB-C'0'\n         MVI   LTR1D+L'LTR1D,C' '\n         UNPK  LTR1E(L'LTR1E+1),SVREGS+12(5)\n         TR    LTR1E(L'LTR1E),TRTAB-C'0'\n         MVI   LTR1E+L'LTR1E,C' '\n         MVI   LTR1F,C' '\n         MVC   LTR1F+1(L'LTR1F-1),LTR1F\n         SLL   R1,2\n         B     *+L'*(R1)\n         B     TRMG                0\n         B     TRMG                1\n         B     TRMG                2\n         B     TRMG                3\n         B     TRMG                4\n         B     TRMG                5\n         B     TRMS                6\n         B     TRMS                7\n         B     TRMG                8\nTRMG     MVC   LTR1F,GDGNAME\n         B     TRNULL\nTRMS     MVC   LTR1F,GSVNAME\nTRNULL  $PRINT LTR1,,DDTEST\n         LTR   R15,R15\n         BNZ   TRERR\n         LH    R1,0(R8)\n         SLL   R1,2\n         B     *+L'*(R1)\n         B     TRCB                0\n         B     TRCB                1\n         B     TRNONE              2\n         B     TRCB                3\n         B     TRNONE              4\n         B     TRVB                5\n         B     TRNONE              6\n         B     TRNONE              7\n         B     TRCB                8\nTRCB     MVC   LTR2A,=CL7'CB ===>'\n         LA    R14,CATBLK\n         LA    R15,8\nTRNEXT   LA    R0,8\n         LA    R1,LTR2B\nTRLOOP   UNPK  0(9,R1),0(5,R14)\n         TR    0(8,R1),TRTAB-C'0'\n         MVI   8(R1),C' '\n         LA    R1,L'LTR2B(R1)\n         LA    R14,4(R14)\n         BCT   R0,TRLOOP\n         STM   R14,R15,CURRPT\n        $PRINT LTR2,,DDTEST\n         LTR   R15,R15\n         BNZ   TRERR\n         MVC   LTR2A(L'LTR2A),=CL9' '\n         LM    R14,R15,CURRPT\n         BCT   R15,TRNEXT\n         LA    R0,8\n         LA    R1,LTR2B\n         MVC   0(L'LTR2B,R1),=CL9' '\n         LA    R1,L'LTR2B(R1)\n         BCT   R0,*-10\n         LA    R1,LTR2B\n         UNPK  0(9,R1),0(5,R14)\n         TR    0(8,R1),TRTAB-C'0'\n         MVI   8(R1),C' '\n         UNPK  9(9,R1),4(5,R14)\n         TR    9(8,R1),TRTAB-C'0'\n         MVI   17(R1),C' '\n         UNPK  18(3,R1),8(2,R14)\n         TR    18(2,R1),TRTAB-C'0'\n         MVI   20(R1),C' '\n        $PRINT LTR2,,DDTEST\n         LTR   R15,R15\n         BZ    TRNONE\n         B     TRERR\nTRVB     MVC   LTR2A,=CL7'VB ===>'\n         LA    R14,CATBLK\n         LA    R0,8\n         LA    R1,LTR2B\n         MVC   0(L'LTR2B,R1),=CL9' '\n         LA    R1,L'LTR2B(R1)\n         BCT   R0,*-10\n         LA    R1,LTR2B\n         UNPK  0(9,R1),0(5,R14)\n         TR    0(8,R1),TRTAB-C'0'\n         MVI   8(R1),C' '\n         UNPK  9(9,R1),4(5,R14)\n         TR    9(8,R1),TRTAB-C'0'\n         MVI   17(R1),C' '\n         UNPK  18(9,R1),8(5,R14)\n         TR    18(8,R1),TRTAB-C'0'\n         MVI   26(R1),C' '\n         UNPK  27(5,R1),12(3,R14)\n         TR    27(4,R1),TRTAB-C'0'\n         MVI   31(R1),C' '\n        $PRINT LTR2,,DDTEST\n         LTR   R15,R15\n         BNZ   TRERR\nTRNONE   LM    R14,R1,SVREGS\n         B     2(R8)               RETURN\nTRERR    ST    R15,CCODE           WRITE OUTPUT ERROR\n         B     BYE\n         EJECT\n*- - - - - - - - - - - - DATA AND WORK AREAS - - - - - - - - - - - - -*\n         SPACE 1\n         DS    0D\nCATBLK   DS    0CL265         KEEP ON DOUBLE-WORD\n         DC    XL242'0'            VOLUME LIST INCLUDING # OF VOLUMES\n         DC    XL10'0'             ZEROS\n         DC    XL3'0'              CHAIN TTR\n         DC    XL4'0'              ZERO\n         DC    XL6'0'              FOUND ON THIS CVOL\nVOLBLK   DS    0H             KEEP ON HALF-WORD\n         DC    H'1'                NUMBER OF VOLUMES\nSCRDC    DC    XL4'0'              DEVICE CODE\nSCRVSN   DC    CL6' '              VOLUME SERIAL NUMBER\nSCRSC    DC    H'0'                SCRATCH STATUS CODE\nPWORK    DC    D'0'\nSVREGS   DC    4F'0'\nCURRPT   DC    2F'0'\nTABADDR  DC    A(*-*)\nTABLEN   DC    A(TBMAX)\nATIOT    DC    A(*-*)\nCCODE    DC    F'0'\nDDIN     DC    CL8'GDGIN'\nDDOUT    DC    CL8'GDGOUT'\nDDTEST   DC    CL8'SYSTEST'\nGDGNAME  DC    CL44' '\nGSVNAME  DC    CL44' '\nGRLNAME  DC    CL44' '\nENTRIES  DC    CL3' '\nONEMP    DC    CL1' '\nONSCR    DC    CL1' '\nNPG      DC    PL3'+0'\nNLN      DC    PL2'+99'\nCATYPE   DC    XL1'0'              CATALOG TYPE\nCVOLTYPE EQU   X'08'\nSWITCH   DC    XL1'0'              PROCESSING FLAGS\nSWSNP    EQU   X'80'\nSWSNR    EQU   X'40'\nSWTST    EQU   X'20'\nSWIDC    EQU   X'10'\nSWDLX    EQU   X'08'\nSWNOS    EQU   X'04'\nSWSNE    EQU   X'01'\n         SPACE 1\nINAREA   DS    0CL80\nINREQ    DC    CL72' ',CL8' '\n         SPACE 1\n         DC    AL1(OUTAL)\nOUTAREA  DS    0C\nMSGCC    DC    CL1' '\nMSGNAME  DC    CL44' ',CL2' '\nMSGAREA  DC    CL80' '\nOUTAL    EQU   *-OUTAREA\n         SPACE 1\n         DC    AL1(TIT1L)\nTIT1     DC    CL71'1-- GENERATION DATA GROUP UTILITY --'\n         DC    CL4'PAGE'\nTIT1A    DC    CL6' '\nTIT1L    EQU   *-TIT1\n         SPACE 1\n         DC    AL1(LTR1L)\nLTR1     DC    C'   T ='\nLTR1A    DC    CL4' ',C' R14-R1 : '\nLTR1B    DC    CL8' ',C' - '\nLTR1C    DC    CL8' ',C' - '\nLTR1D    DC    CL8' ',C' - '\nLTR1E    DC    CL8' ',C' => '\nLTR1F    DC    CL44' ',C' '\nLTR1L    EQU   *-LTR1\n         SPACE 1\n         DC    AL1(LTR2L)\nLTR2     DC    CL3' '\nLTR2A    DC    CL7' ',C' '\nLTR2B    DC    8CL9' '\nLTR2L    EQU   *-LTR2\n         SPACE 1\n         DC    0F'0',CL8'LOCATE  ' TAG FOR ERROR MSG\nLOCNAME CAMLST NAME,GDGNAME,,CATBLK\n         DC    0F'0',CL8'UNCATAL ' TAG FOR ERROR MSG\nUNCAT   CAMLST UNCAT,GDGNAME       UNCAT AND RETAIN INDEX LEVLELS\n         DC    0F'0',CL8'DLTX    ' TAG FOR ERROR MSG\nDELIDX  CAMLST DLTX,GSVNAME        DELETE GDG INDEX\n         DC    0F'0',CL8'BLDG    ' TAG FOR ERROR MSG\nBGDG    CAMLST BLDG,GSVNAME,,,DELETE,,000\n         DC    0F'0',CL8'CATAL   ' TAG FOR ERROR MSG\nCATNAME CAMLST CAT,GDGNAME,,CATBLK\n         DC    0F'0',CL8'SCRATCH ' TAG FOR ERROR MSG\nSCRNAME CAMLST SCRATCH,GDGNAME,,VOLBLK,,OVRD\n         SPACE 1\nIDCDEL   DC    F'1'                ONE CARD WILL BE PASSED TO IDCAMS\n         DC    A(DELC)             ADDRESS OF THE DELETE STMT\nDELC     DC    CL10' DELETE ( '\nDELCNM   DC    CL35' ',CL6' ) GDG'\nDELCL    EQU   *-DELC\n         DC    (72-DELCL)C' ',CL8' ' FILL IT OUT WITH BLANKS\n         SPACE 1\nIDCDEF   DC    F'2'                TWO CARDS WILL BE PASSED TO IDCAMS\n         DC    A(DEFC)             ADDRESS OF THE DEFINE STMT\nDEFC     DC    CL19' DEFINE GDG (NAME( '\nDEFCNM   DC    CL35' ',CL7' ) LIM('\nDEFCLM   DC    CL3' ',CL3') -'\nDEFCL    EQU   *-DEFC\n         DC    (72-DEFCL)C' ',CL8' ' FILL IT OUT WITH BLANKS\nDEFC1    DC    CL8' ',CL7'OWNER( '\nDEFCOW   DC    CL8' ',CL2') '\nDEFCEM   DC    CL1' ',CL4'EMP '\nDEFCSC   DC    CL1' ',CL4'SCR)'\nDEFCL1   EQU   *-DEFC1\n         DC    (72-DEFCL1)C' ',CL8' ' FILL IT OUT WITH BLANKS\n         SPACE 1\nBLANKTBL DC    64X'00',X'FF',191X'00'\nTRTAB    DC    CL16'0123456789ABCDEF'\nTERMMSG  DC    CL91'** UNACCEPTABLE ERROR ** - PROGRAM TERMINATING - NOX\n                FURTHER INPUT RECORDS WILL BE PROCESSED'\nRDRMSG   DC    CL20'*** INPUT READ ERROR'\nGDGMSG   DC    CL21'*** GDG NAME TOO LONG'\nENTMSG   DC    CL20'*** ENTRIES TOO LONG'\nOPTMSG   DC    CL24'*** INVALID OPTION INPUT'\nINVMSG   DC    CL25'*** INVALID ENTRIES INPUT'\nUNCATMSG DC    CL11'UNCATALOGED'\nSCRMSG   DC    CL14'SCRATCHED FROM'\nCATMSG   DC    CL9'CATALOGED'\nDELXMSG  DC    CL13'INDEX DELETED'\nBLDGMSG  DC    CL22'INDEX CREATED ENTRIES='\nCAMLMSG  DC    CL15'ERROR IN CAMLST'\nIDCSMSG  DC    CL50'IDCAMS RETURNED ERROR - SEE IDCAMS MESSAGES - RC ='\nSNPOMSG  DC    CL21'SYSSNAP - OPEN FAILED'\nSNPEMSG  DC    CL27'SYSSNAP - SNAP ERROR - RC ='\nSNPCMSG  DC    CL22'SYSSNAP - CLOSE FAILED'\nSNPTMSG  DC    CL15'SNAP-DUMP TAKEN'\n         SPACE 1\n        PRINT  NOGEN\nSNAPPER DCB    DDNAME=SYSSNAP,MACRF=W,LRECL=125,BLKSIZE=882,DSORG=PS,  X\n               RECFM=VBA\n        PRINT  GEN\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R11,R12\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*                  I D C A M S    I N T E R F A C E                   *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        THIS MODULE WILL ALLOW YOU TO INVOKE IDCAMS. ON ENTRY,       *\n*        R1 SHOULD POINT TO A LIST THAT LOOKS LIKE THIS :             *\n*              - FULLWORD CONTAINING THE BINARY COUNT OF 80 BYTE      *\n*                ENTRIES FOLLOWING,                                   *\n*              - ADDRESS OF 80 BYTE IDCAMS SYSIN RECORDS.             *\n*        THIS MODULE IGNORES OPEN/CLOSE REQUESTS FROM IDCAMS.         *\n*        REGISTER USAGE :                                             *\n*              R1  = PARM'S ADDRESS                                   *\n*              R9  = BASE REGISTER                                    *\n*              R11 = FIRST MAIN BASE REGISTER                         *\n*              R12 = SECOND MAIN BASE REGISTER                        *\n*              R13 = SAVE-AREA POINTER                                *\n*              R14 = RETURN REGISTER                                  *\n*              R15 = ENTRY ADDRESS / RETURN CODE                      *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nIDCAMSX CSECT  ,\n        $XENT  BASE=R9\n         EJECT\n         MVC   USIDATA(8),0(R1)    SET THE PARM'S\n         STM   R11,R12,USODATA\n        LINK   EP=IDCAMS,PARAM=(OPTLIST,DNAMELST,PGNOLIST,IOLIST),     X\n               VL=1\n        $XRET  CC=(R15)\n         SPACE 1\nOPTLIST  DC    H'0'                EMPTY OPTION LIST\nDNAMELST DC    H'0'                EMPTY DDNAME LIST\nPGNOLIST DC    H'0'                EMPTY PAGE NO LIST\nIOLIST   DC    F'2'                ONE GROUP OF I/O LISTS FOLLOW\n         DC    A(SYSINID)          POINTER TO ID FOR SYSIN\n         DC    A(INROUT)           POINTER TO INPUT I/O ROUTINE\n         DC    A(USIDATA)          ADDRESS OF INPUT USER-DATA AREA\n         DC    A(SYSOUTID)         POINTER TO ID FOR SYSPRINT\n         DC    A(OUTROUT)          POINTER TO OUTPUT I/O ROUTINE\n         DC    A(USODATA)          ADDRESS OF OUTPUT USER-DATA AREA\nSYSINID  DC    CL10'DDSYSIN   '    INDICATE WE WISH TO MANAGE SYSIN\nSYSOUTID DC    CL10'DDSYSPRINT'    INDICATE WE WISH TO MANAGE SYSPRINT\nUSIDATA  DC    2F'0'               INPUT USER-DATA AREA\nUSODATA  DC    2A(*-*)             OUTPUT USER-DATA AREA\n         SPACE 1\n         DROP  R9\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* I D C A M S    I N T E R F A C E * * * USER INPUT I/O ROUTINE * * * *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        REGISTER USAGE :                                             *\n*              R1  = PARM'S ADDRESS                                   *\n*              R4  = NUMBER OF IDCAMS SYSIN RECORD IMAGES FROM CALLER *\n*              R5  = POINTER TO CURRENT SYSIN RECORD FROM CALLER      *\n*              R6  = POINTER TO INPUT USER-DATA AREA                  *\n*              R7  = POINTER TO IOFLAGS FROM IDCAMS                   *\n*              R8  = POINTER TO IOINFO FROM IDCAMS                    *\n*              R9  = BASE REGISTER                                    *\n*              R10 = LOCAL LINK REGISTER                              *\n*              R13 = SAVE-AREA POINTER                                *\n*              R14 = RETURN REGISTER                                  *\n*              R15 = ENTRY ADDRESS / RETURN CODE                      *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nINROUT  CSECT  ,\n        $XENT  BASE=R9\n         LM    R6,R8,0(R1)         USER-DATA/IOFLGS/IOINFO POINTERS\n         LM    R4,R5,0(R6)         GET THE USER-DATA\n         XR    R15,R15\n         IC    R15,0(,R7)          GET THE REQUEST CODE\n         L     R15,INFTB(R15)      LOAD ROUTINE ADDRESS\n         BASR  R10,R15             AND GO DO IT\n        $XRET  CC=(R15)\n         SPACE 1\nOPENIN   XR    R15,R15             WE WILL INGNORE OPEN REQUESTS\n         BR    R10                 RETURN\n         SPACE 1\nCLOSEIN  XR    R15,R15             WE WILL IGNORE CLOSE REQUESTS\n         BR    R10                 RETURN\n         SPACE 1\nABORTIN  LA    R15,12              DO NOT ALLOW ANY FURTHER CALLS\n         BR    R10                 RETURN\n         SPACE 1\nGETIN    LTR   R4,R4               ANY MORE SYSIN RECS ?\n         BP    *+L'*+6             YES, GO GET ONE\n         LA    R15,4               ELSE INDICATE END OF FILE\n         BR    R10                 RETURN\n         ST    R5,0(,R8)           POINT TO THE RECORD IN IDCAM'S LIST\n         MVC   4(4,R8),=F'80'      INDICATE IT'S LENGTH IS 80\n         LA    R5,80(,R5)          POINT TO THE NEXT RECORD\n         BCTR  R4,0                DECREMENT THE SYSIN RECORD COUNT\n         STM   R4,R5,0(R6)         STORE COUNT AND ADDRESS\n         XR    R15,R15             ZERO THE RETURN CODE\n         BR    R10                 RETURN\n         SPACE 1\n*- - - - - - - - - - - - DATA AND WORK AREAS - - - - - - - - - - - - -*\n         SPACE 1\nINFTB    DC    A(OPENIN,CLOSEIN,GETIN,ABORTIN)\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* I D C A M S    I N T E R F A C E * * * USER OUTPUT I/O ROUTINE  * * *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*        REGISTER USAGE :                                             *\n*              R1  = PARM'S ADDRESS / WORK REGISTER                   *\n*              R4  = POINTER TO SYSPRINT RECORD FROM CALLER           *\n*              R5  = POINTER TO SYSPRINT RECORD LENGTH FROM CALLER    *\n*              R6  = POINTER TO OUTPUT USER-DATA AREA                 *\n*              R7  = POINTER TO IOFLAGS FROM IDCAMS                   *\n*              R8  = POINTER TO IOINFO FROM IDCAMS                    *\n*              R9  = BASE REGISTER                                    *\n*              R10 = LOCAL LINK REGISTER                              *\n*              R11 = FIRST MAIN BASE REGISTER                         *\n*              R12 = SECOND MAIN BASE REGISTER                        *\n*              R13 = SAVE-AREA POINTER                                *\n*              R14 = RETURN REGISTER                                  *\n*              R15 = ENTRY ADDRESS / RETURN CODE                      *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nOUTROUT CSECT  ,\n        $XENT  BASE=R9\n         LM    R6,R8,0(R1)         USER-DATA/IOFLGS/IOINFO POINTERS\n         LM    R4,R5,0(R6)         GET THE USER-DATA\n         XR    R15,R15\n         IC    R15,0(,R7)          GET THE REQUEST CODE\n         L     R15,OUTFTB(R15)     LOAD ROUTINE ADDRESS\n         BASR  R10,R15             AND GO DO IT\n        $XRET  CC=(R15)\n         SPACE 1\nOPENOUT  XR    R15,R15             WE WILL INGNORE OPEN REQUESTS\n         BR    R10                 RETURN\n         SPACE 1\nCLOSEOUT XR    R15,R15             WE WILL IGNORE CLOSE REQUESTS\n         BR    R10                 RETURN\n         SPACE 1\nABORTOUT LA    R15,12              DO NOT ALLOW ANY FURTHER CALLS\n         BR    R10                 RETURN\n         SPACE 1\nPUTOUT   LM    R4,R5,0(R8)         GET ADDRESS AND LENGTH OF RECORD\n         CLC   0(24,R4),=CL24'1IDCAMS  SYSTEM SERVICES'\n         BE    PTTX                DO NOT COPY TITLE LINE\n         LR    R2,R4\n         LR    R3,R5\n         LA    R2,1(R2)\n         BCT   R3,*+L'*+4\n         B     PTTX                DO NOT COPY BLANK LINE\n         CLI   0(R2),C' '\n         BE    *-16\n         LM    R11,R12,0(R6)       SET MAIN BASE REGISTERS\n         USING GDGRESET,R11,R12\n         CL    R5,=A(OUTAL)\n         BNH   *+L'*+4\n         L     R5,=A(OUTAL)\n         BCT   R5,*+L'*+6\n         MVC   OUTAREA(*-*),0(R4)  GET RECORD\n         EX    R5,*-6\n         MVI   MSGCC,C' '\n         OI    SWITCH,SWIDC\n         BAS   R8,WRITPRT          GO TO PRINT IT\n         TM    SWITCH,SWIDC        ALL OK ?\n         BZ    ABORTOUT            NO\n         NI    SWITCH,255-SWIDC    YES\n         DROP  R11,R12\nPTTX     XR    R15,R15             ZERO THE RETURN CODE\n         BR    R10                 RETURN\n         SPACE 1\n*- - - - - - - - - - - - DATA AND WORK AREAS - - - - - - - - - - - - -*\n         SPACE 1\nOUTFTB   DC    A(OPENOUT,CLOSEOUT,ABORTOUT,PUTOUT)\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\nTBENTRY DSECT\nTNAME    DS    CL44           ABSOLUTE NAME\nTCATBLK  DS    0CL265         KEEP ON DOUBLE-WORD\nTVOLLIST DS    CL242               VOLUME LIST INCLUDING # OF VOLUMES\n         DS    CL10                ZEROS\nCHAINTTR DS    CL3                 CHAIN TTR\n         DS    CL4                 ZERO\nCVOLSER  DS    CL6                 FOUND ON THIS CVOL\n         DS    C              FILLER\nTBLENTRY EQU   *-TBENTRY      TABLE ENTRY LENGTH\nTBBL     EQU   ((TBLENTRY+15)/16)*16\nTBMAX    EQU   ((256+1)*TBBL)      ENOUGH STORAGE FOR 256 ENTRIES\n         SPACE 1\n        PRINT  NOGEN\n        CVT    DSECT=YES\n        IHAPSA\n        IHAASCB\n        IHAASXB\n        IHAACEE\nTIODSECT DSECT\n        IEFTIOT1\nUCBDSECT DSECT\n        IEFUCBOB\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETPAN": {"ttr": 17925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"o\\x00\\x91\"o\\x14D\\x00\\x9d\\x00\\x9d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-14T00:00:00", "modifydate": "1991-08-14T14:44:00", "lines": 157, "newlines": 157, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM,BPARM) NOPROCESS\n/* * --- DELETE FROM HERE ****************************************** */\n/* * BEFORE YOU MAY EXECUTE THIS PROCEDURE :                       * */\n/* * 1. VERIFY THE PRE-REQUISITE MODULES INTALLATION. SEE BELOW.   * */\n/* * 2. ADJUST THE TASKLIB OPERAND OF THE \"DOPROG\" COMMAND         * */\n/* *    (REPLACE \"TARGET.LINKLIB\" BY YOUR DATA-SET NAME).          * */\n/* *    DO A 'FIND TASKLIB' TO GET IT BELOW.                       * */\n/* * THEN, DELETE ALL INDICATED STATEMENTS, GOOD LUCK.             * */\n/* ***************************************************************** */\nWRITE *** MANDATORY - ISPF CLIST \"GETPAN\" INTERVENTION REQUIRED ***\nEXIT\n/* * --- UP TO HERE WHEN ADJUSTMENT IS DONE ************************ */\n/*  MACRO NAME : GETPAN                                             */\n/*    FUNCTION : COPY AN ISPF-PANEL IMAGE (EASIER TO INSERT IN A    */\n/*               BOOK TEXT)                                         */\n/*      SYNTAX : GETPAN PANEL-ID                                    */\n/*               GETPAN PANEL-ID DS-NAME                            */\n/*               GETPAN HELP OR H                                   */\n/*               OPERANDS : 1. PANEL-ID NAME                        */\n/*                          2. ISPF-PANELS FULLY QUALIFIED DATA-SET */\n/*       DEBUG : GETPAN PANEL-ID LIST                               */\n/*      AUTHOR : MOINIL P.A.                                        */\n/* PRE-REQUISITE MODULES INSTALLATION :                             */\n/*               DOPROG TSO-COMMAND AND TUTOLIST PROGRAM.           */\n  IF &STR(&APARM.) = &STR(HELP) OR +\n    &STR(&APARM.) = &STR(H) THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTGPAN)\n      SET &GPCC = &LASTCC\n      ISPEXEC CONTROL DISPLAY RESTORE\n      EXIT CODE(&GPCC)\n      END\n  IF &STR(&BPARM.) = &STR(LIST) THEN DO\n    CONTROL LIST CONLIST SYMLIST\n    SET &BPARM = &Z\n    END\n  IF &STR(&APARM.) = &Z THEN DO\n    SET ZEDSMSG = &STR(OPERAND MISSING)\n    SET ZEDLMSG = &STR(== FIRST OPERAND PANEL-ID NAME IS MANDATORY ==)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  IF &STR(&BPARM.) = &Z THEN SET &BPARM = &STR(EUR1.PANELS.DATA)\n  CONTROL NOMSG\n  FREE F(SYSPDS SYSPRINT SYSIN)\n  ERROR DO\n    ERROR OFF\n    ALLOC F(SYSIN) DA(*)\n    ALLOC F(SYSPRINT) DA(*)\n    SET ZEDSMSG = &STR(ALLOC ERROR)\n    SET ZEDLMSG = &STR(== UNABLE TO ALLOCATE SYSPDS FOR TUTOLIST ==)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    CONTROL MSG\n    EXIT CODE(8)\n    END\n  ALLOC F(SYSPDS) DA('&BPARM') SHR\n  ERROR OFF\n  ERROR DO\n    ERROR OFF\n    FREE F(SYSPDS)\n    ALLOC F(SYSIN) DA(*)\n    ALLOC F(SYSPRINT) DA(*)\n    SET ZEDSMSG = &STR(ALLOC ERROR)\n    SET ZEDLMSG = &STR(== UNABLE TO ALLOCATE SYSPRINT FOR TUTOLIST ==)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    CONTROL MSG\n    EXIT CODE(8)\n    END\n  ALLOC F(SYSPRINT) UNIT(VIO) SPACE(1 1) TRACKS -\n        DSORG(PS) RECFM(F B A) LRECL(88) BLKSIZE(4048) NEW\n  ERROR OFF\n  ERROR DO\n    ERROR OFF\n    FREE F(SYSPDS SYSPRINT)\n    ALLOC F(SYSIN) DA(*)\n    ALLOC F(SYSPRINT) DA(*)\n    SET ZEDSMSG = &STR(ALLOC ERROR)\n    SET ZEDLMSG = &STR(== UNABLE TO ALLOCATE SYSIN FOR TUTOLIST ==)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    CONTROL MSG\n    EXIT CODE(8)\n    END\n  ALLOC F(SYSIN) UNIT(VIO) SPACE(1 1) TRACKS -\n        DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(4080) NEW\n  ERROR OFF\n  OPENFILE SYSIN OUTPUT\n  SET SYSIN = &STR(*VAR ZCMD )\n  PUTFILE SYSIN\n  SET SYSIN = &STR(*HDR )\n  PUTFILE SYSIN\n  SET SYSIN = &STR(&APARM )\n  PUTFILE SYSIN\n  CLOSFILE SYSIN\n  DOPROG TUTOLIST TASKLIB('TARGET.LINKLIB')\n  SET &XQCC = &LASTCC\n  IF &XQCC \u00ac= 0 THEN DO\n    FREE F(SYSPDS SYSPRINT SYSIN)\n    ALLOC F(SYSIN) DA(*)\n    ALLOC F(SYSPRINT) DA(*)\n    SET ZEDSMSG = &STR(EXEC ERROR)\n    SET ZEDLMSG = &STR(== TUTOLIST EXECUTION RC : &XQCC ==)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    CONTROL MSG\n    EXIT CODE(8)\n    END\n  FREE F(SYSPDS SYSIN)\n  ERROR DO\n    SET &GPCC = &LASTCC\n    IF &GPCC EQ 400 THEN GOTO EOF\n    SET ZEDSMSG = &STR(READ ERROR)\n    SET ZEDLMSG = &STR(== SYSPRINT READ OPERATION RC : &GPCC ==)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    GOTO EOF\n    END\n  OPENFILE SYSPRINT INPUT\n  SET &CN = 1\n  CONTROL ASIS\nRDF: GETFILE SYSPRINT\n  SET &TS = &SUBSTR(1:2,&SYSPRINT)\n  IF &TS = &STR(1 ) THEN SET TX&CN = &Z\n  ELSE SET TX&CN = &SUBSTR(7:86,&SYSPRINT)\n  SET &CN = &CN + 1\n  GOTO RDF\nEOF: ERROR OFF\n  CLOSFILE SYSPRINT\n  FREE F(SYSPRINT)\n  ALLOC F(SYSPRINT) DA(*)\n  SET &WH = 0\n  SET &TN = 1\n  SET &C = &STR(&&)\n  ISREDIT PROCESS DEST\n  IF &LASTCC = 0 THEN DO\n    ISREDIT LOCATE .ZDEST\n    IF &LASTCC = 8 THEN GOTO IN2\nIN1: ISREDIT (LINEPTR) = LINENUM .ZDEST\n    SET &LINEPTR = &LINEPTR + &WH\n    SET TF = &NRSTR(&C.TX&TN)\n    ISREDIT MASKLINE = \"&TF\"\n    ISREDIT LINE_AFTER &LINEPTR = MASKLINE\n    SET &WH = &WH + 1\n    SET &TN = &TN + 1\n    IF &TN < &CN THEN GOTO IN1\n    END\n  ELSE DO\nIN2: ISREDIT (LINEPTR) = LINENUM .ZCSR\n    SET &LINEPTR = .ZLAST\n    SET TF = &NRSTR(&C.TX&TN)\n    ISREDIT MASKLINE = \"&TF\"\n    ISREDIT LINE_AFTER &WH = MASKLINE\n    SET &WH = &WH + 1\n    SET &TN = &TN + 1\n    IF &TN < &CN THEN GOTO IN2\n    END\n  ISREDIT MASKLINE = \" \"\n  CONTROL MSG\n  CONTROL CAPS\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETPAN@": {"ttr": 17929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"o\\x00\\x91\"o\\x10\\t\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-14T00:00:00", "modifydate": "1991-08-14T10:09:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/05/90\n                                                      GETPAN    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    GETPAN ISPF/PDF EDIT command     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to copy an ISPF-panel image\n  ----------   in a book text (allowing to get it already cleaned from\n               all statements and fields controls).\n\n  Command syntax : GETPAN Panel-ID\n  ---------------- GETPAN Panel-ID DS-name\n                   GETPAN HELP or H\n               Operands : Panel-ID = the name of the ISPF panel\n                          DS-name = optional ISPF panels data-set name,\n                                    fully qualified\n                                    (default is EUR1.PANELS.DATA)\n\n  Use :        Type GETPAN Panel-ID on the COMMAND line, the panel will\n  -----        then be inserted at the top of data. If you desire it\n               somewhere other than the top of data, type A (after) or\n               B (before) on the line number at the point in the data\n               you want the panel, as i.e. :\n               COMMAND ===> GETPAN Panel-ID\n          ---> A 0600   Data ...\n               000700   Data ...\n               Result : the panel would be inserted after line 600.\n                        Identical process is obtained with :\n          ---> B 0700   Data ...\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GFDATE": {"ttr": 17931, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x13\\x7f\\x00\\x91\\x13\\x7f\\x139\\x03\\x16\\x03\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-05-17T00:00:00", "modifydate": "1991-05-17T13:39:00", "lines": 790, "newlines": 790, "modlines": 0, "user": "SYSPAJA"}, "text": "GDS      TITLE 'GENERATE DATES SUBROUTINES.'\nGFDATE   START 0\n         SPACE 1\n* GENERATE DATES SUBROUTINES PACKAGE\n* ==================================\n*\n* THIS PACKAGE CONTAINS NOW THE NEW AND OLD ROUTINES VERSIONS FOR TIME\n* AND DATE EDITING AS BELOW :\n*\n*        A. NEW VERSIONS\n*           1. GFDATE   : GENERATE FULLY EXPANDED DATE\n*           2. GWKDAY   : GET WEEK DAY\n*           3. GSDATE   : GENERATE SERIAL DAY\n*\n*        B. OLD VERSIONS\n*           4. GDATE    : GENERATE DATE\n*           5. WEEKDAY  : WEEK DAY\n*           6. SDATE    : GENERATE SERIAL DAY\n*           7. HRDAY    : HOUR-DAY\n*                         ALIAS : GIORNO\n*\n* GENERAL NOTICE : THESE ROUTINES ARE RE-ENTERABLE.\n* ----------------\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n* 1. GENERATE FULLY EXPANDED DATE\n* ===============================\n* CALLING SEQUENCE : CALL GFDATE,(A,B,C,D,E),VL\n* ------------------             (A,B,C,D)\n*                                (A,B,C)\n*                                (A,B)\n*                                (A)\n*\n*        WHERE : A - RECEIVES THE FULLY EXPANDED DATE IN CHARACTERS\n*                    (FORMAT CL20), AS FOR EXAMPLE :\n*\n*                            'WED, DEC. 09, 1981  '\n*\n*                B - RECEIVES THE TIME OF DAY 'HHMMSS' IN CHARACTERS\n*                    (FORMAT CL6) IF SUPPLIED (OPTIONAL ARGUMENT) AND\n*                    IF THE D-ARGUMENT IS NOT SUPPLIED. IN CASE THE\n*                    D-ARGUMENT IS PRESENT, B-ARGUMENT IS NEVER BUILD.\n*\n*                C - RECEIVES THE DATE 'MMDDYYYY' IN CHARACTERS\n*                    (FORMAT CL8) IF SUPPLIED (OPTIONAL ARGUMENT).\n*\n*                D - IF ARGUMENT IS PRESENT, IT MUST BE A SERIAL DAY\n*                    'YYYYDDD' IN CHATACTERS (FORMAT CL7). IF ARGUMENT\n*                    IS OMITED, THE DATE AND TIME OF DAY IS OBTAINED\n*                    FROM THE SYSTEM. THIS PARAMETER MAY BE USEFULL TO\n*                    OBTAIN THE FULLY EXPANDED DATE OF A PREDETERMINED\n*                    SERIAL DATE (YYYYDDD).\n*\n*                E - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                    F BOUNDARY) IF SUPPLIED (OPTIONAL).\n*\n*        THUS : A, B AND C ARE OUTPUT PARAMETERS, AND D, IF PRESENT,\n*               IS AN INPUT PARAMETER.\n*\n*        RETURN CODES : 0 = NORMAL.\n*                       4 = WRONG D PARAMETER OR E PARAMETER ALIGNMENT.\n*                       8 = MORE THAN 5 PARAMETERS.\n*\n*        N.B. - IF ONE OR MORE ADDRESSES OF THE A, B, C OR D ARGUMENTS\n*        ----   ARE ZERO IN THE PARAMETERS LIST, THE PROCESSING FOR THE\n*               CORRESPONDING ARGUMENT WILL BE SKIPPED.\n         EJECT\n* 2. GET WEEKDAY\n* ==============\n* CALLING SEQUENCE : CALL GWKDAY,(A,B,C),VL\n* ------------------\n*\n*        WHERE : A - ADDRESS OF THE YEAR IN BINARY (FULLWORD).\n*                B - ADDRESS OF THE SERIAL DAY IN BINARY (FULLWORD).\n*                C - RECEIVES A DAY BINARY INDEX (FORMAT XL1, VALUE\n*                    IS 0 TO 6 FOR SUNDAY TO SATURDAY).\n*\n*\n* 3. GENERATE SERIAL DAY\n* ======================\n* CALLING SEQUENCE : CALL GSDATE,(A,B,C),VL\n* ------------------             (A,B)\n*\n*        WHERE : A - IS THE DATE 'MMDDYYYY' IN CHARACTERS (FORMAT CL8).\n*\n*                B - RECEIVES THE SERIAL DATE 'YYYYDDD' IN CHARACTERS\n*                    (FORMAT CL7).\n*\n*                C - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                    F BOUNDARY) IF SUPPLIED (OPTIONAL).\n*\n*        RETURN CODES : 0 = NORMAL.\n*                       4 = WRONG A PARAMETER OR C PARAMETER\n*                           ALIGNMENT.\n*                       8 = WRONG PARAMETERS LIST OR MORE THAN 3\n*                           PARAMETERS.\n         EJECT\n* 4. GENERATE DATE SUBROUTINE\n* ===========================\n* CALLING SEQUENCE : CALL GDATE,(A,B,C,D,E),VL\n* ------------------            (A,B,C,D)\n*                               (A,B,C)\n*                               (A,B)\n*                               (A)\n*\n*        WHERE : A - RECEIVES THE FULLY EXPANDED DATE IN CHARACTERS\n*                    (FORMAT CL20), AS FOR EXAMPLE :\n*\n*                            'WED, DEC. 09, 1981  '\n*\n*                B - RECEIVES THE TIME OF DAY 'HHMMSS' IN CHARACTERS\n*                    (FORMAT CL6) IF SUPPLIED (OPTIONAL ARGUMENT) AND\n*                    IF THE D-ARGUMENT IS NOT SUPPLIED. IN CASE THE\n*                    D-ARGUMENT IS PRESENT, B-ARGUMENT IS NEVER BUILD.\n*\n*                C - RECEIVES THE DATE 'MMDDYY' IN CHARACTERS\n*                    (FORMAT CL6) IF SUPPLIED (OPTIONAL ARGUMENT).\n*\n*                D - IF ARGUMENT IS PRESENT, IT MUST BE A SERIAL DAY\n*                    'YYDDD' IN CHATACTERS (FORMAT CL5). IF ARGUMENT IS\n*                    OMITED, THE DATE AND TIME OF DAY IS OBTAINED FROM\n*                    THE SYSTEM. THIS PARAMETER MAY BE USEFULL TO\n*                    OBTAIN THE FULLY EXPANDED DATE OF A PREDETERMINED\n*                    SERIAL DATE (YYDDD).\n*\n*                E - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                    F BOUNDARY) IF SUPPLIED (OPTIONAL).\n*\n*        THUS : A, B AND C ARE OUTPUT PARAMETERS, AND D, IF PRESENT,\n*               IS AN INPUT PARAMETER.\n*\n*        RETURN CODES : 0 = NORMAL.\n*                       4 = WRONG D PARAMETER OR E PARAMETER ALIGNMENT.\n*                       8 = MORE THAN 5 PARAMETERS.\n*\n*        N.B. - IF ONE OR MORE ADDRESSES OF THE A, B, C OR D ARGUMENTS\n*        ----   ARE ZERO IN THE PARAMETERS LIST, THE PROCESSING FOR THE\n*               CORRESPONDING ARGUMENT WILL BE SKIPPED.\n*\n* ADVICE :     THIS ROUTINE NOW INTERFACE TO 'GFDATE' ROUTINE, SO LOOK\n* --------     TO ADJUST THE CENTURY AS YOU WANT IT.\n         EJECT\n* 5. WEEKDAY SUBROUTINE\n* =====================\n* CALLING SEQUENCE : CALL WEEKDAY,(A,B),VL\n* ------------------\n*\n*        WHERE : A - IS 'YYYYMMDD' (FORMAT CL8).\n*                B - RECEIVES A DAY BINARY INDEX (0 TO 6, FORMAT XL1).\n*\n* ADVICE :     THIS ROUTINE NOW INTERFACE TO 'GSDATE' AND 'GWKDAY'\n* --------     ROUTINES.\n*\n*\n* 6. GENERATE SERIAL DAY\n* ======================\n* CALLING SEQUENCE : CALL SDATE,(A,B,C),VL\n* ------------------            (A,B)\n*\n*        WHERE : A - IS THE DATE 'MMDDYY' IN CHARACTERS (FORMAT CL6).\n*\n*                B - RECEIVES THE SERIAL DATE 'YYDDD' IN CHARACTERS\n*                    (FORMAT CL5).\n*\n*                C - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                    F BOUNDARY) IF SUPPLIED (OPTIONAL).\n*\n*        RETURN CODES : 0 = NORMAL.\n*                       4 = WRONG A PARAMETER OR C PARAMETER\n*                           ALIGNMENT.\n*                       8 = WRONG PARAMETERS LIST OR MORE THAN 3\n*                           PARAMETERS.\n*\n* ADVICE :     THIS ROUTINE NOW INTERFACE TO 'GSDATE' ROUTINE, SO LOOK\n* --------     TO ADJUST THE CENTURY AS YOU WANT IT.\n         EJECT\n* 7. HOUR-DAY\n* ===========\n* CALLING SEQUENCE : CALL HRDAY,(A,B,C),VL\n* ------------------            (A,B)\n*\n*        WHERE : A - RECEIVES THE TIME OF DAY 'HH.MM.SS' IN CHARACTERS\n*                    (FORMAT CL8).\n*\n*                B - RECEIVES THE DATE 'YY/MM/DD' IN CHARACTERS\n*                    (FORMAT CL8).\n*\n*                C - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                    F BOUNDARY) IF SUPPLIED (OPTIONAL).\n*\n*        RETURN CODES : 0, 4 OR 8 = THOSE OF 'GFDATE' SUBROUTINE.\n*                       12 = WRONG PARAMETERS LIST.\n*\n*        ALIAS : CALL GIORNO,(A,B,C),VL\n*                            (A,B)\n*\n* ADVICE :     THIS ROUTINE NOW INTERFACE TO 'GFDATE' ROUTINE.\n* --------\n         EJECT\nGFDATE  AMODE  ANY\nGFDATE  RMODE  ANY\n         SPACE 1\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nRX       EQU   0\n         SPACE 1\n        $XENT  BASE=R9,LV=GFWAL,TYPE=RENT\n         LR    R11,R13\n         USING GFWA,R11\n         MVI   FDATE,C' '\n         MVC   FDATE+1(L'FDATE-1),FDATE\n         MVI   FDATE+3,C','\n         MVI   DAY+L'DAY,C','\n         LA    R0,5                SCAN ARGUMENTS ADDRESSES.\n         XR    R4,R4\n         LR    R5,R4\n         LR    R6,R4\n         LR    R7,R4\n         LR    R8,R4\n         LA    R2,R3*16+R3\nARGLP    LA    R2,R1*16+R1(R2)\n         EX    R2,ARGGA            GET ARGUMENT ADDRESS.\n         LA    R1,4(R1)            BUMP PARAMETER LIST.\n         EX    R2,ARGTS            TEST ADDRESS, END OF LIST?\n         BM    ARGEL               BRANCH IF YES.\n         BCT   R0,ARGLP\n         LA    R15,8 ------------- TOO MUCH PARAMETERS.\n         B     EXIT\nARGEL    EX    R2,ARGCL            CLEAN ADDRESS (END OF LIST).\n         LTR   R8,R8\n         BZ    TSD\n         ST    R8,WORK\n         TM    WORK+3,X'03'\n         BNZ   WRP                 WRONG E PARAMETER ALIGNMENT.\nTSD      LTR   R7,R7               YYYYDDD SUPPLIED?\n         BZ    GTIME               BRANCH IF NOT.\n         MVC   WORK(7),0(R7)\n         NC    WORK(7),=CL7'0000000'\n         CLC   WORK(7),=CL7'0000000'\n         BNE   WRP                 ERROR, NOT NUMERICS.\n         CLC   0(4,R7),=CL4'1582'\n         BL    WRP                 ERROR, LESS.\n         CLC   0(4,R7),=CL4'4315'\n         BH    WRP                 ERROR, HIGH.\n         PACK  WORK(4),0(7,R7)     PICK IT.\n         XR    R0,R0\n         L     R1,WORK             R1 = YYYYDDDF.\n         ST    R0,WORK\n         SLDL  R0,16               R0 = 0000YYYY.\n         SLL   R0,4                R0 = 000YYYY0.\n         LA    R15,X'0F'\n         OR    R0,R15              R0 = 000YYYYF.\n         ST    R0,WORK+4\n         SRL   R1,16               R1 = 0000DDDF.\n         B     COMMON\nARGGA    L     RX,0(RX,R1)         <<EXECUTED>> - GET ADDRESS.\nARGTS    LTR   RX,RX               <<EXECUTED>> - TEST ADDRESS.\nARGCL    LA    RX,0(RX)            <<EXECUTED>> - CLEAN ADDRESS.\nGTIME   TIME   DEC\n         LTR   R5,R5               TIME OF DAY REQUESTED?\n         BZ    TIMEOK              BRANCH IF NOT.\n         IC    R0,=CL7'0000000'    R0 = HHMMSSF0.\n         SRL   R0,4                R0 = 0HHMMSSF.\n         ST    R0,WORK+4\n         UNPK  0(6,R5),WORK+4(4)\nTIMEOK   XR    R0,R0               R1 = 0CYYDDDF.\n         ST    R0,WORK\n         SLDL  R0,16               R0 = 00000CYY.\n         SRL   R1,16               R1 = 0000DDDF.\n         SLL   R0,4                R0 = 0000CYY0.\n         LA    R15,X'0F'\n         OR    R0,R15              R0 = 0000CYYF.\n         ST    R0,WORK+4\n         AP    WORK,=PL3'+1900'    ADD BASE CENTURY\n         OI    WORK+L'WORK-1,X'0F'\nCOMMON   UNPK  YEAR(L'YEAR),WORK+5(3)   SET YEAR IN PLACE.\n         CVB   R0,WORK             R0 = YEAR IN BINARY.\n         ST    R1,WORK+4\n         CVB   R1,WORK             R1 = SERIAL DAY IN BINARY.\n         LR    R5,R1\n         CH    R1,=Y(31+28)        DAY PAST FEBRUARY?\n         BNH   CMONTH              BRANCH IF NOT.\n         LR    R15,R0              LOOK TO SEE\n         XR    R14,R14               IF WE ARE\n         D     R14,=F'100'             ON A\n         LTR   R14,R14                   CENTURY?\n         BNZ   NOTCNT              NO.\n         LR    R14,R15             YES, LOOK IF\n         SRL   R14,2                 THE CENTURY\n         SLL   R14,2                   MUST BE\n         CLR   R14,R15                   A LEAP YEAR?\n         BE    CMONTH              BRANCH IF YES.\n         B     ADJST               ELSE ADJUST DAYS.\nNOTCNT   LR    R15,R0              LOOK TO SEE\n         SRL   R15,2                 IF FEBRUARY\n         SLL   R15,2                   OF THIS YEAR\n         CLR   R15,R0                    MUST BE 29 DAYS?\n         BE    CMONTH              BRANCH IF YES.\nADJST    LA    R1,1(R1)            NO, ADJUST DAYS.\nCMONTH   LA    R2,12               NOW COMPUTE MONTH.\n         XR    R3,R3\nCMLP     IC    R3,TMONTH-1(R2)\n         SR    R1,R3\n         BNP   CMEND\n         BCT   R2,CMLP\nWRP      LA    R15,4 ------------- WRONG YYYYDDD (OR E PARM. ALIGN.).\n         B     EXIT\nCMEND    AR    R1,R3               R1 IS THE DAY IN THE MONTH.\n         CVD   R1,WORK\n         OI    WORK+7,X'0F'\n         UNPK  DAY(L'DAY),WORK+6(2)\n         LA    R3,13\n         SR    R3,R2               R3 IS THE MONTH.\n         LTR   R6,R6               MONTH/DAY/YEAR REQUESTED?\n         BZ    FEXDT               BRANCH IF NOT.\n         MVC   2(L'DAY,R6),DAY\n         CVD   R3,WORK\n         OI    WORK+7,X'0F'\n         UNPK  0(2,R6),WORK+6(2)\n         MVC   4(L'YEAR,R6),YEAR\nFEXDT    LTR   R4,R4               FULLY EXPANDED DATE REQUESTED?\n         BZ    SETRC               BRANCH IF NOT.\n         ST    R0,WORK             YEAR IN BINARY.\n         ST    R5,WORK+4           DAY IN BINARY.\n         LA    R1,GWKPL            CALL GWKDAY,(WORK,WORK+4,INDEX),VL\n         LA    R15,WORK\n         ST    R15,0(R1)\n         LA    R15,WORK+4\n         ST    R15,4(R1)\n         LA    R15,INDEX\n         ST    R15,8(R1)\n         OI    8(R1),X'80'\n         L     R15,=A(GWKDAY)\n         BASR  R14,R15\n         MVC   0(L'FDATE,R4),FDATE BUILD NOW 'DDD, MMMM DD, YYYY '.\n         SLA   R3,2\n         LA    R3,MONTHT-L'MONTHT(R3)\n         MVC   5(L'MONTHT,R4),0(R3)\n         IC    R2,INDEX\n         LR    R3,R2\n         SLA   R2,1\n         AR    R2,R3\n         LA    R2,DAYT(R2)\n         MVC   0(L'DAYT,R4),0(R2)\nSETRC    XR    R15,R15             RC = OK.\nEXIT     LTR   R8,R8               GO BACK TO CALLER.\n         BZ    *+L'*+4\n         ST    R15,0(R8)\n        $XRET  CC=(R15),LV=GFWAL,TYPE=RENT\n         EJECT\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\nTMONTH   DC    AL1(31,30,31,30,31,31,30,31,30,31,29,31)\nMONTHT   DC    CL4'JAN.',C'FEB.MAR.APR.MAY.JUN.'\n         DC    C'JUL.AUG.SEP.OCT.NOV.DEC.'\nDAYT     DC    CL3'SUN',C'MONTUEWEDTHUFRISAT'\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9,R11\n         SPACE 1\nGFWA     DSECT\n         DS    18F                 SAVE AREA.\nWORK     DS    D\nGWKPL    DS    3F                  PARM. LIST.\nFDATE    DS    0CL20,CL10\nDAY      DS    CL2,CL2\nYEAR     DS    CL4,CL2\nINDEX    DS    XL1\nGFWAL    EQU   (((*-GFWA)+7)/8)*8\n         EJECT\nGWKDAY   CSECT\n         SPACE 1\nGWKDAY  AMODE  ANY\nGWKDAY  RMODE  ANY\n         SPACE 1\n* WEEKDAY COMPUTATION : GREGORIAN CALENDAR (1582)          MOINIL P.A.\n*        EACH FOURTH YEAR IS A LEAP YEAR, AND YEARS MARKING THE\n*        CENTURY WILL NOT BE LEAP YEARS UNLESS DIVISIBLE BY 400.\n*        I.E. : 1600 WAS A LEAP YEAR, BUT 1700, 1800, 1900 WERE NOT.\n* METHOD : TO OBTAIN A DAY NAME INDEX FROM 0 TO 6, 7 DAYS OF THE\n*        WEEK, IT IS KNOWN THAT A YEAR IS NORMALLY 365 DAYS, WHICH\n*        IS A MULTIPLE OF 7 PLUS 1 DAY (52 * 7 = 364). IF ASSUMING\n*        ALL REGULAR AND STARTING FROM YEAR 0, IT MEANS THAT EVERY\n*        YEAR THE INDEX IS INCREMENTED BY 1, MOVED FORWARD. THUS :\n*             INDEX-COUNT = SERIAL-DAY + YEAR\n*        THIS IS TRUE UNLESS FOR THE PREVIOUS LEAP YEARS, WHICH MUST\n*        BE INCREMENTED 1 MORE (NOT THE CURRENT YEAR BECAUSE IF IT IS\n*        A LEAP YEAR IT IS TAKEN IN ACCOUNT IN THE SERIAL DAY), SO :\n*             INDEX-COUNT = SERIAL-DAY + YEAR + (YEAR-1)/4\n*        FINALLY, IT MUST BE BACK ADJUSTED FOR ALL PREVIOUS CENTURIES\n*        NOT MULTIPLE OF 4, THEY WERE NOT A LEAP YEAR :\n*             ADJUST = (YEAR-1)/100 - ((YEAR-1)/100)/4\n*             INDEX-COUNT = SERIAL-DAY + YEAR + (YEAR-1)/4 - ADJUST\n*        NOW DIVIDING THE INDEX-COUNT BY 7, THE REMAINDER IS THE\n*        NEEDED WEEKDAY INDEX FROM 0 TO 6.\n         EJECT\n         USING *,R15\n         SPACE 1\n         STM   R14,R12,12(R13)     SAVE REGISTERS.\n         LM    R5,R7,0(R1)         GET PARAMETERS ADDRESSES.\n         L     R3,0(R5)            R3 = YEAR IN BINARY\n         L     R4,0(R6)            R4 = SERIAL DAY IN BINARY\n         LR    R1,R3\n         XR    R0,R0\n         BCTR  R1,0\n         D     R0,=F'100'\n         LR    R2,R1\n         SRL   R1,2\n         SR    R2,R1\n         LR    R1,R3\n         LR    R0,R1\n         BCTR  R1,0\n         SRL   R1,2\n         AR    R1,R0\n         AR    R1,R4\n         SR    R1,R2\n         XR    R0,R0\n         D     R0,=F'7'\n         A     R0,=F'6'            ADJUST SO SUNDAY = INDEX 0.\n         CL    R0,=F'7'\n         BL    *+L'*+4\n         S     R0,=F'7'\n         STC   R0,0(R7)            ONE DIGIT DAY INDEX.\n         LM    R14,R12,12(R13)     RESTORE REGISTERS.\n         BR    R14                 RETURN.\n         SPACE 1\n        LTORG\n         SPACE 2\n         DROP R15\n         EJECT\nGSDATE   CSECT\n         SPACE 1\nGSDATE  AMODE  ANY\nGSDATE  RMODE  ANY\n         SPACE 1\n        $XENT  BASE=R9,DT=NO,LV=GSWAL,TYPE=RENT\n         LR    R11,R13\n         USING GSWA,R11\n         MVC   TBMON(L'TBMON),=AL1(31,28,31,30,31,30,31,31,30,31,30,31)\n         TM    0(R1),X'80'         VALID PARAMETERS LIST TEST.\n         BO    ERRPL\n         XR    R10,R10\n         TM    4(R1),X'80'\n         BO    OKPL\n         TM    8(R1),X'80'\n         BZ    ERRPL\n         TM    11(R1),X'03'\n         BNZ   ERRPP\n         L     R10,8(R1)\n         LA    R10,0(R10)\nOKPL     LM    R2,R3,0(R1)\n         MVC   WKAR(8),0(R2)       CONTROL NUMERICS.\n         NC    WKAR(8),=CL8'00000000'\n         CLC   WKAR(8),=CL8'00000000'\n         BNE   ERRPP\n         PACK  WKAR,2(2,R2)        GET DAY.\n         CVB   R4,WKAR\n         LTR   R4,R4\n         BNP   ERRPP\n         CH    R4,=H'31'\n         BH    ERRPP\n         PACK  WKAR,0(2,R2)        GET MONTH.\n         CVB   R1,WKAR\n         LTR   R1,R1\n         BNP   ERRPP\n         CH    R1,=H'12'\n         BH    ERRPP\n         CLC   4(4,R2),=CL4'1582'  CONTROL YEAR.\n         BL    ERRPP               ERROR, LESS.\n         CLC   4(4,R2),=CL4'4315'\n         BH    ERRPP               ERROR, HIGH.\n         PACK  WKAR,4(4,R2)        GET YEAR.\n         CVB   R0,WKAR\n         LR    R15,R0              LOOK TO SEE\n         XR    R14,R14               IF WE ARE\n         D     R14,=F'100'             ON A\n         LTR   R14,R14                   CENTURY?\n         BNZ   NCENT               NO.\n         LR    R14,R15             YES, LOOK IF\n         SRL   R14,2                 THE CENTURY\n         SLL   R14,2                   MUST BE\n         CLR   R14,R15                   A LEAP YEAR?\n         BE    LPY                 YES.\n         B     NLP                 NO.\nNCENT    LR    R15,R0              LOOK TO SEE\n         SRL   R15,2                 IF FEBRUARY\n         SLL   R15,2                   OF THIS YEAR\n         CLR   R15,R0                    MUST BE 29 DAYS?\n         BNE   NLP                 NO.\nLPY      MVI   TBMON+1,29          YES, SET IT.\nNLP      XR    R0,R0\n         IC    R0,TBMON-1(R1)\n         CLR   R4,R0\n         BH    ERRPP\nCMSD     BCT   R1,*+L'*+4\n         B     STSD\n         IC    R0,TBMON-1(R1)\n         AR    R4,R0\n         B     CMSD\nSTSD     MVC   0(4,R3),4(R2)       SET YEAR (YYYY).\n         CVD   R4,WKAR\n         UNPK  4(3,R3),WKAR+6(2)   SET SERIAL DAY (DDD).\n         OI    6(R3),C'0'\n         XR    R15,R15\n         B     QUIT\nERRPP    LA    R15,4 ------------- WRONG A PARM. OR C ALIGNMENT.\n         B     QUIT\nERRPL    LA    R15,8 ------------- WRONG PARAMETERS LIST.\n         SPACE 1\nQUIT     LTR   R10,R10             GO BACK TO CALLER.\n         BZ    EXRET\n         ST    R15,0(R10)\nEXRET   $XRET  CC=(R15),LV=GSWAL,TYPE=RENT\n         EJECT\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R11\n         SPACE 1\nGSWA     DSECT\n         DS    18F                 SAVE AREA.\nWKAR     DS    D\nTBMON    DS    XL12\nGSWAL    EQU   (((*-GSWA)+7)/8)*8\n         EJECT\nGDATE    CSECT\n         SPACE 1\nGDATE   AMODE  ANY\nGDATE   RMODE  ANY\n         SPACE 1\n        $XENT  BASE=R9,DT=NO,LV=GDWAL,TYPE=RENT\n         LR    R11,R13\n         USING GDWA,R11\n         LA    R0,5                SCAN ARGUMENTS ADDRESSES.\n         XR    R4,R4\n         LR    R5,R4\n         LR    R6,R4\n         LR    R7,R4\n         LR    R8,R4\n         LA    R2,R3*16+R3\nGRGLP    LA    R2,R1*16+R1(R2)\n         EX    R2,GRGGA            GET ARGUMENT ADDRESS.\n         LA    R1,4(R1)            BUMP PARAMETER LIST.\n         EX    R2,GRGTS            TEST ADDRESS, END OF LIST?\n         BM    GRGEL               BRANCH IF YES.\n         BCT   R0,GRGLP\n         LA    R10,8 ------------- TOO MUCH PARAMETERS.\n         B     GXIT\nGRGGA    L     RX,0(RX,R1)         GET ADDRESS.\nGRGTS    LTR   RX,RX               TEST ADDRESS.\nGRGCL    LA    RX,0(RX)            CLEAN ADDRESS.\nGRGEL    EX    R2,GRGCL            CLEAN ADDRESS (END OF LIST).\n         LTR   R8,R8\n         BZ    SETPL\n         LR    R3,R8\n         SRL   R3,2\n         SLL   R3,2\n         CLR   R3,R8\n         BE    SETPL\n         LA    R10,4 ------------- WRONG E PARM. ALIGNMENT.\n         B     GXIT\nSETPL    MVC   GMDY,=CL8' '\n         MVC   GYD(L'GYD),=CL8' '\n         LTR   R2,R6               MMDDYY REQUESTED?\n         BZ    *+L'*+4             BRANCH IF NOT.\n         LA    R6,GMDY\n         LTR   R7,R7               YYDDD SUPPLIED?\n         BZ    TODAY               BRANCH IF NOT.\n         CLC   0(2,R7),=CL2'50'    YES, SET CENTURY AHEAD.\n         BL    *+L'*+10\n         MVC   GYD(2),=CL2'19'\n         B     *+L'*+6\n         MVC   GYD(2),=CL2'20'\n         MVC   GYD+2(5),0(R7)\n         LA    R7,GYD\nTODAY    LA    R1,GFDPL            $GFDATE (R4),(R5),(R6),(R7)\n         STM   R4,R7,0(R1)\n         OI    12(R1),X'80'\n         L     R15,=A(GFDATE)\n         BASR  R14,R15\n         LTR   R10,R15\n         BNZ   GXIT\n         LTR   R2,R2               MMDDYY REQUESTED?\n         BZ    GXIT                BRANCH IF NOT.\n         MVC   0(4,R2),GMDY\n         MVC   4(2,R2),GMDY+6\nGXIT     LTR   R8,R8               GO BACK TO CALLER.\n         BZ    *+L'*+4\n         ST    R10,0(R8)\n        $XRET  CC=(R10),LV=GDWAL,TYPE=RENT\n         EJECT\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9,R11\n         SPACE 1\nGDWA     DSECT\n         DS    18F                 SAVE AREA.\nGFDPL    DS    4F                  PARM. LIST.\nGMDY     DS    CL8\nGYD      DS    CL7\nGDWAL    EQU   (((*-GDWA)+7)/8)*8\n         EJECT\nWEEKDAY  CSECT\n         SPACE 1\nWEEKDAY AMODE  ANY\nWEEKDAY RMODE  ANY\n         SPACE 1\n        $XENT  BASE=R9,DT=NO,LV=WKWAL,TYPE=RENT\n         LR    R11,R13\n         USING WKWA,R11\n         LM    R3,R4,0(R1)         R3 POINTS TO 'YYYYMMDD'.\n         MVC   FMDY(4),4(R3)\n         MVC   FMDY+4(4),0(R3)\n         MVC   FYD,=CL7' '\n         LA    R1,WWKPL            $GSDATE FMDY,FYD\n         LA    R15,FMDY\n         ST    R15,0(R1)\n         LA    R15,FYD\n         ST    R15,4(R1)\n         OI    4(R1),X'80'\n         L     R15,=A(GSDATE)\n         BASR  R14,R15\n         LTR   R10,R15\n         BNZ   SETCC\n         PACK  WRKF,FYD(4)\n         CVB   R2,WRKF\n         PACK  WRKF,FYD+4(3)\n         CVB   R3,WRKF\n         STM   R2,R3,WRKF\n         LA    R1,WWKPL            CALL GWKDAY,(WRKF,WRKF+4,(R4)),VL\n         LA    R15,WRKF\n         ST    R15,0(R1)\n         LA    R15,WRKF+4\n         ST    R15,4(R1)\n         ST    R4,8(R1)\n         OI    8(R1),X'80'\n         L     R15,=A(GWKDAY)\n         BASR  R14,R15\nSETCC   $XRET  CC=(R10),LV=WKWAL,TYPE=RENT   GO BACK TO CALLER.\n         SPACE 1\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP R9,R11\n         SPACE 1\nWKWA     DSECT\n         DS    18F                 SAVE AREA.\nWRKF     DS    D\nWWKPL    DS    3F                  PARM. LIST.\nFMDY     DS    CL8\nFYD      DS    CL7\nWKWAL    EQU   (((*-WKWA)+7)/8)*8\n         EJECT\nSDATE    CSECT\n         SPACE 1\nSDATE   AMODE  ANY\nSDATE   RMODE  ANY\n         SPACE 1\n        $XENT  BASE=R9,DT=NO,LV=SDWAL,TYPE=RENT\n         LR    R11,R13\n         USING SDWA,R11\n         TM    0(R1),X'80'         VALID PARAMETERS LIST TEST.\n         BZ    *+L'*+8\nSRRPL    LA    R10,8  - - - - - -  WRONG PARAMETERS LIST.\n         B     SXIT\n         XR    R4,R4\n         TM    4(R1),X'80'\n         BO    SOKPL\n         TM    8(R1),X'80'\n         BZ    SRRPL\n         TM    11(R1),X'03'\n         BZ    *+L'*+8\n         LA    R10,4  - - - - - -  WRONG C ALIGNMENT.\n         B     SXIT\n         L     R4,8(R1)\n         LA    R4,0(R4)\nSOKPL    LM    R2,R3,0(R1)\n         MVC   SMDY(4),0(R2)\n         MVC   SMDY+6(2),4(R2)\n         CLC   SMDY+6(2),=CL2'50'  SET CENTURY AHEAD.\n         BL    *+L'*+10\n         MVC   SMDY+4(2),=CL2'19'\n         B     *+L'*+6\n         MVC   SMDY+4(2),=CL2'20'\n         MVC   SYD,=CL7' '\n         LA    R1,SWKPL            $GSDATE SMDY,SYD\n         LA    R15,SMDY\n         ST    R15,0(R1)\n         LA    R15,SYD\n         ST    R15,4(R1)\n         OI    4(R1),X'80'\n         L     R15,=A(GSDATE)\n         BASR  R14,R15\n         LTR   R10,R15\n         BNZ   SXIT\n         MVC   0(5,R3),SYD+2\nSXIT     LTR   R4,R4               GO BACK TO CALLER.\n         BZ    *+L'*+4\n         ST    R10,0(R4)\n        $XRET  CC=(R10),LV=SDWAL,TYPE=RENT\n         SPACE 1\n*        CONSTANTS AND WORK-AREAS.\n*        -------------------------\n         SPACE 1\n        LTORG\n         SPACE 2\n         DROP  R9,R11\n         SPACE 1\nSDWA     DSECT\n         DS    18F                 SAVE AREA.\nSWKPL    DS    2F                  PARM. LIST.\nSMDY     DC    CL8' '\nSYD      DC    CL7' '\nSDWAL    EQU   (((*-SDWA)+7)/8)*8\n         EJECT\nHRDAY    CSECT\n         SPACE 1\nHRDAY   AMODE  ANY\nHRDAY   RMODE  ANY\n         SPACE 1\n         ENTRY GIORNO              DEFINE THE ALIAS NAME.\n         SPACE 1\nGIORNO  $XENT  BASE=R9,DT=NO,LV=HDWAL,TYPE=RENT\n         LR    R11,R13\n         USING HDWA,R11\n         TM    0(R1),X'80'         VALID PARAMETERS LIST TEST.\n         BO    HRRPL\n         XR    R4,R4\n         TM    4(R1),X'80'\n         BO    HOKPL\n         TM    8(R1),X'80'\n         BZ    HRRPL\n         TM    11(R1),X'03'\n         BZ    LDAD\nHRRPL    LA    R10,12 - - - - - -  WRONG PARAMETERS LIST.\n         B     HXIT\nLDAD     L     R4,8(R1)\n         LA    R4,0(R4)\nHOKPL    LM    R2,R3,0(R1)\n         LA    R1,HWKPL            $GFDATE ,HOUR,HDAY\n         XC    0(4,R1),0(R1)\n         LA    R15,HOUR\n         ST    R15,4(R1)\n         LA    R15,HDAY\n         ST    R15,8(R1)\n         OI    8(R1),X'80'\n         L     R15,=A(GFDATE)\n         BASR  R14,R15\n         LTR   R10,R15\n         BNZ   HXIT\n         MVC   0(2,R2),HOUR\n         MVI   2(R2),C'.'\n         MVC   3(2,R2),HOUR+2\n         MVI   5(R2),C'.'\n         MVC   6(2,R2),HOUR+4\n         MVC   0(2,R3),HDAY+6\n         MVI   2(R3),C'/'\n         MVC   3(2,R3),HDAY\n         MVI   5(R3),C'/'\n         MVC   6(2,R3),HDAY+2\nHXIT     LTR   R4,R4               GO BACK TO CALLER.\n         BZ    *+L'*+4\n         ST    R10,0(R4)\n        $XRET  CC=(R10),LV=HDWAL,TYPE=RENT\n         SPACE 1\n*        CONSTANTS AND WORK-AREAS.\n*        -------------------------\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R11\n         SPACE 1\nHDWA     DSECT\n         DS    18F                 SAVE AREA.\nHWKPL    DS    3F                  PARM. LIST.\nHDAY     DS    CL8\nHOUR     DS    CL6\nHDWAL    EQU   (((*-HDWA)+7)/8)*8\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GFDATE$": {"ttr": 18187, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89#o\\x00\\x89#o\\x16#\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-24T00:00:00", "modifydate": "1989-08-24T16:23:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//GFDATE   JOB (........),'INSTALL  - GFDATE -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=3\n//ASS     EXEC PAJIAS2,MBR=GFDATE\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   GWKDAY\n  ALIAS   GSDATE\n  ALIAS   GDATE\n  ALIAS   WEEKDAY\n  ALIAS   SDATE\n  ALIAS   HRDAY\n  ALIAS   GIORNO\n  NAME    GFDATE(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GFDATE@": {"ttr": 18433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89#o\\x00\\x89#o\\x16(\\x00\\xec\\x00\\xec\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-24T00:00:00", "modifydate": "1989-08-24T16:28:00", "lines": 236, "newlines": 236, "modlines": 0, "user": "SYSPAJA"}, "text": "1   24/08/89\n                                                      GFDATE    1/6.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     GENERATE DATES SUBROUTINES      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Generate dates subroutines package\n  ==================================\n\n  This package contains now the new and old routines versions for time\n  and date editing as below :\n\n         A. new versions\n            1. GFDATE   : generate fully expanded date\n            2. GWKDAY   : get week day\n            3. GSDATE   : generate serial day\n\n         B. old versions\n            4. GDATE    : generate date\n            5. WEEKDAY  : week day\n            6. SDATE    : generate serial day\n            7. HRDAY    : hour-day\n                          Alias : GIORNO\n\n  Validity check : the year YYYY, input parameter of GFDATE or GSDATE,\n  ---------------- is checked to see if in the range from 1582 up to\n                   4315 included (Gregorian calendar).\n                   No check when entering GWKDAY.\n\n  General notice : these routines are re-enterable.\n  ----------------\n1   24/08/89\n                                                      GFDATE    2/6.\n\n  1. Generate fully expanded date\n  ===============================\n  Calling sequence : CALL GFDATE,(A,B,C,D,E),VL\n  ------------------             (A,B,C,D)\n                                 (A,B,C)\n                                 (A,B)\n                                 (A)\n\n         Where : A - receives the fully expanded date in characters\n                     (format CL20), as for example :\n\n                             'WED, DEC. 09, 1981  '\n\n                 B - receives the time of day (HHMMSS) in characters\n                     (format CL6) if supplied (optional argument) and\n                     if the D-argument is not supplied. In case the\n                     D-argument is present, B-argument is never build.\n\n                 C - receives the date (MMDDYYYY) in characters\n                     (format CL8) if supplied (optional argument).\n\n                 D - if argument is present, it must be a serial day\n                     (YYYYDDD) in characters (format CL7). If argument\n                     is omited, the date and time of day is obtained\n                     from the System. This parameter may be usefull to\n                     obtain the fully expanded date of a predetermined\n                     serial date (YYYYDDD).\n\n                 E - receives the return code (format FULLWORD -\n                     F boundary) if supplied (optional).\n\n         Thus : A, B and C are output parameters, and D, if present,\n                is an input parameter.\n\n         N.B. - If one or more addresses of the A, B, C or D arguments\n         ----   are zero in the parameters list, the processing for the\n                corresponding argument will be skipped.\n\n  Return codes (register 15) : 0 = normal.\n  ---------------------------- 4 = wrong D parameter or E parameter\n                                   alignment.\n                               8 = more than 5 parameters.\n1   24/08/89\n                                                      GFDATE    3/6.\n\n  Assembler macro : $GFDATE A,B,C,D,E\n  -----------------\n\n         Where A, B, C, D and/or E are optional and may be omited.\n         Register use may be coded within parentheses.\n\n  2. Get week day\n  ===============\n  Calling sequence : CALL GWKDAY,(A,B,C),VL\n  ------------------\n\n         Where : A - is the address of the year in binary (format is a\n                     FULLWORD).\n                 B - is the address of the serial day in binary (format\n                     is a FULLWORD).\n                 C - Receives a day binary index (format XL1, value is\n                     0 to 6 for Sunday to Saturday).\n\n  3. Generate serial day\n  ======================\n  Calling sequence : CALL GSDATE,(A,B,C),VL\n  ------------------             (A,B)\n\n         Where : A - is the date (MMDDYYYY) in characters (format CL8).\n\n                 B - receives the serial date (YYYYDDD) in characters\n                     (format CL7).\n\n                 C - receives the return code (format FULLWORD -\n                     F boundary) if supplied (optional).\n\n  Return codes (register 15) : 0 = normal.\n  ---------------------------- 4 = wrong A parameter or C parameter\n                                   alignment.\n                               8 = wrong parameters list or more than 3\n                                   parameters.\n\n  Assembler macro : $GSDATE A,B,C\n  -----------------\n\n         Where C is optional and may be omited.\n         Register use may be coded within parentheses.\n1   24/08/89\n                                                      GFDATE    4/6.\n\n  4. Generate date\n  ================\n  Calling sequence : CALL GDATE,(A,B,C,D,E),VL\n  ------------------            (A,B,C,D)\n                                (A,B,C)\n                                (A,B)\n                                (A)\n\n         Where : A - receives the fully expanded date in characters\n                     (format CL20), as for example :\n\n                             'WED, DEC. 09, 1981  '\n\n                 B - receives the time of day (HHMMSS) in characters\n                     (format CL6) if supplied (optional argument) and\n                     if the D-argument is not supplied. In case the\n                     D-argument is present, B-argument is never build.\n\n                 C - receives the date (MMDDYY) in characters\n                     (format CL6) if supplied (optional argument).\n\n                 D - if argument is present, it must be a serial day\n                     (YYDDD) in characters (format CL5). If argument is\n                     omited, the date and time of day is obtained from\n                     the System. This parameter may be usefull to\n                     obtain the fully expanded date of a predetermined\n                     serial date (YYDDD).\n\n                 E - receives the return code (format FULLWORD -\n                     F boundary) if supplied (optional).\n\n         Thus : A, B and C are output parameters, and D, if present,\n                is an input parameter.\n\n         N.B. - If one or more addresses of the A, B, C or D arguments\n         ----   are zero in the parameters list, the processing for the\n                corresponding argument will be skipped.\n1   24/08/89\n                                                      GFDATE    5/6.\n\n  Return codes (register 15) : 0 = normal.\n  ---------------------------- 4 = wrong D parameter or E parameter\n                                   alignment.\n                               8 = more than 5 parameters.\n\n  Assembler macro : $GDATE A,B,C,D,E\n  -----------------\n\n         Where A, B, C, D and/or E are optional and may be omited.\n         Register use may be coded within parentheses.\n\n\n  5. Week day\n  ===========\n  Calling sequence : CALL WEEKDAY,(A,B),VL\n  ------------------\n\n         Where : A - is year, month and day (YYYYMMDD) in characters\n                     (format CL8).\n                 B - Receives a day binary index (format XL1, value is\n                     0 to 6 for Sunday to Saturday).\n\n  6. Generate serial day\n  ======================\n  Calling sequence : CALL SDATE,(A,B,C),VL\n  ------------------            (A,B)\n\n         Where : A - is the date MMDDYY in characters (format CL6).\n\n                 B - receives the serial date YYDDD in characters\n                     (format CL5).\n\n                 C - receives the return code (format FULLWORD -\n                     F boundary) if supplied (optional).\n\n  Return codes (register 15) : 0 = normal.\n  ---------------------------- 4 = wrong A parameter or C parameter\n                                   alignment.\n                               8 = wrong parameters list or more than\n                                   3 parameters.\n\n  Assembler macro : $SDATE A,B,C\n  -----------------\n\n         Where C is optional and may be omited.\n         Register use may be coded within parentheses.\n1   24/08/89\n                                                      GFDATE    6/6.\n\n  7. Hour-Day\n  ===========\n  Calling sequence : CALL HRDAY,(A,B,C),VL\n  ------------------            (A,B)\n\n         Where : A - receives the time of day (HH.MM.SS) in characters\n                     (format CL8).\n\n                 B - receives the date (YY/MM/DD) in characters\n                     (format CL8).\n\n                 C - receives the return code (format FULLWORD -\n                     F boundary) if supplied (optional).\n\n         Return codes : 0, 4 or 8 = those of GFDATE subroutine.\n                        12 = wrong parameters list.\n                        Return code is always placed in register 15.\n\n         Alias : CALL GIORNO,(A,B,C),VL\n                             (A,B)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GGUR": {"ttr": 18438, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x17\\x11\\x01Q\\x01Q\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T17:11:00", "lines": 337, "newlines": 337, "modlines": 0, "user": "SYSPAJA"}, "text": "GGUR     TITLE 'GET GROUP''S USERIDS FROM RACF - ROUTINE.'\nGGUR     START 0\n         SPACE 1\n* CALLING SEQUENCE : CALL GGUR,(A,B,C),VL\n* ------------------ CALL GGUR,(A,B),VL\n*\n*        WHERE : A - IS THE ADDRESS OF THE DESIRED RACF GROUP NAME\n*                    (FORMAT CL8). THIS ARGUMENT IS MANDATORY, AND\n*                    MUST BE RIGHT PADDED WITH BLANKS.\n*\n*                B - IS THE ADDRESS OF AN ARRAY INTO WHICH THE USERIDS\n*                    PART OF THE REQUESTED RACF GROUP ARE STORED. THE\n*                    FORMAT IS AS FOLLOWS :\n*                            DC  AL2(NO. OF USERIDS OR ZERO)\n*                            DC  CL8'1ST USERID'\n*                            DC  CL8'2ND USERID'\n*                            ...\n*                            DC  CL8'NTH USERID'\n*                    THE ARRAY MUST BE LARGE ENOUGH TO RECEIVES THE\n*                    MAXIMUM NUMBER OF USERIDS FOR A RACF GROUP, UNLESS\n*                    UNPREDICTABLE RESULTS MAY OCCUR.\n*                    THIS ARGUMENT IS MANDATORY.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                    -1 - GROUP NAME NOT FOUND.\n*                     0 - REQUEST CORRECTLY EXHAUSTED.\n*                     1 - RACF INACTIVE.\n*                     2 - REGION SPACE TOO SMALL.\n*                     3 - RACF READ TYPE 'GRP' ERROR.\n*                     4 - RACF-GRP NO DATA RETURNED BACK.\n*                     5 - GROUPS/USERIDS TABLE OVERFLOW.\n*                     6 - TABLE EMPTY, NO GROUPS.\n*                     7 - CALLING SEQUENCE OR ARGUMENT ERROR.\n*\n*\n* CALLING SEQUENCE : CALL GGUCL,(A),VL\n* ------------------ CALL GGUCL ---> WITH R1=0\n*\n*        WHERE : A - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - INTERNAL RACF TABLE SPACE RELEASED.\n*                     1 - CALLING SEQUENCE OR ARGUMENT ERROR.\n*\n* NOTES : ON ANY ERROR DETECTION, A MESSAGE IS INCLUDED IN THE MESSAGE\n* ======= CLASS FOR THE JOB.\n*         MVS/XA : MUST BE AMODE AND RMODE 24.\n         EJECT\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n        $DEFREG\n*        WORK-AREAS SPACE DEFINITIONS.\n         SPACE 1\nMXG      EQU   500                 MAX. NUMBER OF GROUP NAMES\nMXU      EQU   4000                MAX. USERIDS INTO ALL GROUPS\nWAL      EQU   2000                RACF WORK AREA SPACE LENGTH\n         SPACE 1\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nGRL      EQU   8+2                 GROUP INFO LENGTH\nUSL      EQU   8                   USERID INFO LENGTH\nMXGRL    EQU   (MXG*GRL)           GROUPS INFO AREA\nMXUSL    EQU   (MXU*USL)           USERIDS INTO GROUPS INFO AREA\nTOTL     EQU   ((MXGRL+MXUSL+11)/8)*8   TOTAL AREA + ALIGNMENT\nWALL     EQU   ((WAL+7)/8)*8       RACF WORK AREA\n         EJECT\n        $XENT  BASE=R12\n         SPACE 1\n         SR    R9,R9               SET DEFAULTS.\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    ERR7\n         TM    4(R1),X'80'\n         BO    NOIND\n         TM    8(R1),X'80'\n         BZ    ERR7\n         TM    11(R1),X'03'\n         BNZ   ERR7\n         L     R9,8(R1)\n         LA    R9,0(R9)\nNOIND    LM    R7,R8,0(R1)\n         LA    R8,0(R8)\n         LA    R7,0(R7)\n         L     R6,TABLE\n         LTR   R6,R6               GROUPS-USERIDS TABLE EXIST?\n         BNZ   SEARCH              YES\n         SPACE 1\n*        GET SPACE FOR WORK-AREAS.\n         SPACE 1\n        RACSTAT ,                  TEST RACF ACTIVE\n         LTR   R15,R15             ACTIVE?\n         BNZ   ERR1                NO\n        GETMAIN EC,LV=TOTL,A=TABLE\n         LTR   R15,R15             STORAGE AVAILABLE?\n         BNZ   ERR2                NO\n         L     R1,TABLE            ZEROES TABLE SPACE\n         LR    R2,R1\n         L     R3,=A(TOTL)\n         LA    R4,*\n         SR    R5,R5\n         MVCL  R2,R4\n         AL    R1,=A(MXGRL+MXUSL)  COMPUTE TABLE OVERFLOW POINTER\n         ST    R1,TABLEND\n        GETMAIN EC,LV=WALL,A=WAR\n         LTR   R15,R15             STORAGE AVAILABLE?\n         BNZ   ERR2                NO\n         L     R2,WAR              ZEROES RACF WORK AREA\n         LR    R6,R2\n         L     R3,=A(WALL)\n         LA    R4,*\n         SR    R5,R5\n         MVCL  R2,R4\n         MVC   0(4,R6),=A(WALL)\n         SPACE 1\n*        GET GROUPS/USERS FROM RACF.\n         SPACE 1\n         L     R5,TABLE\n         LA    R1,L'GRNAME\n         STC   R1,GRNMEL\n         MVC   GRNAME,=CL8' '\n         USING WADS,R6\n        SETAUTH\nGREAD    XC    WARBA(WARBSL),WARBA\n        ICHEINTY NEXTC,TYPE='GRP',ENTRY=GRNMEL,WKAREA=(R6),            1\n               ACTIONS=(AGC,AGL)\n         CH    R15,=H'12'          END OF FILE?\n         BE    GREND               YES\n         LTR   R15,R15             ANY ERROR?\n         BNZ   ERR3                YES\n         OC    WARTL,WARTL         DATA RETURNED?\n         BZ    ERR4                NO\n         LA    R1,GRL(R5)\n         CL    R1,TABLEND\n         BNL   ERR5                TABLE OVERFLOW\n         SR    R1,R1\n         IC    R1,GRNMEL           GET LENGTH OF GROUP NAME\n         BCTR  R1,0                -1 FOR MOVE\n         MVC   0(8,R5),=CL8' '\n         EX    R1,GRNMMV           SET GROUP NAME\n         MVC   LSTGNM+29(8),0(R5)  SET FOR EVENTUAL DIAGNOSE\n         LA    R2,WARVRA           START OF VARIABLE FIELDS\n         MVC   8(2,R5),2(R2)       SET NO. USERIDS\n         SR    R3,R3\n         ICM   R3,B'0011',2(R2)    GET NO. USERIDS\n         BZ    GRNONE              AT LEAST ONE? BRANCH IF NO\n         LA    R2,6(R2)            POINTS TO NAMES LIST\n         LR    R1,R3\n         MH    R1,=Y(USL)\n         LA    R1,GRL(R1,R5)\n         CL    R1,TABLEND\n         BNL   ERR5                TABLE OVERFLOW\nGRLOOP   MVC   GRL(8,R5),0(R2)     MOVE USERID\n         LA    R2,8(R2)            ADVANCE IN NAMES LIST\n         LA    R5,USL(R5)          ADVANCE IN TABLE\n         BCT   R3,GRLOOP           LOOP IF ANY MORE\nGRNONE   LA    R5,GRL(R5)          BUMP GROUP POINTER\n         B     GREAD\nGRNMMV   MVC   0(*-*,R5),GRNAME    << EXECUTED >>\n         DROP  R6\nGREND   RESAUTH\n        FREEMAIN E,LV=WALL,A=WAR\n         MVC   WAR,=F'0'\n         L     R6,TABLE\n         CLR   R5,R6\n         BNH   ERR6                TABLE EMPTY, NO GROUPS\n         SPACE 1\n*        PROCESS THE GROUP-NAME REQUESTED.\n         SPACE 1\nSEARCH   CLC   0(4,R6),=F'0'       END OF TABLE?\n         BE    NOTFND              YES, NOT FOUND\n         CLC   0(8,R6),0(R7)       THIS GROUP-NAME?\n         BE    FOUND               YES\n         SR    R1,R1               NO, BUMP TO NEXT\n         ICM   R1,B'0011',8(R6)\n         MH    R1,=Y(USL)\n         LA    R6,GRL(R1,R6)\n         B     SEARCH\nFOUND    MVC   0(2,R8),8(R6)       SET NO. OF USERIDS\n         SR    R1,R1\n         ICM   R1,B'0011',8(R6)\n         BZ    EXIT\nLOOP     MVC   2(8,R8),GRL(R6)     MOVE USERID\n         LA    R8,8(R8)            ADVANCE IN ARRAY LIST\n         LA    R6,USL(R6)          ADVANCE IN TABLE\n         BCT   R1,LOOP             LOOP IF ANY MORE\n         SPACE 1\n*        NORMAL/ABNORMAL EXITS.\n         SPACE 1\nEXIT     SR    R10,R10             C.C. = 0.\n         B     GREXIT\n         SPACE 1\nNOTFND   SR    R10,R10\n         BCT   R10,GREXIT          C.C. = -1.\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nERR4     BCTR  R10,0\nERR5     BCTR  R10,0\nERR6     BCTR  R10,0\nERR7     BCTR  R10,0\n         SPACE 1\nMAXERR   EQU   ((*-ERR1)/2)+1\n         SPACE 1\n         LR    R2,R10\n         BCTR  R2,0\n         LA    R3,ACTION(R2)\n         SLL   R2,2\n         L     R1,TABD(R2)\n        WTO    MF=(E,(1))\n         TM    0(R3),ACTRS\n         BZ    GRNORS\n        RESAUTH\nGRNORS   TM    0(R3),ACTDG\n         BZ    GRNODG\n        WTO    MF=(E,LSTGNM)\nGRNODG   TM    0(R3),ACTFR\n         BZ    GRNOWA\n         CLC   WAR,=F'0'\n         BE    GRNOWA\n        FREEMAIN E,LV=WALL,A=WAR\n         MVC   WAR,=F'0'\nGRNOWA   TM    0(R3),ACTFT\n         BZ    GREXIT\n         CLC   TABLE,=F'0'\n         BE    GREXIT\n        FREEMAIN E,LV=TOTL,A=TABLE\n         MVC   TABLE,=F'0'\nGREXIT   LTR   R9,R9\n         BZ    *+L'*+4\n         ST    R10,0(R9)           STORE IND.\n         SPACE 1\n*        THAT'S ALL FOLKS.\n         SPACE 1\n        $XRET  CC=(R10)\n         SPACE 1\n         DROP  R12\n         EJECT\n         ENTRY GGUCL\n         SPACE 1\nGGUCL   $XENT  BASE=R12,DT=NO\n         SPACE 1\n         SR    R9,R9               CONTROL ARGUMENTS.\n         LTR   R1,R1\n         BZ    GCNONE\n         TM    0(R1),X'80'\n         BZ    ERCL\n         TM    3(R1),X'03'\n         BNZ   ERCL\n         L     R9,0(R1)\n         LA    R9,0(R9)\n         SPACE 1\nGCNONE   SR    R10,R10\n         CLC   WAR,=F'0'\n         BE    GCNOWA\n        FREEMAIN E,LV=WALL,A=WAR\n         MVC   WAR,=F'0'\nGCNOWA   CLC   TABLE,=F'0'\n         BE    GCEXIT\n        FREEMAIN E,LV=TOTL,A=TABLE\n         MVC   TABLE,=F'0'\nGCEXIT   LTR   R9,R9\n         BZ    *+L'*+4\n         ST    R10,0(R9)           STORE IND.\n         SPACE 1\n*        THAT'S ALL FOLKS.\n         SPACE 1\n        $XRET  CC=(R10)\n         SPACE 1\nERCL    WTO    'GGUCL/ERR=1 - CALLING SEQUENCE OR ARGUMENT ERROR.',    1\n               ROUTCDE=11,DESC=7\n         LA    R10,1\n         B     GCNONE+L'GCNONE\n         SPACE 1\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nTABD     DC    A(DIAG1,DIAG2,DIAG3,DIAG4,DIAG5,DIAG6,DIAG7)\nTABLE    DC    A(*-*)\nTABLEND  DC    A(*-*)\nWAR      DC    A(*-*)\nGRNMEL   DC    AL1(*-*)\nGRNAME   DC    CL8' '\n         SPACE 1\nACTION   DS    0XL1                ACTION SWITCHES BYTES\nACTRS    EQU   X'80'                    RESET AUTH.\nACTDG    EQU   X'40'                    DIAGNOSE LAST GROUP NAME\nACTFR    EQU   X'20'                    RELEASE RACF WORK AREA\nACTFT    EQU   X'10'                    RELEASE TABLE SPACE\n         DC    AL1(0)                                  ERR. 1\n         DC    AL1(ACTFR)                              ERR. 2\n         DC    AL1(ACTRS+ACTDG+ACTFR)                  ERR. 3\n         DC    AL1(ACTRS+ACTDG+ACTFR)                  ERR. 4\n         DC    AL1(ACTRS+ACTDG+ACTFR+ACTFT)            ERR. 5\n         DC    AL1(0)                                  ERR. 6\n         DC    AL1(0)                                  ERR. 7\n         SPACE 1\nAGC     ICHEACTN FIELD=ACLCNT\nAGL     ICHEACTN FIELD=USERID\n         EJECT\n         PRINT NOGEN\nLSTGNM  WTO    'GGUR - LAST GROUP NAME :         ',                    1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG1   WTO    'GGUR/ERR=1 - RACF INACTIVE.',                          1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG2   WTO    'GGUR/ERR=2 - REGION SPACE TOO SMALL.',                 1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG3   WTO    'GGUR/ERR=3 - RACF READ TYPE ''GRP'' ERROR.',           1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG4   WTO    'GGUR/ERR=4 - RACF-GRP NO DATA RETURNED BACK.',         1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG5   WTO    'GGUR/ERR=5 - GROUPS/USERIDS TABLE OVERFLOW.',          1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG6   WTO    'GGUR/ERR=6 - TABLE EMPTY, NO GROUPS.',                 1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG7   WTO    'GGUR/ERR=7 - CALLING SEQUENCE OR ARGUMENT ERROR.',     1\n               ROUTCDE=11,DESC=7,MF=L\n         PRINT GEN\n         SPACE 2\n        LTORG\n         SPACE 2\nWADS     DSECT                     RACF WORK AREA DESCRIPTION\n         DS    F                   LENGTH OF ENTIRE USER AREA\nWARBA    DS    XL8,F,XL8\nWARTL    DS    F                   LENGTH OF DATA RETURNED INTO W.A.\nWARVRA   DS    XL4 ...             FIELD VALUE RETURN AREA (VARIABLE)\nWARBSL   EQU   *-WARBA\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GGUR$": {"ttr": 18444, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14\"\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:22:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "//GGUR     JOB (........),'INSTALL  - GGUR -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,MBR=GGUR\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   GGUCL\n  NAME    GGUR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GGUR@": {"ttr": 18689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14R\\x00K\\x00K\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:52:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "SYSPAJA"}, "text": "1   19/06/86\n                                                      GGUR      1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         GET GROUP'S USERIDS         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         FROM RACF - ROUTINE.        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL GGUR,(A,B,C),VL\n  ------------------ CALL GGUR,(A,B),VL\n\n         Where : A - is the address of the desired RACF GROUP name\n                     (format CL8). This argument is mandatory, and\n                     must be right padded with blanks.\n\n                 B - is the address of an array into which the USERIDs\n                     part of the requested RACF GROUP are stored. The\n                     format is as follows :\n                             DC  AL2(no. of USERIDs or zero)\n                             DC  CL8'1st USERID'\n                             DC  CL8'2nd USERID'\n                             ...\n                             DC  CL8'nth USERID'\n                     The array must be large enough to receives the\n                     maximum number of USERIDs for a RACF GROUP, unless\n                     unpredictable results may occur.\n                     This argument is mandatory.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                     -1 - GROUP name not found.\n                      0 - request correctly exhausted.\n                      1 - RACF inactive.\n                      2 - region space too small.\n                      3 - RACF read type GRP error.\n                      4 - RACF-GRP no data returned back.\n                      5 - GROUPs/USERIDs table overflow.\n                      6 - table empty, no GROUPs.\n                      7 - calling sequence or argument error.\n\n  Assembler macro : $GGUR A,B,C\n  -----------------\n\n         Where C is optional and may be omitted.\n         Register use may be coded within parentheses.\n1   30/07/86\n                                                      GGUR      2/2.\n\n  Calling sequence : CALL GGUCL,(A),VL\n  ------------------ CALL GGUCL ---> with R1=0\n\n         Where : A - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - internal RACF table space released.\n                      1 - calling sequence or argument error.\n\n  Assembler macro : $GGUCL A\n  -----------------\n\n         Where A is optional and may be omitted.\n         Register use may be coded within parentheses.\n\n\n  NOTES : 1. On any error detection, a message is included in the\n  =======    message class for the job.\n          2. At the first call of GGUR, an internal table is builded\n             with all the RACF GROUPs/USERIDs. At execution end, call\n             GGUCL to release this space.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GPARM": {"ttr": 18692, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x0f\\x00\\x882\\x0f\\x16Q\\x00;\\x00;\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-15T00:00:00", "modifydate": "1988-11-15T16:51:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "SYSPAJA"}, "text": "GPAR     TITLE 'GET PARM. FIELD SUBROUTINE.'\nGPARM    START 0\n         SPACE 1\nGPARM   AMODE  ANY\nGPARM   RMODE  ANY\n         SPACE 1\n* CALLING SEQUENCE : CALL GPARM,(A),VL\n* ------------------\n*\n*        WHERE : A - IS THE ADDRESS OF A FIELD (FORMAT CL...) INTO\n*                    WHICH THE CONTENTS OF THE 'EXEC STATEMENT'\n*                    PARM. FIELD IS MOVED AS DESCRIBED BELOW :\n*\n*                    A --->          DC    AL2(L'PARM)\n*                           PARM     DC    C'...TEXT...'\n*\n*                    OR IN CASE THERE IS NO PARM. FIELD :\n*\n*                    A --->          DC    AL2(0)\n*\n*                    THIS ARGUMENT IS MANDATORY BECAUSE INFORMATION IS\n*                    RETURNED TO THE CALLER.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n        PRINT  NOGEN\n         SPACE 1\n        CVT    DSECT=YES,LIST=YES\n         SPACE 1\n        IKJTCB LIST=YES\n         SPACE 1\nGPARM    CSECT                     RESTORE ORIGINAL CSECT.\n         SPACE 1\n        PRINT  GEN\n         EJECT\n        $XENT  BASE=R12\n         L     R2,0(R1)\n         L     R3,CVTPTR           CVT POINTER.\n         USING CVT,R3\n         L     R4,CVTTCBP\n         DROP  R3\n         L     R3,4(R4)            CURRENT TCB.\n         USING TCB,R3\n         L     R4,TCBFSA           FIRST SAVE AREA OF PROBLEM.\n         DROP  R3\n         L     R1,24(R1)           RESTORE ENTRY REG. 1.\n         L     R1,0(R1)            PARM. FIELD ADDRESS.\n         LH    R3,0(R1)            GET PARM. FIELD LENGTH.\n         LA    R3,1(R3)\n         EX    R3,MVPARM           GIVE PARM. FIELD TO CALLER.\nEXIT    $XRET  CC=0\n         SPACE 1\nMVPARM   MVC   0(*-*,R2),0(R1)\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GPARM$": {"ttr": 18694, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x17\"\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T17:22:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//GPARM    JOB (........),'INSTALL  - GPARM -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,MBR=GPARM\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ENTRY   GPARM\n  NAME    GPARM(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GPARM@": {"ttr": 18696, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      GPARM     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         OBTAIN PARM. FIELD          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL GPARM,(A),VL\n  ------------------\n\n         Where : A - is the address of a field (format CL...) into\n                     which the contents of the EXEC statement parm.\n                     field is moved as described below :\n\n                     A --->          DC    AL2(L'PARM)\n                            PARM     DC    C'...TEXT...'\n\n                     or in case there is no parm. field :\n\n                     A --->          DC    AL2(0)\n\n                     This argument is mandatory because information is\n                     returned to the caller.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GUAR": {"ttr": 18698, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x17\\x11\\x01O\\x01O\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T17:11:00", "lines": 335, "newlines": 335, "modlines": 0, "user": "SYSPAJA"}, "text": "GUAR     TITLE 'GET USERID ACCOUNT FROM SYS1.UADS (TSO) - ROUTINE.'\nGUAR     START 0\n         SPACE 2\n* CALLING SEQUENCE : CALL GUAR,(A,B,C),VL\n* ------------------ CALL GUAR,(A,B),VL\n*\n*        WHERE : A - IS THE ADDRESS OF THE DESIRED USERID (FORMAT CL7).\n*                    THIS ARGUMENT IS MANDATORY, AND MUST BE RIGHT\n*                    PADDED WITH BLANKS.\n*\n*                B - IS THE ADDRESS OF AN ARRAY INTO WHICH THE ACCOUNT\n*                    FIELD(S) FOR THE REQUESTED USERID ARE STORED. THE\n*                    FORMAT IS AS FOLLOWS :\n*                            DC  AL2(NO. OF ACCOUNT FIELDS OR ZERO)\n*                            DC  AL1(L'ACC1)\n*                      ACC1  DC  C'ACCOUNT FIELD'\n*                            ...\n*                            DC  AL1(L'ACCN)\n*                      ACCN  DC  C'ACCOUNT FIELD'\n*                    THE ARRAY MUST BE LARGE ENOUGH TO RECEIVES THE\n*                    MAXIMUM NUMBER OF ACCOUNT FIELDS FOR A USERID,\n*                    UNLESS UNPREDICTABLE RESULTS MAY OCCUR.\n*                    THIS ARGUMENT IS MANDATORY.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                    -1 - USERID NOT FOUND.\n*                     0 - REQUEST CORRECTLY EXHAUSTED.\n*                     1 - SYSUADS DD-CARD MISSING.\n*                     2 - SYSUADS OPEN ERROR.\n*                     3 - SYSUADS BLDL ERROR.\n*                     4 - SYSUADS UNEXPECTED EOF.\n*                     5 - SYSUADS READ ERROR.\n*                     6 - CALLING SEQUENCE OR ARGUMENT ERROR.\n*\n*\n* CALLING SEQUENCE : CALL GUACL,(A),VL\n* ------------------ CALL GUACL ---> WITH R1=0\n*\n*        WHERE : A - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE OR ARGUMENT ERROR.\n*\n* NOTES : 1. ON ANY ERROR DETECTION, A MESSAGE IS INCLUDED IN THE\n* =======    MESSAGE CLASS FOR THE JOB.\n*         2. THIS ROUTINE NEEDS TO RUN A JCL DD-CARD AS BELOW :\n*              //SYSUADS DD DSN=SYS1.UADS,DISP=SHR\n*         3. MVS/XA : MUST BE AMODE AND RMODE 24.\n         EJECT\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 2\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMXMU     EQU   3    <--- MAXIMUM NUMBER OF MEMBERS FOR A USERID       *\n*                        (ACCEPTABLE RANGE IS : 1 UP TO 9).           *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         EJECT\n        $XENT  BASE=R12\n         SPACE 1\n         SR    R9,R9               SET DEFAULTS.\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    ERR6\n         TM    4(R1),X'80'\n         BO    GR1\n         TM    8(R1),X'80'\n         BZ    ERR6\n         TM    11(R1),X'03'\n         BNZ   ERR6\n         L     R9,8(R1)\n         LA    R9,0(R9)\nGR1      LM    R7,R8,0(R1)\n         LA    R8,0(R8)\n         LA    R7,0(R7)\n         SPACE 1\n         LA    R2,SYSUADS\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   ALREADY OPENED?\n         BO    GR5                 YES.\n         OC    ATIOT(L'ATIOT),ATIOT     FIRST TIME?\n         BNZ   GR2                 NO.\n        EXTRACT ATIOT,'S',FIELDS=(TIOT)\nGR2      L     R3,ATIOT            SEARCH DD AND OPEN IT.\n         USING TIODSECT,R3\nGR3      CLC   TIOELNGH(4),=F'0'\n         BE    ERR1\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM\n         BE    GR4\n         SR    R1,R1\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     GR3\n         DROP  R3\nGR4     OPEN   (SYSUADS,(INPUT))\n         TM    DCBOFLGS,DCBOFOPN   SUCCESSFULLY OPENED?\n         BZ    ERR2                NO, ERROR.\n         LH    R0,DCBBLKSI         GET UADS BLOCKSIZE.\n         DROP  R2\n         ST    R0,INUSIZ           PHYSICAL BLOCK LENGTH.\n         MH    R0,MXMEMB           N TIMES.\n         LH    R2,MXMEMB           COMPUTE BLDL SPACE.\n         MH    R2,MXMEMB+2\n         AH    R2,=H'4'\n         AR    R0,R2               ADD BLDL SPACE.\n         AH    R0,=H'7'            ROUND UP TO DOUBLE WORD.\n         SRL   R0,3\n         SLL   R0,3\n         ST    R0,INULEN           SAVE IT.\n        GETMAIN R,LV=(0)\n         ST    R1,INUPTR\n         AR    R1,R2               ADD BLDL SPACE.\n         ST    R1,INUBUF\n         SPACE 1\nGR5      L     R2,INUPTR           GET REQUESTED USERID.\n         MVC   0(4,R2),MXMEMB      SET START OF BLDL LIST.\n         LA    R15,4(R2)\n         MVC   0(8,R15),=CL8' '    ONE BLDL ENTRY = 12 BYTES.\n         MVC   8(4,R15),=F'0'\n         LA    R1,6(R7)\nGR6      CLI   0(R1),C' '\n         BNE   GR7\n         CLR   R1,R7\n         BNH   ERR6\n         BCT   R1,GR6\nGRMV     MVC   0(*-*,R15),0(R7)    <<EXECUTED>>\nGR7      SLR   R1,R7\n         EX    R1,GRMV\n         LA    R14,1(R1,R15)\n         MVI   0(R14),C'0'         APPEND '0' TO USERID.\n         LH    R3,MXMEMB\n         SR    R1,R1\nGR8      BCT   R3,*+L'*+4\n         B     GR9\n         LA    R1,1(R1)\n         LA    R15,12(R15)\n         LA    R14,12(R14)\n         MVC   0(12,R15),4(R2)     BUILD NEXT BLDL ENTRY.\n         EX    R1,GROI             APPEND 'N' TO USERID.\n         B     GR8\nGROI     OI    0(R14),*-*          <<EXECUTED>>\n         SPACE 1\nGR9     BLDL   SYSUADS,(R2)\n         LTR   R15,R15             IS USERID IN UADS?\n         BZ    GR10                YES.\n         CH    R15,=H'4'           WAS ERROR DUE TO MEMBER NOT FOUND.\n         BNE   ERR3                NO, I/O ERROR OR DCB ERROR.\nGR10     L     R4,INUBUF\n         LR    R3,R4               START OF READ.\n         LA    R2,4(R2)            SET TO MEMBER0.\n         BAL   R11,UADGET          READ MEMBER0.\n         B     NOTFND              +0 - NOT FOUND.\n         LH    R5,MXMEMB\nGR11     BCT   R5,*+L'*+4\n         B     PROCESS             END OF READ.\n         AL    R3,INUSIZ           NEXT TO READ.\n         LA    R2,12(R2)           SET TO NEXT MEMBER.\n         BAL   R11,UADGET          READ MEMBER.\n         B     PROCESS             +0 - NO MORE.\n         B     GR11\nUADGET   CLI   10(R2),0            WAS MEMBER FOUND.\n         BER   R11                 NO, BRANCH.\n        FIND   SYSUADS,8(R2),C\n         XC    UADDECB(4),UADDECB  CLEAR ECB\n         NI    SWREAD+1,OFF        RESET READ ERROR SWITCH.\n        READ   UADDECB,SF,SYSUADS,(R3),'S',MF=E\n        CHECK  UADDECB\nSWREAD   NOP   ERR5\n         B     4(R11)\n         SPACE 1\nPROCESS  SR    R14,R14             NO. OF ACCOUNT FIELDS.\n         LA    R15,2(R8)           START ADDRESS.\n         USING DHED,R4             --->  HEADER BLOCK.\n         L     R5,UADSPWD1\n         LA    R5,UADSMHDR(R5)\n         USING DPOB,R5             ---> PASSWORD LEVEL.\nNEWPASS  L     R6,UADSPSUB\n         LA    R6,UADSMHDR(R6)\n         USING DNOB,R6             ---> ACCOUNT LEVEL.\nNEWACCT  ICM   R7,B'1111',UADSADAT ACCOUNT PRESENT?\n         BZ    UPTOACCT            NO, BRANCH.\n         LA    R7,UADSMHDR(R7)\n         USING DNOBD,R7\n         SR    R2,R2\n         IC    R2,UADSALEN\n         LTR   R2,R2               LENGTH ZERO?\n         BZ    UPTOACCT            YES, BRANCH.\n         LA    R1,L'UADSANUM\n         CLR   R2,R1\n         BNH   *+L'*+2\n         LR    R2,R1\n         STC   R2,0(R15)           SET LENGTH.\n         BCT   R2,*+L'*+6\n         MVC   1(*-*,R15),UADSANUM <<EXECUTED>>\n         EX    R2,*-6              SET UP TO 40 DIGITS OF ACCOUNT.\n         LA    R14,1(R14)          UPDATE NO. OF ACC. FIELDS STORED.\n         LA    R15,2(R2,R15)       UPDATE ADDRESS.\n         DROP  R7\n         SPACE 1\nUPTOACCT TM    UADSAFLG,AFLG01     ANY MORE ACCOUNT NUMBERS?\n         BO    UPTOPASS            NO, GO UP 1 LEVEL.\n         SR    R1,R1\n         ICM   R1,B'0111',UADSANEX\n         LA    R6,UADSMHDR(R1)\n         BNZ   NEWACCT\n         DROP  R6\nUPTOPASS TM    UADSPFLG,PFLG01     ANY MORE PASSWORDS?\n         BO    ENDUSER             NO, FINISHED THE USERID.\n         SR    R1,R1\n         ICM   R1,B'0111',UADSPNEX\n         LA    R5,UADSMHDR(R1)\n         BNZ   NEWPASS\n         DROP  R4,R5\nENDUSER  STCM  R14,B'0011',0(R8)   SET NO. OF ACCOUNT FILEDS.\n         SR    R10,R10             C.C. = 0.\n         B     GREXIT\n         SPACE 1\nNOTFND   SR    R10,R10\n         BCT   R10,GREXIT          C.C. = -1.\n         SPACE 1\nUADERR   OI    SWREAD+1,ON         SET READ ERROR SWITCH.\n         BR    R14\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nERR4     BCTR  R10,0\nERR5     BCTR  R10,0\nERR6     BCTR  R10,0\n         SPACE 1\nMAXERR   EQU   ((*-ERR1)/2)+1\n         SPACE 1\n         LR    R2,R10\n         BCTR  R2,0\n         SLL   R2,2\n         L     R1,TABD(R2)\n        WTO    MF=(E,(1))\nGREXIT   LTR   R9,R9\n         BZ    *+L'*+4\n         ST    R10,0(R9)           STORE IND.\n        $XRET  CC=(R10)\n         SPACE 1\n         DROP  R12\n         EJECT\n         ENTRY GUACL\n         SPACE 1\nGUACL   $XENT  BASE=R12,DT=NO\n         SPACE 1\n         SR    R9,R9               CONTROL ARGUMENTS.\n         LTR   R1,R1\n         BZ    GCNONE\n         TM    0(R1),X'80'\n         BZ    ERCL\n         TM    3(R1),X'03'\n         BNZ   ERCL\n         L     R9,0(R1)\n         LA    R9,0(R9)\n         SPACE 1\nGCNONE   SR    R10,R10\n         L     R1,INUPTR\n         LTR   R1,R1\n         BZ    GCNOINU\n         L     R0,INULEN\n        FREEMAIN R,A=(1),LV=(0)\n         XC    INUPTR,INUPTR\nGCNOINU  LA    R4,SYSUADS\n         USING IHADCB,R4\n         TM    DCBOFLGS,DCBOFOPN   ALREADY CLOSED?\n         BZ    GCEXIT              YES.\n         DROP  R4\n        CLOSE  (SYSUADS)\nGCEXIT   LTR   R9,R9\n         BZ    *+L'*+4\n         ST    R10,0(R9)           STORE IND.\n        $XRET  CC=(R10)\n         SPACE 1\nERCL    WTO    'GUACL/ERR=1 - CALLING SEQUENCE OR ARGUMENT ERROR.',    1\n               ROUTCDE=11,DESC=7\n         LA    R10,1\n         B     GCNONE+L'GCNONE\n         SPACE 1\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nATIOT    DC    A(*-*)\nINUPTR   DC    F'0'\nINUBUF   DC    F'0'\nINUSIZ   DC    F'0'\nINULEN   DC    F'0'\nMXMEMB   DC    0H'0',AL2(MXMU,12)  N ENTRIES, EACH 12 BYTES.\n         SPACE 1\n        PRINT  NOGEN\nSYSUADS DCB    DDNAME=SYSUADS,DSORG=PO,MACRF=R,                        1\n               EODAD=ERR4,SYNAD=UADERR\n        PRINT  GEN\n        READ   UADDECB,SF,0,0,'S',MF=L\nTABD     DC    A(DIAG1,DIAG2,DIAG3,DIAG4,DIAG5,DIAG6)\n        PRINT  NOGEN\nDIAG1   WTO    'GUAR/ERR=1 - SYSUADS DD-CARD MISSING.',                1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG2   WTO    'GUAR/ERR=2 - SYSUADS OPEN ERROR.',                     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG3   WTO    'GUAR/ERR=3 - SYSUADS BLDL ERROR.',                     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG4   WTO    'GUAR/ERR=4 - SYSUADS UNEXPECTED EOF.',                 1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG5   WTO    'GUAR/ERR=5 - SYSUADS READ ERROR.',                     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG6   WTO    'GUAR/ERR=6 - CALLING SEQUENCE OR ARGUMENT ERROR.',     1\n               ROUTCDE=11,DESC=7,MF=L\n        PRINT  GEN\n         SPACE 2\n        LTORG\n         SPACE 1\n        PRINT  NOGEN\n        DCBD   DSORG=PO,DEVD=DA\nTIODSECT DSECT\n        IEFTIOT1\n        IKJEFUAD DSPL,ALL\n        PRINT  GEN\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUAR$": {"ttr": 18704, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x08O\\x00\\x87\\x08O\\x16$\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-03-25T00:00:00", "modifydate": "1987-03-25T16:24:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//GUAR     JOB (........),'INSTALL  - GUAR -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,OPT=',ALIGN',MBR=GUAR\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   GUACL\n  NAME    GUAR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GUAR@": {"ttr": 18945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14R\\x00Q\\x00Q\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:52:00", "lines": 81, "newlines": 81, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/03/87\n                                                      GUAR      1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       GET USERID ACCOUNT FROM       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      SYS1.UADS (TSO) - ROUTINE      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL GUAR,(A,B,C),VL\n  ------------------ CALL GUAR,(A,B),VL\n\n         Where : A - is the address of the desired USERID (format CL7).\n                     This argument is mandatory, and must be right\n                     padded with blanks.\n\n                 B - is the address of an array into which the account\n                     filed(s) for the requested USERID are stored. The\n                     format is as follows :\n                             DC  AL2(no. of account fields or zero)\n                             DC  AL1(L'ACC1)\n                       ACC1  DC  C'account field'\n                             ...\n                             DC  AL1(L'ACCN)\n                       ACCN  DC  C'account field'\n                     The array must be large enough to receives the\n                     maximum number of account fields for a USERID,\n                     unless unpredictable results may occur.\n                     This argument is mandatory.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                     -1 - USERID not found.\n                      0 - request correctly exhausted.\n                      1 - SYSUADS DD-card missing.\n                      2 - SYSUADS OPEN error.\n                      3 - SYSUADS BLDL error.\n                      4 - SYSUADS unexpected EOF.\n                      5 - SYSUADS READ error.\n                      6 - calling sequence or argument error.\n\n  Assembler macro : $GUAR A,B,C\n  -----------------\n\n         Where C is optional and may be omitted.\n         Register use may be coded within parentheses.\n1   30/07/86\n                                                      GUAR      2/2.\n\n  Calling sequence : CALL GUACL,(A),VL\n  ------------------ CALL GUACL ---> with R1=0\n\n         Where : A - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence or argument error.\n\n  Assembler macro : $GUACL A\n  -----------------\n\n         Where A is optional and may be omitted.\n         Register use may be coded within parentheses.\n\n\n  NOTES : 1. On any error detection, a message is included in the\n  =======    message class for the job.\n          2. When running, this routine needs a JCL DD-card as below :\n               //SYSUADS DD DSN=SYS1.UADS,DISP=SHR\n          3. At the first call of GUAR, the UADS data-set is opened,\n             then, as for successive calls, the records pertaining\n             to the desired USERID are read. At execution end, call\n             GUACL to close the UADS data-set.\n             It is suggested to fill dynamically an internal table\n             with the received information in order to minimize the\n             number of I/O operations.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ICFS": {"ttr": 18948, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x0f\\x00\\x882\\x0f\\x17\\x12\\x04 \\x04 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-15T00:00:00", "modifydate": "1988-11-15T17:12:00", "lines": 1056, "newlines": 1056, "modlines": 0, "user": "SYSPAJA"}, "text": "ICFS     TITLE 'ICF CATALOG SEQUENTIAL READ SUBROUTINE.'\nICFSR    START 0\n         SPACE 2\n* PURPOSE :    ROUTINE TO READ SEQUENTIALLY AN ENTIRE ICF CATALOG.\n* ---------    A DD-CARD, WRITTEN AS BELOW, IS NEEDED TO DEFINE\n*              THE DESIRED CATALOG :\n*\n*              //...     DD  DSN=...CATALOG DS-NAME...,DISP=SHR\n*\n* CALLING SEQUENCE : CALL ICFSO,(A,B,C,D),VL\n* ------------------            (A,B,C)\n*                               (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8).\n*\n*                B - IS THE ADDRESS OF THE DEVICE CHARACTERISTICS\n*                    (FORMAT FULLWORD - F BOUNDARY) RETURNED BY THE\n*                    ROUTINE IF SUPPLIED (OPTIONAL). IT WILL RECEIVE\n*                    FIVE FULLWORDS INFORMATION AS DESCRIBED IN DEVTYPE\n*                    MACRO (SEE MVS/EXTENDED ARCHITECTURE : SYSTEM-DATA\n*                    ADMINISTRATION), FOLLOWED BY ONE HALFWORD\n*                    CONTAINING THE NUMBER OF ALTERNATE TRACKS FOR\n*                    THE DEVICE, FOLLOWED BY A 6 CHARACTERS FIELD\n*                    CONTAINING THE VOLUME SERIAL NUMBER OF THE\n*                    DEVICE, FOLLOWED BY A 44 CHARACTERS FIELD\n*                    CONTAINING THE CATALOG DATA-SET NAME. THIS\n*                    ARGUMENT IS OPTIONAL AND MAY BE OMITTED OR HIS\n*                    ADDRESS MAY BE SET TO ZERO IN THE PARAMETERS LIST.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - OPEN CORRECTLY EXECUTED.\n*                     1 - FILE ALREADY OPENED.\n*                     2 - OPEN ERROR : R0 = VSAM OPEN ERROR CODE,\n*                                      R1 = OPEN RETURN CODE (R15).\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - NOT OS/VS2 SYSTEM.\n*                     5 - DD-CARD MISSING.\n*                     6 - NOT DIRECT-ACCESS STORAGE DEVICE.\n*                     7 - READ JFCB ERROR.\n*                     8 - DD-CARD INCORRECTLY CODED.\n*                     9 - NOT ICF CATALOG.\n*                         CLOSE CATALOG IS OK (R0 AND R1 = 0) OR IF\n*                         CLOSE ERROR : R0 = VSAM CLOSE ERROR CODE,\n*                                       R1 = CLOSE RETURN CODE (R15).\n*                    10 - CATALOG DSCB FORMAT-1 CONTROL ERROR.\n*\n*                D - IS THE ADDRESS OF A ONE BYTE FLAGS TO INDICATE\n*                    CALLER STATUS AND SPECIAL REQUEST (SEE MACRO\n*                    $ICFSW FOR MORE DETAIL).\n         EJECT\n* CALLING SEQUENCE : CALL ICFSR,(A,B,C,D),VL\n* ------------------            (A,B,C)\n*                               (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF A FIELD (FORMAT XL1,CL44) WHICH\n*                    RECEIVES, AFTER EACH READ OPERATION, UNLESS WHEN\n*                    THE END-OF-FILE IS DETECTED, ONE OF THE FOLLOWING\n*                    INFORMATION :\n*                     - A NON-VSAM DATA-SET NAME (FORMAT AL1(1),CL44).\n*                     - A GDG DATA-SET NAME (FORMAT AL1(2),CL44).\n*                     - A CLUSTER NAME (FORMAT AL1(3),CL44).\n*                     - AN ALTERNATE INDEX NAME (FORMAT AL1(4),CL44).\n*                     - A DATA (CLUSTER) NAME (FORMAT AL1(5),CL44).\n*                     - AN INDEX (CLUSTER) NAME (FORMAT AL1(6),CL44).\n*                     - A PATH NAME (FORMAT AL1(7),CL44).\n*                     - AN ALIAS NAME (FORMAT AL1(8),CL44).\n*                     - AN AIX TRUE-NAME NAME (FORMAT AL1(9),CL44).\n*                     - A DATA TRUE-NAME NAME (FORMAT AL1(10),CL44).\n*                     - AN INDEX TRUE-NAME NAME (FORMAT AL1(11),CL44).\n*                     - AN ICF CONNECTOR NAME (FORMAT AL1(12),CL44).\n*                     - A VSAM CONNECTOR NAME (FORMAT AL1(13),CL44).\n*                     - AN INFORMATION CONTINUATION OF A PREVIOUS NAME\n*                       (FORMAT AL1(255),CL44).\n*\n*                B - IS THE ADDRESS OF A FIELD (FORMAT CL6,XL2) WHICH\n*                    RECEIVES THE VOLUME SERIAL NUMBER RELATIVE\n*                    TO THE FIRST ARGUMENT IF PERTINENT (OTHERWISE\n*                    IT IS CLEARED TO BLANKS), FOLLOWED BY THE FILE\n*                    SEQUENCE NUMBER (ONLY USED FOR NON-VSAM TAPE, IT\n*                    IS CLEARED TO BINARY ZEROS). THIS ARGUMENT IS\n*                    OPTIONAL AND MAY BE OMITTED OR HIS ADDRESS MAY\n*                    BE SET TO ZERO IN THE PARAMETERS LIST.\n*\n*                C - IS THE ADDRESS OF A FIELD (FORMAT XL4) WHICH\n*                    RECEIVES THE DEVICE TYPE RELATIVE TO THE SECOND\n*                    ARGUMENT IF PERTINENT, OTHERWISE IT IS CLEARED\n*                    TO BLANKS. THIS ARGUMENT IS OPTIONAL AND MAY BE\n*                    OMITTED OR HIS ADDRESS MAY BE SET TO ZERO IN THE\n*                    PARAMETERS LIST.\n         EJECT\n*                D - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                    -1 - END-OF-FILE DETECTED.\n*                         CLOSE CATALOG IS OK (R0 AND R1 = 0) OR IF\n*                         CLOSE ERROR : R0 = VSAM CLOSE ERROR CODE,\n*                                       R1 = CLOSE RETURN CODE (R15).\n*                     0 - READ OPERATION CORRECTLY EXECUTED.\n*                     1 - READ ERROR : R0 = VSAM FDBK ERROR CODE,\n*                                      R1 = GET RETURN CODE (R15).\n*                     2 - FILE NOT OPENED.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - UNEXPECTED CATALOG RECORD STRUCTURE.\n*\n*        NOTE : ON ALL ERROR RETURN, THE CATALOG FILE STATUS REMAINS\n*               UNCHANGED (OPENED OR CLOSED).\n         EJECT\n* CALLING SEQUENCE : CALL ICFSC,(A,B),VL\n* ------------------            (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE CATALOG CONTROL INFORMATION\n*                    (FORMAT FULLWORDS - F BOUNDARIES) RETURNED BY THE\n*                    ROUTINE IF SUPPLIED (OPTIONAL : ARGUMENT MAY BE\n*                    OMITTED PASSING A ZERO PARAMETERS LIST POINTER,\n*                    REGISTER 1, WHEN THE NEXT IS ALSO OMITTED, OR HIS\n*                    ADDRESS MAY BE ZERO IN THE PARAMETERS LIST).\n*                    IT WILL RECEIVE TWELVE FULLWORDS INFORMATION AS\n*                    DESCRIBED BELOW :\n*                     - THE TOTAL NUMBER OF GETS ISSUED AGAINST THE\n*                       BASIC CATALOG STRUCTURE.\n*                     - THE NUMBER OF NONVSAM ENTRIES FOUND.\n*                     - THE NUMBER OF CLUSTER ENTRIES FOUND.\n*                     - THE NUMBER OF ALTERNATE INDEX ENTRIES FOUND.\n*                     - THE NUMBER OF DATA (CLUSTER) ENTRIES FOUND.\n*                     - THE NUMBER OF INDEX (CLUSTER) ENTRIES FOUND.\n*                     - THE NUMBER OF GDG BASE ENTRIES FOUND.\n*                     - THE NUMBER OF GDG ENTRIES FOUND.\n*                     - THE NUMBER OF PATH ENTRIES FOUND.\n*                     - THE NUMBER OF ALIAS ENTRIES FOUND.\n*                     - THE NUMBER OF TRUE-NAME ENTRIES FOUND.\n*                     - THE NUMBER OF ICF CONNECTOR ENTRIES FOUND.\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     2 - CLOSE ERROR : R0 = VSAM CLOSE ERROR CODE,\n*                                       R1 = CLOSE RETURN CODE (R15).\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n         SPACE 1\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               SET SWITCH NOP OPERATION\nON       EQU   X'F0'               SET SWITCH BRANCH OPERATION\nBSL      EQU   12                  BUFFER SPACE LENGTH (IN K-BYTES)\n         SPACE 2\n        PRINT  NOGEN\n         SPACE 1\n        CVT    DSECT=YES,LIST=YES\n        IHAPSA\n        IKJTCB\n        IEZJSCB\nTIODSECT DSECT\n        IEFTIOT1\nJFCDSECT DSECT\n        IEFJFCBN LIST=YES\n        DCBD   DSORG=PS,DEVD=DA\nDSCDSECT DSECT\n        IECSDSL1 (1)\n        IFGACB\n         SPACE 1\n        PRINT  GEN\n         SPACE 2\nICFSR    CSECT                     RESTORE ORIGINAL CSECT\n         EJECT\n        $ICFCD\n         EJECT\n         ENTRY ICFSO\n         ENTRY ICFSC\n         SPACE 1\n         USING *,R15\n         MVI   WTGO+3,ICFS-*       SET ENTRY DISPLACEMENT (READ)\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nICFSO    MVI   WTGO+3,ICFS-*       SET ENTRY DISPLACEMENT (OPEN)\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nICFSC    MVI   WTGO+3,ICFS-*       SET ENTRY DISPLACEMENT (CLOSE)\n         DROP  R15\n         SPACE 1\nWTGO     LA    R15,*-*(R15)        SET COMMON ENTRY ADDRESS\n         SPACE 1\nICFS    $XENT BASE=(R11,R12)\n         LR    R15,R11             COMPUTE WHERE TO GO?\n         BCTR  R15,0\n         XR    R14,R14\n         IC    R14,0(R15)\n         SRL   R14,1\n         B     *+L'*-(ICFS-WTGO)+0(R14) ENTER SELECTED ROUTINE\n         SPACE 1\n         B     CTCLOSE             BRANCH ENTRIES VECTOR\n         B     CTOPEN\n         EJECT\n         XR    R9,R9\n         XR    R6,R6\n         XR    R7,R7\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS\n         BO    RD3\n         TM    4(R1),X'80'\n         BO    RD2\n         TM    8(R1),X'80'\n         BO    RD1\n         TM    12(R1),X'80'\n         BZ    ERR3\n         TM    15(R1),X'03'\n         BNZ   ERR3\n         L     R9,12(R1)\n         LA    R9,0(R9)\nRD1      L     R6,8(R1)\n         LA    R6,0(R6)\n         LTR   R6,R6\n         BZ    RD2\n         XC    0(4,R6),0(R6)\nRD2      L     R7,4(R1)\n         LA    R7,0(R7)\n         LTR   R7,R7\n         BZ    RD3\n         MVC   0(6,R7),=CL8' '\n         XC    6(2,R7),6(R7)\nRD3      L     R8,0(R1)\n         LA    R8,0(R8)\n         LTR   R8,R8\n         BZ    ERR3\n         MVI   0(R8),0\n         MVI   1(R8),C' '\n         MVC   2(L'DSNAME-1,R8),1(R8)\n         LA    R1,DCBSR\n         USING IHADCB,R1\n         TM    DCBOFLGS,DCBOFOPN   TEST IF OPENED?\n         BZ    ERR2                BRANCH IF NOT\n         DROP  R1\n         L     R2,CURREC           GET CURRENT RECORD POINTER\n         CL    R2,ENDREC           NEW RECORD MUST READ?\n         BL    XCONT               NO, CONTINUE PROCESS OF CURRENT\nGETNEXT  L     R2,RPLSR            PICK UP RPL ADDRESS\n        GET    RPL=(R2)            READ A CATALOG (BCS) RECORD\n         L     R0,NGETS            UPDATE GETS COUNT\n         AH    R0,=H'1'\n         ST    R0,NGETS\n         LTR   R15,R15\n         BZ    GETOK\n         L     R3,4(R13)\n         ST    R15,24(R3)          SET GET RC IN R1\n        SHOWCB RPL=(R2),AREA=WORK,LENGTH=4,FIELDS=(FDBK)\n         MVC   20(4,R3),WORK       SET ERROR CODE IN R0\n         B     ERR1\nGETOK    L     R2,BUFPTR           GET RECORD ADDRESS\n         LR    R1,R2               COMPUTE END OF RECORD + 1 ADDRESS\n         AH    R1,0(R2)\n         ST    R1,ENDREC\n         LA    R2,2(R2)            SKIP OVER RECORD LENGTH (LL)\n         USING ICFDSECT,R2\n         LA    R1,TBTYPES\nNXTTY    CLC   0(1,R1),ICFRTY      CURRENT RECORD TYPE?\n         BE    SELTY               YES\n         LA    R1,L'TBTYPES(R1)    NO, POINT TO NEXT\n         CLI   0(R1),0             END OF TABLE?\n         BNE   NXTTY               NO\n         B     ERR4                YES, SIGNAL IT, GO BACK FOR ANOTHER\nSELTY    ICM   R15,B'1111',1(R1)   GET PROCESSING ADDRESS\n         BR    R15                 GO PROCESS IT\nXPASS    ST    R14,SVBACK          SAVE BACK FOR FURTHER PROCESS\n         STM   R3,R5,SVREGS\n         ST    R2,CURREC           SAVE CURRENT RECORD POINTER\n         XR    R10,R10\n         B     EXIT\nXCONT    L     R14,SVBACK          GET CONTINUE PROCESS ADDRESS\n         LM    R3,R5,SVREGS\n         BR    R14\nXRET     XR    R10,R10\n         ST    R10,ENDREC\n         B     EXIT\n         SPACE 2\n*        NON-VSAM RECORD\n         SPACE 1\nNONVSAM  L     R0,NNVSM            UPDATE NONVSAM ENTRIES COUNT\n         AH    R0,=H'1'\n         ST    R0,NNVSM\n         MVI   0(R8),1             SAY NON-VSAM\n         MVC   1(L'NVNAME,R8),NVNAME    SET DATA-SET NAME\n         LTR   R7,R7\n         BZ    XRET\n         XR    R3,R3\n         ICM   R3,B'0011',NVOLCNT  GET # OF VOLUME CELLS\n         BZ    ERR4                NONE\n         LA    R1,X'04'            ASK FOR VOLUME CELL\n         BAS   R14,NXCELLS         GO TO SEARCH CELL\n         BNZ   ERR4                NOT FOUND\nNVS1     MVC   0(L'VOLSERN,R7),VOLSERN  PROCESS VOLUME CELL\n         MVC   6(L'VOLFLSEQ,R7),VOLFLSEQ\n         LTR   R6,R6\n         BZ    *+L'*+6\n         MVC   0(L'VOLDEVTP,R6),VOLDEVTP\n         BCT   R3,*+L'*+4          LOOP TILL ALL VOLUMES DONE\n         B     XRET\n         BAS   R14,XPASS\n         BAS   R14,NXCELL          GO TO NEXT CELL\n         BNZ   ERR4                NOT FOUND\n         CLI   VOLTYPE,X'04'       VOLUME CELL?\n         BNE   ERR4                NO\n         MVI   0(R8),255           YES, SAY CONTINUATION\n         B     NVS1\n         SPACE 2\n*        GDG RECORD\n         SPACE 1\nGDGDS    L     R0,NGDGB            UPDATE GDG BASE ENTRIES COUNT\n         AH    R0,=H'1'\n         ST    R0,NGDGB\n         MVC   DSNAME,GDGNAME      GET DATA-SET NAME\n         LA    R4,DSNAME           POINT TO BEGINNING OF DSNAME\nGDG1     CLI   0(R4),C' '          LOOK FOR FIRST BLANK\n         BE    *+L'*+8             WHEN FOUND, STOP\n         LA    R4,1(R4)            GO TO NEXT CHARACTER\n         B     GDG1\n         LA    R1,X'05'            ASK FOR GAT CELL (GEN. AGING TABLE)\n         BAS   R14,NXCELLS         GO TO SEARCH CELL\n         BNZ   ERR4                NOT FOUND\n         XR    R5,R5\n         ICM   R5,B'0001',GATCNT\n         BNZ   GDG2                GO PROCESS\n         MVI   0(R8),2             SAY GDG\n         MVC   1(L'DSNAME,R8),DSNAME    SET BASE DATA-SET NAME\n         B     XRET\nGDG2     MVC   0(2,R4),=C'.G'      GET READY TO ADD GEN# & VER#\nGDG3     LA    R1,C'H'             ASK FOR GEN. D.S. NAME CELL\n         BAS   R14,NXCELLS         GO TO SEARCH CELL\n         BNZ   ERR4                NOT FOUND\n         L     R0,NGDGE            UPDATE GDG ENTRIES COUNT\n         AH    R0,=H'1'\n         ST    R0,NGDGE\n         XR    R0,R0\n         ICM   R0,B'0011',GDSGENO  GET GENERATION NUMBER\n         CVD   R0,WORKD            CONVERT\n         UNPK  WORKC,WORKD         UNPACK\n         MVZ   WORKC+7(1),WORKC+6  MOVE ZONE BYTE\n         MVC   2(4,R4),WORKC+4     MOVE INTO DATA-SET NAME\n         MVI   6(R4),C'V'          GET READY TO ADD VER#\n         XR    R0,R0\n         ICM   R0,B'0001',GDSVERNO GET VERSION NUMBER\n         CVD   R0,WORKD            CONVERT\n         UNPK  WORKC,WORKD         UNPACK\n         MVZ   WORKC+7(1),WORKC+6  MOVE ZONE BYTE\n         MVC   7(2,R4),WORKC+6     MOVE INTO DATA-SET NAME\n         XR    R3,R3\n         ICM   R3,B'0011',GDSVOLCT SAVE # OF VOLUME CELLS\n         MVI   0(R8),2             SAY GDG\n         MVC   1(L'DSNAME,R8),DSNAME    SET DATA-SET NAME\n         LTR   R7,R7\n         BZ    XRET\n         LA    R1,X'04'            ASK FOR VOLUME CELL\n         BAS   R14,NXCELLS         GO TO SEARCH CELL\n         BNZ   ERR4                NOT FOUND\nGDG4     MVC   0(L'VOLSERN,R7),VOLSERN  PROCESS VOLUME CELL\n         MVC   6(L'VOLFLSEQ,R7),VOLFLSEQ\n         LTR   R6,R6\n         BZ    *+L'*+6\n         MVC   0(L'VOLDEVTP,R6),VOLDEVTP\n         BCT   R3,GDG5             LOOP TILL ALL VOLUMES DONE\n         BCT   R5,*+L'*+4          LOOP TILL ALL GDG'S DONE\n         B     XRET\n         BAS   R14,XPASS\n         B     GDG3\nGDG5     BAS   R14,XPASS\n         BAS   R14,NXCELL          GO TO NEXT CELL\n         BNZ   ERR4                NOT FOUND\n         CLI   VOLTYPE,X'04'       VOLUME CELL?\n         BNE   ERR4                NO\n         MVI   0(R8),255           YES, SAY CONTINUATION\n         B     GDG4\n         SPACE 2\n*        CLUSTER RECORD\n         SPACE 1\nCLUSTER  L     R0,NCLTR            UPDATE CLUSTER ENTRIES COUNT\n         AH    R0,=H'1'\n         ST    R0,NCLTR\n         MVI   0(R8),3             SAY VSAM CLUSTER\n         NI    SWCLS+1,OFF\n         CLI   CLNAME,0            IS IT THE CATALOG ITSELF?\n         BE    CLS2                YES\n         XR    R1,R1\n         IC    R1,CLNMLEN\n         BCTR  R1,0\n         BCTR  R1,0\n         EX    R1,CLSMN            SET CLUSTER NAME\nCLS2     BAS   R14,NXCELL          GET NEXT CELL\n         BNZ   ERR4                NOT FOUND\n         CLI   SECTYPE,X'02'       SECURITY CELL?\n         BNE   CLS3                NO\n         TM    SWPRI,ICFMSPW       MASTER PASSWORD REQUESTED?\n         BZ    CLS2                NO\n         ICM   R1,B'1111',AMSPW    YES, SET MASTER PASSWORD\n         MVC   1(L'SECMSTR,R1),SECMSTR\n         B     CLS2\nCLS3     CLI   RELTYPE,X'06'       AIX ASSOCIATED CELL?\n         BNE   CLS4                NO\n         XR    R3,R3\n         IC    R3,RELCNT           GET COUNT\n         B     CLS2\nCLS4     CLI   DIDTYPE,C'D'        DATA NAME CELL?\n         BNE   CLS2                NO\n         BAS   R14,XPASS\n         B     CLS11\nCLS10    BAS   R14,XPASS\n         LA    R1,C'D'             ASK FOR DATA NAME CELL\n         BAS   R14,NXCELLS         GO TO SEARCH CELL\n         BNZ   ERR4                NOT FOUND\nCLS11    L     R0,NDTCL            UPDATE DATA ENTRIES COUNT\n         AH    R0,=H'1'\n         ST    R0,NDTCL\n         MVI   0(R8),5             SAY DATA OF CLUSTER\n         XR    R1,R1\n         IC    R1,DIDKEYLN         LENGTH OF NAME\n         BCTR  R1,0\n         BCTR  R1,0\n         EX    R1,CLSMK            SET DATA NAME\n         LTR   R7,R7\n         BNZ   CLS13\n         BAS   R14,XPASS\nCLS12    BAS   R14,NXCELL          GO TO NEXT CELL\n         BNZ   GETNEXT             BRANCH IF END\n         CLI   DIDTYPE,C'I'        INDEX NAME CELL?\n         BE    CLS15               BRANCH IF YES\n         TM    SWCLS+1,ON\n         BO    CLS12\n         CLI   AIXTYPE,C'G'        ALT. INDEX NAME CELL?\n         BE    CLS18               BRANCH IF YES\n         B     CLS12\nCLS13    LA    R1,X'04'            ASK FOR VOLUME CELL\n         BAS   R14,NXCELLS         GO TO SEARCH CELL\n         BNZ   ERR4                NOT FOUND\nCLS14    MVC   0(L'VOLSERN,R7),VOLSERN  PROCESS VOLUME CELL\n         MVC   6(L'VOLFLSEQ,R7),VOLFLSEQ\n         LTR   R6,R6\n         BZ    *+L'*+6\n         MVC   0(L'VOLDEVTP,R6),VOLDEVTP\n         BAS   R14,XPASS\n         BAS   R14,NXCELL          GO TO NEXT CELL\n         BNZ   GETNEXT             BRANCH IF END\n         CLI   VOLTYPE,X'04'       VOLUME CELL?\n         BNE   *+L'*+8             BRANCH IF NOT\n         MVI   0(R8),255           YES, SAY CONTINUATION\n         B     CLS14\n         CLI   DIDTYPE,C'I'        INDEX NAME CELL?\n         BNE   SWCLS               BRANCH IF NOT\nCLS15    L     R0,NIXCL            UPDATE INDEX ENTRIES COUNT\n         AH    R0,=H'1'\n         ST    R0,NIXCL\n         MVI   0(R8),6             SAY INDEX OF CLUSTER\n         XR    R1,R1\n         IC    R1,DIDKEYLN         LENGTH OF NAME\n         BCTR  R1,0\n         BCTR  R1,0\n         EX    R1,CLSMK            SET INDEX NAME\n         LTR   R7,R7\n         BNZ   CLS16\n         BAS   R14,XPASS\n         TM    SWCLS+1,ON\n         BO    GETNEXT\n         BAS   R14,NXCELL          GO TO NEXT CELL\n         BNZ   GETNEXT             BRANCH IF END\n         CLI   AIXTYPE,C'G'        ALT. INDEX NAME CELL?\n         BNE   *-12                BRANCH IF NOT\n         B     CLS18\nCLS16    LA    R1,X'04'            ASK FOR VOLUME CELL\n         BAS   R14,NXCELLS         GO TO SEARCH CELL\n         BNZ   ERR4                NOT FOUND\nCLS17    MVC   0(L'VOLSERN,R7),VOLSERN  PROCESS VOLUME CELL\n         MVC   6(L'VOLFLSEQ,R7),VOLFLSEQ\n         LTR   R6,R6\n         BZ    *+L'*+6\n         MVC   0(L'VOLDEVTP,R6),VOLDEVTP\n         BAS   R14,XPASS\n         BAS   R14,NXCELL          GO TO NEXT CELL\n         BNZ   GETNEXT             BRANCH IF END\n         CLI   VOLTYPE,X'04'       VOLUME CELL?\n         BNE   SWCLS               BRANCH IF NOT\n         MVI   0(R8),255           YES, SAY CONTINUATION\n         B     CLS17\nSWCLS    NOP   ERR4\n         CLI   AIXTYPE,C'G'        ALT. INDEX NAME CELL?\n         BNE   ERR4                BRANCH IF NOT\nCLS18    L     R0,NAIXE            UPDATE ALT. INDEX ENTRIES COUNT\n         AH    R0,=H'1'\n         ST    R0,NAIXE\n         MVI   0(R8),4             SAY ALTERNATE INDEX\n         BCT   R3,*+L'*+4\n         OI    SWCLS+1,ON\n         XR    R1,R1\n         IC    R1,AIXKYLEN         LENGTH OF AIX NAME\n         EX    R1,CLSAX            SET AIX NAME\n         B     CLS10\nCLSMN    MVC   1(*-*,R8),CLNAME\nCLSMK    MVC   1(*-*,R8),DIDKEY\nCLSAX    MVC   1(*-*,R8),AIXKEY\n         SPACE 2\n*        PATH RECORD\n         SPACE 1\nPATH     L     R0,NPATH            UPDATE PATH ENTRIES COUNT\n         AH    R0,=H'1'\n         ST    R0,NPATH\n         MVI   0(R8),7             SAY PATH\n         XR    R1,R1\n         IC    R1,PATHKYLN         LENGTH OF PATH NAME\n         EX    R1,PTHMV            SET PATH NAME\n         LA    R1,X'03'            ASK FOR ASSOCIATION CELL\n         BAS   R14,NXCELLS         GO TO SEARCH CELL\n         BNZ   XRET                NOT FOUND\n         XR    R3,R3\n         ICM   R3,B'0011',ASCOUNT  COUNT OF ASSOCIATIONS\n         BZ    XRET                NONE\n         LA    R2,L'ASSOCC(R2)     POSITION TO REPEAT FIELDS\n         B     PTH1+L'PTH1\nPTH1     LA    R2,ASCKEY(R5)       POINT TO NEXT FIELD\n         BAS   R14,XPASS\n         MVI   0(R8),255           SAY CONTINUATION\n         XR    R1,R1\n         IC    R1,ASCKYLEN         LENGTH OF ASS. NAME\n         LR    R5,R1\n         BCTR  R1,0\n         BCTR  R1,0\n         EX    R1,PTHMK            SET ASS. NAME\n         BCT   R3,PTH1             LOOP TILL ALL ASS. DONE\n         B     XRET\nPTHMV    MVC   1(*-*,R8),PATHNAME\nPTHMK    MVC   1(*-*,R8),ASCKEY\n         SPACE 2\n*        ALIAS RECORD\n         SPACE 1\nALIAS    L     R0,NALSE            UPDATE ALIAS ENTRIES COUNT\n         AH    R0,=H'1'\n         ST    R0,NALSE\n         MVI   0(R8),8             SAY ALIAS\n         XR    R1,R1\n         IC    R1,ALIKYLEN         LENGTH OF ALIAS NAME\n         BCTR  R1,0\n         BCTR  R1,0\n         EX    R1,ALSMV            SET ALIAS NAME\n         LA    R1,X'03'            ASK FOR ASSOCIATION CELL\n         BAS   R14,NXCELLS         GO TO SEARCH CELL\n         BNZ   XRET                NOT FOUND\n         XR    R3,R3\n         ICM   R3,B'0011',ASCOUNT  COUNT OF ASSOCIATIONS\n         BZ    XRET                NONE\n         LA    R2,L'ASSOCC(R2)     POSITION TO REPEAT FIELDS\n         B     ALS1+L'ALS1\nALS1     LA    R2,ASCKEY(R5)       POINT TO NEXT FIELD\n         BAS   R14,XPASS\n         MVI   0(R8),255           SAY CONTINUATION\n         XR    R1,R1\n         IC    R1,ASCKYLEN         LENGTH OF ASS. NAME\n         LR    R5,R1\n         BCTR  R1,0\n         BCTR  R1,0\n         EX    R1,ALSMK            SET ASS. NAME\n         BCT   R3,ALS1             LOOP TILL ALL ASS. DONE\n         B     XRET\nALSMV    MVC   1(*-*,R8),ALINAME\nALSMK    MVC   1(*-*,R8),ASCKEY\n         SPACE 2\n*        TRUE-NAME RECORD\n         SPACE 1\nTRUE     L     R0,NTRUE            UPDATE TRUE-NAME ENTRIES COUNT\n         AH    R0,=H'1'\n         ST    R0,NTRUE\n         CLI   TRUNTYPE,C'G'\n         BNE   *+L'*+8\n         MVI   0(R8),9             SAY AIX TRUE-NAME\n         B     TRN1\n         CLI   TRUNTYPE,C'D'\n         BNE   *+L'*+8\n         MVI   0(R8),10            SAY DATA TRUE-NAME\n         B     TRN1\n         CLI   TRUNTYPE,C'I'\n         BNE   ERR4\n         MVI   0(R8),11            SAY INDEX TRUE-NAME\nTRN1     XR    R1,R1\n         IC    R1,TRUEKEYL         LENGTH OF TRUE-NAME\n         BCTR  R1,0\n         BCTR  R1,0\n         EX    R1,TRUMV            SET TRUE-NAME\n         LA    R1,X'03'            ASK FOR ASSOCIATION CELL\n         BAS   R14,NXCELLS         GO TO SEARCH CELL\n         BNZ   XRET                NOT FOUND\n         XR    R3,R3\n         ICM   R3,B'0011',ASCOUNT  COUNT OF ASSOCIATIONS\n         BZ    XRET                NONE\n         LA    R2,L'ASSOCC(R2)     POSITION TO REPEAT FIELDS\n         B     TRN2+L'TRN2\nTRN2     LA    R2,ASCKEY(R5)       POINT TO NEXT FIELD\n         BAS   R14,XPASS\n         MVI   0(R8),255           SAY CONTINUATION\n         XR    R1,R1\n         IC    R1,ASCKYLEN         LENGTH OF ASS. NAME\n         LR    R5,R1\n         BCTR  R1,0\n         BCTR  R1,0\n         EX    R1,TRUMK            SET ASS. NAME\n         BCT   R3,TRN2             LOOP TILL ALL ASS. DONE\n         B     XRET\nTRUMV    MVC   1(*-*,R8),TRUENAME\nTRUMK    MVC   1(*-*,R8),ASCKEY\n         SPACE 2\n*        ICF CONNECTOR RECORD\n         SPACE 1\nCONNECT  L     R0,NICFC            UPDATE ICF CONNETOR ENTRIES COUNT\n         AH    R0,=H'1'\n         ST    R0,NICFC\n         TM    COFLAG,COCATYPE     WHICH KIND OF CONNECTOR?\n         BO    *+L'*+8\n         MVI   0(R8),13            SAY VSAM CONNECTOR\n         B     *+L'*+4\n         MVI   0(R8),12            SAY ICF CONNECTOR\n         XR    R1,R1\n         IC    R1,COKEYLN          LENGTH OF CATALOG NAME\n         BCTR  R1,0\n         BCTR  R1,0\n         EX    R1,CONMV            SET CATALOG NAME\n         LTR   R7,R7\n         BZ    XRET\n         LA    R1,X'04'            ASK FOR VOLUME CELL\n         BAS   R14,NXCELLS         GO TO SEARCH CELL\n         BNZ   ERR4                NOT FOUND\nICN1     MVC   0(L'VOLSERN,R7),VOLSERN  PROCESS VOLUME CELL\n         MVC   6(L'VOLFLSEQ,R7),VOLFLSEQ\n         LTR   R6,R6\n         BZ    *+L'*+6\n         MVC   0(L'VOLDEVTP,R6),VOLDEVTP\n         BAS   R14,XPASS\n         BAS   R14,NXCELL          GO TO NEXT CELL\n         BNZ   GETNEXT             BRANCH IF END\n         CLI   VOLTYPE,X'04'       VOLUME CELL?\n         BNE   ERR4                BRANCH IF NOT\n         MVI   0(R8),255           YES, SAY CONTINUATION\n         B     ICN1\nCONMV    MVC   1(*-*,R8),CONAME\n         DROP  R2\n         SPACE 1\nENDSR    LA    R1,DCBSR\n         USING IHADCB,R1\n         NI    DCBOFLGS,255-DCBOFOPN    SET CLOSED\n         DROP  R1\n         BAS   R14,XCLOSE\n         L     R2,4(R13)\n         XC    20(4,R2),20(R2)     SET R0 = 0\n         ST    R15,24(R2)          SET CLOSE RC IN R1\n         LTR   R15,R15             CLOSE OK?\n         BZ    *+L'*+10            YES\n         BAS   R14,XSHOW           GET VSAM ACB ERROR CODE\n         MVC   20(4,R2),WORK       SET ERROR CODE IN R0\n         XR    R10,R10\n         ST    R10,ENDREC\n         BCT   R10,EXIT\n         SPACE 2\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nERR4     BCTR  R10,0\nMAXERR   EQU   ((*-ERR1)/2)+1\n         XR    R0,R0\n         ST    R0,ENDREC\n         B     EXIT\n         EJECT\nCTOPEN   XR    R9,R9\n         XR    R8,R8\n         LA    R10,MAXERO\n         MVI   SWPRI,0\n         TM    0(R1),X'80'         CONTROL ARGUMENTS\n         BO    OP3\n         TM    4(R1),X'80'\n         BO    OP2\n         TM    8(R1),X'80'\n         BO    OP1\n         TM    12(R1),X'80'\n         BZ    ERO3\n         L     R2,12(R1)\n         MVC   SWPRI(L'SWPRI),0(R2)\n         TM    SWPRI,ICFMSPW\n         BZ    OP1\n         STCM  R2,B'1111',AMSPW\n         XC    1(L'SECMSTR,R2),1(R2)\nOP1      TM    11(R1),X'03'\n         BNZ   ERO3\n         L     R9,8(R1)\n         LA    R9,0(R9)\nOP2      TM    7(R1),X'03'\n         BNZ   ERO3\n         L     R8,4(R1)\n         LA    R8,0(R8)\nOP3      L     R7,0(R1)\n         LA    R7,0(R7)\n         SPACE 1\n         OC    ATIOT(L'ATIOT),ATIOT FISRT TIME?\n         BNZ   GOT                 BRANCH IF NOT\n         L     R2,CVTPTR           GET CVT ADDRESS\n         USING CVT,R2\n         TM    CVTDCB,CVT4MS1      TEST IF OS/VS2?\n         BZ    ERO4                BRANCH IF NOT\n         DROP  R2\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\n         SPACE 1\nGOT      LA    R5,DCBSR            SEARCH DD-CARD\n         USING IHADCB,R5\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED?\n         BO    ERO1                BRANCH IF YES\n         MVC   DCBDDNAM(L'DCBDDNAM),0(R7)\n         XR    R1,R1\n         L     R2,ATIOT            GET TIOT ADDRESS\n         USING TIODSECT,R2\nSRCH     CLC   TIOELNGH(L'ZEROS),ZEROS END OF TIOT?\n         BE    ERO5                YES\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM DD-NAME FOR US?\n         BE    DDFND               YES\n         IC    R1,TIOELNGH\n         AR    R2,R1               NEXT DD ENTRY\n         B     SRCH\n         DROP  R2\nDDFND   DEVTYPE  DCBDDNAM,DVTYP,DEVTAB\n         CLI   DVTYP+2,X'20'       TEST IF DIRECT-ACCESS STORAGE\n         BNE   ERO6                BRANCH IF NOT\n         LTR   R8,R8\n         BZ    RDJ\n         MVC   0(5*4,R8),DVTYP\n         L     R4,CVTPTR           GET CVT POINTER\n         USING CVT,R4\n         L     R15,CVTZDTAB        ADDRESS OF IECZDTAB\n         DROP  R4\n         LA    R15,0(0,R15)        IECZDTAB IS THE RESIDENT DIRECT\n         XR    R4,R4                    ACCESSS DEVICE CONSTANT TABLE\n         LR    R14,R4                   (SEE ASSEMBLY OF IECZDTAB)\n         IC    R14,DVTYP+3         GET DIRECT-ACCESS TYPE\n         IC    R4,0(R14,R15)       PICK UP TABLE DISPLACEMENT\n         ALR   R4,R15              DEVICE CONSTANT TABLE ADDRESS\n         MVC   20(2,R8),12(R4)     MOVE NR. OF ALT. TRACKS\nRDJ     RDJFCB  (DCBSR)\n         LTR   R15,R15             TEST COMPLETION CODE\n         BNZ   ERO7                JFCB ERROR\n         LA    R4,JF\n         USING JFCDSECT,R4\n         CLI   JFCBIND2,JFCOLD+JFCSHARE TEST DISP=SHR CODED?\n         BNE   ERO8                BRANCH IF NOT\n         CLC   JFCDSORG,=AL2(JFCORGAM)  TEST VSAM?\n         BNE   ERO8                BRANCH IF NOT\n         CLC   JFCBELNM,=CL8' '    CONTROL DD-CARD CODE\n         BNZ   ERO8\nJL0      EQU   JFCBLTYP-JFCBDSCB\n         OC    JFCBDSCB(JL0),JFCBDSCB\n         BNZ   ERO8\nJL1      EQU   JFCBCRDT-JFCBOTTR\n         OC    JFCBOTTR(JL1),JFCBOTTR\n         BNZ   ERO8\nJL2      EQU   JFCBIND2-JFCBXPDT\n         OC    JFCBXPDT(JL2),JFCBXPDT\n         BNZ   ERO8\nJL3      EQU   JFCDSORG-JFCBUFNO\n         OC    JFCBUFNO(JL3),JFCBUFNO\n         BNZ   ERO8\nJL4      EQU   JFCBNVOL-JFCRECFM\n         OC    JFCRECFM(JL4),JFCRECFM\n         BNZ   ERO8\nJL5      EQU   JFCBVLCT-JFCBPQTY\n         OC    JFCBPQTY(JL5),JFCBPQTY\n         BNZ   ERO8\n         CLI   JFCBVLCT,X'01'\n         BNE   ERO8\n         CLI   JFCBLTYP,JFCSL\n         BNE   ERO8\n         CLI   JFCBNVOL,X'01'\n         BNE   ERO8\n         CLI   JFCBSPTN,X'00'\n         BNE   ERO8\n         LTR   R8,R8\n         BZ    *+L'*+12\n         MVC   22(6,R8),JFCBVOLS   CATALOG VOLUME\n         MVC   28(L'JFCBDSNM,R8),JFCBDSNM    CATALOG NAME\n         MVC   WORKC(6),JFCBVOLS\n         MVC   DSNAME,JFCBDSNM\n         DROP  R4\n        OBTAIN GETDSCB\n         LTR   R15,R15\n         BNZ   ERO10               NO DSCB FMT-1 BACK, NOT ICF\n         USING DS1FMTID,R4\n         CLC   DS1DSSN(L'DS1DSSN),WORKC\n         BNE   ERO10\n         CLC   DS1DSORG,=AL1(0,DS1ACBM)\n         BNE   ERO10\n         CLI   DS1OPTCD,DS1OPTIC+DS1OPTBC\n         BNE   ERO10\n         CLI   DS1DSIND,DS1IND10\n         BNE   ERO10               NO PASSWORD REQUIRED\n         DROP  R4\n         SPACE 1\n         MVC   ACBSR+(ACBDDNM-IFGACB)(L'ACBDDNM),DCBDDNAM\n         TM    SWPRI,ICFAUTH       ALREADY AUTHORIZED?\n         BO    TT01                YES\n        SETAUTH ,                  NO, SET AUTHORIZATION ON\nTT01     TM    SWPRI,ICFKEY0       ALREADY SUP MODE, KEY 0?\n         BO    TT02                YES\n        MODESET KEY=ZERO,MODE=SUP  NO, ENTER SUPERVISOR MODE\n         USING PSA,R0\nTT02     L     R2,PSATOLD          PSA -> TCB\n         DROP  R0\n         LA    R2,0(,R2)\n         USING TCB,R2\n         L     R3,TCBJSCB          TCB -> JSCB\n         DROP  R2\n         USING IEZJSCB,R3\n         L     R3,JSCBACT          ACTIVE JSCB\n         OI    JSCBSWT1,JSCBPASS   SAY NO PASSWORDS, JUST IN CASE\n         TM    SWPRI,ICFKEY0       ALREADY SUP MODE, KEY 0?\n         BO    TT03                YES\n        MODESET KEY=NZERO,MODE=PROB     NO, RE-ENTER PROBLEM MODE\nTT03    OPEN   ACBSR               OPEN THE CATALOG\n         LR    R2,R15              SAVE OPEN RC\n         TM    SWPRI,ICFKEY0       ALREADY SUP MODE, KEY 0?\n         BO    TT04                YES\n        MODESET KEY=ZERO,MODE=SUP  NO, ENTER SUPERVISOR MODE\nTT04     NI    JSCBSWT1,255-JSCBPASS    PASSWORDS OFF\n         DROP  R3\n         TM    SWPRI,ICFKEY0       ALREADY SUP MODE, KEY 0?\n         BO    TT05                YES\n        MODESET KEY=NZERO,MODE=PROB     NO, RE-ENTER PROBLEM MODE\nTT05     TM    SWPRI,ICFAUTH       ALREADY AUTHORIZED?\n         BO    TT06                YES\n        RESAUTH ,                  NO, SET AUTHORIZATION OFF\nTT06     LTR   R15,R2              TEST OPEN RC\n         BZ    ACBOK\n         L     R2,4(R13)\n         ST    R15,24(R2)          SET OPEN RC IN R1\n         BAS   R14,XSHOW           GET VSAM ACB ERROR CODE\n         MVC   20(4,R2),WORK       SET ERROR CODE IN R0\n         B     ERO2\nACBOK    LA    R2,ACBSR            GET ADDRESS TO ACB\n         USING IFGACB,R2\n         TM    ACBINFL2,ACBCATX    CATX OPEN?\n         BO    ICFOK               YES\n         DROP  R2\n         BAS   R14,XCLOSE          NO, CLOSE IMMEDIATELY\n         L     R2,4(R13)\n         ST    R15,24(R2)          SET CLOSE RC IN R1\n         XC    WORK,WORK\n         LTR   R15,R15             CLOSE OK?\n         BZ    *+L'*+4             YES\n         BAS   R14,XSHOW           GET VSAM ACB ERROR CODE\n         MVC   20(4,R2),WORK       SET ERROR CODE IN R0\n         B     ERO9\nICFOK    OI    DCBOFLGS,DCBOFOPN   SET OPEN SUCCESSFULLY\n         DROP  R5\n         L     R0,BUFLEN           GET BUFFER SPACE\n        GETMAIN R,LV=(0)           INPUT BUFFER FOR BCS RECORDS\n         ST    R1,BUFPTR           SET ADDRESS OF RECORD BUFFER\n        GENCB  BLK=RPL,ACB=ACBSR,AM=VSAM,AREA=(*,BUFPTR),              1\n               AREALEN=(*,BUFLEN),OPTCD=(KEY,SEQ,MVE)\n         ST    R1,RPLSR            ADDRESS OF GENERATED RPL\n         XR    R10,R10\n         ST    R10,ENDREC\n         B     EXIT\n         SPACE 1\nERO1     BCTR  R10,0\nERO2     BCTR  R10,0\nERO3     BCTR  R10,0\nERO4     BCTR  R10,0\nERO5     BCTR  R10,0\nERO6     BCTR  R10,0\nERO7     BCTR  R10,0\nERO8     BCTR  R10,0\nERO9     BCTR  R10,0\nERO10    BCTR  R10,0\nMAXERO   EQU   ((*-ERO1)/2)+1\n         MVI   SWPRI,0             RESET PROCESSING INDICATORS\n         B     EXIT\n         EJECT\nCTCLOSE  XR    R9,R9\n         XR    R8,R8\n         LTR   R1,R1\n         BZ    CL2\n         LA    R10,MAXERC\n         TM    0(R1),X'80'         CONTROL ARGUMENTS\n         BO    CL1\n         TM    4(R1),X'80'\n         BZ    ERC1\n         TM    7(R1),X'03'\n         BNZ   ERC1\n         L     R9,4(R1)\n         LA    R9,0(R9)\nCL1      TM    3(R1),X'03'\n         BNZ   ERC1\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         SPACE 1\nCL2      LA    R2,DCBSR\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST IF OPENED?\n         BZ    CL3                 BRANCH IF NOT\n         NI    DCBOFLGS,255-DCBOFOPN    SET CLOSED\n         DROP  R2\n         BAS   R14,XCLOSE\n         L     R2,4(R13)\n         XC    20(4,R2),20(R2)     SET R0 = 0\n         ST    R15,24(R2)          SET CLOSE RC IN R1\n         LTR   R15,R15             CLOSE OK?\n         BZ    CL3                 YES\n         BAS   R14,XSHOW           GET VSAM ACB ERROR CODE\n         MVC   20(4,R2),WORK       SET ERROR CODE IN R0\n         B     ERC2\nCL3      LTR   R8,R8\n         BZ    CL4\n         MVC   0(LDATA,R8),NGETS\nCL4      XC    NGETS(LDATA),NGETS\n         XR    R10,R10\n         ST    R10,ENDREC\n         B     EXIT\n         SPACE 1\nERC1     BCTR  R10,0\nERC2     BCTR  R10,0\nMAXERC   EQU   ((*-ERC1)/2)+1\n         EJECT\nEXIT     LTR   R9,R9\n         BZ    *+L'*+4\n         ST    R10,0(R9)\n        $XRET  CC=(R10)\n         SPACE 2\n*        FIND NEXT CELL ROUTINE\n*\n*              R0  = WORK REGISTER\n*              R1  = CELL TYPE SEARCH REQUEST OR ZERO FOR NEXT ONLY\n*              R2  = BUFFER POINTER (CURRENT CELL)\n*              R14 = LINK REGISTER\n*\n*        AT EXIT, CC = ZERO - CELL TYPE FOUND\n*                      NON-ZERO - CELL TYPE NOT FOUND OR END OF\n*                                 RECORD REACHED\n         SPACE 1\n         USING ICFDSECT,R2\nNXCELL   XR    R1,R1\nNXCELLS  XR    R0,R0\n         ICM   R0,B'0011',ICFRLN   GET CELL LENGTH\n         AR    R2,R0               POINT TO NEXT CELL\n         CL    R2,ENDREC           END OF RECORD?\n         BL    *+L'*+4             BRANCH IF NOT\n         LTR   R2,R2               YES, SET CC\n         BR    R14\n         LTR   R1,R1               CELL TYPE REQUESTED?\n         BZR   R14                 NO\n         EX    R1,NXCELLT          IS IT THIS ONE?\n         BNE   NXCELL+L'NXCELL     NO, CONTINUE SEARCH\n         BR    R14                 YES (CC EQUAL = CC ZERO)\nNXCELLT  CLI   ICFRTY,*-*\n         DROP  R2\n         EJECT\n*        CLOSE CATALOG ACB AND FREE BUFFER SPACE ROUTINE.\n*\n*              R0  = WORK REGISTER\n*              R1  = WORK REGISTER\n*              R14 = LINK REGISTER\n*              R15 = CLOSE RETURN CODE\n         SPACE 1\nXCLOSE   ST    R14,SVLINK          SAVE LINK REGISTER\n         ICM   R1,B'1111',BUFPTR   ADDRESS OF RECORD BUFFER\n         BZ    XCLACB              BRANCH IF NONE\n         L     R0,BUFLEN           LENGTH TO GETMAIN\n        FREEMAIN R,LV=(0),A=(1)    RELEASE SPACE\n         XC    BUFPTR,BUFPTR       INDICATE IT\nXCLACB  CLOSE  ACBSR\n         L     R14,SVLINK          RESTORE LINK REGISTER\n         BR    R14                 BACK TO CALLER\n         SPACE 2\n*        GET VSAM ACB ERROR CODE ROUTINE.\n*\n*              R14 = LINK REGISTER\n*\n*        NOTE. AT EXIT, THE FIELD NAMED 'WORK' CONTAIN THE ERROR CODE.\n         SPACE 1\nXSHOW    ST    R14,SVLINK          SAVE LINK REGISTER\n        SHOWCB ACB=ACBSR,AREA=WORK,LENGTH=4,FIELDS=(ERROR)\n         L     R14,SVLINK          RESTORE LINK REGISTER\n         BR    R14                 BACK TO CALLER\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nWORKD    DC    D'0'\nWORKC    DC    CL8' '\nWORK     DC    F'0'\nATIOT    DC    A(*-*)\nRPLSR    DC    A(*-*)              MOVE MODE RPL FOR BCS ACCESS\nBUFLEN   DC    A(BSL*1024)         BUFFER SPACE LENGTH\nBUFPTR   DC    F'0'                ADDRESS OF RECORD WITHIN BUFFER\nDVTYP    DC    5F'0'\nCURREC   DC    F'0'                CURRENT POINTER IN RECORD\nENDREC   DC    F'0'                END OF RECORD POINTER\nSVBACK   DC    F'0'\nSVREGS   DC    3F'0'\nSVLINK   DC    F'0'\nZEROS    DC    F'0'\n         SPACE 1\nNGETS    DC    F'0'                GETS ISSUED AGAINST THE BCS\nNNVSM    DC    F'0'                NONVSAM ENTRIES\nNCLTR    DC    F'0'                CLUSTER ENTRIES\nNAIXE    DC    F'0'                ALTERNATE INDEX ENTRIES\nNDTCL    DC    F'0'                DATA (CLUSTER) ENTRIES\nNIXCL    DC    F'0'                INDEX (CLUSTER) ENTRIES\nNGDGB    DC    F'0'                GDG BASE ENTRIES\nNGDGE    DC    F'0'                GDG ENTRIES\nNPATH    DC    F'0'                PATH ENTRIES\nNALSE    DC    F'0'                ALIAS ENTRIES\nNTRUE    DC    F'0'                TRUENAME ENTRIES\nNICFC    DC    F'0'                ICF CONNECTOR ENTRIES\nLDATA    EQU   *-NGETS\n         SPACE 1\nDSNAME   DC    CL44' '\n         SPACE 1\nJOBFILE  DC    0F'0',XL1'87',AL3(JF)\nJF       DC    0F'0',XL176'00'\n         SPACE 1\nGETDSCB CAMLST SEARCH,DSNAME,WORKC,JF\n         EJECT\nTBTYPES  DS    0XL5                RECORD TYPES TABLE\n         DC    CL1'A',AL4(NONVSAM)\n         DC    CL1'B',AL4(GDGDS)\n         DC    CL1'C',AL4(CLUSTER)\n         DC    CL1'R',AL4(PATH)\n         DC    CL1'T',AL4(TRUE)\n         DC    CL1'U',AL4(CONNECT)\n         DC    CL1'X',AL4(ALIAS)\n         DC    XL1'0'              END OF TABLE MARKER\n         SPACE 2\nSWPRI   $ICFSW ,\nAMSPW    DC    AL4(*-*)\n         SPACE 2\n        LTORG\n         SPACE 2\n        PRINT  NOGEN\n         SPACE 1\nDCBSR   DCB    DEVD=DA,DSORG=PS,MACRF=R,EXLST=JOBFILE,DDNAME=XXXXXXXX\nACBSR   ACB    AM=VSAM,BUFNI=16,BUFND=16,EXLST=ERRSR,DDNAME=XXXXXXXX\nERRSR   EXLST  AM=VSAM,EODAD=ENDSR\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ICFS$": {"ttr": 19211, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14\"\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:22:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//ICFS     JOB (........),'INSTALL  - I C F S -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=3\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=ICFS\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   ICFSO\n  ALIAS   ICFSC\n  NAME    ICFSR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ICFS@": {"ttr": 19457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x18\\x8f\\x00\\x87\\x18\\x8f\\x16C\\x00\\xa6\\x00\\xa6\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-07-07T00:00:00", "modifydate": "1987-07-07T16:43:00", "lines": 166, "newlines": 166, "modlines": 0, "user": "SYSPAJA"}, "text": "1   01/06/87\n                                                      ICFS      1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *  READ SEQUENTIALLY AN ICF CATALOG.  * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Routine to read sequentially an entire ICF catalog.\n  ---------    A DD-card, written as below, is needed to define\n               the desired catalog :\n\n               //...     DD  DSN=...ICF catalog...,DISP=SHR\n\n  Calling sequence : CALL ICFSR,(A,B,C,D),VL\n  ------------------            (A,B,C)\n                                (A,B)\n                                (A)\n\n         Where : A - is the address of a field (format XL1,CL44) which\n                     receives, after each read operation, unless when\n                     the END-OF-FILE is detected, one of the following\n                     information :\n                      - a NON-VSAM DATA-SET name (format AL1(1),CL44).\n                      - a GDG DATA-SET name (format AL1(2),CL44).\n                      - a CLUSTER name (format AL1(3),CL44).\n                      - an ALTERNATE INDEX name (format AL1(4),CL44).\n                      - a DATA (CLUSTER) name (format AL1(5),CL44).\n                      - an INDEX (CLUSTER) name (format AL1(6),CL44).\n                      - a PATH name (format AL1(7),CL44).\n                      - an ALIAS name (format AL1(8),CL44).\n                      - an AIX TRUE-NAME name (format AL1(9),CL44).\n                      - a DATA TRUE-NAME name (format AL1(10),CL44).\n                      - an INDEX TRUE-NAME name (format AL1(11),CL44).\n                      - an ICF CONNECTOR name (format AL1(12),CL44).\n                      - a VSAM CONNECTOR name (format AL1(13),CL44).\n                      - an information continuation of a previous name\n                        (format AL1(255),CL44).\n\n                 B - is the address of a field (format CL6,XL2) which\n                     receives the VOLUME SERIAL NUMBER relative\n                     to the first argument if pertinent (otherwise\n                     it is cleared to blanks), followed by the FILE\n                     SEQUENCE NUMBER (only used for NON-VSAM tape, it\n                     is cleared to binary zeros). This argument is\n                     optional and may be omitted or his address may\n                     be set to zero in the parameters list.\n\n                 C - is the address of a field (format XL4) which\n                     receives the DEVICE TYPE relative to the second\n                     argument if pertinent, otherwise it is cleared\n                     to blanks. This argument is optional and may be\n                     omitted or his address may be set to zero in the\n                     parameters list.\n1   07/07/87\n                                                      ICFS      2/3.\n\n                 D - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional). Value is always\n                     placed in register 15 and can be :\n                     -1 - END-OF-FILE detected.\n                          CLOSE catalog is ok (R0 and R1 = 0) or if\n                          CLOSE error : R0 = VSAM CLOSE error code,\n                                        R1 = CLOSE return code (R15).\n                      0 - READ operation correctly executed.\n                      1 - READ error : R0 = VSAM FDBK error code,\n                                       R1 = GET return code (R15).\n                      2 - file not opened.\n                      3 - calling sequence or argument alignment error.\n                      4 - unexpected catalog record structure.\n\n         NOTE : on all error return, the catalog file status remains\n                unchanged (opened or closed).\n\n  Assembler macro : $ICFSR A,B,C,D\n  -----------------\n\n         Where B, C and/or D are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  Calling sequence : CALL ICFSO,(A,B,C),VL\n  ------------------            (A,B)\n                                (A)\n\n         Where : A - is the address of the DD-name (format CL8).\n\n                 B - is the address of the device characteristics\n                     (format FULLWORD - F boundary) returned by the\n                     routine if supplied (optional). It will receive\n                     five fullwords information as described in DEVTYPE\n                     macro (see MVS/Extended Architecture : System-Data\n                     Administration), followed by one halfword\n                     containing the number of alternate tracks for\n                     the device, followed by a six characters field\n                     containing the VOLUME SERIAL NUMBER of the device,\n                     followed by a 44 characters field containing the\n                     catalog data-set name. This argument is optional\n                     and may be omitted or his address may be set to\n                     zero in the parameters list.\n\n                 C - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional). Value is always\n                     placed in register 15 and can be :\n                      0 - OPEN correctly executed.\n                      1 - file already opened.\n                      2 - OPEN error : R0 = VSAM OPEN error code,\n                                       R1 = OPEN return code (R15).\n                      3 - calling sequence or argument alignment error.\n                      4 - not OS/VS2 System.\n1   01/06/87\n                                                      ICFS      3/3.\n                      5 - DD-card missing.\n                      6 - not direct-access storage device.\n                      7 - read JFCB error.\n                      8 - DD-card incorrectly coded.\n                      9 - not ICF catalog.\n                          CLOSE catalog is ok (R0 and R1 = 0) or if\n                          CLOSE error : R0 = VSAM CLOSE error code,\n                                        R1 = CLOSE return code (R15).\n                     10 - catalog DSCB FORMAT-1 control error.\n\n  Assembler macro : $ICFSO A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  Calling sequence : CALL ICFSC,(A,B),VL\n  ------------------            (A)\n\n         Where : A - is the address of the CATALOG CONTROL INFORMATION\n                     (format FULLWORDS - F boundaries) returned by the\n                     routine if supplied (optional : argument may be\n                     omitted passing a zero parameters list pointer,\n                     register 1, when the next is also omitted, or his\n                     address may be zero in the parameters list).\n                     It will receive twelve fullwords information as\n                     described below :\n                      - the total number of GETs issued against the\n                        Basic Catalog Structure.\n                      - the number of NONVSAM entries found.\n                      - the number of CLUSTER entries found.\n                      - the number of ALTERNATE INDEX entries found.\n                      - the number of DATA (CLUSTER) entries found.\n                      - the number of INDEX (CLUSTER) entries found.\n                      - the number of GDG BASE entries found.\n                      - the number of GDG entries found.\n                      - the number of PATH entries found.\n                      - the number of ALIAS entries found.\n                      - the number of TRUE-NAME entries found.\n                      - the number of ICF CONNECTOR entries found.\n\n                 B - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional). Value is always\n                     placed in register 15 and can be :\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence or argument alignment error.\n                      2 - CLOSE error : R0 = VSAM CLOSE error code,\n                                        R1 = CLOSE return code (R15).\n\n  Assembler macro : $ICFSC A,B\n  -----------------\n\n         Where A and/or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSORT": {"ttr": 19461, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x03\\x7f\\x00\\x90\\x03\\x7f\\x12F\\x01u\\x01u\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-02-06T00:00:00", "modifydate": "1990-02-06T12:46:00", "lines": 373, "newlines": 373, "modlines": 0, "user": "SYSPAJA"}, "text": "ISRT     TITLE 'INCORE SORT SUBROUTINE.'\nINSORT   START 0\n         SPACE 1\n* PURPOSE :    SORT IN ASCENDING OR DESCENDING ORDER (ONE CONTROL\n* ---------    FIELD ONLY) AN ARRAY OF FIXED ELEMENTS (USES A\n*              PARTITON-EXCHANGE SORT).\n*\n* CALLING SEQUENCE : CALL INSORT,(A,B,C),VL\n* ------------------             (A,B)\n*\n*        WHERE : A - IS THE ARRAY STARTING ADDRESS (FIRST ELEMENT).\n*\n*                B - IS THE ADDRESS OF THE PARAMETERS FIELD (MUST\n*                    BE HALFWORD BOUNDARY).\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - SORT CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     2 - KEY DISPLACEMENT NEGATIVE OR > 4095.\n*                     3 - ORDER OPTION ERROR (NOT A OR D).\n*                     4 - COMPARE OPTION ERROR (NOT B OR P).\n*                     5 - KEY LENGTH ZERO, NEGATIVE , > 256 IF 'B'\n*                         OPTION, OR > 16 IF 'P' OPTION.\n*                     6 - ELEMENT LENGTH ZERO OR NEGATIVE.\n*                     7 - NUMBER OF ELEMENTS NEGATIVE.\n*                     8 - KEY DISPL. + KEY LENGTH > ELEMENT LENGTH.\n*                     9 - INTERNAL STACK WORK AREA TOO SMALL.\n*                    10 - LOGIC ERROR.\n*\n* PARAMETERS FIELD DESCRIPTION : (FIVE CONTIGUOUS HALFWORDS)\n* ------------------------------\n*\n* OFFSET + 0 - NUMBER OF ELEMENTS TO BE SORTED (HALFWORD).\n*        + 2 - KEY DISPLACEMENT (HALFWORD). THIS IS THE STARTING\n*              POSITION OF THE CONTROL FIELD IN THE ARRAY'S\n*              ELEMENTS, ASSUMING THE FIRST POSITION OF AN ELEMENT\n*              KNOWN AS 0 (ZERO).\n*        + 4 - KEY LENGTH (HALFWORD).\n*        + 6 - LENGTH OF AN ELEMENT (HALFWORD).\n*        + 8 - OPTIONS (CHARACTERS) WHICH MAY BE :\n*              + 8 - A OR D (ASCENDING OR DESCENDING SORT ORDER)\n*              + 9 - B OR P (BINARY OR PACKED SORT COMPARE)\n*\n* GENERAL NOTICE : NOTE THAT THE RECORDS OUTSIDE OF THE AREA TO\n* ---------------- SORT ARE NOT REFERENCED AT ALL.\n         EJECT\n* AUTHOR :     RECEIVED FROM A. COLOMBO (AMDAHL CONSULTANT)\n* --------     REVISED BY MOINIL P.A. (J.R.C. ISPRA (VA), ITALY)\n         SPACE 2\nINSORT  AMODE  ANY\nINSORT  RMODE  ANY\n         SPACE 2\n        $DEFREG\nNS       EQU   128                 STACK NUMBER\nCLCOP    EQU   X'D5'               CLC OP. CODE\nCPOP     EQU   X'F9'               CP OP. CODE\n         EJECT\n        $XENT  BASE=R12\n         SPACE 1\n*        INITIALIZATION\n         SPACE 1\n         XR    R3,R3\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS\n         BO    ERR1\n         TM    7(R1),X'01'\n         BNZ   ERR1\n         TM    4(R1),X'80'\n         BO    INIT\n         TM    8(R1),X'80'\n         BZ    ERR1\n         TM    11(R1),X'03'\n         BNZ   ERR1\n         L     R3,8(R1)\n         LA    R3,0(R3)\nINIT     L     R11,4(R1)           POINTER TO PARAMETERS FIELD\n         LA    R11,0(R11)\n         LTR   R11,R11\n         BZ    ERR1\n         USING P#,R11\n         LH    R8,P#KEYDI          KEY DISPLACEMENT\n         LTR   R8,R8\n         BM    ERR2\n         CH    R8,=H'4095'         MAX DISPLACEMENT\n         BH    ERR2\n         SPACE 1\n*        SET ASCENDIND/DESCENDING\n*        SET BINARY/PACKED (IF PACKED MAX 16 BYTES KEY)\n         SPACE 1\n         STH   R8,CLC+2            FIRST RECORD\n         STH   R8,CLC+4            SECOND RECORD\n         CLI   P#AD,C'A'           IF ASCENDING, OK\n         BNE   IFD                 OTHERWISE REVERSE ORDER OF REGS\n         OI    CLC+2,R1*16         REGISTER 1\n         OI    CLC+4,R2*16         REGISTER 2\n         B     LOOKKEY\nIFD      CLI   P#AD,C'D'           IF DESCENDING, OK\n         BNE   ERR3\n         OI    CLC+2,R2*16         REGISTER 2\n         OI    CLC+4,R1*16         REGISTER 1\nLOOKKEY  LH    R8,P#KEYLE          KEY LENGTH\n         LTR   R8,R8               NO ZERO OR LESS\n         BNP   ERR5\n         CLI   P#TYPE,C'P'         PACKED\n         BNE   BINARY\n         CH    R8,=H'16'           MAX CP LENGTH\n         BH    ERR5\n         BCTR  R8,0                -1\n         STC   R8,CLC+1            SECOND OPERAND LENGTH\n         MVO   CLC+1(1),CLC+1(1)   FIRST OPERAND LENGTH\n         MVI   CLC,CPOP            CP INSTEAD OF CLC\n         B     LOOKRCL\nBINARY   CLI   P#TYPE,C'B'         BINARY\n         BNE   ERR4\n         CH    R8,=H'256'          MAX KEY LENGTH\n         BH    ERR5\n         BCTR  R8,0                -1\n         STC   R8,CLC+1            TO BUILD UP CLC\n         MVI   CLC,CLCOP           SET CLC\nLOOKRCL  LH    R8,P#RECLN          RECORD LENGTH\n         LTR   R8,R8\n         BNP   ERR6                NO ZERO OR NEGATIVE\n         LH    R5,P#RECNM          NUMBER OF RECORDS\n         LTR   R5,R5\n         BM    ERR7\n         BZ    RET                 NOTHING, DONE\n         LH    R2,P#KEYDI          KEY DISPLACEMENT\n         AH    R2,P#KEYLE          ADD KEY LENGTH\n         CH    R2,P#RECLN          > THAN RECORD LENGTH?\n         BH    ERR8                YES, ERROR\n         MR    R4,R8               RECORDS * LENGTH RECORD\n         L     R2,0(R1)            @ 1ST RECORD            (A)\n         LA    R2,0(R2)\n         LTR   R2,R2\n         BZ    ERR1\n         ST    R2,W#RECPT          @ 1ST RECORD\n         LA    R5,0(R2,R5)         @ PAST LAST RECORD\n         SLR   R5,R8               @ LAST RECORD           (B)\n         ST    R5,W#RECLS          SAVE @ LAST RECORD\n         L     R9,=A(STARTSTE)     @ OF START OF STACK\n         ST    R9,W#STKPT          SAVE @ OF STACK\n         SPACE 1\n*        MAIN : CHECK FOR ONLY ONE RECORD TO SORT\n         SPACE 1\n* REGISTERS USAGE :\n*        R0  - WORK\n*        R1  - @ RECORD (FOR COMPARE ROUTINE) / WORK\n*        R2  - A (@ LEFTMOST RECORD IN CURRENT GROUP)\n*        R3  - @ INDICATOR IF SUPPLIED (OR ZERO)\n*        R4  - WORK\n*        R5  - B (@ RIGHTMOST RECORD IN CURRENT GROUP)\n*        R6  - I (LEFT TO RIGHT SCAN PTR)\n*        R7  - J (RIGHT TO LEFT SCAN PTR)\n*        R8  - RECORD LENGTH\n*        R9  - STACK POINTER\n*        R10 - INDICATOR VALUE (CC)\n*        R11 - @ P#\n*        R12 - PGM BASE\n*        R13 - @ W#\n*        R14 - WORK\n*        R15 - WORK\n         SPACE 1\nSORT     CLR   R2,R5               COMPARE A AND B\n         BNL   SORTUS              BIF A >= B (ONLY ONE RECORD)\n         SPACE 1\n*        I = A\n*        J = B + RECLN (@ PAST LAST RECORD IN GROUP)\n         SPACE 1\n         LR    R6,R2               I = A\n         LR    R7,R5               B\n         ALR   R7,R8               + RECLN\n         SPACE 1\n*        PICK MEDIAN RECORD HERE AND SWAP WITH K(A)\n*        SO THAT ORDERED INPUT IS NOT WORST CASE...\n*        (((B - A)/RECLN)/2)*RECLN\n         SPACE 1\n         LR    R1,R5               B\n         SLR   R1,R2               B - A\n         SLR   R0,R0\n         DR    R0,R8               B-A/RECLN\n         SRL   R1,1                HALF THE RECORDS\n         CH    R1,=H'4'            < 4 RECORDS\n         BL    SORTL1              BIF < 4 RECORDS, SKIP MID SWAP\n         MR    R0,R8               OFFSET OF THE RECORD\n         ALR   R1,R2               @ OF K(MID)\n         LR    R4,R1               SAVE @ K(MID)\n         SPACE 1\n*        SWAP K(A) & K(MID)\n         SPACE 1\n         LR    R0,R4               @ K(MID)                (SOURCE)\n         LR    R1,R8               RECLN\n         L     R14,=A(WAREC)       @ TEMP RECORD AREA      (TARGET)\n         LR    R15,R8              RECLN\n         MVCL  R14,R0              K(MID) TO TEMP AREA\n         LR    R0,R2               @ K(A)                  (SOURCE)\n         LR    R1,R8               RECLN\n         LR    R14,R4              @ K(MID)                (TARGET)\n         LR    R15,R8              RECLN\n         MVCL  R14,R0              K(A) TO K(MID)\n         L     R0,=A(WAREC)        @ TEMP RECORD AREA      (SOURCE)\n         LR    R1,R8               RECLN\n         LR    R14,R2              @ K(A)                  (TARGET)\n         LR    R15,R8              RECLN\n         MVCL  R14,R0              K(MID) TO K(A) FROM TEMP AREA\n         SPACE 1\n*        FIND K(I) > K(A)\n         SPACE 1\nSORTL1   ALR   R6,R8               I = I + RECLN\n         CLR   R6,R7               I :: J\n         BNL   SORTF               BIF I >= J\n         LR    R1,R6               K(I)\n         EX    0,CLC               COMPARE K(I) AND K(A)      <R2>\n         BNH   SORTL1              BIF K(I) <= K(A)\n         SPACE 1\n*        FIND K(J) <= K(A)\n         SPACE 1\nSORTL2   SLR   R7,R8               J = J - RECLN\n         CLR   R7,R6               J :: I\n         BNH   SORTF               BIF J <= I\n         LR    R1,R7               K(J)\n         EX    0,CLC               COMPARE K(J) AND K(A)      <R2>\n         BH    SORTL2              BIF K(J) > K(A)\n         SPACE 1\n*        HAVE K(I) > K(A) & K(J) <= K(A)\n*        ALSO I < J SO ARE DIFFERENT RECORDS\n*        SWAP K(I) AND K(J)\n         SPACE 1\n         LR    R0,R6               @ K(I)                  (SOURCE)\n         LR    R1,R8               RECLN\n         L     R14,=A(WAREC)       @ TEMP RECORD AREA      (TARGET)\n         LR    R15,R8              RECLN\n         MVCL  R14,R0              K(I) TO TEMP AREA\n         LR    R0,R7               @ K(J)                  (SOURCE)\n         LR    R1,R8               RECLN\n         LR    R14,R6              @ K(I)                  (TARGET)\n         LR    R15,R8              RECLN\n         MVCL  R14,R0              K(J) TO K(I)\n         L     R0,=A(WAREC)        @ TEMP RECORD AREA      (SOURCE)\n         LR    R1,R8               RECLN\n         LR    R14,R7              @ K(J)                  (TARGET)\n         LR    R15,R8              RECLN\n         MVCL  R14,R0              K(I) TO K(J) FROM TEMP AREA\n         B     SORTL1              AND CONTINUE\n         SPACE 1\n*        UNABLE TO FIND K(I) > K(A) AND K(J) <= K(A) FOR I < J\n*        (I = J HERE AND I = J MAY BE > B)\n*        SO SWAP K(A) WITH K(J-1)\n         SPACE 1\nSORTF    LR    R4,R7               @ K(J)\n         SLR   R4,R8               @ K(J-1)\n         LR    R0,R4               @ K(J-1)                (SOURCE)\n         LR    R1,R8               RECLN\n         L     R14,=A(WAREC)       @ TEMP RECORD AREA      (TARGET)\n         LR    R15,R8              RECLN\n         MVCL  R14,R0              K(J-1) TO TEMP AREA\n         LR    R0,R2               @ K(A)                  (SOURCE)\n         LR    R1,R8               RECLN\n         LR    R14,R4              @ K(J-1)                (TARGET)\n         LR    R15,R8              RECLN\n         MVCL  R14,R0              K(A) TO K(J-1)\n         L     R0,=A(WAREC)        @ TEMP RECORD AREA      (SOURCE)\n         LR    R1,R8               RECLN\n         LR    R14,R2              @ K(A)                  (TARGET)\n         LR    R15,R8              RECLN\n         MVCL  R14,R0              K(J-1) TO K(A) FROM TEMP AREA\n         SPACE 1\n*        NOW SORT (A, J-2) AND (J, B)\n*        (R2, R4-R8) AND (R7, R5)\n*        (SOME MIGHT BE NULL - SORT SHORTEST FIRST, STACK OTHER)\n         SPACE 1\n         SLR   R4,R8               END ADDR OF GRP 1\n         LR    R0,R4\n         SLR   R0,R2               LENGTH OF GRP 1\n         LR    R1,R5\n         SLR   R1,R7               LENGTH OF GRP 2\n         CLR   R0,R1               COMPARE GRP LENGTHS\n         BH    SORTGRP             BIF GRP 1 > GRP 2 (DO GRP 2 FIRST)\n         XR    R2,R7               SWAP GRP'S 1 AND 2\n         XR    R7,R2\n         XR    R2,R7\n         XR    R4,R5\n         XR    R5,R4\n         XR    R4,R5\n         SPACE 1\n*        STACK GROUP 1 TO BE SORTED LATER\n         SPACE 1\nSORTGRP  CL    R9,=A(ENDSTE)       ROOM FOR ANOTHER STACK ENTRY\n         BH    ERR9                BIF WORKAREA TOO SMALL\n         ST    R2,0(,R9)           @ 1ST RECORD IN GROUP\n         ST    R4,4(,R9)           @ LAST RECORD IN GROUP\n         LA    R9,8(,R9)           PUSH STACK\n         SPACE 1\n*        SET UP TO SORT GROUP 2 NOW\n         SPACE 1\n         LR    R2,R7               @ 1ST REC IN GRP 2 (R5 ALREADY SET)\n         B     SORT\n         SPACE 1\n*        REMOVE STACK ENTRY\n         SPACE 1\nSORTUS   SH    R9,=H'8'\n         CL    R9,W#STKPT\n         BL    SRTCK               BIF STACK EMPTY, DONE\n         L     R2,0(,R9)           @ 1ST RECORD OF GROUP\n         L     R5,4(,R9)           @ LAST RECORD IN GROUP\n         B     SORT\n         SPACE 1\n*        SRTCK : CHECK THAT RESULTS IS ACTUALLY SORTED\n         SPACE 1\nSRTCK    L     R2,W#RECPT          @ 1ST RECORD\n         L     R5,W#RECLS          @ LAST RECORD\n         SLR   R2,R8               @ RECORD - 1\nSRTCKL   ALR   R2,R8               @ NEXT RECORD\n         LR    R1,R2\n         ALR   R1,R8               @ NEXT RECORD (IF ANY)\n         CLR   R1,R5               ANY NEXT RECORD?\n         BH    RET                 BIF NO NEXT, ALL DONE\n         EX    0,CLC               COMPARE TWO RECORDS, CHECK SEQ\n         BNL   SRTCKL              BIF NOT SEQ ERROR\n         B     ERR10               LOGIC ERROR\n         SPACE 1\nERR1     BCTR  R10,0     CALL SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\nERR2     BCTR  R10,0     KEY DISPLACEMENT NEGATIVE OR > 4095.\nERR3     BCTR  R10,0     ORDER OPTION ERROR (NOT A OR D).\nERR4     BCTR  R10,0     COMPARE OPTION ERROR (NOT B OR P).\nERR5     BCTR  R10,0     KEY LENGTH <=0, > 256 IF B, OR > 16 IF P.\nERR6     BCTR  R10,0     ELEMENT LENGTH ZERO OR NEGATIVE.\nERR7     BCTR  R10,0     NUMBER OF ELEMENTS NEGATIVE.\nERR8     BCTR  R10,0     KEY DISPL. + KEY LENGTH > ELEMENT LENGTH.\nERR9     BCTR  R10,0     INTERNAL STACK WORK AREA TOO SMALL.\nERR10    BCTR  R10,0     LOGIC ERROR.\n         SPACE 1\nMAXERR   EQU   ((*-ERR1)/2)+1\n         SPACE 1\n         B     SETCC\nRET      XR    R10,R10             RETURN CODE ZERO\nSETCC    LTR   R3,R3\n         BZ    EXIT\n         ST    R10,0(R3)           STORE CC IN INDICATOR\nEXIT    $XRET  CC=(R10)\n         SPACE 1\nCLC      CLC   0(*-*,R1),0(R2)     COMPARE TWO ELEMENTS <<EXECUTED>>\n         EJECT\n*        CONSTANTS AND WORK POINTERS\n         SPACE 1\nW#STKPT  DC    A(0)                @ STACK\nW#RECPT  DC    A(0)                @ FIRST RECORD IN RECORD AREA\nW#RECLS  DC    A(0)                @ LAST RECORD IN RECORD AREA\n         SPACE 2\n*        LITERAL POOL\n         SPACE 1\n         LTORG\n         SPACE 2\n*        WORK AREAS.\n         SPACE 1\nSTARTSTE DC    (NS)D'0'            STACK\nENDSTE   EQU   *-8\nWAREC    DC    (NS)D'0'            WORK AREA FOR RECORD\n         SPACE 2\n*        DATA DESCRIPTIONS (DSECTS)\n         SPACE 1\nP#       DSECT ,                   SORT PARAMETER LIST\n         SPACE 1\nP#RECNM  DC    H'0'                NUMBER OF RECORDS      (>= 0)\nP#KEYDI  DC    H'0'                KEY DISPLACEMENT\nP#KEYLE  DC    H'0'                KEY LENGTH\nP#RECLN  DC    H'0'                LENGTH OF EACH RECORD  (> 0)\nP#AD     DC    C' '                A/D\nP#TYPE   DC    C' '                B/P\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSORT$": {"ttr": 19468, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x17#\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T17:23:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//INSORT   JOB (........),'INSTALL  - INSORT -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=3\n//ASS     EXEC PAJIAS2,MBR=INSORT\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ENTRY   INSORT\n  NAME    INSORT(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSORT@": {"ttr": 19713, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00\\\\\\x00\\\\\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 92, "newlines": 92, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      INSORT    1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       INCORE SORT SUBROUTINE        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Sort in ascending or descending order (one control\n  ---------    field only) an array of fixed elements (uses a\n               partition-exchange sort).\n               Note : the records outside of the area to sort are\n                      not referenced at all.\n\n  Calling sequence : CALL INSORT,(A,B,C),VL\n  ------------------             (A,B)\n\n         Where : A - is the array starting address (first element).\n\n                 B - is the address of the parameters field (must\n                     be halfword boundary).\n\n                 C - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional). Value is always\n                     placed in register 15 and can be :\n\n                      0 - sort correctly executed.\n                      1 - calling sequence or argument alignment error.\n                      2 - key displacement negative or > 4095.\n                      3 - order option error (not A or D).\n                      4 - compare option error (not B or P).\n                      5 - key length zero, negative , > 256 if B\n                          option, or > 16 if P option.\n                      6 - element length zero or negative.\n                      7 - number of elements negative.\n                      8 - key displ. + key length > element length.\n                      9 - internal stack work area too small.\n                     10 - logic error.\n\n  Assembler macro : $INSORT A,B,C\n  -----------------\n\n         Where C is optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/09/85\n                                                      INSORT    2/2.\n\n  Parameters field description : (five contiguous halfwords)\n  ------------------------------\n\n  Offset + 0 - number of elements to be sorted (halfword).\n         + 2 - key displacement (halfword). This is the starting\n               position of the control field in the array's\n               elements, assuming the first position of an element\n               known as 0 (zero).\n         + 4 - key length (halfword).\n         + 6 - length of an element (halfword).\n         + 8 - options (characters) which may be :\n               + 8 - A or D (ascending or descending sort order)\n               + 9 - B or P (binary or packed sort compare)\n\n  Assembler macro : $INSORT PARM=(P1,P2,P3,P4,P5,P6)\n  -----------------\n\n         Only when building parameters field, register (0-15) use\n         may be coded within parentheses.\n\n  Examples of valid macro syntax :\n  --------------------------------\n\n         1. To generate only the call :\n               ...   $INSORT A,B\n               (register use may be coded within parentheses)\n\n         2. To generate an empty parameters field :\n               ...   $INSORT\n\n         3. To generate a parameters field :\n               ...   $INSORT PARM=(P1,P2,P3,P4,P5,P6)\n\n         4. To build a parameters field :\n               ...   $INSORT ,B,PARM=(P1,P2,P3,P4,P5,P6)\n               (register use may be coded within parentheses)\n\n         5. To generate a parameters field and the call :\n               ...   $INSORT A,PARM=(P1,P2,P3,P4,P5,P6)\n               (register use may be coded within parentheses)\n\n         6. To build a parameters field and generate the call :\n               ...   $INSORT A,B,PARM=(P1,P2,P3,P4,P5,P6)\n               (register use may be coded within parentheses)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INTRDR": {"ttr": 19716, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07O\\x00\\x95\\x07O\\x16C\\x00\\x9c\\x00\\x9c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-15T00:00:00", "modifydate": "1995-03-15T16:43:00", "lines": 156, "newlines": 156, "modlines": 0, "user": "SYSPAJA"}, "text": "IRDA     TITLE 'INTERNAL READER DYNAMIC ALLOCATION TSO-COMMAND.'\nINTRDR   START 0\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* * * *                                                         * * * *\n* * * *     INTERNAL READER DYNAMIC ALLOCATION TSO-COMMAND.     * * * *\n* * * *                                                         * * * *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* PURPOSE :    DYNAMICALLY ALLOCATE BY DDNAME AN INTERNAL READER.\n* ---------\n*\n* COMMAND :    SYNTAX : INTRDR DD-NAME\n* ---------    DEFAULT : DD-NAME 'SYSIR'.\n*\n* AUTHOR :     RAVARANI N. - MOINIL P.A.\n* --------     COMPUTING CENTRE (TP 361)\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\nINTRDR  AMODE  24\nINTRDR  RMODE  24\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R11,R13             SET WORK-AREAS ADDRESSABILITY.\n         USING WRKDSECT,R11\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n         LA    R1,RBBK\n         ST    R1,RBBKPTR\n         OI    RBBKPTR,X'80'\n         MVC   RBBK(L'RBBK),RBBKC\n         XC    RBRSC(RBBKEND-RBRSC),RBRSC\n         LA    R1,TXP\n         ST    R1,RBTXP\n         LA    R1,TXTUN1\n         ST    R1,TXP\n         LA    R1,TXTUN2\n         ST    R1,TXP+4\n         LA    R1,TXTUN3\n         ST    R1,TXP+8\n         LA    R1,TXTUN4\n         ST    R1,TXP+12\n         LA    R1,TXTUN5\n         ST    R1,TXP+16\n         LA    R1,TXTUN6\n         ST    R1,TXP+20\n         OI    TXP+20,X'80'\n         MVC   TXTUN1(TXTUNL),TXTUNC\n        $TEW$PP PARM=PARMLST,REG=R3\n         TM    DDNME+6,X'80'       IS DD-NAME SUPPLIED?\n         BZ    NONME               NO, USE DEFAULT.\n         L     R1,DDNME            GET POINTER TO DD-NAME.\n         LH    R2,DDNME+4          GET LENGTH.\n         BCTR  R2,0                - 1 FOR MOVE.\n         MVC   TXTDDN(8),=CL8' '   CLEAR TARGET FIELD.\n         EX    R2,MOVEDDN          MOVE REQUESTED DD-NAME.\n         MVC   TXTDDNL(2),DDNME+4  SET TRUE DD-NAME LENGTH.\n         DROP  R3\nNONME   IKJRLSA #TSANSW\n         SPACE 1\n         LA    R1,RBBKPTR          DYNALLOC LIST.\n        DYNALLOC\n         LTR   R15,R15             CHECK FOR ERRORS.\n         BZ    LEAVE               OK, ALLOCATED, C.C. = 0.\n         MVC   MSLNE(64),=CL64' -> INT-READER DYNAM ALL. FAILED (R15=  X\n               ) - ERC=    , INFO=    .'\n         STC   R15,MSLNE+39\n         SRL   R15,4\n         STC   R15,MSLNE+38\n         NC    MSLNE+38(2),=XL4'0F0F0F0F'\n         TR    MSLNE+38(2),=CL16'0123456789ABCDEF'\n         UNPK  MSLNE+48(5),RBRSC(3)\n         MVI   MSLNE+52,C','\n         NC    MSLNE+48(4),=XL4'0F0F0F0F'\n         TR    MSLNE+48(4),=CL16'0123456789ABCDEF'\n         UNPK  MSLNE+59(5),RBRSC+2(3)\n         MVI   MSLNE+63,C'.'\n         NC    MSLNE+59(4),=XL4'0F0F0F0F'\n         TR    MSLNE+59(4),=CL16'0123456789ABCDEF'\n         LA    R0,64\n         LA    R1,MSLNE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     LEAVE               +0 - NORMAL COMPLETION\n*                                  +4 - ERROR\n         SPACE 1\n*------- END OF PROCESSING.\n         SPACE 1\nSETRC    LA    R15,16              C.C. = 16.\nLEAVE   $XRET  CC=(R15),LV=WRKL,TYPE=RENT\n         SPACE 1\nMOVEDDN  MVC   TXTDDN(*-*),0(R1)   << EXECUTED >>\n         EJECT\n*------- CONSTANTS AND CONTROL BLOCKS SKELETONS.\n         SPACE 1\n*        DYNAMIC ALLOCATION CONSTANTS.\n         SPACE 1\nRBBKC    DC    AL1(RBBKEND-RBBK,S99VRBAL,S99NOCNV+S99NOMNT,0)\n         SPACE 1\nTXTUNC   DC    AL2(DALDDNAM),AL2(1)\n         DC    AL2(5)              DD-NAME LENGTH.\n         DC    CL8'SYSIR'          DD-NAME.\n         DC    AL2(DALDSNAM),AL2(1),AL2(5),CL5'&&SBMT'\n         DC    AL2(DALSYSOU),AL2(1),AL2(1),CL1'A'\n         DC    AL2(DALSPGNM),AL2(1),AL2(6),CL6'INTRDR'\n         DC    AL2(DALLRECL),AL2(1),AL2(2),AL2(80)\n         DC    AL2(DALRECFM),AL2(1),AL2(1),AL1(DCBRECF)\nTXTUNL   EQU   *-TXTUNC\n         SPACE 1\n        LTORG\n         SPACE 1\nPARMLST IKJPARM\nDDNME   IKJIDENT 'DD-NAME',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\n        IKJENDP\n         EJECT\n*------- WORK-AREAS DESCRIPTION.\n         SPACE 1\nWRKDSECT DSECT\n         SPACE 1\nSVA      DS    18F                 SAVE AREA.\n         SPACE 1\n        $TEW$WA\n         SPACE 1\nRBBKPTR  DC    0F'0',XL1'80',AL3(*-*)\n         SPACE 1\nRBBK     DC    0F'0',AL1(RBBKEND-RBBK,S99VRBAL,S99NOCNV+S99NOMNT,0)\nRBRSC    DC    F'0'                ERROR/INFO REASON CODES.\nRBTXP    DC    A(*-*)\n         DC    F'0',XL4'0'\nRBBKEND  EQU   *\n         SPACE 1\nTXP      DC    A(*-*,*-*,*-*,*-*,*-*),XL1'80',AL3(*-*)\n         SPACE 1\nTXTUN1   DC    AL2(DALDDNAM),AL2(1)\nTXTDDNL  DC    AL2(5)              DD-NAME LENGTH.\nTXTDDN   DC    CL8'SYSIR'          DD-NAME.\nTXTUN2   DC    AL2(DALDSNAM),AL2(1),AL2(5),CL5'&&SBMT'\nTXTUN3   DC    AL2(DALSYSOU),AL2(1),AL2(1),CL1'A'\nTXTUN4   DC    AL2(DALSPGNM),AL2(1),AL2(6),CL6'INTRDR'\nTXTUN5   DC    AL2(DALLRECL),AL2(1),AL2(2),AL2(80)\nTXTUN6   DC    AL2(DALRECFM),AL2(1),AL2(1),AL1(DCBRECF)\n         SPACE 1\nMSLNE    DS    CL64\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK-AREAS LENGTH.\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS\n        IEFZB4D0\n        IEFZB4D2\n        DCBD   DEVD=DA,DSORG=PS\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INTRDR$": {"ttr": 19720, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x8f\\x00\\x88\\t\\x8f\\x10W\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-07T00:00:00", "modifydate": "1988-04-07T10:57:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//INTRDR   JOB (........),'INSTALL  -INTRDR-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=INTRDR\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  NAME    INTRDR(R)\n/*\n//HLP     EXEC PAJHELP,MBR=INTRDRH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INTRDR@": {"ttr": 19722, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      INTRDR    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     ALLOCATE AN INTERNAL READER     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n   Function : The INTRDR command dynamically allocates an internal\n   ---------- reader.\n\n   Syntax :   INTRDR DD-name\n   --------   Required : none.\n              Default : DD-name SYSIR.\n\n   Operand :\n   ---------\n  DD-name   - a 1 to 8 alphamerics characters DD-name to which is\n              dynamically allocated an internal reader.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INTRDRH": {"ttr": 19724, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x13\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:13:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=INTRDR\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : THE INTRDR COMMAND DYNAMICALLY ALLOCATES AN INTERNAL\n              READER.\n)X SYNTAX :   INTRDR DD-NAME\n              REQUIRED : NONE.\n              DEFAULT : DD-NAME 'SYSIR'.\n)O OPERAND :\n))DD-NAME   - A 1 TO 8 ALPHAMERICS CHARACTERS DDNAME TO WHICH IS\n              DYNAMICALLY ALLOCATED AN INTERNAL READER.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPCDSN": {"ttr": 19726, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x15\\x1f\\x00\\x90\\x15\\x1f\\x17\\x17\\x00\\x94\\x00\\x94\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-05-31T00:00:00", "modifydate": "1990-05-31T17:17:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "SYSPAJA"}, "text": "ISPCDSN  TITLE 'DATA-SET SELECTION BY CURSOR FROM ISPF DISPLAY.'\nISPCDSN  START 0\n         SPACE 1\n***********************************************************************\n***                                                                 ***\n***  ISPCDSN WILL EXTRACT A DATA-SET, POINTED TO BY THE CURSOR,     ***\n***  FROM AN ISPF DISPLAY PANEL. DATA-SET NAMES ARE SCANNED FOR     ***\n***  FOLLOWING STANDARD NAMING AND LENGTH CONVENTIONS.              ***\n***                                                                 ***\n***  THE VARIABLE NAME TO CONTAIN THE DATA-SET NAME MUST BE PASSED  ***\n***  TO THE PROGRAM AS A PARAMETER, AND WILL BE PLACED INTO THE     ***\n***  SHARED VARIABLE POOL IF NO ERRORS ARE ENCOUNTERED. IF ERRORS   ***\n***  ARE ENCOUNTERED, A RETURN CODE REFLECTING THE TYPE OF ERROR    ***\n***  WILL BE RETURNED FOLLOWING COMPLETION OF THE PROGRAM.          ***\n***                                                                 ***\n***  RETURN CODES :                                                 ***\n***       4 - DATA-SET NAME CONTAINS UNMATCHED QUOTES               ***\n***       8 - DATA-SET NAME MISSING BETWEEN QUOTES                  ***\n***      12 - CURSOR NOT ON A DATA-SET NAME                         ***\n***      16 - DATA-SET NAME LARGER THAN THE 56 BYTE MAXIMUM         ***\n***      20 - CONTROL BLOCK PARAMETER ERROR                         ***\n***                                                                 ***\n***  EXAMPLE :                                                      ***\n***    ISPEXEC SELECT PGM(ISPCDSN) PARM(SOMEVAR)                    ***\n***    IF &LASTCC = 0 THEN ISPEXEC VGET (SOMEVAR) SHARED            ***\n***                                                                 ***\n***********************************************************************\n         SPACE 1\n* ORIGIN :     EXTRACTED FROM CBT TAPE 88 FEB, FILE 270.\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=WORKLEN,TYPE=RENT\n         LR    R9,R13              GET POINTER TO GOTTEN AREA\n         USING WORKAREA,R9         SET ADDRESSABILITY TO SAVE/WORK AREA\n         LA    R2,RPPL\n         LA    R3,RESETL\n         XR    R4,R4\n         LR    R5,R4\n         MVCL  R2,R4               RESET WORK-AREA\n         EJECT\n         LA    R10,MAXCC           SET MAX. EXIT CODE\n         LR    R11,R1              R11 = PARMLIST\n         L     R1,0(R11)           R1 = CONTROL BLOCK\n         CLC   0(3,R1),=C'TLD'     IS IT TLD?\n         BNE   EXIT20              NO, EXIT WITH RC(20)\n         L     R5,96(R1)           GET CURSOR LOCATION, R5 = SCREEN\n         LH    R6,166(R1)          R6 = OFFSET TO CURSOR\n         LA    R3,0(R6,R5)         R3 = CURSOR LOCATION\n         TRT   0(1,R3),TRNTBL      ARE WE ON DATA-SET NAME?\n         BZ    SCANLT              YES, BEGIN SCANNING FOR START\n         CLI   0(R3),C''''         NO, IS IT A QUOTE?\n         BE    SCANLT              YES, BEGIN SCANNING FOR START\n         B     EXIT12              NO, EXIT WITH RC(12)\nSCANLT   LA    R3,0(R6,R5)         R3 = CURSOR LOCATION\n         TRT   0(1,R3),TRNTBL      BYTE IN TABLE?\n         BNZ   *+L'*+6             NO, FOUND LEFT DELIMETER\n         BCTR  R6,0                YES, DECREMENT OFFSET, CHECK NEXT\n         B     SCANLT\n         CLI   0(R3),C''''         WAS DELIMETER A QUOTE?\n         BNE   *+L'*+4             NO, LEAVE BITS UNCHANGED\n         OI    FLAG,SWLQ           YES, FLIP BIT 6, SAYS LEFT QUOTE\n         LA    R4,0(R3)            R4 = LEFT DELIMETER\n         LA    R6,1(R6)            INCREMENT TO LEFTMOST POSITION\n         LA    R3,0(R6,R5)         R3 = LEFT POSITION OF DSNAME\n         XR    R1,R1               CLEAR FOR TEST\n         LR    R2,R1               CLEAR FOR TEST\n         TRT   0(56,R3),TRNTBL     SCAN TILL NOT IN TABLE OR BUFFER END\n         CR    R1,R2               HAVE REGISTERS CHANGED?\n         BE    EXIT16              NO, EXIT WITH RC(16)\n         LA    R7,0(R1)            EXTRACT DATA-SET, R7 = RIGHT DELIM.\n         CLI   0(R7),C''''         WAS DELIMETER A QUOTE?\n         BNE   *+L'*+4             NO, LEAVE BITS UNCHANGED\n         OI    FLAG,SWRQ           YES, FLIP BIT 7, SAYS RIGHT QUOTE\n         TM    FLAG,SWLQ+SWRQ      CHECK FOR QUOTES SURROUNDING DSNAME\n         BZ    ICALL               NO QUOTES\n         BM    EXIT4               UNMATCHED, EXIT WITH RC(4)\n         LA    R3,0(R4)            MATCHING QUOTES, PICK UP LEFT QUOTE\n         BCTR  R7,0                DECREMENT TO DELIMETER-1\n         CR    R3,R7               ARE ADDRESSES SAME?\n         BE    EXIT8               YES, MISSING DSNAME, EXIT WITH RC(8)\n         LA    R7,2(R7)            INCLUDE RIGHT QUOTE, PICK UP IT\nICALL    SR    R7,R3               R7 = LENGTH OF DATA-SET NAME\n         ST    R7,DSNLEN\n         L     R4,4(R11)           R4 = ISPF VARIABLE NAME\n        CALL   ISPLINK,(=CL8'VDEFINE',0(R4),0(R3),=CL8'CHAR',          X\n               DSNLEN),VL,MF=(E,RPPL)\n        CALL   ISPLINK,(=CL8'VPUT',0(R4),=CL8'SHARED'),VL,MF=(E,RPPL)\nEXIT     BCTR  R10,0               RC(0), NO ERRORS\nEXIT4    BCTR  R10,0\nEXIT8    BCTR  R10,0\nEXIT12   BCTR  R10,0\nEXIT16   BCTR  R10,0\nEXIT20   BCTR  R10,0\nMAXCC    EQU   (*-EXIT)/L'EXIT\n         SLL   R10,2\n        $XRET  CC=(R10)            RETURN TO WHO EVER CALLED US\n         EJECT\n***********************************************************************\n***           TRANSLATE TABLE FOR FINDING DATA-SET NAME             ***\n***********************************************************************\nTRNTBL   DC    256X'FF'\n         ORG   TRNTBL+C'.'\n         DC    X'00'               .\n         ORG   TRNTBL+C'('\n         DC    X'00'               (\n         ORG   TRNTBL+C'$'\n         DC    X'00'               $\n         ORG   TRNTBL+C')'\n         DC    X'00'               )\n         ORG   TRNTBL+C'#'\n         DC    2X'00'              # @\n         ORG   TRNTBL+X'81'\n         DC    9X'00'              A-I LOWER CASE\n         ORG   TRNTBL+X'91'\n         DC    9X'00'              J-R LOWER CASE\n         ORG   TRNTBL+X'A2'\n         DC    8X'00'              S-Z LOWER CASE\n         ORG   TRNTBL+C'A'\n         DC    9X'00'              A-I UPPER CASE\n         ORG   TRNTBL+C'J'\n         DC    9X'00'              J-R UPPER CASE\n         ORG   TRNTBL+C'S'\n         DC    8X'00'              S-Z UPPER CASE\n         ORG   TRNTBL+C'0'\n         DC    10X'00'             0-9\n         ORG\n         SPACE 1\n         LTORG ,                   STATIC WORK-AREA - LITERAL POOL\n         EJECT\n***********************************************************************\n***                     DYNAMIC WORK-AREA                           ***\n***********************************************************************\n         SPACE 1\nWORKAREA DSECT\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 1\nRPPL    CALL   ,(0,0,0,0,0),MF=L\nDSNLEN   DS    F\nFLAG     DS    XL1\nSWLQ     EQU   X'80'               LEFT QUOTE ENCOUNTERED\nSWRQ     EQU   X'40'               RIGHT QUOTE ENCOUNTERED\n         SPACE 1\nRESETL   EQU   (((*-RPPL)+7)/8)*8\nWORKLEN  EQU   (((*-WORKAREA)+7)/8)*8\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPCDSN$": {"ttr": 19730, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x1f\\x00\\x89\\x17\\x1f\\x123\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-20T00:00:00", "modifydate": "1989-06-20T12:33:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//ISPCDSN  JOB (........),'INSTALL - ISPCDSN -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS2,MBR=ISPCDSN\n//LNK     EXEC PAJILKI\n//SYSIN     DD *\n  INCLUDE      SYSISP(ISPLINK)\n  ENTRY   ISPCDSN\n  NAME    ISPCDSN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPCDSN@": {"ttr": 19732, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x1f\\x00\\x89\\x17\\x1f\\x12@\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-20T00:00:00", "modifydate": "1989-06-20T12:40:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": "1   16/03/89\n                                                      ISPCDSN   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    Data-set selection by cursor     * * * * * * * *\n  * * * * * * * *         from ISPF display.          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose : ISPCDSN will extract a data-set, pointed to by the cursor,\n  --------- from an ISPF display panel. Data-set names are scanned for\n         following standard naming and length conventions.\n\n         The variable name to contain the data-set name must be passed\n         to the program as a parameter, and will be placed into the\n         SHARED variable pool if no errors are encountered. If errors\n         are encountered, a return code reflecting the type of error\n         will be returned following completion of the program.\n\n         Return Codes :\n               4 - Data-set name contains unmatched quotes\n               8 - Data-set name missing between quotes\n              12 - Cursor not on a data-set name\n              16 - Data-set name larger than the 56 byte maximum\n              20 - Control Block parameter error\n\n         Example :\n              ISPEXEC SELECT PGM(ISPCDSN) PARM(SOMEVAR)\n              IF &LASTCC = 0 THEN ISPEXEC VGET (SOMEVAR) SHARED\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IXTOFMT$": {"ttr": 19734, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x17#\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T17:23:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//IXTOFMT5 JOB (........),'INSTALL  -IXTOFMT5-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=IXTOFMT5\n//LNK     EXEC PAJILKR,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   IXTOFMT5\n  NAME    IXTOFMT5(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IXTOFMT@": {"ttr": 19969, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x16\\x9f\\x00\\x87\\x16\\x9f\\x115\\x006\\x006\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-06-18T00:00:00", "modifydate": "1987-06-18T11:35:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "SYSPAJA"}, "text": "1   18/06/87\n                                                      IXTOFMT5  1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *   INDEXED VTOC FORMAT-5 INTERFACE   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n         This rouitne uses the CVAF service routines to convert the\n   free space bit map of an indexed VTOC into pseudo format-5 DSCBs.\n   This provides a compatibility interface function for PRE-DFDS\n   routines which examine format-5 DSCBs.\n         This routine is called once for each format-5 which must be\n   built. The index record buffer returned by CVAF is saved so that\n   no additional I/O need be done for succeeding calls. The buffers\n   are freed when the last format-5 DSCB is returned. Hence, this\n   ruotine should be called until a format-5 DSCB with DS5PTRDS equal\n   to zero is returned. The non-zero value in DS5PTRDS will allways\n   be C'00001'. No enqueue on the VTOC is performed.\n\n   Input : R1 ---> (PARMLIST)\n           A(WORD) ----- address of a fullword used by this routine.\n                         Must be zeroed for first call and returned\n                         unaltered thereafter.\n           A(DCB) ------ address of a DCB opened to the desired VTOC.\n                         No I/O may be outstanding to this DCB.\n           A(COUNT1) --- address of a fullword where count of the free\n                         (FMT 0) DSCBs will be returned.\n           A(COUNT2) --- address of a fullword where count of the free\n                         VIRS will be returned.\n           A(FMT5) ----- address of a 140-byte area for format-5 DSCB\n                         built by this routine.\n\n   Return codes :\n         R15  = 0   all OK.\n         R15  = 4   VTOC is not in indexed format. CVAFTST RC in reg 0.\n         R15  = 8   CVAFTST call failed (other than not indexed format\n                    VTOC). CVAFTST RC in reg 0.\n         R15  = 12  CVAFDSM call failed (other than non indexed format\n                    VTOC). CVAFDSM RC in high order byte of reg 0 (byte\n                    0). CVSTAT in low order byte of reg 0 (byte 3).\n                    CVAFDSM error ID in byte 1 of reg 0.\n         R15  = 16  (unused)\n         R15  = 20  logic error in this routine. CVAFDIR RC in high\n                    order byte of reg 0 (byte 0). CVSTAT in low order\n                    byte of reg 0 (byte 3).\n\n   Attributes :    Reentrant, Problem state, Problem key. This\n                   routine will work correctly on a non DFDS system.\n                   However, DFDS macros are required for assembly.\n\n   Author :    CHRIS THOMAS, UCLA/OAC SYSTEMS GROUP, 5/30/81.\n   --------    CBT origin : extracted from CBT tape 86 FEB, file 149.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IXTOFMT5": {"ttr": 19971, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x17\\x11\\x01?\\x01?\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T17:11:00", "lines": 319, "newlines": 319, "modlines": 0, "user": "SYSPAJA"}, "text": "IVFI     TITLE 'IXTOFMT5 -- INDEXED VTOC FORMAT-5 INTERFACE.'\n***********************************************************************\n*                                                                     *\n*        THIS ROUTINE USES THE CVAF SERVICE ROUTINES TO CONVERT THE   *\n*  FREE SPACE BIT MAP OF AN INDEXED VTOC INTO PSEUDO FORMAT-5 DSCBS.  *\n*  THIS PROVIDES A COMPATIBILITY INTERFACE FUNCTION FOR PRE-DFDS      *\n*  ROUTINES WHICH EXAMINE FORMAT-5 DSCBS.                             *\n*                                                                     *\n*        THIS ROUTINE IS CALLED ONCE FOR EACH FORMAT-5 WHICH MUST BE  *\n*  BUILT. THE INDEX RECORD BUFFER RETURNED BY CVAF IS SAVED SO THAT   *\n*  NO ADDITIONAL I/O NEED BE DONE FOR SUCCEEDING CALLS. THE BUFFERS   *\n*  ARE FREED WHEN THE LAST FORMAT-5 DSCB IS RETURNED. HENCE, THIS     *\n*  ROUTINE SHOULD BE CALLED UNTIL A FORMAT-5 DSCB WITH DS5PTRDS EQUAL *\n*  TO ZERO IS RETURNED. THE NON-ZERO VALUE IN DS5PTRDS WILL ALWAYS    *\n*  BE C'00001'. NO ENQUEUE ON THE VTOC IS PERFORMED.                  *\n*                                                                     *\n*  INPUT :     R1 ---> (PARMLIST)                                     *\n*              A(WORD) ----- ADDRESS OF A FULLWORD USED BY THIS       *\n*                            ROUTINE. MUST BE ZEROED FOR FIRST CALL   *\n*                            AND RETURNED UNALTERED THEREAFTER.       *\n*              A(DCB) ------ ADDRESS OF A DCB OPENED TO THE DESIRED   *\n*                            VTOC. NO I/O MAY BE OUTSTANDING TO THIS  *\n*                            DCB.                                     *\n*              A(COUNT1) --- ADDRESS OF FULLWORD WHERE COUNT OF THE   *\n*                            FREE (FMT 0) DSCBS WILL BE RETURNED.     *\n*              A(COUNT2) --- ADDRESS OF FULLWORD WHERE COUNT OF THE   *\n*                            FREE VIRS WILL BE RETURNED.              *\n*              A(FMT5) ----- ADDRESS OF 140-BYTE AREA FOR FORMAT-5    *\n*                            DSCB BUILT BY THIS ROUTINE.              *\n*                                                                     *\n*  RETURN CODES :                                                     *\n*              R15  = 0   ALL OK.                                     *\n*              R15  = 4   VTOC IS NOT IN INDEXED FORMAT.              *\n*                         CVAFTST RC IN REG 0.                    -EU-*\n*              R15  = 8   CVAFTST CALL FAILED (OTHER THAN NOT INDEXED *\n*                         FORMAT VTOC). CVAFTST RC IN REG 0.          *\n*              R15  = 12  CVAFDSM CALL FAILED (OTHER THAN NON INDEXED *\n*                         FORMAT VTOC). CVAFDSM RC IN HIGH ORDER BYTE *\n*                         OF REG 0 (BYTE 0). CVSTAT IN LOW ORDER BYTE *\n*                         OF REG 0 (BYTE 3). CVAFDSM ERROR ID IN BYTE *\n*                         1 OF REG 0.                             -EU-*\n*              R15  = 16  (UNUSED)                                    *\n*              R15  = 20  LOGIC ERROR IN THIS ROUTINE.            -EU-*\n*                         CVAFDIR RC IN HIGH ORDER BYTE OF REG 0  -EU-*\n*                         (BYTE 0). CVSTAT IN LOW ORDER BYTE OF   -EU-*\n*                         REG 0 (BYTE 3).                         -EU-*\n*                                                                     *\n*  ATTRIBUTES :    REENTRANT, PROBLEM STATE, PROBLEM KEY. THIS        *\n*                  ROUTINE WILL WORK CORRECTLY ON A NON DFDS SYSTEM.  *\n*                  HOWEVER, DFDS MACROS ARE REQUIRED FOR ASSEMBLY.    *\n*                                                                     *\n*  WRITTEN BY :    CHRIS THOMAS, UCLA/OAC SYSTEMS GROUP, 5/30/81.     *\n*                                                                     *\n***********************************************************************\n         EJECT\n* ---------------------------------------------------------------- -EU-\n* CBT ORIGIN : EXTRACTED FROM CBT TAPE 86 FEB, FILE 149.           -EU-\n* ---------------------------------------------------------------- -EU-\n         SPACE 1\nIXTOFMT5 START 0\n         SPACE 2\n*        REGISTERS DEFINITIONS.\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         TITLE 'IXTOFMT5 -- MAINLINE ROUTINE.'\n         SPACE 1\n*        INITIALIZATION.\n         SPACE 1\n        SAVE   (14,12),,IXTOFMT5-V.1.0--&SYSDATE-&SYSTIME--  SAVE REGS\n         LR    R12,R15             ESTABLISH BASE\n         USING IXTOFMT5,R12\n         LR    R9,R13              SAVE CALLER'S R13\n         LR    R11,R1              SAVE CALLER'S PARM POINTER\n         USING PARMLIST,R11\n         L     R1,PARMWORD         POINT TO ANCHOR WORD\n         ICM   R13,B'1111',0(R1)   GET MY WORK AREA ANCHOR\n         BNZ   SKIPGET             IF NON-ZERO, CALL FOR NEXT FMT5\n         SPACE 1\n*        GET WORK AREA AT FIRST CALL.\n         SPACE 1\n        GETMAIN RU,LV=WORKLEN,SP=0\n         LR    R13,R1              ESTABLISH WORK AREA\n         USING WORKAREA,R13\n         L     R1,PARMWORD         ADDRESS OF ANCHOR\n         ST    R13,0(,R1)          SAVE FOR SUBSEQUENT CALLS\n         LR    R0,R13              ADDRESS FOR MVCL\n         LA    R1,WORKLEN          LENGTH FOR MVCL\n         SR    R3,R3               ZERO FILL BYTE\n         MVCL  R0,R2               ZERO WORK AREA\n         SPACE 1\n*        CHAIN SAVE AREAS.\n         SPACE 1\nSKIPGET  ST    R9,SAVEAREA+4       SAVE CALLER'S R13\n         ST    R13,8(,R9)          FORWARD CHAIN\n         NC    SAVEEXT,SAVEEXT     CALL FOR FIRST FMT5?\n         BNZ   GETNEXT5            NO, RETURN NEXT FMT5\n         EJECT\n*        DETERMINE IF THIS IS A DCB FOR DASD WITH INDEXED VTOC.\n         SPACE 1\n         L     R2,PARMDCB          POINT TO PASSED DCB\n         L     R2,DCBDEBAD-IHADCB(,R2)  GET DEB FROM DCB PASSED\n         ST    R2,DEBADDR          SAVE FOR LATER (ZERO IF UCB)\n         SR    R3,R3               GET UCB ADDRESS FROM DEB        -EU-\n         ICM   R3,B'0111',(DEBUCBA-DEBDASD)+(DEBBASND-DEBBASIC)(R2)\n         ST    R3,UCBADDR\n        CVAFTST UCB=(R3)\n         B     *+L'*(R15)\n         B     UNINDXD             RC = 0  - DFDS NOT ON SYSTEM\n         B     UNINDXD             RC = 4  - VOL IS NOT INDEXED\n         B     GOODIX              RC = 8  - INDEXED. ALL OK\n         B     TSTERROR            RC = 12 - NO VOL MOUNTED, ETC...\n         B     TSTERROR            RC = 16 - BAD UCB (NOT DASD, ETC...)\n         SPACE 1\n*        CALL CVAFDSM FOR NUMBER OF FREE DSCBS.\n         SPACE 1\nGOODIX   L     R2,DEBADDR\n         MVC   CVPL(LENCVPL),CVPLMFL\n         MVC   CVUCB,UCBADDR                                       -EU-\n         MVI   EORID,0                                             -EU-\n        CVAFDSM MF=(E,CVPL),ACCESS=MAPDATA,MAP=VTOC,COUNT=YES,         1\n               MAPRCDS=YES,DEB=(2),CTAREA=COUNT1  GET COUNT1\n         B     *+L'*(R15)\n         B     GOODCT1             RC = 0  - SUCCESSFUL\n         B     DSMERROR            RC = 4  - END OF DATA, OR ERROR\n         B     DSMERROR            RC = 8  - INVALID VTOC INDEX\n         B     DSMERROR            RC = 12 - CVAF PARM LIST ERROR\n         B     DSMERROR            RC = 16 - DASD I/O ERROR\n         EJECT\n*        RETURN COUNT OF FREE DSCBS.\n         SPACE 1\nGOODCT1  L     R1,PARMCT1          @ COUNT1\n         MVC   0(4,R1),COUNT1      RETURN COUNT1\n         SPACE 1\n*        SAVE INDEX BUFFERS FOR SUCCEEDING FUNCTIONS.\n         SPACE 1\n         L     R1,CVMRCDS          GET ADDRESS OF BUFFERS\n         ST    R1,BUFLIST          SAVE FOR LATER\n         SPACE 1\n*        CALL CVAFDSM FOR NUMBER OF FREE INDEX BLOCKS (VIRS).\n         SPACE 1\n         L     R2,DEBADDR\n         L     R3,BUFLIST\n         MVC   CVPL(LENCVPL),CVPLMFL\n         MVC   CVUCB,UCBADDR                                       -EU-\n         MVI   EORID,1                                             -EU-\n        CVAFDSM MF=(E,CVPL),ACCESS=MAPDATA,MAP=INDEX,COUNT=YES,        1\n               MAPRCDS=(YES,(3)),DEB=(2),CTAREA=COUNT2 GET COUNT2\n         B     *+L'*(R15)\n         B     RETCT2              RC = 0  - SUCCESSFUL\n         B     DSMERROR            RC = 4  - END OF DATA, OR ERROR\n         B     DSMERROR            RC = 8  - INVALID VTOC INDEX\n         B     DSMERROR            RC = 12 - CVAF PARM LIST ERROR\n         B     DSMERROR            RC = 16 - DASD I/O ERROR\n         EJECT\n*        RETURN COUNT OF FREE VIRS.\n         SPACE 1\nRETCT2   L     R1,PARMCT2          @ COUNT2\n         MVC   0(4,R1),COUNT2      RETURN COUNT2\n         XC    SAVEEXT,SAVEEXT     BEGIN FMT5S AT THE BEGINNING\n         SPACE 1\n*        GET 26 FREE EXTENTS (ASK FOR 27 TO SIMPLIFY EOD LOGIC).\n         SPACE 1\nGETNEXT5 MVC   EXTS(L'DS5AVEXT),SAVEEXT      SET UP STARTING POINT\n         MVI   NUMEXTS,27\n         L     R2,DEBADDR\n         L     R3,BUFLIST\n         MVC   CVPL(LENCVPL),CVPLMFL\n         MVC   CVUCB,UCBADDR                                       -EU-\n         MVI   EORID,2                                             -EU-\n        CVAFDSM MF=(E,CVPL),ACCESS=MAPDATA,MAP=VOLUME,                 1\n               MAPRCDS=(YES,(3)),DEB=(2),EXTENTS=EXTABL GET EXTENTS\n         B     *+L'*(R15)\n         B     NOERROR             RC = 0  - SUCCESSFUL\n         B     CHECKEOD            RC = 4  - END OF DATA, OR ERROR\n         B     DSMERROR            RC = 8  - INVALID VTOC INDEX\n         B     DSMERROR            RC = 12 - CVAF PARM LIST ERROR\n         B     DSMERROR            RC = 16 - DASD I/O ERROR\n         SPACE 1\n*        IF RC=4, SEE IF ERROR OR END OF EXTENTS.\n         SPACE 1\nCHECKEOD CLI   CVSTAT,STAT032      END OF DATA?\n         BNE   DSMERROR            NO, OTHER ERROR\n         EJECT\n*        USE 26 (OR FEWER) EXTENTS RETURNED TO BUILD PSEUDO FORMT-5.\n         SPACE 1\nNOERROR  L     R10,PARMFMT5        ADDRESS FOR GENERATED FMT5\n         USING IECSDSF5,R10\n         MVC   DS5KEYID,F5ID       SET KEY\n         MVC   DS5AVEXT(L'DS5AVEXT+L'DS5EXTAV),EXTS    MOVE IN EXTS\n         MVI   DS5FMTID,C'5'       SET DSCB ID\n         MVC   DS5MAVET,EXTS+L'DS5AVEXT+L'DS5EXTAV     MOVE REMAINING\n         XC    DS5PTRDS,DS5PTRDS   ZERO CHAIN PTR\n         NC    EXT27,EXT27         IS 27TH EXT ZERO? (1ST IN NEXT FMT5)\n         BZ    CLEANUP             GO CLEANUP. ALL DONE\n         MVC   DS5PTRDS,NZPTR      MAKE PSEUDO CHAIN POINTER\n         MVC   SAVEEXT(5),DS5MAVET+L'DS5MAVET-L'DS5AVEXT    SAVE THE\n         B     RETURN              LAST EXTENT FOR NEXT FORMAT 5\n         DROP  R10\n         SPACE 1\n*        RELEASE BUFFERS FOR INDEX RECORDS AFTER LAST USE.\n         SPACE 1\nCLEANUP  L     R2,DEBADDR\n         L     R3,BUFLIST\n         MVC   CVPL(LENCVPL),CVPLMFL    FREEMAIN CVAF BUFFERS\n         MVC   CVUCB,UCBADDR                                       -EU-\n        CVAFDIR MF=(E,CVPL),ACCESS=RLSE,DEB=(2),MAPRCDS=(NO,(3))\n         LTR   R15,R15             ERROR?\n         BNZ   LOGICERR            YES, BAD, DIE                   -EU-\n         SPACE 1\n*        FREE GOTTEN WORK AREA (OR DFDS NOT INSTALLED ON SYSTEM).\n         SPACE 1\n         LR    R1,R13              ADDRESS OF WORKAREA TO BE FREED\n         L     R13,SAVEAREA+4      RELOAD CALLER'S SAVE PTR\n        FREEMAIN RU,LV=WORKLEN,A=(1),SP=0\n         L     R1,PARMWORD         POINT TO WORK AREA ANCHOR\n         SR    R15,R15             ZERO RETURN CODE\n         SR    R0,R0               ZERO SUPLEMENTARY RETURN CODE\n         ST    R15,0(,R1)          ZERO ANCHOR WORD\n         B     EXIT2               GO LEAVE\n         TITLE 'IXTOFMT5 -- TERMINATION ROUTINES.'\n*        VTOC IS NOT IN INDEXED FORMAT\n*        (OR DFDS NOT INSTALLED ON SYSTEM).\n         SPACE 1\nUNINDXD  LR    R0,R15              SAVE CVAFTST RETURN CODE        -EU-\n         LA    R15,4               INDICATE NOT INDEXED\n         B     EXIT                COMMON EXIT\n         SPACE 1\n*        CVAFTST COMPLETED WITH AN ERROR.\n         SPACE 1\nTSTERROR LR    R0,R15              SAVE CVAFTST RETURN CODE\n         LA    R15,8               INDICATE FAILURE\n         B     EXIT                COMMON EXIT\n         SPACE 1\n*        CVAFDSM COMPLETED WITH AN ERROR.\n         SPACE 1\nDSMERROR LR    R0,R15              PUT CVAFDSM RETURN CODE INTO\n         SLL   R0,24               ... HIGH ORDER BYTE OF R0\n         IC    R0,CVSTAT-CVPL(R1)  ADD CVSTAT VALUE\n         ICM   R0,B'0100',EORID    AND SET ERROR IDENTIFIER        -EU-\n         LA    R15,12              INDICATE FAILURE\n         B     EXIT                COMMON EXIT\n         SPACE 1\n*        INTERNAL LOGIC ERROR OR INCORRECT CALL.\n         SPACE 1\nLOGICERR LR    R0,R15              PUT CVAFDIR RETURN CODE INTO    -EU-\n         SLL   R0,24               ... HIGH ORDER BYTE OF R0       -EU-\n         IC    R0,CVSTAT-CVPL(R1)  ADD CVSTAT VALUE                -EU-\n         LA    R15,20              INDICATE FAILURE\n         B     EXIT                COMMON EXIT\n         SPACE 1\n*        NORMAL CONDITIONS.\n         SPACE 1\nRETURN   SR    R0,R0               ZERO SUPLEMENTARY RETURN CODE\n         SR    R15,R15             ZERO PRIMARY RETURN CODE\n         B     EXIT                COMMON EXIT\n         SPACE 1\n*        COMMON EXIT ROUTINE.\n         SPACE 1\nEXIT     L     R13,SAVEAREA+4      RESTORE CALLER'S SAVE PTR\nEXIT2    L     R14,12(,R13)        RESTORE R14\n         LM    R1,R12,24(R13)      RESTORE R1 THRU R12 (R15,R0 SET)\n         BR    R14                 RETURN\n         TITLE 'IXTOFMT5 -- CONSTANTS.'\nF5ID     DC    XL4'05050505'       FMT5 KEY\nNZPTR    DC    C'00001'            CHAR INSURES INVALID DASD ADDRESS\nCVPLMFL CVAFDSM MF=L\nLENCVPL  EQU   *-CVPLMFL\n         TITLE 'IXTOFMT5 -- WORK AREA DESCRIPTION.'\nWORKAREA DSECT\nSAVEAREA DC    18F'0'              SAVE AREA\nCOUNT1   DC    F'0'                FORMAT 0 DSCBS\nCOUNT2   DC    F'0'                FREE INDEX RECORDS\nBUFLIST  DC    A(0)                ADDR VIX BFRS OBTAINED BY CVAF\nDEBADDR  DC    A(0)                ADDR OF DEB PASSED IN CALLER'S DCB\nUCBADDR  DC    A(0)                ADDR OF UCB PASSED (PRIV CALLER)\nSAVEEXT  DC    XL5'0'              BEGINNING OF NEXT FMT5\nEORID    DC    XL1'0'              ERROR ORIGIN IDENTIFIER         -EU-\nEXTABL   DS    0CL(1+(27*5))       FANCY LENGTH\nNUMEXTS  DC    AL1(27)             NR OF EXTENTS REQUESTED\nEXTS     DC    CL(27*5)' '         27 5-BYTE FREE SPACE EXTENTS\n         ORG   *-5\nEXT27    DC    CL5' '              GIVE LAST ONE A NAME\n         ORG\n         SPACE 1\nCVPL    ICVAFPL DSECT=NO\n         SPACE 1\nWORKLEN  EQU   *-WORKAREA\n         SPACE 2\n         DSECT\n        IECSDSL1 (5)\n         SPACE 2\nPARMLIST DSECT\nPARMWORD DS    A                   ANCHOR FOR GETMAINED AREA\nPARMDCB  DS    A                   ADDR OF DCB FOR VTOC\nPARMCT1  DS    A                   ADDR OF #FMT 0S\nPARMCT2  DS    A                   ADDR OF #FREE VIRS\nPARMFMT5 DS    A                   ADDR OF FMT5 WORKAREA\n         SPACE 2\n        PRINT  NOGEN\n        DCBD   DSORG=PS,DEVD=DA\n        IEZDEB LIST=NO\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JB": {"ttr": 19977, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07O\\x00\\x95\\x07O\\x16I\\x01T\\x01T\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-15T00:00:00", "modifydate": "1995-03-15T16:49:00", "lines": 340, "newlines": 340, "modlines": 0, "user": "SYSPAJA"}, "text": "JB       TITLE 'TSO DISPLAY TIME STATUS OF EXECUTING JOB(S) COMMAND.'\nJB       START 0\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* * * * * * * * * * *                             * * * * * * * * * * *\n* * * * * * * * * * *   DISPLAY TIME STATUS OF    * * * * * * * * * * *\n* * * * * * * * * * *                             * * * * * * * * * * *\n* * * * * * * * * * *     EXECUTING JOB(S).       * * * * * * * * * * *\n* * * * * * * * * * *                             * * * * * * * * * * *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* PURPOSE :    DISPLAY THE CPU AND SRB (I/O) TIME OF A SPECIFIC\n* ---------    EXECUTING JOB OR ALL EXECUTING JOBS WHICH NAME STARTS\n*              BY A GIVEN PREFIX.\n*\n* COMMAND :    SYNTAX : JB JOB-NAME (OR JOB-NAME PREFIX).\n* ---------    DEFAULT : JOB-NAME - CURRENT 'USERID' PREFIX.\n*              ALTERNATE SYNTAX : JB J-LIST\n*                  WHERE J-LIST MAY BE ENTERED IN THE FORM :\n*                      (PARAMETER,PARAMETER,...)\n*                  WHICH IS A LIST OF JOB-NAMES AND/OR JOB-NAME\n*                  PREFIXES.\n*\n* AUTHOR :     COLOMBO A. (AMDAHL CONSULTANT)\n* --------     MOINIL P.A.\n*              COMPUTING CENTRE (TP 361)\n*              J.R.C. - ISPRA ESTABLISHMENT.\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\nJB      AMODE  24\nJB      RMODE  24\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R11,R13             SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R11\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n         XC    DEFLT(L'DEFLT),DEFLT\n         L     R2,#TSPSCB\n         USING PSCB,R2\n         LA    R1,PSCBUSER\n         ST    R1,DEFLTAD\n         MVC   DEFLTLG+1(1),PSCBUSRL\n         DROP  R2\n         MVI   DEFLTCH,X'FF'\n        $TEW$PP PARM=PARMLST,REG=R3\n         TM    JBNME+6,X'80'       IS JOB-NAME SUPPLIED?\n         BO    *+L'*+8             YES.\n         LA    R3,DEFLT            NO, USE DEFAULT PDE (USERID).\n         B     *+L'*+4\n         LA    R3,JBNME\n         DROP  R3\n         ST    R3,STSCAD\n         SPACE 1\n*------- SEARCH ASCB'S.\n         SPACE 1\n         BAS   R10,CLEAR\n        $TSWXA 31,EXPAND=ONLY\n         USING PSA,R0              PSA ADDRESSABILITY.\n         L     R1,FLCCVT           GET CVT POINTER.\n         USING CVT,R1              CVT ADDRESSABILITY.\n         L     R2,CVTASVT          GET ASVT POINTER.\n         USING ASVT,R2             ASVT ADDRESSABILITY.\n         L     R8,ASVTMAXU         NUMBER OF ASCB'S.\n         LA    R7,ASVTENTY         FIRST ENTRY ADDRESS.\n         DROP  R0,R1,R2\nSCAN     TM    0(R7),ASVTAVAL      IS IT AN AVAILABLE ASID?\n         BO    NEXT                YES, GO GET NEXT.\n         L     R2,0(R7)            GET ASCB ADDRESS.\n         USING ASCB,R2             ASCB ADDRESSABILITY.\n         L     R4,ASCBOUCB         GET OUCB POINTER.\n         USING OUCB,R4             OUCB ADDRESSABILITY.\n         TM    OUCBYFL,OUCBLOG     IF ON, TSU.\n         BZ    NOTTSU\n         MVC   TTYPE,=C'TSO'\n         MVC   TTRAN,OUCBTRXN      TRANSACTION NAME.\n         L     R3,ASCBCSCB         GET CSCB ADDRESS.\n         LTR   R3,R3               IF ZERO, NO CSCB (MASTER).\n         BNZ   OKCSCB              NO.\n         L     R3,ASCBJBNS         JOBNAME POINTER.\n         LTR   R3,R3\n         BZ    UNKNOW\n         USING CHKEY,R3            CSCB ADDRESSABILITY.\n         CLI   CHKEY,C' '          IS JOBNAME MISSING?\n         BE    UNKNOW              YES.\n         MVC   TNAME,CHKEY         SET JOBNAME.\n         B     OKNME\n         DROP  R3\nUNKNOW   CLI   OUCBUSRD,C' '       TRY WITH USERID.\n         BE    NOTFND              BRANCH IF MISSING.\n         MVC   TNAME,OUCBUSRD      SET USERID.\n         B     OKNME\nNOTFND   MVC   TNAME,=C'STARTING'\n         L     R3,ASCBTSB          GET TSB ADDRESS.\n         LTR   R3,R3               IS IT ZERO?\n         BZ    OKNME               IF NO TSB, SKIP.\n        ZEROKEY\n         USING TSB,R3              TSB ADDRESSABILITY.\n         CLC   TSBLINE,=H'0'       ADDRESS MISSING?\n         BE    MVTERM              YES.\n         UNPK  WORK(5),TSBLINE(3)  LINE ADDRESS.\n         TR    WORK+1(3),TRTAB-C'0'\n         MVC   TNAME(2),=C'T#'     TO SAY TERMINAL.\n         MVC   TNAME+2(3),WORK+1\n         B     MVTERM+L'MVTERM\nMVTERM   MVC   TNAME,TSBTRMID      TERMINAL SYMBOLIC NAME.\n         DROP  R3\n        RESETKEY\n         B     OKNME\n         USING CHAIN,R3            CSCB ADDRESSABILITY.\nOKCSCB   CLI   CHKEY,C' '          IS JOBNAME MISSING?\n         BE    UNKNOW              BRANCH IF YES.\n         MVC   TNAME,CHKEY         SET JOBNAME.\n         B     OKNME\nNOTTSU   MVC   TNAME,OUCBTRXN      TRANSACTION NAME.\n         L     R3,ASCBCSCB         GET CSCB ADDRESS.\n         TM    CHTRKID,CHINITID    IS IT AN INITIATOR?\n         BNO   SYSTM               NO.\n         DROP  R3\n         L     R3,ASCBJBNI         JOBNAME POINTER.\n         LTR   R3,R3               IS IT ZERO?\n         BZ    NEXT                YES.\n         USING CHKEY,R3            CSCB ADDRESSABILITY.\n         MVC   TTYPE,=C'JOB'\n         MVC   TNAME,CHKEY         SET JOBNAME.\n         CLI   CHSTEP,C' '         IS STEP NAME MISSING?\n         BE    PROCST              YES.\n         MVC   TTRAN,CHSTEP        STEP NAME.\n         B     OKNME\nPROCST   MVC   TTRAN,CHPROCSN      SET PROC. STEP NAME.\n         B     OKNME\nSYSTM    MVC   TTYPE,=C'SYS'       SYSTEM TASK.\n         L     R3,ASCBJBNS         JOBNAME POINTER.\n         LTR   R3,R3               IS IT ZERO?\n         BZ    NEXT                YES.\n         MVC   TNAME,CHKEY         SET JOBNAME.\n         DROP  R3,R4\n         SPACE 1\n*------- MATCH JOB-NAMES OR PREFIXES.\n         SPACE 1\nOKNME    L     R3,STSCAD           GET START SCAN ADDRESS.\n         USING DEFLT,R3            SET PDE'S ADDRESSABILITY.\nLOOP     L     R4,DEFLTAD          JOB-NAME ADDRESS.\n         LH    R1,DEFLTLG          JOB-NAME LENGTH.\n         BCTR  R1,0\n         EX    R1,CLCMMM           IF SOME JOBNAME OR SIMILAR.\n         BE    DOLIST\n         CLC   DEFLTCH(4),=X'FF000000'  END OF SCAN?\n         BE    NEXT                YES.\n         L     R3,DEFLTCH          NEXT PDE IN CHAIN.\n         B     LOOP\n         DROP  R3\nCLCMMM   CLC   TNAME(*-*),0(R4)\n         SPACE 1\n*------- DISPLAY CPU AND SRB TIME.\n         SPACE 1\nDOLIST   MVC   TMCPU,=C'CPU='\n         MVC   PTIME,ASCBEJST      STEP TIME.\n         MVC   STIME,ASCBEATT      JOB TIME.\n         LA    R1,TCPU\n         BAS   R10,EDIT\n         MVC   STIME(L'ASCBJSTL),ASCBJSTL    TIME LIMIT.\n         LA    R1,TLCPU\n         BAS   R10,EDITALT\n         MVC   TMSRB,=C'I/O='\n         XC    PTIME,PTIME\n         MVC   STIME,ASCBSRBT      ACCUMULATED SRB TIME.\n         LA    R1,TSRB\n         BAS   R10,EDIT\n         MVC   STIME(4),ASCBR15C   SRB LIMIT.\n         LA    R1,TLSRB\n         BAS   R10,EDITALT\n         DROP  R2\n        $TSWXA 24,EXPAND=ONLY\n         BAS   R10,SENDL\n        $TSWXA 31,EXPAND=ONLY\nNEXT     LA    R7,4(R7)            NEXT ENTRY.\n         BCT   R8,SCAN             LOOP UNTIL END.\n        $TSWXA 24,EXPAND=ONLY\n         SPACE 1\n*------- COMMAND TERMINATION.\n         SPACE 1\n         XR    R9,R9               SET RC=0.\nLEAVE   IKJRLSA #TSANSW\n         SPACE 1\nQUIT    $XRET  CC=(R9),LV=WRKL,TYPE=RENT\nSETRC    LA    R9,16               SET RC=16.\n         B     QUIT\nPUTERR   LA    R9,8                SET RC=8.\n         B     LEAVE\n         EJECT\n*------- EDIT TIME ROUTINES.\n*        AT ENTRY : 'PTIME' AND 'STIME' OR ONLY 'STIME'.\n*                   R1 POINTS TO EDIT TARGET FIELD (FORMAT CL12).\n*              WORK REGISTERS = R14, R15.\n*              LINK REGISTER = R10.\n         SPACE 1\nEDIT     MVC   0(12,R1),=CL12'  0: 0: 0. 0'\n         OC    PTIME,PTIME\n         BNZ   EDITPM\n         OC    STIME,STIME\n         BNZ   EDITSM\n         BR    R10                 RETURN.\nEDITPM   LM    R14,R15,PTIME\n         SRDL  R14,12              IN 1.000.000 TH. OF SEC.\n         D     R14,=F'10000'       IN 100 TH. OF SEC.\n         OC    STIME,STIME\n         BZ    EDITZR\n         ST    R15,PTIME           BACK IN 100 TH. OF SEC.\n         B     EDITSM\nEDITALT  OC    STIME(4),STIME      ANY LIMIT?\n         BNZ   EDITLMT             YES.\n         MVC   0(11,R1),=CL11' NO CONTROL'\n         BR    R10                 RETURN.\nEDITLMT  MVC   0(11,R1),=CL11'(  0: 0: 0)'\n         LA    R1,1(R1)\n         XR    R15,R15\n         ST    R15,PTIME\n         ST    R15,STIME+4\nEDITSM   LM    R14,R15,STIME\n         SRDL  R14,12              IN 1.000.000 TH. OF SEC.\n         D     R14,=F'10000'       IN 100 TH. OF SEC.\n         A     R15,PTIME           TOTAL TIME.\nEDITZR   XR    R14,R14             CLEAR REMAINDER.\n         D     R14,=F'360000'      GET HOURS.\n         CVD   R15,WORK\n         MVC   EDITW,=XL16'40202020202020202020202020202120'\n         ED    EDITW,WORK\n         MVC   0(3,R1),EDITW+L'EDITW-3\n         LTR   R15,R14             GET REMAINDER.\n         BZR   R10                 NULL, RETURN.\n         XR    R14,R14             CLEAR.\n         D     R14,=F'6000'        GET MINUTES.\n         CVD   R15,WORK\n         MVC   EDITW,=XL16'40202020202020202020202020202120'\n         ED    EDITW,WORK\n         MVC   4(2,R1),EDITW+L'EDITW-2\n         LTR   R15,R14             GET REMAINDER.\n         BZR   R10                 NULL, RETURN.\n         XR    R14,R14             CLEAR.\n         D     R14,=F'100'         GET SECONDS.\n         CVD   R15,WORK\n         MVC   EDITW,=XL16'40202020202020202020202020202120'\n         ED    EDITW,WORK\n         MVC   7(2,R1),EDITW+L'EDITW-2\n         CLI   9(R1),C')'          ALTERNATE FORM?\n         BER   R10                 YES, RETURN.\n         CVD   R14,WORK            TH. OF SEC.\n         MVC   EDITW,=XL16'40202020202020202020202020202120'\n         ED    EDITW,WORK\n         MVC   10(2,R1),EDITW+L'EDITW-2\n         BR    R10                 RETURN.\n         EJECT\n*------- COMMUNICATION WITH USER ROUTINE.\n*        AT ENTRY : THE MESSAGE TEXT IS PLACED IN 'LINE' AREA.\n*        AT EXIT : THE 'LINE' AREA IS BLANKS RESET.\n*              WORK REGISTERS = R0, R1, R14, R15.\n*              LINK REGISTER = R10.\n         SPACE 1\nSENDL    LA    R1,LINE\n         LA    R15,L'LINE-1\n         ALR   R15,R1\nSENDY    CLI   0(R15),C' '\n         BNE   SENDZ\n         CLR   R1,R15\n         BE    SENDZ\n         BCT   R15,SENDY\nSENDZ    SR    R15,R1\n         BZR   R10\n         LA    R0,1(,R15)\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     CLEAR               +0 - NORMAL COMPLETION\n         B     PUTERR              +4 - ERROR\nCLEAR    MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         BR    R10\n         EJECT\n*------- CONSTANTS AND CONTROL BLOCKS SKELETONS.\n         SPACE 1\nTRTAB    DC    C'0123456789ABCDEF'\n         SPACE 1\n        LTORG\n         SPACE 1\nPARMLST IKJPARM\nJBNME   IKJIDENT 'JOB-NAME',LIST,MAXLNTH=8,                            1\n               FIRST=ALPHA,OTHER=ALPHANUM\n        IKJENDP\n         EJECT\n*------- WORK-AREAS DESCRIPTION.\n         SPACE 1\nWRKDSECT DSECT\n         SPACE 1\nSVA      DS    18F                 SAVE AREA.\n         SPACE 1\nWORK     DC    D'0'\nPTIME    DC    D'0'\nSTIME    DC    D'0'\nSTSCAD   DC    A(0)\n         SPACE 1\n        $TEW$WA\n         SPACE 1\n*        DEFAULT PDE.\n         SPACE 1\nDEFLT    DS    0XL12\nDEFLTAD  DC    A(0)\nDEFLTLG  DC    H'0'\n         DC    H'0'\nDEFLTCH  DC    XL1'FF',XL3'0'\n         SPACE 1\nEDITW    DC    CL16' '\nLINE     DC    CL80' '\n         SPACE 1\n         ORG   LINE\nTTYPE    DS    CL3,C\nTNAME    DS    CL8,C\nTTRAN    DS    CL8,C\nTMCPU    DS    CL4\nTCPU     DS    CL12\nTLCPU    DS    CL11,C\nTMSRB    DS    CL4\nTSRB     DS    CL12\nTLSRB    DS    CL11\n         SPACE 1\n         ORG\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         EJECT\n        PRINT  NOGEN\n        IHAASCB\n        IHAASVT\n        IHAPSA\n        IRAOUCB\n        IEECHAIN\n        IKJTSB\n        $TEW$DS\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JB$": {"ttr": 20228, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14\"\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:22:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//JB       JOB (........),'INSTALL  - JB -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=JB\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   JB\n  NAME    JB(R)\n/*\n//HLP     EXEC PAJHELP,MBR=JBH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JB@": {"ttr": 20230, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x08_\\x00\\x87\\x08_\\x10\\x18\\x00-\\x00-\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-03-26T00:00:00", "modifydate": "1987-03-26T10:18:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "SYSPAJA"}, "text": "1   26/03/87\n                                                      JB        1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    DISPLAY CPU - SRB (I/O) TIME.    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n   Function : The JB command displays the CPU and SRB (I/O) time used\n   ---------- by currently executing background jobs and/or foreground\n              sessions (TSO-users), each followed between parentheses\n              by the limit if available.\n\n   Syntax :   JB JOB-list\n   --------   Required : none.\n              Default : current USERID and all the jobs which name\n                        begins with USERID.\n              Alias : none.\n\n   Operands :\n   ----------\n  JOB-list  - A list of one or more names used to search the executing\n              jobs/sessions queue (when more names are entered, they\n              must be enclosed in parentheses and separated each from\n              the other by a comma).\n              A name shorter than 8 characters long is assumed to be\n              a request of notices about all jobs/sessions which names\n              starts by this prefix.\n              ---------------------------------------------\n              Only info about executing jobs are displayed.\n              ---------------------------------------------\n              Jobs in waiting for execution or in output queues are\n              not searched (use the STATUS command).\n              The jobs/sessions accumulated CPU and SRB (I/O) time are\n              displayed in the form :\n                   HH:MM:SS.TH (hours:minutes:seconds.tenths),\n              and the limits are displayed in the form :\n                   HH:MM:SS (hours:minutes:seconds).\n              For background jobs the name of the currently executing\n              step or procedure step is displayed, and for foreground\n              sessions the name of the currently executing command is\n              displayed (blanks means terminal waiting for user input).\n              If session STARTING, the physical terminal address (if\n              available) is displayed in the from T#XXX.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JBH": {"ttr": 20232, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x08_\\x00\\x87\\x08_\\x10\\x18\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-03-26T00:00:00", "modifydate": "1987-03-26T10:18:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=JB\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : THE JB COMMAND DISPLAYS THE CPU AND SRB (I/O) TIME USED\n              BY CURRENTLY EXECUTING BACKGROUND JOBS AND/OR FOREGROUND\n              SESSIONS (TSO-USERS), EACH FOLLOWED BETWEEN PARENTHESES\n              BY THE LIMIT IF AVAILABLE.\n)X SYNTAX :   JB JOB-LIST\n              REQUIRED : NONE.\n              DEFAULT : CURRENT 'USERID' AND ALL THE JOBS WHICH NAME\n                        BEGINS WITH 'USERID'.\n              ALIAS : NONE.\n)O OPERANDS :\n))JOB-LIST  - A LIST OF ONE OR MORE NAMES USED TO SEARCH THE EXECUTING\n              JOBS/SESSIONS QUEUE (WHEN MORE NAMES ARE ENTERED, THEY\n              MUST BE ENCLOSED IN PARENTHESIS AND SEPARATED EACH FROM\n              THE OTHER BY A COMMA).\n              A NAME SHORTER THAN 8 CHARACTERS LONG IS ASSUMED TO BE\n              A REQUEST OF NOTICES ABOUT ALL JOBS/SESSIONS WHICH NAMES\n              STARTS BY THIS PREFIX.\n              ---------------------------------------------\n              ONLY INFO ABOUT EXECUTING JOBS ARE DISPLAYED.\n              ---------------------------------------------\n              JOBS IN WAITING FOR EXECUTION OR IN OUTPUT QUEUES ARE\n              NOT SEARCHED (USE THE STATUS COMMAND).\n              THE JOBS/SESSIONS ACCUMULATED CPU AND SRB (I/O) TIME ARE\n              DISPLAYED IN THE FORM :\n                   HH:MM:SS.TH (HOURS:MINUTES:SECONDS.TENTHS),\n              AND THE LIMITS ARE DISPLAYED IN THE FORM :\n                   HH:MM:SS (HOURS:MINUTES:SECONDS).\n              FOR BACKGROUND JOBS THE NAME OF THE CURRENTLY EXECUTING\n              STEP OR PROCEDURE STEP IS DISPLAYED, AND FOR FOREGROUND\n              SESSIONS THE NAME OF THE CURRENTLY EXECUTING COMMAND IS\n              DISPLAYED (BLANKS MEANS TERMINAL WAITING FOR USER INPUT).\n              IF SESSION 'STARTING', THE PHYSICAL TERMINAL ADDRESS (IF\n              AVAILABLE) IS DISPLAYED IN THE FORM T#XXX.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JOBCARD": {"ttr": 20234, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x179\\x00H\\x00H\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T17:39:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM) NOPROCESS\n/*  MACRO NAME : JOBCARD                                            */\n/*    FUNCTION : COPY JOB CARD FROM USER ISPF PROFILE               */\n/*      SYNTAX : JOBCARD                                            */\n/*               JOBCARD HELP OR H                                  */\n/*       DEBUG : JOBCARD LIST                                       */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(HELP) OR +\n      &STR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTJBCD)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ISREDIT PROCESS DEST\n  IF &LASTCC = 0 THEN DO\n    ISREDIT LOCATE .ZDEST\n    IF &LASTCC = 8 THEN GOTO EMPTY\n    ISPEXEC VGET ZLLGJOB1\n    ISREDIT MASKLINE = \"&ZLLGJOB1\"\n    ISREDIT LINE_AFTER .ZDEST = MASKLINE\n    ISPEXEC VGET ZLLGJOB2\n    ISREDIT (LINEPTR) = LINENUM .ZDEST\n    SET &LINEPTR = &LINEPTR + 1\n    ISREDIT MASKLINE = \"&ZLLGJOB2\"\n    ISREDIT LINE_AFTER &LINEPTR = MASKLINE\n    ISPEXEC VGET ZLLGJOB3\n    ISREDIT (LINEPTR) = LINENUM .ZDEST\n    SET &LINEPTR = &LINEPTR + 2\n    ISREDIT MASKLINE = '&ZLLGJOB3'\n    ISREDIT LINE_AFTER &LINEPTR = MASKLINE\n    ISPEXEC VGET ZLLGJOB4\n    ISREDIT (LINEPTR) = LINENUM .ZDEST\n    SET &LINEPTR = &LINEPTR + 3\n    ISREDIT MASKLINE = '&ZLLGJOB4'\n    ISREDIT LINE_AFTER &LINEPTR = MASKLINE\n    GOTO ERROROUT\n    END\n  ELSE DO\nEMPTY: ISPEXEC VGET ZLLGJOB1\n    ISREDIT MASKLINE = \"&ZLLGJOB1\"\n    ISREDIT LINE_AFTER 0 = MASKLINE\n    ISPEXEC VGET ZLLGJOB2\n    ISREDIT (LINEPTR) = LINENUM .ZCSR\n    SET &LINEPTR = .ZLAST\n    ISREDIT MASKLINE = \"&ZLLGJOB2\"\n    ISREDIT LINE_AFTER 1 = MASKLINE\n    ISPEXEC VGET ZLLGJOB3\n    ISREDIT (LINEPTR) = LINENUM .ZCSR\n    SET &LINEPTR = .ZLAST\n    ISREDIT MASKLINE = '&ZLLGJOB3'\n    ISREDIT LINE_AFTER 2 = MASKLINE\n    ISPEXEC VGET ZLLGJOB4\n    ISREDIT (LINEPTR) = LINENUM .ZCSR\n    SET &LINEPTR = .ZLAST\n    ISREDIT MASKLINE = '&ZLLGJOB4'\n    ISREDIT LINE_AFTER 3 = MASKLINE\nERROROUT: ISREDIT MASKLINE = ' '\n    SET RC = 0\n    END\n  END\nEXIT CODE(&RC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBCARD@": {"ttr": 20237, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11W\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:57:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": "1   21/07/89\n                                                      JOBCARD   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    JOBCARD ISPF/PDF EDIT command    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to copy a JOB card from the\n  ----------   users ISPF profile. Under ISPF option 0.2, the JOB\n               card(s) at the bottom of the panel will be copied when\n               the JOBCARD macro is issued. The JOB card can be updated\n               using the ISPF option 0.2, and it should be changed to\n               reflect a valid JOB card for the user.\n\n  Command syntax : JOBCARD\n  ---------------- JOBCARD HELP or H\n\n  Use :        Type JOBCARD on the COMMAND line, the JOB card will\n  -----        then be inserted at the top of data. If you desire it\n               somewhere other than the top of data, type A (after) or\n               B (before) on the line number at the point in the data\n               you want the JOB card, as i.e. :\n               COMMAND ===> JOBCARD\n          ---> A 0600   Data ...\n               000700   Data ...\n               Result : the JOB card would be inserted after line 600.\n                        Identical process is obtained with :\n          ---> B 0700   Data ...\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBS": {"ttr": 20239, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943_\\x00\\x943_\\t\\x17\\x01s\\x01s\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-01T00:00:00", "modifydate": "1994-12-01T09:17:00", "lines": 371, "newlines": 371, "modlines": 0, "user": "SYSPAJA"}, "text": "A20      TITLE 'PGM TO SHOW EXEC JOBS AND STC'                     -EU-\nTSO020A  START 0                                                   -EU-\n         SPACE 1                                                   -EU-\n*        DATA SET TSO020SU   AT LEVEL 001 AS OF 07/06/77\n*        DATA SET TSO020SU   AT LEVEL 001 AS OF 03/09/77\n*        DATA SET TSO020SU   AT LEVEL 001 AS OF 02/12/77\n*\n* THIS LITTLE GEM WILL SCURRY AROUNT THE ASCBS AND CSCBS TO DISPLAY\n*        THE JOBS RUNNING IN THE SYSTEM (MODIFIED FOR SUPV I AND II\n*        S.U.) THROUGH STEALTH, THIS CODE IS NON PRIVLEDGED (ASSUMING\n*        THAT SQA IS NOT FETCH PROTECTED.\n* THIS WORKS FOR OS/VS2 REL 3.7 AND REQUIRES MACROS FROM SYS1.MODGEN\n*\n* KEN TRUE, FAIRCHILD CAMERA AND INSTRUMENT                22OCT76\n*\n* MODIFIED TO WORK AS TSO COMMAND OR OPER STC     K TRUE   27MAY77\n* ADD SWAP STATUS AND REASON CODE FROM OUCB         \"        \"\n*\n* MODIFIED TO OPERATE FOR MVS/XA 2.1 BY MOINIL P.A.        06AUG86 -EU-\n* MODIFIED TO OPERATE WITH \"PUTLINE\" BY MOINIL P.A.        13APR94 -EU-\n         SPACE 1                                                   -EU-\n* CBT ORIGIN : EXTRACTED FROM FILE 352.                            -EU-\n         SPACE 1                                                   -EU-\nTSO020A  AMODE 24                                                  -EU-\nTSO020A  RMODE 24                                                  -EU-\n         EJECT ,                                                   -EU-\n        $DEFREG ,                                                  -EU-\n        $XENT  BASE=R12,LV=AREAL,TYPE=RENT                         -EU-\n         LR    R11,R13                                             -EU-\n         USING AREA,R11                                            -EU-\n         LR    R2,R1               GET ENTRY REGISTER              -EU-\n        $TSWXA 31,EXPAND=ONLY                                      -EU-\n         MVI   BUFFER,C' '         CLEAR OUT BUFFER\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   MSGTSU(31),=CL31'..XXXXXX JOBS XXXXXX INITIATORS'   -EU-\n        $TEW$EC REG=R2,MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE             -EU-\n         XR    R2,R2               COUNTER FOR # INITIATORS\n         XR    R3,R3               COUNTER FOR # JOBS/STC\n         L     R7,CVTPTR           (R7)=ADDR CVT\n         USING CVTMAP,R7                                           -EU-\n         L     R9,CVTOPCTP         (R9) =ADDR (SRM'S RMCT)\n         ST    R9,RMCTPTR            WHICH IS SAVED FOR LATER\n         L     R9,CVTASVT          (R9)= ADDR ASVT\n         DROP  R7\n         USING ASVT,R9\n         L     R5,ASVTMAXU         (R5)=MAX NUMB OF ASCB ENTRIES\n         LA    R5,2(R5)              +2 SO WE CAN SCAN ENTIRE ASVT..\n         LA    R9,ASVTFRST-4       (R9)= ADDR-4 OF FIRST ASCB ENTRY\n         DROP  R9\n         LA    R0,L'HEADING\n         LA    R1,HEADING\n         BAS   R14,PUTLNE          WRITE OUT HEADING\n         B     *+L'*(R15)          HOW COMPLETE?                   -EU-\n         B     NEXTONE             +0 - GO GET ASCB                -EU-\n         B     SETRC               +4 - INVALID OR ERROR           -EU-\n         USING ASCB,R8\n         SPACE 1\n*------- LOOP THROUGH ALL ASCBS\n         SPACE 1\nLOOP1    L     R10,ASCBCSCB        LOAD CSCB ADDR\n         USING CSCB,R10\n         TM    CHTRKID,CHINITID    IS IT AN INIT?\n         BNO   TESTJOB             NO-> ..GO CHECK FOR JOB\n         A     R2,=F'1'            YES-> INCR COUNT OF INITS\n         B     NEXTONE             GO GET ANOTHER\nTESTJOB  TM    CHTRKID,CHJOBID     IS IT A STC?\n         BNO   NEXTONE             NOPE-> MUST BE TSO..GO GET ANOTHER\n         OI    SWITCH,OUTEX        SAY WE FOUND ONE\n         MVC   JOBNAME,CHCLS       MOVE IN JOBNAME FROM CSCB\n         MVC   PROCNAME,CHKEY      MOVE IN PROCNAME FROM CSCB\n         MVC   STEPNAME,CHPROCSN   MOVE IN STEPNAME FROM CSCB\n         DROP  R10\n         A     R3,=F'1'            BUMP COUNT OF JOBS/STC\n         BAS   R6,COMPTIME         GO GET STEP/CPU TIME\n*                                    AND MEMORY STATUS\n         LA    R0,L'BUFFER\n         LA    R1,BUFFER\n         BAS   R14,PUTLNE          SHOVEL IT OUT\n         B     *+L'*(R15)          HOW COMPLETE?                   -EU-\n         B     *+L'*+4             +0 - CONTINUE                   -EU-\n         B     SETRC               +4 - INVALID OR ERROR           -EU-\n         MVI   BUFFER,C' '         CLEAR IT OUT\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\nNEXTONE  BCT   R5,DOIT             CHECK COUNT\n         B     DOJOBS              NO MORE..SPLIT\nDOIT     LA    R9,4(0,R9)          INCR INTO ASVT\n         L     R8,0(0,R9)          LOAD ASCB ADDR\n         LTR   R8,R8               END OF ASCBS?\n         BZ    DOJOBS              YES->EXIT\n         TM    0(R9),X'80'         ASID ASSIGNED?\n         BO    NEXTONE             NO-> TRY AGAIN.\n         B     LOOP1               YES->SEE IF WE LIKE IT\n         SPACE 1\n*------- NOW WE HAVE DISPOSED OF THE STC IN THE SYSTEM,\n*        WE MUST GO BACK THRU THE ASCBS AND LOOK FOR 'REAL' JOBS...\n         SPACE 1\nDOJOBS   L     R7,CVTPTR           (R7)=ADDR CVT\n         USING CVTMAP,R7                                           -EU-\n         L     R9,CVTASVT          (R9)= ADDR ASVT\n         DROP  R7\n         USING ASVT,R9\n         L     R5,ASVTMAXU         (R5)=MAX NUMB OF ASCB ENTRIES\n         LA    R5,2(R5)              +2 SO WE CAN SCAN ENTIRE ASVT..\n         LA    R9,ASVTFRST-4       (R9)= ADDR-4 OF FIRST ASCB ENTRY\n         DROP  R9\n         B     NEXTPLS             GO GET ASCB\n         SPACE 1\n*------- LOOP THROUGH ALL ASCBS\n         SPACE 1\nLOOP2    L     R10,ASCBCSCB        LOAD CSCB ADDR\n         USING CSCB,R10\n         TM    CHTRKID,CHINITID    IS IT AN INIT?\n         BNO   NEXTPLS             ->NO GO GET ANOTHER ASCB\n         DROP  R10\n         L     R4,ASCBJBNI         GET PTR TO JOBNAME\n         LTR   R4,R4               IS IT A JOB?\n         BZ    NEXTPLS             NOPE->DRY INIT..GO GET ANOTHER\n         SPACE 1\n*------- HERE WE GET  SNEAKY..A HONEST TO GOD JOB'S CSCB IS NOT POINTED\n*        TO BY ASCBCSCB, BUT INSTEAD, ASCBJBNI (JOBNAME) REALLY POINTS\n*        TO THE  CHKEY IN THE CSCB FOR THE JOB. WE'LL GET OUR GOODIES\n*        IN THE INDIRECT ROUTE ...\n         SPACE 1\n         USING CSCB,R4\n         S     R4,=F'8'            ADJUST FOR SNEAKINESS..\n         MVC   JOBNAME,CHKEY       MOVE IN JOBNAME\n         MVC   PROCNAME,CHSTEP     MOVE IN STEPNAME INVOK PROC\n         MVC   STEPNAME,CHPROCSN   MOVE IN STEPNAME OF PROC\n         DROP  R4\n         USING CSCB,R10            PUT BACK ADDRESSABILITY TO\n         A     R3,=F'1'            BUMP COUNT OF JOBS/STC\n         BAS   R6,COMPTIME         GO GET STEP/CPU TIME\n*                                    AND MEMORY STATUS\n         LA    R0,L'BUFFER\n         LA    R1,BUFFER\n         BAS   R14,PUTLNE          SHOVEL IT OUT\n         B     *+L'*(R15)          HOW COMPLETE?                   -EU-\n         B     *+L'*+4             +0 - CONTINUE                   -EU-\n         B     SETRC               +4 - INVALID OR ERROR           -EU-\n         MVI   BUFFER,C' '         CLEAR IT OUT\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\nNEXTPLS  BCT   R5,DOIT1            CHECK COUNT\n         B     CHKFIN              NO MORE..SPLIT\nDOIT1    LA    R9,4(0,R9)          INCR INTO ASVT\n         L     R8,0(0,R9)          LOAD ASCB ADDR\n         LTR   R8,R8               END OF ASCBS?\n         BZ    CHKFIN              YES->EXIT\n         TM    0(R9),X'80'         ASID ASSIGNED?\n         BO    NEXTPLS             NO-> TRY AGAIN.\n         B     LOOP2               YES->SEE IF WE LIKE IT\nCHKFIN   CLC   BUFFER(8),=CL8' '   ANYTHING TO WRITE?\n         BE    CLEANUP             NO-> SPLIT\n         LA    R0,L'BUFFER\n         LA    R1,BUFFER\n         BAS   R14,PUTLNE          SHOVEL IT OUT\n         B     *+L'*(R15)          HOW COMPLETE?                   -EU-\n         B     CLEANUP             +0 - CONTINUE                   -EU-\n         B     SETRC               +4 - INVALID OR ERROR           -EU-\nCLEANUP  TM    SWITCH,OUTEX        DID WE POKE ANYTHING\n         BZ    NOOUTPUT            NO..GRIPE AND SPLIT\n         CVD   R2,WRKD             CONVERT TO BIN\n         MVC   NINIT,=X'402020202120' MOVE IN THE PATTERN\n         ED    NINIT,WRKD+5        EDIT THE PATTERN\n         CVD   R3,WRKD             CONVERT TO BIN\n         MVC   NJOBS,=X'402020202120' MOVE IN THE PATTERN\n         ED    NJOBS,WRKD+5        EDIT THE PATTERN\n         LA    R0,L'MSGTSU\n         LA    R1,MSGTSU\n         B     SHOWIT                                              -EU-\nNOOUTPUT LA    R0,L'GRIPE\n         LA    R1,GRIPE\nSHOWIT   BAS   R14,PUTLNE          SHOVEL IT OUT\n         B     *+L'*(R15)          HOW COMPLETE?                   -EU-\n         B     *+L'*+4             +0 - RETURN                     -EU-\n*        ...                       +4 - INVALID OR ERROR           -EU-\n         SPACE 1                                                   -EU-\n*------- EXIT TSO                                                  -EU-\n         SPACE 1                                                   -EU-\nSETRC    LA    R15,8               SET RC=8 <===================== -EU-\n        $TSWXA 24,EXPAND=ONLY                                      -EU-\n         CH    R15,=H'16'          IS RETURN CODE HIGHER THAN 16?  -EU-\n         BNH   *+L'*+2             NO, LET'S GO                    -EU-\n         XR    R15,R15             YES, ZERO OUT REGISTER 15       -EU-\n        $XRET  CC=(R15),LV=AREAL,TYPE=RENT                         -EU-\n         EJECT\n*------- LOCAL SUBROUTINE TO CALCULATE JOB TIME AND CPU TIME,\n*        AND GEN SWAP REASON CODES/MEMORY STATUS.\n*        ENTER WITH BAS R6,COMPTIME (ALL REGISTERS PRESERVED)\n         SPACE 1\n*------- COMPUTE ELAPSED TRANSACTION TIME (JOB TIME FOR BATCH)\n         SPACE 1\nCOMPTIME STM   R4,R7,SAVEREGS      SAVE WORK REGISTERS\n         L     R4,RMCTPTR          POINTER TO THE RMCT.\n         L     R4,X'7C'(,R4)       PICK UP TIME OF DAY FROM RMCT. (SU)\n         L     R5,ASCBOUCB         GET ADDR OF OUCB FOR USER\n         L     R5,ASCBOUCB         GET ADDR OF OUCB FOR USER\n         USING OUCB,R5                                             -EU-\n         S     R4,OUCBTMO          SUBTRACT TRANSACTION START. (SU)-EU-\n         DROP  R5                                                  -EU-\n         SRDL  R4,32               MOVE INTO R5 FOR DIVIDE.\n         D     R4,=F'1024'         CONVERT TO SECONDS.\n         XR    R4,R4               IGNORE REMAINDER.\n         D     R4,=F'3600'         DIVIDE TO GET HOURS.\n         CVD   R5,WRKD             CONVERT HOURS -\n         UNPK  JOBHH,WRKD+6(2)       - TO PRINTABLE FORMAT.\n         OI    JOBHH+1,X'F0'       FIXUP SIGN BYTE.\n         MVI   JOBHH+2,C':'        SEPARATOR.\n         SRDL  R4,32               MOVE REMAINDER OVER FOR DIVIDE.\n         D     R4,=F'60'           GET MINUTES.\n         CVD   R5,WRKD             CONVERT MINUTES -\n         UNPK  JOBMM(2),WRKD+6(2)    - TO PRINTABLE FORMAT.\n         OI    JOBMM+1,X'F0'       FIXUP SIGN BYTE.\n         MVI   JOBMM+2,C':'        SEPARATOR.\n         CVD   R4,WRKD             REMAINDER IS SECONDS.\n         UNPK  JOBSS(2),WRKD+6(2)  CONVERT SEC TO PRINTABLE FORMAT.\n         OI    JOBSS+1,X'F0'       FIXUP SIGN.\n         SPACE 1\n*------- COMPUTE TOTAL CPU TIME USED IN THE CURRENT STEP.\n         SPACE 1\n         LM    R4,R5,ASCBEJST      LOAD ASCBEJST (CPU TASK TIME).\n         SRDL  R4,12               CONVERT TO MICRO-SECONDS.\n         LM    R6,R7,ASCBSRBT      LOAD ASCBSRBT (CPU SRB TIME).\n         SRDL  R6,12               CONVERT TO MICROSECONDS.\n         AR    R5,R7               TOTAL CPU TIME (LOW ORDER).\n         BNO   CPULBL1             BRANCH IF NO OVERFLOW ON ADD.\n         A     R4,=F'1'            OTHERWISE, ADD 1 TO HIGH ORDER.\nCPULBL1  AR    R4,R6               TOTAL CPU TIME (HIGH ORDER).\n         D     R4,=F'100'          DIVIDE TO GET SECONDS.\n         LTR   R5,R5               CHK TO SEE IF ANYTHING IS THERE\n         BNM   CPULBL2             BRANCH IF RESULT MAKES SENSE.\n         LA    R5,0                OTHERWISE, SET THE VALUE TO ZERO.\nCPULBL2  CVD   R5,WRKD             *\n         MVC   CPUTIME,=X'20202021204B2020' *\n         ED    CPUTIME-1(9),WRKD+3 *\n         SPACE 1\n*------- SWAP  REASON CODE (R8=ASCB,R7=OUCB,R4-6=WORK)\n         SPACE 1\n         L     R7,ASCBOUCB         GET ADDR OF OUCB\n         USING OUCB,R7\n         XR    R4,R4               PREPARE FOR IC INSTRUCTION.    V2M0\n         IC    R4,OUCBSRC          LOAD SU7 SWAP REASON CODE.     V2M0\n         SLL   R4,2                MULTIPLY BY FOUR FOR OFFSET    V2M0\n         LA    R4,SRCTABLE(R4)     POINT TO CORRECT ENTRY.        V2M0\n         MVC   MEMSTAT2,0(R4)      MOVE IN SWAP REASON CODE.      V2M0\n         SPACE 1\n*------- FIND  MEMORY POSITION (R8=ASCB,R7=OUCB,R4-6=WORK)\n         SPACE 1\n         MVC   MEMSTAT1,=CL2'IN'   DEFAULT POSITION IS SWAPPED-IN.V2M0\n         TM    OUCBSFL,OUCBNSW     SEE IF NON-SWAPPABLE MEMORY.   V2M0\n         BZ    QLCLBL1C            BRANCH IF NOT.\n         MVC   MEMSTAT1,=CL2'NS'   MOVE IN NON-SWAPPABLE INDIC.   V2M0\n         B     QLCEND              FINISHED FOR THIS MEMORY.\nQLCLBL1C TM    OUCBSFL,OUCBPVL     SEE IF PRIVILEDGED STATUS.     V2M0\n         BZ    QLCLBL1             BRANCH IF NOT.\n         MVC   MEMSTAT1,=CL2'PR'   MOVE IN PRIVILEDGED INDICATION.V2M0\n*                                  BUT CONTINUE IN CASE SWAPPED-OUT.\nQLCLBL1  TM    OUCBQFL,OUCBOFF     TEST FOR WAIT QUEUE.           V2M0\n         BZ    QLCLBL2             BRANCH IF NOT.\n         MVC   MEMSTAT1,=C'WT'     INDICATE WAIT STATUS.          V2M0\n         B     QLCEND              FINISHED FOR THIS MEMORY.      V2M0\nQLCLBL2  TM    OUCBQFL,OUCBOUT     TEST FOR OUT QUEUE.            V2M0\n         BZ    QLCLBL3             BRANCH IF NOT.\n         MVC   MEMSTAT1,=CL2'S '   INDICATE OUT STATUS.           V2M0\n         B     QLCEND              FINISHED FOR THIS MEMORY.\nQLCLBL3  TM    OUCBQFL,X'E0'       CHECK MISCELLANEOUS BITS.      V2M0\n         BZ    QLCEND              ASSUME MEMORY IS SWAPPED-IN.\n         MVC   MEMSTAT1,=CL2'<>'   INDICATE TRANSITIONING STATUS.\nQLCEND   LM    R4,R7,SAVEREGS      RESTORE REGISTERS\n         BR    R6                  AND RETURN..\n         DROP  R7,R8,R10,R11                                       -EU-\n         EJECT\n*=====================================================================*\n*        CONSTANTS                                                    *\n*=====================================================================*\n         SPACE 1\n*------- SWAP REASON CODES - FOUR BYTES PER ENTRY :\n*                  CODE  DESCRIPTION\n*                  ----  ----------------------------------------------\nSRCTABLE DC    CL4'    '\n         DC    CL4'TPUT' TERMINAL OUTPUT WAIT SWAP-OUT.\n         DC    CL4'TGET' TERMINAL INPUT WAIT SWAP-OUT.\n         DC    CL4'LONG' LONG WAIT CAUSED SWAP-OUT.\n         DC    CL4'PGS<' AUXILIARY STORAGE (PAGING SPACE) SHORTAGE\n*                        SWAP-OUT.\n         DC    CL4'RSS<' REAL STORAGE PAGEABLE POOL SHORTAGE SWAP-OUT.\n         DC    CL4'WAIT' MSO DETECTED WAIT SWAP-OUT.\n         DC    CL4'RQSW' REQSWAP SYSEVENT CAUSED SWAP-OUT.\n         DC    CL4'DENQ' CAP ENQ EXCHANGE SWAP-OUT.\n         DC    CL4'EXCH' CAP EXCHANGE SWAP BASED UPON RECOMMENDATION\n*                        VALUES.\n         DC    CL4'SWAP' CAP UNILATERAL SWAP-OUT.\n         SPACE 1\n*.....................................................................*\n*        MESSAGES                                                     *\n*.....................................................................*\n         SPACE 1\nGRIPE    DC    C'**NO INITIATORS OR JOBS RUNNING**'\n*                XXXXXXXX XXXXXXXX XXXXXXXX XX XXXX XX:XX:XX NNNNN.NN\nHEADING  DC    C'JOBNAME  STEPNAME PROCSTEP STATUS  JOB-TIME STEP-CPU SX\n               EC '\n         EJECT\n*.....................................................................*\n*        LITERAL POOL                                                 *\n*.....................................................................*\n         SPACE 1\n         LTORG\n         EJECT\n*=====================================================================*\n*        WORK-AREAS                                                   *\n*=====================================================================*\n         SPACE 1                                                   -EU-\nAREA     DSECT                     WORK-AREAS DESCRIPTION          -EU-\n         DS    18F                 LOCAL SAVE AREA                 -EU-\n         SPACE 1\n*.....................................................................*\n*        VARIABLES AREA                                               *\n*.....................................................................*\n         SPACE 1\nWRKD     DS    D\nRMCTPTR  DS    F\nSAVEREGS DS    4F\nSWITCH   DS    XL1\nOUTEX    EQU   X'80'               OUTPUT EXISTS..                 -EU-\n        $TEW$WA ,                                                  -EU-\n         SPACE 1\n*.....................................................................*\n*        MESSAGE AREA                                                 *\n*.....................................................................*\n         SPACE 1\n         DS    0F\nBUFFER   DS    0CL72                                               -EU-\nJOBNAME  DS    CL8                 JOBNAME\n         DS    CL1                 FILLER\nPROCNAME DS    CL8                 STEPNAME  OR STEPNAME INVOKING PROC\n         DS    CL1\nSTEPNAME DS    CL8                 STEPNAME FOR PROCS\n         DS    CL1\nMEMSTAT1 DS    CL2\n         DS    CL1\nMEMSTAT2 DS    CL4                 MEMORY STATUS = SWAPPED NS\n         DS    CL1\nJOBHH    DS    CL2                 FOR JOB  TIME HH:MM:SS\n         DS    CL1\nJOBMM    DS    CL2\n         DS    CL1\nJOBSS    DS    CL2\n         DS    CL1\nCPUTIME  DS    CL8                 FOR CPUTIME NNNNN.NN SECONDS\n         DS    CL28                                                -EU-\nMSGTSU   DS    0CL31                                               -EU-\n         DS    CL2                                                 -EU-\nNJOBS    DS    CL6\n         DS    CL6                                                 -EU-\nNINIT    DS    CL6\n         DS    CL11                                                -EU-\n         SPACE 1\nAREAL    EQU   (((*-AREA)+7)/8)*8  WORK-AREAS LENGTH               -EU-\n         EJECT\n*=====================================================================*\n*        SYSTEM DSECT'S                                               *\n*=====================================================================*\n         SPACE 1\n         PRINT NOGEN                                               -EU-\n        $TEW$DS CVT=YES                                            -EU-\nCSCB     DSECT\n         IEECHAIN\n         IHAASCB\n         IHAASVT\n         IRAOUCB                                                   -EU-\n         SPACE 1                                                   -EU-\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBS$": {"ttr": 20485, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x8f\\x00\\x88\\t\\x8f\\x10W\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-07T00:00:00", "modifydate": "1988-04-07T10:57:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//JOBS     JOB (........),'INSTALL  - JOBS -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=JOBS\n//LNK     EXEC PAJILKL,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   TSO020A\n  SETCODE AC(1)\n  NAME    JOBS(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JOBS@": {"ttr": 20487, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12o\\x00\\x88\\x12o\\x12V\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-05T00:00:00", "modifydate": "1988-05-05T12:56:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "1   06/08/86\n                                                      JOBS      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         TSO : JOBS COMMAND          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    This little gem will scurry around the ASCBs and CSCBs\n  ---------    to display the jobs running in the system. It gives\n               also the swap status and reason code from OUCB.\n               Note : it can be also started task.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "KUMX": {"ttr": 20489, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x931_\\x00\\x931_\\x161\\x01T\\x01T\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-11-11T00:00:00", "modifydate": "1993-11-11T16:31:00", "lines": 340, "newlines": 340, "modlines": 0, "user": "SYSPAJA"}, "text": "KUMX     TITLE 'KEYWORDS USER MASK FUNCTION.'\nKUMX     START 0\n         SPACE 1\n*- - - - - -  - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*                                                                    *\n* PURPOSE :    BUILD LOCK TSO-COMMAND TABLE (PRIVATE USE ONLY).      *\n* ---------                                                          *\n*                                                                    *\n* AUTHOR :     P.A. MOINIL                                           *\n* --------     COMPUTING CENTRE                                      *\n*              J.R.C. - ISPRA ESTABLISHMENT                          *\n*              21020 ISPRA (VA), ITALY                               *\n*                                                                    *\n*- - - - - -  - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n         PRINT NOGEN\n        $DEFREG\n        $XENT  BASE=(R11,R12)\n         PRINT GEN\n         EJECT\n        CALL   ISPLINK,(VDEF,LL,BUFFER,TYPEC,LENBUF),VL\n         LTR   R15,R15\n         BNZ   ERR1\n        CALL   ISPLINK,(VDEF,DL,LINENO,TYPEF,LEN4),VL\n         LTR   R15,R15\n         BNZ   ERR2\n        CALL   ISPLINK,(EDIT,LEN0,EDMAC),VL\n         LTR   R15,R15\n         BNZ   ERR3\n        CALL   ISPLINK,(EDIT,LEN0,EDDST),VL\n         LTR   R15,R15\n         BNZ   ERR4\n        CALL   ISPLINK,(EDIT,LEN0,EDBDS),VL\n         LTR   R15,R15\n         BNZ   ERR5\n         OC    LINENO,LINENO\n         BZ    ERR6\n         OC    COLNO,COLNO\n         BZ    ERR6\n         L     R3,RIGHTB\n         CL    R3,LENBUF\n         BH    ERR7\n        CALL   ISPLINK,(EDIT,LEN0,EDGLN),VL\n         LTR   R15,R15\n         BNZ   ERR8\n        CALL   ISPLINK,(EDIT,LEN0,EDMSK),VL\n         LTR   R15,R15\n         BNZ   ERR9\n         MVC   WKAREA,BUFFER\n         LA    R2,1\n         LA    R4,WKAREA-1\n         ALR   R3,R4\n         AL    R4,LEFTB\n         CLI   0(R4),C'*'\n         BE    *+L'*+8\n         CLI   0(R4),C' '\n         BNE   *+L'*+8\n         BXLE  R4,R2,*-8\n         B     ERR10\n         LR    R14,R4\n         BXLE  R4,R2,*+L'*+4\n         B     ERR11\n         CLI   0(R4),C' '\n         BNE   *-12\n         LR    R15,R4\n         SLR   R15,R14\n         CH    R15,=Y(L'KEYW-1)\n         BH    ERR11\n         BCT   R15,*+L'*+6\n         MVC   KEYW(*-*),0(R14)\n         EX    R15,*-6\n         BXLE  R4,R2,*+L'*+4\n         B     ERR10\n         CLI   0(R4),C' '\n         BE    *-12\n         LR    R14,R4\n         BXLE  R4,R2,*+L'*+4\n         B     ERR11\n         CLI   0(R4),C' '\n         BNE   *-12\n         LR    R15,R4\n         SLR   R15,R14\n         CH    R15,=Y(L'KEYW)\n         BH    ERR11\n         BCT   R15,*+L'*+6\n         MVC   KEYW+L'KEYW(*-*),0(R14)\n         EX    R15,*-6\n         BXLE  R4,R2,*+L'*+4\n         B     ERR10\n         CLI   0(R4),C' '\n         BE    *-12\n         LR    R14,R4\n         BXLE  R4,R2,*+L'*+4\n         B     ERR11\n         CLI   0(R4),C' '\n         BNE   *-12\n         LR    R15,R4\n         SLR   R15,R14\n         CH    R15,=Y(L'KEYW)\n         BH    ERR11\n         BCT   R15,*+L'*+6\n         MVC   KEYW+2*L'KEYW(*-*),0(R14)\n         EX    R15,*-6\n         MVI   SWDE1,2\n         MVI   SWDE2,2\n         MVI   SWDE3,2\n         XC    TSWRD(8),=XL8'A4C4CD2F1D9C7664'\n         OI    SWDE1,1\n         XI    SWDE2,3\n         OI    SWDE3,1\nAGAIN    L     R2,TSWRD\n         XR    R3,R3\n         LA    R8,15\n         LR    R6,R8\n         SLL   R6,28\n         XR    R7,R7\n         LR    R4,R2\n         SRL   R4,*-*\nSWDE1    EQU   *-1\n         XR    R2,R4\n         NR    R2,R6\n         STM   R2,R3,DBLWRD\n         BASR  R1,0\n         LM    R4,R5,TSWRD\n         NR    R2,R6\n         NR    R3,R7\n         SRDL  R6,4\n         NR    R4,R6\n         NR    R5,R7\n         SRDL  R2,4\n         XR    R4,R2\n         XR    R5,R3\n         SLDL  R2,*-*\nSWDE2    EQU   *-1\n         XR    R4,R2\n         XR    R5,R3\n         NR    R4,R6\n         NR    R5,R7\n         LR    R2,R4\n         LR    R3,R5\n         SRDL  R2,*-*\nSWDE3    EQU   *-1\n         XR    R4,R2\n         XR    R5,R3\n         NR    R4,R6\n         NR    R5,R7\n         LM    R2,R3,DBLWRD\n         OR    R2,R4\n         OR    R3,R5\n         STM   R2,R3,DBLWRD\n         BCTR  R8,R1\n         CLI   SWDE1,2\n         BE    *+L'*+22\n         NI    SWDE1,2\n         XI    SWDE2,3\n         NI    SWDE3,2\n         MVC   TSWRD,DBLWRD\n         B     AGAIN\n         MVI   SWDE1,*-*\n         MVI   SWDE2,*-*\n         MVI   SWDE3,*-*\n         CLI   DBLWRD,C' '\n         BNE   *+L'*+14\n         MVC   DBLWRD(L'DBLWRD-1),DBLWRD+1\n         MVI   DBLWRD+L'DBLWRD-1,C' '\n         B     *-18\n         LA    R1,PLST1\n         L     R15,=V(SETKEY)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR12\n         MVC   IDWRD,KEYW\n         LA    R1,PLST5\n         L     R15,=V(ENCIPH)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR13\n         LA    R1,PLST4\n         L     R15,=V(ENCIPH)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR13\n         LA    R1,PLST2\n         L     R15,=V(SETKEY)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR12\n         LA    R1,PLST4\n         L     R15,=V(ENCIPH)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR13\n         LA    R1,PLST3\n         L     R15,=V(SETKEY)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR12\n         LA    R1,PLST4\n         L     R15,=V(ENCIPH)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR13\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   BUFFER+9(2),=CL2'DC'\n         MVC   BUFFER+15(5),=CL5'XL16'''\n         LA    R1,BUFFER+20\n         LA    R2,IDWRD\n         LA    R3,L'IDWRD+L'DBLWRD\nLOOP     XR    R0,R0\n         IC    R0,0(R2)\n         STC   R0,1(R1)\n         SRL   R0,4\n         STC   R0,0(R1)\n         NC    0(2,R1),=XL2'0F0F'\n         TR    0(2,R1),=CL16'0123456789ABCDEF'\n         LA    R1,2(R1)\n         LA    R2,1(R2)\n         BCT   R3,LOOP\n         MVI   0(R1),C''''\n         MVC   4(2,R1),=CL2'<='\n         MVC   7(L'KEYW,R1),KEYW\n        CALL   ISPLINK,(EDIT,LEN0,EDPLN),VL\n         LTR   R15,R15\n         BNZ   ERR14\n         SPACE 1\n         XR    R10,R10             SET RETURN CODE\n         PRINT NOGEN\nLEAVE   $XRET  CC=(R10)            RETURN\n         PRINT GEN\n         EJECT\nERR1     MVC   MLOP,=CL8'BUFFER  '\n         B     ERRA\nERR2     MVC   MLOP,=CL8'... ... '\nERRA     MVC   MLFU,VDEF\n         B     ERRXR\nERR3     MVC   MLOP,=CL8'MACRO   '\n         B     ERRE\nERR4     MVC   MLOP,=CL8'CURSOR  '\n         B     ERRE\nERR5     MVC   MLOP,=CL8'BOUNDS  '\n         B     ERRE\nERR6     MVC   MLOP,=CL8'CURSOR  '\n         B     ERRB\nERR7     MVC   MLOP,=CL8'BUFFER  '\nERRB     MVC   MLFU,=CL8'CHECK   '\n         B     ERRC\nERR8     MVC   MLOP,=CL8'GET LINE'\n         B     ERRE\nERR9     MVC   MLOP,=CL8'MASKLINE'\n         B     ERRE\nERR10    MVC   MLOP,=CL8'BUFFER  '\n         MVC   MLFU,=CL8'EMPTY   '\n         B     ERRC\nERR11    MVC   MLOP,=CL8'ARGUMENT'\n         MVC   MLFU,=CL8'INVALID '\nERRC     XR    R15,R15\n         B     ERRXR\nERR12    MVC   MLOP,=CL8'SETKEY  '\n         B     ERRD\nERR13    MVC   MLOP,=CL8'ENCIPH  '\nERRD     MVC   MLFU,=CL8'ERROR   '\n         B     ERRXR\nERR14    MVC   MLOP,=CL8'PUT LINE'\nERRE     MVC   MLFU,EDIT\nERRXR    CVD   R15,DBLWRD          EDIT RETURN CODE RECEIVED\n         MVC   MSRC,=XL4'40202120'\n         ED    MSRC,DBLWRD+6\n        CALL   ISPLINK,(VREP,MS,MSL,MSV),VL\n         LR    R10,R15\n        CALL   ISPLINK,(VREP,ML,MLL,MLV),VL\n         SLL   R10,8\n         OR    R10,R15\n        CALL   ISPLINK,(SETM,MSGID),VL\n         SLL   R10,8\n         OR    R10,R15\n         LTR   R10,R10\n         BNZ   LEAVE\n         LA    R10,100             SET RETURN CODE\n         B     LEAVE\n         EJECT\n* ------ CONSTANTS AND WORK-AREAS.\n         SPACE 1\nIDWRD    DC    D'0'\nDBLWRD   DC    D'0'\n         SPACE 1\nVDEF     DC    CL8'VDEFINE '\nEDIT     DC    CL8'ISREDIT '\nVREP     DC    CL8'VREPLACE'\nSETM     DC    CL8'SETMSG  '\nMSGID    DC    CL8'ISRZ001 '\nTYPEC    DC    CL8'CHAR    '\nTYPEF    DC    CL8'FIXED   '\nLEN0     DC    F'0'\nLEN4     DC    F'4'\nLENBUF   DC    A(BUFLEN)\nMSL      DC    A(MSVL)\nMLL      DC    A(MLVL)\n         SPACE 1\nPLST1    DC    A(KEYW)\nPLST2    DC    A(KEYW+L'KEYW)\nPLST3    DC    A(KEYW+2*L'KEYW)\nPLST4    DC    A(DBLWRD,*+4,L'DBLWRD)\nPLST5    DC    A(IDWRD,*+4,L'IDWRD)\nKEYW     DC    3CL8' '\nTSWRD    DC    0XL8'0',F'-1',F'-1'\n         SPACE 1\nLINENO   DC    F'0'\nCOLNO    DC    F'0'\nLEFTB    DC    F'0'\nRIGHTB   DC    F'0'\nBUFFER   DC    CL80' '\nBUFLEN   EQU   *-BUFFER\nWKAREA   DC    CL(BUFLEN)' '\n         SPACE 1\nLL       DC    C'(BUFFER)'\nDL       DC    C'(LINENO,COLNO,LEFTB,RIGHTB)'\nMS       DC    C'(ZEDSMSG)'\nML       DC    C'(ZEDLMSG)'\n         SPACE 1\nEDMAC    DC    C'\u00a2MACRO NOPROCESS\u00a2'\nEDDST    DC    C'\u00a2(LINENO,COLNO) = CURSOR\u00a2'\nEDBDS    DC    C'\u00a2(LEFTB,RIGHTB) = BOUNDS\u00a2'\nEDGLN    DC    C'\u00a2(BUFFER) = LINE &&LINENO\u00a2'\nEDMSK    DC    C'\u00a2MASKLINE = \" \"\u00a2'\nEDPLN    DC    C'\u00a2LINE_AFTER &&LINENO = MASKLINE + (BUFFER)\u00a2'\n         SPACE 1\nMSV      DC    C'RC ='\nMSRC     DC    CL4' '\nMSVL     EQU   *-MSV\nMLV      DC    C'-- ERROR AT FUNCTION : '\nMLFU     DC    CL8' ',C' / OPERATION : '\nMLOP     DC    CL8' ',C' --'\nMLVL     EQU   *-MLV\n         EJECT\n         LTORG\n         SPACE 1\n         DROP  R11,R12 - - - - - - END OF BASE REGISTER ADDRESSABILITY\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KUMX$": {"ttr": 20495, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x11\\x07\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T11:07:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": "//KUMX     JOB (........),'INSTALL - K U M X -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//*       \"LOCK\" PRE-REQUISITE ISPF EDIT MACRO.                       *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                R050A90                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,MBR=KUMX\n//LNK     EXEC PAJILKI\n//SYSIN     DD *\n  INCLUDE SYSISP(ISPLINK)\n  INCLUDE SYSADD(R050A90)\n  ENTRY   KUMX\n  NAME    KUMX(R)\n/*\n//CPYP    EXEC PAJISPF,DST='->.ISPF.PANELS'\n//CM.SYSIN  DD *\n  COPY   OUTDD=TARGET,INDD=SOURCE\n  SELECT MEMBER=(PAJKUMXH)\n/*\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* EXECUTE THE STEP BELOW WITH PROCEDURE :                           *\n//*       \"PAJISPF\" IF YOUR TARGET ->.ISPF.CLISTS DATA-SET            *\n//*                                IS RECFM=FB AND LRECL=80, ELSE     *\n//*       \"PAJISPV\" IF YOUR TARGET ->.ISPF.CLISTS DATA-SET            *\n//*                                IS RECFM=VB AND LRECL=255.         *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//CPYS    EXEC PAJISPF,DST='->.ISPF.CLISTS'\n//CM.SYSIN  DD *\n  COPY   OUTDD=TARGET,INDD=SOURCE\n  SELECT MEMBER=((PAJCKUMX,KUMX))\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTAX": {"ttr": 20737, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x0f\\x00\\x944\\x0f\\x14\\x05\\x01h\\x01h\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-06T00:00:00", "modifydate": "1994-12-06T14:05:00", "lines": 360, "newlines": 360, "modlines": 0, "user": "SYSPAJA"}, "text": "LISTAX   TITLE 'LISTAX -- LIST ALL ALLOCATED DATA-SETS.'\nLISTAX   START 0\n         SPACE 1\n* FUNCTION :   THE LISTAX COMMAND LISTS ALL ALLOCATED DATA-SETS\n*              IN THE FOLLOWING FORMAT\n*              DDNAME   DISP         ORG DSNAME\n*              XXXXXXXX XXX,XXXX,XXXX XX XXXXXXXXXXXXXXXXXXXX...\n*\n* SYNTAX :     LISTAX\n*\n* ORIGIN :     EXTRACTED FROM TAPE CBT 89 FEB, FILE 300.\n*              LISTAX WAS WRITTEN BY BOB JUCH\n*                                    POSTAL DATA CENTER\n*                                    850 CHERRY AVE.\n*                                    SAN BRUNO CA. 94097\n*                                    415 876-9176\n*              ADAPTED BY MOINIL P.A.\n*\n* ATTRIBUTES : RENT\n         SPACE 1\nLISTAX  AMODE  24\nLISTAX  RMODE  24\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=@SIZE,TYPE=RENT\n         LR    R11,R13\n         USING @STORAGE,R11        STORAGE BASE REGISTER\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n         LA    R0,L'HEADER         POINT TO HEAD LINE\n         LA    R1,HEADER\n         BAS   R14,PUTLNE\n         LTR   R15,R15             HOW COMPLETE ?\n         BNZ   SETRC               ERROR\n         LA    R0,UNDRL            POINT TO UNDER LINE\n         LA    R1,UNDERL\n         BAS   R14,PUTLNE\n         LTR   R15,R15             HOW COMPLETE ?\n         BNZ   SETRC               ERROR\n         LA    R1,DYNRBP\n         USING S99RBP,R1\n         LA    R2,DYNRB\n         ST    R2,S99RBPTR\n         OI    S99RBPTR,S99RBPND\n         DROP  R1\n         USING S99RB,R2\n         MVI   S99RBLN,S99RBEND-S99RB\n         MVI   S99VERB,S99VRBIN\n         XC    S99FLAG1,S99FLAG1\n         XC    S99ERROR,S99ERROR\n         XC    S99INFO,S99INFO\n         LA    R1,DYNTUPL\n         ST    R1,S99TXTPP\n         XC    S99S99X,S99S99X     (OLD S99RSV01 FIELD)\n         XC    S99FLAG2,S99FLAG2\n         DROP  R2\n         USING S99TUNIT,R1\n         LA    R1,S99TUN04\n         LA    R2,DINRTDDN\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'8'\n         MVC   S99TUPAR(8),=CL80' '\n         ST    R1,S99TUP04\n         LA    R1,S99TUN05\n         LA    R2,DINRTDSN\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'44'\n         MVC   S99TUPAR(44),=CL80' '\n         ST    R1,S99TUP05\n         LA    R1,S99TUN06\n         LA    R2,DINRTMEM\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'8'\n         MVC   S99TUPAR(8),=CL80' '\n         ST    R1,S99TUP06\n         LA    R1,S99TUN07\n         LA    R2,DINRTSTA\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'1'\n         MVI   S99TUPAR,0\n         ST    R1,S99TUP07\n         LA    R1,S99TUN08\n         LA    R2,DINRTNDP\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'1'\n         MVI   S99TUPAR,0\n         ST    R1,S99TUP08\n         LA    R1,S99TUN09\n         LA    R2,DINRTCDP\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'1'\n         MVI   S99TUPAR,0\n         ST    R1,S99TUP09\n         LA    R1,S99TUN10\n         LA    R2,DINRTORG\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'2'\n         MVC   S99TUPAR(2),=H'0'\n         ST    R1,S99TUP10\n         LA    R1,S99TUN13\n         LA    R2,DINRTLST\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'1'\n         MVI   S99TUPAR,0\n         ST    R1,S99TUP13\n         LA    R1,S99TUN14\n         LA    R2,DINRTTYP\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'1'\n         MVI   S99TUPAR,0\n         ST    R1,S99TUP14\n         LA    R1,S99TUN15\n         LA    R2,DINRELNO\n         STH   R2,S99TUKEY\n         MVC   S99TUNUM,=H'1'\n         MVC   S99TULNG,=H'2'\n         MVC   S99TUPAR(2),=H'0'\n         ST    R1,S99TUP15\n         OI    S99TUP15,S99TUPLN\n         DROP  R1\n         XR    R3,R3               CLEAR FOR COUNTER\n         B     SETRLN\nTOP      MVC   DDNAME(2),=H'8'\n         MVC   DDNAME+2(8),=CL80' '\n         MVC   DSNAME(2),=H'44'\n         MVC   DSNAME+2(44),=CL80' '\n         MVC   MEMBER(2),=H'8'\n         MVC   MEMBER+2(8),=CL80' '\n         MVI   STATUS,0\n         MVI   NDISP,0\n         MVI   CDISP,0\n         MVC   DSORG(2),=H'0'\n         MVI   LASTENT,0\n         MVI   DSTYPE,0\nSETRLN   AH    R3,=H'1'            ADD FOR REQUEST NUMBER\n         STH   R3,RELNO            PUT IT IN TEXT UNIT\n         LA    R1,DYNRBP           POINT TO REQUEST BLOCK\n        DYNALLOC ,                 GO DO IT\n         MVC   OUTLINE(L'OUTLINE),=CL80' '\n         MVC   OUTDDN,DDNAME+2     MOVE DDNAME TO OUTPUT LINE\n         CLI   DSTYPE,X'00'        NORMAL DATA-SET ?\n         BE    MOVEDSN\n         CLI   DSTYPE,X'80'        ALLOC TO DUMMY ?\n         BE    NULLDSN\n         CLI   DSTYPE,X'40'        ALLOC TO TERM ?\n         BE    TERMDSN\n         CLI   DSTYPE,X'20'        ALLOC TO SYSIN ?\n         BE    SYSIDSN\n         CLI   DSTYPE,X'10'        ALLOC TO SYSOUT ?\n         BE    SYSODSN\n         MVC   OUTDSN(9),=CL9'*UNKNOWN*'\n         LA    R0,OUTDSN-OUTLINE+9 SET REDUCED LINE LENGTH\n         B     CHKSTAT\nNULLDSN  MVC   OUTDSN(8),=CL8'NULLFILE'\n         LA    R0,OUTDSN-OUTLINE+8 SET REDUCED LINE LENGTH\n         B     CHKSTAT\nTERMDSN  MVI   OUTDSN,C'*'\n         LA    R0,OUTDSN-OUTLINE+1 SET SHORT LINE LENGTH\n         B     CHKSTAT\nSYSIDSN  MVC   OUTDSN(5),=CL5'SYSIN'\n         LA    R0,OUTDSN-OUTLINE+5 SET REDUCED LINE LENGTH\n         B     CHKSTAT\nSYSODSN  MVC   OUTDSN(6),=CL6'SYSOUT'\n         LA    R0,OUTDSN-OUTLINE+6 SET REDUCED LINE LENGTH\n         B     CHKSTAT\nMOVEDSN  MVC   OUTDSN,DSNAME+2     MOVE DSNAME\n         MVC   OUTMEM,MEMBER+2     MOVE MEMBER NAME\n         LA    R0,L'OUTLINE        SET FULL LINE LENGTH\nCHKSTAT  MVC   OUTSTA(L'OUTSTA),=CL80' '\n         LA    R2,OUTSTA\n         CLI   STATUS,X'01'        SEE IF OLD\n         BNE   *+L'*+6\n         MVC   0(3,R2),=CL3'OLD'\n         CLI   STATUS,X'02'        SEE IF MOD\n         BNE   *+L'*+6\n         MVC   0(3,R2),=CL3'MOD'\n         CLI   STATUS,X'04'        SEE IF NEW\n         BNE   *+L'*+6\n         MVC   0(3,R2),=CL3'NEW'\n         CLI   STATUS,X'08'        SEE IF SHR\n         BNE   *+L'*+6\n         MVC   0(3,R2),=CL3'SHR'\n         CLI   0(R2),C' '\n         BE    *+L'*+4\n         LA    R2,3(R2)\n         MVI   0(R2),C','\n         LA    R2,1(R2)\n         CLI   NDISP,X'01'         SEE IF UNCATLG\n         BNE   *+L'*+6\n         MVC   0(4,R2),=CL4'UNCT'\n         CLI   NDISP,X'02'         SEE IF CATLG\n         BNE   *+L'*+6\n         MVC   0(4,R2),=CL4'CTLG'\n         CLI   NDISP,X'04'         SEE IF DELETE\n         BNE   *+L'*+6\n         MVC   0(3,R2),=CL3'DEL'\n         CLI   NDISP,X'08'         SEE IF KEEP\n         BNE   *+L'*+6\n         MVC   0(4,R2),=CL4'KEEP'\n         CLI   NDISP,X'10'         SEE IF PASS\n         BNE   *+L'*+6\n         MVC   0(4,R2),=CL4'PASS'\n         CLI   0(R2),C' '\n         BNE   *+L'*+6\n         MVC   0(4,R2),=CL4'????'  NO DISP ?\n         CLI   3(R2),C' '\n         BNE   *+L'*+2\n         BCTR  R2,0\n         MVI   4(R2),C','\n         LA    R2,5(R2)\n         CLI   CDISP,X'01'         SEE IF UNCATLG\n         BNE   *+L'*+6\n         MVC   0(4,R2),=CL4'UNCT'\n         CLI   CDISP,X'02'         SEE IF CATLG\n         BNE   *+L'*+6\n         MVC   0(4,R2),=CL4'CTLG'\n         CLI   CDISP,X'04'         SEE IF DELETE\n         BNE   *+L'*+6\n         MVC   0(3,R2),=CL3'DEL'\n         CLI   CDISP,X'08'         SEE IF KEEP\n         BNE   *+L'*+6\n         MVC   0(4,R2),=CL4'KEEP'\n         CLI   CDISP,X'10'         SEE IF PASS\n         BNE   *+L'*+6\n         MVC   0(4,R2),=CL4'PASS'\n         CLI   0(R2),C' '\n         BNE   *+L'*+6\n         BCTR  R2,0                NO DISP\n         MVI   0(R2),C' '\n         LA    R2,LNEOUT\n         TM    DSORG,DCBDSGPS      SEE IF PS\n         BZ    *+L'*+8\n         MVC   OUTORG,=CL2'PS'\n         BR    R2\n         TM    DSORG,DCBDSGPO      SEE IF PO\n         BZ    *+L'*+8\n         MVC   OUTORG,=CL2'PO'\n         BR    R2\n         TM    DSORG+1,DCBACBM     SEE IF VSAM\n         BZ    *+L'*+8\n         MVC   OUTORG,=CL2'VS'\n         BR    R2\n         TM    DSORG,DCBDSGDA      SEE IF DA\n         BZ    *+L'*+8\n         MVC   OUTORG,=CL2'DA'\n         BR    R2\n         TM    DSORG,DCBDSGIS      SEE IF ISAM\n         BZ    *+L'*+8\n         MVC   OUTORG,=CL2'IS'\n         BR    R2\n         TM    DSORG,DCBDSGCX      SEE IF CX\n         BZ    *+L'*+8\n         MVC   OUTORG,=CL2'CX'\n         BR    R2\n         TM    DSORG+1,DCBDSGGS    SEE IF GS\n         BZ    *+L'*+8\n         MVC   OUTORG,=CL2'GS'\n         BR    R2\n         TM    DSORG+1,DCBDSGTX    SEE IF TX\n         BZ    *+L'*+8\n         MVC   OUTORG,=CL2'TX'\n         BR    R2\n         TM    DSORG+1,DCBDSGTQ    SEE IF TQ\n         BZ    *+L'*+8\n         MVC   OUTORG,=CL2'TQ'\n         BR    R2\n         TM    DSORG+1,DCBDSGTR    SEE IF TR\n         BZ    *+L'*+8\n         MVC   OUTORG,=CL2'TR'\n         BR    R2\n         MVC   OUTORG,=CL2'**'\nLNEOUT   LA    R1,OUTLINE\n         BAS   R14,PUTLNE\n         LTR   R15,R15             HOW COMPLETE ?\n         BNZ   SETRC               ERROR\n         TM    LASTENT,X'80'       WAS THIS LAST ENTRY\n         BZ    TOP\n         XR    R2,R2               RC=0 -------------------------------\nLEAVE   $XRET  CC=(R2),LV=@SIZE,TYPE=RENT\nSETRC    LA    R2,16               RC=16 ------------------------------\n         B     LEAVE\n         EJECT\n*------- CONSTANTS\nHEADER   DC    C'DDNAME   DISP         ORG DSNAME'\nUNDERL   DC    C'-------- ------------- -- '\n         DC    44C'-'\nUNDRL    EQU   *-UNDERL\n         SPACE 1\n        LTORG\n         EJECT\n@STORAGE DSECT\n         DS    18F                 S.A.\n        $TEW$WA\n         SPACE 1\nDYNRBP   DS    F\nDYNRB    DS    0F,((((S99RBEND-S99RB)+3)/4)*4)X\n         SPACE 1\nDYNTUPL  DS    0F\nS99TUP04 DS    F\nS99TUP05 DS    F\nS99TUP06 DS    F\nS99TUP07 DS    F\nS99TUP08 DS    F\nS99TUP09 DS    F\nS99TUP10 DS    F\nS99TUP13 DS    F\nS99TUP14 DS    F\nS99TUP15 DS    F\n         SPACE 1\nS99TUN04 DS    2H\nDDNAME   DS    H,CL8\nS99TUN05 DS    2H\nDSNAME   DS    H,CL44\nS99TUN06 DS    2H\nMEMBER   DS    H,CL8\nS99TUN07 DS    3H\nSTATUS   DS    XL1\nS99TUN08 DS    3H\nNDISP    DS    XL1\nS99TUN09 DS    3H\nCDISP    DS    XL1\nS99TUN10 DS    3H\nDSORG    DS    XL2\nS99TUN13 DS    3H\nLASTENT  DS    XL1\nS99TUN14 DS    3H\nDSTYPE   DS    XL1\nS99TUN15 DS    3H\nRELNO    DS    H\n         SPACE 1\nOUTLINE  DS    0CL79 ------------- COLS\nOUTDDN   DS    CL8                 1-8\n         DS    C                   9\nOUTSTA   DS    CL13                10-22\n         DS    C                   23\nOUTORG   DS    CL2                 24-25\n         DS    C                   26\nOUTDSN   DS    CL44                27-70\n         DS    C                   71\nOUTMEM   DS    CL8                 72-79\n         SPACE 1\n@SIZE    EQU   (((*-@STORAGE)+7)/8)*8\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS\n        IEFZB4D0\n        IEFZB4D2\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTAX$": {"ttr": 20744, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x147\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:37:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//LISTAX   JOB (........),'INSTALL  - LISTAX -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=LISTAX\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   LISTAX\n  NAME    LISTAX(R)\n/*\n//HLP     EXEC PAJHELP,MBR=LISTAXH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTAX@": {"ttr": 20746, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14U\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:55:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/07/90\n                                                      LISTAX    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         LISTAX TSO command          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Command name :      LISTAX\n  Author :            Bob Juch, Postal Data Center\n                      850 Cherry Ave.\n                      San Bruno CA. 94097\n                      415 876-9176\n  Origin :            Extracted from tape CBT 89 FEB, file 300\n                      Adapted by MOINIL P.A.\n  Function :          The LISTAX command lists all allocated data-sets\n                      in the following format\n                      DDNAME   DISP         ORG DSNAME\n                      XXXXXXXX XXX,XXXX,XXXX XX XXXXXXXXXXXXXXXXXXXX...\n\n  Syntax :\n  --------------------------------------------------------------------\n  Command    Operands\n  --------------------------------------------------------------------\n  LISTAX\n  --------------------------------------------------------------------\n\n  Operands :\n     Required - None\n     Default  - None\n\n  Return codes :  0 - list done.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTAXH": {"ttr": 20748, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14U\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:55:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=LISTAX\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  the LISTAX command lists all allocated data-sets in\n               the following format\n               DDNAME   DISP         ORG DSNAME\n               XXXXXXXX XXX,XXXX,XXXX XX XXXXXXXXXXXXXXXXXXXX...\n)X SYNTAX :    LISTAX\n)O OPERANDS :  Required - None\n               Default  - None\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTENQ": {"ttr": 20750, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\tQ\\x01\\x1a\\x01\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T09:51:00", "lines": 282, "newlines": 282, "modlines": 0, "user": "SYSPAJA"}, "text": "LENQ     TITLE 'TSO - LIST ENQS FOR A JOB OR USERID COMMAND.'\nLISTENQ  START 0\n         SPACE 1\n* PURPOSE :    THIS COMMAND SHOWS THE DATA-SETS ALLOCATIONS FOR A\n* ---------    JOB OR USERID.\n*              COMMAND EXAMPLES :\n*              LISTENQ ABCDEFG   - TO LOCATE ENQS FOR A JOB OR USERID.\n*              LISTENQ XXXX USER - TO LOCATE ONLY ENQS FOR A USERID.\n*              LISTENQ XXXX JOB  - TO LOCATE ONLY ENQS FOR A JOB.\n*              LISTENQ *         - TO LOCATE ENQS OF USERID ISSUING CP.\n*              RESPONSES EXAMPLES :\n*              ABC.THIS.THAT                      ALLOCATED SHR\n*              XYZ.THE.OTHER.THING                ALLOCATED OLD\n*              THIS.IS.A.NOTHER                   WAITING   OLD\n* RETURN CODES :    0 - JOB OR USER FOUND IN EXECUTION, CONFLICTS MAY\n* --------------        OR MAY NOT HAVE BEEN FOUND.\n*                   4 - JOB OR USER WAS NOT FOUND IN EXECUTION.\n*                   8 - PARSE ERROR OCCURRED.\n*                  12 - COMMAND COULD NOT FIND THE DSN QCB CHAIN.\n*                  16 - COMMAND ERROR DETECTED.\n* AUTHOR :     ORIGINAL VERSION FROM CBT TAPE (FILE 141).\n* --------     THIS IS THE SP1.3 VERSION OF LISTENQ.\n*              MODIFIED BY : RAVARANI N. - MOINIL P.A.\n*                            COMPUTING CENTRE\n*                            J.R.C. - ISPRA ESTABLISHMENT\n*                            21020 ISPRA (VA), ITALY\n         SPACE 1\n        $DEFREG\nSIAL     EQU   12*1024             SCAN INFO AREA LENGTH\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R9,R13              SET WORK AREAS ADDRESSABILITY\n         USING WRKDSECT,R9\n        $TEW$EC MSG=PUTMSG,ERR=CMDERR,PUT=PUTLNE\n        $TEW$PP PARM=PARMLST,REG=R3,ERR=PARSERR\n         MVC   JOBNAME,=CL8' '     CLEAR JOBNAME\n         L     R1,JOBN             ADDRESS OF JOBNAME\n         LH    R2,JOBN+4           GET LENGTH OF JOBNAME\n         BCT   R2,*+L'*+6\n         MVC   JOBNAME(*-*),0(R1)  <<EXECUTED>>\n         EX    R2,*-6              MOVE JOBNAME\n         MVI   SWITCH,0\n         CLI   JOBNAME,C'*'        CHECK FOR * (OR USERID THATS ON)\n         BNE   SETUFLAG\n         L     R2,#TSCPPL\n         USING CPPL,R2             CPPL ADDRESSABILITY\n         L     R1,CPPLPSCB         -> PSCB\n         DROP  R2\n         USING PSCB,R1\n         XR    R2,R2\n         IC    R2,PSCBUSRL         LENGTH OF USERID\n         BCT   R2,*+L'*+6\n         MVC   JOBNAME(*-*),PSCBUSER <<EXECUTED>>\n         EX    R2,*-6              MOVE USERID\n         OI    SWITCH,RQSTUSER     ONLY TAKE USER\n         B     RLSESA\n         DROP  R1\nSETUFLAG CLI   USER+1,1            WAS USER SPECIFIED?\n         BNE   *+L'*+4\n         OI    SWITCH,RQSTUSER\n         CLI   JOB+1,1             WAS JOB SPECIFIED?\n         BNE   RLSESA\n         OI    SWITCH,RQSTJOB\n         DROP  R3\nRLSESA  IKJRLSA #TSANSW\n         SPACE 1\n*------- CVT -> ASVT -> ASCB -> CSCB\n*        (BOY WHAT FUN ...)\n         SPACE 1\n         L     R2,CVTPTR           -> CVT\n         USING CVT,R2\n         L     R3,CVTASVT          -> ASVT\n         DROP  R2\n         USING ASVT,R3\n         LA    R7,ASVTFRST-4       -> ENTRY ADDS (MINUS 4)\n         L     R8,ASVTMAXU         -> # OF ASCBS\n         DROP  R3\nCHKASID  LA    R7,4(R7)            ENTRY + 4\n         TM    0(R7),ASVTAVAI      IN USE?\n         BO    NXTASID             NO... DON'T LOOK AT IT THEN\n         L     R6,0(R7)            -> ASCB\n         USING ASCB,R6\n         L     R5,ASCBCSCB         -> POSSIBLE CSCB\n         LTR   R5,R5               TEST FOR POSITIVE\n         BNP   *+L'*+8             NO -> TRY NEXT ONE\n         TM    28(R5),X'03'        IS THIS A USER OR JOB?\n         BM    TJBNM               YES\n         L     R5,ASCBJBNI         TRY NEXT ONE\n         LTR   R5,R5               ONE MORE TIME\n         BNP   *+L'*+8\n         S     R5,=F'8'            ADJUST POINTER BACK SOME\n         B     GOTCSCB\n         L     R5,ASCBJBNS         ONE LAST TRY\n         LTR   R5,R5               CROSS YOUR FINGERS\n         BNP   NXTASID             OH WELL... TRY NEXT ASID\n         S     R5,=F'16'           GOT TO ADJUST THIS ONE TOO\nGOTCSCB  TM    28(R5),X'03'        IS THIS A USER OR JOB?\n         BNM   NXTASID             NO...\nTJBNM    CLC   8(8,R5),JOBNAME\n         BNE   NXTASID\n         TM    SWITCH,RQSTUSER     DID THEY ONLY WANT A USER?\n         BZ    *+L'*+12            NO, CHECK FOR JOB ONLY\n         TM    28(R5),X'01'        IS IT TSU?\n         BZ    NXTASID             NO, SKIP IT EVEN IF IT COMPARED\n         B     GOTASID\n         TM    SWITCH,RQSTJOB      DID THEY ONLY WANT A JOB?\n         BZ    GOTASID             NO, THEN TAKE WHAT WE GOT\n         TM    28(R5),X'02'        IS IT JOB?\n         BO    GOTASID             YES, WE GOT WHAT WE WANT\nNXTASID  BCT   R8,CHKASID          GO FOR NEXT ASID\n         B     NOTFND              JOB DOESN'T EXIST\nGOTASID  MVC   ASID,ASCBASID       SAVE THE ASID\n         XC    TKN,TKN             ASSURE TOKEN ZERO\n         DROP  R6\nDOGQ     LA    R13,SCANSAVE        ADDRESS GQSCAN SAVE AREA\n         XC    0(18*4,R13),0(R13)\n         MVC   SCAN(LSCAN),SCANP\n         LH    R8,ASID             GET THE ASID # FOR THE JOB\n         LA    R7,TABLE\n        GQSCAN AREA=((R7),),TOKEN=TKN,SYSNAME=(,(R8)),MF=(E,SCAN)\n         LR    R13,R9              RESTORE MAIN SAVE AREA\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     SEARCH              +0 - O.K.\n         B     CODE04              +4 - NO RESOURCES MATCHED REQUEST\n         B     SEARCH              +8 - GQSCAN AREA TOO SHORT\n         B     CODE0C              +12 - ERROR WHILE PROCESSING\n         B     CODE10              +16 - INVALID SYSNAME\n         B     CODE14              +20 - GQSCAN AREA TOO SHORT\n         SPACE 1\nCODE04   LA    R0,L'CODE04M        NO RESOURCES FOUND\n         LA    R1,CODE04M\n         B     GQERR\nCODE0C   LA    R0,L'CODE0CM        ERROR IN GQSCAN\n         LA    R1,CODE0CM\n         B     GQERR\nCODE10   LA    R0,L'CODE10M        INVALID SYSNAME\n         LA    R1,CODE10M\n         B     GQERR\nCODE14   LA    R0,L'CODE14M        GQSCAN AREA TOO SHORT\n         LA    R1,CODE14M\nGQERR    BAS   R14,PUTLNE\n         B     *+L'*+4             +0 - NORMAL COMPLETION\n         B     CMDERR              +4 - ERROR\n         LA    R15,12              RC=12 ------------------------------\n         B     QUIT\n         SPACE 1\nSEARCH   LTR   R6,R1               DID SOME DUMMY ASK IF HIS JOB WAS\n         BNP   BYEBYE                   WAITING EVEN IF IT DIDN'T\n*                                       ALLOCATE ANYTHING\n         STCM  R0,B'1111',RIBLNGTH STORE RIB AND RIBE LENGTH\n         LA    R7,TABLE            FIRST RIB, R6 : NO. OF RIBS\n         USING RIB,R7\nRIBLOOP  CLC   RIBQNAME,=CL8'SYSDSN' IS THIS A DSNAME RIB?\n         BNE   BUMPRIB\n         L     R5,RIBNRIBE         NUMBER OF RIBE'S\n         LTR   R5,R5\n         BNP   BUMPRIB             NO RIBE'S SUPPLIED\n         OI    SWITCH,EFLAG        SHOW WE GOT ONE\n         MVI   WAITLINE,C' '\n         MVC   WAITLINE+1(L'WAITLINE-1),WAITLINE\n         LR    R8,R7               GET RIB POINTER\n         AH    R8,RIBLNGTH         POINT TO RIB VARIABLE SECTION\n         USING RIBVAR,R8\n         XR    R1,R1\n         IC    R1,RIBRNMLN         RNAME LENGTH\n         BCT   R1,*+L'*+6          -1 FOR MOVE\n         MVC   WAITDSN(*-*),RIBRNAME <<EXECUTED>>\n         EX    R1,*-6              GET THE DSNAME\n         DROP  R8\n         AH    R8,RIBVLEN          POINT TO FIRST RIBE\n         USING RIBE,R8\nNEXTRIBE TM    RIBERFLG,RIBETYPE   WHAT TYPE OF HOLD?\n         BZ    *+L'*+10\n         MVC   HOWTYPE,=CL3'SHR'   TYPE OF WAIT = SHARE\n         B     *+L'*+6\n         MVC   HOWTYPE,=CL3'OLD'   TYPE OF WAIT = EXCLUSIVE\n         TM    RIBESFLG,RIBESTAT   DO I WAIT OR HOLD?\n         BZ    *+L'*+10\n         MVC   WHATMSG,=CL10'ALLOCATED' I HAVE IT\n         B     *+L'*+6\n         MVC   WHATMSG,=CL10'WAITING  ' I WANT IT\n         DROP  R8\n         LA    R0,L'WAITLINE       AND PUT IT\n         LA    R1,WAITLINE\n         BAS   R14,PUTLNE\n         B     *+L'*+4             +0 - NORMAL COMPLETION\n         B     CMDERR              +4 - ERROR\n         AH    R8,RIBELENG         POINT TO NEXT RIBE\n         BCT   R5,NEXTRIBE\nBUMPRIB  XR    R14,R14\n         L     R15,RIBNRIBE        NUMBER OF RIBE'S\n         LTR   R15,R15\n         BNP   *+L'*+8             NO RIBE'S SUPPLIED\n         AH    R14,RIBELENG        ADD RIBE LENGTH\n         BCT   R15,*-4             ADD TIMES NO. OF RIBE'S\n         AH    R14,RIBLNGTH        ADD LENGTH OF RIB\n         AH    R14,RIBVLEN         ADD LENGTH OF VARIABLE SECTION\n         AR    R7,R14              POINT TO NEXT RIB\n         BCT   R6,RIBLOOP          LOOP UNTIL NO MORE RIBS\n         DROP  R7\n         CLC   TKN,=F'0'           ANY MORE RIBS NOT YET SCANNED\n         BNE   DOGQ                YES\nBYEBYE   TM    SWITCH,EFLAG        WAS THERE ONE?\n         BO    LEAVE               YES, PRINTED SOMETHING\n         LA    R0,L'NUTTIN         TELL THEM NO D.S. ALLOCATED...\n         LA    R1,NUTTIN\n         BAS   R14,PUTLNE\n         B     LEAVE               +0 - NORMAL COMPLETION\n*                                  +4 - ERROR\nCMDERR   LA    R15,16              RC=16 ------------------------------\n         B     QUIT\nLEAVE    XR    R15,R15             RC=0 -------------------------------\nQUIT    $XRET  CC=(R15),LV=WRKL,TYPE=RENT\nNOTFND   LA    R0,L'NOTF\n         LA    R1,NOTF\n         BAS   R14,PUTLNE\n         B     *+L'*+4             +0 - NORMAL COMPLETION\n         B     CMDERR              +4 - ERROR\n         LA    R15,4               RC=4 -------------------------------\n         B     QUIT\nPARSERR  LA    R15,8               RC=8 -------------------------------\n         B     QUIT\n         EJECT\n*------- SKELETONS, MESSAGES AND CONSTANTS\n         SPACE 1\n         PRINT NOGEN\nSCANP   GQSCAN AREA=(,SIAL),SCOPE=ALL,SYSNAME=(0,),REQLIM=MAX,MF=L\n         PRINT GEN\nLSCAN    EQU   *-SCANP\n         SPACE 1\nNOTF     DC    C' -> JOB OR USER NOT FOUND IN EXECUTION'\nNUTTIN   DC    C' -> JOB OR USER HAS NO DATA-SETS ALLOCATED'\nCODE04M  DC    C' -> JOB OR USER HAS NO RESOURCES ENQUEUED'\nCODE0CM  DC    C' -> GQSCAN : ERROR WHILE PROCESSING'\nCODE10M  DC    C' -> GQSCAN : \"SYSNAME\" IS INVALID'\nCODE14M  DC    C' -> GQSCAN : \"AREA\" TOO SHORT'\n         SPACE 1\n        LTORG\n         SPACE 1\n        PRINT  NOGEN\nPARMLST IKJPARM\nJOBN    IKJIDENT 'JOBNAME',FIRST=ANY,OTHER=ANY,MAXLNTH=8,              1\n               PROMPT='JOB-NAME OR USER-ID'\nUSER    IKJKEYWD\n        IKJNAME 'USER'\nJOB     IKJKEYWD\n        IKJNAME 'JOB'\n        IKJENDP\n        PRINT  GEN\n         EJECT\n*------- WORK-AREAS DESCRIPTION\n         SPACE 1\nWRKDSECT DSECT\nSVA      DS    18F                 SAVE AREA\nSCANSAVE DS    18F                 18 WORDS SAVE AREA REQ FOR GQSCAN\n        $TEW$WA\nSCAN     DS    0F,(LSCAN)X\nTKN      DS    F\nJOBNAME  DS    CL8\nRIBLNGTH DS    H                   RIB LENGTH\nRIBELENG DS    H                   RIBE LENGTH\nWAITLINE DS    0CL62,CL2\nWAITDSN  DS    CL44,CL2\nWHATMSG  DS    CL10,CL1\nHOWTYPE  DS    CL3\nASID     DS    H\nSWITCH   DS    XL1\nEFLAG    EQU   X'01'\nRQSTUSER EQU   X'10'\nRQSTJOB  EQU   X'20'\nTABLE    DS    0F,(SIAL)X          SCAN INFO AREA\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS\n        IHAASVT\n        IHAASCB\n        ISGRIB\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTENQ$": {"ttr": 20997, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//LISTENQ  JOB (........),'INSTALL  -LISTENQ-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=LISTENQ\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  NAME    LISTENQ(R)\n/*\n//HLP     EXEC PAJHELP,MBR=LISTENQH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTENQ@": {"ttr": 20999, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x002\\x002\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      LISTENQ   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    LIST ENQ'S FOR A JOB OR USERID   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n   Function :  The LISTENQ command returns information reguarding\n   ----------  allocations for a JOB or USERID. It tells you what\n               data-set(s) the job has allocated, and how it is\n               allocated (OLD or SHR). It will also tell what\n               data-sets the job or user may be waiting on.\n          Outputs :\n               XYZ.ABC.DEF               ALLOCATED SHR\n                    means the job scanned has XYZ.ZBC.DEF SHR.\n               ABC.DEF.GHI               ALLOCATED OLD\n                    means the job scanned has ABC.DEF.GHI OLD.\n               ABC.TRS.XYZ               WAITING   SHR.\n                    means the job scanned wants data-set ABC.TRS.XYZ\n                    allocated share, but the data-set is currently\n                    allocated OLD to another job.\n          Return codes :\n                0 - indicates job or user found in execution.\n                    All conflicts (if any) have been listed.\n                4 - indicates job or user not found in execution.\n                8 - indicates PARSE error occured.\n               12 - indicates command could not find the DSN QCB chain.\n               16 - indicates error occurred, re-enter command.\n\n   Syntax :    LISTENQ J-U USER JOB\n   --------\n\n   Operands :\n   ----------\n  J-U (required) :  the JOBname or USERid to be scanned.\n                    USERid can be specified as * if you wish to scan\n                    your own USERid.\n  USER (optional) : specifies that only TSO users are to be searched if\n                    a job and TSO session have the same name.\n  JOB (optional) :  specifies that only jobs are to be searched if a\n                    job and TSO session have the same name.\n  Examples :\n       (1) LISTENQ XXYYZZ   - this scans for the job or USERid XXXZXY\n                              if in execution.\n       (2) LISTENQ JJJ JOB  - this scans only for the job JJJ if in\n                              execution.\n       (3) LISTENQ UUU USER - this scans only for the user UUU.\n       (4) LISTENQ *        - scan for the user issuing the command.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTENQH": {"ttr": 21001, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00(\\x00(\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=LISTENQ\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  THE \"LISTENQ\" COMMAND RETURNS INFORMATION REGUARDING\n               ALLOCATIONS FOR A JOB OR USERID. IT TELLS YOU WHAT\n               DATA-SET(S) THE JOB HAS ALLOCATED, AND HOW IT IS\n               ALLOCATED (OLD OR SHR). IT WILL ALSO TELL WHAT\n               DATA-SETS THE JOB OR USER MAY BE WAITING ON.\n          OUTPUTS :\n               XYZ.ABC.DEF               ALLOCATED SHR\n                    MEANS THE JOB SCANNED HAS 'XYZ.ZBC.DEF' SHR.\n               ABC.DEF.GHI               ALLOCATED OLD\n                    MEANS THE JOB SCANNED HAS 'ABC.DEF.GHI' OLD.\n               ABC.TRS.XYZ               WAITING   SHR.\n                    MEANS THE JOB SCANNED WANTS DATA-SET 'ABC.TRS.XYZ'\n                    ALLOCATED SHARE, BUT THE DATA-SET IS CURRENTLY\n                    ALLOCATED OLD TO ANOTHER JOB.\n          RETURN CODES :\n                0 - INDICATES JOB OR USER FOUND IN EXECUTION.\n                    ALL CONFLICTS (IF ANY) HAVE BEEN LISTED.\n                4 - INDICATES JOB OR USER NOT FOUND IN EXECUTION.\n                8 - INDICATES PARSE ERROR OCCURED.\n               12 - INDICATES COMMAND COULD NOT FIND THE DSN QCB CHAIN.\n               16 - INDICATES ERROR OCCURRED, RE-ENTER COMMAND.\n)X SYNTAX :    LISTENQ J-U USER JOB\n)O OPERANDS :\n))J-U (REQUIRED) :  THE JOBNAME OR USERID TO BE SCANNED.\n                    USERID CAN BE SPECIFIED AS '*' IF YOU WISH TO SCAN\n                    YOUR OWN USERID.\n))USER (OPTIONAL) : SPECIFIES THAT ONLY TSO USERS ARE TO BE SEARCHED IF\n                    A JOB AND TSO SESSION HAVE THE SAME NAME.\n))JOB (OPTIONAL) :  SPECIFIES THAT ONLY JOBS ARE TO BE SEARCHED IF A\n                    JOB AND TSO SESSION HAVE THE SAME NAME.\n))EXAMPLES :\n       (1) LISTENQ XXYYZZ   - THIS SCANS FOR THE JOB OR USERID XXXZXY\n                              IF IN EXECUTION.\n       (2) LISTENQ JJJ JOB  - THIS SCANS ONLY FOR THE JOB JJJ IF IN\n                              EXECUTION.\n       (3) LISTENQ UUU USER - THIS SCANS ONLY FOR THE USER UUU.\n       (4) LISTENQ *        - SCAN THE USER ISSUING THE COMMAND.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTNO": {"ttr": 21003, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x14o\\x00\\x93\\x14o\\x14T\\x02\\xd5\\x02\\xd5\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-05-26T00:00:00", "modifydate": "1993-05-26T14:54:00", "lines": 725, "newlines": 725, "modlines": 0, "user": "SYSPAJA"}, "text": "LNMP     TITLE 'LIST MANUAL''S MEMBERS.'\nLISTNO   START 0\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* * * * * * * * *                                     * * * * * * * * *\n* * * * * * * * *        LIST MANUAL'S MEMBERS        * * * * * * * * *\n* * * * * * * * *                                     * * * * * * * * *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n* AUTHOR :     P.A. MOINIL                                            *\n* --------     COMPUTING CENTRE                                       *\n*              J.R.C. - ISPRA ESTABLISHMENT                           *\n*              21020 ISPRA (VA), ITALY                                *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n* PURPOSE :    PRINT ENTIRELY A SELECTED MANUAL OR ONLY THE PAGES     *\n* ---------    UPDATED STARTING FROM A SPECIFIED DATE.                *\n*                                                                     *\n* CALL OF THE PROGRAM :                                               *\n* ---------------------                                               *\n*                                                                     *\n*        //NOTES  EXEC  PGM=LISTNO,PARM='...'                         *\n*        //SYSPRINT DD  SYSOUT=A                                      *\n*        //SYSPDS   DD  ... NOTES DATA-SET (DSORG=PO) ...             *\n*        //SYSIN    DD  ... REQUESTS CARDS  ...                       *\n*                                                                     *\n* PARM. FIELD DESCRIPTION :                                           *\n* -------------------------                                           *\n*                                                                     *\n*        MANUAL=... - THE NAME (1 TO 6 ALPHAMERICS) OF THE MANUAL     *\n*        M=...        MAIN MEMBER, CONTAINING THE TITLE AND THE       *\n*                     LIST OF ALL THE MEMBERS COMPONENT OF THIS       *\n*                     MANUAL. THE NAME GIVEN BY THIS PARAMETER IS     *\n*                     SURROUNDED BY THE CHARACTER # TO FORM THE       *\n*                     MANUAL MAIN MEMBER NAME. IF OMITTED, THE        *\n*                     DEFAULT NAME USED IS '#MANUAL#'.                *\n*                                                                     *\n*        DATE=...   - THE DATE OF THE LAST TIME THE MANUAL OR THE     *\n*        D=...        UPDATED PAGES HAS BEEN REQUESTED. THE FORMAT    *\n*                     IS DDMMYY, DD.MM.YY OR DD/MM/YY, WHERE DD IS    *\n*                                                                     *\n*        LIST=...   - THE NAME (1 TO 8 ALPHAMERICS) OF A SPECIFIC     *\n*        L=...        MEMBER (NO DEFAULT SUPPLIED). THIS WAY OF USE   *\n*                     EXCLUDE ANY OTHER SELECTION TYPE (MANUAL=...,   *\n*                     DATE=... OR REQUESTS CARDS).                    *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n* REQUESTS CARDS (SYSIN) :                                            *\n* ------------------------                                            *\n*                                                                     *\n*        THE REQUESTS CARDS ARE FREE FORMAT CODED FROM COLUMN 1 TO    *\n*        72 INCLUDED, AND EVERY REQUEST MUST BE SEPARATED FROM EACH   *\n*        OTHER BY AT LEAST ONE BLANK. A REQUEST IS A MANUAL NAME      *\n*        (1 TO 6 ALPHAMERICS), EVENTUALLY FOLLOWED BY A DATE (FORMAT  *\n*        MAY BE DDMMYY, DD.MM.YY OR DD/MM/YY) TO OBTAIN THE UPDATED   *\n*        PAGES OF THE MANUAL.                                         *\n*        NEVER A MANUAL NAME OR A DATE MUST BE SPLITTED BETWEEN TWO   *\n*        SUCCESSIVE CARDS, BUT I.E., A MANUAL NAME MAY BE IN A CARD   *\n*        AND THE CORRESPONDING SELECTION DATE IN THE NEXT.            *\n*                                                                     *\n* MEMBERS CONTROL CARDS :                                             *\n* -----------------------                                             *\n*                                                                     *\n*        1. PAGE CONTROL CARDS : ALL MEMBERS.                         *\n*                                                                     *\n*              COL.  1 -  4 : =/EJ OR 1 FOLLOWED BY THREE BLANKS.     *\n*              COL.  5 - 12 : THE DATE OF THE PAGE CREATION OR        *\n*                             UPDATE (FORMAT MAY BE : DD/MM/YY,       *\n*                             DD.MM.YY OR DDMMYY).                    *\n*                      NOTE : THIS DATE IS CONTROLED WHEN 'DATE=...'  *\n*                             IS SPECIFIED IN THE PARAMETERS FIELD.   *\n*                             IT IS NEVER CHECKED FOR THE FIRST PAGE  *\n*                             OF THE MANUAL MAIN MEMBER.              *\n*                                                                     *\n*        2. SELECTION CONTROL CARDS : ONLY IN THE MANUAL MAIN MEMBER. *\n*                                                                     *\n*              COL.  1 -  4 : =/MB                                    *\n*              COL. 10 - 17 : THE NAME OF A MEMBER PART OF THIS       *\n*                             MANUAL.                                 *\n*              COL. 20 - 72 : MEMBER TITLE.                           *\n*                      NOTE : THIS CARD IS ALWAYS PRINTED UNLESS      *\n*                             ENCOUNTERED IN THE FIRST PAGE OF THE    *\n*                             MANUAL MAIN MEMBER.                     *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12\n         XR    R10,R10             SET C.C. = 0.\n         EJECT\n*        ANALYZE PARM. FIELD REQUEST IF ANY.\n         SPACE 1\n         L     R1,0(R1)            PARM. FIELD ADDRESS.\n         LH    R3,0(R1)\n         LTR   R3,R3\n         BNP   ENDPARM\n         LA    R2,2(R1)            SCAN PARM. FIELD.\n         LA    R3,1(R1,R3)\nSCAN     TM    SWITCH,SWD\n         BO    TESTL\n         CLC   0(L'DTL,R2),DTL     DATE REQUEST?\n         BE    DT1\n         CLC   0(L'DTS,R2),DTS\n         BE    DT2\nTESTL    TM    OPERSW,SWL\n         BO    TESTM\n         CLC   0(L'LSL,R2),LSL     LIST REQUEST?\n         BE    LS1\n         CLC   0(L'LSS,R2),LSS\n         BE    LS2\nTESTM    TM    SWITCH,SWM\n         BO    TESTT\n         CLC   0(L'MNL,R2),MNL     MANUAL REQUEST?\n         BE    MN1\n         CLC   0(L'MNS,R2),MNS\n         BE    MN2\nTESTT    TM    OPERSW,SWT\n         BO    TESTS\n         CLC   0(L'TEST,R2),TEST   TEST REQUEST?\n         BE    TS1\nTESTS    TM    OPERSW,SWS\n         BO    ERPARM\n         CLC   0(L'SEOM,R2),SEOM   SKIP REQUEST?\n         BE    SE1\n         B     ERPARM\n         SPACE 1\nDT1      LA    R2,L'DTL(R2)\n         B     DT3\nDT2      LA    R2,L'DTS(R2)\nDT3      CLR   R2,R3               DATE= OR D=\n         BH    ENDPARM\n         TM    OPERSW,SWL\n         BO    ERPARM              ALREADY LIST REQUESTED.\n         CLI   0(R2),C','\n         BE    DTMNX\n         LR    R6,R2               CONTROL AND GET DATE.\n         BAS   R9,SDATE\n         BNZ   ERPARM\n         MVC   TDATE,WORK\n         CLI   2(R2),C'/'\n         BE    *+L'*+8\n         CLI   2(R2),C'.'\n         BNE   *+L'*+4\n         LA    R2,2(R2)\n         LA    R2,6(R2)\n         OI    SWITCH,SWD\nDTMN     CLR   R2,R3\n         BH    ENDPARM\n         CLI   0(R2),C','\n         BNE   ERPARM\nDTMNX    LA    R2,1(R2)\n         B     SCAN\n         SPACE 1\nMN1      LA    R2,L'MNL(R2)        MANUAL= OR M=\n         B     MN3\nMN2      LA    R2,L'MNS(R2)\nMN3      CLR   R2,R3\n         BH    ENDPARM\n         TM    OPERSW,SWL\n         BO    ERPARM              ALREADY LIST REQUESTED.\n         CLI   0(R2),C','\n         BE    DTMNX\n         CLI   0(R2),C'A'\n         BL    ERPARM\n         CLI   0(R2),C'Z'\n         BH    ERPARM\n         LA    R1,5(R2)\n         LR    R4,R2\nMN4      LA    R2,1(R2)\n         CLR   R2,R3\n         BH    MN5\n         CLI   0(R2),C','\n         BE    MN5\n         CLR   R2,R1\n         BH    ERPARM\n         CLI   0(R2),C'#'\n         BE    MN4\n         CLI   0(R2),C'$'\n         BE    MN4\n         CLI   0(R2),C'@'\n         BE    MN4\n         CLI   0(R2),C'A'\n         BNL   MN4\n         B     ERPARM\nMN5      LR    R1,R2\n         SR    R1,R4\n         BCTR  R1,0\n         EX    R1,MVMAN\n         EX    R1,MVNMB\n         MVI   MANME,C'#'\n         LA    R1,MANME+L'MANME-1\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         MVI   1(R1),C'#'\n         OI    SWITCH,SWM\n         B     DTMN\nMVMAN    MVC   MANME+1(*-*),0(R4)\nMVNMB    MVC   NMBN(*-*),0(R4)\n         SPACE 1\nLS1      LA    R2,L'LSL(R2)        LIST= OR L=\n         B     LS3\nLS2      LA    R2,L'LSS(R2)\nLS3      CLR   R2,R3\n         BH    ENDPARM\n         TM    SWITCH,SWD+SWM\n         BNZ   ERPARM              LIST IS EXCLUSIVE.\n         CLI   0(R2),C','\n         BE    DTMNX\n         CLI   0(R2),C'#'\n         BE    LS4\n         CLI   0(R2),C'$'\n         BE    LS4\n         CLI   0(R2),C'@'\n         BE    LS4\n         CLI   0(R2),C'A'\n         BL    ERPARM\n         CLI   0(R2),C'Z'\n         BH    ERPARM\nLS4      LA    R1,7(R2)\n         LR    R4,R2\nLS5      LA    R2,1(R2)\n         CLR   R2,R3\n         BH    LS6\n         CLI   0(R2),C','\n         BE    LS6\n         CLR   R2,R1\n         BH    ERPARM\n         CLI   0(R2),C'#'\n         BE    LS5\n         CLI   0(R2),C'$'\n         BE    LS5\n         CLI   0(R2),C'@'\n         BE    LS5\n         CLI   0(R2),C'A'\n         BNL   LS5\n         B     ERPARM\nLS6      LR    R1,R2\n         SR    R1,R4\n         BCTR  R1,0\n         L     R5,SLIST\n         A     R5,SLIST+4\n         EX    R1,MVNML\n         OI    OPERSW,SWL\n         B     DTMN\nMVNML    MVC   0(*-*,R5),0(R4)\n         SPACE 1\nTS1      LA    R2,L'TEST(R2)       TEST\n         OI    OPERSW,SWT\n         B     DTMN\n         SPACE 1\nSE1      LA    R2,L'SEOM(R2)       SKIP\n         OI    OPERSW,SWS\n         B     DTMN\n         SPACE 1\nENDPARM  TM    OPERSW,SWL\n         BO    NOIN                LIST REQUESTED.\n        $GDATE DAY,,WORK\n         LTR   R10,R15\n         BNZ   ERRG\n         MVC   TODAY(2),WORK+4\n         MVC   TODAY+3(2),WORK\n         MVC   TODAY+6(2),WORK+2\n         CLC   TDATE,TODAY\n         BNL   ERDATE\n         SPACE 2\n*        ANALYZE REQUESTS CARDS (SYSIN) IF ANY.\n         SPACE 1\n         L     R1,=V(#RMSW#)\n         MVI   0(R1),1\n        $READ  CTCD\n         LTR   R10,R15\n         BM    NOIN\n         BP    ANAL\n         OI    OPERSW,SWR\n         B     NOIN\nANAL     CH    R15,=H'1'\n         BNE   END5\nNOIN    $MOPEN WORK\n         LTR   R10,R15\n         BNZ   END4\n         CLI   WORK+3,L'CARD\n         BNE   ERLRL\n         TM    OPERSW,SWL\n         BO    STPM                LIST REQUESTED.\n         TM    OPERSW,SWR\n         BZ    SETDEF\n         CLI   MANME,C' '\n         BNE   FNM\nGNXT     LM    R3,R5,LOOK\n         MVI   SWITCH,0\n         MVC   MANME,BLKS\n         MVC   NMBN,BLKS\nRSTRT    CLI   0(R3),C' '\n         BNE   WHAT\nCONT     BXLE  R3,R4,*-8\n        $READ  CTCD\n         LTR   R10,R15\n         BP    END5\n         BM    REOF\n         LA    R3,CTCD\n         B     RSTRT\nREOF     NI    OPERSW,255-SWR\n         CLI   MANME,C' '\n         BNE   PRCS\n         TM    SWITCH,SWD\n         BO    PRCS\n         XR    R10,R10\n         B     END4\nWHAT     CLI   0(R3),C'0'          IS IT A DATE?\n         BNL   GDTE                YES.\n         CLI   MANME,C' '\n         BNE   PRCS\n         MVI   MANME,C'#'\n         LA    R2,MANME+1\n         LA    R1,6\nSRCH     CLI   0(R3),C'A'\n         BL    ERSEL\n         MVC   0(1,R2),0(R3)\n         LA    R2,1(R2)\n         BXLE  R3,R4,*+L'*+4\n         B     STRE\n         CLI   0(R3),C' '\n         BE    STRE\n         BCT   R1,SRCH\n         B     ERSEL\nSTRE     MVC   NMBN(6),MANME+1\n         MVI   0(R2),C'#'\n         B     CONT\nGDTE     LR    R6,R3\n         BAS   R9,SDATE\n         BNZ   ERSEL\n         MVC   TDATE,WORK\n         CLI   2(R3),C'/'\n         BE    *+L'*+8\n         CLI   2(R3),C'.'\n         BNE   *+L'*+4\n         LA    R3,2(R3)\n         LA    R3,4(R3)\n         BXLE  R3,R4,*+L'*+6\n         LR    R3,R6\n         B     ERSEL\n         BXLE  R3,R4,TSTE\n         BCTR  R3,0\n         MVI   0(R3),C' '\n         B     OKGDT\nTSTE     CLI   0(R3),C' '\n         BNE   ERSEL\nOKGDT    OI    SWITCH,SWD\nPRCS     ST    R3,LOOK\nSETDEF   CLI   MANME,C' '\n         BNE   FNM\n         MVC   MANME(L'DEFMAN),DEFMAN\n         SPACE 2\n*        SELECT MAIN MANUAL MEMBER AND PRINT TITLE.\n         SPACE 1\nFNM     $MFIND MANME\n         LTR   R10,R15\n         BNZ   END4\n         TM    OPERSW,SWT\n         BZ    NOST\n         MVC   TESTW+22(8),MANME\n         LA    R1,TESTW\n        WTO    MF=(E,(1))\nNOST     LM    R3,R5,SLIST\nRDM     $MREAD CARD\n         LTR   R10,R15\n         BM    ENDLTM\n         BP    END4\n         CLC   CARD(L'MB),MB       MEMBERS LIST.\n         BE    SML\n         CLC   CARD(L'EJ),EJ       SKIP PAGE.\n         BE    *+L'*+10\n         CLC   CARD(L'EJS),EJS\n         BNE   LTT\n         TM    SWITCH,SWN\n         BO    SKP\n         TM    SWITCH,SWF\n         BO    PDT\n         OI    SWITCH,SWF\n         B     SKP\nPDT      OI    SWITCH,SWN\n         MVC   SVDAY(L'SVDAY),CARD+L'EJ\n         MVC   CARD(L'CARD),CARD-1 PRINT CURRENT DATE OF THIS COPY.\n         LA    R2,5\nSKIP     BAS   R9,PLINE\n         BCT   R2,SKIP\n         MVC   CARD+9(L'NMB+L'NMBN),NMB\n         CLC   CARD+L'NMB+9(L'NMBN),BLKS\n         BNE   *+L'*+6\n         MVC   CARD+L'NMB+9(6),DEFMAN+1\n         BAS   R9,PLINE\n         MVC   CARD(L'CARD),CARD-1\n         BAS   R9,PLINE\n         MVC   CARD+9(L'TDT),TDT\n         MVC   CARD+L'TDT+9(2),TODAY+6\n         MVC   CARD+L'TDT+11(4),TODAY+2\n         MVC   CARD+L'TDT+15(2),TODAY\n         MVI   CARD+L'TDT+L'TODAY+10,C'('\n         MVC   CARD+L'TDT+L'TODAY+13(L'DAY),DAY\n         MVI   CARD+L'TDT+L'TODAY+L'DAY+13,C')'\n         BAS   R9,PLINE\n         OI    SWITCH,SWC\n         MVC   CARD(L'CARD),CARD-1\n         MVC   CARD+L'EJ(L'SVDAY),SVDAY\nSKP      TM    SWITCH,SWD\n         BZ    SK3\n         TM    SWITCH,SWN\n         BZ    SK3\n         LA    R6,CARD+L'EJ        CONTROL AND GET DATE.\n         BAS   R9,SDATE\n         BNZ   SK0\n         CLC   WORK,TDATE\n         BH    SK1\n         OI    SWITCH,SWP\n         B     RDM\nSK0      MVC   CARD+L'EJ+20(L'ERDTP),ERDTP\n         B     SK2\nSK1      MVC   CARD+L'EJ(2),WORK+6\n         MVC   CARD+L'EJ+2(4),WORK+2\n         MVC   CARD+L'EJ+6(2),WORK\nSK2      NI    SWITCH,255-SWP\nSK3      MVC   CARD(L'EJ),LINE+1\n         MVI   LINE,C'1'\n         MVI   CARD+L'EJ+9,C'-'\n         MVC   CARD+L'EJ+11(6),NMBN\n         CLC   CARD+L'EJ+11(6),BLKS\n         BNE   *+L'*+6\n         MVC   CARD+L'EJ+11(6),DEFMAN+1\n         TM    SWITCH,SWN\n         BZ    *+L'*+4\n         OI    SWITCH,SWU\n         MVC   CARD(L'EJ),LINE+1\n         MVI   LINE,C'1'\n         B     LTM\nLTT      TM    SWITCH,SWP\n         BO    RDM\nLTM      MVC   CARD+72(8),LINE+1\n         BAS   R9,PLINE\n         MVI   LINE,C' '\n         B     RDM\nSML      BXLE  R3,R4,*+L'*+4\n         B     TABOV\n         MVC   0(L'TLIST,R3),CARD+9\n         MVI   L'TLIST(R3),C' '\n         TM    SWITCH,SWP\n         BO    RDM\n         TM    SWITCH,SWN\n         BZ    RDM                 DON'T PRINT IF FIRST PAGE.\n         MVC   CARD(L'MB+5),LINE+1\n         MVC   CARD+L'MB+4(8),CARD+L'MB+5\n         MVC   CARD+L'MB+12(3),NMB+4\n         B     LTM\n         SPACE 2\n*        PRINT THE CURRENT DATE OF THIS COPY.\n         SPACE 1\nENDLTM   TM    SWITCH,SWC\n         BO    STPM                ALREADY PRINTED.\n         MVC   CARD(L'CARD),CARD-1\n         LA    R2,5\nSPCE     BAS   R9,PLINE\n         BCT   R2,SPCE\n         MVC   CARD+9(L'NMB+L'NMBN),NMB\n         CLC   CARD+L'NMB+9(L'NMBN),BLKS\n         BNE   *+L'*+6\n         MVC   CARD+L'NMB+9(6),DEFMAN+1\n         BAS   R9,PLINE\n         MVC   CARD(L'CARD),CARD-1\n         BAS   R9,PLINE\n         MVC   CARD+9(L'TDT),TDT\n         MVC   CARD+L'TDT+9(2),TODAY+6\n         MVC   CARD+L'TDT+11(4),TODAY+2\n         MVC   CARD+L'TDT+15(2),TODAY\n         MVI   CARD+L'TDT+L'TODAY+10,C'('\n         MVC   CARD+L'TDT+L'TODAY+13(L'DAY),DAY\n         MVI   CARD+L'TDT+L'TODAY+L'DAY+13,C')'\n         BAS   R9,PLINE\nSTPM     L     R4,SLIST\n         A     R4,SLIST+4\n         SPACE 2\n*        SELECT A MEMBER PART OF THIS MANUAL.\n         SPACE 1\nNEXT     CLI   0(R4),C' '\n         BE    ENDMAN\n        $MFIND (R4)\n         LTR   R10,R15\n         BNZ   END4\n         TM    OPERSW,SWT\n         BZ    NOTS\n         MVC   TESTW+22(8),0(R4)\n         LA    R1,TESTW\n        WTO    MF=(E,(1))\nNOTS     LA    R4,L'TLIST(R4)\n         NI    SWITCH,255-SWP\n         SPACE 2\n*        PRINT THE MEMBER PART OF THIS MANUAL.\n         SPACE 1\nRNXT    $MREAD CARD\n         LTR   R10,R15\n         BM    NEXT\n         BP    END4\n         CLC   CARD(L'EJ),EJ       SKIP PAGE.\n         BE    *+L'*+10\n         CLC   CARD(L'EJS),EJS\n         BNE   RM4\n         TM    SWITCH,SWD\n         BZ    RM3\n         LA    R6,CARD+L'EJ        CONTROL AND GET DATE.\n         BAS   R9,SDATE\n         BNZ   RM0\n         CLC   WORK,TDATE\n         BH    RM1\n         OI    SWITCH,SWP\n         B     RNXT\nRM0      MVC   CARD+L'EJ+20(L'ERDTP),ERDTP\n         B     RM2\nRM1      MVC   CARD+L'EJ(2),WORK+6\n         MVC   CARD+L'EJ+2(4),WORK+2\n         MVC   CARD+L'EJ+6(2),WORK\nRM2      NI    SWITCH,255-SWP\nRM3      MVC   CARD(L'EJ),LINE+1\n         MVI   LINE,C'1'\n         OI    SWITCH,SWU\n         TM    OPERSW,SWL\n         BO    RM5\n         MVI   CARD+L'EJ+9,C'-'\n         MVC   CARD+L'EJ+11(6),NMBN\n         CLC   CARD+L'EJ+11(6),BLKS\n         BNE   RM5\n         MVC   CARD+L'EJ+11(6),DEFMAN+1\n         B     RM5\nRM4      TM    SWITCH,SWP\n         BO    RNXT\nRM5      MVC   CARD+72(8),LINE+1\n         BAS   R9,PLINE\n         MVI   LINE,C' '\n         B     RNXT\n         SPACE 2\n*        END PRINTING OF THIS MANUAL.\n         SPACE 1\nENDMAN   XR    R10,R10             SET C.C. = 0.\n         TM    OPERSW,SWL\n         BO    END4\n         TM    SWITCH,SWU\n         BO    END1\n         MVC   UMSG+L'UMSG-L'NMBN(L'NMBN),NMBN\n         LA    R2,UMSG+L'UMSG-1\n         CLI   0(R2),C' '\n         BNE   *+L'*+4\n         BCT   R2,*-8\n         MVI   1(R2),C'.'\n         LA    R2,UMSG\n         B     END2\nEND1     TM    OPERSW,SWS\n         BO    END3\n         LA    R2,EMSG\nEND2    $PRINT (R2)\n         LTR   R10,R15\n         BNZ   END4\nEND3     TM    OPERSW,SWR\n         BO    GNXT\n         SPACE 2\n*        ALL REQUESTS TERMINATED.\n         SPACE 1\nEND4    $MCLOSE\nEND5    $RCLOSE\n        $PCLOSE\n        $XRET  CC=(R10)\n         SPACE 2\n*        ERRORS DIAGNOSTICS.\n         SPACE 1\nERRG     LA    R2,GMSG\n         B     ERR2\nTABOV    LA    R2,OMSG\n         B     ERR1\nERLRL    LA    R2,LMSG\nERR1    $PRINT (R2)\n         B     END4\nERDATE   LA    R2,DMSG\n         B     ERPARM+L'ERPARM\nERPARM   LA    R2,PMSG\n         LA    R10,16\nERR2    $PRINT (R2)\n         B     END5\nERSEL    LA    R2,RMSG\n        $PRINT (R2)\n        $PRINT DEBG\n         MVC   CTCD(L'CTCD),CTCD-1\n         MVI   DEBG,C' '\n         MVI   0(R3),C'$'          SET THE SCAN POINTER.\n        $PRINT DEBG\n         LA    R10,16\n         B     END4\n         EJECT\n*        SEARCH DATE ROUTINE.\n*\n* AT ENTRY :   R6 = ADDRESS OF DATE FIELD.\n*                   FORMAT MAY BE : DDMMYY\n*                                   DD.MM.YY\n*                                   DD/MM/YY\n*              R9 = LINK REGISTER.\n*\n* AT EXIT :    CONDITION CODE = ZERO : ALL OK.\n*                               NON-ZERO : INPUT FIELD FORMAT ERROR.\n*              'WORK' (FORMAT CL8) CONTAINS THE DATE AS YY/MM/DD.\n         SPACE 1\nSDATE    MVC   WORK,MDATE\n         CLI   2(R6),C'/'          DD/MM/YY\n         BE    SD1\n         CLI   2(R6),C'.'          DD.MM.YY\n         BE    SD2\n         MVC   WORK+6(2),0(R6)     DDMMYY\n         MVC   WORK+3(2),2(R6)\n         MVC   WORK(2),4(R6)\n         B     SD4\nSD1      CLI   5(R6),C'/'\n         BE    SD3\n         BR    R9\nSD2      CLI   5(R6),C'.'\n         BNER  R9\nSD3      MVC   WORK+6(2),0(R6)\n         MVC   WORK+3(2),3(R6)\n         MVC   WORK(2),6(R6)\nSD4      MVC   CDATE,WORK\n         NC    CDATE,MDATE\n         CLC   CDATE,MDATE\n         BR    R9\n         EJECT\n*        PRINT ROUTINE.\n*\n*              R9 = LINK REGISTER.\n         SPACE 1\nPLINE   $PRINT LINE\n         LTR   R10,R15\n         BZR   R9\n         B     END4\n         SPACE 2\nTESTW   WTO    'MEMBER SELECTED :         ',ROUTCDE=11,DESC=7,MF=L\n         SPACE 2\n         LTORG\n         EJECT\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\nWORK     DC    D'0'\nLOOK     DC    A(CTCD,1,CTCD+71)\nSLIST    DC    A(TLIST-L'TLIST,L'TLIST,ELIST)\nCDATE    DC    CL8' '\nTDATE    DC    CL8'00/00/00'\nMDATE    DC    CL8'00/00/00'\nTODAY    DC    CL8'00/00/00'\nSVDAY    DC    CL8' '\nDAY      DC    CL20' '\nMANME    DC    CL8' '\nDEFMAN   DC    CL8'#MANUAL#'\nEJ       DC    CL4'=/EJ'\nEJS      DC    CL4'1   '\nMB       DC    CL4'=/MB'\nDTL      DC    C'DATE='\nDTS      DC    C'D='\nMNL      DC    C'MANUAL='\nMNS      DC    C'M='\nLSL      DC    C'LIST='\nLSS      DC    C'L='\nNMB      DC    C'NAME : '\nNMBN     DC    CL8' '\nTDT      DC    C'DATE : '\nTEST     DC    C'TEST'\nSEOM     DC    C'SKIP'\nBLKS     DC    CL8' '\n         SPACE 1\nSWITCH   DC    XL1'0'\nSWD      EQU   X'01'               DATE REQUEST IN PARM. FIELD.\nSWM      EQU   X'02'               MANUAL SELECT IN PARM. FIELD.\nSWP      EQU   X'04'               PAGE TO BE PRINTED.\nSWU      EQU   X'08'               UPDATED PAGES PRINTED.\nSWF      EQU   X'10'               FIRST PAGE PRINT CURRENT DATE.\nSWN      EQU   X'20'               FIRST PAGE CONTROL.\nSWC      EQU   X'40'               PRINT CURRENT DATE.\n         SPACE 1\nOPERSW   DC    XL1'0'\nSWT      EQU   X'01'               TEST REQUEST IN PARM. FIELD.\nSWR      EQU   X'02'               REQUESTS CARDS PRESENT (SYSIN).\nSWL      EQU   X'04'               LIST SELECT IN PARM. FIELD.\nSWS      EQU   X'08'               SKIP END OF MANUAL MESSAGE.\n         EJECT\n         DC    AL1(L'LINE)\nLINE     DC    0CL91' ',CL11' '\nCARD     DC    CL80' '\n         DC    AL1(L'DEBG)\nDEBG     DC    0CL91' ',CL11'0 '\nCTCD     DC    CL80' '\n         SPACE 1\nERDTP    DC    C'*** PAGE PRINT FORCED : WRONG DATE DETECTED.'\n         SPACE 1\n         DC    AL1(L'EMSG)\nEMSG     DC    C'1     --- END OF MANUAL ---'\n         DC    AL1(L'GMSG)\nGMSG     DC    C'1     -GDATE- SUBROUTINE ERROR.'\n         DC    AL1(L'LMSG)\nLMSG     DC    C'1     LOGICAL RECORD LENGTH NOT CARD IMAGE LENGTH.'\n         DC    AL1(L'OMSG)\nOMSG     DC    C'1     MANUAL MEMBERS TABLE OVERFLOW.'\n         DC    AL1(L'DMSG)\nDMSG     DC    C'1     INVALID DATE IN PARAMETERS FIELD.'\n         DC    AL1(L'PMSG)\nPMSG     DC    C'1     PARAMETERS FIELD ERROR.'\n         DC    AL1(L'RMSG)\nRMSG     DC    C'0     INVALID REQUEST DETECTED.'\n         DC    AL1(L'UMSG)\nUMSG     DC    C'1     NO UPDATE PAGES TO MANUAL :         '\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        SYMBOLS BELOW ARE NEVER DIRECTLY ADDRESSED BY PROGRAM.       *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nTLIST    DC    200CL8' '\n         DC    200CL8' '\n         DC    100CL8' '\nELIST    DC    CL8' ',C' '\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTNO$": {"ttr": 21256, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10&\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:26:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//LISTNO   JOB (........),'INSTALL - LISTNO -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=3\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                GFDATE    MREAD     TXPRINT   TXREAD               *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,MBR=LISTNO\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  INCLUDE SYSADD(GFDATE,MREAD,PRINT,READ)\n  ENTRY   LISTNO\n  NAME    LISTNO(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTNO@": {"ttr": 21258, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x01_\\x00\\x86\\x01_\\x12I\\x00M\\x00M\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-01-15T00:00:00", "modifydate": "1986-01-15T12:49:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "SYSPAJA"}, "text": "1   15/01/86\n                                                      LISTNO    1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        LIST MANUAL'S MEMBERS        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Print entirely a selected manual or only the pages\n  ---------    updated starting from a specified date.\n\n  Call of the program :\n  ---------------------\n\n         //NOTES  EXEC  PGM=LISTNO,PARM='...'\n         //SYSPRINT DD  SYSOUT=A\n         //SYSPDS   DD  ... Notes data-set (DSORG=PO) ...\n         //SYSIN    DD  ... Requests cards  ...\n\n  Parm. field description :\n  -------------------------\n\n         MANUAL=... - The name (1 to 6 alphamerics) of the manual\n         M=...        main member, containing the title and the\n                      list of all the members component of this\n                      manual. The name given by this parameter is\n                      surrounded by the character # to form the\n                      manual main member name. If omitted, the\n                      default name used is #MANUAL#.\n\n         DATE=...   - The date of the last time the manual or the\n         D=...        updated pages have been requested. The format\n                      is DDMMYY, DD.MM.YY or DD/MM/YY, where DD is\n                      the day, MM is the month and YY is the year.\n\n         LIST=...   - The name (1 to 8 alphamerics) of a specific\n         L=...        member (no default supplied). This way of use\n                      exclude any other selection type (MANUAL=...,\n                      DATE=... or requests cards).\n\n  Requests cards (SYSIN) :\n  ------------------------\n\n         The requests cards are free format coded from column 1 to\n         72 included, and every request must be separated from each\n         other by at least one blank. A request is a manual name\n         (1 to 6 alphamerics), eventually followed by a date (format\n         may be DDMMYY, DD.MM.YY or DD/MM/YY) to obtain the updated\n         pages of the manual.\n         Never a manual name or a data must be splitted between two\n         successive cards, but i.e., a manual name may be in a card\n         and the corresponding selection date in the next.\n1   15/01/86\n                                                      LISTNO    2/2.\n\n  Members control cards :\n  -----------------------\n\n         1. Page control cards : all members.\n               col.  1 -  4 : =/EJ or 1 followed by three blanks.\n               col.  5 - 12 : the date of the page creation or\n                              update (format may be : DD/MM/YY,\n                              DD.MM.YY or DDMMYY).\n                       Note : this date is controlled when DATE=...\n                              is specified in the parameters field.\n                              It is never checked for the first page\n                              of the manual main member.\n\n         2. Selection control cards : only in the manual main member.\n               col.  1 -  4 : =/MB\n               col. 10 - 17 : the name of a member part of this\n                              manual.\n               col. 20 - 72 : member title.\n                       Note : this card is always printed unless\n                              encountered in the first page of the\n                              manual main member.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LJUST": {"ttr": 21261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x179\\x00\\\\\\x00\\\\\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T17:39:00", "lines": 92, "newlines": 92, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM) NOPROCESS\n/*  MACRO NAME : LJUST                                              */\n/*    FUNCTION : LEFT JUSTIFY TEXT WITHIN DATA LINE(S)              */\n/*      SYNTAX : LJUST                                              */\n/*               LJUST HELP OR H                                    */\n/*       DEBUG : LJUST LIST                                         */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(HELP) OR +\n      &STR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTLJ)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ISPEXEC CONTROL ERRORS RETURN\n  CONTROL ASIS\n/*               PROCESS LINE COMMANDS, CHECK IF C WAS SPECIFIED    */\n  ISREDIT PROCESS RANGE C\n  SET LCC = &LASTCC\n  ISREDIT (RC) = RANGE_CMD\n  SET RCC = &LASTCC\n  IF &LCC \u00ac=0 OR &RCC \u00ac=0 THEN DO\n    IF &RCC = 4 THEN DO\n      IF &STR(&RC) \u00ac= &STR(C) THEN DO\n        IF &LCC = 4 THEN SET &ZEDSMSG = &STR(NO RANGE)\n        ELSE SET &ZEDSMSG = &STR(INVALID RANGE)\n        SET &ZEDLMSG = &STR(YOU MUST SPECIFY A TARGET RANGE OF +\n                            LINES, USING \"CN\" OR \"CC\")\n        END\n      ELSE DO\n        SET &ZEDSMSG = &STR(RANGE INCOMPLETE)\n        SET &ZEDLMSG = &STR(ENTER A MATCHING \"CC\" TO COMPLETE +\n                            THE BLOCK COMMAND PAIR)\n        END\n      END\n    ELSE IF &RCC = 8 THEN DO\n      SET &ZEDSMSG = &STR(NOT ACCEPTABLE)\n      SET &ZEDLMSG = &STR(AN UNACCEPTABLE TARGET RANGE OF LINES +\n                          HAS BEEN SPECIFIED)\n      END\n    ELSE DO\n      SET &ZEDSMSG = &STR(SEVERE ERROR)\n      SET &ZEDLMSG = &STR(SEVERE ERROR OCCURED, RETURN CODES ARE +\n                          &LCC AND &RCC)\n      END\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n    END\n  ISREDIT (FR) = LINENUM .ZFRANGE\n  ISREDIT (LR) = LINENUM .ZLRANGE\n  ISREDIT (LB,RB) = BOUNDS\n  SET BL = &RB - &LB + 1\n  SET I = &FR\n  DO WHILE &I <= &LR\n    ISREDIT (LN) = LINE &I\n    SET L = &LENGTH(&SUBSTR(&LB:&RB,&NRSTR(&LN)))\n    SET S = &LB\n    DO WHILE &S < &L\n      IF &SUBSTR(&S:&S,&NRSTR(&LN)) \u00ac= &STR( ) THEN GOTO FOUNDS\n      SET S = &S + 1\n      END\nFOUNDS: +\n    SET E = &L\n    DO WHILE &E > &S\n      IF &SUBSTR(&E:&E,&NRSTR(&LN)) \u00ac= &STR( ) THEN GOTO FOUNDE\n      SET E = &E - 1\n      END\nFOUNDE: +\n    SET LINE = &SUBSTR(&S:&E,&NRSTR(&LN))\n    SET L = &LENGTH(&NRSTR(&LINE))\n    SET D = &BL - &L\n    IF &D > 1 THEN DO\n      SET H = &D\n      SET LINE2 = &SUBSTR(1:&H,&STR(                                   -\n                                                                       )\n      IF &LB = 1 THEN SET LINE = &NRSTR(&LINE.&LINE2)\n      ELSE SET LINE = &SUBSTR(1:&LB-1,&NRSTR(&LN))&NRSTR(&LINE.&LINE2)\n      END\n    ISREDIT LINE &I = (LINE)\n    SET I = &I + 1\n    END\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LJUST@": {"ttr": 21505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11W\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:57:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "1   19/09/89\n                                                      LJUST     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     LJUST ISPF/PDF EDIT command     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to left justify text within\n  ----------   data line(s).\n\n  Command syntax : LJUST\n  ---------------- LJUST HELP or H\n\n  Use :        Type LJUST on the COMMAND line and mark the range of\n  -----        lines text with the \"C\" range command on the line\n               numbers, as i.e. :\n               COMMAND ===> LJUST\n          ---> CC 500               ... DATA LINE ...\n               000600               ... DATA LINE ...\n          ---> CC 700               ... DATA LINE ...\n               000800               ... DATA LINE ...\n               Result : the text of lines numbered 500, 600 and 700\n                        will be left justified. Identical process is\n                        obtained with :\n          ---> C3 500               ... DATA LINE ...\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOCK": {"ttr": 21507, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x13?\\x00\\x94\\x13?\\x14)\\x02{\\x02{\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-13T00:00:00", "modifydate": "1994-05-13T14:29:00", "lines": 635, "newlines": 635, "modlines": 0, "user": "SYSPAJA"}, "text": "LOCK     TITLE 'TSO - COMMAND TO LOCK TERMINAL'\nLOCK     START   0\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* Purpose :    TSO command to LOCK terminal (restricted to only       *\n*              authorized users : SYSTEM).                            *\n*                                                                     *\n*              Function : terminal is locked until the correct two    *\n*                         secret keywords are typed in, or, the       *\n*                         SESSION is terminated when the defined      *\n*                         maximum WAIT time (minutes) has expired     *\n*                         (see module \"LOCKT\").                       *\n*                                                                     *\n*              Note : the above maximum WAIT time is not connected in *\n*                         any way with the \"JWT\" time expressed in    *\n*                         member SMFPRM00 of the PARMLIB. It starts   *\n*                         at the moment the LOCK command is invoked   *\n*                         and it decrements continuously (REAL time), *\n*                         even if somebody push the ENTER key.        *\n*                                                                     *\n*              Mandatory : 1. define secret keys (see module \"LOCKT\") *\n*                             for authorized users, and               *\n*                          2. verify the value assigned at the DEFWUT *\n*                             symbol defined below.                   *\n*                                                                     *\n*              Pre-requisite : KUMX (ISPF Edit macro, see the module  *\n*                          \"LOCKT\").                                  *\n*                                                                     *\n* Syntax :     LOCK                                                   *\n*                                                                     *\n* Author :     MOINIL P.A.                                            *\n*              Computing Centre (TP 361)                              *\n*              J.R.C. - Ispra Establishment                           *\n*              21020 Ispra (VA), Italy                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n*------- MISCELLANEOUS DEFINITIONS\n         SPACE 1\nDEFWUT   EQU   5              DEFAULT WAKE-UP TIME INTERVAL (MINUTES)\n*                             (THE ABOVE VALUE MUST BE LESS THAN THE\n*                             \"JWT\" VALUE IN \"SMFPRM00\" OF PARMLIB)\nPSWR    $MDL@IX ,             AUTHORITY MODULE NAME\nLV12     EQU   12             AUTHORITY LEVEL : SYSTEM GROUP\n         SPACE 1\n         PRINT NOGEN\n        $DEFREG\n         PRINT GEN\n         EJECT\n        $XENT  BASE=(R11,R12)\n        $TEW$EC NOTTSO=(,ONLY),MSG=PUTMSG,ERR=SETRC\n         SPACE 1\n*------- CHECK USER AUTHORITY : SYSTEM\n         SPACE 1\n        $EACM  REQAUT\n         CLI   XAUTH,LV12          AUTHORITY LEVEL OK?\n         BL    NOTAUT              NO\n         MVC   GROUPN,XGRNME       SET GROUP NAME\n         MVC   USERID,XUSNME       SET USER ID\n         MVC   CMDBUFU,XUSNME\n         MVC   CMNDU,XUSNME\n         LA    R1,CMDBUFU+L'CMDBUFU-2\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         MVI   1(R1),C')'\n         SPACE 1\n*------- CHECK CALLER TERMINAL : SCREEN\n         SPACE 1\n        GTSIZE ,                   GET SCREEN SIZE\n         LTR   R0,R0               IS IT A SCREEN?\n         BZ    NOTSCR              IF ZERO, NOT A SCREEN\n         CH    R0,=H'24'           STANDARD NUMBER OF LINES?\n         BL    NOTSTD              BRANCH IF LESS\n         BE    *+L'*+12            BRANCH IF YES\n         CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    NOTSTD              BRANCH IF LESS\n         B     *+L'*+12\n         CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    NOTSTD              BRANCH IF LESS\n         BE    *+L'*+12            BRANCH IF EQUAL\n         ST    R0,SZSCRN           SAVE SCREEN SIZE\n         ST    R1,SZLINE           SAVE LINE SIZE\n         OI    SWITCH,SCRST        INDICATE SCREEN SIZE TO BE SET\n         SPACE 1\n*------- GET LOCK TABLE AND CHECK USER DEFINED IN\n         SPACE 1\n         MVC   WORKC,USERID\n         LA    R1,PLST0\n         L     R15,=V(SETKEY)\n         BASR  R14,R15\n         LTR   R15,R15\n         BZ    STKOK\n         MVC   MSGERN,=CL6'SETKEY'\nSDMSG    CVD   R15,WORKD\n         MVC   WORKD(5),=XL5'4020202120'\n         ED    WORKD(5),WORKD+L'WORKD-3\n         MVC   MSGERC,WORKD+2\n         LA    R1,MSGER\n         B     XSMSG\nSTKOK    LA    R1,PLST4\n         L     R15,=V(ENCIPH)\n         BASR  R14,R15\n         LTR   R15,R15\n         BZ    *+L'*+10\n         MVC   MSGERN,=CL6'ENCIPH'\n         B     SDMSG\n        LOAD   EP=LOCKT\n         LTR   R15,R15\n         BZ    *+L'*+10\n         MVC   MSGERN,=CL6'\"LOAD\"'\n         B     SDMSG\n         LR    R1,R0\n         CLC   =CL4'LCKT',4*4(R1)  CHECK TABLE IDENTIFICATION\n         BE    CMXWT               OK\n         LA    R1,MSGTW            WRONG\n         B     GODDL\nCMXWT    MVC   MAXWT,3*4(R1)       COPY MAX. WAIT TIME\n         LM    R7,R9,0(R1)\n         CLR   R7,R9\n         BNH   CHKUS\n         LA    R1,MSGTE            TABLE EMPTY\n         B     GODDL\nCHKUS    CLC   WORKC,0(R7)         THIS ONE?\n         BE    CHKOK               YES, OK\n         BXLE  R7,R8,CHKUS         NO, CHECK NEXT IF ANY\n         LA    R1,MSGNT            NOT IN TABLE\nGODDL    BAS   R14,PUTMSG\n         LA    R7,SETRC\nDODEL   DELETE EP=LOCKT\n         BR    R7\nCHKOK    MVC   VALUE,8(R7)         KEEP VALUE FOR CONTROL\n         BAS   R7,DODEL\n         SPACE 1\n*------- VTAM INITIALIZATION\n         SPACE 1\n        STFSMODE ON,INITIAL=YES    TURN ON VTAM FULL SCREEN MODE\n         TM    SWITCH,SCRST        SCREEN SIZE TO BE SET?\n         BZ    NOSCRS              BRANCH IF NOT\n        STSIZE SIZE=80,LINE=24     SET STANDARD SCREEN SIZE\n         OI    SWITCH,SCRRS        INDICATE SCREEN SIZE TO BE RESET\n         SPACE 1\n*------- LOCK INITIALIZATION\n         SPACE 1\n         USING PSA,R0\nNOSCRS   L     R2,PSAAOLD          ASCB ADDRESS\n         USING ASCB,R2\n         L     R3,ASCBASXB         ASXB ADDRESS\n         DROP  R2\n         USING ASXB,R3\n         L     R2,ASXBSENV         RACF ENVIRONMENT ADDRESS\n         DROP  R3\n         USING ACEE,R2\n         MVC   TERMNAME,ACEETRID   SET TERMINAL ID\n         MVI   USERNAME,C' '\n         MVC   USERNAME+1(L'USERNAME-1),USERNAME\n         L     R3,ACEEUNAM\n         XR    R1,R1\n         IC    R1,0(R3)\n         BCT   R1,*+L'*+4\n         B     NOUSNM\n         LA    R0,L'USERNAME\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         BCT   R1,*+L'*+6\n         MVC   USERNAME(*-*),1(R3)\n         EX    R1,*-6              SET USER NAME\n         DROP  R2\nNOUSNM   L     R3,CVTPTR           CVT POINTER\n         USING CVT,R3\n         L     R2,CVTSMCA          SMF AREA ADDRESS\n         USING SMCABASE,R2\n         ICM   R1,B'1111',SMCAJWT  JOB WAIT TIME LIMIT\n         DROP  R2,R3\n         BZ    STPNTM              NORMALLY NEVER BRANCH HERE\n         M     R0,=F'10486'        BIT-31 REPRESENTS 1.048576 SECONDS\n         D     R0,=F'10000'\n         S     R1,=F'60'           JOB WAIT TIME (SECONDS) - 1 MINUTE\n         BP    SETINT\nSTPNTM   L     R1,=A(DEFWUT*60)    DEFAULT WAKE-UP INTERVAL (SECONDS)\nSETINT   ST    R1,WAKEUP           SET WAKE-UP INTERVAL (SECONDS)\n         MH    R1,=H'100'\n         ST    R1,WTTWTI           TIMER WAIT TIME INTERVAL\n         L     R0,MAXWT            MAXIMUM WAIT TIME DESIRED (SECONDS)\n         CL    R0,WAKEUP           WAKE-UP INTERVAL (SECONDS)\n         BL    STLWTI              SMALLER INTERVAL\n         LR    R1,R0\n         XR    R0,R0\n         D     R0,WAKEUP           WAKE-UP INTERVAL (SECONDS)\n         ST    R1,WTTNUM           NUMBER OF WAKE-UP INTERVAL\n         LTR   R0,R0\n         BNP   STTLWT\nSTLWTI   MH    R0,=H'100'\nSTTLWT   ST    R0,WTLWTI           LAST WAKE-UP TIME INTERVAL\n        IDENTIFY ENTRY=WTTIME,EP=WTTIME SET ENTRY POINT\n        ATTACH EP=WTTIME           START SUB-TASK\n         LTR   R15,R15             STARTED?\n         BNZ   *+L'*+8             NO\n         ST    R1,STTCBA           YES, RETAIN TCB ADDRESS\n         MVC   WTRCC,=F'-1'        AND SET SUB-TASK STARTED\n        ESTAE  INTER               INTERCEPT TASK ABNORMAL EXIT\n        STTMPMD OFF,KEYS=ALL       INTERCEPT ALL KEYS\n        TIME   DEC\n         ST    R0,WORKF            R0 = HHMMSSTF\n         UNPK  WORKC(7),WORKF\n         MVC   HHMM(2),WORKC\n         MVC   HHMM+3(2),WORKC+2\n         SPACE 1\n*------- ASK KEYWORDS TO UNLOCK TERMINAL\n         SPACE 1\nLOOP     TM    SWITCH,SCRST+SCRRS  FIRST TPUT DONE?\n         BNO   SNDWR               BRANCH IF YES\n        $FS    CC=EW,MF=(I,WSCR)   SET ERASE/WRITE\nSNDWR   TPUT   WSCR,WSCRL,FULLSCR  WRITE THE SCREEN\n         TM    SWITCH,SCRST+SCRRS  FIRST TPUT DONE?\n         BNO   SNDGT               BRANCH IF YES\n        $FS    CC=W,MF=(I,WSCR)    RESTORE WRITE\n         NI    SWITCH,255-SCRST    SET FIRST TPUT DONE\nSNDGT    MVI   ERRMSG,C' '\n         MVC   ERRMSG+1(L'ERRMSG-1),ERRMSG\n         XC    REPLY(REPLYL),REPLY\n        TGET   REPLY,REPLYL-1,ASIS\n         CH    R15,=H'20'          TERMINAL DISCONNECTED?\n         BE    LEAVE               YES,... SPLIT\n         TM    SWITCH,SLOFF        SESSION LOGOFF/CANCEL?\n         BO    *+L'*+8             YES, SKIP\n         CH    R15,=H'8'           ATTENTION?\n         BE    LOOP                YES,... START OVER\n         CH    R15,=H'12'          IS INPUT LONGER THAN BUFFER?\n         BNE   SKCLRQ              NO\n        TCLEARQ INPUT              FLUSH THE TRASH\nSKCLRQ   TM    SWITCH,SLOFF        SESSION LOGOFF/CANCEL?\n         BO    LEAVE               YES,... SPLIT\n         LM    R2,R4,=A(1,REPLY+REPLYL-1,REPLY)\n         CLI   0(R4),X'7D'         ENTER?\n         BNE   LOOP                IF NOT, IGNORE, RESHOW\n         LA    R4,3(R4)            POINT TO KEYWORD ADDRESS\n         CLC   0(L'AKWD1,R4),AKWD1 IS IT RIGHT?\n         BNE   LOOP                NO\n         LA    R4,L'AKWD1(R4)      YES, POINT TO KEYWORD\n         BAS   R14,GETKW           AND GET IT\n         B     LOOP                +0 - NO OR BLANK KEYWORD\n         MVC   KEYW1,WORKC         +4 - OK, KEEP IT\n         CLC   0(L'AKWD2,R4),AKWD2 NEXT KEYWORD ADDRESS RIGHT?\n         BNE   LOOP                NO\n         LA    R4,L'AKWD2(R4)      YES, POINT TO KEYWORD\n         BAS   R14,GETKW           AND GET IT\n         B     LOOP                +0 - NO OR BLANK KEYWORD\n         MVC   KEYW2,WORKC         +4 - OK, KEEP IT\n         CLI   0(R4),0             END DETECTED?\n         BE    CHKKW               YES\n         B     LOOP                NO, WHAT'S THAT?\n         SPACE 1\n*- - - - GET KEYWORD ROUTINE       R14 = LINK REGISTER\n*                                  R2-R4 = SCAN REGISTERS\n*                                  R0-R1 = WORK REGISTERS\n*                        RETURN +0 = NO OR WRONG KEYWORD PROCESS\n*                               +4 = OK, KEYWORD IN \"WORKC\" FIELD\nGETKW    MVC   WORKC,=CL8' '\n         LA    R0,L'WORKC\n         LA    R1,WORKC\nGETKW1   CLC   0(L'SBACODE,R4),SBACODE\n         BE    GETKW2\n         CLI   0(R4),0\n         BE    GETKW2\n         OC    0(1,R1),0(R4)       COPY IN UPPER CASE\n         BXLE  R4,R2,*+L'*+4\n         B     GETKW2\n         LA    R1,1(R1)\n         BCT   R0,GETKW1\nGETKW2   CLC   WORKC,=CL8' '       HOW IS KEYWORD?\n         BER   R14                 WRONG, RETURN +0\n         B     4(R14)              OK, RETURN +4\n         SPACE 1\n*------- CHECK KEYWORDS VALIDITY\n         SPACE 1\nCHKKW    MVC   WORKC,VALUE\n         LA    R1,PLST1\n         L     R15,=V(SETKEY)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR1\n         LA    R1,PLST4\n         L     R15,=V(DECIPH)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR2\n         LA    R1,PLST2\n         L     R15,=V(SETKEY)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR3\n         LA    R1,PLST4\n         L     R15,=V(DECIPH)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR4\n         LA    R1,PLST3\n         L     R15,=V(SETKEY)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR5\n         LA    R1,PLST4\n         L     R15,=V(DECIPH)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR6\n         LA    R1,PLST5\n         L     R15,=V(SETKEY)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR7\n         MVC   KEYW3(L'KEYW3),LOCK+10\n         LA    R1,PLST6\n         L     R15,=V(ENCIPH)\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   ERR8\n         CLC   CONTROL,KEYW3       AND NOW IS IT THOSE KEYWORDS?\n         BE    LEAVE               YES, OK, UNLOCK IT\n         MVC   ERRMSG(21),=CL21'Failed| Mental midget'\n         B     LOOP                ELSE ...\nERR1     MVC   ERRMSG(3),=CL3'1st'\n         MVC   ERRMSG+9(6),=CL6'SETKEY'\n         B     ERRX\nERR2     MVC   ERRMSG(3),=CL3'1st'\n         MVC   ERRMSG+9(6),=CL6'DECIPH'\n         B     ERRX\nERR3     MVC   ERRMSG(3),=CL3'2nd'\n         MVC   ERRMSG+9(6),=CL6'SETKEY'\n         B     ERRX\nERR4     MVC   ERRMSG(3),=CL3'2nd'\n         MVC   ERRMSG+9(6),=CL6'DECIPH'\n         B     ERRX\nERR5     MVC   ERRMSG(3),=CL3'3rd'\n         MVC   ERRMSG+9(6),=CL6'SETKEY'\n         B     ERRX\nERR6     MVC   ERRMSG(3),=CL3'3rd'\n         MVC   ERRMSG+9(6),=CL6'DECIPH'\n         B     ERRX\nERR7     MVC   ERRMSG(3),=CL3'4th'\n         MVC   ERRMSG+9(6),=CL6'SETKEY'\n         B     ERRX\nERR8     MVC   ERRMSG(3),=CL3'End'\n         MVC   ERRMSG+9(6),=CL6'ENCIPH'\nERRX     MVC   ERRMSG+4(4),=CL4'call'\n         MVC   ERRMSG+16(5),=CL5'error'\n         B     LOOP\n         SPACE 1\n*------- CLEAN UP AND GO HOME\n         SPACE 1\nLEAVE   STTMPMD ON,KEYS=NO         RESET\n        ESTAE  0                   RESET\n         OC    STTCBA,STTCBA       SUB-TASK NEVER STARTED?\n         BZ    SKDET               YES\n         CLC   WTRCC,=F'-1'        NO, STARTED, SUB-TASK TERMINATED?\n         BNE   SKDET               YES\n        DETACH STTCBA              NO, FORCE TERMINATE SUB-TASK\nSKDET   $FS    CC=EW,MF=(I,CLEAR)  SET CLEAR SEQUENCE\n         TM    SWITCH,SCRRS        WAS SCREEN SIZE CHANGED?\n         BZ    ENDCL               BRANCH IF NOT\n        STSIZE SIZELOC=SZLINE,LINELOC=SZSCRN RESTORE ORIGINAL SIZE\n        $FS    CC=EWA,MF=(I,CLEAR)\nENDCL   TPUT   CLEAR,CLEARL,FULLSCR,,HOLD CLEAR THE SCREEN\n        STFSMODE OFF               TELL VTAM WE'RE DONE\n         XR    R15,R15             RC=0 -------------------------------\n         B     QUIT\nNOTAUT   LA    R1,NAUTM\n         B     XSMSG\nNOTSCR   LA    R1,NSCRM\n         B     XSMSG\nNOTSTD   LA    R1,NSTDM\nXSMSG    BAS   R14,PUTMSG\nSETRC    LA    R15,16              RC=16 ------------------------------\nQUIT    $XRET  CC=(R15)\n         EJECT\n*------- RECOVERY ROUTINE\n         SPACE 1\n         CNOP  0,8\nINTER    STM   R14,R12,12(R13)\n         BASR  R10,0\n         USING *,R10\n        STTMPMD ON,KEYS=NO         RESET\n        ESTAE  0                   RESET\n         OC    STTCBA,STTCBA       SUB-TASK NEVER STARTED?\n         BZ    SKINT               YES\n         CLC   WTRCC,=F'-1'        NO, STARTED, SUB-TASK TERMINATED?\n         BNE   SKINT               YES\n        DETACH STTCBA              NO, FORCE TERMINATE SUB-TASK\nSKINT    L     R1,24(R13)          RESTORE SDWA ADDRESS\n        SETRP  ,                   CONTINUE WITH TERMINATION\n         LM    R14,R12,12(R13)\n         BR    R14\n         DROP  R10\n         EJECT\n*--------------------------------------------------------------------*\n*        SUB-TASK TO ALLOW A LONGER WAIT LIMIT.                      *\n*--------------------------------------------------------------------*\n         SPACE 1\n         CNOP  0,8\nWTTIME   STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R10,R15             SET BASE REGISTER\n         USING WTTIME,R10\n         LR    R15,R13             PREVIOUS SAVE AREA\n         LA    R13,WTSVA           CURRENT SAVE AREA\n         ST    R13,8(R15)          LINK SAVE AREAS\n         ST    R15,4(R13)\n         LA    R2,WTTWTI\n         ICM   R3,B'1111',WTTNUM\n         BNZ   WTLOOP\nWTLSET   LA    R2,WTLWTI\nWTLOOP   XC    WTTECB,WTTECB\n        STIMER REAL,WTEXIT,BINTVL=(R2) WAIT TIME INTERVAL\n         LTR   R15,R15             DAMAGED CLOCKS?\n         BNZ   WTDCLK              YES\n        WAIT   ECB=WTTECB,LONG=YES\n        TTIMER CANCEL\n         LTR   R15,R15             DAMAGED CLOCKS?\n         BZ    WTDCOK              NO\nWTDCLK   OI    SWITCH,DCLKS        YES, SAY IT\n         B     WTQUIT              GO STOP ALL (TERMINATION)\nWTDCOK   LTR   R3,R3\n         BZ    WTQUIT\n         BCT   R3,WTLOOP           CONTINUE UNTIL ANY MORE ALLOWED\n         OC    WTLWTI,WTLWTI\n         BNZ   WTLSET\nWTQUIT   ST    R15,WTRCC           SAY HOW TERMINATED\n         OI    SWITCH,SLOFF        NO MORE, SAY SESSION LOGOFF/CANCEL\n        TCLEARQ INPUT              FLUSH THE TRASH\n         TM    SWITCH,DCLKS        DAMAGED CLOCKS?\n         BZ    *+L'*+6             NO, SKIP, MESSAGE OK\n         MVC   CMDBUFM,LDMSG       YES\n         L     R15,CVTPTR          CVT POINTER\n         USING CVT,R15\n         L     R1,CVTTVT           TSO VECTOR TABLE ADDRESS\n         DROP  R15\n         USING TSVT,R1\n         L     R15,TSVTASF         TSO SERVICE ROUTINE ADDRESS\n         DROP  R1\n        CALL   (15),(SFLGS,CMDBUF,BUFLN,RTCC,RSCC,ABCC),VL\n         LR    R3,R15              RETAIN ALL CC'S\n         LM    R4,R6,RTCC\n        ZEROKEY\n         XR    R0,R0               SEND COMMAND\n         XR    R15,R15\n         LA    R2,CMND             COMMAND BUFFER ADDRESS\n        MGCR   (R2)\n         LR    R2,R15              SAVE RETURN CODE\n        RESETKEY\n         LTR   R2,R2               CHECK RETURN CODE?\n         BNZ   WTTERR              BAD RETURN CODE FROM MGCR\n         L     R13,4(R13)          PREVIOUS SAVE AREA\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         MVI   12(R13),X'FF'       SET RETURN INDICATOR\n         XR    R15,R15             SET RETURN CODE\n         BR    R14                 RETURN\nWTTERR   XR    R7,R7               NORMALLY NEVER COME HERE\n         XR    R8,R8               (CLEAR ALL REGISTERS UNLESS CC'S)\n         XR    R9,R9\n         XR    R10,R10\n         XR    R11,R11\n         XR    R12,R12\n         XR    R13,R13\n         XR    R14,R14\n         XR    R15,R15\n        ABEND  522,,STEP           KILL MYSELF\n         DROP  R10\n         SPACE 1\n*------- TIMER EXIT ROUTINE\n         SPACE 1\n         CNOP  0,8\n         USING *,R15\nWTEXIT  POST   WTTECB\n         BR    R14\n         DROP  R15\n         SPACE 1\n*------- SUB-TASK CONSTANTS\n         SPACE 1\nWTSVA    DC    18F'0'              SUB-TASK SAVE AREA\nWTRCC    DC    F'0'                SUB-TASK TERMINATION CODE\nWTTECB   DC    F'0'                TIMER ECB\nWAKEUP   DC    F'0'                TIMER WAIT TIME INTERVAL (SECONDS)\nWTTNUM   DC    F'0'                NUMBER OF WAKE-UP INTERVAL\nWTLWTI   DC    F'0'                LAST WAKE-UP TIME INTERVAL\nWTTWTI   DC    F'0'                TIMER WAIT TIME INTERVAL\nSFLGS    DC    0F'0',H'0',X'00',X'01' (NO DUMP, TSO COMMAND)\nBUFLN    DC    A(CMDBUFL)          COMMAND LENGTH\nRTCC     DC    F'0' ----------->=> RETURN CODE FROM COMMAND 1\nRSCC     DC    F'0'            >   REASON CODE\nABCC     DC    F'0' ----------->   ABEND CODE\nLDMSG    DC    C'damaged clocks has occured'\nCMDBUF   DC    C'SEND '' LOCK : '  COMMAND 1\nCMDBUFM  DC    C'max. WAIT time has expired'\n         DC    C' / Code U0522 '' USER('\nCMDBUFU  DC    CL8' ',C' SAVE'\nCMDBUFL  EQU   *-CMDBUF\nCMND     DC    0F'0',XL1'0'        FLAGS1\nCMNDL    DC    AL1(LCMND),XL2'0'   BUFFER LENGTH, FLAGS2\nCMNDT    DC    CL18'CANCEL U= '    COMMAND TEXT\nCMNDU    EQU   CMNDT+9,8\nLCMND    EQU   *-CMND\n         SPACE 1\nSWITCH   DC    XL1'0'              PROCESS INDICATORS\nSCRST    EQU   X'80'                    SCREEN SIZE TO BE SET\nSCRRS    EQU   X'40'                    SCREEN SIZE TO BE RESET\nSLOFF    EQU   X'08'                    SESSION LOGOFF/CANCEL\nDCLKS    EQU   X'01'                    DAMAGED CLOCKS\n         EJECT\n*------- CONSTANTS AND WORK-AREAS\n         SPACE 1\nWORKD    DC    D'0'\n        $TEW$WA\nWORKF    DC    F'0'\nSTTCBA   DC    A(*-*)              SUB-TASK TCB ADDRESS\nSZLINE   DC    F'0'                LINE SIZE (LINE LENGTH)\nSZSCRN   DC    F'0'                SCREEN SIZE (NUMBER OF LINES)\nREQAUT   DC    0F'0',BL1'00010000',AL3(MDL@IX),AL4(XAUTH)\nMAXWT    DC    F'0'                MAXIMUM WAIT TIME DESIRED (SECONDS)\nPLST0    DC    A(WORKC)\nPLST1    DC    A(KEYW2)\nPLST2    DC    A(KEYW1)\nPLST3    DC    A(XUSNME)\nPLST4    DC    A(WORKC,*+4,L'WORKC)\nPLST5    DC    A(WORKC)\nPLST6    DC    A(KEYW3,*+4,L'KEYW3)\nCONTROL  DC    XL8'E4CC2344D8B579B8'\nVALUE    DC    CL8' '\nWORKC    DC    CL8' '\nKEYW1    DC    CL8' '\nKEYW2    DC    CL8' '\nKEYW3    DC    CL8' '\n         SPACE 1\nREPLY    DS    0F             AREA TO HOLD TGET REPLY (MAX. LENGTH)\n         DC    XL3'0'              AID + CURSOR ADDRESS\n         DC    XL11'0'             1ST FIELD ADDRESS + KEYWORD REPLY\n         DC    XL11'0'             2ND FIELD ADDRESS + KEYWORD REPLY\n         DC    XL4'0'              FILLER\nREPLYL   EQU   (*-REPLY)-1\n         SPACE 1\nXAUTH    DC    XL1'0' --------->=> $EACM RESPONSE LIST\nXUSNME   DC    CL8' '          >\nXGRNME   DC    CL8' ' --------->\n         SPACE 1\nWSCR     $FS   CC=W,WCC=(KBR,RMDT),SBA=(24,80),MF=L SET BUFFER/CLEAR\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(2,28),TEXT='Terminal',MF=L\n         $FS   SF=(INT,SKIP),TEXT='\"LOCKED\"',MF=L\n         $FS   SF=(SKIP),TEXT='at',MF=L\n         $FS   SF=(INT,SKIP),MF=L\nHHMM     $FS   TEXT='  .  ',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(7,8),TEXT='To',MF=L\n         $FS   SF=(INT,SKIP),TEXT='unlock',MF=L\n         $FS   SF=(SKIP),TEXT='this terminal,',MF=L\n         $FS   SF=(INT,SKIP),TEXT='ENTER',MF=L\n         $FS   SF=(SKIP),TEXT='below the',MF=L\n         $FS   SF=(INT,SKIP),TEXT='TWO',MF=L\n         $FS   SF=(SKIP),TEXT='top-secret keywords :',MF=L\n         $FS   SBA=(12,31),SF=(INT,SKIP),TEXT='===>',MF=L\n         $FS   SF=(DARK),MF=L      1ST KEYWORD\n         $FS   SBA=(12,45),SF=(INT,SKIP),TEXT='<===',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(13,31),SF=(INT,SKIP),TEXT='===>',MF=L\n         $FS   SF=(DARK),MF=L      2ND KEYWORD\n         $FS   SBA=(13,45),SF=(INT,SKIP),TEXT='<===',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(18,1),TEXT='User-ID :',MF=L\n         $FS   SF=(INT,SKIP),MF=L\nUSERID   $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(SKIP),TEXT='       RACF-group :',MF=L\n         $FS   SF=(INT,SKIP),MF=L\nGROUPN   $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(SKIP),TEXT='       Terminal-name :',MF=L\n         $FS   SF=(INT,SKIP),MF=L\nTERMNAME $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(19,1),TEXT='User-name :',MF=L\n         $FS   SF=(INT,SKIP),MF=L\nUSERNAME $FS   TEXT=(' ',60),MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(22,30),SF=(INT,SKIP),MF=L\nERRMSG   $FS   TEXT=(' ',21),MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(1,1),SF=(PT,IC),MF=L\nWSCRL    EQU   *-WSCR\n         SPACE 1\nCLEAR   $FS    CC=EW,WCC=(AL,KBR,RMDT),SBA=(24,79),MF=L\nSBACODE  EQU   *,1\n        $FS    SBA=(1,1),RA=(1,1,00),MF=L\n        $FS    SF=(INT,IC),MF=L\nCLEARL   EQU   *-CLEAR\n         SPACE 1\nAKWD1   $FS    SBA=(12,37),MF=L\nAKWD2   $FS    SBA=(13,37),MF=L\n         SPACE 1\n         PRINT NOGEN\nNAUTM   WTO    ' LOCK : not authorized command',                       X\n               ROUTCDE=11,DESC=7\nNSCRM   WTO    ' LOCK : run only on a screen terminal',                X\n               ROUTCDE=11,DESC=7\nNSTDM   WTO    ' LOCK : want to be screen sized 24 x 80',              X\n               ROUTCDE=11,DESC=7\nMSGER   WTO    ' LOCK :        error - RC (R15) =    ',                X\n               ROUTCDE=11,DESC=7\nMSGERN   EQU   MSGER+12,6\nMSGERC   EQU   MSGER+37,3\nMSGTW   WTO    ' LOCK : loaded table wrong identification',            X\n               ROUTCDE=11,DESC=7\nMSGTE   WTO    ' LOCK : loaded table is empty',                        X\n               ROUTCDE=11,DESC=7\nMSGNT   WTO    ' LOCK : not defined in loaded table',                  X\n               ROUTCDE=11,DESC=7\n         PRINT GEN\n         SPACE 1\n*------- LITERALS POOL\n         SPACE 1\n        LTORG\n         SPACE 1\n*------- DSECT'S DEFINITION\n         SPACE 1\n         PRINT NOGEN\n        $TEW$DS CVT=YES\n        IHAPSA\n        IHAASCB\n        IHAASXB\n        IHAACEE\n        IKJTSVT\n        IEESMCA\n        IHASDWA\n         PRINT GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOCK$": {"ttr": 21764, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x11\\x07\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T11:07:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SYSPAJA"}, "text": "//LOCK     JOB (........),'INSTALL - L O C K -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL   KUMX      R050A90                        *\n//*       NOTE : \"KUMX\" MUST BE INSTALLED BEFORE (SEE \"LOCKT\").       *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=LOCK\n//LNK     EXEC PAJILKC\n//SYSIN     DD *\n  INCLUDE SYSADD(R050A90)\n  ENTRY   LOCK\n  NAME    LOCK(R)\n/*\n//ASST    EXEC PAJIAS2,MBR=LOCKT\n//LNKT    EXEC PAJILKC\n//SYSIN     DD *\n  ENTRY   LOCKT\n  NAME    LOCKT(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOCK@": {"ttr": 21766, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x931o\\x00\\x931o\\x11A\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-11-12T00:00:00", "modifydate": "1993-11-12T11:41:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "1   11/11/93\n                                                      LOCK      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    TSO COMMAND TO LOCK TERMINAL.    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    TSO command to LOCK terminal (restricted to only\n  ---------    authorized users : SYSTEM group).\n\n               Function : terminal is locked until the correct two\n                          secret keywords are typed in, or, the SESSION\n                          is terminated when the elapsed maximum WAIT\n                          time (2 hours) has expired (it is decremented\n                          continuously in REAL time from the moment the\n                          LOCK command is invoked, even if somebody\n                          push (unlock failure) the ENTER key.\n\n               Mandatory : if you are an authorized user, you must\n                          contact the SYSTEM group manager, to define\n                          your two secret keywords, unless you cannot\n                          use this command.\n\n  Syntax :     LOCK\n  --------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOCKT": {"ttr": 21768, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x932\\x0f\\x00\\x932\\x0f\\x12\\x06\\x004\\x004\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-11-16T00:00:00", "modifydate": "1993-11-16T12:06:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "SYSPAJA"}, "text": "LCKT     TITLE '* * *   L O C K T   * * *'\nLOCKT    START 0\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* Purpose :    LOCK TSO-command table (private use only).             *\n*              Authorized users must be defined in this table.        *\n*                                                                     *\n* Author :     MOINIL P.A.                                            *\n*              Computing Centre (TP 361)                              *\n*              J.R.C. - Ispra Establishment                           *\n*              21020 Ispra (VA), Italy                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n*------- DEFINITION : SESSION IS TERMINATED WHEN THE HERE BELOW DEFINED\nMAXWT    EQU   120        MAXIMUM WAIT TIME (MINUTES) HAS EXPIRED.\n         SPACE 1\n         DC    A(UKSCT,L'UKSCT,UKSCTEND) TABLE SCAN BXLE VALUES\n         DC    A(MAXWT*60)         MAXIMUM WAIT TIME (SECONDS)\n         SPACE 1\n        $IDENT ID=LCKT             TABLE (MODULE) IDENTIFICATION\n         EJECT\n*---------------------------------------------------------------------*\n* How to define the keywords user mask :                              *\n* ======================================                              *\n*        1. Anywhere you desire, between the lines labeled \"UKSCT\"    *\n*           and \"UKSCTEND\", so in the users keywords table, insert    *\n*           a line starting with an asterisk (comment line) in column *\n*           1 followed by the USER-ID and his TWO SECRET KEYS you     *\n*           want define (each separated from the other by at least a  *\n*           blank). I.e., assuming a USER-ID name \"ZULU\" and the TWO  *\n*           SECRET KEYWORDS \"ALPHA\" and \"BETA\" (which must be given   *\n*           in the same order to UNLOCK terminal), insert the line :  *\n*                         *    ZULU  ALPHA  BETA                      *\n*        2. Then type KUMX (this is an ISPF Edit macro name) in the   *\n*           COMMAND line, place the CURSOR somewhere on the previous  *\n*           inserted line, and push ENTER.                            *\n*           This function insert just after the line you have pointed *\n*           the needed masked constant.                               *\n*        3. Finally, delete the inserted comment line with USER-ID    *\n*           and his SECRET KEYS.                                      *\n*        Repeat these steps for all USER-ID's and couple of KEYS you  *\n*        have to define.                                              *\n*---------------------------------------------------------------------*\n         SPACE 1\nUKSCT    EQU   *,16                USERS KEYWORDS SECRET CODE TABLE\n*------> INSERT HERE AFTER USER-ID'S AND COUPLE OF SECRET KEYS <------*\n         SPACE 1\nUKSCTEND EQU   *-L'UKSCT\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGALLO$": {"ttr": 21770, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14\"\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:22:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//LOGALLOC JOB (........),'INSTALL - LOGALLOC -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=6\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=LOGALLOC\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT'\n//SYSIN     DD *\n  ENTRY   LOGALLOC\n  NAME    LOGALLOC(R)\n/*\n//HLP     EXEC PAJHELP,MBR=LOGALLOH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOGALLO@": {"ttr": 21772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14R\\x00-\\x00-\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:52:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/07/90\n                                                      LOGALLOC  1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        LOGALLOC TSO command         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Command name :      LOGALLOC\n  Author :            Mr Lionel Dyck of Rockwell International\n  Origin :            Extracted from tape CBT 89 FEB, file 437\n                      Adapted by MOINIL P.A.\n  Function :          The LOGALLOC command is to mark all currently\n                      allocated data-sets as permanently allocated.\n                      Data-sets marked permanently allocated are not\n                      freed by the FREE ALL command. They may, however,\n                      be explicitly freed by using the FREE command\n                      and specifying the data-set name (DSNAME).\n\n  Syntax :\n  --------------------------------------------------------------------\n  Command    Operands\n  --------------------------------------------------------------------\n  LOGALLOC   FILE(file-name-list)\n        or   DDNAME(file-name-list)\n  --------------------------------------------------------------------\n\n  Operands :\n     Required - None\n     Default  - None\n\n     file-name-list = DDNAME's list.\n                      Note : if FILE(file-name-list)\n                             or DDNAME(file-name-list)\n                      is entered, only the data-sets in the list are\n                      marked permanently allocated, otherwise, all\n                      dynamically allocated data-sets are marked.\n              Example :\n                 LOGALLOC DDNAME(DD1 DD2 DD3 DD4 DD5)\n              Aliases : DDN, DD, D, FI or F.\n\n  Return codes :  0 - successfully done.\n                  8 - PARSE error.\n                 12 - don't have any data-sets to be processed.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGALLOC": {"ttr": 21774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x13\\x0f\\x00\\x94\\x13\\x0f\\x160\\x00\\xa3\\x00\\xa3\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-10T00:00:00", "modifydate": "1994-05-10T16:30:00", "lines": 163, "newlines": 163, "modlines": 0, "user": "SYSPAJA"}, "text": "UVLA     TITLE 'U V L A -- LOGALLOC TSO-COMMAND.'\nLOGALLOC START 0\n         SPACE 1\n*--------------------------------------------------------------------*\n*                          L O G A L L O C                           *\n*--------------------------------------------------------------------*\n* NAME :       LOGALLOC                                              *\n* ATTRIBUTES : RENT                                                  *\n* ORIGIN :     EXTRACTED FROM TAPE CBT 89 FEB, FILE 437.             *\n*              ADAPTED BY : MOINIL P.A.                              *\n* DESCRIPTION :                                                      *\n*        THE 'LOGALLOC' COMMAND IS USED IN CONJUNCTION WITH THE      *\n*        COMMAND LOGON PROCEDURE.                                    *\n*        LOGALLOC MARKS SOME OR ALL DATA-SETS WHICH ARE ALLOCATED    *\n*        AT THE TIME IT IS INVOKED AS BEING PERMANENTLY ALLOCATED.   *\n*        THIS MEANS THAT THE 'FREE ALL' COMMAND WILL NOT FREE THEM,  *\n*        AND ALLOWS A USER TO CONCATENATE HIS OWN HELP, CLIST,       *\n*        ETC..., DATA-SETS TO THE NORMAL ONES, EFFECTIVELY CREATING  *\n*        A CUSTOMIZED LOGON PROCEDURE.                               *\n*        NOTE THAT THE STEPLIB IS NOT PERMITTED TO BE CHANGED BY     *\n*        THIS TECHNIQUE, SINCE IT IS OPENED BY THE INTIATOR.         *\n*        IF A  FILE(FILE-NAME-LIST) OR DDNAME(FILE-NAME-LIST)        *\n*        IS ENTERED, ONLY THE DDNAMES IN THE LIST ARE MARKED         *\n*        PERMANENTLY ALLOCATED, OTHERWISE, ALL DYNAMICALLY           *\n*        ALLOCATED DATA-SETS ARE MARKED.                             *\n*--------------------------------------------------------------------*\n         SPACE 1\nLOGALLOC AMODE 24\nLOGALLOC RMODE 24\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=LDYNAMIC,TYPE=RENT\n         LR    R9,R13\n         USING WRKDSECT,R9\n         MVI   FLAG,0              CLEAR FLAG\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n        $TEW$PP PARM=PARMLST,REG=R4,ERR=PARSERR,ATT=PARSERR\n         SPACE 1\n*------- CHECK FOR A FILE-NAME LIST.\n         SPACE 1\n         CLI   FILE+1,0            SPECIFIED?\n         BE    *+L'*+12            NO\n         LA    R4,DDNAMES          GET PLACE\n         TM    6(R4),X'80'         EXIST?\n         BO    *+L'*+2             YES\n         XR    R4,R4               ZERO IT\n         DROP  R4\n         SPACE 1\n*------- FIND THE DSAB CHAIN.\n         SPACE 1\n         ST    R4,SAVER4\n         L     R2,CVTPTR           CVT ADDR\n         USING CVTMAP,R2\n         L     R2,CVTTCBP          TCB-TCB ADDR (TCBHEAD)\n         DROP  R2\n         L     R2,4(,R2)           TCB ADDR (CURRENT TCB)\n         USING TCB,R2\n         L     R2,TCBJSCB          JOB STEP CONTROL BLOCK ADDR\n         DROP  R2\n         USING IEZJSCB,R2\n         L     R2,JSCDSABQ         LOAD ADDRESS OF QDB FOR DSAB CHAIN\n         CLC   8(4,R2),=XL4'0'     ZERO DATA-SETS FOR THIS USER\n         BNE   DSOK\n         LA    R0,L'BADREQ         IF HE DONT HAVE ANY WE CANT PERM EM\n         LA    R1,BADREQ           SO SET RC=12\n         BAS   R14,PUTLNE\n         LA    R2,12               RC=12 -----------------------------\n         B     LEAVE\n         DROP  R2\nDSOK     L     R2,12(R2)           LOAD ADDRESS OF FIRST DSAB\n         USING DSAB,R2\n         SPACE 1\n*------- LOOP THROUGH THE DSABS. IF DYNAMICALLY ALLOCATED, MARK THEM\n*              PERMANENTLY ALLOCATED.\n*              IF A FILE-NAME LIST WAS SPECIFIED, ONLY MARK THE ONES\n*              IN THE LIST.\n         SPACE 1\nINLOOP   TM    DSABFLG1,DSABDALC   DATA-SET DYNAMICALLY ALLOCATED\n         BZ    NOPERM              NO, GO LOOK AT NEXT ONE\n         ICM   R4,B'1111',SAVER4\n         BZ    PERM                NO PARM, MARK THEM ALL\n         L     R15,DSABTIOT        POINT TO TIOT\n         USING TIOELNGH,R15\n         CLI   TIOEDDNM,C' '       PART OF A CONCAT GROUP?\n         BNE   RESETFLG            NO, CHECK THE LIST\n         TM    FLAG,FCG            IS THE CONCAT GROUP FLAG ON?\n         BO    PERM                YES, GO MARK THIS ONE\nRESETFLG NI    FLAG,255-FCG        TURN OFF THE FLAG\nDDLOOP   L     R14,0(R4)           PARSED DDNAME\n         LH    R1,4(R4)            PARSED LENGTH\n         BCT   R1,*+L'*+6          DECREMENT LENGTH\n         CLC   0(*-*,R14),TIOEDDNM <<EXECUTED>>\n         EX    R1,*-6              IS THIS DDNAME REQUESTED ?\n         BE    PERM                YES, GO MARK IT PERM\n         CLI   8(R4),X'FF'         END OF LIST?\n         BE    NOPERM              YES, GET NEXT DSAB\n         L     R4,8(R4)            NO, GET NEXT PARSE PDE\n         B     DDLOOP\n         DROP  R15\n         SPACE 1\n*------- MARKS THE DATA-SET PERMANENTLY ALLOCATED.\n         SPACE 1\nPERM    STAX   DEFER=YES           NO ATTN WHILE WE ARE AUTHORIZED\n        ZEROKEY ,                  ENTER KEY ZERO\n         NI    DSABFLG1,X'FF'-DSABDALC INDICATE NO DYNAMICALLY ALLOC'D\n        RESETKEY ,                 RE-ENTER PROBLEM KEY\n        STAX   DEFER=NO\n         OI    FLAG,FCG            TURN ON FLAG FOR CONCAT GROUP\nNOPERM   L     R2,DSABFCHN         LOAD POINTER TO NEXT DSAB ENTRY\n         LTR   R2,R2               END OF CHAIN ?\n         BNZ   INLOOP              NO, KEEP LOOKING\n         DROP  R2\n         SPACE 1\n*------- CLEANUP AND EXIT.\n         SPACE 1\n         XR    R2,R2               RC=0 -------------------------------\n         B     LEAVE\nPARSERR  LA    R2,8                RC=8 -------------------------------\nLEAVE   IKJRLSA #TSANSW            FREE UP CORE\nQUIT    $XRET  CC=(R2),LV=LDYNAMIC,TYPE=RENT DIE\nSETRC    LA    R2,16               RC=16 ------------------------------\n         B     QUIT\n         EJECT\n*------- CONSTANTS, DSECT'S, ETC...\n         SPACE 1\nBADREQ   DC    C' -> NO DATA-SETS STATUS, LOGALLOC FAILED'\n         SPACE 1\n        LTORG\n         SPACE 1\n        PRINT  NOGEN\nPARMLST IKJPARM\nFILE    IKJKEYWD\n        IKJNAME 'FILE',SUBFLD=DDNAME$,ALIAS=('FI','F')\n        IKJNAME 'DDNAME',SUBFLD=DDNAME$,ALIAS=('DDN','DD','D')\nDDNAME$ IKJSUBF\nDDNAMES IKJIDENT 'DDNAME(S) TO BE MARKED AS PERMANENT',                X\n               LIST,                                                   X\n               MAXLNTH=8,                                              X\n               PROMPT='FILE NAME(S) TO MARK PERMANENT',                X\n               HELP='DDNAMES WHICH SHOULD BE PERMANENTLY ALLOCATED',   X\n               OTHER=ALPHANUM\n        IKJENDP\n        PRINT  GEN\n         SPACE 1\nWRKDSECT DSECT\n         DS    18F                 FIRST S.A.\n        $TEW$WA\nSAVER4   DS    F\nWKLINE   DS    CL60\nFLAG     DS    X                   SWITCH\nFCG      EQU   X'80'\n         SPACE 1\nLDYNAMIC EQU   (((*-WRKDSECT)+7)/8)*8\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS TIOT=YES\n        IKJTCB\n        IEZJSCB\nDSAB    IHADSAB\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOGALLOH": {"ttr": 21778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(?\\x00\\x90(?\\x14U\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-10T00:00:00", "modifydate": "1990-10-10T14:55:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=LOGALLOC\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  the LOGALLOC command is to mark all currently allocated\n               data-sets as permanently allocated.\n               Data-sets marked permanently allocated are not freed by\n               the FREE ALL command. They may, however, be explicitly\n               freed by using the FREE command and specifying the\n               data-set name (DSNAME).\n)X SYNTAX :    LOGALLOC FILE(FILE-NAME-LIST) or DDNAME(FILE-NAME-LIST)\n               Example : LOGALLOC DDNAME(DD1 DD2 DD3 DD4 DD5)\n)O OPERANDS :  Required - None\n               Default  - None\n               Note : If FILE(FILE-NAME-LIST) or DDNAME(FILE-NAME-LIST)\n                      is entered, only the data-sets in the list are\n                      marked permanently allocated, otherwise, all\n                      dynamically allocated data-sets are marked.\n))FILE(FILE-NAME-LIST) or DDNAME(FILE-NAME-LIST) : DDNAME's list.\n               Aliases : DDN, DD, D, FI or F.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MBKS00": {"ttr": 21780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893?\\x00\\x893?\\x14I\\x00W\\x00W\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-29T00:00:00", "modifydate": "1989-11-29T14:49:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "SYSPAJA"}, "text": "MBKS001N 'Table not found' .ALARM=YES\n'Manuals list table does not exist (must be created).'\nMBKS001R 'Table in use' .ALARM=YES\n'Manuals list table is in use by another user.'\nMBKS001S 'Catastrophic error' .ALARM=YES\n'Error creating Manuals list table. Return code was &RC..'\nMBKS001T 'Manuals list created' .ALARM=YES\n'Manual list table was not found and has been created (empty).'\n\nMBKS002C 'Updates not saved' .ALARM=YES\n'Manuals list utility ended through \"CANCEL\". Updates were not saved.'\nMBKS002N 'Manuals list done'\n'Manuals list normal end. No updates were entered since last \"SAVE\".'\nMBKS002S 'Updates saved'\n'Manuals list utility normal end. Updates were saved.'\n\nMBKS003D 'Invalid destination' .ALARM=YES\n'Invalid print destination. Enter it as U## or R## (e.g. R41).'\nMBKS003E 'Invalid command' .ALARM=YES\n'Valid commands : INPUT, TNL, LST, FULL, SORT, FIND, CANCEL, END or SAVE.'\nMBKS003L 'Invalid command' .ALARM=YES\n'Enter a valid line command : D, R, S, T or U.'\nMBKS003P 'Print complete'\n'The Manuals list has been sent for printing.'\nMBKS003S 'Invalid SORT field' .ALARM=YES\n'Valid SORT fields : KEY-1, KEY-2, MANUAL, LOCATION, DATE, ROOM.'\nMBKS003T 'Unauthorized' .ALARM=YES\n'Manuals list table update is restricted use, sorry.'\nMBKS003U 'Unavailable' .ALARM=YES\n'Manuals list table update has not been declared, sorry.'\n\nMBKS004A 'Missing Manual' .ALARM=YES\n'Enter an IBM Manual number or a Manual name.'\nMBKS004B 'Manual conflict' .ALARM=YES\n'Enter only an IBM Manual number or only a Manual name.'\nMBKS004C 'Invalid TNL' .ALARM=YES\n'Enter correct TNL no. format (GGGG-NNNN) followed by blank, P or I.'\nMBKS004D 'Invalid date' .ALARM=YES\n'Enter date as \"DDMMMYY\" (e.g. 01JAN85) or leave it blank.'\nMBKS004E 'Invalid TNL' .ALARM=YES\n'Enter correct TNL no. format (GGGG-NNNN).'\nMBKS004M 'Update bypassed'\n'No changes to entry \"&CBMNO\" has been entered.'\nMBKS004N 'Update canceled'\n'Update to entry \"&CBMNO\" has been canceled.'\nMBKS004S 'Update done'\n'Update to entry \"&CBMNO\" has been done.'\nMBKS004T 'Manual incomplete' .ALARM=YES\n'Complete the IBM Manual number (format is GGGG - NNNN - S or SS).'\nMBKS004U 'Update failed'\n'Newsletters update to entry \"&CBMNO\" has been canceled.'\n\nMBKS005R 'Manuals list sorted'\n'The current Manuals list has been sorted using the SORT fields shown.'\nMBKS005S 'Manuals list saved'\n'The current Manuals list has been saved. You may continue updating.'\n\nMBKS006A 'Manual conflict' .ALARM=YES\n'Enter only an IBM Manual number or only a Manual name.'\nMBKS006B 'Manual incomplete' .ALARM=YES\n'Complete the IBM Manual number (format is GGGG - NNNN - S or SS).'\nMBKS006C 'None selected' .ALARM=YES\n'At least one argument field must be set for the FIND command.'\nMBKS006D 'Invalid date' .ALARM=YES\n'Enter date as \"DDMMMYY\" (e.g. 01JAN85).'\nMBKS006E 'Invalid request' .ALARM=YES\n'Only one argument field is acceptable by the FIND command.'\nMBKS006L 'Not found' .ALARM=YES\n'Location argument search field results as not found anywhere.'\nMBKS006M 'Not found' .ALARM=YES\n'Manual argument search field results as not found anywhere.'\nMBKS006N 'Not found' .ALARM=YES\n'Title argument search field results as not found anywhere.'\nMBKS006R 'Not found' .ALARM=YES\n'Room argument search field results as not found anywhere.'\nMBKS006S 'Not found' .ALARM=YES\n'Date argument search field results as not found anywhere.'\nMBKS006T 'Not found' .ALARM=YES\n'TNL no. argument search field results as not found anywhere.'\nMBKS006X 'Not allowed' .ALARM=YES\n'CONT command is allowed only after a FIND Title argument search only.'\nMBKS006Z 'No more' .ALARM=YES\n'Continue of Title argument search field is now exhausted.'\nMBKS0061 'Not found' .ALARM=YES\n'Key-1 argument search field results as not found anywhere.'\nMBKS0062 'Not found' .ALARM=YES\n'Key-2 argument search field results as not found anywhere.'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MOVECOL@": {"ttr": 22017, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\x11\\x19\\x003\\x003\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T11:19:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "SYSPAJA"}, "text": "1   25/10/94\n                                                      MOVECOLS  1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    MOVECOLS ISPF/PDF EDIT command   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to move columns+within the\n  ----------   data lines :\n               1 - using the \"S\" range command to shift the data text,\n                   or\n               2 - using the \"X\" range command to exchange the data\n                   text.\n\n  Command syntax : MOVECOLS START STOP TO\n  ----------------      (start, stop and destination columns numbers)\n                   MOVECOLS HELP or H\n\n  Uses :    1. First, mark the range of lines containing the columns\n  ------       to be shifted with the \"S\" range command on the line\n               numbers, then type on the COMMAND line MOVECOLS with\n               START, STOP and TO operands, as i.e. :\n               COMMAND ===> MOVECOLS 11 20 31\n               Before ************** TOP OF DATA **********************\n               =COLS> ----+----1----+----2----+----3----+----4----+-...\n               SS 001 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEE...\n               000002 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEE...\n               SS 003 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEE...\n               After *************** TOP OF DATA **********************\n               =COLS> ----+----1----+----2----+----3----+----4----+-...\n               000001 AAAAAAAAAACCCCCCCCCCDDDDDDDDDDBBBBBBBBBBEEEEEE...\n               000002 AAAAAAAAAACCCCCCCCCCDDDDDDDDDDBBBBBBBBBBEEEEEE...\n               000003 AAAAAAAAAACCCCCCCCCCDDDDDDDDDDBBBBBBBBBBEEEEEE...\n\n            2. Mark the range of lines containing the columns to\n               be exchanged with the \"X\" range command on the line\n               numbers, then type on the COMMAND line MOVECOLS with\n               START, STOP and TO operands, as i.e. :\n               COMMAND ===> MOVECOLS 11 20 31\n               Before ************** TOP OF DATA **********************\n               =COLS> ----+----1----+----2----+----3----+----4----+-...\n               X3 001 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEE...\n               000002 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEE...\n               000003 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEE...\n               After *************** TOP OF DATA **********************\n               =COLS> ----+----1----+----2----+----3----+----4----+-...\n               000001 AAAAAAAAADDDDDDDDDDDCCCCCCCCCCBBBBBBBBBBEEEEEE...\n               000002 AAAAAAAAADDDDDDDDDDDCCCCCCCCCCBBBBBBBBBBEEEEEE...\n               000003 AAAAAAAAADDDDDDDDDDDCCCCCCCCCCBBBBBBBBBBEEEEEE...\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MOVECOLS": {"ttr": 22019, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x7f\\x00\\x94)\\x7f\\x164\\x00b\\x00b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-24T00:00:00", "modifydate": "1994-10-24T16:34:00", "lines": 98, "newlines": 98, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT MACRO (START STOP TO) NOPROCESS\n/*  MACRO NAME : MOVECOLS                                           */\n/* DESCRIPTION : EDIT MACRO TO MOVE COLUMNS WITHIN A DAT-SET        */\n/*  CBT ORIGIN : EXTRACTED FROM CBT TAPE 94 AUG, FILE 095           */\n/*  ADAPTED BY : MOINIL P.A.                                        */\n         IF (&STR(&START) EQ &STR(HELP)) OR +\n           (&STR(&START) EQ &STR(H)) THEN DO\n           ISPEXEC CONTROL DISPLAY SAVE\n           ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTMVC)\n           SET &MVCCC = &LASTCC\n           ISPEXEC CONTROL DISPLAY RESTORE\n           GOTO XEND\n           END\n         ISPEXEC CONTROL ERRORS RETURN\n         CONTROL ASIS\n         ISREDIT PROCESS RANGE S X\n         SET LCC = &LASTCC\n         ISREDIT (RC) = RANGE_CMD\n         IF &LASTCC = 4 OR (&STR(&RC) NE &STR(S) AND +\n           &STR(&RC) NE &STR(X)) THEN DO\n           SET &ZEDSMSG = NO RANGE\n           SET &ZEDLMSG = SPECIFY A RANGE OF LINES USING \"S\" OR \"X\"\n           GOTO XERR\n           END\n         IF &STOP EQ &Z OR &START EQ &Z OR &TO EQ &Z THEN DO\n           SET &ZEDSMSG = MISSING\n           SET &ZEDLMSG = SPECIFY THE \"START STOP TO\" COLUMNS OF DATA\n           GOTO XERR\n           END\n         IF &START GT &STOP THEN DO\n           SET &ZEDSMSG = INVALID\n           SET &ZEDLMSG = YOU HAVE SPECIFIED \"START\" GREATER THAN +\n             \"STOP\"\n           GOTO XERR\n           END\n         ISREDIT (DW) = DATA_WIDTH\n         ISREDIT (LB,RB) = BOUNDS\n         IF &START LT &LB THEN DO\n           SET &ZEDSMSG = OUTBOUNDS\n           SET &ZEDLMSG = \"START\" SPECIFIED OUT OF LEFT BOUNDARY\n           GOTO XERR\n           END\n         IF &STOP GT &RB THEN DO\n           SET &ZEDSMSG = OUTBOUNDS\n           SET &ZEDLMSG = \"STOP\" SPECIFIED OUT OF RIGHT BOUNDARY\n           GOTO XERR\n           END\n         IF &TO LT &LB THEN DO\n           SET &ZEDSMSG = OUTBOUNDS\n           SET &ZEDLMSG = \"TO\" SPECIFIED OUT OF LEFT BOUNDARY\n           GOTO XERR\n           END\n         IF &TO GT &RB THEN DO\n           SET &ZEDSMSG = OUTBOUNDS\n           SET &ZEDLMSG = \"TO\" SPECIFIED OUT OF RIGHT BOUNDARY\n           GOTO XERR\n           END\n         SET TL = &TO + (&STOP - &START)\n         IF &TL  GT &RB THEN DO\n           SET &ZEDSMSG = OUTBOUNDS\n           SET &ZEDLMSG = \"TO\" END TARGET OUT OF RIGHT BOUNDARY\n           GOTO XERR\n           END\n         ISREDIT (FR) = LINENUM .ZFRANGE\n         ISREDIT (LR) = LINENUM .ZLRANGE\n         SET I = &FR\n         DO WHILE  &I LE &LR\n           ISREDIT (LN) = LINE &I\n           SET SEGX = &STR(&SUBSTR(&START:&STOP,&NRSTR(&LN)))\n           IF &STR(&RC) EQ &STR(S) THEN DO\n             IF &START = 1 THEN SET &SEG1 = &Z\n             ELSE SET SEG1 = &STR(&SUBSTR(1:&START-1,&NRSTR(&LN)))\n             SET SEG2 = &STR(&SUBSTR(&STOP+1:&DW,&NRSTR(&LN)))\n             SET &LO = &NRSTR(&SEG1&SEG2)\n             IF &TO = 1 THEN SET &SEG1 = &Z\n             ELSE SET SEG1 = &STR(&SUBSTR(1:&TO-1,&NRSTR(&LO)))\n             SET SEG2 = +\n               &STR(&SUBSTR(&TO:&LENGTH(&NRSTR(&LO)),&NRSTR(&LO)\n             END\n           ELSE DO\n             SET SEGY = &STR(&SUBSTR(&TO:&TL,&NRSTR(&LN)))\n             IF &START = 1 THEN SET &SEG1 = &Z\n             ELSE SET SEG1 = &STR(&SUBSTR(1:&START-1,&NRSTR(&LN)))\n             SET SEG2 = &STR(&SUBSTR(&STOP+1:&DW,&NRSTR(&LN)))\n             SET &LO = &NRSTR(&SEG1&SEGY&SEG2)\n             IF &TO = 1 THEN SET &SEG1 = &Z\n             ELSE SET SEG1 = &STR(&SUBSTR(1:&TO-1,&NRSTR(&LO)))\n             SET SEG2 = &STR(&SUBSTR(&TL+1:&DW,&NRSTR(&LO)))\n             END\n           SET &LF = &NRSTR(&SEG1&SEGX&SEG2)\n           ISREDIT LINE &I = (LF)\n           SET I = &I + 1\n           END\n         SET &MVCCC = 0\n         GOTO XEND\nXERR:    ISPEXEC SETMSG MSG(ISRZ001)\n         SET &MVCCC = 12\nXEND:    EXIT CODE(&MVCCC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MREAD": {"ttr": 22022, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\t9\\x02G\\x02G\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T09:39:00", "lines": 583, "newlines": 583, "modlines": 0, "user": "SYSPAJA"}, "text": "RMS      TITLE 'READ MEMBERS SUBROUTINE.'\nMREAD    START 0\n         SPACE 2\n* CALLING SEQUENCE : CALL MREAD,(A,B,C),VL\n* ------------------            (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF AN ARRAY (FORMAT CL...) INTO\n*                    WHICH THE NEXT SEQUENTIAL LOGICAL RECORD OF A\n*                    PARTITIONED DATA-SET MEMBER (POINTED TO BY\n*                    MFIND) IS READ.\n*\n*                B - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSPDS  '.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                    -1 - MEMBER REACHES END-OF-FILE.\n*                     0 - READ CORRECTLY EXECUTED.\n*                     1 - FILE NOT OPENED.\n*                     2 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     3 - READ ERROR.\n*\n* CALLING SEQUENCE : CALL MFIND,(A,B,C),VL\n* ------------------            (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE MEMBER NAME (FORMAT CL8)\n*                    TO FIND AND SET READY FOR READ.\n*\n*                B - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSPDS  '.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - MEMBER FOUND.\n*                     1 - FILE NOT OPENED.\n*                     2 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     3 - MEMBER NOT FOUND.\n*                     4 - READ DIRECTORY ERROR OR INSUFFICIENT VIRTUAL\n*                         STORAGE WAS AVAILABLE.\n         EJECT\n* CALLING SEQUENCE : CALL MOPEN,(A,B,C),VL\n* ------------------            (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE MAXIMUM LOGICAL RECORD LENGTH (FORMAT\n*                    FULLWORD - F BOUNDARY) FOR THE FILE. THIS ARGUMENT\n*                    IS MANDATORY BECAUSE INFORMATION IS RETURNED TO\n*                    THE CALLER.\n*\n*                B - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSPDS  '.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - OPEN CORRECTLY EXECUTED.\n*                     1 - DD-CARD MISSING.\n*                     2 - OPEN ERROR, RECORD FORMAT NOT DEFINED OR\n*                         LRECL TOO LARGE (MAXIMUM ALLOWED IS 256).\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - FILE ALREADY OPENED.\n*\n* CALLING SEQUENCE : CALL MCLOSE,(A,B),VL\n* ------------------             (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) TO\n*                    CLOSE. IF THIS ARGUMENT CONTAINS THE 'CLOSEALL'\n*                    KEYWORD, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, OR THE PARAMETERS\n*                    LIST POINTER (REGISTER 1) IS ZERO, ALL THE OPENED\n*                    FILES ARE CLOSED.\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE, ARGUMENT ALIGNMENT OR\n*                         DD-NAME ERROR.\n         EJECT\n* GENERAL NOTICE : ON ANY ERROR DETECTION, A MESSAGE IS INCLUDED IN\n* ---------------- THE MESSAGE CLASS FOR THE JOB.\n*                  IF THE ROUTINE IS RE-CALLED AFTER IND = 1 OR 2,\n*                  THE PROGRAM IS SENDED IN ABEND U0001.\n*                  IF THE INDICATOR RESPONSE IS DETECTED 10 TIMES\n*                  DIFFERENT FROM 0, THE PROGRAM IS SENDED IN\n*                  ABEND U0002.\n*                  MVS/XA : MUST BE AMODE AND RMODE 24.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\n         EJECT\n        PRINT  NOGEN\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DSORG=PO,DEVD=DA\n        PRINT  GEN\n         SPACE 1\n*        FILE BLOCK WORK AREA DESCRIPTION.\n         SPACE 1\nFBWAD    DSECT\nFCHAIN   DC    F'0'                CHAIN WORD.\nFDDNM    DC    CL8' '              DD-NAME.\nFERCNT   DC    H'10'               ERROR COUNT.\nFFLAGS   DC    XL1'0'              FLAGS BYTE.\nFAB      EQU   X'01'                    ABEND.\nFOE      EQU   X'02'                    OPEN ERROR.\nFRE      EQU   X'04'                    READ ERROR.\nFFO      EQU   X'08'                    MEMBER FOUND.\nFRY      EQU   X'10'                    BLOCK IS READY.\n         DC    XL1'0'              UNUSED.\nFMLRL    DC    F'0'                MAX. LOGICAL RECORD LENGTH.\nFMBLK    DC    F'0'                BLOCK SIZE LENGTH.\nFIOAR    DC    F'0'                ADDRESS OF AREA TO HOLD ONE BLOCK.\nFLAST    DC    F'0'                END OF BLOCK POSITION.\nFPOSIT   DC    F'0'                CURRENT BLOCK POSITION.\n         SPACE 1\nMREAD    CSECT                     RESTORE MAIN CSECT.\n         EJECT\n        $XENT  BASE=R12\n         SPACE 1\n         LA    R6,TABD             SET DEFAULTS.\n         LA    R7,DDDEF\n         SR    R9,R9\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    MR1\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         LTR   R8,R8\n         BZ    *+L'*+2\n         LR    R7,R8\n         TM    4(R1),X'80'\n         BO    MR1\n         TM    8(R1),X'80'\n         BZ    ERR2\n         TM    11(R1),X'03'\n         BNZ   ERR2\n         L     R9,8(R1)\n         LA    R9,0(R9)\nMR1      L     R8,0(R1)\n         LA    R8,0(R8)\n         SPACE 1\n         LA    R4,CHAIN\n         USING FBWAD,R4\nMR2      L     R4,FCHAIN           LOOK IF OPENED.\n         LTR   R4,R4\n         BZ    ERR1\n         CLC   FDDNM(L'FDDNM),0(R7)\n         BNE   MR2\n         TM    FFLAGS,FAB          TEST ABEND SWITCH.\n         BO    ABND1\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    ERR1\n         NI    FFLAGS,255-FRE      RESET READ ERROR SWITCH.\n         TM    FFLAGS,FFO          WAS MEMBER FOUND?\n         BZ    ERR2                NO.\n         TM    FFLAGS,FRY          DO I NEED TO READ A BLOCK?\n         BO    MR3                 NO.\n         L     R3,FIOAR            AREA ADDRESS.\n         LA    R1,DY(R4)           DECB ADDRESS.\n        READ   (1),SF,(R2),(R3),'S',MF=E\n         LA    R1,DY(R4)           DECB ADDRESS.\n        CHECK  (1)\n         TM    FFLAGS,FRE          TEST READ ERROR SWITCH.\n         BO    ERR3\n         SPACE 1\n         OI    FFLAGS,FRY          INDICATE BLOCK READ.\n         L     R5,FMBLK            COMPUTE REAL BLOCK LENGTH.\n         L     R1,DY+16(R4)        (IOB ADDRESS)\n         SH    R5,14(R1)\n         LA    R5,0(R3,R5)\n         ST    R5,FLAST            SET LAST + 1 POINTER.\n         B     MR4\nMR3      L     R3,FPOSIT           GET CURRENT POINTER.\nMR4      L     R5,FMLRL            GET LOGICAL RECORD LENGTH.\n         BCTR  R5,0\n         EX    R5,MVRECL           GIVE TO CALLER A RECORD.\n         LA    R3,1(R3,R5)         POINTS AT NEXT LOGICAL RECORD.\n         CL    R3,FLAST            IS BLOCK EXHAUSTED?\n         BNL   MR5                 YES.\n         ST    R3,FPOSIT           NO, SAVE CURRENT POINTER.\n         B     MR6\nMR5      NI    FFLAGS,255-FRY      INDICATE READ NECESSARY.\nMR6      SR    R10,R10\n         B     EXIT4\nMVRECL   MVC   0(*-*,R8),0(R3)\n         DROP  R2\n         SPACE 1\nRDERR    OI    FFLAGS,FRE          SET READ ERROR SWITCH.\n         BR    R14\n         SPACE 1\nRDEND    NI    FFLAGS,255-FFO-FRY  RESET INDICATORS.\n         SR    R10,R10\n         BCTR  R10,0\n         B     EXIT4\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nMAXERR   EQU   ((*-ERR1)/2)+1\n         B     EXIT\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY MFIND\n         SPACE 1\nMFIND   $XENT  BASE=R12,DT=NO\n         SPACE 1\n         LA    R6,TABF             SET DEFAULTS.\n         LA    R7,DDDEF\n         SR    R9,R9\n         LA    R10,MAXERF\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    FM1\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         LTR   R8,R8\n         BZ    *+L'*+2\n         LR    R7,R8\n         TM    4(R1),X'80'\n         BO    FM1\n         TM    8(R1),X'80'\n         BZ    ERF2\n         TM    11(R1),X'03'\n         BNZ   ERF2\n         L     R9,8(R1)\n         LA    R9,0(R9)\nFM1      L     R8,0(R1)\n         LA    R8,0(R8)\n         SPACE 1\n         LA    R4,CHAIN\n         USING FBWAD,R4\nFM2      L     R4,FCHAIN           LOOK IF OPENED.\n         LTR   R4,R4\n         BZ    ERF1\n         CLC   FDDNM(L'FDDNM),0(R7)\n         BNE   FM2\n         TM    FFLAGS,FAB          TEST ABEND SWITCH.\n         BO    ABND1\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    ERF1\n         NI    FFLAGS,255-FRE-FFO-FRY   RESET SWITCHES.\n         MVC   LISTNME(L'LISTNME),0(R8) GET MEMBER NAME.\n        BLDL   (R2),BLDLLIST\n         LTR   R15,R15             TEST COMPLETION CODE.\n         BZ    FM3                 O.K.\n         LA    R0,4\n         CLR   R15,R0\n         BNE   ERF4\n         MVC   DIAG10+23(L'LISTNME),LISTNME\n         B     ERF3\nFM3     FIND   (R2),LISTTTR,C\n         OI    FFLAGS,FFO          INDICATE MEMBER FOUND.\n         SR    R10,R10\n         B     EXIT4\n         DROP  R2\n         SPACE 1\nERF1     BCTR  R10,0\nERF2     BCTR  R10,0\nERF3     BCTR  R10,0\nERF4     BCTR  R10,0\nMAXERF   EQU   ((*-ERF1)/2)+1\n         B     EXIT\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY MOPEN\n         SPACE 1\nMOPEN   $XENT  BASE=R12,DT=NO\n         SPACE 1\n         LA    R6,TABO             SET DEFAULTS.\n         LA    R7,DDDEF\n         SR    R9,R9\n         LA    R10,MAXERO\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    OP1\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         LTR   R8,R8\n         BZ    *+L'*+2\n         LR    R7,R8\n         TM    4(R1),X'80'\n         BO    OP1\n         TM    8(R1),X'80'\n         BZ    ERO3\n         TM    11(R1),X'03'\n         BNZ   ERO3\n         L     R9,8(R1)\n         LA    R9,0(R9)\nOP1      TM    3(R1),X'03'\n         BNZ   ERO3\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         SPACE 1\n         LA    R3,CHAIN            LOOK IF ALREADY DEFINED.\n         USING FBWAD,R4\nOP2      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    OP3\n         CLC   FDDNM(L'FDDNM),0(R7)\n         BE    ERO4\n         LR    R3,R4\n         B     OP2\nOP3     GETMAIN R,LV=WSZ\n         LR    R4,R1\n         ST    R4,0(R3)            NEW FILE.\n         MVC   FCHAIN(WSZ),BFILE   SET SKELETON.\n         MVC   FDDNM(L'FDDNM),0(R7)\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         MVC   DCBDDNAM(L'DCBDDNAM),FDDNM\n         OC    ATIOT(L'ATIOT),ATIOT     TEST FIRST TIME.\n         BNZ   OP4\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\nOP4      L     R3,ATIOT            SEARCH DD AND OPEN IT.\n         USING TIODSECT,R3\nOP5      CLC   TIOELNGH(4),ZEROS\n         BE    ERO1\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM\n         BE    OP6\n         SR    R1,R1\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     OP5\n         DROP  R3\nOP6     OPEN   ((R2),(INPUT))\n         TM    FFLAGS,FOE          TEST OPEN ERROR SWITCH.\n         BO    ERO2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPEN SUCCESSFULL.\n         BZ    ERO2\n         LH    R1,DCBBLKSI\n         LTR   R1,R1\n         BP    *+L'*+4\n         L     R1,FMLRL\n         ST    R1,FMBLK\n         DROP  R2\n         LA    R0,7(R1)\n         SRL   R0,3\n         SLL   R0,3\n        GETMAIN R,LV=(0)\n         ST    R1,FIOAR            SAVE ADDRESS OF I/O AREA.\n         MVC   0(L'FMLRL,R8),FMLRL PASS MAXIMUM LOGICAL RECORD LENGTH.\n         SR    R10,R10\n         B     EXIT4\n         SPACE 1\nERO1     BCTR  R10,0\nERO2     BCTR  R10,0\n         OI    FFLAGS,FAB          SET ABEND SWITCH TO PREVENT RE-CALL.\nERO3     BCTR  R10,0\nERO4     BCTR  R10,0\nMAXERO   EQU   (((*-ERO1)-4)/2)+1\n         B     EXIT\n         SPACE 2\n         USING IHADCB,R1\nDCBEXIT  TM    DCBRECFM,DCBRECF    TEST IF RECORD FORMAT FIXED.\n         BZ    EX2\n         TM    DCBRECFM,DCBRECV\n         BO    EX2\n         LA    R3,256              CONTROL THE LOGICAL RECORD LENGTH.\n         LH    R2,DCBLRECL\n         LTR   R2,R2\n         BP    EX1\n         LH    R2,DCBBLKSI\n         LTR   R2,R2\n         BNP   EX2\nEX1      CLR   R2,R3\n         BH    EX2\n         ST    R2,FMLRL\n         BR    R14\n         DROP  R1\nEX2      OI    FFLAGS,FOE          SET OPEN ERROR SWITCH.\n         BR    R14\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY MCLOSE\n         SPACE 1\nMCLOSE  $XENT  BASE=R12,DT=NO\n         SPACE 1\n         LA    R6,TABC             CONTROL ARGUMENTS.\n         SR    R9,R9\n         LA    R10,1\n         LTR   R8,R1\n         BZ    MC2\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         TM    0(R1),X'80'\n         BO    MC1\n         TM    4(R1),X'80'\n         BZ    EXIT\n         TM    7(R1),X'03'\n         BNZ   EXIT\n         L     R9,4(R1)\n         LA    R9,0(R9)\nMC1      LTR   R8,R8\n         BZ    MC2\n         CLC   0(8,R8),KEYALL\n         BNE   MC2\n         SR    R8,R8\n         SPACE 1\nMC2      LA    R3,CHAIN\n         USING FBWAD,R4\nMC3      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    MC7\n         LTR   R8,R8\n         BZ    MC4\n         CLC   0(L'FDDNM,R8),FDDNM\n         BE    MC4\n         LR    R3,R4\n         B     MC3\nMC4      LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    MC5\n        CLOSE  ((R2))\n         DROP  R2\nMC5      L     R1,FMBLK\n         LA    R0,7(R1)\n         SRL   R0,3\n         SLL   R0,3\n         L     R1,FIOAR\n         LTR   R1,R1\n         BZ    MC6\n        FREEMAIN R,A=(1),LV=(0)\nMC6      MVC   0(L'FCHAIN,R3),FCHAIN    DEQUEUE FILE.\n         LR    R1,R4\n        FREEMAIN R,A=(1),LV=WSZ\n         LTR   R8,R8\n         BNZ   MC8\n         B     MC3\nMC7      LTR   R8,R8\n         BNZ   EXIT\nMC8      SR    R10,R10\n         B     EXIT4\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\nEXIT     BASR  R12,0\n         USING *,R12\n         LR    R2,R10\n         BCTR  R2,0\n         SLL   R2,2\n         L     R3,0(R2,R6)\n         NI    SWEX+1,OFF          SET SWITCH OFF.\n         CLI   12(R3),C' '\n         BNE   *+L'*+10\n         OI    SWEX+1,ON           SET SWITCH ON.\n         MVC   12(8,R3),0(R7)\n         LR    R1,R3\n        WTO    MF=(E,(1))\nSWEX     B     EXIT1\n         LA    R3,CNTR             CONTROL MAX. ERROR.\n         B     EXIT2\nEXIT1    MVC   12(8,R3),BLKS\n         LTR   R4,R4\n         BZ    SWEX+L'SWEX\n         USING FBWAD,R4\n         LA    R3,FERCNT\n         DROP  R4\nEXIT2    LH    R2,0(R3)\n         BCT   R2,EXIT3\n         LA    R1,2                SET ABEND CODE.\n         B     ABND\nEXIT3    STH   R2,0(R3)\n         DROP  R12\n         SPACE 1\nEXIT4    BASR  R12,0\n         USING *,R12\n         LTR   R9,R9\n         BZ    EXIT5\n         ST    R10,0(R9)           STORE IND.\nEXIT5   $XRET  CC=(R10)\n         DROP  R12\n         SPACE 1\nABND1    LA    R1,1                SET ABEND CODE.\n         SPACE 1\nABND     BASR  R12,0\n         USING *,R12\n         LR    R15,R10             SET C.C. IN REG. 15.\n        ABEND  (1),DUMP\n         SPACE 1\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nBLDLLIST DC    0F'0',AL2(1,58)\nLISTNME  DC    CL8' '\nLISTTTR  DC    XL6'0',XL40'0'\nCHAIN    DC    A(*-*)\nATIOT    DC    A(*-*)\nTABD     DC    A(DIAG5,DIAG6,DIAG7)\nTABF     DC    A(DIAG5,DIAG9,DIAG10,DIAG11)\nTABO     DC    A(DIAG1,DIAG2,DIAG3,DIAG4)\nTABC     DC    A(DIAG8)\nZEROS    DC    F'0'\nDIAG1   WTO    'ERR=1 -          DD-CARD MISSING.',                    1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG2   WTO    'ERR=2 -          OPEN ERROR OR DD-CARD CONFLICT.',     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG3   WTO    'ERR=3 - MOPEN CALLING SEQUENCE OR ARGUMENT ALIGNMENT ER1\n               ROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG4   WTO    'ERR=4 -          ALREADY OPENED.',                     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG5   WTO    'ERR=1 -          NOT OPENED.',                         1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG6   WTO    'ERR=2 - MREAD CALLING SEQUENCE OR ARGUMENT ALIGNMENT ER1\n               ROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG7   WTO    'ERR=3 -          I/O ERROR.',                          1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG8   WTO    'ERR=1 - MCLOSE CALLING SEQUENCE, ARGUMENT ALIGNMENT OR 1\n               DD-NAME ERROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG9   WTO    'ERR=2 - MFIND CALLING SEQUENCE OR ARGUMENT ALIGNMENT ER1\n               ROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG10  WTO    'ERR=3 -          :          MEMBER NOT FOUND.',        1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG11  WTO    'ERR=4 -          READ DIR. ERROR OR INSUFFICIENT STORAG1\n               E.',ROUTCDE=11,DESC=7,MF=L\nCNTR     DC    H'10'\nDDDEF    DC    CL8'SYSPDS  '\nKEYALL   DC    CL8'CLOSEALL'\nBLKS     DC    CL8' '\n         EJECT\n        CNOP   0,8\n         SPACE 1\nBFILE    DC    F'0'                CHAIN WORD.\n         DC    CL8' '              DD-NAME.\n         DC    H'10'               ERROR COUNT.\n         DC    XL1'0'              FLAGS BYTE.\n         DC    XL1'0'              UNUSED.\n         DC    F'0'                MAX. LOGICAL RECORD LENGTH.\n         DC    F'0'                BLOCK SIZE LENGTH.\n         DC    F'0'                ADDRESS OF AREA TO HOLD ONE BLOCK.\n         DC    F'0'                END OF BLOCK POSITION.\n         DC    F'0'                CURRENT BLOCK POSITION.\n         SPACE 1\nDCBPDS  DCB    DSORG=PO,DEVD=DA,MACRF=(R),BFALN=D,                     1\n               EXLST=REXLIST,SYNAD=RDERR,EODAD=RDEND,DDNAME=XXXXXXXX\n         SPACE 1\n        READ   PECB,SF,,,'S',MF=L\n         SPACE 1\n        CNOP   0,8\n         SPACE 1\nDZ       EQU   DCBPDS-BFILE\nDY       EQU   PECB-BFILE\nWSZ      EQU   (((*-BFILE)+7)/8)*8\n         SPACE 1\nREXLIST  DC    0F'0',XL1'85',AL3(DCBEXIT)\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MREAD$": {"ttr": 22277, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "//MREAD    JOB (........),'INSTALL  - MREAD -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,MBR=MREAD\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   MOPEN\n  ALIAS   MCLOSE\n  ALIAS   MFIND\n  NAME    MREAD(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MREAD@": {"ttr": 22279, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14R\\x00\\x8e\\x00\\x8e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:52:00", "lines": 142, "newlines": 142, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      MREAD     1/4.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       READ PO-MEMBERS ROUTINES      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL MREAD,(A,B,C),VL\n  ------------------            (A,B)\n                                (A)\n\n         Where : A - is the address of an array (format CL...) into\n                     which the next sequential logical record of a\n                     partitioned data-set member (pointed to by\n                     MFIND) is read.\n\n                 B - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSPDS.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                     -1 - member reaches END-OF-FILE.\n                      0 - READ correctly executed.\n                      1 - file not opened.\n                      2 - calling sequence or argument alignment error.\n                      3 - READ error.\n\n  Assembler macro : $MREAD A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/09/85\n                                                      MREAD     2/4.\n\n  Calling sequence : CALL MFIND,(A,B,C),VL\n  ------------------            (A,B)\n                                (A)\n\n         Where : A - is the address of the member name (format CL8)\n                     to find and set ready for read.\n\n                 B - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSPDS.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - member found.\n                      1 - file not opened.\n                      2 - calling sequence or argument alignment error.\n                      3 - member not found.\n                      4 - read directory error or insufficient virtual\n                          storage was available.\n\n  Assembler macro : $MFIND A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/09/85\n                                                      MREAD     3/4.\n\n  Calling sequence : CALL MOPEN,(A,B,C),VL\n  ------------------            (A,B)\n                                (A)\n\n         Where : A - is the maximum logical record length (format\n                     FULLWORD - F boundary) for the file. This argument\n                     is mandatory because information is returned to\n                     the caller.\n\n                 B - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSPDS.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - OPEN correctly executed.\n                      1 - DD-card missing.\n                      2 - OPEN error, record format not defined or\n                          LRECL too large (maximum allowed is 256).\n                      3 - calling sequence or argument alignment error.\n                      4 - file already opened.\n\n  Assembler macro : $MOPEN A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   13/04/88\n                                                      MREAD     4/4.\n\n  Calling sequence : CALL MCLOSE,(A,B),VL\n  ------------------             (A)\n\n         Where : A - is the address of the DD-name (format CL8) to\n                     close. If this argument contains the CLOSEALL\n                     keyword, or the address of this argument is set\n                     to zero in the parameters list, or the parameters\n                     list pointer (register 1) is zero, all the opened\n                     files are closed.\n\n                 B - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence, argument alignment or\n                          DD-name error.\n\n  Assembler macro : $MCLOSE A,B\n  -----------------\n\n         Where A and or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  General notice : On any error detection, a message is included in\n  ================ the message class for the job.\n                   If the routine is re-called after IND = 1 or 2,\n                   the program is sended in abend U0001.\n                   If the indicator response is detected 10 times\n                   different from 0, the program is sended in\n                   abend U0002.\n                   This routine is multi-files usable, that means\n                   multi-files opened concurrently (using the DD-name\n                   argument).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NEW@MENU": {"ttr": 22283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94#\\x0f\\x00\\x94#\\x0f\\x11\\x11\\x00A\\x00A\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-18T00:00:00", "modifydate": "1994-08-18T11:11:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n` TYPE(TEXT) COLOR(YELLOW)\n{ TYPE(TEXT) COLOR(GREEN)\n} TYPE(TEXT) COLOR(RED)\n! TYPE(TEXT) COLOR(PINK)\n\u00a6 TYPE(TEXT) COLOR(TURQ)\n@ TYPE(TEXT) COLOR(YELLOW) HILITE(REVERSE) SKIP(ON)\n| TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n# TYPE(TEXT) COLOR(RED) HILITE(REVERSE) SKIP(ON)\n~ TYPE(TEXT) COLOR(PINK) HILITE(REVERSE) SKIP(ON)\n\u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n\\ TYPE(TEXT) COLOR(BLUE) HILITE(REVERSE) SKIP(ON)\n? TYPE(TEXT) COLOR(WHITE) HILITE(REVERSE) SKIP(ON)\n)BODY\n`--------------------------<\u00a6 Private Option Menu `>----------------------------\n{Select OPTION%===>_ZCMD                                                       +\n+\n\\                                                                              +\n\\  ?1 +DSPRT : Data-set Print Selection               |                        +\n\\  ~2 \u00a6STATDS : Data-set Statistics                   |  \u00a6Userid -!&ZUSER   |  +\n\\  \u00a23 }Invoke full-screen ZAP                         |  \u00a6Prefix -!&ZPREFIX |  +\n\\  ~4 \u00a6Invoke DIDOCS, QSP, VSM/RSM, PUSE,             |  \u00a6Today  -!&ZDATE   |  +\n\\  +             \u00a6UNITS, UNIT or POF                  |  \u00a6Julian -!&ZJDATE  |  +\n\\  \u00a25 }CDSCB : Change DSCB (VTOC Format-1)            |  \u00a6Time   -?  &ZTIME |  +\n\\  ?6 +ENQDIS : Display ENQ's                         |                        +\n\\  ?7 +TO : Message to one or more TSO user(s)        \\                        +\n\\  ?8 +SEND : Message to a TSO user or MAIN operator  \\  \u00a2A }Allocations    \\  +\n\\  #9 %SPECIAL : Authorized command(s) interface      \\  @G !GDG Utility    \\  +\n\\  ?B +BLKSIZE : Disk block sizes computations/tables \\  |P `PDSMATCH job   \\  +\n\\  \\C {COMPARE : Compare sequentials or members       \\  #V %VCOREZAP       \\  +\n\\  ?D +DAY : Weekday from 1582 up to 4315, or         \\  ~Y \u00a6Various ...    \\  +\n\\  +        ?S +Tables Services (Display/Fill)        \\  |Z `IMS log        \\  +\n\\  \u00a2M }SHORT : Short messages communication           \\  +      `data-set(s)\\  +\n\\  \\O {OPERATOR : Miscellaneous Operators Facilities  \\  #I %Applications   \\  +\n\\                                                                              +\n+Enter`END+or}X\u00a6(EXIT)+command to%return+to the%PRIMARY OPTION MENU+\n+\n)PROC\n  &ZSEL = TRANS (TRUNC (&ZCMD,'.')\n                1,'PANEL(PAJDSP)'\n                2,'PANEL(PAJDSS)'\n                3,'PANEL(PAJZAP)'\n                4,'PANEL(PAJIVK)'\n                5,'PANEL(PAJDSC)'\n                6,'PANEL(PAJEQD)'\n                7,'PANEL(PAJTOCP)'\n                8,'PANEL(PAJSEND)'\n                9,'CMD(%PAJCAUCP)'\n                A,'PGM(PAJPALL)'\n                B,'CMD(%PAJCBLK)'\n                C,'PANEL(PAJCOM)'\n                D,'CMD(%PAJCDAY)'\n                G,'CMD(%PAJCGDG)'\n                I,'PANEL(PAJIAP)'\n                M,'PANEL(PAJSM)'\n                O,'PANEL(PAJMOF)'\n                P,'PANEL(PAJPDS)'\n                S,'PANEL(PAJDAYS)'\n                V,'CMD(VCOREZAP)'\n                Y,'PANEL(PAJVRS)'\n                Z,'CMD(PAJCXIL)'\n                X,'EXIT'\n              ' ',' '\n                *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NEW@PRIM": {"ttr": 22285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94#\\x0f\\x00\\x94#\\x0f\\x11\\x11\\x008\\x008\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-18T00:00:00", "modifydate": "1994-08-18T11:11:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n { TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n } TYPE(TEXT) COLOR(RED) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n @ TYPE(TEXT) COLOR(YELLOW) HILITE(REVERSE) SKIP(ON)\n | TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n # TYPE(TEXT) COLOR(RED) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n ? TYPE(TEXT) COLOR(WHITE) HILITE(REVERSE) SKIP(ON)\n)BODY\n{----------------------<`&ZUSER %-!&ISPF%/\u00a6Primary Menu{>----------------------\n`OPTION%===>_ZCMD\n+\n\u00a6Userid -!&ZUSER   \u00a6Logproc -!&ZLOGON  \u00a6  Today -!&ZDATE   \u00a6   Time -?  &ZTIME +\n\u00a6Prefix -!&ZPREFIX \u00a6 ApplID -!&ZAPPLID \u00a6 Julian -!&ZJDATE  \u00a6 System -!&REST\n+\n % 0 {ISPF parms          +% 1 {Browse              +% 2 {Edit                +\n % 3 {Utilities           +% 4 +Foreground          +% 5 +Batch               +\n % 6 +Dialog test         +% 7 +LM utilities        +% C +Changes             +\n % T +Tutorial            +| P `Private             +|SH `SHOWMVS             +\n ? 2V\u00a6Edit VIO            +? SF\u00a6SEARCH-FOR (Batch)  +                         +\n+\n+Enter`END+or}X\u00a6(EXIT)+command to%terminate+ISPF using%log+and%list+defaults.\n+\n)INIT\n  .HELP = ISR00003                 /* Help for this panel           */\n  &ZPRIM = YES                     /* This is a primary option menu */\n  &ZHTOP = ISR00003                /* Tutorial table of contents    */\n  &ZHINDEX = ISR91000              /* Tutorial index - 1st page     */\n  &ISPF = TRUNC(&ZENVIR,8)\n  &REST = .TRAIL\n  &REST = TRUNC(&REST,8)\n  IF (&REST = MVS)\n    &REST = 'MVS/370'\n)PROC\n  &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n                0,'PANEL(ISPOPTA)'\n                1,'PGM(ISRBRO)'\n                2,'PGM(ISREDIT)'\n                3,'PANEL(ISRUTIL)'\n                4,'PANEL(ISRFPA)'\n                5,'PGM(ISRJB1) PARM(ISRJPA) NOCHECK'\n                6,'PGM(ISRYXDR) NOCHECK'\n                7,'PANEL(ISRLPRIM)'\n                C,'PGM(ISPTUTOR) PARM(ISR00005)'\n                P,'PANEL(NEW@MENU)'\n                T,'PGM(ISPTUTOR) PARM(ISR00000)'\n               2V,'CMD(%EDVIO)'\n               SH,'CMD(%PAJCSHWM)'\n               SF,'CMD(%PAJCSSF)'\n              ' ',' '\n                X,'EXIT'\n                *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NULL": {"ttr": 22287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16(\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:28:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           DEFINE A SYMBOL.\n&NAME    NULL       &DUMMY\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n&NAME    DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OPCOM": {"ttr": 22289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\tD\\x01;\\x01;\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T09:44:00", "lines": 315, "newlines": 315, "modlines": 0, "user": "SYSPAJA"}, "text": "OCS      TITLE 'OPERATOR COMMUNICATION SUBROUTINE.'\nSETOPC   START 0\n         SPACE 2\n* CALLING SEQUENCE : CALL SETOPC,(A,B),VL\n* ------------------             (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE BLOCK INFORMAL TEXT TO\n*                    BE DISPLAYED AT THE SYSTEM MASTER CONSOLE FOR\n*                    OPERATOR SETUP (OPTIONAL). WHEN THIS ARGUMENT\n*                    IS OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS\n*                    SET TO ZERO IN THE PARAMETERS LIST, OR THE\n*                    PARAMETERS LIST POINTER (REGISTER 1) IS ZERO,\n*                    THE DEFAULT REQUEST IS ASSUMED TO BE THE USE\n*                    OF THE OPERATING SYSTEM STOP (P) COMMAND ONLY.\n*                    BLOCK INFORMAL TEXT (THE MAXIMUM TEXT LENGTH\n*                    ALLOWED IS 72 CHARACTERS BY MESSAGE, IF MORE,\n*                    IT IS TRUNCATED) FORMAT :\n*\n*                             DC    AL1(L'TEXT1)\n*                    TEXT1    DC    C'...MESSAGE 1...'\n*                             DC    AL1(L'TEXT2)\n*                    TEXT2    DC    C'...MESSAGE 2...'\n*                    ... ... ...\n*                             DC    AL1(L'TEXTN)\n*                    TEXTN    DC    C'...MESSAGE N...'\n*                             DC    AL1(0) OR AL1(225) : END OF LIST.\n*\n*                B - IS THE RESPONSE INDICATOR (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - OPERATOR COMMUNICATION IS READY.\n*                         THE REGISTER 1 CONTAINS THE ADDRESS OF THE\n*                         MESSAGE-ID'S NUMBERS LIST FOR DELETE USE WHEN\n*                         THE CALLING PROGRAM DOES NOT TERMINATE BY THE\n*                         STOP OR MODIFY (LIKE STOP) OPERATOR COMMAND,\n*                         AND THE REGISTER 0 CONTAINS THE LENGTH OF THE\n*                         GETMAINED AREA INTO WHICH THE LIST HAS BEEN\n*                         BUILDED (FOR FREEMAIN PURPOSE).\n*                     1 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*\n*        ALIAS : CALL INIFIN\n         SPACE 2\nMAX      EQU   64                  MAXIMUM NUMBER OF MESSAGES.\n         EJECT\n* CALLING SEQUENCE : CALL OPCOM,(A,B),VL\n* ------------------            (A)\n*\n*        WHERE : A - IS THE RESPONSE INDICATOR (FORMAT FULLWORD - F\n*                    BOUNDARY). WHEN THE ADDRESS OF THIS ARGUMENT\n*                    IS SET TO ZERO IN THE PARAMETERS LIST, OR THE\n*                    PARAMETERS LIST POINTER (REGISTER 1) IS ZERO,\n*                    THE VALUE IS ALWAYS PLACED IN REGISTER 15 AND\n*                    CAN BE :\n*\n*                     1 - CONTINUE PROCESSING (NOTHING RECEIVED FROM\n*                         THE OPERATOR).\n*                     2 - STOP (P) COMMAND RECEIVED.\n*                     3 - MODIFY (F) COMMAND RECEIVED.\n*                     4 - CALLING SEQUENCE, ARGUMENT ALIGNMENT OR\n*                         OPERATOR COMMUNICATION NOT INITIALIZED.\n*\n*                B - IS THE ADDRESS OF AN ARRAY (OPTIONAL) LARGE ENOUGH\n*                    (OTHERWISE TRUNCATED) TO RECEIVE THE EVENTUAL\n*                    MODIFY COMMAND TEXT TYPED BY THE OPERATOR. WHEN\n*                    THIS ARGUMENT IS OMITTED, THE MODIFY COMMAND TEXT\n*                    IS NOT AVAILABLE TO THE CALLER AND THE RESPONSE\n*                    INDICATOR IS SET TO 2 (AS STOP COMMAND RECEIVED).\n*                    BEFORE ANY CALL, THIS RECEIVING TEXT ARRAY MUST BE\n*                    INITIALIZED AS BELOW :\n*\n*                     +0 - LENGTH OF TEXT RECEIVING FIELD (FORMAT H -\n*                          HALFWORD BOUNDARY).\n*                     +2 - TEXT RECEIVING FIELD (FORMAT CL...).\n*\n*                    THE TEXT ENTERED BY THE MODIFY COMMAND IS PLACED\n*                    IN THE ARRAY AS FOLLOWS :\n*\n*                     +0 - LENGTH OF TEXT (FORMAT H).\n*                     +2 - TEXT (FORMAT CL..., TEXT IS UPPERCASED).\n*\n*        ALIAS : CALL VERFIN,(A),VL\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\nEL       EQU   X'80'               END OF LIST INDICATOR.\n         EJECT\nCIBDSECT DSECT\nCIB      IEZCIB\n         SPACE 1\nSETOPC   CSECT                     RESTORE ORIGINAL CSECT.\n         SPACE 2\n*        ECB BITS DEFINITION.\n         SPACE 1\nWBIT     EQU   X'80'               WAITING FOR COMPLETION OF AN EVENT.\nCBIT     EQU   X'40'               THE EVENT HAS BEEN COMPLETED.\n         EJECT\n         ENTRY INIFIN\n         SPACE 1\n        $XENT  BASE=R12\n         B     GPARM\n         SPACE 1\nDISPL    EQU   *-SETOPC\n         SPACE 1\nINIFIN   LA    R1,DISPL            ENTER AS CALL SETOPC.\n         LA    R15,0(R15)\n         SLR   R15,R1\n         SR    R1,R1\n         BR    R15\n         SPACE 1\nGPARM    LA    R7,1                CONTROL ARGUMENTS.\n         SR    R8,R8\n         LTR   R6,R1\n         BZ    SWIN\n         L     R6,0(R1)\n         LA    R6,0(R6)\n         TM    0(R1),X'80'\n         BO    SWIN\n         TM    4(R1),X'80'\n         BZ    RETURN\n         TM    7(R1),X'03'\n         BNZ   RETURN\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         SPACE 1\nSWIN     NOP   RETURN\n         OI    SWIN+1,ON           CLOSE THIS WAY.\n        EXTRACT    ANSWER,'S',FIELDS=(TIOT,COMM)\n         L     R2,ANSWER           GET TIOT ADDRESS.\n         MVC   MSGIN+57(8),0(R2)   MOVE JOB NAME IN MESSAGE.\n         OI    SWINI+1,ON          SET INITIALIZATION SWITCH.\n         BAS   R9,ANRESP           INITIALIZE COMMUNICATION.\n         NI    SWINI+1,OFF         RESET INITIALIZATION SWITCH.\n         L     R5,MAXSP\n        GETMAIN R,LV=(R5)\n         ST    R1,MSGLA\n         LR    R4,R1\n         LTR   R6,R6\n         BZ    STDIN\n         TM    0(R6),255\n         BZ    STDIN\n         BO    STDIN\n         SPACE 1\n         LA    R14,*\n         SR    R15,R15\n         MVCL  R4,R14\n         LR    R9,R1\n         AL    R1,LASTM\n         OI    0(R1),EL\n         SR    R7,R7\n         LA    R5,72               DISPLAY INFORMAL TEXT.\n         SR    R2,R2\nNEXT     CLI   0(R6),255\n         BE    SETEL\n         IC    R2,0(R6)\n         LTR   R3,R2\n         BZ    SETEL\n         LR    R4,R9\n         CLR   R2,R5\n         BNH   *+L'*+2\n         LR    R2,R5\n         BCTR  R2,0\n         EX    R2,MVMSG\n        WTO    MF=(E,MSGOP)\n         TM    0(R4),EL\n         BO    SETEL\n         ST    R1,0(R4)\n         LA    R9,4(,R4)\n         MVI   MSGOP+4,C' '\n         MVC   MSGOP+5(71),MSGOP+4\n         LA    R6,1(R3,R6)\n         B     NEXT\nMVMSG    MVC   MSGOP+4(*-*),1(R6)\n         SPACE 1\nSTDIN   WTO    MF=(E,MSGIN)\nSETEL    ST    R1,0(R4)\n         OI    0(R4),EL\n         L     R1,4(R13)\n         MVC   20(8,R1),MAXSP      BACK LENGTH AND MSG-ID'S LIST.\n         B     RETURN\n         SPACE 1\n         DROP  R12\n         SPACE 2\n         ENTRY VERINI\n         ENTRY OPCOM\n         SPACE 1\n        CNOP   2,8\nVERINI   OI    0(R1),X'80'         ENTER AS CALL OPCOM,(A),VL.\n         BASR  R15,0\n         SPACE 1\nOPCOM   $XENT  BASE=R12,DT=NO\n         SPACE 1\n         SR    R6,R6               CONTROL ARGUMENTS.\n         LA    R7,4\n         LTR   R8,R1\n         BZ    ANAL\n         TM    3(R1),X'03'\n         BNZ   RETURN\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         TM    0(R1),X'80'\n         BO    ANAL\n         TM    4(R1),X'80'\n         BZ    RETURN\n         L     R6,4(R1)\n         LA    R6,0(R6)\n         SPACE 1\nANAL     L     R2,ECBA             GET ADDR. OF ECB FOR COMMUNICATION.\n         LTR   R2,R2               TEST IF INITIALIZED.\n         BZ    RETURN\n         LA    R7,1\n         TM    0(R2),CBIT          IS COMMUNICATION ECB POSTED.\n         BZ    RETURN\n        WAIT   1,ECB=(R2)\n         BAS   R9,ANRESP           ANALYZE COMMUNICATION.\n         B     RETURN\n         B     MODR\nSTOPR    L     R1,MSGLA\n        DOM    MSGLIST=(1)\n         LM    R0,R1,MAXSP\n        FREEMAIN R,LV=(0),A=(1)\n         LA    R7,2                SET STOP RESPONSE.\n         B     RETURN\nMODR     LTR   R6,R6\n         BZ    STOPR\n         LA    R7,3                SET MODIFY RESPONSE.\n         SPACE 1\n         DROP  R12\n         SPACE 2\nRETURN   BASR  R12,0\n         USING *,R12\n         LTR   R8,R8\n         BZ    EXIT\n         ST    R7,0(R8)\nEXIT    $XRET  CC=(R7)\n         SPACE 1\n         DROP  R12\n         EJECT\n*        ROUTINE TO ANALYZE OPERATOR COMMUNICATION.\n*        ------------------------------------------\n*\n*        BASE REGISTER = R10.\n*        LINK REGISTER = R9.\n*        MOVE MODIFY TEXT POINTER = R6.\n*        WORK REGISTERS = R0, R1, R2, R3, R4, R5.\n*\n*        RETURN +0 = CONTINUE.\n*               +4 = MODIFY COMMAND RECEIVED.\n*               +8 = STOP COMMAND RECEIVED.\n         SPACE 1\nANRESP   BASR  R10,0               SET LOCAL BASE REGISTER.\n         USING *,R10\n         L     R3,ANSWER+4         GET ADDR. OF ECB COMMUNICATION AREA.\n         L     R4,0(R3)            GET ECB ADDRESS.\n         L     R5,4(R3)            GET CIB ADDRESS.\n         LA    R5,0(R5)            CLEAR HIGH BYTE.\n         LA    R2,4(R3)            SET ADDRESS OF CIB ADDRESS.\n         LTR   R5,R5               TEST IF CURRENT CIB SET UP.\n         BZ    EMPTY\nSWINI    B     SKIP\n         USING CIBDSECT,R5\n         CLI   CIBVERB,CIBSTOP     IS IT STOP (P) COMMAND.\n         BE    8(R9)               YES, RETURN +8.\n         CLI   CIBVERB,CIBMODFY    IS IT MODIFY (F) COMMAND.\n         BNE   SKIP\n         LH    R1,CIBDATLN         GET DATA FIELD LENGTH.\n         LTR   R1,R1\n         BNP   SKIP\n         LTR   R6,R6\n         BZ    PURGE\n         CH    R1,0(R6)\n         BNH   *+L'*+4\n         LH    R1,0(R6)\n         BCTR  R1,0\n         MVI   1(R6),C' '\n         EX    R1,CLDATA\n         MVC   0(2,R6),CIBDATLN    MOVE LENGTH OF DATA.\n         EX    R1,MVDATA           MOVE AND UPPER CASE DATA.\nPURGE   QEDIT  ORIGIN=(2),BLOCK=(5)\n         B     4(R9)               RETURN +4.\nCLDATA   MVC   2(*-*,R6),1(R6)\nMVDATA   OC    2(*-*,R6),CIBDATA\n         DROP  R5\nSKIP    QEDIT  ORIGIN=(2),BLOCK=(5)\n         BR    R10\nEMPTY   QEDIT  ORIGIN=(2),CIBCTR=2\n         ST    R4,ECBA             ADDR. OF ECB FOR COMMUNICATION.\n         BR    R9                  RETURN +0.\n         SPACE 1\n         DROP  R10\n         SPACE 2\nMAXNM    EQU   (MAX-1)*4\nMAXAR    EQU   (((MAX*4)+7)/8)*8\n         SPACE 2\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\nANSWER   DC    A(*-*,*-*)\nECBA     DC    A(*-*)\nMAXSP    DC    A(MAXAR)            AREA LENGTH.\nMSGLA    DC    A(*-*)              START MSG-ID'S LIST.\nLASTM    DC    A(MAXNM)\nMSGIN   WTO    '-*-*-*-*-*- TO INTERRUPT PROGRAM USE THE COMMAND = P   1\n                      ',ROUTCDE=(2),DESC=(2),MF=L\nMSGOP   WTO    '                                                       1\n                                ',ROUTCDE=(2),DESC=(2),MF=L\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OPCOM$": {"ttr": 22534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "//OPCOM    JOB (........),'INSTALL  - OPCOM -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=3\n//ASS     EXEC PAJIAS3,MBR=OPCOM\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   INIFIN\n  ALIAS   OPCOM\n  ALIAS   VERFIN\n  NAME    SETOPC(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OPCOM@": {"ttr": 22536, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00d\\x00d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 100, "newlines": 100, "modlines": 0, "user": "SYSPAJA"}, "text": "1   12/11/85\n                                                      OPCOM     1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      OPERATORS COMMUNICATIONS       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL SETOPC,(A,B),VL\n  ------------------             (A)\n\n         Where : A - is the address of the block informal text to\n                     be displayed at the system master console for\n                     operator SETUP (optional). When this argument\n                     is omitted, or the address of this argument is\n                     set to zero in the parameters list, or the\n                     parameters list pointer (register 1) is zero,\n                     the default request is assumed to be the use\n                     of the Operating System STOP (P) command only.\n                     Block informal text (the maximum text length\n                     allowed is 72 characters by message, if more,\n                     it is truncated) format :\n\n                              DC    AL1(L'TEXT1)\n                     TEXT1    DC    C'...MESSAGE 1...'\n                              DC    AL1(L'TEXT2)\n                     TEXT2    DC    C'...MESSAGE 2...'\n                     ... ... ...\n                              DC    AL1(L'TEXTN)\n                     TEXTN    DC    C'...MESSAGE n...'\n                              DC    AL1(0) or AL1(225) : end of list.\n\n                 B - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - operator communication is ready.\n                          The register 1 contains the address of the\n                          message-id's numbers list for delete use when\n                          the calling program does not terminate by the\n                          STOP or MODIFY (like STOP) operator command,\n                          and the register 0 contains the length of the\n                          GETMAINed area into which the list has been\n                          builded (for FREEMAIN purpose).\n                      1 - calling sequence or argument alignment error.\n\n         Alias : CALL INIFIN\n\n  Assembler macro : $SETOPC A,B\n  -----------------\n\n         Where A and/or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   12/11/85\n                                                      OPCOM     2/2.\n\n  Calling sequence : CALL OPCOM,(A,B),VL\n  ------------------            (A)\n\n         Where : A - is the address of the response indicator (format\n                     FULLWORD - F boundary). When the address of this\n                     argument is set to zero in the parameters list,\n                     or the parameters list pointer (register 1) is\n                     zero, the value is always placed in register 15\n                     and can be :\n\n                      1 - continue processing (nothing received from\n                          the operator).\n                      2 - STOP (P) command received.\n                      3 - MODIFY (F) command received.\n                      4 - calling sequence, argument alignment or\n                          operator communication not initialized.\n\n                 B - is the address of an array (optional) large enough\n                     (otherwise truncated) to receive the eventual\n                     MODIFY command text typed by the operator. When\n                     this argument is omitted, the MODIFY command text\n                     is not available to the caller and the response\n                     indicator is set to 2 (as STOP command received).\n                     Before any CALL, this receiving text array must be\n                     initialized as below :\n\n                      +0 - length of text receiving field (format H -\n                           halfword boundary).\n                      +2 - text receiving field (format CL...).\n\n                     The text entered by the MODIFY command is placed\n                     in the array as follows :\n\n                      +0 - length of text (format H).\n                      +2 - text (format CL..., text is uppercased).\n\n         Alias : CALL VERFIN,(A),VL\n\n  Assembler macro : $OPCOM A,B\n  -----------------\n\n         Where A and/or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJ$$ICC": {"ttr": 22539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x13G\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T13:47:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJICC   JOB (........),'ISPF COPY CLISTS',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=1\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* EXECUTE THE STEP BELOW WITH PROCEDURE :                           *\n//*       \"PAJISPF\" IF YOUR TARGET ->.ISPF.CLISTS DATA-SET            *\n//*                                IS RECFM=FB AND LRECL=80, ELSE     *\n//*       \"PAJISPV\" IF YOUR TARGET ->.ISPF.CLISTS DATA-SET            *\n//*                                IS RECFM=VB AND LRECL=255.         *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//CPY     EXEC PAJISPF,DST='->.ISPF.CLISTS'\n//CM.SYSIN  DD *\n  COPY   OUTDD=TARGET,INDD=SOURCE\n  SELECT MEMBER=(BIG,BIGS,BLOCK,CENTER,COMPRESS,CONT,CONTROL,CUT)\n  SELECT MEMBER=(DECRYPT,EDITMACS,EDMODE,EDVIO,ENCRYPT,EOL)\n  SELECT MEMBER=(FC,FIXJCL,FLOWJCL,GETPAN,JOBCARD,LJUST,MOVECOLS)\n  SELECT MEMBER=(CBOOK000,PAJCAUCP,PAJCAUTO,PAJCBLK)\n  SELECT MEMBER=(PAJCBRDS,PAJCBUMU,PAJCCOM)\n  SELECT MEMBER=(PAJCDAY,PAJCDAY1,PAJCDAY2,PAJCDAY3,PAJCDAY4)\n  SELECT MEMBER=(PAJCDSC,PAJCDSP,PAJCDSS)\n  SELECT MEMBER=(PAJCEQD1,PAJCEQD2,PAJCEQD3,PAJCEQD4,PAJCEQD5)\n  SELECT MEMBER=(PAJCGDG,PAJCIVKA,PAJCIVKB)\n  SELECT MEMBER=(PAJCIVK1,PAJCIVK2,PAJCIVK3,PAJCIVK4,PAJCIVK5,PAJCIVK6)\n  SELECT MEMBER=(PAJCLIFE,PAJCMX,PAJCMXD,PAJCMXN,PAJCPDS,PAJCSEND)\n  SELECT MEMBER=(PAJCSHWM,PAJCSLB,,PAJCSM,PAJCSSF,PAJCTOCP)\n  SELECT MEMBER=(PAJCXIL,PAJCZAP,PAJC3270)\n  SELECT MEMBER=(PARA,PEDIT,PLUG,RESUME,RJUST,SKEL,SKELCHK)\n  SELECT MEMBER=(SLINE,SUM,TRAP,UPDTMACS,ZOOM)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJ$$ICM": {"ttr": 22541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x11\\x07\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T11:07:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJICM   JOB (........),'ISPF COPY MESSAGES',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=1\n//CPY     EXEC PAJISPF,DST='->.ISPF.MESSAGES'\n//CM.SYSIN  DD *\n  COPY   OUTDD=TARGET,INDD=SOURCE\n  SELECT MEMBER=(MBKS00)\n  SELECT MEMBER=(PAJA00,PAJB00,PAJD00,PAJG00,PAJI00)\n  SELECT MEMBER=(PAJM99,PAJS00,PAJU00,PAJX00,PAJZ00)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJ$$ICP": {"ttr": 22543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943?\\x00\\x943?\\x17\\x18\\x007\\x007\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-29T00:00:00", "modifydate": "1994-11-29T17:18:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJICP   JOB (........),'ISPF COPY PANELS',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=1\n//CPY     EXEC PAJISPF,DST='->.ISPF.PANELS'\n//CM.SYSIN  DD *\n  COPY   OUTDD=TARGET,INDD=SOURCE\n  SELECT MEMBER=(PAJMENU,PAJIAP,PAJVRS)\n  SELECT MEMBER=(PAJALL,PAJTALL,PAJAUCP,PAJTAUCP,PAJBLK,PAJTBLK)\n  SELECT MEMBER=(PAJTB000,PAJTB001,PAJTB002,PAJTB003)\n  SELECT MEMBER=(PAJTB010,PAJTB011,PAJTB012,PAJTB013)\n  SELECT MEMBER=(PAJTB020,PAJTB021,PAJTB022)\n  SELECT MEMBER=(PAJTB030,PAJTB031,PAJTB032)\n  SELECT MEMBER=(PAJTK000,PAJTK001,PAJTK002)\n  SELECT MEMBER=(PAJTK010,PAJTK011,PAJTK012)\n  SELECT MEMBER=(PAJTK020,PAJTK021,PAJTK030,PAJTK031)\n  SELECT MEMBER=(PAJCOM,PAJTCOM,PAJCRY,PAJTCRY,PAJTCRY1)\n  SELECT MEMBER=(PAJDAY,PAJTDAY,PAJTDAYH,PAJDAYS,PAJTDAYS)\n  SELECT MEMBER=(PAJDAYS1,PAJDAYS2,PAJDAYS3,PAJDAYS4)\n  SELECT MEMBER=(PAJDSC,PAJTDSC,PAJDSP,PAJTDSP)\n  SELECT MEMBER=(PAJDSPL,PAJTDSPL,PAJDSS,PAJTDSS)\n  SELECT MEMBER=(PAJEM,PAJTEM,PAJTEM1,PAJTEM2,PAJTEM3,PAJTEM4,PAJTEM5)\n  SELECT MEMBER=(PAJTEM6,PAJTEM7,PAJTEM8,PAJTEM9,PAJTEM10,PAJTEM11)\n  SELECT MEMBER=(PAJEMA,PAJEML,PAJEMP,PAJEMU,PAJTEMU)\n  SELECT MEMBER=(PAJEOL,PAJEQD,PAJTEQD,PAJGDDM,PAJTGDDM)\n  SELECT MEMBER=(PAJGDG,PAJGDGM,PAJTGDG,PAJTGDGM)\n  SELECT MEMBER=(PAJIVK,PAJTIVK,PAJIVK1,PAJTIVK1)\n  SELECT MEMBER=(PAJLIFE,PAJMOF,PAJTMOF)\n  SELECT MEMBER=(PAJMX0,PAJMX1,PAJMX2,PAJMX3,PAJMX4,PAJMX5)\n  SELECT MEMBER=(PAJTMX0,PAJTMX1,PAJTMX2,PAJTMX3,PAJTMX4,PAJTMX5)\n  SELECT MEMBER=(PAJTMX6,PAJTMX7,PAJTMX8,PAJTMX9,PAJTMX10)\n  SELECT MEMBER=(PAJPARD,PAJPARI,PAJTPAR,PAJTPAR0,PAJTPAR1,PAJTPAR2)\n  SELECT MEMBER=(PAJTPAR3,PAJTPAR4,PAJTPAR5,PAJTPAR6,PAJTPAR7)\n  SELECT MEMBER=(PAJTPARA,PAJTPARB,PAJTPARC,PAJTPARD,PAJTPARE)\n  SELECT MEMBER=(PAJTPARF,PAJTPARG)\n  SELECT MEMBER=(PAJPDS,PAJTPDS,PAJTPDSL,PAJPED,PAJTPED)\n  SELECT MEMBER=(PAJPLUG,PAJPOF,PAJTPOF,PAJSEND)\n  SELECT MEMBER=(PAJSHWM,PAJTSHW0,PAJTSHW1,PAJSLB,PAJTSLB)\n  SELECT MEMBER=(PAJSM,PAJSM1,PAJSM2,PAJTSM1,PAJTSM2,PAJTSM3)\n  SELECT MEMBER=(PAJSNK,PAJTSNK0,PAJTSNK1,PAJSSF,PAJTSSF)\n  SELECT MEMBER=(PAJSUM,PAJSUMX,PAJSUMY,PAJSUMZ,PAJTOCP,PAJTTOCP)\n  SELECT MEMBER=(PAJVQ1,PAJVQ2,PAJTVQ1,PAJTVQ11,PAJTVQ2)\n  SELECT MEMBER=(PAJWRM,PAJTWRM0,PAJTWRM1,PAJTWRM2,PAJTWRM3)\n  SELECT MEMBER=(PAJXIL,PAJXILX,PAJTXIL,PAJZAP,PAJTZAP)\n  SELECT MEMBER=(PAJ3270,PAJT3270,PAJTBIG,PAJTBIGS,PAJTCNTR)\n  SELECT MEMBER=(PAJTCOMP,PAJTCONT,PAJTCTRL,PAJTCUT,PAJTCUT1,PAJTCUT2)\n  SELECT MEMBER=(PAJTCUT3,PAJTCUT4,PAJTCUT5,PAJTEDCR,PAJTFC)\n  SELECT MEMBER=(PAJTFJCL,PAJTFJCX,AJTFLWJ,PAJTGPAN,PAJTJBCD,PAJTJCLF)\n  SELECT MEMBER=(PAJTLJ,PAJTMVC,PAJTMVC1,PAJTMVC2,PAJTRJ)\n  SELECT MEMBER=(PAJTRSM,PAJTSEPL,PAJTSKC,PAJTSKL,PAJTSKL1)\n  SELECT MEMBER=(PAJTSTT1,PAJTSTT2,PAJTSTT3,PAJTSTT4,PAJTTRAP,PAJTZOOM)\n  SELECT MEMBER=(PBOOK0,PBOOK00,PBOOK000)\n  SELECT MEMBER=(PBOOK1,PBOOK2,PBOOK3,PBOOK4,PBOOK5,PBOOK6)\n  SELECT MEMBER=(PBOOKT1,PBOOKT2,PBOOKT3,PBOOKT4,PBOOKT5)\n  SELECT MEMBER=(PBOOKT6,PBOOKT7,PBOOKT8,PBOOKT9)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJ$$ICS": {"ttr": 22545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x115\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T11:35:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJICS   JOB (........),'ISPF COPY SKELETONS',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=1\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* BEFORE EXECUTION OF THIS JOB, ADJUST THE ->.TARGET.LINKLIB IN     *\n//*            THE SKELETON 'PAJSPDS' (MOVED BY STEP BELOW).          *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//CPY     EXEC PAJISPF,DST='->.ISPF.SKELETONS'\n//CM.SYSIN   DD *\n  COPY   OUTDD=TARGET,INDD=SOURCE\n  SELECT MEMBER=(SBOOK0,PAJSBUMU,PAJSDSP,PAJSIVKA,PAJSIVKB)\n  SELECT MEMBER=(PAJSMX1,PAJSMX2,PAJSPDS,PAJSSHWM,PAJSSSF)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJ$$ICT": {"ttr": 22547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x115\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T11:35:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJICT   JOB (........),'ISPF COPY TABLES',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=1\n//CPY     EXEC PAJISPF,DST='->.ISPF.TABLES'\n//CM.SYSIN  DD *\n  COPY   OUTDD=TARGET,INDD=SOURCE\n  SELECT MEMBER=((EDITMACT,EDITMACS))\n  SELECT MEMBER=(TMTH,TMTHD,TMTHDK,TMTHE,TMTHF,TMTHI,TMTHP)\n  SELECT MEMBER=(TWKD,TWKDD,TWKDDK,TWKDE,TWKDF,TWKDI,TWKDP)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJ$ALL": {"ttr": 22549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14#\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:23:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJPALL  JOB (........),'INSTALL - P A L L -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* REMARK : PROGRAM CALLED ONLY BY THE ISPF PANEL 'PAJMENU'.         *\n//* NOTE : AT ASSEMBLY, YOU MAY SET THE SYSPARM AS BELOW :            *\n//*        FULL  =  PRINT GEN FOR THE ENTIRE LIST                     *\n//*        NONE  =  REDUCED PRINT GEN                                 *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT,SYSPARM(NONE)',MBR=PAJPALL\n//LNK     EXEC PAJILKI,OPT=',RENT'\n//SYSIN     DD *\n  INCLUDE      SYSISP(ISPLINK)\n  ENTRY   PAJPALL\n  NAME    PAJPALL(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJ$BLK1": {"ttr": 22551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14#\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:23:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJPBLK1 JOB (........),'INSTALL  - BLK 1 -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                DAUNTY    VGPSUB                                   *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=PAJPBLK1\n//LNK     EXEC PAJILKI\n//SYSIN     DD *\n  INCLUDE      SYSISP(ISPLINK)\n  INCLUDE      SYSADD(VGPSUB,DAUNTY)\n  ENTRY   PAJPBLK1\n  NAME    PAJPBLK1(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJ$BLK2": {"ttr": 22785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14#\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:23:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJPBLK2 JOB (........),'INSTALL  - BLK 2 -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                DAUNTY    VGPSUB                                   *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,MBR=PAJPBLK2\n//LNK     EXEC PAJILKI\n//SYSIN     DD *\n  INCLUDE      SYSISP(ISPLINK)\n  INCLUDE      SYSADD(VGPSUB,DAUNTY)\n  ENTRY   PAJPBLK2\n  NAME    PAJPBLK2(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJ$BUMU": {"ttr": 22787, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14#\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:23:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJPBUMU JOB (........),'INSTALL - B U M U -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC   EUSUB     GUAR      VGPSUB               *\n//* REMARK : PROGRAM CALLED ONLY BY THE ISPF PROCEDURE 'PAJCBUMU',    *\n//* -------- WHICH IN TURN IS USED BY ISPF PANEL 'PAJMOF'.            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,MBR=PAJPBUMU\n//ASP     EXEC PAJIAS2,OPT=',SYSPARM(CALL)',MBR=PSWREST\n//LNK     EXEC PAJILKI\n//SYSIN     DD *\n  INCLUDE      SYSISP(ISPLINK)\n  INCLUDE      SYSADD(GUAR,VGPSUB)\n  ENTRY   PAJPBUMU\n  NAME    PAJPBUMU(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJ$MX": {"ttr": 22789, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14#\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:23:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJPMX   JOB (........),'INSTALL - P M X -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                CRY                                                *\n//* REMARK : PROGRAM CALLED ONLY BY THE ISPF PROCEDURE 'PAJCMX',      *\n//* -------- WHICH IN TURN IS USED BY ISPF PANEL 'PAJIAP'.            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,MBR=PAJPMX\n//LNK     EXEC PAJILKI\n//SYSIN     DD *\n  INCLUDE      SYSISP(ISPLINK)\n  ENTRY   PAJPMX\n  NAME    PAJPMX(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJ$POF": {"ttr": 22791, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14#\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:23:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJPPOF  JOB (........),'INSTALL -ISPF POF-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* REMARK : PROGRAM CALLED ONLY BY THE ISPF PANEL 'PAJIVK'.          *\n//* --------                                                          *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=PAJPPOF\n//LNK     EXEC PAJILKI\n//SYSIN     DD *\n  INCLUDE      SYSISP(ISPLINK)\n  ENTRY   PAJPPOF\n  NAME    PAJPPOF(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJ$VQ": {"ttr": 22793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14#\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:23:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "//PAJPVQ   JOB (........),'INSTALL - P V Q -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=2\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* REMARK : PROGRAM CALLED ONLY BY THE ISPF PANEL 'PAJEQD'.          *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=PAJPVQ\n//LNK     EXEC PAJILKI\n//SYSIN     DD *\n  INCLUDE      SYSISP(ISPLINK)\n  ENTRY   PAJPVQ\n  NAME    PAJPVQ(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJALL": {"ttr": 22795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90&\\x1f\\x00\\x90&\\x1f\\x11C\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-09-18T00:00:00", "modifydate": "1990-09-18T11:43:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n  { TYPE(OUTPUT) INTENS(LOW) CAPS(ON) JUST(LEFT)\n  \u00a6 TYPE(OUTPUT) INTENS(LOW) CAPS(ON) JUST(ASIS)\n  ` TYPE(OUTPUT) INTENS(LOW) CAPS(ON) JUST(RIGHT)\n)BODY\n% Allocation Summary -----------------------------------------------------------\n+Command%===>_ZCMD                                            %SCROLL ===>_AMT +\n\n The following data-sets are allocated to%&ZUSER\n  DDname   Data-set name                  Disp DSORG RECFM LRECL BLKSZ VOLSER\n  -------- ------------------------------ ---- ----- ----- ----- ----- ------  +\n)MODEL\n+ {Z       \u00a6Z                             {Z    {Z    {Z   `Z    `Z    {Z\n)INIT\n  .ZVARS = '(WALDD WALDSN WALDISP WALDORG WALFMT WALRECL WALBLK WALVOL)'\n  .HELP = PAJTALL\n  &AMT = PAGE\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJAUCP": {"ttr": 22797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90)/\\x00\\x90)/\\x10I\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-19T00:00:00", "modifydate": "1990-10-19T10:49:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n@ TYPE(OUTPUT) INTENS(LOW)\n)BODY\n%SPECIAL - Command authorization interface -------------------------------------\n+Command%===>_RCMD\n\n\n+                                                             %SCROLL ===>_AMT +\n%Set authorization :_RAUT+(OFF/ON)\n+==============================================================================+\n)MODEL\n@Z\n)INIT\n  .ZVARS = '(XY)'\n  .HELP = PAJTAUCP\n  .CURSOR = RCMD\n  IF (&AMT = &Z)\n    &AMT = PAGE\n  &RAUT = TRANS (&RAUT ' ',OFF *,*)\n  &ZTDMARK = '=================================== Bottom +\n              ==================================='\n)PROC\n  VER (&RCMD,NONBLANK)\n  &CHKC = TRUNC (&RCMD,' ')\n  IF (&CHKC = 'F')\n    &RCMD = TRUNC (&RCMD,' ')\n    &CHCK = .TRAIL\n    IF (&CHCK = &Z)\n      VER (&FCMD,NONBLANK)\n    IF (&CHCK \u00ac= &Z)\n      &FCMD = &CHCK\n  &RAUT = TRUNC (&RAUT,2)\n  &RAUT = TRANS (&RAUT ON,ON OF,OFF *,*)\n  VER (&RAUT,NONBLANK)  VER (&RAUT,LIST,ON,OFF)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJA00": {"ttr": 22799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90&\\x1f\\x00\\x90&\\x1f\\tX\\x00`\\x00`\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-09-18T00:00:00", "modifydate": "1990-09-18T09:58:00", "lines": 96, "newlines": 96, "modlines": 0, "user": "SYSPAJA"}, "text": "PAJA000A 'CONTROL error - RC = 04'   .HELP=PAJTALL    .ALARM=NO\n'CONTROL completed with an invalid return code. Notify Systems Programming'\n\nPAJA000B 'CONTROL error - RC = 08'  .HELP=PAJTALL    .ALARM=NO\n'Split screen remains enabled. Notify Systems Programming'\n\nPAJA000C 'CONTROL error - RC = 12'  .HELP=PAJTALL    .ALARM=NO\n'CONTROL completed with an invalid return code. Notify Systems Programming'\n\nPAJA000D 'CONTROL error - RC = 16'   .HELP=PAJTALL    .ALARM=NO\n'CONTROL completed with an invalid return code. Notify Systems Programming'\n\nPAJA000E 'CONTROL error - RC = 20'   .HELP=PAJTALL    .ALARM=NO\n'Severe error. Notify Systems Programming'\n\nPAJA001A 'TBADD error - RC = 04'     .HELP=PAJTALL    .ALARM=NO\n'TBADD completed with an invalid return code. Notify Systems Programming'\n\nPAJA001B 'TBADD error - RC = 08'     .HELP=PAJTALL    .ALARM=NO\n'Row with the same key already exists; CRP set to top (zero)'\n\nPAJA001C 'TBADD error - RC = 12'     .HELP=PAJTALL    .ALARM=NO\n'Table is not open'\n\nPAJA001D 'TBADD error - RC = 16'     .HELP=PAJTALL    .ALARM=NO\n'Numeric convert error; see numeric restrictions for TBSORT'\n\nPAJA001E 'TBADD error - RC = 20'     .HELP=PAJTALL    .ALARM=NO\n'Severe error. Notify Systems Programming'\n\nPAJA002A 'TBCREATE error - RC = 08'  .HELP=PAJTALL    .ALARM=NO\n'Table already exists; REPLACE was not specified'\n\nPAJA002B 'TBCREATE error - RC = 12'  .HELP=PAJTALL    .ALARM=NO\n'Table in use; ENQ failed'\n\nPAJA002C 'TBCREATE error - RC = 16'  .HELP=PAJTALL    .ALARM=NO\n'Write mode specified and table input library is not allocated'\n\nPAJA002D 'TBCREATE error - RC = 20'  .HELP=PAJTALL    .ALARM=NO\n'Severe error. Notify Systems Programming'\n\nPAJA003A 'VDEFINE error - RC = 04'   .HELP=PAJTALL    .ALARM=NO\n'VDEFINE completed with an invalid return code. Notify Systems Programming'\n\nPAJA003B 'VDEFINE error - RC = 08'  .HELP=PAJTALL    .ALARM=NO\n'Variable not found'\n\nPAJA003C 'VDEFINE error - RC = 12'  .HELP=PAJTALL    .ALARM=NO\n'VDEFINE completed with an invalid return code. Notify Systems Programming'\n\nPAJA003D 'VDEFINE error - RC = 16'   .HELP=PAJTALL    .ALARM=NO\n'Data truncation occurred'\n\nPAJA003E 'VDEFINE error - RC = 20'   .HELP=PAJTALL    .ALARM=NO\n'Severe error. Notify Systems Programming'\n\nPAJA004A 'TBDISPL error - RC = 12'  .HELP=PAJTALL    .ALARM=NO\n'The specified panel or message could not be found or the table was not open'\n\nPAJA004B 'TBDISPL error - RC = 16'   .HELP=PAJTALL    .ALARM=NO\n'TBDISPL completed with an invalid return code. Notify Systems Programming'\n\nPAJA004C 'TBDISPL error - RC = 20'   .HELP=PAJTALL    .ALARM=NO\n'Severe error. Notify Systems Programming'\n\nPAJA005A 'VREPLACE error - RC = 04'  .HELP=PAJTALL    .ALARM=NO\n'VREPLACE completed with an invalid return code. Notify Systems Programming'\n\nPAJA005B 'VREPLACE error - RC = 08' .HELP=PAJTALL    .ALARM=NO\n'VREPLACE completed with an invalid return code. Notify Systems Programming'\n\nPAJA005C 'VREPLACE error - RC = 12' .HELP=PAJTALL    .ALARM=NO\n'VREPLACE completed with an invalid return code. Notify Systems Programming'\n\nPAJA005D 'VREPLACE error - RC = 16'  .HELP=PAJTALL    .ALARM=NO\n'Truncation has occurred during data movement'\n\nPAJA005E 'VREPLACE error - RC = 20'  .HELP=PAJTALL    .ALARM=NO\n'Severe error. Notify Systems Programming'\n\nPAJA006A 'TBTOP error - RC = 04'     .HELP=PAJTALL    .ALARM=NO\n'TBTOP completed with an invalid return code. Notify Systems Programming'\n\nPAJA006B 'TBTOP error - RC = 08'    .HELP=PAJTALL    .ALARM=NO\n'TBTOP completed with an invalid return code. Notify Systems Programming'\n\nPAJA006C 'TBTOP error - RC = 12'    .HELP=PAJTALL    .ALARM=NO\n'Table is not open'\n\nPAJA006D 'TBTOP error - RC = 16'     .HELP=PAJTALL    .ALARM=NO\n'TBTOP completed with an invalid return code. Notify Systems Programming'\n\nPAJA006E 'TBTOP error - RC = 20'     .HELP=PAJTALL    .ALARM=NO\n'Severe error. Notify Systems Programming'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJBLK": {"ttr": 22802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x9f\\x00\\x88\\x15\\x9f\\x103\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-07T00:00:00", "modifydate": "1988-06-07T10:33:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n  @ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD(NULLS)\n)BODY\n%BLKSIZE -----------  Disk block sizes computations/tables  --------------------\n%Enter/verify values below:\n+\n+ DEVICES TYPES%===>@UTYPE                      + or use PF1 (Help) for tables\n+ LRECL%===>_LRECL+     MAX BLKSIZE%===>_BLOCK+     KEYLEN%===>_KEY+\n+\n%&U1     +%&KD1        +%&B11  +%&B12  +%&B13  +%&B14  +%&B15  +%&B16  +%&B17  +\n+ &NC1   + &BT1        +%&N11  +%&N12  +%&N13  +%&N14  +%&N15  +%&N16  +%&N17  +\n+          &RB1        +%&R11  +%&R12  +%&R13  +%&R14  +%&R15  +%&R16  +%&R17  +\n+          &RT1        +%&T11  +%&T12  +%&T13  +%&T14  +%&T15  +%&T16  +%&T17  +\n+          &RC1        +%&C11  +%&C12  +%&C13  +%&C14  +%&C15  +%&C16  +%&C17  +\n+\n%&U2     +%&KD2        +%&B21  +%&B22  +%&B23  +%&B24  +%&B25  +%&B26  +%&B27  +\n+ &NC2   + &BT2        +%&N21  +%&N22  +%&N23  +%&N24  +%&N25  +%&N26  +%&N27  +\n+          &RB2        +%&R21  +%&R22  +%&R23  +%&R24  +%&R25  +%&R26  +%&R27  +\n+          &RT2        +%&T21  +%&T22  +%&T23  +%&T24  +%&T25  +%&T26  +%&T27  +\n+          &RC2        +%&C21  +%&C22  +%&C23  +%&C24  +%&C25  +%&C26  +%&C27  +\n+\n%&U3     +%&KD3        +%&B31  +%&B32  +%&B33  +%&B34  +%&B35  +%&B36  +%&B37  +\n+ &NC3   + &BT3        +%&N31  +%&N32  +%&N33  +%&N34  +%&N35  +%&N36  +%&N37  +\n+          &RB3        +%&R31  +%&R32  +%&R33  +%&R34  +%&R35  +%&R36  +%&R37  +\n+          &RT3        +%&T31  +%&T32  +%&T33  +%&T34  +%&T35  +%&T36  +%&T37  +\n+          &RC3        +%&C31  +%&C32  +%&C33  +%&C34  +%&C35  +%&C36  +%&C37  +\n)INIT\n  .HELP = PAJTBLK\n  .CURSOR = LRECL\n)PROC\n  VER (&UTYPE,NONBLANK)\n  VER (&LRECL,NONBLANK)  VER (&LRECL,NUM)\n  IF (&BLOCK \u00ac= ' ')\n    VER (&BLOCK,NUM)\n  VER (&KEY,RANGE,0,255)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJB00": {"ttr": 22804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88(_\\x00\\x88(_\\x14\\x00\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-10-11T00:00:00", "modifydate": "1988-10-11T14:00:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "PAJB000A 'UTYPE VGET error  '  .ALARM=YES\n'See ERR1 in program PAJPBLK1'\n\nPAJB000B 'Dev. types missing'  .ALARM=YES\n'Enter at least one device type'\n\nPAJB000C 'Wrong dev. type   '  .ALARM=YES\n'First device type is invalid'\n\nPAJB000D 'Wrong dev. type   '  .ALARM=YES\n'Second device type is invalid'\n\nPAJB000E 'Wrong dev. type   '  .ALARM=YES\n'Third device type is invalid'\n\nPAJB000F 'Unknown dev. type '  .ALARM=YES\n'First device type is unknown (see DAUTTB/DAUNTY)'\n\nPAJB000G 'Undef. dev. type  '  .ALARM=YES\n'First device type is not generated in the system'\n\nPAJB000H 'Unknown dev. type '  .ALARM=YES\n'Second device type is unknown (see DAUTTB/DAUNTY)'\n\nPAJB000I 'Undef. dev. type  '  .ALARM=YES\n'Second device type is not generated in the system'\n\nPAJB000J 'Unknown dev. type '  .ALARM=YES\n'Third device type is unknown (see DAUTTB/DAUNTY)'\n\nPAJB000K 'Undef. dev. type  '  .ALARM=YES\n'Third device type is not generated in the system'\n\nPAJB000L 'U1 VPUT error     '  .ALARM=YES\n'See ERR12 in program PAJPBLK1'\n\nPAJB000M 'NC1 VPUT error    '  .ALARM=YES\n'See ERR13 in program PAJPBLK1'\n\nPAJB000N 'U2 VPUT error     '  .ALARM=YES\n'See ERR14 in program PAJPBLK1'\n\nPAJB000O 'NC2 VPUT error    '  .ALARM=YES\n'See ERR15 in program PAJPBLK1'\n\nPAJB000P 'U3 VPUT error     '  .ALARM=YES\n'See ERR16 in program PAJPBLK1'\n\nPAJB000Q 'NC3 VPUT error    '  .ALARM=YES\n'See ERR17 in program PAJPBLK1'\n\nPAJB000R 'NTC1 VPUT error   '  .ALARM=YES\n'See ERR18 in program PAJPBLK1'\n\nPAJB000S 'NBT1 VPUT error   '  .ALARM=YES\n'See ERR19 in program PAJPBLK1'\n\nPAJB000T 'NTC2 VPUT error   '  .ALARM=YES\n'See ERR20 in program PAJPBLK1'\n\nPAJB000U 'NBT2 VPUT error   '  .ALARM=YES\n'See ERR21 in program PAJPBLK1'\n\nPAJB000V 'NTC3 VPUT error   '  .ALARM=YES\n'See ERR22 in program PAJPBLK1'\n\nPAJB000W 'NBT3 VPUT error   '  .ALARM=YES\n'See ERR23 in program PAJPBLK1'\n\nPAJB000X 'U1TY VPUT error   '  .ALARM=YES\n'See ERR24 in program PAJPBLK1'\n\nPAJB000Y 'U2TY VPUT error   '  .ALARM=YES\n'See ERR25 in program PAJPBLK1'\n\nPAJB000Z 'U3TY VPUT error   '  .ALARM=YES\n'See ERR26 in program PAJPBLK1'\n\nPAJB001A 'U1 VGET error     '  .ALARM=YES\n'See ERR1 in program PAJPBLK2'\n\nPAJB001B 'U2 VGET error     '  .ALARM=YES\n'See ERR2 in program PAJPBLK2'\n\nPAJB001C 'U3 VGET error     '  .ALARM=YES\n'See ERR3 in program PAJPBLK2'\n\nPAJB001D 'KEY VGET error    '  .ALARM=YES\n'See ERR4 in program PAJPBLK2'\n\nPAJB001E 'U1 missing        '  .ALARM=YES\n'See ERR5 in program PAJPBLK2'\n\nPAJB001F 'U1 unknown        '  .ALARM=YES\n'See ERR6 in program PAJPBLK2'\n\nPAJB001G 'BU1 VGET error    '  .ALARM=YES\n'See ERR7 in program PAJPBLK2'\n\nPAJB001H 'U2 unknown        '  .ALARM=YES\n'See ERR8 in program PAJPBLK2'\n\nPAJB001I 'BU2 VGET error    '  .ALARM=YES\n'See ERR9 in program PAJPBLK2'\n\nPAJB001J 'U3 unknown        '  .ALARM=YES\n'See ERR10 in program PAJPBLK2'\n\nPAJB001K 'BU3 VGET error    '  .ALARM=YES\n'See ERR11 in program PAJPBLK2'\n\nPAJB001L 'NU1 VPUT error    '  .ALARM=YES\n'See ERR12 in program PAJPBLK2'\n\nPAJB001M 'NU2 VPUT error    '  .ALARM=YES\n'See ERR13 in program PAJPBLK2'\n\nPAJB001N 'NU3 VPUT error    '  .ALARM=YES\n'See ERR14 in program PAJPBLK2'\n\nPAJB009A 'BLKSIZE < LRECL   '  .ALARM=YES\n'Enter a correct BLKSIZE or leave blank to assume max BLKSIZE'\n\nPAJB009B 'LRECL too large   '  .ALARM=YES\n'LRECL is too large for device &U1'\n\nPAJB009C 'LRECL too large   '  .ALARM=YES\n'LRECL is too large for device &U2'\n\nPAJB009D 'LRECL too large   '  .ALARM=YES\n'LRECL is too large for device &U3'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJCAUCP": {"ttr": 22807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x11\\x7f\\x00\\x94\\x11\\x7f\\t8\\x00W\\x00W\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-27T00:00:00", "modifydate": "1994-04-27T09:38:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         CONTROL MAIN MSG\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN EXIT\n         ISPEXEC CONTROL ERRORS CANCEL\n         SET &PCMD =\n         SET &FCMD =\n         ISPEXEC TBCREATE XYTABLE REPLACE NOWRITE NAMES(XY)\n         SET &XY = &STR(*** READY ***)\n         ISPEXEC TBADD XYTABLE\nTBDR:    SET &RCMD =\n         SET &TBRC = 0\n         SET &ZTDTOP = 0\nTBDX:    IF &TBRC EQ 4 THEN GOTO TBDP\n         ISPEXEC TBTOP XYTABLE\n         ISPEXEC TBSKIP XYTABLE NUMBER(&ZTDTOP)\n         ISPEXEC VGET (ZVERB ZSCROLLN)\n         IF &ZVERB EQ UP THEN -\n           ISPEXEC TBSKIP XYTABLE NUMBER(-&ZSCROLLN)\n         ELSE IF &ZVERB EQ DOWN THEN -\n           ISPEXEC TBSKIP XYTABLE NUMBER(&ZSCROLLN)\nTBDP:    ISPEXEC TBDISPL XYTABLE PANEL(PAJAUCP) POSITION(ROW)\n         SET &TBRC = &LASTCC\n         IF &STR(&RCMD) EQ &STR(CANCEL) OR &TBRC GT 4 THEN GOTO TBEX\n         IF &STR(&RCMD) EQ &STR(*) THEN SET &RCMD = &PCMD\n         IF &STR(&RCMD) EQ &STR(?) THEN GOTO TBRD\n         IF &STR(&RCMD) EQ &STR(F) THEN GOTO TBFN\n         SET &PCMD = &NRSTR(&RCMD)\n         IF &STR(&RCMD) EQ THEN GOTO TBNC\n         SET &SYSOUTTRAP = 5000\n         IF &RAUT EQ ON THEN DO\n           AUTHC &RCMD\n           SET &CMRC = &LASTCC\n           END\n         ELSE DO\n           TSOEXEC &RCMD\n           SET &CMRC = &LASTCC\n           END\n         SET &NL = &SYSOUTLINE\n         SET &SYSOUTTRAP = 0\n         SET &N = 1\n         SET &LN = &STR(&&)\n         ISPEXEC TBCREATE XYTABLE REPLACE NOWRITE NAMES(XY)\n         CONTROL ASIS\n         DO WHILE &N LE &NL\n           SET &XY = &SYSNSUB(2,&LN.SYSOUTLINE&N)\n           ISPEXEC TBADD XYTABLE\n           SET &N = &N + 1\n           END\n         CONTROL CAPS\n         SET &XY = &STR(*** COMMAND ENDED WITH RETURN CODE &CMRC ***)\n         ISPEXEC TBADD XYTABLE\n         GOTO TBDR\nTBNC:    ISPEXEC TBCREATE XYTABLE REPLACE NOWRITE NAMES(XY)\n         SET &XY = &STR(*** THERE IS NO PREVIOUS COMMAND ***)\n         ISPEXEC TBADD XYTABLE\n         GOTO TBDR\nTBRD:    SET &RCMD = &NRSTR(&PCMD)\n         IF &STR(&RCMD) EQ THEN GOTO TBNC\n         SET &TBRC = 4\n         GOTO TBDX\nTBFN:    SET &RCMD =\n         ISPEXEC TBSKIP XYTABLE NUMBER(&ZTDTOP)\n         ISPEXEC TBSKIP XYTABLE NUMBER(+1) POSITION(ROW)\n         SET &FNRC = &LASTCC\n         IF &FNRC NE 8 THEN GOTO TBFT\n         ISPEXEC TBTOP XYTABLE\nTBFS:    ISPEXEC TBSKIP XYTABLE NUMBER(+1) POSITION(ROW)\n         SET &FNRC = &LASTCC\nTBFT:    IF &FNRC NE 0 THEN GOTO TBFE\n         ISPEXEC TBGET XYTABLE POSITION(ROW)\n         SET &FNRC = &LASTCC\n         IF &FNRC NE 0 THEN GOTO TBFE\n         SET &N = &SYSINDEX(&NRSTR(&FCMD),&NRSTR(&XY))\n         IF &N EQ 0 THEN GOTO TBFS\n         SET &TBRC = 4\n         GOTO TBDX\nTBFE:    IF &FNRC EQ 8 THEN -\n           ISPEXEC TBBOTTOM XYTABLE NOREAD POSITION(ROW)\n         ELSE IF &ROW NE 0 THEN -\n           ISPEXEC TBSKIP XYTABLE NUMBER(-1) NOREAD POSITION(ROW)\n         SET &TBRC = 4\n         GOTO TBDX\nTBEX:    ISPEXEC TBEND XYTABLE\n         IF &TBRC NE 8 THEN DO\n           WRITE *** EXIT CODE &TBRC ***\n           END\n         CONTROL MSG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCAUTO": {"ttr": 22810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x14_\\x00\\x88\\x14_\\x15\\x13\\x00\\x03\\x00\\x03\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-24T00:00:00", "modifydate": "1988-05-24T15:13:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 LDDS(...OPERATOR.LIBRARY...) LDMB()\n         IF &SYSISPF = ACTIVE THEN ISPEXEC VGET (LDDS LDMB)\n         AUTOCI '&LDDS' &LDMB TEST\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCBLK": {"ttr": 23041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x880/\\x00\\x880/\\t\"\\x00\\xd2\\x00\\xd2\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-10-28T00:00:00", "modifydate": "1988-10-28T09:22:00", "lines": 210, "newlines": 210, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         SET &OUTY = 0\n         SET &OBLOCK = 0\n         SET &OLRECL = 0\n         SET &OKEY = 0\n         SET &C = &STR(&&)\n         SET &UTYPE = &STR(3380)\n         SET &KEY = 0\n         SET &U1 =\n         SET &NC1 =\n         SET &U2 =\n         SET &NC2 =\n         SET &U3 =\n         SET &NC3 =\n/* ----> CONTROL LIST CONLIST SYMLIST <---- */\nIS:      ISPEXEC DISPLAY PANEL(PAJBLK) CURSOR(LRECL)\n         IF &LASTCC = 8 THEN END\nISSET:   ISPEXEC VPUT (UTYPE)\n         ISPEXEC SELECT PGM(PAJPBLK1)\n         SET &CC = &LASTCC\n         IF &CC > 0 THEN GOTO ERR1\n         ISPEXEC VGET (U1 NC1 U2 NC2 U3 NC3)\n         ISPEXEC VGET (NTC1 NBT1 NTC2 NBT2 NTC3 NBT3)\n         ISPEXEC VGET (U1TY U2TY U3TY)\n         SET &UTY = &U1TY + (&U2TY * 100) + (&U3TY * 10000)\n         IF (&UTY = &OUTY                                            -\n             AND &BLOCK = &OBLOCK                                    -\n             AND &LRECL = &OLRECL                                    -\n             AND &KEY = &OKEY) THEN GOTO IS\n         IF &BLOCK = THEN GOTO SETMU\n         IF &BLOCK < &LRECL THEN GOTO ERR2\n         SET &BSZ = ((&BLOCK / &LRECL) * &LRECL)\n         SET &BKSZ = &BSZ + &KEY\n         SET &BU1 = &BSZ\n         IF &BKSZ <= &NBT1 THEN GOTO OKU1\n         SET &BU1 = (((&NBT1 - &KEY) / &LRECL) * &LRECL)\nOKU1:    IF &U2TY = 0 THEN GOTO SETCK\n         SET &BU2 = &BSZ\n         IF &BKSZ <= &NBT2 THEN GOTO OKU2\n         SET &BU2 = (((&NBT2 - &KEY) / &LRECL) * &LRECL)\nOKU2:    IF &U3TY = 0 THEN GOTO SETCK\n         SET &BU3 = &BSZ\n         IF &BKSZ <= &NBT3 THEN GOTO SETCK\n         SET &BU3 = (((&NBT3 - &KEY) / &LRECL) * &LRECL)\n         GOTO SETCK\nSETMU:   SET &BU1 = (((&NBT1 - &KEY) / &LRECL) * &LRECL)\n         IF &U2TY = 0 THEN GOTO SETCK\n         SET &BU2 = (((&NBT2 - &KEY) / &LRECL) * &LRECL)\n         IF &U3TY = 0 THEN GOTO SETCK\n         SET &BU3 = (((&NBT3 - &KEY) / &LRECL) * &LRECL)\nSETCK:   SET &OUTY = &UTY\n         SET &OBLOCK = &BLOCK\n         SET &OLRECL = &LRECL\n         SET &OKEY = &KEY\nAGAIN:   ISPEXEC VPUT (U1 U2 U3 KEY BU1 BU2 BU3)\n         ISPEXEC SELECT PGM(PAJPBLK2)\n         SET &CC = &LASTCC\n         IF &CC > 0 THEN GOTO ERR3\n         ISPEXEC VGET (NU1 NU2 NU3)\n         SET &CC = 0\n         IF &NU1 > 0 THEN GOTO TSU2\n         IF &LRECL >= &BU1 THEN GOTO ERR4\n         SET &CC = 1\n         SET &BU1 = &BU1 - &LRECL\nTSU2:    IF &U2TY = 0 THEN GOTO TSALL\n         IF &NU2 > 0 THEN GOTO TSU3\n         IF &LRECL >= &BU2 THEN GOTO ERR5\n         SET &CC = 1\n         SET &BU2 = &BU2 - &LRECL\nTSU3:    IF &U3TY = 0 THEN GOTO TSALL\n         IF &NU3 > 0 THEN GOTO TSALL\n         IF &LRECL >= &BU3 THEN GOTO ERR6\n         SET &CC = 1\n         SET &BU3 = &BU3 - &LRECL\nTSALL:   IF &CC = 1 THEN GOTO AGAIN\n         SET &CURR = 1\nCLALL:   SET KD&CURR =\n         SET BT&CURR =\n         SET RB&CURR =\n         SET RT&CURR =\n         SET RC&CURR =\n         SET &THIS = 1\nCLPAN:   SET B&CURR&THIS =\n         SET N&CURR&THIS =\n         SET R&CURR&THIS =\n         SET T&CURR&THIS =\n         SET C&CURR&THIS =\n         IF &THIS = 7 THEN GOTO CLEND\n         SET &THIS = &THIS + 1\n         GOTO CLPAN\nCLEND:   IF &CURR = 3 THEN GOTO STINI\n         SET &CURR = &CURR + 1\n         GOTO CLALL\nSTINI:   SET &CURR = 1\nSTTST:   IF &C.U&CURR.TY = 0 THEN GOTO STEND\n         IF &KEY = 0 THEN GOTO NOKEY\n         SET KD&CURR = &STR(KEY+DATA   :)\n         GOTO STCNT\nNOKEY:   SET KD&CURR = &STR(BLKSIZE    :)\nSTCNT:   SET BT&CURR = &STR(BLK/TRACK  :)\n         SET RB&CURR = &STR(REC/BLOCK  :)\n         SET RT&CURR = &STR(REC/TRACK  :)\n         SET RC&CURR = &STR(REC/CYL    :)\n         SET B&CURR.1 = &C.BU&CURR + &KEY\n         SET N&CURR.1 = &C.NU&CURR\n         SET NRB&CURR = &C.BU&CURR / &LRECL\n         SET R&CURR.1 = &C.NRB&CURR\n         SET T&CURR.1 = &C.N&CURR.1 * &C.NRB&CURR\n         SET C&CURR.1 = &C.T&CURR.1 * &C.NTC&CURR\nSTEND:   IF &CURR = 3 THEN GOTO STOTH\n         SET &CURR = &CURR + 1\n         GOTO STTST\nSTOTH:   SET &PREV = 1\n         SET &THIS = 2\n         SET &TLIM = &LRECL * 7\nTRNXT:   SET &SWTC = 0\n         GOTO TRYNX\nTRYNC:   SET &SWTC = 1\nTRYNX:   SET &CURR = 1\n         SET &SWTR = 0\nSLOOP:   IF &C.U&CURR.TY = 0 THEN GOTO STEST\n         IF &C.BU&CURR > &TLIM THEN GOTO STALT\n         IF &SWTC = 1 THEN GOTO STEST\n         SET BU&CURR = &C.BU&CURR - &LRECL\n         IF &C.BU&CURR > 0 THEN GOTO STEST\n         SET U&CURR.TY = 0\n         GOTO STEST\nSTALT:   IF &C.NU&CURR \u00ac= &C.N&CURR&PREV THEN GOTO STEST\n         SET BU&CURR = &C.BU&CURR - &LRECL\n         SET &SWTR = 1\nSTEST:   IF &CURR = 3 THEN GOTO SSETN\n         SET &CURR = &CURR + 1\n         GOTO SLOOP\nSSETN:   IF (&U1TY = 0 AND &U2TY = 0 AND &U3TY = 0) THEN GOTO IS\n         ISPEXEC VPUT (U1 U2 U3 KEY BU1 BU2 BU3)\n         ISPEXEC SELECT PGM(PAJPBLK2)\n         SET &CC = &LASTCC\n         IF &CC > 0 THEN GOTO ERR3\n         ISPEXEC VGET (NU1 NU2 NU3)\n         IF &SWTR = 1 THEN GOTO TRYNC\n         SET &CURR = 1\nSDISP:   IF &C.U&CURR.TY = 0 THEN GOTO STDIS\n         SET B&CURR&THIS = &C.BU&CURR + &KEY\n         SET N&CURR&THIS = &C.NU&CURR\n         SET NRB&CURR = &C.BU&CURR / &LRECL\n         SET R&CURR&THIS = &C.NRB&CURR\n         SET T&CURR&THIS = &C.N&CURR&THIS * &C.NRB&CURR\n         SET C&CURR&THIS = &C.T&CURR&THIS * &C.NTC&CURR\nSTDIS:   IF &CURR = 3 THEN GOTO SNEXT\n         SET &CURR = &CURR + 1\n         GOTO SDISP\nSNEXT:   IF &THIS >= 7 THEN GOTO IS\n         SET &PREV = &THIS\n         SET &THIS = &THIS + 1\n         GOTO TRNXT\nERR1:    IF &CC = 1 THEN SET &MS = &STR(0A)\n         IF &CC = 2 THEN SET &MS = &STR(0B)\n         IF &CC = 3 THEN SET &MS = &STR(0C)\n         IF &CC = 4 THEN SET &MS = &STR(0D)\n         IF &CC = 5 THEN SET &MS = &STR(0E)\n         IF &CC = 6 THEN SET &MS = &STR(0F)\n         IF &CC = 7 THEN SET &MS = &STR(0G)\n         IF &CC = 8 THEN SET &MS = &STR(0H)\n         IF &CC = 9 THEN SET &MS = &STR(0I)\n         IF &CC = 10 THEN SET &MS = &STR(0J)\n         IF &CC = 11 THEN SET &MS = &STR(0K)\n         IF &CC = 12 THEN SET &MS = &STR(0L)\n         IF &CC = 13 THEN SET &MS = &STR(0M)\n         IF &CC = 14 THEN SET &MS = &STR(0N)\n         IF &CC = 15 THEN SET &MS = &STR(0O)\n         IF &CC = 16 THEN SET &MS = &STR(0P)\n         IF &CC = 17 THEN SET &MS = &STR(0Q)\n         IF &CC = 18 THEN SET &MS = &STR(0R)\n         IF &CC = 19 THEN SET &MS = &STR(0S)\n         IF &CC = 20 THEN SET &MS = &STR(0T)\n         IF &CC = 21 THEN SET &MS = &STR(0U)\n         IF &CC = 22 THEN SET &MS = &STR(0V)\n         IF &CC = 23 THEN SET &MS = &STR(0W)\n         IF &CC = 24 THEN SET &MS = &STR(0X)\n         IF &CC = 25 THEN SET &MS = &STR(0Y)\n         IF &CC = 26 THEN SET &MS = &STR(0Z)\n         ISPEXEC DISPLAY PANEL(PAJBLK) MSG(PAJB00&MS) CURSOR(UTYPE)\n         IF &LASTCC = 8 THEN END\n         GOTO ISSET\nERR2:    ISPEXEC DISPLAY PANEL(PAJBLK) MSG(PAJB009A) CURSOR(BLOCK)\n         IF &LASTCC = 8 THEN END\n         GOTO ISSET\nERR3:    IF &CC = 1 THEN SET &MS = &STR(1A)\n         IF &CC = 2 THEN SET &MS = &STR(1B)\n         IF &CC = 3 THEN SET &MS = &STR(1C)\n         IF &CC = 4 THEN SET &MS = &STR(1D)\n         IF &CC = 5 THEN SET &MS = &STR(1E)\n         IF &CC = 6 THEN SET &MS = &STR(1F)\n         IF &CC = 7 THEN SET &MS = &STR(1G)\n         IF &CC = 8 THEN SET &MS = &STR(1H)\n         IF &CC = 9 THEN SET &MS = &STR(1I)\n         IF &CC = 10 THEN SET &MS = &STR(1J)\n         IF &CC = 11 THEN SET &MS = &STR(1K)\n         IF &CC = 12 THEN SET &MS = &STR(1L)\n         IF &CC = 13 THEN SET &MS = &STR(1M)\n         IF &CC = 14 THEN SET &MS = &STR(1N)\n         GOTO DSERR\nERR4:    SET &MS = &STR(9B)\n         GOTO DSERR\nERR5:    SET &MS = &STR(9C)\n         GOTO DSERR\nERR6:    SET &MS = &STR(9D)\nDSERR:   ISPEXEC DISPLAY PANEL(PAJBLK) MSG(PAJB00&MS) CURSOR(LRECL)\n         IF &LASTCC = 8 THEN END\n         GOTO ISSET\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCBRDS": {"ttr": 23045, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15/\\x00\\x88\\x15/\\x17\\t\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-31T00:00:00", "modifydate": "1988-05-31T17:09:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 MOFB\n         CONTROL NOMSG\n         FREE F(BRODCAST SYSOUT)\n         DELETE BRODSCAN.REPORT\n         CONTROL MSG\n         ISPEXEC VGET (MOFB)\n         ALLOC F(BRODCAST) DA('SYS1.BRODCAST') SHR\n         IF &MOFB \u00ac= YES THEN GOTO DIRL\n         ALLOC F(SYSOUT) DA(BRODSCAN.REPORT) NEW BL(1580) SPA(46,23)\n         GOTO XLST\nDIRL:    ALLOC F(SYSOUT) DA(*)\nXLST:    CALL '...TARGET.LINKLIB(BRODSCAN)'\n         CONTROL NOMSG\n         IF &MOFB \u00ac= YES THEN GOTO FRPL\n         ISPEXEC BROWSE DATASET(BRODSCAN.REPORT)\n         DELETE BRODSCAN.REPORT\nFRPL:    FREE F(BRODCAST SYSOUT)\n         FREE DA('...TARGET.LINKLIB')\n         CONTROL MSG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCBUMU": {"ttr": 23047, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x15\\x7f\\x00\\x90\\x15\\x7f\\x12\\x17\\x00&\\x00&\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-06T00:00:00", "modifydate": "1990-06-06T12:17:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         SET &ACCN =\n         SET &PSWD =\n         SET &DGRP =\n         ISPEXEC VGET (USID)\n         ISPEXEC SELECT PGM(PAJPBUMU)\n         SET &CC = &LASTCC\n         IF &CC \u00ac= 0 THEN DO\n           IF &CC = 1 THEN SET &MS = &STR(0A)\n           IF &CC = 2 THEN SET &MS = &STR(0B)\n           IF &CC = 3 THEN SET &MS = &STR(0C)\n           IF &CC = 4 THEN SET &MS = &STR(0D)\n           IF &CC = 5 THEN SET &MS = &STR(0E)\n           IF &CC = 6 THEN SET &MS = &STR(0F)\n           IF &CC = 7 THEN SET &MS = &STR(0G)\n           IF &CC = 8 THEN SET &MS = &STR(0H)\n           IF &CC = 9 THEN SET &MS = &STR(0I)\n           IF &CC = 10 THEN SET &MS = &STR(0J)\n           IF &CC = 11 THEN SET &MS = &STR(0K)\n           IF &CC = 12 THEN SET &MS = &STR(0L)\n           ISPEXEC SETMSG MSG(PAJU00&MS)\n           EXIT CODE (0)\n           END\n         ISPEXEC VGET (ACCN PSWD DGRP)\n         CONTROL NOMSG\n         FREE F(SYSPO SYSSU)\n         CONTROL MSG\n         ISPEXEC FTOPEN TEMP\n         ISPEXEC FTINCL PAJSBUMU\n         ISPEXEC FTCLOSE\n         ISPEXEC VGET ZTEMPF\n         ALLOC F(SYSPO) DA('&ZTEMPF')\n         INTRDR SYSSU\n         EUSUB\n         CONTROL NOMSG\n         FREE F(SYSPO SYSSU)\n         CONTROL MSG\n         EXIT CODE (0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCCOM": {"ttr": 23049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16O\\x00\\x90\\x16O\\x128\\x00<\\x00<\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-13T00:00:00", "modifydate": "1990-06-13T12:38:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         CONTROL MSG\n         ISPEXEC VGET (DDSN1 DVOL1 DDSN2 DVOL2 DDSN3 DVOL3 -\n                       CMOP1 CMOP2 CMOP3 CMOP4)\n         SET &CMOPT =\n         SET &CMOVL =\n         SET &CMNVL =\n         IF &CMOP1 \u00ac= YES THEN GOTO OPTA\n         SET &CMOPT = &STR(FULL )\nOPTA:    IF &CMOP2 \u00ac= YES THEN GOTO OPTB\n         SET &CMOPT = &STR(&CMOPT ASM)\nOPTB:    IF &CMOP3 \u00ac= YES THEN GOTO OPTC\n         SET &CMOPT = &STR(&CMOPT IEBCOMPR)\nOPTC:    IF &CMOP4 = THEN GOTO OVLT\n         IF &CMOP4 = PRINT THEN GOTO OVLT\n         IF &CMOP4 = SYSOUT THEN GOTO OPTE\n         IF &CMOP4 = NOPRINT THEN GOTO OPTE\n         IF &CMOP4 = BROWSE THEN GOTO OPTD\n         SET &CMOPT = &STR(&CMOPT OUTFILE(&CMOP4))\n         GOTO OVLT\nOPTD:    CONTROL NOMSG\n         FREE F(OUT)\n         DELETE COMPARE.REPORT\n         CONTROL MSG\n         ALLOC F(OUT) DA(COMPARE.REPORT) NEW BL(1210) SPA(112,56)\n         SET &CMOPT = &STR(&CMOPT OUTFILE(OUT))\n         GOTO OVLT\nOPTE:    SET &CMOPT = &STR(&CMOPT &CMOP4)\nOVLT:    IF &DVOL1 = THEN GOTO NVLT\n         SET &CMOVL = &STR(OVOL(&DVOL1))\nNVLT:    IF &DVOL2 = THEN GOTO TIAL\n         SET &CMNVL = &STR(NVOL(&DVOL2))\nTIAL:    IF &DDSN3 = THEN GOTO CXEQ\n         IF &DVOL3 = THEN GOTO IALL\n         ALLOC F(IGNORE) DA(&DDSN3) VOL(&DVOL3) SHR\n         GOTO CXEQ\nIALL:    ALLOC F(IGNORE) DA(&DDSN3) SHR\nCXEQ:    CONTROL NOMSG\n         ERROR DO\n           ERROR OFF\n           CONTROL MSG\n           WRITE  *** ERROR EXECUTING \"COMPARE\" TSO COMMAND ***\n           IF &CMOP4 = BROWSE THEN DO\n             DELETE COMPARE.REPORT\n             FREE F(OUT)\n             END\n           IF &DDSN3 \u00ac= THEN FREE F(IGNORE)\n           EXIT CODE(8)\n           END\n         COMPARE &DDSN1 &DDSN2 &CMOVL &CMNVL &CMOPT\n         SET &COMCC = &LASTCC\n         ERROR OFF\n         IF &CMOP4 = BROWSE THEN DO\n           IF &COMCC = 0 THEN ISPEXEC BROWSE DATASET(COMPARE.REPORT)\n           DELETE COMPARE.REPORT\n           FREE F(OUT)\n           END\n         IF &DDSN3 \u00ac= THEN FREE F(IGNORE)\n         CONTROL MSG\n         EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJCDAY": {"ttr": 23051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x895o\\x00\\x895o\\x11\\x00\\x00\\xba\\x00\\xba\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-22T00:00:00", "modifydate": "1989-12-22T11:00:00", "lines": 186, "newlines": 186, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n/*  WEEKDAY COMPUTATION :                             MOINIL P.A.   */\n/*       DATES ARE ACCEPTED FROM 1582 (GREGORIAN CALENDAR) UNTIL    */\n/*       4315 INCLUDED (BECAUSE 4316 WILL BE THE YEAR IT WILL       */\n/*       HAVE GAINED ONE DAY ON THE SUN.                            */\n         CONTROL MAIN MSG\n         SET &DI =\n         SET &MI =\n         SET &YI =\n         SET &SDI =\n         SET &TSFX =\n         SET &SWOP = 0\n         SET &TOLD =\n         SET &DOLD =\n         SET &MOLD =\n         SET &YOLD =\n         SET &SDOLD =\n         SET &NORM = &STR(032060091121152182213244274305335366)\n         SET &LEAP = &STR(032061092122153183214245275306336367)\nDSPNL:   ISPEXEC DISPLAY PANEL(PAJDAY) CURSOR(DI)\nSETCC:   SET &CC = &LASTCC\n         IF &CC = 8 THEN DO\n           IF &SWOP = 0 THEN GOTO NOCL\n           SET &SWOP = 0\n           ISPEXEC TBEND TWKD&TOLD\n           ISPEXEC TBEND TMTH&TOLD\nNOCL:      EXIT\n           END\n         SET &SWTS = 0\n         IF &SWOP = 0 THEN GOTO OPW\n         IF &STR(&TSFX) = &STR(&TOLD) THEN GOTO CMPTE\n         SET &SWOP = 0\n         ISPEXEC TBEND TWKD&TOLD\n         ISPEXEC TBEND TMTH&TOLD\n         SET &SWTS = 1\nOPW:     ISPEXEC TBOPEN TWKD&TSFX NOWRITE\n         SET &CC = &LASTCC\n         IF &CC = 0 THEN GOTO OPM\n         IF &CC = 8 THEN -\n           ISPEXEC DISPLAY PANEL(PAJDAY) MSG(PAJD000E) CURSOR(TSFX)\n         ELSE -\n           ISPEXEC DISPLAY PANEL(PAJDAY) MSG(PAJD000F) CURSOR(TSFX)\n         GOTO SETCC\nOPM:     ISPEXEC TBOPEN TMTH&TSFX NOWRITE\n         SET &CC = &LASTCC\n         IF &CC = 0 THEN GOTO OPOK\n         ISPEXEC TBEND TWKD&TSFX\n         IF &CC = 8 THEN -\n           ISPEXEC DISPLAY PANEL(PAJDAY) MSG(PAJD000G) CURSOR(TSFX)\n         ELSE -\n           ISPEXEC DISPLAY PANEL(PAJDAY) MSG(PAJD000H) CURSOR(TSFX)\n         GOTO SETCC\nOPOK:    SET &SWOP = 1\n         SET &TOLD = &STR(&TSFX)\nCMPTE:   SET &DNME =\n         SET &DO =\n         SET &MNME =\n         IF &DI = AND &MI = AND &YI = AND &SDI = THEN GOTO USEDT\n         IF &DI = &DOLD AND &MI = &MOLD AND &YI = &YOLD AND -\n           &SDI = &SDOLD THEN GOTO CKTS\n/*                                           ON WITH PREVIOUS DATES */\n         IF &SDI = &SDOLD THEN GOTO CKYEAR\n         IF &DATATYPE(&SDI) = CHAR THEN GOTO ERSER1\n         IF &YI = THEN DO\n           ISPEXEC VGET (ZYEAR)\n           SET &YI = &STR(19&ZYEAR)\n           END\n         SET &IRE = &YI // 4                /* IF = ZERO, LEAP YEAR */\n         IF &IRE = 0 THEN DO\n           SET &CRE = &YI // 100\n           IF &CRE = 0 THEN DO\n             SET &IRE = (&YI/100) // 4\n             END\n           END\n         IF &IRE = 0 THEN SET &UP = 366\n         ELSE SET &UP = 365\n         IF (&SDI < 1 OR &SDI > &UP) THEN GOTO ERSER2\n         SET &MI = 0                                  /* INITIALIZE */\nLOOPMI:  SET &LOW = (&MI * 3) + 1\n         SET &HIGH = &LOW + 2\n         SET &MI = &MI + 1\n         IF &IRE = 0 THEN SET &DDW = &SUBSTR(&LOW:&HIGH,&LEAP)\n         ELSE SET &DDW = &SUBSTR(&LOW:&HIGH,&NORM)\n         IF &LOW = 1 THEN SET &SUB = 1\n         ELSE DO\n           SET &LOW = &LOW - 3\n           SET &HIGH = &LOW + 2\n           IF &IRE = 0 THEN SET &SUB = &SUBSTR(&LOW:&HIGH,&LEAP)\n           ELSE SET &SUB = &SUBSTR(&LOW:&HIGH,&NORM)\n           END\n         IF &SDI < &DDW THEN GOTO OKMONN\n         GOTO LOOPMI                         /* SHOULD NOT OVERFLOW */\nOKMONN:  SET &DI = &SDI - &SUB + 1\n         GOTO PROCESS\nERSER1:  ISPEXEC DISPLAY PANEL (PAJDAY) MSG(PAJD000D) CURSOR(SDI)\n         GOTO SETCC\nERSER2:  ISPEXEC DISPLAY PANEL(PAJDAY) MSG(PAJD000C) CURSOR(SDI)\n         GOTO SETCC\nUSEDT:   ISPEXEC VGET (ZDAY ZMONTH ZYEAR ZJDATE)\n         SET &DI = &ZDAY\n         SET &MI = &ZMONTH\n         SET &YI = &STR(19&ZYEAR)\n         SET &SDI = &SUBSTR(4:6,&ZJDATE)\n         GOTO PROCESS             /* WE HOPE SYSTEM DATE IS CORRECT */\nCKTS:    IF &SWTS = 1 THEN GOTO CHANGED\nCKYEAR:  IF &DATATYPE(&YI) = CHAR THEN GOTO ERYEAR\n         IF &YI < 1582 THEN GOTO ERYEAR\n         IF &YI > 4315 THEN GOTO ERYEAR\n         IF &DATATYPE(&MI) = CHAR THEN GOTO ERMON\n         IF (&MI > 0 AND &MI <= 12) THEN GOTO CKDAY\nERMON:   ISPEXEC DISPLAY PANEL(PAJDAY) MSG(PAJD000B) CURSOR(MI)\n         GOTO SETCC\nERYEAR:  ISPEXEC DISPLAY PANEL(PAJDAY) MSG(PAJD000A) CURSOR(YI)\n         GOTO SETCC\nCKDAY:   IF &DATATYPE(&DI) = CHAR THEN GOTO ERDAY\n         SET &IRE = &YI // 4                /* IF = ZERO, LEAP YEAR */\n         IF &IRE = 0 THEN DO\n           SET &CRE = &YI // 100\n           IF &CRE = 0 THEN DO\n             SET &IRE = (&YI/100) // 4\n             END\n           END\n         SET &HIGH = &EVAL(&MI*2)\n         SET &LOW = &EVAL(&HIGH-1)\n         IF &IRE = 0 THEN -\n           SET &UP = &SUBSTR(&LOW:&HIGH,312931303130313130313031)\n         ELSE SET &UP = &SUBSTR(&LOW:&HIGH,312831303130313130313031)\n         IF (&DI > 0 AND &DI <= &UP) THEN GOTO SETJUL\nERDAY:   ISPEXEC DISPLAY PANEL(PAJDAY) MSG(PAJD000C) CURSOR(DI)\n         GOTO SETCC\nSETJUL:  IF &MI = 1 THEN GOTO INITY\n         SET &LOW = ((&MI - 2) * 3) + 1\n         SET &HIGH = &LOW + 2\n         SET &IRE = &YI // 4\n         IF &IRE = 0 THEN DO\n           SET &CRE = &YI // 100\n           IF &CRE = 0 THEN DO\n             SET &IRE = (&YI/100) // 4\n             END\n           END\n         IF &IRE = 0 THEN SET &DDW = &SUBSTR(&LOW:&HIGH,&LEAP)\n         ELSE SET &DDW = &SUBSTR(&LOW:&HIGH,&NORM)\n         SET &SDI = &DDW + &DI - 1\n         GOTO PROCESS\nINITY:   SET &SDI = &DI\n/*                   AT THIS POINT WE HAVE A CORRECT DATE AVAILABLE */\nPROCESS: IF &DI \u00ac= &DOLD OR &MI \u00ac= &MOLD OR &YI \u00ac= &YOLD -\n           THEN GOTO CHANGED\n         IF &DI < &UP THEN GOTO INCRDAY\n         SET &DI = 1                                  /* NEXT MONTH */\n         IF &MI < 12 THEN GOTO INCRMON\n         SET &MI = 1                                   /* NEXT YEAR */\n         SET &UP = 31                                    /* JANUARY */\n         SET &YI = &YI + 1\n         SET &SDI= 1\n         GOTO CHANGED\nINCRDAY: SET &DI = &DI + 1\n         SET &SDI = &SDI + 1\n         GOTO CHANGED\nINCRMON: SET &MI = &MI + 1\n         SET &LOW = ((&MI - 2) * 3) + 1\n         SET &HIGH = &LOW + 2\n         IF &IRE = 0 THEN SET &SDI = &SUBSTR(&LOW:&HIGH,&LEAP)\n         ELSE SET &SDI = &SUBSTR(&LOW:&HIGH,&NORM)\n         SET &HIGH = &EVAL(&MI*2)\n         SET &LOW = &EVAL(&HIGH-1)\n         IF &IRE = 0 THEN -\n           SET &UP = &SUBSTR(&LOW:&HIGH,312931303130313130313031)\n         ELSE SET &UP = &SUBSTR(&LOW:&HIGH,312831303130313130313031)\nCHANGED: SET &DDX = (&YI-1)/100\n         SET &DDC = &DDX - (&DDX/4)\n         SET &DDX = (&YI - 1) / 4\n         SET &DDW = &YI + &DDX + &SDI - &DDC\n         SET &N7 = &DDW // 7            /* REMAINDER FOR SUNDAY = 1 */\n         IF &N7 = 0 THEN SET &N7 = 7 /* CHANGE SATURDAY FROM 0 TO 7 */\n         ISPEXEC TBGET TWKD&TSFX\n         SET &DNME = &STR(&DAYNAME)\n         SET &N12 = &MI\n         ISPEXEC TBGET TMTH&TSFX\n         SET &MNME = &STR(&MONNAME)\n         SET &DO = &STR(&DI &MNME &YI)\n         SET &DOLD = &DI\n         SET &MOLD = &MI\n         SET &YOLD = &YI\n         SET &SDOLD = &SDI\n         GOTO DSPNL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCDAY1": {"ttr": 23055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x19\\x1f\\x00\\x85\\x19\\x1f\\x16 \\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-10T00:00:00", "modifydate": "1985-07-10T16:20:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         ISPEXEC VGET (TSFX)\n         ISPEXEC TBOPEN TWKD&TSFX NOWRITE\n         SET &CC = &LASTCC\n         IF &CC = 0 THEN GOTO DISPL\n         IF &CC = 8 THEN DO\n             ISPEXEC DISPLAY MSG(PAJD000E)\n             EXIT\n             END\n         ISPEXEC DISPLAY MSG(PAJD000F)\n         EXIT\n         END\nDISPL:   ISPEXEC TBDISPL TWKD&TSFX PANEL(PAJDAYS1)\n         ISPEXEC TBEND TWKD&TSFX\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCDAY2": {"ttr": 23057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x19\\x1f\\x00\\x85\\x19\\x1f\\x16 \\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-10T00:00:00", "modifydate": "1985-07-10T16:20:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         ISPEXEC VGET (TSFX)\n         ISPEXEC TBOPEN TWKD&TSFX WRITE\n         SET &CC = &LASTCC\n         IF &CC >= 8 THEN DO\n             ISPEXEC TBCREATE TWKD&TSFX KEYS(N7) NAMES(DAYNAME) -\n                 WRITE REPLACE\n             END\n         SET N7 =\n         SET DAYNAME =\nDAYLOOP: ISPEXEC DISPLAY PANEL(PAJDAYS2)\n         SET &CC = &LASTCC\n         IF &CC >= 8 THEN  DO\n             ISPEXEC TBCLOSE TWKD&TSFX REPLCOPY\n             EXIT\n             END\n         IF &DATATYPE(&N7) = CHAR THEN DO\n             ISPEXEC DISPLAY MSG(PAJD001A)\n             SET N7 =\n             GOTO DAYLOOP\n             END\n         IF &N7 > 7 OR &N7 < 0 THEN DO\n             ISPEXEC DISPLAY MSG(PAJD001B)\n             SET N7 =\n             GOTO DAYLOOP\n             END\n         ISPEXEC TBMOD  TWKD&TSFX\n         SET N7 =\n         SET DAYNAME =\n         GOTO DAYLOOP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCDAY3": {"ttr": 23297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x19\\x1f\\x00\\x85\\x19\\x1f\\x16 \\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-10T00:00:00", "modifydate": "1985-07-10T16:20:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         ISPEXEC VGET (TSFX)\n         ISPEXEC TBOPEN TMTH&TSFX NOWRITE\n         SET &CC = &LASTCC\n         IF &CC = 0 THEN GOTO DISPL\n         IF &CC = 8 THEN DO\n             ISPEXEC DISPLAY MSG(PAJD000G)\n             EXIT\n             END\n         ISPEXEC DISPLAY MSG(PAJD000H)\n         EXIT\n         END\nDISPL:   ISPEXEC TBDISPL TMTH&TSFX PANEL(PAJDAYS3)\n         ISPEXEC TBEND TMTH&TSFX\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCDAY4": {"ttr": 23299, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x19\\x1f\\x00\\x85\\x19\\x1f\\x16 \\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-10T00:00:00", "modifydate": "1985-07-10T16:20:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         ISPEXEC VGET (TSFX)\n         ISPEXEC TBOPEN TMTH&TSFX WRITE\n         SET &CC = &LASTCC\n         IF &CC >= 8 THEN DO\n             ISPEXEC TBCREATE TMTH&TSFX KEYS(N12) NAMES(MONNAME) -\n                 WRITE REPLACE\n             END\n         SET N12 =\n         SET MONNAME =\nDAYLOOP: ISPEXEC DISPLAY PANEL(PAJDAYS4)\n         SET &CC = &LASTCC\n         IF &CC >= 8 THEN DO\n             ISPEXEC TBCLOSE TMTH&TSFX REPLCOPY\n             EXIT\n             END\n         IF &DATATYPE(&N12) = CHAR THEN DO\n             ISPEXEC DISPLAY MSG(PAJD001C)\n             SET N12 =\n             GOTO DAYLOOP\n             END\n         IF &N12 > 12 OR &N12 < 0 THEN DO\n             ISPEXEC DISPLAY MSG(PAJD001D)\n             SET N12 =\n             GOTO DAYLOOP\n             END\n         ISPEXEC TBMOD TMTH&TSFX\n         SET N12 =\n         SET MONNAME =\n         GOTO DAYLOOP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCDSC": {"ttr": 23301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x88)?\\x00\\x88)?\\x15C\\x00'\\x00'\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-10-19T00:00:00", "modifydate": "1988-10-19T15:43:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 DDSN DVOL LPARM OPARM\n         CONTROL MSG\n         ISPEXEC VGET (PRJO LIBO TYPO DDSN DVOL LPARM OPARM)\n         IF &OPARM = THEN GOTO DSLL\n         IF &DDSN = THEN GOTO ANDS\n         IF &DVOL = THEN GOTO TTDS\n         CDSCB &DDSN VOL(&DVOL) &OPARM\n         GOTO DSTL\nTTDS:    CDSCB &DDSN &OPARM\n         GOTO DSTL\nANDS:    IF &PRJO = &SYSUID THEN GOTO OWDS\n         IF &DVOL = THEN GOTO VLDS\n         CDSCB '&PRJO..&LIBO..&TYPO' VOL(&DVOL) &OPARM\n         GOTO DSTL\nVLDS:    CDSCB '&PRJO..&LIBO..&TYPO' &OPARM\n         GOTO DSTL\nOWDS:    IF &DVOL = THEN GOTO NVDS\n         CDSCB &LIBO..&TYPO VOL(&DVOL) &OPARM\n         GOTO DSTL\nNVDS:    CDSCB &LIBO..&TYPO &OPARM\n         GOTO DSTL\nDSLL:    IF &LPARM \u00ac= NO THEN GOTO DSSL\n         SET &LBL = &STR( )\n         GOTO DSXL\nDSTL:    IF &LPARM = NO THEN GOTO DSEX\nDSSL:    SET &LBL = &STR(LABEL)\nDSXL:    IF &DDSN = THEN GOTO ANDL\n         IF &DVOL \u00ac= THEN GOTO DSAL\n         LISTDS &DDSN &LBL\n         GOTO DSEX\nDSAL:    ALLOC DSN(&DDSN) VOL(&DVOL) SHR\n         LISTDS &DDSN &LBL\n         FREE DSN(&DDSN)\n         GOTO DSEX\nANDL:    IF &PRJO = &SYSUID THEN GOTO OWDL\n         LISTDS '&PRJO..&LIBO..&TYPO' &LBL\n         GOTO DSEX\nOWDL:    LISTDS &LIBO..&TYPO &LBL\nDSEX:    CONTROL MSG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCDSP": {"ttr": 23303, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07?\\x00\\x95\\x07?\\x11\\x18\\x00\\xb6\\x00\\xb6\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-14T00:00:00", "modifydate": "1995-03-14T11:18:00", "lines": 182, "newlines": 182, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 DDSN DVOL PCLASS PCOPIES PFOLD PHOLD PDEST PTEST()\n         CONTROL MAIN NOMSG\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN EXIT\n/*-------------------------------------------------------------------*/\n/* PRE-REQUISITE : \"PRINTO\" TSO COMMAND (AVAILABLE IN CBT FILES      */\n/*                 433 AND 437).                                 (PM)*/\n/*-------------------------------------------------------------------*/\n         ISPEXEC VGET (PRJO LIBO TYPO DDSN DVOL MBRO +\n                       PCLASS PCOPIES PHEAD PFOLD PHOLD PDEST)\n         IF &PTEST EQ YES THEN CONTROL LIST SYMLIST CONLIST MSG\n         ELSE CONTROL MSG\n         SET &TBPDEL =\n         SET &PVSN =\n         SET &PDST =\n         IF &DVOL NE THEN SET &PVSN = &STR(VOLUME(&DVOL))\n         IF &PHEAD EQ YES THEN SET PHDN = &STR(HEADING)\n         ELSE SET PHDN = &STR(NOHEADING)\n         IF &PDEST NE THEN SET &PDST = &STR(DEST(&PDEST))\n         IF &DDSN NE THEN DO\n           IF &SUBSTR(1:1,&DDSN) NE &STR(') THEN DO\n             SET &PDSN = &STR(&DDSN)\n             END\n           ELSE DO\n             SET &LDSN = &LENGTH(&STR(&DDSN)) - 1\n             SET &PDSN = &SUBSTR(2:&LDSN,&DDSN)\n             END\n           SET &LDSN = &LENGTH(&STR(&PDSN))\n           IF &SUBSTR(&LDSN:&LDSN,&PDSN) EQ ) THEN GOTO PRT1\n           GOTO MBR1\n           END\n         SET &PDSN = &STR(&PRJO..&LIBO..&TYPO)\nMBR1:    IF &STR(&MBRO) EQ THEN GOTO STB1\n         IF &STR(&MBRO) EQ &STR(*) THEN GOTO PRT1\n         SET &PDSN = &STR(&PDSN.(&MBRO))\nPRT1:    PRINTO '&PDSN' &PVSN CLASS(&PCLASS) +\n                COPIES(&PCOPIES) &PHDN &PFOLD &PHOLD &PDST\n         GOTO XTF1\nSTB1:    ISPEXEC CONTROL ERRORS CANCEL\n         ISPEXEC LMINIT DATAID(DSID) DATASET('&PDSN') +\n                 &PVSN ORG(DSOR)\n         IF &DSOR NE PO THEN DO\n           ISPEXEC LMFREE DATAID(&DSID)\n           IF &LASTCC EQ 0 THEN GOTO PRT1\n           WRITE -- INPUT DATA-SET FREE FAILED\n           WRITE -- ERROR : &ZERRLM\n           GOTO PRT1\n           END\n         IF &LASTCC NE 0 THEN DO\n           WRITE -- INPUT DATA-SET ALLOCATION FAILED\n           WRITE -- ERROR : &ZERRLM\n           GOTO XTF1\n           END\n         ISPEXEC LMOPEN DATAID(&DSID)\n         IF &LASTCC NE 0 THEN DO\n           WRITE -- INPUT DATA-SET OPEN FAILED\n           WRITE -- ERROR : &ZERRLM\n           GOTO XTF1\n           END\n         ISPEXEC TBCREATE MEMTABLE REPLACE NOWRITE +\n                 KEYS(MEMBER) NAMES(STATS)\n         SET &LMLRC = 0\n         DO WHILE &LMLRC = 0\n           ISPEXEC LMMLIST DATAID(&DSID) MEMBER(MEMBER) +\n                   OPTION(LIST) STATS(YES)\n           SET &LMLRC = &LASTCC\n           IF &LMLRC EQ 0 THEN DO\n             SET &STATS = &STR(&ZLVERS..&ZLMOD  &ZLCDATE +\n                               &ZLMDATE &ZLMTIME &ZLCNORC +\n                               &ZLINORC &ZLMNORC &ZLUSER)\n             ISPEXEC TBADD MEMTABLE\n             END\n           ELSE IF &LMLRC NE 8 THEN DO\n             WRITE -- TABLE CREATION FAILED. RC=&LMLRC\n             WRITE -- ERROR : &ZERRLM\n             END\n           END\n         ISPEXEC LMMLIST DATAID(&DSID) OPTION(FREE)\n         ISPEXEC LMCLOSE DATAID(&DSID)\n         IF &LASTCC NE 0 THEN DO\n           WRITE -- INPUT DATA-SET CLOSE FAILED\n           WRITE -- ERROR : &ZERRLM\n           END\n         ISPEXEC LMFREE DATAID(&DSID)\n         IF &LASTCC NE 0 THEN DO\n           WRITE -- INPUT DATA-SET FREE FAILED\n           WRITE -- ERROR : &ZERRLM\n           END\n         IF &LMLRC NE 8 THEN GOTO XTB1\n         ISPEXEC TBTOP MEMTABLE\n         IF &PTEST EQ ONLY THEN CONTROL LIST SYMLIST CONLIST MSG\nLTB1:    ISPEXEC TBDISPL MEMTABLE PANEL(PAJDSPL) POSITION(ROW)\nLTB2:    SET &TBDRC = &LASTCC\n         IF &TBCMD EQ THEN GOTO PTB1\n         IF &TBCMD NE D THEN GOTO LTB3\n         CONTROL NOMSG\n         ERROR DO\n           ERROR OFF\n           FREE ATTR(VBA)\n           ATTR VBA RECFM(V B A) LRECL(137) BLKSIZE(6356) DSORG(PS)\n           ALLOC F(ISPFILE) DSN(DIRTEMP.LISTING) REUSE CATALOG +\n             USING(VBA) SP(2 2) TRACKS\n           SET &TBPDEL = DELETE\n           END\n         ALLOC F(ISPFILE) DSN(DIRTEMP.LISTING) OLD REUSE\n         ERROR OFF\n         CONTROL MSG\n         ISPEXEC FTOPEN\n         ISPEXEC FTINCL PAJSDSP\n         ISPEXEC FTCLOSE\n         PRINTO DIRTEMP.LISTING CLASS(&PCLASS) +\n                COPIES(&PCOPIES) &PHDN &PFOLD &PHOLD &PDST\n         SET &TBCMD =\n         SET &TBMNM =\n         GOTO LTB1\nLTB3:    IF &TBMNM EQ THEN GOTO CML5\n         SET &SFL = 1\n         SET &LFL = &LENGTH(&STR(&TBMNM))\nCML1:    IF &SUBSTR(&SFL:&SFL,&TBMNM) NE &STR( ) THEN GOTO CML2\n         IF &SFL EQ &LFL THEN GOTO CML5\n         SET &SFL = &SFL + 1\n         GOTO CML1\nCML2:    SET &EFL = &SFL\nCML3:    IF &EFL EQ &LFL THEN GOTO CML4\n         SET &EFL = &EFL + 1\n         IF &SUBSTR(&EFL:&EFL,&TBMNM) NE &STR( ) THEN GOTO CML3\n         SET &EFL = &EFL - 1\nCML4:    SET &STMEM = &SUBSTR(&SFL:&EFL,&TBMNM)\n         SET &LFL = &LENGTH(&STR(&STMEM))\n         IF &LFL GT 8 THEN DO\n           ISPEXEC TBDISPL MEMTABLE MSG(PAJX000D) POSITION(ROW)\n           GOTO LTB2\n           END\n         SET &MEMBER = &STMEM\n         SET &TBCMD =\n         SET &TBMNM =\n         ISPEXEC TBTOP MEMTABLE\n         ISPEXEC TBSCAN MEMTABLE ARGLIST(MEMBER) NOREAD +\n                 POSITION(ROW) CONDLIST(GE)\n         IF &LASTCC EQ 8 THEN -\n           ISPEXEC TBBOTTOM MEMTABLE NOREAD POSITION(ROW)\n         ELSE IF &ROW NE 0 THEN -\n           ISPEXEC TBSKIP MEMTABLE NUMBER(-1) NOREAD POSITION(ROW)\n         GOTO LTB1\nCML5:    ISPEXEC TBDISPL MEMTABLE MSG(PAJX000C) POSITION(ROW)\n         GOTO LTB2\nPTB1:    SET &DONE = NONE\n         DO WHILE &DONE = NONE\n           IF &TBDRC GT 4 THEN SET &DONE = ERROR\n           ELSE IF &TBCMD NE THEN SET &DONE = LOCATE\n           ELSE IF &S EQ S THEN DO\n             SET &TBDRC = 0\n             SET &DONE = PRINT\n             END\n           ELSE IF &S EQ B THEN DO\n             SET &TBDRC = 0\n             SET &DONE = BROWSE\n             END\n           ELSE IF &S EQ &STR( ) THEN DO\n             ISPEXEC TBDISPL MEMTABLE POSITION(ROW)\n             SET &TBDRC = &LASTCC\n             END\n           ELSE DO\n             ISPEXEC TBDISPL MEMTABLE MSG(PAJX000B) POSITION(ROW) +\n                     CSRROW(&ROW)\n             SET &TBDRC = &LASTCC\n             END\n           END\n         IF &TBDRC EQ 0 THEN DO\n           IF &DONE EQ LOCATE THEN GOTO LTB3\n           SET &MBRO = &MEMBER\n           SET &XDSN = &STR(&PDSN.(&MBRO))\n           IF &DONE EQ BROWSE THEN -\n             ISPEXEC BROWSE DATASET('&XDSN') &PVSN\n           ELSE PRINTO '&XDSN' &PVSN CLASS(&PCLASS) +\n                       COPIES(&PCOPIES) &PHDN &PFOLD &PHOLD &PDST\n           GOTO LTB1\n           END\n         IF &TBDRC NE 8 THEN DO\n           WRITE -- EXIT CODE : &DONE = &TBDRC\n           END\nXTB1:    ISPEXEC TBEND MEMTABLE\nXTF1:    IF &TBPDEL EQ DELETE THEN FREE F(ISPFILE) ATTR(VBA) &TBPDEL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJCDSS": {"ttr": 23307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07?\\x00\\x95\\x07?\\x11\\x18\\x00%\\x00%\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-14T00:00:00", "modifydate": "1995-03-14T11:18:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 DDSN DVOL DPARM REPORT\n/*-------------------------------------------------------------------*/\n/* PRE-REQUISITE : \"PRINTO\" TSO COMMAND (AVAILABLE IN CBT FILES      */\n/*                 433 AND 437).                                 (PM)*/\n/*-------------------------------------------------------------------*/\n         CONTROL NOMSG\n         FREE F(IN OUT)\n         DELETE STATDS.REPORT\n         CONTROL MSG\n         ISPEXEC VGET (PRJO LIBO TYPO DDSN DVOL DPARM REPORT)\n         IF &REPORT = T THEN ALLOC F(OUT) DA(*)\n         IF &REPORT \u00ac= T THEN ALLOC F(OUT) DA(STATDS.REPORT) -\n                                    NEW BL(1200) SPA(112,56)\n         IF &DDSN = THEN GOTO TTDS\n         IF &DVOL = THEN ALLOC F(IN) DA(&DDSN) SHR\n                    ELSE ALLOC F(IN) DA(&DDSN) VOL(&DVOL) SHR\n         GOTO STAT\nTTDS:    IF &PRJO = &SYSUID THEN GOTO OWDS\n         IF &DVOL = THEN ALLOC F(IN) DA('&PRJO..&LIBO..&TYPO') SHR\n                    ELSE ALLOC F(IN) DA('&PRJO..&LIBO..&TYPO') -\n                                     VOL(&DVOL) SHR\n         GOTO STAT\nOWDS:    IF &DVOL = THEN ALLOC F(IN) DA(&LIBO..&TYPO) SHR\n                    ELSE ALLOC F(IN) DA(&LIBO..&TYPO) VOL(&DVOL) SHR\nSTAT:    STATS &DPARM\n         CONTROL NOMSG\n         IF &REPORT = T THEN GOTO FRFL\n         IF &REPORT \u00ac= B THEN GOTO SEEN\n         ISPEXEC BROWSE DATASET(STATDS.REPORT)\n         GOTO DLDS\nSEEN:    IF &REPORT = L THEN GOTO OULS\n         WRITE DATA-SET NAME = &SYSUID..STATDS.REPORT\n         GOTO FRFL\nOULS:    PRINTO STATDS.REPORT NOHEADING\nDLDS:    DELETE STATDS.REPORT\nFRFL:    FREE F(IN OUT)\n         CONTROL MSG\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJCEQD1": {"ttr": 23309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x13?\\x00\\x85\\x13?\\x14\\x10\\x00\\x05\\x00\\x05\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-05-13T00:00:00", "modifydate": "1985-05-13T14:10:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         CONTROL MSG\n         ISPEXEC VGET (JUNME JUNO JU)\n         LISTENQ &JUNME &JU\n         CONTROL MSG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCEQD2": {"ttr": 23311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x13?\\x00\\x85\\x13?\\x13W\\x00\\x05\\x00\\x05\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-05-13T00:00:00", "modifydate": "1985-05-13T13:57:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         CONTROL MSG\n         ISPEXEC VGET (JUNME JUNO JU)\n         WAITR &JUNME &JU\n         CONTROL MSG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCEQD3": {"ttr": 23313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x13?\\x00\\x85\\x13?\\x14\\x10\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-05-13T00:00:00", "modifydate": "1985-05-13T14:10:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 TDSN\n         ISPEXEC CONTROL DISPLAY LINE\n         SCRSZ\n         SET &TTYPE = &LASTCC\n         TERMINAL SCRSIZE(24,80)\n         CONTROL MSG\n         ISPEXEC VGET (TDSN)\n         TSODSN &TDSN\n         CONTROL MSG\n         IF &TTYPE = 1 THEN TERMINAL SCRSIZE(24,80)\n         IF &TTYPE = 2 THEN TERMINAL SCRSIZE(27,132)\n         IF &TTYPE = 3 THEN TERMINAL SCRSIZE(32,80)\n         IF &TTYPE = 4 THEN TERMINAL SCRSIZE(43,80)\n         ISPEXEC CONTROL DISPLAY REFRESH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCEQD4": {"ttr": 23315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x13?\\x00\\x85\\x13?\\x14\\t\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-05-13T00:00:00", "modifydate": "1985-05-13T14:09:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         ISPEXEC CONTROL DISPLAY LINE\n         SCRSZ\n         SET &TTYPE = &LASTCC\n         TERMINAL SCRSIZE(24,80)\n         CONTROL MSG\n         TSOENQ\n         CONTROL MSG\n         IF &TTYPE = 1 THEN TERMINAL SCRSIZE(24,80)\n         IF &TTYPE = 2 THEN TERMINAL SCRSIZE(27,132)\n         IF &TTYPE = 3 THEN TERMINAL SCRSIZE(32,80)\n         IF &TTYPE = 4 THEN TERMINAL SCRSIZE(43,80)\n         ISPEXEC CONTROL DISPLAY REFRESH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCEQD5": {"ttr": 23317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x13?\\x00\\x85\\x13?\\x14\\x10\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-05-13T00:00:00", "modifydate": "1985-05-13T14:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         ISPEXEC CONTROL DISPLAY LINE\n         SCRSZ\n         SET &TTYPE = &LASTCC\n         TERMINAL SCRSIZE(24,80)\n         CONTROL MSG\n         RSVENQ\n         CONTROL MSG\n         IF &TTYPE = 1 THEN TERMINAL SCRSIZE(24,80)\n         IF &TTYPE = 2 THEN TERMINAL SCRSIZE(27,132)\n         IF &TTYPE = 3 THEN TERMINAL SCRSIZE(32,80)\n         IF &TTYPE = 4 THEN TERMINAL SCRSIZE(43,80)\n         ISPEXEC CONTROL DISPLAY REFRESH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCGDG": {"ttr": 23319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91(\\x9f\\x00\\x91(\\x9f\\x14C\\x00\\xef\\x00\\xef\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-16T00:00:00", "modifydate": "1991-10-16T14:43:00", "lines": 239, "newlines": 239, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN EXIT\n         CONTROL NOPROMPT NOFLUSH\n         ATTN OFF\n         ERROR OFF\n/* - - - GDG UTILITY REQUEST(S) - - - - - - - - - - - - - - - - - - */\nDISPLAY: ISPEXEC DISPLAY PANEL(PAJGDG)\n         IF &LASTCC NE 0 THEN GOTO ALLDONE\n         ISPEXEC CONTROL DISPLAY SAVE\n         ISPEXEC VGET (GDGPREF G GDGPJ GDGGR GDGTY K GNM)\n         ISPEXEC VGET (OSC OEM ZCHARCNL)\n         CONTROL NOLIST NOMSG NOPROMPT\n         SET &GDGPRT = &STR(&GDGPJ..&GDGGR..&GDGTY)\n         IF &K NE &STR(M) THEN DELETE '&GDGPRT'\n         SET &GDGNAME = &GDGPREF\n         IF &SUBSTR(1:1,&STR(&GDGPREF) ) EQ &STR(') THEN DO\n           SET &GDGLENG = &EVAL(&LENGTH(&STR(&GDGPREF))-1)\n           SET &GDGNAME = &SUBSTR(2:&GDGLENG,&GDGPREF )\n           END\n         ELSE SET &GDGNAME = &SYSPREF..&GDGPREF\n         SET &GDGPREF = &STR('&GDGNAME')\n         FREE ATTR($L$C$P $G$R$I)\n         ATTR $L$C$P LRECL(133) BLKSIZE(9076) RECFM(V B A)\n         ALLOC F(GDGOUT) DA('&GDGPRT') +\n           REUSE US($L$C$P) MOD CAT SPACE(2,1) TRACK\n/* - - - I AND L PROCESSES  - - - - - - - - - - - - - - - - - - - - */\n         IF (&G = I OR &G = L) THEN DO\n           IF &G = I THEN SET &ALL = &STR(GDG ALL)\n           ELSE SET &ALL = &STR(ALL)\n           LISTC ENT(&GDGPREF) &ALL OUTFILE(GDGOUT)\n           SET &CCND = &LASTCC\n           IF &CCND > 0 THEN ISPEXEC SETMSG MSG(PAJG000A)\n           ELSE DO\n             SET HCHARCNL = &ZCHARCNL\n             SET ZCHARCNL = NOCC\n             ISPEXEC VPUT (ZCHARCNL)\n             ISPEXEC BROWSE DATASET('&GDGPRT')\n             SET ZCHARCNL = &HCHARCNL\n             ISPEXEC VPUT (ZCHARCNL)\n             ISPEXEC SETMSG MSG(PAJG000B)\n             END\n           END\n/* - - - C PROCESS  - - - - - - - - - - - - - - - - - - - - - - - - */\n         ELSE IF &G = C THEN DO\n           SET &GDGENTS = &STR(&GNM)\n           SET &ACTION  = &STR(CREATED)\n           IF &OSC EQ NO THEN SET &SCROPT = &STR(NOSCRATCH)\n           ELSE SET &SCROPT = &STR(SCRATCH)\n           IF &OEM EQ YES THEN SET &EMPOPT = &STR(EMPTY)\n           ELSE SET &EMPOPT = &STR(NOEMPTY)\n           CONTROL MSG\n           DEFINE GDG(NAME(&GDGPREF) LIMIT(&GNM) &SCROPT +\n             &EMPOPT OWNER(&SYSUID))\n           SET &CCND = &LASTCC\n           CONTROL NOMSG\n           IF &CCND > 0 THEN ISPEXEC SETMSG MSG(PAJG000C)\n           ELSE DO\n             LISTC ENT(&GDGPREF) GDG ALL OUTFILE(GDGOUT)\n             SET HCHARCNL = &ZCHARCNL\n             SET ZCHARCNL = NOCC\n             ISPEXEC VPUT (ZCHARCNL)\n             ISPEXEC BROWSE DATASET('&GDGPRT')\n             SET ZCHARCNL = &HCHARCNL\n             ISPEXEC VPUT (ZCHARCNL)\n             ISPEXEC SETMSG MSG(PAJG000D)\n             END\n           END\n/* - - - D AND M PROCESSES  - - - - - - - - - - - - - - - - - - - - */\n         ELSE IF (&G = D OR &G = M) THEN DO\n           IF &G = M THEN DO\n             SET &GDGENTL = &LENGTH(&STR(00&GNM))\n             SET &GDGENTS = +\n               &STR(&SUBSTR(&EVAL(&GDGENTL-2):&GDGENTL,&STR(00&GNM)))\n             SET &ACTION  = &STR(MODIFIED)\n             END\n           ELSE DO\n             SET &GDGENTS = &STR(&GNM)\n             SET &ACTION  = &STR(DELETED)\n             END\n           LISTC ENT(&GDGPREF) GDG ALL OUTFILE(GDGOUT)\n           SET &CCND = &LASTCC\n           IF &CCND > 0 THEN ISPEXEC SETMSG MSG(PAJG000C)\n           ELSE DO\n             IF &OSC EQ NO THEN SET &SCROPT = &STR(NS)\n             ELSE SET &SCROPT = &Z\n             IF &OEM EQ YES THEN SET &EMPOPT = &STR(EM)\n             ELSE SET &EMPOPT = &Z\n             SET &GDGWRK = &STR(  &GDGNAME &GDGENTS &SCROPT &EMPOPT )\n             ATTR $G$R$I LRECL(80) BLKSIZE(80) RECFM(F B)\n             ALLOC F(GDGIN) DA('&SYSUID..GDGIN.DATA') +\n               REUSE US($G$R$I) NEW DEL SPACE(1) TRACK\n             OPENFILE GDGIN OUTPUT\n             SET &GDGIN = &STR(&GDGWRK)\n             PUTFILE GDGIN\n             CLOSFILE GDGIN\n             GDGRESET\n             FREE F(GDGIN) DELETE\n             IF &G = M THEN DO\n               LISTC ENT(&GDGPREF) GDG ALL OUTFILE(GDGOUT)\n               SET &CCND = &LASTCC\n               END\n             SET HCHARCNL = &ZCHARCNL\n             SET ZCHARCNL = NOCC\n             ISPEXEC VPUT (ZCHARCNL)\n             ISPEXEC BROWSE DATASET('&GDGPRT')\n             SET ZCHARCNL = &HCHARCNL\n             ISPEXEC VPUT (ZCHARCNL)\n             IF &G = M THEN DO\n               IF &CCND > 0 THEN ISPEXEC SETMSG MSG(PAJG000C)\n               ELSE ISPEXEC SETMSG MSG(PAJG000D)\n               END\n             ELSE ISPEXEC SETMSG MSG(PAJG000D)\n             END\n           END\n/* - - - S PROCESS  - - - - - - - - - - - - - - - - - - - - - - - - */\n         ELSE IF &G = S THEN DO\n           ISPEXEC DISPLAY PANEL(PAJGDGM)\n           IF &LASTCC EQ 0 THEN DO\n             ISPEXEC VGET (G0 G1 G2 G3)\n             IF (&G1 NE &Z OR &G2 NE &Z OR &G3 NE &Z) THEN DO\n               SET &ACTION  = &STR(CREATED)\n               SET &GREC = &STR()\n               IF &G1 NE &Z THEN DO\n                 SET &GRLN = &LENGTH(&G1)\n                 SET &I = 1\n                 DO WHILE &I LE &GRLN\n                   SET &GRCH = &SUBSTR(&I:&I,&STR(&G1))\n                   IF &GRCH NE &Z THEN DO\n                     IF &STR(&GREC) EQ &Z THEN SET &GREC = &STR(&GRCH)\n                     ELSE SET &GREC = &STR(&GREC &GRCH)\n                     END\n                   SET &I = &I + 1\n                   END\n                 END\n               SET &GATT = &STR()\n               IF &STR(&GREC) NE &Z THEN -\n                 SET &GATT = &STR(RECFM(&GREC.))\n               IF &STR(&G2) NE &Z THEN -\n                 SET &GATT = &STR(&GATT BLKSIZE(&G2.))\n               IF &STR(&G3) NE &Z THEN -\n                 SET &GATT = &STR(&GATT LRECL(&G3.))\n               ALLOC F(GDGMDL) DA(&GDGPREF) UNIT(DISK) VOLUME(&G0)  -\n                 TRACKS SPACE(0) NEW KEEP &GATT\n               SET &CCND = &LASTCC\n               IF &CCND > 0 THEN ISPEXEC SETMSG MSG(PAJG000E)\n               ELSE DO\n                 FREE F(GDGMDL) KEEP\n                 SET &CCND = &LASTCC\n                 IF &CCND > 0 THEN ISPEXEC SETMSG MSG(PAJG000F)\n                 ELSE ISPEXEC SETMSG MSG(PAJG000G)\n                 END\n               END\n             ELSE DO\n               SET &ACTION  = &STR(DELETED)\n               ALLOC F(GDGMDL) DA(&GDGPREF) UNIT(DISK) VOLUME(&G0) OLD\n               SET &CCND = &LASTCC\n               IF &CCND > 0 THEN ISPEXEC SETMSG MSG(PAJG000E)\n               ELSE DO\n                 FREE F(GDGMDL) DELETE\n                 SET &CCND = &LASTCC\n                 IF &CCND > 0 THEN ISPEXEC SETMSG MSG(PAJG00F)\n                 ELSE ISPEXEC SETMSG MSG(PAJG000G)\n                 END\n               END\n             END\n           END\n/* - - - T PROCESS  - - - - - - - - - - - - - - - - - - - - - - - - */\n         ELSE IF &G = T THEN DO\n           ISPEXEC DISPLAY PANEL(PAJGDGM)\n           IF &LASTCC EQ 0 THEN DO\n             LISTDSI &GDGPREF VOL(&G0) NODIRECTORY NORECALL\n             SET &CCND = &LASTCC\n             OPENFILE GDGOUT OUTPUT\n             IF &CCND > 4 THEN DO\n               SET &ACTION  = &STR(FAILED)\n               SET &GDGOUT = +\n                 &STR(1-- GENERATION DATA GROUP MODEL UTILITY --)\n               PUTFILE GDGOUT\n               SET &GDGOUT = +\n                 &STR(0     GDG MODEL = &GDGPREF ON &G0 )\n               PUTFILE GDGOUT\n               SET &GDGOUT = +\n                 &STR(      RETURN CODE = &CCND / REASON = &SYSREASON )\n               PUTFILE GDGOUT\n               SET &GDGOUT = &STR(           &SYSMSGLVL1 )\n               PUTFILE GDGOUT\n               SET &GDGOUT = &STR(           &SYSMSGLVL2 )\n               PUTFILE GDGOUT\n               END\n             ELSE DO\n               SET &ACTION  = &STR(COMPLETE)\n               SET &GDGOUT = +\n                 &STR(1-- GENERATION DATA GROUP MODEL UTILITY --)\n               PUTFILE GDGOUT\n               SET &GDGOUT = +\n                 &STR(0     GDG MODEL = &SYSDSNAME ON &SYSVOLUME )\n               PUTFILE GDGOUT\n               SET &GDGOUT = +\n                 &STR(      RETURN CODE = &CCND REASON = &SYSREASON )\n               PUTFILE GDGOUT\n               SET &GDGOUT = +\n                 &STR(           DSORG      = &SYSDSORG )\n               PUTFILE GDGOUT\n               SET &GDGOUT = +\n                 &STR(           RECFM      = &SYSRECFM )\n               PUTFILE GDGOUT\n               SET &GDGOUT = +\n                 &STR(           LRECL      = &SYSLRECL )\n               PUTFILE GDGOUT\n               SET &GDGOUT = +\n                 &STR(           BLKSIZE    = &SYSBLKSIZE )\n               PUTFILE GDGOUT\n               SET &GDGOUT = +\n                 &STR(           ALLOCATION = &SYSUNITS  &SYSALLOC  )\n               PUTFILE GDGOUT\n               END\n             CLOSFILE GDGOUT\n             SET HCHARCNL = &ZCHARCNL\n             SET ZCHARCNL = NOCC\n             ISPEXEC VPUT (ZCHARCNL)\n             ISPEXEC BROWSE DATASET('&GDGPRT')\n             SET ZCHARCNL = &HCHARCNL\n             ISPEXEC VPUT (ZCHARCNL)\n             ISPEXEC SETMSG MSG(PAJG000H)\n             END\n           END\n/* - - - END OF PROCESSES - - - - - - - - - - - - - - - - - - - - - */\n         IF &K EQ D THEN FREE F(GDGOUT) DELETE\n         ELSE FREE F(GDGOUT)\n         ISPEXEC CONTROL DISPLAY RESTORE\n         GOTO DISPLAY\n/* - - - THAT'S ALL FOLKS - - - - - - - - - - - - - - - - - - - - - */\nALLDONE: CONTROL NOMSG\n         FREE ATTR($L$C$P $G$R$O $G$R$I)\n         CONTROL MSG\n         ISPEXEC VPUT (GDGPREF G GDGPJ GDGGR GDGTY K GNM)\n         ISPEXEC VPUT (OSC OEM ZCHARCNL)\n         ISPEXEC CONTROL DISPLAY REFRESH\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCIVKA": {"ttr": 23556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x1f\\x00\\x944\\x1f\\x15C\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-07T00:00:00", "modifydate": "1994-12-07T15:43:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n/*       PRE-REQUISITE PRODUCTS : IOFSPF                             */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN EXIT\n         EUSID\n         IF &LASTCC \u00ac= 0 THEN EXIT\n         CONTROL NOMSG\n         FREE F(SYSPO SYSSU)\n         CONTROL MSG\n         ISPEXEC FTOPEN TEMP\n         ISPEXEC FTINCL PAJSIVKA\n         ISPEXEC FTCLOSE\n         ISPEXEC VGET ZTEMPF\n         ALLOC F(SYSPO) DA('&ZTEMPF')\n         INTRDR SYSSU\n         EUSUB\n         CONTROL NOMSG\n         FREE F(SYSPO SYSSU)\n         CONTROL MSG\n         SET &IOPARM = &STR(I.&EURUSID.V)\n         ISPEXEC SELECT PGM(IOFSPF) PARM(&IOPARM) NEWAPPL(IOF)\n         EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCIVKB": {"ttr": 23558, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x1f\\x00\\x944\\x1f\\x15C\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-07T00:00:00", "modifydate": "1994-12-07T15:43:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n/*       PRE-REQUISITE PRODUCTS : IOFSPF                             */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN EXIT\n         EUSID\n         IF &LASTCC \u00ac= 0 THEN EXIT\n         CONTROL NOMSG\n         FREE F(SYSPO SYSSU)\n         CONTROL MSG\n         ISPEXEC FTOPEN TEMP\n         ISPEXEC FTINCL PAJSIVKB\n         ISPEXEC FTCLOSE\n         ISPEXEC VGET ZTEMPF\n         ALLOC F(SYSPO) DA('&ZTEMPF')\n         INTRDR SYSSU\n         EUSUB\n         CONTROL NOMSG\n         FREE F(SYSPO SYSSU)\n         CONTROL MSG\n         SET &IOPARM = &STR(I.&EURUSID.R)\n         ISPEXEC SELECT PGM(IOFSPF) PARM(&IOPARM) NEWAPPL(IOF)\n         EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCIVK1": {"ttr": 23560, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x12\\x7f\\x00\\x85\\x12\\x7f\\t\\x17\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-05-07T00:00:00", "modifydate": "1985-05-07T09:17:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 DOPT\n         ISPEXEC VGET (DOPT)\n         ISPEXEC CONTROL DISPLAY LINE\n         SCRSZ\n         SET &TTYPE = &LASTCC\n         TERMINAL SCRSIZE(24,80)\n         IF &DOPT = YES THEN GOTO SDSY\n         DIDOCS\n         GOTO SDEX\nSDSY:    DIDOCS S\nSDEX:    IF &TTYPE = 1 THEN TERMINAL SCRSIZE(24,80)\n         IF &TTYPE = 2 THEN TERMINAL SCRSIZE(27,132)\n         IF &TTYPE = 3 THEN TERMINAL SCRSIZE(32,80)\n         IF &TTYPE = 4 THEN TERMINAL SCRSIZE(43,80)\n         ISPEXEC CONTROL DISPLAY REFRESH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCIVK2": {"ttr": 23562, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x12\\x7f\\x00\\x85\\x12\\x7f\\tA\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-05-07T00:00:00", "modifydate": "1985-05-07T09:41:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 DSBC\n         ISPEXEC VGET (DSBC)\n         ISPEXEC CONTROL DISPLAY LINE\n         SCRSZ\n         SET &TTYPE = &LASTCC\n         TERMINAL SCRSIZE(24,80)\n         QSP &DSBC\n         IF &TTYPE = 1 THEN TERMINAL SCRSIZE(24,80)\n         IF &TTYPE = 2 THEN TERMINAL SCRSIZE(27,132)\n         IF &TTYPE = 3 THEN TERMINAL SCRSIZE(32,80)\n         IF &TTYPE = 4 THEN TERMINAL SCRSIZE(43,80)\n         ISPEXEC CONTROL DISPLAY REFRESH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCIVK3": {"ttr": 23564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x880/\\x00\\x880/\\t\"\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-10-28T00:00:00", "modifydate": "1988-10-28T09:22:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         ISPEXEC CONTROL DISPLAY LINE\n         SCRSZ\n         SET &TTYPE = &LASTCC\n         TERMINAL SCRSIZE(24,80)\n         VSM\n         IF &TTYPE = 1 THEN TERMINAL SCRSIZE(24,80)\n         IF &TTYPE = 2 THEN TERMINAL SCRSIZE(27,132)\n         IF &TTYPE = 3 THEN TERMINAL SCRSIZE(32,80)\n         IF &TTYPE = 4 THEN TERMINAL SCRSIZE(43,80)\n         ISPEXEC CONTROL DISPLAY REFRESH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCIVK4": {"ttr": 23566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x12\\x8f\\x00\\x85\\x12\\x8f\\x14\\x03\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-05-08T00:00:00", "modifydate": "1985-05-08T14:03:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         ISPEXEC CONTROL DISPLAY LINE\n         SCRSZ\n         SET &TTYPE = &LASTCC\n         TERMINAL SCRSIZE(24,80)\n         PUSE\n         IF &TTYPE = 1 THEN TERMINAL SCRSIZE(24,80)\n         IF &TTYPE = 2 THEN TERMINAL SCRSIZE(27,132)\n         IF &TTYPE = 3 THEN TERMINAL SCRSIZE(32,80)\n         IF &TTYPE = 4 THEN TERMINAL SCRSIZE(43,80)\n         ISPEXEC CONTROL DISPLAY REFRESH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCIVK5": {"ttr": 23568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x17\\x1f\\x00\\x85\\x17\\x1f\\x15H\\x00\\x05\\x00\\x05\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-06-20T00:00:00", "modifydate": "1985-06-20T15:48:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 VOPT\n         CONTROL MSG\n         ISPEXEC VGET (VOPT)\n         UNITS &VOPT\n         CONTROL MSG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCIVK6": {"ttr": 23570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x17\\x1f\\x00\\x85\\x17\\x1f\\x15H\\x00\\x05\\x00\\x05\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-06-20T00:00:00", "modifydate": "1985-06-20T15:48:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 UOPT\n         CONTROL MSG\n         ISPEXEC VGET (UOPT)\n         UNIT (&UOPT)\n         CONTROL MSG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCKUMX": {"ttr": 23572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x931_\\x00\\x931_\\x127\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-11-11T00:00:00", "modifydate": "1993-11-11T12:37:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM) NOPROCESS\n/*  MACRO NAME : KUMX                                               */\n/*    FUNCTION : PRIVATE USE ONLY (LOCK TSO-COMMAND)                */\n/*      AUTHOR : MOINIL P.A                                         */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(HELP) OR +\n      &STR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJKUMXH)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ISREDIT !KUMX\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCLIFE": {"ttr": 23574, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x11_\\x00\\x92\\x11_\\x12\\x02\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-04-24T00:00:00", "modifydate": "1992-04-24T12:02:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n/*       PURPOSE : \"LIFE\" INVOCATION.                            (PM)*/\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN EXIT\n         ISPEXEC VGET (LFE)\n         IF (&LFE EQ YES) THEN DO\n           ISPEXEC VGET (LFEDS)\n           DSNCHECK &LFEDS NOLIST\n           SET &LFRC = &LASTCC\n           IF &LFRC NE 0 THEN DO\n             ALLOC F(LIFEDS) DA(&LFEDS) UNIT(DISK) VOLUME(USER00) -\n               CYLINDERS SPACE(1,1) DIR(10) NEW CATALOG OUTPUT -\n               DSORG(PO) RECFM(F B) BLKSIZE(1600) LRECL(80)\n             SET &LFRC = &LASTCC\n             IF &LFRC NE 0 THEN WRITE => NEW ALLOCATION FAILED\n             ELSE FREE F(LIFEDS)\n             END\n           IF &LFRC EQ 0 THEN DO\n             LIFE &LFEDS\n             SET &LFRC = &LASTCC\n             END\n           END\n         ELSE DO\n           LIFE\n           SET &LFRC = &LASTCC\n           END\n         EXIT CODE(&LFRC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJCMX": {"ttr": 23576, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07?\\x00\\x95\\x07?\\x11\\x18\\x03F\\x03F\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-14T00:00:00", "modifydate": "1995-03-14T11:18:00", "lines": 838, "newlines": 838, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n/*       PURPOSE : MAIL-BOXES FACILITY DRIVER.                   (PM)*/\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\nCONTROL MAIN NOMSG\nIF &SYSISPF EQ &STR(NOT ACTIVE) THEN EXIT\n/*-------------------------------------------------------------------*/\n/* PRE-REQUISITE : \"PRINTO\" TSO COMMAND (AVAILABLE IN CBT FILES      */\n/*                 433 AND 437).                                 (PM)*/\n/*-------------------------------------------------------------------*/\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC DISPLAY PANEL(PAJMX0)\nIF &LASTCC NE 0 THEN EXIT\nISPEXEC CONTROL ERRORS CANCEL\nIF &MXTEST EQ YES THEN CONTROL LIST SYMLIST CONLIST MSG\n/* - - - SET MAIL-BOXES TABLE (DDNAME = MXTBMB). - - - - - - - - - - */\nERROR DO\n  ERROR DO\n    ERROR OFF\n    ISPEXEC SETMSG MSG(PAJM991U)\n    EXIT\n    END\n  SET &MXDSN = &STR(&MXTPRO..&MXTLIB..&MXTTYP)\n  SET &MXUNM = SYSDA\n  SET &MXSP1 = 5\n  SET &MXSP2 = 2\n  SET &MXSPU = TRACKS\n  SET &MXDIR = 46\n  ISPEXEC VPUT (MXDSN MXUNM MXSP1 MXSP2 MXSPU MXDIR)\n  ISPEXEC DISPLAY PANEL(PAJMX3)\n  ALLOC F(MXTBMB) DSN('&MXTPRO..&MXTLIB..&MXTTYP') +\n    NEW CATALOG UNIT(&MXUNM) VOLUME(&MXVOL) +\n    SP(&MXSP1 &MXSP2) &MXSPU DIR(&MXDIR) +\n    RECFM(F B) LRECL(80) BLKSIZE(9040)\n  FREE F(MXTBMB)\n  ERROR OFF\n  END\nALLOC F(MXTBMB) DSN('&MXTPRO..&MXTLIB..&MXTTYP') SHR\nERROR OFF\nISPEXEC LIBDEF ISPTLIB LIBRARY ID(MXTBMB)\nISPEXEC LIBDEF ISPTABL LIBRARY ID(MXTBMB)\nISPEXEC CONTROL ERRORS RETURN\nIF &MXUPDT EQ YES THEN ISPEXEC TBOPEN &MXLIST WRITE SHARE\nELSE ISPEXEC TBOPEN &MXLIST NOWRITE SHARE\nSET &RC = &LASTCC\nISPEXEC CONTROL ERRORS CANCEL\nIF &RC EQ 12 THEN DO\n  ISPEXEC SETMSG MSG(PAJM991R)\n  GOTO EX01\n  END\nIF &RC GT 12 THEN DO\n  ISPEXEC SETMSG MSG(PAJM991S)\n  GOTO EX01\n  END\nIF &RC EQ 8 THEN DO\n  IF &MXUPDT EQ YES THEN DO\n    ISPEXEC TBCREATE &MXLIST WRITE SHARE +\n      NAMES(MXNUM MXDES MXDATE MXSORT MXFIELD MXAUT)\n    SET &RC = &LASTCC\n    IF &RC NE 0 THEN DO\n      ISPEXEC SETMSG MSG(PAJM991S)\n      GOTO EX01\n      END\n    ISPEXEC SETMSG MSG(PAJM991T)\n    END\n  ELSE DO\n    ISPEXEC SETMSG MSG(PAJM991N)\n    GOTO EX01\n    END\n  END\nISPEXEC TBSORT &MXLIST +\n  FIELDS(MXNUM,N,D MXSORT,N,A MXFIELD,C,A MXAUT,C,A)\nSET &MXSRTF = &STR( MAIL DATE FIELD AUTHOR)\nISPEXEC VPUT (MXSRTF)\nSET &MXPDEL =\nSET &RC = 0\nSET &ZTDTOP = 0\nSET &MXUPF =\n/* - - - DISPLAY MAIL-BOXES TABLE. - - - - - - - - - - - - - - - - - */\nNX00: IF &RC EQ 4 THEN ISPEXEC TBDISPL &MXLIST POSITION(CRP)\nELSE DO\n  ISPEXEC TBTOP &MXLIST\n  ISPEXEC TBSKIP &MXLIST NUMBER(&ZTDTOP)\n  ISPEXEC VGET (ZVERB ZSCROLLN)\n  IF &ZVERB EQ UP THEN ISPEXEC TBSKIP &MXLIST NUMBER(-&ZSCROLLN)\n  ELSE IF &ZVERB EQ DOWN THEN ISPEXEC TBSKIP &MXLIST +\n    NUMBER(&ZSCROLLN)\n  ISPEXEC TBDISPL &MXLIST PANEL(PAJMX1) POSITION(CRP)\n  END\nSET &RC = &LASTCC\nIF &CMD EQ CANCEL OR &RC GT 4 THEN GOTO EX00\n/* - - - SORT COMMAND. - - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ SORT THEN DO\n  IF &SFMX1 EQ THEN DO\n    SET &SFMX1 = M\n    SET &SFMX2 = D\n    SET &SFMX3 = F\n    SET &SFMX4 = A\n    END\n  SET &MXSFLDS =\n  SET &MXSRTF =\n  SET &I = 1\n  DO WHILE &I LT 5\n    SET &SFMX = SFMX&I\n    SET &S = &&&SFMX\n    IF &S EQ M THEN DO\n      SET &MXSFLDS = &STR(&MXSFLDS MXNUM,N,D)\n      SET &MXSRTF = &STR(&MXSRTF MAIL)\n      END\n    ELSE IF &S EQ MI THEN DO\n      SET &MXSFLDS = &STR(&MXSFLDS MXNUM,N,A)\n      SET &MXSRTF = &STR(&MXSRTF MAIL(A))\n      END\n    ELSE IF &S EQ D THEN DO\n      SET &MXSFLDS = &STR(&MXSFLDS MXSORT,N,A)\n      SET &MXSRTF = &STR(&MXSRTF DATE)\n      END\n    ELSE IF &S EQ DI THEN DO\n      SET &MXSFLDS = &STR(&MXSFLDS MXSORT,N,D)\n      SET &MXSRTF = &STR(&MXSRTF DATE(D))\n      END\n    ELSE IF &S EQ F THEN DO\n      SET &MXSFLDS = &STR(&MXSFLDS MXFIELD,C,A)\n      SET &MXSRTF = &STR(&MXSRTF FIELD)\n      END\n    ELSE IF &S EQ FI THEN DO\n      SET &MXSFLDS = &STR(&MXSFLDS MXFIELD,C,D)\n      SET &MXSRTF = &STR(&MXSRTF FIELD(D))\n      END\n    ELSE IF &S EQ A THEN DO\n      SET &MXSFLDS = &STR(&MXSFLDS MXAUT,C,A)\n      SET &MXSRTF = &STR(&MXSRTF AUTHOR)\n      END\n    ELSE IF &S EQ AI THEN DO\n      SET &MXSFLDS = &STR(&MXSFLDS MXAUT,C,D)\n      SET &MXSRTF = &STR(&MXSRTF AUTHOR(D))\n      END\n    SET &I = &I + 1\n    END\n  ISPEXEC VPUT (MXSRTF)\n  ISPEXEC TBSORT &MXLIST FIELDS(&MXSFLDS)\n  ISPEXEC SETMSG MSG(PAJM995R)\n  END\n/* - - - SAVE COMMAND. - - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ SAVE THEN DO\n  IF &MXUPDT EQ YES THEN DO\n    ISPEXEC TBSORT &MXLIST +\n      FIELDS(MXNUM,N,D MXSORT,N,A MXFIELD,C,A MXAUT,C,A)\n    ISPEXEC TBSAVE &MXLIST REPLCOPY PAD(15)\n    SET &MXUPF =\n    ISPEXEC TBSORT &MXLIST FIELDS(&MXSFLDS)\n    ISPEXEC SETMSG MSG(PAJM995S)\n    END\n  ELSE ISPEXEC SETMSG MSG(PAJM993T)\n  END\n/* - - - INPUT COMMAND.  - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ INPUT THEN DO\n  IF &MXUPDT EQ YES THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    DO WHILE &MXIN GE 1\n      ISPEXEC TBVCLEAR &MXLIST\n      ISPEXEC DISPLAY PANEL(PAJMX2)\n      IF &LASTCC EQ 0 THEN DO\n        SET &MXDEL = &MXNUM\n        SET &MXNUM = &MXDEL\n        ISPEXEC TBADD &MXLIST ORDER\n        SET &MXUPF = YES\n        END\n      SET &MXIN = &MXIN - 1\n      END\n    ISPEXEC CONTROL DISPLAY RESTORE\n    END\n  ELSE ISPEXEC SETMSG MSG(PAJM993T)\n  END\n/* - - - MAILBOX COMMAND.  - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ MAILBOX THEN DO\n  ISPEXEC CONTROL DISPLAY SAVE\n  SET &ALRC = 0\n  ERROR DO\n    ERROR DO\n      ISPEXEC SETMSG MSG(PAJM998E)\n      SET &ALRC = 1\n      GOTO MC00\n      END\n    SET &MXDSN = &STR(&MXMPRO..&MXMLIB..&MXMTYP)\n    SET &MXUNM = SYSDA\n    SET &MXSP1 = 2\n    SET &MXSP2 = 1\n    SET &MXSPU = CYLINDERS\n    SET &MXDIR = 46\n    SET &MXRCF = VARIABLE\n    ISPEXEC VPUT (MXDSN MXUNM MXSP1 MXSP2 MXSPU MXDIR MXRCF)\n    ISPEXEC DISPLAY PANEL(PAJMX5)\n    IF &MXRCF EQ FIXED THEN -\n      ATTR MXATTR RECFM(F B) LRECL(80) BLKSIZE(6320)\n    ELSE ATTR MXATTR RECFM(V B) LRECL(84) BLKSIZE(6356)\n    ALLOC F(MXMLBX) DSN('&MXMPRO..&MXMLIB..&MXMTYP.($MAIL$)') +\n      NEW REUSE UNIT(&MXUNM) VOLUME(&MXVOL) +\n      SP(&MXSP1 &MXSP2) &MXSPU DIR(&MXDIR) USING(MXATTR)\n    FREE ATTR(MXATTR)\n    ERROR OFF\n    END\n  ALLOC F(MXMLBX) DSN('&MXMPRO..&MXMLIB..&MXMTYP') SHR REUSE\nMC00: ERROR OFF\n  FREE F(MXMLBX)\n  ERROR OFF\n  IF &ALRC NE 0 THEN GOTO MC01\n  ISPEXEC CONTROL ERRORS RETURN\n  ISPEXEC EDIT DATASET('&MXMPRO..&MXMLIB..&MXMTYP') MACRO(PAJCMXN)\n  IF &LASTCC GT 4 THEN ISPEXEC SETMSG MSG(PAJM996T)\n  ISPEXEC CONTROL ERRORS CANCEL\nMC01: ISPEXEC CONTROL DISPLAY RESTORE\n  END\n/* - - - LIST COMMAND. - - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ LIST THEN DO\n  ERROR DO\n    ERROR OFF\n    FREE ATTR(VBA)\n    ATTR VBA RECFM(V B A) LRECL(137) BLKSIZE(6356) DSORG(PS)\n    ALLOC F(ISPFILE) DSN(MXTEMP.LISTING) REUSE CATALOG +\n      USING(VBA) SP(2 2) TRACKS\n    SET &MXPDEL = DELETE\n    END\n  ALLOC F(ISPFILE) DSN(MXTEMP.LISTING) OLD REUSE\n  ERROR OFF\n  ISPEXEC FTOPEN\n  ISPEXEC FTINCL PAJSMX1\n  ISPEXEC FTCLOSE\n  SET &MXPOPT =\n  IF &MXPDEST NE THEN SET &MXPOPT = &STR(DEST(&MXPDEST))\n  IF &MXPCLAS NE THEN SET &MXPOPT = &STR(&MXPOPT CLASS(&MXPCLAS))\n  PRINTO MXTEMP.LISTING &MXPOPT NOHEADING\n  ISPEXEC SETMSG MSG(PAJM993P)\n  END\n/* - - - STATUS COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &CMD EQ STATUS THEN DO\n  ISPEXEC CONTROL DISPLAY SAVE\n  ISPEXEC DISPLAY PANEL(PAJMX4)\n  IF &LASTCC GT 8 THEN EXIT\n  ISPEXEC CONTROL DISPLAY RESTORE\n  END\n/* - - - D LINE-COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\nELSE IF &ZTDSELS GE 1 THEN DO\n  IF &ACT EQ D THEN DO\n    IF &MXUPDT EQ YES THEN -\n      DO WHILE &N GE 1\n        ISPEXEC TBDELETE &MXLIST\n        ISPEXEC TBSKIP &MXLIST\n        IF &LASTCC NE 0 THEN SET &N = 0\n        ELSE SET &N = &N - 1\n        SET &MXUPF = YES\n        END\n    ELSE ISPEXEC SETMSG MSG(PAJM993T)\n    END\n/* - - - R LINE-COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\n  ELSE IF &ACT EQ R THEN DO\n    IF &MXUPDT EQ YES THEN -\n      DO WHILE &N GE 1\n        ISPEXEC TBADD &MXLIST ORDER\n        SET &N = &N - 1\n        SET &MXUPF = YES\n        END\n    ELSE ISPEXEC SETMSG MSG(PAJM993T)\n    END\n/* - - - U LINE-COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\n  ELSE IF &ACT EQ U THEN DO\n    IF &MXUPDT EQ YES THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      DO WHILE &N GE 1\n        ISPEXEC DISPLAY PANEL(PAJMX2)\n        SET &RCLC = &LASTCC\n        IF &RCLC EQ 0 THEN DO\n          SET &MXDEL = &MXNUM\n          SET &MXNUM = &MXDEL\n          ISPEXEC TBPUT &MXLIST ORDER\n          ISPEXEC SETMSG MSG(PAJM994S)\n          SET &MXUPF = YES\n          END\n        ELSE IF &RCLC GT 8 THEN GOTO UL00\n        ELSE ISPEXEC SETMSG MSG(PAJM994N)\n        IF &N EQ 1 THEN GOTO UL01\n        ISPEXEC TBSKIP &MXLIST\n        IF &LASTCC EQ 0 THEN GOTO UL01\nUL00:   SET &N = 1\nUL01:   SET &N = &N - 1\n        END\n      ISPEXEC CONTROL DISPLAY RESTORE\n      END\n    ELSE ISPEXEC SETMSG MSG(PAJM993T)\n    END\n/* - - - M LINE-COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\n  ELSE IF &ACT EQ M THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    SET &ALRC = 0\n    ERROR DO\n      ERROR DO\n        ISPEXEC SETMSG MSG(PAJM998E)\n        SET &ALRC = 1\n        GOTO ML00\n        END\n      SET &MXDSN = &STR(&MXMPRO..&MXMLIB..&MXMTYP)\n      SET &MXUNM = SYSDA\n      SET &MXSP1 = 2\n      SET &MXSP2 = 1\n      SET &MXSPU = CYLINDERS\n      SET &MXDIR = 46\n      SET &MXRCF = VARIABLE\n      ISPEXEC VPUT (MXDSN MXUNM MXSP1 MXSP2 MXSPU MXDIR MXRCF)\n      ISPEXEC DISPLAY PANEL(PAJMX5)\n      IF &MXRCF EQ FIXED THEN -\n        ATTR MXATTR RECFM(F B) LRECL(80) BLKSIZE(6320)\n      ELSE ATTR MXATTR RECFM(V B) LRECL(84) BLKSIZE(6356)\n      ALLOC F(MXMLBX) DSN('&MXMPRO..&MXMLIB..&MXMTYP') +\n        NEW REUSE UNIT(&MXUNM) VOLUME(&MXVOL) +\n        SP(&MXSP1 &MXSP2) &MXSPU DIR(&MXDIR) USING(MXATTR)\n      FREE ATTR(MXATTR)\n      ERROR OFF\n      END\n    ALLOC F(MXMLBX) DSN('&MXMPRO..&MXMLIB..&MXMTYP') SHR\nML00: ERROR OFF\n    FREE F(MXMLBX)\n    ERROR OFF\n    IF &ALRC NE 0 THEN GOTO ML03\n    DO WHILE &N GE 1\n      ISPEXEC EDIT DATASET('&MXMPRO..&MXMLIB..&MXMTYP.(MX&MXNUM)') +\n        MACRO(PAJCMXN)\n      SET &RCLC = &LASTCC\n      IF &RCLC GT 4 THEN GOTO ML01\n      IF &RCLC EQ 0 THEN ISPEXEC SETMSG MSG(PAJM996S)\n      ELSE ISPEXEC SETMSG MSG(PAJM996N)\n      IF &N EQ 1 THEN GOTO ML02\n      ISPEXEC TBSKIP &MXLIST\n      IF &LASTCC EQ 0 THEN GOTO ML02\nML01: ISPEXEC SETMSG MSG(PAJM996N)\n      SET &N = 1\nML02: SET &N = &N - 1\n      END\nML03: ISPEXEC CONTROL DISPLAY RESTORE\n    END\n/* - - - B LINE-COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\n  ELSE IF &ACT EQ B THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    SET &ALRC = 0\n    ERROR DO\n      ERROR DO\n        ISPEXEC SETMSG MSG(PAJM998E)\n        SET &ALRC = 1\n        GOTO BL00\n        END\n      SET &MXDSN = &STR(&MXMPRO..&MXMLIB..&MXMTYP)\n      SET &MXUNM = SYSDA\n      SET &MXSP1 = 2\n      SET &MXSP2 = 1\n      SET &MXSPU = CYLINDERS\n      SET &MXDIR = 46\n      SET &MXRCF = VARIABLE\n      ISPEXEC VPUT (MXDSN MXUNM MXSP1 MXSP2 MXSPU MXDIR MXRCF)\n      ISPEXEC DISPLAY PANEL(PAJMX5)\n      IF &MXRCF EQ FIXED THEN -\n        ATTR MXATTR RECFM(F B) LRECL(80) BLKSIZE(6320)\n      ELSE ATTR MXATTR RECFM(V B) LRECL(84) BLKSIZE(6356)\n      ALLOC F(MXMLBX) DSN('&MXMPRO..&MXMLIB..&MXMTYP') +\n        NEW REUSE UNIT(&MXUNM) VOLUME(&MXVOL) +\n        SP(&MXSP1 &MXSP2) &MXSPU DIR(&MXDIR) USING(MXATTR)\n      FREE ATTR(MXATTR)\n      ERROR OFF\n      END\n    ALLOC F(MXMLBX) DSN('&MXMPRO..&MXMLIB..&MXMTYP') SHR\nBL00: ERROR OFF\n    ERROR OFF\n    IF &ALRC NE 0 THEN GOTO BL94\n    ALLOC F(MXBRWS) UNIT(VIO) SPACE(1 1) CYLINDERS -\n      DSORG(PS) RECFM(V B A) LRECL(80) BLKSIZE(4084) NEW\n    ISPEXEC CONTROL ERRORS RETURN\n    ISPEXEC LMINIT DATAID(MXFIN) DDNAME(MXMLBX)\n    SET &RCLC = &LASTCC\n    IF &RCLC NE 0 THEN DO\n      ISPEXEC SETMSG MSG(PAJM998I)\n      GOTO BL93\n      END\n    ISPEXEC LMINIT DATAID(MXFOU) DDNAME(MXBRWS) ENQ(EXCLU)\n    SET &RCLC = &LASTCC\n    IF &RCLC NE 0 THEN DO\n      ISPEXEC SETMSG MSG(PAJM998J)\n      GOTO BL92\n      END\n    IF &MXOPT NE NO THEN ISPEXEC LMOPEN DATAID(&MXFIN) RECFM(MXRFT)\n    ELSE ISPEXEC LMOPEN DATAID(&MXFIN)\n    SET &RCLC = &LASTCC\n    IF &RCLC NE 0 THEN DO\n      ISPEXEC SETMSG MSG(PAJM998O)\n      GOTO BL91\n      END\n    IF &MXOPT NE NO THEN DO\n      ISPEXEC CONTROL ERRORS CANCEL\n      IF &MXRFT EQ FB THEN -\n        ALLOC F(MXWORK) UNIT(VIO) SPACE(1 1) CYLINDERS -\n          DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(4080) NEW\n      ELSE ALLOC F(MXWORK) UNIT(VIO) SPACE(1 1) CYLINDERS -\n          DSORG(PS) RECFM(V B) LRECL(84) BLKSIZE(4096) NEW\n      ISPEXEC CONTROL ERRORS RETURN\n      ISPEXEC LMINIT DATAID(MXFWK) DDNAME(MXWORK) ENQ(EXCLU)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998J)\n        GOTO BL90\n        END\n      END\n    DO WHILE &N GE 1\n      ISPEXEC LMOPEN DATAID(&MXFOU) OPTION(OUTPUT)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998P)\n        GOTO BL33\n        END\n      ISPEXEC LMMFIND DATAID(&MXFIN) MEMBER(MX&MXNUM)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998N)\n        GOTO BL32\n        END\n      IF &MXOPT NE NO THEN GOTO BL10\n      CONTROL ASIS\n      SET &MXPRQ = B\nBL01: ISPEXEC LMGET DATAID(&MXFIN) MODE(INVAR) +\n        DATALOC(MXRIN) DATALEN(MXLIN) MAXLEN(80)\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 8 THEN GOTO BL02\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998R)\n        GOTO BL31\n        END\n      ISPEXEC VPUT (MXRIN MXLIN MXPRQ) SHARED\n      ISPEXEC SELECT PGM(PAJPMX)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998X)\n        GOTO BL31\n        END\n      ISPEXEC VGET (MXROU MXLOU) SHARED\n      ISPEXEC LMPUT DATAID(&MXFOU) MODE(INVAR) +\n        DATALOC(MXROU) DATALEN(&MXLOU) NOBSCAN\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 0 THEN GOTO BL01\n      ISPEXEC SETMSG MSG(PAJM998W)\n      GOTO BL31\nBL02: CONTROL CAPS\n      GOTO BL20\nBL10: ISPEXEC LMOPEN DATAID(&MXFWK) OPTION(OUTPUT)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998P)\n        GOTO BL32\n        END\n      CONTROL ASIS\n      SET &MXPRQ = M\nBL11: ISPEXEC LMGET DATAID(&MXFIN) MODE(INVAR) +\n        DATALOC(MXRIN) DATALEN(MXLIN) MAXLEN(80)\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 8 THEN GOTO BL12\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998R)\n        GOTO BL30\n        END\n      ISPEXEC VPUT (MXRIN MXLIN MXPRQ) SHARED\n      ISPEXEC SELECT PGM(PAJPMX)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998X)\n        GOTO BL30\n        END\n      ISPEXEC VGET (MXROU MXLOU) SHARED\n      ISPEXEC LMPUT DATAID(&MXFWK) MODE(INVAR) +\n        DATALOC(MXROU) DATALEN(&MXLOU) NOBSCAN\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 0 THEN GOTO BL11\n      ISPEXEC SETMSG MSG(PAJM998W)\n      GOTO BL30\nBL12: CONTROL CAPS\n      ISPEXEC LMCLOSE DATAID(&MXFWK)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998D)\n        GOTO BL32\n        END\nBL13: IF &MXOPT EQ YES THEN ISPEXEC EDIT DATAID(&MXFWK) MACRO(PAJCMXD)\n      ELSE ISPEXEC EDIT DATAID(&MXFWK) MACRO(PAJCMXN)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        IF &RCLC EQ 4 THEN ISPEXEC SETMSG MSG(PAJM998Y)\n        ELSE ISPEXEC SETMSG MSG(PAJM998Z)\n        GOTO BL32\n        END\n      IF &MXOPT EQ YES THEN DO\n        ISPEXEC VGET (CRYKSI) SHARED\n        IF &CRYKSI EQ YES THEN GOTO BL13\n        END\n      ISPEXEC LMOPEN DATAID(&MXFWK)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998O)\n        GOTO BL32\n        END\n      CONTROL ASIS\n      SET &MXPRQ = B\nBL14: ISPEXEC LMGET DATAID(&MXFWK) MODE(INVAR) +\n        DATALOC(MXRIN) DATALEN(MXLIN) MAXLEN(80)\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 8 THEN GOTO BL15\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998R)\n        GOTO BL30\n        END\n      ISPEXEC VPUT (MXRIN MXLIN MXPRQ) SHARED\n      ISPEXEC SELECT PGM(PAJPMX)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998X)\n        GOTO BL30\n        END\n      ISPEXEC VGET (MXROU MXLOU) SHARED\n      ISPEXEC LMPUT DATAID(&MXFOU) MODE(INVAR) +\n        DATALOC(MXROU) DATALEN(&MXLOU) NOBSCAN\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 0 THEN GOTO BL14\n      ISPEXEC SETMSG MSG(PAJM998W)\n      GOTO BL30\nBL15: CONTROL CAPS\n      ISPEXEC LMCLOSE DATAID(&MXFWK)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998C)\n        GOTO BL32\n        END\nBL20: ISPEXEC LMCLOSE DATAID(&MXFOU)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998D)\n        GOTO BL33\n        END\n      ISPEXEC BROWSE DATAID(&MXFOU)\n      IF &LASTCC NE 0 THEN ISPEXEC SETMSG MSG(PAJM997N)\n      ELSE ISPEXEC SETMSG MSG(PAJM997S)\n      IF &N EQ 1 THEN GOTO BL34\n      ISPEXEC TBSKIP &MXLIST\n      IF &LASTCC EQ 0 THEN GOTO BL34\n      GO TO BL33\nBL30: ISPEXEC LMCLOSE DATAID(&MXFWK)\nBL31: CONTROL CAPS\nBL32: ISPEXEC LMCLOSE DATAID(&MXFOU)\nBL33: SET &N = 1\nBL34: SET &N = &N - 1\n      END\n    IF &MXOPT NE NO THEN ISPEXEC LMFREE DATAID(&MXFWK)\nBL90: ISPEXEC LMCLOSE DATAID(&MXFIN)\n    IF &MXOPT NE NO THEN FREE F(MXWORK)\nBL91: ISPEXEC LMFREE DATAID(&MXFOU)\nBL92: ISPEXEC LMFREE DATAID(&MXFIN)\nBL93: FREE F(MXBRWS)\nBL94: FREE F(MXMLBX)\n    ISPEXEC CONTROL ERRORS CANCEL\n    ISPEXEC CONTROL DISPLAY RESTORE\n    END\n/* - - - L LINE-COMMAND. - - - - - - - - - - - - - - - - - - - - - - */\n  ELSE IF &ACT EQ L THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    ERROR DO\n      ERROR OFF\n      FREE ATTR(VBA)\n      ATTR VBA RECFM(V B A) LRECL(137) BLKSIZE(6356) DSORG(PS)\n      ALLOC F(ISPFILE) DSN(MXTEMP.LISTING) REUSE CATALOG +\n        USING(VBA) SP(2 2) TRACKS\n      SET &MXPDEL = DELETE\n      END\n    ALLOC F(ISPFILE) DSN(MXTEMP.LISTING) OLD REUSE\n    ERROR OFF\n    SET &ALRC = 0\n    ERROR DO\n      ERROR DO\n        ISPEXEC SETMSG MSG(PAJM998E)\n        SET &ALRC = 1\n        GOTO LL00\n        END\n      SET &MXDSN = &STR(&MXMPRO..&MXMLIB..&MXMTYP)\n      SET &MXUNM = SYSDA\n      SET &MXSP1 = 2\n      SET &MXSP2 = 1\n      SET &MXSPU = CYLINDERS\n      SET &MXDIR = 46\n      SET &MXRCF = VARIABLE\n      ISPEXEC VPUT (MXDSN MXUNM MXSP1 MXSP2 MXSPU MXDIR MXRCF)\n      ISPEXEC DISPLAY PANEL(PAJMX5)\n      IF &MXRCF EQ FIXED THEN -\n        ATTR MXATTR RECFM(F B) LRECL(80) BLKSIZE(6320)\n      ELSE ATTR MXATTR RECFM(V B) LRECL(84) BLKSIZE(6356)\n      ALLOC F(MXMLBX) DSN('&MXMPRO..&MXMLIB..&MXMTYP') +\n        NEW REUSE UNIT(&MXUNM) VOLUME(&MXVOL) +\n        SP(&MXSP1 &MXSP2) &MXSPU DIR(&MXDIR) USING(MXATTR)\n      FREE ATTR(MXATTR)\n      ERROR OFF\n      END\n    ALLOC F(MXMLBX) DSN('&MXMPRO..&MXMLIB..&MXMTYP') SHR\nLL00: ERROR OFF\n    FREE F(MXMLBX)\n    ERROR OFF\n    IF &ALRC NE 0 THEN GOTO LL92\n    ISPEXEC CONTROL ERRORS RETURN\n    ISPEXEC LMINIT DATAID(MXFIN) DATASET('&MXMPRO..&MXMLIB..&MXMTYP')\n    SET &RCLC = &LASTCC\n    IF &RCLC NE 0 THEN DO\n      ISPEXEC SETMSG MSG(PAJM998I)\n      ISPEXEC CONTROL ERRORS CANCEL\n      GOTO LL92\n      END\n    IF &MXOPT NE NO THEN ISPEXEC LMOPEN DATAID(&MXFIN) RECFM(MXRFT)\n    ELSE ISPEXEC LMOPEN DATAID(&MXFIN)\n    SET &RCLC = &LASTCC\n    IF &RCLC NE 0 THEN DO\n      ISPEXEC SETMSG MSG(PAJM998O)\n      ISPEXEC CONTROL ERRORS CANCEL\n      GOTO LL91\n      END\n    IF &MXOPT NE NO THEN DO\n      ISPEXEC CONTROL ERRORS CANCEL\n      IF &MXRFT EQ FB THEN -\n        ALLOC F(MXWORK) UNIT(VIO) SPACE(1 1) CYLINDERS -\n          DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(4080) NEW\n      ELSE ALLOC F(MXWORK) UNIT(VIO) SPACE(1 1) CYLINDERS -\n          DSORG(PS) RECFM(V B) LRECL(84) BLKSIZE(4096) NEW\n      ISPEXEC CONTROL ERRORS RETURN\n      ISPEXEC LMINIT DATAID(MXFWK) DDNAME(MXWORK) ENQ(EXCLU)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998J)\n        ISPEXEC CONTROL ERRORS CANCEL\n        GOTO LL90\n        END\n      END\n    ISPEXEC CONTROL ERRORS CANCEL\n    DO WHILE &N GE 1\n      ISPEXEC FTOPEN\n      ISPEXEC FTINCL PAJSMX2\n      ISPEXEC FTCLOSE\n      ISPEXEC CONTROL ERRORS RETURN\n      ISPEXEC LMINIT DATAID(MXFOU) DATASET(MXTEMP.LISTING) ENQ(MOD)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998J)\n        GOTO LL34\n        END\n      ISPEXEC LMOPEN DATAID(&MXFOU) OPTION(OUTPUT)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998P)\n        GOTO LL33\n        END\n      ISPEXEC LMMFIND DATAID(&MXFIN) MEMBER(MX&MXNUM)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998N)\n        GOTO LL32\n        END\n      IF &MXOPT NE NO THEN GOTO LL10\n      CONTROL ASIS\n      SET &MXPRQ = L\nLL01: ISPEXEC LMGET DATAID(&MXFIN) MODE(INVAR) +\n        DATALOC(MXRIN) DATALEN(MXLIN) MAXLEN(80)\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 8 THEN GOTO LL02\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998R)\n        GOTO LL31\n        END\n      ISPEXEC VPUT (MXRIN MXLIN MXPRQ) SHARED\n      ISPEXEC SELECT PGM(PAJPMX)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998X)\n        GOTO LL31\n        END\n      ISPEXEC VGET (MXROU MXLOU) SHARED\n      ISPEXEC LMPUT DATAID(&MXFOU) MODE(INVAR) +\n        DATALOC(MXROU) DATALEN(&MXLOU) NOBSCAN\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 0 THEN GOTO LL01\n      ISPEXEC SETMSG MSG(PAJM998W)\n      GOTO LL31\nLL02: CONTROL CAPS\n      GOTO LL20\nLL10: ISPEXEC LMOPEN DATAID(&MXFWK) OPTION(OUTPUT)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998P)\n        GOTO LL32\n        END\n      CONTROL ASIS\n      SET &MXPRQ = M\nLL11: ISPEXEC LMGET DATAID(&MXFIN) MODE(INVAR) +\n        DATALOC(MXRIN) DATALEN(MXLIN) MAXLEN(80)\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 8 THEN GOTO LL12\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998R)\n        GOTO LL30\n        END\n      ISPEXEC VPUT (MXRIN MXLIN MXPRQ) SHARED\n      ISPEXEC SELECT PGM(PAJPMX)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998X)\n        GOTO LL30\n        END\n      ISPEXEC VGET (MXROU MXLOU) SHARED\n      ISPEXEC LMPUT DATAID(&MXFWK) MODE(INVAR) +\n        DATALOC(MXROU) DATALEN(&MXLOU) NOBSCAN\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 0 THEN GOTO LL11\n      ISPEXEC SETMSG MSG(PAJM998W)\n      GOTO LL30\nLL12: CONTROL CAPS\n      ISPEXEC LMCLOSE DATAID(&MXFWK)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998D)\n        GOTO LL32\n        END\nLL13: IF &MXOPT EQ YES THEN ISPEXEC EDIT DATAID(&MXFWK) MACRO(PAJCMXD)\n      ELSE ISPEXEC EDIT DATAID(&MXFWK) MACRO(PAJCMXN)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        IF &RCLC EQ 4 THEN ISPEXEC SETMSG MSG(PAJM998Y)\n        ELSE ISPEXEC SETMSG MSG(PAJM998Z)\n        GOTO LL32\n        END\n      IF &MXOPT EQ YES THEN DO\n        ISPEXEC VGET (CRYKSI) SHARED\n        IF &CRYKSI EQ YES THEN GOTO LL13\n        END\n      ISPEXEC LMOPEN DATAID(&MXFWK)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998O)\n        GOTO LL32\n        END\n      CONTROL ASIS\n      SET &MXPRQ = B\nLL14: ISPEXEC LMGET DATAID(&MXFWK) MODE(INVAR) +\n        DATALOC(MXRIN) DATALEN(MXLIN) MAXLEN(80)\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 8 THEN GOTO LL15\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998R)\n        GOTO LL30\n        END\n      ISPEXEC VPUT (MXRIN MXLIN MXPRQ) SHARED\n      ISPEXEC SELECT PGM(PAJPMX)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998X)\n        GOTO LL30\n        END\n      ISPEXEC VGET (MXROU MXLOU) SHARED\n      ISPEXEC LMPUT DATAID(&MXFOU) MODE(INVAR) +\n        DATALOC(MXROU) DATALEN(&MXLOU) NOBSCAN\n      SET &RCLC = &LASTCC\n      IF &RCLC EQ 0 THEN GOTO LL14\n      ISPEXEC SETMSG MSG(PAJM998W)\n      GOTO LL30\nLL15: CONTROL CAPS\n      ISPEXEC LMCLOSE DATAID(&MXFWK)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998C)\n        GOTO LL32\n        END\nLL20: ISPEXEC LMCLOSE DATAID(&MXFOU)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998D)\n        GOTO LL33\n        END\n      ISPEXEC LMFREE DATAID(&MXFOU)\n      SET &RCLC = &LASTCC\n      IF &RCLC NE 0 THEN DO\n        ISPEXEC SETMSG MSG(PAJM998G)\n        GOTO LL34\n        END\n      ISPEXEC CONTROL ERRORS CANCEL\n      SET &MXLOPT =\n      IF &MXLDEST NE THEN SET &MXLOPT = &STR(DEST(&MXLDEST))\n      IF &MXLCLAS NE THEN SET &MXLOPT = &STR(&MXLOPT CLASS(&MXLCLAS))\n      PRINTO MXTEMP.LISTING &MXLOPT NOHEADING\n      ISPEXEC SETMSG MSG(PAJM997X)\n      IF &N EQ 1 THEN GOTO LL36\n      ISPEXEC TBSKIP &MXLIST\n      IF &LASTCC EQ 0 THEN GOTO LL36\n      GOTO LL35\nLL30: ISPEXEC LMCLOSE DATAID(&MXFWK)\nLL31: CONTROL CAPS\nLL32: ISPEXEC LMCLOSE DATAID(&MXFOU)\nLL33: ISPEXEC LMFREE DATAID(&MXFOU)\nLL34: ISPEXEC CONTROL ERRORS CANCEL\nLL35: SET &N = 1\nLL36: SET &N = &N - 1\n      END\n    IF &MXOPT NE NO THEN ISPEXEC LMFREE DATAID(&MXFWK)\nLL90: ISPEXEC LMCLOSE DATAID(&MXFIN)\n    IF &MXOPT NE NO THEN FREE F(MXWORK)\nLL91: ISPEXEC LMFREE DATAID(&MXFIN)\nLL92: ISPEXEC CONTROL DISPLAY RESTORE\n    END\n  END\nGOTO NX00\n/* - - - END-CANCEL COMMANDS.  - - - - - - - - - - - - - - - - - - - */\nEX00: FREE F(ISPFILE) ATTR(VBA) &MXPDEL\nIF &CMD EQ CANCEL THEN DO\n  ISPEXEC TBEND &MXLIST\n  ISPEXEC SETMSG MSG(PAJM992C)\n  END\nELSE IF &MXUPF EQ THEN DO\n  ISPEXEC TBEND &MXLIST\n  ISPEXEC SETMSG MSG(PAJM992N)\n  END\nELSE DO\n  ISPEXEC TBSORT &MXLIST +\n    FIELDS(MXNUM,N,D MXSORT,N,A MXFIELD,C,A MXAUT,C,A)\n  IF &MXUPDT EQ YES THEN DO\n    ISPEXEC TBCLOSE &MXLIST REPLCOPY PAD(15)\n    ISPEXEC SETMSG MSG(PAJM992S)\n    END\n  ELSE DO\n    ISPEXEC TBCLOSE &MXLIST\n    ISPEXEC SETMSG MSG(PAJM992N)\n    END\n  END\nEX01: ISPEXEC LIBDEF ISPTLIB LIBRARY\nISPEXEC LIBDEF ISPTABL LIBRARY\nFREE F(MXTBMB)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJCMXD": {"ttr": 24065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16(\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:28:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "         ISREDIT MACRO\n /*                                                                 */\n /* THIS MACRO DO THE DECRYPTION FOR PAJCMX                         */\n /*                                                                 */\n         ISREDIT CAPS OFF\n         ISREDIT NUMBER ON\n         ISREDIT NULLS ON\n         ISREDIT !CRY D\n         ISREDIT END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCMXN": {"ttr": 24067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16(\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:28:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "SYSPAJA"}, "text": "         ISREDIT MACRO\n /*                                                                 */\n /* THIS MACRO SET THE INITIAL EDIT MODE FOR PAJCMX                 */\n /*                                                                 */\n         ISREDIT CAPS OFF\n         ISREDIT NUMBER ON\n         ISREDIT NULLS ON\n         EXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCOM": {"ttr": 24069, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16O\\x00\\x90\\x16O\\x128\\x00:\\x00:\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-13T00:00:00", "modifydate": "1990-06-13T12:38:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n` TYPE(TEXT) COLOR(YELLOW)\n{ TYPE(TEXT) COLOR(GREEN)\n} TYPE(TEXT) COLOR(RED)\n)BODY\n%COMPARE --------------  Compare Sequentials or Members  -----------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n%Enter/verify parameters below:\n+\n}OLD -`Data-set name%===>_DDSN1\n{      Volume serial%===>_DVOL1   +  (if not cataloged)\n+\n}NEW -`Data-set name%===>_DDSN2\n{      Volume serial%===>_DVOL2   +  (if not cataloged)\n+\n}Options:+Full (columns 1-80) %===>_CMOP1     +  (default is 1-72)\n+         ASM source code     %===>_CMOP2     +\n+         IBM utility IEBCOMPR%===>_CMOP3     +  (default is COMPAREB)\n+         Messages destination%===>_CMOP4     +  (default is to terminal)\n+                 You may specify : SYSOUT, PRINT (like default), NOPRINT,\n+                                   BROWSE or a file DD-name.\n+\n}IGNORE -`Data-set name%===>_DDSN3\n{         Volume serial%===>_DVOL3   +  (if not cataloged)\n+\n)INIT\n  .HELP = PAJTCOM\n  .CURSOR = DDSN1\n  &CMOP1 = TRANS (&CMOP1 ' ',NO YES,YES NO,NO *,*)\n  &CMOP2 = TRANS (&CMOP2 ' ',YES YES,YES NO,NO *,*)\n  &CMOP3 = TRANS (&CMOP3 ' ',NO YES,YES NO,NO *,*)\n  IF (&CMOP4 \u00ac= ' ')\n    &CMOP4 = TRANS (&CMOP4 PRINT,' ' *,*)\n)PROC\n  VER (&DDSN1,DSNAME)\n  IF (&DVOL1 \u00ac= ' ')\n    VER (&DVOL1,NAME)\n  VER (&DDSN2,DSNAME)\n  IF (&DVOL2 \u00ac= ' ')\n    VER (&DVOL2,NAME)\n  &CMOP1 = TRUNC (&CMOP1,1)\n  &CMOP1 = TRANS (&CMOP1 N,NO Y,YES *,*)\n  VER (&CMOP1,NONBLANK)  VER (&CMOP1,LIST,NO,YES)\n  &CMOP2 = TRUNC (&CMOP2,1)\n  &CMOP2 = TRANS (&CMOP2 N,NO Y,YES *,*)\n  VER (&CMOP2,NONBLANK)  VER (&CMOP2,LIST,NO,YES)\n  &CMOP3 = TRUNC (&CMOP3,1)\n  &CMOP3 = TRANS (&CMOP3 N,NO Y,YES *,*)\n  VER (&CMOP3,NONBLANK)  VER (&CMOP3,LIST,NO,YES)\n  IF (&DDSN3 \u00ac= ' ')\n    VER (&DDSN3,DSNAME)\n    IF (&DVOL3 \u00ac= ' ')\n      VER (&DVOL3,NAME)\n  IF (&CMOP4 \u00ac= ' ')\n    VER (&CMOP4,NAME)\n  &SEL = 'CMD(%PAJCCOM) '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJCPDS": {"ttr": 24071, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x1f\\x00\\x944\\x1f\\x15D\\x001\\x001\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-07T00:00:00", "modifydate": "1994-12-07T15:44:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n/*       PRE-REQUISITE PRODUCTS : IOFSPF                             */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN EXIT\n         EUSID\n         IF &LASTCC \u00ac= 0 THEN EXIT\n         ISPEXEC VGET (ZPREFIX PDSN1 PDSN2 PDOP1 PDOP2 PDOP3)\n         IF &SUBSTR(1:1,&PDSN1) EQ &STR(') THEN DO\n           SET &LL = &LENGTH(&STR(&PDSN1)) -1\n           SET &PDSNA = &SUBSTR(2:&LL,&PDSN1)\n           END\n         ELSE DO\n           SET &PDSNA = &STR(&ZPREFIX..&PDSN1)\n           END\n         IF &SUBSTR(1:1,&PDSN2) EQ &STR(') THEN DO\n           SET &LL = &LENGTH(&STR(&PDSN2)) -1\n           SET &PDSNB = &SUBSTR(2:&LL,&PDSN2)\n           END\n         ELSE DO\n           SET &PDSNB = &STR(&ZPREFIX..&PDSN2)\n           END\n         SET &PDOPT =\n         IF &PDOP1 \u00ac= THEN SET &PDOPT = &STR(&PDOP1)\n         IF &PDOP2 \u00ac= THEN DO\n           IF &PDOPT = THEN SET &PDOPT = &STR(&PDOP2)\n           ELSE SET &PDOPT = &STR(&PDOPT &PDOP2)\n           END\n         IF &PDOP3 \u00ac= THEN DO\n           IF &PDOPT = THEN SET &PDOPT = &STR(SIZE=&PDOP3)\n           ELSE SET &PDOPT = &STR(&PDOPT SIZE=&PDOP3)\n           END\n         ISPEXEC VPUT (PDOPT PDSNA PDSNB)\n         CONTROL NOMSG\n         FREE F(SYSPO SYSSU)\n         CONTROL MSG\n         ISPEXEC FTOPEN TEMP\n         ISPEXEC FTINCL PAJSPDS\n         ISPEXEC FTCLOSE\n         ISPEXEC VGET ZTEMPF\n         ALLOC F(SYSPO) DA('&ZTEMPF')\n         INTRDR SYSSU\n         EUSUB\n         CONTROL NOMSG\n         FREE F(SYSPO SYSSU)\n         CONTROL MSG\n         SET &IOPARM = &STR(I.&EURUSID.C)\n         ISPEXEC SELECT PGM(IOFSPF) PARM(&IOPARM) NEWAPPL(IOF)\n         EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCRY": {"ttr": 24073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x15\\x8f\\x00\\x90\\x15\\x8f\\x10$\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-07T00:00:00", "modifydate": "1990-06-07T10:24:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n  # TYPE(INPUT) CAPS(OFF) INTENS(NON)\n  _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH)\n)BODY\n%CRY ---------------------- Encryption - Decryption ---------------------------+\n+\n+\n+\n+  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+  - - - - - - - - - -%Enter your secret key-value below+- - - - - - - - - - -\n+  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+  - - - - - - - - - -%unviewable entry ===>#CRYKEY1 + - - - - - - - - - - - -\n+  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+  - - - - - - - -%or, if desired, viewable entry ===>_CRYKEY2 + - - - - - - -\n+  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n)INIT\n  &CRYKEY = &Z\n  &CRYKEY1 = &Z\n  &CRYKEY2 = &Z\n)PROC\n  &CRYKSI = YES\n  IF (&CRYKEY2 \u00ac= &Z)\n    &CRYKEY = &CRYKEY2\n  IF (&CRYKEY2 = &Z)\n    IF (&CRYKEY1 \u00ac= &Z)\n      &CRYKEY = &CRYKEY1\n  IF (&CRYKEY = &Z)\n    &CRYKSI = NO\n  VPUT (CRYKSI) SHARED\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJCSEND": {"ttr": 24075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x880/\\x00\\x880/\\t\"\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-10-28T00:00:00", "modifydate": "1988-10-28T09:22:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 SNDM SNDUID SNSO SNWO\n         CONTROL MSG\n         ISPEXEC VGET (SNDM SNDUID SNSO SNWO)\n         IF &SNDUID = THEN GOTO OPER\n         IF &SNSO = THEN GOTO SNOW\n         SEND '&SNDM' USER(&SNDUID) &SNSO &SNWO\n         GOTO SEXT\nSNOW:    SEND '&SNDM' USER(&SNDUID) NOW &SNWO\n         GOTO SEXT\nOPER:    SEND '&SNDM'\nSEXT:    WRITE ** YOUR MESSAGE IS NOW BEING SENT **\n         CONTROL MSG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCSHWM": {"ttr": 24077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93#/\\x00\\x93#/\\x10%\\x00\\xcf\\x00\\xcf\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-08-20T00:00:00", "modifydate": "1993-08-20T10:25:00", "lines": 207, "newlines": 207, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n/*       PURPOSE : CLIST TO EXECUTE \"SHOWMVS\"                    (PM)*/\n/*       PRE-REQUISITE PRODUCTS : IOFSPF                             */\n/*       PRE-REQUISITE COMMANDS : AUTHC                              */\n/*                                DOCP (DOPROG)                      */\n/*                                FILEINFO                           */\n/*                                EUSID                              */\n/*                                EUSUB                              */\n/*                                INTRDR                             */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n         CONTROL MAIN NOMSG\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN DO\n           CONTROL MSG\n           EXIT CODE(16)\n           END\n         ISPEXEC CONTROL ERRORS RETURN\n         EUSID\n         SET &LSCC = &LASTCC\n         IF &LSCC NE 0 THEN DO\n           SET ZERRSM = &STR(EUSID ERROR)\n           SET ZERRLM = +\n             &STR(ENVIRONMENT VARIABLES SETTING FAILED / CC=&LSCC)\n           ISPEXEC SETMSG MSG(ISRZ002)\n           ISPEXEC CONTROL ERRORS CANCEL\n           CONTROL MSG\n           EXIT CODE(16)\n           END\n         SET &SHFLD = &Z\n         SET &SWDS = &STR(NO)\n         SET &SHENV = &STR(ISPF)\n         SET &CAPS = &STR(OFF)\n         SET &HPG = &STR(YES)\n         SET &LPG = &STR(60)\n         SET &PGN = &STR(1)\n         SET &SJCL = &Z\n         SET &SHWMDS = &Z\n         SET &DDS = &STR(OLD)\n         SET &SHCUR = &STR(CURSOR(SHENV))\n         GOTO RDSP\nMDSP:    SET &ZERRALRM = &STR(NO)\n         SET &ZERRHM = &STR(PAJTSHW0)\n         SET &SHMSG = &STR(MSG(ISRZ002))\n         GOTO DDSP\nRDSP:    SET &SHMSG = &Z\nDDSP:    SET &WWENV = &NRSTR(&SHENV)\n         SET &WWCAPS = &NRSTR(&CAPS)\n         SET &WWHPG = &NRSTR(&HPG)\n         SET &WWLPG = &NRSTR(&LPG)\n         SET &WWPGN = &NRSTR(&PGN)\n         SET &WWSJCL = &NRSTR(&SJCL)\n         SET &WWDS = &NRSTR(&SHWMDS)\n         SET &WWDDS = &NRSTR(&DDS)\nBDSP:    ISPEXEC DISPLAY PANEL(PAJSHWM) &SHMSG &SHCUR\n         SET &LSCC = &LASTCC\n         IF ((&LSCC EQ 0) AND ((&SHCM EQ CANCEL) OR (&SHCM EQ END))) +\n           THEN SET &LSCC = 8\n         IF &LSCC NE 0 THEN DO\n           IF &LSCC GT 8 THEN DO\n             SET ZERRSM = &STR(PANEL ERROR)\n             SET ZERRLM = +\n               &STR(PANEL DISPLAY FAILED / CC=&LSCC)\n             ISPEXEC SETMSG MSG(ISRZ002)\n             END\n           ELSE SET &LSCC = 0\n           ISPEXEC CONTROL ERRORS CANCEL\n           CONTROL MSG\n           EXIT CODE(&LSCC)\n           END\n         IF &SHCMD NE &Z THEN DO\n           IF &SHOPN EQ &Z THEN AUTHC &SHCMD\n           ELSE AUTHC &SHCMD &SHOPN\n           SET &SWDS = &STR(NO)\n           SET &SHCM = &Z\n           SET &SHCMD = &Z\n           SET &SHOPN = &Z\n           GOTO BDSP\n           END\n         IF ((&NRSTR(&WWENV) NE (&NRSTR(&SHENV)) OR +\n           (&NRSTR(&WWCAPS) NE (&NRSTR(&CAPS)) OR +\n           (&NRSTR(&WWHPG) NE (&NRSTR(&HPG)) OR +\n           (&NRSTR(&WWLPG) NE (&NRSTR(&LPG)) OR +\n           (&NRSTR(&WWPGN) NE (&NRSTR(&PGN)) OR +\n           (&NRSTR(&WWDS) NE (&NRSTR(&SHWMDS)) OR +\n           (&NRSTR(&WWSJCL) NE (&NRSTR(&SJCL)) OR +\n           (&NRSTR(&WWDDS) NE (&NRSTR(&DDS))) THEN DO\n           SET &SWDS = &STR(NO)\n           GOTO RDSP\n           END\n         IF &SWDS EQ &STR(NO) THEN DO\n           SET &SWDS = &STR(YES)\n           GOTO RDSP\n           END\n         SET &SWDS = &STR(NO)\n         SET &PARM = &Z\n         IF &CAPS EQ &STR(ON) THEN SET &PARM = &STR(C)\n         IF &HPG EQ &STR(NO) THEN DO\n           IF &PARM EQ &Z THEN SET &PARM = &STR(H(N))\n           ELSE SET &PARM = &STR(&PARM H(N))\n           END\n         ELSE DO\n           IF &LPG NE &STR(60) THEN DO\n             IF &PARM EQ &Z THEN SET &PARM = &STR(L(&LPG))\n             ELSE SET &PARM = &STR(&PARM L(&LPG))\n             END\n           IF &PGN NE &STR(1) THEN DO\n             IF &PARM EQ &Z THEN SET &PARM = &STR(P(&PGN))\n             ELSE SET &PARM = &STR(&PARM P(&PGN))\n             END\n           END\n         IF (&NRSTR(&SHWMDS) NE &Z) THEN DO\n           SET &SHCUR = &STR(CURSOR(SHWMDS))\n           FILEINFO DSN('&SHWMDS')\n           SET &LSCC = &LASTCC\n           IF &LSCC NE 0 THEN DO\n             SET &SWERR = &STR(YES)\n             IF &LSCC EQ 24 THEN DO\n               IF ((&MEMCNTL EQ &STR(YES) AND +\n                 (&MEMFND EQ &STR(NO)) THEN SET &SWERR = &STR(NO)\n               END\n             IF &SWERR EQ &STR(YES) THEN DO\n               SET ZERRSM = &STR(FILEINFO ERROR)\n               SET ZERRLM = +\n                 &STR(FILEINFO FAILED / CC=&LSCC / &OUTMSG)\n               GOTO MDSP\n               END\n             END\n           IF ((&DSORG NE &STR(PS)) AND (&DSORG NE &STR(PO))) THEN DO\n             SET ZERRSM = &STR(DSORG ERROR)\n             SET ZERRLM = +\n               &STR(DATA-SET DSORG=&DSORG - IT MUST BE PS OR PO)\n             GOTO MDSP\n             END\n           IF &DSORG EQ &STR(PO) THEN SET &DDS = &STR(OLD)\n           IF ((&RECFM NE &STR(F)) AND (&CNTLCHAR NE &STR(A))) THEN DO\n             SET ZERRSM = &STR(RECFM ERROR)\n             SET ZERRLM = +\n               &STR(DATA-SET RECFM=&RECFM&CNTLCHAR - IT MUST BE FA)\n             GOTO MDSP\n             END\n           IF &LRECL NE &STR(00101) THEN DO\n             SET ZERRSM = &STR(LRECL ERROR)\n             SET ZERRLM = +\n               &STR(DATA-SET LRECL=&LRECL - IT MUST BE 101)\n             GOTO MDSP\n             END\n           IF &SHENV NE &STR(BATCH) THEN DO\n             FREE F(SHOWMVS)\n             ALLOC F(SHOWMVS) DA('&SHWMDS') &DDS\n             SET &LSCC = &LASTCC\n             IF &LSCC NE 0 THEN DO\n               SET ZERRSM = &STR(ALLOC ERROR)\n               SET ZERRLM = +\n                 &STR(FILE ALLOCATION FAILED / CC=&LSCC)\n               GOTO MDSP\n               END\n             END\n           END\n         SET &SHCUR = &STR(CURSOR(SHENV))\n         IF (&SHENV NE &STR(BATCH)) THEN DO\n           IF (&SHENV EQ &STR(TSO)) THEN DO\n             IF &PARM EQ &Z THEN AUTHC SHOWMVS\n             ELSE AUTHC SHOWMVS &PARM\n             END\n           ELSE DO\n             IF &PARM EQ &Z THEN DOCP SHOWMVS 'SHOWMVS' AC\n             ELSE DOCP SHOWMVS 'SHOWMVS &PARM' AC\n             END\n           IF (&NRSTR(&SHWMDS) NE &Z) THEN FREE F(SHOWMVS)\n           ELSE DO\n             IF (&SHENV EQ &STR(TSO)) THEN DO\n               CONTROL MSG\n               SET &IOPARM = &STR(I.&EURUSID)\n               ISPEXEC CONTROL ERRORS CANCEL\n               ISPEXEC SELECT PGM(IOFSPF) PARM(&IOPARM) NEWAPPL(IOF)\n               CONTROL NOMSG\n               ISPEXEC CONTROL ERRORS RETURN\n               END\n             END\n           END\n         ELSE DO\n           ISPEXEC CONTROL ERRORS CANCEL\n           FREE F(SYSPO SYSSU)\n           CONTROL MSG\n           ISPEXEC FTOPEN TEMP\n           ISPEXEC FTINCL PAJSSHWM\n           ISPEXEC FTCLOSE\n           ISPEXEC VGET ZTEMPF\n           ALLOC F(SYSPO) DA('&ZTEMPF')\n           INTRDR SYSSU\n           EUSUB\n           CONTROL NOMSG\n           FREE F(SYSPO SYSSU)\n           CONTROL MSG\n           SET &IOPARM = &STR(I.&EURUSID.S)\n           ISPEXEC SELECT PGM(IOFSPF) PARM(&IOPARM) NEWAPPL(IOF)\n           CONTROL NOMSG\n           ISPEXEC CONTROL ERRORS RETURN\n           END\n           IF (&NRSTR(&SHWMDS) NE &Z) THEN DO\n             CONTROL MSG\n             ISPEXEC CONTROL ERRORS CANCEL\n             ISPEXEC BROWSE DATASET('&SHWMDS')\n             CONTROL NOMSG\n             ISPEXEC CONTROL ERRORS RETURN\n             END\n         GOTO RDSP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJCSLB": {"ttr": 24081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x12\\x8f\\x00\\x90\\x12\\x8f\\x11!\\x00X\\x00X\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-05-08T00:00:00", "modifydate": "1990-05-08T11:21:00", "lines": 88, "newlines": 88, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n         ISPEXEC CONTROL ERRORS RETURN\n         SET &SLBMD = NO\n         ISPEXEC VGET (SLBN1 SLBN2 SLBN3 SLBN4 SLBN5 SLBN6 SLBN7 +\n           SLBN8 SLBN9 SLBN10 SLBN11) PROFILE\n         SET &SLBNME = &SLBN1\nSLB1:    SET &SLBCC =\n         SET &SLBEN =\nSLB2:    IF &SLBNME = &SLBN1 THEN SET &SLBCS = 1\n         ELSE IF &SLBNME = &SLBN2 THEN SET &SLBCS = 2\n         ELSE IF &SLBNME = &SLBN3 THEN SET &SLBCS = 3\n         ELSE IF &SLBNME = &SLBN4 THEN SET &SLBCS = 4\n         ELSE IF &SLBNME = &SLBN5 THEN SET &SLBCS = 5\n         ELSE IF &SLBNME = &SLBN6 THEN SET &SLBCS = 6\n         ELSE IF &SLBNME = &SLBN7 THEN SET &SLBCS = 7\n         ELSE IF &SLBNME = &SLBN8 THEN SET &SLBCS = 8\n         ELSE IF &SLBNME = &SLBN9 THEN SET &SLBCS = 9\n         ELSE IF &SLBNME = &SLBN10 THEN SET &SLBCS = 10\n         ELSE IF &SLBNME = &SLBN11 THEN SET &SLBCS = 11\n         ELSE IF &SLBNME = &SLBNN THEN SET &SLBCS = N\n         ELSE SET &SLBCS = 1\nSLB3:    SET &SLBPN1 = &SLBN1\n         SET &SLBPN2 = &SLBN2\n         SET &SLBPN3 = &SLBN3\n         SET &SLBPN4 = &SLBN4\n         SET &SLBPN5 = &SLBN5\n         SET &SLBPN6 = &SLBN6\n         SET &SLBPN7 = &SLBN7\n         SET &SLBPN8 = &SLBN8\n         SET &SLBPN9 = &SLBN9\n         SET &SLBPN10 = &SLBN10\n         SET &SLBPN11 = &SLBN11\n         SET &SLBPNN = &SLBNN\n         ISPEXEC DISPLAY PANEL(PAJSLB)\n         SET &SLBCC = &LASTCC\n         IF &SLBCC = 8 THEN GOTO SLB99\n         IF &SLBCC \u00ac= 0 THEN GOTO SLB10\n         IF &SLBPN1 \u00ac= &SLBN1 THEN SET &SLBNME = &SLBN1\n         ELSE IF &SLBPN2 \u00ac= &SLBN2 THEN SET &SLBNME = &SLBN2\n         ELSE IF &SLBPN3 \u00ac= &SLBN3 THEN SET &SLBNME = &SLBN3\n         ELSE IF &SLBPN4 \u00ac= &SLBN4 THEN SET &SLBNME = &SLBN4\n         ELSE IF &SLBPN5 \u00ac= &SLBN5 THEN SET &SLBNME = &SLBN5\n         ELSE IF &SLBPN6 \u00ac= &SLBN6 THEN SET &SLBNME = &SLBN6\n         ELSE IF &SLBPN7 \u00ac= &SLBN7 THEN SET &SLBNME = &SLBN7\n         ELSE IF &SLBPN8 \u00ac= &SLBN8 THEN SET &SLBNME = &SLBN8\n         ELSE IF &SLBPN9 \u00ac= &SLBN9 THEN SET &SLBNME = &SLBN9\n         ELSE IF &SLBPN10 \u00ac= &SLBN10 THEN SET &SLBNME = &SLBN10\n         ELSE IF &SLBPN11 \u00ac= &SLBN11 THEN SET &SLBNME = &SLBN11\n         ELSE IF &SLBNN = THEN DO\n           ISPEXEC SELECT PGM(ISPCDSN) PARM(SLBNME)\n           SET &SLBCC = &LASTCC\n           IF &SLBCC NE 0 THEN GOTO SLB11\n           ISPEXEC VGET (SLBNME) SHARED\n           END\n         ELSE SET &SLBNME = &SLBNN\n         IF &SLBMD = YES THEN GOTO SLB4\n         ISPEXEC BROWSE DATASET(&SLBNME)\n         SET &SLBCC = &LASTCC\n         IF &SLBCC NE 0 THEN GOTO SLB12\n         GOTO SLB1\nSLB4:    ISPEXEC EDIT DATASET(&SLBNME)\n         SET &SLBCC = &LASTCC\n         IF &SLBCC GT 4 THEN GOTO SLB13\n         GOTO SLB1\nSLB10:   SET &SLBEN = DISPLAY\n         GOTO SLB2\nSLB11:   SET &SLBEN = ISPCDSN\n         IF &SLBPN1 \u00ac= &SLBN1 THEN SET &SLBCS = 1\n         ELSE IF &SLBPN2 \u00ac= &SLBN2 THEN SET &SLBCS = 2\n         ELSE IF &SLBPN3 \u00ac= &SLBN3 THEN SET &SLBCS = 3\n         ELSE IF &SLBPN4 \u00ac= &SLBN4 THEN SET &SLBCS = 4\n         ELSE IF &SLBPN5 \u00ac= &SLBN5 THEN SET &SLBCS = 5\n         ELSE IF &SLBPN6 \u00ac= &SLBN6 THEN SET &SLBCS = 6\n         ELSE IF &SLBPN7 \u00ac= &SLBN7 THEN SET &SLBCS = 7\n         ELSE IF &SLBPN8 \u00ac= &SLBN8 THEN SET &SLBCS = 8\n         ELSE IF &SLBPN9 \u00ac= &SLBN9 THEN SET &SLBCS = 9\n         ELSE IF &SLBPN10 \u00ac= &SLBN10 THEN SET &SLBCS = 10\n         ELSE IF &SLBPN11 \u00ac= &SLBN11 THEN SET &SLBCS = 11\n         ELSE IF &SLBPNN \u00ac= &SLBNN THEN SET &SLBCS = N\n         ELSE SET &SLBCS = 1\n         GOTO SLB3\nSLB12:   SET &SLBEN = BROWSE\n         GOTO SLB2\nSLB13:   SET &SLBEN = EDIT\n         GOTO SLB2\nSLB99:   ISPEXEC VPUT (SLBN1 SLBN2 SLBN3 SLBN4 SLBN5 SLBN6 SLBN7 +\n           SLBN8 SLBN9 SLBN10 SLBN11) PROFILE\n         ISPEXEC CONTROL ERRORS CANCEL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCSM": {"ttr": 24084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x15Q\\x01\\xc9\\x01\\xc9\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T15:51:00", "lines": 457, "newlines": 457, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 SMID() SMDSG(SPF) SMDST(PROF) SMMEM(SM$PROF) SMTEST()\n         CONTROL MAIN NOMSG\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN DO\n           WRITE *** NOT AVAILABLE OUTSIDE ISPF ***\n           EXIT CODE(0)\n           END\n         IF &SUBSTR(1:3,&SYSUID) NE SYS AND +\n           &SUBSTR(1:3,&SYSUID) NE S32 THEN DO\n             ISPEXEC SETMSG MSG(PAJS000X)\n             EXIT CODE(0)\n             END\n         IF &SMTEST EQ TEST THEN CONTROL LIST CONLIST SYMLIST MSG\n         IF &SMID EQ THEN DO\n           SET &SMSWU = YES\n           SET &SMSWC = NO\n           SET &SMID = &SYSUID\n           END\n         ELSE SET &SMSWU = NO\n         SET &SMSWT = NO\n         SET &SMSWM = NO\n         ISPEXEC CONTROL ERRORS RETURN\n         IF &SMSWU EQ YES THEN -\n         ISPEXEC LMINIT DATAID(SMFIN) -\n           DATASET('&SMID..&SMDSG..&SMDST') ENQ(EXCLU)\n         ELSE ISPEXEC LMINIT DATAID(SMFIN) -\n           DATASET('&SMID..&SMDSG..&SMDST')\n         SET &RC = &LASTCC\n         IF &RC NE 0 THEN DO\n           IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS001A)\n           ELSE ISPEXEC SETMSG MSG(PAJS002A)\n           SET &SMSWM = YES\n           GOTO ERIFI\n           END\n         ISPEXEC LMOPEN DATAID(&SMFIN)\n         SET &RC = &LASTCC\n         IF &RC NE 0 THEN DO\n           IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS001B)\n           ELSE ISPEXEC SETMSG MSG(PAJS002B)\n           SET &SMSWM = YES\n           GOTO EROFI\n           END\n         ISPEXEC LMMFIND DATAID(&SMFIN) MEMBER(&SMMEM)\n         SET &RC = &LASTCC\n         IF &SMSWU EQ YES THEN DO\n           IF &RC EQ 8 THEN DO\n             SET &SMSWC = YES\n             GOTO ERFFI\n             END\n           ELSE IF &RC EQ 4 THEN DO\n             ISPEXEC SETMSG MSG(PAJS002C)\n             SET &SMSWM = YES\n             GOTO ERFFI\n             END\n           END\n         IF &RC NE 0 THEN DO\n           IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS001D)\n           ELSE ISPEXEC SETMSG MSG(PAJS002D)\n           SET &SMSWM = YES\n           GOTO ERFFI\n           END\n         ISPEXEC TBCREATE SMTABLE REPLACE NOWRITE NAMES(SMAROU)\n         CONTROL ASIS\nGETFI:   ISPEXEC LMGET DATAID(&SMFIN) MODE(INVAR) +\n           DATALOC(SMARIN) DATALEN(SMALIN) MAXLEN(80)\n         SET &RC = &LASTCC\n         IF &RC EQ 8 THEN GOTO EOFFI\n         IF &RC NE 0 THEN DO\n           IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS001E)\n           ELSE ISPEXEC SETMSG MSG(PAJS002E)\n           SET &SMSWM = YES\n           SET &SMSWT = NO\n           GOTO EOFFI\n           END\n         SET &SMARLIN = &LENGTH(&STR(&SMARIN))\n         IF &SMARLIN GE 11 THEN DO\n           SET &SMTT = &SUBSTR(1:11,&SMARIN)\n           IF &SMSWU EQ NO THEN DO\n             IF &STR(&SMTT) EQ &STR(STOP       ) THEN GOTO EOFFI\n             END\n           IF &SMSWU EQ YES THEN DO\n             IF &STR(&SMTT) EQ &STR(Aggiornato ) THEN GOTO GETFI\n             IF &STR(&SMTT) EQ &STR(Ajourn! au ) THEN GOTO GETFI\n             IF &STR(&SMTT) EQ &STR(Updated on ) THEN GOTO GETFI\n             END\n           END\n         IF &SMARLIN GT 72 THEN SET &SMARLIN = 72\n         SET &SMAROU = &STR(&SUBSTR(1:&SMARLIN,&SMARIN))\n         ISPEXEC TBADD SMTABLE\n         SET &SMSWT = YES\n         GOTO GETFI\nEOFFI:   CONTROL CAPS\nERFFI:   ISPEXEC LMCLOSE DATAID(&SMFIN)\n         SET &RC = &LASTCC\n         IF &RC NE 0 THEN DO\n           IF &SMSWM EQ NO THEN DO\n             IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS001F)\n             ELSE ISPEXEC SETMSG MSG(PAJS002F)\n             SET &SMSWM = YES\n             END\n           END\n         IF &SMSWU EQ NO THEN GOTO EROFI\n         IF &SMSWC EQ YES THEN GOTO UPDFI\n         IF &SMSWT EQ YES THEN GOTO UPDFI\nEROFI:   ISPEXEC LMFREE DATAID(&SMFIN)\n         SET &RC = &LASTCC\n         IF &RC NE 0 THEN DO\n           IF &SMSWM EQ NO THEN DO\n             IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS001G)\n             ELSE ISPEXEC SETMSG MSG(PAJS002G)\n             SET &SMSWM = YES\n             END\n           END\n         IF &SMSWT EQ NO THEN GOTO ENDTB\n         ISPEXEC TBTOP SMTABLE\nDSTSC:   ISPEXEC TBDISPL SMTABLE PANEL(PAJSM1) POSITION(CRP)\n         SET &RC = &LASTCC\n         IF &RC LE 4 THEN GOTO DSTSC\n         IF &RC NE 8 THEN DO\n           IF &SMSWM EQ NO THEN DO\n             IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS001H)\n             END\n           END\nENDTB:   ISPEXEC TBEND SMTABLE\nERIFI:   ISPEXEC CONTROL ERRORS CANCEL\n         IF &SMSWM EQ NO THEN ISPEXEC SETMSG MSG(PAJS009A)\n         EXIT CODE(0)\nUPDFI:   CONTROL ASIS\n         IF &SMSWC EQ YES THEN DO\n           SET &SMTIT = &STR(Create)\n           ISPEXEC TBCREATE SMTABLE REPLACE NOWRITE NAMES(SMAROU)\n           SET &SMAROU = &STR( )\n           ISPEXEC TBADD SMTABLE\n           END\n         ELSE SET &SMTIT = &STR(Update)\n         ISPEXEC VPUT (SMTIT SMID)\n         ISPEXEC VGET (SMLANG) PROFILE\n         SET &RC = 0\n         SET &ZTDTOP = 0\nULOOP:   IF &RC EQ 4 THEN ISPEXEC TBDISPL SMTABLE POSITION(CRP)\n         ELSE DO\n           ISPEXEC TBTOP SMTABLE\n           ISPEXEC TBSKIP SMTABLE NUMBER(&ZTDTOP)\n           ISPEXEC VGET (ZVERB ZSCROLLN)\n           IF &ZVERB EQ UP THEN -\n             ISPEXEC TBSKIP SMTABLE NUMBER(-&ZSCROLLN)\n           ELSE IF &ZVERB EQ DOWN THEN -\n             ISPEXEC TBSKIP SMTABLE NUMBER(&ZSCROLLN)\n           ISPEXEC TBDISPL SMTABLE PANEL(PAJSM2) POSITION(CRP)\n           END\n         SET &RC = &LASTCC\n         IF &RC GT 8 THEN DO\n           ISPEXEC SETMSG MSG(PAJS009B)\n           SET &SMSWM = YES\n           GOTO XLOOP\n           END\n         ELSE IF &RC EQ 8 OR &CMD EQ SAVE THEN GOTO TSAVE\n         ELSE IF &CMD EQ CANCEL THEN DO\n           ISPEXEC SETMSG MSG(PAJS009C)\n           SET &SMSWM = YES\n           GOTO XLOOP\n           END\n         ELSE IF &ZTDSELS GE 1 THEN DO\n           IF &SMA EQ A OR &SMA EQ B THEN DO\n             SET &HIGH = &MM*9\n             SET &LOW = &HIGH-8\n             IF &SMLANG EQ I THEN DO\n               SET &GN = &STR(Gennaio  Febbraio Marzo    Aprile   )\n               SET &GN = &GN&STR(Maggio   Giugno   Luglio   Agosto   )\n               SET &GN = &GN&STR(SettembreOttobre  Novembre Dicembre )\n               END\n             ELSE IF &SMLANG EQ F THEN DO\n               SET &GN = &STR(Janvier  Fevrier  Mars     Avril    )\n               SET &GN = &GN&STR(Mai      Juin     Juillet  Aout     )\n               SET &GN = &GN&STR(SeptembreOctobre  Novembre D!cembre )\n               END\n             ELSE DO\n               SET &GN = &STR(January  February March    April    )\n               SET &GN = &GN&STR(May      June     July     August   )\n               SET &GN = &GN&STR(SeptemberOctober  November December )\n               END\n             SET &MONTH = &SUBSTR(&LOW:&HIGH,&GN)\n             SET &MONTH = &MONTH          /* TO LOSE TRAILING BLANKS */\n             SET &ISEC = 1900\n             IF &AA = 0 THEN SET &ISEC = 2000\n             SET &AA1 = &AA+&ISEC\n             SET &N0 = ((&AA1/4)*4)\n             SET &N2 = &MM*2\n             SET &N1 = &N2-1\n             IF &AA1 EQ &N0 THEN -\n               SET &GGT = &SUBSTR(&N1:&N2,312931303130313130313031)\n             ELSE SET &GGT = &SUBSTR(&N1:&N2,312831303130313130313031)\n             IF &GG GT &GGT THEN DO\n               ISPEXEC SETMSG MSG(PAJS000Y)\n               GOTO ULOOP\n               END\n             SET &MM1 = &SUBSTR(&MM,032503514624)\n             SET &GGX = &GG+&MM1\n             SET &AA2 = ((&AA1*100)+&MM-3)/100\n             SET &N0 = &AA2/100\n             SET &N01 = &AA2//100\n             SET &N1 = &N0//4\n             SET &N2 = &N01//4\n             SET &N4 = &N01/4 +&N1\n             SET &N7 = &GGX+&N2+&N4*5\n             SET &N8 = &N7//7        /* DAY NUMBER, WHERE SUNDAY = 0 */\n             SET &LOW = &N8*10+1\n             SET &HIGH = &LOW+9\n             IF &SMLANG EQ I THEN DO\n               SET &GN = &STR(Domenica  Lunedi'   Martedi'  Mercoledi')\n               SET &GN = &GN&STR(Giovedi'  Venerdi'  Sabato    )\n               END\n             ELSE IF &SMLANG EQ F THEN DO\n               SET &GN = &STR(Dimanche  Lundi     Mardi     Mercredi  )\n               SET &GN = &GN&STR(Jeudi     Vendredi  Samedi    )\n               END\n             ELSE DO\n               SET &GN = &STR(Sunday    Monday    Tuesday   Wenesday  )\n               SET &GN = &GN&STR(Thursday  Friday    Saterday  )\n               END\n             SET &SMD = &SUBSTR(&LOW:&HIGH,&GN)\n             SET &SMD = &SMD              /* TO LOSE TRAILING BLANKS */\n             IF &SUBSTR(1,&GG) \u00ac= 0 THEN DO\n               IF &LENGTH(&GG) = 1 THEN SET &GG = &STR(0&GG)\n               END\n             IF &SUBSTR(1,&MM) \u00ac= 0 THEN DO\n               IF &LENGTH(&MM) = 1 THEN SET &MM = &STR(0&MM)\n               END\n             IF &SUBSTR(1,&AA) \u00ac= 0 THEN DO\n               IF &LENGTH(&AA) = 1 THEN SET &AA = &STR(0&AA)\n               END\n             SET &SMAROU = &STR(--- &SMD &GG &MONTH &AA1 :)\n             IF &SMA EQ B THEN ISPEXEC TBSKIP SMTABLE NUMBER(-1)\n             ISPEXEC TBADD SMTABLE\n             END\n           ELSE IF &SMA EQ D THEN DO\n             DO WHILE &SMN GE 1\n               ISPEXEC TBDELETE SMTABLE\n               ISPEXEC TBSKIP SMTABLE\n               IF &LASTCC NE 0 THEN SET &SMN = 0\n               ELSE SET &SMN = &SMN - 1\n               END\n             END\n           ELSE IF &SMA EQ I THEN DO\n             DO WHILE &SMN GE 1\n               SET &SMAROU = &STR( )\n               ISPEXEC TBADD SMTABLE\n               SET &SMN = &SMN - 1\n               END\n             END\n           ELSE IF &SMA EQ R THEN DO\n             DO WHILE &SMN GE 1\n               ISPEXEC TBADD SMTABLE\n               SET &SMN = &SMN - 1\n               END\n             END\n           ELSE IF &SMA EQ S THEN DO\n             SET &SMAROU = &STR(STOP       )\n             ISPEXEC TBADD SMTABLE\n             END\n           ELSE IF &SMA EQ &STR( ) THEN ISPEXEC TBPUT SMTABLE\n           END\n         GOTO ULOOP\nTSAVE:   SET &GG = &SUBSTR(4:5,&SYSDATE)\n         SET &MM = &SUBSTR(1:2,&SYSDATE)\n         SET &AA = &SUBSTR(7:8,&SYSDATE)\n         SET &ISEC = 1900\n         IF &AA = 0 THEN SET &ISEC = 2000\n         SET &MM1 = &SUBSTR(&MM,032503514624)\n         SET &GGX = &GG+&MM1\n         SET &AA1 = &AA+&ISEC\n         SET &AA2 = ((&AA1*100)+&MM-3)/100\n         SET &N0 = &AA2/100\n         SET &N01 = &AA2//100\n         SET &N1 = &N0//4\n         SET &N2 = &N01//4\n         SET &N4 = &N01/4 +&N1\n         SET &N7 = &GGX+&N2+&N4*5\n         SET &N8 = &N7//7            /* DAY NUMBER, WHERE SUNDAY = 0 */\n         SET &LOW = &N8*10+1\n         SET &HIGH = &LOW+9\n         IF &SMLANG EQ I THEN DO\n           SET &GN = &STR(Domenica  Lunedi'   Martedi'  Mercoledi')\n           SET &GN = &GN&STR(Giovedi'  Venerdi'  Sabato    )\n           END\n         ELSE IF &SMLANG EQ F THEN DO\n           SET &GN = &STR(Dimanche  Lundi     Mardi     Mercredi  )\n           SET &GN = &GN&STR(Jeudi     Vendredi  Samedi    )\n           END\n         ELSE DO\n           SET &GN = &STR(Sunday    Monday    Tuesday   Wenesday  )\n           SET &GN = &GN&STR(Thursday  Friday    Saterday  )\n           END\n         SET &SMD = &SUBSTR(&LOW:&HIGH,&GN)\n         SET &SMD = &SMD                  /* TO LOSE TRAILING BLANKS */\n         SET &HIGH = &MM*9\n         SET &LOW = &HIGH-8\n         IF &SMLANG EQ I THEN DO\n           SET &GN = &STR(Gennaio  Febbraio Marzo    Aprile   )\n           SET &GN = &GN&STR(Maggio   Giugno   Luglio   Agosto   )\n           SET &GN = &GN&STR(SettembreOttobre  Novembre Dicembre )\n           END\n         ELSE IF &SMLANG EQ F THEN DO\n           SET &GN = &STR(Janvier  Fevrier  Mars     Avril    )\n           SET &GN = &GN&STR(Mai      Juin     Juillet  Aout     )\n           SET &GN = &GN&STR(SeptembreOctobre  Novembre D!cembre )\n           END\n         ELSE DO\n           SET &GN = &STR(January  February March    April    )\n           SET &GN = &GN&STR(May      June     July     August   )\n           SET &GN = &GN&STR(SeptemberOctober  November December )\n           END\n         SET &MONTH = &SUBSTR(&LOW:&HIGH,&GN)\n         SET &MONTH = &MONTH              /* TO LOSE TRAILING BLANKS */\n         IF &SUBSTR(1,&GG) \u00ac= 0 THEN DO\n           IF &LENGTH(&GG) = 1 THEN SET &GG = &STR(0&GG)\n           END\n         IF &SUBSTR(1,&MM) \u00ac= 0 THEN DO\n           IF &LENGTH(&MM) = 1 THEN SET &MM = &STR(0&MM)\n           END\n         IF &SUBSTR(1,&AA) \u00ac= 0 THEN DO\n           IF &LENGTH(&AA) = 1 THEN SET &AA = &STR(0&AA)\n           END\n         SET &SMO = &SUBSTR(1:5,&SYSTIME)\n         IF &SMLANG EQ I THEN DO\n         SET &SMUPDT = &STR(Aggiornato &SMD &GG &MONTH &AA1 ore &SMO..)\n           END\n         ELSE IF &SMLANG EQ F THEN DO\n         SET &SMUPDT = &STR(Ajourn! au &SMD &GG &MONTH &AA1 { &SMO..)\n           END\n         ELSE DO\n         SET &SMUPDT = &STR(Updated on &SMD &GG &MONTH &AA1 at &SMO..)\n           END\n         SET &SMSWI = NO\n         ISPEXEC LMOPEN DATAID(&SMFIN) OPTION(OUTPUT)\n         SET &RC = &LASTCC\n         IF &RC NE 0 THEN DO\n           IF &SMTEST EQ TEST THEN DO\n             WRITE *** OPEN ERROR - RC=&RC ***\n             WRITE &ZERRLM\n             END\n           ELSE WRITE \"&SMID\" communication cannot be saved\n           GOTO XLOOP\n           END\n         SET &SMSWW = NO\n         ISPEXEC TBTOP SMTABLE\nWLOOP:   ISPEXEC TBSKIP SMTABLE NUMBER(+1)\n         SET &RC = &LASTCC\n         IF &RC NE 0 THEN GOTO WLEND\n         ISPEXEC TBGET SMTABLE\n         SET &RC = &LASTCC\n         IF &RC GT 4 THEN DO\n           IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS003A)\n           ELSE ISPEXEC SETMSG MSG(PAJS004A)\n           SET &SMSWM = YES\n           GOTO WRCLS\n           END\n         SET &SMSWW = YES\n         IF &SMSWI EQ NO THEN DO\n           SET &SMARLOU = &LENGTH(&STR(&SMAROU))\n           IF &SMARLOU GE 11 THEN DO\n             SET &SMTT = &SUBSTR(1:11,&SMAROU)\n             IF &STR(&SMTT) EQ &STR(STOP       ) THEN DO\n               SET &SMARIN = &STR(&SMUPDT)\n               ISPEXEC LMPUT DATAID(&SMFIN) MODE(INVAR) +\n                 DATALOC(SMARIN) DATALEN(80) NOBSCAN\n               SET &RC = &LASTCC\n               IF &RC NE 0 THEN DO\n                 IF &SMSWM EQ NO THEN DO\n                   IF &SMTEST EQ TEST THEN -\n                     ISPEXEC SETMSG MSG(PAJS003B)\n                   ELSE ISPEXEC SETMSG MSG(PAJS004B)\n                   SET &SMSWM = YES\n                   END\n                 GOTO WRCLS\n                 END\n               SET &SMSWI = YES\n               END\n             END\n           END\n         SET &SMARIN = &STR(&SMAROU)\n         ISPEXEC LMPUT DATAID(&SMFIN) MODE(INVAR) +\n           DATALOC(SMARIN) DATALEN(80) NOBSCAN\n         SET &RC = &LASTCC\n         IF &RC EQ 0 THEN GOTO WLOOP\n         IF &SMSWM EQ NO THEN DO\n           IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS003B)\n           ELSE ISPEXEC SETMSG MSG(PAJS004B)\n           SET &SMSWM = YES\n           END\n         GOTO WRCLS\nWLEND:   IF &RC GT 8 THEN DO\n           IF &SMSWM EQ NO THEN DO\n             IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS003C)\n             ELSE ISPEXEC SETMSG MSG(PAJS004C)\n             SET &SMSWM = YES\n             END\n           GOTO WRCLS\n           END\n         IF &SMSWW EQ NO THEN DO\n           IF &SMSWC EQ NO THEN DO\n             ISPEXEC LMMDEL DATAID(&SMFIN) MEMBER(&SMMEM)\n             SET &RC = &LASTCC\n             IF &RC EQ 0 THEN ISPEXEC SETMSG MSG(PAJS009D)\n             ELSE IF &SMSWM EQ NO THEN DO\n               IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS003D)\n               ELSE ISPEXEC SETMSG MSG(PAJS004D)\n               END\n             END\n           ELSE ISPEXEC SETMSG MSG(PAJS009E)\n           SET &SMSWM = YES\n           GOTO WRCLS\n           END\n         IF &SMSWI EQ NO THEN DO\n           SET &SMARIN = &STR(&SMUPDT)\n           ISPEXEC LMPUT DATAID(&SMFIN) MODE(INVAR) +\n             DATALOC(SMARIN) DATALEN(80) NOBSCAN\n           SET &RC = &LASTCC\n           IF &RC NE 0 THEN DO\n             IF &SMSWM EQ NO THEN DO\n               IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS003B)\n               ELSE ISPEXEC SETMSG MSG(PAJS004B)\n               SET &SMSWM = YES\n               END\n             GOTO WRCLS\n             END\n           END\n         IF &SMSWC EQ YES THEN -\n           ISPEXEC LMMADD DATAID(&SMFIN) MEMBER(&SMMEM)\n         ELSE ISPEXEC LMMREP DATAID(&SMFIN) MEMBER(&SMMEM)\n         SET &RC = &LASTCC\n         IF &RC EQ 0 THEN GOTO WRCLS\n         ELSE IF &SMSWM EQ NO THEN DO\n           IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS003E)\n           ELSE ISPEXEC SETMSG MSG(PAJS004E)\n           SET &SMSWM = YES\n           END\nWRCLS:   ISPEXEC LMCLOSE DATAID(&SMFIN)\n         SET &RC = &LASTCC\n         IF &RC NE 0 THEN DO\n           IF &SMSWM EQ NO THEN DO\n             IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS003F)\n             SET &SMSWM = YES\n             END\n           END\nXLOOP:   CONTROL CAPS\n         ISPEXEC LMFREE DATAID(&SMFIN)\n         SET &RC = &LASTCC\n         IF &RC NE 0 THEN DO\n           IF &SMSWM EQ NO THEN DO\n             IF &SMTEST EQ TEST THEN ISPEXEC SETMSG MSG(PAJS003G)\n             SET &SMSWM = YES\n             END\n           END\n         ISPEXEC TBEND SMTABLE\n         ISPEXEC CONTROL ERRORS CANCEL\n         IF &SMSWM EQ NO THEN ISPEXEC SETMSG MSG(PAJS009F)\n         EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJCSSF": {"ttr": 24328, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"O\\x00\\x94\"O\\x143\\x00\\xa4\\x00\\xa4\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-12T00:00:00", "modifydate": "1994-08-12T14:33:00", "lines": 164, "newlines": 164, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 DEBUG(NONE)\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n/*       PURPOSE : CLIST TO CREATE JCL TO RUN OPTION 3.14 SEARCH-FOR */\n/*                 IN BATCH                                          */\n/*        AUTHOR : J. KALINICH, X4521                                */\n/*    CBT ORIGIN : EXTRACTED FROM CBT TAPE 94 APR, FILE 078 (SUPERC) */\n/*    ADAPTED BY : MOINIL P.A.                                       */\n/*                 PRE-REQUISITE PRODUCTS : IOFSPF                   */\n/*                 PRE-REQUISITE COMMANDS : EUSID                    */\n/*                                          EUSUB                    */\n/*                                          INTRDR                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n         CONTROL MAIN NOMSG\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN DO\n           CONTROL MSG\n           EXIT CODE(16)\n           END\n         IF &STR(&DEBUG) EQ &STR(DEBUG) THEN +\n           CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT\n         ELSE CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST\n         IF (&STR(&DEBUG) NE &STR(SCAN)) AND +\n           (&STR(&DEBUG) NE &STR(COPY)) THEN SET DEBUG = &Z\n         ISPEXEC CONTROL ERRORS RETURN\n/*                 ASK BATCH JOB RUNNING VALUES :                    */\n/*                 CPU TIME, I/O TIME AND LINES                      */\n         SET EUNMN = &Z\n         SET EUNSC = &Z\n         SET EUNIO = &Z\n         SET EUNLN = &Z\n         SET EUIOF = &Z\n         SET RCC = 0\n         DO WHILE &RCC LT 8\n           ISPEXEC DISPLAY PANEL(PAJSSF)\n           SET RCC = &LASTCC\n           IF &RCC GT 8 THEN DO\n             SET ZERRSM = &STR(DISPLAY ERROR)\n             SET ZERRLM = &STR(DISPLAY PANEL \"PAJSSF\" FAILED +\n                               / RC=&RCC)\n             ISPEXEC SETMSG MSG(ISRZ002)\n             ISPEXEC CONTROL ERRORS CANCEL\n             EXIT CODE(20)\n             END\n           END\n         IF &EUNMN NE 0 AND &EUNSC NE 0 THEN +\n           SET EUCPU = &STR(&EUNMN,&EUNSC)\n         ELSE IF &EUNMN EQ 0 THEN SET EUCPU = &STR(,&EUNSC)\n         ELSE SET EUCPU = &STR(&EUNMN)\n         SET EUIO = &STR(&EUNIO)\n         SET EULINES = &STR(&EUNLN)\n/*                 GET TSO CLIST VARIABLES OF CURRENT ENVIRONMENT    */\n         EUSID\n         SET RCC = &LASTCC\n         IF &RCC NE 0 THEN DO\n           SET ZERRSM = &STR(EUSID ERROR)\n           SET ZERRLM = &STR(GET TSO CLIST VARIABLES \"EUSID\" FAILED +\n                             / RC=&RCC)\n           ISPEXEC SETMSG MSG(ISRZ002)\n           ISPEXEC CONTROL ERRORS CANCEL\n           EXIT CODE(20)\n           END\nBACK:    ISPEXEC DISPLAY PANEL(ISRSFSPR)\n         SET RCC = &LASTCC\n         IF &RCC EQ 8 THEN EXIT CODE(8)\n         ELSE IF &RCC GT 8 THEN DO\n           SET ZERRSM = &STR(DISPLAY ERROR)\n           SET ZERRLM = &STR(DISPLAY PANEL \"ISRSFSPR\" FAILED +\n                             / RC=&RCC)\n           ISPEXEC SETMSG MSG(ISRZ002)\n           ISPEXEC CONTROL ERRORS CANCEL\n           EXIT CODE(20)\n           END\n         IF &STR(&ZSSFNDSN) EQ &Z THEN +\n           SET NEWDD = &ZSSFNPRJ..&ZSSFNGR1..&ZSSFNTYP\n         ELSE DO\n           IF &SUBSTR(1:1,&ZSSFNDSN) EQ &STR(') THEN +\n             SET NEWDD = &STR(&ZSSFNDSN)\n           ELSE SET NEWDD = &STR(&SYSUID..&ZSSFNDSN)\n/*                 STRIP OUT (*) IF ENTERED WITH OTHER DSNAME        */\n           IF &SUBSTR(&LENGTH(&STR(&NEWDD))-3:+\n             &LENGTH(&STR(&NEWDD)),&STR(&NEWDD)) EQ &STR((*)') THEN +\n             SET NEWDD = &SUBSTR(2:&LENGTH(&STR(&NEWDD))-4,&STR(&NEWDD))\n           IF &SUBSTR(&LENGTH(&STR(&NEWDD))-2:+\n             &LENGTH(&STR(&NEWDD)),&STR(&NEWDD)) EQ &STR((*)) THEN +\n             SET NEWDD = &SUBSTR(1:&LENGTH(&STR(&NEWDD))-3,&STR(&NEWDD))\n           END\n         IF &ZSSFNVOL EQ &Z THEN SET NEWVOL = &Z\n         ELSE SET NEWVOL = &STR(,VOL=SER=&ZSSFNVOL,UNIT=SYSALLDA)\n         IF &ZSSFMULT EQ &STR(YES) THEN DO\n           ISPEXEC DISPLAY PANEL(ISRSFSST)\n           SET RCC = &LASTCC\n           IF &RCC EQ 8 THEN GOTO BACK\n           ELSE IF &RCC GT 8 THEN DO\n             SET ZERRSM = &STR(DISPLAY ERROR)\n             SET ZERRLM = &STR(DISPLAY PANEL \"ISRSFSST\" FAILED +\n                               / RC=&RCC)\n             ISPEXEC SETMSG MSG(ISRZ002)\n             ISPEXEC CONTROL ERRORS CANCEL\n             EXIT CODE(20)\n             END\n           END\n         SET I = 1\n         DO WHILE &I LE 10\n           SET SRCH&I = &Z\n           SET SFS = &&ZSSFS&I\n           IF &STR(&SFS) NE &STR() THEN DO\n             IF &SUBSTR(1:1,&STR(&SFS)) NE &STR(') THEN DO\n               IF &LENGTH(&STR(&SFS)) GT 5 THEN DO\n                 IF &SUBSTR(&LENGTH(&STR(&SFS))-4:+\n                  &LENGTH(&STR(&SFS)),&STR(&SFS)) EQ &STR( WORD) THEN +\n                  SET SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-3,&STR(&SFS))\n                 END\n               IF &LENGTH(&STR(&SFS)) GT 7 THEN DO\n                 IF &SUBSTR(&LENGTH(&STR(&SFS))-6:+\n                 &LENGTH(&STR(&SFS)),&STR(&SFS)) EQ &STR( PREFIX) THEN +\n                  SET SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-5,&STR(&SFS))\n                 END\n               IF &LENGTH(&STR(&SFS)) GT 7 THEN DO\n                 IF &SUBSTR(&LENGTH(&STR(&SFS))-6:+\n                 &LENGTH(&STR(&SFS)),&STR(&SFS)) EQ &STR( SUFFIX) THEN +\n                  SET SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-5,&STR(&SFS))\n                 END\n               IF &SUBSTR(&LENGTH(&STR(&SFS))-1:+\n                 &LENGTH(&STR(&SFS)),&STR(&SFS)) EQ &STR( C) OR +\n                 &SUBSTR(&LENGTH(&STR(&SFS))-1:+\n                 &LENGTH(&STR(&SFS)),&STR(&SFS)) EQ &STR( P) OR +\n                 &SUBSTR(&LENGTH(&STR(&SFS))-1:+\n                 &LENGTH(&STR(&SFS)),&STR(&SFS)) EQ &STR( S) OR +\n                 &SUBSTR(&LENGTH(&STR(&SFS))-1:+\n                 &LENGTH(&STR(&SFS)),&STR(&SFS)) EQ &STR( W) THEN DO\n                 SET SFS = &STR(')+\n                   &SUBSTR(1:&LENGTH(&STR(&SFS))-2,&STR(&SFS))+\n                   &STR(',)&SUBSTR(&LENGTH(&STR(&SFS)),&STR(&SFS))\n                 END\n               ELSE SET SFS = &STR('&STR(&SFS)')\n               END\n             IF &SUBSTR(&LENGTH(&STR(&SFS)),&STR(&SFS)) EQ &STR(C) +\n               THEN DO\n               SET SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-2,&STR(&SFS))\n               SET SRCH&I = &STR(SRCHFORC)\n               END\n             ELSE SET SRCH&I = &STR(SRCHFOR)\n             SET SFS&I = &STR(&SFS)\n             END\n           SET I = &I + 1\n           END\n         ISPEXEC CONTROL ERRORS CANCEL\n         CONTROL NOMSG\n         FREE F(SYSPO SYSSU)\n         CONTROL MSG\n         ISPEXEC FTOPEN TEMP\n         ISPEXEC FTINCL PAJSSSF\n         ISPEXEC FTCLOSE\n         ISPEXEC VGET ZTEMPF\n         ALLOC F(SYSPO) DA('&ZTEMPF')\n         INTRDR SYSSU\n         EUSUB\n         CONTROL NOMSG\n         FREE F(SYSPO SYSSU)\n         CONTROL MSG\n         IF &STR(&EUIOF) EQ &STR(YES) THEN DO\n           SET &IOPARM = &STR(I.&EURUSID.S)\n           ISPEXEC SELECT PGM(IOFSPF) PARM(&IOPARM) NEWAPPL(IOF)\n           END\n         EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJCTOCP": {"ttr": 24332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x853\\x9f\\x00\\x853\\x9f\\t0\\x00\\x05\\x00\\x05\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-05T00:00:00", "modifydate": "1985-12-05T09:30:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 SMST UTOT\n         CONTROL MSG\n         ISPEXEC VGET (SMST UTOT)\n         TO (&UTOT) &SMST\n         CONTROL MSG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCVEP": {"ttr": 24577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x95\\x07?\\x00\\x95\\x07?\\t'\\x01\\xe3\\x01\\xe3\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-14T00:00:00", "modifydate": "1995-03-14T09:27:00", "lines": 483, "newlines": 483, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 DEBUG(NO)\n/*------------------------------------------------------------------*/\n/* ORIGIN : EXTRACTED FROM CBT 94 DEC TAPE, FILE 012, MEMBERS       */\n/*          NAMES : \"JH#TEDPR\" = ISPF PROCEDURE                     */\n/*                  \"JHTEPE31\" AND \"JHTEPE32\" = ISPF PANELS         */\n/*                  \"JHA@M00\" = ISPF MESSAGES                       */\n/* UPDATE : SOME ENHANCEMENTS DONE BY MOINIL P.A.                   */\n/* PRE-REQUISITES : \"DSNCHECK\", \"EURACFT\", \"PRINTO\" AND \"WHATDSN\"   */\n/*                  TSO COMMANDS.                               (PM)*/\n/*------------------------------------------------------------------*/\n         CONTROL MAIN NOMSG\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN GOTO QUIT\n         IF &DEBUG EQ YES THEN CONTROL MSG LIST SYMLIST CONLIST\n         ELSE CONTROL NOMSG\n/* - - - - - - - - - - - - - - - - - - - - - - - - - INITIALIZATION */\n         SET &AMP = &STR(&&)\n         SET &PRP = )\n         WHATDSN FILE(ISPPROF)\n         SET &RCC = &LASTCC\n         IF  &RCC NE 0 THEN GOTO ERRDDN\n         ISPEXEC VGET (ZSCREEN ZUSER ZDATE ZTIME) SHARED\n         SET &PXD = &STR(&ZDATE)\n         SET &PXT = &STR(&ZTIME)\n         SET &DDN = &STR(JHEDPR&ZSCREEN)\n         FREE F(&DDN)\n         CONTROL NOMSG\n         ALLOC F(&DDN) SPACE(5 5) TRACKS DIR(2) +\n           BLKSIZE(3120) LRECL(80) RECFM(F B)\n         ISPEXEC LIBDEF ISPTLIB LIBRARY ID(&DDN)\n         ISPEXEC LIBDEF ISPTABL LIBRARY ID(&DDN)\n         SET &W = &STR(W&ZUSER)\n         SET &X = &STR(X&ZUSER)\n         SET &Y = &STR(Y&ZUSER)\n         SET &TB = &STR(&Y)\n         SET &PMDSN = &Z\n         SET &PMT = &STR(OFF)\n         SET &PXP = 0\n         SET &PDL = &Z\n         SET &JHEDPRID = &Z\n         SET &JHEDPRDS = &Z\n         SET &JHEDPRAP = &Z\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  SELECTION */\nDSPLIN:  ISPEXEC DISPLAY PANEL(PAJVEP00)\n         IF &LASTCC NE 0 THEN GOTO LEAVE\nDSPLPR:  IF &PCM NE &Z THEN GOTO DSPLIN\n         SET &CSR = &Z\n         SET &JHPROFDS = &STR(&JHEDPRID..&JHEDPRDS)\n         IF &PMT EQ SLM THEN SET &JHRACC = &STR(UPDATE)\n         ELSE SET &JHRACC = &STR(READ)\n         EURACFT '&JHPROFDS' ACCESS(&JHRACC) NOLIST\n         SET &RCC = &LASTCC\n         IF &RCC GT 4 THEN GOTO ERRACC\n         IF &PMT EQ SLM THEN GOTO SLMTBL\n/* - - - - - - - - - - - - - - - - - - - -  COPY EDIT PROFILE TABLE */\n         SET &TN = &STR(&JHEDPRAP.EDIT)\n         DSNCHECK '&JHPROFDS(&TN)' NOLIST\n         SET &RCC = &LASTCC\n         IF &RCC NE 0 THEN GO TO ERRDSN\n         ISPEXEC LMINIT DATAID(JHDID) DATASET('&JHPROFDS')\n         ISPEXEC LMINIT DATAID(JHDOD) DDNAME(&DDN)\n         ISPEXEC LMCOPY FROMID(&JHDID) FROMMEM(&TN) +\n           TODATAID(&JHDOD) TOMEM(&Y) REPLACE\n         ISPEXEC LMFREE DATAID(&JHDID)\n         ISPEXEC LMCOMP DATAID(&JHDOD)\n         ISPEXEC LMFREE DATAID(&JHDOD)\n         IF &PMT EQ DLT THEN GOTO DLTTBL\n         IF &PMT NE TBL THEN GOTO CRDSPT\n/* - - - - - - - - - - - - - - - - - - - - - - - - - TABLE ANALYSIS */\n         ISPEXEC TBSTATS &TB CDATE(PMCDT)     CTIME(PMCTM)     +\n           UDATE(PMUDT)      UTIME(PMUTM)     USER(PMUSR)      +\n           ROWCREAT(PMRWC)   ROWCURR(PMRCU)   ROWUPD(PMRUP)    +\n           TABLEUPD(PMTUP)   SERVICE(PMSRV)   RETCODE(PMRCD)   +\n           STATUS1(PMST1)    STATUS2(PMST2)   STATUS3(PMST3)\n         ISPEXEC TBOPEN &TB NOWRITE\n         ISPEXEC TBTOP &TB\n         ISPEXEC TBSKIP &TB NUMBER(1) SAVENAME(PMSVN)\n         ISPEXEC TBQUERY &TB KEYS(PMKEY) NAMES(PMNMS) ROWNUM(PMRNM)   +\n           KEYNUM(PMKNM) NAMENUM(PMNMN)\n         SET &PMK01 = &Z\n         SET &PMK02 = &Z\n         SET &PMK03 = &Z\n         SET &PMX = &Z\n         IF &PMKNM NE 0 THEN DO\n           SET &PLL = 2\n           SET &PLH = &LENGTH(&STR(&PMKEY))\n           IF &SUBSTR(&PLH:&PLH,&PMKEY) EQ &PRP THEN +\n             SET &PLH = &PLH - 1\n           SYSCALL VDSPL PMK01 PLL PLH PMKEY\n           IF &PLL LE &PLH THEN SYSCALL VDSPL PMK02 PLL PLH PMKEY\n           IF &PLL LE &PLH THEN SYSCALL VDSPL PMK03 PLL PLH PMKEY\n           IF &PLL LE &PLH THEN SET &PMX = &STR(...)\n           END\n         SET &PMN01 = &Z\n         SET &PMN02 = &Z\n         SET &PMN03 = &Z\n         SET &PMN04 = &Z\n         SET &PMY = &Z\n         IF &PMNMN NE 0 THEN DO\n           SET &PLL = 2\n           SET &PLH = &LENGTH(&STR(&PMNMS))\n           IF &SUBSTR(&PLH:&PLH,&PMNMS) EQ &PRP THEN +\n             SET &PLH = &PLH - 1\n           SYSCALL VDSPL PMN01 PLL PLH PMNMS\n           IF &PLL LE &PLH THEN SYSCALL VDSPL PMN02 PLL PLH PMNMS\n           IF &PLL LE &PLH THEN SYSCALL VDSPL PMN03 PLL PLH PMNMS\n           IF &PLL LE &PLH THEN SYSCALL VDSPL PMN04 PLL PLH PMNMS\n           IF &PLL LE &PLH THEN SET &PMY = &STR(...)\n           END\n         SET &PMS01 = &Z\n         SET &PMS02 = &Z\n         SET &PMS03 = &Z\n         SET &PMZ = &Z\n         IF &PMSVN NE &Z THEN DO\n           SET &PLL = 2\n           SET &PLH = &LENGTH(&STR(&PMSVN))\n           IF &SUBSTR(&PLH:&PLH,&PMSVN) EQ &PRP THEN +\n             SET &PLH = &PLH - 1\n           SYSCALL VDSPL PMS01 PLL PLH PMSVN\n           IF &PLL LE &PLH THEN SYSCALL VDSPL PMS02 PLL PLH PMSVN\n           IF &PLL LE &PLH THEN SYSCALL VDSPL PMS03 PLL PLH PMSVN\n           IF &PLL LE &PLH THEN SET &PMZ = &STR(...)\n           END\nDSPLST:  SET &PSW = 0\n         ISPEXEC DISPLAY PANEL(PAJVEP03)\n         SET &RCC = &LASTCC\n         IF &RCC NE 0 THEN GOTO DSPLEX\n         IF &PCM EQ &Z THEN GOTO DSPLQR       /* JUST PRESSED ENTER */\n         GOTO LSDSPL\nDSPLQR:  SET &PSW = 1\n         ISPEXEC DISPLAY PANEL(PAJVEP04)\n         SET &RCC = &LASTCC\n         IF &RCC NE 0 THEN GOTO DSPLEX\n         IF &PCM EQ &Z THEN GOTO DSPLST       /* JUST PRESSED ENTER */\n         GOTO LSDSPL\nDSPLBK:  ISPEXEC SETMSG MSG(PAJV000X)\n         IF &PSW EQ 0 THEN GOTO DSPLST\n         GOTO DSPLQR\nDSPLEX:  SET &PMT = &STR(OFF)\n         GOTO ENDTBS\n/* - - - - - - - - - - - - - - - - - - - - - - - - -  DISPLAY TABLE */\nCRDSPT:  SET &JHEDUDT = &Z\n         SET &JHEDUTM = &Z\n         ISPEXEC TBSTATS &TB UDATE(JHEDUDT) UTIME(JHEDUTM)\n         SET &ZEDPIMAC = &Z                  /* NOT IN OLD PROFILES */\n         ISPEXEC TBOPEN &TB NOWRITE\n         ISPEXEC TBTOP &TB\n         IF &PMT EQ ON THEN DO\n           ISPEXEC TBCREATE &W NOWRITE +\n             NAMES(PMPTYPE PMPLRCL PMPRCFM PMPFLAG PMPBNDL +\n                   PMPBNDR PMPTABC PMPMASK PMPTABS PMPIMAC)\n           SET &PNL = &STR(PAJVEP02)\n           END\n         ELSE DO\n           ISPEXEC TBCREATE &W NOWRITE +\n             NAMES(JHEDPROF JHEDATTR JHEDLOCK JHEDIMAC JHEDSTAT +\n                   JHEDPACK JHEDRECV JHEDNULL JHEDCAPS JHEDTABS +\n                   JHEDNUMB JHEDAUTN JHEDBNDL JHEDBNDR)\n           SET &PNL = &STR(PAJVEP01)\n           END\n         SET &MSG = &Z\nSKPTBN:  ISPEXEC TBSKIP &TB NUMBER(1)\n         IF &LASTCC EQ 8 THEN GOTO DSPLTB\n         IF &PMT NE ON THEN DO\n           SET &JHEDPROF = &STR(&ZEDPTYPE)               /* PROFILE */\n           SET &JHEDATTR = &STR(&ZEDPRCFM-&ZEDPLRCL)        /* ATTR */\n           IF &SUBSTR(2,&ZEDPFLAG) EQ &STR(1) THEN          /* CAPS */ +\n             SET &JHEDCAPS = &STR(ON)\n           ELSE SET &JHEDCAPS = &STR(OFF)\n           IF &SUBSTR(4,&ZEDPFLAG) EQ &STR(1) THEN DO        /* HEX */\n             IF &SUBSTR(5,&ZEDPFLAG) EQ &STR(1) THEN +\n               SET &JHEDHEXM = &STR(ON DATA)\n             ELSE SET &JHEDHEXM = &STR(ON VERT)\n             END\n           ELSE SET &JHEDHEXM = &STR(OFF)\n           IF &SUBSTR(6,&ZEDPFLAG) EQ &STR(1) THEN          /* PACK */ +\n             SET &JHEDPACK = &STR(ON)\n           ELSE SET &JHEDPACK = &STR(OFF)\n           IF &SUBSTR(7,&ZEDPFLAG) EQ &STR(1) THEN DO      /* NULLS */\n             IF &SUBSTR(8,&ZEDPFLAG) EQ &STR(1) THEN +\n               SET &JHEDNULL = &STR(ON ALL)\n             ELSE SET &JHEDNULL = &STR(ON STD)\n             END\n           ELSE SET &JHEDNULL = &STR(OFF)\n           IF &SUBSTR(11,&ZEDPFLAG) EQ &STR(1) THEN       /* NUMBER */ +\n             SET &JHEDNUMB = &STR(COBOL)\n           ELSE SET &JHEDNUMB = &Z\n           IF &SUBSTR(10,&ZEDPFLAG) EQ &STR(1) THEN DO\n             IF &JHEDNUMB = &Z THEN SET &JHEDNUMB = &STR(STD)\n             ELSE SET &JHEDNUMB = &STR(STD &JHEDNUMB)\n             IF &SUBSTR(9,&ZEDPFLAG) EQ &STR(1) THEN +\n               SET &JHEDNUMB = &STR(DISPLAY &JHEDNUMB)\n             ELSE SET &JHEDNUMB = &STR(ON &JHEDNUMB)\n             END\n           IF &STR(&JHEDNUMB) EQ &Z THEN SET &JHEDNUMB = &STR(OFF)\n           IF &SUBSTR(14,&ZEDPFLAG) EQ &STR(1) THEN DO      /* TABS */\n             IF &SUBSTR(15:16,&ZEDPFLAG) EQ &STR(00) THEN +\n               SET &JHEDTABS = &STR(ON STD)\n             ELSE IF &SUBSTR(15:16,&ZEDPFLAG) = &STR(01) THEN +\n               SET &JHEDTABS = &STR(ON &ZEDPTABC)\n             ELSE SET &JHEDTABS = &STR(ON ALL)\n             END\n           ELSE SET &JHEDTABS = &STR(OFF)\n           IF &SUBSTR(18,&ZEDPFLAG) EQ &STR(1) THEN      /* AUTONUM */ +\n             SET &JHEDAUTN = &STR(ON)\n           ELSE SET &JHEDAUTN = &STR(OFF)\n           IF &SUBSTR(19,&ZEDPFLAG) EQ &STR(1) THEN     /* AUTOLIST */ +\n             SET &JHEDAUTL = &STR(ON)\n           ELSE SET &JHEDAUTL = &STR(OFF)\n           IF &SUBSTR(20,&ZEDPFLAG) EQ &STR(1) THEN        /* STATS */ +\n             SET &JHEDSTAT = &STR(ON)\n           ELSE SET &JHEDSTAT = &STR(OFF)\n           IF &SUBSTR(21,&ZEDPFLAG) EQ &STR(1) THEN         /* RECV */ +\n             SET &JHEDRECV = &STR(ON)\n           ELSE SET &JHEDRECV = &STR(OFF)\n           IF &SUBSTR(22,&ZEDPFLAG) EQ &STR(1) THEN         /* LOCK */ +\n             SET &JHEDLOCK = &STR(YES)\n           ELSE SET &JHEDLOCK = &STR(NO)\n           IF &SUBSTR(23,&ZEDPFLAG) EQ &STR(1) THEN DO  /* AUTOSAVE */\n             IF &SUBSTR(24,&ZEDPFLAG) EQ &STR(1) THEN +\n               SET &JHEDAUTS = &STR(OFF PROMPT)\n             ELSE SET &JHEDAUTS = &STR(OFF NOPROMPT)\n             END\n           ELSE SET &JHEDAUTS = &STR(ON)\n           SET &JHEDBNDL = &STR(&ZEDPBNDL)           /* LEFT BOUNDS */\n           SET &JHEDBNDR = &STR(&ZEDPBNDR)          /* RIGHT BOUNDS */\n           SET &JHEDIMAC = &STR(&ZEDPIMAC)    /* INITIAL EDIT MACRO */\n           END\n         ELSE DO\n           SET &PMPTYPE = &STR(&ZEDPTYPE)\n           SET &PMPLRCL = &STR(&ZEDPLRCL)\n           SET &PMPRCFM = &STR(&ZEDPRCFM)\n           SET &PMPFLAG = &STR(&ZEDPFLAG)\n           SET &PMPBNDL = &STR(&ZEDPBNDL)\n           SET &PMPBNDR = &STR(&ZEDPBNDR)\n           SET &PMPTABC = &STR(&ZEDPTABC)\n           SET &PMPMASK = &STR(&ZEDPMASK)\n           SET &PMPTABS = &STR(&ZEDPTABS)\n           SET &PMPIMAC = &STR(&ZEDPIMAC)\n           END\n         ISPEXEC TBADD &W\n         GOTO SKPTBN\nDSPLTB:  ISPEXEC TBTOP &W\n         ISPEXEC TBDISPL &W PANEL(&PNL) MSG(&MSG)\n         SET &RCC = &LASTCC\n         SET &PNL = &Z\n         IF &RCC NE 0 THEN GOTO ENDTBD\n         IF &PCM EQ &Z THEN GOTO DSPLTB       /* JUST PRESSED ENTER */\n/* - - - - - - - - - - - - - - - - - - - - -  PRINT CURRENT DISPLAY */\nLSDSPL:  CONTROL NOMSG\n         ERROR DO\n           ERROR OFF\n           FREE ATTR(VBA)\n           ATTR VBA RECFM(V B A) LRECL(137) BLKSIZE(6356) DSORG(PS)\n           ALLOC F(ISPFILE) DSN(VEPTEMP.LISTING) REUSE CATALOG +\n             USING(VBA) SP(5 2) TRACKS\n           SET &PDL = &STR(DELETE)\n           END\n         ALLOC F(ISPFILE) DSN(VEPTEMP.LISTING) OLD REUSE\n         ERROR OFF\n         ISPEXEC FTOPEN\n         IF &PMT EQ TBL THEN ISPEXEC FTINCL PAJSVEP3\n         ELSE IF &PMT EQ ON THEN ISPEXEC FTINCL PAJSVEP2\n         ELSE ISPEXEC FTINCL PAJSVEP1\n         ISPEXEC FTCLOSE\n         SET &POP = &Z\n         IF &PDS NE &Z THEN SET &POP = &STR(DEST(&PDS))\n         IF &PCL NE &Z THEN SET &POP = &STR(&POP CLASS(&PCL))\n         PRINTO VEPTEMP.LISTING &POP NOHEADING NOMSG\n         CONTROL MSG\n         IF &PMT EQ TBL THEN GOTO DSPLBK\n         IF &PMT EQ ON THEN SET &MSG = PAJV000Y\n         ELSE SET &MSG = PAJV000Z\n         GOTO DSPLTB\nENDTBD:  ISPEXEC TBEND &W\nENDTBS:  ISPEXEC TBEND &TB\n         GOTO DSPLIN\n/* - - - - - - - - - - - - - - - - - - - - - - - - DISPLAY APPLID'S */\nSLMTBL:  IF &PMDSN EQ &Z THEN GOTO LDAPTB\n         SET &PSW = 1\n         IF &STR(&PMDSN) EQ &STR(&JHPROFDS) THEN GOTO DSPLSL\n         ISPEXEC TBEND &X\n         SET &PMDSN = &Z\nLDAPTB:  ISPEXEC LMINIT DATAID(JHDID) DATASET('&JHPROFDS')\n         ISPEXEC LMOPEN DATAID(&JHDID)\n         ISPEXEC TBCREATE &X NOWRITE +\n           NAMES(XN1 XN2 XN3 XN4 XN5 XN6 XN7 XN8)\n         SET &PSW = 0\n         SET &N = 1\n         DO WHILE &N LE 8\n           SET XN&N = &Z\n           SET &N = &N + 1\n           END\n         SET &N = 1\n         SET &PMMSL = &Z\n         SET &RCC = 0\n         DO WHILE &RCC EQ 0\n           ISPEXEC LMMLIST DATAID(&JHDID) MEMBER(PMMSL) OPTION(LIST)\n           SET &RCC = &LASTCC\n           IF &RCC EQ 0 THEN DO\n             SET &PMMEM = &PMMSL\n             SET &L = &LENGTH(&STR(&PMMEM))\n             IF &L GT 4 THEN DO\n               SET &I = &L - 3\n               IF &SUBSTR(&I:&L,&PMMEM) EQ &STR(EDIT) THEN DO\n                 SET &PSW = 1\n                 SET &I = &L - 4\n                 SET XN&N = &SUBSTR(1:&I,&PMMEM)\n                 IF &N EQ 8 THEN DO\n                   ISPEXEC TBADD &X\n                   SET &N = 1\n                   DO WHILE &N LE 8\n                     SET XN&N = &Z\n                     SET &N = &N + 1\n                     END\n                   SET &N = 1\n                   END\n                 ELSE SET &N = &N + 1\n                 END\n               END\n             END\n           END\n         IF &N NE 1 THEN ISPEXEC TBADD &X\n         ISPEXEC LMMLIST DATAID(&JHDID) OPTION(FREE)\n         ISPEXEC LMCLOSE DATAID(&JHDID)\n         ISPEXEC LMFREE DATAID(&JHDID)\nDSPLSL:  IF &PSW EQ 1 THEN DO\n           ISPEXEC TBTOP &X\n           SET &MSG = &Z\n           SET &I = 0\n           DO WHILE &I EQ 0\n             ISPEXEC TBDISPL &X PANEL(PAJVEP10) MSG(&MSG) +\n               POSITION(CRP)\n             SET &RCC = &LASTCC\n             IF &RCC GT 4 THEN SET &I = 1\n             ELSE IF &ZTDSELS GT 1 THEN SET &MSG = PAJV001C\n             ELSE IF &XERR EQ ON THEN SET &MSG = PAJV001D\n             ELSE IF &ZTDSELS EQ 1 THEN DO\n               SET &N = &XSL\n               SET &L = &STR(&AMP.XN&N)\n               IF &L NE &Z THEN SET &I = 1\n               ELSE SET &MSG = PAJV001E\n               END\n             ELSE SET &MSG = PAJV001B\n             END\n           IF &RCC NE 0 THEN DO\n             ISPEXEC TBEND &X                          /* FORCE END */\n             SET &PMDSN = &Z\n             END\n           ELSE DO\n             SET &JHEDPRAP = &STR(&AMP.XN&XSL)    /* SELECTION DONE */\n             SET &PMDSN = &STR(&JHPROFDS)\n             END\n           END\n         ELSE DO\n           ISPEXEC TBEND &X                          /* TABLE EMPTY */\n           SET &PMDSN = &Z\n           ISPEXEC SETMSG MSG(PAJV001F)\n           END\n         SET &PMT = &STR(OFF)\n         GOTO DSPLIN\n/* - - - - - - - - - - - - - - - - - - - - - - -  DELETE FROM TABLE */\nDLTTBL:  ISPEXEC TBOPEN &TB WRITE\n         SET &ZTDTOP = 0\n         SET &PMUPT = NO\n         SET &RCC = 0\nDLTTBD:  IF &RCC EQ 4 THEN ISPEXEC TBDISPL &TB POSITION(CRP)\n         ELSE DO\n           ISPEXEC TBTOP &TB\n           ISPEXEC TBSKIP &TB NUMBER(&ZTDTOP)\n           ISPEXEC VGET (ZVERB ZSCROLLN)\n           IF &ZVERB EQ UP THEN ISPEXEC TBSKIP &TB +\n             NUMBER(-&ZSCROLLN)\n           ELSE IF &ZVERB EQ DOWN THEN ISPEXEC TBSKIP &TB +\n             NUMBER(&ZSCROLLN)\n           ISPEXEC TBDISPL &TB PANEL(PAJVEP20) POSITION(CRP)\n           END\n         SET &RCC = &LASTCC\n         IF &PCM EQ CANCEL OR &RCC GT 4 THEN GOTO DLTTBX\n         ELSE IF &ZTDSELS GE 1 THEN DO\n           IF (&STR(&XERR) EQ ON THEN DO\n             ISPEXEC SETMSG MSG(PAJV002B)\n             SET RCC = 0\n             END\n           ELSE DO WHILE &N GE 1\n             ISPEXEC TBDELETE &TB\n             ISPEXEC TBSKIP &TB\n             IF &LASTCC NE 0 THEN SET &N = 0\n             ELSE SET &N = &N - 1\n             SET &PMUPT = YES\n             END\n           END\n         GOTO DLTTBD\nDLTTBX:  IF (&PCM EQ CANCEL) OR (&PMUPT NE YES) THEN DO\n           ISPEXEC TBEND &TB\n           IF (&PCM EQ CANCEL) THEN ISPEXEC SETMSG MSG(PAJV002X)\n           ELSE ISPEXEC SETMSG MSG(PAJV002Y)\n           END\n         ELSE DO\n           ISPEXEC TBCLOSE &TB\n           SET &PRF = &STR(NO)\n           SET &PCF = &STR(NO)\n           ISPEXEC DISPLAY PANEL(PAJVEP21)\n           SET &RCC = &LASTCC\n           IF (&RCC NE 0) OR (&PCM NE &Z) OR +\n             (&PRF NE YES) THEN ISPEXEC SETMSG MSG(PAJV002W)\n           ELSE DO\n             ISPEXEC LMINIT DATAID(JHDID) DDNAME(&DDN)\n             ISPEXEC CONTROL ERRORS RETURN\n             ISPEXEC LMINIT DATAID(JHDOD) DATASET('&JHPROFDS') +\n               ENQ(EXCLU)\n             SET &ICC = &LASTCC\n             IF &ICC EQ 0 THEN DO\n               ISPEXEC LMCOPY FROMID(&JHDID) FROMMEM(&Y) +\n                 TODATAID(&JHDOD) TOMEM(&TN) REPLACE\n               SET &CCC = &LASTCC\n               END\n             ISPEXEC CONTROL ERRORS CANCEL\n             ISPEXEC LMFREE DATAID(&JHDID)\n             IF (&ICC EQ 0) AND (&CCC EQ 0) AND (&PCF EQ YES) THEN DO\n               ISPEXEC CONTROL ERRORS RETURN\n               ISPEXEC LMCOMP DATAID(&JHDOD)\n               ISPEXEC CONTROL ERRORS CANCEL\n               SET &PCC = &LASTCC\n               END\n             IF &CCC EQ 0 THEN ISPEXEC LMFREE DATAID(&JHDOD)\n             IF &ICC NE 0 THEN ISPEXEC SETMSG MSG(PAJV002V)\n             ELSE IF &CCC NE 0 THEN ISPEXEC SETMSG MSG(PAJV002U)\n             ELSE IF (&PCF EQ YES) AND (&PCC NE 0) THEN +\n               ISPEXEC SETMSG MSG(PAJV002T)\n             ELSE ISPEXEC SETMSG MSG(PAJV002Z)\n             END\n           END\n         SET &PMT = &STR(OFF)\n         GOTO DSPLIN\n/* - - - - - - - - - - - - - - - - - - - - - - - - ERROR PROCESSING */\nERRDDN:  IF &RCC EQ 8 THEN SET &MSG = PAJV000G\n         ELSE SET &MSG = PAJV000H\n         GOTO QUIT\nERRACC:  IF &RCC EQ 8 THEN SET &MSG = PAJV000A\n         ELSE SET &MSG = PAJV000B\n         SET &CSR = JHEDPRID\n         GOTO ERRMSG\nERRDSN:  IF &RCC EQ 4 THEN SET &MSG = PAJV000C\n         ELSE IF &RCC EQ 8 THEN SET &MSG = PAJV000D\n         ELSE IF &RCC EQ 12 THEN SET &MSG = PAJV000E\n         ELSE SET &MSG = PAJV000F\n         SET &CSR = JHEDPRAP\nERRMSG:  ISPEXEC DISPLAY MSG(&MSG) CURSOR(&CSR)\n         IF &LASTCC EQ 0 THEN GOTO DSPLPR\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - TERMINATED */\nLEAVE:   ISPEXEC LIBDEF ISPTLIB LIBRARY\n         ISPEXEC LIBDEF ISPTABL LIBRARY\n         FREE F(&DDN)\n         IF &PDL EQ &STR(DELETE) THEN DO\n           FREE ATTR(VBA) DELETE\n           FREE F(ISPFILE) DELETE\n           END\nQUIT:    IF &PMDSN NE &Z THEN ISPEXEC TBEND &X\n         EXIT CODE(0)\n/* ============== INTERNAL PROCEDURE (PREPARE DISPLAY OF VARIABLES) */\nVDSPL:   PROC 4 PV1 PV2 PV3 PV4\n         SYSREF &PV1 &PV2 &PV3 &PV4\n         SET &BLK = &STR(        .)\n         SET &L = 0\n         SET &M = 1\n         DO WHILE &M LE 7\n           IF &PV2 GT &PV3 THEN SET &M = 8\n           ELSE DO\n             IF &SUBSTR(&PV2:&PV2,&PV4) NE &Z THEN DO\n               SET &PV1 = &STR(&PV1.&SUBSTR(&PV2:&PV2,&PV4))\n               SET &L = &L + 1\n               END\n             ELSE DO\n               SET &N = 8 - &L\n               IF &N EQ 0 THEN SET &PV1 = &STR(&PV1 )\n               ELSE SET &PV1 = &STR(&PV1.&SUBSTR(1:&M,&BLK) )\n               SET &L = 0\n               SET &M = &M + 1\n               END\n             SET &PV2 = &PV2 + 1\n             END\n           END\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJCXIL": {"ttr": 24585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x15\\x7f\\x00\\x92\\x15\\x7f\\x15&\\x00E\\x00E\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-05T00:00:00", "modifydate": "1992-06-05T15:26:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n/*       PURPOSE : IMS LOG DATA-SET(S).                          (PM)*/\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n         CONTROL MAIN NOMSG\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN EXIT\n         ISPEXEC CONTROL ERRORS RETURN\nIMSL:    ISPEXEC DISPLAY PANEL(PAJXIL)\n         SET &ILCC = &LASTCC\n         IF &ILCC NE 0 THEN DO\n           IF &ILCC LE 8 THEN GOTO IMSX\n           ISPEXEC SETMSG MSG(PAJI001A)\n           GOTO IMSL\n           END\n         IF &MAS EQ YES THEN DO\n           CONTROL MSG\n           SET &ILST =\n           END\n         ELSE DO\n           CONTROL NOMSG\n           SET &ILST = &STR(N)\n           END\n         IF &JI NE THEN SET &ILST = &STR(J(&JI) &ILST)\n         ELSE SET &ILST = &STR(&ILST)\n         IF &DD NE THEN SET &ILST = &STR(D(&DD/&DM/&DY) &ILST)\n         ELSE IF &DM NE THEN DO\n           IF &DF NE THEN DO\n             IF &DT NE THEN -\n               SET &ILST = &STR(F(&DF/&DM/&DY) T(&DT/&DM/&DY) &ILST)\n             ELSE SET &ILST = &STR(F(&DF/&DM/&DY) &ILST)\n             END\n           ELSE SET &ILST = &STR(F(01/&DM/&DY) &ILST)\n           END\n         SET &EUGENDS =\n         IMSLDS &ILST\n         SET &ILRC = &LASTCC\n         CONTROL NOMSG\n         ISPEXEC VPUT (ILST ILRC EUGENDS)\nIMSD:    ISPEXEC DISPLAY PANEL(PAJXILX)\n         SET &ILCC = &LASTCC\n         IF &ILCC NE 0 THEN DO\n           IF &ILCC EQ 4 THEN GOTO IMSL\n           IF &ILCC EQ 8 THEN GOTO IMSX\n           ISPEXEC SETMSG MSG(PAJI001A)\n           GOTO IMSD\n           END\n         IF &EUGENDS EQ THEN GOTO IMSL\n         IF &DX NE D THEN DO\n           IF &DX EQ B THEN ISPEXEC BROWSE DATASET('&EUGENDS')\n           ELSE ISPEXEC EDIT DATASET('&EUGENDS')\n           SET &ILCC = &LASTCC\n           IF &ILCC NE 0 THEN DO\n             IF &ILCC GT 8 THEN DO\n               IF &DX EQ B THEN ISPEXEC SETMSG MSG(PAJI002A)\n               ELSE ISPEXEC SETMSG MSG(PAJI002B)\n               END\n             END\n           GOTO IMSD\n           END\n         IF &MAS EQ YES THEN CONTROL MSG\n         DELETE '&EUGENDS'\n         SET &ILCC = &LASTCC\n         IF &MAS EQ YES THEN CONTROL NOMSG\n         IF &ILCC NE 0 THEN ISPEXEC SETMSG MSG(PAJI002C)\n         SET &EUGENDS =\n         GOTO IMSL\nIMSX:    ISPEXEC CONTROL ERRORS CANCEL\n         CONTROL MSG\n         EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJCZAP": {"ttr": 24587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\"\\x9f\\x00\\x88\"\\x9f\\tX\\x00?\\x00?\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-08-16T00:00:00", "modifydate": "1988-08-16T09:58:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0 SZDSN SZVOL SZVTA\n         ISPEXEC VGET (PRJO LIBO TYPO SZDSN SZVOL SZVTA)\n         ISPEXEC CONTROL DISPLAY LINE\n         SCRSZ\n         SET &TTYPE = &LASTCC\n         TERMINAL SCRSIZE(24,80)\n         IF &SZVTA = YES THEN GOTO ALVA\n         IF &SZDSN = THEN GOTO ALLB\n         IF &SZVOL = THEN GOTO ALLA\n         ZAP &SZDSN VOLUME(&SZVOL)\n         GOTO ALEX\nALLA:    ZAP &SZDSN\n         GOTO ALEX\nALLB:    IF &PRJO = &SYSUID THEN GOTO ALLD\n         IF &SZVOL = THEN GOTO ALLC\n         ZAP '&PRJO..&LIBO..&TYPO' VOLUME(&SZVOL)\n         GOTO ALEX\nALLC:    ZAP '&PRJO..&LIBO..&TYPO'\n         GOTO ALEX\nALLD:    IF &SZVOL = THEN GOTO ALLE\n         ZAP &LIBO..&TYPO VOLUME(&SZVOL)\n         GOTO ALEX\nALLE:    ZAP &LIBO..&TYPO\n         GOTO ALEX\nALVA:    IF &SZDSN = THEN GOTO ALVC\n         IF &SZVOL = THEN GOTO ALVB\n         ZAP 'FORMAT4.DSCB' VOLUME(&SZVOL) ALLOCDSN(&SZDSN)\n         GOTO ALEX\nALVB:    ZAP 'FORMAT4.DSCB' ALLOCDSN(&SZDSN)\n         GOTO ALEX\nALVC:    IF &SZVOL = THEN GOTO ALVD\n         IF &PRJO \u00ac= &SYSUID THEN GOTO ALVD\n         IF &LIBO \u00ac= THEN GOTO ALVD\n         IF &TYPO \u00ac= THEN GOTO ALVD\n         CONTROL NOMSG\n         FREE F(ZAPTEMP)\n         DELETE ZAPVTOC.DATA\n         CONTROL MSG\n         ALLOC F(ZAPTEMP) DA(ZAPVTOC.DATA) VOL(&SZVOL) -\n             NEW TRACKS SPACE(0,0)\n         FREE F(ZAPTEMP)\n         ZAP 'FORMAT4.DSCB' ALLOCDSN(ZAPVTOC.DATA)\n         CONTROL NOMSG\n         DELETE ZAPVTOC.DATA\n         CONTROL MSG\n         GOTO ALEX\nALVD:    IF &PRJO = &SYSUID THEN GOTO ALVF\n         IF &SZVOL = THEN GOTO ALVE\n         ZAP 'FORMAT4.DSCB' VOLUME(&SZVOL) -\n             ALLOCDSN('&PRJO..&LIBO..&TYPO')\n         GOTO ALEX\nALVE:    ZAP 'FORMAT4.DSCB' ALLOCDSN('&PRJO..&LIBO..&TYPO')\n         GOTO ALEX\nALVF:    IF &SZVOL = THEN GOTO ALVG\n         ZAP 'FORMAT4.DSCB' VOLUME(&SZVOL) ALLOCDSN(&LIBO..&TYPO)\n         GOTO ALEX\nALVG:    ZAP 'FORMAT4.DSCB' ALLOCDSN(&LIBO..&TYPO)\n         GOTO ALEX\nALEX:    IF &TTYPE = 1 THEN TERMINAL SCRSIZE(24,80)\n         IF &TTYPE = 2 THEN TERMINAL SCRSIZE(27,132)\n         IF &TTYPE = 3 THEN TERMINAL SCRSIZE(32,80)\n         IF &TTYPE = 4 THEN TERMINAL SCRSIZE(43,80)\n         ISPEXEC CONTROL DISPLAY REFRESH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJC3270": {"ttr": 24833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x08?\\x00\\x94\\x08?\\tY\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-24T00:00:00", "modifydate": "1994-03-24T09:59:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "PROC     0\n/*********************************************************************/\n/*       T3270FS : IBM 3270 STRUCTURED FIELD TEST.                   */\n/*********************************************************************/\n         CONTROL MAIN NOMSG\n         IF &SYSISPF EQ &STR(NOT ACTIVE) THEN EXIT CODE(0)\n         ISPEXEC VGET (TFST TFSC TFSH TFSN TFSD)\n         FREE F(SYSTEST) DELETE\n         CONTROL MSG\n         IF &TFST EQ YES THEN DO\n           IF &TFSD EQ &Z THEN SET &SDST = LOCAL\n           ELSE SET &SDST = &TFSD\n           ATTR XTEST RECFM(F B A) BLKSIZE(800) LRECL(80)\n           ALLOC F(SYSTEST) TRACKS SPACE(2 1) USING(XTEST) +\n             SYSOUT(&TFSC) &TFSH COPIES(&TFSN) DEST(&SDST)\n           IF &LASTCC NE 0 THEN DO\n             FREE ATTR(XTEST)\n             WRITE => TEST ALLOCATION FAILED <=\n             EXIT CODE(8)\n             END\n           END\n         T3270FS\n         IF &TFST EQ YES THEN DO\n           CONTROL NOMSG\n           FREE F(SYSTEST)\n           FREE ATTR(XTEST)\n           CONTROL MSG\n           END\n         EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJDAY": {"ttr": 24835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89#?\\x00\\x89#?\\tF\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-21T00:00:00", "modifydate": "1989-08-21T09:46:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "%DAY --------------------------  W E E K D A Y  --------------------------------\n+\n+\n%Enter a date as+Day :_DI+(1-2 digits)%or as+Serial :_SDI+(1-3 digits)\n+              Month :_MI+(1-2 digits)\n+\n%       and the+Year :_YI  +(4 digits, only Gregorian calendar from 1582 up to\n+                            4315 included, see Help History, PFK-1)\n+\n%Enter a Table Suffix ===>_TSFX+(a 1-4 characters identifying the tables to\n+                                be used, see at HELP, PFK-1)\n+\n%     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n%     |                                                                 |\n%     |+  Weekday is :%&DNME                               +           %|\n%     |                                                                 |\n%     |+     Date is :%&DO                                 +           %|\n%     |                                                                 |\n%     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n)INIT\n  .HELP = PAJTDAY\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJDAYS": {"ttr": 24837, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x9f\\x00\\x88\\x15\\x9f\\x12\\x08\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-07T00:00:00", "modifydate": "1988-06-07T12:08:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": "%DAY ------------------------  Tables Services Menu  ---------------------------\n%SELECT OPTION ===>_OPT                                                        +\n+\n+\n%Enter Table Suffix ===>_TSFX+  (a 1-4 characters, at your disposal, to\n+                                identify a table, i.e., F for French)\n+\n+\n%   WEEKDAY+Table :%  1+- Display Days names table\n+                  %  2+- Fill Days names table\n+\n%     MONTH+Table :%  3+- Display Months names table\n+                  %  4+- Fill Months names table\n+\n%   X +EXIT        - Return to the PRIMARY OPTION MENU\n+\n+Press%END KEY+to return to the PRIVATE OPTION MENU\n+\n)INIT\n  .HELP = PAJTDAYS\n)PROC\n  &SEL = TRANS( TRUNC (&OPT,'.')\n                1,'CMD(%PAJCDAY1)'\n                2,'CMD(%PAJCDAY2)'\n                3,'CMD(%PAJCDAY3)'\n                4,'CMD(%PAJCDAY4)'\n                X,'EXIT'\n              ' ',' '\n                *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJDAYS1": {"ttr": 24839, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x19\\x1f\\x00\\x85\\x19\\x1f\\x12R\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-10T00:00:00", "modifydate": "1985-07-10T12:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n  @ TYPE(OUTPUT) INTENS(LOW)\n)BODY\n%DAY -----------------------  WEEKDAY table display  ---------------------------\n%COMMAND INPUT ===>_OPT                                    +  %SCROLL ===>_AMTL+\n+\n+\n%      KEY+(Day number)        %VALUE+(Day name)\n+\n)MODEL\n      @Z                       @Z\n)INIT\n  .HELP = PAJTDAYS\n  &VARS = '(N7 DAYNAME)'\n  &AMTL = HALF\n  &OPT  = ' '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJDAYS2": {"ttr": 24841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x19\\x1f\\x00\\x85\\x19\\x1f\\x12R\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-10T00:00:00", "modifydate": "1985-07-10T12:52:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "%DAY -----------------------  WEEKDAY table create  ----------------------------\n+\n+\n%Enter KEY and VALUE :+\n+\n+\n%       DAY+number :_N7  +  (1 to 7, 1 = Sunday)\n%         DAY+name :_DAYNAME        +\n+\n)INIT\n  .HELP = PAJTDAYS\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJDAYS3": {"ttr": 24843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x19\\x1f\\x00\\x85\\x19\\x1f\\x12R\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-10T00:00:00", "modifydate": "1985-07-10T12:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n  @ TYPE(OUTPUT) INTENS(LOW)\n)BODY\n%DAY ------------------------  MONTH table display  ----------------------------\n%COMMAND INPUT ===>_OPT                                    +  %SCROLL ===>_AMTL+\n+\n+\n%      KEY+(Month number)      %VALUE+(Month name)\n+\n)MODEL\n      @Z                       @Z\n)INIT\n  .HELP = PAJTDAYS\n  &VARS = '(N12 MONNAME)'\n  &AMTL = HALF\n  &OPT  = ' '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJDAYS4": {"ttr": 24845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x19\\x1f\\x00\\x85\\x19\\x1f\\x12R\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-10T00:00:00", "modifydate": "1985-07-10T12:52:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "%DAY ------------------------  MONTH table create  -----------------------------\n+\n+\n%Enter KEY and VALUE :+\n+\n+\n%     MONTH+number :_N12 +  (1 to 12, 1 = January)\n%       MONTH+name :_MONNAME        +\n+\n)INIT\n  .HELP = PAJTDAYS\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJDSC": {"ttr": 24847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x9f\\x00\\x88\\x15\\x9f\\x12\\x08\\x00,\\x00,\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-07T00:00:00", "modifydate": "1988-06-07T12:08:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SYSPAJA"}, "text": "%CDSCB -----------------  Change DSCB (VTOC Format-1)  -------------------------\n%Enter/verify parameters below:\n+\n+Library name: PROJECT %===>_PRJO       +\n+              LIBRARY %===>_LIBO       +\n+              TYPE    %===>_TYPO       +\n+\n+    or Data-set Name: %===>_DDSN\n+   and Volume Serial: %===>_DVOL       +  (if not cataloged)\n+\n+  Options -  Display: %===>_LPARM      +  (NO/YES)\n+          - Keep op.: %===>_KPARM      +  (NO/YES)\n+\n+Operands: %===>_OPARM\n\n\n+  (to only display the DSCB, leave operands blank)\n)INIT\n  .HELP = PAJTDSC\n  .CURSOR = LIBO\n  IF (&PRJO = ' ')\n    &PRJO = TRUNC (&ZPREFIX,' ')\n  IF (&LPARM = ' ')\n    &LPARM = NO\n  IF (&KPARM \u00ac= YES)\n    &KPARM = NO\n    &OPARM = ' '\n)PROC\n  IF (&DDSN = ' ')\n    VER (&PRJO,NONBLANK)  VER (&PRJO,NAME)\n    VER (&LIBO,NONBLANK)  VER (&LIBO,NAME)\n    VER (&TYPO,NONBLANK)  VER (&TYPO,NAME)\n  IF (&DDSN \u00ac= ' ')\n    VER (&DDSN,DSNAME)\n  IF (&DVOL \u00ac= ' ')\n    VER (&DVOL,NAME)\n  &LPARM = TRUNC (&LPARM,1)\n  &LPARM = TRANS (&LPARM N,NO Y,YES *,*)\n  VER (&LPARM,NONBLANK)  VER (&LPARM,LIST,NO,YES)\n  &KPARM = TRUNC (&KPARM,1)\n  &KPARM = TRANS (&KPARM N,NO Y,YES *,*)\n  VER (&KPARM,NONBLANK)  VER (&KPARM,LIST,NO,YES)\n  &SEL = 'CMD(%PAJCDSC) '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJDSP": {"ttr": 24849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x924o\\x00\\x924o\\x14\\x11\\x007\\x007\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-12-11T00:00:00", "modifydate": "1992-12-11T14:11:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "SYSPAJA"}, "text": "%DSPRT -------------------  Data-Set Print Selection  --------------------------\n%Enter/verify parameters below:\n+\n+Library name: PROJECT %===>_PRJO    +\n+              LIBRARY %===>_LIBO    +\n+              TYPE    %===>_TYPO    +\n+              MEMBER  %===>_MBRO    +  (blank = member list, * = all members)\n+      or data-set name%===>_DDSN\n+                                       (enter above the fully qualified name)\n+     and volume serial%===>_DVOL    +  (if not cataloged or you want force it)\n+\n+Ouput print options:\n+         SYSOUT Class            %===>_PCLASS    +\n+         Copies                  %===>_PCOPIES   +  (1-100)\n+         Heading                 %===>_PHEAD     +  (YES/NO)\n+         Upper case translation  %===>_PFOLD     +  (Fold or Nofold)\n+         Output status           %===>_PHOLD     +  (Hold or Nohold)\n+         RMT destination         %===>_PDEST     +  (optional)\n+\n)INIT\n  .HELP = PAJTDSP\n  .CURSOR = LIBO\n  IF (&PRJO = ' ')\n    &PRJO = TRUNC (&ZPREFIX,' ')\n  &MBRO = &Z\n  &PCLASS = TRANS (&PCLASS ' ',A *,*)\n  &PCOPIES = TRANS (&PCOPIES ' ',1 *,*)\n  &PHEAD  = TRANS (&PHEAD ' ',YES NO,YES *,*)\n  &PFOLD  = TRANS (&PFOLD ' ',NOFOLD *,*)\n  &PHOLD  = TRANS (&PHOLD ' ',NOHOLD *,*)\n)PROC\n  IF (&DDSN = ' ')\n    VER (&PRJO,NONBLANK)  VER (&PRJO,NAME)\n    VER (&LIBO,NONBLANK)  VER (&LIBO,NAME)\n    VER (&TYPO,NONBLANK)  VER (&TYPO,NAME)\n  IF (&MBRO \u00ac= '*')\n    IF (&MBRO \u00ac= ' ')\n      VER (&MBRO,NAME)\n  IF (&DDSN \u00ac= ' ')\n    VER (&DDSN,DSNAME)\n  IF (&DVOL \u00ac= ' ')\n    VER (&DVOL,NAME)\n  VER (&PCLASS,NONBLANK)\n  VER (&PCOPIES,RANGE,1,100)\n  &PHEAD = TRUNC (&PHEAD,1)\n  &PHEAD = TRANS (&PHEAD N,NO Y,YES *,*)\n  VER (&PHEAD,LIST,NO,YES)\n  &PFOLD = TRUNC (&PFOLD,1)\n  &PFOLD = TRANS (&PFOLD F,FOLD N,NOFOLD *,*)\n  VER (&PFOLD,LIST,FOLD,NOFOLD)\n  &PHOLD = TRUNC (&PHOLD,1)\n  &PHOLD = TRANS (&PHOLD H,HOLD N,NOHOLD *,*)\n  VER (&PHOLD,LIST,HOLD,NOHOLD)\n  &SEL = 'CMD(%PAJCDSP) '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJDSPL": {"ttr": 24851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(/\\x00\\x90(/\\tE\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-09T00:00:00", "modifydate": "1990-10-09T09:45:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)\n @ TYPE(OUTPUT) INTENS(LOW)\n)BODY WIDTH(80)\n%DSPRT --- Select member : &PDSN -----------------------------------------------\n%Command ===>_ZCMD                                            %Scroll ===>_Z   +\n+   Name                VV.MM   Created  Last modified  Size  Init   Mod   ID\n+===============================================================================\n)MODEL\n_S@MEMBER              @STATS\n)INIT\n .HELP = PAJTDSPL\n .ZVARS = 'ZSCML'\n &S = ' '\n &ZCMD = ' '\n &ZTDMARK = '============================ Bottom of names list +\n             ============================='\n)REINIT\n IF (.MSG = &Z)\n   &S = ' '\n   REFRESH(S)\n)PROC\n IF (&ZCMD \u00ac= &Z)\n   &TBCMD = TRANS (TRUNC (&ZCMD,' ')\n            D,D DIR,D DIRECTORY,D\n            L,L LOC,L LOCATE,L *,*)\n   VER (&TBCMD,LIST,D,L,MSG=PAJX000A)\n   &TBMNM = .TRAIL\n IF (&ZCMD = &Z)\n   &TBCMD = ' '\n   &TBMNM = ' '\n VPUT (ZSCML) PROFILE\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJDSS": {"ttr": 24853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x03\\x7f\\x00\\x89\\x03\\x7f\\x16&\\x00*\\x00*\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-02-06T00:00:00", "modifydate": "1989-02-06T16:26:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SYSPAJA"}, "text": "%STATDS --------------------  Data-Set Statistics  -----------------------------\n%Enter/verify parameters below:\n+\n+Library name: PROJECT %===>_PRJO       +\n+              LIBRARY %===>_LIBO       +\n+              TYPE    %===>_TYPO       +\n+\n+    or Data-set Name: %===>_DDSN\n+   and Volume Serial: %===>_DVOL       +  (if not cataloged)\n+\n+Processing Parm: %===>_DPARM           +  (blank - all\n+                                           NO    - no gas\n+                                           LABEL - only dcb and dscb\n+                                           FULL  - directory list, only PO\n+                                           GAS(TT.TT.RR) - name a gas\n+                                           GAS(ALL) - name all gas)\n+\n+Report Option:   %===>_REPORT          +  (T - terminal\n+                                           B - browse list\n+                                           L - output list\n+                                           D - disk data-set)\n+\n)INIT\n  .HELP = PAJTDSS\n  .CURSOR = LIBO\n  IF (&PRJO = ' ')\n    &PRJO = TRUNC (&ZPREFIX,' ')\n  IF (&REPORT = ' ')\n    &REPORT = B\n)PROC\n  IF (&DDSN = ' ')\n    VER (&PRJO,NONBLANK)  VER (&PRJO,NAME)\n    VER (&LIBO,NONBLANK)  VER (&LIBO,NAME)\n    VER (&TYPO,NONBLANK)  VER (&TYPO,NAME)\n  IF (&DDSN \u00ac= ' ')\n    VER (&DDSN,DSNAME)\n  IF (&DVOL \u00ac= ' ')\n    VER (&DVOL,NAME)\n  &REPORT = TRUNC (&REPORT,1)\n  VER (&REPORT,NONBLANK)  VER (&REPORT,LIST,B,D,L,T)\n  &SEL = 'CMD(%PAJCDSS) '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJD00": {"ttr": 24855, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89#?\\x00\\x89#?\\x111\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-21T00:00:00", "modifydate": "1989-08-21T11:31:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": "PAJD000A 'Year error        '  .ALARM=YES\n'Year must be numerics and not less than 1582 or greater than 4315'\n\nPAJD000B 'Month error       '  .ALARM=YES\n'Month must be from 1 to 12'\n\nPAJD000C 'Serial date error '  .ALARM=YES\n'Serial date must be from 1 to &UP'\n\nPAJD000D 'Serial date error '  .ALARM=YES\n'Serial date must be numerics (format DDD)'\n\nPAJD000E 'Table error       '  .ALARM=YES\n'Weekday table TWKD&TSFX does not exist, create it'\n\nPAJD000F 'Table error       '  .ALARM=YES\n'Weekday table TWKD&TSFX open R.C. = &CC'\n\nPAJD000G 'Table error       '  .ALARM=YES\n'Month table TMTH&TSFX does not exist, create it'\n\nPAJD000H 'Table error       '  .ALARM=YES\n'Month table TMTH&TSFX open R.C. = &CC'\n\nPAJD001A 'Numeric field     '  .ALARM=YES\n'Enter a DAY number'\n\nPAJD001B 'DAY number error  '  .ALARM=YES\n'DAY number must be from 1 to 7'\n\nPAJD001C 'Numeric field     '  .ALARM=YES\n'Enter a MONTH number'\n\nPAJD001D 'MONTH number error'  .ALARM=YES\n'MONTH number must be from 1 to 12'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJEM": {"ttr": 24857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16_\\x00\\x90\\x16_\\x16D\\x00[\\x00[\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "1990-06-14T16:44:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n  @ TYPE(OUTPUT) INTENS(LOW)\n)BODY\n%EDMODE -------------------------  EDIT Modes  ---------------------------------\n+\n+Current data-set : &EMDSNM\n+                  +BLKSIZE : &EMBLKS +  LRECL : &EMLRCL +  RECFM : &EMRCFM\n+Controlled Library Status : &EMCTL1  &EMCTL2\n+&EMTXT1  +&EMMEMB +&EMTXT2  @EMSTAT  +&EMTXT3  @EMVRSN  +&EMTXT4  @EMLEVL\n%Enter/verify EDIT modes :\n+  RECOVERY   %===>_EMRCVR  +(ON/OFF)         AUTONUM %===>_EMANUM  +(ON/OFF)\n+  CAPS       %===>_EMCAPS  +(ON/OFF)         AUTOLIST%===>_EMALST  +(ON/OFF)\n+  NUMBER     %===>_EMNBR1  +(ON/OFF)         AUTOSAVE%===>_EMASV1  +(ON/OFF)\n+             %===>_EMNBRA  +(STD/NOSTD)              %===>_EMASV2  +(if OFF\n+             %===>_EMNBRB  +(COBOL/NOCOBOL)                          above :\n+             %===>_EMNBRC  +(DISPLAY/NODISPL)                        PROMPT/\n+  NULLS      %===>_EMNLS1  +(ON/OFF)                                 NOPROMPT)\n+             %===>_EMNLS2  +(STD/ALL)\n+  HEX        %===>_EMHEX1  +(ON/OFF)\n+             %===>_EMHEX2  +(if ON above : VERT/DATA)\n+  BOUNDS Left%===>_EMLEFT+  Logical data width :+&EMWDTH +\n+        Right%===>_EMRGHT+\n+\n+Hit%ENTER+to continue with Edit modes\n+Hit%&EPF+to exit EDMODE facility\n+Hit%&HPF+to get explanation about Edit modes\n)INIT\n  .HELP = PAJTEM\n  .CURSOR = EMRCVR\n  &EMTXT1 = &Z\n  &EMTXT2 = &Z\n  &EMTXT3 = &Z\n  &EMTXT4 = &Z\n  IF (&EMMEMB \u00ac= &Z)\n    &EMTXT1 = ' Member :'\n    &EMTXT2 = '  STATS :'\n    .ATTR(EMSTAT) = 'TYPE(INPUT) INTENS(HIGH)'\n    IF (&EMSTAT = 'ON')\n      &EMTXT3 = 'VERSION :'\n      .ATTR(EMVRSN) = 'TYPE(INPUT) INTENS(HIGH)'\n      IF (&EMVRSN = &Z)\n        &EMVRSN = '01'\n      &EMTXT4 = '  LEVEL :'\n      .ATTR(EMLEVL) = 'TYPE(INPUT) INTENS(HIGH)'\n      IF (&EMLEVL = &Z)\n        &EMLEVL = '00'\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  IF (&EMMEMB \u00ac= &Z)\n    VER (&EMSTAT,LIST,ON,OFF)\n    IF (&EMSTAT = 'ON')\n      IF (&EMVRSN = &Z)\n        &EMVRSN = '01'\n      IF (&EMLEVL = &Z)\n        &EMLEVL = '00'\n      VER (&EMVRSN,NUM)  VER (&EMVRSN,RANGE,1,99)\n      VER (&EMLEVL,NUM)  VER (&EMLEVL,RANGE,0,99)\n  VER (&EMRCVR,NONBLANK)  VER (&EMRCVR,LIST,ON,OFF)\n  VER (&EMCAPS,NONBLANK)  VER (&EMCAPS,LIST,ON,OFF)\n  VER (&EMNBR1,NONBLANK)  VER (&EMNBR1,LIST,ON,OFF)\n  VER (&EMNBRA,NONBLANK)  VER (&EMNBRA,LIST,STD,NOSTD)\n  IF (&EMNBRB \u00ac= &Z)\n    VER (&EMNBRB,LIST,COBOL,NOCOBOL)\n  IF (&EMNBRC \u00ac= &Z)\n    VER (&EMNBRC,LIST,DISPLAY,NODISPL)\n  VER (&EMNLS1,NONBLANK)  VER (&EMNLS1,LIST,ON,OFF)\n  IF (&EMNLS2 \u00ac= &Z)\n    VER (&EMNLS2,LIST,STD,ALL)\n  VER (&EMHEX1,NONBLANK)  VER (&EMHEX1,LIST,ON,OFF)\n  IF (&EMHEX1 = 'ON')\n    VER (&EMHEX2,NONBLANK)  VER (&EMHEX2,LIST,VERT,DATA)\n  VER (&EMLEFT,NUM)\n  VER (&EMRGHT,NUM)\n  VER (&EMASV1,NONBLANK)  VER (&EMASV1,LIST,ON,OFF)\n  IF (&EMASV1 = 'OFF')\n    VER (&EMASV2,NONBLANK)  VER (&EMASV2,LIST,PROMPT,NOPROMPT)\n  VER (&EMANUM,NONBLANK)  VER (&EMANUM,LIST,ON,OFF)\n  VER (&EMALST,NONBLANK)  VER (&EMALST,LIST,ON,OFF)\n  &EMNBR2 = '&EMNBRA &EMNBRB &EMNBRC'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJEMA": {"ttr": 24860, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x90\\x14\\x1f\\x00\\x90\\x14\\x1f\\x14'\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-05-21T00:00:00", "modifydate": "1990-05-21T14:27:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n@ TYPE(INPUT) INTENS(LOW) CAPS(OFF)\n# TYPE(INPUT) INTENS(LOW) CAPS(ON)\n)BODY\n%------------------------ Additional local Edit macros ------------------------+\n%COMMAND ===>_ZCMD                                                             +\n+\n+\n%Specify or change macro information below :\n+\n+  Name of the macro\n%       ===>#MACNAME +\n+            (up to 8 characters macro name)\n+\n+  Description of the macro\n%       ===>@MACDESC                                                          +\n+            <-------------------- (up to 65 characters) -------------------->\n+\n)INIT\n  &ZCMD = &Z\n)PROC\n  VER (&MACNAME,NB,NAME)\n  VER (&MACDESC,NB)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJEML": {"ttr": 25089, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x14\\x1f\\x00\\x90\\x14\\x1f\\x140\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-05-21T00:00:00", "modifydate": "1990-05-21T14:30:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n # TYPE(INPUT) INTENS(LOW) CAPS(ON)\n @ TYPE(OUTPUT) INTENS(LOW) SKIP(ON)\n)BODY\n%------------------------ Additional local Edit macros ------------------------+\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_SCRL+\n+\n+S Mac.name  Macro function (use S in front of a name to get the HELP of macro)\n+- --------- ------------------------------------------------------------------\n)MODEL CLEAR(A)\n#A@Z        @Z\n)INIT\n  &VARS = '(MACNAME MACDESC)'\n  IF (&SCRL = &Z)\n    &SCRL = PAGE\n  &ZTDMARK = '============================ Bottom of macros list +\n              ============================'\n  &ZCMD = &Z\n)PROC\n  IF (&ZTDSELS \u00ac= 0000)\n    &EMOPTN = TRUNC(&A,1)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJEMP": {"ttr": 25091, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x90\\x14\\x1f\\x00\\x90\\x14\\x1f\\x14'\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-05-21T00:00:00", "modifydate": "1990-05-21T14:27:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n  _ TYPE(INPUT) CAPS(ON) INTENS(NON)\n)BODY\n%------------------------ Additional local Edit macros ------------------------+\n+\n+\n%  Table update is limited to macro's administrator, so ...\n+\n+\n+  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+  - - - - - - - %Enter password to update table ===>_EMPASS  +  - - - - - - -\n+  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n)INIT\n  &EMPASS = &Z\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJEMU": {"ttr": 25093, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"o\\x00\\x91\"o\\x12\\'\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-14T00:00:00", "modifydate": "1991-08-14T12:27:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n # TYPE(INPUT) INTENS(LOW) CAPS(ON)\n @ TYPE(OUTPUT) INTENS(LOW) SKIP(ON)\n)BODY\n%-------------------- Additional local Edit macros Updates --------------------+\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_SCRL+\n+\n+S Mac.name  Macro function (hit%&HPF+to get explanation of various functions)\n+- --------- ------------------------------------------------------------------\n)MODEL CLEAR(A)\n#A@Z        @Z\n)INIT\n  .HELP = PAJTEMU\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &VARS = '(MACNAME MACDESC)'\n  IF (&SCRL = &Z)\n    &SCRL = PAGE\n  &ZTDMARK = '============================ Bottom of macros list +\n              ============================'\n  &ZCMD = &Z\n)PROC\n  IF (&ZTDSELS \u00ac= 0000)\n    &EMOPTN = TRUNC(&A,1)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJEOL": {"ttr": 25095, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\t3\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T09:33:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                       -------------------------------\n                        |      Edit Macro  \"EOL\"      |\n                        -------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to%position the cursor+at the end of\n             the current screen line (like most PC editors do when you press\n             the \"End\" scroll key). Yes, it takes some interrupts and a PF key\n             definition, but that is the price you have to pay for PC-like\n             features on a 3270. By pressing the EOL PF key repeatedly, you can\n             jump to end of line (EOL) on successive lines.\n             EOL HELP or H to view this tutorial.\n%USE :      +Press appropriate PF key (the one assigned to EOL)\n            %COMMAND ===> <PFn>     +Assume%cursor+was on word%IN+on line 000020\n            %Before+********************** TOP OF DATA *************************\n            +000020 D: %IN+A858SES FIND ALL RECORDS FOR WHICH\n            +000021       REC-TY = 'SESC'\n            +000022     END FIND\n            %After+*********************** TOP OF DATA *************************\n            +000020 D:  IN A858SES FIND ALL RECORDS FOR WHICH\n            +000021       REC-TY = 'SESC'   %now cursor here \u00ac+\n            +000022     END FIND\n)PROC\n  &ZCONT = PAJEOL\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJEQD": {"ttr": 25097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90&/\\x00\\x90&/\\x16)\\x000\\x000\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-09-19T00:00:00", "modifydate": "1990-09-19T16:29:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SYSPAJA"}, "text": "%ENQDIS -----------------  Various Enqueues displays  --------------------------\n%COMMAND NUMBER ===>_JUNO                                                      +\n+\n%Enter/verify parameters below:\n+\n%   1 +LISTENQ  - List data-sets allocations for a Job and/or User-id.\n%   2 +WAITR    - data-sets allocations conflicts for a Job and/or User-id.\n+                 JOBNAME OR USERID%===>_JUNME   +\n+                 Option :_JU+  (set J to scan for Job-name only,\n+                                set U to scan for User-id only,\n+                                leave blank for both)\n+\n%   3 +TSODSN   - Display data-set enqueues.\n+                 D.S. Name :%===>_TDSN                                        +\n+\n%   4 +TSOENQ   - Display data-sets enqueues conflicts.\n%   5 +RSVENQ   - Display resources enqueued RESERVE.\n+                 Remark : when RS flag is on(Y) and GL flag is off(N), the\n+                          hardware RESERVE has been issued.\n+\n%   6 +PAJPVQ   - Generalized GRS/ENQ display.\n+\n)INIT\n  .HELP = PAJTEQD\n  .CURSOR = JUNO\n  IF (&JUNME = ' ')\n    &JUNME = &ZUSER\n  IF (&JU \u00ac= ' ')\n    &JU = TRUNC (&JU,1)\n)PROC\n  IF (&JUNO = 1,2)\n    VER (&JUNME,NONBLANK)  VER (&JUNME,NAME)\n    &JU = TRUNC (&JU,1)\n    IF (&JU \u00ac= ' ')\n      &JU = TRANS (&JU J,JOB U,USER *,*)\n      VER (&JU,LIST,JOB,USER)\n  IF (&JUNO = 3)\n    VER (&TDSN,NONBLANK)  VER (&TDSN,DSNAME)\n  &SEL = TRANS (TRUNC (&JUNO,' ')\n               1,'CMD(%PAJCEQD1) '\n               2,'CMD(%PAJCEQD2) '\n               3,'CMD(%PAJCEQD3) '\n               4,'CMD(%PAJCEQD4) '\n               5,'CMD(%PAJCEQD5) '\n               6,'PGM(PAJPVQ) '\n             ' ',' '\n               *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJGDDM": {"ttr": 25099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x941\\x9f\\x00\\x941\\x9f\\x15E\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-15T00:00:00", "modifydate": "1994-11-15T15:45:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n\\ TYPE(INPUT) CAPS(ON) INTENS(HIGH) HILITE(USCORE)\n\u00ac TYPE(TEXT) INTENS(LOW) SKIP(ON)\n\u00a2 TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n{ TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n\u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n~ TYPE(TEXT) COLOR(PINK) SKIP(ON)\n@ TYPE(TEXT) COLOR(YELLOW) HILITE(USCORE) SKIP(ON)\n# TYPE(TEXT) COLOR(RED) HILITE(REVERSE) SKIP(ON)\n)BODY\n#                            ~ GDDM demonstrations #                           \u00ac\n#  \u00ac                                                                        #  \u00ac\n#  @List of available tests :\u00ac                                              #  \u00ac\n#  \u00ac                                                                        #  \u00ac\n#  \u00ac              \u00a21 -\u00a6LOGO\u00ac                                                #  \u00ac\n#  \u00ac              \u00a22 -\u00a6SHUTTLE\u00ac                                             #  \u00ac\n#  \u00ac              \u00a23 -\u00a6NITEFLT\u00ac                                             #  \u00ac\n#  \u00ac              \u00a24 -\u00a6CODEBUST\u00ac                                            #  \u00ac\n#  \u00ac              \u00a25 -\u00a6SABREBAT\u00ac                                            #  \u00ac\n#  \u00ac              \u00a26 -\u00a6ZOOM\u00ac                                                #  \u00ac\n#  \u00ac                                                                        #  \u00ac\n#                                                                              \u00ac\n\n\\NN`ENTER{a specific test`number{or just`ENTER{to execute all sequentially\u00ac\n\n\u00acPress\u00a2END KEY\u00acto return to the\u00a6AMDAHL Option Menu\u00ac\n\n)INIT\n  .HELP = PAJTGDDM\n  &NN = &Z\n)PROC\n  IF (&NN \u00ac= &Z)\n    VER (&NN,RANGE,1,6)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJGDG": {"ttr": 25101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91(\\x9f\\x00\\x91(\\x9f\\x14C\\x00<\\x00<\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-16T00:00:00", "modifydate": "1991-10-16T14:43:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "SYSPAJA"}, "text": "%----------------- Generation Data Group Utility -------------------------------\n%Command ===>_ZCMD\n+\n%GDG prefix ===>_GDGPREF                            +(35 chars maximum)\n%    Select ===>_G+(a process from list below)\n+  %I+- List the GDG%Index+entry information.\n+  %L+-%List+the GDG data-sets with VOLSER information.\n+  %C+-%Create+a GDG%Index.\n+  %M+-%Modify+the number of GDG data-set%entries+to be%kept.\n+  %D+-%Delete+the GDG%Index+and%Uncatalog+(but not delete) any data-sets\n+            that currently are cataloged under this GDG.\n+  %S+-%Create+or%Delete+a GDG%model+data-set label.\n+  %T+-%Test+if a GDG%model+data-set label is existing.\n%Specify below when selection above is:+\n+  %C-M   :+Number of GDG%entries+to be%created+or%kept ===>_GNM+(2-255)\n+  %C-M   :+Uncataloged data-sets%EMPTY+option%===>_OEM+(NO/YES)\n+  %C-M-D :+Uncataloged data-sets%SCRATCH+option%===>_OSC+(YES/NO)\n%List+data-set name :%PROJECT =>_GDGPJ   %GROUP =>_GDGGR   %TYPE =>_GDGTY   +\n+                       %DISP =>_K+(K-Keep/D-Delete/M-Mod)\n+\n+Press%ENTER+to proceed or%END+to terminate.\n+\n)INIT\n  .HELP = PAJTGDG\n  IF (&GDGPREF = &Z)\n    .CURSOR = GDGPREF\n  IF (&GDGPREF \u00ac= &Z)\n    .CURSOR = G\n  &G = I\n  &GNM = &Z\n  IF (&GDGPJ = &Z)\n    &GDGPJ = &ZUSER\n  IF (&GDGGR = &Z)\n    &GDGGR = 'GDGPRT'\n  IF (&GDGTY = &Z)\n    &GDGTY = 'LIST'\n  IF (&K = &Z)\n    &K = D\n  &OEM = TRANS (&OEM ' ',NO YES,NO *,*)\n  &OSC = TRANS (&OSC ' ',YES NO,YES *,*)\n)PROC\n  VER (&GDGPREF,NB,DSNAME)\n  VER (&G,NB,LIST,C,D,I,L,M,S,T)\n  VER (&GDGPJ,NB,NAME)\n  VER (&GDGGR,NB,NAME)\n  VER (&GDGTY,NB,NAME)\n  VER (&K,NB,LIST,D,K,M)\n  IF (&G = C,M)\n    VER (&GNM,NB,NUM) VER (&GNM,RANGE,2,255)\n    &OEM = TRUNC (&OEM,1)\n    &OEM = TRANS (&OEM N,NO Y,YES *,*)\n    VER (&OEM,NB,LIST,NO,YES)\n  IF (&G = C,D,M)\n    &OSC = TRUNC (&OSC,1)\n    &OSC = TRANS (&OSC N,NO Y,YES *,*)\n    VER (&OSC,NB,LIST,NO,YES)\n  IF (&G = 'D')\n    &GNM = 'DLX'\n  VPUT (GDGPREF G GDGPJ GDGGR GDGTY K GNM OSC OEM) SHARED\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJGDGM": {"ttr": 25103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91(\\x9f\\x00\\x91(\\x9f\\x10Y\\x00,\\x00,\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-16T00:00:00", "modifydate": "1991-10-16T10:59:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SYSPAJA"}, "text": "%----------------- Generation Data Group Utility -------------------------------\n%Command ===>_ZCMD\n+\n+                  %---+GDG%model+data-set label Utility%---+\n+\n+GDG%model+data-set label is :%&GDGPREF\n+\n%Enter/verify parameters below :+\n+\n+   Volume serial%===>_G0    + (must be the volume on which the%Index+resides,\n+                               so, you should first LIST the GDG to know it)\n+\n%   Only for Create :+- - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n+           RECFM%===>_G1   %(*)+(left all these parameters blanks for%Delete+\n+         BLKSIZE%===>_G2   %(*)+ operation.%Beware+to fill any one which will\n+           LRECL%===>_G3   %(*)+ cause a%Create+operation)\n+                           %(*)---> Note :+values are%not+verified.\n+\n+\n+Press%ENTER+to proceed or%END+to terminate.\n+\n)INIT\n  .HELP = PAJTGDGM\n  .CURSOR = G0\n  &G0 = &Z\n  &G1 = &Z\n  &G2 = &Z\n  &G3 = &Z\n)PROC\n  VER (&G0,NB,NAME)\n  IF (&G = S)\n    IF (&G1 \u00ac= &Z)\n      VER (&G1,ALPHA)\n    IF (&G2 \u00ac= &Z)\n      VER (&G2,NUM)\n    IF (&G3 \u00ac= &Z)\n      VER (&G3,NUM)\n  IF (&G = T)\n    &G1 = &Z\n    &G2 = &Z\n    &G3 = &Z\n  VPUT (G0 G1 G2 G3) SHARED\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJG00": {"ttr": 25105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91(\\x8f\\x00\\x91(\\x8f\\x17\\x07\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-15T00:00:00", "modifydate": "1991-10-15T17:07:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SYSPAJA"}, "text": "PAJG000A 'GDG not found' .ALARM=YES\n'The GDG Index &GDGPREF was not found - RC=&CCND'\nPAJG000B 'GDG was displayed'\n'The GDG Index &GDGPREF was displayed - RC=&CCND'\nPAJG000C 'GDG not &ACTION' .ALARM=YES\n'The GDG Index &GDGPREF was not &ACTION - RC=&CCND'\nPAJG000D 'GDG was &ACTION'\n'The GDG Index &GDGPREF was &ACTION - RC=&CCND'\nPAJG000E 'Model not &ACTION' .ALARM=YES\n'The GDG model &GDGPREF was not &ACTION - ALLOC RC=&CCND'\nPAJG000F 'Model not &ACTION' .ALARM=YES\n'The GDG model &GDGPREF was not &ACTION - FREE RC=&CCND'\nPAJG000G 'Model was &ACTION'\n'The GDG model &GDGPREF was &ACTION - RC=&CCND'\nPAJG000H 'Model &ACTION'\n'The test of GDG model &GDGPREF was &ACTION'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJIAP": {"ttr": 25107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07?\\x00\\x95\\x07?\\x117\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-14T00:00:00", "modifydate": "1995-03-14T11:37:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": "%----------------------------  ISPF APPLICATIONS  ------------------------------\n%SELECT OPTION ===>_ZCMD                                                       +\n+                                                           +USERID   -%&ZUSER\n%   S +SYSLIB      - System libraries browse/edit           +PREFIX   -%&ZPREFIX\n+                    selection (this is an example          +TODAY    -%&ZDATE\n+                    of ISPCDSN use)                        +JULIAN   -%&ZJDATE\n+                                                           +TIME     -%&ZTIME\n%   M +MAIL-BOXES  - \"mail-boxes\" facility (this ISPF\n+                    application is an example of ISPF\n+                    services and ENCRYPT/DECRYPT use, try it)\n+\n%   I +MANUALS     - IBM manuals maintenance (this ISPF\n+                    application allows you to maintain\n+                    an online list of your manuals, try it)\n+\n%   V +VEP         - View EDIT Profiles (ISPF)\n+\n%   X +EXIT        - Return to SPF\n+\n+\n+Press%END KEY+to return to the PRIVATE OPTION MENU\n+\n)PROC\n  &ZSEL = TRANS (TRUNC (&ZCMD,'.')\n                S,'CMD(PAJCSLB)'\n                M,'CMD(PAJCMX)'\n                I,'CMD(%CBOOK000)'\n                V,'CMD(%PAJCVEP)'\n                X,'EXIT'\n              ' ',' '\n                *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJIVK": {"ttr": 25109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x91'_\\x00\\x91'_\\x14#\\x00C\\x00C\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-02T00:00:00", "modifydate": "1991-10-02T14:23:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "SYSPAJA"}, "text": "%INVOKER ---------------  Invoke special TSO commands  -------------------------\n%COMMAND NUMBER ===>_ZCMD                                                      +\n+\n%Enter/verify parameters below:\n+\n%   1 +DIDOCS   - Simulate OS console for TSO user.\n+                 System auth.:_DOPT  +  (NO/YES)\n%   2 +QSP      - Queue/Spool analyzer.\n+                 Subcommand:_DSBC              +  (DI/DA/ST/...)\n%   3 +VSM      - Virtual Storage monitor.\n%   C +VSM/RSM  - VSM and RSM analysis jobs.\n%   4 +PUSE     - Pageing Utilization.\n%   5 +UNITS    - Display unit names of the device name table.\n+                 Short list :_LOPT  +  (NO/YES)\n%   6 +UNIT     - Display data about physical device(s).\n+                 Devices list :_UOPT                                          +\n+                         i.e. - SYSDA TAPES USE 310 B0 5 ...\n+                         note - an asterisk (*) means the whole configuration.\n%   7 +POF      - VTAM secondary Program Operator Facility.\n+\n)INIT\n  .HELP = PAJTIVK\n  .CURSOR = ZCMD\n  IF (&DOPT = ' ')\n    IF (&ZUSER = WIZARD,MASTER)\n      &DOPT = TRANS (&DOPT ' ',YES *,*)\n    &DOPT = TRANS (&DOPT ' ',NO *,*)\n  IF (&DSBC = ' ')\n    &DSBC = TRANS (&DSBC ' ',DO *,*)\n  IF (&LOPT = ' ')\n    &LOPT = TRANS (&LOPT ' ',NO *,*)\n  IF (&UOPT = ' ')\n    &UOPT = TRANS (&UOPT ' ',DASD *,*)\n)PROC\n  &IVKN = TRUNC (&ZCMD,'/')\n  &ZTRAIL = .TRAIL\n  IF (&IVKN = 1)\n    IF (&ZTRAIL \u00ac= &Z)\n      &DOPT = &ZTRAIL\n    &DOPT = TRUNC (&DOPT,1)\n    &DOPT = TRANS (&DOPT N,NO Y,YES *,*)\n    VER (&DOPT,NONBLANK)  VER (&DOPT,LIST,NO,YES)\n  IF (&IVKN = 2)\n    IF (&ZTRAIL \u00ac= &Z)\n      &DSBC = &ZTRAIL\n  IF (&IVKN = 5)\n    IF (&ZTRAIL \u00ac= &Z)\n      &LOPT = &ZTRAIL\n    &LOPT = TRUNC (&LOPT,1)\n    &LOPT = TRANS (&LOPT N,NO Y,YES *,*)\n    VER (&LOPT,NONBLANK)  VER (&LOPT,LIST,NO,YES)\n    &VOPT = TRANS (&LOPT YES,NAMES NO,' ' *,*)\n  IF (&IVKN = 6)\n    IF (&ZTRAIL \u00ac= &Z)\n      &UOPT = &ZTRAIL\n  &ZSEL = TRANS (&IVKN\n                1,'CMD(%PAJCIVK1) '\n                2,'CMD(%PAJCIVK2) '\n                3,'CMD(%PAJCIVK3) '\n                C,'PANEL(PAJIVK1) '\n                4,'CMD(%PAJCIVK4) '\n                5,'CMD(%PAJCIVK5) '\n                6,'CMD(%PAJCIVK6) '\n                7,'PGM(PAJPPOF)'\n              ' ',' '\n                *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJIVK1": {"ttr": 25111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x91'_\\x00\\x91'_\\x11B\\x00\\x8c\\x00\\x8c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-02T00:00:00", "modifydate": "1991-10-02T11:42:00", "lines": 140, "newlines": 140, "modlines": 0, "user": "SYSPAJA"}, "text": "%ANALYZE ----------------  VSM and RSM analysis jobs  --------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n%Enter/verify parameters below:\n+\n+   Job selection :_IVR+(VSM/RSM)\n+\n+   Request(s) for :\n+       %VSM -  SQA :_IV1+(NO/YES)            or%RSM -  VSM :_IV6+(NO/YES)\n+       %       CSA :_IV2+(NO/YES)              %      PFTE :_IV7+(NO/YES)\n+       %      LSQA :_IV3+(NO/YES)              %      ESTE :_IV8+(NO/YES)\n+       %       PVT :_IV4+(NO/YES)\n+       %        AE :_IV5+(NO/YES)\n+       %VSM+default = SQA : YES                %RSM+default = PFTE : YES\n+       %VSM+special test :_IVT     +\n+                           (ALL/GET/hhhhhhhh)\n+\n%   LIST+DD-name :_IVKL    +\n%   SNAP+wanted :_IVKT+(NO/YES, then%SNAP+DD-name :_IVKS    +\n%   DUMP+wanted :_IVKD+(NO/YES)\n+\n)INIT\n  .HELP = PAJTIVK1\n  .CURSOR = IVR\n  &IVR = &Z\n  &IV1 = TRANS (&IV1 ' ',NO *,*)\n  &IV2 = TRANS (&IV2 ' ',NO *,*)\n  &IV3 = TRANS (&IV3 ' ',NO *,*)\n  &IV4 = TRANS (&IV4 ' ',NO *,*)\n  &IV5 = TRANS (&IV5 ' ',NO *,*)\n  &IVT = &Z\n  &IV6 = TRANS (&IV6 ' ',NO *,*)\n  &IV7 = TRANS (&IV7 ' ',NO *,*)\n  &IV8 = TRANS (&IV8 ' ',NO *,*)\n  &IVKL = TRANS (&IVKL ' ',SYSPRINT *,*)\n  &IVKT = TRANS (&IVKT ' ',NO *,*)\n  &IVKS = TRANS (&IVKS ' ',SYSSNAP *,*)\n  &IVKD = TRANS (&IVKD ' ',NO *,*)\n)PROC\n  VER (&IVR,NB,LIST,VSM,RSM)\n  &IV1 = TRUNC (&IV1,1)\n  &IV1 = TRANS (&IV1 N,NO Y,YES ' ',NO *,*)\n  VER (&IV1,NB,LIST,NO,YES)\n  &IV2 = TRUNC (&IV2,1)\n  &IV2 = TRANS (&IV2 N,NO Y,YES ' ',NO *,*)\n  VER (&IV2,NB,LIST,NO,YES)\n  &IV3 = TRUNC (&IV3,1)\n  &IV3 = TRANS (&IV3 N,NO Y,YES ' ',NO *,*)\n  VER (&IV3,NB,LIST,NO,YES)\n  &IV4 = TRUNC (&IV4,1)\n  &IV4 = TRANS (&IV4 N,NO Y,YES ' ',NO *,*)\n  VER (&IV4,NB,LIST,NO,YES)\n  &IV5 = TRUNC (&IV5,1)\n  &IV5 = TRANS (&IV5 N,NO Y,YES ' ',NO *,*)\n  VER (&IV5,NB,LIST,NO,YES)\n  &IV6 = TRUNC (&IV6,1)\n  &IV6 = TRANS (&IV6 N,NO Y,YES ' ',NO *,*)\n  VER (&IV6,NB,LIST,NO,YES)\n  &IV7 = TRUNC (&IV7,1)\n  &IV7 = TRANS (&IV7 N,NO Y,YES ' ',NO *,*)\n  VER (&IV7,NB,LIST,NO,YES)\n  &IV8 = TRUNC (&IV8,1)\n  &IV8 = TRANS (&IV8 N,NO Y,YES ' ',NO *,*)\n  VER (&IV8,NB,LIST,NO,YES)\n  &IVKT = TRUNC (&IVKT,1)\n  &IVKT = TRANS (&IVKT N,NO Y,YES ' ',NO *,*)\n  VER (&IVKT,NB,LIST,NO,YES)\n  &IVKD = TRUNC (&IVKD,1)\n  &IVKD = TRANS (&IVKD N,NO Y,YES ' ',NO *,*)\n  VER (&IVKD,NB,LIST,NO,YES)\n  &IVKL = TRANS (&IVKL ' ',SYSPRINT *,*)\n  VER (&IVKL,NB,NAME)\n  &IVKS = TRANS (&IVKS ' ',SYSSNAP *,*)\n  IF (&IVKT = NO)\n    &IVKS = &Z\n  IF (&IVKT = YES)\n    VER (&IVKS,NB,NAME)\n  &IVKP = &Z\n  IF (&IVR = VSM)\n    &IVKW = 1\n    IF (&IV1 = YES)\n      &IVKP = SQA\n    IF (&IV2 = YES)\n      IF (&IVKP \u00ac= &Z)\n        &IVKP = '&IVKP,CSA'\n      IF (&IVKP = &Z)\n        &IVKP = CSA\n    IF (&IV3 = YES)\n      IF (&IVKP \u00ac= &Z)\n        &IVKP = '&IVKP,LSQA'\n      IF (&IVKP = &Z)\n        &IVKP = LSQA\n    IF (&IV4 = YES)\n      IF (&IVKP \u00ac= &Z)\n        &IVKP = '&IVKP,PVT'\n      IF (&IVKP = &Z)\n        &IVKP = PVT\n    IF (&IV5 = YES)\n      IF (&IVKP \u00ac= &Z)\n        &IVKP = '&IVKP,AE'\n      IF (&IVKP = &Z)\n        &IVKP = AE\n    IF (&IVT \u00ac= &Z)\n      IF (&IVT \u00ac= ALL,GET)\n        VER (&IVT,PICT,XXXXXXXX)\n      IF (&IVKP \u00ac= &Z)\n        &IVKP = '&IVKP,T=&IVT'\n      IF (&IVKP = &Z)\n        &IVKP = 'T=&IVT'\n  IF (&IVR = RSM)\n    &IVKW = 2\n    IF (&IV6 = YES)\n      &IVKP = VSM\n    IF (&IV7 = YES)\n      IF (&IVKP \u00ac= &Z)\n        &IVKP = '&IVKP,PFTE'\n      IF (&IVKP = &Z)\n        &IVKP = PFTE\n    IF (&IV8 = YES)\n      IF (&IVKP \u00ac= &Z)\n        &IVKP = '&IVKP,ESTE'\n      IF (&IVKP = &Z)\n        &IVKP = ESTE\n  IF (&IVKL \u00ac= SYSPRINT)\n    IF (&IVKP \u00ac= &Z)\n      &IVKP = '&IVKP,L=&IVKL'\n    IF (&IVKP = &Z)\n      &IVKP = 'L=&IVKL'\n  IF (&IVKS \u00ac= &Z)\n    IF (&IVKS \u00ac= SYSSNAP)\n      IF (&IVKP \u00ac= &Z)\n        &IVKP = '&IVKP,S=&IVKS'\n      IF (&IVKP = &Z)\n        &IVKP = 'S=&IVKS'\n  &ZSEL = TRANS (&IVKW\n                1,'CMD(%PAJCIVKA) '\n                2,'CMD(%PAJCIVKB) '\n              ' ',' '\n                *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJI00": {"ttr": 25347, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x15\\x7f\\x00\\x92\\x15\\x7f\\x115\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-05T00:00:00", "modifydate": "1992-06-05T11:35:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "PAJI000A 'FROM error' .ALARM=YES\n'Day and days range conflict ...'\nPAJI000B 'TO error' .ALARM=YES\n'Day and end of days range conflict ...'\nPAJI000C 'TO error' .ALARM=YES\n'Start days range missing ...'\nPAJI000D 'YEAR error' .ALARM=YES\n'You probably want yesterday or a month ...'\n\nPAJI001A 'DISPLAY error' .ALARM=YES\n'Display panel RC received back is &ILCC ... Retry ...'\n\nPAJI002A 'BROWSE error' .ALARM=YES\n'Browse RC received back is &ILCC ... Retry ...'\nPAJI002B 'EDIT error' .ALARM=YES\n'Edit RC received back is &ILCC ... Retry ...'\nPAJI002C 'DELETE error' .ALARM=YES\n'Delete RC received back is &ILCC ... Control ...'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJKUMXH": {"ttr": 25349, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x931_\\x00\\x931_\\x12A\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-11-11T00:00:00", "modifydate": "1993-11-11T12:41:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n` TYPE(TEXT) COLOR(YELLOW)\n$ TYPE(TEXT) COLOR(YELLOW) HILITE(REVERSE)\n{ TYPE(TEXT) COLOR(GREEN)\n~ TYPE(TEXT) COLOR(BLUE)\n} TYPE(TEXT) COLOR(RED)\n\\ TYPE(TEXT) COLOR(RED) HILITE(BLINK)\n! TYPE(TEXT) COLOR(PINK)\n\u00a6 TYPE(TEXT) COLOR(TURQ)\n# TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n)BODY\n#---------------------------$   L  O  C  K  table   #---------------------------\n+\n+\n+\n\u00a6Do you know how I run ?+\n+\n+             }... no |!it's your problem,\\sorry |+\n+\n+             {... yes |~OK,+\n+                       `then,+\n+                       \u00a6do you know what I want ?+\n+\n+                                 }... no |!it's also your problem,\\sorry |+\n+\n+                                 {... yes |~OK,+\n+                                           `so long and good luck |+\n+\n)PROC\n  &ZCONT = PAJKUMXH\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJLIFE": {"ttr": 25351, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x941?\\x00\\x941?\\x159\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-09T00:00:00", "modifydate": "1994-11-09T15:39:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": "%LIFE ---------------  A program for TSO 3270 terminals  -----------------------\n+\n+\n+          %|-----------------------------------------------------|+\n+          %|+As soon as you enter execution of the%LIFE+program,%|+\n+          %| HELP+screens are at your disposal for explanations.%|+\n+          %|-----------------------------------------------------|+\n+\n+\n%Option :+Screen data maps save :_LFE+(NO/YES)\n+\n+         If you say%YES+to option above, then the default data-set name\n+         specified below may be changed if you wish.\n+        %DSname :_LFEDS                                          +\n+                 %Notes : 1.+If the data-set name is not quoted, it will be\n+                             prefixed with your USERID.\n+                         %2.+An unexisting data-set will be automatically\n+                             created for you.\n+\n+Hit%ENTER+to execute the program.\n+Hit%END KEY+to return to the Various ... Option Menu.\n+\n)INIT\n  .CURSOR = LFE\n  &LFE = TRANS (&LFE ' ',NO *,*)\n  IF (&LFEDS = &Z)\n    &LFEDS = 'LIFE.DATA'\n)PROC\n  &LFE = TRUNC (&LFE,1)\n  &LFE = TRANS (&LFE N,NO Y,YES *,*)\n  VER (&LFE,NONBLANK)  VER (&LFE,LIST,NO,YES)\n  IF (&LFE = YES)\n    VER (&LFEDS,NONBLANK)\n  &ZSEL = 'CMD(%PAJCLIFE)'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJMENU": {"ttr": 25353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x17O\\x00\\x92\\x17O\\x14$\\x003\\x003\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-22T00:00:00", "modifydate": "1992-06-22T14:24:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "SYSPAJA"}, "text": "%---------------------------  PRIVATE OPTION MENU  -----------------------------\n%SELECT OPTION ===>_ZCMD                                                       +\n+\n%   1 +DSPRT    - Data-set Print Selection                  +USERID   -%&ZUSER\n%   2 +STATDS   - Data-set Statistics                       +PREFIX   -%&ZPREFIX\n%   3 +ZAP      - Invoke full screen ZAP                    +TODAY    -%&ZDATE\n%   4 +INVOKER  - Invoke DIDOCS, QSP, VSM, PUSE, UNITS,     +JULIAN   -%&ZJDATE\n+                        UNIT or POF                        +TIME     -%&ZTIME\n%   5 +CDSCB    - Change DSCB (VTOC Format-1)\n%   6 +ENQDIS   - Display ENQ's                            %A +Allocations\n%   7 +TO       - Message to one or more TSO user(s)       %G +GDG Utility\n%   8 +SEND     - Message to a TSO user or MAIN operator   %P +PDSMATCH job\n%   9 +SPECIAL  - Authorized command(s) interface          %V +VCOREZAP\n%   B +BLKSIZE  - Disk block sizes computations/tables     %Y +Various ...\n%   C +COMPARE  - Compare sequentials or members           %Z +IMS log\n%   D +DAY      - Weekday from 1582 up to 4315, or             data-set(s)\n+                 %S+- Tables Services (Display/Fill)\n%   M +SHORT    - Short messages communication\n%   O +OPERATOR - Miscellaneous Operators Facilities\n%   I +ISPFAPPL - Some ISPF applications            %X +EXIT - Return to SPF\n+\n+Press%END KEY+to return to the PRIMARY OPTION MENU\n+\n)PROC\n  &ZSEL = TRANS (TRUNC (&ZCMD,'.')\n                1,'PANEL(PAJDSP)'\n                2,'PANEL(PAJDSS)'\n                3,'PANEL(PAJZAP)'\n                4,'PANEL(PAJIVK)'\n                5,'PANEL(PAJDSC)'\n                6,'PANEL(PAJEQD)'\n                7,'PANEL(PAJTOCP)'\n                8,'PANEL(PAJSEND)'\n                9,'CMD(%PAJCAUCP)'\n                A,'PGM(PAJPALL)'\n                B,'CMD(%PAJCBLK)'\n                C,'PANEL(PAJCOM)'\n                D,'CMD(%PAJCDAY)'\n                G,'CMD(%PAJCGDG)'\n                I,'PANEL(PAJIAP)'\n                M,'PANEL(PAJSM)'\n                O,'PANEL(PAJMOF)'\n                P,'PANEL(PAJPDS)'\n                S,'PANEL(PAJDAYS)'\n                V,'CMD(VCOREZAP)'\n                Y,'PANEL(PAJVRS)'\n                Z,'CMD(PAJCXIL)'\n                X,'EXIT'\n              ' ',' '\n                *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJMOF": {"ttr": 25355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x9f\\x00\\x88\\x15\\x9f\\x11%\\x004\\x004\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-07T00:00:00", "modifydate": "1988-06-07T11:25:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "SYSPAJA"}, "text": "%------------------* MISCELLANEOUS OPERATORS FACILITIES *-----------------------\n%SELECT OPTION ===>_MOFN                                                       +\n+                                                           +USERID   -%&ZUSER\n%   B +BRODSCAN  - Analyze Broadcast TSO data-set.          +PREFIX   -%&ZPREFIX\n+                - Browse  :_MOFB    +  (YES/NO)            +TODAY    -%&ZDATE\n+                                                           +JULIAN   -%&ZJDATE\n%   U +BRODUNLD  - Broadcast User'id Messages Unload.       +TIME     -%&ZTIME\n+                - USERID  :_USID    +  (User'id name)\n+\n%   T +Test AUTO - Input DS:_LDDS                                              +\n+                - Member  :_LDMB    +  (starting member name)\n+\n)INIT\n  .HELP = PAJTMOF\n  IF (&MOFN = ' ')\n    .CURSOR = LDMB\n    &MOFN = T\n    &MOFB = TRANS (&MOFB ' ',YES *,*)\n    &LDDS = ...OPERATOR.LIBRARY...\n    &USID = ' '\n  IF (&MOFN = T)\n    .CURSOR = LDMB\n  IF (&MOFN = U)\n    .CURSOR = USID\n  IF (&MOFN \u00ac= T)\n    IF (&MOFN \u00ac= U)\n      .CURSOR = MOFN\n)REINIT\n  IF (&MOFN = T)\n    .CURSOR = LDMB\n  IF (&MOFN = U)\n    .CURSOR = USID\n  IF (&MOFN \u00ac= T)\n    IF (&MOFN \u00ac= U)\n      .CURSOR = MOFN\n)PROC\n  IF (&MOFN = B)\n    &MOFB = TRUNC (&MOFB,1)\n    &MOFB = TRANS (&MOFB N,NO Y,YES *,*)\n    VER (&MOFB,NONBLANK)  VER (&MOFB,LIST,NO,YES)\n  IF (&MOFN = T)\n    VER (&LDDS,NONBLANK)\n    VER (&LDMB,NONBLANK)\n  IF (&MOFN = U)\n    VER (&USID,NONBLANK)  VER (&USID,NAME)\n  &SEL = TRANS (TRUNC (&MOFN,' ')\n               B,'CMD(%PAJCBRDS) '\n               U,'CMD(%PAJCBUMU) '\n               T,'CMD(%PAJCAUTO) '\n             ' ',' '\n               *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJMX0": {"ttr": 25357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16(\\x00K\\x00K\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:28:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%-/-/- M A I L - B O X E S -/-/-\n%COMMAND ===>_ZCMD                                                             +\n+\n+Do you intend to allocate a new mail-lists tables\n+     data-set or create-update a MAIL-LIST table%===>_MXUPDT  +(NO or YES)\n+\n%Specify or change information below :\n+\n+  Mail-lists tables data-set name ...... PROJECT%===>_MXTPRO  +\n+                                         LIBRARY%===>_MXTLIB  +\n+                                            TYPE%===>_MXTTYP  +\n+\n+  Mail-boxes data-set name ............. PROJECT%===>_MXMPRO  +\n+                                         LIBRARY%===>_MXMLIB  %===> default\n+                                            TYPE%===>_MXMTYP  %     MAIL-LIST\n+                                                              %     table name\n+\n+  If desired, enter another MAIL-LIST table name%===>_MXLIST  +or leave blank\n+  Debugging aid ................ TEST run option%===>_MXTEST  +(NO or YES)\n+\n+Hit%ENTER+to start MAIL-BOXES facility process\n+Hit%&EPF+to exit MAIL-BOXES facility process\n+Hit%&HPF+to get explanation about MAIL-BOXES facility\n)INIT\n  .HELP = PAJTMX0\n  .CURSOR = ZCMD\n  &ZCMD = &Z\n  &MXUPDT  = TRANS (&MXUPDT ' ',NO YES,NO *,*)\n  IF (&MXTPRO = ' ')\n    &MXTPRO = TRUNC (&ZPREFIX,' ')\n  IF (&MXTLIB = ' ')\n    &MXTLIB = 'TMAILS'\n  IF (&MXTTYP = ' ')\n    &MXTTYP = 'DATA'\n  IF (&MXMPRO = ' ')\n    &MXMPRO = TRUNC (&ZPREFIX,' ')\n  IF (&MXMLIB = ' ')\n    &MXMLIB = 'MAILS'\n  IF (&MXMTYP = ' ')\n    &MXMTYP = 'DATA'\n  &MXLIST = &Z\n  &MXTEST  = TRANS (&MXTEST ' ',NO YES,NO *,*)\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &MXUPDT = TRUNC (&MXUPDT,1)\n  &MXUPDT = TRANS (&MXUPDT N,NO Y,YES *,*)\n  VER (&MXUPDT,LIST,NO,YES)\n  VER (&MXTPRO,NONBLANK)  VER (&MXTPRO,NAME)\n  VER (&MXTLIB,NONBLANK)  VER (&MXTLIB,NAME)\n  VER (&MXTTYP,NONBLANK)  VER (&MXTTYP,NAME)\n  VER (&MXMPRO,NONBLANK)  VER (&MXMPRO,NAME)\n  VER (&MXMLIB,NONBLANK)  VER (&MXMLIB,NAME)\n  VER (&MXMTYP,NONBLANK)  VER (&MXMTYP,NAME)\n  IF (&MXLIST = ' ')\n    &MXLIST = &MXMLIB\n  IF (&MXLIST \u00ac= ' ')\n    VER (&MXLIST,NONBLANK)  VER (&MXLIST,NAME)\n  &MXTEST = TRUNC (&MXTEST,1)\n  &MXTEST = TRANS (&MXTEST N,NO Y,YES *,*)\n  VER (&MXTEST,LIST,NO,YES)\n  VPUT (MXTPRO MXTLIB MXTTYP MXUPDT) PROFILE\n  VPUT (MXMPRO MXMLIB MXMTYP MXLIST MXTEST) PROFILE\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJMX1": {"ttr": 25360, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x18_\\x00\\x90\\x18_\\x12\\x02\\x00\\x82\\x00\\x82\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-07-04T00:00:00", "modifydate": "1990-07-04T12:02:00", "lines": 130, "newlines": 130, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n# TYPE(INPUT) INTENS(LOW) CAPS(ON)\n@ TYPE(OUTPUT) INTENS(LOW) SKIP(ON)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n)BODY EXPAND(//)\n%-/-/- M A I L - B O X E S -/-/-\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_AMT +\n+\n+Current SORT order :&MXSRTF\n+Current L line-command output class :_LCLAS+and destination :_LDEST           +\n+Any B or L line-command data decryption requested :_MXOPT+(NO, YES or RANGE)\n%-/-/- M A I L - L I S T -/-/-\n%Act Mail   Date    Field    Aut. Subject\n%--- ------ ------- -------- ---- ----------------------------------------------\n)MODEL CLEAR(A)\n#A  @MXNUM @Z      @Z        @Z  @MXDES\n)INIT\n  .ZVARS = '(MXDATE MXFIELD MXAUT)'\n  .HELP = PAJTMX1\n  &ZHTOP = PAJTMX1\n  .AUTOSEL = NO\n  IF (&CRP \u00ac= &Z)\n    .CSRROW = &CRP\n  IF (&AMT = &Z)\n    &AMT = PAGE\n  &ZTDMARK = '============================ Bottom of mail-boxes +\n              ============================='\n  &MXCURM = TRANS(&ZMONTH\n            01,January 02,February 03,March 04,April 05,May 06,June\n            07,July 08,August 09,September 10,October 11,November 12,December)\n  &MXCURD = '&ZDAY &MXCURM 19&ZYEAR'\n  VPUT (MXCURD) SHARED\n  IF (&LCLAS = &Z)\n    &LCLAS = A\n  IF (&LDEST = &Z)\n    &LDEST = LOCAL\n  &MXOPT  = TRANS (&MXOPT ' ',NO *,*)\n)REINIT\n  IF (.MSG \u00ac= &Z)\n    .ATTR(.CURSOR) = 'COLOR(RED)'\n    .AUTOSEL = YES\n    .CSRROW = &CRP\n)PROC\n  &MXLCLAS = TRANS(&LCLAS A,' ' *,*)\n  &MXLDEST = TRANS(&LDEST LOCAL,' ' *,*)\n  IF (&MXLDEST \u00ac= &Z)\n    &D = TRUNC(&MXLDEST,1)\n    VER (&D,LIST,U,R,MSG=PAJM993D)\n    &D = .TRAIL\n    VER (&D,NB,NUM,MSG=PAJM993D)\n  &MXOPT = TRUNC (&MXOPT,1)\n  &MXOPT = TRANS (&MXOPT N,NO Y,YES R,RANGE *,*)\n  VER (&MXOPT,LIST,NO,YES,RANGE)\n  &CMD = TRANS(TRUNC(&ZCMD,' ')\n         I,INPUT IN,INPUT INP,INPUT CAN,CANCEL MB,MAILBOX MAIL,MAILBOX\n         L,LIST LS,LIST LST,LIST S,STATUS ST,STATUS STAT,STATUS *,*)\n  VER (&CMD,LIST,INPUT,CANCEL,MAILBOX,LIST,SORT,SAVE,STATUS,MSG=PAJM993E)\n  IF (&CMD = 'SORT')\n    &ZTRAIL = .TRAIL\n    &SFMX1 = TRANS(TRUNC(&ZTRAIL,' ')\n             MAIL,M DATE,D FIELD,F AUTHOR,A AUT,A\n             'M(A)',MI 'D(A)',D 'F(A)',F 'A(A)',A 'AUT(A)',A\n             'MAIL(A)',MI 'DATE(A)',D 'FIELD(A)',F 'AUTHOR(A)',A\n             'M(D)',M 'D(D)',DI 'F(D)',FI 'A(D)',AI 'AUT(D)',AI\n             'MAIL(D)',M 'DATE(D)',DI 'FIELD(D)',FI 'AUTHOR(D)',AI *,*)\n    VER (&SFMX1,LIST,M,D,F,A,MI,DI,FI,AI MSG=PAJM993S)\n    &ZTRAIL = .TRAIL\n    &SFMX2 = TRANS(TRUNC(&ZTRAIL,' ')\n             MAIL,M DATE,D FIELD,F AUTHOR,A AUT,A\n             'M(A)',MI 'D(A)',D 'F(A)',F 'A(A)',A 'AUT(A)',A\n             'MAIL(A)',MI 'DATE(A)',D 'FIELD(A)',F 'AUTHOR(A)',A\n             'M(D)',M 'D(D)',DI 'F(D)',FI 'A(D)',AI 'AUT(D)',AI\n             'MAIL(D)',M 'DATE(D)',DI 'FIELD(D)',FI 'AUTHOR(D)',AI *,*)\n    VER (&SFMX2,LIST,M,D,F,A,MI,DI,FI,AI MSG=PAJM993S)\n    &ZTRAIL = .TRAIL\n    &SFMX3 = TRANS(TRUNC(&ZTRAIL,' ')\n             MAIL,M DATE,D FIELD,F AUTHOR,A AUT,A\n             'M(A)',MI 'D(A)',D 'F(A)',F 'A(A)',A 'AUT(A)',A\n             'MAIL(A)',MI 'DATE(A)',D 'FIELD(A)',F 'AUTHOR(A)',A\n             'M(D)',M 'D(D)',DI 'F(D)',FI 'A(D)',AI 'AUT(D)',AI\n             'MAIL(D)',M 'DATE(D)',DI 'FIELD(D)',FI 'AUTHOR(D)',AI *,*)\n    VER (&SFMX3,LIST,M,D,F,A,MI,DI,FI,AI MSG=PAJM993S)\n    &ZTRAIL = .TRAIL\n    &SFMX4 = TRANS(TRUNC(&ZTRAIL,' ')\n             MAIL,M DATE,D FIELD,F AUTHOR,A AUT,A\n             'M(A)',MI 'D(A)',D 'F(A)',F 'A(A)',A 'AUT(A)',A\n             'MAIL(A)',MI 'DATE(A)',D 'FIELD(A)',F 'AUTHOR(A)',A\n             'M(D)',M 'D(D)',DI 'F(D)',FI 'A(D)',AI 'AUT(D)',AI\n             'MAIL(D)',M 'DATE(D)',DI 'FIELD(D)',FI 'AUTHOR(D)',AI *,*)\n    VER (&SFMX4,LIST,M,D,F,A,MI,DI,FI,AI MSG=PAJM993S)\n    &ZTRAIL = .TRAIL\n  IF (&CMD = 'INPUT')\n    &MXIN = .TRAIL\n    IF (&MXIN = &Z)\n      &MXIN = 1\n    VER (&MXIN,NB,NUM)\n  IF (&CMD = 'LIST')\n    &ZTRAIL = .TRAIL\n    &MXPCLAS = ' '\n    &MXPDEST = ' '\n    IF (&ZTRAIL \u00ac= &Z)\n      &MXPDEST = TRUNC(&ZTRAIL,' ')\n      &MXPCLAS = .TRAIL\n      IF (&MXPDEST = 'LOCAL')\n        &MXPDEST = ' '\n      IF (&MXPDEST \u00ac= 'LOCAL')\n        &D = TRUNC(&MXPDEST,1)\n        IF (&MXPDEST \u00ac= &D)\n          VER (&D,LIST,U,R,MSG=PAJM993D)\n          &D = .TRAIL\n          VER (&D,NB,NUM,MSG=PAJM993D)\n        IF (&MXPDEST = &D)\n          &MXPDEST = &MXPCLAS\n          &MXPCLAS = &D\n          IF (&MXPDEST \u00ac= &Z)\n            IF (&MXPDEST = 'LOCAL')\n              &MXPDEST = ' '\n            IF (&MXPDEST \u00ac= 'LOCAL')\n              &D = TRUNC(&MXPDEST,1)\n              VER (&D,LIST,U,R,MSG=PAJM993D)\n              &D = .TRAIL\n              VER (&D,NB,NUM,MSG=PAJM993D)\n  IF (&ZTDSELS \u00ac= 0000)\n    &ACT = TRUNC(&A,1)\n    VER (&ACT,LIST,R,D,U,M,B,L,MSG=PAJM993L)\n    &N = .TRAIL\n    IF (&N = &Z)\n      &N = 1\n    VER (&N,NB,NUM)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJMX2": {"ttr": 25363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x1f\\x00\\x89\\x17\\x1f\\x120\\x00?\\x00?\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-20T00:00:00", "modifydate": "1989-06-20T12:30:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n@ TYPE(INPUT) INTENS(LOW) CAPS(OFF)\n# TYPE(INPUT) INTENS(LOW) CAPS(ON)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n)BODY EXPAND(//)\n%-/-/- M A I L - B O X E S : &TTL mail-box -/-/-\n%COMMAND ===>_ZCMD                                                             +\n+\n%Specify or change information below :\n+\n+  Mail-id    %===>#MXNUM +  (up to 6 numerics sequence number)\n+  Date       %===>#Z      + (DDMMMYY, where MMM may be JAN, FEB, MAR, ... or\n+                             leave it blank = today)\n+  Field      %===>#Z       +(up to 8 characters argument name)\n+  Author     %===>#Z +      (2 characters identifier, i.e. PM, AC, ...)\n+  Subject    %===>@MXDES                                         +\n+                   <------- (up to 46 characters) -------------->\n+\n+Hit%ENTER+to update the information for this mail-box\n+Hit%&EPF+to cancel this operation and return to MAIL-LIST panel\n+Hit%&HPF+to get explanation about mail-boxes facility\n)INIT\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n  .ZVARS = '(MXDATE MXFIELD MXAUT)'\n  &ZCMD = &Z\n  &TTL = 'Update'\n  IF (&CMD = 'INPUT')\n    &TTL = 'Add'\n)PROC\n  VER (&MXNUM,NB,NUM)  VER (&MXNUM,RANGE,1,999999)\n  VER (&MXFIELD,NB,NAME)\n  VER (&MXAUT,NB,PICT,AA)\n  &MXSORT = '999999'\n  IF (&MXDATE \u00ac= &Z)\n    &DD = TRUNC(&MXDATE,2)\n    VER (&DD,NB,NUM,MSG=PAJM994D)\n    &ZTRAIL = .TRAIL\n    &MM = TRANS(TRUNC(&ZTRAIL,3)\n                JAN,01 FEB,02 MAR,03 APR,04 MAY,05 JUN,06\n                JUL,07 AUG,08 SEP,09 OCT,10 NOV,11 DEC,12\n                MSG=PAJM994D)\n    &YY = .TRAIL\n    VER (&YY,NB,NUM,MSG=PAJM994D)\n    &MXSORT = '&YY.&MM.&DD'\n  IF (&MXDATE = &Z)\n    &MM = TRANS(&ZMONTH\n                01,JAN 02,FEB 03,MAR 04,APR 05,MAY 06,JUN\n                07,JUL 08,AUG 09,SEP 10,OCT 11,NOV 12,DEC)\n    &MXDATE = '&ZDAY.&MM.&ZYEAR'\n    &MXSORT = '&ZYEAR.&ZMONTH.&ZDAY'\n  VER (&MXDES,NB)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJMX3": {"ttr": 25601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x19O\\x00\\x89\\x19O\\x13D\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-07-13T00:00:00", "modifydate": "1989-07-13T13:44:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%-/-/- M A I L - B O X E S -/-/-\n%COMMAND ===>_ZCMD                                                             +\n+\n%Allocate new data-set : &MXDSN\n+\n+  Volume serial     %===>_MXVOL +     (A volume must be specified)\n+  Generic unit      %===>_MXUNM   +   (Generic group name or unit address)\n+  Space units       %===>_MXSPU    +  (TRACKS-TRACK-TRKS-TRK-T or\n+                                       CYLINDERS-CYLINDER-CYLS-CYL-C)\n+  Primary quantity  %===>_MXSP1+      (In above units)\n+  Secondary quantity%===>_MXSP2+      (In above units)\n+  Directory blocks  %===>_MXDIR+\n+\n)INIT\n  .HELP = PAJTMX0\n  .CURSOR = MXVOL\n  &ZCMD = &Z\n  &MXVOL = 'USER00'                /* DEFAULT VOLUME SERIAL NUMBER */\n)PROC\n  VER (&MXVOL,NONBLANK)  VER (&MXVOL,NAME)\n  VER (&MXUNM,NONBLANK)\n  &MXSPU = TRANS (&MXSPU C,CYLINDERS T,TRACKS\n                         CYL,CYLINDERS TRK,TRACKS\n                         CYLS,CYLINDERS TRKS,TRACKS\n                         CYLINDER,CYLINDERS TRACK,TRACKS\n                         CYLINDERS,CYLINDERS TRACKS,TRACKS *,*)\n  VER (&MXSPU,LIST,CYLINDERS,TRACKS)\n  VER (&MXSP1,NUM)\n  VER (&MXSP1,RANGE,1,32760)\n  VER (&MXSP2,NUM)\n  VER (&MXSP2,RANGE,1,32760)\n  VER (&MXDIR,NUM)\n  VER (&MXDIR,RANGE,1,32760)\n  VPUT (MXVOL MXUNM MXSPU MXSP1 MXSP2 MXDIR) PROFILE\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJMX4": {"ttr": 25603, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16(\\x00*\\x00*\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:28:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n@ TYPE(OUTPUT) INTENS(LOW) COLOR(RED)\n)BODY EXPAND(//)\n%-/-/- M A I L - B O X E S -/-/-\n%COMMAND ===>_ZCMD                                                             +\n+\n%S T A T U S+(Working information)\n+\n+            Allocate new mail-lists tables data-set\n+                 or create-update a MAIL-LIST table option%===>@MXUPDT  +\n+\n+            Mail-lists tables data-set name ...... PROJECT%===>@MXTPRO  +\n+                                                   LIBRARY%===>@MXTLIB  +\n+                                                      TYPE%===>@MXTTYP  +\n+                              Current MAIL-LIST table name%===>@MXLIST  +\n+\n+            Mail-boxes data-set name ............. PROJECT%===>@MXMPRO  +\n+                                                   LIBRARY%===>@MXMLIB  +\n+                                                      TYPE%===>@MXMTYP  +\n+\n+            Debugging aid ................ TEST run option%===>@MXTEST  +\n+\n+Hit%ENTER+or%&EPF+to return to MAIL-LIST panel\n+Hit%&HPF+to get explanation about MAIL-BOXES facility\n)INIT\n  .HELP = PAJTMX0\n  .CURSOR = ZCMD\n  &ZCMD = &Z\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJMX5": {"ttr": 25605, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x19\\x8f\\x00\\x89\\x19\\x8f\\x16)\\x00-\\x00-\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-07-17T00:00:00", "modifydate": "1989-07-17T16:29:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%-/-/- M A I L - B O X E S -/-/-\n%COMMAND ===>_ZCMD                                                             +\n+\n%Allocate new data-set : &MXDSN\n+\n+  Volume serial     %===>_MXVOL +     (A volume must be specified)\n+  Generic unit      %===>_MXUNM   +   (Generic group name or unit address)\n+  Space units       %===>_MXSPU    +  (TRACKS-TRACK-TRKS-TRK-T or\n+                                       CYLINDERS-CYLINDER-CYLS-CYL-C)\n+  Primary quantity  %===>_MXSP1+      (In above units)\n+  Secondary quantity%===>_MXSP2+      (In above units)\n+  Directory blocks  %===>_MXDIR+\n+\n+  Record format     %===>_MXRCF   +   (VARIABLE-VAR-V or FIXED-FIX-F)\n+                                      The logical record length is 80 with\n+                                      the sequence number in 73-80 if fixed\n+                                      or in 1-8 if variable.\n+\n)INIT\n  .HELP = PAJTMX0\n  .CURSOR = MXVOL\n  &ZCMD = &Z\n  &MXVOL = 'USER00'                /* DEFAULT VOLUME SERIAL NUMBER */\n)PROC\n  VER (&MXVOL,NONBLANK)  VER (&MXVOL,NAME)\n  VER (&MXUNM,NONBLANK)\n  &MXSPU = TRANS (&MXSPU C,CYLINDERS T,TRACKS\n                         CYL,CYLINDERS TRK,TRACKS\n                         CYLS,CYLINDERS TRKS,TRACKS\n                         CYLINDER,CYLINDERS TRACK,TRACKS\n                         CYLINDERS,CYLINDERS TRACKS,TRACKS *,*)\n  VER (&MXSPU,LIST,CYLINDERS,TRACKS)\n  VER (&MXSP1,NUM)\n  VER (&MXSP1,RANGE,1,32760)\n  VER (&MXSP2,NUM)\n  VER (&MXSP2,RANGE,1,32760)\n  VER (&MXDIR,NUM)\n  VER (&MXDIR,RANGE,1,32760)\n  &MXRCF = TRANS (&MXRCF V,VARIABLE F,FIXED\n                         VAR,VARIABLE FIX,FIXED\n                         VARIABLE,VARIABLE FIXED,FIXED *,*)\n  VER (&MXRCF,LIST,VARIABLE,FIXED)\n  VPUT (MXVOL MXUNM MXSPU MXSP1 MXSP2 MXDIR MXRCF) PROFILE\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJM99": {"ttr": 25607, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x0f\\x00\\x89%\\x0f\\t)\\x00U\\x00U\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-07T00:00:00", "modifydate": "1989-09-07T09:29:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "SYSPAJA"}, "text": "PAJM991N 'Table not found' .ALARM=YES\n'MAIL-LIST table does not exist (must be created).'\nPAJM991R 'Table in use' .ALARM=YES\n'MAIL-LIST table is in use by another user.'\nPAJM991S 'Catastrophic error' .ALARM=YES\n'Error creating MAIL-LIST table. Return code was &RC..'\nPAJM991T 'MAIL-LIST created' .ALARM=YES\n'MAIL-LIST table was not found and has been created (empty).'\nPAJM991U 'MAIL-LIST error' .ALARM=YES\n'Unable to allocate the MAIL-LIST table data-set.'\n\nPAJM992C 'Updates not saved' .ALARM=YES\n'MAIL-LIST utility ended through \"CANCEL\". Updates were not saved.'\nPAJM992N 'MAIL-LIST done'\n'MAIL-LIST ended normally. No updates were entered since last \"SAVE\".'\nPAJM992S 'Updates saved'\n'MAIL-LIST utility ended normally. Updates were saved.'\n\nPAJM993D 'Invalid destination' .ALARM=YES\n'Invalid print destination. Enter it as U## or R## (e.g. R14).'\nPAJM993E 'Invalid command' .ALARM=YES\n'Valid commands : INPUT, CANCEL, MAILBOX, LIST, END, HELP or SAVE.'\nPAJM993L 'Invalid command' .ALARM=YES\n'Enter a valid line command : D, U, R, M, B, or L.'\nPAJM993P 'Print complete'\n'The MAIL-LIST has been sent for printing.'\nPAJM993S 'Invalid SORT field' .ALARM=YES\n'Valid SORT fields : MAIL, DATE, FIELD, AUTHOR.'\nPAJM993T 'Disabled command' .ALARM=YES\n'MAIL-LIST table updates not declared at invocation.'\n\nPAJM994D 'Invalid date' .ALARM=YES\n'Enter date as \"DDMMMYY\" (e.g. 01JAN85) or leave it blank.'\nPAJM994N 'Update not saved'\n'Update to mail-box entry \"&MXNUM\" has been canceled.'\nPAJM994S 'Update saved'\n'Update to mail-box entry \"&MXNUM\" has been saved.'\n\nPAJM995R 'MAIL-LIST sorted'\n'The current MAIL-LIST has been sorted using the SORT fields shown.'\nPAJM995S 'MAIL-LIST saved'\n'The current MAIL-LIST has been saved. You may continue updating.'\n\nPAJM996N 'Data not saved'\n'No updates to MAILBOX entry \"&MXNUM.\".'\nPAJM996S 'Updates saved'\n'The updates to MAILBOX entry for \"&MXNUM.\" have been saved.'\nPAJM996T 'Unable to EDIT' .ALARM=YES\n'Error editing mail-boxes data-set (can be no member).'\n\nPAJM997N 'Unable to BROWSE' .ALARM=YES\n'Error browsing mail-boxes data-set (can be no member).'\nPAJM997S 'Browse done'\n'The mail-box entry for \"&MXNUM.\" has been browsed.'\nPAJM997X 'List done'\n'The mail-box entry for \"&MXNUM.\" has been listed.'\n\nPAJM998C 'CLSE-I/RC=&RCLC' .ALARM=YES\n'&ZERRLM'\nPAJM998D 'CLSE-O/RC=&RCLC' .ALARM=YES\n'&ZERRLM'\nPAJM998E 'Unable to ALLOC' .ALARM=YES\n'Unable to allocate data-set for mail-boxes entries.'\nPAJM998G 'FREE-O/RC=&RCLC' .ALARM=YES\n'&ZERRLM'\nPAJM998I 'INIT-I/RC=&RCLC' .ALARM=YES\n'&ZERRLM'\nPAJM998J 'INIT-O/RC=&RCLC' .ALARM=YES\n'&ZERRLM'\nPAJM998N 'FIND-I/RC=&RCLC' .ALARM=YES\n'&ZERRLM'\nPAJM998O 'OPEN-I/RC=&RCLC' .ALARM=YES\n'&ZERRLM'\nPAJM998P 'OPEN-O/RC=&RCLC' .ALARM=YES\n'&ZERRLM'\nPAJM998R 'READ-I/RC=&RCLC' .ALARM=YES\n'&ZERRLM'\nPAJM998W 'WRTE-O/RC=&RCLC' .ALARM=YES\n'&ZERRLM'\nPAJM998X 'PAJPMX/RC=&RCLC' .ALARM=YES\n'Analyze RC for reason (format B''AAABBBCCCDDD'').'\nPAJM998Y 'EDIT canceled' .ALARM=YES\n'Edit to decrypt data of mail-box entry \"&MXNUM\" has been canceled.'\nPAJM998Z 'EDIT/RC=&RCLC' .ALARM=YES\n'Edit to decrypt data of mail-box entry \"&MXNUM\" has failed.'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJPALL": {"ttr": 25610, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x901\\x7f\\x00\\x901\\x7f\\x17 \\x02\\x82\\x02\\x82\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-11-13T00:00:00", "modifydate": "1990-11-13T17:20:00", "lines": 642, "newlines": 642, "modlines": 0, "user": "SYSPAJA"}, "text": "PALL     TITLE 'PAJPALL - DISPLAY USER DATA-SETS.'\nPAJPALL  START 0\n         SPACE 1\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*                                                                     *\n* MODULE NAME = ALLOCMOD (RENAMED PAJPALL)                        -EU-*\n*                                                                     *\n* DESCRIPTIVE NAME = DISPLAYS INFORMATION FOR DATA SETS ALLOCATED TO  *\n*                    A TSO USER.                                      *\n*                                                                     *\n* FUNCTION =    THIS PROGRAM WILL DISPLAY INFORMATION FOR DATA SETS   *\n*               ALLOCATED TO A TSO USER. INFORMATION IS EXTRACTED     *\n*               FROM THE TIOT, JFCB AND FORMAT1 DSCB.                 *\n*               OPERATION =                                           *\n*                  GETMAIN WORK AREAS                                 *\n*                  DEFINE DIALOG VARIABLES                            *\n*                  CREATE TEMPORARY TABLE AND SET CRP TO TOP          *\n*                  ESTABLISH ADDRESSABILITY TO THE TIOT               *\n*                  LOOP THRU DDNAME ENTRIES FOUND IN THE TIOT         *\n*                    OBTAIN DSCB FOR NEEDED ENTRIES                   *\n*                    CONSTRUCT TABLE ENTRIES USING INFORMATION        *\n*                      FROM THE TIOT, JFCB AND FORMAT1 DSCB           *\n*                  DISPLAY THE TEMPORARY TABLE                        *\n*                    IF ENTER HIT, CONTINUE DISPLAY                   *\n*                    IF END HIT, FINISH                               *\n*                  CLOSE (DELETE) TEMPORARY TABLE                     *\n*                  FREE GETMAIN'ED AREAS                              *\n*                  EXIT                                               *\n*                                                                     *\n*               NOTES =                                               *\n*                  REGISTER CONVENTIONS = STANDARD CONVENTIONS.       *\n*                    REGISTERS 0 TO 1  = WORK REGISTERS               *\n*                    REGISTER  2       = ADDRESSABILITY TO TIOT       *\n*                    REGISTER  3       = ADDRESSABILITY TO JFCB/DSCB  *\n*                    REGISTER  4       = LENGTH OF TIOT DD ENTRY      *\n*                    REGISTERS 5, 6    = WORK REGISTERS               *\n*                    REGISTERS 7, 8    = UNUSED REGISTERS             *\n*                    REGISTER  9       = MAX TIOT DD ENTRIES PROCESSED*\n*                    REGISTER  10      = ADDRESSABILITY TO GETMAINED  *\n*                                        WORK AREA                    *\n*                    REGISTER  11      = UNUSED REGISTER              *\n*                    REGISTER  12      = BASE ADDRESSABILITY          *\n*                    REGISTER  13      = SAVE AREA REGISTER           *\n*                    REGISTERS 14, 15  = WORK REGISTERS               *\n*               CHANGE ACTIVITY = 05/16/85 WRITTEN. JWC.              *\n*                                                                     *\n* ATTRIBUTES =  RE-ENTRANT, RE-USABLE & RE-FRESHABLE                  *\n*                                                                     *\n* ORIGIN =      EXTRACTED FROM TAPE CBT 90 MAY, FILE 53-54-55.        *\n*               ADAPTED BY MOINIL P.A.                            -EU-*\n*                                                                     *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         EJECT\n        $DEFREG\n         SPACE 1\n*------- INITIALIZATION SECTION\n*              (GETMAIN WORKAREA AND SAVE AREA CHAINING)\n         AIF   ('&SYSPARM' EQ 'FULL').N1\n        PRINT NOGEN\n.N1      SPACE 1\n        $XENT  BASE=R12,LV=WORKLEN,TYPE=RENT\n         LR    R10,R13                 ESTABLISH ADDRESSABILITY TO\n         USING WORKAREA,R10            DYNAMIC WORKAREA\n         EJECT\n*------- INITIALIZATION SECTION\n*              (SET DIALOG CONTROL, DEFINE VARIABLES)\n         SPACE 1\n*                                      SET DIALOG CONTROL\n         CALL  ISPLINK,(CNTRL,CNTRL1,CNTRL2),                          X\n               VL,MF=(E,PARMS)\n         B     VCTL10(R15)             CHECK RETURN CODE\nVCTL10   B     VDEF00                  RC = 00 (CONTINUE)\n         B     CTLERR04                RC = 04 (NOT VALID FOR CONTROL)\n         B     CTLERR08                RC = 08 (DISPLAY PANEL / MSG)\n         B     CTLERR12                RC = 12 (NOT VALID FOR CONTROL)\n         B     CTLERR16                RC = 16 (NOT VALID FOR CONTROL)\n         B     CTLERR20                RC = 20 (DISPLAY PANEL / MSG)\n*                                      DEFINE VARIABLES\nVDEF00   CALL  ISPLINK,(VDFN,DEFLIST1,ALRECFM,TYPEC,LEN4),             X\n               VL,MF=(E,PARMS)\n         LTR   R15,R15                 DEFINE SUCCESSFUL?\n         BZ    *+L'*+4                 YES, CONTINUE DEFINE\n         B     VDEF10(R15)             CHECK RETURN CODE\n         CALL  ISPLINK,(VDFN,DEFLIST2,ALDISP,TYPEC,LEN5),              X\n               VL,MF=(E,PARMS)\n         LTR   R15,R15                 DEFINE SUCCESSFUL?\n         BZ    *+L'*+4                 YES, CONTINUE DEFINE\n         B     VDEF10(R15)             CHECK RETURN CODE\n         CALL  ISPLINK,(VDFN,DEFLIST3,ALDSN,TYPEC,LEN30),              X\n               VL,MF=(E,PARMS)\n         LTR   R15,R15                 DEFINE SUCCESSFUL?\n         BZ    *+L'*+4                 YES, CONTINUE DEFINE\n         B     VDEF10(R15)             CHECK RETURN CODE\n         CALL  ISPLINK,(VDFN,DEFLIST4,ALDDNAM,TYPEC,LEN8),             X\n               VL,MF=(E,PARMS)\n         B     VDEF10(R15)             CHECK RETURN CODE\nVDEF10   B     TBCREAT                 RC = 00 (CONTINUE)\n         B     DEFERR04                RC = 04 (NOT VALID FOR VDEF)\n         B     DEFERR08                RC = 08 (DISPLAY PANEL / MSG)\n         B     DEFERR12                RC = 12 (NOT VALID FOR VDEF)\n         B     DEFERR16                RC = 16 (DISPLAY PANEL / MSG)\n         B     DEFERR20                RC = 20 (DISPLAY PANEL / MSG)\n         EJECT\n*------- INITIALIZATION SECTION\n*              (CREATE TEMPORARY TABLE AND POINT TO TOP)\n         SPACE 1\n*                                      CREATE TABLE\nTBCREAT  CALL  ISPLINK,(TBCRT,TBNME,NONE,NAMELST,NOWRT,REPLC),         X\n               VL,MF=(E,PARMS)\n         B     TBCREA10(R15)           CHECK RETURN CODE\nTBCREA10 B     TBTOP                   RC = 00 (CONTINUE)\n         B     TBTOP                   RC = 04 (CONTINUE)\n         B     CREERR08                RC = 08 (DISPLAY PANEL / MSG)\n         B     CREERR12                RC = 12 (DISPLAY PANEL / MSG)\n         B     CREERR16                RC = 16 (DISPLAY PANEL / MSG)\n         B     CREERR20                RC = 20 (DISPLAY PANEL / MSG)\n*                                      POSITION CRP AT TOP OF TABLE\nTBTOP    CALL  ISPLINK,(TBLTP,TBNME),                                  X\n               VL,MF=(E,PARMS)\n         B     TBTOP10(R15)            CHECK RETURN CODE\nTBTOP10  B     SETOBTAN                RC = 00 (CONTINUE)\n         B     TOPERR04                RC = 04 (NOT VALID FOR TBTOP)\n         B     TOPERR08                RC = 08 (NOT VALID FOR TBTOP)\n         B     TOPERR12                RC = 12 (DISPLAY PANEL / MSG)\n         B     TOPERR16                RC = 16 (NOT VALID FOR TBTOP)\n         B     TOPERR20                RC = 20 (DISPLAY PANEL / MSG)\n         SPACE 1\n*------- INITIALIZATION SECTION\n*              (CREATE PARAMETER LIST FOR 'OBTAIN')\n         SPACE 1\n*                                      PARAMETER LIST FOR OBTAIN\nSETOBTAN MVC   OBTANLST(CAMLL),CAML    SET LIST FOR DSN SEARCH\n         LA    R1,ALDSN1               ADDRESS OF FULL DSNAME\n         ST    R1,OBTANLST+4\n         LA    R1,ALVOL                ADDRESS OF VOLUME SERIAL\n         ST    R1,OBTANLST+8\n         LA    R1,WORK                 ADDRESS OF 160 BYTE WORK AREA\n         ST    R1,OBTANLST+12\n         OI    OBTANLST+12,X'80'       INDICATE LAST PARAMETER IN LIST\n         SPACE 1\n*------- INITIALIZATION SECTION\n*              (ESTABLISH ADDRESSABILITY TO TIOT DD ENTRY)\n         SPACE 1\n         L     R2,CVTPTR               R2 - ADDRESS OF CVT\n         USING CVT,R2\n         L     R2,CVTTCBP              R2 - ADDR OF TCB/ASCB ADDR LIST\n         DROP  R2\n         L     R2,4(R2)                R2 - ADDRESS OF CURRENT TCB\n         USING TCB,R2\n         L     R2,TCBTIO               R2 - ADDRESS OF TIOT (BEGINNING)\n         DROP  R2\n         USING TIOT,R2\n         LA    R2,TIOENTRY             R2 - ADDR OF TIOT (DD ENTRY)\n         DROP  R2\n         USING TIOENTRY,R2\n         LA    R9,400                  R9 - SET MAX NUMBER TO LOOP\n         EJECT\n*------- PROCESSING SECTION\n*              (EXTRACT DDNAME, VOLSER AND DSN)\n         SPACE 1\nLOADTBL  XR    R4,R4                   R4 - LENGTH OF TIOT DD ENTRY\n         ICM   R4,B'0001',TIOELNGH     LOAD LENGTH OF ENTRY\n         BZ    DISPL1                  IF ZERO, DISPLAY TABLE\n         NI    SWITCH,255-DSNFLG       INITIALIZE DSN FLAG\n         MVC   ALDDNAM(L'ALDDNAM),=CL30' ' INITIALIZE ALLOCATED DDNAME\n         MVC   ALDSN(L'ALDSN),=CL30' ' INITIALIZE ALLOCATED DSN(1ST 30)\n         MVC   ALDSN1(L'ALDSN1),=CL30' ' INIT. ALLOCATED DSN(1ST 30)\n         MVC   ALDSN2(L'ALDSN2),=CL30' ' INIT. ALLOCATED DSN(END)\n         MVC   ALDISP(L'ALDISP),=CL30' ' INITIALIZE ALLOCATED DISP\n         MVC   ALDSORG(L'ALDSORG),=CL30' ' INITIALIZE ALLOCATED DSORG\n         MVC   ALRECFM(L'ALRECFM),=CL30' ' INITIALIZE ALLOCATED RECFM\n         MVC   ALBLKSZ(L'ALBLKSZ),=CL30' ' INIT. ALLOCATED BLKSIZE\n         MVC   ALRECL(L'ALRECL),=CL30' ' INITIALIZE ALLOCATED LRECL\n         MVC   ALVOL(L'ALVOL),=CL30' ' INITIALIZE ALLOCATED VOLSER\n         TM    TIOESTTA,TIOSLTYP       HAS THIS TIOT ENTRY BEEN FREED?\n         BO    NEXTIOT                 YES, PROCEED TO NEXT TIOT ENTRY\n         MVC   ALDDNAM,TIOEDDNM        GET DDNAME FROM TIOT\n         XR    R3,R3                   FIRST BYTE TO '00', ADJUST\n         ICM   R3,B'0111',TIOEJFCB     R3 - ADDRESS OF JFCB\n         USING ZB502,R3                ESTABLISH JFCB ADDRESSABILITY\n         MVC   ALVOL(L'ALVOL),JFCBVOLS GET VOLSER FROM JFCB\n         MVC   ALDSN(L'ALDSN),JFCBDSNM GET 1ST 30 CHARACTERS OF DSN\n         MVC   ALDSN1(L'ALDSN1),JFCBDSNM GET 1ST 30 CHARACTERS OF DSN\n         MVC   ALDSN2(L'ALDSN2),JFCBDSNM+L'ALDSN GET LAST 14 CHAR.DSN\n         CLC   ALDSN2(L'ALDSN2),=CL30' ' DSN LONGER THAN 30 CHARACTERS?\n         BE    CHKDISP                 NO, GET DISPOSITION\n         OI    SWITCH,DSNFLG           YES, SET DSN FLAG\n         SPACE 1\n*------- PROCESSING SECTION\n*              (WRITE FIRST 30 CHAR OF DSN TO TABLE)\n         SPACE 1\n         MVC   VOLSAVE,ALVOL           SAVE VOLSER FOR NEXT LINE\n         MVC   ALVOL(L'ALVOL),=CL30' ' CLEAR VOLSER FOR THIS LINE\n         LA    R6,ALDSN1+L'ALDSN1-1    R6 - POINT TO END OF ALDSN1\n         LA    R5,8                    R5 - MAX NUM OF CHAR TO VIEW\nFINDEND  CLC   0(1,R6),=CL1'.'         IS THIS THE END OF LAST SEGMENT?\n         BE    FOUNDIT                 YES, SAVE IT TO BE ADDED TO NEXT\n         BCTR  R6,0                    POINT AT PREVIOUS POSITION\n         BCT   R5,FINDEND              GO CHECK FOR SEGMENT END\nFOUNDIT  MVC   ALDSN(L'ALDSN),=CL30' ' CLEAR ALDSN TO PREPARE FOR MOVE\n         LA    R1,ALDSN1               FIND NUMBER OF CHARACTERS\n         SLR   R6,R1                       TO BE MOVED FROM\n         EX    R6,*+L'*+4                      ALDSN1 TO ALDSN\n         B     REPLACE\n         MVC   ALDSN(*-*),ALDSN1       MOVE FIRST PART OF DSN\n         EJECT\n*------- PROCESSING SECTION\n*              (DISP, DSORG, RECFM, LRECL & BLKSIZE FROM JFCB)\n         SPACE 1\nCHKDISP  TM    JFCBIND2,JFCSHARE       DISPOSITION SHR?\n         BZ    *+L'*+10                NO, CHECK TEMP\n         MVC   ALDISP(4),=CL4'SHR'     YES, SET DISP TO SHR\n         B     CHKDSOR1                GO CHECK DSORG\n         TM    JFCBIND2,JFCTEMP        DISPOSITION TEMP?\n         BZ    *+L'*+10                NO, CHECK NEW\n         MVC   ALDISP(4),=CL4'TEMP'    YES, SET DISP TO TEMP\n         B     CHKDSOR1                GO CHECK DSORG\n         TM    JFCBIND2,JFCNEW         DISPOSITION NEW?\n         BNO   *+L'*+10                NO, CHECK MOD\n         MVC   ALDISP(4),=CL4'NEW'     YES, SET DISP TO NEW\n         B     CHKDSOR1                GO CHECK DSORG\n         TM    JFCBIND2,JFCMOD         DISPOSITION MOD?\n         BZ    *+L'*+10                NO, CHECK OLD\n         MVC   ALDISP(4),=CL4'MOD'     YES, SET DISP TO MOD\n         B     CHKDSOR1                GO CHECK DSORG\n         TM    JFCBIND2,JFCOLD         DISPOSITION OLD?\n         BZ    *+L'*+10                NO, SET DISP\n         MVC   ALDISP(4),=CL4'OLD'     YES, SET DISP TO OLD\n         B     CHKDSOR1                GO CHECK DSORG\n         MVC   ALDISP(4),=CL4'????'    SET DISP TO ????\nCHKDSOR1 TM    JFCDSRG2,JFCORGAM       DSORG VSAM?\n         BZ    *+L'*+10                NO, CHECK INDEXED SEQUENTIAL\n         MVC   ALDSORG(2),=CL2'VS'     YES, SET DSORG TO VS\n         B     CHKRCF1                 GO CHECK RECFM\n         TM    JFCDSRG1,JFCORGIS       DSORG INDEXED SEQUENTIAL?\n         BZ    *+L'*+10                NO, CHECK PHYSICAL SEQUENTIAL\n         MVC   ALDSORG(2),=CL2'IS'     YES, SET DSORG TO IS\n         B     CHKFMT1                 GO CHECK UNMOVABLE\n         TM    JFCDSRG1,JFCORGPS       DSORG PHYSICAL SEQUENTIAL?\n         BZ    *+L'*+10                NO, CHECK DIRECT ACCESS\n         MVC   ALDSORG(2),=CL2'PS'     YES, SET DSORG TO PS\n         B     CHKFMT1                 GO CHECK UNMOVABLE\n         TM    JFCDSRG1,JFCORGDA       DSORG DIRECT ACCESS?\n         BZ    *+L'*+10                NO, CHECK PARTITIONED\n         MVC   ALDSORG(2),=CL2'DA'     YES, SET DSORG TO DA\n         B     CHKFMT1                 GO CHECK UNMOVABLE\n         TM    JFCDSRG1,JFCORGPO       DSORG PARTITIONED?\n         BZ    OBTAINIT                NO, OBTAIN FORMAT 1 DSCB\n         MVC   ALDSORG(2),=CL2'PO'     YES, SET DSORG TO PO\nCHKFMT1  TM    JFCDSRG1,JFCORGU        DSORG UNMOVABLE?\n         BZ    CHKRCF1                 NO, CHECK RECFM\n         MVI   ALDSORG+2,C'U'          YES, ADD DSORG U\nCHKRCF1  TM    JFCRECFM,JFCUND         RECFM UNDEFINED?\n         BNO   *+L'*+8                 NO, CHECK FIXED\n         MVI   ALRECFM,C'U'            YES, SET RECFM TO U\n         B     CHKS1                   GO CHECK SPANNED\n         TM    JFCRECFM,JFCFIX         RECFM FIXED?\n         BZ    *+L'*+8                 NO, CHECK VARIABLE\n         MVI   ALRECFM,C'F'            YES, SET RECFM TO F\n         B     CHKB1                   GO CHECK BLOCKED\n         TM    JFCRECFM,JFCVAR         RECFM VARIABLE?\n         BZ    OBTAINIT                NO, OBTAIN FORMAT 1 DSCB\n         MVI   ALRECFM,C'V'            YES, SET RECFM TO V\nCHKB1    TM    JFCRECFM,JFCRFB         RECFM BLOCKED?\n         BZ    CHKS1                   NO, CHECK SPANNED\n         MVI   ALRECFM+1,C'B'          YES, SET RECFM TO B\nCHKS1    TM    JFCRECFM,JFCRFS         RECFM SPANNED?\n         BZ    *+L'*+8                 NO, CHECK ASA CONTROL\n         MVI   ALRECFM+2,C'S'          YES, SET RECFM TO S\n         B     GETBLK1                 GET MAX BLOCK SIZE\n         TM    JFCRECFM,JFCASA         RECFM ASA CONTROL?\n         BZ    *+L'*+8                 NO, CHECK MACHINE CODE CONTROL\n         MVI   ALRECFM+2,C'A'          YES, SET RECFM TO A\n         B     GETBLK1                 GET MAX BLOCK SIZE\n         TM    JFCRECFM,JFCMAC         RECFM MACHINE CODE CONTROL?\n         BZ    GETBLK1                 NO, GET MAX BLOCK SIZE\n         MVI   ALRECFM+2,C'M'          YES, SET RECFM TO M\nGETBLK1  XR    R1,R1\n         ICM   R1,B'0011',JFCBLKSI     LOAD BLOCK SIZE FROM JFCB\n         CVD   R1,DEC                  CONVERT TO DECIMAL\n         MVC   CONV,=XL6'402020202020' MOVE EDIT PATTERN TO WORK AREA\n         ED    CONV,DEC+5              CONVERT TO ZONED\n         MVC   ALBLKSZ(L'ALBLKSZ),CONV+1 MOVE TO OUTPUT AREA\n         XR    R1,R1\n         ICM   R1,B'0011',JFCLRECL     LOAD LOGICAL REC LEN FROM JFCB\n         CVD   R1,DEC                  CONVERT TO DECIMAL\n         MVC   CONV,=XL6'402020202020' MOVE EDIT PATTERN TO WORK AREA\n         ED    CONV,DEC+5              CONVERT TO ZONED\n         MVC   ALRECL(L'ALRECL),CONV+1 MOVE TO OUTPUT AREA\n         DROP  R3                      DROP JFCB ADDRESSABILITY\n         B     REPLACE\n         EJECT\n*------- PROCESSING SECTION\n*              (DISP, DSORG, RECFM, LRECL & BLKSIZE FROM DSCB)\n         SPACE 1\nOBTAINIT OBTAIN OBTANLST               GET DSCB1 INFORMATION\n         LTR   R15,R15                 INFORMATION RETURNED?\n         BNZ   REPLACE                 NO, WRITE OUT INFO AND CONTINUE\n         LA    R3,WORK\n         USING DS1FMTID,R3\n         TM    DS1DSORG+1,DS1ORGAM     DSORG VSAM?\n         BZ    *+L'*+10                NO, CHECK INDEXED SEQUENTIAL\n         MVC   ALDSORG(2),=CL2'VS'     YES, SET DSORG TO VS\n         B     CHKRCF2                 GO CHECK RECFM\n         TM    DS1DSORG,DS1DSGIS       DSORG INDEXED SEQUENTIAL?\n         BZ    *+L'*+10                NO, CHECK PHYSICAL SEQUENTIAL\n         MVC   ALDSORG(2),=CL2'IS'     YES, SET DSORG TO IS\n         B     CHKFMT2                 GO CHECK UNMOVABLE\n         TM    DS1DSORG,DS1DSGPS       DSORG PHYSICAL SEQUENTIAL?\n         BZ    *+L'*+10                NO, CHECK DIRECT ACCESS\n         MVC   ALDSORG(2),=CL2'PS'     YES, SET DSORG TO PS\n         B     CHKFMT2                 GO CHECK UNMOVABLE\n         TM    DS1DSORG,DS1DSGDA       DSORG DIRECT ACCESS?\n         BNO   *+L'*+10                NO, CHECK PARTITIONED\n         MVC   ALDSORG(2),=CL2'DA'     YES, SET DSORG TO DA\n         B     CHKFMT2                 GO CHECK UNMOVABLE\n         TM    DS1DSORG,DS1DSGPO       DSORG PARTITIONED?\n         BZ    CHKFMT2                 NO, CHECK UNMOVABLE\n         MVC   ALDSORG(2),=CL2'PO'     YES, SET DSORG TO PO\nCHKFMT2  TM    DS1DSORG,DS1DSGU        DSORG UNMOVABLE?\n         BZ    CHKRCF2                 NO, CHECK RECFM\n         MVI   ALDSORG+2,C'U'          YES, ADD DSORG U\nCHKRCF2  TM    DS1RECFM,DS1RECFU       RECFM UNDEFINED?\n         BNO   *+L'*+8                 NO, CHECK FIXED\n         MVI   ALRECFM,C'U'            YES, SET RECFM TO U\n         B     CHKS2                   GO CHECK SPANNED\n         TM    DS1RECFM,DS1RECFF       RECFM FIXED?\n         BZ    *+L'*+8                 NO, CHECK VARIABLE\n         MVI   ALRECFM,C'F'            YES, SET RECFM TO F\n         B     CHKB2                   GO CHECK BLOCKED\n         TM    DS1RECFM,DS1RECFV       RECFM VARIABLE?\n         BZ    CHKB2                   NO, CHECK FOR BLOCKED\n         MVI   ALRECFM,C'V'            YES, SET RECFM TO V\nCHKB2    TM    DS1RECFM,DS1RECFB       RECFM BLOCKED?\n         BZ    CHKS2                   NO, CHECK SPANNED\n         MVI   ALRECFM+1,C'B'          YES, SET RECFM TO B\nCHKS2    TM    DS1RECFM,DS1RECFS       RECFM SPANNED?\n         BZ    *+L'*+8                 NO, CHECK ASA CONTROL\n         MVI   ALRECFM+2,C'S'          YES, SET RECFM TO S\n         B     GETBLK2                 GET MAX BLOCK SIZE\n         TM    DS1RECFM,DS1RECFA       RECFM ASA CONTROL?\n         BZ    *+L'*+8                 NO, CHECK MACHINE CODE CONTROL\n         MVI   ALRECFM+2,C'A'          YES, SET RECFM TO A\n         B     GETBLK2                 GET MAX BLOCK SIZE\n         TM    DS1RECFM,DS1RECMC       RECFM MACHINE CODE CONTROL?\n         BZ    GETBLK2                 NO, GET MAX BLOCK SIZE\n         MVI   ALRECFM+2,C'M'          YES, SET RECFM TO M\nGETBLK2  XR    R1,R1\n         ICM   R1,B'0011',DS1BLKL      LOAD BLOCK SIZE FROM DSCB1\n         CVD   R1,DEC                  CONVERT TO DECIMAL\n         MVC   CONV,=XL6'402020202020' MOVE EDIT PATTERN TO WORK AREA\n         ED    CONV,DEC+5              CONVERT TO ZONED\n         MVC   ALBLKSZ(L'ALBLKSZ),CONV+1 MOVE TO OUTPUT AREA\n         XR    R1,R1\n         ICM   R1,B'0011',DS1LRECL     LOAD LOGICAL REC LEN FROM DSCB1\n         CVD   R1,DEC                  CONVERT TO DECIMAL\n         MVC   CONV,=XL6'402020202020' MOVE EDIT PATTERN TO WORK AREA\n         ED    CONV,DEC+5              CONVERT TO ZONED\n         MVC   ALRECL(L'ALRECL),CONV+1 MOVE TO OUTPUT AREA\n         DROP  R3\n         EJECT\n*------- PROCESSING SECTION\n*              (REPLACE VARIABLES AND ADD TO TABLE)\n         SPACE 1\n*                                      REPLACE VARIABLE VALUES\nREPLACE  CALL  ISPLINK,(VRPLC,NAMELST,LENLST1,ALRECFM),                X\n               VL,MF=(E,PARMS)\n         B     VREP10(R15)             CHECK RETURN CODE\nVREP10   B     TBADD                   RC = 00 (CONTINUE)\n         B     REPERR04                RC = 04 (NOT VALID FOR VREPLACE)\n         B     REPERR08                RC = 08 (NOT VALID FOR VREPLACE)\n         B     REPERR12                RC = 12 (NOT VALID FOR VREPLACE)\n         B     REPERR16                RC = 16 (DISPLAY PANEL / MSG)\n         B     REPERR20                RC = 20 (DISPLAY PANEL / MSG)\n*                                      ADD VARIABLES TO TABLE\nTBADD    CALL  ISPLINK,(TBLAD,TBNME),                                  X\n               VL,MF=(E,PARMS)\n         B     TBADD10(R15)            CHECK RETURN CODE\nTBADD10  B     TESTDSN                 RC = 00 (CONTINUE)\n         B     ADDERR04                RC = 04 (NOT VALID FOR TBADD)\n         B     ADDERR08                RC = 08 (DISPLAY PANEL / MSG)\n         B     ADDERR12                RC = 12 (DISPLAY PANEL / MSG)\n         B     ADDERR16                RC = 16 (DISPLAY PANEL / MSG)\n         B     ADDERR20                RC = 20 (DISPLAY PANEL / MSG)\n         SPACE 1\n*------- PROCESSING SECTION\n*              (WRITE REMAINDER OF DSN TO TABLE)\n         SPACE 1\nTESTDSN  TM    SWITCH,DSNFLG           DSN LONGER THAN 30 CHARACTERS?\n         BZ    NEXTIOT                 NO, POINT TO NEXT TIOT ENTRY\n         MVC   ALDSN(L'ALDSN),=CL30' ' CLEAR ALDSN\n         LA    R6,ALDSN1(R6)           RESET R6\n         LA    R1,8                    DETERMINE NUMBER OF CHARACTERS\n         SR    R1,R5                       TO BE ADDED TO ALDSN2\n         BNP   SKIPMOVE                NO CHARACTERS TO BE MOVED\n         LA    R6,1(R6)                POINT TO SEGMENT TO BE MOVED\n         BCT   R1,*+L'*+6              DECREMENT R1 FOR MOVE\n         MVC   ALDSN+4(*-*),0(R6)      MOVE SECOND PART OF DSN\n         EX    R1,*-6                  MOVE SEGMENT ALDSN1 TO ALDSN\nSKIPMOVE LA    R6,ALDSN+4(R1)          SKIP PAST SEGMENT FROM ALDSN1\n         MVC   1(L'ALDSN2,R6),ALDSN2   MOVE ALDSN2 TO ALDSN\n         MVC   ALDDNAM(L'ALDDNAM),=CL30' ' CLEAR DDNAME FOR NEXT LINE\n         MVC   ALVOL,VOLSAVE           RESTORE ALVOL\n         NI    SWITCH,255-DSNFLG       RESTORE DSNFLG\n         B     CHKDISP                 GET MORE INFORMATION\nNEXTIOT  AR    R2,R4                   POINT TO NEXT DD ENTRY OF TIOT\n         BCT   R9,LOADTBL              CONTINUE TO LOAD TABLE\n         DROP  R2\n         EJECT\n*------- DISPLAY SECTION\n*              (TOP OF TABLE AND DISPLAY USING 'PAJALL' PANEL)\n         SPACE 1\n*                                      POSITION CRP AT TOP OF TABLE\nDISPL1   CALL  ISPLINK,(TBLTP,TBNME),                                  X\n               VL,MF=(E,PARMS)\n         B     TBTOP20(R15)            CHECK RETURN CODE\nTBTOP20  B     DISPL2                  RC = 00 (CONTINUE)\n         B     TOPERR04                RC = 04 (NOT VALID FOR TBTOP)\n         B     TOPERR08                RC = 08 (NOT VALID FOR TBTOP)\n         B     TOPERR12                RC = 12 (DISPLAY PANEL / MSG)\n         B     TOPERR16                RC = 16 (NOT VALID FOR TBTOP)\n         B     TOPERR20                RC = 20 (DISPLAY PANEL / MSG)\n*                                      DISPLAY TABLE USING 'PAJALL'\nDISPL2   CALL  ISPLINK,(TBLDS,TBNME,TBPAN),                            X\n               VL,MF=(E,PARMS)\n         B     TBDIS10(R15)            CHECK RETURN CODE\nTBDIS10  B     DISPL2                  RC = 00 (CONTINUE)\n         B     DISPL2                  RC = 04 (CONTINUE)\n         B     FINISH                  RC = 08 (CONTINUE)\n         B     DISERR12                RC = 12 (DISPLAY PANEL / MSG)\n         B     DISERR16                RC = 16 (NOT VALID FOR TBDISPL)\n         B     DISERR20                RC = 20 (DISPLAY PANEL / MSG)\n         EJECT\n*------- ERROR PROCESSING SECTION\n         SPACE 1\nCTLERR04 MVI   ALMSGID2,C'A'           SET MESSAGE-ID\n         B     CTLERROP\nCTLERR08 MVI   ALMSGID2,C'B'           SET MESSAGE-ID\n         B     CTLERROP\nCTLERR12 MVI   ALMSGID2,C'C'           SET MESSAGE-ID\n         B     CTLERROP\nCTLERR16 MVI   ALMSGID2,C'D'           SET MESSAGE-ID\n         B     CTLERROP\nCTLERR20 MVI   ALMSGID2,C'E'           SET MESSAGE-ID\nCTLERROP MVI   ALMSGID1,C'0'           SET OPERATION MESSAGE-ID\n         B     DISPL3                  DISPLAY PANEL WITH MESSAGE\nADDERR04 MVI   ALMSGID2,C'A'           SET MESSAGE-ID\n         B     ADDERROP\nADDERR08 MVI   ALMSGID2,C'B'           SET MESSAGE-ID\n         B     ADDERROP\nADDERR12 MVI   ALMSGID2,C'C'           SET MESSAGE-ID\n         B     ADDERROP\nADDERR16 MVI   ALMSGID2,C'D'           SET MESSAGE-ID\n         B     ADDERROP\nADDERR20 MVI   ALMSGID2,C'E'           SET MESSAGE-ID\nADDERROP MVI   ALMSGID1,C'1'           SET OPERATION MESSAGE-ID\n         B     DISPL3                  DISPLAY PANEL WITH MESSAGE\nCREERR08 MVI   ALMSGID2,C'A'           SET MESSAGE-ID\n         B     CREERROP\nCREERR12 MVI   ALMSGID2,C'B'           SET MESSAGE-ID\n         B     CREERROP\nCREERR16 MVI   ALMSGID2,C'C'           SET MESSAGE-ID\n         B     CREERROP\nCREERR20 MVI   ALMSGID2,C'D'           SET MESSAGE-ID\nCREERROP MVI   ALMSGID1,C'2'           SET OPERATION MESSAGE-ID\n         B     DISPL3                  DISPLAY PANEL WITH MESSAGE\nDEFERR04 MVI   ALMSGID2,C'A'           SET MESSAGE-ID\n         B     DEFERROP\nDEFERR08 MVI   ALMSGID2,C'B'           SET MESSAGE-ID\n         B     DEFERROP\nDEFERR12 MVI   ALMSGID2,C'C'           SET MESSAGE-ID\n         B     DEFERROP\nDEFERR16 MVI   ALMSGID2,C'D'           SET MESSAGE-ID\n         B     DEFERROP\nDEFERR20 MVI   ALMSGID2,C'E'           SET MESSAGE-ID\nDEFERROP MVI   ALMSGID1,C'3'           SET OPERATION MESSAGE-ID\n         B     DISPL3                  DISPLAY PANEL WITH MESSAGE\nDISERR12 MVI   ALMSGID2,C'A'           SET MESSAGE-ID\n         B     DISERROP\nDISERR16 MVI   ALMSGID2,C'B'           SET MESSAGE-ID\n         B     DISERROP\nDISERR20 MVI   ALMSGID2,C'C'           SET MESSAGE-ID\nDISERROP MVI   ALMSGID1,C'4'           SET OPERATION MESSAGE-ID\n         B     DISPL3                  DISPLAY PANEL WITH MESSAGE\nREPERR04 MVI   ALMSGID2,C'A'           SET MESSAGE-ID\n         B     REPERROP\nREPERR08 MVI   ALMSGID2,C'B'           SET MESSAGE-ID\n         B     REPERROP\nREPERR12 MVI   ALMSGID2,C'C'           SET MESSAGE-ID\n         B     REPERROP\nREPERR16 MVI   ALMSGID2,C'D'           SET MESSAGE-ID\n         B     REPERROP\nREPERR20 MVI   ALMSGID2,C'E'           SET MESSAGE-ID\nREPERROP MVI   ALMSGID1,C'5'           SET OPERATION MESSAGE-ID\n         B     DISPL3                  DISPLAY PANEL WITH MESSAGE\nTOPERR04 MVI   ALMSGID2,C'A'           SET MESSAGE-ID\n         B     TOPERROP\nTOPERR08 MVI   ALMSGID2,C'B'           SET MESSAGE-ID\n         B     TOPERROP\nTOPERR12 MVI   ALMSGID2,C'C'           SET MESSAGE-ID\n         B     TOPERROP\nTOPERR16 MVI   ALMSGID2,C'D'           SET MESSAGE-ID\n         B     TOPERROP\nTOPERR20 MVI   ALMSGID2,C'E'           SET MESSAGE-ID\nTOPERROP MVI   ALMSGID1,C'6'           SET OPERATION MESSAGE-ID\nDISPL3   MVC   ALMSGID0,=CL6'PAJA00'   COMPLETE MESSAGE-ID\n*                                      DISPLAY TABLE USING 'PAJALL'\n         CALL  ISPLINK,(TBLDS,TBNME,TBPAN,ALMSGID),                    X\n               VL,MF=(E,PARMS)\n         SPACE 1\n*------- CLOSING SECTION\n*              (FREE GETMAINED AREA, SET RETURN CODE RESTORE REGS)\n         SPACE 1\n*                                      RELEASE AREA HELP BY TEMP TABLE\nFINISH   CALL  ISPLINK,(TBLEND,TBNME),                                 X\n               VL,MF=(E,PARMS)\n         DROP  R10\n        $XRET  CC=(R15),LV=WORKLEN,TYPE=RENT\n         EJECT\n*------- DATA CONSTANTS\n         SPACE 1\nCAML     CAMLST SEARCH,*-*,*-*,*-*\nCAMLL    EQU   *-CAML\n         SPACE 1\nCNTRL    DC    CL8'CONTROL'\nCNTRL1   DC    CL8'ERRORS'\nCNTRL2   DC    CL8'RETURN'\nVDFN     DC    CL8'VDEFINE'\nVRPLC    DC    CL8'VREPLACE'\nTBCRT    DC    CL8'TBCREATE'\nTBLTP    DC    CL8'TBTOP'\nTBLAD    DC    CL8'TBADD'\nTBLDS    DC    CL8'TBDISPL'\nTBLEND   DC    CL8'TBEND'\nTBNME    DC    CL8'WALLTBL'\nTBPAN    DC    CL8'PAJALL'\nNOWRT    DC    CL8'NOWRITE'\nREPLC    DC    CL8'REPLACE'\nNONE     DC    CL8' '\nTYPEC    DC    CL8'CHAR'\nLEN4     DC    F'4'\nLEN5     DC    F'5'\nLEN8     DC    F'8'\nLEN30    DC    F'30'\n         SPACE 1\n* NOTE - ALL FIELDS IN THE LISTS BELOW MUST BE IN THE SAME ORDER AS   *\n*        THEY ARE DEFINED IN 'NAMELST' VECTOR.                        *\n         SPACE 1\nDEFLIST1 DC    A(NDF1,0)               NAMES OF VARIABLES (LENGTH 4)\n         DC    CL8'WALFMT'\nNDF1     EQU   ((*-DEFLIST1)-(2*4))/8\n         SPACE 1\nDEFLIST2 DC    A(NDF2,0)               NAMES OF VARIABLES (LENGTH 5)\n         DC    CL8'WALDISP'\n         DC    CL8'WALDORG'\n         DC    CL8'WALBLK'\n         DC    CL8'WALRECL'\nNDF2     EQU   ((*-DEFLIST2)-(2*4))/8\n         SPACE 1\nDEFLIST3 DC    A(NDF3,0)               NAMES OF VARIABLES (LENGTH 30)\n         DC    CL8'WALDSN'\nNDF3     EQU   ((*-DEFLIST3)-(2*4))/8\n         SPACE 1\nDEFLIST4 DC    A(NDF4,0)               NAMES OF VARIABLES (LENGTH 8)\n         DC    CL8'WALDD'\n         DC    CL8'WALVOL'\nNDF4     EQU   ((*-DEFLIST4)-(2*4))/8\n         SPACE 1\nNAMELST  DC    A(NNME,0)               NAMES OF VARIABLES IN TABLE\n         DC    CL8'WALFMT'\n         DC    CL8'WALDISP'\n         DC    CL8'WALDORG'\n         DC    CL8'WALBLK'\n         DC    CL8'WALRECL'\n         DC    CL8'WALDSN'\n         DC    CL8'WALDD'\n         DC    CL8'WALVOL'\nNNME     EQU   ((*-NAMELST)-(2*4))/8\n         SPACE 1\nLENLST1  DS    0F                      LIST OF VARIABLE LENGTHS\n         DC    F'4'                    LENGTH OF RECFM\n         DC    F'5'                    LENGTH OF DISPOSITION\n         DC    F'5'                    LENGTH OF DSORG\n         DC    F'5'                    LENGTH OF BLKSIZE\n         DC    F'5'                    LENGTH OF LRECL\n         DC    F'30'                   LENGTH OF DSNAME-ONE\n         DC    F'8'                    LENGTH OF DD-NAME\n         DC    F'8'                    LENGTH OF VOLUME SERIAL\n         AIF   ('&SYSPARM' EQ 'FULL').N2\n        PRINT GEN\n.N2      EJECT\n*------- LITERAL POOL\n         SPACE 1\n         LTORG\n         SPACE 1\n*------- MACROS\n         SPACE 1\n        PRINT NOGEN\n        CVT    DSECT=YES,LIST=YES\n        IKJTCB LIST=YES\nTIOT     DSECT\n        IEFTIOT1\n        IEFZB502 , - - - - - - - -+\n        IEFJFCBN LIST=YES         +- SWA CONTROL BLOCK\nDSCDSECT DSECT\n        IECSDSL1 (1)\n         EJECT\n        PRINT GEN\n*------- DYNAMIC WORK AREA\n         SPACE 1\nWORKAREA DSECT\nSAVEAREA DS    18F                     PROGRAM SAVE AREA\nDEC      DS    D                       BINARY TO DECIMAL CONVERSION\nPARMS    CALL  ,(0,0,0,0,0,0),MF=L     PARM LIST FOR CALL ISPLINK\nOBTANLST CAMLST SEARCH,*-*,*-*,*-*     ADDR LIST FOR OBTAIN MACRO\nWORK     DS    0D,XL160                160 BYTE WORK AREA FOR OBTAIN\nCONV     DS    CL6                     DECIMAL TO ZONED CONVERSION\nSWITCH   DS    XL1                     FLAGS\nDSNFLG   EQU   X'80'                   FLAG SET IF DSN LONGER THAN 30\n         SPACE 1\n*- - - - - - - - NOTE - THE FIELDS BELOW MUST BE IN THE SAME ORDER AS *\n*                       THEY ARE DEFINED IN 'NAMELST' VECTOR.         *\nALRECFM  DS    CL4                     RECORD FORMAT OF ALLOCATED DSN *\nALDISP   DS    CL5                     DISPOSITION OF ALLOCATED DSN   *\nALDSORG  DS    CL5                     DATA SET ORGINIZATION OF DSN   *\nALBLKSZ  DS    CL5                     MAX BLCKSIZE OF ALLOCATED DSN  *\nALRECL   DS    CL5                     LOGICAL RECORD LENGTH OF DSN   *\nALDSN    DS    CL30                    1ST 30 CHAR OF ALLOCATED DSN   *\nALDDNAM  DS    CL8                     ALLOCATED DDNAME               *\nALVOL    DS    CL8                     VOLSER ON WHICH DSN RESIDES    *\n         SPACE 1\nALDSN1   DS    CL30                    1ST 30 CHAR OF ALLOCATED DSN\nALDSN2   DS    CL14                    NEXT 14 CHAR OF ALLOCATED DSN\nALMSGID  DS    0CL8                    ----+\nALMSGID0 DS    CL6                         +\nALMSGID1 DS    CL1                         +\nALMSGID2 DS    CL1                         +--- ERROR MESSAGE-ID\nVOLSAVE  DS    CL8                     ALLOCATED VOLSER SAVE AREA\n         SPACE 1\nWORKLEN  EQU   (((*-WORKAREA)+7)/8)*8\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJPARD": {"ttr": 25863, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'O\\x00\\x93'O\\x12\\x08\\x000\\x000\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-10-01T00:00:00", "modifydate": "1993-10-01T12:08:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n  @ TYPE(OUTPUT) INTENS(HIGH)\n)BODY\n%PARA ------------------------  PARA Parameters  -------------------------------\n+\n%Current Variable Pool : @P1                     +\n\n\n%PARA parameters at &P2                          +\n\n        %OL =@P3+(paragraph's old left margin)\n        %NL =@P4+(paragraph's new left margin)\n        %OR =@P5+(paragraph's old right margin)\n        %NR =@P6+(paragraph's new right margin)\n        % I =@P7+(paragraph's first line indentation)\n             @P8+&PTXT1\n             @P9+&PTXT2\n+Recognized%end of sentence+characters are@P10  +(can be changed only through\n                                                  parameters prompting panel)\n\n%Note :+All these PARA parameters are remembered in the current Variable Pool.\n+\n+Hit%ENTER+or%&EPF+to continue/exit PARA facility_PTXR+\n+Hit%&HPF+to get explanation about PARA facility\n)INIT\n  .HELP = PAJTPAR\n  .CURSOR = PTXR\n  IF (&P8 = 'J')\n    &PTXT1 = '(right margin justification)'\n  IF (&P8 \u00ac= 'J')\n    &PTXT1 = '(no right margin justification)'\n  IF (&P9 = 'D')\n    &PTXT2 = '(double space at end of sentence)'\n  IF (&P9 \u00ac= 'D')\n    &PTXT2 = '(single space at end of sentence)'\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJPARI": {"ttr": 25865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'O\\x00\\x93'O\\x12\\x08\\x00[\\x00[\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-10-01T00:00:00", "modifydate": "1993-10-01T12:08:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n  @ TYPE(OUTPUT) INTENS(HIGH)\n)BODY\n%PARA ----------------------  Set PARA Parameters  -----------------------------\n+\n%                   Current Variable Pool :_I1     +<- S(HARED) / P(ROFILE)\n+\n%Paragraph parameters remembered in the current Variable Pool :+\n                        Old left margin%OL=_I2+<- data range :\n                        New left margin%NL=_I3+<-   col.%1+\n                       Old right margin%OR=_I4+<-     up to\n                       New right margin%NR=_I5+<-       col.@U0+\n                  First line indentation%I=_I6+<-         included.\n               Right margin justification%:_I7 +<- Y(ES) / N(O)\n          Double space at end of sentence%:_I8 +<- Y(ES) / N(O)\n    Recognized end of sentence characters%:_IES  +<- maximum 5 characters\n% One time only paragraph parameters :+\n                     Change to lower case%:_I9 +<- Y(ES) / N(O)\n          Remove hyphens and rejoin words%:_I10+<- Y(ES) / N(O)\n+\n%Centering paragraph(s) after reformatted%:_I11+<- Y(ES) / N(O)\n+                   (Note : centering means center inside the%OL/OR+boundaries)\n+\n+Hit%ENTER+to execute or%&EPF+to exit PARA facility\n+Hit%&HPF+to get explanation about PARA facility\n)INIT\n  .HELP = PAJTPAR\n  .CURSOR = &UCSF\n  &I1 = &O1\n  &I2 = &O2\n  &I3 = &O3\n  &I4 = &O4\n  &I5 = &O5\n  &I6 = &O6\n  &I7 = &O7\n  &I8 = &O8\n  &I9 = &O9\n  &I10 = &O10\n  &I11 = &O11\n  &IES = &OES\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)REINIT\n  .CURSOR = &UCSF\n  &I1 = &O1\n  &I2 = &O2\n  &I3 = &O3\n  &I4 = &O4\n  &I5 = &O5\n  &I6 = &O6\n  &I7 = &O7\n  &I8 = &O8\n  &I9 = &O9\n  &I10 = &O10\n  &I11 = &O11\n  &IES = &OES\n)PROC\n  &I1 = TRUNC (&I1,1)\n  &I1 = TRANS (&I1 S,SHARED P,PROFILE *,*)\n  VER (&I1,NB,LIST,SHARED,PROFILE)\n  VER (&I2,NB,NUM)\n  VER (&I3,NB,NUM)\n  VER (&I4,NB,NUM)\n  VER (&I5,NB,NUM)\n  VER (&I6,NB,NUM)\n  &I7 = TRUNC (&I7,1)\n  &I7 = TRANS (&I7 Y,YES N,NO *,*)\n  VER (&I7,NB,LIST,YES,NO)\n  &I8 = TRUNC (&I8,1)\n  &I8 = TRANS (&I8 Y,YES N,NO *,*)\n  VER (&I8,NB,LIST,YES,NO)\n  &I9 = TRUNC (&I9,1)\n  &I9 = TRANS (&I9 Y,YES N,NO *,*)\n  VER (&I9,NB,LIST,YES,NO)\n  &I10 = TRUNC (&I10,1)\n  &I10 = TRANS (&I10 Y,YES N,NO *,*)\n  VER (&I10,NB,LIST,YES,NO)\n  &I11 = TRUNC (&I11,1)\n  &I11 = TRANS (&I11 Y,YES N,NO *,*)\n  VER (&I11,NB,LIST,YES,NO)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJPBLK1": {"ttr": 25868, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x884\\x7f\\x00\\x884\\x7f\\t \\x01`\\x01`\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-12T00:00:00", "modifydate": "1988-12-12T09:20:00", "lines": 352, "newlines": 352, "modlines": 0, "user": "SYSPAJA"}, "text": "BLK1     TITLE 'DISK BLOCK SIZES COMPUTATIONS (1).'\nPAJPBLK1 START 0\n         SPACE 1\n* PURPOSE :    VERIFY REQUESTED DEVICES TYPES AND SUPPLY SOME DEVICES\n* ---------    CHARACTERISTICS (NUMBER OF TRACKS PER CYLINDER AND\n*              NUMBER OF BYTES PER TRACK CAPACITY).\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12\n         EJECT\n         LA    R10,MAXERR\n         MVI   AREA,C' '\n         MVC   AREA+1(L'AREA-1),AREA\n         MVI   SWITCH,RCON\n        $ISPF  VGET,UTYPE,AREA     GET DEVICES TYPES.\n         BNZ   ERR1                ERROR.\n         NI    SWITCH,255-RCON\n         LM    R2,R4,SCAR\n         LA    R5,U1V\n         BAS   R8,EXTUT            GET U1 VALUE.\n         B     ERR2                MISSING.\n         B     ERR3                WRONG LENGTH.\n         LA    R5,U2V\n         BAS   R8,EXTUT            GET U2 VALUE.\n         B     SETDEV              NO MORE.\n         B     ERR4                WRONG LENGTH.\n         LA    R5,U3V\n         BAS   R8,EXTUT            GET U3 VALUE.\n         B     NOLAST              NO MORE.\n         B     ERR5                WRONG LENGTH.\n         CLC   U3V,U1V             ELIMINE DUPLICATED REQUESTS.\n         BE    ELAST\n         CLC   U3V,U2V\n         BNE   NOLAST\nELAST    MVC   U3V,=CL8' '\nNOLAST   CLC   U2V,U1V\n         BNE   SETDEV\n         MVC   U2V,U3V\n         MVC   U3V,=CL8' '\nSETDEV   L     R14,CVTPTR          GET CVT ADDRESS.\n         USING CVT,R14\n         L     R6,CVTZDTAB         DEV. CONSTANT TABLE ADDRESS.\n         DROP  R14\n         LA    R2,U1V\n         LA    R3,NTC1\n         LA    R4,NBT1\n         LA    R5,U1TY\n         BAS   R8,EXTUC            GET U1 CONSTANTS.\n         B     ERR6                UNKNOWN DEVICE.\n         B     ERR7                NO DEVICE TABLE.\n         LA    R2,U2V\n         LA    R3,NTC2\n         LA    R4,NBT2\n         LA    R5,U2TY\n         BAS   R8,EXTUC            GET U2 CONSTANTS.\n         B     ERR8                UNKNOWN DEVICE.\n         B     ERR9                NO DEVICE TABLE.\n         LA    R2,U3V\n         LA    R3,NTC3\n         LA    R4,NBT3\n         LA    R5,U3TY\n         BAS   R8,EXTUC            GET U3 CONSTANTS.\n         B     ERR10               UNKNOWN DEVICE.\n         B     ERR11               NO DEVICE TABLE.\n         L     R1,NTC1\n         LA    R2,NC1V\n         BAS   R8,CNVTC            EDIT NC1V VALUE.\n         L     R1,NTC2\n         LA    R2,NC2V\n         BAS   R8,CNVTC            EDIT NC2V VALUE.\n         L     R1,NTC3\n         LA    R2,NC3V\n         BAS   R8,CNVTC            EDIT NC3V VALUE.\n         OI    SWITCH,RCON\n        $ISPF  VPUT,U1,U1V         SET U1 VALUE.\n         BNZ   ERR12               ERROR.\n        $ISPF  VPUT,NC1,NC1V       SET NC1 VALUE.\n         BNZ   ERR13               ERROR.\n        $ISPF  VPUT,U2,U2V         SET U2 VALUE.\n         BNZ   ERR14               ERROR.\n        $ISPF  VPUT,NC2,NC2V       SET NC2 VALUE.\n         BNZ   ERR15               ERROR.\n        $ISPF  VPUT,U3,U3V         SET U3 VALUE.\n         BNZ   ERR16               ERROR.\n        $ISPF  VPUT,NC3,NC3V       SET NC3 VALUE.\n         BNZ   ERR17               ERROR.\n         L     R1,NTC1\n         LA    R2,NTC1V\n         BAS   R8,EDVRT            EDIT NTC1V VALUE.\n         STCM  R2,B'0011',VPNTC1+18\nVPNTC1  $ISPF  VPUT,NTC1,NTC1V     SET NTC1 VALUE.\n         BNZ   ERR18               ERROR.\n         L     R1,NBT1\n         LA    R2,NBT1V\n         BAS   R8,EDVRT            EDIT NBT1V VALUE.\n         STCM  R2,B'0011',VPNBT1+18\nVPNBT1  $ISPF  VPUT,NBT1,NBT1V     SET NBT1 VALUE.\n         BNZ   ERR19               ERROR.\n         L     R1,NTC2\n         LA    R2,NTC2V\n         BAS   R8,EDVRT            EDIT NTC2V VALUE.\n         STCM  R2,B'0011',VPNTC2+18\nVPNTC2  $ISPF  VPUT,NTC2,NTC2V     SET NTC2 VALUE.\n         BNZ   ERR20               ERROR.\n         L     R1,NBT2\n         LA    R2,NBT2V\n         BAS   R8,EDVRT            EDIT NBT2V VALUE.\n         STCM  R2,B'0011',VPNBT2+18\nVPNBT2  $ISPF  VPUT,NBT2,NBT2V     SET NBT2 VALUE.\n         BNZ   ERR21               ERROR.\n         L     R1,NTC3\n         LA    R2,NTC3V\n         BAS   R8,EDVRT            EDIT NTC3V VALUE.\n         STCM  R2,B'0011',VPNTC3+18\nVPNTC3  $ISPF  VPUT,NTC3,NTC3V     SET NTC3 VALUE.\n         BNZ   ERR22               ERROR.\n         L     R1,NBT3\n         LA    R2,NBT3V\n         BAS   R8,EDVRT            EDIT NBT3V VALUE.\n         STCM  R2,B'0011',VPNBT3+18\nVPNBT3  $ISPF  VPUT,NBT3,NBT3V     SET NBT3 VALUE.\n         BNZ   ERR23               ERROR.\n         L     R1,U1TY\n         LA    R2,U1TYV\n         BAS   R8,EDVRT            EDIT U1TYV VALUE.\n         STCM  R2,B'0011',VPU1TY+18\nVPU1TY  $ISPF  VPUT,U1TY,U1TYV     SET U1TY VALUE.\n         BNZ   ERR24               ERROR.\n         L     R1,U2TY\n         LA    R2,U2TYV\n         BAS   R8,EDVRT            EDIT U2TYV VALUE.\n         STCM  R2,B'0011',VPU2TY+18\nVPU2TY  $ISPF  VPUT,U2TY,U2TYV     SET U2TY VALUE.\n         BNZ   ERR25               ERROR.\n         L     R1,U3TY\n         LA    R2,U3TYV\n         BAS   R8,EDVRT            EDIT U3TYV VALUE.\n         STCM  R2,B'0011',VPU3TY+18\nVPU3TY  $ISPF  VPUT,U3TY,U3TYV     SET U3TY VALUE.\n         BNZ   ERR26               ERROR.\n         NI    SWITCH,255-RCON\n         EJECT\n         XR    R10,R10             SET C.C. = 0.\nLEAVE   $XRET  CC=(R10)            RETURN TO CALLER.\n         SPACE 2\nERR1     BCTR  R10,0               UTYPE VGET ERROR.\nERR2     BCTR  R10,0               U1 MISSING.\nERR3     BCTR  R10,0               U1 WRONG LENGTH.\nERR4     BCTR  R10,0               U2 WRONG LENGTH.\nERR5     BCTR  R10,0               U3 WRONG LENGTH.\nERR6     BCTR  R10,0               U1 UNKNOWN DEVICE.\nERR7     BCTR  R10,0               U1 NO DEVICE TABLE.\nERR8     BCTR  R10,0               U2 UNKNOWN DEVICE.\nERR9     BCTR  R10,0               U2 NO DEVICE TABLE.\nERR10    BCTR  R10,0               U3 UNKNOWN DEVICE.\nERR11    BCTR  R10,0               U3 NO DEVICE TABLE.\nERR12    BCTR  R10,0               U1 VPUT ERROR.\nERR13    BCTR  R10,0               NC1 VPUT ERROR.\nERR14    BCTR  R10,0               U2 VPUT ERROR.\nERR15    BCTR  R10,0               NC2 VPUT ERROR.\nERR16    BCTR  R10,0               U3 VPUT ERROR.\nERR17    BCTR  R10,0               NC3 VPUT ERROR.\nERR18    BCTR  R10,0               NTC1 VPUT ERROR.\nERR19    BCTR  R10,0               NBT1 VPUT ERROR.\nERR20    BCTR  R10,0               NTC2 VPUT ERROR.\nERR21    BCTR  R10,0               NBT2 VPUT ERROR.\nERR22    BCTR  R10,0               NTC3 VPUT ERROR.\nERR23    BCTR  R10,0               NBT3 VPUT ERROR.\nERR24    BCTR  R10,0               U1TY VPUT ERROR.\nERR25    BCTR  R10,0               U2TY VPUT ERROR.\nERR26    BCTR  R10,0               U3TY VPUT ERROR.\n         SPACE 1\nMAXERR   EQU   ((*-ERR1)/2)+1\n         SPACE 1\n         TM    SWITCH,RCON\n         BZ    LEAVE\n         LM    R1,R3,0(R15)\n         CVD   R1,WORK\n         ED    ERRMSA,WORK+6\n         CVD   R2,WORK\n         ED    ERRMSB,WORK+6\n         CVD   R3,WORK\n         ED    ERRMSC,WORK+6\n        TPUT   ERRMS,ERRMSL\n         B     LEAVE\n         EJECT\n*        EXTRACT DEVICE TYPE ROUTINE.\n*              R2-R3-R4 = SCAN POINTERS.\n*              R5 = DEV. TYPE NAME FIELD POINTER.\n*              R8 = LINK REGISTER.\n*              R14-R15 = WORK REGISTERS.\n*              RETURN +  0 = NO DEV. TYPE NAME.\n*                     +  4 = WRONG DEV. TYPE NAME LENGTH.\n*                     +  8 = OK.\n         SPACE 1\nEXTUT    CLI   0(R4),C' '\n         BNE   EXTUT1\n         BXLE  R4,R2,EXTUT\n         BR    R8\nEXTUT1   LR    R14,R4\nEXTUT2   BXLE  R4,R2,EXTUT3\n         B     EXTUT4\nEXTUT3   CLI   0(R4),C' '\n         BNE   EXTUT2\nEXTUT4   LR    R15,R4\n         SR    R15,R14\n         BNP   4(R8)\n         CH    R15,=H'8'\n         BH    4(R8)\n         BCTR  R15,0\n         MVC   0(8,R5),=CL8' '\n         EX    R15,EXTUT5\n         B     8(R8)\nEXTUT5   MVC   0(*-*,R5),0(R14)\n         EJECT\n*        EXTRACT UNIT CONSTANTS ROUTINE.\n*              R2 = DEV. TYPE NAME POINTER.\n*              R3 = TRACKS/CYL VALUE POINTER (FULLWORD).\n*              R4 = BYTES/TRACK CAPACITY POINTER (FULLWORD).\n*              R5 = HEX. DEVICE TYPE POINTER (FULLWORD).\n*              R6 = CVTZDTAB.\n*              R8 = LINK REGISTER.\n*              R1-R14-R15 = WORK REGISTERS.\n*              RETURN +  0 = UNKNOWN DEV. TYPE.\n*                     +  4 = NO DEVICE TABLE.\n*                     +  8 = OK.\n         SPACE 1\nEXTUC    CLI   0(R2),C' '\n         BE    8(R8)\n         L     R1,=V(DAUTTB)\nEXTUC1   CLC   2(8,R1),0(R2)\n         BE    EXTUC2\n         LA    R1,10(R1)\n         CLI   0(R1),X'FF'\n         BNE   EXTUC1\n         BR    R8\nEXTUC2   XR    R14,R14\n         LR    R15,R14\n         IC    R14,0(R1)\n         IC    R15,0(R14,R6)\n         LA    R15,0(R15,R6)\n         CLR   R15,R6\n         BE    4(R8)\n         XC    0(2,R3),0(R3)\n         MVC   2(2,R3),2(R15)\n         XC    0(2,R4),0(R4)\n         MVC   2(2,R4),4(R15)\n         XC    0(3,R5),0(R5)\n         STC   R14,3(R5)\n         B     8(R8)\n         EJECT\n*        EDIT TRACKS/CYL VALUE ROUTINE.\n*              R1 = TRACKS/CYL VALUE / WORK REGISTER.\n*              R2 = EDIT TARGET FIELD.\n*              R8 = LINK REGISTER.\n         SPACE 1\nCNVTC    MVC   0(7,R2),=CL8' '\n         LTR   R1,R1\n         BZR   R8\n         MVI   0(R2),C'('\n         LA    R2,1(R2)\n         CVD   R1,WORK\n         MVC   ZONE,=XL8'4020202020202120'\n         ED    ZONE,WORK+4\n         LA    R1,ZONE+3\nCNVTC1   CLI   0(R1),C' '\n         BNE   CNVTC2\n         LA    R1,1(R1)\n         B     CNVTC1\nCNVTC2   MVC   0(1,R2),0(R1)\n         LA    R1,1(R1)\n         LA    R2,1(R2)\n         CLI   0(R1),C' '\n         BNE   CNVTC2\n         MVI   0(R2),C')'\n         BR    R8\n         EJECT\n*        EDIT VALUE ROUTINE.\n*              R1 = VALUE / WORK REGISTER.\n*              R2 = EDIT TARGET FIELD / LENGTH EDITED VALUE.\n*              R8 = LINK REGISTER.\n*              R0 = WORK REGISTER.\n         SPACE 1\nEDVRT    MVC   0(8,R2),=CL8' '\n         CVD   R1,WORK\n         MVC   ZONE,=XL8'4020202020202120'\n         ED    ZONE,WORK+4\n         LA    R1,ZONE\n         LR    R0,R2\nEDVRT1   CLI   0(R1),C' '\n         BNE   EDVRT2\n         LA    R1,1(R1)\n         B     EDVRT1\nEDVRT2   MVC   0(1,R2),0(R1)\n         LA    R1,1(R1)\n         LA    R2,1(R2)\n         CLI   0(R1),C' '\n         BNE   EDVRT2\n         SR    R2,R0\n         BR    R8\n         EJECT\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\nWORK     DC    D'0'\nSCAR     DC    A(1,AREA+L'AREA-1,AREA)\nNTC1     DC    F'0'\nNBT1     DC    F'0'\nU1TY     DC    F'0'\nNTC2     DC    F'0'\nNBT2     DC    F'0'\nU2TY     DC    F'0'\nNTC3     DC    F'0'\nNBT3     DC    F'0'\nU3TY     DC    F'0'\nAREA     DC    CL60' '\nU1V      DC    CL8' '\nU2V      DC    CL8' '\nU3V      DC    CL8' '\nNBT1V    DC    CL8' '\nNTC1V    DC    CL8' '\nNBT2V    DC    CL8' '\nNTC2V    DC    CL8' '\nNBT3V    DC    CL8' '\nNTC3V    DC    CL8' '\nNC1V     DC    CL7'( '\nNC2V     DC    CL7'( '\nNC3V     DC    CL7'( '\nU1TYV    DC    CL3' '\nU2TYV    DC    CL3' '\nU3TYV    DC    CL3' '\nZONE     DC    CL8' ',C' '\nSWITCH   DC    XL1'0'\nRCON     EQU   X'01'\n         SPACE 1\nERRMS    DC    C' ---> PAJPBLK1 : $ISPF R.C.'\nERRMSA   DC    XL4'40202120',C','\nERRMSB   DC    XL4'40202120',C','\nERRMSC   DC    XL4'40202120',C'.'\nERRMSL   EQU   *-ERRMS\n         SPACE 2\n        LTORG\n         SPACE 2\n        PRINT  NOGEN\n        CVT    DSECT=YES,TSO=YES,RPS=YES,LIST=YES\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJPBLK2": {"ttr": 26118, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x884\\x7f\\x00\\x884\\x7f\\t \\x00\\xf3\\x00\\xf3\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-12T00:00:00", "modifydate": "1988-12-12T09:20:00", "lines": 243, "newlines": 243, "modlines": 0, "user": "SYSPAJA"}, "text": "BLK2     TITLE 'DISK BLOCK SIZES COMPUTATIONS (2).'\nPAJPBLK2 START 0\n         SPACE 1\n* PURPOSE :    COMPUTE THE NUMBER OF BLOCKS PER TRACKS CAPACITY FOR\n* ---------    THE PREVIOUSLY REQUESTED AND CHECKED DEVICES TYPES.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12\n         EJECT\n         LA    R10,MAXERR\n         MVI   SWITCH,RCON\n        $ISPF  VGET,U1,U1V         GET U1 VALUE.\n         BNZ   ERR1                ERROR.\n        $ISPF  VGET,U2,U2V         GET U2 VALUE.\n         BNZ   ERR2                ERROR.\n        $ISPF  VGET,U3,U3V         GET U3 VALUE.\n         BNZ   ERR3                ERROR.\n        $ISPF  VGET,KEY,KEYV       GET KEY VALUE.\n         BNZ   ERR4                ERROR.\n         NI    SWITCH,255-RCON\n         LA    R2,KEYV\n         BAS   R8,CNVRT            CONVERT TO BINARY KEY VALUE.\n         ST    R1,KEY\n         LA    R1,U1TY\n         LA    R2,U1V\n         BAS   R8,EXTUT            GET U1 DEV. TYPE.\n         B     ERR5                MISSING.\n         B     ERR6                UNKNOWN DEVICE.\n         OI    SWITCH,RCON\n        $ISPF  VGET,BU1,BU1V       GET BU1 VALUE.\n         BNZ   ERR7                ERROR.\n         NI    SWITCH,255-RCON\n         LA    R2,BU1V\n         BAS   R8,CNVRT            CONVERT TO BINARY BU1 VALUE.\n         XR    R0,R0\n         LTR   R3,R1\n         BZ    SU1\n         XR    R2,R2\n         IC    R2,U1TY\n         BAS   R8,TRKRT            COMPUTE NU1.\nSU1      ST    R0,NU1\n         LA    R1,U2TY\n         LA    R2,U2V\n         BAS   R8,EXTUT            GET U2 DEV. TYPE.\n         B     NOMORE              NO MORE.\n         B     ERR8                UNKNOWN DEVICE.\n         OI    SWITCH,RCON\n        $ISPF  VGET,BU2,BU2V       GET BU2 VALUE.\n         BNZ   ERR9                ERROR.\n         NI    SWITCH,255-RCON\n         LA    R2,BU2V\n         BAS   R8,CNVRT            CONVERT TO BINARY BU2 VALUE.\n         XR    R0,R0\n         LTR   R3,R1\n         BZ    SU2\n         XR    R2,R2\n         IC    R2,U2TY\n         BAS   R8,TRKRT            COMPUTE NU2.\nSU2      ST    R0,NU2\n         LA    R1,U3TY\n         LA    R2,U3V\n         BAS   R8,EXTUT            GET U3 DEV. TYPE.\n         B     NOMORE              NO MORE.\n         B     ERR10               UNKNOWN DEVICE.\n         OI    SWITCH,RCON\n        $ISPF  VGET,BU3,BU3V       GET BU3 VALUE.\n         BNZ   ERR11               ERROR.\n         NI    SWITCH,255-RCON\n         LA    R2,BU3V\n         BAS   R8,CNVRT            CONVERT TO BINARY BU3 VALUE.\n         XR    R0,R0\n         LTR   R3,R1\n         BZ    SU3\n         XR    R2,R2\n         IC    R2,U3TY\n         BAS   R8,TRKRT            COMPUTE NU3.\nSU3      ST    R0,NU3\nNOMORE   OI    SWITCH,RCON\n         L     R1,NU1\n         LA    R2,NU1V\n         BAS   R8,EDVRT            EDIT NU1V VALUE.\n         STCM  R2,B'0011',VPNU1+18\nVPNU1   $ISPF  VPUT,NU1,NU1V       SET NU1 VALUE.\n         BNZ   ERR12               ERROR.\n         L     R1,NU2\n         LA    R2,NU2V\n         BAS   R8,EDVRT            EDIT NU2V VALUE.\n         STCM  R2,B'0011',VPNU2+18\nVPNU2   $ISPF  VPUT,NU2,NU2V       SET NU2 VALUE.\n         BNZ   ERR13               ERROR.\n         L     R1,NU3\n         LA    R2,NU3V\n         BAS   R8,EDVRT            EDIT NU3V VALUE.\n         STCM  R2,B'0011',VPNU3+18\nVPNU3   $ISPF  VPUT,NU3,NU3V       SET NU3 VALUE.\n         BNZ   ERR14               ERROR.\n         NI    SWITCH,255-RCON\n         EJECT\n         XR    R10,R10             SET C.C. = 0.\nLEAVE   $XRET  CC=(R10)            RETURN TO CALLER.\n         SPACE 2\nERR1     BCTR  R10,0               U1 VGET ERROR.\nERR2     BCTR  R10,0               U2 VGET ERROR.\nERR3     BCTR  R10,0               U3 VGET ERROR.\nERR4     BCTR  R10,0               KEY VGET ERROR.\nERR5     BCTR  R10,0               U1 MISSING.\nERR6     BCTR  R10,0               U1 UNKNOWN DEVICE.\nERR7     BCTR  R10,0               BU1 VGET ERROR.\nERR8     BCTR  R10,0               U2 UNKNOWN DEVICE.\nERR9     BCTR  R10,0               BU2 VGET ERROR.\nERR10    BCTR  R10,0               U3 UNKNOWN DEVICE.\nERR11    BCTR  R10,0               BU3 VGET ERROR.\nERR12    BCTR  R10,0               NU1 VPUT ERROR.\nERR13    BCTR  R10,0               NU2 VPUT ERROR.\nERR14    BCTR  R10,0               NU3 VPUT ERROR.\n         SPACE 1\nMAXERR   EQU   ((*-ERR1)/2)+1\n         SPACE 1\n         TM    SWITCH,RCON\n         BZ    LEAVE\n         LM    R1,R3,0(R15)\n         CVD   R1,WORK\n         ED    ERRMSA,WORK+6\n         CVD   R2,WORK\n         ED    ERRMSB,WORK+6\n         CVD   R3,WORK\n         ED    ERRMSC,WORK+6\n        TPUT   ERRMS,ERRMSL\n         B     LEAVE\n         EJECT\n*        GET UNIT DEVICE TYPE ROUTINE.\n*              R1 = HEX. DEV. TYPE POINTER.\n*              R2 = DEV. TYPE NAME POINTER.\n*              R8 = LINK REGISTER.\n*              R14 = WORK REGISTERS.\n*              RETURN +  0 = DEV. TYPE NAME NOT SUPPLIED.\n*                     +  4 = UNKNOWN DEV. TYPE.\n*                     +  8 = OK.\n         SPACE 1\nEXTUT    CLI   0(R2),C' '\n         BER   R8\n         L     R14,=V(DAUTTB)\nEXTUT1   CLC   2(8,R14),0(R2)\n         BE    EXTUT2\n         LA    R14,10(R14)\n         CLI   0(R14),X'FF'\n         BNE   EXTUT1\n         B     4(R8)\nEXTUT2   MVC   0(1,R1),0(R14)\n         B     8(R8)\n         EJECT\n*        CONVERT BINARY ROUTINE.\n*              R1 = WORK REGISTER / BINARY VALUE.\n*              R2 = KEY VALUE POINTER / WORK REGISTER.\n*              R8 = LINK REGISTER.\n         SPACE 1\nCNVRT    XR    R1,R1\n         CLI   0(R2),C' '\n         BER   R8\n         LR    R1,R2\nCNVRT1   LA    R2,1(R2)\n         CLI   0(R2),C' '\n         BNE   CNVRT1\n         SR    R2,R1\n         BCTR  R1,0\n         EX    R2,CNVRT2\n         CVB   R1,WORK\n         BR    R8\nCNVRT2   PACK  WORK,0(*-*,R1)\n         EJECT\n*        PERFORM TRACK CALCULATIONS ROUTINE.\n*              R2 = UCB DEVICE TYPE (UCBTBYT4).\n*              R3 = DATA LENGTH.\n*              R8 = LINK REGISTER.\n*              R0 = AT EXIT, NUMBER OF RECORDS THAT FIT ON A TRACK.\n         SPACE 1\nTRKRT   TRKCALC FUNCTN=TRKCAP,TYPE=(R2),R=1,K=KEY+3,DD=(R3),           1\n               REGSAVE=YES\n         BR    R8\n         EJECT\n*        EDIT VALUE ROUTINE.\n*              R1 = VALUE / WORK REGISTER.\n*              R2 = EDIT TARGET FIELD / LENGTH EDITED VALUE.\n*              R8 = LINK REGISTER.\n*              R0 = WORK REGISTER.\n         SPACE 1\nEDVRT    MVC   0(8,R2),=CL8' '\n         CVD   R1,WORK\n         MVC   ZONE,=XL8'4020202020202120'\n         ED    ZONE,WORK+4\n         LA    R1,ZONE\n         LR    R0,R2\nEDVRT1   CLI   0(R1),C' '\n         BNE   EDVRT2\n         LA    R1,1(R1)\n         B     EDVRT1\nEDVRT2   MVC   0(1,R2),0(R1)\n         LA    R1,1(R1)\n         LA    R2,1(R2)\n         CLI   0(R1),C' '\n         BNE   EDVRT2\n         SR    R2,R0\n         BR    R8\n         EJECT\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\nWORK     DC    D'0'\nKEY      DC    F'0'\nNU1      DC    F'0'\nNU2      DC    F'0'\nNU3      DC    F'0'\nKEYV     DC    CL8' '\nU1V      DC    CL8' '\nBU1V     DC    CL8' '\nNU1V     DC    CL8' '\nU2V      DC    CL8' '\nBU2V     DC    CL8' '\nNU2V     DC    CL8' '\nU3V      DC    CL8' '\nBU3V     DC    CL8' '\nNU3V     DC    CL8' '\nZONE     DC    CL8' ',C' '\nU1TY     DC    XL1'0'\nU2TY     DC    XL1'0'\nU3TY     DC    XL1'0'\nSWITCH   DC    XL1'0'\nRCON     EQU   X'01'\n         SPACE 1\nERRMS    DC    C' ---> PAJPBLK2 : $ISPF R.C.'\nERRMSA   DC    XL4'40202120',C','\nERRMSB   DC    XL4'40202120',C','\nERRMSC   DC    XL4'40202120',C'.'\nERRMSL   EQU   *-ERRMS\n         SPACE 2\n        LTORG\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJPBUMU": {"ttr": 26123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x15\\x7f\\x00\\x90\\x15\\x7f\\x12$\\x00\\xba\\x00\\xba\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-06T00:00:00", "modifydate": "1990-06-06T12:24:00", "lines": 186, "newlines": 186, "modlines": 0, "user": "SYSPAJA"}, "text": "BUMU     TITLE 'BROADCAST USER MESSAGES UNLOAD.'\nPAJPBUMU START 0\n         SPACE 1\n* PURPOSE :    SUPPLY THE ACCOUNT NUMBER (TSO UADS), THE PASSWORD\n* ---------    AND DEFAULT GROUP NAME (RACF) OF A GIVEN USERID.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12\n         LA    R10,MAXERR\n         MVI   SWITCH,ISPFM\n        $ISPF  VGET,USID,USIDV     GET USERID VALUE.\n         BNZ   ERR1                ERROR.\n         NI    SWITCH,255-ISPFM\n         LA    R1,USIDV+L'USIDV-1  COMPUTE USERID LENGTH.\n         LA    R2,L'USIDV\nLOOP     CLI   0(R1),C' '\n         BNE   SETL\n         BCTR  R1,0\n         BCT   R2,LOOP\n         B     ERR2\nSETL     STC   R2,USIDVL\n        $GUAR  USIDV,ARRAY\n         LR    R2,R15              SAVE COMPLETION OF GUAR CALL.\n        $GUACL\n         LR    R1,R15              SAVE COMPLETION OF GUACL CALL.\n         LTR   R15,R2              TEST COMPLETION OF GUAR CALL.\n         BM    ERR3                NOT FOUND.\n         BP    ERR4                ERROR.\n         LTR   R15,R1              TEST COMPLETION OF GUACL CALL.\n         BNZ   ERR5                ERROR.\n         OC    ARRAY,ARRAY\n         BZ    ERR6                NO ACCOUNT NUMBER.\n         CLI   ARRAY+L'ARRAY,8\n         BNE   ERR7                WRONG ACCOUNT NUMBER.\n        SETAUTH\n        ICHEINTY MF=(E,RPR)        GET RACF PASSWORD.\n         LR    R2,R15\n        RESAUTH\n         OI    SWITCH,RACFM\n         LTR   R15,R2\n         BNZ   ERR8                ERROR.\n         NI    SWITCH,255-RACFM\n         CLC   GPL,=XL2'0'\n         BE    NOPP                NO PASSWORD PROVIDED.\n         OI    SWITCH,PSWEM\n         LA    R2,GPL\n         CLC   GPL,=XL2'0008'\n         BNE   ERR9                UNEXPECTED PASSWORD LENGTH.\n        CALL   PSWREST,(PSWDM,PSWV,PSWDML),VL\n         LTR   R15,R15\n         BNZ   ERR9                UNKNOWN CHARACTERS IN PASSWORD.\n         NI    SWITCH,255-PSWEM\n         LA    R1,PSWV+L'PSWV-1    COMPUTE PASSWORD LENGTH.\n         LA    R2,L'PSWV\nSCAN     CLI   0(R1),C' '\n         BNE   STLG\n         BCTR  R1,0\n         BCT   R2,SCAN\n         XC    GPL,GPL             SET LIKE NO PASSWORD.\n         B     NOPP\nSTLG     STCM  R2,B'0011',VPPSW+18\nNOPP     CLC   GDL,=XL2'0'\n         BE    NODFG               NO GROUP PROVIDED.\n         OI    SWITCH,PSWEM\n         CLC   GDL,=XL2'0008'\n         BE    GRPOK\n         LA    R2,GDL\n         MVC   ERRMPA(8),=CL8'DF-GROUP'\n         B     ERR9                UNEXPECTED GROUP LENGTH.\nGRPOK    NI    SWITCH,255-PSWEM\n         LA    R1,DFGRP+L'DFGRP-1  COMPUTE GROUP LENGTH.\n         LA    R2,L'DFGRP\nSCRH     CLI   0(R1),C' '\n         BNE   STLGP\n         BCTR  R1,0\n         BCT   R2,SCRH\n         XC    GDL,GDL             SET LIKE NO GROUP.\n         B     NODFG\nSTLGP    STCM  R2,B'0011',VPGRP+18\nNODFG    OI    SWITCH,ISPFM\n        $ISPF  VPUT,ACCN,ACCNO     SET ACC.NO. VALUE.\n         BNZ   ERR10               ERROR.\n         CLC   GPL,=XL2'0008'\n         BNE   NOPSWD              NO PASSWORD PROVIDED.\nVPPSW   $ISPF  VPUT,PSWD,PSWV      SET PSWD VALUE.\n         BNZ   ERR11               ERROR.\nNOPSWD   CLC   GDL,=XL2'0008'\n         BNE   NODGRP              NO GROUP PROVIDED.\nVPGRP   $ISPF  VPUT,DGRP,DFGRP     SET DGRP VALUE.\n         BNZ   ERR12               ERROR.\nNODGRP   NI    SWITCH,255-ISPFM\n         XR    R10,R10             SET C.C. = 0.\nLEAVE   $XRET  CC=(R10)            RETURN TO CALLER.\n         SPACE 2\nERR1     BCTR  R10,0               USID VGET ERROR.\nERR2     BCTR  R10,0               NO USERID.\nERR3     BCTR  R10,0               USERID NOT FOUND.\nERR4     BCTR  R10,0               CALL GUAR ERROR.\nERR5     BCTR  R10,0               CALL GUACL ERROR.\nERR6     BCTR  R10,0               NO ACCOUNT NUMBER.\nERR7     BCTR  R10,0               WRONG ACCOUNT NUMBER.\nERR8     BCTR  R10,0               RACF LOCATE ERROR.\nERR9     BCTR  R10,0               RACF PASSWORD OR GROUP ERROR.\nERR10    BCTR  R10,0               ACCN VPUT ERROR.\nERR11    BCTR  R10,0               PSWD VPUT ERROR.\nERR12    BCTR  R10,0               DGRP VPUT ERROR.\n         SPACE 1\nMAXERR   EQU   ((*-ERR1)/2)+1\n         SPACE 1\n         TM    SWITCH,RACFM\n         BO    RACFE\n         TM    SWITCH,PSWEM\n         BO    PASSE\n         TM    SWITCH,ISPFM\n         BZ    LEAVE\n         LM    R1,R3,0(R15)\n         CVD   R1,WORK\n         ED    ERRMSA,WORK+6\n         CVD   R2,WORK\n         ED    ERRMSB,WORK+6\n         CVD   R3,WORK\n         ED    ERRMSC,WORK+6\n        TPUT   ERRMS,ERRMSL\n         B     LEAVE\nRACFE    CVD   R15,WORK\n         ED    ERRMRA,WORK+6\n        TPUT   ERRMR,ERRMRL\n         B     LEAVE\nPASSE    UNPK  ERRMPB(15),0(8,R2)\n         UNPK  ERRMPB+14(7),7(4,R2)\n         TR    ERRMPB,TRTAB-X'F0'\n         MVC   ERRMPB+L'ERRMPB,C'.'\n        TPUT   ERRMP,ERRMPL\n         B     LEAVE\n         EJECT\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\nWORK     DC    D'0'\nRPR     ICHEINTY LOCATE,TYPE='USR',ENTRY=USIDVL,ACTIONS=(GPSW,GDFG),   1\n               WKAREA=WA,OPTIONS=(FLDEF,ACTION),MF=L\nGPSW    ICHEACTN FIELD=PASSWORD,MF=L\nGDFG    ICHEACTN FIELD=DFLTGRP,MF=L\nWA       DC    A(WAL)              WORK AREA LENGTH.\n         DC    XL20'0'             RESERVED.\n         DC    F'0'                ACTION RESPONSE LENGTH.\nGPL      DC    XL2'0'              PASSWORD LENGTH (8).\nPSWDM    DC    XL8'0'              PASSWORD.\nGDL      DC    XL2'0'              DEFAULT GROUP NAME LENGTH (8).\nDFGRP    DC    XL8'0'              DEFAULT GROUP NAME.\n         DC    H'0'\nWAL      EQU   *-WA\n         SPACE 1\nPSWDML   DC    A(L'PSWDM)\nTRTAB    DC    CL16'0123456789ABCDEF'\nPSWV     DC    CL8' '\nARRAY    DC    H'0',XL1'0'\nACCNO    DC    CL8' ',3XL9'0'\nUSIDVL   DC    AL1(*-*)\nUSIDV    DC    CL8' '\nSWITCH   DC    XL1'0'\nISPFM    EQU   X'01'\nRACFM    EQU   X'02'\nPSWEM    EQU   X'04'\n         SPACE 1\nERRMS    DC    C' ---> PAJPBUMU : $ISPF R.C.'\nERRMSA   DC    XL4'40202120',C','\nERRMSB   DC    XL4'40202120',C','\nERRMSC   DC    XL4'40202120',C'.'\nERRMSL   EQU   *-ERRMS\nERRMR    DC    C' ---> PAJPBUMU : RACF (ICHEINTY) R.C.'\nERRMRA   DC    XL4'40202120',C'.'\nERRMRL   EQU   *-ERRMR\nERRMP    DC    C' ---> PAJPBUMU : RACF '\nERRMPA   DC    C'PASSWORD',C' ERROR '\nERRMPB   DC    CL20' ',C'.'\nERRMPL   EQU   *-ERRMR\n         SPACE 2\n        LTORG\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJPDS": {"ttr": 26371, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x91'\\x7f\\x00\\x91'\\x7f\\x14G\\x00.\\x00.\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-04T00:00:00", "modifydate": "1991-10-04T14:47:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n` TYPE(TEXT) COLOR(YELLOW)\n{ TYPE(TEXT) COLOR(GREEN)\n} TYPE(TEXT) COLOR(RED)\n)BODY\n%PDSMATCH ---------------  Compare two PDS directories  ------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n%Enter/verify parameters below :\n+\n} SYSLIB 1 -`Data-set name%===>_PDSN1\n{            Volume serial%===>_PVOL1   +    (if not cataloged)\n+\n} SYSLIB 2 -`Data-set name%===>_PDSN2\n{            Volume serial%===>_PVOL2   +    (if not cataloged)\n+\n+                 }Options%===>_PDOP1+   --->U(SER)\n+                         %===>_PDOP2+   --->E(QO) / N(EO) or S(HORT)\n+\n+               }Size in K%===>_PDOP3+       (default is 128 Kbytes)\n+\n)INIT\n  .HELP = PAJTPDS\n  .CURSOR = PDSN1\n  &PDOP1 = &Z\n  &PDOP2 = &Z\n  &PDOP3 = &Z\n)PROC\n  VER (&PDSN1,DSNAME)\n  IF (&PVOL1 \u00ac= ' ')\n    VER (&PVOL1,NAME)\n  VER (&PDSN2,DSNAME)\n  IF (&PVOL2 \u00ac= ' ')\n    VER (&PVOL2,NAME)\n  &PDOP1 = TRUNC (&PDOP1,1)\n  &PDOP1 = TRANS (&PDOP1 U,USER *,*)\n  IF (&PDOP1 \u00ac= ' ')\n    VER (&PDOP1,LIST,USER)\n  &PDOP2 = TRUNC (&PDOP2,1)\n  &PDOP2 = TRANS (&PDOP2 E,EQO N,NEO S,SHORT *,*)\n  IF (&PDOP2 \u00ac= ' ')\n    VER (&PDOP2,LIST,EQO,NEO,SHORT)\n  IF (&PDOP3 \u00ac= ' ')\n    VER (&PDOP3,RANGE,129,1024)\n  &SEL = 'CMD(%PAJCPDS) '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJPED": {"ttr": 26373, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x15\\x1f\\x00\\x90\\x15\\x1f\\x08Y\\x004\\x004\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-05-31T00:00:00", "modifydate": "1990-05-31T08:59:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "SYSPAJA"}, "text": "%PEDIT ------------------------  Print EDIT file  ------------------------------\n+\n+\n%Enter/verify OUTPUT print options :\n+\n+         First character of data\n+         is the print carriage\n+              Control Character  %===>_PEDCC   +N(O) or Y(ES)\n+\n+         SYSOUT Class            %===>_PEDCL   +\n+\n+         Copies                  %===>_PEDCP   +1-100\n+\n+         Output status           %===>_PEDHD   +H(OLD) or N(OHOLD)\n+\n+         RMT destination         %===>_PEDDT   +i.e. R41, left blank for\n+                                                LOCAL print.\n+\n+\n+Hit%ENTER+to start the print operation\n+Hit%&EPF+to exit PEDIT facility\n+Hit%&HPF+to get explanation about PEDIT facility\n)INIT\n  .HELP = PAJTPED\n  .CURSOR = PEDCC\n  &PEDCC = TRANS (&PEDCC ' ',NO *,*)\n  &PEDCL = TRANS (&PEDCL ' ',A *,*)\n  &PEDCP = TRANS (&PEDCP ' ',1 *,*)\n  &PEDHD  = TRANS (&PEDHD ' ',NOHOLD *,*)\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &PEDCC = TRUNC (&PEDCC,1)\n  &PEDCC = TRANS (&PEDCC N,NO Y,YES *,*)\n  VER (&PEDCC,LIST,NO,YES)\n  &PEDCL = TRUNC (&PEDCL,1)\n  VER (&PEDCL,NONBLANK)\n  VER (&PEDCP,RANGE,1,100)\n  &PEDHD = TRUNC (&PEDHD,1)\n  &PEDHD = TRANS (&PEDHD H,HOLD N,NOHOLD *,*)\n  VER (&PEDHD,LIST,HOLD,NOHOLD)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJPLUG": {"ttr": 26375, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\tV\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T09:56:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                       --------------------------------\n                        |      Edit Macro  \"PLUG\"      |\n                        --------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to%plug data+into a range of lines\n             starting at a given column.\n%SYNTAX :   +On the COMMAND line type in :%PLUG STRING START-COL+\n             and then mark the lines with the%On+or%OO+range command.\n            +or :%PLUG HELP+or%H+to view this tutorial.\n             If%START-COL+is not specified, the%cursor position+will be used.\n%USE :+     %COMMAND ===> PLUG XDCCMD              +(cursor pos.)%---|+\n            %Before+********************** TOP OF DATA *************%|+*********\n            %OO+001 ... data line ...                               (UXM204A)\n            +000002 ... data line ...                               (UXM204B)\n            %OO+003 ... data line ...                               (UXM204C)\n            %After+*********************** TOP OF DATA *************************\n            %OO+001 ... data line ...                               (XDCCMDA)\n            +000002 ... data line ...                               (XDCCMDB)\n            %OO+003 ... data line ...                               (XDCCMDC)\n                                                 +(at end, cursor pos.)%---|+\n)PROC\n  &ZCONT = PAJPLUG\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJPMX": {"ttr": 26377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x19O\\x00\\x89\\x19O\\x12D\\x00\\x8e\\x00\\x8e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-07-13T00:00:00", "modifydate": "1989-07-13T12:44:00", "lines": 142, "newlines": 142, "modlines": 0, "user": "SYSPAJA"}, "text": "PMX      TITLE 'PROGRAM TO MOVE MAIL-BOXES DATA.'\nPAJPMX   START 0\n         SPACE 1\n* PURPOSE :    MOVE MAIL-BOXES DATA FROM INPUT TO OUTPUT RECORD,\n* ---------    WITHOUT DBCS'S SCANNING (THIS PROGRAM RUN ONLY FOR\n*              THE MAIL-BOXES APPLICATION UNDER ISPF).\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12\n         LA    R10,MAXERR\n        CALL   ISPLINK,(VDEF,MXRINN,MXRINF,TYPEC,MXRINL),VL\n         BAS   R14,SETRC           RC OF VDEFINE MXRIN\n        CALL   ISPLINK,(VGET,MXRINN,POOL),VL\n         BAS   R14,STRRC           RC OF VGET MXRIN\n        CALL   ISPLINK,(VDEL,MXRINN),VL\n         BAS   R14,STRRC           RC OF VDELETE MXRIN\n         OC    RCODES(3*4),RCODES  TEST CONDITION CODES\n         BNZ   ERR1\n        CALL   ISPLINK,(VDEF,MXLINN,MXLINF,TYPEF,MXLINL),VL\n         BAS   R14,SETRC           RC OF VDEFINE MXLIN\n        CALL   ISPLINK,(VGET,MXLINN,POOL),VL\n         BAS   R14,STRRC           RC OF VGET MXLIN\n        CALL   ISPLINK,(VDEL,MXLINN),VL\n         BAS   R14,STRRC           RC OF VDELETE MXLIN\n         OC    RCODES(3*4),RCODES  TEST CONDITION CODES\n         BNZ   ERR2\n        CALL   ISPLINK,(VDEF,MXPRQN,MXPRQF,TYPEC,MXPRQL),VL\n         BAS   R14,SETRC           RC OF VDEFINE MXPRQ\n        CALL   ISPLINK,(VGET,MXPRQN,POOL),VL\n         BAS   R14,STRRC           RC OF VGET MXPRQ\n        CALL   ISPLINK,(VDEL,MXPRQN),VL\n         BAS   R14,STRRC           RC OF VDELETE MXPRQ\n         OC    RCODES(3*4),RCODES  TEST CONDITION CODES\n         BNZ   ERR3\n         L     R2,MXLINF\n         LTR   R4,R2\n         BNP   ERR4\n         CLI   MXPRQF,C'M'\n         BE    MVORQ\n         MVC   MXROUF(8),=CL8' '   BROWSE/LIST REQUESTED\n         LA    R4,8\n         CLR   R2,R4\n         BNH   SETLN\n         CL    R2,=F'80'\n         BH    *+L'*+4\n         L     R2,=F'80'\n         SLR   R2,R4\n         LA    R4,5(R2)\n         LA    R3,MXROUF+5\n         CLI   MXPRQF,C'L'\n         BE    *+L'*+4\n         BCTR  R3,0\n         BCTR  R4,0\n         LA    R1,MXRINF\n         MVZ   WORK(8),0(R1)       CHECK AND ADJUST FOR VARIABLE\n         CLC   WORK(8),=CL8'00000000'\n         BNE   *+L'*+4\n         LA    R1,8(R1)\n         BCT   R2,*+L'*+6\n         MVC   0(*-*,R3),0(R1)\n         EX    R2,*-6\n         B     SETLN\nMVORQ    BCT   R2,*+L'*+6          ONLY MOVE REQUESTED\n         MVC   MXROUF(*-*),MXRINF\n         EX    R2,*-6\nSETLN    ST    R4,MXROUL\n         ST    R4,MXLOUF\n        CALL   ISPLINK,(VDEF,MXROUN,MXROUF,TYPEC,MXROUL),VL\n         BAS   R14,SETRC           RC OF VDEFINE MXROU\n        CALL   ISPLINK,(VPUT,MXROUN,POOL),VL\n         BAS   R14,STRRC           RC OF VPUT MXROU\n        CALL   ISPLINK,(VDEL,MXROUN),VL\n         BAS   R14,STRRC           RC OF VDELETE MXROU\n         OC    RCODES(3*4),RCODES  TEST CONDITION CODES\n         BNZ   ERR5\n        CALL   ISPLINK,(VDEF,MXLOUN,MXLOUF,TYPEF,MXLOUL),VL\n         BAS   R14,SETRC           RC OF VDEFINE MXLOU\n        CALL   ISPLINK,(VPUT,MXLOUN,POOL),VL\n         BAS   R14,STRRC           RC OF VPUT MXLOU\n        CALL   ISPLINK,(VDEL,MXLOUN),VL\n         BAS   R14,STRRC           RC OF VDELETE MXLOU\n         OC    RCODES(3*4),RCODES  TEST CONDITION CODES\n         BNZ   ERR6\n         XR    R10,R10             RC=0\nLEAVE   $XRET  CC=(R10)\nERR1     BCTR  R10,0               VGET MXRIN VARIABLE\nERR2     BCTR  R10,0               VGET MXLIN VARIABLE\nERR3     BCTR  R10,0               VGET MXPRQ VARIABLE\nERR4     BCTR  R10,0               MXLIN INVALID VALUE\nERR5     BCTR  R10,0               VPUT MXROU VARIABLE\nERR6     BCTR  R10,0               VPUT MXLOU VARIABLE\nMAXERR   EQU   ((*-ERR1))/2+1\n         LA    R2,RCODES           BUILD COMBINED RETURN CODE\n         LA    R3,3                B'AAABBBCCCDDD'\nCMBRC    L     R11,0(R2)           WHERE AAA = ERROR NUMBER RC\n         SLL   R11,27                    BBB = VDEFINE RC\n         SLDL  R10,3                     CCC = VGET OR VPUT RC\n         LA    R2,4(R2)                  DDD = VDELETE RC\n         BCT   R3,CMBRC            WITH RC 0, 8, 16, 20 SHIFTED\n         B     LEAVE                     AS 0, 2, 4, 5.\n         SPACE 2\nSETRC    LA    R2,RCODES           RETURN CODES ADDRESS.\nSTRRC    ST    R15,0(R2)           STORE THIS RC\n         LA    R2,4(R2)            BUMP TO NEXT CELL\n         BR    R14                 RETURN\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nRCODES   DC    3F'0'\nWORK     DC    XL8'0'\nVDEF     DC    CL8'VDEFINE'\nVGET     DC    CL8'VGET   '\nVPUT     DC    CL8'VPUT   '\nVDEL     DC    CL8'VDELETE'\nTYPEC    DC    CL8'CHAR'\nTYPEF    DC    CL8'FIXED'\nPOOL     DC    CL8'SHARED'\nMXRINN   DC    CL8'MXRIN  '\nMXRINF   DC    XL80'0'\nMXRINL   DC    F'80'\nMXLINN   DC    CL8'MXLIN  '\nMXLINF   DC    F'0'\nMXLINL   DC    F'4'\nMXPRQN   DC    CL8'MXPRQ    '\nMXPRQF   DC    XL4'0'\nMXPRQL   DC    F'4'\nMXROUN   DC    CL8'MXROU  '\nMXROUF   DC    XL80'0'\nMXROUL   DC    F'0'\nMXLOUN   DC    CL8'MXLOU  '\nMXLOUF   DC    F'0'\nMXLOUL   DC    F'4'\n         SPACE 2\n        LTORG\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJPOF": {"ttr": 26381, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90)\\x0f\\x00\\x90)\\x0f\\x14\\x14\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-17T00:00:00", "modifydate": "1990-10-17T14:14:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n@ TYPE(OUTPUT) INTENS(LOW)\n)BODY\n%POF / VTAM Secondary Program Operator Facility --------------------------------\n+Command%===>_VTCMD                                           %SCROLL ===>_AMT +\n+\n%HELP :+look the tutorial for predefined VTAM commands skeletons use.\n+================================== Response ==================================+\n)MODEL\n@Z\n)INIT\n  &VARS = '(X)'\n  &AMT = PAGE\n  .HELP = PAJTPOF\n  &ZTDMARK = '============================== End of response +\n              ==============================='\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJPPOF": {"ttr": 26383, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90)\\x0f\\x00\\x90)\\x0f\\x14T\\x03\\xca\\x03\\xca\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-17T00:00:00", "modifydate": "1990-10-17T14:54:00", "lines": 970, "newlines": 970, "modlines": 0, "user": "SYSPAJA"}, "text": "VSPO     TITLE 'PAJPPOF - ISPF VTAM SECONDARY PROGRAM OPERATOR -'\nPAJPPOF  START 0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  PURPOSE :   PROVIDE VTAM SECONDARY PROGRAM OPERATOR FOR USE        *\n*              IN ISPF (MODIFIED VERSION OF THE ORIGINAL ONE          *\n*              WRITTEN BY DOUG MOORE - SEPTEMBER 1978).               *\n*                                                                     *\n*  ADAPTED TO ISPF BY MOINIL P.A.- OCTOBER 1990                   -EU-*\n*                                                                     *\n***********************************************************************\n         SPACE 1\nPAJPPOF AMODE  24\nPAJPPOF RMODE  24\n         PRINT NOGEN\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nLV0      EQU   0         REJECT LEVEL.\n         SPACE 1\nPOF     $MDL@IX\n         SPACE 1\n        $DEFREG\n         SPACE 1\n        IEZBITS\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - MAIN PROGRAM.                                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n        $XENT  BASE=R12\n         CNOP  0,4\n         L     R8,*+L'*+4          DATA AREA'S BASE REGISTER.\n         B     *+L'*+4\n         DC    A(DATA)\n         USING DATA,R8\n        $EACM  REQAUT\n         CLI   AUTH,LV0            AUTHORIZED ?\n         BNE   POFAUTH             ...YES, OK TO PROCEED\n         MVC   POFOUT(23),=C'* UNAUTHORIZED TO YOU *'\n        TPUT   POFOUT,23\n         B     LEAVE               DON'T LET THEM PLAY\nPOFAUTH  XR    R15,R15             INITIALIZE ISPF\n         L     R10,=A(DOISPF)\n         BASR  R9,R10\n         LTR   R15,R15\n         BNZ   POFRTN              SOMETHING GOES WRONG\n        EXTRACT POFPSCB,'S',FIELDS=(PSB)\n         L     R1,POFPSCB          PSCB ADDRESS\n         USING PSCB,R1\n         MVC   POFUSRID,PSCBUSER   SAVE USERID\n         DROP  R1\n        OPEN   (POFACB)            OPEN SPO ACB\n         LTR   R15,R15             OPEN OK ?\n         BZ    POFOPNK             ...YES, CONTINUE\n         LA    R2,POFACB           POINT TO ACB\n         USING IFGACB,R2\n         CLI   ACBOFLGS,X'02'      POSSIBLE ACB ALREADY OPEN ?\n         BNE   POFOPNF             ...NO, SOMETHING ELSE\n         CLI   ACBERFLG,X'58'      POSSIBLE ACB ALREADY OPEN ?\n         BNE   POFOPNF             ...NO, SOMETHING ELSE\n         CLC   =CL8'POF003',POFACBAI+1  IS THIS THE LAST ALTERNATE ?\n         BE    POFMAXU                  ...YES, THAT WAS THE LAST ACB\n         AP    POFACB#,=PL1'1'     GET NEXT ACB NUMBER\n         UNPK  POFACBAI+4(3),POFACB#(2)\n         OI    POFACBAI+6,X'F0'\n         B     POFAUTH             TRY AGAIN\nPOFMAXU  XR    R15,R15             TERMINATE ISPF\n         L     R10,=A(DOISPF)\n         BASR  R9,R10\n         MVC   POFOUT(37),=C'* MAXIMUM POF USERS ALREADY STARTED *'\n        TPUT   POFOUT,37\n         B     POFRTN              GO AWAY\nPOFOPNF  XR    R15,R15             TERMINATE ISPF\n         L     R10,=A(DOISPF)\n         BASR  R9,R10\n         MVC   POFOUT(39),=C'OPEN FAILED FOR VTAM SPO ACB - XXXXXXXX'\n         MVC   POFOUT+31(8),POFACBAI+1  INSERT ACB NAME\n        TPUT   POFOUT,39\n         MVC   POFDBLWK+1(1),ACBOFLGS   GET OPEN FLAGS\n         UNPK  POFDBLWK(1),POFDBLWK+1(1)     PREPARE FOR CONVERSION\n         MVC   POFDBLWK+3(1),ACBERFLG   GET ERROR FLAGS\n         UNPK  POFDBLWK+2(1),POFDBLWK+3(1)   PREPARE FOR CONVERSION\n         NC    POFDBLWK(4),=X'0F0F0F0F' PREPARE FOR TRANSLATE\n         TR    POFDBLWK(4),POFTRTBL     TRANSLATE\n         MVC   POFMSG1(4),POFDBLWK PUT IN MESSAGE\n        TPUT   POFMSG1,L'POFMSG1\n         B     POFRTN              OPEN FAILED SO GET OUT\n         DROP  R2\nPOFOPNK  MVC   WTOSLT,=AL2(33)     LENGTH OF MESSAGE\n         MVC   WTOSTX(7),POFUSRID  PUT USERID IN MESSAGE\n         MVC   WTOSTX+7(14),=C' LOGGED ON TO '\n         MVC   WTOSTX+21(8),POFACBAI+1  PUT ACB IN MESSAGE\n         MVC   POFOUT(41),=C'-------> VTAM SPO FUNCTION ACTIVATED FOR '\n         MVC   POFOUT+41(8),POFACBAI+1  PUT ACB IN MESSAGE\n         LA    R0,49\n         LA    R1,POFOUT\n         LA    R15,2               ADD TO TABLE\n         L     R10,=A(DOISPF)\n         BASR  R9,R10\n         LTR   R15,R15\n         BNZ   POFEOJ              SOMETHING GOES WRONG\n         OI    POFSW,FSURT         SET SUSPEND RESET TABLE\n        RCVCMD RPL=POFRPLRC        ISSUE FIRST RCVCMD\n         LTR   R15,R15             ACCEPTED ?\n         BZ    POFSTID             ...YES, GO SEND STATUS COMMAND\n         L     R10,=A(ABEND)       ...NO, GIVE UP\n         ICM   R1,B'1111',=CL4'ERR1' - - - - - - - - - - - - - ERROR 1\n         BR    R10\nPOFSTID  MVC   POFIN(20),=CL20'D NET,U,ID=....... '    SET COMMAND\n         MVC   POFIN+11(7),POFUSRID     PUT USERID IN COMMAND\n         LA    R1,20               COMMAND LENGTH\n         B     POFSTORE            GO SEND IT\nPOFRQCMD TM    POFSW,FREND         WAIT FOR END ?\n         BZ    POFEVC              ...NO\n         LA    R5,60               SET 1 MIN CONTROL\nPOFWAIT STIMER WAIT,,BINTVL=TIMESC WAIT A SEC, THEN\n         TM    POFSW,FREND         ALWAYS WAIT FOR END ?\n         BZ    POFEVC              ...NO\n         BCT   R5,POFWAIT          GO WAIT AGAIN\n         NI    POFSW,255-FREND-FRMSG    FORCE\n         MVC   POFOUT(12),=C'*END* FORCED'\n         B     POFENDF\nPOFEVC   TM    POFSW,FRMSG         END MESSAGE PENDING ?\n         BZ    POFEVCS             ...NO\n         NI    POFSW,255-FRMSG     RESET END MESSAGE PENDING\n         MVC   POFOUT(12),=C'IST314I  END'\nPOFENDF  LA    R0,12\n         LA    R1,POFOUT\n         LA    R15,2               ADD TO TABLE\n         L     R10,=A(DOISPF)\n         BASR  R9,R10\n         LTR   R15,R15\n         BNZ   POFEOJ              SOMETHING GOES WRONG\nPOFEVCS  LA    R0,L'POFIN\n         LA    R1,POFIN\n         LA    R15,3               DISPLAY TABLE\n         L     R10,=A(DOISPF)\n         BASR  R9,R10\n         LTR   R15,R15\n         BNZ   POFEOJ              END OR SOMETHING GOES WRONG\n         LTR   R1,R1               ANY INPUT ?\n         BZ    POFRQCMD            ...NO, GO ASK AGAIN\nPOFRQCHK CLC   =CL3'END',POFIN     THE END ?\n         BE    POFEOJ              ...YES, GO TO EOJ\n         CLI   POFIN,C'*'          WANT TO DO SAME THING ?\n         BNE   POFCHKQ             ...NO, GO CHECK FOR QUESTION MARK\n         L     R1,SAVECMDL         RELOAD LENGTH\n         MVC   POFIN,SAVECMD       RELOAD COMMAND\n         B     POFDOCMD            GO DO COMMAND\nPOFCHKQ  CLI   POFIN,C'?'          WANT TO SEE LAST COMMAND ?\n         BNE   POFTSN              ...NO, GO CHECK SEL.NO.\n         MVC   POFIN,SAVECMD       RELOAD COMMAND\n         B     POFRQCMD            GO SEE WHAT TO DO\nPOFTSN   CLI   POFIN,C'0'          WANT TO GET A SKELETON ?\n         BL    *+L'*+8\n         CLI   POFIN,C'9'\n         BNH   POFSKEL             YES\nPOFSTORE ST    R1,SAVECMDL         SAVE LENGTH\n         MVC   SAVECMD,POFIN       SAVE COMMAND\nPOFDOCMD LA    R2,POFRPLSC         POINT TO SENDCMD RPL\n         USING IFGRPL,R2\n         AH    R1,=H'4'            ADD HEADER LENGTH TO COMMAND LENGTH\n         ST    R1,RPLRLEN          STORE LENGTH IN RPL\n         DROP  R2\n         STH   R1,WTOLTH           STORE LENGTH FOR WTO\n         MVC   WTOTXT(L'POFIN),POFIN    MOVE COMMAND TO WTO\n         OI    POFSW,FREND         SET WAIT FOR END\n         TM    POFSW,FSURT         SUSPEND RESET TABLE REQUESTED ?\n         BO    *+L'*+10            YES\n         LA    R15,4               RESET TABLE\n         L     R10,=A(DOISPF)\n         BASR  R9,R10\n         NI    POFSW,255-FSURT     RESET REQUEST\n         L     R10,=A(SNAP)        TRACE IF NEEDED\n         LA    R0,1                SNAP ID NUMBER - - - - - - - ID = 1\n         BASR  R9,R10\n        SENDCMD RPL=POFRPLSC       ISSUE THE COMMAND\n         LTR   R15,R15             SUCCESSFUL ?\n         BZ    POFLOG              ...YES, GO LOG COMMAND\n         L     R10,=A(ABEND)       ...NO, GIVE UP\n         ICM   R1,B'1111',=CL4'ERR2' - - - - - - - - - - - - - ERROR 2\n         BR    R10\nPOFLOG   TM    POFSW,FSLOG         LOG ALREADY ACTIVE ?\n         BO    POFLOGX             BRANCH IF YES\n        WTO    MF=(E,WTOSTRT)      WRITE LOGON TO SYSLOG\n         OI    POFSW,FSLOG         INDICATE LOG STARTED\nPOFLOGX WTO    MF=(E,WTOLIST)      WRITE COMMAND TO LOG\n         MVI   POFIN,C' '          BLANK OUT BUFFER\n         MVC   POFIN+1(L'POFIN-1),POFIN\n         B     POFRQCMD            GO GET ANOTHER COMMAND\nPOFSKEL  MVI   POFOUT,C' '         USE OUTPUT TO BUILD FULL COMMAND\n         MVC   POFOUT+1(L'POFOUT-1),POFOUT\n         XR    R0,R0\n         LR    R2,R0\n         LA    R15,X'0F'\n         IC    R2,POFIN\n         NR    R2,R15\n         BCTR  R1,0                -1 INPUT LENGTH\n         LA    R3,POFIN+1\n         CLI   POFIN+1,C'0'\n         BL    POFSKL1\n         CLI   POFIN+1,C'9'\n         BH    POFSKL1\n         IC    R0,POFIN+1\n         NR    R0,R15\n         BCTR  R1,0                -1 INPUT LENGTH\n         LA    R3,POFIN+2\n         MH    R2,=H'10'\nPOFSKL1  AR    R2,R0\n         CH    R2,=Y(NUMSN)\n         BH    POFSKISN            INVALID SEL.NO.\n         BCT   R2,*+L'*+4\n         B     *+L'*+4\n         MH    R2,=Y(L'SNTABLE)\n         AL    R2,=A(SNTABLE)\n         CLI   10(R2),C' '\n         BE    POFSKNSN            NULL SEL.NO.\n         MVC   POFOUT(L'POFVT),10(R2)\n         LTR   R1,R1\n         BNP   POFSKL2             NO MORE\n         LA    R2,POFOUT+L'POFVT-1 COMPLETE COMMAND SKELETON\n         LA    R4,L'POFVT\n         CLI   0(R2),C' '\n         BNE   *+L'*+6\n         BCTR  R4,0\n         BCT   R2,*-10\n         CLI   0(R3),C' '\n         BNE   *+L'*+12\n         LA    R3,1(R3)\n         BCT   R1,*-12\n         B     POFSKL2             NONE TO COMPLETE\n         LA    R0,L'POFIN\n         SR    R0,R4\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         BCT   R1,*+L'*+6\n         MVC   1(*-*,R2),0(R3)\n         EX    R1,*-6\nPOFSKL2  MVC   POFIN,POFOUT        COPY TO INPUT\n         MVI   POFOUT,C' '         CLEAR OUTPUT\n         MVC   POFOUT+1(L'POFOUT-1),POFOUT\n         B     POFRQCMD            GO SEE WHAT TO DO\nPOFSKISN MVC   POFOUT(38),=C'INV. NO.INVALID SKELETON SELECT NUMBER'\n         B     POFSKMSG\nPOFSKNSN MVC   POFOUT(38),=C'NULL NO.THIS IS A NULL SELECT SKELETON'\nPOFSKMSG LA    R0,30\n         LA    R1,POFOUT\n         LA    R15,1               SET MESSAGES\n         L     R10,=A(DOISPF)\n         BASR  R9,R10\n         LTR   R15,R15\n         BZ    POFRQCMD            GO SEE WHAT TO DO\nPOFEOJ   XR    R15,R15             TERMINATE ISPF\n         L     R10,=A(DOISPF)\n         BASR  R9,R10\n         OI    POFSW,FSEOJ         INDICATE END REQUESTED\n        CLOSE  (POFACB)            CLOSE THE ACB\n         LTR   R15,R15             CLOSE SUCCESSFUL ?\n         BZ    POFCLSOK            ...YES, PROCEED\n         MVC   POFOUT(29),=C'CLOSE FAILED FOR VTAM SPO ACB'\n        TPUT   POFOUT,29\n         LA    R2,POFACB           POINT TO ACB\n         USING IFGACB,R2\n         CLI   ACBERFLG,X'4C'      MORE MESSAGES OUSTANDING ?\n         BNE   POFCLSF             ...NO, PRESS ON\n         MVC   POFOUT(27),=C'OUTSTANDING MESSAGES PURGED'\n        TPUT   POFOUT,27\n         B     POFEOJ              TRY CLOSE AGAIN\nPOFCLSF  MVC   POFDBLWK+1(1),ACBOFLGS   GET OPEN FLAGS\n         UNPK  POFDBLWK(1),POFDBLWK+1(1)     PREPARE FOR CONVERSION\n         MVC   POFDBLWK+3(1),ACBERFLG   GET ERROR FLAGS\n         UNPK  POFDBLWK+2(1),POFDBLWK+3(1)   PREPARE FOR CONVERSION\n         NC    POFDBLWK(4),=X'0F0F0F0F' PREPARE FOR TRANSLATE\n         TR    POFDBLWK(4),POFTRTBL     TRANSLATE\n         MVC   POFMSG1(4),POFDBLWK PUT IN MESSAGE\n        TPUT   POFMSG1,L'POFMSG1\n         B     POFRTN              CLOSE FAILED SO GET OUT\n         DROP  R2\nPOFCLSOK TM    POFSW,FSLOG         LOG WAS ACTIVE ?\n         BZ    POFRTN              BRANCH IF NOT\n         MVC   WTOSLT,=AL2(34)     LENGTH OF MESSAGE\n         MVC   WTOSTX(7),POFUSRID  PUT USERID IN MESSAGE\n         MVC   WTOSTX+7(15),=C' LOGGED OFF OF '\n         MVC   WTOSTX+22(8),POFACBAI+1  PUT ACB IN MESSAGE\n        WTO    MF=(E,WTOSTRT)      WRITE LOGOFF TO SYSLOG\nPOFRTN   L     R10,=A(SNAPCL)\n         BASR  R9,R10\nLEAVE   $XRET  CC=0\n         DROP  R12\n         SPACE 1\n        LTORG\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - RCVCMD EXIT.                                           *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nPOFRCVEX LR    R12,R15             GET NEW BASE\n         USING POFRCVEX,R12\n         CNOP  0,4\n         L     R8,*+L'*+4          DATA AREA'S BASE REGISTER.\n         B     *+L'*+4\n         DC    A(DATA)\n         ST    R14,POFRCSV         SAVE RETURN REG\n         LR    R2,R1               SAVE RPL POINTER\n         USING IFGRPL,R2           ADDRESS RPL\n         LA    R13,POFRCVSA        POINT TO RSA\n        CHECK  RPL=POFRPLRC        CHECK RCVCMD RPL\n         LTR   R15,R15             SUCCESSFUL ?\n         BZ    POFRCVA             ...YES, PROCEED\n         L     R10,=A(ABEND)       ...NO, GIVE UP\n         ICM   R1,B'1111',=CL4'ERR3' - - - - - - - - - - - - - ERROR 3\n         BR    R10\nPOFRCVA  MVC   LRM(L'LRM),RPLRLEN+L'RPLRLEN-L'LRM\n         L     R10,=A(SNAP)        TRACE IF NEEDED\n         LA    R0,2                SNAP ID NUMBER - - - - - - - ID = 2\n         BASR  R9,R10\n         CLC   =XL2'100D',RPLRTNCD ACB CLOSED ?\n         BE    POFRCLD             ...YES, DONT DO ANY MORE\n         TM    POFCMDI+1,POHEND+POHDATA POSSIBLE NO DATA ?\n         BNM   POFRCVB             ...NO, CONTINUE (ONES OR ZEROS)\n         TM    POFCMDI+1,POHEND    END OF MULTI-LINE, NO DATA ?\n         BO    POFRCLD             ...YES, NO OUTPUT\nPOFRCVB  CLC   POFIMSG(12),=C'IST314I  END'  END OF RECEIVE ?\n         BE    POFEMSG             ...YES\n         ICM   R0,B'1111',RPLRLEN  GET LENGTH OF REPLY\n         BZ    POFRCLD             ...NONE\n         STH   R0,WTOLTH           STORE LENGTH FOR WTO\n         SH    R0,=H'4'            LESS HEADER LENGTH\n         LA    R1,POFIMSG          A(REPLY)\n         LA    R15,2               ADD TO TABLE THE REPLY\n         L     R10,=A(DOISPF)\n         BASR  R9,R10\n         LTR   R15,R15\n         BZ    POFRCTL\n         XR    R15,R15             TERMINATE ISPF, LOST THE REST\n         L     R10,=A(DOISPF)        AND FORCE THE END\n         BASR  R9,R10\n         B     POFRCTL\nPOFEMSG  OI    POFSW,FRMSG         SET END MESSAGE PENDING\nPOFRCTL  TM    POFSW,FSLOG         LOG ALREADY ACTIVE ?\n         BO    POFRCVC             BRANCH IF YES\n        WTO    MF=(E,WTOSTRT)      WRITE LOGON TO SYSLOG\n         OI    POFSW,FSLOG         INDICATE LOG STARTED\nPOFRCVC  MVC   WTOTXT(L'POFIMSG),POFIMSG     MOVE RESPONSE TO WTO\n        WTO    MF=(E,WTOLIST)      WRITE RESPONSE TO LOG\n         TM    POFCMDI+1,POHEND    END OF MULTI-LINE ?\n         BO    POFRCLD             ...YES\n         TM    POFCMDI+1,POHDATA   DATA LINE ?\n         BO    POFRCVI             ...YES\n         CLC   POFIMSG(26),=C'IST097I  DISPLAY  ACCEPTED'\n         BE    POFRCVI             ...YES, OTHERWISE ERROR MSG\nPOFRCLD  NI    POFSW,255-FREND     RESET WAIT FOR END\nPOFRCVI  XC    RPLRLEN,RPLRLEN     RESET LENGTH OF REPLY\n         XC    POFCMDI(4),POFCMDI  RESET COMMAND HEADER\n         MVI   POFIMSG,C' '        CLEAR MESSAGE\n         MVC   POFIMSG+1(L'POFIMSG-1),POFIMSG\n        RCVCMD RPL=POFRPLRC        ISSUE ANOTHER RCVCMD\n         LTR   R15,R15             ACCEPTED ?\n         BZ    POFRCRT             ...YES, RETURN\n         L     R10,=A(ABEND)       ...NO, GIVE UP\n         ICM   R1,B'1111',=CL4'ERR4' - - - - - - - - - - - - - ERROR 4\n         BR    R10\nPOFRCRT  L     R14,POFRCSV         RESTORE RETURN REG\n         BR    R14                 RETURN\n         SPACE 1\n         DROP  R2,R12\n         SPACE 1\n        LTORG\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - LERAD/SYNAD EXIT.                                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nPOFLSAD  LR    R12,R15             SET UP BASE\n         USING POFLSAD,R12\n         CNOP  0,4\n         L     R8,*+L'*+4          DATA AREA'S BASE REGISTER.\n         B     *+L'*+4\n         DC    A(DATA)\n         LR    R2,R1               SAVE RPL POINTER\n         USING IFGRPL,R2\n         ST    R14,POFLSSV         SAVE RETURN ADDRESS\n         CLC   =XL2'100D',RPLRTNCD IS THIS PSEUDO ERROR (ACB CLSD) ?\n         BE    POFNOERR            ...YES, NOT REALLY AN ERROR\n         CLC   =XL2'146E',RPLRTNCD IS THIS PSEUDO ERROR ?\n         BE    POFNOERR            ...YES, NOT REALLY AN ERROR\n         CLC   =XL2'1471',RPLRTNCD IS THIS PSEUDO ERROR ?\n         BE    POFNOERR            ...YES, NOT REALLY AN ERROR\n         CLC   =XL2'1470',RPLRTNCD IS THIS PSEUDO ERROR ?\n         BNE   POFERR              ...NO, GO TO ERROR DIAGNOSE\n         TM    POFSW,FSEOJ         ...YES, THE END ?\n         BZ    POFERR              ...NO, ERROR\nPOFNOERR XR    R15,R15             SET GOOD RETURN CODE\n         L     R14,POFLSSV         RELOAD RETURN REG\n         BR    R14                 RETURN\nPOFERR   MVC   POFOUT(35),=C'UNKNOWN FAILED - XXXX = RTNCD/FDBK2'\n         TM    RPLREQ,RPLRVCMD     RCVCMD FAILED ?\n         BNO   POFREQ              ...NO, TRY SENDCMD\n         MVC   POFOUT(7),=C'RCVCMD '    SHOW RCVCMD\n         B     POFRQST\nPOFREQ   TM    RPLREQ,RPLSDCMD     SENDCMD FAILED ?\n         BNO   POFRQST             ...NO, THATS IT\n         MVC   POFOUT(7),=C'SENDCMD'    SHOW SENDCMD\nPOFRQST  MVC   POFDBLWK+1(1),RPLRTNCD   GET RETURN CODE\n         UNPK  POFDBLWK(1),POFDBLWK+1(1)     PREPARE FOR CONVERSION\n         MVC   POFDBLWK+3(1),RPLFDB2    GET FEEDBACK FIELD\n         UNPK  POFDBLWK+2(1),POFDBLWK+3(1)   PREPARE FOR CONVERSION\n         NC    POFDBLWK(4),=X'0F0F0F0F' PREPARE FOR TRANSLATE\n         TR    POFDBLWK(4),POFTRTBL     TRANSLATE\n         MVC   POFOUT+17(4),POFDBLWK PUT IN MESSAGE\n         LA    R0,35\n         LA    R1,POFOUT\n         LA    R15,2               ADD TO TABLE THE MESSAGE\n         L     R10,=A(DOISPF)\n         BASR  R9,R10\n         LTR   R15,R15\n         BZ    *+L'*+8\n         XR    R15,R15             TERMINATE ISPF, LOST THE REST\n         L     R10,=A(DOISPF)        AND FORCE THE END\n         BASR  R9,R10\n         NI    POFSW,255-FREND     RESET WAIT FOR END\n         LA    R15,BIT0            INDICATE SENDCMD/RCVCMD FAILURE\n         L     R14,POFLSSV         RELOAD RETURN REG\n         BR    R14                 RETURN\n         SPACE 1\n         DROP  R2,R12\n         SPACE 1\n        LTORG\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - ABEND PROCESS.                                         *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n         CNOP  2,4\n         USING *,R10\nABEND    STCM  R1,B'1111',ABCODE   SET ABEND ERROR CODE\n         LA    R1,1                SET DUMP OPTION\n         SLL   R1,31\n         ALR   R1,R15              SET ABEND CODE\n        ABEND  (1)                 THIS ABEND WILL CAUSE A SVC DUMP\n         DROP  R10\n         SPACE 1\nABCODE   DC    CL4' '              ENTITLED 'VTAM IRB ABEND' ALSO\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - COMMON DATA AREAS.                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nDATA     DS    0D\n         SPACE 1\nPOFDBLWK DC    D'0'                DOUBLE WORD WORK AREA\nPOFRCVSA DC    18F'0'              RSA FOR RCVCMD EXIT\nPOFRCSV  DC    F'0'\nPOFLSSV  DC    F'0'\nPOFPSCB  DC    A(*-*)\n         SPACE 1\nPOFCMDI  DS    0C                  COMMAND INPUT BUFFER (FROM VTAM)\n         DC    XL4'0'              COMMAND HEADER\nPOFIMSG  DC    CL126' '            MESSAGE\nPOFCMDIL EQU   *-POFCMDI\nLRM      DC    H'0'                LENGTH OF RECEIVED MESSAGE\nPOFCMDIE EQU   *-1                 END SNAP ID 2 ADDRESS\n         SPACE 1\nPOFCMDO  DS    0C                  COMMAND OUTPUT BUFFER (TO VTAM)\n         DC    XL1'0'              COMMAND HEADER\n         DC    AL1(POHRREQ+POHGEN)\n         DC    XL2'0'\nPOFIN    DC    CL80' '             TGET BUFFER\nPOFCMDOL EQU   *-POFCMDO\nSAVECMDL DC    F'0'                LENGTH OF SAVED COMMAND\nPOFCMDOE EQU   *-1                 END SNAP ID 1 ADDRESS\n         SPACE 1\nPOFSW    DC    XL1'0'              PROCESSING FLAGS\nFSEOJ    EQU   X'01'                    END REQUESTED\nFSLOG    EQU   X'02'                    HARD COPY ACTIVE\nFREND    EQU   X'10'                    WAIT END OF RECEIVE\nFRMSG    EQU   X'20'                    END MESSAGE PENDING\nFSURT    EQU   X'80'                    SUSPEND RESET TABLE\nAUTH     DC    XL1'0'\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(AUTH)\nTIMESC   DC    A(1*100)            1.00 SEC WAIT INTERVAL\n         SPACE 1\nPOFTRTBL DC    CL16'0123456789ABCDEF'\nPOFOUT   DC    CL80' '             TPUT BUFFER\nSAVECMD  DC    CL80' '             SAVED COMMAND\nWORKCMD  DC    CL80' '             COMMAND WORK AREA\n         EJECT\nWTOSTRT WTO    ' ',MCSFLAG=HRDCPY,MF=L   WTO TO LOG CMDS & RESPONSES\nWTOSLT   EQU   WTOSTRT,2           LENGTH OF TEXT + 4\n         ORG   WTOSTRT+4           POINT TO MESSAGE\nWTOSTX   DC    CL126' '            MESSAGE TEXT (MAX OF 124)\n         SPACE 1\nWTOLIST WTO    ' ',MCSFLAG=HRDCPY,MF=L   WTO TO LOG CMDS & RESPONSES\nWTOLTH   EQU   WTOLIST,2           LENGTH OF TEXT + 4\n         ORG   WTOLIST+4           POINT TO MESSAGE\nWTOTXT   DC    CL126' '            MESSAGE TEXT (MAX OF 124)\n         SPACE 1\nPOFUSRID DC    CL7' '              TSO USER ID\nPOFMSG1  DC    C'XXXX = ACBOFLGS/ACBERFLG'\n         SPACE 1\nPOFACB   ACB   AM=VTAM,                                                X\n               APPLID=POFACBAI,                                        X\n               PASSWD=POFACBPW,                                        X\n               EXLST=POFACBEX,                                         X\n               MACRF=NLOGON\n         SPACE 1\nPOFACB#  DC    PL2'1'              ACB COUNTER FOR MULTIPLE POF'S\nPOFACBAI DC    X'08'\n         DC    CL8'POF001'         ACB NAME\nPOFACBPW DC    X'08'\n         DC    CL8'POFSPOPW'       ACB PASSWORD\n         SPACE 1\nPOFACBEX EXLST AM=VTAM,                                                X\n               LERAD=POFLSAD,                                          X\n               SYNAD=POFLSAD\n         SPACE 1\nPOFRPLSC RPL   AM=VTAM,                                                X\n               ACB=POFACB,                                             X\n               AREA=POFCMDO,                                           X\n               RECLEN=POFCMDOL,                                        X\n               OPTCD=(SYN)\n         SPACE 1\nPOFRPLRC RPL   AM=VTAM,                                                X\n               ACB=POFACB,                                             X\n               AREA=POFCMDI,                                           X\n               AREALEN=POFCMDIL,                                       X\n               EXIT=POFRCVEX,                                          X\n               OPTCD=(ASY,Q,TRUNC)\n         SPACE 1\n*------- END OF COMMON DATA AREAS ADDESSABILITY (R8) -----------------*\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - PREDEFINED COMMANDS SKELETONS TABLE.                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n         DS    0F\nSNTABLE  DS    0CL28               DISPLAYED BY HELP PANEL PAJTPOF\nPOFVN    EQU   SNTABLE,10          VARIABLE NAME\nPOFVT    EQU   SNTABLE+10,18       VARIABLE VALUE\n         SPACE 1\n         DC    CL10'(POFVT1)',CL18'D NET,BFRUSE'\n         DC    CL10'(POFVT2)',CL18'D NET,PENDING'\n         DC    CL10'(POFVT3)',CL18'D NET,APPLS'\n         DC    CL10'(POFVT4)',CL18'D NET,MAJNODES'\n         DC    CL10'(POFVT5)',CL18'D NET,LINES,I'\n         DC    CL10'(POFVT6)',CL18'D NET,CLSTRS,I'\n         DC    CL10'(POFVT7)',CL18'D NET,TERMS,I'\n         DC    CL10'(POFVT8)',CL18'D NET,ID='\n         DC    CL10'(POFVT9)',CL18' '\n         DC    CL10'(POFVT10)',CL18'V NET,ACT,ID='\n         DC    CL10'(POFVT11)',CL18'V NET,INACT,ID='\n         DC    CL10'(POFVT12)',CL18' '\n         SPACE 1\nSNTBEND  EQU   *-L'SNTABLE\nNUMSN    EQU   (*-SNTABLE)/L'SNTABLE\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - SNAP DUMP PROCESS.                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* SNAP ENTRY : TO TAKE A SNAP DUMP.                                   *\n*              R0  = SNAP ID NUMBER (0-255).                          *\n*              R8  = ADDRESS OF DATA AREA (PASSED BY CALLER).         *\n*              R9  = LINK REGISTER.                                   *\n*              R10 = ADDRESS OF SNAP ROUTINE.                         *\n*              NOTE - THE FOLLOWING ALLOCATION IS NEEDED TO           *\n*                     OBTAIN THE SNAP DUMPS :                         *\n*                        ALLOC F(SYSSNAP) SYSOUT(A)                   *\n*                     OR :                                            *\n*                        ALLOC F(SYSSNAP) DA(...) OLD                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n         CNOP  0,4\n         USING *,R10\nSNAP     TM    SNAPSW,SNAPFNA      FUNCTION INACTIVE ?\n         BOR   R9                  YES, BYPASS\n         STM   R14,R12,12(R13)     ENTRY\n         LR    R1,R13\n         LA    R13,SNAPSV\n         ST    R1,4(R13)\n         ST    R13,8(R1)\n         LR    R4,R0               SAVE SNAP ID NUMBER\n         LA    R2,SNAPDCB\n         USING IHADCB,R2\n         TM    SNAPSW,SNAPOPN      DATA-SET ALREADY OPENED ?\n         BO    SNO                 YES\n        EXTRACT ATIOT,'S',FIELDS=(TIOT)\n         L     R3,ATIOT\n         USING TIODSECT,R3\n         XR    R1,R1\nSNS      CLC   TIOELNGH(4),=F'0'\n         BE    SNN\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM\n         BE    SNF\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     SNS\n         DROP  R3\nSNF     OPEN   (SNAPDCB,OUTPUT)\n         TM    DCBOFLGS,DCBOFOPN   SUCCESSFULLY OPENED ?\n         BZ    SNN                 NO\n         DROP  R2\n         OI    SNAPSW,SNAPOPN      INDICATE DATA-SET OPENED\nSNO      CH    R4,SNAPMAX          KNOWN ID NUMBER ?\n         BNL   SNE                 NO, BYPASS\n         LR    R5,R4\n         MH    R5,SNAPTLE\n         LA    R5,SNAPTB(R5)\n         LA    R6,8(R5)\n         TM    0(R6),X'80'         UNUSED ELEMENT ?\n         BZ    SNE                 YES, BYPASS\n        SNAP   TCB='S',ID=(R4),LIST=(R5),STRHDR=(R6),MF=(E,SNAPLIST)\n         LTR   R15,R15             ALL OK ?\n         BZ    SNE                 YES\nSNN      OI    SNAPSW,SNAPFNA      INACTIVE FUNCTION\nSNE      L     R13,4(R13)          EXIT\n         LM    R14,R12,12(R13)\n         BR    R9\n         DROP  R10\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* SNAPCL ENTRY : TO CLOSE THE SNAP FILE IF OPENED.                    *\n*              R8  = ADDRESS OF DATA AREA (PASSED BY CALLER).         *\n*              R9  = LINK REGISTER.                                   *\n*              R10 = ADDRESS OF SNAPCL ROUTINE.                       *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n         CNOP  0,4\n         USING *,R10\nSNAPCL   TM    SNAPSW,SNAPOPN      DATA-SET IS OPENED ?\n         BZR   R9                  NO\n         STM   R14,R12,12(R13)     ENTRY\n         LR    R1,R13\n         LA    R13,SNAPSV\n         ST    R1,4(R13)\n         ST    R13,8(R1)\n        CLOSE  (SNAPDCB)\n         L     R13,4(R13)          EXIT\n         LM    R14,R12,12(R13)\n         BR    R9\n         DROP  R10\n         EJECT\nSNAPDCB  DCB   DSORG=PS,RECFM=VBA,MACRF=(W),                           X\n               BLKSIZE=1632,LRECL=125,DDNAME=SYSSNAP\nSNAPLIST SNAP  DCB=SNAPDCB,MF=L\n         SPACE 1\nSNAPSV   DC    18F'0'\nATIOT    DC    F'0'\n         SPACE 1\nSNAPTB   DC    3F'0'               0 = NOT USED\nSNAPTBL  EQU   *-SNAPTB            ELEMENT LENGTH\n         DC    A(POFCMDO),XL1'80',AL3(POFCMDOE),XL1'80',AL3(SHDO)\n         DC    A(POFCMDI),XL1'80',AL3(POFCMDIE),XL1'80',AL3(SHDI)\nSNAPTBM  EQU   (*-SNAPTB)/SNAPTBL  NUMBER OF ELEMENTS\n         SPACE 1\nSNAPTLE  DC    Y(SNAPTBL)          ELEMENT LENGTH\nSNAPMAX  DC    Y(SNAPTBM)          NUMBER OF ELEMENTS (MAX ID)\nSNAPSW   DC    XL1'0'\nSNAPFNA  EQU   X'01'               SNAP FUNCTION NOT ACTIVE.\nSNAPOPN  EQU   X'02'               SNAP DATA-SET IS OPENED.\nSHDO     DC    AL1(L'SHDOT)\nSHDOT    DC    C'P O F - DUMP OF COMMAND OUTPUT BUFFER (SENDCMD).'\nSHDI     DC    AL1(L'SHDIT)\nSHDIT    DC    C'P O F - DUMP OF COMMAND INPUT BUFFER (RCVCMD).'\n         SPACE 1\n        LTORG\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - DO ISPF PROCESSING.                                    *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n*              R0    = PARM./WORK REGISTER\n*              R1    = PARM./WORK REGISTER\n*              R2-R7 = ALL SAVED AND RESTORED\n*              R8    = ADDRESS OF DATA AREA (PASSED BY CALLER)\n*              R9    = LINK REGISTER\n*              R10   = ENTRY ADDRESS / LOCAL BASE REGISTER\n*              R12   = CALLER BASE REGISTER\n*              R13   = MAIN SAVE AREA POINTER\n*        AT ENTRY R15 = REQUEST CODE 0 - INITIALIZATION / TERMINATION\n*                                    1 - SET MESSAGES (SHORT/LONG)\n*                                    2 - ADD TO TABLE\n*                                    3 - DISPLAY TABLE\n*        AT EXIT R15 = RETURN CODE 0 - NORMAL, OK\n*                                  4 - SPECIAL CONDITION, OK\n*                                  8 - ERROR, ABORT\n         SPACE 1\n         CNOP  0,4\n         USING *,R10\nDOISPF   STM   R2,R7,SV#REGS\n         LTR   R15,R15\n         BM    RCISPF8\n         BP    WHISPF\n         TM    SW#ISPF,SW#VDF\n         BO    EXISPF\n         TM    SW#ISPF,SW#VDL\n         BO    RCISPF8\n        CALL   ISPLINK,(#VDEFINE,MS,MST,#CHAR,MSL),VL\n         LTR   R15,R15\n         BZ    OKISPF\n         LA    R0,C'S'\nERISPF1  MVC   M#ISPF+25(10),=CL10' MSG/  *'\n         STC   R0,M#ISPF+30\nERISPF2  MVC   M#ISPF+17(8),#VDEFINE\nERISPF3  MVC   M#ISPF(17),=CL17' -- * RC =     -'\n         CVD   R15,DBL#WK\n         MVC   M#ISPF+10(4),=XL4'40202120'\n         ED    M#ISPF+10(4),DBL#WK+6\n        TPUT   M#ISPF,35\n         OI    SW#ISPF,SW#VDL\n         B     RCISPF8\nOKISPF  CALL   ISPLINK,(#VDEFINE,ML,MLT,#CHAR,MLL),VL\n         LTR   R15,R15\n         BZ    *+L'*+8\n         LA    R0,C'L'\n         B     ERISPF1\n        CALL   ISPLINK,(#VDEFINE,#VTCMD,VTCMD,#CHAR,LGHVT),VL\n         LTR   R15,R15\n         BZ    *+L'*+10\n         MVC   M#ISPF+25(10),=CL10' VTCMD *'\n         B     ERISPF2\n        CALL   ISPLINK,(#VDEFINE,#X,X,#CHAR,LGHX),VL\n         LTR   R15,R15\n         BZ    *+L'*+10\n         MVC   M#ISPF+25(10),=CL10' X *'\n         B     ERISPF2\n         LM    R2,R4,=A(L'SNTABLE,SNTBEND,SNTABLE)\nSTISPF   LA    R5,10(R4)\n        CALL   ISPLINK,(#VDEFINE,(R4),(R5),#CHAR,LGHPV),VL\n         LTR   R15,R15\n         BZ    *+L'*+10\n         MVC   M#ISPF+25(10),=CL10' POFVT *'\n         B     ERISPF2\n         BXLE  R4,R2,STISPF\n         OI    SW#ISPF,SW#VDF\n         B     RCISPF0\nEXISPF   TM    SW#ISPF,SW#VDL\n         BO    RCISPF8\n        CALL   ISPLINK,(#VDELETE,#VTCMD),VL\n         LTR   R15,R15\n         BZ    *+L'*+16\n         MVC   M#ISPF+25(10),=CL10' VTCMD *'\nERISPF4  MVC   M#ISPF+17(8),#VDELETE\n         B     ERISPF3\n        CALL   ISPLINK,(#VDELETE,#X),VL\n         LTR   R15,R15\n         BZ    *+L'*+10\n         MVC   M#ISPF+25(10),=CL10' X *'\n         B     ERISPF4\n         LM    R2,R4,=A(L'SNTABLE,SNTBEND,SNTABLE)\nDLISPF  CALL   ISPLINK,(#VDELETE,(R4)),VL\n         LTR   R15,R15\n         BZ    *+L'*+10\n         MVC   M#ISPF+25(10),=CL10' POFVT *'\n         B     ERISPF4\n         BXLE  R4,R2,DLISPF\n         OI    SW#ISPF,SW#VDL\n         TM    SW#ISPF,SW#TBL\n         BZ    RCISPF0\n        CALL   ISPLINK,(#TBEND,#RPTB),VL\n         LTR   R15,R15\n         BZ    RCISPF0\n         MVC   M#ISPF+25(10),=CL10' RSPTAB *'\n         MVC   M#ISPF+17(8),#TBEND\n         B     ERISPF3\nWHISPF   TM    SW#ISPF,SW#VDF\n         BZ    RCISPF8\n         TM    SW#ISPF,SW#VDL\n         BO    RCISPF8\n         CH    R15,MXISPF\n         BH    RCISPF8\n         SLL   R15,2\n         B     *(R15)              SELECT FUNCTION\nGOISPF   B     MSISPF              1 - SET MESSAGES\n         B     ATISPF              2 - ADD TO TABLE\n         B     DTISPF              3 - DISPLAY TABLE\n         B     RTISPF              4 - RESET TABLE\nMXISPF   DC    Y((*-GOISPF)/4)\nMSISPF   MVI   MLT,C' '            R0 = LONG MESSAGE TEXT LENGTH\n         MVC   MLT+1(L'MLT-1),MLT  R1 -> SHORT MSG TEXT (CL8), FOLLOWED\n         MVC   MST(L'MST),0(R1)          LONG MSG TEXT (CL..., MAX=72)\n         LA    R15,L'MLT\n         CLR   R15,R0\n         BNH   *+L'*+2\n         LR    R15,R0\n         BCT   R15,*+L'*+6\n         MVC   MLT(*-*),0+L'MST(R1)\n         EX    R15,*-6\n        CALL   ISPLINK,(#VREP,MS,MSL,MST),VL\n         LTR   R15,R15\n         BZ    *+L'*+24\n         LA    R0,C'S'\nERISPF5  MVC   M#ISPF+25(10),=CL10' MSG/  *'\n         STC   R0,M#ISPF+30\nERISPF6  MVC   M#ISPF+17(8),#VREP\n         B     ERISPF3\n        CALL   ISPLINK,(#VREP,ML,MLL,MLT),VL\n         LTR   R15,R15\n         BZ    *+L'*+8\n         LA    R0,C'L'\n         B     ERISPF5\n        CALL   ISPLINK,(#SETM,#MSGID),VL\n         LTR   R15,R15\n         BZ    RCISPF0\n         MVC   M#ISPF+25(10),=CL10' PAJZ000 *'\n         MVC   M#ISPF+17(8),#SETM\n         B     ERISPF3\nATISPF   TM    SW#ISPF,SW#TBL+SW#TBR\n         BO    XAISPF\n         STM   R0,R1,DBL#WK\n        CALL   ISPLINK,(#TBCREAT,#RPTB,,,#NOWRITE,#REPLACE),VL\n         CH    R15,=H'4'\n         BL    *+L'*+20\n         BE    *+L'*+20\n         MVC   M#ISPF+25(10),=CL10' RSPTAB *'\n         MVC   M#ISPF+17(8),#TBCREAT\n         B     ERISPF3\n         OI    SW#ISPF,SW#TBL\n         OI    SW#ISPF,SW#TBR\n         LM    R0,R1,DBL#WK\nXAISPF   MVI   X,C' '              R0 = LINE TEXT LENGTH\n         MVC   X+1(L'X-1),X        R1 -> LINE TEXT (CL..., MAX=78)\n         LA    R15,L'X\n         CLR   R15,R0\n         BNH   *+L'*+2\n         LR    R15,R0\n         BCT   R15,*+L'*+6\n         MVC   X(*-*),0(R1)\n         EX    R15,*-6\n        CALL   ISPLINK,(#TBADD,#RPTB,#X),VL\n         LTR   R15,R15\n         BZ    RCISPF0\n         MVC   M#ISPF+25(10),=CL10' RSPTAB *'\n         MVC   M#ISPF+17(8),#TBADD\n         B     ERISPF3\nDTISPF   TM    SW#ISPF,SW#TBL+SW#TBR\n         BNO   RCISPF8\n         STM   R0,R1,DBL#WK\n         MVI   VTCMD,C' '\n         MVC   VTCMD+1(L'VTCMD-1),VTCMD\n         L     R15,LGHVT\n         CLR   R15,R0\n         BNH   *+L'*+2\n         LR    R15,R0\n         BCT   R15,*+L'*+6\n         MVC   VTCMD(*-*),0(R1)\n         EX    R15,*-6\n        CALL   ISPLINK,(#VREP,#VTCMD,LGHVT,VTCMD),VL\n         LTR   R15,R15\n         BZ    *+L'*+16\n         MVC   M#ISPF+25(10),=CL10' VTCMD *'\n         MVC   M#ISPF+17(8),#VREP\n         B     ERISPF3\n        CALL   ISPLINK,(#TBTOP,#RPTB),VL\n         LTR   R15,R15\n         BZ    *+L'*+16\n         MVC   M#ISPF+25(10),=CL10' RSPTAB *'\n         MVC   M#ISPF+17(8),#TBTOP\n         B     ERISPF3\n        CALL   ISPLINK,(#TBDISPL,#RPTB,#RPAN),VL\n         CH    R15,=H'8'\n         BE    RCISPF4\n         LTR   R15,R15\n         BZ    *+L'*+16\n         MVC   M#ISPF+25(10),=CL10' RSPTAB *'\n         MVC   M#ISPF+17(8),#TBDISPL\n         B     ERISPF3\n         LM    R0,R1,DBL#WK        R0 = MAX. INPUT TEXT LENGTH\n         MVI   0(R1),C' '          R1 -> INPUT TEXT TO MOVE\n         LR    R15,R0\n         BCTR  R15,0\n         BCT   R15,*+L'*+6\n         MVC   1(*-*,R1),0(R1)\n         EX    R15,*-6\n         LA    R3,VTCMD\n         LR    R4,R3\n         AL    R3,LGHVT\n         BCTR  R3,0\n         LA    R2,1\n         CLI   0(R4),C' '\n         BNE   *+L'*+8\n         BXLE  R4,R2,*-8\n         B     SZISPF\n         CLI   0(R3),C' '\n         BNE   *+L'*+12\n         BCTR  R3,0\n         CLR   R3,R4\n         BL    SZISPF\n         B     *-16\n         SLR   R3,R4\n         EX    R3,*+L'*+8\n         LA    R1,1(R3)            R1 = INPUT TEXT LENGTH\n         B     RCISPF0\n         OC    0(*-*,R1),0(R4)     MAKE UPPERCASE FOR WRITING TO SYSLOG\nSZISPF   XR    R1,R1               R1 = NULL INPUT TEXT LENGTH\n         B     RCISPF0\nRTISPF   NI    SW#ISPF,255-SW#TBR\n         B     RCISPF0\nRCISPF8  LA    R15,8               RC=8\n         B     RSISPF\nRCISPF4  LA    R15,4               RC=4\n         B     RSISPF\nRCISPF0  XR    R15,R15             RC=0\nRSISPF   LM    R2,R7,SV#REGS\n         BR    R9\n         DROP  R10\n         SPACE 1\nDBL#WK   DC    D'0'\nSV#REGS  DC    6F'0'\nM#ISPF   DC    CL40' '\n         SPACE 1\nLGHVT    DC    A(L'VTCMD)\nLGHX     DC    A(L'X)\nLGHPV    DC    A(L'POFVT)\nMSL      DC    A(L'MST)\nMLL      DC    A(L'MLT)\n         SPACE 1\nVTCMD    DC    CL48' '\nX        DC    CL78' '\nMST      DC    CL8' '\nMLT      DC    CL72' '\n         SPACE 1\n#VDEFINE DC    CL8'VDEFINE'\n#VREP    DC    CL8'VREPLACE'\n#VDELETE DC    CL8'VDELETE'\n#TBCREAT DC    CL8'TBCREATE'\n#TBADD   DC    CL8'TBADD'\n#TBTOP   DC    CL8'TBTOP'\n#TBDISPL DC    CL8'TBDISPL'\n#TBEND   DC    CL8'TBEND'\n#RPTB    DC    CL8'RSPTAB'\n#RPAN    DC    CL8'PAJPOF'\n#NOWRITE DC    CL8'NOWRITE'\n#REPLACE DC    CL8'REPLACE'\n#SETM    DC    CL8'SETMSG'\n#MSGID   DC    CL8'PAJZ000'\n         SPACE 1\nMS       DC    C'(EUMSGS) '\nML       DC    C'(EUMSGL) '\n#VTCMD   DC    C'(VTCMD) '\n#X       DC    C'(X) '\n#CHAR    DC    C'CHAR '\n         SPACE 1\nSW#ISPF  DC    XL1'0'\nSW#VDF   EQU   X'80'\nSW#VDL   EQU   X'40'\nSW#TBL   EQU   X'20'\nSW#TBR   EQU   X'10'\n         SPACE 1\n        LTORG\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        POF - DATA DESCRIPTIONS (DSECTS).                            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n        ISTDPOHD\n        IFGACB AM=VTAM\n        IFGRPL AM=VTAM\n        IKJPSCB\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DEVD=DA,DSORG=PS\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJPVQ": {"ttr": 26884, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(\\x8f\\x00\\x90(\\x8f\\t(\\x02\\x03\\x02\\x03\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-15T00:00:00", "modifydate": "1990-10-15T09:28:00", "lines": 515, "newlines": 515, "modlines": 0, "user": "SYSPAJA"}, "text": "PVQ      TITLE 'VENQ - GRS/ENQ DISPLAY.'\nPAJPVQ   START 0\n         SPACE 1\n* ORIGIN : EXTRACTED FROM CBT TAPE 90 MAY, FILE 103.\n*          DATA SET VUTL16 AT LEVEL 005 AS OF 06/25/85\n*          SOME ADJUSMENTS DONE BY : MOINIL P.A.\n         SPACE 1\n        $DEFREG\n*------- INITIALIZATION\n         SPACE 1\n        $XENT  BASE=(R11,R12)\n         EJECT\n*------- DEFINE DISPLAY VARIABLES TO ISPF\n         SPACE 1\n        PRINT  NOGEN\n        CALL   ISPLINK,(#VDEFINE,MS,MST,#CHAR,MSL),VL\n         LTR   R10,R15\n         BNZ   QUIT\n        CALL   ISPLINK,(#VDEFINE,ML,MLT,#CHAR,MLL),VL\n         LTR   R10,R15\n         BNZ   QUIT\n        CALL   ISPLINK,(#VDEFINE,#JOB,JOB,#CHAR,LGH8),VL\n         LTR   R15,R15\n         BNZ   ERR1\n        CALL   ISPLINK,(#VDEFINE,#MAJOR,MAJOR,#CHAR,LGH8),VL\n         LTR   R15,R15\n         BNZ   ERR2\n        CALL   ISPLINK,(#VDEFINE,#MINOR,MINOR,#CHAR,MINLG),VL\n         LTR   R15,R15\n         BNZ   ERR3\n        CALL   ISPLINK,(#VDEFINE,#X,X,#CHAR,LG80),VL\n         LTR   R15,R15\n         BNZ   ERR4\n        CALL   ISPLINK,(#VDEFINE,#T1,T1,#CHAR,LG80),VL\n         LTR   R15,R15\n         BNZ   ERR5\n        CALL   ISPLINK,(#VDEFINE,#T2,T2,#CHAR,LG80),VL\n         LTR   R15,R15\n         BNZ   ERR6\n         EJECT\n*------- DISPLAY FIRST PANEL\n         SPACE 1\nDVENQ1  CALL   ISPLINK,(#DISPLAY,#VENQ1),VL\n         CH    R15,=H'8'\n         BE    RETURN\n         LTR   R15,R15\n         BNZ   ERR10\n        CALL   ISPLINK,(#TBCREAT,#ENQTAB,,,#NOWRITE,#REPLACE),VL\n         CH    R15,=H'4'\n         BH    ERR11\n         BE    *+L'*+4\n         OI    SWITCH,TBLCRT\n         MVC   TCOUNT(4),=F'0'     BLANK OUT COUNT FIELD\n         XR    R3,R3               WAIT COUNT ZERO BY DEFAULT\n         MVC   T1,XB               BLANK OUT T1\n         MVC   T2,XB               BLANK OUT T2\n         CLI   JOB,C' '            JOB BLANK ?\n         BE    NOTJOB1             YES\n         MVC   T1(27),=CL27'ENQ STATUS FOR JOB XXXXXXXX'\n         MVC   T1+19(8),JOB\n         MVC   T2(35),=CL35'TYPE STATUS  SCOPE   MAJOR    MINOR'\n         B     CONT1\nNOTJOB1  MVC   T2(22),=CL22'SCOPE   MAJOR    MINOR'\n         CLI   MAJOR,C' '          MAJOR BLANK ?\n         BNE   NOTCONT             NO\n         CLI   MINOR,C' '          MINOR BLANK ?\n         BNE   NOTCONT             NO\n         LA    R3,1                YES, CONTENTION REQUESTED\n         MVC   T1(14),=CL14'ENQ CONTENTION'\n         B     CONT1\nNOTCONT  MVC   T1(35),=CL35'ENQ STATUS FOR MAJOR XXXXXXXX MINOR'\n         MVC   T1+21(8),MAJOR      MOVE MAJOR NAME TO MESSAGE\n         MVC   T1+36(L'MINOR),MINOR MOVE MINOR NAME\nCONT1    MVC   TKN,=F'0'           RESET TOKEN\n         LA    R5,MINOR            POINT TO MINOR\n         L     R14,=A(BLTABLE)\n         TRT   MINOR,0(R14)        LOOK FOR BLANK\n         BNZ   FONE                FOUND A BLANK\n         LA    R6,L'MINOR          NO BLANK, ALL BYTES ARE PRESENT\n         B     SCAN                GO DO IT\nFONE     SR    R1,R5               GET MINOR LENGTH\n         LR    R6,R1               LOAD IT INTO R6\n         EJECT\n*------- PREPARE TO SCAN GRS CONTROL BLOCKS\n         SPACE 1\nSCAN     L     R0,SVGETL           GETMAIN AREA FOR RIB/RIBE\n        GETMAIN R,LV=(0)\n         ST    R1,SVGETM           SAVE GETMAIN ADDR\n         LR    R4,R1               LOAD R4 WITH GETMAINED ADDR\n         USING RIB,R4\n         L     R0,SVGETL           GETMAIN AREA FOR RIB/RIBE\n         CLI   MAJOR,C' '\n         BE    SCANALL\n         CLI   MINOR,C' '\n         BE    SCANDSN\n         SPACE 1\n*------- SCAN WITH BOTH MAJOR AND MINOR NAMES SPECIFIED\n         SPACE 1\n        GQSCAN AREA=((R4),(R0)),SCOPE=ALL,                             C\n               RESNAME=(MAJOR,(R5),(R6)),                              C\n               TOKEN=TKN\n         B     CKRTN\n         SPACE 1\n*------- SCAN WITH JUST MAJOR NAME SPECIFIED\n         SPACE 1\nSCANDSN GQSCAN AREA=((R4),(R0)),SCOPE=ALL,                             C\n               RESNAME=(MAJOR),                                        C\n               TOKEN=TKN\n         B     CKRTN               GO CHECK RETURN CODE\n         SPACE 1\n*------- SCAN FOR ALL DATA\n         SPACE 1\nSCANALL GQSCAN AREA=((R4),(R0)),SCOPE=ALL,WAITCNT=(R3),                C\n               TOKEN=TKN\nCKRTN    MVI   MLT,C' '\n         MVC   MLT+1(L'MLT-1),MLT\n         B     *+L'*(R15)\n         B     FOUND               RC=0  RESOURCE FOUND\n         B     NOTFOUND            RC=4  RESOURCE NOT FOUND\n         B     FULL                RC=8  QUEUE AREA FULL\n         B     ABEND               RC=12 ABNORMAL SITUATION\n         B     INVLD               RC=16 INVALID SYSNAME\nFOUND    BAS   R9,LISTDTL          DISPLAY COMPLETED TABLE\n         CLC   TCOUNT(4),=F'0'     ANYTHING IN THE TABLE ?\n         BNE   GOODTAB             YES\n         MVC   MST(8),=CL8'NONE ...' SET SHORT MESSAGE\n         CLI   JOB,C' '            JOB BLANK ?\n         BE    NOTJOB2             YES\n         CLI   MINOR,C' '          MINOR BLANK ?\n         BE    *+L'*+10            YES\n         MVC   MLT(28),=CL28'NONE FOR JOB-NAME/MINOR-NAME'\n         B     STMSG\n         MVC   MLT(17),=CL17'NONE FOR JOB-NAME'\n         B     STMSG\nNOTJOB2  MVC   MLT(19),=CL19'NONE FOR MINOR-NAME'\n         B     STMSG\nGOODTAB CALL   ISPLINK,(#TBTOP,#ENQTAB),VL\n         LTR   R15,R15\n         BNZ   ERR12\n        CALL   ISPLINK,(#TBDISPL,#ENQTAB,#VENQ2),VL\n         LTR   R15,R15\n         BZ    DVENQ1\n         CH    R15,=H'8'\n         BE    DVENQ1\n         B     ERR13\nNOTFOUND MVC   MST(8),=CL8'NONE ...' SET SHORT MESSAGE\n         CLI   MINOR,C' '          MINOR BLANK ?\n         BE    TSTMAJ              YES\n         CLI   JOB,C' '            JOB BLANK ?\n         BE    *+L'*+10            YES\n         MVC   MLT(39),=CL39'NONE FOR JOB-NAME/MAJOR-NAME/MINOR-NAME'\n         B     STMSG\n         MVC   MLT(30),=CL30'NONE FOR MAJOR-NAME/MINOR-NAME'\n         B     STMSG\nTSTMAJ   CLI   MAJOR,C' '          MAJOR BLANK ?\n         BE    CNTNTN              YES\n         CLI   JOB,C' '            JOB BLANK ?\n         BE    *+L'*+10            YES\n         MVC   MLT(28),=CL28'NONE FOR JOB-NAME/MAJOR-NAME'\n         B     STMSG\n         MVC   MLT(19),=CL19'NONE FOR MAJOR-NAME'\n         B     STMSG\nCNTNTN   MVC   MLT(17),=CL17'NO CONTENTION ...'\n         B     STMSG\nFULL     BAS   R9,LISTDTL          LIST FIRST BLOCK\n         L     R1,SVGETM           LOAD ADDR OF GETMAIN\n         L     R0,SVGETL           LOAD LENGTH OF GETMAIN\n        FREEMAIN R,LV=(0),A=(1)\n         XC    SVGETM,SVGETM\n         B     SCAN                REISSUE GQSCAN\nABEND    MVC   MST(8),=CL8'ERROR   ' SET SHORT MESSAGE\n         MVC   MLT(34),=CL34'RC=12 - ENQ/GRS ABNORMAL SITUATION'\n         B     STMSG\nINVLD    MVC   MST(8),=CL8'INVALID ' SET SHORT MESSAGE\n         MVC   MLT(31),=CL31'RC=16 - ENQ/GRS INVALID SYSNAME'\n         SPACE 1\n*------- PASS MESSAGES TO ISPF\n         SPACE 1\nSTMSG   CALL   ISPLINK,(#VREP,MS,MSL,MST),VL\n         LTR   R10,R15\n         BNZ   ERRSM\n        CALL   ISPLINK,(#VREP,ML,MLL,MLT),VL\n         LTR   R10,R15\n         BNZ   ERRSM\n        CALL   ISPLINK,(#SETM,#MSGID),VL\n         LTR   R10,R15\n         BZ    DVENQ1              GO DISPLAY INITIAL PANEL\nERRSM    O     R10,=A(X'0000FF00')\n         B     LEAVE\n         EJECT\n*------- DELETE DISPLAY VARIABLES TO ISPF\n         SPACE 1\nRETURN  CALL   ISPLINK,(#VDELETE,#JOB),VL\n         LTR   R15,R15\n         BNZ   ERR20\n        CALL   ISPLINK,(#VDELETE,#MAJOR),VL\n         LTR   R15,R15\n         BNZ   ERR21\n        CALL   ISPLINK,(#VDELETE,#MINOR),VL\n         LTR   R15,R15\n         BNZ   ERR22\n        CALL   ISPLINK,(#VDELETE,#X),VL\n         LTR   R10,R15\n         BNZ   ERR23\n         SPACE 1\n*------- TERMINATION\n         SPACE 1\n        PRINT  GEN\nLEAVE    TM    SWITCH,TBLCRT       TABLE CREATED ?\n         BZ    FRAREA              NO\n        CALL   ISPLINK,(#TBEND,#ENQTAB),VL\n         LTR   R10,R10\n         BNZ   FRAREA\n         LR    R10,R15\nFRAREA   ICM   R1,B'1111',SVGETM   LOAD ADDR OF GETMAIN\n         BZ    QUIT                BRANCH IF NONE\n         L     R0,SVGETL           LOAD LENGTH OF GETMAIN\n        FREEMAIN R,LV=(0),A=(1)\n         XC    SVGETM,SVGETM\nQUIT    $XRET  CC=(R10)            RETURN\n         EJECT\n*------- GENERATE ERROR MESSAGES\n         SPACE 1\nERR1     MVC   MLT+47(8),=CL8'JOB'\n         B     ERRA\nERR2     MVC   MLT+47(8),=CL8'MAJOR'\n         B     ERRA\nERR3     MVC   MLT+47(8),=CL8'MINOR'\n         B     ERRA\nERR4     MVC   MLT+47(8),=CL8'X'\n         B     ERRA\nERR5     MVC   MLT+47(8),=CL8'T1'\n         B     ERRA\nERR6     MVC   MLT+47(8),=CL8'T2'\nERRA     MVC   MLT+34(10),=CL10'  VARIABLE'\n         MVC   MLT+23(8),#VDEFINE\n         B     ERRET\nERR10    MVC   MLT+47(8),#VENQ1\n         MVC   MLT+34(10),=CL10'     PANEL'\n         MVC   MLT+23(8),#DISPLAY\n         B     ERRET\nERR11    MVC   MLT+23(8),#TBCREAT\n         B     ERRB\nERR12    MVC   MLT+23(8),#TBTOP\n         B     ERRB\nERR13    MVC   MLT+23(8),#TBDISPL\n         B     ERRB\nERR14    MVC   MLT+23(8),#TBADD\nERRB     MVC   MLT+47(8),#ENQTAB\n         MVC   MLT+34(10),=CL10'TABLE NAME'\n         B     ERRET\nERR20    MVC   MLT+47(8),=CL8'JOB'\n         B     ERRC\nERR21    MVC   MLT+47(8),=CL8'MAJOR'\n         B     ERRC\nERR22    MVC   MLT+47(8),=CL8'MINOR'\n         B     ERRC\nERR23    MVC   MLT+47(8),=CL8'X'\nERRC     MVC   MLT+34(10),=CL10'  VARIABLE'\n         MVC   MLT+23(8),#VDELETE\nERRET    CVD   R15,WORKD           EDIT RC\n         MVC   MST+4(4),=XL4'40202120'\n         ED    MST+4(4),WORKD+6\n         MVC   MST(4),=CL4'RC ='\n         MVC   MLT(23),=CL23'-- ERROR AT FUNCTION : '\n         MVC   MLT+31(3),=CL3' / '\n         MVC   MLT+44(3),=CL3' : '\n         MVC   MLT+55(4),=CL4' -- '\n         MVC   MLT+59(L'MLT-59),MLT+58\n        CALL   ISPLINK,(#VREP,MS,MSL,MST),VL\n         LR    R10,R15\n        CALL   ISPLINK,(#VREP,ML,MLL,MLT),VL\n         LTR   R10,R10\n         BZ    *+L'*+6\n         SLL   R15,8\n         OR    R10,R15\n        CALL   ISPLINK,(#SETM,#MSGID),VL\n         LTR   R10,R10\n         BZ    LEAVE\n         SLL   R15,16\n         OR    R10,R15\n         B     LEAVE\n         EJECT\n*------- BUILD 'ENQTAB' ROUTINE (LINK = R9)\n         SPACE 1\nLISTDTL  L     R5,SVGETM           GETMAIN'D AREA ADDRESS.\n         AL    R5,SVGETL           POINT PAST END\n         CR    R4,R5               POINTING PAST END ?\n         BNLR  R9                  YES.\n         CLC   0(4,R4),=F'0'       CHECK IF LAST RESOURCE\n         BER   R9                  YES... RETURN\n         LA    R5,40(R4)           LOAD ADDR OF RIBVAR\n         USING RIBVAR,R5\n         LR    R6,R5\n         AH    R6,RIBVLEN          ADDRESS RIBE DESECT\n         USING RIBE,R6\n         L     R7,RIBNRIBE         LOAD NUMBER OF ENTRIES\n         TM    RIBSCOPE,RIBSYS     SYSTEM\n         BNO   CKRIBSS\n         MVC   X1SCOPE(8),=CL8'SYSTEM'\n         B     CKMAJ\nCKRIBSS  TM    RIBSCOPE,RIBSYSS    SYSTEMS\n         BNO   CKRIBST\n         MVC   X1SCOPE(8),=CL8'SYSTEMS'\n         B     CKMAJ\nCKRIBST  TM    RIBSCOPE,RIBSTEP    STEP\n         BNO   CKRIBGL\n         MVC   X1SCOPE(8),=CL8'STEP'\n         B     CKMAJ\nCKRIBGL  TM    RIBSCOPE,RIBGLBL    GLOBAL\n         BNO   CKRIBLO\n         MVC   X1SCOPE(8),=CL8'GLOBAL'\n         B     CKMAJ\nCKRIBLO  MVC   X1SCOPE(8),=CL8'LOCAL'\nCKMAJ    MVC   X3SCOPE(8),X1SCOPE\n         MVC   X1MAJOR(8),RIBQNAME MOVE MAJOR NAME\n         MVC   X3MAJOR(8),X1MAJOR\nCKMIN    XR    R2,R2               CLEAR R2\n         IC    R2,RIBRNMLN\n         CL    R2,MINLG            CHECK IF MINOR GREATER MAX CHAR\n         BNH   *+L'*+4             NO... OK\n         LA    R2,L'MINOR          MAKE MAX CHAR\n         BCTR  R2,0                DECREMENT BY 1 FOR MOVE\n         MVC   X1MINOR(L'MINOR),XB BLANK OUT\n         MVC   X3MINOR(L'MINOR),XB MINORS\n         EX    R2,DSPLMIN1         MOVE MINOR\n         EX    R2,DSPLMIN2         MOVE MINOR\n         L     R14,=A(TT)\n         TR    X1MINOR(L'X1MINOR),0(R14) TRANSLATE NON PRINTABLES\n         TR    X3MINOR(L'X3MINOR),0(R14)\n         NI    SWITCH,255-MNTOK    * MINOR OK *\n         CLI   MINOR,C' '          MINOR BLANK ?\n         BE    NOTMIN              YES\n         CLC   MINOR(L'MINOR),X1MINOR IS THIS THE RIGHT MINOR ?\n         BE    NOTMIN              YES\n         OI    SWITCH,MNTOK        * MINOR NOT OK *\n         B     OWNER\nNOTMIN   CLI   JOB,C' '            IS JOB BLANK ?\n         BNE   OWNER               NO\n         MVC   X,X1                YES, CREATE LINE 1\n        CALL   ISPLINK,(#TBADD,#ENQTAB,#X),VL\n         LTR   R15,R15\n         BNZ   ERR14\n         L     R2,TCOUNT\n         LA    R2,1(R2)\n         ST    R2,TCOUNT\nOWNER    TM    SWITCH,MNTOK        MINOR OK ?\n         BO    CONT3               NO, SKIP\n         TM    RIBERFLG,RIBETYPE   SHR/EXC\n         BNO   CKRIBEX\n         MVC   X2TYPE(4),=CL4'SHR '\n         MVC   X3TYPE(4),X2TYPE\n         B     CKOWN\nCKRIBEX  MVC   X2TYPE(4),=CL4'EXCL'\n         MVC   X3TYPE(4),X2TYPE\nCKOWN    MVC   X2JOB(8),RIBEJBNM   MOVE JOBNAME OF REQUESTER\n         TM    RIBESFLG,RIBESTAT\n         BZ    *+L'*+10\n         MVC   X2STATUS(7),=CL7'OWNER  '\n         B     *+L'*+6\n         MVC   X2STATUS(7),=CL7'WAITING'\n         MVC   X3STATUS(7),X2STATUS\n         MVC   X2(8),=XL8'0000000000000000'\n         MVC   X2SYSID(4),RIBESYSN\n         CLI   JOB,C' '\n         BE    NOTJOB3\n         CLC   JOB,RIBEJBNM\n         BNE   CONT3\n         MVC   X,X3\n        CALL   ISPLINK,(#TBADD,#ENQTAB,#X),VL\n         LTR   R15,R15\n         BNZ   ERR14\n         L     R2,TCOUNT\n         LA    R2,1(R2)\n         ST    R2,TCOUNT\n         B     CONT3\nNOTJOB3  MVC   X,X2\n        CALL   ISPLINK,(#TBADD,#ENQTAB,#X),VL\n         LTR   R15,R15\n         BNZ   ERR14\n         L     R2,TCOUNT\n         LA    R2,1(R2)\n         ST    R2,TCOUNT\nCONT3    LA    R6,36(R6)\n         MVC   X1,XB\n         MVC   X2,XB\n         BCT   R7,OWNER\n         LR    R4,R6\n         B     LISTDTL\n         SPACE 1\nDSPLMIN1 MVC   X1MINOR(0),RIBRNAME <<EXECUTED>>\nDSPLMIN2 MVC   X3MINOR(0),RIBRNAME <<EXECUTED>>\n         EJECT\n*------- CONSTANTS AND WORK-AREAS\n         SPACE 1\nWORKD    DC    D'0'\nSVGETM   DC    F'0'\nSVGETL   DC    F'4096'\nTKN      DC    F'0'\nTCOUNT   DC    F'0'\nLGH8     DC    F'8'\nLG80     DC    F'80'\nMINLG    DC    A(L'MINOR)\nMSL      DC    A(L'MST)\nMLL      DC    A(L'MLT)\n         SPACE 1\nJOB      DC    CL8' '\nMAJOR    DC    CL8' '\nMINOR    DC    CL44' '\nX        DC    CL80' '\nT1       DC    CL80' '\nT2       DC    CL80' '\nXB       DC    CL80' '\nMST      DC    CL8' '\nMLT      DC    CL72' '\nSWITCH   DC    XL1'0'\nTBLCRT   EQU   X'80'\nMNTOK    EQU   X'01'\n         SPACE 1\n#DISPLAY DC    CL8'DISPLAY'\n#NOWRITE DC    CL8'NOWRITE'\n#REPLACE DC    CL8'REPLACE'\n#ENQTAB  DC    CL8'ENQTAB'\n#VDEFINE DC    CL8'VDEFINE'\n#VDELETE DC    CL8'VDELETE'\n#VREP    DC    CL8'VREPLACE'\n#TBCREAT DC    CL8'TBCREATE'\n#TBDISPL DC    CL8'TBDISPL'\n#TBADD   DC    CL8'TBADD'\n#TBTOP   DC    CL8'TBTOP'\n#TBEND   DC    CL8'TBEND'\n#VENQ1   DC    CL8'PAJVQ1'\n#VENQ2   DC    CL8'PAJVQ2'\n#SETM    DC    CL8'SETMSG'\n#MSGID   DC    CL8'PAJZ000'\n         SPACE 1\nMS       DC    C'(EUMSGS) '\nML       DC    C'(EUMSGL) '\n#JOB     DC    C'(JOB) '\n#MAJOR   DC    C'(MAJOR) '\n#MINOR   DC    C'(MINOR) '\n#X       DC    C'(X) '\n#T1      DC    C'(T1) '\n#T2      DC    C'(T2) '\n#CHAR    DC    C'CHAR '\n         SPACE 1\n*------- LINE 1 FOR NON-JOB-SPECIFIC\n         SPACE 1\nX1       DC    CL80' '\nX1SCOPE  EQU   X1\nX1MAJOR  EQU   X1+8\nX1MINOR  EQU   X1+17\n         SPACE 1\n*------- LINE 2 FOR NON-JOB-SPECIFIC\n         SPACE 1\nX2       DC    CL80' '\nX2STATUS EQU   X2+8\nX2TYPE   EQU   X2+17\nX2SYSID  EQU   X2+22\nX2JOB    EQU   X2+27\n         SPACE 1\n*------- LINE 1 FOR JOB-SPECIFIC\n         SPACE 1\nX3       DC    CL80' '\nX3TYPE   EQU   X3\nX3STATUS EQU   X3+5\nX3SCOPE  EQU   X3+13\nX3MAJOR  EQU   X3+21\nX3MINOR  EQU   X3+30\n         EJECT\n        LTORG\n         EJECT\nTT       EQU   *,256\n*                0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  00-0F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  10-1F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  20-2F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  30-3F\n         DC    X'404B4B4B4B4B4B4B4B4B4A4B4C4D4E4F'  40-4F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  50-5F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  60-6F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  70-7F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  80-8F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  90-9F\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  A0-AF\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  B0-BF\n         DC    X'C0C1C2C3C4C5C6C7C8C94B4B4B4B4B4B'  C0-CF\n         DC    X'4BD1D2D3D4D5D6D7D8D94B4B4B4B4B4B'  D0-DF\n         DC    X'4B4BE2E3E4E5E6E7E8E94B4B4B4B4B4B'  E0-EF\n         DC    X'F0F1F2F3F4F5F6F7F8F94B4B4B4B4B4B'  F0-FF\n         SPACE 1\nBLTABLE  EQU   *,256\n*                0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'00000000000000000000000000000000'  00-0F\n         DC    X'00000000000000000000000000000000'  10-1F\n         DC    X'00000000000000000000000000000000'  20-2F\n         DC    X'00000000000000000000000000000000'  30-3F\n         DC    X'01000000000000000000000000000000'  40-4F\n         DC    X'00000000000000000000000000000000'  50-5F\n         DC    X'00000000000000000000000000000000'  60-6F\n         DC    X'00000000000000000000000000000000'  70-7F\n         DC    X'00000000000000000000000000000000'  80-8F\n         DC    X'00000000000000000000000000000000'  90-9F\n         DC    X'00000000000000000000000000000000'  A0-AF\n         DC    X'00000000000000000000000000000000'  B0-BF\n         DC    X'00000000000000000000000000000000'  C0-CF\n         DC    X'00000000000000000000000000000000'  D0-DF\n         DC    X'00000000000000000000000000000000'  E0-EF\n         DC    X'00000000000000000000000000000000'  F0-FF\n         SPACE 1\n        PRINT  NOGEN\nRIB     ISGRIB\n        CVT    DSECT=YES,LIST=YES\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJSBUMU": {"ttr": 27139, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x9f\\x00\\x944\\x9f\\x15Y\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-15T00:00:00", "modifydate": "1994-12-15T15:59:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "//&USID.U  JOB (&ACCN),'-BROADCAST MESSAGES-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1,\n)SEL &DGRP \u00ac= &Z\n//             GROUP=&DGRP,\n)ENDSEL\n)SEL &PSWD \u00ac= &Z\n//             PASSWORD=(&PSWD),\n)ENDSEL\n//             USER=&USID\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//*       FORCED UNLOAD OF ALL TSO BROADCAST WAITING MESSAGES.        *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//BUMU    EXEC PGM=IKJEFT01\n//SYSUADS   DD DSN=SYS1.UADS,DISP=SHR\n//SYSTSPRT  DD SYSOUT=*\n//SYSTSIN   DD *\nLISTBC  NONOTICES\nEND\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJSDSP": {"ttr": 27141, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(/\\x00\\x90(/\\x11\\x08\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-09T00:00:00", "modifydate": "1990-10-09T11:08:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": ")SET TBSRC = 0\n)DOT MEMTABLE\n)SEL &TBSRC = 0\n1  Members list of data-set : &PDSN\n0    Name    VV.MM   Created  Last modified  Size  Init   Mod   ID\n   ========  --------------------------------------------------------\n)BLANK\n)ENDSEL\n)TB 14\n   &MEMBER!&STATS\n)SET TBSRC = &TBSRC + 1\n)SEL &TBSRC = 45\n)SET TBSRC = 0\n)ENDSEL\n)ENDDOT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJSEND": {"ttr": 27143, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x9f\\x00\\x88\\x15\\x9f\\x12\\x08\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-07T00:00:00", "modifydate": "1988-06-07T12:08:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": "%------------------  S E N D  a message to another TSO user  -------------------\n+Enter TSO id of receiver\n%===>_SNDUID +     If blank, message goes to MAIN operator.\n+Enter message text\n%===>_SNDM\n                                       +\n+                  If an apostrophe is to be part of the message, it must be\n+                  entered as 2 apostrophes.\n+\n+Enter SEND opt%===>_SNSO +  NOW   -  send the message now.\n+                           +blank -  send message to operator.\n+                           +SAVE  -  place message in mail box.\n+                           +LOGON -  send message now. If user is not logged\n+                           +         on, then place message in mail box.\n+\n+       WAIT opt%===>_SNWO  +NOWAIT - sender should not be kept waiting if any\n+                           +         user can't receive message immediately.\n+                           +WAIT   - sender (YOU) are willing to wait for\n+                           +         user to receive the message.\n+\n)INIT\n  .CURSOR = SNDUID\n  &SNDUID = TRANS (&SNDUID ' ',' ',*,*)\n  &SNDM = TRANS (&SNDM ' ',' ',*,*)\n  &SNSO = TRANS (&SNSO ' ',NOW,*,*)\n  &SNWO = TRANS (&SNWO ' ',NOWAIT,*,*)\n)PROC\n  IF (&SNDUID \u00ac= &Z)\n    VER (&SNDUID,NONBLANK)  VER(&SNDUID,NAME)\n  VER (&SNDM,NONBLANK)\n  IF (&SNSO \u00ac= &Z)\n    VER (&SNSO,NONBLANK)  VER(&SNSO,LIST,NOW,SAVE,LOGON)\n  VER (&SNWO,NONBLANK)  VER(&SNWO,LIST,NOWAIT,WAIT)\n  &SEL = 'CMD(%PAJCSEND)'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJSHWM": {"ttr": 27145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93#/\\x00\\x93#/\\t8\\x00n\\x00n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-08-20T00:00:00", "modifydate": "1993-08-20T09:38:00", "lines": 110, "newlines": 110, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n\\ TYPE(INPUT) COLOR(GREEN) CAPS(ON) INTENS(HIGH) HILITE(USCORE)\n\u00ac TYPE(TEXT) INTENS(LOW) SKIP(ON)\n\u00a2 TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n{ TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n} TYPE(TEXT) COLOR(RED) SKIP(ON)\n! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n\u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n~ TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n@ TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n? TYPE(TEXT) COLOR(YELLOW) HILITE(REVERSE) SKIP(ON)\n| TYPE(OUTPUT) COLOR(RED) JUST(ASIS) CAPS(OFF) SKIP(ON)\n# TYPE(OUTPUT) COLOR(PINK) JUST(ASIS) CAPS(OFF) SKIP(ON)\n)BODY CMD(SHCM) SMSG(SHSM) LMSG(SHLM) ASIS\n?                      `<\u00a6 SHOWMVS Batch, TSO or ISPF `>?                      \u00ac\n\u00ac\n~                                                                              \u00ac\n~  \u00ac \u00a2SHOWMVS :`display data about the running MVS system.!Enter below :\u00ac   ~  \u00ac\n~  \u00ac    }===>\u00a6Environment :\\SHENV\u00acI(SPF), B(ATCH) or T(SO), default ISPF    ~  \u00ac\n~  \u00ac    }===>\u00a6Output CAPS option :\\CAPS\u00acOFF or ON, default OFF              ~  \u00ac\n~  \u00ac    }===>\u00a6Pages heading :\\HPG\u00acY(ES) or N(O), default YES                ~  \u00ac\n~  \u00ac    }===>\u00a6Lines per page :\\LPG\u00ac20-200 range, default 60                 ~  \u00ac\n~  \u00ac    }===>\u00a6Starting page number :\\PGN  \u00ac1-90000 range, default 1         ~  \u00ac\n~  \u00ac    }===>\u00a6Submit Batch JCL option :\\SJCL\u00acleft blank, S(CAN) or C(OPY)   ~  \u00ac\n~  \u00ac  `If you want output on a\u00a2specific`data-set,!then enter :\u00ac             ~  \u00ac\n~  \u00ac    }===>\u00a6DS-name :\\SHWMDS                                            \u00ac ~  \u00ac\n~  \u00ac                    <---\u00a2unquoted fully qualified name\u00ac-------------->  ~  \u00ac\n~  \u00ac    }===>\u00a6DISP= :\\DDS\u00acO(LD) or M(OD), default OLD                       ~  \u00ac\n~  @                                                                        ~  \u00ac\n~  \u00acHit\u00a2ENTER key}(twice)\u00acto proceed or\u00a2END key\u00acto terminate.               ~  \u00ac\n~  \u00acHit\u00a2HELP key\u00acto get explanation or enter\u00a2CANCEL command\u00acto exit.        ~  \u00ac\n~                                                                              \u00ac\n\u00a2Command ===>_SHCM                                                             \u00ac\n\u00ac                          |SHSM                    \u00ac\n#SHLM                                                                          \u00ac\n\u00ac\n)INIT\n  .HELP = PAJTSHW0\n  IF (&SHFLD \u00ac= &Z)\n    .ATTR(&SHFLD) = 'COLOR(GREEN)'\n    &SHFLD = &Z\n  IF (&SHMSG \u00ac= &Z)\n    &CHKC = TRUNC (&SHCUR,'(')\n    &CHCK = .TRAIL\n    &SHFLD = TRUNC (&CHCK,')')\n    .ATTR(&SHFLD) = 'COLOR(RED)'\n  &SHCM = &Z\n  &SHCMD = &Z\n  &SHOPN = &Z\n  IF (&SHENV = &Z)\n    &SHENV  = ISPF\n  IF (&CAPS = &Z)\n    &CAPS  = OFF\n  IF (&HPG = &Z)\n    &HPG  = YES\n  IF (&LPG = &Z)\n    &LPG  = 60\n  IF (&PGN = &Z)\n    &PGN  = 1\n  IF (&SJCL \u00ac= &Z)\n    &SJCL = TRUNC (&SJCL,1)\n    &SJCL = TRANS (&SJCL S,SCAN C,COPY *,*)\n  IF (&DDS = &Z)\n    &DDS  = OLD\n)REINIT\n  IF (.MSG \u00ac= &Z)\n    .ATTR(.CURSOR) = 'COLOR(RED)'\n)PROC\n  &CHKC = TRUNC (&SHCM,' ')\n  IF (&CHKC = SHOWMVS)\n    &SHCMD = TRUNC (&SHCM,' ')\n    &SHOPN = .TRAIL\n  IF (&SHCMD = &Z)\n    IF (&SHENV \u00ac= &Z)\n      &SHENV = TRUNC (&SHENV,1)\n      &SHENV = TRANS (&SHENV B,BATCH I,ISPF T,TSO *,*)\n      VER (&SHENV,LIST,BATCH,ISPF,TSO)\n    IF (&SHENV = &Z)\n      &SHENV  = ISPF\n    IF (&CAPS \u00ac= &Z)\n      VER (&CAPS,LIST,ON,OFF)\n    IF (&CAPS = &Z)\n      &CAPS  = OFF\n    IF (&HPG \u00ac= &Z)\n      &HPG = TRUNC (&HPG,1)\n      &HPG = TRANS (&HPG Y,YES N,NO *,*)\n      VER (&HPG,LIST,YES,NO)\n    IF (&HPG = &Z)\n      &HPG  = YES\n    IF (&LPG \u00ac= &Z)\n      VER (&LPG,RANGE,20,200)\n    IF (&LPG = &Z)\n      &LPG  = 60\n    IF (&PGN \u00ac= &Z)\n      VER (&PGN,RANGE,1,90000)\n    IF (&PGN = &Z)\n      &PGN  = 1\n    IF (&SHENV = BATCH)\n      IF (&SJCL \u00ac= &Z)\n        &SJCL = TRUNC (&SJCL,1)\n        &SJCL = TRANS (&SJCL S,SCAN C,COPY *,*)\n        VER (&SJCL,LIST,SCAN,COPY)\n      IF (&DDS \u00ac= &Z)\n        &DDS = TRUNC (&DDS,1)\n        &DDS = TRANS (&DDS O,OLD M,MOD *,*)\n        VER (&DDS,LIST,OLD,MOD)\n      IF (&DDS = &Z)\n        &DDS  = OLD\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJSIVKA": {"ttr": 27148, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x9f\\x00\\x944\\x9f\\x15Y\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-15T00:00:00", "modifydate": "1994-12-15T15:59:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "//&EURUSID.V JOB (&EUACCNO),'V S M    ANALYSIS',\n//             MSGLEVEL=(1,1),MSGCLASS=X,REGION=1M,TIME=(,20),\n//             NOTIFY=&EURUSID,USER=&EURUSID\n/*JOBPARM L=10\n)SEL &IVKP = &Z\n//XEQ     EXEC PGM=VSMANAL\n)ENDSEL\n)SEL &IVKP \u00ac= &Z\n//XEQ     EXEC PGM=VSMANAL,\n//             PARM='&IVKP'\n)ENDSEL\n//&IVKL     DD SYSOUT=*\n)SEL &IVKS \u00ac= &Z\n//&IVKS     DD SYSOUT=*\n)ENDSEL\n)SEL &IVKD = YES\n//SYSUDUMP  DD SYSOUT=*\n)ENDSEL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJSIVKB": {"ttr": 27150, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x9f\\x00\\x944\\x9f\\x15Y\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-15T00:00:00", "modifydate": "1994-12-15T15:59:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "//&EURUSID.R JOB (&EUACCNO),'R S M    ANALYSIS',\n//             MSGLEVEL=(1,1),MSGCLASS=X,REGION=1M,TIME=(,30),\n//             NOTIFY=&EURUSID,USER=&EURUSID\n/*JOBPARM L=50\n)SEL &IVKP = &Z\n//XEQ     EXEC PGM=RSMANAL\n)ENDSEL\n)SEL &IVKP \u00ac= &Z\n//XEQ     EXEC PGM=RSMANAL,\n//             PARM='&IVKP'\n)ENDSEL\n//&IVKL     DD SYSOUT=*\n)SEL &IVKS \u00ac= &Z\n//&IVKS     DD SYSOUT=*\n)ENDSEL\n)SEL &IVKD = YES\n//SYSUDUMP  DD SYSOUT=*\n)ENDSEL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJSLB": {"ttr": 27152, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x12\\x8f\\x00\\x90\\x12\\x8f\\x11!\\x00@\\x00@\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-05-08T00:00:00", "modifydate": "1990-05-08T11:21:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "SYSPAJA"}, "text": "%SLB ------------------  Browse/Edit System Libraries  -------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+                  %EDIT mode :_SLBMD+(NO=browse/YES=edit)\n+Select the system library you want to get by placing the cursor anywhere on his\n+name below, or fill in a new name you want retain and select, then press ENTER\n%Libraries names ===>_SLBN1                                       +\n+                    _SLBN2                                       +\n+                    _SLBN3                                       +\n+                    _SLBN4                                       +\n+                    _SLBN5                                       +\n+                    _SLBN6                                       +\n+                    _SLBN7                                       +\n+                    _SLBN8                                       +\n+                    _SLBN9                                       +\n+                    _SLBN10                                      +\n+                    _SLBN11                                      +\n%or another name ===>_SLBNN                                       +\n+                     (temporary name, not retained nor cursor selective)\n+\n+         %&SLBW1             %&SLBEN  %&SLBW2 %&SLBCC+&SLBW3\n+\n+Press%END KEY+to return to the ISPF APPLICATIONS MENU\n+\n)INIT\n  .HELP = PAJTSLB\n  IF (&SLBEN = &Z)\n    &SLBW1 = ' '\n    &SLBW2 = ' '\n    &SLBW3 = ' '\n    &SLBNN = ' '\n  IF (&SLBEN \u00ac= &Z)\n    &SLBW1 = 'DIAGNOSE - error at'\n    &SLBW2 = '/ CC :'\n    &SLBW3 = '(use PF-1)'\n  IF (&SLBCS = '1')\n    .CURSOR = SLBN1\n  IF (&SLBCS = '2')\n    .CURSOR = SLBN2\n  IF (&SLBCS = '3')\n    .CURSOR = SLBN3\n  IF (&SLBCS = '4')\n    .CURSOR = SLBN4\n  IF (&SLBCS = '5')\n    .CURSOR = SLBN5\n  IF (&SLBCS = '6')\n    .CURSOR = SLBN6\n  IF (&SLBCS = '7')\n    .CURSOR = SLBN7\n  IF (&SLBCS = '8')\n    .CURSOR = SLBN8\n  IF (&SLBCS = '9')\n    .CURSOR = SLBN9\n  IF (&SLBCS = '10')\n    .CURSOR = SLBN10\n  IF (&SLBCS = '11')\n    .CURSOR = SLBN11\n  IF (&SLBCS = 'N')\n    .CURSOR = SLBNN\n)PROC\n    &SLBMD = TRUNC (&SLBMD,1)\n    &SLBMD = TRANS (&SLBMD N,NO Y,YES *,*)\n    VER (&SLBMD,NONBLANK) VER (&SLBMD,LIST,NO,YES)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJSM": {"ttr": 27154, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x16R\\x003\\x003\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T16:52:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "SYSPAJA"}, "text": "%SHORT --------------------  S H O R T    messages  ----------------------------\n%Info's from ===>_SMCMD                                                        +\n+                 (Enter User-id or leave blank to update your own)\n+\n+                 Language :_SMLANG   +(Enter Italiano or I,\n+                                       Fran\\ais or F,\n+                                       English, E or leave blank)\n+\n%NOTE :+the%SHORT messages+can be directly entered from the ISPF primary panel\n+       typing the options separated by periods, and eventually followed by a\n+       a slash and the value of the first parameter for the last option that\n+       has been selected.\n+       I.e. : - typing P.M./IBMUSER will enter directly the SHORT messages\n+                communication display for User-id IBMUSER.\n+              - typing P.M./ will enter directly the SHORT messages in update\n+                on your own.\n+       The HELP PF-key can be entered to obtain a descriptive message about\n+       the just executed function or detected error.\n+\n+              TEST option :_SMTS+     (NO/YES)\n+\n)INIT\n  .CURSOR = SMCMD\n  .HELP = PAJTSM1\n  &SMTS = TRANS (&SMTS ' ',NO YES,NO *,*)\n)PROC\n  &SMUSID = ' '\n  &SMWK = TRUNC (&ZCMD,'/')\n  &ZTRAIL = .TRAIL\n  IF (&ZTRAIL \u00ac= &Z)\n    &SMUSID = &ZTRAIL\n  IF (&ZTRAIL = &Z)\n    IF (&SMCMD \u00ac= &Z)\n      &SMUSID = TRUNC (&SMCMD,' ')\n  IF (&SMLANG \u00ac= ' ')\n    &SMWK = TRANS (&SMLANG Italiano,I Fran\\ais,F English,E *,*)\n    VER (&SMWK,LIST,I,F,E)\n    &SMLANG = &SMWK\n    VPUT (SMLANG) PROFILE\n  IF (&SMUSID \u00ac= ' ')\n    VER (&SMUSID,NAME)\n    &SMID = 'SMID(&SMUSID)'\n  &SMTS = TRUNC (&SMTS,1)\n  &SMTS = TRANS (&SMTS N,NO Y,YES *,*)\n  VER (&SMTS,NONBLANK)  VER (&SMTS,LIST,NO,YES)\n  IF (&SMTS = NO)\n    &SMTO = ' '\n  IF (&SMTS = YES)\n    &SMTO = 'SMTEST(TEST)'\n  &SEL = 'CMD(%PAJCSM &SMID &SMTO) '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJSMX1": {"ttr": 27156, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(/\\x00\\x90(/\\x11H\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-09T00:00:00", "modifydate": "1990-10-09T11:48:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": ")SET MXSRC = 0\n)SET MXSRT = &ZTIME\n)DOT &MXLIST\n)SEL &MXSRC = 0\n1&ZUSER - \"&MXLIST\" mail-list (&MXCURD - &MXSRT)\n0Current sort order : &MXSRTF\n0Mail    Date     Field     Aut.  Subject\n ------  -------  --------  ----  -------------------------------------?\n---------\n)BLANK\n)ENDSEL\n)TB 10 19 29 35\n &MXNUM!&MXDATE!&MXFIELD!&MXAUT!&MXDES\n)SET MXSRC = &MXSRC + 1\n)SEL &MXSRC = 45\n)SET MXSRC = 0\n)ENDSEL\n)ENDDOT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJSMX2": {"ttr": 27158, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16\"\\x00\\x07\\x00\\x07\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:22:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "SYSPAJA"}, "text": "1&ZUSER - MAIL-BOXES list (&MXCURD - &ZTIME)\n0   Mail : &MXNUM                                Date : &MXDATE\n   Field : &MXFIELD                            Author : &MXAUT\n Subject : &MXDES\n0----------------------------------------------------------------------?\n----------\n)BLANK\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJSM1": {"ttr": 27160, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x15V\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T15:56:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n @ TYPE(OUTPUT) INTENS(LOW) SKIP(ON)\n)BODY WIDTH(80)\n%------------ Communication from &SSUSID ---------------------------------------\n%Command ===>_ZCMD                                            %Scroll ===>_AMT +\n+\n+===============================================================================\n)MODEL\n   @SMAROU\n)INIT\n .HELP = PAJTSM1\n &ZCMD = ' '\n &ZTDMARK = '=========================== Bottom of communication +\n             ==========================='\n IF (&AMT = &Z)\n   &AMT = PAGE\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJSM2": {"ttr": 27162, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x15V\\x00.\\x00.\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T15:56:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n# TYPE(INPUT) INTENS(LOW) CAPS(ON)\n@ TYPE(INPUT) INTENS(LOW) CAPS(OFF) PAD(NULLS)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n)BODY WIDTH(80)\n%------------ &SMTIT &SMID communication ---------------------------------------\n%Command ===>_ZCMD                                            %Scroll ===>_AMT +\n+\n+     Enter date for%A+and%B+line-commands :_GG+(Day)_MM+(Month)_AA+(Year)\n+\n%Act  Communication text\n%--- <---------------------------------------------------------------------->\n)MODEL CLEAR(A)\n#A  @SMAROU                                                                  +\n)INIT\n  .HELP = PAJTSM2\n  IF (&AMT = &Z)\n    &AMT = PAGE\n  &ZTDMARK = '=========================== Bottom of communication +\n              ==========================='\n  IF (&GG = &Z)\n    &GG = &ZDAY\n  IF (&MM = &Z)\n    &MM = &ZMONTH\n  IF (&AA = &Z)\n    &AA = &ZYEAR\n)REINIT\n  IF (.MSG \u00ac= &Z)\n    .ATTR(.CURSOR) = 'COLOR(RED)'\n    .AUTOSEL = YES\n    .CSRROW = &CRP\n)PROC\n  &CMD = TRANS(TRUNC(&ZCMD,' ') C,CANCEL CAN,CANCEL S,SAVE *,*)\n  VER (&CMD,LIST,CANCEL,SAVE,MSG=PAJS000A)\n  IF (&ZTDSELS \u00ac= 0000)\n    &SMA = TRUNC(&A,1)\n    VER (&SMA,LIST,A,B,D,I,R,S,MSG=PAJS000B)\n    &SMN = .TRAIL\n    IF (&SMN = &Z)\n      &SMN = 1\n    VER (&SMN,NB,NUM,MSG=PAJS000C)  VER (&SMN,RANGE,1,99,MSG=PAJS000C)\n    IF (&SMA = A,B)\n      VER (&GG,NB,NUM,MSG=PAJS000D)  VER (&GG,RANGE,1,31,MSG=PAJS000D)\n      VER (&MM,NB,NUM,MSG=PAJS000E)  VER (&MM,RANGE,1,12,MSG=PAJS000E)\n      VER (&AA,NB,NUM,MSG=PAJS000F)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJSNK": {"ttr": 27164, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x941?\\x00\\x941?\\x15@\\x00&\\x00&\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-09T00:00:00", "modifydate": "1994-11-09T15:40:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SYSPAJA"}, "text": "%SNAKE --------------  A program for TSO 3270 terminals  -----------------------\n+\n+\n%Invoke as :_SNKS    +(S, H or Q) ---> S = SNAKE          => full-screen\n+                                      H = HALFSNAK or HS => top half-screen\n+                                      Q = QUARTERS or QS => top quarter-screen\n+\n%Author :+written August 1987 by Greg Price of Prycroft Six PTY LTD.\n\n%Object :+to pick up as many $25 bundles as possible and make it \"home\" without\n          being eaten by the snake. Money is denoted by a $, the player by a I,\n          \"home\" by #, and the snake by a string of S's in lower case, with the\n          snake's head being in upper case. Each time the player moves the snake\n          moves. At first the snake will move almost randomly, but will make an\n          \"intelligent\" move more often as the game progresses. When the player\n          gets \"home\" the game ends and the score is credited. If the player\n          gets \"eaten\" then the game ends and no score is credited.\n+\n+Hit%ENTER+to execute the program.\n+Hit%HELP+to get program explanation tutorial.\n+Hit%END KEY+to return to the Various ... Option Menu.\n+\n)INIT\n  .HELP = PAJTSNK0\n  IF (&SNKS = ' ')\n    &SNKS = S\n  .CURSOR = SNKS\n)PROC\n  &SNKS = TRUNC (&SNKS,1)\n  VER (&SNKS,NONBLANK)  VER (&SNKS,LIST,S,H,Q)\n  IF (&SNKS = S)\n    &SNKC = SNAKE\n  IF (&SNKS = H)\n    &SNKC = HALFSNAK\n  IF (&SNKS = Q)\n    &SNKC = QUARTERS\n  &ZSEL = 'CMD(&SNKC)'\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJSPDS": {"ttr": 27394, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x9f\\x00\\x944\\x9f\\x15Y\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-15T00:00:00", "modifydate": "1994-12-15T15:59:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "//&EURUSID.C JOB (&EUACCNO),'PDS - DIRECTORIES',\n//             MSGLEVEL=(1,1),MSGCLASS=X,REGION=1M,TIME=(,20),\n//             NOTIFY=&EURUSID,USER=&EURUSID\n/*JOBPARM L=10\n)SEL &PDOPT = &Z\n//XEQ     EXEC PGM=PDSMATCH\n)ENDSEL\n)SEL &PDOPT \u00ac= &Z\n//XEQ     EXEC PGM=PDSMATCH,\n//             PARM='&PDOPT'\n)ENDSEL\n//STEPLIB   DD DSN=->.TARGET.LINKLIB,DISP=SHR\n)SEL &PVOL1 = &Z\n//SYSLIB1   DD DSN=&PDSNA,DISP=SHR\n)ENDSEL\n)SEL &PVOL1 \u00ac= &Z\n//SYSLIB1   DD UNIT=DISK,VOL=SER=&PVOL1,\n//             DSN=&PDSNA,DISP=SHR\n)ENDSEL\n)SEL &PVOL2 = &Z\n//SYSLIB2   DD DSN=&PDSNB,DISP=SHR\n)ENDSEL\n)SEL &PVOL2 \u00ac= &Z\n//SYSLIB2   DD UNIT=DISK,VOL=SER=&PVOL2,\n//             DSN=&PDSNB,DISP=SHR\n)ENDSEL\n//SYSPRINT  DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJSSF": {"ttr": 27396, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"O\\x00\\x94\"O\\x125\\x00)\\x00)\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-12T00:00:00", "modifydate": "1994-08-12T12:35:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SYSPAJA"}, "text": "%SUPERC ------------------- SUPER SEARCH-FOR Utility ------------------- SUPERC+\n%Command ===>_ZCMD                                                             +\n+\n+\n+Welcome to the%SUPERC+process, which allows you to run as a Batch job.\n+\n+\n%Enter/verify parameters below :\n+\n+    Job : CPU time minutes%===>_EUNMN+(JOB card parameter)\n+                   seconds%===>_EUNSC+  \"   \"    \"\n+                  I/O time%===>_EUNIO+(JOBPARM card parameter)\n+                     lines%===>_EUNLN+  \"       \"    \"\n+\n+    Do you want to view (IOF) the submited running job%===>_EUIOF+(No/Yes)\n+\n+\n)INIT\n  &ZCMD = &Z\n  .HELP = PAJTSSF\n  .CURSOR = EUNMN\n  &EUNMN = TRANS (&EUNMN ' ',0 *,*)\n  &EUNSC = TRANS (&EUNSC ' ',30 *,*)\n  &EUNIO = TRANS (&EUNIO ' ',10 *,*)\n  &EUNLN = TRANS (&EUNLN ' ',10 *,*)\n  &EUIOF = TRANS(TRUNC(&EUIOF,1) ' ',NO N,NO Y,YES *,*)\n)PROC\n  &EUNMN = TRANS (&EUNMN ' ',0 *,*)\n  &EUNSC = TRANS (&EUNSC ' ',30 *,*)\n  VER (&EUNMN,NB,RANGE,0,99)\n  IF (&EUNMN = 0)\n    VER (&EUNSC,NB,RANGE,1,59)\n  IF (&EUNMN \u00ac= 0)\n    VER (&EUNSC,NB,RANGE,0,59)\n  &EUNIO = TRANS (&EUNIO ' ',10 *,*)\n  VER (&EUNIO,NB,RANGE,1,999)\n  &EUNLN = TRANS (&EUNLN ' ',10 *,*)\n  VER (&EUNLN,NB,RANGE,1,999)\n  &EUIOF = TRANS(TRUNC(&EUIOF,1) ' ',NO N,NO Y,YES *,*)\n  VER (&EUIOF,NB,LIST,NO,YES)\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJSSHWM": {"ttr": 27398, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x9f\\x00\\x944\\x9f\\x15Y\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-15T00:00:00", "modifydate": "1994-12-15T15:59:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SYSPAJA"}, "text": "//&EURUSID.S JOB (&EUACCNO),'- S H O W    M V S -',\n//             MSGLEVEL=(1,1),MSGCLASS=X,\n)SEL &SJCL = &Z\n//             REGION=1M,TIME=(,30),\n)ENDSEL\n)SEL &SJCL \u00ac= &Z\n//             REGION=1M,TIME=(,30),TYPRUN=&SJCL,\n)ENDSEL\n//             NOTIFY=&EURUSID,USER=&EURUSID\n/*JOBPARM L=10\n)SEL &PARM = &Z\n//GO      EXEC PGM=SHOWMVS\n)ENDSEL\n)SEL &PARM \u00ac= &Z\n//GO      EXEC PGM=SHOWMVS,PARM='&PARM'\n)ENDSEL\n)SEL &SHWMDS = &Z\n//SHOWMVS   DD SYSOUT=*\n)ENDSEL\n)SEL &SHWMDS \u00ac= &Z\n//SHOWMVS   DD DSN=&SHWMDS,DISP=&DDS\n)ENDSEL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJSSSF": {"ttr": 27400, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"O\\x00\\x94\"O\\x123\\x00@\\x00@\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-12T00:00:00", "modifydate": "1994-08-12T12:33:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "SYSPAJA"}, "text": ")SEL &EUPNAME \u00ac= &Z\n//&EURUSID.S JOB (&EUACCNO),'&EUPNAME',\n)ENDSEL\n)SEL &EUPNAME = &Z\n)SEL &EURUSNM \u00ac= &Z\n//&EURUSID.S JOB (&EUACCNO),'&EURUSNM',\n)ENDSEL\n)ENDSEL\n)SEL &EUPNAME = &Z\n)SEL &EURUSNM = &Z\n//&EURUSID.S JOB (&EUACCNO),'SUPER SEARCH-FOR',\n)ENDSEL\n)ENDSEL\n//             MSGLEVEL=(1,1),MSGCLASS=X,\n)SEL &DEBUG = &Z\n//             REGION=1M,TIME=(&EUCPU),\n)ENDSEL\n)SEL &DEBUG \u00ac= &Z\n//             REGION=1M,TIME=(&EUCPU),TYPRUN=&DEBUG,\n)ENDSEL\n//             NOTIFY=&EURUSID,USER=&EURUSID\n/*JOBPARM L=&EULINES,I=&EUIO\n//*\n//*      JCL FOR BATCH EXECUTION OF SEARCH-FOR (ISPF OPTION 3.14)\n//*\n)CM\n)CM      *****     SUPERC WITH SEARCH-FOR OPTION     *****\n)CM\n//SUPERC  EXEC PGM=ISRSUPC,PARM=(SRCHCMP,ANYC)\n//NEWDD     DD DSN=&NEWDD,\n//             DISP=SHR&NEWVOL\n//OUTDD     DD SYSOUT=*\n//SYSIN     DD *\n)SEL &SFS1 \u00ac= &Z\n&SRCH1 &SFS1\n)ENDSEL\n)SEL &SFS2 \u00ac= &Z\n&SRCH2 &SFS2\n)ENDSEL\n)SEL &SFS3 \u00ac= &Z\n&SRCH3 &SFS3\n)ENDSEL\n)SEL &SFS4 \u00ac= &Z\n&SRCH4 &SFS4\n)ENDSEL\n)SEL &SFS5 \u00ac= &Z\n&SRCH5 &SFS5\n)ENDSEL\n)SEL &SFS6 \u00ac= &Z\n&SRCH6 &SFS6\n)ENDSEL\n)SEL &SFS7 \u00ac= &Z\n&SRCH7 &SFS7\n)ENDSEL\n)SEL &SFS8 \u00ac= &Z\n&SRCH8 &SFS8\n)ENDSEL\n)SEL &SFS9 \u00ac= &Z\n&SRCH9 &SFS9\n)ENDSEL\n)SEL &SFS10 \u00ac= &Z\n&SRCH10 &SFS10\n)ENDSEL\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJSUM": {"ttr": 27402, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\x10\\x00\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T10:00:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                       -------------------------------\n                        |      Edit Macro  \"SUM\"      |\n                        -------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to%ADD+columns of numbers.%SUM+can\n             handle numbers with up to 3 decimal places. Only valid numeric data\n             will be added. Numbers must not be aligned with equal number of\n             decimal places.%SUM+can handle%X+and%NX+type of data lines, the\n             default is%ALL+lines. If you wish to exclude lines, use the%NX+\n             parm, if you want to sum only excluded lines, use the%X+parm.\n             The%STARTING+and%ENDING+column of the data lines range may be\n             identified by entering starting and ending column numbers.\n             You may%omit the two numbers+or use in place the%period sign (.)+\n             to get the left and right boundaries as default.\n%SYNTAX :   +On the COMMAND line type in :%SUM TYPE START END+\n             where :%TYPE+may be%ALL+or%X+or%NX+\n                    %START+is the%starting column+of data range\n                    %END+is the%ending column+of data range\n            +or :%SUM HELP+or%H+to view this tutorial.\n                                  (continued)\n)PROC\n  &ZCONT = PAJSUMX\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJSUMX": {"ttr": 27404, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"\\x1f\\x00\\x94\"\\x1f\\x17\\x15\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-09T00:00:00", "modifydate": "1994-08-09T17:15:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                       -------------------------------\n                        |      Edit Macro  \"SUM\"      |\n                        -------------------------------\n+\n%USE :+     %Example 1 :+assumed that all the data lines have been excluded\n                         unless those displayed here below. Note that the range\n                         27 - 35 is not necessary if the rest of the data in the\n                         lines doesn't contain any other valid numbers.\n            %COMMAND ===> SUM NX 27 35                                         +\n            +***************************** TOP OF DATA *************************\n            %----0----1----1----2----2----3----3----4----4----5----5----6----6--\n            %----5----0----5----0----5----0----5----0----5----0----5----0----5--\n            +                          12.345,08\n            +                             345,25\n            +**************************** BOTTOM OF DATA ***********************\n            %Result:\n            +***************************** TOP OF DATA *************************\n            +SUM OF NUMBERS IN COLUMNS 27 TO 35 IS 12690,33\n            +       PROCESSED 2 VALID AND 0 INVALID LINES\n                                  (continued)\n)PROC\n  &ZCONT = PAJSUMY\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJSUMY": {"ttr": 27406, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"\\x1f\\x00\\x94\"\\x1f\\x17\\x15\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-09T00:00:00", "modifydate": "1994-08-09T17:15:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                       -------------------------------\n                        |      Edit Macro  \"SUM\"      |\n                        -------------------------------\n+\n            %Example 2 :+assumes that all data lines are present, none excluded.\n                         Note that the word ALL is not specified (default).\n            %COMMAND ===> SUM . 10                                             +\n            +***************************** TOP OF DATA *************************\n            %----0----1----1----2----2----3----3----4----4----5----5----6----6--\n            %----5----0----5----0----5----0----5----0----5----0----5----0----5--\n            +  1234510,\n            +     ,09\n            +     25,8\n            + 32\n            +**************************** BOTTOM OF DATA ***********************\n            %Result:\n            +***************************** TOP OF DATA *************************\n            +SUM OF NUMBERS IN COLUMNS 1 TO 10 IS 1.234.567,89\n            +       PROCESSED 4 VALID AND 0 INVALID LINES\n                                  (continued)\n)PROC\n  &ZCONT = PAJSUMZ\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJSUMZ": {"ttr": 27408, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"\\x1f\\x00\\x94\"\\x1f\\x17\\x15\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-09T00:00:00", "modifydate": "1994-08-09T17:15:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                       -------------------------------\n                        |      Edit Macro  \"SUM\"      |\n                        -------------------------------\n+\n            %Example 3 :+assumes you have excluded only the data lines of the\n                         books you want buy from the entire cost price list.\n            %COMMAND ===> SUM X 55                                             +\n            +***************************** TOP OF DATA *************************\n            %----0----1----1----2----2----3----3----4----4----5----5----6----6--\n            %----5----0----5----0----5----0----5----0----5----0----5----0----5--\n            +    ... 1st excluded book title ...                        25.000\n            +    ... 2nd excluded book title ...                        42.500\n            +    ... 3rd excluded book title ...                        17.000\n            +    ... 4th excluded book title ...                        31.000\n            +    ... 5th excluded book title ...                         7.500\n            +**************************** BOTTOM OF DATA ***********************\n            %Result:\n            +***************************** TOP OF DATA *************************\n            +SUM OF NUMBERS IN COLUMNS 55 TO 72 IS 123.000\n            +       PROCESSED 5 VALID AND 0 INVALID LINES\n)PROC\n  &ZCONT = PAJSUM\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJSVEP1": {"ttr": 27410, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06o\\x00\\x95\\x06o\\x14\\t\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-07T00:00:00", "modifydate": "1995-03-07T14:09:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": ")SET PXC = 0\n)DOT &W\n)SEL &PXC = 0\n)SET PXP = &PXP + 1\n1Date : &PXD     Time : &PXT                                Page : &PXP\n ------------------------  VIEW EDIT PROFILES  ------------------------\n Data-set : &JHPROFDS\n   APPLID : &JHEDPRAP\n+                                       Last used : &JHEDUDT - &JHEDUTM\n ----------------------------------------------------------------------\n)ENDSEL\n Profile : &JHEDPROF\n+_________              BOUNDS : left &JHEDBNDL / right &JHEDBNDR\n                ATTR : &JHEDATTR\n+                                             CAPS : &JHEDCAPS\n              NUMBER : &JHEDNUMB\n+                                            NULLS : &JHEDNULL\n                 HEX : &JHEDHEXM\n+                                            STATS : &JHEDSTAT\n            RECOVERY : &JHEDRECV\n+                                             TABS : &JHEDTABS\n            AUTOSAVE : &JHEDAUTS\n+                                          AUTONUM : &JHEDAUTN\n            AUTOLIST : &JHEDAUTL\n+                                             PACK : &JHEDPACK\n              IMACRO : &JHEDIMAC\n+                                             LOCK : &JHEDLOCK\n)SET PXC = &PXC + 1\n)SEL &PXC = 6\n)SET PXC = 0\n)ENDSEL\n)ENDDOT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJSVEP2": {"ttr": 27412, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06o\\x00\\x95\\x06o\\x14\\t\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-07T00:00:00", "modifydate": "1995-03-07T14:09:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SYSPAJA"}, "text": ")SET PXC = 0\n)DOT &W\n)SEL &PXC = 0\n)SET PXP = &PXP + 1\n1Date : &PXD     Time : &PXT                                Page : &PXP\n -----------------------  TRACE EDIT PROFILES  ------------------------\n Data-set : &JHPROFDS\n   APPLID : &JHEDPRAP\n+                                       Last used : &JHEDUDT - &JHEDUTM\n ----------------------------------------------------------------------\n)ENDSEL\n ZEDPTYPE : &PMPTYPE\n+__________\n            ZEDPLRCL : &PMPLRCL\n+                                         ZEDPRCFM : &PMPRCFM\n                       ----+----1----+----2----\n            ZEDPFLAG : &PMPFLAG\n            ZEDPBNDL : &PMPBNDL\n+                                         ZEDPBNDR : &PMPBNDR\n            ZEDPTABS : &PMPTABS\n+                                         ZEDPTABC : &PMPTABC\n            ZEDPMASK : &PMPMASK\n            ZEDPIMAC : &PMPIMAC\n)SET PXC = &PXC + 1\n)SEL &PXC = 6\n)SET PXC = 0\n)ENDSEL\n)ENDDOT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJSVEP3": {"ttr": 27414, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06o\\x00\\x95\\x06o\\x14\\t\\x00,\\x00,\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-07T00:00:00", "modifydate": "1995-03-07T14:09:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SYSPAJA"}, "text": ")SET PXP = &PXP + 1\n1Date : &PXD     Time : &PXT                                Page : &PXP\n -------------------  EDIT PROFILES TABLE ANALYSIS  -------------------\n                                        Date : &PXD     Time : &PXT\n Data-set : &JHPROFDS\n   APPLID : &JHEDPRAP\n ----------------------------------------------------------------------\n Table Statistics :                                     USER : &PMUSR\n+__________________\n  CDATE : &PMCDT\n+                  CTIME : &PMCTM\n+                                   UDATE : &PMUDT\n+                                                    UTIME : &PMUTM\n      ROWCREAT : &PMRWC\n+                          ROWCURR : &PMRCU\n+                                               ROWUPD : &PMRUP\n      TABLEUPD : &PMTUP\n+                          SERVICE : &PMSRV\n+                                              RETCODE : &PMRCD\n       STATUS1 : &PMST1\n+                          STATUS2 : &PMST2\n+                                              STATUS3 : &PMST3\n        ROWNUM : &PMRNM\n+                           KEYNUM : &PMKNM\n+                                              NAMENUM : &PMNMN\n KEYS : (variables names)\n+______\n  &PMK01\n  &PMK02\n  &PMK03\n+                                                                &PMX\n NAMES : (variables names)\n+_______\n  &PMN01\n  &PMN02\n  &PMN03\n  &PMN04\n+                                                                &PMY\n SAVE : (variables names)\n+______\n  &PMS01\n  &PMS02\n  &PMS03\n+                                                                &PMZ\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJS00": {"ttr": 27416, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x16\\x13\\x00x\\x00x\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T16:13:00", "lines": 120, "newlines": 120, "modlines": 0, "user": "SYSPAJA"}, "text": "PAJS000A 'Invalid command' .ALARM=YES\n'Valid commands : CANCEL, END, HELP or SAVE.'\n\nPAJS000B 'Invalid command' .ALARM=YES\n'Enter a valid line-command : A, B, D, I, R or S.'\n\nPAJS000C 'Number error' .ALARM=YES\n'Line-commands can be followed by a number from 1 to 99.'\n\nPAJS000D 'DAY error' .ALARM=YES\n'DAY must range from 1 to 31.'\n\nPAJS000E 'MONTH error' .ALARM=YES\n'MONTH must range from 1 to 12.'\n\nPAJS000F 'YEAR error' .ALARM=YES\n'YEAR must range from 0 to 99.'\n\nPAJS000X 'Unauthorized access' .ALARM=YES\n'You are not authorized to use this option, sorry.'\n\nPAJS000Y 'DAY error' .ALARM=YES\n'DAY must range from 1 to &GGT for &MONTH of &AA1..'\n\nPAJS001A 'INIT-I/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS001B 'OPEN-I/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS001D 'FIND-I/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS001E 'READ-I/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS001F 'CLSE-I/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS001G 'FREE-I/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS001H 'DISPLAY ERROR' .ALARM=YES\n'Error displaying \"&SMID\" communication / RC=&RC..'\n\nPAJS002A 'UNAV./RC=&RC' .ALARM=YES\n'\"&SMID\" communication unavailable.'\n\nPAJS002B 'UNACC./RC=&RC' .ALARM=YES\n'\"&SMID\" communication unaccessible.'\n\nPAJS002C 'COMM. IN USE' .ALARM=YES\n'\"&SMID\" communication in use by another user.'\n\nPAJS002D 'NO COMMUNICATION' .ALARM=YES\n'There are no communication from \"&SMID\".'\n\nPAJS002E 'READ ERROR' .ALARM=YES\n'\"&SMID\" communication gives trouble in read, sorry.'\n\nPAJS002F 'CLOSE ERROR' .ALARM=YES\n'\"&SMID\" communication has given trouble at close, warning.'\n\nPAJS002G 'FREE ERROR' .ALARM=YES\n'\"&SMID\" communication has given trouble at deallocation, warning.'\n\nPAJS003A 'TBGET/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS003B 'WRTE-O/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS003C 'TBSKIP/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS003D 'DELETE/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS003E 'STORE/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS003F 'CLSE-O/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS003G 'FREE-O/RC=&RC' .ALARM=YES\n'&ZERRLM'\n\nPAJS004A 'READ ERROR' .ALARM=YES\n'Error reading \"&SMID\" communication / RC=&RC..'\n\nPAJS004B 'WRITE ERROR' .ALARM=YES\n'Error preparing \"&SMID\" communication / RC=&RC..'\n\nPAJS004C 'SCAN ERROR' .ALARM=YES\n'Error scanning \"&SMID\" communication / RC=&RC..'\n\nPAJS004D 'SCAN ERROR' .ALARM=YES\n'Error deleting \"&SMID\" communication / RC=&RC..'\n\nPAJS004E 'STORE ERROR' .ALARM=YES\n'Error saving \"&SMID\" communication / RC=&RC..'\n\nPAJS009A 'Display done' .ALARM=YES\n'Display of \"&SMID\" communication ended normally.'\n\nPAJS009B '&SMTIT failed' .ALARM=YES\n'&SMTIT of \"&SMID\" communication fails, none saved.'\n\nPAJS009C '&SMTIT canceled' .ALARM=YES\n'&SMTIT of \"&SMID\" communication canceled, none saved.'\n\nPAJS009D 'Delete done' .ALARM=YES\n'\"&SMID\" communication is now empty, so none to save.'\n\nPAJS009E 'None stored' .ALARM=YES\n'\"&SMID\" communication create ended empty, so none to save.'\n\nPAJS009F '&SMTIT done' .ALARM=YES\n'&SMTIT of \"&SMID\" communication ended normally, info's saved.'\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTALL": {"ttr": 27649, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90&\\x0f\\x00\\x90&\\x0f\\tE\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-09-17T00:00:00", "modifydate": "1990-09-17T09:45:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%TUTORIAL - Allocation Summary ----------------------------------------TUTORIAL\n%COMMAND ===>_ZCMD\n\n+The ALLOCATION SUMMARY panel displays all data-sets allocated to a user\n               while logged on to TSO.\n\n Information displayed for each data-set includes :\n%              DDNAME                        VOLUME SERIAL\n               DATA-SET NAME                 DISPOSITION\n               DATA-SET ORGANIZATION         RECORD FORMAT\n               BLOCK-SIZE                    LOGICAL RECORD LENGTH\n+\n Data-sets with a disposition of%TEMP+are temporary files which are deleted\n               at the end of the TSO session.\n Concatenated data-sets are grouped together under a single DDNAME.\n Data-set names which are greater than thirty characters in length are\n               truncated and continued on the next line.\n\n The information displayed may be scrolled either%UP+or%DOWN+as needed.\n\n Press%END+to terminate the display.\n)INIT\n  &ZCMD = &Z\n)PROC\n  IF (&ZCMD \u00ac= ' ') .MSG = ISPZ001\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTAUCP": {"ttr": 27651, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90)/\\x00\\x90)/\\x10I\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-19T00:00:00", "modifydate": "1990-10-19T10:49:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - SPECIAL command authorization interface ----------------------------\n+  The AUTH command processor option allows authorized commands (as i.e., any\n+        RACF command) to be executed under ISPF, assuming that the user is\n+        authorized to issue it.\n+        To run the command in authorized mode, say%ON+(it means APF on).\n+        You may enter a long command that wraps to the next two line(s).\n+  You may type :%F+to search (find) a string match, as i.e.%F ACCESS COUNT+\n+                      to scan for string%ACCESS COUNT+in the command response.\n+                      Then each time you enter only%F+the search continue with\n+                      that string until you change it, also if other commands\n+                      are executed.\n+                %?+to display the previous executed command,\n+                %*+to reissue the previous executed command,\n+                %HELP+to display this tutorial, and\n+                %END+to terminate SPECIAL execution.\n+  Depress%PF3+or%PF15+to return to the%SPECIAL+command authorization panel.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTBIG": {"ttr": 27653, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x103\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T10:33:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |        Edit Macro  \"BIG\"        |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to create block characters in text.\n%SYNTAX :+   BIG character or BIG HELP or HE\n%USE :+      Type%BIG+on the COMMAND line followed by a character (A-Z, 0-9, $,\n             # or @), set the cursor in the text where you want the block\n             character, and press ENTER, as i.e. :\n            %COMMAND ===> BIG A            Result :\n+            001100   Data ...  %- <===+ 001100   Data ...   % AAAAAAAAAA\n+            001200   Data ... %(CURSOR)+001200   Data ...   %AAAAAAAAAAAA\n+            001300   Data ...           001300   Data ...   %AA        AA\n+            001400   Data ...           001400   Data ...   %AA        AA\n+            001500   Data ...           001500   Data ...   %AA        AA\n+            001600   Data ...           001600   Data ...   %AAAAAAAAAAAA\n+            001700   Data ...           001700   Data ...   %AAAAAAAAAAAA\n+            001800   Data ...           001800   Data ...   %AA        AA\n+            001900   Data ...           001900   Data ...   %AA        AA\n+            002000   Data ...           002000   Data ...   %AA        AA\n+            002100   Data ...           002100   Data ...   %AA        AA\n)PROC\n  &ZCONT = PAJTBIG\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTBIGS": {"ttr": 27655, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x103\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T10:33:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |        Edit Macro  \"BIGS\"       |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to create slanted block characters.\n%SYNTAX :+   BIGS character or BIGS HELP or HE\n%USE :+      Type%BIGS+on the COMMAND line followed by a character (A-Z, 0-9,\n             $, # or @), set the cursor in the text where you want the block\n             character, and press ENTER, as i.e. :\n       %COMMAND ===> BIGS A           Result :\n+       001100   Data ...  %- <===+ 001100   Data ...   %           AAAAAAAAAA\n+       001200   Data ... %(CURSOR)+001200   Data ...   %         AAAAAAAAAAAA\n+       001300   Data ...           001300   Data ...   %        AA        AA\n+       001400   Data ...           001400   Data ...   %       AA        AA\n+       001500   Data ...           001500   Data ...   %      AA        AA\n+       001600   Data ...           001600   Data ...   %     AAAAAAAAAAAA\n+       001700   Data ...           001700   Data ...   %    AAAAAAAAAAAA\n+       001800   Data ...           001800   Data ...   %   AA        AA\n+       001900   Data ...           001900   Data ...   %  AA        AA\n+       002000   Data ...           002000   Data ...   % AA        AA\n+       002100   Data ...           002100   Data ...   %AA        AA\n)PROC\n  &ZCONT = PAJTBIGS\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTBLK": {"ttr": 27657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x9f\\x00\\x88\\x15\\x9f\\x14\\x19\\x00/\\x00/\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-07T00:00:00", "modifydate": "1988-06-07T14:19:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - Disk block sizes computations ----------------------------\n+  This function can be used to obtain information about DASD capacities.\n+  Follows a description of the selectable options :\n%      DEVICES TYPES+- a list of up to three devices types you want.\n+         Default is 3380.\n+         Restriction : the devices types requested must be generated in the\n+         current system.\n%      LRECL+- the logical record length of the data (key length excluded if\n+         it exist).\n%      MAX BLKSIZE+- the desired physical record length of the data.\n+         Default is the devices maximums.\n%      KEYLEN+- the length of the key data portion to be added at the physical\n+         record length.\n+\n%Tutorial - BLKSIZE - Disk block sizes tables ----------------------------------\n+  Select a disk type table as defined below:\n%DISK TYPE TABLE ===>_XTBU % with keys :_XKEY + (NO/YES)\n+        %0+- 3330-1    %1 +- 3350     %2+- 3380      %3+- 2305-2\n+\n+  Depress%PF3+or%PF15+to return to the%BLKSIZE+panel.\n+\n)INIT\n  .CURSOR = XTBU\n  IF (&XTBU = ' ')\n    &XTBU = TRANS (&XTBU ' ',2 *,*)\n  IF (&XTBU \u00ac= ' ')\n    &XTBU = TRUNC (&XTBU,1)\n  &XKEY = TRANS (&XKEY ' ',NO YES,NO *,*)\n)PROC\n  &XTBU = TRUNC (&XTBU,' ')\n  VER (&XTBU,NONBLANK)  VER (&XTBU,LIST,0,1,2,3)\n  &XKEY = TRUNC (&XKEY,1)\n  &XKEY = TRANS (&XKEY N,NO Y,YES *,*)\n  VER (&XKEY,NONBLANK)  VER (&XKEY,LIST,NO,YES)\n  IF (&XKEY = YES)\n    &XTBU = TRANS (&XTBU 0,0K 1,1K 2,2K 3,3K)\n  &ZSEL = TRANS(&XTBU\n               0,PAJTB000\n               0K,PAJTK000\n               1,PAJTB010\n               1K,PAJTK010\n               2,PAJTB020\n               2K,PAJTK020\n               3,PAJTB030\n               3K,PAJTK030\n               )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB000": {"ttr": 27659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3330-1 block sizes table (1 Cyl = 19 Trks) ---------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I       1        2      96       1824 I      24       25      82       1558 I\n+I       3        3      95       1805 I      26       27      81       1539 I\n+I       4        5      94       1786 I      28       29      80       1520 I\n+I       6        6      93       1767 I      30       31      79       1501 I\n+I       7        8      92       1748 I      32       33      78       1482 I\n+I       9        9      91       1729 I      34       35      77       1463 I\n+I      10       11      90       1710 I      36       38      76       1444 I\n+I      12       12      89       1691 I      39       40      75       1425 I\n+I      13       14      88       1672 I      41       42      74       1406 I\n+I      15       16      87       1653 I      43       45      73       1387 I\n+I      17       18      86       1634 I      46       47      72       1368 I\n+I      19       19      85       1615 I      48       50      71       1349 I\n+I      20       21      84       1596 I      51       53      70       1330 I\n+I      22       23      83       1577 I      54       55      69       1311 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTB001\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB001": {"ttr": 27661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3330-1 block sizes table (1 Cyl = 19 Trks) ---------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I      56       58      68       1292 I     105      108      54       1026 I\n+I      59       61      67       1273 I     109      113      53       1007 I\n+I      62       64      66       1254 I     114      118      52        988 I\n+I      65       67      65       1235 I     119      123      51        969 I\n+I      68       70      64       1216 I     124      128      50        950 I\n+I      71       73      63       1197 I     129      133      49        931 I\n+I      74       77      62       1178 I     134      139      48        912 I\n+I      78       80      61       1159 I     140      145      47        893 I\n+I      81       84      60       1140 I     146      151      46        874 I\n+I      85       88      59       1121 I     152      157      45        855 I\n+I      89       91      58       1102 I     158      164      44        836 I\n+I      92       95      57       1083 I     165      171      43        817 I\n+I      96      100      56       1064 I     172      178      42        798 I\n+I     101      104      55       1045 I     179      186      41        779 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTB002\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB002": {"ttr": 27663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3330-1 block sizes table (1 Cyl = 19 Trks) ---------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     187      194      40        760 I     353      371      26        494 I\n+I     195      202      39        741 I     372      391      25        475 I\n+I     203      211      38        722 I     392      413      24        456 I\n+I     212      220      37        703 I     414      437      23        437 I\n+I     221      230      36        684 I     438      463      22        418 I\n+I     231      241      35        665 I     464      491      21        399 I\n+I     242      252      34        646 I     492      523      20        380 I\n+I     253      263      33        627 I     524      557      19        361 I\n+I     264      276      32        608 I     558      596      18        342 I\n+I     277      289      31        589 I     597      639      17        323 I\n+I     290      303      30        570 I     640      687      16        304 I\n+I     304      318      29        551 I     688      742      15        285 I\n+I     319      335      28        532 I     743      805      14        266 I\n+I     336      352      27        513 I     806      877      13        247 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTB003\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB003": {"ttr": 27665, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3330-1 block sizes table (1 Cyl = 19 Trks) ---------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     878      962      12        228 I                                     I\n+I     963     1061      11        209 I                                     I\n+I    1062     1181      10        190 I                                     I\n+I    1182     1327       9        171 I                                     I\n+I    1328     1510       8        152 I                                     I\n+I    1511     1745       7        133 I                                     I\n+I    1746     2059       6        114 I                                     I\n+I    2060     2498       5         95 I                                     I\n+I    2499     3156       4         76 I                                     I\n+I    3157     4253       3         57 I                                     I\n+I    4254     6447       2         38 I                                     I\n+I    6448    13030       1         19 I                                     I\n+I                                     I                                     I\n+I                                     I                                     I\n+-----------------------------------------------------------------------------\n+\n)PROC\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB010": {"ttr": 27667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3350 block sizes table (1 Cyl = 30 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I       1        1     103       3090 I      29       31      89       2670 I\n+I       2        3     102       3060 I      32       33      88       2640 I\n+I       4        5     101       3030 I      34       36      87       2610 I\n+I       6        7     100       3000 I      37       38      86       2580 I\n+I       8        9      99       2970 I      39       41      85       2550 I\n+I      10       11      98       2940 I      42       44      84       2520 I\n+I      12       13      97       2910 I      45       46      83       2490 I\n+I      14       15      96       2880 I      47       49      82       2460 I\n+I      16       17      95       2850 I      50       52      81       2430 I\n+I      18       19      94       2820 I      53       55      80       2400 I\n+I      20       22      93       2790 I      56       58      79       2370 I\n+I      23       24      92       2760 I      59       61      78       2340 I\n+I      25       26      91       2730 I      62       65      77       2310 I\n+I      27       28      90       2700 I      66       68      76       2280 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTB011\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB011": {"ttr": 27669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3350 block sizes table (1 Cyl = 30 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I      69       71      75       2250 I     126      130      61       1830 I\n+I      72       75      74       2220 I     131      135      60       1800 I\n+I      76       78      73       2190 I     136      141      59       1770 I\n+I      79       82      72       2160 I     142      146      58       1740 I\n+I      83       86      71       2130 I     147      152      57       1710 I\n+I      87       90      70       2100 I     153      158      56       1680 I\n+I      91       94      69       2070 I     159      165      55       1650 I\n+I      95       98      68       2040 I     166      171      54       1620 I\n+I      99      102      67       2010 I     172      178      53       1590 I\n+I     103      106      66       1980 I     179      185      52       1560 I\n+I     107      111      65       1950 I     186      192      51       1530 I\n+I     112      115      64       1920 I     193      200      50       1500 I\n+I     116      120      63       1890 I     201      207      49       1470 I\n+I     121      125      62       1860 I     208      216      48       1440 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTB012\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB012": {"ttr": 27671, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3350 block sizes table (1 Cyl = 30 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     217      224      47       1410 I     382      398      33        990 I\n+I     225      233      46       1380 I     399      416      32        960 I\n+I     234      242      45       1350 I     417      436      31        930 I\n+I     243      252      44       1320 I     437      456      30        900 I\n+I     253      262      43       1290 I     457      478      29        870 I\n+I     263      273      42       1260 I     479      502      28        840 I\n+I     274      284      41       1230 I     503      528      27        810 I\n+I     285      296      40       1200 I     529      555      26        780 I\n+I     297      308      39       1170 I     556      585      25        750 I\n+I     309      321      38       1140 I     586      617      24        720 I\n+I     322      335      37       1110 I     618      652      23        690 I\n+I     336      349      36       1080 I     653      690      22        660 I\n+I     350      365      35       1050 I     691      731      21        630 I\n+I     366      381      34       1020 I     732      777      20        600 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTB013\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB013": {"ttr": 27673, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3350 block sizes table (1 Cyl = 30 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     778      828      19        570 I    3025     3665       5        150 I\n+I     829      884      18        540 I    3666     4628       4        120 I\n+I     885      947      17        510 I    4629     6233       3         90 I\n+I     948     1018      16        480 I    6234     9442       2         60 I\n+I    1019     1098      15        450 I    9443    19069       1         30 I\n+I    1099     1190      14        420 I                                     I\n+I    1191     1296      13        390 I                                     I\n+I    1297     1419      12        360 I                                     I\n+I    1420     1565      11        330 I                                     I\n+I    1566     1740      10        300 I                                     I\n+I    1741     1954       9        270 I                                     I\n+I    1955     2221       8        240 I                                     I\n+I    2222     2565       7        210 I                                     I\n+I    2566     3024       6        180 I                                     I\n+-----------------------------------------------------------------------------\n+\n)PROC\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB020": {"ttr": 27675, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3380 block sizes table (1 Cyl = 15 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I       1       20      93       1395 I     437      468      49        735 I\n+I      21       52      88       1320 I     469      500      48        720 I\n+I      53       84      83       1245 I     501      532      46        690 I\n+I      85      116      78       1170 I     533      564      45        675 I\n+I     117      148      74       1110 I     565      596      44        660 I\n+I     149      180      71       1065 I     597      628      42        630 I\n+I     181      212      68       1020 I     629      660      41        615 I\n+I     213      244      65        975 I     661      692      40        600 I\n+I     245      276      62        930 I     693      724      39        585 I\n+I     277      308      59        885 I     725      756      38        570 I\n+I     309      340      57        855 I     757      788      37        555 I\n+I     341      372      55        825 I     789      820      36        540 I\n+I     373      404      53        795 I     821      852      35        525 I\n+I     405      436      51        765 I     853      916      34        510 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTB021\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB021": {"ttr": 27677, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3380 block sizes table (1 Cyl = 15 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     917      948      33        495 I    1877     2004      19        285 I\n+I     949      980      32        480 I    2005     2164      18        270 I\n+I     981     1044      31        465 I    2165     2324      17        255 I\n+I    1045     1076      30        450 I    2325     2484      16        240 I\n+I    1077     1140      29        435 I    2485     2676      15        225 I\n+I    1141     1204      28        420 I    2677     2932      14        210 I\n+I    1205     1268      27        405 I    2933     3188      13        195 I\n+I    1269     1332      26        390 I    3189     3476      12        180 I\n+I    1333     1396      25        375 I    3477     3860      11        165 I\n+I    1397     1492      24        360 I    3861     4276      10        150 I\n+I    1493     1588      23        345 I    4277     4820       9        135 I\n+I    1589     1684      22        330 I    4821     5492       8        120 I\n+I    1685     1780      21        315 I    5493     6356       7        105 I\n+I    1781     1876      20        300 I    6357     7476       6         90 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTB022\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB022": {"ttr": 27679, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3380 block sizes table (1 Cyl = 15 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I    7477     9076       5         75 I                                     I\n+I    9077    11476       4         60 I                                     I\n+I   11477    15476       3         45 I                                     I\n+I   15477    23476       2         30 I                                     I\n+I   23477    47476       1         15 I                                     I\n+I                                     I                                     I\n+I                                     I                                     I\n+I                                     I                                     I\n+I                                     I                                     I\n+I                                     I                                     I\n+I                                     I                                     I\n+I                                     I                                     I\n+I                                     I                                     I\n+I                                     I                                     I\n+-----------------------------------------------------------------------------\n+\n)PROC\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB030": {"ttr": 27905, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 2305-2 block sizes table (1 Cyl = 8 Trks) ----------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I       1        2      74        592 I      46       49      60        480 I\n+I       3        5      73        584 I      50       53      59        472 I\n+I       6        8      72        576 I      54       58      58        464 I\n+I       9       11      71        568 I      59       62      57        456 I\n+I      12       14      70        560 I      63       67      56        448 I\n+I      15       17      69        552 I      68       72      55        440 I\n+I      18       20      68        544 I      73       77      54        432 I\n+I      21       23      67        536 I      78       82      53        424 I\n+I      24       27      66        528 I      83       87      52        416 I\n+I      28       30      65        520 I      88       93      51        408 I\n+I      31       34      64        512 I      94       99      50        400 I\n+I      35       37      63        504 I     100      105      49        392 I\n+I      38       41      62        496 I     106      111      48        384 I\n+I      42       45      61        488 I     112      118      47        376 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTB031\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB031": {"ttr": 27907, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 2305-2 block sizes table (1 Cyl = 8 Trks) ----------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     119      125      46        368 I     253      266      32        256 I\n+I     126      132      45        360 I     267      281      31        248 I\n+I     133      139      44        352 I     282      297      30        240 I\n+I     140      147      43        344 I     298      314      29        232 I\n+I     148      155      42        336 I     315      332      28        224 I\n+I     156      164      41        328 I     333      352      27        216 I\n+I     165      173      40        320 I     353      373      26        208 I\n+I     174      182      39        312 I     374      396      25        200 I\n+I     183      193      38        304 I     397      421      24        192 I\n+I     194      203      37        296 I     422      448      23        184 I\n+I     204      214      36        288 I     449      477      22        176 I\n+I     215      226      35        280 I     478      509      21        168 I\n+I     227      239      34        272 I     510      544      20        160 I\n+I     240      252      33        264 I     545      584      19        152 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTB032\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTB032": {"ttr": 27909, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 2305-2 block sizes table (1 Cyl = 8 Trks) ----------------\n+-----------------------------------------------------------------------------\n+I                         Capacities without keys                           I\n+I---------------------------------------------------------------------------I\n+I  Bytes/rec(DL)   I   Records per    I  Bytes/rec(DL)   I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     585      627      18        144 I    2774     3516       4         32 I\n+I     628      676      17        136 I    3517     4754       3         24 I\n+I     677      730      16        128 I    4755     7231       2         16 I\n+I     731      792      15        120 I    7232    14660       1          8 I\n+I     793      863      14        112 I                                     I\n+I     864      944      13        104 I                                     I\n+I     945     1040      12         96 I                                     I\n+I    1041     1152      11         88 I                                     I\n+I    1153     1287      10         80 I                                     I\n+I    1288     1452       9         72 I                                     I\n+I    1453     1659       8         64 I                                     I\n+I    1660     1924       7         56 I                                     I\n+I    1925     2278       6         48 I                                     I\n+I    2279     2773       5         40 I                                     I\n+-----------------------------------------------------------------------------\n+\n)PROC\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTCNTR": {"ttr": 27911, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11(\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:28:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"CENTER\"       |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to center text within data line(s).\n%SYNTAX :+   CENTER\n             CENTER HELP or H\n%USE :+      Type%CENTER+on the COMMAND line and mark the range of lines text\n             with the \"C\" range command on the line numbers, as i.e. :\n            %COMMAND ===> CENTER\n        ---> CC+500   --------------\n             000600   |  TITLE ... |\n       %---> CC+700   --------------\n             000800   Subtitle : ...\n            %Result :+the text of lines numbered 500, 600 and 700 will be\n                      centered. Identical process is obtained with :\n       %---> C3+500   --------------\n)PROC\n  &ZCONT = PAJTCNTR\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTCOM": {"ttr": 27913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16O\\x00\\x90\\x16O\\x128\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-13T00:00:00", "modifydate": "1990-06-13T12:38:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - COMPARE - Compare Sequentials or Members ---------------------------\n+\n% Purpose+: Compare two sequential data-sets or members.\n+           The compare is done by either the YALE COMPARE program (COMPAREB)\n+           or by the IBM COMPARE utility program (IEBCOMPR).\n+           The SYSPRINT messages are written to wherever FILENAME(SYSPRINT)\n+           is allocated - usually to the terminal.\n+ Optionally, supply :\n+                FULL     - include the sequence numbers (YALE pgm).\n+                ASM      - comparing assembler source code (YALE pgm).\n+                IEBCOMPR - the IEBCOMPR utility is to be used.\n+                SYSOUT   - messages to a SYSOUT data-set.\n+                PRINT    - messages to terminal (default).\n+                NOPRINT  - messages to dummy file.\n+                BROWSE   - messages in browse to terminal.\n+                ..name.. - messages to specified DDname.\n+           When volume serials are used to indicate two identically named\n+           data-sets on different volumes are being used, unexpected results\n+           can occur unless both are specified.\n+ File IGNORE : is optional. If it is available, then it is used to help\n+               control the possible desynchronization problems.\n+\n+  Depress%PF3+or%PF15+to return to the%COMPARE+panel.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTCOMP": {"ttr": 27915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x103\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T10:33:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |     Edit Macro  \"COMPRESS\"      |\n                      -----------------------------------\n+\n%FUNCTION :+This Edit macro allows a user to compress in place the current\n            partitioned data-set.\n%SYNTAX :+  COMPRESS\n            COMPRESS HELP or H\n%NOTE :+    If the condition code is other than 0 type in HELP for additional\n            information.\n%USE :+     Type%COMPRESS+on the COMMAND line.\n+\n)PROC\n  &ZCONT = PAJTCOMP\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTCONT": {"ttr": 27917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11Y\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:59:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"CONT\"        |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to place a continuation character in\n             column 72 of data line(s).\n%SYNTAX :+   CONT\n             CONT HELP or H\n%USE :+      Type%CONT+on the COMMAND line and mark the range of continuation\n             with the \"C\" range command on the line numbers, as i.e. :\n            %COMMAND ===> CONT\n        ---> CC+500           MYMAC PARM1,\n             000600             PARM2,\n       %---> CC+700             PARM3,\n             000800             LASTPARM\n            %Result :+a%X+is placed in column 72 of lines numbered 500, 600\n                      and 700. Identical process is obtained with :\n       %---> C3+500           MYMAC PARM1,\n)PROC\n  &ZCONT = PAJTCONT\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTCRY": {"ttr": 27919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89!O\\x00\\x89!O\\x12\\x04\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-02T00:00:00", "modifydate": "1989-08-02T12:04:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |        Edit Macro  \"CRY\"        |\n                      -----------------------------------\n+\n%FUNCTION :+ This Edit macro performs the ENCRYPTION or DECRYPTION of data\n             operating as a primary command under ISPF-PDF EDIT.\n%OPERATION :+the ENCRYPTION or DECRYPTION is performed by utilizing a key\n             value supplied as an operand of the primary command.\n%SYNTAX :+   !CRY ENCRYPT,KEYVALUE    !CRY DECRYPT,KEYVALUE    !CRY HELP\n               or EN                    or DE                    or H\n                  E                        D\n             the KEYVALUE is a user supplied keyword which is used as ENCRYPT-\n             DECRYPT code value. The keyword is limited to eight (8) bytes in\n             length, but may be shorter. When the KEYVALUE operand of the\n             primary command is omited, you are prompted to supply it\n             unviewable (i.e. when entering \"!CRY E\" only).\n\n                           (continued on next page)\n+\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTCRY1": {"ttr": 27921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89$\\x9f\\x00\\x89$\\x9f\\x10X\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-06T00:00:00", "modifydate": "1989-09-06T10:58:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |        Edit Macro  \"CRY\"        |\n                      -----------------------------------\n+\n%WARNING :+  If you forget the KEYVALUE that you used to encipher the data,\n             KISS THE DATA GOOD-BYE because there is no way of deciphering\n             the data again. If you are hopelessly paranoid, you can encipher\n             the enciphered data with a different KEYVALUE to really grunge up\n             the data. The decipherion process must be the exact inverse of the\n             encipher process in order to recover the original data again.\n%EXAMPLES :+ 1) to encipher the data with the key of ALPHA, type : !CRY E,ALPHA\n                and to get it back to clear text again, type : !CRY D,ALPHA\n             2) to really garbage up the data with keys of ALPHA and BRAVO,\n                type : !CRY E,ALPHA and then after !CRY E,BRAVO\n                and to decipher the text, just reverse the order as follows,\n                type : !CRY D,BRAVO and then after !CRY D,ALPHA\n%RANGE :+    You may also limit the encryption-decryption by marking a range of\n             lines of text with the \"C\" range command on the line numbers.\n+\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTCTRL": {"ttr": 27923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\t\\x15\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T09:15:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"CONTROL\"      |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to insert CONTROL statements in CLISTs.\n             An optional parameter%OFF+will insert a CLIST statement to turn\n             OFF previously set control. The control CLIST can be used for\n             debugging select lines of a problem CLIST.\n%SYNTAX :+   CONTROL or CONTROL ON, and CONTROL OFF\n             CONTROL HELP or H\n%USE :+      Type%CONTROL+on the COMMAND line and use the \"A\" or \"B\" range\n             command to indicate where the CONTROL statement is to be inserted.\n%Example :   COMMAND ===> CONTROL\n        ---> A+0500      SET TYPE = COMMAND\n             000600      SET I = 1\n            %Result :+\n             000500      SET TYPE = COMMAND\n       %---> 000510      CONTROL MSG LIST CONLIST SYMLIST\n+            000600      SET I = 1\n)PROC\n  &ZCONT = PAJTCTRL\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTCUT": {"ttr": 27925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\tI\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T09:49:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |        Edit Macro  \"CUT\"        |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to\n            %1+- write lines from a file to the user profile POOL for later\n                 inclusion by the INSERT option, or\n            %2+- write lines from the user profile POOL into the current file\n                 (INSERT option), or\n            %3+- delete CUT data in the various levels of CUT in the user\n                 profile POOL, or\n            %4+- show CUT data in the various levels of CUT in the user profile\n                 POOL, or\n            %5+- show the first line of all levels of CUT in the user profile\n                 POOL.\n%SYNTAX :+   CUT (default level is 1) or CUT LN (level-number) or\n             CUT LN INSERT or CUT LN DELETE or CUT LN SHOW or\n             CUT SHOW or CUT SHOW TERSE or CUT HELP or H\n+\n                           (continued on next page)\n+\n)PROC\n  &ZCONT = PAJTCUT1\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTCUT1": {"ttr": 27927, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\tI\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T09:49:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |        Edit Macro  \"CUT\"        |\n                      -----------------------------------\n+\n%1+-write lines from a file to the user profile POOL for later inclusion by the\n    INSERT option.\n   %SYNTAX :+CUT (default level is 1) or CUT LN (level-number)\n   %RESTRICTION :+the level-number may range between 1 and 99 included only.\n%USE :+      Enter%CUT+on the command line and use the%C+or%M+line commands (in\n             any form) to select the lines to be cut. If the%M+line command is\n             used, the indicated lines are%deleted+(reset to blanks) after they\n             have been copied. A level-number may be used to separate different\n             levels of CUT. This way you can make many CUTs before you INSERT.\n             If the level-number is omited, level 1 is assumed and anything in\n             the level 1 will be overlayed.\n             CUT%3+(or any number) will CUT the indicated line(s) into level%3+\n             (or level indicated) and can be INSERTed using the level-number.\n+\n                           (continued on next page)\n+\n)PROC\n  &ZUP = PAJTCUT\n  &ZCONT = PAJTCUT2\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTCUT2": {"ttr": 27929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x14Q\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T14:51:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |        Edit Macro  \"CUT\"        |\n                      -----------------------------------\n+\n%2+-write lines from the user profile POOL into the current file (INSERT\n    option).\n   %SYNTAX :+CUT LN (level-number) INSERT or I\n%USE :+      Enter%CUT+on the command line followed by the level-number and\n             the keyword INSERT or I, and use the%A+or%B+line command to\n             specify where the lines are to be inserted.\n             The level-number may be used to separate different levels of CUTs.\n             CUT%3+(or any number) INSERT will add all the lines of the CUT\n             level%3+(or level indicated) where the%A+or%B+line command (after\n             or before) is pointing in the current file.\n+\n                           (continued on next page)\n+\n)PROC\n  &ZUP = PAJTCUT1\n  &ZCONT = PAJTCUT3\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTCUT3": {"ttr": 27931, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x14Q\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T14:51:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |        Edit Macro  \"CUT\"        |\n                      -----------------------------------\n+\n%3+-delete CUT data in the various levels of CUT in the user profile POOL.\n   %SYNTAX :+CUT LN (level-number) DELETE or D\n%USE :+      Type%CUT+on the COMMAND line followed by the level-number and the\n             keyword DELETE or D.\n             In example :\n            %COMMAND ===> CUT 2 DELETE\n+            ************************** TOP OF DATA **************************\n             Result :\n            %COMMAND ===>                                  CUT LEVEL 2 DELETED\n+            ************************** TOP OF DATA **************************\n+\n                           (continued on next page)\n+\n)PROC\n  &ZUP = PAJTCUT2\n  &ZCONT = PAJTCUT4\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTCUT4": {"ttr": 27933, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x14Q\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T14:51:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |        Edit Macro  \"CUT\"        |\n                      -----------------------------------\n+\n%4+-show CUT data in the various levels of CUT in the user profile POOL.\n   %SYNTAX :+CUT LN (level-number) SHOW or S\n%USE :+      Type%CUT+on the COMMAND line followed by the level-number and the\n             keyword SHOW or S.\n             In example :\n            %COMMAND ===> CUT 2 SHOW\n+            ************************** TOP OF DATA **************************\n             Result :                            %Remark :+you may place the\n            %==MSG> CUT LEVEL 1 HAS 4 LINE(S)    %cursor+on a data line to\n            %==MSG>+... DATA LINE 1 ...           indicate where the MSG lines\n            %==MSG>+... DATA LINE 2 ...           must be inserted (before),\n            %==MSG>+... DATA LINE 3 ...           then press ENTER (by default\n            %==MSG>+... DATA LINE 4 ...           it is before data line 1).\n+\n                           (continued on next page)\n+\n)PROC\n  &ZUP = PAJTCUT3\n  &ZCONT = PAJTCUT5\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTCUT5": {"ttr": 27935, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x14Q\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T14:51:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |        Edit Macro  \"CUT\"        |\n                      -----------------------------------\n+\n%5+-show the first line of all levels of CUT in the user profile POOL. An\n    optional keyword TERSE will prevent display for CUT levels with no lines.\n   %SYNTAX :+CUT SHOW or CUT SHOW TERSE (CUT S or CUT S T)\n%USE :+      Type%CUT+on the COMMAND line followed by the keyword SHOW and the\n             optional TERSE keyword.\n             In example :\n            %COMMAND ===> CUT SHOW TERSE\n+            ************************** TOP OF DATA **************************\n             Result :\n            %==MSG> FIRST LINE OF EACH LEVEL OF CUT WILL BE SHOWN\n            %==MSG> CUT LEVEL 1 HAS 4 LINE(S)    %Remark :+you may place the\n            %==MSG>+... DATA LINE 1 ...          %cursor+on a data line to\n            %==MSG> CUT LEVEL 3 HAS 9 LINE(S)    +indicate where the MSG lines\n            %==MSG>+... DATA LINE 1 ...           must be inserted (before),\n+            ... and so on ...                    then press ENTER (by default\n+            (the scan is done until level 99)    it is before data line 1).\n)PROC\n  &ZUP = PAJTCUT4\n  &ZCONT = PAJTCUT\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTDAY": {"ttr": 27937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89#?\\x00\\x89#?\\tF\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-21T00:00:00", "modifydate": "1989-08-21T09:46:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial -  W E E K D A Y  ----------------------------------------------------\n+  This function is self-explanatory. Try it.\n+  N.B. - If you don't supply any date at the initial start, the today date is\n+         acquired from the system.\n+       - Each time you successively press%ENTER+the date is incremented by\n+         one day.\n+       - Changing only the Table Suffix allows you to redisplay the same date\n+         but selecting other Weekday/Month names tables.\n+  Available Table Suffixes :\n+         none : English (this is the default)\n+         I    : Italian      F    : French       D    : German\n+         E    : Spanish      P    : Portuguese   DK   : Danish\n+\n+  Depress%ENTER+to have the%History+panel.\n+  Depress%PF3+or%PF15+to return to the%DAY+panel.\n)PROC\n  &ZCONT = PAJTDAYH\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTDAYH": {"ttr": 28161, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89#?\\x00\\x89#?\\x118\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-08-21T00:00:00", "modifydate": "1989-08-21T11:38:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial -  W E E K D A Y  -  H I S T O R Y  ----------------------------------\n+  Gregorian calendar :\n+  It was made up by Pope Gregory XIII in 1582 to correct the Julian calendar,\n+  which Julius Caesar worked out in 46 b.c.\n+  The Julian calendar year was 11 minutes and 14 seconds longer than the solar\n+  year. By a.d. 1580, this difference had accumulated to 10 days. Pope Gregory\n+  dropped 10 days from October 1582 (the day that would have been October 5\n+  became October 15) to make the calendar year correspond more closely to the\n+  solar year. He also decreed that each fourth year would be a leap year, when\n+  February would have an extra day. Years marking the century would not be\n+  leap years unless divisible by 400. For example, 1600 was a leap year, but\n+  1700, 1800, and 1900 were not.\n+  The Gregorian calendar is so accurate that the difference between the\n+  calendar and solar years is now only about 26.3 seconds. This difference\n+  will increase by .53 second every hundred years, because the solar year is\n+  gradually growing shorter. By the year 4316, it will have gained one day\n+  on the sun.\n+\n+  Depress%ENTER+to return to the%Tutorial - WEEKDAY+panel.\n+  Depress%PF3+or%PF15+to return to the%DAY+panel.\n)PROC\n  &ZUP = PAJTDAY\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTDAYS": {"ttr": 28163, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x85\\x19\\x1f\\x00\\x85\\x19\\x1f\\x16 \\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-07-10T00:00:00", "modifydate": "1985-07-10T16:20:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - DAY - Tables Services ----------------------------------------------\n+  This function allows you to create (or modify) and display the WEEKDAY and\n+  MONTH names tables.\n+  N.B. - The WEEKDAY and MONTH names tables are members stored in the data-set\n+         allocated to your session by the DD-name \"ISPTLIB\". The names of\n+         these members are generated with the fixed prefix \"TWKD\" (WEEKDAY)\n+         or \"TMTH\" (MONTH) and the suffix you have supplied at creation.\n+  Depress%PF3+or%PF15+to return to the%DAY Services+panel.\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTDSC": {"ttr": 28165, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90)_\\x00\\x90)_\\x170\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-22T00:00:00", "modifydate": "1990-10-22T17:30:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - CDSCB - Change DSCB (Format-1) -------------------------------------\n+  This function can be used to modify a data-set's Format-1 DSCB in a VTOC.\n+\n+  Follows a description of the selectable options :\n%      DISPLAY+- List the Format-1 DSCB (after eventual modify) at the terminal.\n+         Default is NO. Option is ignored if the data-set is not cataloged.\n%      KEEP OP.+- Keep previous operands displayed on panel after an operation.\n+         Default is NO.\n+\n+  Possible%operands+syntax :\n+         SHR   CREATE(YYDDD)   EXPDT(YYDDD)   REFDT(YYDDD)\n+         DSORG(XX)   RECFM(XX)   BLKSIZE(XX)   LRECL(XX)\n+         ALLOC(TR/CYL/BL)   SPACE(Secondary-Amount)\n+         PWR/PWW/NOP/RACF/NORACF\n+         ZAP(Offset Verdata Repdata)\n+         LIST/NOLIST/FULL\n+  You may enter operands wraping the next two line(s).\n+\n+  Depress%PF3+or%PF15+to return to the%CDSCB+panel.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTDSP": {"ttr": 28167, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x924o\\x00\\x924o\\x14\\x12\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-12-11T00:00:00", "modifydate": "1992-12-11T14:12:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - DSPRT - Data-set Print Selection -----------------------------------\n+  This function can be used to invoke the IPO PRINTOFF command.\n+  Follows a description of the selectable ouput print options :\n%      SYSOUT Class+- Sysout class in which output is to be printed.\n+         Default is A.\n%      Copies+- number of copies to be printed.\n%      Heading+- output is to have heading information.\n%      Upper case translation+- FOLD/NOFOLD to convert or not the output to\n+         upper case prior to printing.\n%      Output status+- HOLD/NOHOLD to place or not the output on a Hold Queue\n+         upon deallocation.\n%      RMT destination+- Remote Station to which the output (sysout) is to\n+         be routed.\n+  Depress%PF3+or%PF15+to return to the%DSPRT+panel.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTDSPL": {"ttr": 28169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(/\\x00\\x90(/\\tR\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-09T00:00:00", "modifydate": "1990-10-09T09:52:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - DSPRT - Member selection list --------------------------------------\n+  If you specify an ISPF library or other partitioned data-set and do not\n+  enter a member name, a%member selection list+is displayed, from which you\n+  may select one member at a time for processing by entering in front of\n+  the desired member name :\n+                  a%S+to print it, or\n+                  a%B+to browse it.\n+  You may scroll through the list via the scroll commands (%UP+or%DOWN+).\n+  You may position the list on a specified member name via the%LOCATE+command\n+  (short form%LOC+or%L+also accepted).\n+  You may%print+the displayed%members list+via the%DIRECTORY+command (short\n+  form%DIR+or%D+also accepted).\n+  To terminate the member list, enter the%END+command.\n+\n+  Depress%PF3+or%PF15+to return to the%DSPRT Select member+panel.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTDSS": {"ttr": 28171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x06O\\x00\\x96\\x06O\\x13X\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-03-04T00:00:00", "modifydate": "1996-03-04T13:58:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - STATDS - Data-set Statistics ---------------------------------------\n+  This function formats information on any disk data-set. It reads through the\n+  entire data-set and outputs disk track usage, blocksize and other statistics.\n+  If a%no PARM+is coded, the following information will be given :\n+      a) DCB and DSCB characteristics.\n+      b) Record counts, record size, track usage statistics for any type of\n+         data-set organization. For DSORG=IS, it reads through the entire\n+         data-set (there may be up to three separate files of data and reports\n+         on each file). Also, the ISAM label (format 2 DSCB) record will be\n+         read and a data-set profile which includes data-set reorganization\n+         data and data-set characteristics will be provided.\n+      c) For DSORG=PO, the directory TTR's will be compared against actual\n+         disk addresses to determine the TTRs of \"gas\" members (the first 72\n+         characters of any \"gas\" member are outputed). Statistics are\n+         maintained on the size of \"gas\" and \"real\" members and the number of\n+         alias members. If any aliases are in the data-set, a check is made\n+         to see that corresponding real entries also exist.\n+  A PARM of%'NO'+nullify the gas TTR report.\n+  A PARM of%'LABEL'+give only DCB and DSCB characteristics.\n+  A PARM of%'FULL'+supply the directory members list (only DSORG=PO).\n+  A PARM of%'GAS(TT.TT.RR)'+add a member name to the directory for the \"gas\"\n+      member having the specified TTR location (in HEX from a previous run).\n+  Depress%PF3+or%PF15+to return to the%STATDS+panel.\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEDCR": {"ttr": 28173, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x104\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T10:34:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |  Edit Macros \"ENCRYPT-DECRYPT\"  |\n                      -----------------------------------\n+\n%FUNCTION :+ These Edit macros perform the ENCRYPTION or DECRYPTION of data\n             operating as a primary command under ISPF-PDF EDIT.\n%OPERATION :+the ENCRYPTION or DECRYPTION is performed by utilizing a KEY-VALUE\n             you are prompted to supply it unviewable. The KEY-VALUE is a user\n             supplied keyword which is used as ENCRYPT-DECRYPT code value. The\n             keyword is limited to eight bytes in length, but may be shorter.\n%SYNTAX :+      ENCRYPT or               DECRYPT or\n                ENCRYPT HELP or H        DECRYPT HELP or H\n%WARNING :+  If you forget the KEY-VALUE that you used to encipher the data,\n             KISS THE DATA GOOD-BYE because there is no way of deciphering the\n             data again. If you are hopelessly paranoid, you can encipher the\n             enciphered data with a different KEY-VALUE to really grunge up the\n             data. The decipherion process must be the exact inverse of the\n             encipher process in order to recover the original data again.\n%RANGE :+    You may also limit the encryption-decryption by marking a range of\n             lines of text with the \"C\" range command on the line numbers.\n)PROC\n  &ZCONT = PAJTEDCR\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM": {"ttr": 28175, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"O\\x00\\x91\"O\\x12$\\x001\\x001\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-12T00:00:00", "modifydate": "1991-08-12T12:24:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to verify and set the EDIT modes for\n             the current edit file.\n%SYNTAX :+   EDMODE or EDMODE HELP or H\n%USE :+      Type%EDMODE+on the COMMAND line, and you will be prompted to\n             verify and eventually change the EDIT modes of the editing data.\n\n+The sections listed below will be presented in sequence (hit%ENTER+to go on to\n the next screen) or you may select a particular subject by number :\n\n%  1+- STATS             %  5+- NUMBER            %  9+- AUTONUM\n%  2+- VERSION/LEVEL     %  6+- NULLS             % 10+- AUTOLIST\n%  3+- RECOVERY          %  7+- HEX               % 11+- AUTOSAVE\n%  4+- CAPS              %  8+- BOUNDS\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZSEL = TRANS(&ZCMD\n                1,PAJTEM1\n                2,PAJTEM2\n                3,PAJTEM3\n                4,PAJTEM4\n                5,PAJTEM5\n                6,PAJTEM6\n                7,PAJTEM7\n                8,PAJTEM8\n                9,PAJTEM9\n               10,PAJTEM10\n               11,PAJTEM11\n                )\n  &ZTRAIL = .TRAIL\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEMU": {"ttr": 28177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"o\\x00\\x91\"o\\x12\\'\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-14T00:00:00", "modifydate": "1991-08-14T12:27:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY\n%-------------------- Additional local Edit macros Updates --------------------+\n%COMMAND ===>_ZCMD                                                             +\n+\n\n Available%Line-commands :+(Entered in \"action\" area at the left of the\n                            desired Edit macro name)\n\n                          %A+- Add a new macro name to the list\n                          %D+- Delete a macro name from the list\n                          %R+- Repeat a macro name in the list\n                          %S+- Get the HELP of a macro\n                          %U+- Update a macro name in the list\n\n+\n)PROC\n  &ZCONT = PAJTEMU\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM1": {"ttr": 28179, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16_\\x00\\x90\\x16_\\x16\\x00\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "1990-06-14T16:00:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%STATS :+\n   Use%STATS+to turn STATS mode on or off (\"ON\" is the default).\n   If STATS mode is on, ISPF statistics will be generated for members of\n   partitioned data-sets. If STATS mode is off, no ISPF statistics will be\n   generated. STATS mode is always set off for sequential data-sets.\n\n   More topic will be presented in the EDIT tutorial.\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM10": {"ttr": 28181, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16_\\x00\\x90\\x16_\\x16\\x00\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "1990-06-14T16:00:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%AUTOLIST :+\n+  Use%AUTOLIST+to turn AUTOLIST mode on or off (\"ON\" is the default).\n   If AUTOLIST mode is on, data is automatically formatted and written to the\n   ISPF file when it is saved. The list file is normally printed when you exit\n   from ISPF. If AUTOLIST mode is off, data is not written to the list file.\n   If you want to maintain hardcopy listings of the latest versions of your\n   program source, you should set AUTOLIST on. Then the listings will be\n   created automatically.\n\n   More topic will be presented in the EDIT tutorial.\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM11": {"ttr": 28183, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11\\x19\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:19:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%AUTOSAVE :+\n+  Use%AUTOSAVE+to turn AUTOSAVE mode on or off (\"ON\" is the default) and\n   save the setting in the edit profile.\n   If AUTOSAVE mode is on, END causes data to be saved on disk.\n   If AUTOSAVE mode is off with the PROMPT option, END causes you to be\n   prompted for either a SAVE command or a CANCEL command.\n   If AUTOSAVE mode is off with the NOPROMPT option, END causes data%not+\n   to be saved, and in this case, END works exactly like CANCEL.\n\n   More topic will be presented in the EDIT tutorial.\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTEM\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM2": {"ttr": 28185, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16_\\x00\\x90\\x16_\\x16\\x00\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "1990-06-14T16:00:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%VERSION :+\n   Use%VERSION+to change the version level of the member being edited (STATS\n   must be ON). The version level can be entered as a number in the range 1-99.\n   VERSION has no effect on the modification level (it is not reset to zero\n   when the version number is changed).\n%LEVEL :+\n   Use%LEVEL+to change the modification level of the member being edited (STATS\n   must be ON). The modification level can be entered as a number in the range\n   0-99. Normally, the modification level is automatically incremented  by one\n   when the first change is made to the data. Automatic incrementing is\n   suppressed under the following conditions :\n        - If it is a new member (mod level remains at 00),\n        - If a LEVEL has already been set.\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM3": {"ttr": 28187, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11\\x19\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:19:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%RECOVERY :+\n   Use%RECOVERY+to turn RECOVERY mode on or off.\n   If RECOVERY mode is on when a system crash occurs, automatic recovery will\n   take place the next time that you attempt to use edit.\n   RECOVERY mode is remembered in your edit profile. The default setting for\n   a new edit profile is RECOVERY off.\n   If any changes have been made to the data, turning RECOVERY mode on causes\n   the data to be immediately written to a temporary%backup+file. If no changes\n   have been made to the data, turning RECOVERY mode on simply changes the\n   current edit profile. When the first change is made to the data, it is then\n   written to the backup file.\n\n   More topic will be presented in the EDIT tutorial.\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM4": {"ttr": 28189, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16_\\x00\\x90\\x16_\\x16\\x00\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "1990-06-14T16:00:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%CAPS :+\n   Use%CAPS+to turn CAPS mode off or on (\"ON\" is the default).\n   If CAPS mode is on, edit translates all lower case data that is read from\n   the display into upper case. If CAPS mode is off, data read from the display\n   left unchanged. If the data being edited contains lower case data, it will\n   not be changed unless it is written to the 3270 screen and then read back.\n   Since data is read back by field, only fields that have been changed will\n   be translated to upper case.\n\n   More topic will be presented in the EDIT tutorial.\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM5": {"ttr": 28191, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16_\\x00\\x90\\x16_\\x16\\x00\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "1990-06-14T16:00:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%NUMBER :+\n   Use%NUMBER+to turn NUMBER mode on or off (\"ON\" is the default) and to\n   indicate whether you want standard numbering, COBOL numbering, or both\n   (\"STD\" is the default). When NUMBER mode is set on, edit creates an\n   ascending sequence number for any records that do not already contain them.\n\n   More topic will be presented in the EDIT tutorial.\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM6": {"ttr": 28417, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16_\\x00\\x90\\x16_\\x16\\x00\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "1990-06-14T16:00:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%NULLS :+\n   Use%NULLS+to turn NULLS mode on or off (\"ON\" is the default) and to\n   indicate whether you want the display to be in STD or ALL mode (STD is\n   the default).\n   In STD mode, 3270 null characters replace all but the first trailing\n   blank in each field on the screen. If a field is entirely blank, null\n   characters are not substituted.\n   In ALL mode, 3270 null characters replace all trailing blanks in each\n   field on the screen, including fields that are entirely blank.\n\n   More topic will be presented in the EDIT tutorial.\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM7": {"ttr": 28419, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16_\\x00\\x90\\x16_\\x16\\x00\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "1990-06-14T16:00:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%HEX :+\n   Use%HEX+to turn HEX mode on or off (\"ON\" is the default) and to indicate\n   whether you want the display to be in vertical (VERT) or data (DATA) format\n   (VERT is the default).\n   When HEX mode is on, the cursor will be positioned to the hexadecimal\n   representation of the data after a successfull FIND command.\n   When HEX mode is on, the columns line(s) are specially formatted to make it\n   easier to find the hexadecimal representation of a specific column.\n\n   More topic will be presented in the EDIT tutorial.\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM8": {"ttr": 28421, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16_\\x00\\x90\\x16_\\x16\\x00\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "1990-06-14T16:00:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%BOUNDS :+\n   Use%BOUNDS+to set the left and right bounds and save set them in the edit\n   profile. It provides an easier way to change the bounds instead of setting\n   them in the bounds line (=BNDS>).\n   Either both bounds must be specified. The first one specified (left-column\n   number) must be smaller than the second (right).\n\n   More topic will be presented in the EDIT tutorial.\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEM9": {"ttr": 28423, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x16_\\x00\\x90\\x16_\\x16\\x00\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "1990-06-14T16:00:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"EDMODE\"       |\n                      -----------------------------------\n+\n%AUTONUM :+\n   Use%AUTONUM+to turn AUTONUM mode on or off (\"ON\" is the default).\n   If both AUTONUM and NUMBER modes are on, sequence fields in the data will\n   be automatically renumbered when the data is saved. This can occur when a\n   SAVE, CREATE, REPLACE, or END command is entered. When the SAVE command is\n   used, the displayed data will not be renumbered, but the saved data will.\n   If AUTONUM mode is off, sequence fields will not be renumbered when data\n   is saved.\n   AUTONUM mode is ignored if NUMBER mode is off, since it is assumed that\n   the data does not contain any sequence numbers.\n\n   More topic will be presented in the EDIT tutorial.\n+\n+Enter%&EPF+to exit the tutorial and return to the EDIT modes control panel\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTEQD": {"ttr": 28425, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90&/\\x00\\x90&/\\x16)\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-09-19T00:00:00", "modifydate": "1990-09-19T16:29:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - ENQDIS - Various Enqueues displays ---------------------------------\n% LISTENQ +- Returns information reguarding data-sets allocations for a Job or\n+            User-id. It tells you what data-set(s) the Job or User-id has\n+            allocated (OLD or SHR). It will also tell what data-set(s) the\n+            Job or User-id may be waiting on.\n% WAITR   +- Returns information reguarding data-sets ENQ conflicts for a Job\n+            or User-id. It tells you what data-set(s) the Job or User-id is\n+            waiting on, and how it is waiting (OLD or SHR). It will also tell\n+            what data-set(s) the Job or User-id holds that other Jobs or\n+            User-ids may be waiting on. Once this is known a command such as\n+            TSODSN can be used to see who has the data-set(s) tied up or who\n+            is waiting on it. At this point the FREE or FREE ALL commands can\n+            be used to free it.\n% TSODSN  +- Display for the specified data-set : users, disposition, waiting,\n+            system, must complete / reserve / global / ownership flags.\n% TSOENQ  +- Display data-sets enqueues conflicts.\n% RSVENQ  +- Display resources enqueued RESERVE.\n% PAJPVQ  +- Generalized GRS/ENQ display.\n+  Depress%PF3+or%PF15+to return to the%ENQDIS+panel.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTFC": {"ttr": 28427, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\tH\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T09:48:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |        Edit Macro  \"FC\"         |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to find%pending+Edit line commands.\n%SYNTAX :+   FC or FC F(IRST) or FC N(EXT) or FC P(REV)\n             FC HELP or H to view this tutorial.\n%USE :+      Type%FC+on the COMMAND line.\n%Example :   EDIT -- CURRENT.DATASET(JCL1)                MOVE/COPY IS PENDING\n             COMMAND ===> FC\n+            ************************** TOP OF DATA **************************\n             000001 //JOBEX1   JOB (11112222),'E X A M P L E',\n             000002 //             MSGLEVEL=(1,1),MSGCLASS=X,REGION=1M,\n             000003 //             TIME=(,20),NOTIFY=EXAMPLE\n            %Result :+\n%            EDIT -- CURRENT.DATASET(JCL1)                MOVE/COPY IS PENDING\n             COMMAND ===>\n        ---> C+0043 //STEP4   EXEC PGM=IEBCOPY,TIME=1440\n             000044 //DISPDD    DD SYSOUT=A\n             000045 //COPYDD    DD SYSOUT=A\n)PROC\n  &ZCONT = PAJTFC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTFJCL": {"ttr": 28429, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\tI\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T09:49:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"FIXJCL\"       |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to tidy up JCL (standard columns).\n%SYNTAX :+   FIXJCL (with eventual use of \"C\" range command on line numbers)\n             FIXJCL HELP or H\n%USE :+      Type%FIXJCL+on the COMMAND line.\n             In example, the following JCL statements :\n             000100%//SAMPLE JOB (12341234),'SAMPLE TEST',\n+            000200%//       MSGCLASS=X,REGION=2048K\n+            000300%//TEST EXEC PGM=IEFBR14\n+            000400%//DD1    DD   DSN=USER.DATASET,DISP=OLD\n+            will be changed as follows :\n             000100%//SAMPLE   JOB (12341234),'SAMPLE TEST',\n+            000200%//             MSGCLASS=X,REGION=2048K\n+            000300%//TEST    EXEC PGM=IEFBR14\n+            000400%//DD1       DD DSN=USER.DATASET,DISP=OLD\n+\n                           (continued on next page)\n)PROC\n  &ZCONT = PAJTFJCX\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTFJCX": {"ttr": 28431, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11Y\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:59:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"FIXJCL\"       |\n                      -----------------------------------\n+\n%RANGE USE :+Type%FIXJCL+on the COMMAND line and mark a range of process with\n             the \"C\" range command on the line numbers, as i.e. :\n            %COMMAND ===> FIXJCL\n+            000100 //SAMPLE JOB (12341234),'SAMPLE TEST',\n             000200 //       MSGCLASS=X,REGION=2048K\n       %---> C2+300 //TEST EXEC PGM=IEFBR14\n             000400 //DD1    DD   DSN=USER.DATASET,DISP=OLD\n             000500 //DD2 DD DSN=OTHER.DATASET,DISP=OLD\n             will be changed as follows :\n             000100 //SAMPLE JOB (12341234),'SAMPLE TEST',\n             000200 //       MSGCLASS=X,REGION=2048K\n             000300%//TEST    EXEC PGM=IEFBR14\n+            000400%//DD1       DD DSN=USER.DATASET,DISP=OLD\n+            000500 //DD2 DD DSN=OTHER.DATASET,DISP=OLD\n+\n)PROC\n  &ZUP = PAJTFJCL\n  &ZCONT = PAJTFJCL\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTFLWJ": {"ttr": 28433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x104\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T10:34:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"FLOWJCL\"      |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro allows all the JCL DD statements to be reformatted\n             with one parameter by line.\n%OPERATION :+starting at the top of the data, all DD statements are reformatted\n             by beeing copied one parameter at a time (new lines are inserted\n             into the data to contain all the reformatted DD statements).\n             Anything other than part of a DD statement is left as is.\n%SYNTAX :+      FLOWJCL\n                FLOWJCL HELP or H\n+\n)PROC\n  &ZCONT = PAJTFLWJ\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTGDDM": {"ttr": 28435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x941\\x9f\\x00\\x941\\x9f\\x15F\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-15T00:00:00", "modifydate": "1994-11-15T15:46:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n\u00ac TYPE(TEXT) INTENS(LOW) SKIP(ON)\n\u00a2 TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n{ TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n\u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n~ TYPE(TEXT) COLOR(PINK) SKIP(ON)\n@ TYPE(TEXT) COLOR(YELLOW) HILITE(USCORE) SKIP(ON)\n# TYPE(TEXT) COLOR(RED) HILITE(REVERSE) SKIP(ON)\n)BODY\n#                  `Tutorial# ~GDDM demonstrations# `Tutorial#                 \u00ac\n#  \u00ac                                                                        #  \u00ac\n#  @Available tests :\u00ac                                                      #  \u00ac\n#  \u00ac                                                                        #  \u00ac\n#  \u00a21 -\u00a6LOGO     :{USAF LOGO for the unit\u00ac                                  #  \u00ac\n#  \u00a22 -\u00a6SHUTTLE  :{SPACE SHUTTLE launch\u00ac                                    #  \u00ac\n#  \u00a23 -\u00a6NITEFLT  :{See the SPACE SHUTTLE streak across the night sky\u00ac       #  \u00ac\n#  \u00a24 -\u00a6CODEBUST :{A true BUG BUSTER flag\u00ac                                  #  \u00ac\n#  \u00a25 -\u00a6SABREBAT :{AIR FORCE X-29 airplane\u00ac                                 #  \u00ac\n#  \u00a26 -\u00a6ZOOM     :{Zoom in and look inside the cockpit\u00ac                     #  \u00ac\n#  \u00ac                                                                        #  \u00ac\n#                                                                              \u00ac\n\n\u00acPress\u00a2END KEY\u00acto return to the`GDDM demonstrations\u00acmain panel\n\n)PROC\n  &ZCONT = PAJTGDDM\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTGDG": {"ttr": 28437, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91(\\x8f\\x00\\x91(\\x8f\\t\\x14\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-15T00:00:00", "modifydate": "1991-10-15T09:14:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - Generation Data Group Utility --------------------------------------\n+\n%   1.+This process operates on both%CVOLS+and%VSAM/ICF+catalogs.\n+\n%   2.+With the%D+selection, only when you specifically say%NO+this process\n+     %does not scratch+DISK data-sets as it uncataloges them.\n+\n%   3.+You may use the%Modify+process to%increase+or%reduce+the number of GDG\n+      data-set%entries+to be%kept.+\n+\n%   4. ** WARNING **+As of yet, this process will%not handle+data-sets residing\n+      on%more than 20+(twenty) volumes. So, only the first 20 volumes will be\n+      recataloged. Thus, for security reasons, you should first list the GDG\n+      you are planning to reset.\n+\n+  Depress%PF3+or%PF15+to return to the%GDG Utility+panel.\n+\n)PROC\n  &ZCONT = PAJTGDG\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTGDGM": {"ttr": 28439, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91(?\\x00\\x91(?\\x12#\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-10T00:00:00", "modifydate": "1991-10-10T12:23:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - Generation Data Group Utility --------------------------------------\n+\n%   1.Creation+of a GDG%model+data-set label is equivalent to execution of\n+     the following%JCL+step :\n+             //CREATE EXEC PGM=IEFBR14\n+             //GDGMOD   DD DSN=&TGDGNM,\n+             //            UNIT=DISK,VOLUME=SER=...Index volume...,\n+             //            SPACE=(TRK,(0)),DISP=(NEW,KEEP),\n+             //            DCB=(RECFM=...,BLKSIZE=...,LRECL=...)\n+    %Note :+if you want other attributes, do it yourself using the JCL above\n+            as skeleton.\n+\n%   2.Deletion+of a GDG%model+data-set label is equivalent to execution of\n+     the following%JCL+step :\n+             //DELETE EXEC PGM=IEFBR14\n+             //GDGMOD   DD DSN=&TGDGNM,\n+             //            UNIT=DISK,VOLUME=SER=...Index volume...,\n+             //            DISP=(OLD,DELETE)\n+\n+  Depress%PF3+or%PF15+to return to the%GDG Utility+panel.\n+\n)INIT\n  IF (&GDGPREF = &Z)\n    &TGDGNM = '...GDG prefix...'\n  IF (&GDGPREF \u00ac= &Z)\n    &TGDGNM = &GDGPREF\n)PROC\n  &ZCONT = PAJTGDGM\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTGPAN": {"ttr": 28441, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x113\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:33:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"GETPAN\"       |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to copy an ISPF-panel image in a book\n             text (allowing to get it already cleaned from all statements and\n             fields controls).\n%SYNTAX :+   GETPAN Panel-ID or GETPAN Panel-ID DS-name or GETPAN HELP or H\n             Operands : Panel-ID = the name of the ISPF panel\n                        DS-name = optional ISPF panels data-set name, fully\n                                  qualified (default is EUR1.PANELS.DATA)\n%USE :+      Type%GETPAN Panel-ID+on the COMMAND line, the panel will then be\n             inserted at the top of data. If you desire it somewhere other than\n             the top of data, type%A+(after) or%B+(before) on the line number\n             at the point in the data you want the panel, as i.e. :\n            %COMMAND ===> GETPAN Panel-ID\n        ---> A+0600   Data ...\n             000700   Data ...\n            %Result :+the panel would be inserted after line 600.\n                      Identical process is obtained with :\n       %---> B+0700   Data ...\n)PROC\n  &ZCONT = PAJTGPAN\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTIVK": {"ttr": 28443, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x9f\\x00\\x88\\x15\\x9f\\x12\\x08\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-07T00:00:00", "modifydate": "1988-06-07T12:08:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - INVOKER - Invoke special TSO commands ------------------------------\n+  This function can be used to invoke the following TSO commands :\n%      DIDOCS  +- Simulate an OS console at user TSO tube.\n+                 System auth. : NO - display commands only allowed,\n+                                YES - all commands allowed.\n%      QSP     +- Queue/Spool analyzer.\n+                 Subcommand : any subcommand to be executed when entering.\n+                 When in QSP enter HELP for more details on subcommand syntax.\n%      VSM     +- Virtual Storage monitor.\n+                 When in VSM select what you want monitorize.\n%      PUSE    +- Pageing Utilization (A picture of slots used on each page\n+                 data-set, its name, device and volume, also produced are the\n+                 swap data-sets and number of swap sets allocated.\n%      UNITS   +- Display the unit names in the device name table, and the\n+                 channel-unit-addresses associated with each unit name.\n%      UNIT    +- Display data about physical devices defined in the system.\n+                 It can be used to see information about specified unit names,\n+                 vol=ser or addresses.\n%      POF     +- VTAM secondary program operator.\n+                 When in POF you may enter HELP (or PFK-1) to obtain a list\n+                 of predefined VTAM commands skeletons.\n+  Depress%PF3+or%PF15+to return to the%INVOKER+panel.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTIVK1": {"ttr": 28445, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x91'O\\x00\\x91'O\\x16%\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-01T00:00:00", "modifydate": "1991-10-01T16:25:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - ANALYZE - VSM and RSM analysis jobs --------------------------------\n%VSM+purpose : analyze the entire VSM blocks (all subpools).\n+              Specified storage areas :\n+                  %SQA += System Queue Area\n+                  %CSA += Common Service Area\n+                  %LSQA+= Local System Queue Area\n+                  %PVT += Private (current Address Space)\n+                  %AE  += Allocated Element (current Address Space)\n+              Special test on SQA space (subpool 226) :\n+                  %T=ALL+to getmain/freemain an SQA space\n+                  %T=GET+to getmain only and notify the SQA space\n+                  %T=HHHHHHHH+to freemain only the SQA space getmain'd by a\n+                        previous execution of%T=GET+\n%RSM+purpose : analyze RSM information.\n+              Specified storage areas :\n+                  %VSM += Virtual Storage Map\n+                  %PFTE+= Page Frame Table Entries\n+                  %ESTE+= Extended Storage Table Entries\n+  Depress%PF3+or%PF15+to return to the%ANALYZE+panel.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTJBCD": {"ttr": 28447, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11Y\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:59:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"JOBCARD\"      |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to copy a JOB card from the users ISPF\n             profile. Under ISPF option 0.2, the JOB card(s) at the bottom of\n             the panel will be copied when the%JOBCARD+macro is issued. The\n             JOB card can be updated using the ISPF option 0.2, and it should\n             be changed to reflect a valid JOB card for the user.\n%SYNTAX :+   JOBCARD or JOBCARD HELP or H\n%USE :+      Type%JOBCARD+on the COMMAND line, the JOB card will then be\n             inserted at the top of data. If you desire it somewhere other\n             than the top of data, type A (after) or B (before) on the line\n             number at the point in the data you want the JOB card, as i.e. :\n            %COMMAND ===> JOBCARD\n        ---> A+0600   Data ...\n             000700   Data ...\n            %Result :+the JOB card would be inserted after line 600.\n                      Identical process is obtained with :\n       %---> B+0700   Data ...\n)PROC\n  &ZCONT = PAJTJBCD\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTJCLF": {"ttr": 28449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89 /\\x00\\x89 /\\x11@\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-07-21T00:00:00", "modifydate": "1989-07-21T11:40:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"JCLFLOW\"      |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro allows all the JCL DD statements to be reformatted\n             with one parameter by line.\n%OPERATION :+starting at the top of the data, all DD statements are reformatted\n             by beeing copied one parameter at a time (new lines are inserted\n             into the data to contain all the reformatted DD statements).\n             Anything other than part of a DD statement is left as is.\n%SYNTAX :+   !JCLFLOW\n             !JCLFLOW HELP or H\n+\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTK000": {"ttr": 28674, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3330-1 block sizes table (1 Cyl = 19 Trks) ---------------\n+-----------------------------------------------------------------------------\n+I                          Capacities with keys                             I\n+I---------------------------------------------------------------------------I\n+I Bytes/rec(KL+DL) I   Records per    I Bytes/rec(KL+DL) I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I       2        2      68       1292 I      49       52      54       1026 I\n+I       3        5      67       1273 I      53       57      53       1007 I\n+I       6        8      66       1254 I      58       62      52        988 I\n+I       9       11      65       1235 I      63       67      51        969 I\n+I      12       14      64       1216 I      68       72      50        950 I\n+I      15       17      63       1197 I      73       77      49        931 I\n+I      18       21      62       1178 I      78       83      48        912 I\n+I      22       24      61       1159 I      84       89      47        893 I\n+I      25       28      60       1140 I      90       95      46        874 I\n+I      29       32      59       1121 I      96      101      45        855 I\n+I      33       35      58       1102 I     102      108      44        836 I\n+I      36       39      57       1083 I     109      115      43        817 I\n+I      40       44      56       1064 I     116      122      42        798 I\n+I      45       48      55       1045 I     123      130      41        779 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTK001\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTK001": {"ttr": 28676, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3330-1 block sizes table (1 Cyl = 19 Trks) ---------------\n+-----------------------------------------------------------------------------\n+I                          Capacities with keys                             I\n+I---------------------------------------------------------------------------I\n+I Bytes/rec(KL+DL) I   Records per    I Bytes/rec(KL+DL) I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     131      138      40        760 I     297      315      26        494 I\n+I     139      146      39        741 I     316      335      25        475 I\n+I     147      155      38        722 I     336      357      24        456 I\n+I     156      164      37        703 I     358      381      23        437 I\n+I     165      174      36        684 I     382      407      22        418 I\n+I     175      185      35        665 I     408      435      21        399 I\n+I     186      196      34        646 I     436      467      20        380 I\n+I     197      207      33        627 I     468      501      19        361 I\n+I     208      220      32        608 I     502      540      18        342 I\n+I     221      233      31        589 I     541      583      17        323 I\n+I     234      247      30        570 I     584      631      16        304 I\n+I     248      262      29        551 I     632      686      15        285 I\n+I     263      279      28        532 I     687      749      14        266 I\n+I     280      296      27        513 I     750      821      13        247 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTK002\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTK002": {"ttr": 28678, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3330-1 block sizes table (1 Cyl = 19 Trks) ---------------\n+-----------------------------------------------------------------------------\n+I                          Capacities with keys                             I\n+I---------------------------------------------------------------------------I\n+I Bytes/rec(KL+DL) I   Records per    I Bytes/rec(KL+DL) I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     822      906      12        228 I                                     I\n+I     907     1005      11        209 I                                     I\n+I    1006     1125      10        190 I                                     I\n+I    1126     1271       9        171 I                                     I\n+I    1272     1454       8        152 I                                     I\n+I    1455     1689       7        133 I                                     I\n+I    1690     2003       6        114 I                                     I\n+I    2004     2442       5         95 I                                     I\n+I    2443     3100       4         76 I                                     I\n+I    3101     4197       3         57 I                                     I\n+I    4198     6391       2         38 I                                     I\n+I    6392    12974       1         19 I                                     I\n+I                                     I                                     I\n+I                                     I                                     I\n+-----------------------------------------------------------------------------\n+\n)PROC\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTK010": {"ttr": 28680, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3350 block sizes table (1 Cyl = 30 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                          Capacities with keys                             I\n+I---------------------------------------------------------------------------I\n+I Bytes/rec(KL+DL) I   Records per    I Bytes/rec(KL+DL) I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I       2        4      71       2130 I      65       70      57       1710 I\n+I       5        8      70       2100 I      71       76      56       1680 I\n+I       9       12      69       2070 I      77       83      55       1650 I\n+I      13       16      68       2040 I      84       89      54       1620 I\n+I      17       20      67       2010 I      90       96      53       1590 I\n+I      21       24      66       1980 I      97      103      52       1560 I\n+I      25       29      65       1950 I     104      110      51       1530 I\n+I      30       33      64       1920 I     111      118      50       1500 I\n+I      34       38      63       1890 I     119      125      49       1470 I\n+I      39       43      62       1860 I     126      134      48       1440 I\n+I      44       48      61       1830 I     135      142      47       1410 I\n+I      49       53      60       1800 I     143      151      46       1380 I\n+I      54       59      59       1770 I     152      160      45       1350 I\n+I      60       64      58       1740 I     161      170      44       1320 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTK011\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTK011": {"ttr": 28682, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3350 block sizes table (1 Cyl = 30 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                          Capacities with keys                             I\n+I---------------------------------------------------------------------------I\n+I Bytes/rec(KL+DL) I   Records per    I Bytes/rec(KL+DL) I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     171      180      43       1290 I     375      396      29        870 I\n+I     181      191      42       1260 I     397      420      28        840 I\n+I     192      202      41       1230 I     421      446      27        810 I\n+I     203      214      40       1200 I     447      473      26        780 I\n+I     215      226      39       1170 I     474      503      25        750 I\n+I     227      239      38       1140 I     504      535      24        720 I\n+I     240      253      37       1110 I     536      570      23        690 I\n+I     254      267      36       1080 I     571      608      22        660 I\n+I     268      283      35       1050 I     609      649      21        630 I\n+I     284      299      34       1020 I     650      695      20        600 I\n+I     300      316      33        990 I     696      746      19        570 I\n+I     317      334      32        960 I     747      802      18        540 I\n+I     335      354      31        930 I     803      865      17        510 I\n+I     355      374      30        900 I     866      936      16        480 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTK012\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTK012": {"ttr": 28684, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3350 block sizes table (1 Cyl = 30 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                          Capacities with keys                             I\n+I---------------------------------------------------------------------------I\n+I Bytes/rec(KL+DL) I   Records per    I Bytes/rec(KL+DL) I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     937     1016      15        450 I    9361    18987       1         30 I\n+I    1017     1108      14        420 I                                     I\n+I    1109     1214      13        390 I                                     I\n+I    1215     1337      12        360 I                                     I\n+I    1338     1483      11        330 I                                     I\n+I    1484     1658      10        300 I                                     I\n+I    1659     1872       9        270 I                                     I\n+I    1873     2139       8        240 I                                     I\n+I    2140     2483       7        210 I                                     I\n+I    2484     2942       6        180 I                                     I\n+I    2943     3583       5        150 I                                     I\n+I    3584     4546       4        120 I                                     I\n+I    4547     6151       3         90 I                                     I\n+I    6152     9360       2         60 I                                     I\n+-----------------------------------------------------------------------------\n+\n)PROC\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTK020": {"ttr": 28686, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3380 block sizes table (1 Cyl = 15 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                          Capacities with keys                             I\n+I---------------------------------------------------------------------------I\n+I Bytes/rec(KL+DL) I   Records per    I Bytes/rec(KL+DL) I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I       2       21      62        930 I     438      469      39        585 I\n+I      22       53      59        885 I     470      501      38        570 I\n+I      54       85      57        855 I     502      533      37        555 I\n+I      86      117      55        825 I     534      565      36        540 I\n+I     118      149      53        795 I     566      597      35        525 I\n+I     150      181      51        765 I     598      661      34        510 I\n+I     182      213      49        735 I     662      693      33        495 I\n+I     214      245      48        720 I     694      725      32        480 I\n+I     246      277      46        690 I     726      789      31        465 I\n+I     278      309      45        675 I     790      821      30        450 I\n+I     310      341      44        660 I     822      885      29        435 I\n+I     342      373      42        630 I     886      949      28        420 I\n+I     374      405      41        615 I     950     1013      27        405 I\n+I     406      437      40        600 I    1014     1077      26        390 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTK021\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTK021": {"ttr": 28688, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 3380 block sizes table (1 Cyl = 15 Trks) -----------------\n+-----------------------------------------------------------------------------\n+I                          Capacities with keys                             I\n+I---------------------------------------------------------------------------I\n+I Bytes/rec(KL+DL) I   Records per    I Bytes/rec(KL+DL) I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I    1078     1141      25        375 I    3222     3605      11        165 I\n+I    1142     1237      24        360 I    3606     4021      10        150 I\n+I    1238     1333      23        345 I    4022     4565       9        135 I\n+I    1334     1429      22        330 I    4566     5237       8        120 I\n+I    1430     1525      21        315 I    5238     6101       7        105 I\n+I    1526     1621      20        300 I    6102     7221       6         90 I\n+I    1622     1749      19        285 I    7222     8821       5         75 I\n+I    1750     1909      18        270 I    8822    11221       4         60 I\n+I    1910     2069      17        255 I   11222    15221       3         45 I\n+I    2070     2229      16        240 I   15222    23221       2         30 I\n+I    2230     2421      15        225 I   23222    47221       1         15 I\n+I    2422     2677      14        210 I                                     I\n+I    2678     2933      13        195 I                                     I\n+I    2934     3221      12        180 I                                     I\n+-----------------------------------------------------------------------------\n+\n)PROC\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTK030": {"ttr": 28690, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 2305-2 block sizes table (1 Cyl = 8 Trks) ----------------\n+-----------------------------------------------------------------------------\n+I                          Capacities with keys                             I\n+I---------------------------------------------------------------------------I\n+I Bytes/rec(KL+DL) I   Records per    I Bytes/rec(KL+DL) I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I       2        2      51        408 I     103      112      37        296 I\n+I       3        8      50        400 I     113      123      36        288 I\n+I       9       14      49        392 I     124      135      35        280 I\n+I      15       20      48        384 I     136      148      34        272 I\n+I      21       27      47        376 I     149      161      33        264 I\n+I      28       34      46        368 I     162      175      32        256 I\n+I      35       41      45        360 I     176      190      31        248 I\n+I      42       48      44        352 I     191      206      30        240 I\n+I      49       56      43        344 I     207      223      29        232 I\n+I      57       64      42        336 I     224      241      28        224 I\n+I      65       73      41        328 I     242      261      27        216 I\n+I      74       82      40        320 I     262      282      26        208 I\n+I      83       91      39        312 I     283      305      25        200 I\n+I      92      102      38        304 I     306      330      24        192 I\n+-----------------------------------------------------------------------------\n+                          (continued on next page)\n)PROC\n  &ZCONT = PAJTK031\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTK031": {"ttr": 28692, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x0f\\x00\\x88\\x16\\x0f\\x10$\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-08T00:00:00", "modifydate": "1988-06-08T10:24:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - BLKSIZE - 2305-2 block sizes table (1 Cyl = 8 Trks) ----------------\n+-----------------------------------------------------------------------------\n+I                          Capacities with keys                             I\n+I---------------------------------------------------------------------------I\n+I Bytes/rec(KL+DL) I   Records per    I Bytes/rec(KL+DL) I   Records per    I\n+I Minimum  Maximum I Track   Cylinder I Minimum  Maximum I Track   Cylinder I\n+I------------------I------------------I------------------I------------------I\n+I     331      357      23        184 I    1197     1361       9         72 I\n+I     358      386      22        176 I    1362     1568       8         64 I\n+I     387      418      21        168 I    1569     1833       7         56 I\n+I     419      453      20        160 I    1834     2187       6         48 I\n+I     454      493      19        152 I    2188     2682       5         40 I\n+I     494      536      18        144 I    2683     3425       4         32 I\n+I     537      585      17        136 I    3426     4663       3         24 I\n+I     586      639      16        128 I    4664     7140       2         16 I\n+I     640      701      15        120 I    7141    14569       1          8 I\n+I     702      772      14        112 I                                     I\n+I     773      853      13        104 I                                     I\n+I     854      949      12         96 I                                     I\n+I     950     1061      11         88 I                                     I\n+I    1062     1196      10         80 I                                     I\n+-----------------------------------------------------------------------------\n+\n)PROC\n  &ZUP = PAJTBLK\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTLJ": {"ttr": 28694, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11Y\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:59:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"LJUST\"       |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to left justify text within data\n             line(s).\n%SYNTAX :+   LJUST\n             LJUST HELP or H\n%USE :+      Type%LJUST+on the COMMAND line and mark the range of lines text\n             with the \"C\" range command on the line numbers, as i.e. :\n            %COMMAND ===> LJUST\n        ---> CC+500               ... DATA LINE ...\n             000600               ... DATA LINE ...\n       %---> CC+700               ... DATA LINE ...\n             000800               ... DATA LINE ...\n            %Result :+the text of lines numbered 500, 600 and 700 will be left\n                      justified. Identical process is obtained with :\n       %---> C3+500               ... DATA LINE ...\n)PROC\n  &ZCONT = PAJTLJ\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMOF": {"ttr": 28696, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x9f\\x00\\x88\\x15\\x9f\\x11%\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-07T00:00:00", "modifydate": "1988-06-07T11:25:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - MISCELLANEOUS OPERATORS FACILITIES ---------------------------------\n+  Allows the following facilities :\n%      BRODSCAN+- Analyze Broadcast TSO data-set.\n+                 ISPF Browse output : YES/NO.\n%      BRODUNLD+- Broadcast User'id Messages Unload.\n+                 Select : USERID   - User'id name (no default).\n%      AUTO    +- Automatic Operators commands invoker.\n+                 Option : Input DS - input PO-dsname (fully qualified).\n+                                     Default is \"...OPERATOR.LIBRARY...\".\n+                          Member   - the desired starting member name.\n+                                     No default.\n+  Depress%PF3+or%PF15+to return to the%OPERATOR+panel.\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMVC": {"ttr": 28698, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x7f\\x00\\x94)\\x7f\\x12I\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-24T00:00:00", "modifydate": "1994-10-24T12:49:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     ------------------------------------\n                      |      Edit Macro  \"MOVECOLS\"      |\n                      ------------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to%move columns+within data-lines :\n+\n            %1+- using the \"S\" range command to shift the data text, or\n+\n            %2+- using the \"X\" range command to exchange the data text.\n+\n%SYNTAX :+   MOVECOLS START STOP TO\n                      (start, stop and destination columns numbers)\n             MOVECOLS HELP or H\n+\n                           (continued on next page)\n+\n)PROC\n  &ZCONT = PAJTMVC1\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMVC1": {"ttr": 28700, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x7f\\x00\\x94)\\x7f\\x12I\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-24T00:00:00", "modifydate": "1994-10-24T12:49:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR DEFAULT(%$_)\n)BODY\n%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             $\n$\n%                     ------------------------------------\n                      |      Edit Macro  \"MOVECOLS\"      |\n                      ------------------------------------\n$\n%USES :   1.$First, mark the range of lines containing the columns to be shifted\n             with the \"S\" range command on the line numbers, then type on the\n             COMMAND line%MOVECOLS$with START, STOP and TO operands, as i.e. :\n            %COMMAND ===> MOVECOLS 11 20 31\n            %Before$********************** TOP OF DATA *************************\n            $=COLS> ----+----1----+----2----+----3----+----4----+----5----+-...\n            %SS$001 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEEEEEE...\n            $000002 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEEEEEE...\n            %SS$003 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEEEEEE...\n            %After$*********************** TOP OF DATA *************************\n            $=COLS> ----+----1----+----2----+----3----+----4----+----5----+-...\n            $000001 AAAAAAAAAACCCCCCCCCCDDDDDDDDDDBBBBBBBBBBEEEEEEEEEE...\n            $000002 AAAAAAAAAACCCCCCCCCCDDDDDDDDDDBBBBBBBBBBEEEEEEEEEE...\n            $000003 AAAAAAAAAACCCCCCCCCCDDDDDDDDDDBBBBBBBBBBEEEEEEEEEE...\n$\n                           (continued on next page)\n)PROC\n  &ZUP = PAJTMVC\n  &ZCONT = PAJTMVC2\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMVC2": {"ttr": 28702, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x7f\\x00\\x94)\\x7f\\x12I\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-24T00:00:00", "modifydate": "1994-10-24T12:49:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR DEFAULT(%$_)\n)BODY\n%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             $\n$\n%                     ------------------------------------\n                      |      Edit Macro  \"MOVECOLS\"      |\n                      ------------------------------------\n$\n         %2.$Mark the range of lines containing the columns to be exchanged\n             with the \"X\" range command on the line numbers, then type on the\n             COMMAND line%MOVECOLS$with START, STOP and TO operands, as i.e. :\n            %COMMAND ===> MOVECOLS 11 20 31\n            %Before$********************** TOP OF DATA *************************\n            $=COLS> ----+----1----+----2----+----3----+----4----+----5----+-...\n            %X3$001 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEEEEEE...\n            $000002 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEEEEEE...\n            $000003 AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEEEEEE...\n            %After$*********************** TOP OF DATA *************************\n            $=COLS> ----+----1----+----2----+----3----+----4----+----5----+-...\n            $000001 AAAAAAAAADDDDDDDDDDDCCCCCCCCCCBBBBBBBBBBEEEEEEEEEE...\n            $000002 AAAAAAAAADDDDDDDDDDDCCCCCCCCCCBBBBBBBBBBEEEEEEEEEE...\n            $000003 AAAAAAAAADDDDDDDDDDDCCCCCCCCCCBBBBBBBBBBEEEEEEEEEE...\n)PROC\n  &ZUP = PAJTMVC1\n  &ZCONT = PAJTMVC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMX0": {"ttr": 28704, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16)\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:29:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- M A I L - B O X E S -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n+The%MAIL-BOXES+facility allows you to maintain an online list of news or\n changes communications. This process needs two data-sets :\n\n%  1+- a mail-boxes data-set into which the news or changes communications\n       are stored, and\n\n%  2+- a mail-lists tables data-set into which a summary list of all the\n       news or changes communications, stored in the mail-boxes data-set,\n       is maintained (this table is stored as a member, so this data-set\n       may be used for many mail-boxes data-sets).\n\n%NOTE :+the first time you enter the%MAIL-BOXES+facility, specify the names\n        you want, then further you will be prompted for data-sets allocation.\n\n+Enter%&EPF+to exit the tutorial\n+Hit%ENTER+will go on to the ISPF tutorials panels\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTMX1": {"ttr": 28929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16)\\x00/\\x00/\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:29:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- M A I L - B O X E S -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n+The%MAIL-BOXES+facility allows you to maintain an online list of news or\n changes communications. You can sort the list in various ways, and you can\n get a hardcopy of the list.\n\n The sections listed below will be presented in sequence (hit%ENTER+to go on to\n the next screen) or you may select a particular subject by number :\n\n%  1+- General information about the MAIL-BOXES facility\n%  2+- Adding, Updating mail-boxes on the MAIL-LIST : INPUT and \"U\" commands\n%  3+- Repeating, Deleting mail-boxes on the MAIL-LIST : \"R\" and \"D\" commands\n%  4+- Sorting the MAIL-LIST : the SORT command\n%  5+- Printing the MAIL-LIST : the LST command\n%  6+- Adding, Updating \"mail-box\" entries : MAILBOX and \"M\" commands\n%  7+- Browsing, Printing \"mail-box\" entries : \"B\" and \"L\" commands\n%  8+- Saving the MAIL-LIST and exiting : END, CANCEL, SAVE and STATUS commands\n%  9+- Encryption-Decryption of \"mail-box\" entries data\n\n+Enter%&EPF+to exit the tutorial and return to the MAIL-LIST\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZSEL = TRANS(&ZCMD\n                1,PAJTMX2\n                2,PAJTMX3\n                3,PAJTMX4\n                4,PAJTMX5\n                5,PAJTMX6\n                6,PAJTMX7\n                7,PAJTMX8\n                8,PAJTMX9\n                9,PAJTMX10\n                )\n  &ZTRAIL = .TRAIL\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMX10": {"ttr": 28931, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89$\\x9f\\x00\\x89$\\x9f\\x17&\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-06T00:00:00", "modifydate": "1989-09-06T17:26:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- M A I L - B O X E S -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Encryption-Decryption of \"mail-box\" entries data.+\n\n When creating or updating \"mail-box\" entries (MAILBOX and \"M\" commands), you\n may encrypt the data (see edit macro \"ENCRYPT\") before they are stored (END of\n edit). Then, these \"mail-box\" entries data which have been encrypted at the\n time they have been created or updated, must be decrypted before any browse\n or print operation (\"B\" or \"L\" commands) may be executed. To do it, you must\n also set the data decryption request (on the MAIL-LIST panel) to :\n   %YES+if you have entirely encrypted the text, and you will be prompted to\n      supply your secret key-value(s) for data decryption until you enter a\n      null key-value to signal the end of decryption is reached for the\n      \"mail-box\" entry (entering a null key-value the first time you are\n      prompted is equivalent to say no data decryption),\n or%RANGE+if you have only partially encrypted the text, and you will be set\n      in Edit mode on the \"mail-box\" entry in order to decrypt yourself the\n      \"mail-box\" entry text (macro \"DECRYPT\"), then END the Edit session.\n\n+Enter%&EPF+to exit the tutorial and return to the MAIL-LIST\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMX2": {"ttr": 28933, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16)\\x00'\\x00'\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:29:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- M A I L - B O X E S -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%General Information.+\n\n The MAIL-BOXES facility is used to maintain an online collection of news or\n changes communications.\n\n%Primary+commands : (Entered in COMMAND ===> area at the top of the display)\n  %INPUT   +- Add a new mail-box to the list - Alias :%I+or%IN+or%INP+\n  %SORT    +- Sort the mail-boxes list (table) by one or more of the fields\n  %LST     +- Print the mail-boxes list - Alias :%L+or%LS+\n  %MAILBOX +- Edit mail-box entries - Alias :%MB+or%MAIL+\n  %SAVE    +- Save the mail-boxes list, continue updates\n  %STATUS  +- Current status of work - Alias :%S+or%ST+or%STAT+\n  %CANCEL  +- Exit utility, don't save any changes - Alias :%CAN+\n  %END     +- &EPFN Exit utility, save any changes\n\n%Line-commands :+(Entered in \"action\" area at the left of the desired mail-box)\n  %D+- Delete mail-box     %U+- Update mail-box     %R+- Repeat mail-box\n  %M+- Edit mail-box       %B+- Browse mail-box     %L+- List mail-box\n\n+Enter%&EPF+to exit the tutorial and return to the MAIL-LIST\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n  IF (&EPF \u00ac= 'END')\n    &EPFN = '(Or hit &EPF.)'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMX3": {"ttr": 28935, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16)\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:29:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- M A I L - B O X E S -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Adding, Updating mail-boxes on the MAIL-LIST.+\n\n%Adding a new mail-box.+\n To add a new mail-box to the MAIL-LIST, enter the%INPUT+command in the command\n area at the top of the screen. This will take you to a panel where you may\n enter information about the new mail. Press%ENTER+to return to the MAIL-LIST\n and add the mail to the list. Use the%END+command if you change your mind and\n don't want to add the mail. Enter%INPUT n+to add%n+new mail-boxes, if desired.\n%Updating a mail-box.+\n You can update any of the fields for a mail (e.g. mail, subject, field, author\n or date) by entering%U+in the \"action\" area (at the left margin) for the mail.\n This will take you to a panel showing the current fields values. Overtype any\n that you want to change, then hit%ENTER+to return to MAIL-LIST with the mail's\n information updated. Use the%END+command if you change your mind and don't\n want to update the mail. Enter%Un+to update sequentially the%n+successive\n mail-boxes starting from the one selected by the line-command.\n\n+Enter%&EPF+to exit the tutorial and return to the MAIL-LIST\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMX4": {"ttr": 28937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16)\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:29:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- M A I L - B O X E S -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Repeating, Deleting mail-boxes on the MAIL-LIST.+\n\n%Repeating a mail-box.+\n To add a new mail with the same information as an existing mail, enter%R+in the\n action area for the existing mail (you can then update the mail description\n using the \"U\" line-command). Enter%Rn+to add%n+times an existing mail.\n%Deleting a mail-box.+\n To delete a mail from the list, enter%D+in the action area for the mail. Enter\n%Dn+to delete%n+mails in sequence from an existing mail.\n\n+Enter%&EPF+to exit the tutorial and return to the MAIL-LIST\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMX5": {"ttr": 28939, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16)\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:29:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- M A I L - B O X E S -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Sorting the mail-boxes list.+\n\n To change the sort order of the list, enter the%SORT+command and (optionally)\n the desired sort fields as operands. If you enter no sort fields, MAIL DATE\n FIELD AUTHOR (in that order) will be used. You may enter as many of the sort\n fields as you wish. Note that the current sort order is always shown on the\n MAIL-LIST panel, and is printed in the heading when you print the mail-boxes\n list (LST command).\n Valid sort fields operands are :\n    M, M(D), M(A), MAIL, MAIL(D), MAIL(A)\n    D, D(A), D(D), DATE, DATE(A), DATE(D)\n    F, F(A), F(D), FIELD, FIELD(A), FIELD(D)\n    A, A(A), A(D), AUT, AUT(A), AUT(D), AUTHOR, AUTHOR(A), AUTHOR(D)\n%REMARK :+by default, the sort sequence for MAIL is D (descending order), and\n          for DATE, FIELD and AUTHOR is A (ascending order).\n+Enter%&EPF+to exit the tutorial and return to the MAIL-LIST\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTMX6": {"ttr": 28941, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16)\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:29:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- M A I L - B O X E S -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Printing the mail-boxes list.+\n\n To print the mail-boxes list, enter the%LST+command in the command area at\n the top of the screen. All the information currently contained on mail-boxes\n list will be formatted into a printed report and will be sent for printing.\n\n To specify a destination and (or) a SYSOUT class for the printed output,\n enter the desired destination and (or) SYSOUT class as operand(s) to the\n LST command. For examples : LST A     = class A, destination LOCAL\n                             LST R7    = class A, destination R7\n                             LST X R21 = class X, destination R21\n                             LST R3 A  = class A, destination R3\n By default, the destination is LOCAL and the SYSOUT class is A.\n\n+Enter%&EPF+to exit the tutorial and return to the MAIL-LIST\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTMX7": {"ttr": 28943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16)\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:29:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- M A I L - B O X E S -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Adding and updating \"mail-box\" entries.+\n\n To enter notes or other text pertaining to a mail-box, use the%MAILBOX+\n command or the%M+line-command.\n\n To update (or create) a mail-box entry, enter%M+in the action area of the mail\n with the desired number and hit%ENTER.+You will be taken into EDIT mode on the\n mail-boxes data-set member for the selected mail-box number. Enter changes,\n then hit%&EPF+to resave. Enter%Mn+to update or create sequentially the%n+\n successive mail-box entries starting from the one selected by the line-command.\n\n To edit the mail-boxes data-set using a member selection list, enter the\n %MAILBOX+command in the command area. This will take you to a member selection\n list for the mail-boxes data-set, so you can then select the desired member\n in the usual manner (enter%S+in the action area). Note that you cannot use\n this option if the data-set has no members... you must create one or more\n members using the%M+line-command first (see above).\n\n+Enter%&EPF+to exit the tutorial and return to the MAIL-LIST\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMX8": {"ttr": 28945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16)\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:29:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- M A I L - B O X E S -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Browsing, Printing \"mail-box\" entries.+\n\n%Browse a \"mail-box\" entry.+\n To browse a \"mail-box\" entry, enter%B+in the action area for the mail. Enter\n%Bn+to browse sequentially the%n+successive \"mail-box\" entries starting from\n the one selected by the line-command.\n\n%Printing a \"mail-box\" entry.+\n To print a \"mail-box\" entry, enter%L+in the action area for the mail. Enter\n%Ln+to print sequentially the%n+successive \"mail-box\" entries starting from\n the one selected by the line-command. Verify and set, if you want change it,\n the print output class and destination.\n\n+Enter%&EPF+to exit the tutorial and return to the MAIL-LIST\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTMX9": {"ttr": 28947, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x0f\\x00\\x89\\x17\\x0f\\x16)\\x00&\\x00&\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-19T00:00:00", "modifydate": "1989-06-19T16:29:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- M A I L - B O X E S -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Saving the MAIL-LIST and exiting the utility.+\n\n To exit the MAIL-LIST and resave your changes, enter the%END+command in the\n command area at the top of the screen.\n &EPFN\n\n+To save a copy of the MAIL-LIST and continue the MAIL-LIST update process,\n enter the%SAVE+command in the command area at the top of the screen.\n\n To exit the MAIL-LIST without resaving any changes from this session, enter\n the%CANCEL+command in the command area at the top of the screen.\n+\n%Current status of work.+\n\n To know how and on what you are working, enter the%STATUS+command in the\n command area at the top of the screen.\n\n+Enter%&EPF+to exit the tutorial and return to the MAIL-LIST\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n  IF (&EPF \u00ac= 'END')\n    &EPFN = '(You can use the &EPF key instead of +\n             actually keying the END command)'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTOCP": {"ttr": 28949, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x853\\x9f\\x00\\x853\\x9f\\t@\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-05T00:00:00", "modifydate": "1985-12-05T09:40:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": "%---------------------------  TO command processor  ----------------------------\n%Send a Message:\n+\n%===>_SMST\n\n+\n%to user(s) ===>_UTOT\n+                enter here above the desired User-id(s)\n+\n)INIT\n  .HELP = PAJTTOCP\n  .CURSOR = SMST\n)PROC\n  VER (&SMST,NONBLANK)\n  VER (&UTOT,NONBLANK)\n  &SEL = 'CMD(%PAJCTOCP) '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPAR": {"ttr": 28951, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'O\\x00\\x93'O\\x12\\x08\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-10-01T00:00:00", "modifydate": "1993-10-01T12:08:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                      ---------------------------------\n                       |      Edit Macro  \"PARA\"       |\n                       ---------------------------------\n+\n%FUNCTION  :+This Edit macro is an improved TFLOW, a paragraph reformatter.\n%SYNTAX :+   PARA ...keyword(s)...%(if no keywords specified then prompting)+\n             Use%C+range block commands to define start and end of paragraph.\n%PARA's keyword parameters :+\n% I=nn+define paragraph's first line indentation\n%OL=nn+define old left margin          %OR=nn+define old right margin\n%NL=nn+define new left margin          %NR=nn+define new right margin\n%    D+double space at end of sentence %   ND+none (single space)\n%    J+right margin justification      %   NJ+no justification\n%    C+means centering of paragraph    %   NC+no centering\n%   RH+remove hyphens and rejoin words %   LC+change paragraph to lower case\n% SHAR+store parameters in SHARED pool % PROF+store parameters in your PROFILE\n%    ?+query current parameters values % HELP+display documentation\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPAR0\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTPARA": {"ttr": 28953, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\tR\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T09:52:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ------  Edit Macro PARA Parameters Reference Appendix  ------ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%1. Parameters that PARA remembers during an ISPF session :+\n\n %OL=nn   +Old Left side of the paragraph\n %OR=nn   +Old Right side of the paragraph\n           The Old parameters tell PARA where to find the paragraph to be\n           reformatted. The first time PARA executes during an ISPF session,\n           the Old parameters normally default to the display columns on the\n           left and right sides of the screen. You will only change the Old\n           parameters when :\n            (1) You are editing a document wider than the screen size (i.e.,\n                133 wide for a 3278 model 2, 80 columns wide).\n            (2) Or, when there is textual material that you don't want to\n                include on the left or right side of the paragraph to be\n                reformatted.\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPARB\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPARB": {"ttr": 28955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x10X\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T10:58:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ------  Edit Macro PARA Parameters Reference Appendix  ------ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n           Example :\n                  COMMAND ===>\n                  =COLS> ----+----1----+----2----+----3----+----4----+--\n                  000003 //*  THIS IS A DEMAND DEPOSIT JOB.            *\n                  000004 //*    IT RUNS WEEKLY, EVERY MONDAY, ROLLING  *\n                  000005 //* FORWARD IF MONDAY IS A HOLIDAY.           *\n           In this example, you don't want the //* and the * to be included in\n           your new paragraph, so you code :\n                 %COMMAND ===> PARA OL=4 OR=46 NL=4 NR=45+\n                  =COLS> ----+----1----+----2----+----3----+----4----+--\n            %---> CC+003 //*  THIS IS A DEMAND DEPOSIT JOB.            *\n                  000004 //*    IT RUNS WEEKLY, EVERY MONDAY, ROLLING  *\n            %---> CC+005 //* FORWARD IF MONDAY IS A HOLIDAY.           *\n           to exclude them from the reformatted paragraph. Don't forget to\n           change them back if you switch from JCL to a memorandum.\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPARC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPARC": {"ttr": 29185, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\tR\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T09:52:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ------  Edit Macro PARA Parameters Reference Appendix  ------ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n %NL=nn   +New Left side of the paragraph\n %NR=nn   +New Right side of the paragraph\n           The New parameters tell PARA where to put the reformatted paragraph.\n           The New parameters are the most frequently coded parameters.\n\n %I=nn    +Indent the first line of the paragraph nn spaces (default is 0).\n           The Indent parameter can be either zero (no indenting), positive\n           (Indent nn spaces to the right), or negative (Indent no spaces to\n           the left).\n\n %J       +right margin Justification (default)\n %NJ      +No right margin Justification\n           If J is specified, PARA will insert the necessary number of spaces\n           into each line of the paragraph to right align the right margin.\n           The last line will not be justified.\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPARD\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPARD": {"ttr": 29187, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'O\\x00\\x93'O\\x12\\x08\\x00B\\x00B\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-10-01T00:00:00", "modifydate": "1993-10-01T12:08:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ------  Edit Macro PARA Parameters Reference Appendix  ------ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n %D       +Double space after end of sentence (default)\n %ND      +No Double space after end of sentence\n           The following characters are recognized as end of sentence :\n                &TX1                 %&X1+ (may be changed through\n                &TX2                 %&X2+    the prompting panel)\n                &TX3                 %&X3+%Note :+these characters must never\n                &TX4                 %&X4+        have an hexadecimal value\n                &TX5                 %&X5+        greater than X'7F')\n\n%2. Parameters that PARA will not remember (one time only) :+\n\n %PROF    +store PARA parameters in your PROFile data-set\n %SHAR    +store PARA parameters in the SHARed variable pool (default)\n           If you want your PARA parameters to be remembered from session to\n           session, specify PROF once only. From then on, PARA will store your\n           PARA parameters in your PROFile data-set instead of in the SHARED\n           variable pool. Specify SHAR if you change your mind.\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &TX1 = &Z\n  &X1 = &Z\n  &TX2 = &Z\n  &X2 = &Z\n  &TX3 = &Z\n  &X3 = &Z\n  &TX4 = &Z\n  &X4 = &Z\n  &TX5 = &Z\n  &X5 = &Z\n  IF (&PARAES \u00ac= &Z)\n    &X1 = TRUNC(&PARAES,1)\n    &REST = .TRAIL\n    &TX1 = '. . . end of sentence'\n    IF (&REST \u00ac= &Z)\n      &X2 = TRUNC(&REST,1)\n      &REST = .TRAIL\n      &TX2 = '. . . end of sentence'\n      IF (&REST \u00ac= &Z)\n        &X3 = TRUNC(&REST,1)\n        &REST = .TRAIL\n        &TX3 = '. . . end of sentence'\n        IF (&REST \u00ac= &Z)\n          &X4 = TRUNC(&REST,1)\n          &REST = .TRAIL\n          &TX4 = '. . . end of sentence'\n          IF (&REST \u00ac= &Z)\n            &X5 = TRUNC(&REST,1)\n            &REST = .TRAIL\n            &TX5 = '. . . end of sentence'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPARE\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPARE": {"ttr": 29189, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"O\\x00\\x91\"O\\x11\\x10\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-12T00:00:00", "modifydate": "1991-08-12T11:10:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ------  Edit Macro PARA Parameters Reference Appendix  ------ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n %LC      +change paragraph to Lower Case\n           LC causes UPPER CASE text in the box defined by OL, OR, and the CC\n           line commands to be transformed to lower case letters.\n           Start of sentence words will still be capitalized.\n           Why have this routine ? Two reasons :\n            (1) Suppose under TE (text entry) you typed a lot of upper and lower\n                case text while editing a data-set which had CAPS ON. The text\n                would be converted entirely to UPPER CASE. It is faster to\n                change the entire text to lower case and recapitalize where\n                required than to retype the entire text.\n            (2) Suppose you are modifying old text, all of which is in capitals.\n                You want your revised text in both upper and lower case. It is\n                faster to change the entire text to lower case and recapitalize\n                where required than to retype the entire text.\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPARF\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPARF": {"ttr": 29191, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\tR\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T09:52:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ------  Edit Macro PARA Parameters Reference Appendix  ------ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n %RH      +Remove Hyphens and reconnect words\n           Remove Hyphens means if you have one word split across multiple li-\n           nes with a hyphen (like li- nes in this sentence), the hyphen (-)\n           will be removed and the word will be reconnected into one word (i.e.\n           lines) before reformatting occurs.\n           Why have this routine ? Two reasons :\n            (1) Suppose you made an error previously when you executed PARA,\n                making NL and NR too close together. If PARA finds a word that\n                cannot fit between NL and NR, PARA splits the word into two or\n                more pieces, hyphenating them. Many words might have been split\n                into pieces. This routine makes recovery easy : just execute\n                PARA with the correct NL/NR pair and RH.\n            (2) Suppose you are modifying old text, with many words hyphenated.\n                Your changes will shift the position of the hyphenated words\n                within the paragraph, moving the hyphenated words to the middle\n                of the line. This routine saves a lot of manual unhyphenation\n                time.\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPARG\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPARG": {"ttr": 29193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x17&\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T17:26:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ------  Edit Macro PARA Parameters Reference Appendix  ------ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n %C       +Center paragraph\n %NC      +No Centering of paragraph (default)\n           Centering means center inside the OL/OR boundaries. This allows you\n           to reformat a paragraph, view the results, then center the paragraph\n           inside your document without figuring out any new parameters.\n           Centering does not reformat, since the results after both\n           reformatting and centering may be unexpected.\n\n %?       +What are PARA's current parameters ?\n           If ? is specified, a panel is displayed with the current values of\n           the PARA parameters.\n\n %HELP    +display HELP information\n           If HELP is specified, a panel is displayed which briefly explain the\n           PARA parameters. Then follows full descriptions panels, if desired.\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPAR0\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPAR0": {"ttr": 29195, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x104\\x00*\\x00*\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T10:34:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ---------------------  Edit Macro PARA  --------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n Text processing on TSO has made strides with the introduction of :\n\n                 PPPPPPPPPPP     AAAAA      RRRRRRRRRRR      AAAAA\n                PP        PP   AA   AA     RR        RR    AA   AA\n               PPPPPPPPPPP   AA     AA    RRRRRRRRRRR    AA     AA\n              PP           AAAAAAAAAAA   RR       RR   AAAAAAAAAAA\n             PP           AA        AA  RR        RR  AA        AA\n\n PARA reformats paragraphs more easily. Now you can type a memo using TE (Text\n Enter), and rework it, adding lines, blanking or deleting words and phrases,\n then reformat your paragraphs easily.\n\n+The sections listed below will be presented in sequence (hit%ENTER+to go on to\n the next screen) or you may select a particular subject by number :\n        %1+- PARA parameters (short list)\n        %2+- PARA memorandum (I can hear some questions in your mind)\n        %3+- PARA parameters reference (full description)\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZUP = PAJTPAR\n  &ZSEL = TRANS(&ZCMD\n                1,PAJTPAR1\n                2,PAJTPAR3\n                3,PAJTPARA\n                )\n  &ZTRAIL = .TRAIL\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPAR1": {"ttr": 29197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"O\\x00\\x91\"O\\x11\\x10\\x00%\\x00%\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-12T00:00:00", "modifydate": "1991-08-12T11:10:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ---------------------  Edit Macro PARA  --------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n      ====================================================================\n%                  P A R A G R A P H     R E F O R M A T T E R\n+     ====================================================================\n\n%PARA+is an EDIT macro that reformats text paragraphs. Its operating parameters\n      are specified by keyword=value combinations and/or keywords.\n            Example : PARA OL=13 NL=14 NJ\n      These PARA parameters (keywords) will be remembered throughout a session,\n      no retyping unless you want to change a parameter :\n           %OL=nn+ defines paragraph's old left margin\n           %NL=nn+ defines paragraph's new left margin\n           %OR=nn+ defines paragraph's old right margin\n           %NR=nn+ defines paragraph's new right margin\n           %I=nn + defines paragraph's indentation of first line\n           %D    + means double space at end of sentence\n           %ND   + means no double space at end of sentence (single space)\n           %J    + means right justification of paragraph\n           %NJ   + means no right justification of paragraph\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPAR2\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPAR2": {"ttr": 29199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93&\\x7f\\x00\\x93&\\x7f\\x144\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-24T00:00:00", "modifydate": "1993-09-24T14:34:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ---------------------  Edit Macro PARA  --------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n      ====================================================================\n%                  P A R A G R A P H     R E F O R M A T T E R\n+     ====================================================================\n\n      These PARA parameters are in effect for one execution only :\n           %C    + means centering of paragraph\n           %NC   + means no centering of paragraph\n           %?    + means show parameters values\n           %HELP + means display help information\n           %RH   + means remove word hyphenation\n           %LC   + means change to lower case\n           %PROF + means store PARA parameters in your PROFILE data-set\n           %SHAR + means store PARA parameters in SHARED variable pool\n+\n%New facility :+code%PARA+on the command line and use%\"C\"+range line command(s)\n%==============+only, you will be prompted for all parameters through a panel.\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTPAR3": {"ttr": 29201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"\\x1f\\x00\\x91\"\\x1f\\x16\\x18\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-09T00:00:00", "modifydate": "1991-08-09T16:18:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ---------------------  Edit Macro PARA  --------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%What do you mean by reformat ?+\n%PARA+can change left and right margins, first line indentation, move words from\n line to line to adjust line length, justify the left margin, optionally justify\n the right margin, and double or single space after end of sentences.\n\n     It means that     It means that you  can  create paragraphs side by\n     you       can     side.  These paragraphs are examples.\n     easily create\n     very,   very,        It means that you can indent paragraphs to the\n     very,   very,     right; this paragraph is an example.\n     tall, skinny,\n     slender,          It means that  you  can  indent paragraphs to the\n     willowy,             left.  This paragraph is an example.\n     lean,  narrow\n     paragraphs        You do not have to right justify paragraphs. Or\n     like     this     indent the first line. Or double space after the\n     one.              end of a sentence. This is an example.\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPAR4\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPAR4": {"ttr": 29203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"\\x1f\\x00\\x91\"\\x1f\\x16\\x18\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-09T00:00:00", "modifydate": "1991-08-09T16:18:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ---------------------  Edit Macro PARA  --------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n                              With   some\n                            ingenuity,  you\n                          can          create\n                        paragraphs    in   many\n                      different styles.   You can\n                    create  impact  by  the  visual\n                  appearance  of  your  writing,  and\n                make your  letters  and  memoranda more\n                effective.  True, visual appearance can\n                  never replace the lasting impact of\n                    content,  but  it  can increase\n                      the attention people pay to\n                        your   letters.   After\n                          all,   didn't   you\n                            read this  far?\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPAR5\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPAR5": {"ttr": 29205, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x7f\\x00\\x93'\\x7f\\x114\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-10-04T00:00:00", "modifydate": "1993-10-04T11:34:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ---------------------  Edit Macro PARA  --------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n              You can  even  center  paragraphs after you\n              have   reformatted    them.     Like   this\n                        paragraph, for example.\n\n B                You can reformat   paragraphs\n E     that look like this              paragraph with one command.\n F     This paragraph looks\n O        like some paragraphs I have created when I\n R       was just putting my thoughts down, then went back over the\n E    paragraph and cleaned it up.\n !          SEE!\n\n A      You can reformat paragraphs  that  look like this paragraph with\n F   one command.  This  paragraph  looks  like  some  paragraphs I have\n T   created when I was just  putting  my  thoughts down, then went back\n E   over the paragraph and cleaned it up.  SEE!\n R\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPAR6\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPAR6": {"ttr": 29207, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x7f\\x00\\x93'\\x7f\\x114\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-10-04T00:00:00", "modifydate": "1993-10-04T11:34:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ---------------------  Edit Macro PARA  --------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%What do you mean by easily ?+\n+You tell%PARA+what to do by coding%PARA+on the command line followed by\n keyword=value or keyword combinations, then use%C+range line commands to mark\n the start and end of the paragraph :\n       %COMMAND ===> PARA NL=6 NR=72 I=3 J D\n   ---> CC+068              You can reformat   paragraphs\n        000069   that look like this              paragraph with one command.\n        000070   This paragraph looks\n        000071      like some paragraphs I have created when I\n        000072     was just putting my thoughts down, then went back over the\n        000073  paragraph and cleaned it up.\n  %---> CC+074        SEE!\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZCONT = PAJTPAR7\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPAR7": {"ttr": 29209, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x10X\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T10:58:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial ---------------------  Edit Macro PARA  --------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%PARA+will remember these combinations during the ISPF session, so you only have\n to code any changes the next time you execute PARA.\n       %COMMAND ===> PARA I=0\n   ---> CC+081     You tell PARA what to do by coding PARA\n        000082        on the command line\n  %---> CC+083  followed by keyword=value or keyword combinations,\n%What if I forget these combinations ?+\n+You can ask%PARA+to tell you its current combinations, without doing any\n paragraph reformatting. Example :\n       %COMMAND ===> PARA ?+\n        000081+    You tell PARA what to do by coding PARA\n At this point, a panel is displayed with the current PARA parameters values.\n%What are all these PARA parameters ?+\n+A%PARA+parameters reference appendix is attached.\n+\n+Enter%&EPF+to exit the tutorial and return to the PARA facility\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPDS": {"ttr": 29441, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x91'\\x7f\\x00\\x91'\\x7f\\x126\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-04T00:00:00", "modifydate": "1991-10-04T12:36:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - PDSMATCH - Compare two PDS directories -----------------------------\n+\n% Purpose+: this program compares the directories of two partitioned data-sets\n+           and shows which members match and which members do not match or are\n+           not present in both directories.\n+\n+           Members are said to match if their names are the same, and (if\n+           option USER) if all the other data in their directory entries are\n+           equal (except fields containing TTR track addresses).\n+           Data records for the members are not compared.\n+           Only the information in the directory is compared.\n+\n+           When volume serials are used to indicate two identically named\n+           data-sets on different volumes are being used, unexpected results\n+           can occur unless both are specified.\n+\n+  Depress%ENTER+to go on to the next tutorial panel.\n+  Depress%PF3+or%PF15+to return to the%PDSMATCH+panel.\n+\n)PROC\n  &ZCONT = PAJTPDSL\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPDSL": {"ttr": 29443, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x91'\\x7f\\x00\\x91'\\x7f\\x126\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-04T00:00:00", "modifydate": "1991-10-04T12:36:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - PDSMATCH - Compare two PDS directories -----------------------------\n+\n+ Eventually, supply options :\n+       %USER +- members that are present in both libraries will be compared\n+                for matching USER-DATA (consists of up to 64 bytes of data in\n+                the directory entry which is put there by the linkage editor,\n+                SPF edit, and others).\n+                Note : with USER, if two members have the same name and neither\n+                       has any USER-DATA, they are treated as unequal, with a\n+                       unique message for this case.\n+       %EQO  +- only members that match will be listed.\n+       %NEO  +- (or SHORT) only members that don't match will be listed.\n+        If neither of the above, all members will be listed for both libraries.\n+\n%  Size in K+: set the 2 PDS directories core storage space size to ...K size\n+        (default is 128K). Usefull to avoid an abend S800 if big directories.\n+\n+  Depress%ENTER+to go on to the previous tutorial panel.\n+  Depress%PF3+or%PF15+to return to the%PDSMATCH+panel.\n+\n)PROC\n  &ZUP = PAJTPDS\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTPED": {"ttr": 29445, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x15\\x1f\\x00\\x90\\x15\\x1f\\x08R\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-05-31T00:00:00", "modifydate": "1990-05-31T08:52:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"PEDIT\"       |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro invoke the print of the data you are editing (the\n             current edit file).\n%SYNTAX :+   PEDIT or PEDIT HELP or H\n%USE :+      Type%PEDIT+on the COMMAND line, eventually mark a range of lines\n             with the \"C\" range command on the line numbers, and press ENTER.\n             Immediately, you will be prompted to supply the print options :\n            %Carriage CC+= NO/YES to say if first character is data or CC.\n            %SYSOUT Class+= the class in which output is to be queued for\n                            print. Default is A.\n            %Copies+= the number of copies to be printed. Default is 1.\n            %Output status+= HOLD/NOHOLD to place or not the output on a Hold\n                            Queue upon deallocation. Default is NOHOLD.\n            %RMT destination+= Remote Station to which the output (sysout) is\n                            to be routed (i.e. R41). Default is LOCAL.\n             Then all or only the range of lines you have selected from the\n             current editing file are printed.\n)PROC\n  &ZCONT = PAJTPED\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTPOF": {"ttr": 29447, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90)\\x0f\\x00\\x90)\\x0f\\x16(\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-17T00:00:00", "modifydate": "1990-10-17T16:28:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n@ TYPE(OUTPUT) INTENS(HIGH)\n)BODY\n%Tutorial - POF / VTAM Secondary Program Operator Facility ---------------------\n+\n+  You may type :%?+to display the previous executed command,\n+                %*+to reissue the previous executed command,\n+                %HELP+to display this tutorial, and\n+                %END+to terminate POF execution.\n+\n+  The following predefined VTAM command skeletons are available by entering\n+  the corresponding selective number :\n+  % 1+-@POFVT1             % 2+-@POFVT2             % 3+-@POFVT3             +\n+  % 4+-@POFVT4             % 5+-@POFVT5             % 6+-@POFVT6             +\n+  % 7+-@POFVT7             % 8+-@POFVT8             % 9+-@POFVT9             +\n+  %10+-@POFVT10            %11+-@POFVT11            %12+-@POFVT12            +\n+  This will display the selected skeleton command, allowing you then his\n+                 completion for execution,\n+  or you may enter directly the select number you want, followed by the text\n+                 to complete the skeleton command for execution.\n+\n%  All commands and responses are logged to SYSLOG and your session LOG file.+\n+\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTRJ": {"ttr": 29449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11Y\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:59:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"RJUST\"       |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to right justify text within data\n             line(s).\n%SYNTAX :+   RJUST\n             RJUST HELP or H\n%USE :+      Type%RJUST+on the COMMAND line and mark the range of lines text\n             with the \"C\" range command on the line numbers, as i.e. :\n            %COMMAND ===> RJUST\n        ---> CC+500               ... DATA LINE ...\n             000600               ... DATA LINE ...\n       %---> CC+700               ... DATA LINE ...\n             000800               ... DATA LINE ...\n            %Result :+the text of lines numbered 500, 600 and 700 will be right\n                      justified. Identical process is obtained with :\n       %---> C3+500               ... DATA LINE ...\n)PROC\n  &ZCONT = PAJTRJ\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTRSM": {"ttr": 29451, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x892_\\x00\\x892_\\t\\x03\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-21T00:00:00", "modifydate": "1989-11-21T09:03:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |      Edit Macro  \"RESUME\"       |\n                      -----------------------------------\n+\n%FUNCTION :+This Edit macro allows a user to restore a member edit from the\n            last saved copy. This can be used when you have made a change you\n            did not mean to make.\n%SYNTAX :+  RESUME\n            RESUME HELP or H\n%NOTE :+    Not allowed on PS files (you must do it yourself).\n+\n)PROC\n  &ZCONT = PAJTRSM\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTSEPL": {"ttr": 29453, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11Y\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:59:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"SLINE\"       |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to place a separation line in the data\n             being edited at the point designated by the A or B range command.\n%SYNTAX :+   SLINE or SLINE C=character (if not specified, default is -)\n             SLINE COMMA or CODEC (to use a comma \",\" or the command delimiter\n                                   character, see ISPF option 0.1)\n             SLINE HELP or H\n%USE :+      Type%SLINE+on the COMMAND line and an A or B on the target line\n             number, as i.e. :\n            %COMMAND ===> SLINE\n+            000500   Title : ...\n       %---> A+0600           ...\n             000700   Subtitle : ...\n             000800              ...\n            %Result :+a separation line of \"-\" will be inserted between lines\n                      600 and 700. Identical process is obtained with :\n       %---> B+0700   Subtitle : ...\n)PROC\n  &ZCONT = PAJTSEPL\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTSHW0": {"ttr": 29455, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93#/\\x00\\x93#/\\x100\\x00&\\x00&\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-08-20T00:00:00", "modifydate": "1993-08-20T10:30:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n\u00ac TYPE(TEXT) INTENS(LOW) SKIP(ON)\n\u00a2 TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n{ TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n} TYPE(TEXT) COLOR(RED) SKIP(ON)\n! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n\u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n~ TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n@ TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n? TYPE(TEXT) COLOR(YELLOW) HILITE(REVERSE) SKIP(ON)\n)BODY\n\u00a2TUTORIAL?             `<\u00a6 SHOWMVS Batch, TSO or ISPF `>?             \u00a2TUTORIAL\u00ac\n_Y\u00ac\n~                                                                              \u00ac\n~  \u00ac  \u00a6Purpose :{program/command`SHOWMVS{displays various information about ~  \u00ac\n~  \u00ac          {the\u00a2MVS{system you're running on.`SHOWMVS{can run in Batch   ~  \u00ac\n~  \u00ac          {or as a TSO command and write the output to a\u00a2QSAM{data-set  ~  \u00ac\n~  \u00ac          {instead of displaying the data via the ISPF browse service.  ~  \u00ac\n~  \u00ac  `Options selection :                                                  ~  \u00ac\n~  \u00ac  !1.\u00a6Environment :{just say how to\u00a2execute{SHOWMVS (BATCH = submited   ~  \u00ac\n~  \u00ac          `job{or TSO =`command{or ISPF =`browse{service).              ~  \u00ac\n~  \u00ac  !2.\u00a6CAPS :}ON{to force\u00a2uppercase{output.\u00acDefault is OFF.              ~  \u00ac\n~  \u00ac  !3.\u00a6Page heading :}YES{to have or}NO{to not have the heading at top   ~  \u00ac\n~  \u00ac          {of all pages.\u00acDefault is YES.                                ~  \u00ac\n~  \u00ac  !4.\u00a6Lines per page :{set the desired number.\u00acAcceptable range is 20   ~  \u00ac\n~  \u00ac           up to 200, default is 60.                                    ~  \u00ac\n~  \u00ac  !5.\u00a6Starting page number :{this is the desired initial page count.    ~  \u00ac\n~  \u00ac           Acceptable range is 1-90000, default is 1.                   ~  \u00ac\n~  \u00ac                                               ?(continued on next page)~  \u00ac\n~  @                                                                        ~  \u00ac\n~  \u00acHit\u00a2END key\u00acto exit help.                                               ~  \u00ac\n~                                                                              \u00ac\n\u00ac\n)PROC\n  &ZUP = PAJTSHW0\n  &ZCONT = PAJTSHW1\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTSHW1": {"ttr": 29457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93#/\\x00\\x93#/\\x100\\x00%\\x00%\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-08-20T00:00:00", "modifydate": "1993-08-20T10:30:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n\u00ac TYPE(TEXT) INTENS(LOW) SKIP(ON)\n\u00a2 TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n{ TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n} TYPE(TEXT) COLOR(RED) SKIP(ON)\n# TYPE(TEXT) COLOR(PINK) SKIP(ON)\n\u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n~ TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n@ TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n? TYPE(TEXT) COLOR(YELLOW) HILITE(REVERSE) SKIP(ON)\n)BODY\n\u00a2TUTORIAL?             `<\u00a6 SHOWMVS Batch, TSO or ISPF `>?             \u00a2TUTORIAL\u00ac\n_Y\u00ac\n~                                                                              \u00ac\n~  \u00ac  `Batch Submit -\u00a6JCL option :}SCAN{or}COPY{are the possible\u00a2TYPRUN=... ~  \u00ac\n~  \u00ac          {option to be set in the\u00a2JOB{statement.                       ~  \u00ac\n~  \u00ac  `QSAM output data-set :{normally a}SYSOUT{dynamically allocated.      ~  \u00ac\n~  \u00ac  \u00a6But{you may also drive the output to a\u00a2specific data-set{supplying   ~  \u00ac\n~  \u00ac          {his`fully qualified name{(unquoted). It must be cataloged    ~  \u00ac\n~  \u00ac          {and have\u00a2RECFM=FBA,LRECL=101{characteristics.                ~  \u00ac\n~  \u00ac  \u00a6DISP= :{allows you to rewrite}(OLD){or extent}(MOD){the data-set.    ~  \u00ac\n~  \u00ac          #Note :{you may specify also a\u00a2partitioned data-set member{if ~  \u00ac\n~  \u00ac                 {desired (i.e. :`dsname(member){always unquoted),}but  ~  \u00ac\n~  \u00ac                 {with the exception that in this case}OLD{is forced    ~  \u00ac\n~  \u00ac                 {(a member cannot be extended, only rewritten).        ~  \u00ac\n~  \u00ac  `Typing :\u00a2SHOWMVS{or\u00a2TSO SHOWMVS{in the}Command{line, you execute it  ~  \u00ac\n~  \u00ac         {directly as a`TSO command{(without handling panel values).    ~  \u00ac\n~  \u00ac  \u00a6Operands :{type\u00a2TSO HELP SHOWMVS{for syntax.                         ~  \u00ac\n~  \u00ac  #ISPF EDIT :{use\u00a2!SHOWMVS{in the command line.           ?(final page)~  \u00ac\n~  @                                                                        ~  \u00ac\n~  \u00acHit\u00a2END key\u00acto exit help.                                               ~  \u00ac\n~                                                                              \u00ac\n\u00ac\n)PROC\n  &ZCONT = PAJTSHW0\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTSKC": {"ttr": 29459, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"\\x9f\\x00\\x94\"\\x9f\\x15\\t\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-17T00:00:00", "modifydate": "1994-08-17T15:09:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                       -------------------------------\n                        |    Edit Macro  \"SKELCHK\"    |\n                        -------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to%identify+ISPF skeleton%)SEL+and\n            %)ENDSEL+mismatches. If no mismatches exist, all%)SEL-)ENDSEL+pairs\n             will be matched and identified with a comment in columns 55-71.\n\n%SYNTAX :   +On the COMMAND line type in :%SKELCHK+\n            +or :%SKELCHK H+or%HELP+to view this tutorial.\n\n%AUTHOR :   +Gary FRICKEY (NASPA publication : Technical Support, Volume 6,\n             Number 4, April 1992).\n\n)PROC\n  &ZCONT = PAJTSKC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTSKL": {"ttr": 29461, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x113\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:33:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"SKEL\"        |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro may be used to insert JCL skeletons.\n%SYNTAX :+   SKEL ... or SKEL HELP or H\n             (see at next page for the possible ... operand requests)\n%USE :+      Type%SKEL ...+on the COMMAND line, and the desired JCL skeleton\n             will be inserted at the top of data. If you desire it somewhere\n             other than the top of data, type A (after) or B (before) on the\n             line number at the point in the data you want insert the skeleton,\n             as i.e. :\n            %COMMAND ===> SKEL TA\n        ---> A+0600   Data ...\n             000700   Data ...\n            %Result :+the tape JCL skeleton would be inserted after line 600.\n                      Identical process is obtained with :\n       %---> B+0700   Data ...\n+\n                           (continued on next page)\n)PROC\n  &ZUP = PAJTSKL\n  &ZCONT = PAJTSKL1\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTSKL1": {"ttr": 29463, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\x12A\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T12:41:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"SKEL\"        |\n                      -----------------------------------\n+\n Available%JCL skeletons+:\n\n Operand  insertion of\n -------  ---------------------------------------------------------------------\n %PO     +DD-disk with DSORG=PO\n %PS     +DD-disk with DSORG=PS\n %TA     +DD-tape\n %ASH    +Assembler H step\n %LNK    +Link-Edit step\n %XEQ    +Execution step\n %CPY    +IEBCOPY execution step\n %GEN    +IEBGENER execution step\n\n)PROC\n  &ZUP = PAJTSKL\n  &ZCONT = PAJTSKL\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTSLB": {"ttr": 29465, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x17\\x1f\\x00\\x89\\x17\\x1f\\x125\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-20T00:00:00", "modifydate": "1989-06-20T12:35:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - SLB - Browse/Edit System libraries ---------------------------------\n+  DIAGNOSE - error at :\n+           DISPLAY / CC : 12 - the specified panel, message, or cursor field\n+                               could not be found.\n+                          16 - truncation or translation error in storing\n+                               defined variables.\n+                          20 - severe error.\n+           ISPCDSN / CC :  4 - data-set name contains unmatched quotes.\n+                           8 - data-set name missing between quotes.\n+                          12 - cursor not on a data-set name.\n+                          16 - data-set name too long.\n+                          20 - control block parameter error.\n+           BROWSE  / CC : 12 - zero-length data (empty).\n+                          14 - specified member not found.\n+                          16 - no members in library.\n+                          20 - severe error, unable to continue.\n+           EDIT    / CC : 16 - no members in library.\n+                          20 - severe error, unable to continue.\n+  Depress%PF3+or%PF15+to return to the%SLB+selection panel.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTSM1": {"ttr": 29467, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x16\\x06\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T16:06:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/-  S H O R T    messages  -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n+The%SHORT messages+feature allows you to maintain an online list of short\n messages which inform the other group members on your scheduled work-time.\n\n By selecting, in the calling main panel, a USER-id of a group member, you will\n be browsed to his communication, if any (You may browse yourself also).\n\n By leaving blank, in the calling main panel, the USER-id field, you are entered\n in a special edit mode on your own communication, so you may create or update\n all pertaining information you want notice the other group members.\n\n+Enter%&EPF+to exit the tutorial and return to the SHORT communication\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZUP = PAJTSM1\n  &ZCONT = PAJTSM2\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTSM2": {"ttr": 29469, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x16\\x06\\x00'\\x00'\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T16:06:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/-  S H O R T    messages  -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Special Edit mode.+\n\n%Primary+commands : (Entered in Command ===> area at the top of the display)\n  %CANCEL  +- Exit SHORT communication, don't save any changes - Alias :%CAN+\n  %END     +- &EPFN Exit SHORT communication, save any changes\n  %SAVE    +- Exit SHORT communication, save any changes - Alias :%S+\n  %Note :+the%END+and%SAVE+commands are equivalent, and automatically insert a\n          final line, with the update date, at the end of the communication or\n          just before the STOP line, if any.\n\n%Line+commands : (Entered in \"action\" area at the left of the desired line)\n %A+- Add DATE-line after   %B+- Add DATE-line before  %D+- Delete line(s)\n %I+- Insert blank line(s)  %R+- Repeat line(s)        %S+- Add STOP-line after\n\n%Scroll+commands : (Entered in Command ===> area at the top of the display)\n You may scroll through the communication via the%UP+and%DOWN+commands.\n\n+Enter%&EPF+to exit the tutorial and return to the SHORT communication\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n  IF (&EPF \u00ac= 'END')\n    &EPFN = '(Or hit &EPF.)'\n)PROC\n  &ZUP = PAJTSM1\n  &ZCONT = PAJTSM3\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTSM3": {"ttr": 29471, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x16\\x06\\x00%\\x00%\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T16:06:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/-  S H O R T    messages  -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Line+commands : (Entered in \"action\" area at the left of the desired line)\n\n %A+- Add a nice DATE-line after the line pointed by this command.\n %B+- Add a nice DATE-line before the line pointed by this command.\n      The DATE is that you have set in the line below the Command ===> line.\n %D+- Delete the line pointed by this command. Enter%Dn+to delete%n+lines\n      starting from that pointed by the command.\n %I+- Insert a blank line after the line pointed by this command. Enter%In+to\n      insert%n+blank lines after that pointed by the command.\n %R+- Repeat immediately after the line pointed by this command. Enter%Rn+to\n      repeat%n+times the line pointed by the command.\n %S+- Add the STOP-line after the line pointed by this command. This line may\n      be used to limit the communication display, and thus allows you to\n      prepare some other planned communication in advance.\n\nThe contents of any line may be text edited as you want, then hit ENTER.\n\n+Enter%&EPF+to exit the tutorial and return to the SHORT communication\n+Hit%ENTER+to go on to the first tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZUP = PAJTSM2\n  &ZCONT = PAJTSM1\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTSNK0": {"ttr": 29697, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\tO\\x00\\x92\\tO\\x123\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-04-03T00:00:00", "modifydate": "1992-04-03T12:33:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - SNAKE - A program for TSO 3270 terminals ---------------------------\n%Method :+the player depresses keys to indicate which direction the I should\n          move. Money is gained by moving the I to a location occupied by a $,\n          whereupon another $ will be randomly generated at a vacant location.\n          Getting to \"home\" is achieved by moving the I to the location occupied\n          by the # which does not move during a game. Getting \"eaten\" by the\n          snake occurs when the snake's head moves to the location occupied by\n          the I.\n%Input  : PA+keys - refresh the screen image\n         %PFK  1 / 13+- display%HELP+screen\n         %PFK  3 / 15+-%CANCEL+- end without scoring\n         %PFK  4 / 16+- toggle show-snake-trail switch\n         %PFK  5 / 17+- toggle burst-mode-when-running switch\n         %PFK 12 / 24+-%CANCEL+- end without scoring\n%PFK  7+- move%UP+one location       %PFK 19+- run%UP+until level with money\n%PFK  8+- move%DOWN+one location     %PFK 20+- run%DOWN+until level with money\n%PFK 10+- move%LEFT+one location     %PFK 22+- run%LEFT+until level with money\n%PFK 11+- move%RIGHT+one location    %PFK 23+- run%RIGHT+until level with money\n+                          (continued on next page)\n+Hit%ENTER+to go on to the next tutorial panel.\n+Hit%END KEY+to return to the SNAKE invocation panel\n+\n)PROC\n  &ZUP = PAJTSNK0\n  &ZCONT = PAJTSNK1\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTSNK1": {"ttr": 29699, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\t\\x8f\\x00\\x92\\t\\x8f\\x157\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-04-07T00:00:00", "modifydate": "1992-04-07T15:37:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - SNAKE - A program for TSO 3270 terminals ---------------------------\n+Notes  :+Any other input, or trying to move through an obstruction, is\n          equivalent to standing still while the snake gets a move. Note that\n          running is stopped by an obstruction, but only after failing a move\n          attempt, thus giving the snake an extra move. Any snake trail data\n          present is cleared by a screen image RESHOW/REFRESH.\n          Running can be speeded up by activating BURST MODE. When this is done\n          consecutive running moves are displayed with one TPUT, thus optimizing\n          terminal I/O. However, depending upon the terminal and its controller,\n          each individual move may be invisible and the user will be presented\n          with the final screen image.\n          If file ISPTABL is allocated, then the highest score is kept as user\n          data (PFD STATS, not SPF) of member SNKTAB## (REVIEW will show PFD\n          and SPF STATS) where ## is the number of lines that the screen has.\n          If invoked as HALFSNAK or HS, then only the top half (integer\n          arithmetic) of the screen will be used. Naturally a different\n          scoreboard member will be used. Similarly with QUARTERS and QS.\n          If the terminal's VTAM QUERY bit is ON, then a QUERY will be done to\n          determine if 3270 Extended Data Stream data can be sent.\n+Hit%ENTER+to go on to the first tutorial panel.\n+Hit%END KEY+to return to the SNAKE invocation panel\n+\n)PROC\n  &ZCONT = PAJTSNK0\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTSSF": {"ttr": 29701, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"O\\x00\\x94\"O\\x12I\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-12T00:00:00", "modifydate": "1994-08-12T12:49:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - SUPERC - SUPER SEARCH-FOR Utility ----------------------------------\n%Command ===>_ZCMD                                                             +\n+\n+\n+    The%SUPERC+process allows you to run the%SEARCH-FOR+Utility (ISPF 3.14)\n+    as a Batch job.\n+\n+    Just supply the requested parameters, then press the%END+key to be\n+    prompted for the SEARCH-FOR Utility selections.\n+\n+\n%                      T H A T ' S    A L L    F O L K S\n+\n+               %G O O D    L U C K+   and   %G O O D    B Y E+\n+\n+\n)PROC\n  &ZCONT = ISR314C0\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTSTT1": {"ttr": 29703, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\t)\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T09:29:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"BLOCK\"       |\n                      -----------------------------------\n+\n%FUNCTION :+ This Edit macro may be used to create multiple block characters\n             in your text (Super-Type Text macro).\n%SYNTAX :+   BLOCK T=string of characters to generate after pointed line\n            %Warning :+ If the string of characters must contain any command\n                        delimiter character (special character for command\n                        stacking, see ISPF option 0.1), you must use the next\n                        way of entering the command, otherwise the string will\n                        be truncated at first encountered delimiter character,\n                        and the rest will be handled as another command, which\n                        probably would be invalid.\n             BLOCK or BLOCK T= and string of characters to generate read from\n                                   pointed line\n             BLOCK HELP or H\n\n                           (continued on next page)\n+\n)PROC\n  &ZCONT = PAJTSTT2\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTSTT2": {"ttr": 29705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\t)\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T09:29:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"BLOCK\"       |\n                      -----------------------------------\n+\n%USE :+      Type%BLOCK+on the command line followed by%T=+string of characters\n             that you wish to have in block letters in your text. Then place the\n             cursor on the line where you want the text is to be inserted. The\n             block characters text will be created starting at line after where\n             the cursor is (if it is not within a data line, the first line is\n             assumed as cursor position). An attempt will be made to center the\n             text if only one line of block characters is created. If more than\n             one block-line (requires five data lines) is needed, the starting\n             characters (including spaces) will be on the first indicated block-\n             line, a line is skipped and the next group is created. If more than\n             two block-lines are needed, the next are created after skipping\n             another line, and so on.\n            %Warning :+Remember no command delimiter character in the string.\n\n                           (continued on next page)\n+\n)PROC\n  &ZUP = PAJTSTT1\n  &ZCONT = PAJTSTT3\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTSTT3": {"ttr": 29707, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\t)\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T09:29:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"BLOCK\"       |\n                      -----------------------------------\n+\n%Example :   COMMAND ===> BLOCK T=HI THERE\n+       ****** ***************************** TOP OF DATA ******************...\n        000100 ...\n        000200 ...\n       %Result :+\n        ****** ***************************** TOP OF DATA ******************...\n        000100 ...\n%       000110\n        000120             H   H  III        TTTTT H   H EEEEE RRRR  EEEEE\n        000130             H   H   I           T   H   H E     R   R E\n        000140             HHHHH   I           T   HHHHH EEEE  RRRR  EEEE\n        000150             H   H   I           T   H   H E     R  R  E\n        000160             H   H  III          T   H   H EEEEE R   R EEEEE\n+       000200 ...\n                           (continued on next page)\n+\n)PROC\n  &ZUP = PAJTSTT2\n  &ZCONT = PAJTSTT4\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTSTT4": {"ttr": 29709, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\t0\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T09:30:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"BLOCK\"       |\n                      -----------------------------------\n+\n             To enter a string of characters containing any command delimiter\n             character(s) or to type very long strings, as many as you can get\n             on a line of data, enter the string of characters on a data line\n             within the text. Type%BLOCK+on the command line, move the cursor\n             to the line with the string typed on it, and press enter.\n             The entire line pointed by the cursor will be read, all leading\n             blanks eliminated, and then used as string of characters.\n             Spacing is up to you, thus you must plan your text so that it\n             appears the way you want it.\n             The line with the string of characters text is preserved.\n+\n%Example :   COMMAND ===> BLOCK\n+       002000 ...\n        002100%ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+\n        002200 ...     (The cursor can be placed anywhere on the line above)\n+\n)PROC\n  &ZUP = PAJTSTT3\n  &ZCONT = PAJTSTT1\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTTOCP": {"ttr": 29711, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15\\x9f\\x00\\x88\\x15\\x9f\\x12\\x08\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-07T00:00:00", "modifydate": "1988-06-07T12:08:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - TO command processor -----------------------------------------------\n+  The TO command processor option sends a message to a user at another\n+        terminal. It differs from the SEND command in that the text of the\n+        message is not in quotes, so you don't have to think about doubling\n+        quotes contained in your text. Also, this processor cannot put a\n+        message in the broadcast mail. One or more User-id's, to whom the\n+        message is to be sent, may be specified.\n+        You may enter a long message that wraps to the next line.\n+  Depress%PF3+or%PF15+to return to the%TO command processor+panel.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTTRAP": {"ttr": 29713, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x113\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:33:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial --------------------------  EDIT  --------------------------- Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                     -----------------------------------\n                      |       Edit Macro  \"TRAP\"        |\n                      -----------------------------------\n+\n%FUNCTION  :+This Edit macro will put the output from a TSO command that uses\n             PUTLINE macros into the current edit file.\n%SYNTAX :+   TRAP command or TRAP 'command ...' or TRAP HELP or H\n%USE :+      Type%TRAP command+on the COMMAND line, the output will then be\n             inserted at the top of data. If you desire it somewhere other than\n             the top of data, type%A+(after) or%B+(before) on the line number\n             at the point in the data you want the command output, as i.e. :\n            %COMMAND ===> TRAP LISTA\n                 ---> A+0600   Data ...\n                      000700   Data ...\n            %Result :+000600   Data ...\n                     %==MSG> OUTPUT FROM : LISTA\n                     +000610   ... output would be inserted here ...\n            %Identical process is obtained with :\n                 ---> B+0700   Data ...\n)PROC\n  &ZCONT = PAJTTRAP\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTVP00": {"ttr": 29715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x123\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T12:33:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n } TYPE(TEXT) COLOR(RED) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n | TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n)BODY\n\u00a2                           % VIEW EDIT PROFILES \u00a2                             +\n+\n+\n|                                                                              +\n|  +                                                                        |  +\n|  + - - - - - - - - - - -}   G O O D    L U C K   +- - - - - - - - - - - - |  +\n|  +                                                                        |  +\n|  `Purpose :{view all kinds of`profile types{defined in an EDIT profile    |  +\n|  +         {member for a specific\u00a6APPLID{in a desired}ISPF\u00a6USERID{(TSO)   |  +\n|  +         {data-set.                                                     |  +\n|  +         {A profile type, selectable by name, can be viewed during an   |  +\n|  +         }ISPF Edit session{using the following!Edit command{:          |  +\n|  +         %     PROFILE name                                             |  +\n|  +         {and then modified by various!Edit commands{as :               |  +\n|  +         %     CAPS ON/OFF{or%NULLS ON/OFF STD/ALL{or ...               |  +\n|  +         {or by use of the%EDMODE!Edit macro{(verify/set Edit modes).   |  +\n|  `Commands at disposal :{APPLID, DELETE, TABLE and TRACE ON/OFF.          |  +\n|  +                                                                        |  +\n|  + - - - - - - - - - - -}   G O O D    L U C K   +- - - - - - - - - - - - |  +\n|  +                                                                        |  +\n|                                                                              +\n+\n)PROC\n  &ZCONT = PAJTVP00\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTVP01": {"ttr": 29717, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x123\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T12:33:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n } TYPE(TEXT) COLOR(RED) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n | TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n)BODY\n\u00a2                           % VIEW EDIT PROFILES \u00a2                             +\n+\n+\n|                                                                              +\n|  +                                                                        |  +\n|  `Print the viewed Edit profiles list :                                   |  +\n|  {  To print the viewed Edit profiles list, enter the\u00a6PLIST{command in    |  +\n|  {       the command area at the top of the screen. All the information   |  +\n|  {       currently contained on the viewed list will be formatted into    |  +\n|  {       a printed report and will be sent for printing.                  |  +\n|  `  Aliases :%PL, PLS{and%PLST{are at your disposal.                      |  +\n|  {  To specify a!destination{and (or) a!SYSOUT class{for the printed      |  +\n|  {       output, enter the desired!destination{and (or)!SYSOUT class      |  +\n|  {       as\u00a6operand(s){to the\u00a6PLIST{command.                              |  +\n|  }       I.e. :%PLS A    {= class A, destination LOCAL                    |  +\n|  {             %PLS R7   {= class A, destination R7                       |  +\n|  {             %PLS X R21{= class X, destination R21                      |  +\n|  {             %PLS R3 A {= class A, destination R3                       |  +\n|  `  By default,{the!destination{is}LOCAL{and the!SYSOUT class{is}A.       |  +\n|  +                                                                        |  +\n|                                                                              +\n+\n)PROC\n  &ZCONT = PAJTVP01\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTVP02": {"ttr": 29719, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x123\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T12:33:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n } TYPE(TEXT) COLOR(RED) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n | TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n)BODY\n\u00a2                           % TRACE EDIT PROFILES \u00a2                            +\n+\n+\n|                                                                              +\n|  +                                                                        |  +\n|  `Print the traced Edit profiles list :                                   |  +\n|  {  To print the traced Edit profiles list, enter the\u00a6PLIST{command in    |  +\n|  {       the command area at the top of the screen. All the information   |  +\n|  {       currently contained on the traced list will be formatted into    |  +\n|  {       a printed report and will be sent for printing.                  |  +\n|  `  Aliases :%PL, PLS{and%PLST{are at your disposal.                      |  +\n|  {  To specify a!destination{and (or) a!SYSOUT class{for the printed      |  +\n|  {       output, enter the desired!destination{and (or)!SYSOUT class      |  +\n|  {       as\u00a6operand(s){to the\u00a6PLIST{command.                              |  +\n|  }       I.e. :%PLS A    {= class A, destination LOCAL                    |  +\n|  {             %PLS R7   {= class A, destination R7                       |  +\n|  {             %PLS X R21{= class X, destination R21                      |  +\n|  {             %PLS R3 A {= class A, destination R3                       |  +\n|  `  By default,{the!destination{is}LOCAL{and the!SYSOUT class{is}A.       |  +\n|  +                                                                        |  +\n|                                                                              +\n+\n)PROC\n  &ZCONT = PAJTVP02\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTVP03": {"ttr": 29721, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x123\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T12:33:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n } TYPE(TEXT) COLOR(RED) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n | TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n)BODY\n\u00a2                       % EDIT PROFILES TABLE ANALYSIS \u00a2                       +\n+\n+\n|                                                                              +\n|  +                                                                        |  +\n|  `Print the Edit profiles table analysis :                                |  +\n|  {  To print the Edit profiles table analysis, enter the\u00a6PLIST{command in |  +\n|  {       the command area at the top of the screen. All the information   |  +\n|  {       currently contained on the analysis list will be formatted into  |  +\n|  {       a printed report and will be sent for printing.                  |  +\n|  `  Aliases :%PL, PLS{and%PLST{are at your disposal.                      |  +\n|  {  To specify a!destination{and (or) a!SYSOUT class{for the printed      |  +\n|  {       output, enter the desired!destination{and (or)!SYSOUT class      |  +\n|  {       as\u00a6operand(s){to the\u00a6PLIST{command.                              |  +\n|  }       I.e. :%PLS A    {= class A, destination LOCAL                    |  +\n|  {             %PLS R7   {= class A, destination R7                       |  +\n|  {             %PLS X R21{= class X, destination R21                      |  +\n|  {             %PLS R3 A {= class A, destination R3                       |  +\n|  `  By default,{the!destination{is}LOCAL{and the!SYSOUT class{is}A.       |  +\n|  +                                                                        |  +\n|                                                                              +\n+\n)PROC\n  &ZCONT = PAJTVP03\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTVP10": {"ttr": 29723, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x123\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T12:33:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n } TYPE(TEXT) COLOR(RED) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n | TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n)BODY\n\u00a2                           % VIEW EDIT PROFILES \u00a2                             +\n+\n+\n|                                                                              +\n|  +                                                                        |  +\n|  `Purpose :{collect all!APPLIDs names{existing in the requested data-set  |  +\n|  +         {and allow to do a selection for viewing the EDIT profile.     |  +\n|  +                                                                        |  +\n|  `How to do a selection :{enter in front of the line where is located     |  +\n|  +         {your desired!APPLID name{type his corresponding\u00a6position      |  +\n|  +         \u00a6number (1-8){and then press the\u00a6ENTER{key.                    |  +\n|  +         %This APPLIDs names list remains active until :                |  +\n|  +         }1){you specify`another data-set{name, or                      |  +\n|  +         }2){you force his deletion by pressing the`PF-3{key.           |  +\n|  +                                                                        |  +\n|                                                                              +\n+\n)PROC\n  &ZCONT = PAJTVP10\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTVP20": {"ttr": 29725, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07/\\x00\\x95\\x07/\\x159\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-13T00:00:00", "modifydate": "1995-03-13T15:39:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n } TYPE(TEXT) COLOR(RED) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n | TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n)BODY\n\u00a2                          % DELETE EDIT PROFILES \u00a2                            +\n+\n+\n|                                                                              +\n|  +                                                                        |  +\n|  `Purpose :}delete{one or more\u00a6type(s){in an!APPLID EDIT profile.         |  +\n|  +                                                                        |  +\n|  `How to do deletion:{enter\u00a6S{in the action area for the!APPLID name type |  +\n|  +         {you want delete. Enter\u00a6Sn{to delete the%n!types{in sequence.  |  +\n|  +                                                                        |  +\n|  `To exit{the DELETE process and}save{your changes, enter the\u00a6END{command |  +\n|  +         {in the command area at the top of the screen.                 |  +\n|  +         {You can use the\u00a6PF-3{key instead of typing the%END{command.   |  +\n|  +                                                                        |  +\n|  `To exit{the DELETE process}without saving{any changes, enter the\u00a6CANCEL |  +\n|  +         {command in the command area at the top of the screen.         |  +\n|  +                                                                        |  +\n|                                                                              +\n+\n)PROC\n  &ZCONT = PAJTVP20\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTVP21": {"ttr": 29727, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07?\\x00\\x95\\x07?\\t\\t\\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-14T00:00:00", "modifydate": "1995-03-14T09:09:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n } TYPE(TEXT) COLOR(RED) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n | TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n)BODY\n\u00a2                          % DELETE EDIT PROFILES \u00a2                            +\n+\n+\n|                                                                              +\n|  +                                                                        |  +\n|  `Purpose :!CONFIRM{the}replacement{of the original!APPLID EDIT profile   |  +\n|  +         {in the\u00a6original data-set{(last chance to not destroy it).     |  +\n|  +                                                                        |  +\n|  `To exit{and}REPLACE{the!APPLID EDIT profile{enter%YES{and, if you want  |  +\n|  +         {then}COMPRESS{enter%YES{again, then press the%ENTER{key.      |  +\n|  +         {You}cannot{do COMPRESS without REPLACE.                       |  +\n|  +                                                                        |  +\n|  `To exit{and}not REPLACE{the!APPLID EDIT profile,{just enter the\u00a6END{or  |  +\n|  +         \u00a6CANCEL{command in the command area at the top of the screen,  |  +\n|  +         {(even if you have entered%YES{also).                          |  +\n|  +         {You can use the\u00a6PF-3{key instead of typing the%END{command.   |  +\n|  +                                                                        |  +\n|                                                                              +\n+\n)PROC\n  &ZCONT = PAJTVP20\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTVQ1": {"ttr": 29954, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90$\\x7f\\x00\\x90$\\x7f\\x15P\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-09-04T00:00:00", "modifydate": "1990-09-04T15:50:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "%TUTORIAL -------------------  GRS / ENQ DISPLAY  --------------------- TUTORIAL\n%OPTION ===>_ZCMD                                                              +\n+\n%                     ----------------------------------\n                      |        GRS / ENQ DISPLAY       |\n                      ----------------------------------\n+\n The%GRS / ENQ DISPLAY+dialog may be used to display current operating system\n ENQ information. If the%ENTER+key is pressed without any fields being\n specified, then only%ENQ contention+will be displayed. Otherwise, the dialog\n will display ENQ information for any combination of JOBNAME, MAJOR resource\n name, or MINOR resource name.\n\n+        Hit%ENTER+key to view a list of primary%MAJOR+resource names and\n                          their meanings.\n+        Hit%END+key to return to the%GRS / ENQ DISPLAY+ dialog panel.\n\n)INIT\n  &ZCMD = &Z\n)PROC\n  IF (&ZCMD \u00ac= ' ') .MSG = ISPZ001\n  &ZCONT = PAJTVQ11\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTVQ11": {"ttr": 29956, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90$\\x7f\\x00\\x90$\\x7f\\x15P\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-09-04T00:00:00", "modifydate": "1990-09-04T15:50:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SYSPAJA"}, "text": "%TUTORIAL -------------------  GRS / ENQ DISPLAY  --------------------- TUTORIAL\n%OPTION ===>_ZCMD                                                              +\n+\n%MAJOR+name  Resource / Meaning\n ----------  ------------------\n% SYSDSN    +Data-sets - used by allocation to serialize based on DISP.\n% SYSIEA01  +Dump data-set.\n% SYSIEFSD  +System device allocation.\n% SYSIGGV1  +Master catalog.\n% SYSIGGV2  +Catalog.\n% SYSIKJBC  +TSO broadcast data-set.\n% SYSIKJUA  +User attribute data-set and TSO users.\n% SYSIEWLP  +Linkage editor SYSLMOD data-set.\n% SYSSMF01  +SYS1.MANnn data-set.\n% SYSVSAM   +VSAM data-set.\n% SYSVTOC   +VTOC of a DASD volume.\n% SYSZOPEN  +System data-sets.\n% SYSZVOLS  +System volumes.\n% SYSZWTOR  +WTOR reply.\n\n For further information, see OS/VS2 System Programming Library : Debugging\n Handbook Volume 1, Section 5, \"ENQ/DEQ Summary\".\n\n)INIT\n  &ZCMD = &Z\n)PROC\n  IF (&ZCMD \u00ac= ' ') .MSG = ISPZ001\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTVQ2": {"ttr": 29958, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90$\\x7f\\x00\\x90$\\x7f\\x15P\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-09-04T00:00:00", "modifydate": "1990-09-04T15:50:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%TUTORIAL -------------------  GRS / ENQ DISPLAY  --------------------- TUTORIAL\n%OPTION ===>_ZCMD                                                              +\n+\n The previous panel displayed the ENQ information you requested. The first line\n below the command line displayed the nature of the request :\n\n &T1                                                                           +\n\n This was followed by column headings and their corresponding data :\n\n%TYPE  +- the type of ENQ : SHR means the resource is to be shared, EXCL means\n          the resource is to be owned exclusively by the owner.\n%STATUS+- the status of the ENQ request : OWNER means the request has been\n          satisfied, WAITING means the requestor is waiting for the resource.\n%SCOPE +- the scope of the ENQ request : SYSTEM requests are only for the SYSTEM\n          on which the requestor is running, SYSTEMS are for all systems in the\n          GRS configuration.\n%MAJOR +- the major name of the resource (e.g., for a data-set ENQ, \"SYSDSN\").\n%MINOR +- the minor name of the resource (e.g., for a data-set ENQ, the data-set\n          name).\n\n)INIT\n  &ZCMD = &Z\n)PROC\n  IF (&ZCMD \u00ac= ' ') .MSG = ISPZ001\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTWRM0": {"ttr": 29960, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\t\\x8f\\x00\\x92\\t\\x8f\\x15\"\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-04-07T00:00:00", "modifydate": "1992-04-07T15:22:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - WORM - A program for TSO 3270 terminals ----------------------------\n%Method :+once the WORM is moving ten (10) TGETs are done one-tenth of a second\n          apart. If no input is received the WORM is moved one location in the\n          current direction. When WORMomatic is active, only one (1) TGET is\n          done when in burst mode, or two (2) TGETs one-tenth of a second apart\n          otherwise. The current meaning of PF1 (displayed in the title line)\n          and the move speed indicate the current AUTOMATIC/MANUAL/BURST mode\n          status.\n          An optional operand of one or two decimal digits may be supplied to\n          specifies a target upper limit to TASK-TYPE CPU time consumption by\n          WORMomatic expressed in terms of percentage of elapsed time. The\n          default of zero means that WORMomatic will not try to limit its CPU\n          service absorption rate.\n+                          (continued on next page)\n+Hit%ENTER+to go on to the next tutorial panel.\n+Hit%END KEY+to return to the WORM invocation panel\n+\n)PROC\n  &ZUP = PAJTWRM0\n  &ZCONT = PAJTWRM1\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTWRM1": {"ttr": 29962, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\t\\x8f\\x00\\x92\\t\\x8f\\x15S\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-04-07T00:00:00", "modifydate": "1992-04-07T15:53:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - WORM - A program for TSO 3270 terminals ----------------------------\n%Input  : PA+keys - refresh the screen image\n         %PF 1/13+- WORMomatic - Automatic WORM pilot speed\n         %PF 2/14+- ACTIVATE/DEACTIVATE DEBUG mode when burst mode switch is on\n                        (*NOW DISABLED*) or\n                    ACTIVATE/DEACTIVATE REVERSE VIDEO mode when burst mode\n                        switch is off (*IGNORE*)\n         %PF 3/15+-%END+- end with scoring\n         %PF 4/16+- toggle graphic \"character sets\"\n         %PF 5/17+- ACTIVATE/DEACTIVATE \"burst\" mode\n         %PF 6/18+- ACTIVATE/DEACTIVATE graphic character mode\n         %PF 7/19+- change the current direction to%UP+and make a move\n         %PF 8/20+- change the current direction to%DOWN+and make a move\n         %PF 9/21+- move unconditionally (unless a number is encountered) eight\n                        (8) locations in the current direction\n         %PF10/22+- change the current direction to%RIGHT+and make a move\n         %PF11/23+- change the current direction to%LEFT+and make a move\n         %PF12/24+-%CANCEL+- end without scoring\n+                          (continued on next page)\n+Hit%ENTER+to go on to the next tutorial panel.\n+Hit%END KEY+to return to the WORM invocation panel\n+\n)PROC\n  &ZCONT = PAJTWRM2\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTWRM2": {"ttr": 29964, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\t\\x8f\\x00\\x92\\t\\x8f\\x167\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-04-07T00:00:00", "modifydate": "1992-04-07T16:37:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - WORM - A program for TSO 3270 terminals ----------------------------\n+        %ENTER+causes a move in the current direction to be made immediately.\n         %PA+keys and%PF+keys 1/13, 2/14, 4/16, 5/17 and 6/18 are the only ones\n          which will not stop WORMomatic while it is ACTIVE.\n         %ATTENTION+interrupt%(PA1)+stops WORMomatic.\n%Notes  :+If the terminal's VTAM QUERY bit is on then arrows are used for the\n          WORM instead of lower case O's (this also means UNWINDING information\n          is available to the player), the @ for the head is repalced by a Blob,\n          and the target number will be displayed in reverse video. An alternate\n          graphic display mode is available which shows the WORM as a continuous\n          line and the head as a block. Line mode is simulated in non-graphic\n          mode with dashes, etc... The initial WORM is white, but each WORM food\n          target is artificially coloured at random. No preservatives added. The\n          WORM will gradually take on the colour of the most recently consumed\n          food. No two consecutive food targets will have the same colour.\n          7-colour displays are only transmitted in \"graphic\" mode. PF6/18 is\n          available to ACTIVATE/DEACTIVATE \"graphic\" mode, which is initially\n          on only if the VTAM QUERY bit for the TSO terminal is on and the\n          QUERY indicated 7-colour support.\n+                          (continued on next page)\n+Hit%ENTER+to go on to the next tutorial panel.\n+Hit%END KEY+to return to the WORM invocation panel\n+\n)PROC\n  &ZCONT = PAJTWRM3\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTWRM3": {"ttr": 29966, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\t\\x8f\\x00\\x92\\t\\x8f\\x168\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-04-07T00:00:00", "modifydate": "1992-04-07T16:38:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - WORM - A program for TSO 3270 terminals ----------------------------\n+         If the QUERY does'nt indicate Graphics Escape support then APL/graphic\n          characters will not be used even if seven colours are.\n          Terminal I/O can be speeded up with the use of \"burst\" mode. Instead\n          of one TPUT per move a data stream of over 3K can be accumulated and\n          sent in one TPUT. Eating a number also triggers a TPUT. \"Burst\" mode\n          is only used in automatic mode.\n          If file ISPTABL is allocated then the highest score is kept as user\n          data (PFD STATS, not SPF) of member EWSBTA## (REVIEW will show PFD\n          and SPF STATS) where ## is the number of lines that the screen has.\n          If invoked as HALFWORM or HW, then only the top half (integer\n          arithmetic) of the screen will be used. Naturally a different\n          scoreboard member will be used. Similarly with QUARTERW and QW.\n+\n+Hit%ENTER+to go on to the first tutorial panel.\n+Hit%END KEY+to return to the WORM invocation panel\n+\n)PROC\n  &ZCONT = PAJTWRM0\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJTXIL": {"ttr": 29968, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x15\\x7f\\x00\\x92\\x15\\x7f\\x14S\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-05T00:00:00", "modifydate": "1992-06-05T14:53:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n{ TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n} TYPE(TEXT) COLOR(RED) SKIP(ON)\n! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n\u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n~ TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n@ TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n? TYPE(TEXT) COLOR(YELLOW) HILITE(REVERSE) SKIP(ON)\n)BODY\n%TUTORIAL`-----------------<\u00a6 IMS log data-set(s) `>------------------%TUTORIAL+\n+\n+\n~                                                                              +\n~  \u00a6Assuming the following abbreviations :+                                 ~  +\n~  `D+= a specific day     `F+= a start days range  `T+= an end days range  ~  +\n~  `M+= a specific month   `Y+= a specific year                             ~  +\n~  @                                                                        ~  +\n~  !Now, showed below, some how to process :+                               ~  +\n~  }1.{yesterday :+leave%D F T M Y+all blank.                               ~  +\n~  }2.{a complete month :+leave%D F T+blank, fill%M+only for a month in the ~  +\n~  +           current year, or fill also%Y+for a previous year. When it is ~  +\n~  +           the current month, may be the last day is yesterday.         ~  +\n~  }3.{a specific day :+fill%D+and eventually%M Y+as you want (see 2).      ~  +\n~  }4.{a range of days :+fill%F+only to get range from that date until the  ~  +\n~  +           end of the month, or fill%F T+to specify a start-end range   ~  +\n~  +           of days, and eventually%M Y+as you want (see 2).             ~  +\n~  ?                                                                        ~  +\n~  +Then hit%ENTER+to proceed and do the requested processing.              ~  +\n~  +  or hit%END+to terminate (bypass any processing).                      ~  +\n~                                                                              +\n+\n)PROC\n  &ZUP = PAJTXIL\n  &ZCONT = PAJTXIL\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTZAP": {"ttr": 29970, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88#\\x0f\\x00\\x88#\\x0f\\x153\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-08-17T00:00:00", "modifydate": "1988-08-17T15:33:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - ZAP - Full Screen ZAP command --------------------------------------\n+  The ZAP command may be used to examine, dump, and modify any type of\n+  sequential, partitioned, or direct access data-set (ISAM excluded).\n+  Any RECFM is accepted. This command is the TSO interactive\n+  equivalent of IBM's service aid 'IMASPZAP' or 'SUPERZAP'.\n+  To access a volume VTOC, set VTOC=YES, and give as reference a data-set\n+  residing on that volume, or leave unfilled all fields unless the PROJECT\n+  (your User-ID) and the Volume Serial (desired volume).\n+  Subcommands:\n+    VERBOSE, NOT3270, YES3270, WHATMEM, LASTDS1, EBCDIC, ITRACE,\n+    DISASM, LINE80, LINE40, NODEF, ASCII, FLOAT, ZCODE, WHERE, TERSE,\n+    EJECT, DUMPF, DUMPT, NOZAP, DISPC, DISPK, DISPD, BASE, DUMP, NOTE\n+    LAST, HELP, NAME, IDEF, SAVE, ZSYM, ASM, CRT, LOG, ZAP, SSL, END,\n+    SET, ABS, NN, DO, L, S, O, X, N, F, >, <, M, E, B, D, V, T, R, P,\n+    U, =, ?, H, #, W, ...etc...\n+  When in ZAP enter HELP for more details on subcommand syntax.\n+  Depress%PF3+or%PF15+to return to the%ZAP+panel.\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJTZOOM": {"ttr": 29972, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x9f\\x00\\x94)\\x9f\\t!\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-26T00:00:00", "modifydate": "1994-10-26T09:21:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY Expand(//)\n%Tutorial /-/  EDIT  /-/ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n+\n%                       --------------------------------\n                        |      Edit Macro  \"ZOOM\"      |\n                        --------------------------------\n+\n%FUNCTION :+By placing the cursor on a JCL card containing an EXEC statement,\n            and issueing the%ZOOM+command, this Edit macro will \"zoom in\" on\n            (display in browse) the JCL PROC featured on the statement.\n%SYNTAX :+  ZOOM\n            ZOOM HELP or H to view this tutorial.\n%NOTE :+    This command is most useful when defined to a PF key, thus leaving\n            the cursor free to move to the line containing the EXEC statement.\n+\n)PROC\n  &ZCONT = PAJTZOOM\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAJT3270": {"ttr": 29974, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x08?\\x00\\x94\\x08?\\tY\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-24T00:00:00", "modifydate": "1994-03-24T09:59:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SYSPAJA"}, "text": "%Tutorial - T3270FS - IBM 3270 Terminal test -----------------------------------\n+\n+\n+  This function can be used to TEST Structured Field of an IBM 3270 terminal.\n+\n+\n+  When TEST is set to YES, then a print of the terminal QUERY response is\n+  produced (the SYSOUT data-set is queued to your session with the desired\n+  output class, status, number of copies and destination).\n+\n+\n+  Details about Query Reply response may be found in the IBM manual 3270\n+  Information Display System, Data Stream Programmer's Reference (form\n+  number GA23-0059-05).\n+\n+\n+  Depress%PF3+or%PF15+to return to the%T3270FS+main panel.\n+\n)PROC\n  &ZCONT = PAJT3270\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJU00": {"ttr": 29976, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x90\\x15\\x7f\\x00\\x90\\x15\\x7f\\x11 \\x00'\\x00'\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-06T00:00:00", "modifydate": "1990-06-06T11:20:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SYSPAJA"}, "text": "PAJU000A 'USID VGET error'  .ALARM=YES\n'VGET of USID variable failed (see ERR1 in program PAJPBUMU)'\n\nPAJU000B 'User-id missing'  .ALARM=YES\n'Enter a User-id (it is obviously mandatory to supply it)'\n\nPAJU000C 'User-id not found'  .ALARM=YES\n'May be you entered it wrongly, correct or re-type it, please'\n\nPAJU000D 'CALL GUAR error'  .ALARM=YES\n'The scan of SYS1.UADS has failed (see detail in GUAR routine)'\n\nPAJU000E 'CALL GUACL error'  .ALARM=YES\n'The close of SYS1.UADS has failed (see detail in GUAR routine)'\n\nPAJU000F 'No ACCOUNT NO.'  .ALARM=YES\n'Check SYS1.UADS contents for User-id : &USID (no ACCOUNT)'\n\nPAJU000G 'Wrong ACCOUNT NO.'  .ALARM=YES\n'Check SYS1.UADS contents for User-id : &USID (bad ACCOUNT)'\n\nPAJU000H 'RACF LOCATE error'  .ALARM=YES\n'RACF User-id &USID access failure (see detail of ICHEINTY macro R.C.)'\n\nPAJU000I 'RACF unexpected'  .ALARM=YES\n'RACF User-id &USID default group name length not standard length'\n\nPAJU000J 'ACCN VPUT error'  .ALARM=YES\n'VPUT of ACCN variable failed (see ERR10 in program PAJPBUMU)'\n\nPAJU000K 'DGRP VPUT error'  .ALARM=YES\n'VPUT of DGRP variable failed (see ERR11 in program PAJPBUMU)'\n\nPAJU000Y '&USID interrupt'  .ALARM=YES\n'Interrupt process of User-id &USID has been requested (none done)'\n\nPAJU000Z '&USID reset done'  .ALARM=YES\n'TSO Broadcast messages unloaded and User &USID now RACF reset'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJVEP00": {"ttr": 29978, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x123\\x00Z\\x00Z\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T12:33:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n \\ TYPE(INPUT) INTENS(HIGH) CAPS(ON) HILITE(USCORE)\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n @ TYPE(TEXT) HILITE(REVERSE) SKIP(ON)\n | TYPE(TEXT) COLOR(BLUE) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n # TYPE(OUTPUT) COLOR(YELLOW) JUST(ASIS) CAPS(OFF) SKIP(ON)\n)BODY\n\u00a2                           % VIEW EDIT PROFILES \u00a2                             +\n`Command ===>_ZCMD\n+\n+\n|                                                                              +\n|  +                                                                        |  +\n|  +           {Enter!USERID%===>\\Z      +                                  |  +\n|  +                             \u00a6(project)+                                |  +\n|  +     {to access data-set%===>\\Z                                   +     |  +\n|  +                             \u00a6(group.type)+                             |  +\n|  +             {and!APPLID%===>\\Z   {to access`...EDIT{profile,+          |  +\n|  +                             \u00a6(member)+                                 |  +\n|  +                             {or`APPLID\u00a6command allows the selection.+  |  +\n|  +                                                                        |  +\n|                                                                              +\n+\n+\n+                                                          @                   +\n+                                                          @  + #PMIND    + @  +\n+                                                          @                   +\n+\n)INIT\n  .HELP = PAJTVP00\n  .ZVARS = '(JHEDPRID JHEDPRDS JHEDPRAP)'\n  .CURSOR = JHEDPRID\n  &ZCMD = &Z\n  IF (&PMT = DLT)\n     &PMIND = ' DELETE  '\n    .ATTRCHAR(@) = 'COLOR(RED)'\n  IF (&PMT = SLM)\n     &PMIND = 'S-APPLID '\n    .ATTRCHAR(@) = 'COLOR(WHITE)'\n  IF (&PMT = TBL)\n     &PMIND = ' A-Table '\n    .ATTRCHAR(@) = 'COLOR(TURQ)'\n  IF (&PMT = ON)\n     &PMIND = 'Trace ON '\n    .ATTRCHAR(@) = 'COLOR(PINK)'\n  IF (&PMT = OFF)\n     &PMIND = '(display)'\n    .ATTRCHAR(@) = 'COLOR(GREEN)'\n  IF (&JHEDPRID = &Z)\n    &JHEDPRID = &ZUSER\n  IF (&JHEDPRDS = &Z)\n    IF (&DSNME \u00ac= &Z)\n      &PMC = TRUNC(&DSNME,'.')\n      &JHEDPRDS = .TRAIL\n  IF (&JHEDPRAP = &Z)\n    &JHEDPRAP = &ZAPPLID\n)REINIT\n  IF (.CURSOR = &Z)\n    .CURSOR = JHEDPRID\n)PROC\n  &PCM = TRANS(TRUNC(&ZCMD,' ') A,APPLID AP,APPLID APPL,APPLID D,DELETE\n         DE,DELETE DEL,DELETE T,TRACE TA,TABLE TB,TABLE TR,TRACE TAB,TABLE *,*)\n  IF (&PCM \u00ac= &Z)\n    VER (&PCM,LIST,APPLID,DELETE,TABLE,TRACE,MSG=PAJV000W)\n    &ZTRAIL = .TRAIL\n    IF (&PCM = APPLID)\n      &PMT = SLM\n    IF (&PCM = DELETE)\n      &PMT = DLT\n    IF (&PCM = TABLE)\n      &PMT = TBL\n    IF (&PCM = TRACE)\n      IF (&ZTRAIL = &Z)\n        &PMT = OFF\n      IF (&ZTRAIL \u00ac= &Z)\n        &PMT = TRUNC(&ZTRAIL,' ')\n        IF (&PMT \u00ac= ON)\n          &PMT = OFF\n  IF (&PCM = &Z)\n    VER (&JHEDPRID,NB,NAME)\n    VER (&JHEDPRDS,NB)\n    IF (&PMT \u00ac= SLM)\n      VER (&JHEDPRAP,NB,NAME)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJVEP01": {"ttr": 29981, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x123\\x00>\\x00>\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T12:33:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(BLUE) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n | TYPE(OUTPUT) COLOR(GREEN) SKIP(ON) JUST(LEFT)\n ? TYPE(OUTPUT) COLOR(TURQ) SKIP(ON)\n # TYPE(OUTPUT) COLOR(RED) SKIP(ON)\n)BODY\n\u00a2                           % VIEW EDIT PROFILES \u00a2                             +\n`Command ===>_ZCMD                                            `SCROLL ===>_SCIN+\n+\n!USERID :#JHEDPRID+    !APPLID :#JHEDPRAP+    %Last used :?JHEDUDT !- ?JHEDUTM +\n)MODEL\n `PROFILE :?Z       {ATTR :|Z         {RECOVERY :|Z  {NULLS :|Z     {CAPS :|Z  +\n                    {NUMBER :|Z                + {HEX :|Z      + {TABS :|Z     +\n                    {AUTOSAVE :|Z           +      {AUTONUM :|Z  {AUTOLIST:|Z  +\n                    {IMACRO :|Z           +           {LOCK :|Z  + {STATS :|Z  +\n                    {PACK :|Z  +                 {BOUNDS : left|Z  {/ right|Z  +\n)INIT\n  .HELP = PAJTVP01\n  &ZCMD = &Z\n  .ZVARS = '(JHEDPROF JHEDATTR JHEDRECV JHEDNULL JHEDCAPS JHEDNUMB +\n             JHEDHEXM JHEDTABS JHEDAUTS JHEDAUTN JHEDAUTL JHEDIMAC +\n             JHEDLOCK JHEDSTAT JHEDPACK JHEDBNDL JHEDBNDR )'\n  IF (&SCIN = &Z)\n    &SCIN = 'CSR'\n  &ZTDMARK = '   ======================== Bottom of EDIT profiles +\n              ========================   '\n)PROC\n  &PCM = TRANS(TRUNC(&ZCMD,' ') PL,PLIST PLS,PLIST PLST,PLIST *,*)\n  IF (&PCM \u00ac= &Z)\n    VER (&PCM,LIST,PLIST,MSG=PAJV000V)\n    &ZTRAIL = .TRAIL\n    &PCL = &Z\n    &PDS = &Z\n    IF (&ZTRAIL \u00ac= &Z)\n      &PDS = TRUNC(&ZTRAIL,' ')\n      &PCL = .TRAIL\n      IF (&PDS = 'LOCAL')\n        &PDS = &Z\n      IF (&PDS \u00ac= 'LOCAL')\n        &D = TRUNC(&PDS,1)\n        IF (&PDS \u00ac= &D)\n          VER (&D,LIST,U,R,MSG=PAJV000U)\n          &D = .TRAIL\n          VER (&D,NB,NUM,MSG=PAJV000U)\n        IF (&PDS = &D)\n          &PDS = &PCL\n          &PCL = &D\n          IF (&PDS \u00ac= &Z)\n            IF (&PDS = 'LOCAL')\n              &PDS = &Z\n            IF (&PDS \u00ac= 'LOCAL')\n              &D = TRUNC(&PDS,1)\n              VER (&D,LIST,U,R,MSG=PAJV000U)\n              &D = .TRAIL\n              VER (&D,NB,NUM,MSG=PAJV000U)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJVEP02": {"ttr": 30209, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x123\\x00=\\x00=\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T12:33:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(BLUE) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n | TYPE(OUTPUT) COLOR(GREEN) SKIP(ON) JUST(LEFT)\n ? TYPE(OUTPUT) COLOR(TURQ) SKIP(ON)\n # TYPE(OUTPUT) COLOR(RED) SKIP(ON)\n)BODY\n\u00a2                           % TRACE EDIT PROFILES \u00a2                            +\n`Command ===>_ZCMD                                            `SCROLL ===>_SCIN+\n+\n!USERID :#JHEDPRID+    !APPLID :#JHEDPRAP+    %Last used :?JHEDUDT !- ?JHEDUTM +\n)MODEL\n `ZEDPTYPE :?Z       {ZEDPRCFM :|Z       +         {ZEDPLRCL :|Z       +\n                     {ZEDPFLAG :|Z                                             +\n                     {ZEDPBNDL :|Z       +         {ZEDPBNDR :|Z       +\n                     {ZEDPTABC :|Z       +         {ZEDPIMAC :|Z       +\n                     {ZEDPTABS :|Z       +         {ZEDPMASK :|Z               +\n)INIT\n  .HELP = PAJTVP02\n  &ZCMD = &Z\n  .ZVARS = '(PMPTYPE PMPRCFM PMPLRCL PMPFLAG PMPBNDL +\n             PMPBNDR PMPTABC PMPIMAC PMPTABS PMPMASK)'\n  IF (&SCIN = &Z)\n    &SCIN = 'CSR'\n  &ZTDMARK = '   ======================== Bottom of EDIT profiles +\n              ========================   '\n)PROC\n  &PCM = TRANS(TRUNC(&ZCMD,' ') PL,PLIST PLS,PLIST PLST,PLIST *,*)\n  IF (&PCM \u00ac= &Z)\n    VER (&PCM,LIST,PLIST,MSG=PAJV000V)\n    &ZTRAIL = .TRAIL\n    &PCL = &Z\n    &PDS = &Z\n    IF (&ZTRAIL \u00ac= &Z)\n      &PDS = TRUNC(&ZTRAIL,' ')\n      &PCL = .TRAIL\n      IF (&PDS = 'LOCAL')\n        &PDS = &Z\n      IF (&PDS \u00ac= 'LOCAL')\n        &D = TRUNC(&PDS,1)\n        IF (&PDS \u00ac= &D)\n          VER (&D,LIST,U,R,MSG=PAJV000U)\n          &D = .TRAIL\n          VER (&D,NB,NUM,MSG=PAJV000U)\n        IF (&PDS = &D)\n          &PDS = &PCL\n          &PCL = &D\n          IF (&PDS \u00ac= &Z)\n            IF (&PDS = 'LOCAL')\n              &PDS = &Z\n            IF (&PDS \u00ac= 'LOCAL')\n              &D = TRUNC(&PDS,1)\n              VER (&D,LIST,U,R,MSG=PAJV000U)\n              &D = .TRAIL\n              VER (&D,NB,NUM,MSG=PAJV000U)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJVEP03": {"ttr": 30211, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x123\\x00C\\x00C\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T12:33:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(RED) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n | TYPE(TEXT) COLOR(BLUE) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n \u00ac TYPE(TEXT) COLOR(WHITE) HILITE(USCORE) SKIP(ON)\n @ TYPE(OUTPUT) COLOR(RED) SKIP(ON)\n # TYPE(OUTPUT) COLOR(GREEN) JUST(ASIS) CAPS(ON) SKIP(ON)\n)BODY\n\u00a2                       % EDIT PROFILES TABLE ANALYSIS \u00a2                       +\n`Command ===>_ZCMD\n+\n+\n!USERID :@JHEDPRID+    !APPLID :@JHEDPRAP+\n|                                                                              +\n|  +                                                                        |  +\n|  + \u00acTable Statistics :+                               ` USER :#PMUSR   +  |  +\n|  +                                                                        |  +\n|  + \u00a6CDATE :#PMCDT   \u00a6CTIME :#PMCTM   \u00a6UDATE :#PMUDT   \u00a6UTIME :#PMUTM      |  +\n|  +                                                                        |  +\n|  +       !ROWCREAT :#PMRWC   !ROWCURR :#PMRCU   !ROWUPD :#PMRUP   +       |  +\n|  +                                                                        |  +\n|  +       !TABLEUPD :#PMTUP   !SERVICE :#PMSRV   !RETCODE :#PMRCD  +       |  +\n|  +                                                                        |  +\n|  +      {STATUS1 :#PMST1     {STATUS2 :#PMST2     {STATUS3 :#PMST3   +    |  +\n|  +                                                                        |  +\n|  +  !ROWNUM :#PMRNM   +     \u00a6KEYNUM :#PMKNM   +     \u00a6NAMENUM :#PMNMN   +  |  +\n|  +                                                                        |  +\n|                                                                              +\n+\n)INIT\n  .HELP = PAJTVP03\n  &ZCMD = &Z\n)PROC\n  &PCM = TRANS(TRUNC(&ZCMD,' ') PL,PLIST PLS,PLIST PLST,PLIST *,*)\n  IF (&PCM \u00ac= &Z)\n    VER (&PCM,LIST,PLIST,MSG=PAJV000V)\n    &ZTRAIL = .TRAIL\n    &PCL = &Z\n    &PDS = &Z\n    IF (&ZTRAIL \u00ac= &Z)\n      &PDS = TRUNC(&ZTRAIL,' ')\n      &PCL = .TRAIL\n      IF (&PDS = 'LOCAL')\n        &PDS = &Z\n      IF (&PDS \u00ac= 'LOCAL')\n        &D = TRUNC(&PDS,1)\n        IF (&PDS \u00ac= &D)\n          VER (&D,LIST,U,R,MSG=PAJV000U)\n          &D = .TRAIL\n          VER (&D,NB,NUM,MSG=PAJV000U)\n        IF (&PDS = &D)\n          &PDS = &PCL\n          &PCL = &D\n          IF (&PDS \u00ac= &Z)\n            IF (&PDS = 'LOCAL')\n              &PDS = &Z\n            IF (&PDS \u00ac= 'LOCAL')\n              &D = TRUNC(&PDS,1)\n              VER (&D,LIST,U,R,MSG=PAJV000U)\n              &D = .TRAIL\n              VER (&D,NB,NUM,MSG=PAJV000U)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJVEP04": {"ttr": 30213, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x123\\x00C\\x00C\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T12:33:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n | TYPE(TEXT) COLOR(BLUE) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n \u00ac TYPE(TEXT) COLOR(WHITE) HILITE(USCORE) SKIP(ON)\n @ TYPE(OUTPUT) COLOR(RED) SKIP(ON)\n # TYPE(OUTPUT) COLOR(GREEN) JUST(ASIS) CAPS(ON) SKIP(ON)\n)BODY\n\u00a2                       % EDIT PROFILES TABLE ANALYSIS \u00a2                       +\n`Command ===>_ZCMD\n+\n+\n!USERID :@JHEDPRID+    !APPLID :@JHEDPRAP+\n|                                                                              +\n|  +                                                                        |  +\n|  +\u00acKEYS :`(variables names)+                                              |  +\n|  +    #PMK01                                                          +   |  +\n|  +    #PMK02                                                          +   |  +\n|  +    #PMK03                                                          #PMX|  +\n|  +\u00acNAMES :`(variables names)+                                             |  +\n|  +    #PMN01                                                          +   |  +\n|  +    #PMN02                                                          +   |  +\n|  +    #PMN03                                                          +   |  +\n|  +    #PMN04                                                          #PMY|  +\n|  +\u00acSAVE :`(variables names)+                                              |  +\n|  +    #PMS01                                                          +   |  +\n|  +    #PMS02                                                          +   |  +\n|  +    #PMS03                                                          #PMZ|  +\n|  +                                                                        |  +\n|                                                                              +\n+\n)INIT\n  .HELP = PAJTVP03\n  &ZCMD = &Z\n)PROC\n  &PCM = TRANS(TRUNC(&ZCMD,' ') PL,PLIST PLS,PLIST PLST,PLIST *,*)\n  IF (&PCM \u00ac= &Z)\n    VER (&PCM,LIST,PLIST,MSG=PAJV000V)\n    &ZTRAIL = .TRAIL\n    &PCL = &Z\n    &PDS = &Z\n    IF (&ZTRAIL \u00ac= &Z)\n      &PDS = TRUNC(&ZTRAIL,' ')\n      &PCL = .TRAIL\n      IF (&PDS = 'LOCAL')\n        &PDS = &Z\n      IF (&PDS \u00ac= 'LOCAL')\n        &D = TRUNC(&PDS,1)\n        IF (&PDS \u00ac= &D)\n          VER (&D,LIST,U,R,MSG=PAJV000U)\n          &D = .TRAIL\n          VER (&D,NB,NUM,MSG=PAJV000U)\n        IF (&PDS = &D)\n          &PDS = &PCL\n          &PCL = &D\n          IF (&PDS \u00ac= &Z)\n            IF (&PDS = 'LOCAL')\n              &PDS = &Z\n            IF (&PDS \u00ac= 'LOCAL')\n              &D = TRUNC(&PDS,1)\n              VER (&D,LIST,U,R,MSG=PAJV000U)\n              &D = .TRAIL\n              VER (&D,NB,NUM,MSG=PAJV000U)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJVEP10": {"ttr": 30215, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x14\\x06\\x00,\\x00,\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T14:06:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n \\ TYPE(INPUT) INTENS(LOW) CAPS(ON) HILITE(USCORE)\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n | TYPE(OUTPUT) COLOR(TURQ) SKIP(ON) JUST(LEFT)\n # TYPE(OUTPUT) COLOR(RED) SKIP(ON)\n)BODY\n\u00a2                           % VIEW EDIT PROFILES \u00a2                             +\n`Command ===>_ZCMD                                            `SCROLL ===>_SCIN+\n+\n!APPLIDs names in data-set :#JHPROFDS                                    +\n`   Sel. <1>      <2>      <3>      <4>      <5>      <6>      <7>      <8>\n+   =========================================================================\n)MODEL CLEAR(XSL)\n   \\Z+  |Z   +   |Z   +   |Z   +   |Z   +   |Z   +   |Z   +   |Z   +   |Z   +\n)INIT\n  .HELP = PAJTVP10\n  &ZCMD = &Z\n  .ZVARS = '(XSL XN1 XN2 XN3 XN4 XN5 XN6 XN7 XN8)'\n  .AUTOSEL = NO\n  IF (&CRP \u00ac= &Z)\n    .CSRROW = &CRP\n  IF (&SCIN = &Z)\n    &SCIN = 'CSR'\n  &ZTDMARK = '   ======================== Bottom of APPLIDs names +\n              ========================   '\n)REINIT\n  IF (.MSG \u00ac= &Z)\n    .AUTOSEL = YES\n    .CSRROW = &CRP\n)PROC\n  &PCM = TRANS(TRUNC(&ZCMD,' ') *,*)\n  IF (&PCM \u00ac= &Z)\n    .MSG = PAJV001A\n  IF (&PCM = &Z)\n    &XERR = OFF\n    IF (&ZTDSELS \u00ac= 0000)\n      IF (&XSL \u00ac= 1,2,3,4,5,6,7,8)\n        &XVAL = &XSL\n        &XERR = ON\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJVEP20": {"ttr": 30217, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x06\\x9f\\x00\\x95\\x06\\x9f\\x14\\x02\\x00:\\x00:\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-10T00:00:00", "modifydate": "1995-03-10T14:02:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n \\ TYPE(INPUT) INTENS(LOW) CAPS(ON) HILITE(USCORE)\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n ? TYPE(OUTPUT) COLOR(TURQ) SKIP(ON)\n # TYPE(OUTPUT) COLOR(RED) SKIP(ON)\n)BODY\n\u00a2                          % DELETE EDIT PROFILES \u00a2                            +\n`Command ===>_ZCMD                                            `SCROLL ===>_SCIN+\n+\n!USERID :#JHEDPRID+    !APPLID :#JHEDPRAP+\n{Enter%S{or%Sn{in front of%Profile{name :+\n)MODEL CLEAR(XSL)\n          \\Z  +           ?Z       +\n)INIT\n  .HELP = PAJTVP20\n  &ZCMD = &Z\n  .ZVARS = '(XSL ZEDPTYPE)'\n  .AUTOSEL = NO\n  IF (&CRP \u00ac= &Z)\n    .CSRROW = &CRP\n  IF (&SCIN = &Z)\n    &SCIN = 'CSR'\n  &ZTDMARK = '   ======================== Bottom of EDIT profiles +\n              ========================   '\n)REINIT\n  IF (.MSG \u00ac= &Z)\n    .AUTOSEL = YES\n    .CSRROW = &CRP\n)PROC\n  &PCM = TRANS(TRUNC(&ZCMD,' ') CAN,CANCEL  *,*)\n  VER (&PCM,LIST,CANCEL,MSG=PAJV002A)\n  &XERR = OFF\n  &XVAL = &Z\n  IF (&ZTDSELS \u00ac= 0000)\n    &M = TRUNC(&XSL,1)\n    &N = .TRAIL\n    IF (&M \u00ac= S)\n      &XERR = ON\n      &XVAL = &XSL\n    IF (&M = S)\n      IF (&N \u00ac= &Z)\n        &N1 = TRUNC(&N,1)\n        &N2 = .TRAIL\n        IF (&N1 \u00ac= 1,2,3,4,5,6,7,8,9)\n          &XERR = ON\n          &XVAL = &XSL\n        IF (&N2 \u00ac= &Z)\n          IF (&N2 \u00ac= 0,1,2,3,4,5,6,7,8,9)\n            &XERR = ON\n            &XVAL = &XSL\n      IF (&N = &Z)\n        &N = 1\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJVEP21": {"ttr": 30219, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07?\\x00\\x95\\x07?\\t\\t\\x00/\\x00/\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-14T00:00:00", "modifydate": "1995-03-14T09:09:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n \\ TYPE(INPUT) INTENS(HIGH) CAPS(ON) HILITE(USCORE)\n % TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n + TYPE(TEXT) INTENS(LOW) SKIP(ON)\n { TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n ! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n \u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n ` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n | TYPE(TEXT) COLOR(BLUE) HILITE(REVERSE) SKIP(ON)\n \u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n # TYPE(OUTPUT) COLOR(YELLOW) JUST(ASIS) CAPS(OFF) SKIP(ON)\n)BODY\n\u00a2                          % DELETE EDIT PROFILES \u00a2                            +\n`Command ===>_ZCMD\n+\n+\n|                                                                              +\n|  +                                                                        |  +\n|  +     {Data-set :#Z                                           +          |  +\n|  +                                                                        |  +\n|  +     \u00a6APPLID{EDIT profile :#Z   +                                       |  +\n|  +                                                                        |  +\n|  +     {Confirm you want!REPLACE%===>\\PRF+(NO/YES)                        |  +\n|  +                                                                        |  +\n|  +            {and then!COMPRESS%===>\\PCF+(NO/YES)                        |  +\n|  +                                                                        |  +\n|                                                                              +\n+\n)INIT\n  .HELP = PAJTVP21\n  .ZVARS = '(JHPROFDS JHEDPRAP)'\n  .CURSOR = PRF\n  &ZCMD = &Z\n)PROC\n  &PCM = TRANS(TRUNC(&ZCMD,' ') CAN,CANCEL  *,*)\n  IF (&PCM \u00ac= &Z)\n    VER (&PCM,LIST,CANCEL,MSG=PAJV002A)\n  IF (&PCM = &Z)\n    &PRF = TRUNC (&PRF,1)\n    &PRF = TRANS (&PRF ' ',NO N,NO Y,YES  *,*)\n    VER (&PRF,LIST,NO,YES,MSG=PAJV002C)\n    &PCF = TRUNC (&PCF,1)\n    &PCF = TRANS (&PCF ' ',NO N,NO Y,YES  *,*)\n    VER (&PCF,LIST,NO,YES,MSG=PAJV002D)\n    IF (&PRF \u00ac= YES)\n      VER (&PCF,LIST,NO,MSG=PAJV002E)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJVQ1": {"ttr": 30221, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90%\\x7f\\x00\\x90%\\x7f\\x11\\x00\\x003\\x003\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-09-14T00:00:00", "modifydate": "1990-09-14T11:00:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n + TYPE(TEXT) SKIP(ON) INTENS(LOW)\n)BODY\n%-----------------------------  GRS / ENQ DISPLAY  -----------------------------\n%Command ===>_ZCMD                                                             +\n\n              (leave all fields blanks to get ENQ-contention)\n\n%Enter/Verify parameters below :\n+\n          Job name%===>_JOB     +\n      Major Q-name%===>_MAJOR   +\n      Minor Q-name%===>_MINOR                                       +\n\n%or set specific request for :\n+\n     Data-set name%===>_VQDSN                                       +\n or User-ID in TSO%===>_VQTSO  +\n         or in SPF%===>_VQSPF  +\n\n\n)INIT\n  .HELP = PAJTVQ1\n  .CURSOR = JOB\n  &ZCMD = &Z\n  &VQDSN = &Z\n  &VQTSO = &Z\n  &VQSPF = &Z\n)PROC\n  IF (&ZCMD \u00ac= ' ')  .MSG = ISPZ001\n  IF (&VQDSN \u00ac= ' ')  VER(&VQDSN,DSNAME)\n    &MAJOR = SYSDSN\n    &MINOR = &VQDSN\n    &VQDSN = &Z\n    &VQTSO = &Z\n    &VQSPF = &Z\n  IF (&VQTSO \u00ac= ' ')  VER(&VQTSO,NAME)\n    &MAJOR = SYSIKJUA\n    &MINOR = &VQTSO\n    &VQTSO = &Z\n    &VQSPF = &Z\n    &JOB = &Z\n  IF (&VQSPF \u00ac= ' ')  VER(&VQSPF,NAME)\n    &MAJOR = SPFUSER\n    &MINOR = &VQSPF\n    &VQSPF = &Z\n    &JOB = &Z\n  IF (&JOB \u00ac= ' ')  VER(&JOB,NAME)\n  IF (&MAJOR \u00ac= ' ')  VER(&MAJOR,NAME)\n  IF (&MINOR \u00ac= ' ')  VER(&MINOR,DSNAME)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJVQ2": {"ttr": 30223, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90$\\x7f\\x00\\x90$\\x7f\\x15P\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-09-04T00:00:00", "modifydate": "1990-09-04T15:50:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n @ TYPE(OUTPUT) INTENS(LOW)\n)BODY\n%GRS / ENQ display -------------------------------------------------------------\n+Command%===>_VCMD                                            %SCROLL ===>_AMT +\n+\n%&T1\n%&T2\n)MODEL\n@Z\n)INIT\n  &VARS = '(X)'\n  &AMT = PAGE\n  &VCMD = &Z\n  .HELP = PAJTVQ2\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJVRS": {"ttr": 30225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x1f\\x00\\x942\\x1f\\t0\\x00B\\x00B\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-17T00:00:00", "modifydate": "1994-11-17T09:30:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n{ TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n} TYPE(TEXT) COLOR(RED) SKIP(ON)\n! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n\u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n@ TYPE(TEXT) COLOR(YELLOW) HILITE(REVERSE) SKIP(ON)\n| TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n# TYPE(TEXT) COLOR(RED) HILITE(REVERSE) SKIP(ON)\n~ TYPE(TEXT) COLOR(PINK) HILITE(REVERSE) SKIP(ON)\n\u00a2 TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n\\ TYPE(TEXT) COLOR(BLUE) HILITE(REVERSE) SKIP(ON)\n? TYPE(TEXT) COLOR(WHITE) HILITE(REVERSE) SKIP(ON)\n)BODY\n`-------------------------<\u00a6 Various ... Option Menu `>-------------------------\n{Select OPTION%===>_ZCMD                                                       +\n+\n\\ % D{DHC     +- Hex/Decimal calculator               |                        +\n\\ % S{SEE     +- See current ISPF panel               |  \u00a6Userid -!&ZUSER   |  +\n\u00a2 ! V{T3270FS +- IBM 3270 full-screen terminal test   |  \u00a6Prefix -!&ZPREFIX |  +\n| ` T\u00a6SEIKO   +- Clock-watcher                        |  \u00a6Today  -!&ZDATE   |  +\n+                                                     |  \u00a6Julian -!&ZJDATE  |  +\n? } X%EXIT     - Return to SPF+                       |  \u00a6Time   -?  &ZTIME |  +\n+                                                     |                        +\n@            \u00a6G A M E S - Various games@             +%------------------------+\n\u00a2 %N1 `Blackjack   \u00a2 %N4 `Lunar       \u00a2 %N7 `Klingon     \u00a2 %   `            \u00a2 +\n\u00a2 %N2 `Kalah       \u00a2 %N5 `Decider     \u00a2 %N8 `Strek       \u00a2 %   `            \u00a2 +\n\u00a2 %N3 `Life        \u00a2 %N6 `Jotto       \u00a2 %   `            \u00a2 %   `            \u00a2 +\n%----~  {Only on a terminal with}PS{and}GE{:~  %- - - - - - - - - - - - - - - -+\n# %G1 `Diver       # %G3 Snake        # %   `            # %   `            # +\n# %G2 `Poker       # %G4 `Worm        # %   `            # %   `            # +\n%----~  {Only on a}graphic{terminal :~         %- - - - - - - - - - - - - - - -+\n# %R1 `GDDM-demo   # %R2 `ANIM-demo   # %   `            # %   `            # +\n%------------------------------------------------------------------------------+\n+\n+Press%END KEY+to return to the PRIMARY OPTION MENU\n+\n)INIT\n  &ZPRIM = YES\n  .CURSOR = ZCMD\n)PROC\n  &ZSEL = TRANS (TRUNC (&ZCMD,'.')\n                D,'CMD(DHC)'\n                S,'CMD(SEE)'\n                V,'PANEL(PAJ3270)'\n                T,'CMD(SEIKO)'\n                N1,'CMD(%BLACKJK)'\n                N2,'CMD(KALAH)'\n                N3,'PANEL(PAJLIFE)'\n                N4,'CMD(LUNAR)'\n                N5,'CMD(%DECIDER)'\n                N6,'CMD(%JOTTO)'\n                N7,'CMD(%KLPROC)'\n                N8,'CMD(STREK)'\n                G1,'CMD(DIVER)'\n                G2,'CMD(POKER)'\n                G3,'PANEL(PAJSNK)'\n                G4,'PANEL(PAJWRM)'\n                R1,'CMD(%PAJCGDDM)'\n                R2,'CMD(%PAJCANIM)'\n              BIRD,'CMD(%PAJCBIRD)'\n                X,'EXIT'\n              ' ',' '\n                *,'?' )\n)END\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJV00": {"ttr": 30227, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07?\\x00\\x95\\x07?\\t1\\x00B\\x00B\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-14T00:00:00", "modifydate": "1995-03-14T09:31:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "SYSPAJA"}, "text": "/*       General-purpose messages used in JH#TEDPR procedure        */\n/*            by JOHN HANCOCK modifications/extensions to PDF.      */\n/*       Reworked by MOINIL P.A.                                    */\n\nPAJV000A 'ACCESS error' .ALARM=YES\n'Data-set &JHPROFDS : not allowed to &JHRACC it (RACF protected).'\nPAJV000B 'RACF error' .ALARM=YES\n'Data-set &JHPROFDS : RACF verify access has failed (RC=&RCC).'\nPAJV000C 'MEMBER error' .ALARM=YES\n'Member &TB : not found in data-set &JHPROFDS ...'\nPAJV000D 'CATALOG error' .ALARM=YES\n'Data-set &JHPROFDS : not found in CATALOG ...'\nPAJV000E 'DSORG error' .ALARM=YES\n'Data-set &JHPROFDS : not partitioned organization ...'\nPAJV000F 'DATA-SET error' .ALARM=YES\n'Data-set &JHPROFDS : DSNCHECK verify failed (RC=&RCC).'\nPAJV000G 'ISPPROF error' .ALARM=YES\n'Using WHATDSN : ISPF file ISPPROF results not allocated ...'\nPAJV000H 'WHATDSN error' .ALARM=YES\n'Trying to get data-set name of ISPPROF : WHATDSN failed (RC=&RCC).'\nPAJV000U 'PLIST error' .ALARM=YES\n'Invalid PLIST destination. Enter it as Unn or Rnn (e.g. R14).'\nPAJV000V 'COMMAND error' .ALARM=YES\n'Command &PCM : any command other than PLIST is not supported ...'\nPAJV000W 'COMMAND error' .ALARM=YES\n'Command &PCM : only APPLID, DELETE, TABLE and TRACE are supported ...'\nPAJV000X 'PLIST complete'\n'LIST of EDIT PROFILES TABLE ANALYSIS has been sent for printing.'\nPAJV000Y 'PLIST complete'\n'LIST of all TRACE EDIT PROFILES has been sent for printing.'\nPAJV000Z 'PLIST complete'\n'LIST of all VIEW EDIT PROFILES has been sent for printing.'\n\nPAJV001A 'COMMAND error' .ALARM=YES\n'Command &PCM : all commands are rejected ...'\nPAJV001B 'SELECT please' .ALARM=YES\n'Please, SELECT the APPLID name of your choice.'\nPAJV001C 'SELECT error' .ALARM=YES\n'SELECT multiple APPLIDs names is not allowed (only one accepted).'\nPAJV001D 'SELECT invalid' .ALARM=YES\n'Invalid APPLID name position number : &XVAL ... Correct it (1-8).'\nPAJV001E 'SELECT wrong' .ALARM=YES\n'You have SELECTed a shadow APPLID name <&N>, SELECT again.'\nPAJV001F 'APPLID error'\n'Data-set &JHPROFDS : no APPLIDs names found ...'\n\nPAJV002A 'COMMAND error' .ALARM=YES\n'Command &PCM : any command other than CANCEL is not supported ...'\nPAJV002B 'ACTION error' .ALARM=YES\n'Invalid line ACTION command : &XVAL ... Enter S or Sn.'\nPAJV002C 'CONFIRM please' .ALARM=YES\n'Please, CONFIRM with Y(ES) only or let N(O) (or clear field, blank it).'\nPAJV002T 'LMCOMP error' .ALARM=YES\n'LMCOMP of &JHPROFDS failed (RC=&PCC).'\nPAJV002U 'LMCOPY error' .ALARM=YES\n'LMCOPY to replace &TN failed (RC=&CCC).'\nPAJV002V 'LMINIT error' .ALARM=YES\n'LMINIT of &JHPRODS with ENQ(EXCLU) failed (RC=&ICC).'\nPAJV002W 'CONFIRM NO' .ALARM=YES\n'DELETE process ended normally with update rejected, table not saved ...'\nPAJV002X 'DELETE canceled' .ALARM=YES\n'DELETE process ended through CANCEL, table not saved ...'\nPAJV002Y 'DELETE none'\n'DELETE process ended normally with no update, table not saved ...'\nPAJV002Z 'DELETE saved'\n'DELETE process ended normally with confirmed request(s) done ...'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJWRM": {"ttr": 30465, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x1f\\x00\\x942\\x1f\\t0\\x00)\\x00)\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-17T00:00:00", "modifydate": "1994-11-17T09:30:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SYSPAJA"}, "text": "%WORM ---------------  A program for TSO 3270 terminals  -----------------------\n+\n+\n%Invoke as :_WRMS    +(W, H or Q) ---> W = WORM           => full-screen\n+                                      H = HALFWORM or HW => top half-screen\n%CPU percentage :_WRMN+(1-99)          Q = QUARTERW or QW => top quarter-screen\n+\n%Author :+written October 1986 by Greg Price of Prycroft Six PTY LTD.\n\n%Object :+for the WORM to eat the numbers appearing on the screen without\n          colliding with itself or the border around the screen. When a number\n          is eaten (by moving the WORM's head, denoted by a @, the number's\n          location) another number will appear at a random vacant location.\n          The value of the eaten number will be added to the score and the\n          WORM's length will also increase by that amount. Collisions are\n          denoted by a + then a * one second later, and cause the WORM to die\n          due to brain damage caused by shocking head injuries.\n+\n+Hit%ENTER+to execute the program.\n+Hit%HELP+to get program explanation tutorial.\n+Hit%END KEY+to return to the Various ... Option Menu.\n+\n)INIT\n  .HELP = PAJTWRM0\n  IF (&WRMS = &Z)\n    &WRMS = W\n  &WRMN = &Z\n  .CURSOR = WRMS\n)PROC\n  &WRMS = TRUNC (&WRMS,1)\n  VER (&WRMS,NONBLANK)  VER (&WRMS,LIST,W,H,Q)\n  IF (&WRMN \u00ac= &Z)\n    VER (&WRMN,RANGE,1,99)\n  IF (&WRMS = W)\n    &WRMC = WORM\n  IF (&WRMS = H)\n    &WRMC = HALFWORM\n  IF (&WRMS = Q)\n    &WRMC = QUARTERW\n  &ZSEL = 'CMD(&WRMC &WRMN )'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJXIL": {"ttr": 30467, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x15\\x7f\\x00\\x92\\x15\\x7f\\x15\\x00\\x00^\\x00^\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-05T00:00:00", "modifydate": "1992-06-05T15:00:00", "lines": 94, "newlines": 94, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n\\ TYPE(INPUT) CAPS(ON) INTENS(HIGH)\n` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n{ TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n} TYPE(TEXT) COLOR(RED) SKIP(ON)\n! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n\u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n~ TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n@ TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n? TYPE(TEXT) COLOR(YELLOW) HILITE(REVERSE) SKIP(ON)\n)BODY\n`--------------------------<\u00a6 IMS log data-set(s) `>----------------------------\n+\n+\n~                                                                              +\n~  !Enter}===>{a specific day :\\DD+(format DD)                              ~  +\n~  `or{a range of days - from :\\DF+(format DD)                              ~  +\n~  +                      {to :\\DT+(format DD, default = last day of the    ~  +\n~  +                                month or yesterday if this is lower)    ~  +\n~  +            {Month / Year :\\DM!/\\DY+(format MM / YY, default = current  ~  +\n~  +                                month and current year)                 ~  +\n~  `Note :\u00a6left all above blank to get yesterday.                           ~  +\n~  @                                                                        ~  +\n~  !Enter}===>{JCL skeleton selection :\\JI+(default = 00)                   ~  +\n~  @                                                                        ~  +\n~  !Enter}===>{Messages :\\MAS+(Yes = accept / No = suppress)                ~  +\n~  ?                                                                        ~  +\n~  +Hit%ENTER+to proceed or%END+to terminate.                               ~  +\n~  +Hit%HELP+to get explanation about days selection.                       ~  +\n~                                                                              +\n+\n)INIT\n  .HELP = PAJTXIL\n  .CURSOR = DD\n  IF (&MAS \u00ac= &Z)\n    &MAS = TRUNC (&MAS,1)\n    &MAS = TRANS (&MAS Y,YES N,NO *,*)\n  IF (&MAS = &Z)\n    &MAS = YES\n)PROC\n  IF (&DD \u00ac= &Z)\n    VER (&DD,PICT,'NN')\n    VER (&DD,RANGE,1,31)\n    IF (&DF \u00ac= &Z)\n      .MSG = PAJI000A\n    IF (&DT \u00ac= &Z)\n      .MSG = PAJI000B\n    IF (&DM \u00ac= &Z)\n      VER (&DM,PICT,'NN')\n      VER (&DM,RANGE,1,12)\n    IF (&DM = &Z)\n      &DM = &ZMONTH\n    IF (&DY \u00ac= &Z)\n      VER (&DY,PICT,'NN')\n    IF (&DY = &Z)\n      &DY = &ZYEAR\n  IF (&DF \u00ac= &Z)\n    VER (&DF,PICT,'NN')\n    VER (&DF,RANGE,1,31)\n    IF (&DT \u00ac= &Z)\n      VER (&DT,PICT,'NN')\n      VER (&DT,RANGE,1,31)\n    IF (&DM \u00ac= &Z)\n      VER (&DM,PICT,'NN')\n      VER (&DM,RANGE,1,12)\n    IF (&DM = &Z)\n      &DM = &ZMONTH\n    IF (&DY \u00ac= &Z)\n      VER (&DY,PICT,'NN')\n    IF (&DY = &Z)\n      &DY = &ZYEAR\n  IF (&DF = &Z)\n    IF (&DT \u00ac= &Z)\n      .MSG = PAJI000C\n  IF (&DM \u00ac= &Z)\n    VER (&DM,PICT,'NN')\n    VER (&DM,RANGE,1,12)\n    IF (&DY \u00ac= &Z)\n      VER (&DY,PICT,'NN')\n    IF (&DY = &Z)\n      &DY = &ZYEAR\n  IF (&DM = &Z)\n    IF (&DY \u00ac= &Z)\n      .MSG = PAJI000D\n  IF (&JI \u00ac= &Z)\n    VER (&JI,PICT,'CC')\n  IF (&MAS \u00ac= &Z)\n    &MAS = TRUNC (&MAS,1)\n    &MAS = TRANS (&MAS Y,YES N,NO *,*)\n    VER (&MAS,LIST,YES,NO)\n  IF (&MAS = &Z)\n    &MAS = YES\n  VPUT (DD DF DT DM DY JI MAS) SHARED\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJXILX": {"ttr": 30470, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x15\\x7f\\x00\\x92\\x15\\x7f\\x15%\\x00,\\x00,\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-05T00:00:00", "modifydate": "1992-06-05T15:25:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n\\ TYPE(INPUT) CAPS(ON) INTENS(HIGH)\n# TYPE(OUTPUT) COLOR(TURQ) SKIP(ON)\n| TYPE(OUTPUT) COLOR(PINK) SKIP(ON)\n` TYPE(TEXT) COLOR(YELLOW) SKIP(ON)\n{ TYPE(TEXT) COLOR(GREEN) SKIP(ON)\n} TYPE(TEXT) COLOR(RED) SKIP(ON)\n! TYPE(TEXT) COLOR(PINK) SKIP(ON)\n\u00a6 TYPE(TEXT) COLOR(TURQ) SKIP(ON)\n~ TYPE(TEXT) COLOR(GREEN) HILITE(REVERSE) SKIP(ON)\n@ TYPE(TEXT) COLOR(TURQ) HILITE(REVERSE) SKIP(ON)\n? TYPE(TEXT) COLOR(YELLOW) HILITE(REVERSE) SKIP(ON)\n)BODY\n`--------------------------<\u00a6 IMS log data-set(s) `>----------------------------\n+\n+\n~                                                                              +\n~  {Executed command was :                                                  ~  +\n~  \u00a6      IMSLDS#ILST                                                       ~  +\n~  `Command return code is :|ILRC                                           ~  +\n~  {Generated JCL data-set name is :                                        ~  +\n~  +     #EUGENDS                                                           ~  +\n~  @                                                                        ~  +\n~  `Available data-set processing are :                                     ~  +\n~  +                               }E+-{to edit and/or submit.              ~  +\n~  +                                   {(alias :}S{or}ENTER{only)           ~  +\n~  +                               }B+-{to browse only.                     ~  +\n~  +                               }D+-{to delete only.                     ~  +\n~  !Enter}===>\\DX+(B/E/S/D, as described above)                             ~  +\n~  ?                                                                        ~  +\n~  +Hit%ENTER+to proceed or%END+to terminate.                               ~  +\n~  +Hit%HELP+to get explanation about days selection.                       ~  +\n~                                                                              +\n+\n)INIT\n  .HELP = PAJTXIL\n  .CURSOR = DX\n  &DX = &Z\n)PROC\n  IF (&DX \u00ac= &Z)\n    &DX = TRUNC (&DX,1)\n    VER (&DX,LIST,B,D,E,S)\n  VPUT (DX) SHARED\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJX00": {"ttr": 30472, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88(_\\x00\\x88(_\\x14\\x00\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-10-11T00:00:00", "modifydate": "1988-10-11T14:00:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "PAJX000A 'Invalid command   '  .ALARM=YES\n'Command &ZCMD is undefined'\n\nPAJX000B 'Invalid sel. code '  .ALARM=YES\n'Type S or B in front of desired member name'\n\nPAJX000C 'Operand missing   '  .ALARM=YES\n'Command specified requires a name'\n\nPAJX000D 'Operand too long  '  .ALARM=YES\n'Name specified must be less than or equal to 8 characters'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJZAP": {"ttr": 30474, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88#\\x0f\\x00\\x88#\\x0f\\x153\\x00)\\x00)\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-08-17T00:00:00", "modifydate": "1988-08-17T15:33:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SYSPAJA"}, "text": "%ZAP ------------------------  Full Screen ZAP  --------------------------------\n%Enter/verify parameters below:\n+\n+Library name: PROJECT %===>_PRJO       +  (if VTOC specified, this is the\n+              LIBRARY %===>_LIBO       +   data-set used as reference to\n+              TYPE    %===>_TYPO       +   allocate the volume VTOC)\n+\n+    or Data-set Name: %===>_SZDSN\n+   and Volume Serial: %===>_SZVOL      +  (if not cataloged)\n+\n+      Access to VTOC: %===>_SZVTA      +  (optional: NO/YES)\n+\n+\n+        For further information enter HELP upon entry into ZAP\n+        or depress PF1 or PF13 for HELP now.\n+\n)INIT\n  .HELP = PAJTZAP\n  .CURSOR = LIBO\n  IF (&PRJO = ' ')\n    &PRJO = TRUNC (&ZPREFIX,' ')\n  &SZVTA = TRANS (&SZVTA ' ',NO YES,NO *,*)\n)PROC\n  &SZVTA = TRUNC (&SZVTA,1)\n  &SZVTA = TRANS (&SZVTA N,NO Y,YES *,*)\n  VER (&SZVTA,NONBLANK)  VER (&SZVTA,LIST,NO,YES)\n  IF (&SZVOL \u00ac= ' ')\n    VER (&SZVOL,NAME)\n  IF (&SZDSN \u00ac= ' ')\n    VER (&SZDSN,DSNAME)\n  IF (&SZDSN = ' ')\n    VER (&PRJO,NONBLANK)  VER (&PRJO,NAME)\n    IF (&SZVTA \u00ac= YES)\n      VER (&LIBO,NONBLANK)  VER (&LIBO,NAME)\n      VER (&TYPO,NONBLANK)  VER (&TYPO,NAME)\n    IF (&SZVTA = YES)\n      IF (&LIBO = ' ')\n        IF (&TYPO = ' ')\n          VER (&SZVOL,NONBLANK)\n  &SEL = 'CMD(%PAJCZAP) '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAJZ00": {"ttr": 30476, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x90(\\x8f\\x00\\x90(\\x8f\\t'\\x00\\x02\\x00\\x02\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-15T00:00:00", "modifydate": "1990-10-15T09:27:00", "lines": 2, "newlines": 2, "modlines": 0, "user": "SYSPAJA"}, "text": "PAJZ000 '&EUMSGS' .ALARM=YES\n'&EUMSGL'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAJ3270": {"ttr": 30478, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x08?\\x00\\x94\\x08?\\tY\\x00&\\x00&\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-24T00:00:00", "modifydate": "1994-03-24T09:59:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SYSPAJA"}, "text": "%T3270FS ------------------  IBM 3270 Terminal test  ---------------------------\n+\n+\n%Purpose :+verify and check IBM 3270 Structured Field operations.\n+\n+\n%Enter/verify parameter below :\n+\n+ T3270FS TEST run option%===>_TFST    +N(O) / Y(ES) : this option dumps the\n+                                       terminal QUERY response, and set the\n+                                       SYSOUT queued to your session.\n+            SYSOUT Class%===>_TFSC    +\n+                  Status%===>_TFSH    +N(OHOLD) / H(OLD)\n+                  Copies%===>_TFSN    +1-100, default is 1\n+             Destination%===>_TFSD    +left blank for LOCAL print\n+\n+\n)INIT\n  .HELP = PAJT3270\n  .CURSOR = TFST\n  &TFST = TRANS (&TFST ' ',NO YES,NO *,*)\n  &TFSC = TRANS (&TFSC ' ',A *,*)\n  &TFSH = TRANS (&TFSH ' ',NOHOLD *,*)\n  &TFSN = TRANS (&TFSN ' ',1 *,*)\n)PROC\n  &TFST = TRUNC (&TFST,1)\n  &TFST = TRANS (&TFST ' ',NO N,NO Y,YES *,*)\n  VER (&TFST,LIST,NO,YES)\n  IF (&TFST = YES)\n    &TFSC = TRUNC (&TFSC,1)\n    VER (&TFSC,NONBLANK)\n    &TFSH = TRUNC (&TFSH,1)\n    &TFSH = TRANS (&TFSH H,HOLD N,NOHOLD *,*)\n    VER (&TFSH,LIST,HOLD,NOHOLD)\n    &TFSN = TRANS (&TFSN ' ',1 *,*)\n    VER (&TFSN,RANGE,1,100)\n  &SEL = 'CMD(%PAJC3270) '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PARA": {"ttr": 30480, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x8f\\x00\\x93'\\x8f\\x16B\\x04%\\x04%\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-10-05T00:00:00", "modifydate": "1993-10-05T16:42:00", "lines": 1061, "newlines": 1061, "modlines": 0, "user": "SYSPAJA"}, "text": "/* ---------------------------- P A R A --------------------------- */\n/*            P A R A G R A P H     R E F O R M A T T E R           */\n/* ================================================================ */\n/*                HOUSTON INFORMATION PROCESSING CENTER             */\n/*                  OPERATING SYSTEMS SOFTWARE GROUP                */\n/* ================================================================ */\n/*  MACRO NAME : PARA                                               */\n/*    FUNCTION : REFORMATS TEXT PARAGRAPHS                          */\n/*      SYNTAX : ITS OPERATING PARAMETERS ARE SPECIFIED BY          */\n/*               KEYWORD=VALUE COMBINATIONS AND/OR KEYWORDS         */\n/*               EXAMPLE : PARA OL=13 NL=14 NJ                      */\n/*      ORIGIN : CBT TAPE 91 MAR, FILE 95                           */\n/*      AUTHOR : BERRYHILL M.G. (09/17/86)                          */\n/*               09/29/86 - ADD RH, PROF PARAMETERS                 */\n/*               10/01/86 - FIX ADJUST VALUES                       */\n/*               10/16/86 - SPEEDUP MODS, FIX CENTERING FUNCTION    */\n/*               10/29/86 - ADD LC, FIX CENTERING FUNCTION          */\n/*      UPDATE : MOINIL P.A. (09 AUG 1991)                          */\n/*      UPDATE : MOINIL P.A. (27 SEP 1993)                          */\n/*               IF THERE ARE NO USER-CODED PARAMETERS, THEN        */\n/*               PROMPT THE USER TO SUPPLY THEM THROUGH A PANEL,    */\n/*               IT'S MORE EASY FOR HIM.                            */\n/*      UPDATE : MOINIL P.A. (30 SEP 1993)                          */\n/*               ALLOW USER TO REDEFINE THE END-OF-SENTENCE         */\n/*               CHARACTERS THROUGH THE PROMPTING PANEL.            */\n/*      UPDATE : MOINIL P.A. (05 OCT 1993)                          */\n/*               WHEN LOWER CASE REQUESTED, RECOGNIZE THE WORD I    */\n/*               AND AT END RETAIN CAPS OFF.                        */\n/* ================================================================ */\n/* THESE PARA PARAMETERS (KEYWORDS) WILL BE REMEMBERED THROUGHOUT A */\n/* A SESSION, NO RETYPING UNLESS YOU WANT TO CHANGE A PARAMETER :   */\n/*   OL=NN  DEFINES PARAGRAPH'S OLD LEFT MARGIN                     */\n/*   NL=NN  DEFINES PARAGRAPH'S NEW LEFT MARGIN                     */\n/*   OR=NN  DEFINES PARAGRAPH'S OLD RIGHT MARGIN                    */\n/*   NR=NN  DEFINES PARAGRAPH'S NEW RIGHT MARGIN                    */\n/*   I=NN   DEFINES PARAGRAPH'S INDENTATION OF FIRST LINE           */\n/*   D      MEANS DOUBLE SPACE AT END OF SENTENCE                   */\n/*   ND     MEANS NO DOUBLE SPACE AT END OF SENTENCE (SINGLE SPACE) */\n/*   J      MEANS RIGHT JUSTIFICATION OF PARAGRAPH                  */\n/*   NJ     MEANS NO RIGHT JUSTIFICATION OF PARAGRAPH               */\n/* THESE PARA PARAMETERS ARE IN EFFECT FOR ONE EXECUTION ONLY :     */\n/*   C      MEANS CENTERING OF PARAGRAPH                            */\n/*   NC     MEANS NO CENTERING OF PARAGRAPH                         */\n/*   ?      MEANS DISPLAY PARAMETER VALUES                          */\n/*   H(ELP) MEANS DISPLAY HELP INFORMATION                          */\n/*   RH     MEANS REMOVE WORD HYPHENATION                           */\n/*   LC     MEANS CHANGE TO LOWER CASE                              */\n/*   P(ROF) MEANS STORE PARA PARAMETERS IN YOUR PROFILE DSN         */\n/*   S(HAR) MEANS STORE PARA PARAMETERS IN SHARED VARIABLE POOL     */\n/*   LIST   DEBUG REQUESTED                                         */\n/* ================================================================ */\n  SET &STIME = &SYSTIME\n  SET &SCPU  = &SYSCPU\n  SET &SSRV  = &SYSSRV\nISREDIT  MACRO (P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12) NOPROCESS\n/* PHASE 1 : PROCESS PARAMETERS ----------------------------------- */\n/*           PARA WILL STORE ITS VARIABLES IN EITHER THE SHARED     */\n/*           VARIABLE POOL (DEFAULT), OR IN THE PROFILE VARIABLE    */\n/*           POOL. A VARIABLE, PARAP, IN THE PROFILE VARIABLE POOL  */\n/*           \"REMEMBERS\" THE USER'S CHOICE. IF PARAP IS NOT FOUND,  */\n/*           THE SHARED VARIABLE POOL IS ASSUMED.                   */\n/*           THE PARA PARAMETERS ARE GOTTEN FROM THE APPROPRIATE    */\n/*           VARIABLE POOL. IF NOT FOUND, DEFAULTS ARE CREATED      */\n/*           BASED ON DISPLAY COLUMNS.                              */\n  ISPEXEC VGET (PARAP) PROFILE\n  IF &LASTCC \u00ac= 0 THEN SET &PARAP = &STR(S)\n  SET &POOL = &STR(SHARED)\n  IF &STR(&PARAP) = &STR(P) THEN SET &POOL = &STR(PROFILE)\n  ISPEXEC VGET +\n    (PARAOL,PARANL,PARAOR,PARANR,PARAD,PARAI,PARAJ,PARAES) &POOL\n  IF &LASTCC \u00ac= 0 THEN DO\n    SET &PARAI = 0\n    SET &PARAJ = &STR(J)\n    SET &PARAD = &STR(D)\n    ISREDIT (PARAOL,PARAOR) = DISPLAY_COLS\n    SET &PARANL = &PARAOL\n    SET &PARANR = &PARAOR\n    SET &PARAES = &NRSTR(.|?:\")\n    END\n  SET &PARAC = &STR(NC)\n  SET &PARAL = &STR(NL)\n  SET &PARAH = &STR(NH)\n  SET &PARAQ = &STR(N?)\n  SET &PARAR = &STR(KH)\n  SET &PARAT = &STR(NT)\n  ISREDIT (MAXCOL) = DATA_WIDTH\n/* PROBLEM : THE COLS LINE COMMAND DISPLAYS RECORD COLUMN NUMBERS,  */\n/*           WHILE INTERNAL PARA PROCESSING IS BASED ON DATA COLUMN */\n/*           NUMBERS. IF NUMBER=ON, RECORD COLUMN NUMBERS DO NOT    */\n/*           MATCH DATA COLUMN NUMBERS FOR CERTAIN DATASET TYPES    */\n/*           AND RECORD FORMATS. SEE EDIT COMMAND INTHE SPF/PDF     */\n/*           REFERENCE MANUAL FOR MORE INFORMATION. SINCE THE USER  */\n/*           WILL BE CODING PARAMETERS IN TERMS OF RECORD COLUMN    */\n/*           NUMBERS, AN ADJUSTMENT VALUE MUST BE CALCULATED.       */\n  SET &ADJUST = 0\n  ISREDIT (NUMPARM1,NUMPARM2) = NUMBER\n  IF &STR(&NUMPARM1) = &STR(ON) THEN DO\n    IF &SUBSTR(9:13,&NUMPARM2) \u00ac= &STR(COBOL) THEN DO\n      ISREDIT (FRECFM) = RECFM\n      IF &STR(&FRECFM) = &STR(V) THEN SET &ADJUST = 8\n      END\n    ELSE SET &ADJUST = 6\n    END\n  IF &P1 = &Z THEN GOTO USPP\n  ELSE IF ((&P1 = &STR(T)) AND (&P2 = &Z)) THEN DO\n    SET &PARAT = &STR(T)\n    SET &P1 = &Z\n    GOTO USPP\n    END\n  ELSE SET &SWP = &STR(NO)\n/*           SCAN THE USER-CODED PARAMETERS, EXTRACTING VALUES AND  */\n/*           ADJUSTING THE PARA OPERATING PARAMETERS.               */\nBACK: +\n  ISREDIT SCAN = OFF\n  SET &L = &STR(&&P)\n  ISREDIT SCAN = ON\n  SET &S = 1\n  DO WHILE (&S \u00ac> 12)\n    SET &PARM = &STR(&L&S)\n    SET &S = &S + 1\n    IF &STR(&PARM) \u00ac= &Z THEN DO\n      SET &PARMLEN = &LENGTH(&STR(&PARM))\n      SET &KEYLEN = &PARMLEN\n      IF &KEYLEN > 3 THEN SET &KEYLEN = 3\n      SET &KEYWORD = &SUBSTR(1:&KEYLEN,&PARM)\n      IF &KEYLEN > 2 THEN SET &KEYLEN = 2\n      SET &IKEY = &SUBSTR(1:&KEYLEN,&PARM)\n      IF &STR(&KEYWORD) = &STR(NL=) THEN DO\n        IF &PARMLEN < 4 THEN GOTO MSG1\n        SET &PARANL = &SUBSTR(4:&PARMLEN,&PARM)\n        IF &DATATYPE(&PARANL) \u00ac= NUM THEN GOTO MSG1\n        SET &PARANL = &PARANL - &ADJUST\n        IF &PARANL < 1 THEN GOTO MSG1\n        IF &PARANL > &MAXCOL THEN GOTO MSG1\n        END\n      ELSE IF &STR(&KEYWORD) = &STR(NR=) THEN DO\n        IF &PARMLEN < 4 THEN GOTO MSG1\n        SET &PARANR = &SUBSTR(4:&PARMLEN,&PARM)\n        IF &DATATYPE(&PARANR) \u00ac= NUM THEN GOTO MSG1\n        SET &PARANR = &PARANR - &ADJUST\n        IF &PARANR < 1 THEN GOTO MSG1\n        IF &PARANR > &MAXCOL THEN GOTO MSG1\n        END\n      ELSE IF &STR(&PARM) = &STR(?) THEN SET &PARAQ = &STR(?)\n      ELSE IF &STR(&IKEY) = &STR(I=) THEN DO\n        IF &PARMLEN < 3 THEN GOTO MSG1\n        SET &PARAI = &SUBSTR(3:&PARMLEN,&PARM)\n        IF &DATATYPE(&PARAI) \u00ac= NUM THEN GOTO MSG1\n        END\n      ELSE IF &STR(&KEYWORD) = &STR(OL=) THEN DO\n        IF &PARMLEN < 4 THEN GOTO MSG1\n        SET &PARAOL = &SUBSTR(4:&PARMLEN,&PARM)\n        IF &DATATYPE(&PARAOL) \u00ac= NUM THEN GOTO MSG1\n        SET &PARAOL = &PARAOL - &ADJUST\n        IF &PARAOL < 1 THEN GOTO MSG1\n        IF &PARAOL > &MAXCOL THEN GOTO MSG1\n        END\n      ELSE IF &STR(&KEYWORD) = &STR(OR=) THEN DO\n        IF &PARMLEN < 4 THEN GOTO MSG1\n        SET &PARAOR = &SUBSTR(4:&PARMLEN,&PARM)\n        IF &DATATYPE(&PARAOR) \u00ac= NUM THEN GOTO MSG1\n        SET &PARAOR = &PARAOR - &ADJUST\n        IF &PARAOR < 1 THEN GOTO MSG1\n        IF &PARAOR > &MAXCOL THEN GOTO MSG1\n        END\n      ELSE IF &STR(&PARM) = &STR(NJ) THEN SET &PARAJ = &STR(NJ)\n      ELSE IF &STR(&PARM) = &STR(J) THEN SET &PARAJ = &STR(J)\n      ELSE IF &STR(&PARM) = &STR(ND) THEN SET &PARAD = &STR(ND)\n      ELSE IF &STR(&PARM) = &STR(D) THEN SET &PARAD = &STR(D)\n      ELSE IF &STR(&PARM) = &STR(NC) THEN SET &PARAC = &STR(NC)\n      ELSE IF &STR(&PARM) = &STR(C) THEN SET &PARAC = &STR(C)\n      ELSE IF &STR(&PARM) = &STR(H) THEN SET &PARAH = &STR(H)\n      ELSE IF &STR(&PARM) = &STR(HELP) THEN SET &PARAH = &STR(H)\n      ELSE IF &STR(&PARM) = &STR(LIST) THEN SET &PARAT = &STR(T)\n      ELSE IF &STR(&PARM) = &STR(RH) THEN SET &PARAR = &STR(RH)\n      ELSE IF &STR(&PARM) = &STR(LC) THEN SET &PARAL = &STR(LC)\n      ELSE IF &STR(&PARM) = &STR(P) THEN SET &PARAP = &STR(P)\n      ELSE IF &STR(&PARM) = &STR(PROF) THEN SET &PARAP = &STR(P)\n      ELSE IF &STR(&PARM) = &STR(S) THEN SET &PARAP = &STR(S)\n      ELSE IF &STR(&PARM) = &STR(SHAR) THEN SET &PARAP = &STR(S)\n      ELSE GOTO MSG1\n      END\n    ELSE SET &S = 13\n    END\n  SET &PARM = &STR(I,NL CONFLICT)\n  SET &P1 = &PARANL + &PARAI\n  IF &P1 < 1 THEN GOTO MSG1\n  IF &P1 > &MAXCOL THEN GOTO MSG1\n  SET &PARM = &STR(NL,NR CONFLICT)\n  IF &PARANL \u00ac< &PARANR THEN GOTO MSG1\n  SET &PARM = &STR(OL,OR CONFLICT)\n  IF &PARAOL \u00ac< &PARAOR THEN GOTO MSG1\n  ISPEXEC VPUT (PARAP) PROFILE\n  SET &POOL = &STR(SHARED)\n  IF &STR(&PARAP) = &STR(P) THEN SET &POOL = &STR(PROFILE)\n  ISPEXEC VPUT +\n    (PARAOL,PARANL,PARAOR,PARANR,PARAD,PARAI,PARAJ,PARAES) &POOL\n  SET &MAXLEN = &PARANR - &PARANL + 1\n  SET &FUNC = &STR(1)\n  IF &STR(&PARAC) = &STR(C) THEN SET &FUNC = &STR(2)\n  IF &STR(&PARAH) = &STR(H) THEN SET &FUNC = &STR(3)\n  IF &STR(&PARAQ) = &STR(?) THEN SET &FUNC = &STR(4)\n  IF &STR(&PARAT) = &STR(T) THEN +\n    CONTROL MSG LIST PROMPT CONLIST SYMLIST\n  CONTROL ASIS\n  ISREDIT (STATUS) = USER_STATE\n  ISREDIT CAPS = OFF\n/* PHASE 2 : PROCESS COMMAND -------------------------------------- */\n/* ---- FUNCTION 1 - REFORMAT PARAGRAPH                             */\n/*           SECTION  1 - READ LINES, EXTRACT RIGHT MARGINS, WORDS, */\n/*                        AND LEFT MARGINS.                         */\n/*                        INITIALIZATION.                           */\n  IF &STR(&FUNC) = &STR(1) THEN DO\n    ISPEXEC CONTROL ERRORS RETURN\n    ISREDIT PROCESS RANGE C\n    SET LCC = &LASTCC\n    ISREDIT (RC) = RANGE_CMD\n    SET RCC = &LASTCC\n    ISPEXEC CONTROL ERRORS CANCEL\n    IF &LCC \u00ac= 0 OR &RCC \u00ac= 0 THEN GOTO MSG2\n    ISREDIT (FLNUM) = LINENUM .ZFRANGE\n    ISREDIT (LLNUM) = LINENUM .ZLRANGE\n    SET &LLCHK = &LLNUM\n    ISREDIT LABEL &FLNUM = .BEGINC\n    SET &BEGINL = &STR(.BEGINC)\n    IF &FLNUM \u00ac= &LLNUM THEN DO\n      ISREDIT LABEL &LLNUM = .ENDC\n      SET &ENDL = &STR(.ENDC)\n      END\n    ELSE SET &ENDL = &STR(.BEGINC)\n    ISREDIT C X'50' X'FA' &BEGINL &ENDL ALL\n    ISREDIT C X'7D' X'FB' &BEGINL &ENDL ALL\n    SET &ILCNT = &LLNUM - &FLNUM + 1\n    SET &IWCNT = 0\n    ISPEXEC VGET (ZUSER)\n    ISPEXEC TBCREATE &ZUSER.W NAMES(WORD,WORDLEN) NOWRITE\n    IF &LASTCC \u00ac= 0 THEN DO\n      ISPEXEC TBEND &ZUSER.W\n      ISPEXEC TBCREATE &ZUSER.W NAMES(WORD,WORDLEN) NOWRITE\n      END\n    ISPEXEC TBCREATE &ZUSER.L NAMES(LMARGIN,RMARGIN,LNUM) NOWRITE\n    IF &LASTCC \u00ac= 0 THEN DO\n      ISPEXEC TBEND &ZUSER.L\n      ISPEXEC TBCREATE &ZUSER.L NAMES(LMARGIN,RMARGIN,LNUM) NOWRITE\n      END\n    SET &LPAD = &Z\n    SET &LSTOP = &PARANL - 1\n    IF &PARAOL < &PARANL THEN DO\n      SET &LSTOP = &PARAOL - 1\n      SET &S = 0\n      SET &L = &PARANL - &PARAOL\n      DO WHILE (&S < &L)\n        SET &S = &S + 1\n        SET &LPAD = &STR(&LPAD )\n        END\n      END\n    SET &RPAD = &Z\n    SET &RSTOP = &PARANR + 1\n    IF &PARAOR > &PARANR THEN DO\n      SET &RSTOP = &PARAOR + 1\n      SET &S = 0\n      SET &L = &PARAOR - &PARANR\n      DO WHILE (&S < &L)\n        SET &S = &S + 1\n        SET &RPAD = &STR(&RPAD )\n        END\n      END\n    SET &WLNUM = &FLNUM\n    DO WHILE (&WLNUM \u00ac> &LLNUM)\n      ISREDIT (WLINE) = LINE &WLNUM\n      SET &LNUM = &WLNUM\n      SET &WLNUM = &WLNUM + 1\n      SET &LMARGIN = &Z\n      IF &LSTOP > 0 THEN SET &LMARGIN = &SUBSTR(1:&LSTOP,&WLINE)\n      SET &LMARGIN = &STR(&LMARGIN&LPAD)\n      SET &RMARGIN = &Z\n      IF &RSTOP <= &MAXCOL THEN +\n        SET &RMARGIN = &SUBSTR(&RSTOP:&MAXCOL,&WLINE)\n      ISPEXEC TBADD &ZUSER.L\n      SET &S = &PARAOL\n      DO WHILE (&S \u00ac> &PARAOR)\n        SET &TS = &SUBSTR(&S,&WLINE)\n        DO WHILE (&STR(&TS) = &STR( ))\n          SET &S = &S + 1\n          IF &S \u00ac> &PARAOR THEN SET &TS = &SUBSTR(&S,&WLINE)\n          ELSE SET &TS = &STR(X)\n          END\n        IF &S \u00ac> &PARAOR THEN DO\n          SET &SOW = &S\n          DO WHILE (&STR(&TS) \u00ac= &STR( ))\n            SET &S = &S + 1\n            IF &S \u00ac> &PARAOR THEN SET &TS = &SUBSTR(&S,&WLINE)\n            ELSE SET &TS = &STR( )\n            END\n          SET &WORD = &SUBSTR(&SOW:&S-1,&WLINE)\n          SET &WORDLEN = &LENGTH(&STR(&WORD))\n          ISPEXEC TBADD &ZUSER.W\n          SET &IWCNT = &IWCNT + 1\n          END\n        END\n      END\n/*           SECTION  2 - MANIPULATE EXTRACTED WORDS AND LEFT       */\n/*                        MARGINS. IF DESIRED, REMOVE HYPHENS AND   */\n/*                        REBUILD WORD. WHY REMOVE HYPHENS?         */\n/*                        SUPPOSE NL/NR MISCODED PREVIOUSLY, TOO    */\n/*                        SHORT. NEXT ROUTINE WOULD HAVE SPLIT AND  */\n/*                        HYPHENATED WORDS PREVIOUSLY.              */\n/*                        THIS RECOVERS EASILY.                     */\n    IF &STR(&PARAR) = &STR(RH) THEN DO\n      ISPEXEC TBTOP &ZUSER.W\n      SET &EOTWRD = 0\n      ISPEXEC TBSKIP &ZUSER.W\n      IF &LASTCC \u00ac= 0 THEN SET &EOTWRD = 1\n      DO WHILE (&EOTWRD = 0)\n        IF &WORDLEN > 1 THEN DO\n          SET &P1 = &SUBSTR(&WORDLEN,&WORD)\n          IF &STR(&P1) = &STR(-) THEN DO\n            SET &P2 = &WORDLEN - 1\n            SET &P3 = &SUBSTR(1:&P2,&WORD)\n            ISPEXEC TBSKIP &ZUSER.W\n            IF &LASTCC = 0 THEN DO\n              SET &WORD = &STR(&P3&WORD)\n              SET &WORDLEN = &WORDLEN + &P2\n              ISPEXEC TBPUT &ZUSER.W\n              ISPEXEC TBSKIP &ZUSER.W NUMBER(-1)\n              ISPEXEC TBDELETE &ZUSER.W\n              SET &IWCNT = &IWCNT - 1\n              ISPEXEC TBSKIP &ZUSER.W\n              END\n            ELSE SET &EOTWRD = 1\n            END\n          ELSE DO\n            ISPEXEC TBSKIP &ZUSER.W\n            IF &LASTCC \u00ac= 0 THEN SET &EOTWRD = 1\n            END\n          END\n        ELSE DO\n          ISPEXEC TBSKIP &ZUSER.W\n          IF &LASTCC \u00ac= 0 THEN SET &EOTWRD = 1\n          END\n        END\n      SET &EOTWRD = 0\n      ISPEXEC TBBOTTOM &ZUSER.W\n      IF &LASTCC \u00ac= 0 THEN SET &EOTWRD = 1\n      DO WHILE (&EOTWRD = 0)\n        IF &WORDLEN > 1 THEN DO\n          SET &P1 = &SUBSTR(1,&WORD)\n          IF &STR(&P1) = &STR(-) THEN DO\n            SET &P2 = &WORDLEN - 1\n            SET &P3 = &SUBSTR(2:&WORDLEN,&WORD)\n            ISPEXEC TBSKIP &ZUSER.W NUMBER(-1)\n            IF &LASTCC = 0 THEN DO\n              SET &WORD = &STR(&WORD&P3)\n              SET &WORDLEN = &WORDLEN + &P2\n              ISPEXEC TBPUT &ZUSER.W\n              ISPEXEC TBSKIP &ZUSER.W\n              ISPEXEC TBDELETE &ZUSER.W\n              SET &IWCNT = &IWCNT - 1\n              ISPEXEC TBSKIP &ZUSER.W NUMBER(-1)\n              END\n            ELSE SET &EOTWRD = 1\n            END\n          ELSE DO\n            ISPEXEC TBSKIP &ZUSER.W NUMBER(-1)\n            IF &LASTCC \u00ac= 0 THEN SET &EOTWRD = 1\n            END\n          END\n        ELSE DO\n          ISPEXEC TBSKIP &ZUSER.W NUMBER(-1)\n          IF &LASTCC \u00ac= 0 THEN SET &EOTWRD = 1\n          END\n        END\n      END\n/*                        IF A WORD WON'T FIT BETWEEN NL AND NR,    */\n/*                        SPLIT AND HYPHENATE IT.                   */\n/*                        ALSO, DOUBLE SPACE AT END OF SENTENCE.    */\n    SET &P1 = &STR(Y)\n    ISPEXEC TBTOP &ZUSER.W\n    SET &EOTWRD = 0\n    ISPEXEC TBSKIP &ZUSER.W\n    IF &LASTCC \u00ac= 0 THEN SET &EOTWRD = 1\n    DO WHILE (&EOTWRD = 0)\n      IF &STR(&PARAL) = &STR(LC) THEN DO\n        SET &P4 = &STR(N)\n        IF ((&WORDLEN < 3) AND (&STR(&P1) = &STR(N))) THEN DO\n          IF ((&WORDLEN = 1) AND (&STR(&WORD) = &STR(I))) THEN +\n            SET &P4 = &STR(Y)\n          ELSE IF ((&WORDLEN = 2) AND +\n            (&SUBSTR(1,&WORD) = &STR(I))) THEN +\n            IF &SUBSTR(2,&WORD) \u00ac> &STR(\") THEN SET &P4 = &STR(Y)\n          END\n        IF &STR(&P4) = &STR(Y) THEN SET &P1 = &STR(N)\n        ELSE DO\n          SET &WORD = &STR(&SYSLC(&WORD))\n          IF &STR(&P1) = &STR(Y) THEN DO\n            SET &P1 = &STR(N)\n            SET &P2 = &SYSCAPS(&SUBSTR(1,&WORD))\n            SET &P3 = &Z\n            IF &WORDLEN > 1 THEN SET &P3 = &SUBSTR(2:&WORDLEN,&WORD)\n            SET &WORD = &STR(&P2&P3)\n            END\n          END\n        ISPEXEC TBPUT &ZUSER.W\n        END\n      SET &P4 = &SUBSTR(&WORDLEN,&WORD)\n      SET &S = 1\n      SET &SM = &LENGTH(&NRSTR(&IES))\n      DO WHILE (&S \u00ac> &SM)\n        IF &SUBSTR(&S,&NRSTR(&IES)) = &STR( ) THEN SET &S = &SM + 1\n        ELSE IF &STR(&P4) = &SUBSTR(&S,&NRSTR(&IES)) THEN DO\n          SET &P1 = &STR(Y)\n          IF &STR(&PARAD) = &STR(D) THEN DO\n            SET &WORD = &STR(&WORD )\n            SET &WORDLEN = &WORDLEN + 1\n            IF &WORDLEN \u00ac> &MAXLEN THEN ISPEXEC TBPUT &ZUSER.W\n            END\n          SET &S = &SM + 1\n          END\n        ELSE SET &S = &S + 1\n        END\n      IF &WORDLEN > &MAXLEN THEN DO\n        SET &P4 = &SUBSTR(&MAXLEN+1:&WORDLEN,&WORD)\n        SET &P4 = &STR(-&P4)\n        SET &WORDLEN = &MAXLEN\n        SET &WORD = &SUBSTR(1:&MAXLEN,&WORD)\n        ISPEXEC TBPUT &ZUSER.W\n        SET &WORD = &STR(&P4)\n        SET &WORDLEN = &LENGTH(&STR(&P4))\n        ISPEXEC TBADD &ZUSER.W\n        SET &IWCNT = &IWCNT + 1\n        ISPEXEC TBSKIP &ZUSER.W NUMBER(-1)\n        END\n      ISPEXEC TBSKIP &ZUSER.W\n      IF &LASTCC \u00ac= 0 THEN SET &EOTWRD = 1\n      END\n/*                        ADJUST LEFT MARGIN FOR INDENTATION.       */\n    ISPEXEC TBTOP &ZUSER.L\n    ISPEXEC TBSKIP &ZUSER.L\n    SET &IPAD = &Z\n    IF &PARAI > 0 THEN DO\n      SET &S = 0\n      DO WHILE (&S < &PARAI)\n        SET &S = &S + 1\n        SET &IPAD = &STR(&IPAD )\n        END\n      END\n    IF &PARAI < 0 THEN DO\n      SET &S = &PARANL + &PARAI - 1\n      SET &LMARGIN = &SUBSTR(1:&S,&LMARGIN)\n      END\n    SET &LMARGIN = &STR(&LMARGIN&IPAD)\n    ISPEXEC TBPUT &ZUSER.L\n/*           SECTION  3 - REBUILD PARAGRAPH.                        */\n/*                        READ LINE TABLE AND WORD TABLE, MERGING   */\n/*                        BOTH TO CREATE NEW LINE.                  */\n    SET &OLCNT  = 0\n    SET &OWCNT  = 0\n    SET &EOTLIN = 0\n    SET &EOTWRD = 0\n    ISPEXEC TBTOP &ZUSER.W\n    ISPEXEC TBTOP &ZUSER.L\n    ISPEXEC TBSKIP &ZUSER.L\n    IF &LASTCC > 0 THEN SET &EOTLIN = 1\n    DO WHILE (&EOTLIN = 0)\n      SET &WORKSTG = &STR(&LMARGIN)\n      SET &WORKLEN = &LENGTH(&STR(&WORKSTG))\n      SET &EOSLIN = 0\n      SET &WRDCNT = 0\n      IF &EOTWRD = 0 THEN DO\n        ISPEXEC TBSKIP &ZUSER.W\n        IF &LASTCC \u00ac= 0 THEN DO\n          SET &EOTWRD = 1\n          SET &EOSLIN = 1\n          END\n        DO WHILE (&EOSLIN = 0)\n          SET &WORKLEN = &WORKLEN + &WORDLEN\n          IF &WORKLEN < &PARANR THEN DO\n            SET &OWCNT  = &OWCNT  + 1\n            SET &WRDCNT = &WRDCNT + 1\n            SET &WORKLEN = &WORKLEN + 1\n            SET &WORKSTG = &STR(&WORKSTG&WORD )\n            END\n          ELSE IF &WORKLEN > &PARANR THEN DO\n            SET &WORKLEN = &WORKLEN - &WORDLEN\n            SET &EOSLIN = 1\n            ISPEXEC TBSKIP &ZUSER.W NUMBER(-1)\n            END\n          ELSE IF &WORKLEN = &PARANR THEN DO\n            SET &OWCNT  = &OWCNT  + 1\n            SET &WRDCNT = &WRDCNT + 1\n            SET &WORKSTG = &STR(&WORKSTG&WORD)\n            SET &EOSLIN = 1\n            END\n          IF &EOSLIN = 0 THEN DO\n            ISPEXEC TBSKIP &ZUSER.W\n            IF &LASTCC \u00ac= 0 THEN DO\n              SET &EOTWRD = 1\n              SET &EOSLIN = 1\n              END\n            END\n          END\n        END\n      IF &STR(&PARAJ) = &STR(J) THEN +\n        IF &EOTWRD = 0 THEN DO\n          DO WHILE (&SUBSTR(&WORKLEN,&WORKSTG) = &STR( ))\n            SET &WORKLEN = &WORKLEN - 1\n            SET &WORKSTG = &SUBSTR(1:&WORKLEN,&WORKSTG)\n            END\n          SET &WRDCNT = &WRDCNT - 1\n          IF &WRDCNT \u00ac> 0 THEN DO\n            DO WHILE (&WORKLEN < &PARANR)\n              SET &WORKLEN = &WORKLEN + 1\n              SET &WORKSTG = &STR(&WORKSTG )\n              END\n            END\n          SET &SPCADD = &PARANR - &WORKLEN\n          DO WHILE (&SPCADD > &WRDCNT)\n            SET &S = &LENGTH(&STR(&LMARGIN)) + 1\n            SET &P1 = 0\n            DO WHILE (&P1 < &WRDCNT)\n              DO WHILE (&SUBSTR(&S,&WORKSTG) \u00ac= &STR( ))\n                SET &S = &S + 1\n                END\n              SET &P2 = &SUBSTR(1:&S-1,&WORKSTG)\n              SET &P3 = &SUBSTR(&S:&WORKLEN,&WORKSTG)\n              SET &WORKLEN = &WORKLEN + 1\n              SET &WORKSTG = &STR(&P2 &P3)\n              SET &SPCADD = &SPCADD - 1\n              DO WHILE (&SUBSTR(&S,&WORKSTG) = &STR( ))\n                SET &S = &S + 1\n                END\n              SET &P1 = &P1 + 1\n              END\n            END\n          IF &SPCADD > 0 THEN DO\n            SET &S = &LENGTH(&STR(&LMARGIN)) + 1\n            SET &P1 = (&WRDCNT - &SPCADD) / 2\n            DO WHILE (&P1 > 0)\n              DO WHILE (&SUBSTR(&S,&WORKSTG) \u00ac= &STR( ))\n                SET &S = &S + 1\n                END\n              DO WHILE (&SUBSTR(&S,&WORKSTG)  = &STR( ))\n                SET &S = &S + 1\n                END\n              SET &P1 = &P1 - 1\n              END\n            DO WHILE (&SPCADD > 0)\n              DO WHILE (&SUBSTR(&S,&WORKSTG) \u00ac= &STR( ))\n                SET &S = &S + 1\n                END\n              SET &P1 = &SUBSTR(1:&S-1,&WORKSTG)\n              SET &P2 = &SUBSTR(&S:&WORKLEN,&WORKSTG)\n              SET &WORKLEN = &WORKLEN + 1\n              SET &WORKSTG = &STR(&P1 &P2)\n              SET &SPCADD = &SPCADD - 1\n              DO WHILE (&SUBSTR(&S,&WORKSTG) = &STR( ))\n                SET &S = &S + 1\n                END\n              END\n            END\n          END\n        ELSE DO WHILE (&WORKLEN < &PARANR)\n          SET &WORKLEN = &WORKLEN + 1\n          SET &WORKSTG = &STR(&WORKSTG )\n          END\n      IF &STR(&PARAJ) = &STR(NJ) THEN +\n        DO WHILE (&WORKLEN < &PARANR)\n          SET &WORKLEN = &WORKLEN + 1\n          SET &WORKSTG = &STR(&WORKSTG )\n          END\n      SET &WORKSTG = &STR(&WORKSTG&RPAD&RMARGIN)\n      ISREDIT LINE &LNUM = (WORKSTG)\n      SET &OLCNT = &OLCNT + 1\n      ISPEXEC TBSKIP &ZUSER.L\n      IF &LASTCC > 0 THEN SET &EOTLIN = 1\n      END\n/*                        LINE TABLE AT END, WORD TABLE NOT AT END. */\n/*                        READ WORD TABLE, CREATE  NEW LINES.       */\n    IF &EOTWRD = 0 THEN DO\n      SET &LMARGIN = &Z\n      SET &S = 0\n      SET &LSTOP = &PARANL - 1\n      DO WHILE (&S < &LSTOP)\n        SET &LMARGIN = &STR(&LMARGIN )\n        SET &S = &S + 1\n        END\n      SET &RMARGIN = &Z\n      SET &S = 0\n      SET &RSTOP = &MAXCOL - &PARANR\n      DO WHILE (&S < &RSTOP)\n        SET &RMARGIN = &STR(&RMARGIN )\n        SET &S = &S + 1\n        END\n      ISPEXEC TBSKIP &ZUSER.W\n      IF &LASTCC \u00ac= 0 THEN DO\n        SET &EOTWRD = 1\n        SET &EOSLIN = 1\n        END\n      DO WHILE (&EOTWRD = 0)\n        SET &WORKSTG = &STR(&LMARGIN)\n        SET &WORKLEN = &LENGTH(&STR(&LMARGIN))\n        SET &EOSLIN = 0\n        SET &WRDCNT = 0\n        DO WHILE (&EOSLIN = 0)\n          SET &WORKLEN = &WORKLEN + &WORDLEN\n          IF &WORKLEN < &PARANR THEN DO\n            SET &OWCNT  = &OWCNT + 1\n            SET &WRDCNT = &WRDCNT + 1\n            SET &WORKLEN = &WORKLEN + 1\n            SET &WORKSTG = &STR(&WORKSTG&WORD )\n            END\n          ELSE IF &WORKLEN > &PARANR THEN DO\n            SET &WORKLEN = &WORKLEN - &WORDLEN\n            SET &EOSLIN = 1\n            ISPEXEC TBSKIP &ZUSER.W NUMBER(-1)\n            END\n          ELSE IF &WORKLEN = &PARANR THEN DO\n            SET &OWCNT  = &OWCNT + 1\n            SET &WRDCNT = &WRDCNT + 1\n            SET &WORKSTG = &STR(&WORKSTG&WORD)\n            SET &EOSLIN = 1\n            END\n          IF &EOSLIN = 0 THEN DO\n            ISPEXEC TBSKIP &ZUSER.W\n            IF &LASTCC \u00ac= 0 THEN DO\n              SET &EOTWRD = 1\n              SET &EOSLIN = 1\n              END\n            END\n          END\n        IF &STR(&PARAJ) = &STR(J) THEN +\n          IF &EOTWRD = 0 THEN DO\n            DO WHILE (&SUBSTR(&WORKLEN,&WORKSTG) = &STR( ))\n              SET &WORKLEN = &WORKLEN - 1\n              SET &WORKSTG = &SUBSTR(1:&WORKLEN,&WORKSTG)\n              END\n            SET &WRDCNT = &WRDCNT - 1\n            IF &WRDCNT = 0 THEN +\n              DO WHILE (&WORKLEN < &PARANR)\n                SET &WORKLEN = &WORKLEN + 1\n                SET &WORKSTG = &STR(&WORKSTG )\n                END\n            SET &SPCADD = &PARANR - &WORKLEN\n            DO WHILE (&SPCADD > &WRDCNT)\n              SET &S = &LENGTH(&STR(&LMARGIN)) + 1\n              SET &P1 = 0\n              DO WHILE (&P1 < &WRDCNT)\n                DO WHILE (&SUBSTR(&S,&WORKSTG) \u00ac= &STR( ))\n                  SET &S = &S + 1\n                  END\n                SET &P2 = &SUBSTR(1:&S-1,&WORKSTG)\n                SET &P3 = &SUBSTR(&S:&WORKLEN,&WORKSTG)\n                SET &WORKLEN = &WORKLEN + 1\n                SET &WORKSTG = &STR(&P2 &P3)\n                SET &SPCADD = &SPCADD - 1\n                DO WHILE (&SUBSTR(&S,&WORKSTG) = &STR( ))\n                  SET &S = &S + 1\n                  END\n                SET &P1 = &P1 + 1\n                END\n              END\n            IF &SPCADD > 0 THEN DO\n              SET &S = &LENGTH(&STR(&LMARGIN)) + 1\n              SET &P1 = (&WRDCNT - &SPCADD) / 2\n              DO WHILE (&P1 > 0)\n                DO WHILE (&SUBSTR(&S,&WORKSTG) \u00ac= &STR( ))\n                  SET &S = &S + 1\n                  END\n                DO WHILE (&SUBSTR(&S,&WORKSTG)  = &STR( ))\n                  SET &S = &S + 1\n                  END\n                SET &P1 = &P1 - 1\n                END\n              DO WHILE (&SPCADD > 0)\n                DO WHILE (&SUBSTR(&S,&WORKSTG) \u00ac= &STR( ))\n                  SET &S = &S + 1\n                  END\n                SET &P1 = &SUBSTR(1:&S-1,&WORKSTG)\n                SET &P2 = &SUBSTR(&S:&WORKLEN,&WORKSTG)\n                SET &WORKLEN = &WORKLEN + 1\n                SET &WORKSTG = &STR(&P1 &P2)\n                SET &SPCADD = &SPCADD - 1\n                DO WHILE (&SUBSTR(&S,&WORKSTG) = &STR( ))\n                  SET &S = &S + 1\n                  END\n                END\n              END\n            END\n          ELSE DO WHILE (&WORKLEN < &PARANR)\n            SET &WORKLEN = &WORKLEN + 1\n            SET &WORKSTG = &STR(&WORKSTG )\n            END\n        IF &STR(&PARAJ) = &STR(NJ) THEN +\n          DO WHILE (&WORKLEN < &PARANR)\n            SET &WORKLEN = &WORKLEN + 1\n            SET &WORKSTG = &STR(&WORKSTG )\n            END\n        SET &WORKSTG = &STR(&WORKSTG&RMARGIN)\n        ISREDIT LINE_AFTER &LLNUM = DATALINE (WORKSTG)\n        SET &OLCNT  = &OLCNT + 1\n        SET &LLNUM = &LLNUM + 1\n        IF &EOTWRD = 0 THEN DO\n          ISPEXEC TBSKIP &ZUSER.W\n          IF &LASTCC \u00ac= 0 THEN SET &EOTWRD = 1\n          END\n        END\n      END\n    ISPEXEC TBCLOSE &ZUSER.L\n    ISPEXEC TBCLOSE &ZUSER.W\n    IF ((&LLCHK \u00ac= &FLNUM) AND (&LLCHK \u00ac= &LLNUM)) THEN DO\n      ISREDIT LABEL &LLCHK = ' '\n      ISREDIT LABEL &LLNUM = .ENDC\n      END\n    ISREDIT C X'FA' X'50' &BEGINL &ENDL ALL\n    ISREDIT C X'FB' X'7D' &BEGINL &ENDL ALL\n    ISREDIT RESET CHG\n    IF &IWCNT \u00ac= &OWCNT THEN GOTO MSG3\n    IF &ILCNT >  &OLCNT THEN GOTO MSG3\n    END\n/* ---- FUNCTION 2 - CENTER PARAGRAPH                               */\n  IF &STR(&FUNC) = &STR(2) THEN DO\n    ISPEXEC CONTROL ERRORS RETURN\n    ISREDIT PROCESS RANGE C\n    SET LCC = &LASTCC\n    ISREDIT (RC) = RANGE_CMD\n    SET RCC = &LASTCC\n    ISPEXEC CONTROL ERRORS CANCEL\n    IF &LCC \u00ac= 0 OR &RCC \u00ac= 0 THEN GOTO MSG2\n    ISREDIT (FLNUM) = LINENUM .ZFRANGE\n    ISREDIT (LLNUM) = LINENUM .ZLRANGE\n    SET &WLNUM = &FLNUM\n    DO WHILE (&WLNUM \u00ac> &LLNUM)\n      ISREDIT (WLINE) = LINE &WLNUM\n      SET &SOL = 0\n      DO WHILE (&SOL = 0)\n        SET &S = &PARAOL\n        DO WHILE (&S \u00ac> &PARAOR)\n          IF &SUBSTR(&S,&WLINE) \u00ac= &STR( ) THEN DO\n            SET &SOL = &S\n            SET &S = &PARAOR\n            END\n          SET &S = &S + 1\n          END\n        IF &SOL = 0 THEN SET &SOL = -1\n        END\n      IF &SOL > 0 THEN DO\n        SET &EOL = 0\n        DO WHILE (&EOL = 0)\n          SET &S = &PARAOR\n          DO WHILE (&S \u00ac< &PARAOL)\n            IF &SUBSTR(&S,&WLINE) \u00ac= &STR( ) THEN DO\n              SET &EOL = &S\n              SET &S = &PARAOL\n              END\n            SET &S = &S - 1\n            END\n          END\n        SET &LMARGIN = &Z\n        SET &S = &SOL - 1\n        IF &S > 0 THEN SET &LMARGIN = &SUBSTR(1:&S,&WLINE)\n        SET &RMARGIN = &Z\n        SET &S = &EOL + 1\n        IF &S \u00ac> &MAXCOL THEN SET &RMARGIN = &SUBSTR(&S:&MAXCOL,&WLINE)\n        SET &WORKSTG = &SUBSTR(&SOL:&EOL,&WLINE)\n        SET &WORKLEN = &LENGTH(&STR(&WORKSTG))\n        SET &P1 = &PARAOR - &PARAOL + 1\n        IF &P1 > &WORKLEN THEN DO\n          SET &P2 = ((&P1 - &WORKLEN) / 2) + &PARAOL - 1\n          SET &P3 = &LENGTH(&STR(&LMARGIN))\n          SET &P4 = &P2 - &P3\n          IF &P2 < &P3 THEN +\n            IF &P2 > 0 THEN SET &LMARGIN = &SUBSTR(1:&P2,&LMARGIN)\n            ELSE SET &LMARGIN = &Z\n          DO WHILE (&P2 > &P3)\n            SET &LMARGIN = &STR(&LMARGIN )\n            SET &P3 = &P3 + 1\n            END\n          SET &P3 = &LENGTH(&STR(&RMARGIN))\n          IF &P4 > 0 THEN +\n            IF &P3 > 0 THEN SET &RMARGIN = &SUBSTR(&P4+1:&P3,&RMARGIN)\n            ELSE SET &RMARGIN = &Z\n          DO WHILE (&P4 < 0)\n            SET &RMARGIN = &STR( &RMARGIN)\n            SET &P4 = &P4 + 1\n            END\n          SET &WORKSTG = &STR(&LMARGIN&WORKSTG&RMARGIN)\n          ISREDIT LINE &WLNUM = (WORKSTG)\n          END\n        END\n      SET &WLNUM = &WLNUM + 1\n      END\n    END\n/* ---- FUNCTION 3 - HELP                                           */\n  IF &STR(&FUNC) = &STR(3) THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    ISPEXEC CONTROL ERRORS RETURN\n    ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTPAR)\n    SET EMCC = &LASTCC\n    ISPEXEC CONTROL ERRORS CANCEL\n    ISPEXEC CONTROL DISPLAY RESTORE\n    IF &EMCC > 8 THEN GOTO MSG4\n    END\n/* ---- FUNCTION 4 - DISPLAY CURRENT PARA PARAMETERS                */\n  IF &STR(&FUNC) = &STR(4) THEN DO\n    SET &P1 = &STR(SHARED)\n    IF &STR(&PARAP) = &STR(P) THEN SET &P1 = &STR(PROFILE)\n    SET &P2 = &STR(&SYSSTIME :)\n    SET &P3 = &PARAOL + &ADJUST\n    SET &P4 = &PARANL + &ADJUST\n    SET &P5 = &PARAOR + &ADJUST\n    SET &P6 = &PARANR + &ADJUST\n    SET &P7 = &STR(&PARAI)\n    SET &P8 = &STR(&PARAJ)\n    SET &P9 = &STR(&PARAD)\n    SET &P10 = &NRSTR(&PARAES)\n    ISPEXEC CONTROL ERRORS RETURN\n    ISPEXEC DISPLAY PANEL(PAJPARD)\n    SET EMCC = &LASTCC\n    ISPEXEC CONTROL ERRORS CANCEL\n    IF &EMCC > 8 THEN GOTO MSG4\n    END\n/* PHASE 3 : END OF EXECUTION ------------------------------------- */\n  ISREDIT USER_STATE = (STATUS)\n  IF &STR(&FUNC) = &STR(1) THEN DO\n    ISREDIT CURSOR = &BEGINL &PARANL\n    IF &STR(&PARAL) = &STR(LC) THEN ISREDIT CAPS = OFF\n    END\n  SET ZEDSMSG = &STR(PARA : END)\n  IF ((&STR(&FUNC) = &STR(1)) OR +\n    (&STR(&FUNC) = &STR(2))) THEN DO\n    SET &ETIME = &SYSTIME\n    SET &P1 = &SUBSTR(1:2,&ETIME)\n    SET &P2 = &SUBSTR(4:5,&ETIME)\n    SET &P3 = &SUBSTR(7:8,&ETIME)\n    SET &P4 = &SUBSTR(1:2,&STIME)\n    SET &P5 = &SUBSTR(4:5,&STIME)\n    SET &P6 = &SUBSTR(7:8,&STIME)\n    IF &P1 < &P4 THEN SET &P1 = &P1 + 24\n    SET &WTIME = ((&P1 - &P4) * 3600) + ((&P2 - &P5) * 60) + &P3 - &P6\n    SET &ECPU  = &SYSCPU\n    SET &P1 = &LENGTH(&STR(&ECPU))\n    SET &P2 = &LENGTH(&STR(&SCPU))\n    SET &P3 = &SUBSTR(1:&P1-3,&ECPU)\n    SET &P4 = &SUBSTR(1:&P2-3,&SCPU)\n    SET &P5 = &SUBSTR(&P1-1,&P1,&ECPU)\n    SET &P6 = &SUBSTR(&P2-1,&P2,&SCPU)\n    IF &P5 < &P6 THEN DO\n      SET &P5 = &P5 + 100\n      SET &P3 = &P3 - 1\n      END\n    SET &P1 = &P3 - &P4\n    SET &P2 = &P5 - &P6\n    IF &P2 < 10 THEN SET &P2 = &STR(0&P2)\n    SET &WCPU = &STR(&P1..&STR(&P2))\n    SET &WSRV = &SYSSRV - &SSRV\n    SET &P1 = &STR(PARA ENDED NORMALLY. STATISTICS : )\n    SET ZEDLMSG = &STR(&P1 TIME=&WTIME CPU=&WCPU SERVICE=&WSRV)\n    END\n  ELSE SET ZEDLMSG = &STR(PARA ENDED NORMALLY)\n  ISPEXEC SETMSG MSG(ISRZ000)\n  EXIT CODE(0)\n/* ERROR TERMINATION ---------------------------------------------- */\nMSG1: +\n  SET ZEDSMSG = &STR(INVALID : &PARM)\n  SET ZEDLMSG = &STR(INVALID KEYWORD PARAMETER OR KEYWORD VALUE)\n  ISPEXEC SETMSG MSG(ISRZ001)\n  IF &SWP = &STR(YES) THEN GOTO LOOP\n  EXIT CODE(16)\nMSG2: +\n  IF &RCC = 4 THEN DO\n    IF &STR(&RC) \u00ac= &STR(C) THEN DO\n      IF &LCC = 4 THEN SET ZEDSMSG = &STR(NO RANGE)\n      ELSE SET ZEDSMSG = &STR(INVALID RANGE)\n      SET ZEDLMSG = &STR(YOU MUST SPECIFY A TARGET RANGE OF +\n                         LINES, USING \"CN\" OR \"CC\")\n      END\n    ELSE DO\n      SET ZEDSMSG = &STR(RANGE INCOMPLETE)\n      SET ZEDLMSG = &STR(ENTER A MATCHING \"CC\" TO COMPLETE +\n                         THE BLOCK COMMAND PAIR)\n      END\n    END\n  ELSE IF &RCC = 8 THEN DO\n    SET ZEDSMSG = &STR(NOT ACCEPTABLE)\n    SET ZEDLMSG = &STR(AN UNACCEPTABLE TARGET RANGE OF LINES +\n                       HAS BEEN SPECIFIED)\n    END\n  ELSE DO\n    SET ZEDSMSG = &STR(SEVERE ERROR)\n    SET ZEDLMSG = &STR(SEVERE ERROR OCCURED, RETURN CODES ARE +\n                       &LCC AND &RCC)\n    END\n  ISPEXEC SETMSG MSG(ISRZ001)\n  EXIT CODE(16)\nMSG3: +\n  SET &P1 = &STR(PARA LOGIC ERROR, INPUT WORDS=&IWCNT LINES=&ILCNT)\n  SET &P1 = &STR(&P1, OUTPUT WORDS=&OWCNT LINES=&OLCNT)\n  ISREDIT LINE_AFTER &FLNUM = MSGLINE (P1)\n  EXIT CODE(16)\nMSG4: +\n  SET ZEDSMSG = &STR(ERROR RC=&EMCC)\n  SET ZEDLMSG = &STR(EXIT DUE TO DISPLAY ERROR ENCOUNTERED)\n  ISPEXEC SETMSG MSG(ISRZ001)\n  EXIT CODE(16)\nMSG5: +\n  SET ZEDSMSG = &STR(END RC=&EMCC)\n  SET ZEDLMSG = &STR(EXECUTION STOP DUE TO USER REQUEST)\n  ISPEXEC SETMSG MSG(ISRZ001)\n  EXIT CODE(16)\nLOOP: +\n  SET &S = 1\n  DO WHILE (&S \u00ac> 12)\n    SET P&S = &Z\n    SET &S = &S + 1\n    END\nUSPP: +\n  SET &SWP = &STR(YES)\n  SET &U0 = &MAXCOL\n  IF &STR(&PARAP) = &STR(P) THEN SET &O1 = &STR(PROFILE)\n  ELSE SET &O1 = &STR(SHARED)\n  SET &O2 = &PARAOL\n  SET &O3 = &PARANL\n  SET &O4 = &PARAOR\n  SET &O5 = &PARANR\n  SET &O6 = &PARAI\n  IF &STR(&PARAJ) = &STR(J) THEN SET &O7 = &STR(YES)\n  ELSE SET &O7 = &STR(NO)\n  IF &STR(&PARAD) = &STR(D) THEN SET &O8 = &STR(YES)\n  ELSE SET &O8 = &STR(NO)\n  IF &STR(&PARAL) = &STR(LC) THEN SET &O9 = &STR(YES)\n  ELSE SET &O9 = &STR(NO)\n  IF &STR(&PARAR) = &STR(RH) THEN SET &O10 = &STR(YES)\n  ELSE SET &O10 = &STR(NO)\n  IF &STR(&PARAC) = &STR(C) THEN SET &O11 = &STR(YES)\n  ELSE SET &O11 = &STR(NO)\n  SET &OES = &NRSTR(&PARAES)\n  SET &UCSF = &STR(I9)\nUSPB: +\n  ISPEXEC CONTROL ERRORS RETURN\n  ISPEXEC DISPLAY PANEL(PAJPARI)\n  SET EMCC = &LASTCC\n  ISPEXEC CONTROL ERRORS CANCEL\n  IF &EMCC = 8 THEN GOTO MSG5\n  IF &EMCC > 8 THEN GOTO MSG4\n  SET &S = 1\n  SET &SM = &LENGTH(&NRSTR(&IES))\n  DO WHILE (&S \u00ac> &SM)\n    IF &SUBSTR(&S,&NRSTR(&IES)) > &STR(\") THEN DO\n      SET &O1 = &STR(&I1)\n      SET &O2 = &STR(&I2)\n      SET &O3 = &STR(&I3)\n      SET &O4 = &STR(&I4)\n      SET &O5 = &STR(&I5)\n      SET &O6 = &STR(&I6)\n      SET &O7 = &STR(&I7)\n      SET &O8 = &STR(&I8)\n      SET &O9 = &STR(&I9)\n      SET &O10 = &STR(&I10)\n      SET &O11 = &STR(&I11)\n      SET &OES = &NRSTR(&IES)\n      SET ZEDSMSG = &STR(END-SENTENCE)\n      SET ZEDLMSG = &STR(INVALID END OF SENTENCE CHARACTER +\n        AT POSITION &S IN THE STRING)\n      ISPEXEC SETMSG MSG(ISRZ001)\n      SET &UCSF = &STR(IES)\n      GOTO USPB\n      END\n    ELSE SET &S = &S + 1\n    END\n  SET &S = 1\n  SET &SM = &LENGTH(&NRSTR(&IES))\n  SET &PARM = &Z\n  DO WHILE (&S \u00ac> &SM)\n    IF &SUBSTR(&S,&NRSTR(&IES)) \u00ac= &STR( ) THEN +\n      SET &PARM = &STR(&PARM.&SUBSTR(&S,&NRSTR(&IES)))\n    SET &S = &S + 1\n    END\n  SET &IES = &NRSTR(&PARM)\n  SET &S = 1\n  IF ((&STR(&PARAP) = &STR(SHARED)) AND +\n    (&STR(&I1) = &STR(PROFILE))) THEN DO\n      SET P&S = &STR(P)\n      SET &S = &S + 1\n      END\n  ELSE IF ((&STR(&PARAP) = &STR(PROFILE)) AND +\n    (&STR(&I1) = &STR(SHARED))) THEN DO\n      SET P&S = &STR(S)\n      SET &S = &S + 1\n      END\n  IF &PARAOL \u00ac= &I2 THEN DO\n      SET P&S = &STR(OL=&I2)\n      SET &S = &S + 1\n      END\n  IF &PARANL \u00ac= &I3 THEN DO\n      SET P&S = &STR(NL=&I3)\n      SET &S = &S + 1\n      END\n  IF &PARAOR \u00ac= &I4 THEN DO\n      SET P&S = &STR(OR=&I4)\n      SET &S = &S + 1\n      END\n  IF &PARANR \u00ac= &I5 THEN DO\n      SET P&S = &STR(NR=&I5)\n      SET &S = &S + 1\n      END\n  IF &PARAI \u00ac= &I6 THEN DO\n      SET P&S = &STR(I=&I6)\n      SET &S = &S + 1\n      END\n  IF ((&STR(&PARAJ) = &STR(J)) AND +\n    (&STR(&I7) = &STR(NO))) THEN DO\n      SET P&S = &STR(NJ)\n      SET &S = &S + 1\n      END\n  ELSE IF ((&STR(&PARAJ) = &STR(NJ)) AND +\n    (&STR(&I7) = &STR(YES))) THEN DO\n      SET P&S = &STR(J)\n      SET &S = &S + 1\n      END\n  IF ((&STR(&PARAD) = &STR(D)) AND +\n    (&STR(&I8) = &STR(NO))) THEN DO\n      SET P&S = &STR(ND)\n      SET &S = &S + 1\n      END\n  ELSE IF ((&STR(&PARAD) = &STR(ND)) AND +\n    (&STR(&I8) = &STR(YES))) THEN DO\n      SET P&S = &STR(D)\n      SET &S = &S + 1\n      END\n  IF ((&STR(&PARAL) = &STR(NL)) AND +\n    (&STR(&I9) = &STR(YES))) THEN DO\n      SET P&S = &STR(LC)\n      SET &S = &S + 1\n      END\n  ELSE IF ((&STR(&PARAL) = &STR(LC)) AND +\n    (&STR(&I9) = &STR(NO))) THEN DO\n      SET P&S = &STR(NL)\n      SET &S = &S + 1\n      END\n  IF ((&STR(&PARAR) = &STR(KH)) AND +\n    (&STR(&I10) = &STR(YES))) THEN DO\n      SET P&S = &STR(RH)\n      SET &S = &S + 1\n      END\n  ELSE IF ((&STR(&PARAR) = &STR(RH)) AND +\n    (&STR(&I10) = &STR(NO))) THEN DO\n      SET P&S = &STR(KH)\n      SET &S = &S + 1\n      END\n  IF ((&STR(&PARAC) = &STR(NC)) AND +\n    (&STR(&I11) = &STR(YES))) THEN DO\n      SET P&S = &STR(C)\n      SET &S = &S + 1\n      END\n  ELSE IF ((&STR(&PARAC) = &STR(C)) AND +\n    (&STR(&I11) = &STR(NO))) THEN DO\n      SET P&S = &STR(NC)\n      SET &S = &S + 1\n      END\n  SET &PARAES = &NRSTR(&IES)\n  GOTO BACK\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARA@": {"ttr": 30981, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x7f\\x00\\x93'\\x7f\\x114\\x01\\x10\\x01\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-10-04T00:00:00", "modifydate": "1993-10-04T11:34:00", "lines": 272, "newlines": 272, "modlines": 0, "user": "SYSPAJA"}, "text": "1   30/09/93\n                                                      PARA     1/6.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     PARA ISPF/PDF EDIT command      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro is an improved TFLOW, a paragraph\n  ----------   reformatter.\n\n  Command syntax : PARA ...keyword(s)...\n  ----------------      (if no keywords specified then prompting)\n                   PARA HELP or H\n                   Use \"C\" range block commands to define start and\n                   end of paragraph.\n\n  New facility : code PARA on the command line and use \"C\" range\n  ============== line command(s) only, you will be prompted for all\n                 parameters through a panel.\n\n  PARA's keyword parameters :\n  ---------------------------\n                I=nn : define paragraph's first line indentation\n               OL=nn : define old left margin\n               OR=nn : define old right margin\n               NL=nn : define new left margin\n               NR=nn : define new right margin\n                   D : double space at end of sentence\n                  ND : none (single space)\n                   J : right margin justification\n                  NJ : no justification\n                   C : means centering of paragraph\n                  NC : no centering\n                  RH : remove hyphens and rejoin words\n                  LC : change paragraph to lower case\n                SHAR : store parameters in SHARED pool (alias : S)\n                PROF : store parameters in your PROFILE (alias : P)\n                   ? : query current parameters values\n                HELP : display documentation (alias : H)\n1   12/08/91\n                                                      PARA     2/6.\n\n Text processing on TSO has made strides with the introduction of :\n\n             PPPPPPPPPPP     AAAAA      RRRRRRRRRRR      AAAAA\n            PP        PP   AA   AA     RR        RR    AA   AA\n           PPPPPPPPPPP   AA     AA    RRRRRRRRRRR    AA     AA\n          PP           AAAAAAAAAAA   RR       RR   AAAAAAAAAAA\n         PP           AA        AA  RR        RR  AA        AA\n\n PARA reformats paragraphs more easily. Now you can type a memo using\n TE (Text Enter), and rework it, adding lines, blanking or deleting\n words and phrases, then reformat your paragraphs easily.\n I can hear some questions in your mind :\n\n What do you mean by reformat ?\n PARA can change left and right margins, first line indentation, move\n words from line to line to adjust line length, justify the left\n margin, optionally justify the right margin, and double or single\n space after end of sentences.\n\n    It means that     It means that you  can  create paragraphs side by\n    you       can     side.  These paragraphs are examples.\n    easily create\n    very,   very,        It means that you can indent paragraphs to the\n    very,   very,     right; this paragraph is an example.\n    tall, skinny,\n    slender,          It means that  you  can  indent paragraphs to the\n    willowy,             left.  This paragraph is an example.\n    lean,  narrow\n    paragraphs        You do not have to right justify paragraphs. Or\n    like     this     indent the first line. Or double space after the\n    one.              end of a sentence. This is an example.\n\n                              With   some\n                            ingenuity,  you\n                          can          create\n                        paragraphs    in   many\n                      different styles.   You can\n                    create  impact  by  the  visual\n                  appearance  of  your  writing,  and\n                make your  letters  and  memoranda more\n                effective.  True, visual appearance can\n                  never replace the lasting impact of\n                    content,  but  it  can increase\n                      the attention people pay to\n                        your   letters.   After\n                          all,   didn't   you\n                            read this  far?\n\n              You can  even  center  paragraphs after you\n              have   reformatted    them.     Like   this\n                        paragraph, for example.\n1   12/08/91\n                                                      PARA     3/6.\n\n B               You can reformat   paragraphs\n E    that look like this              paragraph with one command.\n F    This paragraph looks\n O       like some paragraphs I have created when I\n R      was just putting my thoughts down, then went back over the\n E   paragraph and cleaned it up.\n !         SEE!\n\n A     You can reformat paragraphs  that  look like this paragraph with\n F  one command.  This  paragraph  looks  like  some  paragraphs I have\n T  created when I was just  putting  my  thoughts down, then went back\n E  over the paragraph and cleaned it up.  SEE!\n R\n\n What do you mean by easily ?\n You tell PARA what to do by coding PARA on the command line followed\n by keyword=value or keyword combinations, then use \"C\" range line\n commands to mark the start and end of the paragraph :\n      COMMAND ===> PARA NL=6 NR=72 I=3 J D\n ---> CC 068              You can reformat   paragraphs\n      000069   that look like this              paragraph with one\n      000070   command.        This paragraph looks\n      000071      like some paragraphs I have created when I\n      000072     was just putting my thoughts down, then went back\n      000073  over  the  paragraph and cleaned it up.\n ---> CC 074        SEE!\n PARA will remember these combinations during the ISPF session, so you\n only have to code any changes the next time you execute PARA.\n      COMMAND ===> PARA I=0\n ---> CC 081     You tell PARA what to do by coding PARA\n      000082        on the command line\n ---> CC 083  followed by keyword=value or keyword combinations,\n\n What if I forget these combinations ?\n You can ask PARA to tell you its current combinations, without doing\n any paragraph reformatting. Example :\n      COMMAND ===> PARA ?\n      000081     You tell PARA what to do by coding PARA\n At this point, a panel is displayed with the current PARA parameters\n values.\n\n What are all these PARA parameters ?\n A PARA parameters reference appendix follows.\n1   12/08/91\n                                                      PARA     4/6.\n\n     ------  Edit Macro PARA Parameters Reference Appendix  ------\n\n 1. Parameters that PARA remembers during an ISPF session :\n\n  OL=nn    Old Left side of the paragraph\n  OR=nn    Old Right side of the paragraph\n           The Old parameters tell PARA where to find the paragraph to\n           be reformatted. The first time PARA executes during an ISPF\n           session, the Old parameters normally default to the display\n           columns on the left and right sides of the screen. You will\n           only change the Old parameters when :\n            (1) You are editing a document wider than the screen size\n                (i.e., 133 wide for a 3278 model 2, 80 columns wide).\n            (2) Or, when there is textual material that you don't want\n                to include on the left or right side of the paragraph\n                to be reformatted.\n           Example :\n           COMMAND ===>\n           =COLS> ----+----1----+----2----+----3----+----4----+--\n           000003 //*  THIS IS A DEMAND DEPOSIT JOB.            *\n           000004 //*    IT RUNS WEEKLY, EVERY MONDAY, ROLLING  *\n           000005 //* FORWARD IF MONDAY IS A HOLIDAY.           *\n           In this example, you don't want the //* and the * to be\n           included in your new paragraph, so you code :\n           COMMAND ===> PARA OL=4 OR=46 NL=4 NR=45\n           =COLS> ----+----1----+----2----+----3----+----4----+--\n      ---> CC 003 //*  THIS IS A DEMAND DEPOSIT JOB.            *\n           000004 //*    IT RUNS WEEKLY, EVERY MONDAY, ROLLING  *\n      ---> CC 005 //* FORWARD IF MONDAY IS A HOLIDAY.           *\n           to exclude them from the reformatted paragraph. Don't forget\n           to change them back if you switch from JCL to a memorandum.\n\n\n  NL=nn    New Left side of the paragraph\n  NR=nn    New Right side of the paragraph\n           The New parameters tell PARA where to put the reformatted\n           paragraph.\n           The New parameters are the most frequently coded parameters.\n\n  I=nn     Indent the first line of the paragraph nn spaces (default\n           is 0). The Indent parameter can be either zero (no\n           indenting), positive (Indent nn spaces to the right), or\n           negative (Indent no spaces to the left).\n\n  J        right margin Justification (default)\n  NJ       No right margin Justification\n           If J is specified, PARA will insert the necessary number of\n           spaces into each line of the paragraph to right align the\n           right margin. The last line will not be justified.\n1   30/09/93\n                                                      PARA     5/6.\n\n  D        Double space after end of sentence (default)\n  ND       No Double space after end of sentence\n           By default, the following characters are recognized as end\n           of sentence :\n           . . . end of sentence . (may be changed through\n           . . . end of sentence !    the prompting panel)\n           . . . end of sentence ? Note : these characters must never\n           . . . end of sentence :        have an hexadecimal value\n           . . . end of sentence \"        greater than X'7F')\n\n 2. Parameters that PARA will not remember (one time only) :\n\n  PROF     store PARA parameters in your PROFile data-set\n  SHAR     store PARA parameters in the SHARed variable pool (default)\n           If you want your PARA parameters to be remembered from\n           session to session, specify PROF once only. From then on,\n           PARA will store your PARA parameters in your PROFile\n           data-set instead of in the SHARED variable pool.\n           Specify SHAR if you change your mind.\n\n  LC       change paragraph to Lower Case\n           LC causes UPPER CASE text in the box defined by OL, OR,\n           and the \"C\" range line commands to be transformed to\n           lower case letters. Start of sentence words will still be\n           capitalized. Why have this routine ? Two reasons :\n            (1) Suppose under TE (text entry) you typed a lot of upper\n                and lower case text while editing a data-set which had\n                CAPS ON. The text would be converted entirely to UPPER\n                CASE. It is faster to change the entire text to lower\n                case and recapitalize where required than to retype\n                the entire text.\n            (2) Suppose you are modifying old text, all of which is in\n                capitals. You want your revised text in both upper and\n                lower case. It is faster to change the entire text to\n                lower case and recapitalize where required than to\n                retype the entire text.\n1   12/08/91\n                                                      PARA     6/6.\n\n  RH       Remove Hyphens and reconnect words\n           Remove Hyphens means if you have one word split across mul-\n           tiple lines with a hyphen (like mul- tiple in this\n           sentence), the hyphen (-) will be removed and the word\n           will be reconnected into one word (i.e. multiple) before\n           reformatting occurs.\n           Why have this routine ? Two reasons :\n            (1) Suppose you made an error previously when you executed\n                PARA, making NL and NR too close together. If PARA\n                finds a word that cannot fit between NL and NR, PARA\n                splits the word into two or more pieces, hyphenating\n                them. Many words might have been split into pieces.\n                This routine makes recovery easy : just execute PARA\n                with the correct NL/NR and RH.\n            (2) Suppose you are modifying old text, with many words\n                hyphenated. Your changes will shift the position of\n                the hyphenated words within the paragraph, moving the\n                hyphenated words to the middle of the line. This routine\n                saves a lot of manual unhyphenation time.\n\n  C        Center paragraph\n  NC       No Centering of paragraph (default)\n           Centering means center inside the OL/OR boundaries. This\n           allows you to reformat a paragraph, view the results, then\n           center the paragraph inside your document without figuring\n           out any new parameters. Centering does not reformat, since\n           the results after both reformatting and centering may be\n           unexpected.\n\n  ?        What are PARA's current parameters ?\n           If ? is specified, a panel is displayed with the current\n           values of the PARA parameters.\n\n  HELP     display HELP information\n           If HELP is specified, a panel is displayed which briefly\n           explain the PARA parameters. Then follows full descriptions\n           panels, if desired.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PBOOKT1": {"ttr": 30986, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893?\\x00\\x893?\\x16I\\x00,\\x00,\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-29T00:00:00", "modifydate": "1989-11-29T16:49:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- IBM Manuals List -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n+The%IBM Manuals List+facility allows you to maintain an online list of the IBM\n manuals. You can sort the list in various ways, and you can get a hardcopy of\n the list.\n The sections listed below will be presented in sequence (hit%ENTER+to go on to\n the next screen) or you may select a particular subject by number :\n%  1+- General information about the IBM Manuals List facility\n%  2+- Adding, Updating entries on the Manuals list : INPUT and \"U\" commands\n%  3+- Repeating, Deleting entries on the Manuals list : \"R\" and \"D\" commands\n+      Selecting to view full entries on the Manuals list : \"S\" command\n%  4+- Sorting the Manuals list : the SORT command\n%  5+- Printing the Manuals list : the LST and FULL commands\n%  6+- Saving the Manuals list and exiting : END, CANCEL, and SAVE commands\n%  7+- Search a specific argument in the Manuals list : FIND command\n%  8+- Maintain TNLs for not received manuals : TNL and \"T\"  commands\n\n+Enter%&EPF+to exit the tutorial and return to the Manuals list\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n  &ZSEL = TRANS(&ZCMD\n                1,PBOOKT2\n                2,PBOOKT3\n                3,PBOOKT4\n                4,PBOOKT5\n                5,PBOOKT6\n                6,PBOOKT7\n                7,PBOOKT8\n                8,PBOOKT9\n                )\n  &ZTRAIL = .TRAIL\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PBOOKT2": {"ttr": 30988, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893?\\x00\\x893?\\x17\\x13\\x00%\\x00%\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-29T00:00:00", "modifydate": "1989-11-29T17:13:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- IBM Manuals List -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%General Information.+\n The IBM Manuals List facility is used to maintain an online collection of IBM\n Manuals and their Technical News Letters.\n%Primary+commands : (Entered in COMMAND ===> area at the top of the display)\n  %INPUT   +- Add a new entry to the Manuals list - Alias :%I+or%INP+\n  %TNL     +- Define only a TNLs entry for a not received manual - Alias :%T+\n  %SORT    +- Sort the Manuals list entries (table) by one or more fields\n  %LST     +- Print the Manuals list entries - Alias :%L+\n  %FULL    +- Print the Manuals list full entries - Alias :%LF+\n  %FIND    +- Search an argument in the Manuals list - Alias :%F+\n  %SAVE    +- Save the Manuals list entries, continue updates\n  %CANCEL  +- Exit utility, don't save any changes - Alias :%CAN+\n  %END     +- &EPFN Exit utility, save any changes\n%Line-commands :+(Entered in \"action\" area at the left of the desired entry)\n  %D+- Delete entry   %U+- Update entry   %R+- Repeat entry   %S+- Select entry\n  %T+- Add or update TNLs entry for a not received manual\n\n+Enter%&EPF+to exit the tutorial and return to the Manuals list\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n  IF (&EPF \u00ac= 'END')\n    &EPFN = '(Or hit &EPF.)'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PBOOKT3": {"ttr": 30990, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893?\\x00\\x893?\\x16I\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-29T00:00:00", "modifydate": "1989-11-29T16:49:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- IBM Manuals List -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Adding, Updating entries on the Manuals list.+\n%Adding a new entry.+\n To add a new entry to the Manuals list, enter the%INPUT+command in the command\n area at the top of the screen. This will take you to a panel where you may\n enter information about the new entry. Press%ENTER+to return to the Manuals\n list and add the entry to the list. Use the%END+command if you change your\n mind and don't want to add the entry.\n Enter%INPUT n+to add%n+new entries, if desired.\n%Updating an entry.+\n You can update any of the fields for an entry (e.g. key-1, key-2, manual no.,\n ...) by entering%U+in the \"action\" area (at the left margin) for the entry.\n This will take you to a panel showing the current fields values. Overtype any\n that you want to change, then hit%ENTER+to return to the Manuals list with\n the entry information updated. Use the%END+command if you change your mind\n and don't want to update the entry. Enter%Un+to update sequentially the%n+\n successive entries starting from the one selected by the line-command.\n\n+Enter%&EPF+to exit the tutorial and return to the Manuals list\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PBOOKT4": {"ttr": 30992, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893?\\x00\\x893?\\x16I\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-29T00:00:00", "modifydate": "1989-11-29T16:49:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- IBM Manuals list -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Repeating, Deleting, Selecting entries on the Manuals list.+\n%Repeating an entry.+\n To add a new entry with the same information as an existing entry, enter%R+\n in the action area for the existing entry (you can then update the entry\n using the \"U\" line-command). Enter%Rn+to add%n+times an existing entry.\n%Deleting an entry.+\n To delete an entry from the list, enter%D+in the action area for the entry.\n Enter%Dn+to delete%n+entries in sequence from an existing entry.\n%Selecting an entry to fully view it.+\n To select an entry from the list, enter%S+in the action area for the entry.\n Enter%Sn+to select%n+entries in sequence from an existing entry.\n\n+Enter%&EPF+to exit the tutorial and return to the Manuals list\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PBOOKT5": {"ttr": 31233, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893?\\x00\\x893?\\x16I\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-29T00:00:00", "modifydate": "1989-11-29T16:49:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- IBM Manuals List -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Sorting the Manuals list entries.+\n To change the sort order of the list, enter the%SORT+command and (optionally)\n the desired sort fields as operands. If you enter no sort fields, KEY-1 KEY-2\n MANUAL LOCATION (in that order) will be used. You may enter as many of the\n sort fields as you wish. Note that the current sort order is always shown on\n the Manuals list panel, and is printed in the heading when you print the\n Manuals list entries (LST and FULL commands).\n Valid sort fields operands are :\n    K1, K1(A), K1(D), KEY-1, KEY-1(A), KEY-1(D)\n    K2, K2(A), K2(D), KEY-2, KEY-2(A), KEY-2(D)\n    M, M(A), M(D), MAN, MAN(A), MAN(D), MANUAL, MANUAL(A), MANUAL(D)\n    L, L(A), L(D), LOC, LOC(A), LOC(D), LOCATION, LOCATION(A), LOCATION(D)\n    D, D(A), D(D), DATE, DATE(A), DATE(D)\n    R, R(A), R(D), ROOM, ROOM(A), ROOM(D)\n%REMARK :+by default, the sort sequence is A (ascending order).\n\n+Enter%&EPF+to exit the tutorial and return to the Manuals list\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOKT6": {"ttr": 31235, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893?\\x00\\x893?\\x16I\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-29T00:00:00", "modifydate": "1989-11-29T16:49:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- IBM Manuals List -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Printing the Manuals list entries or full entries.+\n To print the Manuals list entries or full entries, enter the%LST+ or%FULL+\n command in the command area at the top of the screen. All the information\n currently contained on Manuals list entries will be formatted into a report\n and sent for printing.\n To specify a destination and (or) a SYSOUT class for the printed output,\n enter the desired destination and (or) SYSOUT class as operand(s) to the\n LST or FULL commands.\n For examples : LST A     or FULL A     = class A, destination LOCAL\n                LST R7    or FULL R7    = class A, destination R7\n                LST X R41 or FULL X R41 = class X, destination R41\n                LST R3 A  or FULL R3 A  = class A, destination R3\n By default, the destination is LOCAL and the SYSOUT class is A.\n\n+Enter%&EPF+to exit the tutorial and return to the Manuals list\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOKT7": {"ttr": 31237, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893?\\x00\\x893?\\x16I\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-29T00:00:00", "modifydate": "1989-11-29T16:49:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- IBM Manuals List -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Saving the Manuals list and exiting the utility.+\n To exit the Manuals list and resave your changes, enter the%END+command in the\n command area at the top of the screen.\n &EPFN\n+To save a copy of the Manuals list and continue the Manuals list update\n process, enter the%SAVE+command in the command area at the top of the screen.\n To exit the Manuals list without resaving any changes from this session, enter\n the%CANCEL+command in the command area at the top of the screen.\n\n+Enter%&EPF+to exit the tutorial and return to the Manuals list\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n  IF (&EPF \u00ac= 'END')\n    &EPFN = '(You can use the &EPF key instead of +\n             actually keying the END command)'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOKT8": {"ttr": 31239, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893?\\x00\\x893?\\x16I\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-29T00:00:00", "modifydate": "1989-11-29T16:49:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- IBM Manuals List -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Search a specific argument in the Manuals list.+\n To search a specific argument in the Manuals list, enter the%FIND+ or%F+\n command in the command area at the top of the screen. You will be promped\n to a FIND panel where you may specify your desired argument to be searched\n anywhere in the Manuals list entries.\n As soon as the FIND process starts, the Manuals list entries will be sorted,\n if necessary, to search for LE (ascending order) or GE (descending order) in\n the corresponding field (i.e. MANUAL, KEY-1, DATE, ROOM, ...) as indicated\n by the requested argument, unless the search is to be done on the TITLE or\n NEWSLETTERS fields (in this case, the scan is executed in the Manuals list\n entries as they are sorted at this moment just because only a true match\n of the argument will satisfy the found condition).\n%Exceptional continue search+is allowed only when the FIND command is working\n on the TITLE field by entering the%CONT+command successively (alias%CONTINUE+\n or%C+ are accepted).\n\n+Enter%&EPF+to exit the tutorial and return to the Manuals list\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOKT9": {"ttr": 31241, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90&/\\x00\\x90&/\\x14\\x07\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-09-19T00:00:00", "modifydate": "1990-09-19T14:07:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": ")BODY EXPAND(//)\n%TUTORIAL-/-/- IBM Manuals List -/-/-TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n%Defining, Adding, Updating TNLs entry for a NOT RECEIVED manual.+\n%>> Note :+use the%U+command on the entry as soon as you receive the manual.%<<\n Defining a new entry for only TNLs :+to add a new entry to the Manuals list\n for Newsletters belonging to a NOT RECEIVED manual, enter the%TNL+command in\n the command area at the top of the screen. This will take you to a panel where\n you may enter information about the new entry. Press%ENTER+to return to the\n Manuals list and add the entry to the list. Use the%END+command if you change\n your mind and don't want to add the entry.\n Enter%TNL n+to add%n+new entries, if desired.\n%Updating an entry for only TNLs :+you can update any of the fields for an\n entry (e.g. manual no., location, ...) by entering%T+in the \"action\" area (at\n the left margin) for the entry. This will take you to a panel showing the\n current fields values. Overtype any that you want to change, then hit%ENTER+\n to return to the Manuals list with the entry information updated. Use the%END+\n command if you change your mind and don't want to update the entry. Enter%Tn+\n to update sequentially the%n+successive entries starting from the one selected\n by the line-command.\n\n+Enter%&EPF+to exit the tutorial and return to the Manuals list\n+Hit%ENTER+to go on to the next tutorial panel\n)INIT\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PBOOK0": {"ttr": 31243, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893_\\x00\\x893_\\x11\"\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-01T00:00:00", "modifydate": "1989-12-01T11:22:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "%MANUALS -----------------  IBM Manuals Maintenance  ---------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+\n+\n+Do you intend to%update+the TABLE contents :_CBUPDT+   (NO/YES)\n+\n)INIT\n  .CURSOR = CBUPDT\n  &CBUPDT = TRANS (&CBUPDT ' ',NO YES,NO *,*)\n)PROC\n  &CBUPDT = TRUNC (&CBUPDT,1)\n  &CBUPDT = TRANS (&CBUPDT N,NO Y,YES *,*)\n  VER (&CBUPDT,NONBLANK)  VER (&CBUPDT,LIST,NO,YES)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOK00": {"ttr": 31245, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893_\\x00\\x893_\\x11U\\x00A\\x00A\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-01T00:00:00", "modifydate": "1989-12-01T11:55:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "SYSPAJA"}, "text": "%MANUALS -----------------  IBM Manuals Maintenance  ---------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+Do you intend to allocate a new IBM manuals tables data-set\n+           or create a new IBM manuals table\n+           or update an existing IBM manuals table%===>_CBUPDT  +(NO/YES)\n+\n%Specify or change options below :\n+  IBM manuals tables data-set name ..... PROJECT%===>_CBTPRO  + default SYS\n+                                         LIBRARY%===>_CBTLIB  + default BOOKS\n+                                            TYPE%===>_CBTTYP  + default DATA\n+  If desired, set another IBM manuals table name%===>_CBLIST  + default CBLIST\n+\n+  If you new allocate, you may assign the VOLUME%===>_CBVOL +   default USER00\n+                                        the UNIT%===>_CBUNIT  + default DISK\n+                                 the SPACE units%===>_CBALLU   +default CYLS\n+    (you may specify TRACKS-TRACK-TRKS-TRK-T or CYLINDERS-CYLINDER-CYLS-CYL-C)\n+                          the PRIMARY quantity  %===>_CBSPA1+   default 1\n+                          the SECONDARY quantity%===>_CBSPA2+   default 1\n+                          the DIRECTORY blocks  %===>_CBNDIR+   default 1\n+\n)INIT\n  .CURSOR = CBUPDT\n  &CBUPDT = TRANS (&CBUPDT ' ',NO YES,NO *,*)\n  &CBTPRO = &Z\n  &CBTLIB = &Z\n  &CBTYPT = &Z\n  &CBLIST = &Z\n  &CBVOL = &Z\n  &CBUNIT = &Z\n  &CBALLU = &Z\n  &CBSPA1 = &Z\n  &CBSPA2 = &Z\n  &CBNDIR = &Z\n)PROC\n  &CBUPDT = TRUNC (&CBUPDT,1)\n  &CBUPDT = TRANS (&CBUPDT N,NO Y,YES *,*)\n  VER (&CBUPDT,NONBLANK)  VER (&CBUPDT,LIST,NO,YES)\n  IF (&CBTPRO \u00ac= &Z)\n    VER (&CBTPRO,NAME)\n  IF (&CBTLIB \u00ac= &Z)\n    VER (&CBTLIB,NAME)\n  IF (&CBTTYP \u00ac= &Z)\n    VER (&CBTTYP,NAME)\n  IF (&CBLIST \u00ac= &Z)\n    VER (&CBLIST,NAME)\n  IF (&CBVOL \u00ac= &Z)\n    VER (&CBVOL,NAME)\n  IF (&CBALLU \u00ac= &Z)\n    &CBALLU = TRANS (&CBALLU C,CYLINDERS T,TRACKS\n                             CYL,CYLINDERS TRK,TRACKS\n                             CYLS,CYLINDERS TRKS,TRACKS\n                             CYLINDER,CYLINDERS TRACK,TRACKS\n                             CYLINDERS,CYLINDERS TRACKS,TRACKS *,*)\n    VER (&CBALLU,LIST,CYLINDERS,TRACKS)\n  IF (&CBSPA1 \u00ac= &Z)\n    VER (&CBSPA1,NUM)\n    VER (&CBSPA1,RANGE,1,32760)\n  IF (&CBSPA2 \u00ac= &Z)\n    VER (&CBSPA2,NUM)\n    VER (&CBSPA2,RANGE,1,32760)\n  IF (&CBNDIR \u00ac= &Z)\n    VER (&CBNDIR,NUM)\n    VER (&CBNDIR,RANGE,1,32760)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOK000": {"ttr": 31247, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893_\\x00\\x893_\\x11U\\x00G\\x00G\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-01T00:00:00", "modifydate": "1989-12-01T11:55:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "SYSPAJA"}, "text": "%MANUALS -----------------  IBM Manuals Maintenance  ---------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+Do you intend to allocate a new IBM manuals tables data-set\n+           or create a new IBM manuals table\n+           or update an existing IBM manuals table%===>_CBUPDT  +(NO/YES)\n+\n%Specify or change options below :\n+  IBM manuals tables data-set name ..... PROJECT%===>_CBTPRO  + default SYS\n+                                         LIBRARY%===>_CBTLIB  + default BOOKS\n+                                            TYPE%===>_CBTTYP  + default DATA\n+  If desired, set another IBM manuals table name%===>_CBLIST  + default CBLIST\n+\n+  If you new allocate, you may assign the VOLUME%===>_CBVOL +   default USER00\n+                                        the UNIT%===>_CBUNIT  + default DISK\n+                                 the SPACE units%===>_CBALLU   +default CYLS\n+    (you may specify TRACKS-TRACK-TRKS-TRK-T or CYLINDERS-CYLINDER-CYLS-CYL-C)\n+                          the PRIMARY quantity  %===>_CBSPA1+   default 1\n+                          the SECONDARY quantity%===>_CBSPA2+   default 1\n+                          the DIRECTORY blocks  %===>_CBNDIR+   default 1\n+\n+  Debugging aid ................ TEST run option%===>_CBTEST  +(NO/YES)\n+\n)INIT\n  .CURSOR = CBUPDT\n  &CBUPDT = TRANS (&CBUPDT ' ',NO YES,NO *,*)\n  &CBTPRO = &Z\n  &CBTLIB = &Z\n  &CBTYPT = &Z\n  &CBLIST = &Z\n  &CBVOL = &Z\n  &CBUNIT = &Z\n  &CBALLU = &Z\n  &CBSPA1 = &Z\n  &CBSPA2 = &Z\n  &CBNDIR = &Z\n  &CBTEST = TRANS (&CBTEST ' ',NO YES,NO *,*)\n)PROC\n  &CBUPDT = TRUNC (&CBUPDT,1)\n  &CBUPDT = TRANS (&CBUPDT N,NO Y,YES *,*)\n  VER (&CBUPDT,NONBLANK)  VER (&CBUPDT,LIST,NO,YES)\n  IF (&CBTPRO \u00ac= &Z)\n    VER (&CBTPRO,NAME)\n  IF (&CBTLIB \u00ac= &Z)\n    VER (&CBTLIB,NAME)\n  IF (&CBTTYP \u00ac= &Z)\n    VER (&CBTTYP,NAME)\n  IF (&CBLIST \u00ac= &Z)\n    VER (&CBLIST,NAME)\n  IF (&CBVOL \u00ac= &Z)\n    VER (&CBVOL,NAME)\n  IF (&CBALLU \u00ac= &Z)\n    &CBALLU = TRANS (&CBALLU C,CYLINDERS T,TRACKS\n                             CYL,CYLINDERS TRK,TRACKS\n                             CYLS,CYLINDERS TRKS,TRACKS\n                             CYLINDER,CYLINDERS TRACK,TRACKS\n                             CYLINDERS,CYLINDERS TRACKS,TRACKS *,*)\n    VER (&CBALLU,LIST,CYLINDERS,TRACKS)\n  IF (&CBSPA1 \u00ac= &Z)\n    VER (&CBSPA1,NUM)\n    VER (&CBSPA1,RANGE,1,32760)\n  IF (&CBSPA2 \u00ac= &Z)\n    VER (&CBSPA2,NUM)\n    VER (&CBSPA2,RANGE,1,32760)\n  IF (&CBNDIR \u00ac= &Z)\n    VER (&CBNDIR,NUM)\n    VER (&CBNDIR,RANGE,1,32760)\n  &CBTEST = TRUNC (&CBTEST,1)\n  &CBTEST = TRANS (&CBTEST N,NO Y,YES *,*)\n  VER (&CBTEST,NONBLANK)  VER (&CBTEST,LIST,NO,YES)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOK1": {"ttr": 31250, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x18_\\x00\\x90\\x18_\\x11S\\x00\\x9b\\x00\\x9b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-07-04T00:00:00", "modifydate": "1990-07-04T11:53:00", "lines": 155, "newlines": 155, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n# TYPE(INPUT) INTENS(LOW) CAPS(ON)\n@ TYPE(OUTPUT) INTENS(LOW) SKIP(ON)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n)BODY EXPAND(//)\n%-/-/- IBM Manuals List -/-/-\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_AMT +\n+\n+Current SORT order :&CBSRTF\n%-/-/- Manuals list -/-/-\n%Act  Key-1    Key-2    Manual no.  Title                               Location\n%                                   Date         Room          TNL no.\n%--- -------- -------- ------------ ----------------------------------  --------\n)MODEL CLEAR(A)\n#A  @CBKW1   @CBKW2   @CBMNO       @CBTMN                              @CBLOC\n+                                  @CBDTE  +    @CBROOM  +      @CBNW0+\n)INIT\n  .HELP = PBOOKT1\n  &ZHTOP = PBOOKT1\n  .AUTOSEL = NO\n  IF (&CRP \u00ac= &Z)\n    .CSRROW = &CRP\n  IF (&AMT = &Z)\n    &AMT = PAGE\n  &ZTDMARK = '=========================== Bottom of Manuals list +\n              ============================'\n  &CBCURM = TRANS(&ZMONTH\n            01,January 02,February 03,March 04,April 05,May 06,June\n            07,July 08,August 09,September 10,October 11,November 12,December)\n  &CBCURD = '&ZDAY &CBCURM 19&ZYEAR'\n  VPUT (CBCURD) SHARED\n)REINIT\n  IF (.MSG \u00ac= &Z)\n    .ATTR(.CURSOR) = 'COLOR(RED)'\n    .AUTOSEL = YES\n    .CSRROW = &CRP\n)PROC\n  &CMD = TRANS(TRUNC(&ZCMD,' ')\n         I,INPUT INP,INPUT T,TNL CAN,CANCEL F,FIND C,CONT CONTINUE,CONT\n         L,LIST LST,LIST LF,FULL *,*)\n  VER (&CMD,LIST,INPUT,TNL,CANCEL,FIND,CONT,LIST,FULL,SORT,SAVE,MSG=MBKS003E)\n  IF (&CMD = 'FIND')\n    &ZTRAIL = .TRAIL\n  IF (&CMD = 'SORT')\n    &ZTRAIL = .TRAIL\n    &SFCB1 = TRANS(TRUNC(&ZTRAIL,' ')\n             'KEY-1',K1 'KEY-1(A)',K1 'K1(A)',K1 'KEY-1(D)',K1I 'K1(D)',K1I\n             'KEY-2',K2 'KEY-2(A)',K2 'K2(A)',K2 'KEY-2(D)',K2I 'K2(D)',K2I\n             MANUAL,M MAN,M 'MANUAL(A)',M 'MAN(A)',M 'M(A)',M 'MANUAL(D)',MI\n             'MAN(D)',MI 'M(D)',MI\n             LOCATION,L LOC,L 'LOCATION(A)',L 'LOC(A)',L 'L(A)',L\n             'LOCATION(D)',LI 'LOC(D)',LI 'L(D)',LI\n             DATE,D 'DATE(A)',D 'D(A)',D 'DATE(D)',DI 'D(D)',DI\n             ROOM,R 'ROOM(A)',R 'R(A)',R 'ROOM(D)',RI 'R(D)',RI *,*)\n    VER (&SFCB1,LIST,K1,K2,M,L,D,R,K1I,K2I,MI,LI,DI,RI MSG=MBKS003S)\n    &ZTRAIL = .TRAIL\n    &SFCB2 = TRANS(TRUNC(&ZTRAIL,' ')\n             'KEY-1',K1 'KEY-1(A)',K1 'K1(A)',K1 'KEY-1(D)',K1I 'K1(D)',K1I\n             'KEY-2',K2 'KEY-2(A)',K2 'K2(A)',K2 'KEY-2(D)',K2I 'K2(D)',K2I\n             MANUAL,M MAN,M 'MANUAL(A)',M 'MAN(A)',M 'M(A)',M 'MANUAL(D)',MI\n             'MAN(D)',MI 'M(D)',MI\n             LOCATION,L LOC,L 'LOCATION(A)',L 'LOC(A)',L 'L(A)',L\n             'LOCATION(D)',LI 'LOC(D)',LI 'L(D)',LI\n             DATE,D 'DATE(A)',D 'D(A)',D 'DATE(D)',DI 'D(D)',DI\n             ROOM,R 'ROOM(A)',R 'R(A)',R 'ROOM(D)',RI 'R(D)',RI *,*)\n    VER (&SFCB2,LIST,K1,K2,M,L,D,R,K1I,K2I,MI,LI,DI,RI MSG=MBKS003S)\n    &ZTRAIL = .TRAIL\n    &SFCB3 = TRANS(TRUNC(&ZTRAIL,' ')\n             'KEY-1',K1 'KEY-1(A)',K1 'K1(A)',K1 'KEY-1(D)',K1I 'K1(D)',K1I\n             'KEY-2',K2 'KEY-2(A)',K2 'K2(A)',K2 'KEY-2(D)',K2I 'K2(D)',K2I\n             MANUAL,M MAN,M 'MANUAL(A)',M 'MAN(A)',M 'M(A)',M 'MANUAL(D)',MI\n             'MAN(D)',MI 'M(D)',MI\n             LOCATION,L LOC,L 'LOCATION(A)',L 'LOC(A)',L 'L(A)',L\n             'LOCATION(D)',LI 'LOC(D)',LI 'L(D)',LI\n             DATE,D 'DATE(A)',D 'D(A)',D 'DATE(D)',DI 'D(D)',DI\n             ROOM,R 'ROOM(A)',R 'R(A)',R 'ROOM(D)',RI 'R(D)',RI *,*)\n    VER (&SFCB3,LIST,K1,K2,M,L,D,R,K1I,K2I,MI,LI,DI,RI MSG=MBKS003S)\n    &ZTRAIL = .TRAIL\n    &SFCB4 = TRANS(TRUNC(&ZTRAIL,' ')\n             'KEY-1',K1 'KEY-1(A)',K1 'K1(A)',K1 'KEY-1(D)',K1I 'K1(D)',K1I\n             'KEY-2',K2 'KEY-2(A)',K2 'K2(A)',K2 'KEY-2(D)',K2I 'K2(D)',K2I\n             MANUAL,M MAN,M 'MANUAL(A)',M 'MAN(A)',M 'M(A)',M 'MANUAL(D)',MI\n             'MAN(D)',MI 'M(D)',MI\n             LOCATION,L LOC,L 'LOCATION(A)',L 'LOC(A)',L 'L(A)',L\n             'LOCATION(D)',LI 'LOC(D)',LI 'L(D)',LI\n             DATE,D 'DATE(A)',D 'D(A)',D 'DATE(D)',DI 'D(D)',DI\n             ROOM,R 'ROOM(A)',R 'R(A)',R 'ROOM(D)',RI 'R(D)',RI *,*)\n    VER (&SFCB4,LIST,K1,K2,M,L,D,R,K1I,K2I,MI,LI,DI,RI MSG=MBKS003S)\n    &ZTRAIL = .TRAIL\n    &SFCB5 = TRANS(TRUNC(&ZTRAIL,' ')\n             'KEY-1',K1 'KEY-1(A)',K1 'K1(A)',K1 'KEY-1(D)',K1I 'K1(D)',K1I\n             'KEY-2',K2 'KEY-2(A)',K2 'K2(A)',K2 'KEY-2(D)',K2I 'K2(D)',K2I\n             MANUAL,M MAN,M 'MANUAL(A)',M 'MAN(A)',M 'M(A)',M 'MANUAL(D)',MI\n             'MAN(D)',MI 'M(D)',MI\n             LOCATION,L LOC,L 'LOCATION(A)',L 'LOC(A)',L 'L(A)',L\n             'LOCATION(D)',LI 'LOC(D)',LI 'L(D)',LI\n             DATE,D 'DATE(A)',D 'D(A)',D 'DATE(D)',DI 'D(D)',DI\n             ROOM,R 'ROOM(A)',R 'R(A)',R 'ROOM(D)',RI 'R(D)',RI *,*)\n    VER (&SFCB5,LIST,K1,K2,M,L,D,R,K1I,K2I,MI,LI,DI,RI MSG=MBKS003S)\n    &ZTRAIL = .TRAIL\n    &SFCB6 = TRANS(TRUNC(&ZTRAIL,' ')\n             'KEY-1',K1 'KEY-1(A)',K1 'K1(A)',K1 'KEY-1(D)',K1I 'K1(D)',K1I\n             'KEY-2',K2 'KEY-2(A)',K2 'K2(A)',K2 'KEY-2(D)',K2I 'K2(D)',K2I\n             MANUAL,M MAN,M 'MANUAL(A)',M 'MAN(A)',M 'M(A)',M 'MANUAL(D)',MI\n             'MAN(D)',MI 'M(D)',MI\n             LOCATION,L LOC,L 'LOCATION(A)',L 'LOC(A)',L 'L(A)',L\n             'LOCATION(D)',LI 'LOC(D)',LI 'L(D)',LI\n             DATE,D 'DATE(A)',D 'D(A)',D 'DATE(D)',DI 'D(D)',DI\n             ROOM,R 'ROOM(A)',R 'R(A)',R 'ROOM(D)',RI 'R(D)',RI *,*)\n    VER (&SFCB6,LIST,K1,K2,M,L,D,R,K1I,K2I,MI,LI,DI,RI MSG=MBKS003S)\n    &ZTRAIL = .TRAIL\n  IF (&CMD = 'INPUT')\n    &CBIN = .TRAIL\n    IF (&CBIN = &Z)\n      &CBIN = 1\n    VER (&CBIN,NB,NUM)\n  IF (&CMD = 'TNL')\n    &CBIN = .TRAIL\n    IF (&CBIN = &Z)\n      &CBIN = 1\n    VER (&CBIN,NB,NUM)\n  IF (&CMD = 'LIST','FULL')\n    &ZTRAIL = .TRAIL\n    &CBPCLAS = ' '\n    &CBPDEST = ' '\n    IF (&ZTRAIL \u00ac= &Z)\n      &CBPDEST = TRUNC(&ZTRAIL,' ')\n      &CBPCLAS = .TRAIL\n      IF (&CBPDEST = 'LOCAL')\n        &CBPDEST = ' '\n      IF (&CBPDEST \u00ac= 'LOCAL')\n        &D = TRUNC(&CBPDEST,1)\n        IF (&CBPDEST \u00ac= &D)\n          VER (&D,LIST,U,R,MSG=MBKS003D)\n          &D = .TRAIL\n          VER (&D,NB,NUM,MSG=MBKS003D)\n        IF (&CBPDEST = &D)\n          &CBPDEST = &CBPCLAS\n          &CBPCLAS = &D\n          IF (&CBPDEST \u00ac= &Z)\n            IF (&CBPDEST = 'LOCAL')\n              &CBPDEST = ' '\n            IF (&CBPDEST \u00ac= 'LOCAL')\n              &D = TRUNC(&CBPDEST,1)\n              VER (&D,LIST,U,R,MSG=MBKS003D)\n              &D = .TRAIL\n              VER (&D,NB,NUM,MSG=MBKS003D)\n  IF (&ZTDSELS \u00ac= 0000)\n    &ACT = TRUNC(&A,1)\n    VER (&ACT,LIST,D,R,S,T,U,MSG=MBKS003L)\n    &N = .TRAIL\n    IF (&N = &Z)\n      &N = 1\n    VER (&N,NB,NUM)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOK2": {"ttr": 31489, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x18_\\x00\\x90\\x18_\\x08S\\x00O\\x00O\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-07-04T00:00:00", "modifydate": "1990-07-04T08:53:00", "lines": 79, "newlines": 79, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n@ TYPE(INPUT) INTENS(LOW) CAPS(OFF)\n# TYPE(INPUT) INTENS(LOW) CAPS(ON)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n% TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n$ TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)\n)BODY EXPAND(//)\n%-/-/- IBM Manuals List : &CBTTL entry -/-/-\n%COMMAND ===>_ZCMD                                                             +\n+\n%Specify or change information below :\n+\n+  Manual no.  %===>#CBN1%-#CBN2%-#NW+(IBM format GGGG - NNNN - S or SS)\n+      or name %===>#CBGNS       +    (or up to 12 characters name)\n+  Title       %===>@CBTMN                             +(up to 34 characters)\n+  Key-1       %===>#CBKW1   +        (up to 8 characters keyword-1 name)\n+  Key-2       %===>#CBKW2   +        (up to 8 characters keyword-2 name)\n+  Location    %===>#CBX +            (sequence, up to 4 numerics, format SSSS)\n+              %===>#CBY+             (number, up to 3 numerics, format NNN)\n+  Room        %===>#CBROOM  +        (up to 8 characters room name)\n+\n+Current number of Technical NewsLetters is :$CBNW0+\n%Do you want define, add or update some TNL :#CBZ+(NO or YES)\n+\n+                                                  &CBTDT date is :$CBDTE  +\n+\n+\n+Hit%ENTER+to update the information for this entry\n+Hit%&EPF+to cancel this operation and return to Manuals list panel\n+Hit%&HPF+to get explanation about Manuals List facility\n)INIT\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n  &ZCMD = &Z\n  &CBTTL = 'Update'\n  &CBTDT = 'Update'\n  IF (&CMD = 'INPUT')\n    &CBTTL = 'Add'\n    &CBTDT = 'Create'\n  &CBZ = TRANS (&CBZ ' ',NO YES,NO *,*)\n  .CURSOR = CBN1\n  &MM = TRANS(&ZMONTH\n             01,JAN 02,FEB 03,MAR 04,APR 05,MAY 06,JUN\n             07,JUL 08,AUG 09,SEP 10,OCT 11,NOV 12,DEC)\n  &CBDTE = '&ZDAY.&MM.&ZYEAR'\n  &CBSORT = '&ZYEAR.&ZMONTH.&ZDAY'\n)PROC\n  IF (&CBN1 = &Z)\n    IF (&CBGNS = &Z)\n      .MSG = MBKS004A\n    IF (&CBN2 \u00ac= &Z)\n      .MSG = MBKS004T\n    IF (&NW \u00ac= &Z)\n      .MSG = MBKS004T\n    VER (&CBGNS,NB)\n  IF (&CBN1 \u00ac= &Z)\n    IF (&CBGNS \u00ac= &Z)\n      .MSG = MBKS004B\n    VER (&CBN1,PICT,CCNN)\n    VER (&CBN2,PICT,NNNN)\n    VER (&NW,NB,NUM)\n  VER (&CBTMN,NB)\n  VER (&CBX,NB,NUM)\n  VER (&CBY,NB,NUM)\n  VER (&CBROOM,NB)\n  &CBZ = TRUNC (&CBZ,1)\n  &CBZ = TRANS (&CBZ N,NO Y,YES *,*)\n  VER (&CBZ,NB) VER (&CBZ,LIST,NO,YES)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOK3": {"ttr": 31492, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x18_\\x00\\x90\\x18_\\x08S\\x01\\xd0\\x01\\xd0\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-07-04T00:00:00", "modifydate": "1990-07-04T08:53:00", "lines": 464, "newlines": 464, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n# TYPE(INPUT) INTENS(LOW) CAPS(ON)\n@ TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n% TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n)BODY EXPAND(//)\n%-/-/- IBM Manuals List : NewsLetters -/-/-\n%COMMAND ===>_ZCMD                                                             +\n+\n%Define, add or update Technical NewsLetters to manual :@CBMNO       +\n+\n+Enter TNL no.s in IBM format%GGGG - NNNN+followed by%I+if they are inserted in\n+               the manual, and by%P+or leave blank if they are only present.\n%===>#T011%-#T012%>#T01+    %===>#T021%-#T022%>#T02+    %===>#T031%-#T032%>#T03+\n%   >#T041%-#T042%>#T04+    %   >#T051%-#T052%>#T05+    %   >#T061%-#T062%>#T06+\n%   >#T071%-#T072%>#T07+    %   >#T081%-#T082%>#T08+    %   >#T091%-#T092%>#T09+\n%   >#T101%-#T102%>#T10+    %   >#T111%-#T112%>#T11+    %   >#T121%-#T122%>#T12+\n%   >#T131%-#T132%>#T13+    %   >#T141%-#T142%>#T14+    %   >#T151%-#T152%>#T15+\n%   >#T161%-#T162%>#T16+    %   >#T171%-#T172%>#T17+    %   >#T181%-#T182%>#T18+\n%   >#T191%-#T192%>#T19+    %   >#T201%-#T202%>#T20+    %   >#T211%-#T212%>#T21+\n%   >#T221%-#T222%>#T22+    %   >#T231%-#T232%>#T23+    %   >#T241%-#T242%>#T24+\n%   >#T251%-#T252%>#T25+    %   >#T261%-#T262%>#T26+    %   >#T271%-#T272%>#T27+\n%   >#T281%-#T282%>#T28+    %   >#T291%-#T292%>#T29+    %   >#T301%-#T302%>#T30+\n+\n+Hit%ENTER+to update the information for this entry\n+Hit%&EPF+to cancel this operation and return to Manuals list panel\n+Hit%&HPF+to get explanation about Manuals List facility\n)INIT\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n  &ZCMD = &Z\n  .CURSOR = ZCMD\n)PROC\n  IF (&T011 = &Z)\n    IF (&T012 \u00ac= &Z)\n      .CURSOR = T012\n      .MSG = MBKS004C\n    IF (&T01 \u00ac= &Z)\n      .CURSOR = T01\n      .MSG = MBKS004C\n  IF (&T011 \u00ac= &Z)\n    VER (&T011,PICT,CCNN)\n    VER (&T012,PICT,NNNN)\n    IF (&T01 \u00ac= &Z)\n      IF (&T01 \u00ac= 'I','P')\n        .CURSOR = T01\n        .MSG = MBKS004C\n  IF (&T021 = &Z)\n    IF (&T022 \u00ac= &Z)\n      .CURSOR = T022\n      .MSG = MBKS004C\n    IF (&T02 \u00ac= &Z)\n      .CURSOR = T02\n      .MSG = MBKS004C\n  IF (&T021 \u00ac= &Z)\n    VER (&T021,PICT,CCNN)\n    VER (&T022,PICT,NNNN)\n    IF (&T02 \u00ac= &Z)\n      IF (&T02 \u00ac= 'I','P')\n        .CURSOR = T02\n        .MSG = MBKS004C\n  IF (&T031 = &Z)\n    IF (&T032 \u00ac= &Z)\n      .CURSOR = T032\n      .MSG = MBKS004C\n    IF (&T03 \u00ac= &Z)\n      .CURSOR = T03\n      .MSG = MBKS004C\n  IF (&T031 \u00ac= &Z)\n    VER (&T031,PICT,CCNN)\n    VER (&T032,PICT,NNNN)\n    IF (&T03 \u00ac= &Z)\n      IF (&T03 \u00ac= 'I','P')\n        .CURSOR = T03\n        .MSG = MBKS004C\n  IF (&T041 = &Z)\n    IF (&T042 \u00ac= &Z)\n      .CURSOR = T042\n      .MSG = MBKS004C\n    IF (&T04 \u00ac= &Z)\n      .CURSOR = T04\n      .MSG = MBKS004C\n  IF (&T041 \u00ac= &Z)\n    VER (&T041,PICT,CCNN)\n    VER (&T042,PICT,NNNN)\n    IF (&T04 \u00ac= &Z)\n      IF (&T04 \u00ac= 'I','P')\n        .CURSOR = T04\n        .MSG = MBKS004C\n  IF (&T051 = &Z)\n    IF (&T052 \u00ac= &Z)\n      .CURSOR = T052\n      .MSG = MBKS004C\n    IF (&T05 \u00ac= &Z)\n      .CURSOR = T05\n      .MSG = MBKS004C\n  IF (&T051 \u00ac= &Z)\n    VER (&T051,PICT,CCNN)\n    VER (&T052,PICT,NNNN)\n    IF (&T05 \u00ac= &Z)\n      IF (&T05 \u00ac= 'I','P')\n        .CURSOR = T05\n        .MSG = MBKS004C\n  IF (&T061 = &Z)\n    IF (&T062 \u00ac= &Z)\n      .CURSOR = T062\n      .MSG = MBKS004C\n    IF (&T06 \u00ac= &Z)\n      .CURSOR = T06\n      .MSG = MBKS004C\n  IF (&T061 \u00ac= &Z)\n    VER (&T061,PICT,CCNN)\n    VER (&T062,PICT,NNNN)\n    IF (&T06 \u00ac= &Z)\n      IF (&T06 \u00ac= 'I','P')\n        .CURSOR = T06\n        .MSG = MBKS004C\n  IF (&T071 = &Z)\n    IF (&T072 \u00ac= &Z)\n      .CURSOR = T072\n      .MSG = MBKS004C\n    IF (&T07 \u00ac= &Z)\n      .CURSOR = T07\n      .MSG = MBKS004C\n  IF (&T071 \u00ac= &Z)\n    VER (&T071,PICT,CCNN)\n    VER (&T072,PICT,NNNN)\n    IF (&T07 \u00ac= &Z)\n      IF (&T07 \u00ac= 'I','P')\n        .CURSOR = T07\n        .MSG = MBKS004C\n  IF (&T081 = &Z)\n    IF (&T082 \u00ac= &Z)\n      .CURSOR = T082\n      .MSG = MBKS004C\n    IF (&T08 \u00ac= &Z)\n      .CURSOR = T08\n      .MSG = MBKS004C\n  IF (&T081 \u00ac= &Z)\n    VER (&T081,PICT,CCNN)\n    VER (&T082,PICT,NNNN)\n    IF (&T08 \u00ac= &Z)\n      IF (&T08 \u00ac= 'I','P')\n        .CURSOR = T08\n        .MSG = MBKS004C\n  IF (&T091 = &Z)\n    IF (&T092 \u00ac= &Z)\n      .CURSOR = T092\n      .MSG = MBKS004C\n    IF (&T09 \u00ac= &Z)\n      .CURSOR = T09\n      .MSG = MBKS004C\n  IF (&T091 \u00ac= &Z)\n    VER (&T091,PICT,CCNN)\n    VER (&T092,PICT,NNNN)\n    IF (&T09 \u00ac= &Z)\n      IF (&T09 \u00ac= 'I','P')\n        .CURSOR = T09\n        .MSG = MBKS004C\n  IF (&T101 = &Z)\n    IF (&T102 \u00ac= &Z)\n      .CURSOR = T102\n      .MSG = MBKS004C\n    IF (&T10 \u00ac= &Z)\n      .CURSOR = T10\n      .MSG = MBKS004C\n  IF (&T101 \u00ac= &Z)\n    VER (&T101,PICT,CCNN)\n    VER (&T102,PICT,NNNN)\n    IF (&T10 \u00ac= &Z)\n      IF (&T10 \u00ac= 'I','P')\n        .CURSOR = T10\n        .MSG = MBKS004C\n  IF (&T111 = &Z)\n    IF (&T112 \u00ac= &Z)\n      .CURSOR = T112\n      .MSG = MBKS004C\n    IF (&T11 \u00ac= &Z)\n      .CURSOR = T11\n      .MSG = MBKS004C\n  IF (&T111 \u00ac= &Z)\n    VER (&T111,PICT,CCNN)\n    VER (&T112,PICT,NNNN)\n    IF (&T11 \u00ac= &Z)\n      IF (&T11 \u00ac= 'I','P')\n        .CURSOR = T11\n        .MSG = MBKS004C\n  IF (&T121 = &Z)\n    IF (&T122 \u00ac= &Z)\n      .CURSOR = T122\n      .MSG = MBKS004C\n    IF (&T12 \u00ac= &Z)\n      .CURSOR = T12\n      .MSG = MBKS004C\n  IF (&T121 \u00ac= &Z)\n    VER (&T121,PICT,CCNN)\n    VER (&T122,PICT,NNNN)\n    IF (&T12 \u00ac= &Z)\n      IF (&T12 \u00ac= 'I','P')\n        .CURSOR = T12\n        .MSG = MBKS004C\n  IF (&T131 = &Z)\n    IF (&T132 \u00ac= &Z)\n      .CURSOR = T132\n      .MSG = MBKS004C\n    IF (&T13 \u00ac= &Z)\n      .CURSOR = T13\n      .MSG = MBKS004C\n  IF (&T131 \u00ac= &Z)\n    VER (&T131,PICT,CCNN)\n    VER (&T132,PICT,NNNN)\n    IF (&T13 \u00ac= &Z)\n      IF (&T13 \u00ac= 'I','P')\n        .CURSOR = T13\n        .MSG = MBKS004C\n  IF (&T141 = &Z)\n    IF (&T142 \u00ac= &Z)\n      .CURSOR = T142\n      .MSG = MBKS004C\n    IF (&T14 \u00ac= &Z)\n      .CURSOR = T14\n      .MSG = MBKS004C\n  IF (&T141 \u00ac= &Z)\n    VER (&T141,PICT,CCNN)\n    VER (&T142,PICT,NNNN)\n    IF (&T14 \u00ac= &Z)\n      IF (&T14 \u00ac= 'I','P')\n        .CURSOR = T14\n        .MSG = MBKS004C\n  IF (&T151 = &Z)\n    IF (&T152 \u00ac= &Z)\n      .CURSOR = T152\n      .MSG = MBKS004C\n    IF (&T15 \u00ac= &Z)\n      .CURSOR = T15\n      .MSG = MBKS004C\n  IF (&T151 \u00ac= &Z)\n    VER (&T151,PICT,CCNN)\n    VER (&T152,PICT,NNNN)\n    IF (&T15 \u00ac= &Z)\n      IF (&T15 \u00ac= 'I','P')\n        .CURSOR = T15\n        .MSG = MBKS004C\n  IF (&T161 = &Z)\n    IF (&T162 \u00ac= &Z)\n      .CURSOR = T162\n      .MSG = MBKS004C\n    IF (&T16 \u00ac= &Z)\n      .CURSOR = T16\n      .MSG = MBKS004C\n  IF (&T161 \u00ac= &Z)\n    VER (&T151,PICT,CCNN)\n    VER (&T152,PICT,NNNN)\n    IF (&T16 \u00ac= &Z)\n      IF (&T16 \u00ac= 'I','P')\n        .CURSOR = T16\n        .MSG = MBKS004C\n  IF (&T171 = &Z)\n    IF (&T172 \u00ac= &Z)\n      .CURSOR = T172\n      .MSG = MBKS004C\n    IF (&T17 \u00ac= &Z)\n      .CURSOR = T17\n      .MSG = MBKS004C\n  IF (&T171 \u00ac= &Z)\n    VER (&T171,PICT,CCNN)\n    VER (&T172,PICT,NNNN)\n    IF (&T17 \u00ac= &Z)\n      IF (&T17 \u00ac= 'I','P')\n        .CURSOR = T17\n        .MSG = MBKS004C\n  IF (&T181 = &Z)\n    IF (&T182 \u00ac= &Z)\n      .CURSOR = T182\n      .MSG = MBKS004C\n    IF (&T18 \u00ac= &Z)\n      .CURSOR = T18\n      .MSG = MBKS004C\n  IF (&T181 \u00ac= &Z)\n    VER (&T181,PICT,CCNN)\n    VER (&T182,PICT,NNNN)\n    IF (&T18 \u00ac= &Z)\n      IF (&T18 \u00ac= 'I','P')\n        .CURSOR = T18\n        .MSG = MBKS004C\n  IF (&T191 = &Z)\n    IF (&T192 \u00ac= &Z)\n      .CURSOR = T192\n      .MSG = MBKS004C\n    IF (&T19 \u00ac= &Z)\n      .CURSOR = T19\n      .MSG = MBKS004C\n  IF (&T191 \u00ac= &Z)\n    VER (&T191,PICT,CCNN)\n    VER (&T192,PICT,NNNN)\n    IF (&T19 \u00ac= &Z)\n      IF (&T19 \u00ac= 'I','P')\n        .CURSOR = T19\n        .MSG = MBKS004C\n  IF (&T201 = &Z)\n    IF (&T202 \u00ac= &Z)\n      .CURSOR = T202\n      .MSG = MBKS004C\n    IF (&T20 \u00ac= &Z)\n      .CURSOR = T20\n      .MSG = MBKS004C\n  IF (&T201 \u00ac= &Z)\n    VER (&T201,PICT,CCNN)\n    VER (&T202,PICT,NNNN)\n    IF (&T20 \u00ac= &Z)\n      IF (&T20 \u00ac= 'I','P')\n        .CURSOR = T20\n        .MSG = MBKS004C\n  IF (&T211 = &Z)\n    IF (&T212 \u00ac= &Z)\n      .CURSOR = T212\n      .MSG = MBKS004C\n    IF (&T21 \u00ac= &Z)\n      .CURSOR = T21\n      .MSG = MBKS004C\n  IF (&T211 \u00ac= &Z)\n    VER (&T211,PICT,CCNN)\n    VER (&T212,PICT,NNNN)\n    IF (&T21 \u00ac= &Z)\n      IF (&T21 \u00ac= 'I','P')\n        .CURSOR = T21\n        .MSG = MBKS004C\n  IF (&T221 = &Z)\n    IF (&T222 \u00ac= &Z)\n      .CURSOR = T222\n      .MSG = MBKS004C\n    IF (&T22 \u00ac= &Z)\n      .CURSOR = T22\n      .MSG = MBKS004C\n  IF (&T221 \u00ac= &Z)\n    VER (&T221,PICT,CCNN)\n    VER (&T222,PICT,NNNN)\n    IF (&T22 \u00ac= &Z)\n      IF (&T22 \u00ac= 'I','P')\n        .CURSOR = T22\n        .MSG = MBKS004C\n  IF (&T231 = &Z)\n    IF (&T232 \u00ac= &Z)\n      .CURSOR = T232\n      .MSG = MBKS004C\n    IF (&T23 \u00ac= &Z)\n      .CURSOR = T23\n      .MSG = MBKS004C\n  IF (&T231 \u00ac= &Z)\n    VER (&T231,PICT,CCNN)\n    VER (&T232,PICT,NNNN)\n    IF (&T23 \u00ac= &Z)\n      IF (&T23 \u00ac= 'I','P')\n        .CURSOR = T23\n        .MSG = MBKS004C\n  IF (&T241 = &Z)\n    IF (&T242 \u00ac= &Z)\n      .CURSOR = T242\n      .MSG = MBKS004C\n    IF (&T24 \u00ac= &Z)\n      .CURSOR = T24\n      .MSG = MBKS004C\n  IF (&T241 \u00ac= &Z)\n    VER (&T241,PICT,CCNN)\n    VER (&T242,PICT,NNNN)\n    IF (&T24 \u00ac= &Z)\n      IF (&T24 \u00ac= 'I','P')\n        .CURSOR = T24\n        .MSG = MBKS004C\n  IF (&T251 = &Z)\n    IF (&T252 \u00ac= &Z)\n      .CURSOR = T252\n      .MSG = MBKS004C\n    IF (&T25 \u00ac= &Z)\n      .CURSOR = T25\n      .MSG = MBKS004C\n  IF (&T251 \u00ac= &Z)\n    VER (&T251,PICT,CCNN)\n    VER (&T252,PICT,NNNN)\n    IF (&T25 \u00ac= &Z)\n      IF (&T25 \u00ac= 'I','P')\n        .CURSOR = T25\n        .MSG = MBKS004C\n  IF (&T261 = &Z)\n    IF (&T262 \u00ac= &Z)\n      .CURSOR = T262\n      .MSG = MBKS004C\n    IF (&T26 \u00ac= &Z)\n      .CURSOR = T26\n      .MSG = MBKS004C\n  IF (&T261 \u00ac= &Z)\n    VER (&T261,PICT,CCNN)\n    VER (&T262,PICT,NNNN)\n    IF (&T26 \u00ac= &Z)\n      IF (&T26 \u00ac= 'I','P')\n        .CURSOR = T26\n        .MSG = MBKS004C\n  IF (&T271 = &Z)\n    IF (&T272 \u00ac= &Z)\n      .CURSOR = T272\n      .MSG = MBKS004C\n    IF (&T27 \u00ac= &Z)\n      .CURSOR = T27\n      .MSG = MBKS004C\n  IF (&T271 \u00ac= &Z)\n    VER (&T271,PICT,CCNN)\n    VER (&T272,PICT,NNNN)\n    IF (&T27 \u00ac= &Z)\n      IF (&T27 \u00ac= 'I','P')\n        .CURSOR = T27\n        .MSG = MBKS004C\n  IF (&T281 = &Z)\n    IF (&T282 \u00ac= &Z)\n      .CURSOR = T282\n      .MSG = MBKS004C\n    IF (&T28 \u00ac= &Z)\n      .CURSOR = T28\n      .MSG = MBKS004C\n  IF (&T281 \u00ac= &Z)\n    VER (&T281,PICT,CCNN)\n    VER (&T282,PICT,NNNN)\n    IF (&T28 \u00ac= &Z)\n      IF (&T28 \u00ac= 'I','P')\n        .CURSOR = T28\n        .MSG = MBKS004C\n  IF (&T291 = &Z)\n    IF (&T292 \u00ac= &Z)\n      .CURSOR = T292\n      .MSG = MBKS004C\n    IF (&T29 \u00ac= &Z)\n      .CURSOR = T29\n      .MSG = MBKS004C\n  IF (&T291 \u00ac= &Z)\n    VER (&T291,PICT,CCNN)\n    VER (&T292,PICT,NNNN)\n    IF (&T29 \u00ac= &Z)\n      IF (&T29 \u00ac= 'I','P')\n        .CURSOR = T29\n        .MSG = MBKS004C\n  IF (&T301 = &Z)\n    IF (&T302 \u00ac= &Z)\n      .CURSOR = T302\n      .MSG = MBKS004C\n    IF (&T30 \u00ac= &Z)\n      .CURSOR = T30\n      .MSG = MBKS004C\n  IF (&T301 \u00ac= &Z)\n    VER (&T301,PICT,CCNN)\n    VER (&T302,PICT,NNNN)\n    IF (&T30 \u00ac= &Z)\n      IF (&T30 \u00ac= 'I','P')\n        .CURSOR = T30\n        .MSG = MBKS004C\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOK4": {"ttr": 31500, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893/\\x00\\x893/\\x16\\x03\\x00*\\x00*\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-28T00:00:00", "modifydate": "1989-11-28T16:03:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n@ TYPE(OUTPUT) INTENS(HIGH) SKIP(ON) CAPS(OFF)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n% TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n)BODY EXPAND(//)\n%-/-/- IBM Manuals List : entry full display -/-/-\n%COMMAND ===>_ZCMD                                                             +\n+\n+  Manual name :@CBMNO       +\n+  Title       :@CBTMN                             +\n+               Key-1    :@CBKW1   +          Key-2    :@CBKW2   +\n+               Location :@CBLOC   +          Room     :@CBROOM  +\n+               Date     :@CBDTE  +           User     :@CBUSR   +\n+\n+  Current number of Technical NewsLetters is :@CBNW0+\n+    @CBNW1      + @CBNW2      + @CBNW3      + @CBNW4      + @CBNW5      +\n+    @CBNW6      + @CBNW7      + @CBNW8      + @CBNW9      + @CBNW10     +\n+    @CBNW11     + @CBNW12     + @CBNW13     + @CBNW14     + @CBNW15     +\n+    @CBNW16     + @CBNW17     + @CBNW18     + @CBNW19     + @CBNW20     +\n+    @CBNW21     + @CBNW22     + @CBNW23     + @CBNW24     + @CBNW25     +\n+    @CBNW26     + @CBNW27     + @CBNW28     + @CBNW29     + @CBNW30     +\n+\n+Hit%ENTER+to continue with the next entry if any selected\n+Hit%&EPF+to cancel this operation and return to Manuals list panel\n+Hit%&HPF+to get explanation about Manuals List facility\n)INIT\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n  &ZCMD = &Z\n  .CURSOR = ZCMD\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOK5": {"ttr": 31745, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x18_\\x00\\x90\\x18_\\x08S\\x00\\xcd\\x00\\xcd\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-07-04T00:00:00", "modifydate": "1990-07-04T08:53:00", "lines": 205, "newlines": 205, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n@ TYPE(INPUT) INTENS(LOW) CAPS(OFF)\n# TYPE(INPUT) INTENS(LOW) CAPS(ON)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n% TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n)BODY EXPAND(//)\n%-/-/- IBM Manuals List : FIND process -/-/-\n%COMMAND ===>_ZCMD\n+\n%Specify your FIND argument for search below :\n+\n+  Manual no.  %===>#CBF1%-#CBF2%-#NW+(IBM format GGGG - NNNN - S or SS)\n+      or name %===>#CBFN        +    (or up to 12 characters name)\n+  Title       %===>@CBFT                              +(up to 34 characters)\n+  Key-1       %===>#CBFK1   +        (up to 8 characters keyword-1 name)\n+  Key-2       %===>#CBFK2   +        (up to 8 characters keyword-2 name)\n+  Location    %===>#CBV +            (sequence, up to 4 numerics, format SSSS)\n+              %===>#CBW+             (number, up to 3 numerics, format NNN)\n+  Room        %===>#CBFR    +        (up to 8 characters room name)\n+  Date        %===>#CBFD   +         (DDMMMYY, where MMM is JAN, FEB, ...)\n+  TNL number  %===>#CBFX%-#CBFY+     (IBM format GGGG - NNNN)\n+\n%Note :+only one field argument is accepted by the FIND command.\n+\n+Hit%ENTER+to execute the FIND process\n+Hit%&EPF+to cancel this operation and return to Manuals list panel\n+Hit%&HPF+to get explanation about Manuals List facility\n)INIT\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n  &ZCMD = &Z\n  .CURSOR = CBF1\n  &CBF1 = &Z\n  &CBF2 = &Z\n  &NW = &Z\n  &CBFN = &Z\n  &CBFT = &Z\n  &CBFK1 = &Z\n  &CBFK2 = &Z\n  &CBV = &Z\n  &CBW = &Z\n  &CBFR = &Z\n  &CBFD = &Z\n  &CBFDS = &Z\n  &CBFX = &Z\n  &CBFY = &Z\n)PROC\n  &CBSW = NO\n  IF (&CBF1 \u00ac= &Z)\n    IF (&CBFN \u00ac= &Z)\n      .MSG = MBKS006A\n    IF (&CBFT \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFK1 \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFK2 \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBV \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBW \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFR \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFD \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFX \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFY \u00ac= &Z)\n      .MSG = MBKS006E\n    VER (&CBF1,PICT,CCNN)\n      IF (&CBF2 \u00ac= &Z)\n        VER (&CBF2,PICT,NNNN)\n      IF (&NW \u00ac= &Z)\n        VER (&NW,NB,NUM)\n        IF (&CBF2 = &Z)\n          .MSG = MBKS006B\n    &CBSW = YES\n  IF (&CBF1 = &Z)\n    IF (&CBF2 \u00ac= &Z)\n      .MSG = MBKS006B\n    IF (&NW \u00ac= &Z)\n      .MSG = MBKS006B\n  IF (&CBFN \u00ac= &Z)\n    IF (&CBFT \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFK1 \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFK2 \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBV \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBW \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFR \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFD \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFX \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFY \u00ac= &Z)\n      .MSG = MBKS006E\n    &CBSW = YES\n  IF (&CBFT \u00ac= &Z)\n    IF (&CBFK1 \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFK2 \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBV \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBW \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFR \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFD \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFX \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFY \u00ac= &Z)\n      .MSG = MBKS006E\n    &CBSW = YES\n  IF (&CBFK1 \u00ac= &Z)\n    IF (&CBFK2 \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBV \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBW \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFR \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFD \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFX \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFY \u00ac= &Z)\n      .MSG = MBKS006E\n    &CBSW = YES\n  IF (&CBFK2 \u00ac= &Z)\n    IF (&CBV \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBW \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFR \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFD \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFX \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFY \u00ac= &Z)\n      .MSG = MBKS006E\n    &CBSW = YES\n  IF (&CBV \u00ac= &Z)\n    IF (&CBFR \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFD \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFX \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFY \u00ac= &Z)\n      .MSG = MBKS006E\n    VER (&CBV,NB,NUM)\n    VER (&CBW,NB,NUM)\n    &CBSW = YES\n  IF (&CBFR \u00ac= &Z)\n    IF (&CBFD \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFX \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFY \u00ac= &Z)\n      .MSG = MBKS006E\n    &CBSW = YES\n  IF (&CBFD \u00ac= &Z)\n    IF (&CBFX \u00ac= &Z)\n      .MSG = MBKS006E\n    IF (&CBFY \u00ac= &Z)\n      .MSG = MBKS006E\n    &DD = TRUNC(&CBFD,2)\n    VER (&DD,NB,NUM,MSG=MBKS006D)\n    &ZTRAIL = .TRAIL\n    &MM = TRANS(TRUNC(&ZTRAIL,3)\n                JAN,01 FEB,02 MAR,03 APR,04 MAY,05 JUN,06\n                JUL,07 AUG,08 SEP,09 OCT,10 NOV,11 DEC,12\n                MSG=MBKS006D)\n    &YY = .TRAIL\n    VER (&YY,NB,NUM,MSG=MBKS006D)\n    &CBFDS = '&YY.&MM.&DD'\n    &CBSW = YES\n  IF (&CBFX \u00ac= &Z)\n    VER (&CBFX,PICT,CCNN)\n    IF (&CBFY \u00ac= &Z)\n      VER (&CBFY,PICT,NNNN)\n    &CBSW = YES\n  IF (&CBSW = NO)\n    .CURSOR = CBF1\n    .MSG = MBKS006C\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBOOK6": {"ttr": 31749, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x18_\\x00\\x90\\x18_\\x08S\\x01\\x16\\x01\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-07-04T00:00:00", "modifydate": "1990-07-04T08:53:00", "lines": 278, "newlines": 278, "modlines": 0, "user": "SYSPAJA"}, "text": ")ATTR\n# TYPE(INPUT) INTENS(LOW) CAPS(ON)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n% TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n)BODY EXPAND(//)\n%-/-/- IBM Manuals List : NewsLetters -/-/-\n%COMMAND ===>_ZCMD                                                             +\n+\n%Define, add or update Technical NewsLetters to a not received manual :\n+  Manual no.  %===>#CBN1%-#CBN2%-#NW+(IBM format GGGG - NNNN - S or SS)\n+      or name %===>#CBGNS       +    (or up to 12 characters name)\n+  Location    %===>#CBX +            (sequence, up to 4 numerics, format SSSS)\n+              %===>#CBY+             (number, up to 3 numerics, format NNN)\n+  Room        %===>#CBROOM  +        (up to 8 characters room name)\n+Enter TNL no.s in IBM format%GGGG - NNNN+:\n%===>#T011%-#T012+          %===>#T021%-#T022+          %===>#T031%-#T032+\n%   >#T041%-#T042+          %   >#T051%-#T052+          %   >#T061%-#T062+\n%   >#T071%-#T072+          %   >#T081%-#T082+          %   >#T091%-#T092+\n%   >#T101%-#T102+          %   >#T111%-#T112+          %   >#T121%-#T122+\n%   >#T131%-#T132+          %   >#T141%-#T142+          %   >#T151%-#T152+\n%   >#T161%-#T162+          %   >#T171%-#T172+          %   >#T181%-#T182+\n%   >#T191%-#T192+          %   >#T201%-#T202+          %   >#T211%-#T212+\n%   >#T221%-#T222+          %   >#T231%-#T232+          %   >#T241%-#T242+\n%   >#T251%-#T252+          %   >#T261%-#T262+          %   >#T271%-#T272+\n%   >#T281%-#T282+          %   >#T291%-#T292+          %   >#T301%-#T302+\n+\n+Hit%ENTER+to update the information for this entry\n+Hit%&EPF+to cancel this operation and return to Manuals list panel\n+Hit%&HPF+to get explanation about Manuals List facility\n)INIT\n  &HPF = PFK(HELP)\n  IF (&HPF = &Z)\n    &HPF = 'HELP'\n  &EPF = PFK(END)\n  IF (&EPF = &Z)\n    &EPF = 'END'\n  &D = TRUNC(&EPF,2)\n  &DT = .TRAIL\n  &D = TRUNC(&DT,1)\n  IF (&D = '0')\n    &DT = .TRAIL\n    &EPF = 'PF&DT'\n  &ZCMD = &Z\n  .CURSOR = CBN1\n  &MM = TRANS(&ZMONTH\n             01,JAN 02,FEB 03,MAR 04,APR 05,MAY 06,JUN\n             07,JUL 08,AUG 09,SEP 10,OCT 11,NOV 12,DEC)\n  &CBDTE = '&ZDAY.&MM.&ZYEAR'\n  &CBSORT = '&ZYEAR.&ZMONTH.&ZDAY'\n)PROC\n  IF (&CBN1 = &Z)\n    IF (&CBGNS = &Z)\n      .MSG = MBKS004A\n    IF (&CBN2 \u00ac= &Z)\n      .MSG = MBKS004T\n    IF (&NW \u00ac= &Z)\n      .MSG = MBKS004T\n    VER (&CBGNS,NB)\n  IF (&CBN1 \u00ac= &Z)\n    IF (&CBGNS \u00ac= &Z)\n      .MSG = MBKS004B\n    VER (&CBN1,PICT,CCNN)\n    VER (&CBN2,PICT,NNNN)\n    VER (&NW,NB,NUM)\n  VER (&CBX,NB,NUM)\n  VER (&CBY,NB,NUM)\n  VER (&CBROOM,NB)\n  IF (&T011 = &Z)\n    IF (&T012 \u00ac= &Z)\n      .CURSOR = T012\n      .MSG = MBKS004E\n  IF (&T011 \u00ac= &Z)\n    VER (&T011,PICT,CCNN)\n    VER (&T012,PICT,NNNN)\n  IF (&T021 = &Z)\n    IF (&T022 \u00ac= &Z)\n      .CURSOR = T022\n      .MSG = MBKS004E\n  IF (&T021 \u00ac= &Z)\n    VER (&T021,PICT,CCNN)\n    VER (&T022,PICT,NNNN)\n  IF (&T031 = &Z)\n    IF (&T032 \u00ac= &Z)\n      .CURSOR = T032\n      .MSG = MBKS004E\n  IF (&T031 \u00ac= &Z)\n    VER (&T031,PICT,CCNN)\n    VER (&T032,PICT,NNNN)\n  IF (&T041 = &Z)\n    IF (&T042 \u00ac= &Z)\n      .CURSOR = T042\n      .MSG = MBKS004E\n  IF (&T041 \u00ac= &Z)\n    VER (&T041,PICT,CCNN)\n    VER (&T042,PICT,NNNN)\n  IF (&T051 = &Z)\n    IF (&T052 \u00ac= &Z)\n      .CURSOR = T052\n      .MSG = MBKS004E\n  IF (&T051 \u00ac= &Z)\n    VER (&T051,PICT,CCNN)\n    VER (&T052,PICT,NNNN)\n  IF (&T061 = &Z)\n    IF (&T062 \u00ac= &Z)\n      .CURSOR = T062\n      .MSG = MBKS004E\n  IF (&T061 \u00ac= &Z)\n    VER (&T061,PICT,CCNN)\n    VER (&T062,PICT,NNNN)\n  IF (&T071 = &Z)\n    IF (&T072 \u00ac= &Z)\n      .CURSOR = T072\n      .MSG = MBKS004E\n  IF (&T071 \u00ac= &Z)\n    VER (&T071,PICT,CCNN)\n    VER (&T072,PICT,NNNN)\n  IF (&T081 = &Z)\n    IF (&T082 \u00ac= &Z)\n      .CURSOR = T082\n      .MSG = MBKS004E\n  IF (&T081 \u00ac= &Z)\n    VER (&T081,PICT,CCNN)\n    VER (&T082,PICT,NNNN)\n  IF (&T091 = &Z)\n    IF (&T092 \u00ac= &Z)\n      .CURSOR = T092\n      .MSG = MBKS004E\n  IF (&T091 \u00ac= &Z)\n    VER (&T091,PICT,CCNN)\n    VER (&T092,PICT,NNNN)\n  IF (&T101 = &Z)\n    IF (&T102 \u00ac= &Z)\n      .CURSOR = T102\n      .MSG = MBKS004E\n  IF (&T101 \u00ac= &Z)\n    VER (&T101,PICT,CCNN)\n    VER (&T102,PICT,NNNN)\n  IF (&T111 = &Z)\n    IF (&T112 \u00ac= &Z)\n      .CURSOR = T112\n      .MSG = MBKS004E\n  IF (&T111 \u00ac= &Z)\n    VER (&T111,PICT,CCNN)\n    VER (&T112,PICT,NNNN)\n  IF (&T121 = &Z)\n    IF (&T122 \u00ac= &Z)\n      .CURSOR = T122\n      .MSG = MBKS004E\n  IF (&T121 \u00ac= &Z)\n    VER (&T121,PICT,CCNN)\n    VER (&T122,PICT,NNNN)\n  IF (&T131 = &Z)\n    IF (&T132 \u00ac= &Z)\n      .CURSOR = T132\n      .MSG = MBKS004E\n  IF (&T131 \u00ac= &Z)\n    VER (&T131,PICT,CCNN)\n    VER (&T132,PICT,NNNN)\n  IF (&T141 = &Z)\n    IF (&T142 \u00ac= &Z)\n      .CURSOR = T142\n      .MSG = MBKS004E\n  IF (&T141 \u00ac= &Z)\n    VER (&T141,PICT,CCNN)\n    VER (&T142,PICT,NNNN)\n  IF (&T151 = &Z)\n    IF (&T152 \u00ac= &Z)\n      .CURSOR = T152\n      .MSG = MBKS004E\n  IF (&T151 \u00ac= &Z)\n    VER (&T151,PICT,CCNN)\n    VER (&T152,PICT,NNNN)\n  IF (&T161 = &Z)\n    IF (&T162 \u00ac= &Z)\n      .CURSOR = T162\n      .MSG = MBKS004E\n  IF (&T161 \u00ac= &Z)\n    VER (&T161,PICT,CCNN)\n    VER (&T162,PICT,NNNN)\n  IF (&T171 = &Z)\n    IF (&T172 \u00ac= &Z)\n      .CURSOR = T172\n      .MSG = MBKS004E\n  IF (&T171 \u00ac= &Z)\n    VER (&T171,PICT,CCNN)\n    VER (&T172,PICT,NNNN)\n  IF (&T181 = &Z)\n    IF (&T182 \u00ac= &Z)\n      .CURSOR = T182\n      .MSG = MBKS004E\n  IF (&T181 \u00ac= &Z)\n    VER (&T181,PICT,CCNN)\n    VER (&T182,PICT,NNNN)\n  IF (&T191 = &Z)\n    IF (&T192 \u00ac= &Z)\n      .CURSOR = T192\n      .MSG = MBKS004E\n  IF (&T191 \u00ac= &Z)\n    VER (&T191,PICT,CCNN)\n    VER (&T192,PICT,NNNN)\n  IF (&T201 = &Z)\n    IF (&T202 \u00ac= &Z)\n      .CURSOR = T202\n      .MSG = MBKS004E\n  IF (&T201 \u00ac= &Z)\n    VER (&T201,PICT,CCNN)\n    VER (&T202,PICT,NNNN)\n  IF (&T211 = &Z)\n    IF (&T212 \u00ac= &Z)\n      .CURSOR = T212\n      .MSG = MBKS004E\n  IF (&T211 \u00ac= &Z)\n    VER (&T211,PICT,CCNN)\n    VER (&T212,PICT,NNNN)\n  IF (&T221 = &Z)\n    IF (&T222 \u00ac= &Z)\n      .CURSOR = T222\n      .MSG = MBKS004E\n  IF (&T221 \u00ac= &Z)\n    VER (&T221,PICT,CCNN)\n    VER (&T222,PICT,NNNN)\n  IF (&T231 = &Z)\n    IF (&T232 \u00ac= &Z)\n      .CURSOR = T232\n      .MSG = MBKS004E\n  IF (&T231 \u00ac= &Z)\n    VER (&T231,PICT,CCNN)\n    VER (&T232,PICT,NNNN)\n  IF (&T241 = &Z)\n    IF (&T242 \u00ac= &Z)\n      .CURSOR = T242\n      .MSG = MBKS004E\n  IF (&T241 \u00ac= &Z)\n    VER (&T241,PICT,CCNN)\n    VER (&T242,PICT,NNNN)\n  IF (&T251 = &Z)\n    IF (&T252 \u00ac= &Z)\n      .CURSOR = T252\n      .MSG = MBKS004E\n  IF (&T251 \u00ac= &Z)\n    VER (&T251,PICT,CCNN)\n    VER (&T252,PICT,NNNN)\n  IF (&T261 = &Z)\n    IF (&T262 \u00ac= &Z)\n      .CURSOR = T262\n      .MSG = MBKS004E\n  IF (&T261 \u00ac= &Z)\n    VER (&T261,PICT,CCNN)\n    VER (&T262,PICT,NNNN)\n  IF (&T271 = &Z)\n    IF (&T272 \u00ac= &Z)\n      .CURSOR = T272\n      .MSG = MBKS004E\n  IF (&T271 \u00ac= &Z)\n    VER (&T271,PICT,CCNN)\n    VER (&T272,PICT,NNNN)\n  IF (&T281 = &Z)\n    IF (&T282 \u00ac= &Z)\n      .CURSOR = T282\n      .MSG = MBKS004E\n  IF (&T281 \u00ac= &Z)\n    VER (&T281,PICT,CCNN)\n    VER (&T282,PICT,NNNN)\n  IF (&T291 = &Z)\n    IF (&T292 \u00ac= &Z)\n      .CURSOR = T292\n      .MSG = MBKS004E\n  IF (&T291 \u00ac= &Z)\n    VER (&T291,PICT,CCNN)\n    VER (&T292,PICT,NNNN)\n  IF (&T301 = &Z)\n    IF (&T302 \u00ac= &Z)\n      .CURSOR = T302\n      .MSG = MBKS004E\n  IF (&T301 \u00ac= &Z)\n    VER (&T301,PICT,CCNN)\n    VER (&T302,PICT,NNNN)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDREAD": {"ttr": 31754, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x1f\\x00\\x93\\x06\\x1f\\tV\\x02\\x0c\\x02\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-02T00:00:00", "modifydate": "1993-03-02T09:56:00", "lines": 524, "newlines": 524, "modlines": 0, "user": "SYSPAJA"}, "text": "PDR      TITLE 'READ PARTITIONED DIRECTORY SUBROUTINE.'\nPDREAD   START 0\n         SPACE 2\n* CALLING SEQUENCE : CALL PDREAD,(A,B,C),VL\n* ------------------             (A,B)\n*                                (A)\n*\n*        WHERE : A - IS THE ADDRESS OF AN ARRAY (FORMAT XL74) INTO\n*                    WHICH THE NEXT SEQUENTIAL DIRECTORY ENTRY OF A\n*                    PARTITIONED DATA-SET IS MOVED.\n*\n*                B - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSDIR  '.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                    -1 - DIRECTORY REACHES END-OF-FILE.\n*                     0 - READ CORRECTLY EXECUTED.\n*                     1 - FILE NOT OPENED.\n*                     2 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     3 - READ ERROR.\n*\n* CALLING SEQUENCE : CALL PDOPEN,(A,B,C),VL\n* ------------------             (A,B)\n*                                (A)\n*\n*        WHERE : A - IS THE ADDRESS OF A RESPONSE FIELD (FORMAT CL50)\n*                    IF SUPPLIED (OPTIONAL). THE INFORMATION RETURNED\n*                    BACK TO THE CALLER ARE THE DATA-SET NAME (CL44)\n*                    FOLLOWED BY THE VOLUME SERIAL NUMBER (CL6).\n*\n*                B - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSDIR  '.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - OPEN CORRECTLY EXECUTED.\n*                     1 - DD-CARD MISSING.\n*                     2 - OPEN ERROR OR DD-CARD CONFLICT.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - FILE ALREADY OPENED.\n*                     5 - FILE RDJFCB ERROR.\n*                     6 - FILE OBTAIN ERROR.\n*                     7 - NOT PARTITIONED DATA-SET.\n         EJECT\n* CALLING SEQUENCE : CALL PDCLOSE,(A,B),VL\n* ------------------              (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) TO\n*                    CLOSE. IF THIS ARGUMENT CONTAINS THE 'CLOSEALL'\n*                    KEYWORD, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, OR THE PARAMETERS\n*                    LIST POINTER (REGISTER 1) IS ZERO, ALL THE OPENED\n*                    FILES ARE CLOSED.\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE, ARGUMENT ALIGNMENT OR\n*                         DD-NAME ERROR.\n         SPACE 2\n* GENERAL NOTICE : ON ANY ERROR DETECTION, A MESSAGE IS INCLUDED IN\n* ---------------- THE MESSAGE CLASS FOR THE JOB.\n*                  IF THE ROUTINE IS RE-CALLED AFTER IND = 1 OR 2,\n*                  THE PROGRAM IS SENDED IN ABEND U0001.\n*                  IF THE INDICATOR RESPONSE IS DETECTED 10 TIMES\n*                  DIFFERENT FROM 0, THE PROGRAM IS SENDED IN\n*                  ABEND U0002.\n*                  MVS/XA : MUST BE AMODE AND RMODE 24.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\n         EJECT\n        PRINT  NOGEN\nTIODSECT DSECT\n        IEFTIOT1\nJFCDSECT DSECT\n        IEFJFCBN LIST=YES\nDSCDSECT DSECT\n        IECSDSL1 (1)\nDSCBLGTH EQU   DS1END-IECSDSL1\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 1\n*        FILE BLOCK WORK AREA DESCRIPTION.\n         SPACE 1\nFBWAD    DSECT\nFCHAIN   DC    F'0'                CHAIN WORD.\nFDDNM    DC    CL8' '              DD-NAME.\nFERCNT   DC    H'10'               ERROR COUNT.\nFFLAGS   DC    XL1'0'              FLAGS BYTE.\nFAB      EQU   X'01'                    ABEND.\nFOE      EQU   X'02'                    OPEN ERROR.\nFRE      EQU   X'04'                    READ ERROR.\nFRY      EQU   X'10'                    BLOCK IS READY.\n         DC    XL1'0'              UNUSED.\nFIOAR    DC    F'0'                ADDRESS OF AREA TO HOLD ONE BLOCK.\nFLAST    DC    F'0'                END OF BLOCK POSITION.\nFPOSIT   DC    F'0'                CURRENT BLOCK POSITION.\n         SPACE 1\nPDREAD   CSECT                     RESTORE MAIN CSECT.\n         EJECT\n        $XENT  BASE=R12\n         SPACE 1\n         LA    R6,TABD             SET DEFAULTS.\n         LA    R7,DDDEF\n         SR    R9,R9\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    RD1\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         LTR   R8,R8\n         BZ    *+L'*+2\n         LR    R7,R8\n         TM    4(R1),X'80'\n         BO    RD1\n         TM    8(R1),X'80'\n         BZ    ERR2\n         TM    11(R1),X'03'\n         BNZ   ERR2\n         L     R9,8(R1)\n         LA    R9,0(R9)\nRD1      L     R8,0(R1)\n         LA    R8,0(R8)\n         SPACE 1\n         LA    R4,CHAIN\n         USING FBWAD,R4\nRD2      L     R4,FCHAIN           LOOK IF OPENED.\n         LTR   R4,R4\n         BZ    ERR1\n         CLC   FDDNM(L'FDDNM),0(R7)\n         BNE   RD2\n         TM    FFLAGS,FAB          TEST ABEND SWITCH.\n         BO    ABND1\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    ERR1\n         NI    FFLAGS,255-FRE      RESET READ ERROR SWITCH.\n         TM    FFLAGS,FRY          DO I NEED TO READ A BLOCK?\n         BO    RD3                 NO.\n         L     R3,FIOAR            AREA ADDRESS.\n         LA    R1,DY(R4)           DECB ADDRESS.\n        READ   (1),SF,(R2),(R3),'S',MF=E\n         LA    R1,DY(R4)           DECB ADDRESS.\n        CHECK  (1)\n         TM    FFLAGS,FRE          TEST READ ERROR SWITCH.\n         BO    ERR3\n         SPACE 1\n         OI    FFLAGS,FRY          INDICATE BLOCK READ.\n         LH    R5,0(R3)            COMPUTE REAL BLOCK LENGTH.\n         LA    R5,0(R3,R5)\n         ST    R5,FLAST            SET LAST + 1 POINTER.\n         LA    R3,2(R3)            SKIP COUNT FIELD\n         B     RD4\nRD3      L     R3,FPOSIT           GET CURRENT POINTER.\nRD4      CLI   0(R3),X'FF'         LAST ENTRY IN DIRECTORY ?\n         BE    RDEND\n         SR    R5,R5               COMPUTE LENGTH OF ENTRY\n         IC    R5,11(R3)\n         LA    R1,X'1F'\n         NR    R5,R1\n         LA    R5,12(R5,R5)\n         BCTR  R5,0\n         EX    R5,MVRECL           GIVE TO CALLER THE ENTRY.\n         LA    R3,1(R3,R5)         POINTS AT NEXT ENTRY.\n         CL    R3,FLAST            IS BLOCK EXHAUSTED?\n         BNL   RD5                 YES.\n         ST    R3,FPOSIT           NO, SAVE CURRENT POINTER.\n         B     RD6\nRD5      NI    FFLAGS,255-FRY      INDICATE READ NECESSARY.\nRD6      SR    R10,R10\n         B     EXIT4\nMVRECL   MVC   0(*-*,R8),0(R3)\n         DROP  R2\n         SPACE 1\nRDERR    OI    FFLAGS,FRE          SET READ ERROR SWITCH.\n         BR    R14\n         SPACE 1\nRDEND    NI    FFLAGS,255-FRY      RESET INDICATOR.\n         SR    R10,R10\n         BCTR  R10,0\n         B     EXIT4\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nMAXERR   EQU   ((*-ERR1)/2)+1\n         B     EXIT\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY PDOPEN\n         SPACE 1\nPDOPEN  $XENT  BASE=R12,DT=NO\n         SPACE 1\n         LA    R6,TABO             SET DEFAULTS.\n         LA    R7,DDDEF\n         SR    R9,R9\n         LA    R10,MAXERO\n         SR    R8,R8               CONTROL ARGUMENTS.\n         LTR   R1,R1\n         BZ    OP1\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         TM    0(R1),X'80'\n         BO    OP1\n         L     R3,4(R1)\n         LA    R3,0(R3)\n         LTR   R3,R3\n         BZ    *+L'*+2\n         LR    R7,R3\n         TM    4(R1),X'80'\n         BO    OP1\n         TM    8(R1),X'80'\n         BZ    ERO3\n         TM    11(R1),X'03'\n         BNZ   ERO3\n         L     R9,8(R1)\n         LA    R9,0(R9)\n         SPACE 1\nOP1      LA    R3,CHAIN            LOOK IF ALREADY DEFINED.\n         USING FBWAD,R4\nOP2      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    OP3\n         CLC   FDDNM(L'FDDNM),0(R7)\n         BE    ERO4\n         LR    R3,R4\n         B     OP2\nOP3     GETMAIN R,LV=WSZ\n         LR    R4,R1\n         ST    R4,0(R3)            NEW FILE.\n         MVC   FCHAIN(WSZ),BFILE   SET SKELETON.\n         MVC   FDDNM(L'FDDNM),0(R7)\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         MVC   DCBDDNAM(L'DCBDDNAM),FDDNM\n         OC    ATIOT(L'ATIOT),ATIOT     TEST FIRST TIME.\n         BNZ   OP4\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\nOP4      L     R3,ATIOT            SEARCH DD AND OPEN IT.\n         USING TIODSECT,R3\nOP5      CLC   TIOELNGH(4),ZEROS\n         BE    ERO1\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM\n         BE    OP6\n         SR    R1,R1\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     OP5\n         DROP  R3\nOP6      XC    JFCBAREA(JFCBLGTH),JFCBAREA\n        RDJFCB ((R2))\n         LTR   R15,R15\n         BNZ   ERO5\n         LA    R1,JFCBAREA\n         USING INFMJFCB,R1\n         LTR   R8,R8\n         BZ    *+L'*+12\n         MVC   0(L'JFCBDSNM,R8),JFCBDSNM\n         MVC   0+L'JFCBDSNM(6,R8),JFCBVOLS\n         LA    R0,JFCBDSNM\n         ST    R0,DSCBF1+4\n         LA    R0,JFCBVOLS\n         ST    R0,DSCBF1+8\n         DROP  R1\n         XC    DSCBAREA(DSCBLGTH),DSCBAREA\n        OBTAIN DSCBF1\n         LTR   R15,R15\n         BZ    OP7\n         CVD   R15,DBLWD\n         UNPK  DBLWD(3),DBLWD+L'DBLWD-2(2)\n         OI    DBLWD+2,C'0'\n         MVC   DIAG10+38(2),DBLWD+1\n         B     ERO6\nOP7      LA    R1,DSCBAREA\n         USING DS1FMTID,R1\n         TM    DS1DSORG,DS1DSGPO\n         BZ    ERO7                NOT PARTITIONED DATA-SET\n         DROP  R1\n         IC    R0,DCBEXLST\n         SLL   R0,24\n         LA    R1,REXLIST\n         SLL   R1,8\n         SRL   R1,8\n         OR    R1,R0\n         ST    R1,DCBEXLST\n        OPEN   ((R2),(INPUT))\n         TM    FFLAGS,FOE          TEST OPEN ERROR SWITCH.\n         BO    ERO2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPEN SUCCESSFULL.\n         BZ    ERO2\n         LH    R0,DCBBLKSI\n         DROP  R2\n        GETMAIN R,LV=(0)\n         ST    R1,FIOAR            SAVE ADDRESS OF I/O AREA.\n         SR    R10,R10\n         B     EXIT4\n         SPACE 1\nERO1     BCTR  R10,0\nERO2     BCTR  R10,0\n         OI    FFLAGS,FAB          SET ABEND SWITCH TO PREVENT RE-CALL.\nERO3     BCTR  R10,0\nERO4     BCTR  R10,0\nERO5     BCTR  R10,0\nERO6     BCTR  R10,0\nERO7     BCTR  R10,0\nMAXERO   EQU   (((*-ERO1)-4)/2)+1\n         B     EXIT\n         SPACE 2\n         USING IHADCB,R1\nDCBEXIT  CLI   DCBRECFM,DCBRECF    JUST CONTROL.\n         BNE   EX1\n         CLI   DCBKEYLE,0\n         BNE   EX1\n         LA    R2,256\n         CH    R2,DCBBLKSI\n         BNE   EX1\n         STH   R2,DCBLRECL         FORCE IT\n         DROP  R1\n         BR    R14\nEX1      OI    FFLAGS,FOE          SET OPEN ERROR SWITCH.\n         BR    R14\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY PDCLOSE\n         SPACE 1\nPDCLOSE $XENT  BASE=R12,DT=NO\n         SPACE 1\n         LA    R6,TABC             CONTROL ARGUMENTS.\n         SR    R9,R9\n         LA    R10,1\n         LTR   R8,R1\n         BZ    CL2\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         TM    0(R1),X'80'\n         BO    CL1\n         TM    4(R1),X'80'\n         BZ    EXIT\n         TM    7(R1),X'03'\n         BNZ   EXIT\n         L     R9,4(R1)\n         LA    R9,0(R9)\nCL1      LTR   R8,R8\n         BZ    CL2\n         CLC   0(8,R8),KEYALL\n         BNE   CL2\n         SR    R8,R8\n         SPACE 1\nCL2      LA    R3,CHAIN\n         USING FBWAD,R4\nCL3      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    CL7\n         LTR   R8,R8\n         BZ    CL4\n         CLC   0(L'FDDNM,R8),FDDNM\n         BE    CL4\n         LR    R3,R4\n         B     CL3\nCL4      LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    CL5\n        CLOSE  ((R2))\nCL5      LH    R0,DCBBLKSI\n         DROP  R2\n         L     R1,FIOAR\n         LTR   R1,R1\n         BZ    CL6\n        FREEMAIN R,A=(1),LV=(0)\nCL6      MVC   0(L'FCHAIN,R3),FCHAIN    DEQUEUE FILE.\n         LR    R1,R4\n        FREEMAIN R,A=(1),LV=WSZ\n         LTR   R8,R8\n         BNZ   CL8\n         B     CL3\nCL7      LTR   R8,R8\n         BNZ   EXIT\nCL8      SR    R10,R10\n         B     EXIT4\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\nEXIT     BASR  R12,0\n         USING *,R12\n         LR    R2,R10\n         BCTR  R2,0\n         SLL   R2,2\n         L     R3,0(R2,R6)\n         NI    SWEX+1,OFF          SET SWITCH OFF.\n         CLI   12(R3),C' '\n         BNE   *+L'*+10\n         OI    SWEX+1,ON           SET SWITCH ON.\n         MVC   12(8,R3),0(R7)\n         LR    R1,R3\n        WTO    MF=(E,(1))\nSWEX     B     EXIT1\n         LA    R3,CNTR             CONTROL MAX. ERROR.\n         B     EXIT2\nEXIT1    MVC   12(8,R3),BLKS\n         LTR   R4,R4\n         BZ    SWEX+L'SWEX\n         USING FBWAD,R4\n         LA    R3,FERCNT\n         DROP  R4\nEXIT2    LH    R2,0(R3)\n         BCT   R2,EXIT3\n         LA    R1,2                SET ABEND CODE.\n         B     ABND\nEXIT3    STH   R2,0(R3)\n         DROP  R12\n         SPACE 1\nEXIT4    BASR  R12,0\n         USING *,R12\n         LTR   R9,R9\n         BZ    EXIT5\n         ST    R10,0(R9)           STORE IND.\nEXIT5   $XRET  CC=(R10)\n         DROP  R12\n         SPACE 1\nABND1    LA    R1,1                SET ABEND CODE.\n         SPACE 1\nABND     BASR  R12,0\n         USING *,R12\n         LR    R15,R10             SET C.C. IN REG. 15.\n        ABEND  (1),DUMP\n         SPACE 1\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nDBLWD    DC    D'0'\nDSCBF1  CAMLST SEARCH,*-*,*-*,DSCBAREA\nCHAIN    DC    A(*-*)\nATIOT    DC    A(*-*)\nTABD     DC    A(DIAG5,DIAG6,DIAG7)\nTABO     DC    A(DIAG1,DIAG2,DIAG3,DIAG4,DIAG9,DIAG10,DIAG11)\nTABC     DC    A(DIAG8)\nZEROS    DC    F'0'\nDIAG1   WTO    'ERR=1 -          DD-CARD MISSING.',                    1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG2   WTO    'ERR=2 -          OPEN ERROR OR DD-CARD CONFLICT.',     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG3   WTO    'ERR=3 - PDOPEN CALLING SEQUENCE OR ARGUMENT ALIGNMENT E1\n               RROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG4   WTO    'ERR=4 -          ALREADY OPENED.',                     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG5   WTO    'ERR=1 -          NOT OPENED.',                         1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG6   WTO    'ERR=2 - PDREAD CALLING SEQUENCE OR ARGUMENT ALIGNMENT E1\n               RROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG7   WTO    'ERR=3 -          I/O ERROR.',                          1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG8   WTO    'ERR=1 - PDCLOSE CALLING SEQUENCE, ARGUMENT ALIGNMENT OR1\n                DD-NAME ERROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG9   WTO    'ERR=5 -          RDJFCB ERROR.',                       1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG10  WTO    'ERR=6 -          OBTAIN ERROR (RC=  ).',               1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG11  WTO    'ERR=7 -          NOT PARTITIONED DATA-SET.',           1\n               ROUTCDE=11,DESC=7,MF=L\nCNTR     DC    H'10'\nDDDEF    DC    CL8'SYSDIR  '\nKEYALL   DC    CL8'CLOSEALL'\nBLKS     DC    CL8' '\n         EJECT\n        CNOP   0,8\n         SPACE 1\nBFILE    DC    F'0'                CHAIN WORD.\n         DC    CL8' '              DD-NAME.\n         DC    H'10'               ERROR COUNT.\n         DC    XL1'0'              FLAGS BYTE.\n         DC    XL1'0'              UNUSED.\n         DC    F'0'                ADDRESS OF AREA TO HOLD ONE BLOCK.\n         DC    F'0'                END OF BLOCK POSITION.\n         DC    F'0'                CURRENT BLOCK POSITION.\n         SPACE 1\nDCBDIR  DCB    DSORG=PS,DEVD=DA,MACRF=(R),BFALN=D,RECFM=F,BLKSIZE=256, 1\n               EXLST=JFXLIST,SYNAD=RDERR,EODAD=RDEND,DDNAME=XXXXXXXX\n         SPACE 1\n        READ   PECB,SF,,,'S',MF=L\n         SPACE 1\n        CNOP   0,8\n         SPACE 1\nDZ       EQU   DCBDIR-BFILE\nDY       EQU   PECB-BFILE\nWSZ      EQU   (((*-BFILE)+7)/8)*8\n         SPACE 1\nREXLIST  DC    0F'0',XL1'85',AL3(DCBEXIT)\nJFXLIST  DC    0F'0',XL1'87',AL3(JFCBAREA)\nJFCBAREA DS    0F\n         DC    (JFCBLGTH)X'0'\nDSCBAREA DS    0F\n         DC    (DSCBLGTH)X'0'\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDREAD$": {"ttr": 32008, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x04\\x9f\\x00\\x93\\x04\\x9f\\x11(\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-18T00:00:00", "modifydate": "1993-02-18T11:28:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//PDREAD   JOB (........),'INSTALL - PDREAD -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,MBR=PDREAD\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   PDOPEN\n  ALIAS   PDCLOSE\n  NAME    PDREAD(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDREAD@": {"ttr": 32010, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93\\x04\\x9f\\x00\\x93\\x04\\x9f\\x11'\\x00o\\x00o\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-18T00:00:00", "modifydate": "1993-02-18T11:27:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "SYSPAJA"}, "text": "1   18/02/93\n                                                      PDREAD    1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * READ PARTITIONED DIRECTORY ROUTINES * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL PDREAD,(A,B,C),VL\n  ------------------             (A,B)\n                                 (A)\n\n         Where : A - is the address of an array (format XL74) into\n                     which the next sequential directory entry of a\n                     partitioned data-set is moved.\n\n                 B - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSDIR.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                     -1 - directory reaches END-OF-FILE.\n                      0 - READ correctly executed.\n                      1 - file not opened.\n                      2 - calling sequence or argument alignment error.\n                      3 - READ error.\n\n  Assembler macro : $PDREAD A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   18/02/93\n                                                      PDREAD    2/3.\n\n  Calling sequence : CALL PDOPEN,(A,B,C),VL\n  ------------------             (A,B)\n                                 (A)\n\n         Where : A - is the address of a response field (format CL50)\n                     if supplied (optional). The information returned\n                     back to the caller are the data-set name (CL44)\n                     followed by the volume serial number (CL6).\n\n                 B - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSDIR.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - OPEN correctly executed.\n                      1 - DD-card missing.\n                      2 - OPEN error or DD-card conflict.\n                      3 - calling sequence or argument alignment error.\n                      4 - file already opened.\n                      5 - file RDJFCB error.\n                      6 - file OBTAIN error.\n                      7 - not partitioned data-set.\n\n  Assembler macro : $PDOPEN A,B,C\n  -----------------\n\n         Where A, B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   18/02/93\n                                                      PDREAD    3/3.\n\n  Calling sequence : CALL PDCLOSE,(A,B),VL\n  ------------------              (A)\n\n         Where : A - is the address of the DD-name (format CL8) to\n                     close. If this argument contains the CLOSEALL\n                     keyword, or the address of this argument is set\n                     to zero in the parameters list, or the parameters\n                     list pointer (register 1) is zero, all the opened\n                     files are closed.\n\n                 B - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence, argument alignment or\n                          DD-name error.\n\n  Assembler macro : $PDCLOSE A,B\n  -----------------\n\n         Where A and or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  General notice : On any error detection, a message is included in\n  ================ the message class for the job.\n                   If the routine is re-called after IND = 1 or 2,\n                   the program is sended in abend U0001.\n                   If the indicator response is detected 10 times\n                   different from 0, the program is sended in\n                   abend U0002.\n                   This routine is multi-files usable, that means\n                   multi-files opened concurrently (using the DD-name\n                   argument).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSW": {"ttr": 32013, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\tV\\x01!\\x01!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T09:56:00", "lines": 289, "newlines": 289, "modlines": 0, "user": "SYSPAJA"}, "text": "PDSW     TITLE 'PARTITIONED DATA-SET - WHERE FUNCTION.'\nPDSW     START 0\n         SPACE 1\n* PURPOSE :    SCAN A PARTITIONED DATA-SET DIRECTORY TO SEARCH A\n* ---------    MEMBER NAME OR ALL MEMBERS HAVING THE NAME STARTING\n*              BY A GIVEN CHARACTERS STRING.\n*\n* FILE NAMES : DD-NAME 'SYSUT0'   - INPUT DATA-SET (DSORG=PO).\n* ------------ DD-NAME 'SORTPRT'  - OUTPUT LIST.\n*\n* TSO ACCESS : USE %CERCA CLIST TO INVOKE THE WHERE FUNCTION.\n* ------------ CERCA CLIST DESCRIPTION :\n*                   PROC   2 LIBRARY MODULE\n*                   ALLOC  F(SYSUT0) DA(&LIBRARY) SHR\n*                   ALLOC  F(SORTPRT) DA(*)\n*                   PDSW   &MODULE\n*                   FREE   F(SYSUT0 SORTPRT)\n*                   TSO    END\n         SPACE 1\nPDSW    AMODE  24\nPDSW    RMODE  24\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12\n         LR    R8,R1               SAVE PARM. FIELD ADDRESS\n        $TEW$EC NOTTSO=CALLM,NOTCMD=CALLM,MSG=PUTMSG,ERR=SETRC\n        $TEW$PP PARM=PARMLST,REG=R3\n         TM    MODULE+6,X'80'      MODULE SPECIFIED?\n         BZ    NOMOD               NO\n         L     R2,MODULE           GET POINTER TO MODULE NAME\n         LH    R8,MODULE+4         GET LENGTH\n         LTR   R8,R8\n         BNP   NOMOD\n         BCT   R8,MOVE+L'MOVE\nMOVE     MVC   PAR(*-*),0(R2)      <<EXECUTED>>\n         EX    R8,MOVE\n         DROP  R3\n         BAS   R2,NOMOD+L'NOMOD\nNOMOD    XR    R2,R2\n        IKJRLSA #TSANSW\n         LTR   R2,R2\n         BNZ   TPAR\n         XR    R8,R8\n         B     NOPARM\n         SPACE 1\nCALLM    L     R2,0(R8)            GET PARM. FIELD ADDRESS\n         LH    R8,0(R2)            PARM. FIELD LENGTH\n         LTR   R8,R8\n         BNP   NOPARM\n         LA    R2,2(R2)            START OF PARM. FIELD TEXT\n         CH    R8,=Y(L'PAR)\n         BNH   *+L'*+4\n         LH    R8,=Y(L'PAR)\n         BCTR  R8,0\n         EX    R8,MOVE\nTPAR     CLI   PAR,C'*'\n         BE    NOPARM\n         OI    SWITCH,SELEZ\n         SPACE 1\nNOPARM   MVC   ERMODD,UTILIN+(DCBDDNAM-IHADCB)\n        OPEN   (UTILIN,INPUT)\n         TM    UTILIN+(DCBOFLGS-IHADCB),DCBOFOPN\n         BZ    OPNERR\n         OI    SWITCH,UTOP\n         MVC   ERMODD,SORTPRT+(DCBDDNAM-IHADCB)\n        OPEN   (SORTPRT,OUTPUT)\n         TM    SORTPRT+(DCBOFLGS-IHADCB),DCBOFOPN\n         BZ    OPNERR\n         OI    SWITCH,SPOP\n         LA    R7,LINE\n         LA    R5,LINE+72\nGTNX    GET    UTILIN,AREA+8       READ 1 DIRECTORY BLOCK\n         LH    R2,AREA+8           DIRECTORY BLOCK LENGTH\n         LA    R3,AREA+8           START ADDRESS\n         AR    R2,R3               END OF BLOCK ADDRESS\n         LA    R3,2(R3)            START OF NAME ADDRESS\nLOOP     CLC   =XL8'FFFFFFFFFFFFFFFF',0(R3) DIRECTORY BLOCK END?\n         BE    QUIT                YES\n         TM    SWITCH,SELEZ        NO, SELEZ IS ON?\n         BZ    *+L'*+18            NO\n         CLC   0(1,R3),PAR\n         BH    QUIT\n         EX    R8,COMPAR\n         BNE   NULLFO\n         TM    11(R3),X'80'\n         BNO   NOTALIAS\n         LR    R4,R3\n         LA    R4,11(R4)\n         IC    R1,0(R4)\n         N     R1,=F'31'\n         SLL   R1,1\n         AR    R4,R1\n         CLI   0(R4),0\n         BE    MVSALIA\n         CLI   0(R4),1\n         BE    MVSALIA\n         SH    R4,=H'7'\n         B     MVSALIA+L'MVSALIA\nMVSALIA  SH    R4,=H'9'\n         MVC   QUA,0(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BE    QUI1\n         MVC   QUA,1(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BE    QUI1\n         MVC   QUA,2(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BE    QUI1\n         MVC   QUA,3(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BE    QUI1\n         MVC   QUA,4(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BE    QUI1\n         MVC   QUA,5(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BE    QUI1\n         MVC   QUA,6(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BE    QUI1\n         MVC   QUA,7(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BNE   QUI1+L'QUI1\nQUI1     SH    R4,=H'4'\n         MVC   QUA,0(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BE    QUI2\n         MVC   QUA,1(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BE    QUI2\n         MVC   QUA,2(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BE    QUI2\n         MVC   QUA,3(R4)\n         BAS   R10,CER\n         CLI   CAR,C'0'\n         BNE   QUI2+L'QUI2\nQUI2     MVC   0(8,R4),=CL8' '\n         MVC   TRA(8),0(R4)\n         MVI   BLI,C' '\n         MVC   BLI+1(L'BLI-1),BLI\n         MVC   BLI(8),0(R3)\n         LA    R6,BLI\n         CLI   0(R6),C' '\n         BE    *+L'*+8\n         LA    R6,1(R6)\n         B     *-12\n         MVI   0(R6),C'='\n         MVC   1(8,R6),TRA\n         BAS   R10,ROUTINE\n         B     NULLFO\nNOTALIAS NI    11(R3),X'1F'        REMAIN ONLY LENGTH(HW) OF FIELDS\n         CLI   11(R3),X'0B'\n         BE    NOSSI               MVT LINK WITHOUT SSI\n         CLI   11(R3),X'0C'\n         BE    NOSSI               MVS MVS WITHOUT SSI\n         CLI   11(R3),X'0D'\n         BE    SSI                 MVT LINK WITH SSI\n         CLI   11(R3),X'0E'\n         BE    SSI                 MVS LINK WITH SSI\n         CLI   11(R3),X'00'\n         BE    NOSSI               IEBUPDTE WITHOUT SSI\n         CLI   11(R3),X'02'\n         BE    IEBSSI              IEBUPDTE WITH SSI\nNOSSI    MVC   BLI(8),0(R3)        MOVE MEMBER NAME\n         MVI   BLI+8,C' '\n         MVC   BLI+9(L'BLI-9),BLI+8\n         BAS   R10,ROUTINE\n         B     NULLFO\nIEBSSI   UNPK  TRA(9),12(5,R3)\n         B     SSI+L'SSI\nSSI      UNPK  TRA(9),34(5,R3)\n         TR    TRA(8),TBZ-C'0'\n         MVI   BLI,C' '\n         MVC   BLI+1(L'BLI-1),BLI\n         MVC   BLI(8),0(R3)\n         LA    R6,BLI\n         CLI   0(R6),C' '\n         BE    *+L'*+8\n         LA    R6,1(R6)\n         B     *-12\n         MVI   0(R6),C'/'\n         MVC   1(8,R6),TRA\n         BAS   R10,ROUTINE\nNULLFO   LA    R3,11(R3)\n         IC    R1,0(R3)\n         N     R1,=F'31'\n         SLL   R1,1                TWICE\n         LA    R3,1(R3)\n         AR    R3,R1               POINTS TO NEW NAME OF NEXT BLDL\n         CR    R3,R2\n         BL    LOOP\n         B     GTNX\nOPNERR   LA    R1,ERMO\n         B     DIRERR+L'DIRERR\nDIRERR   LA    R1,ERMC\n         BAS   R14,PUTMSG\nSETRC    LA    R2,16               RC = 16 ----------------------------\n         B     CLUT\nQUIT    PUT    SORTPRT,PRTLNE\n         XR    R2,R2               RC = 0 -----------------------------\nCLUT     TM    SWITCH,UTOP\n         BZ    CLSP\n        CLOSE  (UTILIN)\nCLSP     TM    SWITCH,SPOP\n         BZ    LEAVE\n        CLOSE  (SORTPRT)\nLEAVE   $XRET  CC=(R2)\n         SPACE 1\nCOMPAR   CLC   0(*-*,R3),PAR       <<EXECUTED>>\n         SPACE 1\nCER      CLI   QUA,C' '\n         BE    QUI\n         CLI   QUA,C'$'\n         BE    QUI\n         CLI   QUA,C'@'\n         BE    QUI\n         CLI   QUA,C'#'\n         BE    QUI\n         CLI   QUA,C'A'\n         BNL   QUI\n         MVI   CAR,C'0'\n         BR    R10\nQUI      MVI   CAR,C'1'\n         BR    R10\n         SPACE 1\nROUTINE  CR    R7,R5\n         BL    ADVN\n        PUT    SORTPRT,PRTLNE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         LA    R7,LINE\nADVN     MVC   0(L'BLI,R7),BLI\n         LA    R7,L'BLI(R7)\n         BR    R10\n         EJECT\n*------- CONSTANTS AND WORK AREAS.\n         SPACE 1\nAREA     DC    0D'0',264X'0'\n        $TEW$WA\nPAR      DC    CL8' '\n         SPACE 1\nSWITCH   DC    XL1'0'\nUTOP     EQU   X'80'\nSPOP     EQU   X'40'\nSELEZ    EQU   X'01'\n         SPACE 1\nPRTLNE   DC    CL1' '\nLINE     DC    CL78' '\nPRTLG    EQU   *-PRTLNE\nCAR      DC    CL1' '\nQUA      DC    CL1' '\nTBZ      DC    CL16'0123456789ABCDEF'\nTRA      DC    CL16' '\nBLI      DC    CL18' '\n         SPACE 1\nERMO    WTO    ' ->          : OPEN FAILED.',ROUTCDE=11,DESC=7,MF=L\nERMODD   EQU   ERMO+8,8\nERMC    WTO    ' -> SYSUT0   : DIR-EOF ERROR.',ROUTCDE=11,DESC=7,MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n        PRINT  NOGEN\n         SPACE 1\nUTILIN  DCB    DSORG=PS,MACRF=GM,RECFM=FB,LRECL=256,BLKSIZE=256,       X\n               EODAD=DIRERR,DDNAME=SYSUT0\nSORTPRT DCB    DSORG=PS,MACRF=PM,RECFM=FA,LRECL=PRTLG,BLKSIZE=PRTLG,   X\n               DDNAME=SORTPRT\n         SPACE 1\nPARMLST IKJPARM\nMODULE  IKJIDENT 'MODULE-PREFIX',MAXLNTH=8,FIRST=ANY,OTHER=ANY\n        IKJENDP\n         SPACE 1\n        $TEW$DS\n        DCBD   DSORG=PS,DEVD=DA\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSW$": {"ttr": 32262, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942o\\x00\\x942o\\x116\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-22T00:00:00", "modifydate": "1994-11-22T11:36:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "//PDSW     JOB (........),'INSTALL  - PDSW -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=3\n//ASS     EXEC PAJIAS3,MBR=PDSW\n//LNK     EXEC PAJILKC\n//SYSIN     DD *\n  ENTRY   PDSW\n  NAME    PDSW(R)\n/*\n//HLP     EXEC PAJHELP,MBR=PDSWH\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* EXECUTE THE STEP BELOW WITH PROCEDURE :                           *\n//*       \"PAJPROC\" IF YOUR ->.TARGET.TSO.CLISTS DATA-SET             *\n//*                         IS RECFM=FB AND LRECL=80, ELSE            *\n//*       \"PAJPROV\" IF YOUR ->.TARGET.TSO.CLISTS DATA-SET             *\n//*                         IS RECFM=VB AND LRECL=255.                *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//TCL     EXEC PAJPROC,MBR=PDSWP,DSP='->.TARGET.TSO.CLISTS'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSW@": {"ttr": 32264, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12o\\x00\\x88\\x12o\\x12W\\x00&\\x00&\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-05T00:00:00", "modifydate": "1988-05-05T12:57:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SYSPAJA"}, "text": "1   19/12/86\n                                                      PDSW      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        PARTITIONED DATA-SET         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           WHERE FUNCTION            * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    The CERCA command procedure scan a partitioned data-set\n  ---------    directory to search a member name or all members having\n               the name starting by a given characters string.\n\n  Syntax :     %CERCA 'LIBRARY' 'MODULE'\n  --------     Where :\n               'LIBRARY' is the name of the partitioned data-set which\n                         directory must be scanned.\n               'MODULE' is the desired member name or members starting\n                        characters string. To indicate all members use\n                        an asterisk (*).\n\n  Action :     The name 'PDSW' must be defined in the sub-commands\n  --------     names table of mudule COMMCHEK part of the QED\n               Editor System, this will allow the CERCA procedure\n               to run under it.\n\n  JCL to call as program :\n  ------------------------\n\n               //...      JOB ...\n               //WHERE   EXEC PGM=PDSW,PARM=...\n               //SYSUT0    DD DSN=...Partitioned data-set...,DISP=SHR\n               //SORTPRT   DD SYSOUT=*\n\n               The PARM field is used as input to supply the 'MODULE'\n               operand. No PARM field is equivalent to '*'.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSWH": {"ttr": 32266, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=CERCA\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : THE CERCA COMMAND PROCEDURE SCAN A PARTITIONED DATA-SET\n              DIRECTORY TO SEARCH A MEMBER NAME OR ALL MEMBERS HAVING\n              THE NAME STARTING BY A GIVEN CHARACTERS STRING.\n)X SYNTAX :   %CERCA 'LIBRARY' 'MODULE'\n)O OPERANDS :\n))LIBRARY   - IS THE NAME OF THE PARTITIONED DATA-SET WHICH DIRECTORY\n              MUST BE SCANNED.\n))MODULE    - IS THE DESIRED MEMBER NAME OR MEMBERS STARTING CHARACTERS\n              STRING. TO INDICATE ALL MEMBERS USE AN ASTERISK (*).\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSWP": {"ttr": 32268, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=CERCA\n./     NUMBER  NEW1=100,INCR=100\nPROC     2 LIBRARY MODULE\n/**/\n/*    ------------------------------------------------     */\n/*    SEARCH A MEMBER IN A PO DATA-SET (EXISTS OR NOT)     */\n/*    ------------------------------------------------     */\n/**/\nCONTROL  NOMSG\nFREE     F(SYSUT0 SORTPRT)\nCONTROL  MSG\nWRITE    %CERCA &LIBRARY &MODULE\nALLOC    F(SYSUT0) DA(&LIBRARY) SHR\nALLOC    F(SORTPRT) DA(*)\nPDSW     &MODULE\nFREE     F(SYSUT0 SORTPRT)\nTSO END\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PEDIT": {"ttr": 32270, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x17\\x16\\x00\\x89\\x00\\x89\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T17:16:00", "lines": 137, "newlines": 137, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM) NOPROCESS\n/*  MACRO NAME : PEDIT                                              */\n/*    FUNCTION : PRINT THE CURRENT EDIT FILE                        */\n/*      SYNTAX : PEDIT                                              */\n/*               PEDIT HELP OR H                                    */\n/*       DEBUG : PEDIT LIST                                         */\n/*      AUTHOR : MOINIL P.A.                                        */\n  ISPEXEC CONTROL ERRORS RETURN\n  IF &STR(&APARM.) = &STR(HELP) OR +\n    &STR(&APARM.) = &STR(H) THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTPED)\n      SET &PECC = &LASTCC\n      ISPEXEC CONTROL DISPLAY RESTORE\n      EXIT CODE(&PECC)\n      END\n  ELSE IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n  ELSE IF &STR(&APARM.) \u00ac= &Z THEN DO\n    SET ZEDSMSG = &STR(INVALID OPERAND)\n    SET ZEDLMSG = &STR(ONLY HELP OR H IS ACCEPTED AS OPERAND)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  ISREDIT PROCESS RANGE C\n  SET &LCC = &LASTCC\n  ISREDIT (RC) = RANGE_CMD\n  SET &RCC = &LASTCC\n  IF &LCC = 4 THEN DO\n    ISREDIT (FIRST) = LINENUM .ZFRANGE\n    ISREDIT (LAST) = LINENUM .ZLRANGE\n    SET &PSW = ALL\n    END\n  ELSE DO\n    IF &LCC \u00ac=0 OR &RCC \u00ac=0 THEN DO\n      IF &RCC = 4 THEN DO\n        IF &STR(&RC) = &STR(C) THEN DO\n          SET &ZEDSMSG = &STR(RANGE INCOMPLETE)\n          SET &ZEDLMSG = &STR(ENTER A MATCHING \"CC\" TO +\n                              COMPLETE THE BLOCK COMMAND PAIR)\n          END\n        ELSE DO\n          SET &ZEDSMSG = &STR(INVALID RANGE)\n          SET &ZEDLMSG = &STR(YOU MUST SPECIFY A RANGE USING +\n                            \"CN\" OR \"CC\")\n          END\n        END\n      ELSE IF &RCC = 8 THEN DO\n        SET &ZEDSMSG = &STR(NOT ACCEPTABLE)\n        SET &ZEDLMSG = &STR(AN UNACCEPTABLE TARGET RANGE OF LINES +\n                            HAS BEEN SPECIFIED)\n        END\n      ELSE DO\n        SET &ZEDSMSG = &STR(SEVERE ERROR)\n        SET &ZEDLMSG = &STR(SEVERE ERROR OCCURED, RETURN CODES ARE +\n                            &LCC AND &RCC)\n        END\n      ISPEXEC SETMSG MSG(ISRZ001)\n      EXIT CODE(12)\n      END\n    ISREDIT (FIRST) = LINENUM .ZFRANGE\n    ISREDIT (LAST) = LINENUM .ZLRANGE\n    SET &PSW = RANGE\n    END\n  ISPEXEC DISPLAY PANEL(PAJPED)\n  SET &PECC = &LASTCC\n  IF &PECC > 4 THEN DO\n    IF &PECC = 8 THEN DO\n      SET ZEDSMSG = &STR(EXIT REQUEST)\n      SET ZEDLMSG = &STR(EXIT \"PEDIT\" FACILITY HAS BEEN REQUESTED)\n      END\n    ELSE DO\n      SET ZEDSMSG = &STR(ERROR RC=&PECC)\n      SET ZEDLMSG = &STR(EXIT DUE TO DISPLAY ERROR ENCOUNTERED)\n      END\n    ISPEXEC SETMSG MSG(ISRZ000)\n    IF &PSW = RANGE THEN ISREDIT RESET COMMAND\n    EXIT CODE(8)\n    END\n  SET &XSW = &PEDCC\n  SET &XCL = &PEDCL\n  SET &XCP = &PEDCP\n  SET &XHD = &PEDHD\n  IF &PEDDT = THEN SET &XDT = LOCAL\n  ELSE SET &XDT = &PEDDT\n  CONTROL NOMSG\n  FREE F(PEDOUT)\n  ERROR DO\n    ERROR OFF\n    SET ZEDSMSG = &STR(ALLOC ERROR)\n    SET ZEDLMSG = &STR(== UNABLE TO ALLOCATE OUTPUT PRINT FILE ==)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    CONTROL MSG\n    EXIT CODE(8)\n    END\n  ALLOC F(PEDOUT) SYSOUT(&XCL) COPIES(&XCP) DEST(&XDT) &XHD RECFM(F A)\n  ERROR OFF\n  ERROR DO\n    ERROR OFF\n    FREE F(PEDOUT)\n    SET ZEDSMSG = &STR(OPEN ERROR)\n    SET ZEDLMSG = &STR(== UNABLE TO OPEN OUTPUT PRINT FILE ==)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    CONTROL MSG\n    EXIT CODE(8)\n    END\n  OPENFILE PEDOUT OUTPUT\n  ERROR OFF\n  ERROR DO\n    ERROR OFF\n    CONTROL CAPS\n    CLOSFILE PEDOUT\n    FREE F(PEDOUT)\n    SET ZEDSMSG = &STR(WRITE ERROR)\n    SET ZEDLMSG = &STR(== UNABLE TO COMPLETE OUTPUT PRINT FILE ==)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    CONTROL MSG\n    EXIT CODE(8)\n    END\n  SET &TL = &EVAL(&LAST-&FIRST+1)\n  SET I = 0\n  CONTROL ASIS\n  DO WHILE &I < &TL\n    ISREDIT (INDATA) = LINE &EVAL(&FIRST+&I)\n    IF &XSW = YES THEN SET &PEDOUT = &NRSTR(&INDATA)\n    ELSE SET &PEDOUT = &STR( &NRSTR(&INDATA))\n    PUTFILE PEDOUT\n    SET &I = &I + 1\n    END\n  ERROR OFF\n  CONTROL CAPS\n  CLOSFILE PEDOUT\n  FREE F(PEDOUT)\n  SET ZEDSMSG = &STR(&PSW PRINTED)\n  SET ZEDLMSG = &STR(PRINT DONE FROM LINE &FIRST UP TO LINE &LAST)\n  ISPEXEC SETMSG MSG(ISRZ000)\n  CONTROL MSG\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PEDIT@": {"ttr": 32273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"o\\x00\\x91\"o\\x10\\x07\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-14T00:00:00", "modifydate": "1991-08-14T10:07:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/05/90\n                                                      PEDIT     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     PEDIT ISPF/PDF EDIT command     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro invoke the print of the data you are\n  ----------   editing (the current edit file).\n\n  Command syntax : PEDIT\n  ---------------- PEDIT HELP or H\n\n  Use :        Type PEDIT on the COMMAND line, eventually mark a range\n  -----        of lines with the \"C\" range command on the line numbers,\n               and press ENTER. Immediately, you will be prompted to\n               supply the following output print options :\n               SYSOUT Class = the class in which output is to be queued\n                              for print. Default is A.\n               Copies = the number of copies to be printed.\n                              Default is 1.\n               Output status - HOLD/NOHOLD to place or not the output\n                              on a Hold Queue upon deallocation.\n                              Default is NOHOLD.\n               RMT destination - Remote Station to which the output\n                              (sysout) is to be routed (i.e. R41).\n                              Default is LOCAL.\n               Then all or only the range of lines you have selected\n               from the current editing file are printed.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLREAD": {"ttr": 32275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x08/\\x00\\x93\\x08/\\x12\\x16\\x02\\x10\\x02\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-23T00:00:00", "modifydate": "1993-03-23T12:16:00", "lines": 528, "newlines": 528, "modlines": 0, "user": "SYSPAJA"}, "text": "PLR      TITLE 'READ PARTITIONED LOAD-MODULES SUBROUTINE.'\nPLREAD   START 0\n         SPACE 2\n* CALLING SEQUENCE : CALL PLREAD,(A,B,C),VL\n* ------------------             (A,B)\n*                                (A)\n*\n*        WHERE : A - IS THE ADDRESS OF 2 WORDS (FORMAT FULLWORD - F\n*                    BOUNDARY) INTO WHICH THE ADDRESS AND THE LENGTH\n*                    OF THE NEXT SEQUENTIAL PHYSICAL RECORD OF A\n*                    PARTITIONED DATA-SET LOAD-MODULE (POINTED TO BY\n*                    PLPOINT) ARE PASSED (STORED). THIS ARGUMENT IS\n*                    MANDATORY BECAUSE INFORMATION IS RETURNED TO\n*                    THE CALLER.\n*\n*                B - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSLOAD '.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                    -1 - LOAD-MODULE REACHES END-OF-FILE.\n*                     0 - READ CORRECTLY EXECUTED.\n*                     1 - FILE NOT OPENED.\n*                     2 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     3 - READ ERROR.\n*\n* CALLING SEQUENCE : CALL PLPOINT,(A,B,C),VL\n* ------------------              (A,B)\n*                                 (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE LOAD-MODULE TTR (FORMAT XL3)\n*                    TO POINT AND SET READY FOR READ.\n*\n*                B - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSLOAD '.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - LOAD-MODULE POINTED.\n*                     1 - FILE NOT OPENED.\n*                     2 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     3 - LOAD-MODULE TTR POINT ERROR.\n         EJECT\n* CALLING SEQUENCE : CALL PLOPEN,(A,B),VL\n* ------------------             (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, OR THE PARAMETERS\n*                    LIST POINTER (REGISTER 1) IS ZERO, THE DEFAULT\n*                    DD-NAME USED IS 'SYSLOAD '.\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - OPEN CORRECTLY EXECUTED.\n*                     1 - DD-CARD MISSING.\n*                     2 - OPEN ERROR, INVALID RECORD FORMAT OR RECORD\n*                         BLOCK SIZE (0 OR NEGATIVE).\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - FILE ALREADY OPENED.\n*\n* CALLING SEQUENCE : CALL PLCLOSE,(A,B),VL\n* ------------------              (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) TO\n*                    CLOSE. IF THIS ARGUMENT CONTAINS THE 'CLOSEALL'\n*                    KEYWORD, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, OR THE PARAMETERS\n*                    LIST POINTER (REGISTER 1) IS ZERO, ALL THE OPENED\n*                    FILES ARE CLOSED.\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE, ARGUMENT ALIGNMENT OR\n*                         DD-NAME ERROR.\n         EJECT\n* GENERAL NOTICE : ON ANY ERROR DETECTION, A MESSAGE IS INCLUDED IN\n* ---------------- THE MESSAGE CLASS FOR THE JOB.\n*                  IF THE ROUTINE IS RE-CALLED AFTER IND = 1 OR 2,\n*                  THE PROGRAM IS SENDED IN ABEND U0001.\n*                  IF THE INDICATOR RESPONSE IS DETECTED 10 TIMES\n*                  DIFFERENT FROM 0, THE PROGRAM IS SENDED IN\n*                  ABEND U0002.\n*                  MVS/XA : MUST BE AMODE AND RMODE 24.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\n         EJECT\n        PRINT  NOGEN\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DSORG=PO,DEVD=DA\n        PRINT  GEN\n         SPACE 1\n*        FILE BLOCK WORK AREA DESCRIPTION.\n         SPACE 1\nFBWAD    DSECT\nFCHAIN   DC    F'0'                CHAIN WORD.\nFDDNM    DC    CL8' '              DD-NAME.\nFERCNT   DC    H'10'               ERROR COUNT.\nFFLAGS   DC    XL1'0'              FLAGS BYTE.\nFAB      EQU   X'01'                    ABEND.\nFOE      EQU   X'02'                    OPEN ERROR.\nFRE      EQU   X'04'                    READ ERROR.\nFFP      EQU   X'08'                    LOAD-MODULE POINTED.\n         DC    XL1'0'              UNUSED.\nFMBLK    DC    F'0'                BLOCK SIZE LENGTH.\nFIOAR    DC    F'0'                ADDRESS OF AREA TO HOLD ONE BLOCK.\n         SPACE 1\nPLREAD   CSECT                     RESTORE MAIN CSECT.\n         EJECT\n        $XENT  BASE=R12\n         SPACE 1\n         LA    R6,TABD             SET DEFAULTS.\n         LA    R7,DDDEF\n         XR    R9,R9\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    LR1\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         LTR   R8,R8\n         BZ    *+L'*+2\n         LR    R7,R8\n         TM    4(R1),X'80'\n         BO    LR1\n         TM    8(R1),X'80'\n         BZ    ERR2\n         TM    11(R1),X'03'\n         BNZ   ERR2\n         L     R9,8(R1)\n         LA    R9,0(R9)\nLR1      L     R8,0(R1)\n         LA    R8,0(R8)\n         SPACE 1\n         LA    R4,CHAIN\n         USING FBWAD,R4\nLR2      L     R4,FCHAIN           LOOK IF OPENED.\n         LTR   R4,R4\n         BZ    ERR1\n         CLC   FDDNM(L'FDDNM),0(R7)\n         BNE   LR2\n         TM    FFLAGS,FAB          TEST ABEND SWITCH.\n         BO    ABND1\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    ERR1\n         NI    FFLAGS,255-FRE      RESET READ ERROR SWITCH.\n         TM    FFLAGS,FFP          WAS LOAD-MODULE POINTED?\n         BZ    ERR2                NO.\n         L     R3,FIOAR            AREA ADDRESS.\n         LA    R1,DY(R4)           DECB ADDRESS.\n        READ   (1),SF,(R2),(R3),'S',MF=E\n         LA    R1,DY(R4)           DECB ADDRESS.\n        CHECK  (1)\n         TM    FFLAGS,FRE          TEST READ ERROR SWITCH.\n         BO    ERR3\n         SPACE 1\n         L     R0,FMBLK            COMPUTE REAL BLOCK LENGTH.\n         L     R1,DY+16(R4)        (IOB ADDRESS)\n         SH    R0,14(R1)\n         ST    R3,0(R8)            PASS BACK ADDRESS AND LENGTH.\n         ST    R0,4(R8)\n         XR    R10,R10\n         B     EXIT4\n         DROP  R2\n         SPACE 1\nRDERR    OI    FFLAGS,FRE          SET READ ERROR SWITCH.\n         BR    R14\n         SPACE 1\nRDEND    NI    FFLAGS,255-FFP      RESET INDICATORS.\n         XR    R10,R10\n         BCTR  R10,0\n         B     EXIT4\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nMAXERR   EQU   ((*-ERR1)/2)+1\n         B     EXIT\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY PLPOINT\n         SPACE 1\nPLPOINT $XENT  BASE=R12,DT=NO\n         SPACE 1\n         LA    R6,TABP             SET DEFAULTS.\n         LA    R7,DDDEF\n         XR    R9,R9\n         LA    R10,MAXERP\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    PT1\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         LTR   R8,R8\n         BZ    *+L'*+2\n         LR    R7,R8\n         TM    4(R1),X'80'\n         BO    PT1\n         TM    8(R1),X'80'\n         BZ    ERP2\n         TM    11(R1),X'03'\n         BNZ   ERP2\n         L     R9,8(R1)\n         LA    R9,0(R9)\nPT1      L     R8,0(R1)\n         LA    R8,0(R8)\n         SPACE 1\n         LA    R4,CHAIN\n         USING FBWAD,R4\nPT2      L     R4,FCHAIN           LOOK IF OPENED.\n         LTR   R4,R4\n         BZ    ERP1\n         CLC   FDDNM(L'FDDNM),0(R7)\n         BNE   PT2\n         TM    FFLAGS,FAB          TEST ABEND SWITCH.\n         BO    ABND1\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    ERP1\n         NI    FFLAGS,255-FRE-FFP       RESET SWITCHES.\n        POINT  (R2),(R8)\n         LTR   R15,R15             TEST COMPLETION CODE.\n         BZ    PT3                 O.K.\n         UNPK  DIAG10+23(7),0(R8)\n         TR    DIAG10+23(6),TRHEX-X'F0'\n         MVI   DIAG10+29,C' '\n         B     ERP3\nPT3      OI    FFLAGS,FFP          INDICATE LOAD-MODULE POINTED.\n         XR    R10,R10\n         B     EXIT4\n         DROP  R2\n         SPACE 1\nERP1     BCTR  R10,0\nERP2     BCTR  R10,0\nERP3     BCTR  R10,0\nMAXERP   EQU   ((*-ERP1)/2)+1\n         B     EXIT\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY PLOPEN\n         SPACE 1\nPLOPEN  $XENT  BASE=R12,DT=NO\n         SPACE 1\n         LA    R6,TABO             SET DEFAULTS.\n         LA    R7,DDDEF\n         XR    R9,R9\n         LA    R10,MAXERO\n         LTR   R1,R1               CONTROL ARGUMENTS.\n         BZ    OP1\n         L     R7,0(R1)\n         LA    R7,0(R7)\n         TM    0(R1),X'80'\n         BO    OP1\n         TM    4(R1),X'80'\n         BZ    ERO3\n         TM    7(R1),X'03'\n         BNZ   ERO3\n         L     R9,4(R1)\n         LA    R9,0(R9)\n         SPACE 1\nOP1      LA    R3,CHAIN            LOOK IF ALREADY DEFINED.\n         USING FBWAD,R4\nOP2      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    OP3\n         CLC   FDDNM(L'FDDNM),0(R7)\n         BE    ERO4\n         LR    R3,R4\n         B     OP2\nOP3     GETMAIN R,LV=WSZ\n         LR    R4,R1\n         ST    R4,0(R3)            NEW FILE.\n         MVC   FCHAIN(WSZ),BFILE   SET SKELETON.\n         MVC   FDDNM(L'FDDNM),0(R7)\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         MVC   DCBDDNAM(L'DCBDDNAM),FDDNM\n         OC    ATIOT(L'ATIOT),ATIOT     TEST FIRST TIME.\n         BNZ   OP4\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\nOP4      L     R3,ATIOT            SEARCH DD AND OPEN IT.\n         USING TIODSECT,R3\nOP5      CLC   TIOELNGH(4),ZEROS\n         BE    ERO1\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM\n         BE    OP6\n         XR    R1,R1\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     OP5\n         DROP  R3\nOP6     OPEN   ((R2),(INPUT))\n         TM    FFLAGS,FOE          TEST OPEN ERROR SWITCH.\n         BO    ERO2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPEN SUCCESSFULL.\n         BZ    ERO2\n         LH    R1,DCBBLKSI\n         ST    R1,FMBLK\n         DROP  R2\n         LA    R0,7(R1)\n         SRL   R0,3\n         SLL   R0,3\n        GETMAIN R,LV=(0)\n         ST    R1,FIOAR            SAVE ADDRESS OF I/O AREA.\n         XR    R10,R10\n         B     EXIT4\n         SPACE 1\nERO1     BCTR  R10,0\nERO2     BCTR  R10,0\n         OI    FFLAGS,FAB          SET ABEND SWITCH TO PREVENT RE-CALL.\nERO3     BCTR  R10,0\nERO4     BCTR  R10,0\nMAXERO   EQU   (((*-ERO1)-4)/2)+1\n         B     EXIT\n         SPACE 2\n         USING IHADCB,R1\nDCBEXIT  TM    DCBRECFM,DCBRECU    TEST IF RECORD FORMAT UNDEFINED\n         BNO   EX2\n         LH    R2,DCBBLKSI         CONTROL THE BLOCK SIZE.\n         LTR   R2,R2\n         BPR   R14\n         DROP  R1\nEX2      OI    FFLAGS,FOE          SET OPEN ERROR SWITCH.\n         BR    R14\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY PLCLOSE\n         SPACE 1\nPLCLOSE $XENT  BASE=R12,DT=NO\n         SPACE 1\n         LA    R6,TABC             CONTROL ARGUMENTS.\n         XR    R9,R9\n         LA    R10,1\n         LTR   R8,R1\n         BZ    PC2\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         TM    0(R1),X'80'\n         BO    PC1\n         TM    4(R1),X'80'\n         BZ    EXIT\n         TM    7(R1),X'03'\n         BNZ   EXIT\n         L     R9,4(R1)\n         LA    R9,0(R9)\nPC1      LTR   R8,R8\n         BZ    PC2\n         CLC   0(8,R8),KEYALL\n         BNE   PC2\n         XR    R8,R8\n         SPACE 1\nPC2      LA    R3,CHAIN\n         USING FBWAD,R4\nPC3      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    PC7\n         LTR   R8,R8\n         BZ    PC4\n         CLC   0(L'FDDNM,R8),FDDNM\n         BE    PC4\n         LR    R3,R4\n         B     PC3\nPC4      LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    PC5\n        CLOSE  ((R2))\n         DROP  R2\nPC5      L     R1,FMBLK\n         LA    R0,7(R1)\n         SRL   R0,3\n         SLL   R0,3\n         L     R1,FIOAR\n         LTR   R1,R1\n         BZ    PC6\n        FREEMAIN R,A=(1),LV=(0)\nPC6      MVC   0(L'FCHAIN,R3),FCHAIN    DEQUEUE FILE.\n         LR    R1,R4\n        FREEMAIN R,A=(1),LV=WSZ\n         LTR   R8,R8\n         BNZ   PC8\n         B     PC3\nPC7      LTR   R8,R8\n         BNZ   EXIT\nPC8      XR    R10,R10\n         B     EXIT4\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\nEXIT     BASR  R12,0\n         USING *,R12\n         LR    R2,R10\n         BCTR  R2,0\n         SLL   R2,2\n         L     R3,0(R2,R6)\n         NI    SWEX+1,OFF          SET SWITCH OFF.\n         CLI   12(R3),C' '\n         BNE   *+L'*+10\n         OI    SWEX+1,ON           SET SWITCH ON.\n         MVC   12(8,R3),0(R7)\n         LR    R1,R3\n        WTO    MF=(E,(1))\nSWEX     B     EXIT1\n         LA    R3,CNTR             CONTROL MAX. ERROR.\n         B     EXIT2\nEXIT1    MVC   12(8,R3),BLKS\n         LTR   R4,R4\n         BZ    SWEX+L'SWEX\n         USING FBWAD,R4\n         LA    R3,FERCNT\n         DROP  R4\nEXIT2    LH    R2,0(R3)\n         BCT   R2,EXIT3\n         LA    R1,2                SET ABEND CODE.\n         B     ABND\nEXIT3    STH   R2,0(R3)\n         DROP  R12\n         SPACE 1\nEXIT4    BASR  R12,0\n         USING *,R12\n         LTR   R9,R9\n         BZ    EXIT5\n         ST    R10,0(R9)           STORE IND.\nEXIT5   $XRET  CC=(R10)\n         DROP  R12\n         SPACE 1\nABND1    LA    R1,1                SET ABEND CODE.\n         SPACE 1\nABND     BASR  R12,0\n         USING *,R12\n         LR    R15,R10             SET C.C. IN REG. 15.\n        ABEND  (1),DUMP\n         SPACE 1\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nCHAIN    DC    A(*-*)\nATIOT    DC    A(*-*)\nTABD     DC    A(DIAG5,DIAG6,DIAG7)\nTABP     DC    A(DIAG5,DIAG9,DIAG10)\nTABO     DC    A(DIAG1,DIAG2,DIAG3,DIAG4)\nTABC     DC    A(DIAG8)\nZEROS    DC    F'0'\nDIAG1   WTO    'ERR=1 -          DD-CARD MISSING.',                    1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG2   WTO    'ERR=2 -          OPEN ERROR OR DD-CARD CONFLICT.',     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG3   WTO    'ERR=3 - PLOPEN CALLING SEQUENCE OR ARGUMENT ALIGNMENT E1\n               RROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG4   WTO    'ERR=4 -          ALREADY OPENED.',                     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG5   WTO    'ERR=1 -          NOT OPENED.',                         1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG6   WTO    'ERR=2 - PLREAD CALLING SEQUENCE OR ARGUMENT ALIGNMENT E1\n               RROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG7   WTO    'ERR=3 -          I/O ERROR.',                          1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG8   WTO    'ERR=1 - PLCLOSE CALLING SEQUENCE, ARGUMENT ALIGNMENT OR1\n                DD-NAME ERROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG9   WTO    'ERR=2 - PLPOINT CALLING SEQUENCE OR ARGUMENT ALIGNMENT 1\n               ERROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG10  WTO    'ERR=3 -          : ...... TTR POINT FAILED.',          1\n               ROUTCDE=11,DESC=7,MF=L\nCNTR     DC    H'10'\nDDDEF    DC    CL8'SYSLOAD '\nKEYALL   DC    CL8'CLOSEALL'\nBLKS     DC    CL8' '\nTRHEX    DC    CL16'0123456789ABCDEF'\n         EJECT\n        CNOP   0,8\n         SPACE 1\nBFILE    DC    F'0'                CHAIN WORD.\n         DC    CL8' '              DD-NAME.\n         DC    H'10'               ERROR COUNT.\n         DC    XL1'0'              FLAGS BYTE.\n         DC    XL1'0'              UNUSED.\n         DC    F'0'                BLOCK SIZE LENGTH.\n         DC    F'0'                ADDRESS OF AREA TO HOLD ONE BLOCK.\n         SPACE 1\nDCBLOAD DCB    DSORG=PO,DEVD=DA,MACRF=(R),                             1\n               EXLST=REXLIST,SYNAD=RDERR,EODAD=RDEND,DDNAME=XXXXXXXX\n         SPACE 1\n        READ   PECB,SF,,,'S',MF=L\n         SPACE 1\n        CNOP   0,8\n         SPACE 1\nDZ       EQU   DCBLOAD-BFILE\nDY       EQU   PECB-BFILE\nWSZ      EQU   (((*-BFILE)+7)/8)*8\n         SPACE 1\nREXLIST  DC    0F'0',XL1'85',AL3(DCBEXIT)\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PLREAD$": {"ttr": 32521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x08_\\x00\\x93\\x08_\\x11\\x19\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-26T00:00:00", "modifydate": "1993-03-26T11:19:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "//PLREAD   JOB (........),'INSTALL - PLREAD -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,MBR=PLREAD\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   PLOPEN\n  ALIAS   PLCLOSE\n  ALIAS   PLPOINT\n  NAME    PLREAD(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PLREAD@": {"ttr": 32523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x08_\\x00\\x93\\x08_\\x11!\\x00\\x89\\x00\\x89\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-26T00:00:00", "modifydate": "1993-03-26T11:21:00", "lines": 137, "newlines": 137, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/03/93\n                                                      PLREAD    1/4.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    READ PARTITIONED LOAD-MODULES    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL PLREAD,(A,B,C),VL\n  ------------------             (A,B)\n                                 (A)\n\n         Where : A - is the address of 2 words (format FULLWORD - F\n                     boundary) into which the address and the length\n                     of the next sequential physical record of a\n                     partitioned data-set load-module (pointed to by\n                     PLPOINT) are passed (stored). This argument is\n                     mandatory because information is returned to\n                     the caller.\n\n                 B - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSLOAD.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                     -1 - Load-module reaches END-OF-FILE.\n                      0 - READ correctly executed.\n                      1 - file not opened.\n                      2 - calling sequence or argument alignment error.\n                      3 - READ error.\n\n  Assembler macro : $PLREAD A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/03/93\n                                                      PLREAD    2/4.\n\n  Calling sequence : CALL PLPOINT,(A,B,C),VL\n  ------------------              (A,B)\n                                  (A)\n\n         Where : A - is the address of the Load-module TTR (format XL3)\n                     to POINT and set ready for read.\n\n                 B - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSLOAD.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - Load-module POINTed.\n                      1 - file not opened.\n                      2 - calling sequence or argument alignment error.\n                      3 - Load-module TTR POINT error.\n\n  Assembler macro : $PLPOINT A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/03/93\n                                                      PLREAD    3/4.\n\n  Calling sequence : CALL PLOPEN,(A,B),VL\n  ------------------             (A)\n\n         Where : A - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, or the parameters\n                     list pointer (register 1) is zero, the default\n                     DD-name used is SYSLOAD.\n\n                 B - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - OPEN correctly executed.\n                      1 - DD-card missing.\n                      2 - OPEN error or DD-card conflict.\n                      3 - calling sequence or argument alignment error.\n                      4 - file already opened.\n\n  Assembler macro : $PLOPEN A,B\n  -----------------\n\n         Where A and or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/03/93\n                                                      PLREAD    4/4.\n\n  Calling sequence : CALL PLCLOSE,(A,B),VL\n  ------------------              (A)\n\n         Where : A - is the address of the DD-name (format CL8) to\n                     close. If this argument contains the CLOSEALL\n                     keyword, or the address of this argument is set\n                     to zero in the parameters list, or the parameters\n                     list pointer (register 1) is zero, all the opened\n                     files are closed.\n\n                 B - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence, argument alignment or\n                          DD-name error.\n\n  Assembler macro : $PLCLOSE A,B\n  -----------------\n\n         Where A and or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  General notice : On any error detection, a message is included in\n  ================ the message class for the job.\n                   If the routine is re-called after IND = 1 or 2,\n                   the program is sended in abend U0001.\n                   If the indicator response is detected 10 times\n                   different from 0, the program is sended in\n                   abend U0002.\n                   This routine is multi-files usable, that means\n                   multi-files opened concurrently (using the DD-name\n                   argument).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PLUG": {"ttr": 32769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\tW\\x00\\x84\\x00\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T09:57:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (PLGS TCOL) NOPROCESS\n/*  MACRO NAME : PLUG                                               */\n/* DESCRIPTION : EDIT MACRO TO PLUG DATA INTO A RANGE OF LINES      */\n/*      AUTHOR : J. KALINICH, X4521                                 */\n/*  CBT ORIGIN : EXTRACTED FROM CBT TAPE 94 APR, FILE 078           */\n/*  ADAPTED BY : MOINIL P.A.                                        */\n/*    MODIFIED : TO USE ONLY \"ON\" OR \"OO\" AS TARGET RANGE OF LINES  */\n  IF (&NRSTR(&PLGS) EQ &STR(HELP)) OR +\n    (&NRSTR(&PLGS) EQ &STR(H)) THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJPLUG)\n    SET &PLGCC = &LASTCC\n    ISPEXEC CONTROL DISPLAY RESTORE\n    EXIT CODE(&PLGCC)\n    END\n  ELSE IF &NRSTR(&PLGS) EQ &Z THEN DO\n    SET ZEDSMSG = &STR(PLUG MISSING)\n    SET ZEDLMSG = &STR(YOU MUST SPECIFY A PLUG STRING)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(20)\n    END\n/*               CHECK FOR PLUG STRING DELIMITERS                   */\n  CONTROL ASIS\n  SET PLGL = &LENGTH(&NRSTR(&PLGS))\n  IF (&SUBSTR(1:1,&PLGS) EQ &STR(') AND +\n    &SUBSTR(&PLGL:&PLGL,&PLGS) EQ &STR(')) OR +\n    (&SUBSTR(1:1,&PLGS) EQ &STR(\") AND +\n    &SUBSTR(&PLGL:&PLGL,&PLGS) EQ &STR(\")) THEN DO\n    SET PLGS = &SUBSTR(2:&PLGL-1,&PLGS)\n    SET PLGL = &PLGL - 2\n    END\n  IF &PLGL EQ 0 THEN DO\n    SET ZEDSMSG = &STR(PLUG NULL)\n    SET ZEDLMSG = &STR(A NULL PLUG STRING HAS NO SENSE)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(20)\n    END\n/*               IF NO COLUMN SPECIFIED, THEN USE CURSOR POSITION   */\n  ISREDIT (LEFTM,RIGHTM) = BOUNDS\n  IF &STR(&TCOL) = &Z THEN DO\n    ISREDIT (CROW,CCOL) = CURSOR\n    IF (&CCOL LT &LEFTM) OR (&CCOL GT &RIGHTM) THEN DO\n      SET ZEDSMSG = &STR(START COLUMN)\n      SET ZEDLMSG = &STR(USE A NUMBER OR SET CORRECT CURSOR LOCATION +\n                         FOR START OF PLUG : BOUNDS)\n      ISPEXEC SETMSG MSG(ISRZ001)\n      EXIT CODE(20)\n      END\n    ELSE SET TCOL = &CCOL\n    END\n  ELSE IF &DATATYPE(&TCOL) NE &STR(NUM) THEN DO\n    SET ZEDSMSG = &STR(INVALID START)\n    SET ZEDLMSG = &STR(START COLUMN NUMBER FOR PLUG IS NOT NUMERIC)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(20)\n    END\n  ELSE IF (&TCOL LT &LEFTM) OR (&TCOL GT &RIGHTM) THEN DO\n    SET ZEDSMSG = &STR(START COLUMN)\n    SET ZEDLMSG = &STR(START COLUMN NUMBER FOR PLUG IS NOT IN DATA +\n                       LINES : BOUNDS)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(20)\n    END\n/*               CHECK PLUG STRING TARGET WIDTH VALIDITY            */\n  SET LCOL = &TCOL + &PLGL - 1\n  IF &LCOL GT &RIGHTM THEN DO\n    SET ZEDSMSG = &STR(PLUG LENGTH)\n    SET ZEDLMSG = &STR(PLUG STRING TOO LONG OR WRONG START COLUMN +\n                       NUMBER : BOUNDS)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(20)\n    END\n/*               PROCESS LINE COMMANDS, CHECK IF \"O\" WAS SPECIFIED  */\n  ISPEXEC CONTROL ERRORS RETURN\n  ISREDIT PROCESS RANGE O\n  SET LCC = &LASTCC\n  ISREDIT (RC) = RANGE_CMD\n  SET RCC = &LASTCC\n  IF &LCC \u00ac=0 OR &RCC \u00ac=0 THEN DO\n    IF &RCC = 4 THEN DO\n      IF &STR(&RC) \u00ac= &STR(O) THEN DO\n        IF &LCC = 4 THEN SET &ZEDSMSG = &STR(NO RANGE)\n        ELSE SET &ZEDSMSG = &STR(INVALID RANGE)\n        SET &ZEDLMSG = &STR(YOU MUST SPECIFY A TARGET RANGE OF +\n                            LINES, USING \"ON\" OR \"OO\")\n        END\n      ELSE DO\n        SET &ZEDSMSG = &STR(RANGE INCOMPLETE)\n        SET &ZEDLMSG = &STR(ENTER A MATCHING \"OO\" TO COMPLETE +\n                            THE BLOCK COMMAND PAIR)\n        END\n      END\n    ELSE IF &RCC = 8 THEN DO\n      SET &ZEDSMSG = &STR(NOT ACCEPTABLE)\n      SET &ZEDLMSG = &STR(AN UNACCEPTABLE TARGET RANGE OF LINES +\n                          HAS BEEN SPECIFIED)\n      END\n    ELSE DO\n      SET &ZEDSMSG = &STR(SEVERE ERROR)\n      SET &ZEDLMSG = &STR(SEVERE ERROR OCCURED, RETURN CODES ARE +\n                          &LCC AND &RCC)\n      END\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n    END\n  ISREDIT (FR) = LINENUM .ZFRANGE\n  ISREDIT (LR) = LINENUM .ZLRANGE\n  SET I = 1\n  SET ANYCHAR = &Z\n  DO WHILE &I LE &PLGL\n    SET ANYCHAR = &STR(&ANYCHAR.=)\n    SET I = &I + 1\n    END\n  ISREDIT CURSOR = .ZFRANGE 1    /* SET CURSOR ON 1ST LINE IN RANGE */\n  SET &I = &FR\n  DO WHILE &I LE &LR\n    ISREDIT CHANGE P'&STR(&ANYCHAR)' '&NRSTR(&PLGS)' &TCOL\n    SET CHGCC = &LASTCC\n    IF &CHGCC NE 0 THEN DO\n      SET ZEDSMSG = &STR(PLUG FAILED)\n      SET ZEDLMSG = &STR(CHANGE RC=&CHGCC, TARGET LINES &FR TO +\n                         &LR AT COLUMN &TCOL)\n      ISPEXEC SETMSG MSG(ISRZ001)\n      EXIT CODE(12)\n      END\n    SET I = &I + 1\n    END\n  SET ZEDSMSG = &STR(PLUG DONE)\n  SET ZEDLMSG = &STR(STRING &PLGS PLUGGED IN LINES &FR TO &LR AT +\n                     COLUMN &TCOL)\n  ISPEXEC SETMSG MSG(ISRZ001)\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLUG@": {"ttr": 32772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\x10@\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T10:40:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/08/94\n                                                      PLUG      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      PLUG ISPF/PDF EDIT command     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to plug data into a range of\n  ----------   lines starting at a given column.\n\n  Command syntax : On the COMMAND line type in\n  ----------------      PLUG STRING START-COL\n                   and then mark the lines with the On or OO range\n                   command, or : PLUG HELP or H to view this tutorial.\n                   If START-COL is not specified, the cursor position\n                   will be used.\n\n  Use :        COMMAND ===> PLUG XDCCMD    (cursor pos.) ---|\n  -----        Before ************** TOP OF DATA ********** | *********\n               OO 001 ... data line ...                    (UXM204A)\n               000002 ... data line ...                    (UXM204B)\n               OO 003 ... data line ...                    (UXM204C)\n               After *************** TOP OF DATA **********************\n               OO 001 ... data line ...                    (XDCCMDA)\n               000002 ... data line ...                    (XDCCMDB)\n               OO 003 ... data line ...                    (XDCCMDC)\n                                         (at end, cursor pos.) ---|\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PSWR": {"ttr": 32774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\tV\\x00\\xf0\\x00\\xf0\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T09:56:00", "lines": 240, "newlines": 240, "modlines": 0, "user": "SYSPAJA"}, "text": "PSWR     TITLE 'TSO RACF PASSWORD READ COMMAND.'\nPSWREAD  START 0\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* * * * * * * * * * *                             * * * * * * * * * * *\n* * * * * * * * * * *     RACF PASSWORD READ.     * * * * * * * * * * *\n* * * * * * * * * * *                             * * * * * * * * * * *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 1\n* PURPOSE :    THIS COMMAND SHOWS BACK THE RACF PASSWORD OF A GIVEN\n* ---------    TSO USER-ID.\n*\n* COMMAND :    SYNTAX : PSWR USERID\n* ---------    DEFAULT : USERID - THE CURRENT SESSION.\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE (TP 361)\n*              J.R.C. - ISPRA ESTABLISHMENT.\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nLV10     EQU   10        WHEN LESS : ONLY REGISTRATION OWNER LEVEL.\nLV6      EQU   6         WHEN LESS : ONLY GROUP LEVEL.\nLV0      EQU   0         REJECT LEVEL.\n         SPACE 1\nPSWR    $MDL@IX\n         SPACE 1\n* LOGIC :      CAL = CALLER AUTHORITY LEVEL\n* -------      CG  = CALLER GROUP NAME\n*              RAL = REQ. AUTHORITY LEVEL\n*              RG  = REQ. GROUP NAME\n*              RRO = RACF PROFILE REQ. OWNER\n*        1. IF CAL EQ 0 ... REJECT\n*        2. IF CAL LT 6 AND CG NE RG ... REJECT\n*        3. IF CAL LT RAL ... REJECT\n*        4. IF CAL LT 10 AND RRO NE 'SYSDMS' OR 'SYSRACF' ... REJECT\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R11,R13             SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R11\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n         L     R2,#TSPSCB\n         USING PSCB,R2             SET PSCB ADDRESSABILITY.\n         MVC   RUSID,=CL8' '\n         MVC   RUSIDL(L'PSCBUSRL),PSCBUSRL SET DEFAULTS.\n         MVC   RUSID(L'PSCBUSER),PSCBUSER\n         DROP  R2\n         XC    REQAUT(REQAUTL),REQAUT\n         OI    REQAUT,X'10'\n         MVC   REQAUT+1(3),=AL3(MDL@IX)\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n        $EACM  REQAUT\n         CLI   AUTH,LV0            USER AUTHORIZED?\n         BE    NOTAUT              NO.\n        $TEW$PP PARM=PARMLST,REG=R3\n         BAS   R9,CLEAR\n         XR    R9,R9\n         TM    USID+6,X'80'        IS USERID SUPPLIED?\n         BZ    SKIP                NO, USE THE CURRENT.\n         L     R1,USID             GET POINTER TO USERID.\n         LH    R2,USID+4           GET LENGTH.\n         STC   R2,RUSIDL\n         MVC   RUSID,=CL8' '       CLEAR BEFORE MOVE.\n         BCT   R2,*+L'*+6          REDUCE BY ONE FOR MACHINE INSTR.\n         MVC   RUSID(*-*),0(R1)    <<EXECUTED>>\n         EX    R2,*-6              SET REQUESTED USERID.\n         DROP  R3\n         OI    REQAUT,X'01'\n         MVC   REQUS,RUSID\n         LA    R1,AUTHRQ\n         ST    R1,REQAUT+4\n        $EACM  REQAUT\n         CLI   AUTH,LV6            GROUP RESTRICTED?\n         BNL   *+L'*+10            NO.\n         CLC   AUTHGRP,AUTHRQG     IDENTICAL GROUP?\n         BNE   *+L'*+10            NO.\n         CLC   AUTH,AUTHRQ         MAY USER SEE THIS ONE?\n         BNL   SKIP                YES.\n         LA    R9,NOTAPW           NO.\nSKIP    IKJRLSA #TSANSW\n         LTR   R9,R9\n         BNZR  R9\n         SPACE 1\n*------- GET RACF PASSWORD.\n         SPACE 1\n         XC    RPR(RPRL),RPR\n         MVC   GAUT(GACTL),GACT\n         XC    WA(WAL),WA\n         LA    R1,WAL\n         ST    R1,WA\n        SETAUTH\n        ICHEINTY LOCATE,TYPE='USR',ENTRY=RUSIDL,ACTIONS=(GAUT,GPSW),   1\n               WKAREA=WA,OPTIONS=(FLDEF,ACTION),MF=(E,RPR)\n         LR    R6,R15\n        RESAUTH\n         LTR   R6,R6\n         BNZ   LOCERR\n         CLC   GOL,=XL2'0008'\n         BNE   NOPSWP\n         CLC   GPL,=XL2'0008'\n         BNE   NOPSWP\n         CLI   AUTH,LV10           AUTHORIZED?\n         BNL   RQOK                YES.\n         CLC   OWNER,=CL8'SYSDMS'  NO, LOOK DEFINED BY REGISTRATION.\n         BE    RQOK\n         CLC   OWNER,=CL8'SYSRACF'\n         BNE   NOTAPW\nRQOK     MVC   PLGTH,=F'8'\n         MVC   LINE+1(L'PSWMSG),PSWMSG\n         LA    R1,CALLLIST\n         LA    R2,PSWDM\n         ST    R2,0(R1)\n         LA    R2,LINE+L'PSWMSG+2\n         ST    R2,4(R1)\n         LA    R2,PLGTH\n         ST    R2,8(R1)\n         OI    8(R1),X'80'\n        CALL   PSWREST             TRANSLATION.\n         LTR   R15,R15\n         BZ    SENDR\n         MVI   LINE+L'PSWMSG+11,C'('\n         UNPK  LINE+L'PSWMSG+12(15),GPL(8)\n         UNPK  LINE+L'PSWMSG+26(7),PSWDM+5(4)\n         TR    LINE+L'PSWMSG+12(20),TRTAB-C'0'\n         MVI   LINE+L'PSWMSG+32,C')'\n         BAS   R9,SENDL\nSENDR    XR    R6,R6               RC = 0 -----------------------------\nLEAVE   $XRET  CC=(R6),LV=WRKL,TYPE=RENT\n         SPACE 1\n*------- DIAGNOSTIC'S MESSAGES.\n         SPACE 1\nNOTAUT   LA    R0,L'NAUTM\n         LA    R1,NAUTM\n         B     QUIT\nNOTAPW   LA    R0,L'NAPWM\n         LA    R1,NAPWM\n         B     QUIT\nNOPSWP   LA    R0,L'NPSWM\n         LA    R1,NPSWM\nQUIT     BAS   R14,PUTLNE\n         B     SETRC\nLOCERR   MVC   LINE+1(L'LOCMSG),LOCMSG\n         CVD   R6,WORK\n         UNPK  LINE+L'LOCMSG+2(2),WORK+6(2)\n         OI    LINE+L'LOCMSG+3,C'0'\n         BAS   R9,SENDL\nSETRC    LA    R6,16               RC = 16 ----------------------------\n         B     LEAVE\n         SPACE 1\n*------- COMMUNICATION WITH USER ROUTINE.\n*        AT ENTRY : THE MESSAGE TEXT IS PLACED IN 'LINE' AREA.\n*        AT EXIT : THE 'LINE' AREA IS BLANKS RESET.\n*              WORK REGISTERS = R0, R1, R14, R15.\n*              LINK REGISTER = R9.\n         SPACE 1\nSENDL    LA    R1,LINE\n         LA    R15,L'LINE-1(R1)\nSENDY    CLI   0(R15),C' '\n         BNE   SENDZ\n         CLR   R1,R15\n         BE    SENDZ\n         BCT   R15,SENDY\nSENDZ    SR    R15,R1\n         BZR   R9\n         LA    R0,1(,R15)\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     CLEAR               +0 - NORMAL COMPLETION\n         B     SETRC               +4 - ERROR\nCLEAR    MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         BR    R9\n         EJECT\n*------- SKELETONS, MESSAGES AND CONSTANTS.\n         SPACE 1\nGACT    ICHEACTN FIELD=AUTHOR,MF=L RACF PASSWORD ACTION LIST.\n        ICHEACTN FIELD=PASSWORD,MF=L\n         SPACE 1\nTRTAB    DC    C'0123456789ABCDEF'\nPSWMSG   DC    C'PASSWORD IS :'\nNAUTM    DC    C' -> UNAUTHORIZED COMMAND.'\nNAPWM    DC    C' -> UNAUTHORIZED TO ACCESS THIS USER-ID.'\nNPSWM    DC    C' -> NO PASSWORD PROVIDED.'\nLOCMSG   DC    C' -> RACF - ICHEINTY MACRO RETURN CODE IS :'\n         SPACE 1\n        LTORG\n         SPACE 1\nPARMLST IKJPARM\nUSID    IKJIDENT 'USER-ID',MAXLNTH=7,FIRST=ALPHA,OTHER=ALPHANUM\n        IKJENDP\n         SPACE 1\n*------- WORK-AREAS DESCRIPTIONS.\n         SPACE 1\nWRKDSECT DSECT\nSVA      DS    18F                 SAVE AREA.\n         SPACE 1\n       $TEW$WA\n         SPACE 1\nRPR     ICHEINTY LOCATE,TYPE='USR',ACTIONS=(*-*,*-*),MF=L\nRPRL     EQU   *-RPR\nGAUT    ICHEACTN FIELD=AUTHOR,MF=L\nGPSW    ICHEACTN FIELD=PASSWORD,MF=L\nGACTL    EQU   *-GAUT\n         SPACE 1\nWA       DS    A                   WORK AREA LENGTH.\n         DS    XL20                RESERVED.\n         DS    F                   ACTION RESPONSE LENGTH.\nGOL      DS    XL2                 AUTHOR LENGTH (8).\nOWNER    DS    CL8                 AUTHOR (OWNER).\nGPL      DS    XL2                 PASSWORD LENGTH (8).\nPSWDM    DS    CL8                 PASSWORD.\n         DS    H\nWAL      EQU   *-WA\n         SPACE 1\nCALLLIST DS    3F                  CALL PARAMETER LIST.\nPLGTH    DS    F\nWORK     DS    D\nLINE     DC    CL80' '\nRUSIDL   DS    XL1\nRUSID    DS    CL8\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)\nREQUS    DC    CL8' '\nAUTH     DC    XL1'0',CL8' '\nAUTHGRP  DC    CL8' '\nAUTHRQ   DC    XL1'0',CL8' '\nAUTHRQG  DC    CL8' '\nREQAUTL  EQU   *-REQAUT\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         SPACE 1\n        PRINT  NOGEN\n       $TEW$DS\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PSWR$": {"ttr": 32779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14#\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:23:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": "//PSWR     JOB (........),'INSTALL - P S W R -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* THIS TSO-COMMAND IS NOW OBSOLETED AT OUR INSTALLATION (91/03/15). *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=PSWR\n//ASP     EXEC PAJIAS2,OPT=',SYSPARM(TSO),RENT',MBR=PSWREST\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   PSWREAD\n  SETCODE AC(1)\n  NAME    PSWR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PSWR@": {"ttr": 32781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      PSWR      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     TSO : OBTAIN RACF PASSWORD      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Obtain the RACF password of a TSO USER-id.\n  ---------\n\n  Command :    Syntax : PSWR USERID\n  ---------\n               Default : if USERID is omitted, the current TSO\n                         session USER-id is assumed.\n\n  Authority :  all the system group USER-id's are fully authorized to\n  -----------  issue this command, and the registration man USER-id is\n               only allowed to issue it for a user who matches the\n               registration owner.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PSWREST": {"ttr": 32783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x171\\x00\\xa1\\x00\\xa1\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T17:31:00", "lines": 161, "newlines": 161, "modlines": 0, "user": "SYSPAJA"}, "text": "PRST     TITLE 'PASSWORD RESTORE ROUTINE.'\nPSWREST  START 0\n         SPACE 1\n* CALLING SEQUENCE : CALL PSWREST,(A,B,C),VL\n* ------------------\n*\n*        WHERE : A - IS THE ADDRESS OF A FIELD (FORMAT CL...) WHICH\n*                    CONTAINS THE MASKED PASSWORD.\n*\n*                B - IS THE ADDRESS OF THE RECEIVING FIELD (FORMAT\n*                    CL...) INTO WHICH IS MOVED THE PASSWORD.\n*\n*                C - IS THE ADDRESS OF A WORD (FORMAT F, FULLWORD\n*                    BOUNDARY) CONTAINING THE LENGTH OF THE MASKED\n*                    PASSWORD AND THUS OF THE PASSWORD.\n*\n*        RETURN CODES : VALUE IS SET IN REGISTER 15.\n*                       0 - NORMAL.\n*                       4 - UNKNOWN CHARACTER(S) DETECTED.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n         AIF   ('&SYSPARM' NE 'TSO').O1S0\n         EJECT\nWRKDSECT DSECT                     WORK AREAS DESCRIPTION.\n         SPACE 1\nSVA      DS    18F                 SAVE AREA.\n         SPACE 1\nWORK     DC    D'0'\nWORKR    DC    D'0'\nWORKA    DC    D'0'\nWORKM    DC    D'0'\nRCODE    DC    H'0'\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         SPACE 1\nPSWREST  CSECT                     RESTORE MAIN CSECT.\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         USING WRKDSECT,R13        SET WORK AREAS ADDRESSABILITY.\n         AGO   .O1S1\n.O1S0    EJECT\n        $XENT  BASE=R12\n.O1S1    LA    R6,1                INITIAL POINTER.\n         L     R7,8(R1)\n         L     R5,0(R7)            GET LENGTH.\n         XC    RCODE,RCODE\n         LTR   R5,R5\n         BNP   EXIT\nLOOP     XC    WORK,WORK\n         XC    WORKR,WORKR\n         LA    R4,8\n         CR    R4,R5\n         BNH   *+L'*+2             BRANCH IF L .GE. 8, LET 8 IN R4.\n         LR    R4,R5               L .LT. 8, SET L IN R4.\n         LR    R7,R4\n         BCTR  R7,0                COMPUTE MACHINE LENGTH.\n         LR    R9,R7\n         L     R8,0(R1)            GET PASSWORD ADDRESS.\n         ALR   R8,R6               + POINTER.\n         BCTR  R8,0                -1 TO ADJUST.\n         EX    R7,MOVEIN           GET IN WORK.\n         MVC   WORKR(1),WORK\n         TR    WORKR(1),RESTT\n         CLI   WORKR,0\n         BE    UNKNOWF\n         LTR   R9,R9\n         BZ    SBCK\n         LA    R10,1\n         LA    R14,WORK+1\n         LA    R15,WORKR+1\nCNXT     IC    R0,0(R14)\n         LA    R8,X'0F'\n         NR    R0,R8\n         LA    R8,RESTT\n         AR    R8,R0\n         LA    R11,NEL\nTNXT     CLI   0(R8),0\n         BE    NOCHAR\n         MVC   0(1,R15),0(R8)\n         MVC   WORKA,WORKR\n         MVC   WORKM,WORKA\n         LM    R2,R3,WORKA\n         SRDL  R2,1\n         STM   R2,R3,WORKA\n         XC    WORKA,WORKM\n         LM    R2,R3,WORKA\n         SRDL  R2,3\n         STM   R2,R3,WORKA\n         XC    WORKA,WORKM\n         EX    R10,TEST\n         BE    THIS\nNOCHAR   LA    R8,L'RESTT(R8)\n         BCT   R11,TNXT\nUNKNOW   MVI   0(R15),C' '\n         LA    R15,1(R15)\n         BCT   R9,UNKNOW\n         B     SETERR\nUNKNOWF  MVI   WORKR,C' '\n         MVC   WORKR+1(L'WORKR-1),WORKR\nSETERR   MVI   RCODE+1,4\n         B     SBCK\nTEST     CLC   WORK(*-*),WORKA\nTHIS     LA    R10,1(R10)\n         LA    R14,1(R14)\n         LA    R15,1(R15)\n         BCT   R9,CNXT\nSBCK     L     R8,4(R1)            GET MASKED PASSWORD ADDRESS.\n         ALR   R8,R6               + POINTER.\n         BCTR  R8,0                -1 TO ADJUST.\n         EX    R7,MOVEOU           SET BACK.\n         SLR   R5,R4               REMAINING BYTES.\n         ALR   R6,R4               NEXT POINTER.\n         LTR   R5,R5               ANY BYTES LEFT?\n         BP    LOOP                YES, GO TO PROCESS NEXT.\nEXIT     LH    R9,RCODE            GET RETURN CODE.\n         AIF   ('&SYSPARM' EQ 'TSO').O2S0\n        $XRET  CC=(R9)\n         AGO   .O2S1\n.O2S0   $XRET  CC=(R9),LV=WRKL,TYPE=RENT\n.O2S1    SPACE 1\nMOVEIN   MVC   WORK(*-*),0(R8)\nMOVEOU   MVC   0(*-*,R8),WORKR\n         EJECT\n         AIF   ('&SYSPARM' EQ 'TSO').O3S0\n         SPACE 1\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nWORK     DC    D'0'\nWORKR    DC    D'0'\nWORKA    DC    D'0'\nWORKM    DC    D'0'\nRCODE    DC    H'0'\n.O3S0    SPACE 1\n*        RESTORE TABLE.\n         SPACE 1\nRESTT    DS    0XL16\n*                    0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    XL16'00000000000000000000000000000000' 0\n         DC    XL16'00000000000000000000000000000000' 1\n         DC    XL16'00000000000000000000000000000000' 2\n         DC    XL16'00000000000000000000000000000000' 3\n         DC    XL16'4D004F4E00004B000000000040000000' 4\n         DC    XL16'5E005C5D005B00000000000000000050' 5\n         DC    XL16'6B0000006F00006C0000606100000000' 6\n         DC    XL16'00007A7B7C7D7E7F0000000000000000' 7\n         DC    XL16'00000000000000000000000000000000' 8\n         DC    XL16'00000000000000000000000000000000' 9\n         DC    XL16'00000000000000000000000000000000' A\n         DC    XL16'00000000000000000000000000000000' B\n         DC    XL16'D7D6D5D4D3D2D100000000000000D8D9' C\n         DC    XL16'C4C5C6C700C1C2C300000000C9C80000' D\n         DC    XL16'F1F0F3F2F5F4F7F6F8F9000000000000' E\n         DC    XL16'E2E30000E6E7E4E50000E9E800000000' F\nNEL      EQU   (*-RESTT)/L'RESTT\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RDCHK": {"ttr": 33027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\tS\\x00\\xbf\\x00\\xbf\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T09:53:00", "lines": 191, "newlines": 191, "modlines": 0, "user": "SYSPAJA"}, "text": "RDCHK    TITLE 'READ DATA-CHECK SUBROUTINE.'\nRDCHK    START 0\n         SPACE 1\n* PURPOSE : THIS IS A ROUTINE TO READ A 9-TRACKS TAPE FILE CONTAINING\n* --------- SOME ERRONEOUS RECORDS (PERMANENT REDUNDANCIES LIKE DATA\n*           CHECKS), AND THUS GIVING THE OPPORTUNITY TO CORRECT OR\n*           SUPPLY INFORMATION.\n*\n*           THE FOLLOWING DD-CARD IS NEEDED TO READ THE TAPE FILE :\n*\n*           //........ DD UNIT=TAPE,VOL=(PRIVATE,RETAIN,SER=......),\n*           //            DISP=(OLD,PASS),LABEL=(...,NL,,IN)\n*\n* CALLING SEQUENCE : CALL RDCHK,(A,B,C),VL\n* ------------------            (A,B)\n*\n*        WHERE : A - IS THE ADDRESS OF AN ARRAY (FORMAT FULLWORD - F\n*                    BOUNDARY) LARGE ENOUGH TO RECEIVE THE LONGEST\n*                    RECORD FROM THE TAPE FILE, WHICH THE DDNAME MUST\n*                    BE PASSED TO THE ROUTINE AT THE FIRST TIME IT IS\n*                    CALLED. THE DDNAME IS ASSUMED BE PLACED IN THE\n*                    FIRST EIGHT BYTES OF THE ARRAY.\n*\n*                B - IS THE ADDRESS OF THE CURRENT RECORD LENGTH\n*                    (FORMAT FULLWORD - F BOUNDARY) RETURNED BY THE\n*                    ROUTINE AFTER EACH READ OPERATION, UNLESS WHEN\n*                    THE END-OF-FILE IS DETECTED.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - READ OPERATION CORRECTLY EXECUTED.\n*                     1 - READ OPERATION HAS TERMINATED WITH PERMANENT\n*                         REDUNDANCY. THE RECORD IS IN THE ARRAY AS IT\n*                         HAS BEEN READ IN CORE STORAGE.\n*                     2 - END-OF-FILE DETECTED. THE FIRST FOUR BYTES\n*                         IN THE ARRAY (FISRT FULLWORD) CONTAINS THE\n*                         NUMBER OF RECORDS CORRECTLY READ, AND THE\n*                         FOLLOWING FOUR BYTES (SECOND FULLWORD)\n*                         CONTAINS THE NUMBER OF ERRONEOUS RECORDS\n*                         ENCOUNTERED.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - DD-CARD MISSING, NOT TAPE OR OPEN ERROR.\n*\n*                     --- IF THE ROUTINE DETECTS AN UNEXPECTED ERROR,\n*                         THE PROGRAM IS SENDED IN ABEND U0001.\n*\n* GENERAL NOTICE : MVS/XA : MUST BE AMODE AND RMODE 24.\n* ----------------\n         EJECT\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\n         SPACE 2\n        PRINT  NOGEN\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 1\nRDCHK    CSECT                     RESTORE MAIN CSECT.\n         EJECT\n        $XENT  BASE=R12\n         SR    R9,R9               SET DEFAULTS.\n         LA    R10,MAXERR\n         L     R7,0(R1)            CONTROL ARGUMENTS.\n         LA    R7,0(R7)\n         TM    0(R1),X'80'\n         BO    ERR3\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         TM    4(R1),X'80'\n         BO    RD1\n         TM    11(R1),X'03'\n         BNZ   ERR3\n         L     R9,8(R1)\n         LA    R9,0(R9)\n         TM    8(R1),X'80'\n         BZ    ERR3\nRD1      TM    3(R1),X'03'\n         BNZ   ERR3\n         TM    7(R1),X'03'\n         BNZ   ERR3\n         LA    R11,DCBTAPE\n         USING IHADCB,R11\n         SPACE 1\nSWOP     NOP   READ\n         MVC   DCBDDNAM(L'DCBDDNAM),0(R7) GET DDNAME.\n         OC    ATIOT(L'ATIOT),ATIOT FIRST TIME?\n         BNZ   RO1                 BRANCH IF NOT.\n        EXTRACT ATIOT,'S',FIELDS=(TIOT)\nRO1      L     R2,ATIOT            SEARCH DD AND OPEN IT.\n         USING TIODSECT,R2\n         SR    R1,R1\nRO2      CLC   TIOELNGH(4),ZEROS\n         BE    ERR4\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM\n         BE    RO3\n         IC    R1,TIOELNGH\n         ALR   R2,R1\n         B     RO2\n         DROP  R2\nRO3     DEVTYPE DCBDDNAM,DVTYP\n         CLI   DVTYP+2,X'80'       IS THAT A MAGNETIC TAPE?\n         BNE   ERR4                BRANCH IF NOT.\n        OPEN   ((R11),(INPUT))\n         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULL?\n         BZ    ERR4                NO, ERROR.\n         XC    OKBLOCK(L'OKBLOCK+L'ERBLOCK),OKBLOCK\n         OI    SWOP+1,ON\n         SPACE 1\nREAD     ST    R7,CCW              ADDRESS OF DATA BUFFER.\n         MVI   CCW,X'02'           SET READ CODE.\n         XC    ECB,ECB             CLEAR EVENT CONTROL BLOCK.\n         XC    CSW,CSW             CLEAR CSW INFO.\n        EXCP   IOB\n        WAIT   ECB=ECB\n         CLI   ECB,X'7F'\n         BE    OKREAD\n         TM    IOB+12,X'01'        UNIT EXCEPTION?\n         BO    TAPEEOF             YES, END-OF-FILE.\n         CLI   ECB,X'41'           I/O ERROR?\n         BE    RDERR               YES.\n         SPACE 1\n        ABEND  1,DUMP\n         SPACE 1\nTAPEEOF  OI    DCBOFLGS,DCBOFTM    SET EOF ENCOUNTERED.\n         NI    SWOP+1,OFF\n        CLOSE  ((R11))\n         MVC   0(L'OKBLOCK+L'ERBLOCK,R7),OKBLOCK\n         XC    0(4,R8),0(R8)\n         B     ERR2\n         SPACE 1\nOKREAD   SR    R10,R10\n         LA    R2,OKBLOCK\n         LA    R6,RET\nCOUNT    L     R1,0(R2)            UPDATE READ RECORDS COUNTER.\n         LA    R1,1(R1)\n         ST    R1,0(R2)\n         L     R2,CCW+4            COMPUTE AND STORE READ LENGTH.\n         LA    R2,0(R2)\n         SH    R2,CSW+6\n         ST    R2,0(R8)\n         BR    R6\n         SPACE 1\nRDERR    LA    R2,ERBLOCK\n         BAS   R6,COUNT\n         DROP  R11\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nERR4     BCTR  R10,0\n         SPACE 1\nMAXERR   EQU   ((*-ERR1)/2)+1\n         SPACE 1\nRET      LTR   R9,R9\n         BZ    EXIT\n         ST    R10,0(R9)\nEXIT    $XRET  CC=(R10)\n         EJECT\nDCBTAPE  DCB   DSORG=PS,DEVD=TA,MACRF=E,RECFM=U,                       1\n               IOBAD=IOB,OPTCD=Z,DDNAME=XXXXXXXX\n         EJECT\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\nCCW      CCW   X'02',*-*,X'20',32767\nATIOT    DC    A(*-*)\nZEROS    DC    F'0'\nDVTYP    DC    2F'0'\nOKBLOCK  DC    F'0'\nERBLOCK  DC    F'0'\n         SPACE 1\nECB      DC    F'0'\n         SPACE 1\nIOB      DC    0F'0',X'42000000'\n         DC    A(ECB)\nCSW      DC    XL8'0'\n         DC    A(CCW)\n         DC    A(DCBTAPE)\n         DC    2F'0'\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RDCHK$": {"ttr": 33031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "SYSPAJA"}, "text": "//RDCHK    JOB (........),'INSTALL  - RDCHK -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS3,MBR=RDCHK\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  NAME    RDCHK(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RDCHK@": {"ttr": 33033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14R\\x00?\\x00?\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:52:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      RDCHK     1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     READ DATA-CHECK SUBROUTINE      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL RDCHK,(A,B,C),VL\n  ------------------            (A,B)\n\n         Where : A - is the address of an array (format FULLWORD - F\n                     boundary) large enough to receive the longest\n                     record from the tape file, which the DDNAME must\n                     be passed to the routine at the first time it is\n                     called. The DDNAME is assumed be placed in the\n                     first eight bytes of the array.\n\n                 B - is the address of the current record length\n                     (format FULLWORD - F boundary) returned by the\n                     routine after each read operation, unless when\n                     the END-OF-FILE is detected.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is laways placed in register 15 and can be :\n\n                      0 - READ operation correctly executed.\n                      1 - READ operation has terminated with permanent\n                          redundancy. The record is in the array as it\n                          has been read in core storage.\n                      2 - END-OF-FILE detected. The first four bytes\n                          in the array (first fullword) contains the\n                          number of records correctly read, and the\n                          following four bytes (second fullword)\n                          contains the number of erroneous records\n                          encountered.\n                      3 - calling sequence or argument alignment error.\n                      4 - DD-card missing, not tape or OPEN error.\n\n                      --- If the routine detects an unexpected error,\n                          the program is sended in abend U0001.\n                          This routine is only serially multi-files\n                          usable.\n1   13/04/88\n                                                      RDCHK     2/2.\n\n  Purpose : This is a routine to read a 9-tracks tape file containing\n  --------- some erroneous records (permanent redundancies like data\n            checks), and thus giving the opportunity to correct or\n            supply information.\n\n            The following DD-card is needed to read the tape file :\n\n            //........ DD UNIT=TAPE,VOL=(PRIVATE,RETAIN,SER=......),\n            //            DISP=(OLD,PASS),LABEL=(...,NL,,IN)\n\n  Assembler macro : $RDCHK A,B,C\n  -----------------\n\n         Where C is optional and may be omitted.\n         Register use may be coded within parentheses.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RESAUTH": {"ttr": 33035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x884?\\x00\\x884?\\x11$\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-08T00:00:00", "modifydate": "1988-12-08T11:24:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           AUTHORIZATION OFF.\n&NAME    RESAUTH    &DUMMY\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n&NAME    XR    0,0                 SET AUTHORIZATION OFF.\n         SVC   ###                 SEND REQUEST.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RESETKEY": {"ttr": 33037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16(\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:28:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           PROBLEM MODE - AUTHORIZATION OFF.\n&NAME    RESETKEY   &DUMMY\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n&NAME   MODESET KEY=NZERO,MODE=PROB RE-ENTER PROBLEM MODE.\n        RESAUTH ,                  SET AUTHORIZATION OFF.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RESUME": {"ttr": 33039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x892O\\x00\\x892O\\x15V\\x00.\\x00.\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-20T00:00:00", "modifydate": "1989-11-20T15:56:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM)\n/*  MACRO NAME : RESUME                                             */\n/*    FUNCTION : RELOAD LAST SAVED COPY OF A MEMBER                 */\n/*      SYNTAX : RESUME                                             */\n/*               RESUME HELP OR H                                   */\n/*       DEBUG : RESUME LIST                                        */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 15                           */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(HELP) OR +\n      &STR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTRSM)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  CONTROL ASIS\n  ISREDIT (MEMBER) = MEMBER\n  IF &MEMBER = THEN DO\n    SET ZEDSMSG = PO ONLY ALLOWED\n    SET ZEDLMSG = ON PS FILES YOU MUST PERFORM THIS FUNCTION YOURSELF\n    END\n  ELSE DO\n    ISREDIT (CHANGED) = DATA_CHANGED\n    IF &CHANGED = YES THEN DO\n      ISREDIT EXCLUDE ALL\n      ISREDIT COPY &MEMBER BEFORE .ZFIRST\n      ISREDIT DELETE ALL EX\n      SET ZEDSMSG = RESUME DONE\n      SET ZEDLMSG = THIS COPY IS NOW REPLACED WITH THE LAST DISK ONE\n      END\n    ELSE DO\n      SET ZEDSMSG = NOT REQUIRED\n      SET ZEDLMSG = THIS COPY WAS NOT CHANGED FROM THE LAST DISK ONE\n      END\n    END\n  ISPEXEC SETMSG MSG(ISRZ000)\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RESUME@": {"ttr": 33041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x892_\\x00\\x892_\\x11A\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-21T00:00:00", "modifydate": "1989-11-21T11:41:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SYSPAJA"}, "text": "1   21/11/89\n                                                      RESUME    1/1.\n\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* * * * * * * * *                                     * * * * * * * * *\n* * * * * * * * *    RESUME ISPF/PDF EDIT command     * * * * * * * * *\n* * * * * * * * *                                     * * * * * * * * *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro allows a user to restore a member edit\n  ----------   from the last saved copy. This can be used when you have\n               made a change you did not mean to make.\n\n  Command syntax : RESUME\n  ---------------- RESUME HELP or H\n\n  Restriction : This command is not allowed on sequential (PS) file,\n  ------------- you must do it yourself (using CANCEL).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RGROUP": {"ttr": 33043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x13\\x8f\\x00\\x95\\x13\\x8f\\x11$\\x01\\xf0\\x01\\xf0\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-05-18T00:00:00", "modifydate": "1995-05-18T11:24:00", "lines": 496, "newlines": 496, "modlines": 0, "user": "SYSPAJA"}, "text": "RGRP     TITLE 'CHANGE CURRENT RACF CONNECT GROUP.'\nRGROUP   START 0\n         SPACE 1\n         GBLA  &NUMINS             MAXIMUM NUMBER OF INSERTS\n&NUMINS  SETA  2                   FOR IKJEFF02\n         SPACE 1\n* PURPOSE :    TO CHANGE THE RACF GROUP TO WHICH A RACF TSO-USER OR\n* ---------    JOB IS CURRENTLY CONNECTED. FOR SHOPS THAT RUN RACF,\n*              ALLOWS THE USER TO SWITCH TO A DIFFERENT CONNECT GROUP\n*              WITHOUT HAVING TO LOGOFF AND LOG BACK ON SPECIFYING THE\n*              DIFFERENT GROUP ON THE LOGON COMMAND. BASICALLY, IT\n*              PERFORMS A RACINIT \"CHANGE\" FUNCTION. MUST BE LINKED\n*              AND EXECUTED AC=1. CAN BE RUN IN BATCH OR AS A TSO CP.\n*\n* INPUT :      (1) A GROUP NAME, WHICH WILL BECOME THE NEW CURRENT\n* -------          GROUP NAME IF THE USER IS RACF AUTHORIZED TO IT.\n*           OR (2) NO PARAMETER, IN WHICH CASE THE NAME OF THE CURRENT\n*                  GROUP WILL BE LISTED.\n*       NOTE - THIS PROGRAM MAY BE RUN UNDER TSO OR AS A BACKGROUND\n*              JOB. IT MUST BE APF AUTHORIZED, WHICH WILL LIMIT THE\n*              WAYS IT CAN BE EXECUTED UNDER TSO.\n*\n* HOW TO USE :\n* ------------\n*\n* 1. FOREGROUND CP :  RGROUP  ...NEW GROUP NAME...\n*\n* 2. BACKGROUND :  //...  EXEC   PGM=RGROUP,PARM=...NEW GROUP NAME...\n*\n* 3. CALLED ROUTINE :\n*    A. THE MESSAGES ARE SENT TO THE SYSTEM LOG :\n*                      ...\n*                      CALL  RGROUP,(PARM),VL\n*                      ...\n*        WITH : PARM   DC    H'0'\n*          OR : PARM   DC    0H'0',AL2(L'GROUP)\n*               GROUP  DC    C'...NEW GROUP NAME...'\n*    B. THE MESSAGES ARE JUST RETURNED TO SUPPLIED CALLER'S BUFFERS :\n*                      ...\n*                      CALL  RGROUP,(PARM,MSGS),VL\n*                      ...\n*        WITH : MSGS   DC    AL1(L'BF1),AL3(BF1),AL1(L'BF2),AL3(BF2)\n*               BF1    DC    CL120' '  FIRST LEVEL MESSAGE\n*               BF2    DC    CL120' '  SECOND LEVEL MESSAGE\n*        THE MESSAGES ARE RETURNED IN THE FORM 'LL00...TEXT...' WHERE\n*        'LL' IS THE LENGTH OF TEXT +4. IF IF THE CALLER'S BUFFER IS\n*        TOO SMALL, AS MUCH OF 'LL00...TEXT...' IS MOVED AS POSSIBLE.\n*        THE CALLER MUST COMPARE MESSAGE SIZE WITH BUFFER SIZE TO KNOW\n*        IF MESSAGE HAS BEEN TRUNCATED. 'LL' ZERO MEANS NO MESSAGE.\n         EJECT\n* ATTRIBUTES : MODULE IS REENTRANT.\n* ------------\n*\n* AUTHOR :     WALT FARRELL, RAINIER BANK, 11/10/78\n* --------     ADAPTED BY : MOINIL P.A.\n*                           COMPUTING CENTRE\n*                           J.R.C. - ISPRA ESTABLISHMENT\n*                           21020 ISPRA (VA), ITALY\n*\n* MODIFICATIONS :\n* ---------------\n*              (1) AFTER SUCCESSFULLY CHANGING THE CURRENT GROUP,\n*                  PROPAGATE THE SETTING OF THE ACEE ADSP FLAG INTO THE\n*                  JSCB, WHERE THE SYSTEM ACTUALLY CHECKS IT. THIS WILL\n*                  BYPASS AN IBM BUG OF NOT PROPAGATING IT.\n         SPACE 2\n        $DEFREG\n         EJECT\n*        INITIALIZATION.\n         SPACE 1\n        $XENT  BASE=R12,LV=LWORKA,TYPE=RENT\n         LR    R10,R13\n         USING WORKA,R10           #####\n         LR    R11,R1              SAVE PARM ADDRESS\n         ST    R11,WCPPLP          SAVE POSSIBLE CPPL ADDRESS\n         MVI   WFLAGS,0            CLEAR THE FLAG BYTE\n         XR    R9,R9               SET RETURN CODE TO ZERO\n         XC    WECB,WECB           CLEAR PARSE ECB\n         MVC   WRACINIT,RACINIT    INIT LIST FORM OF RACINIT\n         MVC   WEXTRACT,EXTRACT    INIT LIST FORM OF EXTRACT\n         EJECT\n*        VERIFY RACF ACTIVE AND USER DEFINED TO RACF.\n         SPACE 1\n         L     R2,CVTPTR           GET CVT\n         USING CVT,R2              #####\n         RACSTAT ,                 TEST FOR RACF ACTIVE\n         LTR   R15,R15             ACTIVE?\n         BNZ   RGNORACF            MESSAGE IF NOT\n         L     R3,CVTTCBP          GET ASCB ADDR\n         L     R3,12(,R3)\n         USING ASCB,R3             #####\n         L     R3,ASCBASXB         GET ASXB ADDRESS\n         USING ASXB,R3             #####\n         L     R3,ASXBSENV         GET ACEE ADDRESS\n         LA    R3,0(,R3)\n         LTR   R3,R3               ACEE ADDRESS THERE?\n         BZ    RGNOUSER            ISSUE MSG IF NOT - NOT RACF USER\n         USING ACEE,R3             #####\n         CLC   ACEEACEE,CACEE      ACEE VALID?\n         BNE   RGACERR             MSG IF NOT\n         TM    ACEEFLG1,ACEERACF   RACF DEFINED USER?\n         BZ    RGNOUSER            MSG IF NOT\n         ST    R3,WACEEP           SAVE ACEE ADDRESS\n         DROP  R2,R3               #####\n         EJECT\n*        CHECK MODE OF OPERATION (CP OR CALLED)\n         SPACE 1\n         EXTRACT WAPSCB,'S',       GET PSCB ADDRESS                    X\n               FIELDS=(PSB),                                           X\n               MF=(E,WEXTRACT)\n         L     R2,WAPSCB           GET PSCB ADDRESS\n         LTR   R2,R2               IS IT TRUE?\n         BZ    RG020               NO, WE ARE'NT IN TSO\n         USING CPPL,R11            #####\n         CLC   WAPSCB(L'WAPSCB),CPPLPSCB     CPPL+8 = PSCB ADDRESS?\n         BE    RG010               YES, TSO COMMAND\n         LR    R1,R11\n         USING IKJEBECA,R1\n         L     R11,CAPTTMP         CPPL ADDRESS\n         DROP  R1\n         CLC   WAPSCB(L'WAPSCB),CPPLPSCB     CPPL+8 = PSCB ADDRESS?\n         BE    RG010               YES, TSO SUB-COMMAND\n         LR    R11,R1              NO, NOT A CP\n         B     RG020               GO CHECK AUTHORIZATION\nRG010    L     R2,CPPLPSCB         PICK UP PSCB ADDR FROM CPPL\n         LA    R2,0(,R2)           CLEAR HIGH BYTE\n         CL    R2,WAPSCB           VERIFY PSCB CORRECT\n         BNE   RGERR2              ERROR IF NOT CORRECT PSCB ADDRESS\n         OI    WFLAGS,WFCP         SHOW WE ARE A CP\n         DROP  R11                 #####\n         EJECT\n*        GET GROUP NAME FROM CALL COMMAND OR PROGRAM.\n         SPACE 1\nRG020    XR    R6,R6\n         TM    WFLAGS,WFCP         RUNNING AS A CP?\n         BO    RG050               YES, GO PARSE COMMAND\n*                                  ELSE USE PARM FROM CALL COMMAND\n         TM    0(R11),X'80'        ONLY ONE PARM IN PARMLIST?\n         BO    RG030               YES, CONTINUE PROCESSING\n         L     R6,4(R11)           GET CALLER'S BUFFERS INFO ADDR\nRG030    L     R1,0(,R11)          PICK UP THE PARM\n         LH    R2,0(,R1)           GET THE PARM LENGTH\n         LTR   R2,R2               CHECK FOR VALID PARM LENGTH\n         BZ    RG500               IF ZERO, LIST CURRENT GROUP NAME\n         BM    RGERR4              IF MINUS, ERROR\n         C     R2,=F'8'            IF GREATER THAN 8 THEN ERROR\n         BH    RGERR4\n         STC   R2,WGROUPL          SAVE LENGTH OF NAME\n         BCTR  R2,0                DECREMENT FOR EXECUTE\n         MVC   WGROUPN(*-*),2(R1)  << EXECUTED >>\n         EX    R2,*-6              SAVE THE GROUP NAME\n         B     RG100               CONTINUE PROCESSING\n         EJECT\n*        PARSE COMMAND TO GET GROUP NAME.\n         SPACE 1\nRG050    LA    R2,WPPL             POINT TO PPL IN WORKAREA\n         USING PPL,R2              #####\n         L     R3,WCPPLP           POINT TO CPPL\n         USING CPPL,R3             #####\n         MVC   PPLUPT,CPPLUPT      SET UP PPL\n         MVC   PPLECT,CPPLECT\n         LA    R1,WECB\n         ST    R1,PPLECB\n         L     R1,APCL\n         ST    R1,PPLPCL\n         LA    R1,WANS\n         ST    R1,PPLANS\n         MVC   PPLCBUF,CPPLCBUF\n         XC    PPLUWA,PPLUWA\n         DROP  R2,R3               #####\n         CALLTSSR EP=IKJPARS,      PARSE THE COMMAND                   X\n               MF=(E,WPPL)\n         CLC   WANS,=XL4'FF000000' PARSE OK?\n         BE    RGERR5              ERROR IF NOT\n         L     R1,WANS             POINT TO PDL\n         USING IKJPARMD,R1         #####\n         XR    R2,R2\n         TM    PGRP+6,X'80'        PARAMETER PRESENT?\n         BZ    RG50X               BRANCH IF NOT\n         L     R2,PGRP             POINT TO GROUP NAME\n         LH    R3,PGRP+4           GET LENGTH\n         EJECT\n*        PARSE COMMAND TO GET GROUP NAME (CONTINUED).\n         SPACE 1\n         STC   R3,WGROUPL          SAVE LENGTH OF GROUP NAME\n         BCTR  R3,0                DECREMENT FOR EXECUTE\n         MVC   WGROUPN(*-*),0(R2)  << EXECUTED >>\n         EX    R3,*-6              MOVE IN GROUP NAME\n         DROP  R1                  #####\nRG50X    IKJRLSA WANS              FREE PDL STORAGE\n         LTR   R2,R2\n         BZ    RG500               GO LIST CURRENT GROUP NAME IF NOT\n         EJECT\n*        CHANGE CURRENT CONNECT GROUP.\n         SPACE 1\nRG100    MVC   WINSGRPL,WGROUPL    SET UP INSERTS FOR\n         LA    R1,WGROUPN          POSSIBLE ERROR MESSAGE\n         STCM  R1,B'0111',WINSGRPA\n         LA    R1,X'84'\n         STC   R1,WINSGR2L\n         LA    R1,WSAVR15\n         STCM  R1,B'0111',WINSGR2A\n         LA    R1,2\n         ST    R1,WINSGRPC\n         ZEROKEY ,                 GET RACF ACCESS\n         RACINIT GROUP=WGROUP,ENVIR=CHANGE,MF=(E,WRACINIT)\n         LR    R2,R15              SAVE RETURN CODE\n         RESETKEY ,                BACK TO OUR NORMAL KEY\n         LTR   R15,R2              SUCCESSFUL?\n         BZ    RG600               YES - GO PROPAGATE ADSP TO GET\n*                                        AROUND IBM BUG\n         ST    R15,WSAVR15         ELSE SAVE FOR ERROR MSG AND\n         C     R15,=F'20'          CHECK ERROR CODE\n         BE    RGNOGRP             BIF NOT DEFINED TO GROUP\n         C     R15,=F'24'\n         BE    RGFEXIT             BIF FAILED BY INST. EXIT\n         C     R15,=F'36'\n         BE    RGGREV              BIF USER REVOKED IN GROUP\n         C     R15,=F'48'\n         BE    RGNOTERM            BIF TERMINAL NOT ALLOWED\n         B     RGRACERR\n         SPACE 2\n*        LIST CURRENT CONNECT GROUP.\n         SPACE 1\nRG500    L     R1,WACEEP           ADDRESS ACEE\n         USING ACEE,R1             #####\n         MVC   WINSGRPL,ACEEGRPL   SET UP INSERTS\n         MVC   WGROUPN,ACEEGRPN\n         DROP  R1                  #####\n         LA    R1,WGROUPN\n         STCM  R1,B'0111',WINSGRPA\n         LA    R1,1\n         ST    R1,WINSGRPC\n         LA    R2,WINSGRP          ISSUE MESSAGE GIVING CURRENT\n         LA    R3,RGM02            GROUP\n         BAS   R7,RGEFF02\n         B     RG900\n         EJECT\n*        PROPAGATE ADSP FROM ACEE TO JSCB TO GET AROUND IBM BUG.\n         SPACE 1\nRG600    L     R1,CVTPTR           GET JSCB ADDRESS\n         USING CVT,R1              #####\n         L     R1,CVTTCBP\n         L     R1,4(,R1)\n         USING TCB,R1              #####\n         L     R2,TCBJSCB\n         USING IEZJSCB,R2          #####\n         DROP  R1                  #####\n         L     R3,WACEEP           GET ACEE ADDRESS\n         USING ACEE,R3             #####\n         ZEROKEY ,                 GET UPDATE ACCESS TO JSCB\n         NI    JSCBFBYT,X'FF'-JSCBADSP  TURN OFF ADSP IN JSCB\n         TM    ACEEFLG1,ACEEADSP   DOES USER NOW HAVE ADSP?\n         BZ    RG650               /NO  - LEAVE JSCBADSP OFF\n         OI    JSCBFBYT,JSCBADSP   /YES - TURN JSCBADSP ON\nRG650    RESETKEY ,                BACK TO OUR NORMAL KEY\n         DROP  R2,R3               #####\n         EJECT\n*        CLEANUP AND LEAVE.\n         SPACE 1\nRG900   $XRET  CC=(R9),LV=LWORKA,TYPE=RENT\n         SPACE 2\n*        ERROR HANDLING.\n         SPACE 1\n*                        RACF NOT ACTIVE - - - - - - - - - - - - - - -\nRGNORACF XR    R2,R2               NO INSERT LIST\n         LA    R3,RGM03            ISSUE MESSAGE 3\n         BAS   R7,RGEFF02\nRGRET4   LA    R9,4                RC=4\n         B     RG900\n*                        USER NOT DEFINED TO RACF  - - - - - - - - - -\nRGNOUSER XR    R2,R2               NO INSERT LIST\n         LA    R3,RGM04            ISSUE MESSAGE 4\n         BAS   R7,RGEFF02\n         B     RGRET4\n*                        INVALID ACEE - - - - - - - - - - - - - - - -\nRGACERR  LA    R2,INSACEE          INSERT = 'ACEE'\n         LA    R3,RGM05            ISSUE MESSAGE 5\n         BAS   R7,RGEFF02\nRGRET16  LA    R9,16               RC=16\n         B     RG900\n*                        INVALID PARM LIST (PSCB ADDR WRONG) - - - - -\nRGERR2   LA    R2,INSPSCB          INSERT = 'PSCB'\n         LA    R3,RGM05            ISSUE MESSAGE 5\n         BAS   R7,RGEFF02\n         B     RGRET16\n*                        INVALID PARM LIST (PARM LENGTH WRONG) - - - -\nRGERR4   LA    R2,INSPARM          INSERT = 'PARAMETER LENGTH'\n         LA    R3,RGM05            ISSUE MESSAGE 5\n         BAS   R7,RGEFF02\nRGRET8   LA    R9,8                RC=8\n         B     RG900\n         EJECT\n*        ERROR HANDLING (CONTINUED).\n         SPACE 1\n*                        PARSE ERROR - - - - - - - - - - - - - - - - -\nRGERR5   ST    R15,WSAVR15         SAVE ERROR CODE\n         LA    R2,WINSR15          INSERT = 'PARAMETER LENGTH'\n         USING INSDSECT,R2         #####\n         LA    R3,1                SET UP INSERT\n         ST    R3,INSCNT\n         MVI   INSLEN,X'84'        LEN=4, TRANSLATE TO NUMERIC\n         LA    R3,WSAVR15\n         STCM  R3,B'0111',INSDATA\n         LA    R3,RGM06            ISSUE MESSAGE 6\n         BAS   R7,RGEFF02\n         B     RGRET16\n*                        USER NOT DEFINED IN REQUESTED GROUP - - - - -\nRGNOGRP  LA    R2,WINSGRP          INSERT = GROUP NAME\n         LA    R3,RGM07            ISSUE MESSAGE 7\n         BAS   R7,RGEFF02\n         B     RGRET8\n*                        RACINIT FAILED BY INST. EXIT  - - - - - - - -\nRGFEXIT  XR    R2,R2               NO INSERT\n         LA    R3,RGM08            ISSUE MESSAGE 8\n         BAS   R7,RGEFF02\n         B     RGRET8\n*                        USER REVOKED IN REQUESTED GROUP - - - - - - -\nRGGREV   LA    R2,WINSGRP          INSERT = GROUP NAME\n         LA    R3,RGM10            ISSUE MESSAGE 10\n         BAS   R7,RGEFF02\n         B     RGRET8\n*                        TERMINAL NOT AUTHORIZED - - - - - - - - - - -\nRGNOTERM L     R2,WACEEP           GET ACEE ADDRESS\n         USING ACEE,R2             #####\n         LA    R2,ACEETRID         POINT TO TERMINAL ID\n         DROP  R2                  #####\n         STCM  R2,B'0111',WINSGR2A PUT INTO INSERT LIST\n         LA    R2,8                LENGTH OF INSERT IS 8\n         STC   R2,WINSGR2L\n         LA    R2,WINSGRP          INSERT = GRP NAME/TERMINAL ID\n         LA    R3,RGM12            ISSUE MESSAGE 12\n         BAS   R7,RGEFF02\n         B     RGRET8\n*                        UNEXPECTED RACINIT RETURN CODE  - - - - - - -\nRGRACERR LA    R2,WINSGRP          INSERT GROUP NAME/RC\n         LA    R3,RGM11            ISSUE MESSAGE 10\n         BAS   R7,RGEFF02\n         B     RGRET16\n         EJECT\n*        INTERFACE TO IKJEFF02.\n*              (R2--->INSDSECT, R3--->CL4'MSGID',R7--->RETURN)\n         SPACE 1\nRGEFF02  XC    MTPARML(MTLENMT),MTPARML CLEAR PARMS\n         LA    R1,MTCSECTP         INIT PARMS\n         ST    R1,MTPLPTR\n         TM    WFLAGS,WFCP         CP?\n         BZ    RGEFF02A            NO CPPL IF NOT\n         L     R1,WCPPLP\n         ST    R1,MTCPPLP\n         OI    MTSW1,MTPUTLSW      SET FOR PUTLINE IF CPPL\n         B     RGEFF02C\nRGEFF02A LTR   R6,R6               CALLER'S BUFFERS INFO?\n         BZ    RGEFF02B            NO, SO USE WTP\n         MVC   MTEXTRCT(8),0(R6)   SET CALLER'S BUFFERS INFO'S\n         B     RGEFF02C\nRGEFF02B OI    MTSW1,MTWTPSW       SET FOR WTP IF NO CPPL\nRGEFF02C OI    MTSW1,MTHEXSW       HEX TRANSLATION FOR NUMERIC INSERTS\n         OI    MTHIGH,X'80'\n         L     R1,AMSGS\n         ST    R1,MTCSECTP\n         MVC   MTMSGID(4),0(R3)\n         LTR   R2,R2               ANY INSERTS?\n         BZ    RGEFF02E            BIF NOT\n         USING INSDSECT,R2         #####\n         L     R1,INSCNT           GET NUMBER OF INSERTS\n         C     R1,=F'&NUMINS'      ENSURE COUNT OK\n         BNH   RGEFF02D\n         ABEND RGA01               IF NOT, USER 1 ABEND - - - - - - - -\nRGEFF02D SLL   R1,2                ELSE GET COUNT*4\n         BCTR  R1,0                LESS ONE FOR EXECUTE\n         MVC   MTINSRTS(*-*),INSLEN     << EXECUTED >>\n         EX    R1,*-6              MOVE INSERT DATA INTO PARMLIST\n         DROP  R2                  #####\nRGEFF02E CALLTSSR EP=IKJEFF02,     ISSUE MESSAGE                       X\n               MF=(E,MTPARML)\n         BR    R7                  RETURN TO CALLER\n         SPACE 2\n         LTORG\n         EJECT\n*        CONSTANTS, ETC...\n         SPACE 1\nAPCL     DC    A(PCL)\nAMSGS    DC    A(MSGS)\n         DS    0F\nRACINIT  RACINIT ENVIR=CHANGE,MF=L\nRACINITL EQU   *-RACINIT\n         DS    0F\nEXTRACT  EXTRACT ,'S',FIELDS=(PSB),MF=L\nEXTRACTL EQU   *-EXTRACT\n         DS    0F\nINSACEE  DC    F'1',AL1(L'CACEE),AL3(CACEE)\nINSPSCB  DC    F'1',AL1(L'CPSCB),AL3(CPSCB)\nINSPARM  DC    F'1',AL1(L'CPMLN),AL3(CPMLN)\nCACEE    DC    C'ACEE'\nCPSCB    DC    C'PSCB'\nCPMLN    DC    C'PARAMETER LENGTH'\nRGA01    EQU   1                   USER 1 ABEND CODE\nRGM02    DC    C'RG02'             MESSAGE ID'S\nRGM03    DC    C'RG03'\nRGM04    DC    C'RG04'\nRGM05    DC    C'RG05'\nRGM06    DC    C'RG06'\nRGM07    DC    C'RG07'\nRGM08    DC    C'RG08'\nRGM09    DC    C'RG09'\nRGM10    DC    C'RG10'\nRGM11    DC    C'RG11'\nRGM12    DC    C'RG12'\n         EJECT\n*        LOCAL DSECTS.\n         SPACE 1\nWORKA    DSECT\n         SPACE 1\n         DS    18F                 MUST BE FIRST IN WORKA - SAVE AREA\n         SPACE 1\nWSAVR15  DS    F                   SAVE AREA FOR R15 FOR ERROR MSGS\nWCPPLP   DS    A                   A(CPPL) IF ANY\nWACEEP   DS    A                   A(ACEE)\nWANS     DS    A                   A(PDE)\nWAPSCB   DS    A                   A(PSCB)\nWECB     DS    F                   PARSE ECB\nWINS     DS    F,FL1,AL3           MAPPED BY INSDSECT\nWFLAGS   DS    X                   FLAGS :\nWFCP     EQU   X'80'                 RGROUP RUNNING AS A CP\nWGROUP   DS    0XL9                GROUP PARAMETER FOR RACINIT :\nWGROUPL  DS    X                     LENGTH OF NEW GROUP NAME\nWGROUPN  DS    CL8                   NEW GROUP NAME\n         DS    0F\nWPPL     DS    XL(LPPL)            PARSE PARM LIST (FULLWORD ALIGN)\n         DS    0F\nWRACINIT DS    XL(RACINITL)        AREA FOR LIST FORM RACINIT\n         DS    0F\nWEXTRACT DS    XL(EXTRACTL)        AREA FOR LIST FORM EXTRACT\nWINSGRP  DS    0F                  MSG INSERT FOR GROUP NAME :\nWINSGRPC DS    F                     INSERT COUNT\nWINSGRPL DS    X                     LENGTH OF INSERT\nWINSGRPA DS    AL3                   ADDR OF INSERT\nWINSGR2L DS    X                     LENGTH OF INSERT\nWINSGR2A DS    AL3                   ADDR OF INSERT\nWINSR15  DS    XL8                 INSERT AREA FOR R15\n         SPACE 1\n         IKJEFFMT MTNINST=&NUMINS\n         SPACE 1\nLWORKA   EQU   (((*-WORKA)+7)/8)*8\n         SPACE 2\nINSDSECT DSECT\n         SPACE 1\nINSCNT   DS    F                   COUNT OF INSERTS\nINSLEN   DS    FL1                 LENGTH OF INSERT\nINSDATA  DS    AL3                 ADDRESS OF INSERT\n* ...\n         SPACE 2\n*        IBM DSECTS.\n         SPACE 1\n         PRINT NOGEN\n         IKJCPPL\n         IKJEBECA\n         IKJPPL\nLPPL     EQU   *-PPL\n         IHAACEE\n         IHAASCB\n         IHAASXB\n         IKJTCB\n         IEZJSCB\n         CVT   DSECT=YES,LIST=YES\n         PRINT GEN\n         EJECT\n*        PARSE PARAMETER CONTROL LIST (PCL).\n         SPACE 1\nRGROUP   CSECT ,                   ENSURE WE ARE IN A CSECT\nPCL      IKJPARM\nPGRP     IKJIDENT 'GROUP NAME',UPPERCASE,MAXLNTH=8,                    X\n               FIRST=ALPHA,OTHER=ALPHANUM,                             X\n               HELP=('NAME OF A RACF GROUP TO WHICH YOU ARE CONNECTED')\n         IKJENDP\n         EJECT\n*        MESSAGES FOR ISSUANCE BY IKJEFF02.\n         SPACE 1\nMSGS     CSECT\n         IKJTSMSG ('RG02 CURRENT GROUP IS ',),RG02\n         IKJTSMSG ('RG03 RGROUP IGNORED, RACF NOT ACTIVE'),RG03\n         IKJTSMSG ('RG04 RGROUP IGNORED, NOT DEFINED TO RACF'),RG04\n         IKJTSMSG ('RG05 INVALID ',),RG05\n         IKJTSMSG ('RG06 PARSE ERROR ',),RG06\n         IKJTSMSG ('RG07 RGROUP FAILED. YOU ARE NOT AUTHORIZED TO USE GX\n               ROUP ',),RG07\n         IKJTSMSG ('RG08 RGROUP FAILED BY INSTALLATION EXIT'),RG08\n         IKJTSMSG ('RG10 RGROUP FAILED. YOU ARE NOT CURRENTLY AUTHORIZEX\n               D TO USE GROUP ',),RG10\n         IKJTSMSG ('RG11 RACINIT FAILED, GROUP = ',,', RC = ',),RG11\n         IKJTSMSG ('RG12 RGROUP FAILED. GROUP ',,' IS NOT AUTHORIZED TOX\n                USE TERMINAL ',),RG12\n         IKJTSMSG\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RGROUP$": {"ttr": 33288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14#\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:23:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//RGROUP   JOB (........),'INSTALL  -RGROUP-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=RGROUP\n//LNK     EXEC PAJILKC,OPT=',RENT'      (ALSO PAJILKR IF NEEDED)\n//SYSIN     DD *\n  ENTRY   RGROUP\n  NAME    RGROUP(R)\n/*\n//HLP     EXEC PAJHELP,MBR=RGROUPH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RGROUP@": {"ttr": 33290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x004\\x004\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      RGROUP    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *  CHANGE CURRENT RACF CONNECT GROUP  * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    To change the RACF GROUP to which a RACF TSO-user or\n  ---------    JOB is currently connected. For shops that run RACF,\n               allows the user to switch to a different CONNECT GROUP\n               without having to LOGOFF and LOGON back specifying the\n               different group on the LOGON command. Basically, it\n               performs a RACINIT \"CHANGE\" function. This program may\n               be run under TSO or as a background JOB.\n\n  Input :      (1) A GROUP name, which will become the new current\n  -------          GROUP name if the user is RACF authorized to it.\n            or (2) no parameter, in which case the name of the current\n                   GROUP will be listed.\n\n  How to use :\n  ------------\n\n  1. Foreground CP :  RGROUP  ...new GROUP name...\n  2. Background :  //...  EXEC   PGM=RGROUP,PARM=...new GROUP name...\n  3. Called routine :\n     A. The messages are sent to the SYSTEM LOG :\n                       ...\n                       CALL  RGROUP,(PARM),VL\n                       ...\n         with : PARM   DC    H'0'\n           or : PARM   DC    0H'0',AL2(L'GROUP)\n                GROUP  DC    C'...new GROUP name...'\n     B. The messages are just returned to supplied caller's buffers :\n                       ...\n                       CALL  RGROUP,(PARM,MSGS),VL\n                       ...\n         with : MSGS   DC    AL1(L'BF1),AL3(BF1),AL1(L'BF2),AL3(BF2)\n                BF1    DC    CL120' '  First level message\n                BF2    DC    CL120' '  Second level message\n         The messages are returned in the form 'LL00...text...' where\n         LL00 is fout bytes long, and into which LL is the length\n         of text +4. If the caller's buffer is too small, then as much\n         of 'LL00...text...' is moved as possible. The caller must\n         compare the message size with the buffer size to know if the\n         message has been truncated. LL is set to zero if no message\n         is moved back.\n\n  Attributes : module is reentrant.\n  ------------\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RGROUPH": {"ttr": 33292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=RGROUP\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  TO CHANGE THE RACF GROUP TO WHICH A RACF TSO-USER IS\n               CURRENTLY CONNECTED. FOR SHOPS THAT RUN RACF, ALLOWS\n               THE USER TO SWITCH TO A DIFFERENT CONNECT GROUP WITHOUT\n               HAVING TO LOGOFF AND LOG BACK ON SPECIFYING THE\n               DIFFERENT GROUP ON THE LOGON COMMAND. BASICALLY, IT\n               PERFORMS A RACINIT \"CHANGE\" FUNCTION.\n)X SYNTAX :    RGROUP GROUP-NAME\n               REQUIRED : NONE.\n               DEFAULT : IF THE GROUP-NAME IS NOT SPECIFIED, THE NAME\n                         OF THE CURRENT GROUP WILL BE LISTED.\n               ALIAS : NONE.\n)O OPERANDS :\n))GROUP-NAME : A GROUP NAME, WHICH WILL BECOME THE NEW CURRENT GROUP\n               NAME IF THE USER IS RACF AUTHORIZED TO IT.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RJUST": {"ttr": 33294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x179\\x00\\\\\\x00\\\\\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T17:39:00", "lines": 92, "newlines": 92, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM) NOPROCESS\n/*  MACRO NAME : RJUST                                              */\n/*    FUNCTION : RIGHT JUSTIFY TEXT WITHIN DATA LINE(S)             */\n/*      SYNTAX : RJUST                                              */\n/*               RJUST HELP OR H                                    */\n/*       DEBUG : RJUST LIST                                         */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n  IF &STR(&APARM.) \u00ac= &STR() THEN DO\n    IF &STR(&APARM.) = &STR(HELP) OR +\n      &STR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTRJ)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = VALID OPERAND ARE HELP OR NULL\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ISPEXEC CONTROL ERRORS RETURN\n  CONTROL ASIS\n/*               PROCESS LINE COMMANDS, CHECK IF C WAS SPECIFIED    */\n  ISREDIT PROCESS RANGE C\n  SET LCC = &LASTCC\n  ISREDIT (RC) = RANGE_CMD\n  SET RCC = &LASTCC\n  IF &LCC \u00ac=0 OR &RCC \u00ac=0 THEN DO\n    IF &RCC = 4 THEN DO\n      IF &STR(&RC) \u00ac= &STR(C) THEN DO\n        IF &LCC = 4 THEN SET &ZEDSMSG = &STR(NO RANGE)\n        ELSE SET &ZEDSMSG = &STR(INVALID RANGE)\n        SET &ZEDLMSG = &STR(YOU MUST SPECIFY A TARGET RANGE OF +\n                            LINES, USING \"CN\" OR \"CC\")\n        END\n      ELSE DO\n        SET &ZEDSMSG = &STR(RANGE INCOMPLETE)\n        SET &ZEDLMSG = &STR(ENTER A MATCHING \"CC\" TO COMPLETE +\n                            THE BLOCK COMMAND PAIR)\n        END\n      END\n    ELSE IF &RCC = 8 THEN DO\n      SET &ZEDSMSG = &STR(NOT ACCEPTABLE)\n      SET &ZEDLMSG = &STR(AN UNACCEPTABLE TARGET RANGE OF LINES +\n                          HAS BEEN SPECIFIED)\n      END\n    ELSE DO\n      SET &ZEDSMSG = &STR(SEVERE ERROR)\n      SET &ZEDLMSG = &STR(SEVERE ERROR OCCURED, RETURN CODES ARE +\n                          &LCC AND &RCC)\n      END\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n    END\n  ISREDIT (FR) = LINENUM .ZFRANGE\n  ISREDIT (LR) = LINENUM .ZLRANGE\n  ISREDIT (LB,RB) = BOUNDS\n  SET BL = &RB - &LB + 1\n  SET I = &FR\n  DO WHILE &I <= &LR\n    ISREDIT (LN) = LINE &I\n    SET L = &LENGTH(&SUBSTR(&LB:&RB,&NRSTR(&LN)))\n    SET S = &LB\n    DO WHILE &S < &L\n      IF &SUBSTR(&S:&S,&NRSTR(&LN)) \u00ac= &STR( ) THEN GOTO FOUNDS\n      SET S = &S + 1\n      END\nFOUNDS: +\n    SET E = &L\n    DO WHILE &E > &S\n      IF &SUBSTR(&E:&E,&NRSTR(&LN)) \u00ac= &STR( ) THEN GOTO FOUNDE\n      SET E = &E - 1\n      END\nFOUNDE: +\n    SET LINE = &SUBSTR(&S:&E,&NRSTR(&LN))\n    SET L = &LENGTH(&NRSTR(&LINE))\n    SET D = &BL - &L\n    IF &D > 1 THEN DO\n      SET H = &D\n      SET LINE2 = &SUBSTR(1:&H,&STR(                                   -\n                                                                       )\n      IF &LB = 1 THEN SET LINE = &NRSTR(&LINE2.&LINE)\n      ELSE SET LINE = &SUBSTR(1:&LB-1,&NRSTR(&LN))&NRSTR(&LINE2.&LINE)\n      END\n    ISREDIT LINE &I = (LINE)\n    SET I = &I + 1\n    END\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RJUST@": {"ttr": 33297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11X\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:58:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "1   19/09/89\n                                                      RJUST     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     RJUST ISPF/PDF EDIT command     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to right justify text within\n  ----------   data line(s).\n\n  Command syntax : RJUST\n  ---------------- RJUST HELP or H\n\n  Use :        Type RJUST on the COMMAND line and mark the range of\n  -----        lines text with the \"C\" range command on the line\n               numbers, as i.e. :\n               COMMAND ===> RJUST\n          ---> CC 500               ... DATA LINE ...\n               000600               ... DATA LINE ...\n          ---> CC 700               ... DATA LINE ...\n               000800               ... DATA LINE ...\n               Result : the text of lines numbered 500, 600 and 700\n                        will be right justified. Identical process is\n                        obtained with :\n          ---> C3 500               ... DATA LINE ...\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RPROT": {"ttr": 33537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07O\\x00\\x95\\x07O\\x17&\\x01e\\x01e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-15T00:00:00", "modifydate": "1995-03-15T17:26:00", "lines": 357, "newlines": 357, "modlines": 0, "user": "SYSPAJA"}, "text": "RPRT     TITLE '--- RPROT - DISPLAY RACF PROFILES FOR DATA-SETS ---'\nRPROT    START 0\n         SPACE 1\n*---------------------------------------------------------------------*\n* PROGRAM :    RPROT (ORIGINALLY RACFPROT)                            *\n* FUNCTION :   TSO COMMAND PROCESSOR THAT WILL ACCEPT CATALOG NODES   *\n*              AS INPUT AND RETURN DATA-SET NAMES UNDER THOSE NODES   *\n*              AND THE RACF PROFILES THAT PROTECT THEM VIA THE        *\n*              PUTLINE MACRO.                                         *\n* ATTRIBUTES : REENTRANT, AC=1                                        *\n* EXIT CODES :  0 - SUCCESSFUL                                        *\n*               4 - NODE(S) NOT FOUND                                 *\n*               8 - ERROR IN PARSE                                    *\n*              12 - WORK-AREA TOO SMALL                               *\n*              16 - RACHECK ERROR                                     *\n*              20 - TSO COMMAND ERROR                                 *\n* SYNTAX :     RPROT CATALOG.NODES OPTION(NOHEAD)                     *\n*              NOTE - YOU MAY SPECIFY ALL NODES EXCEPT FOR LAST ONE   *\n*                     (I.E., YOU MAY SPECIFY PROJECT.GROUP AND YOU    *\n*                     MAY NOT ASK FOR PROJECT.GROUP.TYPE).            *\n* NOTE :       DURING ASSEMBLY YOU MAY RECEIVE A LEVEL 4 MNOTE FROM   *\n*              THE RACHECK MACRO. THIS IS BECAUSE OF THE 'PRIVATE'    *\n*              KEYWORD ON THE ENTITY STATEMENT AND CAN BE IGNORED.    *\n* AUTHOR :     STUART SABEL (12/23/88)                                *\n*              ADAPTED BY : MOINIL P.A.                               *\n*                           COMPUTING CENTRE (TP 361)                 *\n*                           J.R.C. - ISPRA ESTABLISHMENT              *\n*                           21020 ISPRA (VA), ITALY                   *\n* ORIGIN :     EXTRACTED FROM CBT 94 AUG TAPE, FILE 7.                *\n*---------------------------------------------------------------------*\n         SPACE 1\nKBYTES   EQU   1024                   1K-BYTES\nLWASZ    EQU   (64*KBYTES)-8          LOCATES WORK-AREA SIZE\n*                                     (64K IS THE MAXIMUM ALLOWABLE)\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12,LV=PWALEN,TYPE=RENT\n         LR    R10,R13\n         USING PWA,R10\n         XR    R3,R3\n        $TEW$EC MSG=PUTMSG,ERR=TSOERR,PUT=PUTLNE\n        $TEW$PP PARM=PARSBS,REG=R9,ERR=PARSERR\n         SPACE 1\n*------- LOOK AT RESULTS FROM PARSE\n         SPACE 1\n         TM    CTLND+6,X'80'       PARAMETER PRESENT?\n         BO    GETIT               YES\n         L     R14,#TSCPPL         NO, GET CURRENT USER PREFIX\n         USING CPPL,R14\n         L     R15,CPPLUPT\n         DROP  R14\n         USING UPT,R15\n         LA    R1,UPTPREFX         GET THE DSNAME PREFIX ADDRESS\n         XR    R2,R2\n         IC    R2,UPTPREFL         GET THE DSNAME PREFIX LENGTH\n         DROP  R15\n         B     MOVEIT\nGETIT    L     R1,CTLND            GET THE CATALOG.NODE(S) ADDRESS\n         LH    R2,CTLND+4          GET THE CATALOG.NODE(S) LENGTH\nMOVEIT   MVI   LOCNME,C' '         INITIALIZE THE LOCATE AREA\n         MVC   LOCNME+1(L'LOCNME-1),LOCNME\n         BCT   R2,*+L'*+6          SUBTRACT ONE FOR MOVE\n         MVC   LOCNME(*-*),0(R1)   <<EXECUTED>>\n         EX    R2,*-6              MOVE IN THE CATALOG.NODE(S)\n         MVI   SWITCH,0\n         CLI   OPTHD+1,2           NO HEADINGS WANTED?\n         BNE   *+L'*+4             NO, SO DISPLAY HEADINGS\n         OI    SWITCH,NOHDNG       YES, THEN DON'T DISPLAY HEADINGS\n         DROP  R9\n        IKJRLSA #TSANSW            RELEASE THE PDL STORAGE\n         SPACE 1\n*------- SET UP IKJEHCIR PARAMETER LIST\n         SPACE 1\n         MVI   CIROPT,X'06'        OPT = LOCATE ALL NAMES AND VOLUMES\n         XC    CIRRS1,CIRRS1       CLEAR PARM LIST\n         MVI   CIRLOCRC,0          CLEAR LOCATE RETURN CODE\n         LA    R0,LOCNME           SET SEARCH ARGUMENT\n         ST    R0,CIRSRCH\n         XC    CIRCVOL,CIRCVOL     CLEAR PARM LIST\n         L     R4,=A(LWASZ)        WORK-AREA SIZE FOR LOCATES\n        GETMAIN RU,LV=(R4),BNDRY=PAGE GET ON PAGE WORTH\n         ST    R1,CIRWA            USER WORK-AREA ADDRESS\n         LR    R3,R1               SET ADDRESSABILITY\n         LA    R0,REGSAVE          SET SAVE AREA ADDRESS\n         ST    R0,CIRSAVE\n         XC    CIRPSWD,CIRPSWD     CLEAR PARM LIST\n         LR    R0,R3               CLEAR HEADER ETC... (ALL)\n         LR    R1,R4\n         LR    R14,R0\n         XR    R15,R15\n         MVCL  R0,R14\n         USING DSNLST,R3           ADDRESSABILITY\n         STCM  R4,B'0011',DSNBLEN  SET LENGTH INTO LIST\n         SPACE 1\n*------- CALL IKJEHCIR TO DO THE CATALOG LOCATE\n         SPACE 1\n         LA    R1,CIRPARM          POINT TO PARAMETER LIST\n        CALLTSSR EP=IKJEHCIR,MF=(E,(R1)) CALL IT\n         LTR   R15,R15             CHECK IF SUCCESSFUL\n         BNZ   CATERR              NO, GO ISSUE AN ERROR MESSAGE\n         SPACE 1\n*------ LOOP THROUGH THE DATA-SET NAMES AND VOLUMES\n*              (ISSUE A PUTLINE FOR EACH ONE)\n         SPACE 1\n         XR    R5,R5\n         ICM   R5,B'0011',DSNBUSL  GET LENGTH OF RETURNED DATA\n         LA    R5,DSNBLEN(R5)      SUBTRACT OUT FIRST WORD\n         LA    R6,DSNBSDT          POINT TO FIRST ENTRY\n         DROP  R3\n         USING SDTLST,R6           WORK ADDRESSABILITY\n         TM    SWITCH,NOHDNG       NO HEADINGS WANTED?\n         BO    NLOOP               YES, THEN DON'T DISPLAY HEADINGS\n         LA    R0,L'HEAD1          FIRST HEADING\n         LA    R1,HEAD1\n         BAS   R14,PUTLNE\n         LA    R0,L'HEAD2          SECOND HEADING\n         LA    R1,HEAD2\n         BAS   R14,PUTLNE\nNLOOP    MVC   DSNNME,DTNAME       COPY DATA-SET NAME\n         DROP  R6\n         XR    R4,R4\n         IC    R4,SDTLEN(R6)       GET THE NUMBER OF VOLUME ENTRIES\n         LA    R6,SDTLEN+1(R6)     VOLUME ENTRIES START POINT\n         LR    R7,R6               RETAIN IT FOR EVENTUAL CHECK\n         MVI   LINE,C' '           BLANK OUT OUTPUT LINE\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LCNT,LINE           BLANK OUT OUTPUT LINE CONTINUATION\n         MVC   PRFNME(L'PRFNME),LINE BLANK OUT PROFILE NAME\n         MVC   LINE+1(L'DSNNME),DSNNME SET DATA-SET NAME IN LINE\n         LA    R1,LINE+L'DSNNME\n         LA    R0,L'DSNNME/2\nFILLDS   BCTR  R1,0\n         CLC   0(2,R1),=CL2' '\n         BNE   *+L'*+10\n         MVI   1(R1),C'.'\n         BCTR  R1,0\n         BCT   R0,FILLDS\n         MVI   LINE+L'DSNNME+2,C'/'\n         MVI   LINE+L'DSNNME+L'VOLNME+5,C':'\n         LTR   R4,R4\n         BNZ   VLOOP\n         MVC   LINE+L'DSNNME+4(17),=CL17'??? NO VOLUME ???'\n         LA    R0,L'LINE\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     SKIPN\n         USING VOLLST,R6\nVLOOP    MVC   PWARCHK(LENRCHK),STCRCHK MOVE IN RACHECK LIST\n         LA    R1,PWARCHK          ADDRESS OF RACHECK MF=L\n         USING ACHKLIST,R1         RACHECK PARM LIST MAP\n         OI    ACHKFLG3,ACHKPRI    SET 'PRIVATE' BIT\n         DROP  R1                  NO MORE BASE\n         MVC   VOLNME,VOLSRN       VOLSER FOR RACHECK\n         MVC   LINE+L'DSNNME+4(L'VOLNME),VOLNME\n        MODESET KEY=ZERO           BECOME A MINOR DEITY\n        RACHECK ENTITY=(DSNNME),VOLSER=VOLNME,MF=(E,PWARCHK)\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    GOTPROF             GOOD IF ZERO, PROFILE EXIST\n         CH    R15,=H'4'           PROFILE NOT FOUND?\n         BNE   *+L'*+10            NO\n         MVC   PRFNME(19),=CL19'*** UNPROTECTED ***'\n         B     FSP229              GO FREEMAIN SP229\n         CH    R15,=H'8'           NOT AUTHORIZED?\n         BNE   RACFERR             NO, SEVERE ERROR\n         USING RRPF,R1             RETURNED AREA ADDRESSABILITY\n         CLI   DSPDSNM,0           IS THERE A PROFILE NAME?\n         BNE   GOTPROF             YES, TELL 'EM ANYWAY\n         MVC   PRFNME(18),=CL18'*** NO PROFILE ***'\n         B     FSP229              GO FREEMAIN SP229\n         USING RRPF,R1             RETURNED AREA ADDRESSABILITY\nGOTPROF  MVC   PRFNME,DSPDSNM      COPY PROFILE NAME\nFSP229   LTR   R1,R1               RETURNED AREA?\n         BZ    USBACK              NO\n         XR    R2,R2\n         ICM   R2,B'0111',RRPLEN   COPY SP229 LENGTH\n         DROP  R1\n        FREEMAIN R,LV=(R2),A=(R1),SP=229 FREE SP 229 FROM RACHECK\nUSBACK  MODESET KEY=NZERO          BECOME A PEASANT AGAIN\n         LA    R2,L'PRFNME         SET PROFILE NAME IN LINE\n         LA    R1,PRFNME+L'PRFNME-1\n         CLI   0(R1),C' '\n         BNE   *+L'*+6\n         BCTR  R1,0\n         BCT   R2,*-10\n         LTR   R2,R2\n         BP    *+L'*+10\n         MVC   LINE+L'DSNNME+L'VOLNME+7(12),=CL12'??? NONE ???'\n         B     SKIPL\n         LA    R0,LINE+L'LINE\n         SR    R0,R2\n         LA    R1,LINE+L'DSNNME+L'VOLNME+7\n         CLR   R0,R1\n         BNL   *+L'*+8\n         OI    SWITCH,LNECNT\n         B     SKIPL\n         BCT   R2,*+L'*+6\n         MVC   0(*-*,R1),PRFNME    <<EXECUTED>>\n         EX    R2,*-6\nSKIPL    LA    R0,L'LINE\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         TM    SWITCH,LNECNT\n         BO    SKIPC\n         MVC   LINE+L'DSNNME+L'VOLNME+7(L'LINE-L'DSNNME-L'VOLNME-7),LINX\n               E+L'DSNNME+L'VOLNME+6\n         B     SKIPT\nSKIPC    NI    SWITCH,255-LNECNT\n         LA    R1,LCNT+L'LCNT-1\n         SR    R1,R2\n         BCT   R2,*+L'*+6\n         MVC   0(*-*,R1),PRFNME    <<EXECUTED>>\n         EX    R2,*-6\n         LA    R0,L'LCNT\n         LA    R1,LCNT\n         BAS   R14,PUTLNE\n         MVI   LCNT,C' '           BLANK OUT OUTPUT LINE CONTINUATION\n         MVC   LCNT+1(L'LCNT-1),LCNT\nSKIPT    LA    R6,VOLLEN(R6)\n         BCT   R4,*+L'*+4\n         B     SKIPN\n         LR    R1,R7               CHECK TWICE (I.E. VSAM)\nCHKVOL   CLC   VOLSRN,VOLSRN-VOLLST(R1)\n         BE    SKIPT\n         LA    R1,VOLLEN(R1)\n         CLR   R1,R6\n         BL    CHKVOL\n         MVC   LINE+1(L'DSNNME),LINE\n         B     VLOOP\nSKIPN    CLR   R6,R5               REMAINING DATA?\n         BL    NLOOP               CONTINUE IF NOT DONE\n         DROP  R6\n         XR    R2,R2               NORMAL RETURN CODE\n         B     QUIT                RC=0 -------------------------------\nTSOERR   LA    R2,20               TSO COMMAND ERROR RETURN CODE\n         B     QUIT                RC=20 ------------------------------\nRACFERR  MVC   LINE(37),=CL37' => ERROR CONDITION IN RACHECK - RC ='\n         LA    R2,16               RACHECK ERROR RETURN CODE\n         LA    R0,49               RC=16 ------------------------------\n         LA    R1,LINE+37\n         B     SETRC\nTOOSMALL MVC   LINE(36),=CL36' => TOO MANY ENTRIES - IKJEHCIR RC ='\n         LA    R2,12               TOO SMALL ERROR RETURN CODE\n         LA    R0,48               RC=12 ------------------------------\n         LA    R1,LINE+36\n         B     SETRC\nPARSERR  LA    R2,8                PARSE ERROR RETURN CODE\n         B     QUIT                RC=8 -------------------------------\nCATERR   CLI   CIRLOCRC,40         WORK-AREA TOO SMALL\n         BE    TOOSMALL            YES\n         CLI   CIRLOCRC,44         OTHER WAY TO SAY TOO SMALL\n         BE    TOOSMALL            YES\n         MVC   LINE(45),=CL45' => CATALOG NODE(S) NOT FOUND - IKJEHCIR X\n               RC ='\n         LA    R2,4                NOT FOUND ERROR RETURN CODE\n         LA    R0,57               RC=4 -------------------------------\n         LA    R1,LINE+45\nSETRC    CVD   R15,PWADBL\n         MVC   0(6,R1),=XL6'402020202120'\n         ED    0(6,R1),PWADBL+L'PWADBL-3\n         MVI   6(R1),C'('\n         MVI   11(R1),C')'\n         STCM  R15,B'0010',8(R1)\n         STCM  R15,B'0001',10(R1)\n         SRL   R15,4\n         STCM  R15,B'0010',7(R1)\n         STCM  R15,B'0001',9(R1)\n         NC    7(4,R1),=XL4'0F0F0F0F'\n         TR    7(4,R1),=CL16'0123456789ABCDEF'\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         SPACE 1\n*------- FREE GETMAINED STORAGE AND RETURN CONTROL TO THE TMP\n         SPACE 1\nQUIT     LTR   R1,R3                  STORAGE ADDRESS FOR IKJEHCIR\n         BZ    LEAVE                  NONE\n         L     R4,=A(LWASZ)           WORK-AREA SIZE FOR LOCATES\n        FREEMAIN RU,LV=(R4),A=(R1)    FREE IKJEHCIR WORK-AREA\nLEAVE   $XRET  CC=(R2),LV=PWALEN,TYPE=RENT\n         EJECT\n*------- CONSTANTS AND SKELETONS\n         SPACE 1\nSTCRCHK RACHECK ENTITY=*-*,CLASS='DATASET',LOG=NOSTAT,RACFIND=YES,     X\n               RELEASE=1.8,MF=L\nLENRCHK  EQU   *-STCRCHK           LENGTH OF RACHECK MACRO\nHEAD1    DC    C' CATALOGED DATA-SET NAME  . . . . . . . . . . / VOLUMEX\n                : RACF PROFILE PROTECT'\nHEAD2    DC    C' -----------------------------------------------------X\n               ------------------------'\n         SPACE 1\n        LTORG  ,\n         EJECT\n*------- IKJPARS MACROS\n         SPACE 1\n        PRINT  NOGEN\nPARSBS  IKJPARM\nCTLND   IKJPOSIT DSNAME,HELP='UNQUOTED CATALOG.NODE(S) FOR SEARCH'\nOPTKW   IKJKEYWD\n        IKJNAME 'OPTION',SUBFLD=OPTSF,ALIAS=('OPT','O')\nOPTSF   IKJSUBF\nOPTHD   IKJKEYWD DEFAULT='HEAD'\n        IKJNAME 'HEAD',ALIAS=('H','HD','HEADING')\n        IKJNAME 'NOHEAD',ALIAS=('N','NO','NOH','NOHD','NOHEADING')\n        IKJENDP\n        PRINT  GEN\n         SPACE 1\n*------- WORK-AREAS DESCRIPTION\n         SPACE 1\nPWA      DSECT\n         DS    18F                 STANDARD SAVE AREA\nREGSAVE  DS    16F                 REGISTER SAVE AREA\nPWADBL   DS    D\n        $TEW$WA\nCIRPARM  DS    0F                  CATALOG INFORMATION PRAM.LIST\nCIROPT   DS    XL1                 LOCATE OPTION - LOCATE ALL NAMES\nCIRRS1   DS    XL2                 RESERVED\nCIRLOCRC DS    XL1                 CATALOG RETURN CODE\nCIRSRCH  DS    A                   CATALOG SEARCH ARGUMENT ADDRESS\nCIRCVOL  DS    A                   VOLSER OF CVOL ADDRESS\nCIRWA    DS    A                   USER WORK-AREA ADDRESS\nCIRSAVE  DS    A                   SAVE AREA ADDRESS\nCIRPSWD  DS    A                   PASSWORD ADDRESS\nPWARCHK  DS    0F,CL(LENRCHK)      RACHECK PARMS\nLOCNME   DS    CL44                CATALOG.NODE(S) FROM COMMAND LINE\nDSNNME   DS    CL44                RETURNED DATA-SET NAME\nPRFNME   DS    CL44                RETURNED PROFILE NAME\nVOLNME   DS    CL6                 VOLUME SERIAL NUMBER\nLINE     DS    CL78                OUTPUT LINE\nLCNT     DS    CL78                OUTPUT LINE CONTINUATION\nSWITCH   DS    XL1                 SWITCHES BYTE\nNOHDNG   EQU   X'80'               NOHEADING REQUESTED\nLNECNT   EQU   X'01'               LINE CONTINUATION TO BE DONE\nPWALEN   EQU   (((*-PWA)+7)/8)*8\n         SPACE 1\nDSNLST   DSECT\nDSNBLEN  DS    H                   LENGTH OF THIS BLOCK\nDSNBUSL  DS    H                   LENGTH OF BLOCK USED\nDSNBSDT  DS    C                   START OF DATA-SET(S) LIST\n         SPACE 1\nSDTLST   DSECT\nDTTYPE   DS    CL1                 DATA-SET TYPE\nDTNAME   DS    CL44                RETURNED DATA-SET NAME\nSDTLEN   EQU   *-SDTLST            LENGTH OF DATA-SET ENTRIES\n         SPACE 1\nVOLLST   DSECT\nVOLDVT   DS    XL4                 DEVICE TYPE\nVOLSRN   DS    CL6                 VOLUME SERIAL NUMBER\nVOLFSN   DS    H                   FILE SEQUENCE NUMBER\nVOLLEN   EQU   *-VOLLST            LENGTH OF VOLUME ENTRIES\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS\n        IKJUPT\n        ICHRRPF ,                  RACF RESIDENT PROFILE MAP\n        ICHACHKL ,                 RACHECK PARM LIST MAP\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RPROT$": {"ttr": 33544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)?\\x00\\x94)?\\x15\\x14\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-20T00:00:00", "modifydate": "1994-10-20T15:14:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//RPROT    JOB (........),'INSTALL  - RPROT -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=RPROT\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT,AC=1'\n//SYSIN     DD *\n  ENTRY   RPROT\n  NAME    RPROT(R)\n/*\n//HLP     EXEC PAJHELP,MBR=RPROTH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RPROT@": {"ttr": 33546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x940\\x0f\\x00\\x940\\x0f\\x17\\x04\\x00$\\x00$\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-27T00:00:00", "modifydate": "1994-10-27T17:04:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SYSPAJA"}, "text": "1   20/10/94\n                                                      RPROT     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     RACF PROTECTION TSO command     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   TSO command processor that will accept catalog nodes\n  ----------   as input and return data-set names under those nodes\n               and the RACF profiles that protect them.\n\n  Command syntax : RPROT CATALOG.NODES OPTION(NOHEAD)\n  ---------------- Required : none.\n                   Default : CATALOG.NODES is set by default to the\n                                    user current DSNAME prefix, and\n                             OPTION is set to HEAD.\n\n  Operand :    CATALOG.NODES - you may specify all nodes except for\n  ---------                    the last one (i.e. : you may specify\n                               PROJECT.GROUP and you may not ask for\n                               PROJECT.GROUP.TYPE).\n               OPTION - heading lines process option.\n                               Aliases : O and OPT.\n                        HEAD : output the heading lines (default).\n                               Aliases : H, HD and HEADING.\n                        NOHEAD : suppress the heading lines.\n                               Aliases : N, NO, NOH, NOHD and NOHEADING.\n\n  Exit codes :  0 - successfull\n  ------------  4 - node(s) not found\n                8 - error in PARSE\n               12 - work-area too small\n               16 - RACHECK error\n               20 - TSO command error\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RPROTH": {"ttr": 33548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x940\\x0f\\x00\\x940\\x0f\\x17\\x04\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-27T00:00:00", "modifydate": "1994-10-27T17:04:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=RPROT\n./     NUMBER  NEW1=100,INCR=100\n)F Function : TSO command processor that will accept catalog nodes\n              as input and return data-set names under those nodes\n              and the RACF profiles that protect them.\n)X Syntax :   RPROT CATALOG.NODES OPTION(NOHEAD)\n              Required : none.\n              Default : CATALOG.NODES is set by default to the user\n                                      current DSNAME prefix, and\n                        OPTION is set to HEAD.\n)O Operand :  CATALOG.NODES - you may specify all nodes except for\n                              the last one (i.e. : you may specify\n                              PROJECT.GROUP and you may not ask for\n                              PROJECT.GROUP.TYPE).\n              OPTION - heading lines process option.\n                              Aliases : O and OPT.\n                       HEAD : output the heading lines (default).\n                              Aliases : H, HD and HEADING.\n                       NOHEAD : suppress the heading lines.\n                              Aliases : N, NO, NOH, NOHD and NOHEADING.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RSVENQ": {"ttr": 33550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12?\\x00\\x94\\x12?\\x15R\\x01n\\x01n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-03T00:00:00", "modifydate": "1994-05-03T15:52:00", "lines": 366, "newlines": 366, "modlines": 0, "user": "SYSPAJA"}, "text": "RENQ     TITLE 'TSO - DISPLAY RESOURCES ENQUE''S RESERVE COMMAND.'\nRSVENQ   START 0\n         SPACE 1\n* FUNCTION :   DISPLAY RESOURCES ENQUE'S RESERVE (TSO CP) ON SP1.3\n* ----------   SYSTEM.\n* COMMAND :    SYNTAX : RSVENQ\n* ---------    DEFAULT : NONE.\n* NOTES :    - THIS CODE HAS NOT BEEN TESTED WITH A GRS RING, AS\n* -------      SCOPE=GLOBAL WILL HAVE TO BE SPECIFIED ON THE GQSCAN\n*              MACRO AND THE GQSCAN HAS TO RUN AUTHORIZED KEY ZERO.\n*            - THE 'SYSNAME' IN IEASYS00 SHOULD SPECIFY YOUR SMFID\n*              TO GET THE CORRECT SYSTEM NAME IN THE 'SYSTEM' FIELD,\n*              OTHERWISE (NONA) NONAME WILL BE DISPLAYED.\n*            - FOR A SYSTEM WITH MANY RESOURCES IN USE, THE \"SCANAREA\"\n*              MIGHT HAVE TO BE MADE LARGER (THE CORRESPONDING FIELD\n*              ON THE \"AREA\" PARAMETER OF THE \"GQSCAN\" MACRO MUST BE\n*              CHANGED).\n*            - TOKEN HAS BEEN ADDED TO ALLOW SEARCHING OF LONG ENQUE\n*              CHAINS.\n* AUTHOR :     ORIGINAL VERSION FROM TSOENQ ON CBT TAPE (FILE 324).\n* --------     THIS IS A TSOENQ TSO-COMMAND VERSION RENAMED RSVENQ AND\n*              MODIFIED BY : MOINIL P.A.\n*                            COMPUTING CENTRE (TP 361)\n*                            J.R.C. - ISPRA ESTABLISHMENT\n*                            21020 ISPRA (VA), ITALY\n         SPACE 1\nLV0      EQU   0         AUTHORITY LEVEL DEFINITION = REJECT LEVEL.\n        $MDL@IX\n        $DEFREG\nSIAL     EQU   100*1024            SCAN INFO AREA LENGTH.\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R5,R13              SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R5\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n         XC    REQAUT(REQAUTL),REQAUT\n         MVC   REQAUT+1(3),=AL3(MDL@IX)\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n        $EACM  REQAUT\n         CLI   AUTH,LV0            AUTHORIZED?\n         BE    NOTAUT              NO, NOT AUTHORIZED.\n         SPACE 1\n         MVC   LINE,BLANK\n         L     R3,CVTPTR           GET ADDRESS OF CVT.\n         USING CVT,R3\n         L     R4,CVTSMCA\n         DROP  R3\n         USING SMCABASE,R4         SET ADDRESSABILITY.\n         MVC   LINE(28),=CL28'RESOURCES RESERVES DISPLAY ('\n         MVC   LINE+28(4),SMCASID  MOVE SYSTEM ID.\n         MVC   CURSYS(4),SMCASID\n         DROP  R4\n         MVI   LINE+33,C'-'\n        TIME  DEC                  R0 : HHMMSSTH\n         STM   R0,R1,WORKD         TIME - DATE\n         UNPK  LINE+44(7),WORKD(4)\n         MVC   LINE+50(2),LINE+48  XXSS\n         MVC   LINE+48(1),LINE+47  MXSS\n         MVC   LINE+47(1),LINE+46  HHXM MXSS\n         MVI   LINE+46,C'.'\n         MVI   LINE+49,C'.'        HH.MM.SS\n         UNPK  LINE+35(7),WORKD+4(4)\n         MVC   LINE+35(2),LINE+37  YY\n         MVC   LINE+38(3),LINE+39  DDD\n         MVI   LINE+37,C'.'        YY.DDDX\n         MVI   LINE+41,C' '        YY.DDD\n         MVI   LINE+42,C'-'\n         MVI   LINE+52,C')'\n        STLINENO LINE=1            VTAM CLEAR SCREEN.\n         LA    R0,L'LINE           TITLE AND TIME.\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         XC    TKN,TKN             ZERO OUT TOKEN AREA.\n         MVI   SWITCH,0            INITIALIZE SWITCHES.\nSTART    LA    R10,SCANAREA        ADDRESS OF RETURNED DATA.\n         LA    R13,SCANSAVE        ADDRESS GQSCAN SAVE AREA.\n         XC    0(18*4,R13),0(R13)\n         MVC   SCAN(LSCAN),SCANP\n        ZEROKEY ,\n        GQSCAN AREA=((R10),),TOKEN=TKN,MF=(E,SCAN)\n         LR    R13,R5              RESTORE MAIN SAVE AREA.\n         LR    R8,R0               SAVE RIB AND RIBE LENGTHS.\n         LR    R7,R1               SAVE NUMBER OF RIBS.\n         LR    R9,R15              SAVE RETURN CODE.\n        RESETKEY ,\n         B     *+L'*(R9)           HOW COMPLETE ?\n         B     CODE00              +0 - O.K.\n         B     CODE04              +4 - NO RESOURCES MATCHED REQUEST\n         B     CODE08              +8 - GQSCAN AREA TOO SHORT\n         B     CODE0C              +12 - ERROR WHILE PROCESSING\n         B     CODE10              +16 - INVALID SYSNAME\n         B     CODE14              +20 - GQSCAN AREA TOO SHORT\n         SPACE 1\nCODE04   LA    R0,L'CODE04M        NO RESOURCES.\n         LA    R1,CODE04M\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     RETURN              +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\nCODE08   OI    SWITCH,TKNSW        SET TOKEN SWITCH TO CONTINUE.\n         SPACE 1\nCODE00   STCM  R8,B'1111',RIBLNGTH STORE RIB AND RIBE LENGTH.\n         LTR   R7,R7               TEST NUMBER OF RIBS.\n         BZ    RETURN              NO RIB'S SUPPLIED.\n         LA    R6,LINE\n         USING RIB,R10             RESOURCE INFORMATION BLOCK.\nRIBLOOP  L     R9,RIBNRIBE         LOAD THE NO. OF RIBE'S.\n         LTR   R9,R9\n         BNP   BUMPRIB             NO RIBE'S SUPPLIED.\n         LR    R11,R10             GET RIB POINTER.\n         AH    R11,RIBLNGTH        POINT TO RIB VARIABLE SECTION.\n         USING RIBVAR,R11          RESOURCE INFORMATION BLOCK.\n         MVC   LINE,BLANK          CLEAR BEFORE USING.\n         USING RNMLINE,R6\n         MVC   RNMT,=CL16'RESOURCE NAME :'\n         MVC   QNM,RIBQNAME        MOVE QNAME TO PRINT LINE.\n         MVI   QRS,C'/'\n         XR    R1,R1\n         IC    R1,RIBRNMLN         RNAME LENGTH.\n         BCT   R1,*+L'*+6          MINUS ONE FOR EX INSTRUCTION.\n         MVC   RNM(*-*),RIBRNAME   <<EXECUTED>>\n         EX    R1,*-6              MOVE RNAME TO PRINT LINE.\n         DROP  R6,R11\n         AH    R11,RIBVLEN         POINT TO FIRST RIBE.\n         USING RIBE,R11            RESOURCE INFORMATION BLOCK EXT.\n         LR    R0,R9               SAVE IN CASE.\n         LR    R1,R11\n         TM    RIBERFLG,RIBERESV   ANY RESERVE REQUEST?\n         BO    *+L'*+12            BRANCH IF YES.\n         AH    R11,RIBELENG        POINT TO NEXT RIBE.\n         BCT   R9,*-12             DO IT FOR NEXT USER.\n         B     BUMPRIB             NO, BUMP TO NEXT RIB.\n         LR    R9,R0               RESTART FROM FIRST RIBE.\n         LR    R11,R1\n         LA    R0,L'BLANK          A BLANK LINE.\n         LA    R1,BLANK\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         LA    R0,L'LINE           PRINT RESOURCE NAME.\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         LA    R0,L'FLAGHD         PRINT FLAG HEADER.\n         LA    R1,FLAGHD\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         MVI   LINE,C'-'\n         MVC   LINE+1(L'FLAGHD-1),LINE\n         LA    R0,L'FLAGHD         UNDER LINE IT.\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     SEARCH              +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\nSEARCH   MVC   LINE,BLANK          CLEAR BEFORE USING.\n         OI    SWITCH,ENQSW        SET SWITCH THAT THERE WAS ENQ.\n         USING JOBLINE,R6\n         MVC   JOBNAME,RIBEJBNM    JOBNAME OF REQUESTOR.\n         MVC   SYSTEM(4),RIBESYSN  SYSTEM NAME OF REQUESTOR.\n         TM    RIBERFLG,RIBETYPE   IS THIS EXCLUSIVE OR SHARED?\n         BO    *+L'*+10            BRANCH IF SHARED.\n         MVC   EXCLFLAG,=CL4'EXCL' NO, EXCLUSIVE.\n         B     *+L'*+6\n         MVC   EXCLFLAG,=CL4'SHR'\n         TM    RIBERFLG,RIBEMC     IS MUST COMPLETE?\n         BO    *+L'*+8             BRANCH IF YES.\n         MVI   MCFLAG,C'N'\n         B     *+L'*+4\n         MVI   MCFLAG,C'Y'\n         TM    RIBERFLG,RIBERESV   IS THIS RESERVE REQUEST?\n         BO    *+L'*+8             BRANCH IF YES.\n         MVI   RESVFLAG,C'N'\n         B     *+L'*+4\n         MVI   RESVFLAG,C'Y'\n         TM    RIBERFLG,RIBERESC   IS THIS RESERVE REQUEST GLOBAL?\n         BO    *+L'*+8             BRANCH IF YES.\n         MVI   GLOBFLAG,C'N'\n         B     *+L'*+4\n         MVI   GLOBFLAG,C'Y'\n         TM    RIBESFLG,RIBESTAT   IS THIS GUY THE OWNER?\n         BO    *+L'*+14            BRANCH IF YES.\n         MVI   OWNFLAG,C'N'\n         MVC   WAITFLAG,=CL3'*W*'  TELL USER WAITING DATA-SET.\n         B     *+L'*+4\n         MVI   OWNFLAG,C'Y'\n         CLC   CURSYS(4),RIBESYSN  CURRENT SYSTEM NAME?\n         BNE   OTHER               BRANCH IF NOT.\n         L     R1,RIBEUCB          GET UCB ADDRESS.\n         LTR   R1,R1               IS UCB ADDRESS TRUE?\n         BZ    TOUTIT              BRANCH IF NOT.\n         USING UCBDSECT,R1\n         MVC   CUA,UCBNAME         SET UCB NAME.\n         MVC   UNAME,UCBVOLI       SET VOLUME SERIAL NUMBER.\n         DROP  R1\n         B     TOUTIT\nOTHER    MVC   CUA+1(4),=C'--->'   OTHER SYSTEM (BYPASS A 0C4).\n         MVC   CUA+6(4),RIBESYSN\n         DROP  R6,R11\nTOUTIT   LA    R0,L'LINE           PRINT IT.\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         AH    R11,RIBELENG        POINT TO NEXT RIBE.\n         BCT   R9,SEARCH           DO IT FOR NEXT USER.\nBUMPRIB  XR    R3,R3\n         L     R4,RIBNRIBE         NUMBER OF RIBE'S.\n         LTR   R4,R4\n         BNP   *+L'*+8             NO RIBE'S SUPPLIED.\n         AH    R3,RIBELENG         ADD RIBE LENGTH.\n         BCT   R4,*-4              ADD TIMES NO. OF RIBE'S.\n         AH    R3,RIBLNGTH         ADD LENGTH OF RIB.\n         AH    R3,RIBVLEN          ADD LENGTH OF VARIABLE SECTION.\n         AR    R10,R3              POINT TO NEXT RIB.\n         BCT   R7,RIBLOOP          LOOP UNTIL NO MORE RIBS.\n         DROP  R10\nRETURN   TM    SWITCH,TKNSW        IS THERE MORE DATA?\n         BZ    *+L'*+8             NO\n         NI    SWITCH,255-TKNSW    YES\n         B     START               GO CONTINUE PROCESSING.\n         TM    SWITCH,ENQSW        WAS THERE AN ENQ?\n         BO    LEAVE               YES, EXIT.\n         LA    R0,L'BLANK          NO, A BLANK LINE.\n         LA    R1,BLANK\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         LA    R0,L'NOENQ          TELL USER.\n         LA    R1,NOENQ\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     LEAVE               +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         DROP  R5\nLEAVE    XR    R15,R15             RC = 0 -----------------------------\nQUIT    $XRET  CC=(R15),LV=WRKL,TYPE=RENT\nNOTAUT   LA    R0,L'NAUTM          UNAUTHORIZED COMMAND.\n         LA    R1,NAUTM\n         B     FINISH\nCODE0C   LA    R0,L'CODE0CM        ERROR IN GQSCAN.\n         LA    R1,CODE0CM\n         B     FINISH\nCODE10   LA    R0,L'CODE10M        INVALID SYSNAME.\n         LA    R1,CODE10M\n         B     FINISH\nCODE14   LA    R0,L'CODE14M        GQSCAN AREA TOO SHORT.\n         LA    R1,CODE14M\nFINISH   BAS   R14,PUTLNE\nSETRC    LA    R15,16              RC = 16 ----------------------------\n         B     QUIT\n         EJECT\n*------- SKELETONS, CONSTANTS AND MESSAGES\n         SPACE 1\n         PRINT NOGEN\nSCANP   GQSCAN AREA=(,SIAL),REQLIM=MAX,SCOPE=ALL,RESERVE=YES,MF=L\n         PRINT GEN\nLSCAN    EQU   *-SCANP\n         SPACE 1\nFLAGHD   DS    0CL55               FLAG HEADER.\n         DC    CL14'JOBNAME/USERID'\n         DC    CL2' '\n         DC    CL4'DISP'\n         DC    CL2' '\n         DC    CL4'SYS.'\n         DC    CL2' '\n         DC    CL2'MC'\n         DC    CL2' '\n         DC    CL2'RS'\n         DC    CL2' '\n         DC    CL2'GL'\n         DC    CL2' '\n         DC    CL2'OW'\n         DC    CL2' '\n         DC    CL3'CUA'\n         DC    CL2' '\n         DC    CL6'VOLSER'\n         SPACE 1\nNAUTM    DC    C' -> UNAUTHORIZED COMMAND.'\nCODE04M  DC    C' -> GQSCAN : NO RESOURCES ENQUEUED'\nCODE0CM  DC    C' -> GQSCAN : ERROR WHILE PROCESSING'\nCODE10M  DC    C' -> GQSCAN : \"SYSNAME\" IS INVALID'\nCODE14M  DC    C' -> GQSCAN : \"AREA\" TOO SHORT'\nNOENQ    DC    C'NO RESOURCES ENQUE''S RESERVE EXIST.'\nBLANK    DC    CL72' '\n         SPACE 1\n        LTORG\n         EJECT\n*------- WORK-AREAS DESCRIPTTIONS\n         SPACE 1\nRNMLINE  DSECT                     RESOURCE NAME LINE DESCRIPTION.\nRNMT     DC    CL16'RESOURCE NAME :'\nQNM      DS    CL8\n         DC    CL1' '\nQRS      DC    CL1'/'\n         DC    CL1' '\nRNM      DS    CL44\n         SPACE 1\nJOBLINE  DSECT                     INFO LINE DESCRIPTION.\nJOBNAME  DS    CL8\n         DC    C' '\nWAITFLAG DS    CL3\n         DC    CL2' '\n         DC    CL2' '\nEXCLFLAG DS    CL4\n         DC    CL2' '\nSYSTEM   DS    CL4\n         DC    CL2' '\n         DC    CL1' '\nMCFLAG   DS    CL1\n         DC    CL2' '\n         DC    CL1' '\nRESVFLAG DS    CL1\n         DC    CL2' '\n         DC    CL1' '\nGLOBFLAG DS    CL1\n         DC    CL2' '\n         DC    CL1' '\nOWNFLAG  DS    CL1\n         DC    CL2' '\nCUA      DS    CL3\n         DC    CL2' '\nUNAME    DS    CL6\n         DC    CL17' '\n         EJECT\nWRKDSECT DSECT                     WORK AREAS DESCRIPTIONS.\nSVA      DS    18F                 SAVE AREA.\nSCANSAVE DS    18F                 18 WORDS SAVE AREA REQ FOR GQSCAN.\nWORKD    DS    D\n        $TEW$WA\nSCAN     DS    0F,(LSCAN)X\nTKN      DS    F                   TOKEN AREA ADDRESS.\nRIBLNGTH DC    H'0'                RIB LENGTH.\nRIBELENG DC    H'0'                RIBE LENGTH.\nCURSYS   DS    CL4                 CURRENT SYSTEM ID.\nLINE     DS    CL72                TERMINAL LINE WORK AREA.\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)\nAUTH     DC    XL1'0'\nREQAUTL  EQU   *-REQAUT\nSWITCH   DS    XL1                 ENQ/TOKEN SWITCHES.\nTKNSW    EQU   X'01'                - TOKEN SWITCH.\nENQSW    EQU   X'02'                - ENQ SWITCH.\nSCANAREA DS    0F,(SIAL)X          SCAN INFO AREA.\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         SPACE 1\n        PRINT NOGEN\n       $TEW$DS CVT=YES\n        IEESMCA\n        ISGRIB\nUCBDSECT DSECT\n        IEFUCBOB\n        PRINT GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RSVENQ$": {"ttr": 33798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "//RSVENQ   JOB (........),'INSTALL  -RSVENQ-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=RSVENQ\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  NAME    RSVENQ(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RSVENQ@": {"ttr": 33800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      RSVENQ    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *  DISPLAY RESOURCE ENQUE'S RESERVE.  * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Display resources ENQUE's RESERVE (TSO CP) on SP1.3\n  ---------    System.\n\n  Command :    Syntax : RSVENQ\n  ---------\n               Default : none.\n\n  Authority :  all the system group USER-id's are fully authorized to\n  -----------  issue this command, and only operator group USER-id's\n               with the OPER or ACCT attributes are also allowed to\n               issue it.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RTIME": {"ttr": 33802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x884/\\x00\\x884/\\x12D\\x00\\x85\\x00\\x85\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-07T00:00:00", "modifydate": "1988-12-07T12:44:00", "lines": 133, "newlines": 133, "modlines": 0, "user": "SYSPAJA"}, "text": "RTM      TITLE 'GET REMAINING CPU - SRB TIME SUBROUTINE.'\nRTIME    START 0\n         SPACE 1\nRTIME   AMODE  ANY\nRTIME   RMODE  ANY\n         SPACE 1\n         EJECT\n* CALLING SEQUENCE : CALL RTIME,(A,B),VL\n* ------------------            (A)\n*\n*        WHERE : A AND OPTIONALLY B ARE THE ADDRESSES OF FULLWORDS\n*                (F BOUNDARY) RECEIVING CPU - SRB REMAINING TIMES.\n*\n* REMARK :     ALL TIMES ARE IN SECONDS.\n* --------     ONE SECOND OF SRB TIME ALLOWS ABOUT 1000 I/O, IT\n*              MAY BE MORE THAN 1000 (TILL 3000), RARELY LESS FOR\n*              AN AMDAHL V8 IN MVS SP1.3 UNDER VM/SP.\n*\n* HOW TO USE :\n* ------------\n*\n*        IF A AND B ARGUMENTS ARE SUPPLIED, YOU GET REMAINING CPU TIME\n*              IN A AND REMAINING SRB TIME IN B (1 DAY = 86400 SECS).\n*              IF NO TCB (CPU) TIMING, TCB TIME LEFT = 1000000 SECS.\n*              IF NO SRB TIMING, SRB TIME LEFT = 2000000 SECS.\n*\n*        IF A ARGUMENT ONLY, YOU GET REMAINING CPU+SRB TIME.\n*        IN THIS SITUATION, FROM THE SUM YOU CAN DETERMINE IF\n*        THERE IS TCB OR SRB TIMING AS BELOW :\n*              3,0 MILLION = NO SRB, NO TCB TIMING.\n*              2,X MILLION = NO SRB, YES TCB TIMING.\n*              1,X MILLION = NO TCB, YES SRB TIMING.\n*              0,X MILLION = YES TCB, YES SRB TIMING, YOU HAVE THE SUM.\n*\n* SRB-TIME CONTROL AND INSTALLATION DEPENDENCY :\n* ----------------------------------------------\n*\n*        WE HAVE APPLY A ZAP IN THE NUCLEUS IN ORDER TO CHECK IF THE\n*        SRB-TIME LIMIT EXPIRES, AND IF SO SCHEDULES THE IEFUTL SMF\n*        TIME LIMIT EXIT. TO DO THIS CONTROL WE USE A WORD IN THE ASCB\n*        FOR SRB-TIME LIMIT VALUE, WHICH IS GIVEN BY THE USERS JCL\n*        USING THE TIME PARAMETER OF THE /*JOBPARM CARD OF JES2.\n*        THIS SRB-TIME LIMIT REQUEST IS VALIDATED BY THE IEFUJV\n*        SMF JOB VALIDATION EXIT AND PASSED TO THE IEFUJI SMF JOB\n*        INITIATION EXIT (THROUGH THE USER-COMMUNICATION FIELD OF THE\n*        COMMON EXIT PARAMETER AREA) IN ORDER TO INITIALIZE WITH IT\n*        THE WORD IN THE ASCB AT JOB STARTING EXECUTION TIME.\n*        THE IEFUTL SMF TIME LIMIT EXIT, WHEN RECEIVING CONTROL, WILL\n*        ISSUE AN APPROPRIATE MESSAGE TO SIGNAL THE USER ABOUT WHICH\n*        ONE OF CPU OR SRB TIME HAS EXPIRED.\n*\n* AUTHOR :     COLOMBO A. (AMDAHL CONSULTANT)\n* --------     MOINIL P.A.\n*              COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12\n         EJECT\n*        GET VALUES FROM ASCB.\n         SPACE 1\n         LR    R6,R1               SAVE REGISTER 1 ON ENTRY\n        $TREQ  R=CL                GET STEP TIME LIMIT.\n         LTR   R4,R0               IF ZERO, NO TCB TIMING.\n         BNZ   PUTTCB              NO TCB TIMING.\n         MVC   CPULIMIT,ONEMIL     ONE MILLION.\n         MVC   CPUUSED,AZERO       TO GET AGAIN A MILLION.\n         B     SEESRB              TO SEE WHAT ABOUT SRB TIME.\nPUTTCB   XR    R5,R5               TO ZERO.\n         SRDL  R4,12               TO GET MICROSEC IN BIT 63.\n         STM   R4,R5,CPULIMIT      CPU TIME LIMIT FOR THIS STEP.\n         MVI   CPULIMIT,X'4E'      BETTER WITH AN EXPONENT.\n        $TREQ  R=CU                CPU TIME USED IN THIS STEP.\n         SRDL  R0,12               TO GET MICROSEC IN BIT 63.\n         STM   R0,R1,CPUUSED       CPU TIME USED IN THIS STEP.\n         MVI   CPUUSED,X'4E'       BETTER WITH AN EXPONENT.\nSEESRB  $TREQ  R=SL                GET SRB TIME LIMIT.\n         LTR   R4,R0               IF ZERO, NO SRB TIMING.\n         BNZ   PUTSRB              NO SRB TIMING.\n         MVC   SRBLIMIT,TWOMIL     TWO MILLION.\n         MVC   SRBUSED,AZERO       TO GET AGAIN TWO MILLION.\n         B     COMPARE             TO SEE WHAT TIME LEFT.\nPUTSRB   XR    R5,R5               TO ZERO.\n         SRDL  R4,12               TO GET MICROSEC IN BIT 63.\n         STM   R4,R5,SRBLIMIT      SRB TIME LIMIT FOR THIS STEP.\n         MVI   SRBLIMIT,X'4E'      BETTER WITH AN EXPONENT.\n        $TREQ  R=SU                SRB TIME USED IN THIS STEP.\n         SRDL  R0,12               TO GET MICROSEC IN BIT 63.\n         STM   R0,R1,SRBUSED       SRB TIME USED IN THIS STEP.\n         MVI   SRBUSED,X'4E'       BETTER WITH AN EXPONENT.\n         EJECT\n*        COMPUTE REMAINING TCB - SRB TIME.\n         SPACE 1\nCOMPARE  STD   R0,FPR0SAVE         SAVE FLOATING POINT R0.\n         LD    R0,CPULIMIT         GET CPU TIME LIMIT.\n         SD    R0,CPUUSED          GET TIME USED TILL NOW.\n         STD   R0,CPULEFT          STORE RESULT IN A WORK AREA.\n         LD    R0,SRBLIMIT         GET SRB TIME LIMIT.\n         SD    R0,SRBUSED          GET THIS STEP TIME USED.\n         STD   R0,SRBLEFT          STORE RESULT IN A WORK AREA.\n         TM    0(R6),X'80'         IF ON, ONLY ONE PARAMETER.\n         BNO   TWO                 IF OFF, TWO PARAMETERS.\n         AD    R0,CPULEFT          SRB+CPU.\n         STD   R0,CPULEFT          SRB+CPU.\n         B     CPUSTORE            GO TO STORE SRB+CPU TIME.\nTWO      LD    R0,SRBLEFT          IN WORK REGISTER.\n         AW    R0,AZERO            NORMALIZE.\n         DD    R0,ONEMIL           TO GET SECONDS.\n         L     R2,4(R6)            GET ANSWER ADDRESS.\n         STE   R0,0(R2)            GIVE SRB RESULT.\nCPUSTORE LD    R0,CPULEFT          IN WORK REGISTER.\n         AW    R0,AZERO            NORMALIZE.\n         DD    R0,ONEMIL           TO GET SECONDS.\n         L     R2,0(R6)            GET ANSWER ADDRESS.\n         STE   R0,0(R2)            GIVE CPU RESULT.\nGOBACK   LD    R0,FPR0SAVE         RESTORE FPR0.\n        $XRET  CC=0                GO BACK.\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nFPR0SAVE DC    D'0'                SAVE AREA FOR FPR0.\nCPULIMIT DC    D'0'                TCB LIMIT FOR THIS STEP.\nSRBLIMIT DC    D'0'                SRB LIMIT FOR THIS STEP.\nCPULEFT  DC    D'0'                LEFT TCB TIME.\nSRBLEFT  DC    D'0'                LEFT SRB TIME.\nCPUUSED  DC    0D'0',X'4E',XL7'0'  CPU TIME USED.\nSRBUSED  DC    0D'0',X'4E',XL7'0'  SRB TIME USED.\nAZERO    DC    0D'0',X'4E',XL7'0'  A ZERO FOR NORMALIZATION.\nONEMIL   DC    D'1000000'          1 MILLION.\nTWOMIL   DC    D'2000000'          2 MILLION.\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTIME$": {"ttr": 33805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "//RTIME    JOB (........),'INSTALL  - RTIME -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=RTIME\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ENTRY   RTIME\n  NAME    RTIME(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTIME@": {"ttr": 33807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x08O\\x00\\x87\\x08O\\x16\\x19\\x00)\\x00)\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-03-25T00:00:00", "modifydate": "1987-03-25T16:19:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SYSPAJA"}, "text": "1   24/03/87\n                                                      RTIME     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       GET REMAINING CPU - SRB       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           TIME - ROUTINE.           * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL RTIME,(A,B),VL\n  ------------------            (A)\n\n         Where : A and optionally B are the addresses of fullwords\n                 (F boundary) receiving respectively the JOB or STEP\n                 remaining CPU time in seconds and the JOB remaining\n                 number of I/O in thousands (SRB time in seconds),\n                 floating point single precision expressed.\n\n         Note :  the CPU time is that remaining for the STEP if the\n                 'TIME=...' keyword has been coded on the EXEC\n                 statement of this step, otherwise it is the JOB\n                 remaining CPU time.\n\n  How to use :\n  ------------\n\n         If A and B arguments are supplied, you receive the CPU time\n               in A (1 day = 86400 secs) and the number of I/O in B.\n               If no CPU timing, CPU time left = 1000000 secs.\n               If no I/O control, I/O number left = 2000000 thds.\n\n         If A argument only, you get remaining CPU time + I/O number.\n         In this situation, from the resulting sum you can determine\n         if there is CPU timing or I/O control as below :\n               3,0 million = no CPU timing, no I/O control.\n               2,X million = yes CPU timing, no I/O control.\n               1,X million = no CPU timing, yes I/O control.\n               0,X million = yes CPU timing, yes I/O control, you have\n                             the sum.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "R050A90": {"ttr": 33809, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x923o\\x00\\x923o\\x12 \\x01\\xa3\\x01\\xa3\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-12-01T00:00:00", "modifydate": "1992-12-01T12:20:00", "lines": 419, "newlines": 419, "modlines": 0, "user": "SYSPAJA"}, "text": "SEDR     TITLE 'ENCIPHER-DECIPHER ROUTINE.'\nSETKEY   START 0\n         SPACE 1\n*        WRITTEN BY CRAIG KILLE OF FAIRCHILD SEMICONDUCTOR 5/5/76\n*        USING THE DATA ENCRYPTION ALGORITHM SUBMITTED BY IBM TO\n*        THE NATIONAL BUREAU OF STANDARDS AND PUBLISHED IN THE\n*        FEDERAL REGISTER, VOL. 40, NO. 52 - MONDAY, MARCH 17, 1975.\n*\n* THE GENERAL PROCEDURE FOR USE IS TO :\n*        (1) CALL THE SETKEY FUNCTION FROM A HOST PROGRAM, PASSING\n*            THE START ADDRESS OF THE 8 BYTES KEY TO BE USED IN ALL\n*            SUBSEQUENT ENCIPHERING AND/OR DECIPHERING CALLS.\n*\n*            COBOL EXAMPLE : CALL 'SETKEY' USING KEY-FIELD.\n*\n*            THE KEY FIELD WITHIN THE HOST PROGRAM IS LEFT UNCHANGED.\n*            THE CALL TO SETKEY NEED BE MADE ONLY ONCE PER EXECUTION\n*            OF THE HOST PROGRAM, UNLESS IT IS DESIRED TO CHANGE\n*            THE KEY FOR DEFINED GROUPS OF RECORDS, OR TO DECIPHER\n*            OR ENCIPHER TWO OR MORE FILES WITHIN THE SAME PROGRAM.\n*            IN THE LATTER CASE, IF THE CALLS TO ENCIPH/DECIPH ARE\n*            INTERMIXED FOR THE FILES, A CALL TO SETKEY WILL HAVE\n*            TO BE MADE BEFORE EACH ENCIPH/DECIPH CALL TO SET UP\n*            THE KEY PERMUTATIONS APPROPRIATE TO EACH FILE.\n*\n*        (2) CALL THE ENCIPH/DECIPH FUNCTIONS AS NEEDED TO ENCIPHER\n*            A DATA RECORD BEFORE WRITING IT TO A DATA-SET, OR\n*            DECIPHER A DATA RECORD AFTER READING IT FROM A DATA-SET.\n*            THE ARGUMENTS PASSED ARE THE START ADDRESS OF THE DATA\n*            AREA TO ENCIPHER OR DECIPHER, AND THE ADDRESS OF A\n*            FULL WORD BINARY COMPUTATIONAL ITEM THAT CONTAINS THE\n*            COUNT OF BYTES TO ENCIPHER OR DECIPHER. THE RESULT\n*            REPLACES THE ORIGINAL DATA; THE COMPUTATIONAL ITEM\n*            REMAINS UNCHANGED.\n*\n*            COBOL EXAMPLE : CALL 'ENCIPH' USING REC-AREA LENGTH56.\n*                            CALL 'DECIPH' USING REC-AREA LENGTH72.\n*\n*            SINCE THE ALGORITHM WORKS ON 8 BYTES AT A TIME, THE\n*            ACTUAL NUMBER OF BYTES ENCIPHERED OR DECIPHERED WILL\n*            BE AN INTEGRAL NUMBER OF 8 BYTES THAT IS LESS THAN\n*            OR EQUAL TO THE NUMBER PASSED IN ARG2 OF THE CALL.\n*            THE GREATEST NUMBER OF BYTES LEFT UNENCIPHERED OR\n*            DECIPHERED THEN WOULD BE THE RIGHTMOST 7 BYTES.\n*\n* MOD 1 - K TRUE  22JAN81 - CORRECTED BNP TO BM INSTR TO ALLOW 8 BYTES\n*                           FIELD LENGTH TO BE PROCESSED.\n         EJECT\n*          EXTRACTED FROM THE CBT TAPE FEB/88, FILE 270.           -EU-\n*          COPIED FROM THE CBT TAPE 07/17/84.\n*          CALLING EXAMPLE IS IN MEMBER CALLCIPH\n         SPACE 1\n*          DATA-SET R050A90    AT LEVEL 002 AS OF 01/23/81\n*          DATA-SET R050A90    AT LEVEL 001 AS OF 01/22/81\n*          DATA-SET ENCIPH0    AT LEVEL 001 AS OF 03/18/77\n         SPACE 1\n* REGISTERS USAGE :\n*\n*        R1=ADDR OF 1ST BYTE TO ENCIPHER OR DECIPHER\n*        R2=INCR REG. FOR R1 -- 8 BYTES EN/DECIPHERED AT A TIME\n*        R3=ADDR OF LAST 8 BYTES BLOCK TO EN/DECIPHER\n*        R4=SCRATCH\n*        R5=SCRATCH\n*        R6=SCRATCH\n*        R7=BYTE ADDR IN PERM0 TO STORE & SCRATCH\n*        R8=INCR REG. FOR R7 -- CONTAINS -1\n*        R9=ADDR-1 OF LEFTMOST BYTE OF PERM0\n*        R10=SCRATCH\n*        R11=POINTER TO S1,S2,...S8 CIPHER TABLE\n*        R12=BASE ADDRESS REGISTER\n*        R13=CONTAINS INTERATION 1...16 FOR FUNCTION PERFORMANCE COUNT\n*        R14=SCRATCH\n*        R15=SCRATCH\n         SPACE 1\n        $DEFREG\n         EJECT\n* ------ ROUTINE STARTS HERE.\n*        SAVE REGS., SET UP SAVE AREA, & ESTABLISH ADDRESSABILITY\n         SPACE 1\n         ENTRY ENCIPH\n         ENTRY DECIPH\n         SPACE 1\n         USING *,R15\n         MVI   WTGO+1,8       CODE 8 FOR SETKEY\n         B     INIT\n         DROP  R15\n         SPACE 1\n         USING *,R15\nENCIPH   MVI   WTGO+1,0       CODE 0 FOR ENCIPH\n         B     INIT\n         DROP  R15\n         SPACE 1\n         USING *,R15\nDECIPH   MVI   WTGO+1,4       CODE 4 FOR DECIPH\n         DROP  R15\n         EJECT\nINIT     STM   R14,R12,12(R13)\n         BASR  R12,0\n         USING *,R12\n         B     BEGIN\nWTGO     DC    H'0'\nR050A90 $IDENT ,\nSAVEAREA DC    18F'0'         MY REGISTERS SAVE AREA\nBEGIN    LR    R2,R13\n         LA    R13,SAVEAREA\n         ST    R2,SAVEAREA+4\n         ST    R13,8(,R2)\n         LH    R14,WTGO\n         B     *+L'*(R14)     BRANCH TO APPROPRIATE ROUTINE\n         B     ENDECIPH\n         B     ENDECIPH\n*              BRANCH DIRECTLY TO NEXT INSTR. ON SETKEY\n         EJECT\n* ------ BUILD 16 KEY PERMUTATIONS FROM ORIGINAL 8 BYTES KEY.\n         SPACE 1\n         L     R4,0(R1)       (R4)=ADDR OF 8 BYTES KEY PASSED\n         ICM   R6,15,0(R4)    LOAD FIRST 4 BYTES OF KEY\n         ICM   R7,15,4(R4)    LOAD SECOND 4 BYTES OF KEY\n         L     R8,=F'-1'      LOAD INCR REG FOR BXH\n         LA    R5,KEY64+63    LOAD LAST BYTE ADDRESS\n         LA    R9,KEY64-1     LOAD ADDR-1 OF LEFTMOST BYTE\n         STC   R7,0(R5)       SET UP KEY AS 64 BYTES RATHER THAN BITS\n         SRDL  R6,1           SHIFT IN NEXT BIT\n         BXH   R5,R8,*-8\n         SPACE 1\n* ------ PERFORM CHOICE 1 PERMUTATION ON 64 BYTES KEY FOR 56 BYTES KEY.\n         SPACE 1\n         MVC   KEY56,CHOICE1P MOVE IN PATTERN TO EXTRACT KEY\n         TR    KEY56,KEY64    SCRAMBLE ORIGINAL KEY\n         SPACE 1\n* ------ NOW PREPARE A 48 BYTES KEY TO EXCLUSIVE OR TO THE 48 BYTES\n*        I WILL CREATE FROM THE RIGHTSIDE OF PERM1 WHEN WORKING\n*        WITH THE DATA TO ENCIPHER OR DECIPHER.\n         SPACE 1\n         XR    R13,R13        SET UP KEYS FOR R13 = 0 TO 15\nNEXTKEY  LA    R4,1\n         C     R13,=F'1'      IF R13 IS 0,1,8, OR 15 SHIFT ONCE\n         BNH   *+L'*+24       OTHERWISE SHIFT TWICE.\n         C     R13,=F'8'\n         BL    *+L'*+12\n         BE    *+L'*+12\n         C     R13,=F'15'\n         BE    *+L'*+4\n         LA    R4,1(R4)\n         MVC   KEY56-1,KEY56  SHIFT WHOLE KEY LEFT 1 BYTE\n         MVC   BYTE56,BYTE28  AND SIMULATE CIRCULAR SHIFT OF BOTH\n         MVC   BYTE28,BYTEOUT HALVES OF KEY56 BY STUFFING BYTES.\n         BCT   R4,*-18        GO DO AGAIN IF NECESSARY\n         SPACE 1\n* ------ PERFORM CHOICE 2 ON KEY56 BY EXTRACTING 48 BYTES KEY.\n         SPACE 1\n         MVC   KEY48,CHOICE2P MOVE IN PATTERN TO EXTRACT 48 BYTES\n         TR    KEY48,KEY56    EXTRACT\n         LR    R15,R13        COMPUTE AREA ADDR FOR STORE\n         M     R14,=F'48'     MULTIPLY BY WIDTH OF KEY\n         LA    R14,KEY0(R15)  ADD IN BASE ADDR OF KEY0\n         MVC   0(48,R14),KEY48     MOVE KEY TO CORRECT AREA\n         LA    R13,1(R13)     INCREMENT R13\n         C     R13,=F'15'\n         BNH   NEXTKEY\n         B     EXUENT         ALL DONE MY JOB, NOW EXIT\n         EJECT\n* ------ COMMON CODE FOR ENCIPHER AND DECIPHER. ONLY DIFFERENCE\n*        IS WHETHER TO USE KEYS 0-15 (ENCIPH) OR 15-0 (DECIPH).\n         SPACE 1\nENDECIPH ST    R14,MODE       SAVE MODE I CAME IN WITH\n         LM    R2,R3,0(R1)    LOAD ADDR OF 1ST BYTE & LENGTH\n         L     R3,0(R3)       (R2)=ADDR OF START, (R3) = LENGTH\n         N     R3,=F'-8'      MAKE SURE LENGTH IS MULTIPLE OF 8 BYTES\n         S     R3,=F'8'       GET LENGTH MINUS EIGHT\n         BM    EXUENT         LEN < 0, FORGET IT                KMTMOD1\n         LR    R1,R2          LOAD START ADDRESS IN REG. 1\n         AR    R3,R2          ADD IN LENGTH-8 FOR ADDR OF LAST 8 BYTES\n         LA    R2,8           LOAD INCREMENT REGISTER\n         L     R8,=F'-1'      LOAD DECREMENT REG. USED THRUOUT FOR BXH\n         SPACE 1\n* ------ GRAB NEXT 8 BYTES POINTED TO BY REG. 1 AND SPLIT THE 32 BITS\n*        IN THOSE 8 BYTES INTO 32 BYTES SO I CAN USE THE TR INST. TO\n*        DO THE HARD WORK OF SHIFTING EVERYBODY AROUND. I MAKE NO\n*        ATTEMPT TO ELIMINATE ALL BUT THE RIGHTMOST BIT IN EACH BYTE\n*        STORED, BECAUSE THESE OTHER BITS ARE IRRELEVANT IN ALL\n*        PROCESS STEPS, AND ARE DISCARDED ON OUTPUT.\n         SPACE 1\nNEXT8BYT LA    R9,PERM0-1\n         LA    R7,64(R9)      R7 INIT. POINTS TO RIGHTMOST BYTE PERM0\n         ICM   R4,15,0(R1)    LOAD 8 BYTES INTO R4 AND R5, ASSUMING\n         ICM   R5,15,4(R1)    NO ALLIGNMENT OTHER THAN BYTE\n         STC   R5,0(R7)       STORE BYTE (RIGHTMOST BIT,ONLY,IMPORTANT)\n         SRDL  R4,1           SHIFT IN NEXT BIT\n         BXH   R7,R8,*-8      POINT TO PRIOR BYTE IN PERM0 AND REDO\n         SPACE 1\n* ------ PERMUTATION 1 : SCRAMBLE ORIGINAL 64 BITS (BYTES NOW).\n         SPACE 1\n         MVC   PERM1,PERM1PAT MOVE IN PATTERN TO SCRAMBLE\n         TR    PERM1,PERM0    SCRAMBLE PERM0 INTO PERM1\n         L     R14,MODE       DO ITERATION 0-15 ENCIPH, 15-0 DECIPH\n         B     *+L'*(R14)\n         B     *+L'*+8\n         LA    R13,15\n         B     NEXTITER\n         XR    R13,R13\n         SPACE 1\n* ------ MAIN LOOP OF PROGRAM WHERE 16 ITERATIONS OF BASTARDIZATION\n*        ARE PERFORMED. AND WITH A SLIGHT OF HAND, GARBAGE RESULTS.\n*        FIRST PERFORM FUNCTION 'E' WHICH EXPANDS THE RIGHTMOST 32\n*        BYTES OF PERM1 INTO 48.\n         SPACE 1\nNEXTITER MVC   RIGHT48,RIGHT48P    MOVE IN PATTERN TO EXPAND\n         TR    RIGHT48,PERM1+32    EXPAND RIGHTMOST 32 BYTES TO 48\n         SPACE 1\n* ------ GET APPROPRIATE KEY TO EXCLUSIVE OR.\n         SPACE 1\n         LR    R15,R13        COMPUTE KEY ADDR\n         M     R14,=F'48'\n         LA    R14,KEY0(R15)\n         EJECT\n* ------ EXCLUSIVE OR THE 48 BYTES RESULTS OF FUNCTION 'E' AND THE KEY\n*        EXTRACTION.\n         SPACE 1\n         XC    RIGHT48,0(R14)\n         SPACE 1\n* ------ TREAT THIS RESULT (IN RIGHT48) AS 8 6-BYTES BLOCKS.\n*        TRANSLATE SO BYTES 0 & 5 OF EACH BLOCK BECOME BYTES 0 & 1\n*        AND BYTES 1 TO 4 BECOME BYTES 2-5.\n         SPACE 1\n         MVC   KEY48,TICKLE   MOVE IN PATTERN TO TICKLE\n         TR    KEY48,RIGHT48  TICKLE\n         SPACE 1\n* ------ NOW, UNFORTUNATELY, I HAVE TO TURN THE BYTES BACK INTO BITS\n*        SO THAT I CAN FORM A SIX BIT KEY FOR TABLE LOOK UP INTO\n*        THE TABLES S1,S2,...S8. AFTER THAT EACH 6 BYTES (BIT) BLOCK\n*        OF KEY48 WILL BE REPLACED BY THE 4 BIT CODE FOUND IN THE\n*        TABLE LOOK UP. THUS MY 48 BITS BECOME 32 BITS AGAIN. YIPEE.\n*        THE TABLES S1,S2,...S8 ARE USED RESPECTIVELY FOR THE 1ST,2ND,\n*        ...8TH BLOCK OF 6 BITS IN KEY48.\n         SPACE 1\n         LA    R4,KEY48       SET UP BXLE CONTROL\n         LA    R6,1\n         LA    R7,KEY48+47\n         SLDL  R14,1          SHIFT REGS. 14 & 15 LEFT 1 BIT\n         TM    0(R4),1        IS RIGHTMOST BIT IN BYTE TURNED ON?\n         BNO   *+L'*+4        NO, SHIFT IN ZERO\n         O     R15,=F'1'      OR IN A ONE BIT TO SHIFT\n         BXLE  R4,R6,*-16\n         SLDL  R14,16         SHIFT 48 BITS FLUSH LEFT IN REGS. 14 & 15\n         XR    R9,R9          ZERO OUT SCRATCH REGISTER 9\n         LA    R4,S1          POINT TO FIRST TABLE FOR 1ST 6 BIT KEY\n         LA    R6,64          SIZE IN BYTES OF TABLE TO JUMP OVER\n         LA    R7,S7          STOP AFTER LAST ODD NUMBERED TABLE\nLOOP     SLL   R10,8          SHIFT OVER BITS CREATED SO FAR\n         LR    R5,R14         GET LEFTMOST 6 BITS OF R14 IN R5\n         SRL   R5,26\n         SLDL  R14,6          SHIFT IN NEXT 6 BIT KEY\n         IC    R9,0(R5,R4)    GET BYTE FROM TABLE S1,S3,S5,S7\n         AR    R4,R6          POINT TO TABLE S2,S4,S6,S8\n         LR    R5,R14         GET LEFTMOST 6 BITS OF R14 IN R5\n         SRL   R5,26\n         SLDL  R14,6          SHIFT IN NEXT 6 BIT KEY\n         IC    R10,0(R5,R4)   GET BYTE FROM TABLE S2,S4,S6,S8\n         SLL   R9,4           SHIFT LEFT HALF BYTE TO POSITION\n         OR    R10,R9         OR LEFT AND RIGHT HALVES OF BYTE\n         BXLE  R4,R6,LOOP     POINT TO S3,S5,S7 AND GO AGAIN\n         EJECT\n* ------ REGISTER 10 NOW CONTAINS 32 BITS TO DECODE TO 32 BYTES.\n         SPACE 1\n         LA    R7,RIGHT48+31  ADDR FOR FIRST BYTE STORE\n         LA    R9,RIGHT48-1   ADDR-1 OF LAST BYTE TO STORE. (R8)=-1\n         STC   R10,0(R7)      STORE BYTE (ONLY RIGHTMOST BIT IMPORTANT)\n         SRL   R10,1          SHIFT IN NEXT BIT\n         BXH   R7,R8,*-8\n         SPACE 1\n* ------ PERFORM PERMUTATION OF RESULTANT 32 BYTES.\n         SPACE 1\n         MVC   PERM0(32),PRIMP     MOVE IN PERMUTE PATTERN\n         TR    PERM0(32),RIGHT48   TRANSLATE IN 32 LEFT BYTES OF RGHT\n         SPACE 1\n* ------ EXCLUSIVE OR THE COMPLETED PERMUTED RIGHTHALF WITH THE\n*        ORIGINAL LEFT HALF, AND THEN PLACE ORIGINAL RIGHT HALF IN\n*        LEFT HALF, AND MOVE IN EXCLUSIVE OR RESULT TO RIGHT HALF.\n         SPACE 1\n         XC    PERM0(32),PERM1\n         MVC   PERM1(32),PERM1+32  MOVE ORIG. RIGHT TO LEFT HALF\n         MVC   PERM1+32(32),PERM0  MOVE IN EXCL OR RESULT\n         L     R14,MODE       INCR ITER# IF ENCIPH, DECR IF DECIPH\n         B     *+L'*(R14)\n         B     *+L'*+12\n         BCTR  R13,0          DECREMENT BECAUSE WE ARE DECIPHERING\n         LTR   R13,R13\n         BNM   NEXTITER       GO UNTIL ITER # IS NEGATIVE\n         B     *+L'*+12       JUMP OUT WHEN DONE\n         LA    R13,1(R13)     INCREMENT BECAUSE WE ARE ENCIPHERING\n         C     R13,=F'15'\n         BNH   NEXTITER\n         SPACE 1\n* ------ FALL THRU TO HERE WHEN 16 ITERATIONS DONE. NOW DO FINAL\n*        PERMUTATION WHICH IS INVERSE OF FIRST PERMUTATION AND\n*        STORE RESULTING 8 BYTES BACK WHERE I GOT THE ORIGINALS FROM.\n         SPACE 1\n         MVC   PERM1+32(32),PERM1  LEAVE HALVES UNSWITCHED ON 16TH\n         MVC   PERM1(32),PERM0\n         MVC   PERM0,LASTTRAN MOVE IN INVERSE PATTERN\n         TR    PERM0,PERM1    PERMUTE PERM1 INTO PERM0 RESULT\n         SPACE 1\n* ------ CHANGE BYTES BACK TO BITS FOR THE FINAL TIME.\n         SPACE 1\n         LA    R4,PERM0\n         LA    R6,1\n         LA    R7,PERM0+63\n         SLDL  R14,1          SHIFT BITS LEFT ONE\n         TM    0(R4),1        IS RIGHTMOST BIT OF BYTE A ONE?\n         BNO   *+L'*+4        NO, SHIFT IN ZERO BIT\n         O     R15,=F'1'      OR IN A ONE BIT\n         BXLE  R4,R6,*-16\n         STCM  R14,15,0(R1)   STORE OVER ORIG FIRST 4 BYTES\n         STCM  R15,15,4(R1)   STORE OVER ORIG SECOND 4 BYTES\n         BXLE  R1,R2,NEXT8BYT GO GET NEXT 8 BYTES UNTIL DONE\n         EJECT\n* ------ COMMON EXIT FOR SETKEY, ENCIPH, AND DECIPH.\n         SPACE 1\nEXUENT   L     R13,SAVEAREA+4 LOAD ADDR OF CALLERS SAVE AREA\n         XR    R15,R15        SET RETURN CODE TO ZERO\n         RETURN (14,12),RC=(15)\n         EJECT\n* ------ DATA AREAS.\n         SPACE 1\nMODE     DS    F\nKEY0     DS    16CL48\nPERM0    DS    CL64\nPERM1    DS    CL64\nKEY64    DS    CL64\nRIGHT48  DS    CL48\nKEY48    DS    CL48\nBYTEOUT  DS    CL1       *** BYTEOUT THRU BYTE56 MUST BE TOGETHER ***\nKEY56    DS    0CL56                                                *\n         DS    CL27                                                 *\nBYTE28   DS    CL1                                                  *\n         DS    CL27                                                 *\nBYTE56   DS    CL1       *** END OF GROUP                         ***\n         SPACE 2\n         LTORG\n         EJECT\n         SPACE 1\n* ------ TRANSLATION  TABLES.\n         SPACE 1\nPERM1PAT DS    0CL64\n         DC    AL1(57,49,41,33,25,17,09,01,59,51,43,35,27,19,11,03)\n         DC    AL1(61,53,45,37,29,21,13,05,63,55,47,39,31,23,15,07)\n         DC    AL1(56,48,40,32,24,16,08,00,58,50,42,34,26,18,10,02)\n         DC    AL1(60,52,44,36,28,20,12,04,62,54,46,38,30,22,14,06)\nRIGHT48P DS    0CL48\n         DC    AL1(31,00,01,02,03,04,03,04,05,06,07,08)\n         DC    AL1(07,08,09,10,11,12,11,12,13,14,15,16)\n         DC    AL1(15,16,17,18,19,20,19,20,21,22,23,24)\n         DC    AL1(23,24,25,26,27,28,27,28,29,30,31,00)\nCHOICE1P DS    0CL56\n         DC    AL1(56,48,40,32,24,16,08,00,57,49,41,33,25,17)\n         DC    AL1(09,01,58,50,42,34,26,18,10,02,59,51,43,35)\n         DC    AL1(62,54,46,38,30,22,14,06,61,53,45,37,29,21)\n         DC    AL1(13,05,60,52,44,36,28,20,12,04,27,19,11,03)\nCHOICE2P DS    0CL48\n         DC    AL1(13,16,10,23,00,04,02,27,14,05,20,09)\n         DC    AL1(22,18,11,03,25,07,15,06,26,19,12,01)\n         DC    AL1(40,51,30,36,46,54,29,39,50,44,32,47)\n         DC    AL1(43,48,38,55,33,52,45,41,49,35,28,31)\nTICKLE   DS    0CL48\n         DC    AL1(00,05,01,02,03,04,06,11,07,08,09,10)\n         DC    AL1(12,17,13,14,15,16,18,23,19,20,21,22)\n         DC    AL1(24,29,25,26,27,28,30,35,31,32,33,34)\n         DC    AL1(36,41,37,38,39,40,42,47,43,44,45,46)\nLASTTRAN DS    0CL64\n         DC    AL1(39,07,47,15,55,23,63,31,38,06,46,14,54,22,62,30)\n         DC    AL1(37,05,45,13,53,21,61,29,36,04,44,12,52,20,60,28)\n         DC    AL1(35,03,43,11,51,19,59,27,34,02,42,10,50,18,58,26)\n         DC    AL1(33,01,41,09,49,17,57,25,32,00,40,08,48,16,56,24)\nPRIMP    DS    0CL32\n         DC    AL1(15,06,19,20,28,11,27,16,00,14,22,25,04,17,30,09)\n         DC    AL1(01,07,23,13,31,26,02,08,18,12,29,05,21,10,03,24)\nS1       DS    0CL64\n         DC    AL1(14,04,13,01,02,15,11,08,03,10,06,12,05,09,00,07)\n         DC    AL1(00,15,07,04,14,02,13,01,10,06,12,11,09,05,03,08)\n         DC    AL1(04,01,14,08,13,06,02,11,15,12,09,07,03,10,05,00)\n         DC    AL1(15,12,08,02,04,09,01,07,05,11,03,14,10,00,06,13)\nS2       DS    0CL64\n         DC    AL1(15,01,08,14,06,11,03,04,09,07,02,13,12,00,05,10)\n         DC    AL1(03,13,04,07,15,02,08,14,12,00,01,10,06,09,11,05)\n         DC    AL1(00,14,07,11,10,04,13,01,05,08,12,06,09,03,02,15)\n         DC    AL1(13,08,10,01,03,15,04,02,11,06,07,12,00,05,14,09)\nS3       DS    0CL64\n         DC    AL1(10,00,09,14,06,03,15,05,01,13,12,07,11,04,02,08)\n         DC    AL1(13,07,00,09,03,04,06,10,02,08,05,14,12,11,15,01)\n         DC    AL1(13,06,04,09,08,15,03,00,11,01,02,12,05,10,14,07)\n         DC    AL1(01,10,13,00,06,09,08,07,04,15,14,03,11,05,02,12)\nS4       DS    0CL64\n         DC    AL1(07,13,14,03,00,06,09,10,01,02,08,05,11,12,04,15)\n         DC    AL1(13,08,11,05,06,15,00,03,04,07,02,12,01,10,14,09)\n         DC    AL1(10,06,09,00,12,11,07,13,15,01,03,14,05,02,08,04)\n         DC    AL1(03,15,00,06,10,01,13,08,09,04,05,11,12,07,02,14)\nS5       DS    0CL64\n         DC    AL1(02,12,04,01,07,10,11,06,08,05,03,15,13,00,14,09)\n         DC    AL1(14,11,02,12,04,07,13,01,05,00,15,10,03,09,08,06)\n         DC    AL1(04,02,01,11,10,13,07,08,15,09,12,05,06,03,00,14)\n         DC    AL1(11,08,12,07,01,14,02,13,06,15,00,09,10,04,05,03)\nS6       DS    0CL64\n         DC    AL1(12,01,10,15,09,02,06,08,00,13,03,04,14,07,05,11)\n         DC    AL1(10,15,04,02,07,12,09,05,06,01,13,14,00,11,03,08)\n         DC    AL1(09,14,15,05,02,08,12,03,07,00,04,10,01,13,11,06)\n         DC    AL1(04,03,02,12,09,05,15,10,11,14,01,07,06,00,08,13)\nS7       DS    0CL64\n         DC    AL1(04,11,02,14,15,00,08,13,03,12,09,07,05,10,06,01)\n         DC    AL1(13,00,11,07,04,09,01,10,14,03,05,12,02,15,08,06)\n         DC    AL1(01,04,11,13,12,03,07,14,10,15,06,08,00,05,09,02)\n         DC    AL1(06,11,13,08,01,04,10,07,09,05,00,15,14,02,03,12)\nS8       DS    0CL64\n         DC    AL1(13,02,08,04,06,15,11,01,10,09,03,14,05,00,12,07)\n         DC    AL1(01,15,13,08,10,03,07,04,12,05,06,11,00,14,09,02)\n         DC    AL1(07,11,04,01,09,12,14,02,00,06,10,13,15,03,05,08)\n         DC    AL1(02,01,14,07,04,10,08,13,15,12,09,00,03,05,06,11)\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "R050A90$": {"ttr": 34055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10W\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:57:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "//R050A90  JOB (........),'INSTALL  -R050A90-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS2,MBR=R050A90\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   SETKEY\n  ALIAS   ENCIPH\n  ALIAS   DECIPH\n  NAME    R050A90(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SBOOK0": {"ttr": 34057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x893_\\x00\\x893_\\x11!\\x00f\\x00f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-01T00:00:00", "modifydate": "1989-12-01T11:21:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "SYSPAJA"}, "text": ")SET SCBC = 99\n)SET SCBP = 0\n)SET SCBT = &ZTIME\n)DOT &CBLIST\n)SET SCBW = 3\n)SEL &CBPFULL = YES\n)SET SCBW = &SCBW + 1\n)SEL &CBNW0 > 0\n)SET SCBW = &SCBW + 1\n)SEL &CBNW0 > 3\n)SET SCBW = &SCBW + 1\n)ENDSEL\n)SEL &CBNW0 > 6\n)SET SCBW = &SCBW + 1\n)ENDSEL\n)SEL &CBNW0 > 9\n)SET SCBW = &SCBW + 1\n)ENDSEL\n)SEL &CBNW0 > 12\n)SET SCBW = &SCBW + 1\n)ENDSEL\n)SEL &CBNW0 > 15\n)SET SCBW = &SCBW + 1\n)ENDSEL\n)SEL &CBNW0 > 18\n)SET SCBW = &SCBW + 1\n)ENDSEL\n)SEL &CBNW0 > 21\n)SET SCBW = &SCBW + 1\n)ENDSEL\n)SEL &CBNW0 > 24\n)SET SCBW = &SCBW + 1\n)ENDSEL\n)SEL &CBNW0 > 27\n)SET SCBW = &SCBW + 1\n)ENDSEL\n)ENDSEL\n)ENDSEL\n)SET SCBL = &SCBC + &SCBW\n)SEL &SCBL > 54\n)SET SCBC = 0\n)SET SCBP = &SCBP + 1\n1IBM Manuals list for &ZUSER (&CBCURD - &SCBT)                 Page &SC?\nBP\n0Current sort order : &CBSRTF\n0 Key-1    Key-2    Manual no.  Title                               Loc?\nation\n -------- -------- ------------ ----------------------------------  ---?\n-----\n)ENDSEL\n)BLANK\n)TB 11 20 33 69\n &CBKW1!&CBKW2!&CBMNO!&CBTMN!&CBLOC\n                                No. of TNL : &CBNW0  Room : &CBROOM\n)SET SCBC = &SCBC + 3\n)SEL &CBPFULL = YES\n)SEL &CBNW0 > 0\n)SEL &CBNW1 \u00ac= &Z\n                                &CBNW1        &CBNW2        &CBNW3\n)SET SCBC = &SCBC + 1\n)ENDSEL\n)SEL &CBNW4 \u00ac= &Z\n                                &CBNW4        &CBNW5        &CBNW6\n)SET SCBC = &SCBC + 1\n)ENDSEL\n)SEL &CBNW7 \u00ac= &Z\n                                &CBNW7        &CBNW8        &CBNW9\n)SET SCBC = &SCBC + 1\n)ENDSEL\n)SEL &CBNW10 \u00ac= &Z\n                                &CBNW10       &CBNW11       &CBNW12\n)SET SCBC = &SCBC + 1\n)ENDSEL\n)SEL &CBNW13 \u00ac= &Z\n                                &CBNW13       &CBNW14       &CBNW15\n)SET SCBC = &SCBC + 1\n)ENDSEL\n)SEL &CBNW16 \u00ac= &Z\n                                &CBNW16       &CBNW17       &CBNW18\n)SET SCBC = &SCBC + 1\n)ENDSEL\n)SEL &CBNW19 \u00ac= &Z\n                                &CBNW19       &CBNW20       &CBNW21\n)SET SCBC = &SCBC + 1\n)ENDSEL\n)SEL &CBNW22 \u00ac= &Z\n                                &CBNW22       &CBNW23       &CBNW24\n)SET SCBC = &SCBC + 1\n)ENDSEL\n)SEL &CBNW25 \u00ac= &Z\n                                &CBNW25       &CBNW26       &CBNW27\n)SET SCBC = &SCBC + 1\n)ENDSEL\n)SEL &CBNW28 \u00ac= &Z\n                                &CBNW28       &CBNW29       &CBNW30\n)SET SCBC = &SCBC + 1\n)ENDSEL\n)ENDSEL\n                                Date : &CBDTE        User : &CBUSR\n)SET SCBC = &SCBC + 1\n)ENDSEL\n)ENDDOT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCKPRM00": {"ttr": 34060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x005\\x005\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=SCKPRM00\n./     NUMBER  NEW1=100,INCR=100\n/*********************************************************************/\n/*               \"SETCLOCK PARAMETERS SPECIFICATIONS\"                */\n/*********************************************************************/\n/* THE FOLLOWING PARAMETERS SHOULD BE SPECIFIED :                    */\n/*        LONG_WAIT       = SSSS        WHERE SSSS                   */\n/*        TRACK_WAIT      = SSSS          IS THE TIME                */\n/*        SEEK_TIME       = SSSS            IN 100TH OF              */\n/*        DISCONNECT_TIME = SSSS              A SECOND.              */\n/*        MAXCPU          = NN          WHERE N...                   */\n/*        SYNCH_METHOD    = NN            IS A                       */\n/*        SNAP_ID         = NNN             NUMERICAL                */\n/*        SNAP_IDS        = (N,NN,NNN)        VALUE                  */\n/* \"LONG_WAIT\" IS THE INTERVAL OF TIME THE PROGRAM SHOULD WAIT       */\n/*             BEFORE CHECKING IF ANY \"SYSTEM TRACKING\" REQUEST      */\n/*             IS MADE (SAY 300 SECONDS). THIS TIME IS USED AFTER    */\n/*             SETCLOCK WAS STARTED ON A CPU, AND IT WAS THE ONLY    */\n/*             ONE ON WHICH THERE WAS A SETCLOCK JOB. MUST BE LESS   */\n/*             THAN DISCONNECT_TIME.                                 */\n/* \"TRACK_WAIT\" IS THE INTERVAL OF TIME THE PROGRAM SHOULD WAIT      */\n/*             ONCE IT HAS DETECTED A \"SYSTEM TRACKING\" REQUEST.     */\n/*             AT THIS TIME, IT CHECKS IF ALL CPU'S OBTAINED THAT    */\n/*             THAT STATE (SAY 5 SECONDS).                           */\n/* \"SEEK_TIME\" IS THE AVERAGE INTERVAL OF TIME REQUIRED TO COMPLETE  */\n/*             AN I/O ON THE CHECKPOINT DATA-SET.                    */\n/* \"DISCONNECT_TIME\" IS THE PERIOD OF TIME WE SHOULD WAIT BEFORE     */\n/*             CONCLUDING THAT ALL THE OTHER CPUS THAT DID NOT       */\n/*             REACH THE \"TRACK STATE\" ARE NOT ACTIVE (SAY 500       */\n/*             SECONDS). MUST BE HIGHER THAN \"LONG WAIT\".            */\n/* \"MAXCPU\"    IS THE MAXIMUM NUMBER OF CPU'S TO BE SYNCHRONIZED     */\n/*             TOGETHER. NOTE THAT THIS PARAMETER IS USED ONLY       */\n/*             DURING FIRST SETCLOCK AFTER \"RESET\" WAS ISSUED.       */\n/*             AFTER, THE NUMBER OF CPUS WILL BE TAKEN FROM THE      */\n/*             CHECKPOINT AND WILL BE EQUAL TO THE LAST NUMBER OF    */\n/*             CPUS SYNCHRONIZED.                                    */\n/* \"SYNCH_METHOD\" IS THE SYNCHRONIZATION METHOD NUMBER TO BE USED :  */\n/*             1 = THE CPU WHICH RESET CHECKPOINT SET THE BASE CLOCK */\n/*                 VALUE (THE DEFAULT OR ANY OTHER VALUE MEANS THE   */\n/*                 CPU WHICH HAS THE HIGHEST CLOCK VALUE).           */\n/* \"SNAP_ID\"   IS THE SNAP-DUMP ID'S (0-255) TO SET ACTIVE (NEEDS    */\n/* \"SNAP_IDS\"  'SYSSNAP' FILE ALLOCATED).                            */\n/*********************************************************************/\n\n        MAXCPU          =     2   /*  MAXIMUM OF 2 CPU'S             */\n        DISCONNECT_TIME = 12000   /*  INITIAL WAIT TIME FOR CKPT     */\n        LONG_WAIT       =  6000   /*  6000/100  SEC --  1 MINUTE     */\n        TRACK_WAIT      =   200   /*   200/100  SEC --  2 SECONDS    */\n        SEEK_TIME       =     2   /*     2/100  SEC --  20 MILLISEC. */\n        SYNCH_METHOD    =     1   /*  SYNCHRONIZATION METHOD NO.     */\n        SNAP_ID         =     1   /*  SNAP-DUMP ID NO. SELECTION     */\n\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCRSZ": {"ttr": 34062, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x8f\\x00\\x88\\t\\x8f\\x12\\x16\\x00P\\x00P\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-07T00:00:00", "modifydate": "1988-04-07T12:16:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "SYSPAJA"}, "text": "SIZE     TITLE 'TSO SCRSZ COMMAND - GET THE CURRENT SCREEN SIZE.'\nSCRSZ    START 0\n         SPACE 1\n* PURPOSE :    SET A RETURN CODE IN REGISTER 15 TO INFORM ABOUT THE\n* ---------    CURRENT TERMINAL TYPE AND SCREEN SIZE.\n*              THE RETURN CODE (REGISTER 15) MAY BE AS FOLLOWS :\n*                  0 = NOT A DISPLAY TERMINAL.\n*                  1 = TERMINAL SIZE (24,80)\n*                  2 = TERMINAL SIZE (27,132)\n*                  3 = TERMINAL SIZE (32,80)\n*                  4 = TERMINAL SIZE (43,80)\n*                 99 = UNKNOWN TERMINAL SIZE.\n*                100 = NOT TSO ENVIRONMENT.\n*\n* AUTHOR :     MOINIL P.A.\n* ---------    COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 2\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R11,R13             SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R11\n         MVC   EXTR(LEXTR),EXTRP\n         XC    ATSO,ATSO\n        EXTRACT ATSO,'S',FIELDS=(TSO),MF=(E,EXTR)\n         L     R2,ATSO\n         TM    0(R2),X'80'\n         BZ    NOTTSO              WE ARE'NT IN TSO.\n        GTSIZE\n         LTR   R15,R15\n         BNZ   EXITUNK             ERROR RETURN CODE.\n         LTR   R15,R0\n         BZ    EXIT                NOT DISPLAY TERMINAL.\n         CL    R1,=F'80'           TEST LINE LENGTH.\n         BE    T1\n         CL    R1,=F'132'\n         BNE   EXITUNK\n         CL    R0,=F'27'           TEST NUMBER OF LINES.\n         BNE   EXITUNK\n         LA    R15,2\n         B     EXIT\nT1       CL    R0,=F'24'\n         BNE   T2\n         LA    R15,1\n         B     EXIT\nT2       CL    R0,=F'32'\n         BNE   T3\n         LA    R15,3\n         B     EXIT\nT3       CL    R0,=F'43'\n         BNE   EXITUNK\n         LA    R15,4\n         B     EXIT\nNOTTSO   LA    R15,100             SET NOT TSO FOREGROUND C.C.\n         B     EXIT\nEXITUNK  LA    R15,99              SET UNKNOWN C.C.\nEXIT    $XRET  CC=(R15),LV=WRKL,TYPE=RENT\n         EJECT\n*        CONSTANTS AND SKELETONS.\n         SPACE 1\nEXTRP   EXTRACT *-*,'S',MF=L\n         SPACE 2\n        LTORG\n         SPACE 2\n*        WORK AREAS DESCRIPTION.\n         SPACE 1\nWRKDSECT DSECT\n         SPACE 1\nSVA      DS    18F                 LOCAL SAVE AREA.\n         SPACE 1\nEXTR    EXTRACT *-*,'S',MF=L\nLEXTR    EQU   *-EXTR\n         SPACE 1\nATSO     DS    F\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCRSZ$": {"ttr": 34307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//SCRSZ    JOB (........),'INSTALL  -SCRSZ-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS2,OPT=',RENT',MBR=SCRSZ\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   SCRSZ\n  NAME    SCRSZ(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCRSZ@": {"ttr": 34309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x07o\\x00\\x86\\x07o\\tG\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-03-17T00:00:00", "modifydate": "1986-03-17T09:47:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "1   17/03/86\n                                                      SCRSZ     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       GET CURRENT SCREEN SIZE       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    This is a TSO command, usefull in CLIST definition,\n  ---------    which sets a return code in register 15 to indicate\n               the current terminal type, and thus the screen size.\n               The return code (register 15) may be as follows :\n                   0 = not a display terminal.\n                   1 = terminal size (24,80)\n                   2 = terminal size (27,132)\n                   3 = terminal size (32,80)\n                   4 = terminal size (43,80)\n                  99 = unknown terminal size.\n                 100 = not TSO foreground environment.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETAUTH": {"ttr": 34311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           AUTHORIZATION ON.\n&NAME    SETAUTH    &DUMMY\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n&NAME    LA    0,1                 SET AUTHORIZATION ON.\n         SVC   ###                 SEND REQUEST.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SKEL": {"ttr": 34313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943_\\x00\\x943_\\t\\x17\\x00\\xdc\\x00\\xdc\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-01T00:00:00", "modifydate": "1994-12-01T09:17:00", "lines": 220, "newlines": 220, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM,BPARM) NOPROCESS\n/*  MACRO NAME : SKEL                                               */\n/*    FUNCTION : INSERT JCL SKELETONS                               */\n/*      SYNTAX : SKEL ... (VARIOUS SKELETONS, SEE HELP)             */\n/*                    HELP OR H                                     */\n/*       DEBUG : SKEL ... LIST                                      */\n/*      AUTHOR : MOINIL P.A.                                        */\n  IF &STR(&BPARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n  IF &STR(&APARM.) = &STR(HELP) OR +\n    &STR(&APARM.) = &STR(H) THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTSKL)\n      SET &RCX = &LASTCC\n      ISPEXEC CONTROL DISPLAY RESTORE\n      EXIT CODE(&RCX)\n      END\n  SET &SKC = &STR(&&)\n/* --- PS / PO SKELETON - - - - - - - - - - - - - - - - - - - - --- */\n  IF &STR(&APARM.) = &STR(PS) OR +\n    &STR(&APARM.) = &STR(PO) THEN DO\n      SET &MSK1 = +\n        &NRSTR(//........  DD UNIT=DISK,)\n      SET &MSK2 = +\n        &NRSTR(//             VOLUME=SER=......,)\n      SET &MSK3 = +\n        &NRSTR(//             DSNAME=.......................,)\n      IF &STR(&APARM.) = &STR(PO) THEN +\n        SET &MSK4 = &NRSTR(//             SPACE=(CYL,(1,1,5)),)\n      ELSE SET &MSK4 = &NRSTR(//             SPACE=(CYL,(1,1)),)\n      SET &MSK5 = +\n        &NRSTR(//             DCB=(RECFM=FB,BLKSIZE=3120,LRECL=80),)\n      SET &MSK6 = +\n        &NRSTR(//             DISP=(NEW,CATLG))\n      SET &SKM = 6\n      END\n/* --- TA SKELETON  - - - - - - - - - - - - - - - - - - - - - - --- */\n  ELSE IF &STR(&APARM.) = &STR(TA) THEN DO\n      SET &MSK1 = +\n        &NRSTR(//........  DD UNIT=(TAPE,,DEFER),)\n      SET &MSK2 = +\n        &NRSTR(//             VOLUME=(PRIVATE,RETAIN,SER=......),)\n      SET &MSK3 = +\n        &NRSTR(//             DSNAME=.......................,)\n      SET &MSK4 = +\n        &NRSTR(//             LABEL=(1,SL,,OUT),)\n      SET &MSK5 = +\n        &NRSTR(//             DCB=(RECFM=FB,BLKSIZE=3120,LRECL=80),)\n      SET &MSK6 = +\n        &NRSTR(//             DISP=(NEW,PASS))\n      SET &SKM = 6\n      END\n/* --- ASH SKELETON - - - - - - - - - - - - - - - - - - - - - - --- */\n  ELSE IF &STR(&APARM.) = &STR(ASH) THEN DO\n      SET &MSKN = +\n        &NRSTR(//ASS     EXEC PGM=IEV90,)\n      SET &MSK1 = +\n        &NRSTR(&MSKN.PARM='XREF(SHORT),NODECK,OBJECT')\n      SET &MSK2 = +\n        &NRSTR(//SYSLIB    DD DSN=.......................,DISP=SHR)\n      SET &MSK3 = +\n        &NRSTR(//          DD DSN=SYS1.MACLIB,DISP=SHR)\n      SET &MSK4 = +\n        &NRSTR(//          DD DSN=SYS1.MODGEN,DISP=SHR)\n      SET &MSKN = +\n        &NRSTR(//SYSUT1    DD UNIT=VIO,DSN=&&&&SYSUT1,)\n      SET &MSK5 = +\n        &NRSTR(&MSKN.SPACE=(CYL,(10,5)))\n      SET &MSKN = +\n        &NRSTR(//SYSLIN    DD UNIT=SYSDA,)\n      SET &MSK6 = +\n        &NRSTR(&MSKN.SPACE=(CYL,(1,1)),DSN=&&LOADSET,)\n      SET &MSK7 = +\n        &NRSTR(//             DCB=(BLKSIZE=800),DISP=(,PASS,DELETE))\n      SET &MSK8 = +\n        &NRSTR(//SYSPRINT  DD SYSOUT=*)\n      SET &MSKN = +\n        &NRSTR(//SYSIN     DD DSN=.......................)\n      SET &MSK9 = +\n        &NRSTR(&MSKN.(........),DISP=SHR)\n      SET &SKM = 9\n      END\n/* --- LNK SKELETON - - - - - - - - - - - - - - - - - - - - - - --- */\n  ELSE IF &STR(&APARM.) = &STR(LNK) THEN DO\n      SET &MSKN = +\n        &NRSTR(//LNK     EXEC PGM=HEWL,)\n      SET &MSK1 = +\n        &NRSTR(&MSKN.PARM='XREF,LIST,....',COND=(4,LT))\n      SET &MSKN = +\n        &NRSTR(//SYSLMOD   DD UNIT=SYSDA,)\n      SET &MSK2 = +\n        &NRSTR(&MSKN.SPACE=(CYL,(1,1,1)),DSN=&&GOSET,)\n      SET &MSK3 = +\n        &NRSTR(//             DISP=(,PASS,DELETE))\n      SET &MSK4 = +\n        &NRSTR(//SYSADD    DD DSN=.......................,DISP=SHR)\n      SET &MSK5 = +\n        &NRSTR(//SYSUT1    DD UNIT=VIO,SPACE=(CYL,(1,1)))\n      SET &MSK6 = +\n        &NRSTR(//SYSPRINT  DD SYSOUT=* )\n      SET &MSK7 = +\n        &NRSTR(//SYSLIN    DD DSN=&&LOADSET,DISP=(OLD,DELETE,DELETE))\n      SET &MSK8 = +\n        &NRSTR(//          DD *)\n      SET &MSK9 = +\n        &NRSTR(  INCLUDE      SYSADD(........,........,........))\n      SET &MSK10 = +\n        &NRSTR(  ENTRY   ........)\n      SET &MSK11 = +\n        &NRSTR(  NAME    ........(R))\n      SET &MSK12 = +\n        &NRSTR(/*)\n      SET &SKM = 12\n      END\n/* --- XEQ SKELETON - - - - - - - - - - - - - - - - - - - - - - --- */\n  ELSE IF &STR(&APARM.) = &STR(XEQ) THEN DO\n      SET &MSK1 = +\n        &NRSTR(//XEQ     EXEC PGM=........,COND=(4,LT))\n      SET &MSK2 = +\n        &NRSTR(//STEPLIB   DD DSN=&&GOSET,DISP=(OLD,DELETE,DELETE))\n      SET &MSK3 = +\n        &NRSTR(//SYSPRINT  DD SYSOUT=*)\n      SET &MSK4 = +\n        &NRSTR(//SYSUDUMP  DD SYSOUT=*)\n      SET &MSK5 = +\n        &NRSTR(//SYSIN     DD ...)\n      SET &SKM = 5\n      END\n/* --- CPY SKELETON - - - - - - - - - - - - - - - - - - - - - - --- */\n  ELSE IF &STR(&APARM.) = &STR(CPY) THEN DO\n      SET &MSK1 = +\n        &NRSTR(//COPY    EXEC PGM=IEBCOPY,PARM=(SIZE=100K))\n      SET &MSK2 = +\n        &NRSTR(//FROM      DD ...FROM DATA-SET...)\n      SET &MSK3 = +\n        &NRSTR(//TO        DD ...TO DATA-SET...)\n      SET &MSK4 = +\n        &NRSTR(//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(1,1)))\n      SET &MSK5 = +\n        &NRSTR(//SYSUT4    DD UNIT=(SYSDA,SEP=SYSUT3),)\n      SET &MSK6 = +\n        &NRSTR(//             SPACE=(CYL,(1,1)),DCB=(KEYLEN=8))\n      SET &MSK7 = +\n        &NRSTR(//SYSPRINT  DD SYSOUT=*)\n      SET &MSK8 = +\n        &NRSTR(//SYSIN     DD *)\n      SET &MSK9 = +\n        &NRSTR(  COPY   OUTDD=TO,INDD=((FROM,R)))\n      SET &MSK10 = +\n        &NRSTR(  SELECT MEMBER=(...,...) <- IF NOT ALL MEMBERS)\n      SET &MSK11 = +\n        &NRSTR(/*)\n      SET &SKM = 11\n      END\n/* --- GEN SKELETON - - - - - - - - - - - - - - - - - - - - - - --- */\n  ELSE IF &STR(&APARM.) = &STR(GEN) THEN DO\n      SET &MSK1 = +\n        &NRSTR(//GENER   EXEC PGM=IEBGENER)\n      SET &MSK2 = +\n        &NRSTR(//SYSUT1    DD ...FROM DATA-SET...)\n      SET &MSK3 = +\n        &NRSTR(//SYSUT2    DD ...TO DATA-SET...)\n      SET &MSK4 = +\n        &NRSTR(//SYSPRINT  DD SYSOUT=*)\n      SET &MSK5 = +\n        &NRSTR(//SYSIN     DD DUMMY <- IF ...TO DATA-SET... IS A PS)\n      SET &MSK6 = +\n        &NRSTR(//SYSIN     DD *     <- IF ...TO DATA-SET... IS A PO)\n      SET &MSK7 = +\n        &NRSTR(  GENERATE  MAXNAME=... <- NUMBER OF MEMBERS)\n      SET &MSK8 = +\n        &NRSTR(  MEMBER    NAME=(...,...))\n      SET &MSK9 = +\n        &NRSTR(/*)\n      SET &SKM = 9\n      END\n  ELSE DO\n    SET ZEDSMSG = INVALID OPERAND\n    SET ZEDLMSG = USE HELP OR H TO CHECK VALID OPERAND REQUEST\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(12)\n    END\n  ISREDIT PROCESS DEST\n  IF &LASTCC = 0 THEN DO\n    ISREDIT LOCATE .ZDEST\n    IF &LASTCC = 8 THEN GOTO EMPTY\n    ISREDIT SCAN OFF\n    ISREDIT MASKLINE = \"&MSK1\"\n    ISREDIT LINE_AFTER .ZDEST = MASKLINE\n    IF &SKM > 1 THEN DO\n      SET &SKI = 1\n      DO WHILE &SKI LT &SKM\n        ISREDIT (LINEPTR) = LINENUM .ZDEST\n        SET &LINEPTR = &LINEPTR + &SKI\n        SET &SKI = &SKI + 1\n        SET &MSKN = &NRSTR(&SKC.MSK&SKI)\n        ISREDIT MASKLINE = \"&MSKN\"\n        ISREDIT LINE_AFTER &LINEPTR = MASKLINE\n        END\n      END\n    END\n  ELSE DO\nEMPTY: ISREDIT SCAN OFF\n    ISREDIT MASKLINE = \"&MSK1\"\n    ISREDIT LINE_AFTER 0 = MASKLINE\n    IF &SKM > 1 THEN DO\n      SET &SKI = 1\n      DO WHILE &SKI LT &SKM\n        ISREDIT (LINEPTR) = LINENUM .ZCSR\n        SET &LINEPTR = .ZLAST\n        SET &SKW = &SKI + 1\n        SET &MSKN = &NRSTR(&SKC.MSK&SKW)\n        ISREDIT MASKLINE = \"&MSKN\"\n        ISREDIT LINE_AFTER &SKI = MASKLINE\n        SET &SKI = &SKW\n        END\n      END\n    END\n  ISREDIT SCAN ON\n  ISREDIT MASKLINE = \" \"\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SKEL@": {"ttr": 34318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\x14\\x17\\x00(\\x00(\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T14:17:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SYSPAJA"}, "text": "1   25/10/94\n                                                      SKEL      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     SKEL ISPF/PDF EDIT command      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to insert JCL skeletons.\n  ----------\n\n  Command syntax : SKEL ... or SKEL HELP or H\n  ---------------- (see below for the possible ... operand requests)\n\n  Use :        Type SKEL ... on the COMMAND line, and the desired JCL\n  -----        skeleton will be inserted at the top of data. If you\n               desire it somewhere other than the top of data, type A\n               (after) or B (before) on the line number at the point in\n               the data you want insert the skeleton, as i.e. :\n               COMMAND ===> SKEL TA\n                   ---> A 0600   Data ...\n                        000700   Data ...\n               Result : the tape JCL skeleton would be inserted after\n                        line 600.\n               Identical process is obtained with :\n                   ---> B 0700   Data ...\n\n  Available JCL skeletons :\n  =========================\n  Operand  insertion of\n  -------  -----------------------------------------------------------\n   PO      DD-disk with DSORG=PO\n   PS      DD-disk with DSORG=PS\n   TA      DD-tape\n   ASH     Assembler H step\n   LNK     Link-Edit step\n   XEQ     Execution step\n   CPY     IEBCOPY execution step\n   GEN     IEBGENER execution step\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SKELCHK": {"ttr": 34320, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"\\x9f\\x00\\x94\"\\x9f\\x14W\\x00c\\x00c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-17T00:00:00", "modifydate": "1994-08-17T14:57:00", "lines": 99, "newlines": 99, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM)\n/*  MACRO NAME : SKELCHK                                            */\n/*    FUNCTION : IDENTIFY ISPF SKELETON \")SEL\" AND \")ENDSEL\"        */\n/*               MISMATCHES. IF NO MISMATCHES EXIST, ALL            */\n/*               \")SEL-)ENDSEL\" PAIRS WILL BE MATCHED AND           */\n/*               IDENTIFIED WITH A COMMENT IN COLUMNS 55-71.        */\n/*      SYNTAX : SKELCHK                                            */\n/*               SKELCHK HELP OR H                                  */\n/*       DEBUG : SKELCHK LIST                                       */\n/*      AUTHOR : GARY FRICKEY (NASPA PUBLICATION : TECHNICAL        */\n/*               SUPPORT, VOLUME 6, NUMBER 4, APRIL 1992).          */\n/*               INSTALLED BY : MOINIL P.A.                         */\n         ISPEXEC CONTROL ERRORS RETURN\n         IF &STR(&APARM.) = &STR(HELP) OR +\n           &STR(&APARM.) = &STR(H) THEN DO\n             ISPEXEC CONTROL DISPLAY SAVE\n             ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTSKC)\n             SET &SKCC = &LASTCC\n             ISPEXEC CONTROL DISPLAY RESTORE\n             EXIT CODE(&SKCC)\n             END\n         ELSE IF &STR(&APARM.) = &STR(LIST) THEN +\n           CONTROL LIST CONLIST SYMLIST\n         ELSE IF &STR(&APARM.) \u00ac= &Z THEN DO\n           SET ZEDSMSG = &STR(INVALID OPERAND)\n           SET ZEDLMSG = &STR(ONLY HELP OR H IS ACCEPTED AS OPERAND)\n           ISPEXEC SETMSG MSG(ISRZ000)\n           EXIT CODE(0)\n           END\n         ISREDIT SEEK ')SEL' ALL NX 1 4\n         ISREDIT (SELCNT) = SEEK_COUNTS\n         ISREDIT SEEK ')ENDSEL' ALL NX 1 7\n         ISREDIT (ENDCNT) = SEEK_COUNTS\n         IF &SELCNT = &ENDCNT THEN DO\n           ISREDIT (ROW,COL) = CURSOR\n           ISREDIT EXCLUDE ALL\n           ISREDIT CURSOR = 1 1\n           ISREDIT FIND ')SEL' ALL 1 4\n           ISREDIT CURSOR = 1 1\n           ISREDIT FIND ')ENDSEL' ALL 1 7\n           SET CTR = 0\n           SET FINDCC = 0\n           DO WHILE &FINDCC = 0\n             ISREDIT CURSOR = 1 1\n             SET CTR = &CTR + 1\n             ISREDIT FIND ')ENDSEL' NX 1 7\n             SET FINDCC = &LASTCC\n             IF &FINDCC = 0 THEN DO\n               ISREDIT (ROW,COL) = CURSOR\n               ISREDIT LINE &ROW = +\n                 < 1 ')ENDSEL' 55 '/*' 59 'ENDSEL-&CTR' 70 '*/'>\n               ISREDIT EXCLUDE )SEL PREV\n               ISREDIT (ROW,COL) = CURSOR\n               ISREDIT LINE_BEFORE &ROW = +\n                 < 1 ')CM' 55 '/*' 59 'SEL-&CTR' 70 '*/'>\n               ISREDIT (ROW,COL) = CURSOR\n               SET ROW = &ROW - 2\n               ISREDIT CURSOR = &ROW &COL\n               ISREDIT (HOLDLN) = LINE &ROW\n               SET HOLDLN1 = &SUBSTR(2:4,&HOLDLN)\n               IF &STR(&HOLDLN1) = &STR(CM )THEN DO\n                 SET HOLDLN2 = &SUBSTR(59:62,&HOLDLN)\n                 IF &STR(&HOLDLN2) = &STR(SEL-)THEN DO\n                   ISREDIT DELETE &ROW\n                   END\n                 END\n               ISREDIT EXCLUDE )ENDSEL\n               END\n             END\n           ISREDIT RESET\n           IF &SELCNT = 0 THEN SET ZEDSMSG = &STR(NONE)\n           ELSE SET ZEDSMSG = &STR(O.K.)\n           END\n         ELSE DO\n           ISREDIT EXCLUDE ALL\n           ISREDIT CURSOR = 1 1\n           ISREDIT FIND ')SEL' ALL 1 4\n           ISREDIT CURSOR = 1 1\n           ISREDIT FIND ')ENDSEL' ALL 1 7\n           ISREDIT CURSOR = 1 1\n           SET FINDCC = 0\n           DO WHILE &FINDCC = 0\n             ISREDIT FIND ')ENDSEL' NX 1 7\n             SET FINDCC = &LASTCC\n             IF &FINDCC = 0 THEN DO\n               ISREDIT EXCLUDE )SEL PREV\n               SET EXCLCC = &LASTCC\n               IF &EXCLCC = 0 THEN ISREDIT EXCLUDE )ENDSEL\n               END\n             END\n           SET ZEDSMSG = &STR(ERROR)\n           END\n         SET SELTOT = &SELCNT\n         SET ENDTOT = &ENDCNT\n         SET ZEDLMSG = +\n           &STR(SKELETON CHECK : &SELTOT SEL AND &ENDTOT ENDSEL)\n         ISPEXEC SETMSG MSG(ISRZ001)\n         ISREDIT CURSOR = .ZFIRST 0\n         EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SKELCHK@": {"ttr": 34323, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"\\x9f\\x00\\x94\"\\x9f\\x157\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-17T00:00:00", "modifydate": "1994-08-17T15:37:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "SYSPAJA"}, "text": "1   17/08/94\n                                                      SKELCHK   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    SKELCHK ISPF/PDF EDIT command    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to identify ISPF skeleton\n  ----------   )SEL and )ENDSEL mismatches. If no mismatches exist,\n               all )SEL-)ENDSEL pairs will be matched and identified\n               with a comment in columns 55-71.\n\n  Command syntax : SKELCHK or SKEL HELP or H\n  ----------------\n\n  Author :     Gary FRICKEY (NASPA publication : Technical Support,\n  --------     Volume 6, Number 4, April 1992).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SLINE": {"ttr": 34325, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89%\\x7f\\x00\\x89%\\x7f\\x179\\x00e\\x00e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-09-14T00:00:00", "modifydate": "1989-09-14T17:39:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM,BPARM) NOPROCESS\n/*  MACRO NAME : SLINE                                              */\n/*    FUNCTION : INSERT A SEPARATION LINE                           */\n/*      SYNTAX : SLINE                                              */\n/*               SLINE C=CHARACTER TO BE USED                       */\n/*               SLINE COMMA OR CODEC                               */\n/*               SLINE HELP OR H                                    */\n/*       DEBUG : SLINE ... LIST                                     */\n/*      ORIGIN : CBT TAPE 89 FEB, FILE 95                           */\n/*      UPDATE : SEPARATION CHARACTER ADDED (MOINIL P.A.)           */\n  SET &AMPSD = &STR(&&)\n  SET &LPRTH = &NRSTR((\n  SET &SPLUS = &NRSTR(+)\n  IF &STR(&BPARM.) = &STR(LIST) THEN CONTROL LIST SYMLIST CONLIST\n  IF &NRSTR(&APARM.) = &STR() THEN SET &CH = &STR(-)\n  SET &TL = &LENGTH(&NRSTR(&APARM))\n  IF &TL = 3 OR &TL = 5 THEN DO\n    IF &TL = 3 THEN DO\n      SET &TC = &SUBSTR(1:2,&NRSTR(&APARM))\n      IF &STR(&TC) = &STR(C=) THEN +\n        SET &CH = &SUBSTR(3:3,&NRSTR(&APARM))\n      ELSE DO\n        SET ZEDSMSG = INVALID OPERAND\n        SET ZEDLMSG = ENTER \"SLINE HELP\" COMMAND FOR OPERAND SYNTAX\n        ISPEXEC SETMSG MSG(ISRZ000)\n        EXIT CODE(0)\n        END\n      END\n    ELSE DO\n      IF &NRSTR(&APARM.) = &STR(COMMA) THEN SET &CH = &NRSTR(,)\n      IF &NRSTR(&APARM.) = &STR(CODEC) THEN DO\n        ISPEXEC VGET (ZDEL) PROFILE\n        SET &CH = &ZDEL\n        END\n      ELSE DO\n        SET ZEDSMSG = INVALID OPERAND\n        SET ZEDLMSG = ENTER \"SLINE HELP\" COMMAND FOR OPERAND SYNTAX\n        ISPEXEC SETMSG MSG(ISRZ000)\n        EXIT CODE(0)\n        END\n      END\n    END\n  ELSE IF &NRSTR(&APARM.) \u00ac= &STR() THEN DO\n    IF &NRSTR(&APARM.) = &STR(HELP) OR +\n      &NRSTR(&APARM.) = &STR(H) THEN DO\n        ISPEXEC CONTROL DISPLAY SAVE\n        ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTSEPL)\n        SET &RCX = &LASTCC\n        ISPEXEC CONTROL DISPLAY RESTORE\n        EXIT CODE(&RCX)\n        END\n    ELSE DO\n      SET ZEDSMSG = INVALID OPERAND\n      SET ZEDLMSG = ENTER \"SLINE HELP\" COMMAND FOR OPERAND SYNTAX\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ISREDIT (THIS) = MEMBER\n  ISREDIT PROCESS DEST\n  IF &LASTCC = 0 THEN DO\n    ISREDIT LOCATE .ZDEST\n    IF &LASTCC = 8 THEN DO\n      SET ZEDSMSG = &STR(EMPTY DATA)\n      SET ZEDLMSG = &STR(SLINE NEEDS VALID DATA LINE NUMBERS)\n      ISPEXEC SETMSG MSG(ISRZ001)\n      EXIT CODE(12)\n      END\n    ISREDIT (LN) = LRECL\n    SET &RULE1 = &NRSTR(&CH&CH&CH&CH&CH&CH&CH&CH&CH&CH)\n    SET &RULE2 = &NRSTR(&RULE1&RULE1&RULE1&RULE1)\n    SET &RULE3 = &NRSTR(&RULE2&RULE2&RULE2&RULE2&RULE2&RULE2&RULE2)\n    IF &NRSTR(&CH) = &NRSTR(&AMPSD) THEN DO\n      SET &RULE4 = &NRSTR(&RULE3&RULE3)\n      SET &LL = 2*&LN\n      SET &RULES = &SUBSTR(1:&LL,&NRSTR(&RULE4))\n      END\n    ELSE SET &RULES = &SUBSTR(1:&LN,&NRSTR(&RULE3))\n    IF &NRSTR(&CH) = &STR(=) OR +\n      &NRSTR(&CH) = &STR(,) OR +\n      &NRSTR(&CH) = &NRSTR(&SPLUS) OR +\n      &NRSTR(&CH) = &NRSTR(&LPRTH) THEN +\n      ISREDIT LINE_AFTER .ZDEST = '&NRSTR(&RULES)'\n    ELSE ISREDIT LINE_AFTER .ZDEST = &NRSTR(&RULES)\nERROROUT: ISREDIT MASKLINE = ' '\n    SET RC = 0\n    END\n  ELSE DO\n    IF &MAXCC = 8 THEN DO\n      SET ZEDSMSG = &STR(SAY WHERE)\n      SET ZEDLMSG = &STR(USE 'A' OR 'B' TO INDICATE WHERE +\n                         LINE SHOULD BE INSERTED)\n      END\n    ELSE DO\n      SET ZEDSMSG = &STR(PROCESS ERROR)\n      SET ZEDLMSG = &STR(UNABLE TO PROCESS REQUEST, RECHECK INPUT)\n      END\n    ISPEXEC SETMSG MSG(ISRZ000)\n    SET RC = 12\n    END\nEXIT CODE(&RC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SLINE@": {"ttr": 34562, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x11X\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T11:58:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SYSPAJA"}, "text": "1   07/08/89\n                                                      SLINE     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     SLINE ISPF/PDF EDIT command     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to place a separation line\n  ----------   in the data being edited at the point designated by the\n               A or B range command.\n\n  Command syntax : SLINE or SLINE C=character\n  ----------------       (if not specified, default is -)\n                   SLINE COMMA or CODEC\n                         (to use a comma \",\" or the command delimiter\n                          character, see ISPF option 0.1)\n                   SLINE HELP or H\n\n  Use :        Type SLINE on the COMMAND line and an A or B on the\n  -----        target line number, as i.e. :\n               COMMAND ===> SLINE\n               000500   Title : ...\n          ---> A 0600           ...\n               000700   Subtitle : ...\n               000800              ...\n               Result : a separation line of \"-\" will be inserted\n                        between lines 600 and 700.\n                        Identical process is obtained with :\n          ---> B 0700   Subtitle : ...\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRCHRPI": {"ttr": 34564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\x10\\x17\\x00\\xae\\x00\\xae\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T10:17:00", "lines": 174, "newlines": 174, "modlines": 0, "user": "SYSPAJA"}, "text": "SRPI     TITLE 'SEARCH A REPLY PENDING IDENTIFICATION ROUTINE.'\nSRCHRPI  START 0\n         SPACE 1\n* CALLING SEQUENCE : CALL SRCHRPI,(A,B,C),VL\n* ------------------              (A,B)\n*\n*        WHERE : A - IS THE ADDRESS OF A 1-BYTE FIELD CONTAINING THE\n*                    LENGTH-1 OF THE IMMEDIATELY FOLLOWING CHARACTERS\n*                    FIELD GIVING THE REPLY MESSAGE IDENTIFICATION\n*                    TEXT (MUST BE AT LEAST 8-CHARACTERS LONG) USED\n*                    TO FIND THE PENDING REPLY.\n*                    I.E. : R1 --> DC A(A) -->    A DC AL1(L'TEXT-1)\n*                                              TEXT DC C'...'\n*\n*                B - IS THE ADDRESS OF A 2-CHARACTERS FIELD INTO WHICH\n*                    THE REQUESTED PENDING REPLY-ID NUMBER IS EDITED.\n*\n*                C - RECEIVES THE RETURN CODE (FORMAT FULLWORD -\n*                    F BOUNDARY) IF SUPPLIED (OPTIONAL).\n*\n*        RETURN CODES (REGISTER 15) :\n*\n*                        0 = REPLY-ID NUMBER EDITED.\n*                        4 = PENDING REPLY NOT FOUND.\n*                        8 = CALLING SEQUENCE, PARAMETER ALIGNMENT OR\n*                            INVALID ERROR.\n*\n* MODULE ATTRIBUTE : THIS ROUTINE IS RE-ENTERABLE.\n* ------------------\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         EJECT\n         LR    R2,R1\n         LR    R11,R13\n         USING WRKDSECT,R11\n         LA    R14,SVA+(18*4)      CLEAR WORK AREA\n         L     R15,=A(WRKL-(18*4))\n         XR    R0,R0\n         LR    R1,R0\n         MVCL  R14,R0\n         SPACE 1\n         XR    R7,R7               GET ARGUMENTS ADDRESSES\n         LR    R8,R7\n         LR    R9,R7\n         LR    R10,R7\n         TM    0(R2),X'80'\n         BO    ERSA\n         TM    4(R2),X'80'\n         BO    GADD\n         TM    8(R2),X'80'\n         BZ    ERSA\n         TM    11(R2),X'03'\n         BNZ   ERSA\n         L     R9,8(R2)\n         LA    R9,0(R9)\nGADD     L     R8,4(R2)\n         LA    R8,0(R8)\n         L     R7,0(R2)\n         LA    R7,0(R7)\n         CLI   0(R7),7\n         BL    ERSA\n         L     R1,CVTPTR           CVT POINTER\n         L     R1,CVTCUCB-CVT(R1)  UCM BASE POINTER\n         USING UCM,R1\n         MVC   CONASID+2(2),UCMCTID     GET COMMTASK ASID\n         DROP  R1\n        ZEROKEY ,\n        ESAR   R6                  GET SECONDARY ASID\n         ST    R6,SASID            KEEP IT\n         MVC   AXPL(4),=AL2(1,0)\n        AXRES  AXLIST=AXPL         RESERVE AX\n         L     R6,CONASID          GET COMMTASK ASID\n        AXEXT  ASID=(6)            EXTRACT AX OF CONSOLE IN R0\n        AXSET  AX=(0)              SET AX TO ALLOW CONSOLE AS 2ND\n        RESETKEY ,\n         L     R1,CVTPTR           BEGINNING  OF ORE CHAIN\n         L     R1,CVTCUCB-CVT(R1)\n         USING UCM,R1\n         L     R2,UCMRPYQ          ADDRESS OF FIRST ORE (REPLY-Q)\n         DROP  R1\nSTOR0    LTR   R2,R2\n         BZ    NOTFND              NO ORE CHAIN OR END OF ORE CHAIN\n         LA    R3,OREWA            THE 'TO' ADDRESS\n         LA    R4,ORESIZE          LENGTH OF THE 'TO'\n        ZEROKEY ,\n         L     R6,CONASID          GET COMMTASK ASID\n        SSAR   R6                  SET CONSOLE AS SECONDARY\n         SR    R15,R15             ZERO R15 FOR 'FROM' KEY\nSTOR1   MVCP   0(R4,R3),0(R2),R15  MOVE IT\n         BZ    STOR2\n         AL    R2,=F'256'          BUMP 'FROM' ADDRESS BY 256\n         AL    R3,=F'256'          BUMP 'TO' ADDRESS BY 256\n         SL    R4,=F'256'          DECREMENT LENGTH OF MOVE LEFT\n         B     STOR1               GO BACK AGAIN\nSTOR2    L     R6,SASID            RESTORE PREVIOUS SECONDARY\n        SSAR   R6                  SHOULD BE AS PRIMARY\n        RESETKEY ,\n         LA    R3,OREWA            ORE AREA ADDRESS\n         USING OREF,R3\n         CLC   ORECBID,=CL4'ORE '  CHECK BLOCK-ID\n         BNE   NOTFND              NO... STOP HERE?\n         L     R2,ORERWQE          WQE ADDRESS\n         LTR   R2,R2               ANY ONE?\n         BZ    NOTFND              NO... STOP HERE\n         LA    R5,WQEWA            THE 'TO' ADDRESS\n         LA    R4,WQETXTL-WQE      LENGTH OF THE 'TO'\n        ZEROKEY ,\n         L     R6,CONASID          GET COMMTASK ASID\n        SSAR   R6                  SET CONSOLE AS SECONDARY\n         SR    R15,R15             ZERO R15 FOR 'FROM' KEY\nSTOR3   MVCP   0(R4,R5),0(R2),R15  MOVE IT\n         BZ    STOR4\n         AL    R2,=F'256'          BUMP 'FROM' ADDRESS BY 256\n         AL    R5,=F'256'          BUMP 'TO' ADDRESS BY 256\n         SL    R4,=F'256'          DECREMENT LENGTH OF MOVE LEFT\n         B     STOR3               GO BACK AGAIN\nSTOR4    L     R6,SASID            RESTORE PREVIOUS SECONDARY\n        SSAR   R6                  SHOULD BE AS PRIMARY\n        RESETKEY ,\n         LA    R5,WQEWA            WQE AREA ADDRESS\n         USING WQE,R5\n         CLC   OREID(L'OREID),WQETXT+1  REPLY-ID MATCH?\n         BNE   STOR5               NO... BYPASS IT\n         L     R0,WQENBR           MESSAGE TEXT LENGTH\n         SH    R0,=H'5'\n         XR    R1,R1\n         IC    R1,0(R7)            COMPARE LENGTH\n         CLR   R1,R0               CAN COMPARE TEXT?\n         BH    STOR5               NO... BYPASS IT\n         EX    R1,CHKRQ            IS IT THE REQUESTED TEXT?\n         BE    STOR6               YES\nSTOR5    L     R2,ORELKP           LINKAGE POINTER\n         B     STOR0\nCHKRQ    CLC   1(*-*,R7),WQETXT+4  <<EXECUTED>>\nSTOR6    MVC   0(L'OREID,R8),OREID SET REPLY-ID NUMBER\n         DROP  R3,R5\n         B     STORX\nNOTFND   LA    R10,4\nSTORX   ZEROKEY ,\n        AXFRE  AXLIST=AXPL         FREE AX\n        RESETKEY ,\n         B     LEAVE\nERSA     LA    R10,8\nLEAVE    LTR   R9,R9\n         BZ    EXIT\n         ST    R10,0(R9)           STORE INDICATOR\nEXIT    $XRET  CC=(R10),LV=WRKL,TYPE=RENT\n         SPACE 2\n        LTORG\n         EJECT\nWRKDSECT DSECT                     WORK AREAS DESCRIPTION\n         SPACE 1\nSVA      DS    18F                 SAVE AREA\nAXPL     DS    2H                  AX PARM LIST\nSASID    DS    F                   PREVIOUS SECONDARY ASID\nCONASID  DS    F                   'CONSOLE' ASID (COMMTASK)\nOREWA    DS    (((ORESIZE+7)/8)*8)X     ORE AREA\nWQEWA    DS    ((((WQEXA-WQE)+7)/8)*8)X WQE AREA\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH\n         SPACE 2\n        PRINT  NOGEN\n        CVT    DSECT=YES,LIST=YES\n        IEECUCM\n        IHAORE\n        IHAWQE\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SRCHRPI$": {"ttr": 34568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "//SRCHRPI  JOB (........),'INSTALL - SRCHRPI -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=SRCHRPI\n//LNK     EXEC PAJILKR,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   SRCHRPI\n  NAME    SRCHRPI(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SRCHRPI@": {"ttr": 34570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\t'\\x00*\\x00*\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T09:27:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SYSPAJA"}, "text": "1   30/06/88\n                                                      SRCHRPI   1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       SEARCH A REPLY PENDING        * * * * * * * *\n  * * * * * * * *       IDENTIFICATION ROUTINE.       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n  Calling sequence : CALL SRCHRPI,(A,B,C),VL\n  ------------------              (A,B)\n\n         Where : A - is the address of a 1-byte field containing the\n                     length-1 of the immediately following characters\n                     field giving the reply message identification\n                     text (must be at least 8-characters long) used\n                     to find the pending reply.\n                     I.e. : R1 --> DC A(A) -->    A DC AL1(L'TEXT-1)\n                                               TEXT DC C'...'\n\n                 B - is the address of a 2-characters field into which\n                     the requested pending reply-ID number is edited.\n\n                 C - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional). Value is always\n                     placed in register 15 and can be :\n\n                          0 = reply-ID number edited.\n                          4 = pending reply not found.\n                          8 = calling sequence, parameter alignment or\n                              invalid error.\n\n  Assembler macro : $SRPI A,B,C\n  -----------------\n\n         Where C is optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  General notice : This subroutine is reentrant.\n  ----------------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCMD": {"ttr": 34572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\x10\"\\x00\\xec\\x00\\xec\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T10:22:00", "lines": 236, "newlines": 236, "modlines": 0, "user": "SYSPAJA"}, "text": "SSCS     TITLE 'SEND A SYSTEM COMMAND SUBROUTINE.'\nSSCMD    START 0\n         SPACE 1\n* CALLING SEQUENCE : CALL SSCMD,(A,B,C),VL\n* ------------------            (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE AREA CONTAINING THE SYSTEM\n*                    COMMAND TEXT.\n*\n*                B - IS THE ADDRESS OF THE SYSTEM COMMAND TEXT AREA\n*                    LENGTH (NUMBER OF CHARACTERS, FORMAT FULLWORD -\n*                    F BOUNDARY). WHEN THIS ARGUMENT IS OMITTED, OR\n*                    THE ADDRESS OF THIS ARGUMENT IS SET TO ZERO IN\n*                    THE PARAMETERS LIST, THE LENGTH OF THE TEXT AREA\n*                    IS SUPPOSED TO BE IN FRONT OF THE TEXT AREA, AT\n*                    THE ADDRESS OF A-1 (FORMAT XL1).\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                         0 = COMMAND SENDED CORRECTLY.\n*                    LT 256 = SVC 34 RETURN CODE.\n*                       256 = COMMAND TEXT LENGTH IS ZERO.\n*                       260 = COMMAND TEXT IS ALL BLANKS.\n*                       264 = COMMAND TEXT LENGTH GREATER THAN 126.\n*                       268 = CALLING SEQUENCE OR PARAMETER ALIGNMENT\n*                             ERROR.\n*                       272 = UNAUTHORIZED CALLER.\n*\n* GENERAL NOTICE : THIS SUBROUTINE IS REENTRANT.\n* ================ ONLY A SYSTEM OR STARTED TASK MAY USE THIS ROUTINE.\n*                  THE SYSTEM COMMAND TEXT IS EXTRACTED FROM THE AREA\n*                  ELIMINATING ALL EVENTUAL STARTING AND/OR TRAILING\n*                  BLANKS, THEN IT CANNOT BE MORE THAN 126 CHARACTERS\n*                  LONG. ALL COMMANDS SENDED TO THE SYSTEM ARE LOGGED\n*                  ON 'SYSLOG' WITH THE SENDER NAME.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R11,R13\n         USING WRKDSECT,R11        WORK AREAS ADDRESSABILITY\n         EJECT\n         XR    R7,R7\n         XR    R8,R8\n         XR    R9,R9\n         XR    R10,R10\n         TM    0(R1),X'80'\n         BO    SSC1\n         TM    7(R1),X'03'\n         BNZ   ER268\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         TM    4(R1),X'80'\n         BO    SSC1\n         TM    8(R1),X'80'\n         BZ    ER268\n         TM    11(R1),X'03'\n         BNZ   ER268\n         L     R9,8(R1)\n         LA    R9,0(R9)\nSSC1     L     R7,0(R1)\n         LA    R7,0(R7)\n         LTR   R8,R8\n         BNZ   SSC2\n         LR    R8,R7\n         BCTR  R8,0\n         XR    R3,R3\n         ICM   R3,B'0001',0(R8)\n         BNZ   SSC3\n         B     ER256\nSSC2     L     R3,0(R8)\n         LTR   R3,R3\n         BNP   ER256\nSSC3     LA    R5,0(R7,R3)\n         BCTR  R5,0\n         LA    R4,1\nSSC4     CLI   0(R7),C' '          ELIMINE STARTING BLANKS IF ANY\n         BNE   SSC5\n         BCT   R3,*+L'*+4\n         B     ER260\n         BXLE  R7,R4,SSC4\n         B     ER260\nSSC5     CLI   0(R5),C' '          ELIMINE TRAILING BLANKS IF ANY\n         BNE   SSC6\n         BCTR  R5,0\n         BCT   R3,SSC5\n         B     ER260\nSSC6     CH    R3,=Y(L'MGCRTEXT)\n         BH    ER264\n         MVC   SLOG(SLOGL),SLOGSK\n         XC    SLOGMS,SLOGMS\n         LR    R4,R3\n         CH    R4,=Y(SLOGLT)\n         BNH   *+L'*+4\n         LH    R4,=Y(SLOGLT)\n         BCT   R4,*+L'*+6          DO EXECUTE LENGTH\n         MVC   SLOGMS(*-*),0(R7)   <<EXECUTED>>\n         EX    R4,*-6              MOVE COMMAND TEXT TO LOG\n         LA    R1,SLOGL+1(R4)\n         STH   R1,SLOG             SET LENGTH FOR WTL\n         MVI   SWITCH,0\n         L     R4,CVTPTR\n         USING CVT,R4\n         L     R5,CVTTCBP\n         DROP  R4\n         L     R4,4(R5)\n         USING TCB,R4\n         L     R5,TCBJSCB\n         USING IEZJSCB,R5\n         ICM   R6,B'1111',JSCBCSCB GET THE CSCB ADDRESS\n         BZ    SSC10               CSCB MISSING, SYSTEM TASK\n         USING CSCB,R6\n         ICM   R1,B'0111',CHUNIT   ANY UNIT NAME?\n         BNZ   SSC10               YES, STARTED TASK\n         CLI   CHTRKID,CHSASID     SYSTEM A.S.?\n         BE    SSC10               YES\n         CLI   CHTRKID,CHINITID    INITIATOR?\n         BNE   ER272               NO\n         DROP  R6\nSSC10    TM    JSCBOPTS,JSCBAUTH   AUTHORIZED?\n         BZ    *+L'*+4             NO\n         OI    SWITCH,PPAUTH       YES, ALREADY AUTHORIZED\n         DROP  R5\n         L     R5,TCBRBP\n         USING RBBASIC,R5\n         TM    RBOPSWB2,RBOPSWPS   PROBLEM STATE?\n         BO    *+L'*+4             YES\n         OI    SWITCH,PPSUPM       NO, ALREADY SUPERVISOR MODE\n         DROP  R5\n         L     R5,TCBTIO           GET TIOT ADDRESS\n         DROP  R4\n         USING TIODSECT,R5\n         MVC   SLOGNM,TIOCNJOB     SET NAME TO LOG\n         DROP  R5\n         LA    R2,CMND             COMMAND BUFFER ADDRESS\n         USING MGCRPL,R2\n         XC    MGCRPL(MGCRLTH),MGCRPL   CLEAR PARAMETER LIST\n         MVI   MGCRFLG1,MGCRFI     SET MGCRFLG2 VALID\n         BCT   R3,*+L'*+6          DO EXECUTE LENGTH\n         MVC   MGCRTEXT(*-*),0(R7) <<EXECUTED>>\n         EX    R3,*-6              MOVE COMMAND TEXT\n         LA    R1,(MGCRTEXT-MGCRPL)+1(R3)\n         STC   R1,MGCRLGTH         SET LENGTH IN MGCRPL\n         DROP  R2\n        WTL    MF=(E,SLOG)         LOG THE COMMAND\n         TM    SWITCH,PPAUTH\n         BO    SSC20\n        SETAUTH ,                  SET AUTHORIZATION ON\nSSC20    TM    SWITCH,PPSUPM\n         BO    SSC21\n        MODESET MODE=SUP           ENTER SUPERVISOR MODE\nSSC21    XR    R2,R2\n        MODESET EXTKEY=ZERO,SAVEKEY=(2) ENTER KEY ZERO\n         XR    R0,R0               SEND COMMAND\n         XR    R15,R15\n        MGCR   CMND\n         LR    R10,R15             GET RETURN CODE\n        MODESET KEYADDR=(2)        RE-ENTER PROBLEM KEY\n         TM    SWITCH,PPSUPM\n         BO    SSC22\n        MODESET MODE=PROB          RE-ENTER PROBLEM MODE\nSSC22    TM    SWITCH,PPAUTH\n         BO    SSC80\n        RESAUTH ,                  SET AUTHORIZATION OFF\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* NOTE - MVS/XA (MVS/SP 2.1.3) :                                      *\n*        THE FOUR INSTRUCTIONS BELOW ARE ADDED JUST BECAUSE SOME      *\n*        OPERATORS COMMANDS (LIKE VARY B20,MSTCONS), PASSED THROUGH   *\n*        SVC 34, GIVES BACK AN ADDRESS INTO MODULE 'IEE0003D' INSTEAD *\n*        OF A RETURN CODE IN THE REGISTER 15 (DIAGNOSE HAS BEEN DONE  *\n*        USING DIDOCS).                                               *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nSSC80    CL    R10,=F'256'         R.C. CONTROL\n         BL    SSC90               OK\n         XR    R10,R10             RESET\nSSC90    LTR   R9,R9\n         BZ    *+L'*+4\n         ST    R10,0(R9)           STORE INDICATOR\n        $XRET  CC=(R10),LV=WRKL,TYPE=RENT\nER272    LA    R10,4(R10)\nER268    LA    R10,4(R10)\nER264    LA    R10,4(R10)\nER260    LA    R10,4(R10)\nER256    LA    R10,256(R10)\n         B     SSC90\n         EJECT\n*        CONSTANTS.\n*        ----------\n         SPACE 1\nSLOGSK  WTL    '==>J-         : ',MF=L  SYSTEM LOG INFO\n         SPACE 2\n        LTORG\n         SPACE 2\n         DROP  R11,R12\n         EJECT\n*        DSECT DEFINITIONS.\n*        ------------------\n         SPACE 1\nWRKDSECT DSECT ,                   WORK AREAS\n         DC    18F'0'              SAVE AREA\n         SPACE 1\nCMND     DC    0F'0',XL(MGCRLTH)'0'     OPERATOR COMMANDS BUFFER\nSLOG    WTL    '==>J-         : ',MF=L  SYSTEM LOG INFO\nSLOGL    EQU   *-SLOG\nSLOGLT   EQU   L'MGCRTEXT-(SLOGL-4)\nSLOGNM   EQU   SLOG+9,8\nSLOGMS   DC    XL(SLOGLT)'0'\n         SPACE 1\nSWITCH   DC    XL1'0'              PROCESSING SWITCHES\nPPAUTH   EQU   X'80'                    PP ALREADY AUTHORIZED\nPPSUPM   EQU   X'40'                    PP ALREADY SUPERVISOR MODE\n         SPACE 1\nWRKL     EQU   (((*-WRKDSECT)+7)/8)*8\n         SPACE 2\n        PRINT  NOGEN\nTIODSECT DSECT\n        IEFTIOT1\n        CVT    DSECT=YES,LIST=YES\n        IKJTCB\n        IHARB\n        IEZJSCB\nCSCB     DSECT\n        IEECHAIN\n        IEZMGCR\n        PRINT  GEN\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SSCMD$": {"ttr": 34577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "//SSCMD    JOB (........),'INSTALL - SSCMD -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=SSCMD\n//LNK     EXEC PAJILKR,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   SSCMD\n  NAME    SSCMD(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SSCMD@": {"ttr": 34817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x08_\\x00\\x88\\x08_\\x11Q\\x003\\x003\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-25T00:00:00", "modifydate": "1988-03-25T11:51:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "SYSPAJA"}, "text": "1   25/03/88\n                                                      SSCMD     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *  SEND A SYSTEM COMMAND SUBROUTINE.  * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n  Calling sequence : CALL SSCMD,(A,B,C),VL\n  ------------------            (A,B)\n                                (A)\n\n         Where : A - is the address of the area containing the system\n                     command text.\n\n                 B - is the address of the system command text area\n                     length (no. of characters : format FULLWORD _ F\n                     boundary). When this argument is omitted, or the\n                     address of this argument is set to zero in the\n                     parameters list, the length of the text area is\n                     supposed to be in front of the text area, at the\n                     address of A-1 (format XL1).\n\n                 C - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional). Value is always\n                     placed in register 15 and can be :\n\n                          0 = command sended.\n                     LT 256 = SVC 34 return code.\n                        256 = command text length is zero.\n                        260 = command text is all blanks.\n                        264 = command text length greater than 126.\n                        268 = calling sequence or parameter alignment\n                              error.\n                        272 = unauthorized caller.\n\n  Assembler macro : $SSCMD A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  General notice : This subroutine is reentrant.\n  ---------------- Only a system or started task may use this routine.\n                   The system command text is extracted from the area\n                   eliminating all eventual starting and/or trailing\n                   blanks, then it cannot be more than 126 characters\n                   long. All commands sended to the system are logged\n                   on SYSLOG with the sender job-name.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCLOK": {"ttr": 34819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x884/\\x00\\x884/\\x12D\\x00g\\x00g\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-07T00:00:00", "modifydate": "1988-12-07T12:44:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "SYSPAJA"}, "text": "STK      TITLE 'CLOCK MEASUREMENT SUBROUTINE.'\nSTCLOK   START 0\n         SPACE 2\n* CALLING SEQUENCE : CALL STCLOK\n* ------------------\n*\n*        STARTING POINT FOR A CLOCK INTERVAL MEASUREMENT.\n*\n* CALLING SEQUENCE : CALL TIME,(A,B),VL\n* ------------------           (A)\n*\n*        WHERE : A AND OPTIONALLY B ARE THE ADDRESSES OF FULLWORDS\n*                (F BOUNDARY) RECEIVING CPU - SRB INTERVAL TIMES\n*                MEASURED BETWEEN THE STARTING POINT ('STCLOK'CALL)\n*                AND THIS POINT ('TIME' CALL).\n*\n* REMARK :     ALL TIMES ARE IN SECONDS.\n* --------     ONE SECOND OF SRB TIME ALLOWS ABOUT 1000 I/O, IT\n*              MAY BE MORE THAN 1000 (TILL 3000), RARELY LESS FOR\n*              AN AMDAHL V8 IN MVS SP1.3 UNDER VM/SP.\n*\n* HOW TO USE :\n* ------------\n*\n*        IF A AND B ARGUMENTS ARE SUPPLIED, YOU GET THE CPU TIME IN\n*              A AND THE SRB TIME IN B FOR THE ELAPSED INTERVAL.\n*        IF A ARGUMENT ONLY, YOU GET THE SUM OF CPU AND SRB TIMES.\n*\n* AUTHOR :     COLOMBO A. (AMDAHL CONSULTANT)\n* --------     MOINIL P.A.\n*              COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\nSTCLOK  AMODE  ANY\nSTCLOK  RMODE  ANY\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12\n*        STORE CPU/SRB TIME STARTING VALUES.\n         SPACE 1\n        $TREQ  R=CU                CPU TIME USED IN THIS STEP.\n         SRDL  R0,12               TO GET MICROSEC IN BIT 63.\n         STM   R0,R1,CPUSTART      CPU TIME USED IN THIS STEP.\n         MVI   CPUSTART,X'4E'      BETTER WITH AN EXPONENT.\n        $TREQ  R=SU                SRB TIME USED IN THIS STEP.\n         SRDL  R0,12               TO GET MICROSEC IN BIT 63.\n         STM   R0,R1,SRBSTART      SRB TIME USED IN THIS STEP.\n         MVI   SRBSTART,X'4E'      BETTER WITH AN EXPONENT.\n         DROP  R12                 DROP ADDRESSABILITY.\n        $XRET  CC=0                GO BACK.\n         EJECT\n*        TIME : GIVE CPU/SRB TIME PASSED FROM LAST STCLOK.\n         SPACE 1\n         ENTRY TIME\n         SPACE 1\nTIME    $XENT  BASE=R12,DT=NO\n         LR    R6,R1               SAVE PARM POINTER\n         STD   R0,FPR0SAVE         SAVE FPR0 FOR OPERATIONS.\n        $TREQ  R=CU                CPU TIME USED FOR THIS STEP.\n         SRDL  R0,12               TO GET MICROSEC IN BIT 63.\n         STM   R0,R1,CPUTRANS      FOR LATER USE.\n         MVI   CPUTRANS,X'4E'      EXPONENT.\n        $TREQ  R=SU                SRB TIME USED FOR THIS STEP.\n         SRDL  R0,12               TO GET MICROSEC IN BIT 63.\n         STM   R0,R1,SRBTRANS      FOR LATER USE.\n         MVI   SRBTRANS,X'4E'      EXPONENT.\n         LD    R0,CPUTRANS         GET CPU TIME.\n         SD    R0,CPUSTART         GET THIS TRANSACTION TIME.\n         STD   R0,CPUTRANS         STORE RESULT IN A WORK AREA.\n         LD    R0,SRBTRANS         GET SRB TIME.\n         SD    R0,SRBSTART         GET THIS TRANSACTION TIME.\n         STD   R0,SRBTRANS         STORE RESULT IN A WORK AREA.\n         TM    0(R6),X'80'         IF ON, ONLY ONE PARAMETER.\n         BNO   TWO                 IF OFF, TWO PARAMETERS.\n         AD    R0,CPUTRANS         SRB+CPU TRANSACTION.\n         STD   R0,CPUTRANS         SRB+CPU TRANSACTION.\n         B     CPUSTORE            STORE SRB+CPU TIME.\nTWO      LD    R0,SRBTRANS         IN WORK REGISTER.\n         AW    R0,AZERO            NORMALIZE.\n         DD    R0,SECFACT          TO GET SECONDS.\n         L     R2,4(R6)            GET ANSWER ADDRESS.\n         STE   R0,0(R2)            GIVE SRB RESULT.\nCPUSTORE LD    R0,CPUTRANS         IN WORK REGISTER.\n         AW    R0,AZERO            NORMALIZE.\n         DD    R0,SECFACT          TO GET SECONDS.\n         L     R2,0(R6)            GET ANSWER ADDRESS.\n         STE   R0,0(R2)            GIVE CPU RESULT.\nGOBACK   LD    R0,FPR0SAVE         RESTORE FPR0.\n        $XRET  CC=0                GO BACK.\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nFPR0SAVE DC    D'0'                SAVE AREA FOR FPR0.\nCPUTRANS DC    D'0'                CPU FOR THIS TRANSACTION.\nSRBTRANS DC    D'0'                SRB FOR THIS TRANSACTION.\nCPUSTART DC    0D'0',X'4E',XL7'0'  CPU TIME USED.\nSRBSTART DC    0D'0',X'4E',XL7'0'  SRB TIME USED.\nAZERO    DC    0D'0',X'4E',XL7'0'  A ZERO FOR NORMALIZATION.\nSECFACT  DC    D'1000000'          SECONDS FACTOR.\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STCLOK$": {"ttr": 34822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "//STCLOK   JOB (........),'INSTALL  - STCLOK -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=STCLOK\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   TIME\n  NAME    STCLOK(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STCLOK@": {"ttr": 34824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x08O\\x00\\x87\\x08O\\x16\\x19\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-03-25T00:00:00", "modifydate": "1987-03-25T16:19:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/03/87\n                                                      STCLOK    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     CLOCK MEASUREMENT - ROUTINE     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL STCLOK\n  ------------------\n\n         Starting point for a clock interval measurement.\n\n  Calling sequence : CALL TIME,(A,B),VL\n  ------------------           (A)\n\n         Where : A and optionally B are the addresses of fullwords\n                 (F boundary) receiving the CPU time in seconds and\n                 the number of I/O in thousands (SRB time in seconds),\n                 floating point single precision expressed, interval\n                 measured between the starting point (STCLOK call)\n                 and this point (TIME call).\n\n  How to use :\n  ------------\n\n         If A and B arguments are supplied, you receive the CPU time\n               in A and the I/O number in B for the elapsed interval.\n         If A argument only, you get the sum CPU time and I/O number.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUJVTA": {"ttr": 34826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x10/\\x00\\x90\\x10/\\t\\x01\\x00E\\x00E\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-04-12T00:00:00", "modifydate": "1990-04-12T09:01:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "SYSPAJA"}, "text": "SUVT     TITLE 'SEARCH IEFUJV - UJVTABLE SUBROUTINE.'\nSUJVTA   START 0\n         SPACE 1\n         ENTRY DUJVTA\n         SPACE 1\n* CALLING SEQUENCES : CALL SUJVTA\n* -------------------\n*\n*        PURPOSE : SEARCH IN IEFUJV MODULE THE UJVTABLE SECTION START\n*                  ADDRESS AND PASS IT BACK TO CALLER.\n*        AT EXIT : R15 = 0 AND R1 = UJVTABLE SECTION START ADDRESS.\n*                      NOTE THAT THE IEFUJV SMF EXIT ROUTINE IS IN THE\n*                      LPA (LLA ADDRESS SPACE).\n*                  R15 = 4 AND R1 = 0 IF UJVTABLE SECTION NOT FOUND\n*                      (DELETE HAS BEEN DONE).\n*\n*                     CALL DUJVTA\n*\n*        PURPOSE : DELETE IEFUJV MODULE (UJVTABLE SECTION) ACCESS.\n*        AT EXIT : R15 = 0\n*\n* GENERAL NOTICE : THIS ROUTINE IS RE-ENTERABLE.\n* ================\n*\n* AUTHOR :     P.A. MOINIL\n* -------      COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 2\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,TYPE=RENT\n        LOAD   EP=IEFUJV\n         LR    R5,R0\n         L     R4,=F'-4'\n         LR    R3,R0\n         SLL   R1,8\n         SRL   R1,8\n         BCTR  R1,0\n         BCTR  R1,0\n         LTR   R1,R1\n         BNP   QUIT\n         SLL   R1,3\n         ALR   R3,R1\nLOOK     CLC   0(8,R3),=CL8'UJVT-PT='\n         BNE   NEXT\n         CLC   12(4,R3),=CL8'UJVT-PT='\n         BE    UJVTFND\nNEXT     BXH   R3,R4,LOOK\nQUIT    DELETE EP=IEFUJV\n         XR    R2,R2\n         LA    R9,4\n         B     LEAVE\nUJVTFND  L     R2,8(R3)\n         XR    R9,R9\nLEAVE    L     R1,4(R13)\n         ST    R2,24(R1)\n        $XRET  CC=(R9),TYPE=RENT\n         DROP  R12\n         SPACE 1\n        LTORG\n         EJECT\n        CNOP   0,8\nDUJVTA  $XENT  BASE=R12,DT=NO,TYPE=RENT\n        DELETE EP=IEFUJV\n        $XRET  CC=0,TYPE=RENT\n         DROP  R12\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUJVTA$": {"ttr": 34828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "//SUJVTA   JOB (........),'INSTALL  - SUJVTA -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                IEFUJV                                             *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,OPT=',RENT',MBR=SUJVTA\n//LNK     EXEC PAJILKR,OPT=',RENT'\n//SYSIN     DD *\n  NAME    SUJVTA(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUM": {"ttr": 34830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\x10\\x00\\x00\\xc2\\x00\\xc2\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T10:00:00", "lines": 194, "newlines": 194, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (TYPE,FIRST,LAST)\n/*  MACRO NAME : SUM                                                */\n/* DESCRIPTION : EDIT MACRO TO SUM A COLUMN OF NUMBERS              */\n/*      AUTHOR : ANDREW CALL                                        */\n/*    MODIFIED : CHANGED FROM 255 VB TO 80 FB  PAUL G. DAVIS        */\n/*               CHANGED TO HANDLE UP TO 3 DECIMAL PLACES           */\n/*               DATE/TIME : 09/11/86 - 86.254 - 13:34              */\n/*  CBT ORIGIN : EXTRACTED FROM CBT TAPE 94 APR, FILE 095           */\n/*  ADAPTED BY : MOINIL P.A.                                        */\n/*    MODIFIED : CHANGED TO SEARCH/SCAN/DISPLAY EUROPEAN NUMBERS    */\n/*               DATE/TIME : 08/09/94 - 94.221 - 17:15              */\n  IF (&STR(&TYPE) EQ &STR(HELP)) OR (&STR(&TYPE) EQ &STR(H)) THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJSUM)\n    SET &SUMCC = &LASTCC\n    ISPEXEC CONTROL DISPLAY RESTORE\n    EXIT CODE(&SUMCC)\n    END\n  ISREDIT (START) = LINENUM .ZFIRST\n  ISREDIT (END) = LINENUM .ZLAST\n  ISREDIT (LEFTM,RIGHTM) = BOUNDS\n  SET TOTAL = 0\n  SET VALID = 0\n  SET INVALID = 0\n  IF &STR(&TYPE) EQ &Z THEN SET TYPE = &STR(ALL)\n  ELSE IF (&STR(&TYPE) EQ &STR(.)) OR +\n    (&DATATYPE(&TYPE) EQ &STR(NUM)) THEN DO\n    SET LAST = &FIRST\n    SET FIRST = &TYPE\n    SET TYPE = &STR(ALL)\n    END\n  IF (&STR(&FIRST) EQ &Z) OR +\n    (&STR(&FIRST) EQ &STR(.)) THEN SET FIRST = &LEFTM\n  ELSE IF &DATATYPE(&FIRST) NE &STR(NUM) THEN DO\n    SET ZEDSMSG = &STR(INVALID START)\n    SET ZEDLMSG = &STR(START COLUMN NUMBER IS NOT NUMERIC)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(20)\n    END\n  IF (&STR(&LAST) EQ &Z) OR +\n    (&STR(&LAST) EQ &STR(.)) THEN SET LAST = &RIGHTM\n  ELSE IF &DATATYPE(&LAST) NE &STR(NUM) THEN DO\n    SET ZEDSMSG = &STR(INVALID END)\n    SET ZEDLMSG = &STR(END COLUMN NUMBER IS NOT NUMERIC)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(20)\n    END\n  IF &TYPE EQ &STR(X) THEN SET CHECK = &STR(X)\n  ELSE IF &TYPE EQ &STR(NX) THEN SET CHECK = &STR(NX)\n  ELSE IF &TYPE EQ &STR(ALL) THEN SET CHECK = &STR(ALL)\n  ELSE DO\n    SET ZEDSMSG = &STR(INVALID TYPE)\n    SET ZEDLMSG = &STR(TYPE OF LINES MUST BE \"X\", \"NX\" OR \"ALL\")\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(20)\n    END\n  IF (&FIRST LT &LEFTM) OR (&FIRST GE &RIGHTM) THEN DO\n    SET ZEDSMSG = &STR(VERIFY START)\n    SET ZEDLMSG = &STR(START COLUMN NUMBER IS OUT OF BOUNDS)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(20)\n    END\n  IF (&LAST LE &LEFTM) OR (&LAST GT &RIGHTM) THEN DO\n    SET ZEDSMSG = &STR(VERIFY END)\n    SET ZEDLMSG = &STR(END COLUMN NUMBER IS OUT OF BOUNDS)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(20)\n    END\n  IF &FIRST GE &LAST THEN DO\n    SET ZEDSMSG = &STR(WRONG START-END)\n    SET ZEDLMSG = &STR(START +\n      COLUMN NUMBER MUST BE LESS THAN END COLUMN NUMBER)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(20)\n    END\n  SET TD = 0\n  DO WHILE &START LE &END\n    IF &CHECK EQ &STR(ALL) THEN SET STATUS = &STR(ALL)\n    ELSE ISREDIT (STATUS) = XSTATUS &START\n    IF &STATUS EQ &CHECK THEN DO\n      ISREDIT (DATALINE) = LINE &START\n      SET HOLDER = &SUBSTR(&FIRST:&LAST,&DATALINE)\n      SET LH = &LENGTH(&STR(&HOLDER))\n      SET X = &Z\n      SET SWI = Y\n      SET I = 1\n      DO WHILE &I LE &LH\n        SET TMP = &SUBSTR(&I:&I,&STR(&HOLDER))\n        IF ((&STR(&TMP) EQ &STR(,)) OR ((&STR(&TMP) GE &STR(0)) AND +\n          (&STR(&TMP) LE &STR(9)))) AND (&SWI EQ Y) THEN +\n          SET X = &STR(&X&TMP)\n        ELSE IF &STR(&TMP) NE &STR(.) THEN DO\n          IF &STR(&TMP) EQ &Z THEN DO\n            IF &STR(&X) EQ &STR(,) THEN DO\n              SET X = &Z\n              SET SWI = Y\n              END\n            ELSE IF &STR(&X) EQ &Z THEN SET SWI = Y\n            ELSE SET I = &LH\n            END\n          ELSE DO\n            IF &STR(&X) NE &Z THEN SET X = &Z\n            SET SWI = N\n            END\n          END\n        SET I = &I + 1\n        END\n      IF &STR(&X) NE &Z THEN DO\n        SET LX = &LENGTH(&STR(&X))\n        IF &LX NE 0 THEN DO\n          SET VD = 0\n          SET I = &LX\n          DO WHILE &I GE 1\n            SET TMP = &SUBSTR(&I:&I,&STR(&X))\n            IF &STR(&TMP) EQ &STR(,) THEN DO\n              SET VD = &LX - &I\n              SET I = 1\n              END\n            SET I = &I - 1\n            END\n          SET I = 1\n          SET NMR = &Z\n          DO WHILE &I LE &LX\n            SET TMP = &SUBSTR(&I:&I,&STR(&X))\n            IF &STR(&TMP) NE &STR(,) THEN SET NMR = &NMR&TMP\n            SET I = &I + 1\n            END\n          SET HOLDER = &NMR\n          END\n        END\n      IF (&DATATYPE(&HOLDER) EQ &STR(NUM)) AND (&VD LE 3) THEN DO\n        IF &VD NE &TD THEN DO\n          DO WHILE &TD NE &VD\n            IF &TD GT &VD THEN DO\n              SET HOLDER = &HOLDER * 10\n              SET VD = &VD + 1\n              END\n            ELSE DO\n              SET TOTAL = &TOTAL * 10\n              SET TD = &TD + 1\n              END\n            END\n          END\n        SET TOTAL = &TOTAL + &HOLDER\n        SET VALID = &VALID + 1\n        END\n      ELSE SET INVALID = &INVALID + 1\n      END\n    SET START = &START + 1\n    END\n  SET TOTED = &STR(&TOTAL)\n  IF &TOTAL NE 0 THEN DO\n    IF &TD EQ 0 THEN SET TWORK = &TOTED\n    ELSE DO\n      SET LT = &LENGTH(&TOTED)\n      IF &TD GT &LT THEN DO\n        SET I = &LT\n        SET TWORK = &STR(TOTED)\n        DO WHILE &I NE &TD\n          SET TWORK = &STR(0)&STR(TWORK)\n          SET I = &I + 1\n          END\n        SET TWORK = &STR(0,)&STR(TWORK)\n        END\n      ELSE IF &TD EQ &LT THEN SET TWORK = &STR(0,)&STR(TOTED)\n      ELSE DO\n        SET N = &LT - &TD\n        SET M = &N + 1\n        SET TWORK = &SUBSTR(1:&N,&TOTED)&STR(,)&SUBSTR(&M:&LT,&TOTED)\n        END\n      END\n    IF &TD NE 0 THEN SET LT = &LENGTH(&TWORK) - &TD - 1\n    ELSE SET LT = &LENGTH(&TWORK)\n    IF &LT GT 3 THEN DO\n      SET I = &LT\n      DO WHILE &I GT 3\n        SET N = &I - 3\n        SET M = &N + 1\n        SET LT = &LENGTH(&TWORK)\n        SET TWORK = &SUBSTR(1:&N,&TWORK)&STR(.)&SUBSTR(&M:&LT,&TWORK)\n        SET I = &N\n        END\n      END\n    SET TOTED = &TWORK\n    END\n  SET ZEDSMSG = &STR(SUM : &TOTED)\n  SET ZEDLMSG = &STR(THE SUM OF +\n    \"&TYPE\" NUMBERS IN COLUMNS &FIRST TO &LAST IS : &TOTED)\n  ISPEXEC SETMSG MSG(ISRZ001)\n  ISREDIT LINE_BEFORE 1 = NOTELINE +\n    'SUM OF NUMBERS IN COLUMNS &FIRST TO &LAST IS &TOTED'\n  ISREDIT LINE_BEFORE 1 = NOTELINE +\n    '       PROCESSED &VALID VALID AND &INVALID INVALID LINES'\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUM@": {"ttr": 34834, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x8f\\x00\\x94)\\x8f\\x10@\\x00X\\x00X\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-25T00:00:00", "modifydate": "1994-10-25T10:40:00", "lines": 88, "newlines": 88, "modlines": 0, "user": "SYSPAJA"}, "text": "1   10/08/94\n                                                      SUM       1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      SUM ISPF/PDF EDIT command      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro may be used to ADD columns of numbers.\n  ----------   SUM can handle numbers with up to 3 decimal places. Only\n               valid numeric data will be added. Numbers must not be\n               aligned with equal number of decimal places. SUM can\n               handle X and NX type of data lines, the default is ALL\n               lines. If you wish to exclude lines, use the NX parm,\n               if you want to sum only excluded lines, use the X parm.\n               The STARTING and ENDING column of the data lines range\n               may be identified by entering starting and ending\n               column numbers. You may omit the two numbers or use in\n               place the period sign (.) to get the left and right\n               boundaries as default.\n\n  Command syntax : On the COMMAND line type in\n  ----------------      SUM TYPE START END\n                   and then mark the lines with the On or OO range\n                   command, or : SUM HELP or H to view this tutorial.\n                   If START-COL is not specified, the cursor position\n                   will be used.\n                   On the COMMAND line type in\n                        SUM TYPE START END\n                   where : TYPE may be ALL or X or NX\n                           START is the starting column of data range\n                           END is the ending column of data range\n                   or : SUM HELP or H to view this tutorial.\n\n  Use :        Example 1 : assumed that all the data lines have been\n  -----                    excluded unless those displayed here below.\n                           Note that the range 27 - 35 is not necessary\n                           if the rest of the data in the lines\n                           doesn't contain any other valid numbers.\n               COMMAND ===> SUM NX 27 35\n               *************************** TOP OF DATA ****************\n               ----0----1----1----2----2----3----3----4----4----5----5-\n               ----5----0----5----0----5----0----5----0----5----0----5-\n                                         12.345,08\n                                            345,25\n               ************************** BOTTOM OF DATA **************\n               Result:\n               *************************** TOP OF DATA ****************\n               SUM OF NUMBERS IN COLUMNS 27 TO 35 IS 12690,33\n                      PROCESSED 2 VALID AND 0 INVALID LINES\n1   10/08/94\n                                                      SUM       2/2.\n\n               Example 2 : assumes that all data lines are present, none\n                           excluded. Note that the word ALL is not\n                           specified (default).\n               COMMAND ===> SUM . 10\n               *************************** TOP OF DATA *****************\n               ----0----1----1----2----2----3----3----4----4----5----5--\n               ----5----0----5----0----5----0----5----0----5----0----5--\n                 1234510,\n                    ,09\n                    25,8\n                32\n               ************************** BOTTOM OF DATA ***************\n               Result:\n               *************************** TOP OF DATA *****************\n               SUM OF NUMBERS IN COLUMNS 1 TO 10 IS 1.234.567,89\n                      PROCESSED 4 VALID AND 0 INVALID LINES\n\n               Example 3 : assumes you have excluded only the data\n                           lines of the books you want buy from the\n                           entire cost price list.\n               COMMAND ===> SUM X 45\n               *************************** TOP OF DATA *****************\n               ----0----1----1----2----2----3----3----4----4----5----5--\n               ----5----0----5----0----5----0----5----0----5----0----5--\n                 ... 1st excluded book title ...              25.000\n                 ... 2nd excluded book title ...              42.500\n                 ... 3rd excluded book title ...              17.000\n                 ... 4th excluded book title ...              31.000\n                 ... 5th excluded book title ...               7.500\n               ************************** BOTTOM OF DATA ***************\n               Result:\n               *************************** TOP OF DATA *****************\n               SUM OF NUMBERS IN COLUMNS 45 TO 72 IS 123.000\n                      PROCESSED 5 VALID AND 0 INVALID LINES\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYSMAC@": {"ttr": 35074, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x884?\\x00\\x884?\\x14\\x15\\x00'\\x00'\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-08T00:00:00", "modifydate": "1988-12-08T14:15:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SYSPAJA"}, "text": "1   08/12/88\n                                                      MACROS    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        SPECIAL SYSTEM MACROS        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n               ---------------------------------------\n                 M V S    S Y S T E M    M A C R O S\n               ---------------------------------------\n\n $NOSWAP  : issued to notify SRM that the issuing address space\n ---------- must not be swapped out until a $OKSWAP has occured.\n   Syntax : $NOSWAP ADDRESS\n  Operand : omitted - SYSEVENT CODE and ASID are assumed in the\n                      register 0.\n            ADDRESS - the address of the ASID (halfword).\n            (register) - the indicated register contains the ASID\n                         (bits 16-31).\n\n $OKSWAP  : issued to notify SRM that the issuing address space\n ---------- may again be considered for swapping.\n   Syntax : $OKSWAP ADDRESS\n  Operand : omitted - SYSEVENT CODE and ASID are assumed in the\n                      register 0.\n            ADDRESS - the address of the ASID (halfword).\n            (register) - the indicated register contains the ASID\n                         (bits 16-31).\n\n\n $TREQ    : get TIME values (operand : R=CL/CU/SL/SU).\n RESAUTH  : set off authorization (operand : none).\n RESETKEY : re-enter key and problem mode, and set off authorization\n            (operand : none).\n SETAUTH  : set on authorization (operand : none).\n ZEROKEY  : set on authorization, and enter supervisor mode with key\n            zero (operand : none).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TMTH": {"ttr": 35076, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TMTHD": {"ttr": 35078, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TMTHDK": {"ttr": 35080, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TMTHE": {"ttr": 35082, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TMTHF": {"ttr": 35084, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TMTHI": {"ttr": 35086, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TMTHP": {"ttr": 35088, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TRAP": {"ttr": 35090, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"_\\x00\\x91\"_\\x17\\x16\\x00]\\x00]\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-13T17:16:00", "lines": 93, "newlines": 93, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM,BPARM) NOPROCESS                              */\n/*  MACRO NAME : TRAP                                               */\n/*    FUNCTION : PUT ANY TSO COMMAND OUTPUT INTO EDIT               */\n/*      SYNTAX : TRAP COMMAND                                       */\n/*               TRAP 'COMMAND ...'                                 */\n/*               TRAP HELP OR H                                     */\n/*               OPERAND : DESIRED TSO COMMAND (MUST USE PUTLINE)   */\n/*       DEBUG : TRAP COMMAND LIST                                  */\n/*               TRAP 'COMMAND ...' LIST                            */\n/*      ORIGIN : EXTRACTED FROM CBT TAPE 89 FEB, FILE 015.          */\n/*      UPDATE : MOINIL P.A.                                        */\n  IF &STR(&APARM.) = &Z THEN DO\n    SET ZEDSMSG = &STR(OPERAND MISSING)\n    SET ZEDLMSG = &STR(== FIRST OPERAND TSO COMMAND IS MANDATORY ==)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  IF &STR(&APARM.) = &STR(HELP) OR +\n    &STR(&APARM.) = &STR(H) THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTTRAP)\n      SET &TPCC = &LASTCC\n      ISPEXEC CONTROL DISPLAY RESTORE\n      EXIT CODE(&TPCC)\n      END\n  IF &STR(&BPARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n  IF &SUBSTR(1:1,&APARM) = &STR(') THEN DO\n    SET &CL = &LENGTH(&STR(&APARM)) - 1\n    SET &CMDNM = &SUBSTR(2:&CL,&APARM)\n    END\n  ELSE SET &CMDNM = &STR(&APARM.)\n  CONTROL ASIS\n  SET &SYSOUTTRAP = 400\n  TSOEXEC &CMDNM\n  SET &SYSOUTTRAP = 0\n  SET &TL = &SYSOUTLINE\n  SET &TN = 1\n  SET &C = &STR(&&)\n  ISREDIT PROCESS DEST\n  IF &LASTCC = 0 THEN DO\n    ISREDIT LOCATE .ZDEST\n    IF &LASTCC = 8 THEN GOTO IN2\nIN1: ISREDIT (LINEPTR) = LINENUM .ZDEST\n    SET &WH = &LINEPTR\n    DO WHILE &TL >= &TN\n      SET &TF = &NRSTR(&C.SYSOUTLINE&TN)\n      SET &TT = &SYSNSUB(2,&TF)\n      SET &TS = 1\n      SET &TM = &LENGTH(&NRSTR(&TT))\n      SET &TQ =\n      DO WHILE &TS <= &TM\n        SET &TX = &SUBSTR(&TS,&NRSTR(&TT))\n        IF &NRSTR(&TX) = &STR(\") THEN -\n          SET &TX = &STR(')\n        SET &TQ = &NRSTR(&TQ&TX)\n        SET &TS = &TS + 1\n        END\n      ISREDIT MASKLINE = &SYSNSUB(1,\"&TQ\")\n      ISREDIT LINE_AFTER &LINEPTR = MASKLINE\n      SET &LINEPTR = &LINEPTR + 1\n      SET &TN = &TN + 1\n      END\n    ISREDIT MASKLINE = \"OUTPUT FROM : &CMDNM\"\n    ISREDIT LINE_AFTER &WH = MSGLINE MASKLINE\n    END\n  ELSE DO\nIN2: ISREDIT (LINEPTR) = LINENUM .ZCSR\n    SET &LINEPTR = .ZLAST\n    DO WHILE &TL >= &TN\n      SET &WH = &TN - 1\n      SET &TF = &NRSTR(&C.SYSOUTLINE&TN)\n      SET &TT = &SYSNSUB(2,&TF)\n      SET &TS = 1\n      SET &TM = &LENGTH(&NRSTR(&TT))\n      SET &TQ =\n      DO WHILE &TS <= &TM\n        SET &TX = &SUBSTR(&TS,&NRSTR(&TT))\n        IF &NRSTR(&TX) = &STR(\") THEN -\n          SET &TX = &STR(')\n        SET &TQ = &NRSTR(&TQ&TX)\n        SET &TS = &TS + 1\n        END\n      ISREDIT MASKLINE = &SYSNSUB(1,\"&TQ\")\n      ISREDIT LINE_AFTER &WH = MASKLINE\n      SET &TN = &TN + 1\n      END\n    ISREDIT MASKLINE = \"OUTPUT FROM : &CMDNM\"\n    ISREDIT LINE_AFTER 0 = MSGLINE MASKLINE\n    END\n  ISREDIT MASKLINE = \" \"\n  CONTROL MSG\n  CONTROL CAPS\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRAP@": {"ttr": 35093, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"o\\x00\\x91\"o\\x10\\x10\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-14T00:00:00", "modifydate": "1991-08-14T10:10:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/05/90\n                                                      TRAP      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     TRAP ISPF/PDF EDIT command      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   This Edit macro will put the output from a TSO command\n  ----------   that uses PUTLINE macros into the current edit file.\n\n  Command syntax : TRAP command\n  ---------------- TRAP 'command ...'\n                   TRAP HELP or H\n\n  Use :        Type TRAP command on the COMMAND line, the output will\n  -----        then be inserted at the top of data. If you desire it\n               somewhere other than the top of data, type A (after) or\n               B (before) on the line number at the point in the data\n               you want the command output, as i.e. :\n               COMMAND ===> TRAP LISTA\n                   ---> A 0600   Data ...\n                        000700   Data ...\n               Result : 000600   Data ...\n                        ==MSG> OUTPUT FROM : LISTA\n                        000610   ... output would be inserted here ...\n               Identical process is obtained with :\n                   ---> B 0700   Data ...\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSODSN": {"ttr": 35095, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\tY\\x011\\x011\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T09:59:00", "lines": 305, "newlines": 305, "modlines": 0, "user": "SYSPAJA"}, "text": "TDSN     TITLE 'TSO - LIST OWNERS OF DATA-SET COMMAND.'\nTSODSN   START 0\n         SPACE 1\n* FUNCTION :   DISPLAY FOR THE SPECIFIED DATA-SET :\n* ----------       1) USERS\n*                  2) DISPOSITION\n*                  3) WAITING FOR DATASETS\n*                  4) SYSTEM\n*                  5) MUST COMPLETE FLAG\n*                  6) RESERVE FLAG\n*                  7) GLOBAL FLAG\n*                  8) OWNERSHIP FLAG\n* COMMAND :    SYNTAX : TSODSN ...DATA-SET NAME...\n* ---------    DEFAULT : NONE.\n* NOTE :     - THIS CODE HAS NOT BEEN TESTED WITH A GRS RING.\n* ------       SCOPE=GLOBAL WILL HAVE TO BE SPECIFIED ON THE GQSCAN\n*              MACRO AND THE GQSCAN HAS TO RUN AUTHORIZED KEY ZERO.\n*            - THE 'SYSNAME' IN IEASYS00 SHOULD SPECIFY YOUR SMFID\n*              TO GET THE CORRECT SYSTEM NAME IN THE 'SYSTEM' FIELD,\n*              OTHERWISE (NONA) NO-NAME WILL BE DISPLAYED.\n* AUTHOR :     ORIGINAL VERSION FROM CBT TAPE (FILE 324).\n* --------     MODIFIED BY : RAVARANI N. - MOINIL P.A.\n*                            COMPUTING CENTRE (TP 361)\n*                            J.R.C. - ISPRA ESTABLISHMENT\n*                            21020 ISPRA (VA), ITALY\n         SPACE 1\n        $DEFREG\nSIAL     EQU   12*1024             SCAN INFO AREA LENGTH.\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R5,R13              SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R5\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n        $TEW$PP PARM=PARMLST\n         TM    DSNAM+6,X'80'       IS DSNAME THERE?\n         BZ    ERRDS1              NO.\n         TM    DSNAM+14,X'80'      ANY MEMBER NAME ALSO?\n         BO    ERRDS2              YES, NOT ALLOWED.\n         MVC   REQDSN(L'REQDSN),BLANK\n         LH    R4,DSNAM+4          GET DSNAME LENGTH.\n         L     R14,DSNAM           GET DSNAME POINTER.\n         LR    R15,R4\n         BCT   R15,*+L'*+6\n         MVC   REQDSN(*-*),0(R14)  <<EXECUTED>>\n         EX    R15,*-6             MOVE DSNAME.\n         DROP  R2\n        IKJRLSA #TSANSW\n         SPACE 1\n         MVC   LINE,BLANK\n         L     R3,CVTPTR           GET ADDRESS OF CVT.\n         USING CVT,R3\n         L     R1,CVTSMCA\n         DROP  R3\n         USING SMCABASE,R1\n         MVC   LINE(24),=CL24'DATA-SET USAGE DISPLAY ('\n         MVC   LINE+24(4),SMCASID  MOVE IN SYSTEM ID.\n         DROP  R1\n         MVI   LINE+29,C'-'\n        TIME   DEC                 R0 : HHMMSSTH\n         STM   R0,R1,WORKD         TIME - DATE\n         UNPK  LINE+40(7),WORKD(4)\n         MVC   LINE+46(2),LINE+44  XXSS\n         MVC   LINE+44(1),LINE+43  MXSS\n         MVC   LINE+43(1),LINE+42  HHXM MXSS\n         MVI   LINE+42,C'.'\n         MVI   LINE+45,C'.'        HH.MM.SS\n         UNPK  LINE+31(7),WORKD+4(4)\n         MVC   LINE+31(2),LINE+33  YY\n         MVC   LINE+34(3),LINE+35  DDD\n         MVI   LINE+33,C'.'        YY.DDDX\n         MVI   LINE+37,C' '        YY.DDD\n         MVI   LINE+38,C'-'\n         MVI   LINE+48,C')'\n        STLINENO LINE=1            VTAM CLEAR SCREEN.\n         LA    R0,L'LINE           TITLE AND TIME.\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         LA    R0,L'BLANK          A BLANK LINE.\n         LA    R1,BLANK\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         MVC   LINE,BLANK\n         MVC   LINE(16),=CL16'DATA-SET NAME :'\n         MVC   LINE+16(L'REQDSN),REQDSN MOVE IN DSNAME.\n         LA    R0,L'LINE\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         LA    R0,L'BLANK          A BLANK LINE.\n         LA    R1,BLANK\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         LA    R7,REQDSN           ADDRESS OF DSN MINOR NAME.\n         LA    R8,SCANAREA         ADDRESS OF RETURNED DATA.\n         LA    R9,SYSDSN           ADDRESS OF SYSDSN MAJOR NAME.\n         MVC   SYSDSN,=CL8'SYSDSN'\n         LA    R13,SCANSAVE        ADDRESS GQSCAN SAVE AREA.\n         XC    0(18*4,R13),0(R13)\n         MVC   SCAN(LSCAN),SCANP\n        GQSCAN AREA=((R8),),RESNAME=((R9),(R7),(R4)),MF=(E,SCAN)\n         LR    R13,R5              RESTORE MAIN SAVE AREA.\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     CODE00              +0 - O.K.\n         B     CODE04              +4 - NO RESOURCES MATCHED REQUEST\n         B     CODE08              +8 - GQSCAN AREA TOO SHORT\n         B     CODE0C              +12 - ERROR WHILE PROCESSING\n         B     CODE10              +16 - INVALID SYSNAME\n         B     CODE14              +20 - GQSCAN AREA TOO SHORT\n         SPACE 1\nCODE04   LA    R0,L'CODE04M        DSNAME NOT FOUND.\n         LA    R1,CODE04M\n         B     FINISH\nCODE08   LA    R0,L'CODE08M        GQSCAN AREA TOO SHORT.\n         LA    R1,CODE08M\n         B     FINISH\nCODE0C   LA    R0,L'CODE0CM        ERROR IN GQSCAN.\n         LA    R1,CODE0CM\n         B     FINISH\nCODE10   LA    R0,L'CODE10M        INVALID SYSNAME.\n         LA    R1,CODE10M\n         B     FINISH\nCODE14   LA    R0,L'CODE14M        GQSCAN AREA TOO SHORT.\n         LA    R1,CODE14M\nFINISH   BAS   R14,PUTLNE\n         B     SETRC\n         SPACE 1\nCODE00   ST    R0,RIBLNGTH         STORE RIB AND RIBE LENGTH.\n         LA    R10,SCANAREA        ADDRESS OF GQSCAN AREA.\n         USING RIB,R10             RESOURCE INFORMATION BLOCK.\n         L     R9,RIBNRIBE         LOAD THE NO. OF RIBE'S.\n         LTR   R9,R9\n         BNP   CODE04              NO RIBE'S SUPPLIED.\n         LA    R0,L'FLAGHD         PRINT FLAG HEADER.\n         LA    R1,FLAGHD\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         MVI   LINE,C'-'\n         MVC   LINE+1(L'LINE-1),LINE\n         LA    R0,L'FLAGHD         UNDER LINE IT.\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         LA    R0,L'BLANK          A BLANK LINE.\n         LA    R1,BLANK\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         LR    R11,R10             SAVE RIB POINTER.\n         AH    R11,RIBLNGTH        POINT TO RIB VARIABLE SECTION.\n         AH    R11,RIBVLEN         POINT TO FIRST RIBE.\n         USING RIBE,R11            RESOURCE INFORMATION BLOCK EXT.\n         LA    R6,LINE\n         USING JOBLINE,R6\nSEARCH   MVC   LINE,BLANK\n         MVC   JOBNAME,RIBEJBNM    JOBNAME OF REQUESTOR.\n         MVC   SYSTEM(4),RIBESYSN  SYSTEM NAME OF REQUESTOR.\n         TM    RIBERFLG,RIBETYPE   IS THIS EXCLUSIVE OR SHARED?\n         BO    *+L'*+10            BRANCH IF SHARED.\n         MVC   EXCLFLAG,=CL4'EXCL' NO, EXCLUSIVE.\n         B     *+L'*+6\n         MVC   EXCLFLAG,=CL4'SHR'\n         TM    RIBERFLG,RIBEMC     IS MUST COMPLETE?\n         BO    *+L'*+8             BRANCH IF YES.\n         MVI   MCFLAG,C'N'\n         B     *+L'*+4\n         MVI   MCFLAG,C'Y'\n         TM    RIBERFLG,RIBERESV   IS THIS RESERVE REQUEST?\n         BO    *+L'*+8             BRANCH IF YES.\n         MVI   RESVFLAG,C'N'\n         B     *+L'*+4\n         MVI   RESVFLAG,C'Y'\n         TM    RIBERFLG,RIBERESC   IS THIS RESERVE REQUEST GLOBAL?\n         BO    *+L'*+8             BRANCH IF YES.\n         MVI   GLOBFLAG,C'N'\n         B     *+L'*+4\n         MVI   GLOBFLAG,C'Y'\n         TM    RIBESFLG,RIBESTAT   IS THIS GUY THE OWNER?\n         BO    *+L'*+14            BRANCH IF YES.\n         MVI   OWNFLAG,C'N'\n         MVC   WAITFLAG,=CL9'*WAITING*'\n         B     *+L'*+4\n         MVI   OWNFLAG,C'Y'\n         DROP  R6,R10,R11\n         LA    R0,L'LINE           PRINT IT.\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         AH    R11,RIBELENG        POINT TO NEXT RIBE.\n         BCT   R9,SEARCH           DO IT FOR NEXT USER.\n         XR    R15,R15             RC = 0 -----------------------------\nQUIT    $XRET  CC=(R15),LV=WRKL,TYPE=RENT\nERRDS1   LA    R0,L'ERRMS1\n         LA    R1,ERRMS1\n         B     OUTMS\nERRDS2   LA    R0,L'ERRMS2\n         LA    R1,ERRMS2\nOUTMS    BAS   R14,PUTLNE\n        IKJRLSA #TSANSW\nSETRC    LA    R15,16              RC = 16 ----------------------------\n         B     QUIT\n         EJECT\n*------- SKELETONS, MESSAGES AND CONSTANTS\n         SPACE 1\n        PRINT  NOGEN\nSCANP   GQSCAN AREA=(,SIAL),REQLIM=MAX,SCOPE=ALL,MF=L\n        PRINT  GEN\nLSCAN    EQU   *-SCANP\n         SPACE 1\nFLAGHD   DS   0CL72\n         DC    CL14'JOBNAME/USERID'\n         DC    CL5' '\n         DC    CL4'DISP'\n         DC    CL2' '\n         DC    CL8' SYSTEM '\n         DC    CL2' '\n         DC    CL13'MUST COMPLETE'\n         DC    CL2' '\n         DC    CL7'RESERVE'\n         DC    CL2' '\n         DC    CL6'GLOBAL'\n         DC    CL2' '\n         DC    CL5'OWNER'\n         SPACE 1\nCODE04M  DC    C'NOT IN-USE OR NOT FULLY QUALIFIED DATA-SET NAME.'\nCODE08M  DC    C' -> GQSCAN : \"AREA\" TOO SHORT'\nCODE0CM  DC    C' -> GQSCAN : ERROR WHILE PROCESSING'\nCODE10M  DC    C' -> GQSCAN : \"SYSNAME\" IS INVALID'\nCODE14M  EQU   CODE08M,L'CODE08M\nERRMS1   DC    C'DATA-SET NAME MISSING.'\nERRMS2   DC    C'MEMBER NAME NOT ALLOWED.'\nBLANK    DC    CL72' '\n         EJECT\n        LTORG\n         SPACE 1\n        PRINT  NOGEN\nPARMLST IKJPARM\nDSNAM   IKJPOSIT DSNAME,USID,PROMPT='DATA-SET NAME'\n        IKJENDP\n        PRINT  GEN\n         EJECT\n*------- WORK-AREAS DESCRIPTION\n         SPACE 1\nJOBLINE  DSECT                     INFO LINE DESCRIPTION.\nJOBNAME  DS    CL8\n         DC    C' '\nWAITFLAG DS    CL9' '\n         DC    C' '\nEXCLFLAG DS    CL4\n         DC    CL4' '\nSYSTEM   DS    CL4\n         DC    CL4' '\n         DC    CL6' '\nMCFLAG   DS    CL1\n         DC    CL6' '\n         DC    CL2' '\n         DC    CL3' '\nRESVFLAG DS    CL1\n         DC    CL3' '\n         DC    CL2' '\n         DC    CL2' '\nGLOBFLAG DS    CL1\n         DC    CL3' '\n         DC    CL2' '\n         DC    CL2' '\nOWNFLAG  DS    CL1\n         DC    CL2' '\n         SPACE 1\nWRKDSECT DSECT                     WORK AREAS. DESCRIPTION.\nSVA      DS    18F                 SAVE AREA.\nSCANSAVE DS    18F                 18 WORDS SAVE AREA REQ FOR GQSCAN.\nWORKD    DS    D\n        $TEW$WA\nSCAN     DS    0F,(LSCAN)X\nRIBLNGTH DC    H'0'\nRIBELENG DC    H'0'\nSYSDSN   DS    CL8\nREQDSN   DS    CL44\nLINE     DS    CL72\nSCANAREA DS    0F,(SIAL)X          SCAN INFO AREA.\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         SPACE 1\n        PRINT  NOGEN\n       $TEW$DS\n        IEESMCA\n        ISGRIB\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSODSN$": {"ttr": 35331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//TSODSN   JOB (........),'INSTALL  -TSODSN-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=TSODSN\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  NAME    TSODSN(R)\n/*\n//HLP     EXEC PAJHELP,MBR=TSODSNH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSODSN@": {"ttr": 35333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      TSODSN    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     DISPLAY DATA-SET'S ENQUEUES.    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n   Function : Display for the specified data-set :\n   ----------      - users\n                   - disposition\n                   - waiting for data-sets\n                   - system\n                   - must complete flag\n                   - reserve flag\n                   - global flag\n                   - ownership flag\n\n   Syntax :   TSODSN 'DSN'\n   --------   Required : 'DSN'\n              Default : none.\n\n   Operands : 'DSN' - name of the data-set to be considered.\n   ----------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSODSNH": {"ttr": 35335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=TSODSN\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : DISPLAY FOR THE SPECIFIED DATA-SET :\n                   - USERS\n                   - DISPOSITION\n                   - WAITING FOR DATA-SETS\n                   - SYSTEM\n                   - MUST COMPLETE FLAG\n                   - RESERVE FLAG\n                   - GLOBAL FLAG\n                   - OWNERSHIP FLAG\n)X SYNTAX :   TSODSN 'DSN'\n              REQUIRED : 'DSN'\n              DEFAULT : NONE.\n)O OPERANDS : 'DSN' - NAME OF THE DATA-SET TO BE CONSIDERED.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSOENQ": {"ttr": 35337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12?\\x00\\x94\\x12?\\x15R\\x01L\\x01L\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-03T00:00:00", "modifydate": "1994-05-03T15:52:00", "lines": 332, "newlines": 332, "modlines": 0, "user": "SYSPAJA"}, "text": "TENQ     TITLE 'TSO - DISPLAY DATA-SETS ENQUE''S CONFLICTS COMMAND.'\nTSOENQ   START 0\n         SPACE 1\n* FUNCTION :   DISPLAY DATA-SETS ENQUE'S CONFLICTS (TSO CP) ON SP1.3\n* ----------   SYSTEM.\n* COMMAND :    SYNTAX : TSOENQ\n* ---------    DEFAULT : NONE.\n* NOTES :    - THIS CODE HAS NOT BEEN TESTED WITH A GRS RING, AS\n* -------      SCOPE=GLOBAL WILL HAVE TO BE SPECIFIED ON THE GQSCAN\n*              MACRO AND THE GQSCAN HAS TO RUN AUTHORIZED KEY ZERO.\n*            - THE 'SYSNAME' IN IEASYS00 SHOULD SPECIFY YOUR SMFID\n*              TO GET THE CORRECT SYSTEM NAME IN THE 'SYSTEM' FIELD,\n*              OTHERWISE (NONA) NONAME WILL BE DISPLAYED.\n*            - FOR A SYSTEM WITH MANY DATA-SETS IN USE, THE \"SCANAREA\"\n*              MIGHT HAVE TO BE MADE LARGER (THE CORRESPONDING FIELD\n*              ON THE \"AREA\" PARAMETER OF THE \"GQSCAN\" MACRO MUST BE\n*              CHANGED).\n*            - TOKEN HAS BEEN ADDED TO ALLOW SEARCHING OF LONG ENQUE\n*              CHAINS.\n* AUTHOR :     ORIGINAL VERSION FROM CBT TAPE (FILE 324).\n* --------     MODIFIED BY : RAVARANI N. - MOINIL P.A.\n*                            COMPUTING CENTRE (TP 361)\n*                            J.R.C. - ISPRA ESTABLISHMENT\n*                            21020 ISPRA (VA), ITALY\n         SPACE 1\nLV0      EQU   0         AUTHORITY LEVEL DEFINITION = REJECT LEVEL.\n        $MDL@IX\n        $DEFREG\nSIAL     EQU   100*1024            SCAN INFO AREA LENGTH.\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R5,R13              SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R5\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n         XC    REQAUT(REQAUTL),REQAUT\n         MVC   REQAUT+1(3),=AL3(MDL@IX)\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n        $EACM  REQAUT\n         CLI   AUTH,LV0            AUTHORIZED?\n         BE    NOTAUT              NO, NOT AUTHORIZED.\n         SPACE 1\n         MVC   LINE,BLANK\n         L     R3,CVTPTR           GET ADDRESS OF CVT.\n         USING CVT,R3\n         L     R4,CVTSMCA\n         DROP  R3\n         USING SMCABASE,R4         SET ADDRESSABILITY.\n         MVC   LINE(28),=CL28'DATA-SET CONFLICTS DISPLAY ('\n         MVC   LINE+28(4),SMCASID  MOVE SYSTEM ID.\n         DROP  R4\n         MVI   LINE+33,C'-'\n        TIME  DEC                  R0 : HHMMSSTH\n         STM   R0,R1,WORKD         TIME - DATE\n         UNPK  LINE+44(7),WORKD(4)\n         MVC   LINE+50(2),LINE+48  XXSS\n         MVC   LINE+48(1),LINE+47  MXSS\n         MVC   LINE+47(1),LINE+46  HHXM MXSS\n         MVI   LINE+46,C'.'\n         MVI   LINE+49,C'.'        HH.MM.SS\n         UNPK  LINE+35(7),WORKD+4(4)\n         MVC   LINE+35(2),LINE+37  YY\n         MVC   LINE+38(3),LINE+39  DDD\n         MVI   LINE+37,C'.'        YY.DDDX\n         MVI   LINE+41,C' '        YY.DDD\n         MVI   LINE+42,C'-'\n         MVI   LINE+52,C')'\n        STLINENO LINE=1            VTAM CLEAR SCREEN.\n         LA    R0,L'LINE           TITLE AND TIME.\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         XC    TKN,TKN             ZERO OUT TOKEN AREA.\n         MVI   SWITCH,0            INITIALIZE SWITCHES.\nSTART    LA    R8,SCANAREA         ADDRESS OF RETURNED DATA.\n         LA    R9,SYSDSN           ADDRESS OF SYSDSN MAJOR NAME.\n         MVC   SYSDSN,=CL8'SYSDSN'\n         LA    R13,SCANSAVE        ADDRESS GQSCAN SAVE AREA.\n         XC    0(18*4,R13),0(R13)\n         MVC   SCAN(LSCAN),SCANP\n        GQSCAN AREA=((R8),),RESNAME=((R9)),TOKEN=TKN,MF=(E,SCAN)\n         LR    R13,R5              RESTORE MAIN SAVE AREA.\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     CODE00              +0 - O.K.\n         B     CODE04              +4 - NO RESOURCES MATCHED REQUEST\n         B     CODE08              +8 - GQSCAN AREA TOO SHORT\n         B     CODE0C              +12 - ERROR WHILE PROCESSING\n         B     CODE10              +16 - INVALID SYSNAME\n         B     CODE14              +20 - GQSCAN AREA TOO SHORT\n         SPACE 1\nCODE04   LA    R0,L'CODE04M        NO RESOURCES.\n         LA    R1,CODE04M\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     RETURN              +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\nCODE08   OI    SWITCH,TKNSW        SET TOKEN SWITCH TO CONTINUE.\n         SPACE 1\nCODE00   STCM  R0,B'1111',RIBLNGTH STORE RIB AND RIBE LENGTH.\n         LTR   R7,R1               SAVE NUMBER OF RIBS.\n         BZ    RETURN              NO RIB'S SUPPLIED.\n         LA    R6,LINE\n         LA    R10,SCANAREA        ADDRESS OF GQSCAN AREA (1ST RIB).\n         USING RIB,R10             RESOURCE INFORMATION BLOCK.\nRIBLOOP  L     R9,RIBNRIBE         LOAD THE NO. OF RIBE'S.\n         LTR   R9,R9\n         BNP   BUMPRIB             NO RIBE'S SUPPLIED.\n         LR    R11,R10             GET RIB POINTER.\n         AH    R11,RIBLNGTH        POINT TO RIB VARIABLE SECTION.\n         USING RIBVAR,R11          RESOURCE INFORMATION BLOCK.\n         MVC   LINE,BLANK          CLEAR BEFORE USING.\n         USING DSNLINE,R6\n         MVC   DSNT,=CL16'DATA-SET NAME :'\n         XR    R1,R1\n         IC    R1,RIBRNMLN         RNAME LENGTH.\n         BCT   R1,*+L'*+6          MINUS ONE FOR EX INSTRUCTION.\n         MVC   DSN(*-*),RIBRNAME   <<EXECUTED>>\n         EX    R1,*-6              MOVE DSNAME TO PRINT LINE.\n         DROP  R11\n         AH    R11,RIBVLEN         POINT TO FIRST RIBE.\n         USING RIBE,R11            RESOURCE INFORMATION BLOCK EXT.\n         CLC   RIBNTWE,=F'0'       ANY WAITING FOR EXCLUSIVE?\n         BNE   *+L'*+10            YES, PROCESS.\n         CLC   RIBNTWS,=F'0'       ANY WAITING FOR SHARE?\n         BE    BUMPRIB             NO, BUMP TO NEXT RIB.\n         DROP  R6\n         LA    R0,L'BLANK          A BLANK LINE.\n         LA    R1,BLANK\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         LA    R0,L'LINE           PRINT DATA-SET NAME.\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         LA    R0,L'FLAGHD         PRINT FLAG HEADER.\n         LA    R1,FLAGHD\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         MVI   LINE,C'-'\n         MVC   LINE+1(L'FLAGHD-1),LINE\n         LA    R0,L'FLAGHD         UNDER LINE IT.\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     SEARCH              +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\nSEARCH   MVC   LINE,BLANK          CLEAR BEFORE USING.\n         OI    SWITCH,ENQSW        SET SWITCH THAT THERE WAS ENQ.\n         USING JOBLINE,R6\n         MVC   JOBNAME,RIBEJBNM    JOBNAME OF REQUESTOR.\n         MVC   SYSTEM(4),RIBESYSN  SYSTEM NAME OF REQUESTOR.\n         TM    RIBERFLG,RIBETYPE   IS THIS EXCLUSIVE OR SHARED?\n         BO    *+L'*+10            BRANCH IF SHARED.\n         MVC   EXCLFLAG,=CL4'EXCL' NO, EXCLUSIVE.\n         B     *+L'*+6\n         MVC   EXCLFLAG,=CL4'SHR'\n         TM    RIBERFLG,RIBEMC     IS MUST COMPLETE?\n         BO    *+L'*+8             BRANCH IF YES.\n         MVI   MCFLAG,C'N'\n         B     *+L'*+4\n         MVI   MCFLAG,C'Y'\n         TM    RIBERFLG,RIBERESV   IS THIS RESERVE REQUEST?\n         BO    *+L'*+8             BRANCH IF YES.\n         MVI   RESVFLAG,C'N'\n         B     *+L'*+4\n         MVI   RESVFLAG,C'Y'\n         TM    RIBERFLG,RIBERESC   IS THIS RESERVE REQUEST GLOBAL?\n         BO    *+L'*+8             BRANCH IF YES.\n         MVI   GLOBFLAG,C'N'\n         B     *+L'*+4\n         MVI   GLOBFLAG,C'Y'\n         TM    RIBESFLG,RIBESTAT   IS THIS GUY THE OWNER?\n         BO    *+L'*+14            BRANCH IF YES.\n         MVI   OWNFLAG,C'N'\n         MVC   WAITFLAG,=CL9'*WAITING*' TELL USER WAITING DATA-SET.\n         B     *+L'*+4\n         MVI   OWNFLAG,C'Y'\n         DROP  R6,R11\n         LA    R0,L'LINE           PRINT IT.\n         LA    R1,LINE\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         AH    R11,RIBELENG        POINT TO NEXT RIBE.\n         BCT   R9,SEARCH           DO IT FOR NEXT USER.\nBUMPRIB  XR    R3,R3\n         L     R4,RIBNRIBE         NUMBER OF RIBE'S.\n         LTR   R4,R4\n         BNP   *+L'*+8             NO RIBE'S SUPPLIED.\n         AH    R3,RIBELENG         ADD RIBE LENGTH.\n         BCT   R4,*-4              ADD TIMES NO. OF RIBE'S.\n         AH    R3,RIBLNGTH         ADD LENGTH OF RIB.\n         AH    R3,RIBVLEN          ADD LENGTH OF VARIABLE SECTION.\n         AR    R10,R3              POINT TO NEXT RIB.\n         BCT   R7,RIBLOOP          LOOP UNTIL NO MORE RIBS.\n         DROP  R10\nRETURN   TM    SWITCH,TKNSW        IS THERE MORE DATA?\n         BZ    *+L'*+8             NO\n         NI    SWITCH,255-TKNSW    YES\n         B     START               GO CONTINUE PROCESSING.\n         TM    SWITCH,ENQSW        WAS THERE AN ENQ?\n         BO    LEAVE               YES, EXIT.\n         LA    R0,L'BLANK          NO, A BLANK LINE.\n         LA    R1,BLANK\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     *+L'*+4             +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         LA    R0,L'NOENQ          TELL USER.\n         LA    R1,NOENQ\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)\n         B     LEAVE               +0 - CONTINUE.\n         B     SETRC               +4 - ERROR.\n         DROP  R5\nLEAVE    XR    R15,R15             RC = 0 -----------------------------\nQUIT    $XRET  CC=(R15),LV=WRKL,TYPE=RENT\nNOTAUT   LA    R0,L'NAUTM          UNAUTHORIZED COMMAND.\n         LA    R1,NAUTM\n         B     FINISH\nCODE0C   LA    R0,L'CODE0CM        ERROR IN GQSCAN.\n         LA    R1,CODE0CM\n         B     FINISH\nCODE10   LA    R0,L'CODE10M        INVALID SYSNAME.\n         LA    R1,CODE10M\n         B     FINISH\nCODE14   LA    R0,L'CODE14M        ERROR IN GQSCAN.\n         LA    R1,CODE14M\nFINISH   BAS   R14,PUTLNE\nSETRC    LA    R15,16              RC = 16 ----------------------------\n         B     QUIT\n         EJECT\n*------- SKELETONS, CONSTANTS AND MESSAGES\n         SPACE 1\n        PRINT  NOGEN\nSCANP   GQSCAN AREA=(,SIAL),REQLIM=MAX,SCOPE=ALL,MF=L\n        PRINT  GEN\nLSCAN    EQU   *-SCANP\n         SPACE 1\nFLAGHD   DS    0CL72               FLAG HEADER.\n         DC    CL14'JOBNAME/USERID'\n         DC    CL5' '\n         DC    CL4'DISP'\n         DC    CL2' '\n         DC    CL8' SYSTEM '\n         DC    CL2' '\n         DC    CL13'MUST COMPLETE'\n         DC    CL2' '\n         DC    CL7'RESERVE'\n         DC    CL2' '\n         DC    CL6'GLOBAL'\n         DC    CL2' '\n         DC    CL5'OWNER'\n         SPACE 1\nNAUTM    DC    C' -> UNAUTHORIZED COMMAND.'\nCODE04M  DC    C' -> GQSCAN : NO RESOURCES ENQUEUED'\nCODE0CM  DC    C' -> GQSCAN : ERROR WHILE PROCESSING'\nCODE10M  DC    C' -> GQSCAN : \"SYSNAME\" IS INVALID'\nCODE14M  DC    C' -> GQSCAN : \"AREA\" TOO SHORT'\nNOENQ    DC    C'NO DATA-SETS ENQUE''S CONFLICTS EXIST.'\nBLANK    DC    CL72' '\n         SPACE 1\n        LTORG\n         EJECT\n*------- WORK-AREAS DESCRIPTION\n         SPACE 1\nDSNLINE  DSECT                     DATA-SET NAME LINE DESCRIPTION.\nDSNT     DC    CL16'DATA-SET NAME :'\nDSN      DS    CL44\n         SPACE 1\nJOBLINE  DSECT                     INFO LINE DESCRIPTION.\nJOBNAME  DS    CL8\n         DC    C' '\nWAITFLAG DS    CL9' '\n         DC    C' '\nEXCLFLAG DS    CL4\n         DC    CL4' '\nSYSTEM   DS    CL4\n         DC    CL4' '\n         DC    CL6' '\nMCFLAG   DS    CL1\n         DC    CL6' '\n         DC    CL2' '\n         DC    CL3' '\nRESVFLAG DS    CL1\n         DC    CL3' '\n         DC    CL2' '\n         DC    CL2' '\nGLOBFLAG DS    CL1\n         DC    CL3' '\n         DC    CL2' '\n         DC    CL2' '\nOWNFLAG  DS    CL1\n         DC    CL2' '\n         SPACE 1\nWRKDSECT DSECT                     WORK AREAS DESCRIPTIONS.\nSVA      DS    18F                 SAVE AREA.\nSCANSAVE DS    18F                 18 WORDS SAVE AREA REQ FOR GQSCAN.\nWORKD    DS    D\n        $TEW$WA\nSCAN     DS    0F,(LSCAN)X\nTKN      DS    F                   TOKEN AREA ADDRESS.\nRIBLNGTH DC    H'0'                RIB LENGTH.\nRIBELENG DC    H'0'                RIBE LENGTH.\nSYSDSN   DS    CL8                 QNAME FOR GQSCAN.\nLINE     DS    CL72                TERMINAL LINE WORK AREA.\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)\nAUTH     DC    XL1'0'\nREQAUTL  EQU   *-REQAUT\nSWITCH   DS    XL1                 ENQ/TOKEN SWITCHES.\nTKNSW    EQU   X'01'                - TOKEN SWITCH.\nENQSW    EQU   X'02'                - ENQ SWITCH.\nSCANAREA DS    0F,(SIAL)X          SCAN INFO AREA.\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         SPACE 1\n        PRINT NOGEN\n        $TEW$DS CVT=YES\n        IEESMCA\n        ISGRIB\n        PRINT GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOENQ$": {"ttr": 35343, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "//TSOENQ   JOB (........),'INSTALL  -TSOENQ-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=TSOENQ\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  NAME    TSOENQ(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSOENQ@": {"ttr": 35345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      TSOENQ    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          DISPLAY DATA-SETS          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          ENQUE'S CONFLICTS.         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Display data-sets ENQUE's conflicts (TSO CP) on SP1.3\n  ---------    system.\n\n  Command :    Syntax : TSOENQ\n  ---------\n               Default : none.\n\n  Authority :  all the system group USER-id'S are fully authorized to\n  -----------  issue this command, and only operator group USER-id'S\n               with the OPER or ACCT attributes are also allowed to\n               issue it.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TWKD": {"ttr": 35347, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWKDD": {"ttr": 35349, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWKDDK": {"ttr": 35351, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWKDE": {"ttr": 35353, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWKDF": {"ttr": 35355, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWKDI": {"ttr": 35357, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWKDP": {"ttr": 35585, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TXPRINT": {"ttr": 35587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x02O\\x00\\x92\\x02O\\x14\\x17\\x01\\x8b\\x01\\x8b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-01-24T00:00:00", "modifydate": "1992-01-24T14:17:00", "lines": 395, "newlines": 395, "modlines": 0, "user": "SYSPAJA"}, "text": "TPR      TITLE 'TEXT PRINT SUBROUTINE.'\nPRINT    START 0\n         SPACE 2\n* CALLING SEQUENCE : CALL PRINT,(A,B,C,D),VL\n* ------------------            (A,B,C)\n*                               (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE TEXT TO BE PRINTED (THE\n*                    FIRST CHARACTER MUST BE ASA CONTROL CHARACTER).\n*\n*                B - IS THE LENGTH (NUMBER OF CHARACTERS) OF THE TEXT\n*                    (FORMAT FULLWORD - F BOUNDARY). WHEN THIS ARGUMENT\n*                    IS OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS\n*                    SET TO ZERO IN THE PARAMETERS LIST, THE LENGTH OF\n*                    THE TEXT IS SUPPOSED TO BE IN FRONT OF THE TEXT,\n*                    AT THE ADDRESS OF A-1 (FORMAT XL1).\n*\n*                C - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSPRINT'.\n*\n*                D - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - PRINT CORRECTLY EXECUTED.\n*                     1 - DD-CARD MISSING.\n*                     2 - OPEN ERROR, NOT ASA OR LRECL TOO LARGE.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - LENGTH IS NEGATIVE , ZERO OR GREATER THAN THE\n*                         LOGICAL RECORD LENGTH (MAXIMUM ALLOWABLE IS\n*                         145). THE LINE IS PRINTED, BUT TRUNCATED.\n*                     5 - PRINT ERROR.\n*\n*                     --- IF THE ROUTINE IS RE-CALLED AFTER IND = 1\n*                         OR 2, THE PROGRAM IS SENDED IN ABEND U0001.\n*                         IF THE INDICATOR RESPONSE IS DETECTED 10\n*                         TIMES DIFFERENT FROM 0, THE PROGRAM IS\n*                         SENDED IN ABEND U0002.\n         EJECT\n* CALLING SEQUENCE : CALL PCLOSE,(A,B),VL\n* ------------------             (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) TO\n*                    CLOSE. IF THIS ARGUMENT CONTAINS THE 'CLOSEALL'\n*                    KEYWORD, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, OR THE PARAMETERS\n*                    LIST POINTER (REGISTER 1) IS ZERO, ALL THE\n*                    OPENED FILES ARE CLOSED.\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE, ARGUMENT ALIGNMENT OR\n*                         DD-NAME ERROR.\n*\n* GENERAL NOTICE : ON ANY ERROR DETECTION, A MESSAGE IS INCLUDED\n* ---------------- IN THE MESSAGE CLASS FOR THE JOB.\n*                  MVS/XA : MUST BE AMODE AND RMODE 24.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n         SPACE 1\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\nNPRTLGTH EQU   133                 DEFAULT PRINTER RECORD LENGTH.\n         EJECT\n        PRINT  NOGEN\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 1\n*        FILE BLOCK WORK AREA DESCRIPTION.\n         SPACE 1\nFBWAD    DSECT\nFCHAIN   DC    F'0'                CHAIN WORD.\nFDDNM    DC    CL8' '              DD-NAME.\nFERCNT   DC    H'10'               ERROR COUNT.\nFFLAGS   DC    XL1'0'              FLAGS BYTE.\nFAB      EQU   X'01'                    ABEND.\nFOE      EQU   X'02'                    OPEN ERROR.\nFPE      EQU   X'04'                    PRINT ERROR.\nFTR      EQU   X'08'                    TRUNCATED.\nFRB      EQU   X'10'                    VARIABLE RECORD FORMAT.\n         DC    XL1'0'              UNUSED.\nFMLRL    DC    F'0'                MAX. LOGICAL RECORD LENGTH.\n         SPACE 1\nPRINT    CSECT                     RESTORE MAIN CSECT.\n         EJECT\n        $XENT  BASE=R12\n         SPACE 1\n         XR    R9,R9               SET DEFAULTS.\n         LA    R6,DDDEF\n         LA    R10,MAXERR\n         XR    R8,R8\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    PR1\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         TM    7(R1),X'03'\n         BNZ   ERR3\n         TM    4(R1),X'80'\n         BO    PR1\n         L     R7,8(R1)\n         LA    R7,0(R7)\n         LTR   R7,R7\n         BZ    *+L'*+2\n         LR    R6,R7\n         TM    8(R1),X'80'\n         BO    PR1\n         TM    12(R1),X'80'\n         BZ    ERR3\n         TM    15(R1),X'03'\n         BNZ   ERR3\n         L     R9,12(R1)\n         LA    R9,0(R9)\nPR1      L     R7,0(R1)\n         LA    R7,0(R7)\n         LTR   R8,R8\n         BZ    PR2\n         L     R8,0(R8)\n         B     PR3\nPR2      BCTR  R7,0\n         IC    R8,0(R7)\n         LA    R7,1(R7)\nPR3      LTR   R8,R8\n         BNP   ERR4\n         SPACE 1\n         LA    R3,CHAIN            LOOK IF ALREADY DEFINED.\n         USING FBWAD,R4\nPR4      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    PR5\n         CLC   FDDNM(L'FDDNM),0(R6)\n         BE    PR9\n         LR    R3,R4\n         B     PR4\nPR5     GETMAIN R,LV=WSZ\n         LR    R4,R1\n         ST    R4,0(R3)            NEW FILE.\n         MVC   FCHAIN(WSZ),BFILE   SET SKELETON.\n         MVC   FDDNM(L'FDDNM),0(R6)\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         MVC   DCBDDNAM(L'DCBDDNAM),FDDNM\n         OC    ATIOT(L'ATIOT),ATIOT     TEST FIRST TIME.\n         BNZ   PR6\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\nPR6      L     R3,ATIOT            SEARCH DD AND OPEN IT.\n         USING TIODSECT,R3\nPR7      CLC   TIOELNGH(4),ZEROS\n         BE    ERR1\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM\n         BE    PR8\n         XR    R1,R1\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     PR7\n         DROP  R3\nPR8     OPEN   ((R2),(OUTPUT))\n         TM    FFLAGS,FOE          TEST OPEN ERROR SWITCH.\n         BO    ERR2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPEN SUCCESSFULL.\n         BO    PR10\n         B     ERR2\nPR9      TM    FFLAGS,FAB          TEST ABEND SWITCH.\n         BO    ABND1\n         LA    R2,DZ(R4)\n         TM    DCBOFLGS,DCBOFOPN   TEST ALREADY OPENED.\n         BZ    PR8\n         DROP  R2\n         SPACE 1\nPR10     NI    FFLAGS,255-FPE-FTR  RESET SWITCHES.\n         L     R0,FMLRL\n         CLR   R8,R0\n         BNH   PR11\n         OI    FFLAGS,FTR          SET TRUNCATE SWITCH.\n         LR    R8,R0\nPR11     MVI   MESSAGE,C' '\n         MVC   MESSAGE+1(L'MESSAGE-1),MESSAGE\n         TM    FFLAGS,FRB\n         BZ    *+L'*+16\n         LA    R3,MESSLEN\n         LA    R1,4(R8)\n         STH   R1,0(R3)\n         B     *+L'*+4\n         LA    R3,MESSAGE\n         BCTR  R8,0\n         EX    R8,PRMV\n        PUT    (R2),(R3)\n         TM    FFLAGS,FPE          TEST PRINT ERROR SWITCH.\n         BO    ERR5\n         TM    FFLAGS,FTR          TEST TRUNCATE SWITCH.\n         BO    ERR4\n         XR    R10,R10\n         B     PR15\n         SPACE 1\nPRMV     MVC   MESSAGE(*-*),0(R7)\n         SPACE 1\nPRERR    OI    FFLAGS,FPE          SET PRINT ERROR SWITCH.\n         BR    R14\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\n         OI    FFLAGS,FAB          SET ABEND SWITCH TO PREVENT RE-CALL.\nERR3     BCTR  R10,0\nERR4     BCTR  R10,0\nERR5     BCTR  R10,0\n         SPACE 1\nMAXERR   EQU   (((*-ERR1)-4)/2)+1\n         SPACE 1\n         LR    R2,R10\n         BCTR  R2,0\n         SLL   R2,2\n         L     R3,TABD(R2)\n         NI    SWEX+1,OFF          SET SWITCH OFF.\n         CLI   12(R3),C' '\n         BNE   *+L'*+10\n         OI    SWEX+1,ON           SET SWITCH ON.\n         MVC   12(8,R3),0(R6)\n         LR    R1,R3\n        WTO    MF=(E,(1))\nSWEX     B     PR12\n         LA    R3,CNTR             CONTROL MAX. ERROR.\n         B     PR13\nPR12     MVC   12(8,R3),BLKS\n         LA    R3,FERCNT\nPR13     LH    R2,0(R3)\n         BCT   R2,PR14\n         LA    R1,2                SET ABEND CODE.\n         B     ABND\nPR14     STH   R2,0(R3)\n         DROP  R4\n         SPACE 1\nPR15     LTR   R9,R9\n         BZ    PR16\n         ST    R10,0(R9)           STORE IND.\nPR16    $XRET  CC=(R10)\n         SPACE 1\nABND1    LA    R1,1                SET ABEND CODE.\n         SPACE 1\nABND     LR    R15,R10             SET C.C. IN REG. 15.\n        ABEND  (1),DUMP\n         EJECT\n         USING IHADCB,R1\n         USING FBWAD,R4\nDCBEXIT  CLI   DCBRECFM,0          IS FILE DEFINED,\n         BNE   EX0                 BRANCH IF YES.\n         LA    R3,NPRTLGTH         SET DEFAULT VALUES.\n         OI    DCBRECFM,DCBRECF+DCBRECCA\n         STH   R3,DCBBLKSI\n         STH   R3,DCBLRECL\n         ST    R3,FMLRL\n         BR    R14\nEX0      TM    DCBRECFM,DCBRECCA   MUST BE ASA CONTROL CHARACTER.\n         BZ    EX2\n         TM    DCBRECFM,DCBRECF\n         BO    *+L'*+12\n         TM    DCBRECFM,DCBRECV\n         BZ    *+L'*+4\n         OI    FFLAGS,FRB          SET VARIABLE RECORDS FORMAT.\n         LA    R3,L'MESSAGE        CONTROL THE LOGICAL RECORD LENGTH.\n         LH    R2,DCBLRECL\n         LTR   R2,R2\n         BP    EX1\n         LH    R2,DCBBLKSI\n         LTR   R2,R2\n         BNP   EX2\nEX1      CLR   R2,R3\n         BH    EX2\n         ST    R2,FMLRL\n         BR    R14\n         DROP  R1\nEX2      OI    FFLAGS,FOE          SET OPEN ERROR SWITCH.\n         BR    R14\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY PCLOSE\n         SPACE 1\nPCLOSE  $XENT  BASE=R12,DT=NO\n         SPACE 1\n         XR    R9,R9               CONTROL ARGUMENTS.\n         LTR   R8,R1\n         BZ    PC2\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         TM    0(R1),X'80'\n         BO    PC1\n         TM    4(R1),X'80'\n         BZ    ERCL\n         TM    7(R1),X'03'\n         BNZ   ERCL\n         L     R9,4(R1)\n         LA    R9,0(R9)\nPC1      LTR   R8,R8\n         BZ    PC2\n         CLC   0(8,R8),KEYALL\n         BNE   PC2\n         XR    R8,R8\nPC2      LA    R3,CHAIN\n         USING FBWAD,R4\nPC3      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    PC6\n         LTR   R8,R8\n         BZ    PC4\n         CLC   0(L'FDDNM,R8),FDDNM\n         BE    PC4\n         LR    R3,R4\n         B     PC3\nPC4      LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    PC5\n        CLOSE  ((R2))\n         DROP  R2\nPC5      MVC   0(L'FCHAIN,R3),FCHAIN    DEQUEUE FILE.\n         LR    R1,R4\n         DROP  R4\n        FREEMAIN R,A=(1),LV=WSZ\n         LTR   R8,R8\n         BNZ   PC7\n         B     PC3\nPC6      LTR   R8,R8\n         BNZ   ERCL\nPC7      XR    R10,R10\n         LTR   R9,R9\n         BZ    PC8\n         ST    R10,0(R9)           STORE IND.\nPC8     $XRET  CC=(R10)\n         SPACE 1\nERCL     WTO   'ERR=1 - PCLOSE CALLING SEQUENCE, ARGUMENT ALIGNMENT OR 1\n               DD-NAME ERROR.',ROUTCDE=11,DESC=7\n         LA    R10,1\n         B     PC7+L'PC7\n         SPACE 1\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nCHAIN    DC    A(*-*)\nATIOT    DC    A(*-*)\nTABD     DC    A(DIAG1,DIAG2,DIAG3,DIAG4,DIAG5)\nZEROS    DC    F'0'\nDIAG1   WTO    'ERR=1 -          DD-CARD MISSING.',                    1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG2   WTO    'ERR=2 -          OPEN ERROR OR DD-CARD CONFLICT.',     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG3   WTO    'ERR=3 - PRINT CALLING SEQUENCE OR ARGUMENT ALIGNMENT ER1\n               ROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG4   WTO    'ERR=4 - LENGTH IS NEGATIVE, ZERO OR GREATER THAN THE LO1\n               GICAL RECORD.',ROUTCDE=11,DESC=7,MF=L\nDIAG5   WTO    'ERR=5 -          I/O ERROR.',                          1\n               ROUTCDE=11,DESC=7,MF=L\nCNTR     DC    H'10'\nDDDEF    DC    CL8'SYSPRINT'\nKEYALL   DC    CL8'CLOSEALL'\nBLKS     DC    CL8' '\nMESSLEN  DC    F'0'\nMESSAGE  DC    CL145' '\n         EJECT\n        CNOP   0,8\n         SPACE 1\nBFILE    DC    F'0'                CHAIN WORD.\n         DC    CL8' '              DD-NAME.\n         DC    H'10'               ERROR COUNT.\n         DC    XL1'0'              FLAGS BYTE.\n         DC    XL1'0'              UNUSED.\n         DC    F'0'                MAX. LOGICAL RECORD LENGTH.\n         SPACE 1\nDCBPRT  DCB    DSORG=PS,DEVD=DA,MACRF=PM,BFALN=D,                      1\n               EXLST=PEXLIST,SYNAD=PRERR,DDNAME=XXXXXXXX\n         SPACE 1\n        CNOP   0,8\n         SPACE 1\nDZ       EQU   DCBPRT-BFILE\nWSZ      EQU   (((*-BFILE)+7)/8)*8\n         SPACE 1\nPEXLIST  DC    0F'0',XL1'85',AL3(DCBEXIT)\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TXPRINT$": {"ttr": 35594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//PRINT    JOB (........),'INSTALL  - PRINT -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,MBR=TXPRINT\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   PCLOSE\n  NAME    PRINT(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TXPRINT@": {"ttr": 35596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90(\\x1f\\x00\\x90(\\x1f\\x15Q\\x00V\\x00V\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-10-08T00:00:00", "modifydate": "1990-10-08T15:51:00", "lines": 86, "newlines": 86, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      PRINT     1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         TEXT PRINT ROUTINE          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL PRINT,(A,B,C,D),VL\n  ------------------            (A,B,C)\n                                (A,B)\n                                (A)\n\n         Where : A - is the address of the text to be printed (the\n                     first character must be ASA control character).\n\n                 B - is the address of text length (no. of characters :\n                     format FULLWORD - F boundary). When this argument\n                     is omitted, or the address of this argument is\n                     set to zero in the parameters list, the length of\n                     the text is supposed to be in front of the text,\n                     at the address of A-1 (format XL1).\n\n                 C - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSPRINT.\n\n                 D - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - PRINT correctly executed.\n                      1 - DD-card missing.\n                      2 - OPEN error, not ASA or LRECL too large.\n                      3 - calling sequence or argument alignment error.\n                      4 - length is negative, zero or greater than the\n                          logical record length (maximum allowable is\n                          145). The line is printed, but truncated.\n                      5 - PRINT error.\n\n                 --- If the routine is re-called after IND = 1 or 2,\n                     the program is sended in abend U0001. If the\n                     indicator response is detected 10 times different\n                     from 0, the program is sended in abend U0002.\n\n  Assembler macro : $PRINT A,B,C,D\n  -----------------\n\n         Where B, C and/or D are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   28/07/86\n                                                      PRINT     2/2.\n\n  Calling sequence : CALL PCLOSE,(A,B),VL\n  ------------------             (A)\n\n         Where : A - is the address of the DD-name (format CL8) to\n                     close. If this argument contains the CLOSEALL\n                     keyword, or the address of this argument is set\n                     to zero in the parameters list, or the parameters\n                     list pointer (register 1) is zero, all the\n                     opened files are closed.\n\n                 B - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value ia always placed in register 15 and can be :\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence, argument alignment or\n                          DD-name error.\n\n  Assembler macro : $PCLOSE A,B\n  -----------------\n\n         Where A and/or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n\n  General notice : on any error detection, a message is included\n  ================ in the message class for the job.\n                   This routine is multi-files usable, that means\n                   multi-files opened concurrently (using the DD-name\n                   argument).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TXPUNCH": {"ttr": 35599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x171\\x01|\\x01|\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T17:31:00", "lines": 380, "newlines": 380, "modlines": 0, "user": "SYSPAJA"}, "text": "TPU      TITLE 'TEXT PUNCH SUBROUTINE.'\nPUNCH    START 0\n         SPACE 2\n* CALLING SEQUENCE : CALL PUNCH,(A,B,C,D),VL\n* ------------------            (A,B,C)\n*                               (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE TEXT TO BE OUTPUTED.\n*\n*                B - IS THE LENGTH (NUMBER OF CHARACTERS) OF THE TEXT\n*                    (FORMAT FULLWORD - F BOUNDARY). WHEN THIS ARGUMENT\n*                    IS OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS\n*                    SET TO ZERO IN THE PARAMETERS LIST, THE LENGTH OF\n*                    THE TEXT IS SUPPOSED TO BE IN FRONT OF THE TEXT,\n*                    AT THE ADDRESS OF A-1 (FORMAT XL1).\n*\n*                C - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSPUNCH'.\n*\n*                D - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - OUTPUT CORRECTLY EXECUTED.\n*                     1 - DD-CARD MISSING.\n*                     2 - OPEN ERROR OR NOT FIXED RECORD FORMAT.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - LENGTH IS NEGATIVE, ZERO OR GREATER THAN THE\n*                         LOGICAL RECORD LENGTH (MAXIMUM ALLOWABLE IS\n*                         200). THE TEXT IS OUTPUTED, BUT TRUNCATED.\n*                     5 - OUTPUT ERROR.\n*\n*                     --- IF THE ROUTINE IS RE-CALLED AFTER IND = 1\n*                         OR 2, THE PROGRAM IS SENDED IN ABEND U0001.\n*                         IF THE INDICATOR RESPONSE IS DETECTED 10\n*                         TIMES DIFFERENT FROM 0, THE PROGRAM IS\n*                         SENDED IN ABEND U0002.\n*\n         EJECT\n* CALLING SEQUENCE : CALL UCLOSE,(A,B),VL\n* ------------------             (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) TO\n*                    CLOSE. IF THIS ARGUMENT CONTAINS THE 'CLOSEALL'\n*                    KEYWORD, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, OR THE PARAMETERS\n*                    LIST POINTER (REGISTER 1) IS ZERO, ALL THE\n*                    OPENED FILES ARE CLOSED.\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE:\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE, ARGUMENT ALIGNMENT OR\n*                         DD-NAME ERROR.\n*\n* GENERAL NOTICE : ON ANY ERROR DETECTION, A MESSAGE IS INCLUDED\n* ---------------- IN THE MESSAGE CLASS FOR THE JOB.\n*                  MVS/XA : MUST BE AMODE AND RMODE 24.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\n         EJECT\n        PRINT  NOGEN\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 1\n*        FILE BLOCK WORK AREA DESCRIPTION.\n         SPACE 1\nFBWAD    DSECT\nFCHAIN   DC    F'0'                CHAIN WORD.\nFDDNM    DC    CL8' '              DD-NAME.\nFERCNT   DC    H'10'               ERROR COUNT.\nFFLAGS   DC    XL1'0'              FLAGS BYTE.\nFAB      EQU   X'01'                    ABEND.\nFOE      EQU   X'02'                    OPEN ERROR.\nFPE      EQU   X'04'                    PUNCH ERROR.\nFTR      EQU   X'08'                    TRUNCATED.\n         DC    XL1'0'              UNUSED.\nFMLRL    DC    F'0'                MAX. LOGICAL RECORD LENGTH.\n         SPACE 1\nPUNCH    CSECT                     RESTORE MAIN CSECT.\n         EJECT\n        $XENT  BASE=R12\n         SPACE 1\n         SR    R9,R9               SET DEFAULTS.\n         LA    R6,DDDEF\n         LA    R10,MAXERR\n         SR    R8,R8\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    PU1\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         TM    7(R1),X'03'\n         BNZ   ERR3\n         TM    4(R1),X'80'\n         BO    PU1\n         L     R7,8(R1)\n         LA    R7,0(R7)\n         LTR   R7,R7\n         BZ    *+L'*+2\n         LR    R6,R7\n         TM    8(R1),X'80'\n         BO    PU1\n         TM    12(R1),X'80'\n         BZ    ERR3\n         TM    15(R1),X'03'\n         BNZ   ERR3\n         L     R9,12(R1)\n         LA    R9,0(R9)\nPU1      L     R7,0(R1)\n         LA    R7,0(R7)\n         LTR   R8,R8\n         BZ    PU2\n         L     R8,0(R8)\n         B     PU3\nPU2      BCTR  R7,0\n         IC    R8,0(R7)\n         LA    R7,1(R7)\nPU3      LTR   R8,R8\n         BNP   ERR4\n         SPACE 1\n         LA    R3,CHAIN            LOOK IF ALREADY DEFINED.\n         USING FBWAD,R4\nPU4      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    PU5\n         CLC   FDDNM(L'FDDNM),0(R6)\n         BE    PU9\n         LR    R3,R4\n         B     PU4\nPU5     GETMAIN R,LV=WSZ\n         LR    R4,R1\n         ST    R4,0(R3)            NEW FILE.\n         MVC   FCHAIN(WSZ),BFILE   SET SKELETON.\n         MVC   FDDNM(L'FDDNM),0(R6)\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         MVC   DCBDDNAM(L'DCBDDNAM),FDDNM\n         OC    ATIOT(L'ATIOT),ATIOT     TEST FIRST TIME.\n         BNZ   PU6\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\nPU6      L     R3,ATIOT            SEARCH DD AND OPEN IT.\n         USING TIODSECT,R3\nPU7      CLC   TIOELNGH(4),ZEROS\n         BE    ERR1\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM\n         BE    PU8\n         SR    R1,R1\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     PU7\n         DROP  R3\nPU8     OPEN   ((R2),(OUTPUT))\n         TM    FFLAGS,FOE          TEST OPEN ERROR SWITCH.\n         BO    ERR2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPEN SUCCESSFULL.\n         BO    PU10\n         B     ERR2\nPU9      TM    FFLAGS,FAB          TEST ABEND SWITCH.\n         BO    ABND1\n         LA    R2,DZ(R4)\n         TM    DCBOFLGS,DCBOFOPN   TEST ALREADY OPENED.\n         BZ    PU8\n         DROP  R2\n         SPACE 1\nPU10     NI    FFLAGS,255-FPE-FTR  CLEAR SWITCHES.\n         L     R0,FMLRL\n         CLR   R8,R0\n         BNH   PU11\n         OI    FFLAGS,FTR          SET TRUNCATE SWITCH.\n         LR    R8,R0\nPU11     BCTR  R8,0\n         MVI   TEXT,C' '\n         MVC   TEXT+1(L'TEXT-1),TEXT\n         EX    R8,PUMV\n        PUT    (R2),TEXT\n         TM    FFLAGS,FPE          TEST PUNCH ERROR SWITCH.\n         BO    ERR5\n         TM    FFLAGS,FTR          TEST TRUNCATE SWITCH.\n         BO    ERR4\n         SR    R10,R10\n         B     PU15\n         SPACE 1\nPUMV     MVC   TEXT(*-*),0(R7)\n         SPACE 1\nPUERR    OI    FFLAGS,FPE          SET PUNCH ERROR SWITCH.\n         BR    R14\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\n         OI    FFLAGS,FAB          SET ABEND SWITCH TO PREVENT RE-CALL.\nERR3     BCTR  R10,0\nERR4     BCTR  R10,0\nERR5     BCTR  R10,0\n         SPACE 1\nMAXERR   EQU   (((*-ERR1)-4)/2)+1\n         SPACE 1\n         LR    R2,R10\n         BCTR  R2,0\n         SLL   R2,2\n         L     R3,TABD(R2)\n         NI    SWEX+1,OFF          SET SWITCH OFF.\n         CLI   12(R3),C' '\n         BNE   *+L'*+10\n         OI    SWEX+1,ON           SET SWITCH ON.\n         MVC   12(8,R3),0(R6)\n         LR    R1,R3\n        WTO    MF=(E,(1))\nSWEX     B     PU12\n         LA    R3,CNTR             CONTROL MAX. ERROR.\n         B     PU13\nPU12     MVC   12(8,R3),BLKS\n         LA    R3,FERCNT\nPU13     LH    R2,0(R3)\n         BCT   R2,PU14\n         LA    R1,2                SET ABEND CODE.\n         B     ABND\nPU14     STH   R2,0(R3)\n         DROP  R4\n         SPACE 1\nPU15     LTR   R9,R9\n         BZ    PU16\n         ST    R10,0(R9)           STORE IND.\nPU16    $XRET  CC=(R10)\n         SPACE 1\nABND1    LA    R1,1                SET ABEND CODE.\n         SPACE 1\nABND     LR    R15,R10             SET C.C. IN REG. 15.\n        ABEND  (1),DUMP\n         EJECT\n         USING IHADCB,R1\n         USING FBWAD,R4\nDCBEXIT  LA    R3,L'TEXT\n         CLI   DCBRECFM,0          IS FILE DEFINED,\n         BNE   EX0                 BRANCH IF YES.\n         OI    DCBRECFM,DCBRECF    SET DEFAULT VALUES.\n         STH   R3,DCBBLKSI\n         STH   R3,DCBLRECL\n         ST    R3,FMLRL\n         BR    R14\nEX0      TM    DCBRECFM,DCBRECF    MUST BE FIXED RECORD LENGTH.\n         BZ    EX2\n         TM    DCBRECFM,DCBRECV\n         BO    EX2\n         LH    R2,DCBLRECL\n         LTR   R2,R2\n         BP    EX1\n         LH    R2,DCBBLKSI\n         LTR   R2,R2\n         BNP   EX2\nEX1      CLR   R2,R3\n         BH    EX2\n         ST    R2,FMLRL\n         BR    R14\n         DROP  R1\nEX2      OI    FFLAGS,FOE          SET OPEN ERROR SWITCH.\n         BR    R14\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY UCLOSE\n         SPACE 1\nUCLOSE  $XENT  BASE=R12,DT=NO\n         SPACE 1\n         SR    R9,R9               CONTROL ARGUMENTS.\n         LTR   R8,R1\n         BZ    UC2\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         TM    0(R1),X'80'\n         BO    UC1\n         TM    4(R1),X'80'\n         BZ    ERCL\n         TM    7(R1),X'03'\n         BNZ   ERCL\n         L     R9,4(R1)\n         LA    R9,0(R9)\nUC1      LTR   R8,R8\n         BZ    UC2\n         CLC   0(8,R8),KEYALL\n         BNE   UC2\n         SR    R8,R8\nUC2      LA    R3,CHAIN\n         USING FBWAD,R4\nUC3      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    UC6\n         LTR   R8,R8\n         BZ    UC4\n         CLC   0(L'FDDNM,R8),FDDNM\n         BE    UC4\n         LR    R3,R4\n         B     UC3\nUC4      LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    UC5\n        CLOSE  ((R2))\n         DROP  R2\nUC5      MVC   0(L'FCHAIN,R3),FCHAIN    DEQUEUE FILE.\n         LR    R1,R4\n         DROP  R4\n        FREEMAIN R,A=(1),LV=WSZ\n         LTR   R8,R8\n         BNZ   UC7\n         B     UC3\nUC6      LTR   R8,R8\n         BNZ   ERCL\nUC7      SR    R10,R10\n         LTR   R9,R9\n         BZ    UC8\n         ST    R10,0(R9)           STORE IND.\nUC8     $XRET  CC=(R10)\n         SPACE 1\nERCL    WTO    'ERR=1 - PCLOSE CALLING SEQUENCE, ARGUMENT ALIGNMENT OR 1\n               DD-NAME ERROR.',ROUTCDE=11,DESC=7\n        LA     R10,1\n        B      UC7+L'UC7\n         SPACE 1\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nCHAIN    DC    A(*-*)\nATIOT    DC    A(*-*)\nTABD     DC    A(DIAG1,DIAG2,DIAG3,DIAG4,DIAG5)\nZEROS    DC    F'0'\nDIAG1   WTO    'ERR=1 -          DD-CARD MISSING.',                    1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG2   WTO    'ERR=2 -          OPEN ERROR OR DD-CARD CONFLICT.',     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG3   WTO    'ERR=3 - PUNCH CALLING SEQUENCE OR ARGUMENT ALIGNMENT ER1\n               ROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG4   WTO    'ERR=4 - LENGTH IS NEGATIVE, ZERO OR GREATER THAN THE LO1\n               GICAL RECORD.',ROUTCDE=11,DESC=7,MF=L\nDIAG5   WTO    'ERR=5 -          I/O ERROR.',                          1\n               ROUTCDE=11,DESC=7,MF=L\nCNTR     DC    H'10'\nDDDEF    DC    CL8'SYSPUNCH'\nKEYALL   DC    CL8'CLOSEALL'\nBLKS     DC    CL8' '\nTEXT     DC    CL200' '\n         EJECT\n        CNOP   0,8\n         SPACE 1\nBFILE    DC    F'0'                CHAIN WORD.\n         DC    CL8' '              DD-NAME.\n         DC    H'10'               ERROR COUNT.\n         DC    XL1'0'              FLAGS BYTE.\n         DC    XL1'0'              UNUSED.\n         DC    F'0'                MAX. LOGICAL RECORD LENGTH.\n         SPACE 1\nDCBPUN  DCB    DSORG=PS,DEVD=DA,MACRF=PM,BFALN=D,                      1\n               EXLST=PEXLIST,SYNAD=PUERR,DDNAME=XXXXXXXX\n         SPACE 1\n        CNOP   0,8\n         SPACE 1\nDZ       EQU   DCBPUN-BFILE\nWSZ      EQU   (((*-BFILE)+7)/8)*8\n         SPACE 1\nPEXLIST  DC    0F'0',XL1'85',AL3(DCBEXIT)\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TXPUNCH$": {"ttr": 35847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//PUNCH    JOB (........),'INSTALL  - PUNCH -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,MBR=TXPUNCH\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   UCLOSE\n  NAME    PUNCH(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TXPUNCH@": {"ttr": 35849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14S\\x00T\\x00T\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:53:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      PUNCH     1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         TEXT PUNCH ROUTINE          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL PUNCH,(A,B,C,D),VL\n  ------------------            (A,B,C)\n                                (A,B)\n                                (A)\n\n         Where : A - is the address of the text to be outputed.\n\n                 B - is the address of text length (no. of characters :\n                     format FULLWORD - F boundary). When this argument\n                     is omitted, or the address of this argument is\n                     set to zero in the parameters list, the length of\n                     the text is supposed to be in front of the text,\n                     at the address of A-1 (format XL1).\n\n                 C - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSPUNCH.\n\n                 D - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - OUTPUT correctly executed.\n                      1 - DD-card missing.\n                      2 - OPEN error or not fixed record format.\n                      3 - calling sequence or argument alignment error.\n                      4 - length is negative, zero or greater than the\n                          logical record length (maximum allowable is\n                          200). The text is outputed, but truncated.\n                      5 - OUTPUT error.\n\n                 --- If the routine is re-called after IND = 1 or 2,\n                     the program is sended in abend U0001. If the\n                     indicator response is detected 10 times different\n                     from 0, the program is sended in abend U0002.\n\n  Assembler macro : $PUNCH A,B,C,D\n  -----------------\n\n         Where B, C and/or D are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   28/07/86\n                                                      PUNCH     2/2.\n\n  Calling sequence : CALL UCLOSE,(A,B),VL\n  ------------------             (A)\n\n         Where : A - is the address of the DD-name (format CL8) to\n                     close. If this argument contains the CLOSEALL\n                     keyword, or the address of this argument is set\n                     to zero in the parameters list, or the parameters\n                     list pointer (register 1) is zero, all the\n                     opened files are closed.\n\n                 B - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be:\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence, argument alignment or\n                          DD-name error.\n\n  Assembler macro : $UCLOSE A,B\n  -----------------\n         Where A and/or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n\n  General notice : on any error detection, a message is included\n  ================ in the message class for the job.\n                   This routine is multi-files usable, that means\n                   multi-files opened concurrently (using the DD-name\n                   argument).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TXREAD": {"ttr": 35852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x07/\\x00\\x89\\x07/\\x12\\x18\\x01j\\x01j\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-03-13T00:00:00", "modifydate": "1989-03-13T12:18:00", "lines": 362, "newlines": 362, "modlines": 0, "user": "SYSPAJA"}, "text": "TRD      TITLE 'TEXT READ SUBROUTINE.'\nREAD     START 0\n         SPACE 1\n* CALLING SEQUENCE : CALL READ,(A,B,C),VL\n* ------------------           (A,B)\n*                              (A)\n*\n*        WHERE : A - IS THE ADDRESS OF AN ARRAY (FORMAT CL...) WHICH\n*                    RECEIVES THE TEXT IMAGE.\n*\n*                B - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS\n*                    SET TO ZERO IN THE PARAMETERS LIST, THE\n*                    DEFAULT DD-NAME USED IS 'SYSIN   '.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                    -1 - END-OF-FILE.\n*                     0 - READ CORRECTLY EXECUTED.\n*                     1 - DD-CARD MISSING.\n*                     2 - OPEN ERROR OR NOT FIXED RECORD FORMAT.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - READ ERROR.\n*\n*                     --- IF THE ROUTINE IS RE-CALLED AFTER IND = 1\n*                         OR 2, THE PROGRAM IS SENDED IN ABEND U0001.\n*                         IF THE INDICATOR RESPONSE IS DETECTED 10\n*                         TIMES DIFFERENT FROM 0, THE PROGRAM IS\n*                         SENDED IN ABEND U0002.\n*\n* HOW TO SUPPRESS THE 'DD-CARD MISSING' MESSAGE.\n* ----------------------------------------------\n*\n*        BEFORE ENTERING THE FIRST TIME THE READ ROUTINE FOR A FILE\n* (DD-NAME), EXECUTE THE FOLLOWING TWO INSTRUCTIONS :\n*                    ...\n*                    L     RX,=V(#RMSW#)\n*                    MVI   0(RX),1\n*                    ...\n*        THEN IF ERR-1 OCCURS DURING THE FIRST CALL (OPEN FILE TIME),\n* THE MESSAGE IS BYPASSED (THE REGISTER 15 AND THE INDICATOR RESPONSE\n* ARE EVENTUALLY SET).\n         EJECT\n* CALLING SEQUENCE : CALL RCLOSE,(A,B),VL\n* ------------------             (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) TO\n*                    CLOSE. IF THIS ARGUMENT CONTAINS THE 'CLOSEALL'\n*                    KEYWORD, OR THE ADDRESS OF THIS ARGUMENT IS\n*                    SET TO ZERO IN THE PARAMETERS LIST, OR THE\n*                    PARAMETERS LIST POINTER (REGISTER 1) IS ZERO,\n*                    ALL THE OPENED FILES ARE CLOSED.\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE, ARGUMENT ALIGNMENT OR\n*                         DD-NAME ERROR.\n*\n* GENERAL NOTICE : ON ANY ERROR DETECTION, A MESSAGE IS INCLUDED\n* ---------------- IN THE MESSAGE CLASS FOR THE JOB.\n*                  MVS/XA : MUST BE AMODE AND RMODE 24.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n         ENTRY #RMSW#\n         SPACE 1\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\n         EJECT\n        PRINT  NOGEN\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 1\n*        FILE BLOCK WORK AREA DESCRIPTION.\n         SPACE 1\nFBWAD    DSECT\nFCHAIN   DC    F'0'                CHAIN WORD.\nFDDNM    DC    CL8' '              DD-NAME.\nFERCNT   DC    H'10'               ERROR COUNT.\nFFLAGS   DC    XL1'0'              FLAGS BYTE.\nFAB      EQU   X'01'                    ABEND.\nFAM      EQU   X'02'                    ABEND S013-18.\nFOE      EQU   X'04'                    OPEN ERROR.\nFRE      EQU   X'08'                    READ ERROR.\n         DC    XL1'0'              UNUSED.\n         SPACE 1\nREAD     CSECT                     RESTORE MAIN CSECT.\n         EJECT\n        $XENT  BASE=R12\n         SPACE 1\n         SR    R9,R9               SET DEFAULTS.\n         LA    R8,DDDEF\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    RD1\n         L     R7,4(R1)\n         LA    R7,0(R7)\n         LTR   R7,R7\n         BZ    *+L'*+2\n         LR    R8,R7\n         TM    4(R1),X'80'\n         BO    RD1\n         TM    8(R1),X'80'\n         BZ    ERR3\n         TM    11(R1),X'03'\n         BNZ   ERR3\n         L     R9,8(R1)\n         LA    R9,0(R9)\nRD1      L     R7,0(R1)\n         LA    R7,0(R7)\n         SPACE 1\n         LA    R3,CHAIN            LOOK IF ALREADY DEFINED.\n         USING FBWAD,R4\nRD2      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    RD3\n         CLC   FDDNM(L'FDDNM),0(R8)\n         BE    RD8\n         LR    R3,R4\n         B     RD2\nRD3     GETMAIN R,LV=WSZ\n         LR    R4,R1\n         ST    R4,0(R3)            NEW FILE.\n         MVC   FCHAIN(WSZ),BFILE   SET SKELETON.\n         MVC   FDDNM(L'FDDNM),0(R8)\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         MVC   DCBDDNAM(L'DCBDDNAM),FDDNM\n         OC    ATIOT(L'ATIOT),ATIOT     TEST FIRST TIME.\n         BNZ   RD4\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\nRD4      L     R3,ATIOT            SEARCH DD AND OPEN IT.\n         USING TIODSECT,R3\nRD5      CLC   TIOELNGH(4),ZEROS\n         BE    ERR1\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM\n         BE    RD6\n         SR    R1,R1\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     RD5\n         DROP  R3\nRD6     OPEN   ((R2),(INPUT))\n         TM    FFLAGS,FAM          TEST ABEND S013-18 SWITCH.\n         BZ    RD7\n        WTO    MF=(E,ERAB)\n         B     ERR2\nRD7      TM    FFLAGS,FOE          TEST OPEN ERROR SWITCH.\n         BO    ERR2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPEN SUCCESSFULL.\n         BO    RD9\n         B     ERR2\nRD8      TM    FFLAGS,FAB          TEST ABEND SWITCH.\n         BO    ABND1\n         LA    R2,DZ(R4)\n         TM    DCBOFLGS,DCBOFOPN   TEST ALREADY OPENED.\n         BZ    RD6\n         DROP  R2\n         SPACE 1\nRD9      NI    FFLAGS,255-FRE      CLEAR READ ERROR SWITCH.\n        GET    (R2),(R7)\n         TM    FFLAGS,FRE          TEST READ ERROR SWITCH.\n         BO    ERR4\n         SR    R10,R10\n         B     RD13\n         SPACE 1\nRDERR    OI    FFLAGS,FRE          SET READ ERROR SWITCH.\n         BR    R14\n         SPACE 1\nRDEND   CLOSE  ((R2))\n         SR    R10,R10\n         BCTR  R10,0\n         B     RD13\n         SPACE 1\nERR1     BCTR  R10,0\n         MVC   SWMS+1(1),SWMS\nERR2     BCTR  R10,0\n         OI    FFLAGS,FAB          SET ABEND SWITCH TO PREVENT RE-CALL.\nERR3     BCTR  R10,0\nERR4     BCTR  R10,0\n         SPACE 1\nMAXERR   EQU   (((*-ERR1)-10)/2)+1\n         SPACE 1\n         LR    R2,R10\n         BCTR  R2,0\n         SLL   R2,2\n         L     R3,TABD(R2)\n         NI    SWEX+1,OFF          SET SWITCH OFF.\n         CLI   12(R3),C' '\n         BNE   *+L'*+10\n         OI    SWEX+1,ON           SET SWITCH ON.\n         MVC   12(8,R3),0(R8)\n         LR    R1,R3\n         CLI   SWMS+1,0\n         BNE   SWEX\n        WTO    MF=(E,(1))\nSWEX     B     RD10\n         LA    R3,CNTR             CONTROL MAX. ERROR.\n         B     RD11\nRD10     MVC   12(8,R3),BLKS\n         LA    R3,FERCNT\nRD11     LH    R2,0(R3)\n         BCT   R2,RD12\n         LA    R1,2                SET ABEND CODE.\n         B     ABND\nRD12     STH   R2,0(R3)\n         DROP  R4\n         SPACE 1\nRD13     XC    SWMS,SWMS\n         LTR   R9,R9\n         BZ    RD14\n         ST    R10,0(R9)           STORE IND.\nRD14    $XRET  CC=(R10)\n         SPACE 1\nABND1    LA    R1,1                SET ABEND CODE.\n         SPACE 1\nABND     LR    R15,R10             SET C.C. IN REG. 15.\n        ABEND  (1),DUMP\n         SPACE 1\n         CNOP  0,4\n         USING IHADCB,R1\n         USING FBWAD,R4\nDCBEXIT  TM    DCBRECFM,DCBRECF    MUST BE FIXED RECORD LENGTH.\n         BZ    EX1\n         TM    DCBRECFM,DCBRECV\n         BZR   R14\n         DROP  R1\nEX1      OI    FFLAGS,FOE          SET OPEN ERROR SWITCH.\n         BR    R14\n         SPACE 1\n         CNOP  0,4\nDCBABND  TM    3(R1),X'04'         TEST OK TO IGNORE.\n         BZ    *+L'*+10            NO.\n         CLC   0(3,R1),S013RC18    YES, TEST ABEND S013-18.\n         BE    *+L'*+6             YES.\n         MVI   3(R1),0             NO, ABEND TASK IMMEDIATELY.\n         BR    R14\n         MVI   3(R1),4             SET IGNORE ABEND CONDITION.\n         OI    FFLAGS,FAM\n         BR    R14\nS013RC18 DC    XL3'013018'\n         SPACE 1\n         DROP  R4,R12\n         EJECT\n         ENTRY RCLOSE\n         SPACE 1\nRCLOSE  $XENT  BASE=R12,DT=NO\n         SPACE 1\n         SR    R9,R9               CONTROL ARGUMENTS.\n         LTR   R8,R1\n         BZ    RC2\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         TM    0(R1),X'80'\n         BO    RC1\n         TM    4(R1),X'80'\n         BZ    ERCL\n         TM    7(R1),X'03'\n         BNZ   ERCL\n         L     R9,4(R1)\n         LA    R9,0(R9)\nRC1      LTR   R8,R8\n         BZ    RC2\n         CLC   0(8,R8),KEYALL\n         BNE   RC2\n         SR    R8,R8\nRC2      LA    R3,CHAIN\n         USING FBWAD,R4\nRC3      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    RC6\n         LTR   R8,R8\n         BZ    RC4\n         CLC   0(L'FDDNM,R8),FDDNM\n         BE    RC4\n         LR    R3,R4\n         B     RC3\nRC4      LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    RC5\n        CLOSE  ((R2))\n         DROP  R2\nRC5      MVC   0(L'FCHAIN,R3),FCHAIN    DEQUEUE FILE.\n         LR    R1,R4\n         DROP  R4\n        FREEMAIN R,A=(1),LV=WSZ\n         LTR   R8,R8\n         BNZ   RC7\n         B     RC3\nRC6      LTR   R8,R8\n         BNZ   ERCL\nRC7      SR    R10,R10\n         LTR   R9,R9\n         BZ    RC8\n         ST    R10,0(R9)           STORE IND.\nRC8     $XRET  CC=(R10)\n         SPACE 1\nERCL    WTO    'ERR=1 - RCLOSE CALLING SEQUENCE, ARGUMENT ALIGNMENT OR 1\n               DD-NAME ERROR.',ROUTCDE=11,DESC=7\n         LA    R10,1\n         B     RC7+L'RC7\n         SPACE 1\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nCHAIN    DC    A(*-*)\nATIOT    DC    A(*-*)\nTABD     DC    A(DIAG1,DIAG2,DIAG3,DIAG4)\nZEROS    DC    F'0'\nERAB    WTO    'ERR=2 - ABEND CODE SYSTEM=S013-18 (IEC141I).',         1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG1   WTO    'ERR=1 -          DD-CARD MISSING.',                    1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG2   WTO    'ERR=2 -          OPEN ERROR OR DD-CARD CONFLICT.',     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG3   WTO    'ERR=3 - READ CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERR1\n               OR.',ROUTCDE=11,DESC=7,MF=L\nDIAG4   WTO    'ERR=4 -          I/O ERROR.',                          1\n               ROUTCDE=11,DESC=7,MF=L\nCNTR     DC    H'0'\nDDDEF    DC    CL8'SYSIN  '\nKEYALL   DC    CL8'CLOSEALL'\nBLKS     DC    CL8' '\n         SPACE 2\n#RMSW#   DS    0H\nSWMS     DC    H'0'\n         EJECT\n        CNOP   0,8\n         SPACE 1\nBFILE    DC    F'0'                CHAIN WORD.\n         DC    CL8' '              DD-NAME.\n         DC    H'10'               ERROR COUNT.\n         DC    XL1'0'              FLAGS BYTE.\n         DC    XL1'0'              UNUSED.\n         SPACE 1\nDCBRDR  DCB    DSORG=PS,DEVD=DA,MACRF=GM,BFALN=D,                      1\n               EXLST=REXLIST,SYNAD=RDERR,EODAD=RDEND,DDNAME=XXXXXXXX\n         SPACE 1\n        CNOP   0,8\n         SPACE 1\nDZ       EQU   DCBRDR-BFILE\nWSZ      EQU   (((*-BFILE)+7)/8)*8\n         SPACE 1\nREXLIST  DC    0F'0',XL1'05',AL3(DCBEXIT),XL1'91',AL3(DCBABND)\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TXREAD$": {"ttr": 36102, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//READ     JOB (........),'INSTALL  - READ -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,MBR=TXREAD\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   RCLOSE\n  NAME    READ(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TXREAD@": {"ttr": 36104, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14S\\x00Z\\x00Z\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:53:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      READ      1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          TEXT READ ROUTINE          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL READ,(A,B,C),VL\n  ------------------           (A,B)\n                               (A)\n\n         Where : A - is the address of an array (format CL...) which\n                     receives the text image.\n\n                 B - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is\n                     set to zero in the parameters list, the\n                     default DD-name used is SYSIN.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                     -1 - END-OF-FILE.\n                      0 - READ correctly executed.\n                      1 - DD-card missing.\n                      2 - OPEN error or not fixed record format.\n                      3 - calling sequence or argument alignment error.\n                      4 - READ error.\n\n                 --- If the routine is re-called after IND = 1 or 2,\n                     the program is sended in abend U0001. If the\n                     indicator response is detected 10 times different\n                     from 0, the program is sended in abend U0002.\n\n  Assembler macro : $READ A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   28/07/86\n                                                      READ      2/2.\n\n  Calling sequence : CALL RCLOSE,(A,B),VL\n  ------------------             (A)\n\n         Where : A - is the address of the DD-name (format CL8) to\n                     close. If this argument contains the CLOSEALL\n                     keyword, or the address of this argument is\n                     set to zero in the parameters list, or the\n                     parameters list pointer (register 1) is zero,\n                     all the opened files are closed.\n\n                 B - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence, argument alignment or\n                          DD-name error.\n\n  Assembler macro : $RCLOSE A,B\n  -----------------\n\n         Where A and/or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n\n  General notice : on any error detection, a message is included\n  ================ in the message class for the job.\n                   This routine is multi-files usable, that means\n                   multi-files opened concurrently (using the DD-name\n                   argument).\n\n\n  How to suppress the DD-CARD MISSING message.\n  --------------------------------------------\n\n         Before entering the first time the READ routine for a file\n  (DD-name), execute the following two instructions :\n                     ...\n                     L     RX,=V(#RMSW#)\n                     MVI   0(RX),1\n                     ...\n         Then if ERR-1 occurs during the first CALL (OPEN file time),\n  the message is bypassed (the register 15 and the eventual indicator\n  response are set).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TXSNAP": {"ttr": 36107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\x10\\x12\\x01\\x03\\x01\\x03\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T10:12:00", "lines": 259, "newlines": 259, "modlines": 0, "user": "SYSPAJA"}, "text": "SNP      TITLE 'SNAP SUBROUTINE.'\nSNAP     START 0\n         SPACE 2\n* CALLING SEQUENCE : CALL SNAP,(A,B,C,D),VL\n* ------------------           (A,B,C)\n*                              (A,B)\n*\n*        WHERE : A - IS THE ADDRESS OF THE STORAGE AREA TO BE DUMPED.\n*                    THE AREA WILL BE PRINTED HEXADECIMAL AND DECIMAL\n*                    IMAGE.\n*\n*                B - IS THE LENGTH (NUMBER OF CHARACTERS) OF THE\n*                    STORAGE AREA TO BE DUMPED (FORMAT FULLWORD -\n*                    F BOUNDARY).\n*\n*                C - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSPRINT'.\n*\n*                D - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - PRINT CORRECTLY EXECUTED.\n*                     1 - DD-CARD MISSING.\n*                     2 - OPEN ERROR.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - LENGTH IS NEGATIVE, ZERO OR GREATER THAN THE\n*                         LOGICAL RECORD LENGTH (MAXIMUM ALLOWABLE IS\n*                         145). THE LINE IS PRINTED, BUT TRUNCATED.\n*                     5 - PRINT ERROR.\n*\n* GENERAL NOTICE : THIS SUBROUTINE USES THE \"PRINT\" SUBROUTINE, AND\n* ---------------- THUS IT IS NECESSARY TO CALL \"PCLOSE\" IN ORDER TO\n*                  TERMINATE THE SNAP FILE.\n*                  MVS/XA : MUST BE RMODE 24 (AMODE CAN BE ANY).\n*\n* HOW TO SUPPRESS LINES WITH SAME DATA (REDUCE OUTPUT PRINT).\n* -----------------------------------------------------------\n*\n*        EVERY TIMES BEFORE ENTERING THE SNAP ROUTINE FOR AN ARRAY\n* DUMP, EXECUTE THE FOLLOWING TWO INSTRUCTIONS :\n*                    ...\n*                    L     RX,=V(#SNSW#)\n*                    MVI   0(RX),1\n*                    ...\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n         ENTRY #SNSW#\n         SPACE 1\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING\n         EJECT\n        $XENT  BASE=R12\n         SPACE 1\n        $TSWXA ,                   ARE WE 31-BIT AMODE RUNNING?\n         STCM  R14,B'1000',STMODE  SAVE STATUS\n         BM    BEGIN               YES\n        $TSWXA 31,EXPAND=ONLY      NO, ENTER 31-BIT, WAS 24-BIT\n         SPACE 1\nBEGIN    SR    R6,R6\n         SR    R9,R9\n         TM    0(R1),X'80'         CONTROL ARGUMENTS\n         BO    ERARG\n         TM    4(R1),X'80'\n         BO    SHORT\n         L     R9,8(R1)\n         LA    R9,0(R9)\n         TM    8(R1),X'80'\n         BO    SHORT\n         TM    12(R1),X'80'\n         BZ    ERARG\n         TM    15(R1),X'03'\n         BNZ   ERARG\n         L     R6,12(R1)\nSHORT    TM    7(R1),X'03'\n         BZ    INIT\nERARG    LA    R15,3\n         B     RETUR\nINIT     NI    FIRST+1,OFF         SET SWITCH OFF\n         OI    DUPLN+1,ON          SET SWITCH ON\n         NI    LAST+1,OFF          SET SWITCH OFF\n         CLI   SNSW,1              SUPPRESS SAME LINES REQUESTED?\n         BE    *+L'*+8             YES\n         OI    DUPRQ+1,ON          NO, SET SWITCH ON\n         B     *+L'*+4\n         NI    DUPRQ+1,OFF         SET SWITCH OFF\n         MVI   LINE,C'0'           ASA DOUBLE SPACE FIRST LINE\n         MVI   WCTRL,C' '\n         MVC   WCTRL+1(L'WCTRL-1),WCTRL\n         SR    R2,R2\n         L     R3,0(R1)            START ADDRESS\n         D     R2,LNC              REMAIN R2 WITH START OFFSET\n         MH    R3,LNC+2            START\n         SR    R4,R4\n         L     R5,4(R1)            LENGTH\n         L     R5,0(R5)            OBTAIN LENGTH\n         LTR   R5,R5\n         BNP   ERARG\n         AR    R5,R2               + START OFFSET\n         D     R4,LNC              REMAIN R4 WITH END OFFSET\n         LNR   R4,R4\n         BNZ   COMPL\n         BCTR  R5,0\n         B     LOOP\nCOMPL    A     R4,LNC\nLOOP     ST    R3,COUNT            ADDRESS\n         MVC   COUNT+4(32),0(R3)   STORAGE\n         MVC   TEXT(32),COUNT+4\n         UNPK  WHEXR(13),COUNT(7)\n         UNPK  WHEXR+12(13),COUNT+06(7)\n         UNPK  WHEXR+24(13),COUNT+12(7)\n         UNPK  WHEXR+36(13),COUNT+18(7)\n         UNPK  WHEXR+48(13),COUNT+24(7)\n         UNPK  WHEXR+60(13),COUNT+30(7)\n         TR    WHEXR(72),TABLE-240\nFIRST    NOP   NOOFFT\n         OI    FIRST+1,ON          SET SWITCH ON\n         LTR   R2,R2\n         BZ    NOOFFT\n         BCTR  R2,0\n         MVI   TEXT,C' '           CLEAR START OFFSET DEC LINE\n         LTR   R2,R2\n         BZ    NMV1\n         BCTR  R2,0\n         EX    R2,MVTX\n         LA    R2,1(R2)\n         SLL   R2,1                MULTIPLY BY 2\nNMV1     MVI   WHEXR+8,C' '\n         EX    R2,MVHX             CLEAR START OFFSET\n         SR    R2,R2\nNOOFFT   LTR   R5,R5               ONLY ONE LINE TO PRINT?\n         BNZ   DUPRQ\n         OI    LAST+1,ON           SET SWITCH ON\n         LTR   R4,R4               END OFFSET\n         BZ    NOEND\n         LA    R5,TEXT+32\n         SR    R5,R4               START END OFFSET DEC LINE\n         LR    R7,R4\n         SLL   R7,1\n         LA    R8,WHEXR+72\n         SR    R8,R7\n         BCTR  R4,0\n         MVI   0(R5),C' '\n         LTR   R4,R4\n         BZ    NMV2\n         BCTR  R4,0\n         EX    R4,MVCL             CLEAR IN DEC LINE\n         LA    R4,1(R4)\n         SLL   R4,1                MULTIPLY BY 2\nNMV2     LR    R5,R8\n         MVI   0(R5),C' '\n         EX    R4,MVCL             CLEAR IN HEX LINE\nNOEND    SR    R5,R5\nDUPRQ    NOP   PRNT\n         TM    LAST+1,ON\n         BO    DUPLN\n         CLC   WHEXR+8(L'WCTRL),WCTRL\n         BNE   DUPLN\n         NI    DUPLN+1,OFF         SET SWITCH OFF\n         B     LAST+L'LAST\nDUPLN    NOP   MVCTRL\n         OI    DUPLN+1,ON          SET SWITCH ON\n        $TSWXA 24,EXPAND=ONLY      FORCE TO 24-BIT\n        $PRINT LRPT,,(R9)\n        $TSWXA 31,EXPAND=ONLY      RE-ENTER 31-BIT\n         LTR   R15,R15             TEST RETURN INDICATOR\n         BNZ   RETUR\nMVCTRL   MVC   WCTRL(L'WCTRL),WHEXR+8\nPRNT     MVC   BLOCK(8),WHEXR\n         MVC   WD1(8),WHEXR+8\n         MVC   WD2(8),WHEXR+16\n         MVC   WD3(8),WHEXR+24\n         MVC   WD4(8),WHEXR+32\n         MVC   WD5(8),WHEXR+40\n         MVC   WD6(8),WHEXR+48\n         MVC   WD7(8),WHEXR+56\n         MVC   WD8(8),WHEXR+64\n        $TSWXA 24,EXPAND=ONLY      FORCE TO 24-BIT\n        $PRINT LINE,,(R9)\n        $TSWXA 31,EXPAND=ONLY      RE-ENTER 31-BIT\n         LTR   R15,R15             TEST RETURN INDICATOR\n         BNZ   RETUR\nLAST     NOP   RETUR\n         MVI   LINE,C' '           ASA SINGLE SPACE\n         A     R3,LNC              STEP START POINT\n         BCTR  R5,0                DECREMENT LINE COUNT\n         B     LOOP\nMVTX     MVC   TEXT+1(*-*),TEXT\nMVHX     MVC   WHEXR+9(*-*),WHEXR+8\nMVCL     MVC   1(*-*,R5),0(R5)\n         SPACE 1\nRETUR    XC    SNSW,SNSW\n         LTR   R6,R6\n         BZ    *+L'*+4\n         ST    R15,0(R6)           STORE INDICATOR\n         TM    STMODE,A31XA        XA/31-BIT?\n         BO    EXIT                YES\n        $TSWXA 24,EXPAND=ONLY      BACK TO 24-BIT\nEXIT    $XRET  CC=(R15)\n         SPACE 1\n         DROP  R12\n         SPACE 1\n         LTORG\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nLNC      DC    F'32'\n         SPACE 1\nCOUNT    DC    F'0',XL32'00'\n#SNSW#   DS    0H\nSNSW     DC    H'0'\nWHEXR    DC    CL73' '\nWCTRL    DC    CL64' '\nSTMODE   DC    XL1'0'         SYSTEM INDICATOR\nA31XA    EQU   X'80'               AMODE 31 ALREADY IN\nTABLE    DC    C'0123456789ABCDEF'\n         SPACE 1\n         DC    AL1(LLINE)\nLINE     DC    CL2' '\nBLOCK    DS    CL8\n         DC    CL1'-'\nWD1      DS    CL8\n         DC    CL1' '\nWD2      DS    CL8\n         DC    CL1' '\nWD3      DS    CL8\n         DC    CL1' '\nWD4      DS    CL8\n         DC    CL3' '\nWD5      DS    CL8\n         DC    CL1' '\nWD6      DS    CL8\n         DC    CL1' '\nWD7      DS    CL8\n         DC    CL1' '\nWD8      DS    CL8\n         DC    CL2' '\nAST1     DC    CL1'*'\nTEXT     DC    CL32' '\nAST2     DC    CL1'*'\nLLINE    EQU   *-LINE\n         DC    AL1(LLRPT)\nLRPT     DC    CL10' ',C' ---> SAME AS ABOVE UNTIL NEXT ADDRESS'\nLLRPT    EQU   *-LRPT\n         SPACE 2\n        PRINT  NOGEN\n        CVT    DSECT=YES,LIST=YES\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TXSNAP$": {"ttr": 36353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//SNAP     JOB (........),'INSTALL  - SNAP -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=3\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION FOR USE :                      *\n//*                TXPRINT                                            *\n//* NOTE : AT LINK-EDIT YOU WILL RECEIVE A RETURN CODE 4 WHICH IS     *\n//*        ONLY A NORMAL WARNING MESSAGE DUE TO NCAL SPECIFIED.       *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=TXSNAP\n//LNK     EXEC PAJILKR,OPT=',NCAL'\n//SYSIN     DD *\n  NAME    SNAP(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TXSNAP@": {"ttr": 36355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x17\\x7f\\x00\\x90\\x17\\x7f\\x17C\\x00@\\x00@\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-26T00:00:00", "modifydate": "1990-06-26T17:43:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "SYSPAJA"}, "text": "1   05/10/87\n                                                      SNAP      1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          SNAP DUMP ROUTINE          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL SNAP,(A,B,C,D),VL\n  ------------------           (A,B,C)\n                               (A,B)\n\n         Where : A - is the address of the storage area to be dumped.\n                     The area will be printed hexadecimal and EBCDIC\n                     image.\n\n                 B - is the address of the length (no. of characters)\n                     of the storage area to be dumped (format FULLWORD\n                     - F boundary).\n\n                 C - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSPRINT.\n\n                 D - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - PRINT correctly executed.\n                      1 - DD-card missing.\n                      2 - OPEN error.\n                      3 - calling sequence or argument alignment error.\n                      4 - length is negative, zero or greater than the\n                          logical record length (maximum allowable is\n                          145). The line is printed, but truncated.\n                      5 - PRINT error.\n\n  Assembler macro : $SNAP A,B,C,D\n  -----------------\n\n         Where C and/or D are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   05/10/87\n                                                      SNAP      2/2.\n\n  General notice : this subroutine uses the PRINT subroutine, and\n  ================ thus it is necessary to CALL PCLOSE in order to\n                   terminate the snap file.\n                   This routine is multi-files usable, that means\n                   multi-files opened concurrently (using the DD-name\n                   argument).\n\n  How to suppress lines with same data (reduce output print).\n  -----------------------------------------------------------\n\n         Every times before entering the SNAP routine for an array\n  dump, execute the following two instructions :\n                   ...\n                   L     Rx,=V(#SNSW#)\n                   MVI   0(Rx),1\n                   ...\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UADS": {"ttr": 36357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\tY\\x03\\x0e\\x03\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T09:59:00", "lines": 782, "newlines": 782, "modlines": 0, "user": "SYSPAJA"}, "text": "UADS     TITLE 'U A D S   - LIST SYS1.UADS TSO COMMAND.'\n***********************************************************************\n*        U A D S - TSO COMMAND                                        *\n***********************************************************************\n         SPACE 1\n* WRITTEN BY : BILL GODFREY, PLANNING RESEARCH CORPORATION.\n* INSTALLATION : AIR FORCE DATA SERVICES CENTER / PENTAGON.\n* DATE WRITTEN : MAY 6 1981.\n* ATTRIBUTES : RE-ENTRANT.\n* DESCRIPTION : THIS COMMAND LISTS UADS MEMBERS ON THE TERMINAL.\n*         IT DIFFERS FROM THE 'ACCOUNT' COMMAND IN THAT IT\n*         DOES NOT LIST THE PASSWORD, DOES NOT ALLOW CHANGES,\n*         AND CANNOT LIST THE DIRECTORY OF ALL MEMBER NAMES.\n*         IT IS INTENDED FOR USE BY THOSE PERSONS IN SYSTEMS\n*         SUPPORT WHO NEED TO LOOK AT UADS BUT ARE NOT\n*         RESPONSIBLE FOR UPDATING IT.\n* SYNTAX : UADS USERIDX   OR   UADS (USERIDX USERIDY ...)\n*         ASTERISK MAY BE SPECIFIED IN PLACE OF YOUR OWN USERID.\n* THE INFORMATION IS DISPLAYED IN THE FOLLOWING FORMAT :\n* USERID - XXXXXXX  USER ATTR.: OPER ACCT JCL NOMOUNT RECOVER\n*                   INST. ATTR., IN HEX: 0000 -- MAXSIZE:  1000K\n*                   UPT: 00000000000000000000000000000000 PREFIX\n*                   DESTINATION: (DEFAULT)\n*                   HOLD MSGCLASS: (DEFAULT) -- JOB CLASS: (DEFAULT)\n*                   MESSAGE CLASS: (DEFAULT) -- SYSOUT CLASS: (DEFAULT)\n*          PASSWORD XXXXXXXX\n*             ACCOUNT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*                PROC XXXXXXXX  SIZE=NNNNNK  UNIT NAME: SYSDA\n* ----------------------------------------------------------------\n* CBT ORIGIN : EXTRACTED FROM CBT TAPE 86 FEB, FILE 300.\n* ----------------------------------------------------------------\n* UPDATED BY MOINIL P.A. - COMPUTING CENTRE\n*                          J.R.C. - ISPRA ESTABLISHMENT\n*                          21020 ISPRA (VA), ITALY\n*        - LOCAL CHECK OF USER AUTHORITY.\n*        - MAXIMUM NUMBER OF MEMBERS FOR A USERID DYNAMICALLY\n*          COMPUTED FROM ASSEMBLY VARIABLE (SEE 'MXMU',EASY ZAP).\n*        - SNAP OPTION ADDED TO GET UADS BLOCKS TRACE.\n*        - LOGON OPTION ADDED TO GET LOGON DEFAULTS.\n         SPACE 1\n        PRINT  OFF\n         MACRO\n&LAB    @SNAP  &ID,&HEADER,&SKIP\n&LAB     TM    SWSNAP,SNREQ\n         BZ    &SKIP\n         AIF   ('&ID' EQ '').A\n         LA    R0,&ID\n         AGO   .B\n.A       XR    R0,R0\n.B       AIF   ('&HEADER' EQ '').C\n         L     R1,=A(&HEADER)\n         AGO   .D\n.C       XR    R1,R1\n.D       L     R15,=A(SNAP)\n         BASR  R14,R15\n         LTR   R15,R15\n         MEND\n        PRINT  ON\n         EJECT\nUADS     START 0\n         SPACE 1\nUADS    AMODE  24\nUADS    RMODE  24\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\nMXMU     EQU   3    <--- MAXIMUM NUMBER OF MEMBERS FOR A USERID  *\n*                        (ACCEPTABLE RANGE IS : 1 UP TO 9).      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n        $DEFREG\n*------- AUTHORITY LEVEL DEFINITIONS.\n         SPACE 1\nLV10     EQU   10 - 15             SYSTEM + OPERATOR\nLV0      EQU   0 - 9               NONE\n         SPACE 1\nDIDOCS  $MDL@IX\n         EJECT\n        $XENT  BASE=(R11,R12),LV=@DATAL,TYPE=RENT\n         LR    R2,R1               SAVE ENTRY REGISTER\n         LR    R9,R13              INITIALIZE WORKAREA POINTER\n         USING @DATA,R9\n         LA    R0,@DATA+(18*4)     AREA TO BE CLEARED\n         L     R1,@SIZE            LENGTH TO BE CLEARED\n         XR    R15,R15             ZERO PAD AND 'FROM' LENGTH\n         MVCL  R0,R14              ZERO IT ALL\n        $TEW$EC REG=R2,TIOT=YES,MSG=PUTMSG,ERR=QUIT,PUT=PUTLNE\n         MVI   LINE-1,C' '\n         MVI   AUTH,LV0            CHECK AUTHORITY OF USER ISSUING\n         XC    REQAUT(REQAUTL),REQAUT   THE COMMAND\n         MVC   REQAUT+1(3),=AL3(MDL@IX)\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n        $EACM  REQAUT\n         CLI   AUTH,LV10\n         BL    NOTAUT\n        $TEW$PP PARM=UADSPCL,REG=R2\n         MVC   DDNAME,=CL8'SYSUADS'\n        DEVTYPE DDNAME,DEVAREA\n         LTR   R15,R15\n         BNZ   DDERR\n         LA    R4,SYSUADS\n         MVC   0(SYSUADSL,R4),SYSUADS1\n         USING IHADCB,R4\n         MVC   DCBDDNAM,DDNAME\n         MVI   OPEN,X'80'\n        OPEN   ((R4),INPUT),MF=(E,OPEN)\n         TM    DCBOFLGS,DCBOFOPN   SUCCESSFULLY OPENED?\n         BZ    OPERR               NO - ERROR\n         OI    STATUS,STATOPEN\n         LH    R0,DCBBLKSI         GET UADS BLOCKSIZE\n         DROP  R4\n         ST    R0,INUSIZ           PHYSICAL BLOCK LENGTH\n         MH    R0,MXMEMB           N TIMES\n         LH    R3,MXMEMB           COMPUTE BLDL SPACE\n         MH    R3,MXMEMB+2\n         AH    R3,=H'4'\n         AR    R0,R3               ADD BLDL SPACE\n         AH    R0,=H'7'            ROUND UP TO DOUBLE WORD\n         SRL   R0,3\n         SLL   R0,3\n         ST    R0,INULEN           SAVE IT\n        GETMAIN R,LV=(0)\n         ST    R1,INUPTR\n         AR    R1,R3               ADD BLDL SPACE\n         ST    R1,INUBUF\n         OI    STATUS,STATGM\n         MVC   UADDECBW(UADDECBL),UADDECB\n         MVC   PASSKWT(1),PASSKW+1\n         MVC   LOGKWT(1),LOGKW+1\n         CLI   PASSKWT,4           IS TRACE REQUESTED?\n         BNE   *+L'*+4             NO\n         OI    SWSNAP,SNREQ        YES\n         LA    R4,USERID\n         DROP  R2\n         B     *+L'*+4\nNEXTUSER L     R4,8(,R4)\n         ST    R4,USERPTR\n         MVC   MEMBER,=CL8' '\n         L     R14,0(,R4)\n         LH    R1,4(,R4)\n         BCTR  R1,0\n         B     *+L'*+6\n         MVC   MEMBER(0),0(R14)\n         EX    R1,*-6\n         CLC   MEMBER,=CL8'* '\n         BNE   NOTSELF\n         L     R2,#TSCPPL\n         USING CPPL,R2\n         L     R14,CPPLPSCB\n         DROP  R2\n         IC    R1,7(,R14)          PSCBUSRL\n         LTR   R1,R1\n         BZ    NOTFND\n         BCTR  R1,0\n         B     *+L'*+6\n         MVC   MEMBER(0),0(R14)    PSCBUSER\n         EX    R1,*-6\nNOTSELF  L     R2,INUPTR\n         MVC   0(4,R2),MXMEMB      SET START OF BLDL LIST\n         LA    R15,4(R2)\n         LA    R14,1(R1,R15)\n         LH    R3,MXMEMB\n         XR    R1,R1\nBUILDL   MVC   0(8,R15),MEMBER     BUILD BLDL ENTRIES\n         XC    8(4,R15),8(R15)\n         MVI   0(R14),C'0'         APPEND '0' TO USERID\n         EX    R1,APPEND           SET 'N' TO USERID\n         BCT   R3,*+L'*+4\n         B     XBLDL\n         LA    R1,1(R1)\n         LA    R14,12(R14)\n         LA    R15,12(R15)\n         B     BUILDL\nAPPEND   OI    0(R14),*-*          <<EXECUTED>>\nXBLDL   BLDL   SYSUADS,(R2)\n         LTR   R15,R15             IS USERID IN UADS\n         BZ    FOUND               YES, BRANCH\n         CH    R15,=H'4'           WAS ERROR DUE TO MEMBER NOT FOUND\n         BNE   BLDLERR             NO, I/O ERROR OR DCB ERROR\nFOUND    XC    PASSNUM,PASSNUM\n         L     R4,INUBUF\n         LR    R3,R4               START OF READ\n         LA    R2,4(R2)            SET TO MEMBER0\n         BAS   R10,READMB          READ MEMBER0\n         B     NOTFND              +0 - NOT FOUND\n         LH    R5,MXMEMB           +4 - OK\nREADNX   BCT   R5,*+L'*+4\n         B     TSNAP               END OF READ\n         AL    R3,INUSIZ           NEXT TO READ\n         LA    R2,12(R2)           SET TO NEXT MEMBER\n         BAS   R10,READMB          READ MEMBER\n         B     TSNAP               +0 - NO MORE\n         B     READNX              +0 - OK\nUADERR   OI    STATUS,STATERR      SET READ ERROR\n         BR    R14\nTSNAP   @SNAP  1,HDR,PROCESS       DUMP BLOCK READ\n         BZ    PROCESS\n         MVC   LINE,LINE-1         BLANK THE LINE\n         MVC   LINE+1(33),=CL33'---> SNAP RC =     (R15=        )'\n         CVD   R15,DOUBLE\n         MVC   LINE+16(3),=XL3'202120'\n         ED    LINE+15(4),DOUBLE+6\n         ST    R15,DOUBLE\n         UNPK  LINE+25(9),DOUBLE(5)\n         NC    LINE+25(8),=XL8'0F0F0F0F0F0F0F0F'\n         TR    LINE+25(8),=CL16'0123456789ABCDEF'\n         MVI   LINE+33,C')'\n         LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         SPACE 1\n*------- H E A D E R   B L O C K -- (R4)\n         SPACE 1\n         USING DHED,R4\nPROCESS  MVC   LINE,LINE-1         BLANK THE LINE\n         MVC   LINE+1(8),=CL8'USERID -'\n         MVC   LINE+10(8),UADSUSER\n         LA    R1,LINE+10+7\nZEROLOOP CLI   0(R1),C'0'\n         BE    *+L'*+4\n         BCT   R1,ZEROLOOP\n         MVI   0(R1),C' '\n         MVC   LINE+19(11),=CL11'USER ATTR.:'\n         LA    R1,LINE+31\n         TM    UADSATTR,USATR00\n         BNO   NOOPER\nOPER     MVC   0(4,R1),=CL4'OPER'\n         LA    R1,5(,R1)\n         B     OPERX\nNOOPER   MVC   0(6,R1),=CL6'NOOPER'\n         LA    R1,7(,R1)\nOPERX    TM    UADSATTR,USATR01\n         BNO   NOACCT\nACCT     MVC   0(4,R1),=CL4'ACCT'\n         LA    R1,5(,R1)\n         B     ACCTX\nNOACCT   MVC   0(6,R1),=CL6'NOACCT'\n         LA    R1,7(,R1)\nACCTX    TM    UADSATTR,USATR02\n         BNO   NOJCL\nJCL      MVC   0(3,R1),=CL3'JCL'\n         LA    R1,4(,R1)\n         B     JCLX\nNOJCL    MVC   0(5,R1),=CL5'NOJCL'\n         LA    R1,6(,R1)\nJCLX     TM    UADSATTR,USATR03\n         BNO   NOMOUNT\nMOUNT    MVC   0(5,R1),=CL5'MOUNT'\n         LA    R1,6(,R1)\n         B     MOUNTX\nNOMOUNT  MVC   0(7,R1),=CL7'NOMOUNT'\n         LA    R1,8(,R1)\nMOUNTX   TM    UADSATTR,USATR04\n         BNO   RECOV\nNORECOV  MVC   0(9,R1),=CL9'NORECOVER'\n         B     RECOVX\nRECOV    MVC   0(7,R1),=CL7'RECOVER'\nRECOVX   LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         MVC   LINE,LINE-1\n         MVC   LINE+19(20),=CL20'INST. ATTR., IN HEX:'\n         LA    R15,LINE+40\n         UNPK  0(5,R15),UADSINST(3)\n         TR    0(4,R15),HEXTAB-240\n         MVI   4(R15),C' '\n         MVC   LINE+45(11),=CL11'-- MAXSIZE:'\n         LA    R15,LINE+56\n         LH    R0,UADSMAXC\n         CVD   R0,DOUBLE\n         MVC   0(6,R15),=XL6'402020202120'\n         ED    0(6,R15),DOUBLE+5\n         MVI   6(R15),C'K'\n         LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         MVC   LINE,LINE-1\n         MVC   LINE+19(4),=CL4'UPT:'\n         L     R1,UADSUPTP         GET OFFSET TO UPT\n         LA    R1,UADSMHDR(R1)     POINT TO UPT\n         USING UPT,R1\n         UNPK  LINE+24+00(9),UPT(5)\n         UNPK  LINE+24+08(9),UPT+4(5)\n         UNPK  LINE+24+16(9),UPT+8(5)\n         UNPK  LINE+24+24(9),UPTSWS(5)\n         MVI   LINE+24+32,C' '\n         TR    LINE+24(32),HEXTAB-240\n         XR    R14,R14\n         IC    R14,UPTPREFL\n         LTR   R14,R14             IS PREFIX LENGTH ZERO\n         BZ    NOPREF              YES, BRANCH\n         BCT   R14,*+L'*+6\n         MVC   LINE+24+33(*-*),UPTPREFX      MOVE PREFIX\n         EX    R14,*-6\n         DROP  R1\nNOPREF   LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         MVC   LINE,LINE-1\n         MVC   LINE+19(12),=CL12'DESTINATION:'\n         MVC   LINE+32(L'UADSDEST),UADSDEST\n         CLC   LINE+32(L'UADSDEST),=XL8'0'\n         BE    *+L'*+10\n         CLC   LINE+32(L'UADSDEST),=CL8' '\n         BNE   *+L'*+6\n         MVC   LINE+32(9),=CL9'(DEFAULT)'\n         LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         MVC   LINE,LINE-1\n         MVC   LINE+19(14),=CL14'HOLD MSGCLASS:'\n         MVC   LINE+34(L'UADSSUBH),UADSSUBH\n         CLC   LINE+34(L'UADSSUBH),=XL8'0'\n         BE    *+L'*+10\n         CLC   LINE+34(L'UADSSUBH),=CL8' '\n         BNE   *+L'*+6\n         MVC   LINE+34(9),=CL9'(DEFAULT)'\n         MVC   LINE+44(13),=CL13'-- JOB CLASS:'\n         MVC   LINE+58(L'UADSSUBC),UADSSUBC\n         CLC   LINE+58(L'UADSSUBC),=XL8'0'\n         BE    *+L'*+10\n         CLC   LINE+58(L'UADSSUBC),=CL8' '\n         BNE   *+L'*+6\n         MVC   LINE+58(9),=CL9'(DEFAULT)'\n         LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         MVC   LINE,LINE-1\n         MVC   LINE+19(14),=CL14'MESSAGE CLASS:'\n         MVC   LINE+34(L'UADSSUBM),UADSSUBM\n         CLC   LINE+34(L'UADSSUBM),=XL8'0'\n         BE    *+L'*+10\n         CLC   LINE+34(L'UADSSUBM),=CL8' '\n         BNE   *+L'*+6\n         MVC   LINE+34(9),=CL9'(DEFAULT)'\n         MVC   LINE+44(16),=CL16'-- SYSOUT CLASS:'\n         MVC   LINE+61(L'UADSSOUT),UADSSOUT\n         CLC   LINE+61(L'UADSSOUT),=XL8'0'\n         BE    *+L'*+10\n         CLC   LINE+61(L'UADSSOUT),=CL8' '\n         BNE   *+L'*+6\n         MVC   LINE+61(9),=CL9'(DEFAULT)'\n         LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         SPACE 1\n*------- P A S S W O R D   L E V E L -- (R5)\n         SPACE 1\n         L     R5,UADSPWD1\n         LA    R5,UADSMHDR(R5)\n         USING DPOB,R5\nNEWPASS  MVC   LINE,LINE-1         BLANK THE LINE\n         MVC   LINE+10(8),=CL8'PASSWORD'\n         ICM   R6,B'1111',UADSPDAT PASSWORD PRESENT?\n         BNZ   PASSGO              YES - BRANCH\n         MVC   LINE+19(3),=CL3'(*)'\n         B     PASSPR\nPASSGO   LA    R6,UADSMHDR(R6)\n         USING DPOBD,R6\n         MVC   PASSDUM,=CL8'*****'\n         CLI   PASSKWT,3           PASSWORD REQUESTED\n         BNL   PASSSHOW            YES, SHOW IT (RACF GROUP)\n         CLI   PASSKWT,2           PASSNUM (SHOW RELATIVE PASSWORD)\n         BNE   PASSXXX             NO, GO SHOW ASTERISKS\n         LH    R1,PASSNUM\n         LA    R1,1(,R1)           COUNT PASSWORDS FOR THIS USERID\n         STH   R1,PASSNUM\n         CVD   R1,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         MVC   PASSDUM,=CL8' '\n         UNPK  PASSDUM+0(5),DOUBLE+5(3)\nPASSXXX  MVC   UADSPPWD,PASSDUM\nPASSSHOW MVC   LINE+19(8),UADSPPWD\nPASSPR   LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         DROP  R6\n         SPACE 1\n*------- A C C O U N T   L E V E L -- (R6)\n         SPACE 1\n         L     R6,UADSPSUB\n         LA    R6,UADSMHDR(R6)\n         USING DNOB,R6\nNEWACCT  MVC   LINE,LINE-1         BLANK THE LINE\n         MVC   LINE+13(7),=CL7'ACCOUNT'\n         ICM   R7,B'1111',UADSADAT ACCOUNT PRESENT?\n         BNZ   ACCTGO              YES - BRANCH\nACCTSTAR MVC   LINE+21(3),=CL3'(*)'\n         B     ACCTPR\nACCTGO   LA    R7,UADSMHDR(R7)\n         USING DNOBD,R7\n         XR    R2,R2\n         IC    R2,UADSALEN\n         LTR   R2,R2               LENGTH ZERO?\n         BZ    ACCTSTAR            YES - BRANCH\n         LA    R1,L'UADSANUM\n         CLR   R2,R1\n         BNH   *+L'*+2\n         LR    R2,R1\n         LA    R1,LINE+21\n         BCT   R2,*+L'*+6\n         MVC   0(0,R1),UADSANUM\n         EX    R2,*-6              PRINT UP TO 40 DIGITS OF ACCOUNT\nACCTPR   LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         DROP  R7\n         SPACE 1\n*------- P R O C N A M E   L E V E L -- (R7)\n         SPACE 1\n         L     R7,UADSASUB\n         LA    R7,UADSMHDR(R7)\n         USING DROB,R7\nNEWPROC  MVC   LINE,LINE-1         BLANK THE LINE\n         MVC   LINE+16(4),=CL4'PROC'\n         L     R8,UADSRDAT\n         LA    R8,UADSMHDR(R8)\n         USING DROBD,R8\n         MVC   LINE+21(8),UADSRNAM\n         MVC   LINE+31(11),=CL11'SIZE=NNNNNK'\n         LH    R0,UADSRSIZ\n         CVD   R0,DOUBLE\n         MVC   LINE+35(6),=XL6'402020202120'\n         ED    LINE+35(6),DOUBLE+5\n         MVI   LINE+35,C'='\n         MVC   LINE+44(10),=CL10'UNIT NAME:'\n         MVC   LINE+55(8),UADSUNAM\n         CLC   LINE+55(8),=CL8' '\n         BNE   *+L'*+6\n         MVC   LINE+55(6),=CL6'(NONE)'\n         LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         DROP  R8\n         SPACE 1\n*------- S T A R T   B A C K I N G   U P --\n         SPACE 1\n         TM    UADSRFLG,FLGR01     ANY MORE PROCNAMES?\n         BO    UPTOACCT            NO - GO UP 1 LEVEL\n         XR    R1,R1\n         ICM   R1,B'0111',UADSRNEX\n         LA    R7,UADSMHDR(R1)\n         BNZ   NEWPROC\n         DROP  R7\nUPTOACCT TM    UADSAFLG,AFLG01     ANY MORE ACCOUNT NUMBERS?\n         BO    UPTOPASS            NO - GO UP 1 LEVEL\n         XR    R1,R1\n         ICM   R1,B'0111',UADSANEX\n         LA    R6,UADSMHDR(R1)\n         BNZ   NEWACCT\n         DROP  R6\nUPTOPASS TM    UADSPFLG,PFLG01     ANY MORE PASSWORDS?\n         BO    ENDPSWS             NO - FINISHED PASSWORDS\n         XR    R1,R1\n         ICM   R1,B'0111',UADSPNEX\n         LA    R5,UADSMHDR(R1)\n         BNZ   NEWPASS\n         SPACE 1\n*------- L O G O N   D E F A U L T S -- (R5)\n         SPACE 1\nENDPSWS  TM    UADSBN01+1,UADSDFMT DFLT FORMAT UADS?\n         BZ    ENDUSER             NO, FINISHED THIS USERID\n         CLI   LOGKWT,1            LOGN DEFAULTS REQUESTED\n         BNE   ENDUSER             NO, FINISHED THIS USERID\n         L     R5,UADSDFTP\n         LTR   R15,R5              NON ZERO OFFSET?\n         BZ    ENDUSER             NO, FINISHED THIS USERID\n         LA    R5,UADSMHDR(R5)\n         USING DFOB,R5\nLGNPCN   TM    UADSDFOB,DFBLOGN    IS IT A LOGON DEFAULT BLOCK?\n         BZ    LGNPCT              NO, LOOK TO NEXT IF ANY\n         L     R6,UADSDDAT\n         LA    R6,UADSMHDR(R6)\n         USING DDOBD,R6\n         MVC   LINE,LINE-1         BLANK THE LINE\n         MVC   LINE+10(15),=CL15'LOGON DEFAULTS:'\n         LA    R1,LINE+10+16\n         TM    UADSOPT1,UADSMAIL\n         BO    *+L'*+14\n         MVC   0(4,R1),=CL4'MAIL'\n         LA    R1,5(R1)\n         B     *+L'*+10\n         MVC   0(6,R1),=CL6'NOMAIL'\n         LA    R1,7(R1)\n         TM    UADSOPT1,UADSNOTC\n         BO    *+L'*+14\n         MVC   0(6,R1),=CL6'NOTICE'\n         LA    R1,7(R1)\n         B     *+L'*+10\n         MVC   0(8,R1),=CL8'NONOTICE'\n         LA    R1,9(R1)\n         TM    UADSOPT1,UADSOID\n         BO    *+L'*+10\n         MVC   0(7,R1),=CL7'OIDCARD'\n         B     *+L'*+6\n         MVC   0(9,R1),=CL9'NOOIDCARD'\n         LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         MVC   LINE,LINE-1         BLANK THE LINE\n         MVC   LINE+17(8),=CL8'COMMAND:'\n         CLC   LINE+17+9(L'UADSCMD/2),UADSCMD\n         BNE   *+L'*+10\n         MVC   LINE+17+9(6),=CL6'(NONE)'\n         B     LGNPCM\n         MVC   LINE+17+9(L'UADSCMD/2),UADSCMD\n         LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         MVC   LINE,LINE-1         BLANK THE LINE\n         CLC   LINE+17+9(L'UADSCMD/2),UADSCMD+(L'UADSCMD/2)\n         BE    LGNPCT\n         MVC   LINE+17+9(L'UADSCMD/2),UADSCMD+(L'UADSCMD/2)\nLGNPCM   LA    R0,L'LINE-1\n         LA    R1,LINE+1\n         BAS   R10,STLNE\n         DROP  R6\nLGNPCT   TM    UADSDFOB,DFFLG01    LAST DEFAULT BLOCK?\n         BO    ENDUSER             YES - FINISHED THIS USERID\n         XR    R1,R1\n         ICM   R1,B'0111',UADSDNXT\n         LA    R5,UADSMHDR(R1)\n         BNZ   LGNPCN\n         DROP  R4,R5\nENDUSER  L     R4,USERPTR\n         CLI   8(R4),X'FF'         WAS THAT THE LAST USERID\n         BNE   NEXTUSER            NO, BRANCH\n         B     EXIT\n         SPACE 1\n*------- TERMINATION.\n         SPACE 1\nNOTFND   LA    R0,L'MSG2\n         LA    R1,MSG2\n         B     SNDMSG\nBLDLERR  LA    R0,L'MSG3\n         LA    R1,MSG3\n         B     SNDMSG\nUADEOD   LA    R0,L'MSG4\n         LA    R1,MSG4\nSNDMSG   BAS   R14,PUTLNE\nSETRC    MVI   RC+1,12             RC=12 ------------------------------\n         B     ENDUSER\nDDERR    LA    R0,L'MSG5\n         LA    R1,MSG5\n         B     EXRET\nOPERR    LA    R0,L'MSG6\n         LA    R1,MSG6\nEXRET    BAS   R14,PUTLNE\n         MVI   RC+1,12             RC=12 ------------------------------\nEXIT     TM    SWSNAP,SNOPEN\n         BZ    NOSNCL\n        CLOSE  (SNAPDCB),MF=(E,SNAPCL)\nNOSNCL   TM    STATUS,STATGM\n         BZ    EXITNOFM\n         L     R1,INUPTR\n         L     R0,INULEN\n        FREEMAIN R,A=(1),LV=(0)\nEXITNOFM TM    STATUS,STATOPEN\n         BZ    EXITNOCL\n         MVI   CLOSE,X'80'\n        CLOSE  ((R4)),MF=(E,CLOSE)\nEXITNOCL IKJRLSA #TSANSW\n         LH    R15,RC\n         B     LEAVE\nNOTAUT   LA    R0,L'MSG1\n         LA    R1,MSG1\n         BAS   R14,PUTLNE\nQUIT     LA    R15,12              RC=12 ------------------------------\nLEAVE   $XRET  CC=(R15),LV=@DATAL,TYPE=RENT\n         SPACE 1\n*------- READ MEMBER ROUTINE\n*              R2      = LINE ADDRESS\n*              R10     = LINK REGISTER\n         SPACE 1\nREADMB   CLI   10(R2),0            WAS MEMBER FOUND\n         BER   R10                 NO, RETURN +0\n        FIND   SYSUADS,8(R2),C\n         XC    UADDECBW(4),UADDECBW CLEAR ECB\n         NI    STATUS,255-STATERR  RESET READ ERROR\n        READ   UADDECBW,SF,SYSUADS,(R3),'S',MF=E\n        CHECK  UADDECBW\n         TM    STATUS,STATERR      READ ERROR OCCURED?\n         BZ    4(R10)              NO, RETURN +4\n         LA    R0,L'MSG7           YES\n         LA    R1,MSG7\n         B     SNDMSG\n         SPACE 1\n*------- LINE ROUTINE\n*              R0      = LINE LENGTH\n*              R1      = LINE ADDRESS\n*              R10     = LINK REGISTER\n         SPACE 1\nSTLNE    BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     0(R10)              +0 - OK\n         B     SETRC               +4 - ERROR\n         EJECT\n*------- C O N S T A N T S --\n         SPACE 1\n@SIZE    DC    A(@DATAL-(18*4))\nMXMEMB   DC    0H'0',AL2(MXMU,12)  N ENTRIES, EACH 12 BYTES\n         SPACE 1\n         PRINT NOGEN\nSYSUADS1 DCB   DDNAME=SYSUADS,DSORG=PO,MACRF=R,                        1\n               EODAD=UADEOD,SYNAD=UADERR\nSYSUADSL EQU   *-SYSUADS1\n         PRINT GEN\n        READ   UADDECB,SF,0,0,'S',MF=L\nUADDECBL EQU   *-UADDECB\n         SPACE 1\nHEXTAB   DC    C'0123456789ABCDEF'\nMSG1     DC    C'UNAUTHORIZED COMMAND'\nMSG2     DC    C'NOT FOUND'\nMSG3     DC    C'BLDL ERROR'\nMSG4     DC    C'UNEXPECTED EOF'\nMSG5     DC    C'SYSUADS DD NOT FOUND'\nMSG6     DC    C'SYSUADS OPEN ERROR'\nMSG7     DC    C'SYSUADS READ ERROR'\n         SPACE 1\n        LTORG  ,                   LITERAL POOL\n         SPACE 1\n         DROP  R11,R12\n         EJECT\n*------- TRACE ROUTINE (DEBUG AID FACILITY)\n*              R0      = SNAP ID NUMBER (0-255)\n*              R1      = SNAP HEADER ADDRESS\n*              R9      = WORK AREAS POINTER\n*              R11     = LOCAL BASE REGISTER\n*              R13     = NEW SAVE AREA\n*              R14     = LINK REGISTER\n*              R15     = ENTRY ADDRESS\n*        NOTE - THE FOLLOWING ALLOCATION IS NEEDED TO OBTAIN THE SNAP\n*               DUMPS : ALLOC F(SYSSNAP) SYSOUT(A)\n         SPACE 1\n        CNOP   0,8\n         USING *,R11\nSNAP     STM   R14,R12,12(R13)     ENTRY\n         LR    R11,R15\n         LR    R2,R13\n         LA    R13,SVSNAP\n         ST    R2,4(R13)\n         ST    R13,8(R2)\n         LR    R2,R0\n         ST    R1,SNAPHD\n         OI    SNAPHD,X'80'\n         LA    R3,SNAPDCB\n         USING IHADCB,R3\n         TM    SWSNAP,SNOPEN       SNAP ALREADY OPENED?\n         BO    SNS                 YES\n         MVC   SNAPDCB(SNAPLL),SNAPCS\n         XR    R1,R1\n         L     R2,#TSTIOT\n         USING TIODSECT,R2\nSNL      CLC   TIOELNGH(4),=F'0'\n         BE    SNM\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM\n         BE    SNF\n         IC    R1,TIOELNGH\n         ALR   R2,R1\n         B     SNL\n         DROP  R2\nSNM      LA    R15,36              SET DD MISSING\n         B     SNC\nSNF     OPEN   ((R3),OUTPUT),MF=(E,SNAPOP)\n         TM    DCBOFLGS,DCBOFOPN   OPENED?\n         BO    SNO                 YES\n         LA    R15,32              SET OPEN ERROR\n         B     SNC\nSNO      OI    SWSNAP,SNOPEN\n         L     R15,INUPTR          START OF SNAP\n         ST    R15,SNAPLST\n         AL    R15,INULEN          LENGTH\n         ST    R15,SNAPLST+4       END OF SNAP\n         OI    SNAPLST+4,X'80'\nSNS     SNAP   DCB=(R3),TCB='S',ID=(R2),LIST=SNAPLST,                  1\n               STRHDR=SNAPHD,MF=(E,SNAPLIST)\n         LTR   R15,R15             ALL OK?\n         BZ    SNR                 YES\nSNC      NI    SWSNAP,255-SNREQ    KILL THE REQUEST\nSNR      L     R13,4(R13)          EXIT\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         MVI   12(R13),X'FF'\n         BR    R14\n         SPACE 1\n         DROP  R3,R11\n         SPACE 1\n        LTORG  ,                   LITERAL POOL\n         EJECT\n*------- SKELETONS AND CONSTANTS.\n         SPACE 1\n         PRINT NOGEN\nSNAPCS  DCB    DSORG=PS,RECFM=VBA,MACRF=(W),                           1\n               BLKSIZE=1632,LRECL=125,                                 2\n               DDNAME=SYSSNAP\n        OPEN   (*-*),MF=L\n        CLOSE  (*-*),MF=L\n        SNAP   MF=L\n         PRINT GEN\nSNAPLL   EQU   *-SNAPCS\n         PRINT GEN\n         SPACE 1\nHDR      DC    AL1(L'HDRT)\nHDRT     DC    C'U A D S -- DUMP OF A USERID BLOCK.'\n         SPACE 1\n*------- P A R S E   P C L --\n         SPACE 1\n         PRINT NOGEN\nUADSPCL  IKJPARM\nUSERID   IKJIDENT 'USERID',LIST,ASTERISK,                              +\n               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=7,                   +\n               DEFAULT='*'\nPASSKW   IKJKEYWD\n         IKJNAME 'SUPPRESS'\n         IKJNAME 'NUMBER'\n         IKJNAME 'PASSWORD'\n         IKJNAME 'TEST'\nLOGKW    IKJKEYWD\n         IKJNAME 'LOGON'\n         IKJENDP\n         PRINT GEN\n         EJECT\n*------- D S E C T S --\n         SPACE 1\n@DATA    DSECT\n         DS    18F\nSAVEREGS DS    18F                 FOR PUTLINE\nSVSNAP   DS    18F                 SNAP SAVE AREA\nDOUBLE   DS    D\n        $TEW$WA\nDDNAME   DS    CL8\nDEVAREA  DS    2F\nINUPTR   DS    F\nINUBUF   DS    F\nINUSIZ   DS    F\nINULEN   DS    F\nUSERPTR  DS    F\nRC       DS    H\nPASSNUM  DS    H\nPASSDUM  DS    CL8\nMEMBER   DS    CL8\nOPEN     DS    0F\nCLOSE    DS    F\nSYSUADS  DS    0F,(SYSUADSL)X\nUADDECBW DS    0F,(UADDECBL)X\nSTATUS   DS    XL1\nSTATOPEN EQU   X'40'\nSTATGM   EQU   X'20'\nSTATERR  EQU   X'01'\nPASSKWT  DS    XL1                 PASSWORD OPTION\nLOGKWT   DS    XL1                 LOGON OPTION\nLINEM1   DS    C                   LINE MINUS 1\nLINE     DS    CL121\nSWSNAP   DC    XL1'0'\nSNOPEN   EQU   X'80'\nSNREQ    EQU   X'08'\nAUTH     DC    AL1(0)\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)\nREQAUTL  EQU   *-REQAUT\n         SPACE 1\n         PRINT NOGEN\nSNAPDCB DCB    DSORG=PS,RECFM=VBA,MACRF=(W),                           1\n               BLKSIZE=1632,LRECL=125,                                 2\n               DDNAME=SYSSNAP\nSNAPOP  OPEN   (*-*),MF=L\nSNAPCL  CLOSE  (*-*),MF=L\nSNAPLIST SNAP  MF=L\n         PRINT GEN\nSNAPLST  DS    2F\nSNAPHD   DS    F\n         SPACE 1\n@DATAL   EQU   (((*-@DATA)+7)/8)*8\n         SPACE 1\n         PRINT NOGEN\n        $TEW$DS\n        IKJUPT\n        DCBD   DEVD=DA,DSORG=PO\n         PRINT GEN\n         SPACE 1\n        IKJEFUAD DSPL,ALL\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UADS$": {"ttr": 36615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "//UADS     JOB (........),'INSTALL  - UADS -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',ALIGN,RENT',MBR=UADS\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  NAME    UADS(R)\n/*\n//HLP     EXEC PAJHELP,MBR=UADSH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UADS@": {"ttr": 36617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12o\\x00\\x88\\x12o\\x12W\\x00/\\x00/\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-05T00:00:00", "modifydate": "1988-05-05T12:57:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SYSPAJA"}, "text": "1   12/06/86\n                                                      UADS      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     LIST SYS1.UADS TSO COMMAND.     * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :   The UADS command displays information from SYS1.UADS\n  ---------   about one or more USERIDs.\n              Unlike the ACCOUNT command, this command\n                   a) optionally list the password,\n                   b) does not allow changes to be made, and\n                   c) cannot list the directory of all member names.\n\n              DDname SYSUADS must be pre-allocated to SYS1.UADS\n              before using this command (normally in LOGON procedure).\n\n  Authority : This command is restricted to systems support personnel\n  ----------- only. It is intended for use by those persons in\n              systems support who need to look at UADS but are not\n              responsible for updating it.\n\n  Syntax :    UADS   USERID or *   PASSKW\n  --------    PASSKW    -  SUPPRESS, NUMBER or PASSWORD\n              Required  -  none\n              Defaults  -  *   and   SUPPRESS\n              Alias     -  none\n\n  Operands :  USERID   -   The name of the USERID to be displayed.\n  ----------               More than one USERID may be specified\n                           by grouping them between parentheses.\n              *        -   May be used in place of your own USERID.\n\n  The information is displayed in the following format :\n  ------------------------------------------------------\n\n  USERID - XXXXXXX  USER ATTR.: OPER ACCT JCL NOMOUNT RECOVER\n                    INST. ATTR., IN HEX: 0000 -- MAXSIZE:  1000K\n                    UPT: 00000000000000000000000000000000 PREFIX\n                    DESTINATION: (DEFAULT)\n                    HOLD MSGCLASS: (DEFAULT) -- JOB CLASS: (DEFAULT)\n                    MESSAGE CLASS: (DEFAULT) -- SYSOUT CLASS: (DEFAULT)\n           PASSWORD XXXXXXXX\n              ACCOUNT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n                 PROC XXXXXXXX  SIZE=NNNNNK  UNIT NAME: (NONE)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UADSH": {"ttr": 36619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x16?\\x00\\x86\\x16?\\x15\"\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-06-12T00:00:00", "modifydate": "1986-06-12T15:22:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=UADS\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : The UADS command displays information from SYS1.UADS\n              about one or more USERIDs.\n              Unlike the ACCOUNT command, this command\n                   a) optionally list the password, and\n                   b) does not allow changes to be made.\n\n              DDname SYSUADS must be pre-allocated to SYS1.UADS\n              before using this command.\n)X SYNTAX :   UADS   USERID or *   PASSKW\n              PASSKW    -  SUPPRESS, NUMBER or PASSWORD\n              Required  -  none\n              Defaults  -  *   and   SUPPRESS\n              Alias     -  none\n)O OPERANDS : USERID   -   The name of the USERID to be displayed.\n                           More than one USERID may be specified\n                           by grouping them between parentheses.\n              *        -   May be used in place of your own USERID.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNIT": {"ttr": 36621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12O\\x00\\x94\\x12O\\x16@\\x03T\\x03T\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-04T00:00:00", "modifydate": "1994-05-04T16:40:00", "lines": 852, "newlines": 852, "modlines": 0, "user": "SYSPAJA"}, "text": "UNIT     TITLE 'U N I T  - TSO COMMAND (DEVICES INQUIRY).'\nUNIT     START 0\n         SPACE 1\n* PURPOSE :    THE \"UNIT\" COMMAND DISPLAYS DATA ABOUT PHYSICAL DEVICES\n* ---------    DEFINED AT THE INSTALLATION. IT CAN BE USED TO SEE INFO\n*              ABOUT SPECIFIED UNIT'S NAMES, VOL=SER OR ADDRESSES.\n*\n* SYNTAX :     UNIT (DEVICE-LIST)\n* --------     REQUIRED : NONE.\n*              DEFAULT : DASD (ALL DIRECT ACCESS STORAGE DEVICES WHICH\n*                        ARE DEFINED IN THE SYSTEM).\n*              ALIAS : NONE.\n*              NOTE : AN ASTERISK (*) MEANS THE WHOLE CONFIGURATION.\n*\n* OPERANDS :\n* ----------\n* DEVICE-LIST : A LIST OF ONE OR MORE NAMES (USED IN SYSTEM TABLES\n*               SEARCH) TO GET THE DESIRED INFO. MULTIPLE NAMES MAY BE\n*               ENTERED, BUT THEY MUST BE ENCLOSED WITHIN PARENTHESIS\n*               (PARTIAL NAMES MAY BE ALSO SPECIFIED).\n*               WITH DIRECT ACCESS STORAGE DEVICES, THE FOLLOWING FIVE\n*               VALUES ARE SUPPLIED :\n*                       1) NUMBER OF FREE CYLINDERS ON DISK\n*                       2) NUMBER OF FREE TRACKS ON DISK\n*                       3) NUMBER OF EXTENTS ON DISK\n*                       4) NUMBER OF CYLINDERS OF LARGEST EXTENT\n*                       5) NUMBER OF TRACKS OF LARGEST EXTENT\n*\n* EXAMPLES :\n* ----------\n*      (1) UNIT  SYSDA\n*      (2) UNIT  1  ---> ALL DEVICES ON CHANNEL 1\n*      (3) UNIT  TAPES  ---> ALL TAPE DEVICES\n*      (4) UNIT  USE  ---> ALL DISKS NAMED USE...\n*      (5) UNIT  (USER12 USER22)\n*      (6) UNIT  372\n*      (7) UNIT  B0  ---> ALL DEVICES ON CHANNEL B, CONTROL UNIT 0\n*      (8) UNIT  PUBLIC  ---> ALL ONLINE DASD DEVICES WITH PUBLIC\n*                             STATUS\n*      (9) UNIT  PRIVATE  ---> ALL ONLINE DASD DEVICES WITH PRIVATE\n*                              STATUS\n*     (10) UNIT  STORAGE  ---> ALL ONLINE DASD DEVICES WITH STORAGE\n*                              STATUS\n*\n* ADAPTED BY : COLOMBO A. (AMDAHL CONSULTANT)\n* ------------ MOINIL P.A. - COMPUTING CENTRE (TP 361)\n*                            J.R.C. - ISPRA ESTABLISHMENT\n*                            21020 ISPRA (VA), ITALY\n*              23/08/89 : MODULE HAS BEEN CONVERTED TO PUTLINE.\n         EJECT\nUNIT    AMODE  24\nUNIT    RMODE  24\n         SPACE 1\n*        ----------------------------------------------------\n*        DSECT IEFZB421 SHOULD BE SUBSTITUTED WHEN AVAILABLE.\n*        ----------------------------------------------------\n         SPACE 1\nEDTLUVSP EQU   28,4           POINTER TO LOOK UP VALUE SECTION\nLUVENTNO EQU   8,4            NUMBER OF ENTRIES IN THIS SECTION\nLUVENTRY EQU   16,32          TABLE OF LOOK UP ENTRIES\nLUVUNAME EQU   0,8            UNIT NAME IN EBCDIC\n         SPACE 1\nLV0      EQU   0         AUTHORITY LEVEL DEFINITION = REJECT LEVEL.\n        $MDL@IX\n        $DEFREG\n        IEZBITS\n         EJECT\n        $XENT  BASE=(R11,R12),LV=WRKL,TYPE=RENT\n         LR    R9,R13              SET WORK AREAS ADDRESSABILITY\n         USING WRKDSECT,R9\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n         XC    REQAUT(REQAUTL),REQAUT\n         MVC   REQAUT+1(3),=AL3(MDL@IX)\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n        $EACM  REQAUT\n         CLI   AUTH,LV0            AUTHORIZED?\n         BE    NOTAUT              NO\n         MVC   ESTLIST(ESTLEN),ESTSKEL  SET ESTAE LIST\n         MVC   MYESCTR,=PL3'1024'  SET LOOP PROTECTION VALUE\n         SPACE 1\n*------- GET NAMES TABLE SCAN POINTERS.\n         SPACE 1\n        $TSWXA 31,EXPAND=ONLY      ENTER 31-BIT MODE\n         L     R1,CVTPTR           CVT ADDRESS\n         USING CVTMAP,R1\n         L     R1,CVTJESCT         JES CONTROL TABLE\n         DROP  R1\n         USING JESCT,R1\n         L     R15,JESCTEXT        EXTENSION\n         L     R15,JESGB4UV-JESPEXT(R15)     ADDRESS OF IFGGB4UV\n         ST    R15,DSAGB4UV\n         L     R1,JESEDT           EDT\n         DROP  R1\n         L     R2,EDTLUVSP(R1)     LOOK-UP SECTION\n         L     R0,LUVENTNO(R2)     NUMBER OF UNIT NAMES\n         LA    R14,L'LUVENTRY      LENGTH OF ENTRY\n         LA    R15,LUVENTRY(R2)    FIRST ENTRY\n         STM   R14,R0,SCEDT        SAVE EDT SCAN POINTERS\n         SPACE 1\n*------- INITIALIZATION.\n         SPACE 1\n         L     R0,=A(4096)\n        GETMAIN R,LV=(0)\n         ST    R1,DEVLADD\n         MVC   PARMNAME(L'PARMNAME),=CL12' '\n        $TEW$PP PARM=PARMLST,ATT=QUIT\n         LA    R6,VOLLIST          LOAD PTR TO DSNAME LIST\n         DROP  R2                  DROP ADDRESSABILITY TO PDL\n         SPACE 1\n*------- NO ANSWER - FALL THRU.\n         SPACE 1\n         L     R5,0(R6)            SET UP PTR TO VOLUME LIST\n         LH    R4,4(R6)            SET UP LENGTH OF VOL LIST\n         ST    R4,SAVELGTH\n         LTR   R4,R4               IS LENGTH ZERO?\n         BZ    DEFAULT             YES, ASSUME SYSDA\n         BCTR  R4,0\n         EX    R4,MOVEVOL\n         B     MAIN\nDEFAULT  MVC   PARMNAME(4),=CL8'DASD'\n         MVC   SAVELGTH,=F'4'\n         LA    R6,ENDCHAIN-8\n         SPACE 1\n*------- STEP THROUGH SEQUENCE CHECKING FOR CMD PARM ENTRY TYPE.\n         SPACE 1\nMAIN     ST    R6,PARSAVE\n         MVC   PARMNAME+L'PARMNAME(2),=CL2' -'\n         MVC   PARMNAME+L'PARMNAME+2(70),PARMNAME+L'PARMNAME+1\n         LA    R1,PARMNAME\n         LA    R0,L'PARMNAME+71\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     *+L'*+4             +0 - OK\n         B     QUIT                +4 - ERROR\n         SPACE 1\n*------- PROCESS DEVNAME(S) OR VOL(S) REQUEST. ELSE BYPASS.\n         SPACE 1\n         LM    R14,R0,SCEDT        EDT SCAN POINTERS\nNMESC    CLC   PARMNAME(L'PARMNAME),LUVUNAME(R15)\n         BE    HVNAME\n         ALR   R15,R14             GET NEXT ENTRY\n         BCT   R0,NMESC\n         XC    WRKTAB,WRKTAB       PREPARE PARAMETER LIST\n         LA    R1,WRKTAB\n         ST    R1,PRMLIST\n         MVI   DEVCL,0\n         LA    R1,DEVCL\n         ST    R1,PRMLIST+4\n         XC    ADDRUCB,ADDRUCB\n         LA    R1,ADDRUCB\n         ST    R1,PRMLIST+8\n         OI    PRMLIST+8,X'80'\nGNXUCB   LA    R1,PRMLIST          SET PARAMETER LIST ADDRESS\n         L     R2,CVTPTR           GET CVT POINTER\n         USING CVT,R2\n         L     R15,CVTUCBSC        GET SCAN SERVICE ADDRESS\n         DROP  R2\n         BASR  R14,R15             GO TO SCAN SERVICE (R13=SA)\n         LTR   R15,R15             HAS A UCB BEEN RETURNED?\n         BNZ   NONE                BRANCH IF END\n         L     R3,ADDRUCB          GET UCB ADDRESS\n         BAS   R5,CHCKUCB\n         B     GNXUCB\nHVNAME  GETMAIN R,LV=LKEY0SP,SP=0  GET KEY 0 SUBPOOL STORAGE\n         ST    R1,KEY0ADDR         SAVE KEY 0 GETMAIN'D AREA PTR\n         LR    R7,R1               PTR TO KEY 0 STORAGE\n         USING KEY0SP,R7\n         XC    KEY0SP(LKEY0SP),KEY0SP\n         LA    R1,UNITABLE         SET UP PARAMETER LIST FOR KEY 0\n         ST    R1,UTBLPTR               STORAGE FOR IEFAB4UV\n         LA    R1,FLAGS\n         ST    R1,FLAGPTR\n         MVC   UNAME(L'UNAME),PARMNAME\n         MVC   FLAGS,=XL2'1000'    BIT 3 SET FOR UCB SEARCH\n        ESTAE  MYESTAE,CT,PARAM=(R9),MF=(E,ESTLIST)\n         LA    R1,PARMLIST\n         L     R15,DSAGB4UV\n         BASR  R14,R15\n         ST    R15,DSAGB4RC        SAVE RC\n        ESTAE  0\n         MVC   LISTUCB,PTRUCB      SAVE PTR TO UCB LIST\n         DROP  R7\n         L     R1,KEY0ADDR         KEY 0 STORAGE CAN NOW BE FREED\n        FREEMAIN R,A=(1),LV=LKEY0SP,SP=0\n         L     R15,DSAGB4RC        RESTORE RC\n         LTR   R15,R15             HAVE UCBS BEEN RETURNED?\n         BZ    GOTUCBS             UCBS RETURNED GO LOOK AT THEM\n         CH    R15,=H'4'           R15 = 4\n         BE    NONAME              SAY CLASS NAME NOT FOUND\n         CH    R15,=H'16'          R15 = 16\n         BE    NOSTRGE             NO STORAGE AVAIL FOR UCB LIST\n         LA    R1,ABENDIT          ABEND ALL OTHER RETURN CODES\n         LA    R0,L'ABENDIT\n         B     SNDMSG\nNONAME   LA    R1,NONAMEM\n         LA    R0,L'NONAMEM\n         B     SNDMSG\nNOSTRGE  LA    R1,NOSTORGE\n         LA    R0,L'NOSTORGE\n         B     SNDMSG\nGOTUCBS  ICM   R6,B'1111',LISTUCB  PTR TO UCB LIST?\n         BNZ   SCUCBS              YES\n         LA    R1,NOTUCBLS\n         LA    R0,L'NOTUCBLS\n         B     SNDMSG\nSCUCBS   MVC   LISTLEN,0(R6)       HOLD SUBPOOL & LEN OF LIST\n         L     R7,4(R6)            NUMBER OF UCBS IN LIST\n         LA    R6,8(R6)            ADDRESS OF 1ST UCB PTR\nGETUCB   L     R3,0(R6)            FIRST UCB PTR\n         STM   R6,R7,CNTSAVE\n         BAS   R5,ROUTER\n         LM    R6,R7,CNTSAVE\n         LA    R6,4(R6)            NEXT UCB PTR\n         BCT   R7,GETUCB           LOOP IF MORE\n         L     R0,LISTLEN          NOW FREE THE UCB LIST SUBPOOL 0\n         N     R0,=A(X'00FFFFFF')  FORCE SUBPOOL 0\n         L     R1,LISTUCB\n        FREEMAIN R,A=(1),LV=(0)\n         B     SEENEXT\n         SPACE 1\n*------- CHECK FOR ADDITIONAL PARAMETERS. IF MORE, PROCESS.\n         SPACE 1\nNONE     TM    SWITCH,FLPRCSD      SOMETHING DONE?\n         BO    SEENEXT             YES\n         LA    R1,NONEM\n         LA    R0,L'NONEM\nSNDMSG   BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     SEENEXT             +0 - OK\n         B     QUIT                +4 - ERROR\nSEENEXT  L     R6,PARSAVE\n         L     R5,8(,R6)           LOAD CHAIN FOR VOL LIST\n         C     R5,ENDCHAIN         IS IT END OF VOL LIST?\n         BE    LEAVE               IF YES CLEANUP & EXIT\n         L     R6,8(,R6)           LOAD PTR TO NEXT VOLUME\n         L     R5,0(R6)\n         MVC   PARMNAME(L'PARMNAME),=CL12' '\n         LH    R4,4(R6)            SET UP LENGTH OF VOL LIST\n         ST    R4,SAVELGTH\n         LTR   R4,R4               IS LENGTH ZERO?\n         BNP   SEENEXT\n         BCTR  R4,0\n         EX    R4,MOVEVOL\n         L     R4,DEVLADD\n         L     R5,=A(4096)\n         BASR  R14,0\n         XR    R15,R15\n         MVCL  R4,R14\n         B     MAIN\nMOVEVOL  MVC   PARMNAME(*-*),0(R5) GET PARAMETER FROM CMND\n         SPACE 1\n*------- TERMINATION.\n         SPACE 1\nQUIT     LA    R2,16               RC=16 ------------------------------\n         B     LEAVE+L'LEAVE\nLEAVE    XR    R2,R2               RC=0 -------------------------------\n        IKJRLSA #TSANSW\n         L     R0,=A(4096)\n         L     R1,DEVLADD\n        FREEMAIN R,A=(1),LV=(0)\n        $TSWXA 24,EXPAND=ONLY      BACK 24-BIT MODE\n         B     EXIT\nNOTAUT   LA    R1,UNAUT\n         LA    R0,L'UNAUT\n         BAS   R14,PUTLNE\nSETRC    LA    R2,16               RC=16 ------------------------------\nEXIT    $XRET  CC=(R2),LV=WRKL,TYPE=RENT\n         EJECT\n*------- CHCKUCB - REAL UCB CHECK ROUTINE (GO FINGER OUT GOOD UCB).\n*              R3  : POINTS TO AN UCB.\n*              R5  : LINK REGISTER.\n         SPACE 1\n         USING UCBDSECT,R3\nCHCKUCB  MVC   RUCBNAME(16),=CL16'         BAD UCB'\n         CLI   UCBID,X'FF'         GOOD UCB?\n         BNE   RUCBBAD             NO, BAD UCB\n         MVC   WORKF(2),UCBCHAN    BUILD UCB ADDRESS IN CHARACTERS\n         UNPK  WORKD(5),WORKF(3)\n         MVC   RUCBNAME(4),WORKD\n         TR    RUCBNAME(4),TRTABLE-C'0'\n         CLC   RUCBNAME+2(2),UCBNAME+1  UCB NAME OK?\n         BE    RUCBGOOD\n         CLC   UCBTBYT3(2),=AL1(UCB3DACC,BIT5+BIT6)    2305-1?\n         BE    UN2305\n         CLC   UCBTBYT3(2),=AL1(UCB3DACC,BIT5+BIT6+BIT7)    2305-2?\n         BNE   RUCBBAD\nUN2305   CLC   RUCBNAME+1(2),UCBNAME    CHECK FIRST 2 CHARACTERS\n         BNE   RUCBBAD\n         CLI   RUCBNAME+3,C'0'\n         BE    RUCBGOOD\n         CLI   RUCBNAME+3,C'8'\n         BE    RUCBGOOD\n         BR    R5\nRUCBBAD  MVC   RUCBNAME+5(3),UCBNAME\n         LA    R1,RUCBNAME\n         LA    R0,L'RUCBNAME\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     0(R5)               +0 - OK\n         B     QUIT                +4 - ERROR\nRUCBGOOD L     R4,SAVELGTH         RESTORE REG 4\n         BCTR  R4,0\n         EX    R4,COMPUCB          UCB NAME?\n         BE    PROCESS             YES\n         EX    R4,COMPVOL          VOL=SER?\n         BE    PROCESS             YES\n         CLI   PARMNAME,C'*'       WHOLE CONFIGURATION?\n         BE    PROCESS             YES\n         CLI   UCBTBYT3,UCB3DACC   DASD TYPE?\n         BNE   NDSD                NO\n         CLC   PARMNAME(8),=CL8'DASD'\n         BE    PROCESS\n         TM    UCBSTAT,UCBONLI     ONLINE FLAG\n         BZ    NDSD\n         CLC   PARMNAME(6),=CL6'PUBLIC'\n         BNE   IFPRIV\n         TM    UCBSTAB,UCBBPUB     PUBLIC FLAG\n         BO    PROCESS\nIFPRIV   CLC   PARMNAME(6),=CL6'PRIVAT'\n         BNE   IFSTOR\n         TM    UCBSTAB,UCBBPRV     PRIVATE FLAG\n         BO    PROCESS\nIFSTOR   CLC   PARMNAME(7),=CL7'STORAGE'\n         BNE   NDSD\n         TM    UCBSTAB,UCBBSTR     STORAGE FLAG\n         BO    PROCESS\nNDSD     CLI   UCBTBYT3,UCB3TAPE   TAPE TYPE?\n         BNER  R5                  NO\n         CLC   PARMNAME(5),=CL5'TAPES'\n         BNER  R5\nPROCESS  ST    R5,CNTSAVE\n         BAS   R5,ROUTER\n         L     R5,CNTSAVE\n         BR    R5\nCOMPVOL  CLC   PARMNAME(*-*),UCBVOLI\nCOMPUCB  CLC   PARMNAME(*-*),UCBNAME\n         DROP  R3\n         EJECT\n*------- ROUTER - DISPATCH TO DIFFERENT DEVICES ROUTINES.\n*              R3  : POINTS TO A VERIFIED UCB.\n*              R5  : LINK REGISTER.\n         SPACE 1\n         USING UCBDSECT,R3\nROUTER   ST    R5,ROUTERS\n         NI    SWITCH,255-FLPRCSD\n         MVI   MSG,C' '\n         MVC   MSG+1(L'MSG-1),MSG\n         MVC   MSG(3),UCBNAME      ADDRESS\n         MVC   ADDRWK(3),UCBNAME\n         XR    R5,R5\n         CLI   ADDRWK,C'0'\n         BNL   WK1\n         IC    R5,ADDRWK\n         LA    R5,9(,R5)\n         STC   R5,ADDRWK\nWK1      CLI   ADDRWK+1,C'0'\n         BNL   WK2\n         IC    R5,ADDRWK+1\n         LA    R5,9(,R5)\n         STC   R5,ADDRWK+1\nWK2      CLI   ADDRWK+2,C'0'\n         BNL   WK3\n         IC    R5,ADDRWK+2\n         LA    R5,9(,R5)\n         STC   R5,ADDRWK+2\nWK3      PACK  ADDRWK(4),ADDRWK(3) PACK IT\n         L     R5,ADDRWK\n         SRL   R5,4                LOSE SIGN\n         STH   R5,ADDRWK\n         L     R5,DEVLADD\n         AH    R5,ADDRWK           ADDRESS\n         CLI   0(R5),C'Y'\n         BE    DUPLIC\n         MVI   0(R5),C'Y'\n         SPACE 1\n*------- GIVE A UNITNAME TO A DEVTYPE IN A UCB.\n         SPACE 1\n         MVC   WORKD(4),UCBTYP     R3 POINTS TO A UCB\n         UNPK  XWORK(15),WORKD(8)\n         MVC   DEVTYP(8),XWORK\n         TR    DEVTYP(8),TRTABLE-C'0'\n         MVC   DEVTY(4),UCBTYP\n         LM    R14,R0,SCEDT        EDT SCAN POINTERS\nTABLS    CLI   DEVTY+2,UCB3TAPE    TAPE?\n         BNE   COMPT               NO\n         CLC   DEVTY(L'DEVTY),L'LUVUNAME(R15)     TEST CORRECT DEVTYPE\n         BNE   TABLSLOO\nHAVEN    MVC   DEVTYP(L'DEVTYP),LUVUNAME(R15)     DEVTYPE\n         B     DVTEND\nCOMPT    CLC   DEVTY+2(2),LUVUNAME+2(R15)    TEST CORRECT DEVTYPE\n         BE    HAVEN\nTABLSLOO ALR   R15,R14             GET NEXT ENTRY\n         BCT   R0,TABLS            READ AGAIN\n         CLI   DEVTY+2,UCB3COMM    COMMUNICATION?\n         BNE   DVTEND              NO\n         SPACE 1\n*------- RIGTH SEMIBYTE, CONTROL UNIT.\n         SPACE 1\n         TM    DEVTY+3,BIT5\n         BO    TCU3\n         TM    DEVTY+3,BIT6+BIT7\n         BZ    TAT\n         BM    TCU1\n         MVC   DEVTYP(8),=CL8'2703'\n         B     TAT\nTCU1     TM    DEVTY+3,BIT7\n         BO    TCU2\n         MVC   DEVTYP(8),=CL8'2701'\n         B     TAT\nTCU2     MVC   DEVTYP(8),=CL8'2702'\n         B     TAT\nTCU3     TM    DEVTY+3,BIT7\n         BZ    TCU4\n         MVC   DEVTYP(8),=CL8'3704/5'\n         B     DVTEND\nTCU4     MVC   DEVTYP(8),=CL8'2955'\n         SPACE 1\n*------- LEFT  SEMIBYTE, ADAPTER TYPE.\n         SPACE 1\nTAT      TM    DEVTY+3,BIT0+BIT1+BIT2+BIT3\n         BNO   TAT1\n         MVC   DEVTYP(8),=CL8'3791'\n         B     DVTEND\nTAT1     TM    DEVTY+3,BIT3\n         BNO   *+L'*+6\n         MVC   DEVTYP+4(4),=CL4'IBM1'\n         TM    DEVTY+3,BIT2\n         BNO   *+L'*+6\n         MVC   DEVTYP+4(4),=CL4'IBM2'\n         TM    DEVTY+3,BIT2+BIT3\n         BNO   *+L'*+6\n         MVC   DEVTYP+4(4),=CL4'IBMT'\n         TM    DEVTY+3,BIT1\n         BNO   *+L'*+6\n         MVC   DEVTYP+4(4),=CL4'TEL1'\n         TM    DEVTY+3,BIT1+BIT3\n         BNO   *+L'*+6\n         MVC   DEVTYP+4(4),=CL4'TEL2'\n         TM    DEVTY+3,BIT1+BIT2\n         BNO   *+L'*+6\n         MVC   DEVTYP+4(4),=CL4'WTTA'\n         TM    DEVTY+3,BIT1+BIT2+BIT3\n         BNO   *+L'*+6\n         MVC   DEVTYP+4(4),=CL4'SYN1'\n         TM    DEVTY+3,BIT0\n         BNO   *+L'*+6\n         MVC   DEVTYP+4(4),=CL4'IBM3'\n         TM    DEVTY+3,BIT0+BIT3\n         BNO   *+L'*+6\n         MVC   DEVTYP+4(4),=CL4'SYN2'\n         CLC   DEVTYP(8),=CL8'2701SYN2'\n         BNE   AS2\n         TM    DEVTY,BIT5+BIT6+BIT7\n         BO    AS1A\n         MVC   DEVTYP(8),=CL8'BSC1'\n         B     DVTEND\nAS1A     MVC   DEVTYP(8),=CL8'BSC3'\n         B     DVTEND\nAS2      CLC   DEVTYP(8),=CL8'2701TEL2'\n         BNE   AS3\n         MVC   DEVTYP(8),=CL8'TWX'\n         B     DVTEND\nAS3      CLC   DEVTYP(8),=CL8'2701IBM1'\n         BNE   DVTEND\n         TM    DEVTY,BIT5+BIT6+BIT7\n         BO    DVTEND\n         TM    DEVTY,BIT5+BIT7\n         BNO   AS3A\n         MVC   DEVTYP(8),=CL8'2741C'\n         B     DVTEND\nAS3A     TM    DEVTY,BIT5+BIT6\n         BNO   DVTEND\n         MVC   DEVTYP(8),=CL8'2741C'\nDVTEND   MVC   MSG+4(8),DEVTYP\n         LA    R5,MSG+13\n         TM    UCBSTAT,UCBONLI\n         BO    IFTAPE\n         MVC   MSG+13(7),=CL7'OFFLINE'\n         LA    R5,MSG+21\nIFTAPE   CLI   UCBTBYT3,UCB3TAPE   TAPE?\n         BNE   IFDASD              NO\n         BAS   R14,VOLUMES\n         TM    UCBSTAT,UCBONLI\n         BZ    TAPEOFF\n         BAS   R14,OPENDS\nTAPEOFF  TM    UCBTBYT1,BIT5       1600?\n         BO    TTP2                YES\n         TM    UCBTBYT1,BIT6       6250?\n         BZ    ROUTEND             NO\n         TM    UCBTBYT2,BIT3       1600/6250\n         BO    TTP1\n         MVC   0(4,R5),=CL4'6250'\n         LA    R5,5(,R5)\n         B     ROUTEND\nTTP1     MVC   0(9,R5),=CL9'1600/6250'\n         LA    R5,10(,R5)\n         B     ROUTEND\nTTP2     TM    UCBTBYT2,BIT2       800/1600\n         BO    TTP3\n         MVC   0(4,R5),=CL4'1600'\n         LA    R5,5(,R5)\n         B     ROUTEND\nTTP3     MVC   0(8,R5),=CL8'800/1600'\n         LA    R5,9(,R5)\n         B     ROUTEND\nIFDASD   CLI   UCBTBYT3,UCB3DACC\n         BNE   ROUTEND\n         BAS   R14,VOLUMES\n         TM    UCBSTAT,UCBONLI\n         BZ    ROUTEND\n         LR    R0,R3               SET ADDRESS OF UCB\n         LR    R1,R5               SET ADDRESS OF MSG AREA\n         SVC   78                  ISSUE LSPACE SVC\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   CHKCODE             IF NOT ZERO, ERROR\n         LA    R5,31(,R5)\n         BAS   R14,OPENDS\n         B     ROUTEND\nCHKCODE  MVC   DIAG(31),=CL31'LSPACE SVC ERROR. RETURN CODE :'\n         CVD   R15,WORKD\n         MVC   DIAG+31(6),=XL6'402020202120'\n         ED    DIAG+31(6),WORKD+5\n         LA    R1,DIAG\n         LA    R0,37\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     ROUTEND             +0 - OK\n         B     QUIT                +4 - ERROR\nROUTEND  TM    UCBSTAT,UCBONLI     IF OFFLINE, IGNORE FLAGS\n         BZ    PUMS\n         SPACE 1\n*------- PREPARE AND PUT OUT A MESSAGE FOR A DISK(R3 POINTS TO A UCB).\n         SPACE 1\n         L     R1,=A(TABLE)        R3 POINTS TO A UCB\nFLAGLOOP CLI   0(R1),X'FF'         END OF TABLE?\n         BE    PUMSG               YES\n         CLI   0(R1),X'00'         GENERAL CHECK?\n         BE    CHECKIT             YES\n         CLC   0(1,R1),UCBTBYT3    CHECK SPECIFIC DEVICE TYPE\n         BNE   NEXTFLAG\nCHECKIT  LR    R15,R3              GET COPY OF UCB ADDRESS\n         XR    R14,R14             ZERO FOR INSERT\n         IC    R14,1(R1)           GET OFFSET OF FLAG IN UCB\n         AR    R15,R14             GET ADDRESS OF FLAG\n         IC    R14,2(R1)           GET FLAG\n         EX    R14,TEST4FLG        TEST FOR CORRECT FLAG\n         BZ    NEXTFLAG            NOT ON, LOOP\n         MVC   0(7,R5),3(R1)       MOVE IN STATUS DESCRIPTOR\nLOPONIT  LA    R5,1(,R5)           BUMP AREA POINTER\n         CLI   0(R5),C' '\n         BNE   LOPONIT\n         LA    R5,1(,R5)           NEXT CHARACTER TO WRITE\nNEXTFLAG LA    R1,L'TABLE(,R1)     BUMP FLAG POINTER\n         B     FLAGLOOP\nTEST4FLG TM    0(R15),*-*          TEST FOR FLAG\n         SPACE 1\n*------- UCB OFFLINE FLAGS.\n         SPACE 1\nPUMS     TM    UCBFLB,UCBNOPTH\n         BZ    PUMS1\n         DROP  R3\n         MVC   0(6,R5),=CL6'NOPATH'\n         LA    R5,7(R5)\nPUMS1    CLC   MSG+4(8),=CL8'00000000'\n         BNE   PUMSG\n         MVC   MSG+4(8),=CL8'DUMMY...'\n         SPACE 1\n*------- SEND MESSAGE LINE.\n         SPACE 1\nPUMSG    CLI   0(R5),C' '\n         BNE   *+L'*+4\n         BCT   R5,PUMSG\n         LA    R15,MSG\nPUMSG1   LA    R1,78(,R15)\n         CLR   R5,R1\n         BH    PUMSG2\n         LA    R0,1(,R5)\n         XC    MPOS,MPOS\n         B     PUMSGS\nPUMSG2   CLI   0(R1),C' '\n         BE    *+L'*+4\n         BCT   R1,PUMSG2\n         ST    R1,MPOS\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         LA    R0,1(,R1)\nPUMSGS   LR    R1,R15\n         SR    R0,R1\n         OI    SWITCH,FLPRCSD\n         BAS   R14,PUTLNE\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     *+L'*+4             +0 - OK\n         B     QUIT                +4 - ERROR\n         L     R15,MPOS\n         LTR   R15,R15\n         BZ    DUPLIC\n         SH    R15,=H'12'\n         MVC   0(12,R15),=CL12' '\n         B     PUMSG1\nDUPLIC   L     R5,ROUTERS\n         BR    R5\n         EJECT\n         USING UCBDSECT,R3         R3 POINTS TO THE UCB\n         SPACE 1\n*------- VOLUMES - R14 : LINK REGISTER.\n         SPACE 1\nVOLUMES  CLC   UCBVOLI(L'UCBVOLI),=CL12' '\n         BER   R14\n         CLC   UCBVOLI(L'UCBVOLI),=XL6'0'\n         BER   R14\n         MVC   0(L'UCBVOLI,R5),UCBVOLI\n         LA    R5,L'UCBVOLI+1(R5)\n         BR    R14\n         SPACE 1\n*------- OPENDS - R14 : LINK REGISTER.\n         SPACE 1\nOPENDS   MVC   WORKF(1),UCBDMCT    NUMBER OF DATA-SET DCB'S OPEN\n         NI    WORKF,X'7F'         LOSE FIRST BIT\n         CLI   WORKF,0\n         BER   R14\n         XR    R1,R1\n         IC    R1,WORKF\n         CVD   R1,WORKD\n         MVC   WORKF,=XL4'40202120'\n         ED    WORKF,WORKD+6\n         MVC   0(3,R5),WORKF+1\n         LA    R5,4(R5)\n         BR    R14\n         SPACE 1\n         DROP  R3\n         EJECT\n*------- CONSTANTS.\n         SPACE 1\nENDCHAIN DC    A(X'FF000000')\nTRTABLE  DC    CL16'0123456789ABCDEF'\nESTSKEL ESTAE  *-*,MF=L\nESTLEN   EQU   *-ESTSKEL\nABENDIT  DC    C'ABEND IT.'\nNONAMEM  DC    C'CLASS NAME NOT FOUND - RETRY.'\nNOSTORGE DC    C'NO STORAGE AVAILABLE FOR UCB LIST.'\nNOTUCBLS DC    C'UCB LIST NOT BEING SEARCHED.'\nUNAUT    DC    C'UNAUTHORIZED COMMAND - REJECTED.'\nNONEM    DC    C'NONE FOUND OR INVALID.'\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R9,R11,R12\n         EJECT\n         DS    0H\n*------- UCB TEST FLAGS TABLE. EACH ELEMENT (10 BYTES LONG) HAS THE\n*        FOLLOWING FORMAT :\n*              +0  (XL1) : TEST DEVICE CLASS OR 0 FOR ALL CLASSES.\n*              +1  (XL1) : UCB BYTE DISPLACEMENT FOR TEST.\n*              +2  (XL1) : UCB FLAGS TO TEST.\n*              +3  (CL7) : DESCRIPTION (RIGHT PADDED WITH BLANKS).\n         SPACE 1\nTABLE    DS    0CL10               --- START OF TABLE ---\n         DC    AL1(UCB3DACC,UCBJBNR-UCBDSECT,UCBVRDEV),CL7'VIO'\n*                                  UCB FOR VIO DEVICE\n         DC    AL1(UCB3DACC,UCBJBNR-UCBDSECT,UCBJES3),CL7'JES3'\n*                                  JES3 CONTROLLED VOLUME\n         DC    AL1(UCB3TAPE,UCBJBNR-UCBDSECT,UCBJES3),CL7'JES3'\n*                                  JES3 CONTROLLED VOLUME\n         DC    AL1(UCB3DISP,UCBJBNR-UCBDSECT,UCBDUC),CL7'UC/IPL'\n*                                  DISPLAY UNIT CHECK AT IPL\n         DC    AL1(*-*,UCBJBNR-UCBDSECT,UCBMMSGP),CL7'MNT/PND'\n*                                  MOUNT MSG PENDING\n         DC    AL1(UCB3DACC,UCBFL5-UCBDSECT,UCBAMV),CL7'OKVSAM'\n*                                  OK VSAM VTOC ECT\n         DC    AL1(UCB3DACC,UCBFL5-UCBDSECT,UCBNALOC),CL7'*SYS*'\n*                                  JES2, ETC...\n         DC    AL1(UCB3DACC,UCBFL5-UCBDSECT,UCBALTCU),CL7'ALT/CU'\n*                                  DEVICE HAS ALTERNATE CUA\n         DC    AL1(*-*,UCBSTAT-UCBDSECT,UCBCHGS),CL7'OFF/PND'\n*                                  CHANGING STATUS\n         DC    AL1(UCB3DACC,UCBSTAT-UCBDSECT,UCBRESV),CL7'RESVD'\n*                                  MOUNT STATUS - RESERVED\n         DC    AL1(*-*,UCBSTAT-UCBDSECT,UCBUNLD),CL7'UNL/PND'\n*                                  UNLOAD PENDING\n         DC    AL1(UCB3DACC,UCBSTAT-UCBDSECT,UCBALOC),CL7'ALLOC''D'\n*                                  ALLOCATED\n         DC    AL1(UCB3DACC,UCBSTAT-UCBDSECT,UCBPRES),CL7'PERM'\n*                                  PERMANENTLY RESIDENT\n         DC    AL1(UCB3DACC,UCBSTAT-UCBDSECT,UCBSYSR),CL7'SYSRES'\n*                                  SYSRES, MSTRCONS, CONS\n         DC    AL1(UCB3DISP,UCBSTAT-UCBDSECT,UCBSYSR),CL7'CONSOLE'\n*                                  SYSRES, MSTRCONS, CONS\n         DC    AL1(UCB3UREC,UCBSTAT-UCBDSECT,UCBSYSR),CL7'CONSOLE'\n*                                  SYSRES, MSTRCONS, CONS\n         DC    AL1(UCB3TAPE,UCBSTAT-UCBDSECT,UCBDADI),CL7'SL'\n*                                  LABELS VERIFIED/SECONS\n         DC    AL1(UCB3DISP,UCBSTAT-UCBDSECT,UCBDADI),CL7'SECONS'\n*                                  LABELS VERIFIED/SECONS\n         DC    AL1(UCB3UREC,UCBSTAT-UCBDSECT,UCBDADI),CL7'SECONS'\n*                                  LABELS VERIFIED/SECONS\n         DC    AL1(*-*,UCBFLA-UCBDSECT,UCBDEFER),CL7'DEFER''D'\n*                                  DEVICE TEMPORARILY UNUSABLE\n         DC    AL1(*-*,UCBFLA-UCBDSECT,UCBNRY),CL7'N/RDY'\n*                                  DEVICE NOT READY\n         DC    AL1(*-*,UCBFLA-UCBDSECT,UCBPERM),CL7'SCH/OUT'\n*                                  SUBCHANNEL UNUSABLE\n         DC    AL1(*-*,UCBFLA-UCBDSECT,UCBPSNS),CL7'SNS/PND'\n*                                  PENDING SENSE OPERATION\n         DC    AL1(*-*,UCBFLA-UCBDSECT,UCBSTRT),CL7'ST/SCH'\n*                                  START SUBCHANNEL\n         DC    AL1(*-*,UCBFLA-UCBDSECT,UCBHALT),CL7'HL/SCH'\n*                                  HALT SUBCHANNEL\n         DC    AL1(*-*,UCBFLA-UCBDSECT,UCBCLEAR),CL7'CL/SCH'\n*                                  CLEAR SUBCHANNEL\n         DC    AL1(*-*,UCBFLA-UCBDSECT,UCBBOX),CL7'DEV/OFF'\n*                                  DEVICE OFFLINE (I/O ERROR)\n         DC    AL1(*-*,UCBFLB-UCBDSECT,UCBINCPT),CL7'INT/ERP'\n*                                  INTERCEPT / ERP REQUIRED\n         DC    AL1(*-*,UCBFLB-UCBDSECT,UCBNOCON),CL7'NO/SCH'\n*                                  DEV. NOT CONNECTED TO A SUBCH.\n         DC    AL1(*-*,UCBWGT-UCBDSECT,UCBREW),CL7'REWND'\n*                                  REWIND IN PROGRESS\n         DC    AL1(*-*,UCBFLC-UCBDSECT,UCBATTP),CL7'ATT/PND'\n*                                  ATTENTION PENDING\n         DC    AL1(*-*,UCBFLC-UCBDSECT,UCBITFP),CL7'INT/PND'\n*                                  INTERCEPT CONDITION PENDING\n         DC    AL1(*-*,UCBFLC-UCBDSECT,UCBUDE),CL7'UN/DE'\n*                                  UNSOLICITED DEVICE END\n         DC    AL1(*-*,UCBFLC-UCBDSECT,UCBIVRS),CL7'INT/MS'\n*                                  INTERVENTION REQ MSG ISSUED\n         DC    AL1(*-*,UCBFLC-UCBDSECT,UCBIVRR),CL7'INT/RQ'\n*                                  INTERVENTION REQ MSG NEEDED\n         DC    AL1(*-*,UCBFLC-UCBDSECT,UCBDDRSW),CL7'DDR/PND'\n*                                  DDR SWITCH PENDING\n         DC    AL1(UCB3DACC,UCBSTAB-UCBDSECT,UCBBPRV),CL7'PRIVATE'\n*                                  USE STATUS - PRIVATE\n         DC    AL1(UCB3DACC,UCBSTAB-UCBDSECT,UCBBPUB),CL7'PUBLIC'\n*                                  USE STATUS - PUBLIC\n         DC    AL1(UCB3DACC,UCBSTAB-UCBDSECT,UCBBSTR),CL7'STORAGE'\n*                                  USE STATUS - STORAGE\n         DC    XL3'FFFFFF',CL7'     '   --- END OF TABLE ---\n         EJECT\n         USING MYESTAE,R15\n         CNOP  0,4\n         USING SDWA,R1\nMYESTAE  CH    R0,=H'12'           Q/SDWA\n         BE    MYESQUIT            N/GET OUT\n         L     R9,SDWAPARM\n         USING WRKDSECT,R9\n         SP    MYESCTR,=P'1'       LOOP FAILSAFE\n         DROP  R9\n         BZ    MYESQUIT\n         CLC   =X'0C2000',SDWACMPC PRIV OP INTERRUPT?\n         BNE   MYESGFF             YES, SKIP IT\n         L     R0,SDWANXT1         NEW INSTR AFTER PRIVOP\n         B     MYESRTRY\nMYESGFF  CLC   =X'B78000',SDWACMPC GETMAIN/FREEMAIN FAIL\n         BNE   MYESQUIT\n         ICM   R0,B'1111',SDWASRSV+15*4 GET ORIG R15\n         N     R0,=X'FFFF00FF'     SET SUBPOOL TO ZERO\n         STCM  R0,B'1111',SDWASRSV+15*4 NEW R15\n         L     R0,SDWANXT2\n         SH    R0,=H'2'            BACKUP\nMYESRTRY SETRP RC=4,RETADDR=(R0),FRESDWA=YES,DUMP=NO,RETREGS=YES\n         BR    R14\nMYESQUIT SETRP RC=0,FRESDWA=NO,DUMP=YES\n         BR    R14\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R1,R15\n         EJECT\n*------- DSECTS FOR CONTROL BLOCKS.\n         SPACE 1\n         PRINT NOGEN\nPARMLST IKJPARM\nVOLLIST IKJIDENT    NAME,LIST,FIRST=ALPHANUM,OTHER=ALPHANUM,           X\n               DEFAULT='DASD',CHAR,MAXLNTH=8\n        IKJENDP\n         PRINT GEN\n         SPACE 1\n*------- WORK-AREAS DESCRIPTION.\n         SPACE 1\nWRKDSECT DSECT\nSVA      DS    18F\nWORKD    DS    D\nWORKF    DS    F\n        $TEW$WA\n         SPACE 1\nCNTSAVE  DS    5F\nROUTERS  DS    F\nDEVLADD  DS    F\nADDRWK   DS    F\nSAVELGTH DS    F\nPARSAVE  DS    F\nMPOS     DS    F\nXWORK    DS    CL16\nDEVTYP   DS    CL8\nDEVTY    DS    CL4\n         SPACE 1\nRUCBNAME DS    CL16\nPARMNAME DS    CL8,CL72\nDIAG     DS    CL60\nMSG      DS    CL256' '\n         SPACE 1\nESTLIST ESTAE  *-*,MF=L\nSCEDT    DS    3F                  EDT SCAN POINTERS (R14-R15-R0)\nDSAGB4UV DS    A                   EP OF IEFGB4UV\nDSAGB4RC DS    F                   RC OF IEFGB4UV\nKEY0ADDR DS    F\nLISTLEN  DS    F\nLISTUCB  DS    F\n         SPACE 1\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)\nAUTH     DC    XL1'0'\nREQAUTL  EQU   *-REQAUT\nSWITCH   DS    XL1\nFLPRCSD  EQU   X'01'          PROCESSED FLAG\nMYESCTR  DS    PL3                 LOOP PROTECTION COUNTER\n         SPACE 1\n         DS    0D                  ALIGNMENT NEEDED\nWRKTAB   DS    XL100\nPRMLIST  DS    3F\nADDRUCB  DS    F\nDEVCL    DS    XL1\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH\n         SPACE 1\n*------- GETMAIN DSECT FOR KEY 0 SUBPOOL.\n         SPACE 1\nKEY0SP   DSECT\nPARMLIST DS    2F                  PARMLIST MAPPING\n         ORG   PARMLIST\nUTBLPTR  DS    F                   ADDRESS OF THE UNIT TABLE\nFLAGPTR  DS    F                   ADDRESS OF THE FUNCTION REQUEST\n         DS    0F\nUNITABLE DS    CL20\n         ORG   UNITABLE\nUNAME    DS    CL8\nPTRUCB   DS    F\n         DS    F\n         DS    F\nFLAGS    DS    XL2\n         SPACE 1\nLKEY0SP  EQU   (((*-KEY0SP)+7)/8)*8\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS\nUCBDSECT DSECT\n        IEFUCBOB\n        IEFJESCT\n        IHASDWA\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNIT$": {"ttr": 37123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "//UNIT     JOB (........),'INSTALL  - UNIT -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=UNIT\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  NAME    UNIT(R)\n/*\n//HLP     EXEC PAJHELP,MBR=UNITH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNIT@": {"ttr": 37125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00.\\x00.\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      UNIT      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          DEVICES INQUIRY.           * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    The UNIT command displays data about physical devices\n  ---------    defined at the installation. It can be used to see info\n               about specified unit's names, VOL=SER or addresses.\n\n  Authority :  This command is restricted to systems support personnel\n  -----------  only.\n\n  Syntax :     UNIT (DEVICE-LIST)\n  --------     Required : none.\n               Default : DASD (all direct-access storage devices which\n                         are defined in the system).\n               ALIAS : none.\n               Note : an asterisk (*) means the whole configuration.\n\n  Operands :\n  ----------\n  DEVICE-LIST : a list of one or more names (used in system tables\n                search) to get the desired info. Multiple names may be\n                entered, but they must be enclosed within parentheses\n                (partial names may be also specified).\n                With direct-access storage devices, the following five\n                values are supplied :\n                        1) number of free cylinders on disk\n                        2) number of free tracks on disk\n                        3) number of extents on disk\n                        4) number of cylinders of largest extent\n                        5) number of tracks of largest extent\n\n  Examples :\n  ----------\n       (1) UNIT  SYSDA\n       (2) UNIT  1  -----> all devices on channel 1\n       (3) UNIT  TAPES\n       (4) UNIT  USE  ---> all disks named USE...\n       (5) UNIT  (USER12 USER22)\n       (6) UNIT  372\n       (7) UNIT  B0   ---> all devices on channel B, control unit 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNITH": {"ttr": 37127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\"\\x00\"\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=UNIT\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  THE \"UNIT\" COMMAND DISPLAYS DATA ABOUT PHYSICAL DEVICES\n               DEFINED AT THE INSTALLATION. IT CAN BE USED TO SEE INFO\n               ABOUT SPECIFIED UNIT'S NAMES, VOL=SER OR ADDRESSES.\n               THIS COMMAND IS RESTRICTED TO SYSTEMS SUPPORT PEOPLE\n               ONLY.\n)X SYNTAX :    UNIT (DEVICE-LIST)\n               REQUIRED : NONE.\n               DEFAULT : DASD (ALL DIRECT ACCESS STORAGE DEVICES WHICH\n                         ARE DEFINED IN THE SYSTEM).\n               ALIAS : NONE.\n               NOTE : AN ASTERISK (*) MEANS THE WHOLE CONFIGURATION.\n)O OPERANDS :\n))DEVICE-LIST : A LIST OF ONE OR MORE NAMES (USED IN SYSTEM TABLES\n                SEARCH) TO GET THE DESIRED INFO. MULTIPLE NAMES MAY BE\n                ENTERED, BUT THEY MUST BE ENCLOSED WITHIN PARENTHESIS\n                (PARTIAL NAMES MAY BE ALSO SPECIFIED).\n                WITH DIRECT ACCESS STORAGE DEVICES, THE FOLLOWING FIVE\n                VALUES ARE SUPPLIED :\n                        1) NUMBER OF FREE CYLINDERS ON DISK\n                        2) NUMBER OF FREE TRACKS ON DISK\n                        3) NUMBER OF EXTENTS ON DISK\n                        4) NUMBER OF CYLINDERS OF LARGEST EXTENT\n                        5) NUMBER OF TRACKS OF LARGEST EXTENT\n))EXAMPLES :\n       (1) UNIT  SYSDA\n       (2) UNIT  1  -----> ALL DEVICES ON CHANNEL 1\n       (3) UNIT  TAPES\n       (4) UNIT  USE  ---> ALL DISKS NAMED USE...\n       (5) UNIT  (USER12 USER22)\n       (6) UNIT  372\n       (7) UNIT  B0   ---> ALL DEVICES ON CHANNEL B, CONTROL UNIT 0\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNITS": {"ttr": 37129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x13?\\x00\\x94\\x13?\\x10P\\x01i\\x01i\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-13T00:00:00", "modifydate": "1994-05-13T10:50:00", "lines": 361, "newlines": 361, "modlines": 0, "user": "SYSPAJA"}, "text": "UNTS     TITLE 'U N I T S  - TSO COMMAND.'                         -EU-\nUNITS    START 0                                                   -EU-\n         SPACE 1                                                   -EU-\nUNITS   AMODE  24                                                  -EU-\nUNITS   RMODE  24                                                  -EU-\n         SPACE 1                                                   -EU-\n        $DEFREG ,                                                  -EU-\n         SPACE 1                                                   -EU-\nLV0      EQU   0         AUTHORITY LEVEL DEFINITION : REJECT LEVEL.-EU-\n        $MDL@IX ,        MODULE INDEX.                             -EU-\n         EJECT\n*          DATA-SET CBT910 AT LEVEL 002 AS OF 09/21/83\n*          EXTRACTED FROM CBT TAPE 86 FEB, FILE 127 (TSDYNLXA).    -EU-\n         SPACE 1                                                   -EU-\n***********************************************************************\n***********************************************************************\n*******             C. B. T.         8/83               LMB-CBT *******\n*******                                                         *******\n*******  UPDATED WITH UCB CODING CONVENTIONS FOR X-A        CBT *******\n*******  THIS CODE SHOULD RUN UNDER MVS SP AND X-A          CBT *******\n*******                                                     CBT *******\n*******  CONVERTED TO RUN UN-AUTHORIZED                     CJH *******\n*******  THIS MODULE HAS BEEN CONVERTED TO PUTLINE/GETLINE  CBT *******\n*******                                                         *******\n***********************************************************************\n***********************************************************************\n         SPACE 1                                                   -EU-\n*        ADAPTED BY : MOINIL P.A.                                  -EU-\n*                     COMPUTING CENTRE (TP 361)                    -EU-\n*                     J.R.C. - ISPRA ESTABLISHMENT                 -EU-\n*                     21020 ISPRA (VA), ITALY                      -EU-\n         SPACE 1                                                   -EU-\nNTBL     EQU   200                 'NAMETAB' ELEMENTS NUMBER       -EU-\n         SPACE 1                                                   -EU-\n*        ----------------------------------------------------\n*        DSECT IEFZB421 SHOULD BE SUBSTITUTED WHEN AVAILABLE.\n*        ----------------------------------------------------\n         SPACE 1\nEDTLUVSP EQU   28,4           POINTER TO LOOK UP VALUE SECTION\nLUVENTNO EQU   8,4            NUMBER OF ENTRIES IN THIS SECTION\nLUVENTRY EQU   16,32          TABLE OF LOOK UP ENTRIES\nLUVUNAME EQU   0,8            UNIT NAME IN EBCDIC\n         EJECT\n        $XENT  BASE=R12,LV=LDYNAMIC,TYPE=RENT                      -EU-\n         LR    R10,R13                                             -EU-\n         USING DYNMAREA,R10\n         MVC   ESTLIST(ESTLEN),ESTSKEL  SET ESTAE LIST             -EU-\n         MVC   MYESCTR,=PL3'1024'  SET LOOP PROTECTION VALUE       -EU-\n         LA    R2,NAMETAB          CLEAR NAME TABLE TO BLANKS      -EU-\n         L     R3,=A((NTBL+1)*L'NAMETAB)                           -EU-\n         LA    R4,*                                                -EU-\n         XR    R5,R5                                               -EU-\n         ICM   R5,B'1000',=CL8' '                                  -EU-\n         MVCL  R2,R4                                               -EU-\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE,                   -EU-X\n               GET=GETLNE,REL=RELGIB                               -EU-\n         XC    USREQAUT(USRQAUTL),USREQAUT                         -EU-\n         MVC   USREQAUT+1(3),=AL3(MDL@IX)                          -EU-\n         LA    R1,USRQA                                            -EU-\n         ST    R1,USREQAUT+4                                       -EU-\n        $EACM  USREQAUT                                            -EU-\n         CLI   USRQA,LV0           AUTHORIZED?                     -EU-\n         BE    NOTAUT              NO, REJECT                      -EU-\n        $TEW$PP PARM=PARMLST,REG=R3,ATT=SETRC                      -EU-\n         MVI   MSGTXT,C' '\n         MVC   MSGTXT+1(L'MSGTXT-1),MSGTXT\n        $TSWXA 31,EXPAND=ONLY      ENTER 31-BIT MODE               -EU-\n         L     R1,CVTPTR           CVT ADDRESS\n         USING CVTMAP,R1           ADDRESS TO DSECT\n         L     R1,CVTJESCT         JES CONTROL TABLE\n         DROP  R1\n         USING JESCT,R1            ADDRESS TO DSECT\n         L     R15,JESCTEXT             EXTENSION\n         L     R15,JESGB4UV-JESPEXT(R15)     ADDR OF IEFGB4UV\n         ST    R15,DSAGB4UV\n         L     R1,JESEDT           EDT\n         DROP  R1\n         L     R6,EDTLUVSP(,R1)    LOOK-UP SECTION\n         L     R0,LUVENTNO(,R6)    # OF UNIT NAMES\n         CL    R0,=A(NTBL)         TABLE LARGE ENOUGH?             -EU-\n         BH    TBSMALL             NO                              -EU-\n         LA    R8,L'LUVENTRY       LENGTH OF ENTRY\n         LA    R15,LUVENTRY(,R6)   FIRST ENTRY\n         LA    R1,NAMETAB\nTABLSCAN MVC   0(8,R1),LUVUNAME(R15)\n         MVI   8(R1),C' '\n         LA    R1,L'NAMETAB(R1)    INCREMENT OUTPUT STAK\n         ALR   R15,R8              INCREMENT NAME TABLE POINTER\n         BCT   R0,TABLSCAN\n         CLI   NAMEKW+1,1          'NAMES' SPECIFIED?              -EU-\n         BNE   GET                 NO                              -EU-\n         DROP  R3                                                  -EU-\nREPEAT   LA    R2,NAMETAB          AXC NAME\nNAMESOUT MVC   MSGTXT(8*L'NAMETAB),0(R2)     MOVE OUT 8 NAMES\n         BAS   R4,TPTLIT           GO PRINT IT OUT                 -EU-\n         LA    R2,8*L'NAMETAB(R2)\n         CLI   0(R2),C' '\n         BNE   NAMESOUT\nGET      MVC   MSGTXT(L'MSGENTER),MSGENTER\n         LA    R0,L'MSGENTER\n         BAS   R4,TPTLIT+L'TPTLIT                                  -EU-\n         BAS   R14,GETLNE                                          -EU-\n         B     *+L'*(R15)          HOW COMPLETE?                   -EU-\n         B     *+L'*+8             +0 - OK                         -EU-\n         B     TGETNO              +4 - NONE                       -EU-\n         B     LEAVE+L'LEAVE       +8 - ERROR                      -EU-\n         L     R7,#TSIBSP+4        POINT TO INPUT DATA END         -EU-\n         L     R2,#TSIBSP+8        POINT TO INPUT DATA START       -EU-\n         SLR   R7,R2                                               -EU-\n         CH    R7,=H'7'                                            -EU-\n         BNH   ACCEPT                                              -EU-\n         BAS   R14,RELGIB          RELEASE INPUT BUFFER            -EU-\n         MVC   MSGTXT(8),0(R2)                                     -EU-\n         MVC   MSGTXT+9(28),=CL28'... INPUT TOO LONG - REENTER'    -EU-\n         BAS   R4,TPTLIT                                           -EU-\n         B     GET                                                 -EU-\nTGETNO   BAS   R14,RELGIB          RELEASE INPUT BUFFER            -EU-\n         B     GET                 AGAIN                           -EU-\n         OC    UNITNAME(*-*),0(R2) <<EXECUTED>>                    -EU-\nACCEPT   MVC   UNITNAME,=CL8' '                                    -EU-\n         EX    R7,ACCEPT-6         MOVE WITH UPPER-CASE            -EU-\n         BAS   R14,RELGIB          RELEASE INPUT BUFFER            -EU-\n         CLC   UNITNAME,=CL8'END'                                  -EU-\n         BE    EODAD\n         CLC   UNITNAME,=CL8'NAMES'     THE ABILITY TO REPEAT AXC  -EU-\n         BE    REPEAT              THE ABILITY TO REPEAT AXC\n         MVC   MSGTXT(L'UNITNAME),UNITNAME                         -EU-\n         SPACE 1                                                   -EU-\n*------- CHECK THAT THE CLASS NAME ENTERED IS VALID. THIS IS DONE\n*        BY COMPARING THE NAME (GENERIC OR ESOTERIC) AGAINST THE\n*        CLASS NAMES IN THE EDT LOOK UP SECTION.\n         SPACE 1                                                   -EU-\n         L     R0,LUVENTNO(,R6)    # CLASS TYPES IN EDT\n         LA    R8,L'LUVENTRY       LENGTH OF ENTRY\n         LA    R15,LUVENTRY(,R6)   1ST ENTRY\nNAMESCAN CLC   UNITNAME(L'UNITNAME),LUVUNAME(R15)\n         BE    HAVENAME\n         ALR   R15,R8              GET NEXT ENTRY\n         BCT   R0,NAMESCAN\n         MVC   MSGTXT+10(20),=CL20': INVALID CLASS NAME'           -EU-\n         BAS   R4,TPTLIT                                           -EU-\n         B     GET\n         SPACE 1                                                   -EU-\n*------- THE DEVICE NAME ENTERED IS VALID (IT WAS FOUND AGAIN IN\n*        THE EDT LOOKUP SECTION). MOVE UNITNAME TO KEY 0 STORAGE\n*        AND INVOKE IEFAB4UV TO RETURN ASSOCIATED UCB ADDRESSES.\n*        R0, R1, R2, R7, R8, R14 CAN BE REUSED NOW.\n         SPACE 1                                                   -EU-\nHAVENAME GETMAIN R,LV=LKEY0SP,SP=0      FOR KEY 0 SUBPOOL STORAGE  -EU-\n         ST   R1,KEY0ADDR          SAVE KEY 0 GETMAIN'D AREA PTR\n         LR   R7,R1                PTR TO KEY 0 STORAGE\n         USING KEY0SP,R7           ADDR TO DSECT\n         SPACE 1                                                   -EU-\n*------- SET UP PARAMETER LIST FOR KEY 0 STORAGE FOR IEFAB4UV.\n         SPACE 1                                                   -EU-\n         XC   KEY0SP(LKEY0SP),KEY0SP                               -EU-\n         LA   R1,UNITABLE\n         ST   R1,UTBLPTR\n         LA   R1,FLAGS\n         ST   R1,FLAGPTR\n         MVC  UNAME(L'UNAME),UNITNAME\n         MVC  FLAGS,=XL2'1000'     BIT 3 SET FOR UCB SEARCH\n         ESTAE MYESTAE,CT,PARAM=(R10),MF=(E,ESTLIST)               -EU-\n         LA   R1,PARMLIST\n         L     R15,DSAGB4UV\n         BASR  R14,R15\n         ST    R15,DSAGB4RC        SAVE RC\n         ESTAE 0\n         MVC  UCBLIST,UCBPTR       SAVE PTR TO UCB LIST\n         DROP  R7                  FROM KEY 0 PARM DSECT\n         SPACE 1                                                   -EU-\n*------- KEY 0 STORAGE CAN NOW BE FREED, THEN PROCESS THE UCB LIST.\n         SPACE 1                                                   -EU-\n         L    R1,KEY0ADDR\n         FREEMAIN R,A=(1),LV=LKEY0SP,SP=0\n         L     R15,DSAGB4RC        RESTORE RC\n         LTR  R15,R15              HAVE UCBS BEEN RETURNED?\n         BZ   GOTUCBS              UCBS RETURNED GO LOOK AT THEM\n         CH   R15,=H'4'            R15 = 4\n         BE   NONAME               SAY CLASS NAME NOT FOUND\n         CH   R15,=H'16'           R15 = 16\n         BE   NOSTORGE             NO STORAGE AVAIL FOR UCB LIST\n         B    ABENDIT              ABEND ALL OTHER RETURN CODES\nNONAME   MVC   MSGTXT+10(30),=CL30': CLASS NAME NOT FOUND - RETRY'\n         BAS   R4,TPTLIT                                           -EU-\n         B     GET\n         SPACE 1                                                   -EU-\n*------- UCBS RETURNED IN SUBPOOL 0 STORAGE.\n         SPACE 1                                                   -EU-\nGOTUCBS  ICM   R9,B'1111',UCBLIST  PTR TO UCB LIST?                -EU-\n         BZ    NOTUCBLS            NOT UCB LIST SEND MSG\n         MVC   LISTLEN,0(R9)       HOLD SUBPOOL & LEN OF LIST\n         L     R7,4(R9)            NUMBER OF UCBS IN LIST\n         LA    R9,8(R9)            ADDRESS OF 1ST UCB PTR\n         L     R15,0(R9)           FIRST UCB PTR\n         USING UCBOB,R15\n         LA    R4,MSGTXT+10                                        -EU-\n         LA    R5,4                                                -EU-\nGETUCB   MVC   0(L'UCBNAME,R4),UCBNAME                             -EU-\n         TM    UCBDVCLS,UCB3DACC   DIRECT ACCESS?\n         BZ    NOTDA               NO\n         TM    UCBSTAT,UCBONLI     ONLINE?\n         BZ    NOTONL              NO\n         CLI   UCBVOLI,X'00'       YES, VOLID KNOWN?\n         BE    NOTDA               NO\n         MVI   4(R4),C'-'                                          -EU-\n         MVC   6(L'UCBVOLI,R4),UCBVOLI                             -EU-\n         B     NOTDA\n         DROP  R15\nNOTONL   MVI   4(R4),C'-'                                          -EU-\n         MVC   6(7,R4),=CL7'OFFLINE'                               -EU-\nNOTDA    LA    R4,16(R4)                                           -EU-\n         BCT   R5,TSUCBS                                           -EU-\n         BAS   R4,TPTLIT                                           -EU-\n         LA    R4,MSGTXT+10                                        -EU-\n         LA    R5,4                                                -EU-\nTSUCBS   BCT   R7,*+L'*+4                                          -EU-\n         B     LSUCBS                                              -EU-\n         LA    R9,4(,R9)\n         L     R15,0(R9)\n         B     GETUCB\nLSUCBS   CLI   MSGTXT+10,C' '                                      -EU-\n         BE    *+L'*+4                                             -EU-\n         BAS   R4,TPTLIT                                           -EU-\n         SPACE 1                                                   -EU-\n*------- NOW FREE THE UCB LIST SUBPOOL 0 STORAGE.                  -EU-\n         SPACE 1                                                   -EU-\n         L     R0,LISTLEN          SUBPOOL 0 + LEN OF STORAGE      -EU-\n         N     R0,FSP0             FORCE SUBPOOL 0                 -EU-\n         L     R1,UCBLIST          PTR TO GETMAIN'D AREA           -EU-\n         FREEMAIN R,A=(1),LV=(0)   FREEMAIN OF SUBPOOL 0           -EU-\n         B     GET\n         SPACE 1                                                   -EU-\nTPTLIT   LA    R0,L'MSGTXT         PRINT MESSAGE ROUTINE           -EU-\n         LA    R1,MSGTXT                                           -EU-\n         BAS   R14,PUTLNE                                          -EU-\n         B     *+L'*(R15)          HOW COMPLETE?                   -EU-\n         B     *+L'*+4             +0 - OK                         -EU-\n         B     LEAVE+L'LEAVE       +4 - ERROR                      -EU-\n         MVI   MSGTXT,C' '                                         -EU-\n         MVC   MSGTXT+1(L'MSGTXT-1),MSGTXT                         -EU-\n         BR    R4                  BACK TO CONTINUE PROCESSING     -EU-\n         SPACE 1\nNOTAUT   LA    R0,L'NAUTM                                          -EU-\n         LA    R1,NAUTM                                            -EU-\n         BAS   R4,PUTLNE                                           -EU-\nSETRC    LA    R2,16               RC=16 ------------------------- -EU-\n         B     USEXIT                                              -EU-\nTBSMALL  LA    R0,L'MTBSM                                          -EU-\n         LA    R1,MTBSM                                            -EU-\n         B     LEAVE                                               -EU-\nNOSTORGE MVC   MSGTXT+10(35),=CL35': NO STORAGE AVAILABLE FOR UCB LIST'\n         B     LEAVE                                               -EU-\nNOTUCBLS MVC   MSGTXT+10(29),=CL29': UCB LIST NOT BEING SEARCHED'\n         B     LEAVE                                               -EU-\nABENDIT  MVC   MSGTXT+10(10),=CL10': ABEND IT'\nLEAVE    BAS   R4,PUTLNE                                           -EU-\n         LA    R2,16               RC=16 ------------------------- -EU-\n         B     EODAD+L'EODAD                                       -EU-\nEODAD    XR    R2,R2               RC=0 -------------------------- -EU-\n        $TSWXA 24,EXPAND=ONLY      BACK 24-BIT MODE                -EU-\nUSEXIT  $XRET  CC=(R2),LV=LDYNAMIC,TYPE=RENT                       -EU-\n         SPACE 1                                                   -EU-\n         LTORG\n         SPACE 1\n         DROP  R10,R12                                             -EU-\n         EJECT ,                                                   -EU-\nFSP0     DC    0F'0',X'00FFFFFF'   FORCE SUBPOOL 0                 -EU-\nESTSKEL  ESTAE *-*,MF=L                                            -EU-\nESTLEN   EQU   *-ESTSKEL                                           -EU-\n         SPACE 1                                                   -EU-\nNAUTM    DC    C'UNAUTHORIZED COMMAND - REJECTED.'                 -EU-\nMTBSM    DC    C'NOT ENOUGH STORAGE FOR NAMES TABLE.'              -EU-\nMSGENTER DC    C'ENTER DESIRED GROUP NAME, \"NAMES\" OR \"END\"'       -EU-\n         EJECT ,                                                   -EU-\n         USING MYESTAE,R15\n         CNOP  0,4                                                 -EU-\n         USING SDWA,R1\nMYESTAE  CH    R0,=H'12'           Q/SDWA\n         BE    MYESQUIT            N/GET OUT\n         L     R10,SDWAPARM                                        -EU-\n         USING DYNMAREA,R10                                        -EU-\n         SP    MYESCTR,=P'1'       LOOP FAILSAFE\n         DROP  R10                                                 -EU-\n         BZ    MYESQUIT\n         CLC   =X'0C2000',SDWACMPC PRIV OP INTERRUPT?\n         BNE   MYESGFF             YES, SKIP IT\n         L     R0,SDWANXT1         NEW INSTR AFTER PRIVOP\n         B     MYESRTRY\nMYESGFF  CLC   =X'B78000',SDWACMPC GETMAIN/FREEMAIN FAIL\n         BNE   MYESQUIT\n         ICM   R0,B'1111',SDWASRSV+15*4 GET ORIG R15\n         N     R0,=X'FFFF00FF'     SET SUBPOOL TO ZERO\n         STCM  R0,B'1111',SDWASRSV+15*4 NEW R15\n         L     R0,SDWANXT2\n         SH    R0,=H'2'            BACKUP\nMYESRTRY SETRP RC=4,RETADDR=(R0),FRESDWA=YES,DUMP=NO,RETREGS=YES\n         BR    R14\nMYESQUIT SETRP RC=0,FRESDWA=NO,DUMP=YES\n         BR    R14\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R1,R15                                              -EU-\n         EJECT ,                                                   -EU-\n*------- PARSE PCL.                                                -EU-\n         SPACE 1                                                   -EU-\n         PRINT NOGEN                                               -EU-\nPARMLST  IKJPARM ,                                                 -EU-\nNAMEKW   IKJKEYWD ,                                                -EU-\n         IKJNAME 'NAMES'                                           -EU-\n         IKJENDP ,                                                 -EU-\n         PRINT GEN                                                 -EU-\n         EJECT ,                                                   -EU-\n*------- DSECT'S.\n         SPACE 1\nDYNMAREA DSECT\n         DS    18F                 SAVE AREA\nESTLIST  ESTAE *-*,MF=L                                            -EU-\nDSAGB4UV DS    F                   EP OF IEFGB4UV\nDSAGB4RC DS    F                   RC OF IEFGB4UV\nKEY0ADDR DS    F\nLISTLEN  DS    F                   SUBPOOL & LENGTH OF LIST\nUCBLIST  DS    F                   PTR TO UCB LIST\n        $TEW$WA ,                                                  -EU-\nMSGTXT   DS    CL80                                                -EU-\nUSREQAUT DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)            -EU-\nUSRQA    DC    XL1'0'                                              -EU-\nUSRQAUTL EQU   *-USREQAUT                                          -EU-\nMYESCTR  DS    PL3                 LOOP PROTECTION COUNTER         -EU-\nUNITNAME DS    CL8,CL1                                             -EU-\nNAMETAB  DS    (NTBL+1)CL9                                         -EU-\n         SPACE 1                                                   -EU-\nLDYNAMIC EQU   (((*-DYNMAREA)+7)/8)*8   SIZE OF DYNAMIC AREA       -EU-\n         SPACE 1                                                   -EU-\n*------- DSECT FOR KEY 0 SUBPOOL GETMAIN'D STORAGE.\n         SPACE 1\nKEY0SP   DSECT                     GETMAIN DSECT FOR KEY 0 SUBPOOL\nPARMLIST DS    2F                  PARMLIST MAPPING\n         ORG   PARMLIST\nUTBLPTR  DS    F                   ADDRESS OF THE UNIT TABLE\nFLAGPTR  DS    F                   ADDRESS OF THE FUNCTION REQUEST\n         DS    0F\nUNITABLE DS    CL20\n         ORG   UNITABLE\nUNAME    DS    CL8\nUCBPTR   DS    F\n         DS    F\n         DS    F\nFLAGS    DS    XL2\n         SPACE 1                                                   -EU-\nLKEY0SP  EQU   (((*-KEY0SP)+7)/8)*8                                -EU-\n         SPACE 1                                                   -EU-\n         PRINT NOGEN                                               -EU-\n        $TEW$DS ,                                                  -EU-\n         IEFUCBOB ,\n         IEFJESCT ,\n         IHASDWA ,\n         PRINT GEN                                                 -EU-\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNITS$": {"ttr": 37136, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//UNITS    JOB (........),'INSTALL  - UNITS -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=UNITS\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   UNITS\n  NAME    UNITS(R)\n/*\n//HLP     EXEC PAJHELP,MBR=UNITSH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNITS@": {"ttr": 37138, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12o\\x00\\x88\\x12o\\x12W\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-05T00:00:00", "modifydate": "1988-05-05T12:57:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SYSPAJA"}, "text": "1   29/09/86\n                                                      UNITS     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         DISPLAY UNIT NAMES.         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT 84 JUN, file 300, and from CBT 86\n  ------------ FEB, file 127 (TSDYNLXA).\n\n  Purpose :   Displays the unit names in the device name table, and\n  ---------   the channel-unit-addresses associated with each unit\n              name.\n\n  Authority : This command is restricted to systems support personnel.\n  -----------\n\n  Syntax :    UNITS NAMES\n  --------    Required : none.\n              Default  : full unit names list.\n              ALIAS    : none.\n\n  Operands :  NAMES - use this keyword to obtain a shortened list.\n  ----------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNITSH": {"ttr": 37140, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=UNITS\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : DISPLAYS THE UNIT NAMES IN THE DEVICE NAME TABLE, AND\n              THE CHANNEL-UNIT-ADDRESSES ASSOCIATED WITH EACH UNIT\n              NAME. THIS COMMAND IS RESTRICTED TO SYSTEMS SUPPORT\n              PERSONNEL.\n)X SYNTAX :   UNITS NAMES\n              REQUIRED : NONE.\n              DEFAULT  : FULL UNIT NAMES LIST.\n              ALIAS    : NONE.\n)O OPERANDS :\n))NAMES :     USE THIS KEYWORD TO OBTAIN A SHORTENED LIST.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UPDTMACS": {"ttr": 37377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"o\\x00\\x91\"o\\x14D\\x00\\xc0\\x00\\xc0\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-14T00:00:00", "modifydate": "1991-08-14T14:44:00", "lines": 192, "newlines": 192, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM)\n/* * --- DELETE FROM HERE ****************************************** */\n/* * YOU MUST ADJUST THE \"PASSWORD\" (REPLACE IT BY YOUR OWN)       * */\n/* * DEFINED HERE BELOW BEFORE YOU MAY EXECUTE THIS PROCEDURE.     * */\n/* * THEN, DELETE ALL INDICATED STATEMENTS, GOOD LUCK.             * */\n/* ***************************************************************** */\nWRITE *** MANDATORY - ISPF CLIST \"UPDTMACS\" INTERVENTION REQUIRED ***\nEXIT\n/* * --- UP TO HERE WHEN ADJUSTMENT IS DONE ************************ */\n/*  MACRO NAME : UPDTMACS                             (MOINIL P.A.) */\n/*    FUNCTION : CREATE-UPDATE-DISPLAY AVAILABLE ADDITIONAL LOCAL   */\n/*               EDIT MACROS TABLE.                                 */\n/*      SYNTAX : UPDTMACS                                           */\n/*       DEBUG : UPDTMACS LIST                                      */\n  IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST SYMLIST CONLIST\n  ISPEXEC DISPLAY PANEL(PAJEMP)\n  IF &EMPASS \u00ac= PASSWORD THEN DO\n    SET &ZEDSMSG = UPDATE REJECT\n    SET &ZEDLMSG = SORRY ... YOU MAY NOT UPDATE THE TABLE\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  SET &EMPASS =\nSTART: +\n  ISPEXEC CONTROL ERRORS RETURN\n  ISPEXEC TBOPEN EDITMACS WRITE\n  SET &EMRCC = &LASTCC\n  IF &EMRCC = 12 THEN DO\n    SET &ZEDSMSG = TABLE IN USE\n    SET &ZEDLMSG = ENQ FAILED DUE TO TABLE IN USE BY ANOTHER USER OR +\n                   CURRENT USER\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  IF &EMRCC = 16 OR &EMRCC = 20 THEN DO\n    SET &ZEDSMSG = TBOPEN ERROR\n    SET &ZEDLMSG = TBOPEN RETURN CODE &EMRCC ... ABORT\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  IF &EMRCC = 8 THEN DO\n    SET &MACNAME = CREATE\n    SET &MACDESC = THE TABLE \"EDITMACS\" DOES NOT EXIST BUT +\n                   WE WILL MAKE ONE\n    ISPEXEC TBCREATE EDITMACS NAMES(MACNAME MACDESC) WRITE\n    SET &EMTRC = &LASTCC\n    IF &EMTRC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = TBCREATE ERROR\n      SET &ZEDLMSG = TBCREATE RETURN CODE &EMTRC ... ABORT\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    ISPEXEC TBADD EDITMACS\n    SET &EMTRC = &LASTCC\n    IF &EMTRC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = TBADD ERROR\n      SET &ZEDLMSG = TBADD RETURN CODE &EMTRC ... ABORT\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    SET &EMUPDT = YES\n    END\n  ELSE SET &EMUPDT = NO\nSORT: +\n  ISPEXEC TBSORT EDITMACS FIELDS(MACNAME)\n  SET &EMTRC = &LASTCC\n  IF &EMTRC \u00ac= 0 THEN DO\n    SET &ZEDSMSG = TBSORT ERROR\n    SET &ZEDLMSG = TBSORT RETURN CODE &EMTRC ... ABORT\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  SET &EMSORT = NO\nNORMAL: +\n  ISPEXEC TBDISPL EDITMACS PANEL(PAJEMU) POSITION(EMCRP)\n  SET &EMTRC = &LASTCC\n  IF &EMTRC = 8 THEN GOTO LEAVE\n  IF &EMTRC = 12 OR &EMTRC = 20 THEN DO\n    SET &ZEDSMSG = TBDISPL ERROR\n    SET &ZEDLMSG = TBDISPL RETURN CODE &EMTRC ... ABORT\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(0)\n    END\n  IF &ZCMD = CANCEL THEN GOTO QUIT\n  IF &ZTDSELS = 0 THEN GOTO NORMAL\n  IF &EMOPTN = S THEN DO\n    ISREDIT &MACNAME HELP\n    SET &EMTRC = &LASTCC\n    IF &EMTRC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = HELP ERROR\n      SET &ZEDLMSG = DISPLAY HELP HAS GIVEN BACK A &EMTRC RETURN CODE\n      ISPEXEC SETMSG MSG(ISRZ000)\n      END\n    END\n  ELSE IF &EMOPTN = A OR &EMOPTN = R THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    IF &EMOPTN = A THEN DO\n      SET &MACNAME =\n      SET &MACDESC =\n      END\n    ISPEXEC DISPLAY PANEL(PAJEMA)\n    ISPEXEC TBADD EDITMACS\n    SET &EMTRC = &LASTCC\n    ISPEXEC CONTROL DISPLAY RESTORE\n    IF &EMTRC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = TBADD ERROR\n      SET &ZEDLMSG = TBADD RETURN CODE &EMTRC ... ABORT\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    SET &EMSORT = YES\n    END\n  ELSE IF &EMOPTN = D THEN DO\n    ISPEXEC TBDELETE EDITMACS\n    SET &EMTRC = &LASTCC\n    IF &EMTRC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = TBDELETE ERROR\n      SET &ZEDLMSG = TBDELETE RETURN CODE &EMTRC ... ABORT\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    SET &EMSORT = YES\n    END\n  ELSE IF &EMOPTN = U THEN DO\n    ISPEXEC CONTROL DISPLAY SAVE\n    ISPEXEC DISPLAY PANEL(PAJEMA)\n    ISPEXEC TBPUT EDITMACS\n    SET &EMTRC = &LASTCC\n    ISPEXEC CONTROL DISPLAY RESTORE\n    IF &EMTRC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = TBPUT ERROR\n      SET &ZEDLMSG = TBPUT RETURN CODE &EMTRC ... ABORT\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    END\n  ELSE DO\n    SET &ZEDSMSG = INVALID OPTION\n    SET &ZEDLMSG = VALID OPTIONS ARE \"A\", \"D\", \"R\", \"S\" OR \"U\"\n    ISPEXEC SETMSG MSG(ISRZ000)\n    END\n  IF &EMSORT = NO THEN GOTO NORMAL\n  SET &EMUPDT = YES\n  GOTO SORT\nLEAVE: +\n  IF &EMUPDT = YES THEN DO\n    ISPEXEC TBSORT EDITMACS FIELDS(MACNAME)\n    SET &EMTRC = &LASTCC\n    IF &EMTRC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = TBSORT ERROR\n      SET &ZEDLMSG = TBSORT RETURN CODE &EMTRC ... ABORT\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(0)\n      END\n    ISPEXEC TBCLOSE EDITMACS REPLCOPY PAD(15)\n    SET &EMTRC = &LASTCC\n    IF &EMTRC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = TBCLOSE ERROR\n      SET &ZEDLMSG = TBCLOSE RETURN CODE &EMTRC ... ABORT\n      END\n    ELSE DO\n      SET &ZEDSMSG = UPDATES SAVED\n      SET &ZEDLMSG = EVERYTHING ENDS NORMALLY AND UPDATES ARE SAVED\n      END\n    END\n  ELSE DO\n    ISPEXEC TBEND EDITMACS\n    SET &EMTRC = &LASTCC\n    IF &EMTRC \u00ac= 0 THEN DO\n      SET &ZEDSMSG = TBEND ERROR\n      SET &ZEDLMSG = TBEND RETURN CODE &EMTRC ... ABORT BUT NO UPDATES\n      END\n    ELSE DO\n      SET &ZEDSMSG = NONE DONE\n      SET &ZEDLMSG = ENDED NORMALLY BUT NO UPDATES WERE ENTERED\n      END\n    END\n  ISPEXEC SETMSG MSG(ISRZ000)\n  EXIT CODE(0)\nQUIT: +\n  ISPEXEC TBEND EDITMACS\n  SET &EMTRC = &LASTCC\n  IF &EMTRC \u00ac= 0 THEN DO\n    SET &ZEDSMSG = TBEND ERROR\n    SET &ZEDLMSG = TBEND RETURN CODE &EMTRC ... ABORT\n    END\n  ELSE DO\n    SET &ZEDSMSG = CANCEL DONE\n    SET &ZEDLMSG = IMMEDIATE STOP AND UPDATES ARE NOT SAVED\n    END\n  ISPEXEC SETMSG MSG(ISRZ000)\n  EXIT CODE(12)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USERS": {"ttr": 37381, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943_\\x00\\x943_\\t\\x17\\x01d\\x01d\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-01T00:00:00", "modifydate": "1994-12-01T09:17:00", "lines": 356, "newlines": 356, "modlines": 0, "user": "SYSPAJA"}, "text": "AS25     TITLE 'PGM TO SHOW TSO USERS-ASID/UNIT ADDR'              -EU-\nTSO025AS START 0                                                   -EU-\n         SPACE 1                                                   -EU-\n*        DATA SET TSO025AS   AT LEVEL 001 AS OF 07/06/77\n*        DATA SET TSO025SU   AT LEVEL 001 AS OF 03/09/77\n*        DATA SET TSO025SU   AT LEVEL 001 AS OF 02/12/77\n*\n* THIS IS THE SHOWTSO COMMAND FOR TSO (MOD FOR SUPV I & II S. U.).\n* IT PEEKS AT ASCBS TO FIND TSO USERS AND FORMATS A DISPLAY OF\n*        USERIDS/SWAP STATUS/ASID AND TERMINAL UNIT.\n* THIS PGM IS NON-PRIVILEGED, REQUIRES MACROS FROM SYS1.MODGEN\n*\n* KEN TRUE, FAIRCHILD CAMERA AND INSTRUMENT                15DEC76\n*\n* MODIFIED TO OPERATE AS OPER STC OR TSO COMMAND  K. TRUE  27MAY77\n*\n* MODIFIED TO OPERATE FOR MVS/SP 1.3 BY C. DAOLIO          27APR83 -EU-\n* MODIFIED TO OPERATE FOR MVS/XA 2.1 BY MOINIL P.A.        06AUG86 -EU-\n* MODIFIED TO OPERATE WITH \"PUTLINE\" BY MOINIL P.A.        13APR94 -EU-\n         SPACE 1                                                   -EU-\n* CBT ORIGIN : EXTRACTED FROM FILE 352.                            -EU-\n         SPACE 1                                                   -EU-\nTSO025AS AMODE 24                                                  -EU-\nTSO025AS RMODE 24                                                  -EU-\n         EJECT ,                                                   -EU-\n        $DEFREG ,                                                  -EU-\n        $XENT  BASE=R12,LV=AREAL,TYPE=RENT                         -EU-\n         LR    R11,R13                                             -EU-\n         USING AREA,R11                                            -EU-\n         LR    R2,R1               GET ENTRY REGISTER              -EU-\n        $TSWXA 31,EXPAND=ONLY                                      -EU-\n         MVI   BUFFER,C' '         CLEAR OUT BUFFER\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   MSGTSU(27),=CL27'..XXXXXX TIME SHARING USERS'       -EU-\n        $TEW$EC REG=R2,MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE             -EU-\n         XR    R3,R3               COUNTER FOR # TSO USERS\n         LA    R2,BUFFER           BUFFER ADDRESS\n         L     R7,CVTPTR           (R7)=ADDR CVT\n         USING CVTMAP,R7                                           -EU-\n         L     R9,CVTOPCTP         (R9) =ADDR (SRM'S RMCT)\n         ST    R9,RMCTPTR            WHICH IS SAVED FOR LATER\n         L     R9,CVTASVT          (R9)= ADDR ASVT\n         DROP  R7\n         USING ASVT,R9\n         L     R5,ASVTMAXU         (R5)=MAX NUMB OF ASCB ENTRIES\n         LA    R5,2(R5)              +2 SO WE CAN SCAN ENTIRE ASVT..\n         LA    R9,ASVTFRST-4       (R9)= ASVT ENTRY ADDRESS - 4\n         USING ASCB,R8\n         USING CSCB,R10\n         DROP  R9\n         USING OVERLAY,R2          MAPPING...\n         LA    R0,L'HEADING\n         LA    R1,HEADING\n         BAS   R14,PUTLNE          SHOVEL OUT THE LINE\n         B     *+L'*(R15)          HOW COMPLETE?                   -EU-\n         B     NEXTONE             +0 - GO GET ASCB                -EU-\n         B     SETRC               +4 - INVALID OR ERROR           -EU-\n         SPACE 1\n*------- LOOP THROUGH ALL ASCBS\n         SPACE 1\nLOOP     L     R10,ASCBCSCB        LOAD CSCB ADDR\n         L     R7,ASCBTSB          LOAD TSB ADDR\n         LTR   R7,R7               ANYBODY HOME?\n         BZ    NEXTONE             NO NOT TP USER\n         OI    SWITCH,OUTEX        OUTPUT EXISTS..\n         CLC   CHPARM,=CL8' '      ANYBODY REALLY HOME?\n         BNE   MOVEIT              YEP-> GO MOVE EM IN\n         MVC   USERID,=C'STARTING' NOPE-> USE DUMMY NAME\n         B     CONT#1              GO FINISH UP WITH ASID\nMOVEIT   MVC   USERID,CHKEY        MOVE IN USERID\nCONT#1   UNPK  ASID(5),ASCBASID(3) UNPACK ASID\n         NC    ASID,=XL4'0F0F0F0F' AND\n         TR    ASID,=CL16'0123456789ABCDEF' TRANSLATE\n         MVI   ASID+4,C' '                                         -EU-\n        STAX   DEFER=YES,MF=(E,STAXLST) HOLD DEM ATTENTIONS...\n        ZEROKEY ,                                                  -EU-\n         USING TSB,R7                                              -EU-\n         UNPK  LDASH(5),TSBLINE(3) UNPACK LINE ADDR                -EU-\n         MVC   WRKD,TSBTRMID       TERMINAL SYMBOLIC NAME (VTAM)   -EU-\n         DROP  R7                                                  -EU-\n        RESETKEY ,                                                 -EU-\n        STAX   DEFER=NO,MF=(E,STAXLST) LET ATTENTIONS HAVE FUN..\n         NC    UNIT,=XL4'0F0F0F0F'\n         OC    UNIT(L'UNIT),UNIT   LINE ADDR ?                     -EU-\n         BZ    SETID               NONE                            -EU-\n         TR    UNIT,=CL16'0123456789ABCDEF' TRANSLATE\n         MVI   LDASH,C' '\n         MVC   RDASH(L'RDASH),=CL8' '                              -EU-\n         B     SETID+L'SETID                                       -EU-\nSETID    MVC   TERMID,WRKD         SET TERMINAL ID                 -EU-\n         BAS   R6,COMPTIME         GO GET STEP TIME/CPU TIME\n         A     R3,=F'1'            BUMP COUNT\n         LA    R0,L'BUFFER\n         LA    R1,BUFFER\n         BAS   R14,PUTLNE          SHOVEL OUT THE LINE\n         B     *+L'*(R15)          HOW COMPLETE?                   -EU-\n         B     *+L'*+4             +0 - CONTINUE                   -EU-\n         B     SETRC               +4 - INVALID OR ERROR           -EU-\n         MVI   BUFFER,C' '         CLEAR IT OUT\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\nNEXTONE  BCT   R5,DOIT             CHECK COUNT\n         B     CLEANUP             NO MORE..\nDOIT     LA    R9,4(0,R9)          INCR INTO ASVT\n         L     R8,0(0,R9)          LOAD ASCB ADDR\n         LTR   R8,R8               END OF ASCBS?\n         BZ    CLEANUP             YES->EXIT\n         TM    0(R9),X'80'         ASID ASSIGNED?\n         BO    NEXTONE             NO-> TRY AGAIN.\n         B     LOOP                YES->SEE IF WE LIKE IT\nCLEANUP  TM    SWITCH,OUTEX        DID WE POKE ANYTHING\n         BZ    NOOUTPUT            NO..GRIPE AND SPLIT\n         CVD   R3,WRKD             CONVERT TO BIN\n         MVC   MSGUSER,=X'402020202120' MOVE IN THE PATTERN\n         ED    MSGUSER,WRKD+5      EDIT THE PATTERN\n         LA    R0,L'MSGTSU\n         LA    R1,MSGTSU\n         B     SHOWIT\nNOOUTPUT LA    R0,L'GRIPE\n         LA    R1,GRIPE\nSHOWIT   BAS   R14,PUTLNE          SHOVEL OUT THE LINE\n         B     *+L'*(R15)          HOW COMPLETE?                   -EU-\n         B     *+L'*+4             +0 - RETURN                     -EU-\n*        ...                       +4 - INVALID OR ERROR           -EU-\n         SPACE 1                                                   -EU-\n*------- EXIT TSO                                                  -EU-\n         SPACE 1                                                   -EU-\nSETRC    LA    R15,8               SET RC=8 <===================== -EU-\n        $TSWXA 24,EXPAND=ONLY                                      -EU-\n         CH    R15,=H'16'          IS RETURN CODE HIGHER THAN 16?  -EU-\n         BNH   *+L'*+2             NO, LET'S GO                    -EU-\n         XR    R15,R15             YES, ZERO OUT REGISTER 15       -EU-\n        $XRET  CC=(R15),LV=AREAL,TYPE=RENT                         -EU-\n         EJECT\n*------- LOCAL SUBROUTINE TO CALCULATE STEP TIME AND CPU TIME,\n*        AND SWAP STATUS, PAGES + WORKING SET SIZE.\n*        ENTER WITH BAS R6,COMPTIME (ALL REGISTERS PRESERVED).\n         SPACE 1\n*------- COMPUTE ELAPSED TRANSACTION TIME (STEP TIME..)\n         SPACE 1\nCOMPTIME STM    R4,R7,SAVEREGS     SAVE WORK REGISTERS\n         L     R4,RMCTPTR          POINTER TO THE RMCT.\n         L     R4,X'7C'(,R4)       PICK UP TIME OF DAY FROM RMCT. (SU)\n         L     R5,ASCBOUCB         GET ADDR OF OUCB FOR USER\n         USING OUCB,R5                                             -EU-\n         S     R4,OUCBTMO     SUBTRACT TRANSACTION START TIME.(SU) -EU-\n         DROP  R5                                                  -EU-\n         SRDL  R4,32               MOVE INTO R5 FOR DIVIDE.\n         D     R4,=F'1024'         CONVERT TO SECONDS.\n         XR    R4,R4               IGNORE REMAINDER.\n         D     R4,=F'3600'         DIVIDE TO GET HOURS.\n         CVD   R5,WRKD             CONVERT HOURS -\n         UNPK  STEPHH,WRKD+6(2)      - TO PRINTABLE FORMAT.\n         OI    STEPHH+1,X'F0'      FIXUP SIGN BYTE.\n         MVI   STEPHH+2,C':'       SEPARATOR.\n         SRDL  R4,32               MOVE REMAINDER OVER FOR DIVIDE.\n         D     R4,=F'60'           GET MINUTES.\n         CVD   R5,WRKD             CONVERT MINUTES -\n         UNPK  STEPMM(2),WRKD+6(2)   - TO PRINTABLE FORMAT.\n         OI    STEPMM+1,X'F0'      FIXUP SIGN BYTE.\n         MVI   STEPMM+2,C':'       SEPARATOR.\n         CVD   R4,WRKD             REMAINDER IS SECONDS.\n         UNPK  STEPSS(2),WRKD+6(2) CONVERT SEC TO PRINTABLE FORMAT.\n         OI    STEPSS+1,X'F0'      FIXUP SIGN.\n         SPACE 1\n*------- COMPUTE TOTAL CPU TIME USED...\n         SPACE 1\n         LM    R4,R5,ASCBEJST      LOAD ASCBEJST (CPU TASK TIME).\n         SRDL  R4,12               CONVERT TO MICRO-SECONDS.\n         LM    R6,R7,ASCBSRBT      LOAD ASCBSRBT (CPU SRB TIME).\n         SRDL  R6,12               CONVERT TO MICROSECONDS.\n         AR    R5,R7               TOTAL CPU TIME (LOW ORDER).\n         BNO   CPULBL1             BRANCH IF NO OVERFLOW ON ADD.\n         A     R4,=F'1'            OTHERWISE, ADD 1 TO HIGH ORDER.\nCPULBL1  AR    R4,R6               TOTAL CPU TIME (HIGH ORDER).\n         D     R4,=F'100'          DIVIDE TO GET SECONDS.\n         LTR   R5,R5               CHK TO SEE IF ANYTHING IS THERE\n         BNM   CPULBL2             BRANCH IF RESULT MAKES SENSE.\n         LA    R5,0                OTHERWISE, SET THE VALUE TO ZERO.\nCPULBL2  CVD   R5,WRKD             *\n         MVC   CPUTIME,=X'20202021204B2020' *\n         ED    CPUTIME-1(9),WRKD+3 *\n         SPACE 1\n*------- SWAP  REASON CODE (R8=ASCB,R7=OUCB,R4-6=WORK)\n         SPACE 1\n         L     R7,ASCBOUCB         GET ADDR OF OUCB\n         USING OUCB,R7\n         XR    R4,R4               PREPARE FOR IC INSTRUCTION.    V2M0\n         IC    R4,OUCBSRC          LOAD SU7 SWAP REASON CODE.     V2M0\n         SLL   R4,2                MULTIPLY BY FOUR FOR OFFSET    V2M0\n         LA    R4,SRCTABLE(R4)     POINT TO CORRECT ENTRY.        V2M0\n         MVC   MEMSTAT2,0(R4)      MOVE IN SWAP REASON CODE.      V2M0\n         SPACE 1\n*------- FIND  MEMORY POSITION (R8=ASCB,R7=OUCB,R4-6=WORK)\n         SPACE 1\n         MVC   MEMSTAT1,=CL2'IN'   DEFAULT POSITION IS SWAPPED-IN.V2M0\n         TM    OUCBSFL,OUCBNSW     SEE IF NON-SWAPPABLE MEMORY.   V2M0\n         BZ    QLCLBL1C            BRANCH IF NOT.\n         MVC   MEMSTAT1,=CL2'NS'   MOVE IN NON-SWAPPABLE INDIC.   V2M0\n         B     AFCSTART            FINISHED FOR THIS MEMORY.\nQLCLBL1C TM    OUCBSFL,OUCBPVL     SEE IF PRIVILEDGED STATUS.     V2M0\n         BZ    QLCLBL1             BRANCH IF NOT.\n         MVC   MEMSTAT1,=CL2'PR'   MOVE IN PRIVILEDGED INDICATION.V2M0\n*                                  BUT CONTINUE IN CASE SWAPPED-OUT.\nQLCLBL1  TM    OUCBQFL,OUCBOFF     TEST FOR WAIT QUEUE.           V2M0\n         BZ    QLCLBL2             BRANCH IF NOT.\n         MVC   MEMSTAT1,=C'WT'     INDICATE WAIT STATUS.          V2M0\n         B     AFCSTART            FINISHED FOR THIS MEMORY.      V2M0\nQLCLBL2  TM    OUCBQFL,OUCBOUT     TEST FOR OUT QUEUE.            V2M0\n         BZ    QLCLBL3             BRANCH IF NOT.\n         MVC   MEMSTAT1,=CL2'S '   INDICATE OUT STATUS.           V2M0\n         B     AFCSTART            FINISHED FOR THIS MEMORY.\nQLCLBL3  TM    OUCBQFL,X'E0'       CHECK MISCELLANEOUS BITS.      V2M0\n         BZ    AFCSTART            ASSUME MEMORY IS SWAPPED-IN.\n         MVC   MEMSTAT1,=CL2'<>'   INDICATE TRANSITIONING STATUS.\n         SPACE 1\n*------- ALLOCATED FRAME COUNT (R8=ASCB,R7=OUCB,R4-6=WORK)\n         SPACE 1\nAFCSTART LH    R4,152(,R8)         LOAD CURRENT ALLOCATED FRAME CNT.\n         C     R4,=F'999'          CHECK FOR MAXIMU EXCEEDED.\n         BNH   AFCLBL1             BRANCH IF NOT.\n         MVC   SIZE(3),=C'***'     INDICATE VALUE TOO LARGE.\n         B     WSSSTART            EXIT THIS ROUTINE.\nAFCLBL1  CVD   R4,WRKD             *\n         MVC   SIZE(3),=X'202120'  *\n         ED    SIZE-1(4),WRKD+6    *\n         SPACE 1\n*------- WORKING SET SIZE (R8=ASCB,R7=OUCB,R4-6=WORK)\n         SPACE 1\nWSSSTART MVI   WSS+2,C'-'          NULL VALUE.                    V2M0\n         TM    OUCBSFL,OUCBNSW     SEE IF NON-SWAPPABLE.          V2M0\n         BO    WSSEND              EXIT IF YES.\n         LH    R4,OUCBWSS          LOAD WORKING SET AT LAST SWAP. V2M0\n         CVD   R4,WRKD             *\n         MVC   WSS(3),=X'202120'   *                              V2M0\n         ED    WSS-1(4),WRKD+6     *                              V2M0\n         SPACE 1\nWSSEND   LM    R4,R7,SAVEREGS      RESTORE REGISTERS\n         BR    R6                  AND RETURN..\n         DROP  R2,R7,R8,R10,R11                                    -EU-\n         EJECT\n*=====================================================================*\n*        CONSTANTS                                                    *\n*=====================================================================*\n         SPACE 1\n*------- SWAP REASON CODES - FOUR BYTES PER ENTRY :\n*                  CODE  DESCRIPTION\n*                  ----  ----------------------------------------------\nSRCTABLE DC    CL4'    '\n         DC    CL4'TPUT' TERMINAL OUTPUT WAIT SWAP-OUT.\n         DC    CL4'TGET' TERMINAL INPUT WAIT SWAP-OUT.\n         DC    CL4'LONG' LONG WAIT CAUSED SWAP-OUT.\n         DC    CL4'PGS<' AUXILIARY STORAGE (PAGING SPACE) SHORTAGE\n*                        SWAP-OUT.\n         DC    CL4'RSS<' REAL STORAGE PAGEABLE POOL SHORTAGE SWAP-OUT.\n         DC    CL4'WAIT' MSO DETECTED WAIT SWAP-OUT.\n         DC    CL4'RQSW' REQSWAP SYSEVENT CAUSED SWAP-OUT.\n         DC    CL4'DENQ' CAP ENQ EXCHANGE SWAP-OUT.\n         DC    CL4'EXCH' CAP EXCHANGE SWAP BASED UPON RECOMMENDATION\n*                        VALUES.\n         DC    CL4'SWAP' CAP UNILATERAL SWAP-OUT.\n         SPACE 1\n*.....................................................................*\n*        MESSAGES                                                     *\n*.....................................................................*\n         SPACE 1\nGRIPE    DC    C'**NO TIMESHARING USERS ARE ACTIVE**'              -EU-\n*                XXXXXXX XX XXXX XXXX  XXX XXX XXX XX:XX:XX NNNNN.NN\nHEADING  DC    C'USERID  STATUS  ASID LNE/T.ID PGS WSS XACTTIME CPU-SECX\n               S '                                                 -EU-\n         EJECT\n*.....................................................................*\n*        LITERAL POOL                                                 *\n*.....................................................................*\n         SPACE 1\n         LTORG\n         EJECT\n*=====================================================================*\n*        WORK-AREAS                                                   *\n*=====================================================================*\n         SPACE 1                                                   -EU-\nAREA     DSECT                     WORK-AREAS DESCRIPTION          -EU-\n         DS    18F                 LOCAL SAVE AREA                 -EU-\n         SPACE 1                                                   -EU-\n*.....................................................................*\n*        LIST FORMS OF MACROS AREA                                    *\n*.....................................................................*\n         SPACE 1\nSTAXLST  STAX  ,MF=L\n         SPACE 1\n*.....................................................................*\n*        VARIABLES AREA                                               *\n*.....................................................................*\n         SPACE 1\nWRKD     DS    D\nRMCTPTR  DS    F\nSAVEREGS DS    4F\nSWITCH   DS    XL1\nOUTEX    EQU   X'80'               OUTPUT EXISTS..                 -EU-\n        $TEW$WA ,                                                  -EU-\n         SPACE 1\n*.....................................................................*\n*        MESSAGES AREA                                                *\n*.....................................................................*\n         SPACE 1\n         DS    0F                                                  -EU-\nBUFFER   DS    CL73                                                -EU-\nMSGTSU   DS    CL27                                                -EU-\nMSGUSER  EQU   MSGTSU+2,6                                          -EU-\n         SPACE 1\nAREAL    EQU   (((*-AREA)+7)/8)*8  WORK-AREAS LENGTH               -EU-\n         EJECT\n*.....................................................................*\n*        OVERLAY TO PRINT LINE                                        *\n*.....................................................................*\n         SPACE 1\nOVERLAY  DSECT\nUSERID   DS    CL8\nMEMSTAT1 DS    CL2                 MEMORY STATUS\n         DS    CL1\nMEMSTAT2 DS    CL4                 MEMORY SWAP REASON CODE\n         DS    CL1\nASID     DS    CL4                 ADDRESS SPACE ID\n         DS    CL1\nTERMID   DS    0CL8                TERMINAL ID                     -EU-\nLDASH    DS    CL1\nUNIT     DS    CL3                 LINE #\nRDASH    DS    CL4\n         DS    CL1\nSIZE     DS    CL3                 CURRENT SIZE\n         DS    CL1\nWSS      DS    CL3                 WORKING SET SIZE\n         DS    CL1\nSTEPHH   DS    CL2                 FOR STEP TIME HH:MM:SS\n         DS    CL1\nSTEPMM   DS    CL2\n         DS    CL1\nSTEPSS   DS    CL2\n         DS    CL1\nCPUTIME  DS    CL8                 FOR CPUTIME NNNNN.NN SECONDS\n         DS    CL1\nOVERLEN  EQU   *-OVERLAY\n         EJECT\n*=====================================================================*\n*        SYSTEM DSECT'S                                               *\n*=====================================================================*\n         SPACE 1\n         PRINT NOGEN                                               -EU-\n        $TEW$DS CVT=YES                                            -EU-\n         IHAASVT\n         IHAASCB\nCSCB     DSECT\n         IEECHAIN\n         IRAOUCB ,                                                 -EU-\n         IKJTSB ,                                                  -EU-\n         SPACE 1                                                   -EU-\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USERS$": {"ttr": 37388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//USERS    JOB (........),'INSTALL  - USERS -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHSVC                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=USERS\n//LNK     EXEC PAJILKL,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   TSO025AS\n  SETCODE AC(1)\n  NAME    USERS(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "USERS@": {"ttr": 37390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12o\\x00\\x88\\x12o\\x12W\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-05T00:00:00", "modifydate": "1988-05-05T12:57:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SYSPAJA"}, "text": "1   06/08/86\n                                                      USERS     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         TSO : USERS COMMAND         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Shows TSO users. It peeks at ASCBs to find TSO users\n  ---------    and formats a display of USERIDs/swap status/ASID\n               and terminal unit.\n               Note : it can be also started task.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VGPSUB": {"ttr": 37633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91)o\\x00\\x91)o\\tE\\x00f\\x00f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-23T00:00:00", "modifydate": "1991-10-23T09:45:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "SYSPAJA"}, "text": "VGPS     TITLE 'ISPF VGET-VPUT SUBROUTINE.'\nVGPSUB   START 0\n         SPACE 1\n* CALLING SEQUENCES : ONLY BY ASSEMBLER MACROS.\n* -------------------\n*\n*        1. $ISPF VGET,ID,DATA,POOL\n*           WHERE : - 'VGET'.\n*                   - ID IS THE NAME OF THE ISPF VARIABLE.\n*                   - DATA IS THE ADDRESS OF A FIELD INTO WHICH THE\n*                     ISPF VARIABLE CONTENTS VALUE WILL BE STORED.\n*                     FIELD DEFINITION AS BELOW :\n*                     DATA ---> DC C'...CONTENTS VALUE...'\n*                   - POOL IS 'SHARED' (DEFAULT) OR 'PROFILE'\n*\n*        2. $ISPF VPUT,ID,DATA,POOL\n*           WHERE : - 'VPUT'.\n*                   - ID IS THE NAME OF THE ISPF VARIABLE.\n*                   - DATA IS THE ADDRESS OF THE NEW CONTENTS VALUE TO\n*                     STORE IN THE ISPF VARIABLE.\n*                     FIELD DEFINITION AS BELOW :\n*                     DATA ---> DC C'...NEW CONTENTS VALUE...'\n*                   - POOL IS 'SHARED' (DEFAULT) OR 'PROFILE'\n*\n* PROCESS DESCRIPTION :\n* ---------------------\n*\n*        1. VGET : - PERFORM A VDEFINE TO INFORM ISPF OF THE VARIABLE\n*                    WE WANT (R.C. SET IN RCVDEF).\n*                  - PERFORM A VGET TO MOVE THE ISPF VARIABLE INTO THE\n*                    RECEIVING  FIELD (R.C. SET IN RCVGVP).\n*                  - A VDELETE IS THEN DONE TO FREE THE STORAGE AND\n*                    DEFINITION (R.C. SET IN RCVDEL).\n*\n*        2. VPUT : - PERFORM A VDEFINE TO INFORM ISPF OF THE VARIABLE\n*                    WE WANT TO UPDATE (R.C. SET IN RCVDEF).\n*                  - PERFORM A VPUT TO UPDATE THE ISPF VARIABLE FROM\n*                    THE GIVEN FIELD (R.C. SET IN RCVGVP).\n*                  - A VDELETE IS THEN DONE TO FREE THE STORAGE AND\n*                    DEFINITION (R.C. SET IN RCVDEL).\n*\n*        AT ENTRY, THE REGISTER 0 IS SET AS FOLLOWS :\n*                  0 = VGET            + = SHARED POOL\n*                  1 = VPUT            - = PROFILE POOL\n*        AT END, THE CONDITION CODE IS SET AS FOLLOWS :\n*                  ZERO - ALL O.K.\n*                  NON ZERO - AN ERROR HAS OCCURED.\n*        AND THE REGISTER 15 POINTS TO THE RETURN CODES AREA AS SHOWN :\n*                  R15 ---> DC F'...RC OF VDEFINE...'\n*                           DC F'...RC OF VGET OR VPUT...'\n*                           DC F'...RC OF VDELETE...'\n         EJECT\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n         PRINT NOGEN\n        $DEFREG\n        $XENT  BASE=R12\n         MVC   ID(L'ID),0(R1)      SET ISPF VARIABLE NAME.\n         MVC   LEN+2(2),8(R1)      SET DATA FIELD LENGTH.\n         ICM   R3,B'1111',10(R1)   GET DATA FIELD ADDRESS.\n         LR    R1,R0\n         N     R0,=A(X'7FFFFFFF')\n         LTR   R0,R0               SET REQUESTED OPERATION.\n         BNZ   *+L'*+10\n         MVC   VOP,=CL8'VGET'\n         B     *+L'*+6\n         MVC   VOP,=CL8'VPUT'\n         O     R1,=A(X'0FFFFFFF')\n         LTR   R1,R1               SET REQUESTED POOL.\n         BM    *+L'*+10\n         MVC   VPL,=CL8'SHARED'\n         B     *+L'*+6\n         MVC   VPL,=CL8'PROFILE'\n         LA    R4,RCODES           RETURN CODES ADDRESS.\n         SPACE 1\n        CALL   ISPLINK,(VDEF,ID,(R3),CHAR,LEN),VL\n         ST    R15,0(R4)           R.C. OF VDEFINE.\n        CALL   ISPLINK,(VOP,ID,VPL),VL\n         ST    R15,4(R4)           R.C. OF VGET OR VPUT.\n        CALL   ISPLINK,(VDEL,ID),VL\n         ST    R15,8(R4)           R.C. OF VDELETE.\n         OC    0(12,R4),0(R4)      SET CONDITION CODE.\n         SPACE 1\n        $XRET  CC=(R4)\n         EJECT\n*------- CONSTANTS AND WORK AREAS.\n         SPACE 1\nRCODES   DC    3F'0'\nVDEF     DC    CL8'VDEFINE'\nVOP      DC    CL8' '\nVDEL     DC    CL8'VDELETE'\nCHAR     DC    CL8'CHAR'\nVPL      DC    CL8' '\nLEN      DC    F'0'\nID       DC    CL8' '\n         SPACE 1\n        LTORG\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VGPSUB$": {"ttr": 37636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14$\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:24:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "//VGPSUB   JOB (........),'INSTALL  - VGPSUB -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* NOTE : AT LINK-EDIT YOU WILL RECEIVE A RETURN CODE 4 WHICH IS     *\n//*        ONLY A NORMAL WARNING MESSAGE DUE TO NCAL SPECIFIED.       *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,MBR=VGPSUB\n//LNK     EXEC PAJILKR,OPT=',NCAL'\n//SYSIN     DD *\n  NAME    VGPSUB(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VGPSUB@": {"ttr": 37638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91)o\\x00\\x91)o\\x14\\x14\\x00\\\\\\x00\\\\\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-23T00:00:00", "modifydate": "1991-10-23T14:14:00", "lines": 92, "newlines": 92, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/10/91\n                                                      VGPSUB    1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      ISPF VGET-VPUT SUBROUTINE      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose : ISPF variable access.\n  ---------\n\n  Calling sequences : only by $ISPF Assembler macro.\n  -------------------\n\n         1. $ISPF VGET,ID,DATA,POOL\n            where : - VGET is a literal (function name).\n                    - ID is the name of the ISPF variable.\n                    - DATA is the address of a field into which the\n                      ISPF variable contents value will be stored.\n                      Field definition as below :\n                      DATA ---> DC C'...contents value...'\n                      POOL is the keyword SHARED (default) or PROFILE\n                      (cannot be specified on the list form of macro).\n\n         2. $ISPF VPUT,ID,DATA,POOL\n            where : - VPUT is a literal (function name).\n                    - ID is the name of the ISPF variable.\n                    - DATA is the address of the new contents value to\n                      store in the ISPF variable.\n                      Field definition as below :\n                      DATA ---> DC C'...new contents value...'\n                      POOL is the keyword SHARED (default) or PROFILE\n                      (cannot be specified on the list form of macro).\n\n  Process description :\n  ---------------------\n\n         1. VGET : - perform a VDEFINE to inform ISPF of the variable\n                     we want (R.C. set in RCVDEF).\n                   - perform a VGET to move the ISPF variable into the\n                     receiving field (R.C. set in RCVGVP).\n                   - a VDELETE is then done to free the storage and\n                     definition (R.C. set in RCVDEL).\n\n         2. VPUT : - perform a VDEFINE to inform ISPF of the variable\n                     we want to update (R.C. set in RCVDEF).\n                   - perform a VPUT to upadte the ISPF variable from\n                     the given field (R.C. set in RCVGVP).\n                   - a VDELETE is then done to free the storage and\n                     definition (R.C. set in RCVDEL).\n1   23/10/91\n                                                      VGPSUB    2/2.\n\n         At entry, the register 0 is set as below :\n                   0 = VGET            + = SHARED\n                   1 = VPUT            - = PROFILE\n\n         At end, the condition code is set as follows :\n                 - zero : all O.K.\n                 - non zero : an error has occured, and the register\n                   15 points to the return codes area as shown :\n                   R15 ---> DC F'...RC of VDEFINE...'\n                            DC F'...RC of VGET or VPUT...'\n                            DC F'...RC of VDELETE...'\n\n  Some examples of $ISPF Assembler macro coding :\n  ===============================================\n\n      Statement(s)                                       Action(s)\n      -------------------------------------------------  -------------\n  (1)          LA    Rx,DATA.length                      define list\n      label    $ISPF VPUT,ID,(DATA,(Rx)),,MF=E           + execute\n\n  (2)          LA    Rx,DATA.length\n      label    $ISPF VGET,,(,(Rx)),SHARED,MF=(E,list)    execute\n               ...\n      list     $ISPF ,ID,(DATA,),MF=L                    define list\n\n  (3)          LA    Rx,ID.address\n      label    $ISPF VPUT,(Rx),,PROFILE,MF=(E,list)      execute\n               ...\n      list     $ISPF ,,DATA,MF=L                         define list\n\n  (4)          LA    Rx,DATA.address\n               LA    Ry,DATA.length\n               LA    Rz,list\n      label    $ISPF ,,((Rx),(Ry)),,MF=(L,(Rz))          fill list\n               ...\n      label    $ISPF VGET,ID,,,MF=(E,(Rz))               execute\n               ...\n      list     $ISPF ,,,MF=L                             define list\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VREAD": {"ttr": 37641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\x102\\x01\\xc0\\x01\\xc0\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T10:32:00", "lines": 448, "newlines": 448, "modlines": 0, "user": "SYSPAJA"}, "text": "VRD      TITLE 'VARIABLE READ SUBROUTINE.'\nVREAD    START 0\n         SPACE 2\n* CALLING SEQUENCE : CALL VREAD,(A,B,C),VL\n* ------------------            (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE ADDRESS OF AN ARRAY (FORMAT CL...) INTO\n*                    WHICH THE LOGICAL RECORD IS READ.\n*\n*                B - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSVRIN '.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                    -1 - END-OF-FILE.\n*                     0 - READ CORRECTLY EXECUTED.\n*                     1 - FILE NOT OPENED.\n*                     2 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     3 - READ ERROR.\n*\n* CALLING SEQUENCE : CALL VOPEN,(A,B,C),VL\n* ------------------            (A,B)\n*                               (A)\n*\n*        WHERE : A - IS THE MAXIMUM LOGICAL RECORD LENGTH (FORMAT\n*                    FULLWORD - F BOUNDARY) FOR THE FILE. THIS ARGUMENT\n*                    IS MANDATORY BECAUSE INFORMATION IS RETURNED TO\n*                    THE CALLER.\n*\n*                B - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) IF\n*                    SUPPLIED (OPTIONAL). WHEN THIS ARGUMENT IS\n*                    OMITTED, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, THE DEFAULT\n*                    DD-NAME USED IS 'SYSVRIN '.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - OPEN CORRECTLY EXECUTED.\n*                     1 - DD-CARD MISSING.\n*                     2 - OPEN ERROR, RECORD FORMAT NOT DEFINED OR\n*                         LRECL TOO LARGE (MAXIMUM ALLOWED IS 256).\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - FILE ALREADY OPENED.\n         EJECT\n* CALLING SEQUENCE : CALL VCLOSE,(A,B),VL\n* ------------------             (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8) TO\n*                    CLOSE. IF THIS ARGUMENT CONTAINS THE 'CLOSEALL'\n*                    KEYWORD, OR THE ADDRESS OF THIS ARGUMENT IS SET\n*                    TO ZERO IN THE PARAMETERS LIST, OR THE PARAMETERS\n*                    LIST POINTER (REGISTER 1) IS ZERO, ALL THE OPENED\n*                    FILES ARE CLOSED.\n*\n*                B - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE, ARGUMENT ALIGNMENT OR\n*                         DD-NAME ERROR.\n*\n* GENERAL NOTICE : ON ANY ERROR DETECTION, A MESSAGE IS INCLUDED IN\n* ---------------- THE MESSAGE CLASS FOR THE JOB.\n*                  IF THE ROUTINE IS RE-CALLED AFTER IND = 1 OR 2,\n*                  THE PROGRAM IS SENDED IN ABEND U0001.\n*                  IF THE INDICATOR RESPONSE IS DETECTED 10 TIMES\n*                  DIFFERENT FROM 0, THE PROGRAM IS SENDED IN\n*                  ABEND U0002.\n*                  MVS/XA : MUST BE AMODE AND RMODE 24.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\n         EJECT\n        PRINT  NOGEN\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 1\n*        FILE BLOCK WORK AREA DESCRIPTION.\n         SPACE 1\nFBWAD    DSECT\nFCHAIN   DC    F'0'                CHAIN WORD.\nFDDNM    DC    CL8' '              DD-NAME.\nFERCNT   DC    H'10'               ERROR COUNT.\nFFLAGS   DC    XL1'0'              FLAGS BYTE.\nFAB      EQU   X'01'                    ABEND.\nFOE      EQU   X'02'                    OPEN ERROR.\nFRE      EQU   X'04'                    READ ERROR.\n         DC    XL1'0'              UNUSED.\nFMLRL    DC    F'0'                MAX. LOGICAL RECORD LENGTH.\n         SPACE 1\nVREAD    CSECT                     RESTORE MAIN CSECT.\n         EJECT\n        $XENT  BASE=R12\n         SPACE 1\n         LA    R6,TABD             SET DEFAULTS.\n         LA    R7,DDDEF\n         SR    R9,R9\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    VR1\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         LTR   R8,R8\n         BZ    *+L'*+2\n         LR    R7,R8\n         TM    4(R1),X'80'\n         BO    VR1\n         TM    8(R1),X'80'\n         BZ    ERR2\n         TM    11(R1),X'03'\n         BNZ   ERR2\n         L     R9,8(R1)\n         LA    R9,0(R9)\nVR1      L     R8,0(R1)\n         LA    R8,0(R8)\n         SPACE 1\n         LA    R4,CHAIN\n         USING FBWAD,R4\nVR2      L     R4,FCHAIN           LOOK IF OPENED.\n         LTR   R4,R4\n         BZ    ERR1\n         CLC   FDDNM(L'FDDNM),0(R7)\n         BNE   VR2\n         TM    FFLAGS,FAB          TEST ABEND SWITCH.\n         BO    ABND1\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    ERR1\n         NI    FFLAGS,255-FRE      RESET READ ERROR SWITCH.\n        GET    (R2)\n         TM    FFLAGS,FRE          TEST READ ERROR SWITCH.\n         BO    ERR3\n         LH    R15,DCBLRECL        GET LOGICAL RECORD LENGTH.\n         TM    DCBRECFM,DCBRECU    TEST IF UNDEFINED RECORD.\n         BO    EXMVR\n         TM    DCBRECFM,DCBRECV    TEST IF VARIABLE RECORD.\n         BZ    EXMVR\n         SH    R15,RDFOUR          -4 FOR SDW.\n         LA    R1,4(R1)\nEXMVR    BCTR  R15,0               -1 FOR MOVE.\n         EX    R15,MVREC           MOVE RECORD.\n         SR    R10,R10\n         B     EXIT4\nMVREC    MVC   0(*-*,R8),0(R1)     << EXECUTED >>\n         DROP  R2\n         SPACE 1\nRDERR    OI    FFLAGS,FRE          SET READ ERROR SWITCH.\n         BR    R14\n         SPACE 1\nRDEND   CLOSE  ((R2))\n         SR    R10,R10\n         BCTR  R10,0\n         B     EXIT4\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nMAXERR   EQU   ((*-ERR1)/2)+1\n         B     EXIT\n         SPACE 1\nRDFOUR   DC    H'4'\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY VOPEN\n         SPACE 1\nVOPEN   $XENT  BASE=R12,DT=NO\n         SPACE 1\n         LA    R6,TABO             SET DEFAULTS.\n         LA    R7,DDDEF\n         SR    R9,R9\n         LA    R10,MAXERO\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    OP1\n         L     R8,4(R1)\n         LA    R8,0(R8)\n         LTR   R8,R8\n         BZ    *+L'*+2\n         LR    R7,R8\n         TM    4(R1),X'80'\n         BO    OP1\n         TM    8(R1),X'80'\n         BZ    ERO3\n         TM    11(R1),X'03'\n         BNZ   ERO3\n         L     R9,8(R1)\n         LA    R9,0(R9)\nOP1      TM    3(R1),X'03'\n         BNZ   ERO3\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         SPACE 1\n         LA    R3,CHAIN            LOOK IF ALREADY DEFINED.\n         USING FBWAD,R4\nOP2      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    OP3\n         CLC   FDDNM(L'FDDNM),0(R7)\n         BE    OP6\n         LR    R3,R4\n         B     OP2\nOP3     GETMAIN R,LV=WSZ\n         LR    R4,R1\n         ST    R4,0(R3)            NEW FILE.\n         MVC   FCHAIN(WSZ),BFILE   SET SKELETON.\n         MVC   FDDNM(L'FDDNM),0(R7)\n         LA    R2,DZ(R4)\n         USING IHADCB,R2\n         MVC   DCBDDNAM(L'DCBDDNAM),FDDNM\n         OC    ATIOT(L'ATIOT),ATIOT     TEST FIRST TIME.\n         BNZ   OP4\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\nOP4      L     R3,ATIOT            SEARCH DD AND OPEN IT.\n         USING TIODSECT,R3\nOP5      CLC   TIOELNGH(4),ZEROS\n         BE    ERO1\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM\n         BE    OP7\n         SR    R1,R1\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     OP5\n         DROP  R3\nOP6      TM    FFLAGS,FAB          TEST ABEND SWITCH.\n         BO    ABND1\n         LA    R2,DZ(R4)\n         TM    DCBOFLGS,DCBOFOPN   TEST ALREADY OPENED.\n         BO    ERO4\nOP7     OPEN   ((R2),(INPUT))\n         TM    FFLAGS,FOE          TEST OPEN ERROR SWITCH.\n         BO    ERO2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPEN SUCCESSFULL.\n         BZ    ERO2\n         DROP  R2\n         MVC   0(L'FMLRL,R8),FMLRL PASS MAXIMUM LOGICAL RECORD LENGTH.\n         SR    R10,R10\n         B     EXIT4\n         SPACE 1\nERO1     BCTR  R10,0\nERO2     BCTR  R10,0\n         OI    FFLAGS,FAB          SET ABEND SWITCH TO PREVENT RE-CALL.\nERO3     BCTR  R10,0\nERO4     BCTR  R10,0\nMAXERO   EQU   (((*-ERO1)-4)/2)+1\n         B     EXIT\n         SPACE 2\n         USING IHADCB,R1\nDCBEXIT  TM    DCBRECFM,DCBRECU    TEST IF RECORD FORMAT DEFINED.\n         BZ    EX3\n         LA    R3,256              CONTROL THE LOGICAL RECORD LENGTH.\n         LH    R2,DCBLRECL\n         LTR   R2,R2\n         BP    EX1\n         LH    R2,DCBBLKSI\n         LTR   R2,R2\n         BNP   EX3\nEX1      TM    DCBRECFM,DCBRECU    TEST IF UNDEFINED RECORD.\n         BO    EX2\n         TM    DCBRECFM,DCBRECV    TEST IF VARIABLE RECORD.\n         BZ    EX2\n         SH    R2,EXFOUR\n         BNP   EX3\nEX2      CLR   R2,R3\n         BH    EX3\n         ST    R2,FMLRL\n         BR    R14\n         DROP  R1\nEX3      OI    FFLAGS,FOE          SET OPEN ERROR SWITCH.\n         BR    R14\n         SPACE 1\nEXFOUR   DC    H'4'                SDW LENGTH.\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\n         ENTRY VCLOSE\n         SPACE 1\nVCLOSE  $XENT  BASE=R12,DT=NO\n         SPACE 1\n         LA    R6,TABC             CONTROL ARGUMENTS.\n         SR    R9,R9\n         LA    R10,1\n         LTR   R8,R1\n         BZ    VC2\n         L     R8,0(R1)\n         LA    R8,0(R8)\n         TM    0(R1),X'80'\n         BO    VC1\n         TM    4(R1),X'80'\n         BZ    EXIT\n         TM    7(R1),X'03'\n         BNZ   EXIT\n         L     R9,4(R1)\n         LA    R9,0(R9)\nVC1      LTR   R8,R8\n         BZ    VC2\n         CLC   0(8,R8),KEYALL\n         BNE   VC2\n         SR    R8,R8\n         SPACE 1\nVC2      LA    R3,CHAIN\n         USING FBWAD,R4\nVC3      L     R4,0(R3)\n         LTR   R4,R4\n         BZ    VC6\n         LTR   R8,R8\n         BZ    VC4\n         CLC   0(L'FDDNM,R8),FDDNM\n         BE    VC4\n         LR    R3,R4\n         B     VC3\nVC4      LA    R2,DZ(R4)\n         USING IHADCB,R2\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED.\n         BZ    VC5\n        CLOSE  ((R2))\n         DROP  R2\nVC5      MVC   0(L'FCHAIN,R3),FCHAIN    DEQUEUE FILE.\n         LR    R1,R4\n        FREEMAIN R,A=(1),LV=WSZ\n         LTR   R8,R8\n         BNZ   VC7\n         B     VC3\nVC6      LTR   R8,R8\n         BNZ   EXIT\nVC7      SR    R10,R10\n         B     EXIT4\n         SPACE 1\n         DROP  R4\n         DROP  R12\n         EJECT\nEXIT     BASR  R12,0\n         USING *,R12\n         LR    R2,R10\n         BCTR  R2,0\n         SLL   R2,2\n         L     R3,0(R2,R6)\n         NI    SWEX+1,OFF          SET SWITCH OFF.\n         CLI   12(R3),C' '\n         BNE   *+L'*+10\n         OI    SWEX+1,ON           SET SWITCH ON.\n         MVC   12(8,R3),0(R7)\n         LR    R1,R3\n        WTO    MF=(E,(1))\nSWEX     B     EXIT1\n         LA    R3,CNTR             CONTROL MAX. ERROR.\n         B     EXIT2\nEXIT1    MVC   12(8,R3),BLKS\n         LTR   R4,R4\n         BZ    SWEX+L'SWEX\n         USING FBWAD,R4\n         LA    R3,FERCNT\n         DROP  R4\nEXIT2    LH    R2,0(R3)\n         BCT   R2,EXIT3\n         LA    R1,2                SET ABEND CODE.\n         B     ABND\nEXIT3    STH   R2,0(R3)\n         DROP  R12\n         SPACE 1\nEXIT4    BASR  R12,0\n         USING *,R12\n         LTR   R9,R9\n         BZ    EXIT5\n         ST    R10,0(R9)           STORE IND.\nEXIT5   $XRET  CC=(R10)\n         DROP  R12\n         EJECT\nABND1    LA    R1,1                SET ABEND CODE.\n         SPACE 1\nABND     BASR  R12,0\n         USING *,R12\n         LR    R15,R10             SET C.C. IN REG. 15.\n        ABEND  (1),DUMP\n         SPACE 1\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nCHAIN    DC    A(*-*)\nATIOT    DC    A(*-*)\nTABD     DC    A(DIAG5,DIAG6,DIAG7)\nTABO     DC    A(DIAG1,DIAG2,DIAG3,DIAG4)\nTABC     DC    A(DIAG8)\nZEROS    DC    F'0'\nFIVE     DC    F'5'\nDIAG1   WTO    'ERR=1 -          DD-CARD MISSING.',                    1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG2   WTO    'ERR=2 -          OPEN ERROR OR DD-CARD CONFLICT.',     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG3   WTO    'ERR=3 - VOPEN CALLING SEQUENCE OR ARGUMENT ALIGNMENT ER1\n               ROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG4   WTO    'ERR=4 -          ALREADY OPENED.',                     1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG5   WTO    'ERR=1 -          NOT OPENED.',                         1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG6   WTO    'ERR=2 - VREAD CALLING SEQUENCE OR ARGUMENT ALIGNMENT ER1\n               ROR.',ROUTCDE=11,DESC=7,MF=L\nDIAG7   WTO    'ERR=3 -          I/O ERROR.',                          1\n               ROUTCDE=11,DESC=7,MF=L\nDIAG8   WTO    'ERR=1 - VCLOSE CALLING SEQUENCE, ARGUMENT ALIGNMENT OR 1\n               DD-NAME ERROR.',ROUTCDE=11,DESC=7,MF=L\nCNTR     DC    H'10'\nDDDEF    DC    CL8'SYSVRIN '\nKEYALL   DC    CL8'CLOSEALL'\nBLKS     DC    CL8' '\n         EJECT\n        CNOP   0,8\n         SPACE 1\nBFILE    DC    F'0'                CHAIN WORD.\n         DC    CL8' '              DD-NAME.\n         DC    H'10'               ERROR COUNT.\n         DC    XL1'0'              FLAGS BYTE.\n         DC    XL1'0'              UNUSED.\n         DC    F'0'                MAX. LOGICAL RECORD LENGTH.\n         SPACE 1\nDCBRDR  DCB    DSORG=PS,DEVD=DA,MACRF=GL,BFALN=D,                      1\n               EXLST=REXLIST,SYNAD=RDERR,EODAD=RDEND,DDNAME=XXXXXXXX\n         SPACE 1\n        CNOP   0,8\n         SPACE 1\nDZ       EQU   DCBRDR-BFILE\nWSZ      EQU   (((*-BFILE)+7)/8)*8\n         SPACE 1\nREXLIST  DC    0F'0',XL1'85',AL3(DCBEXIT)\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VREAD$": {"ttr": 37892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//VREAD    JOB (........),'INSTALL  - VREAD -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,MBR=VREAD\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   VOPEN\n  ALIAS   VCLOSE\n  NAME    VREAD(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VREAD@": {"ttr": 37894, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14S\\x00m\\x00m\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:53:00", "lines": 109, "newlines": 109, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      VREAD     1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        VARIABLE READ ROUTINE        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL VREAD,(A,B,C),VL\n  ------------------            (A,B)\n                                (A)\n\n         Where : A - is the address of an array (format CL...) into\n                     which the logical record is read.\n\n                 B - is the address of the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSVRIN.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                     -1 - END-OF-FILE.\n                      0 - READ correctly executed.\n                      1 - file not opened.\n                      2 - calling sequence or argument alignment error.\n                      3 - READ error.\n\n  Assembler macro : $VREAD A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/09/85\n                                                      VREAD     2/3.\n\n  Calling sequence : CALL VOPEN,(A,B,C),VL\n  ------------------            (A,B)\n                                (A)\n\n         Where : A - receives the maximum logical record length (format\n                     FULLWORD - F boundary) for the file. This argument\n                     is mandatory because information is returned to\n                     the caller.\n\n                 B - is the address od the DD-name (format CL8) if\n                     supplied (optional). When this argument is\n                     omitted, or the address of this argument is set\n                     to zero in the parameters list, the default\n                     DD-name used is SYSVRIN.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - OPEN correctly executed.\n                      1 - DD-card missing.\n                      2 - OPEN error, record format not defined or\n                          LRECL too large (maximum allowed is 256).\n                      3 - calling sequence or argument alignment error.\n                      4 - file already opened.\n\n  Assembler macro : $VOPEN A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   28/07/86\n                                                      VREAD     3/3.\n\n  Callins sequence : CALL VCLOSE,(A,B),VL\n  ------------------             (A)\n\n         Where : A - is the address of the DD-name (format CL8) to\n                     close. If this argument contains the CLOSEALL\n                     keyword, or the address of this arguemnt is ser\n                     to zero in the parameters list, or the parameters\n                     list pointed (register 1) is zero, all the opened\n                     files are closed.\n\n                 B - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence, argument alignment or\n                          DD-name error.\n\n  Assembler macro : $VCLOSE A,B\n  -----------------\n\n         Where A and/or B are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n\n  General notice : on any error detection, a message is included in\n  ================ the message class for the job.\n                   If the routine is re-called after IND = 1 or 2,\n                   the program is sended in abend U0001.\n                   If the indicator response is detected 10 times\n                   different from 0, the program is sended in\n                   abend U0002.\n                   This routine is multi-files usable, that means\n                   multi-files opened concurrently (using the DD-name\n                   argument).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VTOCD": {"ttr": 37897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\x11#\\x01\\xb1\\x01\\xb1\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T11:23:00", "lines": 433, "newlines": 433, "modlines": 0, "user": "SYSPAJA"}, "text": "VTDR     TITLE 'VTOC DIRECT READ-WRITE SUBROUTINE.'\nVTOCDR   START 0\n         SPACE 2\n* PURPOSE :    ROUTINE TO READ AND/OR WRITE IN DIRECT MODE A VTOC.\n* ---------    A DD-CARD, WRITTEN AS BELOW, IS NEEDED TO DEFINE\n*              THE DESIRED VOLUME :\n*\n*              //...     DD  UNIT=...,VOLUME=SER=...,DISP=OLD\n*\n* CALLING SEQUENCE : CALL VTOCDR,(A,B,C),VL\n* ------------------             (A,B)\n*                                (A)\n*\n*        WHERE : A - IS THE ADDRESS OF AN ARRAY (FORMAT FULLWORD -\n*                    F BOUNDARY) TO READ A DSCB'S RECORD (140 BYTES\n*                    LONG).\n*\n*                B - IS THE ADDRESS OF THE DSCB RECORD TO READ, IN THE\n*                    FORMAT MBBCCHHR (FORMAT XL8).\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - READ OPERATION CORRECTLY EXECUTED.\n*                     1 - READ ERROR.\n*                     2 - FILE NOT OPENED.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*\n* CALLING SEQUENCE : CALL VTOCDW,(A,B,C),VL\n* ------------------             (A,B)\n*                                (A)\n*\n*        WHERE : A - IS THE ADDRESS OF AN ARRAY (FORMAT FULLWORD -\n*                    F BOUNDARY) CONTAINING A DSCB'S RECORD (140 BYTES\n*                    LONG) TO WRITE.\n*\n*                B - IS THE ADDRESS OF THE DSCB RECORD TO WRITE, IN THE\n*                    FORMAT MBBCCHHR (FORMAT XL8).\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - WRITE OPERATION CORRECTLY EXECUTED.\n*                     1 - WRITE ERROR.\n*                     2 - FILE NOT OPENED.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n         EJECT\n* CALLING SEQUENCE : CALL VTOCDO,(A,B,C),VL\n* ------------------             (A,B)\n*                                (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8).\n*\n*                B - IS THE ADDRESS OF THE DEVICE CHARACTERISTICS\n*                    (FORMAT FULLWORD - F BOUNDARY) RETURNED BY THE\n*                    ROUTINE IF SUPPLIED (OPTIONAL). IT WILL RECEIVE\n*                    FIVE FULLWORDS INFORMATION AS DESCRIBED IN DEVTYPE\n*                    MACRO (SEE OS/VS2 SYSTEM PROGRAMMING LIBRARY :\n*                    DATA MANAGEMENT), FOLLOWED BY ONE HALFWORD\n*                    CONTAINING THE NUMBER OF ALTERNATE TRACKS FOR\n*                    THE DEVICE, FOLLOWED BY A SIX CHARACTERS FIELD\n*                    CONTAINING THE VOLUME SERIAL NUMBER OF THE\n*                    DEVICE. THIS ARGUMENT IS OPTIONAL AND MAY BE\n*                    OMITTED OR HIS ADDRESS MAY BE SET TO ZERO IN THE\n*                    PARAMETERS LIST.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - OPEN CORRECTLY EXECUTED.\n*                     1 - FILE ALREADY OPENED.\n*                     2 - OPEN ERROR.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - NOT OS/VS2 SYSTEM.\n*                     5 - DD-CARD MISSING.\n*                     6 - NOT DIRECT-ACCESS STORAGE DEVICE.\n*                     7 - READ JFCB ERROR.\n*                     8 - DD-CARD INCORRECTLY CODED.\n*\n* CALLING SEQUENCE : CALL VTOCDC,(A),VL\n* ------------------\n*\n*        WHERE : A - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL : ARGUMENT MAY BE\n*                    OMITTED PASSING A ZERO PARAMETERS LIST POINTER -\n*                    REGISTER 1). VALUE IS ALWAYS PLACED IN REGISTER 15\n*                    AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n         EJECT\n* GENERAL NOTICE : ON ERROR READING OR WRITING A VTOC'S DSCB A MESSAGE\n* ================ IS INCLUDED IN THE MESSAGE CLASS FOR THE JOB.\n*                  MVS/XA : MUST BE AMODE AND RMODE 24.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n        $DEFREG\n         SPACE 2\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               SET SWITCH NOP OPERATION.\nON       EQU   X'F0'               SET SWITCH BRANCH OPERATION.\n         EJECT\n         ENTRY VTOCDW\n         ENTRY VTOCDO\n         ENTRY VTOCDC\n         SPACE 1\n         USING *,R15\n         MVI   WTGO+3,VTODS-*      SET ENTRY DISPLACEMENT (READ).\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nVTOCDW   MVI   WTGO+3,VTODS-*      SET ENTRY DISPLACEMENT (WRITE).\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nVTOCDO   MVI   WTGO+3,VTODS-*      SET ENTRY DISPLACEMENT (OPEN).\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nVTOCDC   MVI   WTGO+3,VTODS-*      SET ENTRY DISPLACEMENT (CLOSE).\n         DROP  R15\n         SPACE 1\nWTGO     LA    R15,*-*(R15)        SET COMMON ENTRY ADDRESS.\n         EJECT\nVTODS   $XENT BASE=R12\n         LR    R15,R12             COMPUTE WHERE TO GO?\n         BCTR  R15,0\n         SR    R14,R14\n         IC    R14,0(R15)\n         SRL   R14,1\n         B     *+L'*-(VTODS-WTGO)+0(R14) ENTER SELECTED ROUTINE.\n         SPACE 1\n         B     VTCLOSE             BRANCH ENTRIES VECTOR.\n         B     VTOPEN\n         B     VTWRITE\n         EJECT\n         NI    SWT+1,OFF           SET NOP OPERATION.\n         B     RDWR\nVTWRITE  OI    SWT+1,ON            SET BRANCH OPERATION.\n         SPACE 1\nRDWR     SR    R9,R9\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    ERR3\n         TM    4(R1),X'80'\n         BO    RW1\n         TM    8(R1),X'80'\n         BZ    ERR3\n         TM    11(R1),X'03'\n         BNZ   ERR3\n         L     R9,8(R1)\n         LA    R9,0(R9)\nRW1      L     R8,4(R1)\n         LA    R8,0(R8)\n         TM    3(R1),X'03'\n         BNZ   ERR3\n         L     R7,0(R1)\n         LA    R7,0(R7)\n         SPACE 1\n         LA    R6,DCBVR\n         USING IHADCB,R6\n         TM    DCBOFLGS,DCBOFOPN   TEST IF OPENED?\n         BZ    ERR2                BRANCH IF NOT.\nSWT      B     RW2\n         LA    R2,ECBVR\n         LA    R3,ECBVR+4\n         USING ECB,R2\n         USING IOBSTDRD,R3\n         XC    ECB(L'ECBRB),ECB    CLEAR ECB.\n         XC    IOBCSW(L'IOBCSW),IOBCSW CLEAR CSW.\n        XDAP   ECBVR,RI,DCBVR,(R7),140,,(R8)\n         B     TEST\nRW2      LA    R2,ECBVW\n         LA    R3,ECBVW+4\n         XC    ECB(L'ECBRB),ECB    CLEAR ECB.\n         XC    IOBCSW(L'IOBCSW),IOBCSW CLEAR CSW.\n        XDAP   ECBVW,WI,DCBVR,(R7),140,,(R8)\nTEST    WAIT   ECB=(R2)\n         CLI   ECB,ECBNORM         READ-WRITE CORRECTLY EXECUTED?\n         BE    OK\n         DROP  R6\n         TM    SWT+1,ON\n         BO    *+L'*+10\n         MVC   OPER(L'XRM),XRM\n         B     *+L'*+6\n         MVC   OPER(L'XWM),XWM\n         UNPK  ADDR(L'ADDR/2+1),0(5,R8)\n         UNPK  ADDR+L'ADDR/2(L'ADDR/2+1),4(5,R8)\n         TR    ADDR(L'ADDR),TRTAB-X'F0'\n         MVI   ADDR+L'ADDR,C','\n         UNPK  CODE(L'CODE+1),ECB(L'ECBRB+1)\n         TR    CODE(L'CODE),TRTAB-X'F0'\n         MVI   CODE+L'CODE,C','\n         UNPK  STAT(L'STAT+1),IOBCSW(L'IOBCSW+1)\n         TR    STAT(L'STAT),TRTAB-X'F0'\n         MVI   STAT+L'STAT,C'.'\n        WTO    MF=(E,LWTO)\n         B     ERR1\n         DROP  R2,R3\nOK       SR    R10,R10\n         B     EXIT\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nMAXERR   EQU   ((*-ERR1)/2)+1\n         B     EXIT\n         EJECT\nVTOPEN   SR    R9,R9\n         SR    R8,R8\n         LA    R10,MAXERO\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    OP2\n         TM    4(R1),X'80'\n         BO    OP1\n         TM    8(R1),X'80'\n         BZ    ERO3\n         TM    11(R1),X'03'\n         BNZ   ERO3\n         L     R9,8(R1)\n         LA    R9,0(R9)\nOP1      TM    7(R1),X'03'\n         BNZ   ERO3\n         L     R8,4(R1)\n         LA    R8,0(R8)\nOP2      L     R7,0(R1)\n         LA    R7,0(R7)\n         SPACE 1\n         OC    ATIOT(L'ATIOT),ATIOT FISRT TIME?\n         BNZ   GOT                 BRANCH IF NOT.\n         L     R2,CVTPTR           GET CVT ADDRESS.\n         USING CVT,R2\n         TM    CVTDCB,CVT4MS1      TEST IF OS/VS2?\n         BZ    ERO4                BRANCH IF NOT.\n         DROP  R2\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\n         L     R2,ATIOT\n         USING TIODSECT,R2\n         MVC   GN4+1(L'TIOCNJOB),TIOCNJOB\n         DROP  R2\n         LA    R2,GN4+L'GN4-3\n         LA    R3,L'GN4-1\nDSOL     CLI   0(R2),C' '\n         BNE   DSOLF\n         BCTR  R2,0\n         BCT   R3,DSOL\nDSOLF    MVC   1(2,R2),GN3\n         SPACE 1\nGOT      L     R2,ATIOT            GET TIOT ADDRESS.\n         USING TIODSECT,R2\n         LA    R5,DCBVR            SEARCH DD-CARD.\n         USING IHADCB,R5\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED?\n         BO    ERO1                BRANCH IF YES.\n         MVC   DCBDDNAM(L'DCBDDNAM),0(R7)\nSRCH     CLC   TIOELNGH(L'ZEROS),ZEROS END OF TIOT?\n         BE    ERO5                YES.\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM DD-NAME FOR US?\n         BE    FOUND               YES.\nNEXT     SR    R1,R1\n         IC    R1,TIOELNGH\n         AR    R2,R1               NEXT DD ENTRY.\n         B     SRCH\n         DROP  R2\nFOUND    LTR   R2,R8\n         BNZ   *+L'*+4\n         LA    R2,DVTYP\n        DEVTYPE  DCBDDNAM,(R2),DEVTAB\n         CLI   2(R2),X'20'         TEST IF DIRECT-ACCESS STORAGE.\n         BNE   ERO6                BRANCH IF NOT.\n         LTR   R8,R8\n         BZ    RDJ\n         L     R4,CVTPTR           GET CVT POINTER.\n         USING CVT,R4\n         L     R15,CVTZDTAB        ADDRESS OF IECZDTAB.\n         DROP  R4\n         LA    R15,0(0,R15)        IECZDTAB IS THE RESIDENT DIRECT\n         SR    R4,R4                    ACCESSS DEVICE CONSTANT TABLE\n         LR    R14,R4                   (SEE ASSEMBLY OF IECZDTAB).\n         IC    R14,3(R2)           GET UNIT TYPE.\n         IC    R4,0(R14,R15)       PICK UP TABLE DISPLACEMENT.\n         ALR   R4,R15              DEVICE CONSTANT TABLE ADDRESS.\n         MVC   20(2,R8),12(R4)     MOVE NR. OF ALT. TRACKS.\nRDJ     RDJFCB  (DCBVR)\n         LTR   R15,R15             TEST COMPLETION CODE.\n         BNZ   ERO7                JFCB ERROR.\n         LA    R4,JF\n         USING JFCDSECT,R4\n         CLC   JFCBDSNM(L'GN1),GN1 TEST O.S. GENERATED DSNAME.\n         BNE   ERO8\n         CLC   JFCBDSNM+8(L'GN2),GN2\n         BNE   ERO8\n         CLC   JFCBDSNM+16(L'GN3),GN3\n         BNE   ERO8\n         LA    R2,GN4+L'GN4-1\n         LA    R3,L'GN4-1\nDSCL     CLI   0(R2),C' '\n         BNE   DSCLF\n         BCTR  R2,0\n         BCT   R3,DSCL\nDSCLF    EX    R3,DSCC\n         BE    JL0\n         B     ERO8\nDSCC     CLC   JFCBDSNM+22(*-*),GN4\nJL0      CLI   JFCBIND2,JFCOLD     TEST DISP=OLD CODED,\n         BNE   ERO8                BRANCH IF NOT.\nJL1      EQU   JFCBLTYP-JFCBTSDM\n         OC    JFCBTSDM(JL1),JFCBTSDM   CONTROL DD-CARD CODE.\n         BNZ   ERO8\nJL2      EQU   JFCBCRDT-JFCBOTTR\n         OC    JFCBOTTR(JL2),JFCBOTTR\n         BNZ   ERO8\nJL3      EQU   JFCBIND2-JFCBXPDT\n         OC    JFCBXPDT(JL3),JFCBXPDT\n         BNZ   ERO8\nJL4      EQU   JFCBNVOL-JFCBUFNO\n         OC    JFCBUFNO(JL4),JFCBUFNO\n         BNZ   ERO8\nJL5      EQU   JFCBVLCT-JFCBPQTY\n         OC    JFCBPQTY(JL5),JFCBPQTY\n         BNZ   ERO8\n         CLI   JFCBVLCT,X'01'\n         BNE   ERO8\n         CLI   JFCBLTYP,JFCSL\n         BNE   ERO8\n         CLI   JFCBNVOL,X'01'\n         BNE   ERO8\n         CLI   JFCBSPTN,X'00'\n         BNE   ERO8\n         LTR   R8,R8\n         BZ    *+L'*+6\n         MVC   22(6,R8),JFCBVOLS\n         SPACE 1\n         MVI   JFCBDSNM,X'04'      SET VTOC NAME.\n         MVC   JFCBDSNM+1(L'JFCBDSNM-1),JFCBDSNM\n         OI    JFCBTSDM,JFCNWRIT   INHIBIT WRITE BACK.\n         DROP  R4\n        OPEN   (DCBVR,(INOUT)),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULLY?\n         BZ    ERO2                BRANCH IF NOT.\n         DROP  R5\n         SR    R10,R10\n         B     EXIT\n         SPACE 1\nERO1     BCTR  R10,0\nERO2     BCTR  R10,0\nERO3     BCTR  R10,0\nERO4     BCTR  R10,0\nERO5     BCTR  R10,0\nERO6     BCTR  R10,0\nERO7     BCTR  R10,0\nERO8     BCTR  R10,0\nMAXERO   EQU   ((*-ERO1)/2)+1\n         B     EXIT\n         EJECT\nVTCLOSE  SR    R9,R9\n         LTR   R1,R1\n         BZ    CL1\n         LA    R10,MAXERC\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BZ    ERC1\n         TM    3(R1),X'03'\n         BNZ   ERC1\n         L     R9,0(R1)\n         LA    R9,0(R9)\n         SPACE 1\nCL1      LA    R5,DCBVR\n         USING IHADCB,R5\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED?\n         BZ    CL2                 BRANCH IF NOT.\n        CLOSE  (DCBVR)\n         DROP  R5\nCL2      SR    R10,R10\n         B     EXIT\n         SPACE 1\nERC1     BCTR  R10,0\nMAXERC   EQU   ((*-ERC1)/2)+1\n         SPACE 1\nEXIT     LTR   R9,R9\n         BZ    LEAVE\n         ST    R10,0(R9)\nLEAVE   $XRET  CC=(R10)\n         SPACE 1\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nATIOT    DC    A(*-*)\nDVTYP    DC    5F'0'\nZEROS    DC    F'0'\nJOBFILE  DC    0F'0',XL1'87',AL3(JF)\nJF       DC    0F'0',XL176'00'\nLWTO     DC    AL2(RWTO-*),XL2'8000'    WTO : TEXT LENGTH, MCS FLAGS.\nOPER     DC    C'     ... ERROR, MBBCCHHR='\nADDR     DC    XL16'0',C', ECB='\nCODE     DC    XL8'0',C', IOB-CSW='\nSTAT     DC    XL14'0',C'.'\nRWTO     DC    XL2'0200',XL2'0020'      WTO : DESC=7, ROUTCDE=11.\nTRTAB    DC    C'0123456789ABCDEF'\nXRM      DC    C'READ.'\nXWM      DC    C'WRITE'\nGN1      DC    C'SYS'\nGN2      DC    C'.T'\nGN3      DC    C'.RA'\nGN4      DC    CL11'.'\n         SPACE 2\nDCBVR    DCB   DSORG=DA,MACRF=E,DEVD=DA,RECFM=F,                       1\n               EXLST=JOBFILE,DDNAME=XXXXXXXX\n         SPACE 2\n        PRINT  NOGEN\n         SPACE 1\nTIODSECT DSECT\n        IEFTIOT1\n         SPACE 1\n        CVT    DSECT=YES,LIST=YES\nJFCDSECT DSECT\n        IEFJFCBN LIST=YES\n        DCBD   DSORG=PS,DEVD=DA\n        IEZIOB\n        IHAECB\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCD$": {"ttr": 38148, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "//VTOCD    JOB (........),'INSTALL  - VTOCD -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,MBR=VTOCD\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ALIAS   VTOCDW\n  ALIAS   VTOCDO\n  ALIAS   VTOCDC\n  NAME    VTOCDR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCD@": {"ttr": 38150, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14S\\x00\\x87\\x00\\x87\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:53:00", "lines": 135, "newlines": 135, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      VTOCD     1/4.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      VTOC DIRECT READ - WRITE       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Routine to read and/or write in direct mode a VTOC.\n  ---------    A DD-card, written as below, is needed to define\n               the desired volume :\n\n               //...     DD  UNIT=...,VOLUME=SER=...,DISP=OLD\n\n\n  Calling sequence : CALL VTOCDR,(A,B,C),VL\n  ------------------             (A,B)\n                                 (A)\n\n         Where : A - is the address of an array (format FULLWORD -\n                     F boundary) to read a DSCB's record (140 bytes\n                     long).\n\n                 B - is the address of the DSCB's record address read,\n                     in the format MBBCCHHR (format XL8).\n\n                 C - is the address of the indocator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - READ operation correctly executed.\n                      1 - READ error.\n                      2 - file not opened.\n                      3 - calling sequence or argument alignment error.\n\n  Assembler macro : $VTOCDR A,B,C\n  -----------------\n\n         Where C is optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/09/85\n                                                      VTOCD     2/4.\n\n  Calling sequence : CALL VTOCDW,(A,B,C),VL\n  ------------------             (A,B)\n                                 (A)\n\n         Where : A - is the address of an array (format FULLWORD -\n                     F boundary) containing a DSCB's record (140 bytes\n                     long) to write.\n\n                 B - is the address of the DSCB's record address to\n                     write, in the format MBBCCHHR (format XL8).\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - WRITE operation correctly executed.\n                      1 - WRITE error.\n                      2 - file not opened.\n                      3 - calling sequence or argument alignment error.\n\n  Assembler macro : $VTOCDW A,B,C\n  -----------------\n\n         Where C is optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/09/85\n                                                      VTOCD     3/4.\n\n  Calling sequence : CALL VTOCDO,(A,B,C),VL\n  ------------------             (A,B)\n                                 (A)\n\n         Where : A - is the address of the DD-name (format CL8).\n\n                 B - is the address of the device characteristics\n                     (format FULLWORD - F boundary) returned by the\n                     routine if supplied (optional). It will receive\n                     five fullwords information as described in DEVTYPE\n                     macro (see OS/VS2 System Programming Library :\n                     Data Management), followed by one halfword\n                     containing the number of alternate tracks for\n                     the device, followed by a six characters field\n                     containing the volume serial number of the\n                     device. This argument is optional and may be\n                     omitted or his address may be set to zero in the\n                     parameters list.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - OPEN correctly executed.\n                      1 - file already opened.\n                      2 - OPEN error.\n                      3 - calling sequence or argument alignment error.\n                      4 - not OS/VS2 System.\n                      5 - DD-card missing.\n                      6 - not direct-access storage device.\n                      7 - read JFCB error.\n                      8 - DD-card incorrectly coded.\n\n  Assembler macro : $VTOCDO A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   30/07/86\n                                                      VTOCD     4/4.\n\n  Calling sequence : CALL VTOCDC,(A),VL\n  ------------------\n\n         Where : A - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional :\n                     argument may be omitted passing a zero parameters\n                     list pointer - register 1). Value is always placed\n                     in register 15 and can be :\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence or argument alignment error.\n\n  Assembler macro : $VTOCDC A\n  -----------------\n\n         Where A is optional and may be omitted.\n         Register use may be coded within parentheses.\n\n\n  General notice : on error reading or writing a VTOC's DSCB a message\n  ================ is included in the message class for the job.\n                   This routine is only serially volumes usable.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VTOCQ": {"ttr": 38153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\x116\\x02\\x7f\\x02\\x7f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T11:36:00", "lines": 639, "newlines": 639, "modlines": 0, "user": "SYSPAJA"}, "text": "VTQR     TITLE 'VTOC QUICK READ SUBROUTINE.'\nVTOCQR   START 0\n         SPACE 2\n* PURPOSE :    THIS ROUTINE READS THE VOLUME TABLE OF CONTENTS (VTOC)\n* ---------    FROM A DIRECT-ACCESS DEVICE AND PRESENTS IT TO THE\n*              CALLER ONE RECORD (DSCB) AT A TIME (IT IS A SPECIAL\n*              SEQUENTIAL ACCESS METHOD FOR VTOC'S).\n*              ITS ADVANTAGE OVER ORDINARY BSAM IS THAT IT READS AN\n*              ENTIRE TRACK IN ONE REVOLUTION, THUS SAVING CONSIDERABLE\n*              TIME. A DD-CARD, WRITTEN AS BELOW, IS NEEDED TO DEFINE\n*              THE DESIRED VOLUME :\n*\n*              //...     DD  UNIT=...,VOLUME=SER=...,DISP=OLD\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n*\n* METHOD : USES EXCP TO EXECUTE A CHAINED CHANNEL PROGRAM TO READ\n* -------- AN ENTIRE TRACK AT A TIME.\n*\n* ORIGIN : THE ROUTINE IS BASED ON THE SOURCE OF 'XVTCREAD' SUBROUTINE\n* -------- OBTAINED FROM AMDAHL DISTRIBUTION (AMSRES).\n*          AUTHOR : R. F. MORSE, MIT INSTRUMENTATION LABORATORY.\n*          STATUS : VERSION 1, 5 AUGUST 1968.\n*\n* ATTRIBUTES : SERIALLY REUSABLE.\n* ------------\n*\n* GENERAL NOTICE : MVS/XA : MUST BE AMODE AND RMODE 24.\n* ================\n         EJECT\n* CALLING SEQUENCE : CALL VTOCQR,(A,B,C),VL\n* ------------------             (A,B)\n*                                (A)\n*\n*        WHERE : A - IS THE ADDRESS OF AN ARRAY (FORMAT FULLWORD -\n*                    F BOUNDARY) WHICH RECEIVES THE DSCB'S RECORD\n*                    (140 BYTES LONG).\n*\n*                B - IS THE ADDRESS OF THE CURRENT DSCB RECORD, IN THE\n*                    FORMAT MBBCCHHR (FORMAT XL8), RETURNED AFTER EACH\n*                    READ OPERATION, UNLESS WHEN THE END-OF-FILE IS\n*                    DETECTED OR A PSEUDO FORMAT 5 DSCB IS PASSED BACK\n*                    BY THE INDEXED VTOC INTERFACE ROUTINE (IXTOFMT5)\n*                    IF IT HAS BEEN GENERATED (MBBCCHHR IS SET TO\n*                    ALL X'FF'). THIS ARGUMENT IS OPTIONAL AND MAY BE\n*                    OMITTED OR HIS ADDRESS MAY BE SET TO ZERO IN THE\n*                    PARAMETERS LIST.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                    -1 - END-OF-FILE DETECTED. WHEN AN INDEXED VTOC\n*                         IS PROCESSED, AT END-OF-FILE RETURN, THE\n*                         REGISTER 0 POINTS TO TWO FULLWORDS WHICH ARE\n*                         CONTAINING THE COUNTS OF THE FREE (FMT 0)\n*                         DSCBS AND OF THE FREE VIRS RESPECTIVELY.\n*                         WITH NORMAL VTOC, REGISTER 0 IS SET TO ZERO.\n*                     0 - READ OPERATION CORRECTLY EXECUTED.\n*                     1 - READ ERROR.\n*                     2 - FILE NOT OPENED.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                    NN - INDEXED VTOC INTERFACE ROUTINE RETURN CODE\n*                         (IF IT HAS BEEN REQUESTED AT THE ASSEMBLY),\n*                         WITH R0 = ERROR INFORMATION (IXTOFMT5).\n*\n*                    NOTE - ON PERMANENT I/O ERROR, THE KEY AND DATA\n*                           AREAS WILL BE SET TO ZEROS, THE COUNT AREA\n*                           WILL CONTAIN THE CORRECT CCHHR. SINCE\n*                           READING IS DONE A TRACK AT A TIME, ALL\n*                           DSCB'S FOR THAT TRACK WILL BE MARKED IN\n*                           ERROR. READING MAY CONTINUE ON TO THE NEXT\n*                           TRACK.\n         EJECT\n* CALLING SEQUENCE : CALL VTOCQO,(A,B,C),VL\n* ------------------             (A,B)\n*                                (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8).\n*\n*                B - IS THE ADDRESS OF THE DEVICE CHARACTERISTICS\n*                    (FORMAT FULLWORD - F BOUNDARY) RETURNED BY THE\n*                    ROUTINE IF SUPPLIED (OPTIONAL). IT WILL RECEIVE\n*                    FIVE FULLWORDS INFORMATION AS DESCRIBED IN DEVTYPE\n*                    MACRO (SEE OS/VS2 SYSTEM PROGRAMMING LIBRARY :\n*                    DATA MANAGEMENT), FOLLOWED BY ONE HALFWORD\n*                    CONTAINING THE NUMBER OF ALTERNATE TRACKS FOR\n*                    THE DEVICE, FOLLOWED BY A SIX CHARACTERS FIELD\n*                    CONTAINING THE VOLUME SERIAL NUMBER OF THE\n*                    DEVICE. THIS ARGUMENT IS OPTIONAL AND MAY BE\n*                    OMITTED OR HIS ADDRESS MAY BE SET TO ZERO IN THE\n*                    PARAMETERS LIST.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - OPEN CORRECTLY EXECUTED.\n*                     1 - FILE ALREADY OPENED.\n*                     2 - OPEN ERROR.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - NOT OS/VS2 SYSTEM.\n*                     5 - DD-CARD MISSING.\n*                     6 - NOT DIRECT-ACCESS STORAGE DEVICE.\n*                     7 - READ JFCB ERROR.\n*                     8 - DD-CARD INCORRECTLY CODED.\n*\n* CALLING SEQUENCE : CALL VTOCQC,(A),VL\n* ------------------\n*\n*        WHERE : A - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL : ARGUMENT MAY BE\n*                    OMITTED PASSING A ZERO PARAMETERS LIST POINTER -\n*                    REGISTER 1). VALUE IS ALWAYS PLACED IN REGISTER 15\n*                    AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n         EJECT\n        $DEFREG\n         EJECT\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               SET SWITCH NOP OPERATION.\nON       EQU   X'F0'               SET SWITCH BRANCH OPERATION.\nUCB3DACC EQU   X'20'               DIRECT ACCESS DEVICE TYPE.\n         SPACE 1\n*        TAGS FOR CHANNEL COMMANDS AND FLAG BITS.\n         SPACE 1\nREADR0   EQU   X'16'               READ RECORD 0.\nREADCKD  EQU   X'1E'               READ COUNT, KEY, AND DATA.\n         SPACE 1\nCC       EQU   X'40'               COMMAND CHAIN FLAG.\nSLI      EQU   X'20'               SUPPRESS LENGTH INDICATION FLAG.\nSKIP     EQU   X'10'               SKIP DATA TRANSFER FLAG.\n         SPACE 1\n*        VTOC'S RECORDS DEFINITIONS.\n         SPACE 1\nCOUNT    EQU   8                   COUNT LENGTH.\nKEY      EQU   44                  KEY LENGTH PORTION.\nDATA     EQU   96                  DATA LENGTH PORTION.\n         EJECT\n         ENTRY VTOCQO\n         ENTRY VTOCQC\n         SPACE 1\n         USING *,R15\n         MVI   WTGO+3,VTOCQ-*      SET ENTRY DISPLACEMENT (READ).\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nVTOCQO   MVI   WTGO+3,VTOCQ-*      SET ENTRY DISPLACEMENT (OPEN).\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nVTOCQC   MVI   WTGO+3,VTOCQ-*      SET ENTRY DISPLACEMENT (CLOSE).\n         DROP  R15\n         SPACE 1\nWTGO     LA    R15,*-*(R15)        SET COMMON ENTRY ADDRESS.\n         SPACE 1\nVTOCQ   $XENT BASE=R12\n         LR    R15,R12             COMPUTE WHERE TO GO?\n         BCTR  R15,0\n         SR    R14,R14\n         IC    R14,0(R15)\n         SRL   R14,1\n         B     *+L'*-(VTOCQ-WTGO)+0(R14) ENTER SELECTED ROUTINE.\n         SPACE 1\n         B     VTCLOSE             BRANCH ENTRIES VECTOR.\n         B     VTOPEN\n         EJECT\n         SR    R9,R9\n         SR    R8,R8\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    RD2\n         TM    4(R1),X'80'\n         BO    RD1\n         TM    8(R1),X'80'\n         BZ    ERR3\n         TM    11(R1),X'03'\n         BNZ   ERR3\n         L     R9,8(R1)\n         LA    R9,0(R9)\nRD1      L     R8,4(R1)\n         LA    R8,0(R8)\nRD2      TM    3(R1),X'03'\n         BNZ   ERR3\n         L     R7,0(R1)\n         LA    R7,0(R7)\n         SPACE 1\n         LA    R6,DCBVR\n         USING IHADCB,R6\n         TM    DCBOFLGS,DCBOFOPN   TEST IF OPENED?\n         BZ    ERR2                BRANCH IF NOT.\n         AIF   ('&SYSPARM' EQ 'OLD').O1S1\nSWIX1    NOP   IX01\n.O1S1    L     R2,DSCBADR          LOAD BUFFER POINTER.\n         C     R2,DSCBLIM          LAST DSCB IN BUFFER?\n         BNH   NDXSTORE            BRANCH IF NOT.\n         NI    SWR+1,OFF\n         STM   R6,R13,EXCPSAVE     SAVE IMPORTANT REGISTERS.\n         L     R0,TTRN             LOAD RELATIVE TRACK NUMBER.\n         L     R1,DCBDEBAD         LOAD DEB ADDRESS.\n         DROP  R6\n         LA    R2,IOBSEEK          LOAD ADDR TO RECEIVE MBBCCHHR.\n         L     R15,CVTPTR          LOAD CVT ADDRESS.\n         USING CVT,R15\n         L     R15,CVTPCNVT        LOAD ADDRESS OF CONVERT ROUTINE.\n         DROP  R15\n         BASR  R14,R15             CONVERT TTRN TO MBBCCHHR.\n         DROP  R12                 THAT CLOBBERED BASE REGISTER.\n         USING *,R14               REGISTER 14 SET BY BASR ABOVE.\n         LM    R6,R13,EXCPSAVE     RESTORE REGISTERS.\n         DROP  R14\n         USING VTOCQ,R12           BASE REGISTER RECOVERED.\n         LTR   R15,R15             TEST IF EXTENT VIOLATED (RC=4).\n         BNZ   ENDVT               IF SO, MEANS END-OF-FILE.\n         SR    R0,R0\n         ST    R0,ECBVR            CLEAR ECB.\n        EXCP   IOBVR               START CHANNEL PROGRAM.\n        WAIT   ECB=ECBVR           WAIT FOR COMPLETION.\n         CLI   ECBVR,X'7F'         TEST COMPLETION CODE.\n         BNE   PERMERR             BRANCH IF ERROR.\n         L     R3,TTRN             LOAD RELATIVE TRACK NUMBER.\n         AL    R3,=X'00010000'     INCREMENT TO NEXT TRACK.\n         ST    R3,TTRN\nSETDSCBA L     R2,DSCBSTRT         SET BUFFER POINTER TO 1ST DSCB.\nNDXSTORE MVC   0(KEY+DATA,R7),8(R2) PASS DSCB TO USER.\n         LTR   R8,R8\n         BZ    NEXT\n         XC    0(8,R8),0(R8)       CLEAR MBBCCHHR.\n         MVC   3(5,R8),0(R2)       PASS CCHHR.\nNEXT     LA    R2,COUNT+KEY+DATA(R2) ADVANCE TO NEXT DSCB.\n         ST    R2,DSCBADR          STORE UPDATED POINTER.\nSWR      B     ERR1\n         AIF   ('&SYSPARM' EQ 'OLD').O1S2\nSWIX2    NOP   IX05\n         USING IECSDSL5,R7\n         CLI   DS5FMTID,C'5'       FORMAT 5 DSCB?\n         BNE   IX05\n         XC    IXWORD,IXWORD       FIRST ENTRY.\nIX01     ST    R7,IXFMT5A          AREA FOR FMT5.\n         L     R1,4(R13)           PREVIOUS SAVE AREA ADDRESS.\n         XC    20(4,R1),20(R1)     SET R0 VALUE TO GO BACK.\n         LA    R1,IXPARM           POINT TO PARMLIST.\n         L     R15,IXVCON          ROUTINE ADDRESS.\n         BASR  R14,R15             CALL INTERFACE ROUTINE.\n         LTR   R10,R15             INDEXED VTOC?\n         BNZ   SWIX3               NO.\n         OC    DS5PTRDS,DS5PTRDS   LAST FMT5 FROM IX INTERFACE?\n         BZ    IX02                YES.\n         OI    SWIX1+1,ON          NO, SET TO GET NEXT.\n         OI    SWIX3+1,ON\n         B     IX03\nIX02     NI    SWIX1+1,OFF\n         OI    SWIX2+1,ON\n         NI    SWIX4+1,OFF\nIX03     LTR   R8,R8\n         BZ    EXIT\n         MVI   0(R8),X'FF'\n         MVC   1(7,R8),0(R8)\n         B     EXIT\n         DROP  R7\nSWIX3    NOP   IX04\n         CH    R10,NOTIXCC         VTOC IS NOT INDEXED FORMAT?\n         BE    IX05                YES, NORMAL VTOC.\nIX04     NI    SWIX1+1,OFF         NO, ERROR OCCURED.\n         OI    SWIX2+1,ON\n         OI    SWIX3+1,ON\n         OI    SWIX4+1,ON\n         L     R1,4(R13)           PREVIOUS SAVE AREA ADDRESS.\n         ST    R0,20(R1)           SET R0 = ERROR INFORMATION.\n         B     EXIT\nIX05     SR    R10,R10\n         AGO   .O1S3\n.O1S2    SR    R10,R10\n.O1S3    B     EXIT\n         EJECT\n* PERMANENT ERROR :\n* -----------------\n*\n*        ZEROES THE DSCB'S AND FILLS IN THE CCHHR PORTIONS OF THE\n*        COUNT AREAS FOR THIS TRACK.\n         SPACE 1\nPERMERR  OI    SWR+1,ON            SIGNAL READ ERROR.\n         NI    IOBFLAG1,X'FB'      TURN OFF BIT 5 OF IOB FLAG.\n         USING IHADCB,R6\n         NI    DCBIFLGS,X'3F'      TURN OFF BITS 0 AND 1.\n         DROP  R6\n         L     R2,DSCBSTRT         LOAD ADDRESS OF FIRST DSCB.\n         LA    R3,1                LOAD RECORD NUMBER.\nDSCBELUP XC    0(COUNT+KEY+DATA,R2),0(R2) ZERO DSCB BUFFER.\n         MVC   0(4,R2),IOBSEEK+3   INSERT CCHH IN COUNT FIELD.\n         STC   R3,4(R2)            INSERT R IN COUNT FIELD.\n         LA    R2,COUNT+KEY+DATA(R2) POINT TO NEXT BUFFER.\n         LA    R3,1(R3)            INCREMENT RECORD NUMBER.\n         C     R2,DSCBLIM          TEST FOR LAST BUFFER.\n         BNH   DSCBELUP\n         B     SETDSCBA            BRANCH TO RESET BUFFER POINTER.\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nMAXERR   EQU   ((*-ERR1)/2)+1\n         AIF   ('&SYSPARM' EQ 'OLD').O1S4\n         L     R1,4(R13)           PREVIOUS SAVE AREA ADDRESS.\n         XC    20(4,R1),20(R1)     SET R0 VALUE TO GO BACK.\n         B     IXRST\n         AGO   .O1S5\n.O1S4    B     EXIT\n.O1S5    EJECT\n* END-OF-FILE :\n* -------------\n*\n*        CLOSE VTOC'S FILE AND RELEASE BUFFERS CORE.\n         SPACE 1\nENDVT   CLOSE  (DCBVR)\n         LM    R0,R1,CBSIZE        LOAD SIZE AND LOCATION.\n        FREEMAIN  R,LV=(0),A=(1)   FREE CORE.\n         SR    R10,R10\n         BCTR  R10,0\n         L     R1,4(R13)           PREVIOUS SAVE AREA ADDRESS.\n         XC    20(4,R1),20(R1)     SET R0 VALUE TO GO BACK.\n         AIF   ('&SYSPARM' EQ 'OLD').O1S6\nSWIX4    B     IXRST\n         LA    R0,IXCT1\n         ST    R0,20(R1)           PASS COUNTS ADDRESS IN R0.\nIXRST    NI    SWIX1+1,OFF         RESET INDEXED VTOC SWITCHES.\n         NI    SWIX2+1,OFF\n         NI    SWIX3+1,OFF\n         OI    SWIX4+1,ON\n.O1S6    B     EXIT\n         EJECT\nVTOPEN   SR    R9,R9\n         SR    R8,R8\n         AIF   ('&SYSPARM' EQ 'OLD').O2S1\n         NI    SWIX1+1,OFF         RESET INDEXED VTOC SWITCHES.\n         NI    SWIX2+1,OFF\n         NI    SWIX3+1,OFF\n         OI    SWIX4+1,ON\n.O2S1    LA    R10,MAXERO\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    OP2\n         TM    4(R1),X'80'\n         BO    OP1\n         TM    8(R1),X'80'\n         BZ    ERO3\n         TM    11(R1),X'03'\n         BNZ   ERO3\n         L     R9,8(R1)\n         LA    R9,0(R9)\nOP1      TM    7(R1),X'03'\n         BNZ   ERO3\n         L     R8,4(R1)\n         LA    R8,0(R8)\nOP2      L     R7,0(R1)\n         LA    R7,0(R7)\n         SPACE 1\n         OC    ATIOT(L'ATIOT),ATIOT FISRT TIME?\n         BNZ   GOT                 BRANCH IF NOT.\n         L     R2,CVTPTR           GET CVT ADDRESS.\n         USING CVT,R2\n         TM    CVTDCB,CVT4MS1      TEST IF OS/VS2?\n         BZ    ERO4                BRANCH IF NOT.\n         DROP  R2\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\n         L     R2,ATIOT\n         USING TIODSECT,R2\n         MVC   GN4+1(L'TIOCNJOB),TIOCNJOB\n         DROP  R2\n         LA    R2,GN4+L'GN4-3\n         LA    R3,L'GN4-1\nDSOL     CLI   0(R2),C' '\n         BNE   DSOLF\n         BCTR  R2,0\n         BCT   R3,DSOL\nDSOLF    MVC   1(2,R2),GN3\n         SPACE 1\nGOT      L     R2,ATIOT            GET TIOT ADDRESS.\n         USING TIODSECT,R2\n         LA    R5,DCBVR            SEARCH DD-CARD.\n         USING IHADCB,R5\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED?\n         BO    ERO1                BRANCH IF YES.\n         MVC   DCBDDNAM(L'DCBDDNAM),0(R7)\nSRCH     CLC   TIOELNGH(L'ZEROS),ZEROS END OF TIOT?\n         BE    ERO5                YES.\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM DD-NAME FOR US?\n         BE    FOUND               YES.\n         SR    R1,R1\n         IC    R1,TIOELNGH\n         AR    R2,R1               NEXT DD ENTRY.\n         B     SRCH\n         DROP  R2\nFOUND    XC    DVTYP(20),DVTYP\n        DEVTYPE  DCBDDNAM,DVTYP,DEVTAB\n         CLI   DVTYP+2,UCB3DACC    TEST IF DIRECT-ACCESS STORAGE.\n         BNE   ERO6                BRANCH IF NOT.\n         LTR   R8,R8\n         BZ    RDJ\n         MVC   0(20,R8),DVTYP      PASS DEVICE TABLE.\n         L     R4,CVTPTR           GET CVT POINTER.\n         USING CVT,R4\n         L     R15,CVTZDTAB        ADDRESS OF IECZDTAB.\n         DROP  R4\n         LA    R15,0(0,R15)        IECZDTAB IS THE RESIDENT DIRECT\n         SR    R4,R4                    ACCESSS DEVICE CONSTANT TABLE\n         LR    R14,R4                   (SEE ASSEMBLY OF IECZDTAB).\n         IC    R14,DVTYP+3         GET UNIT TYPE.\n         IC    R4,0(R14,R15)       PICK UP TABLE DISPLACEMENT.\n         ALR   R4,R15              DEVICE CONSTANT TABLE ADDRESS.\n         MVC   20(2,R8),12(R4)     MOVE NR. OF ALT. TRACKS.\nRDJ      SR    R2,R2\n         IC    R2,DVTYP+3          GET UNIT TYPE.\n         L     R3,RKDDW            KEYED BLOCK LENGTH.\n        TRKCALC FUNCTN=TRKCAP,TYPE=(R2),RKDD=(R3),REGSAVE=YES\n         LTR   R15,R15             DOES RECORD FIT ON TRACK?\n         BNZ   ERO6                BRANCH IF NOT.\n         ST    R0,NDSCBS           STORE NUMBER OF DSCB'S/TRACK.\n        RDJFCB  (DCBVR)\n         LTR   R15,R15             TEST COMPLETION CODE.\n         BNZ   ERO7                JFCB ERROR.\n         LA    R4,JF\n         USING JFCDSECT,R4\n         CLC   JFCBDSNM(L'GN1),GN1 TEST O.S. GENERATED DSNAME.\n         BNE   ERO8\n         CLC   JFCBDSNM+8(L'GN2),GN2\n         BNE   ERO8\n         CLC   JFCBDSNM+16(L'GN3),GN3\n         BNE   ERO8\n         LA    R2,GN4+L'GN4-1\n         LA    R3,L'GN4-1\nDSCL     CLI   0(R2),C' '\n         BNE   DSCLF\n         BCTR  R2,0\n         BCT   R3,DSCL\nDSCLF    EX    R3,DSCC\n         BE    JL0\n         B     ERO8\nDSCC     CLC   JFCBDSNM+22(*-*),GN4\nJL0      CLI   JFCBIND2,JFCOLD     TEST DISP=OLD CODED,\n         BNE   ERO8                BRANCH IF NOT.\nJL1      EQU   JFCBLTYP-JFCBTSDM\n         OC    JFCBTSDM(JL1),JFCBTSDM   CONTROL DD-CARD CODE.\n         BNZ   ERO8\nJL2      EQU   JFCBCRDT-JFCBOTTR\n         OC    JFCBOTTR(JL2),JFCBOTTR\n         BNZ   ERO8\nJL3      EQU   JFCBIND2-JFCBXPDT\n         OC    JFCBXPDT(JL3),JFCBXPDT\n         BNZ   ERO8\nJL4      EQU   JFCBNVOL-JFCBUFNO\n         OC    JFCBUFNO(JL4),JFCBUFNO\n         BNZ   ERO8\nJL5      EQU   JFCBVLCT-JFCBPQTY\n         OC    JFCBPQTY(JL5),JFCBPQTY\n         BNZ   ERO8\n         CLI   JFCBVLCT,X'01'\n         BNE   ERO8\n         CLI   JFCBLTYP,JFCSL\n         BNE   ERO8\n         CLI   JFCBNVOL,X'01'\n         BNE   ERO8\n         CLI   JFCBSPTN,X'00'\n         BNE   ERO8\n         LTR   R8,R8\n         BZ    *+L'*+6\n         MVC   22(6,R8),JFCBVOLS\n         SPACE 1\n         MVI   JFCBDSNM,X'04'      SET VTOC NAME.\n         MVC   JFCBDSNM+1(L'JFCBDSNM-1),JFCBDSNM\n         OI    JFCBTSDM,JFCNWRIT   INHIBIT WRITE BACK.\n         DROP  R4\n        OPEN   (DCBVR,(INPUT)),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULLY?\n         BZ    ERO2                BRANCH IF NOT.\n         DROP  R5\n         LA    R0,L'READCCW+COUNT+KEY+DATA CORE FOR A DSCB AND CCW'S.\n         MH    R0,NDSCBS+2         TIMES NUMBER PER TRACK.\n         AH    R0,=H'15'           PLUS 1 CCW AND ROUNDING.\n         N     R0,=X'FFFFFFF8'     ROUND TO DOUBLE-WORD MULTIPLE.\n         ST    R0,CBSIZE           SAVE SIZE OF GOTTEN CORE.\n        GETMAIN  R,LV=(0)          GET TRACK BUFFERS.\n         ST    R1,CBADDR           SAVE ADDRESS OF GOTTEN CORE.\n         SPACE 1\n* GENERATE CHANNEL PROGRAM :\n* --------------------------\n*\n*        IT CONSISTS OF A 'READ R0' ORDER WITH THE SKIP FLAG ON,\n*        FOLLOWED BY A 'READ COUNT-KEY-AND-DATA' ORDER FOR EACH DSCB.\n         SPACE 1\n         L     R2,NDSCBS           NUMBER OF DSCB'S.\n         SLL   R2,3                TIMES 8.\n         LA    R2,L'INITCCW(R2,R1) + 1ST CCW + BASE = 1ST BUFFER ADDR.\n         ST    R2,DSCBSTRT         SAVE ADDRESS OF FIRST BUFFER.\n         ST    R1,IOBSTART         ADDRESS OF CHANNEL PROGRAM.\n         MVC   0(L'INITCCW,R1),INITCCW INSERT FIRST CCW.\n         LA    R3,L'INITCCW(R1)    PLACE FOR NEXT CCW.\n         LA    R4,1                BUFFER COUNTER.\nCCWLOOP  MVC   0(L'READCCW,R3),READCCW INSERT READ CCW FOR ONE DSCB.\n         ST    R2,0(R3)            SET ITS BUFFER ADDRESS.\n         MVI   0(R3),READCKD       RESTORE COMMAND CODE.\n         C     R4,NDSCBS           TEST BUFFER COUNTER.\n         BNL   LASTCCW             BRANCH IF LAST BUFFER.\n         LA    R3,L'READCCW(R3)    INCREMENT CCW ADDRESS.\n         LA    R2,COUNT+KEY+DATA(R2) INCREMENT BUFFER ADDRESS.\n         LA    R4,1(R4)            INCREMENT BUFFER COUNTER.\n         B     CCWLOOP             DO NEXT BUFFER.\nLASTCCW  NI    4(R3),X'FF'-CC      TURN OFF COMMAND CHAIN BIT.\n         ST    R2,DSCBLIM          SAVE ADDRESS OF LAST DSCB BUFFER.\n         LA    R2,COUNT+KEY+DATA(R2) INCREMENT BUFFER ADDRESS.\n         ST    R2,DSCBADR          STORE POINTER TO FORCE READ.\n         SR    R0,R0\n         ST    R0,TTRN             SET RELATIVE TRACK NUMBER TO 0.\n         SR    R10,R10\n         B     EXIT\n         SPACE 1\nERO1     BCTR  R10,0\nERO2     BCTR  R10,0\nERO3     BCTR  R10,0\nERO4     BCTR  R10,0\nERO5     BCTR  R10,0\nERO6     BCTR  R10,0\nERO7     BCTR  R10,0\nERO8     BCTR  R10,0\nMAXERO   EQU   ((*-ERO1)/2)+1\n         B     EXIT\n         EJECT\nVTCLOSE  SR    R9,R9\n         AIF   ('&SYSPARM' EQ 'OLD').O3S1\n         NI    SWIX1+1,OFF         RESET INDEXED VTOC SWITCHES.\n         NI    SWIX2+1,OFF\n         NI    SWIX3+1,OFF\n         OI    SWIX4+1,ON\n.O3S1    LTR   R1,R1\n         BZ    CL1\n         LA    R10,MAXERC\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BZ    ERC1\n         TM    3(R1),X'03'\n         BNZ   ERC1\n         L     R9,0(R1)\n         LA    R9,0(R9)\n         SPACE 1\nCL1      LA    R5,DCBVR\n         USING IHADCB,R5\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED?\n         BZ    CL2                 BRANCH IF NOT.\n        CLOSE  (DCBVR)\n         DROP  R5\n         LM    R0,R1,CBSIZE        LOAD SIZE AND LOCATION.\n        FREEMAIN  R,LV=(0),A=(1)   FREE CORE.\nCL2      SR    R10,R10\n         B     EXIT\n         SPACE 1\nERC1     BCTR  R10,0\nMAXERC   EQU   ((*-ERC1)/2)+1\n         SPACE 1\nEXIT     LTR   R9,R9\n         BZ    LEAVE\n         ST    R10,0(R9)\nLEAVE   $XRET  CC=(R10)\n         SPACE 2\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nINITCCW  CCW   READR0,0,CC+SLI+SKIP,8\nREADCCW  CCW   READCKD,0,CC,COUNT+KEY+DATA\n         SPACE 1\nEXCPSAVE DC    8F'0'\n         SPACE 1\nATIOT    DC    A(*-*)\nDVTYP    DC    5F'0'\nCBSIZE   DC    F'0'                SIZE AND\nCBADDR   DC    F'0'                     LOCATION OF GOTTEN CORE.\nNDSCBS   DC    F'0'                NUMBER OF DSCB'S PER TRACK.\nDSCBSTRT DC    F'0'                ADDRESS OF 1ST DSCB BUFFER.\nDSCBLIM  DC    F'0'                ADDRESS OF LAST DSCB BUFFER.\nDSCBADR  DC    F'0'                ADDRESS OF CURRENT DSCB.\nTTRN     DC    F'0'                RELATIVE TRACK NUMBER.\nZEROS    DC    F'0'\nJOBFILE  DC    0F'0',XL1'87',AL3(JF)\nJF       DC    0F'0',XL176'00'\nGN1      DC    C'SYS'\nGN2      DC    C'.T'\nGN3      DC    C'.RA'\nGN4      DC    CL11'.'\n         SPACE 2\nIOBVR    DS    0D                  IOB FOR CHANNEL PROGRAM.\nIOBFLAG1 DC    X'42000000'         COMMAND CHAIN, NOT RELATED.\n         DC    A(ECBVR)\n         DC    2F'0'\nIOBSTART DC    A(0)                CHANNEL PROGRAM BEGINNING.\n         DC    A(DCBVR)\n         DC    X'03000000'\n         DC    F'0'\nIOBSEEK  DC    D'0'                INITIAL SEEK ADDRESS.\n         SPACE 2\nECBVR    DC    F'0'                EVENT CONTROL BLOCK.\n         SPACE 2\nRKDDW    DC    0F'0',AL1(1,KEY),AL2(DATA)\n         EJECT\nDCBVR    DCB   MACRF=(E),EXLST=JOBFILE,DDNAME=XXXXXXXX\n         SPACE 2\n         AIF   ('&SYSPARM' EQ 'OLD').O10S1\n         EJECT\nIXPARM   DC    A(IXWORD)           WORK WORD.\n         DC    A(DCBVR)            OPEN DCB.\n         DC    A(IXCT1)            COUNT OF FREE DSCB'S.\n         DC    A(IXCT2)            COUNT OF FREE VIRS.\nIXFMT5A  DC    A(*-*)              POINTER TO PSEUDO FMT5.\n         SPACE 1\nIXVCON   DC    V(IXTOFMT5)\nIXWORD   DC    F'0'\nIXCT1    DC    F'0'\nIXCT2    DC    F'0'\nNOTIXCC  DC    H'4'\n         SPACE 2\n.O10S1   LTORG\n         SPACE 2\n        PRINT  NOGEN\n         SPACE 1\nTIODSECT DSECT\n        IEFTIOT1\n        CVT    DSECT=YES,LIST=YES\nJFCDSECT DSECT\n        IEFJFCBN LIST=YES\n        DCBD   DSORG=PS,DEVD=DA\n         AIF   ('&SYSPARM' EQ 'OLD').O99S1\n         DSECT\n        IECSDSL1 (5)               FORMAT 5 DSCB.\n.O99S1   SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCQ$": {"ttr": 38407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14%\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:25:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SYSPAJA"}, "text": "//VTOCQ    JOB (........),'INSTALL  - VTOCQ -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION FOR USE :                      *\n//*                IXTOFMT5                                           *\n//* NOTES : 1. SPECIFY SYSPARM(OLD) AT ASSEMBLY STEP 'ASS' IF YOU     *\n//*            DON'T HAVE INDEXED VTOC IN YOUR SYSTEM (IN THIS CASE,  *\n//*            IGNORE THE PRE-REQUISITE).                             *\n//*            BY DEFAULT, YOU OBTAIN A VERSION FOR BOTH VTOC TYPES.  *\n//*                 I.E. : OPT=',SYSPARM(OLD)'                        *\n//*         2. AT LINK-EDIT YOU MAY RECEIVE A RETURN CODE 4 WHICH IS  *\n//*            ONLY A NORMAL WARNING MESSAGE DUE TO NCAL SPECIFIED.   *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=VTOCQ\n//LNK     EXEC PAJILKR,OPT=',NCAL'\n//SYSIN     DD *\n  ALIAS   VTOCQO\n  ALIAS   VTOCQC\n  NAME    VTOCQR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCQ@": {"ttr": 38409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14S\\x00\\x85\\x00\\x85\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:53:00", "lines": 133, "newlines": 133, "modlines": 0, "user": "SYSPAJA"}, "text": "1   18/06/87\n                                                      VTOCQ     1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     VTOC QUICK SEQUENTIAL READ      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    This routine reads the Volume Table of Contents (VTOC)\n  ---------    from a direct-access device and presents it to the\n               caller one record (DSCB) at a time (it is a special\n               sequential access method for VTOC's).\n               Its advantage over ordinary BSAM is that it reads an\n               entire track in one revolution, thus saving considerable\n               time. A DD-card, written as below, is needed to define\n               the desired volume :\n\n               //...     DD  UNIT=...,VOLUME=SER=...,DISP=OLD\n\n  Calling sequence : CALL VTOCQR,(A,B,C),VL\n  ------------------             (A,B)\n                                 (A)\n\n         Where : A - is the address of an array (format FULLWORD -\n                     F boundary) which receives the DSCB's record\n                     (140 bytes long).\n\n                 B - is the address of the current DSCB record, in the\n                     format MBBCCHHR (format XL8), returned after each\n                     read operation, unless when the END-OF-FILE is\n                     detected or a pseudo format 5 DSCB is passed back\n                     by the indexed VTOC interface routine (IXTOFMT5)\n                     if it has been generated (the MBBCCHHR is set to\n                     all x'FF'). This argument is optional and may be\n                     omitted or his address may be set to zero in the\n                     parameters list.\n\n                 C - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional). Value is always\n                     placed in register 15 and can be :\n\n                     -1 - END-OF-FILE detected. When an indexed VTOC is\n                          processed, at END-OF-FILE return, the register\n                          0 points to two fullwords which are containing\n                          the counts of the free (FMT 0) DSCBs and the\n                          free VIRS respectively.\n                          With normal VTOC, register 0 is set to zero.\n                      0 - READ operation correctly executed.\n                      1 - READ error.\n                      2 - file not opened.\n                      3 - calling sequence or argument alignment error.\n                     NN - indexed VTOC interface routine return code\n                          (if it has been requested at the assembly),\n                          with R0 = error information (IXTOFMT5).\n1   29/01/87\n                                                      VTOCQ     2/3.\n\n                     Note - on permanent I/O error, the KEY and DATA\n                            areas will be set to zeros, The COUNT area\n                            will contain the correct CCHHR. Since\n                            reading is done a track at a time, all\n                            DSCB's for that track will be marked in\n                            error. Reading may continue on to the next\n                            track.\n\n  Assembler macro : $VTOCQR A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  Calling sequence : CALL VTOCQO,(A,B,C),VL\n  ------------------             (A,B)\n                                 (A)\n\n         Where : A - is the address of the DD-name (format CL8).\n\n                 B - is the address of the device characteristics\n                     (format FULLWORD - F boundary) returned by the\n                     routine if supplied (optional). It will receive\n                     five fullwords information as described in DEVTYPE\n                     macro (see OS/VS2 System Programming Library :\n                     Data Management), followed by one halfword\n                     containing the number of alternate tracks for\n                     the device, followed by a six characters field\n                     containing the volume serial number of the\n                     device. This argument is optional and may be\n                     omitted or his address may be set to zero in the\n                     parameters list.\n\n                 C - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional). Value is always\n                     placed in register 15 and can be :\n\n                      0 - OPEN correctly executed.\n                      1 - file already opened.\n                      2 - OPEN error.\n                      3 - calling sequence or argument alignment error.\n                      4 - not OS/VS2 System.\n                      5 - DD-card missing.\n                      6 - not direct-access storage device.\n                      7 - read JFCB error.\n                      8 - DD-card incorrectly coded.\n\n  Assembler macro : $VTOCQO A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   30/07/86\n                                                      VTOCQ     3/3.\n\n  Calling sequence : CALL VTOCQC,(A),VL\n  ------------------\n\n         Where : A - is the indicator response (format FULLWORD - F\n                     boundary) if supplied (optional : argument may be\n                     omitted passing a zero parameters list pointer -\n                     register 1). Value is always placed in register 15\n                     and can be :\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence or argument alignment error.\n\n  Assembler macro : $VTOCQC A\n  -----------------\n\n         Where A is optional and may be omitted.\n         Register use may be coded within parentheses.\n\n  General notice : this routine is only serially volumes usable.\n  ----------------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VTOCS": {"ttr": 38412, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\x11W\\x01\\xec\\x01\\xec\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T11:57:00", "lines": 492, "newlines": 492, "modlines": 0, "user": "SYSPAJA"}, "text": "VTSR     TITLE 'VTOC SEQUENTIAL READ SUBROUTINE.'\nVTOCSR   START 0\n         SPACE 2\n* PURPOSE :    ROUTINE TO READ SEQUENTIALLY AN ENTIRE VTOC.\n* ---------    A DD-CARD, WRITTEN AS BELOW, IS NEEDED TO DEFINE\n*              THE DESIRED VOLUME :\n*\n*              //...     DD  UNIT=...,VOLUME=SER=...,DISP=OLD\n*\n* CALLING SEQUENCE : CALL VTOCSR,(A,B,C),VL\n* ------------------             (A,B)\n*                                (A)\n*\n*        WHERE : A - IS THE ADDRESS OF AN ARRAY (FORMAT FULLWORD -\n*                    F BOUNDARY) WHICH RECEIVES THE DSCB'S RECORD\n*                    (140 BYTES LONG).\n*\n*                B - IS THE ADDRESS OF THE CURRENT DSCB RECORD, IN THE\n*                    FORMAT MBBCCHHR (FORMAT XL8), RETURNED AFTER EACH\n*                    READ OPERATION, UNLESS WHEN THE END-OF-FILE IS\n*                    DETECTED OR A PSEUDO FORMAT 5 DSCB IS PASSED BACK\n*                    BY THE INDEXED VTOC INTERFACE ROUTINE (IXTOFMT5)\n*                    IF IT HAS BEEN GENERATED (MBBCCHHR IS SET TO\n*                    ALL X'FF'). THIS ARGUMENT IS OPTIONAL AND MAY BE\n*                    OMITTED OR HIS ADDRESS MAY BE SET TO ZERO IN THE\n*                    PARAMETERS LIST.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                    -1 - END-OF-FILE DETECTED. WHEN AN INDEXED VTOC\n*                         IS PROCESSED, AT END-OF-FILE RETURN, THE\n*                         REGISTER 0 POINTS TO TWO FULLWORDS WHICH ARE\n*                         CONTAINING THE COUNTS OF THE FREE (FMT 0)\n*                         DSCBS AND OF THE FREE VIRS RESPECTIVELY.\n*                         WITH NORMAL VTOC, REGISTER 0 IS SET TO ZERO.\n*                     0 - READ OPERATION CORRECTLY EXECUTED.\n*                     1 - READ ERROR.\n*                     2 - FILE NOT OPENED.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                    NN - INDEXED VTOC INTERFACE ROUTINE RETURN CODE\n*                         (IF IT HAS BEEN REQUESTED AT THE ASSEMBLY),\n*                         WITH R0 = ERROR INFORMATION (IXTOFMT5).\n*\n* GENERAL NOTICE : ON ERROR READING A VTOC'S DSCB A MESSAGE IS INCLUDED\n* ---------------- IN THE MESSAGE CLASS FOR THE JOB.\n*                  MVS/XA : MUST BE AMODE AND RMODE 24.\n         EJECT\n* CALLING SEQUENCE : CALL VTOCSO,(A,B,C),VL\n* ------------------             (A,B)\n*                                (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE DD-NAME (FORMAT CL8).\n*\n*                B - IS THE ADDRESS OF THE DEVICE CHARACTERISTICS\n*                    (FORMAT FULLWORD - F BOUNDARY) RETURNED BY THE\n*                    ROUTINE IF SUPPLIED (OPTIONAL). IT WILL RECEIVE\n*                    FIVE FULLWORDS INFORMATION AS DESCRIBED IN DEVTYPE\n*                    MACRO (SEE OS/VS2 SYSTEM PROGRAMMING LIBRARY :\n*                    DATA MANAGEMENT), FOLLOWED BY ONE HALFWORD\n*                    CONTAINING THE NUMBER OF ALTERNATE TRACKS FOR\n*                    THE DEVICE, FOLLOWED BY A SIX CHARACTERS FIELD\n*                    CONTAINING THE VOLUME SERIAL NUMBER OF THE\n*                    DEVICE. THIS ARGUMENT IS OPTIONAL AND MAY BE\n*                    OMITTED OR HIS ADDRESS MAY BE SET TO ZERO IN THE\n*                    PARAMETERS LIST.\n*\n*                C - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL). VALUE IS ALWAYS\n*                    PLACED IN REGISTER 15 AND CAN BE :\n*\n*                     0 - OPEN CORRECTLY EXECUTED.\n*                     1 - FILE ALREADY OPENED.\n*                     2 - OPEN ERROR.\n*                     3 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*                     4 - NOT OS/VS2 SYSTEM.\n*                     5 - DD-CARD MISSING.\n*                     6 - NOT DIRECT-ACCESS STORAGE DEVICE.\n*                     7 - READ JFCB ERROR.\n*                     8 - DD-CARD INCORRECTLY CODED.\n*\n* CALLING SEQUENCE : CALL VTOCSC,(A),VL\n* ------------------\n*\n*        WHERE : A - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F\n*                    BOUNDARY) IF SUPPLIED (OPTIONAL : ARGUMENT MAY BE\n*                    OMITTED PASSING A ZERO PARAMETERS LIST POINTER -\n*                    REGISTER 1). VALUE IS ALWAYS PLACED IN REGISTER 15\n*                    AND CAN BE :\n*\n*                     0 - CLOSE CORRECTLY EXECUTED.\n*                     1 - CALLING SEQUENCE OR ARGUMENT ALIGNMENT ERROR.\n*\n* AUTHOR :     P.A. MOINIL\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n         SPACE 2\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               SET SWITCH NOP OPERATION.\nON       EQU   X'F0'               SET SWITCH BRANCH OPERATION.\n         EJECT\n         ENTRY VTOCSO\n         ENTRY VTOCSC\n         SPACE 1\n         USING *,R15\n         MVI   WTGO+3,VTOCS-*      SET ENTRY DISPLACEMENT (READ).\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nVTOCSO   MVI   WTGO+3,VTOCS-*      SET ENTRY DISPLACEMENT (OPEN).\n         B     WTGO\n         DROP  R15\n         SPACE 1\n         USING *,R15\nVTOCSC   MVI   WTGO+3,VTOCS-*      SET ENTRY DISPLACEMENT (CLOSE).\n         DROP  R15\n         SPACE 1\nWTGO     LA    R15,*-*(R15)        SET COMMON ENTRY ADDRESS.\n         SPACE 1\nVTOCS   $XENT BASE=R12\n         LR    R15,R12             COMPUTE WHERE TO GO?\n         BCTR  R15,0\n         SR    R14,R14\n         IC    R14,0(R15)\n         SRL   R14,1\n         B     *+L'*-(VTOCS-WTGO)+0(R14) ENTER SELECTED ROUTINE.\n         SPACE 1\n         B     VTCLOSE             BRANCH ENTRIES VECTOR.\n         B     VTOPEN\n         EJECT\n         SR    R9,R9\n         SR    R8,R8\n         LA    R10,MAXERR\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    RD2\n         TM    4(R1),X'80'\n         BO    RD1\n         TM    8(R1),X'80'\n         BZ    ERR3\n         TM    11(R1),X'03'\n         BNZ   ERR3\n         L     R9,8(R1)\n         LA    R9,0(R9)\nRD1      L     R8,4(R1)\n         LA    R8,0(R8)\nRD2      TM    3(R1),X'03'\n         BNZ   ERR3\n         L     R7,0(R1)\n         LA    R7,0(R7)\n         SPACE 1\n         LA    R6,DCBVR\n         USING IHADCB,R6\n         TM    DCBOFLGS,DCBOFOPN   TEST IF OPENED?\n         BZ    ERR2                BRANCH IF NOT.\n         AIF   ('&SYSPARM' EQ 'OLD').O1S1\nSWIX1    NOP   IX01\n.O1S1    NI    SWR+1,OFF\n        READ   DECBVR,SF,DCBVR,(R7)\n        CHECK  DECBVR\nSWR      B     ERR1\n         AIF   ('&SYSPARM' EQ 'OLD').O1S2\nSWIX2    NOP   IX05\n         USING IECSDSL5,R7\n         CLI   DS5FMTID,C'5'       FORMAT 5 DSCB?\n         BNE   IX05\n         XC    IXWORD,IXWORD       FIRST ENTRY.\nIX01     ST    R7,IXFMT5A          AREA FOR FMT5.\n         L     R1,4(R13)           PREVIOUS SAVE AREA ADDRESS.\n         XC    20(4,R1),20(R1)     SET R0 VALUE TO GO BACK.\n         LA    R1,IXPARM           POINT TO PARMLIST.\n         L     R15,IXVCON          ROUTINE ADDRESS.\n         BASR  R14,R15             CALL INTERFACE ROUTINE.\n         LTR   R10,R15             INDEXED VTOC?\n         BNZ   SWIX3               NO.\n         OC    DS5PTRDS,DS5PTRDS   LAST FMT5 FROM IX INTERFACE?\n         BZ    IX02                YES.\n         OI    SWIX1+1,ON          NO, SET TO GET NEXT.\n         OI    SWIX3+1,ON\n         B     IX03\nIX02     NI    SWIX1+1,OFF\n         OI    SWIX2+1,ON\n         NI    SWIX4+1,OFF\nIX03     LTR   R8,R8\n         BZ    EXIT\n         MVI   0(R8),X'FF'\n         MVC   1(7,R8),0(R8)\n         B     EXIT\n         DROP  R7\nSWIX3    NOP   IX04\n         CH    R10,NOTIXCC         VTOC IS NOT INDEXED FORMAT?\n         BE    IX05                YES, NORMAL VTOC.\nIX04     NI    SWIX1+1,OFF         NO, ERROR OCCURED.\n         OI    SWIX2+1,ON\n         OI    SWIX3+1,ON\n         OI    SWIX4+1,ON\n         L     R1,4(R13)           PREVIOUS SAVE AREA ADDRESS.\n         ST    R0,20(R1)           SET R0 = ERROR INFORMATION.\n         B     EXIT\nIX05     SR    R10,R10\n         AGO   .O1S3\n.O1S2    SR    R10,R10\n.O1S3    LTR   R8,R8\n         BZ    EXIT\n         MVC   0(8,R8),DCBFDAD     GET MBBCCHHR.\n         B     EXIT\n         DROP  R6\n         SPACE 1\nERR1     BCTR  R10,0\nERR2     BCTR  R10,0\nERR3     BCTR  R10,0\nMAXERR   EQU   ((*-ERR1)/2)+1\n         AIF   ('&SYSPARM' EQ 'OLD').O1S4\n         L     R1,4(R13)           PREVIOUS SAVE AREA ADDRESS.\n         XC    20(4,R1),20(R1)     SET R0 VALUE TO GO BACK.\n         B     IXRST\n         AGO   .O1S5\n.O1S4    B     EXIT\n.O1S5    SPACE 1\nENDVT   CLOSE  (DCBVR)\n         SR    R10,R10\n         BCTR  R10,0\n         L     R1,4(R13)           PREVIOUS SAVE AREA ADDRESS.\n         XC    20(4,R1),20(R1)     SET R0 VALUE TO GO BACK.\n         AIF   ('&SYSPARM' EQ 'OLD').O1S6\nSWIX4    B     IXRST\n         LA    R0,IXCT1\n         ST    R0,20(R1)           PASS COUNTS ADDRESS IN R0.\nIXRST    NI    SWIX1+1,OFF         RESET INDEXED VTOC SWITCHES.\n         NI    SWIX2+1,OFF\n         NI    SWIX3+1,OFF\n         OI    SWIX4+1,ON\n.O1S6    B     EXIT\n         EJECT\nRDVTERR SYNADAF   ACSMETH=BSAM\n         OI    SWR+1,ON\n         CLI   69(R1),C'*'         TEST UNSIGNIFICANT MESSAGE,\n         BE    SYNAD3              BRANCH IF YES.\n         CLI   8(R1),C' '          TEST IF BINARY INFORMATIONS,\n         BE    SYNAD1              BRANCH IF NOT.\n         UNPK  56(7,R1),9(4,R1)\n         TR    56(6,R1),TRTAB-X'F0'\n         MVI   62(R1),C','\n         UNPK  63(5,R1),12(3,R1)\n         TR    63(4,R1),TRTAB-X'F0'\n         MVI   67(R1),C','\n         B     SYNAD2\nSYNAD1   MVC   56(12,R1),8(R1)     MOVE BLANKS.\nSYNAD2   LA    R1,52(R1)           SET PARM ADDRESS FOR WTO.\n         MVC   0(4,R1),LWTO        SET PARM FOR WTO.\n         MVC   76(4,R1),RWTO\n        WTO    MF=(E,(1))\nSYNAD3  SYNADRLS\n         BR    R14\n         EJECT\nVTOPEN   SR    R9,R9\n         SR    R8,R8\n         AIF   ('&SYSPARM' EQ 'OLD').O2S1\n         NI    SWIX1+1,OFF         RESET INDEXED VTOC SWITCHES.\n         NI    SWIX2+1,OFF\n         NI    SWIX3+1,OFF\n         OI    SWIX4+1,ON\n.O2S1    LA    R10,MAXERO\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BO    OP2\n         TM    4(R1),X'80'\n         BO    OP1\n         TM    8(R1),X'80'\n         BZ    ERO3\n         TM    11(R1),X'03'\n         BNZ   ERO3\n         L     R9,8(R1)\n         LA    R9,0(R9)\nOP1      TM    7(R1),X'03'\n         BNZ   ERO3\n         L     R8,4(R1)\n         LA    R8,0(R8)\nOP2      L     R7,0(R1)\n         LA    R7,0(R7)\n         SPACE 1\n         OC    ATIOT(L'ATIOT),ATIOT FISRT TIME?\n         BNZ   GOT                 BRANCH IF NOT.\n         L     R2,CVTPTR           GET CVT ADDRESS.\n         USING CVT,R2\n         TM    CVTDCB,CVT4MS1      TEST IF OS/VS2?\n         BZ    ERO4                BRANCH IF NOT.\n         DROP  R2\n        EXTRACT    ATIOT,'S',FIELDS=(TIOT)\n         L     R2,ATIOT\n         USING TIODSECT,R2\n         MVC   GN4+1(L'TIOCNJOB),TIOCNJOB\n         DROP  R2\n         LA    R2,GN4+L'GN4-3\n         LA    R3,L'GN4-1\nDSOL     CLI   0(R2),C' '\n         BNE   DSOLF\n         BCTR  R2,0\n         BCT   R3,DSOL\nDSOLF    MVC   1(2,R2),GN3\n         SPACE 1\nGOT      L     R2,ATIOT            GET TIOT ADDRESS.\n         USING TIODSECT,R2\n         LA    R5,DCBVR            SEARCH DD-CARD.\n         USING IHADCB,R5\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED?\n         BO    ERO1                BRANCH IF YES.\n         MVC   DCBDDNAM(L'DCBDDNAM),0(R7)\nSRCH     CLC   TIOELNGH(L'ZEROS),ZEROS END OF TIOT?\n         BE    ERO5                YES.\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM DD-NAME FOR US?\n         BE    FOUND               YES.\nNEXT     SR    R1,R1\n         IC    R1,TIOELNGH\n         AR    R2,R1               NEXT DD ENTRY.\n         B     SRCH\n         DROP  R2\nFOUND    LTR   R2,R8\n         BNZ   *+L'*+4\n         LA    R2,DVTYP\n        DEVTYPE  DCBDDNAM,(R2),DEVTAB\n         CLI   2(R2),X'20'         TEST IF DIRECT-ACCESS STORAGE.\n         BNE   ERO6                BRANCH IF NOT.\n         LTR   R8,R8\n         BZ    RDJ\n         L     R4,CVTPTR           GET CVT POINTER.\n         USING CVT,R4\n         L     R15,CVTZDTAB        ADDRESS OF IECZDTAB.\n         DROP  R4\n         LA    R15,0(0,R15)        IECZDTAB IS THE RESIDENT DIRECT\n         SR    R4,R4                    ACCESSS DEVICE CONSTANT TABLE\n         LR    R14,R4                   (SEE ASSEMBLY OF IECZDTAB).\n         IC    R14,3(R2)           GET UNIT TYPE.\n         IC    R4,0(R14,R15)       PICK UP TABLE DISPLACEMENT.\n         ALR   R4,R15              DEVICE CONSTANT TABLE ADDRESS.\n         MVC   20(2,R8),12(R4)     MOVE NR. OF ALT. TRACKS.\nRDJ     RDJFCB  (DCBVR)\n         LTR   R15,R15             TEST COMPLETION CODE.\n         BNZ   ERO7                JFCB ERROR.\n         LA    R4,JF\n         USING JFCDSECT,R4\n         CLC   JFCBDSNM(L'GN1),GN1 TEST O.S. GENERATED DSNAME.\n         BNE   ERO8\n         CLC   JFCBDSNM+8(L'GN2),GN2\n         BNE   ERO8\n         CLC   JFCBDSNM+16(L'GN3),GN3\n         BNE   ERO8\n         LA    R2,GN4+L'GN4-1\n         LA    R3,L'GN4-1\nDSCL     CLI   0(R2),C' '\n         BNE   DSCLF\n         BCTR  R2,0\n         BCT   R3,DSCL\nDSCLF    EX    R3,DSCC\n         BE    JL0\n         B     ERO8\nDSCC     CLC   JFCBDSNM+22(*-*),GN4\nJL0      CLI   JFCBIND2,JFCOLD     TEST DISP=OLD CODED,\n         BNE   ERO8                BRANCH IF NOT.\nJL1      EQU   JFCBLTYP-JFCBTSDM\n         OC    JFCBTSDM(JL1),JFCBTSDM   CONTROL DD-CARD CODE.\n         BNZ   ERO8\nJL2      EQU   JFCBCRDT-JFCBOTTR\n         OC    JFCBOTTR(JL2),JFCBOTTR\n         BNZ   ERO8\nJL3      EQU   JFCBIND2-JFCBXPDT\n         OC    JFCBXPDT(JL3),JFCBXPDT\n         BNZ   ERO8\nJL4      EQU   JFCBNVOL-JFCBUFNO\n         OC    JFCBUFNO(JL4),JFCBUFNO\n         BNZ   ERO8\nJL5      EQU   JFCBVLCT-JFCBPQTY\n         OC    JFCBPQTY(JL5),JFCBPQTY\n         BNZ   ERO8\n         CLI   JFCBVLCT,X'01'\n         BNE   ERO8\n         CLI   JFCBLTYP,JFCSL\n         BNE   ERO8\n         CLI   JFCBNVOL,X'01'\n         BNE   ERO8\n         CLI   JFCBSPTN,X'00'\n         BNE   ERO8\n         LTR   R8,R8\n         BZ    *+L'*+6\n         MVC   22(6,R8),JFCBVOLS\n         SPACE 1\n         MVI   JFCBDSNM,X'04'      SET VTOC NAME.\n         MVC   JFCBDSNM+1(L'JFCBDSNM-1),JFCBDSNM\n         OI    JFCBTSDM,JFCNWRIT   INHIBIT WRITE BACK.\n         DROP  R4\n        OPEN   (DCBVR,(INPUT)),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULLY?\n         BZ    ERO2                BRANCH IF NOT.\n         DROP  R5\n         SR    R10,R10\n         B     EXIT\n         SPACE 1\nERO1     BCTR  R10,0\nERO2     BCTR  R10,0\nERO3     BCTR  R10,0\nERO4     BCTR  R10,0\nERO5     BCTR  R10,0\nERO6     BCTR  R10,0\nERO7     BCTR  R10,0\nERO8     BCTR  R10,0\nMAXERO   EQU   ((*-ERO1)/2)+1\n         B     EXIT\n         EJECT\nVTCLOSE  SR    R9,R9\n         AIF   ('&SYSPARM' EQ 'OLD').O3S1\n         NI    SWIX1+1,OFF         RESET INDEXED VTOC SWITCHES.\n         NI    SWIX2+1,OFF\n         NI    SWIX3+1,OFF\n         OI    SWIX4+1,ON\n.O3S1    LTR   R1,R1\n         BZ    CL1\n         LA    R10,MAXERC\n         TM    0(R1),X'80'         CONTROL ARGUMENTS.\n         BZ    ERC1\n         TM    3(R1),X'03'\n         BNZ   ERC1\n         L     R9,0(R1)\n         LA    R9,0(R9)\n         SPACE 1\nCL1      LA    R5,DCBVR\n         USING IHADCB,R5\n         TM    DCBOFLGS,DCBOFOPN   TEST OPENED?\n         BZ    CL2                 BRANCH IF NOT.\n        CLOSE  (DCBVR)\n         DROP  R5\nCL2      SR    R10,R10\n         B     EXIT\n         SPACE 1\nERC1     BCTR  R10,0\nMAXERC   EQU   ((*-ERC1)/2)+1\n         SPACE 1\nEXIT     LTR   R9,R9\n         BZ    LEAVE\n         ST    R10,0(R9)\nLEAVE   $XRET  CC=(R10)\n         SPACE 1\n         DROP  R12\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nATIOT    DC    A(*-*)\nDVTYP    DC    5F'0'\nZEROS    DC    F'0'\nJOBFILE  DC    0F'0',XL1'87',AL3(JF)\nJF       DC    0F'0',XL176'00'\nLWTO     DC    AL2(76),XL2'8000'   WTO : TEXT LENGTH, MCS FLAGS.\nRWTO     DC    XL2'0200',XL2'0020' WTO : DESC=7, ROUTCDE=11.\nTRTAB    DC    C'0123456789ABCDEF'\nGN1      DC    C'SYS'\nGN2      DC    C'.T'\nGN3      DC    C'.RA'\nGN4      DC    CL11'.'\n         SPACE 1\nDCBVR    DCB   DSORG=PS,MACRF=R,DEVD=DA,KEYLEN=44,RECFM=FS,BLKSIZE=96, 1\n               LRECL=96,EODAD=ENDVT,SYNAD=RDVTERR,EXLST=JOBFILE,       2\n               DDNAME=XXXXXXXX\n         SPACE 1\n         AIF   ('&SYSPARM' EQ 'OLD').O10S1\nIXPARM   DC    A(IXWORD)           WORK WORD.\n         DC    A(DCBVR)            OPEN DCB.\n         DC    A(IXCT1)            COUNT OF FREE DSCB'S.\n         DC    A(IXCT2)            COUNT OF FREE VIRS.\nIXFMT5A  DC    A(*-*)              POINTER TO PSEUDO FMT5.\n         SPACE 1\nIXVCON   DC    V(IXTOFMT5)\nIXWORD   DC    F'0'\nIXCT1    DC    F'0'\nIXCT2    DC    F'0'\nNOTIXCC  DC    H'4'\n.O10S1   SPACE 2\n        PRINT  NOGEN\n         SPACE 1\nTIODSECT DSECT\n        IEFTIOT1\n        CVT    DSECT=YES,LIST=YES\nJFCDSECT DSECT\n        IEFJFCBN LIST=YES\n        DCBD   DSORG=PS,DEVD=DA\n         AIF   ('&SYSPARM' EQ 'OLD').O99S1\n         DSECT\n        IECSDSL1 (5)               FORMAT 5 DSCB.\n.O99S1   SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCS$": {"ttr": 38664, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14%\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:25:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SYSPAJA"}, "text": "//VTOCS    JOB (........),'INSTALL  - VTOCS -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION FOR USE :                      *\n//*                IXTOFMT5                                           *\n//* NOTES : 1. SPECIFY SYSPARM(OLD) AT ASSEMBLY STEP 'ASS' IF YOU     *\n//*            DON'T HAVE INDEXED VTOC IN YOUR SYSTEM (IN THIS CASE,  *\n//*            IGNORE THE PRE-REQUISITE).                             *\n//*            BY DEFAULT, YOU OBTAIN A VERSION FOR BOTH VTOC TYPES.  *\n//*                 I.E. : OPT=',SYSPARM(OLD)'                        *\n//*         2. AT LINK-EDIT YOU MAY RECEIVE A RETURN CODE 4 WHICH IS  *\n//*            ONLY A NORMAL WARNING MESSAGE DUE TO NCAL SPECIFIED.   *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS3,MBR=VTOCS\n//LNK     EXEC PAJILKR,OPT=',NCAL'\n//SYSIN     DD *\n  ALIAS   VTOCSO\n  ALIAS   VTOCSC\n  NAME    VTOCSR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCS@": {"ttr": 38666, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14S\\x00{\\x00{\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:53:00", "lines": 123, "newlines": 123, "modlines": 0, "user": "SYSPAJA"}, "text": "1   18/06/87\n                                                      VTOCS     1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      READ SEQUENTIALLY A VTOC       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Routine to read sequentially an entire VTOC.\n  ---------    A DD-card, written as below, is needed to define\n               the desired volume :\n\n               //...     DD  UNIT=...,VOLUME=SER=...,DISP=OLD\n\n\n  Calling sequence : CALL VTOCSR,(A,B,C),VL\n  ------------------             (A,B)\n                                 (A)\n\n         Where : A - is the address of an array (format FULLWORD -\n                     F boundary) which receives the DSCB's record\n                     (140 bytes long).\n\n                 B - is the address of the current DSCB's record\n                     address, in the format MBBCCHHR (format XL8),\n                     returned after each read operation, unless when\n                     the END-OF-FILE is detected or a pseudo format 5\n                     DSCB is passed back by the indexed VTOC interface\n                     routine (IXTOFMT5) if it has been generated (the\n                     MBBCCHHR is set to all x'FF'. This argument is\n                     optional and may be omitted or his address may be\n                     set to zero in the parameters list.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                     -1 - END-OF-FILE detected. When an indexed VTOC is\n                          processed, at END-OF-FILE return, the register\n                          0 points to two fullwords which are containing\n                          the counts of the free (FMT 0) DSCBs and the\n                          free VIRS respectively.\n                          With normal VTOC, register 0 is set to zero.\n                      0 - READ operation correctly executed.\n                      1 - READ error.\n                      2 - file not opened.\n                      3 - calling sequence or argument alignment error.\n                     NN - indexed VTOC interface routine return code\n                          (if it has been requested at the assembly),\n                          with R0 = error information (IXTOFMT5).\n\n  Assembler macro : $VTOCSR A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   23/09/85\n                                                      VTOCS     2/3.\n\n  Calling sequence : CALL VTOCSO,(A,B,C),VL\n  ------------------             (A,B)\n                                 (A)\n\n         Where : A - is the address of the DD-name (format CL8).\n\n                 B - is the address of the device characteristics\n                     (format FULLWORD - F boundary) returned by the\n                     routine if supplied (optional). It will receive\n                     five fullwords information as described in DEVTYPE\n                     macro (see OS/VS2 System Programming Library :\n                     Data Management), followed by one halfword\n                     containing the number of alternate tracks for\n                     the device, followed by a six characters field\n                     containing the volume serial number of the\n                     device. This argument is optional and may be\n                     omitted or his address may be set to zero in the\n                     parameters list.\n\n                 C - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional).\n                     Value is always placed in register 15 and can be :\n\n                      0 - OPEN correctly executed.\n                      1 - file already opened.\n                      2 - OPEN error.\n                      3 - calling sequence or argument alignment error.\n                      4 - not OS/VS2 System.\n                      5 - DD-card missing.\n                      6 - not direct-access storage device.\n                      7 - read JFCB error.\n                      8 - DD-card incorrectly coded.\n\n  Assembler macro : $VTOCSO A,B,C\n  -----------------\n\n         Where B and/or C are optional and may be omitted.\n         Register use may be coded within parentheses.\n1   30/07/86\n                                                      VTOCS     3/3.\n\n  Calling sequence : CALL VTOCSC,(A),VL\n  ------------------\n\n         Where : A - is the address of the indicator response (format\n                     FULLWORD - F boundary) if supplied (optional :\n                     argument may be omitted passing a zero parameters\n                     list pointer - register 1). Value is always placed\n                     in register 15 and can be :\n\n                      0 - CLOSE correctly executed.\n                      1 - calling sequence or argument alignment error.\n\n  Assembler macro : $VTOCSC A\n  -----------------\n\n         Where A is optional and may be omitted.\n         Register use may be coded within parentheses.\n\n\n  General notice : on error reading a VTOC's DSCB a message is included\n  ---------------- in the message class for the job.\n                   This routine is only serially volumes usable.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VTTCAM": {"ttr": 38669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\x12\\x15\\x00(\\x00(\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T12:15:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SYSPAJA"}, "text": "VTTM     TITLE 'TEST TCAM OR VTAM RUNNING SUBROUTINE.'\nVTTCAM   START 0\n         SPACE 1\n* CALLING SEQUENCE : CALL VTTCAM\n* ------------------\n*\n*        AT EXIT, REGISTER 15 IS SET AS BELOW :\n*              ZERO (0) IF RUNNING UNDER TCAM,\n*              ONE (1) IF RUNNING UNDER VTAM.\n*\n* AUTHOR :     N. RAVARANI\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 2\n        $DEFREG\n         EJECT\n        $XENT  BASE=R11,TYPE=RENT\n         EJECT\n         USING PSA,R0              WE HAVE TO GET IT FROM ASXB.\n         L     R3,PSAAOLD          GET OUR ASCB ADDRESS.\n         DROP  R0\n         USING ASCB,R3\n         L     R3,ASCBASXB         GET ASXB ADDRESS.\n         DROP  R3\n         USING ASXB,R3\n         XR    R15,R15             SET ZERO.\n         L     R2,ASXBMPST         VTAM MEMORY PROCESS SCHED. TABLE.\n         DROP  R3\n         LTR   R2,R2\n         BZ    EXIT                ADDRESS DOESN'T EXIST : TCAM.\n         LA    R15,1               ADDRESS EXIST : VTAM, SET ONE.\nEXIT    $XRET  TYPE=RENT,CC=(R15)\n         SPACE 1\n        PRINT  NOGEN\n        IHAPSA\n        IHAASCB\n        IHAASXB\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTTCAM$": {"ttr": 38671, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//VTTCAM   JOB (........),'INSTALL  -VTTCAM-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=VTTCAM\n//LNK     EXEC PAJILKR,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   VTTCAM\n  NAME    VTTCAM(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTTCAM@": {"ttr": 38673, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86&/\\x00\\x86&/\\x10Q\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-09-19T00:00:00", "modifydate": "1986-09-19T10:51:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      VTTCAM    1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      TEST TCAM OR VTAM RUNNING      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *             SUBROUTINE.             * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Calling sequence : CALL VTTCAM\n  ------------------\n\n         At exit, register 15 is set to zero if running under TCAM,\n                     and to one if running under VTAM.\n\n  Assembler macro : $VTTCAM\n  -----------------\n\n  General notice : this subroutine is written in reenterable code.\n  ================\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WAITR": {"ttr": 38913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\tY\\x01(\\x01(\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T09:59:00", "lines": 296, "newlines": 296, "modlines": 0, "user": "SYSPAJA"}, "text": "WTRS     TITLE 'TSO - LIST ENQ CONFLICTS FOR A JOB OR USERID COMMAND.'\nWAITR    START 0\n         SPACE 1\n* PURPOSE :    THIS COMMAND WILL SEARCH THE QCB CHAIN TO LOCATE ALL\n* ---------    DSN ENQS THAT RELATE TO A PARTICULAR JOB OR USERID\n*              (* CAN BE USED TO DENOTE THE USER ISSUING THE CP).\n*              IT WILL THEN DETERMINE IF THERE ARE EXIST ANY CONFLICTS.\n*              IF THE JOB IS WAITING AS A RESULT OF THIS (I.E. - OLD IF\n*              ALREADY ALLOCATED OR SHR IF IT IS ALLOCATED OLD), OR IF\n*              THE JOB HOLDS DATA-SETS THAT ANOTHER JOB WANTS, IT WILL\n*              SHOW OUT THE TYPE OF ALLOCATION AND THE DATA-SET NAME.\n*              COMMAND EXAMPLES :\n*              WAITR XXXX      - TO LOCATE ENQS FOR A JOB OR USERID.\n*              WAITR XXXX USER - TO LOCATE ONLY ENQS FOR A USERID.\n*              WAITR XXXX JOB  - TO LOCATE ONLY ENQS FOR A JOB.\n*              WAITR *         - TO LOCATE ENQS OF USERID ISSUING CP.\n*              RESPONSES EXAMPLES :\n*              WAITING SHR FOR DSN = ABC.THIS.THAT\n*              WAITING OLD FOR DSN = XYZ.THE.OTHER.THING\n*              WAITING FOR DSN = THIS.IS.A.NAME, ALLOCATED SHR\n*              WAITING FOR DSN = THIS.IS.A.NOTHER, ALLOCATED OLD\n* RETURN CODES :    0 - JOB OR USER FOUND IN EXECUTION, CONFLICTS MAY\n* --------------        OR MAY NOT HAVE BEEN FOUND.\n*                   4 - JOB OR USER WAS NOT FOUND IN EXECUTION.\n*                  16 - COMMAND ERROR DETECTED.\n* AUTHOR :     ORIGINAL VERSION FROM CBT TAPE (FILE 141).\n* --------     THIS IS THE SP1.3 VERSION OF WAITR.\n*              MODIFIED BY : RAVARANI N. - MOINIL P.A.\n*                            COMPUTING CENTRE (TP 361)\n*                            J.R.C. - ISPRA ESTABLISHMENT\n*                            21020 ISPRA (VA), ITALY\n         SPACE 1\n        $DEFREG\nSIAL     EQU   12*1024             SCAN INFO AREA LENGTH\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R9,R13              SET WORK AREAS ADDRESSABILITY\n         USING WRKDSECT,R9\n         MVI   SWITCH,0\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n        $TEW$PP PARM=PARMLST,REG=R11\n         MVC   JOBNAME,=CL8' '     CLEAR JOBNAME\n         L     R1,JOBN             ADDRESS OF JOBNAME\n         LH    R2,JOBN+4           GET LENGTH OF JOBNAME\n         BCT   R2,*+L'*+6\n         MVC   JOBNAME(*-*),0(R1)  <<EXECUTED>>\n         EX    R2,*-6              MOVE JOBNAME\n         CLI   JOBNAME,C'*'        CHECK FOR * (OR USERID THATS ON)\n         BNE   SETFLGS\n         L     R1,#TSPSCB          ---> PSCB\n         USING PSCB,R1\n         XR    R2,R2\n         IC    R2,PSCBUSRL         LENGTH OF USERID\n         BCT   R2,*+L'*+6\n         MVC   JOBNAME(*-*),PSCBUSER <<EXECUTED>>\n         EX    R2,*-6              MOVE USERID\n         OI    SWITCH,RQSTUSER     ONLY TAKE USER\n         B     RLSESA\n         DROP  R1\nSETFLGS  CLI   USER+1,1            WAS USER SPECIFIED?\n         BNE   *+L'*+4\n         OI    SWITCH,RQSTUSER\n         CLI   JOB+1,1             WAS JOB SPECIFIED?\n         BNE   RLSESA\n         OI    SWITCH,RQSTJOB\n         DROP  R11\nRLSESA  IKJRLSA #TSANSW\n         SPACE 1\n*------- CVT ---> ASVT ---> ASCB ---> CSCB\n*        (BOY WHAT FUN ...)\n         SPACE 1\n         L     R2,CVTPTR           ---> CVT\n         USING CVT,R2\n         L     R3,CVTASVT          ---> ASVT\n         DROP  R2\n         USING ASVT,R3\n         LA    R7,ASVTFRST-4       ---> ENTRY ADDS (MINUS 4)\n         L     R8,ASVTMAXU         ---> # OF ASCBS\n         DROP  R3\nCHKASID  LA    R7,4(R7)            ENTRY + 4\n         TM    0(R7),ASVTAVAI      IN USE?\n         BO    NXTASID             NO... DON'T LOOK AT IT THEN\n         L     R6,0(R7)            ---> ASCB\n         USING ASCB,R6\n         L     R5,ASCBCSCB         ---> POSSIBLE CSCB\n         LTR   R5,R5               TEST FOR POSITIVE\n         BNP   *+L'*+8             NO ---> TRY NEXT ONE\n         TM    28(R5),X'03'        IS THIS A USER OR JOB?\n         BM    TJBNM               YES\n         L     R5,ASCBJBNI         TRY NEXT ONE\n         LTR   R5,R5               ONE MORE TIME\n         BNP   *+L'*+8\n         S     R5,=F'8'            ADJUST POINTER BACK SOME\n         B     GOTCSCB\n         L     R5,ASCBJBNS         ONE LAST TRY\n         LTR   R5,R5               CROSS YOUR FINGERS\n         BNP   NXTASID             OH WELL... TRY NEXT ASID\n         S     R5,=F'16'           GOT TO ADJUST THIS ONE TOO\nGOTCSCB  TM    28(R5),X'03'        IS THIS A USER OR JOB?\n         BNM   NXTASID             NO...\nTJBNM    CLC   8(8,R5),JOBNAME\n         BNE   NXTASID\n         TM    SWITCH,RQSTUSER     DID THEY ONLY WANT A USER?\n         BZ    CHKTJOB             NO, CHECK FOR JOB ONLY\n         TM    28(R5),X'01'        IS IT TSU?\n         BZ    NXTASID             NO, SKIP IT EVEN IF IT COMPARED\n         B     GOTASID\nCHKTJOB  TM    SWITCH,RQSTJOB      DID THEY ONLY WANT A JOB?\n         BZ    GOTASID             NO, THEN TAKE WHAT WE GOT\n         TM    28(R5),X'02'        IS IT JOB?\n         BO    GOTASID             YES WE GOT WHAT WE WANT\nNXTASID  BCT   R8,CHKASID          GO FOR NEXT ASID\n         B     NOTFND              JOB DOESN'T EXIST\nGOTASID  MVC   ASID,ASCBASID       SAVE THE ASID\n         XC    TKN,TKN             ASSURE TOKEN ZERO\n         DROP  R6\nDOGQ     LA    R13,SCANSAVE        ADDRESS GQSCAN SAVE AREA\n         XC    0(18*4,R13),0(R13)\n         MVC   SCAN(LSCAN),SCANP\n         LH    R8,ASID             GET THE ASID # FOR THE JOB\n         LA    R7,TABLE\n        GQSCAN AREA=((R7),),TOKEN=TKN,SYSNAME=(,(R8)),MF=(E,SCAN)\n         LR    R13,R9              RESTORE MAIN SAVE AREA\n         B     *+L'*(R15)          HOW COMPLETE ?\n         B     SEARCH              +0 - O.K.\n         B     CODE04              +4 - NO RESOURCES MATCHED REQUEST\n         B     SEARCH              +8 - GQSCAN AREA TOO SHORT\n         B     CODE0C              +12 - ERROR WHILE PROCESSING\n         B     CODE10              +16 - INVALID SYSNAME\n         B     CODE14              +20 - GQSCAN AREA TOO SHORT\n         SPACE 1\nCODE04   LA    R0,L'CODE04M        NO RESOURCES FOUND\n         LA    R1,CODE04M\n         BAS   R14,PUTLNE\n         B     NTFRC\nCODE0C   LA    R0,L'CODE0CM        ERROR IN GQSCAN\n         LA    R1,CODE0CM\n         B     GQERR\nCODE10   LA    R0,L'CODE10M        INVALID SYSNAME\n         LA    R1,CODE10M\n         B     GQERR\nCODE14   LA    R0,L'CODE14M        GQSCAN AREA TOO SHORT\n         LA    R1,CODE14M\nGQERR    BAS   R14,PUTLNE\n         B     SETRC\n         SPACE 1\nSEARCH   LTR   R6,R1               DID SOME DUMMY ASK IF HIS JOB WAS\n         BNP   BYEBYE                   WAITING EVEN IF IT DIDN'T\n*                                       ALLOCATE ANY DATA-SETS\n         STCM  R0,B'1111',RIBLNGTH STORE RIB AND RIBE LENGTH\n         LA    R7,TABLE            FIRST RIB, R6 : NO. OF RIBS\n         USING RIB,R7\n         MVC   WAITLINE(79),=CL79' WAITING XXX FOR DSN = '\n         MVC   HOLDLINE(79),=CL79' WAITING FOR DSN = '\n         MVC   HOLDALC,=CL12', ALLOCATED '\nRIBLOOP  CLC   RIBQNAME,=CL8'SYSDSN'    IS THIS A DSNAME RIB?\n         BNE   BUMPRIB\n         L     R5,RIBNRIBE         NO. OF RIBE'S\n         LTR   R5,R5\n         BNP   BUMPRIB             NO RIBE'S SUPPLIED\n         CLC   RIBNTWE(8),=XL8'0'  ANY TASKS WAITING?\n         BE    BUMPRIB             NO, NOT EVEN ME\n         OI    SWITCH,EFLAG        SHOW WE GOT ONE\n         MVI   WAITDSN,C' '\n         MVC   WAITDSN+1(L'WAITDSN-1),WAITDSN\n         LR    R8,R7               GET RIB POINTER\n         AH    R8,RIBLNGTH         POINT TO RIB VARIABLE SECTION\n         USING RIBVAR,R8\n         XR    R1,R1\n         IC    R1,RIBRNMLN         RNAME LENGTH\n         BCT   R1,*+L'*+6          -1 FOR MOVE\n         MVC   WAITDSN(*-*),RIBRNAME <<EXECUTED>>\n         EX    R1,*-6              GET THE DSNAME\n         MVC   HOLDDSN,WAITDSN     TO BOTH MESSAGES\n         DROP  R8\n         AH    R8,RIBVLEN          POINT TO FIRST RIBE\n         USING RIBE,R8\nNEXTRIBE TM    RIBERFLG,RIBETYPE   WHAT TYPE OF HOLD?\n         BZ    *+L'*+16\n         MVC   SHRTYPE,=CL3'SHR'   TYPE OF WAIT = SHARE\n         MVC   HOLDTYPE,=CL3'SHR'  OR HOLD = SHARE\n         B     *+L'*+12\n         MVC   SHRTYPE,=CL3'OLD'   TYPE OF WAIT = EXCLUSIVE\n         MVC   HOLDTYPE,=CL3'OLD'  OR HOLD = EXCLUSIVE\n         XR    R1,R1\n         IC    R1,RIBRNMLN\n         LA    R1,HOLDDSN(R1)\n         MVC   0(15,R1),HOLDALC\n         TM    RIBESFLG,RIBESTAT   DO I WAIT OR HOLD?\n         BZ    *+L'*+8\n         LA    R1,HOLDLINE\n         B     *+L'*+4\n         LA    R1,WAITLINE\n         LA    R0,79               SEND IT\n         BAS   R14,PUTLNE\n         B     *+L'*+4             +0 - NORMAL COMPLETION\n         B     SETRC               +4 - ERROR\n         AH    R8,RIBELENG         POINT TO NEXT RIBE\n         BCT   R5,NEXTRIBE\nBUMPRIB  XR    R14,R14\n         L     R15,RIBNRIBE        NO. OF RIBE'S\n         LTR   R15,R15\n         BNP   *+L'*+8             NO RIBE'S SUPPLIED\n         AH    R14,RIBELENG        ADD RIBE LENGTH\n         BCT   R15,*-4             ADD TIMES NO. OF RIBE'S\n         AH    R14,RIBLNGTH        ADD LENGTH OF RIB\n         AH    R14,RIBVLEN         ADD LENGTH OF VARIABLE SECTION\n         AR    R7,R14              POINT TO NEXT RIB\n         BCT   R6,RIBLOOP          LOOP UNTIL NO MORE RIBS\n         DROP  R7\n         CLC   TKN,=F'0'           ANY MORE RIBS NOT YET SCANNED?\n         BNE   DOGQ                YES\nBYEBYE   TM    SWITCH,EFLAG        WAS THERE ONE?\n         BO    LEAVE               YES, PRINTED SOMETHING\n         LA    R0,L'NUTTIN         TELL THEM NO D.S. ALLOCATED...\n         LA    R1,NUTTIN\n         BAS   R14,PUTLNE\n         B     *+L'*+4             +0 - NORMAL COMPLETION\n         B     SETRC               +4 - ERROR\nLEAVE    XR    R4,R4               RC=0 -------------------------------\nQUIT    $XRET  CC=(R4),LV=WRKL,TYPE=RENT\nNOTFND   LA    R0,L'NOTF\n         LA    R1,NOTF\n         BAS   R14,PUTLNE\n         B     NTFRC               +0 - NORMAL COMPLETION\n*                                  +4 - ERROR\nSETRC    LA    R4,16               RC=16 ------------------------------\n         B     QUIT\nNTFRC    LA    R4,4                RC=4  ------------------------------\n         B     QUIT\n         SPACE 1\n        LTORG\n*------- SKELETONS, MESSAGES AND CONSTANTS\n         SPACE 1\n        PRINT  NOGEN\nSCANP   GQSCAN AREA=(,SIAL),SCOPE=ALL,SYSNAME=(0,),REQLIM=MAX,MF=L\n        PRINT  GEN\nLSCAN    EQU   *-SCANP\n         SPACE 1\nNOTF     DC    C'JOB OR USER NOT FOUND IN EXECUTION.'\nNUTTIN   DC    C'JOB OR USER IS NOT WAITING FOR DATA-SET(S) OR HOLDING 1\n               UP ANY OTHER JOBS.'\nCODE04M  DC    C'JOB OR USER HAS NO RESOURCES ENQUEUED.'\nCODE0CM  DC    C' -> GQSCAN : ERROR WHILE PROCESSING'\nCODE10M  DC    C' -> GQSCAN : \"SYSNAME\" IS INVALID'\nCODE14M  DC    C' -> GQSCAN : \"AREA\" TOO SHORT'\n         SPACE 1\n        PRINT  NOGEN\nPARMLST IKJPARM\nJOBN    IKJIDENT 'JOBNAME',FIRST=ANY,OTHER=ANY,MAXLNTH=8,              1\n               PROMPT='JOB-NAME OR USER-ID'\nUSER    IKJKEYWD\n        IKJNAME 'USER'\nJOB     IKJKEYWD\n        IKJNAME 'JOB'\n        IKJENDP\n        PRINT  GEN\n         EJECT\n*------- WORK-AREAS DESCRIPTION\n         SPACE 1\nWRKDSECT DSECT                     WORK AREAS DESCRIPTION\nSVA      DS    18F                 SAVE AREA\nSCANSAVE DS    18F                 18 WORDS SAVE AREA REQ FOR GQSCAN\n        $TEW$WA\nJOBNAME  DS    CL8\nSCAN     DS    0F,(LSCAN)X\nTKN      DS    F\nRIBLNGTH DS    H                   RIB LENGTH\nRIBELENG DS    H                   RIBE LENGTH\nWAITLINE DS    0CL79,CL9\nSHRTYPE  DS    CL3\n         DS    CL11\nWAITDSN  DS    CL44\n         DS    CL12\nHOLDLINE DS    0CL79,CL19\nHOLDDSN  DS    CL44\n         DS    CL15,CL1\nHOLDALC  DS    CL12\nHOLDTYPE DS    CL3\nSWITCH   DS    XL1\nEFLAG    EQU   X'01'\nRQSTUSER EQU   X'10'\nRQSTJOB  EQU   X'20'\nASID     DS    H\nTABLE    DS    0F,(SIAL)X          SCAN INFO AREA\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS\n        IHAASVT\n        IHAASCB\n        ISGRIB\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WAITR$": {"ttr": 38919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//WAITR    JOB (........),'INSTALL  -WAITR-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=WAITR\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  NAME    WAITR(R)\n/*\n//HLP     EXEC PAJHELP,MBR=WAITRH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WAITR@": {"ttr": 38921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x006\\x006\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      WAITR     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *   ENQ CONFLICTS FOR A JOB/USERID.   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n   Function :  The WAITR command returns information reguarding ENQ\n   ----------  conflicts for a JOB or USERID. It tells you what\n               data-set(s) the job is waiting on, and how it is waiting\n               (old or share). It will also tell what data-set the job\n               or user holds that other jobs may be waiting on. Once\n               this is known a command such as TSODSN can be used to\n               see who has the data-set tied up or who is waiting on\n               it. At this point the FREE or FREEALL commands can be\n               used to free it.\n   Outputs :   WAITING OLD FOR DSN = XYZ.ABC.DEF\n                    means the job scanned wants XYZ.ZBC.DEF old,\n                    someone has it shared.\n               WAITING SHR FOR DSN = ABC.DEF.GHI\n                    means the job scanned wants ABC.DEF.GHI shared,\n                    someone has it old.\n               WAITING FOR DSN = ABC.TRS.XYZ, ALLOCATED SHR\n                    means the job scanned has data-set ABC.TRS.XYZ\n                    allocated share, at least one job wants it old.\n               WAITING FOR DSN = DEF.ABC.GHI, ALLOCATED OLD\n                    means the job scanned has data-set DEF.ABC.GHI\n                    allocated old, at least one job wants it shared.\n   Return codes :   0 - indicates JOB or USER found in execution.\n                        All conflicts (if any) have been listed.\n                    4 - indicates JOB or USER not found in execution.\n                   16 - Indicates error occurred, re-enter command.\n\n   Syntax :    WAITR J-U USER JOB\n   --------\n\n   Operands :\n   ----------\n  J-U (required) :  the JOBname or USERid to be scanned.\n                    USERid can be specified as * if you wish to scan\n                    your own USERid.\n  USER (optional) : specifies that only TSO users are to be searched if\n                    a JOB and TSO session have the same name.\n  JOB (optional) :  specifies that only jobs are to be searched if a\n                    JOB and TSO session have the same name.\n  Examples :\n       (1) WAITR XXYYZZ   - this scans for the JOB or USERid XXYYZZ if\n                            in execution.\n       (2) WAITR JJJ JOB  - this scans only for the JOB JJJ if in\n                            execution.\n       (3) WAITR UUU USER - this scans only for the USER UUU.\n       (4) WAITR *        - scan the USER issuing the command.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WAITRH": {"ttr": 38923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00.\\x00.\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=WAITR\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION :  THE \"WAITR\" COMMAND RETURNS INFORMATION REGUARDING ENQ\n               CONFLICTS FOR A JOB OR USERID. IT TELLS YOU WHAT\n               DATA-SET(S) THE JOB IS WAITING ON, AND HOW IT IS WAITING\n               (OLD OR SHARE). IT WILL ALSO TELL WHAT DATA-SET THE JOB\n               OR USER HOLDS THAT OTHER JOBS MAY BE WAITING ON. ONCE\n               THIS IS KNOWN A COMMAND SUCH AS \"TSODSN\" CAN BE USED TO\n               SEE WHO HAS THE DATA-SET TIED UP OR WHO IS WAITING ON\n               IT. AT THIS POINT THE FREE OR FREEALL COMMANDS CAN BE\n               USED TO FREE IT.\n          OUTPUTS :\n               WAITING OLD FOR DSN = XYZ.ABC.DEF\n                    MEANS THE JOB SCANNED WANTS 'XYZ.ZBC.DEF' OLD,\n                    SOMEONE HAS IT SHARED.\n               WAITING SHR FOR DSN = ABC.DEF.GHI\n                    MEANS THE JOB SCANNED WANTS 'ABC.DEF.GHI' SHARED,\n                    SOMEONE HAS IT OLD.\n               WAITING FOR DSN = ABC.TRS.XYZ, ALLOCATED SHR\n                    MEANS THE JOB SCANNED HAS DATA-SET 'ABC.TRS.XYZ'\n                    ALLOCATED SHARE, AT LEAST ONE JOB WANTS IT OLD.\n               WAITING FOR DSN = DEF.ABC.GHI, ALLOCATED OLD\n                    MEANS THE JOB SCANNED HAS DATA-SET 'DEF.ABC.GHI'\n                    ALLOCATED OLD, AT LEAST ONE JOB WANTS IT SHARED.\n          RETURN CODES :\n                0 - INDICATES JOB OR USER FOUND IN EXECUTION.\n                    ALL CONFLICTS (IF ANY) HAVE BEEN LISTED.\n                4 - INDICATES JOB OR USER NOT FOUND IN EXECUTION.\n               16 - INDICATES ERROR OCCURRED, RE-ENTER COMMAND.\n)X SYNTAX :    WAITR J-U USER JOB\n)O OPERANDS :\n))J-U (REQUIRED) :  THE JOBNAME OR USERID TO BE SCANNED.\n                    USERID CAN BE SPECIFIED AS '*' IF YOU WISH TO SCAN\n                    YOUR OWN USERID.\n))USER (OPTIONAL) : SPECIFIES THAT ONLY TSO USERS ARE TO BE SEARCHED IF\n                    A JOB AND TSO SESSION HAVE THE SAME NAME.\n))JOB (OPTIONAL) :  SPECIFIES THAT ONLY JOBS ARE TO BE SEARCHED IF A\n                    JOB AND TSO SESSION HAVE THE SAME NAME.\n))EXAMPLES :\n       (1) WAITR XXYYZZ   - THIS SCANS FOR THE JOB OR USERID XXYYZZ IF\n                            IN EXECUTION.\n       (2) WAITR JJJ JOB  - THIS SCANS ONLY FOR THE JOB JJJ IF IN\n                            EXECUTION.\n       (3) WAITR UUU USER - THIS SCANS ONLY FOR THE USER UUU.\n       (4) WAITR *        - SCAN THE USER ISSUING THE COMMAND.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WPC": {"ttr": 38925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943_\\x00\\x943_\\t\\x17\\x00\\xe1\\x00\\xe1\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-01T00:00:00", "modifydate": "1994-12-01T09:17:00", "lines": 225, "newlines": 225, "modlines": 0, "user": "SYSPAJA"}, "text": "WPC      TITLE '--- WPC - DISPLAY WHAT PROFILE COVERS A DATA-SET ---'\nWPC      START 0\n         SPACE 1\n*---------------------------------------------------------------------*\n*  PROGRAM :   WPC                                                    *\n*  ABSTRACT :  THE WPC COMMAND WILL DISPLAY THE NAME OF THE PROFILE   *\n*              THAT 'COVERS' THE DATA-SET GIVEN ON THE COMMAND. THIS  *\n*              IS DONE USING AN UNDOCUMENTED FUNCTION OF RACHECK.     *\n*  INPUTS :    PARAMETERS - R1                                        *\n*                           -> STANDARD CPPL REPRESENTING COMMAND :   *\n*                              \"WPC  FILE.NAME\"                       *\n*              FILES - NONE                                           *\n*              OTHER - NONE                                           *\n*  OUTPUTS :   MESSAGE - \"ENTITY(....) IS PROTECTED BY PROFILE(....)\" *\n*                        VARIOUS ERROR MESSAGES IF THINGS GO WRONG    *\n*              FILES - NONE                                           *\n*              OTHER - NONE                                           *\n*  MODULE :    REENTRANT, PROBLEM KEY AND STATE EXCEPT AS REQUIRED.   *\n*  ATTRIBUTES : STD. LINKAGE, APF-AUTHORIZED, AMODE(24), RMODE(24).   *\n*  SPECIAL NOTES : WPC MUST BE AUTHORIZED. INCLUDE ITS NAME IN TMP    *\n*              TABLE IKJEFTE2 IF IT IS TO BE USED AS A STANDARD TSO   *\n*              COMMAND (OR IKJTSO00 IN SYS1.PARMLIB, MVS/XA).         *\n*              BECAUSE WPC USES TAGS > 8 CHARACTERS, ASSEMBLER H IS   *\n*              REQUIRED TO ASSEMBLE IT AS PROVIDED. CHANGE THE TAG    *\n*              NAMES TO <= 8 CHARACTERS IF YOU MUST USE ASSEMBLER F.  *\n*              ASSEMBLY OF WPC REQUIRES SYS1.MODGEN.                  *\n*  CHANGE HISTORY :                                                   *\n*              10/23/86 JCB - NEW                                     *\n*              01/19/89 JCB - CONVERTED AWAY FROM CLEMSON STRUCTURED  *\n*                             MACROS TO ALLOW DIST. ON RACF MODS TAPE *\n*              05/12/93 EU  - REMOVED ASSEMBLER F RESTRICTIONS AND    *\n*                             USE OF LOCAL MACROS ($DEFREG, $XENT AND *\n*                             $XRET). MOINIL P.A.                     *\n*                                     COMPUTING CENTER (TP 361)       *\n*                                     J.R.C. - ISPRA ESTABLISHMENT    *\n*                                     21020 ISPRA (VA), ITALY         *\n*  METHOD OF OPERATION :                                              *\n*              - PARSE COMMAND FOR DATA-SET NAME                      *\n*              - GET DATA-SET'S VOLSER FROM CATALOG                   *\n*              - ISSUE RACHECK FOR ALTER WITH MAGIC OPTION            *\n*              - TELL USER WHAT WE FOUND                              *\n*  ORIGIN :    EXTRACTED FROM CBT 92 MAR TAPE, FILE 7.                *\n*---------------------------------------------------------------------*\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12,LV=PWALEN,TYPE=RENT\n         LR    R10,R13\n         USING PWA,R10\n        $TEW$EC MSG=PUTMSG,ERR=SETRC,PUT=PUTLNE\n        $TEW$PP PARM=PARSBS,REG=R9\n         SPACE 1\n*------- LOOK AT RESULTS FROM IKJPARS,\n*              CONSTRUCT DS-NAME TO DO RACHECK FOR\n         SPACE 1\n         MVI   PWADSN,C' '\n         MVC   PWADSN+1(L'PWADSN-1),PWADSN\n         L     R1,PDEDSN           POINT TO PARSED DS-NAME\n         BCTR  R1,0                BACK UP ONE CHAR\n         CLI   0(R1),C''''         IF DS-NAME DOESN'T START W/QUOTE\n         BE    ELSE1\n         L     R15,#TSCPPL\n         USING CPPL,R15\n         L     R2,CPPLUPT          BUILD DS-NAME IN PWA BY\n         DROP  R15\n         USING UPT,R2              PREFIXING W/UPT PREFIX.\n         MVC   PWADSN+1(L'UPTPREFX),UPTPREFX A LENGTH BYTE GOES IN\n         XR    R3,R3               FRONT OF DS-NAME, TOO\n         ICM   R3,B'0001',UPTPREFL\n         LA    R15,PWADSN+1(R3)\n         MVI   0(R15),C'.'\n         LH    R14,PDEDSN+4\n         LA    R3,1(R3,R14)\n         STC   R3,PWADSN\n         BCT   R14,*+L'*+6\n         MVC   1(*-*,R15),1(R1)\n         EX    R14,*-6\n         DROP  R2\n         B     ENDIF1\nELSE1    LH    R15,PDEDSN+4        MOVE STRAIGHT DS-NAME, PUT\n         STC   R15,PWADSN          LENGTH BYTE ON FRONT, TOO\n         BCT   R15,*+L'*+6\n         MVC   PWADSN+1(*-*),1(R1)\n         EX    R15,*-6\n         SPACE 1\n*------- SEE IF DATA-SET IS CATALOGUED, AND WHAT VOLUME IT'S ON.\n*              NOTE THAT WPC DOES NOT SUPPORT UNCATALOGUED DATA-SETS.\n         SPACE 1\nENDIF1   MVC   PWACML(LENCML),STCCML COPY LOCATE PARMS\n         LA    R1,PWADSN+1\n         ST    R1,CMLDSNAM         SET A(DS-NAME) FOR LOCATE\n         LA    R1,PWACAMWA\n         ST    R1,CMLWORK          SET A(WORKAREA) FOR LOCATE\n         XC    CMLCVOL,CMLCVOL     NO CVOL.\n        LOCATE PWACML              SEE IF CATLG'D TO GET VOLUME\n         LTR   R15,R15             LOCATE ERROR?\n         BZ    ENDIF2\n         LA    R0,L'STCNCATM       ASSUME IT'S UNCATALOGUED\n         LA    R1,STCNCATM\n         BAS   R14,PUTLNE\n         B     LEAVE               EXIT WPC COMMAND\n         SPACE 1\n*------- RACHECK THE DATA-SET NAME PROVIDED WITH THE MAGIC OPTION.\n         SPACE 1\nENDIF2   MVC   PWARCHK(LENRCHK),STCRCHK RACHECK PARMS -> PWA\n         LA    R1,PWARCHK          BASE ON RACHECK PARMS\n         USING ACHKLIST,R1\n         OI    ACHKFLG3,ACHKPRI\n         DROP  R1\n        MODESET KEY=ZERO           MAGIC PARM REQUIRES KEY ZERO\n         LA    R3,PWACAMWA+6       GET POINTER TO VOLSER\n        RACHECK ENTITY=(PWADSN+1), ISSUE RACHECK                       X\n               VOLSER=(R3),                                            X\n               MF=(E,PWARCHK)\n         LTR   R15,R15\n         BNZ   RACKERR\n         SPACE 1\n*------- BUILD AND ISSUE RESULTS MESSAGE\n         SPACE 1\n         MVC   PWAGEN+1(L'PWAGEN-1),4(R1) R1 POINTS TO RETURN AREA :\n*                                  PROFILE NAME IS AT +4\n        MODESET KEY=NZERO          GET NORMAL AGAIN\n         LA    R1,PWAGEN+1         SEE HOW LONG PROFILE NAME IS\nLOOP1    CLI   0(R1),C' '          BY SCANNONG FOR A BLANK\n         BE    ENDLOOP1\n         LA    R1,1(R1)\n         B     LOOP1\nENDLOOP1 LA    R15,PWAGEN+1        GET START OF NAME\n         SR    R1,R15              GET DIFFERENCE AND\n         STC   R1,PWAGEN           SET LENGTH\n         MVI   PWAMSG,C' '         BUILD MESSAGE\n         MVC   PWAMSG+1(L'PWAMSG-1),PWAMSG\n         MVC   PWAMSG(L'STCRM1),STCRM1 MESSAGE SEGMENT 1\n         XR    R1,R1               INCLUDE DATA-SET NAME\n         ICM   R1,B'0001',PWADSN\n         BCT   R1,*+L'*+6\n         MVC   PWAMSG+L'STCRM1(*-*),PWADSN+1\n         EX    R1,*-6\n         LA    R1,PWAMSG+L'STCRM1+1(R1) POINT PAST DS-NAME\n         MVC   0(L'STCRM2,R1),STCRM2 MESSAGE SEGMENT 2\n         LA    R1,L'STCRM2(R1)     POINT PAST MSGSEG 2\n         XR    R15,R15\n         ICM   R15,B'0001',PWAGEN\n         BCT   R15,*+L'*+6         INCLUDE PROFILE NAME\n         MVC   0(*-*,R1),PWAGEN+1\n         EX    R15,*-6\n         LA    R1,1(R1,R15)\n         MVI   0(R1),C')'          APPEND CLOSING PAREN\n         LA    R0,1(R1)            POINT TO END OF MESSAGE\n         LA    R1,PWAMSG           POINT TO START\n         SR    R0,R1               GET DIFFERENCE = LENGTH\n         BAS   R14,PUTLNE          SAY WHAT WE FOUND\n         SPACE 1\n*------- TERMINATE\n         SPACE 1\nLEAVE    XR    R15,R15             RC=0 -------------------------------\nENDWPC  $XRET  CC=(R15),LV=PWALEN,TYPE=RENT\nSETRC    LA    R15,12              RC=12 ------------------------------\n         B     ENDWPC\n         SPACE 1\n*------- BLOCK NAME=RACKERR,TYPE=ERREXIT\nRACKERR  LR    R3,R15              SAVE RACHECK RETURN CODE\n        MODESET KEY=NZERO          WE GOT CALLED IN KEY ZERO\n         CH    R3,=H'4'\n         BE    RENOPF\n         LA    R0,L'STCRCKIA       RC=8 : INSUFFICIENT ACCESS\n         LA    R1,STCRCKIA\n         B     RACKEND\nRENOPF   LA    R0,L'STCRCKNP       RC=4 : NO PROFILE\n         LA    R0,STCRCKNP\nRACKEND  BAS   R14,PUTLNE\n         LA    R15,8               RC=8 -------------------------------\n         B     ENDWPC\n         EJECT\n*------- SKELETONS AND CONSTANTS\n         SPACE 1\nSTCCML  CAMLST NAME,*,,*           CAMLST NAME FOR GETTING VOLSERS\nLENCML   EQU   *-STCCML\n         SPACE 1\nSTCRCKIA DC    C'INSUFFICIENT ACCESS TO DATA-SET.'\nSTCRCKNP DC    C'DATA-SET IS NOT COVERED BY A RACF PROFILE.'\nSTCNCATM DC    C'DATA-SET IS NOT CATALOGUED.'\nSTCRM1   DC    C'ENTITY('\nSTCRM2   DC    C') IS PROTECTED BY PROFILE('\n         SPACE 1\nSTCRCHK RACHECK CLASS='DATASET',ATTR=ALTER,MF=L\nLENRCHK  EQU   *-STCRCHK\n         SPACE 1\n        LTORG  ,                   LITERAL POOL\n         SPACE 1\n*------- IKJPARS MACROS\n         SPACE 1\n        PRINT  NOGEN\nPARSBS  IKJPARM ,\nPDEDSN  IKJPOSIT DSNAME,                                               X\n               PROMPT='DATA-SET NAME TO LOCATE PROFILE FOR'\n        IKJENDP ,\n        PRINT  GEN\n         EJECT\n*------- WORK-AREAS DESCRIPTION\n         SPACE 1\nPWA      DSECT ,\n         DS    18F                 STANDARD SAVE AREA\n        $TEW$WA\nPWARCHK  DS    0F,CL(LENRCHK)      RACHECK PARMS\nPWACML   DS    0F,CL(LENCML)       LOCATE DS-NAMES IN CATALOG\n         ORG   PWACML\n         DS    F                   FLAGS FOR LOCATE\nCMLDSNAM DS    F                   A(DATA-SET NAME)\nCMLCVOL  DS    F                   CVOL POINTER OR ZERO\nCMLWORK  DS    F                   A(LOCATE'S PWA)\n         ORG   ,\nPWAMSG   DS    CL100\nPWADSN   DS    CL45\nPWAGEN   DS    CL45\nPWACAMWA DS    0D,XL265\n         SPACE 1\nPWALEN   EQU   (((*-PWA)+7)/8)*8\n         SPACE 1\n        PRINT  NOGEN\n        $TEW$DS\n        IKJUPT ,\n        ICHACHKL ,                 <- MAPPING MACRO FOR RACHECK PL\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WPC$": {"ttr": 39172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x13/\\x00\\x93\\x13/\\x144\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-05-12T00:00:00", "modifydate": "1993-05-12T14:34:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//WPC      JOB (........),'INSTALL  - W P C -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJIAS3,OPT=',RENT',MBR=WPC\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT,AC=1'\n//SYSIN     DD *\n  ENTRY   WPC\n  NAME    WPC(R)\n/*\n//HLP     EXEC PAJHELP,MBR=WPCH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WPC@": {"ttr": 39174, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x13/\\x00\\x93\\x13/\\x14!\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-05-12T00:00:00", "modifydate": "1993-05-12T14:21:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SYSPAJA"}, "text": "1   12/05/93\n                                                      WPC       1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *   WHAT PROFILE COVERS TSO command   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Origin :     extracted from tape CBT 92 MAR, file 7.\n  --------\n\n  Function :   display the name of the RACF PROFILE that covers the\n  ----------   data-set name given on the command.\n               Remark : the data-set name must be catalogued.\n\n  Command syntax : WPC DSNAME\n  ---------------- Required : DSNAME\n                   Default : none.\n\n  Operand :    DSNAME - Data-set name.\n  ---------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WPCH": {"ttr": 39176, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x13/\\x00\\x93\\x13/\\x14\"\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-05-12T00:00:00", "modifydate": "1993-05-12T14:22:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=WPC\n./     NUMBER  NEW1=100,INCR=100\n)F Function : display the name of the RACF PROFILE that covers the\n              data-set name given on the command.\n              Remark : the data-set name must be catalogued.\n)X Syntax :   WPC DSNAME\n              Required : DSNAME\n              Default : none.\n)O Operand :  DSNAME - Data-set name.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XTC": {"ttr": 39178, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\x12&\\x00?\\x00?\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T12:26:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "SYSPAJA"}, "text": "XTC      TITLE 'CALL TSO COMMANDS INVOKER.'\nXTC      START 0\n         SPACE 1\n         AIF   ('&SYSPARM' NE 'TSO/E').O1S1\n         ENTRY XTCE\n         SPACE 1\n* PURPOSE :    CALL TSO COMMANDS INVOKER (SEE XTCL/XTCLE FOR DETAILS).\n* --------\n         AGO   .O1S2\n.O1S1    SPACE 1\n* PURPOSE :    CALL TSO COMMANDS INVOKER (SEE XTCL FOR DETAILS).\n* --------\n.O1S2    SPACE 1\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n         USING *,R15\n         MVI   ID+3,C' '           SET XTC CALL/LOAD\n         B     BEGIN\n         AIF   ('&SYSPARM' NE 'TSO/E').O2S1\n         DROP  R15\n         SPACE 1\n         USING *,R15\nXTCE     MVI   ID+3,C'E'           SET XTCE CALL/LOAD\n         B     BEGIN\n         DROP  R15\n.O2S1    SPACE 1\n         DC    CL4'XTC-'           IDENTIFIER\n         DC    CL8'&SYSDATE'       ASSEMBLY DATE (MM/DD/YY)\n         DC    CL6'-&SYSTIME'      ASSEMBLY TIME (-HH.MM)\n         EJECT\n         AIF   ('&SYSPARM' NE 'TSO/E').O2S2\nBEGIN    BASR  R15,0               SET COMMON BASE\n         USING *,R15\n         STM   R14,R1,REGS         SAVE WHAT I NEED\n         AGO   .O2S3\n.O2S2    CNOP  0,4\nBEGIN    STM   R14,R1,REGS         SAVE WHAT I NEED\n.O2S3   LOAD   EPLOC=ID            LOAD TRUE MODULE\n         DROP  R15\n         LR    R15,R0              SET ENTRY POINT\n         BASR  R14,0\n         USING *,R14\n         LM    R0,R1,REGS+8        GET BACK PARAMETERS\n         DROP  R14\n         BASR  R14,R15             GO TO INVOKER = CALL (15)\n         USING *,R14\n         STM   R15,R0,REGS+4       SAVE COMPLETION CODES\n        DELETE EPLOC=ID            DELETE TRUE MODULE\n         DROP  R14\n         BASR  R14,0\n         USING *,R14\n         LM    R14,R1,REGS         SET RETURN REGISTERS\n         DROP  R14\n         BR    R14                 BACK TO CALLER\n         SPACE 2\nREGS     DC    4F'0'               REGISTERS WORK AREA\nID       DC    CL8'XTC'            LOAD/DELETE NAME\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XTC$": {"ttr": 39180, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942/\\x00\\x942/\\x14%\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1994-11-18T14:25:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "//XTC      JOB (........),'INSTALL  - X T C -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* NOTES : 1. THE STEPS BELOW ASSUME TSO/E INSTALLED.                *\n//*         2. IF TSO/E IS NOT INSTALLED, REMOVE :                    *\n//*            A. THE OPT= FIELD IN THE STEP 'ASS',                   *\n//*            B. THE STEPS 'ASXE' AND 'LNKXE'.                       *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJIAS2,OPT=',SYSPARM(TSO/E)',MBR=XTC\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  ENTRY   XTC\n  NAME    XTC(R)\n/*\n//ASX     EXEC PAJIAS3,MBR=XTCL\n//LNKX    EXEC PAJILKL        (MUST BE A LIBRARY DEFINED IN LINKLIST)\n//SYSIN     DD *\n  ENTRY   XTC\n  NAME    XTC(R)\n/*\n//ASXE    EXEC PAJIAS3,MBR=XTCLE   ---> IF TSO/E INSTALLED\n//LNKXE   EXEC PAJILKL        (MUST BE A LIBRARY DEFINED IN LINKLIST)\n//SYSIN     DD *\n  ENTRY   XTCE\n  NAME    XTCE(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XTC@": {"ttr": 39182, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12o\\x00\\x88\\x12o\\x12W\\x00T\\x00T\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-05T00:00:00", "modifydate": "1988-05-05T12:57:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "SYSPAJA"}, "text": "1   09/04/86\n                                                      XTC       1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        EXECUTE TSO COMMANDS         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           AND/OR CLISTS.            * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Allows a program running in a TSO environment to\n  ---------    invoke and thus execute TSO commands and/or CLISTs\n               (implicit form only is accepted).\n\n  Calling sequence : CALL XTC,(A,B,C,D),VL\n  ------------------          (A,B,C)\n                              (A,B)\n                              (A)\n\n         Where : A - is the address of the TSO command or CLIST text\n                     to be invoked (no alignment needed, but maximum\n                     240 characters long allowed).\n                 B - is the address of the TSO command or CLIST text\n                     length (number of characters - FULLWORD). When\n                     this argument is omitted, or the address of this\n                     argument is set to zero in the parameters list,\n                     the length is assumed to be in the byte (format\n                     XL1) just preceeding the TSO command or CLIST\n                     text, at the address of A-1.\n                 C - is the address of a FULLWORD into which the TSO\n                     command or CLIST execution highest completion\n                     code is stored (format XL4'00SSSUUU', where SSS\n                     is the system code and UUU is the user code),\n                     if supplied.\n                     In any case the value is always placed in the\n                     register 0.\n                 D - is the address of a FULLWORD to store the return\n                     code, if supplied. Value is always placed in\n                     register 15 and can be :\n                      0 - all processings done.\n                      1 - command failed.\n                      2 - invalid command text length.\n                      3 - argument alignment error.\n                      4 - missing command.\n                      5 - invalid command.\n                      6 - command rejected (unsupported).\n                      7 - unable to locate CPPL.\n                      8 - not TSO environment.\n\n         At entry, register 0 is used as messages switch :\n                 - zero to suppress all messages.\n                 - positive to obtain error messages only.\n                 - negative to obtain all messages.\n1   30/07/86\n                                                      XTC       2/2.\n\n  Assembler macro : $XTC A,B,C,D,TSO=,MSG=YES,MF=E\n  -----------------                       NO     (E,...)\n                                          ALL\n                 or $XTC A,B,C,D,MF=L\n\n         Where B, C and/or D are optional and may be omitted.\n         Register use may be coded within parentheses (obviously\n         only in the execute form of the macro).\n         Default : MSG=YES and MF=E.\n\n  BACKGROUND execution :\n  ----------------------\n\n         When used by a program in batch, it must be started by the\n  following JCL statements :\n\n         //IKJ     EXEC PGM=IKJEFT01\n         //SYSPROC   DD ... TSO commands procedures ...\n         //...       DD ... Program DD's if needed ...\n         //SYSTSPRT  DD SYSOUT=*\n         //SYSTSIN   DD *\n         CALL ...Program...\n         END\n         /*\n\n  ADVICE : When running in a batch environment, the commands or\n  ======== programs using TPUT/TGET are not supported.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XTCE@": {"ttr": 39185, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12o\\x00\\x88\\x12o\\x12W\\x00X\\x00X\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-05T00:00:00", "modifydate": "1988-05-05T12:57:00", "lines": 88, "newlines": 88, "modlines": 0, "user": "SYSPAJA"}, "text": "1   30/07/86\n                                                      XTCE      1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       EXECUTE TSO/E COMMANDS        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           AND/OR CLISTS.            * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Allows a program running in a TSO/E environment to\n  ---------    invoke and thus execute TSO commands and/or CLISTs.\n\n  Calling sequence : CALL XTCE,(A,B,C,D),VL\n  ------------------           (A,B,C)\n                               (A,B)\n                               (A)\n\n         Where : A - is the address of the TSO command or CLIST text\n                     to be invoked (no alignment needed, but maximum\n                     240 characters long allowed).\n                 B - is the address of the TSO command or CLIST text\n                     length (number of characters - FULLWORD). When\n                     this argument is omitted, or the address of this\n                     argument is set to zero in the parameters list,\n                     the length is assumed to be in the byte (format\n                     XL1) just preceeding the TSO command or CLIST\n                     text, at the address of A-1.\n                 C - is the address of a FULLWORD into which the TSO\n                     command or CLIST execution completion code is\n                     stored, if supplied. The format is XL4'CCSSSUUU',\n                     where CC is the completion code (TSO service\n                     return code), SSS is the system code (abend code)\n                     and UUU is the user code (reason code or function\n                     return code).\n                     In any case the value is always placed in the\n                     register 0.\n                 D - is the address of a FULLWORD to store the return\n                     code, if supplied. Value is always placed in\n                     register 15 and can be :\n                      0 - all processings done.\n                      1 - command failed.\n                      2 - invalid command text length.\n                      3 - argument alignment error.\n                      4 - missing command.\n                      5 - invalid command.\n                      6 - command rejected (unsupported).\n                      7 - unable to locate CPPL.\n                      8 - not TSO environment.\n\n         At entry, register 0 is used as messages switch :\n                 - zero to suppress all messages.\n                 - positive to obtain error messages only.\n                 - negative to obtain all messages.\n1   30/07/86\n                                                      XTCE      2/2.\n\n  Assembler macro : $XTC A,B,C,D,MSG=YES,MF=E\n  -----------------                  NO     (E,...)\n                                     ALL\n                 or $XTC A,B,C,D,MF=L\n\n         Where B, C and/or D are optional and may be omitted.\n         Register use may be coded within parentheses (obviously\n         only in the execute form of the macro).\n         Default : MSG=YES and MF=E.\n\n  BACKGROUND execution :\n  ----------------------\n\n         When used by a program in batch, it must be started by the\n  following JCL statements :\n\n         //IKJ     EXEC PGM=IKJEFT01\n         //SYSPROC   DD ... TSO commands procedures ...\n         //...       DD ... Program DD's if needed ...\n         //SYSTSPRT  DD SYSOUT=*\n         //SYSTSIN   DD *\n         CALL ...Program...\n         END\n         /*\n\n  ADVICES : When running in a batch environment, the commands or\n  ========= programs using TPUT/TGET are not supported.\n            Do not pass a CLIST command directly to XTC (it will fail),\n            but use the EXEC 'dsname(member)' command to execute the\n            CLIST (all CLISTs variables may be accessed).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XTCL": {"ttr": 39188, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882/\\x00\\x882/\\x112\\x02l\\x02l\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-17T00:00:00", "modifydate": "1988-11-17T11:32:00", "lines": 620, "newlines": 620, "modlines": 0, "user": "SYSPAJA"}, "text": "XTCL     TITLE 'TSO COMMANDS AND/OR CLISTS INVOKER.'\nXTC      START 0\n         SPACE 1\n* PURPOSE :    ALLOWS A PROGRAM RUNNING IN A TSO ENVIRONMENT TO\n* ---------    INVOKE AND THUS EXECUTE TSO COMMANDS AND/OR CLISTS\n*              (IMPLICIT FORM ONLY IS ACCEPTED).\n*\n* CALLING SEQUENCE : CALL XTC,(A,B,C,D),VL\n* ------------------          (A,B,C)\n*                             (A,B)\n*                             (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE COMMAND OR CLIST TEXT TO\n*                    BE INVOKED (NO ALIGNMENT NEEDED, BUT MAXIMUM 240\n*                    CHARACTERS LONG ALLOWED).\n*                B - IS THE ADDRESS OF THE COMMAND OR CLIST TEXT\n*                    LENGTH (NUMBER OF CHARACTERS - FULLWORD). WHEN\n*                    THIS ARGUMENT IS OMITTED, OR THE ADDRESS OF THIS\n*                    ARGUMENT IS SET TO ZERO IN THE PARAMETERS LIST,\n*                    THE LENGTH IS ASSUMED TO BE IN THE BYTE (FORMAT\n*                    XL1) JUST PRECEEDING THE COMMAND OR CLIST TEXT,\n*                    AT THE ADDRESS OF A-1.\n*                C - IS THE ADDRESS OF A FULLWORD INTO WHICH THE\n*                    COMMAND OR CLIST EXECUTION HIGHEST COMPLETION\n*                    CODE IS STORED (FORMAT XL4'00SSSUUU', WHERE SSS\n*                    IS THE SYSTEM CODE AND UUU IS THE USER CODE),\n*                    IF SUPPLIED.\n*                    IN ANY CASE THE VALUE IS ALWAYS PLACED IN THE\n*                    REGISTER 0.\n*                D - IS THE ADDRESS OF A FULLWORD TO STORE THE RETURN\n*                    CODE, IF SUPPLIED. VALUE IS ALWAYS PLACED IN\n*                    REGISTER 15 AND CAN BE :\n*                     0 - ALL PROCESSINGS DONE.\n*                     1 - COMMAND FAILED.\n*                     2 - INVALID COMMAND TEXT LENGTH.\n*                     3 - ARGUMENT ALIGNMENT ERROR.\n*                     4 - MISSING COMMAND.\n*                     5 - INVALID COMMAND.\n*                     6 - COMMAND REJECTED (UNSUPPORTED).\n*                     7 - UNABLE TO LOCATE CPPL.\n*                     8 - NOT TSO ENVIRONMENT.\n*\n*        AT ENTRY, REGISTER 0 IS USED AS MESSAGES SWITCH :\n*                - ZERO TO SUPPRESS ALL MESSAGES.\n*                - POSITIVE TO OBTAIN ERROR MESSAGES ONLY.\n*                - NEGATIVE TO OBTAIN ALL MESSAGES.\n         EJECT\n* OPERATIONAL NEEDS : XTC IS INCLUDED AT PROGRAM LINK-EDIT TIME.\n* ------------------- XTCL MUST BE LINK-EDITED IN A LIBRARY DEFINED\n*              IN THE LINKLIST (LNKLST00 OF SYS1.PARMLIB) AND THIS\n*              LIBRARY IS RACF PROTECTED AGAINST ANY USERS READ OR\n*              WRITE (ONLY SYSTEM GROUP MAY ACCESS IT).\n*              THIS ALLOWS MODIFICATIONS WITHOUT INVOLVING USERS.\n*              REMARK : THE CODE IS NOT 'RENT' NOR 'REUS', IT IS\n*                       BASED ON THE FACT THAT THE MODULE IS EACH\n*                       TIME RE-LOADED.\n*\n*              WHEN USED BY A PROGRAM IN BATCH, YOU MUST START WITH\n*              THE FOLLOWING JCL STATEMENTS :\n*\n*                       //IKJ     EXEC PGM=IKJEFT01\n*                       //SYSPROC   DD ... TSO COMMANDS PROCEDURES\n*                       //...       DD ... PROGRAM DD'S IF NEEDED\n*                       //SYSTSPRT  DD SYSOUT=*\n*                       //SYSTSIN   DD *\n*                       CALL ...PROGRAM...\n*                       END\n*                       /*\n*\n* ADVICE : WHEN RUNNING IN A BATCH ENVIRONMENT, THE COMMANDS OR\n* ======== PROGRAMS USING TGET/TPUT ARE NOT SUPPORTED.\n*          MVS/XA : MUST BE AMODE AND RMODE 24.\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        SPLEVEL SET=1\n         SPACE 2\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12\n         LR    R5,R1               SAVE PARAMETERS LIST POINTER\n         LTR   R0,R0               WANT MESSAGES?\n         BP    INIT                YES\n         BM    SALL                ALL\n         OI    XSWX,NOMSG          SET MSG=NO\n         B     INIT\nSALL     OI    XSWX,ALLMSG         SET MSG=ALL\n         SPACE 1\nINIT    EXTRACT ATSO,'S',FIELDS=(TSO,PSB)\n         EJECT\n*        ARGUMENTS CONTROL.\n         SPACE 1\n         XR    R1,R1\n         XR    R2,R2\n         XR    R3,R3\n         XR    R4,R4\n         LA    R10,MAXERR\n         ICM   R4,B'0111',1(R5)    GET ARGUMENTS\n         TM    0(R5),X'80'\n         BO    ARAN\n         ICM   R3,B'0111',5(R5)\n         TM    4(R5),X'80'\n         BO    ARAN\n         ICM   R1,B'0111',9(R5)\n         TM    8(R5),X'80'\n         BO    ARAN\n         ICM   R2,B'0111',13(R5)\nARAN     STM   R1,R2,ACCC\n         LTR   R1,R1\n         BZ    NOCC\n         TM    ACCC+3,X'03'\n         BNZ   ERR3\n         XC    0(4,R1),0(R1)\nNOCC     LTR   R2,R2\n         BZ    NORC\n         TM    ACRC+3,X'03'\n         BNZ   ERR3\n         XC    0(4,R2),0(R2)\nNORC     LTR   R4,R4\n         BZ    ERR4\n         LTR   R3,R3               GET LENGTH\n         BNZ   ARSL\n         LR    R1,R4\n         BCTR  R1,0\n         IC    R3,0(R1)\n         B     ARST\nARSL     TM    7(R5),X'03'\n         BNZ   ERR3\n         L     R3,0(R3)\nARST     L     R1,ATSO\n         TM    0(R1),X'80'\n         BZ    *+L'*+4\n         OI    XSWX,XFORE\n         OC    APSCB,APSCB\n         BZ    ERR8\n         LTR   R3,R3               VALIDATE ARGUMENTS\n         BNP   ERR2\n         CH    R3,=H'240'\n         BH    ERR2\n         AR    R3,R4\n         LR    R1,R3\n         BCTR  R3,0\n         EJECT\n*        COMMAND/CLIST CONTROL.\n         SPACE 1\n         LA    R2,1\nLNME     CLI   0(R4),C' '          FIND NAME\n         BNE   CNME\nFNME     BXLE  R4,R2,LNME\n         B     ERR4\nCNME     CLI   0(R4),C'%'          CLIST EXECUTION?\n         BNE   SNME                NO\n         OI    XSWX,CLTSO          INDICATE CLIST\n         B     FNME\nSNME     SR    R1,R4\n         LR    R0,R1\n         AH    R0,=H'4'\n         STH   R0,LCMD             SET COMMAND BUFFER LENGTH\n         BCTR  R1,0\n         EX    R1,SNCMD            MOVE COMMAND TEXT\n         LR    R1,R4\nFENME    BXLE  R4,R2,*+L'*+4\n         B     ENME\n         CLI   0(R4),C' '\n         BNE   FENME\nENME     LR    R5,R4\n         SR    R5,R1\n         BNP   ERR5\n         CH    R5,=H'8'\n         BH    ERR5\n         BCTR  R5,0\n         MVC   TCMD,=CL8' '\n         EX    R5,MVCMD\n         TM    XSWX,XFORE\n         BO    SFORE\n         L     R1,=A(TCMDB)        SCAN RESERVED COMMAND (BACKGROUND)\n         B     LSCT\nSFORE    L     R1,=A(TCMDF)        SCAN RESERVED COMMAND (FOREGROUND)\nLSCT     CLI   0(R1),X'FF'         END OF TABLE?\n         BE    TXEQ                YES\n         CLC   TCMD(L'TCMD),0(R1)  MATCH?\n         BE    ERR6                YES, REJECT IT\n         LA    R1,L'TCMDB(R1)      BUMP TO NEXT\n         B     LSCT\n         EJECT\n*        TSO ENVIRONMENT CONTROL.\n         SPACE 1\n         USING PSA,R0\nTXEQ     L     R2,PSATOLD          CURRENT TCB ADDRESS\n         DROP  R0\n         XR    R4,R4\n         USING TCB,R2\nTSCT     L     R3,TCBRBP           CURRENT RB ADDRESS\n         LTR   R3,R3\n         BZ    NXTTCB\n         USING RBBASIC,R3\n         ICM   R4,B'0111',RBCDE1   CURRENT CDE ADDRESS\n         BZ    NXTTCB\n         USING CDENTRY,R4\n         CLC   CDNAME,=CL8'IKJEFT02'\n         BE    TFND\nNXTTCB   L     R2,TCBOTC           ORIGINATING TCB\n         LTR   R2,R2\n         BNZ   TSCT\n         B     ERR7\n         DROP  R3,R4\nTFND     L     R3,TCBGRS9          GET TMP WORK-AREA ADDRESS\n         DROP  R2\n         USING TPL,R3\n         L     R4,CPPLPTR\n         DROP  R3\n         USING CPPL,R4\n         L     R2,APSCB\n         USING PSCB,R2\n         CLC   PSCBUPT,CPPLUPT     UPT ADDRESSES MATCH?\n         BNE   ERR7                NO\n         CL    R2,CPPLPSCB         CPPL+8 = PSCB ADDRESS?\n         BNE   ERR7                NO\n         MVC   XCPPL+4(3*4),CPPLUPT     COPY CPPL\n         DROP  R2,R4\n         EJECT\n*        EXECUTE COMMAND/CLIST.\n*        (BASED ON Q31 IN FILE 153 OF CBT TAPE)\n         SPACE 1\n         LA    R2,XCPPL            ADDRESS OF CPPL FOR COMMAND\n         USING CPPL,R2\n         L     R3,CPPLECT          POINT TO ECT\n         USING ECT,R3\n         LA    R4,GTPBL            GETLINE PARM BLOCK ADDRESS\n         USING GTPB,R4\n         MVC   XPCMD,ECTPCMD       SAVE PRIMARY COMMAND NAME\n         MVC   XSCMD,ECTSCMD       SAVE SECONDARY COMMAND NAME\n         LA    R1,XCSPL            ADDRESS OF IKJSCAN PARM LIST\n         USING CSPL,R1\n         MVC   CSPLUPT,CPPLUPT     COPY UPT POINTER\n         MVC   CSPLECT,CPPLECT     COPY ECT POINTER\n         LA    R15,XECB            ADDRESS OF ECB\n         ST    R15,CSPLECB\n         LA    R15,XTCB            ADDRESS OF FLAGS\n         ST    R15,CSPLFLG\n         LA    R15,XCSOA           ADDRESS OF OUTPUT AREA\n         ST    R15,CSPLOA\n         DROP  R1\n         LA    R1,XCMD             ADDRESS OF COMMAND\n         USING CMDBUF,R1\nCSCAN    XC    CMDOFF,CMDOFF       CLEAR OFFSET TO SECOND OPERAND\n         DROP  R1\n         ST    R1,CPPLCBUF         SET BUFFER CB POINTER\n         LA    R1,XCSPL            ADDRESS OF IKJSCAN PARM LIST\n         USING CSPL,R1\n         MVC   CSPLCBUF,CPPLCBUF   COPY COMMAND BUFFER POINTER\n         DROP  R1\n         XC    XECB,XECB           CLEAR ECB\n         XC    XTCB,XTCB           CLEAR FLAGS\n         XC    XCSOA(2*4),XCSOA    CLEAR OUTPUT AREA\n        CALLTSSR EP=IKJSCAN        SCAN INPUT BUFFER\n         XC    XECB,XECB           CLEAR ECB\n         LA    R1,XCSOA            ADDRESS OF OUTPUT AREA\n         USING CSOA,R1\n         L     R14,CSOACNM         POINTER TO COMMAND NAME\n         ICM   R15,B'0011',CSOALNM LENGTH OF NAME\n         BZ    NOCMD               NONE, SKIP REST\n         TM    CSOAFLG,CSOAQM+CSOANOC   Q.M. OR NO CMD?\n         BNZ   NOCMD               YES, SKIP REST\n         BCTR  R15,0\n         MVC   XBLNM,=CL8' '       FILL WITH BLANKS\n         EX    R15,MVBNM           MOVE TO BLDL NAME\n         TM    CSOAFLG,CSOABAD     BAD COMMAND NAME?\n         BZ    TEXEC               NO\n         L     R1,=A(DIAGB)\n         MVC   DIAGBD(L'DIAGBD,R1),=CL3'BAD'\n         B     SDIAG\nTEXEC    CLC   XBLNM(2),=CL2'EX'   EXEC COMMAND?\n         BNE   TVALID              NO\n         TM    CSOAFLG,CSOAEXEC    IMPLICIT EXEC CMD NAME?\n         BZ    INVCMD              NO, INVALID\nTVALID   TM    CSOAFLG,CSOAVWP+CSOAVNP  VALID COMMAND?\n         BNZ   GOCMD               YES\n         DROP  R1\nINVCMD   L     R1,=A(DIAGB)\n         MVC   DIAGBD(L'DIAGBD,R1),=CL3'INV'\nSDIAG    LA    R8,DIAGBS(R1)\n         MVI   0(R8),C' '\n         MVC   1(L'DIAGBS-1,R8),0(R8)\n         L     R15,CPPLCBUF        POINT TO BUFFER\n         USING CMDBUF,R15\n         LH    R14,CMDLEN          LENGTH\n         SH    R14,=H'4'\n         CH    R14,DIAGBL\n         BNH   *+L'*+4\n         LH    R14,DIAGBL\n         BCTR  R14,0\n         EX    R14,MVMSG\n         DROP  R15\n         CLC   L'DIAGBS-5(5,R8),=CL8' '\n         BE    *+L'*+6\n         MVC   L'DIAGBS-5(5,R8),=CL5' ... '\n         BAS   R8,SMSG\n         B     NOCMD               SKIP REST\nGOCMD    TM    XSWX,ALLMSG         ALL MESSAGES REQUEST?\n         BZ    SRCS                NO\n         L     R1,=A(DIAGA)\n         LA    R8,DIAGAS(R1)\n         MVI   0(R8),C' '\n         MVC   1(L'DIAGAS-1,R8),0(R8)\n         L     R15,CPPLCBUF        POINT TO BUFFER\n         USING CMDBUF,R15\n         LH    R14,CMDLEN          LENGTH\n         SH    R14,=H'4'\n         CH    R14,DIAGAL\n         BNH   *+L'*+4\n         LH    R14,DIAGAL\n         BCT   R14,*+L'*+L'MVMSG\nMVMSG    MVC   0(*-*,R8),CMDTEXT   <<EXECUTED>>\n         EX    R14,MVMSG\n         DROP  R15\n         CLC   L'DIAGAS-5(5,R8),=CL8' '\n         BE    *+L'*+6\n         MVC   L'DIAGAS-5(5,R8),=CL5' ... '\n         BAS   R8,SMSG\nSRCS     L     R1,CPPLCBUF         POINT TO BUFFER\n         USING CMDBUF,R1\n         LA    R15,CMDTEXT         POINT TO COMMAND TEXT\n         DROP  R1\nSRCL     CLI   0(R15),C' '         SEARCH COMMAND\n         BNE   SRCN\n         LA    R15,1(R15)\n         B     SRCL\nSRCN     CLC   0(4,R15),=CL4'END ' END COMMAND?\n         BE    NOCMD               YES, SKIP IT\n         CLC   0(4,R15),=CL4'TSO ' TSO COMMAND?\n         BNE   ANAL                NO\n         LA    R15,4(R15)\n         B     SRCN\nANAL     TM    XSWX,CLTSO          IS IT A CLIST?\n         BO    SCLST               YES\n         CLC   XBLNM(2),=CL2'EX'   IMPLICIT EXEC OF CLIST?\n         BNE   TNEX                NO\nSCLST    NI    XSWX,255-CLTSO\nTSEX     OI    XSWX,CLSTX          CLIST IN EXECUTION\n         MVC   XBLNM,=CL8'EXEC'    SET MODULE NAME TO ATTACH\n         L     R1,CPPLCBUF         POINT TO BUFFER\n         USING CMDBUF,R1\n         XC    CMDOFF,CMDOFF       CLEAR OFFSET FOR EXEC\n         DROP  R1\n         B     TATT\nTNEX     XC    XBLTTR(L'XBLTTR+L'XBLLK),XBLTTR    CLEAR\n        BLDL   0,XBLDL             CHECK FOR MODULE PRESENT\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   TSEX                NONE, MUST BE CLIST\nTATT     XC    XECB,XECB           CLEAR ECB\n         MVC   ECTPCMD,XBLNM       FAKE PRIMARY COMMAND NAME\n         MVC   ECTSCMD,=CL8' '     AND SECONDARY COMMAND NAME\n         LR    R1,R2               SET CPPL ADDRESS\n        ATTACH EPLOC=XBLNM,ECB=XECB,SF=(E,ATTCH),MF=(E,(1))\n         ST    R1,XTCB             SAVE TCB ADDRESS\n        WAIT   ECB=XECB            WAIT FOR SUBTASK COMPLETION\n         LA    R1,XTCB             POINT TO TCB POINTER\n        DETACH (1)\n         OC    XECB+1(3),XECB+1    ANY COMPLETION CODE?\n         BZ    NOCMD               NO\n         CLC   XECB+1(3),XCC+1     COMPLETION CODE TO BE RETAINED?\n         BNH   NOSTCC              NO\n         MVC   XCC+1(3),XECB+1     RETAIN HIGHEST ENCOUNTERED\nNOSTCC   TM    XSWX,NOMSG          DISPLAY RC REQUESTED?\n         BO    NOCMD               NO\n         L     R1,=A(DIAGC)\n         MVC   27(8,R1),XBLNM      GET COMMAND NAME\n         MVC   WORK+5(3),XECB+1\n         UNPK  WORK(5),WORK+5(3)   GET SYSTEM CODE\n         TR    WORK(3),TRTAB-C'0'\n         MVC   38(3,R1),WORK\n         NI    WORK+6,X'0F'        GET USER CODE\n         LH    R0,WORK+6\n         CVD   R0,WORK\n         UNPK  43(4,R1),WORK+5(3)\n         OI    46(R1),C'0'\n         BAS   R8,SMSG\nNOCMD    TM    XSWX,CLSTX          CLIST IN EXECUTION?\n         BZ    DONE                NO, DONE\n         ICM   R1,B'1111',GTPBIBUF GETLINE BUFFER\n         BZ    GSTCK               NO, SKIP\n         USING CMDBUF,R1\n         LH    R0,CMDLEN           LENGTH OF BUFFER\n         DROP  R1\n         ICM   R0,B'1000',=AL1(1)  SUBPOOL 1\n        FREEMAIN R,LV=(0),A=(1)    FREE THE BUFFER\nGSTCK    XC    XECB,XECB           CLEAR ECB\n         LA    R1,XIOPL            GETLINE I/O PARM LIST\n         L     R5,CPPLUPT          ADDRESS OF UPT\n        GETLINE PARM=(R4),UPT=(R5),ECT=(R3),ECB=XECB,MF=(E,(1))\n         CH    R15,=H'16'          END OF INPUT (STACK-CLIST)?\n         BE    DONE                YES, DONE\n         L     R1,GTPBIBUF         POINT TO INPUT BUFFER\n         B     CSCAN\n         EJECT\n*        END OF PROCESSING.\n         SPACE 1\nDONE     MVC   ECTPCMD,XPCMD       RESTORE PRIMARY COMMAND NAME\n         MVC   ECTSCMD,XSCMD       AND SECONDARY COMMAND NAME\n         DROP  R2,R3,R4\n         L     R1,ACCC\n         LTR   R1,R1\n         BZ    *+L'*+6\n         MVC   0(4,R1),XCC\n         OC    XCC+1(3),XCC+1      ANY FINAL COMPLETION CODE?\n         BNZ   CMXC                YES\n         XR    R10,R10             ALL OK\n         B     LEAVE\nCMXC     L     R1,=A(DIAG1)\n         MVC   WORK+5(3),XCC+1\n         UNPK  WORK(5),WORK+5(3)   GET SYSTEM CODE\n         TR    WORK(3),TRTAB-C'0'\n         MVC   38(3,R1),WORK\n         NI    WORK+6,X'0F'        GET USER CODE\n         LH    R0,WORK+6\n         CVD   R0,WORK\n         UNPK  43(4,R1),WORK+5(3)\n         OI    46(R1),C'0'\nERR1     BCTR  R10,0          COMMAND FAILED\nERR2     BCTR  R10,0          INVALID COMMAND TEXT LENGTH\nERR3     BCTR  R10,0          ARGUMENT ALIGNMENT ERROR\nERR4     BCTR  R10,0          MISSING COMMAND\nERR5     BCTR  R10,0          INVALID COMMAND\nERR6     BCTR  R10,0          COMMAND REJECTED (UNSUPPORTED)\nERR7     BCTR  R10,0          UNABLE TO LOCATE CPPL\nERR8     BCTR  R10,0          NOT TSO ENVIRONMENT\nMAXERR   EQU   ((*-ERR1)/2)+1\n         TM    XSWX,NOMSG\n         BO    LEAVE\n         LR    R1,R10\n         BCTR  R1,0\n         SLL   R1,2\n         AL    R1,=A(TABD)\n         L     R1,0(R1)\n         BAS   R8,SMSG\nLEAVE    L     R1,4(R13)\n         MVC   20(4,R1),XCC        SET R0\n         L     R1,ACRC\n         LTR   R1,R1\n         BZ    *+L'*+4\n         ST    R10,0(R1)\n        $XRET  CC=(R10)\n         EJECT\n*        SEND MESSAGES ROUTINE.\n*              R1 : WTO MESSAGE ADDRESS.\n*              R8 : LINK REGISTER.\n         SPACE 1\nSMSG     TM    XSWX,XFORE\n         BO    STSO\n        WTO    MF=(E,(1))\n         BR    R8\nSTSO     LH    R0,0(R1)\n         SH    R0,=H'4'\n         LA    R1,4(R1)\n        TPUT   (1),(0)\n         BR    R8\n         SPACE 2\nSNCMD    MVC   CMND(*-*),0(R4)     << EXECUTED >>\nMVCMD    MVC   TCMD(*-*),0(R1)     << EXECUTED >>\nMVBNM    MVC   XBLNM(*-*),0(R14)   << EXECUTED >>\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nWORK     DC    D'0'\nATSO     DC    A(*-*) -------/\nAPSCB    DC    A(*-*)        /---> MAINTAIN FIELDS ORDER\nACCC     DC    A(*-*) -------/\nACRC     DC    A(*-*)        /---> MAINTAIN FIELDS ORDER\nXCC      DC    F'0'                FINAL COMPLETION CODES\n         SPACE 1\nGTPBL   GETLINE MF=L\nATTCH   ATTACH SHSPV=78,SF=L\n         SPACE 1\nXTCB     DC    F'0'                TCB\nXECB     DC    F'0'                ECB\nXCPPL    DC    4F'0'               CPPL\nXIOPL    DC    4F'0'               GETLINE I/O PARM LIST\nXCSPL    DC    6F'0'               IKJSCAN PARM LIST\nXCSOA    DC    2F'0'               OUTPUT AREA FROM IKJSCAN\n         SPACE 1\nXBLDL    DS    0XL16 --------/     BLDL LIST\nXBLFF    DC    H'1'          /     NUMBER OF ENTRIES IN LIST\nXBLLL    DC    H'12'         /     LENGTH OF EACH ENTRY\nXBLNM    DC    CL8' '        /     MEMBER NAME\nXBLTTR   DC    XL3'0'        /     TTR OF MEMBER START\nXBLLK    DC    XL1'0'        /     CONCATENATION NUMBER\n*                            /---> MAINTAIN FIELDS ORDER\n         SPACE 1\nTCMD     DC    CL8' '              TEST COMMAND/CLIST NAME\nXPCMD    DC    CL8' '              PRIMARY COMMAND NAME\nXSCMD    DC    CL8' '              SECONDARY COMMAND NAME\nXCMD     DS    0F -----------/     COMMAND BUFFER\nLCMD     DC    H'0'          /\nOFFSET   DC    H'0'          /\nCMND     DC    CL240' '      /---> MAINTAIN FIELDS ORDER\n         SPACE 1\nTRTAB    DC    CL16'0123456789ABCDEF'\n         SPACE 1\nDIAGAL   DC    0H'0',AL2(L'DIAGAS)\nDIAGBL   DC    0H'0',AL2(L'DIAGBS)\nXSWX     DC    X'0'                PROCESSING SWITCHES\nXFORE    EQU   X'80'               FOREGROUND REGION\nNOMSG    EQU   X'40'               NO MESSAGES REQUEST\nALLMSG   EQU   X'20'               ALL MESSAGES REQUEST\nCLTSO    EQU   X'02'               CLIST EXECUTION REQUEST\nCLSTX    EQU   X'01'               CLIST IN EXECUTION\n         SPACE 2\n        LTORG\n         SPACE 2\n*- - - - END OF BASE REGISTER ADDRESSING - - - - - - - - - - - - - - -*\n         EJECT\n*        ERROR MESSAGES.\n         SPACE 1\nTABD     DC    A(DIAG1,DIAG2,DIAG3,DIAG4,DIAG5,DIAG6,DIAG7,DIAG8)\n         SPACE 1\n        PRINT  NOGEN\nDIAGA   WTO    '   ---> COMMAND :                                      X\n                                      ',ROUTCDE=11,DESC=7,MF=L\nDIAGAS  EQU    22,60               START OF COMMAND TEXT\nDIAGB   WTO    'XTC -     COMMAND :                                    X\n                                      ',ROUTCDE=11,DESC=7,MF=L\nDIAGBD  EQU    10,3                ERROR TYPE (BAD/INV)\nDIAGBS  EQU    24,58               START OF COMMAND TEXT\nDIAGC   WTO    'XTC - COMMAND FAILED :          (S   /U    ).',        X\n               ROUTCDE=11,DESC=7,MF=L\n         SPACE 1\nDIAG1   WTO    'XTC - ERR=1 : COMMAND(S) FAILED (S   /U    ).',        X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG2   WTO    'XTC - ERR=2 : INVALID COMMAND TEXT LENGTH.',           X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG3   WTO    'XTC - ERR=3 : ARGUMENT ALIGNMENT ERROR.',              X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG4   WTO    'XTC - ERR=4 : MISSING COMMAND.',                       X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG5   WTO    'XTC - ERR=5 : INVALID COMMAND.',                       X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG6   WTO    'XTC - ERR=6 : COMMAND REJECTED (UNSUPPORTED).',        X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG7   WTO    'XTC - ERR=7 : UNABLE TO LOCATE CPPL.',                 X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG8   WTO    'XTC - ERR=8 : NOT TSO ENVIRONMENT.',                   X\n               ROUTCDE=11,DESC=7,MF=L\n        PRINT  GEN\n         EJECT\n*        THE FOLLOWING TABLES MUST BE IN ALPHABETIC ORDER.\n         SPACE 1\nTCMDB    DS    0CL8           RESERVED COMMANDS TABLE (BACKGROUND)\n         DC    CL8'ACCOUNT'\n         DC    CL8'AUTHC'\n         DC    CL8'CDSCB'\n         DC    CL8'CJSD'\n         DC    CL8'DIDOCS'\n         DC    CL8'ISPF'\n         DC    CL8'LISTENQ'\n         DC    CL8'OPER'\n         DC    CL8'PDF'            ALIAS OF ISPF\n         DC    CL8'PDFINIT'\n         DC    CL8'POF'\n         DC    CL8'PSWR'\n         DC    CL8'PUSE'\n         DC    CL8'QSP'\n         DC    CL8'RGROUP'\n         DC    CL8'RSVENQ'\n         DC    CL8'SCHED'\n         DC    CL8'SCHEDULE'\n         DC    CL8'TEST'\n         DC    CL8'TIME'\n         DC    CL8'TSODSN'\n         DC    CL8'TSOENQ'\n         DC    CL8'UJVD'\n         DC    CL8'UNIT'\n         DC    CL8'UNITS'\n         DC    CL8'VCOREZAP'\n         DC    CL8'VSM'\n         DC    CL8'WAITR'\n         DC    CL8'ZAP'\n         DC    XL1'FF'             END OF TABLE INDICATOR\n         SPACE 1\nTCMDF    DS    0CL8           RESERVED COMMANDS TABLE (FOREGROUND)\n         DC    CL8'ACCOUNT'\n         DC    CL8'AUTHC'\n         DC    CL8'CDSCB'\n         DC    CL8'OPER'\n         DC    CL8'POF'\n         DC    CL8'PSWR'\n         DC    CL8'PUSE'\n         DC    CL8'QSP'\n         DC    CL8'TEST'\n         DC    CL8'TIME'\n         DC    CL8'UNIT'\n         DC    CL8'UNITS'\n         DC    CL8'VCOREZAP'\n         DC    CL8'VSM'\n         DC    CL8'ZAP'\n         DC    XL1'FF'             END OF TABLE INDICATOR\n         EJECT\nCMDBUF   DSECT\nCMDLEN   DS    H                   LENGTH, INCLUDES HEADER (+4)\nCMDOFF   DS    H                   OFFSET TO NON-BLANK PAST COMMAND\nCMDTEXT  DS    C                   FIRST TEXT BYTE\n         SPACE 2\n        PRINT  NOGEN\n        CVT    DSECT=YES,LIST=YES\n        IHAPSA\n        IHARB\n        IHACDE\n        IKJCPPL\n        IKJECT\n        IKJPSCB\n        IKJGTPB\n        IKJCSPL\n        IKJCSOA\n        IKJTCB\n        IKJTMPWA\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XTCLE": {"ttr": 39433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882/\\x00\\x882/\\x115\\x01\\xed\\x01\\xed\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-17T00:00:00", "modifydate": "1988-11-17T11:35:00", "lines": 493, "newlines": 493, "modlines": 0, "user": "SYSPAJA"}, "text": "XTCE     TITLE 'TSO/E COMMANDS AND/OR CLISTS INVOKER.'\nXTCE     START 0\n         SPACE 1\n* PURPOSE :    ALLOWS A PROGRAM RUNNING IN A TSO/E ENVIRONMENT TO\n* ---------    INVOKE AND THUS EXECUTE TSO COMMANDS AND/OR CLISTS.\n*\n* CALLING SEQUENCE : CALL XTCE,(A,B,C,D),VL\n* ------------------           (A,B,C)\n*                              (A,B)\n*                              (A)\n*\n*        WHERE : A - IS THE ADDRESS OF THE COMMAND OR CLIST TEXT TO\n*                    BE INVOKED (NO ALIGNMENT NEEDED, BUT MAXIMUM 240\n*                    CHARACTERS LONG ALLOWED).\n*                B - IS THE ADDRESS OF THE COMMAND OR CLIST TEXT\n*                    LENGTH (NUMBER OF CHARACTERS - FULLWORD). WHEN\n*                    THIS ARGUMENT IS OMITTED, OR THE ADDRESS OF THIS\n*                    ARGUMENT IS SET TO ZERO IN THE PARAMETERS LIST,\n*                    THE LENGTH IS ASSUMED TO BE IN THE BYTE (FORMAT\n*                    XL1) JUST PRECEEDING THE COMMAND OR CLIST TEXT,\n*                    AT THE ADDRESS OF A-1.\n*                C - IS THE ADDRESS OF A FULLWORD INTO WHICH THE\n*                    COMMAND OR CLIST EXECUTION COMPLETION CODE IS\n*                    STORED, IF SUPPLIED. THE FORMAT IS XL4'CCSSSUUU',\n*                    WHERE CC IS THE COMPLETION CODE (TSO SERVICE\n*                    RETURN CODE), SSS IS THE SYSTEM CODE (ABEND CODE)\n*                    AND UUU IS THE USER CODE (REASON CODE OR FUNCTION\n*                    RETURN CODE).\n*                    IN ANY CASE THE VALUE IS ALWAYS PLACED IN THE\n*                    REGISTER 0.\n*                D - IS THE ADDRESS OF A FULLWORD TO STORE THE RETURN\n*                    CODE, IF SUPPLIED. VALUE IS ALWAYS PLACED IN\n*                    REGISTER 15 AND CAN BE :\n*                     0 - ALL PROCESSINGS DONE.\n*                     1 - COMMAND FAILED.\n*                     2 - INVALID COMMAND TEXT LENGTH.\n*                     3 - ARGUMENT ALIGNMENT ERROR.\n*                     4 - MISSING COMMAND.\n*                     5 - INVALID COMMAND.\n*                     6 - COMMAND REJECTED (UNSUPPORTED).\n*                     7 - UNABLE TO LOCATE CPPL.\n*                     8 - NOT TSO ENVIRONMENT.\n*\n*        AT ENTRY, REGISTER 0 IS USED AS MESSAGES SWITCH :\n*                - ZERO TO SUPPRESS ALL MESSAGES.\n*                - POSITIVE TO OBTAIN ERROR MESSAGES ONLY.\n*                - NEGATIVE TO OBTAIN ALL MESSAGES.\n         EJECT\n* OPERATIONAL NEEDS : XTC IS INCLUDED AT PROGRAM LINK-EDIT TIME.\n* ------------------- XTCLE MUST BE LINK-EDITED IN A LIBRARY DEFINED\n*              IN THE LINKLIST (LNKLST00 OF SYS1.PARMLIB) AND THIS\n*              LIBRARY IS RACF PROTECTED AGAINST ANY USERS READ OR\n*              WRITE (ONLY SYSTEM GROUP MAY ACCESS IT).\n*              THIS ALLOWS MODIFICATIONS WITHOUT INVOLVING USERS.\n*              REMARK : THE CODE IS NOT 'RENT' NOR 'REUS', IT IS\n*                       BASED ON THE FACT THAT THE MODULE IS EACH\n*                       TIME RE-LOADED.\n*\n*              WHEN USED BY A PROGRAM IN BATCH, YOU MUST START WITH\n*              THE FOLLOWING JCL STATEMENTS :\n*\n*                       //IKJ     EXEC PGM=IKJEFT01\n*                       //SYSPROC   DD ... TSO COMMANDS PROCEDURES\n*                       //...       DD ... PROGRAM DD'S IF NEEDED\n*                       //SYSTSPRT  DD SYSOUT=*\n*                       //SYSTSIN   DD *\n*                       CALL ...PROGRAM...\n*                       END\n*                       /*\n*\n* NOTES :    - WHEN RUNNING IN A BATCH ENVIRONMENT, THE COMMANDS OR\n* =======      PROGRAMS USING TGET/TPUT ARE NOT SUPPORTED.\n*            - SEE THE 'TSO EXTENSIONS GUIDE TO WRITING A TERMINAL\n*              MONITOR PROGRAM OR A COMMAND PROCESSOR' MANUAL FOR\n*              MORE DETAILS (IKJEFTSR SECTION).\n*            - MVS/XA : MUST BE AMODE AND RMODE 24.\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12\n         LR    R5,R1               SAVE PARAMETERS LIST POINTER\n         LTR   R0,R0               WANT MESSAGES?\n         BP    INIT                YES\n         BM    SALL                ALL\n         OI    XSWX,NOMSG          SET MSG=NO\n         B     INIT\nSALL     OI    XSWX,ALLMSG         SET MSG=ALL\n         SPACE 1\nINIT    EXTRACT ATSO,'S',FIELDS=(TSO,PSB)\n         EJECT\n*        ARGUMENTS CONTROL.\n         SPACE 1\n         XR    R1,R1\n         XR    R2,R2\n         XR    R3,R3\n         XR    R4,R4\n         LA    R10,MAXERR\n         ICM   R4,B'0111',1(R5)    GET ARGUMENTS\n         TM    0(R5),X'80'\n         BO    ARAN\n         ICM   R3,B'0111',5(R5)\n         TM    4(R5),X'80'\n         BO    ARAN\n         ICM   R1,B'0111',9(R5)\n         TM    8(R5),X'80'\n         BO    ARAN\n         ICM   R2,B'0111',13(R5)\nARAN     STM   R1,R2,ACCC\n         LTR   R1,R1\n         BZ    NOCC\n         TM    ACCC+3,X'03'\n         BNZ   ERR3\n         XC    0(4,R1),0(R1)\nNOCC     LTR   R2,R2\n         BZ    NORC\n         TM    ACRC+3,X'03'\n         BNZ   ERR3\n         XC    0(4,R2),0(R2)\nNORC     LTR   R4,R4\n         BZ    ERR4\n         LTR   R3,R3               GET LENGTH\n         BNZ   ARSL\n         LR    R1,R4\n         BCTR  R1,0\n         IC    R3,0(R1)\n         B     ARST\nARSL     TM    7(R5),X'03'\n         BNZ   ERR3\n         L     R3,0(R3)\nARST     L     R1,ATSO\n         TM    0(R1),X'80'\n         BZ    *+L'*+4\n         OI    XSWX,XFORE\n         OC    APSCB,APSCB\n         BZ    ERR8\n         LTR   R3,R3               VALIDATE ARGUMENTS\n         BNP   ERR2\n         CH    R3,=H'240'\n         BH    ERR2\n         AR    R3,R4\n         LR    R1,R3\n         BCTR  R3,0\n         EJECT\n*        COMMAND/CLIST CONTROL.\n         SPACE 1\n         LA    R2,1\nLNME     CLI   0(R4),C' '          FIND NAME\n         BNE   CNME\nFNME     BXLE  R4,R2,LNME\n         B     ERR4\nCNME     CLI   0(R4),C'%'          CLIST EXECUTION?\n         BE    FNME                YES\n         SR    R1,R4\n         LR    R0,R1\n         ST    R0,LCMD             SET COMMAND BUFFER LENGTH\n         BCTR  R1,0\n         EX    R1,SNCMD            MOVE COMMAND TEXT\n         LR    R1,R4\nFENME    BXLE  R4,R2,*+L'*+4\n         B     ENME\n         CLI   0(R4),C' '\n         BNE   FENME\nENME     LR    R5,R4\n         SR    R5,R1\n         BNP   ERR5\n         CH    R5,=H'8'\n         BH    ERR5\n         BCTR  R5,0\n         MVC   TCMD,=CL8' '\n         EX    R5,MVCMD\n         TM    XSWX,XFORE\n         BO    SFORE\n         L     R1,=A(TCMDB)        SCAN RESERVED COMMAND (BACKGROUND)\n         B     LSCT\nSFORE    L     R1,=A(TCMDF)        SCAN RESERVED COMMAND (FOREGROUND)\nLSCT     CLI   0(R1),X'FF'         END OF TABLE?\n         BE    TXEQ                YES\n         CLC   TCMD(L'TCMD),0(R1)  MATCH?\n         BE    ERR6                YES, REJECT IT\n         LA    R1,L'TCMDB(R1)      BUMP TO NEXT\n         B     LSCT\n         EJECT\n*        TSO ENVIRONMENT CONTROL.\n         SPACE 1\n         USING PSA,R0\nTXEQ     L     R2,PSATOLD          CURRENT TCB ADDRESS\n         DROP  R0\n         XR    R4,R4\n         USING TCB,R2\nTSCT     L     R3,TCBRBP           CURRENT RB ADDRESS\n         LTR   R3,R3\n         BZ    NXTTCB\n         USING RBBASIC,R3\n         ICM   R4,B'0111',RBCDE1   CURRENT CDE ADDRESS\n         BZ    NXTTCB\n         USING CDENTRY,R4\n         CLC   CDNAME,=CL8'IKJEFT02'\n         BE    TFND\nNXTTCB   L     R2,TCBOTC           ORIGINATING TCB\n         LTR   R2,R2\n         BNZ   TSCT\n         B     ERR7\n         DROP  R3,R4\nTFND     L     R3,TCBGRS9          GET TMP WORK-AREA ADDRESS\n         DROP  R2\n         USING TPL,R3\n         L     R4,CPPLPTR\n         DROP  R3\n         USING CPPL,R4\n         L     R2,APSCB\n         USING PSCB,R2\n         CLC   PSCBUPT,CPPLUPT     UPT ADDRESSES MATCH?\n         BNE   ERR7                NO\n         CL    R2,CPPLPSCB         CPPL+8 = PSCB ADDRESS?\n         BNE   ERR7                NO\n         DROP  R2,R4\n         EJECT\n*        EXECUTE COMMAND/CLIST.\n         SPACE 1\n         TM    XSWX,ALLMSG         ALL MESSAGES REQUEST?\n         BZ    GOCMD               NO\n         L     R1,=A(DIAGA)\n         LA    R8,DIAGAS(R1)\n         MVI   0(R8),C' '\n         MVC   1(L'DIAGAS-1,R8),0(R8)\n         L     R14,LCMD            COMMAND LENGTH\n         CH    R14,DIAGAL\n         BNH   *+L'*+4\n         LH    R14,DIAGAL\n         BCT   R14,*+L'*+L'MVMSG\nMVMSG    MVC   0(*-*,R8),CMND      <<EXECUTED>>\n         EX    R14,MVMSG\n         CLC   L'DIAGAS-5(5,R8),=CL8' '\n         BE    *+L'*+6\n         MVC   L'DIAGAS-5(5,R8),=CL5' ... '\n         BAS   R8,SMSG\nGOCMD    L     R2,CVTPTR           CVT ADDRESS\n         USING CVT,R2\n         L     R1,CVTTVT           TSO VECTOR TABLE\n         DROP  R2\n         USING TSVT,R1\n         L     R15,TSVTASF         TSO SERVICE ROUTINE\n         DROP  R1\n        CALL   (15),(FLAGS,CMND,LCMD,RETCODE,RSNCODE,ABNDCODE),VL\n         LTR   R15,R15             ANY COMPLETION CODE?\n         BZ    DONE                NO\n         CH    R15,=H'4'           FUNCTION RETURN CODE?\n         BNE   ERRCC               NO\n         STC   R15,XCC             SET COMPLETION CODE\n         LA    R15,X'FFF'\n         L     R1,RETCODE\n         NR    R1,R15\n         STCM  R1,B'0011',XCC+2    SET FUNCTION RETURN CODE\n         TM    XSWX,NOMSG          DISPLAY RC REQUESTED?\n         BO    DONE                NO\n         L     R1,=A(DIAGB)\n         UNPK  DIAGBR(L'DIAGBR+1,R1),RETCODE(L'RETCODE+1)\n         TR    DIAGBR(L'DIAGBR,R1),TRTAB-C'0'\n         MVI   DIAGBR+L'DIAGBR(R1),C'.'\n         BAS   R8,SMSG\n         B     DONE\nERRCC    ST    R15,WORK\n         STC   R15,XCC             SET COMPLETION CODE\n         LA    R15,X'FFF'\n         L     R1,RSNCODE\n         NR    R1,R15\n         CLC   ABNDCODE,=F'-1'\n         BE    *+L'*+12\n         L     R0,ABNDCODE\n         NR    R0,R15\n         SLL   R0,12\n         OR    R1,R0\n         STCM  R1,B'0111',XCC+1    SET ABEND AND REASON CODES\n         TM    XSWX,NOMSG          DISPLAY RC REQUESTED?\n         BO    DONE                NO\n         L     R1,=A(DIAGC)\n         UNPK  DIAGCR(L'DIAGCR+1,R1),WORK(5)\n         TR    DIAGCR(L'DIAGCR,R1),TRTAB-C'0'\n         MVI   DIAGCR+L'DIAGCR(R1),C','\n         UNPK  DIAGCS(L'DIAGCS+1,R1),RSNCODE(L'RSNCODE+1)\n         TR    DIAGCS(L'DIAGCS,R1),TRTAB-C'0'\n         MVI   DIAGCS+L'DIAGCS(R1),C','\n         UNPK  DIAGCA(L'DIAGCA+1,R1),ABNDCODE(L'ABNDCODE+1)\n         TR    DIAGCA(L'DIAGCA,R1),TRTAB-C'0'\n         MVI   DIAGCA+L'DIAGCA(R1),C'.'\n         BAS   R8,SMSG\nDONE     ICM   R1,B'1111',ACCC\n         BZ    *+L'*+6\n         MVC   0(4,R1),XCC\n         OC    XCC,XCC             ANY FINAL COMPLETION CODE?\n         BNZ   CMXC                YES\n         XR    R10,R10             ALL OK\n         B     LEAVE\nCMXC     L     R1,=A(DIAG1)\n         XR    R0,R0               SET COMPLETION CODE\n         IC    R0,XCC\n         CVD   R0,WORK\n         UNPK  DIAG1C(L'DIAG1C,R1),WORK+6(2)\n         OI    DIAG1C+L'DIAG1C-1(R1),C'0'\n         MVC   WORK+5(3),XCC+1\n         UNPK  WORK(5),WORK+5(3)   SET SYSTEM CODE\n         TR    WORK(3),TRTAB-C'0'\n         MVC   DIAG1S(L'DIAG1S,R1),WORK\n         NI    WORK+6,X'0F'        SET USER CODE\n         LH    R0,WORK+6\n         CVD   R0,WORK\n         UNPK  DIAG1U(L'DIAG1U,R1),WORK+5(3)\n         OI    DIAG1U+L'DIAG1U-1(R1),C'0'\nERR1     BCTR  R10,0          COMMAND FAILED\nERR2     BCTR  R10,0          INVALID COMMAND TEXT LENGTH\nERR3     BCTR  R10,0          ARGUMENT ALIGNMENT ERROR\nERR4     BCTR  R10,0          MISSING COMMAND\nERR5     BCTR  R10,0          INVALID COMMAND\nERR6     BCTR  R10,0          COMMAND REJECTED (UNSUPPORTED)\nERR7     BCTR  R10,0          UNABLE TO LOCATE CPPL\nERR8     BCTR  R10,0          NOT TSO ENVIRONMENT\nMAXERR   EQU   ((*-ERR1)/2)+1\n         TM    XSWX,NOMSG\n         BO    LEAVE\n         LR    R1,R10\n         BCTR  R1,0\n         SLL   R1,2\n         AL    R1,=A(TABD)\n         L     R1,0(R1)\n         BAS   R8,SMSG\n         EJECT\n*        END OF PROCESSING.\n         SPACE 1\nLEAVE    L     R1,4(R13)\n         MVC   20(4,R1),XCC        SET R0\n         L     R1,ACRC\n         LTR   R1,R1\n         BZ    *+L'*+4\n         ST    R10,0(R1)\n        $XRET  CC=(R10)\n         EJECT\n*        SEND MESSAGES ROUTINE.\n*              R1 : WTO MESSAGE ADDRESS.\n*              R8 : LINK REGISTER.\n         SPACE 1\nSMSG     TM    XSWX,XFORE\n         BO    STSO\n        WTO    MF=(E,(1))\n         BR    R8\nSTSO     LH    R0,0(R1)\n         SH    R0,=H'4'\n         LA    R1,4(R1)\n        TPUT   (1),(0)\n         BR    R8\n         SPACE 2\nSNCMD    MVC   CMND(*-*),0(R4)     << EXECUTED >>\nMVCMD    MVC   TCMD(*-*),0(R1)     << EXECUTED >>\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n         SPACE 1\nWORK     DC    D'0'\nATSO     DC    A(*-*) -------/\nAPSCB    DC    A(*-*)        /---> MAINTAIN FIELDS ORDER\nACCC     DC    A(*-*) -------/\nACRC     DC    A(*-*)        /---> MAINTAIN FIELDS ORDER\nXCC      DC    F'0'                FINAL COMPLETION CODES\nRETCODE  DC    F'0'                RETURN CODE FROM COMMAND\nRSNCODE  DC    F'0'                REASON CODE\nABNDCODE DC    F'0'                ABEND CODE\nFLAGS    DS    0F -----------/     FIRST PARM TO IKJEFTSR\n         DC    H'0'          /     FLAG WORD\n         DC    XL1'0'        /     NO DUMP IF ABEND OCCURS\n         DC    XL1'05'       /     TELL TSR TO EXECUTE COMMAND/CLIST\n*                            /---> MAINTAIN FIELDS ORDER\n         SPACE 1\nLCMD     DC    F'0'                COMMAND LENGTH\nCMND     DC    CL240' '            COMMAND BUFFER\n         SPACE 1\nTCMD     DC    CL8' '              TEST COMMAND/CLIST NAME\nTRTAB    DC    CL16'0123456789ABCDEF'\n         SPACE 1\nDIAGAL   DC    0H'0',AL2(L'DIAGAS)\nXSWX     DC    X'0'                PROCESSING SWITCHES\nXFORE    EQU   X'80'               FOREGROUND REGION\nNOMSG    EQU   X'40'               NO MESSAGES REQUEST\nALLMSG   EQU   X'20'               ALL MESSAGES REQUEST\n         SPACE 2\n        LTORG\n         SPACE 2\n*- - - - END OF BASE REGISTER ADDRESSING - - - - - - - - - - - - - - -*\n         EJECT\n*        ERROR MESSAGES.\n         SPACE 1\nTABD     DC    A(DIAG1,DIAG2,DIAG3,DIAG4,DIAG5,DIAG6,DIAG7,DIAG8)\n         SPACE 1\n        PRINT  NOGEN\nDIAGA   WTO    '   ---> COMMAND :                                      X\n                                      ',ROUTCDE=11,DESC=7,MF=L\nDIAGAS  EQU    22,60               START OF COMMAND TEXT\nDIAGB   WTO    'XTC - COMMAND RETURN CODE :         .',                X\n               ROUTCDE=11,DESC=7,MF=L\nDIAGBR  EQU    32,8                FUNCTION RETURN CODE\nDIAGC   WTO    'XTC - IKJEFTSR FAILED : R15=        , R.CC=        , A.X\n               CC=        .',ROUTCDE=11,DESC=7,MF=L\nDIAGCR  EQU    32,8                R15 CODE\nDIAGCS  EQU    47,8                REASON CODE\nDIAGCA  EQU    62,8                ABEND CODE\n         SPACE 1\nDIAG1   WTO    'XTC - ERR=1 : COMMAND(S) FAILED    (S   /U    ).',     X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG1C  EQU    36,2                COMPLETION CODE\nDIAG1S  EQU    41,3                SYSTEM CODE\nDIAG1U  EQU    46,4                USER (REASON OR FUNCTION) CODE\nDIAG2   WTO    'XTC - ERR=2 : INVALID COMMAND TEXT LENGTH.',           X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG3   WTO    'XTC - ERR=3 : ARGUMENT ALIGNMENT ERROR.',              X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG4   WTO    'XTC - ERR=4 : MISSING COMMAND.',                       X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG5   WTO    'XTC - ERR=5 : INVALID COMMAND.',                       X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG6   WTO    'XTC - ERR=6 : COMMAND REJECTED (UNSUPPORTED).',        X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG7   WTO    'XTC - ERR=7 : UNABLE TO LOCATE CPPL.',                 X\n               ROUTCDE=11,DESC=7,MF=L\nDIAG8   WTO    'XTC - ERR=8 : NOT TSO ENVIRONMENT.',                   X\n               ROUTCDE=11,DESC=7,MF=L\n        PRINT  GEN\n         EJECT\n*        THE FOLLOWING TABLES MUST BE IN ALPHABETIC ORDER.\n         SPACE 1\nTCMDB    DS    0CL8           RESERVED COMMANDS TABLE (BACKGROUND)\n         DC    CL8'ACCOUNT'\n         DC    CL8'AUTHC'\n         DC    CL8'CDSCB'\n         DC    CL8'CJSD'\n         DC    CL8'DIDOCS'\n         DC    CL8'ISPF'\n         DC    CL8'LISTENQ'\n         DC    CL8'OPER'\n         DC    CL8'PDF'            ALIAS OF ISPF\n         DC    CL8'PDFINIT'\n         DC    CL8'POF'\n         DC    CL8'PSWR'\n         DC    CL8'PUSE'\n         DC    CL8'QSP'\n         DC    CL8'RGROUP'\n         DC    CL8'RSVENQ'\n         DC    CL8'SCHED'\n         DC    CL8'SCHEDULE'\n         DC    CL8'TEST'\n         DC    CL8'TIME'\n         DC    CL8'TSODSN'\n         DC    CL8'TSOENQ'\n         DC    CL8'UJVD'\n         DC    CL8'UNIT'\n         DC    CL8'UNITS'\n         DC    CL8'VCOREZAP'\n         DC    CL8'VSM'\n         DC    CL8'WAITR'\n         DC    CL8'ZAP'\n         DC    XL1'FF'             END OF TABLE INDICATOR\n         SPACE 1\nTCMDF    DS    0CL8           RESERVED COMMANDS TABLE (FOREGROUND)\n         DC    CL8'ACCOUNT'\n         DC    CL8'AUTHC'\n         DC    CL8'CDSCB'\n         DC    CL8'OPER'\n         DC    CL8'POF'\n         DC    CL8'PSWR'\n         DC    CL8'PUSE'\n         DC    CL8'QSP'\n         DC    CL8'TEST'\n         DC    CL8'TIME'\n         DC    CL8'UNIT'\n         DC    CL8'UNITS'\n         DC    CL8'VCOREZAP'\n         DC    CL8'VSM'\n         DC    CL8'ZAP'\n         DC    XL1'FF'             END OF TABLE INDICATOR\n         EJECT\n        PRINT  NOGEN\n        CVT    DSECT=YES,LIST=YES\n        IHAPSA\n        IHARB\n        IHACDE\n        IKJCPPL\n        IKJPSCB\n        IKJTCB\n        IKJTMPWA\n        IKJTSVT\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ZEROKEY": {"ttr": 39688, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16(\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:28:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO           AUTHORIZATION ON - SUPERVISOR MODE.\n&NAME    ZEROKEY    &DUMMY\n.*\n.* AUTHOR :    P.A. MOINIL\n.* --------    COMPUTING CENTRE\n.*             J.R.C. - ISPRA ESTABLISHMENT\n.*             21020 ISPRA (VA), ITALY\n.*\n&NAME   SETAUTH ,                  SET AUTHORIZATION ON.\n        MODESET KEY=ZERO,MODE=SUP  ENTER SUPERVISOR MODE.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ZOOM": {"ttr": 39690, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x9f\\x00\\x94)\\x9f\\t!\\x00[\\x00[\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-26T00:00:00", "modifydate": "1994-10-26T09:21:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "SYSPAJA"}, "text": "ISREDIT  MACRO (APARM)\n/*  MACRO NAME : ZOOM                                               */\n/*    FUNCTION : BROWSE JCL PROCEDURE FEATURED ON A JCL STATEMENT   */\n/*      SYNTAX : ZOOM                                               */\n/*               ZOOM HELP OR H                                     */\n/*       DEBUG : ZOOM LIST                                          */\n/*      ORIGIN : EXTRACTED FROM CBT 94 AUG TAPE, FILE 244           */\n/*               ADAPTED BY MOINIL P.A.                             */\n/* ---------------------------------------------------------------- */\n/* Title :       ZOOM                                               */\n/* Author :      Rob Mellor, Systems Programming Group, LOLA        */\n/* Date :        12th October 1989                                  */\n/* Function :    By placing the cursor on a JCL card containing an  */\n/*               EXEC statement, and issueing the ZOOM command,     */\n/*               this edit macro will 'zoom in' on (ie. display in  */\n/*               browse) the JCL PROC featured on the statement.    */\n/*               This command is most useful when defined to a PF   */\n/*               key, thus leaving the cursor free to move to the   */\n/*               line containing the EXEC statement.                */\n/* ---------------------------------------------------------------- */\n/* Notes :       You must customise this macro to reflect the       */\n/*               PROCLIBs used at your shop (set PROC1, PROC2, ...  */\n/*               to PROCLIBs data-sets names). These should be      */\n/*               obtained from your installation's JES2 procedure   */\n/*               (make sure you use the right concatenation if      */\n/*               more than one exists).                             */\n/*               Then, set MAXNUM to the total number of PROCLIBs.  */\n/* ---------------------------------------------------------------- */\n  ISPEXEC CONTROL ERRORS RETURN\n  IF &STR(&APARM.) = &STR(HELP) OR +\n    &STR(&APARM.) = &STR(H) THEN DO\n      ISPEXEC CONTROL DISPLAY SAVE\n      ISPEXEC SELECT PGM(ISPTUTOR) PARM(PAJTZOOM)\n      SET ZMCC = &LASTCC\n      ISPEXEC CONTROL DISPLAY RESTORE\n      EXIT CODE(&ZMCC)\n      END\n  ELSE IF &STR(&APARM.) = &STR(LIST) THEN CONTROL LIST CONLIST SYMLIST\n  ELSE IF &STR(&APARM.) \u00ac= &Z THEN DO\n    SET ZEDSMSG = &STR(INVALID OPERAND)\n    SET ZEDLMSG = &STR(ONLY HELP OR H IS ACCEPTED AS OPERAND)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(12)\n    END\n  ELSE CONTROL NOPROMPT NOMSG\n  ISPEXEC CONTROL DISPLAY REFRESH\n  ISREDIT (SYSDVAL) = LINE .ZCSR\n  READDVAL DUMMY FUNCTION MEMBER\n  IF &STR(&FUNCTION) = EXEC THEN DO\n    IF &LENGTH(&STR(&MEMBER)) >= 4 THEN DO\n      IF &SUBSTR(1:4,&STR(&MEMBER)) = &STR(PGM=) THEN DO\n        SET ZEDSMSG = &STR(ERROR)\n        SET ZEDLMSG = &STR(CLIST &SYSICMD ONLY WORKS ON EXEC +\n                       PROCEDURE)\n        ISPEXEC SETMSG MSG(ISRZ001)\n        EXIT CODE(12)\n        END\n      END\n    END\n  ELSE DO\n    SET ZEDSMSG = &STR(INVALID)\n    SET ZEDLMSG = &STR(CLIST &SYSICMD ONLY WORKS ON JCL EXEC +\n                   CARD TYPE)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n    END\n  SET PROC1  = SYS1.PROCLIB\n  SET PROC2  = EUR1.STC.PROCLIB\n  SET PROC3  = EUR1.PROCLIB\n  SET PROC4  = SYSDMS.EURSTC.PROCLIB\n  SET PROC5  = SYSDMS.EUR.PROCLIB\n  SET PROC6  = EUR1.USER.PROCLIB\n  SET MAXNUM = 6\n  SET PROC = &&PROC\n  SET FOUND = NO\n  DO &I = 1 TO &MAXNUM UNTIL &FOUND = YES\n    IF &SYSDSN('&STR(&PROC&I)(&MEMBER)') = OK THEN SET FOUND = YES\n  END\n  IF &FOUND = YES THEN DO\n    SET DSN = &STR(&PROC&I(&MEMBER))\n    ISPEXEC BROWSE DATASET('&DSN')\n    SET ZMCC = &LASTCC\n    END\n  ELSE DO\n    SET ZEDSMSG = &STR(NOT FOUND)\n    SET ZEDLMSG = &STR(MEMBER &MEMBER COULD NOT BE FOUND IN ANY +\n                    JCL PROCEDURE LIBRARY)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    SET ZMCC = 12\n    END\n  EXIT CODE(&ZMCC)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZOOM@": {"ttr": 39693, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)\\x9f\\x00\\x94)\\x9f\\t@\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-26T00:00:00", "modifydate": "1994-10-26T09:40:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "1   26/10/94\n                                                      ZOOM      1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *     ZOOM ISPF/PDF EDIT command      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Function :   By placing the cursor on a JCL card containing an EXEC\n  ----------   statement, and issueing the ZOOM command, this Edit\n               macro will \"zoom in\" on (display in browse) the JCL\n               PROC featured on the statement.\n\n  Command syntax : ZOOM\n  ---------------- ZOOM HELP or H\n\n  Note :        This command is most useful when defined to a PF key,\n  ------        thus leaving the cursor free to move to the line\n                containing the EXEC statement.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT454/FILE454.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT454", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}