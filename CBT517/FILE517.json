{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012242000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1587222, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE517.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1587222, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1587222, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE517.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x19\\r'", "DS1TRBAL": "b'\\x04\\xc8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xdc\\x00\\x04\\x03\\xdd\\x00\\x0e\\x00\\x1a'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$NOTE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x01\\x13o\\x01\\x01\\x13o\\tT\\x00'\\x00'\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-16T00:00:00", "modifydate": "2001-05-16T09:54:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "WSBG"}, "text": "Golob, Sam\nFrom:   Peter Flass <peter_flass@yahoo.com>\nSent:   Tuesday, May 15, 2001 6:47 PM\nTo:     Golob, Sam\nSubject:        RE: CBT Tape contribution\n\nHi,\n  I got your questions,  I'll try to answer them.\nSorry this was so much work for you.\n\nXPL is a standalone system - a self-compiling\ncompiler. It doesn't need PL/I, and that's why the\nsource uses all 80 columns of the cards.\n\nWhat I sent you is how I packaged it for my XPL web\nsite.  The file \"README.TXT\" is my (ASCII) explanation\nof what's there.  \"PROSE.TXT\" is an ASCII version of\n\"PROSE\", the original documentation file.  The rest\nare the original files from the SHARE distribution, or\nclose to it.  The only difference is that the tape\ncontained IEBCOPY unloaded files and I've just got\nsequential files.  I didn't want to use IEBCOPY\nbecause I'd need HLQ's on my MVS system that weren't\nthere in the originals.\n\nMy packaging assumed that the file would be downloaded\nby a browser, unpacked on a PC, and then uploaded to a\nmainframe.  The EBCDIC files should be uploaded as FB\n80 (any blksize).  The binary files should be uploaded\nas F 3600.  The user has to assemble the \"submonitor\",\nand then use it to load and run the binaries.  All the\nJCL is in PROSE.  Naturally it needed to be modified,\nbut I don't think the modifications I had to make for\nmy system would improve any on what's there.\n\nI'll have a look tomorrow at what you've got.  Thanks\nfor the good work.  I'll see if I can do anything else\nto help.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$#DATE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13\\x8f\\x01\\x01\\x13\\x8f\\x143\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-18T00:00:00", "modifydate": "2001-05-18T14:33:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 435    FILE:  517\n\n    ORIGINAL DSNAME:  WSBG.CBT435.FILE517\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   17 MEMBERS COUNTED; CUMULATIVE SIZE IS 14,763 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   05/18/01    14:33:18    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x12)\\x00_\\x00_\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T12:29:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "WSBG"}, "text": "\"Best viewed with a fixed-pitch font\"\n\n                                       7 May 2001\n\nThis archive is an exercise in computer archeology.\n\nTo date no complete, readable, unmodified XPL distribution\nhas been recovered.  This is, I hope, a reasonable facsimile\nbased on data saved by various individuals over the years.\n\n\nFILE DESCRIPTIONS:\n\nFile Name             Original Description\n                      File Num\n 1.  README.TXT          -     This file\n 2.  PROSE.TXT           -     Ascii version of the original documentation\n 3.  PROSE               1     EBCDIC Documentation\n 4.  XMON.SOURCE         2     Assembler source for the XPL \"submonitor\"\n                               (runtime package)\n 5.  TRACE.SOURCE        3     Assembler source for the trace routine\n 6.  REFORM.SOURCE       4     Assembler source of utility to move\n                               XPL binaries\n 7.  XCOM.SOURCE         5     XPL Source for XCOM compiler\n 8.  XCOM.COMPILER       6     XCOM compiler binary\n -   XCOM.SMALL.COMPILER 7     XCOM compiler binary for small-memory\n                               systems \"not included, PROSE has instructions\n                               on how to create this file\"\n 9.  ANALYZER.SOURCE     8     XPL Source for syntax analyzer\n10.  SYNTAX.ANALYZER     9     Syntax analyzer binary\n11.  SKELETON.SOURCE    10     XPL source for skeleton \"proto-compiler\"\n12.  ALTER.SOURCE       11     XPL source for source update program\n13.  ALTER.PROGRAM      12     Binary for source update program\n14.  XPL.LIBRARY        13     XPL source for string package\n15.  XPL.BNF            14     BNF for the XPL language in format\n                               suitable for use by ANALYZER.\n\nFiles 1 and 2 should not be uploaded, or can be uploaded as text.\nOther files should be uploaded as binary with fixed-length records;\nfiles 8, 10, and 13 (binaries) have LRECL of 3600; other files\nhave LRECL of 80.\n\n\nRECORD SIZES:\n\nThe XPL system requires fixed record sizes for direct-access files.\nFor efficient disk use, these sizes should be the largest multiple\nof 80 that is less than or equal to the track size of the device and\nless than or equal to 32720.  If all binaries are reformatted use\nhalf-track blocking for larger track sizes.\n\nThe distributed system is generated for 2311 disks and uses a record\nlength of 3600.  Changing this number requires the following steps:\n  1. Change the constant 'DISKBYTES' in XCOM and re-compile it.\n  2. Using 'REFORMAT', change the record size of the generated\n     binary to the new value.\n  3. Change the constant 'FILEBYTS' in XMON and re-assemble.\n  4. Reformat or recompile all auxiliary programs with the new length.\n\nThe following are suggested lengths for various DASD devices:\n  Device  LRECL\n    2311 -  3600\n    2314 -  7200\n    3330 - 12960\n    3340 -  8320\n    3350 - 19040\n    3375 - 32720\n    3380 - 23680 \"half-track\" or 32720\n    3390 - 28320 \"half-track\" or 32720\n    9345 - 23200 \"half-track\" of 32720\n\nLarger LRECLs will require larger region sizes.\n\nI have not tested any of these except 3600 and 7200.\n\n\nTHANKS:\n\nThanks to a lot of people who have contributed to this reconstruction,\nin particular to:\n  Lanny R Andersson     <100117.1240@compuserve.com>\n  William M. McKeeman   <mckeeman@mathworks.com>\n  Ronald Tatum          <rhtatum@door.net>\n  Mark S. Waterbury     <mark_s_waterbury@yahoo.com>\n  Heinz W. Wiggeshoff   <ab528@freenet.carleton.ca>\n  David B. Wortman      <dw@pdp1.sys.toronto.edu>\n\n\nCOPYRIGHT:\n\nTo the best of my knowledge this material is now in the public domain.\n\n\n                                       Peter Flass <Peter_Flass@Yahoo.com>\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE517": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x01\\x01\\x02_\\x01\\x01\\x13\\x8f\\x14)\\x00\"\\x00\\x02\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2001-05-18T14:29:00", "lines": 34, "newlines": 2, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 517 is from Peter Flass and contains XPL, which is a      *   FILE 517\n//*           compiler generator system that was developed in the   *   FILE 517\n//*           late 60s.  Most of the source is in its own language, *   FILE 517\n//*           which looks like PL/I.  There is an assembler driver  *   FILE 517\n//*           system, that allows installation of the rest of the   *   FILE 517\n//*           code.                                                 *   FILE 517\n//*                                                                 *   FILE 517\n//*          This file contains the XPL Compiler Generator          *   FILE 517\n//*      System developed at the Stanford Computation Center,       *   FILE 517\n//*      campus facility, and the University of California          *   FILE 517\n//*      Computation Center, Santa Cruz.                            *   FILE 517\n//*                                                                 *   FILE 517\n//*          email:  peter_flass@yahoo.com                          *   FILE 517\n//*                                                                 *   FILE 517\n//*      Peter runs an XPL web site.  Its address is:               *   FILE 517\n//*                                                                 *   FILE 517\n//*          http://www.geocities.com/xpl_lang                      *   FILE 517\n//*                                                                 *   FILE 517\n//*   Some further remarks from Peter:                              *   FILE 517\n//*                                                                 *   FILE 517\n//*      XPL is a standalone system - a self-compiling compiler.    *   FILE 517\n//*      It doesn't need PL/I, and that's why the source uses       *   FILE 517\n//*      all 80 columns of the cards.                               *   FILE 517\n//*                                                                 *   FILE 517\n//*      My packaging assumed that the file would be downloaded     *   FILE 517\n//*      by a browser, unpacked on a PC, and then uploaded to a     *   FILE 517\n//*      mainframe.  The EBCDIC files should be uploaded as FB      *   FILE 517\n//*      80 (any blksize).  The binary files should be uploaded     *   FILE 517\n//*      as F 3600.  The user has to assemble the \"submonitor\",     *   FILE 517\n//*      and then use it to load and run the binaries.  All the     *   FILE 517\n//*      JCL is in PROSE.  Naturally it needed to be modified,      *   FILE 517\n//*      but I don't think the modifications I had to make for      *   FILE 517\n//*      my system would improve any on what's there.               *   FILE 517\n//*                                                                 *   FILE 517\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALTER": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x11Y\\x01=\\x01=\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T11:59:00", "lines": 317, "newlines": 317, "modlines": 0, "user": "SOURCE"}, "text": "\n /*\n\n                             A L T E R    P R O G R A M\n\n\n                                                 DAVID B. WORTMAN\n                                                 STANFORD UNIVERSITY\n                                                 JANUARY  1969\n\n */\n\n\n /*      THIS PROGRAM ALTERS A CARD-IMAGE TAPE OR DISK FILE ONTO AN OUTPUT\n     FILE UNDER CONTROL OF A SMALL ALTER DECK.  IT CAN ALSO BE USED TO COPY\n     ONE FILE TO ANOTHER OR TO COPY A CARD DECK TO DISK OR TAPE.\n\n         THE PROGRAM REQUIRES THREE FILES, AN ALTER FILE, A SOURCE FILE,\n     AND AN OUTPUT FILE.  THE ALTER FILE CONTAINS CONTROL CARDS INDICATING\n     THE LOCATION OF CHANGES TO BE MADE, AND ANY CARDS WHICH ARE TO BE\n     ADDED TO THE SOURCE FILE.  THE SOURCE FILE IS THE PROGRAM TO BE\n     UPDATED.  IT MAY BE OMITTED IF A NEW FILE IS BEING MADE FROM CARDS.\n\n         THE CHOICE OF DEVICE (TAPE, DISKS, OR CARDS) FOR SOURCE AND\n     OUTPUT FILES IS DETERMINED BY JOB CONTROL CARDS.  THE ALTER FILE\n     HAS THE DDNAME SYSIN, THE SOURCE FILE HAS THE DDNAME INPUT3, AND\n     THE OUTPUT FILE HAS THE DDNAME OUTPUT3.  SEE THE PROSE FILE ON\n     THE DISTRIBUTION TAPE FOR EXAMPLES OF APPROPRIATE JCL.\n\n         THE ALTER DECK CONTAINS CONTROL CARDS AND CARDS TO BE ADDED TO\n     THE SOURCE DECK.  IF A CARD IN THE ALTER FILE CONTAINS $$ IN COLUMNS\n     1 AND 2 THEN IT IS TAKEN TO BE A CONTROL CARD.  OTHERWISE IT IS ADDED\n     TO THE SOURCE DECK.  THERE ARE THREE TYPES OF CONTROL CARDS:\n\n               $$ L\n\n               $$ EOF\n\n               $$ <CARD SPECIFICATIONS>\n\n     WHERE <CARD SPECIFICATIONS> WILL BE DESCRIBED SHORTLY.  EACH OF THE\n     THREE TYPES OF CONTROL INFORMATION MAY APPEAR ANYWHERE AFTER\n     COLUMN 2, BUT ONLY ONE TYPE TO A CARD.\n\n         $$ L  INVERTS THE VALUE OF A LOGICAL VARIABLE WHICH DETERMINES\n     WHETHER OR NOT THE OUTPUT FILE WILL BE LISTED ON THE PRINTER.  IF THE\n     VARIABLE HAS THE VALUE FALSE THEN ONLY CHANGES (ADDITIONS AND DELETIONS)\n     AND CONTROL CARDS WILL BE LISTED.  IF IT HAS THE VALUE TRUE THEN THE\n     ENTIRE OUTPUT FILE WILL BE LISTED.  THE VARIABLE IS INITIALLY SET TO\n     THE VALUE FALSE.\n\n         $$ EOF  SIGNIFIES THE END OF THE ALTER INPUT.  THE OUTPUT FILE\n     IS TERMINATED AT THE POINT WHICH WAS REACHED WHEN THE $$ EOF CARD WAS\n     DETECTED.  NO FURTHER CARDS ARE READ FROM THE ALTER INPUT FILE OR\n     FROM THE SOURCE FILE (SYSIN AND INPUT3).  THIS CARD IS CONVENIENT\n     WHEN CREATING A NEW SOURCE FILE, ALTHOUGH SPECIFYING INPUT3 TO BE\n     A DUMMY FILE  (//INPUT3 DD DUMMY) WILL HAVE THE SAME EFFECT.\n\n         THE THIRD TYPE OF CONTROL CARD HAS THREE SUB-TYPES.\n\n     <CARD SPECIFICATIONS>  ::=  <UNSIGNED INTEGER>\n                              |  <UNSIGNED INTEGER>  ,\n                              |  <UNSIGNED INTEGER>  ,  <UNSIGNED INTEGER>\n\n     THE <CARD SPECIFICATIONS> IS TERMINATED BY A BLANK.  THE EFFECTS OF\n     THE THREE TYPES OF CARD SPECIFICATION ARE:\n\n     <UNSIGNED INTEGER>\n         THE SOURCE FILE IS COPIED TO THE OUTPUT FILE UP TO AND INCLUDING\n         THE CARD SPECIFIED BY THE INTEGER.  THEN ANY NON-CONTROL CARDS\n         IN THE ALTER DECK UP TO THE NEXT CONTROL CARD ARE ADDED TO THE\n         OUTPUT FILE.\n\n     <UNSIGNED INTEGER>  ,\n         THE SOURCE FILE IS COPIED TO THE OUTPUT FILE UP TO BUT NOT\n         INCLUDING THE CARD SPECIFIED BY THE INTEGER.  THEN ANY CARDS IN THE\n         ALTER DECK UP TO THE NEXT CONTROL CARD ARE ADDED TO THE OUTPUT\n         FILE.  THE CARD SPECIFIED BY THE INTEGER IS DELETED.\n\n     <UNSIGNED INTEGER>  ,  <UNSIGNED INTEGER>\n         THE SOURCE FILE IS COPIED TO THE OUTPUT FILE UP TO BUT NOT INCLUDING\n         THE CARD SPECIFIED BY THE FIRST INTEGER.  THE CARDS IN THE SOURCE\n         FILE IN THE RANGE INDICATED BY THE PAIR OF INTEGERS INCLUSIVE\n         ARE DELETED.  ANY CARDS IN THE ALTER DECK UP TO THE NEXT CONTROL\n         CARD ARE COPIED TO THE OUTPUT FILE.\n\n         ALTERATIONS MUST BE MADE IN NUMERICALLY ASCENDING SEQUENCE.  ANY\n     REFERENCE TO A LINE WHICH HAS ALREADY BEEN READ FROM THE SOURCE FILE WILL\n     CAUSE AN ERROR MESSAGE.\n\n         THE <CARD SPECIFICATIONS> MAY BE OPTIONALLY FOLLOWED BY A CHARACTER\n     STRING.  THIS STRING IS USED TO CHECK THE LINE NUMBER INDICATED IN THE\n     CARD SPECIFICATION AGAINST THE ACTUAL CARD IN THE SOURCE FILE.\n     THE FIRST NON-BLANK CHARACTER OF THE ALTER CARD IS MATCHED WITH THE\n     FIRST NON-BLANK CHARACTER OF THE LAST NON-DELETED CARD FROM THE SOURCE\n     FILE.  A CHARACTER BY CHARACTER COMPARISON IS DONE THROUGH THE LAST\n     NON-BLANK CHARACTER ON THE ALTER CONTROL CARD.  IF ANY MISMATCH IS\n     FOUND AND ERROR MESSAGE IS GIVEN AND THE INDICATED ALTERATION\n     IS NOT PERFORMED.  THE ALTER DESK IS SEARCHED FOR THE NEXT CONTROL CARD.\n\n         NUMBERING OF THE SOURCE FILE STARTS FROM ONE WITH A CONSTANT\n     INCREMENT OF ONE.  IF THE FIRST CARDS IN THE ALTER CONTROL DECK ARE NOT\n     ALTER CONTROL CARDS THEN THEY WILL BE INSERTED BEFORE THE FIRST CARD OF\n     THE SOURCE FILE.\n\n         TO COPY A FILE (OR PUNCH A FILE, ETC.) THE ALTER DECK SHOULD BE NULL.\n     FOR EXAMPLE,  //SYSIN  DD  DUMMY  COUND BE USED.\n\n */\n\n\n\nDECLARE TRUE LITERALLY '1', FALSE LITERALLY '0' ;\n   /* DEFINE FILES USED BY THE ALTER PROGRAM  */\nDECLARE IN_FILE LITERALLY '3',         /* SOURCE INPUT  */\n   OUT_FILE LITERALLY '3',             /* SOURCE OUTPUT  */\n   CONTROL_FILE LITERALLY '0',         /* SOURCE OF CONTROL CARDS  */\n   PRINT_FILE LITERALLY '0';           /* SINK FOR LISTING  */\n\nDECLARE CONTROL_DELIMITER CHARACTER INITIAL('$$'),\n   LIST_MARK CHARACTER INITIAL('L'),\n   EOF_MARK CHARACTER INITIAL('EOF'),\n   BLANKS CHARACTER INITIAL('      '),\n   STARS CHARACTER INITIAL('******');\n\nDECLARE (SEARCHING, COPYING, LISTING, FLUSHING) BIT (1),\n   (CONTROL_BUFFER, BUFFER) CHARACTER,\n   (LCB, CP, INPUT_COUNT, LCD, LLM, LEM, OUTPUT_COUNT, FIRST, LAST,\n    ERROR_COUNT, BP, LB)  FIXED;\n\n\nERROR:\n   PROCEDURE (MESSAGE) ;\n      DECLARE MESSAGE CHARACTER;\n\n      OUTPUT(PRINT_FILE) = '';\n      OUTPUT(PRINT_FILE) = '*** ERROR, ' || MESSAGE || '      ' || STARS ;\n      OUTPUT(PRINT_FILE) = '';\n      ERROR_COUNT = ERROR_COUNT + 1;\n      FLUSHING = TRUE ;\n   END  ERROR  ;\n\nCONTROL_CARD:\n   PROCEDURE ;\n      IF SEARCHING THEN\n         DO;\n            CONTROL_BUFFER = INPUT(CONTROL_FILE) ;\n            LCB = LENGTH(CONTROL_BUFFER) ;\n            SEARCHING = LCB \u00ac= 0 ;\n         END ;\n   END  CONTROL_CARD  ;\n\nDEBLANK:\n   PROCEDURE ;\n      DO WHILE (BYTE(CONTROL_BUFFER, CP) = BYTE(' ')) & (CP < LCB);\n         CP = CP + 1;\n      END;\n   END  DEBLANK  ;\n\nNUMBER:\n   PROCEDURE ;\n      DECLARE VALUE FIXED ;\n\n      VALUE = 0;\n      DO WHILE (BYTE(CONTROL_BUFFER, CP) >= BYTE('0')) & (CP < LCB) ;\n         VALUE = VALUE*10 + BYTE(CONTROL_BUFFER, CP) - BYTE('0') ;\n         CP = CP + 1;\n      END ;\n      RETURN VALUE ;\n   END  NUMBER ;\n\nADD:\n   PROCEDURE ;\n      OUTPUT_COUNT = OUTPUT_COUNT + 1;\n      OUTPUT(PRINT_FILE) = SUBSTR(BLANKS,LENGTH(OUTPUT_COUNT)) ||\n         OUTPUT_COUNT || ' |' || CONTROL_BUFFER || '| +++ ADDED';\n      OUTPUT(OUT_FILE) = CONTROL_BUFFER ;\n   END  ADD  ;\n\nDELETE:\n   PROCEDURE (LIMIT) ;\n      DECLARE LIMIT FIXED, I FIXED ;\n\n      IF \u00ac COPYING THEN RETURN ;\n      DO I = INPUT_COUNT+1 TO LIMIT ;\n         BUFFER = INPUT(IN_FILE) ;\n         IF LENGTH(BUFFER) = 0 THEN\n            DO;\n               CALL ERROR('RANGE OF DELETE EXTENDS BEYOND END OF SOURCE FILE');\n               SEARCHING,COPYING = FALSE ;\n               RETURN ;\n            END;\n         OUTPUT(PRINT_FILE) = BLANKS || ' |' || BUFFER || '| --- DELETED';\n      END;\n      INPUT_COUNT = LIMIT ;\n   END  DELETE  ;\n\nCOPY:\n   PROCEDURE (LIMIT) ;\n      DECLARE LIMIT FIXED, I FIXED ;\n\n      IF \u00acCOPYING THEN RETURN ;\n      DO I = INPUT_COUNT + 1 TO LIMIT ;\n         OUTPUT_COUNT = OUTPUT_COUNT + 1;\n         BUFFER = INPUT(IN_FILE);\n         IF LENGTH(BUFFER) = 0 THEN\n            DO;\n               SEARCHING, COPYING = FALSE ;\n               RETURN ;\n            END ;\n         IF LISTING THEN\n            OUTPUT(PRINT_FILE) = SUBSTR(BLANKS,LENGTH(OUTPUT_COUNT))\n               || OUTPUT_COUNT || ' |' || BUFFER;\n         OUTPUT(OUT_FILE) = BUFFER;\n      END;\n      INPUT_COUNT = LIMIT ;\n   END  COPY  ;\n\n\nSEARCHING,COPYING = TRUE ;\nFLUSHING, LISTING = FALSE ;\nINPUT_COUNT, OUTPUT_COUNT, ERROR_COUNT = 0;\nLCD = LENGTH(CONTROL_DELIMITER) ;\nLLM = LENGTH(LIST_MARK) ;\nLEM = LENGTH(EOF_MARK) ;\n\nCALL CONTROL_CARD ;\n\n\nDO WHILE SEARCHING ;\n   IF SUBSTR(CONTROL_BUFFER, 0, LCD) \u00ac= CONTROL_DELIMITER THEN\n      CALL ADD ;\n   ELSE\n      DO;\n         CP = LCD ;\n         OUTPUT(PRINT_FILE) = CONTROL_BUFFER ;\n         CALL DEBLANK ;\n         IF SUBSTR(CONTROL_BUFFER, CP, LLM) = LIST_MARK  THEN\n            LISTING = \u00acLISTING ;\n         ELSE IF SUBSTR(CONTROL_BUFFER, CP, LEM) = EOF_MARK THEN\n            SEARCHING, COPYING = FALSE ;\n         ELSE\n            DO;\n               FIRST = NUMBER ;\n               IF BYTE(CONTROL_BUFFER, CP) = BYTE(',')  THEN\n                  DO;\n                     FIRST = FIRST - 1;\n                     CP = CP + 1;\n                     LAST = NUMBER ;\n                     IF LAST = 0 THEN LAST = FIRST + 1;\n                  END ;\n               ELSE\n                  LAST = FIRST ;\n               IF FIRST > LAST THEN\n                  CALL ERROR('1ST ALTER CARD NUMBER > 2ND ALTER CARD NUMBER');\n               ELSE IF FIRST < INPUT_COUNT THEN\n                  CALL ERROR('INPUT CARD COUNT > 1ST ALTER CARD NUMBER');\n               ELSE\n                  DO;\n                     CALL COPY(FIRST) ;\n                     CALL DEBLANK ;\n                     BP = 0;\n                     LB = LENGTH(BUFFER) ;\n                     DO WHILE BYTE(BUFFER, BP) = BYTE(' ') ;\n                        BP = BP + 1;\n                     END ;\n                     DO WHILE (CP < LCB) & (BP < LB) ;\n                        IF BYTE(CONTROL_BUFFER, CP) = BYTE(BUFFER, BP) THEN\n                           DO;\n                              CP = CP + 1;\n                              BP = BP + 1;\n                           END;\n                        ELSE\n                           DO;\n                              CALL DEBLANK ;\n                              IF CP < LCB THEN\n                                 DO;\n                                    CALL ERROR(\n                                       'ALTER CARD DOES NOT MATCH SOURCE:  '\n                                       || BUFFER);\n                                    CP = LCB ;\n                                    LAST = FIRST; /* SUPPRESS DELETE  */\n                                 END;\n                           END;\n                     END ;\n                     CALL DELETE (LAST) ;\n                  END ;\n            END ;\n      END ;\n\n   CALL CONTROL_CARD ;\n   FLUSHING = FLUSHING & (SUBSTR(CONTROL_BUFFER, 0, LCD) \u00ac= CONTROL_DELIMITER) ;\n\n   DO WHILE FLUSHING & SEARCHING ;\n      OUTPUT(PRINT_FILE) = STARS || ' |' || CONTROL_BUFFER || '| *** IGNORED  '\n         || STARS ;\n      CALL CONTROL_CARD ;\n      FLUSHING = SUBSTR(CONTROL_BUFFER, 0, LCD) \u00ac= CONTROL_DELIMITER ;\n   END ;\n\nEND ;\n\nCALL COPY (\"7FFFFFFF\" );\n\nDO BP = 1 TO 6 ;\n   OUTPUT(PRINT_FILE) = '';\nEND;\nOUTPUT(PRINT_FILE) = 'END  OF  ALTER' ;\nIF ERROR_COUNT = 0 THEN\n   OUTPUT(PRINT_FILE) = 'NO ERRORS WERE DETECTED' ;\nELSE IF ERROR_COUNT = 1 THEN\n   OUTPUT(PRINT_FILE) = 'ONE ERROR WAS DETECTED' ;\nELSE\n   OUTPUT(PRINT_FILE) = ERROR_COUNT || ' ERRORS WERE DETECTED' ;\nRETURN  ERROR_COUNT ;\n\nEOF EOF EOF EOF EOF EOF EOF EOF EOF EOF  FOE FOE FOE FOE FOE FOE FOE FOE FOE FOE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALTERPGM": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x12%\\x00\\x87\\x00\\x87\\x00\\x00\\xc2\\xc9\\xd5\\xc1\\xd9\\xe8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T12:25:00", "lines": 135, "newlines": 135, "modlines": 0, "user": "BINARY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ANALYZER": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x11Y\\x05\\xfb\\x05\\xfb\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T11:59:00", "lines": 1531, "newlines": 1531, "modlines": 0, "user": "SOURCE"}, "text": "   /*  ANALYZER\n                 THE SYNTAX ANALYSIS AND TABLE BUILDING PROGRAM\n                 OF THE XPL SYSTEM.\n\n      J. J. HORNING AND W. M. MC KEEMAN      STANFORD UNIVERSITY\n\n      THIS PROGRAM BUILDS TABLES DIRECTLY ACCEPTABLE FOR USE IN\n         THE COMPILER XCOM OR THE PROTO-COMPILER SKELETON.\n\n   INPUT TO ANALYZER MAY BE NEARLY \"FREE FORMAT.\"\n   CARDS WITH THE CHARACTER $ IN COLUMN 1 ARE TREATED AS COMMENT OR CONTROL\n      CARDS, AND LISTED UNCHANGED.  THE CHARACTER IN COLUMN 2 IS THE CONTROL\n      CHARACTER, AS FOLLOWS:\n         L   COMPLEMENT LISTING MODE,\n         T   COMPLEMENT TRACING MODE,\n         P   COMPLEMENT PUNCHING MODE,\n         O   COMPLEMENT LINE PRINTER LISTING OF COMPUTED \"CARD OUTPUT,\"\n         I   COMPLEMENT ITERATIVE IMPROVEMENT MODE,\n         EOG   END OF GRAMMAR;  (ANOTHER GRAMMAR FOLLOWS).\n\n   BLANK CARDS ARE IGNORED.\n   PRODUCTIONS ARE PLACED ONE TO A CARD.\n   A TOKEN IS\n      ANY CONSECUTIVE GROUP OF NON-BLANK CHARACTERS NOT BEGINNING WITH A  \"<\"\n         AND FOLLOWED BY A BLANK,\n      THE CHARACTER \"<\"  FOLLOWED BY A BLANK,\n      THE CHARACTER \"<\"  FOLLOWED BY A NON-BLANK CHARACTER AND THEN ANY\n         STRING OF BLANK OR NON-BLANK CHARACTERS UP TO AND INCLUDING THE\n         NEXT OCCURRENCE OF THE CHARACTER \"<\".\n\n   IF COLUMN 1 IS NON-BLANK, THE FIRST TOKEN ON THE CARD IS TAKEN TO BE THE\n      LEFT PART OF THE PRODUCTION;  OTHERWISE, THE LEFT PART IS TAKEN TO BE\n      THE LEFT PART OF THE PREVIOUS PRODUCTION.\n   THE BALANCE OF THE CARD (UP TO FIVE TOKENS) IS TAKEN TO BE THE RIGHT PART.\n   ANY SYMBOL WHICH DOES NOT OCCUR AS A LEFT PART IS A TERMINAL SYMBOL.\n   ANY SYMBOL WHICH OCCURS ONLY AS A LEFT PART IS A GOAL SYMBOL.\n   ALL PRODUCTIONS WITH THE SAME LEFT PART MUST BE GROUPED.\n\n   PRODUCTIONS ARE REFORMATTED FOR READABILITY (INCLUDING THE INSERTION OF\n      THE META-SYMBOLS  ::=  AND  |  )  BEFORE LISTING.\n   BLANKS BETWEEN TOKENS ARE NOT SIGNIFICANT.\n                                                                       */\n   /* FIRST COME THE GLOBAL VARIABLE DECLARATIONS:        */\n\n   DECLARE V(255) CHARACTER, (LEFT_PART, RIGHT_HEAD) (255) BIT(8),\n      PRODUCTION(255) BIT(32), (ON_LEFT, ON_RIGHT) (255) BIT(1);\n   DECLARE INDEX(255) BIT(8), (IND, IND1) (255) BIT(16);\n   DECLARE SORT#(255) FIXED, AMBIGUOUS BIT(1);\n   DECLARE (NSY, NPR, SP, CP, NT, LEVEL, GOAL_SYMBOL) FIXED;\n\n   DECLARE CONTROL(255) BIT(1);\n   DECLARE TRUE LITERALLY '1', FALSE LITERALLY '0';\n   DECLARE CARRIAGE LITERALLY '1', PUNCH LITERALLY '2', DISK LITERALLY '3',\n      PAGE CHARACTER INITIAL ('1'), DOUBLE CHARACTER INITIAL ('0'),\n      EJECT_PAGE LITERALLY 'OUTPUT(1) = PAGE',\n      DOUBLE_SPACE LITERALLY 'OUTPUT(1) = DOUBLE';\n   DECLARE DOLLAR LITERALLY 'BYTE(''$'')', BLANK LITERALLY 'BYTE('' '')';\n   DECLARE CHANGE BIT(1), WORK(\"4000\") BIT(8);\n   DECLARE HEAD(255) FIXED, TAIL(255) BIT(8);\n   DECLARE STACKLIMIT LITERALLY '200', TEXTLIMIT LITERALLY '255',\n      DEPTH LITERALLY '255';   /*  MUST BE AT LEAST 255  */\n   DECLARE STACK(STACKLIMIT) BIT(8), TEXT(TEXTLIMIT) BIT(8),\n      TOKEN_SAVE(DEPTH) BIT(8), TOKEN FIXED, MP_SAVE(DEPTH) BIT(8), MP FIXED,\n      TP_SAVE(DEPTH) BIT(8), TP FIXED, P_SAVE(DEPTH) BIT(8), P FIXED;\n   DECLARE HEAD_TABLE(\"2000\") BIT(8);\n      DECLARE EMPTY CHARACTER INITIAL('\n                                       ');  /* IMAGE OF BLANK CARD  */\n   DECLARE HALF_LINE CHARACTER INITIAL ('\n                           '), X12 CHARACTER INITIAL ('            ');\n   DECLARE CARDIMAGE CHARACTER, OUTCARD CHARACTER, S CHARACTER, T CHARACTER;\n   DECLARE (NETRY, FIRST_TIME, LAST_TIME, THIS_TIME) FIXED;\n   DECLARE COUNT(3) FIXED;\n   DECLARE PRINT(3) CHARACTER INITIAL (' ', 'Y', 'N', '#');\n   DECLARE DOTS CHARACTER INITIAL (' ... ');\n   DECLARE VALUE(1) FIXED INITIAL (2, 1);\n   DECLARE (I, J, K, L, M) FIXED;\n   DECLARE ERROR_COUNT FIXED;\n   DECLARE TERMINATOR FIXED;\n   DECLARE MAXNF11 LITERALLY '5000', MAXNTRIP LITERALLY '1000';\n   DECLARE F11(MAXNF11) FIXED, NF11 FIXED;\n   DECLARE TRIPLE(MAXNTRIP) FIXED, TV(MAXNTRIP) BIT(2), NTRIP FIXED;\n   DECLARE STACKING BIT(1) INITIAL (TRUE);  /* CONTROLS BATCHING OF GRAMMARS  */\n   DECLARE MAXTROUBLE LITERALLY '50', TROUBLE1(MAXTROUBLE) BIT(8),\n      TROUBLE2(MAXTROUBLE) BIT(8), TROUBLE_COUNT FIXED;\n   DECLARE (BASIC_NSY, BASIC_NPR) FIXED;\n   DECLARE ITERATION_COUNT FIXED;\n\n   /* NOW SOME DATA PACKING/UNPACKING PROCEDURES USED BELOW   */\n\nIS_HEAD:\n   PROCEDURE (I, J) BIT(1);\n   /* THIS PROCEDURE DECODES THE PACKED HEAD TABLE.  TRUE IF V(J) IS A HEAD\n      OF V(I)     */\n   /* WE MUST SIMULATE DOUBLE SUBSCRIPT FOR ARRAY\n      HEAD_TABLE(0:255, 0:255) BIT(1)  */\n\n   DECLARE (I, J) FIXED;\n   RETURN 1 & SHR(HEAD_TABLE(SHL(I,5)+SHR(J,3)), J & 7);\nEND IS_HEAD;\n\nSET_HEAD:\n   PROCEDURE (I, J);\n   /* THIS PROCEDURE ADDS V(J) AS A HEAD OF V(I) IN THE HEAD_TABLE  */\n\n   DECLARE (I, J, K, L) FIXED;\n   CHANGE = TRUE;\n   K = SHL(I, 5) + SHR(J, 3);\n   L = SHL(1, J & 7);\n   HEAD_TABLE(K) = HEAD_TABLE(K) | L;\nEND SET_HEAD;\n\nCLEAR_HEADS:\n   PROCEDURE;\n   DECLARE I FIXED;\n   DO I = 0 TO \"2000\";\n      HEAD_TABLE(I) = 0;\n   END;\nEND CLEAR_HEADS;\n\nGET:\n   PROCEDURE (I, J) BIT(2);\n   DECLARE (I, J) FIXED;\n   /* THIS PROCEDURE DECODES A 2-BIT ENTRY IN THE WORK MATRIX  */\n   /* WE MUST SIMULATE DOUBLE SUBSCRIPT FOR ARRAY\n     WORK(0:255, 0:255) BIT(2)  */\n\n   RETURN 3 & SHR(WORK(SHL(I,6)+SHR(J,2)), SHL(J & 3, 1));\nEND GET;\n\nSET:\n   PROCEDURE (I, J, VAL);\n   /* THIS PROCEDURE OR'S A 2-BIT VAL INTO THE WORK MATRIX    */\n\n   DECLARE (I, J, VAL) FIXED;\n   DECLARE (K, L) FIXED;\n   K = SHL(I, 6) + SHR(J, 2);\n   L = SHL(VAL & 3, SHL(J & 3, 1));\n   WORK(K) = WORK(K) | L;\nEND SET;\n\nCLEAR_WORK:\n   PROCEDURE;\n   DECLARE I FIXED;\n   DO I = 0 TO \"4000\";\n      WORK(I) = 0;\n   END;\nEND CLEAR_WORK;\n\nPACK:\n   PROCEDURE (B1, B2, B3, B4) FIXED;\n   /* THIS PROCEDURE HAS THE VALUE OF THE 4 BYTES PACKED INTO A 32-BIT WORD  */\n\n   DECLARE (B1, B2, B3, B4) BIT(8);\n   RETURN SHL(B1,24) + SHL(B2,16) + SHL(B3,8) + B4;\nEND PACK;\n\nERROR:\n   PROCEDURE (MESSAGE);\n      DECLARE MESSAGE CHARACTER;\n      OUTPUT = '*** ERROR, ' || MESSAGE;\n      ERROR_COUNT = ERROR_COUNT + 1;\n   END ERROR;\n\nENTER:\n   PROCEDURE (ENV, VAL);\n   /* THIS PROCEDURE RECORDS TOGETHER THE 2-BIT VAL 'S FOR EACH UNIQUE ENV\n         TO ASSIST TABLE LOOKUP, THE ENV 'S ARE STORED IN ASCENDING ORDER.\n         THEY ARE LOCATED BY A BINARY SEARCH    */\n\n   DECLARE (ENV, VAL, I, J, K) FIXED;\n   NETRY = NETRY + 1; /* COUNT ENTRIES VS. UNIQUE ENTRIES */\n   I = 0;  K = NTRIP + 1;\n   DO WHILE I + 1 < K; /* BINARY LOOK-UP */\n      J = SHR(I+K,1);\n      IF TRIPLE(J) > ENV THEN K = J;\n      ELSE IF TRIPLE(J) < ENV THEN I = J;\n      ELSE\n         DO;\n            TV(J) = TV(J) | VAL;\n            RETURN;\n         END;\n   END;\n   IF NTRIP >= MAXNTRIP THEN\n      DO;\n         CALL ERROR ('TOO MANY TRIPLES FOR TABLE');\n         NTRIP = 0;\n      END;\n   DO J = 0 TO NTRIP - K;  /* MAKE ROOM IN TABLE FOR NEW ENTRY */\n      I = NTRIP - J;\n      TRIPLE(I+1) = TRIPLE(I);\n      TV(I+1) = TV(I);\n   END;\n   NTRIP = NTRIP + 1;\n   TRIPLE(K) = ENV;\n   TV(K) = VAL;\nEND ENTER;\n\nADD_TROUBLE:\n   PROCEDURE (LEFT, RIGHT);\n      DECLARE (LEFT, RIGHT) FIXED;\n      DECLARE I FIXED;\n      IF LEFT > BASIC_NSY THEN RETURN;\n      IF LEFT = TERMINATOR THEN RETURN;\n      IF TROUBLE_COUNT = MAXTROUBLE THEN RETURN;  /* TROUBLE ENOUGH  */\n      DO I = 1 TO TROUBLE_COUNT;\n         IF TROUBLE1(I) = LEFT THEN IF TROUBLE2(I) = RIGHT THEN RETURN;\n      END;\n      TROUBLE_COUNT = TROUBLE_COUNT + 1;\n      TROUBLE1(TROUBLE_COUNT) = LEFT;\n      TROUBLE2(TROUBLE_COUNT) = RIGHT;\n   END ADD_TROUBLE;\n\nLINE_OUT:\n   PROCEDURE (NUMBER, LINE);\n   /* NUMBER A LINE AND PRINT IT  */\n\n   DECLARE NUMBER FIXED, LINE CHARACTER;\n   DECLARE N CHARACTER;\n   N = NUMBER;  NUMBER = 6 - LENGTH(N);  /* 6 = MARGIN */\n   OUTPUT = SUBSTR(EMPTY, 0, NUMBER) || N || '   ' || LINE;\nEND LINE_OUT;\n\nBUILD_CARD:\n   PROCEDURE (ITEM);\n   /* ADD ITEM TO OUTCARD AND PUNCH IF CARD BOUNDARY EXCEEDED */\n\n   DECLARE ITEM CHARACTER;\n   IF LENGTH(ITEM) + LENGTH(OUTCARD) >= 80 THEN\n      DO;\n         IF CONTROL(BYTE('P')) THEN OUTPUT(PUNCH) = OUTCARD;\n         IF CONTROL(BYTE('O')) THEN\n            OUTPUT = '--- CARD OUTPUT ---|' || OUTCARD;\n         OUTCARD = '      ' || ITEM;\n      END;\n   ELSE OUTCARD = OUTCARD || ' ' || ITEM;\nEND BUILD_CARD;\n\nPUNCH_CARD:\n   PROCEDURE (ITEM);\n   /*  PUNCH OUTCARD AND ITEM  */\n\n   DECLARE ITEM CHARACTER;\n   CALL BUILD_CARD (ITEM);\n   IF CONTROL(BYTE('P')) THEN OUTPUT(PUNCH) = OUTCARD;\n   IF CONTROL(BYTE('O')) THEN\n      OUTPUT = '--- CARD OUTPUT ---|' || OUTCARD;\n   OUTCARD = '  ';\nEND PUNCH_CARD;\n\nPRINT_MATRIX:\n   PROCEDURE (TITLE, SOURCE);\n   /* PRINT AND LABEL THE MATRIX SPECIFIED BY SOURCE (HEAD_TABLE OR WORK)  */\n\n   DECLARE TITLE CHARACTER, SOURCE FIXED;\n   DECLARE (I, J, K, L, M, N, BOT, TOP, MARGIN_SIZE, NUMBER_ACROSS, WIDE) FIXED,\n      (MARGIN, LINE, WASTE, BAR, PAGES) CHARACTER,\n      DIGIT(9) CHARACTER INITIAL ('0','1','2','3','4','5','6','7','8','9'),\n      NUMBER_HIGH LITERALLY '48',\n      GS LITERALLY '16';\n   IF SOURCE = 1 THEN WIDE = NT;  ELSE WIDE = NSY;\n   MARGIN_SIZE = 5;\n   DO I = 1 TO NSY;\n      IF LENGTH(V(I)) >= MARGIN_SIZE THEN MARGIN_SIZE = LENGTH(V(I)) + 1;\n   END;\n   MARGIN = SUBSTR('\n                 ', 0, MARGIN_SIZE);\n   WASTE = MARGIN || '          ';\n   NUMBER_ACROSS = (122 - MARGIN_SIZE)/(GS + 1)*GS;\n   DO I = 0 TO 3;\n      COUNT(I) = 0;\n   END;\n   M = 0;\n   I = (WIDE-1)/NUMBER_ACROSS + 1;\n   PAGES = ((NSY-1)/NUMBER_HIGH + 1)*I;\n   DO I = 0 TO (WIDE-1)/NUMBER_ACROSS;\n      BOT = NUMBER_ACROSS*I + 1;\n      TOP = NUMBER_ACROSS*(I+1);\n      IF TOP > WIDE THEN TOP = WIDE;\n      BAR = SUBSTR(WASTE, 1) || '+';\n      DO L = BOT TO TOP;\n         BAR = BAR || '-';\n         IF L MOD GS = 0 THEN BAR = BAR || '+';\n      END;\n      IF TOP MOD GS \u00ac= 0 THEN BAR = BAR || '+';\n      DO J = 0 TO (NSY-1)/NUMBER_HIGH;\n         /*  ONCE PER PAGE OF PRINTOUT  */\n         EJECT_PAGE;\n         M = M + 1;\n         OUTPUT = TITLE || ':  PAGE ' || M || ' OF ' || PAGES;\n         DOUBLE_SPACE;\n         L = 100;\n         DO WHILE L > 0;\n            LINE = WASTE;\n            DO N = BOT TO TOP;\n               IF N < L THEN LINE = LINE || ' ';\n               ELSE LINE = LINE || DIGIT(N/L MOD 10);\n               IF N MOD GS = 0 THEN LINE = LINE || ' ';\n            END;\n            OUTPUT = LINE;\n            L = L / 10;\n         END;\n         OUTPUT = BAR;\n         N = NUMBER_HIGH*(J+1);\n         IF N > NSY THEN N = NSY;\n         DO K = NUMBER_HIGH*J + 1 TO N;\n            L = LENGTH(V(K));\n            LINE = V(K) || SUBSTR(MARGIN, L) || '|';\n            DO L = BOT TO TOP;\n               IF SOURCE \u00ac= 0 THEN\n                  DO;\n                     N = GET (K, L);\n                     LINE = LINE || PRINT(N);\n                     COUNT(N) = COUNT(N) + 1;\n                  END;\n               ELSE LINE = LINE || PRINT(IS_HEAD (K, L));\n               IF L MOD GS = 0 THEN LINE = LINE || '|';\n            END;\n            IF TOP MOD GS \u00ac= 0 THEN LINE = LINE || '|';\n            CALL LINE_OUT (K, LINE);\n            IF K MOD GS = 0 THEN\n               OUTPUT = BAR;\n         END;\n         IF K MOD GS \u00ac= 1 THEN OUTPUT = BAR;\n      END;\n   END;\n   DOUBLE_SPACE;\n   IF SOURCE \u00ac= 0 THEN\n      DO;\n         OUTPUT = 'TABLE ENTRIES SUMMARY:';\n         DO I = 0 TO 3;\n            CALL LINE_OUT (COUNT(I), PRINT(I));\n         END;\n      END;\nEND PRINT_MATRIX;\n\nPRINT_TRIPLES:\n   PROCEDURE (TITLE);\n   /* FORMAT AND PRINT THE (2,1) TRIPLES FOR C1  */\n\n   DECLARE TITLE CHARACTER, (I, J) FIXED;\n   IF NTRIP = 0 THEN\n      DO;\n         DOUBLE_SPACE;\n         OUTPUT = 'NO TRIPLES REQUIRED.';\n         COUNT(1) = 0;   /* SO WE DON'T PUNCH ANY  */\n         RETURN;\n      END;\n   EJECT_PAGE;\n   OUTPUT = TITLE || ':';\n   DOUBLE_SPACE;\n   DO I = 1 TO 3;\n      COUNT(I) = 0;\n   END;\n   DO I = 1 TO NTRIP;\n      J = TRIPLE(I);\n      K = TV(I);\n      IF K = 3 THEN\n         DO;\n            CALL ERROR ('STACKING DECISION CANNOT BE MADE WITH (2,1) CONTEXT:');\n            CALL ADD_TROUBLE (SHR(J, 16), SHR(J, 8) & \"FF\");\n         END;\n      CALL LINE_OUT (I, PRINT(K) || ' FOR  ' || V(SHR(J, 16)) || ' ' ||\n         V(SHR(J, 8)&\"FF\") || ' ' || V(J&\"FF\"));\n      COUNT(K) = COUNT(K) + 1;\n   END;\n   DOUBLE_SPACE;\n   OUTPUT = NETRY || ' ENTRIES FOR ' || NTRIP || ' TRIPLES.';\n   DOUBLE_SPACE;\n   OUTPUT = 'TABLE ENTRIES SUMMARY:';\n   DO I = 1 TO 3;\n      CALL LINE_OUT (COUNT(I), PRINT(I));\n   END;\nEND PRINT_TRIPLES;\n\nBUILD_RIGHT_PART:\n   PROCEDURE (P);\n      DECLARE (P, PR) FIXED;\n      PR = PRODUCTION(P);\n      T = '';\n      DO WHILE PR \u00ac= 0;\n         T = ' ' || V(PR&\"FF\") || T;\n         PR = SHR(PR, 8);\n      END;\n      T = V(RIGHT_HEAD(P)) || T;\n   END BUILD_RIGHT_PART;\n\nOUTPUT_PRODUCTION:\n   PROCEDURE (P);\n      DECLARE P FIXED;\n      CALL BUILD_RIGHT_PART(P);\n      CALL LINE_OUT (P, V(LEFT_PART(P)) || '  ::=  ' || T);\n   END OUTPUT_PRODUCTION;\n\nPRINT_TIME:\n   PROCEDURE;\n   /* OUTPUT ELAPSED TIMES  */\n\n   DECLARE (I, J) FIXED, T CHARACTER;\n   DOUBLE_SPACE;\n   THIS_TIME = TIME;\n   I = THIS_TIME - LAST_TIME;\n   J = I MOD 100;\n   I = I / 100;\n   T = 'TIME USED WAS ' || I || '.';\n   IF J < 10 THEN T = T || '0';\n   OUTPUT = T || J || ' SECONDS.';\n   I = THIS_TIME - FIRST_TIME;\n   J = I MOD 100;\n   I = I / 100;\n   T = 'TOTAL TIME IS ' || I || '.';\n   IF J < 10 THEN T = T || '0';\n   OUTPUT = T || J || ' SECONDS.';\n   LAST_TIME = THIS_TIME;\nEND PRINT_TIME;\n\nLOOK_UP:\n   PROCEDURE (SYMBOL) BIT(8);  /* GET INDEX OF SYMBOL IN V  */\n   DECLARE SYMBOL CHARACTER;\n   DECLARE J FIXED;\n   DO J = 1 TO NSY;\n      IF V(J) = SYMBOL THEN RETURN J;\n   END;\n   IF J = 256 THEN\n      DO;\n         CALL ERROR ('TOO MANY SYMBOLS');\n         J = 1;\n      END;\n   /* ADD SYMBOL TO V  */\n   NSY = J;\n   V(J) = SYMBOL;\n   RETURN J;\nEND LOOK_UP;\n\nEXPAND:\n   PROCEDURE (F11, P);  /* EXPAND PRODUCTION P IN THE CONTEXT OF F11  */\n   DECLARE (F11, I, J, P, OLDP) FIXED;\n   /* OLDP REMEMBERS ARGUMENT P FROM PREVIOUS CALL TO SAVE REPEATED EFFORT */\n   IF P \u00ac= OLDP THEN\n      DO;\n         OLDP = P;\n         SP = 2;\n         STACK(SP) = RIGHT_HEAD(P);\n         J = PRODUCTION(P);\n         DO WHILE J \u00ac= 0; /* UNPACK PRODUCTION INTO STACK */\n            I = SHR(J, 24);\n            IF I \u00ac= 0 THEN\n               DO;\n                  SP = SP + 1;\n                  STACK(SP) = I;\n               END;\n            J = SHL(J, 8);\n         END;\n      END;\n   STACK(1) = SHR(F11, 8) & \"FF\";  /* LEFT CONTEXT */\n   STACK(SP+1) = F11 & \"FF\";         /* RIGHT CONTEXT */\nEND EXPAND;\n\n\n   /*  NOW THE WORKING PROCEDURES  */\n\nREAD_GRAMMAR:\n   PROCEDURE;  /*  READ IN AND LIST A GRAMMAR  */\n   DECLARE (P, LONG) FIXED;\n\n   SCAN:\n      PROCEDURE BIT(8); /* GET A TOKEN FROM INPUT CARDIMAGE  */\n      DECLARE LP FIXED, LEFT_BRACKET LITERALLY 'BYTE(''<'')',\n         RIGHT_BRACKET LITERALLY 'BYTE(''>'')', STOP FIXED;\n      DO CP = CP TO LONG;\n         IF BYTE(CARDIMAGE,CP) \u00ac= BLANK THEN\n            DO;\n               LP = CP; /* MARK LEFT BOUNDARY OF SYMBOL */\n               IF BYTE(CARDIMAGE,CP) = LEFT_BRACKET & BYTE(CARDIMAGE,CP+1)\n                  \u00ac= BLANK THEN\n                  STOP = RIGHT_BRACKET;\n                  ELSE STOP = BLANK;\n               DO CP = CP + 1 TO LONG;\n                  IF BYTE(CARDIMAGE, CP) = STOP THEN GO TO DELIMIT;\n               END;\n               IF STOP \u00ac= BLANK THEN\n                  DO;\n                     CALL ERROR ('UNMATCHED BRACKET: <');\n                     CP = CP - 1;\n                     DO WHILE BYTE(CARDIMAGE, CP) = BLANK;  /* ERROR RECOVERY */\n                        CP = CP - 1;\n                     END;\n                  END;\n            DELIMIT:\n               IF STOP \u00ac= BLANK THEN CP = CP + 1; /* PICK UP THE > */\n               T = SUBSTR(CARDIMAGE, LP, CP-LP);  /* PICK UP THE SYMBOL */\n               RETURN LOOK_UP(T);\n            END;\n      END;  /* END OF CARD  */\n      T = '';\n      RETURN 0;\n   END SCAN;\n\n   GET_CARD:\n      PROCEDURE BIT(1);  /* READ THE NEXT CARD  */\n      CP = 0;\n      DO WHILE TRUE;\n         CARDIMAGE = INPUT;  /* GET THE CARD */\n         LONG = LENGTH(CARDIMAGE) - 1;\n         IF LONG < 0 THEN\n            DO;    /*  END OF FILE DETECTED  */\n               STACKING = FALSE;\n               RETURN FALSE;\n            END;\n         IF BYTE(CARDIMAGE) = DOLLAR THEN\n            DO;  /* CONTROL CARD OR COMMENT */\n               IF SUBSTR(CARDIMAGE, 1, 3) = 'EOG' THEN RETURN FALSE;\n               IF CONTROL(BYTE('L')) THEN OUTPUT = CARDIMAGE;\n               CONTROL(BYTE(CARDIMAGE,1)) = \u00ac CONTROL(BYTE(CARDIMAGE,1));\n            END;\n         ELSE IF CARDIMAGE \u00ac= EMPTY THEN RETURN TRUE;\n      END;\n   END GET_CARD;\n\n   SORT_V:\n      PROCEDURE;  /* SORT THE SYMBOL TABLE  */\n      DO I = 1 TO NSY;\n          /* SORT ON 1.  TERMINAL VS. NON-TERMINAL\n                        2.  LENGTH OF SYMBOL\n                           3.  ORIGINAL ORDER OF OCCURRENCE  */\n         SORT#(I) = SHL(ON_LEFT(I), 16) | SHL(LENGTH(V(I)), 8) | I;\n      END;\n      /* BUBBLE SORT  */\n      K, L = NSY;\n      DO WHILE K <= L;\n         L = 0;\n         DO I = 2 TO K;\n            L = I - 1;\n            IF SORT#(L) > SORT#(I) THEN\n               DO;\n                  J = SORT#(L);  SORT#(L) = SORT#(I);  SORT#(I) = J;\n                  T = V(L);  V(L) = V(I);  V(I) = T;\n                  K = L;\n               END;\n         END;\n      END;\n      DO I = 1 TO NSY; /* BUILD TABLE TO LOCATE SORTED SYMBOLS OF V */\n         INDEX(SORT#(I)&\"FF\") = I;\n      END;\n      NT = NSY;  /* PREPARE TO COUNT NON-TERMINAL SYMBOLS */\n      DO WHILE SORT#(NT) > \"10000\";  NT = NT - 1;  END;\n      /* SUBSTITUTE NEW INDEX NUMBERS IN PRODUCTIONS  */\n      DO I = 1 TO NPR;\n         LEFT_PART(I) = INDEX(LEFT_PART(I));\n         J = INDEX(RIGHT_HEAD(I));\n         ON_RIGHT(J) = TRUE;\n         RIGHT_HEAD(I) = J;\n         L = PRODUCTION(I);\n         DO K = 0 TO 3;\n            J = INDEX(SHR(L,24));\n            ON_RIGHT(J) = TRUE;\n            L = SHL(L,8) + J;\n         END;\n         PRODUCTION(I) = L;\n      END;\n      TERMINATOR = INDEX(1);  /* ADD _|_ TO VOCABULARY */\n      ON_RIGHT(TERMINATOR) = TRUE;\n   END SORT_V;\n\n   PRINT_DATE:\n      PROCEDURE (MESSAGE, D);\n         DECLARE MESSAGE CHARACTER, D FIXED;\n         DECLARE MONTH(11) CHARACTER INITIAL ('JANUARY', 'FEBRUARY', 'MARCH',\n            'APRIL', 'MAY', 'JUNE', 'JULY', 'AUGUST', 'SEPTEMBER', 'OCTOBER',\n            'NOVEMBER', 'DECEMBER'), DAYS(11) FIXED INITIAL (0, 31, 60, 91,\n            121, 152, 182, 213, 244, 274, 305, 335);\n         DECLARE (YEAR, DAY, M) FIXED;\n\n         YEAR = D/1000 + 1900;\n         DAY = D MOD 1000;\n         IF (YEAR & 3) \u00ac= 0 THEN IF DAY > 59 THEN DAY = DAY + 1;\n         M = 11;\n         DO WHILE DAY <= DAYS(M);  M = M - 1;  END;\n         OUTPUT = MESSAGE || MONTH(M) || ' ' || DAY-DAYS(M) || ', ' ||\n            YEAR || '.';\n      END PRINT_DATE;\n\n   EJECT_PAGE;\n   CALL PRINT_DATE ('GRAMMAR ANALYSIS  --  \"THIS INSTALLATION\"  --  ANALYZER VER\nSION OF ', DATE_OF_GENERATION);\n   DOUBLE_SPACE;\n   CALL PRINT_DATE ('TODAY IS ', DATE);\n   DOUBLE_SPACE;\n   OUTPUT = '             P R O D U C T I O N S';\n   DOUBLE_SPACE;\n   CONTROL(BYTE('L')) = TRUE;\n   V(0) = '<ERROR: TOKEN = 0>';\n   NSY = 1;  V(1) = '_|_';\n   NPR, ERROR_COUNT = 0;\n   DO I = 0 TO 255;  /* CLEAR ON_LEFT AND ON_RIGHT  */\n      ON_LEFT(I), ON_RIGHT(I) = 0;\n   END;\n   DO WHILE GET_CARD;  /* WATCH SIDE EFFECT */\n      IF NPR = 255 THEN CALL ERROR ('TOO MANY PRODUCTIONS');\n      ELSE NPR = NPR + 1;\n      IF BYTE(CARDIMAGE) = BLANK THEN LEFT_PART(NPR) = LEFT_PART(NPR-1);\n      ELSE\n         DO;\n            I = SCAN;      /* LEFT PART SYMBOL  */\n            LEFT_PART(NPR) = I;\n            ON_LEFT(I) = TRUE;\n         END;\n      I = SCAN; /* FIRST SYMBOL ON THE RIGHT */\n      IF I = 0 THEN CALL ERROR ('EMPTY RIGHT PART.');\n      RIGHT_HEAD(NPR) = I;\n      J, P = 0;\n      DO J = 1 TO 4;\n         I = SCAN;\n         IF I \u00ac= 0 THEN\n            P = SHL(P, 8) + I;  /* PACK 4 TO A WORD  */\n      END;\n      IF SUBSTR(CARDIMAGE, CP) \u00ac= SUBSTR(EMPTY, CP) THEN\n         CALL ERROR ('TOO MANY SYMBOLS IN RIGHT PART.  FORCED TO DISCARD  ' ||\n            SUBSTR(CARDIMAGE, CP));\n      PRODUCTION(NPR) = P;\n      IF CONTROL(BYTE('L')) THEN\n         DO;  /* UNPACK TABLE AND PRINT PRODUCTION */\n            IF LEFT_PART(NPR) = LEFT_PART(NPR-1) THEN\n               DO;\n                  I = LENGTH(V(LEFT_PART(NPR)));\n                  CARDIMAGE = SUBSTR(EMPTY, 0, I) || '    |  ';\n               END;\n            ELSE\n               DO;\n                  OUTPUT = '';\n                  CARDIMAGE = V(LEFT_PART(NPR)) || '  ::=  ';\n               END;\n            CALL BUILD_RIGHT_PART(NPR);\n            CALL LINE_OUT (NPR, CARDIMAGE || T);\n         END;\n      IF CONTROL(BYTE('P')) THEN\n         DO;  /* UNPACK TABLE AND PRINT PL COMMENT */\n            P = PRODUCTION(NPR);\n            OUTCARD = ' /*  ' || V(LEFT_PART(NPR)) || ' ::= ' ||\n               V(RIGHT_HEAD(NPR));\n            DO K = 1 TO 4;\n               I = SHR(P, SHL(4-K, 3)) & \"FF\";\n               IF I \u00ac= 0 THEN CALL BUILD_CARD (V(I));\n            END;\n            CALL PUNCH_CARD ('   */');\n         END;\n   END;\n   CALL PRINT_TIME;\n   CALL SORT_V;\n   EJECT_PAGE;\n   OUTPUT  = '   T E R M I N A L   S Y M B O L S\n   N O N T E R M I N A L S';\n   DOUBLE_SPACE;\n   IF NSY - NT > NT THEN L = NSY - NT;  ELSE L = NT; /* L = NUMBER OF LINES */\n   DO I = 1 TO L;  /* PRINT V */\n      IF I > NT THEN CARDIMAGE = HALF_LINE;\n      ELSE\n         DO;  /* TERMINAL SYMBOLS */\n            T = I;\n            J = 5 - LENGTH(T);\n            CARDIMAGE = SUBSTR(SUBSTR(EMPTY, 0, J) || T || '   ' || V(I)\n               || HALF_LINE, 0, 66);\n         END;\n      K = I + NT;\n      IF K <= NSY THEN\n         DO;  /* NON-TERMINAL SYMBOLS */\n            T = K;\n            J = 5 - LENGTH(T);\n            CARDIMAGE = CARDIMAGE || SUBSTR(EMPTY, 0, J) || T || '   '\n               || V(K);\n         END;\n      OUTPUT = CARDIMAGE;\n   END;\n   DOUBLE_SPACE;\n   GOAL_SYMBOL = 0;\n   DO I = 1 TO NSY;   /* LOCATE GOAL SYMBOL */\n      IF \u00ac ON_RIGHT(I) THEN\n         IF GOAL_SYMBOL = 0 THEN\n               DO;\n                  GOAL_SYMBOL = I;\n                  OUTPUT = V(I) || ' IS THE GOAL SYMBOL.';\n               END;\n            ELSE OUTPUT = 'ANOTHER GOAL: ' || V(I) || ' (WILL NOT BE USED)';\n   END;\n   IF GOAL_SYMBOL = 0 THEN\n      DO;\n         GOAL_SYMBOL = LEFT_PART(1);\n         OUTPUT = 'NO GOAL SYMBOL FOUND.  ' || V(GOAL_SYMBOL) ||\n            ' USED FOR GOAL SYMBOL.';\n      END;\n\n   BASIC_NSY = NSY;\n   BASIC_NPR = NPR;\n   TROUBLE_COUNT = 0;\nEND READ_GRAMMAR;\n\nIMPROVE_GRAMMAR:\n   PROCEDURE;\n      DECLARE (T1, T2, S1, S2) FIXED, CHANGE BIT(1),\n         INTERNAL BIT(1), ADD_ON CHARACTER INITIAL ('0123456789ABCDEFGHIJKL');\n      EJECT_PAGE;\n      OUTPUT = 'GRAMMAR MODIFICATION TO ATTEMPT TO RESOLVE CONFLICTS:';\n      DO I = 1 TO BASIC_NSY;\n         INDEX(I) = 0;\n      END;\n      DO I = 1 TO TROUBLE_COUNT;  /* STEP THROUGH PROBLEMS  */\n         DOUBLE_SPACE;\n         T1 = TROUBLE1(I);\n         T2 = TROUBLE2(I);\n         DO P = 1 TO BASIC_NPR;\n            INTERNAL, CHANGE = FALSE;\n            S1 = RIGHT_HEAD(P);\n            M = PRODUCTION(P);\n            DO L = 1 TO 4;  /* STEP THROUGH RIGHT PART  */\n               S2 = SHR(M, 24);\n               M = SHL(M, 8) + S2;\n               IF S2 \u00ac= 0 THEN\n                  DO;\n                     IF S1 = T1 & IS_HEAD (S2, T2) THEN\n                        DO;\n                           J, INDEX(T1) = INDEX(T1) + 1;\n                           IF NSY < 255 THEN NSY = NSY + 1;\n                           ELSE CALL ERROR ('TOO MANY SYMBOLS');\n                           S = SUBSTR(ADD_ON, J, 1);\n                           V(NSY) = '<' || V(T1) || S || '>';\n                           IF NPR < 255 THEN NPR = NPR + 1;\n                           ELSE CALL ERROR ('TOO MANY PRODUCTIONS.');\n                           LEFT_PART(NPR) = NSY;\n                           RIGHT_HEAD(NPR) = T1;\n                           PRODUCTION(NPR) = 0;\n                           CALL OUTPUT_PRODUCTION (NPR);\n                           CHANGE = TRUE;\n                           IF INTERNAL THEN M = M & \"FFFF00FF\" | SHL(NSY, 8);\n                           ELSE RIGHT_HEAD(P) = NSY;\n                        END;\n                     INTERNAL = TRUE;\n                     S1 = S2;\n                  END;\n            END;  /* OF DO L  */\n            PRODUCTION(P) = M;\n            IF CHANGE THEN CALL OUTPUT_PRODUCTION (P);\n         END;  /* OF DO P  */\n      END;  /* OF DO I  */\n      TROUBLE_COUNT, ERROR_COUNT = 0;\n   END IMPROVE_GRAMMAR;\n\nCOMPUTE_HEADS:\n   PROCEDURE;  /* SET UP HEAD SYMBOL MATRIX  */\n   CALL CLEAR_HEADS;\n   CALL CLEAR_WORK;\n   DO I = 1 TO NPR;   /* FIRST GET IMMEDIATE HEADS */\n      CALL SET_HEAD (LEFT_PART(I), RIGHT_HEAD(I));\n   END;\n   DO WHILE CHANGE;   /* THEN COMPUTE TRANSITIVE COMPLETION */\n      CHANGE = FALSE;\n      DO I = NT + 1 TO NSY;\n         DO J = NT + 1 TO NSY;\n            IF IS_HEAD (I, J) THEN\n               DO K = 1 TO NSY;\n                  IF IS_HEAD (J, K) THEN\n                     IF \u00ac IS_HEAD (I, K) THEN\n                        CALL SET_HEAD (I, K);  /* SIDE EFFECT ON CHANGE */\n               END;\n         END;\n      END;\n   END;\n   CHANGE = TRUE;\n   IF ITERATION_COUNT = 1 THEN\n      DO;\n         AMBIGUOUS = FALSE;\n         DO I = 1 TO NPR;\n            J = RIGHT_HEAD(I);  K = PRODUCTION(I);\n            DO WHILE K \u00ac= 0;  J = SHR(K, 24);  K = SHL(K, 8);  END;\n            CALL SET (LEFT_PART(I), J, TRUE);\n         END;\n         DO WHILE CHANGE;\n            CHANGE = FALSE;\n            DO I = NT + 1 TO NSY;\n               DO J = NT + 1 TO NSY;\n                  IF GET (I, J) THEN\n                     DO K = 1 TO NSY;\n                        IF GET (J, K) THEN IF \u00ac GET (I, K) THEN\n                           DO;\n                              CALL SET (I, K, TRUE);\n                              CHANGE = TRUE;\n                           END;\n                     END;\n               END;\n            END;\n         END;\n         DO I = NT + 1 TO NSY;\n            IF IS_HEAD (I, I) THEN IF GET (I, I) THEN\n               DO;\n                  AMBIGUOUS = TRUE;\n                  CALL ERROR ('GRAMMAR IS AMBIGUOUS.  IT IS LEFT AND RIGHT RECUR\nSIVE IN THE SYMBOL  ' || V(I));\n               END;\n         END;\n      END;\n   DO I = 0 TO NSY;   /* THEN THE REFLEXIVE TRANSITIVE COMPLETION */\n      CALL SET_HEAD (I, I);\n   END;\n   CALL PRINT_MATRIX ('PRODUCED HEAD SYMBOLS', 0);\nEND COMPUTE_HEADS;\n\nPRODUCE:\n   PROCEDURE;  /* RUN THROUGH THE GENERATION ALGORITHM TO COMPUTE F11  */\n   DECLARE MAXLEVEL FIXED, NEW BIT(1);\n\n   NEVER_BEEN_HERE:\n      PROCEDURE; /* RECORD THE F11.  RETURN FALSE IF IT IS ALREADY IN TABLE  */\n      DECLARE (NEW_F11, I, J, K, NF11P1) FIXED;\n      NETRY = NETRY + 1;\n      NEW_F11 = PACK(0, STACK(SP), STACK(SP-1), TOKEN);\n      I = 0;  K, NF11P1 = NF11 + 1;\n      DO WHILE I + 1 < K; /* BINARY LOOK-UP */\n         J = SHR(I+K,1);\n         IF F11(J) > NEW_F11 THEN K = J;\n         ELSE IF F11(J) < NEW_F11 THEN I = J;\n         ELSE RETURN FALSE;  /* FOUND IT */\n      END;\n      /* IF WE GOT HERE, WE DIDN'T FIND IT */\n      IF NF11 >= MAXNF11 THEN DO;  CALL ERROR ('F11 OVERFLOW');  NF11 = 1;  END;\n      DO J = 0 TO NF11 - K;   /* MAKE ROOM TO INSERT NEW ENTRY */\n         F11(NF11P1-J) = F11(NF11-J);\n      END;\n      NF11 = NF11P1;\n      F11(K) = NEW_F11;\n      RETURN TRUE;\n   END NEVER_BEEN_HERE;\n\n   ADD_ITEM:\n      PROCEDURE (ITEM);\n      DECLARE ITEM CHARACTER;\n      IF LENGTH(CARDIMAGE) + LENGTH(ITEM) > 130 THEN\n         DO;\n            OUTPUT = CARDIMAGE;\n            CARDIMAGE = '      ';\n         END;\n      CARDIMAGE = CARDIMAGE || ' ' || ITEM;\n   END ADD_ITEM;\n\n   PRINT_FORM:\n      PROCEDURE; /* PRINT THE CURRENT SENTENTIAL FORM WHILE TRACING\n                    THE GENERATING ALGORITHM */\n      CARDIMAGE = 'LEVEL ' || LEVEL || ': ';\n      DO I = 1 TO SP;\n         CALL ADD_ITEM (V(STACK(I)));\n      END;\n      CALL ADD_ITEM ('  |  ');\n      DO I = 0 TO TP - 1;\n         CALL ADD_ITEM (V(TEXT(TP-I)));\n      END;\n      OUTPUT = CARDIMAGE;\n   END PRINT_FORM;\n\n   APPLY_PRODUCTION:\n      PROCEDURE;  /* PERFORM ONE PARSE STEP (ON STACK AND TEXT) AND RECUR  */\n         LEVEL = LEVEL + 1;  /* SIMULATE THE EFFECT OF RECURSION  */\n         IF LEVEL > MAXLEVEL THEN IF LEVEL > DEPTH THEN\n            DO;  CALL ERROR ('LEVEL OVERFLOW');  LEVEL = 1;  END;\n            ELSE MAXLEVEL = LEVEL;\n         MP_SAVE(LEVEL) = MP;      /* SAVE POINTER TO LEFT PART OF PRODUCTION */\n         MP = SP;\n         TP_SAVE(LEVEL) = TP;      /* SAVE POINTER INTO TEXT */\n         P_SAVE(LEVEL) = P;        /* SAVE NUMBER OF PRODUCTION TO BE APPLIED */\n         TOKEN_SAVE(LEVEL) = TOKEN;/* SAVE POINTER INTO IS_HEAD ARRAY */\n         STACK(SP) = RIGHT_HEAD(P);/* EXPAND PRODUCTION INTO STACK */\n         J = PRODUCTION(P);\n         DO WHILE J \u00ac= 0;\n            K = SHR(J,24);  J = SHL(J,8);\n            IF K \u00ac= 0 THEN\n               IF SP = STACKLIMIT THEN CALL ERROR ('STACK OVERFLOW');\n               ELSE DO;  SP = SP + 1;  STACK(SP) = K;  END;\n            END;\n         IF CONTROL(BYTE('T')) THEN CALL PRINT_FORM; /* TRACE */\n   END APPLY_PRODUCTION;\n\n   DIS_APPLY:\n      PROCEDURE;\n      /* UNDO THE PSEUDO-RECURSION, REVERSING THE EFFECT OF APPLY */\n      TOKEN = TOKEN_SAVE(LEVEL);\n      P = P_SAVE(LEVEL);\n      TP = TP_SAVE(LEVEL);\n      SP = MP;\n      MP = MP_SAVE(LEVEL);\n      STACK(SP) = LEFT_PART(P);\n      LEVEL = LEVEL - 1;\n   END DIS_APPLY;\n\n   DO I = 1 TO NSY;  INDEX(I) = 0;  END;\n   DO I = 1 TO NPR;    /* MAKE SURE PRODUCTIONS ARE PROPERLY GROUPED */\n      J = LEFT_PART(I);\n      IF J \u00ac= LEFT_PART(I-1) THEN\n         IF INDEX(J) = 0 THEN\n            INDEX(J) = I;\n         ELSE CALL ERROR ('PRODUCTIONS SEPARATED FOR ' || V(J) ||\n            '.  PRODUCTION ' || I || ' WILL BE IGNORED.');\n   END;\n   LEFT_PART(NPR+1) = 0;  /* FLAG END OF TABLE  */\n   /* SET INITIAL SENTENTIAL FORM TO  _|_  <GOAL>  _|_  */\n   TP = 0;\n   MP, SP = 1;\n   STACK(0), TEXT(0) = TERMINATOR;\n   STACK(1) = GOAL_SYMBOL;\n   NETRY, NF11, LEVEL, MAXLEVEL = 0;\n   EJECT_PAGE;\n   OUTPUT = 'SENTENTIAL FORM PRODUCTION:';\n   DOUBLE_SPACE;\n   IF CONTROL(BYTE('T')) THEN CALL PRINT_FORM;\n\n\n\n   /* NOW COMES THE BASIC ALGORITHM FOR GENERATING THE TABLES  */\n\n\nPRODUCTION_LOOP:\n   DO WHILE SP >= MP;  /* CYCLE THRU RIGHT PART OF PRODUCTION */\n      IF STACK(SP) > NT THEN   /* ONLY NON-TERMINALS CAN EXPAND */\n         DO;\n            NEW = FALSE;\n            I = TEXT(TP);\n            DO TOKEN = 1 TO NT;   /* CYCLE THRU TERMINAL HEADS */\n               IF IS_HEAD (I, TOKEN) THEN IF NEVER_BEEN_HERE THEN NEW = TRUE;\n            END;\n            IF NEW THEN\n               DO;  /* EXPAND STACK(SP) WITH ALL APPLICABLE RULES */\n                  P = INDEX(STACK(SP));\n                  DO WHILE LEFT_PART(P) = STACK(SP);\n                     CALL APPLY_PRODUCTION;\n                     GO TO PRODUCTION_LOOP;  /* NOW DOWN A LEVEL  */\n\n\n            CONTINUE:      /* AND NOW BACK UP A LEVEL  */\n                     P = P + 1;  /* MOVE ON TO NEXT PRODUCTION */\n                  END;\n               END;\n         END;\n      IF TP = TEXTLIMIT THEN CALL ERROR ('TEXT OVERFLOW');\n      ELSE TP = TP + 1;\n      TEXT(TP) = STACK(SP);  /* RUN THE COMPILER BACKWARDS  */\n      SP = SP - 1;           /* UNSTACKING AS YOU GO */\n   END;\n\n   /* FULLY EXPANDED AT THIS LEVEL */\n   CALL DIS_APPLY;   /* TO COME UP A LEVEL  */\n\n   IF LEVEL >= 0 THEN GO TO CONTINUE;\n\n   IF CONTROL(BYTE('T')) THEN DOUBLE_SPACE;\n   OUTPUT = 'F11 HAS ' || NF11 || ' ELEMENTS.';\n   OUTPUT = 'THE MAXIMUM DEPTH OF RECURSION WAS ' || MAXLEVEL || ' LEVELS.';\n   OUTPUT = NETRY || ' SENTENTIAL FORMS WERE EXAMINED.';\nEND PRODUCE;\n\nINDEX_F11:\n   PROCEDURE;\n   /* BUILD AN INDEX INTO F11 FOR EACH PRODUCTION  */\n   DECLARE (Y, YP, P) FIXED;\n\n   DO I = 1 TO NPR;\n      IND(I) = 0;\n      IND1(I) = -1;\n   END;\n\n   Y, YP = 0;\n   F11(NF11+1) = SHL(NSY+1, 16);  /* BOUNDARY CONDITION  */\n   DO I = 1 TO NF11+1;  /* CHECK EACH F11  */\n      IF F11(I) >= YP THEN\n         DO;      /* F11 FOR A NEW LEFT PART */\n            P = INDEX(Y);\n            DO WHILE LEFT_PART(P) = Y;    /* RECORD END FOR OLD LEFT PART */\n               IND1(P) = I - 1;\n               P = P + 1;\n            END;\n            Y = SHR(F11(I), 16);    /* NEW LEFT PART */\n            P = INDEX(Y);\n            DO WHILE LEFT_PART(P) = Y;    /* RECORD START FOR NEW LEFT PART */\n               IND(P) = I;\n               P = P + 1;\n            END;\n            YP = SHL(Y+1, 16);   /* TO COMPARE WITH TRIPLE */\n         END;\n   END;\nEND INDEX_F11;\n\nSORT_PRODUCTIONS:\n   PROCEDURE;    /* RE-NUMBER THE PRODUCTIONS IN AN OPTIMAL ORDER FOR C2  */\n   DO I = 1 TO NPR;  P_SAVE(I) = 0;  END;\n   P = 0;\n   DO I = 1 TO NPR;\n      J = RIGHT_HEAD(I);  /* CONVERT 1 - 4 PACKING TO 4 - 1 PACKING  */\n      M = PRODUCTION(I);\n      IF M = 0 THEN\n         DO;\n            M = J;\n            J = 0;\n            L = 7;\n         END;\n      ELSE L = 6;\n      TAIL(I) = M & \"FF\";\n      M = M & \"FFFFFF00\";\n      DO WHILE M \u00ac= 0;\n         K = SHR(M, 24);  M = SHL(M, 8);\n         IF K \u00ac= 0 THEN\n            DO;\n               J = SHL(J, 8) + K;\n               L = L - 1;\n            END;\n      END;\n      HEAD(I) = J;\n      /*  SORT ON:  1.  TAIL SYMBOL OF RIGHT PART\n                       2. LENGTH OF RIGHT PART\n                          3. NUMBER OF F11'S                 */\n      SORT#(I) = SHL(TAIL(I), 23) + SHL(L, 20) + IND1(I) - IND(I);\n      INDEX(I) = I;\n   END;  /* OF DO I  */\n   /* BUBBLE SORT OF PRODUCTIONS  */\n   K, L = NPR;\n   DO WHILE K <= L;\n      L = -1;\n      DO I = 2 TO K;\n         L = I - 1;\n         IF SORT#(L) > SORT#(I) THEN\n            DO;\n               J = SORT#(L);  SORT#(L) = SORT#(I);  SORT#(I) = J;\n               J = INDEX(L);  INDEX(L) = INDEX(I);  INDEX(I) = J;\n               K = L;\n            END;\n      END;\n   END;\n   INDEX(NPR+1) = 0;\nEND SORT_PRODUCTIONS;\n\nCOMPUTE_C1:\n   PROCEDURE;\n      DECLARE (CX, CTRIP, S1, S2, S3, TR, PR) FIXED;\n\n      CALL CLEAR_WORK;\n      NETRY, NTRIP, CTRIP = 0;\n      DO CX = 0 TO 2;      /* REPEAT BASIC LOOP 3 TIMES:\n                              1. COMPUTE PAIRS\n                                 2. COMPUTE TRIPLES FOR PAIR CONFLICTS\n                                    3. EMIT DIAGNOSTICS FOR TRIPLE CONFLICTS  */\n        DO P = 1 TO NPR;      /* STEP THROUGH THE PRODUCTIONS  */\n          DO I = IND(P) TO IND1(P);    /* STEP THROUGH THE EXPANSION TRIPLES  */\n            CALL EXPAND (F11(I), P);\n            DO J = 2 TO SP;      /* STEP THROUGH RIGHT PART OF PRODUCTION  */\n               K = VALUE(J\u00ac=SP);\n               S1 = STACK(J-1);\n               S2 = STACK(J);\n               L = STACK(J+1);\n               DO S3 = 1 TO NT;     /* STEP THROUGH THE HEADS OF STACK(J+1)  */\n                  IF IS_HEAD(L, S3) THEN\n                     DO CASE CX;\n\n                        /* CASE 0 -- ENTER PAIR  */\n                        CALL SET (S2, S3, K);\n\n                        /* CASE 1 -- IF PAIR CONFLICT THEN ENTER TRIPLE  */\n                        IF GET (S2, S3) = 3 THEN\n                           CALL ENTER (PACK (0, S1, S2, S3), K);\n\n                        /* CASE 2 -- IF TRIPLE CONFLICT EMIT DIAGNOSTIC  */\n                        DO;\n                           TR = PACK (0, S1, S2, S3);\n                           DO M = 0 TO CTRIP;\n                              IF SORT#(M) = TR THEN\n                                 CALL ENTER (PACK(M, P, STACK(1), STACK(SP+1)),\n                                    K);\n                           END;\n                        END;     /* OF CASE 2  */\n                     END;     /* OF DO CASE  */\n               END;     /* OF DO S3  */\n            END;     /* OF DO J  */\n          END;    /* OF DO I  */\n        END;      /* OF DO P  */\n         DO CASE CX;  /* CLEAN UP  */\n\n            /* CASE 0  */\n            DO;\n               DO I = 1 TO NT;      /* SPECIAL RELATIONS FOR TERMINATOR  */\n                  IF IS_HEAD (GOAL_SYMBOL, I) THEN\n                     CALL SET (TERMINATOR, I, VALUE(TRUE));\n               END;\n               CALL SET (GOAL_SYMBOL, TERMINATOR, VALUE(FALSE));\n               CALL PRINT_MATRIX ('C1 MATRIX FOR STACKING DECISION', 1);\n               CALL PRINT_TIME;\n            END;\n\n            /* CASE 1  */\n            DO;\n               CALL PRINT_TRIPLES ('C1 TRIPLES FOR STACKING DECISION');\n               IF COUNT(3) = 0 | ITERATION_COUNT > 1 THEN RETURN;\n               IF \u00ac CONTROL(BYTE('I')) THEN\n                  IF CONTROL(BYTE('P')) | CONTROL(BYTE('O')) THEN RETURN;\n               CALL PRINT_TIME;\n               DO I = 1 TO NTRIP;\n                  IF TV(I) = 3 THEN\n                     DO;\n                        SORT#(CTRIP) = TRIPLE(I);\n                        CTRIP = CTRIP + 1;\n                     END;\n               END;\n               CTRIP = CTRIP - 1;\n               NETRY, NTRIP = 0;\n               DOUBLE_SPACE;\n               OUTPUT = 'ANALYSIS OF (2,1) CONFLICTS:';\n            END;\n\n            /* CASE 2  */\n            DO;\n               J = 1;\n               DO M = 0 TO CTRIP;  /* STEP THROUGH CONFLICTS  */\n                  DO K = 0 TO 1;  /* STEP THROUGH TRUTH VALUES  */\n                     I = SORT#(M);\n                     OUTPUT = '';\n                     OUTPUT = '   THE TRIPLE  ' || V(SHR(I,16)) || ' ' ||\n                        V(SHR(I,8)&\"FF\") || ' ' || V(I&\"FF\") ||\n                        '  MUST HAVE THE VALUE ' || PRINT(VALUE(K)) ||\n                        ' FOR';\n                     OUTPUT = '';\n                     L = SHL(M+1, 24);\n                     I = J;\n                     S1 = 0;\n                     DO WHILE TRIPLE(I) < L & I <= NTRIP;\n                        IF (TV(I)&VALUE(K)) \u00ac= 0 THEN\n                           DO;\n                              TR = TRIPLE(I);\n                              P = SHR(TR, 16) & \"FF\";\n                              IF P \u00ac= S1 THEN CALL OUTPUT_PRODUCTION (P);\n                              S1 = P;\n                              OUTPUT = '         IN THE CONTEXT  ' ||\n                                 V(SHR(TR, 8)&\"FF\") || DOTS || V(TR&\"FF\");\n                           END;\n                        I = I + 1;\n                     END;     /* OF DO WHILE  */\n                  END;  /* OF DO K  */\n                  J = I;\n                  OUTPUT = '';\n               END;     /* OF DO M  */\n            END;\n         END;     /* OF DO CASE  */\n      END;     /* OF DO CX  */\nEND COMPUTE_C1;\n\nCOMPUTE_C2:\n   PROCEDURE;\n   /* DETERMINE WHAT (IF ANY) CONTEXT MUST BE CHECKED FOR EACH PRODUCTION\n      TO AUGMENT THE \"LONGEST MATCH\" RULE FOR THE PRODUCTION SELECTION\n      FUNCTION  C2      */\n\n      DECLARE (IJ, IK, TJ, TK, PJ, PK, JCT, KCT, JCL, JCR) FIXED,\n         PROPER BIT(1);\n      DECLARE CONTEXT_CLASS(3) CHARACTER INITIAL ('EITHER (0,1) OR (1,0)',\n         '(0,1)', '(1,0)', '(1,1)');\n\n      EJECT_PAGE;\n      OUTPUT = 'CONTEXT CHECK FOR EQUAL AND EMBEDDED RIGHT PARTS:';\n      DO I = 1 TO NPR;  MP_SAVE(I), P_SAVE(I) = 0;  END;\n      DO J = 1 TO NPR - 1;\n         IJ = INDEX(J);\n         K = J + 1;\n         IK = INDEX(K);\n         DO WHILE TAIL(IJ) = TAIL(IK);  /* CHECK ALL PRODUCTIONS WITH SAME TAI*/\n            TJ = HEAD(IJ);\n            TK = HEAD(IK);\n            DO WHILE (TJ & \"FF\") = (TK & \"FF\") & TJ \u00ac= 0;\n               TJ = SHR(TJ, 8);  TK = SHR(TK, 8);\n            END;\n            IF TK = 0 THEN\n               DO;      /* PRODUCTION IK IS INCLUDED IN IJ  */\n                  OUTPUT = '';\n                  OUTPUT = '   THERE ARE ' || IND1(IJ)-IND(IJ)+1 ||\n                     ' AND ' || IND1(IK)-IND(IK)+1 ||\n                     ' VALID CONTEXTS, RESPECTIVELY, FOR';\n                  CALL OUTPUT_PRODUCTION (IJ);\n                  CALL OUTPUT_PRODUCTION (IK);\n                  PROPER = TJ \u00ac= 0;  /* IK IS A PROPER SUBSTRING  */\n                  IF PROPER THEN\n                     DO;\n                        JCL = SHL(TJ & \"FF\", 8);\n                        DO I = 1 TO NSY;\n                           ON_RIGHT(I) = FALSE;\n                        END;\n                     END;\n                  ELSE P_SAVE(IJ) = 1;  /* REMEMBER THAT EQUAL RIGHT PARTS\n                                        MUST BE DISTINGUISHED SOMEHOW  */\n                  MP = 0;\n                  DO PJ = IND(IJ) TO IND1(IJ);\n                     JCT = F11(PJ) & \"FFFF\";\n                     JCR = JCT & \"00FF\";\n                     IF PROPER THEN JCT = JCL | JCR;\n                     ELSE JCL = JCT & \"FF00\";\n                     DO PK = IND(IK) TO IND1(IK);\n                        KCT = F11(PK) & \"FFFF\";\n                        IF KCT = JCT THEN\n                           DO;\n                              IF MP < 4 THEN CALL ERROR (\n'THESE PRODUCTIONS CANNOT BE DISTINGUISHED WITH (1,1) CONTEXT.');\n                              MP = MP | 4;\n                              IF PROPER THEN\n                                 DO;\n                                    IF \u00ac ON_RIGHT(JCR) THEN\n                                       OUTPUT = '   ' || V(LEFT_PART(IK)) ||\n                                          '  HAS  ' || V(SHR(JCL, 8)) ||\n                                          DOTS || V(JCR) || '  AS CONTEXT AND  '\n              || V(JCR) || '  IS VALID RIGHT CONTEXT FOR  ' || V(LEFT_PART(IJ));\n                                    ON_RIGHT(JCR) = TRUE;\n                                 END;\n                              ELSE OUTPUT =\n'   THEY HAVE EQUAL RIGHT PARTS AND THE COMMON CONTEXT  '\n                                 || V(SHR(JCL, 8)) || DOTS || V(JCR);\n                              CALL ADD_TROUBLE (SHR(KCT, 8), LEFT_PART(IK));\n                           END;\n                        ELSE IF (KCT & \"FF00\") = JCL THEN\n                           MP = MP | 1;  /* CAN'T TELL BY LEFT CONTEXT */\n                        ELSE IF (KCT & \"00FF\") = JCR THEN\n                           MP = MP | 2;  /* CAN'T TELL BY RIGHT CONTEXT */\n                     END;     /* PK  */\n                  END;        /* PJ  */\n                  IF MP < 4 THEN\n                     DO;      /* RESOLVABLE BY CONTEXT  */\n                        IF PROPER & (\u00acMP) THEN /* CONTEXT IMPLICIT IN LENGTH  */\n                           OUTPUT = '   THEY CAN BE RESOLVED BY LENGTH.';\n                        ELSE\n                           DO;\n                              MP_SAVE(IJ) = MP_SAVE(IJ) | MP;\n                              OUTPUT = '   THEY CAN BE RESOLVED BY ' ||\n                                 CONTEXT_CLASS(MP) || ' CONTEXT.';\n                           END;\n                     END;\n               END;     /* OF TK = 0  */\n            K = K + 1;\n            IK = INDEX(K);\n         END;     /* DO WHILE  */\n      END;     /* DO J  */\n      EJECT_PAGE;\n      OUTPUT = 'C2 PRODUCTION CHOICE FUNCTION:';\n      TK = 0;\n      DO J = 1 TO NPR;\n         IJ = INDEX(J);\n         TJ = TAIL(IJ);\n         IF TJ \u00ac= TK THEN\n            DO;\n               TK = TJ;\n               DOUBLE_SPACE;\n               OUTPUT = '   ' || V(TJ) ||\n'  AS STACK TOP WILL CAUSE PRODUCTIONS TO BE CHECKED IN THIS ORDER:';\n            END;\n         OUTPUT = '';\n         CALL OUTPUT_PRODUCTION (IJ);\n         DO CASE MP_SAVE(IJ) & 3;\n            /* CASE 0  */\n            IF P_SAVE(IJ) THEN GO TO CASE_1;  /* EQUAL RIGHT PART MUST CHECK */\n            ELSE OUTPUT = '         THERE WILL BE NO CONTEXT CHECK.';\n\n            /* CASE 1  */\n         CASE_1:\n            DO;\n               OUTPUT =\n'         (0,1) CONTEXT WILL BE CHECKED.  LEGAL RIGHT CONTEXT:';\n               DO I = 1 TO NSY;  ON_RIGHT(I) = FALSE;  END;\n               DO PJ = IND(IJ) TO IND1(IJ);\n                  JCR = F11(PJ) & \"FF\";\n                  IF \u00ac ON_RIGHT(JCR) THEN\n                     DO;\n                        ON_RIGHT(JCR) = TRUE;\n                        OUTPUT = X12 || DOTS || V(JCR);\n                     END;\n               END;\n            END;\n\n            /* CASE 2  */\n            DO;\n               OUTPUT =\n'         (1,0) CONTEXT WILL BE CHECKED.  LEGAL LEFT CONTEXT:';\n               DO I = 1 TO NSY;  ON_LEFT(I) = FALSE;  END;\n               DO PJ = IND(IJ) TO IND1(IJ);\n                  JCL = SHR(F11(PJ) & \"FF00\", 8);\n                  IF \u00ac ON_LEFT(JCL) THEN\n                     DO;\n                        ON_LEFT(JCL) = TRUE;\n                        OUTPUT = X12 || V(JCL) || DOTS;\n                     END;\n               END;\n            END;\n\n            /* CASE 3  */\n            DO;\n               OUTPUT =\n                  '         (1,1) CONTEXT WILL BE CHECKED.  LEGAL CONTEXT:';\n               DO PJ = IND(IJ) TO IND1(IJ);\n                  OUTPUT = X12 || V(SHR(F11(PJ) & \"FF00\", 8)) ||\n                     DOTS || V(F11(PJ) & \"FF\");\n               END;\n            END;\n         END;   /* OF CASE STATEMENT  */\n      END;  /* OF DO J  */\n  END COMPUTE_C2;\n\nPUNCH_PRODUCTIONS:\n   PROCEDURE;\n   DECLARE WIDE FIXED;\n   IF \u00ac(CONTROL(BYTE('P')) | CONTROL(BYTE('O'))) THEN RETURN;\n   IF CONTROL(BYTE('O')) THEN EJECT_PAGE;\n   OUTCARD = '  ';\n   CALL PUNCH_CARD ('DECLARE NSY LITERALLY ''' || NSY || ''', NT LITERALLY '''\n      || NT || ''';');\n   CALL BUILD_CARD ('DECLARE V(NSY) CHARACTER INITIAL (');\n   DO I = 0 TO NSY;\n      S = V(I);\n      T = '';\n      L = LENGTH(S) - 1;\n      DO WHILE BYTE(S, L) = BLANK;  L = L - 1;  END;\n      IF I > BASIC_NSY THEN\n         DO;      /* CREATED SYMBOL:  ADJUST PRINT NAME  */\n            L = L - 3;\n            S = SUBSTR(S, 1);\n         END;\n      DO J = 0 TO L;\n         IF SUBSTR(S, J, 1) = '''' THEN T = T || '''''';\n         ELSE T = T || SUBSTR(S, J, 1);\n      END;\n      IF I < NSY THEN CALL BUILD_CARD ('''' || T || ''',');\n      ELSE CALL PUNCH_CARD ('''' || T || ''');');\n   END;\n   L = LENGTH(V(NT));\n   CALL BUILD_CARD ('DECLARE V_INDEX(' || L || ') BIT(8) INITIAL (');\n   J = 1;\n   DO I = 1 TO L;\n      CALL BUILD_CARD (J || ',');\n      DO WHILE LENGTH(V(J)) = I;  J = J + 1;  END;\n   END;\n   CALL PUNCH_CARD (NT+1 || ');');\n   IF NT <= 15 THEN WIDE = 16;  /* FORCE LONG BIT STRINGS */\n   ELSE WIDE = NT;\n   I = 2*WIDE + 2;\n   CALL PUNCH_CARD ('DECLARE C1(NSY) BIT(' || I || ') INITIAL (');\n   DO I = 0 TO NSY;\n      T = '   \"(2)';\n      DO J = 0 TO WIDE;\n         IF J MOD 5 = 0 THEN\n            DO;\n               CALL BUILD_CARD (T);\n               T = '';\n            END;\n         T = T || GET (I, J);\n      END;\n      IF I < NSY THEN CALL PUNCH_CARD (T || '\",');\n      ELSE CALL PUNCH_CARD (T || '\");');\n   END;\n   K = COUNT(1) - 1;\n   IF K < 0 THEN\n      DO;\n         CALL PUNCH_CARD ('DECLARE NC1TRIPLES LITERALLY ''0'';');\n         CALL PUNCH_CARD ('DECLARE C1TRIPLES(0) FIXED;');\n      END;\n   ELSE\n      DO;\n         CALL PUNCH_CARD ('DECLARE NC1TRIPLES LITERALLY ''' || K || ''';');\n         CALL BUILD_CARD ('DECLARE C1TRIPLES(NC1TRIPLES) FIXED INITIAL (');\n         J = 0;\n         DO I = 1 TO NTRIP;\n            IF TV(I) = 1 THEN\n               DO;\n                  IF J = K THEN CALL PUNCH_CARD (TRIPLE(I) || ');');\n                  ELSE CALL BUILD_CARD (TRIPLE(I) || ',');\n                  J = J + 1;\n               END;\n         END;\n      END;\n   CALL BUILD_CARD ('DECLARE PRTB(' || NPR || ') FIXED INITIAL (0,');\n   DO I = 1 TO NPR - 1;\n      CALL BUILD_CARD (HEAD(INDEX(I)) || ',');\n   END;\n   CALL PUNCH_CARD (HEAD(INDEX(NPR)) || ');');\n   CALL BUILD_CARD ('DECLARE PRDTB(' || NPR || ') BIT(8) INITIAL (0,');\n   DO I = 1 TO NPR;\n      L = INDEX(I);\n      IF L > BASIC_NPR THEN L = 0;\n      IF I < NPR THEN CALL BUILD_CARD (L || ',');\n      ELSE CALL PUNCH_CARD (L || ');');\n   END;\n   CALL BUILD_CARD ('DECLARE HDTB(' || NPR || ') BIT(8) INITIAL (0,');\n   DO I = 1 TO NPR - 1;\n      CALL BUILD_CARD (LEFT_PART(INDEX(I)) || ',');\n   END;\n   CALL PUNCH_CARD (LEFT_PART(INDEX(NPR)) || ');');\n   CALL BUILD_CARD ('DECLARE PRLENGTH(' || NPR || ') BIT(8) INITIAL (0,');\n   DO I = 1 TO NPR;\n      J = 1;\n      K = HEAD(INDEX(I));\n      DO WHILE K \u00ac= 0;\n         J = J + 1;\n         K = SHR(K, 8);\n      END;\n      IF I = NPR THEN CALL PUNCH_CARD ( J || ');');\n      ELSE CALL BUILD_CARD (J || ',');\n   END;\n   CALL BUILD_CARD ('DECLARE CONTEXT_CASE(' || NPR || ') BIT(8) INITIAL (0,');\n   DO I = 1 TO NSY;  TP_SAVE(I) = 0;  END;\n   DO I = 1 TO NPR;   /* COMPUTE CONTEXT CASE */\n      J = MP_SAVE(INDEX(I));  /* SET UP IN COMPUTE_C2, USED HERE  */\n      K = LEFT_PART(INDEX(I));\n      DO CASE J;\n         /* CASE 0, CAN TELL BY EITHER LEFT OR RIGHT CONTEXT,\n         USE LENGTH TO DECIDE UNLESS EQUAL */\n         J = P_SAVE(INDEX(I));  /* USE THE CHEAP TEST, IF REQUIRED  */\n         /* CASE 1, USE C1 MATRIX FOR THIS CASE */\n         ;\n         /* CASE 2:  NEED LEFT CONTEXT TABLE */\n         TP_SAVE(K) = TP_SAVE(K) | 1;\n         /* CASE 3:  NEED BOTH LEFT AND RIGHT CONTEXT */\n         TP_SAVE(K) = TP_SAVE(K) | 2;\n      END;\n      TOKEN_SAVE(K) = INDEX(I);\n      IF I = NPR THEN CALL PUNCH_CARD (J || ');');\n      ELSE CALL BUILD_CARD (J || ',');\n   END;\n   J = 0;   /* CONSTRUCT CONTEXT TABLES FOR C2 */\n   DO I = NT + 1 TO NSY;  /* CYCLE THRU NON-TERMINALS */\n      SORT#(I) = J;\n      IF TP_SAVE(I) THEN\n         DO;\n            K = TOKEN_SAVE(I);\n            M = 0;\n            DO L = IND(K) TO IND1(K);\n               P = SHR(F11(L), 8) & \"FF\";\n               IF P \u00ac= M THEN\n                  DO;\n                     WORK(J), M = P;\n                     J = J + 1;  /* COUNT THE NUMBER OF ENTRIES */\n                  END;\n            END;\n         END;\n   END;\n   IF J = 0 THEN J = 1;  /* ASSURE NON-NEGATIVE UPPER BOUND FOR ARRAY */\n   CALL BUILD_CARD ('DECLARE LEFT_CONTEXT(' || J - 1 ||\n      ') BIT(8) INITIAL (');\n   DO I = 0 TO J - 2;\n      CALL BUILD_CARD (WORK(I) || ',');\n   END;\n   CALL PUNCH_CARD (WORK(J-1) || ');');\n   IF J > 255 THEN K = 16;  ELSE K = 8;  /* J < 256 ALLOWS 8 BIT PACKING */\n   CALL BUILD_CARD ('DECLARE LEFT_INDEX(' || NSY-NT || ') BIT(' || K\n      || ') INITIAL (');\n   DO I = NT + 1 TO NSY;\n      CALL BUILD_CARD (SORT#(I) || ',');\n   END;\n   CALL PUNCH_CARD (J || ');');\n   J = 0;\n   DO I = NT + 1 TO NSY;\n      SORT#(I) = J;  /* RECORD WHERE EACH NON-TERMINAL STARTS */\n      IF SHR(TP_SAVE(I), 1) THEN  /* NEED BOTH CONTEXTS */\n         DO;\n            K = TOKEN_SAVE(I);\n            DO L = IND(K) TO IND1(K);\n               TRIPLE(J) = F11(L) & \"FFFF\";\n               J = J + 1;\n            END;\n         END;\n   END;\n   IF J = 0 THEN J = 1;  /* ASSURE NON-NEGATIVE UPPER BOUND FOR ARRAY */\n   CALL BUILD_CARD ('DECLARE CONTEXT_TRIPLE(' || J-1 || ') FIXED INITIAL (');\n   DO I = 0 TO J - 2;\n      CALL BUILD_CARD (TRIPLE(I) || ',');\n   END;\n   CALL PUNCH_CARD (TRIPLE(J-1) || ');');\n   IF J > 255 THEN K = 16;  ELSE K = 8;  /* J < 256 ALLOWS 8 BIT PACKING */\n   CALL BUILD_CARD ('DECLARE TRIPLE_INDEX(' || NSY-NT || ') BIT(' || K\n      || ') INITIAL (');\n   DO I = NT + 1 TO NSY;   /* PUNCH MARGINAL INDEX TABLE */\n      CALL BUILD_CARD (SORT#(I) || ',');\n   END;\n   CALL PUNCH_CARD (J || ');');\n   DO I = 0 TO NSY;  P_SAVE(I) = 0;  END;\n   DO I = 1 TO NPR;       /* CYCLE THRU THE PRODUCTIONS */\n      P = TAIL(INDEX(I));  /* MARGINAL INDEX INTO PRODUCTION TABLE */\n      IF P_SAVE(P) = 0 THEN P_SAVE(P) = I;\n   END;\n   P_SAVE(NSY+1) = NPR + 1;  /* MARK THE END OF THE PRODUCTION TABLE */\n   DO J = 0 TO NSY - 1;  /* TAKE CARE OF SYMBOLS THAT NEVER END A PRODUCTION */\n      I = NSY - J;\n      IF P_SAVE(I) = 0 THEN P_SAVE(I) = P_SAVE(I+1);\n   END;\n   CALL BUILD_CARD ('DECLARE PR_INDEX(' || NSY || ') BIT(8) INITIAL (');\n   DO I = 1 TO NSY;\n      CALL BUILD_CARD (P_SAVE(I) || ',');\n   END;\n   CALL PUNCH_CARD (NPR+1 || ');');\n   CALL PRINT_TIME;\nEND PUNCH_PRODUCTIONS;\n\n   /* THE ACTUAL EXECUTION IS CONTROLLED FROM THIS LOOP  */\n\n   DO WHILE STACKING;\n      FIRST_TIME, LAST_TIME = TIME;\n      ITERATION_COUNT, TROUBLE_COUNT = 1;\n      DO WHILE TROUBLE_COUNT > 0;\n         IF ITERATION_COUNT = 1 THEN CALL READ_GRAMMAR;\n         ELSE CALL IMPROVE_GRAMMAR;\n         CALL PRINT_TIME;\n         CALL COMPUTE_HEADS;\n         CALL PRINT_TIME;\n         IF \u00ac AMBIGUOUS THEN\n            DO;\n               CALL PRODUCE;\n               CALL PRINT_TIME;\n               CALL INDEX_F11;\n               CALL SORT_PRODUCTIONS;\n               CALL COMPUTE_C1;\n               CALL PRINT_TIME;\n               CALL COMPUTE_C2;\n               CALL PRINT_TIME;\n               DOUBLE_SPACE;\n            END;\n         OUTPUT = 'ANALYSIS COMPLETE FOR ITERATION ' || ITERATION_COUNT;\n         IF ERROR_COUNT = 0 THEN OUTPUT = 'NO ERRORS WERE DETECTED.';\n         ELSE IF ERROR_COUNT = 1 THEN OUTPUT = '* ONE ERROR WAS DETECTED.';\n         ELSE IF ERROR_COUNT <= 20 THEN\n            OUTPUT = SUBSTR('********************', 0, ERROR_COUNT) || ' ' ||\n               ERROR_COUNT || ' ERRORS WERE DETECTED.';\n         ELSE OUTPUT = '******************** ... ' || ERROR_COUNT ||\n            ' ERRORS WERE DETECTED.';\n         ITERATION_COUNT = ITERATION_COUNT + 1;\n         IF AMBIGUOUS | \u00ac CONTROL(BYTE('I')) THEN TROUBLE_COUNT = 0;\n      END;\n      IF \u00ac AMBIGUOUS THEN CALL PUNCH_PRODUCTIONS;\n      IF CONTROL(BYTE('P')) THEN OUTPUT = 'PUNCHING COMPLETE.';\n   END;\nEOF EOF EOF EOF EOF EOF EOF EOF EOF EOF EOF EOF EOF EOF EOF EOF EOF EOF EOF EOF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROSE": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x11Y\\x03x\\x03x\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T11:59:00", "lines": 888, "newlines": 888, "modlines": 0, "user": "SOURCE"}, "text": "\n     THE XPL COMPILER GENERATOR SYSTEM\n\n          W. M. MCKEEMAN\n\n               INFORMATION AND COMPUTER SCIENCES\n               UNIVERSITY OF CALIFORNIA\n               SANTA CRUZ, CALIFORNIA\n\n          J. J. HORNING\n          D. B. WORTMAN\n\n               COMPUTER SCIENCE DEPARTMENT AND\n               COMPUTATION CENTER (CAMPUS FACILITY)\n               STANFORD UNIVERSITY\n               STANFORD, CALIFORNIA\n\n\n\n    THIS TAPE CONTAINS THE XPL COMPILER GENERATOR SYSTEM\nDEVELOPED AT THE STANFORD COMPUTATION CENTER, CAMPUS FACILITY,    1966-1969\nAND THE UNIVERSITY OF CALIFORNIA COMPUTATION CENTER, SANTA CRUZ,  1968-1969.\n\nA BRIEF DESCRIPTION OF THE XPL SYSTEM IS GIVEN IN:\n\n\n     W.M. MCKEEMAN, J.J. HORNING,  E.C. NELSON, AND D.B. WORTMAN\n     \"THE XPL COMPILER GENERATOR SYSTEM\"\n     PROCEEDINGS OF THE FALL JOINT COMPUTER CONFERENCE (DECEMBER 1968)\n\nA TEXTBOOK ON COMPILER WRITING WHICH COMPLETELY DOCUMENTS THE\nXPL SYSTEM WILL BE PUBLISHED BY PRENTICE HALL IN 1970,\nWITH THE TITLE \"A COMPILER GENERATOR\".\n\nTHE PROGRAMS ON THIS TAPE ASSUME 2311 DISKS FOR  STORAGE AND\nWILL WORK ON 2314 DISKS WITHOUT MODIFICATION.\n\nTHIS TAPE IS A STANDARD OS/360 9-TRACK, 800 BPI UNLABELED TAPE.\n\n\nTHE FILES ON THIS TAPE ARE:\n\n\n 1   PROSE   A DESCRIPTION OF THE CONTENTS OF THIS TAPE (YOU ARE READING IT) AND\n     SOME SAMPLE JOB CONTROL CARDS TO ILLUSTRATE THE USE OF THE COMPONENTS\n     ON THE TAPE UNDER OS/360.\n     (RECFM=FB,LRECL=80,BLKSIZE=2000)\n\n 2   XMON.SOURCE   THE OS ASSEMBLY LANGUAGE SOURCE CARDS FOR THE MACHINE\n     LANGUAGE INTERFACE BETWEEN COMPONENTS OF THE SYSTEM AND OS/360.\n     (RECFM=FB,LRECL=80,BLKSIZE=2000)\n\n 3   TRACE.SOURCE  THE OS ASSEMBLY LANGUAGE SOURCE CARDS FOR A TRACE ROUTINE\n     WHICH IS USED TO FOLLOW THE EXECUTION OF PROGRAMS WRITTEN IN XPL AND\n     RUN UNDER THE XMON MONITOR.  IT PRINTS ONE LINE FOR EVERY INSTRUCTION\n     EXECUTED AND THUS PRODUCES A DETAILED BUT VOLUMINOUS RECORD OF WHAT\n     THE XPL PROGRAM IS DOING.\n     (RECFM=FB,LRECL=80,BLKSIZE=2000)\n\n 4   REFORM.SOURCE  THE OS ASSEMBLY LANGUAGE SOURCE CARDS FOR A SMALL UTILITY\n     PROGRAM WHICH REFORMATS BINARY PROGRAMS FILES AS OUTPUT BY THE XCOM\n     COMPILER.  ITS MAIN USE IS TO MOVE BINARY PROGRAMS FROM ONE DEVICE TO\n     ANOTHER WITHOUT HAVING TO RECOMPILE.    (FOR EXAMPLE, MOVING FROM 2311\n     DISKS TO 2314 DISKS OR TO THE 2321 DATA CELL).\n     (RECFM=FB,LRECL=80,BLKSIZE=2000)\n\n 5   XCOM.SOURCE  THE XPL SOURCE CARDS FOR THE XCOM COMPILER.\n     (RECFM=FB,LRECL=80,BLKSIZE=2000)\n\n 6   XCOM.COMPILER  THE BINARY IMAGE OF THE XCOM COMPILER SUITABLE FOR LOADING\n     BY THE XCOM.MONITOR.  THIS FILE IS THE RESULT OF USING XCOM TO COMPILE\n     ITSELF FROM THE SOURCE CARDS IN FILE 5.\n     (RECFM=F,LRECL=3600,BLKSIZE=3600)\n\n 7   XCOM.SMALL.COMPILER   THE BINARY IMAGE OF A SPECIAL VERSION OF THE XCOM\n     COMPILER FOR PEOPLE WITH SMALL MACHINE PROBLEMS.  THE RESULT OF USING\n     THE ALTER PROGRAM TO CHANGE THE VALUE OF 'DISKBYTES' IN XCOM.SOURCE\n     TO 400 AND COMPILING THE RESULTANT SOURCE WITH XCOM.  SEE THE SECTION\n     BELOW ENTITLED \"COMMENTS FOR PEOPLE WITH SMALL CORE PROBLEMS\" FOR\n     INSTRUCTIONS IN THE USE OF THIS SPECIAL VERSION.\n     (RECFM=F,LRECL=3600,BLKSIZE=3600)\n\n 8   ANALYZER.SOURCE  THE XPL SOURCE CARDS FOR THE SYNTAX ANALYSIS PROGRAM.\n     (RECFM=FB,LRECL=80,BLKSIZE=2000)\n\n 9   SYNTAX.ANALYZER  THE BINARY IMAGE OF THE SYNTAX ANALYSIS PROGRAM SUITABLE\n     FOR LOADING BY XCOM.MONITOR. IT IS THE RESULT OF USING XCOM TO COMPILE\n     FILE 9.\n     (RECFM=F,LRECL=3600,BLKSIZE=3600)\n\n10   SKELETON.SOURCE  THE XPL SOURCE CARDS FOR THE SKELETAL COMPILER.\n     (RECFM=FB,LRECL=80,BLKSIZE=2000)\n\n11   ALTER.SOURCE  THE XPL SOURCE CARDS FOR A SMALL CARD FILE EDITING UTILITY\n     PROGRAM.  THIS PROGRAM IS USEFUL FOR MAINTAINING THE SOURCE FILES FOR\n     THE COMPILERS.  CONTROL CARDS FOR USING THIS PROGRAM ARE DESCRIBED\n     IN A COMMENT AT THE BEGINNING OF THIS SOURCE FILE.\n     (RECFM=FB,LRECL=80,BLKSIZE=2000)\n\n12   ALTER.PROGRAM  THE BINARY IMAGE OF THE ALTER PROGRAM SUITABLE FOR LOADING\n     BY XCOM.MONITOR.  IT IS THE RESULT OF USING XCOM TO COMPILE FILE 11.\n     (RECFM=F,LRECL=3600,BLKSIZE=3600).\n\n13   XPL.LIBRARY  A CARD FILE CONTAINING THE DYNAMIC STRING COMPACTIFICATION\n     PROCEDURE WHICH MUST BE INCLUDED WITH ALL XPL PROGRAMS.  (SEE THE\n     JCL EXAMPLES BELOW).\n     (RECFM=FB,LRECL=80,BLKSIZE=2000)\n\n14   XPL.BNF  CARDS CONTAINING THE BNF GRAMMAR FOR XPL EXPRESSED IN A FORM\n     SUITABLE FOR INPUT TO THE SYNTAX ANALYSIS PROGRAM\n     (RECFM=FB,LRECL=80,BLKSIZE=2000)\n\n\n\nABEND CODES RETURNED BY THE XPL SUBMONITOR\n\n\n     THE SUBMONITOR WILL RETURN THE FOLLOWING USER COMPLETION CODES IN THE\nEVENT OF ERRORS:\n\n      100      ERROR IN OPENING ONE OF THE FILES:  PROGRAM, SYSPRINT OR SYSIN\n\n      200      UNEXPECTED END OF FILE ENCOUNTERED WHILE READING IN THE\n               XPL PROGRAM FILE.\n\n      300      I/O ERROR (SYNAD ERROR) WHILE READING IN THE XPL PROGRAM FILE\n\n      400      XPL PROGRAM TO BE LOADED WILL NOT FIT IN THE AMOUNT OF\n               CORE AVAILABLE\n\n      500      THE XPL PROGRAM HAS CALLED THE SUBMONITOR WITH AN INVALID\n               REQUEST FOR SERVICE\n\n      800+I    I/O ERROR (SYNAD) ON OUTPUTI  (MAY BE UNABLE TO OPEN THE FILE)\n\n      900+I    REFERENCE TO OUTPUT(I) IN THE XPL PROGRAM SPECIFIES A\n               NONEXISTENT OUTPUT FILE\n\n     1000+I    I/O ERROR (SYNAD) IN INPUTI\n\n     1200+I    END OF FILE ERROR ON INPUTI  (THE XPL PROGRAM TRIED TO READ AFTER\n               THE SUBMONITOR HAD PASSED IT AN END OF FILE INDICATION FOR\n               INPUTI)\n\n     1400+I    THE XPL PROGRAM SPECIFIED A NONEXISTENT INPUT FILE:  INPUT(I)\n\n     2000+I    I/O ERROR (SYNAD) ON DIRECT ACCESS FILEI\n               (MAY BE UNABLE TO OPEN THE FILE)\n\n     2200+I    END OF FILE ERROR ON DIRECT ACCESS FILEI\n\n     4000      THE XPL PROGRAM REQUESTED TERMINATION AND A DUMP BY\n               EXECUTING THE STATEMENT:        CALL  EXIT ;\n\n\n\nPARAMETERS FOR THE SUBMONITOR  XPLSM\n\n\n     IN ORDER TO GIVE SOME CONTROL OVER THE OPERATING ENVIRONMENT\nSET UP BY THE XPLSM SUBMONITOR THE FOLLOWING PARAMETERS MAY BE USED\nTO SPECIFY IMPORTANT SYSTEM PARAMETERS.  THESE PARAMETERS ARE PASSED\nTHROUGH THE PARM FIELD ON THE OS EXEC CARD AS IN:\n\n //SAMPLE      EXEC  PGM=XPLSM,PARM='PARM1,PARM2'\n\nTHE VALID PARAMETERS AND THEIR MEANINGS ARE GIVEN BELOW\n\n\n     ALTER         INCREASES THE AMOUNT OF CORE GIVEN BACK TO OS/360\n                   TO WORK WITH SO THAT THERE SHOULD BE SUFFICIENT CORE SPACE\n                   TO ALLOW THE DYNAMIC OPENING OF INPUT AND OUTPUT FILES\n\n     DUMP          SPECIFIES THAT AN ABEND DUMP IS TO BE TAKEN IN THE EVENT\n                   OF SYNAD OR END OF FILE ERRORS\n\n     FILE=NNNN     SPECIFIES THAT THE RECORD LENGTH (LRECL) AND BLOCKSIZE\n                   (BLKSIZE) ON ALL DIRECT ACCESS FILES IS NNNN BYTES\n\n     FREE=NNNN     SPECIFIES THAT THE SUBMONITOR SHOULD GIVE NNNN BYTES\n                   OF CORE BACK TO OS\n\n     MAX=NNNNN     SETS THE MAXIMUM AMOUNT OF CORE REQUESTED BY THE\n                   SUBMONITOR FROM OS TO BE NNNNN BYTES\n\n     MIN=NNNN      SETS THE MINIMUM AMOUNT OF CORE REQUESTED BY THE SUBMONITOR\n                   FROM OS TO BE NNNN BYTES\n\n     TRACE         BEGIN EXECUTION OF THE PROGRAM IN TRACE MODE RATHER THAN\n                   ACTUAL EXECUTION.  EQUIVALENT TO PRECEEDING THE PROGRAM\n                   WITH A   CALL  TRACE;\n\n\n\n\n\n\nCOMMENTS FOR PEOPLE WITH SMALL (128K) CORE PROBLEMS\n\n\n   THE VERSION OF XCOM ON THE DISTRIBUTION TAPE TAKES ABOUT 95K BYTES FOR ITSELF\n+ 8K FOR THE SUBMONITOR AND TRACE PACKAGE + AN UNKNOWN AMOUNT FOR I/O BUFFERS\nAND ACCESS METHOD (BSAM & QSAM) SPACE AND DYNAMIC STRING STORAGE.\n\n   SEVERAL IMMEDIATE WAYS OF REDUCING THE AMOUNT OF CORE REQUIRED BY THE\nSYSTEM ARE:\n\n1  REMOVE THE TRACE PACKAGE AND REPLACE IT WITH A NULL SUBROUTINE. (SAVE 4K)\n\n2  USE UNBLOCKED SOURCE FILES IN ORDER TO REDUCE THE AMOUNT OF SPACE REQUIRED\n   FOR I/O BUFFERS\n\n3  REDUCE THE NUMBER OF BUFFERS SPECIFIED IN THE SUBMONITOR FOR SYSIN\n   AND SYSPRINT\n\n4  REDUCE THE SIZE OF THE CODE, DATA, AND STRING BUFFERS IN XCOM.  THIS\n   REQUIRES CHANGING THE BLKSIZE (FILEBYTS) IN THE SUBMONITOR AND CHANGING\n   THE VARIABLE DISKBYTES AND THE SIZE OF THE ARRAYS CODE, DATA, AND STRINGS\n   IN XCOM.  ONE ALTERNATIVE IS TO MAKE THE BUFFERS VERY SMALL\n   (SAY 400 BYTES).  THIS IN EFFECT TRADES CORE SPACE FOR DISK SPACE.\n   A SPECIAL VERSION OF  XCOM  WITH THIS MODIFICATION IS INCLUDED ON THIS\n   TAPE IN THE FILE  \"XCOM.SMALL.COMPILER\".\n      THE WAY IN WHICH RANDOM ACCESS I/O IS IMPLEMENTED IN THIS SYSTEM\n   DICTATES THAT ONLY ONE RECORD WILL BE WRITTEN PER DISK TRACK WHETHER\n   THERE IS ROOM FOR MORE RECORDS OR NOT.  SETTING THE BUFFER SIZE TO 400\n   BYTES WILL THUS CONSUME MANY DISK TRACKS FOR SCRATCH FILES.\n   THE WAY TO KEEP FROM CLOGGING UP YOUR DISKS WITH THESE INEFFICIENT FILES\n   IS TO FIRST COMPILE ONTO FILES WITH SMALL BLOCKSIZE AND THEN USE THE\n   ASSEMBLY LANGUAGE ROUTINE REFORMAT DESCRIBED BELOW TO BLOCK THE FILES\n   FOR MORE EFFICIENT DISK STORAGE.  SEE THE JCL EXAMPLE BELOW ENTITLED\n   \"EXAMPLE OF COMPILING WITH A LIMITED AMOUNT OF CORE AVAILABLE\".\n\n\n\n\n\n\nSAMPLE  JOB  CONTROL  STATEMENTS\n\n     THE JOB CONTROL PRESENTED BELOW IS FOR ILLUSTRATIVE PURPOSES ONLY.  IT IS\n     NOT SUPPOSED THAT IT WILL WORK AT EVERY INSTALLATION USING OS/360, BUT\n     IS OFFERED AS A GUIDE FOR CONSTRUCTION OF APPROPRIATE LOCAL JCL.\n     ALL PARAMETERS WHICH ARE TO BE SUPPLIED LOCALLY ARE DELIMITED BY < >\n     AND ARE HOPEFULLY SELF EXPLANITORY.\n     ANY CARD BELOW FLAGGED WITH AN * IN COLUMN ONE IS A COMMENT PROVIDED TO\n     CLARIFY SOME POINT\n\n     THE PROGRAMS AS RUN AT STANFORD MAKE SEVERAL ASSUMPTIONS ABOUT THE\n     ENVIRONMENT IN WHICH THEY RUN.  THESE ASSUMPTIONS WILL BE LISTED HERE\n     AS A WARNING TO THE USER THAT ALL MAY NOT BE AS SIMPLE AS IT SEEMS.\n\n  1  ALL DATA-SETS NEEDED BY THE SYSTEM ARE CATALOGED IN THE SYSTEM CATALOG\n     SO THAT ONLY THE DISP AND DSNAME PARAMETERS ARE NEEDED ON THE DD CARDS\n     TO IDENTIFY THE DATASETS.  IF THEY ARE NOT CATALOGED, VOLUME=SER=\n     AND UNIT= PARAMETERS MUST BE ADDED.\n\n  2  THE EXISTENCE OF SYSTEM SCRATCH DATASETS IS EXPLICITLY ASSUMED.\n     THESE DATASETS ARE NAMED SYS1.UT1, SYS1.UT2 AND SYS1.UT3.\n     IF SUCH SCRATCH DATASETS ARE NOT ALWAYS AVAILABLE, THEY MUST BE\n     DYNAMICALLY CREATED FOR EACH RUN USING THE PROPER JCL.\n\n  3  THE EXISTENCE OF THE STANDARD IBM CATALOGED PROCEDURES FOR THE ASSEMBLER\n     AND LINKAGE EDITOR IS EXPLICITLY ASSUMED.\n\n  4  THE SUBMONITOR PROGRAMS CONTAIN NO ASSEMBLED IN INFORMATION\n     ABOUT THE RECORD FORMAT, RECORD LENGTH, OR BLOCKSIZE OF THE\n     'INPUT' AND 'OUTPUT' FILES.  IT MAY BE NECESSARY TO PROVIDE THIS\n     INFORMATION ON DD CARDS WHEN CREATING NEW FILES OR USING\n     PREDEFINED SCRATCH FILES.  WHEN USING OLD FILES THE INFORMATION\n     SHOULD BE PICKED UP FROM THE VOLUME LABEL OR DATASET CONTROL BLOCK.\n\n  5  THE SUBMONITORS DO CONTAIN DEVICE DEPENDENT BLOCKSIZE\n     INFORMATION CONCERNING THE SCRATCH FILES.  IT MAY BE NECESSARY TO\n     OVERRIDE THIS INFORMATION USING THE 'FILE=' PARAMETER IF OTHER THAN\n     2311 DISKS ARE USED.  THE RECORD FORMAT ASSUMED FOR SCRATCH FILES\n     MAY BE CHANGED ONLY THROUGH REASSEMBLY OF THE SUBMONITOR\n\n  6  ONLY THE FILES PROGRAM, SYSPRINT, AND SYSIN ARE OPENED INITIALLY.  ALL\n     OTHER FILES ARE OPENED THE FIRST TIME THEY ARE USED.\n\n  7  IT IS ASSUMED THAT THE ASSEMBLIES OF XMON.SOURCE, TRACE.SOURCE, AND\n     REFORMAT AS SHOWN BELOW HAVE BEEN MADE, SO THAT THESE\n     LOAD MODULES MAY BE REFERENCED IN JOBLIB DD STATEMENTS.\n\n\n*\n*\n*    JOB WHICH CREATED THE DISTRIBUTION TAPE\n*\n*\n //DISTRIB     JOB   <ACCOUNTING INFORMATION ETC.>\n //            EXEC  PGM=IEHMOVE\n //SYSRES      DD    UNIT=2301,DISP=OLD,VOLUME=SER=SYSRES\n //TODD1       DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(1,NL),DSNAME=PROSE\n //TODD2       DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(2,NL),DSNAME=XMON.SOURCE\n //TODD3       DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(3,NL),DSNAME=TRACE.SOURCE\n //TODD4       DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(4,NL),DSNAME=REFORM.SOURCE\n //TODD5       DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(5,NL),DSNAME=XCOM.SOURCE\n //TODD6       DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,                                      X\n //             DCB=(RECFM=F,LRECL=3600,BLKSIZE=3600),                  X\n //             LABEL=(6,NL),DSNAME=XCOM.COMPILER\n //TODD7       DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,                                      X\n //             DCB=(RECFM=F,LRECL=3600,BLKSIZE=3600),                  X\n //             LABEL=(7,NL),DSNAME=XCOM.SMALL.COMPILER\n //TODD8       DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(8,NL),DSNAME=ANALYZER.SOURCE\n //TODD9       DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,                                      X\n //             DCB=(RECFM=F,LRECL=3600,BLKSIZE=3600),                  X\n //             LABEL=(9,NL),DSNAME=SYNTAX.ANALYZER\n //TODD10      DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(10,NL),DSNAME=SKELETON.SOURCE\n //TODD11      DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(11,NL),DSNAME=ALTER.SOURCE\n //TODD12      DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,                                      X\n //             DCB=(RECFM=F,LRECL=3600,BLKSIZE=3600),                  X\n //             LABEL=(12,NL),DSNAME=ALTER.PROGRAM\n //TODD13      DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(13,NL),DSNAME=XPL.LIBRARY\n //TODD114     DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(14,NL),DSNAME=XPL.BNF\n //DTAPE       DD    UNIT=2400,DISP=(OLD,PASS),VOLUME=SER=XPLDTP\n //SYSUT1      DD    UNIT=2314,DISP=OLD,VOLUME=REF=SYS1.UT1\n //SYSPRINT    DD    SYSOUT=A\n //SYSIN       DD    *\n        COPY    FROM=2400=(XPLDTP,1),TO=2400=(XPLSYS,1),TODD=TODD1,     X\n                DSNAME=PROSE\n        COPY    FROM=2400=(XPLDTP,2),TO=2400=(XPLSYS,2),TODD=TODD2,     X\n                DSNAME=XMON.SOURCE\n        COPY    FROM=2400=(XPLDTP,3),TO=2400=(XPLSYS,3),TODD=TODD3,     X\n                DSNAME=TRACE.SOURCE\n        COPY    FROM=2400=(XPLDTP,4),TO=2400=(XPLSYS,4),TODD=TODD4,     X\n                DSNAME=REFORM.SOURCE\n        COPY    FROM=2400=(XPLDTP,5),TO=2400=(XPLSYS,5),TODD=TODD5,     X\n                DSNAME=XCOM.SOURCE\n        COPY    FROM=2400=(XPLDTP,6),TO=2400=(XPLSYS,6),TODD=TODD6,     X\n                DSNAME=XCOM.COMPILER\n        COPY    FROM=2400=(XPLDTP,7),TO=2400=(XPLSYS,7),TODD=TODD7,     X\n                DSNAME=XCOM.SMALL.COMPILER\n        COPY    FROM=2400=(XPLDTP,8),TO=2400=(XPLSYS,8),TODD=TODD8,     X\n                DSNAME=ANALYZER.SOURCE\n        COPY    FROM=2400=(XPLDTP,9),TO=2400=(XPLSYS,9),TODD=TODD9,     X\n                DSNAME=SYNTAX.ANALYZER\n        COPY    FROM=2400=(XPLDTP,10),TO=2400=(XPLSYS,10),TODD=TODD10,  X\n                DSNAME=SKELETON.SOURCE\n        COPY    FROM=2400=(XPLDTP,11),TO=2400=(XPLSYS,11),TODD=TODD11,  X\n                DSNAME=ALTER.SOURCE\n        COPY    FROM=2400=(XPLDTP,12),TO=2400=(XPLSYS,12),TODD=TODD12,  X\n                DSNAME=ALTER.PROGRAM\n        COPY    FROM=2400=(XPLDTP,13),TO=2400=(XPLSYS,13),TODD=TODD13,  X\n                DSNAME=XPL.LIBRARY\n        COPY    FROM=2400=(XPLDTP,14),TO=2400=(XPLSYS,14),TODD=TODD14,  X\n                DSNAME=XPL.BNF\n /*\n //LISTPROS    EXEC  PGM=IEBPTPCH\n //SYSPRINT    DD    DUMMY\n //SYSUT1      DD    UNIT=2400,DISP=OLD,VOLUME=SER=XPLSYS,              X\n //             DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000),                   X\n //             LABEL=(1,NL),DSNAME=PROSE\n //SYSUT2      DD    SYSOUT=A\n //SYSIN       DD    *\n        PRINT   MAXFLDS=1\n        RECORD  FIELD=(80,1,,20)\n /*\n*\n*\n*              JOB TO COPY THE DISTRIBUTION TAPE TO A 2311 DISK PACK\n*\n*\n //UNDIST      JOB   <ACCOUNTING INFORMATION ETC.>\n //            EXEC  PGM=IEHMOVE\n //SYSRES      DD    <DEFINE SYSTEM RESIDENCE VOLUME>\n //SYSUT1      DD    <DEFINE SCRATCH FILE>\n //SYSPRINT    DD    SYSOUT=A\n //FROMDD1     DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(1,NL),DSNAME=PROSE\n //FROMDD2     DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(2,NL),DSNAME=XMON.SOURCE\n //FROMDD3     DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(3,NL),DSNAME=TRACE.SOURCE\n //FROMDD4     DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(4,NL),DSNAME=REFORM.SOURCE\n //FROMDD5     DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(5,NL),DSNAME=XCOM.SOURCE\n //FROMDD6     DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,                                      X\n //             DCB=(RECFM=F,LRECL=3600,BLKSIZE=3600),                  X\n //             LABEL=(6,NL),DSNAME=XCOM.COMPILER\n //FROMDD7     DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,                                      X\n //             DCB=(RECFM=F,LRECL=3600,BLKSIZE=3600),                  X\n //             LABEL=(7,NL),DSNAME=XCOM.SMALL.COMPILER\n //FROMDD8     DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(8,NL),DSNAME=ANALYZER.SOURCE\n //FROMDD9     DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,                                      X\n //             DCB=(RECFM=F,LRECL=3600,BLKSIZE=3600),                  X\n //             LABEL=(9,NL),DSNAME=SYNTAX.ANALYZER\n //FROMDD10    DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(10,NL),DSNAME=SKELETON.SOURCE\n //FROMDD11    DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(11,NL),DSNAME=ALTER.SOURCE\n //FROMDD12    DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,                                      X\n //             DCB=(RECFM=F,LRECL=3600,BLKSIZE=3600),                  X\n //             LABEL=(12,NL),DSNAME=ALTER.PROGRAM\n //FROMDD13    DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(13,NL),DSNAME=XPL.LIBRARY\n //FROMDD114   DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             VOLUME=SER=XPLSYS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000), X\n //             LABEL=(14,NL),DSNAME=XPL.BNF\n //URPACK      DD    UNIT=2311,DISP=OLD,VOLUME=SER=<SERIAL>\n //SYSIN       DD    *\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,1),FROMDD=FROMDD1,   X\n                DSNAME=PROSE\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,2),FROMDD=FROMDD2,   X\n                DSNAME=XMON.SOURCE\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,3),FROMDD=FROMDD3,   X\n                DSNAME=TRACE.SOURCE\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,4),FROMDD=FROMDD4,   X\n                DSNAME=REFORM.SOURCE\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,5),FROMDD=FROMDD5,   X\n                DSNAME=XCOM.SOURCE\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,6),FROMDD=FROMDD6,   X\n                DSNAME=XCOM.COMPILER\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,7),FROMDD=FROMDD7,   X\n                DSNAME=XCOM.SMALL.COMPILER\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,8),FROMDD=FROMDD8,   X\n                DSNAME=ANALYZER.SOURCE\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,9),FROMDD=FROMDD9,   X\n                DSNAME=SYNTAX.ANALYZER\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,10),FROMDD=FROMDD10, X\n                DSNAME=SKELETON.SOURCE\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,11),FROMDD=FROMDD11, X\n                DSNAME=ALTER.SOURCE\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,12),FROMDD=FROMDD12, X\n                DSNAME=ALTER.PROGRAM\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,13),FROMDD=FROMDD13, X\n                DSNAME=XPL.LIBRARY\n        COPY    TO=2311=<SERIAL>,FROM=2400=(XPLSYS,14),FROMDD=FROMDD14, X\n                DSNAME=XPL.BNF\n /*\n*\n*\n*\n*              EXAMPLE OF USING IEBPTPCH TO PRINT A FILE FROM\n*              THE DISTRIBUTION TAPE.\n*\n*\n //LIST        JOB   <ACCOUNTING INFORMATION>\n //LISTXCOM    EXEC  PGM=IEBPTPCH\n //SYSPRINT    DD    DUMMY\n //SYSUT1      DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000),                   X\n //             VOLUME=SER=XPLSYS,LABEL=(5,NL),DSNAME=XCOM.SOURCE\n //SYSUT2      DD    SYSOUT=A\n //SYSIN       DD    *\n        PRINT   MAXFLDS=1\n        RECORD  FIELD=(80,1,,20)\n /*\n*\n*\n*              JOB TO USE IEBPTPCH TO PUNCH A SOURCE FILE FROM THE\n*              DISTRIBUTION TAPE.\n*\n*\n //PUNCH       JOB   <ACCOUNTING INFORMATION>\n //PUNCHXSM    EXEC  PGM=IEBPTPCH\n //SYSPRINT    DD    DUMMY\n //SYSUT1      DD    UNIT=(2400,,DEFER),DISP=(OLD,PASS),                X\n //             DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000),                   X\n //             VOLUME=SER=XPLSYS,LABEL=(2,NL),DSNAME=XMON.SOURCE\n //SYSUT2      DD    UNIT=SYSCP\n //SYSIN       DD    *\n        PUNCH   MAXFLDS=1\n        RECORD  FIELD=(80,1,,)\n /*\n*\n*              JOB TO ASSEMBLE AND LINK EDIT XCOM.MONITOR\n*\n*                  NOTE THAT THESE ASSEMBLIES COULD ALSO BE MADE DIRECTLY\n*                  FROM THE DISTRIBUTION TAPE BY A PROPER DEFINITION\n*                  OF THE ASSEMBLER SYSIN.\n*\n*\n*\n //AXMON       JOB   <ACCOUNTING INFO>\n //            EXEC  ASMFC\n //ASM.SYSIN   DD    DISP=OLD,DSNAME=XMON.SOURCE\n //            EXEC  ASMFCL\n //ASM.SYSIN   DD    DISP=OLD,DSNAME=TRACE.SOURCE\n //LKED.SYSLMOD DD   UNIT=2311,DISP=(NEW,CATLG),VOLUME=SER=<SERIAL>,    X\n //             SPACE=(TRK,(8,2,1),RLSE),DSNAME=XCOM.MONITOR\n //LKED.SYSIN  DD    *\n        ENTRY   XPLSM\n        NAME    XPLSM(R)\n /*\n*\n*\n*              JOB TO ASSEMBLE AND LINK EDIT REFORMAT\n*\n*\n //ARFM        JOB   <ACCOUNTING INFO>\n //            EXEC  ASMFCL\n //ASM.SYSIN   DD    DISP=OLD,DSNAME=REFORM.SOURCE\n //LKED.SYSLMOD DD   UNIT=2311,DISP=(NEW,CATLG),VOLUME=SER=<SERIAL>,    X\n //             SPACE=(TRK,(4,1,1),RLSE),DSNAME=REFORMAT\n //LKED.SYSIN DD *\n        NAME    REFORM(R)\n /*\n*\n*\n*              JOB TO COMPILE XCOM USING ITSELF\n*\n*\n //CXC         JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=OLD,DSNAME=XCOM.MONITOR\n //            EXEC  PGM=XPLSM\n //PROGRAM     DD    DISP=OLD,DSNAME=XCOM.COMPILER\n*\n*              THE XCOM COMPILER WRITES OUT THE COMPILED PROGRAM ON THE\n*              DATASET DEFINED BY FILE1\n*\n //FILE1       DD    UNIT=2311,DISP=(NEW,KEEP),VOLUME=SER=<SERIAL>,     X\n //             SPACE=(TRK,(40,0),RLSE),DSNAME=XCOM.NEW\n //FILE2       DD    DISP=OLD,DSNAME=SYS1.UT1\n //FILE3       DD    DISP=OLD,DSNAME=SYS1.UT2\n*\n*              THE SOURCE TEXT ON INPUT2 (THE XPL LIBRARY) IS COMPILED\n*              BEFORE THE MAIN PROGRAM SOURCE ON SYSIN.\n*\n //INPUT2      DD    DISP=OLD,DSNAME=XPL.LIBRARY\n //SYSPRINT    DD    SYSOUT=A\n //SYSUDUMP    DD    SYSOUT=A\n //SYSIN       DD    DISP=OLD,DSNAME=XCOM.SOURCE\n*\n*\n*              EXAMPLE OF COMPILING WITH A LIMITED AMOUNT OF CORE STORAGE.\n*\n*\n //SMALL       JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=(OLD,PASS),DSNAME=XCOM.MONITOR\n //            DD    DISP=(OLD,PASS),DSNAME=REFORMAT\n //COMPILE     EXEC  PGM=XPLSM,PARM='FILE=400'\n*\n*              THE 'FREE=','MAX=' PARAMETERS MAY ALSO BE NEEDED.\n*\n //PROGRAM     DD    DISP=OLD,DSNAME=XCOM.SMALL.COMPILER\n*\n*              NOTE THAT A SPECIAL VERSION OF XCOM MUST BE USED\n*\n //FILE1       DD    DISP=(NEW,PASS),VOLUME=SER=<SERIAL>,UNIT=2311,     X\n //             SPACE=(TRK,(150,0),RLSE),DSNAME=TEMP\n //FILE2       DD    DISP=OLD,DSNAME=SYS1.UT1\n //FILE3       DD    DISP=OLD,DSNAME=SYS1.UT2\n*\n*              NOTE THAT THE SCRATCH FILES MUST BE LARGE TOO.\n*\n //INPUT2      DD    DISP=OLD,DSNAME=XPL.LIBRARY\n //SYSPRINT    DD    SYSOUT=A\n //SYSIN       DD    DISP=OLD,DSNAME=XCOM.SOURCE\n //REFORMAT    EXEC  PGM=REFORM\n //SYSUT1      DD    DISP=(OLD,DELETE),DSNAME=*.COMPILE.FILE1\n //SYSUT2      DD    DISP=OLD,DSNAME=XCOM.COMPILER,                     X\n //             DCB=(RECFM=F,LRECL=3600,BLKSIZE=3600)\n //SYSPRINT    DD    SYSOUT=A\n*\n*\n*              JOB TO COMPILE THE SYNTAX ANALYSIS PROGRAM\n*\n*\n //CANAL       JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=OLD,DSNAME=XCOM.MONITOR\n //            EXEC  PGM=XPLSM\n //PROGRAM     DD    DISP=OLD,DSNAME=XCOM.COMPILER\n //FILE1       DD    UNIT=2311,DISP=(NEW,KEEP),VOLUME=SER=<SERIAL>,     X\n //             SPACE=(TRK,(30,0),RLSE),DSNAME=ANALYZER.NEW\n //FILE2       DD    DISP=OLD,DSNAME=SYS1.UT1\n //FILE3       DD    DISP=OLD,DSNAME=SYS1.UT2\n //INPUT2      DD    DISP=OLD,DSNAME=XPL.LIBRARY\n //SYSUDUMP    DD    SYSOUT=A\n //SYSPRINT    DD    SYSOUT=A\n //SYSIN       DD    DISP=OLD,DSNAME=ANALYZER.SOURCE\n*\n*\n*              JOB TO COMPILE THE ALTER PROGRAM\n*\n*\n //CALT        JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=OLD,DSNAME=XCOM.MONITOR\n //            EXEC  PGM=XPLSM\n //PROGRAM     DD    DISP=OLD,DSNAME=XCOM.COMPILER\n //FILE1       DD    UNIT=2311,DISP=(NEW,KEEP),VOLUME=SER=<SERIAL>,     X\n //             SPACE=(TRK,(10,0),RLSE),DSNAME=ALTER.NEW\n //FILE2       DD    DISP=OLD,DSNAME=SYS1.UT1\n //FILE3       DD    DISP=OLD,DSNAME=SYS1.UT2\n //INPUT2      DD    DISP=OLD,DSNAME=XPL.LIBRARY\n //SYSUDUMP    DD    SYSOUT=A\n //SYSPRINT    DD    SYSOUT=A\n //SYSIN       DD    DISP=OLD,DSNAME=ALTER.SOURCE\n*\n*\n*              JOB WHICH USES REFORMAT TO MOVE THE XCOM COMPILER FROM\n*              A 2311 TO A 2314 DISK\n*\n*\n //MVXCM       JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=OLD,DSNAME=REFORMAT\n //            EXEC  PGM=REFORM\n*\n*              SYSUT1 IS THE INPUT FILE\n*              OUTPUT APPEARS ON SYSUT2\n*\n //SYSUT1      DD    DISP=OLD,DSNAME=XCOM.COMPILER\n //SYSUT2      DD    UNIT=2314,DISP=(NEW,KEEP),VOLUME=SER=<SERIAL>,     X\n //             DCB=(RECFM=F,LRECL=7294,BLKSIZE=7294),                  X\n //             SPACE=(TRK,(30,0),RLSE),DSNAME=XCOM.COMPILER\n //SYSPRINT    DD    SYSOUT=A\n*\n*\n*              JOB WHICH USES REFORMAT TO MOVE THE ALTER PROGRAM TO A\n*              2321 DATA CELL\n*\n*\n //MVALT       JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=OLD,DSNAME=REFORMAT\n //            EXEC  PGM=REFORM\n //SYSUT1      DD    DISP=OLD,DSNAME=ALTER.PROGRAM\n //SYSUT2      DD    UNIT=2321,DISP=(NEW,KEEP),VOLUME=SER=<SERIAL>,     X\n //             DCB=(RECFM=F,LRECL=2000,BLKSIZE=2000),                  X\n //             SPACE=(TRK,(4,0),RLSE),DSNAME=ALTER.PROGRAM\n //SYSPRINT    DD    SYSOUT=A\n*\n*\n*              JOB WHICH USES REFORMAT TO BLOCK THE XCOM BINARY\n*              FILE ON A 2314 USING TRACK OVERFLOW\n*\n*\n //RFM3        JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=OLD,DSNAME=REFORMAT\n //            EXEC  PGM=REFORM\n //SYSUT1      DD    DISP=OLD,DSNAME=XCOM.COMPILER\n //SYSUT2      DD    UNIT=2314,DISP=(NEW,KEEP),VOLUME=SER=<SERIAL>,     X\n //             DCB=(RECFM=FT,LRECL=32760,BLKSIZE=32760),               X\n //             SPACE=(TRK,(40,0),RLSE),DSNAME=XCOM.COMPILER\n //SYSPRINT    DD    SYSOUT=A\n*\n*\n*              JOB WHICH USES REFORMAT TO REBLOCK A FILE FROM THE\n*              DISTRIBUTION TAPE TO A 2321 DATA CELL\n*\n*\n //REFMTAPE    JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=OLD,DSNAME=REFORMAT\n //            EXEC  PGM=REFORM\n //SYSUT1 DD    UNIT=2400,DISP=(OLD,PASS),VOLUME=(PRIVATE,SER=XPLSYS),  X\n //             DCB=(RECFM=F,LRECL=3600,BLKSIZE=3600),                  X\n //             LABEL=(7,NL),DSNAME=XCOM.SMALL.COMPILER\n //SYSUT2      DD    UNIT=2321,DISP=(NEW,CATLG),VOLUME=SER=<SERIAL>,    X\n //             DCB=(RECFM=F,LRECL=2000,BLKSIZE=2000),                  X\n //             SPACE=(TRK,(60,0),RLSE),DSNAME=XCOM.SMALL.COMPILER\n //SYSPRINT    DD    SYSOUT=A\n*\n*\n*              JOB WHICH ALTERS XCOM.SOURCE AND CREATES A NEW SOURCE FILE\n*\n*\n //ALTX        JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=OLD,DSNAME=XCOM.MONITOR\n //            EXEC  PGM=XPLSM,PARM='ALTER'\n //PROGRAM     DD    DISP=OLD,DSNAME=ALTER.PROGRAM\n*\n*               ALTER INPUT IS FROM INPUT3 AND SYSIN.  OUTPUT\n*               IS ON OUTPUT3\n*\n //INPUT3      DD    DISP=OLD,DSNAME=XCOM.SOURCE\n //OUTPUT3     DD    UNIT=2311,DISP=(NEW,KEEP),VOLUME=SER=<SERIAL>,     X\n //             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3600),                   X\n //             SPACE=(TRK,(80,20),RLSE),DSNAME=XCOM.SOURCE2\n //SYSUDUMP    DD    SYSOUT=A\n //SYSPRINT    DD    SYSOUT=A\n //SYSIN       DD    *\n  < ALTER CONTROL CARDS (SEE ALTER SOURCE LISTING FOR A DESCRIPTION) >\n /*\n*\n*\n*              JOB WHICH USES ALTER TO CREATE A NEW FILE\n*\n*\n //CRAL        JOB   <ACCOUNTING INFO>\n //JOBLIB      DD    DISP=OLD,DSNAME=XCOM.MONITOR\n //            EXEC  PGM=XPLSM,PARM='FREE=16000'\n //PROGRAM     DD    DISP=OLD,DSNAME=ALTER.PROGRAM\n //INPUT3      DD    DUMMY\n //OUTPUT3     DD    UNIT=2314,DISP=(NEW,KEEP),VOLUME=SER=<SERIAL>,     X\n //             DCB=(RECFM=FB,LRECL=80,BLKSIZE=7280),                   X\n //             SPACE=(TRK,(40,20),RLSE),DSNAME=NEW.SOURCE\n //SYSUDUMP    DD    SYSOUT=A\n //SYSPRINT    DD    *\n //SYSIN       DD    *\n  < DECK OF CARDS TO BE PUT ON DISK >\n $$ EOF\n /*\n*\n*\n*              JOB WHICH USES ALTER TO REBLOCK A SOURCE FILE FROM ONE\n*              DEVICE TO ANOTHER\n*\n*\n //REBL        JOB   <ACCOUNTING INFO>\n //JOBLIB      DD    DISP=OLD,DSNAME=XCOM.MONITOR\n //            EXEC  PGM=XPLSM,PARM='FREE=20000'\n //PROGRAM     DD    DISP=OLD,DSNAME=ALTER.PROGRAM\n //INPUT3      DD    UNIT=2311,DISP=(OLD,PASS),VOLUME=SER=<SERIAL>,     X\n //             DSNAME=SOURCE1\n*\n*              INPUT COULD BE FROM A SOURCE FILE ON THE\n*              DISTRIBUTION TAPE.\n*\n //OUTPUT3     DD    UNIT=2321,DISP=(NEW,KEEP),VOLUME=SER=<SERIAL>,     X\n //             DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000),                   X\n //             SPACE=(TRK,(100,20),RLSE),DSNAME=SOURCE2\n //SYSUDUMP    DD    SYSOUT=A\n //SYSPRINT    DD    SYSOUT=A\n //SYSIN       DD    DUMMY\n*\n*\n*              JOB WHICH ALTERS AND THEN COMPILES XCOM\n*\n*\n //AXCOM       JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=(OLD,PASS),DSNAME=XCOM.MONITOR\n //ALT         EXEC  PGM=XPLSM,PARM='ALTER'\n //PROGRAM     DD    DISP=OLD,DSNAME=ALTER.PROGRAM\n //INPUT3      DD    DISP=OLD,DSNAME=XCOM.SOURCE1\n //OUTPUT3     DD    DISP=(OLD,PASS),DSNAME=XCOM.SOURCE2\n //SYSUDUMP    DD    SYSOUT=A\n //SYSPRINT    DD    SYSOUT=A\n //SYSIN       DD    *\n < ALTER CONTROL CARDS >\n /*\n //            EXEC  PGM=XPLSM\n //PROGRAM     DD    DISP=OLD,DSNAME=XCOM.COMPILER\n //FILE1       DD    DISP=OLD,DSNAME=XCOM.CMPLR2\n //FILE2       DD    DISP=OLD,DSNAME=SYS1.UT1\n //FILE3       DD    DISP=OLD,DSNAME=SYS1.UT2\n //INPUT2      DD    DISP=OLD,DSNAME=XPL.LIBRARY\n //SYSPRINT    DD    SYSOUT=A\n //SYSUDUMP    DD    SYSOUT=A\n //SYSIN       DD    DISP=OLD,DSNAME=*.ALT.OUTPUT3\n*\n*\n*              JOB WHICH ALTERS, COMPILES AND EXECUTES XCOM\n*\n*\n //ACXCOM      JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=OLD,DSNAME=XCOM.MONITOR\n //ALTER       EXEC  PGM=XPLSM,PARM='ALTER'\n //PROGRAM     DD    DISP=OLD,DSNAME=ALTER.PROGRAM\n //INPUT3      DD    DISP=OLD,DSNAME=XCOM.SOURCE1\n //OUTPUT3      DD   DISP=(OLD,PASS),DSNAME=XCOM.SOURCE2\n //SYSUDUMP    DD    SYSOUT=A\n //SYSPRINT    DD    SYSOUT=A\n //SYSIN       DD    *\n < ALTER CONTROL CARDS >\n /*\n //COMPILE      EXEC  PGM=XPLSM\n //PROGRAM     DD    DISP=OLD,DSNAME=XCOM.COMPILER\n //FILE1       DD    DISP=(OLD,PASS),DSNAME=XCOM.CMPLR2\n //FILE2       DD    DISP=OLD,DSNAME=SYS1.UT1\n //FILE3       DD    DISP=OLD,DSNAME=SYS1.UT2\n //INPUT2      DD    DISP=OLD,DSNAME=XPL.LIBRARY\n //SYSUDUMP    DD    SYSOUT=A\n //SYSPRINT    DD    SYSOUT=A\n //SYSIN       DD    DISP=OLD,DSNAME=*.ALTER.OUTPUT3\n //GO          EXEC  PGM=XPLSM\n //PROGRAM     DD    DISP=OLD,DSNAME=*.COMPILE.FILE1\n //FILE1       DD    DISP=OLD,DSNAME=SYS1.UT1\n //FILE2       DD    DISP=OLD,DSNAME=SYS1.UT2\n //FILE3       DD    DISP=OLD,DSNAME=SYS1.UT3\n //INPUT2      DD    DISP=OLD,DSNAME=XPL.LIBRARY\n //SYSUDUMP    DD    SYSOUT=A\n //SYSPRINT    DD    SYSOUT=A\n //SYSIN       DD    *\n\n      /* XPL PROGRAM TO BE COMPILED  */\n     ;\n\n /*\n*\n*\n*\n*              JOB WHICH USES THE SYNTAX ANALYZER TO PRODUCE NEW TABLES\n*              FOR XCOM.\n*\n*\n //TABLES      JOB   <ACCOUNTING INFORMATION>\n //JOBLIB      DD    DISP=OLD,DSNAME=XCOM.MONITOR\n //            EXEC  PGM=XPLSM\n //PROGRAM     DD    DISP=OLD,DSNAME=SYNTAX.ANALYZER\n //SYSPUNCH    DD    UNIT=SYSCP,DCB=(RECFM=F,LRECL=80,BLKSIZE=80)\n*\n*              PUNCHED CARD OUTPUT(2) = SYSPUNCH\n*\n //SYSUDUMP    DD    SYSOUT=A\n //SYSPRINT    DD    SYSOUT=A\n //SYSIN       DD    DISP=OLD,DSNAME=XPL.BNF\n*\n*\n*              EXAMPLES OF USEFUL CATALOGUED PROCEDURES FOR THE XPL SYSTEM\n*              (USE OF AN APPROPRIATE JOBLIB CARDS IS ASSUMED).\n*\n*\n*    XPLC      COMPILE AN XPL PROGRAM\n*\n*\n //XPL    EXEC  PGM=XPLSM\n //PROGRAM DD   DISP=OLD,DSNAME=XCOM.COMPILER\n //FILE1  DD    DISP=OLD,DSNAME=SYS1.UT1\n //FILE2  DD    DISP=OLD,DSNAME=SYS1.UT2\n //FILE3  DD    DISP=OLD,DSNAME=SYS1.UT3\n //INPUT2 DD    DISP=OLD,DSNAME=XPL.LIBRARY\n //SYSPRINT DD  SYSOUT=A\n //SYSUDUMP DD  SYSOUT=A\n*\n*    XPLCG     COMPILE AND EXECUTE AN XPL PROGRAM\n*\n //XPL    EXEC  PGM=XPLSM\n //PROGRAM DD   DISP=OLD,DSNAME=XCOM.COMPILER\n //FILE1  DD    DISP=(OLD,PASS),DSNAME=SYS1.UT1\n //FILE2  DD    DISP=OLD,DSNAME=SYS1.UT2\n //FILE3  DD    DISP=OLD,DSNAME=SYS1.UT3\n //INPUT2 DD    DISP=OLD,DSNAME=XPL.LIBRARY\n //SYSPRINT DD  SYSOUT=A\n //SYSUDUMP DD  SYSOUT=A\n //GO     EXEC  PGM=XPLSM\n //PROGRAM DD   DISP=OLD,DSNAME=*.XPL.FILE1\n //FILE1  DD    DISP=OLD,DSNAME=SYS1.UT1\n //FILE2  DD    DISP=OLD,DSNAME=SYS1.UT2\n //FILE3  DD    DISP=OLD,DSNAME=SYS1.UT3\n //SYSPRINT DD  SYSOUT=A\n //SYSPUNCH DD  UNIT=SYSCP\n //SYSUDUMP DD  SYSOUT=A\n*\n*    XPLG      EXECUTE A PREVIOUSLY COMPILED XPL PROGRAM\n*\n //GO     EXEC  PGM=XPLSM\n //FILE1  DD    DISP=OLD,DSNAME=SYS1.UT1\n //FILE2  DD    DISP=OLD,DSNAME=SYS1.UT2\n //FILE3  DD    DISP=OLD,DSNAME=SYS1.UT3\n //SYSPRINT DD  SYSOUT=A\n //SYSPUNCH DD  UNIT=SYSCP\n //SYSUDUMP DD  SYSOUT=A\n*\n*    ANALYZE   EXECUTE THE SYNTAX ANALYSIS PROGRAM\n*\n //ANALYZE EXEC PGM=XPLSM\n //PROGRAM DD   DISP=OLD,DSNAME=SYNTAX.ANALYZER\n //SYSPUNCH DD  UNIT=SYSCP\n //SYSPRINT DD  SYSOUT=A\n //SYSUDUMP DD  SYSOUT=A\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REFORM": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x11Y\\x01\\x94\\x01\\x94\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T11:59:00", "lines": 404, "newlines": 404, "modlines": 0, "user": "SOURCE"}, "text": "REFM     TITLE '      PROGRAM TO REFORMAT XPLSM PROGRAM FILES '\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*              THIS PROGRAM REFORMATS PROGRAM FILE GENERATED BY THE   *\n*              XCOM COMPILER TO ALLOW PROGRAM LOADING FROM DIFFERENT  *\n*              DIRECT ACCESS DEVICES.  ONE ADVATNTAGE IS THE          *\n*              POSSIBILITY OF USING EXTREMELY FAST DEVICES SUCH AS    *\n*              2301 DRUMS FOR COMPILER RESIDENCE WHILE USING SMALL    *\n*              SLOW DISKS LIKE 2311'S FOR SCRATCH DURING THE COMPILER *\n*              GENERATION PROCESS.                                    *\n*                                                                     *\n*              THE PRINCIPLE EFFECT OF THIS PROGRAM IS TO COPY A      *\n*              STANDARD FORMAT FILE FROM THE DATASET 'SYSUT1' TO THE  *\n*              DATASET 'SYSUT2'.  THE DD CARDS FOR BOTH DATA SETS     *\n*              MUST SPECIFY  RECORD LENGTH AND RECORD FORMAT          *\n*                                                                     *\n*                                                                     *\n*              A SIDE EFFECT OF THIS PROGRAM IS TO REBUILD THE FILE   *\n*              CONTROL INFORMATION WHICH IS AT THE HEAD OF THE        *\n*              PROGRAM FILE.                                          *\n*                                                                     *\n*                                                                     *\n*                                      DAVID B. WORTMAN               *\n*                                      STANFORD UNIVERSITY            *\n*                                      MARCH  1969                    *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n         SPACE 5\nREFORM   CSECT               ENTRY POINT\n         USING *,15\n         SPACE 1\nREFORMAT SAVE  (14,12),T,*   SAVE REGISTERS\n         ST    13,SAVE+4\n         LA    15,SAVE\n         ST    15,8(,13)\n         LR    13,15\n         USING SAVE,13\n         DROP  15\n         B     BEGIN\n         SPACE 5\nSAVE     DC    18F'0'        OS SAVE AREA\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*              HEX TO EBCDIC  CONVERSION  ROUTINE                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         USING *,15\nHEXTOEBC ST    0,HEXTABLE+16\n         L     1,HEXTABLE-4\n         UNPK  HEXTABLE+16(9),HEXTABLE+16(5)\n         TR    HEXTABLE+16(8),0(1)\n         LM    0,1,HEXTABLE+16\n         BR    14\n         DROP  15\n         DC    A(HEXTABLE-240)\nHEXTABLE DC    CL25'0123456789ABCDEF'\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              PRIMITIVE ERROR  ROUTINES                              *\n*                                                                     *\n*                                                                     *\n*              ABEND  CODES  ISSUED  IN THE EVENT OF ERRORS           *\n*                                                                     *\n*        100   EOD ERROR ON SYSUT1                                    *\n*                                                                     *\n*        200   SYNAD ERROR ON SYSUT1                                  *\n*                                                                     *\n*        300   SYNAD ERROR ON SYSUT2                                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nEODUT1   STM   0,15,ABEREGS  SAVE ALL REGISTERS\n         ABEND 100,DUMP\n         SPACE 2\nSYNDUT1  STM   0,15,ABEREGS  SAVE ALL REGISTERS\n         ABEND 200,DUMP\n         SPACE 2\nSYNDUT2  STM   0,15,ABEREGS  SAVE ALL REGISTERS\n         ABEND 300,DUMP\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*              ROUTINE TO PRINT THE FILE CONTROL BLOCKS IN HEX        *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPCTRL    ST    14,PSV\n         L     15,AHEX\n         L     2,ACORE\n         USING FILECTRL,2\n         L     0,BYTSCODE\n         BALR  14,15\n         STM   0,1,CT1\n         L     0,BYTSDATA\n         BALR  14,15\n         STM   0,1,CT2\n         L     0,BLKSCODE\n         BALR  14,15\n         STM   0,1,CT3\n         L     0,BLKSDATA\n         BALR  14,15\n         STM   0,1,CT4\n         L     0,BYTSBLK\n         BALR  14,15\n         STM   0,1,CT5\n         L     0,BYTSFULL\n         BALR  14,15\n         STM   0,1,CT6\n         L     0,DATABYTS\n         BALR  14,15\n         STM   0,1,CT7\n         DROP  2\n         SPACE 1\n         PUT   SYSPRINT,CMSG\n         L   14,PSV\n         BR    14\n*\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              BEGIN EXECUTION HERE BY OPENING ALL FILES AND          *\n*              OBTAINING AS MUCH CORE AS POSSIBLE FOR A WORK          *\n*              AREA.                                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBEGIN    OPEN  (SYSUT1,(INPUT),SYSUT2,(OUTPUT),SYSPRINT,(OUTPUT))\n         SPACE 1\n         GETMAIN VU,LA=COREREQ,A=ACORE\n         SPACE 1\n         LM    1,2,ACORE\n         AR    1,2\n         S     1,F4096\n         ST    1,CORETOP\n         S     2,F4096\n         ST    2,CORESIZE\n         L     0,F4096\n         SPACE 1\n         FREEMAIN R,LV=(0),A=(1)  GIVE OS BACK SOME CORE TO WORK WITH\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              READ IN THE CODE BLOCKS OF THE BINARY XPL PROGRAM      *\n*              ON SYSUT1                                              *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         L     2,ACORE       BUFFER ADDRESS\n         LR    8,2           SAVE ADDRESS\n         USING FILECTRL,8\n         SPACE 1\n         READ  DECB1,SF,SYSUT1,(2),'S'  READ IN 1ST BLOCK OF CODE\n         SPACE 1\n         CHECK DECB1\n         SPACE 1\n         MVC   CTP(3),OLDM\n         BAL   14,PCTRL\n         L     5,BLKSCODE    NUMBER OF BLOCKS OF CODE\n         L     3,BYTSBLK     BLOCK SIZE\n         BCT   5,RD1         READ MORE CODE BLOCKS IF ANY\n         B     CODEIN        ONLY ONE BLOCK\n         SPACE 1\nRD1      AR    2,3\n         SPACE 1\nRCODE    READ  DECB1,SF,,(2),,MF=E\n         SPACE 1\n         CHECK DECB1\n         SPACE 1\n         AR    2,3\n         BCT   5,RCODE\n         SR    2,3\n         SPACE 1\nCODEIN   A     2,BYTSFULL\n         ST    2,DATADR\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*              COMPUTE THE NEW FILE CONTROL BLOCK                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         MVC   OLDDBL(4),BLKSDATA\n         MVC   OLDBBL(4),BYTSBLK   SAVE PARTS OF OLD BLOCK\n         LA    7,SYSUT2\n         USING IHADCB,7\n         MVC   BYTSBLK+2(2),DCBLRECL   MOVE IN BLOCK SIZE\n         L     0,BYTSCODE    NUMBER OF BYTES OF CODE\n         S     0,OLDBBL      -BLOCK_SIZE\n         A     0,BYTSFULL    +BYTES IN LAST BLOCK\n         SRDA  0,32\n         D     0,BYTSBLK     COMPUTE NEW NUMBER OF BLOCKS\n         LTR   0,0\n         BZ    LD1A\n         LA    1,1(,1)\n         B     LD1B\nLD1A     L     0,BYTSBLK\nLD1B     ST    0,BYTSFULL\n         ST    1,BLKSCODE\n         SR    0,0\n         M     0,BYTSBLK\n         ST    1,BYTSCODE\n         L     0,BYTSDATA\n         S     0,DATABYTS    - BLOCK_SIZE\n         A     0,DATABYTS    + BYTES IN LAST BLOCK\n         SRDA  0,32\n         D     0,BYTSBLK\n         LTR   0,0\n         BZ    LD2A\n         LA    1,1(,1)\n         B     LD2B\nLD2A     L     0,BYTSBLK\nLD2B     ST    0,DATABYTS     # OF BYTES USED IN LAST DATA BLOCK\n         ST    1,BLKSDATA\n         SR    0,0\n         M     0,BYTSBLK\n         ST    1,BYTSDATA\n         MVC   NEWBBL(4),BYTSBLK\n         MVC   NEWDBL(4),BLKSDATA\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*              WRITE OUT THE CODE BLOCKS IN THE NEW FORMAT            *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         MVC   CTP(3),NEWM\n         BAL   14,PCTRL\n         SPACE 1\n         L     2,ACORE\n         L     3,NEWBBL\n         L     5,BLKSCODE\n         SPACE 1\nWCODE    WRITE DECB2,SF,SYSUT2,(2),'S'\n         SPACE 1\n         CHECK DECB2\n         AR    2,3\n         BCT   5,WCODE\n         SPACE 1\n         L     5,OLDDBL      NUMBER OF BLOCKS ON SYSUT1\n         L     2,ACORE\n         L     3,OLDBBL      BLOCKSIZE ON SYSUT1\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              READ IN THE DATA BLOCKS FOR THE XPL BINARY             *\n*              PROGRAM ON SYSUT1                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nRDATA    READ  DECB1,SF,,(2),,MF=E\n         SPACE 1\n         CHECK DECB1\n         SPACE 1\n         AR    2,3\n         BCT   5,RDATA\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              WRITE OUT THE DATA BLOCKS IN THE NEW FORMAT            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     2,ACORE\n         L     3,NEWBBL\n         L     5,NEWDBL\n         SPACE 1\nWDATA    WRITE DECB2,SF,,(2),,MF=E\n         SPACE 1\n         CHECK DECB2\n         SPACE 1\n         AR    2,3\n         BCT   5,WDATA\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              FREE MEMORY, CLOSE ALL FILES AND RETURN TO OS/360      *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         L     1,ACORE\n         L     0,CORESIZE\n         FREEMAIN R,LV=(0),A=(1)   GIVE CORE BACK TO OS\n         SPACE 1\n         PUT   SYSPRINT,DONEM\n         SPACE 1\n         CLOSE (SYSUT1,,SYSUT2,,SYSPRINT,)\n         SPACE 1\n         L     13,SAVE+4\n         RETURN (14,12)\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*              DATA AREA                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nCOREREQ  DC    F'65768'      MINIMUM CORE REQUEST\n         DC    F'1000000'    MAXIMUM CORE REQUESTED\nACORE    DC    F'0'          ADDRESS OF CORE OBTAINED HERE\nCORESIZE DC    F'0'\nCORETOP  DC    F'0'\nDATADR   DC    F'0'\nF4096    DC    F'4096'\nOLDBBL   DC    F'0'\nOLDDBL   DC    F'0'\nNEWBBL   DC    F'0'\nNEWDBL   DC    F'0'\nAHEX     DC    A(HEXTOEBC)\nABEREGS  DS    16F           SAVE REGISTERS HERE BEFORE ABENDING\n         PRINT NOGEN\n         DS    0F\nCMSG     DC    CL132'    XXX  FILE  CONTROL  BLOCK'\nCTP      EQU   CMSG+4\nCT1      EQU   CMSG+36\nCT2      EQU   CMSG+48\nCT3      EQU   CMSG+60\nCT4      EQU   CMSG+72\nCT5      EQU   CMSG+84\nCT6      EQU   CMSG+96\nCT7      EQU   CMSG+108\nDONEM    DC    CL132'    UTILITY  END'\nNEWM     DC    CL3'NEW'\nOLDM     DC    CL3'OLD'\nPSV      DC    F'0'\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              DATA  CONTROL  BLOCKS  FOR  SYSUT1  AND  SYSUT2        *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYSUT1   DCB   DSORG=PS,                                               X\n               MACRF=R,                                                X\n               DDNAME=SYSUT1,                                          X\n               DEVD=DA,                                                X\n               EODAD=EODUT1,                                           X\n               SYNAD=SYNDUT1\n         SPACE 2\nSYSUT2   DCB   DSORG=PS,                                               X\n               MACRF=W,                                                X\n               DDNAME=SYSUT2,                                          X\n               DEVD=DA,                                                X\n               SYNAD=SYNDUT2\n         SPACE 2\nSYSPRINT DCB   DSORG=PS,                                               X\n               DEVD=DA,                                                X\n               DDNAME=SYSPRINT,                                        X\n               MACRF=PM,                                               X\n               RECFM=FA,                                               X\n               LRECL=133,                                              X\n               BUFNO=2\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*              DSECT WHICH DEFINES THE FORMAT OF THE FILE CONTROL     *\n*              BLOCK WHICH IS AT THE HEAD OF ALL XPL PROGRAMS         *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nFILECTRL DSECT\n         SPACE 1\nBYTSCODE DS    1F            NUMBER OF BYTES OF CODE\n         SPACE 1\nBYTSDATA DS    1F            NUMBER OF BYTES OF DATA\n         SPACE 1\nBLKSCODE DS    1F            NUMBER OF BLOCKS OF CODE\n         SPACE 1\nBLKSDATA DS    1F            NUMBER OF BLOCKS OF DATA\n         SPACE 1\nBYTSBLK  DS    1F            BLOCK LENGTH IN BYTES\n         SPACE 1\nBYTSFULL DS    1F            NUMBER OF BYTES ACTUALLY USED IN THE LAST\n*                            BLOCK OF CODE\n         SPACE 1\nDATABYTS DS    1F            NUMBER OF BYTES ACTUALLY USED IN THE LAST\n*                            BLOCK OF DATA\n         SPACE 5\n         DCBD  DSORG=LR      DCBLRECL  ONLY\n         SPACE 5\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SKELETON": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x11Y\\x03B\\x03B\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T11:59:00", "lines": 834, "newlines": 834, "modlines": 0, "user": "SOURCE"}, "text": " /*   SKELETON\n                THE PROTO-COMPILER OF THE XPL SYSTEM\n\n\nW. M. MCKEEMAN         J. J. HORNING           D. B. WORTMAN\n\nINFORMATION &          COMPUTER SCIENCE        COMPUTER SCIENCE\nCOMPUTER SCIENCE,      DEPARTMENT,             DEPARTMENT,\n\nUNIVERSITY OF          STANFORD                STANFORD\nCALIFORNIA AT          UNIVERSITY,             UNIVERSITY,\n\nSANTA CRUZ,            STANFORD,               STANFORD,\nCALIFORNIA             CALIFORNIA              CALIFORNIA\n95060                  94305                   94305\n\nDEVELOPED AT THE STANFORD COMPUTATION CENTER, CAMPUS FACILITY,   1966-69\nAND THE UNIVERSITY OF CALIFORNIA COMPUTATION CENTER, SANTA CRUZ, 1968-69.\n\nDISTRIBUTED THROUGH THE SHARE ORGANIZATION.\nTHIS VERSION OF SKELETON IS A SYNTAX CHECKER FOR THE FOLLOWING GRAMMAR:\n\n<PROGRAM>  ::=  <STATEMENT LIST>\n\n<STATEMENT LIST>  ::=  <STATEMENT>\n                    |  <STATEMENT LIST> <STATEMENT>\n\n<STATEMENT>  ::=  <ASSIGNMENT> ;\n\n<ASSIGNMENT>  ::=  <VARIABLE> = <EXPRESSION>\n\n<EXPRESSION>  ::=  <ARITH EXPRESSION>\n                |  <IF CLAUSE> THEN <EXPRESSION> ELSE <EXPRESSION>\n\n<IF CLAUSE>  ::=  IF <LOG EXPRESSION>\n\n<LOG EXPRESSION>  ::=  TRUE\n                    |  FALSE\n                    |  <EXPRESSION> <RELATION> <EXPRESSION>\n                    |  <IF CLAUSE> THEN <LOG EXPRESSION> ELSE <LOG EXPRESSION>\n\n<RELATION>  ::=  =\n              |  <\n              |  >\n\n<ARITH EXPRESSION>  ::=  <TERM>\n                      |  <ARITH EXPRESSION> + <TERM>\n                      |  <ARITH EXPRESSION> - <TERM>\n\n<TERM>  ::=  <PRIMARY>\n          |  <TERM> * <PRIMARY>\n          |  <TERM> / <PRIMARY>\n\n<PRIMARY>  ::=  <VARIABLE>\n             |  <NUMBER>\n             |  ( <EXPRESSION> )\n\n<VARIABLE>  ::=  <IDENTIFIER>\n              |  <VARIABLE> ( <EXPRESSION> )\n                                                                              */\n\n   /*  FIRST WE INITIALIZE THE GLOBAL CONSTANTS THAT DEPEND UPON THE INPUT\n      GRAMMAR.  THE FOLLOWING CARDS ARE PUNCHED BY THE SYNTAX PRE-PROCESSOR  */\n\n   DECLARE NSY LITERALLY '32', NT LITERALLY '18';\n   DECLARE V(NSY) CHARACTER INITIAL ( '<ERROR: TOKEN = 0>', ';', '=', '<', '>',\n      '+', '-', '*', '/', '(', ')', 'IF', '_|_', 'THEN', 'ELSE', 'TRUE',\n      'FALSE', '<NUMBER>', '<IDENTIFIER>', '<TERM>', '<PROGRAM>', '<PRIMARY>',\n      '<VARIABLE>', '<RELATION>', '<STATEMENT>', '<IF CLAUSE>', '<ASSIGNMENT>',\n      '<EXPRESSION>', '<STATEMENT LIST>', '<ARITH EXPRESSION>',\n      '<LOG EXPRESSION>', 'ELSE', 'ELSE');\n   DECLARE V_INDEX(12) BIT(16) INITIAL ( 1, 11, 12, 13, 16, 17, 17, 17, 18, 18,\n      18, 18, 19);\n   DECLARE C1(NSY) BIT(38) INITIAL (\n      \"(2) 00000 00000 00000 0000\",\n      \"(2) 00000 00000 00200 0002\",\n      \"(2) 00000 00003 03000 0033\",\n      \"(2) 00000 00002 02000 0022\",\n      \"(2) 00000 00002 02000 0022\",\n      \"(2) 00000 00001 00000 0011\",\n      \"(2) 00000 00001 00000 0011\",\n      \"(2) 00000 00001 00000 0011\",\n      \"(2) 00000 00001 00000 0011\",\n      \"(2) 00000 00001 01000 0011\",\n      \"(2) 02222 22222 20022 0000\",\n      \"(2) 00000 00001 01000 1111\",\n      \"(2) 00000 00000 00000 0001\",\n      \"(2) 00000 00001 01000 1111\",\n      \"(2) 00000 00002 02000 2222\",\n      \"(2) 00000 00000 00022 0000\",\n      \"(2) 00000 00000 00022 0000\",\n      \"(2) 02222 22220 20022 0000\",\n      \"(2) 02222 22222 20022 0000\",\n      \"(2) 02222 22110 20022 0000\",\n      \"(2) 00000 00000 00000 0000\",\n      \"(2) 02222 22220 20022 0000\",\n      \"(2) 02322 22221 20022 0000\",\n      \"(2) 00000 00001 01000 0011\",\n      \"(2) 00000 00000 00200 0002\",\n      \"(2) 00000 00000 00010 0000\",\n      \"(2) 01000 00000 00000 0000\",\n      \"(2) 02333 00000 30023 0000\",\n      \"(2) 00000 00000 00200 0001\",\n      \"(2) 02222 11000 20022 0000\",\n      \"(2) 00000 00000 00023 0000\",\n      \"(2) 00000 00001 01000 0011\",\n      \"(2) 00000 00001 01000 1111\");\n   DECLARE NC1TRIPLES LITERALLY '17';\n   DECLARE C1TRIPLES(NC1TRIPLES) FIXED INITIAL ( 596746, 727810, 727811, 727812,\n      792066, 858882, 858883, 858884, 858894, 859662, 1442313, 1442315, 1442321,\n      1442322, 1840642, 2104066, 2104067, 2104068);\n   DECLARE PRTB(28) FIXED INITIAL (0, 26, 0, 0, 0, 1444123, 2331, 0, 0, 0, 0, 0,\n      0, 7429, 7430, 0, 4871, 4872, 0, 0, 28, 0, 420289311, 5634, 6935, 0, 0,\n      420290080, 11);\n   DECLARE PRDTB(28) BIT(8) INITIAL (0, 4, 13, 14, 15, 26, 24, 0, 0, 9, 10, 23,\n      25, 17, 18, 16, 20, 21, 19, 22, 3, 2, 7, 5, 11, 1, 6, 12, 8);\n   DECLARE HDTB(28) BIT(8) INITIAL (0, 24, 23, 23, 23, 22, 21, 31, 32, 30, 30,\n      21, 22, 29, 29, 29, 19, 19, 19, 21, 28, 28, 27, 26, 30, 20, 27, 30, 25);\n   DECLARE PRLENGTH(28) BIT(8) INITIAL (0, 2, 1, 1, 1, 4, 3, 1, 1, 1, 1, 1, 1,\n      3, 3, 1, 3, 3, 1, 1, 2, 1, 5, 3, 3, 1, 1, 5, 2);\n   DECLARE CONTEXT_CASE(28) BIT(8) INITIAL (0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n   DECLARE LEFT_CONTEXT(0) BIT(8) INITIAL ( 27);\n   DECLARE LEFT_INDEX(14) BIT(8) INITIAL ( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 1, 1);\n   DECLARE CONTEXT_TRIPLE(0) FIXED INITIAL ( 0);\n   DECLARE TRIPLE_INDEX(14) BIT(8) INITIAL ( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 1);\n   DECLARE PR_INDEX(32) BIT(8) INITIAL ( 1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 7, 7, 7,\n      7, 9, 10, 11, 12, 13, 16, 16, 19, 20, 20, 22, 22, 22, 25, 26, 27, 29, 29,\n      29);\n\n   /*  END OF CARDS PUNCHED BY SYNTAX                                      */\n\n   /*  DECLARATIONS FOR THE SCANNER                                        */\n\n   /* TOKEN IS THE INDEX INTO THE VOCABULARY V() OF THE LAST SYMBOL SCANNED,\n      CP IS THE POINTER TO THE LAST CHARACTER SCANNED IN THE CARDIMAGE,\n      BCD IS THE LAST SYMBOL SCANNED (LITERAL CHARACTER STRING). */\n   DECLARE (TOKEN, CP) FIXED, BCD CHARACTER;\n\n   /* SET UP SOME CONVENIENT ABBREVIATIONS FOR PRINTER CONTROL */\n   DECLARE EJECT_PAGE LITERALLY 'OUTPUT(1) = PAGE',\n      PAGE CHARACTER INITIAL ('1'), DOUBLE CHARACTER INITIAL ('0'),\n      DOUBLE_SPACE LITERALLY 'OUTPUT(1) = DOUBLE',\n      X70 CHARACTER INITIAL ('\n                    ');\n\n   /* LENGTH OF LONGEST SYMBOL IN V */\n   DECLARE (RESERVED_LIMIT, MARGIN_CHOP) FIXED;\n\n   /* CHARTYPE() IS USED TO DISTINGUISH CLASSES OF SYMBOLS IN THE SCANNER.\n      TX() IS A TABLE USED FOR TRANSLATING FROM ONE CHARACTER SET TO ANOTHER.\n      CONTROL() HOLDS THE VALUE OF THE COMPILER CONTROL TOGGLES SET IN $ CARDS.\n      NOT_LETTER_OR_DIGIT() IS SIMILIAR TO CHARTYPE() BUT USED IN SCANNING\n      IDENTIFIERS ONLY.\n\n      ALL ARE USED BY THE SCANNER AND CONTROL() IS SET THERE.\n   */\n   DECLARE (CHARTYPE, TX) (255) BIT(8),\n           (CONTROL, NOT_LETTER_OR_DIGIT)(255) BIT(1);\n\n   /* ALPHABET CONSISTS OF THE SYMBOLS CONSIDERED ALPHABETIC IN BUILDING\n      IDENTIFIERS     */\n   DECLARE ALPHABET CHARACTER INITIAL ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_$@#');\n\n   /* BUFFER HOLDS THE LATEST CARDIMAGE,\n      TEXT HOLDS THE PRESENT STATE OF THE INPUT TEXT\n      (NOT INCLUDING THE PORTIONS DELETED BY THE SCANNER),\n      TEXT_LIMIT IS A CONVENIENT PLACE TO STORE THE POINTER TO THE END OF TEXT,\n      CARD_COUNT IS INCREMENTED BY ONE FOR EVERY SOURCE CARD READ,\n      ERROR_COUNT TABULATES THE ERRORS AS THEY ARE DETECTED,\n      SEVERE_ERRORS TABULATES THOSE ERRORS OF FATAL SIGNIFICANCE.\n   */\n   DECLARE (BUFFER, TEXT) CHARACTER,\n      (TEXT_LIMIT, CARD_COUNT, ERROR_COUNT, SEVERE_ERRORS, PREVIOUS_ERROR) FIXED\n      ;\n\n   /* NUMBER_VALUE CONTAINS THE NUMERIC VALUE OF THE LAST CONSTANT SCANNED,\n   */\n   DECLARE NUMBER_VALUE FIXED;\n\n   /* EACH OF THE FOLLOWING CONTAINS THE INDEX INTO V() OF THE CORRESPONDING\n      SYMBOL.   WE ASK:    IF TOKEN = IDENT    ETC.    */\n   DECLARE (IDENT, NUMBER, DIVIDE, EOFILE) FIXED;\n\n   /* STOPIT() IS A TABLE OF SYMBOLS WHICH ARE ALLOWED TO TERMINATE THE ERROR\n      FLUSH PROCESS.  IN GENERAL THEY ARE SYMBOLS OF SUFFICIENT SYNTACTIC\n      HIERARCHY THAT WE EXPECT TO AVOID ATTEMPTING TO START CHECKING AGAIN\n      RIGHT INTO ANOTHER ERROR PRODUCING SITUATION.  THE TOKEN STACK IS ALSO\n      FLUSHED DOWN TO SOMETHING ACCEPTABLE TO A STOPIT() SYMBOL.\n      FAILSOFT IS A BIT WHICH ALLOWS THE COMPILER ONE ATTEMPT AT A GENTLE\n      RECOVERY.   THEN IT TAKES A STRONG HAND.   WHEN THERE IS REAL TROUBLE\n      COMPILING IS SET TO FALSE, THEREBY TERMINATING THE COMPILATION.\n   */\n   DECLARE STOPIT(100) BIT(1), (FAILSOFT, COMPILING) BIT(1);\n\n   DECLARE S CHARACTER;  /* A TEMPORARY USED VARIOUS PLACES */\n\n   /* THE ENTRIES IN PRMASK() ARE USED TO SELECT OUT PORTIONS OF CODED\n      PRODUCTIONS AND THE STACK TOP FOR COMPARISON IN THE ANALYSIS ALGORITHM */\n   DECLARE PRMASK(5) FIXED INITIAL (0, 0, \"FF\", \"FFFF\", \"FFFFFF\", \"FFFFFFFF\");\n\n\n   /*THE PROPER SUBSTRING OF POINTER IS USED TO PLACE AN  |  UNDER THE POINT\n      OF DETECTION OF AN ERROR DURING CHECKING.  IT MARKS THE LAST CHARACTER\n      SCANNED.  */\n   DECLARE POINTER CHARACTER INITIAL ('\n                                           |');\n   DECLARE CALLCOUNT(20) FIXED   /* COUNT THE CALLS OF IMPORTANT PROCEDURES */\n      INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n   /* RECORD THE TIMES OF IMPORTANT POINTS DURING CHECKING */\n   DECLARE CLOCK(5) FIXED;\n\n\n   /* COMMONLY USED STRINGS */\n   DECLARE X1 CHARACTER INITIAL(' '), X4 CHARACTER INITIAL('    ');\n   DECLARE PERIOD CHARACTER INITIAL ('.');\n\n   /* TEMPORARIES USED THROUGHOUT THE COMPILER */\n   DECLARE (I, J, K, L) FIXED;\n\n   DECLARE TRUE LITERALLY '1', FALSE LITERALLY '0', FOREVER LITERALLY 'WHILE 1';\n\n   /*  THE STACKS DECLARED BELOW ARE USED TO DRIVE THE SYNTACTIC\n      ANALYSIS ALGORITHM AND STORE INFORMATION RELEVANT TO THE INTERPRETATION\n      OF THE TEXT.  THE STACKS ARE ALL POINTED TO BY THE STACK POINTER SP.  */\n\n   DECLARE STACKSIZE LITERALLY '75';  /* SIZE OF STACK  */\n   DECLARE PARSE_STACK (STACKSIZE) BIT(8); /* TOKENS OF THE PARTIALLY PARSED\n                                              TEXT */\n   DECLARE VAR (STACKSIZE) CHARACTER;/* EBCDIC NAME OF ITEM */\n   DECLARE FIXV (STACKSIZE) FIXED;   /* FIXED (NUMERIC) VALUE */\n\n   /* SP POINTS TO THE RIGHT END OF THE REDUCIBLE STRING IN THE PARSE STACK,\n      MP POINTS TO THE LEFT END, AND\n      MPP1 = MP+1.\n   */\n   DECLARE (SP, MP, MPP1) FIXED;\n\n\n\n\n\n   /*               P R O C E D U R E S                                  */\n\n\n\nPAD:\n   PROCEDURE (STRING, WIDTH) CHARACTER;\n      DECLARE STRING CHARACTER, (WIDTH, L) FIXED;\n\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN STRING || SUBSTR(X70, 0, WIDTH-L);\n   END PAD;\n\nI_FORMAT:\n   PROCEDURE (NUMBER, WIDTH) CHARACTER;\n      DECLARE (NUMBER, WIDTH, L) FIXED, STRING CHARACTER;\n\n      STRING = NUMBER;\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN SUBSTR(X70, 0, WIDTH-L) || STRING;\n   END I_FORMAT;\n\nERROR:\n   PROCEDURE(MSG, SEVERITY);\n      /* PRINTS AND ACCOUNTS FOR ALL ERROR MESSAGES */\n      /* IF SEVERITY IS NOT SUPPLIED, 0 IS ASSUMED */\n      DECLARE MSG CHARACTER, SEVERITY FIXED;\n      ERROR_COUNT = ERROR_COUNT + 1;\n      /* IF LISTING IS SUPPRESSED, FORCE PRINTING OF THIS LINE */\n      IF \u00ac CONTROL(BYTE('L')) THEN\n         OUTPUT = I_FORMAT (CARD_COUNT, 4) || ' |' || BUFFER || '|';\n      OUTPUT = SUBSTR(POINTER, TEXT_LIMIT-CP+MARGIN_CHOP);\n      OUTPUT = '*** ERROR, ' || MSG ||\n            '.  LAST PREVIOUS ERROR WAS DETECTED ON LINE ' ||\n            PREVIOUS_ERROR || '.  ***';\n      PREVIOUS_ERROR = CARD_COUNT;\n      IF SEVERITY > 0 THEN\n         IF SEVERE_ERRORS > 25 THEN\n            DO;\n               OUTPUT = '*** TOO MANY SEVERE ERRORS, CHECKING ABORTED ***';\n               COMPILING = FALSE;\n            END;\n         ELSE SEVERE_ERRORS = SEVERE_ERRORS + 1;\n   END ERROR;\n\n\n\n\n\n  /*                   CARD IMAGE HANDLING PROCEDURE                      */\n\n\nGET_CARD:\n   PROCEDURE;\n      /* DOES ALL CARD READING AND LISTING                                 */\n      DECLARE I FIXED, (TEMP, TEMP0, REST) CHARACTER, READING BIT(1);\n            BUFFER = INPUT;\n            IF LENGTH(BUFFER) = 0 THEN\n               DO; /* SIGNAL FOR EOF */\n                  CALL ERROR ('EOF MISSING OR COMMENT STARTING IN COLUMN 1.',1);\n                  BUFFER = PAD (' /*''/* */ EOF;END;EOF', 80);\n               END;\n            ELSE CARD_COUNT = CARD_COUNT + 1;  /* USED TO PRINT ON LISTING */\n      IF MARGIN_CHOP > 0 THEN\n         DO; /* THE MARGIN CONTROL FROM DOLLAR | */\n            I = LENGTH(BUFFER) - MARGIN_CHOP;\n            REST = SUBSTR(BUFFER, I);\n            BUFFER = SUBSTR(BUFFER, 0, I);\n         END;\n      ELSE REST = '';\n      TEXT = BUFFER;\n      TEXT_LIMIT = LENGTH(TEXT) - 1;\n      IF CONTROL(BYTE('M')) THEN OUTPUT = BUFFER;\n      ELSE IF CONTROL(BYTE('L')) THEN\n         OUTPUT = I_FORMAT (CARD_COUNT, 4) || ' |' || BUFFER || '|' || REST;\n      CP = 0;\n   END GET_CARD;\n\n\n   /*                THE SCANNER PROCEDURES              */\n\n\nCHAR:\n   PROCEDURE;\n      /* USED FOR STRINGS TO AVOID CARD BOUNDARY PROBLEMS */\n      CP = CP + 1;\n      IF CP <= TEXT_LIMIT THEN RETURN;\n      CALL GET_CARD;\n   END CHAR;\n\n\nSCAN:\n   PROCEDURE;\n      DECLARE (S1, S2) FIXED;\n      CALLCOUNT(3) = CALLCOUNT(3) + 1;\n      FAILSOFT = TRUE;\n      BCD = '';  NUMBER_VALUE = 0;\n   SCAN1:\n      DO FOREVER;\n         IF CP > TEXT_LIMIT THEN CALL GET_CARD;\n         ELSE\n            DO; /* DISCARD LAST SCANNED VALUE */\n               TEXT_LIMIT = TEXT_LIMIT - CP;\n               TEXT = SUBSTR(TEXT, CP);\n               CP = 0;\n            END;\n         /*  BRANCH ON NEXT CHARACTER IN TEXT                  */\n         DO CASE CHARTYPE(BYTE(TEXT));\n\n            /*  CASE 0  */\n\n            /* ILLEGAL CHARACTERS FALL HERE  */\n            CALL ERROR ('ILLEGAL CHARACTER: ' || SUBSTR(TEXT, 0, 1));\n\n            /*  CASE 1  */\n\n            /*  BLANK  */\n            DO;\n               CP = 1;\n               DO WHILE BYTE(TEXT, CP) = BYTE(' ') & CP <= TEXT_LIMIT;\n                  CP = CP + 1;\n               END;\n               CP = CP - 1;\n            END;\n\n            /*  CASE 2  */\n\n        ;   /*  NOT USED IN SKELETON (BUT USED IN XCOM)  */\n\n            /*  CASE 3  */\n\n        ;   /*  NOT USED IN SKELETON (BUT USED IN XCOM)  */\n\n            /*  CASE 4  */\n\n            DO FOREVER;  /* A LETTER:  IDENTIFIERS AND RESERVED WORDS */\n               DO CP = CP + 1 TO TEXT_LIMIT;\n                  IF NOT_LETTER_OR_DIGIT(BYTE(TEXT, CP)) THEN\n                     DO;  /* END OF IDENTIFIER  */\n                        IF CP > 0 THEN BCD = BCD || SUBSTR(TEXT, 0, CP);\n                        S1 = LENGTH(BCD);\n                        IF S1 > 1 THEN IF S1 <= RESERVED_LIMIT THEN\n                           /* CHECK FOR RESERVED WORDS */\n                           DO I = V_INDEX(S1-1) TO V_INDEX(S1) - 1;\n                              IF BCD = V(I) THEN\n                                 DO;\n                                    TOKEN = I;\n                                    RETURN;\n                                 END;\n                           END;\n                        /*  RESERVED WORDS EXIT HIGHER: THEREFORE <IDENTIFIER>*/\n                        TOKEN = IDENT;\n                        RETURN;\n                     END;\n               END;\n               /*  END OF CARD  */\n               BCD = BCD || TEXT;\n               CALL GET_CARD;\n               CP = -1;\n            END;\n\n            /*  CASE 5  */\n\n            DO;      /*  DIGIT:  A NUMBER  */\n               TOKEN = NUMBER;\n               DO FOREVER;\n                  DO CP = CP TO TEXT_LIMIT;\n                     S1 = BYTE(TEXT, CP);\n                     IF S1 < \"F0\" THEN RETURN;\n                     NUMBER_VALUE = 10*NUMBER_VALUE + S1 - \"F0\";\n                  END;\n                  CALL GET_CARD;\n               END;\n            END;\n\n            /*  CASE 6  */\n\n            DO;      /*  A /:  MAY BE DIVIDE OR START OF COMMENT  */\n               CALL CHAR;\n               IF BYTE(TEXT, CP) \u00ac= BYTE('*') THEN\n                  DO;\n                     TOKEN = DIVIDE;\n                     RETURN;\n                  END;\n               /* WE HAVE A COMMENT  */\n               S1, S2 = BYTE(' ');\n               DO WHILE S1 \u00ac= BYTE('*') | S2 \u00ac= BYTE('/');\n                  IF S1 = BYTE('$') THEN\n                     DO;  /* A CONTROL CHARACTER  */\n                        CONTROL(S2) = \u00ac CONTROL(S2);\n                        IF S2 = BYTE('T') THEN CALL TRACE;\n                        ELSE IF S2 = BYTE('U') THEN CALL UNTRACE;\n                        ELSE IF S2 = BYTE('|') THEN\n                           IF CONTROL(S2) THEN\n                              MARGIN_CHOP = TEXT_LIMIT - CP + 1;\n                           ELSE\n                              MARGIN_CHOP = 0;\n                     END;\n                  S1 = S2;\n                  CALL CHAR;\n                  S2 = BYTE(TEXT, CP);\n               END;\n            END;\n\n            /*  CASE 7  */\n            DO;      /*  SPECIAL CHARACTERS  */\n               TOKEN = TX(BYTE(TEXT));\n               CP = 1;\n               RETURN;\n            END;\n\n            /*  CASE 8  */\n        ;   /*  NOT USED IN SKELETON (BUT USED IN XCOM)  */\n\n         END;     /* OF CASE ON CHARTYPE  */\n         CP = CP + 1;  /* ADVANCE SCANNER AND RESUME SEARCH FOR TOKEN  */\n      END;\n   END SCAN;\n\n\n\n\n  /*                       TIME AND DATE                                 */\n\n\nPRINT_TIME:\n   PROCEDURE (MESSAGE, T);\n      DECLARE MESSAGE CHARACTER, T FIXED;\n      MESSAGE = MESSAGE || T/360000 || ':' || T MOD 360000 / 6000 || ':'\n         || T MOD 6000 / 100 || '.';\n      T = T MOD 100;  /* DECIMAL FRACTION  */\n      IF T < 10 THEN MESSAGE = MESSAGE || '0';\n      OUTPUT = MESSAGE || T || '.';\n   END PRINT_TIME;\n\nPRINT_DATE_AND_TIME:\n   PROCEDURE (MESSAGE, D, T);\n      DECLARE MESSAGE CHARACTER, (D, T, YEAR, DAY, M) FIXED;\n      DECLARE MONTH(11) CHARACTER INITIAL ('JANUARY', 'FEBRUARY', 'MARCH',\n         'APRIL', 'MAY', 'JUNE', 'JULY', 'AUGUST', 'SEPTEMBER', 'OCTOBER',\n         'NOVEMBER', 'DECEMBER'),\n      DAYS(12) FIXED INITIAL (0, 31, 60, 91, 121, 152, 182, 213, 244, 274,\n         305, 335, 366);\n      YEAR = D/1000 + 1900;\n      DAY = D MOD 1000;\n      IF (YEAR & \"3\") \u00ac= 0 THEN IF DAY > 59 THEN DAY = DAY + 1; /* \u00ac LEAP YEAR*/\n      M = 1;\n      DO WHILE DAY > DAYS(M);  M = M + 1;  END;\n      CALL PRINT_TIME(MESSAGE || MONTH(M-1) || X1 || DAY-DAYS(M-1) ||  ', '\n         || YEAR || '.  CLOCK TIME = ', T);\n   END PRINT_DATE_AND_TIME;\n\n  /*                       INITIALIZATION                                     */\n\n\n\nINITIALIZATION:\n   PROCEDURE;\n      EJECT_PAGE;\n   CALL PRINT_DATE_AND_TIME ('   SYNTAX CHECK -- STANFORD UNIVERSITY -- SKELETON\n III VERSION OF ', DATE_OF_GENERATION, TIME_OF_GENERATION);\n      DOUBLE_SPACE;\n      CALL PRINT_DATE_AND_TIME ('TODAY IS ', DATE, TIME);\n      DOUBLE_SPACE;\n      DO I = 1 TO NT;\n         S = V(I);\n         IF S = '<NUMBER>' THEN NUMBER = I;  ELSE\n         IF S = '<IDENTIFIER>' THEN IDENT = I;  ELSE\n         IF S = '/' THEN DIVIDE = I;  ELSE\n         IF S = '_|_' THEN EOFILE = I;  ELSE\n         IF S = ';' THEN STOPIT(I) = TRUE;  ELSE\n         ;\n      END;\n      IF IDENT = NT THEN RESERVED_LIMIT = LENGTH(V(NT-1));\n      ELSE RESERVED_LIMIT = LENGTH(V(NT));\n      V(EOFILE) = 'EOF';\n      STOPIT(EOFILE) = TRUE;\n      CHARTYPE(BYTE(' ')) = 1;\n      DO I = 0 TO 255;\n         NOT_LETTER_OR_DIGIT(I) = TRUE;\n      END;\n      DO I = 0 TO LENGTH(ALPHABET) - 1;\n         J = BYTE(ALPHABET, I);\n         TX(J) = I;\n         NOT_LETTER_OR_DIGIT(J) = FALSE;\n         CHARTYPE(J) = 4;\n      END;\n      DO I = 0 TO 9;\n         J = BYTE('0123456789', I);\n         NOT_LETTER_OR_DIGIT(J) = FALSE;\n         CHARTYPE(J) = 5;\n      END;\n      DO I = V_INDEX(0) TO V_INDEX(1) - 1;\n         J = BYTE(V(I));\n         TX(J) = I;\n         CHARTYPE(J) = 7;\n      END;\n      CHARTYPE(BYTE('/')) = 6;\n      /* FIRST SET UP GLOBAL VARIABLES CONTROLLING SCAN, THEN CALL IT */\n      CP = 0;  TEXT_LIMIT = -1;\n      TEXT = '';\n      CONTROL(BYTE('L')) = TRUE;\n      CALL SCAN;\n\n      /* INITIALIZE THE PARSE STACK */\n      SP = 1;  PARSE_STACK(SP) = EOFILE;\n\n   END INITIALIZATION;\n\n\n\n\n\n\nDUMPIT:\n   PROCEDURE;    /* DUMP OUT THE STATISTICS COLLECTED DURING THIS RUN  */\n      DOUBLE_SPACE;\n      /*  PUT OUT THE ENTRY COUNT FOR IMPORTANT PROCEDURES */\n\n      OUTPUT = 'STACKING DECISIONS= ' || CALLCOUNT(1);\n      OUTPUT = 'SCAN              = ' || CALLCOUNT(3);\n      OUTPUT = 'FREE STRING AREA  = ' || FREELIMIT - FREEBASE;\n   END DUMPIT;\n\n\nSTACK_DUMP:\n   PROCEDURE;\n      DECLARE LINE CHARACTER;\n      LINE = 'PARTIAL PARSE TO THIS POINT IS: ';\n      DO I = 2 TO SP;\n         IF LENGTH(LINE) > 105 THEN\n            DO;\n               OUTPUT = LINE;\n               LINE = X4;\n            END;\n         LINE = LINE || X1 || V(PARSE_STACK(I));\n      END;\n      OUTPUT = LINE;\n   END STACK_DUMP;\n\n\n  /*                  THE SYNTHESIS ALGORITHM FOR XPL                      */\n\n\nSYNTHESIZE:\nPROCEDURE(PRODUCTION_NUMBER);\n   DECLARE PRODUCTION_NUMBER FIXED;\n\n   /*  THIS PROCEDURE IS RESPONSIBLE FOR THE SEMANTICS (CODE SYNTHESIS), IF\n      ANY, OF THE SKELETON COMPILER.  ITS ARGUMENT IS THE NUMBER OF THE\n      PRODUCTION WHICH WILL BE APPLIED IN THE PENDING REDUCTION.  THE GLOBAL\n      VARIABLES MP AND SP POINT TO THE BOUNDS IN THE STACKS OF THE RIGHT PART\n      OF THIS PRODUCTION.\n       NORMALLY, THIS PROCEDURE WILL TAKE THE FORM OF A GIANT CASE STATEMENT\n      ON PRODUCTION_NUMBER.  HOWEVER, THE SYNTAX CHECKER HAS SEMANTICS (THE\n      TERMINATION OF CHECKING) ONLY FOR PRODUCTION 1.                     */\n\n   IF PRODUCTION_NUMBER = 1 THEN\n\n /*  <PROGRAM>  ::=  <STATEMENT LIST>    */\n   DO;\n      IF MP \u00ac= 2 THEN  /* WE DIDN'T GET HERE LEGITIMATELY  */\n         DO;\n            CALL ERROR ('EOF AT INVALID POINT', 1);\n            CALL STACK_DUMP;\n         END;\n      COMPILING = FALSE;\n   END;\nEND SYNTHESIZE;\n\n\n\n\n  /*              SYNTACTIC PARSING FUNCTIONS                              */\n\n\nRIGHT_CONFLICT:\n   PROCEDURE (LEFT) BIT(1);\n      DECLARE LEFT FIXED;\n      /*  THIS PROCEDURE IS TRUE IF TOKEN IS \u00ac A LEGAL RIGHT CONTEXT OF LEFT*/\n      RETURN (\"C0\" & SHL(BYTE(C1(LEFT), SHR(TOKEN,2)), SHL(TOKEN,1)\n         & \"06\")) = 0;\n   END RIGHT_CONFLICT;\n\n\nRECOVER:\n   PROCEDURE;\n      /* IF THIS IS THE SECOND SUCCESSIVE CALL TO RECOVER, DISCARD ONE SYMBOL */\n      IF \u00ac FAILSOFT THEN CALL SCAN;\n      FAILSOFT = FALSE;\n      DO WHILE \u00ac STOPIT(TOKEN);\n         CALL SCAN;  /* TO FIND SOMETHING SOLID IN THE TEXT  */\n      END;\n      DO WHILE RIGHT_CONFLICT (PARSE_STACK(SP));\n         IF SP > 2 THEN SP = SP - 1;  /* AND IN THE STACK  */\n         ELSE CALL SCAN;  /* BUT DON'T GO TOO FAR  */\n      END;\n      OUTPUT = 'RESUME:' || SUBSTR(POINTER, TEXT_LIMIT-CP+MARGIN_CHOP+7);\n   END RECOVER;\n\nSTACKING:\n   PROCEDURE BIT(1);  /* STACKING DECISION FUNCTION */\n      CALLCOUNT(1) = CALLCOUNT(1) + 1;\n      DO FOREVER;    /* UNTIL RETURN  */\n         DO CASE SHR(BYTE(C1(PARSE_STACK(SP)),SHR(TOKEN,2)),SHL(3-TOKEN,1)&6)&3;\n\n            /*  CASE 0  */\n            DO;    /* ILLEGAL SYMBOL PAIR  */\n               CALL ERROR('ILLEGAL SYMBOL PAIR: ' || V(PARSE_STACK(SP)) || X1 ||\n                  V(TOKEN), 1);\n               CALL STACK_DUMP;\n               CALL RECOVER;\n            END;\n\n            /*  CASE 1  */\n\n            RETURN TRUE;      /*  STACK TOKEN  */\n\n            /*  CASE 2  */\n\n            RETURN FALSE;     /* DON'T STACK IT YET  */\n\n            /*  CASE 3  */\n\n            DO;      /* MUST CHECK TRIPLES  */\n               J = SHL(PARSE_STACK(SP-1), 16) + SHL(PARSE_STACK(SP), 8) + TOKEN;\n               I = -1;  K = NC1TRIPLES + 1;  /* BINARY SEARCH OF TRIPLES  */\n               DO WHILE I + 1 < K;\n                  L = SHR(I+K, 1);\n                  IF C1TRIPLES(L) > J THEN K = L;\n                  ELSE IF C1TRIPLES(L) < J THEN I = L;\n                  ELSE RETURN TRUE;  /* IT IS A VALID TRIPLE  */\n               END;\n               RETURN FALSE;\n            END;\n\n         END;    /* OF DO CASE  */\n      END;   /*  OF DO FOREVER */\n   END STACKING;\n\nPR_OK:\n   PROCEDURE(PRD) BIT(1);\n      /* DECISION PROCEDURE FOR CONTEXT CHECK OF EQUAL OR IMBEDDED RIGHT PARTS*/\n      DECLARE (H, I, J, PRD) FIXED;\n      DO CASE CONTEXT_CASE(PRD);\n\n         /*  CASE 0 -- NO CHECK REQUIRED  */\n\n         RETURN TRUE;\n\n         /*  CASE 1 -- RIGHT CONTEXT CHECK  */\n\n         RETURN \u00ac RIGHT_CONFLICT (HDTB(PRD));\n\n         /*  CASE 2 -- LEFT CONTEXT CHECK  */\n\n         DO;\n            H = HDTB(PRD) - NT;\n            I = PARSE_STACK(SP - PRLENGTH(PRD));\n            DO J = LEFT_INDEX(H-1) TO LEFT_INDEX(H) - 1;\n               IF LEFT_CONTEXT(J) = I THEN RETURN TRUE;\n            END;\n            RETURN FALSE;\n         END;\n\n         /*  CASE 3 -- CHECK TRIPLES  */\n\n         DO;\n            H = HDTB(PRD) - NT;\n            I = SHL(PARSE_STACK(SP - PRLENGTH(PRD)), 8) + TOKEN;\n            DO J = TRIPLE_INDEX(H-1) TO TRIPLE_INDEX(H) - 1;\n               IF CONTEXT_TRIPLE(J) = I THEN RETURN TRUE;\n            END;\n            RETURN FALSE;\n         END;\n\n      END;  /* OF DO CASE  */\n   END PR_OK;\n\n\n  /*                     ANALYSIS ALGORITHM                                  */\n\n\n\nREDUCE:\n   PROCEDURE;\n      DECLARE (I, J, PRD) FIXED;\n      /* PACK STACK TOP INTO ONE WORD */\n      DO I = SP - 4 TO SP - 1;\n         J = SHL(J, 8) + PARSE_STACK(I);\n      END;\n\n      DO PRD = PR_INDEX(PARSE_STACK(SP)-1) TO PR_INDEX(PARSE_STACK(SP)) - 1;\n         IF (PRMASK(PRLENGTH(PRD)) & J) = PRTB(PRD) THEN\n            IF PR_OK(PRD) THEN\n            DO;  /* AN ALLOWED REDUCTION */\n               MP = SP - PRLENGTH(PRD) + 1; MPP1 = MP + 1;\n               CALL SYNTHESIZE(PRDTB(PRD));\n               SP = MP;\n               PARSE_STACK(SP) = HDTB(PRD);\n               RETURN;\n            END;\n      END;\n\n      /* LOOK UP HAS FAILED, ERROR CONDITION */\n      CALL ERROR('NO PRODUCTION IS APPLICABLE',1);\n      CALL STACK_DUMP;\n      FAILSOFT = FALSE;\n      CALL RECOVER;\n   END REDUCE;\n\nCOMPILATION_LOOP:\n   PROCEDURE;\n\n      COMPILING = TRUE;\n      DO WHILE COMPILING;     /* ONCE AROUND FOR EACH PRODUCTION (REDUCTION)  */\n         DO WHILE STACKING;\n            SP = SP + 1;\n            IF SP = STACKSIZE THEN\n               DO;\n                  CALL ERROR ('STACK OVERFLOW *** CHECKING ABORTED ***', 2);\n                  RETURN;   /* THUS ABORTING CHECKING */\n               END;\n            PARSE_STACK(SP) = TOKEN;\n            VAR(SP) = BCD;\n            FIXV(SP) = NUMBER_VALUE;\n            CALL SCAN;\n         END;\n\n         CALL REDUCE;\n      END;     /* OF DO WHILE COMPILING  */\n   END COMPILATION_LOOP;\n\n\n\n\nPRINT_SUMMARY:\n   PROCEDURE;\n      DECLARE I FIXED;\n      CALL PRINT_DATE_AND_TIME ('END OF CHECKING ', DATE, TIME);\n      OUTPUT = '';\n      OUTPUT = CARD_COUNT || ' CARDS WERE CHECKED.';\n      IF ERROR_COUNT = 0 THEN OUTPUT = 'NO ERRORS WERE DETECTED.';\n      ELSE IF ERROR_COUNT > 1 THEN\n         OUTPUT = ERROR_COUNT || ' ERRORS (' || SEVERE_ERRORS\n            || ' SEVERE) WERE DETECTED.';\n      ELSE IF SEVERE_ERRORS = 1 THEN OUTPUT = 'ONE SEVERE ERROR WAS DETECTED.';\n         ELSE OUTPUT = 'ONE ERROR WAS DETECTED.';\n      IF PREVIOUS_ERROR > 0 THEN\n         OUTPUT = 'THE LAST DETECTED ERROR WAS ON LINE ' || PREVIOUS_ERROR\n            || PERIOD;\n      IF CONTROL(BYTE('D')) THEN CALL DUMPIT;\n      DOUBLE_SPACE;\n      CLOCK(3) = TIME;\n      DO I = 1 TO 3;   /* WATCH OUT FOR MIDNIGHT */\n         IF CLOCK(I) < CLOCK(I-1) THEN CLOCK(I) = CLOCK(I) +  8640000;\n      END;\n      CALL PRINT_TIME ('TOTAL TIME IN CHECKER    ', CLOCK(3) - CLOCK(0));\n      CALL PRINT_TIME ('SET UP TIME              ', CLOCK(1) - CLOCK(0));\n      CALL PRINT_TIME ('ACTUAL CHECKING TIME     ', CLOCK(2) - CLOCK(1));\n      CALL PRINT_TIME ('CLEAN-UP TIME AT END     ', CLOCK(3) - CLOCK(2));\n      IF CLOCK(2) > CLOCK(1) THEN   /* WATCH OUT FOR CLOCK BEING OFF */\n      OUTPUT = 'CHECKING RATE: ' || 6000*CARD_COUNT/(CLOCK(2)-CLOCK(1))\n         || ' CARDS PER MINUTE.';\n   END PRINT_SUMMARY;\n\nMAIN_PROCEDURE:\n   PROCEDURE;\n      CLOCK(0) = TIME;  /* KEEP TRACK OF TIME IN EXECUTION */\n      CALL INITIALIZATION;\n\n      CLOCK(1) = TIME;\n\n      CALL COMPILATION_LOOP;\n\n      CLOCK(2) = TIME;\n\n      /* CLOCK(3) GETS SET IN PRINT_SUMMARY */\n      CALL PRINT_SUMMARY;\n\n   END MAIN_PROCEDURE;\n\n\nCALL MAIN_PROCEDURE;\nRETURN SEVERE_ERRORS;\n\nEOF EOF EOF\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYNTAX": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x12\\x18\\x04\\xec\\x04\\xec\\x00\\x00\\xc1\\xd5\\xc1\\xd3\\xe8\\xe9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T12:18:00", "lines": 1260, "newlines": 1260, "modlines": 0, "user": "ANALYZR"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TRACE": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x11Y\\x07O\\x07O\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T11:59:00", "lines": 1871, "newlines": 1871, "modlines": 0, "user": "SOURCE"}, "text": "TRCR     TITLE 'TRACE ROUTINE FOR THE XPL COMPILER GENERATOR SYSTEM'\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*              THIS PROGRAM PROVIDES A MACHINE LEVEL TRACE OF PROGRAM *\n*              EXECUTION.  IT IS ACTIVATED BY THE XPL STATEMENT:      *\n*                                                                     *\n*              CALL  TRACE ;                                          *\n*                                                                     *\n*              AND TERMINATED BY THE XPL STATEMENT:                   *\n*                                                                     *\n*              CALL UNTRACE ;                                         *\n*                                                                     *\n*              THIS ROUTINE PRINTS ONE LINE FOR EACH MACHINE LANGUAGE *\n*              INSTRUCTION EXECUTED.                                  *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                      DAVID B. WORTMAN               *\n*                                      STANFORD UNIVERSITY            *\n*                                      MARCH  1968                    *\n*                                                                     *\n***********************************************************************\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              DEFINE  REGISTER  USAGE                                *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSCR0     EQU   0                       SCRATCH REGISTER\n         SPACE 1\nSCR1     EQU   SCR0+1                  SCRATCH  REGISTER\n         SPACE 1\nSCR2     EQU   2                       SCRATCH  REGISTER\n         SPACE 1\nSCR3     EQU   3                       SCRATCH  REGISTER\n         SPACE 1\nFLDPT    EQU   3                       POINTER FOR PLINOP\n         SPACE 1\nINITLR   EQU   3                       BASE REGISTER FOR INITIALIZATION\n         SPACE 1\nEXEC     EQU   4                       ADDRESS OF EXECUTE ROUTINE\n         SPACE 1\n*              5                       (UNUSED)\n         SPACE 1\n*              6                       (UNUSED)\n         SPACE 1\n*              7                       (UNUSED)\n         SPACE 1\n*              8                       (UNUSED)\n         SPACE 1\nDATA     EQU   9                       BASE FOR DATA AREA\n         SPACE 1\nHEX2EBC  EQU   10                      ADDRESS OF CONVERT ROUTINE\n         SPACE 1\nILCR     EQU   11                      PSEUDO LOCATION COUNTER\n         SPACE 1\nCBR      EQU   12                      SUBMONITOR BRANCH REGISTER\n         SPACE 1\nBRFROM   EQU   12                      BRANCH REGISTER\n         SPACE 1\nOSAVE    EQU   13                      ADDRESS OF OS SAVE AREA\n         SPACE 1\n*              14                      OS\n         SPACE 1\nSELF     EQU   15                      ADDRESS OF XPL SUBMONITOR\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              SPECIFY LENGTH OF PRINTED LINE                         *\n*                                                                     *\n*              THE VALUE OF 'LPL' SHOULD NOT BE CHANGED WITHOUT       *\n*              CAREFULLY CONSIDERING THE ORGANIZATION OF THE          *\n*              PRINTED OUTPUT.                                        *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nLPL      EQU   132                     LENGTH OF THE PRINT LINE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              DEFINE SERVICE CODES USED TO COMMUNICATE WITH THE      *\n*              XPL SUBMONITOR                                         *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPRNT     EQU   8                       SERVICE CODE FOR PRINTING\n         SPACE 1\nTRACEC   EQU   12                      SERVICE CODE TO BEGIN TRACING\n         SPACE 1\nUNTRACE  EQU   16                      SERVICE CODE TO END TRACING\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              DEFINE REGISTERS USED TO PASS PARAMETERS TO THE        *\n*              XPL SUBMONITOR                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPR1      EQU   0                       1ST PARAMETER REGISTER\n         SPACE 1\nPR2      EQU   1                       2ND PARAMETER REGISTER\n         SPACE 1\nSVCR     EQU   1                       SERVICE CODE REGISTER\n         SPACE 1\nPR3      EQU   2                       3RD PARAMETER REGISTER\n         SPACE 1\nSMBR     EQU   12                      RETURN ADDRESS REGISTER\n*                                      FOR SUBMONITOR CALLS\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              DEFINE FLAG BITS USED THROUGHOUT THE TRACE PACKAGE     *\n*              TO SPECIFY THE ATTRIBUTES OF THE MACHINE INSTRUCTIONS  *\n*                                                                     *\n*                                                                     *\n*              FOR EACH MACHINE LANGUAGE INSTRUCTION BEING CONSIDERED *\n*              BY THE TRACE ROUTINE, A HALF WORD OF ATTRIBUTE         *\n*              INFORMATION IS STORED IN THE LOCATION 'FLAGS'.         *\n*              THIS INFORMATION DETERMINES THE WAY IN WHICH           *\n*              THE TRACE ROUTINE HANDLES THE INSTRUCTION              *\n*                                                                     *\n*                                                                     *\n*              ATTRIBUTES WHICH MAY OCCUR IN THE FIRST BYTE           *\n*              OF 'FLAGS'                                             *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nILGLBIT  EQU   B'10000000'             ILLEGAL INSTRUCTION\n         SPACE 1\nCCBIT    EQU   B'01000000'             INSTRUCTION SETS CONDITION CODE\n         SPACE 1\nBRBIT    EQU   B'00100000'             INSTRUCTION IS BRANCH OR EXECUTE\n         SPACE 1\nHALFBIT  EQU   B'00010000'             HALF WORD INSTRUCTION\n         SPACE 1\nFULLBIT  EQU   B'00001000'             FULL WORD INSTRUCTION\n         SPACE 1\nDBLBIT   EQU   B'00000100'             DOUBLE WORD INSTRUCTION\n         SPACE 1\nFLOATBIT EQU   B'00000010'             FLOATING POINT INSTRUCTION\n         SPACE 1\nSHIFTBIT EQU   B'00000001'             SHIFT INSTRUCTION\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              ATTRIBUTES WHICH MAY OCCUR IN THE SECOND BYTE          *\n*              OF 'FLAGS'                                             *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRRBIT    EQU   B'10000000'             TYPE RR INSTRUCTION\n         SPACE 1\nRXBIT    EQU   B'01000000'             TYPE RX INSTRUCTION\n         SPACE 1\nRSBIT    EQU   B'00100000'             TYPE RS INSTRUCTION\n         SPACE 1\nSIBIT    EQU   B'00010000'             TYPE SI INSTRUCTION\n         SPACE 1\nSSBIT    EQU   B'00001000'             TYPE SS INSTRUCTION\n         SPACE 1\nIMDFBIT  EQU   B'00000100'             INSTRUCTION CONTAINS 8-BIT\n*                                      IMMEDIATE FIELD\n         SPACE 1\nLMSTMBIT EQU   B'00000010'             INSTRUCTION IS LM OR STM\n         SPACE 1\nEXBIT    EQU   B'00000001'             INSTRUCTION IS EXECUTE (EX)\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              TRACE ROUTINE INITIALIZATION                           *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*              WHEN THE TRACE ROUTINE IS CALLED BY THE XPL SUBMONITOR *\n*              THE GENERAL REGISTERS SHOULD CONTAIN:                  *\n*                                                                     *\n*                                                                     *\n*        R0    ADDRESS OF THE PARAMETER FIELD OF THE EXECUTE CARD     *\n*              AS PASSED TO THE SUBMONITOR BY OS/360                  *\n*              (UNUSED IN THIS VERSION OF THE TRACE ROUTINE)          *\n*                                                                     *\n*        R1    ADDRESS OF THE BLOCK WHERE R0 - R15 WERE SAVED PRIOR   *\n*              TO THE CALL OF THE TRACE ROUTINE                       *\n*                                                                     *\n*              F0-F6 ARE ASSUMED TO BE IN PLACE                       *\n*                                                                     *\n*        R2    ADDRESS AT WHICH TRACED EXECUTION SHOULD BEGIN         *\n*                                                                     *\n*        R3    ADDRESS OF THE TRACE ROUTINE ENTRY POINT  'TRACE'      *\n*                                                                     *\n*        R4    ADDRESS OF THE EXECUTE ROUTINE IN THE SUBMONITOR       *\n*                                                                     *\n*        R13   ADDRESS OF THE SUBMONITORS OS SAVE AREA                *\n*                                                                     *\n*        R15   ADDRESS OF THE ENTRY POINT TO THE XPL SUBMONITOR       *\n*                                                                     *\n*              NOTE THAT THE TRACE ROUTINE CRITICALLY DEPENDS ON THE  *\n*              CONDITION THAT THE XPL PROGRAM BEING TRACED DOES NOT   *\n*              CHANGE THE CONTENTS OF REGISTER 15.  THIS REGISTER IS  *\n*              NEEDED TO MAINTAIN ADDRESSABILITY OF THE EXECUTE       *\n*              ROUTINE IN THE SUBMONITOR                              *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*              NOTE THAT TRACE CANNOT USE THE SAVE AREA OF THE        *\n*              CALLING PROGRAM (XPLSM) SINCE IT MAY ENTER XPLSM       *\n*              RECURSIVELY AND CAUSE OS ROUTINES TO ALSO USE XPLSM'S  *\n*              SAVE AREA.  NOTE FURTHER THAT TRACE DOES NOT NEED AN   *\n*              OS SAVE AREA SINCE IT DOES NOT CALL ANY EXTERNAL       *\n*              ROUTINES EXCEPT XPLSM.                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nTRACEP   CSECT\n         SPACE 2\n         ENTRY TRACE                   ENTRY TO THE TRACE ROUTINE\n         SPACE 2\n         USING *,INITLR\n         SPACE 1\nTRACE    DS    0H\n         SPACE 1\n         B     TRACEB\n         DC    AL1(6)                  CSECT IDENTIFIER\n         DC    CL6'TRACE '\n         SPACE 1\nTRACEB   STM   0,15,SAVE               SAVE ALL REGISTERS\n         LA    OSAVE,SAVE              BASE ADDRESS\n         USING SAVE,OSAVE\n         B     BEGN\n         DROP  INITLR\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              SAVE  AREA                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSAVE     DC    16F'0'                  SAVE AREA\nADATA    DC    A(DATAREA)              ADDRESS OF TRACE ROUTINE DATA\nAHEX     DC    A(HEXTOEBC)             ADDRESS OF CONVERT ROUTINE\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  HEXTOEBC    BINARY TO EBCDIC CONVERSION ROUTINE                    *\n*                                                                     *\n*                                                                     *\n*              CONVERTS THE WORD IN SCR0 INTO 8 EBCDIC HEX            *\n*              CHARACTERS SUITABLE FOR PRINTING                       *\n*              RETURNS THE 8 CHARACTERS IN SCR0,SCR1                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         USING *,HEX2EBC\nHEXTOEBC ST    SCR0,HEXTABLE+16        STORE THE WORD TO BE CONVERTED\n         L     SCR1,HEXTABLE-4         NORMALIZED ADDRESS OF CONVERT\n*                                      TABLE\n         UNPK  HEXTABLE+16(9),HEXTABLE+16(5)\n*                                      SPREAD THE HEX DIGITS\n         TR    HEXTABLE+16(8),0(1)     TRANSLATE DIGITS TO\n*                                      CORRESPONDING CHARACTERS\n         LM    SCR0,SCR1,HEXTABLE+16   LOAD RESULT\n         BR    BRFROM                  RETURN\n         DROP  HEX2EBC\n         SPACE 1\n         DC    A(HEXTABLE-240)         NORMALIZED ADDRESS CONSTANT\nHEXTABLE DC    CL25'0123456789ABCDEF'\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  BEGN        INITIALIZATION OF THE TRACE ROUTINE                    *\n*                                                                     *\n*              THE PARAMETERS PASSED TO THE TRACE ROUTINE ARE         *\n*              DESCRIBED IN THE COMMENT ABOVE                         *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBEGN     L     DATA,ADATA              ADDRESS OF THE DATA AREA\n         USING DATAREA,DATA\n         ST    SELF,AENTRY             SAVE ADDRESS OF THE SUBMONITOR\n*                                      ENTRY POINT\n         ST    0,ACONTRL               ADDRESS OF PARM FIELD\n         LR    ILCR,2                  ADDRESS OF 1ST INSTRUCTION\n*                                      TO BE TRACED\n         LR    EXEC,4                  EXECUTE ROUTINE ADDRESS\n         L     HEX2EBC,AHEX            CONVERSION ROUTINE ADDRESS\n         USING HEXTOEBC,HEX2EBC\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              COPY THE REGISTERS OF THE TRACED PROGRAM INTO REGTBL   *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         LA    SCR2,16                 16 REGISTERS\n         SR    SCR3,SCR3               INDEX\nPICKUP   L     SCR0,0(SCR3,SCR1)       FETCH A REGISTER\n         ST    SCR0,REGTBL(SCR3)       STORE IT AWAY\n         LA    SCR3,4(0,SCR3)          INCREMENT INDEX\n         BCT   SCR2,PICKUP             LOOP BACK TO GET NEXT REGISTER\n         SPACE 1\n         BAL   BRFROM,WRITE            WRITE 1 BLANK LINE\n         SPACE 1\n         BAL   BRFROM,RDUMP            DUMP THE INITIAL\n*                                      GENERAL REGISTERS\n         SPACE 1\n         STD   0,F0                    SAVE THE INITIAL VALUES\n         STD   2,F2                    OF THE FLOATING POINT\n         STD   4,F4                    REGISTERS\n         STD   6,F6\n         SPACE 1\n         BAL   BRFROM,FDUMP            DUMP THE FLOATING POINT\n*                                      REGISTERS\n         BAL   BRFROM,WRITE            WRITE 1 BLANK LINE\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  MAINLOOP    THE MAJOR CYCLE OF THE TRACE ROUTINE                   *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nMAINLOOP DS    0H\n         MVC   OLDREG(4*16),REGTBL     SAVE OLD REGISTERS FOR EVALXBD\n         C     ILCR,AENTRY             HAVE WE REACHED THE ENTRY TO THE\n*                                      XPL SUBMONITOR ?\n         BE    GOIO                    YES, GO PROCESS THE REQUEST\n         SPACE 1\n         MVC   XCELL(6),0(ILCR)        FETCH THE NEXT 6 BYTES OF\n*                                      THE INSTRUCTION IMAGE\n         SR    SCR1,SCR1               CLEAR SCR1\n         IC    SCR1,XCELL              THE INSTRUCTION CODE\n         IC    SCR1,OPINDEX(SCR1)      THE INSTRUCTION INDEX\n         LH    SCR1,OPFLAGS(SCR1)      THE INSTRUCTION ATTRIBUTE FLAGS\n         STH   SCR1,FLAGS              SAVE THE FLAGS\n         TM    FLAGS,ILGLBIT           IN THE INSTRUCTION ILLEGAL ?\n         BO    ILGLOP                  YES, GO PRINT MESSAGE AND QUIT\n         TM    FLAGS,BRBIT             IS THE INSTRUCTION\n*                                      A BRANCH OR EXECUTE ?\n         BO    BROP                    YES, GO TO THE BRANCH PROCESSOR\n         STM   0,15,SAVREG             SAVE THE TRACE ROUTINE'S\n*                                      REGISTERS\n         LM    0,2,XCELL               PARAMETERS FOR EXECUTE ROUTINE\n         LM    5,15,REGTBL+4*5         LOAD SOME OF THE PSEUDO\n*                                      REGISTERS (REGISTERS OF THE\n*                                      TRACED PROGRAM)\n         DROP  DATA,HEX2EBC,OSAVE\n         SPACE 1\n         BALR  3,4                     CALL THE EXECUTE ROUTINE IN THE\n*                                      XPL SUBMONITOR\n         USING *,3\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              THE EXECUTE ROUTINE IN THE SUBMONITOR RETURNS HERE     *\n*              WITH A  BALR 1,3  THUS LEAVING THE POSSIBLY MODIFIED   *\n*              CONDITION CODE IN REGISTER 1                           *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         TM    FLAGS,CCBIT             COULD THE INSTRUCTION HAVE\n*                                      CHANGED THE CONDITION CODE ?\n         BZ    NOCC                    NO, NOT A POSSIBILITY\n         SPACE 1\n         SR    SCR0,SCR0               CLEAR SCR0\n         SLL   SCR1,2                  SHIFT OFF LENGTH CODE\n         SLDL  SCR0,2                  CONDITION CODE IN SCR0\n         STC   SCR0,REALCC             SAVE CONDITION CODE IN REALCC\n         SPACE 1\nNOCC     DS    0H\n         LM    0,15,SAVREG             RESTORE TRACE ROUTINE'S\n*                                      REGISTERS\n         USING DATAREA,DATA\n         USING HEXTOEBC,HEX2EBC\n         USING SAVE,OSAVE\n         DROP  3\n         SPACE 1\n         TM    FLAGS,FLOATBIT          FLOATING POINT INSTRUCTION ?\n         BZ    BRETN                   NO, FLOATING REGISTERS\n*                                      ARE UNCHANGED\n         SPACE 1\n         STD   0,F0                    SAVE THE POSSIBLY MODIFIED\n         STD   2,F2                    FLOATING POINT REGISTERS\n         STD   4,F4                    FOR THE PRINT ROUTINES\n         STD   6,F6\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  BRETN       THE BRANCH AND EXECUTE INSTRUCTION PROCESSORS          *\n*              RETURN TO THE MAIN LOOP HERE                           *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBRETN    DS    0H\n         TM    PRINTING,X'FF'          IS PRINTING ENABLED\n         BZ    NOPRTS                  NO, SO SKIP PRINT PHASE\n         SPACE 1\n         BAL   BRFROM,PRINTSUP         CALL THE PRINT SUPERVISOR\n*                                      TO PRINT WHAT HAPPENED\n         SPACE 1\nNOPRTS   DS    0H\n         TM    NOBUMP,X'FF'            SHOULD THE PSEUDO LOCATION\n*                                      COUNTER BE INCREMENTED ?\n         BZ    INCR                    YES, GO INCREMENT\n         MVI   NOBUMP,X'00'            RESET FLAG\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              FETCH THE NEW VALUE FOR THE PSEUDO LOCATION COUNTER    *\n*              THAT WAS PREPARED BY THE BRANCH PROCESSOR              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     ILCR,NEWILC\n         B     CTEST                   GO TO END OF MAIN LOOP\n         SPACE 1\nINCR     DS    0H                      INCREMENT THE PSEUDO LOCATION\n*                                      COUNTER\n         LA    ILCR,2(0,ILCR)          PLUS 2\n         TM    FLAGS+1,RRBIT           TYPE RR INSTRUCTION ?\n         BO    CTEST                   YES, SO DONE INCREMENTING\n         LA    ILCR,2(0,ILCR)          PLUS 2 MORE\n         TM    FLAGS+1,SSBIT           TYPE SS INSTRUCTION ?\n         BZ    CTEST                   NO, SO DONE INCREMENTING\n         LA    ILCR,2(0,ILCR)          PLUS 2 MORE FOR TYPE SS\n         SPACE 1\nCTEST    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  CTEST       HERE WOULD BE A GOOD PLACE TO INSERT AN INCREMENT      *\n*              AND TEST ROUTINE IF IT BECOMES NECESSARY TO            *\n*              LIMIT THE NUMBER OF INSTRUCTIONS THAT ARE TRACED.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         B     MAINLOOP                AROUND THE LOOP AGAIN\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  ILGLOP      ILLEGAL  INSTRUCTION  HANDLING                         *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nILGLOP   DS    0H\n         MVC   PLINE+4(40),ILGMSG      '****  ILLEGAL  INSTRUCTION  '\n         BAL   BRFROM,WRITE            PRINT THE MESSAGE\n         BAL   BRFROM,PRINTSUP         PRINT THE ILLEGAL INSTRUCTION\n         BAL   BRFROM,RDUMP            DUMP THE GENERAL REGISTERS\n         BAL   BRFROM,FDUMP            DUMP THE FLOATING REGISTERS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              RETURN TO THE SUBMONITOR AT THE POINT FROM WHICH TRACE *\n*              WAS CALLED.  USED BY ILGLOP TO TERMINATE THE JOB       *\n*              AFTER AN ILLEGAL INSTRUCTION                           *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         LM    0,15,SAVE               RESTORE ALL REGISTERS\n         BR    CBR                     RETURN TO THE XPLSM SUBMONITOR\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  GOIO        ROUTINE TO PROCESS CALLS TO THE SUBMONITOR             *\n*              WHICH ARE MADE FROM THE PROGRAM BEING TRACED.          *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nGOIO     DS    0H\n         L     SCR0,REGTBL+4*SMBR      GET THE RETURN ADDRESS IN THE\n*                                      TRACED PROGRAM\n         ST    SCR0,IOFROM             SAVE RETURN ADDRESS\n         CLI   REGTBL+4*SVCR+3,TRACEC  IS THE CALL A REQUEST TO\n*                                      BEGIN TRACING ?\n         BE    RETRACE                 YES, GO TO RETRACE\n         CLI   REGTBL+4*SVCR+3,UNTRACE\n*                                      IS THE CALL A REQUEST TO\n*                                      TERMINATE TRACING ?\n         BE    ENDTRACE                YES, GO TO ENDTRACE\n         TM    PRINTING,X'FF'          IS PRINTING ENABLED ?\n         BZ    NOPRIO                  NO, SO REMAIN MUTE\n         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE\n         MVC   PLINE+4(24),IORQM       '       I/O   REQUEST     '\n         L     SCR0,REGTBL+4*PR1       1ST PARAMETER REGISTER\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,PLINE+28      PLACE IN PRINT LINE\n         L     SCR0,REGTBL+4*PR2       SECOND PARAMETER REGISTER\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,PLINE+40      PLACE IN PRINT LINE\n         L     SCR0,REGTBL+4*PR3       3RD PARAMETER REGISTER\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,PLINE+52      PLACE IN PRINT LINE\n         L     SCR0,REGTBL+4*SMBR      RETURN ADDRESS REGISTER\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,PLINE+64      PLACE IN PRINT LINE\n         BAL   BRFROM,WRITE            PRINT THE LINE\n         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE\n         SPACE 1\nNOPRIO   DS    0H\n         STM   0,15,SAVREG             SAVE THE TRACE ROUTINE'S\n*                                      REGISTERS\n         LM    0,15,REGTBL             LOAD THE REGISTERS OF THE\n*                                      TRACED PROGRAM\n         DROP  DATA,OSAVE,HEX2EBC\n         BALR  SMBR,SELF               CALL THE SUBMONITOR\n         SPACE 1\n         USING *,SMBR\n         STM   0,15,REGTBL             SAVE REGISTERS IN THE\n*                                      PSEUDO REGISTER TABLE\n         LM    0,15,SAVREG             RESTORE TRACE ROUTINE'S\n*                                      REGISTERS\n         USING DATAREA,DATA\n         USING HEXTOEBC,HEX2EBC\n         USING SAVE,OSAVE\n         DROP  SMBR\n         L     ILCR,IOFROM             RETURN ADDRESS IN PROGRAM\n         ST    ILCR,REGTBL+4*SMBR      RESTORE RETURN REGISTER ENTRY\n*                                      IN REGTBL\n         B     CTEST                   RETURN TO END OF THE MAIN LOOP\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  ENDTRACE    ROUTINE TO TERMINATE TRACING AND RESUME EXECUTION      *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nENDTRACE DS    0H\n         TM    PRINTING,X'FF'          IS PRINTING ENABLED ?\n         BZ    GOEXEC                  NO, SO SKIP PRINTING\n         L     SCR0,IOFROM             RETURN ADDRESS FOR THE\n*                                      SUBMONITOR CALL\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,ENDADR        PLACE IN MESSAGE\n         MVC   ENDADR(2),BLANKS        TRIM TO SIX HEX DIGITS\n         BAL   BRFROM,RDUMP            DUMP GENERAL REGISTERS\n         BAL   BRFROM,FDUMP            DUMP FLOATING REGISTERS\n         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE\n         MVC   PLINE+4(48),ENDTM       '  RESUME EXECUTION AT:  HHHHHH'\n         BAL   BRFROM,WRITE            PRINT THE MESSAGE\n         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE\n         SPACE 1\nGOEXEC   DS    0H\n         LM    0,15,REGTBL             LOAD THE GENERAL REGISTERS\n*                                      OF THE TRACED PROGRAM\n         BR    CBR                     RESUME EXECUTION OF THE PROGRAM\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  RETRACE     ROUTINE TO PROCESS TRACE REQUESTS ENCOUNTERED WHILE    *\n*              TRACING                                                *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRETRACE  DS    0H\n         TM    PRINTING,X'FF'          IS PRINTING ENABLED ?\n         BZ    RTR2                    NO, SO SKIP PRINTING\n         MVC   PLINE+80(26),RTRM       ' RECURSIVE TRACE REQUEST '\n         BAL   BRFROM,WRITE            PRINT THE MESSAGE\n         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE\n         BAL   BRFROM,RDUMP            DUMP THE GENERAL REGISTERS\n         BAL   BRFROM,FDUMP            DUMP THE FLOATING REGISTERS\n         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE\n         SPACE 1\nRTR2     DS    0H\n         L     ILCR,IOFROM             GET RETURN ADDRESS\n         B     CTEST                   GO TO THE END OF THE MAIN LOOP\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  BROP        ROUTINE TO HANDLE BRANCH AND EXECUTE INSTRUCTIONS      *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBROP     DS    0H\n         TM    FLAGS+1,EXBIT           EXECUTE INSTRUCTION ?\n         BO    EXOP                    YES, GO TO EXECUTE PROCESSOR\n         BAL   BRFROM,BRPROC           CALL THE BRANCH PROCESSOR\n         B     BRETN                   RETURN TO THE MAIN LOOP\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  BRPROC      BRANCH INSTRUCTION PROCESSOR                           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBRPROC   DS    0H\n         ST    BRFROM,BRSV             SAVE RETURN ADDRESS\n         TM    FLAGS+1,RSBIT           BXH OR BXLE ?\n         BO    BXHBXLE                 YES, GO PROCESS\n         TM    XCELL,X'07'             BC (\"47\")  OR  BCR (\"07\") ?\n         BO    BCBCR                   YES, GO PROCESS\n         TM    XCELL,X'02'             BCT (\"46\")  OR  BCTR (\"06\") ?\n         BO    BCTBCTR                 YES, GO PROCESS\n*                                      BY DEFAULT THE INSTRUCTION IS\n*                                      BAL (\"45\")  OR  BALR (\"05\")\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              BAL AND BALR                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         LA    SCR1,2                  COMPUTE INCREMENT TO ILCR\n         TM    FLAGS+1,RRBIT           BALR ?\n         BO    BAL1                    YES, SO INCREMENT IS 2\n         AR    SCR1,SCR1               BAL, SO INCREMENT IS 4\nBAL1     AR    SCR1,ILCR               RETURN ADDRESS FOR BRANCH\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              BUILD UP COMPLETE RETURN REGISTER IN SCR1              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         BALR  SCR0,SCR0               GET PROGRAM MASK BITS\n         N     SCR0,OFOOOOOO           PROGRAM MASK BITS ONLY\n         OR    SCR1,SCR0               INSERT IN THE RETURN\n         L     SCR0,ILC1               GET INSTRUCTION LENGTH BITS\n         TM    FLAGS+1,RXBIT+EXBIT     BAL OR EXECUTE OF A BRANCH ?\n         BZ    BAL2                    NO, BALR SO LENGTH IS 2\n         SLL   SCR0,1                  BAL OR EXECUTED BRANCH\n*                                      LENGTH IS 4\nBAL2     OR    SCR1,SCR0               OR IN INSTRUCTION LENGTH CODE\n         SR    SCR0,SCR0               CLEAR SCR0\n         IC    SCR0,REALCC             GET THE CORRECT CONDITION CODE\n         SLL   SCR0,28                 POSITION IT PROPERLY\n         OR    SCR1,SCR0               OR IN CONDITION CODE BITS\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              SCR1 NOW CONTAINS THE RETURN REGISTER THAT WOULD HAVE  *\n*              RESULTED IN ACTUAL EXECUTION FROM STORING THE RIGHT    *\n*              HALF OF THE PSW                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         IC    SCR2,XCELL+1            RR\n         N     SCR2,OOOOOOFO           R0\n         SRL   SCR2,2                  R*4\n         ST    SCR1,REGTBL(SCR2)       STORE RETURN IN PSEUDO REGISTER\n         TM    FLAGS+1,RXBIT           BAL ?\n         BO    BRXGO                   BAL ALWAYS TRANSFERS\n*                                      GO CALCULATE ADDRESS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  BRRGO       COMPUTATION OF THE BRANCH ADDRESS                      *\n*  BRXGO                                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBRRGO    DS    0H                      TYPE RR,  BRANCH IS TAKEN\n*                                      COMPUTE EFFECTIVE ADDRESS\n         IC    SCR1,XCELL+1            RR\n         N     SCR1,OOOOOOOF           0R\n         BZ    BRTN1                   NO BRANCH IF REGISTER ZERO\n*                                      IS SPECIFIED\n         SLL   SCR1,2                  R*4\n         L     SCR0,OLDREG(SCR1)       GET ADDRESS FROM REGISTER\n         SPACE 1\nBRTN     DS    0H                      SUCCESSFUL BRANCH EXIT\n         ST    SCR0,NEWILC             SAVE BRANCH ADDRESS\n*                                      FOR LOADING AT END OF MAIN LOOP\n         MVI   NOBUMP,X'FF'            SET BRANCH FLAG\n         SPACE 1\nBRTN1    DS    0H                      UNSUCCESSFUL BRANCH EXIT\n         L     BRFROM,BRSV             RESTORE RETURN ADDRESS\n         BR    BRFROM                  RETURN\n         SPACE 1\nBRXGO    DS    0H                      TYPE RX,  BRANCH TAKEN\n         LA    SCR2,XCELL+2            POINT AT BASE,DISPLACEMENT FIELD\n         BAL   BRFROM,EVALXBD          GO EVALUATE EFFECTIVE ADDRESS\n         B     BRTN\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  BCBCR       BC AND BCR                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBCBCR    DS    0H                      CONDITIONAL BRANCH PROCESSOR\n         IC    SCR1,XCELL+1            RR\n         N     SCR1,OOOOOOFO           R0\n         SR    SCR2,SCR2               CLEAR SCR2\n         IC    SCR2,REALCC             ACTUAL CONDITION CODE\n         SLL   SCR2,2                  (CONDITION CODE)*4\n         N     SCR1,CCBITS(SCR2)       MASK BITS CORESPONDING TO\n*                                      THE CONDITION CODE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              IF THE MASK SPECIFIED BY THE R1 FIELD OF THE           *\n*              INSTRUCTION DOES NOT HAVE A ONE BIT THAT CORESPONDS    *\n*              TO THE ONE BIT IN THE MASK REPRESENTING THE CONDITION  *\n*              CODE THEN THE BRANCH IS NOT TAKEN                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         BZ    BRTN1                   BRANCH IS NOT TAKEN\n         TM    FLAGS+1,RXBIT           BC INSTRUCTION ?\n         BO    BRXGO                   YES, GO EVALUATE ADDRESS\n         B     BRRGO                   BCR, GO EVALUATE ADDRESS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  BXHBXLE     BXH AND BXLE                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBXHBXLE  DS    0H                      BXH  BXLE  INSTRUCTION PROCESSOR\n         SR    SCR1,SCR1               CLEAR SCR1\n         IC    SCR1,XCELL+1            RR\n         N     SCR1,OOOOOOOF           0R\n         SLL   SCR1,2                  R3*4\n         L     SCR0,REGTBL(SCR1)       VALUE OF THE INCREMENT\n         SR    SCR2,SCR2               CLEAR SCR2\n         IC    SCR2,XCELL+1            RR\n         N     SCR2,OOOOOOFO           R0\n         SRL   SCR2,2                  R1*4\n         A     SCR0,REGTBL(SCR2)       1ST OPERAND + INCREMENT\n         ST    SCR0,REGTBL(SCR2)       STORE SUM BACK IN R1\n         TM    XCELL+1,X'01'           IS R3 ODD ?\n         BO    CR3                     YES, SO IT IS THE COMPARAND\n         LA    SCR1,4(SCR1)            (R3+1)*4\n         N     SCR1,OOOOOO3C           MODULO 16\nCR3      C     SCR0,REGTBL(SCR1)       COMPARE NEW VALUE AND COMPARAND\n         BH    BHGO                    NEW VALUE IS GREATER\n*                                      NEW VALUE IS LESS THAN OR EQUAL\n         SPACE 1\nBLEGO    TM    XCELL,X'01'             IS THE INSTRUCTION BXLE (\"87\") ?\n         BO    BRXGO                   YES, BXLE SO BRANCH IS TAKEN\n         B     BRTN1                   NO, BXH SO BRANCH IS NOT TAKEN\n         SPACE 1\nBHGO     TM    XCELL,X'01'             IS THE INSTRUCTION BXH (\"86\") ?\n         BZ    BRXGO                   BXH, SO BRANCH IS TAKEN\n         B     BRTN1                   BXLE,  BRANCH IS NOT TAKEN\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  BCTBCTR     BCT AND BCTR                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBCTBCTR  DS    0H                      BCT AND BCTR PROCESSOR\n         IC    SCR2,XCELL+1            RR\n         N     SCR2,OOOOOOFO           R0\n         SRL   SCR2,2                  R1*4\n         L     SCR1,REGTBL(SCR2)       VALUE OF THE INDEX\n         S     SCR1,F1                 SUBTRACT ONE\n         ST    SCR1,REGTBL(SCR2)       STORE NEW VALUE BACK\n         BZ    BRTN1                   NO BRANCH IF NEW VALUE IS ZERO\n         TM    FLAGS+1,RXBIT           BCT OR BCTR ?\n         BO    BRXGO                   BCT, GO EVALUATE ADDRESS\n         B     BRRGO                   BCTR, GO EVALUATE ADDRESS\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  EXOP        EXECUTE INSTRUCTION PROCESSOR                          *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nEXOP     DS    0H\n         LA    SCR2,XCELL+2            POINT TO BASE AND DISPLACEMENT\n         BAL   BRFROM,EVALXBD          EVALUATE THE EFFECTIVE ADDRESS\n*                                      OF THE EXECUTE INSTRUCTION\n         LR    SCR1,SCR0               ADDRESS IS IN SCR0, MOVE IT\n         MVC   PSXCELL(6),0(SCR1)      FETCH 6 BYTES OF THE SUBJECT\n*                                      INSTRUCTION\n         IC    SCR1,XCELL+1            RR  OF THE EXECUTE INSTRUCTION\n         N     SCR1,OOOOOOFO           R0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              IF THE R1 FIELD OF THE EXECUTE INSTRUCTION IS ZERO     *\n*              THEN THE SUBJECT INSTRUCTION IS EXECUTED AS IS.        *\n*              OTHERWISE THE RIGHT HAND BYTE OF THE REGISTER          *\n*              SPECIFIED BY THE R1 FIELD IS OR'ED INTO THE SECOND     *\n*              BYTE OF THE SUBJECT INSTRUCTION                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         BZ    NOOR                    NOTHING TO OR IN\n         SRL   SCR1,2                  R1*4\n         L     SCR2,REGTBL(SCR1)       GET THE BITS TO OR IN\n         EX    SCR2,ORI                OR INTO THE SUBJECT INSTRUCTION\n         SPACE 1\nNOOR     DS    0H\n         SR    SCR1,SCR1               CLEAR SCR1\n         IC    SCR1,PSXCELL            INSTRUCTION CODE OF THE SUBJECT\n*                                      INSTRUCTION\n         IC    SCR1,OPINDEX(SCR1)      INSTRUCTION CODE INDEX\n         LH    SCR1,OPFLAGS(SCR1)      INSTRUCTION CODE ATTRIBUTE FLAGS\n         STH   SCR1,PSFLAGS            SAVE THE FLAGS\n         TM    PSFLAGS,ILGLBIT         IS THE SUBJECT INSTRUCTION\n*                                      ILLEGAL ?\n         BO    ILGLOP                  YES, PRINT MESSAGE AND TERMINATE\n         TM    PSFLAGS,BRBIT           IS THE SUBJECT INSTRUCTION\n*                                      A BRANCH ?\n         BO    EXBR                    YES, GO SIMULATE AN EXECUTED\n*                                      BRANCH INSTRUCTION\n         SPACE 1\n         STM   0,15,SAVREG             SAVE TRACE ROUTINE REGISTERS\n         LM    0,2,PSXCELL             PARAMETERS FOR EXECUTE ROUTINE\n         LM    5,15,REGTBL+4*5         LOAD TRACED PROGRAM'S REGISTERS\n         DROP  DATA,HEX2EBC,OSAVE\n         BALR  3,4                     CALL THE EXECUTE ROUTINE IN\n*                                      THE XPLSM SUBMONITOR\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              EXECUTE ROUTINE RETURNS HERE VIA A BALR 1,3 THUS       *\n*              LEAVING THE POSSIBLY MODIFIED CONDITION CODE IN        *\n*              REGISTER 1                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USING *,3\n         TM    PSFLAGS,CCBIT           WAS THE CONDITION CODE POSSIBLY\n*                                      CHANGED ?\n         BZ    NXCC                    NO, NOT A POSSIBILITY\n         SPACE 1\n         SR    SCR0,SCR0               CLEAR SCR0\n         SLL   SCR1,2                  DELETE INSTRUCTION LENGTH CODE\n         SLDL  SCR0,2                  CONDITION CODE TO SCR0\n         STC   SCR0,REALCC             SAVE CONDITION CODE IN REALCC\n         SPACE 1\nNXCC     DS    0H\n         LM    0,15,SAVREG             RESTORE TRACE ROUTINE REGISTERS\n         USING DATAREA,DATA\n         USING HEXTOEBC,HEX2EBC\n         USING SAVE,OSAVE\n         DROP  3\n         B     BRETN                   RETURN TO THE MAIN LOOP\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  EXBR        ROUTINE TO HANDLE EXECUTED BRANCHES                    *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nEXBR     DS    0H\n         TM    PSFLAGS+1,EXBIT         IS THE SUBJECT INSTRUCTION\n*                                      REALLY AN EXECUTE INSTRUCTION ?\n         BO    ILGLOP                  EXECUTED EXECUTES ARE ILLEGAL\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              MOVE THINGS AROUND TO FOOL THE BRANCH PROCESSOR        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LH    SCR1,FLAGS              SWAP FLAGS AND PSFLAGS\n         LH    SCR2,PSFLAGS\n         STH   SCR1,PSFLAGS\n         STH   SCR2,FLAGS\n         LM    SCR0,SCR1,XCELL         SWAP XCELL AND PSXCELL\n         LM    SCR2,SCR3,PSXCELL\n         STM   SCR0,SCR1,PSXCELL\n         STM   SCR2,SCR3,XCELL\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              SIGNAL AN EXECUTED BRANCH SO THAT THE INSTRUCTION      *\n*              LENGTH CODE COMES OUT RIGHT FOR BAL AND BALR           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         OI    FLAGS+1,EXBIT           SET EXECUTED BRANCH FLAG\n         BAL   BRFROM,BRPROC           CALL THE BRANCH PROCESSOR\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              PUT THINGS BACK THE WAY THEY WERE SO THAT THE EXECUTE  *\n*              INSTRUCTION GETS PRINTED                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LH    SCR1,FLAGS              SWAP FLAGS AND PSFLAGS\n         LH    SCR2,PSFLAGS\n         STH   SCR1,PSFLAGS\n         STH   SCR2,FLAGS\n         LM    SCR0,SCR1,XCELL         SWAP XCELL AND PSXCELL\n         LM    SCR2,SCR3,PSXCELL\n         STM   SCR0,SCR1,PSXCELL\n         STM   SCR2,SCR3,XCELL\n         B     BRETN                   RETURN TO THE MAIN LOOP\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  PRINTSUP    PRINT SUPERVISOR                                       *\n*                                                                     *\n*              THIS ROUTINE CONTROLS THE FABRICATION AND PRINTING     *\n*              OF THE PRINT LINE DESCRIBING EACH INSTRUCTION          *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPRINTSUP DS    0H\n         ST    BRFROM,PRTS             SAVE RETURN\n         SPACE 1\n         BAL   BRFROM,PLINE1           CALL PLINE1\n         SPACE 1\n         BAL   BRFROM,PLINOP           CALL PLINOP\n         SPACE 1\n         BAL   BRFROM,PLINREG          CALL PLINREG\n         SPACE 1\n         BAL   BRFROM,PLINEFA          CALL PLINEFA\n         SPACE 1\n         BAL   BRFROM,WRITE            PRINT THE LINE\n         SPACE 1\n         TM    FLAGS+1,LMSTMBIT        LM OR STM INSTRUCTION ?\n         BZ    NORDMP                  NO\n         SPACE 1\n         BAL   BRFROM,RDUMP            YES, SO DUMP GENERAL REGISTERS\n         SPACE 1\n         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE\n         SPACE 1\nNORDMP   DS    0H\n         L     BRFROM,PRTS             LOAD RETURN ADDRESS\n         BR    BRFROM                  RETURN\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  PLINE1      ROUTINE TO PLACE THE PSEUDO LOCATION COUNTER, THE      *\n*              HEXADECIMAL INSTRUCTION IMAGE, AND THE CONDITION CODE  *\n*              IN THE PRINT LINE                                      *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPLINE1   DS    0H\n         ST    BRFROM,P1S              SAVE RETURN ADDRESS\n         LR    SCR0,ILCR               COPY THE PSEUDO LOCATION COUNTER\n         BALR  BRFROM,HEX2EBC          CONVERT IT FOR PRINTING\n         STM   SCR0,SCR1,ILC           PLACE IT IN THE PRINT LINE\n         MVC   ILC(2),BLANKS           DELETE LEADING ZEROS\n         L     SCR0,XCELL              GET THE INSTRUCTION IMAGE\n         BALR  BRFROM,HEX2EBC          CONVERT 1ST FOUR BYTES\n         ST    SCR0,INSTR              PLACE 1ST 2 BYTES IN PRINT LINE\n         TM    FLAGS+1,RRBIT           TYPE RR INSTRUCTION ?\n         BO    P1CC                    YES, ONLY PRINT TWO BYTES\n         ST    SCR1,INSTR+4            PLACE 2ND 2 BYTES OF THE\n*                                      INSTRUCTION IN THE PRINT LINE\n         TM    FLAGS+1,SSBIT           TYPE SS INSTRUCTION ?\n         BZ    P1CC                    NO, ONLY PRINT 4 BYTES\n         L     SCR0,XCELL+4            GET LAST 2 BYTES OF INSTRUCTION\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         ST    SCR0,INSTR+8            PLACE LAST 2 BYTES IN PRINT LINE\nP1CC     DS    0H                      PLACE THE CONDITION CODE IN THE\n*                                      PRINT LINE\n         SR    SCR1,SCR1               CLEAR SCR1\n         IC    SCR1,REALCC             ACTUAL CONDITION CODE\n         IC    SCR0,EBDCC(SCR1)        GET CORRESPONDING CHARACTER\n         STC   SCR0,CC                 PLACE CHARACTER IN PRINT LINE\n         L     BRFROM,P1S              LOAD RETURN ADDRESS\n         BR    BRFROM                  RETURN\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  PLINOP      ROUTINE TO PLACE THE SYMBOLIC INSTRUCTION CODE AND THE *\n*              INSTRUCTION FIELDS IN ASSEMBLY FORMAT INTO THE         *\n*              PRINT LINE.                                            *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPLINOP   DS    0H\n         ST    BRFROM,P2S              SAVE RETURN ADDRESS\n         SR    SCR1,SCR1               CLEAR SCR1\n         IC    SCR1,XCELL              INSTRUCTION CODE\n         SLL   SCR1,2                  (INSTRUCTION CODE)*4\n         L     SCR0,BCDOP(SCR1)        SYMBOLIC INSTRUCTION CODE\n         ST    SCR0,OP                 PLACE IN PRINT LINE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              PREPARE THE INSTRUCTION FIELDS IN ASSEMBLY FORMAT      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    FLDPT,FIELDS            POINTER TO THE INSTRUCTION\n*                                      FIELDS IN THE PRINT LINE\n         TM    FLAGS+1,IMDFBIT         DOES THE INSTRUCTION CONTAIN\n*                                      AN IMMEDIATE FIELD ?\n         BZ    SPLT                    NO, SO SPLIT THE FIELD INTO R,X\n         SR    SCR1,SCR1               SIGNAL NO INDEX\n         LH    SCR0,XCELL+2            BDDD\n         BAL   BRFROM,BDPROC           'DDD(B)'\n         TM    FLAGS+1,SSBIT           TYPE SS INSTRUCTION ?\n         BZ    FSI                     NO, MUST BE TYPE SI INSTRUCTION\n         S     FLDPT,F3                BACK UP THE FIELD POINTER\n         MVC   4(2,FLDPT),1(FLDPT)     'DDD(   B)'\n         SR    SCR1,SCR1               CLEAR SCR1\n         IC    SCR1,XCELL+1            LL        LENGTH FIELD\n         SRL   SCR1,4                  L\n         IC    SCR1,HEXCHAR(SCR1)      'L'\n         STC   SCR1,1(FLDPT)           'DDD(L  B)'\n         IC    SCR1,XCELL+1            LL\n         N     SCR1,OOOOOOOF            L\n         IC    SCR1,HEXCHAR(SCR1)      'L'\n         STC   SCR1,2(FLDPT)           'DDD(LL B)'\n         MVI   3(FLDPT),C','           'DDD(LL,B)'\n         LA    FLDPT,6(FLDPT)          ADJUST THE FIELD POINTER\n         B     FSS                     GO FINISH TYPE SS INSTRUCTION\n         SPACE 1\nFSI      MVI   0(FLDPT),C','           'DDD(B),'\n         SR    SCR1,SCR1               CLEAR SCR1\n         IC    SCR1,XCELL+1            II        IMMEDIATE FIELD\n         SRL   SCR1,4                  I\n         IC    SCR1,HEXCHAR(SCR1)      'I'\n         STC   SCR1,1(FLDPT)           'DDD(B),I'\n         IC    SCR1,XCELL+1            II\n         N     SCR1,OOOOOOOF            I\n         IC    SCR1,HEXCHAR(SCR1)      'I'\n         STC   SCR1,2(FLDPT)           'DDD(B),II'\n         B     POPDONE                 FINISHED, SO RETURN\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              SPLIT THE SECOND BYTE OF THE INSTRUCTION INTO          *\n*              R,X OR R,R                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSPLT     IC    SCR1,XCELL+1            RX        REGISTER SPECIFIERS\n         N     SCR1,OOOOOOFO           R0\n         SRL   SCR1,4                  R\n         IC    SCR0,HEXCHAR(SCR1)      'R'\n         STC   SCR0,0(0,FLDPT)         'R'\n         MVI   1(FLDPT),C','           'R,'\n         LA    FLDPT,2(FLDPT)          ADJUST FIELD POINTER\n         TM    FLAGS+1,RRBIT+LMSTMBIT\n*                                      IS THE INSTRUCTION TYPE RR OR\n*                                      LM OR STM ?\n         BZ    NOTRR                   NO\n         IC    SCR1,XCELL+1            RR\n         N     SCR1,OOOOOOOF           0R\n         IC    SCR0,HEXCHAR(SCR1)      'R'\n         STC   SCR0,0(0,FLDPT)         'R,R'\n         TM    FLAGS+1,RRBIT           IS THE INSTRUCTION TYPE RR ?\n         BO    POPDONE                 YES, SO FINISHED\n         SR    SCR1,SCR1               NO INDEX FOR LM OR STM\n         MVI   1(FLDPT),C','           'R,R,'\n         LA    FLDPT,2(FLDPT)          ADJUST THE FIELD POINTER\n         B     NOTRR2                  GO EVALUATE BASE, DISPLACEMENT\n         SPACE 1\nNOTRR    IC    SCR1,XCELL+1            RX\n         N     SCR1,OOOOOOOF           0X\nNOTRR2   LH    SCR0,XCELL+2            BDDD      BASE AND DISPLACEMENT\n         BAL   BRFROM,BDPROC           'R,DDD(X,B)'  OR    'R,DDD(B)'\n         B     POPDONE                 FINISHED  SO RETURN\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              FINISH UP TYPE  SS INSTRUCTION                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nFSS      MVI   0(FLDPT),C','           'DDD(LL,B),'\n         LA    FLDPT,1(FLDPT)          ADJUST FIELD POINTER\n         LH    SCR0,XCELL+4            BDDD      2ND BASE,DISPLACEMENT\n         SR    SCR1,SCR1               INDICATE NO INDEX\n         BAL   BRFROM,BDPROC           'DDD(LL,B),DDD(B)'\n         SPACE 1\nPOPDONE  L     BRFROM,P2S              LOAD RETURN ADDRESS\n         BR    BRFROM                  RETURN\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  BDPROC      ROUTINE TO FORMAT THE BASE, DISPLACEMENT, AND INDEX    *\n*              FIELDS INTO ASSEMBLY FORMAT FOR PRINTING               *\n*              INPUT IS A BASE,DISPLACEMENT HALF-WORD IN SCR0 AND THE *\n*              NUMBER OF THE INDEX REGISTER IN SCR1                   *\n*                                                                     *\n*              PLACES EITHER  'DDD(B)' OR 'DDD(X,B)' INTO THE         *\n*              INSTRUCTION IMAGE AT THE POINT SPECIFIED BY FLDPT      *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBDPROC   ST    BRFROM,BDS              SAVE RETURN ADDRESS\n         ST    SCR0,BDT                SAVE  BDDD\n         ST    SCR1,BDT2               SAVE INDEX SPECIFIER\n         N     SCR0,OOOOOFFF           DDD       DISPLACEMENT\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         L     SCR0,BDT2               X         INDEX REGISTER\n         ST    SCR1,BDT2               '0DDD'\n         MVC   0(3,FLDPT),BDT2+1       'DDD'\n         MVI   3(FLDPT),C'('           'DDD('\n         LTR   SCR1,SCR0               IS AN INDEX SPECIFIED ?\n         BZ    BDPNX                   NO, ZERO SPECIFIES NO INDEX\n         IC    SCR1,HEXCHAR(SCR1)      'X'\n         STC   SCR1,4(FLDPT)           'DDD(X'\n         MVI   5(FLDPT),C','           'DDD(X,'\n         LA    FLDPT,2(FLDPT)          ADJUST POINTER FOR THE INDEX\nBDPNX    L     SCR1,BDT                BDDD      BASE, DISPLACEMENT\n         N     SCR1,OOOOFOOO           B000\n         SRL   SCR1,12                 B         BASE REGISTER\n         IC    SCR1,HEXCHAR(SCR1)      'B'\n         STC   SCR1,4(FLDPT)           'DDD(X,B'     OR    'DDD(B'\n         MVI   5(FLDPT),C')'           'DDD(X,B)'    OR    'DDD(B)'\n         LA    FLDPT,6(FLDPT)          ADJUST FIELD POINTER\n         L     BRFROM,BDS              LOAD RETURN ADDRESS\n         BR    BRFROM                  RETURN\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  PLINREG     ROUTINE TO PLACE THE OPERAND REGISTERS REFERENCED      *\n*              BY THE INSTRUCTION INTO THE PRINT LINE                 *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPLINREG  DS    0H\n         TM    FLAGS+1,RRBIT+RXBIT+RSBIT\n*                                      DOES THE INSTRUCTION REFERENCE\n*                                      REGISTERS ?\n         BCR   B'1000',BRFROM          NO, SO RETURN\n         ST    BRFROM,P3S              SAVE RETURN ADDRESS\n         TM    FLAGS,BRBIT             BRANCH INSTRUCTION ?\n         BZ    GR1                     NO\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              INSTRUCTION IS A BRANCH, SO TEST TO SEE IF IT IS       *\n*              A BRANCH CONDITIONAL, IN WHICH CASE THE R1 FIELD       *\n*              IS USED AS A MASK AGAINST THE CONDITION CODE           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   XCELL,X'47'             IS THE INSTRUCTION BC ?\n         BE    R1MASK                  YES\n         CLI   XCELL,X'07'             IS THE INSTRUCTION BCR ?\n         BNE   GR1                     NO\n         SPACE 1\nR1MASK   DS    0H\n         IC    SCR0,FIELDS             R IN EBCDIC\n         STC   SCR0,R1+7               STORE IN REGISTER FIELD\n         LA    SCR2,REGTBL             ADDRESS OF REGISTER TABLE\n         B     RGRR                    GO TEST FOR TYPE RR INSTRUCTION\n         SPACE 1\nGR1      DS    0H\n         IC    SCR1,XCELL+1            RR\n         N     SCR1,OOOOOOFO           R0\n         SRL   SCR1,2                  R*4\n         LA    SCR2,REGTBL             ADDRESS OF REGISTER TABLE\n         TM    FLAGS,FLOATBIT          FLOATING POINT INSTRUCTION ?\n         BZ    FIXD                    NO, USE GENERAL REGISTERS\n         LA    SCR2,F0                 YES, USE FLOATING REGISTERS\n         SPACE 1\nFIXD     DS    0H\n         L     SCR0,0(SCR1,SCR2)       GET THE VALUE OF THE REGISTER\n         ST    SCR1,PRT                SAVE REGISTER NUMBER\n         BALR  BRFROM,HEX2EBC          CONVERT VALUE FOR PRINTING\n         STM   SCR0,SCR1,R1            PLACE IN PRINT LINE\n         TM    FLAGS,DBLBIT            DOUBLE WORD INSTRUCTION ?\n         BZ    RGRR                    NO\n         L     SCR1,PRT                R*4  AGAIN\n         LA    SCR1,4(0,SCR1)          (R+1)*4   SECOND REGISTER NUMBER\n         L     SCR0,0(SCR1,SCR2)       VALUE OF SECOND REGISTER\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,DR1           PLACE IN PRINT LINE\n         TM    FLAGS+1,RRBIT           TYPE RR INSTRUCTION ?\n         BZ    PRDONE                  NO, SO FINISHED\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              GET THE VALUE OF THE 2ND DOUBLE WORD REGISTER          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         IC    SCR1,XCELL+1            RR\n         N     SCR1,OOOOOOOF           0R\n         SLL   SCR1,2                  R*4\n         L     SCR0,0(SCR1,SCR2)       GET REGISTER VALUE\n         ST    SCR1,PRT                SAVE REGISTER NUMBER\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,DR2A          PLACE IN PRINT LINE\n         L     SCR1,PRT                R*4  AGAIN\n         L     SCR0,4(SCR1,SCR2)       GET 2ND HALF OF VALUE\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,DR2B          PLACE IN PRINT LINE\n         B     PRDONE                  FINISHED\n         SPACE 1\nRGRR     DS    0H\n         TM    FLAGS+1,RRBIT           TYPE RR INSTRUCTION ?\n         BZ    PRDONE                  NO, SO DONE\n         IC    SCR1,XCELL+1            RR\n         N     SCR1,OOOOOOOF           0R\n         SLL   SCR1,2                  R*4\n         L     SCR0,0(SCR1,SCR2)       VALUE OF THE REGISTER\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,R2            PLACE IN PRINT LINE\n         SPACE 1\nPRDONE   DS    0H\n         L     BRFROM,P3S              LOAD RETURN ADDRESS\n         BR    BRFROM                  RETURN\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  PLINEFA     ROUTINE TO PLACE THE EFFECTIVE ADDRESS OF THE          *\n*              INSTRUCTION AND THE CONTENTS OF THE MEMORY LOCATION    *\n*              REFERENCED BY THE INSTRUCTION INTO THE PRINT LINE      *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPLINEFA  DS    0H\n         TM    FLAGS+1,RRBIT           TYPE RR INSTRUCTION ?\n         BCR   B'0001',BRFROM          YES, SO NO MEMORY REFERENCE\n         SPACE 1\n         ST    BRFROM,P4S              SAVE RETURN ADDRESS\n         LA    SCR2,XCELL+2            ADDRESS OF BASE, DISPLACEMENT\n         TM    FLAGS+1,RXBIT           TYPE RX INSTRUCTION ?\n         BZ    NOTRX                   NO\n         BAL   BRFROM,EVALXBD          GO EVALUATE ADDRESS WITH INDEX\n         B     PEFA                    GO PLACE IN PRINT LINE\n         SPACE 1\nNOTRX    BAL   BRFROM,EVALBD           GO EVALUATE ADDRESS, NO INDEX\nPEFA     ST    SCR0,EFAT0              SAVE EFFECTIVE ADDRESS\n         BALR  BRFROM,HEX2EBC          CONVERT ADDRESS FOR PRINTING\n         STM   SCR0,SCR1,EFA1          PLACE ADDRESS IN PRINT LINE\n         MVC   EFA1(2),BLANKS          DELETE LEADING ZEROS\n         TM    FLAGS,SHIFTBIT          SHIFT INSTRUCTION ?\n         BO    PEFADONE                YES, SO NO MEMORY REFERENCE\n         CLI   XCELL,X'41'             LOAD ADDRESS INSTRUCTION ?\n         BE    PEFADONE                YES, SO NO MEMORY REFERENCE\n         L     SCR2,EFAT0              EFFECTIVE ADDRESS AGAIN\n         MVC   EFAT0(4),0(SCR2)        CONTENTS OF MEMORY REFERENCED\n         L     SCR0,EFAT0              PLACE CONTENTS IN SCR0\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,EFA1+12       PLACE CONTENTS IN PRINT LINE\n         TM    FLAGS,HALFBIT           HALF WORD INSTRUCTION ?\n         BZ    PEFA1                   NO\n         MVC   EFA1+16(4),BLANKS       YES, ONLY PRINT HALF WORD\n         B     PEFADONE                FINISHED\n         SPACE 1\nPEFA1    DS    0H\n         TM    FLAGS+1,SIBIT           TYPE SI INSTRUCTION ?\n         BZ    PEFA2                   NO\n         MVC   EFA1+14(6),BLANKS       ONLY PRINT ONE BYTE\n         B     PEFADONE                FINISHED\n         SPACE 1\nPEFA2    DS    0H\n         TM    FLAGS,DBLBIT            DOUBLE WORD RX INSTRUCTION ?\n         BZ    PEFA3                   NO\n         MVC   EFAT0(4),4(SCR2)        CONTENTS OF SECOND WORD\n         L     SCR0,EFAT0              PLACE IN SCR0\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,EFA1+20       PLACE IN THE PRINT LINE\n         B     PEFADONE                FINISHED\n         SPACE 1\nPEFA3    DS    0H\n         TM    FLAGS+1,SSBIT           TYPE SS INSTRUCTION ?\n         BZ    PEFADONE                NO, SO FINISHED\n         LA    SCR2,XCELL+4            ADDRESS OF 2ND BASE,DISPLACEMENT\n         BAL   BRFROM,EVALBD           EVALUATE ADDRESS\n         ST    SCR0,EFAT0              SAVE EFFECTIVE ADDRESS\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,EFA2          PLACE IN PRINT LINE\n         MVC   EFA2(2),BLANKS          DELETE LEADING BLANKS\n         L     SCR1,EFAT0              EFFECTIVE ADDRESS AGAIN\n         MVC   EFAT0(4),0(SCR1)        GET CONTENTS OF MEMORY\n         L     SCR0,EFAT0              LOAD CONTENTS INTO SCR0\n         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING\n         STM   SCR0,SCR1,EFA2+12       PLACE IN PRINT LINE\n         SPACE 1\nPEFADONE DS    0H\n         L     BRFROM,P4S              LOAD RETURN ADDRESS\n         BR    BRFROM                  RETURN\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  EVALBD      ROUTINE TO EVALUATE THE MEMORY ADDRESSES OF MEMORY     *\n*  EVALXBD     REFERENCE INSTRUCTIONS                                 *\n*                                                                     *\n*              INPUT IS THE ADDRESS OF A HALF WORD CONTAINING THE     *\n*              BASE AND DISPLACEMENT FIELDS IN SCR2                   *\n*                                                                     *\n*              OUTPUT IS THE EFFECTIVE ADDRESS IN SCR0                *\n*                                                                     *\n*              EVALBD        ASSUMES THAT THERE IS NO INDEX           *\n*                                                                     *\n*              EVALXBD       USES THE INDEX FIELD OF THE INSTRUCTION  *\n*                            IN CALCULATING THE EFFECTIVE ADDRESS     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nEVALBD   DS    0H\n         SR    SCR0,SCR0     VALUE OF THE INDEX IS ZERO\n         B     NOX                     GO EVALUATE BASE, DISPLACEMENT\n         SPACE 2\nEVALXBD  DS    0H\n         SR    SCR0,SCR0               CLEAR SCR0\n         IC    SCR1,XCELL+1            RX\n         N     SCR1,OOOOOOOF           0X\n         BZ    NOX                     REGISTER ZERO IMPLIES NO INDEX\n         SLL   SCR1,2                  X*4\n         L     SCR0,OLDREG(SCR1)       VALUE OF THE INDEX\n         SPACE 1\nNOX      DS    0H                      AT THIS POINT, SCR0 CONTAINS\n*                                      THE VALUE OF THE INDEX\n         IC    SCR1,0(SCR2)            BD\n         N     SCR1,OOOOOOFO           B0        BASE REGISTER\n         BZ    NOB                     REGISTER ZERO IMPLIES NO BASE\n         SRL   SCR1,2                  B*4\n         A     SCR0,OLDREG(SCR1)       INDEX + BASE\n         SPACE 1\nNOB      DS    0H\n         LH    SCR1,0(0,SCR2)          BDDD      BASE, DISPLACEMENT\n         N     SCR1,OOOOOFFF           0DDD      DISPLACEMENT\n         AR    SCR0,SCR1               INDEX + BASE + DISPLACEMENT\n         BR    BRFROM                  RETURN\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  RDUMP       REGISTER DUMP ROUTINES                                 *\n*  FDUMP                                                              *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRDUMP    DS    0H                      DUMP GENERAL REGISTERS\n         ST    BRFROM,RDSV             SAVE RETURN ADDRESS\n         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE\n         LA    SCR2,REGTBL             ADDRESS OF 1ST 8 REGISTERS\n         BAL   BRFROM,RPUT             PLACE THEM IN PRINT LINE\n         MVC   PLINE(10),RM0           ' R0-R7    '\n         BAL   BRFROM,WRITE            PRINT THE LINE\n         LA    SCR2,REGTBL+32          ADDRESS OF 2ND 8 REGISTERS\n         BAL   BRFROM,RPUT             PLACE THEM IN PRINT LINE\n         MVC   PLINE(10),RM8           ' R8-R15   '\n         BAL   BRFROM,WRITE            PRINT THE LINE\n         L     BRFROM,RDSV             LOAD RETURN ADDRESS\n         BR    BRFROM                  RETURN\n         SPACE 4\nFDUMP    DS    0H                      DUMP FLOATING POINT REGISTERS\n         ST    BRFROM,FDSV             SAVE RETURN ADDRESS\n         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE\n         MVC   PLINE(10),FM0           ' F0-F6   '\n         LA    SCR2,F0                 ADDRESS OF FLOATING REGISTER\n*                                      TABLE\n         BAL   BRFROM,RPUT             PLACE THEM IN PRINT LINE\n         BAL   BRFROM,WRITE            PRINT THE LINE\n         L     BRFROM,FDSV             LOAD RETURN ADDRESS\n         BR    BRFROM                  RETURN\n         SPACE 4\nRPUT     DS    0H                      PLACE EIGHT REGISTERS INTO\n*                                      THE PRINT LINE\n         ST    BRFROM,RPSV             SAVE RETURN ADDRESS\n         LA    SCR3,PLINE+16           STARTING POINT IN PRINT LINE\nRNX      L     SCR0,0(SCR2)            GET THE VALUE OF A REGISTER\n         BALR  BRFROM,HEX2EBC          CONVERT IT FOR PRINTING\n         STM   SCR0,SCR1,0(SCR3)       PLACE IN PRINT LINE\n         LA    SCR2,4(0,SCR2)          POINT AT NEXT REGISTER\n         LA    SCR3,12(0,SCR3)         NEXT SPACE IN PRINT LINE\n         C     SCR3,EOL                END OF PRINT LINE ?\n         BL    RNX                     NO, GO GET NEXT REGISTER\n         L     BRFROM,RPSV             YES, LOAD RETURN ADDRESS\n         BR    BRFROM                  RETURN\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  WRITE       ROUTINE TO OUTPUT THE PRINT LINE                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nWRITE    DS    0H\n         ST    SMBR,WTR                SAVE BRANCH REGISTER\n         STM   PR1,PR3,WTS             SAVE PARAMETER REGISTERS\n         L     PR1,PDESC               DESCRIPTOR FOR PRINT LINE\n         LA    SVCR,PRNT               SERVICE CODE FOR PRINTING\n         SR    PR3,PR3                 SPECIFY  OUTPUT(0)\n         SPACE 1\n         BALR  SMBR,SELF               CALL THE XPL SUBMONITOR\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              BLANK THE PRINT LINE                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVI   PLINE,C' '              ONE BLANK TO START\n         MVC   PLINE+1(LPL-1),PLINE    PROPAGATE THE BLANK\n         LM    PR1,PR3,WTS             RESTORE REGISTERS\n         L     SMBR,WTR                RESTORE BRANCH REGISTER\n         BR    BRFROM                  RETURN\n         SPACE 5\nCODEND   DS    0H                      END OF THE TRACE ROUTINE CODE\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              DATA AREA FOR THE TRACE ROUTINE                        *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nDATAREA  DS    0H                      ORIGIN OF THE DATA AREA\n         SPACE 1\nFLAGS    DC    H'0'                    ATTRIBUTE FLAGS DESCRIBING THE\n*                                      CURRENT INSTRUCTION\nHEXCHAR  DC    C'0123456789ABCDEF'     CHARACTER CONSTANT\nNOBUMP   DC    X'00'                   BRANCH INSTRUCTION FLAG\nPRINTING DC    X'FF'                   PRINTING ENABLED FLAG\n*                                      (NOT USED IN THIS VERSION)\nREALCC   DC    X'0'                    ACTUAL CONDITION CODE\nXCELL    DC    F'0'                    A COPY OF THE INSTRUCTION\n         DC    F'0'                    CURRENTLY BEING TRACED\n         DC    A(REGTBL)               ADDRESS OF PSEUDO REGISTER\n*                                      TABLE\nSAVREG   DC    16F'0'                  SAVE REGISTERS HERE WHILE\n*                                      CALLING EXECUTE ROUTINE IN XPLSM\nREGTBL   DC    16F'0'                  REGISTERS OF THE TRACED PROGRAM\nF0       DC    D'0'                    FLOATING POINT REGISTERS\nF2       DC    D'0'                    OF THE TRACED PROGRAM\nF4       DC    D'0'\nF6       DC    D'0'\nOLDREG   DC    16F'0'                  COPY REGISTER TABLE HERE BEFORE\n*                                      EXECUTING THE INSTRUCTION\nAENTRY   DC    F'0'                    ADDRESS OF XPLSM ENTRY POINT\nACONTRL  DC    A(0)                    ADDRESS OF CONTROL PARAMETERS\nNEWILC   DC    F'0'                    NEW VALUE FOR THE LOCATION\n*                                      COUNTER FOR SUCCESSFUL BRANCHES\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              MASKING CONSTANTS                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         DS    0F                      INSURE ALLIGNMENT\nOOOOOOOF DC    X'0000000F'\nOOOOOOFO DC    X'000000F0'\nOOOOOFFF DC    X'00000FFF'\nOOOOFOOO DC    X'0000F000'\nOFOOOOOO DC    X'0F000000'\nOOOOOO3C DC    X'0000003C'\n         DS    0F\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              TEMPORARY STORAGE USED BY THE VARIOUS ROUTINES         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*                                      BY PRINTSUP\n         SPACE 1\nPRTS     DC    F'0'                    RETURN ADDRESS\n         SPACE 1\n*                                      BY PLINE1\n         SPACE 1\nP1S      DC    F'0'                    RETURN ADDRESS\nEBDCC    DC    C'8421'                 CHARACTERS FOR CONDITION CODE\n         DS    0F\n         SPACE 1\n*                                      BY PLINOP\n         SPACE 1\nF3       DC    F'3'                    THE CONSTANT 3\nP2S      DC    F'0'                    RETURN ADDRESS\n         SPACE 1\n*                                      BY BDPROC\n         SPACE 1\nBDS      DC    F'0'                    RETURN ADDRESS\nBDT      DC    F'0'\nBDT2     DS    F\n         SPACE 1\n*                                      BY PLINREG\n         SPACE 1\nP3S      DC    F'0'                    RETURN ADDRESS\nPRT      DC    F'0'\n         SPACE 1\n*                                      BY PLINEFA\n         SPACE 1\nP4S      DC    F'0'                    RETURN ADDRESS\nEFAT0    DC    F'0'\n         SPACE 1\n*                                      BY BRPROC\n         SPACE 1\nCCBITS   DC    X'00000080'             BITS CORESPONDING TO THE\n         DC    X'00000040'             CONDITION CODE\n         DC    X'00000020'\n         DC    X'00000010'\nILC1     DC    X'40000000'             INSTRUCTION LENGTH CODE\n*                                      FOR BAL AND BALR\nF1       DC    F'1'                    THE CONSTANT 1\nBRSV     DC    F'0'                    RETURN ADDRESS\n         SPACE 1\n*                                      BY WRITE\n         SPACE 1\nWTS      DC    3F'0'\nWTR      DC    F'0'                    RETURN ADDRESS\n         DS    0F                      INSURE ALIGNMENT\nPDESC    DC    AL1(LPL-1)              XPL TYPE STRING DESCRIPTOR\n         DC    AL3(PLINE)              FOR THE PRINT LINE\n         SPACE 1\n*                                      BY RDUMP\n         SPACE 1\nRDSV     DC    F'0'                    RETURN ADDRESS\n         SPACE 1\n*                                      BY FDUMP\n         SPACE 1\nFDSV     DC    F'0'                    RETURN ADDRESS\n         SPACE 1\n*                                      BY RPUT\n         SPACE 1\nRPSV     DC    F'0'                    RETURN ADDRESS\nEOL      DC    A(PLINE+16+8*12)        ADDRESS OF END OF PRINT LINE\n         SPACE 1\n*                                      BY EXOP\nORI      OI    PSXCELL+1,0             INSTRUCTION TO OR ONE BYTE\n*                                      INTO THE SUBJECT INSTRUCTION\n*                                      OF AN EXECUTE INSTRUCTION\nPSXCELL  DC    F'0'                    COPY OF THE SUBJECT\n         DC    F'0'                    INSTRUCTION\n         DC    A(REGTBL)               ADDRESS OF THE REGISTER TABLE\nPSFLAGS  DC    H'0'                    ATTRIBUTE FLAGS FOR THE SUBJECT\n*                                      INSTRUCTION\n         SPACE 1\n*                                      BY GOIO\n         SPACE 1\nIOFROM   DC    F'0'                    RETURN ADDRESS FOR SUBMONITOR\n*                                      CALL\n         SPACE 2\n*                                      CHARACTER CONSTANTS\n         SPACE 2\nBLANKS   DC    CL8' '\nFM0      DC    CL10' F0-F6    '\nRM0      DC    C' R0-R7    '\nRM8      DC    C' R8-R15   '\nILGMSG   DC    CL40' ****    ILLEGAL  INSTRUCTION  ****'\nIORQM    DC    CL24'       I/O  REQUEST   '\nRTRM     DC    CL26'    RECURSIVE  TRACE  CALL'\n         DS    0F                      INSURE ALIGNMENT\nENDTM    DC    CL24'  RESUME EXECUTION AT: '\nENDADR   DC    CL24' '\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              THE PRINT LINE                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         DS    0F                      INSURE ALIGNMENT\nPLINE    DC    CL(LPL)' '\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              DEFINE SUBFIELDS WITHIN THE PRINT LINE FOR USE         *\n*              BY THE PRINT ROUTINES                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nILC      EQU   PLINE+4                 LOCATION COUNTER\nINSTR    EQU   PLINE+16                INSTRUCTION IMAGE\nCC       EQU   PLINE+31                CONDITION CODE\nOP       EQU   PLINE+36                SYMBOLIC INSTRUCTION CODE\nFIELDS   EQU   PLINE+44                INSTRUCTION FIELDS\nR1       EQU   PLINE+64                FIRST OPERAND REGISTER\nDR1      EQU   R1+8                    2ND HALF OF 1ST DOUBLE REGISTER\nDR2A     EQU   DR1+12                  2ND DOUBLE REGISTER\nDR2B     EQU   DR2A+8                  2ND HALF OF 2ND DOUBLE REGISTER\nR2       EQU   PLINE+76                SECOND SINGLE REGISTER\nEFA1     EQU   PLINE+88                1ST EFFECTIVE ADDRESS\nEFA2     EQU   PLINE+112               2ND EFFECTIVE ADDRESS\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              DEFINE TO INSTRUCTION CODE FLAG FIELDS USED TO         *\n*              GENERATE THE ATTRIBUTE FLAG TABLE                      *\n*                                                                     *\n*                                                                     *\n*              SHIFTING CONSTANTS FOR FIELD DEFINITIONS               *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nLEFT     EQU   B'100000000'            PLACE IN LEFT HALF OF FLAGS\n         SPACE 1\nRIGHT    EQU   B'000000001'            PLACE IN RIGHT HALF OF FLAGS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              LEFT HALF FIELD DEFINITIONS                            *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nB0       EQU   ILGLBIT*LEFT            ILLEGAL INSTRUCTION\nB1       EQU   CCBIT*LEFT              CONDITION CODE SET\nB2       EQU   BRBIT*LEFT              BRANCH INSTRUCTION\nB3       EQU   HALFBIT*LEFT            HALF WORD INSTRUCTION\nB4       EQU   FULLBIT*LEFT            FULL WORD INSTRUCTION\nB5       EQU   DBLBIT*LEFT             DOUBLE WORD INSTRUCTION\nB6       EQU   FLOATBIT*LEFT           FLOATING POINT INSTRUCTION\nB7       EQU   SHIFTBIT*LEFT           SHIFT INSTRUCTION\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*              RIGHT HALF FIELD DEFINITIONS                           *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nB8       EQU   RRBIT*RIGHT             TYPE RR INSTRUCTION\nB9       EQU   RXBIT*RIGHT             TYPE RX INSTRUCTION\nBA       EQU   RSBIT*RIGHT             TYPE RS INSTRUCTION\nBB       EQU   SIBIT*RIGHT             TYPE SI INSTRUCTION\nBC       EQU   SSBIT*RIGHT             TYPE SS INSTRUCTION\nBD       EQU   IMDFBIT*RIGHT           INSTRUCTION CONTAINS 8-BIT FIELD\nBE       EQU   LMSTMBIT*RIGHT          INSTRUCTION IS LM OR STM\nBF       EQU   EXBIT*RIGHT             EXECUTE INSTRUCTION\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              INSTRUCTION CODE FLAGS                                 *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                  B B B B B B B B B B B B B B B B    *\n*                                  0 1 2 3 4 5 6 7 8 9 A B C D E F    *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nOPFLAGS  DS    0H\n         DC    AL2(B0+B8)          X               X                 00\n         DC    AL2(B2+B8)              X           X                 02\n         DC    AL2(B1+B4+B8)         X     X       X                 04\n         DC    AL2(B4+B8)                  X       X                 06\n         DC    AL2(B1+B5+B8)         X       X     X                 08\n         DC    AL2(B1+B5+B6+B8)      X       X X   X                 0A\n         DC    AL2(B5+B6+B8)                 X X   X                 0C\n         DC    AL2(B1+B4+B6+B8)      X     X   X   X                 0E\n         DC    AL2(B4+B6+B8)               X   X   X                 10\n         DC    AL2(B3+B9)                X           X               12\n         DC    AL2(B4+B9)                  X         X               14\n         DC    AL2(B2+B4+B9+BF)        X   X         X           X   16\n         DC    AL2(B2+B9)              X             X               18\n         DC    AL2(B1+B3+B9)         X   X           X               1A\n         DC    AL2(B0+B9)          X                 X               1C\n         DC    AL2(B1+B4+B9)         X     X         X               1E\n         DC    AL2(B5+B6+B9)                 X X     X               20\n         DC    AL2(B1+B5+B6+B9)      X       X X     X               22\n         DC    AL2(B4+B6+B9)               X   X     X               24\n         DC    AL2(B1+B4+B6+B9)      X     X   X     X               26\n         DC    AL2(B0+BB)          X                     X           28\n         DC    AL2(B2+B4+B6+BA)        X   X   X       X             2A\n         DC    AL2(B4+B7+BA)               X     X     X             2C\n         DC    AL2(B1+B4+B7+BA)      X     X     X     X             2E\n         DC    AL2(BA+BE)                              X       X     30\n         DC    AL2(B1+BB+BD)         X                   X   X       32\n         DC    AL2(BB+BD)                                X   X       34\n         DC    AL2(B0+BB+BD)       X                     X   X       36\n         DC    AL2(B0+BB)          X                     X           38\n         DC    AL2(B0+BC)          X                       X         3A\n         DC    AL2(BC+BD)                                  X X       3C\n         DC    AL2(B1+BC+BD)         X                     X X       3E\n         DC    AL2(BC)                                     X         40\n         DC    AL2(B1+BC)            X                     X         42\n         DC    AL2(B5+B7+BA)                 X   X     X             44\n         DC    AL2(B1+B5+B7+BA)      X       X   X     X             46\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              TABLES OF INDICES FOR EACH POSSIBLE INSTRUCTION        *\n*              CODE INTO THE OPFLAGS TABLE                            *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nOPINDEX  DS    0H\n         DC    X'00000000'  RR00   ...     ...     ...     ...       00\n         DC    X'06020202'    04   SPM     BALR    BCTR    BCR       01\n         DC    X'00000000'    08  *SSK    *ISK    *SVC     ...       02\n         DC    X'00000000'    0C   ...     ...     ...     ...       03\n         DC    X'04040404'    10   LPR     LNR     LTR     LCR       04\n         DC    X'04040404'    14   NR      CLR     0R      XR        05\n         DC    X'06040404'    18   LR      CR      AR      SR        06\n         DC    X'06060404'    1C   MR      DR      ALR     SLR       07\n         DC    X'0A0A0A0A'    20   LPDR    LNDR    LTDR    LCDR      08\n         DC    X'0C000000'    24   HDR     ...     ...     ...       09\n         DC    X'0C0A0A0A'    28   LDR     CDR     ADR     SDR       10\n         DC    X'0C0C0A0A'    2C   MDR     DDR     AWR     SWR       11\n         DC    X'0E0E0E0E'    30   LPER    LNER    LTER    LCER      12\n         DC    X'10000000'    34   HER     ...     ...     ...       13\n         DC    X'100E0E0E'    38   LER     CER     ALR     SER       14\n         DC    X'10100E0E'    3C   MER     DER     AUR     SUR       15\n         DC    X'12141414'  RX4O   STH     LA      STC     IC        16\n         DC    X'16181818'    44   EX      BAL     BCT     BC        17\n         DC    X'121A1A1A'    48   LH      CH      AH      SH        18\n         DC    X'12121414'    4C   MH      ...     CVD     CVB       19\n         DC    X'141C1C1C'    50   ST      ...     ...     ...       20\n         DC    X'1E1E1E1E'    54   N       CL      O       X         21\n         DC    X'141E1E1E'    58   L       C       A       S         22\n         DC    X'14141E1E'    5C   M       D       AL      SL        23\n         DC    X'201C1C1C'    60   STD     ...     ...     ...       24\n         DC    X'1C1C1C1C'    64   ...     ...     ...     ...       25\n         DC    X'20222222'    68   LD      CD      AD      SD        26\n         DC    X'20202222'    6C   MD      DD      AW      SW        27\n         DC    X'241C1C1C'    70   STE     ...     ...     ...       28\n         DC    X'1C1C1C1C'    74   ...     ...     ...     ...       29\n         DC    X'24262626'    78   LE      CE      AE      SE        30\n         DC    X'24242626'    7C   ME      DE      AU      SU        31\n         DC    X'28282828'  RS80  *SSM     ...    *LPSW    ...       32\n         DC    X'28282A2A'    84  *WRD    *RDD     BXH     BXLE      33\n         DC    X'2C2C2E2E'    88   SRL     SLL     SRA     SLA       34\n         DC    X'44444646'    8C   SRDL    SLDL    SRDA    SLDA      35\n         DC    X'30323436'  SI90   STM     TM      MVI    *TS        36\n         DC    X'32323232'    94   NI      CLI     0I      XI        37\n         DC    X'30383838'    98   LM      ...     ...     ...       38\n         DC    X'38383838'    9C  *SI0    *TI0    *HI0    *TCH       39\n         DC    X'38383838'    A0   ...     ...     ...     ...       40\n         DC    X'38383838'    A4   ...     ...     ...     ...       41\n         DC    X'38383838'    A8   ...     ...     ...     ...       42\n         DC    X'38383838'    AC   ...     ...     ...     ...       43\n         DC    X'38383838'    B0   ...     ...     ...     ...       44\n         DC    X'38383838'    B4   ...     ...     ...     ...       45\n         DC    X'38383838'    B8   ...     ...     ...     ...       46\n         DC    X'38383838'    BC   ...     ...     ...     ...       47\n         DC    X'3A3A3A3A'  SSC0   ...     ...     ...     ...       48\n         DC    X'3A3A3A3A'    C4   ...     ...     ...     ...       49\n         DC    X'3A3A3A3A'    C8   ...     ...     ...     ...       50\n         DC    X'3A3A3A3A'    CC   ...     ...     ...     ...       51\n         DC    X'3A3C3C3C'    D0   ...     MVN     MVC     MVZ       52\n         DC    X'3E3E3E3E'    D4   NC      CLC     0C      XC        53\n         DC    X'3A3A3A3A'    D8   ...     ...     ...     ...       54\n         DC    X'3E3E3E3E'    DC   TR      TRT     ED      EDMK      55\n         DC    X'3A3A3A3A'    E0   ...     ...     ...     ...       56\n         DC    X'3A3A3A3A'    E4   ...     ...     ...     ...       57\n         DC    X'3A3A3A3A'    E8   ...     ...     ...     ...       58\n         DC    X'3A3A3A3A'    EC   ...     ...     ...     ...       59\n         DC    X'3A404040'    F0   ...     MVO     PACK    UNPK      60\n         DC    X'3A3A3A3A'    F4   ...     ...     ...     ...       61\n         DC    X'42424242'    F8   ZAP     CP      AP      SP        62\n         DC    X'40403A3A'    FC   MP      DP      ...     ...       63\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              *   INDICATES A PRIVLEDGED INSTRUCTION                 *\n*                                                                     *\n*              ... INDICATES A NON-EXISTENT INSTRUCTION               *\n*                                                                     *\n***********************************************************************\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              SYMBOLIC INSTRUCTION CODES FOR PRINTING                *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBCDOP    DS    0F\n         DC    C'                SPM BALRBCTRBCR '                  000\n         DC    C'SSK ISK SVC                     '                  020\n         DC    C'LPR LNR LTR LCR NR  CLR OR  XR  '                  040\n         DC    C'LR  CR  AR  SR  MR  DR  ALR SLR '                  060\n         DC    C'LPDRLNDRLTDRLCDRHDR             '                  080\n         DC    C'LDR CDR ADR SDR MDR DDR AWR SWR '                  0A0\n         DC    C'LPERLNERLTERLCERHER             '                  0C0\n         DC    C'LER CER AER SER MER DER AUR SUR '                  0E0\n         DC    C'STH LA  STC IC  EX  BAL BCT BC  '                  100\n         DC    C'LH  CH  AH  SH  MH      CVD CVB '                  120\n         DC    C'ST              N   CL  O   X   '                  140\n         DC    C'L   C   A   S   M   D   AL  SL  '                  160\n         DC    C'STD                             '                  180\n         DC    C'LD  CD  AD  SD  MD  DD  AW  SW  '                  1A0\n         DC    C'STE                             '                  1C0\n         DC    C'LE  CE  AE  SE  ME  DE  AU  SU  '                  1E0\n         DC    C'SSM     LPSW    WRD RDD BXH BXLE'                  200\n         DC    C'SRL SLL SRA SLA SRDLSLDLSRDASLDA'                  220\n         DC    C'STM TM  MVI TS  NI  CLI OI  XI  '                  240\n         DC    C'LM              SIO TIO HIO TCH '                  260\n         DC    C'                                '                  280\n         DC    C'                                '                  2A0\n         DC    C'                                '                  2C0\n         DC    C'                                '                  2E0\n         DC    C'                                '                  300\n         DC    C'                                '                  320\n         DC    C'    MVN MVC MVZ NC  CLC OC  XC  '                  340\n         DC    C'                TR  TRT ED  EDMK'                  360\n         DC    C'                                '                  380\n         DC    C'                                '                  3A0\n         DC    C'    MVO PACKUNPK                '                  3C0\n         DC    C'ZAP CP  AP  SP  MP  DP          '                  3E0\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              THE  END                                               *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 5\nDATAEND  DS    0H                      END OF TRACE ROUTINE DATA AREA\n         SPACE 4\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XCOM": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x11Y\\x10l\\x10l\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T11:59:00", "lines": 4204, "newlines": 4204, "modlines": 0, "user": "SOURCE"}, "text": "                                                                              /*\n X          X          CCCCC               OOOOO            M         M\n  X        X          C     C             O     O           MM       MM\n   X      X          C       C           O       O          M M     M M\n    X    X          C         C         O         O         M  M   M  M\n     X  X           C                   O         O         M   M M   M\n      XX            C                   O         O         M    M    M\n      XX            C                   O         O         M         M\n     X  X           C                   O         O         M         M\n    X    X          C         C         O         O         M         M\n   X      X          C       C           O       O          M         M\n  X        X          C     C             O     O           M         M\n X          X          CCCCC               OOOOO            M         M\n\n\n                       THE COMPILER FOR   X P L\n\n\nW. M. MCKEEMAN         J. J. HORNING           D. B. WORTMAN\n\nINFORMATION &          COMPUTER SCIENCE        COMPUTER SCIENCE\nCOMPUTER SCIENCE,      DEPARTMENT,             DEPARTMENT,\n\nUNIVERSITY OF          STANFORD                STANFORD\nCALIFORNIA AT          UNIVERSITY,             UNIVERSITY,\n\nSANTA CRUZ,            STANFORD,               STANFORD,\nCALIFORNIA             CALIFORNIA              CALIFORNIA\n95060                  94305                   94305\n\nDEVELOPED AT THE STANFORD COMPUTATION CENTER, CAMPUS FACILITY,   1966-69\nAND THE UNIVERSITY OF CALIFORNIA COMPUTATION CENTER, SANTA CRUZ, 1968-69.\n\nDISTRIBUTED THROUGH THE SHARE ORGANIZATION.\n                                                                              */\n\n   /*  FIRST WE INITIALIZE THE GLOBAL CONSTANTS THAT DEPEND UPON THE INPUT\n      GRAMMAR.  THE FOLLOWING CARDS ARE PUNCHED BY THE SYNTAX PRE-PROCESSOR  */\n\n   DECLARE NSY LITERALLY '91', NT LITERALLY '42';\n   DECLARE V(NSY) CHARACTER INITIAL ('<ERROR: TOKEN = 0>', ';', ')', '(', ',',\n      ':', '=', '|', '&', '\u00ac', '<', '>', '+', '-', '*', '/', 'IF', 'DO', 'TO',\n      'BY', 'GO', '||', '_|_', 'END', 'BIT', 'MOD', 'THEN', 'ELSE', 'CASE',\n      'CALL', 'GOTO', 'WHILE', 'FIXED', 'LABEL', 'RETURN', 'DECLARE', 'INITIAL',\n      '<STRING>', '<NUMBER>', 'PROCEDURE', 'LITERALLY', 'CHARACTER',\n      '<IDENTIFIER>', '<TYPE>', '<TERM>', '<GROUP>', '<GO TO>', '<ENDING>',\n      '<PROGRAM>', '<REPLACE>', '<PRIMARY>', '<VARIABLE>', '<BIT HEAD>',\n      '<CONSTANT>', '<RELATION>', '<STATEMENT>', '<IF CLAUSE>', '<TRUE PART>',\n      '<LEFT PART>', '<ASSIGNMENT>', '<EXPRESSION>', '<GROUP HEAD>',\n      '<BOUND HEAD>', '<IF STATEMENT>', '<WHILE CLAUSE>', '<INITIAL LIST>',\n      '<INITIAL HEAD>', '<CASE SELECTOR>', '<STATEMENT LIST>',\n      '<CALL STATEMENT>', '<PROCEDURE HEAD>', '<PROCEDURE NAME>',\n      '<PARAMETER LIST>', '<PARAMETER HEAD>', '<LOGICAL FACTOR>',\n      '<SUBSCRIPT HEAD>', '<BASIC STATEMENT>', '<GO TO STATEMENT>',\n      '<STEP DEFINITION>', '<IDENTIFIER LIST>', '<LOGICAL PRIMARY>',\n      '<RETURN STATEMENT>', '<LABEL DEFINITION>', '<TYPE DECLARATION>',\n      '<ITERATION CONTROL>', '<LOGICAL SECONDARY>', '<STRING EXPRESSION>',\n      '<DECLARATION ELEMENT>', '<PROCEDURE DEFINITION>',\n      '<DECLARATION STATEMENT>', '<ARITHMETIC EXPRESSION>',\n      '<IDENTIFIER SPECIFICATION>');\n   DECLARE V_INDEX(12) FIXED INITIAL (1, 16, 22, 26, 31, 34, 35, 37, 39, 42,\n      42, 42, 43);\n   DECLARE C1(NSY) BIT(86) INITIAL (\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 02000 00000 00000 02200 20220 00202 20002 20000 002\",\n      \"(2) 02222 02222 22222 20022 02003 22000 00330 02000 030\",\n      \"(2) 00030 00003 00330 00000 00000 00000 00000 00330 003\",\n      \"(2) 00030 00002 00220 00000 00000 00000 00000 00220 003\",\n      \"(2) 02000 00000 00000 02200 20020 00002 20002 20002 002\",\n      \"(2) 00020 00002 00220 00000 00000 00000 00000 00220 002\",\n      \"(2) 00010 00001 00110 00000 00000 00000 00000 00110 001\",\n      \"(2) 00010 00001 00110 00000 00000 00000 00000 00110 001\",\n      \"(2) 00010 01000 11110 00000 00000 00000 00000 00110 001\",\n      \"(2) 00020 01000 00220 00000 00000 00000 00000 00220 002\",\n      \"(2) 00020 01000 00220 00000 00000 00000 00000 00220 002\",\n      \"(2) 00010 00000 00000 00000 00000 00000 00000 00110 001\",\n      \"(2) 00010 00000 00000 00000 00000 00000 00000 00110 001\",\n      \"(2) 00010 00000 00000 00000 00000 00000 00000 00110 001\",\n      \"(2) 00010 00000 00000 00000 00000 00000 00000 00110 001\",\n      \"(2) 00010 00001 00110 00000 00000 00000 00000 00110 001\",\n      \"(2) 01000 00000 00000 00000 00000 00010 01000 00000 001\",\n      \"(2) 00010 00001 00110 00000 00000 00000 00000 00110 003\",\n      \"(2) 00010 00001 00110 00000 00000 00000 00000 00110 001\",\n      \"(2) 00000 00000 00000 00010 00000 00000 00000 00000 000\",\n      \"(2) 00010 00000 00110 00000 00000 00000 00000 00110 001\",\n      \"(2) 01000 00000 00000 01100 10000 00001 10001 10000 001\",\n      \"(2) 02000 00000 00000 00000 00000 00000 00000 00000 001\",\n      \"(2) 00010 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 00010 00000 00000 00000 00000 00000 00000 00110 001\",\n      \"(2) 02000 00000 00000 02200 20000 00002 20002 20000 002\",\n      \"(2) 02000 00000 00000 02200 20000 00002 20002 20000 002\",\n      \"(2) 00010 00001 00110 00000 00000 00000 00000 00110 001\",\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00000 001\",\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00000 002\",\n      \"(2) 00010 00001 00110 00000 00000 00000 00000 00110 001\",\n      \"(2) 02002 00000 00000 00000 00000 00000 00000 02000 000\",\n      \"(2) 02002 00000 00000 00000 00000 00000 00000 02000 000\",\n      \"(2) 02010 00001 00110 00000 00000 00000 00000 00110 001\",\n      \"(2) 00010 00000 00000 00000 00000 00000 00000 00000 001\",\n      \"(2) 00010 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 02202 02222 22222 20022 02000 22000 00000 00000 000\",\n      \"(2) 02302 02222 22222 20022 02000 22000 00000 00000 000\",\n      \"(2) 02020 00000 00000 00000 00002 00000 00220 00000 020\",\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00100 000\",\n      \"(2) 02002 00000 00000 00000 00000 00000 00000 02000 000\",\n      \"(2) 02333 12222 22222 20022 02002 22000 00220 00000 120\",\n      \"(2) 03002 00000 00000 00000 00000 00000 00000 02000 000\",\n      \"(2) 02202 02222 22221 10022 02000 12000 00000 00000 000\",\n      \"(2) 01000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00000 001\",\n      \"(2) 02000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 00010 00001 00110 00000 00000 00000 00000 00110 001\",\n      \"(2) 02202 02222 22222 20022 02000 22000 00000 00000 000\",\n      \"(2) 02203 03222 22222 20022 02000 22000 00000 00000 000\",\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00010 000\",\n      \"(2) 02303 02222 22222 20022 02000 22000 00000 00000 000\",\n      \"(2) 00010 00000 00110 00000 00000 00000 00000 00110 001\",\n      \"(2) 02000 00000 00000 02200 20220 00002 20002 20000 002\",\n      \"(2) 01000 00000 00000 01100 10000 00001 10001 10000 001\",\n      \"(2) 01000 00000 00000 01100 10000 00001 10001 10000 001\",\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00000 001\",\n      \"(2) 03000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 02101 00100 00000 00011 00000 01000 00000 00000 000\",\n      \"(2) 01000 00000 00000 01100 10010 00001 10001 10000 001\",\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00010 000\",\n      \"(2) 02000 00000 00000 02200 20220 00002 20002 20000 002\",\n      \"(2) 01000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 02002 00000 00000 00000 00000 00000 00000 02000 000\",\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00110 000\",\n      \"(2) 01000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 01000 00000 00000 01100 10210 00001 10001 10000 001\",\n      \"(2) 01000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 01000 00000 00000 01100 10000 00001 10001 10000 001\",\n      \"(2) 01010 00000 00000 00000 00001 00000 00110 00000 010\",\n      \"(2) 01000 00000 00000 00000 00001 00000 00110 00000 010\",\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00000 001\",\n      \"(2) 02202 00210 00000 00022 00000 02000 00000 00000 000\",\n      \"(2) 00010 00001 00110 00000 00000 00000 00000 00110 001\",\n      \"(2) 02000 00000 00000 02200 20220 00302 20002 20000 002\",\n      \"(2) 01000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 01000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 00000 00000 00000 00000 00000 00000 00000 00000 001\",\n      \"(2) 02202 00220 00000 00022 00000 02000 00000 00000 000\",\n      \"(2) 01000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 01000 00000 00000 01100 10010 00001 10001 10001 001\",\n      \"(2) 02002 00000 00000 00000 00000 00000 00000 01000 000\",\n      \"(2) 02000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 02202 00220 00000 00022 00000 02000 00000 00000 000\",\n      \"(2) 02202 01221 11000 00022 01000 02000 00000 00000 000\",\n      \"(2) 02002 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 01000 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 01001 00000 00000 00000 00000 00000 00000 00000 000\",\n      \"(2) 02202 02222 22110 00022 02000 02000 00000 00000 000\",\n      \"(2) 00010 00000 00000 00000 00001 00000 00110 00000 010\");\n   DECLARE NC1TRIPLES LITERALLY '203';\n   DECLARE C1TRIPLES(NC1TRIPLES) FIXED INITIAL (197379, 197385, 197388, 197389,\n      197413, 197414, 197418, 207363, 459523, 459529, 459532, 459533, 459557,\n      459558, 459562, 469507, 525059, 525065, 525068, 525069, 525093, 525094,\n      525098, 535043, 590595, 590601, 590604, 590605, 590629, 590630, 590634,\n      600579, 787203, 787209, 787212, 787213, 787237, 787238, 787242, 797187,\n      852739, 852745, 852748, 852749, 852773, 852774, 852778, 862723, 918275,\n      918281, 918284, 918285, 918309, 918310, 918314, 928259, 983811, 983817,\n      983820, 983821, 983845, 983846, 983850, 993795, 1049347, 1049353, 1049356,\n      1049357, 1049381, 1049382, 1049386, 1059331, 1124867, 1127174, 1180419,\n      1180425, 1180428, 1180429, 1180453, 1180454, 1180458, 1190403, 1245955,\n      1245961, 1245964, 1245965, 1245989, 1245990, 1245994, 1255939, 1377027,\n      1377033, 1377036, 1377037, 1377061, 1377062, 1377066, 1387011, 1452547,\n      1454852, 1454854, 1456897, 1639171, 1639177, 1639180, 1639181, 1639205,\n      1639206, 1639210, 1649155, 1835779, 1835785, 1835788, 1835789, 1835813,\n      1835814, 1835818, 1845763, 1911299, 2032387, 2032393, 2032396, 2032397,\n      2032421, 2032422, 2032426, 2042371, 2228995, 2229001, 2229004, 2229005,\n      2229029, 2229030, 2229034, 2238979, 2490904, 2490912, 2490913, 2490921,\n      3212035, 3212041, 3212044, 3212045, 3212069, 3212070, 3212074, 3222019,\n      3417602, 3539715, 3539721, 3539724, 3539725, 3539749, 3539750, 3539754,\n      3549699, 3680771, 3683076, 3683078, 3685121, 3689499, 3746307, 3748612,\n      3748614, 3750657, 3811843, 3814148, 3814150, 3936810, 4008451, 4010756,\n      4010758, 4012801, 4072962, 4338946, 4338948, 4467203, 4469508, 4469510,\n      4471553, 4598275, 4600580, 4600582, 4602625, 4664065, 4729601, 4794882,\n      4794884, 4915971, 4915977, 4915980, 4915981, 4916005, 4916006, 4916010,\n      4925955, 5188098, 5188100, 5384707, 5387012, 5387014, 5389057, 5833731,\n      5833770);\n   DECLARE PRTB(109) FIXED INITIAL (0, 4671531, 18219, 18248, 4430, 4416, 4419,\n      71, 17, 59, 45, 88, 81, 69, 77, 89, 0, 16949, 18730, 13350, 20266, 828,\n      19260, 91, 36, 24, 42, 0, 0, 18730, 20266, 16949, 19260, 51, 42, 9, 10,\n      11, 0, 0, 9, 0, 9, 0, 20, 0, 4156, 76, 0, 0, 0, 0, 10792, 0, 0, 82, 0, 23,\n      46, 0, 0, 4072962, 91, 23052, 23053, 12, 13, 0, 17988, 82, 61, 11278,\n      11279, 11289, 0, 29, 0, 0, 14393, 68, 61, 56, 0, 58, 1195027, 13105, 18,\n      31, 28, 34, 82, 0, 83, 0, 15367, 0, 82, 0, 9, 0, 0, 3354940, 18952, 0,\n      22070, 0, 22788, 35, 22037, 0);\n   DECLARE PRDTB(109) BIT(8) INITIAL (0, 35, 33, 34, 22, 23, 24, 32, 21, 6, 7,\n      8, 9, 10, 11, 12, 13, 67, 37, 60, 64, 103, 105, 62, 68, 61, 106, 38, 65,\n      39, 66, 69, 107, 73, 43, 85, 88, 89, 82, 72, 86, 83, 87, 84, 48, 40, 18,\n      19, 49, 57, 59, 44, 53, 108, 109, 36, 58, 41, 47, 63, 104, 55, 54, 93, 94,\n      95, 96, 92, 31, 42, 20, 98, 99, 100, 97, 46, 102, 101, 16, 3, 25, 15, 2,\n      71, 28, 70, 27, 29, 30, 45, 17, 5, 56, 1, 75, 74, 14, 4, 79, 78, 52, 26,\n      77, 76, 81, 80, 51, 50, 91, 90);\n   DECLARE HDTB(109) BIT(8) INITIAL (0, 70, 70, 70, 61, 61, 61, 70, 61, 76, 76,\n      76, 76, 76, 76, 76, 76, 65, 72, 43, 91, 50, 51, 62, 66, 52, 75, 73, 79,\n      73, 79, 66, 75, 58, 82, 54, 54, 54, 54, 49, 54, 54, 54, 54, 46, 47, 56,\n      57, 46, 43, 43, 81, 87, 53, 53, 71, 43, 47, 77, 91, 51, 83, 83, 90, 90,\n      90, 90, 90, 88, 47, 45, 44, 44, 44, 44, 69, 50, 50, 63, 68, 61, 63, 68,\n      59, 84, 59, 84, 64, 67, 81, 63, 55, 83, 48, 60, 60, 76, 55, 85, 85, 87,\n      78, 74, 74, 80, 80, 89, 89, 86, 86);\n   DECLARE PRLENGTH(109) BIT(8) INITIAL (0, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,\n      2, 2, 2, 1, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 3, 3, 3, 3, 2, 2, 2, 2, 2,\n      1, 1, 2, 1, 2, 1, 2, 1, 3, 2, 1, 1, 1, 1, 3, 1, 1, 2, 1, 2, 2, 1, 1, 4, 2,\n      3, 3, 2, 2, 1, 3, 2, 2, 3, 3, 3, 1, 2, 1, 1, 3, 2, 2, 2, 1, 2, 4, 3, 2, 2,\n      2, 2, 2, 1, 2, 1, 3, 1, 2, 1, 2, 1, 1, 4, 3, 1, 3, 1, 3, 2, 3, 1);\n   DECLARE CONTEXT_CASE(109) BIT(8) INITIAL (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n   DECLARE LEFT_CONTEXT(1) BIT(8) INITIAL (86, 71);\n   DECLARE LEFT_INDEX(49) BIT(8) INITIAL (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,\n      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2);\n   DECLARE CONTEXT_TRIPLE(0) FIXED INITIAL (0);\n   DECLARE TRIPLE_INDEX(49) BIT(8) INITIAL (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n   DECLARE PR_INDEX(91) BIT(8) INITIAL (1, 17, 23, 29, 34, 35, 40, 40, 40, 40,\n      42, 44, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 46, 46, 46, 47, 48,\n      48, 48, 49, 49, 50, 51, 52, 52, 52, 54, 55, 56, 56, 57, 61, 63, 68, 68,\n      68, 71, 71, 71, 75, 77, 77, 78, 78, 83, 83, 83, 83, 84, 90, 90, 90, 92,\n      92, 93, 93, 93, 94, 94, 94, 94, 94, 94, 96, 96, 98, 98, 98, 98, 100, 100,\n      100, 101, 102, 104, 106, 108, 108, 108, 110, 110);\n\n   /*  END OF CARDS PUNCHED BY SYNTAX                                      */\n\n   /*  DECLARATIONS FOR THE SCANNER                                        */\n\n   /* TOKEN IS THE INDEX INTO THE VOCABULARY V() OF THE LAST SYMBOL SCANNED,\n      CH IS THE LAST CHARACTER SCANNED (HEX CODE),\n      CP IS THE POINTER TO THE LAST CHARACTER SCANNED IN THE CARDIMAGE,\n      BCD IS THE LAST SYMBOL SCANNED (LITERAL CHARACTER STRING). */\n   DECLARE (TOKEN, CH, CP) FIXED, BCD CHARACTER;\n\n   /* SET UP SOME CONVENIENT ABBREVIATIONS FOR PRINTER CONTROL */\n   DECLARE EJECT_PAGE LITERALLY 'OUTPUT(1) = PAGE',\n      PAGE CHARACTER INITIAL ('1'), DOUBLE CHARACTER INITIAL ('0'),\n      DOUBLE_SPACE LITERALLY 'OUTPUT(1) = DOUBLE',\n      X70 CHARACTER INITIAL ('\n                    ');\n\n   /* LENGTH OF LONGEST SYMBOL IN V */\n   DECLARE (RESERVED_LIMIT, MARGIN_CHOP) FIXED;\n\n   /* CHARTYPE() IS USED TO DISTINGUISH CLASSES OF SYMBOLS IN THE SCANNER.\n      TX() IS A TABLE USED FOR TRANSLATING FROM ONE CHARACTER SET TO ANOTHER.\n      CONTROL() HOLDS THE VALUE OF THE COMPILER CONTROL TOGGLES SET IN $ CARDS.\n      NOT_LETTER_OR_DIGIT() IS SIMILIAR TO CHARTYPE() BUT USED IN SCANNING\n      IDENTIFIERS ONLY.\n\n      ALL ARE USED BY THE SCANNER AND CONTROL() IS SET THERE.\n   */\n   DECLARE (CHARTYPE, TX) (255) BIT(8),\n           (CONTROL, NOT_LETTER_OR_DIGIT)(255) BIT(1);\n\n   /* ALPHABET CONSISTS OF THE SYMBOLS CONSIDERED ALPHABETIC IN BUILDING\n      IDENTIFIERS     */\n   DECLARE ALPHABET CHARACTER INITIAL ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_$@#');\n\n   /* BUFFER HOLDS THE LATEST CARDIMAGE,\n      TEXT HOLDS THE PRESENT STATE OF THE INPUT TEXT (INCLUDING MACRO\n      EXPANSIONS AND NOT INCLUDING THE PORTIONS DELETED BY THE SCANNER),\n      TEXT_LIMIT IS A CONVENIENT PLACE TO STORE THE POINTER TO THE END OF TEXT,\n      CARD_COUNT IS INCREMENTED BY ONE FOR EVERY XPL SOURCE CARD READ,\n      ERROR_COUNT TABULATES THE ERRORS AS THEY ARE DETECTED DURING COMPILE,\n      SEVERE_ERRORS TABULATES THOSE ERRORS OF FATAL SIGNIFICANCE.\n   */\n   DECLARE (BUFFER, TEXT, CURRENT_PROCEDURE, INFORMATION) CHARACTER,\n      (TEXT_LIMIT, CARD_COUNT, ERROR_COUNT, SEVERE_ERRORS, PREVIOUS_ERROR) FIXED\n      ;\n\n   /* NUMBER_VALUE CONTAINS THE NUMERIC VALUE OF THE LAST CONSTANT SCANNED,\n      JBASE CONTAINS THE FIELD WIDTH IN BIT STRINGS (DEFAULT VALUE = 4),\n      BASE IS  2**JBASE   (I.E., SHL(1,JBASE) ).\n   */\n   DECLARE (NUMBER_VALUE, JBASE, BASE) FIXED;\n\n   /* EACH OF THE FOLLOWING CONTAINS THE INDEX INTO V() OF THE CORRESPONDING\n      SYMBOL.   WE ASK:    IF TOKEN = IDENT    ETC.    */\n   DECLARE (IDENT, STRING, NUMBER, DIVIDE, EOFILE, ORSYMBOL,\n      CONCATENATE) FIXED;\n\n   /* USED TO SAVE BRANCH ADDRESSES IN DO-LOOP CODE */\n   DECLARE STEPK FIXED;\n\n   /* THE FOLLOWING ARE USED IN THE MACRO EXPANDER.  CONSIDERABLE LOGIC\n      IS DEVOTED TO AVOIDING CREATING STRINGS OF LENGTH > 256, THE STRING LIMIT.\n   */\n   DECLARE BALANCE CHARACTER, LB FIXED;\n   DECLARE MACRO_LIMIT FIXED INITIAL (40), MACRO_NAME(40) CHARACTER,\n      MACRO_TEXT(40) CHARACTER, MACRO_INDEX(256) BIT (8),\n      TOP_MACRO FIXED INITIAL (\"FFFFFFFF\");\n   DECLARE EXPANSION_COUNT FIXED, EXPANSION_LIMIT LITERALLY '300';\n\n   /* STOPIT() IS A TABLE OF SYMBOLS WHICH ARE ALLOWED TO TERMINATE THE ERROR\n      FLUSH PROCESS.  IN GENERAL THEY ARE SYMBOLS OF SUFFICIENT SYNTACTIC\n      HIERARCHY THAT WE EXPECT TO AVOID ATTEMPTING TO START COMPILING AGAIN\n      RIGHT INTO ANOTHER ERROR PRODUCING SITUATION.  THE TOKEN STACK IS ALSO\n      FLUSHED DOWN TO SOMETHING ACCEPTABLE TO A STOPIT() SYMBOL.\n      FAILSOFT IS A BIT WHICH ALLOWS THE COMPILER ONE ATTEMPT AT A GENTLE\n      RECOVERY.   THEN IT TAKES A STRONG HAND.   WHEN THERE IS REAL TROUBLE\n      COMPILING IS SET TO FALSE, THEREBY TERMINATING THE COMPILATION.\n      MAINLOC IS THE SYMBOL TABLE LOCATION OF COMPACTIFY FOR USE IN ERROR().\n   */\n   DECLARE STOPIT(NT) BIT(1), (FAILSOFT, COMPILING) BIT(1), MAINLOC FIXED;\n\n   DECLARE S CHARACTER;  /* A TEMPORARY USED VARIOUS PLACES */\n\n   /* THE ENTRIES IN PRMASK() ARE USED TO SELECT OUT PORTIONS OF CODED\n      PRODUCTIONS AND THE STACK TOP FOR COMPARISON IN THE ANALYSIS ALGORITHM */\n   DECLARE PRMASK(5) FIXED INITIAL (0, 0, \"FF\", \"FFFF\", \"FFFFFF\", \"FFFFFFFF\");\n\n   /* SUBSTR(HEXCODES, I, 1) IS THE HEXADECIMAL CODE LETTER FOR I  */\n   DECLARE HEXCODES CHARACTER INITIAL ('0123456789ABCDEF');\n\n   /*THE PROPER SUBSTRING OF POINTER IS USED TO PLACE AN  |  UNDER THE POINT\n      OF DETECTION OF AN ERROR DURING COMPILATION.  IT MARKS THE LAST CHARACTER\n      SCANNED.  */\n   DECLARE POINTER CHARACTER INITIAL ('\n                                           |');\n   DECLARE (COUNT#STACK, COUNT#SCAN, COUNT#RR, COUNT#RX, COUNT#FORCE,\n      COUNT#ARITH, COUNT#STORE, COUNT#FIXBFW, COUNT#FIXD, COUNT#FIXCHW,\n      COUNT#GETD, COUNT#GETC, COUNT#FIND) FIXED;\n\n   /* RECORD THE TIMES OF IMPORTANT POINTS DURING COMPILATION */\n   DECLARE CLOCK(5) FIXED;\n\n   /* COUNT THE NUMBER OF COMPARISONS OF IDENTIFIERS IN SYMBOL TABLE LOOK-UPS\n      THIS CAN, IN GENERAL, BE EXPECTED TO BE A SUBSTANTIAL PART OF RUN TIME.\n   */\n   DECLARE IDCOMPARES FIXED, STATEMENT_COUNT FIXED;\n   DECLARE TRUELOC FIXED;  /* ADDRESS OF INTEGER 1 IN DATA AREA */\n   DECLARE COMPLOC FIXED; /*  THE ADDRESS OF ALL ONES MASK FOR COMPLEMENT */\n   DECLARE CATCONST FIXED;   /* ADDRESS OF 2**24  */\n   DECLARE BASEDATA FIXED;   /*  BASE REGISTER INITIALIZATION ADDRESS */\n\n   /*  THE EMITTER  ARRAYS  */\n\n\n /******************************************************************************\n\n      WARNING:  THE EMITTER ARRAYS \"CODE\", \"DATA\", AND \"STRINGS\" ARE\n   DEPENDENT ON THE HARDWARE DEVICES AVAILABLE FOR SCRATCH STORAGE.  THE\n   LITERAL CONSTANT \"DISKBYTES\" SHOULD BE EQUAL TO THE BLOCKSIZE OF THESE FILES\n   AS ESTABLISHED IN DCB'S IN THE SUBMONITOR.\n\n   SUGGESTED VALUES:\n            FOR LARGE CORE:             FOR SMALL CORE DISKBYTES = 400.\n\n      2311     DISKBYTES = 3600\n      2314     DISKBYTES = 7200\n      2321     DISKBYTES = 2000\n\n      THIS VERSION OF XCOM NEEDS THREE SCRATCH FILES:\n      1        COMPILED CODE TEMPORARY\n      2        COMPILED DATA TEMPORARY\n      3        CHARACTER STRING TEMPORARY\n      1        BINARY PROGRAM OUTPUT\n\n ******************************************************************************/\n\n   DECLARE DISKBYTES LITERALLY '3600';     /*  2311  DISKS  */\n      /* SIZE OF SCRATCH FILE BLOCKS IN BYTES */\n   DECLARE CODEMAX FIXED;        /* FORCES CODE TO WORD BOUNDARY */\n   DECLARE CODE (DISKBYTES) BIT(8);\n   DECLARE DATAMAX FIXED;     /* FORCES DATA TO WORD BOUNDARY */\n   DECLARE DATA (DISKBYTES) BIT(8);\n   DECLARE STRNGMX FIXED;            /*  AND FORCE STRINGS TO BE ALIGNED  */\n   DECLARE STRINGS (DISKBYTES) BIT(8); /* BUFFER FOR COMPILED STRINGS  */\n\n\n   /*  CODEMAX  IS THE # OF RECORDS OF CODE GENERATED\n       DATAMAX IS THE NUMBER OF RECORDS OF DATA GENERATED\n   */\n\n   DECLARE CODEFILE FIXED INITIAL(1);    /* FILE FOR BINARY CODE, AND */\n   DECLARE BINARYFILE FIXED INITIAL(1);  /* COLLECTION OF ALL COMPILED OUTPUT */\n   DECLARE DATAFILE FIXED INITIAL (2);    /* SCRATCH FILE FOR DATA */\n   DECLARE STRINGFILE FIXED INITIAL (3);\n      /* SCRATCH FILE FOR CHARACTER STRINGS */\n\n   DECLARE (PPORG, PPLIM, DPORG, DPLIM, CURCBLK, CURDBLK, CURSBLK, CHPORG,\n      CHPLIM, STRINGMAX, SHORTDFIX, SHORTCFIX, LONGDFIX, LONGCFIX, FCP) FIXED;\n\n      /* ARRAYS TO HOLD FIXUPS DURING COMPILATION */\n\n   /* FCLIM IS THE NUMBER OF FIXUPS THAT CAN BE RECORDED BEFORE THEY ARE MADE */\n   DECLARE FCLIM LITERALLY '100';\n   DECLARE FIXCADR (FCLIM) FIXED;      /* ADDRESS OF CODE FIXUP  */\n   DECLARE FIXCB1 (FCLIM) BIT(8);      /* 1ST BYTE OF CODE FIXUP  */\n   DECLARE FIXCB2 (FCLIM) BIT(8);      /* 2ND BYTE OF CODE FIXUP  */\n\n   DECLARE LIMITWORD FIXED;\n   DECLARE STRING_RECOVER FIXED;\n\n   DECLARE CATENTRY FIXED;   /*  ENTRY TO CATENATE ROUTINE */\n   DECLARE STRL FIXED;  /* ADDRESS OF LAST STRING COMPUTED FOR OPTIMIZING || */\n   DECLARE STRN FIXED;  /* ADDRESS OF TEMP IN STRING TO NUMBER ROUTINE */\n   DECLARE DESCL FIXED;\n   DECLARE IO_SAVE FIXED;\n   DECLARE NMBRNTRY  FIXED;     /*  ENTRY TO BINARY TO CHAR. CONVERSION */\n   DECLARE TSA FIXED;  /* INTEGER ADDRESS OF TOP-OF-STRINGS  */\n   DECLARE MOVER FIXED;   /*  ADDRESS OF MOVE TEMPLATE  */\n   DECLARE BASES (15) FIXED;    /*  THE VALUE OF THE BASE REGISTERS */\n   DECLARE AVAIL FIXED INITIAL (2);\n   DECLARE INSTRUCT (255) BIT(16);  /*  INSTRUCTION USE COUNTERS */\n   DECLARE DESC(1024) FIXED;  /* STRING DESCRIPTORS, REG 13 RELATIVE */\n\n   /*  360 REGISTER ASSIGNMENTS:\n            0     SCRATCH\n            1-3   ACCUMULATORS\n            4-11  DATA ADDRESSING\n            12    BRANCH REGISTER\n            13    STRING DESCRIPTOR AREA BASE\n            14    PROGRAM BASE\n            15    POINTS TO ENTRY OF I/O PACKAGE\n   */\n\n   DECLARE IOREG LITERALLY '\"F\"';  /* REGISTER FOR IO ROUTINES OF SUBMONITOR */\n   DECLARE PBR LITERALLY '\"E\"';  /* PROGRAM BASE REGISTER POINTS TO CODE  */\n   DECLARE SBR LITERALLY '\"D\"';  /* STRING BASE REGISTER TO ADDRESS DESCRIPT. */\n   DECLARE BRCHREG LITERALLY '\"C\"';  /* REGISTER FOR BRANCHING  */\n   DECLARE DBR LITERALLY '\"B\"';  /* FIRST DATA BASE REGISTER  */\n   DECLARE PROGRAMSIZE LITERALLY '25';  /* NUMBER OF 4096 BYTE PAGES ALLOWED */\n   DECLARE LASTBASE FIXED;   /*  KEEP TRACK OF ALLOCATION OF REG 11 - 4 */\n   DECLARE TARGET_REGISTER FIXED;\n   DECLARE MASKF000 BIT(32);\n   DECLARE ADREG FIXED, ADRDISP FIXED;    /* GLOBALS FOR FINDADDRESS */\n   DECLARE RTNADR FIXED;  /*  WHERE THE PRESENT RETURN ADDRESS IS STORED */\n   DECLARE RETURNED_TYPE BIT (8);\n   DECLARE TEMP(3) FIXED ;         /*  STORAGE FOR SAVE_REGISTERS  */\n   DECLARE (DP, PP, CHP, DSP, NEWDP, NEWDSP) FIXED; /* EMITTER POINTERS */\n   DECLARE ITYPE FIXED;   /*  INITIALIZATION TYPE  */\n   DECLARE STILLCOND FIXED;  /*  REMEMBER CONDITION CODE TEST FOR PEEPHOLE */\n\n   /*  COMMON  IBM  360  OP-CODES  */\n   DECLARE OPNAMES CHARACTER INITIAL ('    BALRBCTRBCR LPR LNR LTR LCR NR  CLR O\nR  XR  LR  CR  AR  SR  MR  DR  ALR SLR LA  STC IC  EX  BAL BCT BC  CVD CVB ST  N\n   CL  O   X   L   C   A   S   M   D   AL  SL  SRL SLL SRA SLA SRDLSLDLSRDASLDAS\nTM TM  MVI NI  CLI OI  XI  LM  MVC STH LH  ');\n   DECLARE OPER(255) BIT(8) INITIAL(\n /*0**/   0,  0,  0,  0,  0,  4,  8, 12,  0,  0,  0,  0,  0,  0,  0,  0,\n /*1**/  16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76,\n /*2**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*3**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*4**/ 236, 80, 84, 88, 92, 96,100,104,240,  0,  0,  0,  0,  0,108,112,\n /*5**/ 116,  0,  0,  0,120,124,128,132,136,140,144,148,152,156,160,164,\n /*6**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*7**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*8**/   0,  0,  0,  0,  0,  0,  0,  0,168,172,176,180,184,188,192,196,\n /*9**/ 200,204,208,  0,212,216,220,224,228,  0,  0,  0,  0,  0,  0,  0,\n /*A**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*B**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*C**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*D**/   0,  0,232,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*E**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*F**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0);\n /*      *0  *1  *2  *3  *4  *5  *6  *7  *8  *9  *A  *B  *C  *D  *E  *F  */\n   DECLARE OP_CODE CHARACTER;  /* FOR DEBUG PRINTOUT */\n   DECLARE COMMUTATIVE(63) BIT(1);  /* RECORD WHICH OPERATORS ARE COMMUTATIVE */\n\n   /* COMMONLY USED /360 OPERATION CODES */\n   DECLARE BC FIXED INITIAL (\"47\"), BCR FIXED INITIAL (\"07\");\n   DECLARE BAL FIXED INITIAL (\"45\"), BALR FIXED INITIAL (\"05\");\n   DECLARE LOAD FIXED INITIAL (\"58\"), STORE FIXED INITIAL (\"50\");\n   DECLARE CMPR FIXED INITIAL (\"59\"), CMPRR FIXED INITIAL (\"19\");\n   DECLARE LA FIXED INITIAL (\"41\");\n\n   /* THE FOLLOWING ARE USED TO HOLD ADDRESS PAIRS IN THE EMITTER FOR || */\n   DECLARE (A1, A2, B1, B2, T1, T2) FIXED;\n\n   /* COMMONLY USED STRINGS */\n   DECLARE X1 CHARACTER INITIAL(' '), X4 CHARACTER INITIAL('    ');\n   DECLARE EQUALS CHARACTER INITIAL (' = '), PERIOD CHARACTER INITIAL ('.');\n\n   /* TEMPORARIES USED THROUGHOUT THE COMPILER */\n   DECLARE CHAR_TEMP CHARACTER;\n   DECLARE (I, J, K, L) FIXED;\n\n   DECLARE TRUE LITERALLY '1', FALSE LITERALLY '0', FOREVER LITERALLY 'WHILE 1';\n\n   /*  SYMBOL  TABLE  VARIABLES  */\n\n   DECLARE HALFWORD     LITERALLY  '1',\n           LABELTYPE    LITERALLY  '2',\n           ACCUMULATOR  LITERALLY  '3',\n           VARIABLE     LITERALLY  '4',\n           CONSTANT     LITERALLY  '5',\n           CONDITION    LITERALLY  '6',\n           CHRTYPE      LITERALLY  '7',\n           FIXEDTYPE    LITERALLY  '8',\n           BYTETYPE     LITERALLY  '9',\n           FORWARDTYPE  LITERALLY '10',\n           DESCRIPT     LITERALLY '11',\n           SPECIAL      LITERALLY '12',\n           FORWARDCALL  LITERALLY '13' ,\n           CHAR_PROC_TYPE LITERALLY '14'\n           ;\n   DECLARE TYPENAME(14) CHARACTER INITIAL ('', 'BIT(16)  ', 'LABEL    ', '', '',\n      '', '', 'CHARACTER', 'FIXED    ', 'BIT(8)   ', '', '', '', '',\n      'CHARACTER PROCEDURE');\n   DECLARE PROCMARK FIXED;  /* START OF LOCAL VARIABLES IN SYMBOL TABLE */\n   DECLARE PARCT FIXED;  /* NUMBER OF PARAMETERS TO CURRENT PROCEDURE */\n   DECLARE NDECSY FIXED;     /* CURRENT NUMBER OF DECLARED SYMBOLS */\n   /* MAXNDECSY IS THE MAXIMUM OF NDECSY OVER A COMPILATION.  IF MAXNDECSY\n      BEGINS TO APPROACH SYTSIZE THEN SYTSIZE SHOULD BE INCREASED */\n   DECLARE MAXNDECSY FIXED;\n\n   DECLARE SYTSIZE LITERALLY '415';  /*   SYMBOL TABLE SIZE   */\n\n   /*  THE SYMBOL TABLE IS INITIALIZED WITH THE NAMES OF ALL\n       BUILTIN FUNCTIONS AND PSEUDO VARIABLES.  THE PROCEDURE\n       INITIALIZE DEPENDS ON THE ORDER AND PLACEMENT OF THESE\n       NAMES.  DUE CAUTION SHOULD BE OBSERVED WHILE MAKING CHANGES .\n   */\n\n   DECLARE SYT (SYTSIZE) CHARACTER          /*  VARIABLE NAME */\n      INITIAL ('','','MONITOR_LINK','TIME_OF_GENERATION',\n         'DATE_OF_GENERATION','COREWORD','COREBYTE','FREEPOINT',\n         'DESCRIPTOR','NDESCRIPT', 'LENGTH','SUBSTR','BYTE','SHL',\n         'SHR','INPUT','OUTPUT','FILE','INLINE','TRACE','UNTRACE',\n         'EXIT','TIME','DATE','CLOCK_TRAP','INTERRUPT_TRAP',\n         'MONITOR','ADDR','COMPACTIFY', '','');\n   DECLARE SYTYPE (SYTSIZE) BIT (8)   /* TYPE OF THE VARIABLE */\n      INITIAL (0,0,FIXEDTYPE,FIXEDTYPE,FIXEDTYPE,FIXEDTYPE,\n         BYTETYPE,FIXEDTYPE,FIXEDTYPE,FIXEDTYPE,SPECIAL,SPECIAL,\n         SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,\n         SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,\n         SPECIAL,SPECIAL,FORWARDCALL,0,0);\n   DECLARE SYBASE (SYTSIZE) BIT (4) INITIAL(0,0,DBR,DBR,DBR,0,0,\n      DBR,SBR,DBR,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,DBR,0,0);\n   DECLARE SYDISP (SYTSIZE) BIT (12)  /* DISPLACEMENT FOR VARIABLE */\n      INITIAL (0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,  10,11,12,13,14,\n         15,16,17,18,19,0,0);\n   DECLARE SYTCO(SYTSIZE) BIT (16);     /* COUNT OF REFERENCES TO SYMBOLS */\n   DECLARE DECLARED_ON_LINE(SYTSIZE) BIT(16);\n\n   /*  THE COMPILER STACKS DECLARED BELOW ARE USED TO DRIVE THE SYNTACTIC\n      ANALYSIS ALGORITHM AND STORE INFORMATION RELEVANT TO THE INTERPRETATION\n      OF THE TEXT.  THE STACKS ARE ALL POINTED TO BY THE STACK POINTER SP.  */\n\n   DECLARE STACKSIZE LITERALLY '75';  /* SIZE OF STACK  */\n   DECLARE PARSE_STACK (STACKSIZE) BIT(8); /* TOKENS OF THE PARTIALLY PARSED\n                                              TEXT */\n   DECLARE TYPE (STACKSIZE) BIT(8);  /* OPERAND TYPE FOR EXPRESSIONS */\n   DECLARE REG (STACKSIZE) BIT(8);   /* ASSOCIATED GENERAL REGISTER */\n   DECLARE INX (STACKSIZE) BIT(8);   /* ASSOCIATED INDEX REGISTER */\n   DECLARE CNT (STACKSIZE) BIT(8);   /* ANNY COUNT, PARAMETERS, SUBSCRIPTS ...*/\n   DECLARE VAR (STACKSIZE) CHARACTER;/* EBCDIC NAME OF ITEM */\n   DECLARE FIXL (STACKSIZE) FIXED;   /* FIXUP LOCATION */\n   DECLARE FIXV (STACKSIZE) FIXED;   /* FIXUP VALUE */\n   DECLARE PPSAVE (STACKSIZE) FIXED; /* ASSOCIATED PROGRAM POINTER */\n\n   /* SP POINTS TO THE RIGHT END OF THE REDUCIBLE STRING IN THE PARSE STACK,\n      MP POINTS TO THE LEFT END, AND\n      MPP1 = MP+1.\n   */\n   DECLARE (SP, MP, MPP1) FIXED;\n\n   /* DECLARE STATEMENTS AND CASE STATEMENTS REQUIRE AN AUXILIARY STACK */\n   DECLARE CASELIMIT LITERALLY '255', CASESTACK(CASELIMIT) FIXED;\n   DECLARE CASEP FIXED;   /* POINTS TO THE CURRENT POSITION IN CASESTACK */\n   DECLARE DCLRM CHARACTER INITIAL ('IDENTIFIER LIST TOO LONG');\n\n\n\n\n   /*               P R O C E D U R E S                                  */\n\n\n\nPAD:\n   PROCEDURE (STRING, WIDTH) CHARACTER;\n      DECLARE STRING CHARACTER, (WIDTH, L) FIXED;\n\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN STRING || SUBSTR(X70, 0, WIDTH-L);\n   END PAD;\n\nI_FORMAT:\n   PROCEDURE (NUMBER, WIDTH) CHARACTER;\n      DECLARE (NUMBER, WIDTH, L) FIXED, STRING CHARACTER;\n\n      STRING = NUMBER;\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN SUBSTR(X70, 0, WIDTH-L) || STRING;\n   END I_FORMAT;\n\nERROR:\n   PROCEDURE(MSG, SEVERITY);\n      /* PRINTS AND ACCOUNTS FOR ALL ERROR MESSAGES */\n      /* IF SEVERITY IS NOT SUPPLIED, 0 IS ASSUMED */\n      DECLARE MSG CHARACTER, SEVERITY FIXED;\n      ERROR_COUNT = ERROR_COUNT + 1;\n      /* IF LISTING IS SUPPRESSED, FORCE PRINTING OF THIS LINE */\n      IF \u00ac CONTROL(BYTE('L')) THEN\n         OUTPUT = I_FORMAT (CARD_COUNT, 4) || ' |' || BUFFER || '|';\n      OUTPUT = SUBSTR(POINTER, TEXT_LIMIT+LB-CP+MARGIN_CHOP);\n      /* SEVERITY(-1) IS A PORNOGRAPHIC WAY OF OBTAINING THE RETURN ADDRESS */\n      OUTPUT = '*** ERROR, ' || MSG || ' (DETECTED AT LOCATION '\n             || (SEVERITY(-1)&\"FFFFFF\") - ADDR(COMPACTIFY) + MAINLOC\n            || ' IN XCOM).  LAST PREVIOUS ERROR WAS DETECTED ON LINE ' ||\n            PREVIOUS_ERROR || '.  ***';\n      PREVIOUS_ERROR = CARD_COUNT;\n      IF SEVERITY > 0 THEN\n         IF SEVERE_ERRORS > 25 THEN\n            DO;\n               OUTPUT = '*** TOO MANY SEVERE ERRORS, COMPILATION ABORTED ***';\n               COMPILING = FALSE;\n            END;\n         ELSE SEVERE_ERRORS = SEVERE_ERRORS + 1;\n   END ERROR;\n\n\n   /*                      FILE HANDLING PROCEDURES                          */\n\n\n\nGETDATA:\n   PROCEDURE;\n      /* HANDLE SCRATCH STORAGE ALLOCATION FOR THE DATA ARRAY  */\n      DECLARE I FIXED;\n      COUNT#GETD = COUNT#GETD + 1;\n      FILE(DATAFILE,CURDBLK) = DATA;     /*  WRITE OUT CURRENT BLOCK */\n      CURDBLK = DP / DISKBYTES;          /* CALCULATE NEW BLOCK NUMBER */\n      DPORG = CURDBLK * DISKBYTES;\n      DPLIM = DPORG + DISKBYTES;\n      IF CURDBLK <= DATAMAX THEN\n            DATA = FILE(DATAFILE,CURDBLK);\n      ELSE\n         DO;\n            /*  ZERO OUT THE NEW DATA BLOCK  */\n            DO I = 1 TO SHR(DISKBYTES,2);\n               DATAMAX(I) = 0;\n            END;\n            DO DATAMAX = DATAMAX + 1 TO CURDBLK - 1;\n               FILE(DATAFILE,DATAMAX)= DATA;\n            END;\n         END;\n   END  GETDATA;\n\nGETCODE:\n   PROCEDURE;\n      /*  HANDLE SCRATCH STORAGE ALLOCATION FOR THE CODE ARRAY */\n      DECLARE I FIXED;\n      COUNT#GETC = COUNT#GETC + 1;\n      FILE(CODEFILE,CURCBLK) = CODE;\n      CURCBLK = PP / DISKBYTES;       /* CALCULATE NEW BLOCK NUMBER */\n      PPORG = CURCBLK * DISKBYTES;\n      PPLIM = PPORG + DISKBYTES;\n      IF CURCBLK <= CODEMAX THEN\n               CODE = FILE(CODEFILE,CURCBLK);\n      ELSE\n         DO;\n         /*  ZERO OUT THE NEW CODE BLOCK */\n            DO I = 1 TO SHR(DISKBYTES,2);\n               CODEMAX(I) = 0;\n            END;\n            DO CODEMAX = CODEMAX + 1 TO CURCBLK - 1;\n               FILE(CODEFILE,CODEMAX) = CODE;\n            END;\n         END;\n   END  GETCODE;\n\nGETSTRINGS:\n   PROCEDURE;\n      /* HANDLE SCRATCH STORAGE ALLOCATION FOR STRING ARRAY */\n      FILE(STRINGFILE, CURSBLK) = STRINGS;    /* WRITE INTO THE FILE */\n      CURSBLK = CHP / DISKBYTES;              /* COMPUTE NEW BLOCK NUMBER */\n      CHPORG = CURSBLK*DISKBYTES;             /* NEW BLOCK ORIGIN */\n      CHPLIM = CHPORG + DISKBYTES;            /* NEW UPPER BOUND */\n      IF CURSBLK <= STRINGMAX THEN\n         STRINGS = FILE(STRINGFILE,CURSBLK);  /* READ BACK FROM FILE */\n      ELSE\n         DO STRINGMAX = STRINGMAX+1 TO CURSBLK - 1;\n            FILE(STRINGFILE,STRINGMAX) = STRINGS;\n            /* FILL OUT FILE SO NO GAPS EXIST */\n         END;\n   END GETSTRINGS;\n\n\n\n  /*                   CARD IMAGE HANDLING PROCEDURE                      */\n\n\nGET_CARD:\n   PROCEDURE;\n      /* DOES ALL CARD READING AND LISTING                                 */\n      DECLARE I FIXED, (TEMP, TEMP0, REST) CHARACTER, READING BIT(1);\n      IF LB > 0 THEN\n         DO;\n            TEXT = BALANCE;\n            TEXT_LIMIT = LB - 1;\n            CP = 0;\n            RETURN;\n         END;\n      EXPANSION_COUNT = 0;   /* CHECKED IN SCANNER MACRO EXPANSION */\n      IF READING THEN\n         DO; /* 'READING' IS FALSE DURING COMPILE OF LIBRARY FROM INPUT(2) */\n            BUFFER = INPUT;\n            IF LENGTH(BUFFER) = 0 THEN\n               DO; /* SIGNAL FOR EOF */\n                  CALL ERROR ('EOF MISSING OR COMMENT STARTING IN COLUMN 1.',1);\n                  BUFFER = PAD (' /*''/* */ EOF;END;EOF', 80);\n               END;\n            ELSE CARD_COUNT = CARD_COUNT + 1;  /* USED TO PRINT ON LISTING */\n         END;\n      ELSE\n         DO; /* WHILE READING LIBRARY FILE ONLY */\n            BUFFER = INPUT(2);\n            IF LENGTH(BUFFER) = 0 THEN\n               DO;  /* SIGNAL TO SWITCH TO SYSIN */\n                  CONTROL(BYTE('L')), READING = TRUE;  /* TURN ON LISTING */\n                  CONTROL(BYTE('D')) = TRUE;    /* TURN ON SYMBOL DUMP  */\n                  CLOCK(1) = TIME;  /* KEEP TRACK OF TIME FOR COMPILE RATE */\n                  TEXT = X1;  /* INITIALIZE TEXT FOR SCAN */\n                  /* STATEMENTS ARE COUNTED FOR STATISTICS */\n                  STATEMENT_COUNT = -1;\n                  TEXT_LIMIT = 0;\n                  PROCMARK = NDECSY + 1;\n                  RETURN;\n               END;\n         END;\n      IF MARGIN_CHOP > 0 THEN\n         DO; /* THE MARGIN CONTROL FROM DOLLAR | */\n            I = LENGTH(BUFFER) - MARGIN_CHOP;\n            REST = SUBSTR(BUFFER, I);\n            BUFFER = SUBSTR(BUFFER, 0, I);\n         END;\n      ELSE REST = '';\n      TEXT = BUFFER;\n      TEXT_LIMIT = LENGTH(TEXT) - 1;\n      IF CONTROL(BYTE('M')) THEN OUTPUT = BUFFER;\n      ELSE IF CONTROL(BYTE('L')) THEN\n         DO;\n            REST = I_FORMAT (PP, 6) || REST;\n            OUTPUT = I_FORMAT (CARD_COUNT, 4) || ' |' || BUFFER || '|' ||\n               REST || CURRENT_PROCEDURE || INFORMATION;\n         END;\n      INFORMATION = '';\n      CP = 0;\n   END GET_CARD;\n\n\n   /*                THE SCANNER PROCEDURES              */\n\n\nCHAR:\n   PROCEDURE;\n      /* USED FOR STRINGS TO AVOID CARD BOUNDARY PROBLEMS */\n      CP = CP + 1;\n      IF CP <= TEXT_LIMIT THEN RETURN;\n      CALL GET_CARD;\n   END CHAR;\n\nDEBLANK:\n   PROCEDURE;\n      /* USED BY BCHAR */\n      CALL CHAR;\n      DO WHILE BYTE(TEXT, CP) = BYTE(' ');\n         CALL CHAR;\n      END;\n   END DEBLANK;\n\nBCHAR:\n   PROCEDURE;\n      /* USED FOR BIT STRINGS */\n      DO FOREVER;\n         CALL DEBLANK;\n         CH = BYTE(TEXT, CP);\n         IF CH \u00ac= BYTE('(') THEN RETURN;\n         /*  (BASE WIDTH)  */\n         CALL DEBLANK;\n         JBASE = BYTE(TEXT, CP) - \"F0\";  /* WIDTH */\n         IF JBASE < 1 | JBASE > 4 THEN\n            DO;\n               CALL ERROR ('ILLEGAL BIT STRING WIDTH: ' || SUBSTR(TEXT, CP, 1));\n               JBASE = 4;  /* DEFAULT WIDTH FOR ERROR */\n            END;\n         BASE = SHL(1, JBASE);\n         CALL DEBLANK;\n         IF BYTE(TEXT, CP) \u00ac= BYTE(')') THEN\n            CALL ERROR ('MISSING ) IN BIT STRING', 0 );\n      END;\n   END BCHAR;\n\nBUILD_BCD:\n   PROCEDURE (C);\n      DECLARE C BIT(8);\n      IF LENGTH(BCD) > 0 THEN\n         BCD = BCD || X1;\n      ELSE\n         BCD = SUBSTR(X1 || X1, 1);\n      /* FORCE BCD TO THE TOP OF FREE STRING AREA AND INCREASE LENGTH\n          BY ONE  */\n      /* THIS LINE DEPENDS UPON THE IMPLEMENTATION OF XPL STRINGS */\n      COREBYTE(FREEPOINT-1) = C;\n   END BUILD_BCD;\n\nSCAN:\n   PROCEDURE;\n      DECLARE (S1, S2) FIXED;\n      DECLARE LSTRNGM CHARACTER INITIAL('STRING TOO LONG');\n      COUNT#SCAN = COUNT#SCAN + 1;\n      FAILSOFT = TRUE;\n      BCD = '';  NUMBER_VALUE = 0;\n   SCAN1:\n      DO FOREVER;\n         IF CP > TEXT_LIMIT THEN CALL GET_CARD;\n         ELSE\n            DO; /* DISCARD LAST SCANNED VALUE */\n               TEXT_LIMIT = TEXT_LIMIT - CP;\n               TEXT = SUBSTR(TEXT, CP);\n               CP = 0;\n            END;\n         /*  BRANCH ON NEXT CHARACTER IN TEXT                  */\n         DO CASE CHARTYPE(BYTE(TEXT));\n\n            /*  CASE 0  */\n\n            /* ILLEGAL CHARACTERS FALL HERE  */\n            CALL ERROR ('ILLEGAL CHARACTER: ' || SUBSTR(TEXT, 0, 1));\n\n            /*  CASE 1  */\n\n            /*  BLANK  */\n            DO;\n               CP = 1;\n               DO WHILE BYTE(TEXT, CP) = BYTE(' ') & CP <= TEXT_LIMIT;\n                  CP = CP + 1;\n               END;\n               CP = CP - 1;\n            END;\n\n            /*  CASE 2  */\n\n            /*  STRING QUOTE ('):  CHARACTER STRING  */\n            DO FOREVER;\n               TOKEN = STRING;\n               S1 = 1;\n               CP = CP + 1;\n               DO WHILE BYTE(TEXT, CP) \u00ac= BYTE('''');\n                  IF CP <= TEXT_LIMIT THEN\n                     CP = CP+1;\n                  ELSE\n                     DO; /* STRING BROKEN ACROSS CARD BOUNDARY */\n                        IF LENGTH(BCD) + CP > 257 THEN\n                           DO;\n                              CALL ERROR(LSTRNGM  ,0);\n                              RETURN;\n                           END;\n                        IF CP > S1 THEN\n                           BCD = BCD || SUBSTR(TEXT,S1,CP-S1);\n                        TEXT = X1;\n                        CP = 0;\n                        CALL GET_CARD;\n               S1 = 0;\n                     END;\n               END;\n               IF LENGTH(BCD) + CP > 257 THEN\n                  DO;\n                     CALL ERROR(LSTRNGM,0);\n                     RETURN;\n                  END;\n               IF CP > S1 THEN\n                  BCD = BCD || SUBSTR(TEXT,S1,CP-S1);\n               CALL CHAR;\n               IF BYTE(TEXT, CP) \u00ac= BYTE('''') THEN\n                  RETURN;\n               IF LENGTH(BCD) > 255 THEN\n                  DO;\n                     CALL ERROR(LSTRNGM,0);\n                     RETURN;\n                  END;\n               BCD = BCD || '''';\n               TEXT_LIMIT = TEXT_LIMIT - CP;\n               TEXT = SUBSTR(TEXT,CP);\n               CP = 0;   /* PREPARE TO RESUME SCANNING STRING */\n            END;\n\n            /*  CASE 3  */\n\n            DO;      /*  BIT QUOTE(\"):  BIT STRING  */\n               JBASE = 4;  BASE = SHL(1, JBASE);  /* DEFAULT WIDTH  */\n               TOKEN = NUMBER;  /* ASSUME SHORT BIT STRING */\n               S1 = 0;\n               CALL BCHAR;\n               DO WHILE CH \u00ac= BYTE('\"');\n                  S1 = S1 + JBASE;\n                  IF CH >= \"F0\" THEN S2 = CH - \"F0\";  /* DIGITS */\n                  ELSE S2 = CH - \"B7\";                /* LETTERS */\n                  IF S2 >= BASE | S2 < 0 THEN\n                     CALL ERROR ('ILLEGAL CHARACTER IN BIT STRING: '\n                     || SUBSTR(TEXT, CP, 1));\n                  IF S1 > 32 THEN TOKEN = STRING;     /* LONG BIT STRING */\n                  IF TOKEN = STRING THEN\n                     DO WHILE S1 - JBASE >= 8;\n                        IF LENGTH(BCD) > \"FF\" THEN\n                           DO;\n                              CALL ERROR (LSTRNGM, 0);\n                              RETURN;\n                           END;\n                        S1 = S1 - 8;\n                        CALL BUILD_BCD (SHR(NUMBER_VALUE, S1-JBASE));\n                     END;\n                  NUMBER_VALUE = SHL(NUMBER_VALUE, JBASE) + S2;\n                  CALL BCHAR;\n               END;     /* OF DO WHILE CH...  */\n               CP = CP + 1;\n               IF TOKEN = STRING THEN\n                  IF LENGTH(BCD) > \"FF\" THEN CALL ERROR (LSTRNGM, 0);\n                  ELSE CALL BUILD_BCD (SHL(NUMBER_VALUE, 8 - S1));\n               RETURN;\n            END;\n\n            /*  CASE 4  */\n\n            DO FOREVER;  /* A LETTER:  IDENTIFIERS AND RESERVED WORDS */\n               DO CP = CP + 1 TO TEXT_LIMIT;\n                  IF NOT_LETTER_OR_DIGIT(BYTE(TEXT, CP)) THEN\n                     DO;  /* END OF IDENTIFIER  */\n                        IF CP > 0 THEN BCD = BCD || SUBSTR(TEXT, 0, CP);\n                        S1 = LENGTH(BCD);\n                        IF S1 > 1 THEN IF S1 <= RESERVED_LIMIT THEN\n                           /* CHECK FOR RESERVED WORDS */\n                           DO I = V_INDEX(S1-1) TO V_INDEX(S1) - 1;\n                              IF BCD = V(I) THEN\n                                 DO;\n                                    TOKEN = I;\n                                    RETURN;\n                                 END;\n                           END;\n                        DO I = MACRO_INDEX(S1-1) TO MACRO_INDEX(S1) - 1;\n                           IF BCD = MACRO_NAME(I) THEN\n                              DO;\n                                 BCD = MACRO_TEXT(I);\n                                 IF EXPANSION_COUNT < EXPANSION_LIMIT THEN\n                                    EXPANSION_COUNT = EXPANSION_COUNT + 1;\n                                 ELSE OUTPUT =\n                                    '*** WARNING, TOO MANY EXPANSIONS FOR ' ||\n                                    MACRO_NAME(I) || ' LITERALLY: ' || BCD;\n                                 TEXT = SUBSTR(TEXT, CP);\n                                 TEXT_LIMIT = TEXT_LIMIT - CP;\n                                 IF LENGTH(BCD) + TEXT_LIMIT > 255 THEN\n                                    DO;\n                                       IF LB + TEXT_LIMIT > 255 THEN\n                                         CALL ERROR('MACRO EXPANSION TOO LONG');\n                                       ELSE\n                                          DO;\n                                             BALANCE = TEXT || BALANCE;\n                                             LB = LENGTH(BALANCE);\n                                             TEXT = BCD;\n                                          END;\n                                    END;\n                                 ELSE TEXT = BCD || TEXT;\n                                 BCD = '';\n                                 TEXT_LIMIT = LENGTH(TEXT) - 1;\n                                 CP = 0;\n                                 GO TO SCAN1;\n                              END;\n                        END;\n                        /*  RESERVED WORDS EXIT HIGHER: THEREFORE <IDENTIFIER>*/\n                        TOKEN = IDENT;\n                        RETURN;\n                     END;\n               END;\n               /*  END OF CARD  */\n               BCD = BCD || TEXT;\n               CALL GET_CARD;\n               CP = -1;\n            END;\n\n            /*  CASE 5  */\n\n            DO;      /*  DIGIT:  A NUMBER  */\n               TOKEN = NUMBER;\n               DO FOREVER;\n                  DO CP = CP TO TEXT_LIMIT;\n                     S1 = BYTE(TEXT, CP);\n                     IF S1 < \"F0\" THEN RETURN;\n                     NUMBER_VALUE = 10*NUMBER_VALUE + S1 - \"F0\";\n                  END;\n                  CALL GET_CARD;\n               END;\n            END;\n\n            /*  CASE 6  */\n\n            DO;      /*  A /:  MAY BE DIVIDE OR START OF COMMENT  */\n               CALL CHAR;\n               IF BYTE(TEXT, CP) \u00ac= BYTE('*') THEN\n                  DO;\n                     TOKEN = DIVIDE;\n                     RETURN;\n                  END;\n               /* WE HAVE A COMMENT  */\n               S1, S2 = BYTE(' ');\n               DO WHILE S1 \u00ac= BYTE('*') | S2 \u00ac= BYTE('/');\n                  IF S1 = BYTE('$') THEN\n                     DO;  /* A CONTROL CHARACTER  */\n                        CONTROL(S2) = \u00ac CONTROL(S2);\n                        IF S2 = BYTE('T') THEN CALL TRACE;\n                        ELSE IF S2 = BYTE('U') THEN CALL UNTRACE;\n                        ELSE IF S2 = BYTE('|') THEN\n                           IF CONTROL(S2) THEN\n                              MARGIN_CHOP = TEXT_LIMIT - CP + 1;\n                           ELSE\n                              MARGIN_CHOP = 0;\n                     END;\n                  S1 = S2;\n                  CALL CHAR;\n                  S2 = BYTE(TEXT, CP);\n               END;\n            END;\n\n            /*  CASE 7  */\n            DO;      /*  SPECIAL CHARACTERS  */\n               TOKEN = TX(BYTE(TEXT));\n               CP = 1;\n               RETURN;\n            END;\n\n            /*  CASE 8  */\n            DO;  /* A |:  MAY BE \"OR\" OR \"CAT\"  */\n               CALL CHAR;\n               IF BYTE(TEXT, CP) = BYTE('|') THEN\n                  DO;\n                     CALL CHAR;\n                     TOKEN = CONCATENATE;\n                  END;\n               ELSE TOKEN = ORSYMBOL;\n               RETURN;\n            END;\n\n         END;     /* OF CASE ON CHARTYPE  */\n         CP = CP + 1;  /* ADVANCE SCANNER AND RESUME SEARCH FOR TOKEN  */\n      END;\n   END SCAN;\n\n\n  /*             ADDRESS AND REGISTER COMPUTATIONS                       */\n\n\nCHECKBASES:\n   PROCEDURE;\n      IF \u00ac COMPILING THEN RETURN;\n      IF DP >= BASES(LASTBASE) + 4096 THEN\n         DO;\n            LASTBASE = LASTBASE - 1;  /* USE REG 11 DOWN TO REG 4 */\n            BASES(LASTBASE) = DP & \"FFFFFC\";\n            INFORMATION = INFORMATION || ' R' || LASTBASE || EQUALS ||\n               BASES(LASTBASE) || PERIOD;\n            IF LASTBASE = 3 THEN CALL ERROR('EXCEEDED DATA AREA',1);\n         END;\n   END  CHECKBASES;\n\nCLEARREGS:\n   PROCEDURE;\n      /* FREE ALL THE ARITHMETIC REGISTERS  */\n      DO I = 0 TO 3;  BASES(I) = AVAIL;  END;\n      TARGET_REGISTER = -1;\n   END  CLEARREGS;\n\nFINDAC:\n   PROCEDURE FIXED;\n      /*  FIND AN ACCUMULATOR FOR 32 BIT QUANTITY  */\n      DECLARE I FIXED;\n      IF TARGET_REGISTER > -1 THEN IF BASES(TARGET_REGISTER) = AVAIL THEN\n         DO;\n            BASES(TARGET_REGISTER) = ACCUMULATOR;\n            RETURN TARGET_REGISTER;\n         END;\n      DO I = 1 TO 3;\n         IF BASES(I) = AVAIL THEN\n            DO;\n               BASES(I) = ACCUMULATOR;\n               RETURN I;\n            END;\n      END;\n      CALL ERROR('USED ALL ACCUMULATORS',0);\n      RETURN 0;\n   END  FINDAC;\n\n\nFINDADDRESS:\n   PROCEDURE (ADR);\n      /* FIND THE APPROPRIATE BASE AND DISPLACEMENT FOR THE ADDRESS  */\n      DECLARE (ADR, I) FIXED;\n      COUNT#FIND = COUNT#FIND + 1;\n      IF ADR < 0 THEN\n         DO;\n            ADRDISP = - ADR;\n            ADREG = SBR;\n            RETURN;\n         END;\n      IF ADR = 0 THEN\n         DO;\n            ADREG,ADRDISP = 0;\n            RETURN;\n         END;\n      DO I = LASTBASE TO DBR;\n         IF BASES(I) <= ADR & BASES(I)+4096 > ADR THEN\n            DO;\n               ADRDISP = ADR - BASES(I);\n               ADREG = I;\n               RETURN;\n            END;\n      END;\n      CALL ERROR('FIND ADDRESS FAILED',1);\n      ADREG,ADRDISP = 0;\n   END  FINDADDRESS;\n\n\n\n\n  /*                    CODE EMISSION PROCEDURES                       */\n\n\nEMITCHAR:\n   PROCEDURE (C);\n      DECLARE C BIT (8);\n      /*  SEND ONE 8-BIT CHARACTER TO THE STRING AREA  */\n      IF CONTROL(BYTE('E')) THEN\n         OUTPUT = X70 || CHP || ': CHARACTER = ' ||\n            SUBSTR(HEXCODES, SHR(C,4), 1) || SUBSTR(HEXCODES, C & \"F\", 1);\n      IF CHP < CHPORG | CHP >= CHPLIM THEN CALL GETSTRINGS;\n      STRINGS(CHP-CHPORG) = C;\n      CHP = CHP + 1;\n   END  EMITCHAR;\n\nEMITBYTE:\n   PROCEDURE (B);\n      DECLARE B FIXED;\n      /*  EMIT ONE BYTE OF DATA  */\n      IF DP < DPORG | DP >= DPLIM THEN CALL GETDATA;\n      DATA(DP-DPORG) = B;\n      IF CONTROL(BYTE('E')) THEN\n         OUTPUT = X70 || DP || ': DATA = ' ||\n            SUBSTR(HEXCODES, SHR(B,4), 1) || SUBSTR(HEXCODES, B & \"F\", 1);\n      DP = DP + 1;\n      CALL CHECKBASES;\n   END EMITBYTE;\n\nEMITCODEBYTES:\n   PROCEDURE (B1,B2);\n      DECLARE (B1, B2) BIT(8), I FIXED;\n      /*  EMIT TWO BYTES OF CODE  */\n      STILLCOND = 0;\n      IF PP < PPORG | PP >= PPLIM THEN CALL GETCODE;\n      I = PP - PPORG;\n      CODE(I) = B1;             /*  FIRST  BYTE  */\n      CODE(I+1) = B2;           /*  SECOND  BYTE  */\n      IF CONTROL(BYTE('B')) THEN\n         OUTPUT = X70 || PP || ': CODE = ' ||\n            SUBSTR(HEXCODES, SHR(B1,4), 1) || SUBSTR(HEXCODES, B1 & \"F\", 1)\n            || SUBSTR(HEXCODES, SHR(B2,4), 1) || SUBSTR(HEXCODES, B2 & \"F\",1);\n      PP =  PP + 2;\n   END  EMITCODEBYTES ;\n\nEMITDATAWORD:\n   PROCEDURE(W);\n      DECLARE (W, I) FIXED;\n      /*  SEND A 32-BIT WORD TO THE DATA ARRAY  */\n      DP = (DP + 3) & \"FFFFFC\";\n      IF DP < DPORG | DP >= DPLIM THEN CALL GETDATA;\n      CALL CHECKBASES;\n      IF CONTROL(BYTE('E')) THEN\n         OUTPUT = X70 || DP || ': DATA = ' || W;\n      I = DP - DPORG;\n      DATA(I) = SHR(W,24);\n      DATA(I+1) = SHR(W,16);\n      DATA(I+2) = SHR(W,8);\n      DATA(I+3) = W;\n      DP = DP + 4;\n      CALL CHECKBASES;\n   END EMITDATAWORD;\n\nEMITDESC:\n   PROCEDURE (D);\n      DECLARE D FIXED;\n      /*  SEND 32-BIT DESCRIPTOR TO STRING DESCRIPTOR AREA  */\n      IF DSP >= 4096 THEN\n         DO;\n            CALL ERROR ('TOO MANY STRINGS', 1);\n            DSP = 0;\n         END;\n      IF CONTROL(BYTE('E')) THEN\n         OUTPUT = X70 || DSP || ': DESC = ' || SHR(D,24) || ', ' ||\n            (D & \"FFFFFF\");\n      DESC(SHR(DSP,2)) = D;\n      DSP = DSP + 4;\n   END EMITDESC;\n\nEMITCONSTANT:\n   PROCEDURE(C);\n      /* SEE IF C HAS ALREADY BEEN EMITED, AND IF NOT EMIT.  SET UP ADDRESS */\n      DECLARE CTAB(100) FIXED, CADD (100) BIT(16), (C, NC, I) FIXED;\n      DO I = 1 TO NC;\n         IF CTAB(I) = C THEN\n            DO;\n               ADREG = SHR(CADD(I),12);\n               ADRDISP = CADD(I) & \"FFF\";\n               RETURN;\n            END;\n      END;\n      CALL EMITDATAWORD (C);\n      CTAB(I) = C;\n      CALL FINDADDRESS(DP-4);\n      CADD(I) = SHL(ADREG,12) + ADRDISP;\n      IF I < 100 THEN NC = I;\n      INFORMATION = INFORMATION || ' C' || I || EQUALS || C || PERIOD;\n   END EMITCONSTANT;\n\nEMITRR:\n   PROCEDURE (OP, R1, R2);\n      DECLARE (OP, R1, R2) FIXED;\n      /* EMIT A 16-BIT RR FORMAT INSTRUCTION  */\n      COUNT#RR = COUNT#RR + 1;\n      IF CONTROL(BYTE('E')) THEN\n         DO;\n            OP_CODE = SUBSTR(OPNAMES, OPER(OP), 4);\n            OUTPUT = X70 || PP || ': CODE = ' || OP_CODE || X1 || R1\n               || ',' || R2;\n         END;\n      CALL EMITCODEBYTES(OP, SHL(R1,4)+R2);\n      INSTRUCT(OP) = INSTRUCT(OP) + 1;\n   END EMITRR;\n\nEMITRX:\n   PROCEDURE (OP, R1, R2, R3, DISP);\n      DECLARE (OP, R1, R2, R3, DISP) FIXED;\n      /*  EMIT A 32-BIT RX FORMAT INSTRUCTION */\n      COUNT#RX = COUNT#RX + 1;\n      IF CONTROL(BYTE('E')) THEN\n         DO;\n            OP_CODE = SUBSTR(OPNAMES, OPER(OP), 4);\n            OUTPUT = X70 || PP || ': CODE = ' || OP_CODE || X1 || R1\n               || ',' || DISP || '(' || R2 || ',' || R3 || ')';\n         END;\n      CALL EMITCODEBYTES(OP, SHL(R1,4)+R2);\n      CALL EMITCODEBYTES(SHL(R3,4)+SHR(DISP,8), DISP & \"FF\");\n      INSTRUCT(OP) = INSTRUCT(OP) + 1;\n   END EMITRX;\n\n\n  /*                       FIXUP PROCEDURES                                  */\n\n\n\nINSERT_CODE_FIXUPS:\n   PROCEDURE;\n      /* EMPTY THE FIXUP TABLE, EITHER FOR LOADING OR BECAUSE OF\n         TABLE OVERFLOW */\n      DECLARE (I, J, L, FXLIM, T1, K) FIXED;\n      DECLARE T2 BIT(8), EXCHANGES BIT(1);\n\n      /* THE FIRST STEP IS TO SORT THE CODE FIXUP TABLE */\n      K,FXLIM = FCP - 1;     EXCHANGES = TRUE;\n      DO WHILE EXCHANGES;  /* QUIT BUBBLE SORT AFTER TABLE QUIETS DOWN */\n         EXCHANGES = FALSE;  /* RESET ON EACH EXCHANGE BELOW */\n         DO J = 0 TO K-1;\n            I = FXLIM-J;\n            L = I-1;\n            IF FIXCADR(L) > FIXCADR(I) THEN\n               DO;  /* SWAP */\n                  T1 = FIXCADR(L);  FIXCADR(L) = FIXCADR(I);  FIXCADR(I) = T1;\n                  T2 = FIXCB1(L);  FIXCB1(L) = FIXCB1(I);  FIXCB1(I) = T2;\n                  T2 = FIXCB2(L);  FIXCB2(L) = FIXCB2(I);  FIXCB2(I) = T2;\n                  EXCHANGES = TRUE;  K = J;\n               END;\n         END;\n      END;\n\n      /* NOW WRITE OUT THE CURRENT BLOCK */\n      FILE(CODEFILE,CURCBLK) = CODE;\n\n      /* WRITE BINARY PROGRAM PATCHES INTO PROGRAM FILE */\n\n      K,PPORG=0;  PPLIM = DISKBYTES;\n      DO J = 0 TO CODEMAX;\n\n         I = K;  /* KEEP TRACK OF K SO THAT WE WILL KNOW WHEN TO READ IN */\n\n         DO WHILE (K <= FXLIM)  &  (FIXCADR(K) < PPLIM);\n            /* IF THE FILE HAS NOT YET BEEN READ IN, DO SO */\n            IF K = I THEN CODE = FILE(CODEFILE,J); /* ONLY IF A FIX IS NEEDED */\n            L = FIXCADR(K) - PPORG;  /* RELATIVE ADDRESS WITHIN THIS BLOCK */\n            CODE(L) = FIXCB1(K);  CODE(L+1) = FIXCB2(K);\n            K = K + 1;\n         END;\n\n         IF K > I THEN    /* A FIXUP WAS DONE */\n            FILE(CODEFILE,J) = CODE;  /* SO WRITE OUT THE CONTENTS */\n\n         PPORG = PPORG + DISKBYTES;\n         PPLIM = PPLIM + DISKBYTES;\n      END;\n\n      FCP = 0;  /* RESET TABLE TO EMPTY */\n      CODE = FILE(CODEFILE,CURCBLK);  /* RESTORE FILE TO PREVIOUS STATE */\n      PPORG = CURCBLK*DISKBYTES;  PPLIM = PPORG + DISKBYTES;\n   END INSERT_CODE_FIXUPS;\n\nFIXCHW:\n   PROCEDURE (ADR, B1, B2);\n      DECLARE ADR FIXED, (B1, B2) BIT(8);\n      /*  FIX UP ONE HALF WORD OF CODE  */\n      COUNT#FIXCHW = COUNT#FIXCHW + 1;\n      IF FCP >= FCLIM THEN\n         CALL INSERT_CODE_FIXUPS;\n      IF PPORG <= ADR & ADR < PPLIM THEN\n         DO;\n            SHORTCFIX = SHORTCFIX + 1;\n            ADR = ADR - PPORG;\n            CODE(ADR) = B1;\n            CODE(ADR+1) = B2;\n         END;\n      ELSE\n         DO;\n            LONGCFIX = LONGCFIX + 1;\n            FIXCADR(FCP) = ADR;\n            FIXCB1(FCP) = B1;\n            FIXCB2(FCP) = B2;\n            FCP = FCP + 1;\n         END;\n   END  FIXCHW;\n\n\nFIXBFW:\n   PROCEDURE (WHERE, VAL);\n      DECLARE (WHERE, VAL, I, J, P) FIXED;\n      IF WHERE = 0 THEN RETURN;\n      /* FIX UP A BRANCH WHOSE ADDRESS WE NOW KNOW */\n      COUNT#FIXBFW = COUNT#FIXBFW + 1;\n      IF CONTROL(BYTE('E')) THEN OUTPUT = X70 || '     ' || WHERE || ': FIXUP ='\n            || VAL;\n      P = WHERE + 2;       /* THE ACTUAL ADDRESS FIELD  */\n      IF WHERE >=  \"1000\" THEN\n         DO;\n            CALL FIXCHW (P, SHL(DBR,4), SHR(VAL,10) & \"FC\");\n            VAL = VAL & \"FFF\";\n            P = P + 4;\n         END;\n      ELSE IF VAL >= \"1000\" THEN\n         DO;\n            I = VAL & \"FFF\";\n            J = SHR(VAL, 12);\n            INSTRUCT(LOAD) = INSTRUCT(LOAD) + 1;\n            INSTRUCT(BC) = INSTRUCT(BC) + 1;\n            CALL EMITDATAWORD (SHL(LOAD, 24) + SHL(BRCHREG, 20) + SHL(DBR, 12)\n                  + SHL(J, 2));\n            CALL EMITDATAWORD(\"47F00000\" +  SHL(BRCHREG,16) + SHL(PBR, 12) + I);\n            CALL FINDADDRESS (DP-8);\n            CALL FIXCHW(P, SHL(ADREG,4)+SHR(ADRDISP,8), ADRDISP & \"FF\");\n            RETURN;\n         END;\n      CALL FIXCHW(P, SHL(PBR,4)+SHR(VAL,8), VAL & \"FF\");\n   END FIXBFW;\n\n\nFIXWHOLEDATAWORD:\n   PROCEDURE (ADR, WORD);\n      DECLARE (ADR, WORD) FIXED;\n      DECLARE (BLK, TEMP) FIXED, REREAD BIT(1);\n      IF CONTROL(BYTE('E')) THEN\n         OUTPUT = X70 || ADR || ':  FIXUP = ' || WORD;\n      COUNT#FIXD = COUNT#FIXD + 1;\n      BLK = ADR/DISKBYTES;\n      REREAD = (CURDBLK \u00ac= BLK);\n      IF REREAD THEN\n         DO;  /* MUST GET THE RIGHT BLOCK  */\n            LONGDFIX = LONGDFIX + 1;\n            TEMP = DP;\n            DP = ADR;\n            CALL GETDATA;\n         END;\n      ELSE SHORTDFIX = SHORTDFIX + 1;\n      ADR = ADR MOD DISKBYTES;\n      DATA(ADR) = SHR(WORD, 24);\n      DATA(ADR+1) = SHR(WORD, 16);\n      DATA(ADR+2) = SHR(WORD, 8);\n      DATA(ADR+3) = WORD;\n      IF REREAD THEN DP = TEMP;\n   END  FIXWHOLEDATAWORD;\n\n\nENTER:\n   PROCEDURE (N, T, L, LINE);\n      /*  ENTER A SYMBOL IN THE SYMBOL TABLE  */\n      DECLARE (I, J, K, L, T, LINE) FIXED, N CHARACTER;\n\n      DO I = PROCMARK TO NDECSY;\n         IF N = SYT(I) THEN\n            DO;\n               K = SYTYPE(I);\n               IDCOMPARES = IDCOMPARES + I - PROCMARK;\n               IF T = LABELTYPE & (K = FORWARDTYPE | K = FORWARDCALL) THEN\n                  DO;\n                     IF CONTROL(BYTE('E')) THEN\n                        OUTPUT = X70 || 'FIX REFERENCES TO: ' || N;\n                     J = BASES(SYBASE(I))+ SYDISP(I);\n                     IF K = FORWARDCALL THEN\n                        IF L > \"FFF\" THEN\n                           L = L+8;\n                        ELSE\n                           L = L+4;\n                     SYBASE(I) = SHR(L, 12);\n                     SYDISP(I) = L & \"FFF\";\n                     CALL FIXWHOLEDATAWORD(J,L);\n                     SYTYPE(I) = T;\n                     DECLARED_ON_LINE(I) = LINE;\n                  END;\n               ELSE IF PROCMARK + PARCT < I THEN\n                  CALL ERROR('DUPLICATE DECLARATION FOR:  ' || N, 0);\n               ELSE DECLARED_ON_LINE(I) = LINE;\n               RETURN I;\n            END;\n      END;\n      NDECSY = NDECSY + 1;\n      IF NDECSY > MAXNDECSY THEN\n         IF NDECSY > SYTSIZE THEN\n            DO;\n               CALL ERROR ('SYMBOL TABLE OVERFLOW', 1);\n               NDECSY = NDECSY - 1;\n            END;\n         ELSE MAXNDECSY = NDECSY;\n      SYT(NDECSY) = N;\n      SYTYPE(NDECSY) = T;\n      DECLARED_ON_LINE(NDECSY) = LINE;\n      SYTCO(NDECSY) = 0;\n      IF T = LABELTYPE THEN\n         DO;\n            SYBASE(NDECSY) = SHR(L, 12);  /* PAGE  */\n            SYDISP(NDECSY) = L & \"FFF\";\n         END;\n      ELSE\n         DO;\n            CALL FINDADDRESS(L);\n            SYBASE(NDECSY) = ADREG;\n            SYDISP(NDECSY) = ADRDISP;\n         END;\n      IDCOMPARES = IDCOMPARES + NDECSY - PROCMARK;\n      RETURN NDECSY;\n   END  ENTER;\n\nID_LOOKUP:\n   PROCEDURE (P);\n       /* LOOKS UP THE IDENTIFIER AT P IN THE ANALYSIS STACK IN THE\n          SYMBOL TABLE AND INITIALIZES FIXL,CNT,TYPE,REG,INX\n          APPROPRIATELY.  IF THE IDENTIFIER IS NOT FOUND, FIXL IS\n          SET TO -1\n       */\n       DECLARE P FIXED, I FIXED;\n       CHAR_TEMP = VAR(P);\n       DO I = 0 TO NDECSY - 1;\n          IF SYT(NDECSY-I) = CHAR_TEMP THEN\n            DO;\n               IDCOMPARES = IDCOMPARES + I;\n               I,FIXL(P) = NDECSY - I;\n               CNT(P) = 0;   /* INITIALIZE SUBSCRIPT COUNT  */\n               TYPE(P) = VARIABLE;\n               IF SYTYPE(I) = SPECIAL THEN\n                  FIXV(P) = SYDISP(I);          /* BUILTIN FUNCTION */\n               ELSE\n                  FIXV(P) = 0;               /* \u00ac BUILTIN FUNCTION */\n               REG(P),INX(P) = 0;   /* INITIALIZE REGISTER POINTERS */\n               SYTCO(I) = SYTCO(I) + 1;  /* COUNT REFERENCES */\n               RETURN;\n            END;\n      END;\n      IDCOMPARES = IDCOMPARES + NDECSY;\n      FIXL(P) = -1;      /*  IDENTIFIER NOT  FOUND */\n   END   ID_LOOKUP;\n\n\nUNDECLARED_ID:\n   PROCEDURE (P);\n      /* ISSUES AN ERROR MESSAGE FOR UNDECLARED IDENTIFIERS AND\n         ENTERS THEM WITH DEFAULT TYPE IN THE SYMBOL TABLE\n      */\n      DECLARE P FIXED;\n      CALL ERROR('UNDECLARED IDENTIFIER:  ' || VAR(P) ,0);\n      CALL EMITDATAWORD(0);\n      CALL ENTER (VAR(P), FIXEDTYPE, DP-4, CARD_COUNT);\n      CNT(P) = 0;\n      FIXV(P) = 0;\n      REG(P) = 0;\n      INX(P) = 0;\n      FIXL(P) = NDECSY;\n      SYTCO(NDECSY) = 1;                /* COUNT FIRST REFERENCE */\n      TYPE(P) = VARIABLE;\n   END  UNDECLARED_ID;\n\nSETINIT:\n   PROCEDURE;\n      /*  PLACES INITIAL VALUES INTO DATA AREA */\n\n      DECLARE (I, J) FIXED;\n      IF ITYPE = CHRTYPE THEN\n         DO;\n            IF TYPE(MPP1) \u00ac= CHRTYPE THEN VAR(MPP1) = FIXV(MPP1);\n            S = VAR(MPP1);    /* THE STRING */\n            I = LENGTH(S) - 1;\n\n            IF I < 0 THEN\n               CALL EMITDESC(0);\n            ELSE\n               CALL EMITDESC(SHL(I,24) + CHP);\n\n            DO J = 0 TO I;\n               CALL EMITCHAR(BYTE(S,J));\n            END;\n         END;\n      ELSE IF TYPE(MPP1) \u00ac= CONSTANT THEN\n         CALL ERROR ('ILLEGAL CONSTANT IN INITIAL LIST');\n      ELSE IF ITYPE = FIXEDTYPE THEN\n         CALL EMITDATAWORD(FIXV(MPP1));\n      ELSE IF ITYPE = HALFWORD THEN\n         DO;\n            /*  FIRST FORCE ALIGNMENT  */\n            DP = (DP + 1) & \"FFFFFE\";\n            CALL EMITBYTE (SHR(FIXV(MPP1), 8));\n            CALL EMITBYTE(FIXV(MPP1) & \"FF\");\n         END;\n      ELSE IF ITYPE = BYTETYPE THEN\n         CALL EMITBYTE(FIXV(MPP1));\n   END  SETINIT;\n\nALLOCATE :\n   PROCEDURE(P,DIM);\n      /* ALLOCATES STORAGE FOR THE IDENTIFIER AT P IN THE ANALYSIS\n         STACK WITH DIMENSION DIM\n      */\n\n      DECLARE (P, DIM, J) FIXED;\n\n\n   CHECK_NEWDP:\n      PROCEDURE;\n         DECLARE T FIXED;\n         T = DP;\n         DP = NEWDP;\n         CALL CHECKBASES;\n         DP = T;\n      END  CHECK_NEWDP;\n\n\n\n      DIM = DIM + 1;         /* ACTUAL NUMBER OF ITEMS  */\n      DO CASE TYPE(P);\n\n         ;     /*  CASE  0    DUMMY        */\n\n         DO;      /*   CASE 1    HALFWORD  */\n            NEWDP = (NEWDP + 1) & \"FFFFFE\";   /* ALIGN HALFWORD  */\n            CALL CHECK_NEWDP;\n            J = NEWDP;\n            NEWDP = NEWDP + SHL(DIM, 1);\n         END;\n\n\n         ;     /*  CASE  2    LABEL TYPE         */\n\n\n          ;    /*  CASE  3    ACCUMULATOR        */\n\n          ;    /*  CASE  4    VARIABLE           */\n\n          ;    /*  CASE  5    CONSTANT           */\n\n          ;    /*  CASE  6    CONDITION          */\n\n          DO;  /*  CASE  7    CHARACTER TYPE     */\n            J = -NEWDSP;\n            NEWDSP = NEWDSP + SHL(DIM,2);\n          END;\n\n          DO;  /*  CASE  8    FIXED TYPE         */\n            NEWDP = (NEWDP + 3) & \"FFFFFC\";    /* ALIGN TO WORD */\n            CALL CHECK_NEWDP;\n            J = NEWDP;\n            NEWDP = NEWDP + SHL(DIM,2);\n          END;\n\n          DO;  /*  CASE  9    BYTE TYPE          */\n            CALL CHECK_NEWDP;\n            J = NEWDP;\n            NEWDP = NEWDP + DIM;\n          END;\n\n         DO;  /*  CASE 10    FORWARD TYPE  (LABEL)  */\n            NEWDP = (NEWDP+3) & \"FFFFFC\";  /* WORD ALIGN */\n            CALL CHECK_NEWDP;\n            J = NEWDP;\n            NEWDP = NEWDP + SHL(DIM,2);        /* SPACE FOR FIXUPS  */\n         END;\n\n          ;    /*  CASE 11    DESCRIPT           */\n\n          ;    /*  CASE 12    SPECIAL            */\n\n          ;    /*  CASE 13    FORWARD CALL       */\n\n          ;    /*  CASE 14    CHAR_PROC_TYPE             */\n\n          ;    /*  CASE 15    UNUSED             */\n\n      END; /*  OF DO CASE TYPE(P)  */\n\n      SYTYPE(FIXL(P)) = TYPE(P);\n      CALL FINDADDRESS(J);\n      SYBASE(FIXL(P)) = ADREG;\n      SYDISP(FIXL(P)) = ADRDISP;\n\n   END  ALLOCATE;\n\n\nTDECLARE:\n   PROCEDURE (DIM);\n      /*  ALLOCATES STORAGE FOR IDENTIFIERS IN DECLARATIONS  */\n      DECLARE DIM FIXED;\n      NEWDP = DP;\n      NEWDSP = DSP;\n      TYPE(MP) = TYPE(SP);\n      CASEP = FIXL(MP);\n      DO I = 1 TO INX(MP);\n         FIXL(MP) = CASESTACK(CASEP+I);      /* SYMBOL TABLE POINTER */\n         CALL ALLOCATE(MP, DIM);\n      END;\n   END  TDECLARE;\n\n\n\n\nMOVESTACKS:\n   PROCEDURE (F,T);\n      DECLARE F FIXED, T FIXED;\n      /*  MOVE ALL THE COMPILER STACKS DOWN FROM F TO T  */\n      TYPE(T) = TYPE(F);  VAR(T) = VAR(F);\n      FIXL(T) = FIXL(F);  FIXV(T) = FIXV(F);\n      INX(T) = INX(F);    REG(T) = REG(F);\n      PPSAVE(T) = PPSAVE(F);  CNT(T) = CNT(F);\n   END  MOVESTACKS;\n\n\n\n\n  /*                        BRANCH PROCEDURES                                */\n\n\n\nBRANCH_BD:\n   PROCEDURE(COND, B, D);\n      DECLARE (COND, B, D) FIXED;\n      /*  BRANCHES ARE A SPECIAL CASE.  IF THEY ARE INTO THE 1ST  4096\n         BYTES OF PROGRAM A SINGLE BRANCH WILL SUFFICE.  OTHERWISE WE\n         MUST INDEX WITH A CONSTANT IN BRCHREG TO GET ANYWHERE.\n      */\n      IF B = 0 THEN\n         CALL EMITRX(BC, COND, 0, PBR, D);\n      ELSE\n         DO;\n            CALL EMITRX(LOAD,BRCHREG,0,DBR,SHL(B,2));\n            CALL EMITRX(BC, COND, BRCHREG, PBR, D);\n         END;\n   END  BRANCH_BD;\n\n\nBRANCH:\n   PROCEDURE (COND, LOCATION);\n      DECLARE (COND, LOCATION) FIXED;\n      IF LOCATION = 0 THEN LOCATION = PP;\n      /* ASSUME FIXUP WILL BE NEAR  */\n      CALL BRANCH_BD(COND, SHR(LOCATION,12), LOCATION & \"FFF\");\n   END BRANCH;\n\n\n\n\n  /*                     EXPRESSIONS                                         */\n\n\nCONDTOREG:\n   PROCEDURE (MP, CC);\n      DECLARE (MP, CC, J) FIXED;\n      J = FINDAC;\n      CALL EMITRX(LA, J, 0, 0, 0);\n      IF PP < 4084 THEN\n         CALL BRANCH(CC, PP+8);\n      ELSE\n         CALL BRANCH(CC, PP+12);\n      CALL EMITRX(LA, J, 0, 0, 1);\n      TYPE(MP) = ACCUMULATOR;\n      REG(MP) = J;\n      STILLCOND = CC;\n   END CONDTOREG;\n\nBRLINK_BD:\n   PROCEDURE (BASE,DISP);\n      DECLARE (BASE, DISP) FIXED;\n      IF BASE = 0 THEN\n         CALL EMITRX(BAL, BRCHREG, 0, PBR, DISP);\n      ELSE\n         DO;\n            CALL EMITRX(LOAD, BRCHREG, 0, DBR, SHL(BASE,2));\n            CALL EMITRX(BAL, BRCHREG, BRCHREG, PBR, DISP);\n         END;\n   END  BRLINK_BD;\n\n\n   /*                  CODE FOR PROCEDURES                                   */\n\n\nSAVE_REGISTERS:\n   PROCEDURE;\n      /* GENERATES CODE TO SAVE REGISTERS BEFORE A PROCEDURE OR\n         FUNCTION CALL\n      */\n      DECLARE I FIXED;\n      DO I = 1 TO 3;\n         IF BASES(I) \u00ac= AVAIL THEN\n            DO;\n               CALL EMITDATAWORD(0);\n               CALL FINDADDRESS(DP-4);\n               TEMP(I) = SHL(ADREG,12)+ ADRDISP;\n               CALL EMITRX(STORE,I,0,ADREG,ADRDISP);\n            END;\n         ELSE\n            TEMP(I) = 0;\n      END;\n   END  SAVE_REGISTERS;\n\n\nUNSAVE_REGISTERS:\n   PROCEDURE (R,P);\n      /*  GENERATES CODE TO RESTORE REGISTERS AFTER A FUNCTION\n          OR PROCEDURE CALL AND ALSO DOES SOME HOUSEKEEPING\n      */\n      DECLARE (R, P, I, J) FIXED;\n      IF BASES(R) \u00ac= AVAIL THEN\n         DO;\n            J = FINDAC;\n            CALL EMITRR(\"18\", J, R);\n         END;\n      ELSE\n         J = R;\n      DO I = 1 TO 3;\n         IF TEMP(I) \u00ac= 0 THEN\n            CALL EMITRX(LOAD,I,0,SHR(TEMP(I),12), TEMP(I)&\"FFF\");\n      END;\n      TYPE(P) = ACCUMULATOR;\n      REG(P) = J;\n      BASES(J) = ACCUMULATOR;\n   END  UNSAVE_REGISTERS;\n\n\n\n\nCALLSUB:\n   PROCEDURE (SB,SD, R, P);\n      DECLARE (SB, SD, R, P) FIXED;\n      CALL SAVE_REGISTERS;\n      CALL BRLINK_BD(SB,SD);\n      CALL UNSAVE_REGISTERS(R, P);\n   END  CALLSUB;\n\n\nCALLSUB_FORWARD:\n   PROCEDURE (SB,SD,R,P);\n      DECLARE (SB, SD, R, P) FIXED;\n      CALL SAVE_REGISTERS;\n      CALL EMITRX(LOAD, BRCHREG, 0, SB,SD);\n      CALL EMITRX(BAL, BRCHREG, BRCHREG, PBR, 0);\n      CALL UNSAVE_REGISTERS(R, P);\n   END  CALLSUB_FORWARD;\n\n\n\nFORCE_ADDRESS:\n   PROCEDURE (SP,R);\n      /* GENERATES THE ADDRESS OF THE <VARIABLE> IN THE ANALYSIS\n         STACK AT SP IN REGISTER R.\n      */\n      DECLARE (SP, R, K, INXSP) FIXED;\n      IF SYTYPE(FIXL(SP)) = LABELTYPE THEN\n         DO;\n            K = FIXL(SP);\n            IF SYBASE(K) = 0 THEN\n               CALL EMITRX(LA,R,0,PBR,SYDISP(K));\n            ELSE\n               DO;\n                  CALL EMITRX(LOAD,R,0,DBR,SHL(SYBASE(K),2));\n                  CALL EMITRX(LA,R,R,PBR,SYDISP(K));\n               END;\n         END;\n      ELSE\n         DO;\n            K = SYTYPE(FIXL(SP));\n            INXSP = INX(SP);\n            IF INXSP \u00ac= 0 THEN\n               DO;\n                  IF K \u00ac= BYTETYPE THEN\n                     IF K = HALFWORD THEN\n                        CALL EMITRR (\"1A\", INXSP, INXSP);\n                     ELSE\n                        CALL EMITRX(\"89\",INXSP,0,0,2);\n                  BASES(INXSP) = AVAIL;\n               END;\n            IF K = FORWARDTYPE | K = FORWARDCALL THEN\n               DO;\n                  K = FIXL(SP);\n                  CALL EMITRX(LOAD,R,0,SYBASE(K),SYDISP(K));\n                  CALL EMITRR(\"1A\",R,PBR);\n               END;\n            ELSE\n               CALL EMITRX(LA,R,INXSP,SYBASE(FIXL(SP)),SYDISP(FIXL(SP)));\n         END;\n   END  FORCE_ADDRESS;\n\n\nFILE_PSEUDO_ARRAY:\n   PROCEDURE (VARP,FILEP, DIRECTION);\n      /* PROCEDURE TO GENERATE CODE FOR THE FILE PSEUDO ARRAY.\n         TWO FORMS ARE HANDLED:\n\n               <VARIABLE>  =  FILE(I,J);\n\n               FILE(I,J)  =  <VARIABLE>;\n\n         VARP IS A POINTER TO THE <VARIABLE> IN THE ANALYSIS STACKS.\n         FILEP IS A POINTER TO THE ANALYSIS STACK WHERE FILE(I,J)\n         HAS BEEN ASSIMILATED UNDER THE GUISE OF A SUBSCRIPTED\n         VARIABLE.  DIRECTION = 0 FOR THE FIRST CASE (READ) AND\n         DIRECTION = 4 FOR THE SECOND CASE (WRITE).  I IS THE FILE\n         INDEX (I = 1,2,3) AND J IS THE RELATIVE RECORD WITHIN THE\n         FILE.  THE GENERATED CODE SHOULD HAVE THE SAME EFFECT AS;\n\n               LA   0,<VARIABLE>\n               L    1,I\n               SLL  1,3                 I*8\n               LA   1,DIRECTION+44(,1)\n               L    2,J\n               BALR BRCHREG,IOREG\n\n         REGISTERS 0-3 ARE NOT PRESERVED ACROSS THE MONITOR CALL,\n         HENCE ALL REGISTERS ARE FREED,\n\n      */\n      DECLARE (VARP, DIRECTION, FILEP, R) FIXED;\n      IF TYPE(VARP) = VARIABLE THEN\n         DO;\n            CALL FORCE_ADDRESS(VARP,0);\n            CALL EMITRX(\"89\",REG(FILEP),0,0,3);   /*  I*8  */\n            R = FINDAC;\n            IF INX(FILEP) = 1 THEN\n               DO;                      /*  JUGGLE REGISTERS  */\n                  CALL EMITRR(\"18\",R,1);\n                  INX(FILEP) = R;\n               END;\n            CALL EMITRX(LA,1,0,REG(FILEP),44+DIRECTION);\n            IF INX(FILEP) \u00ac= 2 THEN\n               CALL EMITRR(\"18\",2,INX(FILEP));    /*  J    */\n            CALL EMITRR(BALR,BRCHREG,IOREG);\n            TYPE(FILEP) = SPECIAL;      /*  NO MORE ASSIGNMENTS  */\n            CALL CLEARREGS;            /*  FREE ALL REGISTERS  */\n         END;\n      ELSE\n         CALL ERROR('ILLEGAL USE OF FILE PSEUDO ARRAY',1);\n   END  FILE_PSEUDO_ARRAY;\n\n\nEMIT_INLINE:\n   PROCEDURE;\n\n      /* GENERATES CODE FOR THE PSEUDO FUNCTION INLINE                */\n\n      DECLARE BINLM CHARACTER INITIAL ('BAD ARGUMENT TO INLINE');\n\n      IF CNT(MP) < 4 THEN\n         DO;\n            IF TYPE(MPP1) = CONSTANT THEN\n               DO CASE CNT(MP);\n\n                  ;                              /* NO CASE 0 */\n\n                  FIXL(MP) = FIXV(MPP1);         /* SAVE OP CODE */\n\n                  DO;                            /* SAVE R1  */\n                     TYPE(MP) = ACCUMULATOR;\n                     REG(MP) = FIXV(MPP1);\n                  END;\n\n                  CALL EMITCODEBYTES(FIXL(MP), SHL(REG(MP), 4) +\n                     FIXV(MPP1));\n                                                 /* EMIT  OP R1 X  */\n               END;\n            ELSE\n               CALL ERROR(BINLM,1);\n         END;\n      ELSE IF TYPE(MPP1) = CONSTANT THEN\n         DO;\n            IF CNT(MP) & 1 THEN\n               CALL EMITCODEBYTES(INX(MP)+SHR(FIXV(MPP1), 8),\n                  FIXV(MPP1));\n                                       /* EMIT  B DDD  */\n            ELSE\n               INX(MP) = SHL(FIXV(MPP1), 4);      /* SAVE BASE REG  */\n         END;\n      ELSE IF TYPE(MPP1) = VARIABLE THEN\n         DO;\n            CNT(MP) = CNT(MP) + 1;\n            IF CNT(MP) & 1 THEN\n               CALL EMITCODEBYTES(SHL(SYBASE(FIXL(MPP1)), 4) +\n                                  SHR(SYDISP(FIXL(MPP1)), 8) ,\n                                  SYDISP(FIXL(MPP1)));\n            ELSE\n               CALL ERROR(BINLM, 1);\n         END;\n      ELSE\n         CALL ERROR(BINLM, 1);\n\n   END  EMIT_INLINE;\n\n\n\n\nPROC_START:\n   PROCEDURE;\n      /*  GENERATES CODE FOR THE HEAD OF A PROCEDURE */\n\n      DECLARE I FIXED;\n      I = FIXL(MP);\n      FIXL(MP) = PP;\n      CALL BRANCH(\"F\",0);    /*  BRANCH AROUND  */\n      CALL EMITDATAWORD(0);  /*  PLACE TO STORE RETURN ADDRESS */\n      PPSAVE(MP) = RTNADR;\n      RTNADR = DP - 4;\n      CALL FINDADDRESS(RTNADR);\n      SYBASE(I) = SHR(PP,12);          /* ADDRESS OF THE PROCEDURE  */\n      SYDISP(I) = PP & \"FFF\";\n      CALL EMITRX(STORE, BRCHREG,0,ADREG,ADRDISP);\n   END  PROC_START;\n\n\nSTUFF_PARAMETER:\n   PROCEDURE;\n      /* GENERATES CODE TO SEND AN ACTUAL PARAMETER TO A PROCEDURE */\n      I = FIXL(MP) + CNT(MP);\n      IF LENGTH(SYT(I)) = 0 THEN\n         DO;\n            IF SYTYPE(I) = BYTETYPE THEN\n               J = \"42\";           /*  STC  */\n            ELSE IF SYTYPE(I) = HALFWORD THEN\n               J = \"40\";\n            ELSE\n               J = STORE;         /*  ST  */\n            CALL EMITRX(J, REG(MPP1), 0, SYBASE(I), SYDISP(I));\n            BASES(REG(MPP1)) = AVAIL;\n         END;\n      ELSE\n         CALL ERROR('TOO MANY ACTUAL PARAMETERS', 1);\n   END  STUFF_PARAMETER;\n\n\nCHECK_STRING_OVERFLOW:\n   PROCEDURE;\n      DECLARE (I, BR_SAVE) FIXED;\n      CALL EMITRX (LOAD, 0, 0, DBR, TSA);\n      CALL EMITRX (CMPR, 0, 0, DBR, LIMITWORD);\n      I = PP;\n      CALL BRANCH (4, 0);\n      CALL EMITDATAWORD(0);  BR_SAVE = DP - 4;\n      CALL FINDADDRESS(BR_SAVE);\n      CALL EMITRX(STORE, BRCHREG, 0, ADREG, ADRDISP);\n      IF SYTYPE (STRING_RECOVER) = LABELTYPE THEN\n         CALL CALLSUB(SYBASE(STRING_RECOVER),SYDISP(STRING_RECOVER), 0,\n            STACKSIZE);\n      ELSE\n         CALL CALLSUB_FORWARD(SYBASE(STRING_RECOVER),\n            SYDISP(STRING_RECOVER), 0, STACKSIZE);\n      BASES(REG(STACKSIZE)) = AVAIL;\n      CALL FINDADDRESS (BR_SAVE);\n      CALL EMITRX(LOAD,BRCHREG,0,ADREG,ADRDISP);\n      SYTCO(STRING_RECOVER) = SYTCO(STRING_RECOVER) + 1;\n      CALL EMITRR (\"1B\", 0, 0);\n      CALL FINDADDRESS (STRL);\n      CALL EMITRX (STORE, 0, 0, ADREG, ADRDISP);\n      CALL FIXBFW (I, PP);\n   END CHECK_STRING_OVERFLOW;\n\n\nFORCEACCUMULATOR:\n   PROCEDURE (P);\n      DECLARE P FIXED;\n      /* FORCE THE OPERAND AT P INTO AN ACCUMULATOR */\n      DECLARE (R, SB, SD, TP, SFP) FIXED, T1 CHARACTER;\n      COUNT#FORCE = COUNT#FORCE + 1;\n      TP = TYPE(P);\n      IF TP = CONDITION THEN CALL CONDTOREG (P, REG(P));\n      ELSE IF TP = VARIABLE THEN\n         DO;\n            SB = SYBASE(FIXL(P));\n            SD = SYDISP(FIXL(P));\n            SFP = SYTYPE(FIXL(P));\n            IF SFP = LABELTYPE | SFP = CHAR_PROC_TYPE THEN\n               DO;\n                  CALL CALLSUB(SB,SD,3,P);\n                  IF LENGTH(SYT(FIXL(P)+CNT(P)+1)) = 0 THEN\n                     IF CONTROL(BYTE('N')) THEN\n                        OUTPUT = '** WARNING--NOT ALL PARAMETERS SUPPLIED';\n                  IF SFP = CHAR_PROC_TYPE THEN\n                     TYPE(P) = DESCRIPT;\n               END;\n            ELSE IF SFP = FORWARDTYPE | SFP = FORWARDCALL THEN\n               DO;\n                  CALL CALLSUB_FORWARD(SB,SD,3,P);\n                  SYTYPE(FIXL(P)) = FORWARDCALL;\n               END;\n            ELSE  IF SFP = SPECIAL THEN\n               DO;\n                  CALL EMITRX(\"90\", 1, 3, DBR, IO_SAVE);\n                  IF SD = 6 THEN\n                     DO;  /*  INPUT */\n                        CALL CHECK_STRING_OVERFLOW;\n                        IF REG(P) = 0 THEN CALL EMITRR (\"1B\", 2, 2);\n                        ELSE IF REG(P)\u00ac=2 THEN CALL EMITRR(\"18\", 2, REG(P));\n                        BASES(REG(P)) = AVAIL;\n                        CALL FINDADDRESS (TSA);\n                        CALL EMITRX (LOAD, 0, 0, ADREG, ADRDISP);\n                        /* THIS IS A POINTER TO THE FIRST FREE STRING AREA*/\n                        CALL EMITRX (LA, 1, 0, 0, 4); /* 4 IS READ CARD  */\n                        CALL EMITRR (BALR, BRCHREG, IOREG); /* MONITOR CALL*/\n                        /* MOVE FREE STRING AREA POINTER */\n                        CALL EMITRX (STORE, 1, 0, ADREG, ADRDISP);\n                        CALL FINDADDRESS (STRL);/* LAST COMPUTED STRING */\n                        CALL EMITRX (STORE, 0, 0, ADREG, ADRDISP);\n                        REG(P) = 0;\n                        TYPE(P) = DESCRIPT;\n                     END;\n                  ELSE IF SD = 8 THEN\n                     CALL FILE_PSEUDO_ARRAY(P-2,P,0);\n                  ELSE IF SD >= 11 & SD <= 18 THEN\n                     DO;\n                        /* TRACE, UNTRACE, EXIT, TIME, DATE, ETC.         */\n                        IF SD = 15 THEN R = 1; ELSE R = 0;\n                        IF SD > 15 THEN\n                           DO;\n                              IF REG(P) \u00ac= 0 THEN\n                                 CALL EMITRR (\"18\", 0, REG(P));\n                              BASES(REG(P)) = AVAIL;\n                              IF INX(P) \u00ac= 2 THEN\n                                 CALL EMITRR (\"18\", 2, INX(P));\n                              BASES(INX(P)) = AVAIL;\n                           END;\n                        /* SET UP MONITOR REQUEST CODE */\n                        CALL EMITRX(LA,1,0,0,SHL(SD-R,2)-32);\n                        /* MONITOR CALL */\n                        CALL EMITRR (BALR, BRCHREG, IOREG);\n                        TYPE(P) = ACCUMULATOR;\n                        IF R \u00ac= 0 THEN\n                           CALL EMITRR (\"18\", 0, R);\n                        REG(P) = 0;\n                     END;\n                  ELSE CALL ERROR (' ILLEGAL USE OF ' || SYT(FIXL(P)));\n                  CALL EMITRX (\"98\", 1, 3, DBR, IO_SAVE);\n               END;\n            ELSE\n               DO;  /* FETCH THE VARIABLE (ALL ELSE HAS FAILED) */\n                  IF SFP \u00ac= BYTETYPE THEN\n                     DO;\n                        IF INX(P) \u00ac= 0 THEN\n                          DO;\n                           IF SFP = HALFWORD THEN\n                              CALL EMITRR (\"1A\", INX(P), INX(P));\n                           ELSE\n                              CALL EMITRX (\"89\", INX(P), 0, 0, 2);\n                           /* SHIFT INDEX FOR WORD-TYPE ARRAY */\n                          R = INX(P);\n                          END;\n                        ELSE R = FINDAC;\n                        IF SFP = HALFWORD THEN TP = \"48\";\n                        ELSE TP = LOAD;\n                           CALL EMITRX(TP,R,INX(P),SYBASE(FIXL(P)),\n                        SYDISP(FIXL(P)));\n                     END;\n                  ELSE\n                     DO;\n                        R = FINDAC;\n                        CALL EMITRR (\"1B\", R, R); /* CLEAR R */\n                           CALL EMITRX(\"43\",R,INX(P),SYBASE(FIXL(P)),\n                        SYDISP(FIXL(P)));\n                        /* INSERT CHARACTER */\n                        BASES(INX(P)) = AVAIL;\n                     END;\n                  IF SFP = CHRTYPE THEN TYPE(P) = DESCRIPT;\n                     ELSE TYPE(P) = ACCUMULATOR;\n                  REG(P) = R;\n               END;\n         END;\n            ELSE IF TP = CONSTANT THEN\n               DO;\n                  R = FINDAC;\n                  /* FETCH A CONSTANT INTO AN ACCUMULATOR */\n                  IF FIXV(P) = 0 THEN CALL EMITRR(\"1B\", R, R);\n                  ELSE IF FIXV(P) < \"1000\" & FIXV(P) >= 1 THEN\n                     CALL EMITRX(LA, R, 0, 0, FIXV(P));\n                     ELSE\n                        DO;\n                           CALL EMITCONSTANT (FIXV(P));\n                           CALL EMITRX (LOAD, R, 0, ADREG, ADRDISP);\n                        END;\n                  TYPE(P) = ACCUMULATOR;\n                  REG(P) = R;\n               END;\n            ELSE IF TP = CHRTYPE THEN\n               DO;\n                  R = FINDAC;\n                  TYPE(P) = DESCRIPT;\n                  REG(P) = R;\n                  T1 = VAR(P);\n                  SD = LENGTH(T1) - 1;\n                  IF SD < 0 THEN\n                     CALL EMITRR(\"1B\",R,R); /* CLEAR  REG R, NULL STRING */\n                  ELSE\n                     DO;\n                        CALL FINDADDRESS (-DSP);\n                        /* MAKE UP A DESCRIPTOR */\n                        CALL EMITDESC(SHL(SD,24)+CHP);\n                        DO I = 0 TO SD;\n                           CALL EMITCHAR(BYTE(T1, I));\n                        END;\n                        CALL EMITRX (LOAD, R, 0, ADREG, ADRDISP);\n                     END;\n               END;\n            ELSE IF TP \u00ac= ACCUMULATOR THEN IF TP \u00ac= DESCRIPT THEN\n               CALL ERROR ('FORCEACCUMULATOR FAILED ***', 1);\n   END FORCEACCUMULATOR;\n\nFORCEDESCRIPT:\n   PROCEDURE (P);\n      /* GET A DESCRIPTOR FOR THE OPERAND P */\n      DECLARE P FIXED;\n      CALL FORCEACCUMULATOR (P);\n      IF TYPE(P) \u00ac= DESCRIPT THEN\n         DO;\n            CALL EMITRX (STORE, REG(P), 0, DBR, STRN);\n            /* STORE IN PARAMETER LOCATION FOR NUMBER-TO -DECIMAL-STRING */\n            BASES(REG(P)) = AVAIL;\n            CALL CALLSUB(0,NMBRNTRY,3,P);\n            /* ASSUMES NUMBER-TO-STRING IS IN THE 1ST PAGE */\n            TYPE(P) = DESCRIPT;\n         END;\n   END FORCEDESCRIPT;\n\nGENSTORE:\n   PROCEDURE (MP, SP);\n      DECLARE (MP, SP, SFP, SB, SD) FIXED;\n      COUNT#STORE = COUNT#STORE + 1;\n      IF TYPE(SP) = SPECIAL THEN RETURN;\n      /* GENERATE TYPE CONVERSION (IF NECESSARY) & STORAGE CODE --\n            ALSO HANDLES OUTPUT AND FILE ON LEFT OF REPLACE OPERATOR */\n      SB = SYBASE(FIXL(MP));\n      SD = SYDISP(FIXL(MP));\n      SFP = SYTYPE(FIXL(MP));\n      IF SFP = SPECIAL THEN\n         DO;\n            IF SD = 3 THEN      /*  FUNCTION BYTE ON THE LEFT */\n               DO;\n                  CALL FORCEACCUMULATOR(SP);\n                  CALL EMITRX(\"42\",REG(SP),INX(MP),REG(MP),0);\n               END;\n            ELSE IF SD = 7 THEN\n               DO;      /* OUTPUT   */\n                  CALL EMITRX(\"90\",1,3,DBR,IO_SAVE);\n                  TARGET_REGISTER = 0;\n                  CALL FORCEDESCRIPT (SP);\n                  TARGET_REGISTER = -1;\n                  IF REG(SP) \u00ac= 0 THEN CALL EMITRR (\"18\", 0, REG(SP));\n                  IF REG(MP) = 0 THEN CALL EMITRR (\"1B\", 2, 2);\n                  ELSE IF REG(MP) \u00ac= 2 THEN CALL EMITRR (\"18\", 2, REG(MP));\n                  BASES(REG(MP)) = AVAIL;\n                  CALL EMITRX (LA, 1, 0, 0, 8);  /* 8 = PRINT CODE */\n                  CALL EMITRR (BALR, BRCHREG, IOREG); /* MONITOR CALL */\n                  CALL EMITRX(\"98\",1,3,DBR,IO_SAVE);\n               END;\n            ELSE IF SD = 8 THEN\n               CALL FILE_PSEUDO_ARRAY(SP,MP,4);\n            ELSE CALL ERROR ('ILLEGAL USE OF ' || SYT(FIXL(MP)));\n         END;\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR (SP);\n            IF TYPE(SP) \u00ac= SPECIAL THEN\n               DO;\n                  IF SFP=FIXEDTYPE & TYPE(SP)=ACCUMULATOR | SFP=CHRTYPE THEN\n                     DO;\n                        IF SFP = CHRTYPE THEN CALL FORCEDESCRIPT (SP);\n                        /* SHIFT INDEX FOR WORD ARRAY */\n                        IF INX(MP) \u00ac= 0 THEN CALL EMITRX (\"89\", INX(MP),0,0,2);\n                        CALL EMITRX(STORE,REG(SP),INX(MP),SB,SD);\n                     END;\n                  ELSE IF SFP = HALFWORD & TYPE(SP) = ACCUMULATOR THEN\n                     DO;\n                        IF INX(MP) \u00ac= 0 THEN CALL EMITRR (\"1A\",INX(MP),INX(MP));\n                        CALL EMITRX (\"40\", REG(SP), INX(MP), SB, SD);\n                     END;\n                  ELSE IF SFP = BYTETYPE & TYPE(SP) = ACCUMULATOR THEN\n                     CALL EMITRX(\"42\",REG(SP),INX(MP),SB,SD); /* STC */\n                  ELSE CALL ERROR('ASSIGNMENT NEEDS ILLEGAL TYPE CONVERSION');\n               END;\n         END;\n      BASES(INX(MP)) = AVAIL;\n      BASES(REG(SP)) = AVAIL;\n      CALL MOVESTACKS (SP, MP);\n   END GENSTORE;\n\nSTRINGCOMPARE:\n   PROCEDURE;\n      /* GENERATES THE CODE TO COMPARE THE STRINGS AT SP & MP */\n      DECLARE (I, J, K) FIXED;\n      CALL FORCEDESCRIPT (SP);  /* GET THE DESCRIPTOR FOR THE SECOND OPERAND */\n      I = 6 - REG(MP) - REG(SP);  /* FIND THE THIRD REGISTER */\n      CALL EMITRR (\"18\", 0, REG(MP));  /* WE CAN USE 0 FOR SCRATCH */\n      CALL EMITRR (\"17\", 0, REG(SP));     /* EXCL. | TO COMPARE  */\n      CALL EMITRX (\"8A\", 0, 0, 0, 24);  /* CHECK HIGH ORDER 8 BITS FOR ZERO */\n      IF REG(MPP1) = 6 | REG(MPP1) = 8 THEN\n         DO;          /* IF WE ONLY NEED TO TEST EQUALITY, CODE IS SIMPLER  */\n            K = PP;\n            CALL BRANCH (6, 0);\n         END;\n      ELSE\n         DO;\n            J = PP;\n            CALL BRANCH (8, 0);     /*  SKIP IF EQUAL LENGTH */\n            CALL EMITRR (\"15\", REG(MP), REG(SP));     /* SET CONDITION CODE  */\n            K = PP;  /* SAVE FOR FIXUP */\n            CALL BRANCH (\"F\", 0);  /* BRANCH AROUND STRING COMPARE CODE  */\n            CALL FIXBFW (J, PP);\n         END;\n      IF BASES(I) \u00ac= AVAIL THEN CALL EMITRR (\"18\", 0, I);  /* SAVE REG I */\n      CALL EMITRR (\"18\", I, REG(MP));\n      CALL EMITRX (\"88\", I, 0, 0, 24);  /* SCALE LENGTH FOR EXECUTE COMMAND  */\n      CALL EMITDATAWORD (\"D5000000\" + SHL(REG(MP), 12));\n      CALL EMITBYTE (SHL(REG(SP), 4));\n      CALL EMITBYTE (0);\n      CALL FINDADDRESS (DP-6);\n      CALL EMITRX (\"44\", I, 0, ADREG, ADRDISP);\n      IF BASES(I) \u00ac= AVAIL THEN CALL EMITRR (\"18\", I, 0);/* RESTORE REG I*/\n      BASES(REG(SP)) = AVAIL;\n      CALL FIXBFW (K, PP);  /* BRING OTHER BRANCH IN HERE */\n   END STRINGCOMPARE;\n\nSHOULDCOMMUTE:\n   PROCEDURE BIT(1);\n      IF TYPE(SP) = VARIABLE THEN\n         IF SYTYPE(FIXL(SP)) = FIXEDTYPE THEN RETURN FALSE;\n      IF TYPE(MP) = CONSTANT THEN RETURN TRUE;\n      IF TYPE(MP) = VARIABLE THEN\n         IF SYTYPE(FIXL(MP)) = FIXEDTYPE THEN RETURN TRUE;\n      RETURN FALSE;\n   END;\n\nARITHEMIT:\n   PROCEDURE (OP);\n      /* EMIT AN INSTRUCTION FOR AN INFIX OPERATOR -- CONNECTS MP & SP */\n\n      DECLARE (OP, TP, T1) FIXED;\n      COUNT#ARITH = COUNT#ARITH + 1;\n      TP = 0;  /* REMEMBER IF COMMUTED */\n      IF COMMUTATIVE(OP) THEN\n            IF SHOULDCOMMUTE THEN\n               DO;\n                  TP = MP; MP = SP; SP = TP;\n               END;\n      CALL FORCEACCUMULATOR (MP);  /* GET THE LEFT ONE INTO AN ACCUMULATOR */\n      /* FIXL(SP) IS GARBAGE IF TYPE \u00ac= VARIABLE, WE GET 0C5 IF WE TEST IT */\n      T1 = \"0\";\n      IF TYPE(SP) = VARIABLE THEN IF SYTYPE(FIXL(SP)) = FIXEDTYPE THEN T1 = \"1\";\n      IF TYPE(MP) = DESCRIPT THEN\n         DO;\n            IF OP = CMPRR THEN CALL STRINGCOMPARE;\n            ELSE CALL ERROR ('ARITHMETIC WITH A STRING DESCRIPTOR');\n         END;\n      ELSE IF T1 THEN\n            DO;  /* OPERATE DIRECTLY FROM STORAGE  */\n               IF INX(SP) \u00ac= 0 THEN CALL EMITRX (\"89\", INX(SP), 0, 0, 2);\n               /* SHIFT TO  WORD INDEXING */\n               CALL EMITRX(OP+64,REG(MP),INX(SP),SYBASE(FIXL(SP)),\n                  SYDISP(FIXL(SP)));\n               /* REG OPCODE + 64 = RX OPCODE */\n               BASES(INX(SP)) = AVAIL;\n            END;\n      ELSE IF TYPE(SP) = CONSTANT THEN\n            DO;\n               CALL EMITCONSTANT (FIXV(SP));\n               CALL EMITRX (OP+64, REG(MP), 0, ADREG, ADRDISP);\n            END;\n      ELSE\n            DO;\n               CALL FORCEACCUMULATOR (SP);\n               IF TYPE(SP) \u00ac= ACCUMULATOR THEN\n                  CALL ERROR ('ARITHMETIC BETWEEN STRING DESCRIPTORS', 1);\n               CALL EMITRR (OP, REG(MP), REG(SP));\n               BASES(REG(SP)) = AVAIL;\n            END;\n      IF TP \u00ac= 0 THEN\n         DO;  /* COMMUTED */\n            SP = MP;  MP = TP;\n            CALL MOVESTACKS (SP, MP);\n         END;\n         /* BY THE ALGORITHM, TYPE(MP) IS ALREADY ACCUMULATOR */\n   END ARITHEMIT;\n\nBOOLBRANCH:\n   PROCEDURE (SP, MP);\n      DECLARE (SP, MP, T1) FIXED;\n      T1 = \"0\";\n      IF TYPE(SP) = VARIABLE THEN IF SYTYPE(FIXL(SP)) = BYTETYPE THEN T1 = \"1\";\n      /* GENERATE A CONDITIONAL BRANCH FOR A DO WHILE OR AN IF STATEMENT */\n      IF STILLCOND \u00ac= 0 THEN\n         DO;\n            BASES(REG(SP)) = AVAIL;\n               IF PP < \"1008\" THEN PP = PP - 12; ELSE PP = PP - 16;\n            IF CONTROL(BYTE('E')) THEN\n                  OUTPUT = X70 || '               BACK UP CODE EMITTER';\n            INSTRUCT(BC) = INSTRUCT(BC) - 1;  /* KEEP STATISTICS ACCURATE */\n            INSTRUCT(LA) = INSTRUCT(LA) - 2;\n            REG(SP) = STILLCOND;\n         END;\n      ELSE IF T1 THEN\n         DO;\n            IF INX(SP) \u00ac= 0 THEN\n               DO;\n                  CALL EMITRR(\"1A\",INX(SP),SYBASE(FIXL(SP)));\n                  CALL EMITRX(\"91\",0,1,INX(SP),SYDISP(FIXL(SP)));\n                  /*  TEST UNDER MASK  */\n                  BASES(INX(SP)) = AVAIL;\n               END;\n            ELSE CALL EMITRX(\"91\",0,1,SYBASE(FIXL(SP)),SYDISP(FIXL(SP)));\n                  /*  TEST UNDER MASK  */\n            REG(SP) = 8;\n         END;\n      ELSE IF TYPE(SP) = CONSTANT THEN\n         DO;\n            IF FIXV(SP) THEN\n               DO;  FIXL(MP) = 0;  RETURN; END;\n            ELSE REG(SP) = 15;\n         END;\n      ELSE IF TYPE(SP) \u00ac= CONDITION THEN\n         DO;\n            CALL FORCEACCUMULATOR (SP);\n            CALL EMITRX (\"54\", REG(SP), 0, DBR, TRUELOC);/* TEST LS BIT */\n            BASES(REG(SP)) = AVAIL;\n            REG(SP) = 8;\n         END;\n      FIXL(MP) = PP;  /* SAVE ADDRESS FOR FUTURE FIXUP */\n      CALL BRANCH (REG(SP), 0);  /* REG(SP) HAS THE CC TO BE TESTED FOR */\n   END BOOLBRANCH;\n\n\nSET_LIMIT:\n   PROCEDURE;\n      /*  SETS DO LOOP LIMIT FOR <ITERATION CONTROL>   */\n      IF TYPE(MPP1) = CONSTANT THEN\n         CALL EMITCONSTANT(FIXV(MPP1));\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR(MPP1);\n            CALL EMITDATAWORD(0);\n            CALL FINDADDRESS(DP-4);\n            CALL EMITRX(STORE,REG(MPP1),0,ADREG,ADRDISP);\n            BASES(REG(MPP1)) = AVAIL;\n         END;\n      INX(MP) = ADREG;\n      FIXV(MP) = ADRDISP;\n   END  SET_LIMIT;\n\n\nDIVIDE_CODE:\n   PROCEDURE;\n      /*  GENERATES THE CODE FOR DIVISION  */\n\n      TARGET_REGISTER = 0;\n      CALL FORCEACCUMULATOR(MP);\n      TARGET_REGISTER = -1;\n      IF REG(MP) \u00ac= 0 THEN\n         DO;\n            CALL EMITRR(\"18\",0,REG(MP));         /*  LR    0,REG(MP)  */\n            BASES(REG(MP)) = AVAIL;\n            REG(MP) = 0;\n         END;\n      IF BASES(1) = AVAIL THEN\n         DO;\n            /*  MUST \"SMEAR\"  THE SIGN  */\n            CALL EMITRX(\"8E\",0,0,0,32);          /*  SRDA  0,32       */\n            BASES(1) = ACCUMULATOR;\n            CALL ARITHEMIT(\"1D\");                /*  DIVIDE  */\n            REG(MP) = 1;                         /*  RESULT  */\n         END;\n      ELSE\n         CALL ERROR('DIVISION OR MOD REQUIRES BUSY REGISTER',1);\n\n   END  DIVIDE_CODE;\n\n\nSHIFT_CODE:\n   PROCEDURE (OP);\n      /*  GENERATES CODE FOR THE BUILT IN FUNCTIONS  SHL  AND  SHR  */\n      DECLARE OP BIT (8);\n      IF CNT(MP) \u00ac= 2 THEN\n         CALL ERROR('SHIFT REQUIRES TWO ARGUMENTS',0);\n      ELSE IF TYPE(MPP1) = CONSTANT THEN\n         DO;\n            IF OP = \"89\" & FIXV(MPP1) = 1 THEN\n               CALL EMITRR (\"1A\", REG(MP), REG(MP));\n            ELSE CALL EMITRX (OP, REG(MP), 0, 0, FIXV(MPP1));\n         END;\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR(MPP1);\n            CALL EMITRX(OP, REG(MP), 0, REG(MPP1), 0);\n            BASES(REG(MPP1)) = AVAIL;\n         END;\n      TYPE(MP) = ACCUMULATOR;\n   END  SHIFT_CODE;\n\n\n\n  /*                    BUILT-IN FUNCTIONS                              */\n\n\nREGISTER_SETUP_CODE:\n   PROCEDURE;\n      CALL EMITRR(\"18\",PBR,2);  /* SET BASE */\n      CALL EMITRR(\"18\",DBR,3);\n      CALL EMITRX(STORE,BRCHREG,0,DBR,RTNADR);\n      CALL EMITCONSTANT (256);\n      CALL EMITRX (\"5B\", 1, 0, ADREG, ADRDISP);\n      LIMITWORD = DP;\n      CALL EMITRX (STORE, 1, 0, DBR, DP);\n      CALL ENTER ('FREELIMIT', FIXEDTYPE, DP, 0);\n      CALL EMITDATAWORD (0);\n      BASEDATA = DP;\n      DP = DP+16;\n      CALL EMITRX (\"98\", 4, DBR-1, DBR, DP);  /* LOAD MULTIPLE  */\n      DO I = 4 TO DBR-1;\n         CALL EMITRR(\"1A\",I,DBR);\n      END;\n      DP = DP + SHL(DBR-4, 2);\n   END REGISTER_SETUP_CODE;\n\nRELOCATE_DESCRIPTORS_CODE:\n   PROCEDURE;\n      /* EMIT CODE TO RELOCATE DESCRIPTORS TO ABSOLUTE ADDRESSES */\n\n      CALL EMITRX(LOAD,0,0,DBR,BASEDATA+8);\n      CALL EMITRR(\"1A\",0,DBR);\n      CALL EMITRX(STORE,0,0,DBR,TSA);\n      CALL EMITRX (STORE, 0, 0, DBR, DP);\n      CALL ENTER ('FREEBASE', FIXEDTYPE, DP, 0);\n      CALL EMITDATAWORD (0);\n      CALL EMITRX(\"91\",0,1,DBR,BASEDATA+12);\n      K = PP;\n      CALL BRANCH (1, 0);\n      CALL EMITRX(\"96\",0,1,DBR,BASEDATA+12);\n      CALL EMITRX(LOAD,1,0,DBR,BASEDATA);\n      CALL EMITRX (LA,SBR,1,DBR,0);\n      CALL EMITRX(LOAD,2,0,DBR,BASEDATA+4);\n      CALL EMITRR (\"1A\",2,DBR);\n      J = PP;                             /* SAVE DESTINATION FOR LOOP */\n      CALL EMITRX (LOAD,3,1,DBR,0);\n      CALL EMITRR (\"12\",3,3);\n      CALL BRANCH (8,PP+10);              /* ESCAPE */\n      CALL EMITRR (\"1A\",3,2);\n      CALL EMITRX (STORE,3,1,DBR,0);\n      CALL EMITRX (LA,1,0,1,4);\n      CALL EMITRX(CMPR,1,0,DBR,BASEDATA+4);\n      CALL BRANCH (4,J);                  /* LOOP */\n      CALL FIXBFW (K,PP);\n      CALL BRANCH (15,0);      /*  JUMP TO FIRST COMPILED CODE */\n   END RELOCATE_DESCRIPTORS_CODE;\n\nCATENATE_CODE:\n   PROCEDURE;\n      /* BUILD A CATENATE SUBROUTINE  */\n\n      CATENTRY = PP;\n      CALL CHECK_STRING_OVERFLOW;\n      CALL EMITRX (LOAD,1,0,A1,A2);  /*  LOAD FIRST DESCRIPTOR */\n      CALL EMITRR (\"18\", 3, 1);  /* COPY INTO REG(3)  */\n      CALL EMITRX (\"5E\", 3, 0, B1, B2);  /* COMBINE DESCRIPTORS  */\n      CALL EMITRR (\"12\", 1, 1);  /* TEST FOR NULL FIRST OPERAND  */\n      CALL EMITRR (BCR, 8, BRCHREG);  /* RETURN WITH RESULT IN REG(3)  */\n      CALL EMITRR (CMPRR, 3, 1);  /* IS SECOND OPERAND NULL?  */\n      CALL EMITRR (BCR, 8, BRCHREG);  /* RETURN WITH RESULT IN REG(3)  */\n      CALL FINDADDRESS (MASKF000);\n      CALL EMITRX (\"54\", 3, 0, ADREG, ADRDISP);  /* MASK OUT ADDRESS  */\n      CALL EMITRX (\"5E\", 3, 0, DBR, CATCONST);  /* CORRECT LENGTH OF RESULT  */\n      CALL FINDADDRESS (MOVER);  /* FIND MOVE INSTRUCTION */\n      T1 = ADREG;  T2 = ADRDISP;\n      CALL EMITRR (\"18\", 0, 3);  /* SAVE LENGTH IN REG(0)  */\n      CALL FINDADDRESS (TSA);  /* FIND CURRENT TOP OF STR AREA  */\n      CALL EMITRX (LOAD,2,0,ADREG,ADRDISP);\n      CALL FINDADDRESS (STRL);  /* LAST STRING MADE IN STRING AREA */\n      CALL EMITRX (CMPR, 1, 0, ADREG, ADRDISP); /* SKIP MOVE IF AT TOP */\n      J = PP;\n      CALL BRANCH (6, 0);       /* FAKE MOVE */\n      CALL EMITRX (LA, 1, 0, 1, 0);\n      CALL EMITRR (\"16\", 0, 1);\n      K = PP;\n      CALL BRANCH (\"F\", 0);\n      CALL FIXBFW (J, PP);\n      CALL EMITRR (\"16\",0,2);  /* OR IN CORRECT ADDRESS */\n      CALL EMITRX (\"43\",3,0,A1,A2);  /* INSERT LENGTH FIELD */\n      CALL EMITRX (\"44\",3,0,T1,T2);   /* EXECUTE THE MOVE */\n      CALL EMITRX (\"41\",2,3,2,1);  /* UPDATE TSA */\n      CALL FIXBFW (K, PP);\n      CALL EMITRX (LOAD,1,0,B1,B2);  /* LOAD SECOND DESCRIPTOR */\n      CALL EMITRX (\"43\", 3,0,B1,B2);  /* INSERT LENGTH FIELD  */\n      CALL EMITRX (\"44\",3,0,T1,T2);  /* EXECUTE THE MOVE */\n      CALL EMITRX (\"41\",2,3,2,1);   /*  UPDATE TSA  */\n      CALL EMITRX (STORE, 0, 0, ADREG, ADRDISP);  /* STORE INTO STRL */\n      CALL FINDADDRESS (TSA);\n      CALL EMITRX (STORE,2,0,ADREG,ADRDISP);   /* SAVE TOP OF STR. A.  */\n      CALL EMITRR (\"18\", 3, 0);  /* RESULT TO REG(3)  */\n      CALL EMITRR (BCR, 15, BRCHREG);  /* RETURN  */\n   END CATENATE_CODE;\n\nCONVERT_CODE:\n   PROCEDURE;\n      /*  THE NUMBER-TO-STRING CONVERSION SUBROUTINE */\n\n      NMBRNTRY = PP;\n      CALL CHECK_STRING_OVERFLOW;         /* CALL COMPACTIFY */\n      CALL EMITRX (LOAD, 3,0, DBR, STRN);\n      CALL EMITRR (\"10\",3,3);             /* SET POSITIVE FOR CONVERT */\n      CALL EMITRX (LOAD, 1,0,DBR,TSA);    /* FREE SOME STRING AREA */\n      CALL EMITRX  (LA,1,0,1,11);         /* 11 IS THE MAXIMUM NUMBER OF DIGITS\n                                             IN A CONVERTED 32 BIT INTEGER */\n      CALL EMITRX (STORE,1,0,DBR,TSA);\n      CALL EMITRX (LA,0,0,0,10);          /* BASE 10 FOR DIVISION */\n      I = PP;\n      CALL EMITRR (\"06\",1,0);             /* COUNT THE DIGIT */\n      CALL EMITRR (\"1B\",2,2);             /* CLEAR REGISTER 2 */\n      CALL EMITRR (\"1D\",2,0);             /* DIVIDE BY 10 */\n      CALL EMITRX (LA,2,0,2,\"F0\");        /* ADD IN THE EBCDIC CODE */\n      CALL EMITRX (\"42\",2,0,1,0);\n      CALL EMITRR (\"12\",3,3);             /* TEST FOR ZERO */\n      CALL BRANCH (6,I);                  /* GET NEXT DIGIT */\n      CALL EMITRX (LOAD,3,0,DBR,STRN);\n      CALL EMITRR (\"12\",3,3);             /* TEST FOR NEGATIVE */\n      I = PP;\n      CALL BRANCH (10,0);\n      CALL EMITRX (LA,2,0,0,\"60\");        /* \"60\" = '-' */\n      CALL EMITRR (\"06\",1,0);\n      CALL EMITRX (\"42\",2,0,1,0);\n      CALL FIXBFW (I,PP);\n      CALL EMITRX (LOAD,3,0,DBR,TSA);     /* MAKE UP RESULT DESCRIPTOR */\n      CALL EMITRR (\"1B\",3,1);\n      CALL EMITRR (\"06\",3,0);\n      CALL EMITRX (\"89\",3,0,0,24);        /* SHIFT LENGTH FIELD LEFT */\n      CALL EMITRR (\"1A\",3,1);             /* ADD IN ADDRESS */\n      CALL FINDADDRESS (STRL);            /* UPDATE POINTER TO NEWEST STRING */\n      CALL EMITRX (STORE, 3, 0, ADREG, ADRDISP);\n      CALL EMITRR (BCR,15,BRCHREG);       /* RETURN */\n      CALL FIXBFW (CATENTRY-4, PP);\n   END CONVERT_CODE;\n\n\n  /*                       TIME AND DATE                                 */\n\n\nPRINT_TIME:\n   PROCEDURE (MESSAGE, T);\n      DECLARE MESSAGE CHARACTER, T FIXED;\n      MESSAGE = MESSAGE || T/360000 || ':' || T MOD 360000 / 6000 || ':'\n         || T MOD 6000 / 100 || '.';\n      T = T MOD 100;  /* DECIMAL FRACTION  */\n      IF T < 10 THEN MESSAGE = MESSAGE || '0';\n      OUTPUT = MESSAGE || T || '.';\n   END PRINT_TIME;\n\nPRINT_DATE_AND_TIME:\n   PROCEDURE (MESSAGE, D, T);\n      DECLARE MESSAGE CHARACTER, (D, T, YEAR, DAY, M) FIXED;\n      DECLARE MONTH(11) CHARACTER INITIAL ('JANUARY', 'FEBRUARY', 'MARCH',\n         'APRIL', 'MAY', 'JUNE', 'JULY', 'AUGUST', 'SEPTEMBER', 'OCTOBER',\n         'NOVEMBER', 'DECEMBER'),\n      DAYS(12) FIXED INITIAL (0, 31, 60, 91, 121, 152, 182, 213, 244, 274,\n         305, 335, 366);\n      YEAR = D/1000 + 1900;\n      DAY = D MOD 1000;\n      IF (YEAR & \"3\") \u00ac= 0 THEN IF DAY > 59 THEN DAY = DAY + 1; /* \u00ac LEAP YEAR*/\n      M = 1;\n      DO WHILE DAY > DAYS(M);  M = M + 1;  END;\n      CALL PRINT_TIME(MESSAGE || MONTH(M-1) || X1 || DAY-DAYS(M-1) ||  ', '\n         || YEAR || '.  CLOCK TIME = ', T);\n   END PRINT_DATE_AND_TIME;\n\n  /*                       INITIALIZATION                                     */\n\n\n\nINITIALIZATION:\n   PROCEDURE;\n      EJECT_PAGE;\n   CALL PRINT_DATE_AND_TIME ('X P L   COMPILATION -- \"THIS INSTALLATION\" -- XCOM\n III VERSION OF ', DATE_OF_GENERATION, TIME_OF_GENERATION);\n      DOUBLE_SPACE;\n      CALL PRINT_DATE_AND_TIME ('TODAY IS ', DATE, TIME);\n      DOUBLE_SPACE;\n      DO I = 1 TO NT;\n         S = V(I);\n         IF S = '<NUMBER>' THEN NUMBER = I;  ELSE\n         IF S = '<IDENTIFIER>' THEN IDENT = I;  ELSE\n         IF S = '<STRING>' THEN STRING = I;  ELSE\n         IF S = '/' THEN DIVIDE = I;  ELSE\n         IF S = '_|_' THEN EOFILE = I;  ELSE\n         IF S = 'DECLARE' THEN STOPIT(I) = TRUE;  ELSE\n         IF S = 'PROCEDURE' THEN STOPIT(I) = TRUE;  ELSE\n         IF S = 'END' THEN STOPIT(I) = TRUE;  ELSE\n         IF S = 'DO' THEN STOPIT(I) = TRUE;  ELSE\n         IF S = ';' THEN STOPIT(I) = TRUE;  ELSE\n         IF S = '|' THEN ORSYMBOL = I; ELSE\n         IF S = '||' THEN CONCATENATE = I; ELSE\n         ;\n      END;\n      IF IDENT = NT THEN RESERVED_LIMIT = LENGTH(V(NT-1));\n      ELSE RESERVED_LIMIT = LENGTH(V(NT));\n      V(EOFILE) = 'EOF';\n      STOPIT(EOFILE) = TRUE;\n      CHARTYPE(BYTE(' ')) = 1;\n      CHARTYPE(BYTE('''')) = 2;\n      CHARTYPE(BYTE('\"')) = 3;\n      DO I = 0 TO 255;\n         NOT_LETTER_OR_DIGIT(I) = TRUE;\n      END;\n      DO I = 0 TO LENGTH(ALPHABET) - 1;\n         J = BYTE(ALPHABET, I);\n         TX(J) = I;\n         NOT_LETTER_OR_DIGIT(J) = FALSE;\n         CHARTYPE(J) = 4;\n      END;\n      DO I = 0 TO 9;\n         J = BYTE('0123456789', I);\n         NOT_LETTER_OR_DIGIT(J) = FALSE;\n         CHARTYPE(J) = 5;\n      END;\n      DO I = V_INDEX(0) TO V_INDEX(1) - 1;\n         J = BYTE(V(I));\n         TX(J) = I;\n         CHARTYPE(J) = 7;\n      END;\n      CHARTYPE(BYTE('|')) = 8;\n      CHARTYPE(BYTE('/')) = 6;\n      COMMUTATIVE(\"14\") = TRUE;\n      COMMUTATIVE(\"16\") = TRUE;\n      COMMUTATIVE(\"1A\") = TRUE;\n      RETURNED_TYPE = FIXEDTYPE;          /* DEFAULT RETURN TYPE */\n\n      LASTBASE = DBR;  BASES(LASTBASE) = 0;\n      /*              INITIALIZE SYMBOL TABLE VARIABLES */\n      PP = 60;   /*  OFFSET  CODE  FOR  CONTROL  RECORD (SEE LOADER) */\n      DP = 0;    /*  DATA ORIGIN  */\n      DSP = 4;\n      CHP = 1;\n      PPLIM, DPLIM, CHPLIM = DISKBYTES;\n         /* UPPER BOUND FOR EMITTER ARRAYS */\n      PPORG, DPORG, CHPORG = 0;\n         /* LOWER BOUND FOR EMITTER ARRAYS */\n      CURCBLK, CURDBLK, CURSBLK = 0;\n         /* CURRENT BLOCK OCCUPYING EMITTER ARRAYS */\n      SHORTCFIX, SHORTDFIX, LONGCFIX, LONGDFIX = 0;\n         /* STATISTICAL COUNTERS FOR FIXUPS */\n      FCP = 0;  /* POINTER INTO FIXUP ARRAY */\n      NDECSY ,PROCMARK = 1;   PARCT = 0;\n      /* INTEGERS FOR BRANCH ADDRESSING */\n      DO I = 0 TO PROGRAMSIZE;  CALL EMITDATAWORD(SHL(I,12)); END;\n\n      /*  WARNING, THE FOLLOWING SECTION OF INITIALIZE DEPENDS ON\n          THE INITIALIZATION OF THE BUILTIN FUNCTION AND PSEUDO\n          VARIABLE NAMES AND ATTRIBUTES IN THE SYMBOL TABLE ARRAYS.\n      */\n\n      SYDISP(2) = DP;                     /*  MONITOR_LINK               */\n      DP = DP + 16;  /* RESERVE 4 WORDS FOR COMMUNICATION WITH MONITOR  */\n      MASKF000 = DP;  CALL EMITDATAWORD(\"FF000000\");\n      IO_SAVE = DP;  DP = DP + 12;  /* REGISTER SAVE FOR INPUT/OUTPUT  */\n\n      /*  SET UP THE MOVE TEMPLATE IN DATA AREA */\n\n      MOVER = DP;\n      CALL EMITBYTE(\"D2\");  /* MVC */\n      CALL EMITBYTE(0);\n      CALL EMITBYTE(\"20\");\n      CALL EMITBYTE(0);\n      CALL EMITBYTE(\"10\");\n      CALL EMITBYTE(0);\n      CALL EMITDATAWORD(0);  TSA = DP-4;\n      SYDISP(3) = DP;                     /*  TIME_OF_GENERATION         */\n      CALL EMITDATAWORD(TIME);\n      SYDISP(4) =  DP;                    /*  DATE_OF_GENERATION         */\n      CALL EMITDATAWORD(DATE);\n      SYDISP(5) = 0;                      /*  COREWORD                   */\n      SYDISP(6) = 0;                      /*  COREBYTE                   */\n      SYDISP(7) = TSA;                    /*  FREEPOINT                  */\n      SYDISP(8) = DSP;                    /*  DESCRIPTOR                 */\n      SYDISP(9) = DP;                     /*  NDESCRIPT                  */\n      DESCL = DP;\n      CALL EMITDATAWORD (0);\n      A1, B1 = SBR;  /* A1,A2 IS THE FIRST PARAMETER TO ||, */\n      A2 = DSP;       /* B1,B2 IS THE SECOND */\n      CALL EMITDESC (0);\n      B2 = DSP;\n      CALL EMITDESC (0);\n      STRL = -DSP;  CALL EMITDESC(0);\n      STRN = DP; CALL EMITDATAWORD(0);\n      TRUELOC = DP; CALL EMITDATAWORD(TRUE);\n      COMPLOC = DP; CALL EMITDATAWORD(\"FFFFFFFF\");\n      CATCONST = DP; CALL EMITDATAWORD (\"1000000\");\n      RTNADR = DP; CALL EMITDATAWORD (0);\n      NDECSY = 28;   /* ONE BEYOND LAST FUNCTION NAME */\n\n      CALL EMITDATAWORD (0);\n      SYDISP(NDECSY) = DP-4;            /*  COMPACTIFY                 */\n      STRING_RECOVER = NDECSY;\n      CALL CLEARREGS;\n\n\n      /*         EMIT CODE FOR BUILT_IN FUNCTIONS                        */\n\n      CALL REGISTER_SETUP_CODE;\n\n      CALL RELOCATE_DESCRIPTORS_CODE;\n\n      CALL CATENATE_CODE;\n\n      CALL CONVERT_CODE;\n\n      MAINLOC = PP;\n      CALL CLEARREGS;\n      /* FIRST SET UP GLOBAL VARIABLES CONTROLLING SCAN, THEN CALL IT */\n      CP = 0;  TEXT_LIMIT = -1;\n      TEXT, CURRENT_PROCEDURE = '';\n      CALL SCAN;\n\n      /* INITIALIZE THE PARSE STACK */\n      SP = 1;  PARSE_STACK(SP) = EOFILE;\n\n   END INITIALIZATION;\n\n\n\n  /*               SYMBOL AND STATISTICS PRINTOUT                         */\n\n\nSYMBOLDUMP:\n   PROCEDURE;\n      /* LISTS THE SYMBOLS IN THE PROCEDURE THAT HAS JUST BEEN\n         COMPILED IF $S OR $D IS ENABLED\n         MAINTAIN PARITY ON $D AND $S\n      */\n      DECLARE (LPM, I, J, K, L, M) FIXED;\n      DECLARE (BUFFER, BLANKS) CHARACTER;\n      DECLARE EXCHANGES BIT(1), SYTSORT(SYTSIZE) BIT(16);\n\n      OUTLINE:\n         PROCEDURE (NAME, P) CHARACTER;\n            DECLARE NAME CHARACTER, (P, B, D) FIXED;\n            IF SYTYPE(P) = LABELTYPE | SYTYPE(P) = CHAR_PROC_TYPE THEN\n               DO;\n                  B = PBR;\n                  D = SHL(SYBASE(P), 12) + SYDISP(P);\n               END;\n            ELSE\n               DO;\n                  B = SYBASE(P);\n                  D = SYDISP(P);\n               END;\n\n            BUFFER = PAD (D || '(' || B || '),', 11);\n            RETURN NAME || ': ' || TYPENAME(SYTYPE(P)) || ' AT ' || BUFFER ||\n               ' DECLARED ON LINE ' || DECLARED_ON_LINE(P) ||\n               ' AND REFERENCED ' || SYTCO(P) || ' TIMES.';\n         END  OUTLINE;\n\n\n      IF PROCMARK <= NDECSY THEN\n         DO;\n            DOUBLE_SPACE;\n            OUTPUT = 'SYMBOL  TABLE  DUMP';\n            DOUBLE_SPACE;\n            LPM = LENGTH(SYT(PROCMARK));\n            L = 15;\n            DO I = PROCMARK TO NDECSY;\n               IF LENGTH(SYT(I)) > L THEN\n                  L = LENGTH(SYT(I));\n            END;\n            IF L > 70 THEN L = 70;\n            BLANKS = SUBSTR(X70, 0, L);\n            DO I = PROCMARK TO NDECSY;\n               SYTSORT(I) = I;\n               K = LENGTH(SYT(I));\n               IF K > 0 THEN\n                  IF K < L THEN\n                     DO;\n                        BUFFER = SUBSTR(BLANKS,K);\n                        SYT(I) = SYT(I) || BUFFER;\n                     END;\n                  ELSE\n                     DO;\n                        BUFFER = SUBSTR (SYT(I), 0, L);\n                        SYT(I) = BUFFER;\n                     END;\n            END;\n\n            EXCHANGES = TRUE;\n            K = NDECSY - PROCMARK;\n\n            DO WHILE EXCHANGES;\n               EXCHANGES = FALSE;\n               DO J = 0 TO K - 1;\n                  I = NDECSY - J;\n                  L = I - 1;\n                  IF SYT(SYTSORT(L)) > SYT(SYTSORT(I)) THEN\n                     DO;\n                        M = SYTSORT(I);\n                        SYTSORT(I) = SYTSORT(L);\n                        SYTSORT(L) = M;\n                        EXCHANGES = TRUE;\n                        K = J;         /* RECORD LAST SWAP */\n                     END;\n               END;\n            END;\n\n            I = PROCMARK;\n            DO WHILE LENGTH(SYT(SYTSORT(I))) = 0;\n               I = I + 1;              /* IGNORE NULL NAMES */\n            END;\n\n            DO I = I TO NDECSY;\n               K = SYTSORT(I);\n               OUTPUT = OUTLINE(SYT(K), K);\n\n               K = K + 1;\n               DO WHILE (LENGTH(SYT(K)) = 0) & (K <= NDECSY);\n                  J = K - SYTSORT(I);\n                  OUTPUT =\n                     OUTLINE('  PARAMETER  ' || J || SUBSTR(BLANKS, 14), K);\n                  K = K + 1;\n               END;\n\n            END;\n\n            BUFFER = SUBSTR(SYT(PROCMARK), 0 , LPM);\n            SYT(PROCMARK) = BUFFER;\n            EJECT_PAGE;\n         END;\n\n   END  SYMBOLDUMP;\n\n\n\nDUMPIT:\n   PROCEDURE;    /* DUMP OUT THE COMPILED CODE & DATA AREAS  */\n      CALL SYMBOLDUMP;\n      OUTPUT = 'MACRO DEFINITIONS:';\n      DOUBLE_SPACE;\n      DO I = 0 TO TOP_MACRO;\n         OUTPUT = PAD(MACRO_NAME(I), 20) || ' LITERALLY: ' || MACRO_TEXT(I);\n      END;\n      DOUBLE_SPACE;\n      /*  PUT OUT THE ENTRY COUNT FOR IMPORTANT PROCEDURES */\n\n      OUTPUT = 'IDCOMPARES        = ' || IDCOMPARES;\n      OUTPUT = 'SYMBOL TABLE SIZE = ' || MAXNDECSY;\n      OUTPUT = 'MACRO DEFINITIONS = ' || TOP_MACRO + 1;\n      OUTPUT = 'STACKING DECISIONS= ' || COUNT#STACK;\n      OUTPUT = 'SCAN              = ' || COUNT#SCAN;\n      OUTPUT = 'EMITRR            = ' || COUNT#RR;\n      OUTPUT = 'EMITRX            = ' || COUNT#RX;\n      OUTPUT = 'FORCEACCUMULATOR  = ' || COUNT#FORCE;\n      OUTPUT = 'ARITHEMIT         = ' || COUNT#ARITH;\n      OUTPUT = 'GENSTORE          = ' || COUNT#STORE;\n      OUTPUT = 'FIXBFW            = ' || COUNT#FIXBFW;\n      OUTPUT = 'FIXDATAWORD       = ' || COUNT#FIXD;\n      OUTPUT = 'FIXCHW            = ' || COUNT#FIXCHW;\n      OUTPUT = 'GETDATA           = ' || COUNT#GETD;\n      OUTPUT = 'GETCODE           = ' || COUNT#GETC;\n      OUTPUT = 'FINDADDRESS       = ' || COUNT#FIND;\n      OUTPUT = 'SHORTCFIX         = ' || SHORTCFIX;\n      OUTPUT = 'LONGCFIX          = ' || LONGCFIX;\n      OUTPUT = 'SHORTDFIX         = ' || SHORTDFIX;\n      OUTPUT = 'LONGDFIX          = ' || LONGDFIX;\n      OUTPUT = 'FREE STRING AREA  = ' || FREELIMIT - FREEBASE;\n      DOUBLE_SPACE;\n      OUTPUT = 'REGISTER VALUES (RELATIVE TO R11):';\n      DO I = 4 TO 13;\n         OUTPUT = 'R' || I || ' = ' || BASES(I);\n      END;\n\n      OUTPUT = ''; OUTPUT = ' INSTRUCTION FREQUENCIES:';\n      OUTPUT = '';\n      DO I = 0 TO 255;\n         IF INSTRUCT(I) \u00ac = 0 THEN\n             OUTPUT = SUBSTR(OPNAMES,OPER(I),4) || X4 || INSTRUCT(I);\n      END;\n   END DUMPIT;\n\n\nSTACK_DUMP:\n   PROCEDURE;\n      DECLARE LINE CHARACTER;\n      LINE = 'PARTIAL PARSE TO THIS POINT IS: ';\n      DO I = 2 TO SP;\n         IF LENGTH(LINE) > 105 THEN\n            DO;\n               OUTPUT = LINE;\n               LINE = X4;\n            END;\n         LINE = LINE || X1 || V(PARSE_STACK(I));\n      END;\n      OUTPUT = LINE;\n   END STACK_DUMP;\n\n\n  /*                  THE SYNTHESIS ALGORITHM FOR XPL                      */\n\n\nSYNTHESIZE:\nPROCEDURE(PRODUCTION_NUMBER);\n   DECLARE PRODUCTION_NUMBER FIXED;\n\n   /*  ONE STATEMENT FOR EACH PRODUCTION OF THE GRAMMAR*/\n\n\nDO CASE PRODUCTION_NUMBER;\n   ;      /*  CASE 0 IS A DUMMY, BECAUSE WE NUMBER PRODUCTIONS FROM 1  */\n\n /*  <PROGRAM>  ::=  <STATEMENT LIST>    */\n   DO;   /* FINAL CODE FOR XPLSM INTERFACE & SETUP  */\n      IF MP \u00ac= 2 THEN  /* WE DIDN'T GET HERE LEGITIMATELY  */\n         DO;\n            CALL ERROR ('EOF AT INVALID POINT', 1);\n            CALL STACK_DUMP;\n         END;\n      DO I = 1 TO NDECSY;\n         IF SYTYPE(I) = FORWARDTYPE | SYTYPE(I) = FORWARDCALL THEN\n          IF SYTCO(I) > 0 THEN\n            CALL ERROR ('UNDEFINED LABEL OR PROCEDURE: ' || SYT(I), 1);\n      END;\n      CALL EMITRR (\"1B\", 3, 3);  /* RETURN CODE OF ZERO  */\n      CALL EMITRX(LOAD, BRCHREG, 0, DBR, RTNADR);\n      CALL EMITRR(BCR, \"F\", BRCHREG);  /* SET UP BASE REGISTERS */\n      BASES(SBR) = (DP + 3) & \"FFFFFC\";\n      DO I = 4 TO DBR-1;\n         CALL FIXWHOLEDATAWORD(BASEDATA+SHL(I,2), BASES(I));\n      END;\n      CALL FIXWHOLEDATAWORD(DESCL, SHR(DSP,2)-1);\n      COMPILING = FALSE;\n   END;\n\n /*  <STATEMENT LIST> ::= <STATEMENT>    */\n   ;\n /*  <STATEMENT LIST> ::= <STATEMENT LIST> <STATEMENT>    */\n   ;\n /*  <STATEMENT> ::= <BASIC STATEMENT>    */\n   DO;\n      CALL CLEARREGS;\n      STATEMENT_COUNT = STATEMENT_COUNT + 1;\n   END;\n\n /*  <STATEMENT> ::= <IF STATEMENT>    */\n   CALL CLEARREGS;\n\n /*  <BASIC STATEMENT> ::= <ASSIGNMENT> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <GROUP> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <PROCEDURE DEFINITION> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <RETURN STATEMENT> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <CALL STATEMENT> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <GO TO STATEMENT> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <DECLARATION STATEMENT> ;    */\n   ;\n\n /*  <BASIC STATEMENT> ::= ;    */\n      ;\n /*  <BASIC STATEMENT> ::= <LABEL DEFINITION> <BASIC STATEMENT>    */\n      ;\n /*  <IF STATEMENT> ::= <IF CLAUSE> <STATEMENT>    */\n   CALL FIXBFW(FIXL(MP), PP); /* FIX THE ESCAPE BRANCH NOW THAT STMT IS DONE */\n\n /*  <IF STATEMENT> ::= <IF CLAUSE> <TRUE PART> <STATEMENT>    */\n   DO;  /* THERE ARE TWO BRANCHES TO BE FILLED IN WITH ADDRESSES HERE */\n      CALL FIXBFW(FIXL(MPP1), PP); /* ESCAPE FROM TRUE PART */\n      CALL FIXBFW(FIXL(MP), FIXV(MPP1)); /* HOP AROUND TRUE PART */\n   END;\n\n /*  <IF STATEMENT> ::= <LABEL DEFINITION> <IF STATEMENT>    */\n   ;\n\n /*  <IF CLAUSE> ::= IF <EXPRESSION> THEN    */\n   CALL BOOLBRANCH(MPP1, MP); /* BRANCH ON FALSE OVER TRUE PART */\n\n  /*  <TRUE PART> ::= <BASIC STATEMENT> ELSE   */\n   DO;  /* SAVE THE PROGRAM POINTER & EMIT THE CONDITIONAL BRANCH */\n      FIXL(MP) = PP;\n      CALL BRANCH(\"F\", 0); /* \"F\" MEANS UNCONDITIONAL BRANCH */\n      FIXV(MP) = PP;\n   END;\n\n /*  <GROUP> ::= <GROUP HEAD> <ENDING>    */\n   DO;  /* BRANCH BACK TO LOOP & FIX ESCAPE JUMP */\n      IF INX(MP) = 1 | INX(MP) = 2 THEN\n         DO; /* STEP OR WHILE LOOP FIX UP */\n            CALL BRANCH(\"F\", PPSAVE(MP));\n            CALL FIXBFW(FIXL(MP), PP);\n         END;\n      ELSE IF  INX(MP) = 3 THEN\n         DO;  /* COMMENT  CASE GROUP */\n            /* JUSTIFY TO WORD BOUNDARY */\n            DP = (DP + 3) & \"FFFFFC\";\n            CALL FINDADDRESS(DP);\n            CALL FIXCHW(FIXL(MP)+2, SHL(ADREG,4)+SHR(ADRDISP,8), ADRDISP);\n            DO I = PPSAVE(MP) TO CASEP-1; CALL EMITDATAWORD(CASESTACK(I)); END;\n            CASEP = PPSAVE(MP) - 1;\n            CALL FIXBFW(FIXV(MP), PP);\n         END;\n      IF LENGTH(VAR(SP)) > 0 THEN IF VAR(MP-1) \u00ac= VAR(SP) THEN\n         CALL ERROR ('END ' || VAR(SP) || '  MUST MATCH LABEL ON GROUP', 0);\n   END;\n\n /*  <GROUP HEAD> ::= DO ;    */\n   INX(MP) = 0;\n\n /*  <GROUP HEAD> ::= DO <STEP DEFINITION> ;    */\n   DO;\n      CALL MOVESTACKS(MPP1, MP);\n      INX(MP) = 1;  /* 1 DENOTES STEP */\n   END;\n\n /*  <GROUP HEAD> ::= DO <WHILE CLAUSE> ;    */\n   DO;\n      PPSAVE(MP) = PPSAVE(MPP1);\n      FIXL(MP) = FIXL(MPP1);\n      INX(MP) = 2;  /* 2 DENOTES WHILE */\n   END;\n\n /*  <GROUP HEAD> ::= DO <CASE SELECTOR> ;    */\n   DO;\n      CALL MOVESTACKS(MPP1, MP);\n      INX(MP) = 3;  /* 3 DENOTES CASE  */\n      INFORMATION = INFORMATION || ' CASE 0.';\n   END;\n\n /*  <GROUP HEAD> ::= <GROUP HEAD> <STATEMENT>    */\n   IF  INX(MP) = 3 THEN\n      DO;  /* CASE GROUP, MUST RECORD STATEMENT ADDRESSES */\n         CALL BRANCH (\"F\", FIXV(MP));\n      IF CASEP >= CASELIMIT THEN CALL ERROR ('TOO MANY CASES', 1);\n         ELSE CASEP = CASEP + 1;  CASESTACK(CASEP) = PP;\n      IF BCD \u00ac= 'END' THEN\n            INFORMATION = INFORMATION || ' CASE ' || CASEP-PPSAVE(MP) || PERIOD;\n      END;\n\n /*  <STEP DEFINITION> ::= <VARIABLE> <REPLACE> <EXPRESSION> <ITERATION CONTROL>\n         */\n   DO; /* EMIT CODE FOR STEPPING DO LOOPS */\n      CALL FORCEACCUMULATOR(MP+2);\n      IF INX(MP) \u00ac = 0 THEN\n         CALL ERROR ('SUBSCRIPTED DO VARIABLE', 0);\n      STEPK = PP;\n      CALL BRANCH(\"F\", 0);\n      PPSAVE(MP) = PP;\n      L = FIXL(MP);\n      ADREG = SYBASE(L);\n      ADRDISP = SYDISP(L);\n      IF SYTYPE(L) = BYTETYPE THEN\n         DO;\n            CALL EMITRR(\"1B\", REG(MP+2), REG(MP+2));\n            CALL EMITRX (\"43\", REG(MP+2), 0, ADREG, ADRDISP);\n         END;\n      ELSE IF SYTYPE(L) = HALFWORD THEN\n         CALL EMITRX (\"48\", REG(MP+2), 0, ADREG, ADRDISP);\n      ELSE\n         CALL EMITRX (LOAD, REG(MP+2), 0, ADREG, ADRDISP);\n      CALL EMITRX (\"5A\", REG(MP+2), 0, REG(MP+3), FIXL(MP+3));\n      CALL FIXBFW(STEPK, PP);\n      IF SYTYPE(L) = BYTETYPE THEN I = \"42\";\n      ELSE IF SYTYPE(L) = HALFWORD THEN I = \"40\";\n      ELSE I = STORE;\n      CALL EMITRX (I, REG(MP+2), 0, ADREG, ADRDISP);\n      CALL EMITRX (CMPR, REG(MP+2), 0, INX(MP+3), FIXV(MP+3));\n      FIXL(MP) = PP;\n      CALL BRANCH(\"2\", 0);\n      BASES(INX(MP)) = AVAIL;\n      BASES(REG(MP+2)) = AVAIL;\n   END;\n\n /*  <ITERATION CONTROL> ::= TO <EXPRESSION>    */\n   DO;\n      REG(MP) = DBR;\n      FIXL(MP) = TRUELOC;  /* POINT AT THE CONSTANT ONE FOR STEP  */\n      CALL SET_LIMIT;\n   END;\n\n /*  <ITERATION CONTROL> ::= TO <EXPRESSION> BY <EXPRESSION>    */\n   DO;\n      IF TYPE(SP) = CONSTANT THEN CALL EMITCONSTANT (FIXV(SP));\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR (SP);\n            CALL EMITDATAWORD (0);\n            CALL FINDADDRESS (DP-4);\n            CALL EMITRX (STORE, REG(SP), 0, ADREG, ADRDISP);\n            BASES(REG(SP)) = AVAIL;\n         END;\n      REG(MP) = ADREG;\n      FIXL(MP) = ADRDISP;\n      CALL SET_LIMIT;\n   END;\n\n /*  <WHILE CLAUSE> ::= WHILE <EXPRESSION>    */\n   CALL BOOLBRANCH(SP, MP);\n\n /*  <CASE SELECTOR> ::= CASE <EXPRESSION>    */\n   DO;\n      CALL FORCEACCUMULATOR(SP);\n      CALL EMITRX(\"89\", REG(SP), 0, 0, 2);\n      FIXL(MP) = PP;\n      CALL EMITRX(LOAD, REG(SP), REG(SP), 0, 0);\n      CALL EMITRX(BC, \"F\", REG(SP), PBR, 0);\n      BASES(REG(SP)) = AVAIL;\n      FIXV(MP) = PP;\n      CALL BRANCH(\"F\", 0);\n      IF CASEP >= CASELIMIT THEN CALL ERROR ('TOO MANY CASES', 1);\n      ELSE CASEP = CASEP + 1;\n      CASESTACK(CASEP) = PP;\n      PPSAVE(MP) = CASEP;\n   END;\n\n /*  <PROCEDURE DEFINITION> ::= <PROCEDURE HEAD> <STATEMENT LIST> <ENDING>    */\n   DO; /* PROCEDURE IS DEFINED, RESTORE SYMBOL TABLE */\n      IF LENGTH(VAR(SP)) > 0 THEN\n         IF SUBSTR(CURRENT_PROCEDURE, 1) \u00ac= VAR(SP) THEN\n            CALL ERROR ('PROCEDURE' || CURRENT_PROCEDURE || ' CLOSED BY END ' ||\n               VAR(SP), 0);\n      IF CONTROL(BYTE('S')) THEN CALL SYMBOLDUMP;\n      DO I = PROCMARK TO NDECSY;\n         IF SYTYPE(I) = FORWARDTYPE | SYTYPE(I) = FORWARDCALL THEN\n          IF SYTCO(I) > 0 THEN\n            CALL ERROR ('UNDEFINED LABEL OR PROCEDURE: ' || SYT(I), 1);\n      END;\n      DO I = PROCMARK + PARCT  TO  NDECSY + 1;\n         SYT(I) = X1;\n      END;\n      NDECSY = PROCMARK + PARCT - 1;\n      /* PARAMETER ADDRESS MUST BE SAVED BUT NAMES DISCARDED */\n      DO I = PROCMARK TO NDECSY;\n         IF SYTYPE(I) = 0 THEN\n            DO;\n               CALL ERROR('UNDECLARED PARAMETER:' || SYT(I));\n               SYTYPE(I) = FIXEDTYPE;\n               CALL EMITDATAWORD(0);\n               CALL FINDADDRESS(DP-4);\n               SYBASE(I) = ADREG;\n               SYDISP(I) = ADRDISP;\n            END;\n         SYT(I) = '';\n      END;\n      CURRENT_PROCEDURE = VAR(MP);\n      PROCMARK = FIXV(MP);  PARCT = CNT(MP);\n      RETURNED_TYPE = TYPE(MP) ;\n      /* EMIT A GRATUITOUS RETURN */\n      CALL FINDADDRESS(RTNADR);\n      CALL EMITRX(LOAD, BRCHREG, 0, ADREG, ADRDISP);\n      CALL EMITRR(BCR, \"F\", BRCHREG);\n      RTNADR = PPSAVE(MP);\n      CALL FIXBFW(FIXL(MP), PP); /* COMPLETE JUMP AROUND PROCEDURE DEFINITION */\n   END;\n\n /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> ;    */\n   DO;  /* MUST POINT AT FIRST PARAMETER EVEN IF NONEXISTENT  */\n      /* SAVE OLD PARAMETER COUNT */\n      CNT(MP) = PARCT; PARCT = 0;\n      /* SAVE OLD PROCEDURE MARK IN SYMBOL TABLE */\n      FIXV(MP) = PROCMARK;  PROCMARK = NDECSY + 1;\n      TYPE(MP) = RETURNED_TYPE;\n      RETURNED_TYPE = 0;\n      CALL PROC_START;\n   END;\n\n\n /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> <TYPE> ;    */\n   DO;\n      CNT(MP) = PARCT;\n      PARCT = 0;\n      FIXV(MP) = PROCMARK;\n      PROCMARK = NDECSY + 1;\n      TYPE(MP) = RETURNED_TYPE;\n      RETURNED_TYPE = TYPE(SP-1);\n      IF RETURNED_TYPE = CHRTYPE THEN\n         SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE ;\n      CALL PROC_START;\n   END;\n\n /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> <PARAMETER LIST> ;    */\n   DO;\n      CNT(MP) = CNT(MPP1);  /* SAVE PARAMETER COUNT */\n      FIXV(MP) = FIXV(MPP1);\n      TYPE(MP) = RETURNED_TYPE;\n      RETURNED_TYPE = 0;\n      CALL PROC_START;\n   END;\n\n\n /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> <PARAMETER LIST> <TYPE> ;       */\n   DO;\n      CNT(MP) = CNT(MPP1);\n      FIXV(MP) = FIXV(MPP1);\n      TYPE(MP) = RETURNED_TYPE;\n      RETURNED_TYPE = TYPE(SP-1);\n      IF RETURNED_TYPE = CHRTYPE THEN\n         SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE ;\n      CALL PROC_START;\n   END;\n\n /*  <PROCEDURE NAME> ::= <LABEL DEFINITION> PROCEDURE    */\n   DO;\n      S = CURRENT_PROCEDURE;\n      CURRENT_PROCEDURE = X1 || VAR(MP);\n      VAR(MP) = S;\n   END;\n\n /*  <PARAMETER LIST> ::= <PARAMETER HEAD> <IDENTIFIER> )    */\n   DO;\n      PARCT = PARCT + 1;\n      CALL ENTER (VAR(MPP1), 0, 0, 0);\n   END;\n\n /*  <PARAMETER HEAD> ::= (   */\n   DO;  /* POINT AT THE FIRST PARAMETER FOR SYMBOL TABLE */\n      FIXV(MP) = PROCMARK;  PROCMARK = NDECSY + 1;\n      CNT(MP) = PARCT;\n      PARCT = 0;\n   END;\n\n /*  <PARAMETER HEAD> ::= <PARAMETER HEAD> <IDENTIFIER> ,    */\n   DO;\n      PARCT = PARCT + 1;\n      CALL ENTER (VAR(MPP1), 0, 0, 0);\n   END;\n\n /*  <ENDING> ::= END    */\n   VAR(MP) = '';\n\n /*  <ENDING> ::= END <IDENTIFIER>    */\n   VAR(MP) = VAR(SP);\n\n /*  <ENDING> ::= <LABEL DEFINITION> <ENDING>    */\n   VAR(MP) = VAR(SP);\n\n /*  <LABEL DEFINITION> ::= <IDENTIFIER> :    */\n   FIXL(MP) = ENTER (VAR(MP), LABELTYPE, PP, FIXL(MP));\n\n\n /*  <RETURN STATEMENT> ::= RETURN    */\n   DO;  /* EMIT A RETURN BRANCH */\n      CALL FINDADDRESS(RTNADR);\n      CALL EMITRX(LOAD, BRCHREG,0,ADREG,ADRDISP);\n      CALL EMITRR(BCR,\"F\",BRCHREG);\n   END;\n\n /*  <RETURN STATEMENT> ::= RETURN <EXPRESSION>    */\n   DO;  /* EMIT A RETURN BRANCH & PASS VALUE IN REGISTER 3 */\n      /* NOW FORCE IT INTO REGISTER 3 */\n      TARGET_REGISTER = 3;\n      IF RETURNED_TYPE = CHRTYPE THEN\n         CALL FORCEDESCRIPT(MPP1);\n      ELSE\n         CALL FORCEACCUMULATOR(MPP1);\n      TARGET_REGISTER = -1;\n      IF REG(MPP1) \u00ac = 3 THEN CALL EMITRR(\"18\",3,REG(MPP1));\n      CALL FINDADDRESS(RTNADR);\n      CALL EMITRX(LOAD, BRCHREG, 0, ADREG, ADRDISP);\n      CALL EMITRR(BCR, \"F\", BRCHREG);\n      CALL CLEARREGS;\n   END;\n\n /*  <CALL STATEMENT> ::= CALL <VARIABLE>    */\n   DO;\n      CALL FORCEACCUMULATOR(SP);\n      CALL CLEARREGS;\n   END;\n\n /*  <GO TO STATEMENT> ::= <GO TO> <IDENTIFIER>    */\n   DO;\n      CALL ID_LOOKUP(SP);\n      J = FIXL(SP);\n      IF J < 0 THEN          /*  1ST OCURRANCE OF THE LABEL */\n         DO;\n            CALL EMITDATAWORD(0);      /* SPACE FOR FIXUP */\n            J = ENTER (VAR(SP), FORWARDTYPE, DP-4, FIXL(SP));\n            SYTCO(J) = 1;\n         END;\n      IF SYTYPE(J) = LABELTYPE THEN\n         CALL BRANCH_BD(\"F\",SYBASE(J),SYDISP(J));\n      ELSE IF SYTYPE(J) = FORWARDTYPE THEN\n         DO;\n            CALL EMITRX(LOAD,BRCHREG,0,SYBASE(J),SYDISP(J));\n            CALL EMITRX(BC,\"F\",BRCHREG,PBR,0);\n         END;\n      ELSE\n         DO;\n            CALL ERROR('TARGET OF GO TO IS NOT A LABEL',0);\n            CALL EMITRX(BC,\"F\",0,SYBASE(J),SYDISP(J));\n         END;\n   END;\n\n /*  <GO TO> ::= GO TO    */\n      ;\n /*  <GO TO> ::= GOTO    */\n      ;\n /*  <DECLARATION STATEMENT> ::= DECLARE <DECLARATION ELEMENT>    */\n      ;\n\n /*  <DECLARATION STATEMENT> ::= <DECLARATION STATEMENT> , <DECLARATION ELEMENT>\n          */\n      ;\n\n /*  <DECLARATION ELEMENT> ::= <TYPE DECLARATION>    */\n   DO;\n      IF TYPE(MP) = CHRTYPE THEN\n         DSP = NEWDSP ;\n      ELSE\n         DO;\n            DP = NEWDP ;\n            CALL CHECKBASES ;\n         END;\n   END;\n\n /*  <DECLARATION ELEMENT> ::= <IDENTIFIER> LITERALLY <STRING>    */\n      IF TOP_MACRO >= MACRO_LIMIT THEN\n         CALL ERROR('MACRO TABLE OVERFLOW',1);\n      ELSE\n         DO;\n            TOP_MACRO = TOP_MACRO + 1;\n            I = LENGTH(VAR(MP));\n            J = MACRO_INDEX(I);\n            DO L = 1 TO TOP_MACRO - J;\n               K = TOP_MACRO - L;\n               MACRO_NAME(K+1) = MACRO_NAME(K);\n               MACRO_TEXT(K+1) = MACRO_TEXT(K);\n            END;\n            MACRO_NAME(J) = VAR(MP);\n            MACRO_TEXT(J) = VAR(SP);\n            DO J = I TO 255;\n               MACRO_INDEX(J) = MACRO_INDEX(J)+1;\n            END;\n         END;\n\n /*  <TYPE DECLARATION> ::= <IDENTIFIER SPECIFICATION> <TYPE>    */\n   CALL TDECLARE(0);\n\n /*  <TYPE DECLARATION> ::= <BOUND HEAD> <NUMBER> ) <TYPE>    */\n   CALL TDECLARE(FIXV(MPP1));\n\n /*  <TYPE DECLARATION> ::= <TYPE DECLARATION> <INITIAL LIST>    */\n      ;\n\n /*  <TYPE> ::= FIXED    */\n   TYPE(MP) = FIXEDTYPE ;\n\n /*  <TYPE> ::= CHARACTER    */\n   TYPE(MP) = CHRTYPE ;\n\n /*  <TYPE> ::= LABEL    */\n   TYPE(MP) = FORWARDTYPE ;\n\n /*  <TYPE> ::= <BIT HEAD> <NUMBER> )    */\n      IF FIXV(MPP1) <= 8 THEN TYPE(MP) = BYTETYPE;\n      ELSE IF FIXV(MPP1) <= 16 THEN TYPE(MP) = HALFWORD;\n      ELSE IF FIXV(MPP1) <= 32 THEN TYPE(MP) = FIXEDTYPE;\n      ELSE TYPE(MP) = CHRTYPE;\n\n /*  <BIT HEAD> ::= BIT (   */\n      ;\n\n /*  <BOUND HEAD> ::= <IDENTIFIER SPECIFICATION> (   */\n      ;\n\n /*  <IDENTIFIER SPECIFICATION> ::= <IDENTIFIER>    */\n   DO;\n      INX(MP) = 1;\n      I = FIXL(MP);\n      FIXL(MP) = CASEP;\n      IF CASEP >= CASELIMIT THEN\n         CALL ERROR(DCLRM,1);\n      ELSE\n         CASEP = CASEP + 1;\n      CASESTACK(CASEP) = ENTER (VAR(MP), 0, 0, I);\n   END;\n\n /*  <IDENTIFIER SPECIFICATION> ::= <IDENTIFIER LIST> <IDENTIFIER> )    */\n   DO;\n      INX(MP) = INX(MP) + 1;\n      IF CASEP >= CASELIMIT THEN\n         CALL ERROR(DCLRM, 1);\n      ELSE\n         CASEP = CASEP + 1;\n      CASESTACK(CASEP) = ENTER (VAR(MPP1), 0, 0, FIXL(MPP1));\n   END;\n\n /*  <IDENTIFIER LIST> ::= (   */\n   DO;\n      INX(MP) = 0;\n      FIXL(MP) = CASEP;\n   END;\n\n /*  <IDENTIFIER LIST> ::= <IDENTIFIER LIST> <IDENTIFIER> ,    */\n   DO;\n      INX(MP) = INX(MP) + 1;\n      IF CASEP >= CASELIMIT THEN\n         CALL ERROR(DCLRM, 1);\n      ELSE\n         CASEP = CASEP + 1;\n      CASESTACK(CASEP) = ENTER (VAR(MPP1), 0, 0, FIXL(MPP1));\n   END;\n\n /*  <INITIAL LIST> ::= <INITIAL HEAD> <CONSTANT> )    */\n   CALL SETINIT ;\n\n /*  <INITIAL HEAD> ::= INITIAL (   */\n   IF INX(MP-1) = 1 THEN\n      ITYPE = TYPE(MP-1);    /*  INFORMATION FROM  <TYPE DECLARATION>  */\n   ELSE\n      DO;\n         CALL ERROR('INITIAL MAY NOT BE USED WITH IDENTIFIER LIST',0);\n         ITYPE = 0;\n      END;\n\n\n /*  <INITIAL HEAD> ::= <INITIAL HEAD> <CONSTANT> ,    */\n   CALL SETINIT;\n\n /*  <ASSIGNMENT> ::= <VARIABLE> <REPLACE> <EXPRESSION>    */\n   CALL GENSTORE(MP,SP);\n\n /*  <ASSIGNMENT> ::= <LEFT PART> <ASSIGNMENT>    */\n   CALL GENSTORE(MP,SP);\n\n /*  <REPLACE> ::= =    */\n   ;\n\n /*  <LEFT PART> ::= <VARIABLE> ,    */\n   ;\n\n /*  <EXPRESSION> ::= <LOGICAL FACTOR>    */\n      ;\n /*  <EXPRESSION> ::= <EXPRESSION> | <LOGICAL FACTOR>    */\n   /* \"16\" = OR, \"56\" = O */\n   CALL ARITHEMIT(\"16\");\n\n /*  <LOGICAL FACTOR> ::= <LOGICAL SECONDARY>    */\n      ;\n\n /*  <LOGICAL FACTOR> ::= <LOGICAL FACTOR> & <LOGICAL SECONDARY>    */\n   /* \"14\" = NR, \"54\" = N */\n   CALL ARITHEMIT(\"14\");\n\n /*  <LOGICAL SECONDARY> ::= <LOGICAL PRIMARY>    */\n   IF TYPE(MP) = CONDITION THEN CALL CONDTOREG(MP, REG(MP));\n\n /*  <LOGICAL SECONDARY> ::= \u00ac <LOGICAL PRIMARY>    */\n   DO;\n      CALL MOVESTACKS (SP, MP);\n      IF TYPE(MP) = CONDITION THEN\n         CALL CONDTOREG (MP, \"E\" - REG(MP));\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR (MP);\n              /* \"57\" = X */\n            CALL EMITRX (\"57\", REG(MP), 0, DBR, COMPLOC);\n         END;\n   END;\n\n /*  <LOGICAL PRIMARY> ::= <STRING EXPRESSION>    */\n      ;\n\n   /*              CONDITION CODES     MASK\n                   0  OPERANDS EQUAL   BIT 8\n                   1  FIRST OPERAND LO BIT 9\n                   2  FIRST OPERAND HI BIT 10                                 */\n\n /*  <LOGICAL PRIMARY> ::= <STRING EXPRESSION> <RELATION> <STRING EXPRESSION>\n         */\n   DO;\n      CALL ARITHEMIT(CMPRR);\n      BASES(REG(MP)) = AVAIL;\n      REG(MP) = REG(MPP1);\n      TYPE(MP) = CONDITION;\n   END;\n\n /*  <RELATION> ::= =    */\n   REG(MP) = 6;\n\n /*  <RELATION> ::= <    */\n   REG(MP) = 10;\n\n /*  <RELATION> ::= >    */\n   REG(MP) = 12;\n\n /*  <RELATION> ::= \u00ac =    */\n   REG(MP) = 8;\n\n /*  <RELATION> ::= \u00ac <    */\n   REG(MP) = 4;\n\n /*  <RELATION> ::= \u00ac >    */\n   REG(MP) = 2;\n\n /*  <RELATION> ::= < =    */\n   REG(MP) = 2;\n\n /*  <RELATION> ::= > =    */\n   REG(MP) = 4;\n\n /*  <STRING EXPRESSION> ::= <ARITHMETIC EXPRESSION>    */\n      ;\n\n /*  <STRING EXPRESSION> ::= <STRING EXPRESSION> || <ARITHMETIC EXPRESSION>\n         */\n   DO; /* CATENATE TWO STRINGS */\n      CALL FORCEDESCRIPT(MP);\n      CALL EMITRX(STORE,REG(MP),0,A1,A2);\n      BASES(REG(MP)) = AVAIL;\n      CALL FORCEDESCRIPT(SP);\n      CALL EMITRX(STORE,REG(SP),0,B1,B2);\n      BASES(REG(SP)) = AVAIL;\n      CALL CALLSUB(0,CATENTRY,3,MP);\n      /* ASSUME CATENATE IS IN THE 1ST PAGE */\n\n      TYPE(MP) = DESCRIPT;\n   END;\n\n /*  <ARITHMETIC EXPRESSION> ::= <TERM>    */\n      ;\n /*  <ARITHMETIC EXPRESSION> ::= <ARITHMETIC EXPRESSION> + <TERM>    */\n   /* \"1A\" = AR, \"5A\" = A  */\n   CALL ARITHEMIT(\"1A\");\n\n /*  <ARITHMETIC EXPRESSION> ::= <ARITHMETIC EXPRESSION> - <TERM>    */\n   /* \"1B\" = SR, \"5B\" = S */\n   CALL ARITHEMIT(\"1B\");\n\n /*  <ARITHMETIC EXPRESSION> ::= + <TERM>    */\n   CALL MOVESTACKS(MPP1,MP);\n\n /*  <ARITHMETIC EXPRESSION> ::= - <TERM>    */\n   DO;\n      CALL MOVESTACKS(MPP1, MP);\n      IF TYPE(MP) = CONSTANT THEN FIXV(MP) = - FIXV(MP);\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR(MP);\n            CALL EMITRR(\"13\", REG(MP), REG(MP));  /* LCR = COMPLEMENT */\n         END;\n   END;\n\n /*  <TERM> ::= <PRIMARY>    */\n      ;\n\n /*  <TERM> ::= <TERM> * <PRIMARY>    */\n   /* \"1C\" = MR, \"5C\" = M */\n   DO;\n      CALL FORCEACCUMULATOR(MP);\n      IF REG(MP) = 1 THEN\n         DO;  /* MULTIPLY IS FUNNY ON A 360--SORRY */\n            REG(MP) = 0;\n            CALL ARITHEMIT(\"1C\");\n            REG(MP) = 1;\n         END;\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR(SP);\n             IF REG(SP) = 1 THEN\n               DO;\n                  CALL EMITRR(\"1C\",0,REG(MP));\n                  BASES(REG(MP)) = AVAIL;\n                  REG(MP) = 1;\n               END;\n            ELSE IF REG(MP) + REG(SP) = 5 THEN\n               DO;  /* OPERANDS ARE IN 2 & 3 */\n                  CALL EMITRR(\"1C\",2,2);\n                  BASES(2) = AVAIL;\n                  REG(MP) = 3;\n               END;\n            ELSE CALL ERROR ('MULTIPLY FAILED ***', 1);\n         END;\n   END;\n\n /*  <TERM> ::= <TERM> / <PRIMARY>    */\n   CALL DIVIDE_CODE;\n   /*  DIVIDE IS EVEN FUNNIER THAN MULTIPLY  */\n\n /*  <TERM> ::= <TERM> MOD <PRIMARY>    */\n   DO;\n      CALL DIVIDE_CODE;\n      CALL EMITRR(\"18\",1,0);                     /*  LR    1,0        */\n   END;\n\n /*  <PRIMARY> ::= <CONSTANT>    */\n      ;\n /*  <PRIMARY> ::= <VARIABLE>    */\n      IF FIXV(MP) = 3 THEN   /*  FINISH OFF THE FUNCTION  BYTE        */\n         IF CNT(MP) = 1 THEN\n            DO;\n               IF TYPE(MP) = CHRTYPE THEN\n                  DO;\n                     TYPE(MP) = CONSTANT;\n                     FIXV(MP) = BYTE(VAR(MP));\n                  END;\n               ELSE\n                  DO;\n                     I = FINDAC;\n                     CALL EMITRR(\"1B\",I,I);      /*  SR    I,I        */\n                     CALL EMITRX(\"43\",I,0,REG(MP),0);\n                                                 /*  IC               */\n                     BASES(REG(MP)) = AVAIL;\n                     REG(MP) = I;\n                     TYPE(MP) = ACCUMULATOR;\n                  END;\n            END;\n         ELSE IF CNT(MP) = 2 THEN\n            DO;\n               I = INX(MP);\n                     CALL EMITRX(\"43\",I,I,REG(MP),0);\n                     BASES(REG(MP)) = AVAIL;\n                     REG(MP) = I;\n               TYPE(MP) = ACCUMULATOR;\n            END;\n\n /*  <PRIMARY> ::= ( <EXPRESSION> )    */\n   CALL MOVESTACKS(MPP1, MP);\n\n /*  <VARIABLE> ::= <IDENTIFIER>    */\n   DO;      /* FIND THE IDENTIFIER IN THE SYMBOL TABLE */\n      CALL ID_LOOKUP(MP);\n      IF FIXL(MP) = -1 THEN\n         CALL UNDECLARED_ID(MP);\n   END;\n\n /*  <VARIABLE> ::= <SUBSCRIPT HEAD> <EXPRESSION> )    */\n   DO;  /* EITHER A PROCEDURE CALL OR ARRAY OR BUILT IN FUNCTION */\n      CNT(MP) = CNT(MP) + 1;\n      I = FIXV(MP);\n\n      IF I < 6 THEN\n      DO CASE I;\n\n         /* CASE  0  */\n\n         DO;      /* SUBS | CALL */\n            CALL FORCEACCUMULATOR (MPP1);\n            IF SYTYPE(FIXL(MP)) = LABELTYPE |\n               SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE  THEN\n               CALL STUFF_PARAMETER;\n            ELSE\n               DO;      /* SUBSCRIPTED VARIABLE */\n                  IF CNT(MP) > 1 THEN\n                     CALL ERROR ('MULTIPLE SUBSCRIPTS NOT ALLOWED', 0);\n                  INX(MP) = REG(MPP1);\n               END;\n         END;\n\n         /* CASE  1  */\n\n         DO;  /* BUILT IN FUNCTION: LENGTH */\n            CALL FORCEDESCRIPT (MPP1);\n            CALL EMITRR (\"12\", REG(MPP1), REG(MPP1));  /* LTR TO CHECK FOR NUL*/\n            CALL EMITRX (\"88\", REG(MPP1), 0, 0, 24);  /* SHIFT TO CHARACTER */\n            I = PP;\n            CALL BRANCH (8, 0);   /* DON'T INCREMENT LENGTH ON NULL STRING */\n            CALL EMITRX (LA, REG(MPP1), 0, REG(MPP1), 1); /*ADD 1, TRUE LENGTH*/\n            CALL FIXBFW (I, PP);  /* DESTINATION OF NULL STRING JUMP */\n            REG(MP) = REG(MPP1);  /* RECORD CONTAINING ACCUMULATOR */\n            TYPE(MP) = ACCUMULATOR;\n         END;\n\n         /* CASE  2  */\n\n         /* BUILT-IN FUNCTION SUBSTR */\n         DO;\n            IF CNT(MP) = 2 THEN\n               DO;\n                  IF TYPE(MPP1) = CONSTANT THEN\n                     DO;\n                        CALL EMITCONSTANT (SHL(FIXV(MPP1), 24) - FIXV(MPP1));\n                        CALL EMITRX (\"5F\", REG(MP), 0, ADREG, ADRDISP);\n                     END;\n                  ELSE\n                     DO;\n                        CALL FORCEACCUMULATOR (MPP1);\n                        CALL EMITRR (\"1E\", REG(MP), REG(MPP1)); /* ALR BASE */\n                        CALL EMITRX (\"89\", REG(MPP1), 0, 0, 24);\n                        CALL EMITRR (\"1F\", REG(MP), REG(MPP1));\n                        BASES(REG(MPP1)) = AVAIL;\n                     END;\n                  I = PP;\n                  CALL BRANCH (1, 0);     /* WE MAY NOW HAVE NEGATIVE LENGTH */\n                  CALL EMITRR (\"1B\", REG(MP), REG(MP));  /* NULL DESCRIPTOR */\n                  CALL FIXBFW (I, PP);\n               END;\n            ELSE\n               DO;         /* THREE ARGUMENTS */\n                  CALL EMITRX (LA, REG(MP), INX(MP), REG(MP), PPSAVE(MP));\n                  BASES(INX(MP)) = AVAIL;\n                  IF TYPE(MPP1) \u00ac= CONSTANT THEN\n                     DO;\n                        CALL FORCEACCUMULATOR (MPP1);\n                        CALL EMITRX (LA, REG(MPP1), 0, REG(MPP1), \"FF\");\n                                /* DECREMENT LENGTH BY 1  */\n                        CALL EMITRX (\"89\", REG(MPP1), 0, 0, 24);\n                        CALL EMITRR (\"16\", REG(MP), REG(MPP1));  /* | INTO D */\n                        BASES(REG(MPP1)) = AVAIL;\n                     END;\n                  ELSE\n                     DO;\n                        CALL EMITCONSTANT (SHL(FIXV(MPP1)-1, 24));\n                        CALL EMITRX (\"56\", REG(MP), 0, ADREG, ADRDISP);\n                     END;\n               END;\n            TYPE(MP) = DESCRIPT;\n         END;\n\n         /* CASE  3  */\n\n         DO;      /* BUILT IN FUNCTION BYTE */\n            IF CNT(MP) = 1 THEN\n               DO;\n                  IF TYPE(MPP1) = CHRTYPE THEN\n                     DO;\n                        TYPE(MP) = CHRTYPE;\n                        VAR(MP) = VAR(MPP1);\n                     END;\n                  ELSE\n                     DO;\n                        CALL FORCEDESCRIPT(MPP1);\n                        IF REG(MPP1) = 0 THEN\n                           DO;\n                              REG(MP) = FINDAC;\n                              CALL EMITRR(\"18\",REG(MP),0);\n                                                 /*  LR    REG(MP),0  */\n                           END;\n                        ELSE\n                           REG(MP) = REG(MPP1);\n                        TYPE(MP) = DESCRIPT;\n                        INX(MP) = 0;\n                    END;\n               END;\n            ELSE IF CNT(MP) = 2 THEN\n               DO;\n                  CALL FORCEACCUMULATOR(MPP1);\n                  INX(MP) = REG(MPP1);\n               END;\n            ELSE\n               CALL ERROR('BYTE CALLED WITH MORE THAN TWO ARGUMENTS',0);\n         END;\n\n         /* CASE  4  */\n\n         CALL SHIFT_CODE(\"89\");        /*  SLL  */\n\n         /* CASE  5  */\n\n         CALL SHIFT_CODE(\"88\");        /*  SRL  */\n      END;     /* OF CASE STATEMENT */\n\n      ELSE IF I = 10 THEN\n         CALL EMIT_INLINE;\n      ELSE IF I = 19 THEN    /*  BUILTIN  FUNCTION  ADDR   */\n         DO;\n            REG(MP) = FINDAC;\n            CALL FORCE_ADDRESS(MPP1,REG(MP));\n            TYPE(MP) = ACCUMULATOR;\n         END;\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR (MPP1);\n            IF CNT(MP) = 1 THEN REG(MP) = REG(MPP1);\n            ELSE INX(MP) = REG(MPP1);\n         END;\n\n   END;     /* OF PRODUCTION */\n\n /*  <SUBSCRIPT HEAD> ::= <IDENTIFIER> (   */\n   DO;\n      CALL ID_LOOKUP(MP);\n      IF FIXL(MP) < 0 THEN\n         CALL UNDECLARED_ID(MP);\n   END;\n\n /*  <SUBSCRIPT HEAD> ::= <SUBSCRIPT HEAD> <EXPRESSION> ,    */\n   DO;      /* BUILT IN FUNCTION OR PROCEDURE CALL */\n      CNT(MP) = CNT(MP) + 1;\n      IF FIXV(MP) = 0 THEN\n         DO;      /* \u00ac BUILT IN FUNCTION */\n            CALL FORCEACCUMULATOR (MPP1);\n            IF SYTYPE(FIXL(MP)) = LABELTYPE |\n               SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE  THEN\n               CALL STUFF_PARAMETER;\n         END;\n      ELSE IF FIXV(MP) = 2 | FIXV(MP) = 3 THEN\n         DO;      /* SUBSTR OR BYTE */\n            IF CNT(MP) = 1 THEN\n               DO;\n                  CALL FORCEDESCRIPT (MPP1);\n                  IF REG(MPP1) = 0 THEN\n                     DO;\n                        REG(MP) = FINDAC;\n                        CALL EMITRR (\"18\", REG(MP), 0);\n                     END;\n                  ELSE REG(MP) = REG(MPP1);\n               END;\n            ELSE IF CNT(MP) = 2 THEN\n               DO;\n                  IF TYPE(MPP1) = CONSTANT THEN PPSAVE(MP) = FIXV(MPP1);\n                  ELSE\n                     DO;\n                        CALL FORCEACCUMULATOR (MPP1);\n                        INX(MP) = REG(MPP1);\n                        PPSAVE(MP) = 0;\n                     END;\n               END;\n            ELSE CALL ERROR ('TOO MANY ARGUMENTS TO SUBSTR | BYTE');\n         END;\n      ELSE IF FIXV(MP) = 4 | FIXV(MP) = 5 THEN\n         DO;  /*  SHR  |  SHL  */\n            CALL FORCEACCUMULATOR(MPP1);\n            REG(MP) = REG(MPP1);\n         END;\n      ELSE IF FIXV(MP) = 10 THEN\n         CALL EMIT_INLINE;\n      ELSE IF FIXV(MP) >= 8 THEN\n         DO;      /* SOME SORT OF MONITOR CALL */\n            CALL FORCEACCUMULATOR (MPP1);\n            IF CNT(MP) = 1 THEN REG(MP) = REG(MPP1);\n            ELSE CALL ERROR ('TOO MANY ARGUMENTS FOR ' || SYT(FIXL(MP)));\n         END;\n      ELSE;      /* RESERVED FOR OTHER BUILT IN FUNCTIONS */\n   END;\n\n /*  <CONSTANT> ::= <STRING>    */\n   TYPE(MP) = CHRTYPE;\n\n /*  <CONSTANT> ::= <NUMBER>    */\n   TYPE(MP) = CONSTANT;\n\n   END;  /* OF CASE SELECTION ON PRODUCTION NUMBER */\nEND SYNTHESIZE;\n\n\n\n\n  /*              SYNTACTIC PARSING FUNCTIONS                              */\n\n\nRIGHT_CONFLICT:\n   PROCEDURE (LEFT) BIT(1);\n      DECLARE LEFT FIXED;\n      /*  THIS PROCEDURE IS TRUE IF TOKEN IS \u00ac A LEGAL RIGHT CONTEXT OF LEFT*/\n      RETURN (\"C0\" & SHL(BYTE(C1(LEFT), SHR(TOKEN,2)), SHL(TOKEN,1)\n         & \"06\")) = 0;\n   END RIGHT_CONFLICT;\n\n\nRECOVER:\n   PROCEDURE;\n      /* IF THIS IS THE SECOND SUCCESSIVE CALL TO RECOVER, DISCARD ONE SYMBOL */\n      IF \u00ac FAILSOFT THEN CALL SCAN;\n      FAILSOFT = FALSE;\n      DO WHILE \u00ac STOPIT(TOKEN);\n         CALL SCAN;  /* TO FIND SOMETHING SOLID IN THE TEXT  */\n      END;\n      DO WHILE RIGHT_CONFLICT (PARSE_STACK(SP));\n         IF SP > 2 THEN SP = SP - 1;  /* AND IN THE STACK  */\n         ELSE CALL SCAN;  /* BUT DON'T GO TOO FAR  */\n      END;\n      OUTPUT = 'RESUME:' || SUBSTR(POINTER, TEXT_LIMIT+LB-CP+MARGIN_CHOP+7);\n   END RECOVER;\n\nSTACKING:\n   PROCEDURE BIT(1);  /* STACKING DECISION FUNCTION */\n      COUNT#STACK = COUNT#STACK + 1;\n      DO FOREVER;    /* UNTIL RETURN  */\n         DO CASE SHR(BYTE(C1(PARSE_STACK(SP)),SHR(TOKEN,2)),SHL(3-TOKEN,1)&6)&3;\n\n            /*  CASE 0  */\n            DO;    /* ILLEGAL SYMBOL PAIR  */\n               CALL ERROR('ILLEGAL SYMBOL PAIR: ' || V(PARSE_STACK(SP)) || X1 ||\n                  V(TOKEN), 1);\n               CALL STACK_DUMP;\n               CALL RECOVER;\n            END;\n\n            /*  CASE 1  */\n\n            RETURN TRUE;      /*  STACK TOKEN  */\n\n            /*  CASE 2  */\n\n            RETURN FALSE;     /* DON'T STACK IT YET  */\n\n            /*  CASE 3  */\n\n            DO;      /* MUST CHECK TRIPLES  */\n               J = SHL(PARSE_STACK(SP-1), 16) + SHL(PARSE_STACK(SP), 8) + TOKEN;\n               I = -1;  K = NC1TRIPLES + 1;  /* BINARY SEARCH OF TRIPLES  */\n               DO WHILE I + 1 < K;\n                  L = SHR(I+K, 1);\n                  IF C1TRIPLES(L) > J THEN K = L;\n                  ELSE IF C1TRIPLES(L) < J THEN I = L;\n                  ELSE RETURN TRUE;  /* IT IS A VALID TRIPLE  */\n               END;\n               RETURN FALSE;\n            END;\n\n         END;    /* OF DO CASE  */\n      END;   /*  OF DO FOREVER */\n   END STACKING;\n\nPR_OK:\n   PROCEDURE(PRD) BIT(1);\n      /* DECISION PROCEDURE FOR CONTEXT CHECK OF EQUAL OR IMBEDDED RIGHT PARTS*/\n      DECLARE (H, I, J, PRD) FIXED;\n      DO CASE CONTEXT_CASE(PRD);\n\n         /*  CASE 0 -- NO CHECK REQUIRED  */\n\n         RETURN TRUE;\n\n         /*  CASE 1 -- RIGHT CONTEXT CHECK  */\n\n         RETURN \u00ac RIGHT_CONFLICT (HDTB(PRD));\n\n         /*  CASE 2 -- LEFT CONTEXT CHECK  */\n\n         DO;\n            H = HDTB(PRD) - NT;\n            I = PARSE_STACK(SP - PRLENGTH(PRD));\n            DO J = LEFT_INDEX(H-1) TO LEFT_INDEX(H) - 1;\n               IF LEFT_CONTEXT(J) = I THEN RETURN TRUE;\n            END;\n            RETURN FALSE;\n         END;\n\n         /*  CASE 3 -- CHECK TRIPLES  */\n\n         DO;\n            H = HDTB(PRD) - NT;\n            I = SHL(PARSE_STACK(SP - PRLENGTH(PRD)), 8) + TOKEN;\n            DO J = TRIPLE_INDEX(H-1) TO TRIPLE_INDEX(H) - 1;\n               IF CONTEXT_TRIPLE(J) = I THEN RETURN TRUE;\n            END;\n            RETURN FALSE;\n         END;\n\n      END;  /* OF DO CASE  */\n   END PR_OK;\n\n\n  /*                     ANALYSIS ALGORITHM                                  */\n\n\n\nREDUCE:\n   PROCEDURE;\n      DECLARE (I, J, PRD) FIXED;\n      /* PACK STACK TOP INTO ONE WORD */\n      DO I = SP - 4 TO SP - 1;\n         J = SHL(J, 8) + PARSE_STACK(I);\n      END;\n\n      DO PRD = PR_INDEX(PARSE_STACK(SP)-1) TO PR_INDEX(PARSE_STACK(SP)) - 1;\n         IF (PRMASK(PRLENGTH(PRD)) & J) = PRTB(PRD) THEN\n            IF PR_OK(PRD) THEN\n            DO;  /* AN ALLOWED REDUCTION */\n               MP = SP - PRLENGTH(PRD) + 1; MPP1 = MP + 1;\n               CALL SYNTHESIZE(PRDTB(PRD));\n               SP = MP;\n               PARSE_STACK(SP) = HDTB(PRD);\n               RETURN;\n            END;\n      END;\n\n      /* LOOK UP HAS FAILED, ERROR CONDITION */\n      CALL ERROR('NO PRODUCTION IS APPLICABLE',1);\n      CALL STACK_DUMP;\n      FAILSOFT = FALSE;\n      CALL RECOVER;\n   END REDUCE;\n\nCOMPILATION_LOOP:\n   PROCEDURE;\n\n      COMPILING = TRUE;\n      DO WHILE COMPILING;     /* ONCE AROUND FOR EACH PRODUCTION (REDUCTION)  */\n         DO WHILE STACKING;\n            SP = SP + 1;\n            IF SP = STACKSIZE THEN\n               DO;\n                  CALL ERROR ('STACK OVERFLOW *** COMPILATION ABORTED ***', 2);\n                  RETURN;   /* THUS ABORTING COMPILATION */\n               END;\n            PARSE_STACK(SP) = TOKEN;\n            VAR(SP) = BCD;\n            FIXV(SP) = NUMBER_VALUE;\n            FIXL(SP) = CARD_COUNT;\n            PPSAVE(SP) = PP;\n            CALL SCAN;\n         END;\n\n         CALL REDUCE;\n      END;     /* OF DO WHILE COMPILING  */\n   END COMPILATION_LOOP;\n\n\nLOADER:\n   PROCEDURE;\n\n      /*  WRITE OUT A LOAD FILE OF COMPILED CODE & DATA\n         ASSUMES CODE ON  FILE(CODEFILE, J)    J = 0 TO CODEMAX\n         ASSUMES DATA ON  FILE(DATAFILE, J)   J = 0 TO DATAMAX\n         ASSUMES STRINGS ON FILE(STRINGFILE,J)\n         OUTPUT  ON FILE(BINARYFILE, J)  J = 0 TO CODEMAX+DATAMAX+1\n         ASSUMES THAT BINARYFILE = CODEFILE    */\n\n\n      /*  PUT SOME CONTROL INFORMATION IN THE FIRST 60 BYTES OF THE\n         FIRST BLOCK OF CODE.  CONSECUTIVE WORDS OF THIS CONTROL\n         INFORMATION CONTAIN:\n\n            1  # OF BYTES OF PROGRAM\n            2  # OF BYTES OF DATA\n            3  # OF BLOCKS OF PROGRAM\n            4  # OF BLOCKS OF DATA\n            5  # OF BYTES PER BLOCK\n            6  # OF BYTES ACTUALLY FILLED IN THE LAST CODE BLOCK\n            7  # OF BYTES ACTUALLY FILLED IN THE LAST DATA BLOCK\n\n         THE FILE IS FORMATTED:\n\n            1  CODEMAX+1 BLOCKS OF PROGRAM\n               (AND CONTROL INFORMATION AT HEAD OF FIRST BLOCK)\n            2  DATAMAX+1 BLOCKS OF DATA AND STRINGS\n      */\n\n      DECLARE (I, J) FIXED;\n      DECLARE BLOCKCNT FIXED;  /* CUMMULATIVE BLOCK COUNTER DURING LOAD */\n\n      CONTROL(BYTE('E')) = FALSE;\n      EJECT_PAGE;\n      DP = BASES(SBR);\n      CALL FIXWHOLEDATAWORD (BASEDATA, DP);\n      DO I = 0 TO SHR(DSP,2);\n         CALL EMITDATAWORD (DESC(I));\n      END;\n      CALL FIXWHOLEDATAWORD(BASEDATA+4, DP);\n\n      /* COPY COMPILED CHARACTER STRINGS TO THE PROGRAM DATA AREA */\n      CHPORG = 0;\n      CHPLIM = DISKBYTES;\n      FILE(STRINGFILE,CURSBLK) = STRINGS;    /* WRITE OUT CURRENT BLOCK */\n      CURSBLK = 0;\n      STRINGS = FILE(STRINGFILE,CURSBLK);    /* READ IN FIRST BLOCK */\n\n      DO I = 0 TO CHP;\n         IF I >= CHPLIM THEN\n            DO;\n               CURSBLK = CURSBLK + 1;\n               STRINGS = FILE(STRINGFILE,CURSBLK);   /* READ IN NEXT BLOCK */\n               CHPORG = CHPORG + DISKBYTES;\n               CHPLIM = CHPLIM + DISKBYTES;\n            END;\n         CALL EMITBYTE(STRINGS(I-CHPORG));\n      END;\n\n      CALL FIXWHOLEDATAWORD(BASEDATA+8, DP);\n\n      CALL INSERT_CODE_FIXUPS;\n\n      CODE = FILE(CODEFILE,0);        /*  READ IN FIRST CODE RECORD  */\n\n      CODEMAX(1) = DISKBYTES*(CODEMAX+1);\n      CODEMAX(2) = DISKBYTES*(DATAMAX+1);\n      CODEMAX(3) = CODEMAX + 1;\n      CODEMAX(4) = DATAMAX + 1;\n      CODEMAX(5) = DISKBYTES;\n      IF SEVERE_ERRORS > 0 THEN IF \u00ac CONTROL(BYTE('Z')) THEN\n         DO;\n            CODE(60) = \"07\";\n            CODE(61) = \"FC\";\n            OUTPUT = '########  EXECUTION OF THIS PROGRAM WILL BE INHIBITED.';\n         END;\n      J = PP - CODEMAX(1) + DISKBYTES;    /*  PORTION ACTUALLY  USED  */\n      /* FORCES REMAINDER TO WORD BOUNDARY  */\n      J = (J + 3) & \"FFFFFC\";\n      CODEMAX(6) = J;\n        /* PORTION OF THE LAST DATA RECORD WHICH WAS ACTUALLY USED  */\n      CODEMAX(7) = (DP - CODEMAX(2) + DISKBYTES + 3) & \"FFFFFC\" ;\n\n\n      OUTPUT = '*  FILE CONTROL BLOCK  ' || CODEMAX(1) || X4 ||\n         CODEMAX(2) || X4 || CODEMAX(3) || X4 || CODEMAX(4) || X4 ||\n         CODEMAX(5) || X4 || CODEMAX(6) || X4 || CODEMAX(7);\n\n      FILE(BINARYFILE,0) = CODE;   /* WRITE FIRST RECORD TO BINARY FILE */\n\n      BLOCKCNT = CODEMAX + 1;\n\n      FILE(DATAFILE,CURDBLK) = DATA;  /* WRITE OUT CURRENT DATA ARRAY */\n\n\n      /*  WRITE OUT THE COMPILE DATA ARRAY  */\n\n      DO J = 0 TO DATAMAX;\n         DATA = FILE(DATAFILE,J);\n         FILE(BINARYFILE, BLOCKCNT)  =  DATA ;\n         BLOCKCNT = BLOCKCNT + 1;\n      END;\n\n      OUTPUT = '*  LOAD FILE WRITTEN.';\n\n   END LOADER;\n\n\nPRINT_SUMMARY:\n   PROCEDURE;\n      DECLARE I FIXED;\n      CALL PRINT_DATE_AND_TIME ('END OF COMPILATION ', DATE, TIME);\n      OUTPUT = '';\n      OUTPUT = CARD_COUNT || ' CARDS CONTAINING ' || STATEMENT_COUNT\n         || ' STATEMENTS WERE COMPILED.';\n      IF ERROR_COUNT = 0 THEN OUTPUT = 'NO ERRORS WERE DETECTED.';\n      ELSE IF ERROR_COUNT > 1 THEN\n         OUTPUT = ERROR_COUNT || ' ERRORS (' || SEVERE_ERRORS\n            || ' SEVERE) WERE DETECTED.';\n      ELSE IF SEVERE_ERRORS = 1 THEN OUTPUT = 'ONE SEVERE ERROR WAS DETECTED.';\n         ELSE OUTPUT = 'ONE ERROR WAS DETECTED.';\n      IF PREVIOUS_ERROR > 0 THEN\n         OUTPUT = 'THE LAST DETECTED ERROR WAS ON LINE ' || PREVIOUS_ERROR\n            || PERIOD;\n      OUTPUT = PP || ' BYTES OF PROGRAM, ' || DP-DSP-CHP || ' OF DATA, ' || DSP\n         || ' OF DESCRIPTORS, ' || CHP || ' OF STRINGS.  TOTAL CORE REQUIREMENT'\n         || X1 || PP + DP || ' BYTES.';\n      IF CONTROL(BYTE('D')) THEN CALL DUMPIT;\n      DOUBLE_SPACE;\n      CLOCK(3) = TIME;\n      DO I = 1 TO 3;   /* WATCH OUT FOR MIDNIGHT */\n         IF CLOCK(I) < CLOCK(I-1) THEN CLOCK(I) = CLOCK(I) +  8640000;\n      END;\n      CALL PRINT_TIME ('TOTAL TIME IN COMPILER   ', CLOCK(3) - CLOCK(0));\n      CALL PRINT_TIME ('SET UP TIME              ', CLOCK(1) - CLOCK(0));\n      CALL PRINT_TIME ('ACTUAL COMPILATION TIME  ', CLOCK(2) - CLOCK(1));\n      CALL PRINT_TIME ('POST-COMPILATION TIME    ', CLOCK(3) - CLOCK(2));\n      IF CLOCK(2) > CLOCK(1) THEN   /* WATCH OUT FOR CLOCK BEING OFF */\n      OUTPUT = 'COMPILATION RATE: ' || 6000*CARD_COUNT/(CLOCK(2)-CLOCK(1))\n         || ' CARDS PER MINUTE.';\n   END PRINT_SUMMARY;\n\nMAIN_PROCEDURE:\n   PROCEDURE;\n      CLOCK(0) = TIME;  /* KEEP TRACK OF TIME IN EXECUTION */\n      CALL INITIALIZATION;\n\n      /* CLOCK(1) GETS SET IN GETCARD */\n      CALL COMPILATION_LOOP;\n\n      CLOCK(2) = TIME;\n      CALL LOADER;\n\n      /* CLOCK(3) GETS SET IN PRINT_SUMMARY */\n      CALL PRINT_SUMMARY;\n\n   END MAIN_PROCEDURE;\n\n\nCALL MAIN_PROCEDURE;\nRETURN SEVERE_ERRORS;\n\nEOF EOF EOF\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XCOMCOMP": {"ttr": 5130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x12%\\x04\\xbf\\x04\\xbf\\x00\\x00\\xc2\\xc9\\xd5\\xc1\\xd9\\xe8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T12:25:00", "lines": 1215, "newlines": 1215, "modlines": 0, "user": "BINARY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "XMON": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x11Y\\x06\\xbd\\x06\\xbd\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T11:59:00", "lines": 1725, "newlines": 1725, "modlines": 0, "user": "SOURCE"}, "text": "XMON     TITLE 'XPLSM SUBMONITOR FOR THE XPL COMPILER SYSTEM'\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        XPLSM    SUBMONITOR FOR THE XPL COMPILER GENERATOR SYSTEM    *\n*                                                                     *\n*                                                                     *\n*                                  DAVID B. WORTMAN                   *\n*                                  STANFORD UNIVERSITY                *\n*                                  MARCH  1969                        *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        DEFINE PARAMETRIC CONSTANTS FOR XPLSM                        *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         GBLA  &INPUTS             NUMBER OF INPUT FILES\n         GBLA  &OUTPUTS            NUMBER OF OUTPUT FILES\n         GBLA  &FILES              NUMBER OF DIRECT ACCESS FILES\n         LCLA  &I                  VARIABLE FOR ITERATION LOOPS\n         SPACE 5\nIOPACK   CSECT\n         SPACE 2\n&INPUTS  SETA  3                   INPUT(I),   I = 0,1,2,3\n         SPACE 1\n&OUTPUTS SETA  3                   OUTPUT(I),  I = 0,1,2,3\n         SPACE 1\n&FILES   SETA  3                   FILE(I,*),  I = 1,2,3\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        FILEBYTS DETERMINES THE BLOCKSIZE FOR DIRECT ACCESS FILE     *\n*        I/O.  IT SHOULD BE EQUAL TO THE VALUE OF THE LITERAL         *\n*        CONSTANT 'DISKBYTES' IN THE XCOM COMPILER FOR COMPILATION    *\n*        TO WORK SUCCESSFULLY.  THE VALUE OF FILEBYTS WHICH IS        *\n*        ASSEMBLED IN MAY BE OVERIDDEN BY THE 'FILE=NNNN' PARAMETER   *\n*        ON THE OS/360 EXEC CARD.                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        DEVICE       ALLOWABLE RANGE         SUGGESTED VALUE         *\n*                                                                     *\n*        2311      80 <= FILEBYTS <= 3624        3600                 *\n*                                                                     *\n*        2314      80 <= FILEBYTS <= 7294        7200                 *\n*                                                                     *\n*        2321      80 <= FILEBYTS <= 2000        2000                 *\n*                                                                     *\n*                                                                     *\n*        LARGER VALUES MAY BE USED FOR FILEBYTS IF THE SUBMONITOR     *\n*        IS REASSEMBLED WITH  RECFM=FT  SPECIFIED IN THE DCBS FOR     *\n*        THE DIRECT ACCESS FILES.                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nFILEBYTS EQU   3600                2311  DISKS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        BLKSIZE DEFAULT FOR SOME INPUT AND OUTPUT FILES.  SEE THE    *\n*        EXIT LIST HANDLING ROUTINE GENXT.  SHOULD BE THE LARGEST     *\n*        MULTIPLE OF 80 THAT IS LESS THAN OR EQUAL TO FILEBYTS        *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nIOFBYTS  EQU   80*(FILEBYTS/80)\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        DEFINE THE REGISTERS USED TO PASS PARAMETERS TO THE          *\n*        SUBMONITOR FROM THE XPL PROGRAM                              *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSVCODE   EQU   1                   CODE INDICATING SERVICE REQUESTED\n         SPACE 1\nPARM1    EQU   0                   FIRST PARAMETER\n         SPACE 1\nPARM2    EQU   2                   SECOND PARAMETER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        DEFINE THE SERVICE CODES USED BY THE XPL PROGRAM TO          *\n*        INDICATE SERVICE REQUESTS TO THE SUBMONITOR                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nGETC     EQU   4                   SEQUENTIAL INPUT\n         SPACE 1\nPUTC     EQU   8                   SEQUENTIAL OUTPUT\n         SPACE 1\nTRC      EQU   12                  INITIATE TRACING\n         SPACE 1\nUNTR     EQU   16                  TERMINATE TRACING\n         SPACE 1\nEXDMP    EQU   20                  FORCE A CORE DUMP\n         SPACE 1\nGTIME    EQU   24                  RETURN TIME AND DATE\n         SPACE 1\nRSVD1    EQU   28                  (UNUSED)\n         SPACE 1\nRSVD2    EQU   32                  CLOCK_TRAP        (NOP IN XPLSM)\n         SPACE 1\nRSVD3    EQU   36                  INTERRUPT_TRAP    (NOP IN XPLSM)\n         SPACE 1\nRSVD4    EQU   40                  MONITOR           (NOP IN XPLSM)\n         SPACE 1\nRSVD5    EQU   44                  (UNUSED)\n         SPACE 1\nRSVD6    EQU   48                  (UNUSED)\n         SPACE 1\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        GENERATE THE SERVICE CODES FOR DIRECT ACCESS FILE I/O        *\n*        BASED ON THE NUMBER OF FILES AVAILABLE  (&FILES)             *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nFILEORG  EQU   RSVD6+4             ORIGIN FOR THE FILE SERVICE CODES\n         SPACE 1\n&I       SETA  1\n.SC1     AIF   (&I GT &FILES).SC2\nRD&I     EQU   FILEORG+8*(&I-1)    CODE FOR READING FILE&I\nWRT&I    EQU   FILEORG+8*(&I-1)+4  CODE FOR WRITING FILE&I\n&I       SETA  &I+1\n         AGO   .SC1\n.SC2     ANOP\n         SPACE 2\nENDSERV  EQU   FILEORG+8*(&I-1)    1ST UNUSED SERVICE CODE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        DEFINE REGISTER USAGE                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRTN      EQU   3                   REGISTER CONTAINING COMPLETION\n*                                  CODE RETURNED BY THE PROGRAM\n         SPACE 1\nEBR      EQU   10                  BASE REGISTER USED DURING\n*                                  INITIALIZATION\n         SPACE 1\nCBR      EQU   12                  LINKAGE REGISTER USED FOR CALLS\n*                                  TO THE SUBMONITOR\n         SPACE 1\nSELF     EQU   15                  REGISTER THAT ALWAYS CONTAINS\n*                                  THE ADDRESS OF THE SUBMONITOR\n*                                  ENTRY POINT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        BIT CONSTANTS NEEDED FOR CONVERSING WITH OS/360 DCBS         *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nOPENBIT  EQU   B'00010000'         DCBOFLGS BIT INDICATING OPEN\n*                                  SUCCESSFULLY COMPLETED\n         SPACE 1\nTAPEBITS EQU   B'10000001'         BITS INDICATING A MAGNETIC TAPE\n         SPACE 1\nKEYLBIT  EQU   B'00000001'         BIT IN RECFM THAT INDICATES\n*                                  KEYLEN WAS SET EXPLICITELY ZERO\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        FLAG BITS USED TO CONTROL SUBMONITOR OPERATION               *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nALLBITS  EQU   B'11111111'         MASK\n         SPACE 1\nTRACEBIT EQU   B'10000000'         BEGIN EXECUTION OF THE PROGRAM\n*                                  IN TRACE MODE\n         SPACE 1\nSFILLBIT EQU   B'01000000'         1 CHARACTER OF FILL NEEDED BY\n*                                  THE PUT ROUTINE\n         SPACE 1\nLFILLBIT EQU   B'00100000'         LONGER FILL NEEDED BY PUT ROUTINE\n         SPACE 1\nDUMPBIT  EQU   B'00001000'         GIVE A CORE DUMP FOR I/O ERRORS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*              DEFINE ABEND CODES ISSUED BY THE SUBMONITOR            *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nOPENABE  EQU   100                 UNABLE TO OPEN ONE OF THE FILES:\n*                                  PROGRAM, SYSIN, OR SYSPRINT\n         SPACE 1\nPGMEOD   EQU   200                 UNEXPECTED END OF FILE WHILE\n*                                  READING IN THE XPL PROGRAM\n         SPACE 1\nPGMERR   EQU   300                 SYNAD ERROR WHILE READING IN\n*                                  THE XPL PROGRAM\n         SPACE 1\nCOREABE  EQU   400                 XPL PROGRAM WON'T FIT IN\n*                                  THE AMOUNT OF MEMORY AVAILABLE\n         SPACE 1\nCODEABE  EQU   500                 INVALID SERVICE CODE FROM THE\n*                                  XPL PROGRAM\n         SPACE 1\nOUTSYND  EQU   800                 SYNAD ERROR ON OUTPUT FILE\n         SPACE 1\nPFABE    EQU   900                 INVALID OUTPUT FILE SPECIFIED\n         SPACE 1\nINSYND   EQU   1000                SYNAD ERROR ON INPUT FILE\n         SPACE 1\nINEODAB  EQU   1200                END OF FILE ERROR ON INPUT FILE\n         SPACE 1\nGFABE    EQU   1400                INVALID INPUT FILE SPECIFIED\n         SPACE 1\nFLSYND   EQU   2000                SYNAD ERROR ON DIRECT ACCESS FILE\n         SPACE 1\nFLEOD    EQU   2200                END OF FILE ERROR ON DIRECT\n*                                  ACCESS FILE\n         SPACE 1\nUSERABE  EQU   4000                XPL PROGRAM CALLED EXIT TO\n*                                  FORCE A CORE DUMP\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        SUBMONITOR  INITIALIZATION                                   *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         ENTRY XPLSM               WHERE OS ENTERS THE SUBMONITOR\n         SPACE 2\n         DS    0F\n         USING *,15\n         SPACE 1\nXPLSM    SAVE  (14,12),T,*         SAVE ALL REGISTERS\n         ST    13,SAVE+4           SAVE RETURN POINTER\n         LA    15,SAVE             ADDRESS OF SUBMONITOR'S OS SAVE AREA\n         ST    15,8(0,13)\n         LR    13,15\n         USING SAVE,13\n         BALR  EBR,0               BASE ADDRESS FOR INITIALIZATION\n         USING *,EBR\nBASE1    DS    0H\n         DROP  15\n         L     1,0(,1)             ADDRESS OF A POINTER TO THE PARM\n*                                  FIELD OF THE OS EXEC CARD\n         ST    1,CONTROL           SAVE ADDRESS FOR THE TRACE ROUTINE\n         MVI   FLAGS,B'00000000'   RESET ALL FLAGS\n         LH    4,0(,1)             LENGTH OF THE PARM FIELD\n         LA    1,2(,1)             ADDRESS OF THE PARM STRING\n         LA    4,0(1,4)            ADDRESS OF END OF PARAMETER LIST\n         LA    7,PARMSCAN\n         SPACE 2\nPARMSCAN DS    0H\n         CR    1,4                 ARE WE DONE ?\n         BNL   NOPARMS             YES, SO QUIT LOOKING\n         CLC   TRCM,0(1)           LOOK FOR 'TRACE'\n         BNE   PS2                 NOT FOUND\n         OI    FLAGS,TRACEBIT      SET FLAG TO BEGIN IN TRACE MODE\n         LA    1,L'TRCM+1(,1)      INCREMENT POINTER\n         BR    7                   BRANCH BACK TO TEST\nPS2      CLC   ALTRM,0(1)          TEST FOR 'ALTER'\n         BNE   PS3                 NOT FOUND\n         MVC   FREEUP,ALTFREE      MAKE MORE ROOM FOR ALTER\n         LA    1,L'ALTRM+1(,1)     INCREMENT POINTER\n         BR    7                   BRANCH BACK TO TEST\nPS3      CLC   CMNM,0(1)           LOOK FOR 'MIN=NNNN'\n         BNE   PS4                 NOT FOUND\n         BAL   CBR,DIGET           GO GET THE NUMBER\n         ST    3,COREMIN           SET NEW MINIMUM VALUE\n         BR    7                   BRANCH TO TEST\nPS4      CLC   CMXM,0(1)           CHECK FOR 'MAX=MMMM'\n         BNE   PS5                 NOT FOUND\n         BAL   CBR,DIGET           GO GET THE VALUE\n         ST    3,COREMAX           SET NEW MAXIMUM VALUE\n         BR    7                   BRANCH TO TEST\nPS5      CLC   FREEM,0(1)          CHECK FOR 'FREE=NNNN'\n         BNE   PS6                 NOT FOUND\n         BAL   CBR,DIGET           GO GET THE VALUE\n         ST    3,FREEUP            SET NEW AMOUNT FREED\n         BR    7                   BRANCH TO TEST\nPS6      CLC   DMPM,0(1)           CHECK FOR 'DUMP'\n         BNE   PS7                 NOT FOUND\n         OI    FLAGS,DUMPBIT       SET DUMP ON ERROR FLAG\n         LA    1,L'DMPM+1(,1)      INCREMENT POINTER\n         BR    7                   BRANCH TO TEST\nPS7      CLC   FILEM,0(1)          CHECK FOR 'FILE=MMMM'\n         BNE   PSBUMP              NOT FOUND\n         BAL   CBR,DIGET           GET THE BLKSIZE VALUE\n         LA    2,&FILES*2          NUMBER OF DCB FOR FILES\n         LA    5,ARWDCBS           ADDRESS OF DCB LIST\nFLOOP    L     6,0(,5)             ADDRESS OF A DCB\n         USING IHADCB,6\n         STH   3,DCBLRECL          SET NEW RECORD LENGTH\n         STH   3,DCBBLKSI          SET NEW BLOCKSIZE\n         DROP  6\n         LA    5,4(,5)             INCREMENT ADDRESS\n         BCT   2,FLOOP             LOOP BACK\n         SLL   3,2                 (NEW BLOCKSIZE)*4\n         ST    3,ALTFREE           ALTER PARAMETER\n         BR    7                   GO TO SCAN LOOP\nPSBUMP   LA    1,1(,1)             INCREMENT POINTER TO PARM STRING\n         BR    7                   BRANCH TO TEST\nNOPARMS  DS    0H\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        OPEN THE FILES  PROGRAM, SYSIN, AND SYSPRINT                 *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         OPEN  (INPUT0,(INPUT),OUTPUT0,(OUTPUT),PROGRAM,(INPUT))\n         SPACE 1\n         L     3,GETDCBS           ADDRESS OF DCB FOR INPUT0\n         USING IHADCB,3\n         TM    DCBOFLGS,OPENBIT    CHECK FOR SUCCESSFUL OPENING\n         BZ    BADOPEN             INPUT0 NOT OPENED SUCCESSFULLY\n         L     3,PUTDCBS           ADDRESS OF DCB FOR OUTPUT0\n         TM    DCBOFLGS,OPENBIT    CHECK FOR SUCCESSFUL OPENING\n         BZ    BADOPEN             OUTPUT0 NOT OPENED SUCCESSFULLY\n         L     3,PGMDCB            ADDRESS OF DCB FOR PROGRAM\n         TM    DCBOFLGS,OPENBIT    TEST FOR SUCCESSFUL OPENING\n         BNZ   OPENOK              PROGRAM SUCCESSFULLY OPENED\n         DROP  3\n         SPACE 2\nBADOPEN  LA    1,OPENABE           ABEND BECAUSE FILES DIDN'T OPEN\n*                                  PROPERLY\n         B     ABEND               GO TO ABEND ROUTINE\n         SPACE 2\nOPENOK   DS    0H\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        NOW OBTAIN SPACE IN MEMORY FOR THE XPL PROGRAM AND ITS       *\n*        FREE STRING AREA.  A GETMAIN IS ISSUED TO OBTAIN AS MUCH     *\n*        MEMORY AS POSSIBLE WITHIN THE PARTITION.  THEN A FREEMAIN    *\n*        IS ISSUED TO RETURN THE AMOUNT OF MEMORY SPECIFIED BY        *\n*        THE VARIABLE 'FREEUP' TO OS/360 FOR USE AS WORK SPACE.       *\n*        OS/360 NEEDS SPACE FOR FOR DYNAMICALLY CREATING BUFFERS      *\n*        FOR THE SEQUENTIAL INPUT AND OUTPUT FILES AND FOR            *\n*        OVERLAYING I/O ROUTINES.                                     *\n*                                                                     *\n*           THE AMOUNT OF CORE REQUESTED FROM OS/360 CAN BE ALTERED   *\n*        WITH THE 'MAX=NNNN' AND 'MIN=MMMM' PARAMETERS TO THE         *\n*        SUBMONITOR.  THE AMOUNT OF CORE RETURNED TO OS/360 CAN BE    *\n*        ALTERED WITH THE 'FREE=NNNN' OR THE 'ALTER' PARAMETER        *\n*                                                                     *\n*                                                                     *\n*        MEMORY REQUEST IS DEFINED BY THE CONTROL BLOCK STARTING AT   *\n*        'COREREQ'.  THE DESCRIPTION OF THE MEMORY SPACE OBTAINED     *\n*        IS PUT INTO THE CONTROL BLOCK STARTING AT 'ACORE'.           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         GETMAIN VU,LA=COREREQ,A=ACORE\n         SPACE 1\n         LM    1,2,ACORE           ADDRESS OF CORE OBTAINED TO R1\n*                                  LENGTH OF CORE AREA TO R2\n         AR    1,2                 ADDRESS OF TOP OF CORE AREA\n         S     1,FREEUP            LESS AMOUNT TO BE RETURNED\n         ST    1,CORETOP           ADDRESS OF TOP OF USABLE CORE\n*                                  (BECOMES 'FREELIMIT')\n         S     2,FREEUP            SUBTRACT AMOUNT RETURNED\n         ST    2,CORESIZE          SIZE OF AVAILABLE SPACE\n         L     0,FREEUP            AMOUNT TO GIVE BACK\n         SPACE 1\n         FREEMAIN R,LV=(0),A=(1)   GIVE 'FREEUP' BYTES OF CORE BACK\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        READ IN THE BINARY XPL PROGRAM AS SPECIFIED BY THE           *\n*                                                                     *\n*        //PROGRAM  DD  .....                                         *\n*                                                                     *\n*        CARD.  IT IS ASSUMED THAT THE BINARY PROGRAM IS IN STANDARD  *\n*        XPL SYSTEM FORMAT.                                           *\n*                                                                     *\n*                                                                     *\n*        THE 1ST RECORD OF THE BINARY PROGRAM FILE SHOULD BEGIN       *\n*        WITH A BLOCK OF INFORMATION DESCRIBING THE CONTENTS OF       *\n*        THE FILE.  THE FORMAT OF THIS BLOCK IS GIVEN IN THE DSECT    *\n*        'FILECTRL' AT THE END OF THIS ASSEMBLY.                      *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         L     2,ACORE             ADDRESS OF START OF CORE AREA\n         LR    4,2                 SAVE STARTING ADDRESS\n         USING FILECTRL,4          ADDRESS OF CONTROL BLOCK\n         ST    2,CODEADR           SAVE STARTING ADDRESS FOR USE\n*                                  BY THE XPL PROGRAM\n         BAL   CBR,READPGM         READ IN 1ST RECORD\n         L     3,BYTSCODE          NUMBER OF BYTES OF CODE\n         S     3,BYTSBLK           LESS ONE RECORD\n         A     3,BYTSFULL          PLUS AMOUNT IN LAST CODE RECORD\n         A     3,BYTSDATA          PLUS SIZE OF DATA AREA\n         C     3,CORESIZE          COMPARE WITH SPACE AVAILABLE\n         LA    1,COREABE           ABEND CODE FOR NO ROOM IN CORE\n         BH    ABEND               WON'T FIT, SO ABEND\n         L     5,BLKSCODE          NUMBER OF RECORDS OF CODE\n         L     3,BYTSBLK           NUMBER OF BYTES PER RECORD\n         B     LOAD1               GO TEST FOR MORE CODE RECORDS\n         SPACE 1\nRCODE    AR    2,3                 ADDRESS TO PUT NEXT RECORD\n         BAL   CBR,READPGM         READ IN THE BINARY XPL PROGRAM\nLOAD1    BCT   5,RCODE             LOOP BACK TO GET NEXT RECORD\n         SPACE 1\n         A     2,BYTSFULL          NUMBER OF BYTES ACTUALLY\n*                                  USED IN LAST CODE RECORD\n         ST    2,DATADR            SAVE ADDRESS OF DATA AREA\n*                                  FOR USE BY THE XPL PROGRAM\n         L     5,BLKSDATA          NUMBER OF RECORDS OF DATA\n         SPACE 1\nRDATA    BAL   CBR,READPGM         READ IN THE XPL PROGRAM'S DATA AREA\n         AR    2,3                 ADDRESS TO PUT NEXT RECORD\n         BCT   5,RDATA             LOOP BACK FOR NEXT RECORD\n         DROP  4\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        CODE TO BRANCH TO THE XPL PROGRAM                            *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         LA    SELF,ENTRY          ADDRESS OF ENTRY POINT TO XPLSM\n         TM    FLAGS,TRACEBIT      START IN TRACE MODE ?\n         BO    BEGTRC              YES, BEGIN TRACING\n         LM    0,3,PGMPARMS        PARAMETERS FOR THE XPL PROGRAM\n         DROP  EBR,13\n         USING ENTRY,SELF\n         SPACE 2\n         USING FILECTRL,2          ADDRESS OF FIRST RECORD OF CODE\nGOC      BAL   CBR,CODEBEGN        BRANCH TO HEAD OF THE XPL PROGRAM\n         DROP  2\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        THE XPL PROGRAM RETURNS HERE AT THE END OF EXECUTION         *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         L     EBR,ABASE1          REGISTER FOR ADDRESSABILITY\n         USING BASE1,EBR\n         ST    RTN,RTNSV           SAVE COMPLETION CODE RETURNED BY\n*                                  THE XPL PROGRAM FOR PASSING TO OS\n         LA    1,UNTR              TURN OFF POSSIBLE TRACE\n         BALR  CBR,SELF            CALL THE SERVICE ROUTINES\n         L     13,ASAVE            ADDRESS OF OS/360 SAVE AREA\n         USING SAVE,13\n         DROP  SELF\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        RELEASE THE MEMORY OCCUPPIED BY THE XPL PROGRAM              *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSMRET    L     1,ACORE             ADDRESS OF THE BLOCK TO BE FREED\n         L     0,CORESIZE          LENGTH OF THE BLOCK TO BE FREED\n         SPACE 1\n         FREEMAIN R,LV=(0),A=(1)   FREEDOM NOW !\n         SPACE 1\n         CLOSE (INPUT0,,OUTPUT0)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        WARNING,  THE CLOSE OF INPUT0 AND OUTPUT0 MUST PRECEDE       *\n*        THE CLOSE WHICH USES THE GETDCBS LIST.  THE CLOSE SVC WILL   *\n*        LOOP INDEFINITELY IF THE SAME DCB ADDRESS APPEARS TWICE IN   *\n*        A CLOSE LIST.                                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLOSE ,MF=(E,GETDCBS)     CLOSE ALL FILE KNOWN TO XPLSM\n         SPACE 1\n         L     15,RTNSV            LOAD RETURN CODE\n         L     13,SAVE+4\n         DROP  13\n         RETURN (14,12),RC=(15)    RETURN TO OS/360\n         SPACE 1\n         DROP  EBR\n         USING SAVE,13\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        CONSTANTS USED DURING INITIALIZATION                         *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSAVE     DS    18F                 SAVE AREA FOR OS/360\nACORE    DS    A                   ADDRESS OF CORE FOR THE PROGRAM\nCORESIZE DS    F                   SIZE OF CORE IN BYTES\nCONTROL  DS    A                   ADDRESS OF PARAMETER STRING PASSED\n*                                  TO THE SUBMONITOR BY OS/360\nCOREREQ  DS    0F                  CORE REQUEST CONTROL BLOCK\nCOREMIN  DC    F'110000'           MINIMUM AMOUNT OF CORE REQUIRED\nCOREMAX  DC    F'5000000'          MAXIMUM AMOUNT OF CORE REQUESTED\nFREEUP   DC    A(2*FILEBYTS)       AMOUNT OF CORE TO RETURN TO OS\nALTFREE  DC    A(4*FILEBYTS)       AMOUNT OF CORE FREED FOR ALTER\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        BLOCK OF PARAMETERS PASSED TO THE XPL PROGRAM                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nPGMPARMS DS    F                   R0  UNUSED\nCORETOP  DC    A(0)                R1  ADDRESS OF TOP OF CORE\nCODEADR  DC    F'0'                R2  ADDRESS OF START OF 1ST RECORD\n*                                  OF THE XPL PROGRAM\nDATADR   DC    F'0'                R3  ADDRESS OF THE START OF THE XPL\n*                                      PROGRAM'S DATA AREA\n         SPACE 1\nTRCM     DC    CL5'TRACE'\nALTRM    DC    CL5'ALTER'\nCMNM     DC    CL4'MIN='\nCMXM     DC    CL4'MAX='\nFREEM    DC    CL5'FREE='\nDMPM     DC    CL4'DUMP'\nFILEM    DC    CL5'FILE='\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        ROUTINE TO SCAN PARAMETER STRINGS FOR DIGITS                 *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nDIGET    DS    0H\n         SR    2,2                 CLEAR REGISTER\n         SR    3,3                  \"\nDG1      CLI   0(1),C'='           CHECK FOR '='\n         BE    DG2\n         LA    1,1(,1)             INCREMENT POINTER\n         CR    1,4                 AT END ?\n         BCR   B'0100',CBR         YES, SO RETURN\n         B     DG1                 KEEP LOOKING FOR '='\nDG2      LA    1,1(,1)             INCREMENT POINTER\n         LA    5,C'0'              BINARY VALUE OF '0'\nDGLP     IC    2,0(,1)             FETCH A CHARACTER\n         SR    2,5                 NORMALIZE\n         BM    DGDN                NOT A DIGIT SO DONE\n         LR    0,3\n         SLL   3,2                 NUMBER*4\n         AR    3,0                 NUMBER*5\n         SLL   3,1                 NUMBER*10\n         AR    3,2                 ADD IN NEW DIGIT\n         LA    1,1(,1)             INCREMENT POINTER\n         CR    1,4                 AT END ?\n         BL    DGLP                NO\nDGDN     LA    1,1(,1)             INCREMENT POINTER\n         BR    CBR                 RETURN\n*                                  VALUE OF NUMBER IS IN REG 3\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        ROUTINE TO READ IN THE BINARY IMAGE OF THE XPL PROGRAM       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nREADPGM  DS    0H\n*                                  SHARE DECB WITH FILE READ ROUTINE\n         SPACE 1\n         READ  RDECB,SF,PROGRAM,(2),MF=E\n         CHECK RDECB               WAIT FOR READ TO COMPLETE\n         SPACE 1\n         BR    CBR                 RETURN TO CALLER\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        ROUTINES TO PROVIDE DEFAULT DATASET INFORMATION IF NONE      *\n*        IS PROVIDED BY JCL OR VOLUME LABELS.  IN PARTICULAR,         *\n*        BLKSIZE, LRECL, BUFNO, AND RECFM INFORMATION.                *\n*                                                                     *\n*                                                                     *\n*        EXIT LISTS FOR DCBS                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         DS    0F\nINEXIT0  DC    X'85'               INPUT0\n         DC    AL3(INXT0)\n         SPACE 1\nOUTEXIT0 DC    X'85'               OUTPUT0\n         DC    AL3(OUTXT0)\n         SPACE 1\nINEXIT2  DC    X'85'               INPUT2\n         DC    AL3(INXT2)\n         SPACE 1\nOUTEXIT2 EQU   INEXIT0             OUTPUT2\n         SPACE 2\n&I       SETA  3\n.IDF1    AIF   (&I GT &INPUTS).IDF2\nINEXIT&I EQU   INEXIT2             INPUT&I\n&I       SETA  &I+1\n         AGO   .IDF1\n.IDF2    ANOP\n         SPACE 1\n&I       SETA  3\n.ODF1    AIF   (&I GT &OUTPUTS).ODF2\nOUTEXIT&I EQU  INEXIT2\n&I       SETA  &I+1\n         AGO   .ODF1\n.ODF2    ANOP\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        DCB EXIT ROUTINE ENTRY POINTS                                *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nINXT0    MVC   DEFAULTS(6),INDFLT0\n         B     GENXT\n         SPACE 1\nINXT2    MVC   DEFAULTS(6),INDFLT2\n         B     GENXT\n         SPACE 1\nOUTXT0   MVC   DEFAULTS(6),OUTDFLT0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        DCB EXIT LIST PROCESSING ROUTINE FOR OPEN EXITS              *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nGENXT    DS    0H\n         USING IHADCB,1            REGISTER 1 POINTS AT THE DCB\n         NC    DCBBLKSI,DCBBLKSI   CHECK BLKSIZE\n         BNZ   GXT1                ALREADY SET\n         MVC   DCBBLKSI(2),DFLTBLKS\n*                                  PROVIDE DEFAULT BLOCKSIZE\n         SPACE 1\nGXT1     NC    DCBLRECL,DCBLRECL   CHECK LRECL\n         BNZ   GXT2                ALREADY SET\n         MVC   DCBLRECL(2),DFLTLREC\n*                                  PROVIDE DEFAULT LRECL\n         SPACE 1\nGXT2     CLI   DCBBUFNO,0          CHECK BUFNO\n         BNE   GXT3                ALREADY SPECIFIED\n         MVC   DCBBUFNO(1),DFLTBUFN\n*                                  PROVIDE DEFAULT BUFNO\n         SPACE 1\nGXT3     TM    DCBRECFM,ALLBITS-KEYLBIT\n*                                  CHECK RECFM\n         BCR   B'0111',14          ALREADY SET SO RETURN\n         OC    DCBRECFM(1),DFLTRECF\n*                                  PROVIDE DEFAULT RECFM\n         BR    14                  RETURN\n         DROP  1\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        ARRAY OF DEFAULT ATTRIBUTES USED BY GENXT                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nDEFAULTS DS    0H\nDFLTBLKS DS    1H                  DEFAULT BLKSIZE\nDFLTLREC DS    1H                  DEFAULT LRECL\nDFLTBUFN DS    AL1                 DEFAULT BUFNO\nDFLTRECF DS    1BL1                DEFAULT RECFM\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        DEFINE ATTRIBUTES PROVIDED FOR THE VARIOUS FILES             *\n*                                                                     *\n*        INPUT(0), INPUT(1), OUTPUT(2)                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nINDFLT0  DS    0H\n         DC    H'80'               BLKSIZE=80\n         DC    H'80'               LRECL=80\n         DC    AL1(2)              BUFNO=2\n         DC    B'10000000'         RECFM=F\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        OUTPUT(0), OUTPUT(1)                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nOUTDFLT0 DS    0H\n         DC    H'133'              BLKSIZE=133\n         DC    H'133'              LRECL=133\n         DC    AL1(2)              BUFNO=2\n         DC    B'10000100'         RECFM=FA\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        INPUT(2), INPUT(3), OUTPUT(3)                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nINDFLT2  DS    0H\n         DC    AL2(IOFBYTS)        BLKSIZE=IOFBYTS\n         DC    H'80'               LRECL=80\n         DC    AL1(1)              BUFNO=1\n         DC    B'10010000'         RECFM=FB\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        INPUT - OUTPUT  ERROR ROUTINES                               *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        SYNAD AND EOD ERROR ROUTINES FOR INITIAL LOADING OF THE      *\n*        XPL PROGRAM                                                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nEODPGM   STM   0,2,ABEREGS         SAVE REGISTERS\n         LA    1,PGMEOD            UNEXPECTED EOD WHILE READING IN\n*                                  THE XPL PROGRAM\n         B     ABEND               GO TO ABEND ROUTINE\n         SPACE 2\nERRPGM   STM   0,2,ABEREGS         SAVE REGISTERS\n         LA    1,PGMERR            SYNAD ERROR WHILE READING IN THE\n*                                  XPL PROGRAM\n         B     ABEND               GO TO ABEND ROUTINE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        SYNAD AND EOD ROUTINES FOR INPUT(I),  I = 0,1, ...  ,&INPUTS *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nINEOD    L     2,SAVREG+PARM2*4    PICK UP SUBCODE SPECIFYING WHICH\n*                                  INPUT FILE\n         SLL   2,2                 SUBCODE*4\n         L     2,GETDCBS(2)        FETCH DCB ADDRESS\n         USING IHADCB,2\n         ST    2,OCDCB             STORE IT FOR THE CLOSE SVC\n         MVI   OCDCB,X'80'         FLAG END OF PARAMETER LIST\n         CLOSE ,MF=(E,OCDCB)       CLOSE THE OFFENDING FILE\n         SPACE 1\nPCLOSE   DS    0H\n         XC    DCBDDNAM,DCBDDNAM   MARK THE FILE PERMANENTLY UNUSABLE\n         DROP  2\n         B     RETNEOF             GO RETURN AN END OF FILE INDICATION\n         SPACE 2\nINSYNAD  STM   0,2,ABEREGS         SAVE REGISTERS\n         LA    1,INSYND            SYNAD ERROR ON AN INPUT FILE\n         B     INERR               BRANCH TO ERROR ROUTINE\n         SPACE 1\nINEOD2   LA    1,INEODAB           EOD ON AN INPUT FILE\n*                                  ATTEMPT TO READ AFTER AN EOD SIGNAL\nINERR    A     1,SAVREG+PARM2*4    SUBCODE INDICATING WHICH INPUT FILE\n         B     ABEND               BRANCH TO ABEND ROUTINE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        SYNAD ERROR ROUTINES FOR OUTPUT FILES                        *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nOUTSYNAD STM   0,2,ABEREGS         SAVE REGISTERS\n         LA    1,OUTSYND           SYNAD ERROR ON OUTPUT FILE\n         B     INERR\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        SYNAD AND EOD ROUTINES FOR DIRECT ACCESS FILE I/O            *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nFILESYND STM   0,2,ABEREGS         SAVE REGISTERS\n         LA    1,FLSYND            SYNAD ERROR ON DIRECT ACCESS FILE\n         B     FILERR              GO TO ERROR ROUTINE\n         SPACE 1\nFILEEOD  STM   0,2,ABEREGS         SAVE REGISTERS\n         LA    1,FLEOD             EOD ERROR ON DIRECT ACCESS FILE\n         SPACE 1\nFILERR   L     2,SAVREG+SVCODE*4   SERVICE CODE\n         LA    0,RD1-8             COMPUTE WHICH DIRECT ACCESS FILE\n         SR    2,0                 SERVICE_CODE - 1ST SERVICE CODE\n         SRL   2,3                 DIVIDE BY 8\n         AR    1,2\n*                                  FALL THROUGH TO ABEND ROUTINE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        ABEND ROUTINE FOR ALL I/O ERRORS                             *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nABEND    DS    0H\n         ST    1,ABESAVE           SAVE ABEND CODE\n         SPACE 1\n         CLOSE (INPUT0,,OUTPUT0)   THESE MUST BE CLOSED FIRST\n         CLOSE ,MF=(E,GETDCBS)     ATTEMPT TO CLOSE ALL FILES\n         SPACE 1\n         L     1,ABESAVE\n         TM    FLAGS,DUMPBIT       IS A CORE DUMP DESIRED ?\n         BZ    NODUMP              NO, ABEND QUIETLY\n         SPACE 1\n         ABEND (1),DUMP            ABEND WITH A DUMP\n         SPACE 1\nNODUMP   DS    0H\n         ABEND (1)                 ABEND WITHOUT A DUMP\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        ROUTINE TO FORCE AN ABEND DUMP WHEN REQUESTED BY THE         *\n*        XPL PROGRAM BY MEANS OF THE STATEMENT:                       *\n*                                                                     *\n*        CALL  EXIT  ;                                                *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nUSEREXIT DS    0H\n         STM   0,2,ABEREGS         SAVE REGISTERS\n         OI    FLAGS,DUMPBIT       FORCE A DUMP\n         LA    1,USERABE           USER ABEND CODE\n         B     ABEND               BRANCH TO ABEND\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        DISPATCHER FOR ALL SERVICE REQUESTS FROM THE XPL PROGRAM     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         DROP  13\n         USING ENTRY,SELF\nENTRY    DS    0H                  XPL PROGRAMS ENTER HERE\n         STM   0,3,SAVREG          SAVE REGISTERS USED BY XPLSM\n         STM   13,15,SAVREG+13*4\n         L     13,ASAVE            ADDRESS OF OS SAVE AREA\n         DROP  SELF\n         USING SAVE,13\n         SPACE 1\n         LTR   SVCODE,SVCODE       CHECK THE SERVICE CODE FOR VALIDITY\n         BNP   BADCODE             SERVICE CODE MUST BE > 0\n         C     SVCODE,MAXCODE      AND < ENDSERV\n         BH    BADCODE             GO ABEND\n         SPACE 1\nTABLE    B     TABLE(SVCODE)       GO DO THE SERVICE\n         SPACE 1\n         ORG   TABLE+GETC\n         B     GET                 READ INPUT FILE\n         SPACE 1\n         ORG   TABLE+PUTC\n         B     PUT                 WRITE OUTPUT FILE\n         SPACE 1\n         ORG   TABLE+TRC\n         B     TRACE               INITIATE TRACING OF THE PROGRAM\n         SPACE 1\n         ORG   TABLE+UNTR\n         B     UNTRACE             TERMINATE TRACING\n         SPACE 1\n         ORG   TABLE+EXDMP\n         B     USEREXIT            TERMINATE WITH A CORE DUMP\n         SPACE 1\n         ORG   TABLE+GTIME\n         B     GETIME              RETURN TIME AND DATE\n         SPACE 1\n         ORG   TABLE+RSVD1\n         B     EXIT                (UNUSED)\n         SPACE 1\n         ORG   TABLE+RSVD2\n         B     EXIT                CLOCK_TRAP        (NOP)\n         SPACE 1\n         ORG   TABLE+RSVD3\n         B     EXIT                INTERRUPT_TRAP    (NOP)\n         SPACE 1\n         ORG   TABLE+RSVD4\n         B     EXIT                MONITOR           (NOP)\n         SPACE 1\n         ORG   TABLE+RSVD5\n         B     EXIT                (UNUSED)\n         SPACE 1\n         ORG   TABLE+RSVD6\n         B     EXIT                (UNUSED)\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        DYNAMICALLY GENERATE THE DISPATCHING TABLE ENTRIES FOR       *\n*        FILE I/O SERVICES.                                           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n&I       SETA  1                   LOOP INDEX\n.DBR1    AIF   (&I GT &FILES).DBR2\n*                                  FINISHED ?\n         ORG   TABLE+RD&I\n         B     READ                BRANCH TO FILE READ ROUTINE\n         ORG   TABLE+WRT&I\n         B     WRITE               BRANCH TO FILE WRITE ROUTINE\n&I       SETA  &I+1                INCREMENT COUNTER\n         AGO   .DBR1               LOOP BACK\n.DBR2    ANOP\n         SPACE 2\n         ORG   TABLE+ENDSERV       RESET PROGRAM COUNTER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        COMMON EXIT ROUTINE FOR RETURN TO THE XPL PROGRAM            *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nEXIT     DS    0H\n         LM    0,3,SAVREG          RESTORE REGISTERS\n         LM    13,15,SAVREG+13*4\n         DROP  13\n         USING ENTRY,SELF\n         SPACE 1\n         BR    CBR                 RETURN TO THE XPL PROGRAM\n         SPACE 1\n         DROP  SELF\n         USING SAVE,13\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        ROUTINE TO ABEND IN CASE OF BAD SERVICE CODES                *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBADCODE  STM   0,2,ABEREGS         SAVE REGISTERS\n         LA    1,CODEABE           BAD SERVICE CODE ABEND\n         B     ABEND               GO ABEND\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        INPUT ROUTINE FOR READING SEQUENTIAL INPUT FILES             *\n*                                                                     *\n*                                                                     *\n*        INPUT TO THIS ROUTINE IS:                                    *\n*                                                                     *\n*      PARM1   ADDRESS OF THE NEXT AVAILABLE SPACE IN THE PROGRAMS    *\n*              DYNAMIC STRING AREA  (FREEPOINT)                       *\n*                                                                     *\n*      SVCODE  THE SERVICE CODE FOR INPUT                             *\n*                                                                     *\n*      PARM2   A SUBCODE DENOTING WHICH INPUT FILE,                   *\n*              INPUT(I),     I = 0,1, ... ,&INPUTS                    *\n*                                                                     *\n*        THE ROUTINE RETURNS:                                         *\n*                                                                     *\n*      PARM1   A STANDARD XPL STRING DESCRIPTOR POINTING AT THE INPUT *\n*              RECORD WHICH IS NOW AT THE TOP OF THE STRING AREA      *\n*                                                                     *\n*      SVCODE  THE NEW VALUE FOR FREEPOINT, UPDATED BY THE LENGTH OF  *\n*              THE RECORD JUST READ IN                                *\n*                                                                     *\n*                                                                     *\n*        A STANDARD XPL STRING DESCRIPTOR HAS:                        *\n*                                                                     *\n*        BITS  0-7                 (LENGTH - 1) OF THE STRING         *\n*        BITS  8-31                ABSOLUTE ADDRESS OF THE STRING     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nGET      DS    0H\n         LA    SVCODE,&INPUTS      CHECK THAT THE SUBCODE IS VALID\n         LTR   PARM2,PARM2         SUBCODE MUST BE >= 0\n         BM    BADGET\n         CR    PARM2,SVCODE        AND <= &INPUTS\n         BH    BADGET              ILLEGAL SUBCODE\n         SLL   PARM2,2             SUBCODE*4\n         L     3,GETDCBS(PARM2)    ADDRESS OF DCB FOR THE FILE\n         USING IHADCB,3\n         NC    DCBDDNAM,DCBDDNAM   HAS THE FILE BEEN PERMANENTLY\n*                                  CLOSED ?\n         BZ    INEOD2              YES, SO TERMINATE THE JOB\n         SPACE 1\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?\n         BO    GETOPEN             YES\n         ST    3,OCDCB             STORE DCB ADDRESS FOR OPEN SVC\n         MVI   OCDCB,X'80'         FLAG END OF PARAMETER LIST\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE\n         LR    2,3                 COPY DCB ADDRESS\n         TM    DCBOFLGS,OPENBIT    WAS THE FILE OPENED SUCCESSFULLY ?\n         BZ    PCLOSE              NO, MARK FILE PERMANENTLY CLOSED AND\n*                                  RETURN EOD INDICATION TO THE PROGRAM\n         SPACE 2\nGETOPEN  DS    0H\n         GET   (3)                 LOCATE MODE GET\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        USING LOCATE MODE, THE ADDRESS OF THE NEXT INPUT BUFFER      *\n*        IS RETURNED IN R1                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     2,SAVREG+PARM1*4    FETCH THE STRING DESCRIPTOR\n         LA    2,0(,2)             ADDRESS PART ONLY\n         LH    3,DCBLRECL          RECORD LENGTH\n         DROP  3\n         S     3,F1                LENGTH - 1\n         EX    3,GETMOVE           MOVE THE CHARACTERS\n         ST    2,SAVREG+PARM1*4    BUILD UP A STRING DESCRIPTOR\n         STC   3,SAVREG+PARM1*4    LENGTH FIELD\n         LA    2,1(2,3)            NEW FREE POINTER\n         ST    2,SAVREG+SVCODE*4\n         B     EXIT                RETURN TO THE XPL PROGRAM\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        RETURN A NULL STRING DESCRIPTOR AS AN END OF FILE            *\n*        INDICATION THE FIRST TIME AN INPUT REQUEST FIND THE          *\n*        END OF DATA CONDITION                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nRETNEOF  DS    0H\n         MVC   SAVREG+SVCODE*4(4),SAVREG+PARM1*4\n*                                  RETURN FREEPOINT UNTOUCHED\n         XC    SAVREG+PARM1*4(4),SAVREG+PARM1*4\n*                                  RETURN A NULL STRING DESCRIPTOR\n         B     EXIT                RETURN TO THE XPL PROGRAM\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        ROUTINE TO ABEND IN CASE OF AN INVALID SUBCODE               *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBADGET   STM   0,2,ABEREGS         SAVE REGISTERS\n         LA    1,GFABE             INVALID GET SUBCODE\n         B     INERR               GO ABEND\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        ROUTINE FOR WRITING SEQUENTIAL OUTPUT FILES                  *\n*                                                                     *\n*                                                                     *\n*        INPUT TO THIS ROUTINE:                                       *\n*                                                                     *\n*      PARM1   XPL STRING DESCRIPTOR OF THE STRING TO BE OUTPUT       *\n*                                                                     *\n*      PARM2   SUBCODE INDICATING  OUTPUT(I),  I = 0,1, ... ,&OUTPUTS *\n*                                                                     *\n*      SVCODE  THE SERVICE CODE FOR OUTPUT                            *\n*                                                                     *\n*                                                                     *\n*        THE STRING NAMED BY THE DESCRIPTOR IS PLACED IN THE NEXT     *\n*        OUTPUT BUFFER OF THE SELECTED FILE.  IF THE STRING IS        *\n*        SHORTER THAN THE RECORD LENGTH OF THE FILE THEN THE          *\n*        REMAINDER OF THE RECORD IS PADDED WITH BLANKS.  IF THE       *\n*        STRING IS LONGER THAN THE RECORD LENGTH OF THE FILE          *\n*        THEN IT IS TRUNCATED ON THE RIGHT TO FIT.  IF THE SUBCODE    *\n*        SPECIFIES OUTPUT(0) THEN A SINGLE BLANK IS CONCATENATED      *\n*        ON TO THE FRONT OF THE STRING TO SERVE AS CARRIAGE CONTROL.  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPUT      DS    0H\n         LTR   PARM2,PARM2         CHECK SUBCODE FOR VALIDITY\n         BM    BADPUT              SUBCODE MUST BE >= 0\n         LA    SVCODE,&OUTPUTS\n         CR    PARM2,SVCODE        AND <= &OUTPUTS\n         BH    BADPUT\n         ST    PARM1,MOVEADR       SAVE THE STRING DESCRIPTOR\n         SLL   PARM2,2             SUBCODE*4\n         L     3,PUTDCBS(PARM2)    GET THE DCB ADDRESS\n         USING IHADCB,3\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?\n         BO    PUTOPEN             YES, GO DO THE OUTPUT\n         ST    3,OCDCB             STORE DCB ADDRESS FOR THE OPEN SVC\n         MVI   OCDCB,X'8F'         FLAG END OF PARAMETER LIST AND SET\n*                                  FLAG INDICATING OPENING FOR OUTPUT\n         SPACE 1\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE\n         SPACE 1\n         TM    DCBOFLGS,OPENBIT    WAS THE OPEN SUCCESSFULL ?\n         BZ    OUTSYNAD            NO, OUTPUT SYNAD ERROR\n         SPACE 1\nPUTOPEN  DS    0H\n         PUT   (3)                 LOCATE MODE PUT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        USING LOCATE MODE, THE ADDRESS OF THE NEXT OUTPUT BUFFER     *\n*        IS RETURNED IN  R1.                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         SR    15,15               CLEAR REGISTER 15\n         C     15,MOVEADR          IS THE STRING NULL (DESCRIPTOR = 0)\n         BE    NULLPUT             YES, SO PUT OUT A BLANK RECORD\n         IC    15,MOVEADR          LENGTH-1 OF THE STRING\n         LA    14,1(15)            REAL LENGTH OF THE STRING\n         LH    0,DCBLRECL          RECORD LENGTH OF THE FILE\n         LTR   PARM2,PARM2         CHECK SUBCODE FOR OUTPUT(0)\n         BNZ   PUT1                NOT OUTPUT(0)\n         LA    14,1(,14)           INCREASE REAL LENGTH BY ONE FOR\n*                                  CARRIAGE CONTROL\nPUT1     SR    0,14                RECORD LENGTH - REAL LENGTH\n         BM    TOOLONG             RECORD LENGTH < REAL LENGTH\n         BZ    MATCH               RECORD LENGTH = REAL LENGTH\n*                                  RECORD LENGTH > REAL LENGTH\n         OI    FLAGS,SFILLBIT+LFILLBIT\n*                                  INDICATE PADDING REQUIRED\n         S     0,F1                RECORD LENGTH - REAL LENGTH - 1\n         BP    LONGMOVE            RECORD LENGTH - REAL LENGTH > 1\n         NI    FLAGS,ALLBITS-LFILLBIT\n*                                  RECORD LENGTH - REAL LENGTH = 1\n*                                  IS A SPECIAL CASE\nLONGMOVE ST    0,FILLENG           SAVE LENGTH FOR PADDING OPERATION\n         B     MOVEIT              GO MOVE THE STRING\n         SPACE 1\nTOOLONG  LH    15,DCBLRECL         REPLACE THE STRING LENGTH\n*                                  WITH THE RECORD LENGTH\n         S     15,F1               RECORD LENGTH - 1 FOR THE MOVE\nMATCH    NI    FLAGS,ALLBITS-SFILLBIT-LFILLBIT\n*                                  INDICATE NO PADDING REQUIRED\n         SPACE 1\nMOVEIT   LTR   PARM2,PARM2         CHECK FOR OUTPUT(0)\n         BNZ   MOVEIT2             OUTPUT(0) IS A SPECIAL CASE\n         MVI   0(1),C' '           PROVIDE BLANK CARRIAGE CONTROL\n         LA    1,1(,1)             INCREMENT BUFFER POINTER\nMOVEIT2  L     2,MOVEADR           STRING DESCRIPTOR\n         LA    2,0(,2)             ADDRESS PART ONLY\n         EX    15,MVCSTRNG         EXECUTE A MVC INSTRUCTION\n         TM    FLAGS,SFILLBIT      IS PADDING REQUIRED ?\n         BZ    EXIT                NO, RETURN TO THE XPL PROGRAM\n         SPACE 1\n         AR    1,15                ADDRESS TO START PADDING - 1\n         MVI   1(1),C' '           START THE PAD\n         TM    FLAGS,LFILLBIT      IS MORE PADDING REQUIRED ?\n         BZ    EXIT                NO, RETURN TO XPL PROGRAM\n         L     15,FILLENG          LENGTH OF PADDING NEEDED\n         S     15,F1               LESS ONE FOR THE MOVE\n         EX    15,MVCBLANK         EXECUTE MVC TO FILL IN BLANKS\n         B     EXIT                RETURN TO THE XPL PROGRAM\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        FOR A NULL STRING OUTPUT A BLANK RECORD                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nNULLPUT  LH    15,DCBLRECL         RECORD LENGTH\n         S     15,F2               LESS TWO FOR THE MOVES\n         MVI   0(1),C' '           INITIAL BLANK\n         EX    15,MVCNULL          EXECUTE MVC TO FILL IN THE BLANKS\n         B     EXIT                RETURN TO THE XPL PROGRAM\n         SPACE 1\n         DROP  3\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        ROUTINE TO ABEND IN CASE OF AN INVALID SERVICE CODE          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nBADPUT   STM   0,2,ABEREGS         SAVE REGISTERS\n         LA    1,PFABE             INVALID PUT SUBCODE\n         B     INERR               GO ABEND\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        READ ROUTINE FOR DIRECT ACCESS FILE I/O                      *\n*                                                                     *\n*                                                                     *\n*        INPUT TO THIS ROUTINE IS:                                    *\n*                                                                     *\n*      PARM1   CORE ADDRESS TO READ THE RECORD INTO                   *\n*                                                                     *\n*      SVCODE  SERVICE CODE INDICATING WHICH FILE TO USE              *\n*                                                                     *\n*      PARM2   RELATIVE RECORD NUMBER   0,1,2,3,...                   *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nREAD     DS    0H\n         ST    PARM1,RDECB+12      STORE ADDRESS\n         L     3,ARWDCBS-FILEORG(SVCODE)\n*                                  ADDRESS OF THE DCB FOR THIS FILE\n         USING IHADCB,3\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?\n         BO    READOPEN            YES, GO READ\n         ST    3,OCDCB             STORE DCB ADDRESS FOR OPEN SVC\n         MVI   OCDCB,X'80'         FLAG END OF PARAMETER LIST\n*                                  AND INDICATE OPEN FOR INPUT\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE\n         TM    DCBOFLGS,OPENBIT    WAS THE OPEN SUCCESSFUL ?\n         BZ    FILESYND            NO, SYNAD ERROR\n         SPACE 1\nREADOPEN DS    0H\n         TM    DCBDEVT,TAPEBITS    IS THE FILE ON MAGNETIC TAPE\n         DROP  3\n         BO    READTP              YES, GO FORM RECORD INDEX FOR TAPE\n         SLA   PARM2,16            FORM  TTRZ  ADDRESS\n         BNZ   RDN0                BLOCK ZERO IS A SPECIAL CASE\n         LA    PARM2,1             FUNNY ADDRESS FOR BLOCK ZERO\n         B     READTP              GO DO THE READ\nRDN0     O     PARM2,TTRSET        SPECIFY LOGICAL RECORD 1\nREADTP   ST    PARM2,TTR           SAVE RECORD POINTER\n         SPACE 1\n         POINT (3),TTR             POINT AT THE RECORD TO BE READ\n         READ  RDECB,SF,(3),0,'S'  READ THE RECORD INTO CORE\n         CHECK RDECB               WAIT FOR THE READ TO COMPLETE\n         SPACE 1\n         B     EXIT                RETURN TO THE XPL PROGRAM\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        WRITE ROUTINE FOR DIRECT ACCESS FILE I/O                     *\n*                                                                     *\n*                                                                     *\n*        INPUT TO THIS ROUTINE IS:                                    *\n*                                                                     *\n*      PARM1   CORE ADDRESS TO READ THE RECORD FROM                   *\n*                                                                     *\n*      SVCODE  SERVICE CODE INDICATING WHICH FILE TO USE              *\n*                                                                     *\n*      PARM2   RELATIVE RECORD NUMBER   0,1,2, ...                    *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nWRITE    DS    0H\n         ST    PARM1,WDECB+12      SAVE CORE ADDRESS\n         L     3,ARWDCBS-FILEORG(SVCODE)\n*                                  GET THE DCB ADDRESS\n         USING IHADCB,3\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?\n         BO    WRTOPEN             YES, GO WRITE\n         ST    3,OCDCB             STORE DCB ADDRESS FOR OPEN SVC\n         MVI   OCDCB,X'8F'         FLAG END OF ARGUMENT LIST AND\n*                                  INDICATE OPENING FOR OUTPUT\n         SPACE 1\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE\n         SPACE 1\n         TM    DCBOFLGS,OPENBIT    WAS THE OPEN SUCCESSFUL ?\n         BZ    FILESYND            NO,SYNAD ERROR\n         SPACE 1\nWRTOPEN  DS    0H\n         TM    DCBDEVT,TAPEBITS    IS THE FILE ON MAGNETIC TAPE\n         DROP  3\n         BO    WRITP               YES, GO FORM RECORD INDEX FOR TAPE\n         SLA   PARM2,16            FORM TTRZ ADDRESS FOR DIRECT ACCESS\n         BNZ   WRDN0               RECORD ZERO IS A SPECIAL CASE\n         LA    PARM2,1             FUNNY ADDRESS FOR RECORD ZERO\n         B     WRITP               GO DO THE WRITE\nWRDN0    O     PARM2,TTRSET        OR IN RECORD NUMBER BIT\nWRITP    ST    PARM2,TTR           SAVE RECORD POINTER\n         SPACE 1\n         POINT (3),TTR             POINT AT THE DESIRED RECORD\n         WRITE WDECB,SF,(3),0,'S'  WRITE THE RECORD OUT\n         CHECK WDECB               WAIT FOR THE WRITE TO FINISH\n         SPACE 1\n         B     EXIT                RETURN TO THE XPL PROGRAM\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        TRACE  AND  UNTRACE                                          *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nTRACE    DS    0H\n         STM   3,12,SAVREG+3*4     SAVE REGISTERS NOT SAVED AT ENTRY\n         L     2,SAVREG+4*CBR      GET ADDRESS OF THE NEXT INSTRUCTION\n         LA    2,0(,2)             ADDRESS PART ONLY\n         ST    2,ILC               SAVE IT FOR THE TRACE ROUTINE\n         LA    SELF,ENTRY          ADDRESS OF ENTRY POINT\n         B     TRCALL              GO CALL THE TRACE ROUTINE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        COME HERE TO BEGIN XPL PROGRAM EXECUTION IN TRACE MODE       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nBEGTRC   DS    0H\n         LM    0,3,PGMPARMS        INITIAL PARAMETERS FOR XPL PROGRAM\n         STM   0,3,SAVREG          PLACE IN PSEUDO REGISTERS\n         ST    SELF,SAVREG+4*SELF  STORE MONITOR ADDRESS\n         SPACE 1\nTRCALL   DS    0H\n         LM    0,4,TPACK           PARAMETERS FOR THE TRACE ROUTINE\n         BALR  CBR,3               CALL THE TRACE ROUTINE\n         L     CBR,ASMR            ADDRESS OF XPLSM RETURN TO OS\n         BR    CBR                 GO RETURN TO OS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        UNTRACE REQUEST IS DETECTED BY THE TRACE ROUTINE IF TRACING  *\n*        IS ACTUALLY BEING DONE.  IT IS A NOP HERE                    *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nUNTRACE  B     EXIT                RETURN TO THE XPL PROGRAM\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        TIME AND DATE FUNCTIONS                                      *\n*                                                                     *\n*                                                                     *\n*        RETURNS TIME OF DAY IN HUNDREDTHS OF A SECOND IN REGISTER    *\n*        PARM1  AND THE DATE IN THE FORM  YYDDD IN REGISTER SVCODE    *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nGETIME   TIME  BIN                 REQUEST THE TIME\n         ST    0,SAVREG+PARM1*4    RETURN IN REGISTER PARM1\n         ST    1,DTSV+4            STORE THE DATE IN PACKED DECIMAL\n         CVB   1,DTSV              CONVERT IT TO BINARY\n         ST    1,SAVREG+SVCODE*4   RETURN DATE IN REGISTER SVCODE\n         B     EXIT                RETURN TO THE XPL PROGRAM\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        EXECUTE ROUTINE FOR USE BY THE TRACE ROUTINE                 *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         DROP  13\n         USING ENTRY,SELF\n         SPACE 1\nEXEC     DS    0H\n         STM   0,3,XCELL           SAVE THE PARAMETERS PASSED IN\n         LM    0,4,0(2)            LOAD THE REST OF THE TRACED\n*                                  PROGRAM'S REGISTERS\n         EX    0,XCELL             EXECUTE ONE INSTRUCTION\n         STM   14,15,EXSV          SAVE REGISTERS TEMPORARILY\n         L     14,XCELL+8          ADDRESS OF TRACE ROUTINE'S\n*                                  REGISTER TABLE\n         STM   0,13,0(14)          STORE REGISTERS IN THE TABLE\n         LM    0,1,EXSV            PICK UP REGISTERS 14 & 15 AGAIN\n         STM   0,1,14*4(14)        STORE THEM IN THE TABLE\n         LM    0,3,XCELL           RESTORE INITIAL REGISTERS\n         BALR  1,3                 RETURN WITH THE CONDITION CODE\n*                                  IN REGISTER 1\n         SPACE 1\n         DROP  SELF\n         USING SAVE,13\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        DATA AREA FOR THE SUBMONITOR                                 *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         DS    0F\nASAVE    DC    A(SAVE)             ADDRESS OF OS SAVE AREA\nABASE1   DC    A(BASE1)            BASE ADDRESS FOR INITIALIZATION\nMAXCODE  DC    A(ENDSERV-4)        LARGEST VALID SERVICE CODE\nASMR     DC    A(SMRET)            ADDRESS OF SUBMONITOR RETURN TO OS\nRTNSV    DC    F'0'                SAVE COMPLETION CODE RETURNED\n*                                  BY THE XPL PROGRAM\nABESAVE  DS    F                   SAVE ABEND CODE DURING CLOSE\nABEREGS  DS    3F                  SAVE PROGRAMS REGS 0-2 BEFORE ABEND\nTTR      DC    F'0'                TTRZ ADDRESS FOR READ AND WRITE\nTTRSET   DC    X'00000100'         ADDRESS CONSTANT FOR TTRZ\nFLAGS    DC    X'00'               SUBMONITOR CONTROL FLAGS\nSAVREG   DC    16F'0'              SAVE AREA FOR THE SUBMONITOR\n         DS    0D\nDTSV     DC    PL8'0'              WORK AREA FOR CONVERTING DATE\nTPACK    DS    0H                  PARAMETERS FOR THE TRACE ROUTINE\n         DC    A(CONTROL)          POINTER TO THE PARM FIELD OF\n*                                  THE OS  EXEC  CARD\n         DC    A(SAVREG)           ADDRESS OF THE REGISTER TABLE\nILC      DC    A(GOC)              ADDRESS TO BEGIN TRACING\n         DC    V(TRACE)            ADDRESS OF THE TRACE ROUTINE\n         DC    A(EXEC)             ADDRESS OF THE EXECUTE ROUTINE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        DCB ADDRESS TABLE FOR ALL I/O ROUTINES                       *\n*                                                                     *\n*                                                                     *\n*        THE FOUR SETS OF DCB ADDRESSES HEADED BY  'GETDCBS',         *\n*        'PUTDCBS', 'ARWDCBS', AND 'PGMDCB' MUST BE CONTIGUOUS        *\n*        AND END WITH 'PGMDCB'.  THESE LISTS ARE USED AT JOB END      *\n*        TO CLOSE ALL FILES BEFORE RETURNING TO OS                    *\n*                                                                     *\n*                                                                     *\n*        DCB ADDRESSES FOR INPUT FILES:                               *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\n         SPACE 1\nGETDCBS  DS    0F\n&I       SETA  0\n.GD1     AIF   (&I GT &INPUTS).GD2\n         DC    A(INPUT&I)\n&I       SETA  &I+1\n         AGO   .GD1\n.GD2     ANOP\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        DCB ADDRESSES FOR OUTPUT FILES                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nPUTDCBS  DS    0F\n         SPACE 1\n&I       SETA  0\n.PD1     AIF   (&I GT &OUTPUTS).PD2\n         DC    A(OUTPUT&I)\n&I       SETA  &I+1\n         AGO   .PD1\n.PD2     ANOP\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        DCB ADDRESS FOR DIRECT ACCESS FILES                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nARWDCBS  DS    0F\n         SPACE 1\n&I       SETA  1\n.DA1     AIF   (&I GT &FILES).DA2\n         ORG   ARWDCBS+RD&I-FILEORG\n         DC    A(FILE&I.IN)\n         ORG   ARWDCBS+WRT&I-FILEORG\n         DC    A(FILE&I.OUT)\n&I       SETA  &I+1\n         AGO   .DA1\n.DA2     ANOP\n         ORG   ARWDCBS+ENDSERV-FILEORG\n         DS    0F\n         SPACE 2\nPGMDCB   DC    X'80'               FLAG END OF PARAMETER LIST\n         DC    AL3(PROGRAM)        ADDRESS OF PROGRAM DCB\n         SPACE 2\nOCDCB    DS    F                   DCB ADDRESSES FOR OPEN AND CLOSE\nMOVEADR  DS    1F                  DESCRIPTOR STORAGE FOR PUT ROUTINE\nFILLENG  DC    F'0'                LENGTH OF PADDING NEEDED IN OUTPUT\nF1       DC    F'1'                THE CONSTANT ONE\nF2       DC    F'2'                THE CONSTANT TWO\nGETMOVE  MVC   0(0,2),0(1)         MVC COMMAND FOR THE GET ROUTINE\nMVCNULL  MVC   1(0,1),0(1)         MVC COMMAND FOR THE PUT ROUTINE\nMVCBLANK MVC   2(0,1),1(1)             \"\nMVCSTRNG MVC   0(0,1),0(2)             \"\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        DATA AREA FOR THE EXECUTE ROUTINE                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nXCELL    DS    1F                  INSTRUCTION TO BE EXECUTED\n         DS    1F                  MORE INSTRUCTION\n         DS    1F                  ADDRESS OF TRACE ROUTINE REGISTER\n*                                  TABLE\n         DS    1F                  RETURN ADDRESS TO THE TRACE ROUTINE\n*                                  ADDRESS OF EXEC IS IN REGISTER FOUR\nEXSV     DS    2F                  WORK AREA FOR THE EXECUTE ROUTINE\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        DEVICE  CONTROL  BLOCKS  FOR  THE  SUBMONITOR                *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPROGRAM  DCB   DSORG=PS,                                               X\n               MACRF=R,                                                X\n               DDNAME=PROGRAM,                                         X\n               DEVD=DA,                                                X\n               KEYLEN=0,                                               X\n               EODAD=EODPGM,                                           X\n               SYNAD=ERRPGM\n         SPACE 2\nINPUT0   DCB   DSORG=PS,                                               X\n               DDNAME=SYSIN,                                           X\n               DEVD=DA,                                                X\n               MACRF=GL,                                               X\n               BUFNO=3,                                                X\n               EODAD=INEOD,                                            X\n               SYNAD=INSYNAD,                                          X\n               EXLST=INEXIT0,                                          X\n               EROPT=ACC\n         SPACE 1\n***********************************************************************\n*                                                                     *\nINPUT1   EQU   INPUT0              INPUT(0) & INPUT(1) ARE BOTH SYSIN *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n&I       SETA  2\n.INP1    AIF   (&I GT &INPUTS).INP2\n         SPACE 1\nINPUT&I  DCB   DSORG=PS,                                               X\n               DDNAME=INPUT&I,                                         X\n               DEVD=DA,                                                X\n               MACRF=GL,                                               X\n               EODAD=INEOD,                                            X\n               SYNAD=INSYNAD,                                          X\n               EXLST=INEXIT&I,                                         X\n               EROPT=ACC\n         SPACE 1\n&I       SETA  &I+1\n         AGO   .INP1\n.INP2    ANOP\n         SPACE 2\nOUTPUT0  DCB   DSORG=PS,                                               X\n               DDNAME=SYSPRINT,                                        X\n               DEVD=DA,                                                X\n               MACRF=PL,                                               X\n               SYNAD=OUTSYNAD,                                         X\n               EXLST=OUTEXIT0,                                         X\n               EROPT=ACC\n         SPACE 1\n***********************************************************************\n*                                                                     *\nOUTPUT1  EQU   OUTPUT0             OUTPUT(0), OUTPUT(1) BOTH SYSPRINT *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nOUTPUT2  DCB   DSORG=PS,                                               X\n               DDNAME=SYSPUNCH,                                        X\n               DEVD=DA,                                                X\n               MACRF=PL,                                               X\n               SYNAD=OUTSYNAD,                                         X\n               EXLST=OUTEXIT2,                                         X\n               EROPT=ACC\n         SPACE 1\n&I       SETA  3\n.OP1     AIF   (&I GT &OUTPUTS).OP2\n         SPACE 1\nOUTPUT&I DCB   DSORG=PS,                                               X\n               DDNAME=OUTPUT&I,                                        X\n               DEVD=DA,                                                X\n               MACRF=PL,                                               X\n               SYNAD=OUTSYNAD,                                         X\n               EXLST=OUTEXIT&I,                                        X\n               EROPT=ACC\n         SPACE 1\n&I       SETA  &I+1\n         AGO   .OP1\n.OP2     ANOP\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        DCBS FOR THE DIRECT ACCESS FILES                             *\n*                                                                     *\n*                                                                     *\n*        BECAUSE OF THE MANNER IN WHICH THE FILES ARE USED,  IT IS    *\n*        NECESSARY TO HAVE TWO DCB'S FOR EACH FILE.  ONE DCB FOR      *\n*        READING AND ONE FOR WRITING.                                 *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n&I       SETA  1\n.DD1     AIF   (&I GT &FILES).DD2\n         SPACE 1\nFILE&I.IN DCB  DSORG=PS,                                               X\n               MACRF=RP,                                               X\n               DDNAME=FILE&I,                                          X\n               DEVD=DA,                                                X\n               RECFM=F,                                                X\n               LRECL=FILEBYTS,                                         X\n               BLKSIZE=FILEBYTS,                                       X\n               KEYLEN=0,                                               X\n               EODAD=FILEEOD,                                          X\n               SYNAD=FILESYND\n         SPACE 2\nFILE&I.OUT DCB DSORG=PS,                                               X\n               MACRF=WP,                                               X\n               DDNAME=FILE&I,                                          X\n               DEVD=DA,                                                X\n               RECFM=F,                                                X\n               KEYLEN=0,                                               X\n               LRECL=FILEBYTS,                                         X\n               BLKSIZE=FILEBYTS,                                       X\n               SYNAD=FILESYND\n         SPACE 1\n&I       SETA  &I+1\n         AGO   .DD1\n.DD2     ANOP\n         SPACE 4\nXPLSMEND DS    0H                  END  OF  THE  SUBMONITOR\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        DSECT WHICH DEFINES THE FORMAT OF BINARY PROGRAM CONTROL     *\n*        INFORMATION AND THE STARTING POINT FOR PROGRAMS              *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nFILECTRL DSECT\n         SPACE 1\nBYTSCODE DS    1F                  NUMBER OF BYTES OF CODE\n         SPACE 1\nBYTSDATA DS    1F                  NUMBER OF BYTES OF DATA AREA\n         SPACE 1\nBLKSCODE DS    1F                  NUMBER OF RECORDS OF CODE\n         SPACE 1\nBLKSDATA DS    1F                  NUMBER OF RECORDS OF DATA AREA\n         SPACE 1\nBYTSBLK  DS    1F                  BLOCKSIZE OF THE XPL PROGRAM FILE\n         SPACE 1\nBYTSFULL DS    1F                  NUMBER OF BYTES OF CODE ACTUALLY\n*                                  USED IN THE LAST RECORD OF CODE\n         SPACE 1\nDATABYTS DS    1F                  NUMBER OF BYTES OF DATA ACTUALLY\n*                                  USED IN THE LAST RECORD OF DATA\n         SPACE 1\n         ORG   FILECTRL+60         REMAINDER OF THE CONTROL BLOCK\n*                                  IS UNUSED\n         SPACE 1\nCODEBEGN DS    0H                  FIRST EXECUTABLE INSTRUCTION\n*                                  IN THE XPL PROGRAM\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        DUMMY  DCB  FOR  DEFINING  DCB  FIELDS                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         DCBD  DSORG=QS,DEVD=DA\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        THE  END                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 5\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XPLBNF": {"ttr": 6408, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x12\\x18\\x00z\\x00z\\x00\\x00\\xc2\\xd5\\xc6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T12:18:00", "lines": 122, "newlines": 122, "modlines": 0, "user": "BNF"}, "text": "$             X P L   G R A M M A R\n$\n$\n$ITERATE\n$PUNCH\n$\n$\n<PROGRAM> <STATEMENT LIST>\n<STATEMENT LIST> <STATEMENT>\n     <STATEMENT LIST> <STATEMENT>\n<STATEMENT>          <BASIC STATEMENT>\n                     <IF STATEMENT>\n<BASIC STATEMENT>    <ASSIGNMENT> ;\n                     <GROUP> ;\n                     <PROCEDURE DEFINITION> ;\n                     <RETURN STATEMENT> ;\n                     <CALL STATEMENT> ;\n                     <GO TO STATEMENT> ;\n                     <DECLARATION STATEMENT>;\n                     ;\n   <LABEL DEFINITION>  <BASIC STATEMENT>\n<IF STATEMENT>       <IF CLAUSE> <STATEMENT>\n                     <IF CLAUSE> <TRUE PART> <STATEMENT>\n   <LABEL DEFINITION>  <IF STATEMENT>\n<IF CLAUSE>   IF <EXPRESSION> THEN\n<TRUE PART>          <BASIC STATEMENT> ELSE\n<GROUP>              <GROUP HEAD> <ENDING>\n<GROUP HEAD>         DO ;\n                     DO <STEP DEFINITION> ;\n   DO <WHILE CLAUSE> ;\n   DO <CASE SELECTOR> ;\n                     <GROUP HEAD> <STATEMENT>\n<STEP DEFINITION>  <VARIABLE> <REPLACE> <EXPRESSION> <ITERATION CONTROL >\n<ITERATION CONTROL>  TO <EXPRESSION>\n   TO <EXPRESSION> BY <EXPRESSION>\n<WHILE CLAUSE>  WHILE <EXPRESSION>\n<CASE SELECTOR>  CASE <EXPRESSION>\n<PROCEDURE DEFINITION> <PROCEDURE HEAD> <STATEMENT LIST> <ENDING>\n<PROCEDURE HEAD>  <PROCEDURE NAME> ;\n                  <PROCEDURE NAME> <TYPE> ;\n   <PROCEDURE NAME> <PARAMETER LIST>;\n   <PROCEDURE NAME> <PARAMETER LIST> <TYPE> ;\n<PROCEDURE NAME>  <LABEL DEFINITION> PROCEDURE\n<PARAMETER LIST>  <PARAMETER HEAD> <IDENTIFIER> )\n<PARAMETER HEAD>  (\n   <PARAMETER HEAD>  <IDENTIFIER> ,\n<ENDING>             END\n                     END <IDENTIFIER>\n   <LABEL DEFINITION> <ENDING>\n<LABEL DEFINITION>  <IDENTIFIER> :\n<RETURN STATEMENT>   RETURN\n                     RETURN <EXPRESSION>\n<CALL STATEMENT>     CALL <VARIABLE>\n<GO TO STATEMENT>    <GO TO> <IDENTIFIER>\n<GO TO>              GO TO\n                     GOTO\n<DECLARATION STATEMENT>  DECLARE <DECLARATION ELEMENT>\n                     <DECLARATION STATEMENT> , <DECLARATION ELEMENT>\n<DECLARATION ELEMENT>  <TYPE DECLARATION>\n   <IDENTIFIER> LITERALLY <STRING>\n<TYPE DECLARATION> <IDENTIFIER SPECIFICATION> <TYPE>\n   <BOUND HEAD> <NUMBER> ) <TYPE>\n   <TYPE DECLARATION> <INITIAL LIST>\n<TYPE>               FIXED\n                     CHARACTER\n   LABEL\n   <BIT HEAD> <NUMBER> )\n<BIT HEAD> BIT (\n<BOUND HEAD> <IDENTIFIER SPECIFICATION> (\n<IDENTIFIER SPECIFICATION> <IDENTIFIER>\n         <IDENTIFIER LIST> <IDENTIFIER> )\n<IDENTIFIER LIST>  (\n     <IDENTIFIER LIST> <IDENTIFIER> ,\n<INITIAL LIST>       <INITIAL HEAD> <CONSTANT> )\n<INITIAL HEAD>       INITIAL (\n                     <INITIAL HEAD> <CONSTANT> ,\n<ASSIGNMENT>  <VARIABLE> <REPLACE> <EXPRESSION>\n                     <LEFT PART> <ASSIGNMENT>\n<REPLACE>  =\n<LEFT PART>          <VARIABLE> ,\n<EXPRESSION>  <LOGICAL FACTOR>\n   <EXPRESSION> |  <LOGICAL FACTOR>\n<LOGICAL FACTOR>     <LOGICAL SECONDARY>\n                     <LOGICAL FACTOR> &   <LOGICAL SECONDARY>\n<LOGICAL SECONDARY>  <LOGICAL PRIMARY>\n                      \u00ac  <LOGICAL PRIMARY>\n<LOGICAL PRIMARY>  <STRING EXPRESSION>\n   <STRING EXPRESSION> <RELATION> <STRING EXPRESSION>\n<RELATION>           =\n                     <\n                     >\n                     \u00ac =\n                     \u00ac <\n                     \u00ac >\n                     < =\n                     > =\n<STRING EXPRESSION>  <ARITHMETIC EXPRESSION>\n   <STRING EXPRESSION> ||  <ARITHMETIC EXPRESSION>\n<ARITHMETIC EXPRESSION> <TERM>\n                     <ARITHMETIC EXPRESSION> + <TERM>\n                     <ARITHMETIC EXPRESSION> - <TERM>\n                     + <TERM>\n                     - <TERM>\n<TERM>               <PRIMARY>\n                     <TERM> * <PRIMARY>\n                     <TERM> / <PRIMARY>\n                     <TERM> MOD <PRIMARY>\n<PRIMARY>            <CONSTANT>\n                     <VARIABLE>\n   ( <EXPRESSION> )\n<VARIABLE>  <IDENTIFIER>\n   <SUBSCRIPT HEAD> <EXPRESSION> )\n<SUBSCRIPT HEAD>     <IDENTIFIER> (\n                     <SUBSCRIPT HEAD> <EXPRESSION> ,\n<CONSTANT>           <STRING>\n                     <NUMBER>\n$\n$\n$\n$\n$\n$OUTPUT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XPLLIBR": {"ttr": 6411, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13_\\x01\\x01\\x13_\\x12\\x18\\x00M\\x00M\\x00\\x00\\xd3\\xc9\\xc2\\xd9\\xc1\\xd9\\xe8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-15T00:00:00", "modifydate": "2001-05-15T12:18:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "LIBRARY"}, "text": "COMPACTIFY:\n   PROCEDURE;\n   DECLARE (I, J, K, L, ND, TC, BC, DELTA) FIXED;\n   DECLARE DX_SIZE LITERALLY '500', DX(DX_SIZE) BIT(16);\n   DECLARE MASK FIXED INITIAL (\"FFFFFF\"), LOWER_BOUND FIXED, TRIED BIT(1);\n   /* FIRST WE MUST SET THE LOWER BOUND OF THE COLLECTABLE AREA */\n   IF LOWER_BOUND = 0 THEN LOWER_BOUND = FREEBASE;\n DO TRIED = 0 TO 1;\n   ND = -1;\n   /* FIND THE COLLECTABLE DESCRIPTORS  */\n   DO I = 0 TO NDESCRIPT;\n      IF (DESCRIPTOR(I) & MASK) >= LOWER_BOUND THEN\n         DO;\n            ND = ND + 1;\n            IF ND > DX_SIZE THEN\n               DO;  /* WE HAVE TOO MANY POTENTIALLY COLLECTABLE STRINGS  */\n                  OUTPUT = '* * * NOTICE FROM COMPACTIFY:  DISASTROUS STRING OVE\nRFLOW.   JOB ABANDONED. * * *';\n                  CALL EXIT;\n               END;\n            DX(ND) = I;\n         END;\n   END;\n   /* SORT IN ASCENDING ORDER  */\n   K, L = ND;\n   DO WHILE K <= L;\n      L = -2;\n      DO I = 1 TO K;\n         L = I - 1;\n         IF (DESCRIPTOR(DX(L)) & MASK) > (DESCRIPTOR (DX(I)) & MASK) THEN\n            DO;\n               J = DX(L); DX(L) = DX(I); DX(I) = J;\n               K = L;\n            END;\n      END;\n   END;\n   /* MOVE THE ACTIVE STRINGS DOWN  */\n   FREEPOINT = LOWER_BOUND;\n   TC, DELTA = 0;\n   BC = 1;   /* SETUP INITIAL CONDITION  */\n   DO I = 0 TO ND;\n      J = DESCRIPTOR(DX(I));\n      IF (J & MASK) - 1 > TC THEN\n         DO;\n           IF DELTA > 0 THEN\n            DO K = BC TO TC;\n               COREBYTE(K-DELTA) = COREBYTE(K);\n            END;\n            FREEPOINT = FREEPOINT + TC - BC + 1;\n            BC = J & MASK;\n            DELTA = BC - FREEPOINT;\n         END;\n      DESCRIPTOR (DX(I)) = J - DELTA;\n      L = (J & MASK) + SHR(J, 24);\n      IF TC < L THEN TC = L;\n   END;\n   DO K = BC TO TC;\n      COREBYTE(K-DELTA) = COREBYTE(K);\n   END;\n   FREEPOINT = FREEPOINT + TC - BC + 1;\n   IF SHL(FREELIMIT-FREEPOINT, 4) < FREELIMIT-FREEBASE THEN\n      LOWER_BOUND = FREEBASE;\n   ELSE\n      DO;\n         LOWER_BOUND = FREEPOINT;\n         RETURN ;\n      END;\n   /* THE HOPE IS THAT WE WON'T HAVE TO COLLECT ALL THE STRINGS EVERY TIME */\n   END ;  /* OF THE DO TRIED LOOP       */\n   IF FREELIMIT-FREEPOINT < 256 THEN\n            DO;\n               OUTPUT = '* * * NOTICE FROM COMPACTIFY:  INSUFFICIENT STRING SPAC\nE  JOB ABANDONED. * * *';\n               CALL EXIT;    /* FORCE ABEND  */\n            END;\n\nEND COMPACTIFY;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT517/FILE517.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT517", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}