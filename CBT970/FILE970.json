{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013624000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE970.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE970.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x05\\x06'", "DS1TRBAL": "b'i\\x0e'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n\\x18\\x00\\x03\\n\\x18\\x00\\x08\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00Y\\x01\\x180\\x8f\\x01\\x180\\x8f\\x14\\x03\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T14:03:59", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-496"}, "text": "REGULAR CBT TAPE - VERSION 496    FILE:  970\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT496.FILE970\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 6 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,106 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/04/18    14:03:59    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DISCLAM": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x18\\x03/\\x01\\x18\\x03?\\x07\\x18\\x00\\x0c\\x00\\x10\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-02-01T00:00:00", "modifydate": "2018-02-02T07:18:32", "lines": 12, "newlines": 16, "modlines": 0, "user": "KTOMIAK"}, "text": "\nSTANDARD GLOBAL DISCLAIMER\n--------------------------\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it. I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so if you use it, you do so at your own risk.\n\nSincerely yours,\n\"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE970": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00R\\x01\\x180\\x8f\\x01\\x180\\x8f\\x14\\x03\\x00 \\x00 \\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T14:03:52", "lines": 32, "newlines": 32, "modlines": 0, "user": "CBT-496"}, "text": "//***FILE 970 is from Kenneth Tomiak and contains a variant of the  *   FILE 970\n//*           RCNVTCAT REXX EXEC from CBT File 542, which generates *   FILE 970\n//*           DEFINE statements to recatalog entries from an old    *   FILE 970\n//*           catalog into a new catalog (usually for a new z/OS    *   FILE 970\n//*           system).                                              *   FILE 970\n//*                                                                 *   FILE 970\n//*           The RCNVTCA$ on File 542 JCL has been reported to     *   FILE 970\n//*           fail on current systems. Changing PGM=IRXJCL to       *   FILE 970\n//*           PGM=IKJEFT1B was part of the fix. Running as a batch  *   FILE 970\n//*           job still had issues, and so Kenneth embarked on      *   FILE 970\n//*           simplifying the REXX code and then added some user    *   FILE 970\n//*           interface enhancements.                               *   FILE 970\n//*                                                                 *   FILE 970\n//*           RCNVTCAT has been traditionally used to create a new  *   FILE 970\n//*           master catalog from the old master catalog on the     *   FILE 970\n//*           old system, recataloging the old entries in the       *   FILE 970\n//*           new catalog, after editing them (when necessary).     *   FILE 970\n//*                                                                 *   FILE 970\n//*           Kenneth has fixed the format of the TCNVTCA$ JCL      *   FILE 970\n//*           and the TCNVTCAT REXX exec so that it runs as both    *   FILE 970\n//*           a batch job and under TSO. In addition, if you have   *   FILE 970\n//*           launched under ISPF then a PROGRESS panel will be     *   FILE 970\n//*           displayed to keep you occupied as it runs.            *   FILE 970\n//*                                                                 *   FILE 970\n//*           It can still be used as a replacement for IBM's       *   FILE 970\n//*           MCNVTCAT program, which IBM no longer supports.       *   FILE 970\n//*                                                                 *   FILE 970\n//*           2018-02-27 Update                                     *   FILE 970\n//*           Included a missing Find_Hostdsn routine.              *   FILE 970\n//*                                                                 *   FILE 970\n//*           email:  sbgolob@cbttape.org                           *   FILE 970\n//*                                                                 *   FILE 970\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TCNVTCA$": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x006\\x01\\x02\\x01\\x0f\\x01\\x18\\x02_\\x10S\\x00H\\x00\\x14\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2002-01-10T00:00:00", "modifydate": "2018-01-25T10:53:36", "lines": 72, "newlines": 20, "modlines": 0, "user": "KTOMIAK"}, "text": "//IBMUSERJ JOB (),'MIGRATE: TCNVTCAT',\n//             CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1),\n//             REGION=32M,NOTIFY=&SYSUID,COND=(4,LT)\n//*\n//         SET DEFINES='&SYSUID..TCNVTCAT.DEFINES'\n//         SET REXXLIB='&SYSUID..CBT496.FILE970'\n//         SET MCATOLD='SYS1.MCAT.VZ25RES'   <= YOUR CURRENT SYSTEM\n//         SET MCATTGT='SYS1.MCAT.VZ26RES'   <= THE NEW SYSTEM\n//         SET MCATNEW='SYS1.MCAT.VZ26RES'   <= FOR COMPARING\n//         SET VOLSER='WORKA2'\n//*\n//*-----------------------------------------------------------------*\n//*   LIB : &SYSUID..CBT496.FILE970(TCNVTCA$)\n//*   DOC : EXECUTE RCNVTCAT CATALOG CONVERSION PROCEDURE.\n//* SETUP : CHANGE VOLSER=WORKA2 TO A VALID VOLSER FOR YOUR SYSTEM.\n//* SETUP : CHANGE IBMUSER TO YOUR USERID.\n//* SETUP : CHANGE THE MCAT* SYMBOLICS TO YOUR CATALOG NAMES.\n//*-----------------------------------------------------------------*\n//*\n//* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n//* -------------------------------------------------------------------\n//* DELETE ANY PRIOR PARTITIONED DATA SET TO HOLD DEFINE CONTROL CARDS\n//* AND A STATISTICAL REPORT OF CATALOG ENTRIES PROCESSED.\n//* -------------------------------------------------------------------\n//* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n//RERUN1  EXEC PGM=IEFBR14\n//DEFINES   DD DISP=(MOD,DELETE),DSN=&DEFINES,\n//             UNIT=SYSALLDA,SPACE=(TRK,(0,0))\n//*\n//* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n//* -------------------------------------------------------------------\n//* ALLOCATE THE PARTITIONED DATA SET TO HOLD DEFINE CONTROL CARDS\n//* AND A STATISTICAL REPORT OF CATALOG ENTRIES PROCESSED.\n//* -------------------------------------------------------------------\n//* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n//RERUN2  EXEC PGM=IEFBR14\n//DEFINES   DD DISP=(NEW,CATLG),DSN=&DEFINES,\n//             UNIT=SYSALLDA,VOLUME=(SER=(&VOLSER)),\n//             SPACE=(TRK,(5,5,5)),\n//             DCB=(DSORG=PO,RECFM=FB,BLKSIZE=0,LRECL=80)\n//*\n//* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n//* -------------------------------------------------------------------\n//* RUN RCNVTCAT TO PRODUCE IDCAMS DEFINE CONTROL CARDS.\n//* -------------------------------------------------------------------\n//* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n//RCNVTCA EXEC PGM=IKJEFT1B,DYNAMNBR=20, <=== IRXJCL IS NOT SUPPORTED!\n//             PARM='%TCNVTCAT &MCATOLD TARGET(&MCATTGT)'\n//*            PARM='%TCNVTCAT TARGET(&MCATTGT)'    USES CURRENT MCAT\n//*            PARM='%TCNVTCAT &MCATOLD'            USES CURRENT AS TGT\n//*            PARM='%TCNVTCAT &MCATOLD &MCATNEW'   COMPARES 2 MCATS\n//*            PARM='%TCNVTCAT &MCATOLD &MCATNEW TARGET(&MCATTGT)'\n//SYSTSIN   DD DUMMY\n//SYSTSPRT  DD SYSOUT=*\n//SYSEXEC   DD DISP=SHR,DSN=&REXXLIB\n//DEFINES   DD DISP=OLD,DSN=&DEFINES\n//*\n//* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n//* -------------------------------------------------------------------\n//* SHOW THE STATISTCAL REPORT.\n//* -------------------------------------------------------------------\n//* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n//          IF RCNVTCA.RC = 0 THEN\n//REPORT  EXEC PGM=IEBGENER\n//SYSIN     DD DUMMY\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DISP=SHR,DSN=&DEFINES($REPORT)\n//SYSUT2    DD SYSOUT=*\n//       ENDIF\n//*\n//* END OF JOB TCNVTCA$.\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TCNVTCAP": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00R\\x01\\x18\\x02O\\x01\\x18\\x02_\\x08B\\x00\\x1d\\x00\\x1a\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2018-01-24T00:00:00", "modifydate": "2018-01-25T08:42:52", "lines": 29, "newlines": 26, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only            */\n      /*  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)             */\n  $ TYPE(INPUT) INTENS(LOW) PAD(_)    /* input field padded with '_' */\n  ! TYPE(INPUT) INTENS(LOW) PAD(' ')  /* input field padded with ' ' */\n  # TYPE(OUTPUT) INTENS(HIGH)\n  @ TYPE(OUTPUT) INTENS(LOW)\n)BODY EXPAND(\\\\)\n%\\-\\ TCNVTCAT User Interface \\-\\\n%COMMAND ===>_ZCMD                                                             +\n%\n+A master catalog name is required. Press enter to accept the current\n+system MCAT or overtype with an alternate name and press enter.\n+\n+MCATOLD:$MCATOLD                                       +\n+MCATTGT:$MCATTGT                                       +\n+MCATNEW:$MCATNEW                                       + COMPARE (Optional)\n+\n+DEFINES:@MCATDEF\n+\n#MESSAGE\n+\n)INIT\n)PROC\nVER(&MCATOLD,DSNAMEQ)\nVER(&MCATTGT,DSNAMEQ)\nVER(&MCATNEW,DSNAMEQ)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TCNVTCAT": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01V\\x00\\x01\\x01\\x16#\\x0f\\x01\\x18\\x05\\x8f\\x10P\\x07\\x9d\\x06}\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.86", "flags": 0, "createdate": "2016-08-17T00:00:00", "modifydate": "2018-02-27T10:50:01", "lines": 1949, "newlines": 1661, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\n/* REXX - TCNVTCAT : MCNVTCAT replacement in REXX */\n/*======================================================================\n   TCNVTCAT : User provided version of a previous CBIPO supplied\n              MCNVTCAT program to help convert your current master\n              catalog to a new SERVERPAC system-replace master catalog.\n              Uses the Catalog Search Interface (CSI) and generates\n              IDCAMS DEFINE control cards you can run against the new\n              master catalog.\n\n              It can later compare the current master catalog against\n              the new master catalog and generate IDCAMS control cards\n              to bring the new master catalog back in synchronization\n              with the current master catalog.\n--------------------------------------------------------------------- */\n\n/*====================================================================*/\n/* Original Author : Alastair Gray - a_j_gray@hotmail.com\n                   (or the e-mail I use to post on TSO-REXX/IBM-MAIN)\n\n   This was an extension of previous work that was initially derived\n   from the code found in 'SYS1.SAMPLIB(IGGCSIRX)' and blended with\n   what CBIPO supplied MCNVTCAT accomplished.\n\n--------------------------------------------------------------------- */\n\n/*====================================================================*/\n/* Changes : dd/mm/yyyy   Who             What                        */\n/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version RCATCNVT   */\n/* 1.1.0   - 14/01/2002 - Alastair Gray - Rewrite using CLICODE base  */\n/* 1.1.1   - 14/01/2002 - Alastair Gray - Modify > 5 item handling    */\n/* 1.2.0   - 14/01/2002 - Alastair Gray - Add proper foreground       */\n/* 1.2.1   - 15/01/2002 - Alastair Gray - Add PAGESPACE RECAT         */\n/* 1.2.2   - 16/01/2002 - Alastair Gray - Add 3590 + extra error msgs */\n/* 1.3.0   - 16/01/2002 - Alastair Gray - Add CLUSTER RECAT some attrs*/\n/* 1.3.1   - 22/01/2002 - Alastair Gray - In line with CSICODE        */\n/* 1.4.0   - 14/02/2002 - Alastair Gray - Added Catalog compare code  */\n/* 1.4.1   - 15/02/2002 - Alastair Gray - Couple of minor typos fixed */\n/* 1.4.2   - 21/02/2002 - Alastair Gray - Fixed RECAT error           */\n/* 1.4.3   - 03/04/2002 - Alastair Gray - Fixed catcomp code          */\n/* 1.4.4   - 29/04/2002 - Alastair Gray - Added '?' option            */\n/* 1.4.5   - 31/05/2002 - Alastair Gray - Correction to processing    */\n/* 1.4.6   - 21/06/2002 - Alastair Gray - Checked work area required  */\n/* 1.4.7   - 08/08/2002 - Alastair Gray - Corrected Pagespace process */\n/* 1.4.8   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.9   - 16/08/2002 - Alastair Gray - Added detail to COMP reports*/\n/* 1.4.10  - 13/09/2002 - Alastair Gray - Renamed to RCNVTCAT         */\n/* 1.4.11  - 20/09/2002 - Alastair Gray - Modified unexpected error   */\n/* 1.4.12  - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.13  - 20/09/2002 - Alastair Gray - Fixed 'odd' VSAM recat error*/\n/* 1.4.14  - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */\n/* 1.4.15  - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.4.15  - 18/11/2002 - Alastair Gray - Fixed catcomp error new>old */\n/* 1.4.16  - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.5.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.5.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.5.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.5.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.5.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/* 1.5.5   - 03/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/\n/* 1.5.6   - 09/12/2003 - Alastair Gray - Added debug code            */\n/* 1.5.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */\n/* 1.5.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */\n/* 1.5.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */\n/* 1.6.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */\n/* 1.6.1   - 26/09/2012 - Alastair Gray - Corrected variable bug      */\n/* 1.7.0   - 17/08/2016 - Lionel Dyck   - SWA Above the Line          */\n/* 1.7.1   - 16/08/2016 - John McKown   - replace LISTDSI &\n                                          make UNIX shell compatible  */\n/* ??      - 06/10/2016 - Tom Taylor    - Fixed Substr of csicatnm    */\n/* 1.7.2   - 08/11/2016 - Lionel Dyck   - Add TARGET keyword          */\n/* 1.81    - 30/08/2017 - \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n             Opinion: No real z/OS System Programmer wanted UNIX\n                      shell compatibility that complicated the code.\n             1) Using the ISPF vv.mm to identify a levelset.\n                Use VER/LEV n to handle bundled changes.\n             2) Changed routine DSEXIST to is_dataset_a_catalog to\n                better describe what the routine is doing.\n             3) Fixed error ROUTINE NOT FOUND on OUTTRAP under\n                is_dataset_a_catalog when RCNVTCAS uses PGM=IRXJCL.\n             4) Removed errant comment claiming the REPORT will always\n                be dynamically allocated.\n             5) Removed 'obsolete' changed routines.\n             6) Removed empty comments to improve phase-1 performance.\n                And removed gobs of trailing comment blank space.\n                Eliminated some redundant comments that stated nothing\n                more than what the REXX code had.\n             7) Changed comment boxes to improve phase-1 performance.\n             8) Added consistent punctuation to comments.\n             9) Personal preference: changed contractions to two words.\n             10) Changed /= to be consistent with use of <>.\n             11) Removed unused routines:\n                 Old LISTDD\n                 Older LISTDD\n                 SWAREQ\n             12) Space permitting, moved DO onto the THEN line so\n                 that a THEN by itself implies only the next statement\n                 is part of the IF.\n                 Moved Then to end of IF.\n                 Put DO onto the ELSE.\n             13) Removed VSAMREUS as it is unused and claimed to\n                 duplicate ATTR1.\n             14) Separated the REPORT from the DEFINES control cards.\n             15) Added a DO to Otherwise for consistency.\n             16) Added OMVS(USS) allocate of DEFINES separate from\n                 REPORT. Better blocking factor, too.\n             17) Added Returns where they were missing or I\n                 accidentally deleted them.\n             18) REPORT: Added the missing printer control for what was\n                 LRECL=133 (now 137 because I went to VBA).\n--------------------------------------------------------------------- */\n/* 1.82    - 19/01/2018 - \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n             1) Fixed the dynamic allocation of REPORT when not run\n                from the sample JCL RCNVTCA$.\n--------------------------------------------------------------------- */\n/* 1.83    - 25/01/2018 - \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n             1) Renamed to TCNVTCAT for TSO-Only.\n             2) The 'REPORT' no longer uses VBA 137 and is placed in the\n                same PDS as the DEFINE statements as member $REPORT.\n             3) Removed the unused sms_flag code.\n             4) Shift code to be more efficient, e.g. check allocations\n                and argument values before initializing variables.\n               a) Moved DD checking earlier in the processing.\n               b) Moved DD allocation earlier in the processing.\n               c) Moved argument checking earlier in the processing.\n             5) Issue return code > 0 when things are not right.\n             6) Documented CSIOPTNS uses 'F' to avoid the 65,535\n                limitation listed below.\n             7) cat.1 was being blanked out, causing the current\n                system master catalog to be used regardless of what\n                'old' catalog name was passed in as an argument.\n                Commented out cat.1 = ' '\n             8) Removed DEBUG code.\n             9) Added PANEL(TCNVTCAP) when FOREGROUND ISPF enabled.\n             10) Reduced REPORT to 80 columns.\n             11) Removed SYSCTLG from the report.\n             12) Removed bogus cat variable from the CATALOG operand.\n             13) Changed 2LQ to TCNVTCAT.\n--------------------------------------------------------------------- */\n/* 1.84    - 25/01/2018 - \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n             1) Removed label FINISH.\n             2) Added progress display to the COMPCAT routine.\n--------------------------------------------------------------------- */\n/* 1.85    - 26/01/2018 - \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n             1) Indentation and stylized using the Programming Using\n                The Kenneth Tomiak Method (PUTKTM).\n             2) Create member $JCL with sample IDCAMS JCL.\n             3) If mcatold not passed then default to current system.\n--------------------------------------------------------------------- */\n/* 1.86    - 27/02/2018 - \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n             1) Included the Find_Hostdsn() routine. This version\n                uses QBASELIB to get the data set name.\n--------------------------------------------------------------------- */\n\n/*======================================================================\n   Notes :\n\n   1. This program writes out various error messages, the return and\n      reason codes can be checked using those found listed for the\n      IBM message IDC3009I. The module is the CSI internal reference\n      and probably is not of much use to anyone outside IBM.\n\n   2. Two return codes are 'special':\n      RC=100, Reason=4\n      RC=44 , Reason=14\n\n      This relates to entries of greater than 65,535 characters.\n      If you get these special RCs, then you need to enable fullword\n      processing by changing the value of CSIOPTNS to 'F' from ' '.\n\n      Kenneth Tomiak writes:\n      CSIOPTNS was added in change 1.5.5   - 03/12/2003.\n      Only those running on a pre OS/390 R10 system would be affected\n      as the code defaults to 'F' when MVSVAR('sysmvs') positions 3,5,7\n      are greater than '609'.\n\n--------------------------------------------------------------------- */\n\n/*====================================================================\n   So how does this differ from the original MCNVTCAT ?\n\n   1. Well it's written in REXX and uses the Catalog Search Interface.\n\n   2. It does not check the actual devices available on the system\n      So you may get a catalog entry for a non-present device type.\n\n   3. It does not add bits of LISTCAT messages into the report totals\n      or the generated members.\n\n   4. It DOES handle datasets cataloged on more than five volume !\n      So does not write out an error message for that condition.\n\n   5. I am pretty sure that it does not handle SYSCTLG properly. As\n      the manual states that OS CVOLs do not work after 01/01/2000 I\n      guess this should not be an issue for many out there.\n\n   6. It writes its report to the $REPORT member of the PDS rather\n      than to a SYSOUT.\n\n   7. It generates a RECAT member that contains statements to allow\n      the RECATALOG of PAGESPACE and SYS1.** datasets.\n\n      Currently this only supports VSAM clusters with the following\n      non-default attributes : LINEAR, REUSE\n\n   8. It can be used to compare two catalogs and produces reports\n      showing the differences between the catalogs.\n\n  ====================================================================*/\n\n  PARSE UPPER Arg all_arguments       /* Get passed arguments */\n  my_rc = Initialization_routine()\n  IF (my_rc = 0) THEN my_rc = Process_routine()\n  my_rc = Termination_routine()\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  PARSE VERSION,\n    version_rexx_name,       /* REXX370 */\n    version_rexx_version,    /* 3.48 */\n    version_rexx_date        /* 01 May 1992 */\n  PARSE SOURCE,\n    source_host_env,         /* TSO */\n    source_call_type,        /* COMMAND */\n    source_uc_exec_name,     /* GENIE */\n    source_hostdd,           /* SYSEXEC */\n    source_hostdsn,          /* ? */\n    source_nf_exec_name,     /* ? */\n    source_initial_cmd_env,  /* TSO */\n    source_asid_name,        /* ISPF */\n    source_char8_user_token, /* ? */\n    source_hostother         /* \"\" */\n  TSO_flag = ''\n  env_flag = ''\n  ispf_flag = ''\n  r_cnt = 0\n  IF (ADDRESS() = 'TSO') THEN DO       /* test IF under TSO */\n    x = Msg('Off')                     /* Disable messages */\n    x = Prompt('Off')                  /* Disable prompts */\n    TSO_flag = 'TSO'                   /* set TSO flag */\n    IF (SYSVAR(\"SYSENV\") = 'FORE') THEN DO /* test for foreground */\n      env_flag = 'FORE'                 /* set ENV flag */\n    END\n    IF (SYSVAR(\"SYSISPF\") = 'ACTIVE') THEN DO /* test for ISPF */\n      ispf_flag = 'ISPF'                /* set ISPF flag */\n      function_rc = ispf_enable()\n    END\n  END\n  ELSE DO\n    SAY \"This simplified version of RCNVTCAT only runs under TSO.\"\n    return_code = 16\n    return return_code\n  END\n\n/*====================================================================\n   Call internal routine to discover DDNAMEs and their data sets.\n======================================================================*/\n  function_rc = get_listalc()     /* This only needs to be done once! */\n\n/*====================================================================\n   Check IF //DEFINES is allocated. IF not, allocate a new data set.\n======================================================================*/\n  rcnvtcat_defines_dsn = ddname_allocated_check(\"DEFINES\")\n  IF (rcnvtcat_defines_dsn = \"UNDEFINED\") THEN DO\n    llq = random(100000)\n    IF (SYSVAR(\"SYSPREF\") <> SYSVAR(\"SYSUID\")) THEN DO\n      SAY SYSVAR(\"SYSPREF\") \"<>\" SYSVAR(\"SYSUID\")\n      rcnvtcat_defines_dsn = SYSVAR(\"SYSPREF\")\".TCNVTCAT.DEFINES.T\"llq\n    END\n    ELSE DO\n      rcnvtcat_defines_dsn = SYSVAR(\"SYSUID\")\".TCNVTCAT.DEFINES.T\"llq\n    END\n    function_rc = SYSDSN(\"'\"rcnvtcat_defines_dsn\"'\")\n    IF (function_rc = \"OK\") THEN DO\n      r_cnt = r_cnt + 1\n      r_text = \"'\"rcnvtcat_defines_dsn\"' exists, deleting it.\"\n      ADDRESS TSO \"DELETE '\"rcnvtcat_defines_dsn\"'\"\n      delete_rc = RC\n      IF (delete_rc <> 0) THEN DO\n        r_cnt = r_cnt + 1\n        r_text.r_cnt = \"DELETE of '\"rcnvtcat_defines_dsn\"'\" ,\n          \"failed, RC(\"delete_rc\")\"\n        r_cnt = r_cnt + 1\n        r_text.r_cnt = \"Unable to continue.\"\n        function_rc = show_report_text()\n        return_code = 16\n        return return_code\n      END\n    END\n    ADDRESS TSO \"ALLOC FILE(DEFINES) DA('\"rcnvtcat_defines_dsn\"')\" ,\n      \"UNIT(SYSALLDA) TRACKS SPACE(5,15) DIR(5)\" ,\n      \"RECFM(F B) BLKSIZE(0) LRECL(80) NEW CATALOG\"\n    alloc_rc = RC\n    IF (alloc_rc <> 0) THEN DO\n      r_cnt = r_cnt + 1\n      r_text.r_cnt = \"Allocation of the PDS for '\"rcnvtcat_defines_dsn\"'\" ,\n        \"failed, RC(\"alloc_rc\")\"\n      r_cnt = r_cnt + 1\n      r_text.r_cnt = \"Unable to continue.\"\n      function_rc = show_report_text()\n        return_code = 16\n        return return_code\n    END\n  END\n\n/*====================================================================\n   Handle passed parameters.\n======================================================================*/\n\n/* ------------------------------------- *\n   Check for TARGET(newcatalog) keyword:\n   - not found THEN done here\n   - found THEN extract\n     - save target catalog name\n     - remove from parameters\n * ------------------------------------- */\n  mcattgt = ''                         /* set target catalog to null */\n  IF POS(\"TARGET(\",all_arguments) > 0 THEN DO\n    PARSE VAR all_arguments val_left \"TARGET(\"mcattgt\")\" val_right\n    all_arguments = val_left val_right\n    IF left(mcattgt,1) = \"'\" THEN DO\n       PARSE VAR mcattgt \"'\" mcattgt \"'\" .\n    END\n  END\n\n  argnum = 0\n  cat. = ''\n  DO i = 1 to Words(all_arguments)     /* loop thru arguments */\n    testarg = STRIP(Word(all_arguments,i),B,\"'\") /* remove apostrophes */\n    argnum = argnum + 1\n    cat.argnum = testarg\n  END\n  SELECT\n    WHEN (argnum = 0) THEN DO\n      IF (env_flag = 'FORE') & ,\n         (ispf_flag = 'ISPF') THEN DO\n        function_rc = prompt_for_mcat()\n        IF (function_rc = 0) THEN DO\n          ZERRALRM = \"YES\"\n          ZERRHM = \"*\"\n          ZERRSM = 'Abort accepted'\n          ZERRLM = 'User aborted processing.'\n          ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n          return_code = 16\n          return return_code\n        END\n      END\n      ELSE DO\n        r_cnt = r_cnt + 1\n        r_text.r_cnt = '**(cat)** No entry provided for catalog name.'\n        r_cnt = r_cnt + 1\n        r_text.r_cnt = '**(cat)** Defaulting to current system.'\n        function_rc = show_report_text()\n        outtrap_rc = OUTTRAP(cat_out.)\n        ADDRESS TSO \"LISTCAT ENTRY('\"SYSVAR(\"SYSUID\")\"')\"\n        outtrap_rc = OUTTRAP(\"OFF\")\n        DO ox = 1 to cat_out.0\n          IF (POS(\"IN-CAT --- \",cat_out.ox) > 0) THEN DO\n            PARSE VAR cat_out.ox . \"IN-CAT --- \" mcatold\n            mcatold = STRIP(mcatold,\"B\",\" \")\n            Leave\n          END\n        END\n        cat.1 = mcatold\n        process = 'RCNVTCAT'               /* process as normal RCNVTCAT */\n        IF (mcattgt = '') THEN mcattgt = mcatold\n      END\n    END\n    WHEN (argnum = 1) THEN DO           /* only one catalog */\n      process = 'RCNVTCAT'               /* process as normal RCNVTCAT */\n      IF (mcattgt = \"\") THEN mcattgt = cat.1\n    END\n    WHEN (argnum = 2) THEN DO           /* WHEN two catalogs THEN */\n      process = 'CATCOMP'                /* process for Catalog compare */\n      IF (mcattgt = \"\") THEN mcattgt = cat.2\n    END\n    Otherwise DO                        /* two catalogs */\n      r_cnt = r_cnt + 1\n      r_text.r_cnt = '**(cat)** Too many arguments - retry.'\n      r_cnt = r_cnt + 1\n      r_text.r_cnt = \"I fear I might misinterpret what you meant to do.\"\n      r_cnt = r_cnt + 1\n      r_text.r_cnt = \"Unable to continue.\"\n      function_rc = show_report_text()\n      return_code = 16\n      return return_code\n    END\n  END\n  IF (is_dataset_a_catalog(\"'\"cat.1\"'\") > 4) THEN DO\n    SAY '**(cat)** Bad entry provided for catalog name.'\n    SAY '**(cat)** 'cat.1\n    SAY '**(cat)** LISTCAT ENTRY Return code = 'sysreason\n    SAY '**(cat)** 'sysmsglvl1\n    SAY '**(cat)** 'sysmsglvl2\n    return_code = 16\n    return return_code\n  END\n  ELSE DO\n    mcatold = cat.1\n  END\n  IF (process = 'CATCOMP') &,\n     (is_dataset_a_catalog(\"'\"cat.2\"'\") > 4) THEN DO\n    SAY '**(cat)** Bad entry provided for second catalog name.'\n    SAY '**(cat)** 'cat.2\n    SAY '**(cat)** LISTCAT ENTRY Return code = 'sysreason\n    SAY '**(cat)** 'sysmsglvl1\n    SAY '**(cat)** 'sysmsglvl2\n    return_code = 16\n    return return_code\n  END\n  IF (cat.2 <> \"\") & ,\n     (is_dataset_a_catalog(\"'\"cat.2\"'\") = 0) THEN DO\n    mcatnew = cat.2\n  END\n  IF (mcattgt = \"\") THEN mcattgt = mcatold\n\n/*====================================================================*/\n/* Initialise the various totals variables */\n/*====================================================================*/\n  l_cnt   = 0                     /* Initialise output line count */\n  ali_tot = 0                     /* Total Aliases */\n  anv_tot = 0                     /* Total Aliases NONVSAM */\n  axx_tot = 0                     /* interim alias total */\n  avu_tot = 0                     /* Total Aliases VSAM UCAT */\n  gdg_tot = 0                     /* Total GDGs */\n  msc_tot = 0                     /* Total MISC datasets */\n  nvd_tot = 0                     /* Total NONVSAM datasets */\n  nvo_tot = 0                     /* Total NONVSAM (not SYS1) dsns */\n  nvv_tot = 0                     /* Total NONVSAM dsn volumes */\n  sy1_tot = 0                     /* Total NONVSAM SYS1 datasets */\n  uct_tot = 0                     /* Total Usercatalog imports */\n  ivd_tot = 0                     /* Total invalid devices */\n\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  flt = '**'                           /* Set the filter */\n  typ = ' '                            /* Set entry types required */\n  ct1 = ' '                            /* Set for 1 catalog only */\n  bcp = MVSVAR('sysmvs')\n  lev = SUBSTR(bcp,3,1)||SUBSTR(bcp,5,1)||SUBSTR(bcp,7,1)\n  IF (lev > 609) THEN DO            /* os/390 R10 and up for fullword*/\n    csioptns = SUBSTR('F',1,1)         /* 'F'for fullword */\n  END\n  ELSE DO\n    csioptns = SUBSTR(' ',1,1)         /* ' 'for halfword */\n  END\n  IF (process = 'RCNVTCAT') THEN DO\n    count.id = 0                       /* initialise count */\n    member = 'ALIAS'                   /* processing ALIAS */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    x = CSI_routine(cat.1,'**','X','Y') /* Call CSI */\n    Call WRITE_MEMBER                  /* write-out member */\n    member = 'NONVSAM'                 /* processing NONVSAM */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    x = CSI_routine(cat.1,'**','AH','Y') /* Call CSI */\n    Call WRITE_MEMBER                  /* write-out member */\n    member = 'SYS1'                    /* processing SYS1 */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    x = CSI_routine(cat.1,'SYS1.**','AH','Y') /* Call CSI */\n    Call WRITE_MEMBER                  /* write-out member */\n    member = 'IMPORT'                  /* processing IMPORT */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    x = CSI_routine(cat.1,'**','U','Y') /* Call CSI */\n    Call WRITE_MEMBER                  /* write-out member */\n    member = 'GDG'                     /* processing GDG */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    x = CSI_routine(cat.1,'**','B','Y') /* Call CSI */\n    Call WRITE_MEMBER                  /* write-out member */\n    member = 'MISC'                    /* processing MISC */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    x = CSI_routine(cat.1,'**','CGR','Y') /* Call CSI */\n    Call WRITE_MEMBER                  /* write-out member */\n    member = 'RECAT'                   /* processing RECAT (MISC+) */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    x = CSI_routine(cat.1,'**','CGR','Y') /* Call CSI */\n    Call WRITE_MEMBER                  /* write-out member */\n    member = '$REPORT'                 /* processing REPORT */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    Call build_statistics_report       /* generate report */\n    Call WRITE_REPORT                  /* write out report */\n    j.1  = \"//*\"\n    j.2  = \"//* Uncomment the control cards you want to process.\"\n    j.3  = \"//*\"\n    j.4  = \"//* The GDG base needs to be defined before entries.\"\n    j.5  = \"//* Import usercatalogs before defining ALIAS entries.\"\n    j.6  = \"//*\"\n    j.7  = \"//DEFINES EXEC PGM=IDCAMS\"\n    j.8  = \"//SYSIN     DD *\"\n    j.9  = \"  /* Generated:\" Date() Time() \"*/\"\n    j.10 = \"/*\"\n    j.11 = \"//*         DD DISP=SHR,DSN=\"rcnvtcat_defines_dsn\"(IMPORT)\"\n    j.12 = \"//*         DD DISP=SHR,DSN=\"rcnvtcat_defines_dsn\"(ALIAS)\"\n    j.13 = \"//*         DD DISP=SHR,DSN=\"rcnvtcat_defines_dsn\"(GDG)\"\n    j.14 = \"//*         DD DISP=SHR,DSN=\"rcnvtcat_defines_dsn\"(SYS1)\"\n    j.15 = \"//*         DD DISP=SHR,DSN=\"rcnvtcat_defines_dsn\"(NONVSAM)\"\n    j.16 = \"//SYSPRINT  DD SYSOUT=*\"\n    j.17 = \"//*\"\n    j.18 = \"//* End of job $JCL.\"\n    j.19 = \"//\"\n    j.0 = 19\n    Call WRITE_JCL                     /* write out JCL    */\n  END\n  ELSE DO                              /* Process as Catalog compare */\n    id = 'OLD'                         /* specify for 'old' catalog */\n    count.id = 0                       /* initialise count */\n    cat.old = cat.1                    /* retain catalog name */\n    x = CSI_routine(cat.1,flt,' ','Y') /* Call CSI procedure */\n    id = 'NEW'                         /* specify for 'NEW' catalog */\n    count.id = 0                       /* initialise count */\n    cat.new = cat.2                    /* retain catalog name */\n    x = CSI_routine(cat.2,flt,' ','Y') /* Call CSI procedure */\n    member = 'COMPFULL'                /* processing FULL comparison */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    Call COMP_REPORT                   /* Build the report */\n    Call WRITE_MEMBER                  /* write the member */\n    member = 'COMPSHRT'                /* processing SHORT comparison */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    Call COMP_REPORT                   /* Build the report */\n    Call WRITE_MEMBER                  /* write the member */\n    member = 'EXTRA'                   /* processing EXTRA member */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    Call NEW_EXT                       /* Build the report */\n    Call WRITE_MEMBER                  /* write the member */\n    member = 'CHANGED'                 /* processing CHANGED member */\n    IF (env_flag = \"FORE\") & (ispf_flag = \"ISPF\") THEN DO\n      ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n      message = \"Processing\" member \"entries\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    END\n    Call OLD_BAD                       /* Build the report */\n    Call WRITE_MEMBER                  /* write the member */\n    Call build_statistics_report       /* generate report */\n    Call WRITE_report                  /* write the report */\n    j.1  = \"//*\"\n    j.2  = \"//* Uncomment the control cards you want to process.\"\n    j.3  = \"//*\"\n    j.4  = \"//DEFINES EXEC PGM=IDCAMS\"\n    j.5  = \"//SYSIN     DD *\"\n    j.6  = \"  /* Generated:\" Date() Time() \"*/\"\n    j.7  = \"/*\"\n    j.8  = \"//*         DD DISP=SHR,DSN=\"rcnvtcat_defines_dsn\"(CHANGED)\"\n    j.9  = \"//SYSPRINT  DD SYSOUT=*\"\n    j.10 = \"//*\"\n    j.11 = \"//* End of job $JCL.\"\n    j.12 = \"//\"\n    j.0 = 12\n    Call WRITE_JCL                     /* write out JCL    */\n  END\n/*====================================================================*/\n/* Display output IF foreground ISPF */\n/*====================================================================*/\n  IF (env_flag = 'FORE') &,\n     (ispf_flag = 'ISPF') THEN DO\n    ADDRESS ISPEXEC \"VIEW DATASET('\"rcnvtcat_defines_dsn\"($REPORT)')\"\n  END\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  IF (libdef_plib = 1) THEN DO\n    ADDRESS ISPEXEC \"LIBDEF ISPPLIB DATASET\"\n  END\n  return 0\n\n/*====================================================================*/\n/* Use LISTALC ST to discover allocated DDNAMEs and their data sets.  */\n/*====================================================================*/\nget_listalc:\n  rc = Outtrap(\"ln.\")                 /* open trap                  */\n  \"LISTALC STATUS\"\n  rc = Outtrap(\"OFF\")                 /* close trap                 */\n  dd_names = 0\n  dd_nnbr. = 0\n  DO trapx = 2 to ln.0                  /* skip heading         */\n    ln.trapx = space(ln.trapx)\n    PARSE VAR ln.trapx tempname tempddnm\n    SELECT\n      WHEN (tempddnm <> \" \") THEN DO\n        PARSE VAR ln.trapx fullname tiotddnm\n        dd_names = dd_names + 1       /* DDName index         */\n        dd_name.dd_names = tiotddnm\n        dd_nnbr.tiotddnm = dd_names\n        dsname.dd_names.0 = 0\n        ds_temp = dsname.dd_names.0 + 1\n        dsname.dd_names.0 = ds_temp\n        dsname.dd_names.ds_temp = fullname\n      END\n      WHEN ((left(ln.trapx,3) <> \" \") &,\n            (Words(ln.trapx) = 1)) THEN DO\n        PARSE VAR ln.trapx fullname .\n        trapx = trapx + 1\n        ln.trapx = space(ln.trapx)\n        PARSE VAR ln.trapx tempddnm \" \" final_disp \" \" .\n        IF ((tempddnm <> \" \") &,\n            (final_disp <> \" \")) THEN DO\n          tiotddnm = tempddnm\n          dd_names = dd_names + 1   /* DDName index         */\n          dd_name.dd_names = tiotddnm\n          dd_nnbr.tiotddnm = dd_names\n          dsname.dd_names.0 = 0\n        END\n        ds_temp = dsname.dd_names.0 + 1\n        dsname.dd_names.0 = ds_temp\n        dsname.dd_names.ds_temp = fullname\n      END\n      Otherwise DO\n        SAY \"*ERR*\" ln.trapx\n      END\n    END\n  END                                 /* trapx                      */\n  return dd_names\n\n/*====================================================================*/\n/* ddname_allocated_check - Discover DSNAME of DDNAME.                */\n/*====================================================================*/\nddname_allocated_check:\n  PARSE arg match_dd\n  match_dsn = \"UNDEFINED\"\n  dd# = dd_nnbr.match_dd\n  IF (dd# > 0) THEN DO\n    dn= dd_name.dd#\n    nd = dsname.dd#.0\n    match_dsn = \"\"\n    DO ds# = 1 to nd\n      IF (nd > 1) THEN DO\n        match_dsn = match_dsn\"\"dsname.dd#.ds#\";\"\n      END\n      ELSE DO\n        match_dsn = dsname.dd#.ds#\n      END\n    END\n  END\n  return match_dsn\n\n/*====================================================================*/\n/* Show report text WHEN no DEFINES pds exists.                       */\n/*====================================================================*/\nshow_report_text:\n  DO rx = 1 to r_cnt\n    SAY r_text.rx\n  END\n  return 0\n\n/*====================================================================*/\n/* ISPF is available so enable ISPPLIB and give a better user interfce*/\n/*====================================================================*/\nispf_enable:\n  IF (source_hostdsn = \"?\") THEN DO\n    function_rc = find_hostdsn()\n  END\n  listdsi_rc = Listdsi(\"'\"source_hostdsn\"'\")\n  vdef_volser = SYSVOLUME\n  vdef_unit = SYSUNIT\n  libdef_plib = 0\n  ADDRESS ISPEXEC \"LIBDEF ISPPLIB DATASET\",\n    \"ID('\"source_hostdsn\"') STACK\"\n  libdef_rc = RC\n  IF (libdef_rc <> 0) THEN DO\n    ZERRLM = \"LIBDEF of ISPPLIB failed, rc=\"libdef_rc\n    msg_rc = 1\n    return_code = libdef_rc\n  END\n  libdef_plib = 1\n  return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Search a DD to find where this code runs from.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nfind_hostdsn:\n  Address ISPEXEC ,\n    \"QBASELIB\" source_hostdd \"ID(DSNLIST)\"\n  ISPEXEC_rc = RC\n  If (ISPEXEC_rc <> 0) Then Do\n    msg_rc = 1\n    ZERRLM = \"QBASELIB Failed, RC(\"ISPEXEC_rc\")\"\n    Return 4\n  End\n  dsnlist_temp = dsnlist\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  Do While dsnlist_temp <> \"\"\n    Parse Var dsnlist_temp one_dsn \",\" dsnlist_temp\n    one_dsn = Strip(one_dsn,\"B\",\"'\")\n    sysdsn_rc = SysDsn(\"'\"one_dsn\"(\"source_uc_exec_name\")'\")\n    If (sysdsn_rc = \"OK\") Then Do\n      source_hostdsn = STRIP(one_dsn,\"B\",\" \")\n      Leave\n    End\n  End\n  msg_rc = Msg(msg_state)\n  @trap_rc = TRAPMSG(@trap_state)\n  Return 0\n\n/*====================================================================*/\n/* No mcat provided, prompt with a panel.                      */\n/*====================================================================*/\nprompt_for_mcat:\n  outtrap_rc = OUTTRAP(cat_out.)\n  ADDRESS TSO \"LISTCAT ENTRY('\"SYSVAR(\"SYSUID\")\"')\"\n  outtrap_rc = OUTTRAP(\"OFF\")\n  DO ox = 1 to cat_out.0\n    IF (POS(\"IN-CAT --- \",cat_out.ox) > 0) THEN DO\n      PARSE VAR cat_out.ox . \"IN-CAT --- \" mcatold\n      mcatold = STRIP(mcatold,\"B\",\" \")\n      Leave\n    END\n  END\n  IF (mcattgt = '') THEN mcattgt = mcatold\n  mcatdef = rcnvtcat_defines_dsn\n  message = \"Enter command CANCEL to abort processing.\"\n  redisplay = 1\n  DO while redisplay = 1\n    ADDRESS ISPEXEC \"DISPLAY PANEL(TCNVTCAP)\"\n    SELECT\n      WHEN (translate(zcmd) = \"CANCEL\") THEN DO\n        redisplay = 0\n      END\n      otherwise DO\n        redisplay = 0\n        cat.1 = mcatold\n        argnum = 1\n        IF (mcatnew <> \"\") THEN DO\n          argnum = argnum + 1\n          cat.2 = mcatnew\n        END\n      END\n    END\n  END\n  IF (argnum = 1) THEN process = 'RCNVTCAT'\n  else process = 'CATCOMP'\n  return argnum\n\n/*====================================================================*/\n/* WRITE_JCL - Write out the generated lines to JCL.                  */\n/*====================================================================*/\nWRITE_JCL:\n  IF (TSO_flag = 'TSO') THEN DO\n   ADDRESS TSO \"Alloc Fi(JCL)\" ,\n    \"Da('\"rcnvtcat_defines_dsn\"($JCL)') Shr Reuse\"\n   alloc_rc = RC\n   IF (alloc_rc <> 0) THEN DO\n     SAY \"Write_JCL TSO ALLOC, RC(\"alloc_rc\").\"\n   END\n  END\n  ADDRESS MVS \"ExecIO \"j.0\" DiskW JCL (Stem j. FINIS)\"\n  ADDRESS TSO \"Free Fi(JCL)\"\n  Return\n\n/*====================================================================*/\n/* WRITE_REPORT - Write out the generated lines to REPORT.            */\n/*====================================================================*/\nWRITE_REPORT:\n  IF (r.0 = 0) THEN DO               /* IF no output */\n    r_cnt = 1                          /* write a no output line */\n    l.r_cnt = ' /* no data produced */'\n  END\n  IF (TSO_flag = 'TSO') THEN DO\n   ADDRESS TSO \"Alloc Fi(REPORT)\" ,\n    \"Da('\"rcnvtcat_defines_dsn\"($REPORT)') Shr Reuse\"\n   alloc_rc = RC\n   IF (alloc_rc <> 0) THEN DO\n     SAY \"Write_REPORT TSO ALLOC, RC(\"alloc_rc\").\"\n   END\n  END\n  ADDRESS MVS \"ExecIO \"r.0\" DiskW REPORT (Stem r. FINIS)\"\n  ADDRESS TSO \"Free Fi(REPORT)\"\n  Return\n\n/*====================================================================*/\n/* WRITE_MEMBER - Write out the generated lines to member.            */\n/*====================================================================*/\nWRITE_MEMBER:\n  IF (l_cnt = 0) THEN DO               /* IF no output */\n    l_cnt = l_cnt + 1                  /* write a no output line */\n    l.l_cnt = ' /* no data produced */'\n  END\n  ADDRESS TSO \"Alloc Fi(\"member\")\" ,\n    \"Da('\"rcnvtcat_defines_dsn\"(\"member\")') Shr Reuse\"\n  alloc_rc = RC\n  IF (alloc_rc <> 0) THEN DO\n    SAY \"Write_Member TSO ALLOC, RC(\"alloc_rc\") on\" member\".\"\n    return 4\n  END\n  c_cnt = 1                          /*  add a line */\n  c.c_cnt = ' /*' member '*/'          /*  add member name */\n  ADDRESS MVS \"ExecIO \"c_cnt\" DiskW\" member \"(Stem c.)\"\n  ADDRESS MVS \"ExecIO \"l_cnt\" DiskW\" member \"(Stem l. FINIS)\"\n  ADDRESS TSO \"Free Fi(\"member\")\"\n  l_cnt = 0                            /* re-init line count for next */\n  Return\n\n/*====================================================================*/\n/* CSI Processing section */\n/*====================================================================*/\n/*====================================================================\n  Execute the Catalog Search Interface\n======================================================================*/\nCSI_routine:\n  Arg cat,flt,typ,ct1\n  modrsnrc = SUBSTR(' ',1,4)           /* clear module/return/reason */\n  csifiltk = SUBSTR(flt,1,44)          /* move filter key into list */\n  csicatnm = SUBSTR(cat,1,44)          /* clear catalog name */\n  csiresnm = SUBSTR(' ',1,44)          /* clear resume name */\n  csidtyps = SUBSTR(typ,1,16)          /* clear entry types */\n  csicldi  = SUBSTR('Y',1,1)           /* indicate data and index */\n  csiresum = SUBSTR(' ',1,1)           /* clear resume flag */\n  csis1cat = SUBSTR(ct1,1,1)           /* indicate search > 1 catalogs */\n/*====================================================================*/\n/* Initialize requested fields */\n/*====================================================================*/\n  csinumen = '000D'X                   /* init number of fields = 13 */\n  csifld01 = Left('ENTYPE  ',8)        /* type of entry */\n  csifld02 = Left('ENTNAME ',8)        /* name of entry */\n  csifld03 = Left('TYPE    ',8)        /* type of associated entry */\n  csifld04 = Left('NAME    ',8)        /* name of associated entry */\n  csifld05 = Left('GDGLIMIT',8)        /* GDG Limit */\n  csifld06 = Left('GDGATTR ',8)        /* GDG Attributes */\n  csifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date */\n  csifld08 = Left('ATTR1   ',8)        /* Attributes */\n  csifld09 = Left('CATTR   ',8)        /* Attributes page and swap */\n  csifld10 = Left('DEVTYP  ',8)        /* UCB Device type */\n  csifld11 = Left('VOLSER  ',8)        /* Volume serial number */\n  csifld12 = Left('FILESEQ ',8)        /* File Sequence number */\n  csifld13 = Left('VSAMTYPE',8)        /* VSAM dataset information */\n/*====================================================================*/\n/* Build the selection criteria fields part of parameter list */\n/*====================================================================*/\n  csiopts  = csicldi ||csiresum||csis1cat||csioptns\n  csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\n  csifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\n  csifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10\n  csifield = csifield||csifld11||csifld12||csifld13||csifld14\n/* Initialise and build work are output part of parameter list */\n  csiusrln = 1048575                   /* CSIUSRLN work area length */\n                                     /* range from 1024 to 1048575 */\n                                     /* was 524288 before 1.81     */\n  dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/* Change csiresum for subsequent invocations. */\n  csiresum = 'Y'\n/* Set up loop for resume (if a resume is necessary). */\n/* Issue link to CSI - Catalog Search Interface */\n  Do While csiresum = 'Y'\n    ADDRESS LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n    r15 = rc                         /* get returned code */\n    mod = SUBSTR(modrsnrc,1,2)       /* get module code */\n    res = C2d(SUBSTR(modrsnrc,3,1))  /* get return code */\n    ret = C2d(SUBSTR(modrsnrc,4,1))  /* get reason code */\n    IF (r15 > 0) THEN DO             /* WHEN error occured */\n      SAY '**(Error-1)* CSI processing.'\n      SAY '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n      Leave\n    END\n/*====================================================================*/\n    csiresum = SUBSTR(csifield,150,1) /* Get resume flag for next loop */\n    csiresnm = SUBSTR(csifield,89,44) /* Get resume name for next loop */\n    csiusrln = C2D(SUBSTR(dwork,1,4)) /* Get length of work area */\n    csireqln = C2D(SUBSTR(dwork,5,4)) /* Get length of work area reqd */\n    csiusdln = C2D(SUBSTR(dwork,9,4)) /* Get length of work area used */\n    IF (csireqln > csiusrln) THEN DO\n      SAY '**(Error-1)* Work Area defined  = 'csiusrln\n      SAY '**(Error-2)* Work Area used     = 'csiusdln\n      SAY '**(Error-3)* Work Area required = 'csireqln\n      SAY '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n    END\n    IF (csiusdln < 65) THEN Leave    /* No entries returned */\n    off = 15                         /* Starting position */\n/*====================================================================*/\n/*   Process data returned in work area */\n/*====================================================================*/\n    DO While off < csiusdln          /* DO until all data is processed*/\n      csi_flag = SUBSTR(dwork,off,1) /* get the flag byte */\n      csi_type = SUBSTR(dwork,off+1,1) /* get the entry type */\n      csi_name = SUBSTR(dwork,off+2,44) /* get the entry name */\n      csi_retn = SUBSTR(dwork,off+46,4) /* get the return code */\n      mod = SUBSTR(csi_retn,1,2)     /* get CSI module */\n      res = C2d(SUBSTR(csi_retn,3,1)) /* get reason code */\n      ret = C2d(SUBSTR(csi_retn,4,1)) /* get return code */\n      IF (csi_type = '0') THEN DO    /* Catalog entry */\n        IF (ret > 0) THEN DO         /* test catalog return code */\n          SAY '**(Error-1)* Catalog processing - 'STRIP(csi_name,B)'.'\n          SAY '**(Error-2)* Module='mod' Return='ret' Reason='res\n        END\n        csicname = csi_name          /* set the catalog name */\n        plus = 50                    /* length for catalog entry */\n      END\n      ELSE DO\n        csiename = csi_name          /* use the entry name */\n        csietype = csi_type          /* use the entry name */\n        csieflag = X2b(C2x(csi_flag)) /* use the entry flag */\n        csienter = SUBSTR(csieflag,2,1) /* get the entry error flag */\n        csiedata = SUBSTR(csieflag,3,1) /* get the data indication flag */\n        SELECT\n          WHEN (csienter = '1') THEN DO\n            SAY '**(Error-1)* Entry processing - 'STRIP(csi_name,B)'.'\n            SAY '**(Error-2)* Module='mod' Return='ret' Reason='res\n            plus = 50                 /* length for error entry */\n          END\n          WHEN (csiedata = '0') THEN DO\n            SAY '**(Error-1)* Entry processing - 'STRIP(csi_name,B)'.'\n            SAY '**(Error-2)* No data returned'\n            SAY '**(Error-3)* Module='mod' Return='ret' Reason='res\n            plus = 50                 /* length for error entry */\n          END\n          Otherwise DO\n            IF (csioptns = 'F') THEN  /* check IF fullword requested */\n              csitotln = C2d(SUBSTR(csi_retn,1,4))/* get entry total length */\n            Else                      /* otherwise (default halfword) */\n              csitotln = C2d(SUBSTR(csi_retn,1,2))/* get entry total length */\n            Call ENTRY                /* Execute entry processing */\n            plus = 46 + csitotln      /* length for normal entry */\n          END\n        END\n       END\n       Call DATA_HANDLING\n       off = off + plus            /* build new offset for next entry */\n    END\n  END\n  Return 0\n\n/*====================================================================*/\n/* Get offsets and lengths of next field */\n/*====================================================================*/\nget_next_field:\n  IF (csioptns = 'F') THEN DO          /* check IF fullword requested */\n    e_off = off + 46                   /* get offset to entries */\n    o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset */\n    l_fld.1 = C2d(SUBSTR(dwork,e_off+8,4)) /* get first field length */\n    e_pos = 12                         /* set offset of second field */\n    DO flds = 2 to C2d(csinumen)       /* loop through other fields */\n     prv = flds - 1                    /* set 'previous' value */\n     o_fld.flds = o_fld.prv + l_fld.prv/* get next offset */\n     l_fld.flds = C2d(SUBSTR(dwork,e_off+e_pos,4)) /* get next length */\n     e_pos = e_pos + 4\n    END\n  END\n  ELSE DO                              /* otherwise (default halfword) */\n    e_off = off + 46                   /* get offset to entries */\n    o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset */\n    l_fld.1 = C2d(SUBSTR(dwork,e_off+4,2)) /* get first field length */\n    e_pos = 6                          /* set offset of second field */\n    DO flds = 2 to C2d(csinumen)       /* loop through other fields */\n     prv = flds - 1                    /* set 'previous' value */\n     o_fld.flds = o_fld.prv + l_fld.prv/* get next offset */\n     l_fld.flds = C2d(SUBSTR(dwork,e_off+e_pos,2)) /* get next length */\n     e_pos = e_pos + 2\n    END\n  END\n  return 0\n\n/*====================================================================*/\n/* Process entry fields to extract data */\n/*====================================================================*/\nENTRY:                               /* Start entry processing      ##*/\n  IF (csioptns = 'F') THEN DO          /* check IF fullword requested */\n    e_off = off + 46                   /* get offset to entries */\n    o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset */\n    l_fld.1 = C2d(SUBSTR(dwork,e_off+8,4)) /* get first field length */\n    e_pos = 12                         /* set offset of second field */\n    DO flds = 2 to C2d(csinumen)       /* loop through other fields */\n     prv = flds - 1                    /* set 'previous' value */\n     o_fld.flds = o_fld.prv + l_fld.prv/* get next offset */\n     l_fld.flds = C2d(SUBSTR(dwork,e_off+e_pos,4)) /* get next length */\n     e_pos = e_pos + 4\n    END\n  END\n  ELSE DO                              /* otherwise (default halfword) */\n    e_off = off + 46                   /* get offset to entries */\n    o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset */\n    l_fld.1 = C2d(SUBSTR(dwork,e_off+4,2)) /* get first field length */\n    e_pos = 6                          /* set offset of second field */\n    DO flds = 2 to C2d(csinumen)       /* loop through other fields */\n     prv = flds - 1                    /* set 'previous' value */\n     o_fld.flds = o_fld.prv + l_fld.prv/* get next offset */\n     l_fld.flds = C2d(SUBSTR(dwork,e_off+e_pos,2)) /* get next length */\n     e_pos = e_pos + 2\n    END\n  END\n  entype   = SUBSTR(dwork,o_fld.1,l_fld.1)   /* Type of entry */\n  entname  = SUBSTR(dwork,o_fld.2,l_fld.2)   /* Name of entry */\n  type     = SUBSTR(dwork,o_fld.3,l_fld.3)   /* Type of assc entry */\n  name     = SUBSTR(dwork,o_fld.4,l_fld.4)   /* Name of assc entry */\n  gdglimit = SUBSTR(dwork,o_fld.5,l_fld.5)   /* GDG limit */\n  gdgattr  = SUBSTR(dwork,o_fld.6,l_fld.6)   /* GDG attributes */\n  dscrdt2  = SUBSTR(dwork,o_fld.7,l_fld.7)   /* dataset creation date */\n  attr1    = SUBSTR(dwork,o_fld.8,l_fld.8)   /* attributes */\n  cattr    = SUBSTR(dwork,o_fld.9,l_fld.9)   /* attribs page and swap */\n  devtyp   = SUBSTR(dwork,o_fld.10,l_fld.10) /* device type */\n  volser   = SUBSTR(dwork,o_fld.11,l_fld.11) /* volume serial */\n  fileseq  = SUBSTR(dwork,o_fld.12,l_fld.12) /* file sequence */\n  vsamtype = SUBSTR(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/\n  vsam_attr = ''                           /* initialise vsam attributes*/\n  IF (Index(csifield,'ENTYPE') > 0) THEN Call FLD_ENTYPE\n  IF (Index(csifield,'ENTNAME') > 0) THEN Call FLD_ENTNAME\n  IF (Index(csifield,'GDGLIMIT') > 0) THEN Call FLD_GDGLIMIT\n  IF (Index(csifield,'GDGATTR') > 0) THEN Call FLD_GDGATTR\n  IF (Index(csifield,'DSCRDT2') > 0) THEN Call FLD_DSCRDT2\n  IF (Index(csifield,'ATTR1') > 0) THEN Call FLD_ATTR1\n  IF (Index(csifield,'CATTR') > 0) THEN Call FLD_CATTR\n  IF (Index(csifield,'DEVTYP') > 0) THEN Call FLD_DEVTYP\n  IF (Index(csifield,'VOLSER') > 0) THEN Call FLD_VOLSER\n  IF (Index(csifield,'FILESEQ') > 0) THEN Call FLD_FILESEQ\n  IF (Index(csifield,'VSAMTYPE') > 0) THEN Call FLD_VSAMTYPE\n  Return\n\n/*====================================================================*/\n/* FLD_ENTYPE   - Process ENTYPE   field */\n/*====================================================================*/\nFLD_ENTYPE:\n  SELECT                               /* decode type flag */\n    WHEN (entype = 'C') THEN entype = 'CLUSTER'\n    WHEN (entype = 'D') THEN entype = 'DATA'\n    WHEN (entype = 'I') THEN entype = 'INDEX'\n    WHEN (entype = 'A') THEN entype = 'NONVSAM'\n    WHEN (entype = 'H') THEN entype = 'GDS'\n    WHEN (entype = 'B') THEN entype = 'GDG'\n    WHEN (entype = 'R') THEN entype = 'PATH'\n    WHEN (entype = 'G') THEN entype = 'AIX'\n    WHEN (entype = 'X') THEN entype = 'ALIAS'\n    WHEN (entype = 'U') THEN entype = 'UCAT'\n    Otherwise DO\n      SAY '**(Error-1)* Entry type processing for 'STRIP(entname,T)\n      SAY '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'\n      entype = ' '                       /* unknown type */\n    END\n  END\n  Return\n\n/*====================================================================*/\n/* FLD_ENTNAME  - Process ENTNAME  field */\n/*====================================================================*/\nFLD_ENTNAME:\n  IF (SUBSTR(entname,1,2) = '0000'x) THEN DO /* IF null dsname */\n    entname = Left(C2x(entname),44)     /* Return hex value */\n  END\n  Return\n\n/*====================================================================*/\n/* FLD_GDGLIMIT - Process GDGLIMIT field */\n/*====================================================================*/\nFLD_GDGLIMIT:\n  gdglimit = X2d(C2x(gdglimit))  /* return decimal number */\n  Return\n\n/*====================================================================*/\n/* FLD_GDGATTR  - Process GDGATTR  field */\n/*====================================================================*/\nFLD_GDGATTR:\n  gdgattr = X2b(C2x(gdgattr))\n  IF (SUBSTR(gdgattr,1,1) = '1') THEN DO\n    gdg_emp = 'EMPTY'\n  END\n  ELSE DO\n    gdg_emp = 'NOEMPTY'\n  END\n  IF (SUBSTR(gdgattr,2,1) = '1') THEN DO\n    gdg_scr = 'SCRATCH'\n  END\n  ELSE DO\n    gdg_scr = 'NOSCRATCH'\n  END\n  Return\n\n/*====================================================================*/\n/* FLD_DSCRDT2  - Process DSCRDT2  field */\n/*====================================================================*/\nFLD_DSCRDT2:\n  IF (SUBSTR(dscrdt2,1,2) <> 'FFFF'X) THEN DO\n    yyddd = C2x(SUBSTR(dscrdt2,1,3))\n    yy    = SUBSTR(yyddd,1,2)\n    ddd   = SUBSTR(yyddd,3,3)\n    cent  = C2x(SUBSTR(dscrdt2,4,1))\n    IF (cent = '00') THEN DO\n      yyyy    = yy + 1900\n    END\n    ELSE DO\n      yyyy    = yy + 2000\n    END\n    IF (yyyy = '1900') THEN DO         /* correct for '00' */\n      yyyy = '2000'\n    END\n    savcrdt2 = dscrdt2\n    dscrdt2 = yyyy'.'ddd\n  END\n  Return\n\n/*====================================================================*/\n/* FLD_ATTR1    - Process ATTR1    field */\n/*====================================================================*/\nFLD_ATTR1:\n  attr1 = X2b(c2x(attr1))\n  IF (SUBSTR(attr1,1,1) = '1') THEN DO\n    vsam_attr = vsam_attr' SPEED'\n  END\n  IF (SUBSTR(attr1,3,1) = '1') THEN DO\n    vsam_attr = vsam_attr' REUSE'\n  END\n  IF (SUBSTR(attr1,4,1) = '1') THEN DO\n    vsam_attr = vsam_attr' ERASE'\n  END\n  Return\n\n/*====================================================================*/\n/* FLD_CATTR    - Process CATTR    field */\n/*====================================================================*/\nFLD_CATTR:\n  cattr = X2b(C2x(cattr))\n  IF (entype = 'CLUSTER') THEN DO\n    IF (SUBSTR(cattr,8,1) = '1') THEN DO\n      entype = 'PAGESPACE'\n    END\n    IF (SUBSTR(cattr,7,1) = '1') THEN DO\n      pageswap = 'SWAP'\n    END\n    ELSE DO\n      pageswap = 'NOSWAP'\n    END\n  END\n  Return\n\n/*====================================================================*/\n/* FLD_DEVTYP   - Process DEVTYP   field to translate data */\n/*====================================================================*/\nFLD_DEVTYP:\n  devices = ''                         /* initialise devices */\n  DO d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field */\n    device = SUBSTR(devtyp,d_pos,4)  /* get device (UCB) */\n    d_model = SUBSTR(device,1,1)     /* get model byte */\n    d_option = SUBSTR(device,2,1)    /* get option byte */\n    d_class = SUBSTR(device,3,1)     /* get class byte */\n    d_device = SUBSTR(device,4,1)    /* get device byte */\n    SELECT\n      WHEN (d_class = '80'x) THEN DO\n        dev_class = 'TAPE'            /* Tape device */\n        SELECT\n          WHEN (d_device = '03'x) THEN dev_type = '3400' /* 3400/3420-3/5/7*/\n          WHEN (d_device = '04'x) THEN dev_type = '3420' /* 3420-4/6/8 */\n          WHEN (d_device = '05'x) THEN dev_type = '3410'\n          WHEN (d_device = '06'x) THEN dev_type = '8809'\n          WHEN (d_device = '07'x) THEN dev_type = '3430'\n          WHEN (d_device = '08'x) THEN dev_type = '7340'\n          WHEN (d_device = '09'x) THEN dev_type = '9374'\n          WHEN (d_device = '80'x) THEN dev_type = '3480'\n          WHEN (d_device = '81'x) THEN dev_type = '3490'\n          WHEN (d_device = '83'x) THEN dev_type = '3590'\n          WHEN (device = '00000000'x) THEN dev_type = '0000'\n          Otherwise DO\n            dev_type = C2x(device)   /* show UCB IF unknown */\n            SAY '**(Error-1)* Device type processing for 'STRIP(entname,T)\n            SAY '**(Error-2)* Device type = 'dev_type\n          END\n        END\n      END\n      WHEN (d_class = '20'x) THEN DO\n        dev_class = 'DASD'            /* DASD device */\n        SELECT\n          WHEN (d_device = '04'x) THEN dev_type = '9345'\n          WHEN (d_device = '09'x) THEN dev_type = '3330'\n          WHEN (d_device = '0A'x) THEN dev_type = '3340'\n          WHEN (d_device = '0B'x) THEN dev_type = '3350'\n          WHEN (d_device = '0C'x) THEN dev_type = '3375'\n          WHEN (d_device = '0D'x) THEN dev_type = '3330' /* 3330-11 */\n          WHEN (d_device = '0E'x) THEN dev_type = '3380'\n          WHEN (d_device = '0F'x) THEN dev_type = '3390'\n          WHEN (device = '00000000'x) THEN dev_type = '0000'\n          Otherwise DO\n            dev_type = C2x(device)    /* show UCB IF unknown */\n            SAY '**(Error-1)* Device type processing for 'STRIP(entname,T)\n            SAY '**(Error-2)* Device type = 'dev_type\n          END\n        END\n      END\n      Otherwise DO\n        dev_class = 'UNKN'            /* Unknown device */\n        SELECT\n          WHEN (device = '00000000'x) THEN dev_type = '0000'\n          Otherwise DO\n            dev_type = C2x(device)      /* show UCB IF unknown */\n            SAY '**(Error-1)* Device type processing for 'STRIP(entname,T)\n            SAY '**(Error-2)* Device type = 'dev_type\n          END\n        END\n      END\n    END\n    devices = devices||' '||Left(dev_type,8) /* build device list */\n  END\n  devices = STRIP(devices,B,' ')       /* clean up device list */\n  Return\n\n/*====================================================================*/\n/* FLD_VOLSER   - Process VOLSER   field */\n/*====================================================================*/\nFLD_VOLSER:\n  volsers = ''\n  DO v_pos = 1 To Length(volser) By 6\n    volume = SUBSTR(volser,v_pos,6)\n    IF (SUBSTR(volume,1,2) = '00'x) THEN DO\n      volume = '000000'\n    END\n    volume = Right(STRIP(volume,B),6)' '\n    volsers = volsers||'  '||volume\n  END\n  volser = STRIP(volsers,B)\n  Return\n\n/*====================================================================*/\n/* FLD_FILESEQ  - Process FILESEQ  field */\n/*====================================================================*/\nFLD_FILESEQ:\n  build = ''\n  DO f_pos = 1 To Length(fileseq) By 2\n    build = build||Right(X2d(C2x(SUBSTR(fileseq,f_pos,2))),8)||' '\n  END\n  fileseq = build\n  Return\n\n/*====================================================================*/\n/* FLD_VSAMTYPE - Process VSAMTYPE field */\n/*====================================================================*/\nFLD_VSAMTYPE:\n  vsam_byte1 = X2b(C2x(SUBSTR(vsamtype,1,1))) /* get byte 1 */\n  vsam_byte2 = X2b(C2x(SUBSTR(vsamtype,2,1))) /* get byte 2 */\n  SELECT\n    WHEN (SUBSTR(vsam_byte1,1,1) = '1') THEN DO\n      vsam_type = 'KSDS'\n      vsam_attr = vsam_attr' INDEXED'\n    END\n    WHEN (SUBSTR(vsam_byte1,7,1) = '1') THEN DO\n      vsam_type = 'RRDS'\n      vsam_attr = vsam_attr' NUMBERED'\n    END\n    WHEN (SUBSTR(vsam_byte2,6,1) = '1') THEN DO\n      vsam_type = 'LDS'\n      vsam_attr = vsam_attr' LINEAR'\n    END\n    WHEN (SUBSTR(vsam_byte2,8,1) = '1') THEN DO\n      vsam_type = 'VRRDS'\n      vsam_attr = vsam_attr' NUMBERED'\n    END\n    Otherwise DO\n      vsam_type = 'ESDS'\n      IF (entype <> 'INDEX') THEN DO\n        vsam_attr = vsam_attr' NONINDEXED'\n      END\n    END\n  END\n  IF (SUBSTR(vsam_byte1,2,1) = '1') THEN DO\n    vsam_attr = vsam_attr' WRITECHECK'\n  END\n  IF (SUBSTR(vsam_byte1,3,1) = '1') THEN DO\n    vsam_attr = vsam_attr' IMBED'\n  END\n  IF (SUBSTR(vsam_byte1,4,1) = '1') THEN DO\n    vsam_attr = vsam_attr' REPLICATE'\n  END\n  IF (entype <> 'INDEX') THEN DO\n    IF (SUBSTR(vsam_byte1,8,1) = '1') THEN DO\n      vsam_attr = vsam_attr' SPANNED'\n    END\n  END\n  IF (SUBSTR(vsam_byte2,2,1) = '1') THEN DO /* undocumented VVDS indicator */\n    vsam_vvds = 'Y'                     /* Set VVDS flag */\n  END\n  ELSE DO\n    vsam_vvds = 'N'                     /* Set VVDS flag off */\n  END\n  vsam_attr = STRIP(vsam_attr,B)\n  Return\n\n/*====================================================================*/\n/* DO a LISCAT ENTRY to ensure the dsn is a catalog. */\n/*====================================================================*/\nis_dataset_a_catalog: Procedure Expose sysreason sysmsglvl1 sysmsglvl2\n  PARSE arg indsn\n  sysreason=0\n  sysmsglvl1=' Not Emulated '\n  sysmsglvl2=' Not Emulated '\n  IF indsn = '' THEN DO\n    sysreason=29\n    return 16\n  END\n  ignore_listcat. = \"\"\n  ignore_listcat.0 = 0\n  Call OutTrap \"ignore_listcat.\"\n  ADDRESS TSO \"LISTCAT ENT(\"indsn\")\"\n  lrc=rc\n  sysreason=rc\n  hexrc=right(d2x(rc),8,\"0\")\n  Call outtrap \"OFF\"\n  drop ignore_listcat.\n  IF \"0438\" = left(hexrc,4) THEN DO\n    sysreason=24\n    Return 16\n  END\n  return lrc\n\n/*====================================================================*/\n/* DATA_HANDLING - Carry out whatever processing is required ... */\n/*====================================================================*/\nDATA_HANDLING:\n  IF (csi_type <> '0') THEN DO         /* Catalog entries */\n    IF (process = 'CATCOMP') THEN DO /* Catalog compare code */\n      count.id         = count.id+1  /* increment count */\n      val              = count.id    /* save value */\n      entname.id.val   = entname     /* store entry name */\n      entype.id.val    = entype      /* store entry type */\n      name.id.val      = name        /* store assoc name */\n      type.id.val      = type        /* store assoc type */\n      pageswap.id.val  = pageswap    /* store pageswap */\n      devices.id.val   = devices     /* store devices */\n      fils.id.val      = fils        /* store fils */\n      gdg_emp.id.val   = gdg_emp     /* store gdg_emp */\n      gdg_scr.id.val   = gdg_scr     /* store gdg_scr */\n      gdglimit.id.val  = gdglimit    /* store gdglimit */\n      vsam_attr.id.val = vsam_attr   /* store vsam_attr */\n      vsam_type.id.val = vsam_type   /* store vsam_attr */\n      vsam_vvds.id.val = vsam_vvds   /* store vsam_vvds */\n      volsers.id.val   = volsers     /* store volsers by value */\n      volsers.id.entname = volsers   /* store volsers by entry name */\n      name.id.entname  = name        /* store name by entry name */\n      val.id.entname   = val         /* store value by entry name */\n    END                               /** END Catalog compare code    **/\n    ELSE DO\n      SELECT\n        WHEN (member = 'MISC') THEN Call MEM_MISC\n        WHEN (member = 'RECAT') THEN Call MEM_RECAT\n        WHEN (member = 'ALIAS') THEN Call MEM_ALIAS\n        WHEN (member = 'GDG') THEN Call MEM_GDG\n        WHEN (member = 'IMPORT') THEN Call MEM_IMPORT\n        WHEN (member = 'NONVSAM') THEN DO /* NONVSAM member */\n          axx_tot = anv_tot          /* set intermim alias total */\n          nvd_tot = nvd_tot + 1      /* increment total non-vsam */\n          nvv_tot = nvv_tot + Words(volser) /* calc non-vsam vols */\n          IF (SUBSTR(entname,1,4) <> 'SYS1') THEN DO /* not SYS1 */\n            nvo_tot = nvo_tot + 1    /* increment non-vsam only total */\n            Call MEM_NONVSAM\n          END\n          anv_tot = axx_tot          /* set non-vsam aliases total */\n        END\n        WHEN (member = 'SYS1') THEN DO /* SYS1 member */\n          sy1_tot = sy1_tot + 1      /* increment sys1 total */\n          Call MEM_NONVSAM\n        END\n        Otherwise DO\n          NOP\n        END\n      END\n    END\n  END\n  Return\n\n/*====================================================================*/\n/* MEM_MISC - Generate MISC member lines */\n/*====================================================================*/\nMEM_MISC:\n  IF (entype = 'CLUSTER') |,\n     (entype = 'PAGESPACE') THEN DO\n    msc_tot = msc_tot + 1\n    l_cnt = l_cnt + 1\n    text = ' /* 'Left(entype' ',15,'-')\n    text = text' 'Left(entname,32)'  NOT PROCESSED */'\n    l.l_cnt = text\n  END\n  Return\n\n/*====================================================================*/\n/* MEM_RECAT - Generate RECAT member lines */\n/*====================================================================*/\nMEM_RECAT:\n  IF (entype = 'PAGESPACE') THEN DO\n    page_name     = entname\n    page_swap     = pageswap\n    IF (Index(type,'D') <> 0) THEN DO\n      data_flag = 'DATA'\n    END\n    ELSE DO\n      data_flag = ''\n    END\n  END\n  IF (entype = 'CLUSTER') THEN DO\n    IF (SUBSTR(entname,1,4) <> 'SYS1') THEN DO\n      cluster_name  = entname\n      l_cnt = l_cnt + 1\n      text = ' /* 'Left(entype' ',15,'-')\n      text = text' 'Left(entname,34)' CANNOT RECAT */'\n      data_flag = ''\n      index_flag = ''\n      l.l_cnt = text\n    END\n    ELSE DO\n      cluster_name  = entname\n      IF (Index(type,'D') <> 0) THEN DO\n        data_flag = 'DATA'\n      END\n      ELSE DO\n        data_flag = ''\n      END\n      IF (Index(type,'I') <> 0) THEN DO\n        index_flag = 'INDEX'\n      END\n      ELSE DO\n        index_flag = ''\n      END\n      cluster_bits  = type\n    END\n  END\n  IF (entype = 'DATA') &,\n     (data_flag = 'DATA') THEN DO\n    SELECT\n      WHEN (vsam_vvds = 'Y') THEN DO          /* use VVDS flag */\n        l_cnt = l_cnt + 1\n        text = ' /* 'Left('VVDS ',15,'-')\n        text = text' 'Left(cluster_name,32)'  NOT PROCESSED */'\n        l.l_cnt = text\n      END\n      WHEN (Index(name,page_name) > 0) THEN DO\n        l_cnt = l_cnt + 1\n        page_name = STRIP(page_name,\"T\",\" \")\n        l.l_cnt = '   DEF PAGESPACE(NAME('page_name') -'\n        l_cnt = l_cnt + 1\n        volser = STRIP(volser,\"T\",\" \")\n        l.l_cnt = '          VOL('volser') -'\n        l_cnt = l_cnt + 1\n        page_swap = STRIP(page_swap,\"T\",\" \")\n        l.l_cnt = '          'page_swap' -'\n        l_cnt = l_cnt + 1\n        l.l_cnt = '          RECATALOG ) -'\n        l_cnt = l_cnt + 1\n             l.l_cnt = '          CAT('mcattgt')'\n      END\n      WHEN (Index(name,cluster_name) > 0) THEN DO\n        l_cnt = l_cnt + 1\n        cluster_name = STRIP(cluster_name,\"T\",\" \")\n        l.l_cnt = '   DEF CLUSTER(NAME('cluster_name') -'\n        l_cnt = l_cnt + 1\n        volser = STRIP(volser,\"T\",\" \")\n        l.l_cnt = '          VOL(  'volser') -'\n        IF (vsam_attr <> '') THEN DO\n          l_cnt = l_cnt + 1\n          l.l_cnt = '          'Left(vsam_attr,57)' -'\n        END\n        l_cnt = l_cnt + 1\n        l.l_cnt = '          RECATALOG ) -'\n        l_cnt = l_cnt + 1\n        entname = STRIP(entname,\"T\",\" \")\n        l.l_cnt = '         DATA(NAME('entname')) -'\n        IF (index_flag = '') THEN DO\n          l_cnt = l_cnt + 1\n          l.l_cnt = '          CAT('mcattgt')'\n        END\n      END\n      Otherwise DO\n       SAY '**(Error--1)* Unexpected condition for :'\n       SAY '**(Error--2)* cluster_name = 'STRIP(cluster_name,T)\n       SAY '**(Error--3)* page_name    = 'STRIP(page_name,T)\n       SAY '**(Error--4)* entname      = 'STRIP(entname,T)\n       SAY '**(Error--5)* entype       = 'STRIP(entype,T)\n       SAY '**(Error--6)* name         = 'STRIP(name,T)\n       SAY '**(Error--7)* type         = 'STRIP(type,T)\n       SAY '**(Error--8)* data_flag    = 'STRIP(data_flag,T)\n       SAY '**(Error--9)* index_flag   = 'STRIP(index_flag,T)\n       SAY '**(Error-10)* vsam_byte1   = 'vsam_byte1\n       SAY '**(Error-11)* vsam_byte2   = 'vsam_byte2\n      END\n    END\n  END\n  IF (entype = 'INDEX') &,\n     (index_flag = 'INDEX') THEN DO\n    l_cnt = l_cnt + 1\n    entname = STRIP(entname,\"T\",\" \")\n    l.l_cnt = '         INDEX(NAME('entname')) -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          CAT('mcattgt')'\n  END\n  Return\n\n/*====================================================================*/\n/* MEM_ALIAS - Generate ALIAS member lines */\n/*====================================================================*/\nMEM_ALIAS:\n  ali_tot = ali_tot + 1\n  l_cnt = l_cnt + 1\n  entname = STRIP(entname,\"T\",\" \")\n  l.l_cnt = '     DEF ALIAS(NAME('entname') -'\n  l_cnt = l_cnt + 1\n  name = STRIP(name,\"T\",\" \")\n  l.l_cnt = '          REL('name')) -'\n  l_cnt = l_cnt + 1\n  l.l_cnt = '          CAT('mcattgt')'\n  Return\n\n/*====================================================================*/\n/* MEM_IMPORT - Generate IMPORT member lines */\n/*====================================================================*/\nMEM_IMPORT:\n  uct_tot = uct_tot + 1\n  l_cnt = l_cnt + 1\n  entname = STRIP(entname,\"T\",\" \")\n  l.l_cnt = '    IMPORT OBJ( ('entname'  -'\n  l_cnt = l_cnt + 1\n  devices = STRIP(devices,\"T\",\" \")\n  l.l_cnt = '          DEVT('devices') VOL('volser')))' ,\n    'CONNECT -'\n  l_cnt = l_cnt + 1\n  l.l_cnt = '          CAT('mcattgt')'\n  Call ASSOC_ENTRY\n  Return\n\n/*====================================================================*/\n/* MEM_GDG - Generate GDG member lines */\n/*====================================================================*/\nMEM_GDG:\n  gdg_tot = gdg_tot + 1\n  l_cnt = l_cnt + 1\n  entname = STRIP(entname,\"T\",\" \")\n  l.l_cnt = '   DEF GDG (NAME('entname') -'\n  l_cnt = l_cnt + 1\n  gdg_scr = STRIP(gdg_scr,\"T\",\" \")\n  gdg_emp = STRIP(gdg_emp,\"T\",\" \")\n  l.l_cnt = '          LIMIT('STRIP(gdglimit,\"B\",\" \")')' ,\n    gdg_scr gdg_emp') -'\n  l_cnt = l_cnt + 1\n  l.l_cnt = '          CAT('mcattgt')'\n  Return\n\n/*====================================================================*/\n/* MEM_NONVSAM - Generate NONVSAM member lines */\n/*====================================================================*/\nMEM_NONVSAM:\n  l_cnt = l_cnt + 1\n  entname = STRIP(entname,\"T\",\" \")\n  l.l_cnt = '   DEF NVSAM(NAME('entname') -'\n  IF (Words(devices) <= 5) THEN DO     /* < 5 devices for dataset */\n    l_cnt = l_cnt + 1\n    devices = STRIP(devices,\"T\",\" \")\n    l.l_cnt = '          DEVT('devices') -'\n    IF (dev_class = 'TAPE') &,         /* IF devices is tape */\n       (fileseq <> '0') THEN DO        /* IF fileseq number exist */\n      l_cnt = l_cnt + 1\n      fileseq = STRIP(fileseq,\"T\",\" \")\n      l.l_cnt = '          FSEQN('fileseq') -'\n    END\n    l_cnt = l_cnt + 1\n    volser = STRIP(volser,\"T\",\" \")\n    l.l_cnt = '          VOL('volser'))-'\n  END\n  ELSE DO                              /* > 5 devices for dataset */\n    item_lead = 'DEVT( '               /* devices header */\n    item_end  = ') -'                  /* devices trailer */\n    item_pad  = ''                     /* no padding */\n    items = devices                    /* pass data */\n    Call PLUS5_HANDLE                  /* handle > 5 items */\n    IF (dev_class = 'TAPE') &,         /* IF devices is tape */\n       (fileseq <> '0') THEN DO        /* IF fileseq number exist */\n      item_lead = 'FSEQN('             /* fileseq header */\n      item_end  = ') -'                /* fileseq trailer */\n      item_pad  = Left(' ',7)           /* 7 spaces padding */\n      items = fileseq                  /* pass data */\n      Call PLUS5_HANDLE                /* handle > 5 items */\n    END\n    item_lead = 'VOL('               /* volumes header */\n    item_end  = ')) -'                /* volumes trailer */\n    item_pad  = ''                     /* no padding */\n    items = volser                     /* pass data */\n    Call PLUS5_HANDLE                  /* handle > 5 items */\n  END\n  l_cnt = l_cnt + 1\n  l.l_cnt = '          CAT('mcattgt')'\n  Call ASSOC_ENTRY\n  Return\n\n/*====================================================================*/\n/* ASSOC_ENTRY - Process associated entries */\n/*====================================================================*/\nASSOC_ENTRY:\n  DO ali = 1 to Words(name)\n    IF (SUBSTR(type,ali,1) = 'X') THEN DO\n      axx_tot = axx_tot + 1\n      l_cnt = l_cnt + 1\n      one_name = STRIP(Word(name,ali),\"T\",\" \")\n      l.l_cnt = '     DEF ALIAS(NAME('one_name') -'\n      l_cnt = l_cnt + 1\n      entname = STRIP(entname,\"T\",\" \")\n      l.l_cnt = '          REL('entname')) -'\n      l_cnt = l_cnt + 1\n      l.l_cnt = '          CAT('mcattgt')'\n    END\n  END\n  Return\n\n/*====================================================================*/\n/* PLUS5_HANDLE - Handle more than 5 fields for NONVSAM */\n/*====================================================================*/\nPLUS5_HANDLE:\n  l_cnt = l_cnt + 1\n  w_end = Wordindex(items,6)\n  data = Left(SUBSTR(items,1,w_end-1),47)\n  l.l_cnt = '          'item_lead||data' -'\n  DO mult = 6 to Words(items) by 5\n    w_sta = Wordindex(items,mult)\n    w_end = Wordindex(items,mult+5)\n    IF (w_end = 0) THEN DO\n      item = SUBSTR(items,w_sta)\n    END\n    ELSE DO\n      item = SUBSTR(items,w_sta,w_end-w_sta)\n    END\n    l_cnt = l_cnt + 1\n    item_length = 47 - Length(item_pad)\n    l.l_cnt = '                '||item_pad||Left(item,item_length)' -'\n  END\n  l.l_cnt = STRIP(l.l_cnt,T,'-')||item_end\n  Return\n\n/*====================================================================*/\n/* build_statistics_report - Generate REPORT member */\n/*====================================================================*/\nbuild_statistics_report:\n  tot_tot = ali_tot + uct_tot + nvd_tot + gdg_tot + msc_tot\n  sta_tot = tot_tot + ali_tot\n  r. = ''\n  r.1  = 'TCNVTCAT*  CONVERSION REPORT              '||,\n         Date() Time()\n  r.2  = 'ICF CATALOG ENTRIES TO BE MIGRATED'\n  r.3  = ' '\n  r.4  = 'ALIAS   TOTAL .......(M)... 'Right(ali_tot,8)'      '|| ,\n         'TOTAL NUMBER OF ALIAS STMTS IN CATALOG'\n  r.5  = ' '\n  r.6  = ' ALIAS  VSAM UCAT ......... 'Right(avu_tot,8)'      '|| ,\n         'ALIAS STMTS ON VSAM USER CATALOGS'\n  r.7  = ' ALIAS  NONVSAM DS ........ 'Right(anv_tot,8)'      '|| ,\n         'ALIAS STMTS ON NON VSAM DATA SETS'\n  r.8  = ''\n  r.9  = 'IMPORT  VSAM UCATS ..(M)... 'Right(uct_tot,8)'      '|| ,\n         'NUMBER OF VSAM USER CATALOGS'\n  r.10 = ''\n  r.11 = 'NONVSAM DS TOTAL .......... 'Right(nvd_tot,8)'      '|| ,\n         'TOTAL NUMBER OF NON VSAM DATA SETS'\n  r.12 = ' NON VSAM VOLUMES ......... 'Right(nvv_tot,8)'      '|| ,\n         'VOLUMES ASSOCIATED WITH NON VSAM'\n  r.13 = '                                          '|| ,\n         'DATA SETS. SEE NOTE 1'\n  r.14 = ''\n  r.15 = ' NONVSAM SYS1. DS....(M)... 'Right(sy1_tot,8)'      '|| ,\n         'SYS1.** NON VSAM DATA SETS'\n  r.16 = ' NONVSAM OTHER DS....(M)... 'Right(nvo_tot,8)'      '|| ,\n         'ALL OTHER NON VSAM DATA SETS'\n  r.17 = ''\n  r.18 = 'GDG     TOTAL .......(M)... 'Right(gdg_tot,8)'      '|| ,\n         'NUMBER OF GENERATION DATA GROUP STMTS'\n  r.19 = ''\n  r.20 = 'MISC    TOTAL .......(M)... 'Right(msc_tot,8)'      '|| ,\n         'NUMBER OF STATEMENTS WHICH COULD NOT'\n  r.21 = '                                          '|| ,\n         'BE PROCESSED'\n  r.22 = '------------------------------------      '\n  r.23 = 'INVALID DEVICE TYPE ....... 'Right(ivd_tot,8)'      '|| ,\n         'NUMBER OF STATEMENTS WHICH CONTAIN AN'\n  r.24 = '                                          '|| ,\n         'INVALID DEVICE TYPE. SEE NOTE 2'\n  r.25 = 'NO. OF STMTS PROCESSED .... 'Right(sta_tot,8)'      '|| ,\n         'TOTAL NUMBER OF STATEMENTS WHICH WERE'\n  r.26 = '                                          '|| ,\n         'PROCESSED'\n  r.27 = 'SUM OF A/I/N/G/M .......... 'Right(tot_tot,8)'      '|| ,\n         'SUM OF STATEMENTS WHICH WERE PROCESSED'\n  r.28 = '                                          '|| ,\n         'FOR ALIAS/IMPORT/NONVSAM/GDG AND MISC.'\n  r.29 = '                                          '|| ,\n         'SEE NOTE 3'\n  r.30 = ''\n  r.31 = '(M)    : A MEMBER WAS CREATED IN DATA SET '|| ,\n         rcnvtcat_defines_dsn\n  r.32 = 'NOTE 1 : SOME DATA SETS MAY NEED MORE THAN ONE VOLUME '\n  r.33 = 'NOTE 2 : DEVICE TYPE IS NOT RECOGNIZED BY RCNVTCAT !!'\n  r.34 = '         BETTER CHECK THE CODE !?!'\n  r.35 = 'NOTE 3 : DIFFERENCE SHOULD BE THE NUMBER OF ALIAS TOTAL.'\n  r.36 = '         THEY ARE PROCESSED TWICE.'\n  r.0 = 36\n  Return\n\n/*====================================================================*/\n/* COMP_REPORT - Produce the Catalog comparison report */\n/*====================================================================*/\nCOMP_REPORT:\n  l_cnt = 0\n  DO loop = 1 to count.OLD\n    entname = entname.OLD.loop\n    entype  = entype.OLD.loop\n    name    = name.OLD.loop\n    volsers = volsers.OLD.loop\n    flag.entname = 'Y'\n    IF (member = 'COMPFULL') THEN DO\n      disp_ent = entname\n      disp_entype = Left(entype,8)\n    END\n    ELSE DO\n      disp_ent = Left(entname,36)\n      disp_entype = Left(SUBSTR(entype,1,3),4)\n    END\n    disp_vol = STRIP(volsers,B)\n    IF (Symbol('val.NEW.entname') = 'LIT') THEN DO\n      l_cnt = l_cnt + 1\n      SELECT\n        WHEN (entype = 'ALIAS'  ) THEN DO\n          detail = STRIP(name.OLD.loop,B)\n        END\n        WHEN (entype = 'DATA'     ) |,\n            (entype = 'INDEX'    ) THEN DO\n          detail = STRIP(volsers.old.loop,B)||' ',\n                 STRIP(devices.old.loop,B)||' ',\n                 STRIP(vsam_type.OLD.loop,B)||' ',\n                 STRIP(vsam_attr.OLD.loop,B)\n        END\n        WHEN (entype = 'NONVSAM'  ) |,\n            (entype = 'GDG'      ) |,\n            (entype = 'UCAT'     ) |,\n            (entype = 'PAGESPACE') THEN DO\n          detail = STRIP(volsers.old.loop,B)||' ',\n                 STRIP(devices.old.loop,B)\n        END\n        Otherwise DO\n          NOp\n        END\n      END\n      disp_ent = strip(disp_ent,\"T\",\" \")\n      l.l_cnt = disp_entype||disp_ent' --missing - 'detail\n      status.OLD.loop = 'MISSING'\n    END\n    ELSE DO\n      namenew = name.NEW.entname\n      volsnew = volsers.NEW.entname\n      SELECT\n        WHEN (namenew <> name) THEN DO\n          IF (entype = 'ALIAS') THEN DO\n            l_cnt = l_cnt + 1\n            err_text = ' ##catalog was 'STRIP(name,B)' is 'STRIP(namenew,B)\n            l.l_cnt = disp_entype||disp_ent||err_text\n            status.OLD.loop = 'BADCAT'\n          END\n          ELSE DO\n            l_cnt = l_cnt + 1\n            err_text = ' entries DO not match.'\n            l.l_cnt = disp_entype||disp_ent||err_text\n            status.OLD.loop = 'BADENT'\n          END\n        END\n        WHEN (volsnew <> volsers) THEN DO\n          l_cnt = l_cnt + 1\n          err_text = ' ##volser was 'disp_vol' is 'STRIP(volsnew,B)\n          l.l_cnt = disp_entype||disp_ent||err_text\n          status.OLD.loop = 'BADVOL'\n        END\n        Otherwise DO\n          l_cnt = l_cnt + 1\n          l.l_cnt = disp_entype||disp_ent' **entry matches.'\n          status.OLD.loop = 'OK'\n        END\n      END\n    END\n  END\n  DO loop = 1 to count.NEW\n    entname = entname.NEW.loop\n    entype  = entype.NEW.loop\n    volsers = volsers.NEW.loop\n    IF (flag.entname <> 'Y') THEN DO\n      IF (member = 'COMPFULL') THEN DO\n        disp_ent = entname\n        disp_entype = Left(entype,8)\n      END\n      ELSE DO\n        disp_ent = Left(entname,36)\n        disp_entype = Left(SUBSTR(entype,1,3),4)\n      END\n      disp_vol = STRIP(volsers,B)\n      l_cnt = l_cnt + 1\n      l.l_cnt = disp_entype||disp_ent' ++new entry on 'disp_vol\n      status.NEW.loop = 'NEW'\n    END\n  END\n  Return\n\n/*====================================================================*/\n/* NEW_EXT - Process for new entries */\n/*====================================================================*/\nNEW_EXT:\n  DO loop = 1 to count.NEW\n    IF (status.NEW.loop = 'NEW') THEN DO\n      entname = entname.NEW.loop\n      entype  = entype.NEW.loop\n      IF (entype = 'DATA') |,\n         (entype = 'INDEX') THEN\n       Iterate\n      l_cnt = l_cnt + 1\n      l.l_cnt = \"      /* Entry not present in catalog \"cat.old\". */\"\n      l_cnt = l_cnt + 1\n      l.l_cnt = \"      /* Entry present in catalog     \"cat.new\". */\"\n      Call ENTRY_DEL                    /* process an entry delete */\n    END\n  END\n  Return\n\n/*====================================================================*/\n/* OLD_BAD - Process for old entries */\n/*====================================================================*/\nOLD_BAD:\n  DO loop = 1 to count.OLD\n    entname   = entname.OLD.loop\n    entype    = entype.OLD.loop\n    volsers   = volsers.OLD.loop\n    volser    = STRIP(volsers,B)\n    name      = name.OLD.loop\n    type      = type.OLD.loop\n    pageswap  = pageswap.OLD.loop\n    devices   = devices.OLD.loop\n    fils      = fils.OLD.loop\n    gdg_emp   = gdg_emp.OLD.loop\n    gdg_scr   = gdg_scr.OLD.loop\n    gdglimit  = gdglimit.OLD.loop\n    vsam_attr = vsam_attr.OLD.loop\n    vsam_type = vsam_type.OLD.loop\n    vsam_vvds = vsam_vvds.OLD.loop\n    namenew   = name.NEW.entname\n    volsnew   = volsers.NEW.entname\n    IF (entype = 'DATA') |,\n       (entype = 'INDEX') THEN DO\n      Iterate\n    END\n    SELECT\n      WHEN (status.OLD.loop = 'MISSING') THEN DO\n        l_cnt = l_cnt + 1\n        l.l_cnt = \"      /* Entry missing in catalog \"cat\". */\"\n      END\n      WHEN (status.OLD.loop = 'BADCAT') THEN DO\n        l_cnt = l_cnt + 1\n        l.l_cnt = \"      /* Alias incorrectly pointing to \"namenew\". */\"\n      END\n      WHEN (status.OLD.loop = 'BADENT') THEN DO\n        l_cnt = l_cnt + 1\n        l.l_cnt = \"      /* Related entries DO not match */\"\n        l_cnt = l_cnt + 1\n        l.l_cnt = \"      /* entry \"STRIP(entname,T)\" */\"\n        l_cnt = l_cnt + 1\n        l.l_cnt = \"      /* old \"STRIP(name,T)\" */\"\n        l_cnt = l_cnt + 1\n        l.l_cnt = \"      /* new \"STRIP(namenew,T)\" */\"\n      END\n      WHEN (status.OLD.loop = 'BADVOL') THEN DO\n        l_cnt = l_cnt + 1\n        l.l_cnt = \"      /* Volume incorrect - was \"volsnew\". */\"\n      END\n      Otherwise DO\n        Iterate\n      END\n    END\n    Call ENTRY_DEL                      /* process an entry delete */\n    Call ENTRY_CHG                      /* process an entry change */\n  END\n  Return\n\n/*====================================================================*/\n/* ENTRY_DEL - Create a DELETE statement */\n/*====================================================================*/\nENTRY_DEL:\n  IF (entype = 'NONVSAM') THEN DO\n    tparm = ''\n  END\n  ELSE DO\n    tparm = entype\n  END\n  l_cnt = l_cnt + 1\n  l.l_cnt = \"      DELETE \"STRIP(entname,T)\" \"tparm\" NOSCRATCH -\"\n  l_cnt = l_cnt + 1\n  l.l_cnt = '          CAT('Left(mcattgt,44)')'\n  l_cnt = l_cnt + 1\n  l.l_cnt = \"      SET MAXCC=0\"\n  Return\n\n/*====================================================================*/\n/* ENTRY_CHG - Create a changed entry statement */\n/*====================================================================*/\nENTRY_CHG:\n  SELECT\n    WHEN (entype = 'NONVSAM') THEN Call MEM_NONVSAM\n    WHEN (entype = 'ALIAS') THEN Call MEM_ALIAS\n    WHEN (entype = 'GDG') THEN Call MEM_GDG\n    Otherwise NOP\n  END\n  Return\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT970/FILE970.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT970", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}