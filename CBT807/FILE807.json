{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012837000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2762942, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "CBT.V500.FILE807.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2762942, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2762942, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE807.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00,\\x02'", "DS1TRBAL": "b'\\xced'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05{\\x00\\x01\\x05~\\x00\\x00\\x00-'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04N\\x00\\x00\\x01\\t \\x8f\\x01\\t \\x8f\\x145\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf8@@@'", "ispf": {"version": "04.78", "flags": 0, "createdate": "2009-07-27T00:00:00", "modifydate": "2009-07-27T14:35:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-478"}, "text": "REGULAR CBT TAPE - VERSION 478    FILE:  807\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT478.FILE807\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 39 MEMBERS COUNTED; CUMULATIVE SIZE IS 25,815 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/27/09    14:35:58    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$CPYRT": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00E\\x01\\t _\\x01\\t _\\x131\\x00\\x11\\x00\\x10\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-07-24T00:00:00", "modifydate": "2009-07-24T13:31:45", "lines": 17, "newlines": 16, "modlines": 0, "user": "SBGOLOB"}, "text": "\n     (C) COPYRIGHT M. KARLIN, N. LINDNER, I. EISENSTEIN  1981.\n         THE RIGHTS OF THE COPYRIGHT HOLDERS WILL BE STRICTLY ENFORCED.\n\n     ---------------------------------------------------------------\n                                                                       C\n     IMPORTANT NOTE!  (JULY 24, 2009 - BY SAM GOLOB)\n\n         PERMISSION HAS BEEN GRANTED BY M. KARLIN AND N. LINDNER\n         TO PLACE THESE MATERIALS ON THE CBT TAPE, SUBJECT TO CBT\n         TAPE CONDITIONS AND DISCLAIMERS, EVEN THOUGH THE PRODUCT\n         AND MATERIALS ON THIS FILE ARE STILL OWNED BY THE\n         COPYRIGHT HOLDERS.\n\n     IMPORTANT NOTE!\n\n     ---------------------------------------------------------------\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOCNTE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x07\\x01\\t _\\x01\\t \\x8f\\x13E\\x00\\x13\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2009-07-24T00:00:00", "modifydate": "2009-07-27T13:45:07", "lines": 19, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "\n To generate the documentation, use the TSO RECEIVE command.\n\n    TSO RECEIVE INDS(this.pds($$DOCS))\n\n and that will produce the documentation pds in DCF SCRIPT format.\n\n The output is a pds, as follows:\n\n         RECFM LRECL BLKSIZE\n         VBA     148    4096\n\n which, by default, will be named:  prefix.FILE807.DOCS\n\n\n To print the documentation, see member IEBGENER in the File 807 pds.\n You may have to rework the JCL for best results at your site.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$DOCS": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x03\\x00\\x00\\x01\\t \\x8f\\x01\\t \\x8f\\x133#d#d\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd5\\xd1\\xd3@@@'", "ispf": {"version": "04.03", "flags": 0, "createdate": "2009-07-27T00:00:00", "modifydate": "2009-07-27T13:33:00", "lines": 9060, "newlines": 9060, "modlines": 0, "user": "CN03NJL"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "$HFSISPM": {"ttr": 4104, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x05o\\x00\\x93\\x05o\\x07I\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-25T00:00:00", "modifydate": "1993-02-25T07:49:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CN03MQK"}, "text": "./ ADD NAME=SELMS00  0102-93011-93013-1126-00006-00008-00000-CN03MQK\nSELMS001 'INCORRECT SYNTAX'  .ALARM=YES\n'FIRST THREE POSITIONS MUST BE NUMERIC. ENTER A NUMBER BETWEEN 001 AND 199.'\nSELMS003 'MESSAGE NOT FOUND'  .ALARM=YES\n'MESSAGE NUMBER INVALID. CHECK FOR ACCURACY.'\nSELMS004 'INVALID COMMAND'   .ALARM=YES\n'COMMAND ''&ZCMD'' IS UNDEFINED.'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$HFSISPP": {"ttr": 4106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x05o\\x00\\x93\\x05o\\x07I\\x0b\\x17\\x0b\\x17\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-25T00:00:00", "modifydate": "1993-02-25T07:49:00", "lines": 2839, "newlines": 2839, "modlines": 0, "user": "CN03MQK"}, "text": "./ ADD NAME=SELH001  0103-93011-93013-1120-00020-00024-00000-CN03MQK\n%HELP----------------------  HFSELECT MESSAGE DIALOG -----------------------HELP\n%COMMAND ===>_ZCMD\n+\n+All messages issued by HFSELECT have the following form:\n+\n+                                %SELnnnx text+\n+\n+where%nnn+is the message number (001 to 199), and%x+may be I, E or W.\n+To access a message in this dialog, enter its number.\n+\n+The letter following the message number signifies the type of message issued:\n+\n%E+is a critical error message. When this type of error occurs, HFSELECT\n+terminates so that the error can be corrected.\n+\n%W+is a warning message. These messages are useful in adjusting a job to\nrun more efficiently or to warn of possible non-critical errors.\n+\n%I+messages document informational messages.\n)END\n./ ADD NAME=SELH002  0101-93011-93013-1123-00020-00018-00000-CN03MQK\n%HELP---------------------  HFSELECT MESSAGE DIALOG  ----------------------HELP\n%COMMAND ===>_ZCMD\n+\n+PF KEY SETTINGS\n+\n+The following PF key settings are used in the message dialog:\n+\n%PF1+ Help\n+\n%PF3+ Go back to the main dialog panel\n+\n+If multiple panels are needed to explain a message, the following additional\n+PF key settings can be used:\n+\n%PF7+ Go back to the previous screen in a sequence\n+\n%PF8+ Go to the next screen in a sequence\n+\n+The%PF13-PF24+keys may be used for the corresponding PF1-PF12 functions.\n)END\n./ ADD NAME=SELMAIN  0103-93011-93187-1842-00053-00053-00000-CN03MQK\n)BODY\n%------------------------  HFSELECT MESSAGE DIALOG  ----------------------------\n%COMMAND ===>_ZCMD\n+\n+To display information about an HFSELECT message, type its number (001-199),\n+then press%ENTER.+\n+\n%MESSAGE NUMBER  ===> SEL_NNN+\n+\n+                               ***%EXAMPLE+***\n+\n+To access message SEL000I, enter the message number (000):\n+\n%MESSAGE NUMBER  ===> SEL 000\n+\n+\n+\n+Press%PF1+for HELP.\n+Press%PF3+to END.\n)INIT\n        .HELP = SELH001\n        &ZCMD = &Z\n        &NNN  = &Z\n       &ZPF01 = HELP\n       &ZPF13 = HELP\n       &ZPF03 = END\n       &ZPF15 = END\n       &ZPF04 = RETURN\n       &ZPF16 = RETURN\n       &ZPF07 = UP\n       &ZPF19 = UP\n       &ZPF08 = DOWN\n       &ZPF20 = DOWN\n      .CURSOR = NNN\n       VPUT ( ZPF01 ZPF03 ZPF07 ZPF08 ZPF13 ZPF15 ZPF19 ZPF20 ) PROFILE\n)PROC\n     IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n     VER (&NNN,NONBLANK)\n     &NN   =  TRUNC (&NNN,2)\n     &NA   = .TRAIL\n     VER (&NNN,NB,PICT,NNN,MSG=SELMS001)\n     VER (&NN,LIST,00,01,02,03,04,05,06,07,08,09,10,MSG=SELMS003)\n     IF (&NN = 01) VER (&NA,LIST,0,2,3,4,5,6,7,8,9,MSG=SELMS003)\n     IF (&NN = 04) VER (&NA,LIST,0,1,2,3,5,6,8,9,MSG=SELMS003)\n     IF (&NN = 05) VER (&NA,LIST,0,1,2,3,4,5,7,MSG=SELMS003)\n     IF (&NN = 06) VER (&NA,LIST,0,2,3,4,8,9,MSG=SELMS003)\n     IF (&NN = 08) VER (&NA,LIST,0,1,2,5,7,8,9,MSG=SELMS003)\n     IF (&NN = 09) VER (&NA,LIST,3,4,5,6,7,9,MSG=SELMS003)\n     IF (&NN = 10) VER (&NA,LIST,0,1,2,3,4,5,6,7,MSG=SELMS003)\n     &PANELID = SEL&NNN\n     VPUT PANELID SHARED\n)END\n./ ADD NAME=SEL000   0103-93011-93013-0943-00022-00023-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL000I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL000I PARM= xxxxxxxxxxxxxxx\n+\n+\n+                 %EXPLANATION:+This message is printed with every execution\n+                  of  HFSELECT. It repeats the characters coded in the PARM\n+                  field in the JCL for the user's convenience.\n+\n+                 %SYSTEM ACTION:+normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL001   0103-93011-93013-0944-00028-00023-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL001I ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL001I CLASS  TEST  REQUESTED,  OPTION(S)=xxxxxx  (A=ALPHABETIC,\n%                  H=HIGH  VALUES,   L=LOW  VALUES,   N=NUMERIC,   P=PACKED,\n%                  Z=ALPHANUMERIC)\n+\n+                 %EXPLANATION:+ This  message  indicates  that a class type\n+                  selection was requested for either a C, D, O or S option.\n+                  For  the D and S options, a class type is requested using\n+                  the  C=x  keytype  parameter.  x  may  be  any one of the\n+                  following characters: A, H, L, N, P or Z.\n+                  For  the  C and O options, class type(s) are requested by\n+                  specifying  the  reserved  word CLASS=xxxxxx in the first\n+                  record  of  the SYSIN file. xxxxxx may be from one to all\n+                  six of the following characters: A, H, L, N, P and Z.\n+                  The message displays which class(es) were requested.\n+\n+                 %SYSTEM ACTION:+normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL002   0105-93011-93032-0946-00031-00027-00000-CN03MQK\n)ATTR DEFAULT(%$_)\n)BODY\n%------------------------- HFSELECT MESSAGE SEL002E ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL002E KEY  ENTERED  IS  NOT  (SIGNED)  NUMERIC  OR  EXCEEDS  15\n%                  CHARACTERS IN LENGTH ON N=,P=,X= OR Y= KEYWORD PARAMETERS\n$\n$                 %EXPLANATION:$ This  message  indicates that the Y= equate\n$                  parameter  had  been specified in an incorrect manner, or\n$                  that  either  the  D or S option had been requested and a\n$                  critical error was encountered while scanning the keytype\n$                  parameter in the PARM field. If the message refers to the\n$                  Y=  equate parameter, the parameter contains more than 14\n$                  characters.  If  it refers to the keytype parameter, this\n$                  parameter had been specified as either N= or P= or X=. If\n$                  N=+/-xxxxxx  or  P=+/-xxxxxx  had  been specified, either\n$                  xxxxxx  was  not a (signed) numeric integer, or +/-xxxxxx\n$                  exceeded   15   characters.   If   X=hexstring  had  been\n$                  specified, hexstring exceeded 14 characters.\n$\n$                 %SYSTEM ACTION:$program terminates with return code of 8.\n$                 %PROGRAMMER   RESPONSE:$correct the applicable PARM  field\n$                  parameter.\n$    Press%PF03$to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL003   0103-93011-93013-0948-00028-00020-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL003E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL003E SYSIN FILE IS  EMPTY (A,B,E,G,M,P,R,T OPT) OR CONTAINS AN\n%                  INSUFFICIENT NUMBER OF KEYS (C,O OPTION)\n+\n+                 %EXPLANATION:+  This  message  indicates  that  an  option\n+                  requiring   the  SYSIN  DD  statement  was  specified.  A\n+                  critical  error  occurred  because  SYSIN did not contain\n+                  enough records for the option specified.\n+                  For  the  C  option,  SYSIN  must  contain at least three\n+                  records.  For  the  O option, SYSIN must have at least as\n+                  many  records as the number of L,P pairs specified in the\n+                  PARM.  For  all  the other options listed in the message,\n+                  SYSIN must contain at least one record.\n+\n+                 %SYSTEM ACTION:+program terminates with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+correct the SYSIN file.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL004   0106-93011-93013-0956-00034-00018-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL004I ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL004I KEY= xxxxxxx  nnn RECORDS PASSED, mmm RECORDS OUTPUT yyy\n+\n+                 %EXPLANATION:+ This message is produced, in whole or part,\n+                  for  every  option except B, D and Q. For the A, C, E, F,\n+                  G,  K,  O,  P, R and T options, and for the M option with\n+                  the L suboption or the V= parameter coded, the message is\n+                  produced  once  at the end of processing and is a summary\n+                  total.  The  field  KEY=  xxxxxxx  and  the yyy field are\n+                  blanked  out. nnn is the total number of records read and\n+                  processed  and mmm is the number of records selected. For\n+                  the  S  option, the message is also produced once but the\n+                  field  KEY=  xxxxxxx  is written only when the keytype K=\n+                  is  specified.  yyy  is  blank  if the number of  records\n+                  selected is less than the J= count parameter and  is  MAX\n+                  if  the J= count parameter  is  satisfied (in which  case\n+                  mmm  will  be  equal  to  the J= count). For the M option\n+                  without the L suboption and without the V= parameter this\n+                  message is produced once for each key read from the SYSIN\n+                  file.  nnn  is  the  number of input records whose select\n+\n+    Press%PF08+to display next screen.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n  &ZPF08 = NEXT\n  &ZPF20 = NEXT\n  VPUT ( ZPF08 ZPF20 ) PROFILE\n)PROC\n   IF (&ZCMD \u00ac= &Z,NEXT)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL004B  0102-93012-93013-0957-00033-00033-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL004I (CONT'D) ------------------\n%COMMAND ===>_ZCMD\n%\n+                  field(s) are greater than the previous KEY and less  than\n+                  or equal to the present KEY (when the B= begin  parameter\n+                  is  coded,  nnn  of  the first KEY includes the  first  B\n+                  records).  mmm  is the number of records selected against\n+                  the KEY. yyy is blank or MAX depending on whether  the J=\n+                  count  parameter  was  satisfied  for the KEY.  For the M\n+                  option, when the N suboption is coded and the  SYSIN file\n+                  ends before the end of processing, a key  of  high values\n+                  (HEX'FF...FF')  is  appended  to  SYSIN  and a message is\n+                  produced for this appended key (with KEY= HIGH VALUES  in\n+                  the KEY field).\n+\n+                 %SYSTEM ACTION:+Normal program continuation/termination.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+\n+    Press%PF03+to END.\n+    Press%PF07+to display the previous screen.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n  &ZPF07 = LAST\n  &ZPF19 = LAST\n  &ZPF08 = DOWN\n  &ZPF20 = DOWN\n  VPUT ( ZPF07 ZPF08 ZPF19 ZPF20 ) PROFILE\n)PROC\n IF (&ZCMD \u00ac= &Z,LAST)\n       .MSG = SELMS004\n)END\n./ ADD NAME=SEL005   0102-93011-93013-0958-00027-00019-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL005I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL005I END OF INPUT FILE REACHED\n+\n+                 %EXPLANATION:+ This  message indicates that the end of the\n+                  primary  input  file  was  reached  during  the selection\n+                  process. This can occur with any option and is one of the\n+                  normal end of processing  occurrences.   If  the  primary\n+                  input file is VSAMKEY this  message  indicates  that  the\n+                  VSAM file  key  has  become greater than the PARM key  (S\n+                  option) or highest SYSIN key (A or M option).  With the V\n+                  option,   however,   this   message  indicates  that  all\n+                  requested VTOCs have been processed.\n+\n+                 %SYSTEM ACTION:+normal program end with return code of 0.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL006   0102-93011-93013-0958-00023-00018-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL006I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL006I END OF SYSIN FILE BEFORE END OF INPUT FILE\n+\n+                 %EXPLANATION:+This message indicates that the end of SYSIN\n+                  was reached before the end of the primary input file,  or\n+                  that selection ended before the end of the primary  input\n+                  file for an option that selects on a single key (D or S).\n+                  It is one of the normal end of processing occurrences.\n+\n+                 %SYSTEM ACTION:+normal program end with return code of 0.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL007   0102-93011-93013-0959-00021-00018-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL007I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL007I PARM FIELD OPTIONS MISSING - DEFAULT OPTION R,1,1 ASSUMED\n+\n+                 %EXPLANATION:+ This  message  indicates  that there are no\n+                  characters in the PARM field. The PARM defaults to R,1,1.\n+\n+                 %SYSTEM ACTION:+program defaults to PARM='R,1,1'.\n+\n+                 %PROGRAMMER RESPONSE:+Code a PARM field unless the default\n+                  is acceptable.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL008   0102-93011-93013-0959-00024-00019-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL008E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL008E ERROR IN EXITS CONTROL STATEMENT\n+\n+                 %EXPLANATION:+This message indicates one of the following\n+                  errors in an EXITS control statement:\n+\n+                  -invalid control statement syntax or exit point\n+                  -specified ddname not found in the JCL\n+                  -modname not found in specified (or default) library\n+\n+                 %SYSTEM ACTION:+program termination with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the EXITS control statement.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL009   0101-93011-93013-0959-00031-00031-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL009E ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL009E INVALID NUMBER OF LENGTH/POSITION (L,P) PARAMETERS SPECIFIED\n+\n+                 %EXPLANATION:+ This  message indicates that a wrong number\n+                  of  L,P  pairs was coded for the option/suboption/keytype\n+                  in  the  PARM  field.  One  and only one L,P pair must be\n+                  coded  for  the  G option, the L suboption when any input\n+                  file  has  a variable record format, and for N=, P=, C=N,\n+                  C=P  and C=Z key and class types for the D and S options.\n+                  Exactly  two  L,P  pairs  must be coded for the B option.\n+                  Exactly  three  L,P pairs must be coded for the C option.\n+                  For  all  other  options except E and R, one to three L,P\n+                  pairs  may  be coded. For the R option, zero to three N,K\n+                  pairs  may  be coded. For the E option, zero to three F,T\n+                  pairs  may  be  coded.  When  the V=(l,p...) parameter is\n+                  coded, one to three l,p pairs may be coded. When the  VP=\n+                  parameter is coded only one L,P pair and one l,p pair may\n+                  be coded.\n+\n+                 %SYSTEM ACTION:+program termination with return code of 8.\n+                 %PROGRAMMER RESPONSE:+Code the correct number of L,P pairs\n+                  in the PARM field.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL010   0101-93011-93013-1000-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL010E ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL010E INVALID PRIMARY OPTION OR SUBOPTION SPECIFIED\n+\n+                 %EXPLANATION:+ This  message  indicates  that  an  invalid\n+                  primary option or an invalid suboption has been specified\n+                  in the  PARM  field. The valid primary options are: A, B,\n+                  C, D, E, F, G, K, M,  O,  P, Q, R, S, T and V.  The valid\n+                  suboptions are: L, N and W. This message is also produced\n+                  when a primary option and suboption are illegally paired,\n+                  i.e., when the N suboption  is  specified with the F or K\n+                  options or when the L suboption  is  specified with other\n+                  than  the  A,  F,  K,  P, Q, M or T options. It  is  also\n+                  produced when the CONVERT DD statement  is coded with the\n+                  D or R options  or when the L suboption is coded with the\n+                  VP= parameter. It is also produced if  the ddname VSAMKEY\n+                  is coded with the B, C, D, E, G, O, P, R or T options, or\n+                  with the N suboption.\n+\n+                 %SYSTEM ACTION:+program termination with return code of 8.\n+                 %PROGRAMMER  RESPONSE:+ Code  a  valid   primary   option,\n+                  suboption or proper combination thereof in the PARM.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL012   0101-93011-93013-1001-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL012E ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL012E LENGTH  PARAMETER  EXCEEDS 15 ON G OPTION OR N= PARAMETER\n%                  OR EXCEEDS 8 ON P= OR X= PARAMETER (S,D,V OPTION)\n+\n+                 %EXPLANATION:+ This  message  indicates that the G, D or S\n+                  option  had  been  requested  and  a  critical  error was\n+                  encountered while scanning the L (length) parameter(s) of\n+                  the PARM field. If the G option was  specified, the value\n+                  of  the L parameter exceeded 15. If the D or S option was\n+                  specified  with the N= or P= keytype parameter, the value\n+                  of  the L parameter exceeded 15 or 8 respectively. If the\n+                  X=  keytype  parameter  was  specified  with  the  D or S\n+                  option,  the  value  of  the sum of the length parameters\n+                  exceeded 7. This message is also produced if the A  or  M\n+                  options are coded with the VP=  parameter  and  a  length\n+                  parameter (L or l) is greater than 15.\n+\n+                 %SYSTEM ACTION:+program termination with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+ correct the length parameter(s) in\n+                  the PARM field.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL013   0101-93011-93013-1001-00026-00026-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL013E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL013E B= PARAMETER EXCEEDS E= PARAMETER\n+\n+                 %EXPLANATION:+  This  message  indicates  that  the  value\n+                  specified  in  the  B=begin  parameter  exceeds the value\n+                  specified  in  the E=end parameter of the PARM field. The\n+                  B=begin parameter indicates the record number after which\n+                  the  program  is  to  begin  selection processing and the\n+                  E=end  parameter indicates the record number at which the\n+                  program is to end selection processing.\n+\n+                 %SYSTEM ACTION:+program terminates with return code of 8.\n+\n+                 %PROGRAMMER   RESPONSE:+ correct  the  B=  and/or  the  E=\n+                  parameter so that B= is less than or equal to E=.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL014   0101-93011-93013-1002-00029-00029-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL014I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL014I FIRST  nnn  SEQUENCE  ERRORS  PRINTED,  SEQUENCE CHECKING\n%                  CONTINUES\n+\n+                 %EXPLANATION:+ This message is produced on the Q (sequence\n+                  checking)  option.  It  indicates  that the primary input\n+                  file   is   out  of  sequence  (ascending  or  descending\n+                  depending  on  whether  the  N  and/or  W  suboptions are\n+                  specified).  The value nnn, which is controlled by the J=\n+                  parameter,  gives  the  number of out of sequence records\n+                  printed.  When  no J= parameter is specified, the default\n+                  value  for  nnn is 200. Sequence checking and output file\n+                  processing  to SYSUT2 and SYSUT3 will continue to the end\n+                  of the input file after this message is printed.\n+\n+                 %SYSTEM ACTION:+program continues normal processing.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL015   0101-93011-93013-1003-00026-00026-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL015E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL015E KEY IN PARM FIELD IS NOT PRECEEDED BY A C=, K=, N=, P= OR\n%                  X= KEYWORD PARAMETER\n+\n+                 %EXPLANATION:+ This  message  is  produced  in  the D or S\n+                  options  when  an  invalid  key  specification  or no key\n+                  specification  is  written  in  the key type field in the\n+                  PARM. The valid key types are C (class), K (character), N\n+                  (zoned  numeric),  P  (packed numeric) and X (hexadecimal\n+                  string).\n+\n+                 %SYSTEM ACTION:+program terminates with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+ Enter a valid key specification in\n+                  the PARM field: e.g., enter K=characters, N=numeric, etc.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL016   0102-93011-93013-1004-00027-00027-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL016E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL016E LENGTH/POSITION/BEGIN/END/COUNT   PARAMETER   EXCEEDS   8\n%                  DIGITS, IS NOT NUMERIC OR HAS 0 VALUE\n+\n+                 %EXPLANATION:+ This  message  is  produced when any of the\n+                  parameters  listed  is  more  than  8  digits  in length,\n+                  is not numeric (except for  the  A  option  where  the J=\n+                  parameter  is, or defaults  to,  a  non-numeric  operator\n+                  instead  of  containing  a  count)  or  has  a zero value\n+                  (except  for  the B=begin parameter or the F option where\n+                  the J= parameter may be set to zero).\n+\n+                 %SYSTEM ACTION:+program terminates with return code of 8.\n+\n+                 %PROGRAMMER   RESPONSE:+  correct  the  invalid  parameter\n+                  specification in the PARM field.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL017   0101-93011-93013-1004-00024-00024-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL017E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL017E Y= KEYWORD  PARAMETER  IS  INVALID FOR THE E OPTION AND L\n%                  SUBOPTION\n+\n+                 %EXPLANATION:+ This message is produced when the Y= equate\n+                  parameter  is  specified  in  the  PARM  and either the E\n+                  option or the L suboption was also coded in the PARM.\n+\n+                 %SYSTEM ACTION:+program terminates with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+ Either delete the Y= parameter  or\n+                  delete the L suboption in the PARM or use an option other\n+                  than the E option.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL018   0102-93011-93014-1238-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL018E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL018E A  LENGTH  PARAMETER EXCEEDS 20 (O,B,C) OR THE SUM OF THE\n%                  LENGTH PARMS EXCEEDS 20 OR THE KEY IN THE PARM EXCEEDS 20\n%                  CHARACTERS\n+\n+                 %EXPLANATION:+ This  message  is  produced  when  a length\n+                  parameter  in  an L,P pair is greater than 20 and the B,C\n+                  or O option is coded,  or the sum of the L's coded in the\n+                  L,P  pairs  is  greater than 20 for other options, or the\n+                  key coded in the keytype parameter  has   more   than  20\n+                  characters  (not  counting  double  ampersands  or double\n+                  apostrophes) for the D, S or V options.\n+\n+                 %SYSTEM ACTION:+program terminates with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Ensure that the select field lengths\n+                  are equal to or less than the allowable maximums, or that\n+                  the  key  length, if the S or D option had been coded, is\n+                  not greater than 20 characters. Use the  L  suboption  if\n+                  the option permits its use.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL019   0101-93011-93013-1007-00023-00023-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL019I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL019I FILE IS IN SEQUENCE\n+\n+                 %EXPLANATION:+ This  message is produced when the Q option\n+                  is  coded  and  the  input  file  is in the desired order\n+                  (ascending   when  the  N  suboption  is  not  coded  and\n+                  descending when the N suboption is coded) with no records\n+                  out of sequence.\n+\n+                 %SYSTEM ACTION:+normal program termination.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL020   0101-93011-93013-1008-00026-00026-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL020E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL020E INVALID HEX CHARACTER USED-ONLY 0-9,A-F ALLOWED OR NUMBER\n%                  OF CHARACTERS IS NOT EVEN IN X= OR Y= KEYWORD PARAMETER\n%                  OR IN THE CONVERT FILE.\n+\n+                 %EXPLANATION:+ This message is produced when the Y= equate\n+                  symbol parameter is used or X=hexstring keytype parameter\n+                  is coded with the  S  or  D  option  or when hex keys are\n+                  coded  in  the CONVERT file, and  the  hexstring contains\n+                  characters other than 0 through 9 and A through F, or the\n+                  string  length is not an even number.\n+\n+                 %SYSTEM ACTION:+program termination with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+ Correct the hexstring.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL021   0104-93011-93013-1008-00034-00074-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL021I ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL021I KEY= xxxxxxx NUMBER OF RECORDS SELECTED= nnn\n+\n+                 %EXPLANATION:+ This message is produced on the C, E, F, G,\n+                  O  and  T  options.  The  meaning  for  each option is as\n+                  follows:\n+                   1. C - This message is produced  three  times - once for\n+                          each of the three keys listed in SYSIN. The first\n+                          message  gives the number of records whose select\n+                          field  defined  by the first L,P pair matches the\n+                          key or class(es) in the first  SYSIN  record. The\n+                          second  message  gives   the  number  of  records\n+                          selected, from  the group  of  records counted in\n+                          the  first  message,  whose select field  defined\n+                          by  the  second  L,P pair  matches the key in the\n+                          second  SYSIN record. The third message gives the\n+                          number  of records  selected, from  those records\n+                          not  counted in the first  message, whose  select\n+                          field  defined by the third L,P pair  matches the\n+                          key in the third SYSIN record.\n+\n+    Press%PF08+to display next screen.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n  &ZPF08 = NEXT\n  &ZPF20 = NEXT\n  VPUT ( ZPF08 ZPF20 ) PROFILE\n)PROC\n   IF (&ZCMD \u00ac= &Z,NEXT)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL021B  0102-93012-93013-1009-00034-00069-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL021I (CONT'D) ------------------\n%COMMAND ===>_ZCMD\n+                   2. E - This message is produced once for each key in the\n+                          SYSIN file (up to  the  maximum  number of  keys)\n+                          except when the  primary  input  file  is  empty.\n+                          xxxxxxx is the key value including the delimiters\n+                          entered  with  the keys. nnn is either the number\n+                          of primary  file records selected for that key or\n+                          the  character  string  'KEY ERROR'  if  the  key\n+                          entered was not valid.  For the  string  replace-\n+                          ment form, when '$' or '@' is coded in  front  of\n+                          the replacement string, these  messages  are  now\n+                          just the counts of the records  that  contain the\n+                          keys listed in SYSIN.\n+                   3. F - This message is produced on  the  F  option  when\n+                          J=0 is coded  in the PARM, i.e., when a frequency\n+                          or  cross-table  is  requested.  The  message  is\n+                          produced  once  for  each  different key value on\n+                          the file. xxxxxxx is the key value and nnn is the\n+                          number of input records with that key value.\n+\n+    Press%PF08+to display next screen.\n+    Press%PF07+to display the previous screen.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n  &ZPF07 = LAST\n  &ZPF19 = LAST\n  VPUT ( ZPF07 ZPF19 ) PROFILE\n)PROC\n IF (&ZCMD \u00ac= &Z,LAST,NEXT)\n       .MSG = SELMS004\n)END\n./ ADD NAME=SEL021C  0102-93012-93013-1010-00031-00047-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL021I (CONT'D) ------------------\n%COMMAND ===>_ZCMD\n+                   4. G - This message is produced once for each key listed\n+                          in SYSIN and once for each generated key. xxxxxxx\n+                          is  the key value, whose length  is determined by\n+                          the L parameter in the PARM field.  The keys  are\n+                          listed in ascending order. nnn is the  number  of\n+                          primary file records selected for that key.\n+                   5. O - This message is produced once for each key listed\n+                          in SYSIN (up to a maximum of 3 times depending on\n+                          the number of L,P pairs coded in the PARM field).\n+                          xxxxxxx is the key value. The first key value can\n+                          be either a character string or the string CLASS=\n+                          yyyyyy,  where  yyyyyy  may  be any or all of the\n+                          letters  A, H, L, N, P and Z in  any  order.  The\n+                          length  of  each  key  is   determined   by   the\n+                          corresponding  value of the L in the PARM. nnn is\n+                          the  number of primary file  records selected for\n+                          that key. If a record contains more than one key,\n+                          the  record is counted  only  once   against  the\n+                          first SYSIN key that it matches.\n+    Press%PF08+to display next screen.\n+    Press%PF07+to display the previous screen.\n+    Press%PF03+to exit.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z,LAST,NEXT)\n       .MSG = SELMS004\n)END\n./ ADD NAME=SEL021D  0101-93012-93013-1010-00032-00032-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL021I (CONT'D) ------------------\n%COMMAND ===>_ZCMD\n%\n+                   6. T - This  message  is  produced  once  for  each  key\n+                          entered in SYSIN.  The key  values  are listed in\n+                          ascending  order.  xxxxxxx  is  the    key/select\n+                          field(s) value whose length is  determined by the\n+                          sum of the L's in the PARM. nnn is the  number of\n+                          primary file records selected for that key/select\n+                          field(s). This message is not produced when the L\n+                          suboption is used.\n+\n+                  When  the  N  suboption is specified for any of the above\n+                  options only the 'KEY =xxxxxxx' portion of the message is\n+                  produced.\n+\n+                 %SYSTEM ACTION:+normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+\n+    Press%PF03+to END.\n+    Press%PF07+to display the previous screen.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n  &ZPF08 = DOWN\n  &ZPF20 = DOWN\n  VPUT ( ZPF08 ZPF20 ) PROFILE\n)PROC\n IF (&ZCMD \u00ac= &Z,LAST)\n       .MSG = SELMS004\n)END\n./ ADD NAME=SEL022   0101-93011-93013-1011-00024-00024-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL022I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL022I FILE IS OUT OF SEQUENCE STARTING AT\n+\n+                 %EXPLANATION:+ This  message is produced when the Q option\n+                  is  specified  and  the  primary  input  file  is  out of\n+                  sequence at any of the records. The message is the header\n+                  for one or more SEL023I messages. The correct sequence is\n+                  ascending   when  the  N  suboption  is  not  coded,  and\n+                  descending when the N suboption is coded.\n+\n+                 %SYSTEM ACTION:+Normal Q option processing continues.\n+\n+                 %PROGRAMMER RESPONSE:+none\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL023   0101-93011-93013-1011-00031-00031-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL023I ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL023I RECORD NUMBER = nnn, KEY =xxxxxxx PREVIOUS KEY =yyyyyyy\n+\n+                 %EXPLANATION:+ This  message is produced when the Q option\n+                  is  specified  and  the  primary  input  file  is  out of\n+                  sequence  at any of the records. nnn is the record number\n+                  of  the  current  out-of-sequence  record  in  the  file,\n+                  xxxxxxx is the key of the current record which has caused\n+                  the  out  of sequence condition and yyyyyyy is the key of\n+                  the  last  preceding  record  which was in sequence. This\n+                  message  is  produced  every  time  a  record  causes  an\n+                  out-of-sequence  condition  or  until the number of these\n+                  messages  equals  the  count  in the J= parameter or 200,\n+                  whichever  is  less.  This  message is always produced in\n+                  conjunction with message SEL022I. When the L suboption is\n+                  specified,  message  SEL023I is output only for the first\n+                  out-of-sequence  occurrence,  and  only  'RECORD NUMBER =\n+                  nnn' is printed for this message.\n+\n+                 %SYSTEM ACTION:+Normal Q option processing continues.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL024   0101-93011-93013-1012-00023-00023-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL024I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL024I KEY NOT FOUND ON DEBUG OPTION\n+\n+                 %EXPLANATION:+ This  message is produced when the D option\n+                  is  specified and no record with the key specified in the\n+                  keytype parameter was found in the file.\n+\n+                 %SYSTEM ACTION:+Normal program end with return code of 0.\n+\n+                 %PROGRAMMER  RESPONSE:+ Check  value  of  key/class in the\n+                  keytype  parameter. Also check L,P parameters for correct\n+                  length and/or position specifications.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL025   0101-93011-93013-1013-00021-00021-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL025I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL025I TOTAL NUMBER OF RECORDS IN INPUT FILE = nnn\n+\n+                 %EXPLANATION:+This message is produced on the Q option and\n+                  gives the total number of records on the input file.\n+\n+                 %SYSTEM  ACTION:+ The  program  has completed its sequence\n+                  checking and selection and has ended normally.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL026   0101-93011-93013-1014-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL026I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL026I mmm RECORDS OUTPUT FROM RECORD nnn.  SKIP FACTOR = kkk.\n+\n+                 %EXPLANATION:+This message is produced on the R option for\n+                  each N,K (begin,skip) pair coded in the PARM field. It is\n+                  produced a maximum of three times. For each N,K pair, mmm\n+                  will  be  the  count  of  the  number  of  records output\n+                  corresponding to that N,K pair. This count will always be\n+                  equal to the J=count parameter unless the input file ends\n+                  or the E=end parameter is reached before the count can be\n+                  satisfied.  The  record  number at which output selection\n+                  began   is  given  by  nnn,  where  nnn  is  the N of the\n+                  corresponding  N,K pair unless a previous N,K pair caused\n+                  selection  to  go  beyond  this  starting  point,  or the\n+                  B=begin  parameter  exceeded  N.  kkk  is  the  K  of the\n+                  corresponding N,K pair.\n+\n+                 %SYSTEM ACTION:+Normal program end with return code of 0.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL027   0101-93011-93013-1014-00026-00026-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL027E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL027E PARM  FIELD  ENDS  IN A COMMA  OR CONTAINS  2 CONSECUTIVE\n%                  COMMAS OR A KEYWORD PARAMETER IS MISSING\n+\n+                 %EXPLANATION:+ The  PARM  field is incorrect. The PARM may\n+                  not  end  in  a  comma  nor can two consecutive commas be\n+                  coded  anywhere  in  the  PARM field. A comma in the PARM\n+                  field  is  always a parameter delimiter. If it is desired\n+                  to  code  a  key containing a comma  in the PARM, HEX'6B'\n+                  must  be  coded  with  the X=hexstring keytype parameter.\n+                  Commas in SYSIN have no special significance.\n+\n+                 %SYSTEM ACTION:+program terminates with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the PARM field.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL028   0101-93011-93013-1015-00023-00023-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL028E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL028E INVALID OPTION SPECIFIED FOR CLASS TEST\n+\n+                 %EXPLANATION:+ This  message  indicates  that a class type\n+                  selection  was requested for either a C, D, O or S option\n+                  but no valid class type was found. A valid class type may\n+                  be  any one of the following characters: A, H, L, N, P or\n+                  Z.\n+\n+                 %SYSTEM ACTION:+Program termination with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the class type.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL029   0101-93011-93013-1016-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL029A ---------------------------\n%COMMAND ===>_ZCMD\n%   SEL029I LOW KEY =xxxxxxx, HIGH KEY =yyyyyyy nnn RECORDS PASSED\n+\n+          %EXPLANATION:+This message is produced on the B or P options.  These\n+           two options select on ranges of keys, with the ranges defined by\n+           pairs of keys in SYSIN. The odd-numbered key of each pair is printed\n+           as the value of LOW KEY and the even-numbered key of the pair is\n+           printed as the value of HIGH KEY. One message is produced for each\n+           key pair entered in SYSIN. When an odd number of keys is entered in\n+           SYSIN, the last LOW KEY value is the last key entered in SYSIN, the\n+           value of HIGH KEY is set equal to high values and yyyy is replaced\n+           by the character string HIGH VALUES.  The end portion of the message\n+           (nnn RECORDS PASSED) is not printed with the P option or with the B\n+           option and the N suboption.  nnn RECORDS PASSED means that nnn\n+           records were read  from the primary input file (in ascending key\n+           order) before  the select fields became greater than that key pair\n+           range and the next pair was read and used for selection. When the L\n+           suboption is used with the P option this message is not produced.\n+\n+          %SYSTEM ACTION:+Normal program continuation.\n+          %PROGRAMMER RESPONSE:+None.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL030   0101-93011-93013-1016-00023-00023-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL030I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL030I TOTAL NUMBER OF UNIQUE KEYS IN INPUT FILE = nnn\n+\n+                 %EXPLANATION:+ This message is generated when the F option\n+                  is  coded. When the unduplicating form of the F option is\n+                  coded  (J=n  with  n>0),  two  other  messages  are  also\n+                  generated-  SEL031I  and  SEL032I.  nnn  is the number of\n+                  unique values found in the input file select field(s).\n+\n+                 %SYSTEM ACTION:+Normal program termination.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL031   0101-93011-93013-1016-00025-00025-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL031I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL031I NUMBER  OF  KEY  GROUPS  WITH  RECORDS  LESS  THAN   PARM\n%                  COUNT= nnn\n+\n+                 %EXPLANATION:+ This  message  is  one  of  three  that are\n+                  generated  when the unduplicating form of the F option is\n+                  coded (J=n and n>0). The other two messages generated are\n+                  SEL030I  and  SEL032I. nnn is the number of unique values\n+                  of  the input file select field(s) that occur fewer times\n+                  than the count specified in the J=count parameter.\n+\n+                 %SYSTEM ACTION:+Normal program termination.\n+\n+                 %PROGRAMMER RESPONSE:+none\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL032   0101-93011-93013-1017-00024-00024-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL032I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL032I NUMBER OF KEY GROUPS WITH RECORDS GREATER THAN COUNT= nnn\n+\n+                 %EXPLANATION:+ This  message  is  one  of  three  that are\n+                  generated  when the unduplicating form of the F option is\n+                  coded (J=n and n>0). The other two messages generated are\n+                  SEL030I  and  SEL031I. nnn is the number of unique values\n+                  of  the  input file select field(s) that occur more times\n+                  than the count specified in the J=count parameter.\n+\n+                 %SYSTEM ACTION:+Normal program termination.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL033   0101-93011-93013-1017-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL033I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL033I TOTAL NUMBER OF NON-SELECTED INPUT RECS OUTPUT = nnn\n+\n+                 %EXPLANATION:+This message is produced only when SYSUT3 is\n+                  coded  in  the JCL. nnn is the number of records that are\n+                  output  to  this file. They include all processed records\n+                  from  the  primary  input  file  that  are  not output to\n+                  SYSUT2;  viz., records whose number is less than or equal\n+                  to the B= begin parameter, records rejected during normal\n+                  processing,  and records whose number is greater than the\n+                  E=  end  parameter when the A or M options are coded with\n+                  the V=(l,p...) parameter.\n+\n+                  For the string replacement form of the E option, when '@'\n+                  is coded in front of the replacement  string, ALL records\n+                  are output to the primary output file (SYSUT2 or LIBOUT),\n+                  hence nnn will always be 0 in this message.\n+\n+                 %SYSTEM ACTION:+Normal program termination.\n+                 %PROGRAMMER RESPONSE:+None.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL034   0101-93011-93013-1018-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL034I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL034I KEY=xxxxxxx  LOCATED IN RECORD kkk.  RECORDS OUTPUT= mmm,\n%                  BEGINNING AT RECORD nnn\n+\n+                 %EXPLANATION:+ This message is produced when the D (debug)\n+                  option  has  been  requested.  When  the C= or K= keytype\n+                  parameter  is  coded in the PARM field, xxxxxxx indicates\n+                  the  key/class  that  is specified. When the N=, P= or X=\n+                  keytype  parameters  are  coded \"=xxxxxxx\" in the message\n+                  text is replaced by the word \"IS\". kk indicates the first\n+                  record  number in which the key/class was found. If the N\n+                  suboption  is  coded, then kkk indicates the first record\n+                  number   in  which  the  key/class  was  not  found.  mmm\n+                  indicates   the  total  number  of  records  output.  nnn\n+                  indicates the record number of the first record output.\n+\n+                 %SYSTEM ACTION:+Normal program termination.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL035   0102-93011-93032-0950-00033-00031-00000-CN03MQK\n)ATTR DEFAULT(%$_)\n)BODY\n%------------------------- HFSELECT MESSAGE SEL035E ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL035E LENGTH+POSITION  PARAMETERS EXCEED LRECL\n$\n$                 %EXPLANATION:$This message is produced when an L,P pair is\n$                  coded  in  the  JCL  such  that  L+P  is greater than the\n$                  LRECL+1  of  the  primary input file. It is also produced\n$                  when  V=(l,p...) is coded and an l,p pair has a sum (l+p)\n$                  that is greater than LRECL+1 of SYSIN.\n$                  Since HFSELECT ignores the first four physical bytes of a\n$                  variable length record, the l,p  pairs  refer to the data\n$                  portion of the record. Hence, for variable length records\n$                  in either file, the sum is compared  to  LRECL-4+1  since\n$                  the data portion of such records is four less than LRECL.\n$                  As  an  example,  if  an  L,P pair of 1,60 is used with a\n$                  variable  length  file  whose LRECL=64, the physical byte\n$                  referenced  would be 60+4=64 and the data byte referenced\n$                  would  be 60. L+P is always one more than the actual data\n$                  byte  referenced.  Note that L+P=61 and that LRECL-4+1 is\n$                  also 61. This would be a valid L,P pair.\n$\n$                 %SYSTEM ACTION:$Program terminates with return code of 8.\n$                 %PROGRAMMER RESPONSE:$Correct the length,position parameters.\n$    Press%PF03$to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL036   0101-93012-93013-1019-00031-00031-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL036I ---------------------------\n%COMMAND ===>_ZCMD\n% SEL036I nnn SYSIN RECORDS ALLOWED, mmm READ/GENERATED AND USED\n+\n+        %EXPLANATION:+ This  message  is produced with the E, G, P and  T\n+         options. nnn  is  the  maximum  number of records allowed.  For the  E\n+         option, the maximum number is 1000; for  the  G,  P and  T options\n+         the  maximum  number  is calculated  by the formula in Appendix D.2.4.\n+         For the  E, P and T options, is gives the number of records read from\n+         the SYSIN file and used for selection purposes. For the G option, it\n+         includes the number  of  records generated by HFSELECT. If  the\n+         number  of records submitted in SYSIN and/or generated from keys in\n+         SYSIN exceeds  the  maximum allowed,  only   the  first  nnn  records\n+         are  used  for selection. The rest of records are ignored.\n+\n+        %SYSTEM ACTION:+Normal program continuation.\n+\n+        %PROGRAMMER  RESPONSE:+ None,  if mmm is less than nnn. If mmm is equal\n+         to nnn, the number of keys entered/generated was either equal to or\n+         greater than the maximum allowable number.  If  the number of keys\n+         entered was greater than the  maximum,  HFSELECT must  be  run  more\n+         than once to select against all the desired keys.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL037   0101-93011-93013-1020-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL037E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL037E SYSIN RECORDS ON G OPTION :\n%                  1) NOT NUMERIC OR\n%                  2) ODD NO OF RECORDS OR\n%                  3) EVEN  NUMBERED RECORD OF A PAIR IS LESS THAN ODD\n%                     NUMBERED RECORD\n+\n+                 %EXPLANATION:+This message is produced if a critical error\n+                  occurs  in  SYSIN  when  the  G option is coded. For this\n+                  option, one and only one L,P pair must be coded. Either a\n+                  non-numeric  character appeared in the first L bytes of a\n+                  record  of  SYSIN,  SYSIN  contained  an  odd  number  of\n+                  records,  or  the  even-numbered  record of a record pair\n+                  contained  a  value  less than the value contained in the\n+                  odd-numbered record of the pair.\n+\n+                 %SYSTEM ACTION:+Program terminates with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the bad record of SYSIN.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL038   0101-93011-93013-1021-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL038E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL038E ON 'A' OPTION, THE J= PARAMETER DID NOT SPECIFY ANY OF THE\n%                  FOLLOWING OPERATORS CORRECTLY- EQ, NE, GT, GE, LT, LE, **\n+\n+                 %EXPLANATION:+This message indicates that a critical error\n+                  has occurred with the A option because an incorrect value\n+                  of  the  J= relation parameter was coded. The J= relation\n+                  parameter shows  the  desired comparison to be made. This\n+                  comparison relates the primary  select  field(s)  to  the\n+                  secondary  select  field(s).  The  valid relations are EQ\n+                  (equal),  NE  (not equal), GT (greater than), GE (greater\n+                  or  equal),  LT  (less than),  LE (less or equal),  or **\n+                  (force  a  match  of  all  records).  Also  valid  is the\n+                  omission  of  the  J= parameter causing a default to J=EQ\n+                  when the N suboption  is  not  specified and to J=NE when\n+                  the N suboption is specified.\n+\n+                 %SYSTEM ACTION:+Program terminates with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the J=relation parameter.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL039   0101-93011-93013-1022-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL039W----------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL039W OUTPUT  (SYSUTn)  RECFM/BLKSIZE  DOES  NOT  MATCH   INPUT\n%                  RECFM/BLKSIZE. OUTPUT RECFM/BLKSIZE ACCEPTED AS WRITTEN.\n+\n+                 %EXPLANATION:+ This  message  is  produced when the record\n+                  format of the output  file,  SYSUTn (n=2, 3,  4 or 5), is\n+                  the same as that of the corresponding  input file but the\n+                  RECFM   of  SYSUTn  is  not  the  same  as  that  of  the\n+                  corresponding input file; e.g., F vs  FB,  VBS vs V, etc.\n+                  The message is also produced  when  the  BLKSIZE  of  the\n+                  SYSUTn file differs from that  of the corresponding input\n+                  file, but is a valid value with  respect to the RECFM and\n+                  LRECL of SYSUTn. This is only a warning  message  and the\n+                  DCB parameters of the SYSUTn data  set  are  accepted  as\n+                  written.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER  RESPONSE:+ Check  DCB of SYSUTx to see if the\n+                  RECFM and BLKSIZE specified are those desired.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL040   0103-93011-93013-1023-00034-00041-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL040I ---------------------------\n%COMMAND ===>_ZCMD\n+\n%          SEL040I ddname  -  DSORG=dsorg,RECFM=recfm,LRECL=lrecl,BLKSIZE=\n%                  blksize,VOLSER=volser,DSN=dsn\n+\n+                 %EXPLANATION:+ This  message  is  always  produced for the\n+                  primary input file, and for the SYSIN file when the V\u00ddP\u00a8=\n+                  parameter is coded. ddname for the primary file is either\n+                  VSAMFILE, VSAMKEY, ISAMFILE, LIBFILE  or SYSUT1.  For the\n+                  secondary  file it is SYSIN.  (When  the  ALTDDS  control\n+                  statement  is  coded in the X0 intialization statement of\n+                  the  EXITS  file,  SYSUT1  and  SYSIN  may  be changed to\n+                  alternate ddnames. See Appendix D.2.2).  dsorg for ddname\n+                  VSAMFILE and VSAMKEY is VS; for ISAMFILE  it is IS or VS;\n+                  for LIBFILE it is PO.  For SYSUT1  the  dsorg  is  PS for\n+                  sequential  files (not PDS  members);  it is PO for files\n+                  that are PDS members; and it is DA if  the  file is coded\n+                  as * or DATA. recfm, lrecl and blksize have  their normal\n+                  meaning except  for  VSAMFILE  and VSAMKEY where recfm is\n+                  set  to  V,  lrecl  is  the  maximum  lrecl  of the  data\n+\n+    Press%PF08+to display next screen.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n  &ZPF08 = NEXT\n  &ZPF20 = NEXT\n  VPUT ( ZPF08 ZPF20 ) PROFILE\n)PROC\n   IF (&ZCMD \u00ac= &Z,NEXT)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL040B  0101-93012-93013-1023-00036-00036-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL040I (CONT'D) ------------------\n%COMMAND ===>_ZCMD\n%\n+                  component  of the cluster and  blksize is  the CI size of\n+                  the data component.  volser is  the first  or only volume\n+                  serial on which the input file  resides.  For *  or  DATA\n+                  input  files  volser  is  blank.  The  dsn is the full 44\n+                  character  file  name.  For  *  or DATA input files it is\n+                  JES2.JOBnnnnn.SImmmm where nnnn  is the number of the job\n+                  in  the  system.  For PDS members, it is that of the PDS.\n+                  For temporary  files, SYSyyddd.Thhmmss.RAnnn.jobname.dsn\n+                  is  the  dsn where:  yyddd is the Julian date of the run,\n+                  hhmmss is the  time at  data  set allocation, jobname is\n+                  obvious, and dsn is either the system assigned dsn (if no\n+                  dsn is coded in the JCL) or  the  user  assigned dsn when\n+                  &&dsn  is  coded.  The two ampersands are not printed. If\n+                  DUMMY is coded, the dsn is NULLFILE.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n+    Press%PF07+to display the previous screen.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n  &ZPF07 = LAST\n  &ZPF19 = LAST\n  &ZPF08 = DOWN\n  &ZPF20 = DOWN\n  VPUT ( ZPF07 ZPF08 ZPF19 ZPF20 ) PROFILE\n)PROC\n IF (&ZCMD \u00ac= &Z,LAST)\n       .MSG = SELMS004\n)END\n./ ADD NAME=SEL041   0101-93011-93013-1024-00029-00029-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL041E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL041E INVALID RECFM\n+\n+                 %EXPLANATION:+ This  message  is produced when the primary\n+                  input  file,  or the SYSIN file (when the V= parameter is\n+                  coded), or the MERGE file does not  have  a record format\n+                  of F, V or U or any  valid  combination  (e.g.,  FB,  VB,\n+                  VBS,  FBS, etc.).  It is also produced if the MERGE  file\n+                  format differs  from  the  primary  input file format, or\n+                  when RECFM=A|M is specified on a //MERGE DD SYSOUT.  This\n+                  message  is  also  produced  when  VSAMOUT is the primary\n+                  output file and the primary input file has a RECFM=U.\n+\n+                 %SYSTEM ACTION:+program termination with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+ Correct  the  RECFM  parameter  in\n+                  error,  or  convert  the  input  data set to an allowable\n+                  RECFM.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL042   0101-93011-93013-1026-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL042W ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL042W OUTPUT (SYSUTx)DCB PARAMETERS ABSENT OR RECORD TYPE/LRECL\n%                  DOESNT MATCH INPUT RECORD TYPE/LRECL.  INPUT RECFM/LRECL/\n%                  BLKSIZE USED.\n+\n+                 %EXPLANATION:+ This  message is produced when RECFM and/or\n+                  LRECL is not coded in the DCB of SYSUTx (x=2, 3, 4 or 5),\n+                  when  the record type coded for SYSUTx is not the same as\n+                  that  of  the corresponding input file, or when the LRECL\n+                  coded  for  SYSUTx  is  not  the  same  as  that  of  the\n+                  corresponding input file.\n+\n+                 %SYSTEM  ACTION:+ The  program  uses  the RECFM, LRECL and\n+                  BLKSIZE   of  the  corresponding  input  file  for  these\n+                  parameters of SYSUTx.\n+\n+                 %PROGRAMMER  RESPONSE:+Check that the RECFM and BLKSIZE of\n+                  the  input  file  are those desired for SYSUTx. Note that\n+                  LRECL  of  SYSUTx  must  in  all cases be the same as the\n+                  corresponding input file (unless DCB=OPTCD=U is coded).\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL043   0101-93011-93013-1028-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL043W ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL043W OUTPUT (SYSUTx) BLKSIZE  NOT INTEGRAL  MULTIPLE  OF INPUT\n%                  LRECL (RECFM=FB) OR  BLKSIZE  NOT  AT LEAST  4  MORE THAN\n%                  LRECL  (RECFM=V) OR  BLKSIZE  NOT  EQUAL  TO INPUT  LRECL\n%                  (RECFM=U OR F UNBLOCKED). OUTPUT BLKSIZE CHANGED TO INPUT\n%                  BLKSIZE.\n+\n+                 %EXPLANATION:+This message is produced when the BLKSIZE of\n+                  SYSUTx  (x=2,  3,  4  or  5)  does  not  meet  the system\n+                  requirements  for  the BLKSIZE of this file. The possible\n+                  errors are listed in the message text.\n+\n+                 %SYSTEM  ACTION:+ The  program  uses  the  BLKSIZE  of the\n+                  corresponding input file for this parameter of SYSUTx.\n+\n+                 %PROGRAMMER  RESPONSE:+Check that the RECFM and/or BLKSIZE\n+                  used  for  SYSUTx  are those desired. The LRECL of SYSUTx\n+                  must  in all cases be the same as the corresponding input\n+                  file (unless DCB=OPTCD=U is coded).\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL045   0101-93011-93013-1028-00025-00025-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL045E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL045E SYSUT1 OR (V)SYSIN DD STATEMENT MISSING\n+\n+                 %EXPLANATION:+ This  message  is  produced when no primary\n+                  input  file  DD statement is coded in the JCL, or when no\n+                  SYSIN DD statement is coded for an option that requires a\n+                  SYSIN  file  or, with  the  A option, when the CONVERT DD\n+                  statement  is  coded  but  the SYSIN DD statement is not.\n+                  The V option requires the VSYSIN file DD statement.\n+\n+                 %SYSTEM ACTION:+Program terminates with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+Add the missing DD statement to the\n+                  JCL.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL046   0101-93012-93013-1029-00022-00022-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL046E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL046E W SUBOPTION REQUESTED BUT INPUT DATA SET NOT TAPE OR VSAM\n+\n+                 %EXPLANATION:+  This   message  is  produced  when  the  W\n+                  suboption is coded in the JCL and the input file is not a\n+                  tape file or a VSAM file.\n+\n+                 %SYSTEM ACTION:+Program terminates with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+ Delete the W suboption or make the\n+                  input file a one volume fixed format tape or VSAM file.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL048   0101-93012-93013-1030-00024-00024-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL048I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL048I TOTAL NUMBER OF SELECTED SYSIN RECORDS OUTPUT = nnn\n+\n+                 %EXPLANATION:+This message is produced when the V=(l,p...)\n+                  parameter  is coded with the A or M option and the SYSUT4\n+                  DD  statement  was  coded  in  the  JCL. This is a normal\n+                  system  message  for these options. nnn is a count of the\n+                  SYSIN  records  that  caused  one  or  more records to be\n+                  selected from the primary input file.\n+\n+                 %SYSTEM ACTION:+Normal program termination.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL049   0101-93012-93013-1030-00024-00024-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL049I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL049I TOTAL NUMBER OF NON-SELECTED SYSIN RECS OUTPUT = nnn\n+\n+                 %EXPLANATION:+This message is produced when the V=(l,p...)\n+                  parameter  is coded with the A or M option and the SYSUT5\n+                  DD  statement  is coded in the JCL. It is a normal system\n+                  message  for  these  options. nnn is a count of the SYSIN\n+                  records  that  did  not  cause any records to be selected\n+                  from the primary input file.\n+\n+                 %SYSTEM ACTION:+Normal program termination.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL050   0101-93012-93013-1030-00026-00026-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL050E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL050E V= PARAMETER VALID ONLY ON  M  OR  T  OPTIONS AND MUST BE\n%                  CODED ON 'A' AND 'ML' OPTION\n+\n+                 %EXPLANATION:+This message is produced when the V=(l,p...)\n+                  parameter is coded with any option other than the A, M or\n+                  T.  The coding of the V=(l,p...) parameter for any option\n+                  other  than  A,  M  or  T is a critical error. If the \"A\"\n+                  or \"ML\" option is  requested  the  V=(l,p,...)  parameter\n+                  must be coded.\n+\n+                 %SYSTEM ACTION:+Program terminates with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+ Use the A,M or T option, or delete\n+                  the V=(l,p...) parameter from the PARM.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL051   0101-93012-93013-1031-00024-00024-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL051E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL051E SYNTAX ERROR DETECTED IN THE V= PARM\n+\n+                 %EXPLANATION:+This message is produced when the V=(l,p...)\n+                  parameter is incorrectly coded. It must  have opening and\n+                  closing  parentheses, must be followed by  a  comma,  and\n+                  must  have  from one to 3 l,p pairs  (an  even number  of\n+                  values coded between the parentheses). Each value of l or\n+                  p must be 8 numeric characters or less.\n+\n+                 %SYSTEM ACTION:+Program terminates with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the V=(l,p...) parameter\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL052   0101-93012-93013-1031-00029-00029-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL052W ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL052W ONE OR MORE UNSUCCESSFUL  ATTEMPTS  TO  STORE  A  RECORD/\n%                  MEMBER INTO VSAMOUT/LIBOUT  FILE  WITH A  DUPLICATE  KEY/\n%                  MEMBER NAME.\n+\n+                 %EXPLANATION:+This message is produced as  a  warning when\n+                  an attempt is made  to  store  a  record/member  into the\n+                  VSAMOUT/LIBOUT  file  but  its  key/member  name  already\n+                  exists on the file  (and  the  replace option of MEMSYSIN\n+                  was not coded for a member).  The  record/member will not\n+                  be written but processing will continue.  This  situation\n+                  may occur when adding records/members  to  a pre-existing\n+                  file  or  when  creating  a VSAM file from non-VSAM input\n+                  containing records with duplicate keys.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL053   0101-93012-93013-1032-00025-00025-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL053E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL053E KEY LENGTHS FOR THE PRIMARY AND SYSIN FILES DO NOT MATCH\n+\n+                 %EXPLANATION:+This message is produced when the V=(l,p...)\n+                  parameter  has been coded and the sum of the l parameters\n+                  does not match the sum of the L parameters i.e. the total\n+                  length  of  the select field(s) on the primary input file\n+                  does not match the total length of the select field(s) on\n+                  the SYSIN file.\n+\n+                 %SYSTEM ACTION:+Program terminates with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+ Correct  the  length parameters so\n+                  that the sum of the l's equals the sum of the L's.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL054   0101-93012-93013-1032-00024-00024-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL054I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL054I JOBNAME/STEPNAME/PROCSTEPNAME=xxx\n+\n+                 %EXPLANATION:+ This message  is  always  produced.  If the\n+                  HFSELECT  step  is   not   in   a   procedure,    xxx  is\n+                  jjjjjjjjssssssss.  If  it  is  in  a  procedure,  xxx  is\n+                  jjjjjjjjppppppppssssssss, where jjjjjjjj is the  jobname,\n+                  ssssssss   is   the   stepname   and   pppppppp  is   the\n+                  procstepname.\n+\n+                 %SYSTEM ACTION:+normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL055   0101-93012-93013-1033-00028-00028-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL055I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL055I SELECTION PROCESSING WILL BEGIN AFTER RECORD nnn\n+\n+                 %EXPLANATION:+ This  message  is produced when the B=begin\n+                  parameter  has  been  coded in the PARM field. nnn is the\n+                  record  number  after which the selection processing will\n+                  begin.  The  first  nnn  records  will  be  processed but\n+                  rejected.\n+\n+                  For the string replacement form of the E option, when '@'\n+                  is coded in front of the replacement string, the  B=begin\n+                  parameter only controls the start of the string  replace-\n+                  ment and does NOT affect selection processing.\n+\n+                 %SYSTEM ACTION:+normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL057   0101-93012-93013-1034-00031-00031-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL057I ---------------------------\n%COMMAND ===>_ZCMD\n+\n%          SEL057I RANDOM RECORD SELECT OPTION, SEED= nnn     or\n%                     RANDOM ENCRYPTION OPTION, SEED= nnn\n%\n+                 %EXPLANATION:+ This  message is produced when the R option\n+                  has  been  requested, no N,K pairs were coded in the PARM\n+                  field   and   the   first   record   of   SYSIN  contains\n+                  RANDOM\u00dd=seed\u00a8 beginning in byte 1 of  the record.  It  is\n+                  also produced when RANDOM\u00dd=seed\u00a8 is coded  in the CONVERT\n+                  file.  The  seed  is  the  parameter  that determines the\n+                  pseudo-random number  sequence  that  is  generated.  The\n+                  same seed  will always generate the same sequence for the\n+                  same range limits.  The seed default  is 8193. If an even\n+                  number is entered as the seed the program will add one to\n+                  the seed to make it odd. Hence, nnn  in  the message text\n+                  is not necessarily the seed  coded  (if  such  a seed had\n+                  been coded).\n+\n+                 %SYSTEM ACTION:+normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL060   0101-93012-93013-1034-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL060I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL060I R ERROR MEANS SYSIN RECORD\n%                  1. EXCEEDS 15 DIGITS,\n%                  2. NUMBER NOT FOLLOWED BY SPACE,\n%                  3. NOT NUMERIC,\n%                  4. OUT OF SEQUENCE OR,\n%                  5. BELOW SELECT RANGE\n+\n+                 %EXPLANATION:+ This informational message is produced with\n+                  the  R  option  when  selection  of  records is by record\n+                  numbers  listed  in  SYSIN. It is always produced in this\n+                  form  of the R option, together with message SEL062I.  If\n+                  an incorrect number  is  specified  on  a  SYSIN  record,\n+                  SEL062I  indicates the  number in error, and this message\n+                  text gives all possible causes.\n+\n+                 %SYSTEM ACTION:+normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL062   0101-93012-93013-1035-00027-00027-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL062I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL062I xxx             action\n+\n+                 %EXPLANATION:+ This informational message is produced with\n+                  the  R  option  when  selection  of  records is by record\n+                  numbers  listed  in  SYSIN.  In  this form of the option,\n+                  message SEL061I is printed as a header and then  one copy\n+                  of this message is printed for each record number entered\n+                  in SYSIN. xxx is the actual value of the record in  SYSIN\n+                  and \"action\", either REC OUTPUT or ERROR,  describes  the\n+                  disposition of the record named by xxx.\n+\n+                 %SYSTEM ACTION:+normal program continuation.\n+\n+                 %PROGRAMMER  RESPONSE:+ If  necessary, correct the numbers\n+                  that are in error and rerun the job.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL063   0101-93012-93013-1037-00025-00025-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL063E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL063E VSAM ERROR, FDBK CODE=nnnn\n+\n+                 %EXPLANATION:+This critical error message is produced when\n+                  VSAMxxx  is coded as the ddname of the primary  input  or\n+                  output  file  and  the system failed in returning records\n+                  from the VSAM file. The meaning of the FDBK errors may be\n+                  found  in  the IBM MACRO INSTRUCTIONS FOR VSAM DATA  SETS\n+                  manual.\n+\n+                 %SYSTEM ACTION:+Program termination with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+ Correct  the error relating to the\n+                  VSAM file and rerun the job.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL064   0101-93012-93013-1039-00024-00024-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL064E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL064E PROGRAM  ERROR- CALL  HFSELECT  VENDOR  FOR   PROGRAMMING\n%                  SUPPORT\n+\n+                 %EXPLANATION:+This critical error message is produced when\n+                  a  software  error  has occurred while running HFSELECT.\n+\n+                 %SYSTEM  ACTION:+ Program  termination with return code of\n+                  0Cx, where x =1-7,9,B,C or F.\n+\n+                 %PROGRAMMER  RESPONSE:+ Contact  your  HFSELECT vendor for\n+                  immediate   programming   support.  Retain  all  JCL  and\n+                  SYSUDUMP for program analysis.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL068   0101-93012-93013-1042-00032-00032-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL068E ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL068E SYSUT1 OR SYSIN DD STATEMENT  SPECIFIES  AN INCORRECT DSN\n%                  OR VOLSER, OR DISK I/O ERROR\n+\n+                 %EXPLANATION:+ This  critical error message indicates that\n+                  either an IEC149I 813-04 ABEND or an IEC143I 213-04 ABEND\n+                  was  started. The IEC message will be printed in the HASP\n+                  listing, but the normal dump resulting from such an ABEND\n+                  is supressed by the program and this message is produced.\n+                  The 813-04 return-code means that a tape was used and the\n+                  data  set  name (DSN) or volume serial number (VOLSER) in\n+                  the SYSUT1 or SYSIN DD statement of the JCL did not match\n+                  the  DSN  in the tape label. The 213-04 return-code means\n+                  that  a  disk data set was used and an I/O error occurred\n+                  or the DSN or VOLSER parameters on the DD statement or in\n+                  the catalog is incorrect.\n+\n+                 %SYSTEM ACTION:+Program terminates  with return code of 8.\n+                  HASP ABEND message printed.\n+                 %PROGRAMMER  RESPONSE:+ Verify that the SYSUT1 or SYSIN DD\n+                  statement specifies the correct DSN and VOLSER. If an I/O\n+                  or catalog error occurred consult your system programmers.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n                   programmers.\n./ ADD NAME=SEL069   0101-93012-93013-1043-00031-00031-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL069A ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL069E IF  COMPLETION  CODE=80A  OR  106-C,   INSUFFICIENT  MAIN\n%                  STORAGE WAS REQUESTED IN REGION PARAMETER ON EXEC CARD\n+\n+                 %EXPLANATION:+ This  critical error message indicates that\n+                  either a return code of 80A or 106-C was generated by the\n+                  system  and  an ABEND occurred. The normal dump resulting\n+                  from  such an ABEND was supressed by the program and this\n+                  message  generated.  If the HASP listing shows an 80A the\n+                  data  set  buffers  and  the  program  required more main\n+                  storage  than  was  allotted  to this step. If a 106-C is\n+                  listed  in  the HASP, the table space required by certain\n+                  options   was   not  available.  See  Section  2,  SYSTEM\n+                  CONFIGURATION,  of the documentation for more information\n+                  about the main storage requirements.\n+\n+                 %SYSTEM ACTION:+Program terminates with return code 80A.\n+                 %PROGRAMMER  RESPONSE:+ Increase the  REGION parameter, or\n+                  code  a  REGION parameter on the JOB or EXEC statement in\n+                  the JCL or decrease, in the DD statements of the JCL, the\n+                  number  of  buffers  requested  of  or  allocated  by the\n+                  system.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL070   0101-93012-93013-1047-00028-00028-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL070E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL070E ON E OPTION- COLUMN  SPECIFICATIONS  EXCEED  LRECL OR ARE\n%                  NOT IN ASCENDING ORDER\n+\n+                 %EXPLANATION:+ This  critical error message indicates that\n+                  when   the   E   option   was  specified,  the  F,T  pair\n+                  specification(s)   were   incorrect.   The   F  parameter\n+                  specifies  the  starting  byte of the record region to be\n+                  searched  and the T specifies the end of this region. One\n+                  of the F or T parameters was greater in value than LRECL,\n+                  or  the F,T pairs are all in ascending order in the PARM\n+                  field.\n+\n+                 %SYSTEM ACTION:+Program terminates  with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+ Correct  the  F  or T parameter in\n+                  error.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL071   0101-93012-93013-1052-00027-00027-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL071E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL071E KEYWORD ERROR- INVALID OR DUPLICATE KEYWORD SPECIFICATION\n+\n+                 %EXPLANATION:+ This  critical error message indicates that\n+                  an  invalid  keyword  parameter  or  a  duplicate keyword\n+                  parameter  was  specified  in  the  PARM field. The valid\n+                  keyword  specifications  are:  B=,  E=, J=, V= or Y=. Any\n+                  other   keyword  parameter  specifications  are  invalid.\n+                  Listing the same keyword parameter more than once is also\n+                  invalid.  These parameters may, however, be listed in any\n+                  order.\n+\n+                 %SYSTEM ACTION:+Program terminates  with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the keyword parameter in the\n+                  PARM.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL072   0101-93012-93013-1053-00031-00031-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL072I ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL072I IGNORE HASP MESSAGE IEC146I 513-04 (IF PRESENT),  PROGRAM\n%                  CONTINUES TO NORMAL END OF JOB\n+\n+                 %EXPLANATION:+ This  informational  message indicates that\n+                  the  A  option  was  coded in the PARM field and the same\n+                  tape  data  set  was  coded  in  the  SYSUT1 and SYSIN DD\n+                  statements of the JCL, or that SYSIN was not coded in the\n+                  JCL  at  all. The A option may be used to match fields in\n+                  the same record of a data set by specifying the same data\n+                  set  for  the primary input file and for SYSIN, or by not\n+                  coding  SYSIN.  The  operating system does not permit the\n+                  same tape data set to be coded in two ddnames in the same\n+                  step.  If  the  same  tape data set is coded in SYSIN and\n+                  SYSUT1,  an  IEC146I  513-04  ABEND  occurs. The program,\n+                  however, intercepts this ABEND, generates message SEL072I\n+                  and allows normal program processing to continue. Message\n+                  SEL072I  will  also  be  generated  whenever SYSIN is not\n+                  coded with the A option.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+                 %PROGRAMMER RESPONSE:+None.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL073   0101-93012-93013-1054-00031-00031-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL073E ---------------------------\n%COMMAND ===>_ZCMD\n%  SEL073E IF COMPLET CODE=B37-E37 INSUFFICIENT SPACE WAS ALLOCATED/ AVAILABLE\n%          TO AN OUTPUT DISK DATA SET\n+\n+         %EXPLANATION:+This critical error message indicates that either an\n+          IEC030I B37-04 orIEC031I D37-04 or IEC032I E37-04 orIEC033I C37-04\n+          message was generated by the operating system. The resulting ABEND\n+          and the corresponding dump were suppressed by the program and this\n+          message produced. The HASP listing of the program contains the system\n+          message  that was generated. These messages mean that one of the\n+          output data sets created by the program was not allocated enough\n+          space; that the system could not find enough free space to allocate\n+          when the file required secondary allocation(s), or that all  fifteen\n+          secondary allocations were made and another allocation was required.\n+\n+         %SYSTEM  ACTION:+Program terminates with a return code of x37, x=B, C,\n+          D or E.\n+\n+         %PROGRAMMER  RESPONSE:+ Increase  the space allocation, or the SPACE\n+          parameter of the JCL, for the appropriate data set.  The IEC message\n+          includes the DSN of the data set in question.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL074   0101-93012-93013-1054-00024-00024-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL074I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL074I (C)  COPYRIGHT SEPTEMBER 1981 BY  M. KARLIN,  N. LINDNER,\n%                  I. EISENSTEIN TODAY'S DATE yyddd  HFSELECT RELEASE a.b\n%                  mm/dd/yy\n+\n+                 %EXPLANATION:+  This   informational   message  is  always\n+                  generated as the first message in the SYSPRINT data  set.\n+                  yyddd is the run date, a.b is the  HFSELECT  release  and\n+                  mm/dd/yy is the date of assembly.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+none\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL075   0101-93012-93013-1055-00028-00028-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL075E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL075E ERROR DUE TO AN ABEND IN A PREVIOUS JOB STEP OR NO VOLSER\n%                  SPECIFIED\n+\n+                 %EXPLANATION:+ This  critical error message indicates that\n+                  the  system  message  IEC145I  413-18  was generated. The\n+                  resulting ABEND and dump were intercepted by the program,\n+                  and this message generated. The system message means that\n+                  an  input  data  set had no volume serial number (VOLSER)\n+                  specified  in  its  DD  statement  in  the  JCL or that a\n+                  previous  step  in  the  same job, which was to create an\n+                  input data set to HFSELECT, failed.\n+\n+                 %SYSTEM ACTION:+Program terminates  with return code of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+Supply a VOLSER for the data set in\n+                  question, or correct the prior step that failed.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL076   0105-93012-93013-1109-00034-00057-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL076E ---------------------------\n%COMMAND ===>_ZCMD\n% SEL076E supplementary text,jobname,stepname,unit address, device\n%         type,ddname,operation attempted,error description,device dependent\n%         information,access method\n%         ----t----1----t----2----t----3----t----4----t----5 ...\n+\n+        %EXPLANATION:+This error message indicates that the system encountered\n+         an uncorrectable I/O error when processing one  of the input or output\n+         files. This  message is produced  by  the SYNADERR routine and is\n+         printed in the SYSOUT data set. It is followed by a printout of  the\n+         bad data block if the block can be read and the supplementary text is\n+         NUMBER OF BYTES READ FROM BLOCK = nnn (when n can be determined). If\n+         the  block  could  not  be read,  the supplementary text is \"UNABLE TO\n+         RECOVER RECORDS FROM BAD BLOCK\".  This message is produced each time a\n+         bad block is encountered.\n+\n+         The  message  fields have the following meanings: jobname and stepname\n+         meanings  are obvious. unit address is the three  byte physical\n+         address of the unit, consisting of the  channel, control  unit, and\n+         unit numbers. ddname is obvious.  operation attempted  indicates  the\n+\n+    Press%PF08+to display next screen.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n  &ZPF08 = NEXT\n  &ZPF20 = NEXT\n  VPUT ( ZPF08 ZPF20 ) PROFILE\n)PROC\n   IF (&ZCMD \u00ac= &Z,NEXT)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL076B  0101-93012-93013-1056-00036-00036-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL076E (CONT'D) ------------------\n%COMMAND ===>_ZCMD\n+         actual I/O operation  (GET, PUT, OPEN, WRITE, etc.) during which the\n+         uncorrectable error occurred. error description is a short statement\n+         of the error condition (WRONG LENGTH RECORD,  EQUIPMENT CHECK, etc.).\n+         The device dependent field is described for each of the following:\n+\n+         unit record device - asterisks\n+         magnetic tape      - relative block number in decimal\n+         direct  access     - actual  track  address  and  block\n+                              number (BBCCHHR in hex)\n+\n+        %SYSTEM  ACTION:+ Each  time an uncorrectable I/O error is encountered\n+         this  message is produced, together with the printout of  the bad\n+         block if possible. A ruler line  is always printed with this message.\n+         The bad block is output only with the first 5 occurrences of this\n+         message. If one or more of these errors occurs  the  program generates\n+         a return  of  8  unless  overridden by  a subsequent error return code\n+         (80A, B37, D37, etc.).\n+\n+        %PROGRAMMER RESPONSE:+Use all output and statistics from the run with\n+         care since at least one bad block was encountered on one of the files.\n+    Press%PF03+to END.\n+    Press%PF07+to display the previous screen.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n  &ZPF07 = LAST\n  &ZPF19 = LAST\n  &ZPF08 = DOWN\n  &ZPF20 = DOWN\n  VPUT ( ZPF07 ZPF08 ZPF19 ZPF20 ) PROFILE\n)PROC\n IF (&ZCMD \u00ac= &Z,LAST)\n       .MSG = SELMS004\n)END\n./ ADD NAME=SEL077   0101-93012-93013-1056-00027-00027-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL077E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL077E AN UNCORRECTABLE I/O ERROR WAS ENCOUNTERED. UP TO 5 BAD\n%                  BLOCKS WILL BE PRINTED.\n+\n+                 %EXPLANATION:+ This  error  message  is printed after  the\n+                  maximum number of uncorrectable I/O errors, which invoked\n+                  the SYNADERR routine, have been encountered. The  maximum\n+                  number depends on the EROPT subparameter coded on the DCB\n+                  parameter of the SYSOUT DD statement.\n+\n+                 %SYSTEM  ACTION:+The program terminates with a return code\n+                  of 8.\n+\n+                 %PROGRAMMER  RESPONSE:+ Examine  message  SEL076E  for the\n+                  cause  of  the  errors  and  take  appropriate  action to\n+                  correct the defect.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL078   0101-93012-93013-1057-00024-00024-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL078I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL078I PRE-SORTED RECORD NUMBERS GENERATED BY RANDOM OPTION or\n%                      ENCRYPTION CODE TABLE GENERATED BY RANDOM OPTION\n+\n+                 %EXPLANATION:+This message is displayed in the SYSOUX data\n+                  set  when  the RANDOM keyword is coded in a control card.\n+                  It is the header for the listing of the random numbers in\n+                  reverse  order  of  generation.  The  listing is  in dump\n+                  format with the numbers in HEX.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL079   0101-93012-93013-1057-00025-00025-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL079I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL079I SORTED RECORD NUMBERS GENERATED BY RANDOM OPTION\n+\n+                 %EXPLANATION:+This message is displayed in the SYSOUX data\n+                  set  when  the random form of the R option is used. It is\n+                  the  header  for  the  listing  of  the random numbers in\n+                  ascending  order. The listing is in dump format with  the\n+                  numbers in HEX. This listing  shows  the  record  numbers\n+                  selected in ascending number order and also clearly shows\n+                  any duplicate numbers that have been generated.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL080   0101-93012-93013-1057-00022-00022-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL080I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL080I END OF PRIMARY INPUT AND SYSIN FILES REACHED\n+\n+                 %EXPLANATION:+This message is always generated when a file\n+                  matching  option  (A  or  M) is used, the V= parameter is\n+                  specified, and the ends of both the  primary  input  file\n+                  and SYSIN were reached.\n+\n+                 %SYSTEM ACTION:+Normal program termination.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL081   0101-93012-93013-1058-00031-00031-00000-CN03MQK\n%------------------------- SYNCSORT MESSAGE SEL081I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL081I PROCESSING ENDED DUE TO E= PARAMETER\n+\n+                 %EXPLANATION:+ This  message indicates that processing has\n+                  halted  because  the  record  number  specified in the E=\n+                  parameter has been processed.  For  the  A  or  M options\n+                  when the V=(l,p...) parameter is  coded,  if  either  the\n+                  primary or the secondary input file has  not  ended,  the\n+                  remaining records of the unfinished input file are output\n+                  to the corresponding reject output file (SYSUT3 or SYSUT5\n+                  respectively), if that ddname was coded in the JCL.\n+\n+                  For the string replacement form of the E option, when '@'\n+                  is coded in front of the replacement  string,  the  E=end\n+                  parameter only controls the end of string replacement and\n+                  does NOT affect selection processing.\n+\n+                 %SYSTEM ACTION:+Normal program termination.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+                  SYSTEM ACTION: Normal program termination.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL082   0101-93012-93013-1059-00026-00026-00000-CN03MQK\n%------------------------- SYNCSORT MESSAGE SEL082I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL082I COUNT SATISFIED BEFORE END OF PRIMARY INPUT FILE\n+\n+                 %EXPLANATION:+ This  message indicates that processing has\n+                  halted  because  the  J= count parameter specified in the\n+                  PARM  has  been  satisfied  for  the option and suboption\n+                  specified.  The  J= count parameter may specify the total\n+                  number  of  records  to  be  selected,  the  number to be\n+                  selected  against  each key, pairs of keys, etc. Refer to\n+                  the  detailed  descriptions  of the options for the exact\n+                  meaning of this parameter.\n+\n+                 %SYSTEM ACTION:+Normal program termination.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL085   0101-93012-93013-1059-00031-00031-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL085I ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL085I ddname -DSORG=Px,RECFM=recype,LRECL=lrecl,BLKSIZE=blksize,\n%                  VOLSER=volser,DSN=dsn\n+\n+                 %EXPLANATION:+ This  message  lists  the attributes of the\n+                  output  file(s).  One message is produced for each output\n+                  ddname coded in the JCL.  DSORG=PS for all ddnames except\n+                  for ddname LIBOUT (DSORG=PO). The rectype is  F, V  or  U\n+                  with no secondary type indicated (e.g., blocked, spanned,\n+                  etc).  All the other parameters are explained in  message\n+                  SEL040I. For SYSOUT files lrecl=133,blksize=5320,  volser\n+                  is blank, and the dsn  is JESn.JOBjobnumber.SOnnnn  where\n+                  jobnumber is the system assigned number of the  job.  For\n+                  a file output to a TSO terminal (ALLOC DD(SYSUTn)  DS(*))\n+                  the volser is blank and the dsn is NULLFILE.  For  the  V\n+                  option, SEL085I is not produced.   For  ddnames MEMBNAME,\n+                  SYSOUX and SYSPRINT the  recfm  field  has  no meaningful\n+                  information.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL087   0101-93012-93013-1059-00021-00021-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL087I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL087I CONVERT KEY = xxxxxxxx\n+\n+                 %EXPLANATION:+ This  message  is produced for each control\n+                  record in the CONVERT file. It  repeats,  for  the user's\n+                  convenience, the characters coded in the record.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL088   0101-93012-93013-1100-00023-00023-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL088I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL088I nnn OCCURRENCES OF xxxx CHANGED TO yyyy\n+\n+                 %EXPLANATION:+ This  message is produced when the E option\n+                  is used and the $ or @ change string replacement is coded\n+                  in the CONVERT DD statement. nnn is the number of changes\n+                  made,  xxxx  is  the  original  string  and  yyyy  is the\n+                  replacement string.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL089   0101-93012-93013-1101-00031-00031-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL089E ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL089E LIBOUT OR LIBFILE DIRECTORY ERROR, MEMBER=xxxxxxxx\n+\n+                 %EXPLANATION:+This message is produced when the LIBFILE or\n+                  LIBOUT DD statement is coded and  a  directory  error  is\n+                  encountered. xxxxxxxx is the member name  of  the  member\n+                  being processed when the error occurred.  Possible causes\n+                  for the error are:\n+                  1. DISP=SHR was coded on the  LIBOUT  DD  statement  when\n+                     member replacement was  requested via MEMSYSIN  (DISP=\n+                     NEW, MOD or OLD must be coded for member replacement)\n+                  2. insufficient number of directory blocks on LIBOUT\n+                  3. insufficient REGION was specified in the JCL\n+                  4. permanent I/O error was  detected (probably the LIBOUT\n+                     file was allocated as physical sequential)\n+                  5. SYNAD error routine was invoked- check message SEL076E\n+                     for diagnostic information\n+\n+                 %SYSTEM ACTION:+Program terminates with return code 8.\n+\n+                 %PROGRAMMER RESPONSE:+See above for possible responses.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL093   0102-93012-93013-1102-00031-00031-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL093I ---------------------------\n%COMMAND ===>_ZCMD\n%          SEL093I MEMBER = xxxxxxxx, NUMBER OF SELECTED RECORDS = nnnn\n+\n+                 %EXPLANATION:+ This  message is produced when the MEMSYSIN\n+                  DD statement or MEMBNAME DD DUMMY is coded. To  have this\n+                  message for every member of LIBFILE, code\n+\n+                        //MEMSYSIN  DD *\n+                        *    control statement requesting all members\n+                        /*\n+\n+                  xxxxxxxx is the member name but is  blank if  no  records\n+                       have been selected from the member.\n+                  nnnn is the number of records selected from xxxxxxxx\n+                  nnnn = ********** indicates that member  xxxxxxxx already\n+                       exists on the LIBOUT file and was  not  replaced  by\n+                       the like-named member from  LIBFILE.  (For  replace-\n+                       ment to occur, code (R) following the member name in\n+                       MEMSYSIN).\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+                 %PROGRAMMER RESPONSE:+None.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL094   0102-93012-93013-1102-00021-00021-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL094I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL094I TOTAL NUMBER OF MEMBERS ADDED/REPLACED = nnnn\n+\n+                 %EXPLANATION:+ This message is produced when the LIBOUT DD\n+                  statement is coded. nnnn is the number of  members  added\n+                  or replaced in the LIBOUT file.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL095   0102-93012-93013-1102-00020-00020-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL095E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL095E SYSOUT NOT ALLOWED FOR LIBOUT OR VSAMOUT DD\n+\n+                 %EXPLANATION:+This message is produced if SYSOUT  is coded\n+                  on the LIBOUT or VSAMOUT DD statement.\n+\n+                 %SYSTEM ACTION:+Program termination with condition code 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the DD statement.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL096   0101-93012-93013-1103-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL096E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL096E INVALID VSYSIN CONTROL STATEMENT ON V OPTION\n+\n+                 %EXPLANATION:+ This  message  is  produced  if  any of the\n+                  following errors has  occurred in the VSYSIN file:\n+                      an invalid dsn was coded\n+                      a dsn with an incorrect full or generic member name\n+                           was coded\n+                      an invalid dsn string search was specified (delimiter\n+                           exclamation points were coded incorrectly)\n+                      the VOL= statement was incorrectly coded or no\n+                           volser(s) was coded on the VOL= statement\n+                      on the first control statement of the extended V\n+                           option (parm specification) no ending quote\n+                           was coded or a null parm was coded (two\n+                           contiguous quotes) or the V option was requested\n+\n+                 %SYSTEM ACTION:+Program terminates with condition code 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the VSYSIN records.\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL097   0101-93012-93013-1103-00021-00021-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL097I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL097I xxxxxxx\n+\n+                 %EXPLANATION:+This message is produced  with the  V option\n+                  and lists the control statements (VOL and/or dsn records)\n+                  entered in the VSYSIN file.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL099   0100-93187-93187-1847-00021-00021-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL099I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL099I xxxxxxxx\n+\n+                 %EXPLANATION:+ This  message  is produced for each control\n+                  record in the EXITS file when an error is encountered  in\n+                  a control statement.\n+\n+                 %SYSTEM ACTION:+Program termination.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the error in the EXITS file.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL100   0101-93012-93013-1104-00022-00022-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL100I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL100I NUMBER OF FMT1 DSCBS PROCESSED = nnnn\n+\n+                 %EXPLANATION:+This message is produced  with the  V option\n+                  and indicates the number of VTOC records (DSCBs) HFSELECT\n+                  has processed  to  find  DSNs  that  match  the selection\n+                  criteria.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL101   0101-93012-93013-1104-00022-00022-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL101I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL101I NUMBER OF FMT1 DSCBS SELECTED  = nnnn\n+\n+                 %EXPLANATION:+This message is produced  with the  V option\n+                  and indicates the number of VTOC records  (DSCBs of DSNs)\n+                  that match  the selection criteria  for  datasets without\n+                  member specification.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL102   0101-93012-93013-1104-00022-00022-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL102I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL102I NUMBER OF PDS FILES PROCESSED  = nnnn\n+\n+                 %EXPLANATION:+This message is produced  with the  V option\n+                  and indicates the number of VTOC records  (DSCBs of DSNs)\n+                  that  match  the  selection  criteria  for  datasets with\n+                  member specification.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL103   0101-93012-93013-1105-00021-00021-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL103I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL103I NUMBER OF PDS MEMBERS PROCESSED= nnnn\n+\n+                 %EXPLANATION:+This message is produced  with the  V option\n+                  and indicates  the  number  of  members  processed in the\n+                  selected PDSs.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL104   0101-93012-93013-1105-00020-00020-00000-CN03MQK\n%------------------------- SYNCSORT MESSAGE SEL104I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL104I NUMBER OF PDS MEMBERS SELECTED = nnnn\n+\n+                 %EXPLANATION:+This message is produced  with the  V option\n+                  and indicates the number of PDS members selected.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL105   0101-93012-93013-1106-00024-00024-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL105I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL105I NUMBER OF TOTAL RECORDS OUTPUT = nnnn\n+\n+                 %EXPLANATION:+This message is produced  with the  V option\n+                  and  indicates the total number of SYSUT2 output records.\n+                  If J= count has not been specified nnnn is the sum of the\n+                  totals  in  messages  SEL101I  and  SEL104I.  If J= count\n+                  and/or a keytype has been specified in the PARM, nnnn may\n+                  be less than this sum.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL106   0101-93012-93013-1106-00030-00030-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL106W ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL106W KEYS BYPASSED DUE TO ERRORS = nnnn\n+\n+                 %EXPLANATION:+ This  warning message  is produced with the\n+                  Catalog search form of the  V  option  and  indicates the\n+                  total  number  of  VSYSIN  records  that  have  not  been\n+                  processed due to errors. Typical errors include:\n+                  - specifying invalid wildcards (% or !)\n+                  - specifying wildcards in the high-order qualifier  of a\n+                    dsn\n+                  - specifying generic  dsn  records  which  would generate\n+                    more than 1455 entries by the catalog search routine\n+                  - specifying a dsn which results  in a security violation\n+                    (user does not have access to catalog to be searched)\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+If nnn is not zero, identify and\n+                  correct the dsn keys in error in VSYSIN.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=SEL107   0102-93012-93032-0953-00033-00031-00000-CN03MQK\n)attr default (%$_)\n)body\n%------------------------- HFSELECT MESSAGE SEL107W ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          SEL107W SUB-TASKS NOT ATTACHED      = nnnn\n$\n$                 %EXPLANATION:$This warning message  is  produced  with the\n$                  extended form of  the  V  option  and indicates the total\n$                  number of  selected  dsns  that were not used in HFSELECT\n$                  attached sub-tasks.  A sub-task  will  not be attached in\n$                  the following situations:\n$                  - the input data set is a VSAM file (DSORG=V)\n$                  - the input data set is a tape file (DSORG=T)\n$                  - the user does  not  have  security  access to the input\n$                    file ('+' in the violation flag)\n$                  - In using the catalog search form  of  the V option, the\n$                    input dataset was cataloged but not found on the volume\n$                    pointed to by the catalog.\n$\n$                 %SYSTEM ACTION:$Normal program continuation.\n$\n$                 %PROGRAMMER RESPONSE:$If n=0  ignore this message  else be\n$                  aware that that not all selected dsns will have sub-tasks\n$                  attached for them.\n$    Press%PF03$to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$INSTALL": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00R\\x00\\x93\\x05O\\x01\\t \\x8f\\x14#\\x00S\\x00\\x88\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1993-02-23T00:00:00", "modifydate": "2009-07-27T14:23:52", "lines": 83, "newlines": 136, "modlines": 0, "user": "SBGOLOB"}, "text": "                       INSTALLATION PROCEDURE\n\n       The following files contain all program materials necessary\n  to install the HFSELECT and SUPRDUMP programs. (All files are PDSs)\n\n       This pds is a JCL and source library containing the following:\n    - member $README - please read\n    - member $INSTALL which you are now reading.\n      Please IGNORE the installation chapter in the documentation\n      contained in the $$DOCS member.\n    - member $INTRO which gives a general overview of the\n      capabilities of HFSELECT & SUPRDUMP.\n    - member MK11 containing the JCL required to create the character\n      set MK11 which is used to print the documentation and must be\n      placed into SYS1.IMAGELIB with the name XTB1MK11.  It is invoked\n      in JCL via the CHARS=MK11 parameter.  The doc is in the pds\n      which was created from the $$DOCS member.\n    - member ASMHCL containing the JCL which is used to assemble and\n      link-edit all source modules contained in this pds.\n    - member MACRO containing the macro IHAQDB required for assembling\n      programs HFSELECT and SUPRDUMP.\n    - members TESTxxx may be ignored.\n\n  For HFSELECT:\n    - the main HFSELECT module (the name 'HFSELECT' may not be\n      changed without requisite source module changes)\n    - two required subroutines- MKMESSAG and SYNADERR\n    - a subroutine module READVTC that is required for the V Option\n    - a source module of a modified  version of the public domain\n      assembler program SCAN4HIT\n    - the CLIST HFSELMSG required for the on-line message dialog\n      facility (place in the SYSPROC concatenation of the LOGON PROC)\n\n    - Use the $PDSLOAD job to create the panel and message libraries\n      for the HFSELECT message explanation system.\n\n  For SUPRDUMP:\n    - the main SUPRDUMP module (must be placed into an APF-authorized\n      library)\n    - the  CLIST SUPRDMSG required for the on-line message dialog\n      facility (place in the SYSPROC concatenation of the LOGON PROC)\n\n    - Use the $PDSLOAD job to create the panel library\n      for the SUPRDUMP message explanation system.\n\n       HFSELECT may be placed in any load library unless the use of\n  the VTOC form of the V option is desired. If so, the HFSELECT and\n  READVTC  (for  the  V  option)  modules  must  be  placed  in  an\n  authorized load library.\n\n       The HFSELMSG/SUPRDMSG CLISTs must be modified for the names used\n  for the libraries containing the panels and messages.\n\n       Files 2 and 3 contain the panel libraries for HFSELECT/SUPRDUMP\n  on-line message dialog facility and file 4 contains a common message\n  library for HFSELECT/SUPRDUMP on-line message dialog facility.\n\n       File 5 contains documentation for HFSELECT/SUPRDUMP.  A\n  3800-compatible laser printer is required to print the documentation.\n\n             __________________________________\n             |FILE   |   FILE   | FILE  |FILE |\n             |  1    |   2/3    |   4   |  5  |\n    _________|_______|__________|_______|_____|\n   | RECFM   |  FB   |    FB    |  FB   | VBA |\n   |_________|_______|__________|_______|_____|\n   | LRECL   |  80   |    80    |  80   | 148 |\n   |_________|_______|__________|_______|_____|\n   | BLKSIZE | 3600  |   3120   | 3120  |4096 |\n   |_________|_______|__________|_______|_____|\n   | SPACE(*)|  25   |    10    |   1   | 24  |\n   |_________|_______|__________|_______|_____|\n   | DIR BLKS|   5   |    20    |   1   |  1  |\n   |_________|_______|__________|_______|_____|\n\n    * All space requirements are in tracks on 3380 DASD.\n\n       The tape copy feature of SUPRDUMP  is available only if  the\n  SAS software product Release 6.07 (distributed  by  SAS Institute\n  Inc.,  Cary,  N. C. 27511)  is  installed  on the system. The SAS\n  module invoked in SUPRDUMP is SAS370,  the entry module specified\n  in the bundled MVS/370 non-LPA configuration of SAS.  This module\n  is in the SAS load library.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INTRO": {"ttr": 5383, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x05O\\x00\\x93\\x05O\\x18V\\x00i\\x00i\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-23T00:00:00", "modifydate": "1993-02-23T18:56:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "CN03MQK"}, "text": "                       HFSELECT                    Introduction\n\n       HFSELECT is an easy to use parameter-driven high performance\n  utility program  that  can  selectively  retrieve, reject, count,\n  print and sequence check records of an input file. The selection,\n  rejection, etc. can be based  on record contents, record position\n  within  a  file,  or  by comparison with another file.  Extensive\n  statistics of the input and output files are printed by HFSELECT.\n\n       HFSELECT performs file or record matching of two input files\n  and  optionally  can  merge  the  matched records onto a separate\n  output file.\n\n       HFSELECT performs VTOC, catalog and PDS  directory  searches\n  and outputs formatted records of the results.  It can recursively\n  call itself for each dsn/member in these formatted records.\n\n       The program can replace a character string by another within\n  a given range  in  a  record.  It can encrypt selected fields  to\n  create test files from sensitive or confidential data sets, or to\n  convert data from one format to another.\n\n       The  input  file  can be a physical sequential (PS) data set\n  (QSAM),  an indexed sequential (IS) data set (QISAM), a VSAM data\n  set (VSAM) or a partitioned organization (PO) data set (BPAM).\n\n       The  record  formats for QSAM, ISAM and BPAM input files can\n  be  fixed, variable, undefined, blocked, spanned, standard or any\n  valid combination  of  these  formats.  All VSAM data sets except\n  variable spanned can be processed.  The  input  files are  always\n  read sequentially. VSAM files may be read either sequentially  by\n  key or by physical sequential RBA.\n\n       Multiple  output  files may be generated, depending upon the\n  option  and suboptions selected, and on the JCL. The output files\n  may be sequential, VSAM or PDS. Thus HFSELECT may be used to copy\n  sequential, PDS or VSAM files,  or  to  convert ISAM, VSAM or PDS\n  files to sequential files or  VSAM  files.  In addition, variable\n  format files may be converted to fixed format files.  Output file\n  LRECLs  and  BLKSIZEs  may  differ from their corresponding input\n  files.\n\n       The  output  files  may  be  directed  to any system storage\n  device  (tape, disk, etc.), or any or all of the output files may\n  be  printed  either unformatted, in character,  character and HEX\n  format, or character with a ruler line.\n\n       User exits may be used to modify standard HFSELECT features,\n  and also to modify records before and after processing.\n\n       Thus, instead of writing and debugging a program  each  time\n  selection of records from  a file is required, HFSELECT steps may\n  be  written  in  a  few  minutes to obtain the desired results.\n1\n                       SUPRDUMP                      Introduction\n\n       SUPRDUMP is an easy-to-use utility print program designed to\n\n        - copy an entire tape volume to one output tape volume\n        - print  datasets, in  whole  or in  part, from  any system\n          storage  device.\n        - show  the characteristics  of  all  data  sets  on a tape\n          volume, including  labels, formats (ASCII or EBCDIC)  and\n          tapemarks for tapes with blocksizes of up to 65535 bytes.\n        - show  the  position  and  attributes  of  files,  and the\n          position of tapemarks on tape volumes.\n        - print files in hex,  with simultaneous  interpretation of\n          each character in both ASCII and EBCDIC format.\n\n       SUPRDUMP  is  parameter-driven, with the parameters coded in\n  the  PARM  of  the EXECute statement. All parameters are keywords\n  and all have defaults so that none need be explicitly specified.\n\n       Information messages displayed by the program are\n\n        - PARM coded on the EXECute statement\n        - Jobname, Stepname and Procstepname of SUPRDUMP job & step\n        - output tape characteristics and a summary of copied files\n        - DSN  coded on the input file (SYSUT1) DD statement\n        - maximum block size in the file\n        - minimum block size in the file (excluding the last block)\n        - size of the last block on the file\n        - total number of bytes in the file\n        - total number of blocks in the file\n        - for tape, the  sequence  number  of the file on the tape,\n            the density, and the recording mode technique\n        - serial number  of the volume containing the file\n        - change in BLKSIZE messages (with relative block number)\n        - RECFM and LRECL of each data set\n        - Creation and Expiration dates\n        - Approximate tape length of each tape file, and the\n            approximate total tape length of all processed files\n\n       The SYSUT1 input file record formats may be fixed, variable,\n  undefined, blocked, spanned, standard or any valid combination of\n  these formats,  but  the  file must  be physical sequential.  The\n  RECFM, LRECL and BLKSIZE of these files need not be known before-\n  hand.  One  file  in  print  format (SYSUT2) is generated and one\n  output tape volume may be created (TAPECOPY). The printout can be\n  in any one  of five display  formats. Variable-length records can\n  be  printed  in  readable  form.  It shows all bytes of the block\n  including the BDW and the RDW if any.\n\n       An  optional output file can  be coded to capture status and\n  sense bytes from reads of tape/cartridge data sets.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PDSLOA$": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x005\\x01\\x026_\\x01\\t \\x8f\\x14)\\x00(\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2009-07-27T14:29:35", "lines": 40, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//* --------------------------------------------------- *//\n//*      PDSLOAD JOB TO CREATE INSTALL LIBRARIES        *//\n//*         Change 'yourid.' to your userid ---         *//\n//*         Change 'volser'  to your output volser      *//\n//*     (THIS JOB WAS TESTED TO WORK ON MY SYSTEM)      *//\n//* --------------------------------------------------- *//\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n   RECEIVE INDS('SBGOLOB.CBT478.FILE807(PDSLOAD)')\n   DSN ('SBGOLOB.TEMP.PDSLOAD') VOL(WORKE1)\n/*\n//*\n//PDSLOAD PROC IPDS='SBGOLOB.CBT478.FILE807',      <=== THIS PDS\n//             OPRE=SBGOLOB,\n//             QUAL=FILE807,\n//             MEMB=XXX,\n//             OUNT=SYSALLDA,\n//             OVL=WORKE1,\n//             DSP1=NEW,\n//             DSP2=CATLG,\n//             DSP3='',\n//             P=30,S=60,D=44\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.TEMP.PDSLOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=&IPDS(&MEMB)\n//SYSUT2   DD UNIT=&OUNT,VOL=SER=&OVL,\n//             DSN=&OPRE..&QUAL..&MEMB,\n//             DISP=(&DSP1,&DSP2&DSP3),\n//             SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//*\n//S001 EXEC PDSLOAD,MEMB=$HFSISPM      HFSELECT Message Library\n//S002 EXEC PDSLOAD,MEMB=$HFSISPP      HFSELECT Panel Library\n//S003 EXEC PDSLOAD,MEMB=$SPRISPP      SUPRDUMP Panel LIbrary\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PDSLOAD": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x00\\x01\\x026_\\x01\\t \\x8f\\x14\\x12\\x00(\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2009-07-27T14:12:00", "lines": 40, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//* --------------------------------------------------- *//\n//*      PDSLOAD JOB TO CREATE INSTALL LIBRARIES        *//\n//*         Change 'yourid.' to your userid ---         *//\n//*         Change 'volser'  to your output volser      *//\n//*     (THIS JOB WAS TESTED TO WORK ON MY SYSTEM)      *//\n//* --------------------------------------------------- *//\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n   RECEIVE INDS('this.pds.name(PDSLOAD)')\n   DSN ('yourid.TEMP.PDSLOAD') VOL(volser)\n/*\n//*\n//PDSLOAD PROC IPDS='yourid.CBT478.FILE807',       <=== THIS PDS\n//             OPRE=yourid,\n//             QUAL=FILE807,\n//             MEMB=XXX,\n//             OUNT=SYSALLDA,\n//             OVL=volser,\n//             DSP1=NEW,\n//             DSP2=CATLG,\n//             DSP3='',\n//             P=30,S=60,D=44\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=yourid.TEMP.PDSLOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=&IPDS(&MEMB)\n//SYSUT2   DD UNIT=&OUNT,VOL=SER=&OVL,\n//             DSN=&OPRE..&QUAL..&MEMB,\n//             DISP=(&DSP1,&DSP2&DSP3),\n//             SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//*\n//S001 EXEC PDSLOAD,MEMB=$HFSISPM      HFSELECT Message Library\n//S002 EXEC PDSLOAD,MEMB=$HFSISPP      HFSELECT Panel Library\n//S003 EXEC PDSLOAD,MEMB=$SPRISPP      SUPRDUMP Panel LIbrary\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$README": {"ttr": 5390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00W\\x00\\x93\\x05_\\x01\\t _\\x131\\x00&\\x00\\x17\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-02-24T00:00:00", "modifydate": "2009-07-24T13:31:57", "lines": 38, "newlines": 23, "modlines": 0, "user": "SBGOLOB"}, "text": "         PROGRAMS HFSELECT AND SUPRDUMP WRITTEN AND COPYRIGHTED BY:\n                   M. KARLIN, N. LINDNER, I. EISENSTEIN\n     (C) COPYRIGHT M. KARLIN, N. LINDNER, I. EISENSTEIN  1981.\n         THE RIGHTS OF THE COPYRIGHT HOLDERS WILL BE STRICTLY ENFORCED.\n\n     ---------------------------------------------------------------\n\n     IMPORTANT NOTE!  (JULY 24, 2009 - BY SAM GOLOB)\n\n         PERMISSION HAS BEEN GRANTED BY M. KARLIN AND N. LINDNER\n         TO PLACE THESE MATERIALS ON THE CBT TAPE, SUBJECT TO CBT\n         TAPE CONDITIONS AND DISCLAIMERS, EVEN THOUGH THE PRODUCT\n         AND MATERIALS ON THIS FILE ARE STILL OWNED BY THE\n         COPYRIGHT HOLDERS.\n\n     IMPORTANT NOTE!\n\n     ---------------------------------------------------------------\n\n      THESE PROGRAMS HAVE MET A BASIC SET OF PROGRAMMING AND\n      DOCUMENTATION STANDARDS, BUT HAVE NOT BEEN PROGRAM TESTED IN ANY\n      FORMAL FASHION. THE USER IS EXPECTED TO MAKE THE FINAL\n      EVALUATION OF THE USE OF THESE PROGRAMS IN THEIR ENVIRONMENT.\n\n      THESE PROGRAMS ARE DISTRIBUTED ON AN AS-IS BASIS.\n      NO WARRANTY, EXPRESSED OR IMPLIED, OF THE FITNESS\n      FOR A PARTICULAR PURPOSE AS RELATES TO THE DOCUMENTATION,\n      FUNCTION, RESULTS, OR PERFORMANCE OF THESE PROGRAMS IS MADE.\n\n     IMPLEMENTATION AND USE OF THESE PROGRAMS CONSTITUTES A RELEASE FROM\n      LIABILITY OF THE AUTHORS FOR ANY PROBLEMS ARISING FROM THE USE OF\n      THESE PROGRAMS AT THE USER'S INSTALLATION.\n\n      THESE PROGRAMS ARE MADE AVAILABLE WITHOUT CHARGE.\n      RECIPIENTS ARE FREE TO MAKE THESE PROGRAMS AVAILABLE TO OTHERS IN\n      LIKE MANNER, PROVIDED THIS DISCLAIMER IS KEPT INTACT. THEY MAY\n      NOT BE SOLD, TRADED, OR EXCHANGED FOR CASH, SERVICES, OR AS AN\n      INCENTIVE FOR SERVICES AND/OR OTHER PURCHASES.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SPRISPP": {"ttr": 5392, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x05o\\x00\\x93\\x05o\\x07P\\x03Y\\x03Y\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-25T00:00:00", "modifydate": "1993-02-25T07:50:00", "lines": 857, "newlines": 857, "modlines": 0, "user": "CN03MQK"}, "text": "./ ADD NAME=DMPH001  0105-93011-93014-1213-00020-00024-00000-CN03MQK\n%HELP----------------------  SUPRDUMP MESSAGE DIALOG -----------------------HELP\n%COMMAND ===>_ZCMD\n+\n+All messages issued by SUPRDUMP have the following form:\n+\n+                                %DMPnnnx text+\n+\n+where%nnn+is the message number (001 to 099), and%x+may be I, E or W.\n+To access a message in this dialog, enter its number.\n+\n+The letter following the message number signifies the type of message issued:\n+\n%E+is a critical error message. When this type of error occurs, SUPRDUMP\n+terminates so that the error can be corrected.\n+\n%W+is a warning message. These messages are useful in adjusting a job to\nrun more efficiently or to warn of possible non-critical errors.\n+\n%I+messages document informational messages.\n)END\n./ ADD NAME=DMPH002  0102-93011-93013-1907-00020-00018-00000-CN03MQK\n%HELP---------------------  SUPRDUMP MESSAGE DIALOG  ----------------------HELP\n%COMMAND ===>_ZCMD\n+\n+PF KEY SETTINGS\n+\n+The following PF key settings are used in the message dialog:\n+\n%PF1+ Help\n+\n%PF3+ Go back to the main dialog panel\n+\n+If multiple panels are needed to explain a message, the following additional\n+PF key settings can be used:\n+\n%PF7+ Go back to the previous screen in a sequence\n+\n%PF8+ Go to the next screen in a sequence\n+\n+The%PF13-PF24+keys may be used for the corresponding PF1-PF12 functions.\n)END\n./ ADD NAME=DMPMAIN  0104-93011-93014-1323-00049-00053-00000-CN03MQK\n)BODY\n%------------------------  SUPRDUMP MESSAGE DIALOG  ----------------------------\n%COMMAND ===>_ZCMD\n+\n+To display information about an SUPRDUMP message, type its number (001-099),\n+then press%ENTER.+\n+\n%MESSAGE NUMBER  ===> DMP_NNN+\n+\n+                               ***%EXAMPLE+***\n+\n+To access message DMP000I, enter the message number (000):\n+\n%MESSAGE NUMBER  ===> DMP 000\n+\n+\n+\n+Press%PF1+for HELP.\n+Press%PF3+to END.\n)INIT\n        .HELP = DMPH001\n        &ZCMD = &Z\n        &NNN  = &Z\n       &ZPF01 = HELP\n       &ZPF13 = HELP\n       &ZPF03 = END\n       &ZPF15 = END\n       &ZPF04 = RETURN\n       &ZPF16 = RETURN\n       &ZPF07 = UP\n       &ZPF19 = UP\n       &ZPF08 = DOWN\n       &ZPF20 = DOWN\n      .CURSOR = NNN\n       VPUT ( ZPF01 ZPF03 ZPF07 ZPF08 ZPF13 ZPF15 ZPF19 ZPF20 ) PROFILE\n)PROC\n     IF (&ZCMD \u00ac= &Z)\n         .MSG = selms004\n     VER (&NNN,NONBLANK)\n     &NN   =  TRUNC (&NNN,2)\n     &NA   = .TRAIL\n     VER (&NNN,NB,PICT,NNN,MSG=selms001)\n     VER (&NN,LIST,00,01,02,04,MSG=selms003)\n     IF (&NN = 00) VER (&NA,LIST,0,1,2,3,4,5,6,8,9,MSG=selms003)\n     IF (&NN = 02) VER (&NA,LIST,0,1,2,3,4,5,6,7,MSG=selms003)\n     IF (&NN = 04) VER (&NA,LIST,0,1,MSG=selms003)\n     &PANELID = DMP&NNN\n     VPUT PANELID SHARED\n)END\n./ ADD NAME=DMP000   0106-93011-93014-1320-00022-00023-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP000I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP000I PARM= xxxxxxxxxxxxxxx\n+\n+\n+                 %EXPLANATION:+This message is printed with every execution\n+                  of  SUPRDUMP. It repeats the characters coded in the PARM\n+                  field in the JCL for the user's convenience.\n+\n+                 %SYSTEM ACTION:+normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+none.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP001   0107-93011-93014-1613-00024-00023-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP001E ---------------------------\n%COMMAND ===>_ZCMD\n+\n%          DMP001E ERROR IN PARM FIELD OR JCL\n+\n+                 %EXPLANATION:+This message indicates that a critical error\n+                  has  occurred  and  is always printed in conjunction with\n+                  previous  critical  error  message(s). The previous error\n+                  messages  may  deal  with  errors encountered in the PARM\n+                  field or JCL.\n+\n+                 %SYSTEM ACTION:+Program end with a non-zero return code.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the error(s) indicated in the\n+                  previous error message(s).\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP002   0107-93011-93014-1613-00021-00027-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP002I ---------------------------\n%COMMAND ===>_ZCMD\n+\n%          DMP002I END OF FILE REACHED\n+\n+                 %EXPLANATION:+ This message is printed when the end of the\n+                  input file has been reached and the C=count parameter has\n+                  not been satisfied.\n+\n+                 %SYSTEM ACTION:+Normal program end.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP003   0106-93011-93014-1614-00022-00020-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP003E ---------------------------\n%COMMAND ===>_ZCMD\n+\n%          DMP003E SYSUT1/2 DD STATEMENT MISSING\n+\n+                 %EXPLANATION:+ This critical message indicates that either\n+                  the  input file has not been defined in the JCL with  the\n+                  ddname of SYSUT1, or that SYSUT2 has not been defined  in\n+                  the JCL and could not be dynamically allocated.\n+\n+                 %SYSTEM ACTION:+Program termination with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Supply the correct JCL DD statement.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP004   0112-93011-93014-1321-00021-00018-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP004E ---------------------------\n%COMMAND ===>_ZCMD\n+\n%          DMP004E KEYWORD PARAMETER NOT FOLLOWED BY = SIGN\n+\n+                 %EXPLANATION:+ This critical message indicates that one of\n+                  the key word parameters in the PARM is not followed by an\n+                  = sign.\n+\n+                 %SYSTEM ACTION:+Program termination with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the parameter in error.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z,NEXT)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP005   0106-93011-93014-1614-00022-00019-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP005E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP005E INVALID OR DUPLICATE KEYWORD PARAMETER\n+\n+                 %EXPLANATION:+ This  critical  message  indicates  that  a\n+                  character other than C, F, N, R, S or T has been coded as\n+                  a key word parameter, or that one of the above parameters\n+                  has been coded more than once.\n+\n+                 %SYSTEM ACTION:+Program termination with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the parameter error.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP006   0105-93011-93014-1615-00022-00018-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP006E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP006E A PARAMETER LENGTH EXCEEDS MAXIMUM ALLOWABLE\n+\n+                 %EXPLANATION:+ This  message  is  produced when any of the\n+                  parameters  listed  in  the PARM is more than 8 digits in\n+                  length, or if the T=title parameter exceeds 65 characters\n+                  in length.\n+\n+                 %SYSTEM ACTION:+Program terminates with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the parameter in error.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP008   0105-93011-93014-1615-00021-00019-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP008E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP008E PARM VALUE NOT NUMERIC\n+\n+                 %EXPLANATION:+ This  message  is  produced when one of the\n+                  parameters listed  in  the  PARM  has a non-numeric value\n+                  after the equal sign.\n+\n+                 %SYSTEM ACTION:+Program terminates with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the parameter in error.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP009   0104-93011-93014-1615-00022-00031-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP009E ---------------------------\n%COMMAND ===>_ZCMD\n+\n%          DMP009E INVALID VALUE SPECIFIED FOR FORMAT PARAMETER\n+\n+                 %EXPLANATION:+ This  message  is produced when a character\n+                  other than A, B, C, H or R as the first sub-parameter has\n+                  been coded or other than  L  or  P  has been coded as the\n+                  second sub-parameter of the F parameter.\n+\n+                 %SYSTEM ACTION:+Program terminates with return code of 8.\n+\n+                 %PROGRAMMER RESPONSE:+Correct the F parameter in the PARM.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP010   0104-93011-93014-1616-00023-00030-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP010I ---------------------------\n%COMMAND ===>_ZCMD\n+\n%          DMP010I NUMBER OF BLOCKS DUMPED = nnnnn\n+\n+                 %EXPLANATION:+ This message is produced once at the end of\n+                  each  file  processed  where  nnn  is the total number of\n+                  blocks  from the input file that were printed. nnn always\n+                  is  less  than or equal to the number of blocks requested\n+                  in the Count parameter coded in the PARM.\n+\n+                 %SYSTEM ACTION:+Normal program end.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP011   0106-93011-93014-1616-00024-00018-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP011I ---------------------------\n%COMMAND ===>_ZCMD\n+\n%          DMP011I NUMBER OF BLOCKS TO BE SKIPPED = nnnnn\n+\n+                 %EXPLANATION:+ This  message  is  produced when the S=nnnn\n+                  parameter  is coded and indicates that nnn blocks will be\n+                  skipped  before  printing  begins. These blocks and their\n+                  lengths are counted and processed in the block statistics\n+                  (block  count, maximum block size, minimum blocksize, and\n+                  last block size).\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP012   0105-93011-93032-0940-00031-00030-00000-CN03MQK\n)ATTR DEFAULT(%$_)\n)BODY\n%------------------------- SUPRDUMP MESSAGE DMP012I ---------------------------\n%COMMAND ===>_ZCMD\n$\n%          DMP012I MINIMUM BLKSIZE = nnnnn, MAXIMUM BLKSIZE = mmmmm, LAST\n%                  BLKSIZE = kkkkk, TOTAL NUMBER OF BYTES = jjjjjjjjj\n$\n$                 %EXPLANATION:$ This message is produced for each file that\n$                  is  read.  nnnnn  is  the  size  of  the  smallest  block\n$                  processed, excluding the last block. mmmmm is the size of\n$                  the  largest block processed and kkkkk is the size of the\n$                  last  block  processed.  jjjjjjjjj is the total number of\n$                  bytes  in the blocks processed. If C=+count is not coded,\n$                  the  program  will  process  every  block in the file. If\n$                  C=+count  is coded, the program will stop processing that\n$                  file  after  the  S and C parameters are satisfied, or at\n$                  the end of file, whichever occurs first.\n$\n$                 %SYSTEM ACTION:$Normal program continuation.\n$\n$                 %PROGRAMMER RESPONSE:$None.\n$\n$    Press%PF03$to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP013   0104-93011-93014-1619-00022-00026-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP013I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP013I nnn FILES TO BE DUMPED (N PARAMETER IGNORED FOR NON-TAPE)\n+\n+                 %EXPLANATION:+ This message indicates that the program has\n+                  been  requested to print the number of files specified in\n+                  the  N=files  parameter.  See Section 5.3 NUMBER OF FILES\n+                  Parameter for details of multiple tape file processing.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP014   0105-93011-93032-1042-00026-00029-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP014W ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP014W DATA NOT VARIABLE FORMAT, R=100 WILL BE USED\n+\n+                 %EXPLANATION:+  This   message   indicates  that  R=V  was\n+                  requested  but  the  program determined that the file did\n+                  not  have  standard IBM variable-format records. (See IBM\n+                  DATA ADMINISTRATION SERVICES GUIDE for  a  description of\n+                  variable-format  records.)  The  default length of 100 is\n+                  used to print out the blocks  except when the data is JCL\n+                  (in which case R=80 is used).\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER  RESPONSE:+ Inspect  the printout to determine\n+                  the actual record format of the file.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP015   0103-93011-93014-1620-00023-00026-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL015I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP015I SKIP COUNT EQUALS OR EXCEEDS TOTAL BLOCK COUNT. NO BLOCKS\n%                  DUMPED.\n+\n+                 %EXPLANATION:+ This  message  is  produced  when the value\n+                  coded in the S=skip parameter is greater than or equal to\n+                  the  total  number  of  blocks in the file. No blocks are\n+                  printed for this file.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP016   0105-93011-93014-1621-00023-00027-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP016I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP016I END OF VOLUME REACHED\n+\n+                 %EXPLANATION:+ This  message  is  produced with tape input\n+                  files  when  the  N parameter is coded greater than 1 and\n+                  an  end  of  volume  condition has been encountered.  The\n+                  program will process the next tape volume(s) (if present)\n+                  until the  N parameter has been satisfied.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP017   0104-93011-93014-1621-00027-00024-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP017I ---------------------------\n%COMMAND ===>_ZCMD\n+\n%          DMP017I TAPE FILE WILL BE PROCESSED BACKWARDS.R=V AND N PARAMETER\n%                  WILL BE IGNORED IF CODED.\n+\n+                 %EXPLANATION:+ This  message  indicates  that the backward\n+                  option of the Count parameter has been specified. The use\n+                  of  this  option  requires  that  the input file is a one\n+                  volume  fixed-format  sequential tape file. Hence, R=V is\n+                  defaulted to R=100 and the  N  parameter  is  ignored  if\n+                  coded. The tape volume is opened and processed backwards.\n+                  Caution is advised in interpreting the resulting messages\n+                  when using this option.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP018   0105-93011-93032-1038-00025-00030-00000-CN03MQK\n)attr default(%$_)\n)body\n%------------------------- SUPRDUMP MESSAGE DMP018I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP018I SUPRDUMP  STATISTICS  APPLY ONLY TO THE  NUMBER OF BLOCKS\n%                  PROCESSED\n$\n$                 %EXPLANATION:$ This  message is issued when a plus sign is\n$                  coded  in  the  C  parameter value. The + sign causes the\n$                  program  to  stop  processing  a  file  if  the  S  and C\n$                  parameters are satisfied.\n$\n$                 %SYSTEM ACTION:$Normal program continuation.\n$\n$                 %PROGRAMMER RESPONSE:$None.\n$\n$    Press%PF03$to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP019   0104-93011-93014-1622-00028-00023-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP019I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP019I BLOCK NO. = nnnnn, NO. OF BYTES IN BLOCK = mmmmm\n+\n+                 %EXPLANATION:+ This  message is issued, when processing  a\n+                  non-variable format file, when the length mmmmm  of block\n+                  nnnnn differs from the length of the previous block.   It\n+                  is always printed for the first block except when R=V  is\n+                  coded but the file is not variable;  then the  message is\n+                  printed  for  the  second block. A maximum of ten DMP019I\n+                  messages will be printed.  If a block number  other  than\n+                  the first or last is printed for a fixed format file then\n+                  the indicated block(s) is probably bad.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+Recreate the file if bad blocks  are\n+                  found.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP020   0104-93011-93014-1622-00024-00026-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP020E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP020E UNABLE TO ALLOCATE FILE(S) FOR TAPE COPY (FT11F001, WORK,\n%                  FT12F001, SYSIN)\n+\n+                 %EXPLANATION:+ This message is issued when the TAPECOPY DD\n+                  statement has been coded in  the  JCL  but  SUPRDUMP  has\n+                  been unable to dynamically allocate one  or  more  of the\n+                  above files required for the tape copy operation.\n+\n+                 %SYSTEM ACTION:+Tape copy operation bypassed.\n+\n+                 %PROGRAMMER RESPONSE:+Code the required file  in  the  JCL\n+                  and rerun the job.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP021   0103-93014-93014-1623-00024-00024-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP021I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP021I FILE OCCUPIES APPROXIMATELY nnn INCH(ES) OF TAPE\n+\n+                 %EXPLANATION:+ This message is issued once  at  the end of\n+                  each  file  processed,   where   nnn  is  the approximate\n+                  physical  length  of  the  file,  computed  from the tape\n+                  density,  recording  mode  technique and number of bytes.\n+                  Refer  to  IBM  3420  Models  4,  6,  and 8 Magnetic Tape\n+                  Subsystems, GA32-0021, for more details.\n+\n+                 %SYSTEM ACTION:+ Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+ None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP022   0104-93011-93014-1623-00022-00024-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP022I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP022I JOBNAME=jobname,PROCSTEPNAME=procstepname,JOBSTEPNAME=\n%                  jobstepname\n+\n+                 %EXPLANATION:+This message is printed with every execution\n+                  of SUPRDUMP. If the program is not executed from  a PROC,\n+                  the PROCSTEPNAME=  becomes STEPNAME=.\n+\n+                 %SYSTEM ACTION:+ Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+ None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP023   0104-93011-93014-1624-00023-00031-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP023I ---------------------------\n%COMMAND ===>_ZCMD\n+\n%          DMP023I APPROXIMATE TOTAL TAPE LENGTH OF PROCESSED FILES = nnnnnn\n%                  INCH(ES)\n+\n+                 %EXPLANATION:+This message is printed with every execution\n+                  of SUPRDUMP with multiple tape data sets. nnnnnnn  is the\n+                  summation of the approximate  tape  lengths  of  all  the\n+                  processed data sets on all tape volume(s).\n+\n+                 %SYSTEM ACTION:+ Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+ None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP024   0106-93011-93032-1039-00029-00023-00000-CN03MQK\n)attr default(%$_)\n)body\n%------------------------- SUPRDUMP MESSAGE DMP024W ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP024W THE BLOCK COUNT IN THE TAPE TRAILER LABEL (nnnn) DOES NOT\n%                  MATCH THE ACTUAL BLOCK COUNT (mmmm).\n$\n$                 %EXPLANATION:$This message is printed with every execution\n$                  of SUPRDUMP with standard label tape processing and C=+cc\n$                  not coded. This message indicates a possible problem with\n$                  the tape data set. nnnn is the block count  on  the  tape\n$                  trailer label  and  mmmm  is  the actual block count. The\n$                  trailer labels of each volume  of a multi-volume standard\n$                  label processed tape data set are checked for block count.\n$\n$                 %SYSTEM ACTION:$ Normal program continuation.\n$\n$                 %PROGRAMMER RESPONSE:$ Examine tape data set. It may need\n$                  to be recreated.\n$\n$    Press%PF03$to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP025   0104-93011-93014-1625-00022-00021-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP025I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP025I VOLUME SWITCHED TO VOLSER= vvvvvv AFTER BLOCK NUMBER nnn\n+\n+                 %EXPLANATION:+ This  message is  printed  for multi-volume\n+                  data sets. vvvvvv  is  the next volume  serial number and\n+                  nnn  is  the block count  of  the just-processed  volume.\n+                  AFTER BLOCK NUMBER nnn is not printed for BLP processing.\n+\n+                 %SYSTEM ACTION:+ Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+ None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP026   0104-93011-93014-1625-00026-00030-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP026E ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP026E BLP PROCESSING FOR CONCATENATED TAPE FILES NOT ALLOWED\n%                  (SPECIFY ALL VOLSERS IN SYSUT1 DD STATEMENT).\n+\n+                 %EXPLANATION:+This message is  printed when the SYSUT1 DD\n+                  statement specifies BLP processing for concatenated tape\n+                  files. This is not allowed; however, all the volumes  in\n+                  the concatenation may be coded in the  VOL=SER parameter\n+                  of the the SYSUT1 DD.\n+\n+                 %SYSTEM ACTION:+Program terminates with a return code of 8\n+\n+                 %PROGRAMMER RESPONSE:+ Recode  the  SYSUT1 DD statement to\n+                  include all the VOLSERs  specified  in  the concatenation\n+                  and remove all the concatenated DD statements.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP027   0104-93011-93014-1626-00024-00026-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP027W ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP027W BLKSIZE OF FILE EXCEEDS 32K - NOT PROCESSABLE USING\n%                  STANDARD IBM ACCESS METHODS\n+\n+                 %EXPLANATION:+This message is printed when a tape file has\n+                  a blocksize exceeding  32K.  See  message DMP012I for the\n+                  maximum blocksize  found  in  the  data set. This message\n+                  tells  the  user  that  programs  using  standard IBM I/O\n+                  methods cannot process the data set properly.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+Take appropriate action.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP040   0109-93011-93032-1040-00036-00041-00000-CN03MQK\n)attr default(%$_)\n)body\n%------------------------- SUPRDUMP MESSAGE DMP040I ---------------------------\n%COMMAND ===>_ZCMD\n$\n%          DMP040I VOLSER=volser,BLK CNT=nnnnnnn,SEQ NO=mmmmm,LABEL=lbl,\n%                                        DEN=den,p-TRK,DSN=dsname\n%                  RECFM=recfm,LRECL=lrecl,CREATION DATE:YY=yy,DDD=ddd,\n%                                        EXPIRATION DATE:YY=yy,DDD=ddd\n$\n$                 %EXPLANATION:$This message is issued for each  input  file\n$                  processed by SUPRDUMP.\n$\n$                  The following are in the first message line:\n$\n$                  \"volser\" is the first  (or only) volume  serial number of\n$                  the storage device on which the file  resides. nnn is the\n$                  number  of  blocks  in  the file except  when C=+count is\n$                  specified,   when  it  is  only  the  number   of  blocks\n$                  processed.  SEQ  NO=mmm  is  printed only  for tape files\n$                  where mmm is the logical  or physical sequence number  of\n$                  the file, depending on the JCL label parameter. If BLP is\n$                  coded, it is the physical sequence number.  For all other\n$\n$    Press%PF08$to display next screen.\n$    Press%PF03$to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n  &ZPF08 = NEXT\n  &ZPF20 = NEXT\n  VPUT ( ZPF08 ZPF20 ) PROFILE\n)PROC\n   IF (&ZCMD \u00ac= &Z,NEXT)\n         .MSG = SELMS004\n)END\n./ ADD NAME=DMP040B  0104-93012-93014-1627-00036-00036-00000-CN03MQK\n%------------------------- HFSELECT MESSAGE SEL040I (CONT'D) ------------------\n%COMMAND ===>_ZCMD\n+         label parameters (SL, SUL, AL, etc.) it is the logical sequence\n+         number. \"lbl\" is the JCL label parameter  (coded or defaulted).\n+         DEN=den is printed for 3420 tape files where \"den\" is the actual tape\n+         density (only 800, 1600 or 6250  BPI) and p-TRK indicates either 7 or\n+         9-track recording mode. For 3480 tape cartridges, \"den\" is listed as\n+         38000 BPI and 18TRK recording mode. \"dsname\" is the file name\n+         specified  in  the JCL.\n+\n+         The following are in the second line of the message. They have valid\n+         values only for disk files, or tape files run with standard label\n+         processing:\n+\n+         \"recfm\" is the record format of the file (F, V, or U only).  \"lrecl\"\n+         is the logical record length.  For SL processing, CREATION DATE is\n+         the  Julian date  of tape creation. For BLP processing, CREATION DATE\n+         is today's Julian date. EXPIRATION DATE yy  and ddd is the Julian date\n+         of expiration if it exists.\n+\n+        %SYSTEM ACTION:+Normal program continuation.\n+        %PROGRAMMER RESPONSE:+None.\n+    Press%PF03+to END.\n+    Press%PF07+to display the previous screen.\n)INIT\n   .HELP = SELH002\n   &ZCMD = &Z\n  &ZPF07 = LAST\n  &ZPF19 = LAST\n  &ZPF08 = DOWN\n  &ZPF20 = DOWN\n  VPUT ( ZPF07 ZPF08 ZPF19 ZPF20 ) PROFILE\n)PROC\n IF (&ZCMD \u00ac= &Z,LAST)\n       .MSG = SELMS004\n)END\n./ ADD NAME=DMP041   0104-93011-93014-1627-00020-00029-00000-CN03MQK\n%------------------------- SUPRDUMP MESSAGE DMP041I ---------------------------\n%COMMAND ===>_ZCMD\n%\n%          DMP041I (C) COPYRIGHT JUNE 1984 BY M. KARLIN, N. LINDNER SUPRDUMP\n%                  RELEASE x.y  date\n+\n+                 %EXPLANATION:+Copyright and release information.\n+\n+                 %SYSTEM ACTION:+Normal program continuation.\n+\n+                 %PROGRAMMER RESPONSE:+None.\n+\n+    Press%PF03+to END.\n)INIT\n   .HELP = DMPH002\n   &ZCMD = &Z\n)PROC\n   IF (&ZCMD \u00ac= &Z)\n         .MSG = SELMS004\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE807": {"ttr": 5892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04N\\x00\\x00\\x01\\t \\x8f\\x01\\t \\x8f\\x145\\x00\\x97\\x00\\x97\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf8@@@'", "ispf": {"version": "04.78", "flags": 0, "createdate": "2009-07-27T00:00:00", "modifydate": "2009-07-27T14:35:00", "lines": 151, "newlines": 151, "modlines": 0, "user": "CBT-478"}, "text": "//***FILE 807 is from Morris Karlin, Norman Lindner, and Irwin      *   FILE 807\n//*           Eisenstein, and contains their programs HFSELECT      *   FILE 807\n//*           and SUPRDUMP.  These programs were originally for     *   FILE 807\n//*           sale, but Morris Karlin and Norman Lindner have       *   FILE 807\n//*           given permission for them to be included on the       *   FILE 807\n//*           CBT Tape collection, subject to CBT Tape disclaimers  *   FILE 807\n//*           and conditions.                                       *   FILE 807\n//*                                                                 *   FILE 807\n//*     HFSELECT is a powerful file selection and match-merge       *   FILE 807\n//*           program, which has additional capabilities, as        *   FILE 807\n//*           described below.                                      *   FILE 807\n//*                                                                 *   FILE 807\n//*     SUPRDUMP is a program that can read, copy, and print the    *   FILE 807\n//*           contents of a large variety of tapes.                 *   FILE 807\n//*                                                                 *   FILE 807\n//*     These programs were reworked for HLASM and z/OS by Morris   *   FILE 807\n//*     Karlin, who is their principal author.                      *   FILE 807\n//*                                                                 *   FILE 807\n//*           email:  Morris_Karlin@bmc.com                         *   FILE 807\n//*                   morris.karlin@gmail.com                       *   FILE 807\n//*                                                                 *   FILE 807\n//*                    HFSELECT  -  Introduction                    *   FILE 807\n//*                                                                 *   FILE 807\n//*          HFSELECT is an easy to use parameter-driven high       *   FILE 807\n//*     performance utility program that can selectively            *   FILE 807\n//*     retrieve, reject, count, print and sequence check           *   FILE 807\n//*     records of an input file. The selection, rejection, etc.    *   FILE 807\n//*     can be based on record contents, record position within     *   FILE 807\n//*     a file, or by comparison with another file.  Extensive      *   FILE 807\n//*     statistics of the input and output files are printed by     *   FILE 807\n//*     HFSELECT.                                                   *   FILE 807\n//*                                                                 *   FILE 807\n//*          HFSELECT performs file or record matching of two       *   FILE 807\n//*     input files and optionally can merge the matched records    *   FILE 807\n//*     onto a separate output file.                                *   FILE 807\n//*                                                                 *   FILE 807\n//*          HFSELECT performs VTOC, catalog and PDS directory      *   FILE 807\n//*     searches and outputs formatted records of the results.      *   FILE 807\n//*     It can recursively call itself for each dsn/member in       *   FILE 807\n//*     these formatted records.                                    *   FILE 807\n//*                                                                 *   FILE 807\n//*          The program can replace a character string by          *   FILE 807\n//*     another within a given range in a record.  It can           *   FILE 807\n//*     encrypt selected fields to create test files from           *   FILE 807\n//*     sensitive or confidential data sets, or to convert data     *   FILE 807\n//*     from one format to another.                                 *   FILE 807\n//*                                                                 *   FILE 807\n//*          The input file can be a physical sequential (PS)       *   FILE 807\n//*     data set (QSAM), an indexed sequential (IS) data set        *   FILE 807\n//*     (QISAM), a VSAM data set (VSAM) or a partitioned            *   FILE 807\n//*     organization (PO) data set (BPAM).                          *   FILE 807\n//*                                                                 *   FILE 807\n//*          The record formats for QSAM, ISAM and BPAM input       *   FILE 807\n//*     files can be fixed, variable, undefined, blocked,           *   FILE 807\n//*     spanned, standard or any valid combination of these         *   FILE 807\n//*     formats.  All VSAM data sets except variable spanned can    *   FILE 807\n//*     be processed.  The input files are always read              *   FILE 807\n//*     sequentially. VSAM files may be read either sequentially    *   FILE 807\n//*     by key or by physical sequential RBA.                       *   FILE 807\n//*                                                                 *   FILE 807\n//*          Multiple output files may be generated, depending      *   FILE 807\n//*     upon the option and suboptions selected, and on the JCL.    *   FILE 807\n//*     The output files may be sequential, VSAM or PDS. Thus       *   FILE 807\n//*     HFSELECT may be used to copy sequential, PDS or VSAM        *   FILE 807\n//*     files, or to convert ISAM, VSAM or PDS files to             *   FILE 807\n//*     sequential files or VSAM files.  In addition, variable      *   FILE 807\n//*     format files may be converted to fixed format files.        *   FILE 807\n//*     Output file LRECLs and BLKSIZEs may differ from their       *   FILE 807\n//*     corresponding input files.                                  *   FILE 807\n//*                                                                 *   FILE 807\n//*          The output files may be directed to any system         *   FILE 807\n//*     storage device (tape, disk, etc.), or any or all of the     *   FILE 807\n//*     output files may be printed either unformatted, in          *   FILE 807\n//*     character, character and HEX format, or character with a    *   FILE 807\n//*     ruler line.                                                 *   FILE 807\n//*                                                                 *   FILE 807\n//*          User exits may be used to modify standard HFSELECT     *   FILE 807\n//*     features, and also to modify records before and after       *   FILE 807\n//*     processing.                                                 *   FILE 807\n//*                                                                 *   FILE 807\n//*          Thus, instead of writing and debugging a program       *   FILE 807\n//*     each time selection of records from a file is required,     *   FILE 807\n//*     HFSELECT steps may be written in a few minutes to obtain    *   FILE 807\n//*     the desired results.                                        *   FILE 807\n//*                                                                 *   FILE 807\n//*                    SUPRDUMP  -  Introduction                    *   FILE 807\n//*                                                                 *   FILE 807\n//*          SUPRDUMP is an easy-to-use utility print program       *   FILE 807\n//*          designed to                                            *   FILE 807\n//*                                                                 *   FILE 807\n//*           - copy an entire tape volume to one output tape       *   FILE 807\n//*             volume                                              *   FILE 807\n//*           - print datasets, in whole or in part, from any       *   FILE 807\n//*             system storage device.                              *   FILE 807\n//*           - show the characteristics of all data sets on a      *   FILE 807\n//*             tape volume, including labels, formats (ASCII or    *   FILE 807\n//*             EBCDIC) and tapemarks for tapes with blocksizes     *   FILE 807\n//*             of up to 65535 bytes.                               *   FILE 807\n//*           - show the position and attributes of files, and      *   FILE 807\n//*             the position of tapemarks on tape volumes.          *   FILE 807\n//*           - print files in hex, with simultaneous               *   FILE 807\n//*             interpretation of each character in both ASCII      *   FILE 807\n//*             and EBCDIC format.                                  *   FILE 807\n//*                                                                 *   FILE 807\n//*          SUPRDUMP is parameter-driven, with the parameters      *   FILE 807\n//*     coded in the PARM of the EXECute statement. All             *   FILE 807\n//*     parameters are keywords and all have defaults so that       *   FILE 807\n//*     none need be explicitly specified.                          *   FILE 807\n//*                                                                 *   FILE 807\n//*          Information messages displayed by the program are      *   FILE 807\n//*                                                                 *   FILE 807\n//*           - PARM coded on the EXECute statement                 *   FILE 807\n//*           - Jobname, Stepname and Procstepname of SUPRDUMP      *   FILE 807\n//*             job & step                                          *   FILE 807\n//*           - output tape characteristics and a summary of        *   FILE 807\n//*             copied files                                        *   FILE 807\n//*           - DSN coded on the input file (SYSUT1) DD             *   FILE 807\n//*             statement                                           *   FILE 807\n//*           - maximum block size in the file                      *   FILE 807\n//*           - minimum block size in the file                      *   FILE 807\n//*             (excluding the last block)                          *   FILE 807\n//*           - size of the last block on the file                  *   FILE 807\n//*           - total number of bytes in the file                   *   FILE 807\n//*           - total number of blocks in the file                  *   FILE 807\n//*           - for tape, the sequence number of the file on the    *   FILE 807\n//*               tape, the density, and the recording mode         *   FILE 807\n//*               technique                                         *   FILE 807\n//*           - serial number of the volume containing the file     *   FILE 807\n//*           - change in BLKSIZE messages (with relative block     *   FILE 807\n//*             number)                                             *   FILE 807\n//*           - RECFM and LRECL of each data set                    *   FILE 807\n//*           - Creation and Expiration dates                       *   FILE 807\n//*           - Approximate tape length of each tape file, and      *   FILE 807\n//*               the approximate total tape length of all          *   FILE 807\n//*               processed files                                   *   FILE 807\n//*                                                                 *   FILE 807\n//*          The SYSUT1 input file record formats may be fixed,     *   FILE 807\n//*     variable, undefined, blocked, spanned, standard or any      *   FILE 807\n//*     valid combination of these formats, but the file must be    *   FILE 807\n//*     physical sequential.  The RECFM, LRECL and BLKSIZE of       *   FILE 807\n//*     these files need not be known before- hand.  One file in    *   FILE 807\n//*     print format (SYSUT2) is generated and one output tape      *   FILE 807\n//*     volume may be created (TAPECOPY). The printout can be in    *   FILE 807\n//*     any one of five display formats. Variable-length records    *   FILE 807\n//*     can be printed in readable form.  It shows all bytes of     *   FILE 807\n//*     the block including the BDW and the RDW if any.             *   FILE 807\n//*                                                                 *   FILE 807\n//*          An optional output file can be coded to capture        *   FILE 807\n//*     status and sense bytes from reads of tape/cartridge data    *   FILE 807\n//*     sets.                                                       *   FILE 807\n//*                                                                 *   FILE 807\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMALL": {"ttr": 5896, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00B\\x01\\t\\x15\\x8f\\x01\\t \\x8f\\x14&\\x00C\\x00\\x19\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2009-06-07T00:00:00", "modifydate": "2009-07-27T14:26:42", "lines": 67, "newlines": 25, "modlines": 0, "user": "CN03MQK"}, "text": "//M45HFS   JOB 0,'CTM',MSGCLASS=X,CLASS=A,MSGLEVEL=(2,0),COND=(8,LE),\n//  NOTIFY=M45\n//** COMPILE AND LINK\n//ASMMCL  PROC MAC='SYS1.MACLIB',\n//             MAC1='SYS1.MODGEN',\n//             SRCLIB='M45.HFSELECT.PDS',\n//             LOADLIB='M45.LOAD',\n//             MEMBER=DUMMY,\n//             UNIT=SYSALLDA           DEFAULT IS: ANY PUBLIC DISK\n//C       EXEC PGM=ASMA90,PARM='NOOBJ,DECK',REGION=1512K\n//SYSLIB   DD  DSN=&MAC,DISP=SHR,DCB=BLKSIZE=32720\n//         DD  DSN=&MAC1,DISP=SHR\n//         DD  DSN=&SRCLIB,DISP=SHR\n//SYSUT1   DD  UNIT=&UNIT,SPACE=(1700,(1600,100))\n//SYSUT2   DD  UNIT=&UNIT,SPACE=(1700,(300,50))\n//SYSUT3   DD  UNIT=&UNIT,SPACE=(1700,(300,50))\n//SYSPRINT DD  SYSOUT=*,DCB=BLKSIZE=1089\n//SYSPUNCH DD  DSN=&&OBJECT,UNIT=&UNIT,SPACE=(280,(200,250)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),\n//             DISP=(,PASS)\n//SYSIN    DD  DISP=SHR,DSN=&SRCLIB(&MEMBER)\n//*\n//L       EXEC PGM=IEWL,PARM=(LET,LIST,NCAL),REGION=512K,\n//             COND=(8,LE,C)\n//SYSLIN   DD  DSN=&&OBJECT,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DISP=SHR,DSN=&LOADLIB\n//SYSLIB   DD  DISP=SHR,DSN=&LOADLIB\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=&UNIT,SPACE=(1024,(50,20))\n//SYSPRINT DD  SYSOUT=*\n//   PEND\n//*\n//MKMESSAG EXEC ASMMCL,MEMBER=MKMESSAG\n//L.SYSIN  DD  *\n  NAME MKMESSAG(R)\n//*\n//SYNADERR EXEC ASMMCL,MEMBER=SYNADERR\n//L.SYSIN  DD  *\n  NAME SYNADERR(R)\n//*\n//SCAN4HIT EXEC ASMMCL,MEMBER=SCAN4HIT\n//L.SYSIN  DD  *\n  NAME SCAN4HIT(R)\n//*\n//READVTC  EXEC ASMMCL,MEMBER=READVTC\n//L.SYSIN  DD  *\n  NAME READVTC(R)\n//*\n//VOL2DEVT EXEC ASMMCL,MEMBER=VOL2DEVT\n//L.SYSIN  DD  *\n  NAME VOL2DEVT(R)\n//*\n//FILSPAC  EXEC ASMMCL,MEMBER=FILSPACE\n//L.SYSIN  DD  *\n  INCLUDE SYSLIB(VOL2DEVT)\n  NAME FILSPACE(R)\n//*\n//HFSELECT EXEC ASMMCL,MEMBER=HFSELECT\n//L.SYSIN  DD  *\n  INCLUDE SYSLIB(MKMESSAG,SYNADERR,SCAN4HIT,FILSPACE)\n  NAME HFSELECT(R)\n//*\n//SUPRDUMP EXEC ASMMCL,MEMBER=SUPRDUMP\n//L.SYSIN  DD  *\n  NAME SUPRDUMP(R)\n//\n//*INCLUDE SYSLIB(IOAGBE,IOARME)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMHCL": {"ttr": 5898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02(\\x00\\x00\\x00\\x88\\x04\\x8f\\x00\\x96\\x10/\\t0\\x001\\x00\\x1a\\x00,\\xc3\\xd5\\xf0\\xf3\\xd5\\xd1\\xd3@@@'", "ispf": {"version": "02.40", "flags": 0, "createdate": "1988-02-17T00:00:00", "modifydate": "1996-04-11T09:30:00", "lines": 49, "newlines": 26, "modlines": 44, "user": "CN03NJL"}, "text": "//CN03MQKH JOB (CN03,SYSP,OD69),'KARLIN',MSGLEVEL=(2,0),CLASS=M,\n//   MSGCLASS=A,NOTIFY=CN03MQK\n/*JOBPARM  ROOM=259\n//MESSAG EXEC  ASMHCL,\n//       PARM.LKED='XREF,LET,LIST,NCAL'        TEST REMOVED\n//ASM.SYSTERM DD  SYSOUT=A,DCB=BLKSIZE=1089\n//ASM.SYSIN  DD  DSN=CN03MQK.HFSELECT(MKMESSAG),DISP=SHR\n//LKED.SYSLMOD  DD  DSN=HRA.LOADLIB(MKMESSAG),DISP=SHR\n//SYNAD  EXEC  ASMHCL,\n//       PARM.LKED='TEST,XREF,LET,LIST,NCAL'\n//ASM.SYSTERM DD  SYSOUT=A,DCB=BLKSIZE=1089\n//ASM.SYSIN  DD  DSN=CN03MQK.HFSELECT(SYNADERR),DISP=SHR\n//LKED.SYSLMOD  DD  DSN=HRA.LOADLIB(SYNADERR),DISP=SHR\n//HFSELECT EXEC  ASMHCL,\n//       PARM.ASM='NODECK,OBJECT,XREF(SHORT)', TEST REMOVED\n//*      TERM,NUM,STMT,NOLIST,NOXREF),\n//       PARM.LKED='XREF,LET,LIST,AC=1'          TEST REMOVED\n//ASM.SYSPRINT DD SYSOUT=C,CHARS=MK11,DEST=LOCAL\n//ASM.SYSTERM DD  SYSOUT=A,DCB=BLKSIZE=1089\n//ASM.SYSIN  DD  DSN=CN03MQK.HFSELECT(HFSELECT),DISP=SHR\n//LKED.SYSLMOD  DD  DSN=HRA.LOADLIB(HFSELECT),DISP=SHR\n//LKED.SYSPRINT DD SYSOUT=C,CHARS=MK11,DEST=LOCAL\n//LKED.SYSLIB   DD DSN=SYS1.HRALIB,DISP=SHR   <=== NEEDED FOR SCAN4HIT\n//LKED.DD1  DD  DSN=HRA.LOADLIB,DISP=SHR\n//LKED.SYSIN  DD  *\n   INCLUDE  DD1(SYNADERR,MKMESSAG)\n//\n//SCAN4HIT EXEC ASMHCL,\n//         PARM.LKED='LIST,LET,MAP,XREF'\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSIN    DD DSN=CN03MQK.HFSELECT(SCAN4HIT),DISP=SHR\n//LKED.SYSLMOD DD DSN=SYS1.HRALIB(SCAN4HIT),DISP=SHR\n//\n//READVTC  EXEC  ASMHCL,\n//       PARM.LKED='XREF,LET,LIST,NCAL,AC=1'\n//ASM.SYSIN  DD  DSN=CN03MQK.HFSELECT(READVTC),DISP=SHR\n//LKED.SYSLMOD  DD  DSN=HRA.LOADLIB(READVTC),DISP=SHR\n//\n//SUPRDUMP EXEC ASMHCL,\n//       PARM.LKED='XREF,LET,LIST,NCAL,AC=1'\n//ASM.SYSIN  DD  DSN=CN03MQK.HFSELECT(SUPRDUMP),DISP=SHR\n//LKED.SYSLMOD  DD  DSN=SYS1.SHARE1(SUPRDUMP),DISP=SHR\n//\n//ASMHCL EXEC  ASMHCL,\n//       PARM.LKED='XREF,LET'\n//ASM.SYSIN  DD  DSN=CN03MQK.HFSELECT(WTOR),DISP=SHR\n//LKED.SYSLMOD  DD  DSN=HRA.LOADLIB(WTOR),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMSBG": {"ttr": 5900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x17\\x01\\t\\x15\\x8f\\x01\\t \\x8f\\x14&\\x00C\\x00\\x19\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2009-06-07T00:00:00", "modifydate": "2009-07-27T14:26:17", "lines": 67, "newlines": 25, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBS JOB 0,'CTM',MSGCLASS=X,CLASS=B,MSGLEVEL=(2,0),COND=(8,LE),\n//  NOTIFY=&SYSUID\n//** COMPILE AND LINK\n//ASMMCL  PROC MAC='SYS1.MACLIB',\n//             MAC1='SYS1.MODGEN',\n//             SRCLIB='SBGOLOB.CBT478.FILE807',\n//             LOADLIB='SBGOLOB.LOAD',\n//             MEMBER=DUMMY,\n//             UNIT=SYSALLDA           DEFAULT IS: ANY PUBLIC DISK\n//C       EXEC PGM=ASMA90,PARM='NOOBJ,DECK',REGION=1512K\n//SYSLIB   DD  DSN=&MAC,DISP=SHR,DCB=BLKSIZE=32720\n//         DD  DSN=&MAC1,DISP=SHR\n//         DD  DSN=&SRCLIB,DISP=SHR\n//SYSUT1   DD  UNIT=&UNIT,SPACE=(1700,(1600,100))\n//SYSUT2   DD  UNIT=&UNIT,SPACE=(1700,(300,50))\n//SYSUT3   DD  UNIT=&UNIT,SPACE=(1700,(300,50))\n//SYSPRINT DD  SYSOUT=*,DCB=BLKSIZE=1089\n//SYSPUNCH DD  DSN=&&OBJECT,UNIT=&UNIT,SPACE=(280,(200,250)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),\n//             DISP=(,PASS)\n//SYSIN    DD  DISP=SHR,DSN=&SRCLIB(&MEMBER)\n//*\n//L       EXEC PGM=IEWL,PARM=(LET,LIST,NCAL),REGION=512K,\n//             COND=(8,LE,C)\n//SYSLIN   DD  DSN=&&OBJECT,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DISP=SHR,DSN=&LOADLIB\n//SYSLIB   DD  DISP=SHR,DSN=&LOADLIB\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=&UNIT,SPACE=(1024,(50,20))\n//SYSPRINT DD  SYSOUT=*\n//   PEND\n//*\n//MKMESSAG EXEC ASMMCL,MEMBER=MKMESSAG\n//L.SYSIN  DD  *\n  NAME MKMESSAG(R)\n//*\n//SYNADERR EXEC ASMMCL,MEMBER=SYNADERR\n//L.SYSIN  DD  *\n  NAME SYNADERR(R)\n//*\n//SCAN4HIT EXEC ASMMCL,MEMBER=SCAN4HIT\n//L.SYSIN  DD  *\n  NAME SCAN4HIT(R)\n//*\n//READVTC  EXEC ASMMCL,MEMBER=READVTC\n//L.SYSIN  DD  *\n  NAME READVTC(R)\n//*\n//VOL2DEVT EXEC ASMMCL,MEMBER=VOL2DEVT\n//L.SYSIN  DD  *\n  NAME VOL2DEVT(R)\n//*\n//FILSPAC  EXEC ASMMCL,MEMBER=FILSPACE\n//L.SYSIN  DD  *\n  INCLUDE SYSLIB(VOL2DEVT)\n  NAME FILSPACE(R)\n//*\n//HFSELECT EXEC ASMMCL,MEMBER=HFSELECT\n//L.SYSIN  DD  *\n  INCLUDE SYSLIB(MKMESSAG,SYNADERR,SCAN4HIT,FILSPACE)\n  NAME HFSELECT(R)\n//*\n//SUPRDUMP EXEC ASMMCL,MEMBER=SUPRDUMP\n//L.SYSIN  DD  *\n  NAME SUPRDUMP(R)\n//\n//*INCLUDE SYSLIB(IOAGBE,IOARME)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMSLC": {"ttr": 5902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x92#\\x1f\\x00\\x93\\x12_\\x187\\x008\\x008\\x00\\x01\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1992-08-18T00:00:00", "modifydate": "1993-05-05T18:37:00", "lines": 56, "newlines": 56, "modlines": 1, "user": "CN03MQK"}, "text": "//CN03MQKH JOB (CN03,SYSP,OD69),'KARLIN ',MSGLEVEL=(2,0),CLASS=M,\n//   MSGCLASS=A,NOTIFY=CN03MQK\n/*JOBPARM ROOM=259\n//ASMSLC PROC  OUTPUT='*'\n//ASM    EXEC  PGM=AEV90,PARM='NODECK,OBJECT,XREF(SHORT)',REGION=768K\n//STEPLIB  DD DSN=CN03MQK.SLCASM.LOAD,DISP=SHR    <==========  SLCASM\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS2.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1\n//SYSPUNCH DD SYSOUT=B,DCB=(BLKSIZE=800),SPACE=(CYL,(5,5,0))\n//SYSPRINT DD SYSOUT=&OUTPUT,\n//            DCB=(BLKSIZE=3509),UNIT=(,SEP=(SYSUT1,SYSPUNCH))\n//SYSLIN   DD DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),\n//            DSN=&&LOADSET,DCB=BLKSIZE=400\n//******************************************************************\n//*\n//LKED     EXEC  PGM=IEWL,PARM='MAP,LET,LIST,NCAL',COND=(8,LT,ASM)\n//SYSLIN   DD DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(2,1,2)),\n//            DSN=&GOSET(GO)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(3,2)),DSN=&SYSUT1\n//SYSPRINT DD SYSOUT=&OUTPUT,DCB=(RECFM=FB,BLKSIZE=3509)\n//   PEND\n//*\n//SELECT EXEC  ASMSLC,\n//       PARM.ASM='NODECK,OBJECT,XREF(SHORT)', TEST REMOVED\n//*      TERM,NUM,STMT,NOLIST,NOXREF),\n//       PARM.LKED='XREF,LET,LIST,AC=1'          TEST REMOVED\n//ASM.SYSPRINT DD SYSOUT=C,CHARS=MK11,DEST=LOCAL\n//ASM.SYSTERM DD  SYSOUT=A,DCB=BLKSIZE=1089\n//ASM.SYSIN  DD  DSN=CN03MQK.HFSELECT(HFSELECT),DISP=SHR\n//LKED.SYSLMOD  DD  DSN=HRA.LOADLIB(HFSELECT),DISP=SHR\n//LKED.SYSPRINT DD SYSOUT=C,CHARS=MK11,DEST=LOCAL\n//LKED.SYSLIB   DD DSN=SYS1.HRALIB,DISP=SHR   <=== NEEDED FOR SCAN4HIT\n//LKED.DD1  DD  DSN=HRA.LOADLIB,DISP=SHR\n//LKED.SYSIN  DD  *\n   INCLUDE  DD1(SYNADERR,MKMESSAG)\n//\n//MESSAG EXEC  ASMSLC,\n//       PARM.LKED='XREF,LET,LIST,NCAL'        TEST REMOVED\n//ASM.SYSTERM DD  SYSOUT=A,DCB=BLKSIZE=1089\n//ASM.SYSIN  DD  DSN=CN03MQK.HFSELECT(MKMESSAG),DISP=SHR\n//LKED.SYSLMOD  DD  DSN=HRA.LOADLIB(MKMESSAG),DISP=SHR\n//SYNAD  EXEC  ASMSLC,\n//       PARM.LKED='TEST,XREF,LET,LIST,NCAL'\n//ASM.SYSTERM DD  SYSOUT=A,DCB=BLKSIZE=1089\n//ASM.SYSIN  DD  DSN=CN03MQK.HFSELECT(SYNADERR),DISP=SHR\n//LKED.SYSLMOD  DD  DSN=HRA.LOADLIB(SYNADERR),DISP=SHR\n//\n//READEXCP EXEC ASMSLC,\n//       PARM.LKED='XREF,LET,LIST,NCAL'        TEST REMOVED\n//ASM.SYSIN  DD  DSN=CN03MQK.HFSELECT(TESTPGM),DISP=SHR\n//LKED.SYSLMOD  DD  DSN=HRA.LOADLIB(TESTPGM),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILSPACE": {"ttr": 5904, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x17O\\x00\\x93\\x17O\\x18S\\x01\\xf9\\x01\\xf9\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-06-23T00:00:00", "modifydate": "1993-06-23T18:53:00", "lines": 505, "newlines": 505, "modlines": 0, "user": "CN03MQK"}, "text": "         PRINT ON,NOGEN\n         SPACE 3\n*        THIS PROGRAM IS A SUBROUTINE THAT ACCEPTS A DATASET NAME\n*        AND THE VOLUME SERIAL NUMBER THAT IS PASSED TO IT AND\n*        RETURNS TO THE INVOKER THE NUMBER OF USED EXTENTS AND THE\n*        NUMBER OF USED TRACKS.\n*\n*        TO USE THIS SUBROUTINE, DO THE FOLLOWING:\n*\n*           1.  PLACE THE FOLLOWING DATA AREA IN THE WORKING-STORAGE:\n*\n*               01  FILSPACE-I-O-AREA.\n*                   05  FILLER                    PIC X(02).\n*                   05  IN-DSN                    PIC X(44).\n*                   05  IN-VOL-SER                PIC X(06).\n*                   05  OUT-NO-OF-USED-EXTENTS    PIC 9(2).\n*                   05  OUT-NO-OF-USED-TRACKS     PIC 9(5).\n*\n*           2.  PLACE THE FOLLOWING CODE IN THE PROCEDURE DIVISION:\n*\n*               MOVE DATASET NAME\n*                 TO IN-DSN OF FILSPACE-I-O-AREA.\n*\n*               MOVE VOLUME SERIAL NUMBER\n*                 TO IN-VOL-SER OF FILSPACE-I-O-AREA.\n*\n*               CALL 'FILSPACE' USING FILSPACE-I-O-AREA.\n*\n*\n*        POSSIBLE RETURN CODES\n*        _____________________\n*\n*           RETURN CODE        MEANING\n*           ___________        ______________________________________\n*\n*               0              SUCCESSFUL COMPLETION\n*               4              REQUIRED VOLUME IS NOT MOUNTED\n*               8              DATASET IS NOT FOUND ON VOLUME\n*                                  INDICATED\n*               12             OBTAIN MACRO RETURNED WITH\n*                                  RC = 12, 16, OR 20\n*               16             ERROR IN VOL2DEVT WAS ENCOUNTERED\n*\n*\n         EJECT\n         SPACE 3\n*\n**********************************************\n*                                            *\n*        I N I T I A L I Z A T I O N         *\n*                                            *\n**********************************************\n*\nFILSPACE CSECT\n         SAVE  (14,12)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        SAVE REGISTER 1 IN REGISTER 11 AND LOAD PARAMETER FIELD   *\n*        INTO PASSAREA                                             *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\nSTARTIT  DS    0D\n         LR    R11,R1              SAVE REGISTER 1 CONTENTS IN REG 11\n         L     R9,0(R11)\n         MVC   PASSAREA,0(R9)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n*\n         MVC   PROCESSW,=CL3'YES'  MOVE 'YES' TO PROCESSW\n         LA    R10,0               R10 ==> 0\n*\n         BAL   R14,OBTANE          PERFORM ROUTINE TO DO OBTAIN\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   GETOUT              IF SO, BRANCH TO GETOUT\n         BAL   R14,EYEDSCB1        PERFORM ROUTINE TO PROCESS THE DSCB1\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   GETOUT              IF SO, BRANCH TO GETOUT\n         CLC   PROCDCB3,=CL3'YES'  DO WE NEED TO PROCESS THE DSCB3 ?\n         BNE   GETOUT              IF NOT, BRANCH TO GETOUT\n         BAL   R14,EYEDSCB3        PERFORM ROUTINE TO PROCESS THE DSCB3\nGETOUT   B     SHUTDOWN            BRANCH TO SHUTDOWN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR DOING AN OBTAIN ON THE    *\n*        DATASET NAME                                              *\n*                                                                  *\n*        IF THE OBTAIN MACRO ISSUES A RETURN CODE OF 0, THEN       *\n*        THIS ROUTINE MOVES 'YES' TO PROCESSW ELSE IT MOVES        *\n*        'NO ' TO PROCESSW                                         *\n*                                                                  *\n********************************************************************\n*\nOBTANE   ST    R14,SAVEIT1\nOBTAAN   OBTAIN CAMLIST2\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    EXITOBT                IF REG 15=0, BRANCH TO EXITOBT\n         C     R15,=F'4'              COMPARE REG 15 TO BE = 4\n         BE    RCODE4                 IF REG 15=4, BRANCH TO RCODE4\n         C     R15,=F'8'              COMPARE REG 15 TO BE = 8\n         BE    RCODE8                 IF REG 15=8, BRANCH TO RCODE8\n         LA    R10,12                 R10==> 12\n         B     MOVENOPE               BRANCH TO MOVENOPE\nRCODE4   LA    R10,4                  R10==> 4\n         B     MOVENOPE               BRANCH TO MOVENOPE\nRCODE8   LA    R10,8                  R10==> 8\nMOVENOPE MVC   PROCESSW,=CL3'NO '     MOVE 'NO ' TO PROCESSW\nEXITOBT  L     R14,SAVEIT1\n         BR    14                     RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR PROCESSING THE DSCB1.     *\n*                                                                  *\n*        IF AN ERROR IS ENCOUNTERED, THIS ROUTINE DOES THE         *\n*        FOLLOWING:                                                *\n*                                                                  *\n*             .  MOVES 'NO ' TO PROCESSW                           *\n*             .  MOVES APPROPRIATE VALUE TO REGISTER 10            *\n*                   WHICH IDENTIFIES THE REASON FOR THE ERROR      *\n*                                                                  *\n*        IF NO ERROR IS ENCOUNTERED AND THIS ROUTINE CALCULATES    *\n*        THAT THE USED EXTENTS DOES NOT EXCEED 3 (HENCE THERE      *\n*        IS NO DSCB3), THEN THIS ROUTINE DOES THE FOLLOWING:       *\n*                                                                  *\n*             .  MOVES 'NO ' TO PROCDCB3                           *\n*             .  MOVES APPROPRIATE VALUE TO OUTTRKNO               *\n*             .  MOVES APPROPRIATE VALUE TO OUTEXTNO               *\n*                   (I.E 1, 2 OR 3)                                *\n*                                                                  *\n*        IF NO ERROR IS ENCOUNTERED AND THIS ROUTINE CALCULATES    *\n*        THAT THE USED EXTENTS DOES EXCEED 3 AND THAT IT NEEDS TO  *\n*        PROCESS THE DSCB3, THEN THIS ROUTINE DOES THE FOLLOWING:  *\n*                                                                  *\n*             .  MOVES 'YES' TO PROCDCB3                           *\n*             .  MOVES APPROPRIATE VALUE TO OUTTRKNO               *\n*                                                                  *\n********************************************************************\n*\nEYEDSCB1 ST    R14,SAVEIT2\n         MVC   PROCDCB3,=CL3'NO '  MOVE 'NO ' TO PROCDCB3\n         ZAP   RUNTOT,PACKED0      RUNTOT = 0\n*\n         MVC   DS1LSTAR,OBTAREA+54\n         CLC   DS1LSTAR,=XL3'000000'\n         BNE   NOTEMPTY\n         MVC   OUTEXTNO,=CL2'00'\n         MVC   OUTTRKNO,=CL5'00000'\n         B     EXITDCB1\nNOTEMPTY MVC   HALFWORD(2),DS1LSTAR\n         LH    R5,HALFWORD\n         AH    R5,=H'1'\n         CVD   R5,CVDOPRND\n         MVC   LSTRTRKS(3),CVDOPRND+5\n         UNPK  OUTTRKNO(5),LSTRTRKS(3)\n         OI    OUTTRKNO+4,X'F0'\n*\n         CLI   OBTAREA+61,X'00'    IS 1ST EXTENT DESC INSIGNIFICANT ?\n         BE    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         MVC   OUTEXTNO,=CL2'01'   MOVE 01 TO OUTEXTNO\n         MVC   BGNCCHH(4),OBTAREA+63\n         MVC   ENDCCHH(4),OBTAREA+67\n         BAL   R14,CALCTRKS        PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                      TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                      DS1LSTAR VALUE ?\n         BNH   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         CLI   OBTAREA+71,X'00'    IS 2ND EXTENT DESC INSIGNIFICANT ?\n         BE    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         MVC   OUTEXTNO,=CL2'02'   MOVE 02 TO OUTEXTNO\n         MVC   BGNCCHH(4),OBTAREA+73\n         MVC   ENDCCHH(4),OBTAREA+77\n         BAL   R14,CALCTRKS        PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                      TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                      DS1LSTAR VALUE ?\n         BNH   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         CLI   OBTAREA+81,X'00'    IS 3RD EXTENT DESC INSIGNIFICANT ?\n         BE    EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         MVC   OUTEXTNO,=CL2'03'   MOVE 03 TO OUTEXTNO\n         MVC   BGNCCHH(4),OBTAREA+83\n         MVC   ENDCCHH(4),OBTAREA+87\n         BAL   R14,CALCTRKS        PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                      TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                      DS1LSTAR VALUE ?\n         BNH   EXITDCB1            IF SO, BRANCH TO EXITDCB1\n         MVC   PROCDCB3,=CL3'YES'  MOVE 'YES' TO PROCDCB3\n         MVC   CCHHR,OBTAREA+91    MOVE CCHHR PTR FOR DSCB3 TO CCHHR\nEXITDCB1 L     R14,SAVEIT2\n         BR    14                  RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        THIS ROUTINE IS RESPONSIBLE FOR PROCESSING THE DSCB3      *\n*        AND THEN GENERATING THE EXTENT NUMBER                     *\n*                                                                  *\n********************************************************************\n*\nEYEDSCB3 ST    R14,SAVEIT3\nDODSCB3  OBTAIN CAMLIST3\n         SPACE 2\n         C     R15,=F'0'              COMPARE REG 15 TO BE = 0\n         BE    COUNTEM                IF REG 15=0, BRANCH TO COUNTEM\n         C     R15,=F'4'              COMPARE REG 15 TO BE = 4\n         BE    DSCB3RC4               IF REG 15=4, BRANCH TO DSCB3RC4\n         C     R15,=F'8'              COMPARE REG 15 TO BE = 8\n         BE    DSCB3RC8               IF REG 15=8, BRANCH TO DSCB3RC8\n         LA    R10,12                 R10==> 12\n         B     EXITDCB3               BRANCH TO EXITDCB3\nDSCB3RC4 LA    R10,4                  R10==> 4\n         B     EXITDCB3               BRANCH TO EXITDCB3\nDSCB3RC8 LA    R10,8                  R10==> 8\n         B     EXITDCB3               BRANCH TO EXITDCB3\nCOUNTEM  ZAP   PACKEXT#,PACKED3\n         LA    R5,DCB3AREA            R5 ==> ADDRESS OF DSCB3\n         A     R5,=F'4'               OFFSET TO DS3EXTNT\n         LA    R6,1\nLOOP3A   C     R6,=F'4'\n         BH    NXTGROUP\n         CLI   0(R5),X'00'\n         BE    UNPKEXT#\n         AP    PACKEXT#,PACKED1\n         MVC   BGNCCHH(4),2(R5)\n         MVC   ENDCCHH(4),6(R5)\n         BAL   R14,CALCTRKS        PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB3            IF SO, BRANCH TO EXITDCB3\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                      TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                      DS1LSTAR VALUE ?\n         BNH   UNPKEXT#            IF SO, BRANCH TO UNPKEXT#\n         A     R6,=F'1'\n         A     R5,=F'10'\n         B     LOOP3A\nNXTGROUP A     R5,=F'1'            OFFSET TO DS3ADEXT\n         LA    R6,1\nLOOP3B   C     R6,=F'9'\n         BH    UNPKEXT#\n         CLI   0(R5),X'00'\n         BE    UNPKEXT#\n         AP    PACKEXT#,PACKED1\n         MVC   BGNCCHH(4),2(R5)\n         MVC   ENDCCHH(4),6(R5)\n         BAL   R14,CALCTRKS        PERFORM ROUTINE TO CALCULATE\n*                                  NUMBER OF TRACKS USED IN THIS EXTENT\n         CLC   PROCESSW,=CL3'YES'  WERE ANY ERRORS ENCOUNTERED ?\n         BNE   EXITDCB3            IF SO, BRANCH TO EXITDCB3\n         AP    RUNTOT,TOTRACKS     RUNTOT = TOTAL NUMBER OF USED TRACKS\n*                                      TO THIS POINT\n         CP    LSTRTRKS,RUNTOT     DOES THIS EXTENT PUT US PAST THE\n*                                      DS1LSTAR VALUE ?\n         BNH   UNPKEXT#            IF SO, BRANCH TO UNPKEXT#\n         A     R6,=F'1'\n         A     R5,=F'10'\n         B     LOOP3B\nUNPKEXT# UNPK  OUTEXTNO(2),PACKEXT#(3)\n         OI    OUTEXTNO+1,X'F0'\nEXITDCB3 L     R14,SAVEIT3\n         BR    14                  RETURN\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        THIS ROUTINE CALCULATES THE NUMBER OF TRACKS GIVEN           *\n*        A BEGINNING CCHH AND AN ENDING CCHH                          *\n*                                                                     *\n*        BEFORE PERFORMING THIS ROUTINE, DO THE FOLLOWING:            *\n*                   MOVE THE BEGINNING CCHH TO BGNCCHH                *\n*                   MOVE THE ENDING CCHH TO ENDCCHH                   *\n*                                                                     *\n*        AFTER PERFORMING THIS ROUTINE, THE NUMBER OF USED            *\n*        TRACKS WILL BE IN TOTRACKS                                   *\n*                                                                     *\n***********************************************************************\n*\nCALCTRKS ST    R14,SAVEIT4        STORE R14 CONTENTS IN SAVEIT4\n         LH    R7,BGNCCHH              ----\n         CVD   R7,CVDOPRND               ----- PACK BEGINNING CYL\n         MVC   BEGINCYL(3),CVDOPRND+5  ----\n         LH    R7,ENDCCHH              ----\n         CVD   R7,CVDOPRND               ----- PACK ENDING CYL\n         MVC   ENDCYL(3),CVDOPRND+5    ----\n         LH    R7,BGNCCHH+2            ----\n         CVD   R7,CVDOPRND               ----- PACK BEGINNING TRK\n         MVC   BEGINTRK(3),CVDOPRND+5  ----\n         LH    R7,ENDCCHH+2            ----\n         CVD   R7,CVDOPRND               ----- PACK ENDING TRK\n         MVC   ENDTRK(3),CVDOPRND+5    ----\n         ZAP   CYLDIFF,ENDCYL          CYLDIFF = ENDING CYL #\n         SP    CYLDIFF,BEGINCYL        CYLDIFF = ENDING CYL - BEGIN CYL\n         BAL   14,DETRKCYL             THIS ROUTINE EXAMINES VOL SER\n*                                          TO DETERMINE THE # OF TRACKS\n*                                          PER CYLINDER AND PLACES THE\n*                                          ANSWER IN TRKPRCYL\n         CP    ENDTRK,BEGINTRK         IF ENDING TRK # > BEGINNING TRK\n         BH    ENDISGT                    # THEN BRANCH TO ENDISGT\n         ZAP   TRKDIFF,ENDTRK          TRKDIFF = ENDING TRACK #\n         SP    TRKDIFF,BEGINTRK        TRKDIFF = ENDING TRK - BEGIN TRK\n         AP    TRKDIFF,PACKED1         ADD 1 TO TRKDIFF\n         B     DOCALC                  BRANCH TO DOCALC\nENDISGT  SP    CYLDIFF,PACKED1         SUBTRACT 1 FROM CYLDIFF\n         ZAP   REMANTRK,TRKPRCYL       REMANTRK = TRKPRCYL\n         SP    REMANTRK,BEGINTRK       REMANTRK = TRKPRCYL - BEGINTRK\n         ZAP   TRKDIFF,REMANTRK        TRKDIFF = REMANTRK\n         AP    TRKDIFF,ENDTRK          TRKDIFF = REMANTRK + ENDTRK\n         AP    TRKDIFF,PACKED1         ADD 1 TO TRKDIFF\nDOCALC   ZAP   TOTRACKS,TRKPRCYL       TOTRACKS = TRKPRCYL\n         MP    TOTRACKS,CYLDIFF        TOTRACKS = TRKPRCYL X CYLDIFF\n         AP    TOTRACKS,TRKDIFF        ADD TRKDIFF TO TOTRACKS\n         L     R14,SAVEIT4\n         BR    R14                     RETURN\n         EJECT\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*        THIS ROUTINE EXAMINES VOL SER TO DETERMINE THE DEVICE TYPE   *\n*        IN ORDER TO DETERMINE THE NUMBER OF TRACKS PER CYLINDER      *\n*                                                                     *\n*        AFTER PERFORMING THIS ROUTINE, THE NUMBER OF TRACKS PER      *\n*        CYLINDER IS IN TRKPRCYL                                      *\n*                                                                     *\n*        IF AN ERROR IS ENCOUNTERED IN THIS ROUTINE, IT WILL          *\n*        MOVE 'NO ' TO PROCESSW AND LOAD REGISTER 10 WITH 16          *\n*                                                                     *\n***********************************************************************\n*\nDETRKCYL ST    R14,SAVEIT5\n         MVC   VOL2DVOL,INVOL     MOVE VOL SER TO VOL2DVOL\n         CALL  VOL2DEVT,(DEVTAREA),VL\n         C     R15,=F'0'          WAS VOL2DEVT SUCCESSFUL ?\n         BE    EYEDEVT            IF SO, BRANCH TO EYEDEVT\n         MVC   PROCESSW,=CL3'NO ' MOVE 'NO ' TO PROCESSW\n         LA    R10,16             R10 ==> 16\n         B     EXITDETR           BRANCH TO EXITDETR\nEYEDEVT  CLC   OUTDEVT(4),=CL4'3330'\n         BE    D3330\n         CLC   OUTDEVT(4),=CL4'3350'\n         BE    D3350\n         CLC   OUTDEVT(4),=CL4'3380'\n         BE    D3380\n         MVC   PROCESSW,=CL3'NO ' MOVE 'NO ' TO PROCESSW\n         LA    R10,16             R10 ==> 16\n         B     EXITDETR           BRANCH TO EXITDETR\nD3330    ZAP   TRKPRCYL,PACKED19  MOVE 19 TO TRKPRCYL\n         B     EXITDETR           BRANCH TO EXITDETR\nD3350    ZAP   TRKPRCYL,PACKED30  MOVE 30 TO TRKPRCYL\n         B     EXITDETR           BRANCH TO EXITDETR\nD3380    ZAP   TRKPRCYL,PACKED15  MOVE 15 TO TRKPRCYL\nEXITDETR L     R14,SAVEIT5\n         BR    R14                RETURN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        E N D  O F   J O B   P R O C E S S I N G                  *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN LR    R15,R10\n         L     R9,0(R11)\n         MVC   0(59,R9),PASSAREA\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        BREAKDOWN OF PASSAREA                                     *\n*                                                                  *\n********************************************************************\n*\n         DS    0F\nPASSAREA DS    0CL59\n         DS    CL2\nINDSN    DS    CL44\nINVOL    DS    CL6\nOUTEXTNO DS    CL2\nOUTTRKNO DS    CL5\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        V O L 2 D E V T   L I N K A G E   A R E A                 *\n*                                                                  *\n********************************************************************\n*\nDEVTAREA DS    0CL16\nVOL2DVOL DS    CL6\nOUTDEVT  DS    CL8\nOUTLEN   DS    CL2\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A S                                       *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nSAVEIT1  DS    F\nSAVEIT2  DS    F\nSAVEIT3  DS    F\nSAVEIT4  DS    F\nSAVEIT5  DS    F\n         DS    0D\nCAMLIST2 CAMLST SEARCH,INDSN,INVOL,OBTAREA\nOBTAREA  DS    0D\n         DS    140C\n         DS    0D\nCAMLIST3 CAMLST SEEK,CCHHR,INVOL,DCB3AREA\nDCB3AREA DS    0D\n         DS    140C\nPROCESSW DS    CL3\nPROCDCB3 DS    CL3\nCCHHR    DS    CL5\nBEGINCYL DS    PL3\nBEGINTRK DS    PL3\nBGNCCHH  DS    F\nCVDOPRND DS    D\nCYLDIFF  DS    PL3\nDS1LSTAR DS    CL3\nENDCCHH  DS    F\nENDCYL   DS    PL3\nENDTRK   DS    PL3\nHALFWORD DS    H\nLSTRTRKS DS    PL3\nPACKED0  DC    PL2'0'\nPACKED1  DC    PL2'1'\nPACKED3  DC    PL2'3'\nPACKED15 DC    PL2'15'\nPACKED19 DC    PL2'19'\nPACKED30 DC    PL2'30'\nPACKEXT# DS    PL3\nREMANTRK DS    PL3\nRUNTOT   DS    PL6\nTOTRACKS DS    PL6\nTRKDIFF  DS    PL3\nTRKPRCYL DS    PL3\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HFSELECT": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02c\\x00W\\x00\\x92\\x05\\x1f\\x01\\t\\x17?\\x16\"\\x1d\\xee\\x1b\\xa5\\x03e\\xd4\\xf4\\xf5@@@@@@@'", "ispf": {"version": "02.99", "flags": 0, "createdate": "1992-02-20T00:00:00", "modifydate": "2009-06-22T16:22:57", "lines": 7662, "newlines": 7077, "modlines": 869, "user": "M45"}, "text": "*----CHANGE LOG FOR V4.3 ---------------------------------------\n* @MK1 6/14/09 CORRECT ADDRESSABILITY ERRORS FOR Z/OS (1.10)\n*              INFINITE LOOP IN SPIE RTN\n*              FALSE SECURITY VIOLATION INDICATIONS\n*              CHANGE DYN ALLOC 'SYSDA' TO 'SYSALLDA'\n*---------------------------------------------------------------\n         TITLE 'IN-LINE MACROS (MESSAGES,DATE, TIOT AND SUBOPT)'\n         MACRO\n&LABEL   LNKMSG   &MSGNUM,&BRANCH=,&RETURN=NO,&EDIT=,&DATA=\n.*    THE MSGNUM SYMBOLIC CAN BE A DECIMAL NUMBER OR OR A REGISTER\n.*        (IN THE NOTATION RX) CONTAINING THE MSG NUMBER\n.*    THE DATA SYMBOLIC CAN BE AN ORDINARY RX-TYPE DATA ITEM\n.*        OR A SUBLIST CONSISTING OG 2 ELEMENTS- THE FIRST-A REGISTER\n.*        CONTAINING THE ADDRESS OF A DATA ITEM AND THE SECOND BEING\n.*       THE DEFINED LENGTH (IN ABS DECIM OR REG NOTAT)OF THE DATA ITEM\n.*    THIS MACRO WILL GO TO A SUB PROGRAM TO MOVE MESSAGES TO AN\n.*    OUTPUT AREA AND PUTS A BRANCH ADDR IN R8(GOREG)\n         AIF  ('&MSGNUM'(1,1) NE 'R').DECNUM  IS REGISTER USED\n&LABEL   STC  &MSGNUM,BRLNKLST+7    YES-STORE MSGNUM IN LIST\n         AGO  .CHKEDIT\n.DECNUM  ANOP\n&LABEL   MVI  BRLNKLST+7,&MSGNUM  LOAD R1 WITH THE MESSAGE NUMBER\n.CHKEDIT AIF  ('&EDIT' EQ '').NOEDIT\n         LA   R1,&EDIT      LOAD ADDR OF FIELD TO BE EDITTED IN R1\n         ST   R1,BRLNKLST+8    STORE ADDR IN 3RD WORD OF LIST\n         AIF  ('&DATA' EQ '').NOEDIT\n.MNOTE   MNOTE 8,'BOTH EDIT AND DATA SYMBOLICS MAY NOT BE SPECIFIED'\n         AGO  .END\n.NOEDIT  AIF  ('&DATA' EQ '').NODATA\n         AIF  ('&DATA'(1,1) NE '(').NOTREG\n         AIF  ('&DATA'(K'&DATA,1) EQ ')').REG\n         MNOTE 8,'DATA PARAM ERROR: END PAREN MISSING;LENGTH NOT NUMER'\n         AGO  .MNOTE\n.REG     ANOP\n         ST   &DATA(1),BRLNKLST+8\n         AIF  ('&DATA(2)'(1,1) NE 'R').DECLEN\n         STC  &DATA(2),BRLNKLST+8        STORE LENGTH FROM REGISTER\n         AGO  .NODATA\n.DECLEN  MVI  BRLNKLST+8,&DATA(2)\n         AGO  .NODATA\n.NOTREG  ANOP\n         LA   R1,&DATA\n         ST   R1,BRLNKLST+8\n         MVI  BRLNKLST+8,L'&DATA  MOVE DATA LEN IN HIGH ORDER BYTE\n.NODATA  ANOP\n         BAL  GOREG,CALLSUB\n         AIF  ('&RETURN' EQ 'NO').NORETRN\n         MVI  PARMERR1,C'1'\n.NORETRN AIF  ('&BRANCH' EQ '').END\n         B    &BRANCH             GO TO THE ROUTINE THAT CALLS THE\n.END     MEND\n         SPACE 1\n         MACRO\n&LABEL   MESSAGE &MSGNUM,&EDIT=,&BRANCH=\n.*   ***************************************************\n.*   *THIS MACRO IS USED TO PRINT MESSAGES             *\n.*   *IT REQUIRES THE ERROR MESSAGE NUMBER AND THE     *\n.*   *RETURN ADDRESS.  IF NO RETURN ADDRESS IS GIVEN   *\n.*   *IT RETURNS TO THE INSTUCTION FOLLOWING THE PRINT *\n.*   **DATE MODIFIED ***7/28/80*************************\n&LABEL   L     R1,PRINTBUF\n         AIF   ('&EDIT' EQ '').NOEDIT\n         ED    MSG&MSGNUM.ED,&EDIT\n.NOEDIT  ANOP\n         MVC   0(MSG&MSGNUM.LEN,R1),MSG&MSGNUM\n         BAL   GOREG,PUTPRINT\n         AIF   ('&BRANCH' EQ '').END      IF &BRANCH KEYWORD NOT CODED\n         B     &BRANCH                      GO TO END OF MACRO\n.END     MEND\n         SPACE 1\n         MACRO\n&LABEL   CHCKTIOT &FOUND=,&NOTFND=TIOTERR\n&LABEL   BAL  GOREG,CALLTIOT    PERFORM FIND DDNAME ROUTINE\n*@MK1    BNE  &NOTFND        DDNAME NOT FOUND\n         BNZ  &NOTFND        DDNAME NOT FOUND  @MK1\n         AIF  ('&FOUND' EQ '').NOBRNCH\n         B    &FOUND        YES\n.NOBRNCH MEND\n         SPACE 1\n         MACRO\n&LABEL   CHECKOPT &SUBOPT,&FOUND=,&NOTFND=\n&LABEL   LA    R0,4          CHECK UP TO 3 SUBOPTIONS\n         LA    R1,WORKFLD+3 START FROM END OF OPTION FLD\n         CLI   0(R1),C'&SUBOPT' IS THIS THE SPECIFIED SUBOPTION\n         BE    *+14             GO TO SPACE OUT SUBOPTION (MVI)\n         BCTR  R1,0             REDUCE ADDRESS BY 1\n         BCT   R0,*-10          RETURN TO COMPARE (CLI)\n         B     &NOTFND          NOT FOUND\n         MVI   0(R1),BLANK1     SPACE OUT SUBOPTION\n         AIF  ('&FOUND' EQ '').NOBRNCH\n         B     &FOUND\n.NOBRNCH MEND\n         TITLE 'INIT BASE REGS,PRINT BUFFERS,HEADINGS,PARM FLD,TIOT'\n         PRINT NOGEN       DO NOT GENERATE MACRO EXPANSIONS\nKEYDUMP  START 0\n****************************************************************\n*   STORE THE CALLERS REGISTERS AND ESTABLISH R13,R10,R11 AND  *\n*   R12 AS BASE REGISTERS FOR THIS PROGRAM.                    *\n         EXTRN SYNADERR   PULL IN THE SYNADERR ROUTINE FROM HRA.LOADLIB\n         EXTRN MOVEMSG\n         ENTRY ABEND,SETRC ENTRY FOR SYNADERR RTN AFTER 5 BLOCKS & RC\n         ENTRY RETURN3  ENTRY FOR SYNAD AFTER 5 BLOCKS & RC (LIBFILE)\n         USING *,R15      USE R15 TEMPORARILY AS A BASE\n         STM   R14,R12,12(R13)      SAVE SYSTEM REGISTERS\n         ST    R13,SAVEAREA+4 STORE ADDR OF SYSTEM SAVE AREA IN SAVEARE\n         LR    R3,R13       LOAD R3 WITH ADDRESS OF SYSTEM SAVE AREA\n         LM    R10,R12,BASES   SET BASE REGISTERS R10,R11 & R12\n         CNOP  0,4        TO ALIGN THE BAL INSTR ON A FULLWORD\n         BAL   R13,JUMPSAVE    STORE THE ADDRESS OF SAVEAREA IN R13\nSAVEAREA DS    18F                   AND BRANCH TO JUMPSAVE\nBASES    DC    A(SAVEAREA+4096,SAVEAREA+8192,SAVEAREA+12288)\nJUMPSAVE ST    R13,8(R3)  STORE ADDR OF SAVEAREA IN SYSTEM SAVE AREA\n         USING SAVEAREA,R13,R10,R11,R12 REGS 13,10,11& 12 USED AS BASES\n         USING TIOENTRY,R4   MAKE TIOT DD ENTRY ADDRESSABLE\n         DROP  R15\n******************************************************************\n* LOAD R3 WITH THE ADDRESS OF THE DATA AREA (PARM) PASSED        *\n*  AND EDIT THE PARM VALUE                                       *\n******************************************************************\n         L     R3,0(0,R1) LOAD THE CONTENTS OF ADDR POINTED TO BY R1\n         USING PARMDS,R3   THIS IS THE DSECT OF THE PASSED (PARM) AREA\n         SPACE 2\n         SPIE  SPIEXIT,((1,7),9,11,12,15) ESTABLISH SPIE ENVIRONMENT\n         ST    R1,SAVESPIE      SAVE PREVIOUS ENVIRONMENT\n         ESTAE ESTAEXIT,CT,PARAM=ESTAPARM,PURGE=HALT,ASYNCH=NO\n         SPACE 1\n         L     GOREG,=A(CLRSCRN)   EXECUTE CLRSCRN VTAM CSECT\n         BALR  R14,GOREG         TO CLEAR THE SCREEN ON CLISTS\n         SPACE 1\n         TIME  DEC    REQUEST THE DATE IN R1\n         ST    R1,PARMEND  STORE THE DATE PACKED FORMATIN PARMEND\n         SPACE 2\n         L     R2,=A(EXITS)     GET DCB ADDR OF EXITS FILE\n         CHCKTIOT NOTFND=EXITOK\n         L     R15,=A(EXITSECT) CHECKS FOR ANY EXITS\n         BALR  R14,R15\n         LTR   R15,R15          ANY ERRORS ON EXITS CONTROL STATEMENTS\n         BZ    EXITOK           NO\n         MVI   XITERR+1,SETNOP YES-PUT OUT ERROR MSG AFTER OPEN SYSPRT\nEXITOK   EQU   *\n         TITLE 'OPEN PRINT FILE AND WRITE HEADING'\n         L     R2,ASYSPRNT      GET SYSPRINT DCB FOR TIOT CHECK\n         CHCKTIOT NOTFND=NOSYSPRT IS SYSPRINT IN JCL\nSYSPRINT L     R2,ASYSPRNT   GET SYSPRINT DCB AGAIN (FOR DEFLT R,1,1)\n         BAL   GOREG,OUTATTR  OPEN SYSPRINT\n*        EXTRACT WORKFLD1,'S',FIELDS=(TIOT)  GET THE ADDR OF THE TIOT\n*        L     R4,WORKFLD1\n         SR    R5,R5    GET PSA ADDR\n         USING PSA,R5\n         L     R5,PSATOLD   GET TCB ADDR\n         USING TCB,R5\n         L     R5,TCBTIO    GET TIOT ADDR\n         DROP  R5\n         LNKMSG 54,DATA=(R5,24)  PRINT JOBNAME/PROCSTEPNAME/STEPNAME\n*   START TO VERIFY THE PARM. IF PARM FLD IS NOT CODED PUT OUT ERR MSG\n         LA    R7,NUMBPARM+1  POINT TO 1 LESS THAN THE START OF PARM\n         LH    R5,NUMBPARM   LOAD REG 4 WITH THE NUMBER OF CHARACTERS\n         LTR   R5,R5         IS THE NO OF CHARS IN PARM = 0\n         BZ    DEFAULT  YES -USE DEFAULT PARM OF 'R,1,1'\nPRNTPARM LA    R1,DATAPARM     POINT TO DATA PORTION OF PARM FIELD\n         LNKMSG 0,DATA=(R1,R5)    PRINT PARM\n         BCTR  R5,0          SUBTRACT 1 FROM NO OF CHARS IN PARM\n         LA    R5,0(R5,R7)      LOAD ADDR OF THE END OF THE PARM FLD\n         ST    R5,PARMEND       STORE IN PARMEND\n         MVC   WORKFLD(5),1(R7) MOVE OPTION INTO WORKFLD\n*        ABOVE NEEDED FOR BACKWARD CHK ONLY (MOVED IN MOVEPARM)\n         SPACE 1\nXITERR   B     CONTPARM       SET TO NOP IF ERROR IN EXITS FILE\n         MVI   XMSGNOP+1,SETBR   PRINT ALL EXITS CONTROL STATEMENTS\n         L     R1,=A(EXITTBL)    PLACE ADDR OF BEGINNING OF MSGS IN R1\n         B     VMSGPT             GO DO IT\nXITERR2  MVI   XMSGNOP+1,SETNOP  RESET NOT TO COME BACK\n         LA    R1,8           PUT OUT ERROR MSG 8\n         B     LNKMSG1\nCONTPARM EQU   *\n         SPACE 2\n         CLI   WORKFLD,C'V'     IS V OPTION REQUESTED\n         BE    MOVEPARM         BYPASS FILE PROCESSING & DCB EXIT\n         MVI   EXLSTDCB,X'05'   ACTIVATE DCB EXIT (INACTIVE FOR V OPT)\n         DROP  R3   REGISTER 3 NOW FREE OF THE PARM FIELD\n         TITLE 'CHECK FOR CONVERT DD'\n         L     R2,ACONVERT          IS THERE A CONVERT DD IN THE JCL\n         CHCKTIOT NOTFND=NOCNVRT\n         BAL   GOREG,OPENINP  OPEN CONVERT FILE\n         MVI   CNVRTBR1+1,SETNOP SET NOP FOR CONVERT\n         MVI   CNVRTBR2+1,SETNOP\n         MVI   CNVRTBR3+1,SETNOP\n         MVI   CNVRTVB1+1,SETNOP\n         MVI   CNVRTVB2+1,SETNOP\n         MVI   CNVRTVB3+1,SETNOP\n         MVI   CNVRTBL1+1,SETNOP\n         MVI   CNVRTBL2+1,SETNOP\n         MVI   CNVRTBL3+1,SETNOP\n         MVI   CNVRTVL1+1,SETNOP\n         MVI   CNVRTVL2+1,SETNOP\n         MVI   CNVRTVL3+1,SETNOP\n         MVI   CNVRTNOP+1,SETNOP\n         MVI   DINVAL+1,SETBR   MAKE D OPTION INVALID\n         MVI   EKEY+1,SETBR   MAKE E OPTION INVALID\n         MVI   RKEY+1,SETBR   MAKE R OPTION INVALID\n         MVI   CHKAOPT+1,C'X'   MAKE A OPTION WITHOUT SYSIN INVALID\n*    SET B=,E=,J=,ETC IN CASE RANDOM OPTION REQUESTED\n         ZAP   END,=P'257'     FOR RANDOM GENERATE 256 RANDOM ENTRIES\n         ZAP   BEGIN,PACKZERO   IN RANGE OF 1-256\n         ZAP   COUNT,=P'256'\n         MVC   RANDMHDR+8(25),=C'    ENCRYPTION CODE TABLE'\n         MVI   RNDMNOP+1,SETBR  SET BR TO RETURN TO EOFCNVRT FROM RNDM\n         ST    R7,SAVEREGS     SAVE R7 PARM ADDR\n         LA    R9,INCARD MOVE INCARD ADDR TO R9 IN CASE RANDOM PROC\nCNVRTGET L     R1,ACONVERT  GET CONVERT DCB\n         GET   (R1)         GET RECORD\n         MVC   CNVRTCOD,0(R1)  MOVE FIRST 4 BYTES TO CNVRTCOD\n         MVC   INCARD,0(R1)    MOVE FIRST CONVERT RECORD TO INCARD\n         LNKMSG 87,DATA=INCARD   PRINT CONVERT KEY\n         CLC   INCARD(6),=C'RANDOM'   RANDOM REQUESTED?\nNOPAFTR1 BE    RNDMCNVT     YES - SET TO NOP AFTER 1ST RANDOM\n         MVI   LOOPCNVT+1,SETBR  SKIP SETTING TABLE WITH RANDOM NO.\n         MVI   NOPAFTR1+1,SETNOP DONT ALLOW RANDOM IF NOT 1ST KEY\n         SPACE 3\n         CLI   CNVRTCOD,C'@'     IS E OPT @ CHANGE REQUESTED\n         BE    SETECHG@          YES\n         CLI   CNVRTCOD,C'$'     IS E OPT $ CHANGE REQUESTED\n         BE    SETECHG$          YES\n         SPACE 3\n*        THE RECORD CONSISTS OF EITHER AN * FOLLOWED BY A FROM CHARACTR\n*        AND A 'TO' CHARACTER OR A 2-BYTE HEX 'FROM' CODE AND A 2-BYTE\n*        'TO' HEX CODE WHICH WILL BE PLACED IN A TRANSLATION TABLE\n         MVC   CRYPTWK+4(2),CNVRTCOD+1  IF 1ST BYTE=* PLACE CHAR CODES\n*        IN BYTES 4 AND 5 OF CRYPTWK WHICH HOLD THE 'FROM'/'TO' CODES\n         CLI   CNVRTCOD,C'*'   IS 1ST BYTE=*\n         BE    CHRCNVRT        YES- SKIP HEX TRANSLATION\n         L     R15,=A(HEXTAB1)  GET TABLE OF VALID HEX CODES\n         TRT   CNVRTCOD,0(R15)   SEE X= AND Y= ROUTINES FOR EXPLANATION\n         BNZ   HEXERR\n         L     R15,=A(HEXTAB2)         SEE PROCESS X= FOR EXPLANATION\n         TR    CNVRTCOD,0(R15)         __________________\n         PACK  CRYPTWK(3),CNVRTCOD(4)  | 0| 1| 2| 3| 4| 5| -OFFSETS IN\n         MVC   CRYPTWK+5(1),CRYPTWK+2  |__|__|__|__|__|__|  CRYPTWK\n         MVO   CRYPTWK+3(3),CRYPTWK(2)   P A C K|HEX REPRE\nCHRCNVRT SR    R2,R2           ZERO OUT R2\n         IC    R2,CRYPTWK+4    PLACE 'FROM' HEX CODE IN R2\n         IC    R5,CRYPTWK+5    PLACE 'TO' HEX CODE IN R5\n         L     R15,=A(CNVRTABL)  GET CONVERT TABLE\n         STC   R5,0(R2,R15) REPLACE 'FROM' CODE WITH 'TO' CODE IN TABL\n         B     CNVRTGET     GET NEXT RECORD\n         SPACE 2\nEOFCNVRT XC    INCARD,INCARD     REZERO INCARD\n         ZAP   COUNT,=P'999999999999999'  RESET\n         ZAP   END,=P'999999999999999'\n         L     R7,SAVEREGS     RESTORE\n         L     R5,=A(CNVRTABL)\n         L     R1,TABLE\n         LA    R2,1020    POINT TO LAST ELEMENT IN RANDOM TABLE\nLOOPCNVT NOP   NOCNVRT   SET TO B IF RANDOM NOT SELECTED\n         L     R9,0(R2,R1)   GET RANDOM ELT\n         STC   R9,0(0,R5)    STORE IN CONVERT TABLE\n         LA    R5,1(R5)   POINT TO NEXT ENTRY IN CONVERT TABLE\n         S     R2,FULL4   POINT TO NEXT ENTRY IN RANDOM TABLE\n         BNM   LOOPCNVT   LOOP TILL DONE\n         MVI   LOOPCNVT+1,SETBR  IF THERE ARE MORE RECORDS IN CONVERT\n         MVI   NOPAFTR1+1,SETNOP AFTER RANDOM= SET NOP AND BR TO\n         B     CNVRTGET      PROCESS REST OF RECORDS AND BRANCH TO GET\n         SPACE 3\nSETECHG@ MVI   E@CHGBR+1,SETBR SET B TO OUTPUT ALL RECS TO SYSUT2\n         MVI   BRPTOUT2+1,SETNOP SET NOP AS IF PROCESSING SYSUT3\n*        WHETHER SELECTED OR NOT (CHG FLDS ARE CHANGED)\n*        WHETHER B= IS CODED     (CHG FLDS ARE NOT CHANGED)\n         MVI   E@EQUBR+1,SETBR   CONTINUE PROCESSING AFTER E=\n         SPACE 1\nSETECHG$ CLI   WORKFLD,C'E'  IS E OPT REQUESTED\n         BNE   KEYINVAL      NO- ERROR\n         MVI   EKEY+1,SETNOP   YES - RESET E KEY VALIDATION\n         MVI   ECHGMSG+1,SETNOP NOP TO PUT OUT CNT OF KEY CHANGES\n         MVC   ECHGKEY+20(19),INCARD+1  SAVE CHG KEY(MINUS $)\n         B     EOFCNVRT\n         TITLE 'CHECK IF VS,IS && OPEN BACKWARDS ON W OPTION REQUESTED'\nNOCNVRT  L     R2,=A(ACBVSK)      GET VSAMKEY ACB (FOR DDNAME)\n         CHCKTIOT NOTFND=NVSAMKEY IS IT A VSAMKSDS/RRDS\n         MVI   TKEY+1,SETBR        DISALLOW E,G,P,T OPTIONS\n         MVI   OKEY1+1,SETBR                B,C,O\n         MVI   RKEY+1,SETBR                 R\n         MVI   VSAMFLAG,C'1'                N SUBOPTION\n         MVI   VSAMGET+1,SETNOP   SET NOP TO MODIFY THE RPL WITH KEYLEN\n         MVI   VSKEYNOP+1,SETNOP SET NOP TO CHK IF POINT HAS POSITIONED\n*                                BACKWARD AFTER A SEQUENTIAL READ\n         MVI   NOPBEQU+1,SETNOP SET NOP TO TO IGNORE B= PARAMATER\n         B     VSCOMMON             BRANCH TO COMMON VSAM CODE\n         SPACE 1\nNVSAMKEY L     R2,=A(ACBVSF) NOT VSAM KSDS/RRDS-GET VSAMFIL ACB(FOR DD)\n         CHCKTIOT NOTFND=NOTVSAM  IS THIS A VSAM ESDS\n         MVI   VSAMFLAG,C'0'        SET FLAG TO 0 FOR VSAMFILE\nVSCOMMON L     R15,=A(VSAMSECT)     BRANCH TO VSAM CSECT\n         BALR  R14,R15\n         ST    R5,DCBADDR           LOAD RPL ADDR FOR VSAM GET MACRO\n         MVI   CHKDCB+1,SETBR       DEACTIVATE THE DCB CHECKING\n         MVI   BR2VSGET+1,SETBR     SET BRANCH FOR VSAM GET MACRO\n         MVI   DINVAL+1,SETBR     SET BRANCH TO SKIP D OPTION\n         MVI   MSG40ORG,C'V'    MOVE VS TO DSORG MSG\n         MVI   MSG40FVU,C'V'    MOVE V TO RECFM\n         MVI   OPTCDU+1,SETBR   DONT DO DCB CHECKING ON OUTPUT FILES\n         B     CHKBACKW             BRANCH TO OPEN INSTRUCTION\nNOTVSAM  L     R2,AISAM      LOAD ADDR OF ISAM DCB IN R2\n         ST    R2,DCBADDR    AND SAVE IT IN DCBADDR\n         CHCKTIOT FOUND=CHKBACKW,NOTFND=NOTISAM\nNOTISAM  L     R2,ALIBRARY\n         ST    R2,DCBADDR\n         CHCKTIOT NOTFND=NOTLIBF\n         MVI   GETLIB+1,SETNOP\n         MVI   DINVAL+1,SETBR     SET BRANCH TO SKIP D OPTION\n         L     R2,=A(MEMSYSIN)    GET MEMSYSIN DCB\n         CHCKTIOT NOTFND=CHKMEMNM\n         MVI   MEMFLAG,C'1'         SET FLAG FOR LIBCSECT\n         MVI   MEMBMSG+1,SETNOP     SET NOP TO WRITE MEMBER MSG\nCHKMEMNM L     R2,AMEMBNAM  CHECK IF MEMBNAME DD CODED\n         CHCKTIOT NOTFND=RESETDD\n         DEVTYPE DCBDDNM(R2),DVCTYPE\n         BAL   GOREG,OUTATTR    OPEN MEMBNAME\n         CLC   DVCTYPE(8),LOWVALUE  IS MEMBNAME DUMMY\n         BNE   MEMNODUM      NO\n         MVI   MEMBMSG+1,SETNOP PUT OUT MEMBER MSGS ONLY\n         B     RESETDD\nMEMNODUM NI    NOPFMEMB+1,X'0F' NOP TO OUTPUT MEMBNAME WHEN SYSUT2 WRIT\nRESETDD  L     R2,ALIBRARY          RESET FOR INPUT FILE MSG\n         B     CHKBACKW\nNOTLIBF  NOP   MOVEPARM     SET TO BRANCH WHEN NOINPUT IN X0 EXIT\n         L     R2,AINFIL    GET SYSUT1 DCB ADDR\n         ST    R2,DCBADDR\n         CHCKTIOT                  IS SYSUT1 DDNAME IN JCL\nCHKBACKW MVC   DDN,DCBDDNM(R2)     SET DDNAME FOR MSG 40\n         CHECKOPT W,NOTFND=FORWDOPN CHK IF W SUBOPT REQ\n         DEVTYPE DCBDDNM(R2),DVCTYPE  CHECK TO INSURE INPUT ON TAPE\n         CLI   DVCTYPE+2,X'80'   IS DEVICE MAGNETIC TAPE\n         BE    BACKOPEN          YES-OK TO OPEN BACKWARDS\n         CLI   VSAMFLAG,C'0'  NO-IS VSAMFILE DDNAME USED\n         BNE   BACKWERR          NO - ERROR\n         L     R5,DCBADDR        YES-OK-GET VSAMFILE RPL ADDR\n         MODCB RPL=(R5),OPTCD=(BWD,LRD)  MODIFY RPL TO READ BACKWARDS\n         MVI   VSMPOINT+1,SETNOP  SET NOP TO ISSUE POINT TO LAST RECORD\n         B     FORWDOPN\n         SPACE 2\nBACKOPEN OPEN  ((R2),RDBACK)    YES-OPEN SYSUT1 BACKWARDS\n         CLI   OPENERR,C'1'     HAVE ANY OPEN BOMBS BEEN RECOVERED\n         BE    ERROREOJ                 YES\n         MVI   OPENBACK,C'W'     SET FLAG TO INDICATE BACKWARD OPEN\n         B     CHKDCB\nBACKWERR LNKMSG 46,RETURN=YES  DEVICE IS NOT TAPE -PUT OUT ERROR MSG\n         SPACE 2\nFORWDOPN BAL   GOREG,OPENINP  OPEN PRIMARY FILE\n         TITLE 'INPUT(SYSUT1,ISAM,VSAM) ATTRIBUTES'\nCHKDCB   NOP   PUTMSG     DCB INFORMATION OF SYSUT1/ISAM. B ON VSAM\n         L     R3,DCBADDR   LOAD R3 WITH THE ADDRESS OF INFIL/ISAM\n         USING IHADCB,R3\nCHKDCB2  MVI   URECFMBR+1,SETNOP  RESET FOR RECFM=U SYSIN RECS\n         MVI   BRANCHV+1,SETNOP  RESET FOR RECFM=V SYSIN RECS\n         MVI   FILLREST,X'48'    RESET FOR SYSIN RECS\n         MVC   MSG40ORG(2),=C' S'     RESET FOR SYSIN FILE\n         MVC   MSG40FVU,MSGSPACE   RESET FOR SYSIN FILE\n         MVC   INRECFM,DCBRECFM  SAVE THE INPUT RECFM IN INRECFM\n         MVC   INRECFM2,DCBRECFM SAVE THE INPUT RECFM IN INRECFM2\n         TM    DCBRECFM,X'10'    IS DATA SET BLOCKED\n         BNO   NOTBLK             NO\n         MVI   MSG40FVU+1,C'B'    YES\nNOTBLK   TM    DCBRECFM,X'08'    ARE RECORDS STANDARD(F) OR SPANNED(V)\n         BNO   RECFMNS            NO\n         CLI   MSG40FVU+1,C'B'    YES-ARE RECORDS BLOCKED\n         BE    SRECFM             YES\n         MVI   MSG40FVU+1,C'S'    NO-MOVE IN S TO RECFM\n         B     RECFMNS\nSRECFM   MVI   MSG40FVU+2,C'S'\nRECFMNS  TM    DCBRECFM,X'C0'    IS RECFM=U\n         BNO   VORFREC           NO -IT IS EITHER V OR F\n         MVI   MSG40FVU,C'U'    MOVE U TO RECORD TYPE FOR PRINTING\n         MVI   URECFMBR+1,SETBNE SET BNE IF LRECL NOT = BLKSIZE\n         LH    R4,DCBBLKSI      SET LRECL TO BLKSIZE\n         MVI   FILLREST,X'49'   SET NOP (CH INSTR) WHEN LOADING LRECL\n         MVI   COMPRDW+1,SETNOP SET NOP ON U RECS FOR AL,ML\n*        ABVE WILL WORK FOR SYSUT1/SYSIN WITH ANY COMBINATION OF RECFM\n*        EXCEPT FOR V AND U.\n         B     NOPV              GO TO LRECL & BLKSIZE PROCESSING\n*        BUT FIRST SET L SUBOPTION NOPS AND BRANCHES\nVORFREC  TM    DCBRECFM,RECFMF   IS RECFM=F\n         BNO   VREC              NO -IT IS V\n         MVI   MSG40FVU,C'F'    MOVE F TO RECORD TYPE FOR PRINTING\n         B     FILLREST\nVREC     TM    DCBRECFM,X'40'    IS RECFM=V\n         BNO   RECFMERR          THERE IS AN ERROR IN THE RECFM\n         MVI   MSG40FVU,C'V'    MOVE V TO RECORD TYPE FOR PRINTING\n         MVI   BRANCHV+1,SETBR  BYPASS INTEGRAL MULTIPLE BLKSIZE TEST\nNOPV     MVI   SYSUTVAR+1,SETBR SET BR ON V RECS FOR AL,ML SYSUT PROC\n         MVI   NOPV,X'95'   CHANGE ABOVE INSTRUCTION TO CLI I.E. NOP IT\n*        THE MVI IS NOPED SO AS NOT TO SET BRANCH IF ONLY SYSIN IS V\n         MVI   COMPLKEY+1,SETBR  ALLOW ONLY 1 L,P ON AL,ML OPTIONS\n*\nFILLREST LH    R4,DCBLRECL  PUT INPUT LRECL IN R4;SET TO CH ON RECFM=U\n         ST    R4,MAXLEN         SAVE THE INPUT LRECL IN MAXLEN\n         CVD   R4,INLRECL    CONVERT THE LRECL TO DECIMAL FOR PRINTING\n         MVC   MSG40REC,MSG23ED       RESET MASK\n         ED    MSG40REC,INLRECL+5  EDIT THE LRECL\n         LH    R4,DCBBLKSI       LOAD THE INPUT BLKSIZE INTO R4\n         ST    R4,MAXBLK         SAVE THE BLKSIZE IN MAXBLK\n         CVD   R4,INBLKSIZ   CONVERT THE BLKSIZE TO DECIMAL FOR PRINT\n         MVC   MSG40BLK,MSG23ED          RESET MASK\n         ED    MSG40BLK,INBLKSIZ+5    EDIT THE BLKSIZE\n         RDJFCB ((R3))       READ THE JFCB FOR THIS INPUT FILE\n         MVC   MSG40VOL,JFCBVOLS     MOVE VOLSER TO MESSAGE\n         MVC   MSG40DSN,JFCBDSNM      MOVE THE DSN TO MSG\n         MVI   MSG40ORG,C'V'              VS (FOR ISAM-VSAM INTERFACE)\n         TM    JFCDSRG2,JFCORGAM      IS DSORG=VS\n         BO    PUTMSG                      YES\n         MVI   MSG40ORG,C'I'              IS\n         TM    JFCDSORG,JFCORGIS      IS DSORG=IS\n         BO    PUTMSG                      YES\n         MVI   MSG40ORG,C'P'              PS\n         TM    JFCDSORG,JFCORGPS      IS DSORG=PS\n         BO    PUTMSG                      YES\n         MVC   MSG40ORG(2),=C'PO'\n         TM    JFCDSORG,JFCORGPO      IS DSORG=PO\n         BO    PUTMSG                      YES\n         MVC   MSG40ORG(2),=C'DA'     DSORG=DA\nPUTMSG   MVC   MSG40+9(8),DDN     MOVE DDNAME TO MSG\n         MESSAGE 40                   PRINT DCB MESSAGE\nSYSINDCB NOP   VRETURN       CHANGED TO B ON WHEN V= REQUESTED\n         L     R2,AOUTFIL       GET SYSUT2 DCB FOR CHCKTIOT & OPEN\n         CHCKTIOT NOTFND=NOSYSUT2\n         BAL   GOREG,OUTATTR OPEN & PUT SYSUT2 ATTRIBUTE MESSAGE\n         B     MOVEPARM\n         SPACE 2\nNOSYSUT2 CLI   GETLIB+1,SETNOP  WAS THE INPUT LIBFILE\n         BNE   NOLIBFIL     NO-CHK IF VSAMOUT CODED\n         L     R2,ALIBOUT           YES- IS LIBOUT PDS REQUESTED\n         CHCKTIOT NOTFND=BYPSYST2\n         MVI   MSG85+26,C'O'   CHANGE MSG85 DSORG TO PO\n         BAL   GOREG,OUTATTR     OPEN & PUT OUT ATTRIB MSG\n         MVI   MSG85+26,C'S'   RESET MSG85 DSORG TO PS\n         MVC   LIBOTBAL(2),SETBAL   SET UP BAL TO WRITE LIBOUT\n         MVI   EOJ+1,SETNOP ISSUE LIBOUT MSG AT EOJ\nCOMONSET MVI   SKIPPUT2+1,SETBR  BYPASS REGULAR WRITE OF SYSUT2\n         MVI   SYSOUTER+1,SETBR  DISALLOW SYSOUT ON LIBOUT\n         B     MOVEPARM\n         SPACE 1\nNOLIBFIL L     R2,=A(ACBVSOUT)   YES- IS VSAMOUT REQUESTED (GET ACB)\n         CHCKTIOT NOTFND=BYPSYST2  ALLOWED ON ANY OPT\n*                    AS LONG AS FILE IS SORTED ON PREDEFINED VSAM KEY\n         MVC   MSG40REC,MSG23ED     RESET EDIT MASKS\n         MVC   MSG40BLK,MSG23ED     RESET EDIT MASKS\n         MVC   MSG40+9(8),ACBDDNM(R2) MVE IN VSAMOUT R2=A(ACB)\n         L     R15,=A(VSAMSECT)  SETUP MSG40 AND THE ACB AND RPL\n         BALR  R14,R15\n         ST    R5,VSOUTRPL      SAVE VSAMOUT RPL ADDR\n         MVC   MSG85+8(MSG85LEN-8),MSG40+8   SET OUTPUT MSG85\n         MESSAGE 85\n         MVC   VSOUTBAL(2),SETBAL   SET UP BAL TO WRITE VSAMOUT\n         MVI   VSMOVREC+1,SETBR DONT MOVE INPUT VSAM RECS TO V WKAREA\n         CLI   VSAMFLAG,C' '    WAS INPUT VSAM?\n         BE    COMONSET         NO\n         MVI   SYST3NOP,X'95'  YES-BOTH IN & OUTPUT VSAM- NO SYST3\n*        MVI INSTRUCTION CHANGED TO CLI (TO PROHIBIT CREATION OF SYST3)\n         B     COMONSET    BYPASS WRITE OF SYSUT2,DISALLOW SYSOUT\n         SPACE 1\nBYPSYST2 MVI   PUTFILE+1,SETBR        BYPASS WRITING THE OUTPUT REC\n         B     MOVEPARM\n         TITLE 'DCB OPEN EXLST ROUTINE'\n*       RULES FOR DCB CHECKING- IF THE OUTPUT RECORD TYPE DOESN'T MATCH\n*       THE INPUT RECORD TYPE THEN THE OUTPUT RECFM,LRECL & BLKSIZE ARE\n*       ALL COPIED FROM THE INPUT. LIKEWISE, IF THE INPUT LRECL DOESN'T\n*       MATCH THE OUTPUT LRECL. IF THE RECORD TYPE & LRECL ARE OK THE\n*       BLKSIZE IS CHECKED FOR COMPATIBILITY (SEE MSG43 & MSG44).\n*\n*   SAVEAREA IS BEING USED AS THE THE SAVE AREA BY THE SYSTEM SINCE R13\n*   CONTAINS THE ADDRESS OF SAVEAREA.\n*      REGISTERS:\n*        R4 -ON ENTRY R4 MUST POINT TO THE TIOT (TO GET DDNAME) -\n*            THIS IS ALWAYS THE CASE SINCE THE DCB OPEN EXIT, WHICH IS\n*            INVOKED FOR OUTPUT FILES AT OPEN TIME, ALWAYS FOLLOWS\n*            THE CHKTIOT MACRO WHEN THE OUTPUT FILE IS OPENED\n*        R14 IS SAVED IN SAVEREGS, GOREG IS SAVED IN WORKFLD1\nEXLSTDCB DS    0F            BEGIN EXLST ON A FULLWORD BOUNDARY\n         DC    X'00'  DEFINE ENTRY AS DCB EXLST X'05' FOR NON V OPT\n         DC    AL3(DCBEXIT)\nJFCBXLST DC    X'87'         JFCB EXIT-LAST EXIT IN LIST\n         DC    AL3(INFMJFCB) ADDR OF JFCB MAPPING MACRO FOR OUTPUTS\nDCBEXIT  ST    R14,SAVEREGS      SAVE R14\n         ST    GOREG,WORKFLD1    SAVE GOREG,THIS EXIT INVOKED FROM\n*                     A BAL GOREG ROUTINE (OUTATTR)\n         LR    R3,R1             MOVE DCB ADDRESS TO R3\n*   NEXT INSTRUCTION REQUIRES THAT R4 POINT TO TIOT (FROM CHKTIOT)\n         MVC   DDN,TIOEDDNM     SAVE DDNAME FOR DCBBUFX CSECT\n         DEVTYPE TIOEDDNM,DVCTYPE  IS OUTPUT BLKSIZE IS LEGAL FOR DEV\n         CLC   DVCTYPE,=X'00000102'  IS THE OUTPUT A SYSOUT DATA SET\n         BE    SYSOUT            YES\n         TM    DCBOPTCD,X'40'   NO-WAS DCB=OPTCD=U CODED ON NON-SYSOUT\nDCBVAL   BO    RETURNU   YES - DO NOT DO DCB CHECKING (PRT ATTR)\n*  DCBVAL SET TO BRANCH WHEN NODCBVAL OPTION SET IN X0 EXIT\nOPTCDU   NOP   RETURN SET TO BR ON VSAMFILE/KEY WHEN OUTPUTING NON-VSAM\n*        FILES TO BYPASS CHKING OUTPUT ATTRIB AGAINST THE INPUT VSAM\n         MVC   OUTRECFM,DCBRECFM SAVE THE OUTPUT RECFM IN OUTRECFM\n         NI    INRECFM,X'C0'   'AND' THE INPUT RECFM WITH 11000000\n         NI    OUTRECFM,X'C0'   'AND' THE OUTPUT RECFM WITH 11000000\n         CLC   INRECFM,OUTRECFM  COMPARE INPUT & OUTPUT RECORD TYPES\n         BNE   CHANGE            THEY ARE NOT THE SAME\n         CLC   DCBLRECL,MAXLEN+2  COMPARE INPUT AND OUTPUT LRECL'S\n         BE    CHKBLK     CHANGED TO NOP WHEN RECORD TYPES DONT MATCH\nCHANGE   MVC   DCBLRECL,MAXLEN+2  MOVE INPUT LRECL TO OUTPUT LRECL\n         MVC   DCBRECFM,INRECFM2  MOVE INPUT RECFM TO OUTPUT RECFM\n         MVC   DCBBLKSI,MAXBLK+2  MOVE INPUT BLKSIZE TO OUTPUT BLKSIZE\n         LNKMSG 42,DATA=SYSUT,BRANCH=ENDDCB PRNT WARNING ON RECFM/LREC\nCHKBLK   LH    R5,DCBBLKSI    LOAD R5 WITH THE OUTPUT BLKSIZE\n         C     R5,MAXLEN    IS THE BLKSIZE = LRECL\nURECFMBR NOP   CHNGBLK      CHANGED TO BNE WHEN RECFM=U\n         SR    R4,R4        LOAD R4 WITH SIGNED ZEROS\n         D     R4,MAXLEN    DIVIDE THE BLKSIZE BY THE LRECL\n         LTR   R5,R5        IS BLKSIZE LESS THAN LRECL,R5=QUOTIENT\n         BZ    CHKVBS      YES-THE QUOTIENT R5=0-CHECK IF RECFM=VS,VBS\nBRANCHV  NOP   CHECKV       CHANGED TO BRANCH ON VARIABLE RECORDS\n         LTR   R4,R4        IS BLKSIZE AN INTEGRAL MULTIPLE OF LRECL\n         BNZ   CHNGBLK      NO-THE REMAINDER R4 DOESNT CONTAIN 0.\n         TM    DCBRECFM,X'10'  IS OUTPUT FILE BLOCKED\n         BO    ENDDCB          YES\n         C     R5,FULL1        NO- IS BLKSIZE = LRECL\n         BE    ENDDCB          YES\n         MVC   DCBBLKSI,MAXLEN+2  NO-MOVE LRECL TO BLKSIZE\n         MVC   MSG44BLK,=C'LRECL  '   CHANGE WARNING MSG\n         B     BLKSIMSG\nCHNGBLK  MVC   DCBBLKSI,MAXBLK+2  MOVE INPUT BLKSIZE TO OUTPUT BLKSIZE\nBLKSIMSG LNKMSG 43,DATA=SYSUT\n         LNKMSG 44,DATA=MSG44BLK     PRINT WARNING MSG ON BLKSIZE\nENDDCB   EQU   *\n         CLC   DVCTYPE(8),LOWVALUE  IS THE OUTPUT A DUMMY DATA SET\n         BE    RETURN               YES\n*        CLC   DVCTYPE+6(2),DCBBLKSI  NO-IS BLKSIZE TOO LARGE\n*        BL    BLKNG      BLKSIZE DOESNT EXCEED LEGAL MAX FOR DEVICE\n         CLC   DCBRECFM,INRECFM2      IS OUTPUT RECFM EXACTLY = INPUT\n         BNE   OKDCBCHG               NO\n         CLC   DCBBLKSI,MAXBLK+2      IS OUTPUT BLKSIZE EXACTLY=INPUT\n         BE    RETURN                 YES\nOKDCBCHG LNKMSG 39,DATA=SYSUT\n*\nRETURN   MVC   MSG85FVU(1),MSG40FVU  SKIP ON OPTCD=U (RECFM MAY CHANGE)\nRETURNU  MVC   MSG44BLK,=C'BLKSIZE'  RESTORE MESSAGE\n         LR    R1,R3             PASS DCB ADDRESS TO DCBBUFX CSECT\n         L     R15,=A(DCBBUFX)\n         BALR  R14,R15           DO BUFNO PERFORMANCE\n         L     GOREG,WORKFLD1    RESTORE GOREG\n         L     R14,SAVEREGS      RESTORE  R14\n         BR    R14                    RETURN TO OPEN MACRO\n         SPACE 3\nCHECKV   C     R5,FULL1    ON VARIABLE RECORDS,IS BLKSIZE = LRECL\n         BNE   ENDDCB      NO-BLKSIZE IS AT LEAST TWICE LRECL-OK\n         C     R4,FULL4    YES-IS BLKSIZE AT LEAST 4 BYTES GREATER\n         BL    CHNGBLK     NO-PUT OUT WARNING AND CHANGE BLKSIZE\n         B     ENDDCB      YES-BLKSIZE IS OK\n         SPACE 3\nCHKVBS   CLI   MSG40FVU,C'V'  IS RECFM=V\n         BNE   CHNGBLK        ERROR-LRECL IS GREATER THAN BLKSIZE\n         CLI   MSG40FVU+1,C'S'   IS RECFM=VS\n         BE    ENDDCB          OK- SPANNED RECORD\n         CLI   MSG40FVU+2,C'S'   IS RECFM=VBS\n         BE    ENDDCB           OK\n         B     CHNGBLK         ERROR\n         SPACE 3\nSYSOUT   EQU   *\n         TM    DCBOPTCD,X'40'   WAS DCB=OPTCD=U CODED ON SYSOUT\nEXITNOP3 BO    OPTCDU           YES - DO NOT DO SYSOUT FORMATTING\n*        ABOVE SET TO BR WHEN X0 EXIT SET FORMAT=NONE\n         NI    DCBRECFM,X'06'   ZERO OUT EVERYTHING EXCEPT RECFM=A,M\n         OI    DCBRECFM,X'90'   MOVE IN RECFM=FB\n         MVC   DCBLRECL,=H'133' MOVE 133 TO LRECL FOR PRINT LINE\n         MVC   DCBBLKSI,=H'5320'  MOVE 5320 TO BLKSIZE\n         CLI   SYSUT,C'2'         IS THIS SYSUT2\n         BNE   SYSOUT3                    NO\nSYSOUTER NOP   LIBERR2   SET TO BRANCH ON LIBOUT\n         MVI   SKIPPUT2+1,SETBR        YES-SET BRANCH AND BAL FOR PRINT\n         MVC   PRNT2BAL(2),SETBAL\n         B     RETURN                  RETURN\nSYSOUT3  CLI   SYSUT,C'3'\n         BNE   SYSOUT4\n         MVI   SKIPPUT3+1,SETBR\n         MVC   PRNT3BAL(2),SETBAL\n         B     RETURN\nSYSOUT4  CLI   SYSUT,C'4'\n         BNE   SYSOUT5\n         MVI   SKIPPUT4+1,SETBR\n         MVC   PRNT4BAL(2),SETBAL\n         B     RETURN\nSYSOUT5  EQU   *\n         MVI   SKIPPUT5+1,SETBR\n         MVC   PRNT5BAL(2),SETBAL\n         B     RETURN\n         SPACE 5\n*        ROUTINE TO GET DSN AND VOLSER FROM JFCB FOR OUTPUT FILES\n*        AND PUT OUT ATTRIBUTE MESSAGE AFTER OPENING THE FILE\nOUTATTR  MVC   MSG85+9(8),DCBDDNM(R2) SET DDNAME IN MSG 85\n         OPEN  ((R2),OUTPUT)  OPEN SYSUT2/3/4/5 OR LIBOUT (R2 HAS DCB)\n         CLI   WORKFLD,C'V'     IS THIS THE V OPTION\n         BER   GOREG            YES- BYPASS MSG85\n         LH    R1,LRECL(R2)     GET OUTPUT ATTRIBUTES\n         CVD   R1,INLRECL\n         MVC   MSG85REC,MSG23ED\n         ED    MSG85REC,INLRECL+5\n         LH    R1,BLKSIZE(R2)\n         CVD   R1,INBLKSIZ\n         MVC   MSG85BLK,MSG23ED\n         ED    MSG85BLK,INBLKSIZ+5\n         RDJFCB ((R2))                  READ JFCB\n         MVC   MSG85VOL,JFCBVOLS\n         MVC   MSG85DSN,JFCBDSNM\n         ST    GOREG,SAVEREGS       SAVE R8\n         C     R2,ASYSPRNT     IS THIS THE SYSPRINT FILE\n         BNE   PUTMSG85        NO\n         BAL   GOREG,PUTPRINT  GET FIRST BUFFER AND SAVE ADDRESS IN R1\n         LNKMSG 74,EDIT=PARMEND+1 PRINT HEADING MSG\nPUTMSG85 MESSAGE 85             THE MESSAGE MACRO USES R8\n         L     GOREG,SAVEREGS       RESTORE R8\n         BR    GOREG    RETURN\n         SPACE 2\nOPENINP  OPEN  ((R2))   COMMON OPEN INPUT ROUTINE\n         CLI   OPENERR,C'1'     HAVE ANY OPEN BOMBS BEEN RECOVERED\n         BE    ERROREOJ                 YES\n         BR    GOREG\n         TITLE 'ABEND AND JFCB EXIT FOR INPUT FILES'\nINPTXLST DS    0F\n         DC    X'07'       JFCB EXIT TO GET ADDR OF JFCB MAPPING MACRO\n         DC    AL3(INFMJFCB)   ADDR OF JFCB MAPPING MACRO\n         DC    X'11'                  ABEND EXIT ON 'A' OPTION\n         DC    AL3(DCBABEND)   ADDR OF ABEND ROUTINE\n         DC    X'85' DCB OPEN EXIT (LAST IN LIST)-BUFNO PERFORMANCE\n         DC    AL3(DCBBUFX)   ADDR OF DCB OPEN EXIT TO ADJUST BUFNO\n         SPACE 1\nDCBABEND ST    R14,SAVEREGS\n         L     R5,0(0,R1)      LOAD PARAMETER LIST INTO R5\n         SRL   R5,20     SHIFT EVERYTHING BUT THE COMPLETION CODE OUT\n         CLI   2(R1),X'04'     IS THE RETURN CODE=4\n         BNE   S413BOMB        NO-IS IT A 413 BOMB\n         CLM   R5,3,=X'0513' IS IT S513 BOMB-SYSIN TAPE SAME AS SYSUT1\nAEXIT    NOP   FIXBOMB       YES-CHANGED TO BE ON 'A'\n         CLM   R5,3,=X'0813' IS THE DSN OR VOLSER SPECIFIED INCORRECTLY\n         BE    DSNBOMB\n         CLM   R5,3,=X'0213'  ON DISK-IS DSN OR VOLSER INCORRECT\n         BE    DSNBOMB\nS413BOMB CLM   R5,3,=X'0413'  HAS A PREVIOUS STEP IN A JOB BOMBED\n         BE    PREVBOMB          YES -NEXT INSTRUCTION MUST BE BOMBOUT\nBOMBOUT  MVI   3(R1),X'00'    NO-BOMB OUT IMMEDIATELY\nRETURN2  L     R14,SAVEREGS\n         BR    R14\n         SPACE 1\nFIXBOMB  MVI   3(R1),X'04'    IGNORE THE BOMB\nNOSYSIN  MVC   SAMETAPE(2),SETBAL   SET A BAL TO GETCARD AFTER GETINPUT\n         MVC   AGETCRD1(2),=X'4700' NOP THE BAL TO GETCARD SET BY 'A'\n         MVI   SKIPGET+1,SETBR      BRANCH AROUND THE READ OF 1ST SYSIN\n         MVI   MNPUTBR+1,SETBR\n         MVI   READCRD1+1,SETNOP SET NOP MOVE SYSUT1 REC TO SYSIN\n         MVI   ASAMETAP+1,SETBR  BYPASS SYSUT4 & SYSUT5 PROCESSING\n         MVI   A513NOP+1,SETNOP BYPASS SYSIN MESSAGE\n         MVI   MMSG+1,SETBR     SET BRANCH ON NORMAL A MSG\n         LNKMSG 72,BRANCH=RETURN2 IGNORE 513 MSG\n         SPACE 1\nDSNBOMB  MVI   3(R1),X'04' IGNORE THE BOMB  EXCEPT WHEN RC=ABEND,DUMP\n         LNKMSG 68\nSETCODE  MVI   OPENERR,C'1'     HAVE ANY OPEN BOMBS BEEN RECOVERED\n         B     RETURN2\n         SPACE 2\nPREVBOMB CLI   2(R1),X'18'     DID PREV STEP BOMB\n         BNE   BOMBOUT         NO\n         MVI   3(R1),X'04' YES-IGNORE BOMB\n         LNKMSG 75,BRANCH=SETCODE\n         TITLE 'SPIE EXIT, ESTAE RETRY EXIT AND CALL TIOT ROUTINE'\n*        AFTER THE SPIE EXIT CONTROL IS RETURNED HERE, WITH THE\n*        RETURN CODE IN R5. A MSG IS PUT OUT AND THEN AN ABEND OCCURS.\n*ABENDMSG LNKMSG 64          PUT 'PROGRAM BOMBED' MSG             @MK1\nABENDMSG EQU   *                                                  @MK1\n         L     R2,SAVESPIE    GET PREVIOUS SPIE ADDRESS\n         SPIE  MF=(E,(2))        CANCEL SPIE TO PREVENT INFINITE LOOPS\n         LNKMSG 64           PUT 'PROGRAM BOMBED' MSG             @MK1\nRCDUMP   ABEND (R5),DUMP,,SYSTEM   CAUSE A DUMP\n         SPACE 5\n*        THIS IS THE RETRY ROUTINE AFTER EXECUTION OF THE ESTAE EXIT\n*        THE REGISTER CONVENTIONS ARE:\n*          UPON ENTRY, IF AN SDWA WAS OBTAINED BY THE SYSTEM THEN THE\n*         BASE REGISTERS ARE RESTORED BY THE SETRP MACRO IN THE ESTAE\n*         EXIT ROUTINE. OTHERWISE IF THE SDWA IS NOT OBTAINED\n*        R0=12\n*        R1=ADDR OF THE PARAMETER LIST ESTABLISHED VIA ESTAE MACRO.\n*           THE LIST CONTAINS THE ADDR OF 'BASES' WHICH CONTAINS THE\n*           VALUES USED TO RESTORE R10-R12,\n*           THE ADDR OF SAVEAREA WHICH IS USED TO RESTORE R13\n*           AND THE COMPLETION CODE IN THE LAST WORD OF THE LIST\nRETRYADR L     R2,8(0,R1)     LOAD THE COMPLETION CODE INTO R2\n         L     R13,4(0,R1)       RELOAD R13\n         L     R1,0(0,R1)      GET ADDRESS OF 'BASES'\n         LM    R10,R12,0(R1)   RELOAD THE BASE REGISTERS R10-R12\n         SPACE 2\nBOMBMSG  LNKMSG 69          PRINT MESSAGES\n         LNKMSG 73\n         ESTAE 0        CANCEL ESTAE EXIT TO PREVENT INFINITE LOOPS\nRCABEND  ABEND  (R2),,,SYSTEM  ABEND WITHOUT A DUMP\n         SPACE 2\n*  ON ENTRY TO CHKTIOT MACRO R2 MUST CONTAIN THE DCB ADDR OF THE FILE\n*  BEING SEARCHED FOR.\nCALLTIOT SR    R5,R5   POINT TO THE PSA, PSA IN FIRST 4K OF CORE\n         USING PSA,R5\n         L     R5,PSATOLD    GET CURRENT TCB ADDRESS\n         USING TCB,R5\n         L     R5,TCBJSCB  GET JSCB ADDR\n         USING IEZJSCB,R5\n         L     R5,JSCDSABQ  GET THE QDB FOR THE DSAB\n         USING QDB,R5\n         L     R5,QDBFELMP   GET THE POINTER TO THE FIRST DSAB\n         USING DSAB,R5\nDSABLOOP L     R4,DSABTIOT   GET THE TIOT ENTRY POINTER\n         CLC   TIOEDDNM,DCBDDNM(R2) IS THIS ENTRY=DDNAME,R2= A(DCB)\n         BE    FOUND        YES\n         ICM   R5,15,DSABFCHN  CHAIN TO THE NEXT DSAB\n         BNZ   DSABLOOP         THERE ARE ADDITIONAL DSABS\n*@MK1    CLI   FULL1+3,0          SET CONDITION FOR NOT EQUAL (NOTFND)\n         LA    R15,4         RC - NOT FOUND                       @MK1\n*@MK1    BR    GOREG\n         B     TIOTRET            RETURN                          @MK1\n*FOUND    CLI   FULL1+3,1   SET BRNCH CONDITION FOR EQUAL (FOUND) @MK1\nFOUND    LA    R15,0        RC - FOUND                            @MK1\nTIOTRET  LTR   R15,R15      SET CONDCODE FOR BRANCH    @MK1\n         BR    GOREG              RETURN\n         TITLE 'VERIFY THE SYNTAX OF THE PARM FIELD'\nMOVEPARM EQU  *\n*   R1=REGISTER USED IN THE DATA MANAGEMENT MACRO INSTRUCTIONS(OPEN,\n*      CLOSE,GET,ETC.) AND FOR THE PRINTING OF ALL MESSAGES\n*   R2=THE FUNCTION BYTE WHICH IS RETURNED BY THE TRT FOR CLASS TESTS\n*   R3=COUNT OF THE NO OF PARAMETERS,R4=LENGTH OF THE KEYS,\n*   R5=NUMBER OF CHARACTERS PER PARM FIELD,R7=CONTAINS ADDR OF PARM FLD\n         LM   R2,R3,LOWVALUE  INITIALIZE R2 AND R3 TO ZEROS\nPRELOOP  SR   R5,R5           INITIALIZE R5 TO ZEROS\n         MVC   WORKFLD,MSGSPACE   SET WORKFLD TO SPACES\nPVERLOOP EQU   *    PARM VERIFICATION LOOP\n         C     R7,PARMEND      COMPARE R7 TO ADDRESS OF END OF PARM FLD\n         BH    VERPARM   COUNT OF CHARACTERS PROCESSED.\n         LA    R7,1(R7)  POINT TO THE DATA FIELD BEING TESTED\n         CLI   0(R7),C')'  ON 'V=' TEST FOR END OF PARAMETER\nCHKV     NOP   VERPARM     CHANGED TO BE ON V=\n         CLI   0(R7),C','  IS THERE A PARAMETER BREAK\n         BE    VERPARM1  YES VERIFY THE PARAMETER\n         IC    R9,0(0,R7)      MOVE THE PARM CHARACTER TO R9\n         STC   R9,WORKFLD(R5)  STORE THE PARM CHAR INTO WORKFLD\n         LA    R5,1(R5)   ADD 1 TO THE NUMBER OF CHARS IN THIS PARM\n         C     R5,FULL8   ARE THERE MORE THAN 8 CHAR. IN A PARM VALUE\n         BH    POSITNG    YES\n         B     PVERLOOP   NO\nVERPARM  MVI   ENDPARMS,C'1'  1 INDICATES THE LAST PARAMETER\nVERPARM1 LTR   R5,R5         IS THERE A COMMA AT THE END OF THE PARM\n         BZ    ERRPARM         OR 2 CONSECUTIVE COMMAS IN THE PARM\n         LA    R3,1(R3)  ADD 1 TO THE NUMBER OF PARAMETERS\n         LR    R9,R3  LOAD R9 WITH R3\n         SLL   R9,2   MULTIPLY THE PARAMETER COUNT BY 4\n         B     JUMPOFF-4(R9) GO TO PROCESS THE PARAMETER IN THE B LIST\nJUMPOFF  B     SELCODE   VERIFY THAT A VALID CODE EXISTS\n         MVI   LENGRET+1,SETBR   SET BRANCH FOR LENGTH VERIFICATION\n         B     POSVER            GO TO VERIFY THE POSITION PARM\n         MVI   LENGRET+1,SETBR\n         B     POSVER                  VERIFY THE POSITION\n         MVI   LENGRET+1,SETBR\n         B     POSVER     VERIFY THE POSITION\n         B     CNTERR2\n         TITLE 'END OF PARM PROCESSING-CHK IF 2,4 OR 6 L,P PAIRS REQU'\nINITNPM  EQU   *        WHEN THE END OF THE PARAMETER LIST IS SENSED\n*PARMERR TESTED TO SEE IF PROCESSING IS TO CONTINUE.\n         CLI   ENDPARMS,C'1'  IS IT THE END OF THE PARM FIELDS\n         BNE   PRELOOP    NO-BRANCH TO INITIALIZE FIELDS\n         LA    R3,1(R3)   ADD 1 TO R3 TO MAKE UP FOR COUNT MISSING\nVBRANCH  NOP   CHKVEQU    CHANGED TO BRANCH WHILE PROCESSING V=\nREXTEND  B     NPEQUAL    CHANGED TO NOP ON R,E AND V OPTIONS\n         C     R3,=F'2'      IS THERE ONLY 1 PARM-THE SELECTION OPTION\n         BNE   CHKNUMB           NO\nEOPTBR   NOP   INITNPM2     CHANGED TO BR ON E AND V OPTIONS\n         MVI   REXTBR+1,SETBR    YES-SET BRANCHES FOR R EXTENDED OPT\n         MVI   REXTLOG+1,SETBR\n         MVI   RMSG+1,SETBR      DO NOT WRITE THE REGULAR R MSG\n         B     MKEY           GO TO OPEN SYSIN\nNPEQUAL  B     CKEYNOP NOP IF P=,N=,C=P,N,Z, G OPT OR L SUBOPT W V RECS\n*                      NOP ALSO ON VP\n         C     R3,FULL4    IS THERE 1 L,P PAIR IN THE PARM FIELD\n         BE    CHKNUMB     YES\n         B     CNTERR2     BRANCH TO PUT OUT OUT ERROR MSG\nCKEYNOP  B     BKEYNOP     CHANGED TO NOP ON 'C' OPTION\n         C     R3,FULL8    ARE THERE 3 L,P PAIRS\n         BE    CHKNUMB     YES\n         B     CNTERR2     PUT OUT ERROR MSG\nBKEYNOP  B     CHKNUMB     NOOPED ON B,BB OPTIONS\n         C     R3,FULL6    ARE THERE EXACTLY 2 L,P PAIRS\n         BNE   CNTERR2     NO\n         TITLE 'VERIFY NO OF PARMS AND SET LENGTHS,BRANCHES AND NOPS'\nCHKNUMB  L     R4,POSLENS  YES-LOAD THE FIRST LENGTH INTO R4\n         STC   R4,SET1+1           R4=LEN1-1\n         STC   R4,SETTR1+1         R4=LEN1-1 FOR CONVERT\n         STC   R4,SETLTR1+1        R4=LEN1-1 FOR CONVERT, L SUBOPT\n         STC   R4,BLOGCLC1+1  SET LENGTH FOR FIRST 'O' KEYCOMPARE\n         STC   R4,OKEYMSG1+1  SET LENGTH FOR FIRST 'O' MSG PRINT\n*        STC   R4,MOVINCRD+1  SET LENGTH FOR FIRST SYSIN CARD\n*  ABOVE INSTRUCT COMMENTED OUT TO ALLOW CLASS= KEYWORD ON C, O OPT\n         C     R3,FULL4   COMPARE FOR EQUAL TO 4 PARAMETERS\n         BE    INITNPM2   YES\n*\n         MVI   BRL1+1,SETNOP  ALLOW 2 L,P'S ON AL,ML\n         MVI   BR1+1,SETNOP\n         MVI   BLOGCLC2+1,SETNOP       NOP THE BRANCH -AT LEAST 2 KEYS\n         MVI   BR2CARDS+1,SETNOP    READ 2ND SYSIN CARD ON 'O' LOGIC\n         MVI   ONLY2OR+1,SETNOP    BRANCH NOOPED TO PUT OUT MESSAGE\n         L     R5,POSLENS+12       LOAD P2 INTO R5\n         S     R5,POSLENS+4        R5=P2-P1\n         ST    R5,POSDISPS    STORE P2-P1 FOR AL,ML OPTIONS ON V RECS\n         L     R5,POSLENS+8   LOAD 2ND LENGTH INTO R5\n         STC   R5,BLOGCLC3+1  SET LENGTH FOR 2ND 'O' KEY CMP\n         STC   R5,OKEYMSG2+1  SET LENGTH FOR 2ND 'O' KEY PRT\n         STC   R5,BKEYMSG2+1  SET LENGTH FOR 2ND 'B' KEY PRT\n         STC   R5,SET2+1      MOVE THE SECOND LENGTH\n         STC   R5,SETTR2+1    MOVE THE SECOND LENGTH FOR CONVERT\n         STC   R5,SETLTR2+1   MOVE THE SECOND LENGTH FOR CONVERT, L OPT\n         STC   R5,MOVINCD2+1  SET THE LENGTH FOR 2ND SYSIN REC\n         LA    R4,1(R4)           ADD 1 TO THE TOTAL LENGTH\n         STC   R4,SET2+3               LEN2\n         STC   R4,BLOGCLC3+3   SETS THE INCREMENT FOR THE 2 OR COMPARE\n         AR    R4,R5             R4=LEN1+LEN2-1\n         C     R3,FULL6     ARE THERE 6 PARAMETERS\n         BE    INITNPM2  YES\n*\n         MVI   BRL2+1,SETNOP   ALLOW 3 L,P'S ON ML,AL\n         MVI   BR2+1,SETNOP\n         MVI   BLOGCLC4+1,SETNOP     NOOP THE BRANCH--3 KEYS\n         MVI   BR3CARDS+1,SETNOP     NOOP THE BRANCH--3 KEYS\n         MVI   ONLY3OR+1,SETNOP    BRANCH NOOPED TO PUT OUT MESSAGE\n         L     R5,POSLENS+20       LOAD P3 INTO R5\n         S     R5,POSLENS+12       R5=P3-P2\n         ST    R5,POSDISPS+4  STORE P2-P1 FOR AL,ML OPTIONS ON V RECS\n         L     R5,POSLENS+16  LOAD R5 WITH THE 3RD LENGTH\n         STC   R5,BLOGCLC5+1  SET LENGTH FOR 3RD 'O' KEY CMP\n         STC   R5,OKEYMSG3+1  SET LENGTH FOR 3RD 'O' KEY PRT\n         STC   R5,SET3+1      MV IN 3RD LENGTH\n         STC   R5,SETTR3+1    MV IN 3RD LENGTH FOR CONVERT\n         STC   R5,SETLTR3+1   MV IN 3RD LENGTH FOR CONVERT,L OPT\n         STC   R5,MOVINCD3+1  SET THE LENGTH FOR 3ND SYSIN REC\n         LA    R4,1(R4)\n         STC   R4,SET3+3               LEN1+LEN2\n         STC   R4,BLOGCLC5+3  SET THE INCREMENT FOR THE 3RD OR COMPARE\n         AR    R4,R5              R4 NOW LEN1 + LEN2 + LEN3 - 1\n         C     R3,FULL8     ARE THERE 8 PARAMETERS\n         BNE   CNTERR2       NO  IF YES FALL THRU\n         TITLE 'SET LENGTHS AND DISPLACEMENTS FOR COMPARES,PRINT,ETC.'\nINITNPM2 NOP   SETYEQU  CHANGED TO BRANCH ON O,B,C,E,R KEYS & L SUBOPT\n         STC   R4,COMPSKEY+1  SET KEY LENGTH FOR COMPARE(S,M,D OPTION)\n         STC   R4,COMPFKEY+1  SET KEY LENGTH FOR COMPARE(F,Q OPTION)\n         STC   R4,GBUILD+1 SET KEY LENGTH TO MOVE KEY TO TABLE (T,G,P)\n         STC   R4,GNUM1+1  SET LEN TO CHK IF LOWER SYSIN IS NUMERIC (G)\n         STC   R4,GNUM2+1  SET LEN TO CHK IF UPPER SYSIN IS NUMERIC (G)\n         STC   R4,GCOMPR+1 SET LENGTH TO COMPARE LOWER & UPPER SYSIN(G)\n         STC   R4,DKEYMSG+1      MOVE KEY LENGTH TO PRINT MSG (D)\nTLCLM    STCM  R4,1,KEYREPT1+1   MOVE KEY LENGTH TO PRT MSG (S,M)\n*        ABOVE STCM CHANGED TO CLM FOR TL OPTION\n         STC   R4,CURRKEY+1      MOVE KEY LENGTH TO PRINT MSG (Q)\n         STC   R4,PREVKEY+1      MOVE KEY LENGTH TO PRINT MSG (Q)\n         STC   R4,TKEYMSG+1      MOVE KEY LENGTH TO PRINT MSG (T)\n         STC   R4,PLOWVALU+1  SET LENGTH FOR UPPER KEY COMPARE  (P)\n         STC   R4,LKYNOTLV+1  SET LENGTH FOR LOWER KEY PRINT    (P)\n         STC   R4,UKYNOTHV+1  SET LENGTH FOR UPPER KEY PRINT    (P)\n         STC   R4,PLVMSG+1  SET LENG FOR LOW VALUE MSG          (P)\n         STC   R4,CHKUKY+1  SET LENG FOR UPPER KEY HIGH VAL MSG (P)\n         STC   R4,FMOVE+1     SET LENGTH TO MOVE KEY           (F)\n         STC   R4,FREQMOVE+1  SET LENGTH TO PRINT MSG        (F,J=0)\n         STC   R4,MOVECARD+1  SET LENGTH FOR SYSIN MOVE (SYSIN OPTIONS)\n*        THE FOLLOWING 2 INSTRUCTIONS ARE CHANGED TO STCM INSTRUCTIONS\n*        ON THE P AND THE G OPTIONS RESPECTIVELY\nSETPLEN  CLM   R4,1,MOVINCRD+1  SET THE LENG FOR MOVING IN P KEY  (P)\nSETGLEN  CLM   R4,1,MOVINCD2+1  SET THE LENG FOR MOVING IN G KEY  (G)\n         LA    R5,1(R4)       ADJUST R5 TO ACTUAL KEY LENGTH (ADD 1)\n         STC   R5,GBUILD2+3   SET DISPLACEMENT TO 0-OUT COUNT (T,G,P)\n         STC   R5,TKEYSEL+3   SET DISPLACEMENT TO PRINT MESSAGE (T,G)\n         STC   R5,PMSGED+3    SET DISPLACEMENT TO EDIT COUNT (P)\n         LA    R5,5(R4)       ADJUST R5 TO KEY LENGTH+COUNT LENGTH (P)\n         STC   R5,CHKUKY+3   SET DISPLACE TO CHK IF UPPER KEY=X'FF'(P)\n         STC   R5,UKYNOTHV+5 SET DISPLACEMENT TO MOVE IN UPPER KEY (P)\nSETYEQU  EQU   *   SET LENGTH FOR Y= PROC & SAVE LENG FOR L SUBOPT ON V\n         STC   R4,YTRNSLT1+1   SET LENGTH OF KEY FOR Y= EQUATE SYMBOL\n         STC   R4,YTRNSLT2+1   OPTION FOR ALL OPTIONS EXCEPT E & R.\n         ST    R4,SAVER4    SAVE R4 FOR V RECS IN AL,ML PROCESSING\n         ST    R4,SAVEVARL SAVE LENGTH FOR SYSIN FILE ON V RECS \"\n         LA    R0,1(R4)\n         ST    R0,VSAMKEYL  FULLWORD STORAGE FOR VSAMKEY GENERIC KEYL\nLKEY     B     PARMGOOD      SET TO NOP ON L SUBOPTION\n         ST    R0,LENGLIST   STORE LENGTH INTO GETMAIN LIST\n         STCM  R0,7,LENGLIST+5  STORE LENGTH-DONT TOUCH HIGH ORDER BYTE\n         GETMAIN LU,LA=LENGLIST,A=LKEYARE1  GET 2 AREAS OF EQUAL LENGTH\n         TITLE 'MISCELLANEOUS'\nPARMGOOD CLI   PARMERR1,C'1'   IS THERE AND ERROR IN ANY PARM FIELD\n         BE    ERROREOJ          YES\n         CLI   SYSINDCB+1,SETNOP NO-WAS THE V= OPTION REQUESTED\n         BE    AOPTION           NO\n         CLM   R4,3,VLENGTH      YES-ARE THE KEY LENGTHS THE SAME\nNOPONVP  BNE   MTCHERR4          NO - NOP ON VP= LENGTHS NEED NOT EQUAL\n         B     CONTINPR          YES\n         SPACE 2\nERROREOJ MVI   SETRC+3,X'08' PLACE RETURN CODE= 8 = ERR IN R15\n         B     EOJ  GO TO EOJ & CLOSE THE FILES\n         SPACE 2\nAOPTION  CLI   MATCHFIL,C'A'   IS 'A' OPTION REQUESTED\n         BNE   CONTINPR        NO-CONTINUE NORMALLY\n         B     MTCHERR1       YES-ERROR NO V= SUBOPTION REQUESTED ON A\n         TITLE 'XB(SYSUT3 PROCESSING) AND XN(NEGATIVE) SELCT SUBOPTION'\nSELCODE  NOP   KEYWRDBE  VERIFY SELECT CODE,CHANGED TO B ON Y=,B=,E=,J=\n         CHECKOPT W,NOTFND=BLANKW  ERASE W SUBOPTION\nBLANKW   L     R2,AOUTFIL2     GET SYSUT3 DCB FOR CHCKTIOT & OPEN\n         CHCKTIOT NOTFND=NEGATKEY\n         MVI   SYSUT,C'3'       CHANGE TO SYSUT3\n         BAL   GOREG,OUTATTR    OPEN & PUT OUT SYSUT3 ATTRIBUTES\n         LA    R3,1             RESET R3 FOR PARM\n         MVI   CLS2NOP+1,SETNOP\nSYST3NOP MVI   BRPTOUT2+1,SETNOP CHANGED TO CLI WHEN VSAMXXX CODED\n*        AS THE PRIMARY INPUT AND PRIMARY OUTPUT FILES\n         SPACE 2\nNEGATKEY CHECKOPT N,NOTFND=LONGKEY CHK IF N SUBOPT REQU\n         CLI   VSAMFLAG,C'1'    IS VSAMKEY DD BEING USED\n         BE    KEYINVAL           YES-ERROR\n         CLI   WORKFLD,C'M'    IS THIS THE M OPTION\n         BE    MNKEY              YES\n         CLI   WORKFLD,C'B'\n         BE    BNKEY\n         CLI   WORKFLD,C'C'\n         BE    CNKEY\n         CLI   WORKFLD,C'A'\n         BE    ANKEY\n         MVI   RNEGAT+1,SETBR  SET BRNCH TO SKIP EVERY NTH RECORD  (R)\n         MVI   ONKEYEQ1+1,SETBE  SET BR ON = CONDITION TO GETINPUT (O)\n         MVI   ONKEYEQ2+1,SETBE                                    (O)\n         MVI   ONKEYEQ3+1,SETBE                                    (O)\n         MVI   ONSELECT+1,SETBR   SET BR TO WRITE RECS ON 'ON' KEY (O)\n         MVI   TLOGNEQ+1,SETBE  SET BR WHEN KEYS ARE =       (E,G,T,P)\n         MVI   TLOGNEQ1+1,SETBL  SET BL WHEN 'COUNT' REACHED (E,G,T,P)\n         MVC   MSG29OUT(25),MSGSPACE  BLANK OUT COUNT MESSAGE      (P)\n         MVC   MSG21KEY+21(37),MSG21KEY+20  BLANK CNT PRINT  (E,O,G,T)\n         MVC   MSGMASK+1(9),MSGSPACE KILL THE EDIT MASK    (E,O,G,T,P)\n         MVI   DKEY+1,SETBNE SET BNE TO GET NEW REC                (D)\n*        MVI   DKEYGT+1,X'D0'   SET BNH                            (D)\n*        MVI   DKEYLT+1,X'B0'  SET BNL                             (D)\n         MVI   QKEY+1,SETBH SET BH TO CHK SEQU FOR DESCENDING ORDER(Q)\n         MVC   INCARD,HIGHV     INIT INCARD TO X'FF' FOR DESC ORDER(Q)\n         MVI   QNLBL+1,X'02'    CHANGE CONDITION CODE TO 'BL'     (QL)\n         MVI   SETQBNE+1,X'02'  CHG COND CODE TO 'BL' FOR RECFM=V (QL)\n         MVI   FNINVAL+1,SETBR  DISALLOW N SUBOPTION ON F KEY      (F)\n         MVI   KNINVAL+1,SETBR  DISALLOW N SUBOPTION ON K KEY      (K)\n         MVI   KEYGT+1,X'D0'    SET BNH                          (S,V)\n         MVI   KEYLT+1,X'B0'    SET BNL                          (S,V)\nANKEY    MVI   BR6+1,SETBNE                                      (A,S)\n         TITLE 'SET LONG SUBOPTION DEFAULTS'\nLONGKEY  CHECKOPT L,NOTFND=VEROPT  CHK IF L SUBOPT\n         MVI   LSKIP1+1,SETBR   SKIP CHECK OF L<20,L+P<4096\n         MVI   NOPONL+1,SETNOP  NOP CHECK FOR L<20\n         MVI   YLOGIC+1,SETBR   DISALLOW Y= PARM\n         MVI   COMPKEY+1,SETBR  SET B FOR PROCEESING LONG COMPARE\n         MVI   FLOGIC1+1,SETBR\n         MVI   QBRONL+1,SETBR   SKIP MESSAGES ON Q\n         MVI   INITNPM2+1,SETBR SKIP SETTING LENGTH FOR COMPARE AND PRT\n         MVI   ELOGIC+1,SETBR   BYPASS SETTING KEYS USING L,P PAIR\n         MVI   LSET2BR+1,SETBR  BYPASS SETTING KEYS ON V=\n*        MVI   TKEY+1,SETBR  INVALIDATE L SUBOPTION ON T,G,E,P OPTIONS\n*                            ALLOW UP TO 256 BYTE KEY ON T,P\n         MVI   TLBR+1,SETBR  SUPPRESS KEY PRINTING ON T,P\n         MVI   TLCLM,X'BD'   SUPPRESS KEY ON TOTAL LINE T,P\n         MVI   GKEY+1,SETBR             INVALIDATE  G\n         MVI   EKEY+1,SETBR             INVALIDATE  E\n*\n         MVI   OKEY1+1,SETBR               INVALIDATE  O,B,C\n         MVI   SKEY+1,SETBR                            S,D\n         MVI   RKEY+1,SETBR                            R\n         MVI   MMSG+1,SETNOP     ALLOW L SUBOPTION ON M OPTION\n         MVI   LNOPPRNT+1,SETNOP     BUT SUPPRESS KEY PRINTING\n         OI    SKIPPRNT+1,SETBR   PRINT ONLY TOTAL LINE\n         MVI   LKEY+1,SETNOP NOP TO DO GETMAIN FOR LKEY STORAGE FOR KEY\n         XC    NPEQUAL+1(1),SYSUTVAR+1  IF SYSUT1 IS RECFM=V ONLY 1 L,P\n         OC    V1LPPAIR+1(1),SYSUTVAR+1\n         SPACE 2\nVEROPT   SR    R2,R2\n         L     R15,=A(OPTIONS)\n         TRT   WORKFLD(1),0(R15) FIND THE REQUEST OPTION FROM TABLE\n         BZ    KEYINVAL\n         B     JUMPOPT-4(R2)         SET UP JUMP TABLE\nJUMPOPT  B     AKEY\n         B     BKEY\n         B     CKEY\n         B     DINVAL\n         B     EKEY\n         B     FNINVAL\n         B     GKEY\n         B     KNINVAL\n         B     MKEY0\n         B     OKEY\n         B     PKEY\n         B     QKEY\n         B     RKEY\n         B     SKEY\n         B     TKEY0\n         B     VKEY\n         TITLE 'VERIFY THE SELECTION TYPE CODE'\nMKEY0    MVI   MATCHFIL,C'M'     SET FLAG IN CASE V= OPTION REQUESTED\nLNOPPRNT MVI   KEYOK+1,SETBR ON M ONLY KEEP BR ON ENDINF,NOP ON L SUBOP\nMKEY     L     R2,ASYSIN         GET SYSIN DCB FOR CHCKTIOT AND OPEN\n         MVC   DDN,DCBDDNM(R2)      SAVE DDNAME FOR MSG 40\n         CHCKTIOT NOTFND=CHKAOPT\n         BAL   GOREG,OPENINP    OPEN SYSIN FILE\nNOSYSINA MVI   BR5+1,SETNOP SET BRANCH TO NOP--READ ADDIT. KEYS-\n         MVI   GETCARD+1,SETNOP\nREXTBR   NOP   PARMGOOD   SET TO BRANCH IF ONLY 1 PARM ON R OPTION\nKEYOK    MVI   ENDINF+1,SETNOP       NOP TO BLANK 'KEY=' MSG\n         CLC   WORKFLD+1(5),MSGSPACE\n         BNE   KEYINVAL\n         B     KEYWRDBE GO TO PROCESS THE NEXT PARAMETER\n         SPACE 2\nCHKAOPT  CLI   MATCHFIL,C'A'  IS THIS THE 'A' OPTION,CHG TO C'X'\n*        WHEN CONVERT DD CODED-NO SYSIN INVALID WITH 'A' AND CONVERT\n         BNE   TIOTERR           NO-SYSIN ABSENT-ERROR\n         LA    R5,NOSYSINA       YES-BYPASS OPENING SYSIN\n         ST    R5,SAVEREGS  AND RETURN TO NOSYSINA AFTER BRANCH\n         B     NOSYSIN     SET BRANCHES AND NOPS AS IF SYSIN PRESENT\n         SPACE 2\nMNKEY    MVI   MNPUTBR+1,SETBR TO BRANCH ON MN TO ALWAYS READ INPUT(M)\n         MVI   MNSTOP+1,SETBE  SET TO BE TO BYPASS ON MNSTOP       (M)\n         MVI   BR6+1,SETBL  SET TO BL WHEN KEYS COMPARED ARE NOT = (M)\n         MVI   NOTMN+1,SETNOP SET   RETURN BRANCH IF PROCESSING MN(M)\n         B     LONGKEY       GO BACK TO CHECK IF LONKEY IS REQUESTED\nBNKEY    EQU   *\n         MVI   BKEYNOP1+1,SETBL  SET BL TO PUT OUT SELECTED RECORD\n         MVI   BKEYBNH+1,SETNOP  NOP A BE INSTR\n         MVI   BKEYBH+1,SETBH    SET BH TO GET 2 NEW SYSIN KEYS\n         MVI   BNKEYBR+1,SETBE   GET NEW INPUT REC WHEN CNT SATISFIED\n         MVI   BNGOREAD+1,SETBR\n         B     BNKEYCNT           CONTINUE WITH B KEY\nCNKEY    EQU   *\n         MVI   ONKEYEQ2+1,SETBE\n         MVI   ONKEYEQ3+1,SETBE\n         MVI   BKEYBNH+1,SETBNE\n         MVI   CKEYNE2+1,SETBNE\n         B     CNKEYBR\n         SPACE 1\nFNINVAL  NOP   KEYINVAL           KEY IS NOT F,CHANGED TO B ON N SUBOP\n         MVI   KEYMSG,C'F'        SET KEYMSG TO INDICATE F KEY\nFKEY     MVI   FMSG+1,SETNOP      NO-OP THE BRANCH AROUND F MESSAGES\n         MVI   FLOGIC+1,SETBR     SET BRANCH TO FLOGIC\n         B     KEYOK              GO TO PROCESS NEXT PARAMETER\nOKEY     MVI   KEYMSG,C'O'   MOVE THE LETTER 'O' TO KEYINDIC FLAG\nOKEY1    NOP   KEYINVAL      CHANGED TO BRANCH ON L SUBOPTION\n         MVI   OLOGIC+1,SETBR  SET BRANCH FOR O KEY\n         MVI   ORKEYBYP+1,SETBR\n         MVI   ORENDCNT+1,SETNOP   BRANCH NOOPED FOR CNT SATISFIED\n         MVI   ONLY1OR+1,SETNOP    BRANCH NOOPED TO PUT OUT MESSAGE\n         MVI   READOLOG+1,SETNOP\n         MVI   INITNPM2+1,SETBR  BYPASS SETTING LENGTH FOR MESSAGE\n         MVI   BCOBRNCH+1,SETBR DONT MOVE LV TO TABLE(R7 NOT SET)-B,C,O\n         B     MKEY\nRKEY     NOP   KEYINVAL\n         MVI   RLOGIC+1,SETBR  SET BRANCH TO ENTER R LOGIC\n         MVI   RBRANCH+1,SETBR SET B AROUND ADDING 4 TO POS & L+P CHK\n         MVI   ORKEYBYP+1,SETBR  SET BRANCH TO SKIP S LOGIC PROCESSING\n         MVI   RMSG+1,SETNOP   SET TO NOP TO PUT OUT COUNT SATISFIED\n         MVI   INITNPM2+1,SETBR  BYPASS SETTING LENGTH FOR MESSAGE\n         MVI   REXTEND+1,SETNOP SET NOP TO CHECK IF ONLY 1 PARM\n         B     KEYOK           PROCESS NEXT PARM\nQKEY     MVI   SEQCHK+1,SETBL    CHANGE NOP TO BRANCH LOW(OUT OF SEQ)\n         MVI   QBOUT2+1,SETBR    CHANGE NOP TO BRANCH (IN SEQUENCE)\n         MVI   NOOPONQ+1,SETNOP  NOOP THE BRANCH = INSTRUCTION ON F\n         MVI   SEQOK+1,SETBR     BRANCH TO GETINPUT ON SEQU O.K.\n         MVI   SEQMSG1+1,SETNOP  NOP TO PUT OUT FILE IN SEQ MSG\n         MVI   SEQMSG2+1,SETNOP  PUT OUT 'OUT OF SEQ' MSG\n         ZAP   TOTLKEYS,=P'200' SET MAX NO OF SEQ ERRORS PRINTED\n         B     FKEY              GO TO F PROCESSING\nBKEY     MVI   ONKEYEQ1+1,SETBL  SET TO BL ON LOW COMPARE TO 1ST KEY\n         MVI   BKEYNOP1+1,SETNOP NOP TO FALL THRU TO COMPARE ON 2ND KEY\n         MVI   BKEYBNH+1,X'D0'  SET BNH TO OUTPT REC AFTER 2ND KEY COMP\n         MVI   BKEYBH+1,SETBR   SET B TO OUTPUT MSG AND GET 2 NEW KEYS\n         MVI   BCNTSAT+1,SETBE  SET BE FOR COUNT SATISFIED\nBNKEYCNT MVI   BKEYNOP+1,SETNOP  SET NOP TO INSURE 6 PARMS ON B KEY\n         MVI   OLOGEND+1,SETNOP NOP THE GO TO ENDINPUT\n         MVI   BMSG+1,SETNOP    NOP TO PUT OUT FINAL B MSG\n         MVI   BKEYBR+1,SETBR   NOP TO SKIP CLASS TEST ROUTINE\n         B     OKEY1   BRANCH INTO O LOGIC\nGKEY     NOP   KEYINVAL         SET TO BR ON L SUBOPTION\n         MVI   GLOGIC+1,SETNOP  SET NOP TO EXECUTE G LOGIC\n         MVI   GBLDBR+1,SETBR   SET TO BRANCH TO BUILD TABLE\n         MVI   PACKFLAG,C'N'     SET FLAG TO INSURE KEY IS LESS THAN 16\n         MVI   READOLOG+1,SETNOP SET NOP TO ENTER O LOGIC TO READ CARDS\n         MVI   BR2CARDS+1,SETNOP SET NOP TO READ 2 CARDS PER PASS\n         MVI   NPEQUAL+1,SETNOP SET NOP TO ACCEPT ONLY 1 L,P PAIR\n         MVI   BKEYBR+1,SETBR  SET B TO SKIP CLASS TEST ROUTINE\n         MVI   SETGLEN,X'BE'   CHANGE CLM INSTRUCTION TO STCM\n         B     TKEY    BRANCH INTO T LOGIC\nTKEY0    MVI   MATCHFIL,C'T'   SET FLAG IN CASE V= OPTION REQUESTED\nTKEY     NOP   KEYINVAL        CHANGED TO BRANCH ON L SUBOPTION\n         MVI   TLOGIC+1,SETBR  SET BRANCH FOR MAIN LINE T LOGIC\n         MVI   TLOGSYS+1,SETNOP     SET NOP FOR READ OF SYSIN\n         MVI   ENDKEYT+1,SETNOP  SET NOP FOR END OF SYSIN\nTLBR     MVI   TTOTRPRT+1,SETNOP SET NOP FOR END OF SYSUT1;SET BR ON L\n         MVI   TMSGBR+1,SETBR     SET BR TO LOOP THRU T MSG\n         MVI   SKIPGET+1,SETBR   SET BRANCH TO TO BYP GETCARD\n         SPACE 2\n         GETMAIN LU,LA=FREELEN,A=TABLE GRAB BYTES FOR TABLE\n         L     R0,TABLE         LOAD R0 WITH THE ADDR OF THE TABLE AREA\n         L     R1,FREELEN     LOAD R1 WITH LENGTH OF THE TABLE\n         SR    R5,R5   LOAD R5 WITH 0-THE LENGTH OF THE SENDING FLD\n         ICM   R5,8,HIGHV       LOAD HIGH ORDER BYTE OF R5 WITH X'FF'\n         MVCL  R0,R4     MOVE HIGH VALUES(PADDING CHAR) TO TABLE AREA\n         CLI   LKEY+1,SETNOP    IS LONG SUBOPTION REQUESTED\n         BNE   MKEY             NO\n         MVI   INITNPM2+1,SETNOP    YES - SET NOPS TO PROCESS L,P PAIRS\n         MVI   ELOGIC+1,SETNOP\n         MVI   LSET2BR+1,SETNOP\n         B     MKEY      GO TO MKEY\nPKEY     MVI   READOLOG+1,SETNOP  READ 1ST SYSIN TO SEE IF LOW VALUES\n         MVI   PBRANCH1+1,SETBR   BRANCH AFTER READING LOW VALUES\n         MVI   PBRANCH2+1,SETBR   BRANCH AFTER READING 1ST SYSIN\n         MVI   PLOGNOP+1,SETNOP   NOP EVEN-ODD SYSIN CHECKING\n         MVI   PZEROBR+1,X'80'    SET BZ TO COUNT EVERY OTHER SYSIN KEY\n         MVI   PMSG+1,SETNOP      NOP TO PRINT P MSG\n         MVC   MSG29PAS(25),MSGSPACE  BLANK OUT RECS PASSED MSG\n         MVI   SETPLEN,X'BE'   CHANGE C INSTRUCTION TO STC\n         B     TKEY\nCKEY     MVI   ONKEYEQ2+1,SETBNE SET BNE FOR NO MATCH ON MASTER\n         MVI   ONKEYEQ3+1,SETBNE SET BNE FOR NO MATCH ON SLAVE\nCNKEYBR  MVI   CKEYEQ+1,SETBR   SET BRANCH TO DO MASTER COMPARE\n         MVI   CKEYNE+1,SETBNE  SET BNE TO DO SLAVE COMPARE\n         MVI   CKEYNOP+1,SETNOP SET NOP TO INSURE 3 SYSIN RECS READ\n         B     OKEY\nKNINVAL  NOP   KEYINVAL        CHANGED TO B ON N SUBOPT\n         MVI   KEQUAL+1,SETBR  SET BRANCH TO PUTOUT REC ON = KEY\n         MVI   FKEY+1,SETBR SET BRANCH TO BYPASS F MESSAGES\n         MVI   KKEYSW+1,SETNOP NOOP TO SEE IF GROUP CNT SATISFIED\n         MVI   KMSG+1,SETNOP   NOOP TO PUT OUT K MESSAGES\n         MVI   KEEQNOP+1,SETNOP SET BR TO ENDINPUT TO A NOP FOR E= PRC\n         B     FKEY\nAKEY     MVI   ACNTBR+1,SETBR   SPECIAL J= PROCESSING\n         MVI   BR4+1,SETNOP\n         MVI   MMSG+1,SETNOP      USE M MSG\n         MVI   MNPUTBR+1,SETNOP   FORCE A NEW SYSIN RECORD\n         MVC   AGETCRD1(2),SETBAL    CHANGE NOP TO BAL INSTR USING R8\n         MVI   MATCHFIL,C'A'         ALLOW V= OPTION\n         MVI   AEXIT+1,SETBE  ACTIVATE ABEND EXIT FOR A 513 BOMB\n         B     MKEY\nEKEY     NOP   KEYINVAL\n         L     R5,MAXLEN       LOAD THE RECORD LENGTH INTO R5\n         BCTR  R5,0              SUBTRACT 1 FROM RECORD LENGTH\n         ST    R5,POSLENS+4     LOAD RESULT INTO 'TO' COL=LRECL\n         MVI   COLBR+1,SETBR   SET B TO PROCESS COLUMN PARAMETERS\n         MVI   REXTEND+1,SETNOP CHECK IF 0 L,P'S SPECIFIED\n         MVI   EOPTBR+1,SETBR  SET B IF 0 L,P'S SPEC.,BYPASS SET LENGTH\n         MVI   INITNPM2+1,SETBR    SET B TO BYPASS SETTING LENGTHS\n         MVI   ORKEYBYP+1,SETBR   SET B TO BYPASS CHECKING THAT L<20\n         MVI   EMSG+1,SETBR       SET B TO PRINT E MSG\n         NI    CONTINPR+1,X'F0'   SET R5=24\n         MVI   CONTINPR+3,X'18'\n         MVI   ELOGIC+1,SETBR      SET B TO BYPASS SETTING UP INPT KEY\n         MVI   YLOGIC+1,SETBR      Y= PARM INVAL ON E OPT\n         MVC   POSLENS(4),LOWVALUE  SET DEFAULT 'FROM' COL=1\n         CLI   MSG40FVU,C'V'        IS SYSUT1 RECFM=V\n         BNE   TKEY                 NO\n         MVC   POSLENS(4),FULL4     YES-SET DEFAULT 'FROM' COL\n         B     TKEY\nVKEY     L     R2,AVSYSIN       GET VSYSIN ADDR\n         BAL   GOREG,OPENINP    OPEN VSYSIN FILE\n         TM    DCBFLAG(R2),X'10'  IS VSYSIN IN JCL\n         BNO   TIOTERR             NO - ERROR\n         MVI   SKIPGET+1,SETBR     SET BR TO BYPASS FET OG SYSIN\n         MVI   MSG40FVU,C'F'       SET 'SYSUT1' TO RECFM=F\n         MVC   MAXLEN(4),=F'100'   SET SYSUT1 LRECL=100\n         MVI   VOPTBR+1,SETBR      SET RETURN AFTER KEY COMPARE SELECT\n         MVI   VOPTREJ+1,SETBR     SET RETURN AFTER KEY COMPARE REJECT\n         MVI   REXTEND+1,SETNOP    NOP TO CHK FOR NO L,P'S\n         MVI   EOPTBR+1,SETBR IF NO L,P'S,SKIP L,P SETS\n         L     R1,=A(OPTNTABL)   ALLOW ONLY J= KEYWORD PARM\n         XC    0(256,R1),0(R1)            \"\n         MVI   X'D1'(R1),X'14'            \"\n         MVI   ENDKEYT+1,SETNOP  NOP FOR EOF ON SYSIN\n         MVI   VTOCLOG+1,SETNOP  PROCESS SYSIN FOR V OPTION\n         MVI   GETVTOC+1,SETNOP  NOP FOR READVTOC CSECT\n         L     R1,=A(VLOGPDS)\n         MVI   1(R1),SETNOP      MODIFY READ PDS RTN FOR V OPTION\n         L     R1,=A(VEND)\n         MVI   1(R1),SETBR\n         B     SKEY            GO TO CHK FOR KEY\n         SPACE 2\nDINVAL   NOP   KEYINVAL        CHANGED TO B ON BPAM,VSAM\nDKEY     MVI   DKEYEQ+1,SETBE CHANGE NOP TO BE TO OUTPUT RECS\n         MVI   DKEYNE+1,SETBR    CHANGE NOP TO B\n         MVI   ACNTBR+1,SETBR  SPECIAL PROCESSING FOR J=+-\n         MVI   SETBEQBR+1,SETBR DONT PUT RECS OUT TO SYSUT3 ON 1ST PASS\n         MVI   DMSG+1,SETNOP  D MESSAGE  - FALL THRU TO S KEY OPTION\n         SPACE 1\nSKEY     NOP   KEYINVAL   THIS ROUTINE WILL MOVE IN THE KEY REQUIRED\n*    FOR THE D, S OR V OPTIONS.THE KEY MUST BE 20\n*    POSITIONS OR LESS AND MUST BE PRECEEDED BY K=,C=,N=,P= OR X=.\n*            THE NOP IS CHANGED TO A BRANCH ON THE L SUBOPTION\n         MVI   BR4+1,SETNOP SET BRANCH TO NOP--ONLY ONE KEY ALLOWED--\n         CLI   VSAMFLAG,C'1' IS VSAMKEY THE PRIMARY INPUT FILE\n         BNE   SKEYCONT      NO\n         MVI   SOPTVSAM+1,SETBR  YES END SELECTION ON S WITH 1ST NEQ\nSKEYCONT LA    R7,1(R7)  POINT TO THE POSITION BEYOND THE ,\n         CLI   1(R7),C'='\n         BNE   CHKVOPT     CHK FOR V OPTION\n         CLI   0(R7),C'K' IS THE FIRST CHARACTER 'K'\n         BE    MOVINKY2   THE KEY STARTS WITH K= CONTINUE PROCESSING\n         TITLE 'CLASS OPTION (AHLNPZ) PROCESSING FOR S, O AND C OPTION'\n         CLI   0(R7),C'C'  HAS CLASS TEST BEEN REQUESTED FOR S KEY\n         BNE   PEQUAL          NO\nCHKLOWV  CLI   2(R7),C'L'     IS LOWVALUE TEST REQUESTED\n         BNE   CHKHIGHV\n         MVI   GOLOWV+1,SETBR\n         MVI   MSG1CLS+2,C'L'\nCHKHIGHV CLI   2(R7),C'H'     IS HIGH VALUES TEST REQUESTED\n         BNE   CHKALPHB\n         MVI   GOHIGHV+1,SETBR\n         MVI   MSG1CLS+1,C'H'\nCHKALPHB CLI   2(R7),C'A'      IS ALPHABETIC TEST REQUESTED\n         BNE   CHKNUMER        NO\n         MVI   GOALPHB+1,SETBR  YES-SET BRANCH ALPHABETIC TEST ROUTINE\n         MVI   MSG1CLS,C'A'     MOVE 'A' TO MESSAGE\nCHKNUMER CLI   2(R7),C'N'      IS NUMERIC TEST REQUESTED\n         BNE   CHKALPHN        NO\n         MVI   GONUMER+1,SETBR  YES-SET BRANCH FOR NUMERIC TEST ROUTINE\n         MVI   NPEQUAL+1,SETNOP SET NOP TO INSURE THERE IS ONLY 1 L,P\n         MVI   MSG1CLS+3,C'N'     MOVE 'N' TO MESSAGE\nCHKALPHN CLI   2(R7),C'Z'    IS ALPHANUMERIC TEST REQUESTED\n         BNE   CHKPACK           NO\n         MVI   GOALPHN+1,SETBR   YES-SET BRANCH FOR FOR ALPHANUM TEST\n         MVI   GONUMER+1,SETBR   AND NUMERIC TEST\n         MVI   NPEQUAL+1,SETNOP SET NOP TO INSURE THERE IS ONLY 1 L,P\n         MVI   MSG1CLS+5,C'Z'    MOVE 'Z' TO MESSAGE\nCHKPACK  CLI   2(R7),C'P'      IS PACK TEST REQUESTED\n         BNE   TESTMSG1          NO\n         MVI   GOPACK+1,SETBR   YES-SET BRANCH FOR PACK TEST ROUTINE\n         MVI   NPEQUAL+1,SETNOP SET NOP TO INSURE THERE IS ONLY 1 L,P\n         MVI   MSG1CLS+4,C'P'     MOVE 'P' TO MESSAGE\nTESTMSG1 CLC   MSG1CLS,MSGSPACE    WAS A CLASS TEST REQUESTED WHEN C=\nOCLASSBR NOP   OCLASCHK        CHANGED TO BRANCH IF O KEY PROCESSING\n         BE    CLASERR1        YES\n         MVI   NOTEST+1,SETNOP NOP FOR CLASS KEY PROCESSING\n         MVI   ENDINF+1,SETNOP TO BLANK OUT K= PART OF MESSAGE\n         LNKMSG 1,DATA=MSG1CLS,BRANCH=MOVINKY2  PUT OUT CLASS TEST MSG\n         SPACE 2\nCHKVOPT  CLI   VOPTBR+1,SETBR  IS THIS V OPTION\n         BNE   KEYERR         ERROR S OPTION MUST HAVE KEY\n         B     VTOCLOG        YES- NO OTHER PARAMETERS, PROCESS SYSIN\n         SPACE 2\nCHKVOPT2 CLI   VOPTBR+1,SETBR IS THIS V OPTION\n         BNE   KEYERR               ERROR\n         BCTR  R7,0    RESET PARM POINTER TO POINT TO COMMA BEFORE J=\n         MVI   ORKEYBYP+1,SETBR  BYPASS KEY LENGTH CHECKING\n         B     KEYWRDBE       YES- JUST 'V,J=N' WITH NO KEY\n         TITLE 'CHECK IF N=,P=,X= SUBOPTION REQUESTED AND MOVE IN KEY'\nPEQUAL   CLI   0(R7),C'P' IS THE FIRST CHAR 'P'\n         BNE   NEQUAL         NO\n         MVI   PACKFLAG,C'P'   YES-SET FLAG FOR P= PROCESSING\n         B     MOVINKY2         CONTINUE PROCESSING\nNEQUAL   CLI   0(R7),C'N'  IS FIRST CHARACTER 'N'\n         BNE   XEQUAL          NO\n         MVI   PACKFLAG,C'N'    YES,SET FLAG FOR N= PROCESSING\n         B     MOVINKY2              CONTINUE PROCESSING\nXEQUAL   CLI   0(R7),C'X'  IS FIRST CHARACTER 'X'\n         BNE   CHKVOPT2    NO-CHK IF V OPTION\n         MVI   PACKFLAG,C'X'    YES-SET FLAG FOR X= PROCESSING\n         SPACE 1\nMOVINKY2 SR    R5,R5     RESET NO. OF CHARS IN PARM TO 0\n         LA    R7,1(R7)  ADD 1 TO THE INPUT ADDRESS GET BEYOND K=\nMOVKYLP  LA    R7,1(R7)  ADD 1 TO POINT TO NEXT FIELD\n         CLI   0(R7),C','  IS THERE A PARAMETER BREAK\n         BE    MOVINKY3   YES\n         IC    R9,0(0,R7)   NO-INSERT THE PARM CHARACTER IN R9\n         STC   R9,INCARD(R5)   STORE THE PARM CHARACTER IN INCARD\n         LA    R5,1(R5)  ADD 1 TO THE NUMBER OF CHAR. IN KEY\n         C     R5,FULL20   ARE THERE MORE THAN 20 CHARACTERS IN THE KEY\n         BH    PARMERR           MORE THAN 20 POSITIONS IN KEY\n         B     MOVKYLP  IF LESS THAN 21 CHAR. CONTINUE PROCESSING\nMOVINKY3 LTR   R5,R5        IS THE SELECTION KEY GREATER THAN 0 POS.\n         BZ    ERRPARM      NO  BRANCH TO ERROR\n         BCTR  R5,0       THE MOVE MUST BE 1 LESS THEN THE ACTUAL CNT\n*        FOR V OPTION SET NOP TO DO KEY COMPARE SINCE K= IS CODED\n         L     R9,=A(VPUTREC)   GET ADDR FROM CSECT OF WRITE RTN\n         MVI   1(R9),SETNOP     FALL THRU TO DO COMPARE BEFORE WRITE\n         TITLE 'PROCESS N=, P= AND X= SUBOPTIONS OF S AND D OPTIONS'\n         CLI   PACKFLAG,BLANK1  IS NUMERIC,PACK OR HEX TEST REQUESTED\n         BE    KEYWRDBE         NO\n         C     R5,FULL15        YES-IS NO OF CHARS IN PARM LESS THAN 15\n         BNL   PACKERR          NO\nNOPMVI   MVI   ENDINF+1,SETNOP YES-NOP THE BRANCH TO BLANK OUT K= MSG\n         CLI   PACKFLAG,C'P'    IS THE P= KEY OPTION REQUESTED\n         BNE   CHKNEQU          NO\n         MVI   GOPACK+1,SETBR   SET BRANCH TO PERFORM PACK TEST\n         MVI   PEQULNOP+1,SETNOP SET NOP TO FALL THRU TO PACK COMPARE\nNUMBROUT EQU   *\n         CLI   INCARD,C'>'      IS N=> OR P=> CODED ON S OPT\n         BE    KEYGT            YES\n         CLI   INCARD,C'<'      IS N=< OR P=< CODED ON S OPT\n         BE    KEYLT            YES\nCHKPLUS  CLI   INCARD,C'+'      IS THERE A PLUS SIGN AS A 1ST CHAR\n         BNE   NOTPLUS          NO\nPACKROUT MVI   INCARD,C'0'      REPLACE THE PLUS WITH A ZERO\nMOVE2WRK MVC   WORKFLD,INCARD   MOVE KEY TO WORKFLD & READY FOR PACKING\n         BAL   GOREG,VERNUM1    PERFORM NUMERIC CHECKING AND THEN PACK\n         CLI   NUMBERR,C'1'     IS IT NUMERIC\n         BE    PACKERR           NO\n         OI    WORKFLD1+7,X'0F'  MOVE AN 'F' TO SIGN HALF-BYTE\nMOVESIGN NI    WORKFLD1+7,X'FC'  MOVE A '+' (C) TO SIGN HALF-BYTE\n         MVC   INCARD(8),WORKFLD1  MOVE WORKFLD1 BACK TO INCARD\n         MVI   NPEQUAL+1,SETNOP    NOP FOR ONLY 1 L,P PAIR IN SETPARM\n         MVI   NOTEST+1,SETNOP     NOP THE BRANCH TO DO REQUESTED TEST\n         B     KEYWRDBE            GET A NEW PARM\nNOTPLUS  EQU   *\n         CLI   INCARD,C'-'         IS THERE A MINUS SIGN AS 1ST CHAR\n         BNE   MOVE2WRK            NO-THERE IS NO SIGN-DEFAULT TO '+'\n         MVI   MOVESIGN+1,X'FD'    YES-MOVE A '-' (D) TO SIGN HALF-BYTE\n         B     PACKROUT            GO BACK TO MAIN ROUTINE\nCHKNEQU  CLI   PACKFLAG,C'N'      IS THE N= KEY OPTION REQUESTED\n         BNE   CHKXEQU            NO\n         MVI   GONEQUAL+1,SETBR   YES-SET BRANCH TO PERFORM N= TEST\n         B     NUMBROUT            GO BACK TO MAIN ROUTINE\n         SPACE 2\nKEYGT    MVI   BR6+1,SETBH CHG TO BH AFTER COMP;CHG TO BNH ON N SUB- S\n*KEYGT   MVI   DKEYEQ+1,SETBH CHG TO BH AFTER COMPARE (D OPT)\n         B     KEYINEQ\nKEYLT    MVI   BR6+1,SETBL CHG TO BL AFTER COMP;CHG TO BNL ON N SUB- S\n*KEYLT   MVI   DKEYEQ+1,SETBL CHG TO BL AFTER COMPARE (D OPT)\n         MVI   SETINVAL+1,X'00' ON INVALID KEY- SET CLI TO PRODUCE A\n*              BNL TRUE CONDITION SO GT(<) DOES NOT CAUSE SELECTION\nKEYINEQ  MVC   INCARD,INCARD+1  SHIFT OUT THE < OR >\n         BCTR  R5,0     ADJUST LENGTH OF KEY\n         B     CHKPLUS\n         TITLE 'PROCESS X= KEYWORD PARAMETER OF THE S AND D OPTIONS'\nCHKXEQU  EQU   *   THE HEX OPTION (PACKFLAG=C'X' OR 'Y') IS REQUESTED\n         STC   R5,HEXTEST+1   STORE NUMBER OF ML HEX CHARS FOR TRT\n         STC   R5,HEXTRANS+1                   AND TR\n         L     R15,=A(HEXTAB1)  LOAD R15 WITH HEXTAB1 ADDRESS\nHEXTEST  TRT   INCARD,0(R15)     DOES KEY HAVE VALID HEX CHARS\n         BNZ   HEXERR            NO\n         L     R15,=A(HEXTAB2)  LOAD R15 WITH HEXTAB2 ADDRESS\nHEXTRANS TR    INCARD,0(R15)     YES-TRANSLATE TO DOUBLE HEX CHARACTERS\n         EX    R5,HEXPACK        PACK THE TRANSLATED KEY\n         MVC   WORKFLD+15(1),WORKFLD1+7  MOVE THE LAST BYTE TO WORKFLD\n         MVO   WORKFLD,WORKFLD1(7)  MOVE IN REST OF KEY SHIFTED RIGHT\n         LA    R5,1(R5)                     1/2 A BYTE\n         LR    R6,R5          R5 CONTAINS THE AL NUMBER OF HEX CHARS\n         N     R6,FULL1  CHANGE ALL BITS TO 0 EXCEPT THE LOW ORDER BIT\n         BNZ   HEXERR   NO OF CHARS ENTERED IS NOT EVEN\n         SRL   R5,1     NO OF CHARS IS EVEN-DIVIDE BY 2\n         LR    R6,R5    LOAD R6 AS THE BRANCH COUNTER WITH KEY LENGTH\n         SR    R4,R4                ZERO R4\n         S     R5,=F'16'    COMPUTE R5=KEY LENGTH-16\n         LPR   R5,R5        COMPUTE R5=|R5|  (ABSOLUTE VALUE)\nMOVEOVER IC    R9,WORKFLD(R5)   WORKFLD NOW CONTAINS CHARACTER KEY\n         STC   R9,WORKFLD(R4)   WHICH WAS GENERATED FROM HEX CHARS.\n         LA    R5,1(R5)      THE MOVEOVER PARAGRAPH CODING LEFT\n         LA    R4,1(R4)      JUSTIFIES THE KEY IN WORKFLD AND\n         BCT   R6,MOVEOVER         AND THEN RETURNS\n         MVC   INCARD(7),WORKFLD   IT TO INCARD.\nYLOGBR   NOP   YLOGIC1         CHANGED TO BRANCH WHEN Y= REQUESTED\n         B     KEYWRDBE\nHEXPACK  PACK  WORKFLD1,INCARD(1)\n         TITLE 'MESSAGE MACRO AREA'\nPACKERR  LA    R1,2                    N= OR P= KEY SUBOPTION ERR\n         B     LNKMSG2\nSYSINNG  LA    R1,3                         SYSIN NO GOOD\n         B     LNKMSG1\nCNTERR2  LA    R1,9\n         B     LNKMSG1\nKEYINVAL LA    R1,10                         KEY INVALID\n         B     LNKMSG1\nPACKERR2 LA    R1,12                         ERR ON N= OR P= KEY SUBOPT\n         B     LNKMSG2\nKEYERR   LA    R1,15\n         B     LNKMSG1\nPOSITNG  LA    R1,16                         L,P INVALID\n         B     LNKMSG2\nYINVAL   LA    R1,17\n         B     LNKMSG1\nPARMERR  LA    R1,18\n         B     LNKMSG1\nHEXERR   LA    R1,20            ERROR ON X= OR Y= PARM OR CONVERT KEYS\n         B     LNKMSG1\nERRPARM  LA    R1,27                         KEYWORD PARM MISSING\n         B     LNKMSG2\nCLASERR1 LA    R1,28       INVALID CLASS ON S AND OPTIONS\n         B     LNKMSG1\nPOSLENNG LA    R1,35                         L+P EXCEEDS LRECL OR 4096\n         B     LNKMSG2\nGERROR   LA    R1,37\n         B     LNKMSG1\nACNTERR  LA    R1,38\n         B     LNKMSG1\nRECFMERR LA    R1,41\n         B     LNKMSG1\nTIOTERR  LA    R1,45\n         B     LNKMSG1\n*LKNG    LNKMSG 47,DATA=SYSUT,BRANCH=RETURN,RETURN=YES  BLK EXCEEDS MAX\nMTCHERR1 LA    R1,50\n         B     LNKMSG1\nMTCHERR2 LA    R1,51\n         B     LNKMSG1\nMTCHERR4 LA    R1,53\n         B     LNKMSG1\nVSAMERR  L     R2,DCBADDR   GET VSAMFILE/KEY RPL ADDR\nVSAMOTER SHOWCB RPL=(R2),AREA=WORKFLD1,LENGTH=4,FIELDS=FDBK\n         L     R2,WORKFLD1      PLACE FDBK CODE IN WORKFLD1\n         CVD   R2,WORKFLD1      AND PACK IT FOR DISPLAY\n         LNKMSG 63,EDIT=WORKFLD1+3,BRANCH=ERROREOJ\n         SPACE 1\nCOLUMNER LA    R1,70        ERR IN COL SPEC OF E OPT\n         B     LNKMSG2\nKEYWRDER LA    R1,71\n         B     LNKMSG1\nABEND    LA    R1,77   THIS IS THE REENTRY ADDRESS AFTER SYNADERR\n         B     LNKMSG1    RETURNS CONTROL AFTER DUMPING 5 BAD BLOCKS\nLIBOUTER EQU   *       STOW ERROR IN WRITING OUTPUT PDS LIBOUT\n         L     R1,=A(BLDENTRY)               GET MEMBER NAME FOR MSG\n         LNKMSG 89,DATA=(R1,8),BRANCH=ERROREOJ\nLIBERR2  LA    R1,95   DISALLOW VARIABLE LENGTH RECS ON LIBOUT UNLESS @\n         B     LNKMSG1\nINVALVKY LA    R1,96   INVALID SYSIN KEY ON V OPTION\n         B     LNKMSG1\nVMSGSAT  MVI   MSG5FLAG,X'52'  SET UP COUNT SATISFIED MSG\n*MSGPT   LA    R2,9    PRINT 9 MSGS FOR V OPTION\nVMSGPT   LH    R2,MSGCNT PRT 9 MSGS FOR V OPTION;VARIABLE FOR EXITS\n         LR    R5,R1   GET ADDR OF FIRST MSG (IN R1)\nVMSGLOOP L     R1,PRINTBUF\n         MVC   0(VMSGLEN,R1),0(R5)   MOVE IN MSG\n         BAL   GOREG,PUTPRINT\n         LA    R5,VMSGLEN(R5)  POINT TO NEXT MSG\n         BCT   R2,VMSGLOOP\nXMSGNOP  NOP   XITERR2         SET TO BR FOR EXITS MSGS\nVMSGNOP  B     PUTMSGR5        SET TO NOP ON V OPTION ERROR\n         SPACE 2\nVMSGERR  LA    R1,98      V OPTION ERROR\n         B     LNKMSG1\n         TITLE 'MESSAGE SUBROUTINE'\nLNKMSG1  LNKMSG R1,BRANCH=ERROREOJ\nLNKMSG2  LNKMSG R1,BRANCH=INITNPM,RETURN=YES\n         SPACE 2\n*   THIS SUBROUTINE WILL USE THE FOLLOWING REGISTERS\n*   R1  ON ENTRY -THIS IS THE MESSAGE NUMBER\n*   R1  IS USED ALSO TO PASS THE ADDRESS OF 2 FULLWORDS THAT\n*        CONTAIN A- THE ADDRESS OF THE PRINT BUFFER\n*                B- THE MESSAGE NUMBER\n*   R14 AND R15 ARE THE LINK REGISTERS (BALR)\n*   R8 USE FOR PRNT SUBROUT\nCALLSUB  EQU   *\n         MVC   BRLNKLST(4),PRINTBUF   MOVE IN THE ADDRESS OF PRINT BUF\n         LA    R1,BRLNKLST       SET R1 TO ADDRESS OF LINKLIST\n         L     R15,MOVEMSGV      LOAD THE SUBROUTINE BRANCH\n         BALR  R14,R15           BRANCH TO SUBROUTINE AND SET RETURN\n         L     R1,PRINTBUF       LOAD THE ADDRESS OF THE PRINT BUFFER\n         ST    GOREG,BRLNKLST    PUT BRANCH ADDR IN BRLNKLST\n         BAL   GOREG,PUTPRINT    PRINT THE ERROR MESSAGE\n         L     GOREG,BRLNKLST\n         MVC   BRLNKLST(12),LOWVALUE   ZERO OUT LIST\n         BR    GOREG             BRANCH TO BRANCH ADDR SPEC BY MACRO\n         TITLE 'PROCESS THE B=, E= AND J= OPTIONS'\nKEYWRDBE NOP   CHKBEQU     CHANGED TO BRANCH FIRST TIME THRU\n         MVI   KEYWRDBE+1,SETBR\n         MVI   SELCODE+1,SETBR  SET BRANCH AFTER READING IN PARM\nCHKEJV   CLI   2(R7),C'='     IS Y=,B=,E=,J=,V= REQUESTED\n         BNE   CHKMLNOV       NO-INSURE V= IS CODED WITH THE ML OPTION\nKEYWRDOK SR    R2,R2\n         L     R15,=A(OPTNTABL)  LOAD ADDR OF KEYWRD TABLE\n         TRT   1(1,R7),0(R15)    IS KEYWORD VALID\n         BZ    KEYWRDER          NO\n         IC    R1,0(0,R1)       PUT THE KEYWORD IN LOW ORDER BYTE OF R1\n         STC   R1,NOPOPTN+3      FIND KEYWORD IN OPTION TABLE\nNOPOPTN  MVI   0(R15),SETNOP NOP THIS KEYWORD FOR THE FUTURE-DISP ADJ\n         MVI   CHKV+1,SETNOP     RESET BRANCH FOR V= KEYWORD\n         MVI   EBRANCH+1,SETNOP  RESET BRANCH FOR E= KEYWORD\n         MVI   JBRANCH+1,SETNOP  RESET BRANCH FOR J= KEYWORD\n         B     JUMPOFF2-4(R2)    BRANCH TO APPROPIATE KEYWORD ROUTINE\nJUMPOFF2 B     YLOGIC            GO TO Y= LOGIC\n         B     MATCHCHK          GO TO V= LOGIC\n         MVI   EBRANCH+1,SETBR   SET BRANCH FOR E=\n         B     GETKEY\nACNTBR   NOP   ACNTCHK     SET TO B ON 'A' AND 'D' OPTIONS\n         MVI   JBRANCH+1,SETBR   SET BRANCH FOR J=\nGETKEY   BCTR  R3,0     YES-RESET R3 (NO OF PARMS) TO 1\nGETKEYV  LA    R7,2(R7)      SET R7 TO POINT TO BEGINNING OF PARM\n         B     PRELOOP        GO TO READ IN PARM ROUTINE\nCHKBEQU  BAL   GOREG,VERNUM   VERIFY THE PARM FOR NUMERICS\n         CLI   NUMBERR,C'1'\n         BE    POSITNG        THERE IS AN ERROR\nEBRANCH  NOP   CHKEEQU        SET TO BRANCH WHEN PROCESSING E= PARM\nJBRANCH  NOP   CHKJEQU        SET TO BRANCH WHEN PROCESSING J= PARM\n         ZAP   BEGIN,WORKFLD1    MOVE BEGIN AMOUNT INTO 'BEGIN'\n         LNKMSG 55,EDIT=BEGIN+3,BRANCH=CHKEJV\n         SPACE 1\nCHKEEQU  ZAP   END,WORKFLD1     MOVE END AMOUNT TO 'END'\n         CP    BEGIN,END        IS BEGIN AMOUNT LESS THAN END AMOUNT\n         BNH   CHKEJV           YES-GOOD,NOW CHK IF J= IS REQUESTED\nBEGINNG  LA    R1,13                NO-ERROR\n         B     LNKMSG1\n         SPACE 1\nCHKJEQU  CP    WORKFLD1,PACKZERO   IS J=0\n         BNE   ZAPCNT               NO\n         CLI   LSKIP1+1,SETBR  YES-IS THIS THE LONG SUBOPTION\n         BE    POSITNG             YES-ERROR\n         CLI   KEYMSG,C'F'         IS THIS THE F OPTION\n         BNE   POSITNG             NO-ERROR\n         MVI   FREQUECY+1,SETBR    YES-SET BRANCHES\n         MVI   FREQMSG+1,SETBR\n         B     CHKEJV\nZAPCNT   CLI   ECHGMSG+1,SETNOP IS E OPT $ OR @ CHG REQUESTED\n         BNE   ZAPCNT2     NO\n         ZAP   EJEQCNT,WORKFLD1 PACK COUNT PARM INTO SPEC CHG-KEY CNT\n         B     CHKEJV\nZAPCNT2  ZAP   COUNT,WORKFLD1   PACK THE COUNT PARM INTO PARM\n         B     CHKEJV           CHK IF V= IS REQUESTED\n         TITLE 'EQUATE SYMBOL PROCESSING'\nYLOGIC   NOP   YINVAL             SET TOB ON E OPT AND L SUBOPT\n         MVI   YLOGBR+1,SETBR     SET BRANCH TO COME BACK HERE\n         MVI   NOPMVI,X'47'       NOP THE NOP OF ENDINF\n         MVC   SAVECARD,INCARD         SAVE INCARD\n         MVC   SAVEFLAG,PACKFLAG       SAVE PACKFLAG\n         MVI   PACKFLAG,C'Y'    MOVE 'Y' TO PACKFLAG TO EX 'X' ROUTINE\n         LA    R7,1(R7)\n         B     MOVINKY2          READ IN Y= KEY\nYLOGIC1  SR    R5,R5\n         L     R9,=A(TRNSTAB5)  LOAD ADDR OF TRANSLATE TABLE INTO R9\n         MVI   KEYSET+1,SETNOP   SET NOP TO TRANSLATE SYSUT1 KEY\n         MVI   TRNSCARD+1,SETNOP SET NOP TO TRANSLATE SYSIN FOR V= KEYS\nYLOOP    SR    R6,R6\n         IC    R6,INCARD(R5)\n         AR    R6,R9        FIND SYMBOL IN Y= IN THE TRANSLATE TABLE\n         MVC   0(1,R6),INCARD    EQUATE SYMBOL TO MASTER SYMBOL\n         LA    R5,1(R5)          POINT TO NEXT SYMBOL\n         BCT   R4,YLOOP R4=LENGTH OF Y= KEY,BUT NOT LENGTH OF INPUT KEY\n         MVC   PACKFLAG,SAVEFLAG      RESTORE PACKFLAG AND INCARD\n         MVC   INCARD,SAVECARD\n         L     R15,=A(TRNSTAB5) LOAD ADDR OF TRANSLATE TABLE INTO R15\n         TR    INCARD,0(R15)      TRANSLATE THE S AND D KEYS\n         B     CHKEJV                   RETURN\n         SPACE 3\nCHKMLNOV CLC   1(3,R7),=C'VP='      IS THIS THE VP= KEYWORD\n         BE    KEYWRDOK         YES-CONTINUE KEYWORD PROCESSING\n         CLI   LSKIP1+1,SETBR    NO-IS THIS THE L SUBOPTION\n         BNE   INITNPM              NO\n         CLI   MATCHFIL,C'M'        YES- IS THIS THE M OPTION\n         BNE   INITNPM              NO\n         L     R15,=A(OPTNTABL)     YES- LOAD THE OPTION TABLE\n         CLI   229(R15),X'00'       230=X'E5'=C'V',IS V= CODED\n         BE    INITNPM              YES\n         LA    R1,50                NO-ERROR\n         B     LNKMSG1              PUT OUT ERROR MSG\n         TITLE 'SET UP OPERATOR FOR RECORD TO RECORD MATCHING'\nACNTCHK  CLI   DKEYNE+1,SETBR   IS THIS THE D OPTION\n         BE    DPLUSMIN         YES -BRANCH TO SPECIAL ROUTINE\n         CLI   5(R7),C','       IS J=(EQ,NE,...) FOLLOWED BY ','\n         BNE   ACNTERR          ERROR\n         CLC   3(2,R7),=C'EQ'   IS OPERATOR ='EQ' (DEFAULT)\n         BE    ACNTOK           YES\n         MVI   BR6+1,SETBNE     NE\n         CLC   3(2,R7),=C'NE'   IS OPERATOR ='NE'\n         BE    ACNTOK           YES\n         MVI   BR6+1,SETBL      LT\n         CLC   3(2,R7),=C'LT'   IS OPERATOR ='LT'\n         BE    ACNTOK           YES\n         MVI   BR6+1,X'D0'      LE\n         CLC   3(2,R7),=C'LE'   IS OPERATOR ='LE'\n         BE    ACNTOK           YES\n         MVI   BR6+1,SETBH      GT\n         CLC   3(2,R7),=C'GT'   IS OPERATOR ='GT'\n         BE    ACNTOK           YES\n         MVI   BR6+1,X'B0'      GE\n         CLC   3(2,R7),=C'GE'   IS OPERATOR ='GE'\n         BE    ACNTOK           YES\n         MVI   BR6+1,SETBR      * (FORCE MATCH INDEPENDENT OF KEYS)\n         CLC   3(2,R7),=C'**'   IS OPERATOR ='*'\n         BNE   ACNTERR          YES\nACNTOK   LA    R7,5(R7)         POINT TO NEXT PARAMETER\n         B     CHKEJV                 RETURN\n         SPACE 3\nDPLUSMIN CLI   3(R7),C'+'   IS J=+N\n         BNE   DNOTPLUS     NO\n         MVI   DPLUSBR+1,SETBR   YES\n         MVI   SUBCNT,X'F9'   NOP THE CHANGING OF PASSCT\n         MVI   ADDCNT,X'F9'   NOP THE CHANGING OF COMPCNT\n         B     JRETURN\nDNOTPLUS CLI   3(R7),C'-'   IS J=-N\n         BNE   JRETURN2\n         MVI   DMINSNOP,X'F9'   NOP THE CHANGING OF COMPCNT\nJRETURN  MVI   3(R7),C'0'       SET + OR - TO 0\nJRETURN2 MVI   JBRANCH+1,SETBR\n         B     GETKEY\n         TITLE 'FILE MATCHING LOGIC- SET UP SYSUT4 AND SYSUT5'\nMATCHCHK CLI   MATCHFIL,BLANK1 YES,IS THE OPTION M, T OR A\n         BE    MTCHERR1       NO-ERROR\n         CLI   2(R7),C'P'     YES, IS VP= PACKED SUBOPTION REQUESTED\n         BE    PACKCOMP       YES\nCHKPAREN CLI   3(R7),C'('     NO,ARE THE L,P'S PRECEEDED BY A '('\n         BNE   MTCHERR2       NO-ERROR\n         MVI   VBRANCH+1,SETBR   SET BRANCH ON L,P PROCESSING FOR V=\n         MVI   CHKV+1,SETBE     SET TO BRANCH EQUAL WHEN ')' IS HIT\n         LA    R7,1(R7)    UP PARM POINTER BY 1 (COMPENSATE FOR '(' )\n         MVI   SYSINDCB+1,SETBR      SET BR FOR SYSIN DCB CHECKING\n         MVC   SAVEDCB(2),MAXLEN+2       SAVE THE INPUT LRECL AND\n         MVC   SAVEDCB+2(3),MSG40FVU                    RECFM\n         L     R3,ASYSIN       LOAD R3 WITH ADDRESS OF SYSIN DCB\nA513NOP  B     CHKDCB2  & BRANCH TO DCB CHECKING ROUTINE,NOP ON S513\n         SPACE 2\nVRETURN  CLI   MATCHFIL,C'T'   ALLOW SYSUT4 AND SYSUT5 ON A AND M OPT\nASAMETAP BE    NOMERGE         BUT NOT ON T,CHANGED TO B ON 'A' S513\n         MVI   MMSG+1,SETNOP     NOP FOR FINAL A OR M MSG ON V= OPT\n         MVI   ENDINF+1,SETNOP   NOP FOR FINAL A OR M MSG ON V= OPT\n         OI    SKIPPRNT+1,SETBR  SET BR TO SUPPRESS DETAIL LINE PRINT\n         MVI   MSG5FLAG,X'50'    SET FOR MSG 80\n         L     R2,AOUTFIL3\n         CHCKTIOT NOTFND=CHKSYST5\n         MVI   SYSUT,C'4'\n         BAL   GOREG,OUTATTR  OPEN & PUTOUT SYSUT4 ATTRIBUTES\n         MVI   SYSINOUT+1,SETNOP   SET NOP TO PUT OUT SYSIN RECS & MSG\n         MVI   CLS3NOP+1,SETNOP\nCHKSYST5 L     R2,AOUTFIL4         GET SYSUT5 FOR CHCKTIOT AND OPEN\n         CHCKTIOT NOTFND=CHKMERGE\n         MVI   SYSUT,C'5'\n         BAL   GOREG,OUTATTR   OPEN & PUTOUT SYSUT5 ATTRIBUTES\n         MVI   SYSINOT2+1,SETNOP   SET NOP TO PUT OUT SYSIN RECS & MSG\n         MVI   CLS4NOP+1,SETNOP\nCHKMERGE L     R2,=A(MERGE)       MOVE MERGE TO DDNAME\n         CHCKTIOT NOTFND=NOMERGE\n         MVC   MERGEBAL(2),SETBAL   SET BAL TO PERFORM MERGE OUTPUT RTN\n         TITLE 'FILE MATCHING-SET UP LENGTHS && DISPLCEMENTS FOR SYSIN'\nNOMERGE  LA    R3,1          RESTORE R3 TO THE COUNT OF THE PARMS\n         B     GETKEYV         RETURN\nCHKVEQU  EQU   *\n         MVI   VBRANCH+1,SETNOP RESET BR ON L,P PROCESSING TO A NOP\n         CLI   MSG40FVU,C'F'    IS RECFM=F ON SYSIN (NOT U OR V)\n         BE    RESTRDCB     YES\n         MVI   SYSINVAR+1,SETBR NO -SET B FOR V/U RECS PROC ON ML,AL\n         OC    V1LPPAIR+1(1),LSKIP1+1   ENSURE 1 L,P ON AL,ML\n         XC    NPEQUAL+1(1),LSKIP1+1   ENSURE 1 L,P ON AL,ML\nRESTRDCB MVC   SYSINFVU,MSG40FVU   SAVE SYSIN RECFM (F,V,U ONLY)\n         MVC   MAXLEN+2(2),SAVEDCB      RESTORE THE LRECL AND RECFM\n         MVC   MSG40FVU(3),SAVEDCB+2    OF THE PRIMARY INPUT FILE\n         MVI   ENDPARMS,BLANK1 RESET THE END OF PARMS FLAG\n         CLI   0(R7),C')'     DOES V= PARM END IN A ')'\n         BNE   MTCHERR2       NO-ERROR\n         LA    R7,1(R7)       YES\n         CLI   0(R7),C','     IS V= PARM FOLLOWED BY ','\n         BNE   MTCHERR2                 NO\nLSET2BR  MVI   VSETNOP+1,SETNOP NOP TO MOV KEY INTO INCARD EXCEPT ON L\n         L     R4,POSLENS               SEE COMMENTS FOR CHKNUMB\n         STC   R4,VSET1+1\n         STC   R4,VSETTR1+1  THIS AND NEXT 3 MVI'S FOR CONVERT PROCESS\n         STC   R4,VSETLTR1+1\n         STC   R4,V1SET1+1\n         STC   R4,V1SET2+1\n         ST    R4,VLEN123\n         MVC   VPOSLENS(4),POSLENS+4   SAVE THE POSITION IN V=\n         C     R3,FULL4\n         BE    ENDV\nV1LPPAIR NOP   CNTERR2           CHANGED TO B ON L SUBOPT\n         SPACE 1\n         MVI   VBRL1+1,SETNOP\n         MVI   VBR1+1,SETNOP\n         L     R5,POSLENS+12\n         S     R5,POSLENS+4\n         ST    R5,VPOSDISP\n         L     R5,POSLENS+8\n         ST    R5,VLEN123+4\n         STC   R5,VSET2+1\n         STC   R5,VSETTR2+1\n         STC   R5,VSETLTR2+1\n         LA    R4,1(R4)\n         STC   R4,VSET2+3\n         AR    R4,R5\n         C     R3,FULL6\n         BE    ENDV\n         SPACE 1\n         MVI   VBRL2+1,SETNOP\n         MVI   VBR2+1,SETNOP\n         L     R5,POSLENS+20\n         S     R5,POSLENS+12\n         ST    R5,VPOSDISP+4\n         L     R5,POSLENS+16\n         ST    R5,VLEN123+8\n         STC   R5,VSET3+1\n         STC   R5,VSETTR3+1\n         STC   R5,VSETLTR3+1\n         LA    R4,1(R4)\n         STC   R4,VSET3+3\n         AR    R4,R5\n         C     R3,FULL8\n         BE    ENDV\n         B     CNTERR2\nENDV     LA    R3,1               RESET R3 TO NUMB OF PARMS PROCESSED\n         MVI   POSLENS,X'FF'\n         MVC   POSLENS+1(23),POSLENS  RESET POSLENS TO HIGH VALUES\n         STCM  R4,3,VLENGTH     STORE LENGTH OF SYSIN KEY\n         STC   R4,VPNUMTST+1    STORE LENGTH OF VP KEY FOR NUM TEST\n         STC   R4,VPPACK+1\n         OI    VPPACK+1,X'70'   SET PACK LENGTH IN PACK INSTRUCT FOR VP\n         B     CHKEJV                      RETURN\n         SPACE 2\nPACKCOMP CLI   NOPONL+1,SETNOP   IS L SUBOPTION USED\n         BE    KEYINVAL                 YES- ERROR\n         CLI   MATCHFIL,C'T'     IS T OPTION USED\n         BE    KEYINVAL                 YES- ERROR\n         LA    R7,1(R7)             NO-ADD 1 TO POINT BEYOND P\n         MVI   PEQULNOP+1,SETNOP   DO PACK COMPARE\n         MVI   NOTEST+1,SETNOP     NOP TO DO PACK TEST AND CP\n         MVI   GOPACK+1,SETBR       DO PACK TEST ON SYSUT1\n         MVI   NOPONVP+1,SETNOP    NOP LENGTH COMPARE\n         NI    NOPGETBR+1,X'0F'    NOP RETURN ON GETCARD TO DO NUM TEST\n         MVI   NPEQUAL+1,SETNOP  ALLOW ANLY 1 L,P PAIR ON SYSUT1\n         MVI   V1LPPAIR+1,SETBR  ALLOW ANLY 1 L,P PAIR ON SYSIN\n         MVI   PACKFLAG+1,C'N'    SET FLAG TO FORCE L<16\n         B     CHKPAREN         RETURN\n         TITLE 'VERIFYING THE LENGTH/POSITION PARAMETERS'\nVERNUM   EQU   * CHECK TO SEE IF WORKFLD IS NUMERIC.\n*   R5 CONTAINS THE NUMBER OF CHARACTERS IN  WORKFLD.\n         BCTR  R5,0      SUBTRACT 1 FROM THE COUNT OF NUMBERS\nVERNUM1  MVI   NUMBERR,BLANK1 SPACE OUT ERROR FLAG AT START OF ROUTINE\n         L     R15,=A(TRNSTAB2)  LOAD R15 WITH ADDRESS OF TRNSTAB2\n         EX    R5,VERNUMLP  TEST WHETHER WORKFLD IS NUMERIC\n         BNZ   VERNUMER   NONZERO RETURN CODE INDICATES NON-NUMERIC\n         EX    R5,PKVNUM  EXECUTE THE PACK OF THE WORKFLD\n         BR    GOREG\nVERNUMER MVI   NUMBERR,C'1'  SET ERROR SWITCH\n         BR    GOREG\nVERNUMLP TRT   WORKFLD(1),0(R15)    TEST WORKFLD FOR NUMERICS\nPKVNUM   PACK  WORKFLD1,WORKFLD(1) THIS PACKS THE  NUMBER BEING\n*   VERIFIED INTO WORKFLD1. THE LENGTH  OF WORKFLD IS MODIFIED.\n         SPACE 1\nPOSVER   EQU   * THE POSITION/LENGTH  MUST BE NUMERIC & LESS THAN LRECL\n         BAL   GOREG,VERNUM  VERIFY THE NUMBER\n         CLI   NUMBERR,C'1'  IS IT O.K.\n         BE    POSITNG\n         CVB   R6,WORKFLD1 CONVERT THE LENGTH/POSITION TO  BINARY\n         LTR   R6,R6        IS WORKFLD1 = 0\n         BZ    POSITNG                YES\n         BCTR  R6,0         SUBTRACT 1 FROM WORKFLD1\n         S     R9,FULL8  R9 NOW PTS TO THE APPROPIATE PLACE IN POSLENS\nCOLBR    NOP   COLUMNS    CHANGED TO B ON E OPT\nLENGRET  NOP   STORELEN   CHANGED TO B IF VERIFYING THE LENGTH\nRBRANCH  NOP   STORELEN         CHANGED TO BRANCH ON R KEY\n         CLI   MSG40FVU,C'V'    IS RECFM=V\n         BNE   STOREPOS         NO\n         A     R6,FULL4     YES-ADD 4 TO POSITION PARM\nSTOREPOS ST    R6,POSLENS(R9) STORE POSITION IN POSLENS + INDEX\n         S     R9,FULL4      POSLENS(R9) NOW POINTS TO PREVIOUS LENGTH\n         A     R6,POSLENS(R9)      ADD LENGTH TO POSITION\n         CLI   VSAMFLAG,C' '      INPUT A VSAMFILE (VSAMKEY)?\n         BE    CMPRLREC         NO\n         S     R6,FULL4       YES-SUBTRACT OFF THE 4 ADDED FOR RDW\nCMPRLREC C     R6,MAXLEN    IS LENGTH+POSITION GREATER THAN LRECL\n         BNL   POSLENNG          YES\nLSKIP1   NOP   LCONTIN           SET TO B ON LSUBOPT\n         L     R6,POSLENS(R9)    LOAD PREVIOUS LENGTH INTO R6\n         C     R6,FULL20        IS THE LENGTH GREATER THAN 20\n         BNL   PARMERR          YES\nLCONTIN  CLI   PACKFLAG,BLANK1 WAS 'N=','X=' OR 'P=', G OPT OR VP= REQ\n         BE    INITNPM        NO\n         C     R6,FULL15  YES-DOES THE PARM LENGTH OF THE KEY EXCEED 15\n         BNL   PACKERR2            YES-THERE IS AN ERROR\n         CLI   PACKFLAG,C'N'   WAS THE N= OPTION REQUESTED\n         BE    INITNPM         YES\n         C     R6,FULL8     NO-DOES THE PARM LENGTH OF THE KEY EXCEED 8\n         BNL   PACKERR2     YES\n         B     INITNPM      NO- PROCESS NEXT PARAMETER\nSTORELEN EX    0,STOREPOS       STORE THE COUNT/LENGTH IN POSLENS\n         MVI   LENGRET+1,SETNOP NOP THE LENGTH VERIFICATION ROUTINE\n         B     INITNPM\n         TITLE 'SET UP COLUMN PROCESSING FOR THE E OPTION'\nCOLUMNS  EQU   *\n         CLI   MSG40FVU,C'V'     IS RECFM=V\n         BNE   COLNOTV             NO\n         LA    R6,4(R6)      YES -ADD 4 TO EACH COLUMN SPECIFICATION\nCOLNOTV  EX    0,STOREPOS        STORE THE COLUMN SPECIF IN POSLENS\n         C     R6,MAXLEN      IS COLUMN SPECIFICATION MORE THAN LRECL\n         BNL   COLUMNER       YES-ERROR\n         S     R9,FULL4       NO-POINT TO PREVIOUS COLUMN SPECIF\n         BM    INITNPM           THIS IS FIST COLUMN SPECIF\n         C     R6,POSLENS(R9)  IS L1<P1<L2<P2<L3<P3\n         BL    COLUMNER         NO-ERROR\n         B     INITNPM                YES\n         TITLE 'CONTINUE PROCESSING AFTER ALL PARAMETERS ARE VERIFIED'\n*   CALCULATE MAXIMUM NO OF TABLE ENTRIES FOR T,G LOGIC\nCONTINPR LA    R5,5(R4)   R5=LENGTH OF KEY+COUNT FOR T,G OPTIONS\n*             CHANGED ON E TO RESET LENGTH\n         LM    R6,R7,LOWVALUE ZERO OUT R6,R7\n         ICM   R7,7,FREELEN+1   GET LENGTH OF TABLE\n         DR    R6,R5      DIVIDE BY LENGTH OF TABLE ENTRY\n         CVD   R7,INLRECL MOVE MAXIMUM NO OF TABLE ENTRIES TO INLRECL\n         ED    MSG36OUT,INLRECL+5  MOVE MAX NO OF ENTRIES TO MSG\n         SPACE 1\n         DROP  R3,R4,R5   R3 NOW FREED FROM THE DCB & R4,R5 FROM TIOT\n         LA    R3,KEYAREA LOAD ADDR OF INPUT KEY AREA & KEEP IT IN R3\n         LA    R9,INCARD  LOAD ADDR OF SYSIN KEY AREA & KEEP IT IN R9\n         SR    R6,R6   INITIALIZE R6 TO 0 FOR R LOGIC\n         L     R7,TABLE    R7 PTS TO 1ST ENTRY IN SYSIN TABLE-T,G LOGIC\n         TITLE 'SET UP PARM && SYSIN CARDS FOR O,C AND B LOGIC'\nORKEYBYP NOP   READOLOG   CHANGED TO BRANCH ON 'O','B','R' ,'E' KEY\n         C     R4,FULL20         MAXIMUM LENGTH OF KEY IS 20 CHARS\nNOPONL   BNL   PARMERR           ERROR,CHANGED TO NOP ON L SUBOPT\nSKIPGET  NOP   READOLOG          CHANGED TO BRANCH ON 'T', 'G' AND 'P'\n         BAL   GOREG,GETCARD     GET FIRST SYSIN CARD\nREADOLOG B     BYPOREAD  NOP ON O,G,P,B & C KEY TO READ 1ST SYSIN CRD\n         SPACE 1\nBKEYREAD L     R1,ASYSIN          GET SYSIN DCB ADDR\n         GET   (R1)\n         MVI   KEYINDIC,C'1'      INDICATES LOWER KEY READ ON B KEYS\n         AP    RCOUNT,PACKONE    ADD 1 TO NO OF SYSIN CARDS READ\nLOWVBR   NOP   MOVINCRD     SET TO B AFTER TIME THRU-ONLY 1 LV ALLOWED\n         MVI   LOWVBR+1,SETBR\n         CLC   0(10,R1),LOWVMSG  IS LOW VALUES REQUESTED ON B OR P\n         BNE   MOVINCRD             NO\n         MVC   MSG29LKY(10),0(R1)   MOVE 'LOW VALUES' INTO MSG ON B OPT\nBCOBRNCH NOP   BR2CARDS    CHANGED TO B ON B,C & O OPT TO GET 2ND CARD\nPLOWVALU MVC   0(0,R7),LOWVALUE   MOVE X'00' TO TABLE,LENGTH ADJUSTED\nPBRANCH1 NOP   GBUILD2              CHANGED TO B ON P OPTION\n         B     BR2CARDS             GO TO READ 2ND CARD\n         SPACE 2\nMOVINCRD MVC   INCARD,0(R1)  LENGTH ADJUSTED- ON P OPT ONLY\n* CANNOT ADJUST LENGTH ON C OR O OPTION FOR CLASS= KEYWORD\n*PROBLEM WILL RESULT ON B,C OR O OPTION IF SYSIN LRECL IS LESS THAN 20\nOKEYMSG1 MVC   MSG21KEY,INCARD       MOVE IN FIRST 'O' KEY\nPBRANCH2 NOP   GBUILD               CHANGED TO BRANCH ON P KEY\n         MVC   MSG29LKY,MSG21KEY    MOVE IN LOW KEY FOR B MSG\n         CLC   INCARD(6),=C'CLASS='   IS CLASS TEST REQUESTED\nBKEYBR   BNE   BR2CARDS  CHANGED TO B ON B,G KEY-NO CLASS TEST ALLOWED\n         MVC   MSG21KEY,INCARD   MOVE 'CLASS=......' SYSIN CARD IN\n         MVI   OCLASSBR+1,SETBR  SET UP BR TO RETURN HERE ON CLASS TEST\n         LA    R7,INCARD+3       SET UP R7(T,G,P ROUTINES NEVER ENTER\nOCLASCHK LA    R7,1(R7)     HERE,HENCE WE CAN USE R7.SIMILARLY FOR R6)\n         LA    R6,1(R6)   R6 COUNTS NO OF CLASS OPTIONS REQUESTED\n         CLI   2(R7),BLANK1   IS THIS THE END OF THE CLASS OPTION LIST\n         BE    TESTMSG2       YES\n         C     R6,FULL6       NO-ARE THERE MORE THAN 6 REQUESTS\n         BNH   CHKLOWV        NO-CONTINUE CHECKING CLASS OPTIONS\nTESTMSG2 MVI   NPEQUAL+1,SETBR RESTORE NPEQUAL TO A BRANCH\n         CLC   MSG1CLS,MSGSPACE    WAS CLASS TEST REQUESTED\n         BE    CLASERR1            YES\n         L     R4,POSLENS      LOAD THE FIRST LENGTH INTO R4 FOR CLASS\n         MVI   MAINLIN1+1,SETNOP NOP TO BRANCH TO O LOGIC MAINLINE\n         MVI   NOTEST+1,SETNOP NOP TO PROCESS CLAS TESTS ON O OPTION\n         LNKMSG 1,DATA=MSG1CLS        PUT OUT CLASS MESSAGE\nBR2CARDS B     BYPOREAD   NOOP ON O,B  KEY TO READ 2ND SYSIN CARD\n         SPACE 1\n         L     R1,ASYSIN    GET SYSIN DCB\n         GET   (R1)\nMOVINCD2 MVC   INCARD1,0(R1)     LENGTH ADJUSTED\nBKEYMSG2 MVC   MSG29UKY,INCARD1  MOVE IN HIGH KEY ON B KEY FOR MSG\n         MVI   KEYINDIC,C'2'      INDICATES HIGHR KEY READ ON B KEYS\nBBRANCH  NOP   OLOGIC1    CHANGED TO BRANCH ON B KEY AFTER 1 TIME THRU\n*           AND CHANGED BACK TO NOP ONLY IF COUNT SATISFIED ON B\nBR3CARDS B     BYPOREAD      NOOP ON O KEY TO READ 3RD SYSIN CARD\n         SPACE 1\n         L     R1,ASYSIN    GET SYSIN DCB\n         GET   (R1)\nMOVINCD3 MVC   INCARD2,0(R1)      LENGTH ADJUSTED\nBYPOREAD EQU   *\n         TITLE 'BUILD SYSIN TABLE FOR T,G AND P LOGIC'\nGLOGIC   B     TLOGSYS    NOP ON G KEY-LENGTH SET ON GNUM1,GNUM2,GCOMPR\n         L     R15,=A(TRNSTAB2)  LOAD R15 WITH ADDRESS OF TRNSTAB2\nGNUM1    TRT   INCARD,0(R15)     TEST FIRST SYSIN CARD FOR NUMERICS\n         BNZ   GERROR      NO\nGNUM2    TRT   INCARD1,0(R15)    TEST 2ND   SYSIN CARD FOR NUMERICS\n         BNZ   GERROR      NO\n         EX    R4,GPACK    PACK THE SYSIN CARD INTO WORKFLD1\n         B     GBUILD      INSERT KEY INTO TABLE\nGEXCMPR  EQU   *           COMPARE THE LOWER & UPPER SYSIN CARDS\nGCOMPR   CLC   INCARD,INCARD1    COMPARE INCARD AND INCARD1\n         BH    GERROR      EVEN NUMBERED SYSIN IS LESS THAN ODD ONE\n         BE    BKEYREAD     IF EQUAL READ IN A NEW PAIR OF SYSIN CARDS\n         AP    WORKFLD1,PACKONE ADD 1 TO INCREMENT NEXT GENERATED SYSIN\n         OI    WORKFLD1+7,X'0F' CHANGE SIGN 1/2-BYTE FROM C BACK TO F\n         SLL   R4,4  SHIFT OVER A 1/2-BYTE TO ADJUST LENGTH OF UNPK\n         EX    R4,GUNPK   EXECUTE UNPK TO MOVE GENERATED KEY TO INCARD\n         SRL   R4,4        RESTORE R4\n         AP    RCOUNT,PACKONE    ADD 1 TO NO OF SYSINS GENERATED\n         B     GBUILD      CONTINUE BUILDING TABLE\n*\nGPACK    PACK  WORKFLD1,INCARD(1)   PACK SYSIN CARD INTO WORKFLD1\nGUNPK    UNPK  INCARD(1),WORKFLD1   UNPACK WORKFLD1 BACK INTO INCARD\n         SPACE 2\n*   BUILD SYSIN TABLE FOR T AND G OPTIONS\nTLOGSYS  B    TLOGSYSE  NOP ON 'T' LOGIC\n         BAL  GOREG,GETCARD    GET A CARD-R1 CONTAINS ADDR OF THE CARD\nGBUILD   MVC  0(20,R7),INCARD  MVE SYSIN CARD TO TABLE-LENGTH ADJUSTED\nGBUILD2  MVC  20(4,R7),LOWVALUE ZERO OUT COUNT FOR THIS KEY-DISPL ADJ\n         AR   R7,R5       INCREMENT R7 TO POINT TO NEXT ENTRY IN TABLE\n*  R5 WAS LOADED WITH THE CONTENTS OF R4 + 5 AT CONTINPR\n         XI   PEVENODD,X'01'\nPZEROBR  NOP  PZEROBR2   CHANGED TO BZ ON P OPT SO ADD IS DONE ON ODDS\n         AP   COMPCNT,COUNT     COMPCNT=MAX NO OF KEYS TO BE SELECTED\nPZEROBR2 CP   RCOUNT,INLRECL    HAVE MAXIMUM NO OF SYSIN CRDS BEEN READ\n         BE   ENDKEYS        YES-GO TO END-OF-SYSIN ROUTINE\nGBLDBR   NOP  GEXCMPR CHANGED TO B ON G KEY-GENERATE NEW SYSIN RECORD\n         B    TLOGSYS        NO READ IN ADDITIONAL CARDS\nTLOGSYSE EQU  *       COMES HERE ON THE END OF SYSIN\n         TITLE 'READ AND PROCESS SYSIN FILE FOR V OPTION'\n*        THE FIRST SYSIN RECORD MUST BE OF THE FORMAT:\n*          VOL=VOLSER,VOLSE*,...,VOL* WHERE THE ASTERISK ALLOWS GENERIC\n*                        VOLUME NAMES. UP TO 10 SPECIFICATIONS ALLOWED.\n*        THE FOLLOWING SYSIN RECORD MUST HAVE THE FORMAT:\n*        DSN\n*        DSNAM*\n*        PDS(MEMBER)\n*        PDSNAM*(MEMBER)\n*        PDS(MEMB*)\n*        PDSNAM*(MEMB*)\n*        %DSNAM*(MEMB*)\n*        %DSN+++(MEMB*)\n*        !ABC!(MEMB*)\n*            WHERE MEMBER MAY OR MAY NOT BE SPECIFIED AND THE MEMBER\n*            NAME CAN BE GENERIC. DSN MUST BE SPECIFIED. UP TO 10\n*            DSN(MEMB) RECORDS ALLOWED.\n*            3 WILDCARD SPECIFICATIONS ON THE DSN ARE ALLOWED:\n*            % - IN FIRST POSITION OF DSN INDICATES ACCEPT ALL\n*                HIGH ORDER QUALIFIERS AS AUTOMATIC MATCH.\n*            + - ANY STRING OF +'S ANYWHERE IN THE THE DSN\n*                ACCEPT ANY CHARACTERS WHEREVER THE + APPEARS AS MATCH\n*            ! - SEARCH ANYWH IN DSCB FOR THE STRING ENCLOSED IN THE !\n*                DELIMITERS.\n*\n*        THE VOL= RECORD SHOULD BE CODED SO THAT NO VOLSER SPECIFICATON\n*        SUBSUMES ANOTHER TO AVOID DUPLICATE VTOC SEARCHES. E.G.\n*        VOL=HRSHR*,HRSHR5 SHOULD NOT BE CODED.\n*        IF THE FIRST RECORD DOES NOT BEGIN WITH VOL= IN COL 1 THEN\n*         IT IS ASSUMED THAT A CATALOG SEARCH IS BEING PERFORMED AND\n*         AND ALL THE SYSIN RECORDS ARE DSN RECORDS.\n*         IN THIS CASE, THE WILDCARD SPECIFICATIONS % AND ! ARE NOT\n*         VALID AND ANY DSN RECORD CONTAINING THEM WILL BE IGNORED.\n*         THE + AND * WILDCARDS ARE OK EXCEPT THAT THEY MAY NOT APPEAR\n*         IN THE THE HIGH ORDER QUALIFIER OF THE DSN. MEMBER NAMES\n*         MAY BE SPECIFIED. THE SYSTEM SEARCHES THE CATALOGS IN SYSTEM\n*         DEFAULT ORDER. ONCE THE CATALOG SEARCH RETURNS A VOLSER FOR A\n*         DSN, THAT DSN AND VOLSER ARE USED TO OBTAIN THE REQUIRED INFO\n*         FROM THE VTOC/DIRECTORY. CATALOGED TAPE DATASETS MAY BE\n*         SPECIFIED, BUT SHOULD NOT BE\n*         USED IN ATTACHED HFSELECT SUBTASKS IF YOUR INSTALLATION\n*         REQUIRES JOB SETUPS FOR TAPE JOBS.\n*        THE REMAINING SYSIN RECORD SHOUD BE SORTED ON DSN (WITH GENERC\n*        DSN PRECEEDING FULL DSNS WITH THE SAME PREFIX) AND MEMBER NAME\n*        TO AVOID MULTIPLE DIRECTORY SEARCHES OF PDSS.\n*        E.G. *(QRST),ABC*,ABC(XYZ),ABC(ZZZ),ABD\n*\n*        THE SYSIN RECORDS ARE STORED IN 2 TABLES:\n*        THE VOLSER TABLE CONSISTS OF UP TO 10 VOLSER ENTRIES 7 BYTES\n*        LONG WHERE THE FIRST BYTE IS EITHER X'00' OR X'80' WHICH\n*        INDICATES THE LAST VOLSER IN THE TABLE\n*\n*        THE DSN(MEMBER) TABLE CONSITS OF UP TO 11 ENTRIES (ONLY 10\n*        NON-ZERO ALLOWED) IN THE FOLLOWING FORMAT-\n*        BYTES 1-4   MATCH COUNT\n*              5     DSN LENGTH IN BINARY\n*              6     MEMBER LENGTH IN BINARY\n*              7-50  DSN (FIRST BYTE BLANK IF !,%-WILDCARD USED)\n*              51-58 MEMBER NAME\n*              59    X'FF' LAST ELEMENT AFTER SORT\n*              60-79 NULL\n*              80    !,%-WILDCARD INDICATOR\n*        THE LENGTH FIELD MAY CONTAIN\n*              X'00' IN DSN FIELD THIS INDICATES END OF SYSIN\n*                    IN MEMBER NAME FIELD INDICATES NO PDS MEMBERS\n*                       ARE TO BE PROCESSED ONLY, ONLY DSNS.\n*              X'FF' NO COMPARISONS ARE NECESSARY, ALL DSNS/MEMBERS ARE\n*                    TO BE SELECTED AS MATCHED\n*              X'ACTUAL LENGTH' A GENERIC DSN/MEMB OR ! HAS BEEN SPECIF\n*                     AND THE COMPARE IS TO DONE ON THE ACTUAL LEN ONLY\n*              X'2C' OR X'08' FULL DSN (LENGTH 44) OR FULL MEMBER NAME\n*                     (8) LENGTH FOR NON-GENERIC COMPARE.\nVTOCLOG  B     GETINPUT             SET TO NOP IF V OPTION REQUESTED\n         MVC   MSG36OUT(6),=CL6'11' LIMIT TO 1 VOL= REC AND 10 DSN(MEM)\nVTOCLOG1 L     R7,=A(VOLTABL)       PLACE ADDR OF SYSIN TABLE IN R7\nVLOGSYS  L     R1,AVSYSIN           GET A VSYSIN RECORD\n         GET   (R1)\nVPARMBR  B     GETVPARM        SET TO BR IF VSYSIN DD CODED\nNOVPARM  AP    RCOUNT,PACKONE\n         MVC   6(72,R7),0(R1)  MOVE RECORD TO TABLE - 1ST 6 BYTES RESER\n         MVI   79(R7),BLANK1   BLANK OUT WILDCARD COL\n         CP    RCOUNT,=P'11'      HAVE WE REACHED TABLE LIMIT\n         BH    ENDKEYS                      YES\n*@MK1    MVC   MSG65LBL,0(R1)     NO - GET READY TO PRINT SYSIN KEY\n*@MK1    LNKMSG 97,DATA=MSG65LBL    PRINT\n         L     R15,=A(MSG65LBL)                                    @MK1\n         MVC   0(L'MSG65LBL,R15),0(R1) NO-READY TO PRINT SYSIN KEY @MK1\n         LNKMSG 97,DATA=(R15,L'MSG65LBL)     PRINT                 @MK1\n         CP    RCOUNT,PACKONE     IS THIS THE FIRST SYSIN RECORD (VOL=)\n         BE    VOLREC          YES- GO TO VOL= SYSIN REC PROCESSING\nVTOCLOG2 AP    COMPCNT,COUNT  NO- MAX NUMBER OF RECORDS TO BE SELECTED\n         CLI   6(R7),C'%'     WILDCARD QUALIFIER OPTION - %\n         BE    VWC            YES\n         CLI   6(R7),C'!'     WILDCARD QUALIFIER OPTION - !\n         BE    VWC2      YES -DONT PUT INDICATOR IN REC UNTIL 2ND FOUND\nVCONTIN  L     R15,=A(ASTPAREN)  NO- GET TRT TABLE WITH '*','(',')','!'\n         SR    R1,R1             ZERO OUT R1 FOR TRT\n         TRT   6(54,R7),0(R15)   EXAMINE SYSIN RECORD\n         BZ    DSNONLY BR IF DID NOT FIND *,(,) OR!,IE. NON-GENERIC DSN\n         ST    R1,SAVEADDR  SAVE ADDR OF 1ST *,(,),!\n         CLM   R2,1,=C'('  DID TRT STOP AT (; I.E. MEMBER WAS SPECIFIED\n         BNE   DSNGENRC    NO- A GENERIC DSN WAS SPECIFIED FIRST\n         MVI   4(R7),X'2C' YES- SET DSN LEN TO 44 I.E. FULL NON-GEN DSN\nMEMTRT   TRT   1(9,R1),0(R15)  STARTING AFTER '(' EXAMINE MEMBER NAME\n         BZ    INVALVKY     ERROR- DID NOT FIND * OR )\n         CLM   R2,1,=C')'   DID WE FIND AN ')'\n         BNE   MEMGENRC      NO - IT MUST BE A GENERIC MEMBER NAME\n         MVI   5(R7),X'08'   YES- SET MEMBER NAME LEN TO 8;NON-GENERIC\n         L     R2,SAVEADDR   GET ADDR OF '('\n         SR    R1,R2         CALCULATE ACTUAL LENGTH OF MEMBER NAME +1\n         C     R1,FULL1      WAS A MEMBER NAME SPECIFIED\n         BE    INVALVKY      NO - ERROR\nMVESYSIN STC   R1,SETDSN+1  SET LENGTH TO BLANK OUT '(MNAME)'\n         BCTR  R1,0         SUBTRACT 1 FOR ACTUAL LENGTH\n         C     R1,FULL8     IS MEMBER NAME GREATER THAN 8\n         BH    INVALVKY            YES- ERROR\n         BCTR  R1,0          NO -SUBTRACT 1 TO SET MVC LENGTH\n         STC   R1,MVEMEMB+1      STORE LEN-1 IN MVC\n         MVC   MEMBHOLD,1(R2)   MOVE MEMBER NAME INTO HOLD AREA\nSETDSN   MVC   0(0,R2),MSGSPACE SET UP DSN PROPER-BLANK FROM '(' TO ')'\nMVEMEMB  MVC   50(0,R7),MEMBHOLD MV MEMBER NAME INTO COLUMN 51 OF TABLE\n         B     NXTVKEY     GET THE NEXT KEY\n         SPACE 3\nVWC      MVI   79(R7),C'%'   SET WILDCARD INDICATOR FLAG\nVWC2     MVI   6(R7),BLANK1  BLANK OUT % OR !, SO IT WILL SORT LOW\n*        AND GIVE ALL HIGH ORDER QUALIFIERS\n         B     VCONTIN\n         SPACE 3\nDSNONLY  MVI   4(R7),X'2C'    SET DSN LENGTH TO 44\nNXTVKEY  LA    R7,80(R7)     POINT TO NEXT TABLE ELEMENT\n         B     VLOGSYS        READ NEXT SYSIN REC\n         SPACE 3\nMEMGENRC MVI   1(R1),BLANK1   BLANK OUT THE ')'\n         CLM   R2,1,=C'*'     IS THE DELIMITER '*' FOR GENERIC MEMBER\n         BNE   INVALVKY               NO -ERROR\n         L     R2,SAVEADDR    GET ADDR OF '('\n         SR    R1,R2          CALCULATE GENERIC MEMBER NAME +1\n         BCTR  R1,0           SUBTRACT 1\n         LTR   R1,R1       IS MEMBER LENGTH =0 I.E. WAS (*) REQUESTED\n         BZ    ALLMEM     YES -PROCESS EVERY MEMBER IN THE PDS AS MATCH\n         STC   R1,5(R7)   NO- PLACE ACTUAL MEMBER NAME LENGTH IN TABLE\n         LA    R1,1(R1)   ADD 1 TO ACTUAL LENGTH FOR BLANK-OUT RTN\n         B     MVESYSIN   WHICH WILL BLANK-OUT '(MNAME*'\n         SPACE 3\nALLMEM   MVI   5(R7),X'FF' SET TABL LEN TO X'FF' - INDICATES ALL MEMBER\n         MVC   0(2,R2),MSGSPACE  BLNK OUT '(*';NO NEED TO MOVE MEM NAME\n         B     NXTVKEY\n         SPACE 3\nDSNGENRC MVI   0(R1),BLANK1   BLANK OUT THE '*' OR '!' IN GENERIC DSN\n         CLM   R2,1,=C'*'     WAS DELIMITER = *\n         BE    GENRCOK        YES - OK\n         CLM   R2,1,=C'!'     WAS DELIMITER = !\n         BNE   INVALVKY           NO - ERROR\n         CLI   6(R7),BLANK1   IS THIS THE FIRST BYTE BLANK (OR WAS !)\n         BNE   INVALVKY       NO - ERROR\n         MVI   79(R7),C'!'    YES PLACE ! IN WILDCARD INDICATOR\nGENRCOK  LA    R2,6(R7)        PLACE COL 6 ADDR OF TABLE ELEMENT IN R2\n         SR    R1,R2        GET ACTUAL LENGTH OF GENERIC DSN\n         BZ    ALLDSN       IS LEN=0 I.E.  ALL DSNS ARE REQUESTED\n         STC   R1,4(R7)     NO- STORE ACTAL GENERIC DSN LEN IN TABLE\nCHKMEM   L     R1,SAVEADDR    GET ADDRESS OF '*' OR '!' IN GENERIC DSN\n         LA    R1,1(R1)  POINT 1 BEYOND THE * OR '!' TO SEE IF MEMB REQ\n         ST    R1,SAVEADDR   BUMP UP SAVEADDR BY 1 TO POINT TO '('\n         CLI   0(R1),C'('    IS '*' OR '!' FOLLOWED BY '('\n         BE    MEMTRT        YES - A MEMBER HAS BEEN SPECIFIED\n         B     NXTVKEY       NO- GET NEXT KEY (IGNORE BEYOND *)\n         SPACE 2\nALLDSN   MVI   4(R7),X'FF'   SET DSN LEN TO 44 TO INDICATE ALL DSNS\n         B     CHKMEM           CHECK FOR MEMBER NAME\n         SPACE 3\nVOLREC   CLC   6(4,R7),=C'VOL='   IS 'VOL=' FIRST 4 CHARS OF 1ST SYSIN\n         BNE   NOVOLS                    NO - CATALOG ACCESS\n         L     R15,=A(COMMABLK)   YES- GET TRT TABLE FOR ' ' AND ','\n         L     R8,=A(VOLSER)    LOAD R8 WITH VOLSER TABLE ADDR\n         LA    R7,10(R7)        POINT BEYOND VOL=\nVOLLOOP  TRT   0(7,R7),0(R15)   FIND THE FIRST ' ' OR ','\n         BZ    INVALVKY         NONE FOUND -ERROR\n         SR    R1,R7            GET VOLSER LENGTH\n         BZ    INVALVKY       LEN=0 NOTHING ENTERED - ERROR\n         BCTR  R1,0             SUBTRACT 1 FOR MVC\n         STC   R1,MVVOLSER+1    SET MOVE LENGTH FOR VOLSER\nMVVOLSER MVC   1(0,R8),0(R7)    MOVE VOLSER INTO TABLE\n         CLM   R2,1,=C' '      WAS ' '  THE DELIMITER\n         BNE   VOLNXT            NO - GET THE NEXT VOLSER\n         MVI   0(R8),X'80'      YES- SET END OF TABLE FLAG\n         B     VTOCLOG1\n         SPACE 2\nVOLNXT   LA    R8,7(R8)         POINT TO NEXT VOLSER TABLE ENTRY\n         LA    R7,2(R1,R7)       POINT TO VOLSER ON VOL= SYSIN REC\n         AP    VOLSERCT,PACKONE    ADD 1 TO VOLSER COUNT\n         CP    VOLSERCT,=P'10'     LIMIT TO 10 VOLSERS\n         BH    VTOCLOG1\n         B     VOLLOOP            PROCESS NEXT VOLSER\n         SPACE 2\nGETVPARM MVI   VPARMBR+1,SETNOP RESET NOP- ONLY 1 TIME THRU HERE\n         CLI   0(R1),X'7D'    IS 'QUOTE' FIRST CHAR OF 1SR VSYSIN CARD\n         BNE   NOVPARM        NO- NO SUBTASKING REQUESTED\n         L     R7,=A(VPARM)   GET PARM AREA ADDR\n         MVC   2(79,R7),1(R1) MOVE PARM IN (MINUS LEADING QUOTE)\n*              LEAVE FIRST 2 BYTE EMPTY- WILL MOVE PARM LENGTH IN THERE\n         L     R15,=A(VPARMTAB)  GET TRANSLATE TABLE TO LOOK FOR QUOTE\n         TRT   2(79,R7),0(R15)   FIND QUOTE\n         BZ    INVALVKY         NO END QUOTE -ERROR\n         CLI   2(R7),C'V'       RECURSIVE V OPTION NOT ALLOWED\n         BE    INVALVKY\n         MVI   0(R1),C' '       BLANK OUT LAST QUOTE\n         LA    R2,2(R7)         GET BEGIN ADDR OF PARM\n         SR    R1,R2            GET PARM LENGTH\n*        BZ    INVALVKY         0 LENGTH NOT ALLOWED<=== 0 OK\n         STH   R1,0(R7)         STORE IN FIRST 2 BYTES OF PARM AREA\n*@MK1    MVC   MSG65LBL,0(R2)   MOVE PARM TO PRINT AREA\n*@MK1    LNKMSG 97,DATA=MSG65LBL  PRINT IT\n         L     R15,=A(MSG65LBL)                                    @MK1\n         MVC   0(L'MSG65LBL,R15),0(R2) NO-READY TO PRINT SYSIN KEY @MK1\n         LNKMSG 97,DATA=(R15,L'MSG65LBL)     PRINT                 @MK1\n         B     VTOCLOG1        CONTINUE PROCESSING REST OF VSYSIN\nNOVOLS   AP    RCOUNT,PACKONE  ADD 1 TO CARDS READ (PHONY VOL= CARD)\n         B     VTOCLOG2\n         TITLE 'READ INPUT FILE'\nGETINPUT NOP   STARTPRC   GET NEXT INPUT RECORD & CK KEY\n*  SET GETINPUT TO BRANCH WHEN NOINPUT CODED IN X0 EXIT\n         L     R1,DCBADDR         LOAD ADDR OF ISAM/INFIL INTO R1\n         SPACE 1\nGETVTOC  B     GETLIB     SET TO NOP ON V OPTION\n         L     R15,=A(READDSCB)\n         BALR  R14,R15    PERFORM READ VTOC RTN TO EOJ\n         C     R15,FULL1  0=NORMAL END, 1=ERROR, 2=COUNT SATISFIED\n         BL    VMSGPT     PRINT MSGS ON NORMAL END\n         BH    VMSGSAT\n         MVI   VMSGNOP+1,SETNOP  ON V OPT ERR, FIRST PRT NORMAL MSGS\n         B     VMSGPT\n         SPACE 2\nGETLIB   B     BR2VSGET           CHANGED TO NOP ON LIBRARY INPUT FILE\n         L     R15,=A(LIBCSECT)   LOAD LIBRARY PROCESSING CSECT ADDR\n         BALR  R14,R15\n         C     R15,FULL1   IS THIS THE LAST REC OF THE LIBRARY (RC=1)\n         BL    STOREADR           NO-CONTINUE NORMALLY         (RC=0)\n         BE    ENDINPUT           YES\n***      B     LIBOUTER           RC=2 STOW ERROR ON LIBOUT AT EOF\n         BAL   GOREG,LIBOTEOJ  RC>=4 STOW ERROR ON LIBOUT(AT EOF ONLY)\n         B      ENDINPUT       OR ON SYNADERR ON LIBFILE\n         SPACE 1\nBR2VSGET NOP   VSAMGET            CHANGED TO B ON VSAM INPUT FILE\n         SPACE 2\n         GET   (R1)               R1 HAS ADDR OF REC ON RETURN\n         SPACE 2\nSTOREADR ST    R1,PUTADDR         SAVE ADDR OF REC IN PUTADDR FOR PUT\nSAMETAPE NOP   GETCARD            CHANGED TO BAL ON S513 BOMB ON 'A'\nEXITBRI1 B     NOEXITI1   CHANGED TO NOP IF EXIT POINT I1 REQUESTED\n         L     R15,=A(EXTEPAI1)   GET EXIT I1 ENTRY POINT\n         L     R15,0(R15)\n         LA    R1,PUTADDR         SET UP PARAMETER LIST\n         BALR  R14,R15            EXECUTE I1 EXIT\n         C     R15,FULL4          CHECK RETURN CODE\n         BL    NOEXITI1 RC=0   CONTINUE NORMAL PROCESSING\n         BE    GETINPUT RC=4  DELETE THIS RECORD-GET NEW SYSUT1\n         MVI   EXITBRI1+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT\nNOEXITI1 EQU   *\n         L     R1,PUTADDR   RESTORE R1 ON RETURN FROM ABOVE BAL ON S513\n*           AND FOR VSAM AND TAPELABL PROCESSING\n         AP    PASSCT,PACKONE     INCREMENT INPUT COUNTER\n         AP    ENDCT,PACKONE    INCREMENT TOTAL RECS READ\n         CP    ENDCT,BEGIN      HAVE BEGIN NO OF RECS BEEN READ(B=)\nNOPBEQU  BNH   AGETCRD1   NO-GET NEW INPUT REC;NOP FOR VSAMKEY\nDBPUTOUT NOP   DPUTREC          CHANGED TO BR ON D KEY\n         CP    ENDCT,END        HAS END BEEN REACHED(E=)\nSETBRONV BNH   STARTPRC    NO-SET TO BR ON V= AFTER 1ST TIME THRU\n*            ALSO SET TO BR ON R OPT WITH NON-RANDOM SYSIN\n         MVI   ENDFLAG,X'51'   SET E= FLAG FOR MSG 81\nE@EQUBR  NOP   PUTOUT    SET TO BR ON E OPT WITH @-CHG AFTER E= SATISF\nKEEQNOP  B     ENDINPUT         GO TO EOJ; SET TO NOP ON K OPT\n         MVI   KEEQUAL+1,SETBR  ON K OPT IF E= ALLOW PROCESSING TO\n         B     STARTPRC  CONTINUE UNTIL NEW GRP ENCOUNTERED(KEY CHG)\n         SPACE 1\nVSAMGET  B     VSMPOINT  SET TO NOP ON VSAMKEY TO MOD KEYLEN,NIX SYSUT3\n         MVI   VSAMGET+1,SETBR   RESET TO B AFTER FIRST TIME THRU\n         MVI   VSMPOINT+1,SETNOP SET NOP TO POINT TO PROPER REC ON KEY\n         LR    R2,R1      GET RPL ADDR\n         MODCB RPL=(R2),KEYLEN=(*,VSAMKEYL)  PUT CORRECT KEYLEN IN RPL\n         LR    R1,R2      PUT RPL ADDR BACK IN R1\n         MVI   BRPTOUT2+1,SETBR  DISALLOW CREATION OF SYSUT3 FILE\nVSMPOINT B     NOTVSKEY  SET TO NOP ON VSAMKEY\n         MVI   VSMPOINT+1,SETBR RESET TO B FOR SEQ UNTIL NEW SYSIN READ\n         POINT RPL=(R1)  POSITION TO REC WITH NEXT KEY ON VSAMKEY\n         LTR   R15,R15\n         BNZ   VSAMERR\nNOTVSKEY GET   RPL=(R1)  GET NEXT PHYS/SEQ VSAM REC R1=ADDR OF RPL\n         LTR   R15,R15   NEXT PHYSICAL RECORD FOR VSAMFILE\n         BNZ   VSAMERR   NEXT LOGICAL SEQ RECORD WITH VSAMKEY\n         LR    R2,R1    PUT RPL ADDR IN R2\n*        GET THE CURRENT RBA AND THE LRECL\n         SHOWCB RPL=(R2),AREA=RBA,LENGTH=8,FIELDS=(RBA,RECLEN)\n         LR    R1,R2      PUT RPL ADDR BACK IN R1\n*        MOVE THE VSAM RECORD TO A WORKAREA, AFTER PLACING AN RDW ON IT\nVSMOVREC NOP   VSKEYNOP  SET TO BR IF VSAMOUT CODED (BYPASS MOVE OF REC\n*              SINCE AN RDW IS NOT NEEDED FOR WRITING A VSAM REC)\n         L     R14,PUTADDR       PUT SENDING FLD ADR IN R14\n         L     R1,=A(VSRECADR)   GET ADDR OF GETMAINED WORKAREA\n         L     R1,0(R1)\n         ST    R1,PUTADDR  REPLACE INPUT REC ADR WITH ADR OF MODIF REC\n         L     R0,VSAMRECL       GET LRECL OF VSAM REC\n         A     R0,FULL4         ADD 4 TO LRECL FOR APPENDED RDW\n         STH   R0,0(R1)     PLACE RDW INTO REC WORKAREA\n         LA    R0,4(R1)     POINT BEYOND RDW & PLACE WKAREA ADR IN R0\n         L     R1,VSAMRECL  GET ORIGINAL LENGTH AGAIN INTO R1\n         LR    R15,R1                                 AND R15\n         MVCL  R0,R14       MOVE RECORD\n         LR    R1,R2      PUT RPL ADDR BACK IN R1\n         SPACE 1\nVSKEYNOP B     SAMETAPE  RETURN TO NORMAL GET ROUTINE, NOP ON VSAMKEY\n         SPACE 2\n         CLC   SAVERBA,RBA  COMPARE TO PREVIOUS RBA\n         BE    NOTVSKEY     ITS THE SAME RECORD- GET NEW RECORD\n         MVC   SAVERBA,RBA  MOVE IN NEW RECORD RBA\n         B     SAMETAPE\n         TITLE 'SET UP INPUT KEY AND BRANCH TO PROCESSING ROUTINE'\nSTARTPRC EQU   *\nELOGIC   NOP   BYPTRNSL  CHANGED TO B ON E OPT TO BYP SETTING KEYS\nRANDMOPT NOP   RNDMROUT  CHANGED TO B ON R KEY IF RANDOM OPTION\nREXTLOG  NOP   REXTLOG1  CHANGED TO B ON R KEY IF ONLY 1 PARM PRESENT\nRLOGIC   NOP   RLOGIC1   CHANGED TO BRANCH ON R KEY\n         SPACE 1\n*              R3 = ADDR OF KEYAREA, R1 = ADDR OF INFIL RECORD\n         L     R1,PUTADDR      LOAD R1 WITH REC ADDR\nVENTRY   A     R1,POSLENS+4    ADD DISP TO REC ADDR;ENTRY PT FOR V OPT\nSET1     MVC   0(0,R3),0(R1)   LENGTH FLDS SET IN SETPARM\n         SPACE 1\nCNVRTBR1 B     BR1     SET TO NOP IF CONVERT FILE PRESENT\n         L     R15,=A(CNVRTABL)   GET CONVERT TABLE\nSETTR1   TR    0(0,R1),0(R15)     CONVERT FIRST KEY -LENGTH SET\n         SPACE 1\nBR1      B     KEYSET             NOP IF TWO OR THREE CHAR GROUPS\n         A     R1,POSDISPS     ADD P2   TO REC ADDR\nSET2     MVC   0(0,R3),0(R1)   LENGTH & DISPLACE FLDS SET IN SETPARM\n         SPACE 1\nCNVRTBR2 B     BR2     SET TO NOP IF CONVERT FILE PRESENT & 2 KEYS\nSETTR2   TR    0(0,R1),0(R15)     CONVERT 2ND KEY -LENGTH SET\n         SPACE 1\nBR2      B     KEYSET             NOP IF THREE CHAR GROUPS IN KEY\n         A     R1,POSDISPS+4   ADD P3   TO REC ADDR\nSET3     MVC   0(0,R3),0(R1)   LENGTH & DISPLACE FLDS SET IN SETPARM\n         SPACE 1\nCNVRTBR3 B     KEYSET  SET TO NOP IF CONVERT FILE PRESENT & 3 KEYS\nSETTR3   TR    0(0,R1),0(R15)     CONVERT 3RD KEY -LENGTH SET\n         SPACE 1\nKEYSET   B     BYPTRNSL  CHANGED TO NOP WHEN Y= OPTION REQUESTED\n         L     R15,=A(TRNSTAB5)  LOAD THE ADDRESS OF TRANSLATE5\nYTRNSLT1 TR    0(0,R3),0(R15)   TRANSLATE THE SYSUT1 KEY\nBYPTRNSL EQU   *\nFLOGIC   NOP   FLOGIC1   CHANGED TO BRANCH ON F KEY\nTLOGIC   NOP   TLOGIC1   CHANGED TO BRANCH ON T KEY\n         SPACE 1\nNOTEST   B     OLOGIC    CHANGED TO NOP IF CLASS REQUESTED\n         MVI   OUTPTKEY,C'N'  RESET OUTPUT FLAG\nGOLOWV   NOP   LOWVTST        SET TO BRANCH IF LOW VALUE TEST REQ\nGOHIGHV  NOP   HIGHVTST       SET TO BRANCH IF HIGH VALUE TEST REQ\nGOALPHB  NOP   ALPHBTST       SET TO BRANCH IF ALPHABETIC REQUESTED\nGONUMER  NOP   NUMERTST       SET TO BRANCH IF NUMERIC REQUESTED\nGOALPHN  NOP   ALPHNTST       SET TO BRANCH IF ALPHANUMER REQUESTED\nGOPACK   NOP   PACKTST    SET TO BRANCH IF PACK TEST REQUESTED OR P=\nGONEQUAL NOP   NEQUTEST      SET TO BRANCH IF N= OPTION REQUESTED\n         SPACE 1\nOUTPTTST EQU   *\n         CLI   OUTPTKEY,C'Y'   WAS A MATCH MADE ON CLASS TEST\nMAINLIN1 B     ENTRYPT   RETURN TO MAINLINE PROCESSING  NOP FOR O LOGIC\n         B     ENTRYPT2        RETURN TO O LOGIC MAINLINE PROCESSING\n         SPACE 1\nOLOGIC   NOP   OLOGIC1   CHANGED TO BRANCH ON O KEY\n         TITLE 'SINGLE AND MULTIPLE KEY LOGIC (A,D,S,M) PROCESSING'\nCOMPKEY  NOP   COMPLKEY          CHANGED TO B ON L SUBOPTION\nCOMPSKEY CLC   0(0,R3),INCARD\nENTRYPT  EQU   *               ENTRY POINT FROM CLASS TEST ROUTINE\nDKEYEQ   NOP   DWRITE    SET TO BE ON D KEY, SET TO BNE ON DN\n*        SET TO BH ON D OPT N,P=>. SET TO BL ON D OPT N,P=<\nDKEYNE   NOP   GETINPUT  SET TO B ON D KEY\nBR6      BE    PUTOUT    CHANGED TO BNE ON SN,BL ON MN,BNE ON 'AN'\n*        SET TO BH ON S OPT N,P=>. SET TO BL ON S OPT N,P=<\nBR4      BH    NEXTKEY   NOPED ON S OR SN OR A OPTIONS\nAGETCRD1 NOP   GETCARD   CHANGED TO BAL ON A OPTION (USING R8)\nSOPTVSAM NOP   ENDINPUT  CHG TO BR ON S OPT WITH VSAMKEY INPUT FILE\n*                        END PROCESSING ON NOMATCH\n         SPACE 1\nVOPTREJ  NOP   VOPTRET2  SET TO B ON V OPT, RECORD REJECTED\nBRPTOUT2 B     GETINPUT  NOP TO OUTPUT NON-SELECTED RECORDS\nSETBEQBR NOP   GETINPUT      SET TO ON 1ST PASS OF D OPTION\nE@CHGBR  NOP   PUTOUT     SET TO B ON E OPT WITH @ CHG-KEY\n*        ALL RECORDS ARE PUT OUT TO SYSUT2 (NON-SELECTED AND B=)\n         MVI   SYSUTX,C'3'\nEXITBRO2 B     NOEXITO2   CHANGED TO NOP IF EXIT POINT O2 REQUESTED\n         L     R15,=A(EXTEPAO2)   GET EXIT O2 ENTRY POINT\n         L     R15,0(R15)\n         LA    R1,PUTADDR         SET UP PARAMETER LIST\n         BALR  R14,R15            EXECUTE O2 EXIT\n         C     R15,FULL4          CHECK RETURN CODE\n         BL    NOEXITO2 RC=0   CONTINUE NORMAL PROCESSING\n         BE    GETINPUT RC=4  DELETE THIS RECORD-GET NEW SYSUT1\n         MVI   EXITBRO2+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT\nNOEXITO2 EQU   *\n         L     R2,DCBADDR    LOAD INPUT DCB ADDR INTO R2 FOR PRINT LINK\n         L     R1,AOUTFIL2   LOAD OUTPUT DCB ADDR INTO R1\n         L     R0,PUTADDR  LOAD ADDR OF ISAM/INFIL REC AREA INTO R0\nSKIPPUT3 NOP   PRNT3BAL   CHANGED TO BRANCH IF SYSUT3 IS SYSOUT\n         PUT   (R1),(R0)   WRITE OUTFIL2 FROM INPUT REC AREA\nPRNT3BAL NOP   PRINTLK    CHANGED TO BAL IF SYSUT3 IS SYSOUT\n         AP    OUTCT2,PACKONE\n         B     GETINPUT  BRANCH TO READ ANOTHER RECORD\n         SPACE 1\nPUTOUT   EQU   *\nVOPTBR   NOP   VOPTRET SET TO B,RTURN TO V OPTION PROCESSING\n         CP    OUTCT,COUNT\nMNSTOP   NOP   BRPTOUT2           SET TO BE ON MN KEY\n         BAL   GOREG,PUTFILE      WRITE OUT LAST REC READ\nMERGEBAL NOP   MERGERTN    SET TO BAL GOREG,MERGERTN FOR MERGE FILE\n         CP    OUTCT,COUNT        COMPARE PARM COUNT TO RECORD COUNT\nMNPUTBR  BL    GETINPUT  ON MN CHANGE TO B,ON 'A' OPT CHANGE TO NOP\n         MVC   MSG4MAX,=C'MAX'    MAX FOR A KEY REACHED\nBR5A     NOP   ENDINPUT  SET TO BRANCH FOR EOJ ON MN\n         BAL   GOREG,KEYREPT      FORMAT & PRINT\nBR5      B     ENDKEYS   IF M OR MN NOP SO MORE KEYS ARE READ\n         BAL   GOREG,GETCARD\n         B     GETINPUT\nNEXTKEY  EQU   *                  THIS ROUTINE ONLY FOR KEYTYPE= M\n         SP    PASSCT,PACKONE\n         BAL   GOREG,KEYREPT      PUT OUT MSG FOR THIS KEY\n         AP    PASSCT,PACKONE\n         BAL   GOREG,GETCARD      GET NEW SYSIN KEY\n         B     NOTEST  GO BACK TO COMPARE (CHG FROM COMPKEY FOR VP)\n         SPACE 1\nVOPTRET  L     R15,=A(VPUTRET)    RETURN TO V OPTION CSECT\n         L     R1,=A(SAVEAREQ)    PASS BASE ADDR BACK TO V OPT CSECT\n         BR    R15\n         SPACE 1\nVOPTRET2 L     R15,=A(VPUTREJ)    RETURN TO V OPTION CSECT, REC REJ\n         L     R1,=A(SAVEAREQ)    PASS BASE ADDR BACK TO V OPT CSECT\n         BR    R15\n         SPACE 1\nMERGERTN L     R15,=A(MERGSECT)     PERFORM MERGE RTN\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   RECFMERR     RC=4\n         BR    GOREG\n         TITLE 'MULTIPLE KEY LOGIC (T) PROCESSING'\nTLOGIC1  L      R15,=A(TSEARCH) LD R15 WITH ADDRESS OF SEARCH ROUTINE\n         BALR   R14,R15   BRANCH TO THE CSECT AND SET RETURN ADDRESS\n         LTR    R15,R15    IF R15=0 THEN RECORD KEY HAS BEEN MATCHED\nTLOGNEQ  BNZ    BRPTOUT2   NO MATCH ON THE KEY -CHANGED TO BZ ON 'TN'\n         BAL    GOREG,PUTFILE   THE RECORD HAS MATCHED PUT IT  OUT.\n         CP     OUTCT,COMPCNT     HAS MAX NO OF RECORDS BEEN SELECTED\n         BE     ENDINPUT          YES\n         CP     OUTCT,COUNT    HAS THE DESIRED COUNT BEEN REACHED ON TN\nTLOGNEQ1 B      GETINPUT   NO-GET THE NEXT RECORD,CHANGED TO BL ON TN\n         B      ENDINPUT          THAT'S ALL FOLKS\n         TITLE 'MATCHING A FILE AGAINST ITSELF LOGIC (F,K,Q) PROCESS'\nFLOGIC1  NOP   COMPLKY2     F LOGIC PROCESSING,CHANGED TO B ON L SUBOPT\nCOMPFKEY CLC   KEYAREA,INCARD   COMPARE\nSEQCHK   NOP   SEQMSG2 CHANGED TO BL ON Q KEY-OUT OF SEQ,BH ON QN\nQBOUT2   NOP   QWRITE      CHANGE TO B TO WRITE THE SEQUENCED FILE ON Q\nNOOPONQ  BE    FEQUALKY    BRANCH ON FKEY EQUAL OTHERWISE BREAK IN KEY\n*                          THIS BE CHANGED TO NOP ON Q KEY\nFREQUECY NOP   BR2PRTF      CHANGED TO B ON F,J=0 FREQUENCY REQUEST\nFKQLMOVE NOP   MVCL   CHANGED TO BAL GOREG,MVCL ON FL,QL,KL OPTION\nFMOVE    MVC   INCARD,KEYAREA     MOVE KEY IN RECORD TO KEY AREA\nSEQOK    NOP   GETINPUT           CHANGED TO BRANCH ON Q OPT\n         SPACE 1\nKEEQUAL  NOP   ENDINPUT   CHANGED TO BR ON K OPT WHEN E= SATISFIED\n*        CONTINUE TO PROCESS UNTIL KEY UNEQUAL CONDITION, THEN B TO END\nKKEYSW   B     FCOMPARE           NOOPED ON K KEY  (NOT EQUAL COND)\n         SPACE 1\nKBEQCHK  NOP   KBEQREST  SET TO BRANCH AFTER FIRST TIME THRU\n         MVI   KBEQCHK+1,SETBR   DONE ON FIRST REC PROCESSED BY K OPT\n         CP    BEGIN,PACKZERO  IS B=0 CODED OR DEFAULTED\n         BNE   KNEWGRP   NO B>0-SKIP TILL NEW GRP IS REACHED LOGIC\nKBEQREST MVI   FWRITE+1,SETNOP YES-DOES NOTHING IF B=0;B>0 RESETS WRITE\n         CP    TOTLKEYS,COUNT     IS NUMBER OF GROUPS = TO PARM COUNT\n         BE    ENDINPUT           YES- BRANCH TO END OF FILE PROCESSING\n         B     FKEYNL             NO\n         SPACE 1\nFCOMPARE CP    COMPCNT,COUNT      WAS COUNT SATISFIED\n         BNL   FKEYNL             BRANCH AROUND INCREMENT IF YES\n         AP    KEYLESS,PACKONE    INCREMENT\nFKEYNL   EQU   *\n         BAL   GOREG,PUTFILE\n         AP    TOTLKEYS,PACKONE   ADD 1 TO TOTAL KEY COUNT\n         ZAP   COMPCNT,PACKONE    ZERO & ADD 1 TO KEY COUNT\n         MVI   FKEYMORE+1,SETNOP  RESET TO NO-OP WHEN NEW KEY\n         B     GETINPUT\n         SPACE 1\nFEQUALKY EQU   *                  THE KEY ON PRIOR REC IS THE SAME\n*   AS ON THIS RECORD. CHECK TO SEE IF THE COUNT FOR\n*   A KEY HAS BEEN REACHED. IF COUNT HAS NOT BEEN\n*   REACHED WRITE OUT REC OTHERWISE BYPASS THE REC\n*   AND ADD 1 TO KEYMORE(COUNT OF RECS FOR KEY  EXCEEDED).\n*   BRANCH AROUND FUTURE ADDS FOR THIS KEY AND GET RECORD.\nKEQUAL   NOP   FWRITE              CHANGED TO BRANCH ON K OPTION\n         CP    COMPCNT,COUNT\n         BNL   FKEYMORE            COUNT FOR THIS KEY HAS BEEN REACHED\nFWRITE   NOP   BRPTOUT2  CHG TO BR WHEN B>0 CODED ON K OPTION\n*        TO GET PAST FIRST GRP UNTIL 1ST NONEQUAL THEN CHG BACK TO NOP\n         BAL   GOREG,PUTFILE       COUNT NOT REACHED,WRITE RECORD\n         AP    COMPCNT,PACKONE     ADD 1 TO COUNT FOR KEY\n         B     GETINPUT\n         SPACE 1\nFKEYMORE NOP   BRPTOUT2   CHANGED TO BRANCH WHEN RECS EXCEED PARM COUNT\n         AP    KEYMORE,PACKONE\n         MVI   FKEYMORE+1,SETBR  DONE ONLY ONCE(FOR EACH KEY)\n         B     BRPTOUT2\n         SPACE 2\nBR2PRTF  CP    COMPCNT,PACKZERO  DONT PRINT FREQ BEFORE 1ST KEY KICKED\n         BE    FMOVE\nFREQMOVE MVC   MSG21KEY,INCARD       MOVE IN KEY-LENGTH ADJUSTED\n         ED    MSG21ED,COMPCNT+3     GET FREQ CNT\n         B     OMSG                 PRINT MSG\n         SPACE 2\nKNEWGRP  MVI   FWRITE+1,SETBR SET TO BRANCH AROUND WRITE UNTIL A NEW\n         B     BRPTOUT2   GRP IS FOUND, I.E. WHEN KEY BECOMES UNEQUAL\n         TITLE 'L SUBOPTION PROCESSING-KEY LENGTH UP TO LRECL'\nCOMPLKYV L     R0,PUTADDR    GET ADDR OF INPUT RECORD\n         MVC   DCBADDR2,DCBADDR  MOVE INPUT DCB TO DCBADDR2 FOR RECFM=U\nSYSUTVAR NOP   SYSUTLEN      SET TO B ON VARIABLE SYSUT1 RECS\n         A     R0,POSLENS+4    ADD POSITION DISPLACEMENT TO ADDR\n         ST    R0,LKEYADDR     STORE KEY ADDR FOR CONVERT\nSETSYSIN L     R2,CARDADDR     GET ADDR OF SYSIN RECORD\n         MVC   DCBADDR2,ASYSIN   MOVE SYSIN DCB TO DCBADDR2 FOR RECFM=U\nSYSINVAR NOP   SYSINLEN      SET TO B ON VARIABLE SYSIN RECS ON A,M\n         A     R2,VPOSLENS     ADD POSITION DISPL TO ADDR\n         ST    R2,LKEYADR2    STORE KEY ADDR FOR CONVERT\nSETLENG  LA    R1,1(R4)        PUT LENGTH OF KEY IN R1 AND R3\n         LR    R3,R1\n         CLCL  R0,R2        COMPARE LONG THE 2 KEYS\nCNVRTNOP B     ENTRYPT   RETURN TO MAIN ROUTINE, SET TO NOP FOR CNVRT\n         SPACE 1\n         L     R15,=A(CNVRTABL)  GET CONVERT TABLE ADDR\n         L     R14,LKEYADDR      GET SYSUT1 KEY\nV1SET1   TR    0(0,R14),0(R15) CONVERT IT, LENG SET-DYNAMIC IF RECFM=V\n         L     R14,LKEYADR2      GET SYSIN KEY\nV1SET2   TR    0(0,R14),0(R15) CONVERT IT, LENG SET-DYNAMIC IF RECFM=V\n         B     ENTRYPT\n         SPACE 2\nSYSUTLEN LR    R1,R0           LOAD REC ADDR INTO R1\n         L     R3,POSLENS+4    LOAD POSITION INTO R3\n         AR    R0,R3           POINT TO KEY\n         ST    R0,LKEYADDR     STORE KEY ADDR FOR CONVERT\n         MVC   SAVEVARL(4),SAVER4  RESTORE SAVEVARL\n         BAL   GOREG,COMPRDW   IS L+P MORE THAN RDW\nFKQNOP1  BNH   SETSYSIN   NO. SET TO NOP ON F,K,Q WITH L SUBOPT, V RECS\nFKQBNH   NOP   FKQRETV1   SET TO BNH ON F,K,Q WITH L SUBOPT, V RECS\n         LH    R4,0(0,R1)      YES-MOVE RDW TO R4\n         S     R4,POSLENS+4    SUBTRACT POSITION OF KEY FROM R4\n         BCTR  R4,0            SET R4=LENGTH-1\n         ST    R4,SAVEVARL     SAVE REVISED KEY LENGTH\n         STC   R4,V1SET1+1     SET TRUNCATED CONVERT LENGTH FOR SYSUT1\n         STC   R4,V1SET2+1     SET TRUNCATED CONVERT LENGTH FOR SYSIN\n         STC   R4,SETLTR1+1    SET TRUNCATED CONVERT LENGTH FOR FKQL\nFKQNOP2  B     SETSYSIN  RETURN FOR COMPARE;SET TO NOP ON FKQL RECFM=V\n         SPACE 3\n         LR    R1,R4     PLACE KEY LENGTH IN R1\nFKQBR1   B     FKQRETV2  RETURN FOR MVCL TO FKQL LOGIC ON RECFM=V\n         SPACE 2\nSYSINLEN LR    R1,R2           SEE SYSUTLEN COMMENTS\n         L     R3,VPOSLENS\n         AR    R2,R3\n         ST    R2,LKEYADR2     STORE KEY ADDR FOR CONVERT\n         BAL   GOREG,COMPRDW\n         BNH   SETLENG\n         LH    R4,0(0,R1)\n         S     R4,VPOSLENS\n         BCTR  R4,0\n         STC   R4,V1SET1+1     SET TRUNCATED CONVERT LENGTH FOR SYSUT1\n         STC   R4,V1SET2+1     SET TRUNCATED CONVERT LENGTH FOR SYSIN\n         C     R4,SAVEVARL     IS R4= TO REVISED LENGTH\n         BE    SETLENG          YES\nSETQBNE  CLI   FULL1+3,X'00'   NO-SET COND CODE TO BNE;SET TO BL ON QNL\n*        THE FOLLOWING SITUATIONS ON THE Q LOGIC WILL BE CONSIDERED\n*        AS BEING IN-SEQUENCE CONDITIONS:\n*        1- A SHORT REC WHOSE RDW IS LESS THAN THE P(POSITION) OF THE\n*           KEY FIELD WILL BE CONSIDERED IN-SEQ.\n*        2- A SHORT REC WHOSE RDW IS LESS THAN L+P OF THE KEY FIELD\n*           BUT THE PORTION OF THE KEY THAT APPEARS IN THE SHORT REC\n*           IS EQUAL OR GREATER (LESS,IF N SUBOPTION USED)\n*           TO THE SAME PORTION OF THE KEY IN THE PREVIOUS REC.\n*        FOR THE F AN K OPTION - SITUATION 1 ABOVE IS CONSIDERED AN\n*           UNEQUAL KEY WHILE SITUATION 2 (WHEN THE TRUNCATED KEY\n*           FIELDS ARE EQUAL) ARE CONSIDERED EQUAL KEYS SINCE THE\n*           COMPARE (CLCL) IN PARAG LKETSET2 USES THE ADJUSTED LENGTH\n*           IN R4 AS SET IN PARAGRAPH SYSUTLEN.\nFKQNOP3  B     ENTRYPT  BR TO GET A NEW REC;SET TO NOP ON FKQL RECFM=V\n         SPACE 1\nFKQBR2   B     SEQCHK   BRANCH TO POST-COMPARE LOGIC IN FKQ\n         SPACE 2\nCOMPRDW  B     COMPRDWV   SET TO NOP IF RECFM=U\n         L     R1,DCBADDR2  GET DCB ADDR OF SYSUT1 OR SYSIN\n         LA    R1,LRECL(R1) LOAD R1 WITH LRECL ADDR (ACTUAL BLOCK LEN)\n         SPACE 2\nCOMPRDWV CH    R3,0(0,R1)      COMPARE POSITION OF KEY TO RDW\n         BH    SETQBNE       POSITION IS GREATER-SET CC TO BNE\n         L     R4,SAVER4       RELOAD ORIGINAL KEY LENGTH IN R4\n         STC   R4,V1SET1+1     SET CONVERT LENGTH FOR SYSUT1\n         STC   R4,V1SET2+1     SET CONVERT LENGTH FOR SYSIN\n         STC   R4,SETLTR1+1    SET CONVERT LENGTH FOR FKQL RECFM=V\n         AR    R3,R4         R3=L+P\n         LA    R3,1(R3)\n         CH    R3,0(0,R1)     IS L+P GREATER THAN RDW\n         BR    GOREG\n         TITLE 'L SUBOPTION PROCESSING-UP TO 3 L,P PAIRS'\nCOMPLKEY NOP   COMPLKYV           SET TO BRANCH IF VARIABLE RECS\n         CP    ENDCT,SAVECNT   ENDCT=#OF PRIMARY INPUT RECS READ\n         BE    LKEYSET   BRANCH IF WE HAVE NOT READ ANY ADDITIONAL RECS\n         ZAP   SAVECNT,ENDCT   SAVE THE # OF PRIMARY INPUT RECS READ\n         L     R0,PUTADDR       PUT ADDR OF INPUT RECORD IN R0\n         A     R0,POSLENS+4     ADD P1 (OF L,P PAIR) TO ADDR\n         ST    R0,LKEYADDR   SAVE KEY ADDR FOR CONVERT\nFKQRETV1 L     R1,POSLENS       SET R1=L1-1;RETURN ON FKQL RECFM=V\nFKQRETV2 LA    R1,1(R1)         SET R1=L1;RETURN ON FKQL RECFM=V,R1 ADJ\n         LR    R3,R1            SET R3=L1\n         LR    R5,R1            SET R5=L1\n         L     R2,LKEYARE1      PUT ADDR OF KEY AREA IN R2\n         MVCL  R2,R0            MOVE FIRST KEY TO KEY AREA\n*        AFTER EXECUTION OF THE MVCL INSTRUCTION R1=R3=0 AND\n*        R2=ADDR OF KEY AREA+L1, R0=ADDR OF INPUT REC+P1+L1\n         SPACE 2\nCNVRTBL1 B     BRL1    SET TO NOP ON CONVERT\n         L     R15,=A(CNVRTABL)   GET CONVERT TABLE\n         L     R14,LKEYADDR       GET FIRST KEY\nSETLTR1  TR    0(0,R14),0(R15) CONVERT, LENGTH SET(DYNAMIC ON RECFM=V)\n         SPACE 2\nBRL1     B     LKEYSET          SET TO NOP IF 2 L,P'S\n         SR    R0,R5        RESET R0=ADDR OF INPUT RECORD + P1\n         A     R0,POSDISPS      SET R0=ADDR OF INPUT AREA+P2\n         ST    R0,LKEYADDR   SAVE KEY ADDR FOR CONVERT\n         L     R1,POSLENS+8     SET R1=L2-1\n         LA    R1,1(R1)         SET R1=L2\n         LR    R3,R1            SET R3=L2\n         LR    R5,R1            SET R5=L2\n         MVCL  R2,R0        MOVE SECOND KEY TO KEY AREA\n         SPACE 2\nCNVRTBL2 B     BRL2    SET TO NOP ON CONVERT\n         L     R14,LKEYADDR       GET FIRST KEY\nSETLTR2  TR    0(0,R14),0(R15)      CONVERT, LENGTH SET\n         SPACE 2\nBRL2     B     LKEYSET            SET TO NOP IF 3 L,P'S\n         SR    R0,R5           SET R2=ADDR OF INPUT RECORD + P2\n         A     R0,POSDISPS+4   SET R0=ADDR OF INPUT AREA+P3\n         ST    R0,LKEYADDR   SAVE KEY FOR CONVERT\n         L     R1,POSLENS+16   SET R1=L3-1\n         LA    R1,1(R1)        SET R1=L3\n         LR    R3,R1           SET R3=L3\n         MVCL  R2,R0        MOVE THIRD KEY TO KEY AREA\n         SPACE 2\nCNVRTBL3 B     LKEYSET SET TO NOP ON CONVERT\n         L     R14,LKEYADDR       GET FIRST KEY\nSETLTR3  TR    0(0,R14),0(R15)      CONVERT, LENGTH SET\n         SPACE 2\nLKEYSET  NOP   FKQLPRC1 SET TO B ON FL,QL,KL OPTION, 1ST TIME THRU ONLY\nLKEYSETA NOP   LKEYSET2     SET TO B ON FL,QL,KL OPTION AFTER 1ST TIME\n*        HAS A NEW SYSIN RECORD BEEN READ, IF NOT BYPASS MOVE SYSIN KEY\n         CP    RCOUNT,SAVRCNT  COMPARE NUMBER OF SYSIN RECORDS READ\n         BE    LKEYSET2        IF EQUAL TO NUMBER SAVED, NO NEW SYSIN\n         ZAP   SAVRCNT,RCOUNT  ELSE IT IS NEW SYSIN\n         L     R0,CARDADDR    SAME PROCESS FOR SYSIN KEY\n         A     R0,VPOSLENS\n         ST    R0,LKEYADDR\n         L     R1,VLEN123\n         LA    R1,1(R1)\n         LR    R3,R1\n         LR    R5,R1\n         L     R2,LKEYARE2\n         MVCL  R2,R0\n         SPACE 2\nCNVRTVL1 B     VBRL1   SET TO NOP ON CONVERT\n         L     R14,LKEYADDR       GET FIRST KEY\nVSETLTR1 TR    0(0,R14),0(R15)      CONVERT, LENGTH SET\n         SPACE 2\nVBRL1    B     LKEYSET2\n         SR    R0,R5\n         A     R0,VPOSDISP\n         ST    R0,LKEYADDR\n         L     R1,VLEN123+4\n         LA    R1,1(R1)\n         LR    R3,R1\n         LR    R5,R1\n         MVCL  R2,R0\n         SPACE 2\nCNVRTVL2 B     VBRL2   SET TO NOP ON CONVERT\n         L     R14,LKEYADDR       GET FIRST KEY\nVSETLTR2 TR    0(0,R14),0(R15)      CONVERT, LENGTH SET\n         SPACE 2\nVBRL2    B     LKEYSET2\n         SR    R0,R5\n         A     R0,VPOSDISP+4\n         ST    R0,LKEYADDR\n         L     R1,VLEN123+8\n         LA    R1,1(R1)\n         LR    R3,R1\n         MVCL  R2,R0\n         SPACE 2\nCNVRTVL3 B     LKEYSET2  SET NOP ON CONVERT\n         L     R14,LKEYADDR       GET FIRST KEY\nVSETLTR3 TR    0(0,R14),0(R15)      CONVERT, LENGTH SET\n         SPACE 1\nLKEYSET2 L     R0,LKEYARE1    LOAD ADDR OF PRIMARY KEY AREA\n         L     R2,LKEYARE2       INTO R0 AND SYSIN KEY AREA INTO R2\n         LA    R1,1(R4)     SET R1=L1+L2+L3\n         LR    R3,R1        SET R3=R1\n         CLCL  R0,R2     COMPARE PRIMARY AND SYSIN KEY AREAS\nLKEYSETB NOP   SEQCHK    SET TO B ON FL,KL,QL OPTIONS\n         B     ENTRYPT\n         TITLE 'F,K,Q SETUP LOGIC FOR LONG SUBOPTION'\nCOMPLKY2 NOP   COMPLKEY            SET TO BRANCH AFTER 1ST TIME THRU\n         MVI   COMPLKY2+1,SETBR\n         MVI   FKQNOP1+1,SETNOP SET NOPS AND BRANCHES FOR RECFM=V LOGIC\n         MVI   FKQNOP2+1,SETNOP\n         MVI   FKQNOP3+1,SETNOP\n         MVI   FKQBNH+1,X'D0' SET BNH FOR RECFM=V LOGIC\n         MVI   LKEYSET+1,SETBR  SET RETURN AFTER CONSTRUCTING KEY\n         B     COMPLKEY\nFKQLPRC1 MVI   LKEYSET+1,SETNOP NOP THE RETURN BACK HERE\n         MVI   LKEYSETA+1,SETBR SET BRANCH TO COMP CURR KEY TO PREV KEY\n         MVI   LKEYSETB+1,SETBR SET B TO RETURN TO SEQCHK AFTER COMPARE\n         MVC   FKQLMOVE(2),SETBAL         SET UP BAL TO MVCL\nQNLBL    CLI   FULL1+3,X'00' SET CC TO BH, CHANGED TO BL ON N SUBOPTION\n         B     SEQCHK\n         SPACE 2\nMVCL     L     R2,LKEYARE1\n         L     R0,LKEYARE2\n         LA    R1,1(R4)\n         LR    R3,R1\n         MVCL  R0,R2      MOVE CURRENT KEY TO PREVIOUS KEY\n         BR    GOREG\n         TITLE 'SEQUENCE CHECKING OUTPUT LOGIC (Q) PROCESSING'\nQWRITE   BAL   GOREG,PUTFILE\n         B     NOOPONQ    GO BACK TO MAINLINE\nSEQMSG2  NOP   QRESTMSG\n         LNKMSG 22                   FIRST OUT OF SEQUENCE MSG\n         MVI   SEQMSG2+1,SETBR THIS PAR EXECUTED ONLY ONCE ON SEQERROR\n         MVI   KEYMSG,C'9'     SET FLAG THAT FILE IS OUT OF SEQ\n         CP    TOTLKEYS,COUNT  IS 200 GREATER THAN USER PARM COUNT\n         BH    QRESTMSG        YES- USER ENTERED COUNT IS USED\n         ZAP   COUNT,TOTLKEYS    SET COUNT TO 200\nQRESTMSG NOP   BRPTOUT2          CHANGED TO  B ON QB KEY\n         CP    COMPCNTA,COUNT    DO NUMBER OF SEQ ERRORS EXCEED COUNT\n         BNE   QCONTINU\n         MVI   QRESTMSG+1,SETBR  THIS PAR BRANCHED AROUND WHEN CNT SAT\n         LNKMSG 14,EDIT=COUNT+3,BRANCH=BRPTOUT2\nQCONTINU AP    COMPCNTA,PACKONE   ADD 1 TO NUMBER OF SEQUENCE ERRORS\n         MVC   MSG23ED,MSGMASK       RESET THE EDIT MASK\n         ED    MSG23ED,PASSCT+3   RECORD NUMBER OUT OF SEQ\nQBRONL   NOP   QLROUT             CHANGED TO B ON L SUBOPTION\nCURRKEY  MVC   MSG23CKY,KEYAREA       CURRENT KEY OUT OF SEQ\nPREVKEY  MVC   MSG23PKY,INCARD        PREVIOUS KEY OUT OF SEQ\nPUTQMSG  MESSAGE 23,BRANCH=BRPTOUT2\n         SPACE 2\nQLROUT   MVC   MSG23CKY-6(6),MSGSPACE\n         MVC   MSG23PKY-14(14),MSGSPACE\n         MVI   QRESTMSG+1,SETBR\n         B     PUTQMSG\n         TITLE 'OR AND RANGE (O,ON,B,C) LOGIC PROCESSING'\nOLOGIC1  EQU   *\nBLOGCLC1 CLC   0(0,R3),INCARD\nENTRYPT2 EQU   *\nONKEYEQ1 NOP   BRPTOUT2   CHANGED TO BE ON 'ON' KEY & BL ON B KEY\nCKEYNE   NOP   BLOGCLC5   CHANGED TO BNE ON 'C' KEY\nBKEYNOP1 BE    OLOGMTCA   NOOPED ON B KEY,CHANGED TO BL ON 'BN' KEY\nBLOGCLC2 B     OLOGEXIT           NOOPED IF MORE THAN 1 KEY\nBLOGCLC3 CLC   0(0,R3),INCARD1\nONKEYEQ2 NOP   BRPTOUT2   CHANGED TO BE ON 'ON',BNE ON 'C',BE ON 'CN'\nBKEYBNH  BE    OLOGMTCB   CHANGED TO BNH ON B,NOP ON 'BN',BNE ON 'CN'\nBKEYBH   NOP   NEXTBKEY   CHANGED TO B ON 'B' KEY,BH ON 'BN' KEY\nBLOGCLC4 B     OLOGEXIT           NOOPED IF MORE 3 KEYS\nBLOGCLC5 CLC   0(0,R3),INCARD2\nONKEYEQ3 NOP   BRPTOUT2   CHANGED TO BE ON 'ON',BNE ON 'C',BE ON 'CN'\nCKEYNE2  BE    OLOGMTCC   CHANGED TO BNE ON 'CN'\nOLOGEXIT EQU   *\nONSELECT NOP   OLOGMTCH   CHANGED TO B ON 'ON' KEY\n         B     BRPTOUT2\nOLOGMTCH EQU   *\n         CP    OUTCT,COUNT     IS COUNT ON BN KEY SATISFIED\nBNKEYBR  NOP   BRPTOUT2   CHANGED TO BE ON 'BN' KEY\n         BAL   GOREG,PUTFILE\n         CP    OUTCT,COUNT\nOLOGEND  BE    ENDINPUT      NOOPED ON B KEY\nBCNTSAT  NOP   LASTBKEY   CHANGED TO BE ON B ONLY(WHEN CNT SATISFIED)\n         B     GETINPUT\nOLOGMTCA AP    COMPCNTA,PACKONE\nCKEYEQ   NOP   BLOGCLC3      CHANGED TO BRANCH ON 'C' KEY\n         B     OLOGMTCH\nOLOGMTCB AP    COMPCNTB,PACKONE\n         B     OLOGMTCH\nOLOGMTCC AP    COMPCNTC,PACKONE\n         B     OLOGMTCH\nNEXTBKEY EQU   *\n         SP    PASSCT,PACKONE     SUBTRACT 1 FROM FROM RECORDS PASSED\nLASTBKEY MVC   MSG29PAS,MSGMASK        RESET MASK\n         MVC   MSG29OUT,MSGMASK\n         ED    MSG29PAS,PASSCT+3   EDIT THE COUNTS\n         ED    MSG29OUT,OUTCT+3    EDIT THE LAST 5 BYTES (9 DIGITS)\n         MESSAGE 29                   PUT OUT B MESSAGE\nENDBKEY  NOP   EOJ                 CHANGED TO B WHEN LAST KEY=HIGHVALUE\n         ZAP   PASSCT,PACKONE      REINITIALIZE THE COUNTS\n         MVI   BBRANCH+1,SETBR  SET B TO BYP GETINPUT AFTER READING KEY\nBNGOREAD NOP   GOREAD           CHANGED TO B ON 'BN' KEY\nENDBNOP  B     BTEST            NOOPED AT END OF INFILE\n         B     ENDFILE\n*\nBTEST    EQU   *\n         CP    OUTCT,COUNT   WAS COUNT SATISFIED\n         BNE   GOREAD         NO-READ 2 MORE KEYS AND SKIP GETINPUT\n         ZAP   PASSCT,PACKZERO  YES-MOVE PASSCT BACK TO ZERO\n         MVI   BBRANCH+1,SETNOP NOP THE BRANCH WHICH SKIPS GETINPUT\nGOREAD   ZAP   OUTCT,PACKZERO   REINITIALIZE OUTCT\n         B     BKEYREAD         GO TO READ 2 NEW KEYS\n         TITLE 'DEBUG LOGIC (D) PROCESSING'\nDWRITE   EQU   *             DEBUG OPTION PROCESSING\n         SP    DCOUNT,PACKONE   DEFAULT DCOUNT=1, CHANGED BY X0 DOPTION\n         BNZ   GETINPUT       KEEP READING UNTIL NTH OCCURRENCE OF KEY\n         MVI   KEYMSG,C'8'   FLAG TO INDICATE KEY WAS FOUND ON D OPTION\n         NI    COUNT,X'4F' ZERO OUT TOP 1/2-BYTE OF COUNT ON DFLT\n         MVI   DBPUTOUT+1,SETBR   SET BRANCH TO RETURN TO D LOGIC\n         MVI   SETBEQBR+1,SETNOP  PUT REJECTS OUT TO SYSUT3\nDKEYMSG  MVC   MSG34KEY,INCARD        MOVE KEY TO MESSAGE\n         CLI   ENDINF+1,SETNOP    IS 'KEY=' MSG TO BE SUPPRESSED\n         BNE   DKEYMSG2           NO\n         MVC   MSG34KEY,MSGSPACE  BLANK OUT KEY IN MESSAGE\n         MVC   MSG34+12(3),=C' IS' YES\nDKEYMSG2 ED    MSG34LOC,PASSCT+3   LOCATION OF RECORD WITH DESIRED KEY\n         AP    COMPCNT,PACKONE  ADD 1 TO NO OF RECS TO BE OUTPUT\nDMINSNOP AP    COMPCNT,COUNT   ADD PARM COUNT TO NO OF RECS TO BE OUTPT\n*        THE ABOVE AP IS CHANGED TO CP WHEN J=-\n         CP    COUNT,PASSCT    IS COUNT PARM LESS THAN RECORDS PASSED\nDPLUSBR  BL    SUBCNT       YES-CHANGED TO B WHEN J=+\n         SP    PASSCT,PACKONE  NO- SUBTRACT 1 FROM PASSCT\n         ZAP   COUNT,PASSCT    MOVE NO OF RECORDS PASSED TO PARM COUNT\n         ZAP   RBEGIN,PACKONE  BEGIN OUTPUTING FROM RECORD 1\n         B     ADDCNT\nSUBCNT   SP    PASSCT,COUNT  SUBTRACT THE PARM COUNT FROM PASSCT\n*        THE ABOVE SP IS CHANGED TO CP WHEN J=+\n         ZAP   RBEGIN,PASSCT    BEGIN OUTPUTTING RECORDS FROM PASSCT\nADDCNT   AP    COMPCNT,COUNT     ADD THE MODIFIED PARM COUNT TO COMPCNT\n*        THE ABOVE AP IS CHANGED TO CP WHEN J=+\n         ED    MSG34BEG,RBEGIN+3  MOVE THE BEGINNING TO MESSAGE\nDOPTIMIZ NOP   DPUTREC  CHANGED TO BRANCH FOR X0 DOPTION=OPTIMIZE\n         SP    RBEGIN,PACKONE     BYPASS RBEGIN-1 RECORDS\n         ZAP   BEGIN,RBEGIN\n         ZAP   ENDCT,PACKZERO\n         L     R2,DCBADDR      LOAD ADDR OF ISAM/INFIL INTO R2\n         L     R15,=A(DCBCSECT) CLOSE INPT FILE-REPOSITION TO FRONT\n         BALR  GOREG,R15    FREE BUFFER POOL FOR INPUT DCB\n         CLI   OPENBACK,C'W'    IS READ BACKWARD OPTION REQUESTED\n         BNE   OPENFOW                NO\n         OPEN  ((R2),RDBACK)        YES-REOPEN BACKWARDS\n         B     GETINPUT               UNTIL\nOPENFOW  BAL   GOREG,OPENINP  REOPEN INPUT AND BEGIN PROCESSING\n         B     GETINPUT               UNTIL\nDPUTREC  BAL   GOREG,PUTFILE    SPECIFIED NUMBER OF RECORDS TO BE\n         L     R1,DCBADDR       GET THE DCB ADDR\n         GET   (R1)               READ AND WRITE RECORDS UNTIL THE\n         ST    R1,PUTADDR         SAVE ADDR OF INPUT REC AREA\n         AP    ENDCT,PACKONE    KEEP COUNT FOR PRINTING\n         SP    COMPCNT,PACKONE\n         CP    COMPCNT,PACKZERO\n         BNE   DPUTREC\n         EX    0,KCNTSAT\nDMSGOUT  ED    MSG34OUT,OUTCT+3   MOVE NO OF RECORDS OUTPUT TO MSG\n         MESSAGE 34,BRANCH=ENDFILE     PUT OUT MSG\n         TITLE 'RANDOM LOGIC (R) PROCESSING'\nRLOGIC1  NOP   RCOMMON         CHANGED TO BRANCH AFTER ENTERED 1ST TIME\n         MVI   RLOGIC1+1,SETBR\n         L     R5,POSLENS(R6) LOAD R5 WITH BEGIN POSIT FROM POSLENS\n         C     R5,HIGHV        IS R5 =HIGH VALUES-END OF POSLENS\n         BE    ENDINPUT        END\n         LA    R5,1(R5)        ADD 1 BACK TO BEGIN POS\n         CVD   R5,RBEGIN       PACK THE BEGIN COUNT\n         L     R5,POSLENS+4(R6) LOAD R5 WITH SKIP FACTOR FROM POSLENS\n         CP    RBEGIN,PASSCT   IS RBEGIN NOT LESS THAN PASSCT\n         BNL   RBEGINOK        YES\n         ZAP   RBEGIN,PASSCT   NO-REPLACE RBEGIN WITH PASSCT\nRBEGINOK LA    R5,1(R5)\n         CVD   R5,RSKIP        PACK THE SKIP FACTOR\n         ZAP   COMPCNT,PACKZERO REINITIALIZE THE PARM COUNTER\n         AP    RCOUNT,COUNT    RCOUNT IS USED IN RMSG ROUTINE\nRCOMMON  CP    PASSCT,RBEGIN   HAVE WE REACHED THE BEGINNING POSIT\n         BL    BRPTOUT2        NO-GO TO GETINPUT\n         AP    SKIPCT,PACKONE  ADD 1 TO THE SKIP COUNTER\n         CP    SKIPCT,RSKIP    IS THE SKIP FACTOR SATISFIED\nRNEGAT   NOP   RNEGAT1         CHANGED TO BRANCH ON RN\n         BNE   BRPTOUT2        NO\n         ZAP   SKIPCT,PACKZERO REINITIALIZE THE SKIP COUNTER\nRPUTOUT  BAL   GOREG,PUTFILE\n         AP    COMPCNT,PACKONE  ADD 1 TO OUTPUT FOR L,P PAIR\n         CP    COMPCNT,COUNT   IS THE COUNT SATISFIED\n         BL    GETINPUT\nRMSGOUT  ZAP   SKIPCT,PACKZERO REINIT THE SKP CNTER(NEEDED FOR RN ONLY)\n         MVC   MSG26OUT,MSG23ED      RESET MASKS\n         MVC   MSG26BEG,MSG23ED   (CANNOT USE MSGMASK BECAUSE IT IS\n         MVC   MSG26SKP,MSG23ED    KILLED ON THE NEGATIVE OPTION)\n         ED    MSG26OUT,COMPCNT+3  RECORDS OUTPUT FOR NTH L,P PAIR\n         ED    MSG26BEG,RBEGIN+3   REC NUMBER OUTPUT BEGAN ON\n         ED    MSG26SKP,RSKIP+3    SKIP FACTOR\n         MESSAGE 26\nRENDBR   NOP   ENDINF     CHANGED TO B WHEN FILE END BEFORE CNT SATISF\n         LA    R6,8(R6)   SET INDEX (R6) UP BY 8 TO POINT TO NEXT FLD\n         C     R6,=F'16'  IS THIS THE LAST POSLENS FLD\n         BH    ENDINPUT   YES\n         MVI   RLOGIC1+1,SETNOP NO\n         B     GETINPUT\n         SPACE 3\nRNEGAT1  BNE   RPUTOUT          SKIP EVERY NTH RECORD AND PUT OUT ALL\n         ZAP   SKIPCT,PACKZERO       THE REST FOR R NEGATIVE\n         B     BRPTOUT2         GET A NEW RECORD\n         TITLE 'RANDOM LOGIC (R) PROCESSING-ONLY 1 PARM FIELD'\nREXTLOG1 NOP   RCOMPARE     SET BRANCH AFTER 1ST TIME THRU\n         MVI   REXTLOG1+1,SETBR\n         BAL   GOREG,GETCARD        GET A SYSIN RECORD\nRANDOMKY NOP   NOTRANDM      SET TO BRANCH AFTER 1ST TIME THRU\n         MVI   RANDOMKY+1,SETBR\n         CLC   INCARD(6),=C'RANDOM' IS RANDOM OPT REQUESTED\n         BE    RANDOM                     YES\n         MVI   SETBRONV+1,SETBR    NO- SET BR TO IGNORE E= PARM\n         LNKMSG 60                 WRITE R HEADING\nNOTRANDM MVC   MSG62KEY,INCARD     MOVE SYSIN VALUE TO PRINT AREA\n         L     R15,=A(TRNSTAB2)\n         TRT   INCARD(16),0(R15)      CHECK IF SYSIN REC IS NUMERIC\n         BZ    RERROR           SYSIN RECORD EXCEEDS 15 NUMERIC DIGITS\n         CLI   0(R1),BLANK1   IS NUMBER ON SYSIN REC FOLLOWED BY SPACE\n         BNE   RERROR          NO-ERROR\n         SR    R1,R9     R1=ADDR OF 1ST SPACE FOLLOWING NUMBER,\n*              R9=ADDR OF INCARD. R1 NOW HAS LENGTH OF SYSIN NUMBER\n         BZ    RERROR         NO\n         BCTR  R1,0     YES-SUBTRACT TO ADJUST LENGTH FOR PACK INSTR\n         EX    R1,HEXPACK PK INCARD INTO WORKFLD1(PACK WORKFLD1,INCARD)\n         CP    WORKFLD1,PASSCT   ARE SYSIN RECORDS IN SEQUENCE\n         BL    RERROR              NO\n         SP    WORKFLD1,PASSCT     YES-SUBTRACT TO GET SKIP FACTOR\nRCOMPARE CP    WORKFLD1,PACKZERO     WHEN WORKFLD1=0 PUT PUT OUT REC\n         BE    RPUT\n         SP    WORKFLD1,PACKONE      SUBTRACT 1 FROM WORKFLD1\n         B     BRPTOUT2          AND GET A NEW RECORD\nRPUT     BAL   GOREG,PUTFILE\n         MVC   MSG62MSG,=C'RECORD OUTPUT'\n         MESSAGE 62\nRPUTLAST NOP   ENDINF       SET TO BR TO EOF AFTER 'LAST' OUTPUT\n         MVC   MSG62MSG,MSGSPACE\n         MVC   MSG62MSG(5),=C'ERROR' MVE 'ERROR' TO MSG\n         MVI   REXTLOG1+1,SETNOP\n         B     GETINPUT         GET A NEW SYSIN RECORD\n         SPACE 3\nRERROR   CLC   INCARD(5),=C'LAST '   IS 'LAST' REC REQUESTED\n         BE    RLAST                 YES\n         MVI   REXTLOG1+1,SETNOP     NO - ERROR\n         MESSAGE  62,BRANCH=REXTLOG1  PUT OUT ERR MSG AND GET NEW SYSIN\n         SPACE 2\nRLAST    ZAP   WORKFLD1,=P'999999999999999'   SET REC NO.= HIGH\n         MVI   REXTMSG+1,SETBR  SET BR TO PUTOUT 'LAST' RECORD\n         MVI   RPUTLAST+1,SETBR SET BR TO GO TO EOF AFTER 'LAST' MSG\n****     SP    OUTCT2,PACKONE SUBT 1 FROM REJCT CNT WHICH INCLUDED LAST\n         B     RCOMPARE         FINISH INPUT FILE TO EOF\n         TITLE 'RANDOM OPTION'\nRANDOM   EQU   *\n         MVI   RANDMOPT+1,SETBR  SET BR FOR RANDOM PROCESSING AFTER GET\nRNDMCNVT CLI   INCARD+6,C'='           IS USER SUPPLYING SEED\n         BNE   DFLTSEED           NO- USE DEFAULT SEED OF 8193\n         CLC   INCARD+7(6),=C'PICKIT' DOES USER WANT A RANDOM SEED\n         BE    PICKIT                 YES\n         MVI   INCARD+15,BLANK1   NO-LIMIT SEED TO 8 DIGITS\n         L     R15,=A(TRNSTAB2)        GET NUMERIC TABLE\n         TRT   INCARD+7(9),0(R15)    FIND WHERE SEED ENDS\n         LA    R9,7(R9)     R9=A(INCARD), R9 NOW POINTS TO SEED\n         SR    R1,R9            GET LENGTH OF SEED\n         BZ    DFLTSEED        IF LENGTH=0 USE DEFAULT SEED\n         BCTR  R1,0        SUBTRACT 1 FROM LENGTH TO SET UP FOR PACK\n         EX    R1,SEEDPACK         PACK SEED INTO WORKFLD1\n         CVB   R9,WORKFLD1    AND CONVERT SEED TO BINARY\nMAKEODD  O     R9,FULL1        INSURE SEED IS ODD\n         ST    R9,SEED\nDFLTSEED L     R9,SEED          GET SEED\n         CVD   R9,WORKFLD1   AND CONVERT IT TO DECIMAL FOR PRINT MSG\n         LNKMSG 57,EDIT=WORKFLD1+3     WRITE MESSAGE\n         CP    END,=P'1073741823' INSURE HIGH RANGE LESS THAN 2**30-1\n         BL    ENDOK\n         ZAP   END,=P'1073741823'\nENDOK    CP    COUNT,MAXRNDM  INSURE NO OF RNDM NUMBS IS IN TABLE <MAX\n         BL    COUNTOK\n         ZAP   COUNT,MAXRNDM\nCOUNTOK  CVB   R3,BEGIN    YES-PUT (B= +1) R3 TO ADD TO EACH RNDM NO\n         LA    R3,1(R3)    DONT CHANGE R3 UNTIL AFTER RANDM NOS GENER\n         CVB   R9,END          LOWER HIGH RANGE BY (B= +1)\n         SR    R9,R3\n         BM    BEGINNG      BEGIN EXCEEDS END-NO GOOD\n         AR    R9,R9        MULTIPLY HIGH RANGE BY 2 AND\n         ST    R9,ENDBIN      STORE 2N IN ENDBIN\n         CVB   R2,COUNT     MULTIPLY COUNT (NUMBER OF ENTRIES IN TABLE)\n         SLL   R2,2           BY 4 TO GET LENGTH OF TABLE\n         LR    R0,R2         AND PUT LENGTH IN R0 FOR THE GETMAIN\n         STCM  R0,7,FREELEN+1 SAVE GETMAIN LENGTH FOR FREEMAIN\n         GETMAIN R,LV=(0)      GRAB STORAGE FOR TABLE\n         ST    R1,TABLE        AND PUT TABLE ADDR IN 'TABLE'\n         LA    R9,4           PUT 4 IN R9\n         LNR   R9,R9          SET R9=-4\n         AR    R2,R9          SUBTRACT 4 FROM TABLE LENGTH\n         LA    R5,0(R2,R1)    COMPUTE ADDR OF LAST ELMT IN TABLE\n         ST    R5,TABLEND      AND STORE ADDR IN TABLE\nLOOPRNDM L     R5,ENDBIN    PUT 2*(HIGH RANGE) (2*N) IN R5\n         L     R7,SEED       PUT SEED IN R7\n         M     R6,=F'65541'      MULTIPLY SEED BY 65541\n         ST    R7,SEED    STORE NEW SEED-A NO FROM -2**31 TO 2**30\n         LPR   R7,R7         SET R7=|R7|\n         MR    R4,R7   R4-R5 NOW HAS A RNDM NO FROM 0 TO 2**32*N\n         AR    R4,R3        R4= 1 TO N IN IT (AFTER ADDING BACK B= +1)\n         ST    R4,0(R2,R1)  STORE RNDM NO IN TABLE\n         BXH   R2,R9,LOOPRNDM      LOOP UNTIL TABLE IS FILLED\n         SPACE 5\n         L     R2,ASNAPDMP         PRINT RNDM NO TABLE IF SYSOUX\n         L     R6,TABLEND\n         CHCKTIOT NOTFND=RSORT\n         BAL   GOREG,OUTATTR       OPEN SYSOUX- SNAPDUMP\n         L     R5,TABLE\n         SNAP  DCB=(R2),ID=1,STORAGE=((R5),(R6)),STRHDR=RNDMHDRL\n         MVI   POSTSORT+1,SETNOP SET NOP TO WRITE RN NUMBS AFTER SORT\n         SPACE 3\nRSORT    L     R5,TABLE           GET TABLE ADDR IN R5\nRNDMNOP  NOP   EOFCNVRT      SET TO BRANCH FOR CONVERT FILE\n         MVI   SORTDONE,C'0'      0=SORT FINISHED\nRSORTCNT C     R5,TABLEND       IS THIS THE LAST TABLE ENTRY\n         BNL   RSORTEND                  YES\n         LM    R6,R7,0(R5)  GET NEXT 2 RANDOM NUMBERS\n         CR    R6,R7            ARE THEY IN SORTED ORDER\n         BNH   RNEXTKEY              YES\n         XR    R6,R7        NO-SWITCH THEM\n         XR    R7,R6\n         XR    R6,R7\n         STM   R6,R7,0(R5)       RESTORE SORTED NUMBERS BACK IN TABLE\n         MVI   SORTDONE,C'1'        INDICATE 2 ENTRIES WERE MOVED\nRNEXTKEY LA    R5,4(R5)       POINT TO NEXT TABLE ENTRY\n         B     RSORTCNT            CONTINUE SORTING\nRSORTEND CLI   SORTDONE,C'0'    IS THE SORT FINISHED\n         BNE   RSORT               NO\n         SPACE 3\n         L     R7,TABLE         YES -GET TABLE ADDR IN R7\nPOSTSORT B     RNDMROUT         SET TO NOP IF SYSOUX IN JCL\n         L     R6,TABLEND\n         MVI   RANDMHDR+5,C'9'    CHANGE MSG NUMBER TO 079\n         MVC   RANDMHDR+8(4),MSGSPACE BLANK OUT 'PRE-'\n         L     R4,ASNAPDMP      GET SNAPDUMP DCB\n         SNAP  DCB=(R4),ID=2,STORAGE=((R7),(R6)),STRHDR=RNDMHDRL\n         SPACE 3\nRNDMROUT NOP   RNDMCOMP\n         MVI   RNDMROUT+1,SETBR\n         CVB   R9,PASSCT         PUT PASSCT IN R9I\nRNDMPROC LA    R6,0(0,R7)        PUT ADDR OF RNDM NO IN R6\n         C     R6,TABLEND      IS THIS THE END OF THE TABLE\nRNDMONLY BH    RNDMEND      YES;SET TO BR WHEN NOINPUT IN X0 EXIT\n         L     R5,0(0,R7)                PUT RNDM NO IN R5\n         SR    R5,R9        NO-PUT  (RNDM NO-PASSCT) IN R5\n         BM    RNDMDUP      DIFFERENCE IS NEGAT-MEANS DUP IN TABLE\nRNDMCOMP LTR   R5,R5        IS DIFFERENCE 0\n         BZ    RNDMPUT  YES-GO TO PUT OUT THIS INPUT RECORD\n         BCTR  R5,0 SUBTRACT 1 FROM DIFFERENCE\n         B     BRPTOUT2\nRNDMPUT  BAL   GOREG,PUTFILE      WRITE REC\n         LA    R7,4(R7)           GET NEXT RANDOM NUMB\n         MVI   RNDMROUT+1,SETNOP\n         B     GETINPUT\n         SPACE 1\nRNDMDUP  LA    R7,4(R7)        POINT TO NEXT RANDOM NUMBER\n         B     RNDMPROC\n         SPACE 1\nSEEDPACK PACK  WORKFLD1,INCARD+7(1)    PACK THE SEED\n         SPACE 2\nPICKIT   TIME  BIN  GET THE TIME OF DAY IN BINARY N R0 (GOOD RANDOM NO)\n         LR    R9,R0     PLACE IN R9\n         B     MAKEODD   AND RETURN TO MAINLINE RANDOM RTN\nRNDMHDRL DC    AL1(L'RANDMHDR)\nRANDMHDR DC    C'SEL078I PRE-SORTED RECORD NUMBERS GENERATED BY RANDOM C\n               OPTION'\n         TITLE 'PRINT DETAIL LINES AND MESSAGES ROUTINES'\nKEYREPT  L     R1,PRINTBUF    SUBROUTINE TO PRINT TOTALS MESSAGE\n         MVC   MSG4KEY,MSGSPACE   SPACE OUT\n         CLI   INCARD,X'FF'  IS THE INPUT = HIGH VALUE\n         BNE   KEYREPT1    GO TO PROCESS THE NORMAL KEY\n         MVC   INCARD,HIGHVALU\nKEYREPT1 MVC   MSG4KEY,INCARD\n         MVC   0(MSG4LEN,R1),MSG4\n         ED    MSG4PASS(MSG4EDIT,R1),PASSCT   PASS & OUT CTS\n         MVC   MSG4MAX,MSGSPACE   RESET TO BLANKS\nKMSG     B     ORENDCNT           NOOP ON K KEY FOR MSG\n         CP    TOTLKEYS,COUNT\n         BE    KCNTSAT\nORENDCNT B     ZAPCNTS     NOOPED FOR 'O' ,'ON' KEY AND 'MN' ON EOJ\n         CP    OUTCT,COUNT\n         BNE   ZAPCNTS\nKCNTSAT  MVI   MSG5FLAG,X'52'    SET FOR MSG 82\nZAPCNTS  AP    TOTPASCT,PASSCT\n         AP    TOTOUTCT,OUTCT\n         ZAP   OUTCT,PACKZERO     RESET TO ZERO\n         ZAP   PASSCT,PACKZERO    RESET TO ZERO\nSKIPPRNT BCR   0,GOREG            CHANGED TO BRANCH ON A,M,V= OPTION\n*\nPUTPRINT L     R1,ASYSPRNT        PRINT SUBROUTINE-GET SYSPRINT DCB\n         PUT   (R1)\n         ST    R1,PRINTBUF        ALLOW DYNAMIC BUFFERING\n         MVI   0(R1),BLANK1            INIT NEXT PRINT LINE TO BLANKS\n         MVC   1(132,R1),0(R1)\n         BR    GOREG\n         TITLE 'READ SYSIN ROUTINE'\nGETCARD  B     RETURNCD   NOP IF KEY TYPE IS M,T,G,P,B,C,O,A OR E\n         SPACE 1\nREADCRD1 B     RDSYSIN    CHANGED TO NOP ON 'A' OPTION WITH S513\n         L     R1,PUTADDR       LOAD ADDR OF INPUT FILE\n         B     AFTEREAD         BRANCH AROUND THE GETCARD\n         SPACE 1\nRDSYSIN  CP    RCOUNT,PACKZERO\n         BE    READCRD2\nSYSINOUT B     SYSINOT2        CHANGED TO NOP IF SYSUT4 PRESENT IN JCL\n         CLI   SYSINFLG,C'1'   DID THIS SYSIN RECORD CAUSE A MATCH\n         BNE   SYSINOT2                NO\n         MVI   SYSUTX,C'4'\nEXITBRO3 B     NOEXITO3   CHANGED TO NOP IF EXIT POINT O3 REQUESTED\n         L     R15,=A(EXTEPAO3)   GET EXIT O3 ENTRY POINT\n         L     R15,0(R15)\n         LA    R1,CARDADDR        SET UP PARAMETER LIST\n         BALR  R14,R15            EXECUTE O3 EXIT\n         C     R15,FULL4          CHECK RETURN CODE\n         BL    NOEXITO3 RC=0   CONTINUE NORMAL PROCESSING\n         BE    RESETFLG RC=4  DELETE THIS RECORD-GET NEW SYSIN\n         MVI   EXITBRO3+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT\nNOEXITO3 EQU   *\n         L     R2,ASYSIN    GET SYSIN DCB\n         L     R1,AOUTFIL3   LOAD SYSUT4 DCB ADDR INTO R1\n         L     R0,CARDADDR  LOAD SYSIN RECORD ADDR INTO R0\nSKIPPUT4 NOP   PRINT4        CHANGED TO BRANCH IF SYSUT4 IS SYSOUT\n         PUT   (R1),(R0)  YES-OUTPUT THIS SYSIN RECORD TO SYSUT4\nPRINT4   ST    GOREG,SAVEREGS   SAVE THE BAL REGISTER\nPRNT4BAL NOP   PRINTLK      CHANGED TO BAL IF SYSUT4 IS SYSOUT\n         L     GOREG,SAVEREGS\n         AP    OUTCT3,PACKONE        ADD 1 TO MATCH COUNT\nRESETFLG MVI   SYSINFLG,C'0'    RESET THE FLAG\n         B     READCRD2         GO TO GET A NEW SYSIN RECORD\n         SPACE 1\nSYSINOT2 B     READCRD2        CHANGED TO NOP IF SYSUT5 PRESENT IN JCL\n         CLI   SYSINFLG,C'1'    DID THIS SYSIN RECORD CAUSE A MATCH\n         BE    RESETFLG        YES\n         MVI   SYSUTX,C'5'\nEXITBRO4 B     NOEXITO4   CHANGED TO NOP IF EXIT POINT O4 REQUESTED\n         L     R15,=A(EXTEPAO4)   GET EXIT O4 ENTRY POINT\n         L     R15,0(R15)\n         LA    R1,CARDADDR        SET UP PARAMETER LIST\n         BALR  R14,R15            EXECUTE O4 EXIT\n         C     R15,FULL4          CHECK RETURN CODE\n         BL    NOEXITO4 RC=0   CONTINUE NORMAL PROCESSING\n         BE    READCRD2 RC=4  DELETE THIS RECORD-GET NEW SYSIN\n         MVI   EXITBRO4+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT\nNOEXITO4 EQU   *\n         L     R2,ASYSIN\n         L     R1,AOUTFIL4\n         L     R0,CARDADDR\nSKIPPUT5 NOP   PRINT5\n         PUT   (R1),(R0)  NO-OUTPUT THIS SYSIN RECORD TO SYSUT5\nPRINT5   ST    GOREG,SAVEREGS\nPRNT5BAL NOP   PRINTLK\n         L     GOREG,SAVEREGS\n         AP    OUTCT4,PACKONE    ADD 1 TO NON-MATCHED COUNT\n         SPACE 1\nREADCRD2 L     R1,ASYSIN   GET SYSIN DCB ADDR\n         GET   (R1)\nAFTEREAD ST    R1,CARDADDR\n         SPACE 1\nEXITBRI2 B     NOEXITI2   CHANGED TO NOP IF EXIT POINT I2 REQUESTED\n         L     R15,=A(EXTEPAI2)   GET EXIT I2 ENTRY POINT\n         L     R15,0(R15)\n         LA    R1,CARDADDR        SET UP PARAMETER LIST\n         BALR  R14,R15            EXECUTE I2 EXIT\n         L     R1,CARDADDR      RESET R1 TO CONTAIN REC ADDR\n         C     R15,FULL4          CHECK RETURN CODE\n         BL    NOEXITI2 RC=0   CONTINUE NORMAL PROCESSING\n         BE    GETCARD  RC=4  DELETE THIS RECORD-GET NEW SYSIN\n         MVI   EXITBRI2+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT\nNOEXITI2 EQU   *\n         CLI   VSAMFLAG,C'1'   IS VSAMKEY DDNAME BEING USED\n         BNE   VSETNOP         NO\n         MVI   VSMPOINT+1,SETNOP FOR VSAMKEY RESET NOP TO REPOSITION\n         SPACE 3\nVSETNOP  B     MOVECARD       NOP IF V= OPTION REQESTED ON A,M  T\n         A     R1,VPOSLENS      ADD P1 TO REC ADDR\nVSET1    MVC   0(0,R9),0(R1)      MOVE IN 1ST L,P INTO INCARD\n         SPACE 1\nCNVRTVB1 B     VBR1      SET TO NOP IF CONVERT FILE PRESENT\n         L     R15,=A(CNVRTABL)\nVSETTR1  TR    0(0,R1),0(R15)\n         SPACE 1\nVBR1     B     TRNSCARD        NOP IF 2 OR MORE L,P'S\n         A     R1,VPOSDISP      ADD P2 TO REC ADDR\nVSET2    MVC   0(0,R9),0(R1)     MOVE IN 2ND L,P INTO INCARD\n         SPACE 1\nCNVRTVB2 B     VBR2      SET TO NOP IF CONVERT FILE PRESENT\nVSETTR2  TR    0(0,R1),0(R15)\n         SPACE 1\nVBR2     B     TRNSCARD        NOP IF 3 L,P'S\n         A     R1,VPOSDISP+4           ADD P3 TO REC ADDR\nVSET3    MVC   0(0,R9),0(R1)     MOVE IN 3RD L,P INTO INCARD\n         SPACE 1\nCNVRTVB3 B     TRNSCARD  SET TO NOP IF CONVERT FILE PRESENT\nVSETTR3  TR    0(0,R1),0(R15)\n         SPACE 1\nTRNSCARD B     RETURNCD        BRANCH AROUND THE FOLLOWING DEFAULT MOVE\n         L     R15,=A(TRNSTAB5)   LOAD ADDRESS OF TRANLATE5 INTO R15\nYTRNSLT2 TR    0(0,R9),0(R15)    TRANSLATE THE SYSIN KEY ON V= OPTION\n         B     RETURNCD\n         SPACE 1\nMOVECARD MVC   INCARD,0(R1)\nRETURNCD AP    RCOUNT,PACKONE  ADD 1 TO NO OF SYSIN CARDS READ\nNOPGETBR BR    GOREG     SET TO NOPR ON VP=\n         SPACE 1\n         L     R15,=A(TRNSTAB2)  GET NUMERIC TEST TABLE\nVPNUMTST TRT   0(0,R9),0(R15)    DO NUMERIC TEST ON SYSIN KEY\n         BC    5,GETCARD  SYSIN KEY NOT NUMERIC - GET NEXT SYSIN KEY\n         BZ    VPPACK    KEY IS NUMERIC - GO PACK IT\n         CLM   R2,1,FULL1+3   IS FUNCTION BYTE =X'01' I.E. NUMERIC\n         BNE   GETCARD    NO - KEY NOT NUMERIC\nVPPACK   PACK  WORKFLD1,0(0,R9)   PACK THE KEY , LENG ADJUSTED\n         MVC   INCARD(8),WORKFLD1 MOVE PACKED KEY TO INCARD FOR CP\n         BR    GOREG\n         TITLE 'WRITE SYSUT2 AND PRINT ROUTINES'\nPUTFILE  NOP   NOPUT1      CHANGED TO BRANCH TO BYPASS WRITING SYSUT2\n         MVI   SYSUTX,C'2'\nEXITBRO1 B     NOEXITO1   CHANGED TO NOP IF EXIT POINT O1 REQUESTED\n         L     R15,=A(EXTEPAO1)   GET EXIT O1 ENTRY POINT\n         L     R15,0(R15)\n         LA    R1,PUTADDR         SET UP PARAMETER LIST\n         BALR  R14,R15            EXECUTE O1 EXIT\n         C     R15,FULL4          CHECK RETURN CODE\n         BL    NOEXITO1 RC=0   CONTINUE NORMAL PROCESSING\n         BE    NOPUT2   RC=4  DELETE THIS RECORD-DONT WRITE SYSUT2\n         MVI   EXITBRO1+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT\nNOEXITO1 EQU   *\n         L     R2,DCBADDR\n         L     R1,AOUTFIL\n         L     R0,PUTADDR  LOAD ADDR OF ISAM/INFIL REC AREA INTO R0\nSKIPPUT2 NOP   PRINT2\n         PUT   (R1),(R0)     PUT OUT A RECORD TO SYSUT2\nPRINT2   ST    GOREG,SAVEREGS\nPRNT2BAL NOP   PRINTLK    CHANGED TO BAL GOREG,PRINTLK ON SYSOUT\nLIBOTBAL NOP   LIBOTRTN   CHANGED TO BAL GOREG,LIBOTRTN ON LIBOUT\nVSOUTBAL NOP   VSOUTRTN   CHANGED TO BAL GOREG,VSOUTRTN ON VSAMOUT\n         L     GOREG,SAVEREGS\nNOPUT1   AP    OUTCT,PACKONE    ADD 1 TO NO OF RECORDS OUTPUT TO SYSUT2\nNOPUT2   MVI   SYSINFLG,C'1'\nMEMBMSG  B     NOPFMEMB    SET TO NOP IF MEMBNAME IS DUMMY OR MEMSYSIN\n         SPACE 1\n         L     R1,=A(BLDENTRY)  GET MEMBER NAME\n         CLI   MSG93MEM,BLANK1  IS MEMBNAME BLANK I.E. FIRST MEMBER\n         BE    FIRSTREC         YES\n         CLC   MSG93MEM,0(R1)   NO - SAME AS PREV MEMBER\n         BNE   MEMMSGPT         NO - PRINT MSG\n         AP    MEMRECCT,PACKONE YES ADD 1 TO RECORDS IN MEMBER\n         B     NOPFMEMB         RETURN\nMEMMSGPT ED    MSG93ED,MEMRECCT+3  EDIT THE NUMBER OF RECS\n         ST    GOREG,SAVEREGS   SAVE R8 WHICH IS USED IN MESSAGE MACRO\n         MESSAGE 93     PUT OUT MESSAGE\n         L     GOREG,SAVEREGS\n         MVC   MSG93ED,MSGMASK   RESET MSG MASK\n         L     R1,=A(BLDENTRY)  GET MEMBER NAME\nFIRSTREC MVC   MSG93MEM,0(R1)    PUT IN NEW MEMBER NAME\n         ZAP   MEMRECCT,PACKONE   RESET COUNT TO ONE\n         SPACE 2\nNOPFMEMB BR    GOREG   SET TO NOPR WHEN MEMBNAME IS WRITTEN ON LIBFILE\n         SPACE 1\n         L     R0,=A(BLDENTRY)   GET MEMBER NAME\n         L     R1,AMEMBNAM       GET  MEMBNAME DCB\n         PUT   (R1),(R0)     WRITE MEMBNAME RECORD\n         BR    GOREG\n         SPACE 2\nPRINTLK  L     R15,=A(PRINTER)   LOAD ADDR OF PRINT ROUTINE\n         BALR  R14,R15           BRANCH AND TO PRINT ROUTINE\n         BR    GOREG\n         SPACE 2\nLIBOTRTN L     R1,ALIBOUT      LOAD DCB ADDR INTO R1\n         L     R15,=A(LIBCSECT)  DO LIBOUT WRITE RTN\n         BALR  R14,R15\nLIBOTEOJ C     R15,FULL4       WAS WRITE SUCCESSFUL\n         BH    LIBOUTER        NO         RC>4 END ON ERROREOJ\n         BE    LIBOTDUP     DUPLICATE MEMBER NAME-CONTINUE PROCESSING\n         BR    GOREG           YES - RETURN\n         SPACE 2\nVSOUTRTN ST    GOREG,WORKFLD1   SAVE GOREG REG- NEED IT IN MODCB\n         L     R2,VSOUTRPL      GET VSAMOUT RPL ADDR\n         L     R8,PUTADDR       PUT OUTPUT REC ADDR IN R8\n         CLI   VSAMFLAG,C' '    IS INPUT VSAMFILE/KEY\n         BNE   SKPSEQIN         YES- SKIP RECFM DETERMINATION\n         CLI   MSG40FVU,C'F'    NO- IS RECFM=F\n         BE    SKPLRECL         YES-SKIP GETTING INPUT LRECL\n*                         GOTTEN FROM MODCB  IN VSAMSECT\n         CLI   MSG40FVU,C'V'    NO-IS RECFM=V(SPANNED OK IF BFTEK=A)\n         BNE   RECFMERR         ALLOW ONLY RECFM=F OR V AS INPUT\n         LH    R0,0(R8)         GET RDW\n         S     R0,FULL4         SUBTRACT 4 FOR ACTUAL DATA PORTION LENG\n         A     R8,FULL4         SET BUFFER IN OUTREC BEYOND RDW\n         B     MODLRECL         MODIFY RECLEN\n         SPACE 1\nSKPSEQIN L     R0,VSAMRECL      RECLEN OF VSAMXXX INPUT FILE\n*        GET RECLEN OF INPUT VSAMKEY-SEE VSAM ADMIN:MACRO INSTR D P.164\n*        AND PUT IT INTO VSAMOUT RPL\nMODLRECL LR    R1,R2         PUT VSAMOUT RPL IN R1\n         L     R15,16           CVT ADDR IN R15\n         L     R15,256(R15)     AMCBS CONTROL BLOCK ADDR IN R15\n         L     R15,12(R15)   CONTROL BLOCK MANIPULATION RTN ADDR IN R15\n         BAL   R14,80(R15)   BRANCH TO THE RTN TO STORE LRECL IN RPL\n         SPACE 1\nSKPLRECL MODCB RPL=(R2),AREA=(R8)   MODIFY VSAMOUT RPL\n         L     GOREG,WORKFLD1   RESTORE GOREG\n         PUT   RPL=(R2)         WRITE VSAMOUT REC\n         C     R15,FULL8\n         BE    VSAMDUP   RC=8 MEANS TRYING TO STORE A REC WITH DUP KEY\n         BH    VSAMOTER  ERR- DO SHOWCB AND GET FDBK CODE FOR VSAMOUT\n         BR    GOREG     RC=0 (RC=4 ONLY HAPPENS ON GET EODAD) OK\n         SPACE 2\nVSAMDUP  SP    OUTCT,PACKONE   ADJUST OUTPUT CNT-NOT WRITING DUP REC\nVSAMDUP2 NOPR  GOREG         SET TO BRANCH AFTER 1ST TIME\n         OI    VSAMDUP2+1,X'F0'  TO WRITE WARNING MESSAGE\n         ST    GOREG,WORKFLD1    SAVE GOREG REG\n         LNKMSG 52\n         L     GOREG,WORKFLD1    RESTORE GOREG\n         BR    GOREG\n         SPACE 1\nLIBOTDUP MVI   MSG93ED,C'*'            MEMBER NOT REPLACED MESSAGE\n         MVC   MSG93ED+1(9),MSG93ED\n         SP    OUTCT,MEMRECCT         ADJUST OUTPUT REC TOTAL IN MSG4\n         B     VSAMDUP2\n         TITLE 'END-OF-KEYS ROUTINES'\nENDKEYS  L     R1,PRINTBUF   GET R1 READY FOR PRINTING AT END OF SYSIN\n         CP    RCOUNT,PACKZERO    WAS SYSIN EMPTY\n         BE    SYSINNG            YES\n         CLI   KEYMSG,C'O'     ARE WE PROCESSING 'O' KEYS\n         BE    SYSINNG           YES-ERROR,NOT ENOUGH SYSIN CARDS\n         SPACE 2\nENDKEYT  B     ENDKEYT1   THIS IS SET TO A NOP DURING T,G,P,E LOGIC\n         ST    R7,TABLEND      STORE THE ADDR OF THE END OF THE TABLE\n         CLI   KEYINDIC,C'1'   WERE THERE AN ODD NO OF SYSIN KEYS ON G\nPLOGNOP  BE    GERROR         YES-ERROR,SET TO NOP ON P OPT\n         L     R1,TABLE     GET ADDRESS OF SYSIN KEY TABLE\n         MVC   ECHGKEY(20),0(R1) MOVE FIRST SYSIN KEY\n*        FOR E OPTION WITH A CHANGE KEY CODED IN CONVERT FILE\n         MESSAGE 36,EDIT=RCOUNT+5,BRANCH=GETINPUT\nENDKEYT1 CP    ENDCT,END     DID PROCESSING END DUE TO E= PARM\n         BH    SYSUT3OP     YES-FINISH THE SYSUT1 FILE IF NECESSARY\n         CLI   ENDPARMS,C'2'     HAS THE SYSUT1 FILE ALREADY ENDED\n         BE    MMSG                 YES\nSYSUT3OP CLI   SYSINDCB+1,SETBR  NO -IS V= REQUESTED  A AND M OPTIONS\n         BNE   SKIPVEQU             NO\n         CLI   CLS2NOP+1,SETNOP  YES-IS SYSUT3 OPEN\n         BNE   MMSG                 NO\n         MVI   SETBRONV+1,SETBR   YES-IGNORE E= PARAMETER\n         MVI   BR4+1,SETNOP      SET NOPS TO WRITE ALL THE REST OF\n         MVI   BR6+1,SETNOP      THE SYSUT1 RECORDS TO SYSUT3\n         MVI   ENDPARMS,C'2'       SET SYSIN ENDED FLAG\n         MVC   AGETCRD1(2),=X'4700' CHANGE BACK TO NOP\n         MVC   INCARD,HIGHV SET SYSIN TO X'FF' FOR VSAMKEY TO END IMMED\n         CLI   NOPONVP+1,SETNOP    IS VP= BEING USED\n         BNE   HIGHVOK             NO\n         MVC   INCARD(15),=P'999999999999999'  YES - USE NUMERIC HIGHV\nHIGHVOK  CP    PASSCT,PACKZERO  WAS SYSIN KEY KICKED BECAUSE CNT SATISF\nEEQUNOP  BE    GETINPUT     YES-DO NOT WRITE PREVIOUS SYSUT1 REC\n         B     STARTPRC     NO-WRITE PREVIOUS SYSUT1 REC TO SYSUT3\n*        BRANCH BACK TO STARTPRC IN CASE ENCRYPTION REQUIRED FOR KEYS\n         SPACE 2\nSKIPVEQU CLI   LSKIP1+1,SETBR    IS THIS THE LONG SUBOPTION ON M OPT\n         BNE   NOTLOPT                       NO\n         NI    SKIPPRNT+1,X'0F'\n         ZAP   PASSCT,TOTPASCT\n         ZAP   OUTCT,TOTOUTCT\n         BAL   GOREG,KEYREPT     YES -PRINT OUT TOTAL LINE\nNOTLOPT  LNKMSG 6                 'END OF KEYS BEFORE END OF INFILE'\n         CLI   REXTLOG+1,SETBR   IS THIS AN R OPTION\n         BNE   NOTROPT           NO\nRNDMEND  MVI   MSG5FLAG,X'53'     SET UP BLANK LINE FOR FINISH MSG\n         B     ENDINF\n         SPACE 2\nNOTROPT  CLI   KEYINDIC,C'1'   DID END OF KEY OCCUR AFTER LOW KEY ON B\n         BNE   NOTMN      N0- CONTINUE WITH END MN ROUTINE\n         MVC   INCARD1,HIGHV     MOVE HIGH VALUES TO 2ND KEY\n         MVC   MSG29UKY(11),HIGHVALU MOVE HIGH VALUE MSG\n         MVI   ENDBKEY+1,SETBR   SET TO BRANCH TO GO TO EOJ\n         B     BYPTRNSL\n         SPACE 2\nNOTMN    B     EOJ           SET NOP IF MN\n         MVI   BR5A+1,SETBR  SET B FOR END OF JOB ON MN\n         MVI   ORENDCNT+1,SETNOP PUT 'COUNT SATISFIED' MESSAGE\n         MVI   MNSTOP+1,SETNOP  STOP PROCESSING ON MN WHEN 'HIGH VALUE'\n         MVI   MNPUTBR+1,SETBL    REACHED AND COUNT SATISFIED\n         MVI   KEYREPT1+1,X'10'   SET TO PRINT 'HIGH VALUES'\n         MVC   INCARD,HIGHV     FILL INPUT AREA WITH HIGH VALUES\n         B     COMPKEY\n         TITLE 'END-OF-INPUT ROUTINES - T,P MESSAGES'\nENDINPUT L     R1,PRINTBUF  INIT R1 WITH ADDR OF PRINTBUF FOR END ROUTN\n         CLI   MEMBMSG+1,SETNOP WAS MEMBNAME DUMMY OR MEMSYSIN CODED\n         BNE   NOMEMMSG       NO\n         ED    MSG93ED,MEMRECCT+3   YES\n         MESSAGE 93\nNOMEMMSG EQU   *\n         SPACE 2\n         CLI   MSG5FLAG,X'50' IS V= REQUESTED ON A OR M OPTION W SYSIN\n         BNE   TTOTRPRT         NO- NORMAL EOJ\n         CLI   ENDPARMS,C'2' HAS SYSIN FILE ALREADY ENDED ON A OR M OPT\n         BE    MMSG                 YES-GO TO PUT OUT M MSG\n         CLI   SYSINFLG,C'1' IS THE LAST SYSIN REC WAITING TO BE WRITTN\n         BE    LASTSYSN         YES\n         CLI   CLS4NOP+1,SETNOP NO-HAS SYSUT5 BEEN OPENED ON A,M,V=\n         BE    LASTSYSN         YES- FINISH PROCESSING SYSIN\n         CLI   ENDFLAG,X'51'    NO-  DID PROCESSING END DUE TO E=\n         BNE   TTOTRPRT         NO-  GO TO NORMAL END\n         MVI   EEQUNOP+1,SETNOP YES- NOP THE B TO GETINPUT\n         B     SYSUT3OP         GO FINISH PUTTING OUT SYSUT3 (IF OPEN)\n         SPACE 2\nLASTSYSN MVI   ENDPARMS,C'2'    YES-SET FLAG TO INDICATE END OF INFILE\n         MVI   EEQUNOP+1,SETNOP NOP THE B TO GETINPUT IN CASE OF E=PARM\n         BAL   GOREG,KEYREPT    PUT OUT LAST DETAIL MSG\nLOOP     BAL   GOREG,GETCARD    GET A NEW SYSIN RECORD\n         B     LOOP             FINISH SYSIN FILE-NO MORE MATCHES\n         SPACE 2\nTTOTRPRT B     BMSG         BYPASS THE T REPORT\n         L     R7,TABLE        LOAD THE ADDR OF FIRST TABLE ENTRY\n         CP    COMPCNT,OUTCT   IS THE TABLE FULL\n         BNE   TMSG            NO\n         EX    0,KCNTSAT      YES-PUT OUT 'CNT SATISFIED ' MSG\nTMSG     C     R7,TABLEND   ARE WE AT THE END OF THE TABLE\n         BNL   ENDINF        YES IT IS THE END OF THE KEY'S\n         SPACE 1\nEMSG     NOP   EKEYMSG       CHANGED TO B ON E OPT\nPMSG     B     TKEYSEL       CHANGED TO NOP ON P OPTION\nPMSGED   L     R9,0(0,R7)    GET BINARY COUNT FIELD (DISPLACEMENT ADJ)\n         CVD   R9,PACKFLD        CONVERT COUNT TO DECIMAL\n         ED    MSG29OUT,PACKFLD+3  EDIT THE COUNT-DISPLAC ADJUSTED\n         MVC   MSG29LKY,MSGSPACE   SPACE OUT THE LOWER KEY(LOW VALUES)\nPLVMSG   CLC   0(0,R7),LOWVALUE  IS FIRST CARD 'LOW VALUES'-LENG ADJUST\n         BNE   LKYNOTLV            NO\n         MVC   MSG29LKY(10),LOWVMSG  YES-MOVE IN 'LOW VALUE' MSG\n         B     CHKUKY                CHECK UPPER KEY\n         SPACE 1\nLKYNOTLV MVC   MSG29LKY,0(R7)  MOVE IN LOWER KEY FOR PRINT-LENGTH ADJ\nCHKUKY   CLC   0(0,R7),HIGHV IS UPPER KEY HIGH VAL-LENG & DISPLAC ADJ\n         BNE   UKYNOTHV                  NO\n         MVC   MSG29UKY(11),HIGHVALU    YES-MOVE IN HIGH VALUES TO MSG\n         B     UKYHV                 HIGH VALUES IS THE LAST SYSIN CARD\n         SPACE 1\nUKYNOTHV MVC   MSG29UKY,0(R7)       MOVE IN UPPER KEY\nUKYHV    AR    R7,R5                 POINT TO NEXT PAIR OF KEYS\n         MESSAGE 29                  WRITE MSG FOR THIS PAIR\n         MVC   MSG29OUT,MSGMASK\n         B     TMSG\n         TITLE 'END-OF-INPUT ROUTINES - T,G AND E MESSAGES'\nEKEYMSG  CLI   0(R7),X'FF'      HAS AN INVALID KEY BEEN ENCOUNTERED\n         BNE   EKEYMSG2            NO\n         MVI   TKEYMSG+1,X'14'  YES -PRINT OUT 20 CHARACTERS OF THE KEY\n         MVC   MSG21ED(9),=C'KEY ERROR'   PRINT ERROR MESSAGE\n         B     TKEYMSG     BYPASS EDITING THE COUNT -JUST PRINT THE KEY\n         SPACE 1\nEKEYMSG2 B     ENDINF   SET TO NOP WHEN SYSUT1 IS NOT NULLFILE\n         SR    R9,R9          CLEAR R9\n         IC    R9,0(0,R7)    INSERT LENGTH OF KEY IN R9\n         CLI   19(R7),C'#'   IS THIS AN 'AND' KEY\n         BNE   EMSGCONT      NO\n         SR    R1,R1         YES\n         IC    R1,1(R9,R7)   GET LENGTH OF SECOND KEY IN R1\n         LA    R9,1(R1,R9)   R9=L1+L2+1\nEMSGCONT STC   R9,ECHGMSGM+1 ADJUST MOVE INSTRUCT WITH LENGTH FOR E CHG\n         LA    R9,1(R9)    ADD 1 TO LENGTH TO PRINT KEY & 2 DELIMITERS\n         STC   R9,TKEYMSG+1  ADJUST MOVE INSTRUCT WITH LENGTH\n         IC    R9,0(R9,R7)   INSERT DELIMITER INTO R9\n         STC   R9,0(0,R7)  PUT DELIMITER BACK INTO 1ST POSITION OF KEY\n         MVC   MSG21KEY,MSGSPACE  CLEAR OUT PREVIOUS KEY\n         SPACE 3\nECHGMSG  B     TKEYSEL  CHG TO NOP IF E OPTION & CHANGE KEY($) IN CNVRT\n         MVI   ECHGMSG+1,SETBR  SETBACK TO B AFTER 1ST TIME THRU\n         L     R1,=A(ECHGCNT)  GET NUM OF KEYS CHANGED FROM E CSECT\n         ED    MSG88CNT,0(R1)  EDIT COUNT INTO MSG\nECHGMSGM MVC   MSG88KEY,0(R7)  PLACE SYSIN KEY INTO MSG\n         MVI   MSG88KEY,BLANK1 BLANK OUT FIRST DELIMITER\n         MVC   MSG88CHG,ECHGKEY+20  PLACE CONVERT KEY INTO MSG\n         MESSAGE 88       PRINT MESSAGE\n         SPACE 3\nTKEYSEL  L     R9,20(0,R7)    GET BINARY COUNT FLD;DISPACEMENT ADJUSTED\n         CVD   R9,PACKFLD\n         ED    MSG21ED,PACKFLD+3\nTKEYMSG  MVC   MSG21KEY,0(R7)    MOVE IN THE KEY TO THE MESSAGE-LEN ADJ\n         AR    R7,R5    BUMP TO THE NEXT TABLE ENTRY\n         B     OMSG          LOOP TO PUT OUT KEY'S AND COUNTS FOR T\n         TITLE 'END-OF-INPUT ROUTINES - O,Q,F,D,R,B,A AND M MESSAGES'\nBMSG     B     ONLY1OR            CHANGED TO NOP ON B KEY\n         MVI   ENDBNOP+1,SETNOP   SET NOP\n         B     LASTBKEY\n         SPACE 1\nONLY1OR  B     SEQMSG1            NOOPED IF  OR OPTION\n         ED    MSG21ED,COMPCNTA+3\nOMSG     MESSAGE 21\n         MVC   MSG21ED,MSGMASK    EDIT MASK IS RESET\nFREQMSG  NOP   FMOVE              SET TO B ON F,J=0\nFJEQ0BR  NOP   FMSG               SET TO B ON F,J=0 AFTER LAST MSG\nTMSGBR   NOP   TMSG               SET TO B ON T,G,E OPTIONS\nONLY2OR  B     ONLY3OR            NOOPED IF 2 KEYS ON OR OPTION\n         MVC   MSG21KEY,MSGSPACE  CLEAR MESSAGE KEY\nOKEYMSG2 MVC   MSG21KEY,INCARD1  MOVE IN THE 2ND KEY FOR 'O' MSG\n         ED    MSG21ED,COMPCNTB+3\n         MVI   ONLY2OR+1,SETBR\n         B     OMSG\nONLY3OR  B     SEQMSG1            NOOPED IF 3 KEYS ON OR OPTION\n         MVC   MSG21KEY,MSGSPACE  CLEAR MESSAGE KEY\nOKEYMSG3 MVC   MSG21KEY,INCARD2   MOVE IN 3RD KEY FOR 'O' MSG\n         ED    MSG21ED,COMPCNTC+3\n         MVI   ONLY3OR+1,SETBR\n         B     OMSG\n         SPACE 1\nSEQMSG1  B     FMSG     CHANGED TO NOP FOR SEQUENCE ERR ON QKEY\n         CLI   KEYMSG,C'9'        FLAG INDICATING THERE WAS AN ERROR\n         BE    QTOTRECS           BYPASS SUCCEEDING MSG\n         LNKMSG 19\nQTOTRECS LNKMSG 25,EDIT=PASSCT+3,BRANCH=EOJ\n         SPACE 1\nFMSG     B     DMSG  IF KEY NOT F,BYPASS  F MESSAGE PRINTOUT\n         CLI   FREQMSG+1,SETBR    IS THIS F,J=0 THE FREQUENCY OPTION\n         BNE   NOTFREQU            NO\n         MVI   FREQMSG+1,SETNOP ALLOW FALL THRU AFTER PRINTING LAST MSG\n         MVI   BYP2MSGS+1,SETBR  SKIP LAST 2 F MESSAGES\n         MVI   FJEQ0BR+1,SETBR  SET A BRANCH AFTER LAST MSG\n         CP    ENDCT,PACKZERO   IS SYSUT1 EMPTY (NULLFILE)\n         BE    NOTFREQU         YES-GET OUT AND PRINT END MESSAGE\n         B     BR2PRTF            NO- GO BACK TO PRINT LAST MSG\nNOTFREQU LNKMSG 30,EDIT=TOTLKEYS+3\nBYP2MSGS NOP   DMSG                  SET TO B ON F,J=0\n         LNKMSG 31,EDIT=KEYLESS+3\n         LNKMSG 32,EDIT=KEYMORE+3\n         SPACE 1\nDMSG     B     RMSG           CHANGED TO NOP ON D KEY\n         CLI   KEYMSG,C'8'    WAS KEY FOUND ON D OPTION\n         BE    DMSGOUT                YES-BRANCH TO PUT OUT D MSG\n         LNKMSG 24,BRANCH=EOJ   'KEY NOT FOUND'\n         SPACE 1\nRMSG     B     REXTMSG          NOP ON R KEY-SKIPPED ON R EXTENDED OPTS\n         MVI   RENDBR+1,SETBR   SET BR TO COME BACK TO ENDINF\n         CP    OUTCT,RCOUNT     WAS COUNT SATISFIED\n         BNE   RMSGOUT          NO-PUT OUT MSG FOR 3RD GROUP\n         CP    RCOUNT,PACKZERO  IS THE FILE EMPTY\n         BE    ENDINF            YES\n         EX    0,KCNTSAT       YES-MOVE 'CNT SATISFIED' MSG\n         SPACE 1\nREXTMSG  NOP   RPUT     SET TO BR ON R OPT WITH 'LAST' REC REQUESTED\nMMSG     B     ENDINF\n         NI    SKIPPRNT+1,X'0F'  RESET NOP TO PRINT TOTAL LINE\n         AP    TOTPASCT,PASSCT  IF KEYS ENDED 1ST ADD REST OF INPUT\n         AP    TOTOUTCT,OUTCT  IF INPUT FILE ENDS ON A MATCH ADD RECS\n         ZAP   PASSCT,TOTPASCT      RESTORE PASSCT AND OUTCT\n         ZAP   OUTCT,TOTOUTCT            FOR PRINTING\nENDINF   B     BYPENDF NOP IF A,C,D,E,F,K,R,O,P,T,Q,B,G,C=,N=,P=,X=\n         CP    COMPCNT,COUNT  WHEN EOF HAPPENS ANDTHE KEYS REMAINED\n         BNL   KEYLESOK    EQUAL & THE RECORD COUNT IS LESS THAN THE\n         AP    KEYLESS,PACKONE  PARM COUNT 1 MUST BE ADDED TO KEYLESS\nKEYLESOK MVC   MSG4+9(5),MSGSPACE BLANK OUT 'KEY=' MSG\n         MVC   INCARD,MSGSPACE\nBYPENDF  BAL   GOREG,KEYREPT      PRINT REPORT LINE ON LAST KEY\nENDFILE  CLI   ENDFLAG,X'51'   DID PROCESSING END DUE TO E=\n         BE    ENDMSG    YES\n         CLI   VSAMFLAG,C'1'   IS VSAMKEY DDNAME USED\n         BE    EOJ             YES- SKIP PUTTING OUT END MSG\nPUTMSGR5 IC    R5,MSG5FLAG  NO-LOAD R5 WITH PROPER MSG.DEFAULT=MSG 5\n         LNKMSG  R5\n         SPACE 3\nEOJ      B     CLS2NOP      SET TO NOP IF LIBOUT REQUESTED\n         CLI   MSG5FLAG,X'52'   WAS COUNT SATIFIED MSG PRTED (MSG 82)\n         BNE   LIBCONT          NO\n         L     R1,=A(BLDENTRY)  YES- STOW THE LAST MEMBER\n         MVC   0(8,R1),HIGHV    SET DIRECTORY ENTRY TO X'FF' (LAST)\n         BAL   GOREG,LIBOTRTN   PERFORM LIBOUT RTN\nLIBCONT  L     R1,=A(MEMBCNT)   GET COUNT OF NUM MEMBERS CREATED\n         MVC   MEMCOUNT,0(R1)\n         LNKMSG 94,EDIT=MEMCOUNT+3    PUT OUT MSG\nCLS2NOP  B     CLS3NOP   THIS IS A SWITCH THAT IS NO-OPED IF SYSUT3\n         LNKMSG 33,EDIT=OUTCT2+3        IS CODED\nCLS3NOP  B     CLS4NOP\n         LNKMSG 48,EDIT=OUTCT3+3\nCLS4NOP  B     SKIPCLS\n         LNKMSG 49,EDIT=OUTCT4+3\nSKIPCLS  L     R2,DCBADDR\n         CLI   GETLIB+1,SETNOP  WAS INPUT FILE LIBFILE\n         BNE   CLOSE            NO\n         MVI   DSORG(R2),X'40'  YES- RESET DSORG TO PS FOR EARLY END\nCLOSE    MVI   KEYMSG,C'0' CLEAR OUT FLAG FOR PROPER CLOSE ON D OPTION\n         L     R15,=A(DCBCSECT)   CLOSE ALL DCBS\n         BALR  R14,R15\n         SPACE 2\n         L     R2,SAVESPIE\n         SPIE  MF=(E,(2))    RESET THE OLD SPIE AND ESTAE ENVIRONMENTS\n         ESTAE 0\n         SPACE 2\nEXIT     LH    R2,SETRC+2     PUT RC IN R2 (NEEDED FOR POSSIBLE ABE)\n         LR    R5,R2          PUT RC IN R5 (FOR RC=ABEND,DUMP)\n         LTR   R2,R2          IS RC=0?\nSETRCDMP NOP   RCDUMP SET TO BNZ TO BOMB ON NON-0 RC WHEN RC=ABEND,DUMP\nSETRCABE NOP   RCABEND     SET TO BNZ TO BOMB ON NON-0 RC WHEN RC=ABEND\n         SPACE\n         L     R13,SAVEAREA+4\n         LM    R14,R12,12(R13)\nSETRC    LA    R15,0              ERR RC=8 SET HERE FROM EOJERR\n         BR    R14\n         SPACE 2\nNOSYSPRT L     R15,=A(DYNALLOC)   LOAD ADDRESS OF DYNALLOC CSECT\n         BALR  R14,R15            BRANCH TO CSECT\n         LTR   R15,R15      WAS SYSPRINT DYNAMICALLY ALLOCATED\n         BZ    SYSPRINT     YES\n         MVI   SETRC+3,X'FF' SET RETURN CODE TO 255 IF SYSPRINT MISSING\n         B     EXIT                   GET OUT\n         SPACE 1\nDEFAULT  LA    R5,5        PUT PARM LENGTH OF 5 IN R5\n         MVC   2(5,R3),=C'R,1,1'  PLACE DEFAULT R,1,1 OPTION IN PARM\n         LNKMSG 7,BRANCH=PRNTPARM\n         SPACE 3\nENDMSG   LNKMSG 81    PUT OUT MSG81, PROCESSING ENDED DUE TO E=\n         CLI   MSG5FLAG,X'05'  ANY OTHER NON-STANDARD END CONDITION\n         BNE   PUTMSGR5    YES - PUT OUT THAT MSG ALSO\n         B     EOJ         NO\n         TITLE 'CLASS TEST ROUTINES'\n*        CLASS TEST ROUTINE AND RTN TO DO PACKED COMPARES FOR VP=\n*        ON VP= WHEN PACKED FIELD IS NOT LEGITIMATELY PACKED THE\n*        BRANCH TO SETINVAL WHICH CREATES A NOP COND CODE\n*        WHICH WILL CAUSE A READ OF A NEW SYSUT1 KEY -- GOOD\n*\nLOWVTST  EX    R4,EXLOW           EXECUTE THE LOW VALUES TEST\n         BNE   GOHIGHV            LOW VALUES NOT FOUND\n         B     MAINLIN1           RETURN TO AFTER CLC\nHIGHVTST EX    R4,EXHIGH          EXECUTE THE HIGH VALUES TEST\n         BNE   GOALPHB            HIGH VALUES NOT FOUND\n         B     MAINLIN1           RETURN TO AFTER CLC\nALPHBTST L     R15,=A(TRNSTAB1)    LOAD THE ADDRESS OF TRNSTAB1 TO R15\n         EX    R4,TRNSLATE        R4=LENGTH-1,EXECUTE ALPHABETIC TEST\n         BNZ   GONUMER            BRANCH BACK IF COND CODE NOT=0\nMATCH    MVI   OUTPTKEY,C'Y'      FLAG INDICATES MATCH\n         B     OUTPTTST           RETURN TO MAIN ROUTINE\nNUMERTST L     R15,=A(TRNSTAB2)    LOAD THE ADDRESS OF TRNSTAB2 TO R15\n         EX    R4,TRNSLATE        EXECUTE NUMERIC TEST\n         BC    5,GOALPHN          BRANCH BACK IF COND CODE NOT=0 OR 2\n         BZ    MATCH              COND CODE=0 MEANS KEY IS NUMERIC\n         CLM   R2,1,FULL1+3    IS LAST FUNCTION BYTE = 1\n         BNE   GOALPHN            NO\n         B     MATCH              YES-KEY IS SIGNED NUMERIC\nALPHNTST L     R15,=A(TRNSTAB4)    LOAD THE ADDRESS OF TRNSTAB4 TO R15\n         EX    R4,TRNSLATE        EXECUTE ALPHANUMERIC TEST\n         BNZ   GOPACK          BRANCH BACK IF COND CODE NOT = 0\n         B     MATCH           YES\nPACKTST  L     R15,=A(TRNSTAB3)    LOAD THE ADDRESS OF TRNSTAB3 TO R15\n         EX    R4,TRNSLATE     EXECUTE PACK TEST\n         BC    X'D',SETINVAL   THE PACK TEST MUST RETURN A X'01'\n         CLM   R2,1,FULL1+3   F BYT AS THE LAST BYTE TO INDIC A SIGN\n         BNE   SETINVAL        SIGN BYTE NOT FOUND\nPEQULNOP B     MATCH    NOP WHEN 'P=' KEY OPTION OR VP= REQ\n         SLL   R4,4     SHIFT LENG TO HIGH ORDER HALF-BYTE FOR CP INSTR\n         EX    R4,EXPEQUAL     EXECUTE THE COMPARE PACK TEST\n         SRL   R4,4     RESTORE LENGTH   - DONT CHG CONDITION CODE\n         B     MAINLIN1        RETURN TO AFTER THE CLC\nNEQUTEST L     R15,=A(TRNSTAB2)    LOAD THE ADDRESS OF TRNSTAB2 TO R15\n         EX    R4,TRNSLATE     IS INPUT KEY NUMERIC\n         BC    5,SETINVAL      NO\n         BZ    PACKNUMB        YES\n         CLM   R2,1,FULL1+3   IS FINL 1/2-BYTE A LEGITIMATE SIGN\n         BNE   SETINVAL            NO\nPACKNUMB EX    R4,EXNEQUAL   PACK THE NUMERIC INPUT KEY\n         CP    WORKFLD1,INCARD(8)  COMPARE PARM KEY TO FILE KEY PACKED\n         B     MAINLIN1  RETURN TO AFTER THE CLC\n         SPACE 2\nSETINVAL CLI   FULL1+3,X'02' SET NOT EQUAL CONDITION. ACTUALLY BL WILL\n*              BE TRUE SO THAT S,P=> OR S,N=> OR M,VP= WILL NOT CAUSE\n*              THE SYSUT1 RECORD TO BE SELECTED. SETINVAL MODIFIED\n*              TO BH TRUE WHEN S,P=< OR S,N=<.\n         B     MAINLIN1     RETURN\n         SPACE 2\nTRNSLATE TRT   0(0,R3),0(R15)  R3=ADDR OF KEY. R15=ADDR OR APPROP TABLE\nEXLOW    CLC   0(0,R3),LOWVALUE COMPARE TO LOWVALUES\nEXHIGH   CLC   0(0,R3),HIGHV    COMPARE TO HIGHVALUES\nEXPEQUAL CP    0(0,R3),INCARD(8) COMPARE PACKED ON P=\nEXNEQUAL PACK  WORKFLD1,0(0,R3)   PACK KEY ON THE FILE ON N=\n         TITLE 'DATA AREAS AND CONSTANTS'\nMOVEMSGV DC    V(MOVEMSG)    ENTRY POINT OF PROGRAM FOR MESSAGE MVC\nBRLNKLST DC   3F'0'    PRINT BUFFER ADDRESS,MESSAGE NUMBER\nPRINTBUF DS    F                  SAVE ADDR OF NEXT PRINT BUFFER\nMAXLEN   DC    F'0'               LRECL OF INPUT\nMAXBLK   DS    F                 BLKSIZE OF INPUT\nPARMEND  DS    F   STORE THE ADDRESS OF THE END OF THE PARM\nSAVEREGS DS    F  USED TO SAVE R13 AND R14 IN THE DCB EXIT ROUTINE\nSAVEADDR DS    A  USED IN V OPTION FOR TRT INSTRUCTION\nSAVER4   DS    F    SAVE KEY LENGTH FOR AL,ML ON V RECS\nSAVEVARL DS    F    SAVE KEY LENGTH\nTABLE    DS    F            ADDRESS OF VS STORAGE GRABBED BY GETMAIN\nTABLEND  DS    F            ADDRESS OF THE BYTE FOLLOWING END OF TABLE\nDCBADDR  DS    F            ADDRESS OF LIBFILE/VSAMFILE/ISAM/INFIL DCB\nDCBADDR2 DS    F ADDR OF PRIMARY INPUT FILE OR SYSIN FOR RECFM=U,L SUB\nPUTADDR  DS    F            ADDRESS OF ISAM/INFIL RECORD AREA\nSAVERBA  DC    F'-1'  RBA OF PREVIOUS VSAMKEY RECORD-INIT TO HIGHVAL\n*        THE FOLLOWING 2 FLDS (RBA, VSAMRECL) MUST BE CONTIGUOUS\nRBA      DS    F    RBA OF CURRENT VSAMKEY RECORD FROM SHOWCB\nVSAMRECL DS    F  LRECL OF VSAMFILE/KEY KEY FROM SHOWCB\n*\nCARDADDR DS    F            ADDRESS OF CARDS RECORD AREA\nLSAVEADR DS    F     ADDRESS OF PREVIOUS RECORD FOR L SUBOPTION\nVPOSLENS DC    F'0'  POSITION OF KEY IN RECORD FOR L SUBOPTION\nVLEN123  DC   3F'0'   USED TO STORE THE LENGTHS ON L SUBOPTION\n*        NEXT FOUR AREAS MUST BE CONTIGUOUS FOR L SUBOPTION GETMAIN\nLENGLIST DS    F     ADDR OF LENGTH OF KEY ON L SUBOPTION\n         DC    X'80000000'   END OF LENGTH LIST\nLKEYARE1 DS    F     ADDR OF SYSUT1 KEY ON L SUBOPTION-\nLKEYARE2 DS    F     ADDR OF SYSIN KEY ON L SUBOPTION\nDVCTYPE  DS    2F 2 WORDS RETURNED ON DEVTYPE MACRO-DEVICE TYP & MAXBLK\nSAVESPIE DS    F          SAVE OLD SPIE HERE\nESTAPARM DC    A(BASES)   PARAMETER LIST FOR THE ESTAE MACRO\n         DC    A(SAVEAREA) ADR OF CONTENTS OF BASE REGISTERS\n         DC    X'80'\n         DC    3X'00'\nPOSLENS  DC    24X'FF' COUNT,POSITION & LENGTH SAVED HERE-INIT TO HIGHV\nPOSDISPS DS    2F      CONTAINS P2-P1,P3-P2 FOR SYSUT1\nVPOSDISP DS    2F      CONTAINS P2-P1,P3-P2 FOR SYSIN\nENDBIN   DS    F       USED TO STORE 2*(E= - B= - 1) FOR RANDOM OPT\nINLRECL  DS    D LRECL CONVERTED TO DECIMAL HERE,ALSO USED AS KEYLEN(T)\nINBLKSIZ DS    D   BLKSIZE CONVERTED TO DECIMAL HERE\nRBEGIN   DS    D   BEGINNINGTO OUTPUT RECORDS ON R KEY\nRSKIP    DS    D   SKIP FACTOR FOR R KEY\nWORKFLD1 DS    D   USED TO PACK A NUMBER BY VERNUM  ROUTINE\nPACKFLD  DS    D  USED TO PACK LRECL & BLKSIZE BY LABEL ROUTINE & T MSG\nCOUNT    DC    PL8'999999999999999'  INITIALIZED TO 10**15-1,CNT DEFLT\nEND      DC    PL8'999999999999999'  INITIALIZED TO 10**15-1,END DEFLT\nEJEQCNT  DC    PL8'999999999999999'  INIT TO 10**15-1,E OPT CHG J= DFLT\nBEGIN    DC    PL8'0'      USED FOR B= COUNTER\nENDCT    DC    PL8'0'      COUNT OF TOTAL RECS PASSED-USED FOR E=\nSAVECNT  DC    PL8'0'      SAVE ENDCT HERE FOR L SUBOPT OPTIMIZATION\nRCOUNT   DC    PL8'0'      COUNT USED FOR R MESSAGE AND T OPTION\nOUTCT2   DC    PL8'0'      COUNT OF RECORDS NOT SELECTED\nOUTCT3   DC    PL8'0'      COUNT OF RECORDS SELECTED  FROM SYSIN\nOUTCT4   DC    PL8'0'      COUNT OF RECORDS NOT SELECTED  FROM SYSIN\nPASSCT   DC    PL8'0'    THIS & THE NEXT FIELD,OUTCT,MUST BE CONTIGUOUS\nOUTCT    DC    PL8'0'      COUNT OF RECORDS SELECTED FOR KEY\nTOTPASCT DC    PL8'0'      COUNT OF RECORDS SELECTED FOR KEY\nTOTOUTCT DC    PL8'0'      COUNT OF RECORDS SELECTED FOR KEY\nSKIPCT   DC    PL4'0'      COUNT OF RECORDS SKIPPED FOR R KEY\nCOMPCNT  DC    PL8'0'    COUNT TO COMPARE RECORDS/KEY TO PARM COUNT\nCOMPCNTA DC    PL8'0'    COUNT NO OF RECORDS ON 1ST O KEY\nCOMPCNTB DC    PL8'0'    COUNT NO OF RECORDS ON 2ND O KEY\nCOMPCNTC DC    PL8'0'    COUNT NO OF RECORDS ON 3RD O KEY\nKEYLESS  DC    PL8'-1'   NO OF TIMES RECS FOR A KEY LESS THAN PARM CNT\nKEYMORE  DC    PL8'0'    NO OF TIMES RECS FOR A KEY MORE THAN PARM CNT\nTOTLKEYS DC    PL8'0'    NUMBER OF KEYS ON THE FILE\nMEMRECCT DC    PL8'0'    NUMBER OF RECORDS PER MEMBER\nMEMCOUNT DC    PL8'0'    NUMBER OF MEMBERS CREATED BY LIBOUT\nMAXRNDM  DC    PL8'5000' MAXIMUM NUMBER OF RANDOM NUMBERS TO BE GENERAT\nWORKFLD  DS    CL16'RESERVE 16 BYTES' - USED TO HOLD OPTIONS AND SUBOPT\nINCARD   DC    XL20'00'   INITIALIZE INCARD TO LOW VALUES FOR F & B\nINCARD1  DC    XL20'00'\nINCARD2  DS    CL20\nSAVECARD DS    CL20        USED TO SAVE INCARD WHEN Y= OPTION REQUESTED\nKEYAREA  DS   3CL20        SAVES UP TO 3 KEYS OF L=20 ON O OPTION\nECHGKEY  DS    CL40 SAVE AREA FOR 1ST E OPT SYSIN KEY AND CONVERT KEY\nLOWVALUE DC    XL20'00'    LOW VALUES\nHIGHV    DC    20X'FF'     HIGH VALUES\nMSGCNT   DS    H             NUMBER OF MSGS FOR EXITS DD AND V OPTION\nLOWVMSG  DC    C'LOW VALUES'\nHIGHVALU DC    C'HIGH VALUES' THIS FLD AND MSGSPACE MUST BE CONTIGUOUS\nMSGSPACE DC    CL30' '\nDDN      DS    CL8         USED TO HOLD DDNAME FOR MSG 40\nMEMBHOLD DS    CL8         HOLD AREA FOR MEMBER NAME ON V OPTION\nSAVEDCB  DS    5X          SAVE LRECL AND RECFM HERE ON V= ROUTINE\nSYSINFVU DS    C           SAVE RECFM OF SYSIN HERE(F,V,U ONLY)\nINRECFM  DS    CL1         INPUT RECORD TYPE\nINRECFM2 DS    CL1         INPUT RECFM\nOUTRECFM DS    CL1         OUTPUT RECFM\nSYSUTX   DS    CL1\nSYSUT    DC    C'2'        USED TO DETERMINE WHICH SYSUTX IS BEING USED\nCRYPTWK  DS    CL6    USED IN ENCRYPTION RTN\nMSG1CLS  DC    CL6' '      USED FOR CLASS MSG\nMSG5FLAG DC    X'05'       SET DEFAULT FOR MSG 5\nENDFLAG  DC    X'00'       SET TO X'51' WHEN PROCESSING ENDS DUE TO E=\nVSAMFLAG DC    C' '        FLAG TO INDICATE DDNAME VSAMKEY IS USED=1\nMSG44BLK DC    CL7'BLKSIZE'\n*MSG65LBL DC    CL80' '     HOLDS LABEL ON TAPELABL OPTION     @MK1\nPARMERR1 DC    C' '\nKEYMSG   DC    C'3'\nOPENERR  DC    C'0'  OPENERR=0 NO OPEN ERR, 1 MEANS IEC OPEN MSG\nNUMBERR  DC    C' ' SPACE IS VALID  1 IS INVALID\nENDPARMS DC    C' '  END OF PARM FIELD FLAG='1',END OF SYSIN/SYSUT1='2'\nPACKFLAG DC    C' '   WAS 'P=' OR 'N=' USED\nSAVEFLAG DS    CL1    USED TO SAVE PACKFLAG WHEN Y= OPTION REQUESTED\nMATCHFIL DC    C' '     FLAG TO DETERMINE IF M OR T OPTION REQ ON V=\nSYSINFLG DC    C'0'     FLAG TO\nMEMFLAG  DC    C'0'     FLAG TO INDICATE IF MEMSYSIN DD CODED\nOPENBACK DC    C' '\nSORTDONE DC    C'0'  FLAG TO INDICATE THAT SORT OF RANDOM NUMBS IS DONE\nVLENGTH  DC   2X'00' LENGTH OF THE SYSIN KEY ON V= SUBOPTION IN BNARY\nPEVENODD DC    X'00'  USED IN AN EXCLUSIVE OR TO ADD TO MAX ON ODD KEYS\nOUTPTKEY DC    C'N'        FLAG TO INDICATE IF MATCH ON CLASS KEY\nKEYINDIC DC    C'0' INDICATE WHETHER LOW OR HIGH KEY WAS LAST READ ON B\nDCOUNT   DC    PL4'1' CHANGED BY XO DOPTION=NNN, NTH OCCURENCE OF KEY\nVOLSERCT DC    PL2'1' COUNT NUMBER OF VOLSERS ON VOL= IN SYSIN -V OPT\nNUMLABLS DC    P'0'  USED TO COUNT NUMBER OF LABELS ON TAPELABL ROUTINE\nPACKZERO DC    P'0'    CONSTANT PACKED 0\nPACKONE  DC    P'1'    CONSTANT PACKED 1\nSETBAL   DC    XL2'4580'   CHANGE NOP TO BAL GOREG,.....\nMSGMASK  DC    X'40202020202020212021'  TO REST MASKS\nCNVRTCOD DS    CL4    CONVERT CODE\nLKEYADDR DS    A     SAVE ADDR OF KEY ON L SUBOPTION AND CONVERT FILE\nLKEYADR2 DS    A     SAVE ADDR OF KEY ON L SUBOPTION AND CONVERT FILE\nSAVRCNT  DC    PL8'-1'  SAVED COUNT OF NUMBER OF SYSIN RECORDS (CNVRT)\nFULL1    DC    F'1'\nFULL4    DC    F'4'\nFULL6    DC    F'6'\nFULL8    DC    F'8'\nFULL15   DC    F'15'\nFULL20   DC    F'20'\nSEED     DC    F'8193' DFLT SEED USED IN RANDOM OPTION\nFREELEN  DC    X'80',AL3(24024) DEFLT LENG FOR E,T,P,G FREEM-MOD BY R\n*VSMKEYL MUST BE DEFINED AS S-CON FOR GENCB MACRO & EXTENDED TO F-WORD\nVSAMKEYL DS    S,H  FULLWORD FOR VSAMKEY GENERIC KEY LEN\nVSOUTRPL DS    F    VSAMOUT RPL ADDR\n         SPACE 2\nACONVERT DC    A(CONVERT)\nAISAM    DC    A(ISAM)\nALIBRARY DC    A(LIBRARY)\nAVSYSIN  DC    A(VSYSIN)\nAMEMBNAM DC    A(MEMBNAME)\nAINFIL   DC    A(INFIL)\nAOUTFIL  DC    A(OUTFIL)\nALIBOUT  DC    A(LIBOUT)\nAOUTFIL2 DC    A(OUTFIL2)\nAOUTFIL3 DC    A(OUTFIL3)\nAOUTFIL4 DC    A(OUTFIL4)\nASYSIN   DC    A(CARDS)\nASNAPDMP DC    A(SNAPDUMP)\nASYSPRNT DC    A(PRINT)\n         TITLE 'INFORMATIONAL AND ERROR MESSAGES'\nMSG4     DC    C'0SEL004I KEY= '\nMSG4KEY  DS    CL20\nMSG4PASS EQU   *-MSG4\nMSG4ED   DC    X'4020202020202020202020202020212021'\n         DC    C'RECORDS PASSED,'\n         DC    X'222020202020202020202020202120'\nMSG4EDIT EQU   *-MSG4ED\n         DC    C' RECORDS OUTPUT '\nMSG4MAX  DC    CL3'   '\nMSG4LEN  EQU   *-MSG4\nMSG21    DC    C'0SEL021I KEY= '  E,F,C,O,G & T MSG\nMSG21KEY DC    CL20' '\n         DC    C' NUMBER OF RECORDS SELECTED='\nMSG21ED  DC    X'40202020202020212021'\nMSG21LEN EQU   *-MSG21\nMSG23    DC    C'0SEL023I RECORD NUMBER = '   Q MSG - OUT OF SEQUENCE\nMSG23ED  DC    X'40202020202020212021'\n         DC    C',KEY ='\nMSG23CKY DC    CL21' '\n         DC    C'PREVIOUS KEY ='\nMSG23PKY DC    CL20' '\nMSG23LEN EQU   *-MSG23\nMSG26    DC    C'0SEL026I '             R MSG\nMSG26OUT DC    X'40202020202020212021'\n         DC    C' RECORDS OUTPUT FROM RECORD'\nMSG26BEG DC    X'40202020202020212021'\n         DC    C'. SKIP FACTOR ='\nMSG26SKP DC    X'40202020202020212021'\n         DC    C' '\nMSG26LEN EQU   *-MSG26\nMSG29    DC    C'0SEL029I LOW KEY ='  P & B (RANGE)  KEY MSG\nMSG29LKY DC    CL20' '\n         DC    C',HIGH KEY ='\nMSG29UKY DC    CL20' '\nMSG29PAS DC    X'40202020202020212021'\n         DC    C' RECORDS PASSED'\nMSG29OUT DC    X'40202020202020212021'\n         DC    C' RECORDS OUTPUT'\nMSG29LEN EQU   *-MSG29\nMSG34    DC    C'0SEL034I KEY= '   DEBUG MESSAGE\nMSG34KEY DC    CL20' '\n         DC    C'LOCATED IN RECORD'\nMSG34LOC DC    X'40202020202020212021'\n         DC    C'.RECORDS OUTPUT= '\nMSG34OUT DC    X'40202020202020212021'\n         DC    C',BEGINNING AT RECORD'\nMSG34BEG DC    X'40202020202020212021'\nMSG34LEN EQU   *-MSG34\nMSG36    DC    C'0SEL036I '          E,T,P & G MESSAGE\nMSG36OUT DC    X'402020202120'   CANT EXCEED 4800\n         DC    C' SYSIN RECORDS ALLOWED,'\nMSG36ED  DC    X'402020212021'  EDIT MAST\n         DC    C'  READ/GENERATED AND USED'\nMSG36LEN EQU   *-MSG36\nMSG40    DC    C'0SEL040I         - DSORG='\nMSG40ORG DC    C'IS,RECFM='\nMSG40FVU DC    CL3' '\n         DC    C',LRECL='\nMSG40REC DC    X'402020202120'\n         DC    C',BLKSIZE='\nMSG40BLK DC    X'402020202120'\n         DC    C',VOLSER='\nMSG40VOL DC    CL6' '\n         DC    C',DSN='\nMSG40DSN DC    CL44' '\nMSG40LEN EQU   *-MSG40\nMSG62    DC   C'0SEL062I '\nMSG62KEY DC   CL16' '\nMSG62MSG DC   CL13'ERROR'\nMSG62LEN EQU  *-MSG62\nMSG85    DC    C'0SEL085I         - DSORG=PS,RECFM='\nMSG85FVU DC    CL3' '\n         DC    C',LRECL='\nMSG85REC DC    X'402020202120'\n         DC    C',BLKSIZE='\nMSG85BLK DC    X'402020202120'\n         DC    C',VOLSER='\nMSG85VOL DC    CL6' '\n         DC    C',DSN='\nMSG85DSN DC    CL44' '\nMSG85LEN EQU   *-MSG85\nMSG88    DC    C'0SEL088I'\nMSG88CNT DC    X'40202020202020202020202020212021'\n         DC    C' OCCURRENCES OF '\nMSG88KEY DC    CL20' '\n         DC    C' CHANGED TO '\nMSG88CHG DC    CL20' '\nMSG88LEN EQU   *-MSG88\nMSG93    DC    C'0SEL093I MEMBER = '\nMSG93MEM DC    CL8' '\n         DC    C', NUMBER OF RECORDS SELECTED = '\nMSG93ED  DC    X'40202020202020212021'\nMSG93LEN EQU   *-MSG93\n         TITLE 'REGISTER ASSIGNMENTS AND GETTING THE COMPILE DATE'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nGOREG    EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\nKEYLE    EQU   16\nDSORG    EQU   26\nRECFM    EQU   36\nBLKSIZE  EQU   62\nLRECL    EQU   82\n         SPACE 2\nSETNOP   EQU   X'00'\nSETBH    EQU   X'20'\nSETBL    EQU   X'40'\nSETBNE   EQU   X'70'\nSETBE    EQU   X'80'\nSETBR    EQU   X'F0'\nRECFMF   EQU   X'80'\nBLANK1   EQU   C' '\n         TITLE 'THE LITERL POOL'\n         LTORG\n         TITLE 'THE PARM FLD,THE DCBD,TIOT AND RELAT,SDWA, JFCB MACROS'\n         IEFJFCBN        PULL IN THE JFCB MAPPING MACRO\n         DCBD  DSORG=(IS,PO,PS,XE)   PULL IN DCB DSECT\n         IEFTIOT1         PULL IN TIOT MAPPING MACRO\n         IHAPSA           PULL IN PSA MAPPING MACRO (FOR TIOT)\n         IKJTCB           PULL IN TCB MAPPING MACRO (FOR TIOT)\n         IEZJSCB          PULL IN JSCB MAPPING MACRO (FOR TIOT)\n         PRINT GEN\n         IHAQDB           PULL IN QDB MAPPING MACRO (FOR TIOT)\n         PRINT NOGEN\n         IHADSAB          PULL IN DSAB MAPPING MACRO (FOR TIOT)\n         IHASDWA          PULL IN SYSTEM DIAGNOSTIC WORK AREA\nPARMDS   DSECT\nNUMBPARM DS    H       THE NUMBER OF CHARACTERS IN THE PARM FIELD\nDATAPARM DS    CL100   DATA ENTERED IN PARM PARAMETER OF THE EXEC CARD\n         TITLE ' CLOSE, FREEPOOL, AND DCB CSECT'\n*        THIS CSECT CONTAINS ALL THE PROGRAM DCBS EXCEPT FOR MEMSYSIN\n*        THIS CSECT ALSO PERFORMS THE CLOSE ON ALL THE DCBS IT CONTAINS\n*        THIS CSECT FREEPOOLS THE BUFFER POOLS OF ALLOCATED FILES AND\n*             ALSO FREEMAINS  E,G,T,P TABLE, L\n*             SUBOPTION RECORD AREAS AND LIBFILE AND LIBOUT BUFFERS.\n*        R2- CONTAINS DCB ADDR OF THE PRIMARY INPUT FILE\n*        R3- BASE REGISTER\n*        GOREG- BAL REGISTER\n*        R14- RETURN ADDR, R15-ADDR OF THIS CSECT\nDCBCSECT CSECT\n         BALR  R3,0    SET UP R3 AS BASE\n         USING *,R3\n         ST    R14,SAVERET        SAVE R14 FOR RETURN\n         L     R4,=A(KEYMSG)      IS THIS THE D OPTION\n         CLI   0(R4),C'8'         WHERE THE KEY WAS FOUND\n         BE    CLOSFREE           YES- CLOSE, FREEPOOL AND GET OUT\n         C     R2,=A(INFIL) SKIP FOR VSAMXXX,LIBFILE, V OPT,ETC\n         BNE   NOTINFIL    NO\n         BAL   GOREG,CLOSFREE FREE BUFFR STORAGE POOL FOR THE INPUT\nNOTINFIL C     R2,=A(ISAM)\n         BNE   NOTISAMF\n         BAL   GOREG,CLOSFREE FREE BUFFR STORAGE POOL FOR THE INPUT\nNOTISAMF L     R2,=A(VSAMFLAG)\n         CLI   0(R2),C' '    WAS VSAMXXX CODED\n         BE    NOTVSKY       NO -ITS NEITHER VSAMFILE NOR VSAMKEY\n         L     R4,=A(ACBVSIN) GET VSAMFILE/KEY ACB ADDR\n         CLOSE ((R4))             CLOSE VSAM FILE\n         FREEMAIN LU,LA=VSRECLN,A=VSRECADR  FREE THE VSAM REC WKAREA\nNOTVSKY  L     R2,=A(VSOUTRPL)   CHECK VSOUTRPL FOR RPL OF VSAMOUT\n         ICM   R2,15,0(R2)   WAS VSAMOUT CODED\n         BZ    NOTVSOUT      NO\n         L     R4,=A(ACBVSOUT) GET VSAMOUT ACB ADDR\n         CLOSE ((R4))             CLOSE VSAMOUT\n*        COMMENTED OUT SINCE NSR IS BEING USED\n*        CLI   0(R2),C'1'    WAS VSAMKEY CODED\n*        BNE   NOTVSKY       NO\n*        DLVRP TYPE=LSR      YES- DELETE THE LSR RESOUCRE POOL\nNOTVSOUT LA    R2,CARDS\n         BAL   GOREG,CLOSFREE\n         LA    R2,OUTFIL\n         BAL   GOREG,CLOSFREE\n         LA    R2,OUTFIL2\n         BAL   GOREG,CLOSFREE\n         LA    R2,OUTFIL3\n         BAL   GOREG,CLOSFREE\n         LA    R2,OUTFIL4\n         BAL   GOREG,CLOSFREE\n         LA    R2,CONVERT\n         BAL   GOREG,CLOSFREE\n         LA    R2,MEMBNAME\n         BAL   GOREG,CLOSFREE\n         LA    R2,MERGE\n         BAL   GOREG,CLOSFREE\n         CLOSE (SNAPDUMP)    <=======  THIS IS A BSAM (NOT QSAM) FILE\n*        BAL   GOREG,CLOSFREE          CANT ISSUE THE FREEPOOL\n         LA    R2,VSYSIN\n         BAL   GOREG,CLOSFREE\n         LA    R2,PRINT CLOS PRNT LAST IN CASE OF B37 BOMB ON ABV CLOSE\n         BAL   GOREG,CLOSFREE\n         SPACE 1\n         L     R2,=A(CONCATLN)\n         LH    R2,0(0,R2)       GET LENGTH OF MERGE FILE RECORD\n         LTR   R2,R2            IS IT 0 -\n         BZ    SKIPFRE0         YES\n         FREEMAIN E,LV=(2),A=SUMRECAD  FREE THE BUFFER\nSKIPFRE0 EQU   *\n         L     R2,=A(TABLE)\n         CLC   0(4,R2),=X'00000000' DID WE GET A TABLE FOR E,G,P,T OR R\n         BE    SKIPFRE1         NO\n         FREEMAIN LU,LA=FREELEN,A=TABLE   YES\nSKIPFRE1 L     R2,=A(LENGLIST)   DID WE GETMAIN A TABLE FOR L SUBOPTION\n         CLC   0(4,R2),=X'00000000' DID WE GET A TABLE FOR L SUBOPTION\n         BE    SKIPFRE2         NO\n         FREEMAIN LU,LA=LENGLIST,A=LKEYARE1 YES\nSKIPFRE2 EQU   *\n         L     R2,=A(LENGTHSV)       IS LIBFILE USED\n         ICM   R2,15,0(R2)         GET LIBFILE BLKSIZE USED IN GETMAIN\n         BZ    SKIPFRE3              NO LIBFILE BUFFER\n         CLOSE (LIBRARY)             CLOSE LIBFILE\n         FREEMAIN E,LV=(2),A=INBUFF\n         L     R2,=A(SVBLKSIZ)\n         LH    R2,0(R2)        WAS LIBOUT REQUESTED\n         LTR   R2,R2               BLKSIZE=0 MEANS NO\n         BZ    SKIPFRE3              NO\n         CLOSE (LIBOUT)           YES- CLOSE LIBOUT PDS\n         FREEMAIN E,LV=(2),A=OUTBUFF   FREE BUFFERS\nSKIPFRE3 EQU   *\n         L     R2,=A(EXITBLDL+4)    DELETE THE LAST EXIT ONLY\n         CLC   0(8,R2),=CL8' '      IS THERE A MODULE NAME IN BLDL\n         BE    SKIPDEL              NO\n         DELETE DE=(R2)             YES\nSKIPDEL  EQU   *\n         SPACE 2\n         L     R14,SAVERET      RELOAD R14 WITH RETURN\n         BR    R14\n         SPACE 2\nCLOSFREE CLOSE ((R2))\n         LTR   R15,R15\n         BNZR  GOREG\n         FREEPOOL (R2)\n         BR    GOREG\n         SPACE 1\nSAVERET  DS    F            SAVE R14 HERE\n         LTORG\n         DROP  R3\n         TITLE 'DCBS'\nPRINT    DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,RECFM=FBA,LRECL=133,  X\n               BLKSIZE=1330,EXLST=JFCBXLST\n         DS    0F\nISAM     DCB   DDNAME=ISAMFILE,DSORG=IS,MACRF=GL,                      X\n               EXLST=INPTXLST,SYNAD=SYNADERR,EODAD=ENDINPUT\n         DS    0F\nLIBRARY  DCB   DDNAME=LIBFILE,DSORG=PS,MACRF=RP,BLKSIZE=0,             X\n               EXLST=INPTXLST,SYNAD=SYNADERR,EODAD=ENDMEM\n         DS    0F\nINFIL    DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=GL,BLKSIZE=0,              X\n               EXLST=INPTXLST,SYNAD=SYNADERR,EROPT=ACC,EODAD=ENDINPUT\n         DS    0F\nCARDS    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,BLKSIZE=0,               X\n               EXLST=INPTXLST,EODAD=ENDKEYS,EROPT=ACC,SYNAD=SYNADERR\n         DS    0F\nVSYSIN   DCB   DDNAME=VSYSIN,DSORG=PS,MACRF=GL,BLKSIZE=0,RECFM=FB,     X\n               EODAD=ENDKEYS,EROPT=ACC,SYNAD=SYNADERR\n         DS    0F\nSNAPDUMP DCB   DDNAME=SYSOUX,DSORG=PS,MACRF=W,RECFM=VBA,LRECL=125,     X\n               BLKSIZE=1632,EXLST=JFCBXLST\n         DS    0F\nOUTFIL   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=PM,BLKSIZE=0,              X\n               EXLST=EXLSTDCB,SYNAD=SYNADERR\n         DS    0F\nLIBOUT   DCB   DDNAME=LIBOUT,DSORG=PO,MACRF=W,BLKSIZE=0,               X\n               EXLST=EXLSTDCB,SYNAD=SYNADERR\n         DS    0F\nOUTFIL2  DCB   DDNAME=SYSUT3,DSORG=PS,MACRF=PM,BLKSIZE=0,              X\n               EXLST=EXLSTDCB,SYNAD=SYNADERR\n         DS    0F\nOUTFIL3  DCB   DDNAME=SYSUT4,DSORG=PS,MACRF=PM,BLKSIZE=0,              X\n               EXLST=EXLSTDCB,SYNAD=SYNADERR\n         DS    0F\nOUTFIL4  DCB   DDNAME=SYSUT5,DSORG=PS,MACRF=PM,BLKSIZE=0,              X\n               EXLST=EXLSTDCB,SYNAD=SYNADERR\n         DS    0F\nMEMBNAME DCB   DDNAME=MEMBNAME,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=8,     X\n               BLKSIZE=0,SYNAD=SYNADERR,EXLST=JFCBXLST\n         DS    0F\nCONVERT  DCB   DDNAME=CONVERT,DSORG=PS,MACRF=GL,BLKSIZE=0,             X\n               SYNAD=SYNADERR,EODAD=EOFCNVRT,EROPT=ACC\n         DS    0F\nMERGE    DCB   DDNAME=MERGE,DSORG=PS,MACRF=PM,BLKSIZE=0,               X\n               SYNAD=SYNADERR,EXLST=MERGXLST\n         TITLE 'VSAM CONTROL BLOCKS AND INTERFACE'\n*        THIS CSECT GETS A VSAM FILE READY FOR OPENING\n*                     VIA--EXLST,ACB AND RPL MACROS\n*        THE LINKAGE CONVENTIONS ARE-\n*        R2-CONTAINS THE ACB ADDR ON ENTRY AND EXIT FROM CSECT-FOR OPEN\n*        R5-PASSES TO THE MAIN PROG THE ADDR OF THE RPL FOR THE GET\n*        R14-RETURN REG\n*        FOR VSAMKEY:\n*        R6- BSAE FOR THE SHOWCAT DSECT\n*        R10,R11- WORK REGISTERS\n*        R7- BCT REGISTER FOR SEARCHING CATALOG ASSOC TYPES\n*        R9- BAL REG\n*\n*        VSAMFILE SHOULD BE USED FOR ESDS FILES\n*        SINCE THE FILE IS PROCESSED PHYSICALLY SEQUENTIALLY\n*        DDNAME VSAMKEY IS BE USED FOR KSDS AND RRDS\n*        FILES. THE FILE IS PROCESSED BY KEY OR RELATIVE RECORD\n*        NUMBER (RRDS). HOWEVER, FOR KSDS,IF THE FIELD BEING SELECTED/\n*        MATCHED ON IS NOT THE KEY DEFINED FOR THE KSDS THEN IT IS\n*        MORE EFFICIENT TO USE THE VSAMFILE DDNAME AND PROCESS THE FILE\n*        PHYSICAL SEQ RATHER THAN THRU THE INDEX TO CUT DOWN ON THE\n*        AMOUNT OF I/O. THE INDEX IS ONLY HELPFUL WHEN PROCESSING THE\n*        FILE THRU THE DEFINED KEY. VSAMKEY MUST BE USED FOR RRDS.\nVSAMSECT CSECT\n         USING *,R15\n         STM   R6,R14,SAVEAREH   SAVE MAIN CSECT BASE REGISTERS\n         CNOP  0,4\n         BAL   R3,JUMPSAV8\nSAVEAREH DS    9F\nJUMPSAV8 EQU   *\n         USING SAVEAREH,R3\n         DROP  R15\n*        BUILD VSAM RESOURCE POOL FOR LOCAL SHARED RESOURCES\n*        ALLOW 4 BUFFERS FOR DATA CI & 15 FOR INDEX CISIZE\n*        OBTAIN THE ACTUAL DATA AND INDX CISIZE AND KEYLEN FROM SHOWCAT\n*        BLDVRP ALLOWS ONLY 512,1K,2K,4K,N*4K UP TO 32K AS BUFF SIZES\n*        SET BLDVRP DEFAULTS AS DATA/INDX CISIZE=512, KEYLEN=20\n         MVC   PHONYDCB+DCBDDNM(8),ACBDDNM(R2) MOVE IN VSAMXXX DDNAME\n         RDJFCB (PHONYDCB)  READ THE PHONY DCB SET UP FOR THE VSAM FILE\n         MVC   VSAMDSN,JFCBAREA+0  TO OBTAIN THE CLUSTER NAME\n         L     R11,=A(MSG40DSN)\n         MVC   0(44,R11),VSAMDSN   MOVE VSAM CLUSTER NAME TO MSG40\n         L     R11,=A(MSG40VOL)\n         MVC   0(6,R11),JFCBAREA+118 MOVE VSAM CLUSTER VOLSER TO MSG40\nSHOWCAT  SHOWCAT AREA=CATINFO1,NAME=VSAMDSN GET OBJ TYPE,ACB AND CI NO.\n         LTR   R15,R15     ERROR?\n         BNZ   CATERR      YES\n         USING SHWOUT,R6       MAKE SHOWCAT OUTPUT DSECT ADDRESSABLE\n         LA    R6,CATINFO1\n         CLI   SHWTYPE,C'C'        IS THIS A CLUSTER CATALOG RECORD\n         BE    GETDI         YES- NOW GET THE DATA/INDX COMPONENT REC\n         CLI   SHWTYPE,C'G' NO-IS IT AN ALT. INDX-GET ITS DATA/INDX REC\n         BNE   VSAMRET   FALL THRU ERR-RETURN TO MAINLINE, BOMB ON OPEN\nGETDI    MVC   CATACB,SHWACBP   SAVE ACB ADDR\n         USING SHWASSOC,R6   SET ADDRESSABILITY FOR SHOWCAT ASSOC DSECT\n         LA    R6,SHWASS0-SHWOUT(R6)\n         LH    R7,SHWACT        GET COUNT OF CAT ASSOC RECS\nGETDSZ   CLI   SHWATYPE,C'D'    IS THIS THE DATA COMPON ASSOC\n         BE    DCISIZE          YES- ISSUE SHOWCAT TO GET DATA CISIZE\n         LA    R6,4(R6)         NO- ADD 4 TO BASE TO POINT TO NXT ASSOC\n         BCT   R7,GETDSZ        LOOP UNTIL FIND DATA COMPON ASSOC\n         B     VSAMRET  FALL THRU ERR-RETURN TO MAINLINE, BOMB ON OPEN\n         SPACE 2\nDCISIZE  MVC   CATCINUM,SHWACI\n         L     R11,CATACB\n         SHOWCAT ACB=(R11),AREA=CATINFO2,CI=CATCINUM\n         LTR   R15,R15     ERROR?\n         BNZ   CATERR      YES\n         USING SHWOUT,R6   RESET ADDRESSABILITY FOR SHOWCAT OUTPT DSECT\n         LA    R6,CATINFO2   RESET SHOWCAT BASE REGISTER\n         ICM   R11,15,SHWMREC    GET MAX LRECL OF DATA COMPONENT\n         L     R10,=A(MAXLEN)   PLACE LRECL IN MAXLEN TO INSURE THE\n         ST    R11,0(R10)       L+P DOES NOT EXCEED LRECL\n         CVD   R11,VSWORK        CONVERT TO DECIMAL\n         LA    R11,4(R11)   ADD 4 TO MAX LRECL FOR OUTPUT FILE RECFM=V\n         STCM  R11,7,VSRECLN+1 TO GETMAIN A WORKAREA OF THAT SIZE\n         L     R11,=A(MSG40REC)  GET MSG40 LRECL FLD\n         ED    0(6,R11),VSWORK+5   EDIT LRECL INTO MSG40\n         ICM   R11,15,SHWCISZ    GET DATA CISIZE\n         CVD   R11,VSWORK        CONVERT TO DECIMAL\n         L     R11,=A(MSG40BLK)  GET MSG40 BLKSI FLD\n         ED    0(6,R11),VSWORK+5   EDIT LRECL INTO MSG40\n         SPACE 1\n         CLC   PHONYDCB+DCBDDNM(8),ACBVSOUT+ACBDDNM\n         BE    VSAMOUT\n         SPACE 1\n         GETMAIN LU,LA=VSRECLN,A=VSRECADR  GET WORK AREA FOR INPUT VSAM\n         SPACE 1\n         CLC   PHONYDCB+DCBDDNM(8),ACBVSK+ACBDDNM\n         BNE   VSAMFILE         NO\n         SPACE 1\n*        THE FOLLOWING CODE IS COMMENTED OUT SINCE FOR BATCH JOBS\n*        ITS SEEMS THAT NSR(NON-SHARED RESOURCES) WITH BUFND=4,BUFNI=15\n*        USES LESS CPU TIME THAN LSR WITH SIMILAR BUFFER POOLS ALLOCATD\n*        ALTHOUGH NSR USES MORE REGION\n         SPACE 2\n*        BAL   R9,ROUNDCI  GET THE DATA CISIZE AND ROUND IT FOR BLDVRP\n*        ST    R11,BLDVRP+60 ST DATA CISIZE (ROUNDED) INTO BLDVRP EXPAN\n*        CLC   SHWKEYLN,=H'19'  IS KEYLEN GREATER THAN 19\n*        BH    BYPKYLMV         YES - DEFAULT TO 20\n*        MVC   BLDVRP+16(1),SHWKEYLN+1 NO-MV IN ACTUAL KEYLEN TO BLDVRP\n*YPKYLMV LA    R6,CATINFO1   POINT TO PRIMARY CATLG AREA\n*        USING SHWASSOC,R6   SET ADDRESSABILITY FOR SHOWCAT ASSOC DSECT\n*        LA    R6,SHWASS0-SHWOUT(R6)\n*        LH    R7,SHWACT     RELOAD NUMBER OF ASSOCIATIONS\n*GETISZ  CLI   SHWATYPE,C'I'  SEARCH FRO INDX COMPON\n*        BE    ICISIZE        FOUND IT\n*        LA    R6,4(R6)\n*        BCT   R7,GETISZ\n*        B     VSAMRET       BRANCH BACK TO MAINLINE -ERR ON OPEN\n*ICISIZE MVC   CATCINUM,SHWACI\n*        L     R11,CATACB\n*        SHOWCAT ACB=(R11),AREA=CATINFO2,CI=CATCINUM\n*        LTR   R15,R15     ERROR?\n*        BNZ   CATERR      YES\n*        USING SHWOUT,R6   RESET ADDRESSABILITY FOR SHOWCAT OUTPT DSECT\n*        LA    R6,CATINFO2   RELOAD SHOWCAT DSECT ADDR\n*        BAL   R9,ROUNDCI    GET THE INDX CISIZE\n*        ST    R11,BLDVRP+68  STORE INDX CISIZE INTO BLDVRP\n*        CNOP  0,4   ALIGN BLDVRP ON FULLWORD FOR MODIFY\n*BLDVRP  BLDVRP BUFFERS=(512(3),512(15)),KEYLEN=20,STRNO=1,TYPE=LSR\n         SPACE 2\n         LA    R2,ACBVSK ADDR OF THE ACB FOR THE OPEN AND THE RPL\n         ST    R2,ACBVSIN     SAVE INPUT ACB ADDR\n         LA    R5,RPLVSK ADDR OF THE REQUEST PARAM LIST FOR THE GET\n         SPACE 2\nVSAMRET  LM    R6,R14,SAVEAREH    RESTORE REGISTERS\n         BR    R14\n         SPACE 2\n*ROUNDCI ICM   R11,15,SHWCISZ    LOAD CISIZE (DATA/INDX) INTO R11\n*        LA    R10,0          CLEAR R10 IN PREP FOR DIVIDE\n*        D     R10,=F'1024'   DIVIDE CISIZE BY 1K\n*        LTR   R11,R11        IS QUOTIENT=0\n*        BZ    CI512          YES- SET CISIZE TO 512\n*        LTR   R10,R10        IS REMAINDER=0\n*        BZ    BUFTRAN        YES- GO DIRECTLY TO TRANSLATE (ROUND UP)\n*        LA    R11,1(R11)     ADD 1 TO QUOTIENT (ROUND UP 1 FIRST)\n*BUFTRAN STC   R11,BUFSZK\n*        TR    BUFSZK,BUFTRTAB\n*        IC    R11,BUFSZK\n*        SLA   R11,10         MULTIPLY ROUNDED RESULT BY 1K\n*        BR    R9             RETURN\n*        SPACE 1\n*CI512   LA    R11,512        SET CISIZE TO 512\n*        BR    R9\n         SPACE 3\n*        VSAMFILE (NOT VSAMKEY)\nVSAMFILE LA    R2,ACBVSF ADDR OF THE ACB FOR THE OPEN AND THE RPL\n         ST    R2,ACBVSIN     SAVE INPUT ACB ADDR\n         LA    R5,RPLVSF ADDR OF THE REQUEST PARAM LIST FOR THE GET\n         B     VSAMRET\n         SPACE 2\nVSAMOUT  LA    R2,ACBVSOUT ADDR OF ACB FOR THE OPEN AND THE RPL\n         LA    R5,RPLVSOUT ADDR OF REQUEST PARAM LIST FOR THE GET\n         L     R10,=A(MAXLEN)    FOR NON-VSAM RECFM=F INPUT FILE\n         L     R10,0(R10)        SET LRECL  FOR VSAMOUT\n* AND ALSO THE MAX LRECL FOR THE AREA LENGTH OF THE RECORD WORK AREA\n         MODCB RPL=(R5),RECLEN=(R10),AREALEN=(R10)\n         OPEN  ((R2),OUTPUT)    OPEN VSAMOUT - ACB ADDRESS IN R2\n         B     VSAMRET\n         DROP  R3\n         SPACE 5\nACBVSIN  DS    F\nEXLSTVSK EXLST AM=VSAM,EODAD=ENDINPUT\n         DS    0F\nACBVSK   ACB   AM=VSAM,DDNAME=VSAMKEY,EXLST=EXLSTVSK,                  X\n               BUFND=4,BUFNI=15,       <======== NSR                   X\n               MACRF=(KEY,SEQ)   LSR)  <======== LSR NOT USED\n*        KEY SEQUENTIAL ACCESS USED WITH POINT MACRO (SIMULAT SKIP-SEQ)\n*        SEARCH ARGUEMENT BUILT FROM SYSIN FILE IN INCARD.\n*        LENGTH OF KEY IN S-CON VSAMKEYL MOVED IN BY MODCB.\n*        FILE WILL BE POSITIONED AT THE NEXT KEY WHICH IS GREATER THAN\n*        OR EQUAL TO THE SEARCH ARG.\n         DS    0F\nRPLVSK   RPL   AM=VSAM,ACB=ACBVSK,AREA=PUTADDR,AREALEN=4,              X\n               OPTCD=(KEY,SEQ,LOC,KGE,GEN),ARG=INCARD\n*              KEYLEN=(*,VSAMKEYL)  <===== SUPPLIED BY A MODCB MACRO\n         DS    0F\nACBVSF   ACB   AM=VSAM,DDNAME=VSAMFILE,EXLST=EXLSTVSK,MACRF=ADR\n         DS    0F\nRPLVSF   RPL   AM=VSAM,ACB=ACBVSF,AREA=PUTADDR,AREALEN=4,              X\n               OPTCD=(ADR,LOC)\n         DS    0F\nACBVSOUT ACB   AM=VSAM,DDNAME=VSAMOUT,MACRF=(KEY,SEQ,OUT),             X\n               BUFND=4,BUFNI=15 <=== NSR (CANT USE LSR ON EMPTY FILE)\n         DS    0F\n*        KEY SEQUENTIAL ACCESS\n* RECLEN- LENGTH OF OUTPUT REC SUPPLIED BY CONTROL BLOCK MANIPULAT RTN\n* AREA  - AREA ADDR WILL BE UPDATED BEFORE PUT BY A MODCB\n* AREALEN-AREALEN WILL BE SUPPLIED BY A MODCB MACRO ABOVE\nRPLVSOUT RPL   AM=VSAM,ACB=ACBVSOUT,OPTCD=(KEY,SEQ,MVE)\n         DS    0F\nPHONYDCB DCB   DDNAME=VSAMXXX,DSORG=PS,MACRF=GL,EXLST=VSAMXLST\nVSAMXLST DS    0F\n         DC    X'87',AL3(JFCBAREA)   JFCB EXIT\nJFCBAREA DS    CL176\nVSAMDSN  DS    CL44\nBUFTRTAB DC    X'0001020404080808080C0C0C0C101010101414141418181818'\n         DC    X'1C1C1C1C20202020'  ROUND BUFSIZE TO ALLOWABLE VALUE\nVSWORK   DS    D      DOUBLE-WORD WORK AREA\nCATACB   DS    F      ACB OF CATALOG RETURNED FROM FIRST SHOWCAT\nCATINFO1 DC    H'64'  WORKAREA INTO WHICH 'C' OR 'G' CATLG INFO RETURND\n         DS    CL62\nCATINFO2 DC    H'64'  WORKAREA INTO WHICH 'D' OR 'I' CATLG INFO RETURND\n         DS    CL62\nCATCINUM DS    XL3    CATLG CI NUMBER FOR SHOWCAT\nBUFSZK   DS    X      CISIZE IN K ROUNDED FOR BLDVRP MACRO\nVSRECLN  DS    0F         PARAMETER LIST FOR GETMAIN\n         DC    X'80000000'   LENGTH OF INPUT VSAM RECORD\nVSRECADR DS    A             ADDRESS OF GETMAINED WORKAREA\nCATERR   ABEND 100,DUMP,STEP,SYSTEM  *******FOR TESTING**************\n         LTORG\n         IGGSHWPL\n         TITLE 'PDS PROCESSING'\n*        THIS CSECT PROCESSES PDS'S.  THE LINKAGE CONVENTIONS ARE-\n*        R1-USED TO PASS THE ADDR OF THE LIBRARY DCB TO THIS CSECT.\n*           THE CSECT THEN PASSES THE RECORD ADDR BACK TO THE\n*           MAIN PROGRAM IN R1.\n*        R5-USED AS THE BASE REGISTER FOR THE DCB\n*        R8-POINTER TO CURRENT ADDR IN THE PDS DIRECTORY\n*        R9-INPUT DATA BLOCK COUNTER-NUMBER OF BYTES REMAINING\n*        R10-DIRECTORY BLOCK COUNTER-NUMBER OF BYTES REMAINING\n*        R11-POINTER TO CURRENT ADDR IN THE INPUT DATA SET BLOCK\n*           R8,R9,R10 & R11 ARE SAVED AND RESTORED IN SAVEINFO\n*        R12-BASE REGISTER\n*        R15-USED TO INDICATE END OF PDS DIRECTORY (EOF) R15=1\n*                FOR THE LIBOUT ROUTINE\n*        R5-LIBOUT DCB ADDR\n*        R6-OUTBUFF ADDR FOR WRITE\n*        R7-WORK REGISTER AND LENGTH OF WRITE BLOCK (WHEN SHORT)\n*        R15-USED TO INDICATE ERROR R15=2\nLIBCSECT CSECT\n         USING *,R15\n         STM   R2,R14,SAVEAREC\n         CNOP  0,4\n         BAL   R12,JUMPSAV3\nSAVEAREC DS    13F\nJUMPSAV3 EQU   *\n         USING SAVEAREC,R12\n         DROP  R15\n         LR    R5,R1           LOAD ADDR OF LIBRARY DCB\n         LM    R8,R11,SAVEINFO\n         MVI   RETURN3+3,X'00'    RESET RETURN CODE (RC=4 CONTINUES)\n         C     R5,=A(LIBOUT)  IS THIS LIBFILE(INPUT) OR LIBOUT PROCES\n         BE    LIBOUTPR        IT IS LIBOUT\n         SPACE 1\nVLOGPDS  B     SETDCB  SET TO NOP ON VOPTION\nBRVRTN   NOP   ENDMEM  SET TO B AFTER 1ST TIME THRU\n         MVI   BRVRTN+1,SETBR\n         B     RDDIR\n         SPACE 1\nSETDCB   NOP   BLKED           CHANGED TO B AFTER 1ST TIME THRU\n         MVI   SETDCB+1,SETBR SET BRANCH AROUND THIS 1 TIME CODING\n         MVC   KEYLEN+1(1),KEYLE(R5)  SAVE DCB KEY LENGTH\n         L     R7,=A(MAXLEN+2)  GET MAX LRECL\n         MVC   RECLEN,0(R7)    SAVE MAX LRECL IN RECLEN\n         LH    R0,BLKSIZE(R5)  LOAD INPUT DATA SET BLKSIZE\n         STH   R0,BLKLEN     SAVE BLKSIZE\n         AH    R0,KEYLEN    ADD KEY LENGTH TO BLKSIZE\n         ST    R0,LENGTHSV  SAVE INPUT BUFFER LENGTH (BLKSIZE+KEYLEN)\n         GETMAIN R,LV=(0)     GET CORE FOR THAT SIZE RECORD\n         ST    R1,INBUFF     SAVE INPUT BUFFER ADDRESS\n         L     R7,=A(MEMFLAG)  GET FLAG THAT INDICATES IF MEMSYSIN DD\n         CLI   0(R7),C'1'       CODED IN JCL\n         BNE   LIBVREC         NO\n         MVI   SELMEM+1,SETNOP YES-SET NOP TO PROCESS MEMB NAMES\n         OPEN  (MEMSYSIN)           OPEN FILE\nLIBVREC  L     R7,=A(MSG40FVU)  GET RECFM\n         CLI   0(R7),C'V'       IS RECFM=V\n         BNE   LIBUREC          NO- SEE IF ITS RECFM=U\n         MVI   RECFMV1+1,SETNOP\n         MVI   RECFMV2+1,SETNOP\n         MVI   WRITEV+1,SETNOP  SET NOP TO PUT BDW INTO BLOCK-LIBOUT\n         MVI   BLKBUFL+1,X'04'  INIT BLK BUF LEN TO 4 FOR\n         MVI   INITBLK+1,X'04'  INIT FACTOR FOR BLKBUFL FOR RECFM=V\nLIBUREC  CLI   0(R7),C'U'       IS RECFM=U\n         BNE   RDDIR            NO\n         MVI   LIBCOMP+1,SETBR  SET BR TO GO TO RECFM=U RTN\n         MVI   NEWBLKU+1,SETBR  SET BRANCH TO BYPASS INSERT RTN\n         MVI   LIBOUTU+1,SETBR SET BR TO BYPASS GETMAIN\n         SPACE 2\nRDDIR    LA    R8,DIRBLK     LOAD DIRECTORY WORK ADRE ADDR\n         MVI   DSORG(R5),X'40'     CHANGE DSORG TO PS\n         MVC   BLKSIZE(2,R5),=H'256' CHANGE BLOCKSIZE TO 256\n         READ  DECBI,SF,(R5),(R8),'S',MF=E     READ DIRECTORY BLOCK\n         CHECK DECBI     CHECK FOR COMPLETION OF READ\n         NOTE  (R5)       REMEMBER LOCATION OF BLOCK READ\n         STCM  R1,X'E',DADDSAV SAVE TTR OF LAST BLOCK READ-3 HIGH BYTES\n         MVI   DSORG(R5),X'02'  CHANGE DSORG BACK TO PDS\n         MVC   BLKSIZE(2,R5),LENGTHSV+2   CHANGE BLKSIZE BACK\n         LH    R10,0(R8)    LOAD DIRECTORY BLOCK BYTE COUNT\n         SH    R10,=H'2'   DECREASE COUNT BY 2\n         LA    R8,2(R8)     LOAD ADDRESS OF FIRST MEMBER IN BLOCK\nCOMP     CLI   0(R8),X'FF'     IS THIS THE END OF DIRECTORY\n         BE    ENDJOB     YES,BRANCH TO END OF JOB\nVEND     NOP   RETURN3    SET TO B ON V OPTION\n         SPACE 1\nSELMEM   B     MVMEMNM    SET TO NOP IF MEMSYSIN DD CODED\nGENERICM CLC   MEMRECIN,0(R8)   IS MEMSYSIN REC = TO DIRECTORY ENTRY\n         BH    ENDMEM      ITS HIGHER - READ NEXT DIRECTORY ENTRY\n         BL    GETMEM    ITS LOWER - READ NEXT MEMSYSIN RECORD\n         SPACE 1\nMVMEMNM  MVC   BLDENTRY,0(R8) ITS EQUAL- MOVE MEMBER NAME TO BLDL LIST\n         BLDL  (R5),BLDLADD     GET THE TTR OF THE MEMBER\n         FIND  (R5),BLDLTTR,C     FIND THE MEMBER\n         SPACE 2\nRDPDS    L     R11,INBUFF     LOAD ADDR OF WORK AREA FOR MEMBER RECS\n         READ  DECBI,SF,(R5),(R11),'S'     READ THE MEMBER\n         CHECK DECBI    CHECK FOR COMPLETION OF READ\n         AH    R11,KEYLEN     ADD IN RECORD KEY LENGTH\nRECFMV1  B     COMPREC      CHANGED TO NOP IF RECFM=V\n         LH    R9,0(R11)    GET BLKSIZE FROM BLOCK DISCRIPTOR WORD\n         SH    R9,=H'4'     SUBTRACT 4 FROM BLKSIZE FOR THE BDW\n         LA    R11,4(R11)   POINT TO RECORD DISCRIPTOR WORD\n         MVC   RECLEN,0(R11)    STORE LRECL IN RECLEN\n         B     RETURN3\nCOMPREC  LH    R9,BLKLEN     LOAD INPUT BLOCK LENGTH WHEN RECFM=F OR U\n         L     R4,DECBI+16   DECBI+16=IOB ADDR\n         SH    R9,14(R4)    SUBTRACT RESIDUAL LENGTH(IOB ADDR+14)\n         B     RETURN3\n         SPACE 2\nBLKED    SH    R9,RECLEN    SUBTRACT LOG. REC FROM BLKSIZE\n         BNP   RDPDS IF 0 (OR NEGATIVE FOR RECFM=U), READ NEXT BLOCK\n         AH    R11,RECLEN        LOAD ADDR OF NEXT LOGICAL REC\nRECFMV2  B     RETURN3       CHANGED TO NOP IF RECFM=V\n         MVC   RECLEN,0(R11)     STORE THE LRECL FROM THE RDW IN RECLEN\n         B     RETURN3\nENDMEM   SR    R7,R7     CLEAR REGISTER\n         NI    11(R8),X'1F'  ZERO OUT ALL BITS EXCEPT 3-7(1/2-WORD CNT)\n         IC    R7,11(R8)     INSET USER DATA BYTE COUNT\n         SLL   R7,1     MULTIPLY # HALFWORDS BY 2\n         LA    R7,12(R7)    ADD MEMBER NAME AND TTR BYTE COUNT\n         LA    R8,0(R7,R8)     LOAD ADDR OF NEXT MEMBER NAME\n         SR    R10,R7    SUBTRACT FROM TOTAL COUNT-IS IT END OF DIRECT\n         BNZ   COMP   NO-GET NEXT LOGICAL DIRECTORY RECORD\n         POINT (R5),DADDSAV YES-POINT TO NEXT DIRECTORY BLOCK FOR READ\n         B     RDDIR\n         SPACE 2\nENDJOB   MVI   DSORG(R5),X'40'      RESTORE DSORG TO PS\n         MVI   RETURN3+3,X'01'     SET R15=1 TO INDICATE END OF PDS\n         CLOSE (MEMSYSIN)\n         LTR   R15,R15\n         BNZ   LIBOTNOP\n         FREEPOOL MEMSYSIN\nLIBOTNOP B     RETURN3   SET TO NOP IF LIBOUT REQUESTED\n*        ENTERED WHEN END OF DIRECTORY SENSED TO WRITE & STOW LAST BLK\n         CLI   LIBOUTPR+1,SETNOP HAVE ANY LIBOUT RECORDS BEEN INSERTED\n         BE    RETURN3       NO- NOTHING TO DO AT ENDJOB\n         MVC   BLDENTRY,=X'FFFFFFFF'  EOF INDICATOR\n         MVI   NEWBLK+1,SETBR SET BR TO RETURN AFTER LAST REC\n         MVI   NEWBLKU+1,SETNOP SETNOP-RETURN AFTER LAST REC FOR RCFM=U\n         MVI   BYPOINT+1,SETBR BYP POINT MACRO IF EOJ (NO WRITES AFTER)\n         L     R5,=A(LIBOUT)  PUT LIBOUT DCB INTO R5\n         B     LIBCOMP\n         SPACE 2\nLIBOUTPR NOP   LIBCOMP   SET TO BR AFTER FIRST TIME THRU\n         MVI   LIBOUTPR+1,SETBR\n         MVI   LIBOTNOP+1,SETNOP AT ENDJOB SET NOP TO PROCESS LAST MEMB\n         MVC   STOWMNME,BLDENTRY  MOVE MEMBER NAME TO STOW LIST\n         MVC   STOWREST,BLDLREST  MOVE IN C AND USER DATA\nLIBOUTU  NOP   LIBCOMPU   SET BR ON RECFM=U TO BYPASS GETMAIN\n         LH    R0,BLKSIZE(R5)    GET LIBOUT BLKSIZE\n         STH   R0,SVBLKSIZ   SAVE OUTPUT BLKSIZE\n         GETMAIN R,LV=(0)        GET STORAGE FOR LIBOUT BLOCK\n         ST    R1,OUTBUFF    STORE SORAGE ADDR IN OUTBUFF\nLIBCOMP  NOP   LIBCOMPU      SET TO BR ON RECFM=U\n         LH    R7,RECLEN     GET LIBOUT LRECL\n         AH    R7,BLKBUFL    ADD CURRENT BLOCK BUF LENGTH\n         L     R6,OUTBUFF    PUT OUTPUT BUFFER ADDR IN R6\n         CLC   STOWMNME,BLDENTRY  IS NEW MEMBER NAME = OLD MEMBER NAME\n         BNE   MEMBCHG           NO\n         CH    R7,SVBLKSIZ       IS OUTPUT BUFFER FULL\n         BNH   INSERT     NO- INSERT RECORD INTO OUTPUT BUFFER\n         BAL   R4,WRITE               YES -WRITE FULL BUFFER\n         B     NEWBLK     INSERT FIRST RECORD OF NEW BLK\n         SPACE 2\nMEMBCHG  BAL   R4,WRITE       WRITE SHORT BUFFER\nMEMBCHGU STOW  (R5),STOWLIST,A    STOW MEMBER IN DIRECTORY\n         C     R15,=F'4'            ERROR IN STOW?\n         BE    REPMEM               CHECK IF REPLACE ALLOWED\n         BH    LIBERR               ERROR\nLIBCONT1 AP    MEMBCNT,=P'1'     NO-ADD 1 TO MEMBERS ADDED/REPLACED\n         MVI   STOWFLAG,C'Y'     SUCCESSFUL STOW INDICATOR\nLIBCONT2 MVC   STOWMNME,BLDENTRY        MOVE IN NEW MEMBER NAME\n         MVC   STOWREST,BLDLREST  MOVE IN C AND USER DATA\n         MVC   REPLFLAG,HOLDREPL        GET UPDATED REPL FLAG\nNEWBLKU  NOP   WRITEU  SET TO B ON RECFM=U TO WRITE NEXT BLK,NOP AT EOJ\nNEWBLK   NOP   RETURN3 MOVE IN 1ST REC OF NEXT MEMB,SET TO B AT EOJ\n*        SET TO BR AT EOJ FOR LAST BLK AND FOR RECFM=U\n         MVC   BLKBUFL,INITBLK  RESET BLK BUF LENGTH TO 0 (OR 4 FOR V)\nINSERT   AH    R6,BLKBUFL  PT TO NEXT RECORD AREA IN BUFFER\n         LH    R7,RECLEN   GET RECORD LENGTH\n         LR    R2,R11      GET INPUT RECORD ADDR\n         LR    R3,R7       LENGTH\n         MVCL  R6,R2       MOVE LOGICAL RECORD (ANY LENGTH)\n         SPACE 1\n         LH    R7,RECLEN    LOAD CURRENT LRECL\n         AH    R7,BLKBUFL   ADD CURRENT BLOCK BUL LENG\n         STH   R7,BLKBUFL   AND STORE NEW BLOCK BUF LENG\n         B     RETURN3\n         SPACE 2\nWRITE    LH    R7,BLKBUFL          GET BLKSIZE FOR WRITE\nWRITEV   B     WRITEFU             SET TO NOP FOR RECFM=V\n         STH   R7,0(R6)            SET BDW IN OUTPUT BUFFER\nWRITEFU  STH   R7,BLKSIZE(R5)      SET BLKSIZE FOR WRITE\n         WRITE DECBO,SF,(R5),(R6),'S'   WRITE BLOCK (SHORT AND FULL)\n         CHECK DECBO\n         CLI   STOWFLAG,C'Y'       WAS LAST STOW SUCCESSFUL\n         BNER  R4                  NO\n         NOTE  (R5)     YES-REMEMBER THE ADDRESS OF THE 1ST BLK OF MEMB\n         ST    R1,WRITEPOS  AND SAVE IT TO RESET POINTER AFTER BAD STOW\n         MVI   STOWFLAG,C'N'       RESET STOW FLAG\n         BR    R4\n         SPACE 2\nGETMEM   GET   MEMSYSIN       GET NEW MEMSYSIN REC\n         MVC   MEMRECIN,0(R1)      MOVE TO 11-BYTE HOLD AREA\n         TRT   MEMRECIN(9),FINDPARN SEE IF (R) CODED ON MEMBNM FOR REPL\n         BZ    NOREPL            NO\n         CLC   0(3,R1),=C'(R)'    MAKE SURE (R) CODED\n         BNE   NOREPL            NO\n         MVI   HOLDREPL,C'Y'     YES\n         MVC   0(3,R1),=C'   '   BLANK OUT (R)\nFRSTREPL NOP   CHKGENRC          SET TO BRANCH AFTER 1ST TIME THRU\n         MVI   FRSTREPL+1,SETBR\n         MVI   REPLFLAG,C'Y'     SET REPLFLAG TO 'Y' 1ST TIME\n         SPACE 1\nCHKGENRC MVI   GENERICM+1,X'07'    SET COMPARE LENGTH TO 8-1\n         TRT   MEMRECIN(8),FINDAST IS GENERIC MEMBER NAME SPECIFIED\n         BZ    GENERICM            NO - DONT RESET COMP LENG\n         LA    R2,MEMRECIN YES- PUT ADDR OF FIRST BYTE OF MNAME IN R2\n         SR    R1,R2   GET LENGTH OF GENERIC NAME IN R1\n         BZ    NOMEMCHK   LENGTH=0, DONT DO ANY MEMSYSIN PROCESSING\n         BCTR  R1,0       SUBTRACT 1 FROM LENGTH FOR COMPARE\n         STC   R1,GENERICM+1    SET LENGTH OF COMPARE\n         B     GENERICM\n         SPACE 1\nNOREPL   MVI   HOLDREPL,C'N'\n         MVI   FRSTREPL+1,SETBR\n         B     CHKGENRC         CHECK IF GENERIC MEMEBER NAME\n         SPACE 2\nNOMEMCHK MVI   SELMEM+1,SETBR   BYPASS MEMSYSIN RTN- PROCESS ALL RECS\n         B     MVMEMNM\n         SPACE 2\nLIBCOMPU L     R7,SAVEINFO+4   GET BLKSIZE FROM R9 OF RECFM=U BLOCK\n         L     R6,INBUFF    PUT INPUT BUFFER ADDR IN R6\n         CLC   STOWMNME,BLDENTRY  IS NEW MEMBER NAME = OLD MEMBER NAME\n         BNE   MEMBCHGU          NO\nWRITEU   BAL   R4,WRITEFU YES - WRITE RECFM=U BLOCK WITH LENGTH IN R7\n         B     RETURN3\n         SPACE 2\nRETURN3  LA    R15,0               R15=0 PDS IS NOT AT END\n         LR    R1,R11\n         STM   R8,R11,SAVEINFO\n         LM    R2,R14,SAVEAREC\n         BR    R14\n         SPACE 2\nREPMEM   CLI   REPLFLAG,C'Y'   SHOULD WE REPLACE MEMBER\n         BNE   LIBERR           NO\nCHKDISP  NOP   REPLSTOW   YES-SET TO BR AFTER 1ST TIME THRU\n         MVI   CHKDISP+1,SETBR\n         RDJFCB ((R5))        GET SETTING OF JCL DISP PARAMETER\n         L     R1,=A(JFCBIND2)\n         TM    0(R1),JFCSHARE IS DISP=SHR CODED IN JCL\n         BNO   REPLSTOW       NO-OK\n         LA    R15,8          YES, PUT OUT ERROR MSG\n         B     LIBERR\nREPLSTOW STOW  (R5),STOWLIST,R  YES-REPLACE MEMBER\n         LTR   R15,R15          OK?\n         BZ    LIBCONT1         YES\nLIBERR   STC   R15,RETURN3+3   NO-OTHER ERROR, STORE RC OF STOW\nBYPOINT  NOP   LIBCONT2        SET TO BRANCH AT EOJ\n         POINT (R5),WRITEPOS   RESET WRITE POINTER ON DUP WITH NO REPL\n         B     LIBCONT2        AND EVENTUALLY GET OUT-ERROREOJ\n         DROP  R12\n         SPACE 2\nSAVEINFO DS    4F\nWRITEPOS DS    F     TTR0-RELATIVE BLK ADDR OF 1ST BLOCK OF MEMBER\n*                    AFTER A SUCCESSFUL STOW\nDADDSAV  DC    F'1'  POINTER TO NEXT BLK(1 IN LOW BYTE FOR NEXT BLK)\nINBUFF   DS    F     ADDR OF AREA FOR INPUT BUFFER\nLENGTHSV DC    F'0'  BLKSIZE+KEYLE\nBLDLADD  DC    H'1'  NO OF ENTRIES IN BLDL TABLE\n         DC    H'76' LENGTH OF ENTRIES IN BLDL TABLE\nBLDENTRY DC    CL8'        '   MEMB NAME IN BLDL TABLE-PRGRM SUPPLIED\nBLDLTTR  DS    XL3   TTR IN BLDL TABLE-SYSTEM SUPPLIED\n         DS    2X    K,Z\nBLDLREST DS    XL63  C AND USER DATA\n         SPACE 1\nKEYLEN   DC    H'0'     SAVE THE KEYLENGTH\nRECLEN   DC    H'0'     SAVE THE LRECL\nBLKLEN   DC    H'0'     SAVE THE BLKSIZE\nDIRBLK   DS    CL264      DIRECTORY WORK AREA\nMEMBCNT  DC    PL8'0'   NUMBER OF MEMBERS CREATED IN LIBOUT RTN\nOUTBUFF  DS    A        OUTPUT BUFFER ADDR FOR LIBOUT- HELD IN R6\nBLKBUFL  DC    H'0'    CURRENT BLK BUF LENGTH\nINITBLK  DC    H'0'   BLOCK INITIALIZATION (0 FOR FIXED,4 FOR VARIABLE)\nSVBLKSIZ DC    H'0'     SAVE OUTPUT BLKSIZE HERE\n         SPACE 1\nSTOWLIST DS    0F    STOW LIST USED IN STOW MACRO\nSTOWMNME DS    CL8   MEMBER NAME OF MEMBER TO BE ADDED-SUPPLIED BY PGRM\n         DS    XL3   TTR - SUPPLIED BY SYSTEM\nSTOWREST DS    XL63  C AND USER DATA; MOVED IN FROM BLDLREST\n         SPACE 1\nSTOWFLAG DC    C'Y'  Y=SUCCESSFUL STOW;INIT TO Y FOR 1ST BLK OF 1ST MEM\nHOLDREPL DC    C'N'  TEMP FLD TO KEEP REPLFLAG IN SYNCH MEMSYSIN & STOW\nREPLFLAG DC    C'N'     REPLACE MEMBER INDICATOR - DEFAULT=NO\nMEMRECIN DC    CL11' '   MEMSYSIN REC (11 BYTE MEMBNAM*(R))\nFINDAST  DC    256X'00'   FIND '*' FOR GENERIC MEMSYSIN REC\n         ORG   FINDAST+C'*'   PUT NON-ZERO FUNCTION BYTE IN '*'\n         DC    X'FF'\n         ORG   FINDAST+256\nFINDPARN DC    256X'00'   FIND '*' FOR GENERIC MEMSYSIN REC\n         ORG   FINDPARN+C'('  PUT NON-ZERO FUNCTION BYTE IN '*'\n         DC    C'('\n         ORG   FINDPARN+256\n         SPACE 1\nMEMSYSIN DCB   DDNAME=MEMSYSIN,DSORG=PS,MACRF=GL,BLKSIZE=0,            X\n               SYNAD=SYNADERR,EROPT=ACC,EODAD=ENDJOB\n         LTORG\n         TITLE 'PACK,NUMERIC,ALPHBETIC,ALPHMERIC,HEX,EQUTE SYMBOL TABL'\n*THE FOLLOWING STORAGE AREAS WILL BE USED AS TRANSLATE TABLES FOR PACK\n*NUMERIC,ALPHABETIC,ALPHANUMERIC,HEX CLASS TESTS AND EQUATE SYMBOLS.\n* PLUS ADDITIONAL STORAGE ARES\n*        LINKAGE CONVENTIONS-\n*        R15-GETS ADDR OF TABLE LOADED INTO IT\nTRANTABS CSECT\n*******************************************************************\nTRNSTAB1 DC    193X'FF'   THIS TABLE USED FOR ALPHABETIC CLASS TEST\n         DC    9X'00',7X'FF'    A-I    '00'=ALPHABETICS,'FF'=GARBAGE\n         DC    9X'00',8X'FF'    J-R\n         DC    8X'00',22X'FF'   S-Z\n*******************************************************************\nTRNSTAB2 DC    160X'FF'   THIS TABLE USED FOR NUMERIC CLASS TEST\n*THE '01' FUNCTION BYTES ARE FOR THE LAST DIGIT SIGNED BYTE,'FF'=GARBAG\n         DC    5X'01010101010101010101FFFFFFFFFFFF'   A0-EF\n         DC    10X'00'    F0-F9   THE ACTUAL ZONED NUMERICS\n         DC    6X'FF'\n*******************************************************************\n*     THE FOLLOWING TABLE USED FOR PACK CLASS TEST\n* '00' FUNCTION BYTE=LEGIT PACK BYTE,'01' FUNCTION BYTE=SIGN PACK BYTE\nTRNSTAB3 DC    10X'00000000000000000000010101010101'  00-9F\n         DC    33X'FF'                  A0-C0\n         DC    X'AABBCCDDEEFF'          A-F (C1-C6)\n         DC    42X'FF'                  C7-F0\n         DC    X'112233445566778899'    1-9 (F1-F9)\n         DC    6X'FF'\n*******************************************************************\nTRNSTAB4 DC    193X'FF'   THIS TABLE USED FOR ALPHANUMERIC CLASS TEST\n         DC    9X'00',7X'FF'   A-I  'FF'=GARBAGE,'00'=ALPHABET OR NUMER\n         DC    9X'00',8X'FF'   J-R\n         DC    8X'00',6X'FF'   S-Z\n         DC    10X'00',6X'FF'  0-9\n*******************************************************************\nTRNSTAB5 DC    X'000102030405060708090A0B0C0D0E0F' TRANSLATE TABLE USED\n         DC    X'101112131415161718191A1B1C1D1E1F' FOR Y= EQUATE SYMBOL\n         DC    X'202122232425262728292A2B2C2D2E2F'   OPTION\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'808182838485868788898A8B8C8D8E8F'\n         DC    X'909192939495969798999A9B9C9D9E9F'\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n*******************************************************************\nHEXTAB1  DC    193X'FF'   THIS TABLE USED FOR VALIDATING HEX CHARS\n         DC    6X'00'          A-F  'FF'=GARBAGE,'00'=VALID HEX\n         DC    41X'FF'\n         DC    10X'00',6X'FF'  0-9\n*******************************************************************\nHEXTAB2  DC    193X'FF'   THIS TABLE USED FOR CONVERTING EXTERNAL HEX\n         DC    X'AABBCCDDEEFF'\n         DC    41X'FF'\n         DC    X'00112233445566778899',6X'FF'\n*******************************************************************\nCNVRTABL DC    X'000102030405060708090A0B0C0D0E0F' CONVERT TABLE USED\n         DC    X'101112131415161718191A1B1C1D1E1F' WHEN CONVERT DD\n         DC    X'202122232425262728292A2B2C2D2E2F'   REQUESTED\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'808182838485868788898A8B8C8D8E8F'\n         DC    X'909192939495969798999A9B9C9D9E9F'\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n*******************************************************************\nOPTIONS  DC    193X'00' TRANSLATE USED TO FIND THE PRIMARY OPTIONS\n         DC    X'04'         THE BRANCH VALUE (04) FOR THE A OPTION\n         DC    X'08'         THE BRANCH VALUE (08) FOR THE B OPTION\n         DC    X'0C'         THE BRANCH VALUE (12) FOR THE C OPTION\n         DC    X'10'         THE BRANCH VALUE (16) FOR THE D OPTION\n         DC    X'14'         THE BRANCH VALUE (20) FOR THE E OPTION\n         DC    X'18'         THE BRANCH VALUE (24) FOR THE F OPTION\n         DC    X'1C',10X'00' THE BRANCH VALUE (28) FOR THE G OPTION\n         DC    X'20',1X'00'  THE BRANCH VALUE (32) FOR THE K OPTION\n         DC    X'24',1X'00'  THE BRANCH VALUE (36) FOR THE M OPTION\n         DC    X'28'         THE BRANCH VALUE (40) FOR THE O OPTION\n         DC    X'2C'         THE BRANCH VALUE (44) FOR THE P OPTION\n         DC    X'30'         THE BRANCH VALUE (48) FOR THE Q OPTION\n         DC    X'34',8X'00'  THE BRANCH VALUE (52) FOR THE R OPTION\n         DC    X'38'         THE BRANCH VALUE (56) FOR THE S OPTION\n         DC    X'3C',1X'00'  THE BRANCH VALUE (60) FOR THE T OPTION\n         DC    X'40'         THE BRANCH VALUE (64) FOR THE V OPTION\n         DC  26X'00'\n*******************************************************************\nOPTNTABL DC    194X'00' TRANSLATE USED TO FIND B=,E=,J=,V=,Y= KEYWORDS\n         DC    X'1C',2X'00'  THE BRANCH VALUE (28) FOR B= IN R2\n         DC    X'0C',11X'00' THE BRANCH VALUE (12) FOR E= IN R2\n         DC    X'14',19X'00' THE BRANCH VALUE (20) FOR J= IN R2\n         DC    X'08',2X'00'  THE BRANCH VALUE (08) FOR V= IN R2\n         DC    X'04',23X'00' THE BRANCH VALUE (04) FOR Y= IN R2\n*******************************************************************\nASTPAREN DC    256X'00'   V OPT TABLE TO FIND *,'(',')','!' IN SYSIN\n         ORG   ASTPAREN+C'*'\n         DC    C'*'\n         ORG   ASTPAREN+C'('\n         DC    C'('\n         ORG   ASTPAREN+C')'\n         DC    C')'\n         ORG   ASTPAREN+C'!'\n         DC    C'!'\n         ORG   ASTPAREN+256\n*******************************************************************\nCOMMABLK DC    256X'00'  V OPT TABLE TO FIND ',' AND ' ' IN VOL=\n         ORG   COMMABLK+C' '\n         DC    C' '\n         ORG   COMMABLK+C','\n         DC    C','\n         ORG   COMMABLK+256\n*******************************************************************\nVPARMTAB DC    256X'00'  V OPT TABLE TO FIND QUOTES ON PARM\n         ORG   VPARMTAB+X'7D'\n         DC    X'7D'\n         ORG   VPARMTAB+256\nWLDCRDTB DC    256X'00'  TABLE TO FIND '.' AND ' '\n         ORG   WLDCRDTB+C'.'\n         DC    C'.'\n         ORG   WLDCRDTB+C' '\n         DC    C' '\n         ORG   WLDCRDTB+256\nPLUSTABL DC    256X'00'  TABLE TO FIND '+'\n         ORG   PLUSTABL+C'+'\n         DC    C'+'\n         ORG   PLUSTABL+256\nSLSHTBL  DC    256X'00'  TABLE TO FIND '/'\n         ORG   SLSHTBL+C'/'\n         DC    C'/'\n         ORG   SLSHTBL+256\nBINTRTBL DC    240X'00'      TABLE TO TRANSLATE HEX TO PRINTABLES\n         DC    C'0123456789ABCDEF'\n*******************************************************************\nVOLTABL  DC    11XL80'00' TABLE OF SYSIN RECS UP TO 10 ENTRIES-V OPT\nVOLSER   DC    10XL7'00'  VOLSER TABLE OF UP TO 10 ENTRIES- V OPT\nVPARM    DS    H,CL80     PARM FROM VSYSIN FILE ON V OPTION\nDAIRBUF  DS    XL510        MSG BUFFER FOR DAIRFAIL\nMSG65LBL DC    CL80' '     HOLDS LABEL ON TAPELABL OPTION   @MK1\n*******************************************************************\n         TITLE 'T,P,E AND G PROCESSING'\n*THE P OPTION IS SIMILIAR TO THE 'T' OPTION EXCEPT THAT PAIRS OF\n*KEYS ARE READ INTTO A TABLE.  THE PAIRS ARE SORTED IN ASCENDING ORDER\n*OF THE FIRST KEY OF EACH PAIR.  ANY KEY FROM THE INPUT RECORD THAT IS\n*EQUAL TO OR GREATER THAN THE FIRST KEY OF A PAIR AND IS EQUAL TO OR\n*LESS THAN THE SECOND MEMBER OF THE PAIR IN THE TABLE IS SELECTED.\n*THE P OPTION USES A SORTED TABLE BUT DOES A SEQUENTIAL SEARCH OF THE\n* TABLE.(THE BINARY SEARCH ROUTINE IS BYPASSED)\n*E.G.  IF THE TABLE HAD THE FOLLOWING ENTRIES\n*        5  10\n*       20  30\n*      ANY KEYS BETWEEN 5 AND 10 OR 20 AND 30 WOULD BE SELECTED.\n*   THE T LOGIC IS USED TO MATCH A FILE AGAINST THE SYSIN FILE\n*      IF THE KEY FROM THE INPUT FILE MATCHES ANY OF THE KEYS FROM\n*      THE SYSIN FILE THEN THE RECORD IS NOTED AS SELECTED AND WRITTEN.\n*      THE COUNT FIELD FROM THE PARM FIELD WILL BE USED BY 'T' AND\n*      'TB' TO INDICATE THE NUMBER OF RECORDS TO SELECT FOR EACH\n*      KEY.  FOR 'TN'  THE COUNT IS USED AS A TOTAL COUNT TO\n*      INDICATE THE TOTAL NUMBER OF RECORDS THAT DON'T MATCH THE KEYS.\n*THE FOLLOWING CONVENTIONS ARE USED BY THE CALLED & CALLING MODULES:\n*  R1    PASSES THE INPUT RECORD ADDRESS TO THE E LOGIC\n*  R3 PASSES THE INPUT RECORD KEY ADDRESS TO BINARY SEARCH.\n*  R4 USED TO PASS THE LENGTH OF THE KEY FOR COMPARISON.\n*        R4 IS SET TO 19 FOR THE E LOGIC\n*  R5 USED TO PASS THE LENGTH OF THE KEY + 4(COUNT FIELD)=TABLE ENTRY.\n*        R5 IS SET TO 24 FOR THE E LOGIC\n* R14 IS USED FOR THE RETURN ADDRESS INTO THE CALLER\n* R15 IS USED AS THE BRANCH ADDRESS ON THE BALR INSTRUCTION  AND ALSO\n*     FOR A RETURN CODE TO SIGNIFY WHETHER THE RECORD WAS SELECTED (0)\n*     OR NOT SELECTED (1).\n*        REGISTERS 0 IS NOT USED(SYSTEM REGISTER) R2 USED IN E LOGIC\n*        R6=BASE REGISTER,R7=TABLE POINTER,R9=WORK REGISTER\n*        R10,R11,R12 ARE USED IN THE BINARY SEARCH ROUTINE,R13=TABLEND\nTSEARCH  CSECT\n         USING *,R15            T LOGIC LINKAGE\n         STM   R6,R14,SAVEAREB  SAVE CALLERS REGISTERS IN SAVE AREA\n         CNOP  0,4              ALIGN ON FULL WORD FOR BAL\n         BAL   R6,JUMPSAVX   JUMP PAST SAVE AREA  AND LOAD R6 AS BASE\nSAVEAREB DS    9F              SAVE AREA FOR REGISTERS\nJUMPSAVX EQU   *\n         USING SAVEAREB,R6   SET BASE REGISTERS\n         DROP  R15           15 NO LONGER BASE REG\n         ST    R1,STARTADR SAVE THE ADDR OF THE INPUT RECORD FOR E LOG\n         L     R13,=A(TABLEND) LD R13 WITH ADDR OF END OF TABLE\n         L     R13,0(0,R13)\nSETDISP  NOP   TSRCH1        SET TO BRNCH AFTER 1ST TIME THRU\n         MVI   SETDISP+1,SETBR  BRANCH AROUND FIRST TIME ROUTINE\n         L     R9,=A(MSG40FVU) GET RECFM\n         CLI   0(R9),C'U'   IS RECFM=U\n         BNE   CHKRECV      NO\n         MVI   EUOPTBR+1,SETNOP YES - SET NOP TO ADJUST FOR SMALL BLOCK\n         B     NOTVREC\nCHKRECV  CLI   0(R9),C'V'          IS RECFM=V\n         BNE   NOTVREC        NO\n         MVI   EVOPTBR+1,SETNOP YES SET NOP TO ADJUST FOR INTERNAL LENG\nNOTVREC  L     R9,=A(ELOGIC)\n         CLI   1(R9),SETBR     IS THE E LOGIC ROUTINE REQUESTED\n         BNE   NOTEOPT         NO\n         LA    R4,19      YES- SET R4=19 FOR KEY LENGTH-1\n         MVI   TSRCH1+1,SETBR  BYPASS SORTING THE KEYS\n         MVI   ELOGBR+1,SETBR  SET BRANCH TO GO INTO E LOGIC\n         L     R9,=A(ECHGMSG)\n         CLI   1(R9),SETNOP IS CONVERT (CHANGE) USED WITH E OPT\n         BNE   NOTEOPT      NO\n         MVI   ECHGMTCH+1,SETNOP SET NOP TO CHANGE KEY WHEN FOUND\n         MVI   TSRCH99+1,SETNOP NOP TO DO ALL CHANGES IN REC- NOT JUST\n*        WHEN THE THE FIRST KEY IS FOUND\n         L     R9,=A(ECHGKEY)   GET SYSIN+CONVERT KEY\n         MVC   ECHNGKEY,0(R9)\n         L     R9,=A(EJEQCNT)   GET J= COUNT ON $ OR @ CHG\n         MVC   EJEQUCNT,0(R9)\nNOTEOPT  EQU   *\n         SPACE 1\n*          THE KEY LENGTH-1 IS PASSED IN R4\n         STC   R4,SORTCOMP+1 SET LENGTH FOR COMPARE IN THE SORT\n         STC   R4,TSRCOMP+1  SET LENGTH FOR COMPARE IN THE BIN SEARCH\n         STC   R4,PCOMPAR2+1  SET LENGTH FOR UPPER KEY COMPARE (P)\n         STC   R5,PCOMPAR2+3  SET DISPLACEMENT FOR HIGH KEY COMPARE (P)\n         LA    R9,1(R4)      SET R9 TO ACTUAL KEY LENGTH\n         STC   R9,TMATCH1+3  SET DISPLAC FOR CNT COMPARE IN BIN SEARCH\n         STC   R9,TABLEADD+3 SET DISPLAC TO ADD 1 TO CNT IN BIN SEARCH\n         SPACE 2\n         L     R9,=A(TLOGNEQ)  LD R9 WITH ADDR OF TLOGNEQ FOR N SUBOPT\n         CLI   1(R9),SETBE      IS THIS THE N SUBOPTION\n         BNE   CHKFORP             NO\n         MVI   BYPCNT+1,SETBR     BYPASS THE INDIVIDUAL COUNTS\n*                           IS THE 'P' OPTION IN EFFECT\nCHKFORP  L     R9,=A(PLOGNOP) LOAD R9 WITH ADDR OF PLOGNOP FOR P TEST\n         CLI   1(R9),SETNOP   IS THIS THE P KEY\n         BNE   TCONTINU       NO\n         MVI   PLOGBR+1,SETBR   YES-BYPASS THE BINARY SEARCH\n         AR    R5,R5            DOUBLE THE LENGTH OF THE KEYS\n         LR    R4,R5            PUT THE DOUBLED LENGTH IN R4 ALSO\n         BCTR  R4,0             ADJUST FOR NEW LENGTH  SUBTRACT 1\nTCONTINU STC   R5,INTRCHG2+3 SET DISPLAC IN THE INTERCHANGE OF THE SORT\n         STC   R5,INTRCHG1+5\n         STC   R5,SORTCOMP+5 SET DISPLAC FOR THE COMPARE IN THE SORT\n         STC   R4,INTRCHG1+1 SET LENGTH IN THE INTERCHANGE\n         STC   R4,INTRCHG2+1\n         L     R9,=A(COUNT)     LOAD ADDRESS OF COUNT INTO R9\n         MVC   SELCOUNT,0(R9)   INITIALIZE THE SELECTION COUNT\n*        THE BINARY SORT IS DONE ONCE AND THEN BYPASSED\nTSRCH1   NOP   BNRYSRCH CHNGD TO B WHEN SYSIN CARDS HAVE BEEN SORTED\n*  SORT THE TABLE ENTRIES USING A BUBBLE SORT\n         L     R7,=A(TABLE)  LD THE TABLE BEGINNING ADDRESS\n         L     R7,0(0,R7)\n         MVI   ALLDONE,C'0' INITIALIZE ALLDONE TO  ZERO\nTSORT    CR    R7,R13  LAST ENTRY THIS PASS-R13=ADDR OF LAST TABLE ENT\n         BNL   TSORTEND      YES-SEE IF ALL THE ENTRIES ARE IN ORDER\nSORTCOMP CLC   0(0,R7),0(R7)  COMPARE 2 ENTRIES-LENGTH & DISPL ADJUSTED\n         BNH   TNEXTKEY   THE CURRENT ENTRY NOT MORE THAN NEXT ENTRY\n*     THREE EXCLUSIVE ORS REVERSE TWO FIELDS\nINTRCHG1 XC    0(0,R7),0(R7) INTERCHANGE 2 CONSECUTIVE KEYS\nINTRCHG2 XC    0(0,R7),0(R7) LENGTHS AND DISPLACEMENTS MODIFIED\n         EX    0,INTRCHG1    COMPLETE THE INTERCHANGE\n         MVI   ALLDONE,C'1'    INDICATE THAT A MOVE OCCURED\nTNEXTKEY AR    R7,R5            UP THE ENTRY BEING WORKED ON\n         B     TSORT         PROCESS THE NEXT ENTRY IN THE TABLE\nTSORTEND CLI   ALLDONE,C'0'     IS SORT FINISHED\n         BNE   TSRCH1       NO-CONTINUE SORTING\n         MVI   TSRCH1+1,SETBR YES-ACTIVATE PROCESSING ROUTINE\n         SPACE 3\n*            BINARY SEARCH ROUTINE AND RETURN TO MAINLINE\nBNRYSRCH EQU   *            LOAD R7 WITH THE ADDRESS OF THE TABLE\n         L     R7,=A(TABLE)  LD THE TABLE BEGINNING ADDRESS\n         L     R7,0(0,R7)\n         LR    R9,R7        LOAD R9 WITH THE ADDRESS OF THE TABLE\n         LA    R15,1       INITIALIZE R15 (1=NO MATCH OR ENTRY IS FULL)\n*\nELOGBR   NOP   ELOGIC1   CHANGED TO B ON E OPTION-BYPASS BINARY SEARCH\nPLOGBR   NOP   PLOGIC1   CHANGED TO B ON P OPTION-BYPASS BINARY SEARCH\n*\n         L     R12,=A(RCOUNT)  LOAD THE ADDRESS OF RCOUNT INTO R12\n*           RCOUNT IS USED TO COUNT THE NUMBER OF SYSIN\n*           RECORDS AND ALSO THE TABLE ENTRIES\n         CVB   R12,0(0,R12)   CONVERT THE NO OF SYSIN RECORDS TO BINARY\nTSRCHLOP EQU   *            THIS IS THE TABLE SEARCH LOOP\n         LTR   R11,R12   ANY MORE ENTRIES TO BE CHKED (R12=NO ENTRIES)\n         BZ    TSRCH99      THE ENTRY IS NOT IN THE TABLE\n         CR    R11,R15   IS THE ENTRY BEING PROCESSED ONE (R15=1)\n         BNE   TSRCOMP      NO THIS IS NOT THE LAST COMPARE\n         SR    R11,R11      LOAD THE ENTRY INCREMENT WITH ZEROS\n*                                    THIS IS THE END OF THE SEARCH\nTSRCOMP  CLC   0(0,R7),0(R3)  IS THIS ENTRY EQUAL TO THE TABLE ENTRY\n         BE    TMATCH          YES GO TO FOUND ROUTINE\n         BL    TSRCHINC    NO-THE TABLE ENTRY IS LOW COMPARED TO INPUT\n*         R9 HAS THE FIRST ENTRY IN THE TABLE\n         CR    R9,R7       IS FIRST SYSIN HIGH COMPARED TO INPUT\n         BE    TSRCH99         YES-NO MATCH\n*  THE TABLE WAS GREATER, DIVIDE THE CURRENT ENTRY(R2)BY 2 AND ROUND\n*  IT.MULTIPLY ENTRY BY LENGTH.SUBTRACT RESULT FROM CURRENT POINTER.\nTSRCHRED NR    R11,R15   ZERO OUT ALL BITS EXCEPT THE LOW ORDER (R15=1)\n         SRL   R12,1     DIVIDE BY 2  THE NUMBER OF ENTRIES IN TABLE\n         AR    R12,R11        IF NUMBER WAS ODD ADD 1 TO ROUND IT\n         LR    R11,R12        LOAD THE RESULT INTO R11\n         MR    R10,R5    MULTIPLY THE TABLE SPLIT FACTOR BY KEY LENGTH\n*              THE FOLLOWING INSTRUCTION IS CHANGED DYNAMICALLY\nADDORSUB SR    R7,R11          REDUCE THE TABLE ADDRESS BY THE RESULT\n         MVI   ADDORSUB,X'1B'  CHANGE SR INSTRUCTION BACK TO SR\n         B     TSRCHLOP        GO TO CONTINUE PROCESSING\n*   THE BELOW INSTRUCTIONS ARE PERFORMED IF THE TABLE ENTRY IS LOW\nTSRCHINC MVI   ADDORSUB,X'1A'   CHANGE ABOVE SR INSTRUCTION TO AR\n         B     TSRCHRED         GO TO TSRCH REDUCE\n         SPACE 3\nPLOGIC1  CR    R7,R13       HAS LAST ENTRY BEEN HIT\n         BNL   TSRCH99         YES-RETURN\n         EX    0,TSRCOMP       NO-COMPARE 1ST KEY OF PAIR TO INPUT\n         BH    TSRCH99         LOW KEY IN SYSIN HIGH TO INPUT-NOMATCH\n*           IF THE TABLE ENTRY IS HIGH THEN THERE IS NO MATCH. GET OUT\nPCOMPAR2 CLC   0(0,R7),0(R3)   IS UPPER KEY LESS THAN INPUT\n         BNL   TMATCH          NO-IT FALLS IN THE RANGE\n         AR    R7,R5          YES-POINT TO NEXT PAIR OF KEYS ON TABLE\n         B     PLOGIC1         RECOMPARE\n         TITLE 'E LOGIC-STRING EDITING TYPE LOGIC'\nELOGIC1  NOP   ECOMPAR1        SET TO B AFTER FRIST TIME THRU\n         MVI   ELOGIC1+1,SETBR\n         L     R1,=A(EKEYMSG2+1)\n         MVI   0(R1),SETNOP SET NOP TO PROCESS E KEY MESSAGES\n         LA    R11,TRNSTAB6    CALCULAT LENGTH OF EACH KEY\nELOOP    LA    R10,0                CLEAR R10\n         IC    R10,0(0,R7)  INSERT DELIMITER CHAR IN R10\n         STC   R10,DELIMITR     SAVE DELIMITER CHARACTER (FOR #)\n         AR    R10,R11          FIND DELIMITER POS IN TABLE\n         MVI   0(R10),X'01'    INSET 1 AS A FUNCTION BYTE\n         LA    R7,1(R7)           POINT BEYOND DELIMITER\n         TRT   0(19,R7),TRNSTAB6  FIND SECOND DELIMITER\n         BZ    INVALKEY      ERROR-NO SECOND DELIMITER-KEY TOO LARGE\n         ST    R1,DELIMADR   SAVE THE THE ADRRESS OF THE DELIMITER\n         SR    R1,R7         GET LENGTH OF SYSIN KEY\n         BZ    INVALKEY      ERROR-2 CONSECUTIVE DELIMITERS-NO KEY\n         BCTR  R7,0          POINT TO 1ST BYTE OF KEY\n         STC   R1,0(0,R7)    STORE ACTUAL LENGTH OF KEY IN 1ST BYTE\n         CLI   DELIMITR,C'#'    IS DELIMITER '#' - 'AND' KEY\n         BE    DELIM#        YES\nRESET    MVI   0(R10),X'00'    RESET TRANSLATE TABLE TO LOW VALUES\n         AR    R7,R5        POINT TO NEXT SYSIN KEY ENTRY\n         CR    R7,R13       IS THIS LAST ENTRY\n         BL    ELOOP          NO\n         LR    R7,R9     RESET R7 TO POINT TO START OF TABLE\n         SPACE 2\n         LA    R12,0     CLEAR R12\n         L     R9,=A(POSLENS)\nLPLOOP   CLI   0(R9),X'FF'     ARE THERE ANY MORE COLUMN SPECIFICATIONS\n         BE    COLSET\n         L     R10,0(0,R9)  GET 'FROM' COLUMN SPECIFICATION\n         LA    R11,4(0,R9)       POINT TO 'TO' COL SPECIFICATION\n         L     R11,0(0,R11)    GET 'TO' COLUMN SPECIFICATION\n         SR    R11,R10          PUT INTERVAL LENGTH-1 IN R11\n         LA    R11,1(R11)       PUT ACTUAL INTERVAL LENGTH IN R11\n         STH   R10,COLSTORE(R12)      STORE 'FROM' COL IN COLSTORE\n         STH   R11,COLSTORE+2(R12)    STORE INTERVAL LENGTH IN COLSTORE\n         LA    R12,4(R12)\n         LA    R9,8(R9)           POINT TO NEXT 'FROM','TO' COLUMN PAIR\n         C     R12,=F'12'\n         BL    LPLOOP\nCOLSET   ST    R12,COLCOUNT\n         SPACE 3\nECOMPAR1 EQU   *\n         L     R3,STARTADR    LOAD ADDR OF BEGINNING OF REC\n         LA    R12,0          CLEAR R12\nNEWKEY   CR    R7,R13         IS THIS THE END OF THE TABLE\n         BNL   TSRCH99            YES\n         CLI   0(R7),X'FF'    IS THIS A VALID KEY ENTRY\n         BE    NEXTEKEY NO\n         IC    R12,0(0,R7)    INSERT LENGTH OF SYSIN KEY INTO R12\n         SPACE 1\n         MVI   ECOMPAR2+3,X'01'  RESET DISPLACEMENT OF SYSIN KEY FOR #\n         CLI   19(R7),C'#'   'AND' KEY? # IN LAST BYTE OF SYSIN REC\n         BE    SET#PROC       YES - DO 'AND' KEY PROCESSING\nSET#RET  MVI   ECOMP#+1,SETNOP   RESET BRANCH AFTER FIRST MATCH ON #\nE#CONT   BCTR  R12,0       SUBTRACT 1 FROM LENGTH FOR CLC INSTRUCTION\n         STC   R12,ECOMPAR2+1      MOVE IN LENGTH ATTRIBUTE\n         STC   R12,ECHG+1      MOVE IN LENGTH ATTRIBUTE FOR E OPT CHG\n         STC   R12,ECLC+1      MOVE IN LENGTH ATTRIBUTE FOR E OPT CLC\n         LA    R12,1(R12)        RESET R12 TO ACTUAL KEY LENGTH\n         LA    R9,0                    CLEAR R9\nNEWCOL   C     R9,COLCOUNT        ARE THERE ANY MORE COLUMN PAIRS\n         BE    NEXTEKEY                 NO\n         LH    R10,COLSTORE(R9)     GET 'FROM' COLUMN SPECIFICATION\n         LH    R11,COLSTORE+2(R9)   GET INTERVAL LENGTH\n         SPACE 1\nEVOPTBR  B     EUOPTBR       NOP ON RECFM=V RECS\n         LH    R2,0(0,R3)  GET RDW AND PLACE IT IN R2\n         B     EUVCOMP     GO TO COMMON RECFM U OR V RTN\n         SPACE 1\nEUOPTBR  B     NOTEU         NOP ON RECFM=U\n         L     R2,=A(DCBADDR)  GET DCB ADDR OF INPUT FILE\n         L     R2,0(R2)\n         LH    R2,LRECL(R2) GET BLKSIZE FROM DCB LRECL FIELD\nEUVCOMP  CR    R10,R2     IS 'FROM' COL GREATER THAN BLKSIZE/RDW\n         BH    NEXTEKEY            YES\n         AR    R10,R11          NO-R11=LENGTH,R10 NOW HAS 'TO' COL\n         CR    R10,R2           IS 'TO' COL GREATER THAN BLKSIZE/RDW\n         BH    ADJUSTU              YES-ADJUST LENGTH\n         SR    R10,R11       NO-RESTORE R10 TO 'FROM'\n         B     NOTEU            GET OUT\n         SPACE 1\nADJUSTU  SR    R10,R11         RESTORE R10 TO 'FROM' COL\n         SR    R2,R10  R2=(BLKSIZE/RDW-'FROM' COL)=LENGTH OF INTERVAL\n         LA    R11,1(R2)     MOVE ACTUAL INTRVAL LENGTH TO R11\nNOTEU    EQU   *\n         SPACE 1\n         LA    R10,0(R10,R3)    SET R10 TO POINT WITHIN INPUT REC\nNEWCHAR  CR    R12,R11            IS KEY LENGTH MORE THAN INTERVAL LENG\n         BH    NEXTCOLS              YES-GET NEXT COLUMN PAIR\nECOMPAR2 CLC   1(0,R7),0(R10)  NO-COMP SYSIN KEY TO REC;DISPL MOD '#'\nECOMP#   NOP   COMP#KY       CHG TO BE ON 'AND' KEY\n         BE    ECHGMTCH  MATCH FOUND\n         LA    R10,1(R10)     POINT TO NEXT BYTE OF INPUT FILE\n         BCT   R11,NEWCHAR      LOOP BACK FOR NEXT COMPARE\nNEXTCOLS LA    R9,4(R9)         POINT TO NEXT COLUMN PAIR\n         B     NEWCOL\nNEXTEKEY LTR   R15,R15  HAS RECORD ALREADY BEEN SELECTED\n         BZ    TEND     YES\n*        A RECORD CAN ALREADY HAVE SELECTED AND STILL GET TO THIS POINT\n*        IF THE E OPTION WITH THE CONVERT CHANGE KEY HAS BEEN REQUESTED\n*        AND THE RECORD CONTAINED A CHANGE-KEY SO THAT THE SEARCH FOR\n*        MORE CHANGE-KEYS CONTINUES ON THAT RECORD.\n         AR    R7,R5    NO- POINT TO SYSIN KEY\n         B     NEWKEY\n         SPACE 2\nINVALKEY BCTR  R7,0\n         MVI   0(R7),X'FF'      MARK THE AS INVALID\n         B     RESET        CONTINUE PROCESSING THE SYSIN KEYS\n         SPACE 2\nECHGMTCH B     TMATCH  SET TO NOP IF E OPT CHANGE (CONVERT) REQUESTED\nECLC     CLC   0(0,R10),ECHNGKEY+1 IS THIS THE E OPT KEY TO BE CHGED\n         BNE   TMATCH             NO\n         CP    ECHGCNT,EJEQUCNT Y-IS J= SATISFIED FOR NO. OF KEYS CHGED\n         BL    ECHG      NO -  DO  MORE KEY CHANGES\n         LTR   R15,R15  WAS THIS RECORD MATCHED ALREADY\n         BZ    TEND     YES- GET OUT\n         B     TMATCH   NO-SELECT RECORD AND COUNT BUT DONT ADD TO CHG\nECHG     MVC   0(0,R10),ECHNGKEY+20 MVE CHANGE INTO RECORD\n         AP    ECHGCNT,=P'1'     YES-ADD 1 TO CHG COUNT\n         CLI   EMTCHFLG,C'0'       IS THIS THE FIRST CHANGE IN RECORD\n         BH    EMULTMCH          NO-\n         MVI   EMTCHFLG,C'1'     YES- SET FLAG TO INDIC FIRST CHG\n         B     TMATCH            GO TO MATCH AND CNT ROUTINE\n         SPACE 2\nEMULTMCH AR    R10,R12         POINT BEYOND CHANGED KEY,R12=KEY LEN\n         BCT   R11,NEWCHAR     CONTINUE SEARCHING\n         B     NEXTCOLS\n         SPACE 2\nDELIM#   L     R2,DELIMADR     GET 2ND DELIMITER ADR\n         TRT   1(17,R2),TRNSTAB6  FIND 3RD # DELIMITER\n         BZ    RESET           NO 'AND' KEY PROCESSING\n         S     R1,DELIMADR     GET LENGTH OF 2ND 'AND' KEY +1\n         BCTR  R1,0            SUBTR 1\n         LTR   R1,R1           IS LENGTH =0  I.E. CONSECUTIVE #'S\n         BZ    RESET           YES - NO 'AND' KEY PROCESSING\n         L     R2,DELIMADR     GET 2ND '#' DELIM ADDR AGAIN\n         STC   R1,0(R2)        PLACE 2ND KEY LENGTH IN 2ND DELIM\n         MVI   19(R7),C'#'      SET LAST BYTE OF SYSIN REC TO '#'\n         B     RESET\n         SPACE 2\nSET#PROC MVI   ECOMP#+1,SETBE  SET BE TO FORCE COMPARISON OF 2ND KEY\n         B     E#CONT          CONTINUE\n         SPACE 2\nCOMP#KY  L     R3,STARTADR      GET START ADDR OF RECORD\n         IC    R12,0(R7)        GET L1\n         LA    R9,2(R12)        GET L1+2\n         STC   R9,ECOMPAR2+3    SET DISPLAC TO POINT TO 2ND 'AND' KEY\n         IC    R12,1(R12,R7)    GET L2 INTO R12\n         B     SET#RET          RETURN TO FIND 2ND KEY\n         TITLE 'E,T,P,G WRAP-UP LOGIC'\nTMATCH   EQU   *\n         CR    R7,R13    HAVE WE HIT END OF TABLE\n         BNL   TSRCH99   YES\nBYPCNT   NOP   TNMATCH       CHANGED TO B ON N SUBOPTION\nTMATCH1  L     R2,0(0,R7)    POINT TO THE BINARY COUNT FLD-DISPLAC ADJ\n         CVD   R2,PACKCNT    PACK THE COUNT FLD\n         CP    PACKCNT,SELCOUNT HAS THE COUNT FOR THIS ENTRY BEEN MET\n         BNL   TSRCH99          YES IT HAS CHECK REJECT FOR EOJ\n*\n         LA    R2,1(R2)      ADD 1 TO THE ENTRY IN THE TABLE\nTABLEADD ST    R2,0(0,R7)    RESTORE THE COUNT\nTNMATCH  SR    R15,R15        MOVE 0 TO RETURN CODE-PUT OUT MATCH REC\n*\n*         THIS IS THE CSECT EXIT.  RESTORE REGISTERS AND EXIT.\n* FROM   THE E OPTION WITH CONVERT FILE CODED ($ CHANGE) THE EXIT TO\n*        THE CSECT IS ENCOUNTERED IN 3 DIFFERENT WAYS DEPENDING ON\n*        THE SETTING OF THE EMTCHFLG FLAG:\n*        FLAG=0 - THERE WAS NO MATCH ON ANY KEYS OR THE RECORD WAS\n*        SELECTED ON A NON-CHANGE KEY (HENCE NO FIELDS ON THE RECORD\n*        WERE CHANGED).\n*        FLAG=1 - THIS IS THE FIRST MATCH ON A CHANGE-KEY AND WE WILL\n*        CONTINUE TO SEARCH THE RECORD FOR MORE CHANGES BY SETTING THE\n*        FLAG TO 2.\n*        FLAG=2 - THE RECORD WAS SELECTED ON A CHANGE-KEY AND SEARCHING\n*        THE RECORD FOR ADDITIONAL KEYS HAS ENDED.\n*\nTSRCH99  B     TEND        SET TO NOP ON E OPT WITH CONVERT FILE ($CHG)\n         CLI   EMTCHFLG,C'1'  IS FLAG=0 OR 2\n         BNE   TEND           YES - END SEARCH ON THIS RECORD\n         MVI   EMTCHFLG,C'2'  NO FLAG=1 SET IT TO 2 AND KEEP SEARCHING\n         B     EMULTMCH\n         SPACE 3\nTEND     MVI   EMTCHFLG,C'0'  RESET THE E OPT FLAG FOR $ CHANGES\n         LM    R6,R14,SAVEAREB\n         DROP  R6         DROP THE REG 6 AS BASE\n         BR    R14                    RETURN TO CALLER\n         SPACE 2\nPACKCNT  DS    D           USED TO CONVERT THE COUNT\nCOLCOUNT DS    F\nSTARTADR DS    F\nDELIMADR DS    F        ADDRESS OF  2ND '#' DELIMITER\nCOLSTORE DS    6H\nTRNSTAB6 DC    256X'00'\nSELCOUNT DC    PL8'0' THE SELECT CNT IS PASSED HERE FROM R2 ON 1ST CALL\nECHGCNT  DC    PL8'0'    NUMBER OF KEYS CHANGED ON E OPT WITH CONVERT\nEJEQUCNT DS    PL8       NUMBER OF KEYS TO BE CHGED ON E OPT W $ OR @\nALLDONE  DC    C'0' 0 IS USED TO INDICATE THAT THE SORT IS DONE\nEMTCHFLG DC    C'0'  FLG TO DETERMINE IF E OPT CHANGE PROCESS CONTINUES\nDELIMITR DS    CL1              SAVE DELIMITER CHARACTER (FOR #)\nECHNGKEY DS    CL40 SAVE AREA FOR 1ST E OPT SYSIN KEY AND CONVERT KEY\n         LTORG\n         TITLE 'PRINT SUBROUTINE'\n******** THIS IS A CSECT TO OUTPUT SYSUT2,3,4,OR 5 TO A PRINT DATA SET.\n*        IT IS REENTRANT CODED SO THAT ANY OR ALL OF THE ABOVE DATA\n*        SETS MAY BE PUT OUT TO ANY SYSOUT CLASS DURING THE SAME\n*        HFSELECT RUN.\n*        IT IS INVOKED BY CODING SYSOUT=A,H,C,ETC. IN THE DD STATEMENT\n*        FOR WHICH AN OUTPUT PRINT IS DESIRED. IF HEX PRINT AS WELL AS\n*        CHARACTER PRINT IS DESIRED, CODE SYSOUT=CLASS,DCB=RECFM=A.\n*        FOR CHAR + RULER LINE, CODE SYSOUT=CLASS,DCB=RECFM=M.\n*\n*         EXAMPLES: //SYSUT4  DD  SYSOUT=A    CHARACTER PRINTOUT\n*                   //SYSUT2  DD  SYSOUT=C,DCB=RECFM=A   HEX AND\n*                                                      CHARACTER\n*                   //SYSUT3  DD  SYSOUT=A,DCB=RECFM=M  CHAR+RULER\n*        THE LINKAGE AND REGISTER CONVENTIONS ARE:\n*         R0-THE ADDRESS OF THE INPUT RECORD IS PASSED THRU R0\n*            AND THEN LOADED INTO R8\n*         R1-THE ADDRESS OF THE OUTPUT DCB IS PASSED THRU R1\n*            AND THEN LOADED INTO R9\n*         R2-THE ADDRESS OF THE INPUT DCB IS PASSED THRU R2\n*            AND THEN LOADED INTO R10\n*         R5-END OF RECORD - *'S COUNTER, R6-RECORD LENGTH COUNTER\n*         R7-CONTANT BINARY 100, R11-BAL REGISTER\n*\nPRINTER  CSECT                 DEFINE ENTRY POINT\n         USING *,R15           SET R15 AS BASE REGISTER\n         STM   R0,R14,MYSAVE   SYSTEM REGISTERS IN MYSAVE\n         CNOP  0,4\n         BAL   R12,JUMPSAV2\nMYSAVE   DS    15F\nJUMPSAV2 LM    R8,R10,MYSAVE\n         USING MYSAVE,R12\n         DROP  R15\n**             ROUTINE TO INITIALIZE HEX PRINT\n         TM    RECFM(R9),X'04'   IS RECFM=A I.E. IS HEX REQUESTED\nEXITNOP1 BNO   CARDPNCH   NO- SET TO NOP WITH X0 FORMAT=HEX EXIT\n         MVI   BR2HEX+1,SETNOP SET NOP FOR HEX PRINT\n         B     MAINPROG\nCARDPNCH TM    RECFM(R9),X'02'   IS RECFM=M I.E. IS RULER LINE REQUST\nEXITNOP2 BNO   MAINPROG   NO- SET TO NOP WITH X0 FORMAT=RULER EXIT\n         MVI   PRTRULER+1,SETNOP NOP TO PRINT RULER\nMAINPROG EQU   *\n         LA    R7,100            R7 CONTAINS MAX PRINT LINE LENGTH\n         SR    R5,R5             END OF RECORD INDICATOR\n         C     R9,=A(MERGE)      IS THIS THE MERGE FILE\n         BNE   NOTMERGE          YES\n         MVC   FILE+2(6),=C'MERGE '  MERGE FILE\nNOTMERGE L     R3,=A(SYSUTX)     NO\n         MVC   FILE+7(1),0(R3) MOVE IN SYSUTX (X=2,3,4,5)\n         C     R10,=A(CARDS)   IS THE INPUT DATA SET SYSIN\n         BNE   REGCOUNT              NO\n         L     R3,=A(RCOUNT)   YES -USE THE SYSIN COUNTER\n         ED    PTRECNO,3(R3)     EDIT THE COUNT (UP TO 9 DIGITS)\n         B     PRTBEGIN              GO TO BEGIN PRINT\nREGCOUNT L     R3,=A(ENDCT)   PICK UP ADDR OF ENDCT (RECORD COUNT)\nEDIT     ED    PTRECNO,3(R3)     EDIT THE COUNT (UP TO 9 DIGITS)\n         SPACE 2\n         L     R3,=A(BR2VSGET)\n         CLI   1(R3),SETBR       IS THE INPUT VSAM\n         BE    VSAMPRT           YES- GO PICK UP THE RDW IMMEDIATELY\n         C     R10,=A(LIBRARY)  NO-IS THE INPUT A PDS\n         BNE   PRTBEGIN          NO\n         L     R3,=A(BLDENTRY)    YES-PICK UP THE MEMBER NAME\n         MVC   PTRECNO+2(8),0(R3)  MOVE THE MEMBER NAME TO PRINT LINE\n         SPACE 2\nPRTBEGIN LH    R6,LRECL(R10)      PICK UP RECORD LENGTH\n         LTR   R6,R6              IS REC LENGTH ZERO\n         BNZ   ARND2            GO AROUND IF NOT\n         LH    R6,BLKSIZE(R10)    ELSE PICK UP BLKSIZE\nARND2    TM    RECFM(R10),RECFMF  TEST FOR FIXED OR UNDEFINED\n         BO    RTNADDR1           BRANCH IF EITHER\nVSAMPRT  LH    R6,0(R8) FOR VAR RECS MOVE RDW INTO REG-R8 PTS TO REC\n         LA    R8,4(R8)           SET RECORD POINTER TO FIRST BYTE\n         S     R6,=F'4'           ADJUST RECORD LENGTH\nRTNADDR1 LR    R4,R7              SET PRINT COUNT FOR MAX\n         BCTR  R4,0\n         CR    R6,R7              IS RECORD LONGER THAN MAX PRINT LNE\n         BH    ARND1              IF SO PRINT MAX LINE\n         LR    R4,R6              ELSE PRINT RECORD\n         BCTR  R4,0               SUBTRACT ONE FROM COUNT\n         LA    R5,PRNTWK+2(R4)    SET UP MOVE REG\n         MVC   0(2,R5),ASK       MOVE TWO * TO END OF RECORD\nARND1    MVC   PTFROM,MASK1       MOVE EDIT MASK TO PRINT\n         ED    PTFROM,RECNT       EDIT BEGINNING NO OF RECORD\n         CVD   R4,RECCOUNT        END POSITION OF RECORD\n         AP    RECNT,RECCOUNT\n         MVC   PTTO,MASK1         MOVE EDIT MASK TO PRINT\n         ED    PTTO,RECNT         EDIT ENDING NO OF RECORD\n         AP    RECNT,PONE         ADD ONE FOR NEXT LOOP\n         LTR   R5,R5             HAS END OF RECORD BEEN FOUND\n         BNZ   SKIPASK           IF NOT - RETURN\n         MVI   ASK1,C'*'         MOVE * TO POSITION 101\nSKIPASK  STC   R4,MOVE+1          MOVE RECORD OR PORTION TO PRINT\n         STC   R4,MVSPRINT+1     DELETE CONTROL CHARS. IN PRINT STRING\nMOVE     MVC   PRNTWK+1,0(R8)     MOVE RECORD TO PRINT AREA\nASCIIPRT B     MVSPRINT    SET TO NOP WITH X0 FORMAT=ASCII EXIT\n         XLATE PRNTWK,100,TO=E    TRANSLATE TO ASCII\nMVSPRINT TR    PRNTWK+1,TABLE4 TRANSLATE PRINT LINE OF CHARACTERS\n         SPACE 1\nBR2HEX   B     NOHEX             CHANGED TO NOP ON HEX OPTION\n         MVI   PRNTWK,C'0'        FORCE DOUBLE SPACING BETWEEN LINES\n         BAL   R11,PRINTSUB       PRINT CHARACTERS FIRST\n         XC    HEXAREA,HEXAREA    ZERO HEXAREA\n         STC   R4,MOVEZONE+1      MOVE ZONE PORTION TO HEXAREA\n         STC   R4,TRANSZN+1       TRANSLATE ZONE PORTION\n         STC   R4,MOVENUMR+1      MOVE NUMERIC PORTION TO HEXAREA\n         STC   R4,ZONELINE+1\n         STC   R4,TRANSNO+1       TRANSLATE NUMERIC PORTION\n         STC   R4,LNO+1       ADJUST LENGTH FOR PRINTING SCALE\nMOVEZONE MVZ   HEXAREA,0(R8)   MOVE ZONES\nTRANSZN  TR    HEXAREA,TABLE2  TRANSLATE ZONES\nZONELINE MVC   PRNTWK+1,HEXAREA   MOVE TRANSLATED PORTION TO PRNT\n         BAL   R11,PRINTSUB       PRINT FIRST LINE - ZONE\n         XC    HEXAREA,HEXAREA    ZERO HEXAREA\nMOVENUMR MVN   HEXAREA,0(R8)   MOVE NUMERIC PORTION\nTRANSNO  TR    HEXAREA,TABLE3      TRANSLATE NUMERIC\n         EX    0,ZONELINE         MOVE TRANSLATED PORTION TO PRNT\n         BAL   R11,PRINTSUB\nLNO      MVC   PRNTWK+1(1),LINECT MVE IN LINE COUNT LINE (LENGTH ADJ)\nNOHEX    BAL   R11,PRINTSUB       GO TO PRINT SUBR\nPRTRULER B     NORULER   SET TO NOP IF RECFM=M REQ TO PRINT RULER\n         EX    R4,LNO            SET UP TO PRINT RULER LINE\n         BAL   R11,PRINTSUB   PRINT\nNORULER  AR    R8,R7              ADD MAX NO OF CHAR TO REC POINTER\n         SR    R6,R7              SUBTRACT MAX LENGTH FROM REC COUNTER\n         BP    RTNADDR1           LOOP BACK IF MORE TO PRINT\n         SPACE 2\n         MVI   ASK1,BLANK1      RESET ANY DATA NAMES AND INSTRUCTIONS\n         MVI   BR2HEX+1,SETBR          THAT HAVE BEEN MODIFIED\n         MVC   PTRECNO,MASK1\n         MVC   FILE+2(5),=C'SYSUT'   REPLACE 'SYSUT' IN THE PRINT LINE\n         ZAP   RECNT,PONE\n         LM    R0,R14,MYSAVE\n         BR    R14\n         SPACE 2\nPRINTSUB PUT   (R9),PRNTWK    WRITE 100 BYTE PORTION\n         MVI   PRNTWK,BLANK1     BLANK PRINT AREA\n         MVC   PRNTWK+1(132),PRNTWK\n         BR    R11\n         SPACE 4\nRECCOUNT DS    D\nPONE     DC    P'1'\nRECNT    DC    PL3'1'\nMASK1    DC    X'40202020202020202020'\nASK      DC    C'**'\nLINECT   DC    C'----+----1----+----2----+----3----+----4----+----5'\n         DC    C'----+----6----+----7----+----8----+----9----+----0'\nTABLE2   DC    16C'0',16C'1',16C'2',16C'3',16C'4',16C'5',16C'6',16C'7'\n         DC    16C'8',16C'9',16C'A',16C'B',16C'C',16C'D',16C'E',C'F'\nTABLE3   DC    C'0123456789ABCDEF'\nTABLE4   DC    64C' '        ** CHANGE TO ACTUAL CHAR EXCEPT CAR CONTR*\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'808182838485868788898A8B8C8D8E8F'\n         DC    X'909192939495969798999A9B9C9D9E9F'\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\nPRNTWK   DS    0CL133\n         DC    101C' '\nASK1     DC    C' '\nPTRECNO  DC    X'40202020202020202020'  RECORD NO FROM SYSUT1/SYSIN\nPTFROM   DS    X'402020202020'\nPTTO     DS    X'402020202020'\nFILE     DC    C'  SYSUT  '\nHEXAREA  DS    CL100\n         LTORG\n         TITLE 'READDSCB CSECT FOR V OPTION'\nREADDSCB CSECT\n*        THIS CSECT INVOKES THE SUBROUTINE READVTOC (THRU THE LOAD\n*        MACRO) WHICH RETURNS DSCBS TO THIS PROGRAM BASED ON THE\n*        VOLSERS PASSED TO IT IN A MASK DATA AREA. THE DSCB AND OTHER\n*        INFORMATION (VOLSER, ETC) IS PASSED BACK TO THE TARGET\n*        DATA AREA. R1 IS USED TO PASS THE ADDRESS OF THE MASK AND\n*        TARGET AREAS TO READVTOC. THE VOLSER MAY BE GENERIC E.G.\n*        HRSHR*. WHEN ALL THE DSCBS ON THE SPECIFIED VOLSER(S) HAVE\n*        BEEN RETURNED, READVTOC PASSES A RETURN CODE OF 4 IN R15.\n*        THE NEXT VOLSER(S) ON THE VOLSER TABLE IS MOVED INTO THE MASK\n*        AND THE PROCESS REPEATED.\n*        WHEN A DSCB IS RETURNED IT IS FIRST CHECKED TO ENSURE THAT IT\n*        IS A FORMAT1 DSCB REPRESENTING A PHYSICAL DATA SET ON THE VOL.\n*        THE DSN OF THE DSCB IS COMPARED TO EVERY ELEMENT IN THE\n*        SYSIN TABLE. IF A GENERIC ELEMENT HAS BEEN SPECIFIED IN THE\n*        SYSIN TABLE ALL DSNS\n*        MATCHING ON THE GENERIC CRITERIA ARE SELECTED. IN PARTICULAR,\n*        IF '*' WAS SPECIFIED ALL DSCBS ON THE REQUESTED VOLUMES\n*        WILL BE SELECTED. IF A DSN HAS BEEN SPECIFIED TOGETHER WITH\n*        A (GENERIC) MEMBER NAME IN THE SYSIN TABLE THE DSCB READ\n*        FROM THE VTOC IS FIRST CHECKED TO ENSURE THAT IT IS A PDS.\n*        IF IT IS, THAT PDS IS DYNAMICALLY ALLOCATED (TO LIBFILE)\n*        AND OPENED SO THAT ITS DIRECTORY MAY BE READ. ALL MEMBERS\n*        OF THE PDS THAT MATCH THE (GENERIC) SYSIN MEMBER NAME ARE\n*        SELECTED. E.G. ALL MEMBERS PREFIXED BY 'ABC' IN ALL PDSS WITH\n*        HIGH-LEVEL QUAL 'SYS1' WILL BE SELECTD WITH KEY SYS1.*(ABC*).\n*        TO SELECT ALL MEMBERS OF ALL PDSS CODE *(*).\n*\n*        WILDCARD MATCHING CRITERIA IS ALSO ALLOWED:\n*        IF % WAS CODED IN COLUMN 1 OF SYSIN RECORD THEN ALL\n*        HIGH ORDER QUALIFIERS ARE AUTOMATICALLY CONSIDERED MATCHES\n*        IF + OR STRINGS OF +'S ARE CODED ANYWHERE IN THE DSN\n*        THEN THE CORRESPONDING CHARACTERS IN THE DSCBS ARE AUTOMAT\n*        CONSIDERED MATCHED.\n*        IF ! DELIMITERS ENCLOSE A STRING THEN THE DSCB IS SEARCHED FOR\n*        THE OCCURRENCE OF THAT STRING ANYWHERE IN THE DSCB\n*\n*        ALL SYSIN ARE CONSIDERED BEFORE A DSCB IS REJECT, HENCE THE\n*        SAME DSCB MAY CAUSE MORE THAN 1 MATCH.\n*        COUNTS OF ALL PROCESSED AND SELECTED DSCBS, PDSS AND MEMBERS\n*        ARE KEPT.\n*\n*        IF THE CATALOG SEARCH FORM OF THE V OPTION IS REQUESTED (NO\n*        VOL= CARD IN VSYSIN) THEN PROCESSING IS DIFFERENT. EACH DSN\n*        IN THE VSYSIN FILE, IN TURN, IS PASSED TO THE CATALOG SEARCH\n*        ROUTINE, IKJEHCIR, WHICH RETURNS ALL FULLY QUALIFIED DSNS\n*        BEGINNING WITH THE REQUESTED DSN AND ASSOCIATED VOLSERS.\n*        EACH DSN AND VOLSER IS THEN PASSED TO A VTOC SEARCH ROUTINE\n*        WHICH RETURNS THE REQUIRED INFO EXCEPT FOR CATALOGED TAPE\n*        DATASETS (ONLY DSN AND VOLSER OUTPUT).\n*        FOR VSAM DATA SETS AN OBTAIN MACRO IS USED TO GET THE ATTRIB\n*        RATHER THAN THE CVAFDIR MACRO WHICH CANT FIND VSAM DS IN\n*        SUBALLOCATED DATA SPACES.\n*\n*        OUTPUT- A PHYSICAL SEQUENTIAL DATA SET (RECFM=FB,LRECL=100)\n*        IS OUTPUT WITH ALL THE DSCBS WHICH MATCHED THE SYSIN CRITERIA.\n*        SEE VRECOUT FOR A LIST OF ALL THE OUPUT FIELDS.\n*       MULTI-VOLUME DATASETS PRODUCE MULTIPLE OUTPUT REC-FOR EACH VOL.\n*       VSAM FILES IN MULTIPLE DATA SPACES ON THE SAME VOL PRODUCE\n*        DUPLICATE OUTPUT RECORDS FOR EACH PIECE.\n*\n*           IF A PARM IN VSYSIN WAS CODED THE HFSELECT WILL CALL ITSELF\n*        FOR EACH RECORD OUTPUT TO SYSUT2. THE FIRST RECORD OF VSYSIN\n*        CONTAINS A PARM WHICH WILL BE PASSED TO EACH ATTACHED HFSELECT\n*        THE PARM MAY HAVE A MAXIMUM LENGTH OF 78.\n*        THE REMAINDER OF VSYSIN CONTAINS VOL= AND DSN/MEMBER STATEMENT\n*        A PRIMARY FILE DD STATEMENT (SYSUT1,LIBFILE,\n*        ETC) IS GENERATED FOR THE ATTACHED HFSELECT FROM THE SYSUT2\n*        RECORD AND THAT ALONG WITH ANY SYSIN IS PASSED TO THE ATTACHED\n*        SUBTASK. SYSUT2 SHOULD BE CODED AS SYSOUT=CLASS,DCB=OPTCD=U.\n*        THE CLASS SHOULD BE A SAR CLASS SO THAT ALL THE SYSOUT OUTPUTS\n*        FROM THE ATTACHED SUBTASKS ARE AVAILABLE ON-LINE UNFORMATTED.\n*\n*        REGISTER USAGE:\n*        R12- BASE\n*        R11- SECOND BASE\n*        R1 - ADDRESS OF MASK AND TARGET ARES PASSED TO READVTOC\n*           - ADDR OF LIBFILE DCB PASSED TO LIBCSECT TO READ DIRECTORY\n*           - ADDR OF DYNALLOC PARAMETER LIST\n*           - ADDR OF MESSAGE BLOCK PASSED TO MAIN CSECT\n*           - WITH V,K=  R1 IS USED TO PASS BACK BASE REG ADDR-SAVEAREQ\n*        R3 - BASE FOR IKJEHCIR WORKAREA\n*        R4 - PDS DSECT\n*        R5 - VOLSER TABLE\n*        R6 - SYSIN TABLE\n*        R8 - ADDR OF MEMBER NAME\n*        R9 - WORK REGISTER\n*        R10- BAL\n*        R15- RETURN CODE FROM READVTOC (0=MORE DSCBS, 4=ALL DONE)\n*             RETURN CODE TO MAIN CSECT (0=NORMAL END, 1=ERROR)\n         USING *,R15\n         STM   R2,R14,SAVEAREQ\n         CNOP  0,4\n         BAL   R12,JUMPSAVQ\nSAVEAREQ DS    13F\nVOPTREGS DS    13F   AREA TO SAVE V OPT CSECT REGISTER ENVIRON\nBASEQ    DC    A(SAVEAREQ+4096)  SET UP BASE ADDR FOR R11\nJUMPSAVQ EQU   *\n         USING SAVEAREQ,R12,R11\n         DROP  R15\n         L     R11,BASEQ         SET UP SECOND BASE REG R11\n*\n*        GET ALTERNATE PGMNAME,IF ONE IS REQ ('PARM..'/PGMNAME,DDOUT)\n         L     R4,=A(VPARM)      GET 'PARM..'/PGMNAME RECORD IF SPECIF\n         L     R15,=A(SLSHTBL)\n         TRT   2(78,R4),0(R15)   LOOK FOR /\n         BZ    NOALTPGM          NO ALTERNATE PGM SPECIFIED\n         ST    R1,VPGMADR        FOUND / - SAVE ADDR OF /\n         L     R15,=A(COMATRT)   LOOK FOR ',' FOLLOWING PGMNAME\n         MVI   X'40'(R15),X'40'  ALSO LOOK FOR SPACE\n         TRT   1(9,R1),0(R15)    LOOK FOR ',' OR ' ' AFTER /\n         BZ    NOALTPGM          NOT FND - INCORRECLY CODED\n         STC   R2,VSAVDLM        SAVE THE DELIMITER FOUND\n         L     R2,VPGMADR        GET BACK ADDR OF /\n         ST    R1,VPGMADR        SAVE ADDR OF , OR SPACE\n         SR    R1,R2             GET LENGTH OF PGM NAME\n         BCTR  R1,0\n         EX    R1,MVCPGMNM       EXECUTE THE MOVE OF PGMNAME\n         CLI   VSAVDLM,C' '      DID A SPACE FOLLOW PGM NAME\n         BE    NOALTPGM          YES - NO NO ALT DDNAME\n         L     R1,VPGMADR        NO- IT WAS A COMMA - GET ALT DD\n         MVC   VPGMDD,1(R1)      MOVE IN ALT DDNAME\n         B     NOALTPGM\nMVCPGMNM MVC   PGMNAME(*-*),1(R2)   MOVE IN PGM NAME\nNOALTPGM EQU   *\n*\n*        LOAD READVTOC ROUTINE USING BLDL AND LOAD MACROS\n         USING PDS2,R4       FOR LOAD MODULE DATA FIELD NAMES\n         LA    R4,BLDLDATA\n         MVC   BLDLDATA+0(8),PGMNAME         HFSELECT BY DEFAULT\n         MVC   BLDLDATA+74(8),=CL8'READVTC'  NAME OF READ VTOC MODULE\n         BLDL  0,BLDLLIST  WHICH MUST RESIDE IN THE LINKLIST OR STEPLIB\n         LOAD  DE=BLDLDATA+74\n         STCM  R0,15,EPA        STORE READVTOC ADDR IN EPA\n         SPACE 1\n         L     R5,=A(VOLSER)     PLACE VOLSER TABLE ADDR IN R5\n         OPEN  (VREPORT1,OUTPUT)    OPEN REPORT1\n         TM    VREPORT1+DCBFLAG,X'10' IS REPORT1 IN THE JCL\n         BO    VGETCNT                YES -OK\n         OI    VPUT+1,SETBR      NOP THE REPORT1 OUTPUT RTN\n         SPACE 3\nVGETCNT  L     R9,=A(COUNT)    GET J=COUNT\n         MVC   VCOUNT,0(R9)\n         L     R9,=A(COMPCNT)  GET MAXIMUM NUMBER OF RECS TO BE SELECT\n         MVC   VTOTCNT,0(R9)\n         SPACE 2\n         RDJFCB (VREPORT2)     IS THERE A REJECT REPORT (VREPORT2)\n         LTR   R15,R15\n         BNZ   SETVSORT        NO\n         OPEN  (VREPORT2,OUTPUT) YES - OPEN IT\n         NI    VPUTREJ2+1,X'0F'  SET BR TO NOP TO WRITE REPORT2\n         SPACE 2\n*        ALPHABETIZE THE SYSIN KEYS CONTAINING DSNS\n*        PLACE X'FF' IN BYTE 59 OF TBL ELT TO INDICATE END OF TBL\nSETVSORT L     R6,=A(VOLTABL)  FIRST TABLE ELT\n         MVI   VSORTDON,C'0'   SET SORT ENDED FLAG\nVSORT    CLI   84(R6),X'00'  DOES NEXT TABLE ELT INDICATE END TBL\n         BE    VSORTEND      YES- NO MORE SORTING NEEDED\n*        THE DSN AND MEMBER NAME ARE USED AS SORT KEY\nVSORTCLC CLC   6(52,R6),86(R6)  COMPARE 2 CONSECTIVE TABLE ELTS\n         BNH   VSORTOK        THEY ARE ALREADY IN SORTED ORDER\n         XC    0(80,R6),80(R6)  IF NOT IN ORDER,SWITCH ENTIRE ELEMENT\n         XC    80(80,R6),0(R6)\n         XC    0(80,R6),80(R6)\n         MVI   VSORTDON,C'1'    INDICATE SORT NOT COMPLETED\nVSORTOK  LA    R6,80(R6)   POINT TO NEXT TABLE ELT\n         B     VSORT       CONTINUE SORTING\nVSORTEND CLI   VSORTDON,C'0'    ANY MORE SORTING?\n         BNE   SETVSORT         YES\n         SPACE 1\n         MVI   58(R6),X'FF'   PUT X'FF' IN COL59 FOR LAST ELT OF TABLE\n         L     R6,=A(VOLTABL)  GET FIRST TABLE ELT AFTER SORT\n         SPACE 1\n         CLI   1(R5),X'00'    WAS CATALOG SEARCH (NO VOL=) REQUESTED\n         BE    SETCAT         YES\n         SPACE 1\n         MVI   INITDSN,X'05'  NO-INIT INITDSN TO X'05' IN CASE\n*        ALL DSNS ARE REQUESTED, SO IT WILL START AFTER FORMAT4 DSCB\n         CLI   4(R6),X'FF'    ARE ALL DSNS REQUESTED\n         BE    GETVOL         YES\n         MVC   INITDSN,6(R6)  MOVE IN FIRST TABLE ELEMENT\n         L     R15,=A(COMMABLK)   GET BLANK TRT TABLE\n         TRT   INITDSN,0(R15)   FIND FIRST BLANK\n         BZ    FULLDSN        FULL 44-BYTE DSN\n         BCTR  R1,0           POINT TO LAST BYTE OF DSN\nSETLSTCH LA    R2,0           CLEAR R2\n         IC    R2,0(R1)       GET LAST CHARACTER OF DSN\n         BCTR  R2,0     SUBTRACT 1 FROM ITS BINARY REPRESENTATION\n         STC   R2,0(R1) STORE IT BACK INTO INITDSN\n         MVC   DSN1STCH,INITDSN  SAVE THE FIRST CHAR\n*        SINCE ITS OVERLAYED BY X'FF' TO INDICATE EOV\n         SPACE 3\nGETVOL   MVC   ENDVOLFL,0(R5)     GET VOLSER FLAG END INDICATOR\n         MVC   MASKVOL(6),1(R5)     MOVE VOLSER TO MASK\nGETDSCB  LA    R1,RVPARML       GET MASK/TARGET PARM ADDR\n         L     R15,EPA          PASS CONTROL TO READVTOC MODULE\n         BALR  R14,R15\n         MVC   INITDSN(1),DSN1STCH   RESET THE FIRST CHAR OF INITDSN\n*        IN CASE EOV WAS HIT AND X'FF' WAS MOVED INTO FIRST BYTE\n         C     R15,=F'4'        RETURN CODE\n         BE    GETNXVOL       NO MORE DSCBS ON SPECIFIED VOLUMES\n         BH    VERROR          CVAF ERROR\n         CLI   DSCBFMT,C'1'    DSCB RETURNED- IS IT A FORMAT 1\n         BNE   GETDSCB           NO - GET ANOTHER\n         AP    PDSCBTOT,ONE      YES -ADD 1 TO DSCB PROCESSED\n         L     R6,=A(VOLTABL)    POINT TO FIRST DSN IN SYSIN TABLE\nVKEYLOOP CLI   4(R6),X'00'        IS THIS THE END OF THE SYSIN TABLE\n         BE    GETDSCB            YES - GET A NEW DSCB\n         CLI   4(R6),X'FF'        NO- ARE ALL DSNS REQUESTED\n         BE    CHKMEMKY          YES- CHECK IF MEMBERS ARE REQUESTED\n         LA    R9,0              NO- INIT R9 TO 0\n         IC    R9,4(R6)          GET DSN LENGTH\n         BCTR  R9,0              SUB 1\n         STC   R9,DSNCLC+1       STORE LENGTH IN CLC INSTRUCTION\n         CLI   79(R6),C'%'    DOES TBL ELT CONTAIN A WILDCARD-%\n         BE    WILDCARD       YES\n         CLI   79(R6),C'!'    DOES TBL ELT CONTAIN A WILDCARD-!\n         BE    FLOAT          YES\n         MVC   WCDSCBDS,DSCBDSN  NO- MOVE DSCB TO WILDCARD CLC AREA\n         SPACE 1\nVCHKPLUS L     R15,=A(PLUSTABL)\n         TRT   6(44,R6),0(R15)    CHECK FOR WILDCARD CHAR '+'\n         BZ    DSNCLC      NONE\n         MVI   WCNOP+1,SETBNE SET COMPAR TO BNE PERMANENTLY (DUE TO WC)\n         MVC   PLUSMASK,6(R6)   MOVE TABLE ELEMENT TO MASK\n         TR    PLUSMASK,0(R15)    TRANSLATE NON-'+'\n         OC    WCDSCBDS,PLUSMASK  'OR' THE DSCB WITH THE MASK\n         MVI   0(R15),X'FF'     CONVERT X'00' TO X'FF' IN THE TR TABL\n         TR    PLUSMASK,0(R15)    TRANS ALL X'00' TO X'FF' IN MASK\n         NC    WCDSCBDS,PLUSMASK  'AND' THE DSCB WITH THE MASK\n*        THE ABOVE CODE HAS OVERLAYED THE '+'-MASK INTO THE DSCB\n*        IN THE SAME PLACE AS THEY APPEAR IN THE SYSIN KEY BUT OTHERWIS\n*        LEAVE THE DSCB UNCHANGED\n         MVI   0(R15),X'00'     CONVERT X'FF' BACK TO X'00'\n         SPACE 1\nDSNCLC   CLC   6(0,R6),WCDSCBDS  DOES DSCB DSN MATCH TABLE ENTRY\n*        IF THE % OR + WILDCARDS ARE BEING USED WE CANT USE THE\n*        BL (TO CHKLAST) AND BH (TO GETDSCB) SHORTCUTS. E.G. IF\n*        SYSIN CONTAINED ONLY 1 RECORD: +ABC, THE COMPARE TO THE\n*        DSCB QBBC (CONVERTED TO +BBC) RESULTS IN A LOW COMPARE\n*        AND WOULD TERMINATE COMPARISONS ON THIS VOLUME EVEN THO\n*        DSCB RABC ON THE SAME VOLUME WOULD MATCH. SIMILARLY, IF THE\n*        ONLY SYSIN WERE %SOURCE.COBOL, THE COMPARE AGAINST DSCB\n*        ABC.TEST WOULD BE LOW AND DSCB XYZ.SOURCE.COBOL ON THE\n*        SAME VOLUME WOULD BE MISSED AS A MATCH.\n*             ALSO, IF SYSIN CONSISTED OF 2 RECORDS: %SOURCE.COBOL\n*        AND: ABC.A THEN THE FIRST COMPARE AGAINST DSCB ABC.A\n*        WOULD RESULT IN A HIGH (SOURCE.COBOL VS. A) AND THE NEXT\n*        DSCB WOULD BE READ AND SYSIN RECORD ABC.A WOULD NEVER\n*        GET MATCHED.\n*            HENCE, WE MUST CHANGE THE FOLLOWING NOP TO A BNE NEXTVKEY\n*        INSTRUCTION WHENEVER WILDCARD PROCESSING IS PRESENT.\n*        IT MUST BE CHANGED PERMANENTLY ON BOTH % AND + BECAUSE\n*        THE COLLATING ORDER OF SYSIN IS THROWN OUT OF WHACK.\n*\nVCHKPLSB NOPR  R10         SET TO BR ON CATALOG SEARCH\n         SPACE 1\nWCNOP    NOP   NEXTVKEY    SEE AVOVE EXPLANATION\n         BL    CHKLAST           NO- CHK IF LAST TABLE ELEMENT\n         BH    GETDSCB    NO - SINCE SYSIN TBL SORTED GET NEXT DSCB\nCHKMEMKY CLI   5(R6),X'00'      YES- WAS A MEMBER REQUESTED\n         BNE   PDSSRCH          YES - SEARCH THE PDS DIRECTORY\n         MVC   VRECMEM,VBLANKS   NO- BLANK MEMBER NAME ON REPORT1\n         BAL   R10,VPUT           PUT OUT REPORT1 REC\n         SPACE 1\nNEXTVKEY LA    R6,80(R6)        POINT TO NEXT SYSIN TABLE ELEMENT\nCATNOP   B     VKEYLOOP         CHANGED TO NOP ON CATALOG SEARCH\n         B     GETCAT\n         SPACE 1\nFULLDSN  LA    R1,INITDSN+43    POINT TO LAST CHAR OD DSN\n         B     SETLSTCH\n         SPACE 1\nCHKLAST  CLI   58(R6),X'FF'     IS THIS THE LAST TABLE ELT\n         BNE   NEXTVKEY         NO- GET THE NEXT TABLE ELEMENT\n         MVI   INITDSN,X'FF'    YES - FOR IXVTOC SET INITDSN TO X'FF'\n         B     GETDSCB          RETURN TO READVTOC RTN\n         SPACE 3\nWILDCARD L     R15,=A(WLDCRDTB)\n         TRT   DSCBDSN,0(R15)    LOOK FOR '.' OR ' '\n         LA    R2,DSCBDSN        GET ADDR OF FIRST BYTE OF DSCB\n         SR    R1,R2    GET LENGTH UP TO FIRST '.' OR ' '\n         LA    R1,1(R1)   LENGTH OF HIGH ORDER QUALIFIER INCLU '.'\n         LA    R9,43\n         SR    R9,R1      LEN OF DSCB MINUS HIGH ORDER QUALIFIER\n         MVC   WCDSCBDS,VBLANKS    BLANK OUT COMPARE AREA\n         STC   R9,MVWLDCRD+1   SET MVC LENGTH\n         STC   R1,MVWLDCRD+5   SET MVC DISPLACEMENT\nMVWLDCRD MVC   WCDSCBDS+1(0),0(R2)   SET UP WILDCARD CLC AREA\n*        LEAVE 1 BLANK IN FRONT FOR % THAT WAS BLANKED OUT\n         MVI   WCNOP+1,SETBNE SET COMPAR TO BNE PERMANENTLY(DUE TO WC)\n         B     VCHKPLUS        CHECK FOR '+'\n         SPACE 3\nPDSSRCH  TM    DSCBORG,X'02'      IS DSCB DSORG=PO\nPDSNOP1  BNO   NEXTVKEY     NO- GET NEXT SYSIN KEY ; NOP ON CAT SRCH\nPDSBR1   NOP   VOLCNTLP     SET TO BNO ON CAT SEARCH\n         RACHECK ENTITY=DSCBDSN,CLASS=DATASETX,VOLSER=TGVOLSER,        X\n               LOG=NOSTAT     DO NO LOG TO AUDIT FILE\n         CHI   R15,4     RESOURCE NOT PROTECTED?                  @MK1\n         BE    NORACF    YES - OK                                 @MK1\n         LTR   R15,R15   DETERMINE IF USER HAS SECURITY ACCESS TO DS\n         BNZ   SECVIOL   NO\nNORACF   EQU   *                                                  @MK1\n         MVC   DYNDSN,DSCBDSN      YES- SET DSN IN DYNALLOC PARM LIST\n         MVC   DYNVOLSR,TGVOLSER      SET VOLSER IN DYNALLOC\n         MVC   DYNDDNAM,=C'VTEMPLIB'  USE VTEMPLIB AS DDNAME\n         LA    R1,REQBLKP         PUT DYNALLOC PARM ADDR IN R1\n         DYNALLOC\n         LTR   R15,R15            WAS PDS SUCCESSFULLY ALLOCATED\n         BNZ   DAIRFAIL                NO\n         L     R9,=A(LIBRARY)     YES- LIBFILE DCB ADDR\n         MVC   DCBDDNM(8,R9),=C'VTEMPLIB'  USE VTEMPLIB AS DDNAME\n         OPEN  ((R9))    INSTEAD OF LIBFILE,FOR PDS DIRECTORY ACCESS\n         LTR   R15,R15\n         BNZ   VERROR\n         AP    PPDSTOT,ONE         ADD 1 TO PDS PROCESSED\nNXTVMEM  L     R1,=A(LIBRARY)       GET LIBFILE DCB ADDR\n         L     R15,=A(LIBCSECT)     GET LIBCSECT ADDR\n         BALR  R14,R15            GET NEXT DIRECTORY ENTRY\n         LTR   R15,R15        0=OK, 1=END OF DIRECTORY\n         BNZ   MEMNFND           MEMBER WAS NOT FOUND\n         AP    PMEMTOT,ONE        ADD 1 TO MEMBERS PROCESSED\n         L     R9,=A(SAVEINFO)    SEE LIBCSECT FOR CONTENTS OF AREA\n         L     R8,0(R9)          GET ADDR OF MEMBER NAME\n         USING PDSDRECT,R8     USE R8 AS BASE FOR PDS DIRECTORY\n         CLI   5(R6),X'FF'     WERE ALL MEMBERS REQUESTED\n         BE    MEMMATCH              YES- SELECT MEMBER\n         LA    R9,0        NO- CLEAR R9\n         IC    R9,5(R6)      GET ACTUAL MEMBER NAME LENGTH\n         BCTR  R9,0                SUB 1\n         STC   R9,MEMBCLC+1    SET LENGTH FOR CLC INSTRUCTION\nMEMBCLC  CLC   50(0,R6),PDSMEMNM  DOES PDS MEMB NAME MATCH CRITERIA\n         BH    NXTVMEM    PDS MEMBER NAME LOW - GET NEXT MEMBER NAME\n         BL    MEMNFND                    HIGH- MEMBER NAME NOT FND\nMEMMATCH MVC   VRECMEM,PDSMEMNM    EQUAL- PUT MEMB NAME IN REPORT1\n         BAL   R10,VPUT        WRITE RECORD\n         B     NXTVMEM         GET NEXT MEMBER\n         SPACE 3\nMEMNFND  L     R9,=A(LIBRARY)   GET LIBFILE DCB\n         MVI   DSORG(R9),X'40'     RESET DSORG=PS FOR CLOSE\n         CLOSE ((R9),FREE)      CLOSE PDS AND UNALLOC\n         LTR   R15,R15\n         BNZ   VERROR\n         L     R9,=A(BRVRTN)\n         MVI   1(R9),SETNOP    RESET NOP FOR READ DIRECTORY ON NEXT PDS\n         L     R9,=A(RETURN3)\n         MVI   3(R9),SETNOP    RESET DIRECTORY END FLAG FOR NEXT PDS\nPDSNOP2  B     NEXTVKEY        SET TO NOP CATALOG SEARCH\n         B     VOLCNTLP\n         SPACE 3\nGETNXVOL CLI   ENDVOLFL,X'80'  IS THIS THE LAST VOLSER ENTRY IN TABLE\n         BE    VEOJ            YES - EOJ\n         LA    R5,7(R5)        NO - POINT TO NEXT VOLSER\n         B     GETVOL\n         SPACE 2\nFLOAT    MVI   WCNOP+1,SETBNE SET COMPARE TO BNE PERMANENTLY(DUE TO WC)\n         L     R15,=A(COMMABLK)    GET BLANK TRT TABLE\n         TRT   DSCBDSN,0(R15)      FIND FIRST BLANK\n         BZ    FLOATFUL            FULL 44-CHAR DSN\nFLOATCON LA    R2,DSCBDSN          GET ADDR OF FIRST BYTE OF DSCB DSN\n         SR    R1,R2               GET LENGTH OF DSN\n         BCTR  R9,0   SUBTRACT 1 FROM SYSIN DSN (FOR LEADING BLANK)\n         SR    R1,R9  CALCULATE THE NUMBER OF ITERATIONS NEEDED\n         BNP   NEXTVKEY   SYSIN STRING GREATER THAN ACTUAL DSCB DSN\n         STC   R9,FLOATLOP+1    SET COMPARE LENGTH\nFLOATLOP CLC   7(0,R6),0(R2)  START IN COL.7 TO BYPASS BLANK\n         BE    CHKMEMKY       MATCH\n         LA    R2,1(R2)       POINT TO NEXT CHAR IN DSCB DSN\n         BCT   R1,FLOATLOP    TRY AGAIN\n         B     NEXTVKEY    STRING DOES NOT OCCUR IN DSCB DSN\n         SPACE 1\nFLOATFUL LA    R1,DSCBDSN+44  POINT TO 1 BEYOND END OF DSCB\n         B     FLOATCON       SO R1 WILL HAVE LENGTH OF 44\n         SPACE 2\nSECVIOL  MVC   VRECMEM,VBLANKS   BLANK OUT MEMBER NAME\n         MVI   VRECVIOL,C'*'     PLACE * IN FILE- VIOLATION INDICATOR\n         BAL   R10,VPUT WRITE JUST THE DATASET REC-MEMBER RECS UNACCES\n         MVI   VRECVIOL,BLANK1   RESET\n         B     NEXTVKEY\n         TITLE 'V OPTION - RETRIEVE CATALOG OPTION'\nSETCAT   OI    VCHKPLSB+1,X'F0'  SET BR VCHKPLUS RTN\n         MVI   CATNOP+1,X'00'    SET NOP IN NEXTVKEY BRANCH\n         MVI   BYPCAT+1,X'F0'    SET B TO BYPASS CATALOG CHECK\n         MVI   PDSNOP1+1,X'00'   SET NOP  ON BR TO NEXTVKEY\n         MVI   PDSBR1+1,X'E0'   SET BNO TO PROCESS NEXT ENTRY IN WKAREA\n         MVI   PDSNOP2+1,X'00'   SET NOP  ON BR TO NEXTVKEY\n         L     R0,CIRWALEN       GET LENGTH OF IKJEHCIR WORKAREA\n         GETMAIN R,LV=(0)\n         ST    R1,CIRWA          PLACE WORKAREA ADDR IN CIRWA\n         L     R0,CIRWALEN\n         S     R0,=F'4'\n         STH   R0,0(R1)          PLACE HEADER IN WORKAREA\n         SPACE 1\n         L     R1,CVTPTR         UCB SCAN - GET CVT ADDR\n         USING CVT,R1            UCB SCAN - CVT ADDRESSABILITY\n         L     R15,CVTUCBSC      UCB SCAN - GET UCB SCAN ADDR\n         ST    R15,SCANUCB       UCB SCAN - STORE UCB SCAN ADDR\n         DROP  R1\n         SPACE 1\n         OI    BFLHFL,BFLHDSCB   CVAFDIR - BUFLIST DESCRIBES DSCBS\n         MVI   BFLHNOE,1         CVAFDIR - ONLY 1 BUFLIST ENTRY\n         MVI   BFLELTH,96        CVAFDIR - INDICATE 96-BYTE DSCB BUFFER\n         LA    R1,DSCBFMT        CVAFDIR ADDR OF 96-BYTE RETURNED DSCB\n         STCM  R1,15,BFLEBUF     CVAFDIR - STORE DSCB BUFFER ADDR\n         SPACE 1\nGETCAT   CLI   4(R6),X'00'       IS THIS THE LAST VSYSIN RECORD\n         BE    VEOJ              YES - FINISHED\n         CLI   79(R6),C' '       IS % OR ! WILDCARD USED\n         BNE   VKEYERR           YES- IGNORE IT (NOT VALID)\n         CLI   4(R6),X'FF'   ALL DATASETS REQUESTED (CODING * IN COL 1)\n         BE    VKEYERR            YES- IGNORE IT (NOT VALID)\n         MVC   HIGHQUAL,6(R6)    MOVE IN DSN FROM DSN TABLE\n         SR    R9,R9             CLEAR\n         IC    R9,4(R6)          GET DSN LENGTH FROM DSN TABLE\n         BCTR  R9,0              SUB 1\n         STC   R9,DSNCLC+1       SET UP DSN COMPARE WITH CATALOG RETRN\n         L     R15,=A(PLUSTABL)\n         TRT   HIGHQUAL,0(R15)   CHECK FOR + (* NOT THERE -CHK LENGHT)\n         BNZ   CATGENRC          FOUND +,IT IS GENERIC\n         CLI   4(R6),X'2C'       + NOT FOUND, WAS A * CODED?\n         BE    VOLINFO2       NO, THE DSN LENG=44(* WOULD HAVE LEN<44)\n*          SO ITS ONLY NECESSARY TO GET THE VOLSER THE DS IS ON\n         IC    R9,4(R6)      YES-GET ACTUAL LENGTH\n         LA    R1,HIGHQUAL(R9)   POINT TO WHERE * WOULD HAVE BEEN\nCATGENRC ST    R1,SAVEWC         SAVE POSITION OF +\n         L     R15,=A(WLDCRDTB)\n         TRT   HIGHQUAL,0(R15)    FIND FIRST BLANK OR '.'\n         BZ    VKEYERR            GENERIC IN HIGH ORDER QUALIFIER\n*                                 IGNORE IT (NOT VALID)\n         CLM   R2,1,=C' '         FOUND BLANK BEFORE '.'\n         BE    VKEYERR            GENERIC IN HIGH ORDER QUAL -IGNORE\n         C     R1,SAVEWC          COMPARE POSITION OF '.' TO +\n         BH    VKEYERR            GENERIC IN HIGH ORDER QUAL -IGNORE\n         LA    R1,HIGHQUAL+43     POINT TO END OF HIGHQUAL FLD\n         L     R2,SAVEWC          GET ADDR OF + (*)\n         SR    R1,R2              COMPUTE NUMBER OF BYTES FROM * TO END\n         STC   R1,BLNKEND+1       AND STORE IN MVC INSTRUCTION\nBLNKEND  MVC   0(*-*,R2),VBLANKS  BLANK OUT TO END\nLOOPBLNK CLI   0(R2),C'.'         BLANK OUT BACKWARDS UNTIL FIND '.'\n         BE    READCAT\n         MVI   0(R2),C' '\n         BCTR  R2,0\n         B     LOOPBLNK\n         SPACE 1\nREADCAT  EQU   *\n         MVC   SRCHARG,HIGHQUAL  MOVE HIGH ORDER QUALIFIERS TO ARGUMENT\n         MVI   CIRLOCRC,X'00'         RESET LOCATE RETURN CODE\n         LA    R1,CIRPARM        LOAD PARAMETER LIST ADDR IN R1\n         L     R3,CIRWA          GET CIR WORKAREA ADDR\n         LA    R3,4(R3)          POINT BEYOND WORKAREA HEADER\n         LINK  EP=IKJEHCIR\n         CLI   CIRLOCRC,X'08' RC=8,DS NOT FOUND OR FULLY QUALIFIED DSN\n*                                  SPECIFIED OR SECURITY VIOLATION\n         BE    VOLINFO        YES\n         CLI   CIRLOCRC,X'2C' RC=44,WORKAREA TOO SMALL (>1455 ENTRIES)?\n         BE    VKEYERR        YES\n         LTR   R15,R15\n         BNZ   VERROR            ERROR IN CATALOG SEARCH RTN\nDSNLOOP  CLI   0(R3),X'FF'       LAST ENTRY FOR THIS VSYSIN DSN?\n         BE    NEXTVKEY          YES\n         MVC   FILETYPE,0(R3)   NO-GET THE DSN TYPE (NON-VSAM, AIX,ETC)\n         MVC   WCDSCBDS,1(R3)    SET UP WCDSCBDS FOR COMPARE\n         MVC   DSCBDSN,1(R3)     STORE IN DSCB AREA-IN CASE OF TAPE\n         LA    R3,45(R3)         POINT PAST THE FULL DSN\nVOLRTN   SR    R9,R9             CLEAR\n         IC    R9,0(R3)          GET NUMBER OF VOLUMES\n         ST    R9,VOLNUM\n         LA    R3,1(R3)          POINT PAST VOL COUNT\nVOLCNTLP ICM   R9,15,VOLNUM      GET VOLUME COUNT\n         BZ    DSNLOOP    NO MORE VOLUMES - GET NEW DSN FROM WKAREA\n         BCTR  R9,0              SUB 1\n         ST    R9,VOLNUM\n         BAL   R10,VCHKPLUS      COMPARE DSNS                   <===\n         BNE   NEXTVOL           DSNS NOT EQUAL - GET NEXT VOL  <===\n         MVC   MASKVOL,4(R3)  EQ-MOVE VOLSER TO MASK FOR VTOC READ\n         MVC   VRECOUT+58(42),VBLANKS    CLEAR OUTPUT REC\n         CLI   2(R3),UCB3TAPE (X'80')       IS THE DATA SET ON TAPE\n*        THIRD BYTE OF DEVICE TYPE INDICATES TAPE(X'80'),DISK(X'20')...\n         BE    CATTAPE           YES\n         LA    R3,12(R3)         NO-ON DISK. POINT PAST VOLUME INFO\n         CLI   FILETYPE,C'A'    IS THIS DSN NON-VSAM\n         BNE   OBTAIN            NO- USE OBTAIN RATHER THAN CVAFDIR\n         SPACE 1\n         XC    WKAREA,WKAREA     UCB SCAN - ZERO OUT WKAREA FOR NEW UCB\n         LA    R1,PARMUCB        UCB SCAN - GET PARMLIST ADDR\n         USING UCBOB,R9          UCB SCAN - SET ADDRESSABILITY\nSRCHUCB  L     R15,SCANUCB       UCB SCAN ADDRESS\n         BALR  R14,R15           UCB SCAN\n         LTR   R15,R15           SUCCESSFUL?\n         BNZ   CATTAPE2     VOLSER DOESNT EXIST IN UCB TABLE\n         L     R9,ADDRUCB        GET UCB\n         TM    UCBSTAT,UCBONLI    IS VOLUME ONLINE\n         BZ    SRCHUCB            NO- KEEP SEARCHING\n         CLC   UCBVOLI,MASKVOL   IS THIS THE VOLSER WE WANT?\n         BNE   SRCHUCB       NO- KEEP SEARCHING\n         DROP  R9\n         MVC   TGVOLSER,MASKVOL MOVE VOLSER TO TARGET,NOT SUPL VIA CVAF\n         CVAFDIR ACCESS=READ,BUFLIST=BUFLIST,UCB=(R9),DSN=DSCBDSN,     X\n               BRANCH=(YES,PGM)              GET THE DSCB\n         LTR   R15,R15\n         BZ    GOTDSCB           SUCCESSFUL EXECUT OF CVAF-GOT THE DSCB\n         USING CVPL,R1           ADDRESSABILITY TO CVPL FOR CVSTAT FLD\n         CLI   CVSTAT,1          THE DSN WAS NOT FOUND ON VTOC- MUST BE\n         BNE   CATTAPE2   A VSAM DATA SET IN A SUBALLOCATED DATA SPACE\n         DROP  R1\nOBTAIN   OBTAIN SRCHVTOC  SO DO OBTAIN CAMLST TO BUILD PSEUDO F1-DSCB\n         LTR   R15,R15\n         BNZ   CATTAPE2          STILL DIDNT FIND DSCB\n         MVC   TGVOLSER,MASKVOL RESET, SINCE OBTAIN OVERLAYS TGVOLSER\n*                               WITH THE CCHHR OF THE DSCB\nGOTDSCB  AP    PDSCBTOT,ONE\n         CLI   5(R6),X'00'       WAS A MEMBER REQUESTED\n         BNE   PDSSRCH          YES - SEARCH THE PDS DIRECTORY\n         MVC   VRECMEM,VBLANKS   NO- BLANK MEMBER NAME ON REPORT1\n         BAL   R10,VPUT           PUT OUT REPORT1 REC\n         B     VOLCNTLP\n         SPACE 2\nCATTAPE  MVI   VRECDSOR,C'T'     INDICATE TAPE IN DSORG FIELD\nCATTAPE2 MVC   VRECDSN,DSCBDSN  GET FROM DSCB AREA WHICH WAS FILLED\n*              AFTER IKJEHCIR AND NOT MODIFIED FOR TAPE DS\n         MVC   VRECVOL,MASKVOL   GET VOLSER\n         MVC   VRECMEM,VBLANKS   BLANK MEMBER NAME\n         MVI   VRECCAT,C'C'      SET CATALOG FLAG TO C\n         MVI   ATTCHFLG,C'N'    DO NOT ATTACH THIS DSN AS A SUB-TASK\n         BAL   R10,VPUTREC       WRITE REPORT1\nNEXTVOL  LA    R3,12(R3)         POINT TO NEXT VOLUME\n         B     VOLCNTLP\n         SPACE 2\nVKEYERR  AP    VKEYERCT,ONE      ADD 1 TO RECORD COUNT\n         B     NEXTVKEY              GET NEXT VSYSIN KEY\n         SPACE 1\nVOLINFO  EQU   *\n         CLM   R0,1,=X'38'       SECURITY VIOLATION?\n         BE    VKEYERR                YES (NO ACCESS TO CATALOG)\nVOLINFO2 MVI   CIRLOCRC,X'00'         RESET LOCATE RETURN CODE\n         MVI   CIROPT,X'04'           NO -CHANGE CATALOG SEARCH OPTION\n*        IF FULLY QUALIFIED DSN WAS SPECIFIED TO GET VOLUME INFORM\n         MVC   SRCHARG,HIGHQUAL MOVE IN AGAIN TO REMOVE TRAILING '.'\n*                               THAT WAS INSERTED BY FIRST IKJEHCIR\n         LA    R1,CIRPARM\n         LINK  EP=IKJEHCIR\n         MVI   CIROPT,X'06'      RESET CATALOG SEARCH OPTION\n         LTR   R15,R15       DID WE GET VOL INFO?\n         BNZ   NEXTVKEY   NO-DS REALLY NOT FOUND\n         MVC   WCDSCBDS,HIGHQUAL\n         MVC   DSCBDSN,HIGHQUAL\n         L     R3,CIRWA     GET CIR WORKAREA ADDR (NEED IF FIRST TIME)\n         LA    R3,4(R3)     POINT PAST HEADER\n         B     VOLRTN\n         TITLE 'V OPTION -PUT OUT REPORT1 RECORD (VTOC DATA)'\nVPUT     NOPR  R10        SET TO BR IF NO REPORT1 IN JCL\n*\n         L     R9,0(0,R6)  GET COUNT FIELD FROM TABLE ELT\n         CVD   R9,VPACKCNT  PACK IT\n         CP    VPACKCNT,VCOUNT    IS IT LESS THAN J=COUNT\n         BNLR  R10    NO- DO NOT OUTPUT RECORD-CNT SATISFIED ON TBL ELT\n         LA    R9,1(R9)  YES- ADD TO TABLE ELEMENT COUNT & PUT OUT REC\n         ST    R9,0(0,R6)   REPLACE NEW COUNT IN TBL ELT\n         SPACE 1\n         MVC   VRECDSN,DSCBDSN    MOVE DSN TO OUTPUT REC\n         MVC   VRECVOL,TGVOLSER   MOVE VOLSER TO OUTPUT REC\n         CLI   VRECMEM,BLANK1     IS THIS A MEMBER RECORD\n         BNE   MEMOUT    YES- SKIP VTOC FIELDS,PUT OUT LIB STATS\n         SPACE 1\n         AP    PDSCBSEL,ONE       ADD 1 TO DSCBS (W/O MEMS) SELECTED\nBYPCAT   NOP   SETCATLG       SET TO BRANCH ON CATALOG SEARCH OPTION\n         MVI   VRECCAT,BLANK1 INIT THE CATALOGUE FLAG TO SPACES\n         LOCATE SRCHCAT    DETERMINE IF THIS DATASET IS CATALOGED\n         LTR   R15,R15     R15=0 MEANS FOUND ON CATALOG\n         BNZ   CHKDSORG    NOT FOUND ON CAT\n         MVI   VRECCAT,C'E'   INIT THE CATALOG FLAG TO 'E'-ELSEWHERE\n         LA    R15,VOLID   GET ADDRESS OF THE FIRST VOLSER\n         LH    R9,VOLCNT   GET NUMBER OF VOLUMES DS WAS FOUND ON\n         C     R9,=F'20'   ON MORE THAN 20 VOLUMES\n         BH    SRCH20      SEARCH ONLY THE FIRST 20 ENTRIES\nCATLOOP  CLC   VRECVOL,0(R15) IS DS CATALOGED ON SAME VOLSER AS FND ON\n         BE    SETCATLG    YES- SET CATALOGED FLAG\n         LA    R15,12(R15) POINT TO NEXT VOLSER (IF IT EXISTS)\n         BCT   R9,CATLOOP  LOOP THROUGH ALL THE VOLSERS\n         B     CHKDSORG       NOT FOUND\nSETCATLG MVI   VRECCAT,C'C'   SET CAT FLAG\n         SPACE 2\nCHKDSORG MVC   VRECDSOR,VBLANKS    BLANK OUT DSORG FIELD\n         MVI   VRECDSOR,C'S'       SEQUENTIAL INDIC\n         TM    DSCBORG,X'40'\n         BO    TESTUORG           GO TO CHECK IF UNMOVABLE\n         MVI   VRECDSOR,C'P'       PARTITION  INDIC\n         TM    DSCBORG,X'02'\n         BO    TESTUORG           GO TO CHECK IF UNMOVABLE\n         MVI   VRECDSOR,C'V'       VSAM INDIC\n         TM    DSCBORG+1,X'08'\n         BO    TESTUORG           GO TO CHECK IF UNMOVABLE\n         MVI   VRECDSOR,C'D'       DIRECT ACC INDIC\n         TM    DSCBORG,X'20'\n         BO    TESTUORG           GO TO CHECK IF UNMOVABLE\n         MVI   VRECDSOR,C'I'       ISAM INDIC\n         TM    DSCBORG,X'80'\n         BO    TESTUORG           GO TO CHECK IF UNMOVABLE\n         MVI   VRECDSOR,C'C'       COMMUNICAT INDIC\n         TM    DSCBORG,X'10'\n         BO    TESTUORG           GO TO CHECK IF UNMOVABLE\n         MVI   VRECDSOR,C'G'       GRAPHICS INDIC\n         TM    DSCBORG+1,X'80'\n         BO    TESTUORG           GO TO CHECK IF UNMOVABLE\n         MVI   DSCBORG,C'O'       INDICATE OTHER\nTESTUORG TM    DSCBORG,X'01'     IS IT UNMOVABLE\n         BNO   TESTRECF          NO\n         MVI   VRECDSOR+1,C'U'    YES\nTESTRECF MVC   VRECRECF,VBLANKS   BLANK OUT RECFM\n         MVI   VRECRECF,C'U'      UNDEFINED RECFM\n         TM    DSCBRECF,X'C0'\n         BO    TESTSREC           TEST IF STANDARD OR SPANNED\n         MVI   VRECRECF,C'F'      FIXED RECFM\n         TM    DSCBRECF,RECFMF\n         BO    TESTSREC           TEST IF STANDARD OR SPANNED\n         MVI   VRECRECF,C'V'      VARIABLE RECFM\n         TM    DSCBRECF,X'40'\n         BO    TESTSREC           TEST IF STANDARD OR SPANNED\n         MVI   VRECRECF,C'O'      OTHER RECFM\nTESTSREC TM    DSCBRECF,X'08'\n         BNO   TESTLREC           TEST IF STANDARD OR SPANNED\n         MVI   VRECRECF+1,C'S'    STANDARD OR SPANNED\nTESTLREC CLI   DSCBLREC,X'80'  IS LRECL GREATER THAN 32K\n         BNE   SETLRECL     NO\n         MVC   VRECLREC,=C'99999'  YES - SET TO 99999\nSETLRECL LH    R9,DSCBLREC     GET LRECL\n         CVD   R9,DSCBWORK     CONVERT TO DECIMAL\n         UNPK  VRECLREC,DSCBWORK+5(3)   UNPACK INTO LRECL FIELD\n         OI    VRECLREC+4,X'F0'\n         LH    R9,DSCBBLKS     GET BLKSIZE\n         CVD   R9,DSCBWORK     CONVERT TO DECIMAL\n         UNPK  VRECBLKS,DSCBWORK+5(3)   UNPACK INTO BLKSI FIELD\n         OI    VRECBLKS+4,X'F0'\n         LA    R9,0     CLEAR R9\n         IC    R9,DSCBNEXT     GET NUMBER OF EXTENTS\n         CVD   R9,DSCBWORK     CONVERT TO DECIMAL\n         UNPK  VRECNEXT,DSCBWORK+6(2)   UNPACK INTO NEXTENTS FLD\n         OI    VRECNEXT+2,X'F0'\n         IC    R9,DSCBCRTD     GET CREATION DATE YEAR\n         CVD   R9,DSCBWORK     CONVERT TO DECIMAL\n         UNPK  DSCBWORK(3),DSCBWORK+6(2) UNPK INTO WORK AREA\n         MVC   VRECCRTD(2),DSCBWORK+1    MOVE INTO FIRST 2 BYTES\n         OI    VRECCRTD+1,X'F0'\n         ICM   R9,3,DSCBCRTD+1   GET DD OF CRTD\n         CVD   R9,DSCBWORK     CONVERT TO DECIMAL\n         UNPK  VRECCRTD+2(3),DSCBWORK+6(2)   UNPACK INTO DDD FLD\n         OI    VRECCRTD+4,X'F0'\n         LA    R9,0       CLEAR R9\n         IC    R9,DSCBDLRF     GET DATE LAST REF YEAR\n         CVD   R9,DSCBWORK     CONVERT TO DECIMAL\n         UNPK  DSCBWORK(3),DSCBWORK+6(2) UNPK INTO WORK AREA\n         MVC   VRECDLRF(2),DSCBWORK+1    MOVE INTO FIRST 2 BYTES\n         OI    VRECDLRF+1,X'F0'\n         ICM   R9,3,DSCBDLRF+1   GET DD OF CRTD\n         CVD   R9,DSCBWORK     CONVERT TO DECIMAL\n         UNPK  VRECDLRF+2(3),DSCBWORK+6(2)   UNPACK INTO DDD FLD\n         OI    VRECDLRF+4,X'F0'\n         LA    R9,0       CLEAR R9\n         IC    R9,DMSDLM       GET DATE LAST MODIF YEAR- DMS/OS ONLY\n         CVD   R9,DSCBWORK     CONVERT TO DECIMAL\n         UNPK  DSCBWORK(3),DSCBWORK+6(2) UNPK INTO WORK AREA\n         MVC   VRECDLM(2),DSCBWORK+1    MOVE INTO FIRST 2 BYTES\n         OI    VRECDLM+1,X'F0'\n         ICM   R9,3,DMSDLM+1   GET DD OF LAST MOD DATE\n         CVD   R9,DSCBWORK     CONVERT TO DECIMAL\n         UNPK  VRECDLM+2(3),DSCBWORK+6(2)   UNPACK INTO DDD FLD\n         OI    VRECDLM+4,X'F0'\n         MVC   VRECJLU,DMSJLU   GET JOB LAST USED;DMS/OS ONLY\n         TM    DSCBCHG,X'02'    OPEN FOR OTHER THAN INPUT AFTER BKUP\n         BNO   CHKALLOC         NO\n         MVI   VRECCHG,C'1'     YES\nCHKALLOC MVI   VRECALOC,C'C'   CYLINDER ALLOC\n         TM    DSCBALOC,X'C0'  IS IT CYLINDER ALLOC\n         BO    CHKPSWD         YES\n         MVI   VRECALOC,C'T'   NO - TRK ALLOC\n         TM    DSCBALOC,X'80'  IS IT TRK ALLOC\n         BO    CHKPSWD         YES\n         MVI   VRECALOC,C'B'   NO - BLK ALLOC\n         TM    DSCBALOC,X'40'  IS IT CYLINDER ALLOC\n         BO    CHKPSWD         YES\n         MVI   VRECALOC,C'A'   NO - ABSTR ALLOC (X'00')\nCHKPSWD  TM    DSCBCHG,X'10'   IS THERE A READ OR WRITE PASSWORD?\n         BNO   CHKRACF         NO\n         MVI   VRECPSWD,C'1'   YES:1=WRITE ONLY\n         TM    DSCBCHG,X'04'   IS IT WRITE ONLY PASSWORD\n         BO    CHKRACF         YES\n         MVI   VRECPSWD,C'2'   NO- 2=READ AND WRITE PASSWORD\nCHKRACF  TM    DSCBCHG,X'40'  IS DS RACF DEFINED I.E. SECURITY INDIC ON\n         BNO   VPUTREC         NO\n         MVI   VRECRACF,C'1'   YES:1=RACF SECURITY INDICATOR ON\n         SPACE 1\nVPUTREC  B     VPUTREC2         SET TO NOP IF V,K= CODED\n         LA    R1,VRECOUT       PASS REPORT1 ADDR IN R1\n         L     R15,=A(VENTRY)   ENTRY PT ADDR IN MAIN CSECT FOR COMPKEY\n         STM   R2,R14,VOPTREGS  SAVE THIS CSECT REG ENVIRON\n         LM    R2,R14,SAVEAREQ  SET UP REGS FOR MAIN CSECT ENVIRONM\n         BR    R15 GO DO COMPARISON IN MAIN CSECT AND RETURN TO VPUTRET\n         SPACE 1\nVPUTRET  LR    R12,R1           RESTORE BASE REG FROM R1=A(SAVEAREQ)\n         LM    R2,R14,VOPTREGS  RESORE CSECT REG ENVIRONMENT\n         SPACE 1\nVPUTREC2 EQU   *    BEFORE WITING OUT THE REPORT1 RECORD, DETERMINE IF\n*        WE MUST REINVOKE HFSELECT AS AN ATTACHED SUBTASK. IF SO USE\n*        THE REPORT1 RECORD TO CONSTRUCT AND DYNAMICALLY ALLOCATE AN\n*        INPUT FILE FOR THE SUBTASK. THE DSORG IS USED TO DETERMINE THE\n*        DDNAME OF THE PRIMARY INPUT FILE.\n*            DO NOT ATTACH A SUBTASK IF THE SECURITY VIOLATION FLAG\n*        IS ON.\n*\n         L     R9,=A(VPARM)      WAS VSYSIN DD CODED\n         CLI   2(R9),X'00'       WAS ANY DATA ENTERED INTO PARM?\n         BE    SKPATTCH         NO - DO NOT ATTACH ANY SUBTASKS\n         CLI   VRECVIOL,C'*'     WAS THERE A SECURITY VIOLATION\n         BE    NOATTCH          YES\n         CLI   ATTCHFLG,C'N'     IS THIS DSN A TAPE OR ORPHAN ENTRY\n         BE    NOATTCH          YES\n         CLI   VRECMEM,BLANK1    IS THERE A MEMBER NAME\n         BNE   BYPWAIT           YES - CONTINUE ON(SECURITY CHECK DONE)\n*                 NO - THERE WAS NO SECURITY CHECK DONE ON THE DSN\n         TM    DSCBORG+1,X'08'   IS DSORG=VS\n         BO    NOATTCH          YES - DONT ATTACH SUB-TASK FOR VSAM\n         RACHECK ENTITY=VRECDSN,CLASS=DATASETX,VOLSER=VRECVOL,         X\n               LOG=NOSTAT     DO NO LOG TO AUDIT FILE\n         CHI   R15,4     RESOURCE NOT PROTECTED?                  @MK1\n         BE    BYPWAIT   YES - OK                                 @MK1\n         LTR   R15,R15   DETERMINE IF USER HAS SECURITY ACCESS TO DS\n         BNZ   SECVIOL2  NO- DO NOT ATTACH A TASK FOR THIS DSN\nBYPWAIT  EQU   *\n         CLI   REALOCRC,X'00'   DID PREV REALLOC MACRO FAIL?\n         BNE   VUNALLOC    YES - SKIP DETACH AND UNALLOC PRIOR INPUT\n*                              NO-     FIRST TIME THRU MEANS\n         CLC   TCBADDR,=X'00000000'      TCB=0 I.E. NO SUBTASK WAITING\n         BE    SKIPWAIT          NO\n         WAIT  ECB=ATTCHECB      WAIT ON PRIOR ATTACHED SUBTASK TO END\n         DETACH TCBADDR          DETACH THE JUST ENDED SUBTASK\n         XC    TCBADDR,TCBADDR   ZERO TCBADDR TO INDICATE DETACH DONE\n         SR    R15,R15\n         ICM   R15,7,ATTCHECB+1  GET RETURN CODE OR ABEND FROM SUB-TASK\n         BZ    TASKOK1           RC=0\n         SRL   R15,12  PUT THE RC IN HIGH ORDER BITS (FOR SYSTEM ABEND)\n         CH    R15,VOPTRC      COMPARE RC TO THE ONE IN THE ECB\n         BNH   BYPRC             THE ECB IS LOWER - DO NOTHING\n         STH   R15,VOPTRC      REPLACE THE CURRENT RC WITH THE ECB\nBYPRC    AP    ATCHFAIL,ONE      ADD 1 TO SUB-TASK FAILED COUNT\nVUNALLOC MVC   DYNDDNAM,SAVDYNDD GET DD OF INPUT FILE FROM FAILED TASK\n         LA    R1,REQBLKUP       UNALLOCATE THAT FILE\n         DYNALLOC\n         MVC   DYNDDNAM,VPGMSYS2 GET DD OF OUT FILE FROM FAILED TASK\n         LA    R1,REQBLKUP       THIS IS ONLY NECESSARY FOR //DISK DD\n         DYNALLOC\nCLEARECB XC    ATTCHECB,ATTCHECB REUSE THE ECB\n*\nSKIPWAIT EQU   *\n*        DYNAMICALLY ALLOC THE PRIMARY INPUT FILE\n         MVI   TUPEOL,X'00'      EXTND DYNALOOC PARAM LIST FOR MEMBER\n         MVC   DYNMEMB,VRECMEM   FILL IN MEMBER NAME\n         CLI   VRECMEM,BLANK1    IS THERE A MEMBER NAME\n         BNE   SEQDD             YES - MAKE DDNAME SYSUT1\n         MVI   TUPEOL,X'80'      NO -CUT MEMBER FROM DYN PARM LIST\n         MVC   DYNDSN,VRECDSN    MOVE IN DSN\n         MVC   DYNVOLSR,VRECVOL  MOVE IN VOLSER\n         MVC   DYNDDNAM,=C'LIBFILE '\n         MVC   VDDPREF,=C'LIB'   FOR //DISK\n         TM    DSCBORG,X'02'     IS DSORG=PO\n         BO    ALLOCDD           YES\n         MVC   DYNDDNAM,=C'ISAMFILE'\n         TM    DSCBORG,X'80'     IS DSORG=IS\n         BO    ALLOCDD           YES -\nSEQDD    MVC   DYNDDNAM,=C'SYSUT1  '\n         MVC   VDDPREF,=C'SYS'   FOR //DISK\nALLOCDD  CLI   2(R9),C'D'      IS THE SUBTASK GOING TO INVOKE THE D OPT\n         BNE   ALLOCDD1         NO\n         XC    TUFREEP,TUFREEP  YES - ELIMIN THE CLOSE=FREE FROM INPUT\n         LA    R1,REQBLKUP      SET UP UNALLOCATION OF INPUT FILE\n         DYNALLOC\nALLOCDD1 LA    R1,REQBLKP\n         DYNALLOC\n         LTR   R15,R15\n         BZ    ALLOCOK\n         AP    NOATCHCT,ONE\n         B     DAIRFAIL\n*\nALLOCOK  MVI   TUPEOL,X'80'            RESET END OF LIST POINTER\n         MVC   SAVDYNDD,DYNDDNAM SAVE DDNAME OF FILE FOR ATTACHED TASK\n*                                NEEDED IN CASE ATTACHED TASK FAILS\n*\n         MVC   VPGMSYS1,DYNDDNAM  FOR ALTPGM USE HFSELECT INPUT DDNAME\n*     CHECK IF DISK DD IS CODED\nVDISKDD  NOP    SKPVDSK1     SET TO BR AFTER 1ST TIME THRU;//DISK SETUP\n         MVI    VDISKDD+1,SETBR\n         RDJFCB (DISK)        GET VOLSER FROM //DISK DD\n         LTR    R15,R15\n         BNZ    SKPVDSK2      THE DISK DD WAS NOT FOUND\n         L      R1,=A(JFCBVOLS)         GET VOLSER\n         MVC    VDISKVOL,0(R1)          AND SAVE IT\n         XC     WKAREA,WKAREA    GET THE UCB ADDR OF THE THE VOL\n         LA     R1,PARMUCB\n         USING  UCBOB,R2  USE R2 AS UCB BASE (R9 IS OCCUPIED WITH PARM)\nVUCBRTN  L      R15,SCANUCB\n         BALR   R14,R15\n         LTR    R15,R15\n         BNZ    SKPVDSK2             UCB NOT FOUND\n         L      R2,ADDRUCB\n         TM     UCBSTAT,UCBONLI\n         BZ     VUCBRTN\n         CLC    UCBVOLI,VDISKVOL\n         BNE    VUCBRTN\n         ST     R2,VUCBA            SAVE UCB ADDR\n         MVC    CVOLDEVT,UCBTYP     SAVE UCB DEV TYPE FOR CATALOG MACRO\n         MVC    CVOLSER,VDISKVOL    SAVE VOLSER FOR CATALOG MACRO\n         DROP   R2                 DROP R2 FROM UCB\n         MVI    SKPVDSK1+1,SETNOP   NOP TO ALLOW NEXT PARAGR EXECUT\n         MVC    XALTDD2,=C'SYSV0000'  USE SYSV0000 INSTEAD OF SYSUT2\n         MVC    XALTDD,=C'LIBV0000'   USE LIBV0000 INSTEAD OG LIBOUT\nSKPVDSK1 B      SKPVDSK2              NOP IF //DISK FOUND\n         CLI    VRECMEM,C' '         IS MEMBER NAME BLANK\n         BNE    VMEMERR  NO- DO NOT ATTACH SUBTASK- MEMBERS NOT ALLOWED\n         MVC    VSPCDSN,VRECDSN      SETUP TO GET # OF TRKS OF INPUT DS\n         MVC    VSPCVOL,VRECVOL\n         CALL   FILSPACE,(VSPCLIST)  CALL FILESPC RTN TO RETURN # TRKS\n         PACK   DSCBWORK,VSPCTRK     PACK THE # OF TRKS\n         CVB    R1,DSCBWORK           AND CONVERT TO BINARY IN FULLWRD\n         ST     R1,VTRKS             SAVE IT\n         MVC    PDSCB(108),TARGET  GET 1ST 108 BYTES OF DSCB FOR REALLC\n         MVI    PDSCB+44,X'F1'       SET DSCB FORMAT TO 1\n         L      R2,VUCBA             GET UCB ADDR\n         REALLOC DSSIZE=VTRKS,PDSCB=PDSCB,UCB=(R2),PDSDIR=VDIRBLKS,    X\n               MF=(E,REALLOCL)   CREATE DSCB1 FOR OUTPUT FILE\n         STC    R15,REALOCRC  SAVE THE RETURN CODE\n         LTR    R15,R15\n         BNZ    REALOCER       COULD NOT ALLOC- DO NOT ATTACH SUB-TASK\n         MVC    DYNVOLSR,VDISKVOL    SET UP TO DYNAMICLLY ALLOC THE DS\n         MVC    DYNDDNAM(3),VDDPREF  GET EITHER 'SYS' OR 'LIB'\n         MVC    DYNDDNAM+3(5),=C'V0000'   DDNAME=SYSV0000/LIBV00000\n         MVC    VPGMSYS2,DYNDDNAM      SET DDNAME FOR ALT PGM\n         MVI    VPGMDD,C' '   SET DDPREF TO BLANK- SO VPGMSYS2 ISNT CHG\n         LA     R1,REQBLKP\n         DYNALLOC\n         LH     R15,RBERR\n         LTR    R15,R15\n         BNZ    DAIRFAIL\n         B      VDISKBR             SKIP CODING FOR SYSVNNNN/LIBVNNNN\nSKPVDSK2 EQU    *\n*\n*     CHECK TO SEE IF SYSVNNNN OR LIBVNNNN DDS ARE CODED\n         AP    XRECCNT,=P'1'      ADD 1 TO SUBTASK NUMB TO GENERATE THE\n*                            NNNN PORTION OF THE DDNAME\n         UNPK  XALTDD,XRECCNT     UNPACK THE NUMBER\n         OI    XALTDD+7,X'F0'     FIX SIGN 1/2 BYTE\n         MVI   XALTDD+3,C'V'      FORM DDNAME XXXVNNNN\n         SR    R1,R1          TIOT SEARCH RTN TO LOOK FOR ABOVE DDNAME\n         USING PSA,R1\n         L     R1,PSATOLD\n         USING TCB,R1\n         L     R1,TCBJSCB\n         USING IEZJSCB,R1\n         L     R1,JSCDSABQ\n         USING QDB,R1\n         L     R1,QDBFELMP\n         USING DSAB,R1\n         USING TIOENTRY,R15   TIOT ADDRESSABILITY\nVTIOTLOP L     R15,DSABTIOT   GET THE TIOT ENTRY POINTER\n         CLC   TIOEDDNM+3(5),XALTDD+3\n         BE    VDDFND       YES\n         ICM   R1,15,DSABFCHN  CHAIN TO THE NEXT DSAB\n         BNZ   VTIOTLOP         THERE ARE ADDITIONAL DSABS\n         B     SKPEXITS\nVDDFND   MVC   XALTDD,TIOEDDNM\n         MVC   XALTDD2,TIOEDDNM\n         DROP  R15\n         MVC   XALTDD(3),=C'LIB'\n         MVC   XALTDD2(3),=C'SYS'\n*  NOW DEALLOC THE EXITS DD, IF CODED IN THE JCL OR DYNAMICALLY ALLOC\nVDISKBR  NOP   ATTACH         SET TO BR IF //DISK DD REQUESTED\n         CLC   PGMNAME,=C'HFSELECT'   IS SUB-TASK PGM NAME= HFSELECT?\n         BNE   SKPEXITS               NO\n         MVI   TXTUNTUP,X'00'         SET UNALLOC TO UNALLOC & REMOVE\n         MVC   DYNDDNAM,=CL8'EXITS'\n         LA    R1,REQBLKUP\n         DYNALLOC\n         MVI   TXTUNTUP,X'80'    RESET\n         LA    R1,REQBLKXP       ALLOCATE NEW EXITS DD\n         DYNALLOC\n         LH    R15,RBERRX\n         LTR   R15,R15\n         BNZ   DAIRFAIL\n         OPEN  (VEXITS,OUTPUT)\n         PUT   VEXITS,EXITR1\n         PUT   VEXITS,EXITR2\n         CLOSE (VEXITS)\n*@MK1    FREEPOOL VEXITS\nSKPEXITS EQU   *\n         CLC   PGMNAME,=C'HFSELECT'   IS SUB-TASK PGM NAME= HFSELECT?\n         BE    CKDISKDD               YES- DONT ALLOCATE NEW SYSPRIN2\n         LA    R1,REQBLKSP   ALLOC NEW SYSPRIN2 FOR IBM-TYPE UTILITIES\n         DYNALLOC\n         CLI   VPGMDD,C' '      DID AN ALT PGM REQUEST AN ALT DD\n         BE    CKDISKDD          NO\n         MVC   VPGMSYS2,XALTDD     YES\n         MVC   VPGMSYS2(3),VPGMDD\nCKDISKDD CLI   SKPVDSK1+1,SETNOP  WAS //DISK DD REQUESTED\n         BNE   ATTACH             NO\n         MVI   VDISKBR+1,SETBR    YES - ALLOC EXITS FILE ONLY ONCE\n*\nATTACH   ATTACH DE=BLDLDATA+0,PARAM=((R9),VPGMLEN),VL=1,ECB=ATTCHECB\n*  VPGMLEN PARAM ADDED TO ATTACH FOR ALTERNATE SUB-TASK PGM\n         ST    R1,TCBADDR   SAVE THE TASK CONTROL BLOCK ADDR\n         B     SKPATTCH     BYPASS ADDING TO SKIP COUNTER\n         SPACE 3\nNOATTCH  AP    NOATCHCT,ONE     ADD 1 TO NUMB OF SUB-TASKS NOT ATTACHED\n         MVI   VMSG8+7,C'W'     CHANGE MSG TO WARNING FROM INFORMATNAL\nSKPATTCH EQU   *\n         MVI   ATTCHFLG,C'Y'    RESET ATTACH FLAG\nVXITBRO1 B     VNOXITO1         SET TO NOP IF O1 EXIT CODED\n         L     R15,=A(EXTEPAO1) GET EPA OF EXIT\n         L     R15,0(R15)\n         LA    R1,EXITPARM      LOAD PARAMETER ADDR IN R1\n         BALR  R14,R15\n         C     R15,=F'4'          CHECK RETURN CODE\n         BL    VNOXITO1 RC=0   CONTINUE NORMAL PROCESSING\n         BER   R10      RC=4  DELETE THIS RECORD-DONT WRITE REPORT1\n         MVI   VXITBRO1+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT\nVNOXITO1 EQU   *\n         PUT   VREPORT1,VRECOUT WRITE REPORT1\n         AP    PRECSEL,ONE      ADD 1 TO RECORDS OUTPUT\n         SPACE 1\n         CP    PRECSEL,VTOTCNT  HAS COUNT BEEN SATISFIED ON ALL KEYS\n         BE    VCNTSAT          YES- GO TO EOJ AND SET FLAG\n         BR    R10              NO\n         SPACE 2\nVPUTREJ  LR    R12,R1           RESTORE BASE REG FROM R1=A(SAVEAREQ)\n         LM    R2,R14,VOPTREGS  RESORE CSECT REG ENVIRONMENT\nVPUTREJ2 BR    R10    SET TO NOP IF REJECTS ARE TO BE WRITTEN\nVXITBRO2 B     VNOXITO2         SET TO NOP IF O2 EXIT CODED\n         L     R15,=A(EXTEPAO2) GET EPA OF EXIT\n         L     R15,0(R15)\n         LA    R1,EXITPARM      LOAD PARAMETER ADDR IN R1\n         BALR  R14,R15\n         C     R15,=F'4'          CHECK RETURN CODE\n         BL    VNOXITO2 RC=0   CONTINUE NORMAL PROCESSING\n         BER   R10      RC=4  DELETE THIS RECORD-DONT WRITE REPORT2\n         MVI   VXITBRO2+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT\nVNOXITO2 EQU   *\n         PUT   VREPORT2,VRECOUT  WRITE REPORT2\n         L     R1,=A(OUTCT2)     GET REPORT2 COUNT\n         AP    0(8,R1),ONE       ADD 1 TO COUNT\n         BR    R10\n         SPACE 2\nSRCH20   LA    R9,20     KNOCK DOWN VOL COUNT TO 20\n         B     CATLOOP   RETURN TO SEARCH FIRST VOLUME CONTROL BLOCK\n         SPACE 2\nSECVIOL2 MVI   VRECVIOL,C'+'     SEC VIOLATION ON ATTACHING TASK\n         B     NOATTCH  RETURN TO ONLY PUTTING OUT REPORT1 REC\nREALOCER STC   R15,VRECVIOL  MOVE IN ERROR CODE FROM REALLOC MACRO\n         B     NOATTCH  RETURN TO ONLY PUTTING OUT REPORT1 REC\nVMEMERR  MVI   REALOCRC,X'01'  SET ERROR CODE TO X'01' MEMB NOT ALLOW\n         B     NOATTCH  RETURN TO ONLY PUTTING OUT REPORT1 REC\n         TITLE 'V OPTION -PUT OUT REPORT1 RECORD (DIRECTORY LM DATA)'\nMEMOUT   MVC   VRECOUT+58(42),VBLANKS  BLANK OUT MEMB PORTION OF REC\n         AP    PMEMSEL,ONE     ADD 1 TO MEMBERS OUTPUT\n         TM    PDSFLAG,PDSALIAS        IS THIS AN ALIAS\n         BNO   NOTALIAS        NO\n         MVI   VRECALIS,C'1'   YES\nNOTALIAS TM    PDSFLAG,PDSPTRS  ARE THERE TTR POINTERS I.E.LOAD MODUL\n         BZ    TMPDSSPF   NO- ITS NOT A LOAD MODULE, CHK FOR SPF STATS\n         MVI   VRECTYPE,C'L'  YES- INDICATE LOAD MODULE\n         MVC   UDATALEN,PDSFLAG    SET UP TO GET USER DATA LENGTH\n         NI    UDATALEN,X'1F'   ZERO OUT ALL FLAGS EXCEPT LENGTH\n         LA    R9,0    CLEAR R9\n         IC    R9,UDATALEN\n         SLL   R9,1            MULTIPLY BY 2 TO GET NUMB OF BYTES\n         LA    R9,PDSFLAG-PDSMEMNM+1(R9)  R9=LEN OF DIRECTORY MEMB\n         STC   R9,UDATALEN     SAVE LENGTH\n         SPACE 2\n         ICM   R9,7,SIZE   GET LOAD MODULE SIZE\n         CVD   R9,DSCBWORK    AND CONVERT TO DECIMAL\n         UNPK  SIZEWRK,DSCBWORK+3(5)  UNPACK TO 9 BYTES\n         MVC   VRECLSZE,SIZEWRK+1  GET RID OF LEADING 0 (MAX 8 DIGITS)\n         OI    VRECLSZE+7,X'F0'    UNSIGN\n         MVC   DSCBWORK(3),PDSTTR   GET LOAD MODULE TTR\n         MVI   DSCBWORK+3,X'0F'    PAD TTR WITH 0\n         UNPK  DSCBWORK(7),DSCBWORK(4)  UNPACK\n         MVC   VRECLTTR,DSCBWORK   TRUNCATE LAST PAD BYTE\n         L     R15,=A(BINTRTBL)\n         TR    VRECLTTR,0(R15)     TRANSLATE HEX TO PRINTABLES\n         SPACE 1\n         TM    MODATTR1,REENT    IS MODULE REENTRANT\n         BNO   TSTATTR2       NO\n         MVI   VRECLRN,C'1' YES\nTSTATTR2 TM    MODATTR1,REUSE    IS MODULE REUSABLE\n         BNO   TSTATTR3       NO\n         MVI   VRECLRU,C'1' YES\nTSTATTR3 TM    MODATTR1,OVERLAY  IS MODULE IN OVERLAY STRUCTURE\n         BNO   TSTATTR4       NO\n         MVI   VRECLOV,C'1' YES\nTSTATTR4 TM    MODATTR1,TESTRAN  IS MODULE TESTRAN\n         BNO   TSTATTR5       NO\n         MVI   VRECLTS,C'1' YES\nTSTATTR5 TM    MODATTR1,ONLYLOAD IS MODULE ONLY LOADABLE\n         BNO   TSTATTR6       NO\n         MVI   VRECLOL,C'1' YES\nTSTATTR6 TM    MODATTR1,SCATTER  IS MODULE SCATTER\n         BNO   TSTATTR7       NO\n         MVI   VRECLSC,C'1' YES\nTSTATTR7 TM    MODATTR1,EXECUT   IS MODULE EXECUTABLE\n         BO    TSTATTR8       YES\n         MVI   VRECLNX,C'1' NO\nTSTATTR8 TM    MODATTR2,FLKED    IS MODULE ONLY EXEC BY F LEVEL LKED\n         BNO   TSTATTR9       NO\n         MVI   VRECLFO,C'1' YES\nTSTATTR9 TM    MODATTR2,REFRESH  IS MODULE REFRESHABLE\n         BNO   TSTALIAS          IS THERE AN ALIAS NAME\n         MVI   VRECLFR,C'1' YES\n         SPACE 1\nTSTALIAS LR    R4,R8    SAVE R8 - BEGINNING ADDR OF DIRECT ENTRY\n         MVC   SAVELMFL,LMFLAG  - SAVE SSI & APF FLAGS\n*        SEE EXPANSION OF IHAPDS MACRO FOR STRUCTURE OF LOAD MODULE\n*        USER DATA AND DEFINITION OF LENGTH LABELS USED IN THIS\n*        CODE TO OBTAIN THE 'ALIAS OF' NAME AND APF CODE\n*        USER DATA CONTAINS 1- BASIC SECTION + 4 OPTIONAL SECTIONS\n*                           2- SCATTER LOAD SECTION\n*                           3- ALIAS SECTION\n*                           4- SSI SECTION\n*                           5- APF SECTION\n         LA    R9,PDSBCLN -GET LENGTH OF BASIC SECTION\n         AR    R8,R9    - OFFSET DSECT PTR TO END OF BASIC SECT\n         CLI   VRECLSC,C'1'   IS THERE A SCATTER SECTION\n         BNE   CHKALIAS       NO\n         LA    R9,PDSS01LN(R9)  YES-ADD SCATTER SECT LENGTH TO R9\n         LA    R8,PDSS01LN(R8)  YES - POINT BEYON SCATTER SECTION\nCHKALIAS CLI   VRECALIS,C'1'    IS THERE AN ALIAS\n         BNE   NOALIAS      NO\n         MVC   VRECLALS,INVALFLD MOVE IN ???????? FOR INVALID FIELD\n         LA    R9,PDSS02LN(R9)   LEN=BASIC(+SCATTER)+ALIAS\n         CLM   R9,1,UDATALEN    IS R9 GREATER THAN COMPUTED MEMB LEN\n         BH    NOALIAS                YES- INVALID\n         MVC   VRECLALS,ALIASOF  NO -MOVE IN ALIAS OF\n         LA    R8,PDSS02LN(R8) POINT BEYOND THE ALIAS SECTION\nNOALIAS  TM    SAVELMFL,SSIINFO  IS THERE SSI INFO IN NOTELIST\n         BNO   NOSSI            NO\n         LA    R9,1(R9)  YES- MAKE SURE SSI SECT IS ALIGNED ON A HALF\n*        WORD BOUNDARY. ADD 1 TO LEN=BASIC(+SCATTER)(+ALIAS) AND\n*        ZERO OUT LOW ORDER BIT. THIS WILL ADD IN SLACK BYTE IF NEEDED\n         N     R9,=X'FFFFFFFE'\n         LA    R8,0(R9,R4)  R4=ADDR OF BEGIN OF DIRECTORY ENTRY\n*                           R8 NOW POINTS TO BEGINNING OF SSI SECTION\n         TM    SSIFLAG,SSIINST    GET SSI INFO\n         BNO   SSI2\n         MVI   VRECLSI1,C'1'\nSSI2     TM    SSIFLAG,SSICHGDP\n         BNO   SSI3\n         MVI   VRECLSI2,C'1'\nSSI3     TM    SSIFLAG,SSISYSG\n         BZ    SSI4\n         MVI   VRECLSI3,C'1'\nSSI4     TM    SSIFLAG,SSIIBMM\n         BNO   PTTOAPF\n         MVI   VRECLSI4,C'1'\nPTTOAPF  LA    R8,PDSS03LN(R9,R4) R4=ADDR OF BEGIN OF DIRECTORY ENTRY\n*               PDSS03LN=LEN OF SSI SECTION. R8 NOW POINTS TO APF SECT\n         LA    R9,PDSS03LN(R9)   LEN=BASIC(+SCATTER)(+ALIAS)+SSI\n         SPACE 1\nNOSSI    TM    SAVELMFL,APFINFO  IS THERE APF CODE INFO IN USER DATA\n         BNO   VPUTREC      NO - ALL DONE -WRITE REPORT1 RECORD\n         MVC   VRECLAPF,INVALFLD   MOVE IN ?? IN CASE APF CODE INVAL\n         LA    R9,PDSS04LN(R9)   LEN=BASIC(+SCATTER)(+ALIAS)(+SSI)+APF\n         CLM   R9,1,UDATALEN  IS R9 GREATER THAN COMPUTED MEMBER LEN\n         BH    VPUTREC         YES - APF CODE IS INVALID\n         LA    R9,0        NO- ZERO R9 FOR APF CODE\n         IC    R9,APFCODE     GET APF CODE\n         CVD   R9,DSCBWORK    CONVERT TO DEC\n         UNPK  DSCBWORK(3),DSCBWORK+6(2)\n         MVC   VRECLAPF,DSCBWORK+1   TRUNCATE HIGH-ORDER BYTE\n         OI    VRECLAPF+1,X'F0'   UNSIGN THE APF CODE\n         B     VPUTREC\n         TITLE 'V OPTION -PUT OUT REPORT1 REC (DIRECTORY SPF DATA)'\nTMPDSSPF TM    PDSFLAG,PDSSPFST  ARE THERE SPF STATISTICS\n         BNO   VPUTREC        NO-LEAVE REST OF RECORD BLANK\n         MVI   VRECTYPE,C'S'  YES- SET RECTYPE TO 'S' - SPF STATS\n         LA    R9,0      CLEAR R9\n         IC    R9,PDSPFVV YES-GET VERSION NUMBER\n         CVD   R9,DSCBWORK\n         UNPK  DSCBWORK(3),DSCBWORK+6(2) UNPACK INTO 3 BYTES\n         MVC   VRECPVV,DSCBWORK+1\n         OI    VRECPVV+1,X'F0'\n         IC    R9,PDSPFMM YES-GET MOD NUMBER\n         CVD   R9,DSCBWORK\n         UNPK  DSCBWORK(3),DSCBWORK+6(2) UNPACK INTO 3 BYTES\n         MVC   VRECPMM,DSCBWORK+1\n         OI    VRECPMM+1,X'F0'\n         UNPK  VRECPCRD,PDSPFCRD    UNPACK THE CREATION DATE\n         UNPK  VRECPLMD,PDSPFLMD    UNPACK THE LAST MOD DATE\n         MVC   DSCBWORK(1),PDSPFHH  GET HR-IN HALF-BYTE DEC(NO SIGN)\n         MVI   DSCBWORK+1,X'0F'     PAD TO MAKE IT A PACKED NUMBER\n         UNPK  DSCBWORK+2(3),DSCBWORK(2)  UNPACK\n         MVC   VRECPHH,DSCBWORK+2   TRUNCATE LAST BYTE(0)\n         MVC   DSCBWORK(1),PDSPFTMM GET MM-IN HALF-BYTE DEC(NO SIGN)\n         MVI   DSCBWORK+1,X'0F'     PAD TO MAKE IT A PACKED NUMBER\n         UNPK  DSCBWORK+2(3),DSCBWORK(2)  UNPACK\n         MVC   VRECPTMM,DSCBWORK+2  TRUNCATE LAST BYTE(0)\n         ICM   R9,3,PDSPFCLN   GET CURRENT NUM OF LINES\n         CVD   R9,DSCBWORK\n         UNPK  VRECPCLN,DSCBWORK+5(3)  UNPACK\n         OI    VRECPCLN+4,X'F0'        DEFAULT SIGN\n         ICM   R9,3,PDSPFILN   GET INITIAL NUM OF LINES\n         CVD   R9,DSCBWORK\n         UNPK  VRECPILN,DSCBWORK+5(3)  UNPACK\n         OI    VRECPILN+4,X'F0'        DEFAULT SIGN\n         ICM   R9,3,PDSPFMLN   GET MODIFID NUM OF LINES\n         CVD   R9,DSCBWORK\n         UNPK  VRECPMLN,DSCBWORK+5(3)  UNPACK\n         OI    VRECPMLN+4,X'F0'        DEFAULT SIGN\n         MVC   VRECPID,PDSPFID     GET LAST MODIFIED USERID\n         DROP  R8\n         B     VPUTREC\n         SPACE 2\nVCNTSAT  MVI   VRC+3,X'02'   SET COUNT SATISFIED RETURN CODE\n         L     R9,=A(LIBRARY)  RESET THE PDS DCB WITH PROPER DSORG\n         MVI   DSORG(R9),X'40'       IN CASE OF EARLY END\n         B     VEOJ\n         SPACE 3\nVEOJ     CLI   CATNOP+1,X'00'  WAS CATALOG SEARCH OPTION USED\n         BNE   VCLOSE          NO\n         L     R2,CIRWALEN     YES- GET LENGTH OF GETMAINED AREA\n         FREEMAIN E,LV=(2),A=CIRWA\nVCLOSE   CLOSE (VREPORT1,,VREPORT2)\n*@MK1    FREEPOOL VREPORT1\n*@MK1    FREEPOOL VREPORT2\n         DELETE EPLOC=BLDLDATA+74  DELETE READVTC MODULE\n         CLC   TCBADDR,=X'00000000'   ANY SUBTASKS STILL ATTACHED\n         BE    VRC               NO\n         WAIT  ECB=ATTCHECB  YES-WAIT ON LAST ATTACHED SUBTASK TO END\n         DETACH TCBADDR          DETACH THE LAST SUBTASK\n         SR    R15,R15\n         ICM   R15,7,ATTCHECB+1  GET RETURN CODE OR ABEND FROM SUB-TASK\n         BZ    TASKOK2           RC=0\n         AP    ATCHFAIL,ONE      ADD 1 TO SUB-TASK FAILED COUNT\n         SRL   R15,12  PUT THE RC IN HIGH ORDER BITS (FOR SYSTEM ABEND)\n         CH    R15,VOPTRC      COMPARE RC TO THE ONE IN THE ECB\n         BNH   VRC               THE ECB IS LOWER - DO NOTHING\n         STH   R15,VOPTRC      REPLACE THE CURRENT RC WITH THE ECB\nVRC      LA    R15,0                   SET RETURN CODE FROM VOPTION\n         CP    ATCHFAIL,ONE      WERE THERE ANY FAILED TASKS\n         BL    VMSG                  NO\n         MVI   VMSG9+7,C'E'   CHANGE MSG TO AN ERROR FROM INFORMATNAL\n         L     R1,=A(SETRC)  YES-SET OVERALL RC\n         MVC   2(2,R1),VOPTRC\n         CLC   VOPTRC,=H'8'      IS RC GREATER THAN 8\n         BNH   VMSG              NO\n         L     R1,=A(SETRCABE)   YES- SET TO ABEND AT EOJ\n         MVI   1(R1),X'70'\nVMSG     ED    VMSG1ED(10),PDSCBTOT+3    EDIT STATS\n         ED    VMSG2ED(10),PDSCBSEL+3\n         ED    VMSG3ED(10),PPDSTOT+3\n         ED    VMSG4ED(10),PMEMTOT+3\n         ED    VMSG5ED(10),PMEMSEL+3\n         ED    VMSG6ED(10),PRECSEL+3\n         ED    VMSG7ED(10),VKEYERCT+3\n         ED    VMSG8ED(10),NOATCHCT+3\n         ED    VMSG9ED(10),ATCHFAIL+3\n         L     R1,=A(MSGCNT)    GET MSGCNT FIELD FOR NUMB OF MSGS\n         MVC   0(2,R1),=H'9'    9 V OPT MSGS\n         LA    R1,VMSG1         LOAD MSG BLOCK ADDR IN R1 FOR PRINT\n         LM    R2,R14,SAVEAREQ      RESTORE REGISTERS\n         BR    R14                  RETURN\n         SPACE 5\nTASKOK1  ST    R10,SAVER10          SAVE BAL REGISTER\n         BAL   R10,RECATRTN         PERFORM RECATALOG RTN\n         L     R10,SAVER10\n         B     CLEARECB            RETURN TO MAINLINE LOGIC AFTER DETCH\nTASKOK2  BAL   R10,RECATRTN         PERFORMLRECATALOG RTN\n         B     VRC                 RETURN TO LOGIC AFTER LAST DETCH\n         SPACE\nRECATRTN BR    R10        SET TO NOP ONLY IF X0 RECAT INIT PARM CODED\n         CATALOG UNCATLG            UNCATL INPUT FILE FOR //DISK DD\n         CATALOG CATLG              CATLG OUTPUT FILE FOR //DISK DD\n         LTR   R15,R15\n         BNZ   VERROR               SOMETHING IS WRONG\n         BR    R10                  RETURN\n         SPACE 3\nDAIRFAIL LA    R1,DAIRPARM          GET DIAR PARM ADDR\n         LINK  EP=IKJEFF18          DAIRFAIL ROUTINE\nVERROR   MVI   VRC+3,X'01'          SET V OPTION ERROR CODE\n         L     R1,=A(SETRCDMP)      CAUSE AN ABEND WITH A DUMP\n         MVI   1(R1),X'70'          (SEE EXITS RC=ABEND,DUMP)\n         B     VEOJ                 GO TO V OPTION EOJ\n         DROP  R12\n         SPACE 3\nDAIRPARM DC    A(REQBLK)    ADDR OF FAILINF SVC99 REQ BLK\n         DC    A(RBERR)     ADDR OF SVC99 DIAR RC\n         DC    A(IKJEFF02)  MSG RTN\n         DC    A(DAIRFLAG)\n         DC    A(0)         ADDR OF CPPL- NEEDED ONLY WHEN NOT WTP\n         DC    A(DAIRBUF)   ADDR OF MSG BUFFER\nIKJEFF02 DC    A(0)         SYSTEM SUPPLIED\nDAIRFLAG DC    X'A0'        WTP REQUESTED, EXTRACT MSG TO BUFFER\n         DC    X'32'        CALLER ID=SVC99\n         TITLE 'V OPTION -DYNALLOC PARAMETER LIST FOR PDSS'\n         DS    0F\nREQBLKP  DC    X'80',AL3(REQBLK)\nREQBLK   DC    X'14'   LENGTH OF REQ BLK\n         DC    X'01'  VERB= DSN ALLOC\n         DC    X'0000'  FLAGS1\nRBERR    DC    H'0',X'0000'\nTXTP     DC    A(TXTUNTP)    TEXT POINTER\n         DC    XL8'00'    RESERVED\nTXTUNTP  DC    A(TUDDNAM)\n         DC    A(TUDSNAM)\n         DC    A(TUSTATS)\n         DC    A(TUUNIT)\nTUFREEP  DC    A(TUFREE)      SET TO ZERO ADDRESS ON D OPTION\nTUPEOL   DC    X'80',AL3(TUVOLSER)  END OF LIST PTR (X'80') ZEROD WHEN\n         DC    X'80',AL3(TUMEMBER)    MEMBER REQUESTED\nTUDDNAM  DC    X'0001'     KEY=0001\n         DC    X'0001'     # OF LEN,PARMS FOLLOWING\n         DC    X'0008'     LEN OF PARM\nDYNDDNAM DC    CL8'VTEMPLIB'    DDNAME\nTUDSNAM  DC    X'0002'     DSN\n         DC    X'0001'\n         DC    H'44'        (DSN MAY BE PADDED WITH BLANKS)\nDYNDSN   DS    CL44\nTUSTATS  DC    X'0004'      DISP=\n         DC    X'0001'\n         DC    X'0001'\n         DC    X'08'    SHR DISP\nTUUNIT   DC    X'0015'  UNIT=SYSALLDA\n         DC    X'0001'\n*@MK1    DC    X'0005'\n*@MK1    DC    C'SYSDA'\n         DC    X'0008'                                @MK1\n         DC    C'SYSALLDA'                            @MK1\nTUVOLSER DC    X'0010'  VOLSER\n         DC    X'0001'\n         DC    X'0006'\nDYNVOLSR DS    CL6\nTUMEMBER DC    X'0003'  MEMBER\n         DC    X'0001'\n*@MK1    DC    H'8'\n         DC    X'0008'        (BAD ALIGNMENT)         @MK1\nDYNMEMB  DS    CL8\nTUFREE   DC    X'001C'  FREE=CLOSE\n         DC    X'0000'\n         SPACE 3\nREQBLKUP DC    X'80',AL3(REQBLKU)\nREQBLKU  DC    X'14'   LENGTH OF REQ BLK\n         DC    X'02'  VERB= UNALLOC DDNAME (FOR D OPTION ONLY)\n         DC    X'0000'  FLAGS1\n         DC    H'0',X'0000'   RBERR\nTXTUP    DC    A(TXTUNTUP)    TEXT POINTER\n         DC    XL8'00'    RESERVED\nTXTUNTUP DC    X'80',AL3(TUDDNAM)    USE DDNAME SET BY ALLOC ABOVE\n         DC    X'80',AL3(TUREMOV)  REMOVE ATTRIB FOR EXITS CODED IN JCL\nTUREMOV  DC    X'0007'\n         DC    X'0000'\n*\nREQBLKXP DC    X'80',AL3(REQBLKX)\nREQBLKX  DC    X'14'   LENGTH OF REQ BLK\n         DC    X'01'  VERB= DSN ALLOC\n         DC    X'0000'  FLAGS1\nRBERRX   DC    H'0',X'0000'\nTXTPX    DC    A(TXTUNTXP)   TEXT POINTER\n         DC    XL8'00'    RESERVED\nTXTUNTXP DC    A(TUDDNAMX)\n         DC    A(TUBLKLN)\n         DC    A(TUSPCPRM)\n         DC    X'80',AL3(TUUNIT)\nTUDDNAMX DC    X'0001'     KEY=0001\n         DC    X'0001'     # OF LEN,PARMS FOLLOWING\n         DC    X'0008'     LEN OF PARM\n         DC    CL8'EXITS   '    DDNAME\nTUBLKLN  DC    X'0009'\n         DC    X'0001'\n         DC    X'0003'\n         DC    FL3'400'    BLKSIZE=400\nTUSPCPRM DC    X'000A'     PRIMARY SPACE\n         DC    X'0001'\n         DC    X'0003'\n         DC    FL3'1'      1 TRK\n         SPACE 3\nREQBLKSP DC    X'80',AL3(REQBLKS)         FOR ALLOCATING SYSPRIN2\nREQBLKS  DC    X'14'   LENGTH OF REQ BLK\n         DC    X'01'  VERB= DSN ALLOC\n         DC    X'1000'  FLAGS1  (SET FOR SYSOUT)\nRBERRS   DC    H'0',X'0000'\n         DC    A(TXTUNTSP)   TEXT POINTER\n         DC    XL8'00'    RESERVED\nTXTUNTSP DC    A(TUDDNAMS)\n         DC    X'80',AL3(TUSYSOUT)\nTUDDNAMS DC    X'0001'     KEY=0001\n         DC    X'0001'     # OF LEN,PARMS FOLLOWING\n         DC    X'0008'     LEN OF PARM\n         DC    CL8'SYSPRIN2'    DDNAME\nTUSYSOUT DC    X'0018'\n         DC    X'0000'\n         TITLE 'V OPTION -PARAMETER LIST AND DATA PASSED BETW READVTOC'\nRVPARML  DC    A(MASK)         PARM LIST PASSED TO READVTOC\n         DC    A(TARGET)\n         DC    A(INITDSN)      INITIAL DSN FOR INDEXED VTOC SEARCH\nMASK     DC    XL40'00'\nMASKVOL  EQU   MASK+28,6       VOLSER PLACED IN MASK\nTARGET   DC    XL156'00'       AREA FOR DATA RETURNED FROM READVTOC\nDSCBDSN  EQU   TARGET,44        DSCB DSN\nDSCBFMT  EQU   TARGET+44,1      DSCB FORMAT\n*DSCBVOL EQU   TARGET+45,6      DSCB VOLSER <== DONT USE!! NOT RELIABLE\nDSCBCRTD EQU   TARGET+53,3      DSCB CREATION DATE\nDSCBNEXT EQU   TARGET+59,1      DSCB NUMBER OF EXTENTS\nDMSJLU   EQU   TARGET+62,8      DMS JOB LAST USED\nDMSDLM   EQU   TARGET+70,3      DMS DATE LAST MODIFIED\nDSCBDLRF EQU   TARGET+75,3      DSCB DATE LAST REFERENCE\nDSCBORG  EQU   TARGET+82        DSCB DSORG\nDSCBRECF EQU   TARGET+84,1      DSCB RECFM\nDSCBBLKS EQU   TARGET+86,2      DSCB BLKSIZE\nDSCBLREC EQU   TARGET+88,2      DSCB LRECL\nDSCBCHG  EQU   TARGET+93,1 DSCB OPEN FOR OTHER THAN INPUT AFTER BKUP FL\n*                          ALSO PASSWORD AND RACF INDICATORS\nDSCBALOC EQU   TARGET+94,1      DSCB SPACE ALLOC TYPE\nTGVOLSER EQU   TARGET+140,6     VOLSER ON WHICH DSCB RESIDES\n         TITLE 'V OPTION -REPORT1 RECORD'\nVRECOUT  DS    0CL100\nVRECVOL  DS    CL6      VOLSER\nVRECDSN  DS    CL44     DSN\nVRECBLNK DS    CL4      BLANKS   (FIRST BYTE MUST BE BLANK IF NO MEMB)\nVRECPSWD DS    CL1      PSWD INDIC:1=WRITE PROTECT,2=READ & WRITE PROT\nVRECRACF DS    CL1      RACF INDICATOR 1=DATASET RACF DEFINED\nVRECVIOL DS    CL1      =* OR + IF SECURITY VIOLATION ON PDS\nVRECCAT  DS    CL1      =C IF DATASET IS CATALOGED\nVRECDSOR DS    CL2      DSORG\nVRECRECF DS    CL2      RECFM\nVRECLREC DS    CL5      LRECL\nVRECBLKS DS    CL5      BLKSIZE\nVRECNEXT DS    CL3      NUMBER OF EXTENTS\nVRECCRTD DS    CL5      CREATION DATE\nVRECDLRF DS    CL5      DATE LAST REFERENCED\nVRECALOC DS    CL1      ALLOCATION TYPE C=CYL,T=TRK,B=BLK,A=ABSTR\nVRECCHG  DS    CL1      CHG FLAG,1=IF UPDATED SINCE LAST BACKUP\n*        THE NEXT 2 FIELDS HAVE MEANING ONLY IF DMS SVC INSTALLED\nVRECDLM  DS    CL5      DATE LAST MODIFIED\nVRECJLU  DS    CL8      JOB LAST USED\n         SPACE 1\n         ORG   VRECBLNK  REDEFINED AREA FOR DIRECTORY MEMB SPF STATS\nVRECMEM  DS    CL8      MEMBER NAME\nVRECALIS DS    CL1    ALIAS INDICATOR BLANK=NO , 1=YES\nVRECPVV  DS    CL2       VERSION\nVRECPMM  DS    CL2       MODIFICATION NUMBER\nVRECPCRD DS    CL5       CREATION DATE\nVRECPLMD DS    CL5       LAST MOD DATE\nVRECPHH  DS    CL2       HOUR MODIFIED\nVRECPTMM DS    CL2       MIN  MODIFIED\nVRECPCLN DS    CL5       CURRENT NUMBR OF LINES\nVRECPILN DS    CL5       INITIAL  \"\nVRECPMLN DS    CL5       MODIFIED\nVRECPID  DS    CL7       USERID\nVRECTYPE DS    CL1       SET TO S FOR SPF STATS, L FOR LOAD MODULES\n         SPACE 2\n         ORG   VRECPVV   REDEFINE FOR LOAD MODULES\nVRECLSZE DS    CL8     LOAD MODULE SIZE IN DECIMAL\nVRECLTTR DS    CL6     TTR IN HEX\nVRECLATR DS    0CL9          ATTR  FIELDS\nVRECLRN  DS    CL1    REENT\nVRECLRU  DS    CL1    REUSE\nVRECLOV  DS    CL1    OVERLAY\nVRECLTS  DS    CL1    TESTRAN\nVRECLOL  DS    CL1    ONLY LOADABLE\nVRECLSC  DS    CL1    SCATTER\nVRECLNX  DS    CL1    NOT EXECUTABLE\nVRECLFO  DS    CL1    F LEVEL LKED\nVRECLFR  DS    CL1    REFRESHABLE\nVRECLALS DS    CL8    ALIAS OF NAME\nVRECLAPF DS    CL2    APF CODE\nVRECLSSI DS    0CL4   SSI INFO\nVRECLSI1 DS    CL1    SEE LOAD MODULE DSECT FOR EXPLANATION\nVRECLSI2 DS    CL1              OF SSI FIELDS\nVRECLSI3 DS    CL1\nVRECLSI4 DS    CL1\n         ORG   VRECOUT+100    RESET ADDRESSING\n         TITLE 'V OPTION -OTHER DATA AREAS, DCB AND MSG AREA'\nEPA      DS    F              ADDR OF READVTOC MODULE\nBLDLLIST DS    0F         BLDL LIST FOR GETTING READVTOC AND HFSELECT\n         DC    H'2'\n         DC    H'74'\nBLDLDATA DC   2XL74'00'   FIRST MODULE=HFSELECT, 2ND=READVTC\n         SPACE 1\nATTCHFLG DC    C'Y'    ATTACH FLAG- SET TO N FOR TAPE;ORPHAN ENTRY\nFILETYPE DS    C             FILE TYPE (NON-VSAM, AIX, CLUSTER, ETC)\nENDVOLFL DC    X'00'           END OF VOLSER TABLE FLAG\nVSORTDON DC    C'0'         SORT END INDICATOR\nDSCBWORK DS    D      8 BYTE WORK AREA\nSAVELMFL DS    X      SAVE THE LOAD MODULE FLAGS (SSI & APF FLAGS)\nUDATALEN DS    XL1   COMPUTE USER DATA LENG AND HOLD MEMB DIRECTORY LEN\nSIZEWRK  DS    CL9    9 BYTE WORK AREA FOR LOAD MODULE SIZE\nINVALFLD DC    C'????????' FILLER FOR INVALID ALIAS OF & APF CODE FLDS\nDATASETX DC    X'09',C'DATASETX',X'40'   CLASS FOR RACHECK\n         SPACE 3\nDCBDDNM  EQU   40        OFFSET TO DCBDDNAME IN DCB\nACBDDNM  EQU   DCBDDNM\nDCBFLAG  EQU   48        OFFSET TO DCBOLGS IN DCB\nDSN1STCH DC    XL1'05'   FIRST CHAR OF INIT DSN DEFAULT TO X'05'\nONE      DC    PL1'1'    CONSTANT ONE\nPDSCBTOT DC    PL8'0'\nPDSCBSEL DC    PL8'0'\nPPDSTOT  DC    PL8'0'\nPMEMTOT  DC    PL8'0'\nPMEMSEL  DC    PL8'0'\nPRECSEL  DC    PL8'0'\nVKEYERCT DC    PL8'0'    NUMBER OF VSYSIN KEY ERRORS ON CATLG SEARCH\nNOATCHCT DC    PL8'0'   NO. OF DSNS FOR WHICH A SUB-TASK WASNT ATTCHED\nATCHFAIL DC    PL8'0'   NO. OF FAILED ATTACHED SUBTASKS\nVCOUNT   DS    PL8       HOLD J=COUNT\nVTOTCNT  DS    PL8     HOLD MAXIMUM NUMBER OF RECS TO BE SELECTED\nVPACKCNT DS    D  PACK THE TABLE ELEMENT COUNT HERE\nSAVDYNDD DS    CL8     DYNALLOC DDNAME SAVED HERE\nATTCHECB DC    F'0'    ATTACH ECB\nTCBADDR  DC    F'0'    TASK CONTROL BLOCK ADDR RETURNED BY ATTACH\nSAVEWC   DS    A     AREA TO SAVE ADDR OF * OR + IN HIGHQUAL(CAT SRCH)\nVOPTRC   DC    H'8'   AREA TO HOLD HIGHEST RC FROM ALL ATTACHED TASKS\nEXITPARM DC    A(VRECOUT)    PARAMETER LIST FOR O1/O2 EXITS\n         SPACE 1\nINITDSN  DS    CL44     FOR INDEXED VTOCS - INITAL DSN\nWCDSCBDS DC    CL44' '  WORK AREA FOR WILDCARD COMPARE\nPLUSMASK DS    CL44     WORK AREA FOR WILDCARD COMPARE\nHIGHQUAL DC    CL44' '  AREA TO FORM HIGH ORDER QUALIF FOR CATALOG SRCH\nVBLANKS  DC    CL44' '  BLANKS\n         SPACE 1\n*        CATALOG SEARCH AREA\nSRCHCAT  CAMLST NAME,DSCBDSN,,RETAREA   CATALOG LOCATE LIST\n         DS    0D    ALIGN RETURN AREA ON DOUBLE WORD\nRETAREA  DS    0CL265\nVOLCNT   DS    H       VOLUME COUNT\n         DS    4X\nVOLID    DS    CL6     VOLSER\n         DS    253X\n         SPACE 1\nSRCHVTOC CAMLST SEARCH,DSCBDSN,MASKVOL,DSCBFMT VTOC SEARCH LIST\n         SPACE 1\nUNCATLG  CAMLST UNCAT,DYNDSN\nCATLG    CAMLST CAT,DYNDSN,,CVOLLIST\nCVOLLIST DC    H'1'            1 VOLUME IN VOL LIST\nCVOLDEVT DS    XL4\nCVOLSER  DS    CL6\n         DC    XL2'0'\nSAVER10  DS    F               SAVE R10 (BAL REG)\n         SPACE 1\nCIRPARM  DS    0F              IKJEHCIR PARAMETER LIST\nCIROPT   DC    X'06'\n         DS    XL2\nCIRLOCRC DS    X\nCIRSRCH  DC    A(SRCHARG)\nCIRCVOL  DS    A\nCIRWA    DS    A\nCIRSAVE  DC    A(SVAREA)\nCIRPSWD  DC    A(PASSWORD)\n         SPACE\nSVAREA   DS    18F\nPASSWORD DC    D'0'\nSRCHARG  DC    CL44' '       <=== MUST BE REINIT TO BLANK\nCIRWALEN DC    A(65530) MAX HALF-WORD LENG FOR IKJEHCIR GETMAINWKAREA\nVOLNUM   DS    F        SAVE AREA FOR NUM OF VOL DS RESIDES ON\n         SPACE 1\nPARMUCB  DS    0F       UCB SEARCH PARAMETER LIST\n         DC    A(WKAREA)\n         DC    A(DEVCLASS)\n         DC    X'80',AL3(ADDRUCB)\nDEVCLASS DC    AL1(UCB3DACC)    SPECIFY DISK ONLY\nADDRUCB  DS    A                ADDR OF UCB RETURNED HERE\n         DS    0D\nWKAREA   DS    CL100\nSCANUCB  DS    A       ADDRESS OF IOSVSUCB ROUTINE IN CVT\n         SPACE 1\nBUFLIST  ICVAFBFL DSECT=NO\n         SPACE 1\n         DS    0H      ALTERNATE PGM UTILITY PARAMETER LIST\nVPGMLEN  DC    AL2(L'VPGMEND)    LENGTH OF UTILITY PARAMETER LIST\nVPGMDDTB DC    5XL8'00'          EMPTY ENTRIES\nVPGMSYSP DC    CL8'SYSPRIN2'     ALTERNATE SYSPRINT DD <===\n         DC    XL8'00'\nVPGMSYS1 DC    CL8'SYSUT1'       ALTERNATE SYSUT1\nVPGMSYS2 DC    CL8'SYSUT2'       ALTERNATE SYSUT2\n         DC    2XL8'00'          SYSUT3/4\nVPGMEND  EQU   VPGMDDTB,*-VPGMDDTB\nPGMNAME  DC    CL8'HFSELECT'     SUB-TASK PROGRAM NAME\nVPGMADR  DS    A                 SAVE ADR OF / AND COMMA FOR PGM NAME\nVPGMDD   DC    CL3' '            ALTERNATE DD FOR ALTPGM (SYS OR LIB)\nVSAVDLM  DS    CL1               DLM FOLLOWING PGM NAME\n*\nXRECCNT  DC    PL3'0'    COUNT USED TO SET UP SYSVNNNN/LIBVNNNN DDS\nEXITR1   DC    CL80'X0'  X0 INIT STATEMENT FOR EXITS FILE\nEXITR2   DC    C' ALTDDS=,,,'\nXALTDD2  DC    CL8'SYSUT2  '     ALT DDNAME SYSVNNNN\n         DC    C',,,,'\nXALTDD   DC    CL8'LIBOUT'       ALT DDNAME LIBVNNNN\n         DC    CL49' '\n*\nVDDPREF  DS    CL3               SYS OR LIB FOR //DISK\nVSPCLIST DS    0XL59    PARAMETER LIST FOR FILESPAC RTN\n         DS    XL2\nVSPCDSN  DS    CL44\nVSPCVOL  DS    CL6\n         DS    CL2\nVSPCTRK  DS    CL5\n*\nREALOCRC DC    XL1'00'         RETURN CODE FROM REALLOC MACRO\nREALLOCL REALLOC MF=L          GENERATE REALLOC PARAMETER LIST\nVUCBA    DS    A\n         DS    0F     ALLIGN ON FULLWORD TO ENSURE NO SLACK\nPDSCB    DS    0XL116          PARTIAL DSCB FOR REALLOC MACRO\n         DS    XL108\nVTRKS    DS    F   VTRKS & VDIRBLKS MUST BE CONTIG WITH PDSCB-NO SLACK!\nVDIRBLKS DC    F'100'       100 DIRECTORY BLKS- MAY BE CHGED BY EXITS\nVDISKVOL DC    CL6' '\n*\nVMSG1    DC    C'0SEL100I NUMBER OF FMT1 DSCBS PROCESSED ='\nVMSG1ED  DC    X'40202020202020212021'\nVMSGLEN  EQU   *-VMSG1\nVMSG2    DC    C'0SEL101I NUMBER OF FMT1 DSCBS SELECTED  ='\nVMSG2ED  DC    X'40202020202020212021'\nVMSG3    DC    C'0SEL102I NUMBER OF PDS FILES PROCESSED  ='\nVMSG3ED  DC    X'40202020202020212021'\nVMSG4    DC    C'0SEL103I NUMBER OF PDS MEMBERS PROCESSED='\nVMSG4ED  DC    X'40202020202020212021'\nVMSG5    DC    C'0SEL104I NUMBER OF PDS MEMBERS SELECTED ='\nVMSG5ED  DC    X'40202020202020212021'\nVMSG6    DC    C'0SEL105I NUMBER OF TOTAL RECORDS OUTPUT ='\nVMSG6ED  DC    X'40202020202020212021'\n* FOLLOWING MSG TALLIES THE NUMBER OF VSYSIN RECORDS THAT HAD ERRORS:\n* 1-INVALID WILDCARDS(%,!), 2-WILDCARDS IN HIGH-ORDER QUALIFIER\n* 3-CATALOG ENTRIES EXCEEDED MAXIMUM(1455) FOR KEY,4-SECURITY VIOL-NO\n*   ACCESS TO CATALOG FOR THIS PREFIX\nVMSG7    DC    C'0SEL106W KEYS BYPASSED DUE TO ERRORS    ='\nVMSG7ED  DC    X'40202020202020212021'\n* FOLLOWING MSG TALLIES THE NUMBER OF DSNS FOR WHICH A SUBTASK WAS NOT\n* ATTACHED. REASONS: 1-TAPE DS,2-VSAM DS,3-SECURITY VIOLATION WOULD\n* RESULT,4-DATASET IS CATALOGED BUT NOT ON INDICATED VOLUME (OR NON-\n* EXISTANT VOLUME) (FOR CATALOG SEARCH OPTION)\nVMSG8    DC    C'0SEL107I SUB-TASKS NOT ATTACHED         ='\nVMSG8ED  DC    X'40202020202020212021'\n* FOLLOWING MSG TALLIES THE NUMBER OF FAILED ATTACHED SUBTASKS\n*  REASONS: 1-NOT ENOUGH REGION (80A,106,804),2-X37,3-BAD PARM, ETC.\nVMSG9    DC    C'0SEL108I NUMBER OF FAILED SUB-TASKS     ='\nVMSG9ED  DC    X'40202020202020212021'\n         SPACE 2\nVREPORT1 DCB   DDNAME=VREPORT1,DSORG=PS,MACRF=PM,BLKSIZE=0,            X\n               LRECL=100,RECFM=FB,SYNAD=SYNADERR,DCBE=VRP1DCBE   @MK1\n*@MK1          LRECL=100,RECFM=FB,SYNAD=SYNADERR\n         SPACE 2\nVREPORT2 DCB   DDNAME=VREPORT2,DSORG=PS,MACRF=PM,BLKSIZE=0,            X\n               LRECL=100,RECFM=FB,SYNAD=SYNADERR,EXLST=JFCBXLST, @MK1  X\n               DCBE=VRP2DCBE                                     @MK1\n*@MK1          LRECL=100,RECFM=FB,SYNAD=SYNADERR,EXLST=JFCBXLST\n         SPACE 2\nVEXITS   DCB   DDNAME=EXITS,DSORG=PS,MACRF=PM,BLKSIZE=400,             X\n               LRECL=80,RECFM=FB,DCBE=VEXTDCBE                   @MK1\n*@MK1          LRECL=80,RECFM=FB\n         SPACE 2\nDISK     DCB   DDNAME=DISK,DSORG=PS,MACRF=R,EXLST=JFCBXLST\n         LTORG\nVRP1DCBE DCBE  RMODE31=BUFF  31-BIT BUFF -NO FREEPOOL AFTR CLOSE @MK1\nVRP2DCBE DCBE  RMODE31=BUFF  31-BIT BUFF -NO FREEPOOL AFTR CLOSE @MK1\nVEXTDCBE DCBE  RMODE31=BUFF  31-BIT BUFF -NO FREEPOOL AFTR CLOSE @MK1\n         TITLE 'PDS DIRECTORY MAP FOR SPF AND LOAD MODULE STATS'\nPDSDRECT DSECT\nPDSMEMNM DS    CL8     MEMBER NAME\nPDSTTR   DS    XL3     TTR\nPDSFLAG  DS    X       INDICATOR FLAG\nPDSALIAS EQU   X'80'   ALIAS INDICATOR\nPDSPTRS  EQU   X'60'   NO. TTR POINTERS - INDICATES LOAD MODULE\nPDSSPFST EQU   X'0F'   NUMBER OF HALFWORDS (15) FOR SPF STATS\nPDSPFVV  DS    X       VV -BINARY\nPDSPFMM  DS    X       MM- BINARY\n         DS    XL3\nPDSPFCRD DS    PL3    CREATION DATE - PACKED-YYDDD\n         DS    X\nPDSPFLMD DS    PL3    LAST MOD DATE - PACKED-YYDDD\nPDSPFHH  DS    X      HH - HOURS IN PACKED DEC FORMAT WITH SIGN MISSING\nPDSPFTMM DS    X      MM - MINUTES\nPDSPFCLN DS    XL2    CURRENT LENGTH\nPDSPFILN DS    XL2    INITIAL LENGTH\nPDSPFMLN DS    XL2    MODIFIED LENGTH\nPDSPFID  DS    CL7    USERID\n         SPACE 1\n         ORG   PDSPFVV    REDEFINE FOR LOAD MODULES\n         DS    8X\nMODATTR1 DS    X\nREENT    EQU   X'80'\nREUSE    EQU   X'40'\nOVERLAY  EQU   X'20'\nTESTRAN  EQU   X'10'\nONLYLOAD EQU   X'08'\nSCATTER  EQU   X'04'\nEXECUT   EQU   X'02'\nMODATTR2 DS    X\nFLKED    EQU   X'80'\nREFRESH  EQU   X'01'\nSIZE     DS    XL3\n         DS    5X\nLMFLAG   DS    X      LOAD MODULE FLAGS\nSSIINFO  EQU   X'10'  SSI SECTION PRESENT\nAPFINFO  EQU   X'08'  APF CODE SECTION PRESENT\n         SPACE 1\n         ORG   PDSMEMNM    ORG BACK TO DISPLACEMENT 0 OF DIRECTORY MEMB\n         DS    3X          ALIAS OF SECTION\nALIASOF  DS    CL8\n         SPACE 1\n         ORG   PDSMEMNM\n         DS    X           SSI SECTION\nSSIFLAG  DS    X      SSI FLAG GIVING INFO ON MODULE\nSSIINST  EQU   X'20' CHG BY INSTALLATION; NOT BY IBM MAINTENANCE\nSSICHGDP EQU   X'08' MODULE IS CHG DEPENDENT ON SOME OTHER SYSTEM MODUL\nSSISYSG  EQU   X'06' CHANGE MAY REQUIRE COMPLETE/PARTIAL SYSGEN\nSSIIBMM  EQU   X'01' IBM SUPPLIED MODULE\n         ORG   PDSMEMNM\n         DS    X           APF SECTION\nAPFCODE  DS    X\n         SPACE 1\n         IHAPDS PDSBLDL=NO     GET PDS DSECT,NO EXTRA BLDL BYTES\n         SPACE 1\n         CVT   DSECT=YES\n         SPACE 1\n         DSECT\n         IEFUCBOB\n         SPACE 1\nCVPL     ICVAFPL ,\n         TITLE 'DYNAMIC ALLOCATION OF SYSPRINT SYSOUT DATA SET'\nDYNALLOC CSECT\n*        THIS CSECT WILL DYNAMICALLY PRODUCE A SYSPRINT DD\n*        STATEMENT (ASSIGNED TO SYSOUT=MSGCLASS) IF THE SYSPRINT\n*        DD STATEMENT HAS NOT BEEN CODED IN THE JCL.\n*           THE REGISTER ASSIGNMENTS ARE AS FOLLOWS:\n*        R12=BASE REGISTER\n*        R8 =BASE FOR REQUEST BLOCK POINTER\n*        R4 =BASE FOR REQUEST BLOCK\n*        R5 =BASE FOR TEXT UNIT POINTERS\n*        R6 =BASE FOR TEXT UNITS\n         USING *,R15\n         STM   R2,R14,SAVEAREF    SAVE REGISTER ROUTINE\n         CNOP  0,4\n         BAL   R12,JUMPSAV7\nSAVEAREF DS    13F\nJUMPSAV7 EQU   *\n         USING SAVEAREF,R12\n         DROP  R15\n         LA    R8,S99AREA      GET ADDRESS OF STORAGE USED FOR\n         USING S99RBP,R8      REQUEST BLOCK POINTER AND PARAMETERS\n         LA    R4,S99RBPTR+4    POINT TO REQUEST BLOCK BEYOND POINTER\n         USING S99RB,R4       ESTABLISH ADDRESSABILITY\n         ST    R4,S99RBPTR         STORE REQUEST BLOCK ADDR IN POINTER\n         OI    S99RBPTR,S99RBPND    INDICATE END OF LIST (X'80')\n         XC    S99RB(RBLEN),S99RB   ZERO OUT REQUEST BLOCK\n         MVI   S99RBLN,RBLEN       PUT LENGTH OF RB IN ITS LENGTH FLD\n         MVI   S99VERB,S99VRBAL  SET VERB CODE FIELD TO ALLOCATION FUNC\n         MVI   S99FLG11,S99JBSYS  INDICATE THIS IS A SYSOUT DATA SET\n         LA    R5,S99RB+RBLEN  POINT 20 BYTE BEYOND RB TO TEXT POINTERS\n         USING S99TUPL,R5      ESTABLISH ADDRESSABILITY FOR TU POINTERS\n         ST    R5,S99TXTPP    INITIALIZE TEXT POINTER ADDR IN RB\n         LA    R6,S99TUPL+8   POINT JUST PAST THE 2 TEXT UNIT POINTERS\n         USING S99TUNIT,R6   TO TEXT UNITS AND ESTABLISH ADDRESSABILITY\n         ST    R6,S99TUPTR POINT 1ST TEXT UNIT POINTER TO 1ST TEXT UNIT\n         LA    R7,DALSYSOU   GET THE KEY FOR ALLOCATING SYSOUT DATA SET\n         STH   R7,S99TUKEY    PUT THE KEY IN THE TEXT UNIT KEY FIELD\n*  ONLY  THE KEY IS NEEDED FOR SYSOUT WITH DEFAULT CLASS (OF MSGCLASS)\n         LA    R6,S99TUNIT+4    POINT PAST THE FIRST TEXT UNIT\n         LA    R5,S99TUPL+4 POINT TO THE 2ND TEXT UNIT POINTER IN LIST\n         ST    R6,S99TUPTR POINT 2ND TEXT UNIT POINTER TO 2ND TEXT UNIT\n         LA    R7,DALDDNAM GET THE KEY FOR ASSOCIATING A DDNAME TO DSN\n         STH   R7,S99TUKEY    PUT THE KEY IN THE TEXT UNIT KEY FIELD\n         MVI   S99TUNUM+1,X'01' DDNAME NEEDS ONLY 1 PARM-PUT 1 IN # FLD\n         MVI   S99TULNG+1,X'08' SET LENGTH OF DDNAME\n         L     R1,=A(PRINT)     GET SYSPRINT DCB\n         MVC   S99TUPAR(8),DCBDDNM(R1)   MOVE IN DDNAME\n         OI    S99TUPTR,S99TUPLN      INDICATE END OF LIST\n         LR    R1,R8  PUT RB POINTER IN R1 FOR DYNALLOC TO INVOKE SVC99\n         DYNALLOC\n         LH    R15,S99ERROR  LOAD R15 WITH ERROR MSG, IF ANY\n         LM    R2,R14,SAVEAREF    RESTORE REGISTERS\n         DROP  R4,R5,R6,R8,R12    DROP ALL USING REGISTERS\n         BR    R14\n         SPACE 1\nS99AREA  DS    CL50\n         LTORG\n         IEFZB4D0\n         IEFZB4D2\nRBLEN    EQU   S99RBEND-S99RB\n         TITLE 'MERGE FILE PROCESSING'\nMERGSECT CSECT\n*        THIS CSECT WILL OUTPUT A RECORD OF THE MERGE FILE WHENEVER\n*        A RECORD IS OUTPUT TO SYSUT2\n*           THE REGISTER ASSIGNMENTS ARE AS FOLLOWS:\n*        R12=BASE REGISTER\n*        R2 =IS ESTABLISHED AS THE ADDR OF THE MERGE DCB\n*        R15=RETURN CODE FROM CSECT 0=OK;4=RECFM ERROR\n         USING *,R15\n         STM   R2,R14,SAVEAREI    SAVE REGISTER ROUTINE\n         CNOP  0,4\n         BAL   R12,JUMPSAV9\nSAVEAREI DS    13F\nJUMPSAV9 EQU   *\n         USING SAVEAREI,R12\n         DROP  R15\n         L     R1,=A(PUTADDR)   SAVE PRIMARY INPUT RECORD ADDR\n         L     R1,0(0,R1)\n         ST    R1,INREC\n         L     R1,=A(CARDADDR)\n         L     R1,0(0,R1)       SAVE SYSIN REC ADDR\n         ST    R1,SYSINREC\n         L     R2,=A(MERGE)     ESTABLISH R2 AS MERGE DCB ADDR\nHOUSEKP  NOP   PUTMERGE         SET TO BR AFTER 1ST TIME THRU\n         MVI   HOUSEKP+1,SETBR\n         OPEN  ((R2),OUTPUT)    OPEN MERGE FILE\n         LH    R0,CONCATLN  CONCATLN IS CALCULATE IN THE MERGE DCB EXIT\n         GETMAIN R,LV=(0)       GET BUFFER FOR CONCATENATED RECORD\n         ST    R1,SUMRECAD      SAVE BUFFER ADDR\n         SPACE 2\nPUTMERGE L     R0,INREC     GET SYSUT1 REC ADDR\n         CLI   INRECFVU,C'V'  IS SYSUT1 VARIABLE\n         BE    RECFM1V       YES\n         LH    R1,INRECLRE NO-GET SYSUT1 LRECL\nCONTINU1 LR    R15,R1\n         L     R14,SUMRECAD  GET CONCATENATED AREA ADDR\n         MVCL  R14,R0  R14 NOW CONTAINS ADDR OF SUMRECAD+LENGTH(SYSUT1)\n         L     R0,SYSINREC     GET SYSIN REC ADDR\n         CLI   SYSNRECF,C'V'   IS SYSIN RECFM=V\n         BE    RECFM2V         NO\n         LH    R1,SYSINLRE     GET SYSIN LRECL\nCONTINU2 LR    R15,R1\n         MVCL  R14,R0          PLACE SYSIN REC JUST BEYOND SYSUT1\n         CLI   INRECFVU,C'V'   IS SYSUT1 RECFM=V\n         BNE   MVCLEND         NO- NO MORE ADJUSTMENTS\n         L     R1,SUMRECAD     YES -POINT TO BEGINNING OF CONCAT REC\n         LH    R0,0(0,R1)      RDW OF CONCATENATED REC\n         CLI   SYSNRECF,C'V'   IS SYSIN RECFM=V\n         BE    VVREC            YES- BOTH SYSUT1 AND SYSIN ARE RECFM=V\n         AH    R0,SYSINLRE    NO- ADD LRECL OF SYSIN FROM DCB\n         B     SETRDW\nVVREC    L     R14,SYSINREC    POINT TO BEGINNING OF SYSIN REC\n         LH    R14,0(0,R14)    GET SYSIN RDW\n         S     R14,=F'4'      SUBTRACT 4 FROM RDW OF SYSIN(DATA LENG)\n         AR    R0,R14         ADD SYSIN RDW TO SYSUT1 RDW\nSETRDW   CH    R0,LRECL(R2)   COMPARE RDW TO JCL LRECL\n         BNH   SETRDW2        OK TO USE JUST CALCULATED RDW\n         LH    R0,LRECL(R2)   JCL LRECL IS LESS THAN RDW - USE JCL\nSETRDW2  STH   R0,0(0,R1)      AND STORE INTO CONCATENATED RDW\nMVCLEND  EQU   *\n         SPACE 1\nEXITBROM B     NOEXITOM   CHANGED TO NOP IF EXIT POINT OM REQUESTED\n         L     R15,=A(EXTEPAOM)   GET EXIT OM ENTRY POINT\n         L     R15,0(R15)\n         LA    R1,SUMRECAD        SET UP PARAMETER LIST\n         BALR  R14,R15            EXECUTE OM EXIT\n         C     R15,=F'4'          CHECK RETURN CODE\n         BL    NOEXITOM RC=0   CONTINUE NORMAL PROCESSING\n         BE    RETURN6  RC=4  DELETE THIS RECORD-DONT WRITE MERGE REC\n         MVI   EXITBROM+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT\nNOEXITOM EQU   *\n         LR    R1,R2          GET MERGE DCB ADDRESS\n         L     R0,SUMRECAD LOAD ADDR OF CONCATENATED AREA INTO R0\nMERGPUT  NOP   MERGPRT        SET TO BRANCH ON //MERGE DD SYSOUT=\n         PUT   (R1),(R0)     PUT OUT A RECORD TO SYSUT2\nMERGPRT  B     RETURN6       SET TO NOP ON SYSOUT\nMERGPRTL L     R15,=A(PRINTER)  PRINT RTN FOR SYSOUT\n         LA    R2,PRTDCB        ORIGINAL MERGE DCB\n         BALR  R14,R15         PERFORM PRINT RTN\n         SPACE 1\nRETURN6  LA    R15,0         SET RETURN CODE\n         LM    R2,R14,SAVEAREI\n         BR    R14\n         SPACE 2\nRECFM1V  L     R1,INREC      GET ADDR OF SYSUT1 REC\n         LH    R1,0(0,R1)    GET RDW IN R1\n         B     CONTINU1\n         SPACE 2\nRECFM2V  L     R1,SYSINREC   GET ADDR OF SYSIN  REC\n         LH    R1,0(0,R1)    GET RDW IN R1\n         A     R0,=F'4'      POINT BEYOND RDW\n         B     CONTINU2\n         SPACE 5\n*       RULES FOR DCB CHECKING- IF THE OUTPUT RECORD TYPE DOESN'T MATCH\n*       THE INPUT RECORD TYPE - ERROR (SEE ABOVE).\n*       DEFAULTS: IF NO RECFM USE PRIMARY FILE RECFM\n*                 IF NO LRECL USE SYSUT1 LRECL + SYSIN LRECL\n*   SAVEAREA IS BEING USED AS THE THE SAVE AREA BY THE SYSTEM SINCE R13\n*   CONTAINS THE ADDRESS OF SAVEAREA.\n*        R14 IS SAVED IN XLSTSAVE\nMERGXLST DS    0F            BEGIN EXLST ON A FULLWORD BOUNDARY\n         DC    X'85'  DEFINE ENTRY AS DCB EXLST\n         DC    AL3(MERGDCB)\nMERGDCB  ST    R14,XLSTSAVE      SAVE R14\n         LR    R2,R1             MOVE DCB ADDRESS TO R2\n         USING IHADCB,R2         ADDRESSABILITY\n         CLI   DCBRECFM,X'00'    WAS RECFM SPECIFIED\n         BNE   SETRECFM                 YES\n         L     R1,=A(INRECFM2)\n         MVC   DCBRECFM,0(R1)     NO- USE PRIMARY INPUT RECFM\nSETRECFM MVI   MERGEFVU,C'U'\n         TM    DCBRECFM,X'C0'  IS MERGE RECFM=U\n         BO    RECFMOK          YES\n         MVI   MERGEFVU,C'F'\n         TM    DCBRECFM,X'80'  IS MERGE RECFM=F\n         BO    RECFMOK          YES\n         MVI   MERGEFVU,C'V'\n         TM    DCBRECFM,X'40'  IS MERGE RECFM=V\n         BO    RECFMOK          YES\nRECFMER2 MVI   RETURN6+3,X'04'  NO-INVALID RECFM\n         B     ENDXLST\nRECFMOK  EQU   *\n         L     R1,=A(MSG40FVU)  GET TRANSLATED RECFM OF SYSUT1\n         MVC   INRECFVU,0(R1)   AND SAVE IT\n         CLC   INRECFVU,MERGEFVU   COMPARE SYSUT1 AND MERGE RECFMS\n         BNE   RECFMER2            ERROR\n         L     R1,=A(SYSINFVU)  SYSIN RECFM (F,V,U)\n         MVC   SYSNRECF,0(R1)      AND SAVE IT\n         SPACE 1\n         L     R4,=A(MAXLEN)    GET LRECL OF PRIMARY INPUT FILE\n         L     R4,0(0,R4)\n         L     R1,=A(MSG40ORG)  IS THIS A VSAM FILE\n         CLI   0(R1),C'V'\n         BNE   NOTVS            NO\n         LA    R4,4(R4)     YES-ADD IN 4-BYTES FOR VSAM RDW\nNOTVS    STH   R4,INRECLRE      SAVE LRECL\n         L     R1,=A(CARDS)     GET SYSIN LRECL\n         MVC   SYSINLRE,LRECL(R1)   SAVE SYSIN LRECL\n         AH    R4,LRECL(R1)     ADD SYSUT1 AND SYSIN LRECLS\n         C     R4,=F'32760'     INSURE DOESNT EXCEED MAX\n         BL    LRECLOK\n         L     R4,=F'32760'\nLRECLOK  STH   R4,CONCATLN      SAVE LRECL SUM\n         LH    R1,DCBLRECL         GET MERGE LRECL\n         LTR   R1,R1\n         BNZ   CHKSYSOT    IF NOT 0 - OK TO USE WHATS ENTERED IN JCL\n         MVC   DCBLRECL,CONCATLN OTHERWISE USE DEFAULT SUM\n*  BLKSIZE PROBLEMS WILL TAKEN CARE OF BY IEC141I 013,RC=20,34,OR 60\nCHKSYSOT DEVTYPE MERGEDD,MERGEDEV\n         CLC   MERGEDEV,=X'00000102'  IS MERGE A SYSOUT DATA SET\n         BE    MRGSYSOT         YES\nENDXLST  EQU   *\n         L     R14,XLSTSAVE      RESTORE  R14\n         BR    R14                    RETURN TO OPEN MACRO\n*\nMRGSYSOT EQU   *\n         TM    DCBOPTCD,X'40'   WAS DCB=OPTCD=U CODED ON SYSOUT\n         BO    ENDXLST          YES - DO NOT DO SYSOUT FORMATTING\n         MVC   PRTDCB,0(R2)      SAVE ORIGINAL DCB FOR PRINT CSECT\n         NI    DCBRECFM,X'06'   ZERO OUT EVERYTHING EXCEPT RECFM=A,M\n         OI    DCBRECFM,X'90'   MOVE IN RECFM=FB\n         MVC   DCBLRECL,=H'133' MOVE 133 TO LRECL FOR PRINT LINE\n         MVC   DCBBLKSI,=H'5320'  MOVE 5320 TO BLKSIZE\n         MVI   MERGPUT+1,SETBR    YES-SET BRANCH AND NOP FOR PRINT\n         MVI   MERGPRT+1,SETNOP\n         B     ENDXLST                 RETURN\n         DROP  R12,R2\n         SPACE 2\nXLSTSAVE DS    A         SAVE R14 FOR DCB XLST PROCESSING\nSYSINREC DS    A         ADDR OF THE SYSIN REC\nINREC    DS    A         ADDR OF THE PRIMARY INPUT REC\nSUMRECAD DS    A         ADDR OF AREA WHERE SYSUT1 AND SYSIN ARE GLUED\nCONCATLN DS    H         LENGTH OF SUMRECAD AREA\nINRECLRE DS    H         PRIMARY INPUT FILE LRECL\nSYSINLRE DS    H         SYSIN LRECL\nMERGEFVU DS    C         MERGE FILE RECFM (F,V,U)\nINRECFVU DS    C         PRIMARY FILE RECFM (F,V,U)\nSYSNRECF DS    C         SYSIN RECFM (F,V,U)\nMERGEDD  DC    C'MERGE   '\nMERGEDEV DS    2F\nPRTDCB   DS    CL96      ORIGINAL MERGE DCB\n         LTORG\n         TITLE 'PROCESS EXITS FILE'\nEXITSECT CSECT\n*        THIS CSECT WILL READ THE EXITS FILE AND SET UP THE CODE\n*        FOR HFSELECT TO TAKE THE FOLLOWING EXIT POINTS:\n*        I1- BEFORE INPUT\n*        I2- AFTER INPUT BUT BEFORE SELECTION PROCESSING\n*        O1- BEFORE OUTPUT AND AFTER SELECTION PROCESSING ON SYSUT2\n*        O2- BEFORE OUTPUT AND AFTER SELECTION PROCESSING ON SYSUT3\n*        O3- BEFORE OUTPUT AND AFTER SELECTION PROCESSING ON SYSUT4\n*        O4- BEFORE OUTPUT AND AFTER SELECTION PROCESSING ON SYSUT5\n*        OM- BEFORE OUTPUT AND AFTER SELECTION PROCESSING ON MERGE\n*        X0- GLOBAL INITIALIZATION EXIT\n*            FORMAT={NONE|HEX|ASCII|RULER}\n*            ALTDDS=NAME1,...,NAME7    ALTERNATE NAMES FOR SYSPRINT,\n*                  SYSIN,SYSUT1,...,SYSUT5\n*            NOCATCK\n*       EXIT O1 IS IGNORED IF SYSUT2 SPECIFIES VSAMOUT\n*       THE FORMAT OF THE EXITS CONTROL STATEMENT IS:\n*       EXITPOINT=MODNAME,DDNAME  E.G. O2=COMPRESS,LOADLIB\n*        DDNAME IS AN OPTIONAL PARAMETER-IF NOT CODED MODNAME COME FROM\n*        EITHER A LINKLISTED LIBRARY OR FROM THE STEPLIB\n*           THE REGISTER ASSIGNMENTS ARE AS FOLLOWS:\n*        R3= CONTAINS PARM ADDR - SAVED IN PARMREG\n*        R12=BASE REGISTER\n*        R15=RETURN CODE FROM CSECT 0=OK;4=CONTOL STATEMENT ERROR\n         USING *,R15\n         STM   R2,R14,SAVEAREZ    SAVE REGISTER ROUTINE\n         CNOP  0,4\n         BAL   R12,JUMPSAVZ\nSAVEAREZ DS    13F\nJUMPSAVZ EQU   *\n         USING SAVEAREZ,R12\n         DROP  R15\n         ST    R3,PARMREG\n         OPEN  (EXITS)      OPEN EXITS FILE, IF IT EXISTS\nGETEXITS GET   EXITS        READ EXITS FILE\n         MVC   EXITREC,0(R1)   MOVE TO RECORD AREA\n         BAL   R8,PRTEXIT      PERFORM- STORE CONTROL CARD FOR PRINTING\nNORMEXIT MVC   EXITBLDL+4(8),=CL8' '      SPACE OUT MODULE NAME\n         LA    R3,0 INIT R3 (DCB ADDR) TO 0 IN CASE NO DDNAME SPECIFIED\n         TRT   EXITREC+3(9),COMATRT    IS THERE A COMMA FOR DDNAME\n         BZ    NODDNM       NO\n         MVC   LOADDCB+DCBDDNM(8),1(R1)  MODIFY DCB FOR DDNAME\n         LA    R2,EXITREC+3              GET START ADDR OF MODNAME\n         SR    R1,R2                     GET LENGTH OF MODNAME\n         BCTR  R1,0         SUB 1\n         STC   R1,MVMODNM+1              SET MODNM LENGTH\n         OPEN  (LOADDCB)                 OPEN LOAD LIB CONTAINING MODNM\n         TM    LOADDCB+DCBFLAG,X'10'  WAS LOADDCB FOUND IN JCL\n         BNO   EXITERR\n         LA    R3,LOADDCB\nMVMODNM  MVC   EXITBLDL+4(0),EXITREC+3\n         CLC   EXITREC(3),=C'O1='   IS THIS AN O1 EXIT POINT\n         BNE   NOTO1                NO\n         BAL   R8,BLDLRTN\n         MVC   EXTEPAO1,EPASV SAVE O1 EPA LOAD POINT\n         L     R1,=A(EXITBRO1)\n         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O1 EXIT\n         L     R1,=A(VXITBRO1)      V OPTION\n         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O1 EXIT\n         B     GETEXITS             ANY MORE EXITS?\nNOTO1    CLC   EXITREC(3),=C'O2='   IS THIS AN O2 EXIT POINT\n         BNE   NOTO2                NO\n         BAL   R8,BLDLRTN\n         MVC   EXTEPAO2,EPASV SAVE O2 EPA LOAD POINT\n         L     R1,=A(EXITBRO2)\n         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O1 EXIT\n         L     R1,=A(VXITBRO2)      V OPTION\n         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O1 EXIT\n         B     GETEXITS             ANY MORE EXITS?\nNOTO2    CLC   EXITREC(3),=C'O3='   IS THIS AN O3 EXIT POINT\n         BNE   NOTO3                NO\n         BAL   R8,BLDLRTN\n         MVC   EXTEPAO3,EPASV SAVE O3 EPA LOAD POINT\n         L     R1,=A(EXITBRO3)\n         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O1 EXIT\n         B     GETEXITS             ANY MORE EXITS?\nNOTO3    CLC   EXITREC(3),=C'O4='   IS THIS AN O4 EXIT POINT\n         BNE   NOTO4                NO\n         BAL   R8,BLDLRTN\n         MVC   EXTEPAO4,EPASV SAVE O4 EPA LOAD POINT\n         L     R1,=A(EXITBRO4)\n         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O4 EXIT\n         B     GETEXITS             ANY MORE EXITS?\n         SPACE 1\nNOTO4    CLC   EXITREC(3),=C'OM='   IS THIS AN OM EXIT POINT\n         BNE   NOTOM                NO\n         BAL   R8,BLDLRTN\n         MVC   EXTEPAOM,EPASV SAVE OM EPA LOAD POINT\n         L     R1,=A(EXITBROM)\n         MVI   1(R1),SETNOP         SET NOP TO EXECUTE OM EXIT\n         B     GETEXITS             ANY MORE EXITS?\n         SPACE 1\nNOTOM    CLC   EXITREC(3),=C'I1='   IS THIS AN I1 EXIT POINT\n         BNE   NOTI1                NO\n         BAL   R8,BLDLRTN\n         MVC   EXTEPAI1,EPASV SAVE I1 EPA LOAD POINT\n         L     R1,=A(EXITBRI1)\n         MVI   1(R1),SETNOP         SET NOP TO EXECUTE I1 EXIT\n         B     GETEXITS             ANY MORE EXITS?\n         SPACE 1\nNOTI1    CLC   EXITREC(3),=C'I2='   IS THIS AN I2 EXIT POINT\n         BNE   NOTI2                NO\n         BAL   R8,BLDLRTN\n         MVC   EXTEPAI2,EPASV SAVE I2 EPA LOAD POINT\n         L     R1,=A(EXITBRI2)\n         MVI   1(R1),SETNOP         SET NOP TO EXECUTE I2 EXIT\n         B     GETEXITS             ANY MORE EXITS?\n         SPACE 1\nBLDLRTN  BLDL  (R3),EXITBLDL GET MODNM FROM LNKLST, STEPLIB OR LOADDCB\n         LTR   R15,R15       WAS BLDL SUCCESSFUL\n         BNZ   EXITERR               NO\n         LOAD  DE=EXITBLDL+4,DCB=(R3)   GET EPA OF EXIT\n         ST    R0,EPASV                 AND SAVE IT\n         CLOSE ((R3))\n         BR    R8              RETURN\n         SPACE 1\nNODDNM   MVI   MVMODNM+1,X'07'  MOVE FULL 8 BYTES MODNAME\n         B     MVMODNM\n         SPACE 1\nRETURNX  CLOSE (EXITS)\n         FREEPOOL EXITS\n         SPACE 1\n         CVB   R15,XTBLCNT      STORE THE COUNT OF EXITS CONTROL ST\n         L     R1,=A(MSGCNT)    IN MSGCNT FOR PRINTING\n         STH   R15,0(R1)\n         LM    R2,R14,SAVEAREZ\nEXITRC   LA    R15,0\n         BR    R14\n         SPACE 2\nEXITERR  MVI   EXITRC+3,X'04'   ERROR CONDITION\n         B     RETURNX\n         SPACE 1\nNOTI2    CLC   EXITREC(2),=C'X0'   IS THIS AN X0 EXIT POINT-INIT\n         BNE   EXITERR              NO\nXINIT    GET   EXITS\n         MVC   EXITREC,0(R1)\n         BAL   R8,PRTEXIT\n         CLI   EXITREC,BLANK1      FIRST COLUMN MUST BE BLANK\n         BNE   NORMEXIT\n*        CLC   EXITREC+1(5),=C'SORT='     SORT INIT OPTION\n*        BNE   NOTSORT                         NO\n*        L     R1,=A(INFIL)             YES - GET SYSUT1 DCB ADDR\n*        CLC   EXITREC+6(6),=C'SYSUT1'\n*        BE    SETSORT\n*        L     R1,=A(CARDS)                   GET SYSIN DCB ADDR\n*        CLC   EXITREC+6(5),=C'SYSIN'\n*        BNE   EXITERR\n*ETSORT  MVC   DCBDDNM(R1),=C'SORTOUT' MAKE HFSELECT INPUT FILE SORTOUT\n*        ZAP   SORTNUM,=P'1'\n*        TRT   EXITREC+11(3),COMATRT     LOOK FOR ,N\n*        BZ    SKIPPACK\n*        PACK  SORTNUM,1(1,R1)       GET NUMBER OF SORT CONTROL RECS\n*KIPPACK CVB   R2,SORTNUM            AND CONVERT TO BINARY\n*        LA    R3,SORT1        READ THAT MANY STATEMENTS FROM EXITS\n*ORTLOOP GET   EXITS\n*        MVC   0(80,R3),0(R1)      MOVE ALL SORT CONTROLS TO PARM LIST\n*        LA    R3,80(0,R3)\n*        BCT   R2,SORTLOOP\n*        LINK  EP=SORT,PARAM=(SORTPARM),VL=1     INVOKE SORT\n*        B     XINIT\n         SPACE 1\n         CLC   EXITREC+1(7),=C'FORMAT='\n         BNE   NOTFORMT\n         CLC   EXITREC+8(3),=C'HEX'\n         BNE   NOTFHEX\n         L     R1,=A(EXITNOP1)     SET NOP FOR ALL FILES TO PRNT HEX\n         MVI   1(R1),SETNOP\n         B     XINIT\nNOTFHEX  CLC   EXITREC+8(5),=C'RULER'\n         BNE   NOTFRULE\n         L     R1,=A(EXITNOP2)\n         MVI   1(R1),SETNOP\n         B     XINIT\nNOTFRULE CLC   EXITREC+8(5),=C'ASCII'\n         BNE   NOTFASCI\n         L     R1,=A(ASCIIPRT)\n         MVI   1(R1),SETNOP\n         B     XINIT\nNOTFASCI CLC   EXITREC+8(4),=C'NONE'\n         BNE   EXITERR\n         L     R1,=A(EXITNOP3)\n         MVI   1(R1),SETBR\n         B     XINIT\n         SPACE 1\nNOTFORMT CLC   EXITREC+1(7),=C'ALTDDS='\n         BNE   NOTALTDD\n         MVI   COMATRT+C' ',C' ' CHANGE TRT TBL TO LOOK FOR BLANKS ALSO\n         LA    R3,EXITREC+8\n         LA    R4,DDTBL\nDDNMTRT  TRT   0(9,R3),COMATRT     LOOK FOR NEXT ALTDD\n         BZ    EXITERR             ERROR\n         SR    R1,R3        GET LENGTH OF ALTDD\n         BZ    GETNXTDD     NO REPLACEMENT\n         BCTR  R1,0         SUB 1\n         STC   R1,MVDDNM+1\n         L     R2,0(0,R4)   GET APPROPIATE DCB FROM DDTBL\n         MVC   DCBDDNM(8,R2),=CL8' '    SPACE OUT THE DDNAME FIRST\nMVDDNM   MVC   DCBDDNM(0,R2),0(R3)\n         LA    R3,1(R3)  POINT TO NEXT DD ENTRY\nNEXTDD   LA    R3,1(R1,R3)  POINT TO NEXT DD ENTRY\n         LA    R4,4(0,R4)   POINT TO NEXT DCB IN DDTBL\n         CLI   0(R4),X'FF'  END OF TABLE\n         BE    XINIT        YES\n         B     DDNMTRT      NO- KEEP PROCESSING ALTDDS\n         SPACE 1\nGETNXTDD CLM   R2,1,=C','    WAS DELIMITER A COMMA\n         BE    NEXTDD       YES- THERE ARE MORE ENTRIES IN ALTDDS\n         MVI   COMATRT+C' ',X'00'  RESET TRT TABLE\n         B     XINIT\nNOTALTDD CLC   EXITREC+1(7),=C'NOCATCK'  BYPASS CATLG CHK ON V OPT\n         BNE   NONOCAT\n         L     R1,=A(BYPCAT)\n         MVI   1(R1),SETBR\n         L     R1,=A(SETCATLG)\n         MVI   1(R1),C'*'       MOVE IN '*' TO INDICATE NOT CHECKED\n         B     XINIT\n         SPACE 2\nNONOCAT  CLC   EXITREC+1(10),=C'TABLESIZE='  MODIFYING T,P,G,E TABL SZ?\n         BNE   NOTABSZ                                   NO\n         LA    R3,EXITREC+11\n         BAL   R8,PACKRTN\n         CVB   R1,EXITWORK               AND MAKE IT BINARY\n         L     R15,=A(FREELEN)    GET ADDR OF FREELEN - THE TABLE SIZE\n         STCM  R1,7,1(R15)    & STORE MODIFIED (IN RIGHTMOST 3 BYTES)\n         B     XINIT                      GET MORE PARAMETERS\n         SPACE 2\nNOTABSZ  CLC   EXITREC+1(7),=C'NOINPUT'   NOINPUT OPTION\n         BNE   NOTNOINP                    NO\n         L     R1,=A(NOTLIBF)           YES - SET BRANCHES TO BYPASS\n         MVI   1(R1),SETBR                    OPEN OF SYSUT1\n         L     R1,=A(RNDMONLY)      FORCE END AFTER PRINTING RNDM TBL\n         MVI   1(R1),SETBR\n         L     R1,=A(GETINPUT)                READ OF SYSUT1\n         MVI   1(R1),SETBR\n         B     XINIT\n         SPACE 2\nNOTNOINP CLC   EXITREC+1(10),=C'RANDOMCNT='\n         BNE   NOTRNDM                    NO\n         LA    R3,EXITREC+11\n         BAL   R8,PACKRTN\n         L     R1,=A(MAXRNDM)    GET ADDR OF THE MAX NUMB OF RNDM NUMBS\n         ZAP   0(8,R1),EXITWORK     AND MOVE IN NEW VALUE (PACKED)\n         B     XINIT\n         SPACE 2\nNOTRNDM  CLC   EXITREC+1(8),=C'NODCBVAL'\n         BNE   NOTNODCB\n         L     R1,=A(DCBVAL)\n         MVI   1(R1),SETBR\n         B     XINIT\n         SPACE 2\nNOTNODCB CLC   EXITREC+1(3),=C'RC='\n         BNE   NOTRC                      NO\n         CLC   EXITREC+4(5),=C'ABEND'     IS RC=ABEND?\n         BNE   NOTRCABE                   NO- MUST BE RC=NNN\n         CLC   EXITREC+9(5),=C',DUMP'     IS RC=ABEND,DUMP\n         BNE   NOTRCDMP                   NO- MUST BE RC=ABEND ONLY\n         L     R1,=A(SETRCDMP)       YES- SET TO ABEND WITH A DUMP\n         MVI   1(R1),X'70'           SET BNZ FOR NON-0 RC\n         L     R1,=A(DSNBOMB)  MODIFY DCB ABEND EXIT TO NOT IGNORE ABND\n         MVI   1(R1),X'00'             AND CREATE A DUMP\n         L     R1,=A(IGNOREBM) MODIFY ESTAE EXIT TO NOT IGNORE ABND\n         MVI   3(R1),X'00'             AND CREATE A DUMP\n         L     R1,=A(SDWAOBT2) (DONT EXEC THE SETRP MACRO IN ESTAE XIT)\n         MVI   1(R1),SETBR\n         B     XINIT\nNOTRCDMP L     R1,=A(SETRCABE)       YES- SET HFSELECT TO ABEND\n         MVI   1(R1),X'70'           SET BNZ FOR NON-ZERO RETURN CODE\n         B     XINIT\nNOTRCABE LA    R3,EXITREC+4\n         BAL   R8,PACKRTN\n         CVB   R1,EXITWORK\n         L     R15,=A(ERROREOJ)\n         STC   R1,1(R15)         SET NEW ERROR CODE\n         B     XINIT\n         SPACE 2\nNOTRC    CLC   EXITREC+1(8),=C'DOPTION='  DOPTION=OPTIMIZE|NNN\n         BNE   NOTDOPT                 NO\n         LA    R3,EXITREC+9            SET UP TO PROCESS DOPTION=NNN\n         CLC   EXITREC+9(8),=C'OPTIMIZE'   IS IT DOPTION=OPTIMIZE\n         BNE   NODOPTMZ                NO\n         L     R1,PARMREG        YES-  GET PARM ADDR\n         LH    R15,0(R1)               GET PARM LENGTH\n         LTR   R15,R15                  IS IT 0?\n         BZ    EXITERR                 YES- THIS IS NOT THE D OPTION\n         STH   R15,SCANPRML            PUT PARM LENGTH IN SCANLIST\n         STC   R15,SCANMVC+1           SET MOVE LENGTH\nSCANMVC  MVC   SCANPARM(0),2(R1)           GET PARM DATA\n         CALL  SCAN4HIT,(SCANLIST)   SEARCH FOR ,J=+ IN PARM\n         CLI   SCANHIT,C'Y'                FOUND?\n         BNE   EXITERR                      NO\n         L     R1,=A(DOPTIMIZ+1)       YES\n         MVI   0(R1),SETBR             SKIP D OPT OPEN/CLOSE\n         CLI   EXITREC+17,C','         IS THERE A DOPTION=...,NNN\n         BNE   XINIT                   NO\n         LA    R3,9(R3)                YES- POINT TO NNN\nNODOPTMZ BAL   R8,PACKRTN  PROCESS THE NNN - TO ACTIVATE D PROCESSING\n         L     R1,=A(DCOUNT)      AFTER THE NTH OCCURRENCE OF THE KEY\n         ZAP   0(4,R1),EXITWORK\n         B     XINIT\n         SPACE\nNOTDOPT  CLC   EXITREC+1(9),=C'VDIRBLKS='  MODIFYING REALLOC DIR BLKS\n         BNE   NOTDIRBL                                  NO\n         LA    R3,EXITREC+10\n         BAL   R8,PACKRTN\n         CVB   R1,EXITWORK               AND MAKE IT BINARY\n         L     R15,=A(VDIRBLKS)   GET ADDR OF VDIRBLKS FOR REALLOC\n         ST    R1,0(R15)          & STORE\n         B     XINIT                      GET MORE PARAMETERS\n         SPACE 2\nNOTDIRBL CLC   EXITREC+1(5),=C'RECAT'  RECAT FILES ON //DISK\n         BNE   EXITERR\n         L     R1,=A(RECATRTN)\n         NI    1(R1),X'0F'       SET NOPR TO PERFORM UNCAT AND CATLG\n         B     XINIT\n         SPACE 2\nPACKRTN  L     R15,=A(TRNSTAB2)        GET NUMERIC TRANSLATE TBL\n         TRT   0(8,R3),0(R15)    AND CHECK THAT SIZE ENTERED\n         BZ    EXITERR                   INVALID NNNN FOLLOWING =\n         SR    R1,R3                     LENGTH OF SIZE\n         BZ    EXITERR                   0=INVALID\n         BCTR  R1,0                      SUB 1 FROM LENGTH FOR PACK\n         EX    R1,PKSIZE                 PACK THE SIZE\n         BR    R8\n         SPACE 2\nPRTEXIT  L     R1,TBLPTR    STORE THE CONTROL CARD\n         MVC   9(VMSGLEN,R1),EXITREC    IN A TABLE\n         LA    R1,VMSGLEN(R1)        POINT TO NEXT ENTRY\n         ST    R1,TBLPTR\n         AP    XTBLCNT,=P'1'        CONTROL CARD COUNTER\n         BR    R8\n         SPACE 2\nPKSIZE   PACK  EXITWORK,0(*-*,R3)    PACK THE NNN (TBLSZ, RNDMCNT, RC)\n         LTORG\nEXITWORK DS    D\nXTBLCNT  DC    PL8'0'      COUNTER FOR NUMBER OF CONTROL STATEMENTS\nEPASV    DS    F\nEXTEPAO1 DS    F\nEXTEPAO2 DS    F\nEXTEPAO3 DS    F\nEXTEPAO4 DS    F\nEXTEPAOM DS    F\nEXTEPAI1 DS    F\nEXTEPAI2 DS    F\nEXITBLDL DC    H'1',H'74'   NUMBER OF ENTRIES,LENGTH OF ENTRY\n         DC    CL8' ',XL66'00'   MODULE NAME,OTHER STUFF\nEXITREC  DS    CL80\nEXITS    DCB   DDNAME=EXITS,DSORG=PS,MACRF=GL,BLKSIZE=0,LRECL=80,      X\n               RECFM=FB,EODAD=RETURNX\nLOADDCB  DCB   DDNAME=XXXXX,DSORG=PO,MACRF=R\nCOMATRT  DC    256X'00'\n         ORG   COMATRT+C','    LOOK FOR COMMAS\n         DC    C','\n         ORG   COMATRT+256\n         CNOP  2,4\n*ORTPARM DC    H'28'\n*        DC    A(SORT1)       BEGIN ADDR OF SORT CONTROL STATEMENT\n*        DC    A(SORT1+719)     END ADDR\n*        DC    4F'0'          NO RECORD OR E15/35\n*        DC    X'03',AL3(SORTMSG)    CHANGE SYSOUT TO SORTMSG\n*ORT1    DC    9CL80' '           ALLOW UP TO 9 SORT CONTROL STATEMENTS\n*ORTMSG  DC    CL8'SORTMSG'\n*ORTNUM  DC    PL8'1'\nDDTBL    DC    A(PRINT)\n         DC    A(CARDS)\n         DC    A(INFIL)\n         DC    A(OUTFIL)\n         DC    A(OUTFIL2)\n         DC    A(OUTFIL3)\n         DC    A(OUTFIL4)\n         DC    A(LIBOUT)\n         DC    X'FF'\nTBLPTR   DC    A(EXITTBL)  POINTER TO TABLE OF EXITS CONTROL STATEMENTS\nEXITTBL  DC    25CL(VMSGLEN)'0SEL099I'\nPARMREG  DS    F           SAVE PARM REGISTER R3 HERE\nSCANLIST DS    0C\n         DC    CL80',J=+'  STRING TO BE SCANNED FOR IN DOPTION=OPTIMIZE\n         DC    H'4'        SCANNED STRING LENGTH\nSCANPARM DC    CL168' '    PARM FIELD TO BE SCANNED\nSCANPRML DS    H           PARM FIELD LENGTH\n         DS    H           NOT USED\nSCANHIT  DS    CL1\n         DROP  R12\n         TITLE 'DCB OPEN EXIT FOR INPUT FILES TO SET DCBBUFNO-X0 HIPER'\nDCBBUFX  CSECT\n         USING *,R15\n         STM   R2,R14,SAVEAREV\n         CNOP  0,4\n         BAL   R12,JUMPSAVV\nSAVEAREV DS    13F                    SAVE R14\nJUMPSAVV EQU   *\n         USING SAVEAREV,R12\n         DROP  R15\n         LR    R4,R1           GET FILE DCB\n         USING IHADCB,R4\n         L     R1,=A(DDN)        GET INPUT DDNAME\n         MVC   DEVDDNAM,0(R1)    MOVE TO DEVDDNAM\n         DEVTYPE DEVDDNAM,DEVAREA,DEVTAB  GET NUMB OF TRKS/CYL & DEVTYP\n         TM    UCBCLASS,UCB3TAPE     IS IT A TAPE DEVICE\n         BO    TAPBUFNO          TAPE RTN\n         TM    UCBCLASS,UCB3DACC     IS IT A DASD DEVICE\n         BNO   DCBXRET            NO - RETURN\n         TM    DCBRECFM,X'80'    IS RECFM=F\n         BNO   DCBXRET           NO- RETURN WITHOUT DOING ANYTHING\n         TM    DCBRECFM,X'40'\n         BO    DCBXRET               ITS RECFM=U\n*        COMPUTE THE MAX NUMBER OF RECORDS (BLOCKS) ON A TRACK IN R0\n         TRKCALC FUNCTN=TRKCAP,TYPE=UCBDEVCD,R=1,K=DCBKEYLE,           X\n               DD=DCBBLKSI,REGSAVE=YES\n         C     R0,=F'2' DONT DO ANYTHING FOR FILES WITH 1 OR 2 BLKS/TRK\n         BNH   DCBXRET\n         C     R0,=F'5'       IS IT LESS THAN THE DEFAULT BUFNO(5)\n         BL    BUFNO2X        YES - USE BUFNO = 2*(NUMBER OF BLOCKS)\nSETBUFNO STC   R0,DCBBUFNO    MODIFY BUFNO\nDCBXRET  LM    R2,R14,SAVEAREV\n         BR    R14            RETURN\n         SPACE 1\nBUFNO2X  SLL   R0,1           MULTIPLY NUMBER OF BLOCKS BY 2 (2 TRKS)\n         B     SETBUFNO\n         SPACE 1\nTAPBUFNO LH    R1,DCBBLKSI     GET TAPE BLKSIZE\n         C     R1,=F'15040'         OVER 15K- DONT DO ANYTHING\n         BH    DCBXRET\n         MVI   DCBBUFNO,X'0A'       UNDER 15K- MAKE BUFNO=10\n         B     DCBXRET\n         DROP  R4\n         SPACE 1\nDEVDDNAM DS    CL8\n*\nDEVAREA  DS   0F     5-WORD AREA RETURNED BY DEVTYPE MACRO\nUCBBYTES DS   0F\n         DS    2X\nUCBCLASS DS    X\nUCBDEVCD DS    X\n         DS    F,H   MAX BLOCK SIZE, NO. OF PHYSICAL CYLS ON DEVICE\nTRKPRCYL DS    H\n         DS    2F\n*ORKAREA DS    XL140   AREA WHERE OBTAIN CAMLST RETURNS DATA\n*        WORKARE+50 IS THE ALLOC TYPE BYTE- X'C0' INDICATES CYL ALLOC\n         SPACE 2\n         LTORG\n         DROP  R12\n         TITLE 'ESTAE EXIT ROUTINE'\nESTAEXIT CSECT\n*        THE PURPOSE OF THIS CSECT IS TO INTERRUPT CERTAIN ABEND CODES,\n*        WRITE A MESSAGE TO THE USER EXPLAINING THE ABEND AND THEN\n*        SUPPRESSING AN ABEND DUMP. THE ABEND CODES INTERCEPTED ARE\n*        80A(REGION), B37-E37(SPACE ON DISK), 722(LINES EXCEEDED.\n*           REGISTER CONVENTIONS UPON ENTRY TO CSECT ARE:\n*        R0=12 IF SDWA IS OBTAINED BY SYSTEM\n*        R1=COMPL CODE,R2=ADDR OF PARAM LIST ON ESTAE MACRO IF R0=12\n*        R3-R13 ARE UNPREDICTABLE\n*        R14=RETURN ADDR TO CONTROL PROGRAM, R15=ENTRY ADDR TO ESTAEXIT\n*           REGISTER CONVENTIONS DURING EXECUTION OF CSECT\n*        R0=RETRY ADDR\n*        R1=ADDR OF SDWA IF IT IS OBTAINED,R2=ADDR OF PARAM LIST\n*        R3=COMPLETION CODE\n*        R6=BASE REGISTER\n*        R14=RETURN ADDR\n*        R15=RETRY CODE-0 IF NO RETRY,4 IF RETRY\n         USING *,R15\n         ST    R14,SAVEAREE\n         CNOP  0,4\n         BAL   R6,JUMPSAV5\nSAVEAREE DS    F\nJUMPSAV5 EQU   *\n         USING SAVEAREE,R6\n         DROP  R15\n         LA    R15,0    BOMBOUT\n         C     R0,=F'12'     WAS THE SDWA ALLOCATED\n         BNE   SDWAOBT       YES\n         LR    R3,R1         NO-LOAD ABEND CODE INTO R3\nCOMPCC   CLM   R3,3,=X'080A' IS IT A REGION ERR(R1 CONTAINS COMPL CODE)\n         BE    IGNOREBM    YES\n         CLM   R3,1,=X'37' IS IT A SPACE PROBLEM\n         BE    SPACERR\nSETRP1   B     RETURN5            CHANGED TO NOP IF SDWA OBTAINED\n         SETRP WKAREA=(R1),RC=0,COMPCOD=((R3),SYSTEM)         BOMB\n         B     RETURN5\n         SPACE 2\nSPACERR  CLM   R3,2,=X'0B'    IS IT A B37,C37,D37 OR E37 ERROR\n         BL    RETURN5        NO\n         SPACE 2\nIGNOREBM LA    R15,4     IGNORE THE BOMB EXCEPT WHEN RC=ABEND,DUMP\n         L     R0,=A(RETRYADR) LD R0 WITH RETURN ADDR TO MAIN PROGR\nSETRP2   B     RETURN5        CHANGED TO NOP IF SDWA OBTAINED\n         LR    R4,R0      LOAD RETRY ADDR INTO R4\n         SETRP WKAREA=(R1),DUMP=NO,RC=4,RETADDR=(R4),FRESDWA=YES,      X\n               COMPCOD=((R3),SYSTEM)\n         B     RETURN5\n         SPACE 2\nSDWAOBT  MVI   SETRP1+1,SETNOP\nSDWAOBT2 MVI   SETRP2+1,SETNOP   SETNOP CHG TO SETBR ON RC=ABEND,DUMP\n         USING SDWA,R1\n         L     R2,SDWAPARM      INSERT PARAM LIST ADDR INTO R2\n         L     R3,SDWAABCC      INSERT ABEND COMPL CODE INTO R3\n         SRL   R3,12            GET SYSTEM COMPL CODE\n         B     COMPCC\n         SPACE 2\nRETURN5  STH   R3,10(0,R2)      PUT COMPL CODE INTO PARAM LIST\n         L     R14,SAVEAREE      RELOAD RETURN ADDR\n         DROP  R1,R6\n         BR    R14            RETURN TO CONTROL PROGRAM\n         SPACE 2\n         LTORG\n         TITLE 'SPIE EXIT'\nSPIEXIT  CSECT\n*        THE PURPOSE OF THIS ROUTINE IS TO PUT OUT A MSG TO THE USER\n*        INFORMING HIM OF A PROGRAM BUG AND TO CONTACT THE VENDOR\n*         REGISTER CONTENTS UPON ENTRY ARE:\n*         R1=ADDR OF THE PIE CONTROL BLOCK\n*         R2-R12 UNCHANGED FROM THE PROGRAM\n*         R13=ADDR OF THE SAVE AREA FOR MAIN PROGRAM\n*         R14=RETURN ADDR TO CONTROL PROG, R15=A(SPIEXIT)\n*        REGISTER CONVENTIONS DURING THE CSECT:\n*         R1=A(PIE),  R2=BASE REGISTER\n*         R5=WORK REGISTER AND USED TO PASS THE CC TO MAIN PROGRAM\n*         R10-R13=RESTORED AS BASE REGISTERS FOR MAIN PROG\n*         R14=RETURN REGISTER, R15=A(SPIEXIT)\n*\n*        ABENDREG WILL CONTAIN THE EPA CONTENTS OF REGS AT ABEND.\n*         WORD 1 CONTAINS THE EPA AT ABEND.\n*         R1=A(PIE) WHERE THE PSW,CC AND R14-R2 ARE FOUND IN WORD 2\n*         R2-R12 FOLLOW IN WORDS 3 THRU 13.\n*\n*        THE FORMAT OF THE PIE WHICH IS 32 BYTES (8 WORDS) LONG IS:\n*         WORD 1= PICA ADDRESS\n*             2-3= PSW (BYTES 7-8 CONTAIN THE COMPLETION CODE)\n*             4-8= R14,R15,R0,R1 AND R2\n*\n         USING *,R15\n         STM   R1,R12,ABENDREG+4   STORE R1-R12 IN WORDS 2-13\n         CNOP  0,4\n         BAL   R2,JUMPSAV6\nABENDREG DS    13F\nJUMPSAV6 EQU   *\n         USING ABENDREG,R2\n         DROP  R15\n         L     R13,=A(SAVEAREA)    RESTORE BASE REGISTER R13\n         L     R5,=A(BASES)\n         LM    R10,R12,0(R5)       RESTORE BASE REGISTERS R10-R12\n*        THE PSW IS LOCATED 8 BYTES INTO THE PIE\n         MVC   ABENDREG(4),8(R1)     MOVE EPA AT ABEND TO ABENDREG\n         MVC   8(4,R1),=A(ABENDMSG)  PLACE RETURN ADDR INTO PSW\n*        THE ABEND CODE IS LOCATED 6 BYTES INTO THE PIE\n         LH    R5,6(0,R1)     INSERT COMP CODE(1-15) INTO R5\n         O     R5,=X'000000C0'    FIX R5 TO CONTAIN 0CX\n         DROP  R2\n         BR    R14                 RETURN  TO MAIN PROG\n         SPACE 2\n         LTORG\n         TITLE 'CLEAR SCREEN CSECT'\nCLRSCRN  CSECT\n         USING *,GOREG\n         ST    R14,SAVER14     SAVE R14\n         STFSMODE ON,INITIAL=YES  FOR VTAM-SET FULLSCREEN MODE ON\n         LA    R0,L'TERMCMDS   LOAD LENGTH OF PARAMETER LIST INTO R0\n         LA    R1,TERMCMDS  LOAD ADDRESS OF PARAMETER LIST INTO R1\n         TPUT  (1),(0),FULLSCR  ERASE SCREEN & POSIT CURSOR\n         STFSMODE OFF             FOR VTAM SET FULLSCREEN MODE OFF\n         L     R14,SAVER14     LOAD R14\n         DROP  GOREG\n         BR    R14             RETURN\nSAVER14  DS    F\nTERMCMDS DC    X'40115D7E1140403CC760003C4F40003CD660003C40400013'\n*        TRY ALSO FOR TERMCMDS DC X'27F54011404013'\n*        27=ESCAPE, F5=ERASE/WRITE, 40=WCC\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HFSELMSG": {"ttr": 9473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x93\\x01\\x1f\\x00\\x93\\x01?\\x18W\\x00*\\x001\\x00\\x16\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1993-01-11T00:00:00", "modifydate": "1993-01-13T18:57:00", "lines": 42, "newlines": 49, "modlines": 22, "user": "CN03MQK"}, "text": "          ISPEXEC LIBDEF ISPPLIB DATASET ID('HRA.HFSELECT.ISPPLIB')\n          ISPEXEC LIBDEF ISPMLIB DATASET ID('HRA.HFSELECT.ISPMLIB')\n        SELMAIN:  ISPEXEC DISPLAY PANEL(SELMAIN)\n                  IF LASTCC EQ 8 THEN EXIT\n                  ISPEXEC VGET (PANELID) SHARED\n                  IF &PANELID EQ SEL004 THEN GOTO SEL004\n                  IF &PANELID EQ SEL021 THEN GOTO SEL021\n                  IF &PANELID EQ SEL040 THEN GOTO SEL040\n                  IF &PANELID EQ SEL076 THEN GOTO SEL076\n                  ISPEXEC DISPLAY PANEL(&PANELID)\n                  GOTO SELMAIN\n        SEL004:   ISPEXEC DISPLAY PANEL(SEL004)\n                  IF LASTCC EQ 8 THEN GOTO SELMAIN\n                  ISPEXEC DISPLAY PANEL(SEL004B)\n                  IF LASTCC EQ 8 THEN GOTO SELMAIN\n                  IF &ZCMD EQ LAST THEN GOTO SEL004\n                  GOTO SELMAIN\n        SEL040:   ISPEXEC DISPLAY PANEL(SEL040)\n                  IF LASTCC EQ 8 THEN GOTO SELMAIN\n                  ISPEXEC DISPLAY PANEL(SEL040B)\n                  IF LASTCC EQ 8 THEN GOTO SELMAIN\n                  IF &ZCMD EQ LAST THEN GOTO SEL040\n                  GOTO SELMAIN\n        SEL076:   ISPEXEC DISPLAY PANEL(SEL076)\n                  IF LASTCC EQ 8 THEN GOTO SELMAIN\n                  ISPEXEC DISPLAY PANEL(SEL076B)\n                  IF LASTCC EQ 8 THEN GOTO SELMAIN\n                  IF &ZCMD EQ LAST THEN GOTO SEL076\n                  GOTO SELMAIN\n        SEL021:   ISPEXEC DISPLAY PANEL(SEL021)\n                  IF LASTCC EQ 8 THEN GOTO SELMAIN\n        SEL021B: ISPEXEC DISPLAY PANEL(SEL021B)\n                  IF LASTCC EQ 8 THEN GOTO SELMAIN\n                  IF &ZCMD EQ LAST THEN GOTO SEL021\n        SEL021C: ISPEXEC DISPLAY PANEL(SEL021C)\n                  IF LASTCC EQ 8 THEN GOTO SELMAIN\n                  IF &ZCMD EQ LAST THEN GOTO SEL021B\n                  ISPEXEC DISPLAY PANEL(SEL021D)\n                  IF LASTCC EQ 8 THEN GOTO SELMAIN\n                  IF &ZCMD EQ LAST THEN GOTO SEL021C\n                  GOTO SELMAIN\n                  END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEBGENER": {"ttr": 9475, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\t \\x8f\\x01\\t \\x8f\\x13C\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-07-27T00:00:00", "modifydate": "2009-07-27T13:43:24", "lines": 18, "newlines": 18, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBG JOB (CN03,SYSP,OD69),'LINDNER.N RM.288',MSGLEVEL=(1,1),\n//             MSGCLASS=H,NOTIFY=CN03NJL,CLASS=B\n//*JOBPARM COPIES=1\n//STEP3   EXEC PGM=IEBGENER\n//SYSUT1    DD DSN=SBGOLOB.FILE807.DOCS(HFSELECT),DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2    DD SYSOUT=(M)\n//\n//*  -----  Or substitute one of the //SYSUT1 lines below......\n//*\n//SYSUT1    DD DSN=SBGOLOB.FILE807.DOCS(SELOPTNS),DISP=SHR\n//\n//          DD DSN=SBGOLOB.FILE807.DOCS(SELMSG),DISP=SHR\n//\n//          DD DSN=SBGOLOB.FILE807.DOCS(SUPRDUMP),DISP=SHR\n//\n//          DD DSN=SBGOLOB.FILE807.DOCS(SELXMPLE),DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INCLUDE": {"ttr": 9477, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\t\\x15\\x8f\\x01\\t\\x15\\x8f\\x01U\\x00\\x01\\x00\\x01\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-06-07T00:00:00", "modifydate": "2009-06-07T01:55:49", "lines": 1, "newlines": 1, "modlines": 0, "user": "SBGOLOB"}, "text": "   INCLUDE OBJECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MACRO": {"ttr": 9479, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x05o\\x00\\x93\\x05o\\x11\\x02\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-25T00:00:00", "modifydate": "1993-02-25T11:02:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CN03MQK"}, "text": "          MACRO\n          IHAQDB\n* /*******************************************************************/\n* /* MODULE-NAME - IHAQDB                                        @L2C*/\n* /*                                                             @L2C*/\n* /* DESCRIPTIVE-NAME - QUEUE DESCRIPTOR BLOCK\n* /* STATUS - CREATED  BY  M.KARLIN 2/19/92\n* /* FUNCTION - CONTAINS INFO ON SIZE, LOCATION, AND ATTRIBUTES OF A\n* /*            QUEUE\n* /* INVOCATION:  BAL - IHAQDB                                   @L2C*/\n* /* MODULE-TYPE - MACRO                                         @L2C*/\n* /*******************************************************************/\nQDB     DSECT\n         DS    0F\nQDBQDB   DS    CL4                     IN-CORE ID,CHARACTERS 'QDB-'\nQDBATTR  DS    XL2                     QUEUE ATTRIBUTES\nQDBRV001 DS    XL2                     RESERVED\nQDBNELMS DS    F                       NUMBER OF ELEMENTS ON QUEUE\nQDBFELMP DS    A                       POINTER TO FIRST ELEMENT\nQDBLELMP DS    A                       POINTER TO LAST ELEMENT\nQDBFPTDS DS    H                       FOWARD POINTER DISPLACEMENT\nQDBBPTDS DS    H                     BACKWARD POINTER DISPLACEMENT\nQDBPRSZ  DS    H                       PRIORITY FIELD SIZE\nQDBPRDS  DS    H                       PRIORITY FIELD DISPLACEMENT\nQDBRV002 DS    XL4                     RESERVED\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MKMESSAG": {"ttr": 9481, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x1c\\x00W\\x00\\x88\\x04\\x8f\\x01\\t\\x17?\\x11@\\x02<\\x02H\\x00;\\xd4\\xf4\\xf5@@@@@@@'", "ispf": {"version": "02.28", "flags": 0, "createdate": "1988-02-17T00:00:00", "modifydate": "2009-06-22T11:40:57", "lines": 572, "newlines": 584, "modlines": 59, "user": "M45"}, "text": "         MACRO\n         GETDATE &TODAY\n&TODAY   DC      C'&SYSDATE'    DATE OF COMPILE IN FORM MM/DD/YY\n         MEND\n         SPACE 2\nMOVEMSG  START 0\n*******************************************************************\n*      THIS PROGRAM WILL GENERATE A MESSAGE FROM A MESSAGE\n* NUMBER PASSED TO IT AND WILL PASS THAT MESSAGE BACK TO AN\n* AREA ALSO PASSED TO IT.\n*\n* R1  - CONTAINS THE ADDR OF A WORK FIELD. THE FIRST WORD IN THIS FLD\n*       CONTAINS THE ADDRESS OF THE PRINT BUFFER (RETURN AREA). THE 2ND\n*       WORD CONTAINS THE MSG NUMBER IN BINARY TO BE USED IN THE MOVE.\n*       THE 3RD WORD CONTAINS EITHER 0 OR AN ADDR IF A FIELD IN THE\n*       MESSAGE IS TO EDITED OR AN ADDR OF A DATA FLD TO BE MOVED INTO\n*       THE MSG TOGETHER WITH ITS LENGTH IN THE HIGH ORDER BYTE.\n* R3  - ADDRESS OF MESSAGE LENGTH AND MSG IN MSGTABLE\n* R4  -  ADDRESS OF MSG EDIT DISPLACEMENT IN TABLE\n* R5  - PRINT BUFFER ADDRESSS,   R8=BASE REGISTER\n* R6  - MESSAGE NUMBER IN BINARY\n* R7  -  ADDR OF FIELD TO BE EDITED\n* R9  - A WORK REGISTER\n*--- CHANGE LOG -----------------------------------------------*\n* 6/22/09 @MK1 UPDATE RELEASE TO 4.3                           *\n****************************************************************\n         ENTRY MOVEMSG  THIS IS THE ENTRY NAME USED BY THE CALLING PROG\n         USING *,R15         CONTAINS ADDRESS OF MOVEMSG START\n         STM   R0,R15,SAVEAREA     STORE ALL THE REGISTERS IN SAVEAREA\n         CNOP  0,4      ALIGN SO R8 WILL CONTAIN THE ADDR OF SAVEAREA\n         BAL   R8,START1           BYPASS SAVEAREA AND LOAD R8 AS BASE\nSAVEAREA DS    16F                 OUR SAVE AREA\n         USING SAVEAREA,R8         SET R8 AS BASE REGISTER\n         DROP  R15                 DROP R15 AS BASE REGISTER\nSTART1   LM    R5,R7,0(R1)   LOAD MSG NO IN R5,PRINT BUF ADDR IN R6\n*        AND ADDR OF FIELD TO BE EDITED IN R7\n         LA    R4,MSGEDTBL(R6)  GET ADDR OF EDIT DISPLACEMENT\n         SR    R9,R9            CLEAR R9\n         IC    R9,0(0,R4)       INSERT EDIT DISPLACEMENT IN R9\n         STC   R9,EDITMSG+3   MODIFY EDIT INSTRUCTION WITH DISPL\n         STC   R9,DATAMSG+3   MODIFY MVC INSTRUCTION WITH DISPL\n         SLL   R6,2                MULTIPLY NUMBER BY 4 (1 WORD)\n         LA    R3,MSGTABLE(R6)  OBTAIN ADDR OF MESSAGE ADDR AND LENGTH\n         CLI   0(R3),X'00'         DOES MESSAGE EXIST,I.E. IS LENGTH=0\n         BNE   MOVEIN              MESSAGE EXISTS.\n*    PUT ADDRESS OF NO-MESSAGE ADDDRESS AND LENGTH INTO REGISTERS\n         LA    R3,NOMSG            GET NO-MESSAGE LENGTH AND ADDR\nMOVEIN   SR    R9,R9            CLEAR R9\n         IC    R9,0(0,R3)      PUT MESSAGE LENGTH IN R9\n         BCTR  R9,0            SUBTRACT 1 FROM LENGTH FOR MOVE\n         STC   R9,LOADBUF+1    MOVE THE MESSAGE LENGTH TO NEXT INSTR\n         L     R3,0(0,R3)\n         LTR   R9,R7           DOES THIS MSG REQIRE EDITING OR DATA\n         BZ    LOADBUF         NO\n         SRA   R9,24   YES-MOVE LENGTH OF DATA FROM HIGH ORDER BYTE\n         BNZ   DATALEN       NO-THERE IS DATA TO MOVE IN\nEDITMSG  ED    0(10,R3),0(R7)  YES-  *****CHANGE 10 FOR GENL MSG******\nLOADBUF  MVC   0(0,R5),0(R3)    LOAD THE MSG INTO PRINT BUFFER\n         LM    R0,R15,SAVEAREA     RELOAD REGISTERS FROM SAVEAREA\n         BR    R14                 RETURN FROM CSECT\n         SPACE 2\nDATALEN  BCTR  R9,0             SUBTRACT 1 FROM LENGTH TO\n         STC   R9,DATAMSG+1     SET LENGTH OF DATA IN NEXT INSTRUCTION\nDATAMSG  MVC   0(0,R3),0(R7)    MOVE DATA INTO MSG\n         B     LOADBUF\n         TITLE 'REGISTER DESIGNATIONS AND MESSAGE TABLES AND MSGS'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*  STORAGE AREA FOR SUBPROGRAM\nNOMSG    DC    AL1(MSGNOLEN),AL3(MSGNO)\nMSGTABLE DC    AL1(MSG0LEN),AL3(MSG0),AL1(MSG1LEN),AL3(MSG1)\n         DC    AL1(MSG2LEN),AL3(MSG2),AL1(MSG3LEN),AL3(MSG3)\n         DC    AL1(MSG4LEN),AL3(MSG4),AL1(MSG5LEN),AL3(MSG5)\n         DC    AL1(MSG6LEN),AL3(MSG6),AL1(MSG7LEN),AL3(MSG7)\n         DC    AL1(MSG8LEN),AL3(MSG8),AL1(MSG9LEN),AL3(MSG9)\n         DC    AL1(MSG10LEN),AL3(MSG10),AL1(MSG11LEN),AL3(MSG11)\n         DC    AL1(MSG12LEN),AL3(MSG12),AL1(MSG13LEN),AL3(MSG13)\n         DC    AL1(MSG14LEN),AL3(MSG14),AL1(MSG15LEN),AL3(MSG15)\n         DC    AL1(MSG16LEN),AL3(MSG16),AL1(MSG17LEN),AL3(MSG17)\n         DC    AL1(MSG18LEN),AL3(MSG18),AL1(MSG19LEN),AL3(MSG19)\n         DC    AL1(MSG20LEN),AL3(MSG20),AL1(MSG21LEN),AL3(MSG21)\n         DC    AL1(MSG22LEN),AL3(MSG22),AL1(MSG23LEN),AL3(MSG23)\n         DC    AL1(MSG24LEN),AL3(MSG24),AL1(MSG25LEN),AL3(MSG25)\n         DC    AL1(MSG26LEN),AL3(MSG26),AL1(MSG27LEN),AL3(MSG27)\n         DC    AL1(MSG28LEN),AL3(MSG28),AL1(MSG29LEN),AL3(MSG29)\n         DC    AL1(MSG30LEN),AL3(MSG30),AL1(MSG31LEN),AL3(MSG31)\n         DC    AL1(MSG32LEN),AL3(MSG32),AL1(MSG33LEN),AL3(MSG33)\n         DC    AL1(MSG34LEN),AL3(MSG34),AL1(MSG35LEN),AL3(MSG35)\n         DC    AL1(MSG36LEN),AL3(MSG36),AL1(MSG37LEN),AL3(MSG37)\n         DC    AL1(MSG38LEN),AL3(MSG38),AL1(MSG39LEN),AL3(MSG39)\n         DC    AL1(MSG40LEN),AL3(MSG40),AL1(MSG41LEN),AL3(MSG41)\n         DC    AL1(MSG42LEN),AL3(MSG42),AL1(MSG43LEN),AL3(MSG43)\n         DC    AL1(MSG44LEN),AL3(MSG44),AL1(MSG45LEN),AL3(MSG45)\n         DC    AL1(MSG46LEN),AL3(MSG46),AL1(MSG47LEN),AL3(MSG47)\n         DC    AL1(MSG48LEN),AL3(MSG48),AL1(MSG49LEN),AL3(MSG49)\n         DC    AL1(MSG50LEN),AL3(MSG50),AL1(MSG51LEN),AL3(MSG51)\n         DC    AL1(MSG52LEN),AL3(MSG52),AL1(MSG53LEN),AL3(MSG53)\n         DC    AL1(MSG54LEN),AL3(MSG54),AL1(MSG55LEN),AL3(MSG55)\n         DC    AL1(MSG56LEN),AL3(MSG56),AL1(MSG57LEN),AL3(MSG57)\n         DC    AL1(MSG58LEN),AL3(MSG58),AL1(MSG59LEN),AL3(MSG59)\n         DC    AL1(MSG60LEN),AL3(MSG60),AL1(MSG61LEN),AL3(MSG61)\n         DC    AL1(MSG62LEN),AL3(MSG62),AL1(MSG63LEN),AL3(MSG63)\n         DC    AL1(MSG64LEN),AL3(MSG64),AL1(MSG65LEN),AL3(MSG65)\n         DC    AL1(MSG66LEN),AL3(MSG66),AL1(MSG67LEN),AL3(MSG67)\n         DC    AL1(MSG68LEN),AL3(MSG68),AL1(MSG69LEN),AL3(MSG69)\n         DC    AL1(MSG70LEN),AL3(MSG70),AL1(MSG71LEN),AL3(MSG71)\n         DC    AL1(MSG72LEN),AL3(MSG72),AL1(MSG73LEN),AL3(MSG73)\n         DC    AL1(MSG74LEN),AL3(MSG74),AL1(MSG75LEN),AL3(MSG75)\n         DC    AL1(MSG76LEN),AL3(MSG76),AL1(MSG77LEN),AL3(MSG77)\n         DC    AL1(MSG78LEN),AL3(MSG78),AL1(MSG79LEN),AL3(MSG79)\n         DC    AL1(MSG80LEN),AL3(MSG80),AL1(MSG81LEN),AL3(MSG81)\n         DC    AL1(MSG82LEN),AL3(MSG82),AL1(MSG83LEN),AL3(MSG83)\n         DC    AL1(MSG84LEN),AL3(MSG84),AL1(MSG85LEN),AL3(MSG85)\n         DC    AL1(MSG86LEN),AL3(MSG86),AL1(MSG87LEN),AL3(MSG87)\n         DC    AL1(MSG88LEN),AL3(MSG88),AL1(MSG89LEN),AL3(MSG89)\n         DC    AL1(MSG90LEN),AL3(MSG90),AL1(MSG91LEN),AL3(MSG91)\n         DC    AL1(MSG92LEN),AL3(MSG92),AL1(MSG93LEN),AL3(MSG93)\n         DC    AL1(MSG94LEN),AL3(MSG94),AL1(MSG95LEN),AL3(MSG95)\n         DC    AL1(MSG96LEN),AL3(MSG96),AL1(MSG97LEN),AL3(MSG97)\n         DC    AL1(MSG98LEN),AL3(MSG98),AL1(MSG99LEN),AL3(MSG99)\n         SPACE 5\nMSGEDTBL DC    AL1(MSG0DLN,MSG1DLN,00000000,00000000,00000000) 00-04\n         DC    AL1(00000000,00000000,00000000,00000000,00000000) 05-09\n         DC    AL1(00000000,00000000,00000000,00000000,MSG14ELN) 10-14\n         DC    AL1(00000000,00000000,00000000,00000000,00000000) 15-19\n         DC    AL1(00000000,00000000,00000000,00000000,00000000) 20-24\n         DC    AL1(MSG25ELN,00000000,00000000,00000000,00000000) 25-29\n         DC    AL1(MSG30ELN,MSG31ELN,MSG32ELN,MSG33ELN,00000000) 30-34\n         DC    AL1(00000000,00000000,00000000,00000000,MSG39DLN) 35-39\n         DC    AL1(00000000,00000000,MSG42DLN,MSG43DLN,MSG44DLN) 40-44\n         DC    AL1(00000000,00000000,00000000,MSG48ELN,MSG49ELN) 45-49\n         DC    AL1(00000000,00000000,00000000,00000000,MSG54DLN) 50-54\n         DC    AL1(MSG55ELN,00000000,MSG57ELN,00000000,00000000) 55-59\n         DC    AL1(00000000,00000000,00000000,MSG63ELN,00000000) 60-64\n         DC    AL1(00000000,00000000,00000000,00000000,00000000) 65-69\n         DC    AL1(00000000,00000000,00000000,00000000,MSG74ELN) 70-74\n         DC    AL1(00000000,00000000,00000000,00000000,00000000) 75-79\n         DC    AL1(00000000,00000000,00000000,00000000,00000000) 80-84\n         DC    AL1(00000000,00000000,MSG87DLN,00000000,MSG89DLN) 85-89\n         DC    AL1(00000000,00000000,00000000,00000000,MSG94ELN) 90-94\n         DC    AL1(00000000,00000000,MSG97DLN,00000000,00000000) 95-99\n         TITLE 'MESSAGE LISTING'\nMSGNO    DC    C'0MESSAGE DOES NOT EXIST IN THIS CSECT'\nMSGNOLEN EQU   *-MSGNO\n         SPACE 1\nMSG0     DC    C'0SEL000I PARM = '\nMSG0DLN  EQU   *-MSG0\n         DC    CL100' '\nMSG0LEN  EQU   *-MSG0\n         SPACE 1\nMSG1     DC    C'0SEL001I CLASS TEST REQUESTED, OPTION(S)='\nMSG1DLN  EQU   *-MSG1\n         DC    CL6' '  INSERT A,H,L,N,P OR Z\n         DC    C' (A=ALPHABETIC,H=HIGH VALUES,L=LOW VALUES,N=NUMERIC,'\n         DC    C'P=PACKED,Z=ALPHANUMERIC)'\nMSG1LEN  EQU   *-MSG1\n         SPACE 1\nMSG2     DC    C'0SEL002E KEY ENTERED IS NOT (SIGNED) NUMERIC OR '\n         DC    C'EXCEEDS 15 CHARACTERS IN LENGTH ON '\n         DC    C'N=, P=, X= OR Y= KEYWORD PARAMETERS'\nMSG2LEN  EQU   *-MSG2\n         SPACE 1\nMSG3     DC    C'0SEL003E SYSIN FILE IS EMPTY (A,B,E,G,M,P,R,T OPT)'\n         DC    C' OR CONTAINS AN INSUFFICIENT NUMBER OF KEYS '\n         DC    C'(C,O OPTION)'\nMSG3LEN  EQU   *-MSG3\n         SPACE 1\nMSG4     DS    0C        KEY=XXX NNN RECORDS PASSED, MMM RECORDS OUTP\nMSG4LEN  EQU   *-MSG4\n         SPACE 1\nMSG5     DC    C'0SEL005I END OF INPUT FILE REACHED'\nMSG5LEN  EQU   *-MSG5\n         SPACE 1\nMSG6     DC    C'0SEL006I END OF SYSIN FILE BEFORE END OF INPUT FILE'\nMSG6LEN  EQU   *-MSG6\n         SPACE 1\nMSG7     DC    C'0SEL007I PARM FIELD OPTIONS MISSING- DEFAULT OPTION'\n         DC    C' R,1,1 ASSUMED'\nMSG7LEN  EQU   *-MSG7\n         SPACE 1\nMSG8     DC    C'0SEL008E ERROR IN EXITS CONTROL STATEMENT'\nMSG8LEN  EQU   *-MSG8\n         SPACE 1\nMSG9     DC    C'0SEL009E INVALID NUMBER OF LENGTH/POSITION (L,P) '\n         DC    C'PARAMETERS SPECIFIED'\n*        1 L,P FOR N=,P=,C=N,C=P,C=Z,G OPT,L SUBOPT\n*        2 L,P'S FOR B OPT, 3 L,P'S FOR C OPT,ETC.\nMSG9LEN  EQU   *-MSG9\n         SPACE 1\nMSG10    DC    C'0SEL010E INVALID PRIMARY OPTION OR SUBOPTION '\n         DC    C'SPECIFIED'\nMSG10LEN EQU   *-MSG10    A,B,C,D,E,F,G,K,M,O,P,Q,R,S,T  B,L,N,W\n         SPACE 1\nMSG11    DS   0C\nMSG11LEN EQU   *-MSG11\n         SPACE 1\nMSG12    DC    C'0SEL012E LENGTH PARAMETER EXCEEDS 15 ON G '\n         DC    C'OPTION OR N= PARAMETER OR EXCEEDS 8 ON P= OR X= '\n         DC    C'PARAMETER (S,D OPTION)'\nMSG12LEN EQU   *-MSG12\n         SPACE 1\nMSG13    DC    C'0SEL013E B= PARAMETER EXCEEDS E= PARAMETER'\nMSG13LEN EQU   *-MSG13\n         SPACE 1\nMSG14    DC    C'0SEL014I FIRST'\nMSG14ELN EQU   *-MSG14\n         DC    X'40202020202020212021'\n         DC    C' SEQUENCE ERRORS PRINTED,SEQUENCE CHECKING CONTINUES'\nMSG14LEN EQU   *-MSG14\n         SPACE 1\nMSG15    DC    C'0SEL015E KEY IN PARM FIELD IS NOT PRECEEDED BY A '\n         DC    C'C=,K=,N=,P= OR X= KEYWORD PARAMETER'\nMSG15LEN EQU   *-MSG15\n         SPACE 1\nMSG16    DC    C'0SEL016E LENGTH/POSITION/BEGIN/END/COUNT PARAMETER '\n         DC    C'EXCEEDS 8 DIGITS, IS NOT NUMERIC OR HAS 0 VALUE'\nMSG16LEN EQU   *-MSG16\n         SPACE 1\nMSG17    DC    C'0SEL017E Y= KEYWORD PARAMETER IS INVALID FOR THE '\n         DC    C'E OPTION AND THE L SUBOPTION'\nMSG17LEN EQU   *-MSG17\n         SPACE 1\nMSG18    DC    C'0SEL018E A LENGTH PARAMETER EXCEEDS 20(O,B,C) '\n         DC    C'OR THE SUM OF THE LENGTH PARMS EXCEEDS 20 '\n         DC    C'OR THE KEY IN PARM EXCEEDS 20 CHARS'\nMSG18LEN EQU   *-MSG18\n         SPACE 1\nMSG19    DC    C'0SEL019I FILE IS IN SEQUENCE'   Q MSG\nMSG19LEN EQU   *-MSG19\n         SPACE 1\nMSG20    DC    C'0SEL020E INVALID HEX CHAR USED- ONLY 0-9,A-F'\n         DC    C' ALLOWED OR NO. OF CHARS IS NOT EVEN '\n         DC    C'IN X= OR Y= KEYWORD PARAMETER OR IN CONVERT FILE'\nMSG20LEN EQU   *-MSG20\n         SPACE 1\nMSG21    DS    0C        KEY=XXX NUMBER OF RECORDS SELECTED=NNN\nMSG21LEN EQU   *-MSG21\n         SPACE 1\nMSG22    DC    C'0SEL022I FILE IS OUT OF SEQUENCE STARTING AT'\nMSG22LEN EQU   *-MSG22\n         SPACE 1\nMSG23    DS    0C     RECORD NUMBER=NNN KEY=XXX PREVIOUS KEY=YYYY\nMSG23LEN EQU   *-MSG23\n         SPACE 1\nMSG24    DC    C'0SEL024I KEY NOT FOUND ON DEBUG OPTION'\nMSG24LEN EQU   *-MSG24\n         SPACE 1\nMSG25    DC    C'0SEL025I TOTAL NUMBER OF RECORDS IN INPUT FILE = '\nMSG25ELN EQU   *-MSG25                   EDIT DISPLACEMENT\n         DC    X'40202020202020212021'\nMSG25LEN EQU   *-MSG25\n         SPACE 1\nMSG26    DS    0C  MMM RECORDS OUTPUT STARTING AT RECORD NNN. SKIP FACT\nMSG26LEN EQU   *-MSG26\n         SPACE 1\nMSG27    DC    C'0SEL027E PARM FIELD ENDS IN A COMMA OR '\n         DC    C'CONTAINS 2 CONSECUTIVE COMMAS OR A KEYWORD '\n         DC    C'PARAMETER IS MISSING'\nMSG27LEN EQU   *-MSG27\n         SPACE 1\nMSG28    DC    C'0SEL028E INVALID OPTION SPECIFIED FOR CLASS TEST'\n*        A,H,L,N,P,Z\nMSG28LEN EQU   *-MSG28\n         SPACE 1\nMSG29    DS    0C LOW KEY=XXX, HIGH KEY=YYY NNN RECORDS PASSED\nMSG29LEN EQU   *-MSG29\n         SPACE 1\nMSG30    DC    C'0SEL030I TOTAL NUMBER OF UNIQUE KEYS IN INPUT '\n         DC    C'FILE      ='\nMSG30ELN EQU   *-MSG30\n         DC    X'40202020202020212021'\nMSG30LEN EQU   *-MSG30\n         SPACE 1\nMSG31    DC    C'0SEL031I NUMBER OF KEY GROUPS WITH RECORDS '\n         DC    C'LESS THAN PARM COUNT='\nMSG31ELN EQU   *-MSG31\n         DC    X'40202020202020212021'\nMSG31LEN EQU   *-MSG31\n         SPACE 1\nMSG32    DC    C'0SEL032I NUMBER OF KEY GROUPS WITH RECORDS '\n         DC    C'GREATER THAN COUNT  ='\nMSG32ELN EQU   *-MSG32\n         DC    X'40202020202020212021'\nMSG32LEN EQU   *-MSG32\n         SPACE 1\nMSG33    DC    C'0SEL033I TOTAL NUMBER OF NON-SELECTED '\n         DC    C'INPUT RECS OUTPUT ='\nMSG33ELN EQU   *-MSG33\n         DC    X'40202020202020212021'\nMSG33LEN EQU   *-MSG33\n         SPACE 1\nMSG34    DS    0C KEY=XXX LOCATED IN RECORD KKK. RECORDS OUTPUT=MMM\nMSG34LEN EQU   *-MSG34\n         SPACE 1\nMSG35    DC    C'0SEL035E LENGTH+POSITION PARAMETERS EXCEED LRECL'\nMSG35LEN EQU   *-MSG35\n         SPACE 1\nMSG36    DS    0C NNN SYSIN RECORDS ALLOWED, MMM READ/GENERATED & USED\nMSG36LEN EQU   *-MSG36\n         SPACE 1\nMSG37    DC    C'0SEL037E SYSIN RECS ON G OPTION :1)NOT NUMERIC OR '\n         DC    C'2)ODD NO OF RECS OR 3)EVEN NUMBERED REC OF A PAIR IS '\n         DC    C'LESS THAN ODD NUMBERED REC'\nMSG37LEN EQU   *-MSG37\n         SPACE 1\nMSG38    DC    C'0SEL038E ON ''A'' OPTION, THE J= PARAMETER DID NOT'\n         DC    C' SPECIFY ANY OF THE FOLLOWING OPERATORS CORRECTLY- '\n         DC    C'EQ,NE,GE,GE,LT,LE'\nMSG38LEN EQU   *-MSG38\n         SPACE 1\nMSG39    DC    C'0SEL039W OUTPUT (SYSUT'\nMSG39DLN EQU   *-MSG39\n         DC    C'2'\n         DC    C') RECFM/BLKSIZE DOES NOT MATCH INPUT RECFM/BLKSIZE. '\n         DC    C'OUTPUT RECFM/BLKSIZE ACCEPTED AS WRITTEN.'\nMSG39LEN EQU   *-MSG39\n         SPACE 1\nMSG40    DS    0C           FILE ATTRIBUTES MSG\nMSG40LEN EQU   *-MSG40\n         SPACE 1\nMSG41    DC    C'0SEL041E INVALID RECFM'\nMSG41LEN EQU   *-MSG41\n         SPACE 1\nMSG42    DC    C'0SEL042W OUTPUT (SYSUT'\nMSG42DLN EQU  *-MSG42\n         DC   C'2'\n         DC   C') DCB PARAMETERS ABSENT OR REC TYPE/LRECL DOESNT MATCH'\n         DC   C' INPUT REC TYPE/LRECL.INPUT RECFM/LRECL/BLKSIZE USED.'\nMSG42LEN EQU  *-MSG42\n         SPACE 1\nMSG43    DC   C'0SEL043W OUTPUT (SYSUT'\nMSG43DLN EQU  *-MSG43\n         DC   C'2'\n         DC   C') BLKSIZE NOT INTEGRAL MULTIPLE OF INPUT LRECL(RECFM=F'\n         DC   C'B) OR BLKSIZE NOT AT LEAST 4 MORE THAN LRECL(RECFM=V) '\nMSG43LEN EQU  *-MSG43\n         SPACE 1\nMSG44    DC   C'         OR BLKSIZE NOT EQUAL TO INPUT LRECL(RECFM='\n         DC   C'U OR F UNBLOCKED). OUTPUT BLKSIZE CHANGED TO INPUT '\nMSG44DLN EQU  *-MSG44\n         DC   C'BLKSIZE'\nMSG44LEN EQU  *-MSG44\n         SPACE 1\nMSG45    DC    C'0SEL045E PRIMARY INPUT FILE '\n         DC   C'OR (V)SYSIN DD STATEMENT MISSING'\nMSG45LEN EQU  *-MSG45\n         SPACE 1\nMSG46    DC   C'0SEL046E W SUBOPTION REQUESTED BUT INPUT DATA SET '\n         DC   C'NOT ON TAPE OR VSAM'\nMSG46LEN EQU  *-MSG46\n         SPACE 1\nMSG47    DS   0C\nMSG47LEN EQU  *-MSG47\n         SPACE 1\nMSG48    DC    C'0SEL048I TOTAL NUMBER OF SELECTED SYSIN'\n         DC    C' RECORDS OUTPUT  ='\nMSG48ELN EQU   *-MSG48\n         DC    X'40202020202020212021'\nMSG48LEN EQU   *-MSG48\n         SPACE 1\nMSG49    DC    C'0SEL049I TOTAL NUMBER OF NON-SELECTED SYSIN'\n         DC    C' RECS OUTPUT ='\nMSG49ELN EQU   *-MSG49\n         DC    X'40202020202020212021'\nMSG49LEN EQU   *-MSG49\n         SPACE 1\nMSG50    DC   C'0SEL050E V= PARAMETER VALID ONLY ON M OR T '\n         DC   C'OPTIONS AND MUST BE CODED ON ''A'' AND ''ML'' OPTION'\nMSG50LEN EQU  *-MSG50\n         SPACE 1\nMSG51    DC   C'0SEL051E SYNTAX ERROR DETECTED IN THE V= PARM'\nMSG51LEN EQU  *-MSG51\n         SPACE 1\nMSG52    DC   C'0SEL052W ONE OR MORE UNSUCCESSFUL ATTEMPTS TO STORE '\n         DC   C'A RECORD/MEMBER INTO VSAMOUT/LIBOUT FILE WITH A'\n         DC   C' DUPLICATE KEY/MEMBER NAME'\nMSG52LEN EQU  *-MSG52\n         SPACE 1\nMSG53    DC   C'0SEL053E KEY LENGTHS FOR THE MASTER AND '\n         DC   C'SYSIN FILES DO NOT MATCH'\nMSG53LEN EQU  *-MSG53\n         SPACE 1\nMSG54    DC   C'0SEL054I JOBNAME/PROCSTEPNAME/STEPNAME= '\nMSG54DLN EQU  *-MSG54\n         DS   CL24\nMSG54LEN EQU  *-MSG54\n         SPACE 1\nMSG55    DC   C'0SEL055I SELECTION PROCESSING WILL'\n         DC   C' BEGIN AFTER RECORD '\nMSG55ELN EQU  *-MSG55\n         DC   X'40202020202020212021'\nMSG55LEN EQU  *-MSG55\n         SPACE 1\nMSG56    DS   0C\nMSG56LEN EQU  *-MSG56\n         SPACE 1\nMSG57    DC   C'0SEL057I RANDOM RECORD SELECT OR ENCRYPTION OPTION, '\n         DC   C'SEED='\nMSG57ELN EQU  *-MSG57\n         DC   X'40202020202020212021'\nMSG57LEN EQU  *-MSG57\n         SPACE 1\nMSG58    DS  0C\nMSG58LEN EQU  *-MSG58\n         SPACE 1\nMSG59    DS  0C\nMSG59LEN EQU  *-MSG59\n         SPACE 1\nMSG60    DC   C'0SEL060I R ERROR MEANS SYSIN REC '\n         DC   C'EXCEEDS 15 DIGITS,NUMBER NOT FOLLOWED BY SPACE, '\n         DC   C'NOT NUMERIC,OUT OF SEQUENCE, OR BELOW SELECT RANGE'\nMSG60LEN EQU  *-MSG60\n         SPACE 1\nMSG61    DS   0C\nMSG61LEN EQU  *-MSG61\n         SPACE 1\nMSG62    DS    0C         R OPTION KEY AND ACTION\nMSG62LEN EQU   *-MSG62\n         SPACE 1\nMSG63    DC   C'0SEL063E VSAM ERROR, FDBK CODE='\nMSG63ELN EQU  *-MSG63\n         DC   X'40202020202020212021'   VSAM FDBK CODE\nMSG63LEN EQU  *-MSG63\n         SPACE 1\nMSG64    DC   C'0SEL064E PROGRAM ERROR- CALL HFSELECT VENDOR '\n         DC   C'FOR PROGRAMMING SUPPORT'\nMSG64LEN EQU  *-MSG64\n         SPACE 1\nMSG65    DS   0C\nMSG65LEN EQU   *-MSG65\n         SPACE 1\nMSG66    DS  0C\nMSG66LEN EQU  *-MSG66\n         SPACE 1\nMSG67    DS  0C\nMSG67LEN EQU  *-MSG67\n         SPACE 1\nMSG68    DC   C'0SEL068E SYSUT1 OR SYSIN DD STATEMENT SPECIFIES '\n         DC   C'AN INCORRECT DSN OR VOLSER, OR DISK I/O ERROR'\nMSG68LEN EQU  *-MSG68\n         SPACE 1\nMSG69    DC   C'0SEL069E IF COMPLETION CODE=80A OR 106-C, '\n         DC   C'INSUFFICIENT MAIN STORAGE WAS REQEUESTED IN REGION '\n         DC   C'PARAMETER ON EXEC CARD'\nMSG69LEN EQU  *-MSG69\n         SPACE 1\nMSG70    DC   C'0SEL070E ON E OPTION- COLUMN SPECIFICATIONS '\n         DC   C'EXCEED LRECL OR ARE NOT IN ASCENDING ORDER'\nMSG70LEN EQU  *-MSG70\n         SPACE 1\nMSG71    DC    C'0SEL071E KEYWORD ERROR- INVALID OR '\n         DC    C'DUPLICATE KEYWORD SPECIFICATION'\nMSG71LEN EQU   *-MSG71\n         SPACE 1\nMSG72    DC    C'0SEL072I IGNORE HASP MESSAGE IEC146I 513-04 '\n         DC    C'(IF PRESENT), PROGRAM CONTINUES TO NORMAL '\n         DC    C'END OF JOB'\nMSG72LEN EQU   *-MSG72\n         SPACE 1\nMSG73    DC   C'0SEL073E IF COMPLETION CODE=B37-E37 INSUFFICIENT '\n         DC   C'SPACE WAS ALLOCATED/AVAILABLE TO AN '\n         DC   C'OUTPUT DISK DATA SET'\nMSG73LEN EQU  *-MSG73\n         SPACE 1\nMSG74    DC   C'1SEL074I (C) COPYRIGHT SEPT 1981 BY M. KARLIN, '\n         DC   C'N. LINDNER, I. EISENSTEIN     TODAY''S DATE'\nMSG74ELN EQU  *-MSG74\nMSG74ED  DC   X'40404040402120202020'\n         DC   C' HFSELECT RELEASE 4.3 '                 @MK1\n         GETDATE DATE\nMSG74LEN EQU  *-MSG74\n         SPACE 1\nMSG75    DC    C'0SEL075E ERROR DUE TO AN ABEND IN A PREVIOUS'\n         DC    C' JOB STEP OR NO VOLSER SPECIFIED'\nMSG75LEN EQU   *-MSG75\n         SPACE 1\nMSG76    DS    0C                USED FOR SYNADERR MSG ON SYSOUT\nMSG76LEN EQU   *-MSG76\n         SPACE 1\nMSG77    DC   C'0SEL077E SYSOUT DD MISSING OR'\n         DC   C' AN UNCORRECTABLE I/O ERROR WAS '\n         DC   C'ENCOUNTERED. UP TO 5 BAD BLOCKS WILL BE PRINTED.'\nMSG77LEN EQU   *-MSG77\n         SPACE 1\nMSG78    DS    0C         MSG 78 AND 79 ARE USED FOR RANDOM MSGS\nMSG78LEN EQU   *-MSG78\nMSG79    DS    0C         RANDOM MSG IN MAIN MODULE\nMSG79LEN EQU   *-MSG79\n         SPACE 1\nMSG80    DC    C'0SEL080I END OF PRIMARY INPUT AND SYSIN FILES '\n         DC    C'REACHED'\nMSG80LEN EQU   *-MSG80\n         SPACE 1\nMSG81    DC    C'0SEL081I SELECTION ENDED DUE TO E= PARAMETER'\nMSG81LEN EQU   *-MSG81\n         SPACE 1\nMSG82    DC    C'0SEL082I COUNT SATISFIED BEFORE END OF PRIMARY INPUT'\n         DC    C' FILE'\nMSG82LEN EQU   *-MSG82\n         SPACE 1\nMSG83    DC    C'0'      TO PRINT BLANK MSG\nMSG83LEN EQU   *-MSG83\n         SPACE 1\nMSG84    DS    0C\nMSG84LEN EQU   *-MSG84\nMSG85    DS    0C        OUTPUT FILE ATTRIBUTES\nMSG85LEN EQU   *-MSG85\n         SPACE 1\nMSG86    DS    0C\nMSG86LEN EQU   *-MSG86\n         SPACE 1\nMSG87    DC    C' SEL087I CONVERT KEY = '\nMSG87DLN EQU   *-MSG87\n         DS    CL20\nMSG87LEN EQU   *-MSG87\n         SPACE 1\nMSG88    DS    0C              E OPT $ AND @ MSG\nMSG88LEN EQU   *-MSG88\n         SPACE 1\nMSG89    DC    C'0SEL089E LIBOUT OR LIBFILE DIRECTORY ERROR, MEMBER='\nMSG89DLN EQU   *-MSG89\n         DS    CL8\nMSG89LEN EQU   *-MSG89\n         SPACE 1\nMSG90    DS    0C\nMSG90LEN EQU   *-MSG90\nMSG91    DS    0C\nMSG91LEN EQU   *-MSG91\n         SPACE 1\nMSG92    DS    0C\nMSG92LEN EQU   *-MSG92\n         SPACE 1\nMSG93    DS    0C        MEMBER=XXXX, NUMBER OF SELECTED RECORDS=NNN\nMSG93LEN EQU   *-MSG93\n         SPACE 1\nMSG94    DC    C'0SEL094I TOTAL NUMBER OF MEMBERS ADDED/REPLACED ='\nMSG94ELN EQU   *-MSG94\n         DC    X'40202020202020212021'\nMSG94LEN EQU   *-MSG94\n         SPACE 1\nMSG95    DC    C'0SEL095E SYSOUT NOT ALLOWED FOR LIBOUT OR VSAMOUT '\n         DC    C'FILE'\nMSG95LEN EQU   *-MSG95\n         SPACE 1\nMSG96    DC    C'0SEL096E INVALID VSYSIN KEY ON V OPTION'\nMSG96LEN EQU   *-MSG96\n         SPACE 1\nMSG97    DC    C'0SEL097I '      V OPTION KEYS\nMSG97DLN EQU   *-MSG97\n         DS    CL80\nMSG97LEN EQU   *-MSG97\n         SPACE 1\nMSG98    DC    C'0SEL098E INTERNAL CVAF, CATALOG OR PDS DYNALLOC ERROR'\nMSG98LEN EQU   *-MSG98\n         SPACE 1\nMSG99    DS    0C\nMSG99LEN EQU   *-MSG99\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MK11": {"ttr": 9732, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x93\\x05O\\x00\\x93\\x05O\\x148\\x00P\\x00)\\x00+\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-02-23T00:00:00", "modifydate": "1993-02-23T14:38:00", "lines": 80, "newlines": 41, "modlines": 43, "user": "CN03MQK"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "PDSLOAD": {"ttr": 9735, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x156\\x00e\\x00e\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:36:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "READEXCP": {"ttr": 9738, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x90\\x16?\\x00\\x900_\\x111\\x01\\x1a\\x01\\x0e\\x00J\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1990-06-12T00:00:00", "modifydate": "1990-11-01T11:31:00", "lines": 282, "newlines": 270, "modlines": 74, "user": "CN03MQK"}, "text": "         TITLE 'SUPER FAST READ'\n*****   CODE FOR DIFFERENT RECFM F,V,U (VBS??)\n*****   DECIDE WHAT KIND OF DEVICE DASD, TAPE, UNIT RECORD\n*  REGS  R0=PASSES RELATIVE TRACK ADDRESS TO CONVERT RTN IN FORM TTRN\n*           & PASSES THE PARAMETER XXKR TO SECTOR CALC RTN\n*        R1=UPON ENTRY CONTAINS DCB ADDRESS OF FILE TO BE READ\n*        R1=PASSES ADDRESS OF DEB TO CONVERT RTN (ALSO WORK REG)\n*        R2=PASS ADDRESS OF IOB AREA (ECB+36) TO GET ABSOLUTE TRK ADDR\n*           & SECTOR PARM (UCB TYPE & ADDR OF SECTOR VALUE)\n*        R3=BASE REGISTER\n*        R4=DCB ADDR\n*        R5=..........\n*        R6=..........\n*        R7=..........\n*        R8=.........\n*        R9=RELATIVE TRACK COUNTER (RESET TO 0 AT EOV)\n*       R10=REMAINING NUMBER OF BYTES IN BLOCK INDICATOR\n*        R11=BUFFER POINTER IN BUFAREA (BUFFER IS SEARCHED BACKWARD)\n*        R12=BLOCK COUNTER ON TRACK (SET FROM TRKCALC MACRO)\n*        R13=UNUSED (EXCEPT BY ABS ADDR CNVRT RTN)\n*        R14=RETURN FROM CONVERT RTN, R15=ADDR OF CONVERT RTN & RC\n         PRINT NOGEN\nREADEXCP START 0\n         USING *,R15\n         STM   R14,R12,12(R13)      SAVE CALLERS REGS\n         ST    R13,SAVEAREA+4\n         CNOP  0,4\n         BAL   R3,JUMPSAVE\nSAVEAREA DS    18F\nJUMPSAVE ST    R3,8(R13)\n         LR    R13,R3       LOAD SAVEAREA ADDR INTO R13\n         USING SAVEAREA,R3  ESTABLISH R3 AS BASE REGS\n         DROP  R15\n         SPACE 1\n         LM    R10,R11,SAVEINFO    RESTORE BUFFER PTR AND LENGTH\nSETUP    NOP   PTNXTREC        SET TO BR -TO GET NEXT RECORD\n         MVI   SETUP+1,X'F0'   SET TO BRANCH AFTER FIRST TIME\n         LR    R4,R1        SAVE DCB ADDR PASSED FROM CALLING PGM\n         USING IHADCB,R4\n         LH    R0,DCBBLKSI LOAD BLKSIZE INTO R0 FOR STORAGE FOR BUFFR\n         STH   R0,BLKSIZE  MOVE BLKSIZE INTO BLKSIZE OF XXKR\n         TM    DCBRECFM,X'80'    IS RECFM=F\n         BNO   RC4               NO\n         L     R1,16   GET ADDR OF CVT (COMMUN VECTOR TABL) AT LOC 16\n         L     R1,28(R1)  GET ADDR OF CVTPCNVT AT DISPLAC 28\n         ST    R1,CNVRTRTN  TO CONVERT RELATIVE ADDRESSES TO ABSOLUTE\n         L     R1,44(R4)      GET DEB ADDR AT OFFSET 44 OF DCB\n         L     R1,32(R1)  GET UCB ADDR OF DATA SET AT OFFSET 32 IN DEB\n         CLI   18(R1),X'20'   IS IT A DASD DEVICE\n         BNE   RC4                NO - RETURN\n         MVC   UCBTYPE(1),19(R1)  GET UCB DEVICE TYPE FOR SECTOR CNVRT\n         TM    17(R1),X'10'  IS RPS VALID FOR DEVICE-BIT 3 AT OFFSET 17\n         BNO   SKPRPS  NO -DONT TAKE DEFAULT XDAP WITH SECTOR OPTION\n         L     R1,16   GET ADDR OF CVT (COMMUN VECTOR TABL) AT LOC 16\n         L     R15,232(R1) GET ADDR OF CVT0SCR1 AT DISPL 232\n         L     R2,SECTPARM LOAD UCB TYPE AND ADDR OF SECTOR VALUE RETRN\n         L     R0,XXKR  LOAD BLKSIZE AND RECORD NUMBER IN FORM XXKR\n         BALR  R14,R15    EXECUTE SECTOR CONVERT RTN\n         B     TRKCALC\n         SPACE 1\nSKPRPS   MVI   ECB+44,X'03' CHNG SET SECTOR CCW TO NOP CONTROL CCW\n         OI    ECB+48,X'20' SET SLI FLAG FOR NOP OPERATION\nTRKCALC  TRKCALC FUNCTN=TRKCAP,TYPE=UCBTYPE,R=1,K=0,DD=BLKSIZE,        X\n               REGSAVE=YES\n*        COMPUTE THE MAXIMUM NUMBER OF RECORDS (BLOCKS) ON A TRACK\n         LTR   R15,R15   SUCESSFUL COMPLETION\n         BNZ   BLKERR\n         ST    R0,NUMREC  R0 IS RETURNED WITH MAX NUMBER OF RECS\n         ST    R0,BLKPRCYL IF DOING TRK READ - #BLKS/TRK\n         RDJFCB ((R4))      R4=DCB ADDR\n         CLI   JFCBSPTN,X'00'  WAS DATASET ALLOCATED AS SPLIT CYL\n         BNE   TRKREAD               YES - BYPASS CYL READ\n         CLC   JFCBSBNM(3),=X'000000'  IS THIS A SUBALLOCATED DS\n         BNE   TRKREAD      YES- BYPASS CYL READ\n         TM    JFCBCTRI,JFCBCYL   WAS DS ALLOCATED IN CYL\n         BNO   TRKREAD      NO - BYPASS CYL READ\n         DEVTYPE DEVDDNAM,DEVAREA,DEVTAB  GET NUMB OF TRKS/CYL & DEVTYP\n         L     R1,NUMREC    PUT #BLKS/TRKS IN R1\n         MH    R1,TRKPRCYL  MULTIPLY TO GET #BLKS/CYL\n         ST    R1,BLKPRCYL\nTRKREAD  CLOSE ((R4))       CLOSE FILE AS MACRF=G\n         OPEN  (SYSUT1)     OPEN FILE AS  MACRF=E\n         L     R1,BLKPRCYL  PUT #BLKS/CYL(TRK) IN R1\n         MH    R1,BLKSIZE   MULTIPLY TO GET #BYTES/CYL(TRK)\n         LR    R0,R1\n         ST    R0,CYLSIZE\n         ST    R0,FREBUFSZ  SAVE FOR FREEMAIN\n         GETMAIN R,LV=(0)   GET BUFFER FOR FULL CYLINDER READ\n         ST    R1,BUFADDR   PUT ADDR OF OBTAINED BUFFER IN BUFADDR\n         L     R1,BLKPRCYL  GET SPACE FOR DISK CCW\n         LA    R1,3(R1)     BUT NEED AN ADDITIONAL 3 CCW'S\n         SLA   R1,3         MULTIPLY BY 8\n         LR    R0,R1\n         ST    R0,FRECCWSZ\n         GETMAIN R,LV=(0)\n         ST    R1,ECB+20     MOVE ADDR OF 1ST CCW INTO DISK IOB\n         MVC   0(24,R1),ECB+44  MOVE 1ST 3 XDAP CCW'S INTO DISK CCWAREA\n         LA    R2,8(R1)  LOAD ADDR OF 2ND CCW IN R2\n         STCM  R2,7,17(R1)  AND STORE IN THE THIRD CCW WHICH IS A TIC\n         LA    R1,24(R1)    POINT 3 CCW'S BEYOND IN DISK CCW AREA\n*        SET UP LOOP TO FILL CCW'S\n         ST    R1,DSKCCWAD  STORE NEW DISK CCW ADDRESS\n         LR    R7,R1        PUT DISK CCW ADDR IN R7\n         L     R2,BUFADDR\n         L     R5,BLKPRCYL\n         LH    R6,BLKSIZE\nLOOP     ST    R2,0(R7)     PUT BUFFER ADDR IN CCW FOR DISK\n         MVI   0(R7),X'8E'  PUT IN OPCODE FOR DISK READ-MULTI-TRACK\n         MVI   4(R7),X'40'  SET COMMAND CHAIN FLAG FOR DISK (BIT 33)\n         STH   R6,6(R7)     SET LENGTH OF BLOCK FOR DISK\n         LA    R2,0(R6,R2)  SET BUFFER ADDR TO NEXT BLOCK\n         LA    R7,8(R7)     POINT TO NEXT DISK CCW\n         BCT   R5,LOOP      LOOP UNTIL EVERY CCW FOR ALL BLOCKS\n*        IN THE CYL ARE SET\n         S     R7,=F'8'  POINT BACK TO LAST CCW\n         MVI   4(R7),X'00'  TURN OFF CHAIN COMMAND FOR DISK\n*        SET REGISTERS FOR THE REST OF THE PROGRAM\n         LA    R9,0    TRACK COUNTER\n         LH    R1,JFCLRECL  GET MAX LRECL FROM JFCB\n         LTR   R1,R1       IS LRECL=0 (RECFM=U)\n         BNZ   SAVLRECL     NO\n         LH    R1,BLKSIZE  YES - USE BLKSIZE AS LRECL\nSAVLRECL ST    R1,RECLEN      SAVE MAX LRECL IN RECLEN\n*        TM    JFCRECFM,X'40'   IS RECFM=V\n*        BNO   RD1                 NO\n*        MVI   RECFMV1+1,SETNOP    YES\n*        MVI   RECFMV2+1,SETNOP\nRD1      L     R1,SYSUT1+44  PLACE DEB ADDRESS IN R1\n         LA    R2,ECB+36 HAVE ABS ADDR (MBBCCHHR) PUT IN IOB OF XDAP\n         L     R0,TTRN    LOAD R0 WITH TTRN\n         STM   R9,R13,SAVEREGS   SAVE R9 THRU R13 (USED IN CONVERT RTN)\n         L     R15,CNVRTRTN      LOAD ADDR OF CONVERT RTN INTO R15\n         BALR  R14,R15    BRANCH TO CONVERT RTN WITH RETURN ADDR IN R14\n         LM    R9,R13,SAVEREGS RESTOR R9 THRU R13\n         LTR   R15,R15   IS ABSOLUTE ADDR OUTSIDE THE DS EXTENTS\n         BNZ   EOVRTN    YES - DO THE END-OF-VOLUME ROUTINE\n*\n         XDAP  ECB,,,,,,,,MF=E  EXECUTE CHANNEL PGM SET UP BY LIST XDAP\n*        ALL PARAMETERS MUST BE SUPPLIED INTO LIST PRIOR TO EXECUTE\n         WAIT  ECB=ECB\n         CLI   ECB,X'7F'   WERE THERE ANY ERROR ON THE EXCP\n         BE    SETBUFPT  NO- CONTINUE PROC\n         CLI   ECB,X'42'  WAS EOE CONDITION ENCOUNTERED\n         BNE   BLKERR    NO - ERROR\n         L     R1,ECB+12 YES-GET CURRENT CCW ADDR FROM DISK CSW(IOB+8)\n         S     R1,DSKCCWAD  GET LENGTH OF CCWS ALREADY EXECUTED\n         SRA   R1,3   DIVIDE BY 8 TO GET NUMBER OF CCWS\n         ST    R1,BLKPRCYL   ADJUST BLKPRCYL FOR LAST ADD TO #BLKS\n         MH    R1,BLKSIZE    GET NEW LENGTH OF BUFFER\n         SH    R1,ECB+18 <=SUBTRACT RESIDUAL LENGTH IN CSW(IOB ADDR+14)\n         ST    R1,CYLSIZE    ADJUST CYLSIZE FOR LAST SEARCH THRU BUFFER\n*\nSETBUFPT L     R10,CYLSIZE    LOAD LENGTH OF BUFFER\n         L     R11,BUFADDR    LOAD BUFFER ADDR INTO R11\n         SPACE 1\nPTNXTREC S     R10,RECLEN\n         BM    NXTREAD     R10 IS NEGATIVE, THE BUFFR HAS BEEN EXHAUSTD\n         LR    R1,R11           PUT RECORD ADDR IN R1 FOR CALLING PGM\n         A     R11,RECLEN       SET PTR UP TO NEXT RECORD\n         STM   R10,R11,SAVEINFO    RESTORE BUFFER PTR AND LENGTH\n         B     QUIT          RETURN TO PROCESS REC\n         SPACE 2\nNXTREAD  AH    R9,TRKPRCYL  ADD 1 TO RELATIVE TRACK NUMBER\n         STH   R9,TT        STORE RELATIVE TRACK NUMBER IN TT\n         B     RD1          RETURN TO RD1\nRC4      MVI   SETRC+3,X'04'    SET RC=4  DO NOT RETURN\n         B     QUIT\nRC8      MVI   SETRC+3,X'08'    SET RC=8  EODAD\n         CLOSE (SYSUT1)\n         L     R0,FREBUFSZ\n         FREEMAIN R,LV=(0),A=BUFADDR  FREE BUFFERS\n         L     R0,FRECCWSZ\n         FREEMAIN R,LV=(0),A=ECB+20    FREE CCW CHAIN\nQUIT     L     R13,SAVEAREA+4\n         LM    R14,R0,12(R13)   RESTORE R14-R0\n         LM    R2,R12,28(R13)   RESTORE R2-R12  DO NOT RESTORE R1\nSETRC    LA    R15,0            0=SUCCESSFUL RETURN CODE\n         BR    R14\n         SPACE 1\nBLKERR   ABEND 99,DUMP,STEP GET DUMP TO SEE WHATS WRONG & RTN TO SYSTEM\n         SPACE 5\nEOVRTN   EOV   SYSUT1    DO VOLUME SWITCHING OR GO TO EODAD\n         LA    R9,0      RESET RELATIVE TRACK COUNTER\n         STH   R9,TT\n         B     RD1\n         SPACE 5\nEXLSTRTN DS    0F      EXLST ROUTINE ADDRESS\n         DC    X'87',AL3(INFMJFCB)    DEFINE JFCB EXIT\nXXKR     DS    0F   FULLWORD LOADED INTO R0 FOR SECTOR CONVERT RTN\nBLKSIZE  DC    H'0'     BLKSIZE\n         DC    X'00'       BINARY 0\n         DC    X'01'  RELATIVE BLOCK NUMBER ON TRACK\n*\nTTRN     DS    0F   FULLWORD LOADED INTO R0 FOR ABSOLUTE TRK CONV RTN\nTT       DC    H'0'  RELATIVE TRK NUMBER\n         DC    X'01'  RELATIVE BLOCK NUMBER ON TRACK\n         DC    X'00'\n*\nSECTPARM DS    0F    FULL WORD LOADED INTO R2 FOR SECTOR CONVERSION\nUCBTYPE  DS    X     UCB DEVICE TYPE\n         DC    AL3(SECTVAL)   ADDRESS OF SECTOR VALUE\n*\nDVCTYPE  DS    2F              USE FOR DEVTYPE MACRO FRO DEVICE TYPE\nDEVDDNAM DC    CL8'SYSUT1  '   USE FOR DEVTYPE MACRO TO #TRKS/CYL\nDEVAREA  DS    2F,H\nTRKPRCYL DC    H'1'  INITIAL TO 1 FOR TRK READ\n         DS    2F\n*\nRECLEN   DS    H        SAVE THE LRECL\nNUMREC   DS    F    TRKCALC RETURNS THE MAX NUMBER OF BLOCKS HERE\nCNVRTRTN DS    F     CONVERT ROUTINE ADDRESS FOR ABSOLUTE TRACK ADDR\nSAVEREGS DS    5F  SAVE AREA FOR REGISTERS R9-R13\nSAVEINFO DS    2F  SAVE AREA FOR REGS R10,R11-BUFFER LEN AND ADDR\nDSKCCWAD DS    F   ADDR OF 1STT CCW FOR DISK\nBUFADDR  DS    F   ADDR OF DATA BUFFER\nBLKPRCYL DS    F   SET TO #BLKS/TRK FOR TRK READS\nCYLSIZE  DS    F   NUMBER OF BYTES IN A CYLINDER\nFREBUFSZ DS    F   BUF SIZE FOR FREEMAIN\nFRECCWSZ DS    F   CCW CHAIN AREA SIZE FOR FREEMAIN\nSECTVAL  DS    X     SECTOR VALUE PLACED HERE BY SECTOR CALC ROUT\n         LTORG\n         SPACE 2\nSYSUT1   DCB   DSORG=PS,MACRF=(E),DDNAME=SYSUT1,EODAD=RC8,DEVD=DA,     X\n               EXLST=EXLSTRTN\n         SPACE 1\n         IEFJFCBN     JFCB AREA\n         SPACE 1\n         PRINT GEN\n*        THE FOLLOWING XDAP LIST MACRO GENERATES AN ECB (4 BYTES), AN\n*        IOB (40 BYTES) AND A CHANNEL PROGRAM (4 CCW'S OF 8 BYTES EA)\n*        TO READ ONE BLOCK FROM DISK. THE PARAMETERS SPECIFIED ARE:\n*    1.  ECB- AN ECB SYMBOL WHICH GENERATES 'ECB' AS THE ECB LABEL\n*    2.  RI - THE READ IDENTIFY FUNCTION (READ NOT BY KEY) FOR CCW OPCD\n*    3.  SYSUT1 - THE INPUT DATA SET DCB PLACED IN IOB\n*    4.  BUFAREA- A DUMMY AREA CONTAINING THE INPUT BUFFER ADDRESS\n*                 WHICH MUST BE SUPPLIED BY A GETMAIN MACRO TO THE LIST\n*                 AND IS PLACED INTO THE 4TH CCW\n*    5.  BUFLEN - A DUMMY QUANTITY SPECIFYING THE BUFFER LENGT SET TO 0\n*                 WHICH MUST BE OBTAINED FROM THE DCBBLKSI FIELD OF\n*                 THE DCB AND IS PLACED INTO THE 4TH CCW\n*    6.  ECB+36 - THE AREA IN THE LIST INTO WHICH THE ABSOLUTE SEEK\n*                ADDRESS (MBBCCHHR) IS PLACED (IN THE IOB) BY CNVRT RTN\n*    7.  SECTVAL- THE ADDRESS OF THE SECTOR VALUE FOR RPS DEVICES\n*                 WHICH IS PLACED INTO THE 1ST CCW\n         XDAP  ECB,RI,SYSUT1,BUFAREA,0,,ECB+36,SECTVAL,MF=L\nBUFAREA  DS    X   A DUMMY AREA WHOSE ADDR IS USED IN ABOVE XDAP\n         SPACE 1\n         PRINT NOGEN\n         DCBD  DSORG=(PS,XE)    GET DCB MAPPING MACRO\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\nRECFMV1  B     COMPREC      CHANGED TO NOP IF RECFM=V\n         LH    R5,0(R11)    GET BLKSIZE FROM BLOCK DISCRIPTOR WORD\n         SH    R5,=H'4'     SUBTRACT 4 FROM BLKSIZE FOR THE BDW\n         LA    R11,4(R11)   POINT TO RECORD DISCRIPTOR WORD\n         MVC   RECLEN,0(R11)    STORE LRECL IN RECLEN\n         B     PROCESSRTN\nCOMPREC  LH    R5,CYLSIZE LOAD INPUT CYL(BLK?) LENG WHEN RECFM=F OR U\n         SH    R5,IOB+14 <=?SUBTRACT RESIDUAL LENGTH(IOB ADDR+14)\n         B     PROCESSRTN\n         SPACE 2\nBLKED    SH    R5,RECLEN    SUBTRACT LOG. REC FROM BLKSIZE\n         BNP   RDPDS IF 0 (OR NEGATIVE FOR RECFM=U), READ NEXT BLOCK\n         AH    R11,RECLEN        LOAD ADDR OF NEXT LOGICAL REC\nRECFMV2  B     RETURN3       CHANGED TO NOP IF RECFM=V\n         MVC   RECLEN,0(R11)     STORE THE LRECL FROM THE RDW IN RECLEN\n         B     RETURN3\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "READVTC": {"ttr": 9985, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x89\\t?\\x00\\x93\\x05O\\x10\\x08\\x02#\\x02\"\\x02#\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1989-04-03T00:00:00", "modifydate": "1993-02-23T10:08:00", "lines": 547, "newlines": 546, "modlines": 547, "user": "CN03MQK"}, "text": "*   SEE  ASM(READVTC) - CONTAINS TSO UPDATE NUMBERS IN COL 72-80\n*   READ  VTOCS\n*        RETURN CODES:\n*          00 - DSCB READ AND MOVED TO CALLERS WORKAREA\n*          04 - ALL VOLUMES PROCESSED, NO DATA RETURNED\n*          08 - CVAFTST MACRO FAILED\n*          16 - CVAFSEQ OR CVAFDIR FAILED\n*\n*        REGISTER USAGE:\n*          R1 - PARM\n*          R2 - UCBOB\n*          R3 - UCB ADDR\n*          R4 - MASK\n*          R5 - TARGET\n*          R15- LTR\n*\n*        INPUT REQUIREMENTS:\n*           1. 40-BYTE MASK - USED BY FINDUCB\n*              SEE RVPARM MACRO\n*           2. TARGET AREA - INFO TO USER; SEE RVDATA MACRO (156 BYTES)\n*              DSCB, VOLSER, CCHHR OF DSCB, IXVTOC FLAG, UCB ADDR\n*           3. INITAL DSN  - FOR INDEXED VTOCS THE DSN AT WHICH THE\n*              SEARCH OF THE VTOC SHOULD BEGIN.\n*\n         MACRO\n&NAME    FINDUCB &UCB,&WA,&MASK,&PENDOFF=NOSKIP,&PENDMNT=NOSKIP,       X\n               &VOLZERO=NOSKIP,&VIRTVOL=NOSKIP\n.*\n.*       RESTRICTIONS: YOU MUST 'DROP' ANY USING FOR BOTH 'UCBOB' AND\n.*            'CVTMAP' BEFORE ENTERING THIS MACRO.\n.*\n.*       REGISTER USAGE:\n.*            R1 - BASE REGISTER OF THE UCBOB DSECT, MODIF BY TRT\n.*            R2 - MODIFIED BY TRT INSTRUCTION\n.*            R14- BAL AND WORK REGISTER\n.*            R15- BASE FOR CVT, BAL AND RC FOR UCB SCAN SERVICE\n.*\n.*       REQUIREMENTS: YOU MUST INCLUDE THE 'IEFUCBOB' MACRO AND THE\n.*            'CVT DSECT=YES' MACRO IN YOUR CODE.\n.*\n.*       REQUIRED POSITIONAL PARAMETERS:\n.*           &UCB - FULLWORD IN WHICH THE UCB ADDRESS WILL BE RETURNED\n.*           &WA  - 100 BYTE WORKAREA, MUST BE ZERO AT FIRST CALL\n.*                  DO NOT ZERO ON SUBSEQUENT CALLS UNLESS YOU WISH\n.*                  TO START WITH THE FIRST UCB AGAIN.\n.*           &MASK- 40 BYTE MASK THAT IS COMPARED TO THE UCBS AND ONLY\n.*                  THOSE UCBS MATCHING THE BITS IN THE MASK WILL BE\n.*                  RETURNED.\n.*\n.*       OPTIONAL KEYWORD PARAMETERS:\n.*           &PENDOFF=NOSKIP/SKIP: RETURN UCB EVEN IF IT IS PENDING\n.*                    OFFLINE, THIS (NOSKIP) IS THE DEFAULT.\n.*           &PENDMNT=NOSKIP/SKIP: RETURN UCB EVEN IF A MOUNT IS\n.*                    PENDING, THIS (NOSKIP) IS THE DEFAULT.\n.*           &VOLZERO=NOSKIP/SKIP: RETURN UCB EVEN IF THE VOLSER IS\n.*                    ZERO, THIS (NOSKIP) IS THE DEFAULT.\n.*           &VIRTVOL=NOSKIP/SKIP: RETURN UCB EVEN IF IT IS A VIRTUAL\n.*                    VOL, THIS (NOSKIP) IS THE DEFAULT.\n.*\n.*EXAMPL\n.*       USING UCBOB,R2     ESTABLISH ADDRESSABILITY TO\n.*       LA    R2,MASK            UCB MASK AND DSECT\n.*       XC    UCBWA,UCBWA    CLEAR 100 BYTE WORK AREA\n.*       XC    MASK,MASK      CLEAR MASK\n.*       OI    UCBBYT3,UCB3DACC     DIRECT ACCESS DEVICE\n.*       OI    UCBSTAT,UCBONLI      MUST BE ONLINE\n.*       OI    UCBSTAB,UCBBSTR      MUST BE MOUNTED STORAGE\n.*       DROP  R2                 DROP ADDRESSABILITY\n.* LOOP  EQU   *\n.*       FINDUCB UCBPTR,UCBWA,MASK,PENDOFF=SKIP,PENDMNT=SKIP,\n.*            VOLZERO=SKIP,VIRTVOL=SKIP\n.*       USING UCBOB,R2           RE-ESTABLISH ADDRESSABILITY\n.*       LTR   R15,R15            FIND ONE?\n.*       BNZ   EXIT               NO - END OF UCBS\n.*       ICM   R2,15,UCBPTR    YES- PICK UP RETURNED UCB ADDRESS\n.*       .                               PROCESS\n.*       .\n.*       .\n.*       B     LOOP               GET NEXT UCB\n.* EXIT  EQU   *\n.*\n.*       THE MASK IN THE ABOVE EXAMPLE WOULD LIMIT THE UCBS RETURNED\n.*       TO THOSE THAT ARE: DASD AND ONLINE AND MOUNTED AS STORAGE\n.*       AND A MOUNT IS NOT PENDING AND IS NOT PENDING OFFLINE AND THE\n.*       VOLSER IS NOT X'00'S AND IT IS NOT A VIRTUAL DEVICE (MSS).\n.*\n.*       ANY BITS MAY BE SET IN THE MASK. IF YOU WANT A SPECIFIC DEVICE\n.*       ADDRESS, SET EITHER THE BINARY OR CHARACTER DEVICE ADDRESS IN\n.*       THE MASK TO THE SPECIFIC DEVICE REQUIRED.\n.*\n.*       IF YOU ALL UCBS, SET THE MASK TO ZERO AND OMIT THE OPTIONAL\n.*       KEYWORD PARAMETRS.\n.*------ --------------------------------------------------------------\n         LCLA  &X\n&X       SETA  &SYSNDX\n         USING UCBOB,R1     UCB DSECT\n         USING CVTMAP,R15   CVT DSECT\n&NAME    DS    0H\n         LA    R1,&WA       GET ADDRESS OF 100 BYTE WORKAREA\n         ST    R1,PWA&X         STORE ADDRESS INTO PARMLIST\n         LA    R1,&MASK+18  PICK UP DEVICE CLASS\n         ST    R1,PDVT&X        STORE ADDRESS INTO PARMLIST\n         LA    R1,&UCB      GET ADDRESS OF WORD TO STORE UCB ADDR\n         ST    R1,PUCB&X        STORE ADDRESS INTO PARMLIST\n         OI    PUCB&X,X'80' INDICATE END OF PARMLIST\nMLPA&X   EQU   *\n         LA    R1,PARM&X    PUT PARMLIST ADDRESS INTO R1\n         L     R15,CVTPTR    GET CVT ADDRESS\n         L     R15,CVTUCBSC  GET UCB SCAN SERVICE ADDRESS\n         BALR  R14,R15       BRANCH TO SCAN SERVICE\n         LTR   R15,R15       DID SCAN SERVICE RETURN A UCB?\n         BNZ   MZZZ&X          NO- MUST BE END OF UCB TABLE\n         L     R1,&UCB      YES-GET UCB ADDR THAT SCAN SERVICE RETURND\n         MVC   WUCB&X,0(R1)   COPY UCB\n         CLI   &MASK+28,X'00'   DID USER SUPPLY A VOLSER?\n         BE    MBBB&X           NO - OK\n         XC    WTRT&X,WTRT&X    YES - CLEAR TRT TABLE\n         MVI   WTRT&X+C'*',C'*'    SET FOR A GENERIC VOLSER TEST\n         TRT   &MASK+28(6),WTRT&X  DID USER SUPPLY A GENERIC VOLSER?\n         BZ    MAAA&X              NO - OK\n         LA    R14,&MASK+28      START OF GENERIC\n         SR    R1,R14              LENGTH OF GENERIC\n         STC   R2,WUCB&X+28(R1) PLACE * IN CORRESPONDNG UCB VOLS WKAREA\n*        SO THAT WHEN ITS 'ANDED' WITH MASK WILL GIVE AN EQ COMPARISON\n         BCTR  R1,0                LENGTH-1\n         LR    R2,R1      USE R2 AS LENGTH IN EX INSTRUCTION\n         L     R1,&UCB    RESET R1 AS BASE REG FOR UCB\n         LTR   R2,R2  IS LENGTH = -1 I.E. WAS VOL=* SPECIFIED\n         BM    MBBB&X     YES - GET ALL VOLUMES\n         EX    R2,MCLC&X  NO- GENERIC COMPARE\n         BNE   MLPA&X              NOT EQUAL\n         B     MBBB&X              EQUAL\nMAAA&X   EQU   *\n         CLC   UCBVOLI,&MASK+28    SAME VOLSER?\n         BNE   MLPA&X              NO - SKIP IT\nMBBB&X   EQU   *\n         NC    WUCB&X,&MASK   'AND' MASK OVER COPY OF UCB\n         CLC   WUCB&X,&MASK   COMPARE 'ANDED' UCB TO MASK\n         BNE   MLPA&X           NOT EQUAL - SKIP IT\n         AIF   ('&PENDOFF' EQ 'NOSKIP').AAA\n         TM    UCBSTAT,UCBCHGS     PENDING OFFLINE/UNLOAD\n         BO    MLPA&X              YES - IGNORE IT\n.AAA     ANOP\n         AIF   ('&PENDMNT' EQ 'NOSKIP').BBB\n         TM    UCBDMCT,UCBMOUNT    MOUNT PENDING\n         BO    MLPA&X              YES - IGNORE IT\n.BBB     ANOP\n         AIF   ('&VOLZERO' EQ 'NOSKIP').CCC\n         CLI   UCBVOLI,X'00'       ANY VOLUME INFORMATION\n         BE    MLPA&X              NO - SKIP IT\n.CCC     ANOP\n         AIF   ('&VIRTVOL' EQ 'NOSKIP').DDD\n         TM    UCBTBYT2,UCBRVDEV   IS THIS A VIRTUAL VOLUME\n         BO    MLPA&X              YES - SKIP IT\n.DDD     ANOP\n         B     MZZZ&X\nPARM&X   DS    0F\nPWA&X    DS    F           ADDRESS OF 100-BYTE WORK AREA\nPDVT&X   DS    F           ADDRESS OF DEVICE CLASS BYTE\nPUCB&X   DS    F           ADDRESS OF WORD TO STORE UCB ADDR\n*\nWUCB&X   DC    XL40'00'    COPY OF UCB FOR 'AND'\nWTRT&X   DC    XL256'00'            TRT TABLE\nMCLC&X   CLC   UCBVOLI(0),&MASK+28   SAME VOLSER?\nMZZZ&X   DS    0H\n         MEND\n*   END  MACRO\n*\n         MACRO\n&NAME    RVPARM &DSECT=NO,&CSECT=YES,&CONTDS=NO\n*        MAP DATA PASSED TO READVTOC SUBROUTINE\n*        USAGE NOTES:\n*          ALL ZEROS- ALL DASD VOLUMES WILL BE PROCESSED\n*          RVUCBNME - SET THIS TO PROCESS A SPECIFIC DASD ADDR\n*          RVUCBVOL - SET THIS TO PROCESS A SPECIFIC DASD VOLUME\n*          RVUCBSTA - SET THIS TO PROCESS ONLY:\n*                     PRIVATE, PUBLIC OR STORAGE\n*\n         AIF   ('&DSECT' EQ 'YES').CHKCONT\n&NAME    DS    0D\nRVMASK   DS    0XL40    UCB MASK\n         DC    XL13'00'\nRVUCBNME DC    XL3'00'   CHAR - UCB NAME  CUA\n         DC    XL12'00'\nRVUCBVOL DC    XL6'00'   CHAR - VOLSER NUMBER\nRVUCBSTA DC    XL1'00'   HEX - VOLUME STATUS\n         DC    XL5'00'\n         AGO   .DONE\n.CHKCONT AIF   ('&CONTDS' EQ 'YES').DS\n&NAME    DSECT\n.DS      ANOP\nRVMASK   DS    0XL40    UCB MASK\n         DS    XL13\nRVUCBNME DS    XL3       CHAR - UCB NAME  CUA\n         DS    XL12\nRVUCBVOL DS    XL6       CHAR - VOLSER NUMBER\nRVUCBSTA DS    XL1       HEX - VOLUME STATUS\n&SYSECT  CSECT\n.DONE    ANOP\n*                     VOLUME STATUS BITS\nRVUCBPRV EQU   X'10'           PRIVATE\nRVUCBPUB EQU   X'08'           PUBLIC\nRVUCBSTG EQU   X'04'           STORAGE\n         MEND\n*   END  MACRO\n*\n         MACRO\n&NAME    RVDATA &DSECT=NO,&CSECT=YES,&CONTDS=NO\n*        MAP AREA FOR READVTOC SUBROUTINE\n         AIF   ('&DSECT' EQ 'YES').CHKCONT\n&NAME    DS    0D\nRVSTART  EQU   *\nRVDSCB   DC    CL140' '       DSCB\nRVVOLSER DC    CL6' '         VOLSER\nRVCCHHR  DC    CL5'00'        CCHHR OF THIS DSCB\nRVFLAG   DC    XL1'00'         FLAG BYTE\nRVUCBA   DC    XL4'00'         UCB ADDR\nRVEND    EQU   *\n         AGO   .DONE\n.CHKCONT AIF   ('&CONTDS' EQ 'YES').DS\n&NAME    DSECT\n.DS      ANOP\nRVSTART  EQU   *\nRVDSCB   DS    CL140      DSCB\nRVVOLSER DS    CL6        VOLSER\nRVCCHHR  DS    CL5        CCHHR\nRVFLAG   DS    XL1        FLAG\nRVUCBA   DS    XL4        UCB ADDR\nRVEND    EQU   *\n&SYSECT  CSECT\n.DONE    ANOP\nRVINDEX  EQU   X'80'   INDEXED VTOC (RVFLAG)\nRVLEN    EQU   (RVEND-RVSTART)\n         MEND\n*   END  MACRO\n*\n         PRINT NOGEN\nREADVTOC START 0\n         USING *,R15\n         STM   R14,R12,12(R13)  SAVE CALLERS REGISTERS IN HIS SAVEAREA\n         ST    R13,SAVEAREA+4  PLACE CALLERS SAVEAREA ADDR IN MY SVAREA\n         CNOP  0,4\n         BAL   R12,JUMPSAVE    LOAD BASE REGISTER\nSAVEAREA DS    18F\nJUMPSAVE ST    R12,8(R13)    PLACE MY SAVEAREA ADDR IN CALLERS SAVEAREA\n         LR    R13,R12       LOAD MY SAVEAREA ADDR INTO R13\n         USING SAVEAREA,R12\n         DROP  R15\n*        GET PARM\n         USING MASK,R4\n         USING TARGET,R5\nENTRY010 DS    0H\n         XC    RC,RC    CLEAR RETURN CODE\n         ICM   R4,15,0(R1)   PICK UP MASK IN FIRST WORD OF PARM\n         ICM   R5,15,4(R1)   PICK UP TARGET AREA IN 2ND WORD OF PARM\n         ICM   R15,15,8(R1)   PICK UP INITIAL DSN IN 3RD WORD OF PARM\n         TM    FLAG,FIRST    HAVE WE BEEN HERE BEFORE?\n         BZ    ZZZ010                NO -OK\n         CLI   0(R15),X'FF'  ARE WE FORCING END-OF-VOLUME FOR IXVTOC\n         BNE   AAA010        NO\n         MVI   IDXDSN,X'FF'  YES - SET CVAF DSN TO X'FF'\nAAA010   LM    R2,R11,SAVEREGS    YES -PICK UP OUR REGS\n         TM    FLAG,FORMAT4     DID WE JUST GET A FORMAT4 DSCB\n         BO    ENTRY060         YES SETUP FOR THE REST\n         TM    FLAG,INDEXED    DOES THIS VOLUME HAVE AN INDEXED VTOC\n         BZ    LOOP060A          YES - USE THIS RTN\n         B     LOOP065A          NO\nZZZ010   EQU   *\n         OI    FLAG,FIRST       SET FLAG\n         MVC   IDXDSN,0(R15) SET DSN FIELD WITH INIT DSN FOR INDEX VTOC\n         MVC   SAVEDSN,IDXDSN SAVE THE ORIGINAL INITDSN FOR ENDVOL PRCS\nEXIT010  EQU   *\n         SPACE 3\n*        GET A DASD UCB\nENTRY020 DS    0H\n         USING UCBOB,R2    ESTABLISH ADDRESSABILITY TO\n         LR    R2,R4       ADDRESS OF CALLERS MASK\n         XC    UCBWA,UCBWA          CLEAR 100 BYTE WORK AREA\n         OI    UCBTBYT3,UCB3DACC    DIRECT ACCESS DEVICE\n         OI    UCBSTAT,UCBONLI     MUST BE ONLINE\n         DROP  R2          DROP ADDRESSABILITY\nLOOP020A EQU   *\n         FINDUCB UCBPTR,UCBWA,MASK,PENDOFF=SKIP,PENDMNT=SKIP,          X\n               VOLZERO=SKIP,VIRTVOL=SKIP\n         USING UCBOB,R2        RE-ESTABLISH ADDRESSABILITY\n         ICM   R2,15,UCBPTR     - UCB\n         STCM  R2,15,RVUCBA     RETURN ADDRESS OF UCB TO CALLER\n         MVC   RVVOLSER,UCBVOLI  COPY VOLSER FROM UCB\n         DROP  R2\n         LTR   R15,R15           FIND ONE?\n         BZ    EXIT020           YES - PROCESS IT\n         OI    FLAG,DONE\nEXIT020  EQU   *\n         B     ENTRY030\nUCBPTR   DC    A(0)\nUCBWA    DC    XL100'00'\n         SPACE 3\n*RELEASE  THE CVAF IOAREA   (FOR MULTIPLE VOLUMES)\nENTRY030 DS    0H\n         SR    R15,R15     ZERO R15 FOR FIRST TIME THRU WHEN\n*        NOT DONE, NO IOAREA AND NOT VOLEND\n         TM    FLAG,IOAREA    DO WE HAVE AN IO AREA\n         BZ    BYPAS030      NO - OK - CHECK IF FOUND UCB (DONE FLAG)\n*        IF DONE FLAG SET THEN NON-EXISTANT VOLSER WAS REQUESTED\n         ICM   R3,15,UCBPTR     YES - PUT UCB ADDR IN R3\n         CVAFSEQ UCB=(R3),IOAREA=NOKEEP,MF=(E,CVAFSEQ)\nBYPAS030 TM    FLAG,DONE     ARE WE ALL DONE?\n         BZ    AAA030         NO  - OK\n         MVI   FLAG,X'00'     YES - RESET FLAG\n         XC    UCBWA,UCBWA  REINIT WORK AREA FOR FINDUCB MACRO\n         MVC   RC,=F'4'       SET RETURN CODE\n         B     GOBACK\nAAA030   EQU   *\n         TM    FLAG,VOLEND    HAVE WE HIT THE END OF THE CURRENT VOL\n         BO    EXIT030   YES- RESET ENDVOL FLAG AND PROCESS NEXT VOL\n         MVI   ERR,C'1'       SET ERRO NUMBER FOR TRACKING\n         LTR   R15,R15\n         BNZ   ERROR1\nEXIT030  EQU   *\n         OI    FLAG,IOAREA          SET FLAG\n         NI    FLAG,X'FF'-VOLEND  RESET VOLEND FLAG\n         SPACE 3\n*        GET THE FORMAT4 DSCB\nENTRY040 DS    0H\n         XC    BUFLIST(BFLHLN+BFLELN),BUFLIST\n         OI    BFLHFL,BFLHDSCB   DSCB TO BE READ\n         MVI   BFLHNOE,1         ONE BUFFER\n         LA    R1,DSCB           ADDR OF DSCB AREA\n         STCM  R1,15,BFLEBUF     STORE IN BUFLIST\n         MVI   BFLELTH,96        LENGTH OF DSCB AREA\n         ICM   R3,15,UCBPTR           UCB ADDR\n         CVAFDIR UCB=(R3),IOAREA=NOKEEP,MF=(E,CVAFDIR)\n         MVI   ERR,C'2'\n         LTR   R15,R15\n         BNZ   ERROR1\n         OI    FLAG,FORMAT4      SET THE FLAG\n         MVC   RVDSCB(96),DSCB   MOVE TO CALLERS AREA\n         MVC   RVCCHHR,BFLEARG   COPY CCHHR OF THIS DSCB\nEXIT040  EQU   *\n         SPACE 3\n*        TEST FOR INDEXED VTOC\nENTRY050 DS    0H\n         NI    FLAG,X'FF'-INDEXED    RESET\n         MVC   IDXDSN,SAVEDSN       GET INITIAL DSN FOR NEW IXVTOC\n*        XC    IDXDSN,IDXDSN         CLEAR\n*        MVI   IDXDSN,X'05'  START AFTER THE FORMAT4 DSCB\n         ICM   R3,15,UCBPTR      UCB ADDR\n         CVAFTST UCB=(R3)\n         LTR   R15,R15      RETURN CODE\n         BZ    BBB050       0 - SYSTEM DOES NOT SUPPORT INDEXED VTOC\n         C     R15,=F'4'    4 - NON-INDEXED VOLUME\n         BE    BBB050\n         C     R15,=F'8'    8 - INDEXED VTOC\n         BE    AAA050\n         B     ERROR2       INVALID\nAAA050   EQU   *\n         OI    FLAG,INDEXED   SET FLAG\n         OI    RVFLAG,RVINDEX SET FLAG\nBBB050   EQU   *\n         MVC   LASTCCHH,DS4HPCHR   SAVE LAST USED FORMAT1\nEXIT050  EQU   *\n         B     GOBACK\n*\n*        GET VTOC ENTRIES  - NON-INDEXED\n*\nENTRY060 DS    0H\n         TM    FLAG,INDEXED       IS IT INDEXED?\n         BO    ENTRY065               YES - USE DSN= CVAF\n         NI    FLAG,X'FF'-FORMAT4               RESET\n         XC    BUFLIST(BFLHLN+BFLELN),BUFLIST\n         OI    BFLHFL,BFLHDSCB        DSCBS TO BE READ\n         MVI   BFLHNOE,1              1 BUFFER\n         LA    R1,DSCB               ADDR OF DSCB AREA\n         STCM  R1,15,BFLEBUF         STORE IN BUFLIST\n         MVI   BFLELTH,140           LENGTH OF DSCB AREA\n         ICM   R3,15,UCBPTR             UCB ADDR\n         CVAFSEQ UCB=(R3),IOAREA=KEEP,DSN=0,MF=(E,CVAFSEQ)\n         LTR   R15,R15       DID WE GET A DSCB\n         BZ    EXIT060      YES - OK\n         USING CVPL,R1\n         CLI   CVSTAT,32    END OF DATA\n         BE    EXIT060\n         MVI   ERR,C'3'\n         B     ERROR1\n         DROP  R1\nLOOP060A EQU   *\n         OI    BFLHFL,BFLHDSCB   DSCBS TO BE READ\n         MVI   BFLHNOE,1              1 BUFFER\n         LA    R1,DSCB               ADDR OF DSCB AREA\n         STCM  R1,15,BFLEBUF         STORE IN BUFLIST\n         MVI   BFLELTH,140           LENGTH OF DSCB AREA\n         ICM   R3,15,UCBPTR             UCB ADDR\n         CVAFSEQ IOAREA=KEEP,DSN=0,MF=(E,CVAFSEQ)\n         LTR   R15,R15       DID WE GET A DSCB\n         BZ    EXIT060      YES - OK\n         USING CVPL,R1\n         OI    FLAG,VOLEND   SET END OF VOL FLAG\n         CLI   CVSTAT,32   END OF DATA\n         BE    LOOP020A    YES - GET NEXT VOLUME\n         MVI   ERR,C'4'    SET ERROR NUMBER FOR TRACKING\n         B     ERROR1       NO - ERROR\n         DROP  R1\nEXIT060  EQU   *\n         B     ENTRY100\nBUFLIST  ICVAFBFL DSECT=NO\n         SPACE 5\n*        GET VTOC ENTRIES  - INDEXED\n*\nENTRY065 DS    0H\n         NI    FLAG,X'FF'-FORMAT4               RESET\n         XC    BUFLIST(BFLHLN+BFLELN),BUFLIST\n         OI    BFLHFL,BFLHDSCB        DSCBS TO BE READ\n         MVI   BFLHNOE,1              1 BUFFER\n         LA    R1,DSCB               ADDR OF DSCB AREA\n         STCM  R1,15,BFLEBUF         STORE IN BUFLIST\n         MVI   BFLELTH,96           LENGTH OF DSCB AREA\n         ICM   R3,15,UCBPTR             UCB ADDR\n         CVAFSEQ UCB=(R3),IOAREA=KEEP,DSN=IDXDSN,MF=(E,CVAFSEQ)\n         LTR   R15,R15       DID WE GET A DSCB\n         BZ    EXIT065      YES - OK\n         USING CVPL,R1\n         CLI   CVSTAT,32  END OF DATA(NEVER GETS TO EOD ON INDEXED VOL\n*        AFTER FIRST CVAF BECAUSE THERS ALWAYS A SYS1.VTOCIX DS)\n         BE    EXIT065\n         MVI   ERR,C'5'\n         B     ERROR1\n         DROP  R1\nLOOP065A EQU   *\n         OI    BFLHFL,BFLHDSCB   DSCBS TO BE READ\n         MVI   BFLHNOE,1              1 BUFFER\n         LA    R1,DSCB               ADDR OF DSCB AREA\n         STCM  R1,15,BFLEBUF         STORE IN BUFLIST\n         MVI   BFLELTH,96            LENGTH OF DSCB AREA\n         ICM   R3,15,UCBPTR             UCB ADDR\n         CVAFSEQ IOAREA=KEEP,DSN=IDXDSN,MF=(E,CVAFSEQ)\n         LTR   R15,R15       DID WE GET A DSCB\n         BZ    EXIT065      YES - OK\n         USING CVPL,R1\n         OI    FLAG,VOLEND   SET END OF VOL FLAG\n         CLI   CVSTAT,32   END OF DATA\n         BE    LOOP020A    YES - GET NEXT VOLUME\n         MVI   ERR,C'6'    SET ERROR NUMBER FOR TRACKING\n         B     ERROR1       NO - ERROR\n         DROP  R1\nEXIT065  EQU   *\n         B     ENTRY100\nIDXDSN   DC    XL44'05'\n         SPACE 5\n*        MOVE DATA TO CALLERS AREA\nENTRY100 DS    0H\n         MVC   RVCCHHR,BFLEARG   COPY CCHHR OF THIS DSCB\n         TM    FLAG,INDEXED      IS VOL INDEXED\n         BO    AAA100        YES- OK\n         MVC   RVDSCB,DSCB    NO\n         CLC   LASTCCHH,BFLEARG   PAST THE LAST FORMAT1 ON VOLUME\n         BNL   EXIT100       NO - CONTINUE NORMALLY\n         OI    FLAG,VOLEND   YES- SET VOLEND FLAG\n         B     LOOP020A            GET THE NEXT VOLUME\nAAA100   EQU   *\n         MVC   RVDSCB(44),IDXDSN     COPY DSN\n         MVC   RVDSCB+44(96),DSCB    COPY REST OF DSCB\nEXIT100  EQU   *\n         SPACE 5\n*\n*        EOJ\nGOBACK   DS    0H\n         STM   R2,R11,SAVEREGS\n         ICM   R15,15,RC      GET RETURN CODE\n         L     R13,SAVEAREA+4\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         SPACE 3\nRC       DC    F'0'\nSAVEREGS DC    10F'0'\n         SPACE 3\n*        ERRORS\nERROR1   DS    0H\n         USING CVPL,R1\n         XR    R2,R2    CLEAR\n         ICM   R2,1,CVSTAT          STATUS CODE\n         CVD   R2,DBWRD             CONVERT\n         MVC   STAT,=X'40202120'    EDIT MASK\n         ED    STAT,DBWRD+6\n         DROP  R1\n         CVD   R15,DBWRD\n         MVC   RETCODE,=X'40202120'\n         ED    RETCODE,DBWRD+6\n         MVC   RC,=F'16'\n         B     GOBACK\nRETCODE  DC    CL4' '\nSTAT     DC    CL4' '\nERR      DC    C' '\n         SPACE 1\nERROR2   DS    0H\n         MVC   RC,=F'8'   SET RC\n         B     GOBACK\n         SPACE 5\n*        STORAGE AREAS\nFLAG     DC    X'00'\nINDEXED  EQU   X'80'\nIOAREA   EQU   X'40'\nFIRST    EQU   X'20'\nDONE     EQU   X'10'\nFORMAT4  EQU   X'08'\nVOLEND   EQU   X'04'\n         SPACE 1\nLASTCCHH DC    XL5'00'\nDBWRD    DC    D'0'\nSAVEDSN  DS    CL44\nFMT4DSN  DC    44X'04'\nDSCB     DC    XL140'00'\n         ORG   DSCB\n         IECSDSL1 (4)\n         ORG   *+44    TAKE UP THE SLACK\n         SPACE 2\nCVAFSEQ  CVAFSEQ ACCESS=GT,BUFLIST=BUFLIST,BRANCH=(YES,PGM),MF=L\n         SPACE 2\nCVAFDIR  CVAFDIR ACCESS=READ,BUFLIST=BUFLIST,DSN=FMT4DSN,              X\n               BRANCH=(YES,PGM),MF=L\n         SPACE 2\nMASK     RVPARM DSECT=YES\n         SPACE 2\nTARGET   RVDATA DSECT=YES\n         SPACE 2\nCVPL     ICVAFPL ,\n         SPACE 2\n         CVT   DSECT=YES\nUCVDSECT DSECT\n         IEFUCBOB\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCAN4HIT": {"ttr": 9994, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x05O\\x00\\x93\\x05O\\tQ\\x00{\\x00{\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-23T00:00:00", "modifydate": "1993-02-23T09:51:00", "lines": 123, "newlines": 123, "modlines": 0, "user": "CN03MQK"}, "text": "*   THIS PROGRAM IS A SUBROUTINE WHICH WILL SCAN A FIELD OF UP\n*   TO 168 BYTES IN LENGTH FOR AN ARGUMENT OF UP TO 80 BYTES IN\n*        LENGTH AND INFORM THE INVOKER OF WHETHER A MATCH WAS FOUND.\n*\n*        TO CALL THIS PROGRAM, DO THE FOLLOWING :\n*\n*           MOVE YOUR ARGUMENT TO ARGUMENT OF SCAN4HIT-I-O-AREA.\n*           MOVE THE LENGTH OF YOUR ARGUMENT\n*             TO ARGUMENT-LENGTH OF SCAN4HIT-I-O-AREA.\n*           MOVE YOUR RECORD TO BE SCANNED\n*             TO TABLE-ELEMENT OF SCAN4HIT-I-O-AREA.\n*           MOVE THE LENGTH OF YOUR RECORD TO BE SCANNED\n*             TO TABLE-ELEMENT-LENGTH OF SCAN4HIT-I-O-AREA.\n*\n*           CALL 'SCAN4HIT' USING SCAN4HIT-I-O-AREA.\n*\n*           AFTER THE CALL, HIT-SWITCH OF SCAN4HIT-I-O-AREA WILL\n*           CONTAIN EITHER 'Y' OR 'N'.  'Y' MEANS A MATCH WAS\n*           FOUND AND 'N' MEANS A MATCH WAS NOT FOUND.\n*           IF HIT-SWITCH ='Y' ARG-POSITION IS BEGINNING POS OF STRNG\n*\n*                WHERE:\n*                      01  SCAN4HIT-I-O-AREA.\n*                          05  ARGUMENT              PIC X(80).\n*                          05  ARGUMENT-LENGTH       PIC S9(4) COMP.\n*                          05  TABLE-ELEMENT         PIC X(168).\n*                          05  TABLE-ELEMENT-LENGTH  PIC S9(4) COMP.\n*                          05  ARG-POSITION          PIC S9(4) COMP.\n*                          05  HIT-SWITCH            PIC X.\n*\n*         RETURN CODES        MEANING\n*                 0           MATCH WAS FOUND\n*                 4           NO MATCH WAS FOUND\n*                 8           INVALID PARAMETERS PASSED TO PROGRAM\nSCAN4HIT CSECT\n         PRINT NOGEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\nSAVEAREA DC    18F'0'\n********************************************************************\n*        SAVE REGISTER 1 IN REGISTER 11 AND LOAD PARAMETER FIELD   *\n*        INTO IOAREA                                               *\n********************************************************************\nSTARTIT  LR    R11,R1              SAVE REGISTER 1 CONTENTS IN REG 11\n         L     R9,0(R11)\n         MVC   IOAREA,0(R9)\n********************************************************************\n*        M A I N   L I N E   L O G I C                             *\n********************************************************************\n         LA    R10,0\n         LH    R8,INARGLEN\n         LH    R9,INTBLLEN\n         LTR   R8,R8\n         BNP   NOGOOD\n         CH    R8,=H'80'\n         BH    NOGOOD\n         LTR   R9,R9\n         BNP   NOGOOD\n         CH    R9,=H'168'     FIELD IN RECORD TO BE SEARCHED @MK\n         BH    NOGOOD\n         CR    R8,R9\n         BH    NOGOOD\n         LA    R6,ARGUMENT\n         LA    R7,TBLELMNT\n         BCTR  R8,0            SUBTRACT 1\n         AR    R9,R7\n         SR    R9,R8\n         BCTR  R9,0            SUBTRACT 1\nLOOP     CR    R7,R9\n         BH    NOHIT\n         EX    R8,DOCOMPR\nCHEK     BE    HIT\n         LA    R7,1(R7)        ADD 1\n         B     LOOP\nNOHIT    MVI   HITSW,C'N'\n         LA    R10,4\n         B     SHUTDOWN\nNOGOOD   MVI   HITSW,C' '\n         LA    R10,8\n         B     SHUTDOWN\nHIT      MVI   HITSW,C'Y'\n         LA    R5,TBLELMNT-1    GET ADDR OF RECORD (MINUS 1)   @MK\n         SR    R7,R5            GET POSITION OF FOUND STRING   @MK\n         STH   R7,ARGPOSIT      STORE IT IN PARAMETER LIST     @MK\n         B     SHUTDOWN\nDOCOMPR  CLC   0(0,R6),0(R7)\n         B     CHEK\n*    E N D  O F   J O B   P R O C E S S I N G                  *\nSHUTDOWN LR    R15,R10\n         L     R9,0(R11)\n         MVC   0(255,R9),IOAREA\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n*    BREAKDOWN OF IOAREA                                       *\nIOAREA   DS    0CL255        @MK\nARGUMENT DS    CL80\nINARGLEN DS    H\nTBLELMNT DS    CL168         @MK\nINTBLLEN DS    H\nARGPOSIT DS    H             @MK\nHITSW    DS    CL1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUPRDMSG": {"ttr": 10243, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x05O\\x00\\x93\\x05O\\x10#\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-23T00:00:00", "modifydate": "1993-02-23T10:23:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "CN03MQK"}, "text": "          ISPEXEC LIBDEF ISPPLIB DATASET ID('HRA.SUPRDUMP.ISPPLIB')\n          ISPEXEC LIBDEF ISPMLIB DATASET ID('HRA.HFSELECT.ISPMLIB')\n        DMPMAIN:  ISPEXEC DISPLAY PANEL(DMPMAIN)\n                  IF LASTCC EQ 8 THEN EXIT\n                  ISPEXEC VGET (PANELID) SHARED\n                  IF &PANELID EQ DMP040 THEN GOTO DMP040\n                  ISPEXEC DISPLAY PANEL(&PANELID)\n                  GOTO DMPMAIN\n        DMP040:   ISPEXEC DISPLAY PANEL(DMP040)\n                  IF LASTCC EQ 8 THEN GOTO DMPMAIN\n                  ISPEXEC DISPLAY PANEL(DMP040B)\n                  IF LASTCC EQ 8 THEN GOTO DMPMAIN\n                  IF &ZCMD EQ LAST THEN GOTO DMP040\n                  GOTO DMPMAIN\n                  END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUPRDUMP": {"ttr": 10245, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x05O\\x00\\x93\\x05O\\x10\\x19\\x05H\\x05H\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-23T00:00:00", "modifydate": "1993-02-23T10:19:00", "lines": 1352, "newlines": 1352, "modlines": 0, "user": "CN03MQK"}, "text": "         MACRO\n&LABEL   CHCKTIOT &FOUND=,&NOTFND=TIOTERR\n&LABEL   BAL   R6,CALLTIOT\n         CLI   TIOTFLAG,C'1'\n         BNE   &NOTFND\n         AIF   ('&FOUND' EQ '').NOBRNCH\n         B     &FOUND\n.NOBRNCH MEND\n         SPACE 2\n         MACRO\n&LABEL   MESSAGE &MSGNUM,&BRANCH=\n&LABEL   L     R1,PRINTBUF\n         MVC   0(MSG&MSGNUM.LEN,R1),MSG&MSGNUM\n         BAL   R6,PUTP2\n         AIF   ('&BRANCH' EQ '').END\n         B     &BRANCH\n.END     MEND\n         SPACE 2\n         MACRO\n         GETDATE &TODAY\n&TODAY   DC    C'&SYSDATE'\n         MEND\n         TITLE 'SUPRDUMP PROGRAM'\n         PRINT NOGEN\nSUPRDUMP START 0\n         USING *,R15\n         STM   R14,R12,12(R13)      SAVE SYSTEM REGISTERS\n         ST    R13,SAVEAREA+4\n         LR    R3,R13               SAVE SYSTEM SAVEAREA ADDR\n         LM    R11,R12,BASES\n         CNOP  0,4\n         BAL   R13,JUMPSAVE\nSAVEAREA DS    18F\nBASES    DC    A(SAVEAREA+4096,SAVEAREA+8192)\nJUMPSAVE ST    R13,8(R3)     STORE MY SAVEAREA ADDR IN SYSTEM SAVEAREA\n         USING SAVEAREA,R13,R11,R12 ESTABLISH R13,R11 & R12 AS BASE REG\n         USING TIOENTRY,R4  MAKE TIOT DD ENTRY ADDRESSABLE\n         DROP  R15\n         L     R7,0(R1)   SAVE ADDR OF PARMS, REF BY R1 AT ENTRY\n         SPACE 2\n         L     R0,F65535  LOAD R0 WITH 65535\n         GETMAIN R,LV=(0)     GET AN INPUT BUFFER OF 65535 BYTES\n         STCM  R1,7,CCW+1     STORE BUFFER ADDRESS IN CCW\n         CHCKTIOT NOTFND=NOSYSPRT\nSYSPRNT  OPEN  (SYSPRINT,OUTPUT)          PARM, ATTRIBUTE & STATS FILE\n         BAL   R6,PUTP2  INITIALIZE PRINTBUF WITH SYSPRINT BUF ADDR\n         MESSAGE 41\n         SR    R5,R5             GET PSA ADDR\n         USING PSA,R5\n         L     R5,PSATOLD        GET TCB ADDR\n         USING TCB,R5\n         L     R5,TCBTIO         GET TIOT ADDR\n         DROP  R5\n         MVC   MSG22JOB,0(R5)        GET JOBNAME\n         MVC   MSG22PRC,8(R5)        GET (PROC)STEPNAME\n         CLI   16(R5),C' '  IS THERE ONLY A STEPNAME & NO PROCSTEPNAME\n         BE    NOPRCSTP               YES\n         MVC   MSG22STP,16(R5)        NO\n         B     ENDMSG22\nNOPRCSTP MVC   MSG22JOB+9(4),MSGSPACE    BLANK OUT PROC LITERAL\n         MVC   MSG22PRC+8(20),MSGSPACE\nENDMSG22 MESSAGE 22\n         MVC   DDNAME,=C'SYSUT2  '   CHECK IF SYSUT2 IS IN JCL\n         CHCKTIOT NOTFND=NOSYSUT2\nSYSUT2   OPEN  (PRINTER,OUTPUT)    OUTPUT PRINT FILE\n         BAL   R6,PUTP1           SKIP TO CH 1\n         MVC   DDNAME,=C'DIAGNOSE'   CHECK IF DIAGNOSE DD IS IN JCL\n         CHCKTIOT NOTFND=NODIAG\n         OPEN  (DIAGNOSE,OUTPUT)\n         MVI   DIAGNOP+1,X'00'       SET NOP TO DO SENSE\n         MVI   DENCKEND+1,X'00'      SET NOP TO WRITE TO DIAGNOSE FILE\n         DEVTYPE DDNAME,DVCTYPE\n         CLC   DVCTYPE,=X'00000102'  IS DIAGNOSE ALLOCATED TO SYSOUT\n         BNE   NODIAG                NO\n         MVI   PRTDIAG+1,X'F0'       YES- SET BRANCH FOR PRINTING\n         MVC   DIAGNOSE+LRECL(2),=H'80'  CHNG LRECL FOR PRINTING\nNODIAG   EQU   *\n*              ** GET LENGTH OF PARM FIELD\n         LH    R5,0(R7)           GET LENGTH OF PARMS\n         LTR   R5,R5              IS IT ZERO ?\n         BZ    EOC                YES - NO PARMS\n         LA    R7,1(R7)\n         BCTR  R5,0\n         L     R1,PRINTBUF\n         STC   R5,PRNTCTL+1\n         MVC   0(MSG0LEN,R1),MSG0\nPRNTCTL  MVC   MSG0LEN(0,R1),1(R7)   PRINT OUT PARM FIELD\n         BAL   R6,PUTP2\n*\n         LA    R5,0(R5,R7)     GET ADDRESS OF LAST PARM BYTE\n         ST    R5,PARMEND        AND STORE IT IN PARMEND\nNEXTPARM CLI   2(R7),C'='     IS NEXT PARM A KEYWORD\n         BNE   KEYWRDER          NO-ERROR\n         LA    R2,0             YES. ZERO OUT R2 FOR USE IN TRT\n         LA    R15,OPTNTABL     LOAD ADDR OF KEYWORD TABLE\n         TRT   1(1,R7),0(15)   IS THIS A VALID KEYWORD\n         BZ    DUPKEYW              NO\n         IC    R1,0(0,R1)          YES-LOAD KEYWORD INTO R1\n         STC   R1,NOPOPTN+3\nNOPOPTN  MVI   0(R15),X'00'       BLANK OUT KEYWORD ON TABLE\n         LA    R7,2(R7)         POINT TO PARM VALUE\n         B     JUMPOFF2-4(R2)    JUMP TO CORRECT KEYWORD PROCESSING\nJUMPOFF2 B     GETR                  R=\n         B     GETC                  C=\n         B     GETS                  S=\n         B     GETT                  T=\n         B     GETF                  F=\n         B     GETN                  N=\n         B     GETD                  D=\n         TITLE 'PARM PROCESSING'\nTESTN    LA    R5,0\n         MVC   WORKFLD,MSGSPACE\nPVERLOOP C     R7,PARMEND           IS THIS THE END OF THE PARM\n         BH    VERPARM              YES\n         LA    R7,1(R7)             NO-GET NEXT PARM CHARACTER\n         CLI   0(R7),C','      ','= KEYWORD DELIMITER\n         BE    VERPARM1\n         IC    R9,0(0,R7)       PUT PARM CHARACTER INTO R9\n         STC   R9,WORKFLD(R5)   AND THENCE INTO WORKFLD1\n         LA    R5,1(R5)        R5=POINTER FOR WORKFLD1\n         C     R5,PARMLIM      PARMS NOT ALLOWED TO EXCEED 8 CHARS\n         BH    PARMLNER\n         B     PVERLOOP         FILL UP WORKFLD1 WITH KEYWORD VALUE\nVERPARM  MVI   ENDPARMS,C'1'    1 INDICATES END OF PARM\nVERPARM1 LTR   R5,R5            PARM EMPTY\n         BZ    NXT              YES-OK GO TO NEXT PARAMETER\n         BCTR  R5,0\nBACKWTST MVI   NUMBERR,C' '\n         EX    R5,VERNUMLP     TEST TO SEE IF PARM IS NUMERIC\n         BNZ   VERNUMER\n         EX    R5,PKVNUM       PACK PARM INTO WORKFLD1\n         CP    WORKFLD1,ONE    IS PARM VALUE = 0\n         BL    NXT             YES-OK USE DEFAULT\n         BR    R6\n*\nVERNUMER MVI   NUMBERR,C'1'\n         BR    R6\nVERNUMLP TRT   WORKFLD(1),TRNSTAB2\nPKVNUM   PACK  WORKFLD1,WORKFLD(1)\n         TITLE 'T=, R= AND C= PARM PROCESSING'\nGETT     MVC   PARMLIM,=F'65'\n         ST    R7,TITADDR     STORE STARTING ADDRESS OF TITLE\n         BAL   R6,TESTN       EXECUTE TESTN TO GET LENGTH OF TITLE\n         L     R9,TITADDR     LOAD R1 WITH ADDR OF TITLE FOR PRINTING\n         LA    R9,1(R9)       POINT BEYOND THE EQUAL SIGN TO TITLE\n         STC   R5,TITMV+1\nTITMV    MVC   TITLE+2(0),0(R9) SAVE TITLE FOR PRTING ON EACH PAGE\n         MVC   PARMLIM,=F'8'\n         B     NXT             GET NEXT PARM\n         SPACE 1\nGETR     BAL   R6,TESTN\n         MVI   RLENFLAG,C'1'     FLAG TO INDICATE USER CODED R=\n         CLI   NUMBERR,C'1'\n         BE    CHKVAR            IS R=V (VARIABLE RECFM) REQUESTED\n         ZAP   RLEN,WORKFLD1     PUT R= PARM INTO RLEN\n         B     NXT\n         SPACE 1\nCHKVAR   CLI   WORKFLD,C'V'      R=V\n         BNE   PMNUMBER         NO-ERROR\n         MVI   VARFLAG,C'V'   NOP FOR VARIABLE LENGTH RECORDS\n         MVI   REC1BLK+1,X'00'   NOP FOR VARIABLE LENGTH RECORDS\n         MVI   NXTREC+1,X'00'\n         B     NXT\n         SPACE 1\nGETC     BAL   R6,TESTN\n         CLI   NUMBERR,C'1'\n         BE    CHKBACKW\nCNTPROC  MVI   CNTSW+1,X'00'    NOP THE BRANCH TO OUTPUT ONLY C= BLOCKS\n         ZAP   LIMIT,WORKFLD1     PRINT ONLY 'LIMIT' BLOCKS\n         B     NXT\n         SPACE 1\nCHKBACKW CLI   WORKFLD,C'-'   IS BACKWARD OPTION REQUESTED (NEGAT. CNT)\n         BNE   CHKFINSH  NO- IS '+' REQU - STOP BEFORE END OF FILE\n         MVI   BACKWOPN+1,X'F0' YES-SET BRANCH FOR BACKWARD OPEN\n         MESSAGE 17\nRETURNC  MVI   WORKFLD,C'0'   YES-REPLACE '-' WITH A ZERO\n         BAL   R6,BACKWTST    CHECK FOR NO OTHER ERRORS\n         CLI   NUMBERR,C'1'   IS THERE ANUMERIC ERROR\n         BE    PMNUMBER          YES\n         B     CNTPROC\n         SPACE 1\nCHKFINSH CLI   WORKFLD,C'+'   IS STOP BEFORE END OF FILE REQUESTED\n         BNE   PMNUMBER       NO- ERROR\n         MVI   FINSHFIL+1,X'F0'  SET BRANCH TO STOP PROCESSING\n         MESSAGE 18,BRANCH=RETURNC\n         TITLE 'S=, F= AND N= PARM PROCESSING'\nGETS     BAL   R6,TESTN\n         CLI   NUMBERR,C'1'\n         BE    PMNUMBER\n         ZAP   SKPCNT,WORKFLD1\n         ED    MSG11SKP,SKPCNT+3\n         MESSAGE 11,BRANCH=NXT\n         SPACE 1\nGETF     BAL   R6,TESTN      GET FORMAT PARAMETER INTO WORKFLD\n         LTR   R5,R5      IS THERE JUST 1 SUBPARM\n         BZ    ACHCHK     YES\n         CLI   WORKFLD+1,C'P'  2ND BYTE =P:PARTIAL BLOCK LISTING ONLY\n         BNE   FORMATL         NO\n         MVI   FORMATP+1,X'F0' SET BRANCH TO ONLY PRT 1ST LINE OF BLOCK\n         B     ACHCHK\nFORMATL  CLI   WORKFLD+1,C'L'  2ND BYTE OF WORKFLD IS FOR LOC/REMOTE\n         BNE   FORMATER   ERROR-SECOND BYTE NOT L\n         MVI   REMOTESW+1,X'F0'  YES-SET THE B TO BYPASS REMOTE TABLE\n         MVI   REMOTSW2,X'47'  YES-NOP THE USE OF THE REMOTE TABLE\nACHCHK   CLI   WORKFLD,C'C'    IS CHARACTER ONLY PRINTOUT WANTED\n         BE    NXT                        YES\n         MVI   LINECT+1,X'00'   PUT OUT RULER LINE\n         CLI   WORKFLD,C'R'     IS RULER LINE ON CHARACTER ONLY REQU\n         BE    NXT            YES\n         MVI   HEXSW+1,X'00'\n         CLI   WORKFLD,C'H'  IS THIS THE HEX OPTION\n         BE    NXT\n         MVI   ASCIISW+1,X'00'\n         CLI   WORKFLD,C'A'   IS ASCII TRANSLATION REQUESTED\n         BE    NXT            YES\n         CLI   WORKFLD,C'B'   ARE BOTH ASCII AND EBXDIC REQUESTED\n         BNE   FORMATER       NO- INVALID FORMAT\n         MVI   ASCIEBCD+1,X'00' SET NOP TO PRINT BOTH\n         B     NXT\n         SPACE 1\nGETN     BAL   R6,TESTN\n         CLI   NUMBERR,C'1'\n         BE    PMNUMBER\n         ZAP   FILES,WORKFLD1    NUMBER OF DATA SETS TO BE COPIED\n         ED    MSG13NEQ,FILES+3\n         MESSAGE 13,BRANCH=NXT\n         SPACE 1\nGETD     BAL   R6,TESTN\n         CLI   NUMBERR,C'1'\n         BE    PMNUMBER\n         ZAP   DIAGRECS,WORKFLD1  NUMBER OF DIAGNOSTIC RECORDS TO WRITE\n*        ED    MSG.....,DIAGRECS+3\n*        MESSAGE ..,BRANCH=NXT\n         B     NXT\n         SPACE 2\nNXT      CLI   ENDPARMS,C'1'\n         BE    EOC\n         B     NEXTPARM\n         TITLE 'TIOT ROUTINE'\nCALLTIOT SR    R5,R5\n         USING PSA,R5\n         L     R5,PSATOLD\n         USING TCB,R5\n         L     R5,TCBJSCB\n         USING IEZJSCB,R5\n         L     R5,JSCDSABQ\n         USING QDB,R5\n         L     R5,QDBFELMP\n         USING DSAB,R5\nDSABLOOP L     R4,DSABTIOT\n         CLC   TIOEDDNM,DDNAME\n         BE    FOUND\n         ICM   R5,15,DSABFCHN\n         BNZ   DSABLOOP\n         MVI   TIOTFLAG,C'0'\n         BR    R6\nFOUND    MVI   TIOTFLAG,C'1'\n         BR    R6\n         TITLE 'OPEN SYSUT2'\nEOC      MVC   DDNAME,=C'SYSUT1  '\n         CHCKTIOT\n         DEVTYPE DDNAME,DVCTYPE\n         CLI   DVCTYPE+2,X'80'    IS DEVICE A MAG TAPE\n         BNE   OPEN2           NO-BR TO NOT TAPE INPUT\n         MVI   VOLVER,X'18'    TURN ON TAPE VOL VER EXIT TO GET EXPDT\n         MVI   READX+1,X'00'      SET NOP FOR TAPE READ ROUTINE\n         LA    R5,TAPEX           EXCP DCB\n         B     OPENINPT           GO TO BEGIN\n         SPACE 1\nOPEN2    LA    R5,INPUT           FOR OTHER THAN TAPE\n         MVC   MSG40BLK+9(14),MSGSPACE   BLANK OUT SEQUENCE NO ON DISK\n         MVC   MSG40LBL+4(16),MSGSPACE   BLANK OUT DENSITY ON DISK\n         MVI   BACKWOPN+1,X'00'  DISALLOW BACKWARD OPEN ON DISK\n         ZAP   FILES,ONE         DISALLOW MORE THAN 1 FILE ON DISK\nOPENINPT RDJFCB ((R5))        GET INPUT JFCB\n         MVC   MSG40VOL,JFCBVOLS   GET VOLSER\n         MVC   MSG40DSN,JFCBDSNM   GET DSN\n         SPACE 1\n         LH    R1,JFCBFLSQ       GET DATA SET SEQUENCE NUMBER\n         LTR   R1,R1 IS LABEL=(0,TYPE) OR LABEL=(,TYPE) SPECIFIED-DEFLT\n         BNZ   NODEFLT           NO\n         LA    R1,1    YES - CHANGE TO LABEL=(1,TYPE)\n         STH   R1,JFCBFLSQ    AND PUT IN THE JFCB\nNODEFLT  CVD   R1,FILESQ           CONVERT SEQUENCE NO TO DECIMAL\n         ED    MSG40SEQ,FILESQ+5   AND EDIT IT INTO THE MESSAGE\n         TM    JFCBLTYP,JFCBLP  BLP?\n         BNO   NOTBLP           NO\n         MVC   MSG40LBL,=C'BLP'  YES\n         LA    R1,CKCONCAT       CHECK IF CONCATENATED TAPE BLP\n         DYNALLOC                ISSUE DYN INFO RETRIEVAL\n         TM    CONCPARM,X'80'    BIT 0=PERMANENT CONCATENATION\n         BO    CONCATER          YES- ERROR\n*\n*  FOLLOWING CODE FOR MULTI-VOLUME TAPE BLP PROCESSING\n         SR    R1,R1             CLEAR\n         IC    R1,JFCBNVOL       GET COUNT OF NUMBER OF VOLUMES\n         ST    R1,NVOLSAVE       SAVE COUNT\n         MVI   JFCBNVOL,X'01'    PROCESS JUST 1 VOL AT A TIME\n*  I.E. MAKE THE SYSTEM THINK THIS IS THE ONLY VOLUME UNTIL IT\n*  IT IS COMPLETELY PROCESSED, THE ADD 1 TO COUNT TO PROCESS NEXT VOL\n         B     BACKWOPN          BRANCH OUT\nNOTBLP   ZAP   FILES,ONE         DISALLOW MORE THAN 1 FILE IF NOT BLP\n         TM    JFCBLTYP,JFCNL    NL?\n         BNO   NOTNL\n         MVC   MSG40LBL,=C'NL '\nNOTNL    TM    JFCBLTYP,JFCSL    SL?\n         BNO   NOTSL\n         MVC   MSG40LBL,=C'SL '\nNOTSL    TM    JFCBLTYP,JFCNSL  NSL?\n         BNO   NOTNSL\n         MVC   MSG40LBL,=C'NSL'\nNOTNSL   TM    JFCBLTYP,JFCSUL  SUL?\n         BNO   NOTSUL\n         MVC   MSG40LBL,=C'SUL'\nNOTSUL   TM    JFCBLTYP,JFCBLTM    LTM?\n         BNO   NOTLTM\n         MVC   MSG40LBL,=C'LTM'\nNOTLTM   TM    JFCBLTYP,JFCBAL   AL?\n         BNO   BACKWOPN\n         MVC   MSG40LBL,=C'AL '\nBACKWOPN NOP   OPENBACK     SET TO BRANCH ON BACKWARD OPEN\nOPENREG  OPEN  ((R5)),TYPE=J OPEN (TYPE=J FOR DEFAULT LABEL)\nRDJFCB   RDJFCB ((R5)) RE-ISSUE RDJFCB TO PICK UP RECFM,LRECL,CRDT/XPDT\n*                                                                  NL\nCHKRECFM TM    JFCRECFM,JFCUND   IS RECFM=U\n         BNO   NOTU              NO\n         MVI   MSG39FVU,C'U'     YES\n         B     NOTV\nNOTU     TM    JFCRECFM,JFCFIX   IS RECFM=F\n         BNO   NOTF              NO\n         MVI   MSG39FVU,C'F'     YES\n         B     NOTV\nNOTF     TM    JFCRECFM,JFCVAR   IS RECFM=V\n         BNO   NOTV              NO\n         MVI   MSG39FVU,C'V'     YES\nNOTV     EQU   *\n         LH    R1,JFCLRECL       GET LRECL\n         CVD   R1,WORKFLD1\n         ED    MSG39REC,WORKFLD1+5\n         SPACE 1\n         CLI   RLENFLAG,C'1'     DID USER CODE R=\n         BE    GETDATES          YES\n         CLI   READX+1,X'00'     NO- IS THIS A TAPE FILE\n         BNE   ITSDISK           NO-ITS DISK, USE LRECL\n         CLC   MSG40LBL(2),=C'SL'   YES-IS IT SL TAPE\n         BNE   GETDATES          NO- USE R=100\nITSDISK  LTR   R1,R1             YES- IS LRECL=0 NEVETHELESS (RECFM=U)\n         BZ    GETDATES          YES\n         CVD   R1,RLEN           NO - USE RLEN=LRECL\n         SPACE 1\nGETDATES SR    R1,R1             CLEAR R1\n         IC    R1,JFCBCRDT       GET CREATION DATE-YY\n         CVD   R1,WORKFLD1\n         UNPK  WORKFLD1(3),WORKFLD1+6(2)   UNPK 3 BYTES\n         MVC   MSG39CRY,WORKFLD1+1\n         OI    MSG39CRY+1,X'F0'\n         ICM   R1,3,JFCBCRDT+1   GET CREATION DDD\n         CVD   R1,WORKFLD1\n         ED    MSG39CRD,WORKFLD1+6\n         SPACE\n         CLI   VOLVER,X'18' DID WE GET EXPDT FROM TAPE VOL VER EXIT\n         BE    STRTPROC          YES\n         SR    R1,R1         NO- CLEAR R1\n         IC    R1,JFCBXPDT       GET EXPIRATN DATE-YY\n         CVD   R1,WORKFLD1\n         UNPK  WORKFLD1(3),WORKFLD1+6(2)   UNPK 3 BYTES\n         MVC   MSG39EXY,WORKFLD1+1\n         OI    MSG39EXY+1,X'F0'\n         ICM   R1,3,JFCBXPDT+1   GET EXPIRATN DDD\n         CVD   R1,WORKFLD1\n         ED    MSG39EXD,WORKFLD1+6\n         SPACE\n         DROP  R4,R5   R4,R5 NO LONGER NEEDED FOR TIOT CHECKING\n         TITLE 'SKIP AND OPEN BACKWARD ROUTINE'\nSTRTPROC CP    SKPCNT,ONE\n         BL    RD1\n         CVB   R5,SKPCNT            NO\nEX       BAL   R6,READX      READ THRU S=SKIP NUMBER OF BLOCKS\n         BAL   R2,MSG19RTN   DO MSG 19 RTN\n         BCT   R5,EX\n         B     NXTBLK   SEE IF BLKCNT > LIMIT\n         SPACE 1\nOPENBACK OPEN  ((R5),RDBACK),TYPE=J  (TYPE=J IF DEFLT LABEL SPECIFIED)\n         L     R5,CCW           GET BUFFER ADDRESS\n         A     R5,F65535        SET R5 TO POINT TO LAST BYTE OF BUFFER\n         ST    R5,CCW           PUT NEW BUFFER ADDRESS IN CCW\n         MVI   CCW,X'0C'        SET CCW TO READ BACKWARD\n         MVI   BACKNOP+1,X'F0' CHK EOV1 IN LBL ON FORWRD TPE READ ONLY\n         MVI   BACKOFLG+1,X'44' SET EOV TO INDICATE LAST READ WAS BCKW\n         MVI   BACKBUF1+1,X'48' CHANGE NOP TO 'SR R4,R8'\n         MVI   BACKBUF2+3,X'01' CHNG NOP TO 'LA R4,1(R4)' ADD 1 TO PNT\n         MVI   REFLECT+1,X'02' CHNG NOP TO 'TM IOB+12,X'02' UNIT EXCEPT\n         ZAP   FILES,ONE   FORCE N=1 (ONE FILE ONLY ON BACKWARD READ)\n         CLI   VARFLAG,C'V'  IS R=V REQUESTED FOR BACKWARD OPEN\n         BNE   RDJFCB            NO-BR TO RDJFCB FOLLOWING REGULAR OPEN\n         L     R4,CCW  SET UP LEGIT ADDR IN R4 FOR CLC 0(2,R4),C'//'\nIGNREQV  MVI   REC1BLK+1,X'F0'   YES-IGNORE R=V\n         MVI   NXTREC+1,X'F0'\n         CLC   0(2,R4),=C'//'    IS THE DATA JCL?\n         BE    SETREQ80          YES\n         ZAP   RLEN,=P'100'  NO- USE DEFAULT R=100\n         B     VARERR\nSETREQ80 ZAP   RLEN,=P'80'       USE R=80 FOR PRINTING JCL\nVARERR   NOP   NXTRECNV    SET TO B WHEN R=V AND REC NOT VAR (ERROR)\n         B     RDJFCB      FOR BACKWARDS ONLY- BR TO RDJFCB AFTER OPEN\n         TITLE 'MAINLINE LOGIC'\nRD1      BAL   R6,READX          LINK TO READ ROUTINE (READ OR READX)\n         AP    BLKWRIT,ONE   ADD 1 TO BLOCKS WRITTEN\n         MVC   PNT+4(8),MASK\n         ED    PNT+4(8),BLKCNT+4   MOVE IN THE BLOCK NUMBER\n         MVC   PNT(5),=C'BLOCK'\n         CVD   R8,WORKFLD1            PRINT THE BLKSIZE\n         BAL   R2,MSG19RTN  BAD BLK DISPLAY ROUTINE (R6 USED FOR MSG)\n         MVC   PNT+16(8),MASK\n         ED    PNT+16(8),WORKFLD1+4\n         MVC   PNT+14(4),=C'SIZE'\n         MVC   PNT+31(100),NUMLINE\n         MVI   CC,C'0'      SKIP A BLANK LINE AFTER BLKCNT LINE\n         AP    LINES,ONE    ADD 1 TO LINE FOR BLANK LINE\n         BAL   R6,PUTP\n         LTR   R8,R8   ARE NUMBER OF BYTES IN BLOCK = 0\n         BZ    BLKERR  YES- I/O UNABLE TO READ DATA IN BLOCK\n         SPACE 1\nREC1BLK  B     NXTRECNV     SET TO NOP ON VARIABLE LENGTH RECS\n         CH    R8,0(R4)     IS BDW = BLKSIZE\n         BNE   VARIBER      NO - VARIABLE ERROR\n         LH    R3,4(R4)     GET RDW OF 1ST REC IN BLOCK\n         C     R3,=F'5'     IS RDW LESS THAN 5\n         BL    VARIBER      YES - RDW IS INVALID\n         LA    R3,4(R3)     ADD 4 TO RDW TO PRINT BDW WITH 1ST REC\n         CVD   R3,RLEN      INITIALIZE RLEN\n         B     VARREC\n*\nNXTREC   B     NXTRECNV     SET TO NOP ON VARIABLE LENGTH RECORDS\n         LH    R3,0(R4)     GET RDW OF REC (NOT 1ST REC OF BLOCK)\n         C     R3,=F'5'     IS RDW LESS THAN 5\n         BL    VARIBER      YES - RDW IS INVALID\n         CVD   R3,RLEN      INITIALIZE RLEN\n         B     VARREC\n*\nNXTRECNV CVB   R3,RLEN         R3=RECORD LENGTH\nVARREC   MVI   FORMTLIN+1,X'00'\n         MVI   CC,C'0'   SKIP A LINE BEFORE NEW RECORD\n         AP    LINES,ONE    ADD 1 TO LINE FOR BLANK LINE\nSAMEREC  LR    R10,R3    R10=THE LESSER OF R3, R8 AND 100\n         CR    R10,R8          R8=REMAINING BLKSIZE\n         BH    RECMORE\nCOMP100  CVD   R10,WORKFLD1\n         C     R10,=F'100'\n         BH    LINELESS\nFORMTLIN NOP   PRINTLIN\n         AP    RCNT,ONE\n         MVC   PNT+4(8),MASK\n         ED    PNT+4(8),RCNT\n         MVC   PNT+14(3),=C'LEN'\n         MVC   PNT+18(6),MASK  MOVE IN MASK FOR RECORD LENGTH\n         ED    PNT+18(6),WORKFLD1+5\n         SPACE 1\nPRINTLIN LR    R9,R10\n         BCTR  R9,0\n         STC   R9,STORLEN+1\n         STC   R9,PRNTCHAR+1\n         STC   R9,LNO+1       ADJUST THE LENGTH OF THE RULER LINE\nSTORLEN  MVC   HEXAREA,0(R4)      MOVE TO THE WORKAREA\nASCIISW  B     REMOTESW            NOP IF ASCII OPTION IS REQUESTED\n         XLATE HEXAREA,100,TO=E   TRANSLATE ASCII TO EBCDIC\n         MVC   PNT+27(3),=C'ASC'   INDICATE EBCDIC LINE\nREMOTESW NOP   PRNTCHAR      B  IF LOCAL PRINTER REQUESTED\n         STC   R9,REMOTETR+1    SET LENGTH OF TRANSLATE\nREMOTETR TR    HEXAREA,TABLE4\nPRNTCHAR MVC   PNT+31(0),HEXAREA  MOVE LINE FOR PRINTING\n         BAL   R6,PUTP\nASCIEBCD B     HEXSW       SET TO NOP WHEN BOTH ASCII AND EBCDIC REQU\n         EX    0,STORLEN         MOVE ORIGINAL RECORD INTO HEXAREA\nREMOTSW2 EX    0,REMOTETR  TRANSLATE FOR REMOTE PRINTER, NOP ON F=XL\n         EX    0,PRNTCHAR        PRINT EBCDIC CHARACTER LINE\n         MVC   PNT+27(3),=C'EBC'   INDICATE EBCDIC LINE\n         BAL   R6,PUTP\n         SPACE 1\nHEXSW    B     LINECT             NOP IF HEX SPECIFIED\n         XC    HEXAREA,HEXAREA\n         STC   R9,MOVEZONE+1\n         STC   R9,TRANSZN+1\n         STC   R9,MOVENUMR+1\n         STC   R9,TRANSNO+1\nMOVEZONE MVZ   HEXAREA,0(R4)\nTRANSZN  TR    HEXAREA,TABLE2\n         EX    0,PRNTCHAR\n         BAL   R6,PUTP\n         XC    HEXAREA,HEXAREA\nMOVENUMR MVN   HEXAREA,0(R4)\nTRANSNO  TR    HEXAREA,TABLE3\n         EX    0,PRNTCHAR\n         BAL   R6,PUTP\nLINECT   B     CONTINPR     CHANGED TO NOP IF NOT(F=C OR DEFAULT)\nLNO      MVC   PNT+31(0),NUMLINE\n         BAL   R6,PUTP\n         SPACE 1\nCONTINPR AR    R4,R10           R4=ADDRESS OF RECORD BUFFER AREA\n         SR    R8,R10\nFORMATP  BNP   NXTBLK           CHANGED TO BRANCH WHEN F=XP\n         SR    R3,R10\n         BZ    NXTREC\n         MVI   FORMTLIN+1,X'F0'\n         B     SAMEREC\n         SPACE 1\nRECMORE  LR    R10,R8\n         B     COMP100\nLINELESS LA    R10,100\n         B     FORMTLIN\n         SPACE 3\nNXTBLK   EQU   *\nCNTSW    B     RD1                NOP IF COUNT SPECIFIED\n         CP    BLKWRIT,LIMIT   IS BLOCK COUNT PARAMETER SATISFIED\n         BL    RD1              NO\nFINSHFIL NOP   QUIT        SET TO BRANCH IF C=+COUNT CODED\n         SR    R5,R5       YES-CREATE INFINITE LOOP BY PUTTING 0 IN R5\n         B     EX          GO TO SPACE FORWARD ROUTINE\n         TITLE 'READ AND WRITE ROUTINES'\nREADX    B     READ         READ FORWARD CODE IS X'02' FOR TAPE READ\n         L     R4,CCW       LOAD ADDRESS OF THE BUFFER\n         EXCP  IOB\n         WAIT  ECB=ECB\n         SPACE 3\nDENCK    NOP   DENCKEND        SET TO BRANCH AFTER FIRST TIME THRU\nDIAGNOP  MVI   DENCK+1,X'F0'   SET BRANCH\n         MVC   MSG40DEN(7),MSGSPACE   BLANK OUT DENSITY AND P-TRK  NL\n         EXCP  IOB1         GET TAPE DRIVE SENSE BYTES             NL\n         WAIT  ECB=ECB1                                            NL\n         TM    DVCTYPE+3,X'80' (UCBTYPE) IS IT 3480 CARTRIDGE TAPE NL\n         BNO   TAPEDEN           NO                                NL\n         MVC   MSG40DEN(5),=C'38000'   YES 38000 BPI               NL\n         MVC   MSG40TRK(2),=C'18'   18 TRK TAPES                   NL\n         ZAP   DENSITY,=PL3'38000'                                 NL\n         MVI   IBGLEN,X'8C'         IBG=.08 INCHES                 NL\n         MVI   SRP+5,SHFT3480   SET SHIFT TO DIVIDE BY 100         NL\n         B     DENCKEND         NOW CHECK RECFM                    NL\n         SPACE 1                                                   NL\nTAPEDEN  TM    SENSE6,X'10'  IS TAPE T1600                         NL\n         BO    TEST6250                                            NL\n         MVC   MSG40DEN(5),=C' 1600'  YES                          NL\n         MVI   MSG40TRK,C'9'                                       NL\n         ZAP   DENSITY,=PL3'1600'  SET DEN VAR TO 1600 FOR CALC    NL\n         MVI   IBGLEN,X'6C'     SET INT-BLK-GAP LNGTH TO .6 INCHES NL\n         B     CHKTRK7                                             NL\nTEST6250 TM    SENSE6,X'08'     IS DRIVE 3420-4,-6,-8              NL\n         BNO   NOT6250          NO - TAPE IS THEN 800BPI           NL\n         MVC   MSG40DEN(5),=C' 6250'  YES TAPE IS 6250BPI          NL\n         ZAP   DENSITY,=PL3'6250' SET DEN VAR TO 6250 FOR CALC     NL\n         MVI   IBGLEN,X'3C'  SET INT-BLK-GAP LNGTH TO .3 INCHES    NL\n         B     CHKTRK7                                             NL\nNOT6250  MVC   MSG40DEN(5),=C'  800'  TAPE IS 800BPI               NL\n         ZAP   DENSITY,=PL3'800'  SET DEN VAR TO 800 FOR CALC      NL\n         MVI   IBGLEN,X'6C'     SET INT-BLK-GAP LNGTH TO .6 INCHES NL\nCHKTRK7  TM    SENSE6,X'80'     IS 7-TRK RECORDING MODE USED       NL\n         BNO   TRK9             NO - IT IS 9 TRACK                 NL\n         MVI   MSG40TRK,C'7'  YES - IT IS 7 TRACK           NL\n         MVI   IBGLEN,X'7C'           SET IBG TO .7 INCHES         NL\n         B     DENCKEND                                            NL\nTRK9     MVI   MSG40TRK,C'9'  NO - IT IS 9 TRACK            NL\n         SPACE 1\nDENCKEND B     SKIPDIAG          SET TO NOP IF DIAGNOSE REQUESTED\n         AP    DIAGPUTS,ONE      ADD 1 TO RECS WRITTEN TO DIAG FILE\n         CP    DIAGPUTS,DIAGRECS HAVE WE WRITTEN THE REQUESTED AMOUNT\n         BH    SKIPDIAG          YES\n         MVC   STATUS,IOB+12     MOVE IN UNIT AND CHANNEL STATUS BYTES\nPRTDIAG  NOP   PRTDIAG2          CHNG TO BRANCH IF DIAGNOSE IS SYSOUT\n         PUT   DIAGNOSE,SBYTES\nSKIPDIAG EQU   *\n         SPACE 3\n         TM    IOB+12,X'01'       TEST FOR TM (UNIT EXCEPTION)\n         BO    TPMK            END OF DATA SET\nREFLECT  TM    IOB+12,X'00' CHG TO X'02' ON READBACK FOR UNIT CHECK\n         BNO   UNTCKRET     NO UNIT CHECK\n         TM    IOB+3,X'08'  YES- CHECK 2ND SENSE BYTE FOR LOAD POINT\n         BO    QUIT         BEGINNING OF TAPE HIT\nUNTCKRET L     R8,F65535      LOAD LENGTH OF BUFFER\n         LH    R9,IOB+14   GET RESIDUAL COUNT\n         SLL   R9,16         AND PUSH OUT HIGH ORDER SIGN BITS\n         SRL   R9,16         WHEN RESIDUAL COUNT EXCEEDS 32K\n         SR    R8,R9        GET BLOCK LENGTH IN R8\n         BZR   R6     RETURN TO MAIN ROUTINE IF BLKSIZE=0\n         CLI   HDRFLAG,C'2'    HAVE WE READ A TM AFTER A HDR LABEL\n         BNE   BACKNOP         NO\n         MVI   HDRFLAG,C'0'    YES-RESET FLAG AFTER READING MORE DATA\n         SPACE 1\n*   NXT PARAGR FOR EOV1/HDR1 CHECK ON TAPE LABELS-SKIP WHEN BACKW READ\nBACKNOP  NOP   BACKBUF1    SET TO BRANCH WHEN BACKWARD READ\n         C     R8,=F'80'      IS THE BLKSIZE = 80 (FOR LABEL RECORD)\n         BNE   BACKBUF1    NO\n         CLC   0(4,R4),=C'EOV1' YES-EOV1 THE FIRST 4 CHARS OF RECORD?\n         BNE   CHKHDR     NO\n         MVI   EOVFLAG,C'1' YES- SET EOV FLAG- CHECKED WHEN TPMK HIT\n         B     BACKBUF1\n         SPACE 1\nCHKHDR   CLC   0(4,R4),=C'HDR1'  HDR1 THE FIRST 4 BYTES OF RECORD?\n         BNE   BACKBUF1    NO\n         MVI   HDRFLAG,C'1'      YES - SET HDR FLAG\n         SPACE 1\nBACKBUF1 SR    0,0   NOP CHANGED TO SR R4,R8 ON BACKWARD READ\nBACKBUF2 LA    R4,0(R4) NOP CHNG TO LA R4,1(R4)-BACKWARD READ\nMINMAX   AP    BLKCNT,ONE            ADD 1 TO NUMBER OF BLOCKS\n         CVD   R8,WORKFLD1     PUT BLKSIZE IN WORKFLD1\n         AP    TOTBYTES,WORKFLD1 ADD BLKSIZE TO TOTAL NUMBER OF BYTES\n         ST    R8,LASTBLK      STORE THE BLKSIZE OF THE LAST BLOCK\n         MVC   MINBLK(4),SAVEMIN  PUT PREV MIN IN MINBLK\n         C     R8,SAVEMIN\n         BNL   MINMAX2\n         ST    R8,SAVEMIN\nMINMAX2  C     R8,MAXBLK\n         BNHR  R6\n         ST    R8,MAXBLK\n         BR    R6\n         SPACE 1\nREAD     L     R4,CCW             FOR DISK READ\n         READ  DECB,SF,INPUT,(R4),'S'\n         CHECK DECB\n         LH    R8,INPUT+62     LOAD BLKSIZE INTO R8\n         L     R2,DECB+16      LOAD IOB ADDRESS INTO R2\n         SH    R8,14(R2)   SUBTRACT RESID CNT- BLK LENG IN R8\n         B     MINMAX\n         SPACE 1\nPUTP     CP    LINES,=P'58'   HAVE 58 LINES BEEN PRINTED ON PAGE\n         BL    PUTP1          NOT YET\n         ZAP   LINES,ONE      YES - SET PAGE LINE COUNTER TO 1\n         PUT   PRINTER,TITLE  PRINT TITLE\n         MVI   TITLE,C'1'     SET TITLE TO SKIP TO NEW PAGE\nPUTP1    PUT   PRINTER,CC\n         MVC   PNT,PNT-1\n         MVI   CC,C' '\n         AP    LINES,ONE\n         BR    R6\n         SPACE 1\nPUTP2    PUT   SYSPRINT\n         ST    R1,PRINTBUF\n         MVI   0(R1),C' '\n         MVC   1(132,R1),0(R1)\n         BR    R6\n         SPACE 1\nPRTDIAG2 MVC   PNT+31(40),NUMLINE    PRINT RULER\n         MVI   CC,C'0'\n         ST    R6,SAVER6              SAVE BAL REGISTER\n         BAL   R6,PUTDIAG\n         MVZ   HEXAREA(40),SBYTES     PRINT FIRST HEX LINE\n         TR    HEXAREA(40),TABLE2\n         MVC   PNT+31(40),HEXAREA\n         BAL   R6,PUTDIAG\n         XC    HEXAREA(40),HEXAREA    ZERO OUT\n         MVN   HEXAREA(40),SBYTES     PRINT SECOND HEX LINE\n         TR    HEXAREA(40),TABLE3\n         MVC   PNT+31(40),HEXAREA\n         BAL   R6,PUTDIAG\n         L     R6,SAVER6          RESTORE BAL REGISTER\n         B     SKIPDIAG\n         SPACE 1\nPUTDIAG  PUT   DIAGNOSE,CC            PRINT DIAGNOSE\n         MVC   PNT,PNT-1\n         MVI   CC,C' '\n         BR    R6\n         TITLE 'TAPEMARK AND EOJ ROUTINES'\nTPMK     CLI   HDRFLAG,C'1'     WAS A HDR LABEL JUST READ?\n         BNE   NOHDR            NO\n         MVI   HDRFLAG,C'2'     INDICATE WE HAVE JUST PROCESSED A HDR\nNOHDR    EQU   *                FOLLOWED BY A TPMK\n         MVC   PNT(9),=C'TAPE MARK'   PRINT TAPE MARK\n         MVC   PNT+11(6),MSG40SEQ   PRINT ABSOLUTE FILE SEQ NO\n         MVI   PNT+18,C'*'     MOVE ASTERISKS TO REST OF LINE\n         MVC   PNT+19(113),PNT+18    RIPPLE\n         MVI   CC,C'0'\n         AP    LINES,ONE\n         BAL   R6,PUTP\n         ZAP   WORKFLD1,BLKCNT    GET TOTAL BLOCK COUNT\n         SP    WORKFLD1,EOVBLKCT  SUBTACT PRIOR VOLUMES'S BLKCNT\n         CVB   R1,WORKFLD1  GET THE NO.OF BLOCKS PROCESSED ON THIS VOL\n         ST    R1,TAPEX+12  PLACE IT IN DCBBLKCT FIELD FOR LABL VERIFY\n         ZAP   EOVBLKCT,BLKCNT\n*        TM    JFCBLTYP,JFCNL+JFCBLP  IS LABEL TYPE=NL OR BLP\n*        BM    QUIT      SKIP EOV RTN-TO ALLOW MULTIPLE FILE PROCESS\n* ABOVE COMMENTED - NOT ISSUING EOV CAUSED OUT OF SYNC ON MULTI-FILES\nBACKOFLG OI    TAPEX+48,X'04' SET BIT 5 OF DCBOFLAGS TO INDICATE A TM\n         EOV   TAPEX HAS BEEN READ & BRANCH TO EODAD ROUTINE (QUIT) FOR\n*    EOF OR DO VOLUME SWITCHING FOR EOV (FOR STANDARD LABEL PROCESSING)\n         L     R1,TAPEX+44   END OF FILE NOT HIT SO GET DEB ADDRESS\n         L     R1,32(,R1)    GET UCB ADDR\n         MVC   MSG25VOL,28(R1)    GET VOLSER OF SWITCHED VOLUME\n         ED    MSG25BLK,BLKCNT+4 GET NO OF BLKS PROCESSED AT SWITCHTIME\n         MESSAGE 25               PUT OUT VOLUME SWITCH MESSAGE\n         CLI   EOVFLAG,C'2'   HAS VOLUME ALREADY BEEN SWITCHED ON\n*                 MULTI-VOLUME TAPE BLP\n         BNE   NXTBLK     NO- CONTINUE PROCESSING\n         MVC   MSG40VOL,MSG25VOL    YES- SET MSG40 WITH NEW VOLSER\n         SR    R1,R1      CLEAR\n         IC    R1,JFCBNVOL     RESET VOL SEQ # TO VOL BEING PROCESSED\n         STH   R1,JFCBVLSQ\n         B     NXTBLK     CONTINUE PROCEESSING\n         SPACE 2\nQUIT     CP    BLKCNT,ONE    2 CONSECTUTIVE TPMKS ENCOUNTERED\n         BL    CHKEOV               YES\n         AP    FILEPROC,ONE NO-ADD 1 TO NUMBER OF DATA SETS PROCESS\n         ED    MSG40BLK,BLKCNT+4\n         MESSAGE 40\n         MESSAGE 39\n         CP    BLKCNT,ONE   IS THERE ONLY 1 BLOCK IN THE FILE\n         BH    LDMINBLK     NO\n         MVC   MINBLK(4),SAVEMIN  YES-USE SAVEMIN AS ACTUAL MIN\nLDMINBLK L     R1,MINBLK\n         CVD   R1,WORKFLD1\n         ED    MSG12MIN,WORKFLD1+5\n         L     R1,MAXBLK\n         CVD   R1,WORKFLD1\n         ED    MSG12MAX,WORKFLD1+5\n         C     R1,=F'32767'        IS MAX BLKSIZE > 32K?\n         BH    BLKGT32K            YES\nBLKMSG   EQU   *\n         L     R1,LASTBLK\n         CVD   R1,WORKFLD1\n         ED    MSG12LST,WORKFLD1+5\n         ED    MSG12BYT,TOTBYTES+2\n         MESSAGE 12\n         ED    MSG10CNT,BLKWRIT+3   NUMBER OF BLOCKS DUMPED\n         MESSAGE 10\n         CP    SKPCNT,BLKCNT\n         BNL   NOBLKS\n         AP    BLKWRIT,SKPCNT\n         CP    BLKWRIT,BLKCNT\n         BE    EOFMSG\nQUIT2    CLI   READX+1,X'00'   IS THIS A TAPE FILE\n         BNE   QUIT3           NO\n         CP    DENSITY,PZERO   YES- IS DENSITY 6250/1600/800/38000?\n         BE    QUIT3           NO\n         DP    TOTBYTES,DENSITY THE QUOTIENT GOES INTO FIRST 5 BYTES\n         SP    BLKCNT,ONE      ONE LESS IBG THAN THERE BLOCKS\n         MP    BLKCNT,IBGLEN    MULTIPLY INTER-REC-BLK LEN BY # BLKS\nSRP      SRP   BLKCNT,64-1,0   DIVIDE BY 10-SHIFT RIGHT 1 WITH NO ROUND\n*          MODIFIED FOR 3480 CARTRIDGE TO DIVIDE BY 100 SINCE IBG=.08\n         AP    BLKCNT,TOTBYTES(5)\n         AP    BLKCNT,ONE\n         ED    MSG21TPL,BLKCNT+3\n         MESSAGE 21\n         AP    TAPELEN,BLKCNT  SUM FOR TOTAL TAPE LENGTH\nQUIT3    CLI   EOVFLAG,C'1'    HAS EOV1 BEEN HIT IN A TAPE LABEL\n         BE    EOVMSG          YES-END (SO TAPE DOESNT RUN OFF REEL)\n*        SINCE MULTI-REEL DATASETS ONLY HAVE 1 TPMK FOLLOWING EOV LABL\n         CP    FILES,FILEPROC  IS N= PARAMETER SATISFIED\n         BH    REINIT          NO\n         SPACE 2\nCLOSE    CLOSE (TAPEX,,PRINTER,,DIAGNOSE)\n         CP    FILEPROC,ONE       HAVS MORE THAN 1 FILE BEEN PROCESSED\n         BNH   CKTAPCPY\n         ED    MSG23TPL,TAPELEN+3\n         MESSAGE 23            TOTAL LENGTH OF TAPE PROCESSED\n         USING TIOENTRY,R4\nCKTAPCPY MVC   DDNAME,=C'TAPECOPY'   IS THERE A TAPECOPY DD STATEMENT\n         CHCKTIOT FOUND=DOTAPCPY,NOTFND=RETURN\nRETURN   CLOSE (SYSPRINT)\n         L     R13,SAVEAREA+4\n         LM    R14,R12,12(R13)\nRCSPOT   LA    R15,0      RETURN CODE (MODIFIED)\n         BR    R14\n         SPACE 1\nBLKCTXIT ST    R14,SAVER14    SAVE R14\n         CVD   R0,WORKFLD1    TRAILER LABEL BLOCK COUNT IN R0\n         ED    MSG24LBL,WORKFLD1+4\n         L     R1,12(0,R1)    GET DCB BLKCT-AT OFFSET 12 IN DCB (R1)\n         CVD   R1,WORKFLD1\n         ED    MSG24BLK,WORKFLD1+4\n         MESSAGE 24      PUT OUT WARNING- LABEL BLK CNT NOT= ACTUAL\n         L     R14,SAVER14    RESTORE R14\n         LA    R15,4     IGNORE BLOCKCOUNT UNEQUAL CONDITION\n         BR    R14       RETURN\n         SPACE 1\nVOLVERXT ST    R14,SAVER14    SAVE R14\n         USING OEVSID,R1      SET BASE\n         L     R2,OEVSHDR1    GET ADDR OF TAPE LABEL HEADER\n         MVC   MSG39EXY(2),48(R2)   GET YY OF EXPIRATION DATE\n         MVC   MSG39EXD+1(3),50(R2)   GET DDD OF XPIRATION DATE\n         DROP  R1\n         L     R14,SAVER14    RESTORE R14\n         SR    R15,R15   RETURN NORMALLY TO OPEN/EOV\n         BR    R14       RETURN\n         SPACE 1\nEOFMSG   MESSAGE 2,BRANCH=QUIT2\nTIOTERR  MESSAGE 3,BRANCH=ER\nKEYWRDER MESSAGE 4,BRANCH=ER\nDUPKEYW  MESSAGE 5,BRANCH=ER\nPARMLNER MESSAGE 6,BRANCH=ER\nPMNUMBER MESSAGE 8,BRANCH=ER\nFORMATER MESSAGE 9,BRANCH=ER\nVARIBER  MVI   VARERR+1,X'F0'  SET BRANCH TO SKIP OVER READ\n         MESSAGE 14,BRANCH=IGNREQV\nNOBLKS   MESSAGE 15,BRANCH=QUIT2\nCONCATER MESSAGE 26,BRANCH=ER        TAPE BLP CONCATENATION\nBLKGT32K MESSAGE 27,BRANCH=BLKMSG    WARNING - BLKSIZE > 32K\nEOVMSG   MESSAGE 16     ADDED LOGIC TO PROCESS MULTI-VOL TAPES BLP\n         SR    R1,R1             CLEAR\n         IC    R1,JFCBNVOL       GET NUMBER OF VOLUMES\n         C     R1,NVOLSAVE       HAVE WE PROCESSED ALL VOLUMES\n         BNL   CLOSE             YES - ALL DONE\n         LA    R1,1(R1)          ADD 1 TO PROCESS NEXT VOLUME\n         STC   R1,JFCBNVOL       MODIFY JFCB\n         ZAP   FILESQ,PZERO      RESET FILESQ COUNTER\n         MVI   ENDINIT+1,X'00'   SET NOP TO BRANCH TO EOV\n         MVI   EOVFLAG,C'2'  SET EOV FLAG TO INDICATE ALREADY SWITCHED\n         MVC   MSG25VOL+6(19),MSGSPACE  BLANK OUT BLOCK COUNT\n         B     REINIT            REINIT FIELDS\n         SPACE 2\nSASFILER MVI   RCSPOT+3,X'08'    DYNAMIC ALLOC FOR A SAS FILE FAILED\n         MESSAGE 20,BRANCH=RETURN\nBLKERR   MVC   PNT(29),=C' UNABLE TO READ DATA IN BLOCK'\n         BAL   R6,PUTP     WRITE MSG\n         B     NXTBLK      GET NEXT BLOCK\n         SPACE 1\nER       MVI   RCSPOT+3,X'08'     STORE RET CODE 8 FOR EXIT ROUTINE\n         MESSAGE 1,BRANCH=CLOSE\n         SPACE 1\nNOSYSPRT LA    R1,REQBLKP\n         DYNALLOC\n         LH    R15,RBERR    ERROR\n         LTR   R15,R15      WAS SYSPRINT DYNAMICALLY ALLOCATED\n         BNZ   NOPRINT NO-BRANCH TO WRITE 'NO SYSPRINT' MSG ON CONSOLE\n         WTO   'SYSPRINT FILE DYNAMICALLY ALLOCATED TO SYSOUT=*'\n         B     SYSPRNT   OPEN SYSPRINT,SET TO NOP IF SYSUT2 NOT IN JCL\n         SPACE 1\nNOSYSUT2 LA    R1,REQBLKP\n         DYNALLOC\n         LH    R15,RBERR    ERROR\n         LTR   R15,R15      WAS SYSPRINT DYNAMICALLY ALLOCATED\n         BNZ   TIOTERR      NO\n         WTO   'SYSUT2 FILE DYNAMICALLY ALLOCATED TO SYSOUT=*'\n         B     SYSUT2    BRANCH TO OPEN SYSUT2\n         SPACE 1\nNOPRINT  MVI   RCSPOT+3,X'FF' SET RETURN CD TO 255-CANT ALLOC SYSPRINT\n         WTO   'SYSPRINT DD STATEMENT MISSING'\n         B     CLOSE                  GET OUT\n         SPACE 1\nREINIT   MVC   MINBLK,F65535     RESET MINIMUM BLKSIZE\n         MVC   SAVEMIN,F65535 RESET MINIMUM BLKSIZE\n         XC    MAXBLK,MAXBLK     RESET MAXIMUM BLKSIZE TO LOW VALUES\n         XC    LASTBLK,LASTBLK  RESET LAST BLKSIZE\n         MVC   MSG10CNT,MASK     RESET MASKS\n         MVC   MSG12MIN,MASK\n         MVC   MSG12MAX,MASK\n         MVC   MSG12LST,MASK\n         MVC   MSG12BYT,MASK\n         MVC   MSG21TPL,MASK\n         MVC   MSG24BLK,MASK\n         MVC   MSG24LBL,MASK\n         MVC   MSG25BLK,MASK\n         MVC   MSG40BLK,MASK\n         MVC   MSG40SEQ,MASK\n*        MVC   MSG39REC,MASK    MSG39 NEED NOT BE RE-INIT, USED ONLY\n*        MVC   MSG39CRD,MASK          FOR DISK AND SL TAPES (N=1 ONLY)\n*        MVC   MSG39EXD,MASK\n         ZAP   BLKCNT,PZERO     RESET BLOCK COUNT\n         ZAP   BLKWRIT,PZERO\n         ZAP   RCNT,PZERO       RESET RECORD COUNT\n         ZAP   TOTBYTES,PZERO   RESET TOTAL BYTE COUNT\n         ZAP   SAVEBLK,=P'-1'  RESET THE PREV BLK\n         ZAP   MSG19CNT,PZERO   RESET MSG 19 COUNTER (MAX 10)\n         MVI   DENCK+1,X'00'    RESET TO GET DENSITY OF NEXT FILE\n         ZAP   DIAGPUTS,PZERO   RESET FOR DIAGNOSE FILE\n         BAL   R6,PUTP2      SKIP EXTRA LINE BETWEEN SYSPRINT GROUPS\n         AP    FILESQ,ONE       ADD 1 TO NUMBER OF FILES PROCESSED\n         ED    MSG40SEQ,FILESQ+5  EDIT FILE SEQ INTO ATTRIB MSG\n         MVC   TITLE+68(6),MSG40SEQ  MV ABSOLUTE FILE SEQ NO TO TITLE\n         ZAP   LINES,=P'58'          CAUSES SKIP TO TOP OF NEXT PAGE\n         CLOSE (TAPEX,LEAVE)       CLOSE TAPE FILE INORDER TO KEEP\n         CVB   R9,FILESQ     SYSTEM INFORMED WHICH FILE IS BEING PROC\n         STH   R9,JFCBFLSQ  BY INSERTING THE CORRECT FILE SEQ NO INTO\n         OPEN  (TAPEX),TYPE=J     THE JFCB AND OPENING THE DCB\n*                             WITH THE MODIFIED JFCB\n         CLI   VARFLAG,C'V'   IS R=V REQUESTED\n         BNE   ENDINIT        NO\n         MVI   REC1BLK+1,X'00'  YES-RESET ALL THE NOP'S\n         MVI   NXTREC+1,X'00'\n         MVI   VARERR+1,X'00'\nENDINIT  B     STRTPROC  RETURN TO START OF FILE PROCESSING-\n*                  NOP FOR FOR MULTIVOLUME BLP TAPE PROCESSING\n         MVI   ENDINIT+1,X'F0' RESET ABOVE TO BR AFTER EACH TIME THRU\n         B     BACKOFLG    FOR MULTIVOLUME BLP TAPE PROCESSING\n         SPACE 1\nCHKEOV   CLI   HDRFLAG,C'2'  HAVE WE PROCESSED 2 TPMKS FOLLOWING A HDR\n         BE    STRTPROC      YES - ITS A DUMMY DATA SET, CONTINUE\n         CLI   JFCBLTYP,JFCBLP  NO- IS LABEL TYPE 'BLP'\n         BNE   EOVMSG           NO-GO TO EOV MSG\n         CP    FILESQ,ONE   IS THIS THE FIRST PHYSICAL DATA SET\n         BNE   EOVMSG           NO-GO TO EOV\n         B     STRTPROC      YES- THIS IS (1,BLP) WITH LEADING TM\n         SPACE 2\nMSG19RTN CP    SAVEBLK,WORKFLD1 NO-IS CURRENT BLKSIZE = TO PREV BLKSIZE\n         BER   R2              YES\n         CLI   REC1BLK+1,X'00' HAS R=V BEEN REQUESTED FOR VARIABLE RECS\n         BER   R2              YES\n         CP    MSG19CNT,=P'9'  NO- HAS MSG19 BEEN WRITTEN 10 TIMES\n         BHR   R2              YES\n         ZAP   SAVEBLK,WORKFLD1  NO- MOVE CURRENT BLKSIZE TO PREV BLKSI\n         AP    MSG19CNT,ONE    ADD 1 TO NUMBER OF TIMES MSG19 WRITTEN\n         MVC   MSG19BYT(6),MASK\n         MVC   MSG19BLK(8),MASK\n         ED    MSG19BYT(6),SAVEBLK\n         ED    MSG19BLK(8),BLKCNT+4\n         MESSAGE 19\n         BR    R2\n         TITLE 'ALLOCATE FILES FOR SAS TAPECOPY ROUTINE'\nDOTAPCPY MVC   DDNAME,=C'FT11F001'   LOG FILE\n         CHCKTIOT NOTFND=NOFT11\nNEXT1    MVC   DDNAME,=C'FT12F001'   PRT FILE\n         CHCKTIOT NOTFND=NOFT12\nNEXT2    MVI   SYSOUTC1,X'00'   ZERO OUT SYSOUT FLAG\n         XC    SYSOUTC2(4),SYSOUTC2 ZERO OUT SYSOUT POINTER\n         MVC   DDNAME,=C'WORK    '   SAS WORK FILE\n         CHCKTIOT NOTFND=NOWORK\nNEXT3    MVC   DDNAME,=C'SYSIN   '   SAS SYSIN CONTROL STATEMENTS\n         CHCKTIOT NOTFND=NOSYSIN\nLINK     LINK  EP=SAS370,PARAM=(SASPARM),VL=1 EXECUTE SAS TAPECOPY RTN\n         STC   R15,RCSPOT+3   PUT OUT SAS RETURN CODE\n         B     RETURN\n         SPACE 5\nNOFT11   LA    R1,REQBLKP\n         DYNALLOC           ALLOCAT FT11F001\n         LH    R15,RBERR    ERROR\n         LTR   R15,R15      WAS FT11F001 DYNAMICALLY ALLOCATED\n         BNZ   SASFILER     NO\n         B     NEXT1   BRANCH TO CHECK FOR FT12F001\n         SPACE 1\nNOFT12   LA    R1,REQBLKP\n         DYNALLOC\n         LH    R15,RBERR    ERROR\n         LTR   R15,R15      WAS FT12F001 DYNAMICALLY ALLOCATED\n         BNZ   SASFILER     NO\n         B     NEXT2     BRANCH TO CHECK FOR SAS WORK FILE\n         SPACE 1\nNOWORK   LA    R1,REQBLKP\n         DYNALLOC\n         LH    R15,RBERR    ERROR\n         LTR   R15,R15      WAS WORK FLE DYNAMICALLY ALLOCATED\n         BNZ   SASFILER     NO\n         B     NEXT3     BRANCH TO CHECK FOR SYSIN FILE\n         SPACE 1\nNOSYSIN  XC    WORKSEC(4),WORKSEC     ZERO SECONDARY SPACE ALLOC\n         MVC   WRKBLKSZ(3),=FL3'80'   SET SYSIN BLKSIZE TO 80\n         MVC   WORKPRM(3),=FL3'1'     ALLOC 1 BLOCK OF SPACE TO SYSIN\n         LA    R1,REQBLKP\n         DYNALLOC\n         LH    R15,RBERR    ERROR\n         LTR   R15,R15      WAS SYSIN DYNAMICALLY ALLOCATED\n         BNZ   SASFILER     NO\n         OPEN  (SYSIN,OUTPUT)  YES- OPEN SYSIN FILE\n         PUT   SYSIN,SYSINR1   REC1= PROC TAPECOPY INDD=SYSUT1 OUTDD=..\n         CLOSE (SYSIN)       CLOSE SYSIN\n         B     LINK      BRANCH TO LINK TO SAS\n         SPACE 1\n         TITLE 'DATA AREAS AND CONSTANTS'\nTITADDR  DS    A         STARTING ADDRESS OF TITLE STORED HERE\nSAVER6   DS    F         SAVE AREA FOR R6\nSAVER14  DS    F         SAVE AREA FOR R14\nPARMEND  DS    F         ADDRESS OF LAST PARM CHARACTER\nNVOLSAVE DS    F   NUMBER OF INPUT VOLUMES FROM JFCBNVOL-FOR BLP TAPES\nPRINTBUF DS    F         ADDRESS OF THE PRINT BUFFER-USED FOR SYSPRINT\nPARMLIM  DC    F'8'    MAXIMUM NUMBER OF CHARACTER FOR ANY KEYWORD PARM\nDVCTYPE  DS    2F\nWORKFLD1 DS    D         WORK FIELD USED USED TO PACK NUMBERS INTO\nFILESQ   DS    PL8           FILE SEQUENCE COUNTER\nSKPCNT   DC    PL8'0'        S= PARAMETER (DEFAULT=0)\nRLEN     DC    PL8'100'      R= PARAMETER (DEFAULT=100)\nFILES    DC    PL8'1'        N= PARAMETER\nFILEPROC DC    PL8'0'    NUMBER OF FILES ALREADY PROCESSED\nBLKWRIT  DC    PL8'0'         NUMBER OF BLOCKS WRITTEN\nBLKCNT   DC    PL8'0'         NUMBER OF BLOCKS READ\nEOVBLKCT DC    PL8'0'       BLKCNT FOR EOV (NUMBER OF BLKS ON VOLUME)\nTOTBYTES DC    PL8'0'         TOTAL NUMBER OF BYTES IN FILE\nTAPELEN  DC    PL8'0'         TOTAL LENGTH OF TAPE PROCESSED\nDIAGRECS DC    PL8'999999999999999' NUMBER OF DIAG RECS TO WRITE\nMINBLK   DC    F'65535'     MINIMUM BLKSIZE OF THE BLOCKS IN A FILE\nSAVEMIN  DC    F'65535'\nF65535   DC    F'65535'     CONSTANT-MAXIMUM BLKSIZE\nMAXBLK   DC    F'0'         MAXIMUM    \"\nLASTBLK  DC    F'0'         LAST       \"\nWORKFLD  DS    CL16'RESERVE 16 BYTES'\n         DS    CL50 FIELD TO CONCATENATE TO WORKFLD TO HOLD TITLE\nRCNT     DC    PL4'0'         NUMBER OF RECORDS PROCESSED\nLIMIT    DC    PL5'0'         C= PARAMETER (DEFAULT=ALL)\nSAVEBLK  DC    PL3'-1'    COUNT OF BYTES IN PREV BLOCK\nMSG19CNT DC    PL2'0'     NUMBER OF MESSAGE 19'S PUT OUT\nONE      DC    P'1'           CONSTANT PACKED 1\nPZERO    DC    P'0'           CONSTANT PACKED 0\nDENSITY  DC    PL3'0'         TAPE DENSITY (6250/1600/800) FOR CALCUL\nIBGLEN   DC    PL1'0'  INTER-RECORD-GAP LENGTH (.3 OR .6 OR .7 INCH)\nRLENFLAG DC    C'0'    INDICATE IF USER CODED R= (0=NO, 1=YES)\nLINES    DC    PL2'58' PAGE LINE COUNTER\nTITLE    DC    CL133' '       SAVE TITLE HERE\nCC       DC    C' '           CARRIAGE CONTROL CHARACTER\n         DC    C' '           1ST BYTE OF PRINT LINE\nPNT      DC    CL131' '        REST OF PRINT LINE\nHEXAREA  DS    CL100      WORK AREA FOR TRANSLATING FROM ASCII,RMT PRT\nMSGSPACE DC    CL20' '    CONSTANT CHARACTER SPACES\nENDPARMS DC    C' '            END OF PARM FLAG\nNUMBERR  DC    C' '            NUMERIC ERROR IN PARM FLAG\nTIOTFLAG DC    C'0'            DDNAME NOT FOUND IN TIOT FLAG\nEOVFLAG  DC    C'0'   FLAG TO INDICATE EOV1 HIT ON TAPE LABEL\n* 0=EOV NEVER HIT, 1=VOLUME TO BE SWITCHED, 2=VOLUME ALREADY SWITCHED\nHDRFLAG  DC    C'0'   FLAG TO INDICATE HDR1 HIT ON TAPE LABEL\n* 0=HDR NEVER HIT, 1=HDR LABEL HIT, 2=TPMK HIT AFTER HDR LABEL\nVARFLAG  DS    CL1             FLAG INDICATING IF R=V REQUESTED\nSASPARM  DC    H'33',C'NONEWS NOOPLIST NOSTIMER NOSOURCE' TSO,MINSTG\nMASK     DC    X'402020202020202020202120'\nSHFT3480 EQU   62   SHIFT FACTOR FOR 3480 CARTRIDGE (DIVIDE BY 100)\nLRECL    EQU   82   DCB LRECL\n         TITLE 'MESSAGES'\nMSG0     DC    C'0DMP000I PARM= '\nMSG0LEN  EQU   *-MSG0\nMSG1     DC    C'0DMP001E ERROR IN PARM FIELD OR JCL'\nMSG1LEN  EQU   *-MSG1\nMSG2     DC    C'0DMP002I END OF FILE REACHED'\nMSG2LEN  EQU   *-MSG2\nMSG3     DC    C'0DMP003E SYSUT1/2 DD STATEMENT MISSING'\nMSG3LEN  EQU   *-MSG3\nMSG4     DC    C'0DMP004E KEYWORD PARAMETER NOT FOLLOWED BY = SIGN'\nMSG4LEN  EQU   *-MSG4\nMSG5     DC    C'0DMP005E INVALID OR DUPLICATE KEYWORD PARMATER'\nMSG5LEN  EQU   *-MSG5\nMSG6     DC    C'0DMP006E A PARAMETER LENGTH EXCEEDS MAXIMUM ALLOWABLE'\nMSG6LEN  EQU   *-MSG6\nMSG8     DC    C'0DMP008E PARM VALUE NOT NUMERIC'\nMSG8LEN  EQU   *-MSG8\nMSG9     DC    C'0DMP009E INVALID VALUE SPECIFIED FOR FORMAT PARAMETER'\nMSG9LEN  EQU   *-MSG9\nMSG10    DC    C'0DMP010I NUMBER OF BLOCKS DUMPED ='\nMSG10CNT DC    X'40202020202020202120'\nMSG10LEN EQU   *-MSG10\nMSG11    DC    C'0DMO011I NUMBER OF BLOCKS TO BE SKIPPED ='\nMSG11SKP DC    X'40202020202020202120'\nMSG11LEN EQU   *-MSG11\nMSG12    DC    C'0DMP012I MINIMUM BLKSIZE ='\nMSG12MIN DC    X'402020202120'\n         DC    C', MAXIMUM BLKSIZE ='\nMSG12MAX DC    X'402020202120'\n         DC    C', LAST BLKSIZE ='\nMSG12LST DC    X'402020202120'\n         DC    C', TOTAL NUMBER OF BYTES ='\nMSG12BYT DC    X'402020202020202020202120'\nMSG12LEN EQU   *-MSG12\nMSG13    DC    C'0DMP013I '\nMSG13NEQ DC    X'40202020202020202120'\n         DC    C' FILES TO BE DUMPED (N PARAMETER VALID ONLY WHEN '\n         DC    C'LABEL PROCESSING IS BYPASSED ON TAPE FILES)'\nMSG13LEN EQU   *-MSG13\nMSG14    DC    C'0DMP014W DATA NOT VARIABLE FORMAT, R=100 WILL BE USED'\nMSG14LEN EQU   *-MSG14\nMSG15    DC    C'0DMP015I SKIP COUNT EQUALS OR EXCEEDS TOTAL'\n         DC    C' BLOCK COUNT. NO BLOCKS DUMPED.'\nMSG15LEN EQU   *-MSG15\nMSG16    DC    C'0DMP016I END OF VOLUME REACHED'\nMSG16LEN EQU   *-MSG16\nMSG17    DC    C'0DMP017I TAPE FILE WILL BE PROCESSED BACKWARDS. '\n         DC    C'(R=V AND N PARAMETER WILL BE IGNORED IF CODED)'\nMSG17LEN EQU   *-MSG17\nMSG18    DC    C'0DMP018I SUPRDUMP STATISTICS APPLY ONLY TO THE '\n         DC    C'NUMBER OF BLOCKS PROCESSED'\nMSG18LEN EQU   *-MSG18\nMSG19    DC    C'0DMP019I BLOCK NO. ='\nMSG19BLK DC    X'4020202020202120'\n         DC    C', NO. OF BYTES IN BLOCK ='\nMSG19BYT DC    X'402020202120'\nMSG19LEN EQU   *-MSG19\nMSG20    DC    C'0DMP020E UNABLE TO ALLOCATE FILE(S) FOR TAPECOPY '\n         DC    C'(FT11F001, FT12F001, WORK, SYSIN)'\nMSG20LEN EQU   *-MSG20\nMSG21    DC    C'0DMP021I FILE OCCUPIES APPROXIMATELY'\nMSG21TPL DC    X'40202020202020202120'\n         DC    C' INCH(ES) OF TAPE'\nMSG21LEN EQU   *-MSG21\nMSG22    DC    C'0DMP022I JOBNAME='\nMSG22JOB DS    CL8\n         DC    C',PROCSTEPNAME='\nMSG22PRC DS    CL8\n         DC    C',JOBSTEPNAME='\nMSG22STP DS    CL8\nMSG22LEN EQU   *-MSG22\nMSG23    DC    C'0DMP023I APPROXIMATE TOTAL TAPE LENGTH OF PROCESSED '\n         DC    C'FILES='\nMSG23TPL DC    X'40202020202020202120'\n         DC    C' INCH(ES)'\nMSG23LEN EQU   *-MSG23\nMSG24    DC    C'0DMP024W THE BLOCK COUNT ON THE TAPE TRAILER LABEL ('\nMSG24LBL DC    X'4020202020202120'\n         DC    C') DOES NOT MATCH THE ACTUAL BLOCK COUNT ('\nMSG24BLK DC    X'4020202020202120'\n         DC    C')'\nMSG24LEN EQU   *-MSG24\nMSG25    DC    C'0DMP025I VOLUME SWITCHED TO VOLSER='\nMSG25VOL DS    CL6\n         DC    C' AFTER BLOCK NUMBER'\nMSG25BLK DC    X'4020202020202120'\nMSG25LEN EQU   *-MSG25\nMSG26    DC    C'0DMP026E BLP PROCESSING FOR CONCATENATED TAPE FILES '\n         DC    C'NOT ALLOWED (SPECIFY ALL VOLSERS IN SYSUT1 DD)'\nMSG26LEN EQU   *-MSG26\nMSG27    DC   C'0DMP027W BLKSIZE OF FILE EXCEEDS 32K - NOT PROCESSABLE'\n         DC    C' USING STANDARD IBM ACCESS METHODS'\nMSG27LEN EQU   *-MSG27\nMSG39    DC    C'         RECFM='\nMSG39FVU DS    CL1\n         DC    C',LRECL='\nMSG39REC DC    X'402020202120'\n         DC    C',CREATION DATE:YY='\nMSG39CRY DS    CL2\n         DC    C',DDD='\nMSG39CRD DC    X'40202020'\n         DC    C',EXPIRATION DATE:YY='\nMSG39EXY DS    CL2\n         DC    C',DDD='\nMSG39EXD DC    X'40202020'\nMSG39LEN EQU   *-MSG39\nMSG40    DC    C'0DMP040I VOLSER='\nMSG40VOL DC    CL6' '\n         DC    C',BLK CNT='\nMSG40BLK DC    X'4020202020202120'\n         DC    C',SEQ NO='\nMSG40SEQ DC    X'402020202120'\n         DC    C',LABEL='\nMSG40LBL DC    CL3' '\n         DC    C',DEN='\nMSG40DEN DS    CL5              (6250/1600/800)\n         DC    C' '\nMSG40TRK DS    CL1              (7/9)\n         DC    C'-TRK'\n         DC    C',DSN='\nMSG40DSN DC    CL44' '\nMSG40LEN EQU   *-MSG40\nMSG41    DC    C'0DMP041I (C) COPYRIGHT JUNE 1984 BY M. KARLIN, '\n         DC    C'N. LINDNER          SUPRDUMP RELEASE 3.3 '\n         GETDATE DATE\nMSG41LEN EQU   *-MSG41\n         TITLE 'TABLES AND LTORG'\nTABLE3   DC    C'0123456789ABCDEF'\nTABLE2   DC    16C'0',16C'1',16C'2',16C'3',16C'4',16C'5',16C'6',16C'7'\n         DC    16C'8',16C'9',16C'A',16C'B',16C'C',16C'D',16C'E',C'F'\nTABLE4   DC    64C'.'        UNPRINTABLE CHARACTERS PRINT AS '.'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'808182838485868788898A8B8C8D8E8F'\n         DC    X'909192939495969798999A9B9C9D9E9F'\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\nTRNSTAB2 DC    160X'FF'\n         DC    5X'01010101010101010101FFFFFFFFFFFF'\n         DC    10X'00',6X'FF'\nNUMLINE  DC    C'----+----1----+----2----+----3----+----4----+----5---'\n         DC    C'-+----6----+----7----+----8----+----9----+----0'\nSYSINR1  DC    CL80'PROC  TAPECOPY INDD=SYSUT1 OUTDD=TAPECOPY NORER;'\n*\nOPTNTABL DC    195X'00'\n         DC    X'08'          C=\n         DC    X'1C',1X'00'   D=\n         DC    X'14',14X'00'  F=\n         DC    X'18',3X'00'   N=\n         DC    X'04',8X'00'   R=\n         DC    X'0C'          S=\n         DC    X'10',28X'00'  T=\n         SPACE 1\n         LTORG\n         TITLE 'DYNAMIC ALLOCATION AREAS'\n*        DYNAMICALLY PRODUCE A SYSPRINT/SYSUT2 DD\n*        STATEMENT (ASSIGNED TO SYSOUT=MSGCLASS) IF THE SYSPRINT/SYSUT2\n*        DD STATEMENT HAS NOT BEEN CODED IN THE JCL.\n*           FOR SAS TAPECOPY RTN\n*         WILL DYNAMICALLY ALLOCATE FT11F001 AND FT12F001 TO SYSOUT=*\n*         THE WORK DD TO A TEMPORARY SYSDA FILE (BLKSIZE=6160,(90,90)\n*             BLOCKS) AND A SYSIN FILE OF 1 BLOCK, BLKSIZE=80 FOR\n*             THE SAS CONTROL STATEMENTS.\n         DS    0F\nREQBLKP  DC    X'80',AL3(REQBLK)  POINTER TO REQUEST BLOCK\nREQBLK   DC    X'14'   RB LENGTH(20)\n         DC    X'01'   VERB CODE = 1, DS ALLOC\nSYSOUTC1 DC    X'1000' FLAG SET FOR SYSOUT DATA SET - ZEROD FOR OTHERS\nRBERR    DC    H'0',X'0000'   HALFWORD ERROR RETURN CODE FROM DYNALLOC\nTXTP     DC    A(TXTUNTP)     POINTER TO TEXT UNITS\n         DC    XL8'00'\nTXTUNTP  DC    A(TUDDNAM)     ADDRESS OF DDNAME ALLOC\nSYSOUTC2 DC    X'80',AL3(TUSYSOUT) ZEROED WHEN SYSOUT=* ALLOCATES DONE\n         DC    A(TUBLKLN)     ADDR OF BLOCK LENGTH ALLOC\n         DC    A(TUSPCPRM)            PRIMARY SPACE ALLOC\nWORKSEC  DC    A(TUSPCSEC)            SEC SPACE- ZEROED OUT FOR SYSIN\n         DC    X'80',AL3(TUUNIT)      UNIT ALLOC\nTUDDNAM  DC    X'0001'         KEY=1\n         DC    X'0001'         #  =1  (NUMBER OF 'LEN,PARM'S FOLLOWING)\n         DC    X'0008'         LEN=8\nDDNAME   DC    CL8'SYSPRINT'      CHANGED FOR EACH FILE\nTUBLKLN  DC    X'0009'\n         DC    X'0001'\n         DC    X'0003'\nWRKBLKSZ DC    FL3'6160'   CHANGED TO 80 FOR SYSIN\nTUSPCPRM DC    X'000A'\n         DC    X'0001'\n         DC    X'0003'\nWORKPRM  DC    FL3'90'     CHANGED TO 1 FOR SYSIN\nTUSPCSEC DC    X'000B'\n         DC    X'0001'\n         DC    X'0003'\n         DC    FL3'90'\nTUUNIT   DC    X'0015'\n         DC    X'0001'\n         DC    X'0005'\n         DC    C'SYSDA'\nTUSYSOUT DC    X'0018'\n         DC    X'0000'\n         SPACE 1\n         DS    0F\nCKCONCAT DC    X'80',AL3(CONCAT)  POINTER TO REQUEST BLOCK\nCONCAT   DC    X'14'   RB LENGTH(20)\n         DC    X'07'   VERB CODE = 7, DYNAMIC INFORMATION RETRIEVAL\n         DC    XL6'00'\n         DC    A(CONCATTX)    POINTER TO TEXT UNITS\n         DC    XL8'00'\nCONCATTX DC    A(CONCATDD)    ADDRESS OF DDNAME\n         DC    X'80',AL3(DINRTATT) POINTER TO ATTRIBUTES TEXT UNIT\nCONCATDD DC    X'0001'         KEY=1\n         DC    X'0001'         #  =1  (NUMBER OF 'LEN,PARM'S FOLLOWING)\n         DC    X'0006'         LEN=6\n         DC    CL6'SYSUT1'\nDINRTATT DC    X'000C'         KEY=C\n         DC    X'0001'         #  =1\n         DC    X'0001'         LEN=1\nCONCPARM DS    X     ATTRIBUTES RETURNED HERE:X'80'=PERMANENT CONCATEN\n         TITLE 'EXLST,IOB,ECB,CCW,DCB''S,JFCB,TIOT AND REG EQUATES'\nINPTXLST DS    0F\n         DC    X'07',AL3(INFMJFCB)   JFCB EXIT\nVOLVER   DC    X'00',AL3(VOLVERXT)   CHANGED TO X'18' FOR TAPE TO GET\n* THE EXPDT FROM THE VOLUME VERIF EXIT WHICH GIVES ACCESS TO HDR1 LABEL\n         DC    X'8B',AL3(BLKCTXIT)   BYPASS UNQUAL BLKCNT EXIT\n         SPACE 1\nIOB      DS    0F\n         DC    X'02000000'\n         DC    A(ECB)\n         DC    2F'0' CSW(SEE P228 POPS) CONTAINS CCW ADDR, UNIT STAT,\n*              RESIDUAL COUNT FLD, ETC.\n         DC    A(CCW)\n         DC    A(TAPEX)\n         DC    5F'0'\n         SPACE 1\nECB      DC    F'0'\nCCW      CCW   2,0,0,65535  COMMAND CODE,ADDR OF BUFFER,0,LENGTH OF BUF\n         SPACE 1\n*                                                                  NL\nIOB1     DS    0F           FOR TAPE DRIVE SENSE COMMAND           NL\n         DC    X'02000000'                                         NL\n         DC    A(ECB1)                                             NL\n         DC    2F'0' CSW(SEE P228 POPS) CONTAINS CCW ADDR,         NL\n*                UNIT STAT,RESIDUAL COUNT FLD, ETC.                NL\n         DC    A(CCW1)                                             NL\n         DC    A(TAPEX)                                            NL\n         DC    5F'0'                                               NL\n*                                                                  NL\nECB1     DC    F'0'         FOR SENSE DRIVE SENSE COMMAND          NL\n*                                                                  NL\nCCW1     CCW   X'04',SBYTES,0,32 CCW FOR SENSE (TAPE OR CARTRIDGE)\n*                                                                  NL\nSBYTES   DS    0F     32 SENSE BYTES FOR BOTH TAPE AND CASSETTE    NL\nSENSE0   DS    XL1    UNIT CHECK                                   NL\nSENSE1   DS    XL1                                                 NL\nSENSE2   DS    XL1    TRACK IN ERROR                               NL\nSENSE3   DS    XL1    DATA AND EQUIPMENT CHECK                     NL\nSENSE4   DS    XL1                                                 NL\nSENSE5   DS    XL1                                                 NL\nSENSE6   DS    XL1    TAPE UNIT                                    NL\nSENSE7   DS    XL1    TAPE UNIT READY-DROP SOURCE                  NL\nSENSE8   DS    XL1    MICRO PROGRAM DETECTED ERRORS                NL\nSENSE9   DS    XL1                                                 NL\nSENSE10  DS    XL1                                                 NL\nSENSE11  DS    XL1    MAL 1 ROS/MP ERRORS                          NL\nSENSE12  DS    XL1    MAL 2 ROS/MP ERRORS                          NL\nSENSE13  DS    XL1    TAPE CONTROL IDENTIFICATION - SERIAL NUMBER  NL\nSENSE14  DS    XL1    TAPE CONTROL IDENTIFICATION - SERIAL NUMBER  NL\nSENSE15  DS    XL1    TAPE UNIT IDENTIFICATION - SERIAL NUMBER     NL\nSENSE16  DS    XL1    TAPE UNIT IDENTIFICATION - SERIAL NUMBER     NL\nSENSE17  DS    XL1    TAPE CONTROL FEATURES                        NL\nSENSE18  DS    XL1                                                 NL\nSENSE19  DS    XL1                                                 NL\nSENSE20  DS    XL1                                                 NL\nSENSE21  DS    XL1    THREAD AND LOAD  DIAGNOSTICS                 NL\nSENSE22  DS    XL1    FIELD REPLACEABLE UNIT IDENTIFICATION        NL\nSENSE23  DS    XL1    FIELD REPLACEABLE UNIT IDENTIFICATION        NL\nSENSE24  DS    XL1                                                 NL\nSENSE25  DS    XL1                                                 NL\nSENSE26  DS    XL1                                                 NL\nSENSE27  DS    XL1                                                 NL\nSENSE28  DS    XL1                                                 NL\nSENSE29  DS    XL1                                                 NL\nSENSE30  DS    XL1                                                 NL\nSENSE31  DS    XL1                                                 NL\n         SPACE 1\nSTATUS   DS    XL2\nDIAGPUTS DC    PL6'0'    DIAG RECORD COUNTER\n*\nTAPEX    DCB   DSORG=PS,MACRF=(E),DDNAME=SYSUT1,EODAD=QUIT,RECFM=U,    X\n               EXLST=INPTXLST\n         SPACE 1\nINPUT    DCB   DSORG=PS,MACRF=R,DDNAME=SYSUT1,EODAD=QUIT,BLKSIZE=0,    X\n               EXLST=INPTXLST\n         SPACE 1\nPRINTER  DCB   DSORG=PS,RECFM=FBA,BLKSIZE=4788,LRECL=133,MACRF=PM,     X\n               DDNAME=SYSUT2\n         SPACE 1\nSYSPRINT DCB   DSORG=PS,RECFM=FBA,BLKSIZE=4788,LRECL=133,MACRF=PL,     X\n               DDNAME=SYSPRINT\n         SPACE 1\nSYSIN    DCB   DSORG=PS,RECFM=F,LRECL=80,BLKSIZE=80,MACRF=PM,          X\n               DDNAME=SYSIN  BUILT BY SUPRDUMP;USED BY SAS\n         SPACE 2\nDIAGNOSE DCB   DSORG=PS,RECFM=FBA,LRECL=40,BLKSIZE=0,MACRF=PM,         X\n               DDNAME=DIAGNOSE\n         SPACE 2\n         IEFJFCBN\n         SPACE 1\n         IEFTIOT1\n         SPACE 1\n         IHAPSA      NEEDED FOT TIOT\n         SPACE 1\n         IKJTCB      NEEDED FOR TIOT\n         SPACE 1\n         IEZJSCB     NEEDED FOR TIOT\n         SPACE 1\n         IHAQDB      NEEDED FOR TIOT\n         SPACE 1\n         IHADSAB     NEEDED FOR TIOT\n         SPACE 1\n         IECOEVSE\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYNADERR": {"ttr": 10758, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x06\\x00\\x00\\x00\\x88\\x04\\x8f\\x00\\x91#O\\x103\\x00\\xab\\x00\\x86\\x00(\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "02.06", "flags": 0, "createdate": "1988-02-17T00:00:00", "modifydate": "1991-08-22T10:33:00", "lines": 171, "newlines": 134, "modlines": 40, "user": "CN03MQK"}, "text": "         TITLE  'SYNADERR ROUTINE'\n         PRINT  NOGEN\n*        R12 - BASE REGISTER\n*        AFTER ISSUING THE SYNADAF MACRO R1 HAS THE MSG BUFFER ADDR\n*              AND R0 HAS THE SYNADAF RETURN CODE\n*        R2 IS LOADED WITH THE MSG BUFFER ADDR (FROM R1)\n*          AT OFFSET 8 OF R2 IS THE INPUT BUFFER ADDRESS\n*            IF THIS ADDRESS IS BLANK-NO DATA WAS PASSED TO SYNAD\n*            R3 IS LOADED WITH THIS ADDR IF ITS NOT BLANK\n*          AT OFFSET 12 OF R2 IS THE NUMBER OF BYTES READ(LOADED IN R4)\n*        R10 IS LOADED WITH THE RETURN CODE (FROM R0)\n*        R6 - LOADED WITH 120 - LENGTH OF PRINT LINE\n*        R4 - NUMBER OF BYTES REMAINING IN THE BLOCK TO BE PRINTED\n*        R11- BAL REGISTER\n*        SYNADERR CAN BE INVOKED IN 4 WAYS\n*      1 NO EROPT PARAMETER ON THE SYSOUT DD - INVOKED 5 TIMES AT MOST\n*      2 EROPT=ABE INVOKED AT MOST ONCE (SIMULATES ALL OTHER PROGRAMS)\n*      3 EROPT=SKP INVOKED AT MOST 25 TIMES\n*      4 EROPT=ACC INVOKED FOR I/O ERRORS\n*        SAMPLE:  //SYSOUT  DD  SYSOUT=A,DCB=EROPT=ACC\n*        NOTE-MESSAGE SEL076 WILL PRINT THE BAD BLOCK AT MOST 5 TIMES\nSYNADERR START  0\n         EXTRN  ABEND,SETRC  ADDR TO BR BACK TO AFTER 5 CALLS & SET RC\n         EXTRN  RETURN3 ADDR TO BR BACK TO AFTER 5 CALLS-LIBFILE/LIBOUT\n         USING  *,R15\n         STM    R13,R12,SAVEAREA     SAVE REGISTERS\n         BALR   R12,0               ESTABLISH R12 AS BASE REGISTER\n         USING  *,R12\n         SYNADAF ACSMETH=QSAM\n         LR     R2,R1              LOAD MSG BUFFER ADDR INTO R2\n         LR     R10,R0             LOAD RETURN CODE FROM SYNADAF MACRO\nOPEN     OPEN   (SYSOUT,OUTPUT)      OPEN SYSOUT\n         TM     SYSOUT+48,X'10'     IS SYSOUT IN JCL OR DYNAMIC ALLOCAT\n         BNO    DYNALLOC             NO - DYNAMICALLY ALLOCATE IT\nEROPTPRC NOP    SKPSETUP   SET TO BRANCH AFTER FIRST TIME THRU\n         MVI    EROPTPRC+1,X'F0'\n         TM     SYSOUT+84,X'80'    IS EROPT=ACC CODED ON SYSOUT DD\n         BO     ALLERRS            YES - ALLOW ALL I/O ERRORS\n         TM     SYSOUT+84,X'40'    IS EROPT=SKP CODED ON SYSOUT DD\n         BO     ALLOW25            YES - ALLOW 25 I/O ERRORS\n         TM     SYSOUT+84,X'20'    IS EROPT=ABE CODED ON SYSOUT DD\n         BNO    SKPSETUP           NO  - USE DEFAULT (5)\n         ZAP    ERRALLOW,=P'1'     YES - ALLOW ONLY 1 I/O ERROR\nSKPSETUP AP     NUMBNVOK,=P'1'     ADD 1 TO BAD BLOCKS OUTPUT\n         CP     NUMBNVOK,=P'5'     HAVE 5 BLOCKS BEEN PUT OUT BY SYNAD\n         BNH    CONTINUE              NO\n         MVI    NOMOPRT+1,X'F0'  YES-SET BR,NO MORE BAD BLOCKS PRINTED\nCONTINUE MVC    0(8,R2),=C'SEL076E '  MOVE IN MSG NO.\n         L      R7,=A(SETRC)      SET THE RETURN CODE TO 8\n         MVI    3(R7),X'08'\n         MVC    SAVDDNAM,75(R2)    SAVE THE DDNAME OF FILE IN ERROR\n         CH     R10,=H'4'          IS RC = 4\n         BE     DATAREAD        YES-DATA WAS PASSED TO BUFFER\n         BL     MOVEBUF           RC=0-NO DATA WAS READ\n         CLI    8(R2),C' '      RC=8,IS INPUT BUFFER ADDRESS BLANK\n         BE     MOVEBUF         YES -NO DATA WAS READ\nDATAREAD L      R3,8(R2)    NO- LOAD R3 WITH INPUT BUFFER ADDR\n         LH     R4,12(R2)       LOAD R4 WITH NUMBER OF BYTES READ\n         MVC    BLKSIZE(8),MASK RESET BLKSIZE\n         CVD    R4,WORKFLD      CONVERT BLKSIZE TO DEC\n         ED     BLKSIZE(8),WORKFLD+4\n         MVC    8(40,R2),BLKSIMSG   MOVE IN BLKSIZE MSG\n         BAL    R11,WRITE       WRITE SYNAD MSG\nNOMOPRT  NOP    CLOSE  SET TO BR AFTER 5 BAD BLOCKS TO PREVENT WRITE\n         MVC    8(120,R2),RULER   PLACE RULER FOLLOWING SEL076\n         BAL    R11,WRITE\n         LA     R6,120         LOAD R6 WITH LENGTH OF PRINT LINE\nLOOP     CR     R4,R6  IS NO. OF BYTES LEFT LESS THAN PRINT LINE LENGTH\n         BL     ENDBLK              YES-FINISH LAST BLOCK\n         EX     R6,MOVEINPT        MOVE INPUT DATA TO MSG BUFFER\n         AR     R3,R6              UP INPUT ADDR POINTER\n         SR     R4,R6              SUBTRACT TO GET NO. OF BYTES LEFT\n         BAL    R11,WRITE           PRINT A LINE OF THE RECORD\n         B      LOOP\n         SPACE  2\nENDBLK   LTR    R4,R4            IS THERE ANYMORE DATA\n         BZ     NOMODATA\n         BCTR   R4,0             SET LENGTH OF BYTES TO BE MOVED TO PRT\n         EX     R4,MOVEINPT      MOVE DATA TO MSG BUFFER\n         BAL    R11,WRITE                   WRITE\nNOMODATA BAL    R11,WRITE         WRITE BLANK LINE\nCLOSE    CLOSE  (SYSOUT)\n         FREEPOOL SYSOUT\n         SYNADRLS                      RELEASE MSG BUFFER\n         CP     NUMBNVOK,ERRALLOW  HAVE MAX NO. OF BAD BLOCKS OUTPUT\n         BNE    SYNADXIT     NO\n         CLC    SAVDDNAM(3),=C'LIB' IS THIS THE LIBFILE OF LIBOUT DDNAM\n         BE     LIBERR   YES- RETURN TO LIB CSECT AND NOT ABEND LABEL\nERROR    MVC    SAVEAREA+4(4),=V(ABEND)  CHANGE R14 TO RETURN TO ABEND\nSYNADXIT LM     R13,R12,SAVEAREA          RESTORE REGISTERS\n         BR     R14                  RETURN TO SYSTEM\n         SPACE  2\nMOVEINPT MVC    8(0,R2),0(R3)    MOVE INPUT DATA TO MSG BUFFER TO PRT\n         SPACE  2\nMOVEBUF  MVC    8(40,R2),BADBLK     'UNABLE TO RECOVER RECORDS' MSG\n         BAL    R11,WRITE              WRITE\n         B      CLOSE\n         SPACE  2\nWRITE    PUT    SYSOUT,(R2)\n         MVI    0(R2),C' '           SPACE OUT MSG BUFFER\n         MVC    1(127,R2),0(R2)\n         BR     R11\n         SPACE  2\nALLERRS  ZAP    ERRALLOW,=P'-1'    ALLOW INFINITE NO. OF BAD BLOCKS\n         B      SKPSETUP           COMPAISON WILL NEVER BE EQUAL\n         SPACE  2\nALLOW25  ZAP    ERRALLOW,=P'25'    ALLOW 25 BAD BLOCKS\n         B      SKPSETUP\n         SPACE  2\nLIBERR   L      R7,=A(RETURN3)     SET LIB ERROR RC=8\n         MVI    3(R7),X'08'\n         B      SYNADXIT           RETURN VIA CONTROL PGM\n         SPACE  2\nDYNALLOC LA     R1,REQBLKP     DYNAMICALLY ALLOCATE SYSOUT DATASET\n         DYNALLOC\n         LH     R15,RBERR\n         LTR    R15,R15              SUCCESSFUL?\n         BNZ    ERROR                   NO-JUST GET OUT WITH ERR MSG\n         B      OPEN                    YES- DO OPEN AGAIN\n         SPACE  2\nWORKFLD  DS     D\nSAVEAREA DS     16F\nSAVDDNAM DS     CL8\nNUMBNVOK DC     PL8'0'    COUNTS NMBER OF TIMES SYNAD IS INVOKED\nERRALLOW DC     PL2'5'    SET DEFAULT MAX NO. OF BAD BLOCKS ALLOWED\nMASK     DC     X'4020202020202120'\nRULER    DC     C'----+----1----+----2----+----3----+----4----+----5'\n         DC     C'----+----6----+----7----+----8----+----9----+----0'\n         DC     C'----+----1----+----2'   120 BYTE RULER\nBADBLK   DC     CL40'UNABLE TO RECOVER RECORDS FROM BAD BLOCK'\nBLKSIMSG DS     0CL40\n         DC     C'NUMBER OF BYTES READ IN BLOCK = '\nBLKSIZE  DC     X'4020202020202120'\nSYSOUT   DCB    DDNAME=SYSOUT,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=128,    X\n               BLKSIZE=1280\n         SPACE  2\n         DS     0F\nREQBLKP  DC     X'80',AL3(REQBLK)\nREQBLK   DC     X'14'\n         DC     X'01'      DS ALLOC\n         DC     X'1000'    FOR SYSOUT FILES\nRBERR    DC     H'0',X'0000'\nTXTP     DC     A(TXTUNTP)\n         DC     XL8'00'\nTXTUNTP  DC     A(TUDDNAM)\n         DC     X'80',AL3(TUSYSOUT)\nTUDDNAM  DC     X'0001'\n         DC     X'0001'\n         DC     X'0008'\n         DC     CL8'SYSOUT'\nTUSYSOUT DC     X'0018'\n         DC     X'0000'\n         SPACE  2\n         LTORG\nR0       EQU    0          SYNADAF RETURN CODE\nR1       EQU    1          ADDRESS OF MSG BUFFER\nR2       EQU    2           SAME AS R1\nR3       EQU    3          POINTER IN THE INPUT RECORD BUFFER\nR4       EQU    4           NUMBER OF BYTES LEFT IN BUFFER\nR5       EQU    5\nR6       EQU    6           LENGTH OF PRINT LINE\nR7       EQU    7\nR8       EQU    8\nR9       EQU    9\nR10      EQU    10         RC\nR11      EQU    11         BAL REGISTER\nR12      EQU    12         BASE REGISTER\nR13      EQU    13\nR14      EQU    14\nR15      EQU    15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TEST": {"ttr": 10762, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00@\\x00\\x89\\x01\\x7f\\x01\\t\\x17?\\x14\\x13\\x01\\xbe\\x00Q\\x01\\xbe\\xd4\\xf4\\xf5@@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1989-01-17T00:00:00", "modifydate": "2009-06-22T14:13:40", "lines": 446, "newlines": 81, "modlines": 446, "user": "M45"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TESTMAC": {"ttr": 11014, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00\\x00\\x00\\x89\\x05\\x9f\\x00\\x93\\x17?\\x12P\\x00\\x1e\\x00\\x03\\x00\\x1e\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "1989-02-28T00:00:00", "modifydate": "1993-06-22T12:50:00", "lines": 30, "newlines": 3, "modlines": 30, "user": "CN03MQK"}, "text": "         USING *,5\n*        SHOWCAT ACB=ACB,AREA=AREA,CI=CI\n*        SETRP WKAREA=(7),DUMP=NO,RC=4,RETADDR=(8),FRESDWA=YES,        X\n*              COMPCOD=((9),SYSTEM)\n         REALLOC UCB=(5),PDSDIR=DUMYFLD,MF=(E,REALLOCL),               X\n               DSSIZE=DUMYFLD,PDSCB=DUMYFLD\n         DS    0F\nREALLOCL REALLOC MF=L\n*        OBTAIN SRCHVTOC\n*RCHVTOC CAMLST SEARCH,DSCBDSN,VOL,WORKAREA\n*SCBDSN  DS    CL44\n*OL      DS    CL6\n*ORKAREA DS    XL140\n*        DEVTYPE 40(R5),AREA\n*        CNOP  0,4\n*LDVRP   BLDVRP BUFFERS=(4096(4),1024(10)),KEYLEN=20,STRNO=1,TYPE=LSR\nDUMYFLD  DS    F\nVSAMRECL DS    S,H\nVSAMKEYL DS    S,H\nOPEN     DS    F\nACB      DS    F\nAREA     DS    F\nCI       DS    3X\n         DS    0F\nMODLIST  DS    10X\nR5       EQU   5\n*        IGGSHWPL\n         PRINT NOGEN\n         IHASDWA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TESTPGM": {"ttr": 11016, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0e\\x00\\x00\\x00\\x900_\\x00\\x903\\x9f\\x143\\x00<\\x00'\\x00\\x1d\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@\"", "ispf": {"version": "01.14", "flags": 0, "createdate": "1990-11-01T00:00:00", "modifydate": "1990-12-05T14:33:00", "lines": 60, "newlines": 39, "modlines": 29, "user": "CN03MQK"}, "text": "CIR      START 0\n         USING *,R15      USE R15 TEMPORARILY AS A BASE\n         STM   R14,R12,12(R13)      SAVE SYSTEM REGISTERS\n         ST    R13,SAVEAREA+4 STORE ADDR OF SYSTEM SAVE AREA IN SAVEARE\n         LR    R3,R13       LOAD R3 WITH ADDRESS OF SYSTEM SAVE AREA\n         CNOP  0,4        TO ALIGN THE BAL INSTR ON A FULLWORD\n         BAL   R13,JUMPSAVE    STORE THE ADDRESS OF SAVEAREA IN R13\nSAVEAREA DS    18F                   AND BRANCH TO JUMPSAVE\nJUMPSAVE ST    R13,8(R3)  STORE ADDR OF SAVEAREA IN SYSTEM SAVE AREA\n         USING SAVEAREA,R13\n         DROP  R15\n         L     R3,0(0,R1) LOAD THE CONTENTS OF ADDR POINTED TO BY R1\n         LH    R4,0(R3)    GET LENGTH\n         MVC   CIROPT(1),2(R3)     SET UP OPTION FLAG\n         BCTR  R4,0       SUB 1\n         BCTR  R4,0       SUB 1\n         STC   R4,MVCPARM+1\nMVCPARM  MVC   SRCHARG(*-*),3(R3)     SET UP SEARCH ARG\n         LA    R1,CIRPARM\n         LINK  EP=IKJEHCIR\n         SPACE 2\n         ABEND 100,DUMP,STEP,SYSTEM   CAUSE A DUMP\nEXIT     L     R13,SAVEAREA+4\n         LM    R14,R12,12(R13)\nSETRC    LA    R15,0\n         BR    R14\n         SPACE\nCIRPARM  DS    0F\nCIROPT   DS    X             OPTION FLAG (FROM PARM)\n         DS    XL2\nCIRLOCRC DS    X\nCIRSRCH  DC    A(SRCHARG)\nCIRCVOL  DS    A             <==========\nCIRWA    DC    A(WKAREA)\nCIRSAVE  DC    A(SVAREA)\nCIRPSWD  DC    A(PASSWORD)\n         SPACE\nSVAREA   DS    18F\nPASSWORD DC    D'0'\nVOLADDR  DS    CL6           <===========\nSRCHARG  DC    CL44' '       <=== MUST BE REINIT TO BLANK\nWKAREA   DC    AL2(65000),H'0'\n         DS    65000X\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TESTPGM2": {"ttr": 11018, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x903\\x7f\\x00\\x903\\x7f\\x11C\\x00.\\x00.\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-03T00:00:00", "modifydate": "1990-12-03T11:43:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "CN03MQK"}, "text": "CIR      START 0\n         USING *,R15      USE R15 TEMPORARILY AS A BASE\n         STM   R14,R12,12(R13)      SAVE SYSTEM REGISTERS\n         ST    R13,SAVEAREA+4 STORE ADDR OF SYSTEM SAVE AREA IN SAVEARE\n         LR    R3,R13       LOAD R3 WITH ADDRESS OF SYSTEM SAVE AREA\n         CNOP  0,4        TO ALIGN THE BAL INSTR ON A FULLWORD\n         BAL   R13,JUMPSAVE    STORE THE ADDRESS OF SAVEAREA IN R13\nSAVEAREA DS    18F                   AND BRANCH TO JUMPSAVE\nJUMPSAVE ST    R13,8(R3)  STORE ADDR OF SAVEAREA IN SYSTEM SAVE AREA\n         USING SAVEAREA,R13\n         DROP  R15\n         L     R3,0(0,R1) LOAD THE CONTENTS OF ADDR POINTED TO BY R1\nMVCPARM  MVC   DSN+9(6),2(R3)     SET UP VOLSER\nMVCPARM2 MVC   CVOL,2(R3)    SET UP VOLSER\n         LOCATE HIGHQUAL\n         SPACE 2\n         ABEND 100,DUMP,STEP,SYSTEM   CAUSE A DUMP\nEXIT     L     R13,SAVEAREA+4\n         LM    R14,R12,12(R13)\nSETRC    LA    R15,0\n         BR    R14\n         SPACE\nHIGHQUAL CAMLST NAME,DSN,CVOL,AREA\nDSN      DC    CL44'SYSCTLG.V'\nCVOL     DS    CL6\n         DS    0D\nAREA     DS    CL265\n         SPACE 1\nTEST     CAMLST NAME,DSN,,AREA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TESTXIT": {"ttr": 11020, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x91!\\x1f\\x00\\x91#O\\x11Y\\x00\\x10\\x00\\x0f\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1991-07-30T00:00:00", "modifydate": "1991-08-22T11:59:00", "lines": 16, "newlines": 15, "modlines": 0, "user": "CN03MQK"}, "text": "EXITEST  CSECT\n         PRINT NOGEN\n         USING *,12          ASSIGN BASE REGISTER\n         STM   14,12,12(13)  SAVE REGISTERS\n         LR    12,15         LOAD BASE REGISTER\n         ST    13,SAVEAREA+4 *\n         LR    11,13         *\n         LA    13,SAVEAREA   * SAVE AREA CHAINING\n         ST    13,8(11)      *\n         L     1,0(1)\n         LR    3,1       RECORD ADDR\n         MVC   0(2,3),2(3)   MOVE BYTES 3 AND 4 TO POSITION 1 AND 2\n         L     13,SAVEAREA+4 RECS ARE THE SAME,DELETE REC IN OUTPT AREA\n         RETURN (14,12),RC=0\nSAVEAREA DS    18F\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TESTXITC": {"ttr": 11022, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x91!?\\x00\\x91)_\\x17\"\\x00\\x11\\x00\\x0c\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1991-08-01T00:00:00", "modifydate": "1991-10-22T17:22:00", "lines": 17, "newlines": 12, "modlines": 0, "user": "CN03MQK"}, "text": "000100 ID DIVISION.\n000200 PROGRAM-ID. EXITESTC.\n000300 ENVIRONMENT DIVISION.\n001000 DATA DIVISION.\n001100 LINKAGE SECTION.\n003100 01  SELECTED-RECORD.\n           05  FILLER            PIC X(11).\n           05  JOB-CARD          PIC X(3).\n           05  FILLER            PIC X(16).\n           05  CHK-FOR-SPACES    PIC X(20).\n           05  FILLER            PIC X(30).\n003200 PROCEDURE DIVISION USING SELECTED-RECORD.\n004200     IF CHK-FOR-SPACES = SPACES\n              OR JOB-CARD = 'JOB'\n              MOVE 4 TO RETURN-CODE\n              ELSE MOVE 0 TO RETURN-CODE.\n004900     GOBACK.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VOL2DEVT": {"ttr": 11024, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x17O\\x00\\x93\\x17O\\x18T\\x00\\xc4\\x00\\xc4\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd4\\xd8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-06-23T00:00:00", "modifydate": "1993-06-23T18:54:00", "lines": 196, "newlines": 196, "modlines": 0, "user": "CN03MQK"}, "text": "         PRINT ON,NOGEN\n         SPACE 3\n*        THIS PROGRAM IS A SUBROUTINE WHICH WILL ACCEPT A VOLUME SERIAL\n*        NUMBER AND PASS BACK TO THE INVOKER THE DEVICE TYPE\n*\n*        TO CALL THIS PROGRAM, DO THE FOLLOWING :\n*\n*           MOVE YOUR VOL SER TO VOL-SER-NO OF VOL2DEVT-I-O-AREA.\n*\n*           CALL 'VOL2DEVT' USING VOL2DEVT-I-O-AREA.\n*\n*           AFTER THE CALL, DEVICE-TYPE WILL CONTAIN THE DEVICE TYPE\n*           AND SIGNIF-LENGTH-OF-DEVICE-TYPE WILL CONTAIN THE\n*           SIGNIFICANT LENGTH OF THE DEVICE TYPE\n*\n*                WHERE:\n*\n*              01  VOL2DEVT-I-O-AREA.\n*                  05  VOL-SER-NO                    PIC X(6).\n*                  05  DEVICE-TYPE                   PIC X(8).\n*                  05  SIGNIF-LENGTH-OF-DEVICE-TYPE  PIC S9(3) COMP.\n*\n*\n*         RETURN CODES        MEANING\n*         -----------------   -----------------------------------\n*\n*                 0           SUCCESSFUL COMPLETION\n*                 4           VOLUME NOT MOUNTED\n*                 12          NON RECOGNIZABLE UNIT TYPE\n         EJECT\n         SPACE 3\n*\n**********************************************\n*                                            *\n*        I N I T I A L I Z A T I O N         *\n*                                            *\n**********************************************\n*\nVOL2DEVT CSECT\n         SAVE  (14,12)\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         B     STARTIT\n         SPACE\nSAVEAREA DC    18F'0'\n         SPACE 3\n********************************************************************\n*        EQUATE RESISTERS 0 THRU 15 TO MORE MEANINGFUL NAMES       *\n********************************************************************\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        SAVE REGISTER 1 IN REGISTER 11 AND LOAD PARAMETER FIELD   *\n*        INTO IOAREA                                               *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\nSTARTIT  DS    0D\n         LR    R11,R1              SAVE REGISTER 1 CONTENTS IN REG 11\n         L     R9,0(R11)\n         MVC   IOAREA,0(R9)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        M A I N   L I N E   L O G I C                             *\n*                                                                  *\n********************************************************************\n*\n         L     R9,16                   ADDRESS OF CVT INTO R9\n         XC    UCBWA,UCBWA             UCB LOOKUP LIST FROM CVT\nUCBSCAN  L     R15,1076(R9)\n         LA    R1,PLIST\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   UCBERR1\n         L     R6,UCBADD               GET ADDRESS OF A UCB\n         TM    0(R6),X'80'             IS IT VIO?\n         BO    UCBSCAN                 IF YES, BRANCH TO UCBSCAN\n         TM    3(R6),X'80'             IS IT ONLINE?\n         BNO   UCBSCAN                 IF NOT, BRANCH TO UCBSCAN\n         CLC   VOLSER,28(R6)           TABLE ENTRY VS VOL IN UCB\n         BNE   UCBSCAN                 IF NOT EQUAL, BRANCH TO UCBSCAN\n         CLI   19(R6),X'0B'            3350 DA?\n         BE    D3350                   IF YES, BRANCH TO D3350\n         CLI   19(R6),X'09'            3330 DA?\n         BE    D3330                   IF YES, BRANCH TO D3330\n         CLI   19(R6),X'0D'            3330 DA?\n         BE    D3330                   IF YES, BRANCH TO D3330\n         CLI   19(R6),X'06'            2305 DA?\n         BE    D2305                   IF YES, BRANCH TO D2305\n         CLI   19(R6),X'07'            2305-2 DA?\n         BE    D23052                  IF YES, BRANCH TO D23052\n         CLI   19(R6),X'0E'            3380 DA?\n         BE    D3380                   IF YES, BRANCH TO 3380\n         B     UCBERR2                 WHAT IN THE HECK IS IT THEN?\nUCBERR1  LA    R4,4                   SET R4 = 4\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nUCBERR2  LA    R4,12                  SET R4 = 12\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\nD3350    MVC   DEVTTYPE,=C'3350    '  MOVE 3350 TO DEVTTYPE\n         LA    R7,4                   ---\n         STH   R7,LEN                    --- DEVTLEN = 4\n         MVC   DEVTLEN,LEN            ---\n         B     ALLGOOD                BRANCH TO ALLGOOD\nD3330    MVC   DEVTTYPE,=C'3330-1  '  MOVE 3330-1 TO DEVTTYPE\n         LA    R7,6                   ---\n         STH   R7,LEN                    --- DEVTLEN = 6\n         MVC   DEVTLEN,LEN            ---\n         B     ALLGOOD                BRANCH TO ALLGOOD\nD2305    MVC   DEVTTYPE,=C'2305    '  MOVE 2305 TO DEVTTYPE\n         LA    R7,4                   ---\n         STH   R7,LEN                    --- DEVTLEN = 4\n         MVC   DEVTLEN,LEN            ---\n         B     ALLGOOD                BRANCH TO ALLGOOD\nD23052   MVC   DEVTTYPE,=C'2305-2  '  MOVE 2305-2 TO DEVTTYPE\n         LA    R7,6                   ---\n         STH   R7,LEN                    --- DEVTLEN = 6\n         MVC   DEVTLEN,LEN            ---\n         B     ALLGOOD                BRANCH TO ALLGOOD\nD3380    MVC   DEVTTYPE,=C'3380    '  MOVE 3380 TO DEVTTYPE\n         LA    R7,4                   ---\n         STH   R7,LEN                    --- DEVTLEN = 4\n         MVC   DEVTLEN,LEN            ---\nALLGOOD  LA    R4,0                   SET R4 = 0\n         B     SHUTDOWN               BRANCH TO SHUTDOWN\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        E N D  O F   J O B   P R O C E S S I N G                  *\n*                                                                  *\n********************************************************************\n*\nSHUTDOWN LR    R15,R4\n         L     R9,0(R11)\n         MVC   0(16,R9),IOAREA\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        BREAKDOWN OF IOAREA                                       *\n*                                                                  *\n********************************************************************\n*\nIOAREA   DS    0CL16\nVOLSER   DS    CL6\nDEVTTYPE DS    CL8\nDEVTLEN  DS    CL2\n         EJECT\n         SPACE 3\n*\n********************************************************************\n*                                                                  *\n*        D A T A   A R E A S                                       *\n*                                                                  *\n********************************************************************\n*\n         SPACE 3\n         DS    0F\nLEN      DS    H\nPLIST    DS    0F\nUCBWAP   DC    A(UCBWA)\nUCBCLP   DC    A(DEVCL)\nUCBPTR   DC    X'80',AL3(UCBADD)\nUCBWA    DS    XL100\nDEVCL    DC    X'20'\nUCBADD   DS    A\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT807/FILE807.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT807", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}