*----CHANGE LOG FOR V4.3 ---------------------------------------
* @MK1 6/14/09 CORRECT ADDRESSABILITY ERRORS FOR Z/OS (1.10)
*              INFINITE LOOP IN SPIE RTN
*              FALSE SECURITY VIOLATION INDICATIONS
*              CHANGE DYN ALLOC 'SYSDA' TO 'SYSALLDA'
*---------------------------------------------------------------
         TITLE 'IN-LINE MACROS (MESSAGES,DATE, TIOT AND SUBOPT)'
         MACRO
&LABEL   LNKMSG   &MSGNUM,&BRANCH=,&RETURN=NO,&EDIT=,&DATA=
.*    THE MSGNUM SYMBOLIC CAN BE A DECIMAL NUMBER OR OR A REGISTER
.*        (IN THE NOTATION RX) CONTAINING THE MSG NUMBER
.*    THE DATA SYMBOLIC CAN BE AN ORDINARY RX-TYPE DATA ITEM
.*        OR A SUBLIST CONSISTING OG 2 ELEMENTS- THE FIRST-A REGISTER
.*        CONTAINING THE ADDRESS OF A DATA ITEM AND THE SECOND BEING
.*       THE DEFINED LENGTH (IN ABS DECIM OR REG NOTAT)OF THE DATA ITEM
.*    THIS MACRO WILL GO TO A SUB PROGRAM TO MOVE MESSAGES TO AN
.*    OUTPUT AREA AND PUTS A BRANCH ADDR IN R8(GOREG)
         AIF  ('&MSGNUM'(1,1) NE 'R').DECNUM  IS REGISTER USED
&LABEL   STC  &MSGNUM,BRLNKLST+7    YES-STORE MSGNUM IN LIST
         AGO  .CHKEDIT
.DECNUM  ANOP
&LABEL   MVI  BRLNKLST+7,&MSGNUM  LOAD R1 WITH THE MESSAGE NUMBER
.CHKEDIT AIF  ('&EDIT' EQ '').NOEDIT
         LA   R1,&EDIT      LOAD ADDR OF FIELD TO BE EDITTED IN R1
         ST   R1,BRLNKLST+8    STORE ADDR IN 3RD WORD OF LIST
         AIF  ('&DATA' EQ '').NOEDIT
.MNOTE   MNOTE 8,'BOTH EDIT AND DATA SYMBOLICS MAY NOT BE SPECIFIED'
         AGO  .END
.NOEDIT  AIF  ('&DATA' EQ '').NODATA
         AIF  ('&DATA'(1,1) NE '(').NOTREG
         AIF  ('&DATA'(K'&DATA,1) EQ ')').REG
         MNOTE 8,'DATA PARAM ERROR: END PAREN MISSING;LENGTH NOT NUMER'
         AGO  .MNOTE
.REG     ANOP
         ST   &DATA(1),BRLNKLST+8
         AIF  ('&DATA(2)'(1,1) NE 'R').DECLEN
         STC  &DATA(2),BRLNKLST+8        STORE LENGTH FROM REGISTER
         AGO  .NODATA
.DECLEN  MVI  BRLNKLST+8,&DATA(2)
         AGO  .NODATA
.NOTREG  ANOP
         LA   R1,&DATA
         ST   R1,BRLNKLST+8
         MVI  BRLNKLST+8,L'&DATA  MOVE DATA LEN IN HIGH ORDER BYTE
.NODATA  ANOP
         BAL  GOREG,CALLSUB
         AIF  ('&RETURN' EQ 'NO').NORETRN
         MVI  PARMERR1,C'1'
.NORETRN AIF  ('&BRANCH' EQ '').END
         B    &BRANCH             GO TO THE ROUTINE THAT CALLS THE
.END     MEND
         SPACE 1
         MACRO
&LABEL   MESSAGE &MSGNUM,&EDIT=,&BRANCH=
.*   ***************************************************
.*   *THIS MACRO IS USED TO PRINT MESSAGES             *
.*   *IT REQUIRES THE ERROR MESSAGE NUMBER AND THE     *
.*   *RETURN ADDRESS.  IF NO RETURN ADDRESS IS GIVEN   *
.*   *IT RETURNS TO THE INSTUCTION FOLLOWING THE PRINT *
.*   **DATE MODIFIED ***7/28/80*************************
&LABEL   L     R1,PRINTBUF
         AIF   ('&EDIT' EQ '').NOEDIT
         ED    MSG&MSGNUM.ED,&EDIT
.NOEDIT  ANOP
         MVC   0(MSG&MSGNUM.LEN,R1),MSG&MSGNUM
         BAL   GOREG,PUTPRINT
         AIF   ('&BRANCH' EQ '').END      IF &BRANCH KEYWORD NOT CODED
         B     &BRANCH                      GO TO END OF MACRO
.END     MEND
         SPACE 1
         MACRO
&LABEL   CHCKTIOT &FOUND=,&NOTFND=TIOTERR
&LABEL   BAL  GOREG,CALLTIOT    PERFORM FIND DDNAME ROUTINE
*@MK1    BNE  &NOTFND        DDNAME NOT FOUND
         BNZ  &NOTFND        DDNAME NOT FOUND  @MK1
         AIF  ('&FOUND' EQ '').NOBRNCH
         B    &FOUND        YES
.NOBRNCH MEND
         SPACE 1
         MACRO
&LABEL   CHECKOPT &SUBOPT,&FOUND=,&NOTFND=
&LABEL   LA    R0,4          CHECK UP TO 3 SUBOPTIONS
         LA    R1,WORKFLD+3 START FROM END OF OPTION FLD
         CLI   0(R1),C'&SUBOPT' IS THIS THE SPECIFIED SUBOPTION
         BE    *+14             GO TO SPACE OUT SUBOPTION (MVI)
         BCTR  R1,0             REDUCE ADDRESS BY 1
         BCT   R0,*-10          RETURN TO COMPARE (CLI)
         B     &NOTFND          NOT FOUND
         MVI   0(R1),BLANK1     SPACE OUT SUBOPTION
         AIF  ('&FOUND' EQ '').NOBRNCH
         B     &FOUND
.NOBRNCH MEND
         TITLE 'INIT BASE REGS,PRINT BUFFERS,HEADINGS,PARM FLD,TIOT'
         PRINT NOGEN       DO NOT GENERATE MACRO EXPANSIONS
KEYDUMP  START 0
****************************************************************
*   STORE THE CALLERS REGISTERS AND ESTABLISH R13,R10,R11 AND  *
*   R12 AS BASE REGISTERS FOR THIS PROGRAM.                    *
         EXTRN SYNADERR   PULL IN THE SYNADERR ROUTINE FROM HRA.LOADLIB
         EXTRN MOVEMSG
         ENTRY ABEND,SETRC ENTRY FOR SYNADERR RTN AFTER 5 BLOCKS & RC
         ENTRY RETURN3  ENTRY FOR SYNAD AFTER 5 BLOCKS & RC (LIBFILE)
         USING *,R15      USE R15 TEMPORARILY AS A BASE
         STM   R14,R12,12(R13)      SAVE SYSTEM REGISTERS
         ST    R13,SAVEAREA+4 STORE ADDR OF SYSTEM SAVE AREA IN SAVEARE
         LR    R3,R13       LOAD R3 WITH ADDRESS OF SYSTEM SAVE AREA
         LM    R10,R12,BASES   SET BASE REGISTERS R10,R11 & R12
         CNOP  0,4        TO ALIGN THE BAL INSTR ON A FULLWORD
         BAL   R13,JUMPSAVE    STORE THE ADDRESS OF SAVEAREA IN R13
SAVEAREA DS    18F                   AND BRANCH TO JUMPSAVE
BASES    DC    A(SAVEAREA+4096,SAVEAREA+8192,SAVEAREA+12288)
JUMPSAVE ST    R13,8(R3)  STORE ADDR OF SAVEAREA IN SYSTEM SAVE AREA
         USING SAVEAREA,R13,R10,R11,R12 REGS 13,10,11& 12 USED AS BASES
         USING TIOENTRY,R4   MAKE TIOT DD ENTRY ADDRESSABLE
         DROP  R15
******************************************************************
* LOAD R3 WITH THE ADDRESS OF THE DATA AREA (PARM) PASSED        *
*  AND EDIT THE PARM VALUE                                       *
******************************************************************
         L     R3,0(0,R1) LOAD THE CONTENTS OF ADDR POINTED TO BY R1
         USING PARMDS,R3   THIS IS THE DSECT OF THE PASSED (PARM) AREA
         SPACE 2
         SPIE  SPIEXIT,((1,7),9,11,12,15) ESTABLISH SPIE ENVIRONMENT
         ST    R1,SAVESPIE      SAVE PREVIOUS ENVIRONMENT
         ESTAE ESTAEXIT,CT,PARAM=ESTAPARM,PURGE=HALT,ASYNCH=NO
         SPACE 1
         L     GOREG,=A(CLRSCRN)   EXECUTE CLRSCRN VTAM CSECT
         BALR  R14,GOREG         TO CLEAR THE SCREEN ON CLISTS
         SPACE 1
         TIME  DEC    REQUEST THE DATE IN R1
         ST    R1,PARMEND  STORE THE DATE PACKED FORMATIN PARMEND
         SPACE 2
         L     R2,=A(EXITS)     GET DCB ADDR OF EXITS FILE
         CHCKTIOT NOTFND=EXITOK
         L     R15,=A(EXITSECT) CHECKS FOR ANY EXITS
         BALR  R14,R15
         LTR   R15,R15          ANY ERRORS ON EXITS CONTROL STATEMENTS
         BZ    EXITOK           NO
         MVI   XITERR+1,SETNOP YES-PUT OUT ERROR MSG AFTER OPEN SYSPRT
EXITOK   EQU   *
         TITLE 'OPEN PRINT FILE AND WRITE HEADING'
         L     R2,ASYSPRNT      GET SYSPRINT DCB FOR TIOT CHECK
         CHCKTIOT NOTFND=NOSYSPRT IS SYSPRINT IN JCL
SYSPRINT L     R2,ASYSPRNT   GET SYSPRINT DCB AGAIN (FOR DEFLT R,1,1)
         BAL   GOREG,OUTATTR  OPEN SYSPRINT
*        EXTRACT WORKFLD1,'S',FIELDS=(TIOT)  GET THE ADDR OF THE TIOT
*        L     R4,WORKFLD1
         SR    R5,R5    GET PSA ADDR
         USING PSA,R5
         L     R5,PSATOLD   GET TCB ADDR
         USING TCB,R5
         L     R5,TCBTIO    GET TIOT ADDR
         DROP  R5
         LNKMSG 54,DATA=(R5,24)  PRINT JOBNAME/PROCSTEPNAME/STEPNAME
*   START TO VERIFY THE PARM. IF PARM FLD IS NOT CODED PUT OUT ERR MSG
         LA    R7,NUMBPARM+1  POINT TO 1 LESS THAN THE START OF PARM
         LH    R5,NUMBPARM   LOAD REG 4 WITH THE NUMBER OF CHARACTERS
         LTR   R5,R5         IS THE NO OF CHARS IN PARM = 0
         BZ    DEFAULT  YES -USE DEFAULT PARM OF 'R,1,1'
PRNTPARM LA    R1,DATAPARM     POINT TO DATA PORTION OF PARM FIELD
         LNKMSG 0,DATA=(R1,R5)    PRINT PARM
         BCTR  R5,0          SUBTRACT 1 FROM NO OF CHARS IN PARM
         LA    R5,0(R5,R7)      LOAD ADDR OF THE END OF THE PARM FLD
         ST    R5,PARMEND       STORE IN PARMEND
         MVC   WORKFLD(5),1(R7) MOVE OPTION INTO WORKFLD
*        ABOVE NEEDED FOR BACKWARD CHK ONLY (MOVED IN MOVEPARM)
         SPACE 1
XITERR   B     CONTPARM       SET TO NOP IF ERROR IN EXITS FILE
         MVI   XMSGNOP+1,SETBR   PRINT ALL EXITS CONTROL STATEMENTS
         L     R1,=A(EXITTBL)    PLACE ADDR OF BEGINNING OF MSGS IN R1
         B     VMSGPT             GO DO IT
XITERR2  MVI   XMSGNOP+1,SETNOP  RESET NOT TO COME BACK
         LA    R1,8           PUT OUT ERROR MSG 8
         B     LNKMSG1
CONTPARM EQU   *
         SPACE 2
         CLI   WORKFLD,C'V'     IS V OPTION REQUESTED
         BE    MOVEPARM         BYPASS FILE PROCESSING & DCB EXIT
         MVI   EXLSTDCB,X'05'   ACTIVATE DCB EXIT (INACTIVE FOR V OPT)
         DROP  R3   REGISTER 3 NOW FREE OF THE PARM FIELD
         TITLE 'CHECK FOR CONVERT DD'
         L     R2,ACONVERT          IS THERE A CONVERT DD IN THE JCL
         CHCKTIOT NOTFND=NOCNVRT
         BAL   GOREG,OPENINP  OPEN CONVERT FILE
         MVI   CNVRTBR1+1,SETNOP SET NOP FOR CONVERT
         MVI   CNVRTBR2+1,SETNOP
         MVI   CNVRTBR3+1,SETNOP
         MVI   CNVRTVB1+1,SETNOP
         MVI   CNVRTVB2+1,SETNOP
         MVI   CNVRTVB3+1,SETNOP
         MVI   CNVRTBL1+1,SETNOP
         MVI   CNVRTBL2+1,SETNOP
         MVI   CNVRTBL3+1,SETNOP
         MVI   CNVRTVL1+1,SETNOP
         MVI   CNVRTVL2+1,SETNOP
         MVI   CNVRTVL3+1,SETNOP
         MVI   CNVRTNOP+1,SETNOP
         MVI   DINVAL+1,SETBR   MAKE D OPTION INVALID
         MVI   EKEY+1,SETBR   MAKE E OPTION INVALID
         MVI   RKEY+1,SETBR   MAKE R OPTION INVALID
         MVI   CHKAOPT+1,C'X'   MAKE A OPTION WITHOUT SYSIN INVALID
*    SET B=,E=,J=,ETC IN CASE RANDOM OPTION REQUESTED
         ZAP   END,=P'257'     FOR RANDOM GENERATE 256 RANDOM ENTRIES
         ZAP   BEGIN,PACKZERO   IN RANGE OF 1-256
         ZAP   COUNT,=P'256'
         MVC   RANDMHDR+8(25),=C'    ENCRYPTION CODE TABLE'
         MVI   RNDMNOP+1,SETBR  SET BR TO RETURN TO EOFCNVRT FROM RNDM
         ST    R7,SAVEREGS     SAVE R7 PARM ADDR
         LA    R9,INCARD MOVE INCARD ADDR TO R9 IN CASE RANDOM PROC
CNVRTGET L     R1,ACONVERT  GET CONVERT DCB
         GET   (R1)         GET RECORD
         MVC   CNVRTCOD,0(R1)  MOVE FIRST 4 BYTES TO CNVRTCOD
         MVC   INCARD,0(R1)    MOVE FIRST CONVERT RECORD TO INCARD
         LNKMSG 87,DATA=INCARD   PRINT CONVERT KEY
         CLC   INCARD(6),=C'RANDOM'   RANDOM REQUESTED?
NOPAFTR1 BE    RNDMCNVT     YES - SET TO NOP AFTER 1ST RANDOM
         MVI   LOOPCNVT+1,SETBR  SKIP SETTING TABLE WITH RANDOM NO.
         MVI   NOPAFTR1+1,SETNOP DONT ALLOW RANDOM IF NOT 1ST KEY
         SPACE 3
         CLI   CNVRTCOD,C'@'     IS E OPT @ CHANGE REQUESTED
         BE    SETECHG@          YES
         CLI   CNVRTCOD,C'$'     IS E OPT $ CHANGE REQUESTED
         BE    SETECHG$          YES
         SPACE 3
*        THE RECORD CONSISTS OF EITHER AN * FOLLOWED BY A FROM CHARACTR
*        AND A 'TO' CHARACTER OR A 2-BYTE HEX 'FROM' CODE AND A 2-BYTE
*        'TO' HEX CODE WHICH WILL BE PLACED IN A TRANSLATION TABLE
         MVC   CRYPTWK+4(2),CNVRTCOD+1  IF 1ST BYTE=* PLACE CHAR CODES
*        IN BYTES 4 AND 5 OF CRYPTWK WHICH HOLD THE 'FROM'/'TO' CODES
         CLI   CNVRTCOD,C'*'   IS 1ST BYTE=*
         BE    CHRCNVRT        YES- SKIP HEX TRANSLATION
         L     R15,=A(HEXTAB1)  GET TABLE OF VALID HEX CODES
         TRT   CNVRTCOD,0(R15)   SEE X= AND Y= ROUTINES FOR EXPLANATION
         BNZ   HEXERR
         L     R15,=A(HEXTAB2)         SEE PROCESS X= FOR EXPLANATION
         TR    CNVRTCOD,0(R15)         __________________
         PACK  CRYPTWK(3),CNVRTCOD(4)  | 0| 1| 2| 3| 4| 5| -OFFSETS IN
         MVC   CRYPTWK+5(1),CRYPTWK+2  |__|__|__|__|__|__|  CRYPTWK
         MVO   CRYPTWK+3(3),CRYPTWK(2)   P A C K|HEX REPRE
CHRCNVRT SR    R2,R2           ZERO OUT R2
         IC    R2,CRYPTWK+4    PLACE 'FROM' HEX CODE IN R2
         IC    R5,CRYPTWK+5    PLACE 'TO' HEX CODE IN R5
         L     R15,=A(CNVRTABL)  GET CONVERT TABLE
         STC   R5,0(R2,R15) REPLACE 'FROM' CODE WITH 'TO' CODE IN TABL
         B     CNVRTGET     GET NEXT RECORD
         SPACE 2
EOFCNVRT XC    INCARD,INCARD     REZERO INCARD
         ZAP   COUNT,=P'999999999999999'  RESET
         ZAP   END,=P'999999999999999'
         L     R7,SAVEREGS     RESTORE
         L     R5,=A(CNVRTABL)
         L     R1,TABLE
         LA    R2,1020    POINT TO LAST ELEMENT IN RANDOM TABLE
LOOPCNVT NOP   NOCNVRT   SET TO B IF RANDOM NOT SELECTED
         L     R9,0(R2,R1)   GET RANDOM ELT
         STC   R9,0(0,R5)    STORE IN CONVERT TABLE
         LA    R5,1(R5)   POINT TO NEXT ENTRY IN CONVERT TABLE
         S     R2,FULL4   POINT TO NEXT ENTRY IN RANDOM TABLE
         BNM   LOOPCNVT   LOOP TILL DONE
         MVI   LOOPCNVT+1,SETBR  IF THERE ARE MORE RECORDS IN CONVERT
         MVI   NOPAFTR1+1,SETNOP AFTER RANDOM= SET NOP AND BR TO
         B     CNVRTGET      PROCESS REST OF RECORDS AND BRANCH TO GET
         SPACE 3
SETECHG@ MVI   E@CHGBR+1,SETBR SET B TO OUTPUT ALL RECS TO SYSUT2
         MVI   BRPTOUT2+1,SETNOP SET NOP AS IF PROCESSING SYSUT3
*        WHETHER SELECTED OR NOT (CHG FLDS ARE CHANGED)
*        WHETHER B= IS CODED     (CHG FLDS ARE NOT CHANGED)
         MVI   E@EQUBR+1,SETBR   CONTINUE PROCESSING AFTER E=
         SPACE 1
SETECHG$ CLI   WORKFLD,C'E'  IS E OPT REQUESTED
         BNE   KEYINVAL      NO- ERROR
         MVI   EKEY+1,SETNOP   YES - RESET E KEY VALIDATION
         MVI   ECHGMSG+1,SETNOP NOP TO PUT OUT CNT OF KEY CHANGES
         MVC   ECHGKEY+20(19),INCARD+1  SAVE CHG KEY(MINUS $)
         B     EOFCNVRT
         TITLE 'CHECK IF VS,IS && OPEN BACKWARDS ON W OPTION REQUESTED'
NOCNVRT  L     R2,=A(ACBVSK)      GET VSAMKEY ACB (FOR DDNAME)
         CHCKTIOT NOTFND=NVSAMKEY IS IT A VSAMKSDS/RRDS
         MVI   TKEY+1,SETBR        DISALLOW E,G,P,T OPTIONS
         MVI   OKEY1+1,SETBR                B,C,O
         MVI   RKEY+1,SETBR                 R
         MVI   VSAMFLAG,C'1'                N SUBOPTION
         MVI   VSAMGET+1,SETNOP   SET NOP TO MODIFY THE RPL WITH KEYLEN
         MVI   VSKEYNOP+1,SETNOP SET NOP TO CHK IF POINT HAS POSITIONED
*                                BACKWARD AFTER A SEQUENTIAL READ
         MVI   NOPBEQU+1,SETNOP SET NOP TO TO IGNORE B= PARAMATER
         B     VSCOMMON             BRANCH TO COMMON VSAM CODE
         SPACE 1
NVSAMKEY L     R2,=A(ACBVSF) NOT VSAM KSDS/RRDS-GET VSAMFIL ACB(FOR DD)
         CHCKTIOT NOTFND=NOTVSAM  IS THIS A VSAM ESDS
         MVI   VSAMFLAG,C'0'        SET FLAG TO 0 FOR VSAMFILE
VSCOMMON L     R15,=A(VSAMSECT)     BRANCH TO VSAM CSECT
         BALR  R14,R15
         ST    R5,DCBADDR           LOAD RPL ADDR FOR VSAM GET MACRO
         MVI   CHKDCB+1,SETBR       DEACTIVATE THE DCB CHECKING
         MVI   BR2VSGET+1,SETBR     SET BRANCH FOR VSAM GET MACRO
         MVI   DINVAL+1,SETBR     SET BRANCH TO SKIP D OPTION
         MVI   MSG40ORG,C'V'    MOVE VS TO DSORG MSG
         MVI   MSG40FVU,C'V'    MOVE V TO RECFM
         MVI   OPTCDU+1,SETBR   DONT DO DCB CHECKING ON OUTPUT FILES
         B     CHKBACKW             BRANCH TO OPEN INSTRUCTION
NOTVSAM  L     R2,AISAM      LOAD ADDR OF ISAM DCB IN R2
         ST    R2,DCBADDR    AND SAVE IT IN DCBADDR
         CHCKTIOT FOUND=CHKBACKW,NOTFND=NOTISAM
NOTISAM  L     R2,ALIBRARY
         ST    R2,DCBADDR
         CHCKTIOT NOTFND=NOTLIBF
         MVI   GETLIB+1,SETNOP
         MVI   DINVAL+1,SETBR     SET BRANCH TO SKIP D OPTION
         L     R2,=A(MEMSYSIN)    GET MEMSYSIN DCB
         CHCKTIOT NOTFND=CHKMEMNM
         MVI   MEMFLAG,C'1'         SET FLAG FOR LIBCSECT
         MVI   MEMBMSG+1,SETNOP     SET NOP TO WRITE MEMBER MSG
CHKMEMNM L     R2,AMEMBNAM  CHECK IF MEMBNAME DD CODED
         CHCKTIOT NOTFND=RESETDD
         DEVTYPE DCBDDNM(R2),DVCTYPE
         BAL   GOREG,OUTATTR    OPEN MEMBNAME
         CLC   DVCTYPE(8),LOWVALUE  IS MEMBNAME DUMMY
         BNE   MEMNODUM      NO
         MVI   MEMBMSG+1,SETNOP PUT OUT MEMBER MSGS ONLY
         B     RESETDD
MEMNODUM NI    NOPFMEMB+1,X'0F' NOP TO OUTPUT MEMBNAME WHEN SYSUT2 WRIT
RESETDD  L     R2,ALIBRARY          RESET FOR INPUT FILE MSG
         B     CHKBACKW
NOTLIBF  NOP   MOVEPARM     SET TO BRANCH WHEN NOINPUT IN X0 EXIT
         L     R2,AINFIL    GET SYSUT1 DCB ADDR
         ST    R2,DCBADDR
         CHCKTIOT                  IS SYSUT1 DDNAME IN JCL
CHKBACKW MVC   DDN,DCBDDNM(R2)     SET DDNAME FOR MSG 40
         CHECKOPT W,NOTFND=FORWDOPN CHK IF W SUBOPT REQ
         DEVTYPE DCBDDNM(R2),DVCTYPE  CHECK TO INSURE INPUT ON TAPE
         CLI   DVCTYPE+2,X'80'   IS DEVICE MAGNETIC TAPE
         BE    BACKOPEN          YES-OK TO OPEN BACKWARDS
         CLI   VSAMFLAG,C'0'  NO-IS VSAMFILE DDNAME USED
         BNE   BACKWERR          NO - ERROR
         L     R5,DCBADDR        YES-OK-GET VSAMFILE RPL ADDR
         MODCB RPL=(R5),OPTCD=(BWD,LRD)  MODIFY RPL TO READ BACKWARDS
         MVI   VSMPOINT+1,SETNOP  SET NOP TO ISSUE POINT TO LAST RECORD
         B     FORWDOPN
         SPACE 2
BACKOPEN OPEN  ((R2),RDBACK)    YES-OPEN SYSUT1 BACKWARDS
         CLI   OPENERR,C'1'     HAVE ANY OPEN BOMBS BEEN RECOVERED
         BE    ERROREOJ                 YES
         MVI   OPENBACK,C'W'     SET FLAG TO INDICATE BACKWARD OPEN
         B     CHKDCB
BACKWERR LNKMSG 46,RETURN=YES  DEVICE IS NOT TAPE -PUT OUT ERROR MSG
         SPACE 2
FORWDOPN BAL   GOREG,OPENINP  OPEN PRIMARY FILE
         TITLE 'INPUT(SYSUT1,ISAM,VSAM) ATTRIBUTES'
CHKDCB   NOP   PUTMSG     DCB INFORMATION OF SYSUT1/ISAM. B ON VSAM
         L     R3,DCBADDR   LOAD R3 WITH THE ADDRESS OF INFIL/ISAM
         USING IHADCB,R3
CHKDCB2  MVI   URECFMBR+1,SETNOP  RESET FOR RECFM=U SYSIN RECS
         MVI   BRANCHV+1,SETNOP  RESET FOR RECFM=V SYSIN RECS
         MVI   FILLREST,X'48'    RESET FOR SYSIN RECS
         MVC   MSG40ORG(2),=C' S'     RESET FOR SYSIN FILE
         MVC   MSG40FVU,MSGSPACE   RESET FOR SYSIN FILE
         MVC   INRECFM,DCBRECFM  SAVE THE INPUT RECFM IN INRECFM
         MVC   INRECFM2,DCBRECFM SAVE THE INPUT RECFM IN INRECFM2
         TM    DCBRECFM,X'10'    IS DATA SET BLOCKED
         BNO   NOTBLK             NO
         MVI   MSG40FVU+1,C'B'    YES
NOTBLK   TM    DCBRECFM,X'08'    ARE RECORDS STANDARD(F) OR SPANNED(V)
         BNO   RECFMNS            NO
         CLI   MSG40FVU+1,C'B'    YES-ARE RECORDS BLOCKED
         BE    SRECFM             YES
         MVI   MSG40FVU+1,C'S'    NO-MOVE IN S TO RECFM
         B     RECFMNS
SRECFM   MVI   MSG40FVU+2,C'S'
RECFMNS  TM    DCBRECFM,X'C0'    IS RECFM=U
         BNO   VORFREC           NO -IT IS EITHER V OR F
         MVI   MSG40FVU,C'U'    MOVE U TO RECORD TYPE FOR PRINTING
         MVI   URECFMBR+1,SETBNE SET BNE IF LRECL NOT = BLKSIZE
         LH    R4,DCBBLKSI      SET LRECL TO BLKSIZE
         MVI   FILLREST,X'49'   SET NOP (CH INSTR) WHEN LOADING LRECL
         MVI   COMPRDW+1,SETNOP SET NOP ON U RECS FOR AL,ML
*        ABVE WILL WORK FOR SYSUT1/SYSIN WITH ANY COMBINATION OF RECFM
*        EXCEPT FOR V AND U.
         B     NOPV              GO TO LRECL & BLKSIZE PROCESSING
*        BUT FIRST SET L SUBOPTION NOPS AND BRANCHES
VORFREC  TM    DCBRECFM,RECFMF   IS RECFM=F
         BNO   VREC              NO -IT IS V
         MVI   MSG40FVU,C'F'    MOVE F TO RECORD TYPE FOR PRINTING
         B     FILLREST
VREC     TM    DCBRECFM,X'40'    IS RECFM=V
         BNO   RECFMERR          THERE IS AN ERROR IN THE RECFM
         MVI   MSG40FVU,C'V'    MOVE V TO RECORD TYPE FOR PRINTING
         MVI   BRANCHV+1,SETBR  BYPASS INTEGRAL MULTIPLE BLKSIZE TEST
NOPV     MVI   SYSUTVAR+1,SETBR SET BR ON V RECS FOR AL,ML SYSUT PROC
         MVI   NOPV,X'95'   CHANGE ABOVE INSTRUCTION TO CLI I.E. NOP IT
*        THE MVI IS NOPED SO AS NOT TO SET BRANCH IF ONLY SYSIN IS V
         MVI   COMPLKEY+1,SETBR  ALLOW ONLY 1 L,P ON AL,ML OPTIONS
*
FILLREST LH    R4,DCBLRECL  PUT INPUT LRECL IN R4;SET TO CH ON RECFM=U
         ST    R4,MAXLEN         SAVE THE INPUT LRECL IN MAXLEN
         CVD   R4,INLRECL    CONVERT THE LRECL TO DECIMAL FOR PRINTING
         MVC   MSG40REC,MSG23ED       RESET MASK
         ED    MSG40REC,INLRECL+5  EDIT THE LRECL
         LH    R4,DCBBLKSI       LOAD THE INPUT BLKSIZE INTO R4
         ST    R4,MAXBLK         SAVE THE BLKSIZE IN MAXBLK
         CVD   R4,INBLKSIZ   CONVERT THE BLKSIZE TO DECIMAL FOR PRINT
         MVC   MSG40BLK,MSG23ED          RESET MASK
         ED    MSG40BLK,INBLKSIZ+5    EDIT THE BLKSIZE
         RDJFCB ((R3))       READ THE JFCB FOR THIS INPUT FILE
         MVC   MSG40VOL,JFCBVOLS     MOVE VOLSER TO MESSAGE
         MVC   MSG40DSN,JFCBDSNM      MOVE THE DSN TO MSG
         MVI   MSG40ORG,C'V'              VS (FOR ISAM-VSAM INTERFACE)
         TM    JFCDSRG2,JFCORGAM      IS DSORG=VS
         BO    PUTMSG                      YES
         MVI   MSG40ORG,C'I'              IS
         TM    JFCDSORG,JFCORGIS      IS DSORG=IS
         BO    PUTMSG                      YES
         MVI   MSG40ORG,C'P'              PS
         TM    JFCDSORG,JFCORGPS      IS DSORG=PS
         BO    PUTMSG                      YES
         MVC   MSG40ORG(2),=C'PO'
         TM    JFCDSORG,JFCORGPO      IS DSORG=PO
         BO    PUTMSG                      YES
         MVC   MSG40ORG(2),=C'DA'     DSORG=DA
PUTMSG   MVC   MSG40+9(8),DDN     MOVE DDNAME TO MSG
         MESSAGE 40                   PRINT DCB MESSAGE
SYSINDCB NOP   VRETURN       CHANGED TO B ON WHEN V= REQUESTED
         L     R2,AOUTFIL       GET SYSUT2 DCB FOR CHCKTIOT & OPEN
         CHCKTIOT NOTFND=NOSYSUT2
         BAL   GOREG,OUTATTR OPEN & PUT SYSUT2 ATTRIBUTE MESSAGE
         B     MOVEPARM
         SPACE 2
NOSYSUT2 CLI   GETLIB+1,SETNOP  WAS THE INPUT LIBFILE
         BNE   NOLIBFIL     NO-CHK IF VSAMOUT CODED
         L     R2,ALIBOUT           YES- IS LIBOUT PDS REQUESTED
         CHCKTIOT NOTFND=BYPSYST2
         MVI   MSG85+26,C'O'   CHANGE MSG85 DSORG TO PO
         BAL   GOREG,OUTATTR     OPEN & PUT OUT ATTRIB MSG
         MVI   MSG85+26,C'S'   RESET MSG85 DSORG TO PS
         MVC   LIBOTBAL(2),SETBAL   SET UP BAL TO WRITE LIBOUT
         MVI   EOJ+1,SETNOP ISSUE LIBOUT MSG AT EOJ
COMONSET MVI   SKIPPUT2+1,SETBR  BYPASS REGULAR WRITE OF SYSUT2
         MVI   SYSOUTER+1,SETBR  DISALLOW SYSOUT ON LIBOUT
         B     MOVEPARM
         SPACE 1
NOLIBFIL L     R2,=A(ACBVSOUT)   YES- IS VSAMOUT REQUESTED (GET ACB)
         CHCKTIOT NOTFND=BYPSYST2  ALLOWED ON ANY OPT
*                    AS LONG AS FILE IS SORTED ON PREDEFINED VSAM KEY
         MVC   MSG40REC,MSG23ED     RESET EDIT MASKS
         MVC   MSG40BLK,MSG23ED     RESET EDIT MASKS
         MVC   MSG40+9(8),ACBDDNM(R2) MVE IN VSAMOUT R2=A(ACB)
         L     R15,=A(VSAMSECT)  SETUP MSG40 AND THE ACB AND RPL
         BALR  R14,R15
         ST    R5,VSOUTRPL      SAVE VSAMOUT RPL ADDR
         MVC   MSG85+8(MSG85LEN-8),MSG40+8   SET OUTPUT MSG85
         MESSAGE 85
         MVC   VSOUTBAL(2),SETBAL   SET UP BAL TO WRITE VSAMOUT
         MVI   VSMOVREC+1,SETBR DONT MOVE INPUT VSAM RECS TO V WKAREA
         CLI   VSAMFLAG,C' '    WAS INPUT VSAM?
         BE    COMONSET         NO
         MVI   SYST3NOP,X'95'  YES-BOTH IN & OUTPUT VSAM- NO SYST3
*        MVI INSTRUCTION CHANGED TO CLI (TO PROHIBIT CREATION OF SYST3)
         B     COMONSET    BYPASS WRITE OF SYSUT2,DISALLOW SYSOUT
         SPACE 1
BYPSYST2 MVI   PUTFILE+1,SETBR        BYPASS WRITING THE OUTPUT REC
         B     MOVEPARM
         TITLE 'DCB OPEN EXLST ROUTINE'
*       RULES FOR DCB CHECKING- IF THE OUTPUT RECORD TYPE DOESN'T MATCH
*       THE INPUT RECORD TYPE THEN THE OUTPUT RECFM,LRECL & BLKSIZE ARE
*       ALL COPIED FROM THE INPUT. LIKEWISE, IF THE INPUT LRECL DOESN'T
*       MATCH THE OUTPUT LRECL. IF THE RECORD TYPE & LRECL ARE OK THE
*       BLKSIZE IS CHECKED FOR COMPATIBILITY (SEE MSG43 & MSG44).
*
*   SAVEAREA IS BEING USED AS THE THE SAVE AREA BY THE SYSTEM SINCE R13
*   CONTAINS THE ADDRESS OF SAVEAREA.
*      REGISTERS:
*        R4 -ON ENTRY R4 MUST POINT TO THE TIOT (TO GET DDNAME) -
*            THIS IS ALWAYS THE CASE SINCE THE DCB OPEN EXIT, WHICH IS
*            INVOKED FOR OUTPUT FILES AT OPEN TIME, ALWAYS FOLLOWS
*            THE CHKTIOT MACRO WHEN THE OUTPUT FILE IS OPENED
*        R14 IS SAVED IN SAVEREGS, GOREG IS SAVED IN WORKFLD1
EXLSTDCB DS    0F            BEGIN EXLST ON A FULLWORD BOUNDARY
         DC    X'00'  DEFINE ENTRY AS DCB EXLST X'05' FOR NON V OPT
         DC    AL3(DCBEXIT)
JFCBXLST DC    X'87'         JFCB EXIT-LAST EXIT IN LIST
         DC    AL3(INFMJFCB) ADDR OF JFCB MAPPING MACRO FOR OUTPUTS
DCBEXIT  ST    R14,SAVEREGS      SAVE R14
         ST    GOREG,WORKFLD1    SAVE GOREG,THIS EXIT INVOKED FROM
*                     A BAL GOREG ROUTINE (OUTATTR)
         LR    R3,R1             MOVE DCB ADDRESS TO R3
*   NEXT INSTRUCTION REQUIRES THAT R4 POINT TO TIOT (FROM CHKTIOT)
         MVC   DDN,TIOEDDNM     SAVE DDNAME FOR DCBBUFX CSECT
         DEVTYPE TIOEDDNM,DVCTYPE  IS OUTPUT BLKSIZE IS LEGAL FOR DEV
         CLC   DVCTYPE,=X'00000102'  IS THE OUTPUT A SYSOUT DATA SET
         BE    SYSOUT            YES
         TM    DCBOPTCD,X'40'   NO-WAS DCB=OPTCD=U CODED ON NON-SYSOUT
DCBVAL   BO    RETURNU   YES - DO NOT DO DCB CHECKING (PRT ATTR)
*  DCBVAL SET TO BRANCH WHEN NODCBVAL OPTION SET IN X0 EXIT
OPTCDU   NOP   RETURN SET TO BR ON VSAMFILE/KEY WHEN OUTPUTING NON-VSAM
*        FILES TO BYPASS CHKING OUTPUT ATTRIB AGAINST THE INPUT VSAM
         MVC   OUTRECFM,DCBRECFM SAVE THE OUTPUT RECFM IN OUTRECFM
         NI    INRECFM,X'C0'   'AND' THE INPUT RECFM WITH 11000000
         NI    OUTRECFM,X'C0'   'AND' THE OUTPUT RECFM WITH 11000000
         CLC   INRECFM,OUTRECFM  COMPARE INPUT & OUTPUT RECORD TYPES
         BNE   CHANGE            THEY ARE NOT THE SAME
         CLC   DCBLRECL,MAXLEN+2  COMPARE INPUT AND OUTPUT LRECL'S
         BE    CHKBLK     CHANGED TO NOP WHEN RECORD TYPES DONT MATCH
CHANGE   MVC   DCBLRECL,MAXLEN+2  MOVE INPUT LRECL TO OUTPUT LRECL
         MVC   DCBRECFM,INRECFM2  MOVE INPUT RECFM TO OUTPUT RECFM
         MVC   DCBBLKSI,MAXBLK+2  MOVE INPUT BLKSIZE TO OUTPUT BLKSIZE
         LNKMSG 42,DATA=SYSUT,BRANCH=ENDDCB PRNT WARNING ON RECFM/LREC
CHKBLK   LH    R5,DCBBLKSI    LOAD R5 WITH THE OUTPUT BLKSIZE
         C     R5,MAXLEN    IS THE BLKSIZE = LRECL
URECFMBR NOP   CHNGBLK      CHANGED TO BNE WHEN RECFM=U
         SR    R4,R4        LOAD R4 WITH SIGNED ZEROS
         D     R4,MAXLEN    DIVIDE THE BLKSIZE BY THE LRECL
         LTR   R5,R5        IS BLKSIZE LESS THAN LRECL,R5=QUOTIENT
         BZ    CHKVBS      YES-THE QUOTIENT R5=0-CHECK IF RECFM=VS,VBS
BRANCHV  NOP   CHECKV       CHANGED TO BRANCH ON VARIABLE RECORDS
         LTR   R4,R4        IS BLKSIZE AN INTEGRAL MULTIPLE OF LRECL
         BNZ   CHNGBLK      NO-THE REMAINDER R4 DOESNT CONTAIN 0.
         TM    DCBRECFM,X'10'  IS OUTPUT FILE BLOCKED
         BO    ENDDCB          YES
         C     R5,FULL1        NO- IS BLKSIZE = LRECL
         BE    ENDDCB          YES
         MVC   DCBBLKSI,MAXLEN+2  NO-MOVE LRECL TO BLKSIZE
         MVC   MSG44BLK,=C'LRECL  '   CHANGE WARNING MSG
         B     BLKSIMSG
CHNGBLK  MVC   DCBBLKSI,MAXBLK+2  MOVE INPUT BLKSIZE TO OUTPUT BLKSIZE
BLKSIMSG LNKMSG 43,DATA=SYSUT
         LNKMSG 44,DATA=MSG44BLK     PRINT WARNING MSG ON BLKSIZE
ENDDCB   EQU   *
         CLC   DVCTYPE(8),LOWVALUE  IS THE OUTPUT A DUMMY DATA SET
         BE    RETURN               YES
*        CLC   DVCTYPE+6(2),DCBBLKSI  NO-IS BLKSIZE TOO LARGE
*        BL    BLKNG      BLKSIZE DOESNT EXCEED LEGAL MAX FOR DEVICE
         CLC   DCBRECFM,INRECFM2      IS OUTPUT RECFM EXACTLY = INPUT
         BNE   OKDCBCHG               NO
         CLC   DCBBLKSI,MAXBLK+2      IS OUTPUT BLKSIZE EXACTLY=INPUT
         BE    RETURN                 YES
OKDCBCHG LNKMSG 39,DATA=SYSUT
*
RETURN   MVC   MSG85FVU(1),MSG40FVU  SKIP ON OPTCD=U (RECFM MAY CHANGE)
RETURNU  MVC   MSG44BLK,=C'BLKSIZE'  RESTORE MESSAGE
         LR    R1,R3             PASS DCB ADDRESS TO DCBBUFX CSECT
         L     R15,=A(DCBBUFX)
         BALR  R14,R15           DO BUFNO PERFORMANCE
         L     GOREG,WORKFLD1    RESTORE GOREG
         L     R14,SAVEREGS      RESTORE  R14
         BR    R14                    RETURN TO OPEN MACRO
         SPACE 3
CHECKV   C     R5,FULL1    ON VARIABLE RECORDS,IS BLKSIZE = LRECL
         BNE   ENDDCB      NO-BLKSIZE IS AT LEAST TWICE LRECL-OK
         C     R4,FULL4    YES-IS BLKSIZE AT LEAST 4 BYTES GREATER
         BL    CHNGBLK     NO-PUT OUT WARNING AND CHANGE BLKSIZE
         B     ENDDCB      YES-BLKSIZE IS OK
         SPACE 3
CHKVBS   CLI   MSG40FVU,C'V'  IS RECFM=V
         BNE   CHNGBLK        ERROR-LRECL IS GREATER THAN BLKSIZE
         CLI   MSG40FVU+1,C'S'   IS RECFM=VS
         BE    ENDDCB          OK- SPANNED RECORD
         CLI   MSG40FVU+2,C'S'   IS RECFM=VBS
         BE    ENDDCB           OK
         B     CHNGBLK         ERROR
         SPACE 3
SYSOUT   EQU   *
         TM    DCBOPTCD,X'40'   WAS DCB=OPTCD=U CODED ON SYSOUT
EXITNOP3 BO    OPTCDU           YES - DO NOT DO SYSOUT FORMATTING
*        ABOVE SET TO BR WHEN X0 EXIT SET FORMAT=NONE
         NI    DCBRECFM,X'06'   ZERO OUT EVERYTHING EXCEPT RECFM=A,M
         OI    DCBRECFM,X'90'   MOVE IN RECFM=FB
         MVC   DCBLRECL,=H'133' MOVE 133 TO LRECL FOR PRINT LINE
         MVC   DCBBLKSI,=H'5320'  MOVE 5320 TO BLKSIZE
         CLI   SYSUT,C'2'         IS THIS SYSUT2
         BNE   SYSOUT3                    NO
SYSOUTER NOP   LIBERR2   SET TO BRANCH ON LIBOUT
         MVI   SKIPPUT2+1,SETBR        YES-SET BRANCH AND BAL FOR PRINT
         MVC   PRNT2BAL(2),SETBAL
         B     RETURN                  RETURN
SYSOUT3  CLI   SYSUT,C'3'
         BNE   SYSOUT4
         MVI   SKIPPUT3+1,SETBR
         MVC   PRNT3BAL(2),SETBAL
         B     RETURN
SYSOUT4  CLI   SYSUT,C'4'
         BNE   SYSOUT5
         MVI   SKIPPUT4+1,SETBR
         MVC   PRNT4BAL(2),SETBAL
         B     RETURN
SYSOUT5  EQU   *
         MVI   SKIPPUT5+1,SETBR
         MVC   PRNT5BAL(2),SETBAL
         B     RETURN
         SPACE 5
*        ROUTINE TO GET DSN AND VOLSER FROM JFCB FOR OUTPUT FILES
*        AND PUT OUT ATTRIBUTE MESSAGE AFTER OPENING THE FILE
OUTATTR  MVC   MSG85+9(8),DCBDDNM(R2) SET DDNAME IN MSG 85
         OPEN  ((R2),OUTPUT)  OPEN SYSUT2/3/4/5 OR LIBOUT (R2 HAS DCB)
         CLI   WORKFLD,C'V'     IS THIS THE V OPTION
         BER   GOREG            YES- BYPASS MSG85
         LH    R1,LRECL(R2)     GET OUTPUT ATTRIBUTES
         CVD   R1,INLRECL
         MVC   MSG85REC,MSG23ED
         ED    MSG85REC,INLRECL+5
         LH    R1,BLKSIZE(R2)
         CVD   R1,INBLKSIZ
         MVC   MSG85BLK,MSG23ED
         ED    MSG85BLK,INBLKSIZ+5
         RDJFCB ((R2))                  READ JFCB
         MVC   MSG85VOL,JFCBVOLS
         MVC   MSG85DSN,JFCBDSNM
         ST    GOREG,SAVEREGS       SAVE R8
         C     R2,ASYSPRNT     IS THIS THE SYSPRINT FILE
         BNE   PUTMSG85        NO
         BAL   GOREG,PUTPRINT  GET FIRST BUFFER AND SAVE ADDRESS IN R1
         LNKMSG 74,EDIT=PARMEND+1 PRINT HEADING MSG
PUTMSG85 MESSAGE 85             THE MESSAGE MACRO USES R8
         L     GOREG,SAVEREGS       RESTORE R8
         BR    GOREG    RETURN
         SPACE 2
OPENINP  OPEN  ((R2))   COMMON OPEN INPUT ROUTINE
         CLI   OPENERR,C'1'     HAVE ANY OPEN BOMBS BEEN RECOVERED
         BE    ERROREOJ                 YES
         BR    GOREG
         TITLE 'ABEND AND JFCB EXIT FOR INPUT FILES'
INPTXLST DS    0F
         DC    X'07'       JFCB EXIT TO GET ADDR OF JFCB MAPPING MACRO
         DC    AL3(INFMJFCB)   ADDR OF JFCB MAPPING MACRO
         DC    X'11'                  ABEND EXIT ON 'A' OPTION
         DC    AL3(DCBABEND)   ADDR OF ABEND ROUTINE
         DC    X'85' DCB OPEN EXIT (LAST IN LIST)-BUFNO PERFORMANCE
         DC    AL3(DCBBUFX)   ADDR OF DCB OPEN EXIT TO ADJUST BUFNO
         SPACE 1
DCBABEND ST    R14,SAVEREGS
         L     R5,0(0,R1)      LOAD PARAMETER LIST INTO R5
         SRL   R5,20     SHIFT EVERYTHING BUT THE COMPLETION CODE OUT
         CLI   2(R1),X'04'     IS THE RETURN CODE=4
         BNE   S413BOMB        NO-IS IT A 413 BOMB
         CLM   R5,3,=X'0513' IS IT S513 BOMB-SYSIN TAPE SAME AS SYSUT1
AEXIT    NOP   FIXBOMB       YES-CHANGED TO BE ON 'A'
         CLM   R5,3,=X'0813' IS THE DSN OR VOLSER SPECIFIED INCORRECTLY
         BE    DSNBOMB
         CLM   R5,3,=X'0213'  ON DISK-IS DSN OR VOLSER INCORRECT
         BE    DSNBOMB
S413BOMB CLM   R5,3,=X'0413'  HAS A PREVIOUS STEP IN A JOB BOMBED
         BE    PREVBOMB          YES -NEXT INSTRUCTION MUST BE BOMBOUT
BOMBOUT  MVI   3(R1),X'00'    NO-BOMB OUT IMMEDIATELY
RETURN2  L     R14,SAVEREGS
         BR    R14
         SPACE 1
FIXBOMB  MVI   3(R1),X'04'    IGNORE THE BOMB
NOSYSIN  MVC   SAMETAPE(2),SETBAL   SET A BAL TO GETCARD AFTER GETINPUT
         MVC   AGETCRD1(2),=X'4700' NOP THE BAL TO GETCARD SET BY 'A'
         MVI   SKIPGET+1,SETBR      BRANCH AROUND THE READ OF 1ST SYSIN
         MVI   MNPUTBR+1,SETBR
         MVI   READCRD1+1,SETNOP SET NOP MOVE SYSUT1 REC TO SYSIN
         MVI   ASAMETAP+1,SETBR  BYPASS SYSUT4 & SYSUT5 PROCESSING
         MVI   A513NOP+1,SETNOP BYPASS SYSIN MESSAGE
         MVI   MMSG+1,SETBR     SET BRANCH ON NORMAL A MSG
         LNKMSG 72,BRANCH=RETURN2 IGNORE 513 MSG
         SPACE 1
DSNBOMB  MVI   3(R1),X'04' IGNORE THE BOMB  EXCEPT WHEN RC=ABEND,DUMP
         LNKMSG 68
SETCODE  MVI   OPENERR,C'1'     HAVE ANY OPEN BOMBS BEEN RECOVERED
         B     RETURN2
         SPACE 2
PREVBOMB CLI   2(R1),X'18'     DID PREV STEP BOMB
         BNE   BOMBOUT         NO
         MVI   3(R1),X'04' YES-IGNORE BOMB
         LNKMSG 75,BRANCH=SETCODE
         TITLE 'SPIE EXIT, ESTAE RETRY EXIT AND CALL TIOT ROUTINE'
*        AFTER THE SPIE EXIT CONTROL IS RETURNED HERE, WITH THE
*        RETURN CODE IN R5. A MSG IS PUT OUT AND THEN AN ABEND OCCURS.
*ABENDMSG LNKMSG 64          PUT 'PROGRAM BOMBED' MSG             @MK1
ABENDMSG EQU   *                                                  @MK1
         L     R2,SAVESPIE    GET PREVIOUS SPIE ADDRESS
         SPIE  MF=(E,(2))        CANCEL SPIE TO PREVENT INFINITE LOOPS
         LNKMSG 64           PUT 'PROGRAM BOMBED' MSG             @MK1
RCDUMP   ABEND (R5),DUMP,,SYSTEM   CAUSE A DUMP
         SPACE 5
*        THIS IS THE RETRY ROUTINE AFTER EXECUTION OF THE ESTAE EXIT
*        THE REGISTER CONVENTIONS ARE:
*          UPON ENTRY, IF AN SDWA WAS OBTAINED BY THE SYSTEM THEN THE
*         BASE REGISTERS ARE RESTORED BY THE SETRP MACRO IN THE ESTAE
*         EXIT ROUTINE. OTHERWISE IF THE SDWA IS NOT OBTAINED
*        R0=12
*        R1=ADDR OF THE PARAMETER LIST ESTABLISHED VIA ESTAE MACRO.
*           THE LIST CONTAINS THE ADDR OF 'BASES' WHICH CONTAINS THE
*           VALUES USED TO RESTORE R10-R12,
*           THE ADDR OF SAVEAREA WHICH IS USED TO RESTORE R13
*           AND THE COMPLETION CODE IN THE LAST WORD OF THE LIST
RETRYADR L     R2,8(0,R1)     LOAD THE COMPLETION CODE INTO R2
         L     R13,4(0,R1)       RELOAD R13
         L     R1,0(0,R1)      GET ADDRESS OF 'BASES'
         LM    R10,R12,0(R1)   RELOAD THE BASE REGISTERS R10-R12
         SPACE 2
BOMBMSG  LNKMSG 69          PRINT MESSAGES
         LNKMSG 73
         ESTAE 0        CANCEL ESTAE EXIT TO PREVENT INFINITE LOOPS
RCABEND  ABEND  (R2),,,SYSTEM  ABEND WITHOUT A DUMP
         SPACE 2
*  ON ENTRY TO CHKTIOT MACRO R2 MUST CONTAIN THE DCB ADDR OF THE FILE
*  BEING SEARCHED FOR.
CALLTIOT SR    R5,R5   POINT TO THE PSA, PSA IN FIRST 4K OF CORE
         USING PSA,R5
         L     R5,PSATOLD    GET CURRENT TCB ADDRESS
         USING TCB,R5
         L     R5,TCBJSCB  GET JSCB ADDR
         USING IEZJSCB,R5
         L     R5,JSCDSABQ  GET THE QDB FOR THE DSAB
         USING QDB,R5
         L     R5,QDBFELMP   GET THE POINTER TO THE FIRST DSAB
         USING DSAB,R5
DSABLOOP L     R4,DSABTIOT   GET THE TIOT ENTRY POINTER
         CLC   TIOEDDNM,DCBDDNM(R2) IS THIS ENTRY=DDNAME,R2= A(DCB)
         BE    FOUND        YES
         ICM   R5,15,DSABFCHN  CHAIN TO THE NEXT DSAB
         BNZ   DSABLOOP         THERE ARE ADDITIONAL DSABS
*@MK1    CLI   FULL1+3,0          SET CONDITION FOR NOT EQUAL (NOTFND)
         LA    R15,4         RC - NOT FOUND                       @MK1
*@MK1    BR    GOREG
         B     TIOTRET            RETURN                          @MK1
*FOUND    CLI   FULL1+3,1   SET BRNCH CONDITION FOR EQUAL (FOUND) @MK1
FOUND    LA    R15,0        RC - FOUND                            @MK1
TIOTRET  LTR   R15,R15      SET CONDCODE FOR BRANCH    @MK1
         BR    GOREG              RETURN
         TITLE 'VERIFY THE SYNTAX OF THE PARM FIELD'
MOVEPARM EQU  *
*   R1=REGISTER USED IN THE DATA MANAGEMENT MACRO INSTRUCTIONS(OPEN,
*      CLOSE,GET,ETC.) AND FOR THE PRINTING OF ALL MESSAGES
*   R2=THE FUNCTION BYTE WHICH IS RETURNED BY THE TRT FOR CLASS TESTS
*   R3=COUNT OF THE NO OF PARAMETERS,R4=LENGTH OF THE KEYS,
*   R5=NUMBER OF CHARACTERS PER PARM FIELD,R7=CONTAINS ADDR OF PARM FLD
         LM   R2,R3,LOWVALUE  INITIALIZE R2 AND R3 TO ZEROS
PRELOOP  SR   R5,R5           INITIALIZE R5 TO ZEROS
         MVC   WORKFLD,MSGSPACE   SET WORKFLD TO SPACES
PVERLOOP EQU   *    PARM VERIFICATION LOOP
         C     R7,PARMEND      COMPARE R7 TO ADDRESS OF END OF PARM FLD
         BH    VERPARM   COUNT OF CHARACTERS PROCESSED.
         LA    R7,1(R7)  POINT TO THE DATA FIELD BEING TESTED
         CLI   0(R7),C')'  ON 'V=' TEST FOR END OF PARAMETER
CHKV     NOP   VERPARM     CHANGED TO BE ON V=
         CLI   0(R7),C','  IS THERE A PARAMETER BREAK
         BE    VERPARM1  YES VERIFY THE PARAMETER
         IC    R9,0(0,R7)      MOVE THE PARM CHARACTER TO R9
         STC   R9,WORKFLD(R5)  STORE THE PARM CHAR INTO WORKFLD
         LA    R5,1(R5)   ADD 1 TO THE NUMBER OF CHARS IN THIS PARM
         C     R5,FULL8   ARE THERE MORE THAN 8 CHAR. IN A PARM VALUE
         BH    POSITNG    YES
         B     PVERLOOP   NO
VERPARM  MVI   ENDPARMS,C'1'  1 INDICATES THE LAST PARAMETER
VERPARM1 LTR   R5,R5         IS THERE A COMMA AT THE END OF THE PARM
         BZ    ERRPARM         OR 2 CONSECUTIVE COMMAS IN THE PARM
         LA    R3,1(R3)  ADD 1 TO THE NUMBER OF PARAMETERS
         LR    R9,R3  LOAD R9 WITH R3
         SLL   R9,2   MULTIPLY THE PARAMETER COUNT BY 4
         B     JUMPOFF-4(R9) GO TO PROCESS THE PARAMETER IN THE B LIST
JUMPOFF  B     SELCODE   VERIFY THAT A VALID CODE EXISTS
         MVI   LENGRET+1,SETBR   SET BRANCH FOR LENGTH VERIFICATION
         B     POSVER            GO TO VERIFY THE POSITION PARM
         MVI   LENGRET+1,SETBR
         B     POSVER                  VERIFY THE POSITION
         MVI   LENGRET+1,SETBR
         B     POSVER     VERIFY THE POSITION
         B     CNTERR2
         TITLE 'END OF PARM PROCESSING-CHK IF 2,4 OR 6 L,P PAIRS REQU'
INITNPM  EQU   *        WHEN THE END OF THE PARAMETER LIST IS SENSED
*PARMERR TESTED TO SEE IF PROCESSING IS TO CONTINUE.
         CLI   ENDPARMS,C'1'  IS IT THE END OF THE PARM FIELDS
         BNE   PRELOOP    NO-BRANCH TO INITIALIZE FIELDS
         LA    R3,1(R3)   ADD 1 TO R3 TO MAKE UP FOR COUNT MISSING
VBRANCH  NOP   CHKVEQU    CHANGED TO BRANCH WHILE PROCESSING V=
REXTEND  B     NPEQUAL    CHANGED TO NOP ON R,E AND V OPTIONS
         C     R3,=F'2'      IS THERE ONLY 1 PARM-THE SELECTION OPTION
         BNE   CHKNUMB           NO
EOPTBR   NOP   INITNPM2     CHANGED TO BR ON E AND V OPTIONS
         MVI   REXTBR+1,SETBR    YES-SET BRANCHES FOR R EXTENDED OPT
         MVI   REXTLOG+1,SETBR
         MVI   RMSG+1,SETBR      DO NOT WRITE THE REGULAR R MSG
         B     MKEY           GO TO OPEN SYSIN
NPEQUAL  B     CKEYNOP NOP IF P=,N=,C=P,N,Z, G OPT OR L SUBOPT W V RECS
*                      NOP ALSO ON VP
         C     R3,FULL4    IS THERE 1 L,P PAIR IN THE PARM FIELD
         BE    CHKNUMB     YES
         B     CNTERR2     BRANCH TO PUT OUT OUT ERROR MSG
CKEYNOP  B     BKEYNOP     CHANGED TO NOP ON 'C' OPTION
         C     R3,FULL8    ARE THERE 3 L,P PAIRS
         BE    CHKNUMB     YES
         B     CNTERR2     PUT OUT ERROR MSG
BKEYNOP  B     CHKNUMB     NOOPED ON B,BB OPTIONS
         C     R3,FULL6    ARE THERE EXACTLY 2 L,P PAIRS
         BNE   CNTERR2     NO
         TITLE 'VERIFY NO OF PARMS AND SET LENGTHS,BRANCHES AND NOPS'
CHKNUMB  L     R4,POSLENS  YES-LOAD THE FIRST LENGTH INTO R4
         STC   R4,SET1+1           R4=LEN1-1
         STC   R4,SETTR1+1         R4=LEN1-1 FOR CONVERT
         STC   R4,SETLTR1+1        R4=LEN1-1 FOR CONVERT, L SUBOPT
         STC   R4,BLOGCLC1+1  SET LENGTH FOR FIRST 'O' KEYCOMPARE
         STC   R4,OKEYMSG1+1  SET LENGTH FOR FIRST 'O' MSG PRINT
*        STC   R4,MOVINCRD+1  SET LENGTH FOR FIRST SYSIN CARD
*  ABOVE INSTRUCT COMMENTED OUT TO ALLOW CLASS= KEYWORD ON C, O OPT
         C     R3,FULL4   COMPARE FOR EQUAL TO 4 PARAMETERS
         BE    INITNPM2   YES
*
         MVI   BRL1+1,SETNOP  ALLOW 2 L,P'S ON AL,ML
         MVI   BR1+1,SETNOP
         MVI   BLOGCLC2+1,SETNOP       NOP THE BRANCH -AT LEAST 2 KEYS
         MVI   BR2CARDS+1,SETNOP    READ 2ND SYSIN CARD ON 'O' LOGIC
         MVI   ONLY2OR+1,SETNOP    BRANCH NOOPED TO PUT OUT MESSAGE
         L     R5,POSLENS+12       LOAD P2 INTO R5
         S     R5,POSLENS+4        R5=P2-P1
         ST    R5,POSDISPS    STORE P2-P1 FOR AL,ML OPTIONS ON V RECS
         L     R5,POSLENS+8   LOAD 2ND LENGTH INTO R5
         STC   R5,BLOGCLC3+1  SET LENGTH FOR 2ND 'O' KEY CMP
         STC   R5,OKEYMSG2+1  SET LENGTH FOR 2ND 'O' KEY PRT
         STC   R5,BKEYMSG2+1  SET LENGTH FOR 2ND 'B' KEY PRT
         STC   R5,SET2+1      MOVE THE SECOND LENGTH
         STC   R5,SETTR2+1    MOVE THE SECOND LENGTH FOR CONVERT
         STC   R5,SETLTR2+1   MOVE THE SECOND LENGTH FOR CONVERT, L OPT
         STC   R5,MOVINCD2+1  SET THE LENGTH FOR 2ND SYSIN REC
         LA    R4,1(R4)           ADD 1 TO THE TOTAL LENGTH
         STC   R4,SET2+3               LEN2
         STC   R4,BLOGCLC3+3   SETS THE INCREMENT FOR THE 2 OR COMPARE
         AR    R4,R5             R4=LEN1+LEN2-1
         C     R3,FULL6     ARE THERE 6 PARAMETERS
         BE    INITNPM2  YES
*
         MVI   BRL2+1,SETNOP   ALLOW 3 L,P'S ON ML,AL
         MVI   BR2+1,SETNOP
         MVI   BLOGCLC4+1,SETNOP     NOOP THE BRANCH--3 KEYS
         MVI   BR3CARDS+1,SETNOP     NOOP THE BRANCH--3 KEYS
         MVI   ONLY3OR+1,SETNOP    BRANCH NOOPED TO PUT OUT MESSAGE
         L     R5,POSLENS+20       LOAD P3 INTO R5
         S     R5,POSLENS+12       R5=P3-P2
         ST    R5,POSDISPS+4  STORE P2-P1 FOR AL,ML OPTIONS ON V RECS
         L     R5,POSLENS+16  LOAD R5 WITH THE 3RD LENGTH
         STC   R5,BLOGCLC5+1  SET LENGTH FOR 3RD 'O' KEY CMP
         STC   R5,OKEYMSG3+1  SET LENGTH FOR 3RD 'O' KEY PRT
         STC   R5,SET3+1      MV IN 3RD LENGTH
         STC   R5,SETTR3+1    MV IN 3RD LENGTH FOR CONVERT
         STC   R5,SETLTR3+1   MV IN 3RD LENGTH FOR CONVERT,L OPT
         STC   R5,MOVINCD3+1  SET THE LENGTH FOR 3ND SYSIN REC
         LA    R4,1(R4)
         STC   R4,SET3+3               LEN1+LEN2
         STC   R4,BLOGCLC5+3  SET THE INCREMENT FOR THE 3RD OR COMPARE
         AR    R4,R5              R4 NOW LEN1 + LEN2 + LEN3 - 1
         C     R3,FULL8     ARE THERE 8 PARAMETERS
         BNE   CNTERR2       NO  IF YES FALL THRU
         TITLE 'SET LENGTHS AND DISPLACEMENTS FOR COMPARES,PRINT,ETC.'
INITNPM2 NOP   SETYEQU  CHANGED TO BRANCH ON O,B,C,E,R KEYS & L SUBOPT
         STC   R4,COMPSKEY+1  SET KEY LENGTH FOR COMPARE(S,M,D OPTION)
         STC   R4,COMPFKEY+1  SET KEY LENGTH FOR COMPARE(F,Q OPTION)
         STC   R4,GBUILD+1 SET KEY LENGTH TO MOVE KEY TO TABLE (T,G,P)
         STC   R4,GNUM1+1  SET LEN TO CHK IF LOWER SYSIN IS NUMERIC (G)
         STC   R4,GNUM2+1  SET LEN TO CHK IF UPPER SYSIN IS NUMERIC (G)
         STC   R4,GCOMPR+1 SET LENGTH TO COMPARE LOWER & UPPER SYSIN(G)
         STC   R4,DKEYMSG+1      MOVE KEY LENGTH TO PRINT MSG (D)
TLCLM    STCM  R4,1,KEYREPT1+1   MOVE KEY LENGTH TO PRT MSG (S,M)
*        ABOVE STCM CHANGED TO CLM FOR TL OPTION
         STC   R4,CURRKEY+1      MOVE KEY LENGTH TO PRINT MSG (Q)
         STC   R4,PREVKEY+1      MOVE KEY LENGTH TO PRINT MSG (Q)
         STC   R4,TKEYMSG+1      MOVE KEY LENGTH TO PRINT MSG (T)
         STC   R4,PLOWVALU+1  SET LENGTH FOR UPPER KEY COMPARE  (P)
         STC   R4,LKYNOTLV+1  SET LENGTH FOR LOWER KEY PRINT    (P)
         STC   R4,UKYNOTHV+1  SET LENGTH FOR UPPER KEY PRINT    (P)
         STC   R4,PLVMSG+1  SET LENG FOR LOW VALUE MSG          (P)
         STC   R4,CHKUKY+1  SET LENG FOR UPPER KEY HIGH VAL MSG (P)
         STC   R4,FMOVE+1     SET LENGTH TO MOVE KEY           (F)
         STC   R4,FREQMOVE+1  SET LENGTH TO PRINT MSG        (F,J=0)
         STC   R4,MOVECARD+1  SET LENGTH FOR SYSIN MOVE (SYSIN OPTIONS)
*        THE FOLLOWING 2 INSTRUCTIONS ARE CHANGED TO STCM INSTRUCTIONS
*        ON THE P AND THE G OPTIONS RESPECTIVELY
SETPLEN  CLM   R4,1,MOVINCRD+1  SET THE LENG FOR MOVING IN P KEY  (P)
SETGLEN  CLM   R4,1,MOVINCD2+1  SET THE LENG FOR MOVING IN G KEY  (G)
         LA    R5,1(R4)       ADJUST R5 TO ACTUAL KEY LENGTH (ADD 1)
         STC   R5,GBUILD2+3   SET DISPLACEMENT TO 0-OUT COUNT (T,G,P)
         STC   R5,TKEYSEL+3   SET DISPLACEMENT TO PRINT MESSAGE (T,G)
         STC   R5,PMSGED+3    SET DISPLACEMENT TO EDIT COUNT (P)
         LA    R5,5(R4)       ADJUST R5 TO KEY LENGTH+COUNT LENGTH (P)
         STC   R5,CHKUKY+3   SET DISPLACE TO CHK IF UPPER KEY=X'FF'(P)
         STC   R5,UKYNOTHV+5 SET DISPLACEMENT TO MOVE IN UPPER KEY (P)
SETYEQU  EQU   *   SET LENGTH FOR Y= PROC & SAVE LENG FOR L SUBOPT ON V
         STC   R4,YTRNSLT1+1   SET LENGTH OF KEY FOR Y= EQUATE SYMBOL
         STC   R4,YTRNSLT2+1   OPTION FOR ALL OPTIONS EXCEPT E & R.
         ST    R4,SAVER4    SAVE R4 FOR V RECS IN AL,ML PROCESSING
         ST    R4,SAVEVARL SAVE LENGTH FOR SYSIN FILE ON V RECS "
         LA    R0,1(R4)
         ST    R0,VSAMKEYL  FULLWORD STORAGE FOR VSAMKEY GENERIC KEYL
LKEY     B     PARMGOOD      SET TO NOP ON L SUBOPTION
         ST    R0,LENGLIST   STORE LENGTH INTO GETMAIN LIST
         STCM  R0,7,LENGLIST+5  STORE LENGTH-DONT TOUCH HIGH ORDER BYTE
         GETMAIN LU,LA=LENGLIST,A=LKEYARE1  GET 2 AREAS OF EQUAL LENGTH
         TITLE 'MISCELLANEOUS'
PARMGOOD CLI   PARMERR1,C'1'   IS THERE AND ERROR IN ANY PARM FIELD
         BE    ERROREOJ          YES
         CLI   SYSINDCB+1,SETNOP NO-WAS THE V= OPTION REQUESTED
         BE    AOPTION           NO
         CLM   R4,3,VLENGTH      YES-ARE THE KEY LENGTHS THE SAME
NOPONVP  BNE   MTCHERR4          NO - NOP ON VP= LENGTHS NEED NOT EQUAL
         B     CONTINPR          YES
         SPACE 2
ERROREOJ MVI   SETRC+3,X'08' PLACE RETURN CODE= 8 = ERR IN R15
         B     EOJ  GO TO EOJ & CLOSE THE FILES
         SPACE 2
AOPTION  CLI   MATCHFIL,C'A'   IS 'A' OPTION REQUESTED
         BNE   CONTINPR        NO-CONTINUE NORMALLY
         B     MTCHERR1       YES-ERROR NO V= SUBOPTION REQUESTED ON A
         TITLE 'XB(SYSUT3 PROCESSING) AND XN(NEGATIVE) SELCT SUBOPTION'
SELCODE  NOP   KEYWRDBE  VERIFY SELECT CODE,CHANGED TO B ON Y=,B=,E=,J=
         CHECKOPT W,NOTFND=BLANKW  ERASE W SUBOPTION
BLANKW   L     R2,AOUTFIL2     GET SYSUT3 DCB FOR CHCKTIOT & OPEN
         CHCKTIOT NOTFND=NEGATKEY
         MVI   SYSUT,C'3'       CHANGE TO SYSUT3
         BAL   GOREG,OUTATTR    OPEN & PUT OUT SYSUT3 ATTRIBUTES
         LA    R3,1             RESET R3 FOR PARM
         MVI   CLS2NOP+1,SETNOP
SYST3NOP MVI   BRPTOUT2+1,SETNOP CHANGED TO CLI WHEN VSAMXXX CODED
*        AS THE PRIMARY INPUT AND PRIMARY OUTPUT FILES
         SPACE 2
NEGATKEY CHECKOPT N,NOTFND=LONGKEY CHK IF N SUBOPT REQU
         CLI   VSAMFLAG,C'1'    IS VSAMKEY DD BEING USED
         BE    KEYINVAL           YES-ERROR
         CLI   WORKFLD,C'M'    IS THIS THE M OPTION
         BE    MNKEY              YES
         CLI   WORKFLD,C'B'
         BE    BNKEY
         CLI   WORKFLD,C'C'
         BE    CNKEY
         CLI   WORKFLD,C'A'
         BE    ANKEY
         MVI   RNEGAT+1,SETBR  SET BRNCH TO SKIP EVERY NTH RECORD  (R)
         MVI   ONKEYEQ1+1,SETBE  SET BR ON = CONDITION TO GETINPUT (O)
         MVI   ONKEYEQ2+1,SETBE                                    (O)
         MVI   ONKEYEQ3+1,SETBE                                    (O)
         MVI   ONSELECT+1,SETBR   SET BR TO WRITE RECS ON 'ON' KEY (O)
         MVI   TLOGNEQ+1,SETBE  SET BR WHEN KEYS ARE =       (E,G,T,P)
         MVI   TLOGNEQ1+1,SETBL  SET BL WHEN 'COUNT' REACHED (E,G,T,P)
         MVC   MSG29OUT(25),MSGSPACE  BLANK OUT COUNT MESSAGE      (P)
         MVC   MSG21KEY+21(37),MSG21KEY+20  BLANK CNT PRINT  (E,O,G,T)
         MVC   MSGMASK+1(9),MSGSPACE KILL THE EDIT MASK    (E,O,G,T,P)
         MVI   DKEY+1,SETBNE SET BNE TO GET NEW REC                (D)
*        MVI   DKEYGT+1,X'D0'   SET BNH                            (D)
*        MVI   DKEYLT+1,X'B0'  SET BNL                             (D)
         MVI   QKEY+1,SETBH SET BH TO CHK SEQU FOR DESCENDING ORDER(Q)
         MVC   INCARD,HIGHV     INIT INCARD TO X'FF' FOR DESC ORDER(Q)
         MVI   QNLBL+1,X'02'    CHANGE CONDITION CODE TO 'BL'     (QL)
         MVI   SETQBNE+1,X'02'  CHG COND CODE TO 'BL' FOR RECFM=V (QL)
         MVI   FNINVAL+1,SETBR  DISALLOW N SUBOPTION ON F KEY      (F)
         MVI   KNINVAL+1,SETBR  DISALLOW N SUBOPTION ON K KEY      (K)
         MVI   KEYGT+1,X'D0'    SET BNH                          (S,V)
         MVI   KEYLT+1,X'B0'    SET BNL                          (S,V)
ANKEY    MVI   BR6+1,SETBNE                                      (A,S)
         TITLE 'SET LONG SUBOPTION DEFAULTS'
LONGKEY  CHECKOPT L,NOTFND=VEROPT  CHK IF L SUBOPT
         MVI   LSKIP1+1,SETBR   SKIP CHECK OF L<20,L+P<4096
         MVI   NOPONL+1,SETNOP  NOP CHECK FOR L<20
         MVI   YLOGIC+1,SETBR   DISALLOW Y= PARM
         MVI   COMPKEY+1,SETBR  SET B FOR PROCEESING LONG COMPARE
         MVI   FLOGIC1+1,SETBR
         MVI   QBRONL+1,SETBR   SKIP MESSAGES ON Q
         MVI   INITNPM2+1,SETBR SKIP SETTING LENGTH FOR COMPARE AND PRT
         MVI   ELOGIC+1,SETBR   BYPASS SETTING KEYS USING L,P PAIR
         MVI   LSET2BR+1,SETBR  BYPASS SETTING KEYS ON V=
*        MVI   TKEY+1,SETBR  INVALIDATE L SUBOPTION ON T,G,E,P OPTIONS
*                            ALLOW UP TO 256 BYTE KEY ON T,P
         MVI   TLBR+1,SETBR  SUPPRESS KEY PRINTING ON T,P
         MVI   TLCLM,X'BD'   SUPPRESS KEY ON TOTAL LINE T,P
         MVI   GKEY+1,SETBR             INVALIDATE  G
         MVI   EKEY+1,SETBR             INVALIDATE  E
*
         MVI   OKEY1+1,SETBR               INVALIDATE  O,B,C
         MVI   SKEY+1,SETBR                            S,D
         MVI   RKEY+1,SETBR                            R
         MVI   MMSG+1,SETNOP     ALLOW L SUBOPTION ON M OPTION
         MVI   LNOPPRNT+1,SETNOP     BUT SUPPRESS KEY PRINTING
         OI    SKIPPRNT+1,SETBR   PRINT ONLY TOTAL LINE
         MVI   LKEY+1,SETNOP NOP TO DO GETMAIN FOR LKEY STORAGE FOR KEY
         XC    NPEQUAL+1(1),SYSUTVAR+1  IF SYSUT1 IS RECFM=V ONLY 1 L,P
         OC    V1LPPAIR+1(1),SYSUTVAR+1
         SPACE 2
VEROPT   SR    R2,R2
         L     R15,=A(OPTIONS)
         TRT   WORKFLD(1),0(R15) FIND THE REQUEST OPTION FROM TABLE
         BZ    KEYINVAL
         B     JUMPOPT-4(R2)         SET UP JUMP TABLE
JUMPOPT  B     AKEY
         B     BKEY
         B     CKEY
         B     DINVAL
         B     EKEY
         B     FNINVAL
         B     GKEY
         B     KNINVAL
         B     MKEY0
         B     OKEY
         B     PKEY
         B     QKEY
         B     RKEY
         B     SKEY
         B     TKEY0
         B     VKEY
         TITLE 'VERIFY THE SELECTION TYPE CODE'
MKEY0    MVI   MATCHFIL,C'M'     SET FLAG IN CASE V= OPTION REQUESTED
LNOPPRNT MVI   KEYOK+1,SETBR ON M ONLY KEEP BR ON ENDINF,NOP ON L SUBOP
MKEY     L     R2,ASYSIN         GET SYSIN DCB FOR CHCKTIOT AND OPEN
         MVC   DDN,DCBDDNM(R2)      SAVE DDNAME FOR MSG 40
         CHCKTIOT NOTFND=CHKAOPT
         BAL   GOREG,OPENINP    OPEN SYSIN FILE
NOSYSINA MVI   BR5+1,SETNOP SET BRANCH TO NOP--READ ADDIT. KEYS-
         MVI   GETCARD+1,SETNOP
REXTBR   NOP   PARMGOOD   SET TO BRANCH IF ONLY 1 PARM ON R OPTION
KEYOK    MVI   ENDINF+1,SETNOP       NOP TO BLANK 'KEY=' MSG
         CLC   WORKFLD+1(5),MSGSPACE
         BNE   KEYINVAL
         B     KEYWRDBE GO TO PROCESS THE NEXT PARAMETER
         SPACE 2
CHKAOPT  CLI   MATCHFIL,C'A'  IS THIS THE 'A' OPTION,CHG TO C'X'
*        WHEN CONVERT DD CODED-NO SYSIN INVALID WITH 'A' AND CONVERT
         BNE   TIOTERR           NO-SYSIN ABSENT-ERROR
         LA    R5,NOSYSINA       YES-BYPASS OPENING SYSIN
         ST    R5,SAVEREGS  AND RETURN TO NOSYSINA AFTER BRANCH
         B     NOSYSIN     SET BRANCHES AND NOPS AS IF SYSIN PRESENT
         SPACE 2
MNKEY    MVI   MNPUTBR+1,SETBR TO BRANCH ON MN TO ALWAYS READ INPUT(M)
         MVI   MNSTOP+1,SETBE  SET TO BE TO BYPASS ON MNSTOP       (M)
         MVI   BR6+1,SETBL  SET TO BL WHEN KEYS COMPARED ARE NOT = (M)
         MVI   NOTMN+1,SETNOP SET   RETURN BRANCH IF PROCESSING MN(M)
         B     LONGKEY       GO BACK TO CHECK IF LONKEY IS REQUESTED
BNKEY    EQU   *
         MVI   BKEYNOP1+1,SETBL  SET BL TO PUT OUT SELECTED RECORD
         MVI   BKEYBNH+1,SETNOP  NOP A BE INSTR
         MVI   BKEYBH+1,SETBH    SET BH TO GET 2 NEW SYSIN KEYS
         MVI   BNKEYBR+1,SETBE   GET NEW INPUT REC WHEN CNT SATISFIED
         MVI   BNGOREAD+1,SETBR
         B     BNKEYCNT           CONTINUE WITH B KEY
CNKEY    EQU   *
         MVI   ONKEYEQ2+1,SETBE
         MVI   ONKEYEQ3+1,SETBE
         MVI   BKEYBNH+1,SETBNE
         MVI   CKEYNE2+1,SETBNE
         B     CNKEYBR
         SPACE 1
FNINVAL  NOP   KEYINVAL           KEY IS NOT F,CHANGED TO B ON N SUBOP
         MVI   KEYMSG,C'F'        SET KEYMSG TO INDICATE F KEY
FKEY     MVI   FMSG+1,SETNOP      NO-OP THE BRANCH AROUND F MESSAGES
         MVI   FLOGIC+1,SETBR     SET BRANCH TO FLOGIC
         B     KEYOK              GO TO PROCESS NEXT PARAMETER
OKEY     MVI   KEYMSG,C'O'   MOVE THE LETTER 'O' TO KEYINDIC FLAG
OKEY1    NOP   KEYINVAL      CHANGED TO BRANCH ON L SUBOPTION
         MVI   OLOGIC+1,SETBR  SET BRANCH FOR O KEY
         MVI   ORKEYBYP+1,SETBR
         MVI   ORENDCNT+1,SETNOP   BRANCH NOOPED FOR CNT SATISFIED
         MVI   ONLY1OR+1,SETNOP    BRANCH NOOPED TO PUT OUT MESSAGE
         MVI   READOLOG+1,SETNOP
         MVI   INITNPM2+1,SETBR  BYPASS SETTING LENGTH FOR MESSAGE
         MVI   BCOBRNCH+1,SETBR DONT MOVE LV TO TABLE(R7 NOT SET)-B,C,O
         B     MKEY
RKEY     NOP   KEYINVAL
         MVI   RLOGIC+1,SETBR  SET BRANCH TO ENTER R LOGIC
         MVI   RBRANCH+1,SETBR SET B AROUND ADDING 4 TO POS & L+P CHK
         MVI   ORKEYBYP+1,SETBR  SET BRANCH TO SKIP S LOGIC PROCESSING
         MVI   RMSG+1,SETNOP   SET TO NOP TO PUT OUT COUNT SATISFIED
         MVI   INITNPM2+1,SETBR  BYPASS SETTING LENGTH FOR MESSAGE
         MVI   REXTEND+1,SETNOP SET NOP TO CHECK IF ONLY 1 PARM
         B     KEYOK           PROCESS NEXT PARM
QKEY     MVI   SEQCHK+1,SETBL    CHANGE NOP TO BRANCH LOW(OUT OF SEQ)
         MVI   QBOUT2+1,SETBR    CHANGE NOP TO BRANCH (IN SEQUENCE)
         MVI   NOOPONQ+1,SETNOP  NOOP THE BRANCH = INSTRUCTION ON F
         MVI   SEQOK+1,SETBR     BRANCH TO GETINPUT ON SEQU O.K.
         MVI   SEQMSG1+1,SETNOP  NOP TO PUT OUT FILE IN SEQ MSG
         MVI   SEQMSG2+1,SETNOP  PUT OUT 'OUT OF SEQ' MSG
         ZAP   TOTLKEYS,=P'200' SET MAX NO OF SEQ ERRORS PRINTED
         B     FKEY              GO TO F PROCESSING
BKEY     MVI   ONKEYEQ1+1,SETBL  SET TO BL ON LOW COMPARE TO 1ST KEY
         MVI   BKEYNOP1+1,SETNOP NOP TO FALL THRU TO COMPARE ON 2ND KEY
         MVI   BKEYBNH+1,X'D0'  SET BNH TO OUTPT REC AFTER 2ND KEY COMP
         MVI   BKEYBH+1,SETBR   SET B TO OUTPUT MSG AND GET 2 NEW KEYS
         MVI   BCNTSAT+1,SETBE  SET BE FOR COUNT SATISFIED
BNKEYCNT MVI   BKEYNOP+1,SETNOP  SET NOP TO INSURE 6 PARMS ON B KEY
         MVI   OLOGEND+1,SETNOP NOP THE GO TO ENDINPUT
         MVI   BMSG+1,SETNOP    NOP TO PUT OUT FINAL B MSG
         MVI   BKEYBR+1,SETBR   NOP TO SKIP CLASS TEST ROUTINE
         B     OKEY1   BRANCH INTO O LOGIC
GKEY     NOP   KEYINVAL         SET TO BR ON L SUBOPTION
         MVI   GLOGIC+1,SETNOP  SET NOP TO EXECUTE G LOGIC
         MVI   GBLDBR+1,SETBR   SET TO BRANCH TO BUILD TABLE
         MVI   PACKFLAG,C'N'     SET FLAG TO INSURE KEY IS LESS THAN 16
         MVI   READOLOG+1,SETNOP SET NOP TO ENTER O LOGIC TO READ CARDS
         MVI   BR2CARDS+1,SETNOP SET NOP TO READ 2 CARDS PER PASS
         MVI   NPEQUAL+1,SETNOP SET NOP TO ACCEPT ONLY 1 L,P PAIR
         MVI   BKEYBR+1,SETBR  SET B TO SKIP CLASS TEST ROUTINE
         MVI   SETGLEN,X'BE'   CHANGE CLM INSTRUCTION TO STCM
         B     TKEY    BRANCH INTO T LOGIC
TKEY0    MVI   MATCHFIL,C'T'   SET FLAG IN CASE V= OPTION REQUESTED
TKEY     NOP   KEYINVAL        CHANGED TO BRANCH ON L SUBOPTION
         MVI   TLOGIC+1,SETBR  SET BRANCH FOR MAIN LINE T LOGIC
         MVI   TLOGSYS+1,SETNOP     SET NOP FOR READ OF SYSIN
         MVI   ENDKEYT+1,SETNOP  SET NOP FOR END OF SYSIN
TLBR     MVI   TTOTRPRT+1,SETNOP SET NOP FOR END OF SYSUT1;SET BR ON L
         MVI   TMSGBR+1,SETBR     SET BR TO LOOP THRU T MSG
         MVI   SKIPGET+1,SETBR   SET BRANCH TO TO BYP GETCARD
         SPACE 2
         GETMAIN LU,LA=FREELEN,A=TABLE GRAB BYTES FOR TABLE
         L     R0,TABLE         LOAD R0 WITH THE ADDR OF THE TABLE AREA
         L     R1,FREELEN     LOAD R1 WITH LENGTH OF THE TABLE
         SR    R5,R5   LOAD R5 WITH 0-THE LENGTH OF THE SENDING FLD
         ICM   R5,8,HIGHV       LOAD HIGH ORDER BYTE OF R5 WITH X'FF'
         MVCL  R0,R4     MOVE HIGH VALUES(PADDING CHAR) TO TABLE AREA
         CLI   LKEY+1,SETNOP    IS LONG SUBOPTION REQUESTED
         BNE   MKEY             NO
         MVI   INITNPM2+1,SETNOP    YES - SET NOPS TO PROCESS L,P PAIRS
         MVI   ELOGIC+1,SETNOP
         MVI   LSET2BR+1,SETNOP
         B     MKEY      GO TO MKEY
PKEY     MVI   READOLOG+1,SETNOP  READ 1ST SYSIN TO SEE IF LOW VALUES
         MVI   PBRANCH1+1,SETBR   BRANCH AFTER READING LOW VALUES
         MVI   PBRANCH2+1,SETBR   BRANCH AFTER READING 1ST SYSIN
         MVI   PLOGNOP+1,SETNOP   NOP EVEN-ODD SYSIN CHECKING
         MVI   PZEROBR+1,X'80'    SET BZ TO COUNT EVERY OTHER SYSIN KEY
         MVI   PMSG+1,SETNOP      NOP TO PRINT P MSG
         MVC   MSG29PAS(25),MSGSPACE  BLANK OUT RECS PASSED MSG
         MVI   SETPLEN,X'BE'   CHANGE C INSTRUCTION TO STC
         B     TKEY
CKEY     MVI   ONKEYEQ2+1,SETBNE SET BNE FOR NO MATCH ON MASTER
         MVI   ONKEYEQ3+1,SETBNE SET BNE FOR NO MATCH ON SLAVE
CNKEYBR  MVI   CKEYEQ+1,SETBR   SET BRANCH TO DO MASTER COMPARE
         MVI   CKEYNE+1,SETBNE  SET BNE TO DO SLAVE COMPARE
         MVI   CKEYNOP+1,SETNOP SET NOP TO INSURE 3 SYSIN RECS READ
         B     OKEY
KNINVAL  NOP   KEYINVAL        CHANGED TO B ON N SUBOPT
         MVI   KEQUAL+1,SETBR  SET BRANCH TO PUTOUT REC ON = KEY
         MVI   FKEY+1,SETBR SET BRANCH TO BYPASS F MESSAGES
         MVI   KKEYSW+1,SETNOP NOOP TO SEE IF GROUP CNT SATISFIED
         MVI   KMSG+1,SETNOP   NOOP TO PUT OUT K MESSAGES
         MVI   KEEQNOP+1,SETNOP SET BR TO ENDINPUT TO A NOP FOR E= PRC
         B     FKEY
AKEY     MVI   ACNTBR+1,SETBR   SPECIAL J= PROCESSING
         MVI   BR4+1,SETNOP
         MVI   MMSG+1,SETNOP      USE M MSG
         MVI   MNPUTBR+1,SETNOP   FORCE A NEW SYSIN RECORD
         MVC   AGETCRD1(2),SETBAL    CHANGE NOP TO BAL INSTR USING R8
         MVI   MATCHFIL,C'A'         ALLOW V= OPTION
         MVI   AEXIT+1,SETBE  ACTIVATE ABEND EXIT FOR A 513 BOMB
         B     MKEY
EKEY     NOP   KEYINVAL
         L     R5,MAXLEN       LOAD THE RECORD LENGTH INTO R5
         BCTR  R5,0              SUBTRACT 1 FROM RECORD LENGTH
         ST    R5,POSLENS+4     LOAD RESULT INTO 'TO' COL=LRECL
         MVI   COLBR+1,SETBR   SET B TO PROCESS COLUMN PARAMETERS
         MVI   REXTEND+1,SETNOP CHECK IF 0 L,P'S SPECIFIED
         MVI   EOPTBR+1,SETBR  SET B IF 0 L,P'S SPEC.,BYPASS SET LENGTH
         MVI   INITNPM2+1,SETBR    SET B TO BYPASS SETTING LENGTHS
         MVI   ORKEYBYP+1,SETBR   SET B TO BYPASS CHECKING THAT L<20
         MVI   EMSG+1,SETBR       SET B TO PRINT E MSG
         NI    CONTINPR+1,X'F0'   SET R5=24
         MVI   CONTINPR+3,X'18'
         MVI   ELOGIC+1,SETBR      SET B TO BYPASS SETTING UP INPT KEY
         MVI   YLOGIC+1,SETBR      Y= PARM INVAL ON E OPT
         MVC   POSLENS(4),LOWVALUE  SET DEFAULT 'FROM' COL=1
         CLI   MSG40FVU,C'V'        IS SYSUT1 RECFM=V
         BNE   TKEY                 NO
         MVC   POSLENS(4),FULL4     YES-SET DEFAULT 'FROM' COL
         B     TKEY
VKEY     L     R2,AVSYSIN       GET VSYSIN ADDR
         BAL   GOREG,OPENINP    OPEN VSYSIN FILE
         TM    DCBFLAG(R2),X'10'  IS VSYSIN IN JCL
         BNO   TIOTERR             NO - ERROR
         MVI   SKIPGET+1,SETBR     SET BR TO BYPASS FET OG SYSIN
         MVI   MSG40FVU,C'F'       SET 'SYSUT1' TO RECFM=F
         MVC   MAXLEN(4),=F'100'   SET SYSUT1 LRECL=100
         MVI   VOPTBR+1,SETBR      SET RETURN AFTER KEY COMPARE SELECT
         MVI   VOPTREJ+1,SETBR     SET RETURN AFTER KEY COMPARE REJECT
         MVI   REXTEND+1,SETNOP    NOP TO CHK FOR NO L,P'S
         MVI   EOPTBR+1,SETBR IF NO L,P'S,SKIP L,P SETS
         L     R1,=A(OPTNTABL)   ALLOW ONLY J= KEYWORD PARM
         XC    0(256,R1),0(R1)            "
         MVI   X'D1'(R1),X'14'            "
         MVI   ENDKEYT+1,SETNOP  NOP FOR EOF ON SYSIN
         MVI   VTOCLOG+1,SETNOP  PROCESS SYSIN FOR V OPTION
         MVI   GETVTOC+1,SETNOP  NOP FOR READVTOC CSECT
         L     R1,=A(VLOGPDS)
         MVI   1(R1),SETNOP      MODIFY READ PDS RTN FOR V OPTION
         L     R1,=A(VEND)
         MVI   1(R1),SETBR
         B     SKEY            GO TO CHK FOR KEY
         SPACE 2
DINVAL   NOP   KEYINVAL        CHANGED TO B ON BPAM,VSAM
DKEY     MVI   DKEYEQ+1,SETBE CHANGE NOP TO BE TO OUTPUT RECS
         MVI   DKEYNE+1,SETBR    CHANGE NOP TO B
         MVI   ACNTBR+1,SETBR  SPECIAL PROCESSING FOR J=+-
         MVI   SETBEQBR+1,SETBR DONT PUT RECS OUT TO SYSUT3 ON 1ST PASS
         MVI   DMSG+1,SETNOP  D MESSAGE  - FALL THRU TO S KEY OPTION
         SPACE 1
SKEY     NOP   KEYINVAL   THIS ROUTINE WILL MOVE IN THE KEY REQUIRED
*    FOR THE D, S OR V OPTIONS.THE KEY MUST BE 20
*    POSITIONS OR LESS AND MUST BE PRECEEDED BY K=,C=,N=,P= OR X=.
*            THE NOP IS CHANGED TO A BRANCH ON THE L SUBOPTION
         MVI   BR4+1,SETNOP SET BRANCH TO NOP--ONLY ONE KEY ALLOWED--
         CLI   VSAMFLAG,C'1' IS VSAMKEY THE PRIMARY INPUT FILE
         BNE   SKEYCONT      NO
         MVI   SOPTVSAM+1,SETBR  YES END SELECTION ON S WITH 1ST NEQ
SKEYCONT LA    R7,1(R7)  POINT TO THE POSITION BEYOND THE ,
         CLI   1(R7),C'='
         BNE   CHKVOPT     CHK FOR V OPTION
         CLI   0(R7),C'K' IS THE FIRST CHARACTER 'K'
         BE    MOVINKY2   THE KEY STARTS WITH K= CONTINUE PROCESSING
         TITLE 'CLASS OPTION (AHLNPZ) PROCESSING FOR S, O AND C OPTION'
         CLI   0(R7),C'C'  HAS CLASS TEST BEEN REQUESTED FOR S KEY
         BNE   PEQUAL          NO
CHKLOWV  CLI   2(R7),C'L'     IS LOWVALUE TEST REQUESTED
         BNE   CHKHIGHV
         MVI   GOLOWV+1,SETBR
         MVI   MSG1CLS+2,C'L'
CHKHIGHV CLI   2(R7),C'H'     IS HIGH VALUES TEST REQUESTED
         BNE   CHKALPHB
         MVI   GOHIGHV+1,SETBR
         MVI   MSG1CLS+1,C'H'
CHKALPHB CLI   2(R7),C'A'      IS ALPHABETIC TEST REQUESTED
         BNE   CHKNUMER        NO
         MVI   GOALPHB+1,SETBR  YES-SET BRANCH ALPHABETIC TEST ROUTINE
         MVI   MSG1CLS,C'A'     MOVE 'A' TO MESSAGE
CHKNUMER CLI   2(R7),C'N'      IS NUMERIC TEST REQUESTED
         BNE   CHKALPHN        NO
         MVI   GONUMER+1,SETBR  YES-SET BRANCH FOR NUMERIC TEST ROUTINE
         MVI   NPEQUAL+1,SETNOP SET NOP TO INSURE THERE IS ONLY 1 L,P
         MVI   MSG1CLS+3,C'N'     MOVE 'N' TO MESSAGE
CHKALPHN CLI   2(R7),C'Z'    IS ALPHANUMERIC TEST REQUESTED
         BNE   CHKPACK           NO
         MVI   GOALPHN+1,SETBR   YES-SET BRANCH FOR FOR ALPHANUM TEST
         MVI   GONUMER+1,SETBR   AND NUMERIC TEST
         MVI   NPEQUAL+1,SETNOP SET NOP TO INSURE THERE IS ONLY 1 L,P
         MVI   MSG1CLS+5,C'Z'    MOVE 'Z' TO MESSAGE
CHKPACK  CLI   2(R7),C'P'      IS PACK TEST REQUESTED
         BNE   TESTMSG1          NO
         MVI   GOPACK+1,SETBR   YES-SET BRANCH FOR PACK TEST ROUTINE
         MVI   NPEQUAL+1,SETNOP SET NOP TO INSURE THERE IS ONLY 1 L,P
         MVI   MSG1CLS+4,C'P'     MOVE 'P' TO MESSAGE
TESTMSG1 CLC   MSG1CLS,MSGSPACE    WAS A CLASS TEST REQUESTED WHEN C=
OCLASSBR NOP   OCLASCHK        CHANGED TO BRANCH IF O KEY PROCESSING
         BE    CLASERR1        YES
         MVI   NOTEST+1,SETNOP NOP FOR CLASS KEY PROCESSING
         MVI   ENDINF+1,SETNOP TO BLANK OUT K= PART OF MESSAGE
         LNKMSG 1,DATA=MSG1CLS,BRANCH=MOVINKY2  PUT OUT CLASS TEST MSG
         SPACE 2
CHKVOPT  CLI   VOPTBR+1,SETBR  IS THIS V OPTION
         BNE   KEYERR         ERROR S OPTION MUST HAVE KEY
         B     VTOCLOG        YES- NO OTHER PARAMETERS, PROCESS SYSIN
         SPACE 2
CHKVOPT2 CLI   VOPTBR+1,SETBR IS THIS V OPTION
         BNE   KEYERR               ERROR
         BCTR  R7,0    RESET PARM POINTER TO POINT TO COMMA BEFORE J=
         MVI   ORKEYBYP+1,SETBR  BYPASS KEY LENGTH CHECKING
         B     KEYWRDBE       YES- JUST 'V,J=N' WITH NO KEY
         TITLE 'CHECK IF N=,P=,X= SUBOPTION REQUESTED AND MOVE IN KEY'
PEQUAL   CLI   0(R7),C'P' IS THE FIRST CHAR 'P'
         BNE   NEQUAL         NO
         MVI   PACKFLAG,C'P'   YES-SET FLAG FOR P= PROCESSING
         B     MOVINKY2         CONTINUE PROCESSING
NEQUAL   CLI   0(R7),C'N'  IS FIRST CHARACTER 'N'
         BNE   XEQUAL          NO
         MVI   PACKFLAG,C'N'    YES,SET FLAG FOR N= PROCESSING
         B     MOVINKY2              CONTINUE PROCESSING
XEQUAL   CLI   0(R7),C'X'  IS FIRST CHARACTER 'X'
         BNE   CHKVOPT2    NO-CHK IF V OPTION
         MVI   PACKFLAG,C'X'    YES-SET FLAG FOR X= PROCESSING
         SPACE 1
MOVINKY2 SR    R5,R5     RESET NO. OF CHARS IN PARM TO 0
         LA    R7,1(R7)  ADD 1 TO THE INPUT ADDRESS GET BEYOND K=
MOVKYLP  LA    R7,1(R7)  ADD 1 TO POINT TO NEXT FIELD
         CLI   0(R7),C','  IS THERE A PARAMETER BREAK
         BE    MOVINKY3   YES
         IC    R9,0(0,R7)   NO-INSERT THE PARM CHARACTER IN R9
         STC   R9,INCARD(R5)   STORE THE PARM CHARACTER IN INCARD
         LA    R5,1(R5)  ADD 1 TO THE NUMBER OF CHAR. IN KEY
         C     R5,FULL20   ARE THERE MORE THAN 20 CHARACTERS IN THE KEY
         BH    PARMERR           MORE THAN 20 POSITIONS IN KEY
         B     MOVKYLP  IF LESS THAN 21 CHAR. CONTINUE PROCESSING
MOVINKY3 LTR   R5,R5        IS THE SELECTION KEY GREATER THAN 0 POS.
         BZ    ERRPARM      NO  BRANCH TO ERROR
         BCTR  R5,0       THE MOVE MUST BE 1 LESS THEN THE ACTUAL CNT
*        FOR V OPTION SET NOP TO DO KEY COMPARE SINCE K= IS CODED
         L     R9,=A(VPUTREC)   GET ADDR FROM CSECT OF WRITE RTN
         MVI   1(R9),SETNOP     FALL THRU TO DO COMPARE BEFORE WRITE
         TITLE 'PROCESS N=, P= AND X= SUBOPTIONS OF S AND D OPTIONS'
         CLI   PACKFLAG,BLANK1  IS NUMERIC,PACK OR HEX TEST REQUESTED
         BE    KEYWRDBE         NO
         C     R5,FULL15        YES-IS NO OF CHARS IN PARM LESS THAN 15
         BNL   PACKERR          NO
NOPMVI   MVI   ENDINF+1,SETNOP YES-NOP THE BRANCH TO BLANK OUT K= MSG
         CLI   PACKFLAG,C'P'    IS THE P= KEY OPTION REQUESTED
         BNE   CHKNEQU          NO
         MVI   GOPACK+1,SETBR   SET BRANCH TO PERFORM PACK TEST
         MVI   PEQULNOP+1,SETNOP SET NOP TO FALL THRU TO PACK COMPARE
NUMBROUT EQU   *
         CLI   INCARD,C'>'      IS N=> OR P=> CODED ON S OPT
         BE    KEYGT            YES
         CLI   INCARD,C'<'      IS N=< OR P=< CODED ON S OPT
         BE    KEYLT            YES
CHKPLUS  CLI   INCARD,C'+'      IS THERE A PLUS SIGN AS A 1ST CHAR
         BNE   NOTPLUS          NO
PACKROUT MVI   INCARD,C'0'      REPLACE THE PLUS WITH A ZERO
MOVE2WRK MVC   WORKFLD,INCARD   MOVE KEY TO WORKFLD & READY FOR PACKING
         BAL   GOREG,VERNUM1    PERFORM NUMERIC CHECKING AND THEN PACK
         CLI   NUMBERR,C'1'     IS IT NUMERIC
         BE    PACKERR           NO
         OI    WORKFLD1+7,X'0F'  MOVE AN 'F' TO SIGN HALF-BYTE
MOVESIGN NI    WORKFLD1+7,X'FC'  MOVE A '+' (C) TO SIGN HALF-BYTE
         MVC   INCARD(8),WORKFLD1  MOVE WORKFLD1 BACK TO INCARD
         MVI   NPEQUAL+1,SETNOP    NOP FOR ONLY 1 L,P PAIR IN SETPARM
         MVI   NOTEST+1,SETNOP     NOP THE BRANCH TO DO REQUESTED TEST
         B     KEYWRDBE            GET A NEW PARM
NOTPLUS  EQU   *
         CLI   INCARD,C'-'         IS THERE A MINUS SIGN AS 1ST CHAR
         BNE   MOVE2WRK            NO-THERE IS NO SIGN-DEFAULT TO '+'
         MVI   MOVESIGN+1,X'FD'    YES-MOVE A '-' (D) TO SIGN HALF-BYTE
         B     PACKROUT            GO BACK TO MAIN ROUTINE
CHKNEQU  CLI   PACKFLAG,C'N'      IS THE N= KEY OPTION REQUESTED
         BNE   CHKXEQU            NO
         MVI   GONEQUAL+1,SETBR   YES-SET BRANCH TO PERFORM N= TEST
         B     NUMBROUT            GO BACK TO MAIN ROUTINE
         SPACE 2
KEYGT    MVI   BR6+1,SETBH CHG TO BH AFTER COMP;CHG TO BNH ON N SUB- S
*KEYGT   MVI   DKEYEQ+1,SETBH CHG TO BH AFTER COMPARE (D OPT)
         B     KEYINEQ
KEYLT    MVI   BR6+1,SETBL CHG TO BL AFTER COMP;CHG TO BNL ON N SUB- S
*KEYLT   MVI   DKEYEQ+1,SETBL CHG TO BL AFTER COMPARE (D OPT)
         MVI   SETINVAL+1,X'00' ON INVALID KEY- SET CLI TO PRODUCE A
*              BNL TRUE CONDITION SO GT(<) DOES NOT CAUSE SELECTION
KEYINEQ  MVC   INCARD,INCARD+1  SHIFT OUT THE < OR >
         BCTR  R5,0     ADJUST LENGTH OF KEY
         B     CHKPLUS
         TITLE 'PROCESS X= KEYWORD PARAMETER OF THE S AND D OPTIONS'
CHKXEQU  EQU   *   THE HEX OPTION (PACKFLAG=C'X' OR 'Y') IS REQUESTED
         STC   R5,HEXTEST+1   STORE NUMBER OF ML HEX CHARS FOR TRT
         STC   R5,HEXTRANS+1                   AND TR
         L     R15,=A(HEXTAB1)  LOAD R15 WITH HEXTAB1 ADDRESS
HEXTEST  TRT   INCARD,0(R15)     DOES KEY HAVE VALID HEX CHARS
         BNZ   HEXERR            NO
         L     R15,=A(HEXTAB2)  LOAD R15 WITH HEXTAB2 ADDRESS
HEXTRANS TR    INCARD,0(R15)     YES-TRANSLATE TO DOUBLE HEX CHARACTERS
         EX    R5,HEXPACK        PACK THE TRANSLATED KEY
         MVC   WORKFLD+15(1),WORKFLD1+7  MOVE THE LAST BYTE TO WORKFLD
         MVO   WORKFLD,WORKFLD1(7)  MOVE IN REST OF KEY SHIFTED RIGHT
         LA    R5,1(R5)                     1/2 A BYTE
         LR    R6,R5          R5 CONTAINS THE AL NUMBER OF HEX CHARS
         N     R6,FULL1  CHANGE ALL BITS TO 0 EXCEPT THE LOW ORDER BIT
         BNZ   HEXERR   NO OF CHARS ENTERED IS NOT EVEN
         SRL   R5,1     NO OF CHARS IS EVEN-DIVIDE BY 2
         LR    R6,R5    LOAD R6 AS THE BRANCH COUNTER WITH KEY LENGTH
         SR    R4,R4                ZERO R4
         S     R5,=F'16'    COMPUTE R5=KEY LENGTH-16
         LPR   R5,R5        COMPUTE R5=|R5|  (ABSOLUTE VALUE)
MOVEOVER IC    R9,WORKFLD(R5)   WORKFLD NOW CONTAINS CHARACTER KEY
         STC   R9,WORKFLD(R4)   WHICH WAS GENERATED FROM HEX CHARS.
         LA    R5,1(R5)      THE MOVEOVER PARAGRAPH CODING LEFT
         LA    R4,1(R4)      JUSTIFIES THE KEY IN WORKFLD AND
         BCT   R6,MOVEOVER         AND THEN RETURNS
         MVC   INCARD(7),WORKFLD   IT TO INCARD.
YLOGBR   NOP   YLOGIC1         CHANGED TO BRANCH WHEN Y= REQUESTED
         B     KEYWRDBE
HEXPACK  PACK  WORKFLD1,INCARD(1)
         TITLE 'MESSAGE MACRO AREA'
PACKERR  LA    R1,2                    N= OR P= KEY SUBOPTION ERR
         B     LNKMSG2
SYSINNG  LA    R1,3                         SYSIN NO GOOD
         B     LNKMSG1
CNTERR2  LA    R1,9
         B     LNKMSG1
KEYINVAL LA    R1,10                         KEY INVALID
         B     LNKMSG1
PACKERR2 LA    R1,12                         ERR ON N= OR P= KEY SUBOPT
         B     LNKMSG2
KEYERR   LA    R1,15
         B     LNKMSG1
POSITNG  LA    R1,16                         L,P INVALID
         B     LNKMSG2
YINVAL   LA    R1,17
         B     LNKMSG1
PARMERR  LA    R1,18
         B     LNKMSG1
HEXERR   LA    R1,20            ERROR ON X= OR Y= PARM OR CONVERT KEYS
         B     LNKMSG1
ERRPARM  LA    R1,27                         KEYWORD PARM MISSING
         B     LNKMSG2
CLASERR1 LA    R1,28       INVALID CLASS ON S AND OPTIONS
         B     LNKMSG1
POSLENNG LA    R1,35                         L+P EXCEEDS LRECL OR 4096
         B     LNKMSG2
GERROR   LA    R1,37
         B     LNKMSG1
ACNTERR  LA    R1,38
         B     LNKMSG1
RECFMERR LA    R1,41
         B     LNKMSG1
TIOTERR  LA    R1,45
         B     LNKMSG1
*LKNG    LNKMSG 47,DATA=SYSUT,BRANCH=RETURN,RETURN=YES  BLK EXCEEDS MAX
MTCHERR1 LA    R1,50
         B     LNKMSG1
MTCHERR2 LA    R1,51
         B     LNKMSG1
MTCHERR4 LA    R1,53
         B     LNKMSG1
VSAMERR  L     R2,DCBADDR   GET VSAMFILE/KEY RPL ADDR
VSAMOTER SHOWCB RPL=(R2),AREA=WORKFLD1,LENGTH=4,FIELDS=FDBK
         L     R2,WORKFLD1      PLACE FDBK CODE IN WORKFLD1
         CVD   R2,WORKFLD1      AND PACK IT FOR DISPLAY
         LNKMSG 63,EDIT=WORKFLD1+3,BRANCH=ERROREOJ
         SPACE 1
COLUMNER LA    R1,70        ERR IN COL SPEC OF E OPT
         B     LNKMSG2
KEYWRDER LA    R1,71
         B     LNKMSG1
ABEND    LA    R1,77   THIS IS THE REENTRY ADDRESS AFTER SYNADERR
         B     LNKMSG1    RETURNS CONTROL AFTER DUMPING 5 BAD BLOCKS
LIBOUTER EQU   *       STOW ERROR IN WRITING OUTPUT PDS LIBOUT
         L     R1,=A(BLDENTRY)               GET MEMBER NAME FOR MSG
         LNKMSG 89,DATA=(R1,8),BRANCH=ERROREOJ
LIBERR2  LA    R1,95   DISALLOW VARIABLE LENGTH RECS ON LIBOUT UNLESS @
         B     LNKMSG1
INVALVKY LA    R1,96   INVALID SYSIN KEY ON V OPTION
         B     LNKMSG1
VMSGSAT  MVI   MSG5FLAG,X'52'  SET UP COUNT SATISFIED MSG
*MSGPT   LA    R2,9    PRINT 9 MSGS FOR V OPTION
VMSGPT   LH    R2,MSGCNT PRT 9 MSGS FOR V OPTION;VARIABLE FOR EXITS
         LR    R5,R1   GET ADDR OF FIRST MSG (IN R1)
VMSGLOOP L     R1,PRINTBUF
         MVC   0(VMSGLEN,R1),0(R5)   MOVE IN MSG
         BAL   GOREG,PUTPRINT
         LA    R5,VMSGLEN(R5)  POINT TO NEXT MSG
         BCT   R2,VMSGLOOP
XMSGNOP  NOP   XITERR2         SET TO BR FOR EXITS MSGS
VMSGNOP  B     PUTMSGR5        SET TO NOP ON V OPTION ERROR
         SPACE 2
VMSGERR  LA    R1,98      V OPTION ERROR
         B     LNKMSG1
         TITLE 'MESSAGE SUBROUTINE'
LNKMSG1  LNKMSG R1,BRANCH=ERROREOJ
LNKMSG2  LNKMSG R1,BRANCH=INITNPM,RETURN=YES
         SPACE 2
*   THIS SUBROUTINE WILL USE THE FOLLOWING REGISTERS
*   R1  ON ENTRY -THIS IS THE MESSAGE NUMBER
*   R1  IS USED ALSO TO PASS THE ADDRESS OF 2 FULLWORDS THAT
*        CONTAIN A- THE ADDRESS OF THE PRINT BUFFER
*                B- THE MESSAGE NUMBER
*   R14 AND R15 ARE THE LINK REGISTERS (BALR)
*   R8 USE FOR PRNT SUBROUT
CALLSUB  EQU   *
         MVC   BRLNKLST(4),PRINTBUF   MOVE IN THE ADDRESS OF PRINT BUF
         LA    R1,BRLNKLST       SET R1 TO ADDRESS OF LINKLIST
         L     R15,MOVEMSGV      LOAD THE SUBROUTINE BRANCH
         BALR  R14,R15           BRANCH TO SUBROUTINE AND SET RETURN
         L     R1,PRINTBUF       LOAD THE ADDRESS OF THE PRINT BUFFER
         ST    GOREG,BRLNKLST    PUT BRANCH ADDR IN BRLNKLST
         BAL   GOREG,PUTPRINT    PRINT THE ERROR MESSAGE
         L     GOREG,BRLNKLST
         MVC   BRLNKLST(12),LOWVALUE   ZERO OUT LIST
         BR    GOREG             BRANCH TO BRANCH ADDR SPEC BY MACRO
         TITLE 'PROCESS THE B=, E= AND J= OPTIONS'
KEYWRDBE NOP   CHKBEQU     CHANGED TO BRANCH FIRST TIME THRU
         MVI   KEYWRDBE+1,SETBR
         MVI   SELCODE+1,SETBR  SET BRANCH AFTER READING IN PARM
CHKEJV   CLI   2(R7),C'='     IS Y=,B=,E=,J=,V= REQUESTED
         BNE   CHKMLNOV       NO-INSURE V= IS CODED WITH THE ML OPTION
KEYWRDOK SR    R2,R2
         L     R15,=A(OPTNTABL)  LOAD ADDR OF KEYWRD TABLE
         TRT   1(1,R7),0(R15)    IS KEYWORD VALID
         BZ    KEYWRDER          NO
         IC    R1,0(0,R1)       PUT THE KEYWORD IN LOW ORDER BYTE OF R1
         STC   R1,NOPOPTN+3      FIND KEYWORD IN OPTION TABLE
NOPOPTN  MVI   0(R15),SETNOP NOP THIS KEYWORD FOR THE FUTURE-DISP ADJ
         MVI   CHKV+1,SETNOP     RESET BRANCH FOR V= KEYWORD
         MVI   EBRANCH+1,SETNOP  RESET BRANCH FOR E= KEYWORD
         MVI   JBRANCH+1,SETNOP  RESET BRANCH FOR J= KEYWORD
         B     JUMPOFF2-4(R2)    BRANCH TO APPROPIATE KEYWORD ROUTINE
JUMPOFF2 B     YLOGIC            GO TO Y= LOGIC
         B     MATCHCHK          GO TO V= LOGIC
         MVI   EBRANCH+1,SETBR   SET BRANCH FOR E=
         B     GETKEY
ACNTBR   NOP   ACNTCHK     SET TO B ON 'A' AND 'D' OPTIONS
         MVI   JBRANCH+1,SETBR   SET BRANCH FOR J=
GETKEY   BCTR  R3,0     YES-RESET R3 (NO OF PARMS) TO 1
GETKEYV  LA    R7,2(R7)      SET R7 TO POINT TO BEGINNING OF PARM
         B     PRELOOP        GO TO READ IN PARM ROUTINE
CHKBEQU  BAL   GOREG,VERNUM   VERIFY THE PARM FOR NUMERICS
         CLI   NUMBERR,C'1'
         BE    POSITNG        THERE IS AN ERROR
EBRANCH  NOP   CHKEEQU        SET TO BRANCH WHEN PROCESSING E= PARM
JBRANCH  NOP   CHKJEQU        SET TO BRANCH WHEN PROCESSING J= PARM
         ZAP   BEGIN,WORKFLD1    MOVE BEGIN AMOUNT INTO 'BEGIN'
         LNKMSG 55,EDIT=BEGIN+3,BRANCH=CHKEJV
         SPACE 1
CHKEEQU  ZAP   END,WORKFLD1     MOVE END AMOUNT TO 'END'
         CP    BEGIN,END        IS BEGIN AMOUNT LESS THAN END AMOUNT
         BNH   CHKEJV           YES-GOOD,NOW CHK IF J= IS REQUESTED
BEGINNG  LA    R1,13                NO-ERROR
         B     LNKMSG1
         SPACE 1
CHKJEQU  CP    WORKFLD1,PACKZERO   IS J=0
         BNE   ZAPCNT               NO
         CLI   LSKIP1+1,SETBR  YES-IS THIS THE LONG SUBOPTION
         BE    POSITNG             YES-ERROR
         CLI   KEYMSG,C'F'         IS THIS THE F OPTION
         BNE   POSITNG             NO-ERROR
         MVI   FREQUECY+1,SETBR    YES-SET BRANCHES
         MVI   FREQMSG+1,SETBR
         B     CHKEJV
ZAPCNT   CLI   ECHGMSG+1,SETNOP IS E OPT $ OR @ CHG REQUESTED
         BNE   ZAPCNT2     NO
         ZAP   EJEQCNT,WORKFLD1 PACK COUNT PARM INTO SPEC CHG-KEY CNT
         B     CHKEJV
ZAPCNT2  ZAP   COUNT,WORKFLD1   PACK THE COUNT PARM INTO PARM
         B     CHKEJV           CHK IF V= IS REQUESTED
         TITLE 'EQUATE SYMBOL PROCESSING'
YLOGIC   NOP   YINVAL             SET TOB ON E OPT AND L SUBOPT
         MVI   YLOGBR+1,SETBR     SET BRANCH TO COME BACK HERE
         MVI   NOPMVI,X'47'       NOP THE NOP OF ENDINF
         MVC   SAVECARD,INCARD         SAVE INCARD
         MVC   SAVEFLAG,PACKFLAG       SAVE PACKFLAG
         MVI   PACKFLAG,C'Y'    MOVE 'Y' TO PACKFLAG TO EX 'X' ROUTINE
         LA    R7,1(R7)
         B     MOVINKY2          READ IN Y= KEY
YLOGIC1  SR    R5,R5
         L     R9,=A(TRNSTAB5)  LOAD ADDR OF TRANSLATE TABLE INTO R9
         MVI   KEYSET+1,SETNOP   SET NOP TO TRANSLATE SYSUT1 KEY
         MVI   TRNSCARD+1,SETNOP SET NOP TO TRANSLATE SYSIN FOR V= KEYS
YLOOP    SR    R6,R6
         IC    R6,INCARD(R5)
         AR    R6,R9        FIND SYMBOL IN Y= IN THE TRANSLATE TABLE
         MVC   0(1,R6),INCARD    EQUATE SYMBOL TO MASTER SYMBOL
         LA    R5,1(R5)          POINT TO NEXT SYMBOL
         BCT   R4,YLOOP R4=LENGTH OF Y= KEY,BUT NOT LENGTH OF INPUT KEY
         MVC   PACKFLAG,SAVEFLAG      RESTORE PACKFLAG AND INCARD
         MVC   INCARD,SAVECARD
         L     R15,=A(TRNSTAB5) LOAD ADDR OF TRANSLATE TABLE INTO R15
         TR    INCARD,0(R15)      TRANSLATE THE S AND D KEYS
         B     CHKEJV                   RETURN
         SPACE 3
CHKMLNOV CLC   1(3,R7),=C'VP='      IS THIS THE VP= KEYWORD
         BE    KEYWRDOK         YES-CONTINUE KEYWORD PROCESSING
         CLI   LSKIP1+1,SETBR    NO-IS THIS THE L SUBOPTION
         BNE   INITNPM              NO
         CLI   MATCHFIL,C'M'        YES- IS THIS THE M OPTION
         BNE   INITNPM              NO
         L     R15,=A(OPTNTABL)     YES- LOAD THE OPTION TABLE
         CLI   229(R15),X'00'       230=X'E5'=C'V',IS V= CODED
         BE    INITNPM              YES
         LA    R1,50                NO-ERROR
         B     LNKMSG1              PUT OUT ERROR MSG
         TITLE 'SET UP OPERATOR FOR RECORD TO RECORD MATCHING'
ACNTCHK  CLI   DKEYNE+1,SETBR   IS THIS THE D OPTION
         BE    DPLUSMIN         YES -BRANCH TO SPECIAL ROUTINE
         CLI   5(R7),C','       IS J=(EQ,NE,...) FOLLOWED BY ','
         BNE   ACNTERR          ERROR
         CLC   3(2,R7),=C'EQ'   IS OPERATOR ='EQ' (DEFAULT)
         BE    ACNTOK           YES
         MVI   BR6+1,SETBNE     NE
         CLC   3(2,R7),=C'NE'   IS OPERATOR ='NE'
         BE    ACNTOK           YES
         MVI   BR6+1,SETBL      LT
         CLC   3(2,R7),=C'LT'   IS OPERATOR ='LT'
         BE    ACNTOK           YES
         MVI   BR6+1,X'D0'      LE
         CLC   3(2,R7),=C'LE'   IS OPERATOR ='LE'
         BE    ACNTOK           YES
         MVI   BR6+1,SETBH      GT
         CLC   3(2,R7),=C'GT'   IS OPERATOR ='GT'
         BE    ACNTOK           YES
         MVI   BR6+1,X'B0'      GE
         CLC   3(2,R7),=C'GE'   IS OPERATOR ='GE'
         BE    ACNTOK           YES
         MVI   BR6+1,SETBR      * (FORCE MATCH INDEPENDENT OF KEYS)
         CLC   3(2,R7),=C'**'   IS OPERATOR ='*'
         BNE   ACNTERR          YES
ACNTOK   LA    R7,5(R7)         POINT TO NEXT PARAMETER
         B     CHKEJV                 RETURN
         SPACE 3
DPLUSMIN CLI   3(R7),C'+'   IS J=+N
         BNE   DNOTPLUS     NO
         MVI   DPLUSBR+1,SETBR   YES
         MVI   SUBCNT,X'F9'   NOP THE CHANGING OF PASSCT
         MVI   ADDCNT,X'F9'   NOP THE CHANGING OF COMPCNT
         B     JRETURN
DNOTPLUS CLI   3(R7),C'-'   IS J=-N
         BNE   JRETURN2
         MVI   DMINSNOP,X'F9'   NOP THE CHANGING OF COMPCNT
JRETURN  MVI   3(R7),C'0'       SET + OR - TO 0
JRETURN2 MVI   JBRANCH+1,SETBR
         B     GETKEY
         TITLE 'FILE MATCHING LOGIC- SET UP SYSUT4 AND SYSUT5'
MATCHCHK CLI   MATCHFIL,BLANK1 YES,IS THE OPTION M, T OR A
         BE    MTCHERR1       NO-ERROR
         CLI   2(R7),C'P'     YES, IS VP= PACKED SUBOPTION REQUESTED
         BE    PACKCOMP       YES
CHKPAREN CLI   3(R7),C'('     NO,ARE THE L,P'S PRECEEDED BY A '('
         BNE   MTCHERR2       NO-ERROR
         MVI   VBRANCH+1,SETBR   SET BRANCH ON L,P PROCESSING FOR V=
         MVI   CHKV+1,SETBE     SET TO BRANCH EQUAL WHEN ')' IS HIT
         LA    R7,1(R7)    UP PARM POINTER BY 1 (COMPENSATE FOR '(' )
         MVI   SYSINDCB+1,SETBR      SET BR FOR SYSIN DCB CHECKING
         MVC   SAVEDCB(2),MAXLEN+2       SAVE THE INPUT LRECL AND
         MVC   SAVEDCB+2(3),MSG40FVU                    RECFM
         L     R3,ASYSIN       LOAD R3 WITH ADDRESS OF SYSIN DCB
A513NOP  B     CHKDCB2  & BRANCH TO DCB CHECKING ROUTINE,NOP ON S513
         SPACE 2
VRETURN  CLI   MATCHFIL,C'T'   ALLOW SYSUT4 AND SYSUT5 ON A AND M OPT
ASAMETAP BE    NOMERGE         BUT NOT ON T,CHANGED TO B ON 'A' S513
         MVI   MMSG+1,SETNOP     NOP FOR FINAL A OR M MSG ON V= OPT
         MVI   ENDINF+1,SETNOP   NOP FOR FINAL A OR M MSG ON V= OPT
         OI    SKIPPRNT+1,SETBR  SET BR TO SUPPRESS DETAIL LINE PRINT
         MVI   MSG5FLAG,X'50'    SET FOR MSG 80
         L     R2,AOUTFIL3
         CHCKTIOT NOTFND=CHKSYST5
         MVI   SYSUT,C'4'
         BAL   GOREG,OUTATTR  OPEN & PUTOUT SYSUT4 ATTRIBUTES
         MVI   SYSINOUT+1,SETNOP   SET NOP TO PUT OUT SYSIN RECS & MSG
         MVI   CLS3NOP+1,SETNOP
CHKSYST5 L     R2,AOUTFIL4         GET SYSUT5 FOR CHCKTIOT AND OPEN
         CHCKTIOT NOTFND=CHKMERGE
         MVI   SYSUT,C'5'
         BAL   GOREG,OUTATTR   OPEN & PUTOUT SYSUT5 ATTRIBUTES
         MVI   SYSINOT2+1,SETNOP   SET NOP TO PUT OUT SYSIN RECS & MSG
         MVI   CLS4NOP+1,SETNOP
CHKMERGE L     R2,=A(MERGE)       MOVE MERGE TO DDNAME
         CHCKTIOT NOTFND=NOMERGE
         MVC   MERGEBAL(2),SETBAL   SET BAL TO PERFORM MERGE OUTPUT RTN
         TITLE 'FILE MATCHING-SET UP LENGTHS && DISPLCEMENTS FOR SYSIN'
NOMERGE  LA    R3,1          RESTORE R3 TO THE COUNT OF THE PARMS
         B     GETKEYV         RETURN
CHKVEQU  EQU   *
         MVI   VBRANCH+1,SETNOP RESET BR ON L,P PROCESSING TO A NOP
         CLI   MSG40FVU,C'F'    IS RECFM=F ON SYSIN (NOT U OR V)
         BE    RESTRDCB     YES
         MVI   SYSINVAR+1,SETBR NO -SET B FOR V/U RECS PROC ON ML,AL
         OC    V1LPPAIR+1(1),LSKIP1+1   ENSURE 1 L,P ON AL,ML
         XC    NPEQUAL+1(1),LSKIP1+1   ENSURE 1 L,P ON AL,ML
RESTRDCB MVC   SYSINFVU,MSG40FVU   SAVE SYSIN RECFM (F,V,U ONLY)
         MVC   MAXLEN+2(2),SAVEDCB      RESTORE THE LRECL AND RECFM
         MVC   MSG40FVU(3),SAVEDCB+2    OF THE PRIMARY INPUT FILE
         MVI   ENDPARMS,BLANK1 RESET THE END OF PARMS FLAG
         CLI   0(R7),C')'     DOES V= PARM END IN A ')'
         BNE   MTCHERR2       NO-ERROR
         LA    R7,1(R7)       YES
         CLI   0(R7),C','     IS V= PARM FOLLOWED BY ','
         BNE   MTCHERR2                 NO
LSET2BR  MVI   VSETNOP+1,SETNOP NOP TO MOV KEY INTO INCARD EXCEPT ON L
         L     R4,POSLENS               SEE COMMENTS FOR CHKNUMB
         STC   R4,VSET1+1
         STC   R4,VSETTR1+1  THIS AND NEXT 3 MVI'S FOR CONVERT PROCESS
         STC   R4,VSETLTR1+1
         STC   R4,V1SET1+1
         STC   R4,V1SET2+1
         ST    R4,VLEN123
         MVC   VPOSLENS(4),POSLENS+4   SAVE THE POSITION IN V=
         C     R3,FULL4
         BE    ENDV
V1LPPAIR NOP   CNTERR2           CHANGED TO B ON L SUBOPT
         SPACE 1
         MVI   VBRL1+1,SETNOP
         MVI   VBR1+1,SETNOP
         L     R5,POSLENS+12
         S     R5,POSLENS+4
         ST    R5,VPOSDISP
         L     R5,POSLENS+8
         ST    R5,VLEN123+4
         STC   R5,VSET2+1
         STC   R5,VSETTR2+1
         STC   R5,VSETLTR2+1
         LA    R4,1(R4)
         STC   R4,VSET2+3
         AR    R4,R5
         C     R3,FULL6
         BE    ENDV
         SPACE 1
         MVI   VBRL2+1,SETNOP
         MVI   VBR2+1,SETNOP
         L     R5,POSLENS+20
         S     R5,POSLENS+12
         ST    R5,VPOSDISP+4
         L     R5,POSLENS+16
         ST    R5,VLEN123+8
         STC   R5,VSET3+1
         STC   R5,VSETTR3+1
         STC   R5,VSETLTR3+1
         LA    R4,1(R4)
         STC   R4,VSET3+3
         AR    R4,R5
         C     R3,FULL8
         BE    ENDV
         B     CNTERR2
ENDV     LA    R3,1               RESET R3 TO NUMB OF PARMS PROCESSED
         MVI   POSLENS,X'FF'
         MVC   POSLENS+1(23),POSLENS  RESET POSLENS TO HIGH VALUES
         STCM  R4,3,VLENGTH     STORE LENGTH OF SYSIN KEY
         STC   R4,VPNUMTST+1    STORE LENGTH OF VP KEY FOR NUM TEST
         STC   R4,VPPACK+1
         OI    VPPACK+1,X'70'   SET PACK LENGTH IN PACK INSTRUCT FOR VP
         B     CHKEJV                      RETURN
         SPACE 2
PACKCOMP CLI   NOPONL+1,SETNOP   IS L SUBOPTION USED
         BE    KEYINVAL                 YES- ERROR
         CLI   MATCHFIL,C'T'     IS T OPTION USED
         BE    KEYINVAL                 YES- ERROR
         LA    R7,1(R7)             NO-ADD 1 TO POINT BEYOND P
         MVI   PEQULNOP+1,SETNOP   DO PACK COMPARE
         MVI   NOTEST+1,SETNOP     NOP TO DO PACK TEST AND CP
         MVI   GOPACK+1,SETBR       DO PACK TEST ON SYSUT1
         MVI   NOPONVP+1,SETNOP    NOP LENGTH COMPARE
         NI    NOPGETBR+1,X'0F'    NOP RETURN ON GETCARD TO DO NUM TEST
         MVI   NPEQUAL+1,SETNOP  ALLOW ANLY 1 L,P PAIR ON SYSUT1
         MVI   V1LPPAIR+1,SETBR  ALLOW ANLY 1 L,P PAIR ON SYSIN
         MVI   PACKFLAG+1,C'N'    SET FLAG TO FORCE L<16
         B     CHKPAREN         RETURN
         TITLE 'VERIFYING THE LENGTH/POSITION PARAMETERS'
VERNUM   EQU   * CHECK TO SEE IF WORKFLD IS NUMERIC.
*   R5 CONTAINS THE NUMBER OF CHARACTERS IN  WORKFLD.
         BCTR  R5,0      SUBTRACT 1 FROM THE COUNT OF NUMBERS
VERNUM1  MVI   NUMBERR,BLANK1 SPACE OUT ERROR FLAG AT START OF ROUTINE
         L     R15,=A(TRNSTAB2)  LOAD R15 WITH ADDRESS OF TRNSTAB2
         EX    R5,VERNUMLP  TEST WHETHER WORKFLD IS NUMERIC
         BNZ   VERNUMER   NONZERO RETURN CODE INDICATES NON-NUMERIC
         EX    R5,PKVNUM  EXECUTE THE PACK OF THE WORKFLD
         BR    GOREG
VERNUMER MVI   NUMBERR,C'1'  SET ERROR SWITCH
         BR    GOREG
VERNUMLP TRT   WORKFLD(1),0(R15)    TEST WORKFLD FOR NUMERICS
PKVNUM   PACK  WORKFLD1,WORKFLD(1) THIS PACKS THE  NUMBER BEING
*   VERIFIED INTO WORKFLD1. THE LENGTH  OF WORKFLD IS MODIFIED.
         SPACE 1
POSVER   EQU   * THE POSITION/LENGTH  MUST BE NUMERIC & LESS THAN LRECL
         BAL   GOREG,VERNUM  VERIFY THE NUMBER
         CLI   NUMBERR,C'1'  IS IT O.K.
         BE    POSITNG
         CVB   R6,WORKFLD1 CONVERT THE LENGTH/POSITION TO  BINARY
         LTR   R6,R6        IS WORKFLD1 = 0
         BZ    POSITNG                YES
         BCTR  R6,0         SUBTRACT 1 FROM WORKFLD1
         S     R9,FULL8  R9 NOW PTS TO THE APPROPIATE PLACE IN POSLENS
COLBR    NOP   COLUMNS    CHANGED TO B ON E OPT
LENGRET  NOP   STORELEN   CHANGED TO B IF VERIFYING THE LENGTH
RBRANCH  NOP   STORELEN         CHANGED TO BRANCH ON R KEY
         CLI   MSG40FVU,C'V'    IS RECFM=V
         BNE   STOREPOS         NO
         A     R6,FULL4     YES-ADD 4 TO POSITION PARM
STOREPOS ST    R6,POSLENS(R9) STORE POSITION IN POSLENS + INDEX
         S     R9,FULL4      POSLENS(R9) NOW POINTS TO PREVIOUS LENGTH
         A     R6,POSLENS(R9)      ADD LENGTH TO POSITION
         CLI   VSAMFLAG,C' '      INPUT A VSAMFILE (VSAMKEY)?
         BE    CMPRLREC         NO
         S     R6,FULL4       YES-SUBTRACT OFF THE 4 ADDED FOR RDW
CMPRLREC C     R6,MAXLEN    IS LENGTH+POSITION GREATER THAN LRECL
         BNL   POSLENNG          YES
LSKIP1   NOP   LCONTIN           SET TO B ON LSUBOPT
         L     R6,POSLENS(R9)    LOAD PREVIOUS LENGTH INTO R6
         C     R6,FULL20        IS THE LENGTH GREATER THAN 20
         BNL   PARMERR          YES
LCONTIN  CLI   PACKFLAG,BLANK1 WAS 'N=','X=' OR 'P=', G OPT OR VP= REQ
         BE    INITNPM        NO
         C     R6,FULL15  YES-DOES THE PARM LENGTH OF THE KEY EXCEED 15
         BNL   PACKERR2            YES-THERE IS AN ERROR
         CLI   PACKFLAG,C'N'   WAS THE N= OPTION REQUESTED
         BE    INITNPM         YES
         C     R6,FULL8     NO-DOES THE PARM LENGTH OF THE KEY EXCEED 8
         BNL   PACKERR2     YES
         B     INITNPM      NO- PROCESS NEXT PARAMETER
STORELEN EX    0,STOREPOS       STORE THE COUNT/LENGTH IN POSLENS
         MVI   LENGRET+1,SETNOP NOP THE LENGTH VERIFICATION ROUTINE
         B     INITNPM
         TITLE 'SET UP COLUMN PROCESSING FOR THE E OPTION'
COLUMNS  EQU   *
         CLI   MSG40FVU,C'V'     IS RECFM=V
         BNE   COLNOTV             NO
         LA    R6,4(R6)      YES -ADD 4 TO EACH COLUMN SPECIFICATION
COLNOTV  EX    0,STOREPOS        STORE THE COLUMN SPECIF IN POSLENS
         C     R6,MAXLEN      IS COLUMN SPECIFICATION MORE THAN LRECL
         BNL   COLUMNER       YES-ERROR
         S     R9,FULL4       NO-POINT TO PREVIOUS COLUMN SPECIF
         BM    INITNPM           THIS IS FIST COLUMN SPECIF
         C     R6,POSLENS(R9)  IS L1<P1<L2<P2<L3<P3
         BL    COLUMNER         NO-ERROR
         B     INITNPM                YES
         TITLE 'CONTINUE PROCESSING AFTER ALL PARAMETERS ARE VERIFIED'
*   CALCULATE MAXIMUM NO OF TABLE ENTRIES FOR T,G LOGIC
CONTINPR LA    R5,5(R4)   R5=LENGTH OF KEY+COUNT FOR T,G OPTIONS
*             CHANGED ON E TO RESET LENGTH
         LM    R6,R7,LOWVALUE ZERO OUT R6,R7
         ICM   R7,7,FREELEN+1   GET LENGTH OF TABLE
         DR    R6,R5      DIVIDE BY LENGTH OF TABLE ENTRY
         CVD   R7,INLRECL MOVE MAXIMUM NO OF TABLE ENTRIES TO INLRECL
         ED    MSG36OUT,INLRECL+5  MOVE MAX NO OF ENTRIES TO MSG
         SPACE 1
         DROP  R3,R4,R5   R3 NOW FREED FROM THE DCB & R4,R5 FROM TIOT
         LA    R3,KEYAREA LOAD ADDR OF INPUT KEY AREA & KEEP IT IN R3
         LA    R9,INCARD  LOAD ADDR OF SYSIN KEY AREA & KEEP IT IN R9
         SR    R6,R6   INITIALIZE R6 TO 0 FOR R LOGIC
         L     R7,TABLE    R7 PTS TO 1ST ENTRY IN SYSIN TABLE-T,G LOGIC
         TITLE 'SET UP PARM && SYSIN CARDS FOR O,C AND B LOGIC'
ORKEYBYP NOP   READOLOG   CHANGED TO BRANCH ON 'O','B','R' ,'E' KEY
         C     R4,FULL20         MAXIMUM LENGTH OF KEY IS 20 CHARS
NOPONL   BNL   PARMERR           ERROR,CHANGED TO NOP ON L SUBOPT
SKIPGET  NOP   READOLOG          CHANGED TO BRANCH ON 'T', 'G' AND 'P'
         BAL   GOREG,GETCARD     GET FIRST SYSIN CARD
READOLOG B     BYPOREAD  NOP ON O,G,P,B & C KEY TO READ 1ST SYSIN CRD
         SPACE 1
BKEYREAD L     R1,ASYSIN          GET SYSIN DCB ADDR
         GET   (R1)
         MVI   KEYINDIC,C'1'      INDICATES LOWER KEY READ ON B KEYS
         AP    RCOUNT,PACKONE    ADD 1 TO NO OF SYSIN CARDS READ
LOWVBR   NOP   MOVINCRD     SET TO B AFTER TIME THRU-ONLY 1 LV ALLOWED
         MVI   LOWVBR+1,SETBR
         CLC   0(10,R1),LOWVMSG  IS LOW VALUES REQUESTED ON B OR P
         BNE   MOVINCRD             NO
         MVC   MSG29LKY(10),0(R1)   MOVE 'LOW VALUES' INTO MSG ON B OPT
BCOBRNCH NOP   BR2CARDS    CHANGED TO B ON B,C & O OPT TO GET 2ND CARD
PLOWVALU MVC   0(0,R7),LOWVALUE   MOVE X'00' TO TABLE,LENGTH ADJUSTED
PBRANCH1 NOP   GBUILD2              CHANGED TO B ON P OPTION
         B     BR2CARDS             GO TO READ 2ND CARD
         SPACE 2
MOVINCRD MVC   INCARD,0(R1)  LENGTH ADJUSTED- ON P OPT ONLY
* CANNOT ADJUST LENGTH ON C OR O OPTION FOR CLASS= KEYWORD
*PROBLEM WILL RESULT ON B,C OR O OPTION IF SYSIN LRECL IS LESS THAN 20
OKEYMSG1 MVC   MSG21KEY,INCARD       MOVE IN FIRST 'O' KEY
PBRANCH2 NOP   GBUILD               CHANGED TO BRANCH ON P KEY
         MVC   MSG29LKY,MSG21KEY    MOVE IN LOW KEY FOR B MSG
         CLC   INCARD(6),=C'CLASS='   IS CLASS TEST REQUESTED
BKEYBR   BNE   BR2CARDS  CHANGED TO B ON B,G KEY-NO CLASS TEST ALLOWED
         MVC   MSG21KEY,INCARD   MOVE 'CLASS=......' SYSIN CARD IN
         MVI   OCLASSBR+1,SETBR  SET UP BR TO RETURN HERE ON CLASS TEST
         LA    R7,INCARD+3       SET UP R7(T,G,P ROUTINES NEVER ENTER
OCLASCHK LA    R7,1(R7)     HERE,HENCE WE CAN USE R7.SIMILARLY FOR R6)
         LA    R6,1(R6)   R6 COUNTS NO OF CLASS OPTIONS REQUESTED
         CLI   2(R7),BLANK1   IS THIS THE END OF THE CLASS OPTION LIST
         BE    TESTMSG2       YES
         C     R6,FULL6       NO-ARE THERE MORE THAN 6 REQUESTS
         BNH   CHKLOWV        NO-CONTINUE CHECKING CLASS OPTIONS
TESTMSG2 MVI   NPEQUAL+1,SETBR RESTORE NPEQUAL TO A BRANCH
         CLC   MSG1CLS,MSGSPACE    WAS CLASS TEST REQUESTED
         BE    CLASERR1            YES
         L     R4,POSLENS      LOAD THE FIRST LENGTH INTO R4 FOR CLASS
         MVI   MAINLIN1+1,SETNOP NOP TO BRANCH TO O LOGIC MAINLINE
         MVI   NOTEST+1,SETNOP NOP TO PROCESS CLAS TESTS ON O OPTION
         LNKMSG 1,DATA=MSG1CLS        PUT OUT CLASS MESSAGE
BR2CARDS B     BYPOREAD   NOOP ON O,B  KEY TO READ 2ND SYSIN CARD
         SPACE 1
         L     R1,ASYSIN    GET SYSIN DCB
         GET   (R1)
MOVINCD2 MVC   INCARD1,0(R1)     LENGTH ADJUSTED
BKEYMSG2 MVC   MSG29UKY,INCARD1  MOVE IN HIGH KEY ON B KEY FOR MSG
         MVI   KEYINDIC,C'2'      INDICATES HIGHR KEY READ ON B KEYS
BBRANCH  NOP   OLOGIC1    CHANGED TO BRANCH ON B KEY AFTER 1 TIME THRU
*           AND CHANGED BACK TO NOP ONLY IF COUNT SATISFIED ON B
BR3CARDS B     BYPOREAD      NOOP ON O KEY TO READ 3RD SYSIN CARD
         SPACE 1
         L     R1,ASYSIN    GET SYSIN DCB
         GET   (R1)
MOVINCD3 MVC   INCARD2,0(R1)      LENGTH ADJUSTED
BYPOREAD EQU   *
         TITLE 'BUILD SYSIN TABLE FOR T,G AND P LOGIC'
GLOGIC   B     TLOGSYS    NOP ON G KEY-LENGTH SET ON GNUM1,GNUM2,GCOMPR
         L     R15,=A(TRNSTAB2)  LOAD R15 WITH ADDRESS OF TRNSTAB2
GNUM1    TRT   INCARD,0(R15)     TEST FIRST SYSIN CARD FOR NUMERICS
         BNZ   GERROR      NO
GNUM2    TRT   INCARD1,0(R15)    TEST 2ND   SYSIN CARD FOR NUMERICS
         BNZ   GERROR      NO
         EX    R4,GPACK    PACK THE SYSIN CARD INTO WORKFLD1
         B     GBUILD      INSERT KEY INTO TABLE
GEXCMPR  EQU   *           COMPARE THE LOWER & UPPER SYSIN CARDS
GCOMPR   CLC   INCARD,INCARD1    COMPARE INCARD AND INCARD1
         BH    GERROR      EVEN NUMBERED SYSIN IS LESS THAN ODD ONE
         BE    BKEYREAD     IF EQUAL READ IN A NEW PAIR OF SYSIN CARDS
         AP    WORKFLD1,PACKONE ADD 1 TO INCREMENT NEXT GENERATED SYSIN
         OI    WORKFLD1+7,X'0F' CHANGE SIGN 1/2-BYTE FROM C BACK TO F
         SLL   R4,4  SHIFT OVER A 1/2-BYTE TO ADJUST LENGTH OF UNPK
         EX    R4,GUNPK   EXECUTE UNPK TO MOVE GENERATED KEY TO INCARD
         SRL   R4,4        RESTORE R4
         AP    RCOUNT,PACKONE    ADD 1 TO NO OF SYSINS GENERATED
         B     GBUILD      CONTINUE BUILDING TABLE
*
GPACK    PACK  WORKFLD1,INCARD(1)   PACK SYSIN CARD INTO WORKFLD1
GUNPK    UNPK  INCARD(1),WORKFLD1   UNPACK WORKFLD1 BACK INTO INCARD
         SPACE 2
*   BUILD SYSIN TABLE FOR T AND G OPTIONS
TLOGSYS  B    TLOGSYSE  NOP ON 'T' LOGIC
         BAL  GOREG,GETCARD    GET A CARD-R1 CONTAINS ADDR OF THE CARD
GBUILD   MVC  0(20,R7),INCARD  MVE SYSIN CARD TO TABLE-LENGTH ADJUSTED
GBUILD2  MVC  20(4,R7),LOWVALUE ZERO OUT COUNT FOR THIS KEY-DISPL ADJ
         AR   R7,R5       INCREMENT R7 TO POINT TO NEXT ENTRY IN TABLE
*  R5 WAS LOADED WITH THE CONTENTS OF R4 + 5 AT CONTINPR
         XI   PEVENODD,X'01'
PZEROBR  NOP  PZEROBR2   CHANGED TO BZ ON P OPT SO ADD IS DONE ON ODDS
         AP   COMPCNT,COUNT     COMPCNT=MAX NO OF KEYS TO BE SELECTED
PZEROBR2 CP   RCOUNT,INLRECL    HAVE MAXIMUM NO OF SYSIN CRDS BEEN READ
         BE   ENDKEYS        YES-GO TO END-OF-SYSIN ROUTINE
GBLDBR   NOP  GEXCMPR CHANGED TO B ON G KEY-GENERATE NEW SYSIN RECORD
         B    TLOGSYS        NO READ IN ADDITIONAL CARDS
TLOGSYSE EQU  *       COMES HERE ON THE END OF SYSIN
         TITLE 'READ AND PROCESS SYSIN FILE FOR V OPTION'
*        THE FIRST SYSIN RECORD MUST BE OF THE FORMAT:
*          VOL=VOLSER,VOLSE*,...,VOL* WHERE THE ASTERISK ALLOWS GENERIC
*                        VOLUME NAMES. UP TO 10 SPECIFICATIONS ALLOWED.
*        THE FOLLOWING SYSIN RECORD MUST HAVE THE FORMAT:
*        DSN
*        DSNAM*
*        PDS(MEMBER)
*        PDSNAM*(MEMBER)
*        PDS(MEMB*)
*        PDSNAM*(MEMB*)
*        %DSNAM*(MEMB*)
*        %DSN+++(MEMB*)
*        !ABC!(MEMB*)
*            WHERE MEMBER MAY OR MAY NOT BE SPECIFIED AND THE MEMBER
*            NAME CAN BE GENERIC. DSN MUST BE SPECIFIED. UP TO 10
*            DSN(MEMB) RECORDS ALLOWED.
*            3 WILDCARD SPECIFICATIONS ON THE DSN ARE ALLOWED:
*            % - IN FIRST POSITION OF DSN INDICATES ACCEPT ALL
*                HIGH ORDER QUALIFIERS AS AUTOMATIC MATCH.
*            + - ANY STRING OF +'S ANYWHERE IN THE THE DSN
*                ACCEPT ANY CHARACTERS WHEREVER THE + APPEARS AS MATCH
*            ! - SEARCH ANYWH IN DSCB FOR THE STRING ENCLOSED IN THE !
*                DELIMITERS.
*
*        THE VOL= RECORD SHOULD BE CODED SO THAT NO VOLSER SPECIFICATON
*        SUBSUMES ANOTHER TO AVOID DUPLICATE VTOC SEARCHES. E.G.
*        VOL=HRSHR*,HRSHR5 SHOULD NOT BE CODED.
*        IF THE FIRST RECORD DOES NOT BEGIN WITH VOL= IN COL 1 THEN
*         IT IS ASSUMED THAT A CATALOG SEARCH IS BEING PERFORMED AND
*         AND ALL THE SYSIN RECORDS ARE DSN RECORDS.
*         IN THIS CASE, THE WILDCARD SPECIFICATIONS % AND ! ARE NOT
*         VALID AND ANY DSN RECORD CONTAINING THEM WILL BE IGNORED.
*         THE + AND * WILDCARDS ARE OK EXCEPT THAT THEY MAY NOT APPEAR
*         IN THE THE HIGH ORDER QUALIFIER OF THE DSN. MEMBER NAMES
*         MAY BE SPECIFIED. THE SYSTEM SEARCHES THE CATALOGS IN SYSTEM
*         DEFAULT ORDER. ONCE THE CATALOG SEARCH RETURNS A VOLSER FOR A
*         DSN, THAT DSN AND VOLSER ARE USED TO OBTAIN THE REQUIRED INFO
*         FROM THE VTOC/DIRECTORY. CATALOGED TAPE DATASETS MAY BE
*         SPECIFIED, BUT SHOULD NOT BE
*         USED IN ATTACHED HFSELECT SUBTASKS IF YOUR INSTALLATION
*         REQUIRES JOB SETUPS FOR TAPE JOBS.
*        THE REMAINING SYSIN RECORD SHOUD BE SORTED ON DSN (WITH GENERC
*        DSN PRECEEDING FULL DSNS WITH THE SAME PREFIX) AND MEMBER NAME
*        TO AVOID MULTIPLE DIRECTORY SEARCHES OF PDSS.
*        E.G. *(QRST),ABC*,ABC(XYZ),ABC(ZZZ),ABD
*
*        THE SYSIN RECORDS ARE STORED IN 2 TABLES:
*        THE VOLSER TABLE CONSISTS OF UP TO 10 VOLSER ENTRIES 7 BYTES
*        LONG WHERE THE FIRST BYTE IS EITHER X'00' OR X'80' WHICH
*        INDICATES THE LAST VOLSER IN THE TABLE
*
*        THE DSN(MEMBER) TABLE CONSITS OF UP TO 11 ENTRIES (ONLY 10
*        NON-ZERO ALLOWED) IN THE FOLLOWING FORMAT-
*        BYTES 1-4   MATCH COUNT
*              5     DSN LENGTH IN BINARY
*              6     MEMBER LENGTH IN BINARY
*              7-50  DSN (FIRST BYTE BLANK IF !,%-WILDCARD USED)
*              51-58 MEMBER NAME
*              59    X'FF' LAST ELEMENT AFTER SORT
*              60-79 NULL
*              80    !,%-WILDCARD INDICATOR
*        THE LENGTH FIELD MAY CONTAIN
*              X'00' IN DSN FIELD THIS INDICATES END OF SYSIN
*                    IN MEMBER NAME FIELD INDICATES NO PDS MEMBERS
*                       ARE TO BE PROCESSED ONLY, ONLY DSNS.
*              X'FF' NO COMPARISONS ARE NECESSARY, ALL DSNS/MEMBERS ARE
*                    TO BE SELECTED AS MATCHED
*              X'ACTUAL LENGTH' A GENERIC DSN/MEMB OR ! HAS BEEN SPECIF
*                     AND THE COMPARE IS TO DONE ON THE ACTUAL LEN ONLY
*              X'2C' OR X'08' FULL DSN (LENGTH 44) OR FULL MEMBER NAME
*                     (8) LENGTH FOR NON-GENERIC COMPARE.
VTOCLOG  B     GETINPUT             SET TO NOP IF V OPTION REQUESTED
         MVC   MSG36OUT(6),=CL6'11' LIMIT TO 1 VOL= REC AND 10 DSN(MEM)
VTOCLOG1 L     R7,=A(VOLTABL)       PLACE ADDR OF SYSIN TABLE IN R7
VLOGSYS  L     R1,AVSYSIN           GET A VSYSIN RECORD
         GET   (R1)
VPARMBR  B     GETVPARM        SET TO BR IF VSYSIN DD CODED
NOVPARM  AP    RCOUNT,PACKONE
         MVC   6(72,R7),0(R1)  MOVE RECORD TO TABLE - 1ST 6 BYTES RESER
         MVI   79(R7),BLANK1   BLANK OUT WILDCARD COL
         CP    RCOUNT,=P'11'      HAVE WE REACHED TABLE LIMIT
         BH    ENDKEYS                      YES
*@MK1    MVC   MSG65LBL,0(R1)     NO - GET READY TO PRINT SYSIN KEY
*@MK1    LNKMSG 97,DATA=MSG65LBL    PRINT
         L     R15,=A(MSG65LBL)                                    @MK1
         MVC   0(L'MSG65LBL,R15),0(R1) NO-READY TO PRINT SYSIN KEY @MK1
         LNKMSG 97,DATA=(R15,L'MSG65LBL)     PRINT                 @MK1
         CP    RCOUNT,PACKONE     IS THIS THE FIRST SYSIN RECORD (VOL=)
         BE    VOLREC          YES- GO TO VOL= SYSIN REC PROCESSING
VTOCLOG2 AP    COMPCNT,COUNT  NO- MAX NUMBER OF RECORDS TO BE SELECTED
         CLI   6(R7),C'%'     WILDCARD QUALIFIER OPTION - %
         BE    VWC            YES
         CLI   6(R7),C'!'     WILDCARD QUALIFIER OPTION - !
         BE    VWC2      YES -DONT PUT INDICATOR IN REC UNTIL 2ND FOUND
VCONTIN  L     R15,=A(ASTPAREN)  NO- GET TRT TABLE WITH '*','(',')','!'
         SR    R1,R1             ZERO OUT R1 FOR TRT
         TRT   6(54,R7),0(R15)   EXAMINE SYSIN RECORD
         BZ    DSNONLY BR IF DID NOT FIND *,(,) OR!,IE. NON-GENERIC DSN
         ST    R1,SAVEADDR  SAVE ADDR OF 1ST *,(,),!
         CLM   R2,1,=C'('  DID TRT STOP AT (; I.E. MEMBER WAS SPECIFIED
         BNE   DSNGENRC    NO- A GENERIC DSN WAS SPECIFIED FIRST
         MVI   4(R7),X'2C' YES- SET DSN LEN TO 44 I.E. FULL NON-GEN DSN
MEMTRT   TRT   1(9,R1),0(R15)  STARTING AFTER '(' EXAMINE MEMBER NAME
         BZ    INVALVKY     ERROR- DID NOT FIND * OR )
         CLM   R2,1,=C')'   DID WE FIND AN ')'
         BNE   MEMGENRC      NO - IT MUST BE A GENERIC MEMBER NAME
         MVI   5(R7),X'08'   YES- SET MEMBER NAME LEN TO 8;NON-GENERIC
         L     R2,SAVEADDR   GET ADDR OF '('
         SR    R1,R2         CALCULATE ACTUAL LENGTH OF MEMBER NAME +1
         C     R1,FULL1      WAS A MEMBER NAME SPECIFIED
         BE    INVALVKY      NO - ERROR
MVESYSIN STC   R1,SETDSN+1  SET LENGTH TO BLANK OUT '(MNAME)'
         BCTR  R1,0         SUBTRACT 1 FOR ACTUAL LENGTH
         C     R1,FULL8     IS MEMBER NAME GREATER THAN 8
         BH    INVALVKY            YES- ERROR
         BCTR  R1,0          NO -SUBTRACT 1 TO SET MVC LENGTH
         STC   R1,MVEMEMB+1      STORE LEN-1 IN MVC
         MVC   MEMBHOLD,1(R2)   MOVE MEMBER NAME INTO HOLD AREA
SETDSN   MVC   0(0,R2),MSGSPACE SET UP DSN PROPER-BLANK FROM '(' TO ')'
MVEMEMB  MVC   50(0,R7),MEMBHOLD MV MEMBER NAME INTO COLUMN 51 OF TABLE
         B     NXTVKEY     GET THE NEXT KEY
         SPACE 3
VWC      MVI   79(R7),C'%'   SET WILDCARD INDICATOR FLAG
VWC2     MVI   6(R7),BLANK1  BLANK OUT % OR !, SO IT WILL SORT LOW
*        AND GIVE ALL HIGH ORDER QUALIFIERS
         B     VCONTIN
         SPACE 3
DSNONLY  MVI   4(R7),X'2C'    SET DSN LENGTH TO 44
NXTVKEY  LA    R7,80(R7)     POINT TO NEXT TABLE ELEMENT
         B     VLOGSYS        READ NEXT SYSIN REC
         SPACE 3
MEMGENRC MVI   1(R1),BLANK1   BLANK OUT THE ')'
         CLM   R2,1,=C'*'     IS THE DELIMITER '*' FOR GENERIC MEMBER
         BNE   INVALVKY               NO -ERROR
         L     R2,SAVEADDR    GET ADDR OF '('
         SR    R1,R2          CALCULATE GENERIC MEMBER NAME +1
         BCTR  R1,0           SUBTRACT 1
         LTR   R1,R1       IS MEMBER LENGTH =0 I.E. WAS (*) REQUESTED
         BZ    ALLMEM     YES -PROCESS EVERY MEMBER IN THE PDS AS MATCH
         STC   R1,5(R7)   NO- PLACE ACTUAL MEMBER NAME LENGTH IN TABLE
         LA    R1,1(R1)   ADD 1 TO ACTUAL LENGTH FOR BLANK-OUT RTN
         B     MVESYSIN   WHICH WILL BLANK-OUT '(MNAME*'
         SPACE 3
ALLMEM   MVI   5(R7),X'FF' SET TABL LEN TO X'FF' - INDICATES ALL MEMBER
         MVC   0(2,R2),MSGSPACE  BLNK OUT '(*';NO NEED TO MOVE MEM NAME
         B     NXTVKEY
         SPACE 3
DSNGENRC MVI   0(R1),BLANK1   BLANK OUT THE '*' OR '!' IN GENERIC DSN
         CLM   R2,1,=C'*'     WAS DELIMITER = *
         BE    GENRCOK        YES - OK
         CLM   R2,1,=C'!'     WAS DELIMITER = !
         BNE   INVALVKY           NO - ERROR
         CLI   6(R7),BLANK1   IS THIS THE FIRST BYTE BLANK (OR WAS !)
         BNE   INVALVKY       NO - ERROR
         MVI   79(R7),C'!'    YES PLACE ! IN WILDCARD INDICATOR
GENRCOK  LA    R2,6(R7)        PLACE COL 6 ADDR OF TABLE ELEMENT IN R2
         SR    R1,R2        GET ACTUAL LENGTH OF GENERIC DSN
         BZ    ALLDSN       IS LEN=0 I.E.  ALL DSNS ARE REQUESTED
         STC   R1,4(R7)     NO- STORE ACTAL GENERIC DSN LEN IN TABLE
CHKMEM   L     R1,SAVEADDR    GET ADDRESS OF '*' OR '!' IN GENERIC DSN
         LA    R1,1(R1)  POINT 1 BEYOND THE * OR '!' TO SEE IF MEMB REQ
         ST    R1,SAVEADDR   BUMP UP SAVEADDR BY 1 TO POINT TO '('
         CLI   0(R1),C'('    IS '*' OR '!' FOLLOWED BY '('
         BE    MEMTRT        YES - A MEMBER HAS BEEN SPECIFIED
         B     NXTVKEY       NO- GET NEXT KEY (IGNORE BEYOND *)
         SPACE 2
ALLDSN   MVI   4(R7),X'FF'   SET DSN LEN TO 44 TO INDICATE ALL DSNS
         B     CHKMEM           CHECK FOR MEMBER NAME
         SPACE 3
VOLREC   CLC   6(4,R7),=C'VOL='   IS 'VOL=' FIRST 4 CHARS OF 1ST SYSIN
         BNE   NOVOLS                    NO - CATALOG ACCESS
         L     R15,=A(COMMABLK)   YES- GET TRT TABLE FOR ' ' AND ','
         L     R8,=A(VOLSER)    LOAD R8 WITH VOLSER TABLE ADDR
         LA    R7,10(R7)        POINT BEYOND VOL=
VOLLOOP  TRT   0(7,R7),0(R15)   FIND THE FIRST ' ' OR ','
         BZ    INVALVKY         NONE FOUND -ERROR
         SR    R1,R7            GET VOLSER LENGTH
         BZ    INVALVKY       LEN=0 NOTHING ENTERED - ERROR
         BCTR  R1,0             SUBTRACT 1 FOR MVC
         STC   R1,MVVOLSER+1    SET MOVE LENGTH FOR VOLSER
MVVOLSER MVC   1(0,R8),0(R7)    MOVE VOLSER INTO TABLE
         CLM   R2,1,=C' '      WAS ' '  THE DELIMITER
         BNE   VOLNXT            NO - GET THE NEXT VOLSER
         MVI   0(R8),X'80'      YES- SET END OF TABLE FLAG
         B     VTOCLOG1
         SPACE 2
VOLNXT   LA    R8,7(R8)         POINT TO NEXT VOLSER TABLE ENTRY
         LA    R7,2(R1,R7)       POINT TO VOLSER ON VOL= SYSIN REC
         AP    VOLSERCT,PACKONE    ADD 1 TO VOLSER COUNT
         CP    VOLSERCT,=P'10'     LIMIT TO 10 VOLSERS
         BH    VTOCLOG1
         B     VOLLOOP            PROCESS NEXT VOLSER
         SPACE 2
GETVPARM MVI   VPARMBR+1,SETNOP RESET NOP- ONLY 1 TIME THRU HERE
         CLI   0(R1),X'7D'    IS 'QUOTE' FIRST CHAR OF 1SR VSYSIN CARD
         BNE   NOVPARM        NO- NO SUBTASKING REQUESTED
         L     R7,=A(VPARM)   GET PARM AREA ADDR
         MVC   2(79,R7),1(R1) MOVE PARM IN (MINUS LEADING QUOTE)
*              LEAVE FIRST 2 BYTE EMPTY- WILL MOVE PARM LENGTH IN THERE
         L     R15,=A(VPARMTAB)  GET TRANSLATE TABLE TO LOOK FOR QUOTE
         TRT   2(79,R7),0(R15)   FIND QUOTE
         BZ    INVALVKY         NO END QUOTE -ERROR
         CLI   2(R7),C'V'       RECURSIVE V OPTION NOT ALLOWED
         BE    INVALVKY
         MVI   0(R1),C' '       BLANK OUT LAST QUOTE
         LA    R2,2(R7)         GET BEGIN ADDR OF PARM
         SR    R1,R2            GET PARM LENGTH
*        BZ    INVALVKY         0 LENGTH NOT ALLOWED<=== 0 OK
         STH   R1,0(R7)         STORE IN FIRST 2 BYTES OF PARM AREA
*@MK1    MVC   MSG65LBL,0(R2)   MOVE PARM TO PRINT AREA
*@MK1    LNKMSG 97,DATA=MSG65LBL  PRINT IT
         L     R15,=A(MSG65LBL)                                    @MK1
         MVC   0(L'MSG65LBL,R15),0(R2) NO-READY TO PRINT SYSIN KEY @MK1
         LNKMSG 97,DATA=(R15,L'MSG65LBL)     PRINT                 @MK1
         B     VTOCLOG1        CONTINUE PROCESSING REST OF VSYSIN
NOVOLS   AP    RCOUNT,PACKONE  ADD 1 TO CARDS READ (PHONY VOL= CARD)
         B     VTOCLOG2
         TITLE 'READ INPUT FILE'
GETINPUT NOP   STARTPRC   GET NEXT INPUT RECORD & CK KEY
*  SET GETINPUT TO BRANCH WHEN NOINPUT CODED IN X0 EXIT
         L     R1,DCBADDR         LOAD ADDR OF ISAM/INFIL INTO R1
         SPACE 1
GETVTOC  B     GETLIB     SET TO NOP ON V OPTION
         L     R15,=A(READDSCB)
         BALR  R14,R15    PERFORM READ VTOC RTN TO EOJ
         C     R15,FULL1  0=NORMAL END, 1=ERROR, 2=COUNT SATISFIED
         BL    VMSGPT     PRINT MSGS ON NORMAL END
         BH    VMSGSAT
         MVI   VMSGNOP+1,SETNOP  ON V OPT ERR, FIRST PRT NORMAL MSGS
         B     VMSGPT
         SPACE 2
GETLIB   B     BR2VSGET           CHANGED TO NOP ON LIBRARY INPUT FILE
         L     R15,=A(LIBCSECT)   LOAD LIBRARY PROCESSING CSECT ADDR
         BALR  R14,R15
         C     R15,FULL1   IS THIS THE LAST REC OF THE LIBRARY (RC=1)
         BL    STOREADR           NO-CONTINUE NORMALLY         (RC=0)
         BE    ENDINPUT           YES
***      B     LIBOUTER           RC=2 STOW ERROR ON LIBOUT AT EOF
         BAL   GOREG,LIBOTEOJ  RC>=4 STOW ERROR ON LIBOUT(AT EOF ONLY)
         B      ENDINPUT       OR ON SYNADERR ON LIBFILE
         SPACE 1
BR2VSGET NOP   VSAMGET            CHANGED TO B ON VSAM INPUT FILE
         SPACE 2
         GET   (R1)               R1 HAS ADDR OF REC ON RETURN
         SPACE 2
STOREADR ST    R1,PUTADDR         SAVE ADDR OF REC IN PUTADDR FOR PUT
SAMETAPE NOP   GETCARD            CHANGED TO BAL ON S513 BOMB ON 'A'
EXITBRI1 B     NOEXITI1   CHANGED TO NOP IF EXIT POINT I1 REQUESTED
         L     R15,=A(EXTEPAI1)   GET EXIT I1 ENTRY POINT
         L     R15,0(R15)
         LA    R1,PUTADDR         SET UP PARAMETER LIST
         BALR  R14,R15            EXECUTE I1 EXIT
         C     R15,FULL4          CHECK RETURN CODE
         BL    NOEXITI1 RC=0   CONTINUE NORMAL PROCESSING
         BE    GETINPUT RC=4  DELETE THIS RECORD-GET NEW SYSUT1
         MVI   EXITBRI1+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT
NOEXITI1 EQU   *
         L     R1,PUTADDR   RESTORE R1 ON RETURN FROM ABOVE BAL ON S513
*           AND FOR VSAM AND TAPELABL PROCESSING
         AP    PASSCT,PACKONE     INCREMENT INPUT COUNTER
         AP    ENDCT,PACKONE    INCREMENT TOTAL RECS READ
         CP    ENDCT,BEGIN      HAVE BEGIN NO OF RECS BEEN READ(B=)
NOPBEQU  BNH   AGETCRD1   NO-GET NEW INPUT REC;NOP FOR VSAMKEY
DBPUTOUT NOP   DPUTREC          CHANGED TO BR ON D KEY
         CP    ENDCT,END        HAS END BEEN REACHED(E=)
SETBRONV BNH   STARTPRC    NO-SET TO BR ON V= AFTER 1ST TIME THRU
*            ALSO SET TO BR ON R OPT WITH NON-RANDOM SYSIN
         MVI   ENDFLAG,X'51'   SET E= FLAG FOR MSG 81
E@EQUBR  NOP   PUTOUT    SET TO BR ON E OPT WITH @-CHG AFTER E= SATISF
KEEQNOP  B     ENDINPUT         GO TO EOJ; SET TO NOP ON K OPT
         MVI   KEEQUAL+1,SETBR  ON K OPT IF E= ALLOW PROCESSING TO
         B     STARTPRC  CONTINUE UNTIL NEW GRP ENCOUNTERED(KEY CHG)
         SPACE 1
VSAMGET  B     VSMPOINT  SET TO NOP ON VSAMKEY TO MOD KEYLEN,NIX SYSUT3
         MVI   VSAMGET+1,SETBR   RESET TO B AFTER FIRST TIME THRU
         MVI   VSMPOINT+1,SETNOP SET NOP TO POINT TO PROPER REC ON KEY
         LR    R2,R1      GET RPL ADDR
         MODCB RPL=(R2),KEYLEN=(*,VSAMKEYL)  PUT CORRECT KEYLEN IN RPL
         LR    R1,R2      PUT RPL ADDR BACK IN R1
         MVI   BRPTOUT2+1,SETBR  DISALLOW CREATION OF SYSUT3 FILE
VSMPOINT B     NOTVSKEY  SET TO NOP ON VSAMKEY
         MVI   VSMPOINT+1,SETBR RESET TO B FOR SEQ UNTIL NEW SYSIN READ
         POINT RPL=(R1)  POSITION TO REC WITH NEXT KEY ON VSAMKEY
         LTR   R15,R15
         BNZ   VSAMERR
NOTVSKEY GET   RPL=(R1)  GET NEXT PHYS/SEQ VSAM REC R1=ADDR OF RPL
         LTR   R15,R15   NEXT PHYSICAL RECORD FOR VSAMFILE
         BNZ   VSAMERR   NEXT LOGICAL SEQ RECORD WITH VSAMKEY
         LR    R2,R1    PUT RPL ADDR IN R2
*        GET THE CURRENT RBA AND THE LRECL
         SHOWCB RPL=(R2),AREA=RBA,LENGTH=8,FIELDS=(RBA,RECLEN)
         LR    R1,R2      PUT RPL ADDR BACK IN R1
*        MOVE THE VSAM RECORD TO A WORKAREA, AFTER PLACING AN RDW ON IT
VSMOVREC NOP   VSKEYNOP  SET TO BR IF VSAMOUT CODED (BYPASS MOVE OF REC
*              SINCE AN RDW IS NOT NEEDED FOR WRITING A VSAM REC)
         L     R14,PUTADDR       PUT SENDING FLD ADR IN R14
         L     R1,=A(VSRECADR)   GET ADDR OF GETMAINED WORKAREA
         L     R1,0(R1)
         ST    R1,PUTADDR  REPLACE INPUT REC ADR WITH ADR OF MODIF REC
         L     R0,VSAMRECL       GET LRECL OF VSAM REC
         A     R0,FULL4         ADD 4 TO LRECL FOR APPENDED RDW
         STH   R0,0(R1)     PLACE RDW INTO REC WORKAREA
         LA    R0,4(R1)     POINT BEYOND RDW & PLACE WKAREA ADR IN R0
         L     R1,VSAMRECL  GET ORIGINAL LENGTH AGAIN INTO R1
         LR    R15,R1                                 AND R15
         MVCL  R0,R14       MOVE RECORD
         LR    R1,R2      PUT RPL ADDR BACK IN R1
         SPACE 1
VSKEYNOP B     SAMETAPE  RETURN TO NORMAL GET ROUTINE, NOP ON VSAMKEY
         SPACE 2
         CLC   SAVERBA,RBA  COMPARE TO PREVIOUS RBA
         BE    NOTVSKEY     ITS THE SAME RECORD- GET NEW RECORD
         MVC   SAVERBA,RBA  MOVE IN NEW RECORD RBA
         B     SAMETAPE
         TITLE 'SET UP INPUT KEY AND BRANCH TO PROCESSING ROUTINE'
STARTPRC EQU   *
ELOGIC   NOP   BYPTRNSL  CHANGED TO B ON E OPT TO BYP SETTING KEYS
RANDMOPT NOP   RNDMROUT  CHANGED TO B ON R KEY IF RANDOM OPTION
REXTLOG  NOP   REXTLOG1  CHANGED TO B ON R KEY IF ONLY 1 PARM PRESENT
RLOGIC   NOP   RLOGIC1   CHANGED TO BRANCH ON R KEY
         SPACE 1
*              R3 = ADDR OF KEYAREA, R1 = ADDR OF INFIL RECORD
         L     R1,PUTADDR      LOAD R1 WITH REC ADDR
VENTRY   A     R1,POSLENS+4    ADD DISP TO REC ADDR;ENTRY PT FOR V OPT
SET1     MVC   0(0,R3),0(R1)   LENGTH FLDS SET IN SETPARM
         SPACE 1
CNVRTBR1 B     BR1     SET TO NOP IF CONVERT FILE PRESENT
         L     R15,=A(CNVRTABL)   GET CONVERT TABLE
SETTR1   TR    0(0,R1),0(R15)     CONVERT FIRST KEY -LENGTH SET
         SPACE 1
BR1      B     KEYSET             NOP IF TWO OR THREE CHAR GROUPS
         A     R1,POSDISPS     ADD P2   TO REC ADDR
SET2     MVC   0(0,R3),0(R1)   LENGTH & DISPLACE FLDS SET IN SETPARM
         SPACE 1
CNVRTBR2 B     BR2     SET TO NOP IF CONVERT FILE PRESENT & 2 KEYS
SETTR2   TR    0(0,R1),0(R15)     CONVERT 2ND KEY -LENGTH SET
         SPACE 1
BR2      B     KEYSET             NOP IF THREE CHAR GROUPS IN KEY
         A     R1,POSDISPS+4   ADD P3   TO REC ADDR
SET3     MVC   0(0,R3),0(R1)   LENGTH & DISPLACE FLDS SET IN SETPARM
         SPACE 1
CNVRTBR3 B     KEYSET  SET TO NOP IF CONVERT FILE PRESENT & 3 KEYS
SETTR3   TR    0(0,R1),0(R15)     CONVERT 3RD KEY -LENGTH SET
         SPACE 1
KEYSET   B     BYPTRNSL  CHANGED TO NOP WHEN Y= OPTION REQUESTED
         L     R15,=A(TRNSTAB5)  LOAD THE ADDRESS OF TRANSLATE5
YTRNSLT1 TR    0(0,R3),0(R15)   TRANSLATE THE SYSUT1 KEY
BYPTRNSL EQU   *
FLOGIC   NOP   FLOGIC1   CHANGED TO BRANCH ON F KEY
TLOGIC   NOP   TLOGIC1   CHANGED TO BRANCH ON T KEY
         SPACE 1
NOTEST   B     OLOGIC    CHANGED TO NOP IF CLASS REQUESTED
         MVI   OUTPTKEY,C'N'  RESET OUTPUT FLAG
GOLOWV   NOP   LOWVTST        SET TO BRANCH IF LOW VALUE TEST REQ
GOHIGHV  NOP   HIGHVTST       SET TO BRANCH IF HIGH VALUE TEST REQ
GOALPHB  NOP   ALPHBTST       SET TO BRANCH IF ALPHABETIC REQUESTED
GONUMER  NOP   NUMERTST       SET TO BRANCH IF NUMERIC REQUESTED
GOALPHN  NOP   ALPHNTST       SET TO BRANCH IF ALPHANUMER REQUESTED
GOPACK   NOP   PACKTST    SET TO BRANCH IF PACK TEST REQUESTED OR P=
GONEQUAL NOP   NEQUTEST      SET TO BRANCH IF N= OPTION REQUESTED
         SPACE 1
OUTPTTST EQU   *
         CLI   OUTPTKEY,C'Y'   WAS A MATCH MADE ON CLASS TEST
MAINLIN1 B     ENTRYPT   RETURN TO MAINLINE PROCESSING  NOP FOR O LOGIC
         B     ENTRYPT2        RETURN TO O LOGIC MAINLINE PROCESSING
         SPACE 1
OLOGIC   NOP   OLOGIC1   CHANGED TO BRANCH ON O KEY
         TITLE 'SINGLE AND MULTIPLE KEY LOGIC (A,D,S,M) PROCESSING'
COMPKEY  NOP   COMPLKEY          CHANGED TO B ON L SUBOPTION
COMPSKEY CLC   0(0,R3),INCARD
ENTRYPT  EQU   *               ENTRY POINT FROM CLASS TEST ROUTINE
DKEYEQ   NOP   DWRITE    SET TO BE ON D KEY, SET TO BNE ON DN
*        SET TO BH ON D OPT N,P=>. SET TO BL ON D OPT N,P=<
DKEYNE   NOP   GETINPUT  SET TO B ON D KEY
BR6      BE    PUTOUT    CHANGED TO BNE ON SN,BL ON MN,BNE ON 'AN'
*        SET TO BH ON S OPT N,P=>. SET TO BL ON S OPT N,P=<
BR4      BH    NEXTKEY   NOPED ON S OR SN OR A OPTIONS
AGETCRD1 NOP   GETCARD   CHANGED TO BAL ON A OPTION (USING R8)
SOPTVSAM NOP   ENDINPUT  CHG TO BR ON S OPT WITH VSAMKEY INPUT FILE
*                        END PROCESSING ON NOMATCH
         SPACE 1
VOPTREJ  NOP   VOPTRET2  SET TO B ON V OPT, RECORD REJECTED
BRPTOUT2 B     GETINPUT  NOP TO OUTPUT NON-SELECTED RECORDS
SETBEQBR NOP   GETINPUT      SET TO ON 1ST PASS OF D OPTION
E@CHGBR  NOP   PUTOUT     SET TO B ON E OPT WITH @ CHG-KEY
*        ALL RECORDS ARE PUT OUT TO SYSUT2 (NON-SELECTED AND B=)
         MVI   SYSUTX,C'3'
EXITBRO2 B     NOEXITO2   CHANGED TO NOP IF EXIT POINT O2 REQUESTED
         L     R15,=A(EXTEPAO2)   GET EXIT O2 ENTRY POINT
         L     R15,0(R15)
         LA    R1,PUTADDR         SET UP PARAMETER LIST
         BALR  R14,R15            EXECUTE O2 EXIT
         C     R15,FULL4          CHECK RETURN CODE
         BL    NOEXITO2 RC=0   CONTINUE NORMAL PROCESSING
         BE    GETINPUT RC=4  DELETE THIS RECORD-GET NEW SYSUT1
         MVI   EXITBRO2+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT
NOEXITO2 EQU   *
         L     R2,DCBADDR    LOAD INPUT DCB ADDR INTO R2 FOR PRINT LINK
         L     R1,AOUTFIL2   LOAD OUTPUT DCB ADDR INTO R1
         L     R0,PUTADDR  LOAD ADDR OF ISAM/INFIL REC AREA INTO R0
SKIPPUT3 NOP   PRNT3BAL   CHANGED TO BRANCH IF SYSUT3 IS SYSOUT
         PUT   (R1),(R0)   WRITE OUTFIL2 FROM INPUT REC AREA
PRNT3BAL NOP   PRINTLK    CHANGED TO BAL IF SYSUT3 IS SYSOUT
         AP    OUTCT2,PACKONE
         B     GETINPUT  BRANCH TO READ ANOTHER RECORD
         SPACE 1
PUTOUT   EQU   *
VOPTBR   NOP   VOPTRET SET TO B,RTURN TO V OPTION PROCESSING
         CP    OUTCT,COUNT
MNSTOP   NOP   BRPTOUT2           SET TO BE ON MN KEY
         BAL   GOREG,PUTFILE      WRITE OUT LAST REC READ
MERGEBAL NOP   MERGERTN    SET TO BAL GOREG,MERGERTN FOR MERGE FILE
         CP    OUTCT,COUNT        COMPARE PARM COUNT TO RECORD COUNT
MNPUTBR  BL    GETINPUT  ON MN CHANGE TO B,ON 'A' OPT CHANGE TO NOP
         MVC   MSG4MAX,=C'MAX'    MAX FOR A KEY REACHED
BR5A     NOP   ENDINPUT  SET TO BRANCH FOR EOJ ON MN
         BAL   GOREG,KEYREPT      FORMAT & PRINT
BR5      B     ENDKEYS   IF M OR MN NOP SO MORE KEYS ARE READ
         BAL   GOREG,GETCARD
         B     GETINPUT
NEXTKEY  EQU   *                  THIS ROUTINE ONLY FOR KEYTYPE= M
         SP    PASSCT,PACKONE
         BAL   GOREG,KEYREPT      PUT OUT MSG FOR THIS KEY
         AP    PASSCT,PACKONE
         BAL   GOREG,GETCARD      GET NEW SYSIN KEY
         B     NOTEST  GO BACK TO COMPARE (CHG FROM COMPKEY FOR VP)
         SPACE 1
VOPTRET  L     R15,=A(VPUTRET)    RETURN TO V OPTION CSECT
         L     R1,=A(SAVEAREQ)    PASS BASE ADDR BACK TO V OPT CSECT
         BR    R15
         SPACE 1
VOPTRET2 L     R15,=A(VPUTREJ)    RETURN TO V OPTION CSECT, REC REJ
         L     R1,=A(SAVEAREQ)    PASS BASE ADDR BACK TO V OPT CSECT
         BR    R15
         SPACE 1
MERGERTN L     R15,=A(MERGSECT)     PERFORM MERGE RTN
         BALR  R14,R15
         LTR   R15,R15
         BNZ   RECFMERR     RC=4
         BR    GOREG
         TITLE 'MULTIPLE KEY LOGIC (T) PROCESSING'
TLOGIC1  L      R15,=A(TSEARCH) LD R15 WITH ADDRESS OF SEARCH ROUTINE
         BALR   R14,R15   BRANCH TO THE CSECT AND SET RETURN ADDRESS
         LTR    R15,R15    IF R15=0 THEN RECORD KEY HAS BEEN MATCHED
TLOGNEQ  BNZ    BRPTOUT2   NO MATCH ON THE KEY -CHANGED TO BZ ON 'TN'
         BAL    GOREG,PUTFILE   THE RECORD HAS MATCHED PUT IT  OUT.
         CP     OUTCT,COMPCNT     HAS MAX NO OF RECORDS BEEN SELECTED
         BE     ENDINPUT          YES
         CP     OUTCT,COUNT    HAS THE DESIRED COUNT BEEN REACHED ON TN
TLOGNEQ1 B      GETINPUT   NO-GET THE NEXT RECORD,CHANGED TO BL ON TN
         B      ENDINPUT          THAT'S ALL FOLKS
         TITLE 'MATCHING A FILE AGAINST ITSELF LOGIC (F,K,Q) PROCESS'
FLOGIC1  NOP   COMPLKY2     F LOGIC PROCESSING,CHANGED TO B ON L SUBOPT
COMPFKEY CLC   KEYAREA,INCARD   COMPARE
SEQCHK   NOP   SEQMSG2 CHANGED TO BL ON Q KEY-OUT OF SEQ,BH ON QN
QBOUT2   NOP   QWRITE      CHANGE TO B TO WRITE THE SEQUENCED FILE ON Q
NOOPONQ  BE    FEQUALKY    BRANCH ON FKEY EQUAL OTHERWISE BREAK IN KEY
*                          THIS BE CHANGED TO NOP ON Q KEY
FREQUECY NOP   BR2PRTF      CHANGED TO B ON F,J=0 FREQUENCY REQUEST
FKQLMOVE NOP   MVCL   CHANGED TO BAL GOREG,MVCL ON FL,QL,KL OPTION
FMOVE    MVC   INCARD,KEYAREA     MOVE KEY IN RECORD TO KEY AREA
SEQOK    NOP   GETINPUT           CHANGED TO BRANCH ON Q OPT
         SPACE 1
KEEQUAL  NOP   ENDINPUT   CHANGED TO BR ON K OPT WHEN E= SATISFIED
*        CONTINUE TO PROCESS UNTIL KEY UNEQUAL CONDITION, THEN B TO END
KKEYSW   B     FCOMPARE           NOOPED ON K KEY  (NOT EQUAL COND)
         SPACE 1
KBEQCHK  NOP   KBEQREST  SET TO BRANCH AFTER FIRST TIME THRU
         MVI   KBEQCHK+1,SETBR   DONE ON FIRST REC PROCESSED BY K OPT
         CP    BEGIN,PACKZERO  IS B=0 CODED OR DEFAULTED
         BNE   KNEWGRP   NO B>0-SKIP TILL NEW GRP IS REACHED LOGIC
KBEQREST MVI   FWRITE+1,SETNOP YES-DOES NOTHING IF B=0;B>0 RESETS WRITE
         CP    TOTLKEYS,COUNT     IS NUMBER OF GROUPS = TO PARM COUNT
         BE    ENDINPUT           YES- BRANCH TO END OF FILE PROCESSING
         B     FKEYNL             NO
         SPACE 1
FCOMPARE CP    COMPCNT,COUNT      WAS COUNT SATISFIED
         BNL   FKEYNL             BRANCH AROUND INCREMENT IF YES
         AP    KEYLESS,PACKONE    INCREMENT
FKEYNL   EQU   *
         BAL   GOREG,PUTFILE
         AP    TOTLKEYS,PACKONE   ADD 1 TO TOTAL KEY COUNT
         ZAP   COMPCNT,PACKONE    ZERO & ADD 1 TO KEY COUNT
         MVI   FKEYMORE+1,SETNOP  RESET TO NO-OP WHEN NEW KEY
         B     GETINPUT
         SPACE 1
FEQUALKY EQU   *                  THE KEY ON PRIOR REC IS THE SAME
*   AS ON THIS RECORD. CHECK TO SEE IF THE COUNT FOR
*   A KEY HAS BEEN REACHED. IF COUNT HAS NOT BEEN
*   REACHED WRITE OUT REC OTHERWISE BYPASS THE REC
*   AND ADD 1 TO KEYMORE(COUNT OF RECS FOR KEY  EXCEEDED).
*   BRANCH AROUND FUTURE ADDS FOR THIS KEY AND GET RECORD.
KEQUAL   NOP   FWRITE              CHANGED TO BRANCH ON K OPTION
         CP    COMPCNT,COUNT
         BNL   FKEYMORE            COUNT FOR THIS KEY HAS BEEN REACHED
FWRITE   NOP   BRPTOUT2  CHG TO BR WHEN B>0 CODED ON K OPTION
*        TO GET PAST FIRST GRP UNTIL 1ST NONEQUAL THEN CHG BACK TO NOP
         BAL   GOREG,PUTFILE       COUNT NOT REACHED,WRITE RECORD
         AP    COMPCNT,PACKONE     ADD 1 TO COUNT FOR KEY
         B     GETINPUT
         SPACE 1
FKEYMORE NOP   BRPTOUT2   CHANGED TO BRANCH WHEN RECS EXCEED PARM COUNT
         AP    KEYMORE,PACKONE
         MVI   FKEYMORE+1,SETBR  DONE ONLY ONCE(FOR EACH KEY)
         B     BRPTOUT2
         SPACE 2
BR2PRTF  CP    COMPCNT,PACKZERO  DONT PRINT FREQ BEFORE 1ST KEY KICKED
         BE    FMOVE
FREQMOVE MVC   MSG21KEY,INCARD       MOVE IN KEY-LENGTH ADJUSTED
         ED    MSG21ED,COMPCNT+3     GET FREQ CNT
         B     OMSG                 PRINT MSG
         SPACE 2
KNEWGRP  MVI   FWRITE+1,SETBR SET TO BRANCH AROUND WRITE UNTIL A NEW
         B     BRPTOUT2   GRP IS FOUND, I.E. WHEN KEY BECOMES UNEQUAL
         TITLE 'L SUBOPTION PROCESSING-KEY LENGTH UP TO LRECL'
COMPLKYV L     R0,PUTADDR    GET ADDR OF INPUT RECORD
         MVC   DCBADDR2,DCBADDR  MOVE INPUT DCB TO DCBADDR2 FOR RECFM=U
SYSUTVAR NOP   SYSUTLEN      SET TO B ON VARIABLE SYSUT1 RECS
         A     R0,POSLENS+4    ADD POSITION DISPLACEMENT TO ADDR
         ST    R0,LKEYADDR     STORE KEY ADDR FOR CONVERT
SETSYSIN L     R2,CARDADDR     GET ADDR OF SYSIN RECORD
         MVC   DCBADDR2,ASYSIN   MOVE SYSIN DCB TO DCBADDR2 FOR RECFM=U
SYSINVAR NOP   SYSINLEN      SET TO B ON VARIABLE SYSIN RECS ON A,M
         A     R2,VPOSLENS     ADD POSITION DISPL TO ADDR
         ST    R2,LKEYADR2    STORE KEY ADDR FOR CONVERT
SETLENG  LA    R1,1(R4)        PUT LENGTH OF KEY IN R1 AND R3
         LR    R3,R1
         CLCL  R0,R2        COMPARE LONG THE 2 KEYS
CNVRTNOP B     ENTRYPT   RETURN TO MAIN ROUTINE, SET TO NOP FOR CNVRT
         SPACE 1
         L     R15,=A(CNVRTABL)  GET CONVERT TABLE ADDR
         L     R14,LKEYADDR      GET SYSUT1 KEY
V1SET1   TR    0(0,R14),0(R15) CONVERT IT, LENG SET-DYNAMIC IF RECFM=V
         L     R14,LKEYADR2      GET SYSIN KEY
V1SET2   TR    0(0,R14),0(R15) CONVERT IT, LENG SET-DYNAMIC IF RECFM=V
         B     ENTRYPT
         SPACE 2
SYSUTLEN LR    R1,R0           LOAD REC ADDR INTO R1
         L     R3,POSLENS+4    LOAD POSITION INTO R3
         AR    R0,R3           POINT TO KEY
         ST    R0,LKEYADDR     STORE KEY ADDR FOR CONVERT
         MVC   SAVEVARL(4),SAVER4  RESTORE SAVEVARL
         BAL   GOREG,COMPRDW   IS L+P MORE THAN RDW
FKQNOP1  BNH   SETSYSIN   NO. SET TO NOP ON F,K,Q WITH L SUBOPT, V RECS
FKQBNH   NOP   FKQRETV1   SET TO BNH ON F,K,Q WITH L SUBOPT, V RECS
         LH    R4,0(0,R1)      YES-MOVE RDW TO R4
         S     R4,POSLENS+4    SUBTRACT POSITION OF KEY FROM R4
         BCTR  R4,0            SET R4=LENGTH-1
         ST    R4,SAVEVARL     SAVE REVISED KEY LENGTH
         STC   R4,V1SET1+1     SET TRUNCATED CONVERT LENGTH FOR SYSUT1
         STC   R4,V1SET2+1     SET TRUNCATED CONVERT LENGTH FOR SYSIN
         STC   R4,SETLTR1+1    SET TRUNCATED CONVERT LENGTH FOR FKQL
FKQNOP2  B     SETSYSIN  RETURN FOR COMPARE;SET TO NOP ON FKQL RECFM=V
         SPACE 3
         LR    R1,R4     PLACE KEY LENGTH IN R1
FKQBR1   B     FKQRETV2  RETURN FOR MVCL TO FKQL LOGIC ON RECFM=V
         SPACE 2
SYSINLEN LR    R1,R2           SEE SYSUTLEN COMMENTS
         L     R3,VPOSLENS
         AR    R2,R3
         ST    R2,LKEYADR2     STORE KEY ADDR FOR CONVERT
         BAL   GOREG,COMPRDW
         BNH   SETLENG
         LH    R4,0(0,R1)
         S     R4,VPOSLENS
         BCTR  R4,0
         STC   R4,V1SET1+1     SET TRUNCATED CONVERT LENGTH FOR SYSUT1
         STC   R4,V1SET2+1     SET TRUNCATED CONVERT LENGTH FOR SYSIN
         C     R4,SAVEVARL     IS R4= TO REVISED LENGTH
         BE    SETLENG          YES
SETQBNE  CLI   FULL1+3,X'00'   NO-SET COND CODE TO BNE;SET TO BL ON QNL
*        THE FOLLOWING SITUATIONS ON THE Q LOGIC WILL BE CONSIDERED
*        AS BEING IN-SEQUENCE CONDITIONS:
*        1- A SHORT REC WHOSE RDW IS LESS THAN THE P(POSITION) OF THE
*           KEY FIELD WILL BE CONSIDERED IN-SEQ.
*        2- A SHORT REC WHOSE RDW IS LESS THAN L+P OF THE KEY FIELD
*           BUT THE PORTION OF THE KEY THAT APPEARS IN THE SHORT REC
*           IS EQUAL OR GREATER (LESS,IF N SUBOPTION USED)
*           TO THE SAME PORTION OF THE KEY IN THE PREVIOUS REC.
*        FOR THE F AN K OPTION - SITUATION 1 ABOVE IS CONSIDERED AN
*           UNEQUAL KEY WHILE SITUATION 2 (WHEN THE TRUNCATED KEY
*           FIELDS ARE EQUAL) ARE CONSIDERED EQUAL KEYS SINCE THE
*           COMPARE (CLCL) IN PARAG LKETSET2 USES THE ADJUSTED LENGTH
*           IN R4 AS SET IN PARAGRAPH SYSUTLEN.
FKQNOP3  B     ENTRYPT  BR TO GET A NEW REC;SET TO NOP ON FKQL RECFM=V
         SPACE 1
FKQBR2   B     SEQCHK   BRANCH TO POST-COMPARE LOGIC IN FKQ
         SPACE 2
COMPRDW  B     COMPRDWV   SET TO NOP IF RECFM=U
         L     R1,DCBADDR2  GET DCB ADDR OF SYSUT1 OR SYSIN
         LA    R1,LRECL(R1) LOAD R1 WITH LRECL ADDR (ACTUAL BLOCK LEN)
         SPACE 2
COMPRDWV CH    R3,0(0,R1)      COMPARE POSITION OF KEY TO RDW
         BH    SETQBNE       POSITION IS GREATER-SET CC TO BNE
         L     R4,SAVER4       RELOAD ORIGINAL KEY LENGTH IN R4
         STC   R4,V1SET1+1     SET CONVERT LENGTH FOR SYSUT1
         STC   R4,V1SET2+1     SET CONVERT LENGTH FOR SYSIN
         STC   R4,SETLTR1+1    SET CONVERT LENGTH FOR FKQL RECFM=V
         AR    R3,R4         R3=L+P
         LA    R3,1(R3)
         CH    R3,0(0,R1)     IS L+P GREATER THAN RDW
         BR    GOREG
         TITLE 'L SUBOPTION PROCESSING-UP TO 3 L,P PAIRS'
COMPLKEY NOP   COMPLKYV           SET TO BRANCH IF VARIABLE RECS
         CP    ENDCT,SAVECNT   ENDCT=#OF PRIMARY INPUT RECS READ
         BE    LKEYSET   BRANCH IF WE HAVE NOT READ ANY ADDITIONAL RECS
         ZAP   SAVECNT,ENDCT   SAVE THE # OF PRIMARY INPUT RECS READ
         L     R0,PUTADDR       PUT ADDR OF INPUT RECORD IN R0
         A     R0,POSLENS+4     ADD P1 (OF L,P PAIR) TO ADDR
         ST    R0,LKEYADDR   SAVE KEY ADDR FOR CONVERT
FKQRETV1 L     R1,POSLENS       SET R1=L1-1;RETURN ON FKQL RECFM=V
FKQRETV2 LA    R1,1(R1)         SET R1=L1;RETURN ON FKQL RECFM=V,R1 ADJ
         LR    R3,R1            SET R3=L1
         LR    R5,R1            SET R5=L1
         L     R2,LKEYARE1      PUT ADDR OF KEY AREA IN R2
         MVCL  R2,R0            MOVE FIRST KEY TO KEY AREA
*        AFTER EXECUTION OF THE MVCL INSTRUCTION R1=R3=0 AND
*        R2=ADDR OF KEY AREA+L1, R0=ADDR OF INPUT REC+P1+L1
         SPACE 2
CNVRTBL1 B     BRL1    SET TO NOP ON CONVERT
         L     R15,=A(CNVRTABL)   GET CONVERT TABLE
         L     R14,LKEYADDR       GET FIRST KEY
SETLTR1  TR    0(0,R14),0(R15) CONVERT, LENGTH SET(DYNAMIC ON RECFM=V)
         SPACE 2
BRL1     B     LKEYSET          SET TO NOP IF 2 L,P'S
         SR    R0,R5        RESET R0=ADDR OF INPUT RECORD + P1
         A     R0,POSDISPS      SET R0=ADDR OF INPUT AREA+P2
         ST    R0,LKEYADDR   SAVE KEY ADDR FOR CONVERT
         L     R1,POSLENS+8     SET R1=L2-1
         LA    R1,1(R1)         SET R1=L2
         LR    R3,R1            SET R3=L2
         LR    R5,R1            SET R5=L2
         MVCL  R2,R0        MOVE SECOND KEY TO KEY AREA
         SPACE 2
CNVRTBL2 B     BRL2    SET TO NOP ON CONVERT
         L     R14,LKEYADDR       GET FIRST KEY
SETLTR2  TR    0(0,R14),0(R15)      CONVERT, LENGTH SET
         SPACE 2
BRL2     B     LKEYSET            SET TO NOP IF 3 L,P'S
         SR    R0,R5           SET R2=ADDR OF INPUT RECORD + P2
         A     R0,POSDISPS+4   SET R0=ADDR OF INPUT AREA+P3
         ST    R0,LKEYADDR   SAVE KEY FOR CONVERT
         L     R1,POSLENS+16   SET R1=L3-1
         LA    R1,1(R1)        SET R1=L3
         LR    R3,R1           SET R3=L3
         MVCL  R2,R0        MOVE THIRD KEY TO KEY AREA
         SPACE 2
CNVRTBL3 B     LKEYSET SET TO NOP ON CONVERT
         L     R14,LKEYADDR       GET FIRST KEY
SETLTR3  TR    0(0,R14),0(R15)      CONVERT, LENGTH SET
         SPACE 2
LKEYSET  NOP   FKQLPRC1 SET TO B ON FL,QL,KL OPTION, 1ST TIME THRU ONLY
LKEYSETA NOP   LKEYSET2     SET TO B ON FL,QL,KL OPTION AFTER 1ST TIME
*        HAS A NEW SYSIN RECORD BEEN READ, IF NOT BYPASS MOVE SYSIN KEY
         CP    RCOUNT,SAVRCNT  COMPARE NUMBER OF SYSIN RECORDS READ
         BE    LKEYSET2        IF EQUAL TO NUMBER SAVED, NO NEW SYSIN
         ZAP   SAVRCNT,RCOUNT  ELSE IT IS NEW SYSIN
         L     R0,CARDADDR    SAME PROCESS FOR SYSIN KEY
         A     R0,VPOSLENS
         ST    R0,LKEYADDR
         L     R1,VLEN123
         LA    R1,1(R1)
         LR    R3,R1
         LR    R5,R1
         L     R2,LKEYARE2
         MVCL  R2,R0
         SPACE 2
CNVRTVL1 B     VBRL1   SET TO NOP ON CONVERT
         L     R14,LKEYADDR       GET FIRST KEY
VSETLTR1 TR    0(0,R14),0(R15)      CONVERT, LENGTH SET
         SPACE 2
VBRL1    B     LKEYSET2
         SR    R0,R5
         A     R0,VPOSDISP
         ST    R0,LKEYADDR
         L     R1,VLEN123+4
         LA    R1,1(R1)
         LR    R3,R1
         LR    R5,R1
         MVCL  R2,R0
         SPACE 2
CNVRTVL2 B     VBRL2   SET TO NOP ON CONVERT
         L     R14,LKEYADDR       GET FIRST KEY
VSETLTR2 TR    0(0,R14),0(R15)      CONVERT, LENGTH SET
         SPACE 2
VBRL2    B     LKEYSET2
         SR    R0,R5
         A     R0,VPOSDISP+4
         ST    R0,LKEYADDR
         L     R1,VLEN123+8
         LA    R1,1(R1)
         LR    R3,R1
         MVCL  R2,R0
         SPACE 2
CNVRTVL3 B     LKEYSET2  SET NOP ON CONVERT
         L     R14,LKEYADDR       GET FIRST KEY
VSETLTR3 TR    0(0,R14),0(R15)      CONVERT, LENGTH SET
         SPACE 1
LKEYSET2 L     R0,LKEYARE1    LOAD ADDR OF PRIMARY KEY AREA
         L     R2,LKEYARE2       INTO R0 AND SYSIN KEY AREA INTO R2
         LA    R1,1(R4)     SET R1=L1+L2+L3
         LR    R3,R1        SET R3=R1
         CLCL  R0,R2     COMPARE PRIMARY AND SYSIN KEY AREAS
LKEYSETB NOP   SEQCHK    SET TO B ON FL,KL,QL OPTIONS
         B     ENTRYPT
         TITLE 'F,K,Q SETUP LOGIC FOR LONG SUBOPTION'
COMPLKY2 NOP   COMPLKEY            SET TO BRANCH AFTER 1ST TIME THRU
         MVI   COMPLKY2+1,SETBR
         MVI   FKQNOP1+1,SETNOP SET NOPS AND BRANCHES FOR RECFM=V LOGIC
         MVI   FKQNOP2+1,SETNOP
         MVI   FKQNOP3+1,SETNOP
         MVI   FKQBNH+1,X'D0' SET BNH FOR RECFM=V LOGIC
         MVI   LKEYSET+1,SETBR  SET RETURN AFTER CONSTRUCTING KEY
         B     COMPLKEY
FKQLPRC1 MVI   LKEYSET+1,SETNOP NOP THE RETURN BACK HERE
         MVI   LKEYSETA+1,SETBR SET BRANCH TO COMP CURR KEY TO PREV KEY
         MVI   LKEYSETB+1,SETBR SET B TO RETURN TO SEQCHK AFTER COMPARE
         MVC   FKQLMOVE(2),SETBAL         SET UP BAL TO MVCL
QNLBL    CLI   FULL1+3,X'00' SET CC TO BH, CHANGED TO BL ON N SUBOPTION
         B     SEQCHK
         SPACE 2
MVCL     L     R2,LKEYARE1
         L     R0,LKEYARE2
         LA    R1,1(R4)
         LR    R3,R1
         MVCL  R0,R2      MOVE CURRENT KEY TO PREVIOUS KEY
         BR    GOREG
         TITLE 'SEQUENCE CHECKING OUTPUT LOGIC (Q) PROCESSING'
QWRITE   BAL   GOREG,PUTFILE
         B     NOOPONQ    GO BACK TO MAINLINE
SEQMSG2  NOP   QRESTMSG
         LNKMSG 22                   FIRST OUT OF SEQUENCE MSG
         MVI   SEQMSG2+1,SETBR THIS PAR EXECUTED ONLY ONCE ON SEQERROR
         MVI   KEYMSG,C'9'     SET FLAG THAT FILE IS OUT OF SEQ
         CP    TOTLKEYS,COUNT  IS 200 GREATER THAN USER PARM COUNT
         BH    QRESTMSG        YES- USER ENTERED COUNT IS USED
         ZAP   COUNT,TOTLKEYS    SET COUNT TO 200
QRESTMSG NOP   BRPTOUT2          CHANGED TO  B ON QB KEY
         CP    COMPCNTA,COUNT    DO NUMBER OF SEQ ERRORS EXCEED COUNT
         BNE   QCONTINU
         MVI   QRESTMSG+1,SETBR  THIS PAR BRANCHED AROUND WHEN CNT SAT
         LNKMSG 14,EDIT=COUNT+3,BRANCH=BRPTOUT2
QCONTINU AP    COMPCNTA,PACKONE   ADD 1 TO NUMBER OF SEQUENCE ERRORS
         MVC   MSG23ED,MSGMASK       RESET THE EDIT MASK
         ED    MSG23ED,PASSCT+3   RECORD NUMBER OUT OF SEQ
QBRONL   NOP   QLROUT             CHANGED TO B ON L SUBOPTION
CURRKEY  MVC   MSG23CKY,KEYAREA       CURRENT KEY OUT OF SEQ
PREVKEY  MVC   MSG23PKY,INCARD        PREVIOUS KEY OUT OF SEQ
PUTQMSG  MESSAGE 23,BRANCH=BRPTOUT2
         SPACE 2
QLROUT   MVC   MSG23CKY-6(6),MSGSPACE
         MVC   MSG23PKY-14(14),MSGSPACE
         MVI   QRESTMSG+1,SETBR
         B     PUTQMSG
         TITLE 'OR AND RANGE (O,ON,B,C) LOGIC PROCESSING'
OLOGIC1  EQU   *
BLOGCLC1 CLC   0(0,R3),INCARD
ENTRYPT2 EQU   *
ONKEYEQ1 NOP   BRPTOUT2   CHANGED TO BE ON 'ON' KEY & BL ON B KEY
CKEYNE   NOP   BLOGCLC5   CHANGED TO BNE ON 'C' KEY
BKEYNOP1 BE    OLOGMTCA   NOOPED ON B KEY,CHANGED TO BL ON 'BN' KEY
BLOGCLC2 B     OLOGEXIT           NOOPED IF MORE THAN 1 KEY
BLOGCLC3 CLC   0(0,R3),INCARD1
ONKEYEQ2 NOP   BRPTOUT2   CHANGED TO BE ON 'ON',BNE ON 'C',BE ON 'CN'
BKEYBNH  BE    OLOGMTCB   CHANGED TO BNH ON B,NOP ON 'BN',BNE ON 'CN'
BKEYBH   NOP   NEXTBKEY   CHANGED TO B ON 'B' KEY,BH ON 'BN' KEY
BLOGCLC4 B     OLOGEXIT           NOOPED IF MORE 3 KEYS
BLOGCLC5 CLC   0(0,R3),INCARD2
ONKEYEQ3 NOP   BRPTOUT2   CHANGED TO BE ON 'ON',BNE ON 'C',BE ON 'CN'
CKEYNE2  BE    OLOGMTCC   CHANGED TO BNE ON 'CN'
OLOGEXIT EQU   *
ONSELECT NOP   OLOGMTCH   CHANGED TO B ON 'ON' KEY
         B     BRPTOUT2
OLOGMTCH EQU   *
         CP    OUTCT,COUNT     IS COUNT ON BN KEY SATISFIED
BNKEYBR  NOP   BRPTOUT2   CHANGED TO BE ON 'BN' KEY
         BAL   GOREG,PUTFILE
         CP    OUTCT,COUNT
OLOGEND  BE    ENDINPUT      NOOPED ON B KEY
BCNTSAT  NOP   LASTBKEY   CHANGED TO BE ON B ONLY(WHEN CNT SATISFIED)
         B     GETINPUT
OLOGMTCA AP    COMPCNTA,PACKONE
CKEYEQ   NOP   BLOGCLC3      CHANGED TO BRANCH ON 'C' KEY
         B     OLOGMTCH
OLOGMTCB AP    COMPCNTB,PACKONE
         B     OLOGMTCH
OLOGMTCC AP    COMPCNTC,PACKONE
         B     OLOGMTCH
NEXTBKEY EQU   *
         SP    PASSCT,PACKONE     SUBTRACT 1 FROM FROM RECORDS PASSED
LASTBKEY MVC   MSG29PAS,MSGMASK        RESET MASK
         MVC   MSG29OUT,MSGMASK
         ED    MSG29PAS,PASSCT+3   EDIT THE COUNTS
         ED    MSG29OUT,OUTCT+3    EDIT THE LAST 5 BYTES (9 DIGITS)
         MESSAGE 29                   PUT OUT B MESSAGE
ENDBKEY  NOP   EOJ                 CHANGED TO B WHEN LAST KEY=HIGHVALUE
         ZAP   PASSCT,PACKONE      REINITIALIZE THE COUNTS
         MVI   BBRANCH+1,SETBR  SET B TO BYP GETINPUT AFTER READING KEY
BNGOREAD NOP   GOREAD           CHANGED TO B ON 'BN' KEY
ENDBNOP  B     BTEST            NOOPED AT END OF INFILE
         B     ENDFILE
*
BTEST    EQU   *
         CP    OUTCT,COUNT   WAS COUNT SATISFIED
         BNE   GOREAD         NO-READ 2 MORE KEYS AND SKIP GETINPUT
         ZAP   PASSCT,PACKZERO  YES-MOVE PASSCT BACK TO ZERO
         MVI   BBRANCH+1,SETNOP NOP THE BRANCH WHICH SKIPS GETINPUT
GOREAD   ZAP   OUTCT,PACKZERO   REINITIALIZE OUTCT
         B     BKEYREAD         GO TO READ 2 NEW KEYS
         TITLE 'DEBUG LOGIC (D) PROCESSING'
DWRITE   EQU   *             DEBUG OPTION PROCESSING
         SP    DCOUNT,PACKONE   DEFAULT DCOUNT=1, CHANGED BY X0 DOPTION
         BNZ   GETINPUT       KEEP READING UNTIL NTH OCCURRENCE OF KEY
         MVI   KEYMSG,C'8'   FLAG TO INDICATE KEY WAS FOUND ON D OPTION
         NI    COUNT,X'4F' ZERO OUT TOP 1/2-BYTE OF COUNT ON DFLT
         MVI   DBPUTOUT+1,SETBR   SET BRANCH TO RETURN TO D LOGIC
         MVI   SETBEQBR+1,SETNOP  PUT REJECTS OUT TO SYSUT3
DKEYMSG  MVC   MSG34KEY,INCARD        MOVE KEY TO MESSAGE
         CLI   ENDINF+1,SETNOP    IS 'KEY=' MSG TO BE SUPPRESSED
         BNE   DKEYMSG2           NO
         MVC   MSG34KEY,MSGSPACE  BLANK OUT KEY IN MESSAGE
         MVC   MSG34+12(3),=C' IS' YES
DKEYMSG2 ED    MSG34LOC,PASSCT+3   LOCATION OF RECORD WITH DESIRED KEY
         AP    COMPCNT,PACKONE  ADD 1 TO NO OF RECS TO BE OUTPUT
DMINSNOP AP    COMPCNT,COUNT   ADD PARM COUNT TO NO OF RECS TO BE OUTPT
*        THE ABOVE AP IS CHANGED TO CP WHEN J=-
         CP    COUNT,PASSCT    IS COUNT PARM LESS THAN RECORDS PASSED
DPLUSBR  BL    SUBCNT       YES-CHANGED TO B WHEN J=+
         SP    PASSCT,PACKONE  NO- SUBTRACT 1 FROM PASSCT
         ZAP   COUNT,PASSCT    MOVE NO OF RECORDS PASSED TO PARM COUNT
         ZAP   RBEGIN,PACKONE  BEGIN OUTPUTING FROM RECORD 1
         B     ADDCNT
SUBCNT   SP    PASSCT,COUNT  SUBTRACT THE PARM COUNT FROM PASSCT
*        THE ABOVE SP IS CHANGED TO CP WHEN J=+
         ZAP   RBEGIN,PASSCT    BEGIN OUTPUTTING RECORDS FROM PASSCT
ADDCNT   AP    COMPCNT,COUNT     ADD THE MODIFIED PARM COUNT TO COMPCNT
*        THE ABOVE AP IS CHANGED TO CP WHEN J=+
         ED    MSG34BEG,RBEGIN+3  MOVE THE BEGINNING TO MESSAGE
DOPTIMIZ NOP   DPUTREC  CHANGED TO BRANCH FOR X0 DOPTION=OPTIMIZE
         SP    RBEGIN,PACKONE     BYPASS RBEGIN-1 RECORDS
         ZAP   BEGIN,RBEGIN
         ZAP   ENDCT,PACKZERO
         L     R2,DCBADDR      LOAD ADDR OF ISAM/INFIL INTO R2
         L     R15,=A(DCBCSECT) CLOSE INPT FILE-REPOSITION TO FRONT
         BALR  GOREG,R15    FREE BUFFER POOL FOR INPUT DCB
         CLI   OPENBACK,C'W'    IS READ BACKWARD OPTION REQUESTED
         BNE   OPENFOW                NO
         OPEN  ((R2),RDBACK)        YES-REOPEN BACKWARDS
         B     GETINPUT               UNTIL
OPENFOW  BAL   GOREG,OPENINP  REOPEN INPUT AND BEGIN PROCESSING
         B     GETINPUT               UNTIL
DPUTREC  BAL   GOREG,PUTFILE    SPECIFIED NUMBER OF RECORDS TO BE
         L     R1,DCBADDR       GET THE DCB ADDR
         GET   (R1)               READ AND WRITE RECORDS UNTIL THE
         ST    R1,PUTADDR         SAVE ADDR OF INPUT REC AREA
         AP    ENDCT,PACKONE    KEEP COUNT FOR PRINTING
         SP    COMPCNT,PACKONE
         CP    COMPCNT,PACKZERO
         BNE   DPUTREC
         EX    0,KCNTSAT
DMSGOUT  ED    MSG34OUT,OUTCT+3   MOVE NO OF RECORDS OUTPUT TO MSG
         MESSAGE 34,BRANCH=ENDFILE     PUT OUT MSG
         TITLE 'RANDOM LOGIC (R) PROCESSING'
RLOGIC1  NOP   RCOMMON         CHANGED TO BRANCH AFTER ENTERED 1ST TIME
         MVI   RLOGIC1+1,SETBR
         L     R5,POSLENS(R6) LOAD R5 WITH BEGIN POSIT FROM POSLENS
         C     R5,HIGHV        IS R5 =HIGH VALUES-END OF POSLENS
         BE    ENDINPUT        END
         LA    R5,1(R5)        ADD 1 BACK TO BEGIN POS
         CVD   R5,RBEGIN       PACK THE BEGIN COUNT
         L     R5,POSLENS+4(R6) LOAD R5 WITH SKIP FACTOR FROM POSLENS
         CP    RBEGIN,PASSCT   IS RBEGIN NOT LESS THAN PASSCT
         BNL   RBEGINOK        YES
         ZAP   RBEGIN,PASSCT   NO-REPLACE RBEGIN WITH PASSCT
RBEGINOK LA    R5,1(R5)
         CVD   R5,RSKIP        PACK THE SKIP FACTOR
         ZAP   COMPCNT,PACKZERO REINITIALIZE THE PARM COUNTER
         AP    RCOUNT,COUNT    RCOUNT IS USED IN RMSG ROUTINE
RCOMMON  CP    PASSCT,RBEGIN   HAVE WE REACHED THE BEGINNING POSIT
         BL    BRPTOUT2        NO-GO TO GETINPUT
         AP    SKIPCT,PACKONE  ADD 1 TO THE SKIP COUNTER
         CP    SKIPCT,RSKIP    IS THE SKIP FACTOR SATISFIED
RNEGAT   NOP   RNEGAT1         CHANGED TO BRANCH ON RN
         BNE   BRPTOUT2        NO
         ZAP   SKIPCT,PACKZERO REINITIALIZE THE SKIP COUNTER
RPUTOUT  BAL   GOREG,PUTFILE
         AP    COMPCNT,PACKONE  ADD 1 TO OUTPUT FOR L,P PAIR
         CP    COMPCNT,COUNT   IS THE COUNT SATISFIED
         BL    GETINPUT
RMSGOUT  ZAP   SKIPCT,PACKZERO REINIT THE SKP CNTER(NEEDED FOR RN ONLY)
         MVC   MSG26OUT,MSG23ED      RESET MASKS
         MVC   MSG26BEG,MSG23ED   (CANNOT USE MSGMASK BECAUSE IT IS
         MVC   MSG26SKP,MSG23ED    KILLED ON THE NEGATIVE OPTION)
         ED    MSG26OUT,COMPCNT+3  RECORDS OUTPUT FOR NTH L,P PAIR
         ED    MSG26BEG,RBEGIN+3   REC NUMBER OUTPUT BEGAN ON
         ED    MSG26SKP,RSKIP+3    SKIP FACTOR
         MESSAGE 26
RENDBR   NOP   ENDINF     CHANGED TO B WHEN FILE END BEFORE CNT SATISF
         LA    R6,8(R6)   SET INDEX (R6) UP BY 8 TO POINT TO NEXT FLD
         C     R6,=F'16'  IS THIS THE LAST POSLENS FLD
         BH    ENDINPUT   YES
         MVI   RLOGIC1+1,SETNOP NO
         B     GETINPUT
         SPACE 3
RNEGAT1  BNE   RPUTOUT          SKIP EVERY NTH RECORD AND PUT OUT ALL
         ZAP   SKIPCT,PACKZERO       THE REST FOR R NEGATIVE
         B     BRPTOUT2         GET A NEW RECORD
         TITLE 'RANDOM LOGIC (R) PROCESSING-ONLY 1 PARM FIELD'
REXTLOG1 NOP   RCOMPARE     SET BRANCH AFTER 1ST TIME THRU
         MVI   REXTLOG1+1,SETBR
         BAL   GOREG,GETCARD        GET A SYSIN RECORD
RANDOMKY NOP   NOTRANDM      SET TO BRANCH AFTER 1ST TIME THRU
         MVI   RANDOMKY+1,SETBR
         CLC   INCARD(6),=C'RANDOM' IS RANDOM OPT REQUESTED
         BE    RANDOM                     YES
         MVI   SETBRONV+1,SETBR    NO- SET BR TO IGNORE E= PARM
         LNKMSG 60                 WRITE R HEADING
NOTRANDM MVC   MSG62KEY,INCARD     MOVE SYSIN VALUE TO PRINT AREA
         L     R15,=A(TRNSTAB2)
         TRT   INCARD(16),0(R15)      CHECK IF SYSIN REC IS NUMERIC
         BZ    RERROR           SYSIN RECORD EXCEEDS 15 NUMERIC DIGITS
         CLI   0(R1),BLANK1   IS NUMBER ON SYSIN REC FOLLOWED BY SPACE
         BNE   RERROR          NO-ERROR
         SR    R1,R9     R1=ADDR OF 1ST SPACE FOLLOWING NUMBER,
*              R9=ADDR OF INCARD. R1 NOW HAS LENGTH OF SYSIN NUMBER
         BZ    RERROR         NO
         BCTR  R1,0     YES-SUBTRACT TO ADJUST LENGTH FOR PACK INSTR
         EX    R1,HEXPACK PK INCARD INTO WORKFLD1(PACK WORKFLD1,INCARD)
         CP    WORKFLD1,PASSCT   ARE SYSIN RECORDS IN SEQUENCE
         BL    RERROR              NO
         SP    WORKFLD1,PASSCT     YES-SUBTRACT TO GET SKIP FACTOR
RCOMPARE CP    WORKFLD1,PACKZERO     WHEN WORKFLD1=0 PUT PUT OUT REC
         BE    RPUT
         SP    WORKFLD1,PACKONE      SUBTRACT 1 FROM WORKFLD1
         B     BRPTOUT2          AND GET A NEW RECORD
RPUT     BAL   GOREG,PUTFILE
         MVC   MSG62MSG,=C'RECORD OUTPUT'
         MESSAGE 62
RPUTLAST NOP   ENDINF       SET TO BR TO EOF AFTER 'LAST' OUTPUT
         MVC   MSG62MSG,MSGSPACE
         MVC   MSG62MSG(5),=C'ERROR' MVE 'ERROR' TO MSG
         MVI   REXTLOG1+1,SETNOP
         B     GETINPUT         GET A NEW SYSIN RECORD
         SPACE 3
RERROR   CLC   INCARD(5),=C'LAST '   IS 'LAST' REC REQUESTED
         BE    RLAST                 YES
         MVI   REXTLOG1+1,SETNOP     NO - ERROR
         MESSAGE  62,BRANCH=REXTLOG1  PUT OUT ERR MSG AND GET NEW SYSIN
         SPACE 2
RLAST    ZAP   WORKFLD1,=P'999999999999999'   SET REC NO.= HIGH
         MVI   REXTMSG+1,SETBR  SET BR TO PUTOUT 'LAST' RECORD
         MVI   RPUTLAST+1,SETBR SET BR TO GO TO EOF AFTER 'LAST' MSG
****     SP    OUTCT2,PACKONE SUBT 1 FROM REJCT CNT WHICH INCLUDED LAST
         B     RCOMPARE         FINISH INPUT FILE TO EOF
         TITLE 'RANDOM OPTION'
RANDOM   EQU   *
         MVI   RANDMOPT+1,SETBR  SET BR FOR RANDOM PROCESSING AFTER GET
RNDMCNVT CLI   INCARD+6,C'='           IS USER SUPPLYING SEED
         BNE   DFLTSEED           NO- USE DEFAULT SEED OF 8193
         CLC   INCARD+7(6),=C'PICKIT' DOES USER WANT A RANDOM SEED
         BE    PICKIT                 YES
         MVI   INCARD+15,BLANK1   NO-LIMIT SEED TO 8 DIGITS
         L     R15,=A(TRNSTAB2)        GET NUMERIC TABLE
         TRT   INCARD+7(9),0(R15)    FIND WHERE SEED ENDS
         LA    R9,7(R9)     R9=A(INCARD), R9 NOW POINTS TO SEED
         SR    R1,R9            GET LENGTH OF SEED
         BZ    DFLTSEED        IF LENGTH=0 USE DEFAULT SEED
         BCTR  R1,0        SUBTRACT 1 FROM LENGTH TO SET UP FOR PACK
         EX    R1,SEEDPACK         PACK SEED INTO WORKFLD1
         CVB   R9,WORKFLD1    AND CONVERT SEED TO BINARY
MAKEODD  O     R9,FULL1        INSURE SEED IS ODD
         ST    R9,SEED
DFLTSEED L     R9,SEED          GET SEED
         CVD   R9,WORKFLD1   AND CONVERT IT TO DECIMAL FOR PRINT MSG
         LNKMSG 57,EDIT=WORKFLD1+3     WRITE MESSAGE
         CP    END,=P'1073741823' INSURE HIGH RANGE LESS THAN 2**30-1
         BL    ENDOK
         ZAP   END,=P'1073741823'
ENDOK    CP    COUNT,MAXRNDM  INSURE NO OF RNDM NUMBS IS IN TABLE <MAX
         BL    COUNTOK
         ZAP   COUNT,MAXRNDM
COUNTOK  CVB   R3,BEGIN    YES-PUT (B= +1) R3 TO ADD TO EACH RNDM NO
         LA    R3,1(R3)    DONT CHANGE R3 UNTIL AFTER RANDM NOS GENER
         CVB   R9,END          LOWER HIGH RANGE BY (B= +1)
         SR    R9,R3
         BM    BEGINNG      BEGIN EXCEEDS END-NO GOOD
         AR    R9,R9        MULTIPLY HIGH RANGE BY 2 AND
         ST    R9,ENDBIN      STORE 2N IN ENDBIN
         CVB   R2,COUNT     MULTIPLY COUNT (NUMBER OF ENTRIES IN TABLE)
         SLL   R2,2           BY 4 TO GET LENGTH OF TABLE
         LR    R0,R2         AND PUT LENGTH IN R0 FOR THE GETMAIN
         STCM  R0,7,FREELEN+1 SAVE GETMAIN LENGTH FOR FREEMAIN
         GETMAIN R,LV=(0)      GRAB STORAGE FOR TABLE
         ST    R1,TABLE        AND PUT TABLE ADDR IN 'TABLE'
         LA    R9,4           PUT 4 IN R9
         LNR   R9,R9          SET R9=-4
         AR    R2,R9          SUBTRACT 4 FROM TABLE LENGTH
         LA    R5,0(R2,R1)    COMPUTE ADDR OF LAST ELMT IN TABLE
         ST    R5,TABLEND      AND STORE ADDR IN TABLE
LOOPRNDM L     R5,ENDBIN    PUT 2*(HIGH RANGE) (2*N) IN R5
         L     R7,SEED       PUT SEED IN R7
         M     R6,=F'65541'      MULTIPLY SEED BY 65541
         ST    R7,SEED    STORE NEW SEED-A NO FROM -2**31 TO 2**30
         LPR   R7,R7         SET R7=|R7|
         MR    R4,R7   R4-R5 NOW HAS A RNDM NO FROM 0 TO 2**32*N
         AR    R4,R3        R4= 1 TO N IN IT (AFTER ADDING BACK B= +1)
         ST    R4,0(R2,R1)  STORE RNDM NO IN TABLE
         BXH   R2,R9,LOOPRNDM      LOOP UNTIL TABLE IS FILLED
         SPACE 5
         L     R2,ASNAPDMP         PRINT RNDM NO TABLE IF SYSOUX
         L     R6,TABLEND
         CHCKTIOT NOTFND=RSORT
         BAL   GOREG,OUTATTR       OPEN SYSOUX- SNAPDUMP
         L     R5,TABLE
         SNAP  DCB=(R2),ID=1,STORAGE=((R5),(R6)),STRHDR=RNDMHDRL
         MVI   POSTSORT+1,SETNOP SET NOP TO WRITE RN NUMBS AFTER SORT
         SPACE 3
RSORT    L     R5,TABLE           GET TABLE ADDR IN R5
RNDMNOP  NOP   EOFCNVRT      SET TO BRANCH FOR CONVERT FILE
         MVI   SORTDONE,C'0'      0=SORT FINISHED
RSORTCNT C     R5,TABLEND       IS THIS THE LAST TABLE ENTRY
         BNL   RSORTEND                  YES
         LM    R6,R7,0(R5)  GET NEXT 2 RANDOM NUMBERS
         CR    R6,R7            ARE THEY IN SORTED ORDER
         BNH   RNEXTKEY              YES
         XR    R6,R7        NO-SWITCH THEM
         XR    R7,R6
         XR    R6,R7
         STM   R6,R7,0(R5)       RESTORE SORTED NUMBERS BACK IN TABLE
         MVI   SORTDONE,C'1'        INDICATE 2 ENTRIES WERE MOVED
RNEXTKEY LA    R5,4(R5)       POINT TO NEXT TABLE ENTRY
         B     RSORTCNT            CONTINUE SORTING
RSORTEND CLI   SORTDONE,C'0'    IS THE SORT FINISHED
         BNE   RSORT               NO
         SPACE 3
         L     R7,TABLE         YES -GET TABLE ADDR IN R7
POSTSORT B     RNDMROUT         SET TO NOP IF SYSOUX IN JCL
         L     R6,TABLEND
         MVI   RANDMHDR+5,C'9'    CHANGE MSG NUMBER TO 079
         MVC   RANDMHDR+8(4),MSGSPACE BLANK OUT 'PRE-'
         L     R4,ASNAPDMP      GET SNAPDUMP DCB
         SNAP  DCB=(R4),ID=2,STORAGE=((R7),(R6)),STRHDR=RNDMHDRL
         SPACE 3
RNDMROUT NOP   RNDMCOMP
         MVI   RNDMROUT+1,SETBR
         CVB   R9,PASSCT         PUT PASSCT IN R9I
RNDMPROC LA    R6,0(0,R7)        PUT ADDR OF RNDM NO IN R6
         C     R6,TABLEND      IS THIS THE END OF THE TABLE
RNDMONLY BH    RNDMEND      YES;SET TO BR WHEN NOINPUT IN X0 EXIT
         L     R5,0(0,R7)                PUT RNDM NO IN R5
         SR    R5,R9        NO-PUT  (RNDM NO-PASSCT) IN R5
         BM    RNDMDUP      DIFFERENCE IS NEGAT-MEANS DUP IN TABLE
RNDMCOMP LTR   R5,R5        IS DIFFERENCE 0
         BZ    RNDMPUT  YES-GO TO PUT OUT THIS INPUT RECORD
         BCTR  R5,0 SUBTRACT 1 FROM DIFFERENCE
         B     BRPTOUT2
RNDMPUT  BAL   GOREG,PUTFILE      WRITE REC
         LA    R7,4(R7)           GET NEXT RANDOM NUMB
         MVI   RNDMROUT+1,SETNOP
         B     GETINPUT
         SPACE 1
RNDMDUP  LA    R7,4(R7)        POINT TO NEXT RANDOM NUMBER
         B     RNDMPROC
         SPACE 1
SEEDPACK PACK  WORKFLD1,INCARD+7(1)    PACK THE SEED
         SPACE 2
PICKIT   TIME  BIN  GET THE TIME OF DAY IN BINARY N R0 (GOOD RANDOM NO)
         LR    R9,R0     PLACE IN R9
         B     MAKEODD   AND RETURN TO MAINLINE RANDOM RTN
RNDMHDRL DC    AL1(L'RANDMHDR)
RANDMHDR DC    C'SEL078I PRE-SORTED RECORD NUMBERS GENERATED BY RANDOM C
               OPTION'
         TITLE 'PRINT DETAIL LINES AND MESSAGES ROUTINES'
KEYREPT  L     R1,PRINTBUF    SUBROUTINE TO PRINT TOTALS MESSAGE
         MVC   MSG4KEY,MSGSPACE   SPACE OUT
         CLI   INCARD,X'FF'  IS THE INPUT = HIGH VALUE
         BNE   KEYREPT1    GO TO PROCESS THE NORMAL KEY
         MVC   INCARD,HIGHVALU
KEYREPT1 MVC   MSG4KEY,INCARD
         MVC   0(MSG4LEN,R1),MSG4
         ED    MSG4PASS(MSG4EDIT,R1),PASSCT   PASS & OUT CTS
         MVC   MSG4MAX,MSGSPACE   RESET TO BLANKS
KMSG     B     ORENDCNT           NOOP ON K KEY FOR MSG
         CP    TOTLKEYS,COUNT
         BE    KCNTSAT
ORENDCNT B     ZAPCNTS     NOOPED FOR 'O' ,'ON' KEY AND 'MN' ON EOJ
         CP    OUTCT,COUNT
         BNE   ZAPCNTS
KCNTSAT  MVI   MSG5FLAG,X'52'    SET FOR MSG 82
ZAPCNTS  AP    TOTPASCT,PASSCT
         AP    TOTOUTCT,OUTCT
         ZAP   OUTCT,PACKZERO     RESET TO ZERO
         ZAP   PASSCT,PACKZERO    RESET TO ZERO
SKIPPRNT BCR   0,GOREG            CHANGED TO BRANCH ON A,M,V= OPTION
*
PUTPRINT L     R1,ASYSPRNT        PRINT SUBROUTINE-GET SYSPRINT DCB
         PUT   (R1)
         ST    R1,PRINTBUF        ALLOW DYNAMIC BUFFERING
         MVI   0(R1),BLANK1            INIT NEXT PRINT LINE TO BLANKS
         MVC   1(132,R1),0(R1)
         BR    GOREG
         TITLE 'READ SYSIN ROUTINE'
GETCARD  B     RETURNCD   NOP IF KEY TYPE IS M,T,G,P,B,C,O,A OR E
         SPACE 1
READCRD1 B     RDSYSIN    CHANGED TO NOP ON 'A' OPTION WITH S513
         L     R1,PUTADDR       LOAD ADDR OF INPUT FILE
         B     AFTEREAD         BRANCH AROUND THE GETCARD
         SPACE 1
RDSYSIN  CP    RCOUNT,PACKZERO
         BE    READCRD2
SYSINOUT B     SYSINOT2        CHANGED TO NOP IF SYSUT4 PRESENT IN JCL
         CLI   SYSINFLG,C'1'   DID THIS SYSIN RECORD CAUSE A MATCH
         BNE   SYSINOT2                NO
         MVI   SYSUTX,C'4'
EXITBRO3 B     NOEXITO3   CHANGED TO NOP IF EXIT POINT O3 REQUESTED
         L     R15,=A(EXTEPAO3)   GET EXIT O3 ENTRY POINT
         L     R15,0(R15)
         LA    R1,CARDADDR        SET UP PARAMETER LIST
         BALR  R14,R15            EXECUTE O3 EXIT
         C     R15,FULL4          CHECK RETURN CODE
         BL    NOEXITO3 RC=0   CONTINUE NORMAL PROCESSING
         BE    RESETFLG RC=4  DELETE THIS RECORD-GET NEW SYSIN
         MVI   EXITBRO3+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT
NOEXITO3 EQU   *
         L     R2,ASYSIN    GET SYSIN DCB
         L     R1,AOUTFIL3   LOAD SYSUT4 DCB ADDR INTO R1
         L     R0,CARDADDR  LOAD SYSIN RECORD ADDR INTO R0
SKIPPUT4 NOP   PRINT4        CHANGED TO BRANCH IF SYSUT4 IS SYSOUT
         PUT   (R1),(R0)  YES-OUTPUT THIS SYSIN RECORD TO SYSUT4
PRINT4   ST    GOREG,SAVEREGS   SAVE THE BAL REGISTER
PRNT4BAL NOP   PRINTLK      CHANGED TO BAL IF SYSUT4 IS SYSOUT
         L     GOREG,SAVEREGS
         AP    OUTCT3,PACKONE        ADD 1 TO MATCH COUNT
RESETFLG MVI   SYSINFLG,C'0'    RESET THE FLAG
         B     READCRD2         GO TO GET A NEW SYSIN RECORD
         SPACE 1
SYSINOT2 B     READCRD2        CHANGED TO NOP IF SYSUT5 PRESENT IN JCL
         CLI   SYSINFLG,C'1'    DID THIS SYSIN RECORD CAUSE A MATCH
         BE    RESETFLG        YES
         MVI   SYSUTX,C'5'
EXITBRO4 B     NOEXITO4   CHANGED TO NOP IF EXIT POINT O4 REQUESTED
         L     R15,=A(EXTEPAO4)   GET EXIT O4 ENTRY POINT
         L     R15,0(R15)
         LA    R1,CARDADDR        SET UP PARAMETER LIST
         BALR  R14,R15            EXECUTE O4 EXIT
         C     R15,FULL4          CHECK RETURN CODE
         BL    NOEXITO4 RC=0   CONTINUE NORMAL PROCESSING
         BE    READCRD2 RC=4  DELETE THIS RECORD-GET NEW SYSIN
         MVI   EXITBRO4+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT
NOEXITO4 EQU   *
         L     R2,ASYSIN
         L     R1,AOUTFIL4
         L     R0,CARDADDR
SKIPPUT5 NOP   PRINT5
         PUT   (R1),(R0)  NO-OUTPUT THIS SYSIN RECORD TO SYSUT5
PRINT5   ST    GOREG,SAVEREGS
PRNT5BAL NOP   PRINTLK
         L     GOREG,SAVEREGS
         AP    OUTCT4,PACKONE    ADD 1 TO NON-MATCHED COUNT
         SPACE 1
READCRD2 L     R1,ASYSIN   GET SYSIN DCB ADDR
         GET   (R1)
AFTEREAD ST    R1,CARDADDR
         SPACE 1
EXITBRI2 B     NOEXITI2   CHANGED TO NOP IF EXIT POINT I2 REQUESTED
         L     R15,=A(EXTEPAI2)   GET EXIT I2 ENTRY POINT
         L     R15,0(R15)
         LA    R1,CARDADDR        SET UP PARAMETER LIST
         BALR  R14,R15            EXECUTE I2 EXIT
         L     R1,CARDADDR      RESET R1 TO CONTAIN REC ADDR
         C     R15,FULL4          CHECK RETURN CODE
         BL    NOEXITI2 RC=0   CONTINUE NORMAL PROCESSING
         BE    GETCARD  RC=4  DELETE THIS RECORD-GET NEW SYSIN
         MVI   EXITBRI2+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT
NOEXITI2 EQU   *
         CLI   VSAMFLAG,C'1'   IS VSAMKEY DDNAME BEING USED
         BNE   VSETNOP         NO
         MVI   VSMPOINT+1,SETNOP FOR VSAMKEY RESET NOP TO REPOSITION
         SPACE 3
VSETNOP  B     MOVECARD       NOP IF V= OPTION REQESTED ON A,M  T
         A     R1,VPOSLENS      ADD P1 TO REC ADDR
VSET1    MVC   0(0,R9),0(R1)      MOVE IN 1ST L,P INTO INCARD
         SPACE 1
CNVRTVB1 B     VBR1      SET TO NOP IF CONVERT FILE PRESENT
         L     R15,=A(CNVRTABL)
VSETTR1  TR    0(0,R1),0(R15)
         SPACE 1
VBR1     B     TRNSCARD        NOP IF 2 OR MORE L,P'S
         A     R1,VPOSDISP      ADD P2 TO REC ADDR
VSET2    MVC   0(0,R9),0(R1)     MOVE IN 2ND L,P INTO INCARD
         SPACE 1
CNVRTVB2 B     VBR2      SET TO NOP IF CONVERT FILE PRESENT
VSETTR2  TR    0(0,R1),0(R15)
         SPACE 1
VBR2     B     TRNSCARD        NOP IF 3 L,P'S
         A     R1,VPOSDISP+4           ADD P3 TO REC ADDR
VSET3    MVC   0(0,R9),0(R1)     MOVE IN 3RD L,P INTO INCARD
         SPACE 1
CNVRTVB3 B     TRNSCARD  SET TO NOP IF CONVERT FILE PRESENT
VSETTR3  TR    0(0,R1),0(R15)
         SPACE 1
TRNSCARD B     RETURNCD        BRANCH AROUND THE FOLLOWING DEFAULT MOVE
         L     R15,=A(TRNSTAB5)   LOAD ADDRESS OF TRANLATE5 INTO R15
YTRNSLT2 TR    0(0,R9),0(R15)    TRANSLATE THE SYSIN KEY ON V= OPTION
         B     RETURNCD
         SPACE 1
MOVECARD MVC   INCARD,0(R1)
RETURNCD AP    RCOUNT,PACKONE  ADD 1 TO NO OF SYSIN CARDS READ
NOPGETBR BR    GOREG     SET TO NOPR ON VP=
         SPACE 1
         L     R15,=A(TRNSTAB2)  GET NUMERIC TEST TABLE
VPNUMTST TRT   0(0,R9),0(R15)    DO NUMERIC TEST ON SYSIN KEY
         BC    5,GETCARD  SYSIN KEY NOT NUMERIC - GET NEXT SYSIN KEY
         BZ    VPPACK    KEY IS NUMERIC - GO PACK IT
         CLM   R2,1,FULL1+3   IS FUNCTION BYTE =X'01' I.E. NUMERIC
         BNE   GETCARD    NO - KEY NOT NUMERIC
VPPACK   PACK  WORKFLD1,0(0,R9)   PACK THE KEY , LENG ADJUSTED
         MVC   INCARD(8),WORKFLD1 MOVE PACKED KEY TO INCARD FOR CP
         BR    GOREG
         TITLE 'WRITE SYSUT2 AND PRINT ROUTINES'
PUTFILE  NOP   NOPUT1      CHANGED TO BRANCH TO BYPASS WRITING SYSUT2
         MVI   SYSUTX,C'2'
EXITBRO1 B     NOEXITO1   CHANGED TO NOP IF EXIT POINT O1 REQUESTED
         L     R15,=A(EXTEPAO1)   GET EXIT O1 ENTRY POINT
         L     R15,0(R15)
         LA    R1,PUTADDR         SET UP PARAMETER LIST
         BALR  R14,R15            EXECUTE O1 EXIT
         C     R15,FULL4          CHECK RETURN CODE
         BL    NOEXITO1 RC=0   CONTINUE NORMAL PROCESSING
         BE    NOPUT2   RC=4  DELETE THIS RECORD-DONT WRITE SYSUT2
         MVI   EXITBRO1+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT
NOEXITO1 EQU   *
         L     R2,DCBADDR
         L     R1,AOUTFIL
         L     R0,PUTADDR  LOAD ADDR OF ISAM/INFIL REC AREA INTO R0
SKIPPUT2 NOP   PRINT2
         PUT   (R1),(R0)     PUT OUT A RECORD TO SYSUT2
PRINT2   ST    GOREG,SAVEREGS
PRNT2BAL NOP   PRINTLK    CHANGED TO BAL GOREG,PRINTLK ON SYSOUT
LIBOTBAL NOP   LIBOTRTN   CHANGED TO BAL GOREG,LIBOTRTN ON LIBOUT
VSOUTBAL NOP   VSOUTRTN   CHANGED TO BAL GOREG,VSOUTRTN ON VSAMOUT
         L     GOREG,SAVEREGS
NOPUT1   AP    OUTCT,PACKONE    ADD 1 TO NO OF RECORDS OUTPUT TO SYSUT2
NOPUT2   MVI   SYSINFLG,C'1'
MEMBMSG  B     NOPFMEMB    SET TO NOP IF MEMBNAME IS DUMMY OR MEMSYSIN
         SPACE 1
         L     R1,=A(BLDENTRY)  GET MEMBER NAME
         CLI   MSG93MEM,BLANK1  IS MEMBNAME BLANK I.E. FIRST MEMBER
         BE    FIRSTREC         YES
         CLC   MSG93MEM,0(R1)   NO - SAME AS PREV MEMBER
         BNE   MEMMSGPT         NO - PRINT MSG
         AP    MEMRECCT,PACKONE YES ADD 1 TO RECORDS IN MEMBER
         B     NOPFMEMB         RETURN
MEMMSGPT ED    MSG93ED,MEMRECCT+3  EDIT THE NUMBER OF RECS
         ST    GOREG,SAVEREGS   SAVE R8 WHICH IS USED IN MESSAGE MACRO
         MESSAGE 93     PUT OUT MESSAGE
         L     GOREG,SAVEREGS
         MVC   MSG93ED,MSGMASK   RESET MSG MASK
         L     R1,=A(BLDENTRY)  GET MEMBER NAME
FIRSTREC MVC   MSG93MEM,0(R1)    PUT IN NEW MEMBER NAME
         ZAP   MEMRECCT,PACKONE   RESET COUNT TO ONE
         SPACE 2
NOPFMEMB BR    GOREG   SET TO NOPR WHEN MEMBNAME IS WRITTEN ON LIBFILE
         SPACE 1
         L     R0,=A(BLDENTRY)   GET MEMBER NAME
         L     R1,AMEMBNAM       GET  MEMBNAME DCB
         PUT   (R1),(R0)     WRITE MEMBNAME RECORD
         BR    GOREG
         SPACE 2
PRINTLK  L     R15,=A(PRINTER)   LOAD ADDR OF PRINT ROUTINE
         BALR  R14,R15           BRANCH AND TO PRINT ROUTINE
         BR    GOREG
         SPACE 2
LIBOTRTN L     R1,ALIBOUT      LOAD DCB ADDR INTO R1
         L     R15,=A(LIBCSECT)  DO LIBOUT WRITE RTN
         BALR  R14,R15
LIBOTEOJ C     R15,FULL4       WAS WRITE SUCCESSFUL
         BH    LIBOUTER        NO         RC>4 END ON ERROREOJ
         BE    LIBOTDUP     DUPLICATE MEMBER NAME-CONTINUE PROCESSING
         BR    GOREG           YES - RETURN
         SPACE 2
VSOUTRTN ST    GOREG,WORKFLD1   SAVE GOREG REG- NEED IT IN MODCB
         L     R2,VSOUTRPL      GET VSAMOUT RPL ADDR
         L     R8,PUTADDR       PUT OUTPUT REC ADDR IN R8
         CLI   VSAMFLAG,C' '    IS INPUT VSAMFILE/KEY
         BNE   SKPSEQIN         YES- SKIP RECFM DETERMINATION
         CLI   MSG40FVU,C'F'    NO- IS RECFM=F
         BE    SKPLRECL         YES-SKIP GETTING INPUT LRECL
*                         GOTTEN FROM MODCB  IN VSAMSECT
         CLI   MSG40FVU,C'V'    NO-IS RECFM=V(SPANNED OK IF BFTEK=A)
         BNE   RECFMERR         ALLOW ONLY RECFM=F OR V AS INPUT
         LH    R0,0(R8)         GET RDW
         S     R0,FULL4         SUBTRACT 4 FOR ACTUAL DATA PORTION LENG
         A     R8,FULL4         SET BUFFER IN OUTREC BEYOND RDW
         B     MODLRECL         MODIFY RECLEN
         SPACE 1
SKPSEQIN L     R0,VSAMRECL      RECLEN OF VSAMXXX INPUT FILE
*        GET RECLEN OF INPUT VSAMKEY-SEE VSAM ADMIN:MACRO INSTR D P.164
*        AND PUT IT INTO VSAMOUT RPL
MODLRECL LR    R1,R2         PUT VSAMOUT RPL IN R1
         L     R15,16           CVT ADDR IN R15
         L     R15,256(R15)     AMCBS CONTROL BLOCK ADDR IN R15
         L     R15,12(R15)   CONTROL BLOCK MANIPULATION RTN ADDR IN R15
         BAL   R14,80(R15)   BRANCH TO THE RTN TO STORE LRECL IN RPL
         SPACE 1
SKPLRECL MODCB RPL=(R2),AREA=(R8)   MODIFY VSAMOUT RPL
         L     GOREG,WORKFLD1   RESTORE GOREG
         PUT   RPL=(R2)         WRITE VSAMOUT REC
         C     R15,FULL8
         BE    VSAMDUP   RC=8 MEANS TRYING TO STORE A REC WITH DUP KEY
         BH    VSAMOTER  ERR- DO SHOWCB AND GET FDBK CODE FOR VSAMOUT
         BR    GOREG     RC=0 (RC=4 ONLY HAPPENS ON GET EODAD) OK
         SPACE 2
VSAMDUP  SP    OUTCT,PACKONE   ADJUST OUTPUT CNT-NOT WRITING DUP REC
VSAMDUP2 NOPR  GOREG         SET TO BRANCH AFTER 1ST TIME
         OI    VSAMDUP2+1,X'F0'  TO WRITE WARNING MESSAGE
         ST    GOREG,WORKFLD1    SAVE GOREG REG
         LNKMSG 52
         L     GOREG,WORKFLD1    RESTORE GOREG
         BR    GOREG
         SPACE 1
LIBOTDUP MVI   MSG93ED,C'*'            MEMBER NOT REPLACED MESSAGE
         MVC   MSG93ED+1(9),MSG93ED
         SP    OUTCT,MEMRECCT         ADJUST OUTPUT REC TOTAL IN MSG4
         B     VSAMDUP2
         TITLE 'END-OF-KEYS ROUTINES'
ENDKEYS  L     R1,PRINTBUF   GET R1 READY FOR PRINTING AT END OF SYSIN
         CP    RCOUNT,PACKZERO    WAS SYSIN EMPTY
         BE    SYSINNG            YES
         CLI   KEYMSG,C'O'     ARE WE PROCESSING 'O' KEYS
         BE    SYSINNG           YES-ERROR,NOT ENOUGH SYSIN CARDS
         SPACE 2
ENDKEYT  B     ENDKEYT1   THIS IS SET TO A NOP DURING T,G,P,E LOGIC
         ST    R7,TABLEND      STORE THE ADDR OF THE END OF THE TABLE
         CLI   KEYINDIC,C'1'   WERE THERE AN ODD NO OF SYSIN KEYS ON G
PLOGNOP  BE    GERROR         YES-ERROR,SET TO NOP ON P OPT
         L     R1,TABLE     GET ADDRESS OF SYSIN KEY TABLE
         MVC   ECHGKEY(20),0(R1) MOVE FIRST SYSIN KEY
*        FOR E OPTION WITH A CHANGE KEY CODED IN CONVERT FILE
         MESSAGE 36,EDIT=RCOUNT+5,BRANCH=GETINPUT
ENDKEYT1 CP    ENDCT,END     DID PROCESSING END DUE TO E= PARM
         BH    SYSUT3OP     YES-FINISH THE SYSUT1 FILE IF NECESSARY
         CLI   ENDPARMS,C'2'     HAS THE SYSUT1 FILE ALREADY ENDED
         BE    MMSG                 YES
SYSUT3OP CLI   SYSINDCB+1,SETBR  NO -IS V= REQUESTED  A AND M OPTIONS
         BNE   SKIPVEQU             NO
         CLI   CLS2NOP+1,SETNOP  YES-IS SYSUT3 OPEN
         BNE   MMSG                 NO
         MVI   SETBRONV+1,SETBR   YES-IGNORE E= PARAMETER
         MVI   BR4+1,SETNOP      SET NOPS TO WRITE ALL THE REST OF
         MVI   BR6+1,SETNOP      THE SYSUT1 RECORDS TO SYSUT3
         MVI   ENDPARMS,C'2'       SET SYSIN ENDED FLAG
         MVC   AGETCRD1(2),=X'4700' CHANGE BACK TO NOP
         MVC   INCARD,HIGHV SET SYSIN TO X'FF' FOR VSAMKEY TO END IMMED
         CLI   NOPONVP+1,SETNOP    IS VP= BEING USED
         BNE   HIGHVOK             NO
         MVC   INCARD(15),=P'999999999999999'  YES - USE NUMERIC HIGHV
HIGHVOK  CP    PASSCT,PACKZERO  WAS SYSIN KEY KICKED BECAUSE CNT SATISF
EEQUNOP  BE    GETINPUT     YES-DO NOT WRITE PREVIOUS SYSUT1 REC
         B     STARTPRC     NO-WRITE PREVIOUS SYSUT1 REC TO SYSUT3
*        BRANCH BACK TO STARTPRC IN CASE ENCRYPTION REQUIRED FOR KEYS
         SPACE 2
SKIPVEQU CLI   LSKIP1+1,SETBR    IS THIS THE LONG SUBOPTION ON M OPT
         BNE   NOTLOPT                       NO
         NI    SKIPPRNT+1,X'0F'
         ZAP   PASSCT,TOTPASCT
         ZAP   OUTCT,TOTOUTCT
         BAL   GOREG,KEYREPT     YES -PRINT OUT TOTAL LINE
NOTLOPT  LNKMSG 6                 'END OF KEYS BEFORE END OF INFILE'
         CLI   REXTLOG+1,SETBR   IS THIS AN R OPTION
         BNE   NOTROPT           NO
RNDMEND  MVI   MSG5FLAG,X'53'     SET UP BLANK LINE FOR FINISH MSG
         B     ENDINF
         SPACE 2
NOTROPT  CLI   KEYINDIC,C'1'   DID END OF KEY OCCUR AFTER LOW KEY ON B
         BNE   NOTMN      N0- CONTINUE WITH END MN ROUTINE
         MVC   INCARD1,HIGHV     MOVE HIGH VALUES TO 2ND KEY
         MVC   MSG29UKY(11),HIGHVALU MOVE HIGH VALUE MSG
         MVI   ENDBKEY+1,SETBR   SET TO BRANCH TO GO TO EOJ
         B     BYPTRNSL
         SPACE 2
NOTMN    B     EOJ           SET NOP IF MN
         MVI   BR5A+1,SETBR  SET B FOR END OF JOB ON MN
         MVI   ORENDCNT+1,SETNOP PUT 'COUNT SATISFIED' MESSAGE
         MVI   MNSTOP+1,SETNOP  STOP PROCESSING ON MN WHEN 'HIGH VALUE'
         MVI   MNPUTBR+1,SETBL    REACHED AND COUNT SATISFIED
         MVI   KEYREPT1+1,X'10'   SET TO PRINT 'HIGH VALUES'
         MVC   INCARD,HIGHV     FILL INPUT AREA WITH HIGH VALUES
         B     COMPKEY
         TITLE 'END-OF-INPUT ROUTINES - T,P MESSAGES'
ENDINPUT L     R1,PRINTBUF  INIT R1 WITH ADDR OF PRINTBUF FOR END ROUTN
         CLI   MEMBMSG+1,SETNOP WAS MEMBNAME DUMMY OR MEMSYSIN CODED
         BNE   NOMEMMSG       NO
         ED    MSG93ED,MEMRECCT+3   YES
         MESSAGE 93
NOMEMMSG EQU   *
         SPACE 2
         CLI   MSG5FLAG,X'50' IS V= REQUESTED ON A OR M OPTION W SYSIN
         BNE   TTOTRPRT         NO- NORMAL EOJ
         CLI   ENDPARMS,C'2' HAS SYSIN FILE ALREADY ENDED ON A OR M OPT
         BE    MMSG                 YES-GO TO PUT OUT M MSG
         CLI   SYSINFLG,C'1' IS THE LAST SYSIN REC WAITING TO BE WRITTN
         BE    LASTSYSN         YES
         CLI   CLS4NOP+1,SETNOP NO-HAS SYSUT5 BEEN OPENED ON A,M,V=
         BE    LASTSYSN         YES- FINISH PROCESSING SYSIN
         CLI   ENDFLAG,X'51'    NO-  DID PROCESSING END DUE TO E=
         BNE   TTOTRPRT         NO-  GO TO NORMAL END
         MVI   EEQUNOP+1,SETNOP YES- NOP THE B TO GETINPUT
         B     SYSUT3OP         GO FINISH PUTTING OUT SYSUT3 (IF OPEN)
         SPACE 2
LASTSYSN MVI   ENDPARMS,C'2'    YES-SET FLAG TO INDICATE END OF INFILE
         MVI   EEQUNOP+1,SETNOP NOP THE B TO GETINPUT IN CASE OF E=PARM
         BAL   GOREG,KEYREPT    PUT OUT LAST DETAIL MSG
LOOP     BAL   GOREG,GETCARD    GET A NEW SYSIN RECORD
         B     LOOP             FINISH SYSIN FILE-NO MORE MATCHES
         SPACE 2
TTOTRPRT B     BMSG         BYPASS THE T REPORT
         L     R7,TABLE        LOAD THE ADDR OF FIRST TABLE ENTRY
         CP    COMPCNT,OUTCT   IS THE TABLE FULL
         BNE   TMSG            NO
         EX    0,KCNTSAT      YES-PUT OUT 'CNT SATISFIED ' MSG
TMSG     C     R7,TABLEND   ARE WE AT THE END OF THE TABLE
         BNL   ENDINF        YES IT IS THE END OF THE KEY'S
         SPACE 1
EMSG     NOP   EKEYMSG       CHANGED TO B ON E OPT
PMSG     B     TKEYSEL       CHANGED TO NOP ON P OPTION
PMSGED   L     R9,0(0,R7)    GET BINARY COUNT FIELD (DISPLACEMENT ADJ)
         CVD   R9,PACKFLD        CONVERT COUNT TO DECIMAL
         ED    MSG29OUT,PACKFLD+3  EDIT THE COUNT-DISPLAC ADJUSTED
         MVC   MSG29LKY,MSGSPACE   SPACE OUT THE LOWER KEY(LOW VALUES)
PLVMSG   CLC   0(0,R7),LOWVALUE  IS FIRST CARD 'LOW VALUES'-LENG ADJUST
         BNE   LKYNOTLV            NO
         MVC   MSG29LKY(10),LOWVMSG  YES-MOVE IN 'LOW VALUE' MSG
         B     CHKUKY                CHECK UPPER KEY
         SPACE 1
LKYNOTLV MVC   MSG29LKY,0(R7)  MOVE IN LOWER KEY FOR PRINT-LENGTH ADJ
CHKUKY   CLC   0(0,R7),HIGHV IS UPPER KEY HIGH VAL-LENG & DISPLAC ADJ
         BNE   UKYNOTHV                  NO
         MVC   MSG29UKY(11),HIGHVALU    YES-MOVE IN HIGH VALUES TO MSG
         B     UKYHV                 HIGH VALUES IS THE LAST SYSIN CARD
         SPACE 1
UKYNOTHV MVC   MSG29UKY,0(R7)       MOVE IN UPPER KEY
UKYHV    AR    R7,R5                 POINT TO NEXT PAIR OF KEYS
         MESSAGE 29                  WRITE MSG FOR THIS PAIR
         MVC   MSG29OUT,MSGMASK
         B     TMSG
         TITLE 'END-OF-INPUT ROUTINES - T,G AND E MESSAGES'
EKEYMSG  CLI   0(R7),X'FF'      HAS AN INVALID KEY BEEN ENCOUNTERED
         BNE   EKEYMSG2            NO
         MVI   TKEYMSG+1,X'14'  YES -PRINT OUT 20 CHARACTERS OF THE KEY
         MVC   MSG21ED(9),=C'KEY ERROR'   PRINT ERROR MESSAGE
         B     TKEYMSG     BYPASS EDITING THE COUNT -JUST PRINT THE KEY
         SPACE 1
EKEYMSG2 B     ENDINF   SET TO NOP WHEN SYSUT1 IS NOT NULLFILE
         SR    R9,R9          CLEAR R9
         IC    R9,0(0,R7)    INSERT LENGTH OF KEY IN R9
         CLI   19(R7),C'#'   IS THIS AN 'AND' KEY
         BNE   EMSGCONT      NO
         SR    R1,R1         YES
         IC    R1,1(R9,R7)   GET LENGTH OF SECOND KEY IN R1
         LA    R9,1(R1,R9)   R9=L1+L2+1
EMSGCONT STC   R9,ECHGMSGM+1 ADJUST MOVE INSTRUCT WITH LENGTH FOR E CHG
         LA    R9,1(R9)    ADD 1 TO LENGTH TO PRINT KEY & 2 DELIMITERS
         STC   R9,TKEYMSG+1  ADJUST MOVE INSTRUCT WITH LENGTH
         IC    R9,0(R9,R7)   INSERT DELIMITER INTO R9
         STC   R9,0(0,R7)  PUT DELIMITER BACK INTO 1ST POSITION OF KEY
         MVC   MSG21KEY,MSGSPACE  CLEAR OUT PREVIOUS KEY
         SPACE 3
ECHGMSG  B     TKEYSEL  CHG TO NOP IF E OPTION & CHANGE KEY($) IN CNVRT
         MVI   ECHGMSG+1,SETBR  SETBACK TO B AFTER 1ST TIME THRU
         L     R1,=A(ECHGCNT)  GET NUM OF KEYS CHANGED FROM E CSECT
         ED    MSG88CNT,0(R1)  EDIT COUNT INTO MSG
ECHGMSGM MVC   MSG88KEY,0(R7)  PLACE SYSIN KEY INTO MSG
         MVI   MSG88KEY,BLANK1 BLANK OUT FIRST DELIMITER
         MVC   MSG88CHG,ECHGKEY+20  PLACE CONVERT KEY INTO MSG
         MESSAGE 88       PRINT MESSAGE
         SPACE 3
TKEYSEL  L     R9,20(0,R7)    GET BINARY COUNT FLD;DISPACEMENT ADJUSTED
         CVD   R9,PACKFLD
         ED    MSG21ED,PACKFLD+3
TKEYMSG  MVC   MSG21KEY,0(R7)    MOVE IN THE KEY TO THE MESSAGE-LEN ADJ
         AR    R7,R5    BUMP TO THE NEXT TABLE ENTRY
         B     OMSG          LOOP TO PUT OUT KEY'S AND COUNTS FOR T
         TITLE 'END-OF-INPUT ROUTINES - O,Q,F,D,R,B,A AND M MESSAGES'
BMSG     B     ONLY1OR            CHANGED TO NOP ON B KEY
         MVI   ENDBNOP+1,SETNOP   SET NOP
         B     LASTBKEY
         SPACE 1
ONLY1OR  B     SEQMSG1            NOOPED IF  OR OPTION
         ED    MSG21ED,COMPCNTA+3
OMSG     MESSAGE 21
         MVC   MSG21ED,MSGMASK    EDIT MASK IS RESET
FREQMSG  NOP   FMOVE              SET TO B ON F,J=0
FJEQ0BR  NOP   FMSG               SET TO B ON F,J=0 AFTER LAST MSG
TMSGBR   NOP   TMSG               SET TO B ON T,G,E OPTIONS
ONLY2OR  B     ONLY3OR            NOOPED IF 2 KEYS ON OR OPTION
         MVC   MSG21KEY,MSGSPACE  CLEAR MESSAGE KEY
OKEYMSG2 MVC   MSG21KEY,INCARD1  MOVE IN THE 2ND KEY FOR 'O' MSG
         ED    MSG21ED,COMPCNTB+3
         MVI   ONLY2OR+1,SETBR
         B     OMSG
ONLY3OR  B     SEQMSG1            NOOPED IF 3 KEYS ON OR OPTION
         MVC   MSG21KEY,MSGSPACE  CLEAR MESSAGE KEY
OKEYMSG3 MVC   MSG21KEY,INCARD2   MOVE IN 3RD KEY FOR 'O' MSG
         ED    MSG21ED,COMPCNTC+3
         MVI   ONLY3OR+1,SETBR
         B     OMSG
         SPACE 1
SEQMSG1  B     FMSG     CHANGED TO NOP FOR SEQUENCE ERR ON QKEY
         CLI   KEYMSG,C'9'        FLAG INDICATING THERE WAS AN ERROR
         BE    QTOTRECS           BYPASS SUCCEEDING MSG
         LNKMSG 19
QTOTRECS LNKMSG 25,EDIT=PASSCT+3,BRANCH=EOJ
         SPACE 1
FMSG     B     DMSG  IF KEY NOT F,BYPASS  F MESSAGE PRINTOUT
         CLI   FREQMSG+1,SETBR    IS THIS F,J=0 THE FREQUENCY OPTION
         BNE   NOTFREQU            NO
         MVI   FREQMSG+1,SETNOP ALLOW FALL THRU AFTER PRINTING LAST MSG
         MVI   BYP2MSGS+1,SETBR  SKIP LAST 2 F MESSAGES
         MVI   FJEQ0BR+1,SETBR  SET A BRANCH AFTER LAST MSG
         CP    ENDCT,PACKZERO   IS SYSUT1 EMPTY (NULLFILE)
         BE    NOTFREQU         YES-GET OUT AND PRINT END MESSAGE
         B     BR2PRTF            NO- GO BACK TO PRINT LAST MSG
NOTFREQU LNKMSG 30,EDIT=TOTLKEYS+3
BYP2MSGS NOP   DMSG                  SET TO B ON F,J=0
         LNKMSG 31,EDIT=KEYLESS+3
         LNKMSG 32,EDIT=KEYMORE+3
         SPACE 1
DMSG     B     RMSG           CHANGED TO NOP ON D KEY
         CLI   KEYMSG,C'8'    WAS KEY FOUND ON D OPTION
         BE    DMSGOUT                YES-BRANCH TO PUT OUT D MSG
         LNKMSG 24,BRANCH=EOJ   'KEY NOT FOUND'
         SPACE 1
RMSG     B     REXTMSG          NOP ON R KEY-SKIPPED ON R EXTENDED OPTS
         MVI   RENDBR+1,SETBR   SET BR TO COME BACK TO ENDINF
         CP    OUTCT,RCOUNT     WAS COUNT SATISFIED
         BNE   RMSGOUT          NO-PUT OUT MSG FOR 3RD GROUP
         CP    RCOUNT,PACKZERO  IS THE FILE EMPTY
         BE    ENDINF            YES
         EX    0,KCNTSAT       YES-MOVE 'CNT SATISFIED' MSG
         SPACE 1
REXTMSG  NOP   RPUT     SET TO BR ON R OPT WITH 'LAST' REC REQUESTED
MMSG     B     ENDINF
         NI    SKIPPRNT+1,X'0F'  RESET NOP TO PRINT TOTAL LINE
         AP    TOTPASCT,PASSCT  IF KEYS ENDED 1ST ADD REST OF INPUT
         AP    TOTOUTCT,OUTCT  IF INPUT FILE ENDS ON A MATCH ADD RECS
         ZAP   PASSCT,TOTPASCT      RESTORE PASSCT AND OUTCT
         ZAP   OUTCT,TOTOUTCT            FOR PRINTING
ENDINF   B     BYPENDF NOP IF A,C,D,E,F,K,R,O,P,T,Q,B,G,C=,N=,P=,X=
         CP    COMPCNT,COUNT  WHEN EOF HAPPENS ANDTHE KEYS REMAINED
         BNL   KEYLESOK    EQUAL & THE RECORD COUNT IS LESS THAN THE
         AP    KEYLESS,PACKONE  PARM COUNT 1 MUST BE ADDED TO KEYLESS
KEYLESOK MVC   MSG4+9(5),MSGSPACE BLANK OUT 'KEY=' MSG
         MVC   INCARD,MSGSPACE
BYPENDF  BAL   GOREG,KEYREPT      PRINT REPORT LINE ON LAST KEY
ENDFILE  CLI   ENDFLAG,X'51'   DID PROCESSING END DUE TO E=
         BE    ENDMSG    YES
         CLI   VSAMFLAG,C'1'   IS VSAMKEY DDNAME USED
         BE    EOJ             YES- SKIP PUTTING OUT END MSG
PUTMSGR5 IC    R5,MSG5FLAG  NO-LOAD R5 WITH PROPER MSG.DEFAULT=MSG 5
         LNKMSG  R5
         SPACE 3
EOJ      B     CLS2NOP      SET TO NOP IF LIBOUT REQUESTED
         CLI   MSG5FLAG,X'52'   WAS COUNT SATIFIED MSG PRTED (MSG 82)
         BNE   LIBCONT          NO
         L     R1,=A(BLDENTRY)  YES- STOW THE LAST MEMBER
         MVC   0(8,R1),HIGHV    SET DIRECTORY ENTRY TO X'FF' (LAST)
         BAL   GOREG,LIBOTRTN   PERFORM LIBOUT RTN
LIBCONT  L     R1,=A(MEMBCNT)   GET COUNT OF NUM MEMBERS CREATED
         MVC   MEMCOUNT,0(R1)
         LNKMSG 94,EDIT=MEMCOUNT+3    PUT OUT MSG
CLS2NOP  B     CLS3NOP   THIS IS A SWITCH THAT IS NO-OPED IF SYSUT3
         LNKMSG 33,EDIT=OUTCT2+3        IS CODED
CLS3NOP  B     CLS4NOP
         LNKMSG 48,EDIT=OUTCT3+3
CLS4NOP  B     SKIPCLS
         LNKMSG 49,EDIT=OUTCT4+3
SKIPCLS  L     R2,DCBADDR
         CLI   GETLIB+1,SETNOP  WAS INPUT FILE LIBFILE
         BNE   CLOSE            NO
         MVI   DSORG(R2),X'40'  YES- RESET DSORG TO PS FOR EARLY END
CLOSE    MVI   KEYMSG,C'0' CLEAR OUT FLAG FOR PROPER CLOSE ON D OPTION
         L     R15,=A(DCBCSECT)   CLOSE ALL DCBS
         BALR  R14,R15
         SPACE 2
         L     R2,SAVESPIE
         SPIE  MF=(E,(2))    RESET THE OLD SPIE AND ESTAE ENVIRONMENTS
         ESTAE 0
         SPACE 2
EXIT     LH    R2,SETRC+2     PUT RC IN R2 (NEEDED FOR POSSIBLE ABE)
         LR    R5,R2          PUT RC IN R5 (FOR RC=ABEND,DUMP)
         LTR   R2,R2          IS RC=0?
SETRCDMP NOP   RCDUMP SET TO BNZ TO BOMB ON NON-0 RC WHEN RC=ABEND,DUMP
SETRCABE NOP   RCABEND     SET TO BNZ TO BOMB ON NON-0 RC WHEN RC=ABEND
         SPACE
         L     R13,SAVEAREA+4
         LM    R14,R12,12(R13)
SETRC    LA    R15,0              ERR RC=8 SET HERE FROM EOJERR
         BR    R14
         SPACE 2
NOSYSPRT L     R15,=A(DYNALLOC)   LOAD ADDRESS OF DYNALLOC CSECT
         BALR  R14,R15            BRANCH TO CSECT
         LTR   R15,R15      WAS SYSPRINT DYNAMICALLY ALLOCATED
         BZ    SYSPRINT     YES
         MVI   SETRC+3,X'FF' SET RETURN CODE TO 255 IF SYSPRINT MISSING
         B     EXIT                   GET OUT
         SPACE 1
DEFAULT  LA    R5,5        PUT PARM LENGTH OF 5 IN R5
         MVC   2(5,R3),=C'R,1,1'  PLACE DEFAULT R,1,1 OPTION IN PARM
         LNKMSG 7,BRANCH=PRNTPARM
         SPACE 3
ENDMSG   LNKMSG 81    PUT OUT MSG81, PROCESSING ENDED DUE TO E=
         CLI   MSG5FLAG,X'05'  ANY OTHER NON-STANDARD END CONDITION
         BNE   PUTMSGR5    YES - PUT OUT THAT MSG ALSO
         B     EOJ         NO
         TITLE 'CLASS TEST ROUTINES'
*        CLASS TEST ROUTINE AND RTN TO DO PACKED COMPARES FOR VP=
*        ON VP= WHEN PACKED FIELD IS NOT LEGITIMATELY PACKED THE
*        BRANCH TO SETINVAL WHICH CREATES A NOP COND CODE
*        WHICH WILL CAUSE A READ OF A NEW SYSUT1 KEY -- GOOD
*
LOWVTST  EX    R4,EXLOW           EXECUTE THE LOW VALUES TEST
         BNE   GOHIGHV            LOW VALUES NOT FOUND
         B     MAINLIN1           RETURN TO AFTER CLC
HIGHVTST EX    R4,EXHIGH          EXECUTE THE HIGH VALUES TEST
         BNE   GOALPHB            HIGH VALUES NOT FOUND
         B     MAINLIN1           RETURN TO AFTER CLC
ALPHBTST L     R15,=A(TRNSTAB1)    LOAD THE ADDRESS OF TRNSTAB1 TO R15
         EX    R4,TRNSLATE        R4=LENGTH-1,EXECUTE ALPHABETIC TEST
         BNZ   GONUMER            BRANCH BACK IF COND CODE NOT=0
MATCH    MVI   OUTPTKEY,C'Y'      FLAG INDICATES MATCH
         B     OUTPTTST           RETURN TO MAIN ROUTINE
NUMERTST L     R15,=A(TRNSTAB2)    LOAD THE ADDRESS OF TRNSTAB2 TO R15
         EX    R4,TRNSLATE        EXECUTE NUMERIC TEST
         BC    5,GOALPHN          BRANCH BACK IF COND CODE NOT=0 OR 2
         BZ    MATCH              COND CODE=0 MEANS KEY IS NUMERIC
         CLM   R2,1,FULL1+3    IS LAST FUNCTION BYTE = 1
         BNE   GOALPHN            NO
         B     MATCH              YES-KEY IS SIGNED NUMERIC
ALPHNTST L     R15,=A(TRNSTAB4)    LOAD THE ADDRESS OF TRNSTAB4 TO R15
         EX    R4,TRNSLATE        EXECUTE ALPHANUMERIC TEST
         BNZ   GOPACK          BRANCH BACK IF COND CODE NOT = 0
         B     MATCH           YES
PACKTST  L     R15,=A(TRNSTAB3)    LOAD THE ADDRESS OF TRNSTAB3 TO R15
         EX    R4,TRNSLATE     EXECUTE PACK TEST
         BC    X'D',SETINVAL   THE PACK TEST MUST RETURN A X'01'
         CLM   R2,1,FULL1+3   F BYT AS THE LAST BYTE TO INDIC A SIGN
         BNE   SETINVAL        SIGN BYTE NOT FOUND
PEQULNOP B     MATCH    NOP WHEN 'P=' KEY OPTION OR VP= REQ
         SLL   R4,4     SHIFT LENG TO HIGH ORDER HALF-BYTE FOR CP INSTR
         EX    R4,EXPEQUAL     EXECUTE THE COMPARE PACK TEST
         SRL   R4,4     RESTORE LENGTH   - DONT CHG CONDITION CODE
         B     MAINLIN1        RETURN TO AFTER THE CLC
NEQUTEST L     R15,=A(TRNSTAB2)    LOAD THE ADDRESS OF TRNSTAB2 TO R15
         EX    R4,TRNSLATE     IS INPUT KEY NUMERIC
         BC    5,SETINVAL      NO
         BZ    PACKNUMB        YES
         CLM   R2,1,FULL1+3   IS FINL 1/2-BYTE A LEGITIMATE SIGN
         BNE   SETINVAL            NO
PACKNUMB EX    R4,EXNEQUAL   PACK THE NUMERIC INPUT KEY
         CP    WORKFLD1,INCARD(8)  COMPARE PARM KEY TO FILE KEY PACKED
         B     MAINLIN1  RETURN TO AFTER THE CLC
         SPACE 2
SETINVAL CLI   FULL1+3,X'02' SET NOT EQUAL CONDITION. ACTUALLY BL WILL
*              BE TRUE SO THAT S,P=> OR S,N=> OR M,VP= WILL NOT CAUSE
*              THE SYSUT1 RECORD TO BE SELECTED. SETINVAL MODIFIED
*              TO BH TRUE WHEN S,P=< OR S,N=<.
         B     MAINLIN1     RETURN
         SPACE 2
TRNSLATE TRT   0(0,R3),0(R15)  R3=ADDR OF KEY. R15=ADDR OR APPROP TABLE
EXLOW    CLC   0(0,R3),LOWVALUE COMPARE TO LOWVALUES
EXHIGH   CLC   0(0,R3),HIGHV    COMPARE TO HIGHVALUES
EXPEQUAL CP    0(0,R3),INCARD(8) COMPARE PACKED ON P=
EXNEQUAL PACK  WORKFLD1,0(0,R3)   PACK KEY ON THE FILE ON N=
         TITLE 'DATA AREAS AND CONSTANTS'
MOVEMSGV DC    V(MOVEMSG)    ENTRY POINT OF PROGRAM FOR MESSAGE MVC
BRLNKLST DC   3F'0'    PRINT BUFFER ADDRESS,MESSAGE NUMBER
PRINTBUF DS    F                  SAVE ADDR OF NEXT PRINT BUFFER
MAXLEN   DC    F'0'               LRECL OF INPUT
MAXBLK   DS    F                 BLKSIZE OF INPUT
PARMEND  DS    F   STORE THE ADDRESS OF THE END OF THE PARM
SAVEREGS DS    F  USED TO SAVE R13 AND R14 IN THE DCB EXIT ROUTINE
SAVEADDR DS    A  USED IN V OPTION FOR TRT INSTRUCTION
SAVER4   DS    F    SAVE KEY LENGTH FOR AL,ML ON V RECS
SAVEVARL DS    F    SAVE KEY LENGTH
TABLE    DS    F            ADDRESS OF VS STORAGE GRABBED BY GETMAIN
TABLEND  DS    F            ADDRESS OF THE BYTE FOLLOWING END OF TABLE
DCBADDR  DS    F            ADDRESS OF LIBFILE/VSAMFILE/ISAM/INFIL DCB
DCBADDR2 DS    F ADDR OF PRIMARY INPUT FILE OR SYSIN FOR RECFM=U,L SUB
PUTADDR  DS    F            ADDRESS OF ISAM/INFIL RECORD AREA
SAVERBA  DC    F'-1'  RBA OF PREVIOUS VSAMKEY RECORD-INIT TO HIGHVAL
*        THE FOLLOWING 2 FLDS (RBA, VSAMRECL) MUST BE CONTIGUOUS
RBA      DS    F    RBA OF CURRENT VSAMKEY RECORD FROM SHOWCB
VSAMRECL DS    F  LRECL OF VSAMFILE/KEY KEY FROM SHOWCB
*
CARDADDR DS    F            ADDRESS OF CARDS RECORD AREA
LSAVEADR DS    F     ADDRESS OF PREVIOUS RECORD FOR L SUBOPTION
VPOSLENS DC    F'0'  POSITION OF KEY IN RECORD FOR L SUBOPTION
VLEN123  DC   3F'0'   USED TO STORE THE LENGTHS ON L SUBOPTION
*        NEXT FOUR AREAS MUST BE CONTIGUOUS FOR L SUBOPTION GETMAIN
LENGLIST DS    F     ADDR OF LENGTH OF KEY ON L SUBOPTION
         DC    X'80000000'   END OF LENGTH LIST
LKEYARE1 DS    F     ADDR OF SYSUT1 KEY ON L SUBOPTION-
LKEYARE2 DS    F     ADDR OF SYSIN KEY ON L SUBOPTION
DVCTYPE  DS    2F 2 WORDS RETURNED ON DEVTYPE MACRO-DEVICE TYP & MAXBLK
SAVESPIE DS    F          SAVE OLD SPIE HERE
ESTAPARM DC    A(BASES)   PARAMETER LIST FOR THE ESTAE MACRO
         DC    A(SAVEAREA) ADR OF CONTENTS OF BASE REGISTERS
         DC    X'80'
         DC    3X'00'
POSLENS  DC    24X'FF' COUNT,POSITION & LENGTH SAVED HERE-INIT TO HIGHV
POSDISPS DS    2F      CONTAINS P2-P1,P3-P2 FOR SYSUT1
VPOSDISP DS    2F      CONTAINS P2-P1,P3-P2 FOR SYSIN
ENDBIN   DS    F       USED TO STORE 2*(E= - B= - 1) FOR RANDOM OPT
INLRECL  DS    D LRECL CONVERTED TO DECIMAL HERE,ALSO USED AS KEYLEN(T)
INBLKSIZ DS    D   BLKSIZE CONVERTED TO DECIMAL HERE
RBEGIN   DS    D   BEGINNINGTO OUTPUT RECORDS ON R KEY
RSKIP    DS    D   SKIP FACTOR FOR R KEY
WORKFLD1 DS    D   USED TO PACK A NUMBER BY VERNUM  ROUTINE
PACKFLD  DS    D  USED TO PACK LRECL & BLKSIZE BY LABEL ROUTINE & T MSG
COUNT    DC    PL8'999999999999999'  INITIALIZED TO 10**15-1,CNT DEFLT
END      DC    PL8'999999999999999'  INITIALIZED TO 10**15-1,END DEFLT
EJEQCNT  DC    PL8'999999999999999'  INIT TO 10**15-1,E OPT CHG J= DFLT
BEGIN    DC    PL8'0'      USED FOR B= COUNTER
ENDCT    DC    PL8'0'      COUNT OF TOTAL RECS PASSED-USED FOR E=
SAVECNT  DC    PL8'0'      SAVE ENDCT HERE FOR L SUBOPT OPTIMIZATION
RCOUNT   DC    PL8'0'      COUNT USED FOR R MESSAGE AND T OPTION
OUTCT2   DC    PL8'0'      COUNT OF RECORDS NOT SELECTED
OUTCT3   DC    PL8'0'      COUNT OF RECORDS SELECTED  FROM SYSIN
OUTCT4   DC    PL8'0'      COUNT OF RECORDS NOT SELECTED  FROM SYSIN
PASSCT   DC    PL8'0'    THIS & THE NEXT FIELD,OUTCT,MUST BE CONTIGUOUS
OUTCT    DC    PL8'0'      COUNT OF RECORDS SELECTED FOR KEY
TOTPASCT DC    PL8'0'      COUNT OF RECORDS SELECTED FOR KEY
TOTOUTCT DC    PL8'0'      COUNT OF RECORDS SELECTED FOR KEY
SKIPCT   DC    PL4'0'      COUNT OF RECORDS SKIPPED FOR R KEY
COMPCNT  DC    PL8'0'    COUNT TO COMPARE RECORDS/KEY TO PARM COUNT
COMPCNTA DC    PL8'0'    COUNT NO OF RECORDS ON 1ST O KEY
COMPCNTB DC    PL8'0'    COUNT NO OF RECORDS ON 2ND O KEY
COMPCNTC DC    PL8'0'    COUNT NO OF RECORDS ON 3RD O KEY
KEYLESS  DC    PL8'-1'   NO OF TIMES RECS FOR A KEY LESS THAN PARM CNT
KEYMORE  DC    PL8'0'    NO OF TIMES RECS FOR A KEY MORE THAN PARM CNT
TOTLKEYS DC    PL8'0'    NUMBER OF KEYS ON THE FILE
MEMRECCT DC    PL8'0'    NUMBER OF RECORDS PER MEMBER
MEMCOUNT DC    PL8'0'    NUMBER OF MEMBERS CREATED BY LIBOUT
MAXRNDM  DC    PL8'5000' MAXIMUM NUMBER OF RANDOM NUMBERS TO BE GENERAT
WORKFLD  DS    CL16'RESERVE 16 BYTES' - USED TO HOLD OPTIONS AND SUBOPT
INCARD   DC    XL20'00'   INITIALIZE INCARD TO LOW VALUES FOR F & B
INCARD1  DC    XL20'00'
INCARD2  DS    CL20
SAVECARD DS    CL20        USED TO SAVE INCARD WHEN Y= OPTION REQUESTED
KEYAREA  DS   3CL20        SAVES UP TO 3 KEYS OF L=20 ON O OPTION
ECHGKEY  DS    CL40 SAVE AREA FOR 1ST E OPT SYSIN KEY AND CONVERT KEY
LOWVALUE DC    XL20'00'    LOW VALUES
HIGHV    DC    20X'FF'     HIGH VALUES
MSGCNT   DS    H             NUMBER OF MSGS FOR EXITS DD AND V OPTION
LOWVMSG  DC    C'LOW VALUES'
HIGHVALU DC    C'HIGH VALUES' THIS FLD AND MSGSPACE MUST BE CONTIGUOUS
MSGSPACE DC    CL30' '
DDN      DS    CL8         USED TO HOLD DDNAME FOR MSG 40
MEMBHOLD DS    CL8         HOLD AREA FOR MEMBER NAME ON V OPTION
SAVEDCB  DS    5X          SAVE LRECL AND RECFM HERE ON V= ROUTINE
SYSINFVU DS    C           SAVE RECFM OF SYSIN HERE(F,V,U ONLY)
INRECFM  DS    CL1         INPUT RECORD TYPE
INRECFM2 DS    CL1         INPUT RECFM
OUTRECFM DS    CL1         OUTPUT RECFM
SYSUTX   DS    CL1
SYSUT    DC    C'2'        USED TO DETERMINE WHICH SYSUTX IS BEING USED
CRYPTWK  DS    CL6    USED IN ENCRYPTION RTN
MSG1CLS  DC    CL6' '      USED FOR CLASS MSG
MSG5FLAG DC    X'05'       SET DEFAULT FOR MSG 5
ENDFLAG  DC    X'00'       SET TO X'51' WHEN PROCESSING ENDS DUE TO E=
VSAMFLAG DC    C' '        FLAG TO INDICATE DDNAME VSAMKEY IS USED=1
MSG44BLK DC    CL7'BLKSIZE'
*MSG65LBL DC    CL80' '     HOLDS LABEL ON TAPELABL OPTION     @MK1
PARMERR1 DC    C' '
KEYMSG   DC    C'3'
OPENERR  DC    C'0'  OPENERR=0 NO OPEN ERR, 1 MEANS IEC OPEN MSG
NUMBERR  DC    C' ' SPACE IS VALID  1 IS INVALID
ENDPARMS DC    C' '  END OF PARM FIELD FLAG='1',END OF SYSIN/SYSUT1='2'
PACKFLAG DC    C' '   WAS 'P=' OR 'N=' USED
SAVEFLAG DS    CL1    USED TO SAVE PACKFLAG WHEN Y= OPTION REQUESTED
MATCHFIL DC    C' '     FLAG TO DETERMINE IF M OR T OPTION REQ ON V=
SYSINFLG DC    C'0'     FLAG TO
MEMFLAG  DC    C'0'     FLAG TO INDICATE IF MEMSYSIN DD CODED
OPENBACK DC    C' '
SORTDONE DC    C'0'  FLAG TO INDICATE THAT SORT OF RANDOM NUMBS IS DONE
VLENGTH  DC   2X'00' LENGTH OF THE SYSIN KEY ON V= SUBOPTION IN BNARY
PEVENODD DC    X'00'  USED IN AN EXCLUSIVE OR TO ADD TO MAX ON ODD KEYS
OUTPTKEY DC    C'N'        FLAG TO INDICATE IF MATCH ON CLASS KEY
KEYINDIC DC    C'0' INDICATE WHETHER LOW OR HIGH KEY WAS LAST READ ON B
DCOUNT   DC    PL4'1' CHANGED BY XO DOPTION=NNN, NTH OCCURENCE OF KEY
VOLSERCT DC    PL2'1' COUNT NUMBER OF VOLSERS ON VOL= IN SYSIN -V OPT
NUMLABLS DC    P'0'  USED TO COUNT NUMBER OF LABELS ON TAPELABL ROUTINE
PACKZERO DC    P'0'    CONSTANT PACKED 0
PACKONE  DC    P'1'    CONSTANT PACKED 1
SETBAL   DC    XL2'4580'   CHANGE NOP TO BAL GOREG,.....
MSGMASK  DC    X'40202020202020212021'  TO REST MASKS
CNVRTCOD DS    CL4    CONVERT CODE
LKEYADDR DS    A     SAVE ADDR OF KEY ON L SUBOPTION AND CONVERT FILE
LKEYADR2 DS    A     SAVE ADDR OF KEY ON L SUBOPTION AND CONVERT FILE
SAVRCNT  DC    PL8'-1'  SAVED COUNT OF NUMBER OF SYSIN RECORDS (CNVRT)
FULL1    DC    F'1'
FULL4    DC    F'4'
FULL6    DC    F'6'
FULL8    DC    F'8'
FULL15   DC    F'15'
FULL20   DC    F'20'
SEED     DC    F'8193' DFLT SEED USED IN RANDOM OPTION
FREELEN  DC    X'80',AL3(24024) DEFLT LENG FOR E,T,P,G FREEM-MOD BY R
*VSMKEYL MUST BE DEFINED AS S-CON FOR GENCB MACRO & EXTENDED TO F-WORD
VSAMKEYL DS    S,H  FULLWORD FOR VSAMKEY GENERIC KEY LEN
VSOUTRPL DS    F    VSAMOUT RPL ADDR
         SPACE 2
ACONVERT DC    A(CONVERT)
AISAM    DC    A(ISAM)
ALIBRARY DC    A(LIBRARY)
AVSYSIN  DC    A(VSYSIN)
AMEMBNAM DC    A(MEMBNAME)
AINFIL   DC    A(INFIL)
AOUTFIL  DC    A(OUTFIL)
ALIBOUT  DC    A(LIBOUT)
AOUTFIL2 DC    A(OUTFIL2)
AOUTFIL3 DC    A(OUTFIL3)
AOUTFIL4 DC    A(OUTFIL4)
ASYSIN   DC    A(CARDS)
ASNAPDMP DC    A(SNAPDUMP)
ASYSPRNT DC    A(PRINT)
         TITLE 'INFORMATIONAL AND ERROR MESSAGES'
MSG4     DC    C'0SEL004I KEY= '
MSG4KEY  DS    CL20
MSG4PASS EQU   *-MSG4
MSG4ED   DC    X'4020202020202020202020202020212021'
         DC    C'RECORDS PASSED,'
         DC    X'222020202020202020202020202120'
MSG4EDIT EQU   *-MSG4ED
         DC    C' RECORDS OUTPUT '
MSG4MAX  DC    CL3'   '
MSG4LEN  EQU   *-MSG4
MSG21    DC    C'0SEL021I KEY= '  E,F,C,O,G & T MSG
MSG21KEY DC    CL20' '
         DC    C' NUMBER OF RECORDS SELECTED='
MSG21ED  DC    X'40202020202020212021'
MSG21LEN EQU   *-MSG21
MSG23    DC    C'0SEL023I RECORD NUMBER = '   Q MSG - OUT OF SEQUENCE
MSG23ED  DC    X'40202020202020212021'
         DC    C',KEY ='
MSG23CKY DC    CL21' '
         DC    C'PREVIOUS KEY ='
MSG23PKY DC    CL20' '
MSG23LEN EQU   *-MSG23
MSG26    DC    C'0SEL026I '             R MSG
MSG26OUT DC    X'40202020202020212021'
         DC    C' RECORDS OUTPUT FROM RECORD'
MSG26BEG DC    X'40202020202020212021'
         DC    C'. SKIP FACTOR ='
MSG26SKP DC    X'40202020202020212021'
         DC    C' '
MSG26LEN EQU   *-MSG26
MSG29    DC    C'0SEL029I LOW KEY ='  P & B (RANGE)  KEY MSG
MSG29LKY DC    CL20' '
         DC    C',HIGH KEY ='
MSG29UKY DC    CL20' '
MSG29PAS DC    X'40202020202020212021'
         DC    C' RECORDS PASSED'
MSG29OUT DC    X'40202020202020212021'
         DC    C' RECORDS OUTPUT'
MSG29LEN EQU   *-MSG29
MSG34    DC    C'0SEL034I KEY= '   DEBUG MESSAGE
MSG34KEY DC    CL20' '
         DC    C'LOCATED IN RECORD'
MSG34LOC DC    X'40202020202020212021'
         DC    C'.RECORDS OUTPUT= '
MSG34OUT DC    X'40202020202020212021'
         DC    C',BEGINNING AT RECORD'
MSG34BEG DC    X'40202020202020212021'
MSG34LEN EQU   *-MSG34
MSG36    DC    C'0SEL036I '          E,T,P & G MESSAGE
MSG36OUT DC    X'402020202120'   CANT EXCEED 4800
         DC    C' SYSIN RECORDS ALLOWED,'
MSG36ED  DC    X'402020212021'  EDIT MAST
         DC    C'  READ/GENERATED AND USED'
MSG36LEN EQU   *-MSG36
MSG40    DC    C'0SEL040I         - DSORG='
MSG40ORG DC    C'IS,RECFM='
MSG40FVU DC    CL3' '
         DC    C',LRECL='
MSG40REC DC    X'402020202120'
         DC    C',BLKSIZE='
MSG40BLK DC    X'402020202120'
         DC    C',VOLSER='
MSG40VOL DC    CL6' '
         DC    C',DSN='
MSG40DSN DC    CL44' '
MSG40LEN EQU   *-MSG40
MSG62    DC   C'0SEL062I '
MSG62KEY DC   CL16' '
MSG62MSG DC   CL13'ERROR'
MSG62LEN EQU  *-MSG62
MSG85    DC    C'0SEL085I         - DSORG=PS,RECFM='
MSG85FVU DC    CL3' '
         DC    C',LRECL='
MSG85REC DC    X'402020202120'
         DC    C',BLKSIZE='
MSG85BLK DC    X'402020202120'
         DC    C',VOLSER='
MSG85VOL DC    CL6' '
         DC    C',DSN='
MSG85DSN DC    CL44' '
MSG85LEN EQU   *-MSG85
MSG88    DC    C'0SEL088I'
MSG88CNT DC    X'40202020202020202020202020212021'
         DC    C' OCCURRENCES OF '
MSG88KEY DC    CL20' '
         DC    C' CHANGED TO '
MSG88CHG DC    CL20' '
MSG88LEN EQU   *-MSG88
MSG93    DC    C'0SEL093I MEMBER = '
MSG93MEM DC    CL8' '
         DC    C', NUMBER OF RECORDS SELECTED = '
MSG93ED  DC    X'40202020202020212021'
MSG93LEN EQU   *-MSG93
         TITLE 'REGISTER ASSIGNMENTS AND GETTING THE COMPILE DATE'
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
GOREG    EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE 2
KEYLE    EQU   16
DSORG    EQU   26
RECFM    EQU   36
BLKSIZE  EQU   62
LRECL    EQU   82
         SPACE 2
SETNOP   EQU   X'00'
SETBH    EQU   X'20'
SETBL    EQU   X'40'
SETBNE   EQU   X'70'
SETBE    EQU   X'80'
SETBR    EQU   X'F0'
RECFMF   EQU   X'80'
BLANK1   EQU   C' '
         TITLE 'THE LITERL POOL'
         LTORG
         TITLE 'THE PARM FLD,THE DCBD,TIOT AND RELAT,SDWA, JFCB MACROS'
         IEFJFCBN        PULL IN THE JFCB MAPPING MACRO
         DCBD  DSORG=(IS,PO,PS,XE)   PULL IN DCB DSECT
         IEFTIOT1         PULL IN TIOT MAPPING MACRO
         IHAPSA           PULL IN PSA MAPPING MACRO (FOR TIOT)
         IKJTCB           PULL IN TCB MAPPING MACRO (FOR TIOT)
         IEZJSCB          PULL IN JSCB MAPPING MACRO (FOR TIOT)
         PRINT GEN
         IHAQDB           PULL IN QDB MAPPING MACRO (FOR TIOT)
         PRINT NOGEN
         IHADSAB          PULL IN DSAB MAPPING MACRO (FOR TIOT)
         IHASDWA          PULL IN SYSTEM DIAGNOSTIC WORK AREA
PARMDS   DSECT
NUMBPARM DS    H       THE NUMBER OF CHARACTERS IN THE PARM FIELD
DATAPARM DS    CL100   DATA ENTERED IN PARM PARAMETER OF THE EXEC CARD
         TITLE ' CLOSE, FREEPOOL, AND DCB CSECT'
*        THIS CSECT CONTAINS ALL THE PROGRAM DCBS EXCEPT FOR MEMSYSIN
*        THIS CSECT ALSO PERFORMS THE CLOSE ON ALL THE DCBS IT CONTAINS
*        THIS CSECT FREEPOOLS THE BUFFER POOLS OF ALLOCATED FILES AND
*             ALSO FREEMAINS  E,G,T,P TABLE, L
*             SUBOPTION RECORD AREAS AND LIBFILE AND LIBOUT BUFFERS.
*        R2- CONTAINS DCB ADDR OF THE PRIMARY INPUT FILE
*        R3- BASE REGISTER
*        GOREG- BAL REGISTER
*        R14- RETURN ADDR, R15-ADDR OF THIS CSECT
DCBCSECT CSECT
         BALR  R3,0    SET UP R3 AS BASE
         USING *,R3
         ST    R14,SAVERET        SAVE R14 FOR RETURN
         L     R4,=A(KEYMSG)      IS THIS THE D OPTION
         CLI   0(R4),C'8'         WHERE THE KEY WAS FOUND
         BE    CLOSFREE           YES- CLOSE, FREEPOOL AND GET OUT
         C     R2,=A(INFIL) SKIP FOR VSAMXXX,LIBFILE, V OPT,ETC
         BNE   NOTINFIL    NO
         BAL   GOREG,CLOSFREE FREE BUFFR STORAGE POOL FOR THE INPUT
NOTINFIL C     R2,=A(ISAM)
         BNE   NOTISAMF
         BAL   GOREG,CLOSFREE FREE BUFFR STORAGE POOL FOR THE INPUT
NOTISAMF L     R2,=A(VSAMFLAG)
         CLI   0(R2),C' '    WAS VSAMXXX CODED
         BE    NOTVSKY       NO -ITS NEITHER VSAMFILE NOR VSAMKEY
         L     R4,=A(ACBVSIN) GET VSAMFILE/KEY ACB ADDR
         CLOSE ((R4))             CLOSE VSAM FILE
         FREEMAIN LU,LA=VSRECLN,A=VSRECADR  FREE THE VSAM REC WKAREA
NOTVSKY  L     R2,=A(VSOUTRPL)   CHECK VSOUTRPL FOR RPL OF VSAMOUT
         ICM   R2,15,0(R2)   WAS VSAMOUT CODED
         BZ    NOTVSOUT      NO
         L     R4,=A(ACBVSOUT) GET VSAMOUT ACB ADDR
         CLOSE ((R4))             CLOSE VSAMOUT
*        COMMENTED OUT SINCE NSR IS BEING USED
*        CLI   0(R2),C'1'    WAS VSAMKEY CODED
*        BNE   NOTVSKY       NO
*        DLVRP TYPE=LSR      YES- DELETE THE LSR RESOUCRE POOL
NOTVSOUT LA    R2,CARDS
         BAL   GOREG,CLOSFREE
         LA    R2,OUTFIL
         BAL   GOREG,CLOSFREE
         LA    R2,OUTFIL2
         BAL   GOREG,CLOSFREE
         LA    R2,OUTFIL3
         BAL   GOREG,CLOSFREE
         LA    R2,OUTFIL4
         BAL   GOREG,CLOSFREE
         LA    R2,CONVERT
         BAL   GOREG,CLOSFREE
         LA    R2,MEMBNAME
         BAL   GOREG,CLOSFREE
         LA    R2,MERGE
         BAL   GOREG,CLOSFREE
         CLOSE (SNAPDUMP)    <=======  THIS IS A BSAM (NOT QSAM) FILE
*        BAL   GOREG,CLOSFREE          CANT ISSUE THE FREEPOOL
         LA    R2,VSYSIN
         BAL   GOREG,CLOSFREE
         LA    R2,PRINT CLOS PRNT LAST IN CASE OF B37 BOMB ON ABV CLOSE
         BAL   GOREG,CLOSFREE
         SPACE 1
         L     R2,=A(CONCATLN)
         LH    R2,0(0,R2)       GET LENGTH OF MERGE FILE RECORD
         LTR   R2,R2            IS IT 0 -
         BZ    SKIPFRE0         YES
         FREEMAIN E,LV=(2),A=SUMRECAD  FREE THE BUFFER
SKIPFRE0 EQU   *
         L     R2,=A(TABLE)
         CLC   0(4,R2),=X'00000000' DID WE GET A TABLE FOR E,G,P,T OR R
         BE    SKIPFRE1         NO
         FREEMAIN LU,LA=FREELEN,A=TABLE   YES
SKIPFRE1 L     R2,=A(LENGLIST)   DID WE GETMAIN A TABLE FOR L SUBOPTION
         CLC   0(4,R2),=X'00000000' DID WE GET A TABLE FOR L SUBOPTION
         BE    SKIPFRE2         NO
         FREEMAIN LU,LA=LENGLIST,A=LKEYARE1 YES
SKIPFRE2 EQU   *
         L     R2,=A(LENGTHSV)       IS LIBFILE USED
         ICM   R2,15,0(R2)         GET LIBFILE BLKSIZE USED IN GETMAIN
         BZ    SKIPFRE3              NO LIBFILE BUFFER
         CLOSE (LIBRARY)             CLOSE LIBFILE
         FREEMAIN E,LV=(2),A=INBUFF
         L     R2,=A(SVBLKSIZ)
         LH    R2,0(R2)        WAS LIBOUT REQUESTED
         LTR   R2,R2               BLKSIZE=0 MEANS NO
         BZ    SKIPFRE3              NO
         CLOSE (LIBOUT)           YES- CLOSE LIBOUT PDS
         FREEMAIN E,LV=(2),A=OUTBUFF   FREE BUFFERS
SKIPFRE3 EQU   *
         L     R2,=A(EXITBLDL+4)    DELETE THE LAST EXIT ONLY
         CLC   0(8,R2),=CL8' '      IS THERE A MODULE NAME IN BLDL
         BE    SKIPDEL              NO
         DELETE DE=(R2)             YES
SKIPDEL  EQU   *
         SPACE 2
         L     R14,SAVERET      RELOAD R14 WITH RETURN
         BR    R14
         SPACE 2
CLOSFREE CLOSE ((R2))
         LTR   R15,R15
         BNZR  GOREG
         FREEPOOL (R2)
         BR    GOREG
         SPACE 1
SAVERET  DS    F            SAVE R14 HERE
         LTORG
         DROP  R3
         TITLE 'DCBS'
PRINT    DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,RECFM=FBA,LRECL=133,  X
               BLKSIZE=1330,EXLST=JFCBXLST
         DS    0F
ISAM     DCB   DDNAME=ISAMFILE,DSORG=IS,MACRF=GL,                      X
               EXLST=INPTXLST,SYNAD=SYNADERR,EODAD=ENDINPUT
         DS    0F
LIBRARY  DCB   DDNAME=LIBFILE,DSORG=PS,MACRF=RP,BLKSIZE=0,             X
               EXLST=INPTXLST,SYNAD=SYNADERR,EODAD=ENDMEM
         DS    0F
INFIL    DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=GL,BLKSIZE=0,              X
               EXLST=INPTXLST,SYNAD=SYNADERR,EROPT=ACC,EODAD=ENDINPUT
         DS    0F
CARDS    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,BLKSIZE=0,               X
               EXLST=INPTXLST,EODAD=ENDKEYS,EROPT=ACC,SYNAD=SYNADERR
         DS    0F
VSYSIN   DCB   DDNAME=VSYSIN,DSORG=PS,MACRF=GL,BLKSIZE=0,RECFM=FB,     X
               EODAD=ENDKEYS,EROPT=ACC,SYNAD=SYNADERR
         DS    0F
SNAPDUMP DCB   DDNAME=SYSOUX,DSORG=PS,MACRF=W,RECFM=VBA,LRECL=125,     X
               BLKSIZE=1632,EXLST=JFCBXLST
         DS    0F
OUTFIL   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=PM,BLKSIZE=0,              X
               EXLST=EXLSTDCB,SYNAD=SYNADERR
         DS    0F
LIBOUT   DCB   DDNAME=LIBOUT,DSORG=PO,MACRF=W,BLKSIZE=0,               X
               EXLST=EXLSTDCB,SYNAD=SYNADERR
         DS    0F
OUTFIL2  DCB   DDNAME=SYSUT3,DSORG=PS,MACRF=PM,BLKSIZE=0,              X
               EXLST=EXLSTDCB,SYNAD=SYNADERR
         DS    0F
OUTFIL3  DCB   DDNAME=SYSUT4,DSORG=PS,MACRF=PM,BLKSIZE=0,              X
               EXLST=EXLSTDCB,SYNAD=SYNADERR
         DS    0F
OUTFIL4  DCB   DDNAME=SYSUT5,DSORG=PS,MACRF=PM,BLKSIZE=0,              X
               EXLST=EXLSTDCB,SYNAD=SYNADERR
         DS    0F
MEMBNAME DCB   DDNAME=MEMBNAME,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=8,     X
               BLKSIZE=0,SYNAD=SYNADERR,EXLST=JFCBXLST
         DS    0F
CONVERT  DCB   DDNAME=CONVERT,DSORG=PS,MACRF=GL,BLKSIZE=0,             X
               SYNAD=SYNADERR,EODAD=EOFCNVRT,EROPT=ACC
         DS    0F
MERGE    DCB   DDNAME=MERGE,DSORG=PS,MACRF=PM,BLKSIZE=0,               X
               SYNAD=SYNADERR,EXLST=MERGXLST
         TITLE 'VSAM CONTROL BLOCKS AND INTERFACE'
*        THIS CSECT GETS A VSAM FILE READY FOR OPENING
*                     VIA--EXLST,ACB AND RPL MACROS
*        THE LINKAGE CONVENTIONS ARE-
*        R2-CONTAINS THE ACB ADDR ON ENTRY AND EXIT FROM CSECT-FOR OPEN
*        R5-PASSES TO THE MAIN PROG THE ADDR OF THE RPL FOR THE GET
*        R14-RETURN REG
*        FOR VSAMKEY:
*        R6- BSAE FOR THE SHOWCAT DSECT
*        R10,R11- WORK REGISTERS
*        R7- BCT REGISTER FOR SEARCHING CATALOG ASSOC TYPES
*        R9- BAL REG
*
*        VSAMFILE SHOULD BE USED FOR ESDS FILES
*        SINCE THE FILE IS PROCESSED PHYSICALLY SEQUENTIALLY
*        DDNAME VSAMKEY IS BE USED FOR KSDS AND RRDS
*        FILES. THE FILE IS PROCESSED BY KEY OR RELATIVE RECORD
*        NUMBER (RRDS). HOWEVER, FOR KSDS,IF THE FIELD BEING SELECTED/
*        MATCHED ON IS NOT THE KEY DEFINED FOR THE KSDS THEN IT IS
*        MORE EFFICIENT TO USE THE VSAMFILE DDNAME AND PROCESS THE FILE
*        PHYSICAL SEQ RATHER THAN THRU THE INDEX TO CUT DOWN ON THE
*        AMOUNT OF I/O. THE INDEX IS ONLY HELPFUL WHEN PROCESSING THE
*        FILE THRU THE DEFINED KEY. VSAMKEY MUST BE USED FOR RRDS.
VSAMSECT CSECT
         USING *,R15
         STM   R6,R14,SAVEAREH   SAVE MAIN CSECT BASE REGISTERS
         CNOP  0,4
         BAL   R3,JUMPSAV8
SAVEAREH DS    9F
JUMPSAV8 EQU   *
         USING SAVEAREH,R3
         DROP  R15
*        BUILD VSAM RESOURCE POOL FOR LOCAL SHARED RESOURCES
*        ALLOW 4 BUFFERS FOR DATA CI & 15 FOR INDEX CISIZE
*        OBTAIN THE ACTUAL DATA AND INDX CISIZE AND KEYLEN FROM SHOWCAT
*        BLDVRP ALLOWS ONLY 512,1K,2K,4K,N*4K UP TO 32K AS BUFF SIZES
*        SET BLDVRP DEFAULTS AS DATA/INDX CISIZE=512, KEYLEN=20
         MVC   PHONYDCB+DCBDDNM(8),ACBDDNM(R2) MOVE IN VSAMXXX DDNAME
         RDJFCB (PHONYDCB)  READ THE PHONY DCB SET UP FOR THE VSAM FILE
         MVC   VSAMDSN,JFCBAREA+0  TO OBTAIN THE CLUSTER NAME
         L     R11,=A(MSG40DSN)
         MVC   0(44,R11),VSAMDSN   MOVE VSAM CLUSTER NAME TO MSG40
         L     R11,=A(MSG40VOL)
         MVC   0(6,R11),JFCBAREA+118 MOVE VSAM CLUSTER VOLSER TO MSG40
SHOWCAT  SHOWCAT AREA=CATINFO1,NAME=VSAMDSN GET OBJ TYPE,ACB AND CI NO.
         LTR   R15,R15     ERROR?
         BNZ   CATERR      YES
         USING SHWOUT,R6       MAKE SHOWCAT OUTPUT DSECT ADDRESSABLE
         LA    R6,CATINFO1
         CLI   SHWTYPE,C'C'        IS THIS A CLUSTER CATALOG RECORD
         BE    GETDI         YES- NOW GET THE DATA/INDX COMPONENT REC
         CLI   SHWTYPE,C'G' NO-IS IT AN ALT. INDX-GET ITS DATA/INDX REC
         BNE   VSAMRET   FALL THRU ERR-RETURN TO MAINLINE, BOMB ON OPEN
GETDI    MVC   CATACB,SHWACBP   SAVE ACB ADDR
         USING SHWASSOC,R6   SET ADDRESSABILITY FOR SHOWCAT ASSOC DSECT
         LA    R6,SHWASS0-SHWOUT(R6)
         LH    R7,SHWACT        GET COUNT OF CAT ASSOC RECS
GETDSZ   CLI   SHWATYPE,C'D'    IS THIS THE DATA COMPON ASSOC
         BE    DCISIZE          YES- ISSUE SHOWCAT TO GET DATA CISIZE
         LA    R6,4(R6)         NO- ADD 4 TO BASE TO POINT TO NXT ASSOC
         BCT   R7,GETDSZ        LOOP UNTIL FIND DATA COMPON ASSOC
         B     VSAMRET  FALL THRU ERR-RETURN TO MAINLINE, BOMB ON OPEN
         SPACE 2
DCISIZE  MVC   CATCINUM,SHWACI
         L     R11,CATACB
         SHOWCAT ACB=(R11),AREA=CATINFO2,CI=CATCINUM
         LTR   R15,R15     ERROR?
         BNZ   CATERR      YES
         USING SHWOUT,R6   RESET ADDRESSABILITY FOR SHOWCAT OUTPT DSECT
         LA    R6,CATINFO2   RESET SHOWCAT BASE REGISTER
         ICM   R11,15,SHWMREC    GET MAX LRECL OF DATA COMPONENT
         L     R10,=A(MAXLEN)   PLACE LRECL IN MAXLEN TO INSURE THE
         ST    R11,0(R10)       L+P DOES NOT EXCEED LRECL
         CVD   R11,VSWORK        CONVERT TO DECIMAL
         LA    R11,4(R11)   ADD 4 TO MAX LRECL FOR OUTPUT FILE RECFM=V
         STCM  R11,7,VSRECLN+1 TO GETMAIN A WORKAREA OF THAT SIZE
         L     R11,=A(MSG40REC)  GET MSG40 LRECL FLD
         ED    0(6,R11),VSWORK+5   EDIT LRECL INTO MSG40
         ICM   R11,15,SHWCISZ    GET DATA CISIZE
         CVD   R11,VSWORK        CONVERT TO DECIMAL
         L     R11,=A(MSG40BLK)  GET MSG40 BLKSI FLD
         ED    0(6,R11),VSWORK+5   EDIT LRECL INTO MSG40
         SPACE 1
         CLC   PHONYDCB+DCBDDNM(8),ACBVSOUT+ACBDDNM
         BE    VSAMOUT
         SPACE 1
         GETMAIN LU,LA=VSRECLN,A=VSRECADR  GET WORK AREA FOR INPUT VSAM
         SPACE 1
         CLC   PHONYDCB+DCBDDNM(8),ACBVSK+ACBDDNM
         BNE   VSAMFILE         NO
         SPACE 1
*        THE FOLLOWING CODE IS COMMENTED OUT SINCE FOR BATCH JOBS
*        ITS SEEMS THAT NSR(NON-SHARED RESOURCES) WITH BUFND=4,BUFNI=15
*        USES LESS CPU TIME THAN LSR WITH SIMILAR BUFFER POOLS ALLOCATD
*        ALTHOUGH NSR USES MORE REGION
         SPACE 2
*        BAL   R9,ROUNDCI  GET THE DATA CISIZE AND ROUND IT FOR BLDVRP
*        ST    R11,BLDVRP+60 ST DATA CISIZE (ROUNDED) INTO BLDVRP EXPAN
*        CLC   SHWKEYLN,=H'19'  IS KEYLEN GREATER THAN 19
*        BH    BYPKYLMV         YES - DEFAULT TO 20
*        MVC   BLDVRP+16(1),SHWKEYLN+1 NO-MV IN ACTUAL KEYLEN TO BLDVRP
*YPKYLMV LA    R6,CATINFO1   POINT TO PRIMARY CATLG AREA
*        USING SHWASSOC,R6   SET ADDRESSABILITY FOR SHOWCAT ASSOC DSECT
*        LA    R6,SHWASS0-SHWOUT(R6)
*        LH    R7,SHWACT     RELOAD NUMBER OF ASSOCIATIONS
*GETISZ  CLI   SHWATYPE,C'I'  SEARCH FRO INDX COMPON
*        BE    ICISIZE        FOUND IT
*        LA    R6,4(R6)
*        BCT   R7,GETISZ
*        B     VSAMRET       BRANCH BACK TO MAINLINE -ERR ON OPEN
*ICISIZE MVC   CATCINUM,SHWACI
*        L     R11,CATACB
*        SHOWCAT ACB=(R11),AREA=CATINFO2,CI=CATCINUM
*        LTR   R15,R15     ERROR?
*        BNZ   CATERR      YES
*        USING SHWOUT,R6   RESET ADDRESSABILITY FOR SHOWCAT OUTPT DSECT
*        LA    R6,CATINFO2   RELOAD SHOWCAT DSECT ADDR
*        BAL   R9,ROUNDCI    GET THE INDX CISIZE
*        ST    R11,BLDVRP+68  STORE INDX CISIZE INTO BLDVRP
*        CNOP  0,4   ALIGN BLDVRP ON FULLWORD FOR MODIFY
*BLDVRP  BLDVRP BUFFERS=(512(3),512(15)),KEYLEN=20,STRNO=1,TYPE=LSR
         SPACE 2
         LA    R2,ACBVSK ADDR OF THE ACB FOR THE OPEN AND THE RPL
         ST    R2,ACBVSIN     SAVE INPUT ACB ADDR
         LA    R5,RPLVSK ADDR OF THE REQUEST PARAM LIST FOR THE GET
         SPACE 2
VSAMRET  LM    R6,R14,SAVEAREH    RESTORE REGISTERS
         BR    R14
         SPACE 2
*ROUNDCI ICM   R11,15,SHWCISZ    LOAD CISIZE (DATA/INDX) INTO R11
*        LA    R10,0          CLEAR R10 IN PREP FOR DIVIDE
*        D     R10,=F'1024'   DIVIDE CISIZE BY 1K
*        LTR   R11,R11        IS QUOTIENT=0
*        BZ    CI512          YES- SET CISIZE TO 512
*        LTR   R10,R10        IS REMAINDER=0
*        BZ    BUFTRAN        YES- GO DIRECTLY TO TRANSLATE (ROUND UP)
*        LA    R11,1(R11)     ADD 1 TO QUOTIENT (ROUND UP 1 FIRST)
*BUFTRAN STC   R11,BUFSZK
*        TR    BUFSZK,BUFTRTAB
*        IC    R11,BUFSZK
*        SLA   R11,10         MULTIPLY ROUNDED RESULT BY 1K
*        BR    R9             RETURN
*        SPACE 1
*CI512   LA    R11,512        SET CISIZE TO 512
*        BR    R9
         SPACE 3
*        VSAMFILE (NOT VSAMKEY)
VSAMFILE LA    R2,ACBVSF ADDR OF THE ACB FOR THE OPEN AND THE RPL
         ST    R2,ACBVSIN     SAVE INPUT ACB ADDR
         LA    R5,RPLVSF ADDR OF THE REQUEST PARAM LIST FOR THE GET
         B     VSAMRET
         SPACE 2
VSAMOUT  LA    R2,ACBVSOUT ADDR OF ACB FOR THE OPEN AND THE RPL
         LA    R5,RPLVSOUT ADDR OF REQUEST PARAM LIST FOR THE GET
         L     R10,=A(MAXLEN)    FOR NON-VSAM RECFM=F INPUT FILE
         L     R10,0(R10)        SET LRECL  FOR VSAMOUT
* AND ALSO THE MAX LRECL FOR THE AREA LENGTH OF THE RECORD WORK AREA
         MODCB RPL=(R5),RECLEN=(R10),AREALEN=(R10)
         OPEN  ((R2),OUTPUT)    OPEN VSAMOUT - ACB ADDRESS IN R2
         B     VSAMRET
         DROP  R3
         SPACE 5
ACBVSIN  DS    F
EXLSTVSK EXLST AM=VSAM,EODAD=ENDINPUT
         DS    0F
ACBVSK   ACB   AM=VSAM,DDNAME=VSAMKEY,EXLST=EXLSTVSK,                  X
               BUFND=4,BUFNI=15,       <======== NSR                   X
               MACRF=(KEY,SEQ)   LSR)  <======== LSR NOT USED
*        KEY SEQUENTIAL ACCESS USED WITH POINT MACRO (SIMULAT SKIP-SEQ)
*        SEARCH ARGUEMENT BUILT FROM SYSIN FILE IN INCARD.
*        LENGTH OF KEY IN S-CON VSAMKEYL MOVED IN BY MODCB.
*        FILE WILL BE POSITIONED AT THE NEXT KEY WHICH IS GREATER THAN
*        OR EQUAL TO THE SEARCH ARG.
         DS    0F
RPLVSK   RPL   AM=VSAM,ACB=ACBVSK,AREA=PUTADDR,AREALEN=4,              X
               OPTCD=(KEY,SEQ,LOC,KGE,GEN),ARG=INCARD
*              KEYLEN=(*,VSAMKEYL)  <===== SUPPLIED BY A MODCB MACRO
         DS    0F
ACBVSF   ACB   AM=VSAM,DDNAME=VSAMFILE,EXLST=EXLSTVSK,MACRF=ADR
         DS    0F
RPLVSF   RPL   AM=VSAM,ACB=ACBVSF,AREA=PUTADDR,AREALEN=4,              X
               OPTCD=(ADR,LOC)
         DS    0F
ACBVSOUT ACB   AM=VSAM,DDNAME=VSAMOUT,MACRF=(KEY,SEQ,OUT),             X
               BUFND=4,BUFNI=15 <=== NSR (CANT USE LSR ON EMPTY FILE)
         DS    0F
*        KEY SEQUENTIAL ACCESS
* RECLEN- LENGTH OF OUTPUT REC SUPPLIED BY CONTROL BLOCK MANIPULAT RTN
* AREA  - AREA ADDR WILL BE UPDATED BEFORE PUT BY A MODCB
* AREALEN-AREALEN WILL BE SUPPLIED BY A MODCB MACRO ABOVE
RPLVSOUT RPL   AM=VSAM,ACB=ACBVSOUT,OPTCD=(KEY,SEQ,MVE)
         DS    0F
PHONYDCB DCB   DDNAME=VSAMXXX,DSORG=PS,MACRF=GL,EXLST=VSAMXLST
VSAMXLST DS    0F
         DC    X'87',AL3(JFCBAREA)   JFCB EXIT
JFCBAREA DS    CL176
VSAMDSN  DS    CL44
BUFTRTAB DC    X'0001020404080808080C0C0C0C101010101414141418181818'
         DC    X'1C1C1C1C20202020'  ROUND BUFSIZE TO ALLOWABLE VALUE
VSWORK   DS    D      DOUBLE-WORD WORK AREA
CATACB   DS    F      ACB OF CATALOG RETURNED FROM FIRST SHOWCAT
CATINFO1 DC    H'64'  WORKAREA INTO WHICH 'C' OR 'G' CATLG INFO RETURND
         DS    CL62
CATINFO2 DC    H'64'  WORKAREA INTO WHICH 'D' OR 'I' CATLG INFO RETURND
         DS    CL62
CATCINUM DS    XL3    CATLG CI NUMBER FOR SHOWCAT
BUFSZK   DS    X      CISIZE IN K ROUNDED FOR BLDVRP MACRO
VSRECLN  DS    0F         PARAMETER LIST FOR GETMAIN
         DC    X'80000000'   LENGTH OF INPUT VSAM RECORD
VSRECADR DS    A             ADDRESS OF GETMAINED WORKAREA
CATERR   ABEND 100,DUMP,STEP,SYSTEM  *******FOR TESTING**************
         LTORG
         IGGSHWPL
         TITLE 'PDS PROCESSING'
*        THIS CSECT PROCESSES PDS'S.  THE LINKAGE CONVENTIONS ARE-
*        R1-USED TO PASS THE ADDR OF THE LIBRARY DCB TO THIS CSECT.
*           THE CSECT THEN PASSES THE RECORD ADDR BACK TO THE
*           MAIN PROGRAM IN R1.
*        R5-USED AS THE BASE REGISTER FOR THE DCB
*        R8-POINTER TO CURRENT ADDR IN THE PDS DIRECTORY
*        R9-INPUT DATA BLOCK COUNTER-NUMBER OF BYTES REMAINING
*        R10-DIRECTORY BLOCK COUNTER-NUMBER OF BYTES REMAINING
*        R11-POINTER TO CURRENT ADDR IN THE INPUT DATA SET BLOCK
*           R8,R9,R10 & R11 ARE SAVED AND RESTORED IN SAVEINFO
*        R12-BASE REGISTER
*        R15-USED TO INDICATE END OF PDS DIRECTORY (EOF) R15=1
*                FOR THE LIBOUT ROUTINE
*        R5-LIBOUT DCB ADDR
*        R6-OUTBUFF ADDR FOR WRITE
*        R7-WORK REGISTER AND LENGTH OF WRITE BLOCK (WHEN SHORT)
*        R15-USED TO INDICATE ERROR R15=2
LIBCSECT CSECT
         USING *,R15
         STM   R2,R14,SAVEAREC
         CNOP  0,4
         BAL   R12,JUMPSAV3
SAVEAREC DS    13F
JUMPSAV3 EQU   *
         USING SAVEAREC,R12
         DROP  R15
         LR    R5,R1           LOAD ADDR OF LIBRARY DCB
         LM    R8,R11,SAVEINFO
         MVI   RETURN3+3,X'00'    RESET RETURN CODE (RC=4 CONTINUES)
         C     R5,=A(LIBOUT)  IS THIS LIBFILE(INPUT) OR LIBOUT PROCES
         BE    LIBOUTPR        IT IS LIBOUT
         SPACE 1
VLOGPDS  B     SETDCB  SET TO NOP ON VOPTION
BRVRTN   NOP   ENDMEM  SET TO B AFTER 1ST TIME THRU
         MVI   BRVRTN+1,SETBR
         B     RDDIR
         SPACE 1
SETDCB   NOP   BLKED           CHANGED TO B AFTER 1ST TIME THRU
         MVI   SETDCB+1,SETBR SET BRANCH AROUND THIS 1 TIME CODING
         MVC   KEYLEN+1(1),KEYLE(R5)  SAVE DCB KEY LENGTH
         L     R7,=A(MAXLEN+2)  GET MAX LRECL
         MVC   RECLEN,0(R7)    SAVE MAX LRECL IN RECLEN
         LH    R0,BLKSIZE(R5)  LOAD INPUT DATA SET BLKSIZE
         STH   R0,BLKLEN     SAVE BLKSIZE
         AH    R0,KEYLEN    ADD KEY LENGTH TO BLKSIZE
         ST    R0,LENGTHSV  SAVE INPUT BUFFER LENGTH (BLKSIZE+KEYLEN)
         GETMAIN R,LV=(0)     GET CORE FOR THAT SIZE RECORD
         ST    R1,INBUFF     SAVE INPUT BUFFER ADDRESS
         L     R7,=A(MEMFLAG)  GET FLAG THAT INDICATES IF MEMSYSIN DD
         CLI   0(R7),C'1'       CODED IN JCL
         BNE   LIBVREC         NO
         MVI   SELMEM+1,SETNOP YES-SET NOP TO PROCESS MEMB NAMES
         OPEN  (MEMSYSIN)           OPEN FILE
LIBVREC  L     R7,=A(MSG40FVU)  GET RECFM
         CLI   0(R7),C'V'       IS RECFM=V
         BNE   LIBUREC          NO- SEE IF ITS RECFM=U
         MVI   RECFMV1+1,SETNOP
         MVI   RECFMV2+1,SETNOP
         MVI   WRITEV+1,SETNOP  SET NOP TO PUT BDW INTO BLOCK-LIBOUT
         MVI   BLKBUFL+1,X'04'  INIT BLK BUF LEN TO 4 FOR
         MVI   INITBLK+1,X'04'  INIT FACTOR FOR BLKBUFL FOR RECFM=V
LIBUREC  CLI   0(R7),C'U'       IS RECFM=U
         BNE   RDDIR            NO
         MVI   LIBCOMP+1,SETBR  SET BR TO GO TO RECFM=U RTN
         MVI   NEWBLKU+1,SETBR  SET BRANCH TO BYPASS INSERT RTN
         MVI   LIBOUTU+1,SETBR SET BR TO BYPASS GETMAIN
         SPACE 2
RDDIR    LA    R8,DIRBLK     LOAD DIRECTORY WORK ADRE ADDR
         MVI   DSORG(R5),X'40'     CHANGE DSORG TO PS
         MVC   BLKSIZE(2,R5),=H'256' CHANGE BLOCKSIZE TO 256
         READ  DECBI,SF,(R5),(R8),'S',MF=E     READ DIRECTORY BLOCK
         CHECK DECBI     CHECK FOR COMPLETION OF READ
         NOTE  (R5)       REMEMBER LOCATION OF BLOCK READ
         STCM  R1,X'E',DADDSAV SAVE TTR OF LAST BLOCK READ-3 HIGH BYTES
         MVI   DSORG(R5),X'02'  CHANGE DSORG BACK TO PDS
         MVC   BLKSIZE(2,R5),LENGTHSV+2   CHANGE BLKSIZE BACK
         LH    R10,0(R8)    LOAD DIRECTORY BLOCK BYTE COUNT
         SH    R10,=H'2'   DECREASE COUNT BY 2
         LA    R8,2(R8)     LOAD ADDRESS OF FIRST MEMBER IN BLOCK
COMP     CLI   0(R8),X'FF'     IS THIS THE END OF DIRECTORY
         BE    ENDJOB     YES,BRANCH TO END OF JOB
VEND     NOP   RETURN3    SET TO B ON V OPTION
         SPACE 1
SELMEM   B     MVMEMNM    SET TO NOP IF MEMSYSIN DD CODED
GENERICM CLC   MEMRECIN,0(R8)   IS MEMSYSIN REC = TO DIRECTORY ENTRY
         BH    ENDMEM      ITS HIGHER - READ NEXT DIRECTORY ENTRY
         BL    GETMEM    ITS LOWER - READ NEXT MEMSYSIN RECORD
         SPACE 1
MVMEMNM  MVC   BLDENTRY,0(R8) ITS EQUAL- MOVE MEMBER NAME TO BLDL LIST
         BLDL  (R5),BLDLADD     GET THE TTR OF THE MEMBER
         FIND  (R5),BLDLTTR,C     FIND THE MEMBER
         SPACE 2
RDPDS    L     R11,INBUFF     LOAD ADDR OF WORK AREA FOR MEMBER RECS
         READ  DECBI,SF,(R5),(R11),'S'     READ THE MEMBER
         CHECK DECBI    CHECK FOR COMPLETION OF READ
         AH    R11,KEYLEN     ADD IN RECORD KEY LENGTH
RECFMV1  B     COMPREC      CHANGED TO NOP IF RECFM=V
         LH    R9,0(R11)    GET BLKSIZE FROM BLOCK DISCRIPTOR WORD
         SH    R9,=H'4'     SUBTRACT 4 FROM BLKSIZE FOR THE BDW
         LA    R11,4(R11)   POINT TO RECORD DISCRIPTOR WORD
         MVC   RECLEN,0(R11)    STORE LRECL IN RECLEN
         B     RETURN3
COMPREC  LH    R9,BLKLEN     LOAD INPUT BLOCK LENGTH WHEN RECFM=F OR U
         L     R4,DECBI+16   DECBI+16=IOB ADDR
         SH    R9,14(R4)    SUBTRACT RESIDUAL LENGTH(IOB ADDR+14)
         B     RETURN3
         SPACE 2
BLKED    SH    R9,RECLEN    SUBTRACT LOG. REC FROM BLKSIZE
         BNP   RDPDS IF 0 (OR NEGATIVE FOR RECFM=U), READ NEXT BLOCK
         AH    R11,RECLEN        LOAD ADDR OF NEXT LOGICAL REC
RECFMV2  B     RETURN3       CHANGED TO NOP IF RECFM=V
         MVC   RECLEN,0(R11)     STORE THE LRECL FROM THE RDW IN RECLEN
         B     RETURN3
ENDMEM   SR    R7,R7     CLEAR REGISTER
         NI    11(R8),X'1F'  ZERO OUT ALL BITS EXCEPT 3-7(1/2-WORD CNT)
         IC    R7,11(R8)     INSET USER DATA BYTE COUNT
         SLL   R7,1     MULTIPLY # HALFWORDS BY 2
         LA    R7,12(R7)    ADD MEMBER NAME AND TTR BYTE COUNT
         LA    R8,0(R7,R8)     LOAD ADDR OF NEXT MEMBER NAME
         SR    R10,R7    SUBTRACT FROM TOTAL COUNT-IS IT END OF DIRECT
         BNZ   COMP   NO-GET NEXT LOGICAL DIRECTORY RECORD
         POINT (R5),DADDSAV YES-POINT TO NEXT DIRECTORY BLOCK FOR READ
         B     RDDIR
         SPACE 2
ENDJOB   MVI   DSORG(R5),X'40'      RESTORE DSORG TO PS
         MVI   RETURN3+3,X'01'     SET R15=1 TO INDICATE END OF PDS
         CLOSE (MEMSYSIN)
         LTR   R15,R15
         BNZ   LIBOTNOP
         FREEPOOL MEMSYSIN
LIBOTNOP B     RETURN3   SET TO NOP IF LIBOUT REQUESTED
*        ENTERED WHEN END OF DIRECTORY SENSED TO WRITE & STOW LAST BLK
         CLI   LIBOUTPR+1,SETNOP HAVE ANY LIBOUT RECORDS BEEN INSERTED
         BE    RETURN3       NO- NOTHING TO DO AT ENDJOB
         MVC   BLDENTRY,=X'FFFFFFFF'  EOF INDICATOR
         MVI   NEWBLK+1,SETBR SET BR TO RETURN AFTER LAST REC
         MVI   NEWBLKU+1,SETNOP SETNOP-RETURN AFTER LAST REC FOR RCFM=U
         MVI   BYPOINT+1,SETBR BYP POINT MACRO IF EOJ (NO WRITES AFTER)
         L     R5,=A(LIBOUT)  PUT LIBOUT DCB INTO R5
         B     LIBCOMP
         SPACE 2
LIBOUTPR NOP   LIBCOMP   SET TO BR AFTER FIRST TIME THRU
         MVI   LIBOUTPR+1,SETBR
         MVI   LIBOTNOP+1,SETNOP AT ENDJOB SET NOP TO PROCESS LAST MEMB
         MVC   STOWMNME,BLDENTRY  MOVE MEMBER NAME TO STOW LIST
         MVC   STOWREST,BLDLREST  MOVE IN C AND USER DATA
LIBOUTU  NOP   LIBCOMPU   SET BR ON RECFM=U TO BYPASS GETMAIN
         LH    R0,BLKSIZE(R5)    GET LIBOUT BLKSIZE
         STH   R0,SVBLKSIZ   SAVE OUTPUT BLKSIZE
         GETMAIN R,LV=(0)        GET STORAGE FOR LIBOUT BLOCK
         ST    R1,OUTBUFF    STORE SORAGE ADDR IN OUTBUFF
LIBCOMP  NOP   LIBCOMPU      SET TO BR ON RECFM=U
         LH    R7,RECLEN     GET LIBOUT LRECL
         AH    R7,BLKBUFL    ADD CURRENT BLOCK BUF LENGTH
         L     R6,OUTBUFF    PUT OUTPUT BUFFER ADDR IN R6
         CLC   STOWMNME,BLDENTRY  IS NEW MEMBER NAME = OLD MEMBER NAME
         BNE   MEMBCHG           NO
         CH    R7,SVBLKSIZ       IS OUTPUT BUFFER FULL
         BNH   INSERT     NO- INSERT RECORD INTO OUTPUT BUFFER
         BAL   R4,WRITE               YES -WRITE FULL BUFFER
         B     NEWBLK     INSERT FIRST RECORD OF NEW BLK
         SPACE 2
MEMBCHG  BAL   R4,WRITE       WRITE SHORT BUFFER
MEMBCHGU STOW  (R5),STOWLIST,A    STOW MEMBER IN DIRECTORY
         C     R15,=F'4'            ERROR IN STOW?
         BE    REPMEM               CHECK IF REPLACE ALLOWED
         BH    LIBERR               ERROR
LIBCONT1 AP    MEMBCNT,=P'1'     NO-ADD 1 TO MEMBERS ADDED/REPLACED
         MVI   STOWFLAG,C'Y'     SUCCESSFUL STOW INDICATOR
LIBCONT2 MVC   STOWMNME,BLDENTRY        MOVE IN NEW MEMBER NAME
         MVC   STOWREST,BLDLREST  MOVE IN C AND USER DATA
         MVC   REPLFLAG,HOLDREPL        GET UPDATED REPL FLAG
NEWBLKU  NOP   WRITEU  SET TO B ON RECFM=U TO WRITE NEXT BLK,NOP AT EOJ
NEWBLK   NOP   RETURN3 MOVE IN 1ST REC OF NEXT MEMB,SET TO B AT EOJ
*        SET TO BR AT EOJ FOR LAST BLK AND FOR RECFM=U
         MVC   BLKBUFL,INITBLK  RESET BLK BUF LENGTH TO 0 (OR 4 FOR V)
INSERT   AH    R6,BLKBUFL  PT TO NEXT RECORD AREA IN BUFFER
         LH    R7,RECLEN   GET RECORD LENGTH
         LR    R2,R11      GET INPUT RECORD ADDR
         LR    R3,R7       LENGTH
         MVCL  R6,R2       MOVE LOGICAL RECORD (ANY LENGTH)
         SPACE 1
         LH    R7,RECLEN    LOAD CURRENT LRECL
         AH    R7,BLKBUFL   ADD CURRENT BLOCK BUL LENG
         STH   R7,BLKBUFL   AND STORE NEW BLOCK BUF LENG
         B     RETURN3
         SPACE 2
WRITE    LH    R7,BLKBUFL          GET BLKSIZE FOR WRITE
WRITEV   B     WRITEFU             SET TO NOP FOR RECFM=V
         STH   R7,0(R6)            SET BDW IN OUTPUT BUFFER
WRITEFU  STH   R7,BLKSIZE(R5)      SET BLKSIZE FOR WRITE
         WRITE DECBO,SF,(R5),(R6),'S'   WRITE BLOCK (SHORT AND FULL)
         CHECK DECBO
         CLI   STOWFLAG,C'Y'       WAS LAST STOW SUCCESSFUL
         BNER  R4                  NO
         NOTE  (R5)     YES-REMEMBER THE ADDRESS OF THE 1ST BLK OF MEMB
         ST    R1,WRITEPOS  AND SAVE IT TO RESET POINTER AFTER BAD STOW
         MVI   STOWFLAG,C'N'       RESET STOW FLAG
         BR    R4
         SPACE 2
GETMEM   GET   MEMSYSIN       GET NEW MEMSYSIN REC
         MVC   MEMRECIN,0(R1)      MOVE TO 11-BYTE HOLD AREA
         TRT   MEMRECIN(9),FINDPARN SEE IF (R) CODED ON MEMBNM FOR REPL
         BZ    NOREPL            NO
         CLC   0(3,R1),=C'(R)'    MAKE SURE (R) CODED
         BNE   NOREPL            NO
         MVI   HOLDREPL,C'Y'     YES
         MVC   0(3,R1),=C'   '   BLANK OUT (R)
FRSTREPL NOP   CHKGENRC          SET TO BRANCH AFTER 1ST TIME THRU
         MVI   FRSTREPL+1,SETBR
         MVI   REPLFLAG,C'Y'     SET REPLFLAG TO 'Y' 1ST TIME
         SPACE 1
CHKGENRC MVI   GENERICM+1,X'07'    SET COMPARE LENGTH TO 8-1
         TRT   MEMRECIN(8),FINDAST IS GENERIC MEMBER NAME SPECIFIED
         BZ    GENERICM            NO - DONT RESET COMP LENG
         LA    R2,MEMRECIN YES- PUT ADDR OF FIRST BYTE OF MNAME IN R2
         SR    R1,R2   GET LENGTH OF GENERIC NAME IN R1
         BZ    NOMEMCHK   LENGTH=0, DONT DO ANY MEMSYSIN PROCESSING
         BCTR  R1,0       SUBTRACT 1 FROM LENGTH FOR COMPARE
         STC   R1,GENERICM+1    SET LENGTH OF COMPARE
         B     GENERICM
         SPACE 1
NOREPL   MVI   HOLDREPL,C'N'
         MVI   FRSTREPL+1,SETBR
         B     CHKGENRC         CHECK IF GENERIC MEMEBER NAME
         SPACE 2
NOMEMCHK MVI   SELMEM+1,SETBR   BYPASS MEMSYSIN RTN- PROCESS ALL RECS
         B     MVMEMNM
         SPACE 2
LIBCOMPU L     R7,SAVEINFO+4   GET BLKSIZE FROM R9 OF RECFM=U BLOCK
         L     R6,INBUFF    PUT INPUT BUFFER ADDR IN R6
         CLC   STOWMNME,BLDENTRY  IS NEW MEMBER NAME = OLD MEMBER NAME
         BNE   MEMBCHGU          NO
WRITEU   BAL   R4,WRITEFU YES - WRITE RECFM=U BLOCK WITH LENGTH IN R7
         B     RETURN3
         SPACE 2
RETURN3  LA    R15,0               R15=0 PDS IS NOT AT END
         LR    R1,R11
         STM   R8,R11,SAVEINFO
         LM    R2,R14,SAVEAREC
         BR    R14
         SPACE 2
REPMEM   CLI   REPLFLAG,C'Y'   SHOULD WE REPLACE MEMBER
         BNE   LIBERR           NO
CHKDISP  NOP   REPLSTOW   YES-SET TO BR AFTER 1ST TIME THRU
         MVI   CHKDISP+1,SETBR
         RDJFCB ((R5))        GET SETTING OF JCL DISP PARAMETER
         L     R1,=A(JFCBIND2)
         TM    0(R1),JFCSHARE IS DISP=SHR CODED IN JCL
         BNO   REPLSTOW       NO-OK
         LA    R15,8          YES, PUT OUT ERROR MSG
         B     LIBERR
REPLSTOW STOW  (R5),STOWLIST,R  YES-REPLACE MEMBER
         LTR   R15,R15          OK?
         BZ    LIBCONT1         YES
LIBERR   STC   R15,RETURN3+3   NO-OTHER ERROR, STORE RC OF STOW
BYPOINT  NOP   LIBCONT2        SET TO BRANCH AT EOJ
         POINT (R5),WRITEPOS   RESET WRITE POINTER ON DUP WITH NO REPL
         B     LIBCONT2        AND EVENTUALLY GET OUT-ERROREOJ
         DROP  R12
         SPACE 2
SAVEINFO DS    4F
WRITEPOS DS    F     TTR0-RELATIVE BLK ADDR OF 1ST BLOCK OF MEMBER
*                    AFTER A SUCCESSFUL STOW
DADDSAV  DC    F'1'  POINTER TO NEXT BLK(1 IN LOW BYTE FOR NEXT BLK)
INBUFF   DS    F     ADDR OF AREA FOR INPUT BUFFER
LENGTHSV DC    F'0'  BLKSIZE+KEYLE
BLDLADD  DC    H'1'  NO OF ENTRIES IN BLDL TABLE
         DC    H'76' LENGTH OF ENTRIES IN BLDL TABLE
BLDENTRY DC    CL8'        '   MEMB NAME IN BLDL TABLE-PRGRM SUPPLIED
BLDLTTR  DS    XL3   TTR IN BLDL TABLE-SYSTEM SUPPLIED
         DS    2X    K,Z
BLDLREST DS    XL63  C AND USER DATA
         SPACE 1
KEYLEN   DC    H'0'     SAVE THE KEYLENGTH
RECLEN   DC    H'0'     SAVE THE LRECL
BLKLEN   DC    H'0'     SAVE THE BLKSIZE
DIRBLK   DS    CL264      DIRECTORY WORK AREA
MEMBCNT  DC    PL8'0'   NUMBER OF MEMBERS CREATED IN LIBOUT RTN
OUTBUFF  DS    A        OUTPUT BUFFER ADDR FOR LIBOUT- HELD IN R6
BLKBUFL  DC    H'0'    CURRENT BLK BUF LENGTH
INITBLK  DC    H'0'   BLOCK INITIALIZATION (0 FOR FIXED,4 FOR VARIABLE)
SVBLKSIZ DC    H'0'     SAVE OUTPUT BLKSIZE HERE
         SPACE 1
STOWLIST DS    0F    STOW LIST USED IN STOW MACRO
STOWMNME DS    CL8   MEMBER NAME OF MEMBER TO BE ADDED-SUPPLIED BY PGRM
         DS    XL3   TTR - SUPPLIED BY SYSTEM
STOWREST DS    XL63  C AND USER DATA; MOVED IN FROM BLDLREST
         SPACE 1
STOWFLAG DC    C'Y'  Y=SUCCESSFUL STOW;INIT TO Y FOR 1ST BLK OF 1ST MEM
HOLDREPL DC    C'N'  TEMP FLD TO KEEP REPLFLAG IN SYNCH MEMSYSIN & STOW
REPLFLAG DC    C'N'     REPLACE MEMBER INDICATOR - DEFAULT=NO
MEMRECIN DC    CL11' '   MEMSYSIN REC (11 BYTE MEMBNAM*(R))
FINDAST  DC    256X'00'   FIND '*' FOR GENERIC MEMSYSIN REC
         ORG   FINDAST+C'*'   PUT NON-ZERO FUNCTION BYTE IN '*'
         DC    X'FF'
         ORG   FINDAST+256
FINDPARN DC    256X'00'   FIND '*' FOR GENERIC MEMSYSIN REC
         ORG   FINDPARN+C'('  PUT NON-ZERO FUNCTION BYTE IN '*'
         DC    C'('
         ORG   FINDPARN+256
         SPACE 1
MEMSYSIN DCB   DDNAME=MEMSYSIN,DSORG=PS,MACRF=GL,BLKSIZE=0,            X
               SYNAD=SYNADERR,EROPT=ACC,EODAD=ENDJOB
         LTORG
         TITLE 'PACK,NUMERIC,ALPHBETIC,ALPHMERIC,HEX,EQUTE SYMBOL TABL'
*THE FOLLOWING STORAGE AREAS WILL BE USED AS TRANSLATE TABLES FOR PACK
*NUMERIC,ALPHABETIC,ALPHANUMERIC,HEX CLASS TESTS AND EQUATE SYMBOLS.
* PLUS ADDITIONAL STORAGE ARES
*        LINKAGE CONVENTIONS-
*        R15-GETS ADDR OF TABLE LOADED INTO IT
TRANTABS CSECT
*******************************************************************
TRNSTAB1 DC    193X'FF'   THIS TABLE USED FOR ALPHABETIC CLASS TEST
         DC    9X'00',7X'FF'    A-I    '00'=ALPHABETICS,'FF'=GARBAGE
         DC    9X'00',8X'FF'    J-R
         DC    8X'00',22X'FF'   S-Z
*******************************************************************
TRNSTAB2 DC    160X'FF'   THIS TABLE USED FOR NUMERIC CLASS TEST
*THE '01' FUNCTION BYTES ARE FOR THE LAST DIGIT SIGNED BYTE,'FF'=GARBAG
         DC    5X'01010101010101010101FFFFFFFFFFFF'   A0-EF
         DC    10X'00'    F0-F9   THE ACTUAL ZONED NUMERICS
         DC    6X'FF'
*******************************************************************
*     THE FOLLOWING TABLE USED FOR PACK CLASS TEST
* '00' FUNCTION BYTE=LEGIT PACK BYTE,'01' FUNCTION BYTE=SIGN PACK BYTE
TRNSTAB3 DC    10X'00000000000000000000010101010101'  00-9F
         DC    33X'FF'                  A0-C0
         DC    X'AABBCCDDEEFF'          A-F (C1-C6)
         DC    42X'FF'                  C7-F0
         DC    X'112233445566778899'    1-9 (F1-F9)
         DC    6X'FF'
*******************************************************************
TRNSTAB4 DC    193X'FF'   THIS TABLE USED FOR ALPHANUMERIC CLASS TEST
         DC    9X'00',7X'FF'   A-I  'FF'=GARBAGE,'00'=ALPHABET OR NUMER
         DC    9X'00',8X'FF'   J-R
         DC    8X'00',6X'FF'   S-Z
         DC    10X'00',6X'FF'  0-9
*******************************************************************
TRNSTAB5 DC    X'000102030405060708090A0B0C0D0E0F' TRANSLATE TABLE USED
         DC    X'101112131415161718191A1B1C1D1E1F' FOR Y= EQUATE SYMBOL
         DC    X'202122232425262728292A2B2C2D2E2F'   OPTION
         DC    X'303132333435363738393A3B3C3D3E3F'
         DC    X'404142434445464748494A4B4C4D4E4F'
         DC    X'505152535455565758595A5B5C5D5E5F'
         DC    X'606162636465666768696A6B6C6D6E6F'
         DC    X'707172737475767778797A7B7C7D7E7F'
         DC    X'808182838485868788898A8B8C8D8E8F'
         DC    X'909192939495969798999A9B9C9D9E9F'
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'
         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'
         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'
*******************************************************************
HEXTAB1  DC    193X'FF'   THIS TABLE USED FOR VALIDATING HEX CHARS
         DC    6X'00'          A-F  'FF'=GARBAGE,'00'=VALID HEX
         DC    41X'FF'
         DC    10X'00',6X'FF'  0-9
*******************************************************************
HEXTAB2  DC    193X'FF'   THIS TABLE USED FOR CONVERTING EXTERNAL HEX
         DC    X'AABBCCDDEEFF'
         DC    41X'FF'
         DC    X'00112233445566778899',6X'FF'
*******************************************************************
CNVRTABL DC    X'000102030405060708090A0B0C0D0E0F' CONVERT TABLE USED
         DC    X'101112131415161718191A1B1C1D1E1F' WHEN CONVERT DD
         DC    X'202122232425262728292A2B2C2D2E2F'   REQUESTED
         DC    X'303132333435363738393A3B3C3D3E3F'
         DC    X'404142434445464748494A4B4C4D4E4F'
         DC    X'505152535455565758595A5B5C5D5E5F'
         DC    X'606162636465666768696A6B6C6D6E6F'
         DC    X'707172737475767778797A7B7C7D7E7F'
         DC    X'808182838485868788898A8B8C8D8E8F'
         DC    X'909192939495969798999A9B9C9D9E9F'
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'
         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'
         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'
*******************************************************************
OPTIONS  DC    193X'00' TRANSLATE USED TO FIND THE PRIMARY OPTIONS
         DC    X'04'         THE BRANCH VALUE (04) FOR THE A OPTION
         DC    X'08'         THE BRANCH VALUE (08) FOR THE B OPTION
         DC    X'0C'         THE BRANCH VALUE (12) FOR THE C OPTION
         DC    X'10'         THE BRANCH VALUE (16) FOR THE D OPTION
         DC    X'14'         THE BRANCH VALUE (20) FOR THE E OPTION
         DC    X'18'         THE BRANCH VALUE (24) FOR THE F OPTION
         DC    X'1C',10X'00' THE BRANCH VALUE (28) FOR THE G OPTION
         DC    X'20',1X'00'  THE BRANCH VALUE (32) FOR THE K OPTION
         DC    X'24',1X'00'  THE BRANCH VALUE (36) FOR THE M OPTION
         DC    X'28'         THE BRANCH VALUE (40) FOR THE O OPTION
         DC    X'2C'         THE BRANCH VALUE (44) FOR THE P OPTION
         DC    X'30'         THE BRANCH VALUE (48) FOR THE Q OPTION
         DC    X'34',8X'00'  THE BRANCH VALUE (52) FOR THE R OPTION
         DC    X'38'         THE BRANCH VALUE (56) FOR THE S OPTION
         DC    X'3C',1X'00'  THE BRANCH VALUE (60) FOR THE T OPTION
         DC    X'40'         THE BRANCH VALUE (64) FOR THE V OPTION
         DC  26X'00'
*******************************************************************
OPTNTABL DC    194X'00' TRANSLATE USED TO FIND B=,E=,J=,V=,Y= KEYWORDS
         DC    X'1C',2X'00'  THE BRANCH VALUE (28) FOR B= IN R2
         DC    X'0C',11X'00' THE BRANCH VALUE (12) FOR E= IN R2
         DC    X'14',19X'00' THE BRANCH VALUE (20) FOR J= IN R2
         DC    X'08',2X'00'  THE BRANCH VALUE (08) FOR V= IN R2
         DC    X'04',23X'00' THE BRANCH VALUE (04) FOR Y= IN R2
*******************************************************************
ASTPAREN DC    256X'00'   V OPT TABLE TO FIND *,'(',')','!' IN SYSIN
         ORG   ASTPAREN+C'*'
         DC    C'*'
         ORG   ASTPAREN+C'('
         DC    C'('
         ORG   ASTPAREN+C')'
         DC    C')'
         ORG   ASTPAREN+C'!'
         DC    C'!'
         ORG   ASTPAREN+256
*******************************************************************
COMMABLK DC    256X'00'  V OPT TABLE TO FIND ',' AND ' ' IN VOL=
         ORG   COMMABLK+C' '
         DC    C' '
         ORG   COMMABLK+C','
         DC    C','
         ORG   COMMABLK+256
*******************************************************************
VPARMTAB DC    256X'00'  V OPT TABLE TO FIND QUOTES ON PARM
         ORG   VPARMTAB+X'7D'
         DC    X'7D'
         ORG   VPARMTAB+256
WLDCRDTB DC    256X'00'  TABLE TO FIND '.' AND ' '
         ORG   WLDCRDTB+C'.'
         DC    C'.'
         ORG   WLDCRDTB+C' '
         DC    C' '
         ORG   WLDCRDTB+256
PLUSTABL DC    256X'00'  TABLE TO FIND '+'
         ORG   PLUSTABL+C'+'
         DC    C'+'
         ORG   PLUSTABL+256
SLSHTBL  DC    256X'00'  TABLE TO FIND '/'
         ORG   SLSHTBL+C'/'
         DC    C'/'
         ORG   SLSHTBL+256
BINTRTBL DC    240X'00'      TABLE TO TRANSLATE HEX TO PRINTABLES
         DC    C'0123456789ABCDEF'
*******************************************************************
VOLTABL  DC    11XL80'00' TABLE OF SYSIN RECS UP TO 10 ENTRIES-V OPT
VOLSER   DC    10XL7'00'  VOLSER TABLE OF UP TO 10 ENTRIES- V OPT
VPARM    DS    H,CL80     PARM FROM VSYSIN FILE ON V OPTION
DAIRBUF  DS    XL510        MSG BUFFER FOR DAIRFAIL
MSG65LBL DC    CL80' '     HOLDS LABEL ON TAPELABL OPTION   @MK1
*******************************************************************
         TITLE 'T,P,E AND G PROCESSING'
*THE P OPTION IS SIMILIAR TO THE 'T' OPTION EXCEPT THAT PAIRS OF
*KEYS ARE READ INTTO A TABLE.  THE PAIRS ARE SORTED IN ASCENDING ORDER
*OF THE FIRST KEY OF EACH PAIR.  ANY KEY FROM THE INPUT RECORD THAT IS
*EQUAL TO OR GREATER THAN THE FIRST KEY OF A PAIR AND IS EQUAL TO OR
*LESS THAN THE SECOND MEMBER OF THE PAIR IN THE TABLE IS SELECTED.
*THE P OPTION USES A SORTED TABLE BUT DOES A SEQUENTIAL SEARCH OF THE
* TABLE.(THE BINARY SEARCH ROUTINE IS BYPASSED)
*E.G.  IF THE TABLE HAD THE FOLLOWING ENTRIES
*        5  10
*       20  30
*      ANY KEYS BETWEEN 5 AND 10 OR 20 AND 30 WOULD BE SELECTED.
*   THE T LOGIC IS USED TO MATCH A FILE AGAINST THE SYSIN FILE
*      IF THE KEY FROM THE INPUT FILE MATCHES ANY OF THE KEYS FROM
*      THE SYSIN FILE THEN THE RECORD IS NOTED AS SELECTED AND WRITTEN.
*      THE COUNT FIELD FROM THE PARM FIELD WILL BE USED BY 'T' AND
*      'TB' TO INDICATE THE NUMBER OF RECORDS TO SELECT FOR EACH
*      KEY.  FOR 'TN'  THE COUNT IS USED AS A TOTAL COUNT TO
*      INDICATE THE TOTAL NUMBER OF RECORDS THAT DON'T MATCH THE KEYS.
*THE FOLLOWING CONVENTIONS ARE USED BY THE CALLED & CALLING MODULES:
*  R1    PASSES THE INPUT RECORD ADDRESS TO THE E LOGIC
*  R3 PASSES THE INPUT RECORD KEY ADDRESS TO BINARY SEARCH.
*  R4 USED TO PASS THE LENGTH OF THE KEY FOR COMPARISON.
*        R4 IS SET TO 19 FOR THE E LOGIC
*  R5 USED TO PASS THE LENGTH OF THE KEY + 4(COUNT FIELD)=TABLE ENTRY.
*        R5 IS SET TO 24 FOR THE E LOGIC
* R14 IS USED FOR THE RETURN ADDRESS INTO THE CALLER
* R15 IS USED AS THE BRANCH ADDRESS ON THE BALR INSTRUCTION  AND ALSO
*     FOR A RETURN CODE TO SIGNIFY WHETHER THE RECORD WAS SELECTED (0)
*     OR NOT SELECTED (1).
*        REGISTERS 0 IS NOT USED(SYSTEM REGISTER) R2 USED IN E LOGIC
*        R6=BASE REGISTER,R7=TABLE POINTER,R9=WORK REGISTER
*        R10,R11,R12 ARE USED IN THE BINARY SEARCH ROUTINE,R13=TABLEND
TSEARCH  CSECT
         USING *,R15            T LOGIC LINKAGE
         STM   R6,R14,SAVEAREB  SAVE CALLERS REGISTERS IN SAVE AREA
         CNOP  0,4              ALIGN ON FULL WORD FOR BAL
         BAL   R6,JUMPSAVX   JUMP PAST SAVE AREA  AND LOAD R6 AS BASE
SAVEAREB DS    9F              SAVE AREA FOR REGISTERS
JUMPSAVX EQU   *
         USING SAVEAREB,R6   SET BASE REGISTERS
         DROP  R15           15 NO LONGER BASE REG
         ST    R1,STARTADR SAVE THE ADDR OF THE INPUT RECORD FOR E LOG
         L     R13,=A(TABLEND) LD R13 WITH ADDR OF END OF TABLE
         L     R13,0(0,R13)
SETDISP  NOP   TSRCH1        SET TO BRNCH AFTER 1ST TIME THRU
         MVI   SETDISP+1,SETBR  BRANCH AROUND FIRST TIME ROUTINE
         L     R9,=A(MSG40FVU) GET RECFM
         CLI   0(R9),C'U'   IS RECFM=U
         BNE   CHKRECV      NO
         MVI   EUOPTBR+1,SETNOP YES - SET NOP TO ADJUST FOR SMALL BLOCK
         B     NOTVREC
CHKRECV  CLI   0(R9),C'V'          IS RECFM=V
         BNE   NOTVREC        NO
         MVI   EVOPTBR+1,SETNOP YES SET NOP TO ADJUST FOR INTERNAL LENG
NOTVREC  L     R9,=A(ELOGIC)
         CLI   1(R9),SETBR     IS THE E LOGIC ROUTINE REQUESTED
         BNE   NOTEOPT         NO
         LA    R4,19      YES- SET R4=19 FOR KEY LENGTH-1
         MVI   TSRCH1+1,SETBR  BYPASS SORTING THE KEYS
         MVI   ELOGBR+1,SETBR  SET BRANCH TO GO INTO E LOGIC
         L     R9,=A(ECHGMSG)
         CLI   1(R9),SETNOP IS CONVERT (CHANGE) USED WITH E OPT
         BNE   NOTEOPT      NO
         MVI   ECHGMTCH+1,SETNOP SET NOP TO CHANGE KEY WHEN FOUND
         MVI   TSRCH99+1,SETNOP NOP TO DO ALL CHANGES IN REC- NOT JUST
*        WHEN THE THE FIRST KEY IS FOUND
         L     R9,=A(ECHGKEY)   GET SYSIN+CONVERT KEY
         MVC   ECHNGKEY,0(R9)
         L     R9,=A(EJEQCNT)   GET J= COUNT ON $ OR @ CHG
         MVC   EJEQUCNT,0(R9)
NOTEOPT  EQU   *
         SPACE 1
*          THE KEY LENGTH-1 IS PASSED IN R4
         STC   R4,SORTCOMP+1 SET LENGTH FOR COMPARE IN THE SORT
         STC   R4,TSRCOMP+1  SET LENGTH FOR COMPARE IN THE BIN SEARCH
         STC   R4,PCOMPAR2+1  SET LENGTH FOR UPPER KEY COMPARE (P)
         STC   R5,PCOMPAR2+3  SET DISPLACEMENT FOR HIGH KEY COMPARE (P)
         LA    R9,1(R4)      SET R9 TO ACTUAL KEY LENGTH
         STC   R9,TMATCH1+3  SET DISPLAC FOR CNT COMPARE IN BIN SEARCH
         STC   R9,TABLEADD+3 SET DISPLAC TO ADD 1 TO CNT IN BIN SEARCH
         SPACE 2
         L     R9,=A(TLOGNEQ)  LD R9 WITH ADDR OF TLOGNEQ FOR N SUBOPT
         CLI   1(R9),SETBE      IS THIS THE N SUBOPTION
         BNE   CHKFORP             NO
         MVI   BYPCNT+1,SETBR     BYPASS THE INDIVIDUAL COUNTS
*                           IS THE 'P' OPTION IN EFFECT
CHKFORP  L     R9,=A(PLOGNOP) LOAD R9 WITH ADDR OF PLOGNOP FOR P TEST
         CLI   1(R9),SETNOP   IS THIS THE P KEY
         BNE   TCONTINU       NO
         MVI   PLOGBR+1,SETBR   YES-BYPASS THE BINARY SEARCH
         AR    R5,R5            DOUBLE THE LENGTH OF THE KEYS
         LR    R4,R5            PUT THE DOUBLED LENGTH IN R4 ALSO
         BCTR  R4,0             ADJUST FOR NEW LENGTH  SUBTRACT 1
TCONTINU STC   R5,INTRCHG2+3 SET DISPLAC IN THE INTERCHANGE OF THE SORT
         STC   R5,INTRCHG1+5
         STC   R5,SORTCOMP+5 SET DISPLAC FOR THE COMPARE IN THE SORT
         STC   R4,INTRCHG1+1 SET LENGTH IN THE INTERCHANGE
         STC   R4,INTRCHG2+1
         L     R9,=A(COUNT)     LOAD ADDRESS OF COUNT INTO R9
         MVC   SELCOUNT,0(R9)   INITIALIZE THE SELECTION COUNT
*        THE BINARY SORT IS DONE ONCE AND THEN BYPASSED
TSRCH1   NOP   BNRYSRCH CHNGD TO B WHEN SYSIN CARDS HAVE BEEN SORTED
*  SORT THE TABLE ENTRIES USING A BUBBLE SORT
         L     R7,=A(TABLE)  LD THE TABLE BEGINNING ADDRESS
         L     R7,0(0,R7)
         MVI   ALLDONE,C'0' INITIALIZE ALLDONE TO  ZERO
TSORT    CR    R7,R13  LAST ENTRY THIS PASS-R13=ADDR OF LAST TABLE ENT
         BNL   TSORTEND      YES-SEE IF ALL THE ENTRIES ARE IN ORDER
SORTCOMP CLC   0(0,R7),0(R7)  COMPARE 2 ENTRIES-LENGTH & DISPL ADJUSTED
         BNH   TNEXTKEY   THE CURRENT ENTRY NOT MORE THAN NEXT ENTRY
*     THREE EXCLUSIVE ORS REVERSE TWO FIELDS
INTRCHG1 XC    0(0,R7),0(R7) INTERCHANGE 2 CONSECUTIVE KEYS
INTRCHG2 XC    0(0,R7),0(R7) LENGTHS AND DISPLACEMENTS MODIFIED
         EX    0,INTRCHG1    COMPLETE THE INTERCHANGE
         MVI   ALLDONE,C'1'    INDICATE THAT A MOVE OCCURED
TNEXTKEY AR    R7,R5            UP THE ENTRY BEING WORKED ON
         B     TSORT         PROCESS THE NEXT ENTRY IN THE TABLE
TSORTEND CLI   ALLDONE,C'0'     IS SORT FINISHED
         BNE   TSRCH1       NO-CONTINUE SORTING
         MVI   TSRCH1+1,SETBR YES-ACTIVATE PROCESSING ROUTINE
         SPACE 3
*            BINARY SEARCH ROUTINE AND RETURN TO MAINLINE
BNRYSRCH EQU   *            LOAD R7 WITH THE ADDRESS OF THE TABLE
         L     R7,=A(TABLE)  LD THE TABLE BEGINNING ADDRESS
         L     R7,0(0,R7)
         LR    R9,R7        LOAD R9 WITH THE ADDRESS OF THE TABLE
         LA    R15,1       INITIALIZE R15 (1=NO MATCH OR ENTRY IS FULL)
*
ELOGBR   NOP   ELOGIC1   CHANGED TO B ON E OPTION-BYPASS BINARY SEARCH
PLOGBR   NOP   PLOGIC1   CHANGED TO B ON P OPTION-BYPASS BINARY SEARCH
*
         L     R12,=A(RCOUNT)  LOAD THE ADDRESS OF RCOUNT INTO R12
*           RCOUNT IS USED TO COUNT THE NUMBER OF SYSIN
*           RECORDS AND ALSO THE TABLE ENTRIES
         CVB   R12,0(0,R12)   CONVERT THE NO OF SYSIN RECORDS TO BINARY
TSRCHLOP EQU   *            THIS IS THE TABLE SEARCH LOOP
         LTR   R11,R12   ANY MORE ENTRIES TO BE CHKED (R12=NO ENTRIES)
         BZ    TSRCH99      THE ENTRY IS NOT IN THE TABLE
         CR    R11,R15   IS THE ENTRY BEING PROCESSED ONE (R15=1)
         BNE   TSRCOMP      NO THIS IS NOT THE LAST COMPARE
         SR    R11,R11      LOAD THE ENTRY INCREMENT WITH ZEROS
*                                    THIS IS THE END OF THE SEARCH
TSRCOMP  CLC   0(0,R7),0(R3)  IS THIS ENTRY EQUAL TO THE TABLE ENTRY
         BE    TMATCH          YES GO TO FOUND ROUTINE
         BL    TSRCHINC    NO-THE TABLE ENTRY IS LOW COMPARED TO INPUT
*         R9 HAS THE FIRST ENTRY IN THE TABLE
         CR    R9,R7       IS FIRST SYSIN HIGH COMPARED TO INPUT
         BE    TSRCH99         YES-NO MATCH
*  THE TABLE WAS GREATER, DIVIDE THE CURRENT ENTRY(R2)BY 2 AND ROUND
*  IT.MULTIPLY ENTRY BY LENGTH.SUBTRACT RESULT FROM CURRENT POINTER.
TSRCHRED NR    R11,R15   ZERO OUT ALL BITS EXCEPT THE LOW ORDER (R15=1)
         SRL   R12,1     DIVIDE BY 2  THE NUMBER OF ENTRIES IN TABLE
         AR    R12,R11        IF NUMBER WAS ODD ADD 1 TO ROUND IT
         LR    R11,R12        LOAD THE RESULT INTO R11
         MR    R10,R5    MULTIPLY THE TABLE SPLIT FACTOR BY KEY LENGTH
*              THE FOLLOWING INSTRUCTION IS CHANGED DYNAMICALLY
ADDORSUB SR    R7,R11          REDUCE THE TABLE ADDRESS BY THE RESULT
         MVI   ADDORSUB,X'1B'  CHANGE SR INSTRUCTION BACK TO SR
         B     TSRCHLOP        GO TO CONTINUE PROCESSING
*   THE BELOW INSTRUCTIONS ARE PERFORMED IF THE TABLE ENTRY IS LOW
TSRCHINC MVI   ADDORSUB,X'1A'   CHANGE ABOVE SR INSTRUCTION TO AR
         B     TSRCHRED         GO TO TSRCH REDUCE
         SPACE 3
PLOGIC1  CR    R7,R13       HAS LAST ENTRY BEEN HIT
         BNL   TSRCH99         YES-RETURN
         EX    0,TSRCOMP       NO-COMPARE 1ST KEY OF PAIR TO INPUT
         BH    TSRCH99         LOW KEY IN SYSIN HIGH TO INPUT-NOMATCH
*           IF THE TABLE ENTRY IS HIGH THEN THERE IS NO MATCH. GET OUT
PCOMPAR2 CLC   0(0,R7),0(R3)   IS UPPER KEY LESS THAN INPUT
         BNL   TMATCH          NO-IT FALLS IN THE RANGE
         AR    R7,R5          YES-POINT TO NEXT PAIR OF KEYS ON TABLE
         B     PLOGIC1         RECOMPARE
         TITLE 'E LOGIC-STRING EDITING TYPE LOGIC'
ELOGIC1  NOP   ECOMPAR1        SET TO B AFTER FRIST TIME THRU
         MVI   ELOGIC1+1,SETBR
         L     R1,=A(EKEYMSG2+1)
         MVI   0(R1),SETNOP SET NOP TO PROCESS E KEY MESSAGES
         LA    R11,TRNSTAB6    CALCULAT LENGTH OF EACH KEY
ELOOP    LA    R10,0                CLEAR R10
         IC    R10,0(0,R7)  INSERT DELIMITER CHAR IN R10
         STC   R10,DELIMITR     SAVE DELIMITER CHARACTER (FOR #)
         AR    R10,R11          FIND DELIMITER POS IN TABLE
         MVI   0(R10),X'01'    INSET 1 AS A FUNCTION BYTE
         LA    R7,1(R7)           POINT BEYOND DELIMITER
         TRT   0(19,R7),TRNSTAB6  FIND SECOND DELIMITER
         BZ    INVALKEY      ERROR-NO SECOND DELIMITER-KEY TOO LARGE
         ST    R1,DELIMADR   SAVE THE THE ADRRESS OF THE DELIMITER
         SR    R1,R7         GET LENGTH OF SYSIN KEY
         BZ    INVALKEY      ERROR-2 CONSECUTIVE DELIMITERS-NO KEY
         BCTR  R7,0          POINT TO 1ST BYTE OF KEY
         STC   R1,0(0,R7)    STORE ACTUAL LENGTH OF KEY IN 1ST BYTE
         CLI   DELIMITR,C'#'    IS DELIMITER '#' - 'AND' KEY
         BE    DELIM#        YES
RESET    MVI   0(R10),X'00'    RESET TRANSLATE TABLE TO LOW VALUES
         AR    R7,R5        POINT TO NEXT SYSIN KEY ENTRY
         CR    R7,R13       IS THIS LAST ENTRY
         BL    ELOOP          NO
         LR    R7,R9     RESET R7 TO POINT TO START OF TABLE
         SPACE 2
         LA    R12,0     CLEAR R12
         L     R9,=A(POSLENS)
LPLOOP   CLI   0(R9),X'FF'     ARE THERE ANY MORE COLUMN SPECIFICATIONS
         BE    COLSET
         L     R10,0(0,R9)  GET 'FROM' COLUMN SPECIFICATION
         LA    R11,4(0,R9)       POINT TO 'TO' COL SPECIFICATION
         L     R11,0(0,R11)    GET 'TO' COLUMN SPECIFICATION
         SR    R11,R10          PUT INTERVAL LENGTH-1 IN R11
         LA    R11,1(R11)       PUT ACTUAL INTERVAL LENGTH IN R11
         STH   R10,COLSTORE(R12)      STORE 'FROM' COL IN COLSTORE
         STH   R11,COLSTORE+2(R12)    STORE INTERVAL LENGTH IN COLSTORE
         LA    R12,4(R12)
         LA    R9,8(R9)           POINT TO NEXT 'FROM','TO' COLUMN PAIR
         C     R12,=F'12'
         BL    LPLOOP
COLSET   ST    R12,COLCOUNT
         SPACE 3
ECOMPAR1 EQU   *
         L     R3,STARTADR    LOAD ADDR OF BEGINNING OF REC
         LA    R12,0          CLEAR R12
NEWKEY   CR    R7,R13         IS THIS THE END OF THE TABLE
         BNL   TSRCH99            YES
         CLI   0(R7),X'FF'    IS THIS A VALID KEY ENTRY
         BE    NEXTEKEY NO
         IC    R12,0(0,R7)    INSERT LENGTH OF SYSIN KEY INTO R12
         SPACE 1
         MVI   ECOMPAR2+3,X'01'  RESET DISPLACEMENT OF SYSIN KEY FOR #
         CLI   19(R7),C'#'   'AND' KEY? # IN LAST BYTE OF SYSIN REC
         BE    SET#PROC       YES - DO 'AND' KEY PROCESSING
SET#RET  MVI   ECOMP#+1,SETNOP   RESET BRANCH AFTER FIRST MATCH ON #
E#CONT   BCTR  R12,0       SUBTRACT 1 FROM LENGTH FOR CLC INSTRUCTION
         STC   R12,ECOMPAR2+1      MOVE IN LENGTH ATTRIBUTE
         STC   R12,ECHG+1      MOVE IN LENGTH ATTRIBUTE FOR E OPT CHG
         STC   R12,ECLC+1      MOVE IN LENGTH ATTRIBUTE FOR E OPT CLC
         LA    R12,1(R12)        RESET R12 TO ACTUAL KEY LENGTH
         LA    R9,0                    CLEAR R9
NEWCOL   C     R9,COLCOUNT        ARE THERE ANY MORE COLUMN PAIRS
         BE    NEXTEKEY                 NO
         LH    R10,COLSTORE(R9)     GET 'FROM' COLUMN SPECIFICATION
         LH    R11,COLSTORE+2(R9)   GET INTERVAL LENGTH
         SPACE 1
EVOPTBR  B     EUOPTBR       NOP ON RECFM=V RECS
         LH    R2,0(0,R3)  GET RDW AND PLACE IT IN R2
         B     EUVCOMP     GO TO COMMON RECFM U OR V RTN
         SPACE 1
EUOPTBR  B     NOTEU         NOP ON RECFM=U
         L     R2,=A(DCBADDR)  GET DCB ADDR OF INPUT FILE
         L     R2,0(R2)
         LH    R2,LRECL(R2) GET BLKSIZE FROM DCB LRECL FIELD
EUVCOMP  CR    R10,R2     IS 'FROM' COL GREATER THAN BLKSIZE/RDW
         BH    NEXTEKEY            YES
         AR    R10,R11          NO-R11=LENGTH,R10 NOW HAS 'TO' COL
         CR    R10,R2           IS 'TO' COL GREATER THAN BLKSIZE/RDW
         BH    ADJUSTU              YES-ADJUST LENGTH
         SR    R10,R11       NO-RESTORE R10 TO 'FROM'
         B     NOTEU            GET OUT
         SPACE 1
ADJUSTU  SR    R10,R11         RESTORE R10 TO 'FROM' COL
         SR    R2,R10  R2=(BLKSIZE/RDW-'FROM' COL)=LENGTH OF INTERVAL
         LA    R11,1(R2)     MOVE ACTUAL INTRVAL LENGTH TO R11
NOTEU    EQU   *
         SPACE 1
         LA    R10,0(R10,R3)    SET R10 TO POINT WITHIN INPUT REC
NEWCHAR  CR    R12,R11            IS KEY LENGTH MORE THAN INTERVAL LENG
         BH    NEXTCOLS              YES-GET NEXT COLUMN PAIR
ECOMPAR2 CLC   1(0,R7),0(R10)  NO-COMP SYSIN KEY TO REC;DISPL MOD '#'
ECOMP#   NOP   COMP#KY       CHG TO BE ON 'AND' KEY
         BE    ECHGMTCH  MATCH FOUND
         LA    R10,1(R10)     POINT TO NEXT BYTE OF INPUT FILE
         BCT   R11,NEWCHAR      LOOP BACK FOR NEXT COMPARE
NEXTCOLS LA    R9,4(R9)         POINT TO NEXT COLUMN PAIR
         B     NEWCOL
NEXTEKEY LTR   R15,R15  HAS RECORD ALREADY BEEN SELECTED
         BZ    TEND     YES
*        A RECORD CAN ALREADY HAVE SELECTED AND STILL GET TO THIS POINT
*        IF THE E OPTION WITH THE CONVERT CHANGE KEY HAS BEEN REQUESTED
*        AND THE RECORD CONTAINED A CHANGE-KEY SO THAT THE SEARCH FOR
*        MORE CHANGE-KEYS CONTINUES ON THAT RECORD.
         AR    R7,R5    NO- POINT TO SYSIN KEY
         B     NEWKEY
         SPACE 2
INVALKEY BCTR  R7,0
         MVI   0(R7),X'FF'      MARK THE AS INVALID
         B     RESET        CONTINUE PROCESSING THE SYSIN KEYS
         SPACE 2
ECHGMTCH B     TMATCH  SET TO NOP IF E OPT CHANGE (CONVERT) REQUESTED
ECLC     CLC   0(0,R10),ECHNGKEY+1 IS THIS THE E OPT KEY TO BE CHGED
         BNE   TMATCH             NO
         CP    ECHGCNT,EJEQUCNT Y-IS J= SATISFIED FOR NO. OF KEYS CHGED
         BL    ECHG      NO -  DO  MORE KEY CHANGES
         LTR   R15,R15  WAS THIS RECORD MATCHED ALREADY
         BZ    TEND     YES- GET OUT
         B     TMATCH   NO-SELECT RECORD AND COUNT BUT DONT ADD TO CHG
ECHG     MVC   0(0,R10),ECHNGKEY+20 MVE CHANGE INTO RECORD
         AP    ECHGCNT,=P'1'     YES-ADD 1 TO CHG COUNT
         CLI   EMTCHFLG,C'0'       IS THIS THE FIRST CHANGE IN RECORD
         BH    EMULTMCH          NO-
         MVI   EMTCHFLG,C'1'     YES- SET FLAG TO INDIC FIRST CHG
         B     TMATCH            GO TO MATCH AND CNT ROUTINE
         SPACE 2
EMULTMCH AR    R10,R12         POINT BEYOND CHANGED KEY,R12=KEY LEN
         BCT   R11,NEWCHAR     CONTINUE SEARCHING
         B     NEXTCOLS
         SPACE 2
DELIM#   L     R2,DELIMADR     GET 2ND DELIMITER ADR
         TRT   1(17,R2),TRNSTAB6  FIND 3RD # DELIMITER
         BZ    RESET           NO 'AND' KEY PROCESSING
         S     R1,DELIMADR     GET LENGTH OF 2ND 'AND' KEY +1
         BCTR  R1,0            SUBTR 1
         LTR   R1,R1           IS LENGTH =0  I.E. CONSECUTIVE #'S
         BZ    RESET           YES - NO 'AND' KEY PROCESSING
         L     R2,DELIMADR     GET 2ND '#' DELIM ADDR AGAIN
         STC   R1,0(R2)        PLACE 2ND KEY LENGTH IN 2ND DELIM
         MVI   19(R7),C'#'      SET LAST BYTE OF SYSIN REC TO '#'
         B     RESET
         SPACE 2
SET#PROC MVI   ECOMP#+1,SETBE  SET BE TO FORCE COMPARISON OF 2ND KEY
         B     E#CONT          CONTINUE
         SPACE 2
COMP#KY  L     R3,STARTADR      GET START ADDR OF RECORD
         IC    R12,0(R7)        GET L1
         LA    R9,2(R12)        GET L1+2
         STC   R9,ECOMPAR2+3    SET DISPLAC TO POINT TO 2ND 'AND' KEY
         IC    R12,1(R12,R7)    GET L2 INTO R12
         B     SET#RET          RETURN TO FIND 2ND KEY
         TITLE 'E,T,P,G WRAP-UP LOGIC'
TMATCH   EQU   *
         CR    R7,R13    HAVE WE HIT END OF TABLE
         BNL   TSRCH99   YES
BYPCNT   NOP   TNMATCH       CHANGED TO B ON N SUBOPTION
TMATCH1  L     R2,0(0,R7)    POINT TO THE BINARY COUNT FLD-DISPLAC ADJ
         CVD   R2,PACKCNT    PACK THE COUNT FLD
         CP    PACKCNT,SELCOUNT HAS THE COUNT FOR THIS ENTRY BEEN MET
         BNL   TSRCH99          YES IT HAS CHECK REJECT FOR EOJ
*
         LA    R2,1(R2)      ADD 1 TO THE ENTRY IN THE TABLE
TABLEADD ST    R2,0(0,R7)    RESTORE THE COUNT
TNMATCH  SR    R15,R15        MOVE 0 TO RETURN CODE-PUT OUT MATCH REC
*
*         THIS IS THE CSECT EXIT.  RESTORE REGISTERS AND EXIT.
* FROM   THE E OPTION WITH CONVERT FILE CODED ($ CHANGE) THE EXIT TO
*        THE CSECT IS ENCOUNTERED IN 3 DIFFERENT WAYS DEPENDING ON
*        THE SETTING OF THE EMTCHFLG FLAG:
*        FLAG=0 - THERE WAS NO MATCH ON ANY KEYS OR THE RECORD WAS
*        SELECTED ON A NON-CHANGE KEY (HENCE NO FIELDS ON THE RECORD
*        WERE CHANGED).
*        FLAG=1 - THIS IS THE FIRST MATCH ON A CHANGE-KEY AND WE WILL
*        CONTINUE TO SEARCH THE RECORD FOR MORE CHANGES BY SETTING THE
*        FLAG TO 2.
*        FLAG=2 - THE RECORD WAS SELECTED ON A CHANGE-KEY AND SEARCHING
*        THE RECORD FOR ADDITIONAL KEYS HAS ENDED.
*
TSRCH99  B     TEND        SET TO NOP ON E OPT WITH CONVERT FILE ($CHG)
         CLI   EMTCHFLG,C'1'  IS FLAG=0 OR 2
         BNE   TEND           YES - END SEARCH ON THIS RECORD
         MVI   EMTCHFLG,C'2'  NO FLAG=1 SET IT TO 2 AND KEEP SEARCHING
         B     EMULTMCH
         SPACE 3
TEND     MVI   EMTCHFLG,C'0'  RESET THE E OPT FLAG FOR $ CHANGES
         LM    R6,R14,SAVEAREB
         DROP  R6         DROP THE REG 6 AS BASE
         BR    R14                    RETURN TO CALLER
         SPACE 2
PACKCNT  DS    D           USED TO CONVERT THE COUNT
COLCOUNT DS    F
STARTADR DS    F
DELIMADR DS    F        ADDRESS OF  2ND '#' DELIMITER
COLSTORE DS    6H
TRNSTAB6 DC    256X'00'
SELCOUNT DC    PL8'0' THE SELECT CNT IS PASSED HERE FROM R2 ON 1ST CALL
ECHGCNT  DC    PL8'0'    NUMBER OF KEYS CHANGED ON E OPT WITH CONVERT
EJEQUCNT DS    PL8       NUMBER OF KEYS TO BE CHGED ON E OPT W $ OR @
ALLDONE  DC    C'0' 0 IS USED TO INDICATE THAT THE SORT IS DONE
EMTCHFLG DC    C'0'  FLG TO DETERMINE IF E OPT CHANGE PROCESS CONTINUES
DELIMITR DS    CL1              SAVE DELIMITER CHARACTER (FOR #)
ECHNGKEY DS    CL40 SAVE AREA FOR 1ST E OPT SYSIN KEY AND CONVERT KEY
         LTORG
         TITLE 'PRINT SUBROUTINE'
******** THIS IS A CSECT TO OUTPUT SYSUT2,3,4,OR 5 TO A PRINT DATA SET.
*        IT IS REENTRANT CODED SO THAT ANY OR ALL OF THE ABOVE DATA
*        SETS MAY BE PUT OUT TO ANY SYSOUT CLASS DURING THE SAME
*        HFSELECT RUN.
*        IT IS INVOKED BY CODING SYSOUT=A,H,C,ETC. IN THE DD STATEMENT
*        FOR WHICH AN OUTPUT PRINT IS DESIRED. IF HEX PRINT AS WELL AS
*        CHARACTER PRINT IS DESIRED, CODE SYSOUT=CLASS,DCB=RECFM=A.
*        FOR CHAR + RULER LINE, CODE SYSOUT=CLASS,DCB=RECFM=M.
*
*         EXAMPLES: //SYSUT4  DD  SYSOUT=A    CHARACTER PRINTOUT
*                   //SYSUT2  DD  SYSOUT=C,DCB=RECFM=A   HEX AND
*                                                      CHARACTER
*                   //SYSUT3  DD  SYSOUT=A,DCB=RECFM=M  CHAR+RULER
*        THE LINKAGE AND REGISTER CONVENTIONS ARE:
*         R0-THE ADDRESS OF THE INPUT RECORD IS PASSED THRU R0
*            AND THEN LOADED INTO R8
*         R1-THE ADDRESS OF THE OUTPUT DCB IS PASSED THRU R1
*            AND THEN LOADED INTO R9
*         R2-THE ADDRESS OF THE INPUT DCB IS PASSED THRU R2
*            AND THEN LOADED INTO R10
*         R5-END OF RECORD - *'S COUNTER, R6-RECORD LENGTH COUNTER
*         R7-CONTANT BINARY 100, R11-BAL REGISTER
*
PRINTER  CSECT                 DEFINE ENTRY POINT
         USING *,R15           SET R15 AS BASE REGISTER
         STM   R0,R14,MYSAVE   SYSTEM REGISTERS IN MYSAVE
         CNOP  0,4
         BAL   R12,JUMPSAV2
MYSAVE   DS    15F
JUMPSAV2 LM    R8,R10,MYSAVE
         USING MYSAVE,R12
         DROP  R15
**             ROUTINE TO INITIALIZE HEX PRINT
         TM    RECFM(R9),X'04'   IS RECFM=A I.E. IS HEX REQUESTED
EXITNOP1 BNO   CARDPNCH   NO- SET TO NOP WITH X0 FORMAT=HEX EXIT
         MVI   BR2HEX+1,SETNOP SET NOP FOR HEX PRINT
         B     MAINPROG
CARDPNCH TM    RECFM(R9),X'02'   IS RECFM=M I.E. IS RULER LINE REQUST
EXITNOP2 BNO   MAINPROG   NO- SET TO NOP WITH X0 FORMAT=RULER EXIT
         MVI   PRTRULER+1,SETNOP NOP TO PRINT RULER
MAINPROG EQU   *
         LA    R7,100            R7 CONTAINS MAX PRINT LINE LENGTH
         SR    R5,R5             END OF RECORD INDICATOR
         C     R9,=A(MERGE)      IS THIS THE MERGE FILE
         BNE   NOTMERGE          YES
         MVC   FILE+2(6),=C'MERGE '  MERGE FILE
NOTMERGE L     R3,=A(SYSUTX)     NO
         MVC   FILE+7(1),0(R3) MOVE IN SYSUTX (X=2,3,4,5)
         C     R10,=A(CARDS)   IS THE INPUT DATA SET SYSIN
         BNE   REGCOUNT              NO
         L     R3,=A(RCOUNT)   YES -USE THE SYSIN COUNTER
         ED    PTRECNO,3(R3)     EDIT THE COUNT (UP TO 9 DIGITS)
         B     PRTBEGIN              GO TO BEGIN PRINT
REGCOUNT L     R3,=A(ENDCT)   PICK UP ADDR OF ENDCT (RECORD COUNT)
EDIT     ED    PTRECNO,3(R3)     EDIT THE COUNT (UP TO 9 DIGITS)
         SPACE 2
         L     R3,=A(BR2VSGET)
         CLI   1(R3),SETBR       IS THE INPUT VSAM
         BE    VSAMPRT           YES- GO PICK UP THE RDW IMMEDIATELY
         C     R10,=A(LIBRARY)  NO-IS THE INPUT A PDS
         BNE   PRTBEGIN          NO
         L     R3,=A(BLDENTRY)    YES-PICK UP THE MEMBER NAME
         MVC   PTRECNO+2(8),0(R3)  MOVE THE MEMBER NAME TO PRINT LINE
         SPACE 2
PRTBEGIN LH    R6,LRECL(R10)      PICK UP RECORD LENGTH
         LTR   R6,R6              IS REC LENGTH ZERO
         BNZ   ARND2            GO AROUND IF NOT
         LH    R6,BLKSIZE(R10)    ELSE PICK UP BLKSIZE
ARND2    TM    RECFM(R10),RECFMF  TEST FOR FIXED OR UNDEFINED
         BO    RTNADDR1           BRANCH IF EITHER
VSAMPRT  LH    R6,0(R8) FOR VAR RECS MOVE RDW INTO REG-R8 PTS TO REC
         LA    R8,4(R8)           SET RECORD POINTER TO FIRST BYTE
         S     R6,=F'4'           ADJUST RECORD LENGTH
RTNADDR1 LR    R4,R7              SET PRINT COUNT FOR MAX
         BCTR  R4,0
         CR    R6,R7              IS RECORD LONGER THAN MAX PRINT LNE
         BH    ARND1              IF SO PRINT MAX LINE
         LR    R4,R6              ELSE PRINT RECORD
         BCTR  R4,0               SUBTRACT ONE FROM COUNT
         LA    R5,PRNTWK+2(R4)    SET UP MOVE REG
         MVC   0(2,R5),ASK       MOVE TWO * TO END OF RECORD
ARND1    MVC   PTFROM,MASK1       MOVE EDIT MASK TO PRINT
         ED    PTFROM,RECNT       EDIT BEGINNING NO OF RECORD
         CVD   R4,RECCOUNT        END POSITION OF RECORD
         AP    RECNT,RECCOUNT
         MVC   PTTO,MASK1         MOVE EDIT MASK TO PRINT
         ED    PTTO,RECNT         EDIT ENDING NO OF RECORD
         AP    RECNT,PONE         ADD ONE FOR NEXT LOOP
         LTR   R5,R5             HAS END OF RECORD BEEN FOUND
         BNZ   SKIPASK           IF NOT - RETURN
         MVI   ASK1,C'*'         MOVE * TO POSITION 101
SKIPASK  STC   R4,MOVE+1          MOVE RECORD OR PORTION TO PRINT
         STC   R4,MVSPRINT+1     DELETE CONTROL CHARS. IN PRINT STRING
MOVE     MVC   PRNTWK+1,0(R8)     MOVE RECORD TO PRINT AREA
ASCIIPRT B     MVSPRINT    SET TO NOP WITH X0 FORMAT=ASCII EXIT
         XLATE PRNTWK,100,TO=E    TRANSLATE TO ASCII
MVSPRINT TR    PRNTWK+1,TABLE4 TRANSLATE PRINT LINE OF CHARACTERS
         SPACE 1
BR2HEX   B     NOHEX             CHANGED TO NOP ON HEX OPTION
         MVI   PRNTWK,C'0'        FORCE DOUBLE SPACING BETWEEN LINES
         BAL   R11,PRINTSUB       PRINT CHARACTERS FIRST
         XC    HEXAREA,HEXAREA    ZERO HEXAREA
         STC   R4,MOVEZONE+1      MOVE ZONE PORTION TO HEXAREA
         STC   R4,TRANSZN+1       TRANSLATE ZONE PORTION
         STC   R4,MOVENUMR+1      MOVE NUMERIC PORTION TO HEXAREA
         STC   R4,ZONELINE+1
         STC   R4,TRANSNO+1       TRANSLATE NUMERIC PORTION
         STC   R4,LNO+1       ADJUST LENGTH FOR PRINTING SCALE
MOVEZONE MVZ   HEXAREA,0(R8)   MOVE ZONES
TRANSZN  TR    HEXAREA,TABLE2  TRANSLATE ZONES
ZONELINE MVC   PRNTWK+1,HEXAREA   MOVE TRANSLATED PORTION TO PRNT
         BAL   R11,PRINTSUB       PRINT FIRST LINE - ZONE
         XC    HEXAREA,HEXAREA    ZERO HEXAREA
MOVENUMR MVN   HEXAREA,0(R8)   MOVE NUMERIC PORTION
TRANSNO  TR    HEXAREA,TABLE3      TRANSLATE NUMERIC
         EX    0,ZONELINE         MOVE TRANSLATED PORTION TO PRNT
         BAL   R11,PRINTSUB
LNO      MVC   PRNTWK+1(1),LINECT MVE IN LINE COUNT LINE (LENGTH ADJ)
NOHEX    BAL   R11,PRINTSUB       GO TO PRINT SUBR
PRTRULER B     NORULER   SET TO NOP IF RECFM=M REQ TO PRINT RULER
         EX    R4,LNO            SET UP TO PRINT RULER LINE
         BAL   R11,PRINTSUB   PRINT
NORULER  AR    R8,R7              ADD MAX NO OF CHAR TO REC POINTER
         SR    R6,R7              SUBTRACT MAX LENGTH FROM REC COUNTER
         BP    RTNADDR1           LOOP BACK IF MORE TO PRINT
         SPACE 2
         MVI   ASK1,BLANK1      RESET ANY DATA NAMES AND INSTRUCTIONS
         MVI   BR2HEX+1,SETBR          THAT HAVE BEEN MODIFIED
         MVC   PTRECNO,MASK1
         MVC   FILE+2(5),=C'SYSUT'   REPLACE 'SYSUT' IN THE PRINT LINE
         ZAP   RECNT,PONE
         LM    R0,R14,MYSAVE
         BR    R14
         SPACE 2
PRINTSUB PUT   (R9),PRNTWK    WRITE 100 BYTE PORTION
         MVI   PRNTWK,BLANK1     BLANK PRINT AREA
         MVC   PRNTWK+1(132),PRNTWK
         BR    R11
         SPACE 4
RECCOUNT DS    D
PONE     DC    P'1'
RECNT    DC    PL3'1'
MASK1    DC    X'40202020202020202020'
ASK      DC    C'**'
LINECT   DC    C'----+----1----+----2----+----3----+----4----+----5'
         DC    C'----+----6----+----7----+----8----+----9----+----0'
TABLE2   DC    16C'0',16C'1',16C'2',16C'3',16C'4',16C'5',16C'6',16C'7'
         DC    16C'8',16C'9',16C'A',16C'B',16C'C',16C'D',16C'E',C'F'
TABLE3   DC    C'0123456789ABCDEF'
TABLE4   DC    64C' '        ** CHANGE TO ACTUAL CHAR EXCEPT CAR CONTR*
         DC    X'404142434445464748494A4B4C4D4E4F'
         DC    X'505152535455565758595A5B5C5D5E5F'
         DC    X'606162636465666768696A6B6C6D6E6F'
         DC    X'707172737475767778797A7B7C7D7E7F'
         DC    X'808182838485868788898A8B8C8D8E8F'
         DC    X'909192939495969798999A9B9C9D9E9F'
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'
         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'
         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'
PRNTWK   DS    0CL133
         DC    101C' '
ASK1     DC    C' '
PTRECNO  DC    X'40202020202020202020'  RECORD NO FROM SYSUT1/SYSIN
PTFROM   DS    X'402020202020'
PTTO     DS    X'402020202020'
FILE     DC    C'  SYSUT  '
HEXAREA  DS    CL100
         LTORG
         TITLE 'READDSCB CSECT FOR V OPTION'
READDSCB CSECT
*        THIS CSECT INVOKES THE SUBROUTINE READVTOC (THRU THE LOAD
*        MACRO) WHICH RETURNS DSCBS TO THIS PROGRAM BASED ON THE
*        VOLSERS PASSED TO IT IN A MASK DATA AREA. THE DSCB AND OTHER
*        INFORMATION (VOLSER, ETC) IS PASSED BACK TO THE TARGET
*        DATA AREA. R1 IS USED TO PASS THE ADDRESS OF THE MASK AND
*        TARGET AREAS TO READVTOC. THE VOLSER MAY BE GENERIC E.G.
*        HRSHR*. WHEN ALL THE DSCBS ON THE SPECIFIED VOLSER(S) HAVE
*        BEEN RETURNED, READVTOC PASSES A RETURN CODE OF 4 IN R15.
*        THE NEXT VOLSER(S) ON THE VOLSER TABLE IS MOVED INTO THE MASK
*        AND THE PROCESS REPEATED.
*        WHEN A DSCB IS RETURNED IT IS FIRST CHECKED TO ENSURE THAT IT
*        IS A FORMAT1 DSCB REPRESENTING A PHYSICAL DATA SET ON THE VOL.
*        THE DSN OF THE DSCB IS COMPARED TO EVERY ELEMENT IN THE
*        SYSIN TABLE. IF A GENERIC ELEMENT HAS BEEN SPECIFIED IN THE
*        SYSIN TABLE ALL DSNS
*        MATCHING ON THE GENERIC CRITERIA ARE SELECTED. IN PARTICULAR,
*        IF '*' WAS SPECIFIED ALL DSCBS ON THE REQUESTED VOLUMES
*        WILL BE SELECTED. IF A DSN HAS BEEN SPECIFIED TOGETHER WITH
*        A (GENERIC) MEMBER NAME IN THE SYSIN TABLE THE DSCB READ
*        FROM THE VTOC IS FIRST CHECKED TO ENSURE THAT IT IS A PDS.
*        IF IT IS, THAT PDS IS DYNAMICALLY ALLOCATED (TO LIBFILE)
*        AND OPENED SO THAT ITS DIRECTORY MAY BE READ. ALL MEMBERS
*        OF THE PDS THAT MATCH THE (GENERIC) SYSIN MEMBER NAME ARE
*        SELECTED. E.G. ALL MEMBERS PREFIXED BY 'ABC' IN ALL PDSS WITH
*        HIGH-LEVEL QUAL 'SYS1' WILL BE SELECTD WITH KEY SYS1.*(ABC*).
*        TO SELECT ALL MEMBERS OF ALL PDSS CODE *(*).
*
*        WILDCARD MATCHING CRITERIA IS ALSO ALLOWED:
*        IF % WAS CODED IN COLUMN 1 OF SYSIN RECORD THEN ALL
*        HIGH ORDER QUALIFIERS ARE AUTOMATICALLY CONSIDERED MATCHES
*        IF + OR STRINGS OF +'S ARE CODED ANYWHERE IN THE DSN
*        THEN THE CORRESPONDING CHARACTERS IN THE DSCBS ARE AUTOMAT
*        CONSIDERED MATCHED.
*        IF ! DELIMITERS ENCLOSE A STRING THEN THE DSCB IS SEARCHED FOR
*        THE OCCURRENCE OF THAT STRING ANYWHERE IN THE DSCB
*
*        ALL SYSIN ARE CONSIDERED BEFORE A DSCB IS REJECT, HENCE THE
*        SAME DSCB MAY CAUSE MORE THAN 1 MATCH.
*        COUNTS OF ALL PROCESSED AND SELECTED DSCBS, PDSS AND MEMBERS
*        ARE KEPT.
*
*        IF THE CATALOG SEARCH FORM OF THE V OPTION IS REQUESTED (NO
*        VOL= CARD IN VSYSIN) THEN PROCESSING IS DIFFERENT. EACH DSN
*        IN THE VSYSIN FILE, IN TURN, IS PASSED TO THE CATALOG SEARCH
*        ROUTINE, IKJEHCIR, WHICH RETURNS ALL FULLY QUALIFIED DSNS
*        BEGINNING WITH THE REQUESTED DSN AND ASSOCIATED VOLSERS.
*        EACH DSN AND VOLSER IS THEN PASSED TO A VTOC SEARCH ROUTINE
*        WHICH RETURNS THE REQUIRED INFO EXCEPT FOR CATALOGED TAPE
*        DATASETS (ONLY DSN AND VOLSER OUTPUT).
*        FOR VSAM DATA SETS AN OBTAIN MACRO IS USED TO GET THE ATTRIB
*        RATHER THAN THE CVAFDIR MACRO WHICH CANT FIND VSAM DS IN
*        SUBALLOCATED DATA SPACES.
*
*        OUTPUT- A PHYSICAL SEQUENTIAL DATA SET (RECFM=FB,LRECL=100)
*        IS OUTPUT WITH ALL THE DSCBS WHICH MATCHED THE SYSIN CRITERIA.
*        SEE VRECOUT FOR A LIST OF ALL THE OUPUT FIELDS.
*       MULTI-VOLUME DATASETS PRODUCE MULTIPLE OUTPUT REC-FOR EACH VOL.
*       VSAM FILES IN MULTIPLE DATA SPACES ON THE SAME VOL PRODUCE
*        DUPLICATE OUTPUT RECORDS FOR EACH PIECE.
*
*           IF A PARM IN VSYSIN WAS CODED THE HFSELECT WILL CALL ITSELF
*        FOR EACH RECORD OUTPUT TO SYSUT2. THE FIRST RECORD OF VSYSIN
*        CONTAINS A PARM WHICH WILL BE PASSED TO EACH ATTACHED HFSELECT
*        THE PARM MAY HAVE A MAXIMUM LENGTH OF 78.
*        THE REMAINDER OF VSYSIN CONTAINS VOL= AND DSN/MEMBER STATEMENT
*        A PRIMARY FILE DD STATEMENT (SYSUT1,LIBFILE,
*        ETC) IS GENERATED FOR THE ATTACHED HFSELECT FROM THE SYSUT2
*        RECORD AND THAT ALONG WITH ANY SYSIN IS PASSED TO THE ATTACHED
*        SUBTASK. SYSUT2 SHOULD BE CODED AS SYSOUT=CLASS,DCB=OPTCD=U.
*        THE CLASS SHOULD BE A SAR CLASS SO THAT ALL THE SYSOUT OUTPUTS
*        FROM THE ATTACHED SUBTASKS ARE AVAILABLE ON-LINE UNFORMATTED.
*
*        REGISTER USAGE:
*        R12- BASE
*        R11- SECOND BASE
*        R1 - ADDRESS OF MASK AND TARGET ARES PASSED TO READVTOC
*           - ADDR OF LIBFILE DCB PASSED TO LIBCSECT TO READ DIRECTORY
*           - ADDR OF DYNALLOC PARAMETER LIST
*           - ADDR OF MESSAGE BLOCK PASSED TO MAIN CSECT
*           - WITH V,K=  R1 IS USED TO PASS BACK BASE REG ADDR-SAVEAREQ
*        R3 - BASE FOR IKJEHCIR WORKAREA
*        R4 - PDS DSECT
*        R5 - VOLSER TABLE
*        R6 - SYSIN TABLE
*        R8 - ADDR OF MEMBER NAME
*        R9 - WORK REGISTER
*        R10- BAL
*        R15- RETURN CODE FROM READVTOC (0=MORE DSCBS, 4=ALL DONE)
*             RETURN CODE TO MAIN CSECT (0=NORMAL END, 1=ERROR)
         USING *,R15
         STM   R2,R14,SAVEAREQ
         CNOP  0,4
         BAL   R12,JUMPSAVQ
SAVEAREQ DS    13F
VOPTREGS DS    13F   AREA TO SAVE V OPT CSECT REGISTER ENVIRON
BASEQ    DC    A(SAVEAREQ+4096)  SET UP BASE ADDR FOR R11
JUMPSAVQ EQU   *
         USING SAVEAREQ,R12,R11
         DROP  R15
         L     R11,BASEQ         SET UP SECOND BASE REG R11
*
*        GET ALTERNATE PGMNAME,IF ONE IS REQ ('PARM..'/PGMNAME,DDOUT)
         L     R4,=A(VPARM)      GET 'PARM..'/PGMNAME RECORD IF SPECIF
         L     R15,=A(SLSHTBL)
         TRT   2(78,R4),0(R15)   LOOK FOR /
         BZ    NOALTPGM          NO ALTERNATE PGM SPECIFIED
         ST    R1,VPGMADR        FOUND / - SAVE ADDR OF /
         L     R15,=A(COMATRT)   LOOK FOR ',' FOLLOWING PGMNAME
         MVI   X'40'(R15),X'40'  ALSO LOOK FOR SPACE
         TRT   1(9,R1),0(R15)    LOOK FOR ',' OR ' ' AFTER /
         BZ    NOALTPGM          NOT FND - INCORRECLY CODED
         STC   R2,VSAVDLM        SAVE THE DELIMITER FOUND
         L     R2,VPGMADR        GET BACK ADDR OF /
         ST    R1,VPGMADR        SAVE ADDR OF , OR SPACE
         SR    R1,R2             GET LENGTH OF PGM NAME
         BCTR  R1,0
         EX    R1,MVCPGMNM       EXECUTE THE MOVE OF PGMNAME
         CLI   VSAVDLM,C' '      DID A SPACE FOLLOW PGM NAME
         BE    NOALTPGM          YES - NO NO ALT DDNAME
         L     R1,VPGMADR        NO- IT WAS A COMMA - GET ALT DD
         MVC   VPGMDD,1(R1)      MOVE IN ALT DDNAME
         B     NOALTPGM
MVCPGMNM MVC   PGMNAME(*-*),1(R2)   MOVE IN PGM NAME
NOALTPGM EQU   *
*
*        LOAD READVTOC ROUTINE USING BLDL AND LOAD MACROS
         USING PDS2,R4       FOR LOAD MODULE DATA FIELD NAMES
         LA    R4,BLDLDATA
         MVC   BLDLDATA+0(8),PGMNAME         HFSELECT BY DEFAULT
         MVC   BLDLDATA+74(8),=CL8'READVTC'  NAME OF READ VTOC MODULE
         BLDL  0,BLDLLIST  WHICH MUST RESIDE IN THE LINKLIST OR STEPLIB
         LOAD  DE=BLDLDATA+74
         STCM  R0,15,EPA        STORE READVTOC ADDR IN EPA
         SPACE 1
         L     R5,=A(VOLSER)     PLACE VOLSER TABLE ADDR IN R5
         OPEN  (VREPORT1,OUTPUT)    OPEN REPORT1
         TM    VREPORT1+DCBFLAG,X'10' IS REPORT1 IN THE JCL
         BO    VGETCNT                YES -OK
         OI    VPUT+1,SETBR      NOP THE REPORT1 OUTPUT RTN
         SPACE 3
VGETCNT  L     R9,=A(COUNT)    GET J=COUNT
         MVC   VCOUNT,0(R9)
         L     R9,=A(COMPCNT)  GET MAXIMUM NUMBER OF RECS TO BE SELECT
         MVC   VTOTCNT,0(R9)
         SPACE 2
         RDJFCB (VREPORT2)     IS THERE A REJECT REPORT (VREPORT2)
         LTR   R15,R15
         BNZ   SETVSORT        NO
         OPEN  (VREPORT2,OUTPUT) YES - OPEN IT
         NI    VPUTREJ2+1,X'0F'  SET BR TO NOP TO WRITE REPORT2
         SPACE 2
*        ALPHABETIZE THE SYSIN KEYS CONTAINING DSNS
*        PLACE X'FF' IN BYTE 59 OF TBL ELT TO INDICATE END OF TBL
SETVSORT L     R6,=A(VOLTABL)  FIRST TABLE ELT
         MVI   VSORTDON,C'0'   SET SORT ENDED FLAG
VSORT    CLI   84(R6),X'00'  DOES NEXT TABLE ELT INDICATE END TBL
         BE    VSORTEND      YES- NO MORE SORTING NEEDED
*        THE DSN AND MEMBER NAME ARE USED AS SORT KEY
VSORTCLC CLC   6(52,R6),86(R6)  COMPARE 2 CONSECTIVE TABLE ELTS
         BNH   VSORTOK        THEY ARE ALREADY IN SORTED ORDER
         XC    0(80,R6),80(R6)  IF NOT IN ORDER,SWITCH ENTIRE ELEMENT
         XC    80(80,R6),0(R6)
         XC    0(80,R6),80(R6)
         MVI   VSORTDON,C'1'    INDICATE SORT NOT COMPLETED
VSORTOK  LA    R6,80(R6)   POINT TO NEXT TABLE ELT
         B     VSORT       CONTINUE SORTING
VSORTEND CLI   VSORTDON,C'0'    ANY MORE SORTING?
         BNE   SETVSORT         YES
         SPACE 1
         MVI   58(R6),X'FF'   PUT X'FF' IN COL59 FOR LAST ELT OF TABLE
         L     R6,=A(VOLTABL)  GET FIRST TABLE ELT AFTER SORT
         SPACE 1
         CLI   1(R5),X'00'    WAS CATALOG SEARCH (NO VOL=) REQUESTED
         BE    SETCAT         YES
         SPACE 1
         MVI   INITDSN,X'05'  NO-INIT INITDSN TO X'05' IN CASE
*        ALL DSNS ARE REQUESTED, SO IT WILL START AFTER FORMAT4 DSCB
         CLI   4(R6),X'FF'    ARE ALL DSNS REQUESTED
         BE    GETVOL         YES
         MVC   INITDSN,6(R6)  MOVE IN FIRST TABLE ELEMENT
         L     R15,=A(COMMABLK)   GET BLANK TRT TABLE
         TRT   INITDSN,0(R15)   FIND FIRST BLANK
         BZ    FULLDSN        FULL 44-BYTE DSN
         BCTR  R1,0           POINT TO LAST BYTE OF DSN
SETLSTCH LA    R2,0           CLEAR R2
         IC    R2,0(R1)       GET LAST CHARACTER OF DSN
         BCTR  R2,0     SUBTRACT 1 FROM ITS BINARY REPRESENTATION
         STC   R2,0(R1) STORE IT BACK INTO INITDSN
         MVC   DSN1STCH,INITDSN  SAVE THE FIRST CHAR
*        SINCE ITS OVERLAYED BY X'FF' TO INDICATE EOV
         SPACE 3
GETVOL   MVC   ENDVOLFL,0(R5)     GET VOLSER FLAG END INDICATOR
         MVC   MASKVOL(6),1(R5)     MOVE VOLSER TO MASK
GETDSCB  LA    R1,RVPARML       GET MASK/TARGET PARM ADDR
         L     R15,EPA          PASS CONTROL TO READVTOC MODULE
         BALR  R14,R15
         MVC   INITDSN(1),DSN1STCH   RESET THE FIRST CHAR OF INITDSN
*        IN CASE EOV WAS HIT AND X'FF' WAS MOVED INTO FIRST BYTE
         C     R15,=F'4'        RETURN CODE
         BE    GETNXVOL       NO MORE DSCBS ON SPECIFIED VOLUMES
         BH    VERROR          CVAF ERROR
         CLI   DSCBFMT,C'1'    DSCB RETURNED- IS IT A FORMAT 1
         BNE   GETDSCB           NO - GET ANOTHER
         AP    PDSCBTOT,ONE      YES -ADD 1 TO DSCB PROCESSED
         L     R6,=A(VOLTABL)    POINT TO FIRST DSN IN SYSIN TABLE
VKEYLOOP CLI   4(R6),X'00'        IS THIS THE END OF THE SYSIN TABLE
         BE    GETDSCB            YES - GET A NEW DSCB
         CLI   4(R6),X'FF'        NO- ARE ALL DSNS REQUESTED
         BE    CHKMEMKY          YES- CHECK IF MEMBERS ARE REQUESTED
         LA    R9,0              NO- INIT R9 TO 0
         IC    R9,4(R6)          GET DSN LENGTH
         BCTR  R9,0              SUB 1
         STC   R9,DSNCLC+1       STORE LENGTH IN CLC INSTRUCTION
         CLI   79(R6),C'%'    DOES TBL ELT CONTAIN A WILDCARD-%
         BE    WILDCARD       YES
         CLI   79(R6),C'!'    DOES TBL ELT CONTAIN A WILDCARD-!
         BE    FLOAT          YES
         MVC   WCDSCBDS,DSCBDSN  NO- MOVE DSCB TO WILDCARD CLC AREA
         SPACE 1
VCHKPLUS L     R15,=A(PLUSTABL)
         TRT   6(44,R6),0(R15)    CHECK FOR WILDCARD CHAR '+'
         BZ    DSNCLC      NONE
         MVI   WCNOP+1,SETBNE SET COMPAR TO BNE PERMANENTLY (DUE TO WC)
         MVC   PLUSMASK,6(R6)   MOVE TABLE ELEMENT TO MASK
         TR    PLUSMASK,0(R15)    TRANSLATE NON-'+'
         OC    WCDSCBDS,PLUSMASK  'OR' THE DSCB WITH THE MASK
         MVI   0(R15),X'FF'     CONVERT X'00' TO X'FF' IN THE TR TABL
         TR    PLUSMASK,0(R15)    TRANS ALL X'00' TO X'FF' IN MASK
         NC    WCDSCBDS,PLUSMASK  'AND' THE DSCB WITH THE MASK
*        THE ABOVE CODE HAS OVERLAYED THE '+'-MASK INTO THE DSCB
*        IN THE SAME PLACE AS THEY APPEAR IN THE SYSIN KEY BUT OTHERWIS
*        LEAVE THE DSCB UNCHANGED
         MVI   0(R15),X'00'     CONVERT X'FF' BACK TO X'00'
         SPACE 1
DSNCLC   CLC   6(0,R6),WCDSCBDS  DOES DSCB DSN MATCH TABLE ENTRY
*        IF THE % OR + WILDCARDS ARE BEING USED WE CANT USE THE
*        BL (TO CHKLAST) AND BH (TO GETDSCB) SHORTCUTS. E.G. IF
*        SYSIN CONTAINED ONLY 1 RECORD: +ABC, THE COMPARE TO THE
*        DSCB QBBC (CONVERTED TO +BBC) RESULTS IN A LOW COMPARE
*        AND WOULD TERMINATE COMPARISONS ON THIS VOLUME EVEN THO
*        DSCB RABC ON THE SAME VOLUME WOULD MATCH. SIMILARLY, IF THE
*        ONLY SYSIN WERE %SOURCE.COBOL, THE COMPARE AGAINST DSCB
*        ABC.TEST WOULD BE LOW AND DSCB XYZ.SOURCE.COBOL ON THE
*        SAME VOLUME WOULD BE MISSED AS A MATCH.
*             ALSO, IF SYSIN CONSISTED OF 2 RECORDS: %SOURCE.COBOL
*        AND: ABC.A THEN THE FIRST COMPARE AGAINST DSCB ABC.A
*        WOULD RESULT IN A HIGH (SOURCE.COBOL VS. A) AND THE NEXT
*        DSCB WOULD BE READ AND SYSIN RECORD ABC.A WOULD NEVER
*        GET MATCHED.
*            HENCE, WE MUST CHANGE THE FOLLOWING NOP TO A BNE NEXTVKEY
*        INSTRUCTION WHENEVER WILDCARD PROCESSING IS PRESENT.
*        IT MUST BE CHANGED PERMANENTLY ON BOTH % AND + BECAUSE
*        THE COLLATING ORDER OF SYSIN IS THROWN OUT OF WHACK.
*
VCHKPLSB NOPR  R10         SET TO BR ON CATALOG SEARCH
         SPACE 1
WCNOP    NOP   NEXTVKEY    SEE AVOVE EXPLANATION
         BL    CHKLAST           NO- CHK IF LAST TABLE ELEMENT
         BH    GETDSCB    NO - SINCE SYSIN TBL SORTED GET NEXT DSCB
CHKMEMKY CLI   5(R6),X'00'      YES- WAS A MEMBER REQUESTED
         BNE   PDSSRCH          YES - SEARCH THE PDS DIRECTORY
         MVC   VRECMEM,VBLANKS   NO- BLANK MEMBER NAME ON REPORT1
         BAL   R10,VPUT           PUT OUT REPORT1 REC
         SPACE 1
NEXTVKEY LA    R6,80(R6)        POINT TO NEXT SYSIN TABLE ELEMENT
CATNOP   B     VKEYLOOP         CHANGED TO NOP ON CATALOG SEARCH
         B     GETCAT
         SPACE 1
FULLDSN  LA    R1,INITDSN+43    POINT TO LAST CHAR OD DSN
         B     SETLSTCH
         SPACE 1
CHKLAST  CLI   58(R6),X'FF'     IS THIS THE LAST TABLE ELT
         BNE   NEXTVKEY         NO- GET THE NEXT TABLE ELEMENT
         MVI   INITDSN,X'FF'    YES - FOR IXVTOC SET INITDSN TO X'FF'
         B     GETDSCB          RETURN TO READVTOC RTN
         SPACE 3
WILDCARD L     R15,=A(WLDCRDTB)
         TRT   DSCBDSN,0(R15)    LOOK FOR '.' OR ' '
         LA    R2,DSCBDSN        GET ADDR OF FIRST BYTE OF DSCB
         SR    R1,R2    GET LENGTH UP TO FIRST '.' OR ' '
         LA    R1,1(R1)   LENGTH OF HIGH ORDER QUALIFIER INCLU '.'
         LA    R9,43
         SR    R9,R1      LEN OF DSCB MINUS HIGH ORDER QUALIFIER
         MVC   WCDSCBDS,VBLANKS    BLANK OUT COMPARE AREA
         STC   R9,MVWLDCRD+1   SET MVC LENGTH
         STC   R1,MVWLDCRD+5   SET MVC DISPLACEMENT
MVWLDCRD MVC   WCDSCBDS+1(0),0(R2)   SET UP WILDCARD CLC AREA
*        LEAVE 1 BLANK IN FRONT FOR % THAT WAS BLANKED OUT
         MVI   WCNOP+1,SETBNE SET COMPAR TO BNE PERMANENTLY(DUE TO WC)
         B     VCHKPLUS        CHECK FOR '+'
         SPACE 3
PDSSRCH  TM    DSCBORG,X'02'      IS DSCB DSORG=PO
PDSNOP1  BNO   NEXTVKEY     NO- GET NEXT SYSIN KEY ; NOP ON CAT SRCH
PDSBR1   NOP   VOLCNTLP     SET TO BNO ON CAT SEARCH
         RACHECK ENTITY=DSCBDSN,CLASS=DATASETX,VOLSER=TGVOLSER,        X
               LOG=NOSTAT     DO NO LOG TO AUDIT FILE
         CHI   R15,4     RESOURCE NOT PROTECTED?                  @MK1
         BE    NORACF    YES - OK                                 @MK1
         LTR   R15,R15   DETERMINE IF USER HAS SECURITY ACCESS TO DS
         BNZ   SECVIOL   NO
NORACF   EQU   *                                                  @MK1
         MVC   DYNDSN,DSCBDSN      YES- SET DSN IN DYNALLOC PARM LIST
         MVC   DYNVOLSR,TGVOLSER      SET VOLSER IN DYNALLOC
         MVC   DYNDDNAM,=C'VTEMPLIB'  USE VTEMPLIB AS DDNAME
         LA    R1,REQBLKP         PUT DYNALLOC PARM ADDR IN R1
         DYNALLOC
         LTR   R15,R15            WAS PDS SUCCESSFULLY ALLOCATED
         BNZ   DAIRFAIL                NO
         L     R9,=A(LIBRARY)     YES- LIBFILE DCB ADDR
         MVC   DCBDDNM(8,R9),=C'VTEMPLIB'  USE VTEMPLIB AS DDNAME
         OPEN  ((R9))    INSTEAD OF LIBFILE,FOR PDS DIRECTORY ACCESS
         LTR   R15,R15
         BNZ   VERROR
         AP    PPDSTOT,ONE         ADD 1 TO PDS PROCESSED
NXTVMEM  L     R1,=A(LIBRARY)       GET LIBFILE DCB ADDR
         L     R15,=A(LIBCSECT)     GET LIBCSECT ADDR
         BALR  R14,R15            GET NEXT DIRECTORY ENTRY
         LTR   R15,R15        0=OK, 1=END OF DIRECTORY
         BNZ   MEMNFND           MEMBER WAS NOT FOUND
         AP    PMEMTOT,ONE        ADD 1 TO MEMBERS PROCESSED
         L     R9,=A(SAVEINFO)    SEE LIBCSECT FOR CONTENTS OF AREA
         L     R8,0(R9)          GET ADDR OF MEMBER NAME
         USING PDSDRECT,R8     USE R8 AS BASE FOR PDS DIRECTORY
         CLI   5(R6),X'FF'     WERE ALL MEMBERS REQUESTED
         BE    MEMMATCH              YES- SELECT MEMBER
         LA    R9,0        NO- CLEAR R9
         IC    R9,5(R6)      GET ACTUAL MEMBER NAME LENGTH
         BCTR  R9,0                SUB 1
         STC   R9,MEMBCLC+1    SET LENGTH FOR CLC INSTRUCTION
MEMBCLC  CLC   50(0,R6),PDSMEMNM  DOES PDS MEMB NAME MATCH CRITERIA
         BH    NXTVMEM    PDS MEMBER NAME LOW - GET NEXT MEMBER NAME
         BL    MEMNFND                    HIGH- MEMBER NAME NOT FND
MEMMATCH MVC   VRECMEM,PDSMEMNM    EQUAL- PUT MEMB NAME IN REPORT1
         BAL   R10,VPUT        WRITE RECORD
         B     NXTVMEM         GET NEXT MEMBER
         SPACE 3
MEMNFND  L     R9,=A(LIBRARY)   GET LIBFILE DCB
         MVI   DSORG(R9),X'40'     RESET DSORG=PS FOR CLOSE
         CLOSE ((R9),FREE)      CLOSE PDS AND UNALLOC
         LTR   R15,R15
         BNZ   VERROR
         L     R9,=A(BRVRTN)
         MVI   1(R9),SETNOP    RESET NOP FOR READ DIRECTORY ON NEXT PDS
         L     R9,=A(RETURN3)
         MVI   3(R9),SETNOP    RESET DIRECTORY END FLAG FOR NEXT PDS
PDSNOP2  B     NEXTVKEY        SET TO NOP CATALOG SEARCH
         B     VOLCNTLP
         SPACE 3
GETNXVOL CLI   ENDVOLFL,X'80'  IS THIS THE LAST VOLSER ENTRY IN TABLE
         BE    VEOJ            YES - EOJ
         LA    R5,7(R5)        NO - POINT TO NEXT VOLSER
         B     GETVOL
         SPACE 2
FLOAT    MVI   WCNOP+1,SETBNE SET COMPARE TO BNE PERMANENTLY(DUE TO WC)
         L     R15,=A(COMMABLK)    GET BLANK TRT TABLE
         TRT   DSCBDSN,0(R15)      FIND FIRST BLANK
         BZ    FLOATFUL            FULL 44-CHAR DSN
FLOATCON LA    R2,DSCBDSN          GET ADDR OF FIRST BYTE OF DSCB DSN
         SR    R1,R2               GET LENGTH OF DSN
         BCTR  R9,0   SUBTRACT 1 FROM SYSIN DSN (FOR LEADING BLANK)
         SR    R1,R9  CALCULATE THE NUMBER OF ITERATIONS NEEDED
         BNP   NEXTVKEY   SYSIN STRING GREATER THAN ACTUAL DSCB DSN
         STC   R9,FLOATLOP+1    SET COMPARE LENGTH
FLOATLOP CLC   7(0,R6),0(R2)  START IN COL.7 TO BYPASS BLANK
         BE    CHKMEMKY       MATCH
         LA    R2,1(R2)       POINT TO NEXT CHAR IN DSCB DSN
         BCT   R1,FLOATLOP    TRY AGAIN
         B     NEXTVKEY    STRING DOES NOT OCCUR IN DSCB DSN
         SPACE 1
FLOATFUL LA    R1,DSCBDSN+44  POINT TO 1 BEYOND END OF DSCB
         B     FLOATCON       SO R1 WILL HAVE LENGTH OF 44
         SPACE 2
SECVIOL  MVC   VRECMEM,VBLANKS   BLANK OUT MEMBER NAME
         MVI   VRECVIOL,C'*'     PLACE * IN FILE- VIOLATION INDICATOR
         BAL   R10,VPUT WRITE JUST THE DATASET REC-MEMBER RECS UNACCES
         MVI   VRECVIOL,BLANK1   RESET
         B     NEXTVKEY
         TITLE 'V OPTION - RETRIEVE CATALOG OPTION'
SETCAT   OI    VCHKPLSB+1,X'F0'  SET BR VCHKPLUS RTN
         MVI   CATNOP+1,X'00'    SET NOP IN NEXTVKEY BRANCH
         MVI   BYPCAT+1,X'F0'    SET B TO BYPASS CATALOG CHECK
         MVI   PDSNOP1+1,X'00'   SET NOP  ON BR TO NEXTVKEY
         MVI   PDSBR1+1,X'E0'   SET BNO TO PROCESS NEXT ENTRY IN WKAREA
         MVI   PDSNOP2+1,X'00'   SET NOP  ON BR TO NEXTVKEY
         L     R0,CIRWALEN       GET LENGTH OF IKJEHCIR WORKAREA
         GETMAIN R,LV=(0)
         ST    R1,CIRWA          PLACE WORKAREA ADDR IN CIRWA
         L     R0,CIRWALEN
         S     R0,=F'4'
         STH   R0,0(R1)          PLACE HEADER IN WORKAREA
         SPACE 1
         L     R1,CVTPTR         UCB SCAN - GET CVT ADDR
         USING CVT,R1            UCB SCAN - CVT ADDRESSABILITY
         L     R15,CVTUCBSC      UCB SCAN - GET UCB SCAN ADDR
         ST    R15,SCANUCB       UCB SCAN - STORE UCB SCAN ADDR
         DROP  R1
         SPACE 1
         OI    BFLHFL,BFLHDSCB   CVAFDIR - BUFLIST DESCRIBES DSCBS
         MVI   BFLHNOE,1         CVAFDIR - ONLY 1 BUFLIST ENTRY
         MVI   BFLELTH,96        CVAFDIR - INDICATE 96-BYTE DSCB BUFFER
         LA    R1,DSCBFMT        CVAFDIR ADDR OF 96-BYTE RETURNED DSCB
         STCM  R1,15,BFLEBUF     CVAFDIR - STORE DSCB BUFFER ADDR
         SPACE 1
GETCAT   CLI   4(R6),X'00'       IS THIS THE LAST VSYSIN RECORD
         BE    VEOJ              YES - FINISHED
         CLI   79(R6),C' '       IS % OR ! WILDCARD USED
         BNE   VKEYERR           YES- IGNORE IT (NOT VALID)
         CLI   4(R6),X'FF'   ALL DATASETS REQUESTED (CODING * IN COL 1)
         BE    VKEYERR            YES- IGNORE IT (NOT VALID)
         MVC   HIGHQUAL,6(R6)    MOVE IN DSN FROM DSN TABLE
         SR    R9,R9             CLEAR
         IC    R9,4(R6)          GET DSN LENGTH FROM DSN TABLE
         BCTR  R9,0              SUB 1
         STC   R9,DSNCLC+1       SET UP DSN COMPARE WITH CATALOG RETRN
         L     R15,=A(PLUSTABL)
         TRT   HIGHQUAL,0(R15)   CHECK FOR + (* NOT THERE -CHK LENGHT)
         BNZ   CATGENRC          FOUND +,IT IS GENERIC
         CLI   4(R6),X'2C'       + NOT FOUND, WAS A * CODED?
         BE    VOLINFO2       NO, THE DSN LENG=44(* WOULD HAVE LEN<44)
*          SO ITS ONLY NECESSARY TO GET THE VOLSER THE DS IS ON
         IC    R9,4(R6)      YES-GET ACTUAL LENGTH
         LA    R1,HIGHQUAL(R9)   POINT TO WHERE * WOULD HAVE BEEN
CATGENRC ST    R1,SAVEWC         SAVE POSITION OF +
         L     R15,=A(WLDCRDTB)
         TRT   HIGHQUAL,0(R15)    FIND FIRST BLANK OR '.'
         BZ    VKEYERR            GENERIC IN HIGH ORDER QUALIFIER
*                                 IGNORE IT (NOT VALID)
         CLM   R2,1,=C' '         FOUND BLANK BEFORE '.'
         BE    VKEYERR            GENERIC IN HIGH ORDER QUAL -IGNORE
         C     R1,SAVEWC          COMPARE POSITION OF '.' TO +
         BH    VKEYERR            GENERIC IN HIGH ORDER QUAL -IGNORE
         LA    R1,HIGHQUAL+43     POINT TO END OF HIGHQUAL FLD
         L     R2,SAVEWC          GET ADDR OF + (*)
         SR    R1,R2              COMPUTE NUMBER OF BYTES FROM * TO END
         STC   R1,BLNKEND+1       AND STORE IN MVC INSTRUCTION
BLNKEND  MVC   0(*-*,R2),VBLANKS  BLANK OUT TO END
LOOPBLNK CLI   0(R2),C'.'         BLANK OUT BACKWARDS UNTIL FIND '.'
         BE    READCAT
         MVI   0(R2),C' '
         BCTR  R2,0
         B     LOOPBLNK
         SPACE 1
READCAT  EQU   *
         MVC   SRCHARG,HIGHQUAL  MOVE HIGH ORDER QUALIFIERS TO ARGUMENT
         MVI   CIRLOCRC,X'00'         RESET LOCATE RETURN CODE
         LA    R1,CIRPARM        LOAD PARAMETER LIST ADDR IN R1
         L     R3,CIRWA          GET CIR WORKAREA ADDR
         LA    R3,4(R3)          POINT BEYOND WORKAREA HEADER
         LINK  EP=IKJEHCIR
         CLI   CIRLOCRC,X'08' RC=8,DS NOT FOUND OR FULLY QUALIFIED DSN
*                                  SPECIFIED OR SECURITY VIOLATION
         BE    VOLINFO        YES
         CLI   CIRLOCRC,X'2C' RC=44,WORKAREA TOO SMALL (>1455 ENTRIES)?
         BE    VKEYERR        YES
         LTR   R15,R15
         BNZ   VERROR            ERROR IN CATALOG SEARCH RTN
DSNLOOP  CLI   0(R3),X'FF'       LAST ENTRY FOR THIS VSYSIN DSN?
         BE    NEXTVKEY          YES
         MVC   FILETYPE,0(R3)   NO-GET THE DSN TYPE (NON-VSAM, AIX,ETC)
         MVC   WCDSCBDS,1(R3)    SET UP WCDSCBDS FOR COMPARE
         MVC   DSCBDSN,1(R3)     STORE IN DSCB AREA-IN CASE OF TAPE
         LA    R3,45(R3)         POINT PAST THE FULL DSN
VOLRTN   SR    R9,R9             CLEAR
         IC    R9,0(R3)          GET NUMBER OF VOLUMES
         ST    R9,VOLNUM
         LA    R3,1(R3)          POINT PAST VOL COUNT
VOLCNTLP ICM   R9,15,VOLNUM      GET VOLUME COUNT
         BZ    DSNLOOP    NO MORE VOLUMES - GET NEW DSN FROM WKAREA
         BCTR  R9,0              SUB 1
         ST    R9,VOLNUM
         BAL   R10,VCHKPLUS      COMPARE DSNS                   <===
         BNE   NEXTVOL           DSNS NOT EQUAL - GET NEXT VOL  <===
         MVC   MASKVOL,4(R3)  EQ-MOVE VOLSER TO MASK FOR VTOC READ
         MVC   VRECOUT+58(42),VBLANKS    CLEAR OUTPUT REC
         CLI   2(R3),UCB3TAPE (X'80')       IS THE DATA SET ON TAPE
*        THIRD BYTE OF DEVICE TYPE INDICATES TAPE(X'80'),DISK(X'20')...
         BE    CATTAPE           YES
         LA    R3,12(R3)         NO-ON DISK. POINT PAST VOLUME INFO
         CLI   FILETYPE,C'A'    IS THIS DSN NON-VSAM
         BNE   OBTAIN            NO- USE OBTAIN RATHER THAN CVAFDIR
         SPACE 1
         XC    WKAREA,WKAREA     UCB SCAN - ZERO OUT WKAREA FOR NEW UCB
         LA    R1,PARMUCB        UCB SCAN - GET PARMLIST ADDR
         USING UCBOB,R9          UCB SCAN - SET ADDRESSABILITY
SRCHUCB  L     R15,SCANUCB       UCB SCAN ADDRESS
         BALR  R14,R15           UCB SCAN
         LTR   R15,R15           SUCCESSFUL?
         BNZ   CATTAPE2     VOLSER DOESNT EXIST IN UCB TABLE
         L     R9,ADDRUCB        GET UCB
         TM    UCBSTAT,UCBONLI    IS VOLUME ONLINE
         BZ    SRCHUCB            NO- KEEP SEARCHING
         CLC   UCBVOLI,MASKVOL   IS THIS THE VOLSER WE WANT?
         BNE   SRCHUCB       NO- KEEP SEARCHING
         DROP  R9
         MVC   TGVOLSER,MASKVOL MOVE VOLSER TO TARGET,NOT SUPL VIA CVAF
         CVAFDIR ACCESS=READ,BUFLIST=BUFLIST,UCB=(R9),DSN=DSCBDSN,     X
               BRANCH=(YES,PGM)              GET THE DSCB
         LTR   R15,R15
         BZ    GOTDSCB           SUCCESSFUL EXECUT OF CVAF-GOT THE DSCB
         USING CVPL,R1           ADDRESSABILITY TO CVPL FOR CVSTAT FLD
         CLI   CVSTAT,1          THE DSN WAS NOT FOUND ON VTOC- MUST BE
         BNE   CATTAPE2   A VSAM DATA SET IN A SUBALLOCATED DATA SPACE
         DROP  R1
OBTAIN   OBTAIN SRCHVTOC  SO DO OBTAIN CAMLST TO BUILD PSEUDO F1-DSCB
         LTR   R15,R15
         BNZ   CATTAPE2          STILL DIDNT FIND DSCB
         MVC   TGVOLSER,MASKVOL RESET, SINCE OBTAIN OVERLAYS TGVOLSER
*                               WITH THE CCHHR OF THE DSCB
GOTDSCB  AP    PDSCBTOT,ONE
         CLI   5(R6),X'00'       WAS A MEMBER REQUESTED
         BNE   PDSSRCH          YES - SEARCH THE PDS DIRECTORY
         MVC   VRECMEM,VBLANKS   NO- BLANK MEMBER NAME ON REPORT1
         BAL   R10,VPUT           PUT OUT REPORT1 REC
         B     VOLCNTLP
         SPACE 2
CATTAPE  MVI   VRECDSOR,C'T'     INDICATE TAPE IN DSORG FIELD
CATTAPE2 MVC   VRECDSN,DSCBDSN  GET FROM DSCB AREA WHICH WAS FILLED
*              AFTER IKJEHCIR AND NOT MODIFIED FOR TAPE DS
         MVC   VRECVOL,MASKVOL   GET VOLSER
         MVC   VRECMEM,VBLANKS   BLANK MEMBER NAME
         MVI   VRECCAT,C'C'      SET CATALOG FLAG TO C
         MVI   ATTCHFLG,C'N'    DO NOT ATTACH THIS DSN AS A SUB-TASK
         BAL   R10,VPUTREC       WRITE REPORT1
NEXTVOL  LA    R3,12(R3)         POINT TO NEXT VOLUME
         B     VOLCNTLP
         SPACE 2
VKEYERR  AP    VKEYERCT,ONE      ADD 1 TO RECORD COUNT
         B     NEXTVKEY              GET NEXT VSYSIN KEY
         SPACE 1
VOLINFO  EQU   *
         CLM   R0,1,=X'38'       SECURITY VIOLATION?
         BE    VKEYERR                YES (NO ACCESS TO CATALOG)
VOLINFO2 MVI   CIRLOCRC,X'00'         RESET LOCATE RETURN CODE
         MVI   CIROPT,X'04'           NO -CHANGE CATALOG SEARCH OPTION
*        IF FULLY QUALIFIED DSN WAS SPECIFIED TO GET VOLUME INFORM
         MVC   SRCHARG,HIGHQUAL MOVE IN AGAIN TO REMOVE TRAILING '.'
*                               THAT WAS INSERTED BY FIRST IKJEHCIR
         LA    R1,CIRPARM
         LINK  EP=IKJEHCIR
         MVI   CIROPT,X'06'      RESET CATALOG SEARCH OPTION
         LTR   R15,R15       DID WE GET VOL INFO?
         BNZ   NEXTVKEY   NO-DS REALLY NOT FOUND
         MVC   WCDSCBDS,HIGHQUAL
         MVC   DSCBDSN,HIGHQUAL
         L     R3,CIRWA     GET CIR WORKAREA ADDR (NEED IF FIRST TIME)
         LA    R3,4(R3)     POINT PAST HEADER
         B     VOLRTN
         TITLE 'V OPTION -PUT OUT REPORT1 RECORD (VTOC DATA)'
VPUT     NOPR  R10        SET TO BR IF NO REPORT1 IN JCL
*
         L     R9,0(0,R6)  GET COUNT FIELD FROM TABLE ELT
         CVD   R9,VPACKCNT  PACK IT
         CP    VPACKCNT,VCOUNT    IS IT LESS THAN J=COUNT
         BNLR  R10    NO- DO NOT OUTPUT RECORD-CNT SATISFIED ON TBL ELT
         LA    R9,1(R9)  YES- ADD TO TABLE ELEMENT COUNT & PUT OUT REC
         ST    R9,0(0,R6)   REPLACE NEW COUNT IN TBL ELT
         SPACE 1
         MVC   VRECDSN,DSCBDSN    MOVE DSN TO OUTPUT REC
         MVC   VRECVOL,TGVOLSER   MOVE VOLSER TO OUTPUT REC
         CLI   VRECMEM,BLANK1     IS THIS A MEMBER RECORD
         BNE   MEMOUT    YES- SKIP VTOC FIELDS,PUT OUT LIB STATS
         SPACE 1
         AP    PDSCBSEL,ONE       ADD 1 TO DSCBS (W/O MEMS) SELECTED
BYPCAT   NOP   SETCATLG       SET TO BRANCH ON CATALOG SEARCH OPTION
         MVI   VRECCAT,BLANK1 INIT THE CATALOGUE FLAG TO SPACES
         LOCATE SRCHCAT    DETERMINE IF THIS DATASET IS CATALOGED
         LTR   R15,R15     R15=0 MEANS FOUND ON CATALOG
         BNZ   CHKDSORG    NOT FOUND ON CAT
         MVI   VRECCAT,C'E'   INIT THE CATALOG FLAG TO 'E'-ELSEWHERE
         LA    R15,VOLID   GET ADDRESS OF THE FIRST VOLSER
         LH    R9,VOLCNT   GET NUMBER OF VOLUMES DS WAS FOUND ON
         C     R9,=F'20'   ON MORE THAN 20 VOLUMES
         BH    SRCH20      SEARCH ONLY THE FIRST 20 ENTRIES
CATLOOP  CLC   VRECVOL,0(R15) IS DS CATALOGED ON SAME VOLSER AS FND ON
         BE    SETCATLG    YES- SET CATALOGED FLAG
         LA    R15,12(R15) POINT TO NEXT VOLSER (IF IT EXISTS)
         BCT   R9,CATLOOP  LOOP THROUGH ALL THE VOLSERS
         B     CHKDSORG       NOT FOUND
SETCATLG MVI   VRECCAT,C'C'   SET CAT FLAG
         SPACE 2
CHKDSORG MVC   VRECDSOR,VBLANKS    BLANK OUT DSORG FIELD
         MVI   VRECDSOR,C'S'       SEQUENTIAL INDIC
         TM    DSCBORG,X'40'
         BO    TESTUORG           GO TO CHECK IF UNMOVABLE
         MVI   VRECDSOR,C'P'       PARTITION  INDIC
         TM    DSCBORG,X'02'
         BO    TESTUORG           GO TO CHECK IF UNMOVABLE
         MVI   VRECDSOR,C'V'       VSAM INDIC
         TM    DSCBORG+1,X'08'
         BO    TESTUORG           GO TO CHECK IF UNMOVABLE
         MVI   VRECDSOR,C'D'       DIRECT ACC INDIC
         TM    DSCBORG,X'20'
         BO    TESTUORG           GO TO CHECK IF UNMOVABLE
         MVI   VRECDSOR,C'I'       ISAM INDIC
         TM    DSCBORG,X'80'
         BO    TESTUORG           GO TO CHECK IF UNMOVABLE
         MVI   VRECDSOR,C'C'       COMMUNICAT INDIC
         TM    DSCBORG,X'10'
         BO    TESTUORG           GO TO CHECK IF UNMOVABLE
         MVI   VRECDSOR,C'G'       GRAPHICS INDIC
         TM    DSCBORG+1,X'80'
         BO    TESTUORG           GO TO CHECK IF UNMOVABLE
         MVI   DSCBORG,C'O'       INDICATE OTHER
TESTUORG TM    DSCBORG,X'01'     IS IT UNMOVABLE
         BNO   TESTRECF          NO
         MVI   VRECDSOR+1,C'U'    YES
TESTRECF MVC   VRECRECF,VBLANKS   BLANK OUT RECFM
         MVI   VRECRECF,C'U'      UNDEFINED RECFM
         TM    DSCBRECF,X'C0'
         BO    TESTSREC           TEST IF STANDARD OR SPANNED
         MVI   VRECRECF,C'F'      FIXED RECFM
         TM    DSCBRECF,RECFMF
         BO    TESTSREC           TEST IF STANDARD OR SPANNED
         MVI   VRECRECF,C'V'      VARIABLE RECFM
         TM    DSCBRECF,X'40'
         BO    TESTSREC           TEST IF STANDARD OR SPANNED
         MVI   VRECRECF,C'O'      OTHER RECFM
TESTSREC TM    DSCBRECF,X'08'
         BNO   TESTLREC           TEST IF STANDARD OR SPANNED
         MVI   VRECRECF+1,C'S'    STANDARD OR SPANNED
TESTLREC CLI   DSCBLREC,X'80'  IS LRECL GREATER THAN 32K
         BNE   SETLRECL     NO
         MVC   VRECLREC,=C'99999'  YES - SET TO 99999
SETLRECL LH    R9,DSCBLREC     GET LRECL
         CVD   R9,DSCBWORK     CONVERT TO DECIMAL
         UNPK  VRECLREC,DSCBWORK+5(3)   UNPACK INTO LRECL FIELD
         OI    VRECLREC+4,X'F0'
         LH    R9,DSCBBLKS     GET BLKSIZE
         CVD   R9,DSCBWORK     CONVERT TO DECIMAL
         UNPK  VRECBLKS,DSCBWORK+5(3)   UNPACK INTO BLKSI FIELD
         OI    VRECBLKS+4,X'F0'
         LA    R9,0     CLEAR R9
         IC    R9,DSCBNEXT     GET NUMBER OF EXTENTS
         CVD   R9,DSCBWORK     CONVERT TO DECIMAL
         UNPK  VRECNEXT,DSCBWORK+6(2)   UNPACK INTO NEXTENTS FLD
         OI    VRECNEXT+2,X'F0'
         IC    R9,DSCBCRTD     GET CREATION DATE YEAR
         CVD   R9,DSCBWORK     CONVERT TO DECIMAL
         UNPK  DSCBWORK(3),DSCBWORK+6(2) UNPK INTO WORK AREA
         MVC   VRECCRTD(2),DSCBWORK+1    MOVE INTO FIRST 2 BYTES
         OI    VRECCRTD+1,X'F0'
         ICM   R9,3,DSCBCRTD+1   GET DD OF CRTD
         CVD   R9,DSCBWORK     CONVERT TO DECIMAL
         UNPK  VRECCRTD+2(3),DSCBWORK+6(2)   UNPACK INTO DDD FLD
         OI    VRECCRTD+4,X'F0'
         LA    R9,0       CLEAR R9
         IC    R9,DSCBDLRF     GET DATE LAST REF YEAR
         CVD   R9,DSCBWORK     CONVERT TO DECIMAL
         UNPK  DSCBWORK(3),DSCBWORK+6(2) UNPK INTO WORK AREA
         MVC   VRECDLRF(2),DSCBWORK+1    MOVE INTO FIRST 2 BYTES
         OI    VRECDLRF+1,X'F0'
         ICM   R9,3,DSCBDLRF+1   GET DD OF CRTD
         CVD   R9,DSCBWORK     CONVERT TO DECIMAL
         UNPK  VRECDLRF+2(3),DSCBWORK+6(2)   UNPACK INTO DDD FLD
         OI    VRECDLRF+4,X'F0'
         LA    R9,0       CLEAR R9
         IC    R9,DMSDLM       GET DATE LAST MODIF YEAR- DMS/OS ONLY
         CVD   R9,DSCBWORK     CONVERT TO DECIMAL
         UNPK  DSCBWORK(3),DSCBWORK+6(2) UNPK INTO WORK AREA
         MVC   VRECDLM(2),DSCBWORK+1    MOVE INTO FIRST 2 BYTES
         OI    VRECDLM+1,X'F0'
         ICM   R9,3,DMSDLM+1   GET DD OF LAST MOD DATE
         CVD   R9,DSCBWORK     CONVERT TO DECIMAL
         UNPK  VRECDLM+2(3),DSCBWORK+6(2)   UNPACK INTO DDD FLD
         OI    VRECDLM+4,X'F0'
         MVC   VRECJLU,DMSJLU   GET JOB LAST USED;DMS/OS ONLY
         TM    DSCBCHG,X'02'    OPEN FOR OTHER THAN INPUT AFTER BKUP
         BNO   CHKALLOC         NO
         MVI   VRECCHG,C'1'     YES
CHKALLOC MVI   VRECALOC,C'C'   CYLINDER ALLOC
         TM    DSCBALOC,X'C0'  IS IT CYLINDER ALLOC
         BO    CHKPSWD         YES
         MVI   VRECALOC,C'T'   NO - TRK ALLOC
         TM    DSCBALOC,X'80'  IS IT TRK ALLOC
         BO    CHKPSWD         YES
         MVI   VRECALOC,C'B'   NO - BLK ALLOC
         TM    DSCBALOC,X'40'  IS IT CYLINDER ALLOC
         BO    CHKPSWD         YES
         MVI   VRECALOC,C'A'   NO - ABSTR ALLOC (X'00')
CHKPSWD  TM    DSCBCHG,X'10'   IS THERE A READ OR WRITE PASSWORD?
         BNO   CHKRACF         NO
         MVI   VRECPSWD,C'1'   YES:1=WRITE ONLY
         TM    DSCBCHG,X'04'   IS IT WRITE ONLY PASSWORD
         BO    CHKRACF         YES
         MVI   VRECPSWD,C'2'   NO- 2=READ AND WRITE PASSWORD
CHKRACF  TM    DSCBCHG,X'40'  IS DS RACF DEFINED I.E. SECURITY INDIC ON
         BNO   VPUTREC         NO
         MVI   VRECRACF,C'1'   YES:1=RACF SECURITY INDICATOR ON
         SPACE 1
VPUTREC  B     VPUTREC2         SET TO NOP IF V,K= CODED
         LA    R1,VRECOUT       PASS REPORT1 ADDR IN R1
         L     R15,=A(VENTRY)   ENTRY PT ADDR IN MAIN CSECT FOR COMPKEY
         STM   R2,R14,VOPTREGS  SAVE THIS CSECT REG ENVIRON
         LM    R2,R14,SAVEAREQ  SET UP REGS FOR MAIN CSECT ENVIRONM
         BR    R15 GO DO COMPARISON IN MAIN CSECT AND RETURN TO VPUTRET
         SPACE 1
VPUTRET  LR    R12,R1           RESTORE BASE REG FROM R1=A(SAVEAREQ)
         LM    R2,R14,VOPTREGS  RESORE CSECT REG ENVIRONMENT
         SPACE 1
VPUTREC2 EQU   *    BEFORE WITING OUT THE REPORT1 RECORD, DETERMINE IF
*        WE MUST REINVOKE HFSELECT AS AN ATTACHED SUBTASK. IF SO USE
*        THE REPORT1 RECORD TO CONSTRUCT AND DYNAMICALLY ALLOCATE AN
*        INPUT FILE FOR THE SUBTASK. THE DSORG IS USED TO DETERMINE THE
*        DDNAME OF THE PRIMARY INPUT FILE.
*            DO NOT ATTACH A SUBTASK IF THE SECURITY VIOLATION FLAG
*        IS ON.
*
         L     R9,=A(VPARM)      WAS VSYSIN DD CODED
         CLI   2(R9),X'00'       WAS ANY DATA ENTERED INTO PARM?
         BE    SKPATTCH         NO - DO NOT ATTACH ANY SUBTASKS
         CLI   VRECVIOL,C'*'     WAS THERE A SECURITY VIOLATION
         BE    NOATTCH          YES
         CLI   ATTCHFLG,C'N'     IS THIS DSN A TAPE OR ORPHAN ENTRY
         BE    NOATTCH          YES
         CLI   VRECMEM,BLANK1    IS THERE A MEMBER NAME
         BNE   BYPWAIT           YES - CONTINUE ON(SECURITY CHECK DONE)
*                 NO - THERE WAS NO SECURITY CHECK DONE ON THE DSN
         TM    DSCBORG+1,X'08'   IS DSORG=VS
         BO    NOATTCH          YES - DONT ATTACH SUB-TASK FOR VSAM
         RACHECK ENTITY=VRECDSN,CLASS=DATASETX,VOLSER=VRECVOL,         X
               LOG=NOSTAT     DO NO LOG TO AUDIT FILE
         CHI   R15,4     RESOURCE NOT PROTECTED?                  @MK1
         BE    BYPWAIT   YES - OK                                 @MK1
         LTR   R15,R15   DETERMINE IF USER HAS SECURITY ACCESS TO DS
         BNZ   SECVIOL2  NO- DO NOT ATTACH A TASK FOR THIS DSN
BYPWAIT  EQU   *
         CLI   REALOCRC,X'00'   DID PREV REALLOC MACRO FAIL?
         BNE   VUNALLOC    YES - SKIP DETACH AND UNALLOC PRIOR INPUT
*                              NO-     FIRST TIME THRU MEANS
         CLC   TCBADDR,=X'00000000'      TCB=0 I.E. NO SUBTASK WAITING
         BE    SKIPWAIT          NO
         WAIT  ECB=ATTCHECB      WAIT ON PRIOR ATTACHED SUBTASK TO END
         DETACH TCBADDR          DETACH THE JUST ENDED SUBTASK
         XC    TCBADDR,TCBADDR   ZERO TCBADDR TO INDICATE DETACH DONE
         SR    R15,R15
         ICM   R15,7,ATTCHECB+1  GET RETURN CODE OR ABEND FROM SUB-TASK
         BZ    TASKOK1           RC=0
         SRL   R15,12  PUT THE RC IN HIGH ORDER BITS (FOR SYSTEM ABEND)
         CH    R15,VOPTRC      COMPARE RC TO THE ONE IN THE ECB
         BNH   BYPRC             THE ECB IS LOWER - DO NOTHING
         STH   R15,VOPTRC      REPLACE THE CURRENT RC WITH THE ECB
BYPRC    AP    ATCHFAIL,ONE      ADD 1 TO SUB-TASK FAILED COUNT
VUNALLOC MVC   DYNDDNAM,SAVDYNDD GET DD OF INPUT FILE FROM FAILED TASK
         LA    R1,REQBLKUP       UNALLOCATE THAT FILE
         DYNALLOC
         MVC   DYNDDNAM,VPGMSYS2 GET DD OF OUT FILE FROM FAILED TASK
         LA    R1,REQBLKUP       THIS IS ONLY NECESSARY FOR //DISK DD
         DYNALLOC
CLEARECB XC    ATTCHECB,ATTCHECB REUSE THE ECB
*
SKIPWAIT EQU   *
*        DYNAMICALLY ALLOC THE PRIMARY INPUT FILE
         MVI   TUPEOL,X'00'      EXTND DYNALOOC PARAM LIST FOR MEMBER
         MVC   DYNMEMB,VRECMEM   FILL IN MEMBER NAME
         CLI   VRECMEM,BLANK1    IS THERE A MEMBER NAME
         BNE   SEQDD             YES - MAKE DDNAME SYSUT1
         MVI   TUPEOL,X'80'      NO -CUT MEMBER FROM DYN PARM LIST
         MVC   DYNDSN,VRECDSN    MOVE IN DSN
         MVC   DYNVOLSR,VRECVOL  MOVE IN VOLSER
         MVC   DYNDDNAM,=C'LIBFILE '
         MVC   VDDPREF,=C'LIB'   FOR //DISK
         TM    DSCBORG,X'02'     IS DSORG=PO
         BO    ALLOCDD           YES
         MVC   DYNDDNAM,=C'ISAMFILE'
         TM    DSCBORG,X'80'     IS DSORG=IS
         BO    ALLOCDD           YES -
SEQDD    MVC   DYNDDNAM,=C'SYSUT1  '
         MVC   VDDPREF,=C'SYS'   FOR //DISK
ALLOCDD  CLI   2(R9),C'D'      IS THE SUBTASK GOING TO INVOKE THE D OPT
         BNE   ALLOCDD1         NO
         XC    TUFREEP,TUFREEP  YES - ELIMIN THE CLOSE=FREE FROM INPUT
         LA    R1,REQBLKUP      SET UP UNALLOCATION OF INPUT FILE
         DYNALLOC
ALLOCDD1 LA    R1,REQBLKP
         DYNALLOC
         LTR   R15,R15
         BZ    ALLOCOK
         AP    NOATCHCT,ONE
         B     DAIRFAIL
*
ALLOCOK  MVI   TUPEOL,X'80'            RESET END OF LIST POINTER
         MVC   SAVDYNDD,DYNDDNAM SAVE DDNAME OF FILE FOR ATTACHED TASK
*                                NEEDED IN CASE ATTACHED TASK FAILS
*
         MVC   VPGMSYS1,DYNDDNAM  FOR ALTPGM USE HFSELECT INPUT DDNAME
*     CHECK IF DISK DD IS CODED
VDISKDD  NOP    SKPVDSK1     SET TO BR AFTER 1ST TIME THRU;//DISK SETUP
         MVI    VDISKDD+1,SETBR
         RDJFCB (DISK)        GET VOLSER FROM //DISK DD
         LTR    R15,R15
         BNZ    SKPVDSK2      THE DISK DD WAS NOT FOUND
         L      R1,=A(JFCBVOLS)         GET VOLSER
         MVC    VDISKVOL,0(R1)          AND SAVE IT
         XC     WKAREA,WKAREA    GET THE UCB ADDR OF THE THE VOL
         LA     R1,PARMUCB
         USING  UCBOB,R2  USE R2 AS UCB BASE (R9 IS OCCUPIED WITH PARM)
VUCBRTN  L      R15,SCANUCB
         BALR   R14,R15
         LTR    R15,R15
         BNZ    SKPVDSK2             UCB NOT FOUND
         L      R2,ADDRUCB
         TM     UCBSTAT,UCBONLI
         BZ     VUCBRTN
         CLC    UCBVOLI,VDISKVOL
         BNE    VUCBRTN
         ST     R2,VUCBA            SAVE UCB ADDR
         MVC    CVOLDEVT,UCBTYP     SAVE UCB DEV TYPE FOR CATALOG MACRO
         MVC    CVOLSER,VDISKVOL    SAVE VOLSER FOR CATALOG MACRO
         DROP   R2                 DROP R2 FROM UCB
         MVI    SKPVDSK1+1,SETNOP   NOP TO ALLOW NEXT PARAGR EXECUT
         MVC    XALTDD2,=C'SYSV0000'  USE SYSV0000 INSTEAD OF SYSUT2
         MVC    XALTDD,=C'LIBV0000'   USE LIBV0000 INSTEAD OG LIBOUT
SKPVDSK1 B      SKPVDSK2              NOP IF //DISK FOUND
         CLI    VRECMEM,C' '         IS MEMBER NAME BLANK
         BNE    VMEMERR  NO- DO NOT ATTACH SUBTASK- MEMBERS NOT ALLOWED
         MVC    VSPCDSN,VRECDSN      SETUP TO GET # OF TRKS OF INPUT DS
         MVC    VSPCVOL,VRECVOL
         CALL   FILSPACE,(VSPCLIST)  CALL FILESPC RTN TO RETURN # TRKS
         PACK   DSCBWORK,VSPCTRK     PACK THE # OF TRKS
         CVB    R1,DSCBWORK           AND CONVERT TO BINARY IN FULLWRD
         ST     R1,VTRKS             SAVE IT
         MVC    PDSCB(108),TARGET  GET 1ST 108 BYTES OF DSCB FOR REALLC
         MVI    PDSCB+44,X'F1'       SET DSCB FORMAT TO 1
         L      R2,VUCBA             GET UCB ADDR
         REALLOC DSSIZE=VTRKS,PDSCB=PDSCB,UCB=(R2),PDSDIR=VDIRBLKS,    X
               MF=(E,REALLOCL)   CREATE DSCB1 FOR OUTPUT FILE
         STC    R15,REALOCRC  SAVE THE RETURN CODE
         LTR    R15,R15
         BNZ    REALOCER       COULD NOT ALLOC- DO NOT ATTACH SUB-TASK
         MVC    DYNVOLSR,VDISKVOL    SET UP TO DYNAMICLLY ALLOC THE DS
         MVC    DYNDDNAM(3),VDDPREF  GET EITHER 'SYS' OR 'LIB'
         MVC    DYNDDNAM+3(5),=C'V0000'   DDNAME=SYSV0000/LIBV00000
         MVC    VPGMSYS2,DYNDDNAM      SET DDNAME FOR ALT PGM
         MVI    VPGMDD,C' '   SET DDPREF TO BLANK- SO VPGMSYS2 ISNT CHG
         LA     R1,REQBLKP
         DYNALLOC
         LH     R15,RBERR
         LTR    R15,R15
         BNZ    DAIRFAIL
         B      VDISKBR             SKIP CODING FOR SYSVNNNN/LIBVNNNN
SKPVDSK2 EQU    *
*
*     CHECK TO SEE IF SYSVNNNN OR LIBVNNNN DDS ARE CODED
         AP    XRECCNT,=P'1'      ADD 1 TO SUBTASK NUMB TO GENERATE THE
*                            NNNN PORTION OF THE DDNAME
         UNPK  XALTDD,XRECCNT     UNPACK THE NUMBER
         OI    XALTDD+7,X'F0'     FIX SIGN 1/2 BYTE
         MVI   XALTDD+3,C'V'      FORM DDNAME XXXVNNNN
         SR    R1,R1          TIOT SEARCH RTN TO LOOK FOR ABOVE DDNAME
         USING PSA,R1
         L     R1,PSATOLD
         USING TCB,R1
         L     R1,TCBJSCB
         USING IEZJSCB,R1
         L     R1,JSCDSABQ
         USING QDB,R1
         L     R1,QDBFELMP
         USING DSAB,R1
         USING TIOENTRY,R15   TIOT ADDRESSABILITY
VTIOTLOP L     R15,DSABTIOT   GET THE TIOT ENTRY POINTER
         CLC   TIOEDDNM+3(5),XALTDD+3
         BE    VDDFND       YES
         ICM   R1,15,DSABFCHN  CHAIN TO THE NEXT DSAB
         BNZ   VTIOTLOP         THERE ARE ADDITIONAL DSABS
         B     SKPEXITS
VDDFND   MVC   XALTDD,TIOEDDNM
         MVC   XALTDD2,TIOEDDNM
         DROP  R15
         MVC   XALTDD(3),=C'LIB'
         MVC   XALTDD2(3),=C'SYS'
*  NOW DEALLOC THE EXITS DD, IF CODED IN THE JCL OR DYNAMICALLY ALLOC
VDISKBR  NOP   ATTACH         SET TO BR IF //DISK DD REQUESTED
         CLC   PGMNAME,=C'HFSELECT'   IS SUB-TASK PGM NAME= HFSELECT?
         BNE   SKPEXITS               NO
         MVI   TXTUNTUP,X'00'         SET UNALLOC TO UNALLOC & REMOVE
         MVC   DYNDDNAM,=CL8'EXITS'
         LA    R1,REQBLKUP
         DYNALLOC
         MVI   TXTUNTUP,X'80'    RESET
         LA    R1,REQBLKXP       ALLOCATE NEW EXITS DD
         DYNALLOC
         LH    R15,RBERRX
         LTR   R15,R15
         BNZ   DAIRFAIL
         OPEN  (VEXITS,OUTPUT)
         PUT   VEXITS,EXITR1
         PUT   VEXITS,EXITR2
         CLOSE (VEXITS)
*@MK1    FREEPOOL VEXITS
SKPEXITS EQU   *
         CLC   PGMNAME,=C'HFSELECT'   IS SUB-TASK PGM NAME= HFSELECT?
         BE    CKDISKDD               YES- DONT ALLOCATE NEW SYSPRIN2
         LA    R1,REQBLKSP   ALLOC NEW SYSPRIN2 FOR IBM-TYPE UTILITIES
         DYNALLOC
         CLI   VPGMDD,C' '      DID AN ALT PGM REQUEST AN ALT DD
         BE    CKDISKDD          NO
         MVC   VPGMSYS2,XALTDD     YES
         MVC   VPGMSYS2(3),VPGMDD
CKDISKDD CLI   SKPVDSK1+1,SETNOP  WAS //DISK DD REQUESTED
         BNE   ATTACH             NO
         MVI   VDISKBR+1,SETBR    YES - ALLOC EXITS FILE ONLY ONCE
*
ATTACH   ATTACH DE=BLDLDATA+0,PARAM=((R9),VPGMLEN),VL=1,ECB=ATTCHECB
*  VPGMLEN PARAM ADDED TO ATTACH FOR ALTERNATE SUB-TASK PGM
         ST    R1,TCBADDR   SAVE THE TASK CONTROL BLOCK ADDR
         B     SKPATTCH     BYPASS ADDING TO SKIP COUNTER
         SPACE 3
NOATTCH  AP    NOATCHCT,ONE     ADD 1 TO NUMB OF SUB-TASKS NOT ATTACHED
         MVI   VMSG8+7,C'W'     CHANGE MSG TO WARNING FROM INFORMATNAL
SKPATTCH EQU   *
         MVI   ATTCHFLG,C'Y'    RESET ATTACH FLAG
VXITBRO1 B     VNOXITO1         SET TO NOP IF O1 EXIT CODED
         L     R15,=A(EXTEPAO1) GET EPA OF EXIT
         L     R15,0(R15)
         LA    R1,EXITPARM      LOAD PARAMETER ADDR IN R1
         BALR  R14,R15
         C     R15,=F'4'          CHECK RETURN CODE
         BL    VNOXITO1 RC=0   CONTINUE NORMAL PROCESSING
         BER   R10      RC=4  DELETE THIS RECORD-DONT WRITE REPORT1
         MVI   VXITBRO1+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT
VNOXITO1 EQU   *
         PUT   VREPORT1,VRECOUT WRITE REPORT1
         AP    PRECSEL,ONE      ADD 1 TO RECORDS OUTPUT
         SPACE 1
         CP    PRECSEL,VTOTCNT  HAS COUNT BEEN SATISFIED ON ALL KEYS
         BE    VCNTSAT          YES- GO TO EOJ AND SET FLAG
         BR    R10              NO
         SPACE 2
VPUTREJ  LR    R12,R1           RESTORE BASE REG FROM R1=A(SAVEAREQ)
         LM    R2,R14,VOPTREGS  RESORE CSECT REG ENVIRONMENT
VPUTREJ2 BR    R10    SET TO NOP IF REJECTS ARE TO BE WRITTEN
VXITBRO2 B     VNOXITO2         SET TO NOP IF O2 EXIT CODED
         L     R15,=A(EXTEPAO2) GET EPA OF EXIT
         L     R15,0(R15)
         LA    R1,EXITPARM      LOAD PARAMETER ADDR IN R1
         BALR  R14,R15
         C     R15,=F'4'          CHECK RETURN CODE
         BL    VNOXITO2 RC=0   CONTINUE NORMAL PROCESSING
         BER   R10      RC=4  DELETE THIS RECORD-DONT WRITE REPORT2
         MVI   VXITBRO2+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT
VNOXITO2 EQU   *
         PUT   VREPORT2,VRECOUT  WRITE REPORT2
         L     R1,=A(OUTCT2)     GET REPORT2 COUNT
         AP    0(8,R1),ONE       ADD 1 TO COUNT
         BR    R10
         SPACE 2
SRCH20   LA    R9,20     KNOCK DOWN VOL COUNT TO 20
         B     CATLOOP   RETURN TO SEARCH FIRST VOLUME CONTROL BLOCK
         SPACE 2
SECVIOL2 MVI   VRECVIOL,C'+'     SEC VIOLATION ON ATTACHING TASK
         B     NOATTCH  RETURN TO ONLY PUTTING OUT REPORT1 REC
REALOCER STC   R15,VRECVIOL  MOVE IN ERROR CODE FROM REALLOC MACRO
         B     NOATTCH  RETURN TO ONLY PUTTING OUT REPORT1 REC
VMEMERR  MVI   REALOCRC,X'01'  SET ERROR CODE TO X'01' MEMB NOT ALLOW
         B     NOATTCH  RETURN TO ONLY PUTTING OUT REPORT1 REC
         TITLE 'V OPTION -PUT OUT REPORT1 RECORD (DIRECTORY LM DATA)'
MEMOUT   MVC   VRECOUT+58(42),VBLANKS  BLANK OUT MEMB PORTION OF REC
         AP    PMEMSEL,ONE     ADD 1 TO MEMBERS OUTPUT
         TM    PDSFLAG,PDSALIAS        IS THIS AN ALIAS
         BNO   NOTALIAS        NO
         MVI   VRECALIS,C'1'   YES
NOTALIAS TM    PDSFLAG,PDSPTRS  ARE THERE TTR POINTERS I.E.LOAD MODUL
         BZ    TMPDSSPF   NO- ITS NOT A LOAD MODULE, CHK FOR SPF STATS
         MVI   VRECTYPE,C'L'  YES- INDICATE LOAD MODULE
         MVC   UDATALEN,PDSFLAG    SET UP TO GET USER DATA LENGTH
         NI    UDATALEN,X'1F'   ZERO OUT ALL FLAGS EXCEPT LENGTH
         LA    R9,0    CLEAR R9
         IC    R9,UDATALEN
         SLL   R9,1            MULTIPLY BY 2 TO GET NUMB OF BYTES
         LA    R9,PDSFLAG-PDSMEMNM+1(R9)  R9=LEN OF DIRECTORY MEMB
         STC   R9,UDATALEN     SAVE LENGTH
         SPACE 2
         ICM   R9,7,SIZE   GET LOAD MODULE SIZE
         CVD   R9,DSCBWORK    AND CONVERT TO DECIMAL
         UNPK  SIZEWRK,DSCBWORK+3(5)  UNPACK TO 9 BYTES
         MVC   VRECLSZE,SIZEWRK+1  GET RID OF LEADING 0 (MAX 8 DIGITS)
         OI    VRECLSZE+7,X'F0'    UNSIGN
         MVC   DSCBWORK(3),PDSTTR   GET LOAD MODULE TTR
         MVI   DSCBWORK+3,X'0F'    PAD TTR WITH 0
         UNPK  DSCBWORK(7),DSCBWORK(4)  UNPACK
         MVC   VRECLTTR,DSCBWORK   TRUNCATE LAST PAD BYTE
         L     R15,=A(BINTRTBL)
         TR    VRECLTTR,0(R15)     TRANSLATE HEX TO PRINTABLES
         SPACE 1
         TM    MODATTR1,REENT    IS MODULE REENTRANT
         BNO   TSTATTR2       NO
         MVI   VRECLRN,C'1' YES
TSTATTR2 TM    MODATTR1,REUSE    IS MODULE REUSABLE
         BNO   TSTATTR3       NO
         MVI   VRECLRU,C'1' YES
TSTATTR3 TM    MODATTR1,OVERLAY  IS MODULE IN OVERLAY STRUCTURE
         BNO   TSTATTR4       NO
         MVI   VRECLOV,C'1' YES
TSTATTR4 TM    MODATTR1,TESTRAN  IS MODULE TESTRAN
         BNO   TSTATTR5       NO
         MVI   VRECLTS,C'1' YES
TSTATTR5 TM    MODATTR1,ONLYLOAD IS MODULE ONLY LOADABLE
         BNO   TSTATTR6       NO
         MVI   VRECLOL,C'1' YES
TSTATTR6 TM    MODATTR1,SCATTER  IS MODULE SCATTER
         BNO   TSTATTR7       NO
         MVI   VRECLSC,C'1' YES
TSTATTR7 TM    MODATTR1,EXECUT   IS MODULE EXECUTABLE
         BO    TSTATTR8       YES
         MVI   VRECLNX,C'1' NO
TSTATTR8 TM    MODATTR2,FLKED    IS MODULE ONLY EXEC BY F LEVEL LKED
         BNO   TSTATTR9       NO
         MVI   VRECLFO,C'1' YES
TSTATTR9 TM    MODATTR2,REFRESH  IS MODULE REFRESHABLE
         BNO   TSTALIAS          IS THERE AN ALIAS NAME
         MVI   VRECLFR,C'1' YES
         SPACE 1
TSTALIAS LR    R4,R8    SAVE R8 - BEGINNING ADDR OF DIRECT ENTRY
         MVC   SAVELMFL,LMFLAG  - SAVE SSI & APF FLAGS
*        SEE EXPANSION OF IHAPDS MACRO FOR STRUCTURE OF LOAD MODULE
*        USER DATA AND DEFINITION OF LENGTH LABELS USED IN THIS
*        CODE TO OBTAIN THE 'ALIAS OF' NAME AND APF CODE
*        USER DATA CONTAINS 1- BASIC SECTION + 4 OPTIONAL SECTIONS
*                           2- SCATTER LOAD SECTION
*                           3- ALIAS SECTION
*                           4- SSI SECTION
*                           5- APF SECTION
         LA    R9,PDSBCLN -GET LENGTH OF BASIC SECTION
         AR    R8,R9    - OFFSET DSECT PTR TO END OF BASIC SECT
         CLI   VRECLSC,C'1'   IS THERE A SCATTER SECTION
         BNE   CHKALIAS       NO
         LA    R9,PDSS01LN(R9)  YES-ADD SCATTER SECT LENGTH TO R9
         LA    R8,PDSS01LN(R8)  YES - POINT BEYON SCATTER SECTION
CHKALIAS CLI   VRECALIS,C'1'    IS THERE AN ALIAS
         BNE   NOALIAS      NO
         MVC   VRECLALS,INVALFLD MOVE IN ???????? FOR INVALID FIELD
         LA    R9,PDSS02LN(R9)   LEN=BASIC(+SCATTER)+ALIAS
         CLM   R9,1,UDATALEN    IS R9 GREATER THAN COMPUTED MEMB LEN
         BH    NOALIAS                YES- INVALID
         MVC   VRECLALS,ALIASOF  NO -MOVE IN ALIAS OF
         LA    R8,PDSS02LN(R8) POINT BEYOND THE ALIAS SECTION
NOALIAS  TM    SAVELMFL,SSIINFO  IS THERE SSI INFO IN NOTELIST
         BNO   NOSSI            NO
         LA    R9,1(R9)  YES- MAKE SURE SSI SECT IS ALIGNED ON A HALF
*        WORD BOUNDARY. ADD 1 TO LEN=BASIC(+SCATTER)(+ALIAS) AND
*        ZERO OUT LOW ORDER BIT. THIS WILL ADD IN SLACK BYTE IF NEEDED
         N     R9,=X'FFFFFFFE'
         LA    R8,0(R9,R4)  R4=ADDR OF BEGIN OF DIRECTORY ENTRY
*                           R8 NOW POINTS TO BEGINNING OF SSI SECTION
         TM    SSIFLAG,SSIINST    GET SSI INFO
         BNO   SSI2
         MVI   VRECLSI1,C'1'
SSI2     TM    SSIFLAG,SSICHGDP
         BNO   SSI3
         MVI   VRECLSI2,C'1'
SSI3     TM    SSIFLAG,SSISYSG
         BZ    SSI4
         MVI   VRECLSI3,C'1'
SSI4     TM    SSIFLAG,SSIIBMM
         BNO   PTTOAPF
         MVI   VRECLSI4,C'1'
PTTOAPF  LA    R8,PDSS03LN(R9,R4) R4=ADDR OF BEGIN OF DIRECTORY ENTRY
*               PDSS03LN=LEN OF SSI SECTION. R8 NOW POINTS TO APF SECT
         LA    R9,PDSS03LN(R9)   LEN=BASIC(+SCATTER)(+ALIAS)+SSI
         SPACE 1
NOSSI    TM    SAVELMFL,APFINFO  IS THERE APF CODE INFO IN USER DATA
         BNO   VPUTREC      NO - ALL DONE -WRITE REPORT1 RECORD
         MVC   VRECLAPF,INVALFLD   MOVE IN ?? IN CASE APF CODE INVAL
         LA    R9,PDSS04LN(R9)   LEN=BASIC(+SCATTER)(+ALIAS)(+SSI)+APF
         CLM   R9,1,UDATALEN  IS R9 GREATER THAN COMPUTED MEMBER LEN
         BH    VPUTREC         YES - APF CODE IS INVALID
         LA    R9,0        NO- ZERO R9 FOR APF CODE
         IC    R9,APFCODE     GET APF CODE
         CVD   R9,DSCBWORK    CONVERT TO DEC
         UNPK  DSCBWORK(3),DSCBWORK+6(2)
         MVC   VRECLAPF,DSCBWORK+1   TRUNCATE HIGH-ORDER BYTE
         OI    VRECLAPF+1,X'F0'   UNSIGN THE APF CODE
         B     VPUTREC
         TITLE 'V OPTION -PUT OUT REPORT1 REC (DIRECTORY SPF DATA)'
TMPDSSPF TM    PDSFLAG,PDSSPFST  ARE THERE SPF STATISTICS
         BNO   VPUTREC        NO-LEAVE REST OF RECORD BLANK
         MVI   VRECTYPE,C'S'  YES- SET RECTYPE TO 'S' - SPF STATS
         LA    R9,0      CLEAR R9
         IC    R9,PDSPFVV YES-GET VERSION NUMBER
         CVD   R9,DSCBWORK
         UNPK  DSCBWORK(3),DSCBWORK+6(2) UNPACK INTO 3 BYTES
         MVC   VRECPVV,DSCBWORK+1
         OI    VRECPVV+1,X'F0'
         IC    R9,PDSPFMM YES-GET MOD NUMBER
         CVD   R9,DSCBWORK
         UNPK  DSCBWORK(3),DSCBWORK+6(2) UNPACK INTO 3 BYTES
         MVC   VRECPMM,DSCBWORK+1
         OI    VRECPMM+1,X'F0'
         UNPK  VRECPCRD,PDSPFCRD    UNPACK THE CREATION DATE
         UNPK  VRECPLMD,PDSPFLMD    UNPACK THE LAST MOD DATE
         MVC   DSCBWORK(1),PDSPFHH  GET HR-IN HALF-BYTE DEC(NO SIGN)
         MVI   DSCBWORK+1,X'0F'     PAD TO MAKE IT A PACKED NUMBER
         UNPK  DSCBWORK+2(3),DSCBWORK(2)  UNPACK
         MVC   VRECPHH,DSCBWORK+2   TRUNCATE LAST BYTE(0)
         MVC   DSCBWORK(1),PDSPFTMM GET MM-IN HALF-BYTE DEC(NO SIGN)
         MVI   DSCBWORK+1,X'0F'     PAD TO MAKE IT A PACKED NUMBER
         UNPK  DSCBWORK+2(3),DSCBWORK(2)  UNPACK
         MVC   VRECPTMM,DSCBWORK+2  TRUNCATE LAST BYTE(0)
         ICM   R9,3,PDSPFCLN   GET CURRENT NUM OF LINES
         CVD   R9,DSCBWORK
         UNPK  VRECPCLN,DSCBWORK+5(3)  UNPACK
         OI    VRECPCLN+4,X'F0'        DEFAULT SIGN
         ICM   R9,3,PDSPFILN   GET INITIAL NUM OF LINES
         CVD   R9,DSCBWORK
         UNPK  VRECPILN,DSCBWORK+5(3)  UNPACK
         OI    VRECPILN+4,X'F0'        DEFAULT SIGN
         ICM   R9,3,PDSPFMLN   GET MODIFID NUM OF LINES
         CVD   R9,DSCBWORK
         UNPK  VRECPMLN,DSCBWORK+5(3)  UNPACK
         OI    VRECPMLN+4,X'F0'        DEFAULT SIGN
         MVC   VRECPID,PDSPFID     GET LAST MODIFIED USERID
         DROP  R8
         B     VPUTREC
         SPACE 2
VCNTSAT  MVI   VRC+3,X'02'   SET COUNT SATISFIED RETURN CODE
         L     R9,=A(LIBRARY)  RESET THE PDS DCB WITH PROPER DSORG
         MVI   DSORG(R9),X'40'       IN CASE OF EARLY END
         B     VEOJ
         SPACE 3
VEOJ     CLI   CATNOP+1,X'00'  WAS CATALOG SEARCH OPTION USED
         BNE   VCLOSE          NO
         L     R2,CIRWALEN     YES- GET LENGTH OF GETMAINED AREA
         FREEMAIN E,LV=(2),A=CIRWA
VCLOSE   CLOSE (VREPORT1,,VREPORT2)
*@MK1    FREEPOOL VREPORT1
*@MK1    FREEPOOL VREPORT2
         DELETE EPLOC=BLDLDATA+74  DELETE READVTC MODULE
         CLC   TCBADDR,=X'00000000'   ANY SUBTASKS STILL ATTACHED
         BE    VRC               NO
         WAIT  ECB=ATTCHECB  YES-WAIT ON LAST ATTACHED SUBTASK TO END
         DETACH TCBADDR          DETACH THE LAST SUBTASK
         SR    R15,R15
         ICM   R15,7,ATTCHECB+1  GET RETURN CODE OR ABEND FROM SUB-TASK
         BZ    TASKOK2           RC=0
         AP    ATCHFAIL,ONE      ADD 1 TO SUB-TASK FAILED COUNT
         SRL   R15,12  PUT THE RC IN HIGH ORDER BITS (FOR SYSTEM ABEND)
         CH    R15,VOPTRC      COMPARE RC TO THE ONE IN THE ECB
         BNH   VRC               THE ECB IS LOWER - DO NOTHING
         STH   R15,VOPTRC      REPLACE THE CURRENT RC WITH THE ECB
VRC      LA    R15,0                   SET RETURN CODE FROM VOPTION
         CP    ATCHFAIL,ONE      WERE THERE ANY FAILED TASKS
         BL    VMSG                  NO
         MVI   VMSG9+7,C'E'   CHANGE MSG TO AN ERROR FROM INFORMATNAL
         L     R1,=A(SETRC)  YES-SET OVERALL RC
         MVC   2(2,R1),VOPTRC
         CLC   VOPTRC,=H'8'      IS RC GREATER THAN 8
         BNH   VMSG              NO
         L     R1,=A(SETRCABE)   YES- SET TO ABEND AT EOJ
         MVI   1(R1),X'70'
VMSG     ED    VMSG1ED(10),PDSCBTOT+3    EDIT STATS
         ED    VMSG2ED(10),PDSCBSEL+3
         ED    VMSG3ED(10),PPDSTOT+3
         ED    VMSG4ED(10),PMEMTOT+3
         ED    VMSG5ED(10),PMEMSEL+3
         ED    VMSG6ED(10),PRECSEL+3
         ED    VMSG7ED(10),VKEYERCT+3
         ED    VMSG8ED(10),NOATCHCT+3
         ED    VMSG9ED(10),ATCHFAIL+3
         L     R1,=A(MSGCNT)    GET MSGCNT FIELD FOR NUMB OF MSGS
         MVC   0(2,R1),=H'9'    9 V OPT MSGS
         LA    R1,VMSG1         LOAD MSG BLOCK ADDR IN R1 FOR PRINT
         LM    R2,R14,SAVEAREQ      RESTORE REGISTERS
         BR    R14                  RETURN
         SPACE 5
TASKOK1  ST    R10,SAVER10          SAVE BAL REGISTER
         BAL   R10,RECATRTN         PERFORM RECATALOG RTN
         L     R10,SAVER10
         B     CLEARECB            RETURN TO MAINLINE LOGIC AFTER DETCH
TASKOK2  BAL   R10,RECATRTN         PERFORMLRECATALOG RTN
         B     VRC                 RETURN TO LOGIC AFTER LAST DETCH
         SPACE
RECATRTN BR    R10        SET TO NOP ONLY IF X0 RECAT INIT PARM CODED
         CATALOG UNCATLG            UNCATL INPUT FILE FOR //DISK DD
         CATALOG CATLG              CATLG OUTPUT FILE FOR //DISK DD
         LTR   R15,R15
         BNZ   VERROR               SOMETHING IS WRONG
         BR    R10                  RETURN
         SPACE 3
DAIRFAIL LA    R1,DAIRPARM          GET DIAR PARM ADDR
         LINK  EP=IKJEFF18          DAIRFAIL ROUTINE
VERROR   MVI   VRC+3,X'01'          SET V OPTION ERROR CODE
         L     R1,=A(SETRCDMP)      CAUSE AN ABEND WITH A DUMP
         MVI   1(R1),X'70'          (SEE EXITS RC=ABEND,DUMP)
         B     VEOJ                 GO TO V OPTION EOJ
         DROP  R12
         SPACE 3
DAIRPARM DC    A(REQBLK)    ADDR OF FAILINF SVC99 REQ BLK
         DC    A(RBERR)     ADDR OF SVC99 DIAR RC
         DC    A(IKJEFF02)  MSG RTN
         DC    A(DAIRFLAG)
         DC    A(0)         ADDR OF CPPL- NEEDED ONLY WHEN NOT WTP
         DC    A(DAIRBUF)   ADDR OF MSG BUFFER
IKJEFF02 DC    A(0)         SYSTEM SUPPLIED
DAIRFLAG DC    X'A0'        WTP REQUESTED, EXTRACT MSG TO BUFFER
         DC    X'32'        CALLER ID=SVC99
         TITLE 'V OPTION -DYNALLOC PARAMETER LIST FOR PDSS'
         DS    0F
REQBLKP  DC    X'80',AL3(REQBLK)
REQBLK   DC    X'14'   LENGTH OF REQ BLK
         DC    X'01'  VERB= DSN ALLOC
         DC    X'0000'  FLAGS1
RBERR    DC    H'0',X'0000'
TXTP     DC    A(TXTUNTP)    TEXT POINTER
         DC    XL8'00'    RESERVED
TXTUNTP  DC    A(TUDDNAM)
         DC    A(TUDSNAM)
         DC    A(TUSTATS)
         DC    A(TUUNIT)
TUFREEP  DC    A(TUFREE)      SET TO ZERO ADDRESS ON D OPTION
TUPEOL   DC    X'80',AL3(TUVOLSER)  END OF LIST PTR (X'80') ZEROD WHEN
         DC    X'80',AL3(TUMEMBER)    MEMBER REQUESTED
TUDDNAM  DC    X'0001'     KEY=0001
         DC    X'0001'     # OF LEN,PARMS FOLLOWING
         DC    X'0008'     LEN OF PARM
DYNDDNAM DC    CL8'VTEMPLIB'    DDNAME
TUDSNAM  DC    X'0002'     DSN
         DC    X'0001'
         DC    H'44'        (DSN MAY BE PADDED WITH BLANKS)
DYNDSN   DS    CL44
TUSTATS  DC    X'0004'      DISP=
         DC    X'0001'
         DC    X'0001'
         DC    X'08'    SHR DISP
TUUNIT   DC    X'0015'  UNIT=SYSALLDA
         DC    X'0001'
*@MK1    DC    X'0005'
*@MK1    DC    C'SYSDA'
         DC    X'0008'                                @MK1
         DC    C'SYSALLDA'                            @MK1
TUVOLSER DC    X'0010'  VOLSER
         DC    X'0001'
         DC    X'0006'
DYNVOLSR DS    CL6
TUMEMBER DC    X'0003'  MEMBER
         DC    X'0001'
*@MK1    DC    H'8'
         DC    X'0008'        (BAD ALIGNMENT)         @MK1
DYNMEMB  DS    CL8
TUFREE   DC    X'001C'  FREE=CLOSE
         DC    X'0000'
         SPACE 3
REQBLKUP DC    X'80',AL3(REQBLKU)
REQBLKU  DC    X'14'   LENGTH OF REQ BLK
         DC    X'02'  VERB= UNALLOC DDNAME (FOR D OPTION ONLY)
         DC    X'0000'  FLAGS1
         DC    H'0',X'0000'   RBERR
TXTUP    DC    A(TXTUNTUP)    TEXT POINTER
         DC    XL8'00'    RESERVED
TXTUNTUP DC    X'80',AL3(TUDDNAM)    USE DDNAME SET BY ALLOC ABOVE
         DC    X'80',AL3(TUREMOV)  REMOVE ATTRIB FOR EXITS CODED IN JCL
TUREMOV  DC    X'0007'
         DC    X'0000'
*
REQBLKXP DC    X'80',AL3(REQBLKX)
REQBLKX  DC    X'14'   LENGTH OF REQ BLK
         DC    X'01'  VERB= DSN ALLOC
         DC    X'0000'  FLAGS1
RBERRX   DC    H'0',X'0000'
TXTPX    DC    A(TXTUNTXP)   TEXT POINTER
         DC    XL8'00'    RESERVED
TXTUNTXP DC    A(TUDDNAMX)
         DC    A(TUBLKLN)
         DC    A(TUSPCPRM)
         DC    X'80',AL3(TUUNIT)
TUDDNAMX DC    X'0001'     KEY=0001
         DC    X'0001'     # OF LEN,PARMS FOLLOWING
         DC    X'0008'     LEN OF PARM
         DC    CL8'EXITS   '    DDNAME
TUBLKLN  DC    X'0009'
         DC    X'0001'
         DC    X'0003'
         DC    FL3'400'    BLKSIZE=400
TUSPCPRM DC    X'000A'     PRIMARY SPACE
         DC    X'0001'
         DC    X'0003'
         DC    FL3'1'      1 TRK
         SPACE 3
REQBLKSP DC    X'80',AL3(REQBLKS)         FOR ALLOCATING SYSPRIN2
REQBLKS  DC    X'14'   LENGTH OF REQ BLK
         DC    X'01'  VERB= DSN ALLOC
         DC    X'1000'  FLAGS1  (SET FOR SYSOUT)
RBERRS   DC    H'0',X'0000'
         DC    A(TXTUNTSP)   TEXT POINTER
         DC    XL8'00'    RESERVED
TXTUNTSP DC    A(TUDDNAMS)
         DC    X'80',AL3(TUSYSOUT)
TUDDNAMS DC    X'0001'     KEY=0001
         DC    X'0001'     # OF LEN,PARMS FOLLOWING
         DC    X'0008'     LEN OF PARM
         DC    CL8'SYSPRIN2'    DDNAME
TUSYSOUT DC    X'0018'
         DC    X'0000'
         TITLE 'V OPTION -PARAMETER LIST AND DATA PASSED BETW READVTOC'
RVPARML  DC    A(MASK)         PARM LIST PASSED TO READVTOC
         DC    A(TARGET)
         DC    A(INITDSN)      INITIAL DSN FOR INDEXED VTOC SEARCH
MASK     DC    XL40'00'
MASKVOL  EQU   MASK+28,6       VOLSER PLACED IN MASK
TARGET   DC    XL156'00'       AREA FOR DATA RETURNED FROM READVTOC
DSCBDSN  EQU   TARGET,44        DSCB DSN
DSCBFMT  EQU   TARGET+44,1      DSCB FORMAT
*DSCBVOL EQU   TARGET+45,6      DSCB VOLSER <== DONT USE!! NOT RELIABLE
DSCBCRTD EQU   TARGET+53,3      DSCB CREATION DATE
DSCBNEXT EQU   TARGET+59,1      DSCB NUMBER OF EXTENTS
DMSJLU   EQU   TARGET+62,8      DMS JOB LAST USED
DMSDLM   EQU   TARGET+70,3      DMS DATE LAST MODIFIED
DSCBDLRF EQU   TARGET+75,3      DSCB DATE LAST REFERENCE
DSCBORG  EQU   TARGET+82        DSCB DSORG
DSCBRECF EQU   TARGET+84,1      DSCB RECFM
DSCBBLKS EQU   TARGET+86,2      DSCB BLKSIZE
DSCBLREC EQU   TARGET+88,2      DSCB LRECL
DSCBCHG  EQU   TARGET+93,1 DSCB OPEN FOR OTHER THAN INPUT AFTER BKUP FL
*                          ALSO PASSWORD AND RACF INDICATORS
DSCBALOC EQU   TARGET+94,1      DSCB SPACE ALLOC TYPE
TGVOLSER EQU   TARGET+140,6     VOLSER ON WHICH DSCB RESIDES
         TITLE 'V OPTION -REPORT1 RECORD'
VRECOUT  DS    0CL100
VRECVOL  DS    CL6      VOLSER
VRECDSN  DS    CL44     DSN
VRECBLNK DS    CL4      BLANKS   (FIRST BYTE MUST BE BLANK IF NO MEMB)
VRECPSWD DS    CL1      PSWD INDIC:1=WRITE PROTECT,2=READ & WRITE PROT
VRECRACF DS    CL1      RACF INDICATOR 1=DATASET RACF DEFINED
VRECVIOL DS    CL1      =* OR + IF SECURITY VIOLATION ON PDS
VRECCAT  DS    CL1      =C IF DATASET IS CATALOGED
VRECDSOR DS    CL2      DSORG
VRECRECF DS    CL2      RECFM
VRECLREC DS    CL5      LRECL
VRECBLKS DS    CL5      BLKSIZE
VRECNEXT DS    CL3      NUMBER OF EXTENTS
VRECCRTD DS    CL5      CREATION DATE
VRECDLRF DS    CL5      DATE LAST REFERENCED
VRECALOC DS    CL1      ALLOCATION TYPE C=CYL,T=TRK,B=BLK,A=ABSTR
VRECCHG  DS    CL1      CHG FLAG,1=IF UPDATED SINCE LAST BACKUP
*        THE NEXT 2 FIELDS HAVE MEANING ONLY IF DMS SVC INSTALLED
VRECDLM  DS    CL5      DATE LAST MODIFIED
VRECJLU  DS    CL8      JOB LAST USED
         SPACE 1
         ORG   VRECBLNK  REDEFINED AREA FOR DIRECTORY MEMB SPF STATS
VRECMEM  DS    CL8      MEMBER NAME
VRECALIS DS    CL1    ALIAS INDICATOR BLANK=NO , 1=YES
VRECPVV  DS    CL2       VERSION
VRECPMM  DS    CL2       MODIFICATION NUMBER
VRECPCRD DS    CL5       CREATION DATE
VRECPLMD DS    CL5       LAST MOD DATE
VRECPHH  DS    CL2       HOUR MODIFIED
VRECPTMM DS    CL2       MIN  MODIFIED
VRECPCLN DS    CL5       CURRENT NUMBR OF LINES
VRECPILN DS    CL5       INITIAL  "
VRECPMLN DS    CL5       MODIFIED
VRECPID  DS    CL7       USERID
VRECTYPE DS    CL1       SET TO S FOR SPF STATS, L FOR LOAD MODULES
         SPACE 2
         ORG   VRECPVV   REDEFINE FOR LOAD MODULES
VRECLSZE DS    CL8     LOAD MODULE SIZE IN DECIMAL
VRECLTTR DS    CL6     TTR IN HEX
VRECLATR DS    0CL9          ATTR  FIELDS
VRECLRN  DS    CL1    REENT
VRECLRU  DS    CL1    REUSE
VRECLOV  DS    CL1    OVERLAY
VRECLTS  DS    CL1    TESTRAN
VRECLOL  DS    CL1    ONLY LOADABLE
VRECLSC  DS    CL1    SCATTER
VRECLNX  DS    CL1    NOT EXECUTABLE
VRECLFO  DS    CL1    F LEVEL LKED
VRECLFR  DS    CL1    REFRESHABLE
VRECLALS DS    CL8    ALIAS OF NAME
VRECLAPF DS    CL2    APF CODE
VRECLSSI DS    0CL4   SSI INFO
VRECLSI1 DS    CL1    SEE LOAD MODULE DSECT FOR EXPLANATION
VRECLSI2 DS    CL1              OF SSI FIELDS
VRECLSI3 DS    CL1
VRECLSI4 DS    CL1
         ORG   VRECOUT+100    RESET ADDRESSING
         TITLE 'V OPTION -OTHER DATA AREAS, DCB AND MSG AREA'
EPA      DS    F              ADDR OF READVTOC MODULE
BLDLLIST DS    0F         BLDL LIST FOR GETTING READVTOC AND HFSELECT
         DC    H'2'
         DC    H'74'
BLDLDATA DC   2XL74'00'   FIRST MODULE=HFSELECT, 2ND=READVTC
         SPACE 1
ATTCHFLG DC    C'Y'    ATTACH FLAG- SET TO N FOR TAPE;ORPHAN ENTRY
FILETYPE DS    C             FILE TYPE (NON-VSAM, AIX, CLUSTER, ETC)
ENDVOLFL DC    X'00'           END OF VOLSER TABLE FLAG
VSORTDON DC    C'0'         SORT END INDICATOR
DSCBWORK DS    D      8 BYTE WORK AREA
SAVELMFL DS    X      SAVE THE LOAD MODULE FLAGS (SSI & APF FLAGS)
UDATALEN DS    XL1   COMPUTE USER DATA LENG AND HOLD MEMB DIRECTORY LEN
SIZEWRK  DS    CL9    9 BYTE WORK AREA FOR LOAD MODULE SIZE
INVALFLD DC    C'????????' FILLER FOR INVALID ALIAS OF & APF CODE FLDS
DATASETX DC    X'09',C'DATASETX',X'40'   CLASS FOR RACHECK
         SPACE 3
DCBDDNM  EQU   40        OFFSET TO DCBDDNAME IN DCB
ACBDDNM  EQU   DCBDDNM
DCBFLAG  EQU   48        OFFSET TO DCBOLGS IN DCB
DSN1STCH DC    XL1'05'   FIRST CHAR OF INIT DSN DEFAULT TO X'05'
ONE      DC    PL1'1'    CONSTANT ONE
PDSCBTOT DC    PL8'0'
PDSCBSEL DC    PL8'0'
PPDSTOT  DC    PL8'0'
PMEMTOT  DC    PL8'0'
PMEMSEL  DC    PL8'0'
PRECSEL  DC    PL8'0'
VKEYERCT DC    PL8'0'    NUMBER OF VSYSIN KEY ERRORS ON CATLG SEARCH
NOATCHCT DC    PL8'0'   NO. OF DSNS FOR WHICH A SUB-TASK WASNT ATTCHED
ATCHFAIL DC    PL8'0'   NO. OF FAILED ATTACHED SUBTASKS
VCOUNT   DS    PL8       HOLD J=COUNT
VTOTCNT  DS    PL8     HOLD MAXIMUM NUMBER OF RECS TO BE SELECTED
VPACKCNT DS    D  PACK THE TABLE ELEMENT COUNT HERE
SAVDYNDD DS    CL8     DYNALLOC DDNAME SAVED HERE
ATTCHECB DC    F'0'    ATTACH ECB
TCBADDR  DC    F'0'    TASK CONTROL BLOCK ADDR RETURNED BY ATTACH
SAVEWC   DS    A     AREA TO SAVE ADDR OF * OR + IN HIGHQUAL(CAT SRCH)
VOPTRC   DC    H'8'   AREA TO HOLD HIGHEST RC FROM ALL ATTACHED TASKS
EXITPARM DC    A(VRECOUT)    PARAMETER LIST FOR O1/O2 EXITS
         SPACE 1
INITDSN  DS    CL44     FOR INDEXED VTOCS - INITAL DSN
WCDSCBDS DC    CL44' '  WORK AREA FOR WILDCARD COMPARE
PLUSMASK DS    CL44     WORK AREA FOR WILDCARD COMPARE
HIGHQUAL DC    CL44' '  AREA TO FORM HIGH ORDER QUALIF FOR CATALOG SRCH
VBLANKS  DC    CL44' '  BLANKS
         SPACE 1
*        CATALOG SEARCH AREA
SRCHCAT  CAMLST NAME,DSCBDSN,,RETAREA   CATALOG LOCATE LIST
         DS    0D    ALIGN RETURN AREA ON DOUBLE WORD
RETAREA  DS    0CL265
VOLCNT   DS    H       VOLUME COUNT
         DS    4X
VOLID    DS    CL6     VOLSER
         DS    253X
         SPACE 1
SRCHVTOC CAMLST SEARCH,DSCBDSN,MASKVOL,DSCBFMT VTOC SEARCH LIST
         SPACE 1
UNCATLG  CAMLST UNCAT,DYNDSN
CATLG    CAMLST CAT,DYNDSN,,CVOLLIST
CVOLLIST DC    H'1'            1 VOLUME IN VOL LIST
CVOLDEVT DS    XL4
CVOLSER  DS    CL6
         DC    XL2'0'
SAVER10  DS    F               SAVE R10 (BAL REG)
         SPACE 1
CIRPARM  DS    0F              IKJEHCIR PARAMETER LIST
CIROPT   DC    X'06'
         DS    XL2
CIRLOCRC DS    X
CIRSRCH  DC    A(SRCHARG)
CIRCVOL  DS    A
CIRWA    DS    A
CIRSAVE  DC    A(SVAREA)
CIRPSWD  DC    A(PASSWORD)
         SPACE
SVAREA   DS    18F
PASSWORD DC    D'0'
SRCHARG  DC    CL44' '       <=== MUST BE REINIT TO BLANK
CIRWALEN DC    A(65530) MAX HALF-WORD LENG FOR IKJEHCIR GETMAINWKAREA
VOLNUM   DS    F        SAVE AREA FOR NUM OF VOL DS RESIDES ON
         SPACE 1
PARMUCB  DS    0F       UCB SEARCH PARAMETER LIST
         DC    A(WKAREA)
         DC    A(DEVCLASS)
         DC    X'80',AL3(ADDRUCB)
DEVCLASS DC    AL1(UCB3DACC)    SPECIFY DISK ONLY
ADDRUCB  DS    A                ADDR OF UCB RETURNED HERE
         DS    0D
WKAREA   DS    CL100
SCANUCB  DS    A       ADDRESS OF IOSVSUCB ROUTINE IN CVT
         SPACE 1
BUFLIST  ICVAFBFL DSECT=NO
         SPACE 1
         DS    0H      ALTERNATE PGM UTILITY PARAMETER LIST
VPGMLEN  DC    AL2(L'VPGMEND)    LENGTH OF UTILITY PARAMETER LIST
VPGMDDTB DC    5XL8'00'          EMPTY ENTRIES
VPGMSYSP DC    CL8'SYSPRIN2'     ALTERNATE SYSPRINT DD <===
         DC    XL8'00'
VPGMSYS1 DC    CL8'SYSUT1'       ALTERNATE SYSUT1
VPGMSYS2 DC    CL8'SYSUT2'       ALTERNATE SYSUT2
         DC    2XL8'00'          SYSUT3/4
VPGMEND  EQU   VPGMDDTB,*-VPGMDDTB
PGMNAME  DC    CL8'HFSELECT'     SUB-TASK PROGRAM NAME
VPGMADR  DS    A                 SAVE ADR OF / AND COMMA FOR PGM NAME
VPGMDD   DC    CL3' '            ALTERNATE DD FOR ALTPGM (SYS OR LIB)
VSAVDLM  DS    CL1               DLM FOLLOWING PGM NAME
*
XRECCNT  DC    PL3'0'    COUNT USED TO SET UP SYSVNNNN/LIBVNNNN DDS
EXITR1   DC    CL80'X0'  X0 INIT STATEMENT FOR EXITS FILE
EXITR2   DC    C' ALTDDS=,,,'
XALTDD2  DC    CL8'SYSUT2  '     ALT DDNAME SYSVNNNN
         DC    C',,,,'
XALTDD   DC    CL8'LIBOUT'       ALT DDNAME LIBVNNNN
         DC    CL49' '
*
VDDPREF  DS    CL3               SYS OR LIB FOR //DISK
VSPCLIST DS    0XL59    PARAMETER LIST FOR FILESPAC RTN
         DS    XL2
VSPCDSN  DS    CL44
VSPCVOL  DS    CL6
         DS    CL2
VSPCTRK  DS    CL5
*
REALOCRC DC    XL1'00'         RETURN CODE FROM REALLOC MACRO
REALLOCL REALLOC MF=L          GENERATE REALLOC PARAMETER LIST
VUCBA    DS    A
         DS    0F     ALLIGN ON FULLWORD TO ENSURE NO SLACK
PDSCB    DS    0XL116          PARTIAL DSCB FOR REALLOC MACRO
         DS    XL108
VTRKS    DS    F   VTRKS & VDIRBLKS MUST BE CONTIG WITH PDSCB-NO SLACK!
VDIRBLKS DC    F'100'       100 DIRECTORY BLKS- MAY BE CHGED BY EXITS
VDISKVOL DC    CL6' '
*
VMSG1    DC    C'0SEL100I NUMBER OF FMT1 DSCBS PROCESSED ='
VMSG1ED  DC    X'40202020202020212021'
VMSGLEN  EQU   *-VMSG1
VMSG2    DC    C'0SEL101I NUMBER OF FMT1 DSCBS SELECTED  ='
VMSG2ED  DC    X'40202020202020212021'
VMSG3    DC    C'0SEL102I NUMBER OF PDS FILES PROCESSED  ='
VMSG3ED  DC    X'40202020202020212021'
VMSG4    DC    C'0SEL103I NUMBER OF PDS MEMBERS PROCESSED='
VMSG4ED  DC    X'40202020202020212021'
VMSG5    DC    C'0SEL104I NUMBER OF PDS MEMBERS SELECTED ='
VMSG5ED  DC    X'40202020202020212021'
VMSG6    DC    C'0SEL105I NUMBER OF TOTAL RECORDS OUTPUT ='
VMSG6ED  DC    X'40202020202020212021'
* FOLLOWING MSG TALLIES THE NUMBER OF VSYSIN RECORDS THAT HAD ERRORS:
* 1-INVALID WILDCARDS(%,!), 2-WILDCARDS IN HIGH-ORDER QUALIFIER
* 3-CATALOG ENTRIES EXCEEDED MAXIMUM(1455) FOR KEY,4-SECURITY VIOL-NO
*   ACCESS TO CATALOG FOR THIS PREFIX
VMSG7    DC    C'0SEL106W KEYS BYPASSED DUE TO ERRORS    ='
VMSG7ED  DC    X'40202020202020212021'
* FOLLOWING MSG TALLIES THE NUMBER OF DSNS FOR WHICH A SUBTASK WAS NOT
* ATTACHED. REASONS: 1-TAPE DS,2-VSAM DS,3-SECURITY VIOLATION WOULD
* RESULT,4-DATASET IS CATALOGED BUT NOT ON INDICATED VOLUME (OR NON-
* EXISTANT VOLUME) (FOR CATALOG SEARCH OPTION)
VMSG8    DC    C'0SEL107I SUB-TASKS NOT ATTACHED         ='
VMSG8ED  DC    X'40202020202020212021'
* FOLLOWING MSG TALLIES THE NUMBER OF FAILED ATTACHED SUBTASKS
*  REASONS: 1-NOT ENOUGH REGION (80A,106,804),2-X37,3-BAD PARM, ETC.
VMSG9    DC    C'0SEL108I NUMBER OF FAILED SUB-TASKS     ='
VMSG9ED  DC    X'40202020202020212021'
         SPACE 2
VREPORT1 DCB   DDNAME=VREPORT1,DSORG=PS,MACRF=PM,BLKSIZE=0,            X
               LRECL=100,RECFM=FB,SYNAD=SYNADERR,DCBE=VRP1DCBE   @MK1
*@MK1          LRECL=100,RECFM=FB,SYNAD=SYNADERR
         SPACE 2
VREPORT2 DCB   DDNAME=VREPORT2,DSORG=PS,MACRF=PM,BLKSIZE=0,            X
               LRECL=100,RECFM=FB,SYNAD=SYNADERR,EXLST=JFCBXLST, @MK1  X
               DCBE=VRP2DCBE                                     @MK1
*@MK1          LRECL=100,RECFM=FB,SYNAD=SYNADERR,EXLST=JFCBXLST
         SPACE 2
VEXITS   DCB   DDNAME=EXITS,DSORG=PS,MACRF=PM,BLKSIZE=400,             X
               LRECL=80,RECFM=FB,DCBE=VEXTDCBE                   @MK1
*@MK1          LRECL=80,RECFM=FB
         SPACE 2
DISK     DCB   DDNAME=DISK,DSORG=PS,MACRF=R,EXLST=JFCBXLST
         LTORG
VRP1DCBE DCBE  RMODE31=BUFF  31-BIT BUFF -NO FREEPOOL AFTR CLOSE @MK1
VRP2DCBE DCBE  RMODE31=BUFF  31-BIT BUFF -NO FREEPOOL AFTR CLOSE @MK1
VEXTDCBE DCBE  RMODE31=BUFF  31-BIT BUFF -NO FREEPOOL AFTR CLOSE @MK1
         TITLE 'PDS DIRECTORY MAP FOR SPF AND LOAD MODULE STATS'
PDSDRECT DSECT
PDSMEMNM DS    CL8     MEMBER NAME
PDSTTR   DS    XL3     TTR
PDSFLAG  DS    X       INDICATOR FLAG
PDSALIAS EQU   X'80'   ALIAS INDICATOR
PDSPTRS  EQU   X'60'   NO. TTR POINTERS - INDICATES LOAD MODULE
PDSSPFST EQU   X'0F'   NUMBER OF HALFWORDS (15) FOR SPF STATS
PDSPFVV  DS    X       VV -BINARY
PDSPFMM  DS    X       MM- BINARY
         DS    XL3
PDSPFCRD DS    PL3    CREATION DATE - PACKED-YYDDD
         DS    X
PDSPFLMD DS    PL3    LAST MOD DATE - PACKED-YYDDD
PDSPFHH  DS    X      HH - HOURS IN PACKED DEC FORMAT WITH SIGN MISSING
PDSPFTMM DS    X      MM - MINUTES
PDSPFCLN DS    XL2    CURRENT LENGTH
PDSPFILN DS    XL2    INITIAL LENGTH
PDSPFMLN DS    XL2    MODIFIED LENGTH
PDSPFID  DS    CL7    USERID
         SPACE 1
         ORG   PDSPFVV    REDEFINE FOR LOAD MODULES
         DS    8X
MODATTR1 DS    X
REENT    EQU   X'80'
REUSE    EQU   X'40'
OVERLAY  EQU   X'20'
TESTRAN  EQU   X'10'
ONLYLOAD EQU   X'08'
SCATTER  EQU   X'04'
EXECUT   EQU   X'02'
MODATTR2 DS    X
FLKED    EQU   X'80'
REFRESH  EQU   X'01'
SIZE     DS    XL3
         DS    5X
LMFLAG   DS    X      LOAD MODULE FLAGS
SSIINFO  EQU   X'10'  SSI SECTION PRESENT
APFINFO  EQU   X'08'  APF CODE SECTION PRESENT
         SPACE 1
         ORG   PDSMEMNM    ORG BACK TO DISPLACEMENT 0 OF DIRECTORY MEMB
         DS    3X          ALIAS OF SECTION
ALIASOF  DS    CL8
         SPACE 1
         ORG   PDSMEMNM
         DS    X           SSI SECTION
SSIFLAG  DS    X      SSI FLAG GIVING INFO ON MODULE
SSIINST  EQU   X'20' CHG BY INSTALLATION; NOT BY IBM MAINTENANCE
SSICHGDP EQU   X'08' MODULE IS CHG DEPENDENT ON SOME OTHER SYSTEM MODUL
SSISYSG  EQU   X'06' CHANGE MAY REQUIRE COMPLETE/PARTIAL SYSGEN
SSIIBMM  EQU   X'01' IBM SUPPLIED MODULE
         ORG   PDSMEMNM
         DS    X           APF SECTION
APFCODE  DS    X
         SPACE 1
         IHAPDS PDSBLDL=NO     GET PDS DSECT,NO EXTRA BLDL BYTES
         SPACE 1
         CVT   DSECT=YES
         SPACE 1
         DSECT
         IEFUCBOB
         SPACE 1
CVPL     ICVAFPL ,
         TITLE 'DYNAMIC ALLOCATION OF SYSPRINT SYSOUT DATA SET'
DYNALLOC CSECT
*        THIS CSECT WILL DYNAMICALLY PRODUCE A SYSPRINT DD
*        STATEMENT (ASSIGNED TO SYSOUT=MSGCLASS) IF THE SYSPRINT
*        DD STATEMENT HAS NOT BEEN CODED IN THE JCL.
*           THE REGISTER ASSIGNMENTS ARE AS FOLLOWS:
*        R12=BASE REGISTER
*        R8 =BASE FOR REQUEST BLOCK POINTER
*        R4 =BASE FOR REQUEST BLOCK
*        R5 =BASE FOR TEXT UNIT POINTERS
*        R6 =BASE FOR TEXT UNITS
         USING *,R15
         STM   R2,R14,SAVEAREF    SAVE REGISTER ROUTINE
         CNOP  0,4
         BAL   R12,JUMPSAV7
SAVEAREF DS    13F
JUMPSAV7 EQU   *
         USING SAVEAREF,R12
         DROP  R15
         LA    R8,S99AREA      GET ADDRESS OF STORAGE USED FOR
         USING S99RBP,R8      REQUEST BLOCK POINTER AND PARAMETERS
         LA    R4,S99RBPTR+4    POINT TO REQUEST BLOCK BEYOND POINTER
         USING S99RB,R4       ESTABLISH ADDRESSABILITY
         ST    R4,S99RBPTR         STORE REQUEST BLOCK ADDR IN POINTER
         OI    S99RBPTR,S99RBPND    INDICATE END OF LIST (X'80')
         XC    S99RB(RBLEN),S99RB   ZERO OUT REQUEST BLOCK
         MVI   S99RBLN,RBLEN       PUT LENGTH OF RB IN ITS LENGTH FLD
         MVI   S99VERB,S99VRBAL  SET VERB CODE FIELD TO ALLOCATION FUNC
         MVI   S99FLG11,S99JBSYS  INDICATE THIS IS A SYSOUT DATA SET
         LA    R5,S99RB+RBLEN  POINT 20 BYTE BEYOND RB TO TEXT POINTERS
         USING S99TUPL,R5      ESTABLISH ADDRESSABILITY FOR TU POINTERS
         ST    R5,S99TXTPP    INITIALIZE TEXT POINTER ADDR IN RB
         LA    R6,S99TUPL+8   POINT JUST PAST THE 2 TEXT UNIT POINTERS
         USING S99TUNIT,R6   TO TEXT UNITS AND ESTABLISH ADDRESSABILITY
         ST    R6,S99TUPTR POINT 1ST TEXT UNIT POINTER TO 1ST TEXT UNIT
         LA    R7,DALSYSOU   GET THE KEY FOR ALLOCATING SYSOUT DATA SET
         STH   R7,S99TUKEY    PUT THE KEY IN THE TEXT UNIT KEY FIELD
*  ONLY  THE KEY IS NEEDED FOR SYSOUT WITH DEFAULT CLASS (OF MSGCLASS)
         LA    R6,S99TUNIT+4    POINT PAST THE FIRST TEXT UNIT
         LA    R5,S99TUPL+4 POINT TO THE 2ND TEXT UNIT POINTER IN LIST
         ST    R6,S99TUPTR POINT 2ND TEXT UNIT POINTER TO 2ND TEXT UNIT
         LA    R7,DALDDNAM GET THE KEY FOR ASSOCIATING A DDNAME TO DSN
         STH   R7,S99TUKEY    PUT THE KEY IN THE TEXT UNIT KEY FIELD
         MVI   S99TUNUM+1,X'01' DDNAME NEEDS ONLY 1 PARM-PUT 1 IN # FLD
         MVI   S99TULNG+1,X'08' SET LENGTH OF DDNAME
         L     R1,=A(PRINT)     GET SYSPRINT DCB
         MVC   S99TUPAR(8),DCBDDNM(R1)   MOVE IN DDNAME
         OI    S99TUPTR,S99TUPLN      INDICATE END OF LIST
         LR    R1,R8  PUT RB POINTER IN R1 FOR DYNALLOC TO INVOKE SVC99
         DYNALLOC
         LH    R15,S99ERROR  LOAD R15 WITH ERROR MSG, IF ANY
         LM    R2,R14,SAVEAREF    RESTORE REGISTERS
         DROP  R4,R5,R6,R8,R12    DROP ALL USING REGISTERS
         BR    R14
         SPACE 1
S99AREA  DS    CL50
         LTORG
         IEFZB4D0
         IEFZB4D2
RBLEN    EQU   S99RBEND-S99RB
         TITLE 'MERGE FILE PROCESSING'
MERGSECT CSECT
*        THIS CSECT WILL OUTPUT A RECORD OF THE MERGE FILE WHENEVER
*        A RECORD IS OUTPUT TO SYSUT2
*           THE REGISTER ASSIGNMENTS ARE AS FOLLOWS:
*        R12=BASE REGISTER
*        R2 =IS ESTABLISHED AS THE ADDR OF THE MERGE DCB
*        R15=RETURN CODE FROM CSECT 0=OK;4=RECFM ERROR
         USING *,R15
         STM   R2,R14,SAVEAREI    SAVE REGISTER ROUTINE
         CNOP  0,4
         BAL   R12,JUMPSAV9
SAVEAREI DS    13F
JUMPSAV9 EQU   *
         USING SAVEAREI,R12
         DROP  R15
         L     R1,=A(PUTADDR)   SAVE PRIMARY INPUT RECORD ADDR
         L     R1,0(0,R1)
         ST    R1,INREC
         L     R1,=A(CARDADDR)
         L     R1,0(0,R1)       SAVE SYSIN REC ADDR
         ST    R1,SYSINREC
         L     R2,=A(MERGE)     ESTABLISH R2 AS MERGE DCB ADDR
HOUSEKP  NOP   PUTMERGE         SET TO BR AFTER 1ST TIME THRU
         MVI   HOUSEKP+1,SETBR
         OPEN  ((R2),OUTPUT)    OPEN MERGE FILE
         LH    R0,CONCATLN  CONCATLN IS CALCULATE IN THE MERGE DCB EXIT
         GETMAIN R,LV=(0)       GET BUFFER FOR CONCATENATED RECORD
         ST    R1,SUMRECAD      SAVE BUFFER ADDR
         SPACE 2
PUTMERGE L     R0,INREC     GET SYSUT1 REC ADDR
         CLI   INRECFVU,C'V'  IS SYSUT1 VARIABLE
         BE    RECFM1V       YES
         LH    R1,INRECLRE NO-GET SYSUT1 LRECL
CONTINU1 LR    R15,R1
         L     R14,SUMRECAD  GET CONCATENATED AREA ADDR
         MVCL  R14,R0  R14 NOW CONTAINS ADDR OF SUMRECAD+LENGTH(SYSUT1)
         L     R0,SYSINREC     GET SYSIN REC ADDR
         CLI   SYSNRECF,C'V'   IS SYSIN RECFM=V
         BE    RECFM2V         NO
         LH    R1,SYSINLRE     GET SYSIN LRECL
CONTINU2 LR    R15,R1
         MVCL  R14,R0          PLACE SYSIN REC JUST BEYOND SYSUT1
         CLI   INRECFVU,C'V'   IS SYSUT1 RECFM=V
         BNE   MVCLEND         NO- NO MORE ADJUSTMENTS
         L     R1,SUMRECAD     YES -POINT TO BEGINNING OF CONCAT REC
         LH    R0,0(0,R1)      RDW OF CONCATENATED REC
         CLI   SYSNRECF,C'V'   IS SYSIN RECFM=V
         BE    VVREC            YES- BOTH SYSUT1 AND SYSIN ARE RECFM=V
         AH    R0,SYSINLRE    NO- ADD LRECL OF SYSIN FROM DCB
         B     SETRDW
VVREC    L     R14,SYSINREC    POINT TO BEGINNING OF SYSIN REC
         LH    R14,0(0,R14)    GET SYSIN RDW
         S     R14,=F'4'      SUBTRACT 4 FROM RDW OF SYSIN(DATA LENG)
         AR    R0,R14         ADD SYSIN RDW TO SYSUT1 RDW
SETRDW   CH    R0,LRECL(R2)   COMPARE RDW TO JCL LRECL
         BNH   SETRDW2        OK TO USE JUST CALCULATED RDW
         LH    R0,LRECL(R2)   JCL LRECL IS LESS THAN RDW - USE JCL
SETRDW2  STH   R0,0(0,R1)      AND STORE INTO CONCATENATED RDW
MVCLEND  EQU   *
         SPACE 1
EXITBROM B     NOEXITOM   CHANGED TO NOP IF EXIT POINT OM REQUESTED
         L     R15,=A(EXTEPAOM)   GET EXIT OM ENTRY POINT
         L     R15,0(R15)
         LA    R1,SUMRECAD        SET UP PARAMETER LIST
         BALR  R14,R15            EXECUTE OM EXIT
         C     R15,=F'4'          CHECK RETURN CODE
         BL    NOEXITOM RC=0   CONTINUE NORMAL PROCESSING
         BE    RETURN6  RC=4  DELETE THIS RECORD-DONT WRITE MERGE REC
         MVI   EXITBROM+1,SETBR  RC=8  DO NOT RETURN TO THIS EXIT
NOEXITOM EQU   *
         LR    R1,R2          GET MERGE DCB ADDRESS
         L     R0,SUMRECAD LOAD ADDR OF CONCATENATED AREA INTO R0
MERGPUT  NOP   MERGPRT        SET TO BRANCH ON //MERGE DD SYSOUT=
         PUT   (R1),(R0)     PUT OUT A RECORD TO SYSUT2
MERGPRT  B     RETURN6       SET TO NOP ON SYSOUT
MERGPRTL L     R15,=A(PRINTER)  PRINT RTN FOR SYSOUT
         LA    R2,PRTDCB        ORIGINAL MERGE DCB
         BALR  R14,R15         PERFORM PRINT RTN
         SPACE 1
RETURN6  LA    R15,0         SET RETURN CODE
         LM    R2,R14,SAVEAREI
         BR    R14
         SPACE 2
RECFM1V  L     R1,INREC      GET ADDR OF SYSUT1 REC
         LH    R1,0(0,R1)    GET RDW IN R1
         B     CONTINU1
         SPACE 2
RECFM2V  L     R1,SYSINREC   GET ADDR OF SYSIN  REC
         LH    R1,0(0,R1)    GET RDW IN R1
         A     R0,=F'4'      POINT BEYOND RDW
         B     CONTINU2
         SPACE 5
*       RULES FOR DCB CHECKING- IF THE OUTPUT RECORD TYPE DOESN'T MATCH
*       THE INPUT RECORD TYPE - ERROR (SEE ABOVE).
*       DEFAULTS: IF NO RECFM USE PRIMARY FILE RECFM
*                 IF NO LRECL USE SYSUT1 LRECL + SYSIN LRECL
*   SAVEAREA IS BEING USED AS THE THE SAVE AREA BY THE SYSTEM SINCE R13
*   CONTAINS THE ADDRESS OF SAVEAREA.
*        R14 IS SAVED IN XLSTSAVE
MERGXLST DS    0F            BEGIN EXLST ON A FULLWORD BOUNDARY
         DC    X'85'  DEFINE ENTRY AS DCB EXLST
         DC    AL3(MERGDCB)
MERGDCB  ST    R14,XLSTSAVE      SAVE R14
         LR    R2,R1             MOVE DCB ADDRESS TO R2
         USING IHADCB,R2         ADDRESSABILITY
         CLI   DCBRECFM,X'00'    WAS RECFM SPECIFIED
         BNE   SETRECFM                 YES
         L     R1,=A(INRECFM2)
         MVC   DCBRECFM,0(R1)     NO- USE PRIMARY INPUT RECFM
SETRECFM MVI   MERGEFVU,C'U'
         TM    DCBRECFM,X'C0'  IS MERGE RECFM=U
         BO    RECFMOK          YES
         MVI   MERGEFVU,C'F'
         TM    DCBRECFM,X'80'  IS MERGE RECFM=F
         BO    RECFMOK          YES
         MVI   MERGEFVU,C'V'
         TM    DCBRECFM,X'40'  IS MERGE RECFM=V
         BO    RECFMOK          YES
RECFMER2 MVI   RETURN6+3,X'04'  NO-INVALID RECFM
         B     ENDXLST
RECFMOK  EQU   *
         L     R1,=A(MSG40FVU)  GET TRANSLATED RECFM OF SYSUT1
         MVC   INRECFVU,0(R1)   AND SAVE IT
         CLC   INRECFVU,MERGEFVU   COMPARE SYSUT1 AND MERGE RECFMS
         BNE   RECFMER2            ERROR
         L     R1,=A(SYSINFVU)  SYSIN RECFM (F,V,U)
         MVC   SYSNRECF,0(R1)      AND SAVE IT
         SPACE 1
         L     R4,=A(MAXLEN)    GET LRECL OF PRIMARY INPUT FILE
         L     R4,0(0,R4)
         L     R1,=A(MSG40ORG)  IS THIS A VSAM FILE
         CLI   0(R1),C'V'
         BNE   NOTVS            NO
         LA    R4,4(R4)     YES-ADD IN 4-BYTES FOR VSAM RDW
NOTVS    STH   R4,INRECLRE      SAVE LRECL
         L     R1,=A(CARDS)     GET SYSIN LRECL
         MVC   SYSINLRE,LRECL(R1)   SAVE SYSIN LRECL
         AH    R4,LRECL(R1)     ADD SYSUT1 AND SYSIN LRECLS
         C     R4,=F'32760'     INSURE DOESNT EXCEED MAX
         BL    LRECLOK
         L     R4,=F'32760'
LRECLOK  STH   R4,CONCATLN      SAVE LRECL SUM
         LH    R1,DCBLRECL         GET MERGE LRECL
         LTR   R1,R1
         BNZ   CHKSYSOT    IF NOT 0 - OK TO USE WHATS ENTERED IN JCL
         MVC   DCBLRECL,CONCATLN OTHERWISE USE DEFAULT SUM
*  BLKSIZE PROBLEMS WILL TAKEN CARE OF BY IEC141I 013,RC=20,34,OR 60
CHKSYSOT DEVTYPE MERGEDD,MERGEDEV
         CLC   MERGEDEV,=X'00000102'  IS MERGE A SYSOUT DATA SET
         BE    MRGSYSOT         YES
ENDXLST  EQU   *
         L     R14,XLSTSAVE      RESTORE  R14
         BR    R14                    RETURN TO OPEN MACRO
*
MRGSYSOT EQU   *
         TM    DCBOPTCD,X'40'   WAS DCB=OPTCD=U CODED ON SYSOUT
         BO    ENDXLST          YES - DO NOT DO SYSOUT FORMATTING
         MVC   PRTDCB,0(R2)      SAVE ORIGINAL DCB FOR PRINT CSECT
         NI    DCBRECFM,X'06'   ZERO OUT EVERYTHING EXCEPT RECFM=A,M
         OI    DCBRECFM,X'90'   MOVE IN RECFM=FB
         MVC   DCBLRECL,=H'133' MOVE 133 TO LRECL FOR PRINT LINE
         MVC   DCBBLKSI,=H'5320'  MOVE 5320 TO BLKSIZE
         MVI   MERGPUT+1,SETBR    YES-SET BRANCH AND NOP FOR PRINT
         MVI   MERGPRT+1,SETNOP
         B     ENDXLST                 RETURN
         DROP  R12,R2
         SPACE 2
XLSTSAVE DS    A         SAVE R14 FOR DCB XLST PROCESSING
SYSINREC DS    A         ADDR OF THE SYSIN REC
INREC    DS    A         ADDR OF THE PRIMARY INPUT REC
SUMRECAD DS    A         ADDR OF AREA WHERE SYSUT1 AND SYSIN ARE GLUED
CONCATLN DS    H         LENGTH OF SUMRECAD AREA
INRECLRE DS    H         PRIMARY INPUT FILE LRECL
SYSINLRE DS    H         SYSIN LRECL
MERGEFVU DS    C         MERGE FILE RECFM (F,V,U)
INRECFVU DS    C         PRIMARY FILE RECFM (F,V,U)
SYSNRECF DS    C         SYSIN RECFM (F,V,U)
MERGEDD  DC    C'MERGE   '
MERGEDEV DS    2F
PRTDCB   DS    CL96      ORIGINAL MERGE DCB
         LTORG
         TITLE 'PROCESS EXITS FILE'
EXITSECT CSECT
*        THIS CSECT WILL READ THE EXITS FILE AND SET UP THE CODE
*        FOR HFSELECT TO TAKE THE FOLLOWING EXIT POINTS:
*        I1- BEFORE INPUT
*        I2- AFTER INPUT BUT BEFORE SELECTION PROCESSING
*        O1- BEFORE OUTPUT AND AFTER SELECTION PROCESSING ON SYSUT2
*        O2- BEFORE OUTPUT AND AFTER SELECTION PROCESSING ON SYSUT3
*        O3- BEFORE OUTPUT AND AFTER SELECTION PROCESSING ON SYSUT4
*        O4- BEFORE OUTPUT AND AFTER SELECTION PROCESSING ON SYSUT5
*        OM- BEFORE OUTPUT AND AFTER SELECTION PROCESSING ON MERGE
*        X0- GLOBAL INITIALIZATION EXIT
*            FORMAT={NONE|HEX|ASCII|RULER}
*            ALTDDS=NAME1,...,NAME7    ALTERNATE NAMES FOR SYSPRINT,
*                  SYSIN,SYSUT1,...,SYSUT5
*            NOCATCK
*       EXIT O1 IS IGNORED IF SYSUT2 SPECIFIES VSAMOUT
*       THE FORMAT OF THE EXITS CONTROL STATEMENT IS:
*       EXITPOINT=MODNAME,DDNAME  E.G. O2=COMPRESS,LOADLIB
*        DDNAME IS AN OPTIONAL PARAMETER-IF NOT CODED MODNAME COME FROM
*        EITHER A LINKLISTED LIBRARY OR FROM THE STEPLIB
*           THE REGISTER ASSIGNMENTS ARE AS FOLLOWS:
*        R3= CONTAINS PARM ADDR - SAVED IN PARMREG
*        R12=BASE REGISTER
*        R15=RETURN CODE FROM CSECT 0=OK;4=CONTOL STATEMENT ERROR
         USING *,R15
         STM   R2,R14,SAVEAREZ    SAVE REGISTER ROUTINE
         CNOP  0,4
         BAL   R12,JUMPSAVZ
SAVEAREZ DS    13F
JUMPSAVZ EQU   *
         USING SAVEAREZ,R12
         DROP  R15
         ST    R3,PARMREG
         OPEN  (EXITS)      OPEN EXITS FILE, IF IT EXISTS
GETEXITS GET   EXITS        READ EXITS FILE
         MVC   EXITREC,0(R1)   MOVE TO RECORD AREA
         BAL   R8,PRTEXIT      PERFORM- STORE CONTROL CARD FOR PRINTING
NORMEXIT MVC   EXITBLDL+4(8),=CL8' '      SPACE OUT MODULE NAME
         LA    R3,0 INIT R3 (DCB ADDR) TO 0 IN CASE NO DDNAME SPECIFIED
         TRT   EXITREC+3(9),COMATRT    IS THERE A COMMA FOR DDNAME
         BZ    NODDNM       NO
         MVC   LOADDCB+DCBDDNM(8),1(R1)  MODIFY DCB FOR DDNAME
         LA    R2,EXITREC+3              GET START ADDR OF MODNAME
         SR    R1,R2                     GET LENGTH OF MODNAME
         BCTR  R1,0         SUB 1
         STC   R1,MVMODNM+1              SET MODNM LENGTH
         OPEN  (LOADDCB)                 OPEN LOAD LIB CONTAINING MODNM
         TM    LOADDCB+DCBFLAG,X'10'  WAS LOADDCB FOUND IN JCL
         BNO   EXITERR
         LA    R3,LOADDCB
MVMODNM  MVC   EXITBLDL+4(0),EXITREC+3
         CLC   EXITREC(3),=C'O1='   IS THIS AN O1 EXIT POINT
         BNE   NOTO1                NO
         BAL   R8,BLDLRTN
         MVC   EXTEPAO1,EPASV SAVE O1 EPA LOAD POINT
         L     R1,=A(EXITBRO1)
         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O1 EXIT
         L     R1,=A(VXITBRO1)      V OPTION
         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O1 EXIT
         B     GETEXITS             ANY MORE EXITS?
NOTO1    CLC   EXITREC(3),=C'O2='   IS THIS AN O2 EXIT POINT
         BNE   NOTO2                NO
         BAL   R8,BLDLRTN
         MVC   EXTEPAO2,EPASV SAVE O2 EPA LOAD POINT
         L     R1,=A(EXITBRO2)
         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O1 EXIT
         L     R1,=A(VXITBRO2)      V OPTION
         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O1 EXIT
         B     GETEXITS             ANY MORE EXITS?
NOTO2    CLC   EXITREC(3),=C'O3='   IS THIS AN O3 EXIT POINT
         BNE   NOTO3                NO
         BAL   R8,BLDLRTN
         MVC   EXTEPAO3,EPASV SAVE O3 EPA LOAD POINT
         L     R1,=A(EXITBRO3)
         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O1 EXIT
         B     GETEXITS             ANY MORE EXITS?
NOTO3    CLC   EXITREC(3),=C'O4='   IS THIS AN O4 EXIT POINT
         BNE   NOTO4                NO
         BAL   R8,BLDLRTN
         MVC   EXTEPAO4,EPASV SAVE O4 EPA LOAD POINT
         L     R1,=A(EXITBRO4)
         MVI   1(R1),SETNOP         SET NOP TO EXECUTE O4 EXIT
         B     GETEXITS             ANY MORE EXITS?
         SPACE 1
NOTO4    CLC   EXITREC(3),=C'OM='   IS THIS AN OM EXIT POINT
         BNE   NOTOM                NO
         BAL   R8,BLDLRTN
         MVC   EXTEPAOM,EPASV SAVE OM EPA LOAD POINT
         L     R1,=A(EXITBROM)
         MVI   1(R1),SETNOP         SET NOP TO EXECUTE OM EXIT
         B     GETEXITS             ANY MORE EXITS?
         SPACE 1
NOTOM    CLC   EXITREC(3),=C'I1='   IS THIS AN I1 EXIT POINT
         BNE   NOTI1                NO
         BAL   R8,BLDLRTN
         MVC   EXTEPAI1,EPASV SAVE I1 EPA LOAD POINT
         L     R1,=A(EXITBRI1)
         MVI   1(R1),SETNOP         SET NOP TO EXECUTE I1 EXIT
         B     GETEXITS             ANY MORE EXITS?
         SPACE 1
NOTI1    CLC   EXITREC(3),=C'I2='   IS THIS AN I2 EXIT POINT
         BNE   NOTI2                NO
         BAL   R8,BLDLRTN
         MVC   EXTEPAI2,EPASV SAVE I2 EPA LOAD POINT
         L     R1,=A(EXITBRI2)
         MVI   1(R1),SETNOP         SET NOP TO EXECUTE I2 EXIT
         B     GETEXITS             ANY MORE EXITS?
         SPACE 1
BLDLRTN  BLDL  (R3),EXITBLDL GET MODNM FROM LNKLST, STEPLIB OR LOADDCB
         LTR   R15,R15       WAS BLDL SUCCESSFUL
         BNZ   EXITERR               NO
         LOAD  DE=EXITBLDL+4,DCB=(R3)   GET EPA OF EXIT
         ST    R0,EPASV                 AND SAVE IT
         CLOSE ((R3))
         BR    R8              RETURN
         SPACE 1
NODDNM   MVI   MVMODNM+1,X'07'  MOVE FULL 8 BYTES MODNAME
         B     MVMODNM
         SPACE 1
RETURNX  CLOSE (EXITS)
         FREEPOOL EXITS
         SPACE 1
         CVB   R15,XTBLCNT      STORE THE COUNT OF EXITS CONTROL ST
         L     R1,=A(MSGCNT)    IN MSGCNT FOR PRINTING
         STH   R15,0(R1)
         LM    R2,R14,SAVEAREZ
EXITRC   LA    R15,0
         BR    R14
         SPACE 2
EXITERR  MVI   EXITRC+3,X'04'   ERROR CONDITION
         B     RETURNX
         SPACE 1
NOTI2    CLC   EXITREC(2),=C'X0'   IS THIS AN X0 EXIT POINT-INIT
         BNE   EXITERR              NO
XINIT    GET   EXITS
         MVC   EXITREC,0(R1)
         BAL   R8,PRTEXIT
         CLI   EXITREC,BLANK1      FIRST COLUMN MUST BE BLANK
         BNE   NORMEXIT
*        CLC   EXITREC+1(5),=C'SORT='     SORT INIT OPTION
*        BNE   NOTSORT                         NO
*        L     R1,=A(INFIL)             YES - GET SYSUT1 DCB ADDR
*        CLC   EXITREC+6(6),=C'SYSUT1'
*        BE    SETSORT
*        L     R1,=A(CARDS)                   GET SYSIN DCB ADDR
*        CLC   EXITREC+6(5),=C'SYSIN'
*        BNE   EXITERR
*ETSORT  MVC   DCBDDNM(R1),=C'SORTOUT' MAKE HFSELECT INPUT FILE SORTOUT
*        ZAP   SORTNUM,=P'1'
*        TRT   EXITREC+11(3),COMATRT     LOOK FOR ,N
*        BZ    SKIPPACK
*        PACK  SORTNUM,1(1,R1)       GET NUMBER OF SORT CONTROL RECS
*KIPPACK CVB   R2,SORTNUM            AND CONVERT TO BINARY
*        LA    R3,SORT1        READ THAT MANY STATEMENTS FROM EXITS
*ORTLOOP GET   EXITS
*        MVC   0(80,R3),0(R1)      MOVE ALL SORT CONTROLS TO PARM LIST
*        LA    R3,80(0,R3)
*        BCT   R2,SORTLOOP
*        LINK  EP=SORT,PARAM=(SORTPARM),VL=1     INVOKE SORT
*        B     XINIT
         SPACE 1
         CLC   EXITREC+1(7),=C'FORMAT='
         BNE   NOTFORMT
         CLC   EXITREC+8(3),=C'HEX'
         BNE   NOTFHEX
         L     R1,=A(EXITNOP1)     SET NOP FOR ALL FILES TO PRNT HEX
         MVI   1(R1),SETNOP
         B     XINIT
NOTFHEX  CLC   EXITREC+8(5),=C'RULER'
         BNE   NOTFRULE
         L     R1,=A(EXITNOP2)
         MVI   1(R1),SETNOP
         B     XINIT
NOTFRULE CLC   EXITREC+8(5),=C'ASCII'
         BNE   NOTFASCI
         L     R1,=A(ASCIIPRT)
         MVI   1(R1),SETNOP
         B     XINIT
NOTFASCI CLC   EXITREC+8(4),=C'NONE'
         BNE   EXITERR
         L     R1,=A(EXITNOP3)
         MVI   1(R1),SETBR
         B     XINIT
         SPACE 1
NOTFORMT CLC   EXITREC+1(7),=C'ALTDDS='
         BNE   NOTALTDD
         MVI   COMATRT+C' ',C' ' CHANGE TRT TBL TO LOOK FOR BLANKS ALSO
         LA    R3,EXITREC+8
         LA    R4,DDTBL
DDNMTRT  TRT   0(9,R3),COMATRT     LOOK FOR NEXT ALTDD
         BZ    EXITERR             ERROR
         SR    R1,R3        GET LENGTH OF ALTDD
         BZ    GETNXTDD     NO REPLACEMENT
         BCTR  R1,0         SUB 1
         STC   R1,MVDDNM+1
         L     R2,0(0,R4)   GET APPROPIATE DCB FROM DDTBL
         MVC   DCBDDNM(8,R2),=CL8' '    SPACE OUT THE DDNAME FIRST
MVDDNM   MVC   DCBDDNM(0,R2),0(R3)
         LA    R3,1(R3)  POINT TO NEXT DD ENTRY
NEXTDD   LA    R3,1(R1,R3)  POINT TO NEXT DD ENTRY
         LA    R4,4(0,R4)   POINT TO NEXT DCB IN DDTBL
         CLI   0(R4),X'FF'  END OF TABLE
         BE    XINIT        YES
         B     DDNMTRT      NO- KEEP PROCESSING ALTDDS
         SPACE 1
GETNXTDD CLM   R2,1,=C','    WAS DELIMITER A COMMA
         BE    NEXTDD       YES- THERE ARE MORE ENTRIES IN ALTDDS
         MVI   COMATRT+C' ',X'00'  RESET TRT TABLE
         B     XINIT
NOTALTDD CLC   EXITREC+1(7),=C'NOCATCK'  BYPASS CATLG CHK ON V OPT
         BNE   NONOCAT
         L     R1,=A(BYPCAT)
         MVI   1(R1),SETBR
         L     R1,=A(SETCATLG)
         MVI   1(R1),C'*'       MOVE IN '*' TO INDICATE NOT CHECKED
         B     XINIT
         SPACE 2
NONOCAT  CLC   EXITREC+1(10),=C'TABLESIZE='  MODIFYING T,P,G,E TABL SZ?
         BNE   NOTABSZ                                   NO
         LA    R3,EXITREC+11
         BAL   R8,PACKRTN
         CVB   R1,EXITWORK               AND MAKE IT BINARY
         L     R15,=A(FREELEN)    GET ADDR OF FREELEN - THE TABLE SIZE
         STCM  R1,7,1(R15)    & STORE MODIFIED (IN RIGHTMOST 3 BYTES)
         B     XINIT                      GET MORE PARAMETERS
         SPACE 2
NOTABSZ  CLC   EXITREC+1(7),=C'NOINPUT'   NOINPUT OPTION
         BNE   NOTNOINP                    NO
         L     R1,=A(NOTLIBF)           YES - SET BRANCHES TO BYPASS
         MVI   1(R1),SETBR                    OPEN OF SYSUT1
         L     R1,=A(RNDMONLY)      FORCE END AFTER PRINTING RNDM TBL
         MVI   1(R1),SETBR
         L     R1,=A(GETINPUT)                READ OF SYSUT1
         MVI   1(R1),SETBR
         B     XINIT
         SPACE 2
NOTNOINP CLC   EXITREC+1(10),=C'RANDOMCNT='
         BNE   NOTRNDM                    NO
         LA    R3,EXITREC+11
         BAL   R8,PACKRTN
         L     R1,=A(MAXRNDM)    GET ADDR OF THE MAX NUMB OF RNDM NUMBS
         ZAP   0(8,R1),EXITWORK     AND MOVE IN NEW VALUE (PACKED)
         B     XINIT
         SPACE 2
NOTRNDM  CLC   EXITREC+1(8),=C'NODCBVAL'
         BNE   NOTNODCB
         L     R1,=A(DCBVAL)
         MVI   1(R1),SETBR
         B     XINIT
         SPACE 2
NOTNODCB CLC   EXITREC+1(3),=C'RC='
         BNE   NOTRC                      NO
         CLC   EXITREC+4(5),=C'ABEND'     IS RC=ABEND?
         BNE   NOTRCABE                   NO- MUST BE RC=NNN
         CLC   EXITREC+9(5),=C',DUMP'     IS RC=ABEND,DUMP
         BNE   NOTRCDMP                   NO- MUST BE RC=ABEND ONLY
         L     R1,=A(SETRCDMP)       YES- SET TO ABEND WITH A DUMP
         MVI   1(R1),X'70'           SET BNZ FOR NON-0 RC
         L     R1,=A(DSNBOMB)  MODIFY DCB ABEND EXIT TO NOT IGNORE ABND
         MVI   1(R1),X'00'             AND CREATE A DUMP
         L     R1,=A(IGNOREBM) MODIFY ESTAE EXIT TO NOT IGNORE ABND
         MVI   3(R1),X'00'             AND CREATE A DUMP
         L     R1,=A(SDWAOBT2) (DONT EXEC THE SETRP MACRO IN ESTAE XIT)
         MVI   1(R1),SETBR
         B     XINIT
NOTRCDMP L     R1,=A(SETRCABE)       YES- SET HFSELECT TO ABEND
         MVI   1(R1),X'70'           SET BNZ FOR NON-ZERO RETURN CODE
         B     XINIT
NOTRCABE LA    R3,EXITREC+4
         BAL   R8,PACKRTN
         CVB   R1,EXITWORK
         L     R15,=A(ERROREOJ)
         STC   R1,1(R15)         SET NEW ERROR CODE
         B     XINIT
         SPACE 2
NOTRC    CLC   EXITREC+1(8),=C'DOPTION='  DOPTION=OPTIMIZE|NNN
         BNE   NOTDOPT                 NO
         LA    R3,EXITREC+9            SET UP TO PROCESS DOPTION=NNN
         CLC   EXITREC+9(8),=C'OPTIMIZE'   IS IT DOPTION=OPTIMIZE
         BNE   NODOPTMZ                NO
         L     R1,PARMREG        YES-  GET PARM ADDR
         LH    R15,0(R1)               GET PARM LENGTH
         LTR   R15,R15                  IS IT 0?
         BZ    EXITERR                 YES- THIS IS NOT THE D OPTION
         STH   R15,SCANPRML            PUT PARM LENGTH IN SCANLIST
         STC   R15,SCANMVC+1           SET MOVE LENGTH
SCANMVC  MVC   SCANPARM(0),2(R1)           GET PARM DATA
         CALL  SCAN4HIT,(SCANLIST)   SEARCH FOR ,J=+ IN PARM
         CLI   SCANHIT,C'Y'                FOUND?
         BNE   EXITERR                      NO
         L     R1,=A(DOPTIMIZ+1)       YES
         MVI   0(R1),SETBR             SKIP D OPT OPEN/CLOSE
         CLI   EXITREC+17,C','         IS THERE A DOPTION=...,NNN
         BNE   XINIT                   NO
         LA    R3,9(R3)                YES- POINT TO NNN
NODOPTMZ BAL   R8,PACKRTN  PROCESS THE NNN - TO ACTIVATE D PROCESSING
         L     R1,=A(DCOUNT)      AFTER THE NTH OCCURRENCE OF THE KEY
         ZAP   0(4,R1),EXITWORK
         B     XINIT
         SPACE
NOTDOPT  CLC   EXITREC+1(9),=C'VDIRBLKS='  MODIFYING REALLOC DIR BLKS
         BNE   NOTDIRBL                                  NO
         LA    R3,EXITREC+10
         BAL   R8,PACKRTN
         CVB   R1,EXITWORK               AND MAKE IT BINARY
         L     R15,=A(VDIRBLKS)   GET ADDR OF VDIRBLKS FOR REALLOC
         ST    R1,0(R15)          & STORE
         B     XINIT                      GET MORE PARAMETERS
         SPACE 2
NOTDIRBL CLC   EXITREC+1(5),=C'RECAT'  RECAT FILES ON //DISK
         BNE   EXITERR
         L     R1,=A(RECATRTN)
         NI    1(R1),X'0F'       SET NOPR TO PERFORM UNCAT AND CATLG
         B     XINIT
         SPACE 2
PACKRTN  L     R15,=A(TRNSTAB2)        GET NUMERIC TRANSLATE TBL
         TRT   0(8,R3),0(R15)    AND CHECK THAT SIZE ENTERED
         BZ    EXITERR                   INVALID NNNN FOLLOWING =
         SR    R1,R3                     LENGTH OF SIZE
         BZ    EXITERR                   0=INVALID
         BCTR  R1,0                      SUB 1 FROM LENGTH FOR PACK
         EX    R1,PKSIZE                 PACK THE SIZE
         BR    R8
         SPACE 2
PRTEXIT  L     R1,TBLPTR    STORE THE CONTROL CARD
         MVC   9(VMSGLEN,R1),EXITREC    IN A TABLE
         LA    R1,VMSGLEN(R1)        POINT TO NEXT ENTRY
         ST    R1,TBLPTR
         AP    XTBLCNT,=P'1'        CONTROL CARD COUNTER
         BR    R8
         SPACE 2
PKSIZE   PACK  EXITWORK,0(*-*,R3)    PACK THE NNN (TBLSZ, RNDMCNT, RC)
         LTORG
EXITWORK DS    D
XTBLCNT  DC    PL8'0'      COUNTER FOR NUMBER OF CONTROL STATEMENTS
EPASV    DS    F
EXTEPAO1 DS    F
EXTEPAO2 DS    F
EXTEPAO3 DS    F
EXTEPAO4 DS    F
EXTEPAOM DS    F
EXTEPAI1 DS    F
EXTEPAI2 DS    F
EXITBLDL DC    H'1',H'74'   NUMBER OF ENTRIES,LENGTH OF ENTRY
         DC    CL8' ',XL66'00'   MODULE NAME,OTHER STUFF
EXITREC  DS    CL80
EXITS    DCB   DDNAME=EXITS,DSORG=PS,MACRF=GL,BLKSIZE=0,LRECL=80,      X
               RECFM=FB,EODAD=RETURNX
LOADDCB  DCB   DDNAME=XXXXX,DSORG=PO,MACRF=R
COMATRT  DC    256X'00'
         ORG   COMATRT+C','    LOOK FOR COMMAS
         DC    C','
         ORG   COMATRT+256
         CNOP  2,4
*ORTPARM DC    H'28'
*        DC    A(SORT1)       BEGIN ADDR OF SORT CONTROL STATEMENT
*        DC    A(SORT1+719)     END ADDR
*        DC    4F'0'          NO RECORD OR E15/35
*        DC    X'03',AL3(SORTMSG)    CHANGE SYSOUT TO SORTMSG
*ORT1    DC    9CL80' '           ALLOW UP TO 9 SORT CONTROL STATEMENTS
*ORTMSG  DC    CL8'SORTMSG'
*ORTNUM  DC    PL8'1'
DDTBL    DC    A(PRINT)
         DC    A(CARDS)
         DC    A(INFIL)
         DC    A(OUTFIL)
         DC    A(OUTFIL2)
         DC    A(OUTFIL3)
         DC    A(OUTFIL4)
         DC    A(LIBOUT)
         DC    X'FF'
TBLPTR   DC    A(EXITTBL)  POINTER TO TABLE OF EXITS CONTROL STATEMENTS
EXITTBL  DC    25CL(VMSGLEN)'0SEL099I'
PARMREG  DS    F           SAVE PARM REGISTER R3 HERE
SCANLIST DS    0C
         DC    CL80',J=+'  STRING TO BE SCANNED FOR IN DOPTION=OPTIMIZE
         DC    H'4'        SCANNED STRING LENGTH
SCANPARM DC    CL168' '    PARM FIELD TO BE SCANNED
SCANPRML DS    H           PARM FIELD LENGTH
         DS    H           NOT USED
SCANHIT  DS    CL1
         DROP  R12
         TITLE 'DCB OPEN EXIT FOR INPUT FILES TO SET DCBBUFNO-X0 HIPER'
DCBBUFX  CSECT
         USING *,R15
         STM   R2,R14,SAVEAREV
         CNOP  0,4
         BAL   R12,JUMPSAVV
SAVEAREV DS    13F                    SAVE R14
JUMPSAVV EQU   *
         USING SAVEAREV,R12
         DROP  R15
         LR    R4,R1           GET FILE DCB
         USING IHADCB,R4
         L     R1,=A(DDN)        GET INPUT DDNAME
         MVC   DEVDDNAM,0(R1)    MOVE TO DEVDDNAM
         DEVTYPE DEVDDNAM,DEVAREA,DEVTAB  GET NUMB OF TRKS/CYL & DEVTYP
         TM    UCBCLASS,UCB3TAPE     IS IT A TAPE DEVICE
         BO    TAPBUFNO          TAPE RTN
         TM    UCBCLASS,UCB3DACC     IS IT A DASD DEVICE
         BNO   DCBXRET            NO - RETURN
         TM    DCBRECFM,X'80'    IS RECFM=F
         BNO   DCBXRET           NO- RETURN WITHOUT DOING ANYTHING
         TM    DCBRECFM,X'40'
         BO    DCBXRET               ITS RECFM=U
*        COMPUTE THE MAX NUMBER OF RECORDS (BLOCKS) ON A TRACK IN R0
         TRKCALC FUNCTN=TRKCAP,TYPE=UCBDEVCD,R=1,K=DCBKEYLE,           X
               DD=DCBBLKSI,REGSAVE=YES
         C     R0,=F'2' DONT DO ANYTHING FOR FILES WITH 1 OR 2 BLKS/TRK
         BNH   DCBXRET
         C     R0,=F'5'       IS IT LESS THAN THE DEFAULT BUFNO(5)
         BL    BUFNO2X        YES - USE BUFNO = 2*(NUMBER OF BLOCKS)
SETBUFNO STC   R0,DCBBUFNO    MODIFY BUFNO
DCBXRET  LM    R2,R14,SAVEAREV
         BR    R14            RETURN
         SPACE 1
BUFNO2X  SLL   R0,1           MULTIPLY NUMBER OF BLOCKS BY 2 (2 TRKS)
         B     SETBUFNO
         SPACE 1
TAPBUFNO LH    R1,DCBBLKSI     GET TAPE BLKSIZE
         C     R1,=F'15040'         OVER 15K- DONT DO ANYTHING
         BH    DCBXRET
         MVI   DCBBUFNO,X'0A'       UNDER 15K- MAKE BUFNO=10
         B     DCBXRET
         DROP  R4
         SPACE 1
DEVDDNAM DS    CL8
*
DEVAREA  DS   0F     5-WORD AREA RETURNED BY DEVTYPE MACRO
UCBBYTES DS   0F
         DS    2X
UCBCLASS DS    X
UCBDEVCD DS    X
         DS    F,H   MAX BLOCK SIZE, NO. OF PHYSICAL CYLS ON DEVICE
TRKPRCYL DS    H
         DS    2F
*ORKAREA DS    XL140   AREA WHERE OBTAIN CAMLST RETURNS DATA
*        WORKARE+50 IS THE ALLOC TYPE BYTE- X'C0' INDICATES CYL ALLOC
         SPACE 2
         LTORG
         DROP  R12
         TITLE 'ESTAE EXIT ROUTINE'
ESTAEXIT CSECT
*        THE PURPOSE OF THIS CSECT IS TO INTERRUPT CERTAIN ABEND CODES,
*        WRITE A MESSAGE TO THE USER EXPLAINING THE ABEND AND THEN
*        SUPPRESSING AN ABEND DUMP. THE ABEND CODES INTERCEPTED ARE
*        80A(REGION), B37-E37(SPACE ON DISK), 722(LINES EXCEEDED.
*           REGISTER CONVENTIONS UPON ENTRY TO CSECT ARE:
*        R0=12 IF SDWA IS OBTAINED BY SYSTEM
*        R1=COMPL CODE,R2=ADDR OF PARAM LIST ON ESTAE MACRO IF R0=12
*        R3-R13 ARE UNPREDICTABLE
*        R14=RETURN ADDR TO CONTROL PROGRAM, R15=ENTRY ADDR TO ESTAEXIT
*           REGISTER CONVENTIONS DURING EXECUTION OF CSECT
*        R0=RETRY ADDR
*        R1=ADDR OF SDWA IF IT IS OBTAINED,R2=ADDR OF PARAM LIST
*        R3=COMPLETION CODE
*        R6=BASE REGISTER
*        R14=RETURN ADDR
*        R15=RETRY CODE-0 IF NO RETRY,4 IF RETRY
         USING *,R15
         ST    R14,SAVEAREE
         CNOP  0,4
         BAL   R6,JUMPSAV5
SAVEAREE DS    F
JUMPSAV5 EQU   *
         USING SAVEAREE,R6
         DROP  R15
         LA    R15,0    BOMBOUT
         C     R0,=F'12'     WAS THE SDWA ALLOCATED
         BNE   SDWAOBT       YES
         LR    R3,R1         NO-LOAD ABEND CODE INTO R3
COMPCC   CLM   R3,3,=X'080A' IS IT A REGION ERR(R1 CONTAINS COMPL CODE)
         BE    IGNOREBM    YES
         CLM   R3,1,=X'37' IS IT A SPACE PROBLEM
         BE    SPACERR
SETRP1   B     RETURN5            CHANGED TO NOP IF SDWA OBTAINED
         SETRP WKAREA=(R1),RC=0,COMPCOD=((R3),SYSTEM)         BOMB
         B     RETURN5
         SPACE 2
SPACERR  CLM   R3,2,=X'0B'    IS IT A B37,C37,D37 OR E37 ERROR
         BL    RETURN5        NO
         SPACE 2
IGNOREBM LA    R15,4     IGNORE THE BOMB EXCEPT WHEN RC=ABEND,DUMP
         L     R0,=A(RETRYADR) LD R0 WITH RETURN ADDR TO MAIN PROGR
SETRP2   B     RETURN5        CHANGED TO NOP IF SDWA OBTAINED
         LR    R4,R0      LOAD RETRY ADDR INTO R4
         SETRP WKAREA=(R1),DUMP=NO,RC=4,RETADDR=(R4),FRESDWA=YES,      X
               COMPCOD=((R3),SYSTEM)
         B     RETURN5
         SPACE 2
SDWAOBT  MVI   SETRP1+1,SETNOP
SDWAOBT2 MVI   SETRP2+1,SETNOP   SETNOP CHG TO SETBR ON RC=ABEND,DUMP
         USING SDWA,R1
         L     R2,SDWAPARM      INSERT PARAM LIST ADDR INTO R2
         L     R3,SDWAABCC      INSERT ABEND COMPL CODE INTO R3
         SRL   R3,12            GET SYSTEM COMPL CODE
         B     COMPCC
         SPACE 2
RETURN5  STH   R3,10(0,R2)      PUT COMPL CODE INTO PARAM LIST
         L     R14,SAVEAREE      RELOAD RETURN ADDR
         DROP  R1,R6
         BR    R14            RETURN TO CONTROL PROGRAM
         SPACE 2
         LTORG
         TITLE 'SPIE EXIT'
SPIEXIT  CSECT
*        THE PURPOSE OF THIS ROUTINE IS TO PUT OUT A MSG TO THE USER
*        INFORMING HIM OF A PROGRAM BUG AND TO CONTACT THE VENDOR
*         REGISTER CONTENTS UPON ENTRY ARE:
*         R1=ADDR OF THE PIE CONTROL BLOCK
*         R2-R12 UNCHANGED FROM THE PROGRAM
*         R13=ADDR OF THE SAVE AREA FOR MAIN PROGRAM
*         R14=RETURN ADDR TO CONTROL PROG, R15=A(SPIEXIT)
*        REGISTER CONVENTIONS DURING THE CSECT:
*         R1=A(PIE),  R2=BASE REGISTER
*         R5=WORK REGISTER AND USED TO PASS THE CC TO MAIN PROGRAM
*         R10-R13=RESTORED AS BASE REGISTERS FOR MAIN PROG
*         R14=RETURN REGISTER, R15=A(SPIEXIT)
*
*        ABENDREG WILL CONTAIN THE EPA CONTENTS OF REGS AT ABEND.
*         WORD 1 CONTAINS THE EPA AT ABEND.
*         R1=A(PIE) WHERE THE PSW,CC AND R14-R2 ARE FOUND IN WORD 2
*         R2-R12 FOLLOW IN WORDS 3 THRU 13.
*
*        THE FORMAT OF THE PIE WHICH IS 32 BYTES (8 WORDS) LONG IS:
*         WORD 1= PICA ADDRESS
*             2-3= PSW (BYTES 7-8 CONTAIN THE COMPLETION CODE)
*             4-8= R14,R15,R0,R1 AND R2
*
         USING *,R15
         STM   R1,R12,ABENDREG+4   STORE R1-R12 IN WORDS 2-13
         CNOP  0,4
         BAL   R2,JUMPSAV6
ABENDREG DS    13F
JUMPSAV6 EQU   *
         USING ABENDREG,R2
         DROP  R15
         L     R13,=A(SAVEAREA)    RESTORE BASE REGISTER R13
         L     R5,=A(BASES)
         LM    R10,R12,0(R5)       RESTORE BASE REGISTERS R10-R12
*        THE PSW IS LOCATED 8 BYTES INTO THE PIE
         MVC   ABENDREG(4),8(R1)     MOVE EPA AT ABEND TO ABENDREG
         MVC   8(4,R1),=A(ABENDMSG)  PLACE RETURN ADDR INTO PSW
*        THE ABEND CODE IS LOCATED 6 BYTES INTO THE PIE
         LH    R5,6(0,R1)     INSERT COMP CODE(1-15) INTO R5
         O     R5,=X'000000C0'    FIX R5 TO CONTAIN 0CX
         DROP  R2
         BR    R14                 RETURN  TO MAIN PROG
         SPACE 2
         LTORG
         TITLE 'CLEAR SCREEN CSECT'
CLRSCRN  CSECT
         USING *,GOREG
         ST    R14,SAVER14     SAVE R14
         STFSMODE ON,INITIAL=YES  FOR VTAM-SET FULLSCREEN MODE ON
         LA    R0,L'TERMCMDS   LOAD LENGTH OF PARAMETER LIST INTO R0
         LA    R1,TERMCMDS  LOAD ADDRESS OF PARAMETER LIST INTO R1
         TPUT  (1),(0),FULLSCR  ERASE SCREEN & POSIT CURSOR
         STFSMODE OFF             FOR VTAM SET FULLSCREEN MODE OFF
         L     R14,SAVER14     LOAD R14
         DROP  GOREG
         BR    R14             RETURN
SAVER14  DS    F
TERMCMDS DC    X'40115D7E1140403CC760003C4F40003CD660003C40400013'
*        TRY ALSO FOR TERMCMDS DC X'27F54011404013'
*        27=ESCAPE, F5=ERASE/WRITE, 40=WCC
         END
