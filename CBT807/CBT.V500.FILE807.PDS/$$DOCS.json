{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20090727173111000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1058148, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 148, "INMBLKSZ": 4096, "INMRECFM": "VBA", "INMDIR": 7, "INMDSNAM": "SBGOLOB.FILE807.DOCS", "INMMEMBR": "SBGOLOB.FILE807.DOCS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1058148, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1058148, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SBGOLOB.FILE807.DOCS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 4096, "DS1LRECL": 148, "DS1RECFM": "VBA", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "090208", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00-'", "DS1LSTAR": "b'\\x00\\x12\\r'", "DS1TRBAL": "b'\\xac\\xca'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f<@\\x00\\x04\\x88\\x90P'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f<@\\x00\\x04\\x88\\x90P'", "b'P\\xf5G@\\x00\\x00\\x03A\\x00\\x00\\x03C\\x00\\x0e\\x00-'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"HFSELECT": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x03\\x00\\x00\\x00\\x96\\x19?\\x00\\x96\\x19?\\x13Q\\x1c\\t\\x1c\\t\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd5\\xd1\\xd3@@@'", "ispf": {"version": "04.03", "flags": 0, "createdate": "1996-07-11T00:00:00", "modifydate": "1996-07-11T13:51:00", "lines": 7177, "newlines": 7177, "modlines": 0, "user": "CN03NJL"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "IEBGENER": {"ttr": 4618, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x02\\x00\\x96\\x19?\\x01\\t \\x8f\\x13'\\x00\\x12\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1996-07-11T00:00:00", "modifydate": "2009-07-27T13:27:02", "lines": 18, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "//CN03NJLG JOB (CN03,SYSP,OD69),'LINDNER.N RM.288',MSGLEVEL=(1,1),\n//             MSGCLASS=H,NOTIFY=CN03NJL,CLASS=M\n//*JOBPARM COPIES=1\n//STEP3   EXEC PGM=IEBGENER\n//SYSUT1    DD DSN=SBGOLOB.FILE807.DOC(HFSELECT),DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2    DD SYSOUT=(M)\n//\n//SYSUT1    DD DSN=CN03NJL.FORMLIB2.LIST,DISP=SHR\n//\n//SYSUT1    DD DSN=SBGOLOB.FILE807.DOCS(SELOPTNS),DISP=SHR\n//\n//          DD DSN=SBGOLOB.FILE807.DOCS(SELMSG),DISP=SHR\n//\n//          DD DSN=SBGOLOB.FILE807.DOCS(SUPRDUMP),DISP=SHR\n//\n//          DD DSN=SBGOLOB.FILE807.DOCS(SELXMPLE),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SELDTEMP": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93 /\\x00\\x93 O\\x103\\x00*\\x00\\xf3\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd5\\xd1\\xd3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-21T00:00:00", "modifydate": "1993-07-23T10:33:00", "lines": 42, "newlines": 243, "modlines": 0, "user": "CN03NJL"}, "text": "                                HFSELECT                JCL and PARM   5-1.1\n\n\n           \u00dd 1\u00a8  The general form of the PARM field for the program  is  as\n                 follows:\n\n                PARM='option\u00ddsuboptions\u00a8\u00dd,keytype=\u00bbkey/class\u00ba\u00a8\u00dd,Y=hexstring\u00a8\n                     \u00dd,B=begin\u00a8\u00dd,E=end\u00a8\u00dd,J=\u00bb\u00dd\u00c6\u00a8count/relation/0\u00ba\u00a8\n                  \u00dd,V\u00ddP\u00a8=(l\u00a3,p\u00a3\u00dd,l\u00a5,p\u00a5\u00a8\u00dd,l\u00b7,p\u00b7\u00a8)\u00a8\n                     \u00dd,L\u00a3,P\u00a3\u00a8\u00dd,L\u00a5,P\u00a5\u00a8\u00dd,L\u00b7,P\u00b7\u00a8'\n\n                Parameters required by HFSELECT, including the options,  are\n           specified in the PARM field and must be entered as shown  in  the\n           detailed description of the PARM  field for each  option.  If  no\n           PARM is coded, the default, PARM='R,1,1', copies the entire input\n           file.\n\n                The  various  parameters  that  may be entered into the PARM\n           field are either positional or keyword parameters. If a parameter\n           is  not  coded,  the comma associated with that parameter must be\n           omitted.  No  blanks are permitted in the PARM except in the key.\n           The PARM field may contain up to 100 bytes including  commas  and\n           internal parentheses.\n\n                The primary selection options and  suboptions are  described\n           briefly in section  5.1  and  5.2  and are described in detail in\n           section 7.  The  remainder  of  the  various  PARM parameters are\n           described in detail in sections 5.3 through 5.9.\n\n           \u00dd2,3\u00a8 See section 6.2.\n\n           \u00dd 4\u00a8  See section 6.1.2.\n\n           \u00dd 5\u00a8  See section 6.1.1 and also note below for EROPT=.\n\n           \u00dd 6\u00a8  See section 6.1.3.\n\n           \u00dd 7\u00a8  This DD statement is required when a dump is desired if the\n                 program ABENDS. However, most ABENDS are intercepted by the\n                 program and short messages describing the ABEND are printed\n                 rather than complete dumps.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SELMSG": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x00\\x93\\x07O\\x00\\x96\\x19?\\x11A\\x07\\x8a\\x07>\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd5\\xd1\\xd3@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1993-03-15T00:00:00", "modifydate": "1996-07-11T11:41:00", "lines": 1930, "newlines": 1854, "modlines": 0, "user": "CN03NJL"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SELOPTNS": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93 \\x0f\\x00\\x96\\x19?\\x11B\\x00K\\x00H\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd5\\xd1\\xd3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-07-19T00:00:00", "modifydate": "1996-07-11T11:42:00", "lines": 75, "newlines": 72, "modlines": 0, "user": "CN03NJL"}, "text": "\n\n                                  HFSELECT\n\n                HFSELECT OPTIONS TO USE FOR VARIOUS FILE FUNCTIONS\n\n\n                                                               OPTION\n            To compare fields in a record                      A\n\n            To compare the same numbered records\n            in two files                                       A\n\n            To select records between ranges of keys           B  P  G\n\n            To select records on IF THEN ELSE logic            C\n\n            To select records about a given key for\n            debugging a program                                D\n\n            To search for given character strings in\n            records or parts of records                        E\n\n            To replace character strings in records\n            or parts of records                                E\n\n            To unduplicate a file                              F\n\n            To create a frequency listing of keys              F\n\n            To select records between ranges of integer keys   G\n\n            To select complete groups of records on keys       K\n\n            To select records from two files on key matches    A  M  T\n\n            To select records from a file on OR logic          O\n\n            To check a file for sequence                       Q\n\n            To copy a file completely or skipping records      R\n\n            To create a test file by random selection          R\n\n            To select records on a single key or key class     S\n\n            To find data sets/members by VTOC searches         V\n\n            To find data sets members by CATALOG searches      V\n\n            To find data sets/members and then call\n            programs using the found data sets/members\n            as input files                                     V\n\n\n                                  HFSELECT\n\n               HFSELECT SUBOPTIONS\n\n            Permit long keys in some options                   L\n\n            Reverse selection logic                            M\n\n            Read tape or VSAM input files backwards            W\n\n               HFSELECT USER EXITS\n\n            Call programs to modify records before             I1-4,Im\n            HFSELECT processing\n\n            Call programs to modify records after\n            HFSELECT processing before outputing to file       O1-2\n\n            Modify HFSELECT program defaults                   X0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SELXMPLE": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01-\\x00\\x00\\x00\\x93\\x07O\\x00\\x96\\x19?\\x11A\\x0bS\\x12\\xb8\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd5\\xd1\\xd3@@@'", "ispf": {"version": "01.45", "flags": 0, "createdate": "1993-03-15T00:00:00", "modifydate": "1996-07-11T11:41:00", "lines": 2899, "newlines": 4792, "modlines": 0, "user": "CN03NJL"}, "text": "\n\n\n\n\n\n\n\n           HH  HH  FFFFFF   SSSS   EEEEEE  LL      EEEEEE   CCCC   TTTTTT\n           HH  HH  FFFFFF  SSSSSS  EEEEEE  LL      EEEEEE  CCCCCC  TTTTTT\n           HH  HH  FF      SS   S  EE      LL      EE      CC   C    TT\n           HH  HH  FF      SS      EE      LL      EE      CC        TT\n           HH  HH  FF      SS      EE      LL      EE      CC        TT\n           HHHHHH  FFFFFF   SS     EEEEEE  LL      EEEEEE  CC        TT\n           HHHHHH  FFFFFF    SS    EEEEEE  LL      EEEEEE  CC        TT\n           HH  HH  FF         SS   EE      LL      EE      CC        TT\n           HH  HH  FF         SS   EE      LL      EE      CC        TT\n           HH  HH  FF     S   SS   EE      LL      EE      CC   C    TT\n           HH  HH  FF     SSSSSS   EEEEEE  LLLLLL  EEEEEE  CCCCCC    TT\n           HH  HH  FF      SSSS    EEEEEE  LLLLLL  EEEEEE   CCCC     TT\n\n           EEEEEE  XX  XX AAAAAAA  MMM  MM PPPPPP  LL      EEEEEE   SSSS\n           EEEEEE  XX  XX AAAAAAA  MMMMMMM PPPPPP  LL      EEEEEE  SSSSSS\n           EE       XXXX  AA   AA  MM M MM PP   P  LL      EE      SS   S\n           EE       XXXX  AA   AA  MM   MM PP   P  LL      EE      SS\n           EE        XX   AA   AA  MM   MM PPPPPP  LL      EE      SS\n           EEEEEE    XX   AAAAAAA  MM   MM PPPPP   LL      EEEEEE   SS\n           EEEEEE    XX   AAAAAAA  MM   MM PP      LL      EEEEEE    SS\n           EE       XXXX  AA   AA  MM   MM PP      LL      EE         SS\n           EE       XXXX  AA   AA  MM   MM PP      LL      EE         SS\n           EE      XX XX  AA   AA  MM   MM PP      LL      EE     S   SS\n           EEEEEE  XX  XX AA   AA  MM   MM PP      LLLLLL  EEEEEE SSSSSS\n           EEEEEE  XX  XX AA   AA  MM   MM PP      LLLLLL  EEEEEE  SSSS\n\n\n\n\n                                                      RELEASE  4.3  07/12/93\n\n                                                               MORRIS KARLIN\n                                                              NORMAN LINDNER\n\n                                                        EDITED BY L. KAUFMAN\n\n\n     (C) COPYRIGHT SEPT 1981 BY M. KARLIN, N. LINDNER, I. EISENSTEIN\n\n\n\n                                  HFSELECT\n                                                         FUNCTIONS   i\n\n                HFSELECT OPTIONS TO USE FOR VARIOUS FILE FUNCTIONS\n\n                                                               OPTION\n\n            To compare fields in a record                      A\n\n            To compare the same numbered records\n            in two files                                       A\n\n            To select records between ranges of keys           B  P  G\n\n            To select records on IF THEN ELSE logic            C\n\n            To select records about a given key for\n            debugging a program                                D\n\n            To search for given character strings in\n            records or parts of records                        E\n\n            To replace character strings in records\n            or parts of records                                E\n\n            To unduplicate a file                              F\n\n            To create a frequency listing of keys              F\n\n            To select records between ranges of integer keys   G\n\n            To select complete groups of records on keys       K\n\n            To select records from two files on key matches    A  M  T\n\n            To select records from a file on OR logic          O\n\n            To select records on key class                     C  D  O  S\n\n            To check a file for sequence                       Q\n\n            To copy a file completely or skipping records      R\n\n            To create a test file by random selection          R\n\n            To select records on a single key or key class     S\n\n            To find data sets/members by VTOC searches         V\n\n            To find data sets/members by CATALOG searches      V\n\n            To find data sets/members and then call\n            programs using the found data sets/members\n            as input files                                     V\n\n\n                                  HFSELECT\n                                                         FUNCTIONS  ii\n\n               HFSELECT SUBOPTIONS\n\n            Permit long keys in some options                   L\n\n            Reverse selection logic                            M\n\n            Read tape or VSAM input files backwards            W\n\n               HFSELECT USER EXITS\n\n            Call programs to modify records before             I1-4,Im\n            HFSELECT processing\n\n            Call programs to modify records after\n            HFSELECT processing before outputing to file       O1-2\n\n            Modify HFSELECT program defaults                   X0\n\n\n\n                                 HFSELECT                       CONTENTS  ii\n\n                           TABLE OF EXAMPLES\n                                                                               PAGE\n\n       A1- Select records if field A is greater than field B                   A-1\n       A2- Select changed records from an updated file                         A-1\n       A3- Copy a file and also print the records (in one step)                A-1\n       A4- Select records if date X (mmddyy) is earlier or same as date y      A-2\n                  (yymmdd)\n       A5- Match two files, record for record, and output matching and         A-2\n                  non-matching records of both files\n       A6-Create a sequential copy of a PDS with a member name appended to     A-3\n                  each record\n       A1- Copy two separate files in a single step                            A-4\n       B1- Select records within ranges of dates                               B-1\n       B2- Select records within ranges of numbers                             B-1\n       B3- Select records not in ranges of numbers                             B-2\n       B4- Select records on ranges defined by two different fields            B-2\n       C1- Select records if (field A equals X) or (field A  equals Y and      C-1\n                  field B equals Z)\n       C2- Select records if (field A equals X and field B equals Y) or        C-1\n                  (field A does not equal X and field C equals Z)\n       C3- Select records if (field A is numeric and field B equals Y) or      C-2\n                  (field A is not numeric and field B equals Z)\n       C4- Select records if field A is not equal to X and field C equals Y    C-2\n       C5- Select records if field A equals X (the length of field A is        C-3\n                  greater than 20)\n       D1- Select records  around  A  record with non-numerics in a numeric    D-1\n                  field\n       D2- Select records after a specific packed key                          D-1\n       D3- Select records before a specific hex key                            D-1\n       D4- Select all records after a given key (near the end of the file)     D-2\n       E1- Separate JCL from data in a library containing JCL members          E-1\n       E2- Select records containing certain keys anywhere  in  a specified    E-1\n                  area of the record\n       E3- Find all 'GO TO' statements in a COBOL program                      E-2\n       E4- Search a documentation data set for all lines that extend beyond    E-2\n                  margins\n       E5- Produce a directory listing of the members in a source library      E-2\n                  that are COBOL programs\n       E6- Perform a string replacement in a file                              E-3\n       E7- Perform a string replacement in all members of a PDS                E-3\n       E8- Perform a string replacement only on selected records in a PDS      E-4\n       E9- Perform an in-place string replacement in members of a PDS          E-4\n       F1- Unduplicate a file on case number                                   F-1\n       F2- Generate a two-dimensional statistical cross table by sex and       F-1\n                  year of birth\n       F3- Unduplicate a  file or list the number of occurrences of each key   F-2\n                  in a file. This example contains outputs of the F option\n                  using various values of n in the J=n parameter\n       F4- Unduplicate a descending ordered tape file on a key field larger    F-3\n                  than 20 bytes\n\n\n                                 HFSELECT                       CONTENTS  ii\n\n                           TABLE OF EXAMPLES\n                                                                               PAGE\n\n       F5- Generate a frequency report on a frequency listing                  F-3\n       F6- Convert a variable length file to fixed format to produce           F-4\n                  a frequency list of RDWs\n       F7- Encrypt a field on every record of a file                           F-5\n       G1- Select 5 records for each MANHATTAN zip code (10000 thru 10099)     G-1\n       G2- Select case numbers within ranges and print frequency               G-1\n                  distribution  of case numbers\n       G3- Same as  example G2 but the case numbers are not zero filled        G-2\n       G4- Generate a key file                                                 G-2\n       K1- Generate a test file of 30 groups of master/slave records, each     K-1\n                  group having the same key\n       K2- Group select with B=begin  and E=end parameters                     K-1\n       M1- Select records against a key file                                   M-1\n       M2- Select a given number of records that do not match any key in a     M-1\n                  key file\n       M3- Select all records not matching keys in a key file                  M-1\n       M4- Select from  two  files, records  that match on specified fields    M-2\n       M5- Match two files on a selected field. select n records for each key. M-3\n                 this example has a list of outputs for various values of n\n       M6- Match an ISAM file against a variable record length file on         M-4\n                  several fields. Begin and end the match at selected\n                  numbered records\n       M7- Match two files on numeric fields where one field is packed and     M-4\n                  the other is zoned\n       M8- Match two files and produce a merged matched output file            M-5\n       O1- Select records if any one of three fields match a specified key     O-1\n                  for that field\n       O2- Select records on a class type in one field or with a given key     O-1\n                  in a second field\n       O3- Select records on 'nand' logic in three separate fields             O-1\n       O4- Select records if any one of three fields matches a key specified   O-2\n                  for that field\n       P1- Select records with a mmddyy date field having values between       P-1\n                  giveen ranges of dates\n       P2- Select records with a field having values between multiple          P-1\n                  ranges\n       P3- Select records  with  a  field  not in specified ranges             P-2\n       P4- Encrypt a field on every record of a file                           P-2\n       Q1- Check for ascending sequence of a file on concatenated fields       Q-1\n       Q2- Check for descending sequence of a file on a field longer than 20   Q-1\n                  bytes. Output the in-sequence and out-of-sequence records\n       Q3- Same as example Q2 except output the records in ascending order     Q-1\n       Q4- Check for ascending sequence of a file. Change   the collating      Q-1\n                  sequence  of certain characters while checking\n       Q5- Check for ascending sequence of a file. A listing of the two        Q-2\n                  output files is shown for a given input file\n       R1- Select every  kth record in range one, every lth record in range    R-1\n                  two and every mth record in range three\n\n\n                                 HFSELECT                       CONTENTS iii\n\n                           TABLE OF EXAMPLES\n                                                                               PAGE\n\n       R2- Select records with a different skip factor in each of three        R-1\n                  ranges\n       R3- Select records from a file by their relative record numbers         R-2\n       R4- Copy a file                                                         R-2\n       R5- Select records at random using the default seed supplied by the     R-2\n                  program\n       R6- Select records  at random using a user specified seed               R-3\n       R7- Delete every nth record from a file                                 R-3\n       R8- Convert a non-sequential file to a sequential file                  R-3\n       R9- Select the  last n records from a tape file                         R-4\n       R10- Count the number of records in a file                              R-4\n       R11- Generate a table of random numbers                                 R-4\n       R12- Copy selected PDS members to a PDS file                            R-5\n       R13- Convert a sequential/ISAM file to VSAM                             R-5\n       R14- Select the first and last record of a file                         R-5\n       S1- Select records that do not have zero in a given field               S-1\n       S2- Select records  that  have  any one of five  different characters   S-1\n                  in a given 1-byte field\n       S3- Select records that have non-alphabetic characters in a given       S-1\n                  field\n       S4- Select records that have binary zeros in three fields               S-2\n       S5- Delete records  with  high values in a given field                  S-2\n       S6- Count all records with a given value in one field  and another      S-2\n                  specified value in a second field\n       S7- Select all records with a specified number in a binary/packed       S-3\n                  field\n       S8- Select records with values in a packed field greater than a         S-3\n                  specified number\n       S9- Select records based on four  or  more select fields                S-3\n       T1- Select records with any of  five different values in a given        T-1\n                  field\n       T2- Select records by multiple and/or logic                             T-1\n       T3- Select records that do not have any of several different values     T-2\n       T4- Select records from one file that match any record in another file  T-2\n       V1- List all user01 files on volume applda                              V-1\n       V2- List all SOURCE.COBOL files on multiple volumes                     V-1\n       V3- List member directories of multiple PDSs, selecting members         V-1\n                  created after a given date\n       V4- List all dataset names prefixed with USERxx on all volumes that     V-2\n                  start with WORK\n       V5- Create a file of 100 names each of:                                 V-2\n                  datasets with prefix USERxx\n                  names of files that contain the string 'SOURCE'\n       V6- Create a file containing the names of every dataset and every       V-2\n                  member of every PDS on every mounted volume in the system\n       V7- List members of a PDS that have aliases                             V-3\n\n\n                                 HFSELECT                       CONTENTS  iv\n\n                           TABLE OF EXAMPLES\n                                                                               PAGE\n\n       V8- List all catalogued datasets with the prefix USER001, or            V-3\n                  beginning with PROD.HFS\n       V9- List all statements containing a given string in multiple PDSs      V-4\n       V10- List all SORTOUT JCL statements together with the four records     V-4\n                   following each occurrence in multiple libraries\n       V11- List members with specified names in multiple libraries via a      V-4\n                   VTOC search\n       V12- List members with specified names in multiple libraries via a      V-4\n                   catalog search\n       V13- Create a file containing the first n records from each member of   V-5\n                   a pds\n       V14- Copy all non-VSAM data sets from one DASD to another               V-5\n       V15- Copy non-VSAM data sets with specified generic names to            V-6\n            another pack. Catalog the new data sets and uncatalog the\n            old\n       V16- Compress all data sets with given prefixes                         V-6\n       V17- Copy six data sets on a volume with a generic prefix and           V-7\n            an LRECL=80\n       V18- Copy all PDS data sets with given prefixes to another              V-7\n            volume using the IBM utility IEBCOPY\n       TSO1- Copy a file                                                     TSO-1\n       TSO2- Perform  example M5 on-line                                     TSO-1\n         X1- Invoke an input and an output user exit                           X-1\n         X2- Sample COBOL exit program - fixed length records                  X-1\n         X3- Sample COBOL exit program - variable length records               X-2\n         X4- Sample ASSEMBLER exit program                                     X-2\n\n                                HFSELECT EXAMPLES               Preface    v\n\n           All  examples coded  in  this  manual  are  assumed  to  use  the\n           following PROC:\n\n           //HFSELECT PROC\n           //S1     EXEC  HFSELECT\n           //SYSPRINT  DD  SYSOUT=*,DCB=BLKSIZE=133   PROGRAM MESSAGES\n           //SYSOUT    DD  SYSOUT=*                   SYSTEM MESSAGES\n           //SYSOUX    DD  SYSOUT=*                   RANDOM NUMBER TABLES\n\n                The following examples demonstrate the various options\n           of HFSELECT. See the HFSELECT Reference Guide  for complete\n           descriptions of the HFSELECT options.\n\n\n                                HFSELECT EXAMPLES                   PAGE A-1\n\n           EXAMPLE A1\n\n           Select  all records from TEST.FILE1 whose six position date field\n           starting  in  position 10 is greater than the date field starting\n           in data position 30. The file is on tape.\n\n           //STEPA1 EXEC  HFSELECT,PARM='A,J=GT,V=(6,30),6,10'\n           //SYSUT1  DD  DSN=TEST.FILE1,UNIT=T6250,DISP=OLD,VOL=SER=111111\n           //SYSUT2  DD  DSN=TEST.FILE2,UNIT=T6250,DISP=(,KEEP)\n\n           Note:  the  JCL  is  identical  for  fixed and for variable RECFM\n           files.  Also, since we are comparing a file against itself, SYSIN\n           has not been coded.\n\n           EXAMPLE A2\n\n           A  disk file has been updated by incrementing a 50 position field\n           starting  in position 200. Print the changed records from the new\n           file  in character  and  HEX format and put out the corresponding\n           records  from  the old file. Start the selection at record 10 and\n           end the selection at record 500.\n\n           //STEPA2 EXEC HFSELECT,PARM='AL,E=500,B=9,J=NE,V=(50,200),50,200'\n           //*A2 EXEC HFSELECT,PARM='ANL,B=9,E=500,V=(50,200),50,200'\n           //*  THE TWO EXEC STATEMENTS ARE EQUIVALENT SINCE THE\n           //*  J= DEFAULT WITH THE N SUBOPTION IS NE.\n           //SYSUT1  DD  DSN=DISK.FILE1,DISP=SHR          OLD FILE\n           //SYSIN   DD  DSN=DISK.FILE2,DISP=SHR          NEW FILE\n           //SYSUT2  DD  DSN=DISK.FILE3,parameters   OUTPUT FROM OLD FILE\n           //SYSUT4  DD  SYSOUT=*,DCB=RECFM=A  PRINT IN CHARACTER AND HEX\n           //*                                        FROM NEW FILE\n\n           The L suboption must be used since the selection field is greater\n           than  20 characters long. B=9 starts the selection at record pair\n           10  and  E=500  stops  the selection at record 500. Since neither\n           SYSUT3  nor  SYSUT5 were coded, the program stops after the 500th\n           record pair is tested.\n\n           EXAMPLE A3\n\n           Copy  a  disk  file  to  tape  and  also print out the records in\n           character and HEX format.\n\n           //STEPA3  EXEC HFSELECT,PARM='A,J=EQ,V=(1,1),1,1'\n           //*STEP2 EXEC HFSELECT,PARM='A,V=(1,1),1,1'\n           //* THE TWO EXEC STATEMENTS GIVE THE SAME RESULT SINCE\n           //* THE J= DEFAULT IS EQ.\n           //*STEP3 EXEC HFSELECT,PARM='A,J=**,V=(1,1),1,1'\n           //* THIS ALSO GIVES THE SAME RESULT SINCE ** FORCES ALL RECORDS OUT\n           //SYSUT1   DD  DSN=DISKFILE,DISP=SHR\n           //SYSIN    DD  DSN=*.SYSUT1,DISP=SHR\n           //SYSUT2   DD  DSN=TAPEFILE,UNIT=T6250,DISP=(,KEEP)\n           //*            THIS IS THE TAPE OUTPUT FILE.\n           //SYSUT4   DD  SYSOUT=*,DCB=RECFM=A\n           //*            THIS IS THE PRINTOUT OF THE FILE\n\n                                HFSELECT EXAMPLES                   PAGE A-2\n\n\n           Note:  SYSIN  was coded even though it is the  same  data  set as\n           SYSUT1,  in order to produce the SYSUT4 file. Since the same file\n           is  used  for SYSUT1 and SYSIN, specifying the same record select\n           fields  for  each  file causes a match to occur automatically for\n           each  record.  Only  the  first  byte  of each record was used to\n           maximize  efficiency. SYSUT2 and SYSUT4  are  identical as SYSUT3\n           and SYSUT5 would be if they were coded.\n\n\n           EXAMPLE A4\n\n           Select from a file all records whose date in field A is less than\n           or  equal to the date in field B. The format of field A is MMDDYY\n           starting in byte 150. The format of field B is YYMMDD starting in\n           byte 8000.\n\n           //STEPA4 EXEC HFSELECT,PARM='A,J=LE,V=(6,8000),2,154,2,150,2,152'\n           //SYSUT1 DD DSN=SAMEFILE,DISP=SHR\n           //SYSUT2 DD DSN=OUTFILE,DISP=(NEW,KEEP),SPACE=(TRK,30),UNIT=SYSDA\n\n\n           EXAMPLE A5\n\n           Two  payroll  files  are  to  be compared, record for record, for\n           equality  on the first 100 bytes. The first file is fixed blocked\n           sequential  with  an  LRECL  of  100. The second file is variable\n           blocked  ISAM.  Output the matching and non-matching records from\n           ISAMFILE  to  SYSUT2 and SYSUT3 respectively. Output the matching\n           and   non-matching  records  from  SYSIN  to  SYSUT4  and  SYSUT5\n           respectively.\n\n           //STEPA5 EXEC HFSELECT,PARM='AL,V=(100,1),100,1'\n           //ISAMFILE DD DSN=ISAMPAY,UNIT=SYSDA,DISP=(OLD,KEEP),\n           //  DCB=(RECFM=VB,LRECL=124,BLKSIZE=12960)\n           //SYSIN    DD DSN=SEQPAY,UNIT=T6250,DISP=(OLD,KEEP),\n           //   DCB=(RECFM=FB,LRECL=100,BLKSIZE=30000)\n           //SYSUT2  DD  DSN=MATCHED.PAY,DISP=(NEW,KEEP),UNIT=SYSDA,\n           //   DCB=(RECFM=V,LRECL=124,BLKSIZE=128),\n           //   SPACE=(CYL,(5,1),RLSE,)\n           //SYSUT3  DD  DSN=NONMATCH.PAY,DISP=(,CATLG,DELETE),\n           //   DCB=(RECFM=VB,LRECL=124,BLKSIZE=24804),\n           //   UNIT=TAPE9,LABEL=(,SL,RETPD=60)\n           //SYSUT4  DD  DSN=MATCHED.SYSIN,DISP=(MOD,KEEP),UNIT=DISK,\n           //   DCB=(RECFM=F,LRECL=100,BLKSIZE=100),\n           //   SPACE=(TRK,(100,10),RLSE)\n           //SYSUT5   DD DSN=NONMATCH.SYSIN,DISP=(NEW,KEEP),\n           //   DCB=(RECFM=FBS,LRECL=100,BLKSIZE=13000),\n           //   UNIT=3330,SPACE=(CYL,(3,1))\n\n                                HFSELECT EXAMPLES                   PAGE A-3\n\n\n                All  four  output files are sequential datasets  even though\n           the  primary  input file is ISAM. The LRECL and the record format\n           type (F,V) of each output file must be the same as the input file\n           from which it was created. The BLKSIZE of the output files may be\n           any value which meets the operating system requirements.\n\n                Input  file DCB information is not required in the JCL if it\n           can  be  obtained from any other source. Output file DCB is never\n           required  unless  the BLKSIZE is to differ from that of the input\n           file  from  which  it  is  derived  which may require a change in\n           RECFM (from F to FB, VB to V, etc).\n\n                The L suboption is used  since  the  record  select field is\n           greater than 20 bytes.\n\n           EXAMPLE A6\n\n           Create a sequential copy of  a  PDS and append to each record its\n           member name. The PDS LRECL=80.\n\n           //STEPA6A EXEC HFSELECT,PARM='R,1,1'\n           //* first create a file containing only member names for each\n           //* record in the PDS\n           //LIBFILE  DD  DSN=FILE.PDS,DISP=SHR\n           //MEMBNAME DD  DSN=&&MEMBNAME,DISP=(,PASS),SPACE=(TRK,5),\n           //  DCB=BLKSIZE=800,UNIT=SYSDA\n           //*\n           //STEPA6B EXEC HFSELECT,PARM='A,J=**,V=(1,1),1,1'\n           //* merge the PDS with the corresponding member name\n           //LIBFILE  DD  DSN=FILE.PDS,DISP=SHR\n           //SYSIN    DD  DSN=&&MEMBNAME,DISP=(OLD,DELETE)\n           //MERGE    DD  DSN=MERGED.FILE,DCB=(LRECL=88,BLKSIZE=8800)\n\n           NOTE: The J=** parameter is used in STEPA6B  to  cause records on\n           the LIBFILE and SYSIN  file  to  be  selected regardless of their\n           relationship. The position and length parameters must be coded in\n           the PARM only because the  syntax  of the A option requires them.\n           Coding 1,1 for the  l,p pairs  maximizes  the  efficiency  of the\n           program when J=** is coded.\n\n                                HFSELECT EXAMPLES                        A-4\n\n\n           EXAMPLE A7\n\n           Make copies of two separate files in one step. The output files\n           are preallocated.\n\n           //STEPA7 EXEC HFSELECT,PARM='A,J=**.V=(1,1),1,1'\n           //SYSUT1   DD DSN=INFILE1,DISP=SHR\n           //SYSUT2   DD DSN=OUTFILE1,DISP=OLD     COPY OF INFILE1\n           //SYSIN    DD DSN=INFILE2, DISP=SHR\n           //SYSUT4   DD DSN=OUTFILE2,DISP=OLD     COPY OF OUTFILE2\n\n\n                                HFSELECT EXAMPLES                        B-1\n\n\n           EXAMPLE B1\n\n           Select all records with values in a date field that are less than\n           Dec  21,1976,  or  are  between June 16,1978 and September 5,l978\n           inclusive, or are equal to or greater than March 4,l980. The date\n           field  is  in the format yymmdd starting in position 25. The file\n           is  in  EBCDIC order on this field. Skip the first 49 records and\n           stop  selecting  after  the  2000th record. The output file is to\n           have the same DCB as the input file.\n\n           //STEPB1 EXEC HFSELECT,PARM='B,B=49,E=2000,6,25,6,25'\n           //SYSUT1   DD DSN=INFILE,DISP=SHR\n           //SYSUT2   DD DSN=OUTFILE,DISP=(NEW,KEEP),UNIT=T6250,\n           //            LABEL=RETPD=60\n           //SYSIN    DD *\n           LOW VALUES\n           761220\n           780616\n           780905\n           800304\n           /*\n\n           Note  that  no  DCB  need  be specified for SYSUT2. A key of high\n           values,  of length 6, is appended to SYSIN since SYSIN has an odd\n           number of keys.\n\n\n           EXAMPLE B2\n\n           Select from the input file records whose key select field (length\n           5 starting in position 15) is in the following ranges:\n\n                          10 \u00f0 select field \u00f0 200\n\n                         350 \u00f0 select field < 3000\n\n                            5000 \u00f0 select field\n\n           Select 50 records for each range. The file is ISAM.\n\n           //STEPB2 EXEC  HFSELECT,PARM='B,J=50,5,15,5,15'\n           //ISAMFILE DD  DSN=ISFILEIN,DISP=SHR\n           //SYSUT2 DD DSN=SEQOUT,DISP=(,KEEP),UNIT=SYSDA,SPACE=(TRK,(5,2))\n           //SYSIN  DD   *,DCB=BLKSIZE=80\n           00010\n           00200\n           00350\n           02999\n           05000\n           /*\n\n           A key of high values of length 5 is appended to SYSIN.\n\n                                HFSELECT EXAMPLES                   PAGE B-2\n\n\n           EXAMPLE B3\n\n           Select  from  the  input  file all records whose key select field\n           (length  5  starting  in  position  15)  is  NOT in the following\n           ranges:\n\n                          10 < select field  < 200\n                         350 < select field \u00f0 3000\n                        5000 \u00f0 select field\n\n           //STEPB3 EXEC  HFSELECT,PARM='BN,5,15,5,15'\n           //SYSUT1 DD DSN=INFILE,DISP=SHR\n           //SYSUT2 DD DSN=FILOUT,DISP=(,KEEP),UNIT=SYSDA,SPACE=(TRK,(5,2))\n           //SYSIN  DD   *,DCB=BLKSIZE=80\n           00011\n           00199\n           00351\n           03000\n           05000\n           /*\n\n           A key of high values of length 5 is appended to SYSIN.\n\n                                HFSELECT EXAMPLES                   PAGE B-3\n\n           EXAMPLE B4\n\n           Select  all  persons  from  an employee file whose age is greater\n           than  20  and  whose  salary is less than $20,000, and also those\n           whose  age  is  greater  than  45  and  whose salary is less than\n           $40,000.  Age  is in bytes 10 and 11 and salary begins in byte 50\n           for a length of 5 bytes.\n\n           The employee file must be sorted on salary within age.\n\n           //STEPB4 EXEC  HFSELECT,PARM='B,2,10,5,50'\n           //SYSUT1  DD   DSN=EMPLOYEE.FILE,DISP=SHR\n           //SYSUT2  DD   DSN=OUTFILE,DISP=(NEW,KEEP),UNIT=T6250,LABEL=RETPD\n           //SYSIN   DD   *\n           20\n           20000\n           45\n           40000\n           /*\n           //\n\n           In  this  example,  no high values key is appended to SYSIN since\n           SYSIN has an even number of keys.\n\n           NOTE: Although in the examples for the B option, all the keys  in\n           SYSIN are listed as numerals, they are treated as characters.  The\n           comparison utilizes the  8-bit binary sequence from '00000000'  to\n           '11111111'.\n\n\n                                HFSELECT EXAMPLES                   PAGE C-1\n\n                EXAMPLE C1\n\n                Select  all records with 01 in positions 1 and 2, or with 00\n           in  positions  1  and 2 and JAN80 in positions 10 through 14. The\n           JCL is\n\n           //STEPC1  EXEC  HFSELECT,PARM='C,2,1,5,10,2,1'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Output file of selected records\n           //SYSIN     DD  *,DCB=BLKSIZE=80\n           00\n           JAN80\n           01\n           /*\n\n           EXAMPLE C2\n\n                Select from an input file all records that are inactive with\n           a  closing date of Jan 1,1981, or that are active with an opening\n           date of December 31,1980. The file is VSAM.\n\n                The  activity  indicator  is one byte in position 50 and the\n           code  for 'active' = 1. The opening date is a 6 byte field of the\n           form  MMDDYY  starting  in  position 272. The closing date is a 6\n           byte  field  of the form MMDDYY starting in position 280. The JCL\n           required is\n\n           //STEPC2 EXEC  HFSELECT,PARM='C,1,50,6,272,6,280'\n           //STEPCAT  DD  DSN=catalog,DISP=SHR\n           //VSAMFILE DD  DSN=VSAMFILE,DISP=SHR\n           //SYSUT2   DD  DSN=OUTPUT,DCB=(RECFM=VB,LRECL=input file lrecl+4,\n           //      BLKSIZE=10*lrecl),parameters\n           //*  NOTE THAT SYSUT2 IS A SEQUENTIAL FILE\n           //SYSIN    DD   *\n           1\n           123180\n           010181\n           /*\n\n\n                                HFSELECT EXAMPLES                   PAGE C-2\n\n\n           EXAMPLE C3\n\n                A  personnel  file  contains  records of both managerial and\n           non-managerial employees. The managerial employees are designated\n           by  a  two  digit  zoned  decimal  number in bytes 10 and 11. The\n           non-managerial  employees  are  designated  by  a  two  character\n           alphabetic  code in these positions. A work location code for all\n           employees  is  in  bytes  50  through  53.  Select all managerial\n           employees  in  location  A641 and all non-managerial employees in\n           location B371.\n\n           //STEPC3  EXEC  HFSELECT,PARM='C,2,11,4,50,4,50'\n           //SYSUT1    DD  DSN=PERSONEL.FILE,DISP=SHR\n           //SYSUT2    DD  DSN=PERSONEL.OUTPUT,DISP=OLD\n           //SYSIN     DD  *\n           CLASS=N\n           A641\n           B371\n           /*\n           //\n\n           The  length  2,  position  11  refers  to the class key type.\n\n           EXAMPLE C4\n\n           Select  from  the  primary input file all records that have 05 in\n           positions 1 and 2 and do not have F in position 100.\n\n           //STEPC4  EXEC HFSELECT,PARM='C,1,100,1,100,2,1'\n           //SYSUT1    DD Input file\n           //SYSUT2    DD Output file of selected records\n           //SYSIN     DD *\n           F                          KEY A\n           Z                          KEY B\n           05                         KEY C\n           /*\n\n                                                     _\n           Note that the logic of the C option is AB+AC ((A AND B) OR (NOT A\n           AND  C)).  If  keys  A  and  B  refer  to the same field but have\n           different  values,  AB  (A AND B) can never be true since a field\n           cannot  have two values at the same time. Therefore, selection is\n           on (NOT A AND C) only.\n\n\n                                HFSELECT EXAMPLES                   PAGE C-3\n\n\n           EXAMPLE C5\n\n           Select  all  records  with  an  address  of 124-126 EAST HAVILAND\n           STREET  in  an address field beginning in byte 51 for a length of\n           40.\n\n           //STEPC5   EXEC HFSELECT,PARM='C,20,51,20,71,20,51'\n           //SYSUT1     DD Input address file\n           //SYSUT2     DD Selected address file\n           //SYSIN      DD *\n           124-126 EAST HAVILAN\n           D STREET\n           124-126 EAST HAVILAN\n           /*\n\n                                                                _\n           The  basic  logic  of  the  C  option, which is AB + AC, has been\n           changed  to  AB  by  setting key C equal to key A and referencing\n           them  to  the same field, thus preventing (NOT A AND C) from ever\n           being  true.  Since each key in this option can be 20 bytes long,\n           the effective key length for selection can be up to 40 characters\n           by concatenating keys A and B. This is equivalent to the S option\n           with  2  L,P pairs, but with a total select field length extended\n           to 40 characters (instead of 20).\n\n\n                                HFSELECT EXAMPLES                   PAGE D-1\n\n\n                EXAMPLE D1\n\n                Find the first occurrence, if any, of a non-numeric value in\n           a  field defined as numeric. The field is of length 4 starting in\n           byte  50.  Print  in character and HEX format five records before\n           the  non-numeric  record, the record itself, and the five records\n           after the record.\n\n                The field is zoned numeric signed or unsigned.\n\n           //STEPD11  EXEC  HFSELECT,PARM='DN,C=N,J=5,4,50'\n           //SYSUT1     DD  Input file\n           //SYSUT2     DD  SYSOUT=*,DCB=RECFM=A\n\n                The field is packed numeric.\n\n           //STEPD12  EXEC  HFSELECT,PARM='DN,C=P,J=5,4,50'\n           //SYSUT1     DD  Input file\n           //SYSUT2     DD  SYSOUT=*,DCB=RECFM=A\n\n\n                EXAMPLE D2\n\n                Select  the  fifth  occurrence  of  a record with the number\n           -21376.42  in  a  packed field, and print this record and the ten\n           records  following this record in character and HEX. The field is\n           of length 5 starting in position 15.\n\n           //STEPD2  EXEC  HFSELECT,PARM='D,P=-2137642,J=+10,5,15'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  SYSOUT=*,DCB=RECFM=A\n           //EXITS     DD  *\n           X0\n            DOPTION=OPTIMIZE,5\n           //\n\n           Note: See Appendix  D.2.9  for  a  description  of  the  DOPTION\n                 parameter of the X0 initialization exit to begin selection\n                 processing at other than the first key matched record.\n\n                EXAMPLE D3\n\n                Select  the  first  occurrence of the hexstring 9496\n           and  the five records preceeding it. The field starts in position\n           30 for a length of six bytes. Print out the records.\n\n           //STEPD3 EXEC HFSELECT,PARM='D,X=949699998982,J=-5,6,30'\n           //SYSUT1   DD Input file\n           //SYSUT2   DD SYSOUT=*,DCB=RECFM=M\n\n                The  records  will  be printed  out with ruler lines.\n\n\n                                HFSELECT EXAMPLES                   PAGE D-2\n\n\n                EXAMPLE D4\n\n                Select from  a  tape  file  of  1,000,000 records, with keys\n           numbered sequentially from 000001 to 1000000, the record with key\n           999940  and the remaining records in the file. The keys are zoned\n           numeric,  unsigned,  starting  in  position  1 with a length of 7\n           bytes.\n\n           //STPD41 EXEC HFSELECT,PARM='DW,K=0999940,J=-65,7,1'\n           //*              OR\n           //*STPD42 EXEC HFSELECT,PARM='DW,N=999940,J=-70,7,1'\n           //*              OR\n           //*STPD43 EXEC HFSELECT,PARM='D,K=0999940,J=+60,7,1'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Output file\n           //\n\n                The  three  EXECute  statements above all select the same 61\n           records. The first two use the W suboption, reading the tape file\n           backwards for speed of execution since the desired records are at\n           the  end  of  the  file. The records for these two statements are\n           output in reverse order from the input file order.\n\n                The  minus  sign  is  used in the J= parameter for these two\n           statements since the end of file records occur before the desired\n           record in the backwards read.\n\n                A  count  of  60  or  greater  ensures  that  records 999941\n           through  1000000  which follow the desired record are put out.\n\n                If K= is used, a character compare is done by the program so\n           the  leading  zero  must be included in the key. If N= is used, a\n           numeric comparison is performed so no leading zero is necessary.\n\n                In all cases of the D option, all records of the input file,\n           from the first record on the file up to the record preceding  the\n           first one output to SYSUT2, are output to SYSUT3 if it is coded.\n\n\n                                HFSELECT EXAMPLES                   PAGE E-1\n\n\n                EXAMPLE E1\n\n                Select and print out from a TSO data set all the JCL records\n           except the data delimiters. Print to SYSUT3 all the data records.\n           Put  the delimiters in SYSUT3 so that the separation of the  data\n           groups is shown.\n\n           //STEPE1 EXEC HFSELECT,PARM='E,1,9'\n           //LIBFILE  DD DSN=SO11NJL.TSO,DISP=SHR\n           //SYSUT2   DD SYSOUT=*    JCL PRINTOUT\n           //SYSUT3   DD SYSOUT=* DATA AND DELIMITER PRINTOUT\n           //SYSIN    DD *\n           A//A\n           C/*ROUTEC\n           X/*OUTPUTX\n           !/*JOBPARM!\n           B/*MESSAGEB\n           A/*SETUPA\n           /*\n\n           /* in the first two columns, if followed by certain keywords such\n           as  ROUTE,  SETUP,  etc.,  are  HASP  (JES) control cards and are\n           considered JCL in this example.\n\n\n                EXAMPLE E2\n\n                Select  from  a  sequential  file all records with the names\n           SMITH,  JONES,  or  DOE  in  the  fifteen  byte field starting in\n           position 10.\n\n           //STEPE2  EXEC  HFSELECT,PARM='E,10,24'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Output file\n           //SYSIN     DD  *\n           DSMITHD\n           DJONESD\n           XDOEX\n           /*\n\n\n                                HFSELECT EXAMPLES                   PAGE E-2\n\n\n                EXAMPLE E3\n\n                Search  a  COBOL  program,  presumably written in structured\n           format, for any line containing 'GO TO'.\n\n           //STEPE3  EXEC HFSELECT,PARM=E\n           //SYSUT1    DD DSN=SOURCE.COBOL(PROGRAM),DISP=SHR\n           //SYSUT2    DD SYSOUT=*\n           //SYSIN     DD *\n           X GO X\n           /*\n\n                Since   GO   is  a  reserved  word  in  COBOL  a  string  of\n           blankGOblank  will find all examples of GO TO, no matter how many\n           blanks are between GO and TO.\n\n                EXAMPLE E4\n\n                Documentation was to have been written with ten blank spaces\n           at  either margin.  Find any lines with fewer than ten spaces (no\n           blanks)  at  the  margins.  The  data  set  is 80 character fixed\n           length.\n\n           //STEPE4  EXEC HFSELECT,PARM='EN,1,10,71,80'\n           //SYSUT1    DD Documentation file\n           //SYSUT2    DD SYSOUT=*        bad lines\n           //SYSIN     DD *\n           A A\n           /*\n\n                The  JCL above will select lines that do not have a blank in\n           any column from 1 to 10 and from 71 to 80.\n\n                EXAMPLE E5\n\n                Produce a directory listing  of  the  members  of  a  source\n           library which are COBOL programs.\n\n           //STEPE5  EXEC HFSELECT,PARM='E,8,72'\n           //LIBFILE   DD DSN=LIB.SOURCE,DISP=SHR\n           //MEMBNAME  DD SYSOUT=*\n           //SYSIN     DD *\n           *PROGRAM-ID.*\n           //\n\n\n                                HFSELECT EXAMPLES                   PAGE E-3\n\n\n           EXAMPLE E6\n\n                Change every occurrence of the string UNIT=3330 to UNIT=3350\n           in  member  U3330 in the JCL dataset JCLPDS01. Name the resultant\n           member  U3350.  Also  count  the  number  of  records  containing\n           UNIT=SYSDA.\n\n           //STEPE6  EXEC HFSELECT,PARM='E,4,71'\n           //SYSUT1   DD  DSN=JCLPDS01(U3330),DISP=SHR\n           //SYSUT2   DD  DSN=JCLPDS01(U3350),DISP=SHR\n           //CONVERT  DD  *\n           @UNIT=3350\n           /*\n           //SYSIN    DD  *\n           XUNIT=3330X\n           *UNIT=SYSDA*\n           /*\n           //\n\n                Note:  This  example  will  create  member U3350 in JCLPDS01\n           identical  to  member  U3330  except  that all references to 3330\n           units  will  be  changed  to  3350 units. SYSUT2 will contain all\n           records that occur in member U3330. The column ranges of 4 and 71\n           were  specified  since  JCL  parameters  must occur between these\n           column  values.  This is more efficient than searching the entire\n           80 byte record by specifying PARM='E'.\n\n                A   message   will   be  generated  listing  the  number  of\n           occurrences   of  the  string  UNIT=3330  that  were  changed  to\n           UNIT=3350. Messages will also be generated listing   the   number\n           of  records  containing  the  string  UNIT=3330  and  the  number\n           containing the string UNIT=SYSDA.\n\n           EXAMPLE E7\n\n                Change  every  occurrence  of the string PGM=IEBGENER to the\n           string  PGM=HFSELECT  in  the  library  PDS.PROCLIB.  Output  the\n           changed  file  as  PDS.PROCLIB1.  This  job  assumes that all the\n           IEBGENER steps in PDS.PROCLIB are pure copy functions.\n\n           //STEPE7  EXEC HFSELECT,PARM='E,4,71'\n           //LIBFILE  DD  DSN=PDS.PROCLIB,DISP=SHR\n           //LIBOUT   DD  DSN=PDS.PROCLIB1,DISP=SHR\n           //CONVERT  DD  *\n           @PGM=HFSELECT\n           /*\n           //SYSIN    DD  *\n           XPGM=IEBGENERX\n           //\n                Note: This example creates a library file that is  an  exact\n           copy of the input library, but with all references to the program\n           IEBGENER changed to HFSELECT. The example assumes that space  and\n           directory blocks had been preallocated to PDS.PROCLIB1.\n\n\n                                HFSELECT EXAMPLES                   PAGE E-4\n\n\n           EXAMPLE E8\n\n                Perform  a  test  run on EXAMPLE E7, routing the output to a\n           print file. The test run will print out only the records changed.\n\n           //STEPE8  EXEC HFSELECT,PARM='E,4,71'\n           //LIBFILE  DD  DSN=PDS.PROCLIB,DISP=SHR\n           //SYSUT2   DD  SYSOUT=*\n           //CONVERT  DD  *\n           $PGM=HFSELECT\n           /*\n           //SYSIN    DD  *\n           XPGM=IEBGENERX\n           /*\n           //\n\n                Note:  The  SYSUT2 print file will contain only records that\n           had the string PGM=IEBGENER. This will prevent the entire library\n           from being printed.\n\n           EXAMPLE E9\n\n                Change, in place, every occurrence of the string TEST.ABC to\n           the string PROD.ABC in the library PDS.PROCLIB.\n\n           //STEPE7  EXEC HFSELECT,PARM='E,4,71'\n           //LIBFILE  DD  DSN=PDS.PROCLIB,DISP=SHR\n           //LIBOUT   DD  DSN=PDS.PROCLIB,DISP=SHR\n           //MEMSYSIN DD  *\n           *(R)             THIS ALLOWS ALL MEMBERS TO BE UPDATED IN PLACE\n           //SYSIN    DD  *\n           XPROD.ABCX\n           //CONVERT  DD  *\n           @TEST.ABC\n           //\n\n\n                                HFSELECT EXAMPLES                   PAGE F-1\n\n\n           EXAMPLE F1\n\n           A  file is given in case number order. It is known that there are\n           duplicate  records  in  the  file  and  it  is desired that these\n           duplicates  be deleted from the file. It is also desired that the\n           duplicate  case  records  be  output  to  a second file. The case\n           number is of length 10 and is in position 1 of the record.\n\n           //STEPF1 EXEC HFSELECT,PARM='F,J=1,10,1'\n           //SYSUT1   DD DSN=TEST.INPUTFILE,DISP=SHR\n           //SYSUT2   DD DSN=TEST.UNDUP.FILE,UNIT=T6250,DISP=(,KEEP)\n           //SYSUT3   DD DSN=TEST.DUPLI.FILE,UNIT=T6250,DISP=(,PASS)\n\n           EXAMPLE F2\n\n           It is desired to generate the crosstab statistics for a file. The\n           statistics required are the sex and year of birth on each record.\n           The  sex  is a one character field in position 18 and the date of\n           birth  is a six character field starting in position 35 (YYMMDD).\n           The file is in ascending sort order on date of birth within sex.\n\n           //STEPF2 EXEC HFSELECT',PARM='F,J=0,1,18,2,35'\n           //SYSUT1   DD DSN=TEST.INFILE,DISP=SHR\n\n\n                                HFSELECT EXAMPLES                   PAGE F-2\n\n\n           EXAMPLE F3\n\n           It  is  desired  to  print  the first n records of each unique ID\n           contained in a file. The ID is of length 1 and starts in position\n           1 of the record. Print out the remaining records in SYSUT3.\n\n           //STEPF3 EXEC HFSELECT,PARM='F,J=n,1,1'  n coded as shown below\n           //SYSUT2   DD SYSOUT=*\n           //SYSUT3   DD SYSOUT=*\n           //SYSUT1   DD input file\n\n           The  outputs for the input file keys listed below and for various\n           values of n in the J= parameter are as follows:\n\n\n                           n=1               n=2               n=3\n\n           SYSUT1     SYSUT2 SYSUT3     SYSUT2 SYSUT3     SYSUT2 SYSUT3\n\n             1          1                 1                 1\n             1                 1          1                 1\n             2          2                 2                 2\n             3          3                 3                 3\n             3                 3          3                 3\n             3                 3                 3          3\n             3                 3                 3                 3\n             4          4                 4                 4\n             4                 4          4                 4\n             4                 4                 4          4\n             4                 4                 4                 4\n             4                 4                 4                 4\n             5          5                 5                 5\n             7          7                 7                 7\n             8          8                 8                 8\n             9          9                 9                 9\n             9                 9          9                 9\n\n           If n=0 the following messages would be printed:\n\n           KEY= 1   NUMBER OF RECORDS SELECTED = 2\n           KEY= 2   NUMBER OF RECORDS SELECTED = 1\n           KEY= 3   NUMBER OF RECORDS SELECTED = 4\n           KEY= 4   NUMBER OF RECORDS SELECTED = 5\n           KEY= 5   NUMBER OF RECORDS SELECTED = 1\n           KEY= 7   NUMBER OF RECORDS SELECTED = 1\n           KEY= 8   NUMBER OF RECORDS SELECTED = 1\n           KEY= 9   NUMBER OF RECORDS SELECTED = 2\n\n           and SYSUT2 would contain all the records of the input file.\n\n\n                                HFSELECT EXAMPLES                   PAGE F-3\n\n\n           EXAMPLE F4\n\n           It  is  desired  to  unduplicate  a  tape  file.  The  file is in\n           descending order on a 100 byte key which starts in position 1.\n\n           //STEPF4 EXEC HFSELECT,PARM='FWL,J=1,100,1'\n           //SYSUT1   DD  DSN=TAPEFILE,UNIT=T6250,DISP=(OLD,KEEP),\n           //             VOL=SER=001234\n           //SYSUT2   DD  DSN=UNDUP.FILE,UNIT=T6250,DISP=(,CATLG)\n\n           The  W  suboption is used because reading the file backwards puts\n           it in ascending order on the key. The L suboption is used because\n           the key length is greater than 20 bytes.\n\n           EXAMPLE F5\n\n           A file is sorted by social security number which is in position 5\n           of the record. Produce a frequency report of the number of social\n           security numbers that are on the file  once,  twice, three times,\n           etc.\n\n           //STEPF5A EXEC HFSELECT,PARM='F,J=0,9,5'\n           //* create frequency on social security number\n           //* and send sysprint data set to disk to be passed\n           //SYSPRINT DD  DSN=&&SSNFREQ,UNIT=SYSDA,DISP=(,PASS),\n           //             SPACE=(TRK,(50,5)),\n           //             DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)\n           //SYSUT1   DD  DSN=SSNFILE,UNIT=T6250,DISP=(OLD,KEEP),\n           //             VOL=SER=001234\n           //*\n           //STEPF5B EXEC HFSELECT,PARM='S,K=SEL021,6,2'\n           //* select frequency messages SEL021 only\n           //SYSUT1   DD  DSN=&&SSNFREQ,DISP=(OLD,DELETE)\n           //SYSUT2   DD  DSN=&&MSGS,DISP=(,PASS),UNIT=SYSDA,\n           //             SPACE=(TRK,(50,5))\n           //*\n           //STEPF5C EXEC PGM=SORT\n           //* sort on frequency count in SEL021 messages\n           //* the count is in position 63 for a length of 10 in SEL021\n           //* this step groups the keys by number of occurrences\n           //SYSOUT   DD  SYSOUT=*\n           //SORTIN   DD  DSN=&&MSGS,DISP=(OLD,DELETE),\n           //SORTOUT  DD  DSN=&&SORTMSGS,UNIT=SYSDA,DISP=(,PASS),\n           //             SPACE=(TRK,(50,5))\n           //SYSIN    DD  *\n             SORT FIELDS=(63,10,A,CH)\n           //*\n           //STEPF5D EXEC HFSELECT,PARM='F,J=0,10,63'\n           //* count the number of keys with each number of occurrences\n           //SYSUT1   DD  DSN=&&SORTMSGS,DISP=(OLD,DELETE)\n\n\n                                HFSELECT EXAMPLES                   PAGE F-4\n\n\n           EXAMPLE F6\n\n           Read  a  variable length file  and report on the sizes of records\n           found and how many of each size were on the file.\n\n           //STEPF6A EXEC HFSELECT\n           //* convert variable length file to fixed format and truncate\n           //* to retain RDW portion of record only (by using OPTCD=U)\n           //SYSUT1   DD  DSN=variable.file,DISP=OLD\n           //SYSUT2   DD  DSN=&&RDWS,DISP=(,PASS),UNIT=SYSDA,\n           //             SPACE=(TRK,(50,5)),\n           //             DCB=(RECFM=FB,LRECL=4,BLKSIZE=4000,OPTCD=U)\n           //*\n           //STEPF6B EXEC PGM=SORT    SORT ON RDWs\n           //SYSOUT   DD  sysout=*\n           //SORTIN   DD  DSN=&&RDWS,DISP=(OLD,DELETE),\n           //SORTOUT  DD  DSN=&&SORTRDWS,UNIT=SYSDA,DISP=(,PASS),\n           //             SPACE=(TRK,(50,5))\n           //SYSIN    DD  *\n             SORT FIELDS=(1,4,A,BI)\n           //*\n           //STEPF6C EXEC HFSELECT,PARM='F,J=0,4,1'\n           //* produce frequency count on RDWs.\n           //* frequency report is output to a disk file, since the RDW\n           //*    key is in non-printable binary\n           //SYSPRINT DD  DSN=RDW.FREQ,UNIT=SYSDA,DISP=(,KEEP),\n           //             SPACE=(TRK,(50,5),RLSE)\n           //SYSUT1   DD  DSN=&&SORTRDWS,DISP=(OLD,DELETE)\n\n\n                                HFSELECT EXAMPLES                   PAGE F-5\n\n\n           EXAMPLE F7\n\n                Encrypt  the  social  security  number  on every record of a\n           personnel  file.  The  SSN is in zoned decimal format in position\n           50.  Use  the  following encryption algorithm: n ---> n+3 mod 10;\n           i.e. add 3 to each number, with no carryover into the ten's place.\n\n           //STEPF7  EXEC HFSELECT,PARM='F,9,50'\n           //SYSUT1   DD  DSN=PERSFILE,DISP=SHR\n           //SYSUT2   DD  DSN=CRYPTFLE,UNIT=T6250,DISP=(,KEEP)\n           //CONVERT  DD  *\n           *03\n           *14\n           *25\n           *36\n           *47\n           *58\n           *69\n           *70\n           *81\n           *92\n           /*\n           //\n\n                Note:  The  F  option was used to copy the entire input file\n           (rather  than  the  more  customary R option) because a key field\n           must  be specified for encryption. Normally, the F option is only\n           useful  when the file is sorted on the key field(s) specified. If\n           the  file  is not sorted on the key field(s), and no J= parameter\n           is coded, the entire file is output to SYSUT2.\n\n\n                                HFSELECT EXAMPLES                   PAGE G-1\n\n\n           EXAMPLE G1\n\n           A  file  contains  a  list  of New York City residents with their\n           addresses and ZIP codes. It is desired that 5 residents from each\n           Manhattan  ZIP  code be selected. The ZIP code starts in position\n           45  for  a length of 5. Note that all residential  Manhattan  ZIP\n           codes fall in the range between 10001 and 10099.\n\n           //STEPG1  EXEC  HFSELECT,PARM='G,J=5,5,45'\n           //SYSUT1    DD  DSN=TEST.NYC.FILE,DISP=SHR\n           //SYSUT2    DD  DSN=TEST.MANHTN.ZIP,DISP=SHR\n           //SYSIN     DD  *\n           10001\n           10099\n           /*\n\n\n           EXAMPLE G2\n\n           It  is  desired to select a range of cases from a file with seven\n           digit  case  numbers.  The  ranges  are  cases between 0 and 500,\n           between 12000 and 12050, and between 1,000,678 and 1,001,000. The\n           case numbers are in the first seven bytes of the records.\n\n           //STEPG2  EXEC HFSELECT,PARM='G,7,1'\n           //ISAMFILE  DD DSN=TEST.CASES,DISP=SHR\n           //SYSUT2    DD DSN=output file\n           //SYSIN     DD *\n           0000000\n           0000500\n           0012000\n           0012050\n           1000678\n           1001000\n           /*\n\n\n                                HFSELECT EXAMPLES                   PAGE G-2\n\n\n           EXAMPLE G3\n\n           If  the  input file in the EXAMPLE G2 did not have leading zeroes\n           in  the  case  number  field,  but  instead had leading blanks or\n           leading   low-values   (HEX'00'),  the  JCL  for  that  selection\n           requirement would be:\n\n           //STEPG3  EXEC HFSELECT,PARM='G,Y=F04000,7,1'\n           //ISAMFILE  DD DSN=TEST.CASES,DISP=SHR\n           //SYSUT2    DD DSN=output file\n           //SYSIN     DD *\n           0000000\n           0000500\n           1000678\n           1001000\n           0012000\n           0012050\n           /*\n\n           The  Y=F04000  parameter  equates,  for  selection  purposes, all\n           blanks  (HEX'40')  and  low-values  (HEX('00') in the case number\n           field  to  the  EBCDIC  representation  of an unsigned zoned zero\n           (HEX'F0').  Note also that the pairs of keys in SYSIN need not be\n           in order.\n\n\n                                HFSELECT EXAMPLES                   PAGE G-3\n\n\n           EXAMPLE G4\n\n           Generate  a  file  of  keys  containing  all  the  values  in the\n           following      ranges:      4113274-4113320,     4118121-4118126,\n           4159800-4159820, 4183641-4183641.\n\n           //STEPG4A EXEC  HFSELECT,PARM='G,7,1'\n           //procstepname.SYSPRINT  DD  DSN=&&MSGS,DISP=(,PASS),\n           //          SPACE=(TRK,5,RLSE),UNIT=SYSDA\n           //SYSUT1    DD  DUMMY,DCB=BLKSIZE=20\n           //SYSIN     DD  *\n           4113274\n           4113320\n           4118121\n           4118126\n           4159800\n           4159820\n           4183641\n           4183641\n           /*\n           //STEPG4B  EXEC  HFSELECT,PARM='S,K=SEL021I,7,2'\n           //SYSUT1     DD  DSN=&&MSGS,DISP=(OLD,DELETE)\n           //SYSUT2     DD  DSN=KEYFILE,DISP=(,KEEP),UNIT=SYSDA,\n           //           SPACE=(TRK,5,RLSE)\n\n           Note:  SYSPRINT  is normally the HFSELECT print file in which the\n           keys  to be selected and the number selected, together with other\n           messages,   are   printed.   The   attributes   of  SYSPRINT  are\n           RECFM=FBA,LRECL=133,BLSIZE=1330. The form of the key messages are\n           SEL021I  KEY=  xxxxxxx NUMBER OF RECORDS SELECTED= nnn. Since, in\n           this  example,  SYSPRINT  is  defined as a disk data set, all the\n           values  in the ranges listed in SYSIN will be written to the disk\n           data  set  in  the  form of the above message, e.g., SEL021I KEY=\n           4113274  NUMBER  OF RECORDS SELECTED= 0. The SYSPRINT data set is\n           edited  in  the  second  step  of  the job (STEPG4B), using the S\n           option (see section 7.14), to eliminate any records which contain\n           messages  other  than SEL021I KEY= xxx. The first character is  a\n           carriage control; SEL021I begins in column 2 and  the  actual key\n           begins in column 15.\n\n           Note  also that a primary input file is not necessary to generate\n           these key values, and therefore SYSUT1 has been DUMMYed.\n\n\n                                HFSELECT EXAMPLES                   PAGE K-1\n\n\n           EXAMPLE K1\n\n           It  is  desired  to make a test file of 30 groups of master/slave\n           records  from a production file. The record keys are of length 16\n           starting  in  position 1 of the variable length records. The file\n           is  stored on tape.\n\n           //STEPK1  EXEC HFSELECT,PARM='K,J=30,16,1'\n           //SYSUT1    DD DSN=PROD.ABC425T1,UNIT=TAPE9,DISP=OLD,\n           //             VOL=SER=010453,LABEL=(1,BLP)\n           //SYSUT2    DD DSN=TEST.ABC425T1,UNIT=SYSDA,DISP=(,CATLG),\n           //             SPACE=(TRK,(19,5),RLSE)\n\n           EXAMPLE K2\n\n           Using the SYSUT1 file from EXAMPLE M5 in section 7.9, if\n                     PARM='K,B=4,E=11,1,4' is coded\n           the seventh thru  the  twelfth record of SYSUT1 will be selected.\n\n\n                                HFSELECT EXAMPLES                   PAGE M-1\n\n\n           EXAMPLE M1\n\n           Select from an input file all records matching keys in an ordered\n           SYSIN file. The keys are in the first fifteen positions of SYSIN.\n           The  record  select  fields  are  positions  1  through 10 and 22\n           through  26.\n\n           //STEPM1  EXEC  HFSELECT,PARM='M,10,1,5,22'\n           //SYSUT1    DD  Ordered input file\n           //SYSUT2    DD  Output file with desired records from SYSUT1\n           //SYSUT3    DD  Output file with rejected records from SYSUT1\n           //SYSIN     DD  Ordered key file\n\n\n           EXAMPLE M2\n\n           Select  from  an input file records that do not match the keys in\n           example M1. Only the first four non-matching records for each key\n           are desired. There are 20 keys in SYSIN.\n\n           //STEPM2  EXEC  HFSELECT,PARM='MN,J=4,10,1,5,22'\n           //SYSUT1    DD  Ordered input file\n           //SYSUT2    DD  Output file with selected records\n           //SYSIN     DD  Ordered key file\n\n           In  this example, up to four  records  are output for each key in\n           SYSIN.  After  the last key, four more records are output (if the\n           end  of the input file is not reached) due to the appended key of\n           HEX'FF...FF'.  A  maximum  of 84 records could be selected (4 for\n           each key and four after the last key).\n\n           EXAMPLE M3\n\n           Select from the input file all records that do not match the keys\n           in  SYSIN. The last key in SYSIN is less than the last key in the\n           input  file.  Note that if HEX'FF...FF' key were not appended  to\n           SYSIN, selection  would stop before the end of the input file and\n           the non-matching records with keys that were higher than the last\n           key in SYSIN would not be put out to SYSUT2.\n\n           //STEPM3  EXEC  HFSELECT,PARM='MN,10,1,5,22'\n           //ISAMFILE  DD  Ordered input file\n           //SYSUT2    DD  Ordered sequential output file from ISAMFILE\n           //SYSIN     DD  Ordered key file\n\n\n                                HFSELECT EXAMPLES                   PAGE M-2\n\n\n           EXAMPLE M4\n\n           Select  from  the  primary  input file all records that match the\n           secondary  file records on last name. Both files are in ascending\n           order on last name. The last name field starts in position 10 for\n           a  length of 25 in the primary file. It starts in position 20 for\n           a length of 25 in the secondary file. In both files the last name\n           is  left  justified in the fields. Also output to print all names\n           from the secondary file that have a match on the primary file.\n\n           //STEPM4  EXEC  HFSELECT,PARM='ML,V=(25,20),25,10'\n           //SYSUT1    DD  Primary input file\n           //SYSIN     DD  Secondary input file\n           //SYSUT2    DD  Selected records from the primary file\n           //SYSUT4    DD  sysout=*   Records of the secondary file\n                                      that contain a last name that has a\n                                      match on the primary file\n\n           The L suboption is used since the fields to be matched are longer\n           than 20 characters.\n\n\n                                HFSELECT EXAMPLES                   PAGE M-3\n\n\n           EXAMPLE M5\n\n           Match  a  primary  input file against a secondary input file. The\n           select  field  in  the  primary input file is in position 4 for a\n           length  of  1. The select field in the secondary input file is in\n           position  9  for  a length of 1. Select n records for each key in\n           the secondary input file SYSIN. Note: in the JCL, n must have  an\n           numerical value.\n\n           //STEPM5 EXEC HFSELECT,PARM='M,J=n,V=(1,9),1,4'\n           //* WHERE n IS CODED AS SHOWN BELOW\n           //SYSUT1   DD Ordered primary input file          (S1)\n           //SYSIN    DD Ordered secondary input file        (SI)\n           //SYSUT2   DD Selected output file from SYSUT1    (S2)\n           //SYSUT3   DD Rejected output file from SYSUT1    (S3)\n           //SYSUT4   DD Selected output file from SYSIN     (S4)\n           //SYSUT5   DD Rejected output file from SYSIN     (S5)\n\n           The  outputs  of  the  primary and secondary input files, for the\n           contents  of the record select fields shown below, are listed for\n           various values of n and for the count default.\n\n                  count default        n=1            n=2            n=3\n\n           S1 SI    S2 S3 S4 S5    S2 S3 S4 S5    S2 S3 S4 S5    S2 S3 S4 S5\n\n            1  1     1     1        1     1        1     1        1     1\n            1  2     1     2           1  2        1     2        1     2\n            2  3     2     3        2     3        2     3        2     3\n            3  3     3        3     3     3        3     3        3        3\n            3  4     3     4        3     4        3     4        3     4\n            3  4     3        4        3  4        3     4        3     4\n            4  4     4        4     4     4        4        4     4        4\n            4  6     4     6        4     6        4     6        4     6\n            4  6     4        6     4        6     4        6     4        6\n            4  7     4     7           4  7        4     7        4     7\n            5  8        5     8        5     8        5     8        5     8\n            5  9        5  9           5  9           5  9           5  9\n            6  9     6        9     6     9        6     9        6        9\n            7        7              7              7              7\n            7        7                 7           7              7\n            7        7                 7              7           7\n            9        9              9              9              9\n            9        9              9              9              9\n            9        9                 9           9              9\n\n\n           Note  that  no  detail  messages,  KEY=nnn,  will  be  printed in\n           SYSPRINT  when  the V= parameter is coded. The only message to be\n           printed will be: nnn RECORDS PASSED, mmm RECORDS OUTPUT.\n\n\n                                HFSELECT EXAMPLES                   PAGE M-4\n\n\n           EXAMPLE M6\n\n           Select  from  the  primary  input file all records that match the\n           records  in the secondary input file on the following fields. The\n           primary  file fields are 10 bytes starting in position 1, 4 bytes\n           starting  in position 5, and 2 bytes starting in position 50. The\n           secondary file fields are 15 bytes starting in position 150 and 1\n           byte  starting  in  position  6000.  The primary file  is a fixed\n           format  ISAM file  with  an LRECL of 76.  The secondary file is a\n           variable format  sequential file with an LRECL of 12960.  Records\n           in this file can be smaller  than  6000.  Begin  record selection\n           after record 10 and end record selection after record 1000 in the\n           primary input file.\n\n           //STEPM6  EXEC HFSELECT,PARM=(M,'V=(15,150,1,6000),B=10,E=1000',\n           //             10,1,4,5,2,50)\n           //ISAMFILE  DD DSN=TEST.ISAM,UNIT=SYSDA,DISP=OLD,\n           //             DCB=(RECFM=FB,LRECL=76,BLKSIZE=7600,DSORG=IS)\n           //SYSIN     DD DSN=TEST.SEQNTL1,UNIT=T6250,DISP=OLD,\n           //             DCB=(RECFM=VB,LRECL=12960,BLKSIZE=32000),\n           //             VOL=SER=013456\n           //SYSUT2    DD DSN=SEQNTL.OUTPUT.FROM.ISAM,DISP=(,KEEP),\n           //             UNIT=T6250,DCB=DSORG=PS\n\n           Note  that the two files are of different data set organizations,\n           have  different  record  formats  and logical record lengths, and\n           that  the  number  of  L,P  pairs  differs from the number of l,p\n           pairs. Note also that the output file(s) are always sequential.\n\n\n           EXAMPLE M7\n\n           Select from a master file ordered on a packed decimal case number\n           all records that match a  transaction  file ordered  on  a  zoned\n           decimal case  number. The master file case number is 5 bytes long\n           (9 digits followed by a sign half-byte)  starting  in  position 3\n           and the transaction case number is a 9 byte field in position 2.\n\n           //STEPM7  EXEC HFSELECT,PARM='M,VP=(9,2),5,3'\n           //SYSUT1    DD DSN=MAST.FILE,DISP=OLD\n           //SYSIN     DD DSN=TRAN.FILE,DISP=OLD\n           //SYSUT2    DD DSN=MATCH.FILE,DISP=OLD\n\n           Note: the VP parameter will ensure that the SYSIN key is a valid\n           zoned numeric field and then pack it. It  will  also ensure that\n           the SYSUT1 key is a valid packed numeric  field and then compare\n           the keys algebraically. Note also that  the lengths  of the keys\n           need not be equal.\n\n\n                                HFSELECT EXAMPLES                   PAGE M-5\n\n\n           EXAMPLE M8\n\n           Match  a  transaction  file  against  a  master personnel file on\n           personnel key of length 9. The key is in position 3 of the master\n           file and position  5 of the transaction file.  Output the matched\n           personnel records  concatenated  with  their matching transaction\n           records.  The  master  file  has  a  variable  LRECL,  while  the\n           transaction file has a fixed length LRECL.\n\n           //STEPM8  EXEC HFSELECT,PARM='M,V=(9,5),9,3'\n           //SYSUT1    DD Ordered sequential master file,\n           //             DCB=(RECFM=VB,LRECL=604,BLKSIZE=6044)\n           //SYSIN     DD Ordered sequential transaction file,\n           //             DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000)\n           //MERGE     DD Matched master file records with\n           //             matching SYSIN records concatenated,\n           //             DCB=BLKSIZE=15000,SPACE=(space),etc.\n\n           Note: only a BLKSIZE need be  specified  for  the MERGE file.  In\n           this example, the RECFM defaults to VB, and the LRECL defaults to\n           684.\n\n\n                                HFSELECT EXAMPLES                   PAGE O-1\n\n           EXAMPLE O1\n\n           Select  from  an  input  file a total of 100 records that contain\n           either  379 in positions 1 through 3, or JONES starting in 20 for\n           a  length of 7, or SAMUEL starting in position 30 for a length of\n           6.\n\n           //STEPO1  EXEC  HFSELECT,PARM='O,J=100,3,1,7,20,6,30'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Output file of selected records\n           //SYSIN     DD  *\n           379\n           JONES   NOTE THAT TWO BLANKS AFTER JONES ARE PART OF THE KEY\n           SAMUEL\n           /*\n\n\n           EXAMPLE O2\n\n           Select  from  the  input  file  all records that have either high\n           values, low values, or numeric keys in positions 1 through 10  or\n           have 030779 in positions 20 through 25. Output all other  records\n           of SYSUT1 into SYSUT3.\n\n           //STEPO2  EXEC  HFSELECT,PARM='O,10,1,6,20'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Selected output file\n           //SYSUT3    DD  All non-selected records from SYSUT1\n           //SYSIN     DD  *\n           CLASS=NHL\n           030779\n           /*\n\n\n           EXAMPLE O3\n\n           Select from the input file 500 records that do not have the start\n           date  010179  in positions 1 through 6 nor the end date 010879 in\n           positions  10 through 15, nor the report date 010579 in positions\n           50 through 55.\n\n           //STEPO3  EXEC  HFSELECT,PARM='ON,J=500,6,1,6,10,6,50'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Selected output file\n           //SYSIN     DD  *\n           010179\n           010879\n           010579\n           /*\n\n\n                                HFSELECT EXAMPLES                   PAGE O-2\n\n\n           EXAMPLE O4\n\n           Delete from the input file all records that have B24 in positions\n           1  through  3  or  'EDWARD  SMITH'  starting in position 20 for a\n           length  of  12  or  '124 NORFOLK AV.' in positions 50 through 64.\n           Output the rest of the file and also print the deleted records in\n           HEX for inspection.\n\n           //STEPO4  EXEC  HFSELECT,PARM='O,3,1,12,20,15,50'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  SYSOUT=*,DCB=RECFM=A DELETED RECORDS IN HEX\n           //SYSUT3    DD  Output file without deleted records\n           //SYSIN     DD  *\n           B24\n           EDWARD SMITH\n           124 NORFOLK AV.\n           /*\n\n\n                                HFSELECT EXAMPLES                   PAGE P-1\n\n\n           EXAMPLE P1\n\n           Select  from the input file all records with a start date earlier\n           than  December  24,  1975 or between January 1, 1977 and June 15,\n           1978 inclusive or after May 17, 1980. The start date field begins\n           in position 50, has a length of 6 and is in the format mmddyy.\n\n           //STEPP1  EXEC HFSELECT,PARM='P,2,54,2,50,2,52'\n           //SYSUT1    DD Input file\n           //SYSUT2    DD Selected records\n           //SYSIN     DD *    KEYS WILL BE ENTERED AS yymmdd\n           LOW VALUES      this pair selects  records\n           751223               earlier than 12/24/75\n           770101          this pair selects  records\n           780615               between 1/1/77 and 6/15/78 inclusive\n           800518          this record paired with an appended\n           /*                   high values selects records\n           //*                  later than 5/17/80\n\n\n           EXAMPLE P2\n\n           Select from the input file ten records from each of the following\n           ranges   of   case   numbers:  0-100,  500-1,000,  10,000-20,000,\n           21,000-23,000. The case number is a seven position numeric  field\n           starting in byte 1.\n\n           //STEPP2  EXEC HFSELECT,PARM='P,J=10,7,1'\n           //SYSUT1  DD Input file\n           //SYSUT2  DD Output file\n           //SYSIN   DD *\n           0021000\n           0023000\n           0000000\n           0000100\n           0010000\n           0020000\n           0000500\n           0001000\n           /*\n\n           Note  that the key pairs need not be entered in range order, also\n           that  the  numbers  must  be  zero-filled  so that the key is the\n           length of the select field(s) specified in the PARM.\n\n                                HFSELECT EXAMPLES                   PAGE P-2\n\n           EXAMPLE P3\n\n           Select from the input file 500 records that have end dates before\n           January 1, 1979 or after than December 31, 1980. The end  date is\n           a six position field starting in byte 45. The format is yymmdd.\n\n           //STEPP3  EXEC HFSELECT,PARM='PN,J=500,6,45'\n           //SYSUT1    DD Input file\n           //SYSUT2    DD Selected records\n           //SYSIN     DD *\n           790101\n           801231\n           /*\n\n           Note that while all the examples use numbers in SYSIN, the  keys\n           are actually treated as characters, and  ranges  of names  could\n           have been used just as well as ranges of dates.\n\n           EXAMPLE P4\n\n                Create  a file of personnel whose salaries are over $30,000.\n           Encrypt  the  name, address and salary on this selected file. The\n           salary  is  of  length 6 (zoned decimal) starting in position 40.\n           The  name  has a length of 26 starting in position 10 and address\n           has a length of 40 starting in position 60. Use RANDOM encryption\n           for  name and address and the algorithm in example F7  for salary\n           encryption.\n\n           //STEPP4A EXEC HFSELECT,PARM='P,6,40'\n           //SYSUT1   DD  DSN=PERSFILE,DISP=SHR\n           //SYSUT2   DD  DSN=&&FILE1,UNIT=SYSDA,DISP=(,PASS),\n           //         SPACE=(CYL,1)\n           //SYSIN    DD  *\n           30000\n           //CONVERT  DD  *\n           *03\n           *14\n           F2F5             NOTE THAT HEX AND CHARACTER CONTROL STATEMENTS\n           F3F6             MAY BE MIXED IN THE CONVERT FILE\n           *47\n           *58\n           F6F9\n           F7F0\n           *81\n           *92\n           //STEPP4B EXEC HFSELECT,PARM='FL,26,10,40,60'\n           //SYSUT1   DD  DSN=&&FILE1,DISP=(OLD,DELETE)\n           //SYSUT2   DD  DSN=CRYPTFLE,UNIT=T6250,DISP=(,KEEP)\n           //CONVERT  DD  *\n           RANDOM=PICKIT       see description of random in R option\n           //\n\n                Note:  The  first  step  of the job selects the records with\n           salaries  greater  than 30000 and then encrypts the salary field.\n           The  second  step  then  encrypts  the  name  and  address of the\n           selected  file.  The random encryption table of step 2 is printed\n           out in reverse order in SYSOUX.\n\n\n                                HFSELECT EXAMPLES                   PAGE Q-1\n\n\n           EXAMPLE Q1\n\n           Test an input file for ascending sequence on case number and line\n           number  within  case number. The case number starts in position 1\n           for  a length of 16 and the line number starts in position 21 for\n           a length of 4.\n\n           //STEPQ1  EXEC HFSELECT,PARM='Q,16,1,4,21'\n           //SYSUT1  DD  DSN=PROD.ABC425T1,UNIT=T6250,DISP=OLD,\n           //        DCB=(RECFM=VB,LRECL=604,BLKSIZE=12960),\n           //        VOL=SER=001265\n\n           EXAMPLE Q2\n\n           Test  an  input  file  for  descending order on a name field that\n           starts  in position 20 for a length of 28. Output the in-sequence\n           records and the out-of-sequence records. Print  messages  for the\n           first 100 out-sequence records.\n\n           //STEPQ2  EXEC HFSELECT,PARM='QNL,J=100,28,20'\n           //SYSUT1    DD Input file\n           //SYSUT2    DD In-sequence records from SYSUT1\n           //SYSUT3    DD Out-of-sequence records from SYSUT1\n\n           The L suboption is required because the name field is longer than\n           20 bytes. The N suboption is used because a descending order test\n           is required.\n\n           EXAMPLE Q3\n\n           Test  a tape input file for descending order on a name field that\n           starts  in position 20 for a length of 28. Output the in-sequence\n           records and the out-of-sequence records in ascending order.\n\n           //STEPQ3  EXEC HFSELECT,PARM='QWL,28,20'\n           //SYSUT1    DD Input file on tape\n           //SYSUT2    DD In-sequence records from SYSUT1 in ascending order\n           //SYSUT3    DD Out-of-sequence records from SYSUT1\n\n           The L suboption is required because the name field is longer than\n           20 bytes. Since the input file is on tape, the W suboption may be\n           used  to  read  the  file  in  reverse  order,  thus  testing and\n           outputting a descending ordered file in ascending order.\n\n           EXAMPLE Q4\n\n           Test  an  input  file  for  ascending  order.  Treat  zoned zeros\n           (X'F0'),  low  values (X'00') and asterisks (X'5C') as equivalent\n           characters  for  sequence  testing  purposes  and  have  them all\n           collating  as  zoned  zeros. The field to be tested on is 6 bytes\n           long beginning in position 70.\n\n           //STEPQ4  EXEC  HFSELECT,PARM='Q,Y=F0005C,6,70'\n           //SYSUT1    DD  Input file\n\n\n                                HFSELECT EXAMPLES                   PAGE Q-2\n\n\n           EXAMPLE Q5\n\n           Sequence  test an input file for ascending order on the first two\n           bytes  of the record. Output both the in-sequence records and the\n           out-of-sequence records.\n\n           //STEPQ5  EXEC  HFSELECT,PARM='Q,2,1'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Output file of in-sequence records\n           //SYSUT3    DD  Output file of out-of-sequence records\n\n           The  following list shows the outputs that would be obtained from\n           the listed input file.\n\n                input file   in-sequence  out-of-sequence\n                  SYSUT1       SYSUT2        SYSUT3\n\n                   01            01\n                   02            02\n                   03            03\n                   05            05\n                   15            15\n                   25            25\n                   11                          11\n                   12                          12\n                   17                          17\n                   27            27\n                   29            29\n\n\n                                HFSELECT EXAMPLES                   PAGE R-1\n\n\n                EXAMPLE R1\n\n           Select  every third record from the input file starting the count\n           at  the  tenth record, then every fifth record starting the count\n           at  the 80th record, and every 100th record starting the count at\n           the  4000th  record.  Select  a  total  of  20  records  for each\n           interval.\n\n           //STEPR1  EXEC  HFSELECT,PARM='R,J=20,10,3,80,5,4000,100'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Selected records output file\n\n           Records selected; 12,15,18,...,84,89,94,...,4099,4199,4299,...\n\n\n           EXAMPLE R2\n\n           Select  every  third  record  from  the  input  file starting the\n           selection  at  the tenth record, then every fifth record starting\n           selection  at  the  80th  record, and every 100th record starting\n           selection  at the 4000th record. Select a total of 20 records for\n           each interval.\n\n           //STEPR2  EXEC  HFSELECT,PARM='R,J=20,8,3,76,5,3901,100'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Selected records output file\n\n           Since  the  tenth record is desired, the start of the first count\n           must be 8. For the 80th record, the start of the count must be 76\n           and for the 4000 record the start must me 3901.\n\n           Records selected: 10,13,16,...,80,85,90,...,4000,4100,4200,...\n\n\n                                HFSELECT EXAMPLES                   PAGE R-2\n\n\n           EXAMPLE R3\n\n           Delete from the input file the records listed in SYSIN.  Copy the\n           non-deleted  records  to  tape.  Print out the deleted records in\n           HEX format. Start the selection at the 10th record.\n\n           //STEPR3  EXEC  HFSELECT,PARM='R,B=9'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  SYSOUT=*,DCB=RECFM=A  Deleted records in HEX\n           //SYSUT3    DD  Non-deleted records in file (between 10 and 1000)\n           //SYSIN     DD  *,DCB=BLKSIZE=80\n           1     invalid number  < (B+1)          record not selected\n           25      valid number                    record 25 selected\n           0045    valid number                    record 45 selected\n           467     valid number                   record 467 selected\n           321   invalid number (out of sequence) record not selected\n           45R   invalid number (not numeric)     record not selected\n           475 9   valid number (9 ignored)       record 475 selected\n           475     valid number (duplicate number)record was selected\n           LAST    to select the last record in the file\n           /*\n\n           EXAMPLE R4\n\n           Copy an input file from tape to disk.\n\n           //STEPR4   EXEC  HFSELECT,PARM='R,1,1'\n           //*STEPR4  EXEC  HFSELECT\n           //SYSUT1     DD  DSN=INPUT.FILE,UNIT=T1600,DISP=OLD,\n           //         VOL=SER=005645\n           //SYSUT2     DD  DSN=OUTPUT.FILE,UNIT=SYSDA,DISP=(NEW,KEEP),\n           //         SPACE=(CYL,(2,1),RLSE)\n           //*  THE DCB WILL BE COPIED FROM THE INPUT FILE\n\n           The 1,1 coded in the N,K pair indicates that the selection should\n           be  every  single  record  starting  from the first record in the\n           file. The commented EXEC statement is the same, since 'R,1,1'  is\n           the default PARM.\n\n\n           EXAMPLE R5\n\n           Select 2000 records at random from a file of 100,000 records.\n\n           //STEPR5  EXEC HFSELECT,PARM='R,J=2000,E=100000'\n           //SYSUT1     DD Input file\n           //SYSUT2     DD Output file of approximately 2000 records\n           //SYSIN      DD *\n           RANDOM\n           /*\n\n           The  seed  used  is  the  default  seed, 8193. The first 5 random\n           records selected are: 46,235,414,438 and 464.\n\n\n                                HFSELECT EXAMPLES                   PAGE R-3\n\n\n           EXAMPLE R6\n\n           Select 2000 records at random from a file of 100,000 records. Use\n           a  seed  of 12479 to select different records from those selected\n           in EXAMPLE R5.\n\n           //STEPR6  EXEC HFSELECT,PARM='R,J=2000,E=100000'\n           //SYSUT1     DD Input file\n           //SYSUT2     DD Output file of approximately 2000 records\n           //SYSIN      DD *\n           RANDOM=12479\n           /*\n\n           The first 5 random records selected are: 30,57,59,64 and 74.\n\n\n           EXAMPLE R7\n\n           Delete every third record from an input file.\n\n           //STEPR7  EXEC HFSELECT,PARM='RN,1,3'\n           //SYSUT1    DD Input file\n           //SYSUT2    DD Output file with every third record deleted\n           //SYSUT3    DD Every deleted third record\n\n           The first 10 records selected are: 1,2,4,5,7,8,10,11,13 and 14.\n\n\n           EXAMPLE R8\n\n           Convert an ISAM/VSAM/Partitioned file to a sequential file with\n           the same data set attributes.\n\n           //STEPR8  EXEC  HFSELECT,PARM='R,1,1'\n           //inddnam   DD  DSN=INPUT,DISP=OLD,UNIT=SYSDA\n           //SYSUT2    DD  DSN=OUTPUT.SEQU,UNIT=T6250,DISP=(,KEEP)\n\n           Note: if the input is an ISAM file inddnam  should  be  coded  as\n           ISAMFILE. If the input is a VSAM file  inddnam  may  be  coded as\n           VSAMFILE (a STEPCAT DD statement  may also  be  needed).  If  the\n           input is a partitioned  data  set  (library)  inddnam  should  be\n           coded as LIBFILE. See section 6.3  for  more detailed information\n           on the use of these ddnames. See section 6.8 for more information\n           on the attributes of SYSUT2 when the input file is VSAM.\n\n\n                                HFSELECT EXAMPLES                   PAGE R-4\n\n\n           EXAMPLE R9\n\n           Create  a  test file by selecting the last 50 records from a VSAM\n           file.\n\n           //STEPR9  EXEC  HFSELECT,PARM='RW,J=50,1,1'\n           //VSAMFILE  DD  Input VSAM file\n           //SYSUT2    DD  Selected records\n\n           Because the W suboption opens the input file backwards the output\n           file,  SYSUT2,  will  contain the last 50 records file in reverse\n           order.\n\n\n           EXAMPLE R10\n\n           Count the number of records in a file.\n\n           //STEPR10  EXEC  HFSELECT,PARM='R,1,1'\n           //SYSUT1     DD  Input file\n\n\n           EXAMPLE R11\n\n           Generate (print) a table of 10000 random numbers, in the range of\n           1 to 99.\n\n           //STEPR11  EXEC  HFSELECT,PARM='R,E=99,J=10000'\n           //SYSIN      DD  *\n           RANDOM=PICKIT    a randomly chosen seed is requested\n           /*\n           //EXITS      DD  *\n           X0\n            NOINPUT\n            RANDOMCNT=10000\n           /*\n\n           Note:  The  10000  random  numbers  will print on the SYSOUX file\n           which is coded in the HFSELECT PROC as SYSOUT=*.  Note  also that\n           no  primary  input  file  is  necessary  since  a NOINPUT control\n           statement was  coded  in  the  X0 initialization exit. Since more\n           than  the  default  maximum of 5000  random numbers was required,\n           the RANDOMCNT control statement was also necessary in the X0 exit\n           (see Appendix D.2.5 and D.2.6 for details.)\n\n\n                                HFSELECT EXAMPLES                   PAGE R-5\n\n\n           EXAMPLE R12\n\n           Copy all members of a PDS whose names begin with IEB to an output\n           PDS. Also copy members ALPHA1 and SORTX.\n\n           //STEPR12  EXEC  HFSELECT\n           //LIBFILE    DD  DSN=INPDS,DISP=SHR\n           //LIBOUT     DD  DSN=OUTPDS,DISP=SHR\n           //MEMSYSIN   DD  *\n           ALPHA1\n           IEB*\n           SORTX\n           /*\n\n           Note:  If no MEMSYSIN had been coded,  all members  of the input\n           PDS would be copied to the output PDS.  Also,  since  no PARM is\n           coded, the default  PARM='R,1,1'  is used.  Member names must be\n           specified in ascending sequence.\n\n           EXAMPLE R13\n\n           Convert a sequential/ISAM file to a VSAM file.\n\n           //STEPR13 EXEC  HFSELECT,PARM='R,1,1'\n           //inddnam   DD  DSN=INPUT,DISP=OLD,UNIT=SYSDA\n           //VSAMOUT   DD  DSN=OUTPUT.VSAM,DISP=SHR\n\n           Note: If the input is a sequential file, inddnam should be coded\n           as SYSUT1. If the input is an ISAM file, inddnam should be coded\n           as ISAMFILE. The input files must be  in  sorted  order  on  the\n           predefined VSAMOUT key.\n\n\n           EXAMPLE R14\n\n           Print out the first and last record of a file.\n\n           //STEPR14  EXEC  HFSELECT,PARM='R'\n           //SYSUT1     DD  Input file\n           //SYSUT2     DD  SYSOUT=*\n           //SYSIN      DD  *\n           1\n           LAST\n           /*\n\n\n                                HFSELECT EXAMPLES                   PAGE S-1\n\n\n              EXAMPLE S1\n\n              Select  100 records from an input file beginning from the 50th\n              record  of  the file, with budget code numbers not equal to 0.\n              The  budget  code  is a 4-byte zoned numeric field starting in\n              byte 21.\n\n              //STEPS1  EXEC  HFSELECT,PARM='SN,N=0,J=100,B=49,4,21'\n              //SYSUT1    DD  Input file\n              //SYSUT2    DD  Selected records\n\n\n              EXAMPLE S2\n\n              Select all records from a personnel file with an employee code\n              of A, B, Q, S or V. The employee code is in byte 105. The file\n              is a VSAM file whose key is employee code. Create a VSAM  file\n              of the output records.\n\n              //STEPS2  EXEC  HFSELECT,PARM='S,K=A,Y=C1C2D8E2E5,1,105'\n              //STEPCAT   DD  DSN=CATALOG,DISP=SHR\n              //VSAMKEY   DD  DSN=VSAM.FILE,DISP=SHR\n              //VSAMOUT   DD  DSN=VSAMOUT.FILE,DISP=SHR\n\n              Note: the Y= equate symbol parameter equates A, B, Q, S and V.\n              Hence, by  coding  the  key K=A, i.e., specifying that records\n              with  an  employee  code of A are to be selected, records with\n              any of the desired employee codes will be selected.\n\n\n              EXAMPLE S3\n\n              Select  all  records from a personnel file with non-alphabetic\n              employee  codes. End selection processing after record 10,000.\n              The employee code is a 1-byte field in position 105. Print all\n              the rejected records in hex format.\n\n              //STEPS3  EXEC  HFSELECT,PARM='SN,C=A,E=10000,1,105'\n              //SYSUT1    DD  Input file\n              //SYSUT2    DD  Selected records\n              //SYSUT3    DD  SYSOUT=*,DCB=RECFM=A\n\n\n                                HFSELECT EXAMPLES                   PAGE S-2\n\n\n              EXAMPLE S4\n\n              Select  all records from a welfare case history file where the\n              number of children in a family between the ages of 0 and 5, 10\n              and  15,  and  over  16 are all zero. The three fields are all\n              2-byte  binary  fields  and  begin  in  bytes  20,  25  and 30\n              respectively.\n\n              //STEPS4  EXEC  HFSELECT,PARM='S,C=L,2,20,2,25,2,30'\n              //SYSUT1    DD  Input file\n              //SYSUT2    DD  Selected records\n\n              Note: C=L denotes a key of low values which is binary zeros.\n\n\n              EXAMPLE S5\n\n              A  sequential  master  file  was created with a last record of\n              high  values in its first 20 bytes to indicate end-of-file. It\n              is  now  desired  to  add more records to this master file and\n              hence  as  a  first step to remove the high values record. The\n              JCL required is:\n\n              //STEPS5  EXEC  HFSELECT,PARM='S,C=H,20,1'\n              //SYSUT1    DD  Input master file\n              //SYSUT3    DD  master file with high values record deleted\n\n\n              EXAMPLE S6\n\n              Count  all records in a personnel file that have an M sex code\n              (male) and a D employment code (temporarily disabled). The sex\n              code is in byte 80 and the employment code is in byte 335.\n\n              //STEPS6  EXEC  HFSELECT,PARM='S,K=MD,1,80,1,335'\n              //SYSUT1    DD  Input file\n\n              Note:  no  output  files  will  be  created;  only  statistics\n              indicating  the  number  of  records  satisfying the selection\n              criteria will be generated.\n\n\n                                HFSELECT EXAMPLES                   PAGE S-3\n\n\n              EXAMPLE S7\n\n              Select  from  a welfare file all clients whose rent is $150.50\n              per  month. The rent field is a 4-byte field beginning in byte\n              30.\n\n              If the rent field is binary:\n\n              //STEPS7A  EXEC  HFSELECT,PARM='S,X=00003ACA,4,30'\n              //SYSUT1     DD  Input file\n              //SYSUT2     DD  Selected records\n\n              Note: 00003ACA is the hexadecimal equivalent of 15050.\n\n              If the rent field is packed:\n\n              //STEPS7A  EXEC  HFSELECT,PARM='S,P=+15050,4,30'\n              //SYSUT1     DD  Input file\n              //SYSUT2     DD  Selected records\n\n              Note:  the  +  in  P=+15050  is  not  necessary since + is the\n              default.\n\n              EXAMPLE S8\n\n              Select  from  a welfare file all clients whose rent is greater\n              than $150.50 per  month. The rent field  is  a  4-byte  packed\n              field beginning in byte 30.\n\n              //STEPS8   EXEC  HFSELECT,PARM='S,P=>15050,4,30'\n              //SYSUT1     DD  Input file\n              //SYSUT2     DD  Selected records\n\n              EXAMPLE S9\n\n              It is necessary to staff a project with 5 people  who  satisfy\n              the following criteria: they must be managers,  have  computer\n              skills, know the COBOL language, and speak Spanish.  To choose\n              these people, four fields in an employee file must be searched\n              for specific values:\n\n                 TITLE field    - length of 1 in position 10, value M,\n                 SKILL field    - length of 2 in position 20, value 'C ',\n                 SOFTWARE field - length of 3 in position 25, value COB,\n                 LANGUAGE field - length of 1 in position 45, value S.\n\n              Four selection fields have been specified but only 3 L,P pairs\n              may be coded in the HFSELECT PARM. An input  record processing\n              exit may be written so that at least two fields are contiguous\n              prior to HFSELECT processing of the  record.  In this example,\n              all four fields will be made contiguous in the last 7 bytes of\n              the record and only one L,P pair  need  be  coded.  The  input\n              record processing exit may be written in COBOL as follows:\n\n\n                                HFSELECT EXAMPLES                   PAGE S-4\n\n\n           ID DIVISION.\n           PROGRAM-ID. REFORMAT.\n           ENVIRONMENT DIVISION.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  INPUT-RECORD.\n               05  FILLER            PIC X(09).\n               05  TITLE-FIELD       PIC X(01).\n               05  FILLER            PIC X(09).\n               05  SKILL-FIELD       PIC X(02).\n               05  FILLER            PIC X(03).\n               05  SOFTWARE-FIELD    PIC X(02).\n               05  FILLER            PIC X(18).\n               05  LANGUAGE-FIELD    PIC X(01).\n               05  FILLER            PIC X(28)\n               05  CONTIG-FIELD.\n                   10 CONTIG-TITLE   PIC X(01).\n                   10 CONTIG-SKILL   PIC X(02).\n                   10 CONTIG-SOFTW   PIC X(03).\n                   10 CONTIG-LANG    PIC X(01).\n           PROCEDURE DIVISION USING INPUT-RECORD.\n               MOVE TITLE-FIELD     TO CONTIG-TITLE.\n               MOVE SKILL-FIELD     TO CONTIG-SKILL.\n               MOVE SOFTWARE-FIELD  TO CONTIG-SOFTW.\n               MOVE LANGUAGE-FIELD  TO CONTIG-LANG.\n               MOVE 0 TO RETURN-CODE.\n               GOBACK.\n\n               The above COBOL program is then compiled and link-edited into\n               a load library, EXIT.LOADLIB, with the member name  REFORMAT.\n               The following JCL will then perform the requested  selection,\n               with the selected records printed in HEX format.\n\n              //STEPS9  EXEC  HFSELECT,PARM='S,K=MC COBS,J=5,7,74'\n              //SYSUT1    DD  input file\n              //SYSUT2    DD  SYSOUT=*\n              //EXITMOD   DD  DSN=EXIT.LOADLIB,DISP=SHR\n              //EXITS     DD  *\n              I1=REFORMAT,EXITMOD\n              X0\n               FORMAT=HEX\n              //\n\n              The S option key is now coded as a single L,P pair with length\n              seven in position 74. Refer to Appendix  D  for  a explanation\n              of the EXITS and EXITMOD DD statements  and  for  the  control\n              statements contained in the EXITS file.\n\n\n                                HFSELECT EXAMPLES                   PAGE T-1\n\n\n           EXAMPLE T1\n\n           Select  5  records  for each of the following Manhattan zip codes\n           from a Manhattan address file: 10023, 10010, 10033, 10099, 10072,\n           10053. The zip code starts in byte 51.\n\n           //STEPT1  EXEC  HFSELECT,PARM='T,J=5,5,51'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Selected records\n           //SYSIN     DD  *\n           10023\n           10010\n           10033\n           10099\n           10072\n           10053\n           /*\n\n           Note  that  neither  the  input  file nor the key file need be in\n           sequence.\n\n           EXAMPLE T2\n\n           Select all records from a personnel file that have a D employment\n           code (temporary disabled) AND an R status code (regular) AND an O\n           salary  code  (overtime  allowed)  OR  have  an O employment code\n           (on-leave)  AND a P status code (provisional) AND a C salary code\n           (compensatory-time   allowed)   OR  have  an  H  employment  code\n           (half-time) AND a C status code (consultant) AND an N salary code\n           (no overtime). The three  fields  are located in bytes 23, 77 and\n           91 respectively.\n\n           //STEPT2  EXEC  HFSELECT,PARM='T,1,23,1,77,1,91'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Selected records\n           //SYSIN     DD  *\n           DRO\n           OPC\n           HCN\n           /*\n\n\n                                HFSELECT EXAMPLES                   PAGE T-2\n\n\n           EXAMPLE T3\n\n           Select 10,000 records, from a Manhattan address file, that do not\n           contain  the  zip  codes  10011,  10017,  10027, 10039, 10045 and\n           10068. The zip code starts in byte 51.\n\n           //STEPT3  EXEC  HFSELECT,PARM='TN,J=10000,5,51'\n           //SYSUT1    DD  Input file\n           //SYSUT2    DD  Selected records\n           //SYSIN     DD  *\n           10011\n           10017\n           10027\n           10039\n           10045\n           10068\n           /*\n\n           EXAMPLE T4\n\n           A   5000-record   disk   file  contains  validation  information,\n           including  valid 25-byte budget line codes which start in byte 10\n           of the record, against which a transaction file is to be matched.\n           Those  transaction records with valid budget line codes are to be\n           selected, with  all  others  to  be put out to a reject file. The\n           budget  line  codes  in  the  transaction  file start in byte 21.\n           Neither file is necessarily sorted by budget line code.\n\n           //STEPT4  EXEC  HFSELECT,PARM='TL,V=(25,10),25,21'\n           //SYSUT1    DD  transaction file\n           //SYSIN     DD  5000 record disk file\n           //SYSUT2    DD  Selected records from the transaction file\n           //SYSUT3    DD  Rejected records from the transaction file\n           //EXITS     DD  *\n           X0\n            TABLESIZE=145000\n           //\n\n           The V=(25,10)  parameter gives the length and position of the key\n           in the SYSIN file.\n           Since the number of keys in the SYSIN file  exceeds  the  default\n           maximum  (24000 / (25 + 4) = 827)  the  TABLESIZE  initialization\n           control statement in the X0 exit must be used. See section  D.2.4\n           for details.\n\n\n                                HFSELECT EXAMPLES                   PAGE V-1\n\n\n           EXAMPLE V1\n\n           Create a file of all data set names belonging to USER01 on volume\n           APPLDA.\n\n           //STEPV1  EXEC HFSELECT,PARM='V'\n           //VREPORT1  DD DSN=USER01.DATALIST,DISP=(,CATLG),UNIT=SYSDA,\n           //             SPACE=(TRK,(1,1)),DCB=BLKSIZE=23400\n           //VSYSIN    DD *\n           VOL=APPLDA\n           USER01.*\n           /*\n\n           VREPORT1  will  contain  one  record  for each data set on APPLDA\n           whose high order qualifier is USER01.\n\n           EXAMPLE V2\n\n           List  all  userid.SOURCE.COBOL  data  sets  on volumes VOL001 and\n           VOL002.\n\n           //STEPV2  EXEC HFSELECT,PARM='V'\n           //VREPORT1  DD SYSOUT=*,DCB=BLKSIZE=8000\n           //VSYSIN    DD *\n           VOL=VOL001,VOL002\n           %SOURCE.COBOL\n           /*\n\n           Note  that  the  percent  sign  is a wild card that automatically\n           matches all high order qualifiers.\n\n           EXAMPLE V3\n\n           Create a member list from PDSs USER01.PROCLIB  and USER02.PROCLIB\n           of all members created after January, 1986 on volume MYVOL1.\n\n           //STEPV3  EXEC HFSELECT,PARM='V,N=>86032,5,64'\n           //VREPORT1  DD SYSOUT=*,DCB=BLKSIZE=100\n           //VSYSIN    DD *\n           VOL=MYVOL1\n           USER01.PROCLIB(*)\n           USER02.PROCLIB(*)\n           /*\n\n           Note  that  an  asterisk in the first position of the member name\n           requests  all  members  of the library. The creation date is a  5\n           byte numeric field starting in position 64 of the output record.\n\n\n                                HFSELECT EXAMPLES                   PAGE V-2\n\n\n           EXAMPLE V4\n\n           Create  a  file  with  the names of all data sets with the prefix\n           USERxx on all work volumes WORKnn.\n\n           //STEPV4  EXEC HFSELECT,PARM='V'\n           //VREPORT1  DD DSN=USER01.DATALIST,DISP=(,CATLG),UNIT=SYSDA,\n           //             SPACE=(TRK,(5,1)),\n           //             DCB=BLKSIZE=3200\n           //VSYSIN    DD *\n           VOL=WORK*\n           USER++.*\n           /*\n\n           EXAMPLE V5\n\n           Create  a  file  with  the  first 100 names of data sets with the\n           prefix  USERxx and the  first  100  names  of  data  sets  having\n           the character string SOURCE anywhere in their dsn on all volumes.\n\n           //STEPV5  EXEC HFSELECT,PARM='V,J=100'\n           //VREPORT1  DD DSN=USER01.DATALIST,DISP=(,CATLG),UNIT=SYSDA,\n           //             SPACE=(TRK,(5,1)),\n           //             DCB=BLKSIZE=3200\n           //VSYSIN    DD *\n           VOL=*\n           USER++.*\n           !SOURCE!\n           /*\n\n           Note that the J=100 means that up to 100 names will be output for\n           each  dsn VSYSIN record. VOL=* requests a search of every on-line\n           DASD   volume.  The  output  file  will  not  necessarily  be  in\n           alphabetical order by dsn.\n\n           EXAMPLE V6\n\n           Create  a file containing every member name of every PDS on every\n           volume,  and  also  with  every  data  set  name on every volume.\n           Suppress printing the catalog indicator to improve performance.\n\n           //STEPV6  EXEC HFSELECT,PARM=V\n           //VREPORT1  DD DSN=USER01.DATALIST,DISP=(,CATLG),UNIT=SYSDA,\n           //             SPACE=(CYL,(50,10),RLSE),\n           //             DCB=BLKSIZE=23400\n           //VSYSIN    DD *\n           VOL=*\n           *(*)\n           *\n           /*\n           //EXITS    DD *\n           X0\n            NOCATCK\n           //\n\n\n                                HFSELECT EXAMPLES                   PAGE V-3\n\n\n           EXAMPLE V7\n\n           Create a file containing names of members of PDS TEST.LOADLIB, on\n           volume TEST01, that have aliases.\n\n           //STEPV7  EXEC HFSELECT,PARM='V,K=1,1,59'\n           //VREPORT1  DD DSN=SELECT,DISP=(,KEEP),UNIT=SYSDA,\n           //             SPACE=(CYL,(5,1),RLSE),\n           //             DCB=BLKSIZE=19000\n           //VREPORT2  DD DSN=REJECT,DISP=(,KEEP),UNIT=SYSDA,\n           //             SPACE=(CYL,(5,1),RLSE),\n           //             DCB=BLKSIZE=19000\n           //VSYSIN    DD *\n           VOL=TEST01\n           TEST.LOADLIB(*)\n           /*\n           //\n\n           This job first creates the record in the  output format for  each\n           dsn that satisfies the criteria in VSYSIN. It outputs this record\n           to VREPORT1 if it meets the key criteria in the  PARM and outputs\n           the rejected records to VREPORT2. Note that an alias is indicated\n           by a 1 in position 59 of the created record.\n\n                            V OPTION - Catalog search EXAMPLES\n\n           EXAMPLE V8\n\n           Create  a  file  containing names of all catalogued datasets with\n           the prefix  USER001  and  all cataloged production datasets whose\n           second order qualifier is 8 characters beginning with HFS.\n\n           //STEPV8  EXEC HFSELECT,PARM='V'\n           //VREPORT1  DD DSN=SELECT,DISP=(,KEEP),UNIT=SYSDA,\n           //             SPACE=(CYL,(5,1),RLSE),\n           //             DCB=BLKSIZE=19000\n           //VSYSIN    DD *\n           USER001.*\n           PROD.HFS+++++.*\n           /*\n           //\n\n\n                                HFSELECT EXAMPLES                   PAGE V-4\n\n\n           EXAMPLE V9\n\n           List all statements containing UNIT=3350 in   procedure libraries\n           with the format xxx.PROCLIB.  Precede  each  print group with its\n           PDS library name.\n\n           //STEPV9  EXEC HFSELECT,PARM='V',REGION=3000K\n           //VREPORT1  DD SYSOUT=*,DCB=BLKSIZE=100\n           //VSYSIN    DD *\n           'E,4,71'      this is the sub-task parm field\n           VOL=*\n           %PROCLIB\n           /*\n           //SYSIN    DD *\n           XUNIT=3350X\n           //\n\n           EXAMPLE V10\n\n           List the first statement with the ddname  SORTOUT,  together with\n           the 4 records following the  statement in all members of all proc\n           libraries xxx.PROCLIB in the system.  Break on member name.\n\n           //STEPV10 EXEC HFSELECT,PARM='V',REGION=3000K\n           //VSYSIN    DD *\n           'D,K=SORTOUT,J=+4,7,3'\n           VOL=*\n           %PROCLIB(*)\n           /*\n\n\n           EXAMPLE V11\n\n           Find and print out all members MYMEMB  and YOURMEMB in all of  my\n           libraries on VOL001 and VOL002.\n\n           //STEPV11 EXEC HFSELECT,PARM='V',REGION=3000K\n           //VREPORT1  DD SYSOUT=*,DCB=BLKSIZE=100\n           //VSYSIN    DD *\n           'R,1,1'\n           VOL=VOL001,VOL002\n           MYUSERID.*\n           /*\n           //MEMSYSIN  DD *\n           MYMEMB\n           YOURMEMB\n           /*\n\n\n                                HFSELECT EXAMPLES                   PAGE V-5\n\n\n           EXAMPLE V12\n\n           Find and print out all members MYMEMB  and YOURMEMB in all of  my\n           catalogued libraries.\n\n           //STEPV12 EXEC HFSELECT,PARM='V',REGION=3000K\n           //VREPORT1  DD SYSOUT=*,DCB=BLKSIZE=100\n           //VSYSIN    DD *\n           'R,1,1'\n           MYUSERID.*\n           /*\n           //MEMSYSIN  DD *\n           MYMEMB\n           YOURMEMB\n           /*\n\n           EXAMPLE V13\n\n           Create  a  data  set  containing the  first three records of each\n           member of a catalogued library.\n\n           //STEPV13 EXEC HFSELECT,PARM='V',REGION=3000K\n           //VREPORT1  DD SYSOUT=*,DCB=BLKSIZE=100\n           //SYSUT2    DD DSN=MYUSERID.JOBCARDS,DISP=MOD\n           //VSYSIN    DD *\n           'R,J=3,1,1'\n           MYUSERID.PDS(*)\n           //\n\n           NOTE:  VREPORT1 will contain the output  from the  V option  main\n           task only. The  SYSUT2 DD data set will contain the output of the\n           attached subtasks; the first three records of each member of  the\n           PDS.  DISP=MOD  must  be  coded  on the SYSUT2 DD as each subtask\n           reopens the data set.\n\n           EXAMPLE V14\n\n           Copy  all  non-VSAM  data  sets  on  DASD volume IBM100 to volume\n           IBM200.\n\n           //STEP14  EXEC HFSELECT,PARM=V,REGION=3000K\n           //SYSPRINT  DD SYSOUT=*\n           //DISK      DD UNIT=SYSDA,DISP=SHR,VOL=SER=IBM200\n           //VREPORT1  DD SYSOUT=*,DCB=BLKSIZE=100\n           //VSYSIN  DD  *\n           ''\n           VOL=IBM100\n           *\n           /*\n\n           Note: The  data sets will be created and copied on volume IBM200.\n                 They  will  have  the same DSNs and  formats  as  those  on\n                 volume  IBM100.   DSNs  already existing on IBM200 will not\n                 be overlaid. The output data sets will not be catalogued.\n\n\n                                HFSELECT EXAMPLES                   PAGE V-6\n\n\n           EXAMPLE V15\n\n           Copy all non-VSAM data sets  on DASD volume  IBM100 that have the\n           prefix USERID1 and a second qualifier  beginning with S to volume\n           IBM200.  None of the PDSs have more than 50 members.  Catalog the\n           newly created data sets and uncatalog the old.\n\n           //STEP14  EXEC HFSELECT,PARM=V,REGION=3000K\n           //SYSPRINT  DD SYSOUT=*\n           //DISK      DD UNIT=SYSDA,DISP=SHR,VOL=SER=IBM200\n           //VREPORT1  DD SYSOUT=*,DCB=BLKSIZE=100\n           //EXITS  DD  *\n           X0\n            VDIRBLKS=10\n            RECAT\n           /*\n           //VSYSIN  DD  *\n           ''\n           VOL=IBM100\n           USERID1.S*\n           /*\n\n           Note: Since the PDSs copied have less than 50 members an exit has\n                 been  coded  that  reduces  the default number of directory\n                 blocks (100) to 10. RECAT causes the required cataloging.\n\n\n           EXAMPLE V16\n\n           Compress all catalogued PDSs with prefixes USERID1, USERID2,  and\n           USERID3.\n\n           //STEP1   EXEC HFSELECT,PARM='V,K=P,1,59',REGION=3000K\n           //SYSPRINT  DD SYSOUT=*\n           //SYSPRIN2  DD SYSOUT=*\n           //VREPORT1  DD SYSOUT=*,DCB=BLKSIZE=100\n           //VSYSIN  DD  *\n           ''/IEBCOPY\n           USERID1.*\n           USERID2.*\n           USERID3.*\n           /*\n           //SYSIN  DD  *\n            COPY I=LIBFILE,O=LIBFILE\n           /*\n\n           Note: This example calls the IBM Utility Program IEBCOPY for  the\n                 attached  subtasks.  SYSPRIN2   will  contain  the  IEBCOPY\n                 messages. Note that  each  PDS selected is allocated by the\n                 primary task to a DDname LIBFILE.\n\n\n                                HFSELECT EXAMPLES                   PAGE V-7\n\n           EXAMPLE V17\n\n           Copy  the  first  six data sets on volume DISK01 whose high order\n           qualifiers begin  with  USER  and  whose LRECL=80, whether PDS or\n           Sequential.\n\n           //STEP1   EXEC HFSELECT,PARM='V,N=80,J=6,5,63',REGION=3000K\n           //SYSPRINT  DD SYSOUT=*\n           //VREPORT1  DD SYSOUT=*,DCB=BLKSIZE=100\n           //LIBV0001  DD DSN=USER001.PDS,DISP=SHR\n           //LIBV0002  DD DSN=USER002.PDS,DISP=SHR\n           //LIBV0003  DD DSN=USER003.PDS,DISP=SHR\n           //LIBV0004  DD DSN=USER004.PDS,DISP=SHR\n           //LIBV0005  DD DSN=USER005.PDS,DISP=SHR\n           //LIBV0006  DD DSN=USER006.PDS,DISP=SHR\n           //SYSV0001  DD DSN=USER001.SEQ,DISP=SHR\n           //SYSV0002  DD DSN=USER002.SEQ,DISP=SHR\n           //SYSV0003  DD DSN=USER003.SEQ,DISP=SHR\n           //SYSV0004  DD DSN=USER004.SEQ,DISP=SHR\n           //SYSV0005  DD DSN=USER005.SEQ,DISP=SHR\n           //SYSV0006  DD DSN=USER006.SEQ,DISP=SHR\n           //SYSIN  DD  DUMMY\n           //VSYSIN  DD  *\n           ''\n           VOL=DISK01\n           USER*\n           /*\n           //\n\n           EXAMPLE V18\n\n           Copy  all  catalogued  PDSs  with  prefixes USERID1, USERID2, and\n           USERID3 to volume IBM200 using the IBM utility IEBCOPY.\n\n           //STEP1   EXEC HFSELECT,PARM='V,K=P,1,59',REGION=3000K\n           //SYSPRINT  DD SYSOUT=*\n           //VREPORT1  DD SYSOUT=*,DCB=BLKSIZE=100\n           //DISK      DD UNIT=SYSDA,DISP=SHR,VOL=SER=IBM200\n           //VSYSIN  DD  *\n           ''/IEBCOPY\n           USERID1.*\n           USERID2.*\n           USERID3.*\n           /*\n           //SYSIN  DD  *\n            COPY I=LIBFILE,O=LIBV0000\n           /*\n\n           Note: This example calls the IBM Utility Program IEBCOPY  for the\n                 attached  subtasks.  SYSPRIN2 will be dynamically allocated\n                 and  will  contain the IEBCOPY messages. Note that each PDS\n                 selected  is  allocated  by  the  primary  task to a DDname\n                 LIBFILE and the output PDS are allocated to the DDname\n                 LIBV0000.\n\n\n                                HFSELECT EXAMPLES                 PAGE TSO-1\n\n           In the  following examples it is assumed that the CLIST described\n           in the HFSELECT REFERENCE GUIDE, Appendix C, is in member  SELECT\n           of the PDS USER.CLIST and that the program load module resides in\n           the library LOADLIB under the name HFSELECT. It is  also  assumed\n           that the PARM field prompt \u00dd14\u00a8 is  ENTER  PARM FIELD,  that  the\n           DISPositions of all the output data sets  are coded  OLD and that\n           the library USER.CLIST has been ALLOCated to the ddname SYSPROC.\n\n           EXAMPLE TSO1\n\n           Copy  every  tenth  record  from  the  ISAM  file ALLCASES to the\n           sequential disk file userid.TESTCASE.\n\n            SELECT   INPUTDSN('''ALLCASES''')       +\n                     SYSUT2(TESTCASE),INPUTYPE(ISAMFILE)\n\n           When  the  prompt  ENTER  PARM  FIELD  appears on the screen type\n           'R,1,10' and press the ENTER key.\n\n\n           EXAMPLE TSO2\n\n           Perform EXAMPLE M5 using TSO, with n=10\n\n                SELECT   INPUTDSN('''ALLCASES''')        +\n                         SYSUT2('''SELECTED.OUTPUT.RECORDS''')    +\n                         SYSUT3('''REJECTED.OUTPUT.RECORDS''')    +\n                         SYSUT4('''SYSIN.MATCHED.RECORDS''')      +\n                         SYSUT5('''SYSIN.NOTMTCHD.RECORDS''')     +\n                         SYSIN('''INPUT2.FILE''')\n\n           When    ENTER   PARM   FIELD   appears   on   the   screen   type\n           'M,V=(1,9),J=10,1,4' and press the ENTER key.\n\n\n                                HFSELECT EXAMPLES                 PAGE   X-1\n\n           EXAMPLE X1\n\n                Following is the additional JCL for HFSELECT to invoke\n           record processing input and output exits:\n\n                            //EXITS    DD *\n                            O1=EXITSEL1,LOADLIB1\n                            O3=EXITSEL3,LOADLIB1\n                            O2=EXITSEL1\n                            OM=EXITM,LOADLIB4\n                            O4=EXITSEL4,LOADLIB4\n                            I1=EXITSEL0\n                            //LOADLIB1 DD DSN=loadlib1,DISP=SHR\n                            //LOADLIB4 DD DSN=loadlib4,DISP=SHR\n\n           EXAMPLE X2\n\n                The following is an example  of  a COBOL exit program with a\n           fixed length record file.\n\n           ID DIVISION.\n           PROGRAM-ID. EXITESTC.\n           ENVIRONMENT DIVISION.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  SELECTED-RECORD.\n               05  FIRST-FOUR-BYTES  PIC X(4).\n               05  NEXT-FOUR-BYTES   PIC X(4).\n               05  FILLER            PIC X(72).\n           PROCEDURE DIVISION USING SELECTED-RECORD.\n               MOVE NEXT-FOUR-BYTES TO FIRST-FOUR-BYTES.\n               MOVE 0 TO RETURN-CODE.\n               GOBACK.\n\n\n                                HFSELECT EXAMPLES                 PAGE   X-2\n\n           EXAMPLE X3\n\n                The  following  is an example of a COBOL output exit program\n           processing  a  variable  length record.  This program removes the\n           last four bytes from the record, by reducing the binary RDW by 4.\n           The record length is thus  changed from 84 to 80. Any record that\n           has less than 5 data bytes (9 bytes including  RDW)  is  deleted.\n           Note that the LRECL defined in the JCL need not be changed.\n\n           ID DIVISION.\n           PROGRAM-ID. EXITESTV.\n           ENVIRONMENT DIVISION.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  SELECTED-RECORD.\n               05  RECORD-RDW         PIC 9(4)  COMP.\n               05  FILLER-REST-OF-RDW PIC X(2).\n               05  FILLER             PIC X(76).\n               05  LAST-FOUR-BYTES    PIC X(4).\n           PROCEDURE DIVISION USING SELECTED-RECORD.\n               IF RECORD-RDW LESS THAN 9\n                  MOVE 4 TO RETURN-CODE\n                  ELSE\n                    SUBTRACT 4 FROM RECORD-RDW\n                    MOVE 0 TO RETURN-CODE.\n               GOBACK.\n\n           EXAMPLE X4\n\n                The following is an example of an ASSEMBLER exit program.\n           This program copies bytes 3 and 4 of each record into positions 1\n           and 2.\n\n           EXITEST  CSECT\n                    USING *,12          ASSIGN BASE REGISTER\n                    STM   14,12,12(13)  SAVE REGISTERS\n                    LR    12,15         LOAD BASE REGISTER\n                    ST    13,SAVEAREA+4 *\n                    LR    11,13         *\n                    LA    13,SAVEAREA   * SAVE AREA CHAINING\n                    ST    13,8(11)      *\n                    L     1,0(1)\n                    LR    3,1           RECORD ADDR\n                    MVC   0(2,3),2(3)   MOVE BYTES 3 AND 4 TO POS. 1 AND 2\n                    L     13,SAVEAREA+4 RESTORE R13\n                    RETURN (14,12),RC=0 RELOAD REGS AND RETURN TO HFSELECT\n           SAVEAREA DS    18F\n                    END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUPRDUMP": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x016\\x00\\x00\\x00\\x91%_\\x00\\x95\\x02\\x0f\\t5\\t\\x9b\\x08\\x9c\\x00\\x00\\xc3\\xd5\\xf0\\xf3\\xd5\\xd1\\xd3@@@'", "ispf": {"version": "01.54", "flags": 0, "createdate": "1991-09-12T00:00:00", "modifydate": "1995-01-20T09:35:00", "lines": 2459, "newlines": 2204, "modlines": 0, "user": "CN03NJL"}, "text": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         SSSS   UU  UU  PPPPP   RRRRR   DDDDD   UU  UU  MMM    MMM  PPPPP\n        SSSSSS  UU  UU  PPPPPP  RRRRRR  DDDDDD  UU  UU  MM M  M MM  PPPPPP\n        SS   S  UU  UU  PP  PP  RR  RR  DD  DD  UU  UU  MM M  M MM  PP  PP\n        SS      UU  UU  PP  PP  RR  RR  DD  DD  UU  UU  MM M  M MM  PP  PP\n        SS      UU  UU  PP  PP  RR  RR  DD  DD  UU  UU  MM  MM  MM  PP  PP\n         SS     UU  UU  PPPPP   RRRRR   DD  DD  UU  UU  MM  MM  MM  PPPPP\n          SS    UU  UU  PP      RRR     DD  DD  UU  UU  MM      MM  PP\n           SS   UU  UU  PP      RR R    DD  DD  UU  UU  MM      MM  PP\n           SS   UU  UU  PP      RR  R   DD  DD  UU  UU  MM      MM  PP\n       S   SS   UU  UU  PP      RR  RR  DD  DD  UU  UU  MM      MM  PP\n       SSSSSS   UUUUUU  PP      RR  RR  DDDDDD  UUUUUU  MM      MM  PP\n        SSSS     UUUU   PP      RR  RR  DDDDD    UUUU   MM      MM  PP\n\n\n\n\n\n\n\n\n\n\n\n                                                    RELEASE  3.3  01/21/93\n\n                                                             MORRIS KARLIN\n                                                            NORMAN LINDNER\n\n      (C) COPYRIGHT JUNE 1984 BY M. KARLIN, N. LINDNER\n\n\n\n                              SUPRDUMP                      Contents   i\n\n                         TABLE OF CONTENTS\n                                                     PAGE\n\n             SUMMARY OF AMENDMENTS                     ii\n\n             PREFACE                                   iv\n\n             INTRODUCTION                               v\n\n        1.   PROGRAMMING NOTES                        1-1\n\n        2.   SYSTEM CONFIGURATION                     2-1\n\n        3.   GUIDE TO SUPRDUMP FUNCTIONS              3-1\n\n        4.   INSTALLATION PROCEDURES                  4-1\n\n        5.   JCL AND PARM FIELD                       5-1\n\n             5.1.  BLOCK COUNT PARAMETER              5-3\n             5.2.  PRINT FORMAT PARAMETER             5-3\n             5.3.  NUMBER OF FILES PARAMETER          5-5\n             5.4.  GROUP LENGTH PARAMETER             5-6\n             5.5.  SKIP PARAMETER                     5-6\n             5.6.  TITLE PARAMETER                    5-6\n             5.7.  DIAGNOSTICS PARAMETER              5-7\n\n        6.   FILES                                    6-1\n\n             6.1.  INPUT FILE - SYSUT1                6-1\n             6.2.  OUTPUT PRINT FILE - SYSUT2         6-2\n             6.3.  STATISTICS FILE - SYSPRINT         6-2\n             6.4.  OUTPUT TAPE - TAPECOPY             6-3\n             6.5.  OTHER FILES                        6-4\n             6.6.  DIAGNOSTICS FILE - DIAGNOSE        6-4\n\n        7.  EXAMPLES                                  7-1\n\n        8.  MESSAGES                                  8-1\n\n            8.1   NUMBERED MESSAGES                   8-1\n            8.2   UNNUMBERED MESSAGES                8-11\n\n        9.  APPENDIX A - QUICK REFERENCE CHART        A-1\n\n       10.  APPENDIX B - TSO (ON-LINE) CONSIDERATIONS B-1\n\n       11.  APPENDIX C - BIBLIOGRAPHY                 C-1\n\n       12.  GLOSSARY                                  G-1\n\n       13.  INDEX                                     I-1\n\n\n                              SUPRDUMP                  Amendments     ii\n\n                       SUMMARY OF AMENDMENTS\n\n     RELEASE 3.3                                              01/21/93\n\n       SUPRDUMP now provides a TSO/E ISPF/PDF  dialog  that allows on-line\n       access to all SUPRDUMP  message text and explanations.\n\n       The installation procedure has been enhanced and streamlined.\n\n     RELEASE 3.2                                              09/09/92\n\n       One output file has been added. The ddname is:\n         DIAGNOSE-  Diagnostic output for all tape reads.\n\n       An additional keyword parameter D= has  been  added to  control\n       output directed to the DIAGNOSE file.\n\n       Release 6.07 of SAS,  the  addition  of  three DD statements, and a\n       region  of  at  least  2500K  are  now required to use the TAPECOPY\n       function of SUPRDUMP.\n\n     RELEASE 3.1                                              02/06/92\n\n       SUPRDUMP now allows null (dummy) file  processing  for  tapes  when\n       using non-standard label processing.\n\n       Null or zero values are now allowed  in the PARM  parameters.  When\n       null or zero is specified, the parameter takes its default value.\n\n       If no R= parameter is coded in the PARM and the data set is  a disk\n       or SL tape, the R parameter defaults to the data set LRECL.\n\n       Message DMP027W has been added warning that  a tape file contains a\n       block whose BLKSIZE exceeds 32K. This file can  not be processed by\n       standard IBM access methods.\n\n       This documentation has been enhanced and repaged.\n\n\n                              SUPRDUMP                   Amendments  iii\n\n\n\n     RELEASE 3                                                07/22/91\n\n       An  additional subparameter, P,  has been added to the F= parameter\n       (print format) to limit the number  of  characters printed for each\n       block.\n\n       SUPRDUMP now  allows multi-volume and concatenated file processing.\n       Messages DMP025I and DMP026E have been added  in  support  of  this\n       function.\n\n       Support has been added for 3480 magnetic tape cartridge subsystems.\n\n       The title from the T= parameter is now displayed on each page.\n\n       SUPRDUMP is now an authorized program and must be installed  in  an\n       APF-authorized library.\n\n       Release 5.16 of SAS is required to use the TAPECOPY function.\n\n       Message DMP040I has  been  enhanced,  giving more information about\n       the disk or tape data sets that have been processed.\n\n       Message DMP021I has been added giving the approximate  tape  length\n       of each file processed. The approximate  total  tape  length of all\n       processed tape files is also displayed in message DMP023I.\n\n       Message DMP022I, listing the JOB name, the PROCSTEP  name  (if any)\n       and the STEP name has been added.\n\n       Message DMP024W has been  added  which  warns  that  an actual tape\n       block count does not match the block count  in  the  trailer label.\n       If such a tape data set were used in a program and read to the end,\n       an ABEND (IEC210I 214-10) would occur.\n\n       Numerous  editorial  changes  and  revisions  have been made to the\n       documentation for these changes  and  for  clarity. This supersedes\n       and  obsoletes  all  previous  editions of SUPRDUMP documentation.\n\n     RELEASE  2                                               11/01/87\n\n       The ability to copy tape-to-tape.\n\n       One output file has been added. The ddname is:\n\n         TAPECOPY-  The output tape which is an exact copy of SYSUT1.\n\n\n                              SUPRDUMP                       Preface    iv\n\n                                PREFACE\n\n              This  publication  provides a full description of the use of\n         the  utility  program  SUPRDUMP. A working knowledge of IBM OS/VS\n         JCL is required to understand this publication.\n\n              This publication consists of 13 parts:\n\n                1. Programming  notes,  which  contain  coding conventions\n                   used in coding the JCL and PARM statements.\n\n                2. A  Guide  to  SUPRDUMP functions,  which is a  table of\n                   parameters and  certain other file processing tasks.\n\n                3. System Configuration, which provides a general overview\n                   of system requirements.\n\n                4. Installation  Procedures, which  provides  the  JCL  to\n                   install the program SUPRDUMP.\n\n                5. A general description of the SUPRDUMP PARM and the JCL.\n\n                6. The input and output files used with SUPRDUMP.\n\n                7. Examples.\n\n                8. A complete listing of the messages produced by SUPRDUMP\n                   and their meaning.\n\n                9. Appendix A - A chart providing a quick reference  guide\n                   to SUPRDUMP.\n\n               10. Appendix B - TSO  considerations  for  users  executing\n                   SUPRDUMP on-line rather than in batch mode.\n\n               11. Bibliography.\n\n               12. Glossary  of special  terms  used in the description of\n                   the program operation.\n\n               13. Index.\n\n\n                              SUPRDUMP                      Introduction v\n\n                               INTRODUCTION\n\n              SUPRDUMP is an easy-to-use utility print program designed to\n\n               \u00ae copy an entire tape volume to one output tape volume\n\n               \u00ae print  datasets, in  whole  or in  part, from  any system\n                 storage  device.\n\n               \u00ae show  the characteristics  of  all  data  sets  on a tape\n                 volume, including  labels, formats (ASCII or EBCDIC)  and\n                 tapemarks for tapes with blocksizes of up to 65535 bytes.\n\n               \u00ae show  the  position  and  attributes  of  files,  and the\n                 position of tapemarks on tape volumes.\n\n               \u00ae print files in hex,  with simultaneous  interpretation of\n                 each character in both ASCII and EBCDIC format.\n\n              SUPRDUMP  is  parameter-driven, with the parameters coded in\n         the  PARM  of  the EXECute statement. All parameters are keywords\n         and all have defaults so that none need be explicitly specified.\n\n              Information messages displayed by the program are\n\n               \u00ae PARM coded on the EXECute statement\n\n               \u00ae Jobname, Stepname and Procstepname of SUPRDUMP job & step\n\n               \u00ae output tape characteristics and a summary of copied files\n\n               \u00ae DSN  coded on the input file (SYSUT1) DD statement\n\n               \u00ae maximum block size in the file\n\n               \u00ae minimum block size in the file (excluding the last block)\n\n               \u00ae size of the last block on the file\n\n               \u00ae total number of bytes in the file\n\n               \u00ae total number of blocks in the file\n\n               \u00ae for tape, the  sequence  number  of the file on the tape,\n                   the density, and the recording mode technique\n\n\n                              SUPRDUMP                     Introduction vi\n\n               \u00ae serial number  of the volume containing the file\n\n               \u00ae change in BLKSIZE messages (with relative block number)\n\n               \u00ae RECFM and LRECL of each data set\n\n               \u00ae Creation and Expiration dates\n\n               \u00ae Approximate tape length of each tape file, and the\n                   approximate total tape length of all processed files\n\n              The SYSUT1 input file record formats may be fixed, variable,\n         undefined, blocked, spanned, standard or any valid combination of\n         these formats,  but  the  file must  be physical sequential.  The\n         RECFM, LRECL and BLKSIZE of these files need not be known before-\n         hand.  One  file  in  print  format (SYSUT2) is generated and one\n         output tape volume may be created (TAPECOPY). The printout can be\n         in any one  of five display  formats. Variable-length records can\n         be  printed  in  readable  form.  It shows all bytes of the block\n         including the BDW and the RDW if any.\n\n              An  optional output file can  be coded to capture status and\n         sense bytes from reads of tape/cartridge data sets.\n\n\n                              SUPRDUMP               Programming Notes 1-1\n\n                         \u00fc1 PROGRAMMING NOTES\n\n              The  formats of the parameters described in this publication\n         and  the  notations used in the format descriptions are described\n         below:\n\n                1. Uppercase letters and words written in  uppercase  must\n                   be  coded in  the  JCL  exactly  as  they appear in the\n                   format descriptions. The following characters must also\n                   be coded  exactly  as they appear in the descriptions:\n\n                   ampersand      &\n                   asterisk       *\n                   comma          ,\n                   equal sign     =\n                   parentheses    ()\n                   apostrophe     '\n\n                2. Lowercase  letters,  words  and  symbols  appearing  in\n                   the format description represent  variables  for  which\n                   specific information is substituted when the  parameter\n                   is coded.\n\n                       For example, C=count is the format description  for\n                   the C= parameter. When you code the C  parameter in the\n                   PARM  field,  you  substitute  a  number for  the  word\n                   \"count\"; e.g., C=44056.\n\n                3. Brackets \u00dd\u00a8 are a special notation and  are never coded\n                   in  the  JCL or  the PARM field. Brackets indicate that\n                   the enclosed item  or items are  optional  and you  can\n                   code one or none of the items.\n\n                       For example,  \u00dd,S=skip\u00a8   is  part  of  the  format\n                   description of the PARM field. When  you code the  PARM\n                   field,  you can include  ,S=skip   in the PARM field or\n                   omit it.\n\n                4. Verticals | are a special notation and  are never coded\n                   in  the  JCL or the PARM field. Verticals indicate that\n                   only one of the items adjacent to the verticals may  be\n                   coded. E. g., A|B|C|H|R means that either A, B, C, H or\n                   R may be chosen as a value of the parameter.\n\n                5. Braces \u00bb\u00ba  are a special  notation and  are never coded\n                   in the JCL or the  PARM field.  Braces indicate that at\n                   least one of the items in the  braces  must  be  coded.\n                   E. g., F=\u00bbA|B|C|H|R\u00ba means that if F= is coded,  either\n                   A, B, C, H or R must be coded.\n\n\n                              SUPRDUMP            System Configuration 2-1\n\n                        \u00fc2 SYSTEM CONFIGURATION\n\n              The  program SUPRDUMP is designed for any IBM  MVS operating\n         system.  Any tape, disk or unit record device allowed  on  an MVS\n         operating system is compatible with the program SUPRDUMP.\n\n              SUPRDUMP consists of one load  module which  requires 10K of\n         core for the basic SUPRDUMP program, plus a dynamic allocation of\n         64K. If the tape copy function is being  utilized, an  additional\n         2500K is required.\n\n              In  addition  to this core requirement, for disk files only,\n         buffer  areas  are required for all input data sets. The size and\n         number  of these areas vary, depending on the BLKSIZE of the data\n         sets  and  the  BUFNO (the number of buffers assigned) parameters\n         used.\n\n              Additional core for buffers is required for  any  additional\n         files (SYSPRINT, SYSUT2, DIAGNOSE) used.\n\n              The  program  is  written  in  ASSEMBLER  Language  and  was\n         assembled under ASSEMBLER H.\n\n              The tape copy feature of SUPRDUMP  is available only if  the\n         SAS software product Release 6.07 (distributed  by  SAS Institute\n         Inc.,  Cary,  N. C. 27511)  is  installed  on the system. The SAS\n         module invoked in SUPRDUMP is SAS370,  the entry module specified\n         in the bundled MVS/370 non-LPA configuration of SAS.  This module\n         is in the SAS load library.\n\n\n                              SUPRDUMP            Guide to Functions  3-1\n\n                    \u00fc3 GUIDE TO SUPRDUMP FUNCTIONS\n\n           _____________________________________________________________\n          |          |                                        |         |\n          |OPERATION |             DESCRIPTION                |PARAMETER|\n          |__________|________________________________________|_________|\n          |__________|________________________________________|_________|\n          |          |                                        |TAPECOPY |\n          | COPY     | an entire tape volume to one output    |   DD    |\n          |          | tape volume                            |statement|\n          |__________|________________________________________|_________|\n          |          |                                        |DIAGNOSE |\n          | DIAGNOSE | tape I/O read functions                |   DD    |\n          |          |                                        |statement|\n          |__________|________________________________________|_________|\n          |          |                                        |         |\n          | DISPLAY  | labels of tape files                   |  JCL    |\n          |__________|________________________________________|_________|\n          |          |                                        |         |\n          | LIST     | data set attributes                    |automatic|\n          |__________|________________________________________|_________|\n          |          | sequential disk or tape files in       |         |\n          |          |character and/or hex and/or ASCII format|F=format |\n          | PRINT    |________________________________________|_________|\n          |          | sequential disk or tape files with     |         |\n          |          | IBM variable record format             |   R=V   |\n          |          |________________________________________|_________|\n          |          | a specified number of blocks from a    |         |\n          |          | file                                   | C=nnn   |\n          |          |________________________________________|_________|\n          |          | a specified number of blocks           |         |\n          |          | reading a tape file backwards          | C=-nnn  |\n          |__________|________________________________________|_________|\n          |MULTI-FILE| print from multiple files on           |         |\n          |  READ    | single or multiple tape volumes        | N=nnn   |\n          |__________|________________________________________|_________|\n          |          | HEX to EBCDIC                          |   F=H   |\n          | TRANSLATE| HEX to ASCII                           |   F=A   |\n          |          | HEX to both ASCII and EBCDIC           |   F=B   |\n          |__________|________________________________________|_________|\n\n\n                              SUPRDUMP                   Installation  4-1\n\n                       \u00fc4 INSTALLATION PROCEDURE\n\n              SUPRDUMP  is  distributed  as  7  files on either a standard\n         labeled  6250 BPI  tape or 3480 cartridge.  File 1 contains a JCL\n         PROC used to install the program and to print the documentation.\n\n              File 2 is a  load  library  containing the SUPRDUMP module.\n\n              The next three files contain the components  of the SUPRDUMP\n         on-line  message  dialog  facility.  File  3  contains  the CLIST\n         SUPRDMSG, which should be placed in  the SYSPROC concatenation of\n         the LOGON PROC. File 4 contains the panel library and File  5 the\n         message library of the dialog facility.  The SUPRDMSG CLIST (from\n         File 3) must be modified  for  the names  used for  the libraries\n         containing the panels and messages.\n\n              File 6 contains a special character  set used  to  print the\n         documentation and must  be placed  into  SYS1.IMAGELIB  with  the\n         name XTB1MK11. It is invoked in JCL via the CHARS=MK11 parameter.\n         File  7  is  the  documentation  itself.  A 3800-compatible laser\n         printer is required to print the documentation. If such a printer\n         is  not available, then comment out  the second COPY statement in\n         the first  step (PGMLOAD) of the installation PROC.\n\n              To use the TAPECOPY feature of SUPRDUMP, SAS607 must be\n         installed.\n\n              The first file may be  retrieved with the following JCL:\n\n                   //PROCUNLD EXEC PGM=IEBGENER\n                   //SYSUT1 DD DSN=SUPRDUMP.INSTALL,DISP=OLD,\n                   //    UNIT=tape,VOL=SER=SUPRDP  <=== code tape unit\n                   //SYSUT2 DD DSN=your.install.file,DISP=SHR\n                   //SYSIN  DD DUMMY\n                   //SYSPRINT DD SYSOUT=*\n\n\n                              SUPRDUMP                   Installation  4-2\n\n              Following is the JCL contained in the first tape file.\n\n                   //SUPRDUMP PROC LOADLIB=,       PROGRAM LOAD LIBRARY\n                   //   CMDPROC=,PANELIB=,MSGLIB=, CLIST, PANEL & MSG LIB\n                   //   UNIT=,      CLASS FOR 6250 TAPE OR CARTRIDGE\n                   //   SYSOUT=,    3800 LASER PRINT CLASS FOR DOC PRINT\n                   //   CHARSET=MK11,     SPECIAL CHAR SET FOR DOC PRINT\n                   //   COPIES=1          NO. OF COPIES OF DOCUMENTATION\n                   //PGMLOAD EXEC PGM=IEBCOPY  LOAD THE SUPRDUMP PROGRAM\n                   //SYSPRINT  DD SYSOUT=*\n                   //IN        DD DSN=SUPRDUMP.PGM,    <=== LOAD MODULE PDS\n                   //             UNIT=&UNIT,DISP=(OLD,PASS),\n                   //             LABEL=(2,SL),VOL=(,RETAIN,SER=SUPRDP)\n                   //OUT       DD DSN=&LOADLIB,DISP=SHR\n                   //CLSTIN    DD DSN=SUPRDUMP.CLIST   <=== CLIST PDS\n                   //             UNIT=&UNIT,DISP=(OLD,PASS),\n                   //             LABEL=(3,SL),VOL=REF=*.IN\n                   //CLSTOUT   DD DSN=&CMDPROC,DISP=SHR\n                   //PNLIN     DD DSN=SUPRDUMP.PANEL,  <=== PANEL PDS\n                   //             UNIT=&UNIT,DISP=(OLD,PASS),\n                   //             LABEL=(4,SL),VOL=REF=*.IN\n                   //PNLOUT    DD DSN=&PANELIB,DISP=SHR\n                   //MSGIN     DD DSN=SUPRDUMP.MSG,    <=== MSG PDS\n                   //             UNIT=&UNIT,DISP=(OLD,PASS),\n                   //             LABEL=(5,SL),VOL=REF=*.IN\n                   //MSGOUT    DD DSN=&MSGLIB,DISP=SHR\n                   //CHARIN    DD DSN=SUPRDUMP.CHAR,   <=== CHAR SET\n                   //             UNIT=&UNIT,DISP=(OLD,PASS),\n                   //             LABEL=(6,SL),VOL=REF=*.IN\n                   //CHAROUT   DD DSN=SYS1.IMAGELIB,DISP=SHR\n                   //SYSUT3    DD UNIT=SYSDA,SPACE=(TRK,(2,2))\n                   //SYSIN     DD *\n                     COPY INDD=((IN,R)),OUTDD=OUT\n                     COPY INDD=((CHARIN,R)),OUTDD=CHAROUT\n                     COPY INDD=((CLSTIN,R)),OUTDD=CLSTOUT\n                     COPY INDD=((PNLIN,R)),OUTDD=PNLOUT\n                     COPY INDD=((MSGIN,R)),OUTDD=MSGOUT\n                   //*\n                   //DOCPRINT EXEC PGM=IEBGENER  PRINT THE DOC\n                   //SYSPRINT  DD SYSOUT=*\n                   //SYSUT1    DD DSN=SUPRDUMP.DOC,DISP=(OLD,KEEP),\n                   //             UNIT=&UNIT,\n                   //             LABEL=(7,SL),VOL=REF=*.PGMLOAD.IN\n                   //SYSUT2    DD SYSOUT=&SYSOUT,CHARS=&CHARSET,\n                   //             COPIES=&COPIES\n                   //SYSIN     DD DUMMY\n                   //      PEND\n\n\n                              SUPRDUMP                  Installation   4-3\n\n\n              Files 2 thru 7 are unloaded using the PROC retrieved  by the\n         IEBGENER step. The PROC should be customized to your installation\n         standards.  Execution  of  the  above  JCL  should produce a zero\n         return code for each step.\n\n         THE LOADLIB INTO WHICH THE SUPRDUMP MODULE IS LOADED MUST SPECIFY\n         AN APF-AUTHORIZED LIBRARY.\n\n              Note that  the  R  parameter has been specified in the  COPY\n         control statements of the first (PGMLOAD) step above.  This  will\n         cause any module in the corresponding libraries to be replaced by\n         the modules being loaded from the installation tape. If there are\n         any modules  with  these  names they  may be kept, if desired, by\n         renaming them before running the installation procedure.\n\n              The following table summarizes the attributes and contents\n         of the installation tape files.\n\n               _____________________________________________________________\n               |FILE   | FILE   |  FILE  |   FILE   | FILE  | FILE   |FILE |\n               |  1    |   2    |    3   |     4    |   5   |   6    |  7  |\n      _________|_______|________|________|__________|_______|________|_____|\n     | DSN(1)  |INSTALL|  PGM   | CLIST  |  PANEL   | MSG   | CHAR   | DOC |\n     |_________|_______|________|________|__________|_______|________|_____|\n     | RECFM   |  FB   |   U    |   FB   |    FB    |  FB   |   U    | VBA |\n     |_________|_______|________|________|__________|_______|________|_____|\n     | LRECL   |  80   |   -    |   80   |    80    |  80   |   -    | 148 |\n     |_________|_______|________|________|__________|_______|________|_____|\n     | BLKSIZE | 3120  | 23476  |  3120  |   3120   | 3120  | 23476  |4096 |\n     |_________|_______|________|________|__________|_______|________|_____|\n     | SPACE(2)|   1   |   2    |    1   |     5    |   1   |   1    | 14  |\n     |_________|_______|________|________|__________|_______|________|_____|\n     | DIR BLKS|   -   |   2    |    1   |    15    |   1   |   1    |  -  |\n     |_________|_______|________|________|__________|_______|________|_____|\n     |         |       |        |        | DMPnnn(x)|       |        |     |\n     | MEMBER  |       |SUPRDUMP|SUPRDMSG| DMPH001/2|DMPMS00|XTB1MK11|     |\n     |  NAMES  |       |        |        | DMPMAIN  |       |        |     |\n     |_________|_______|________|________|__________|_______|________|_____|\n\n       Notes: (1) The high level qualifier on all dsns is SUPRDUMP.\n              (2) All space requirements are in tracks on 3380 DASD.\n\n\n                              SUPRDUMP                 JCL and PARM    5-1\n\n                 \u00fc5 DESCRIPTION OF JCL AND PARM FIELD\n\n              The  JCL  required  to  run the program consists of one EXEC\n         statement and as many of the DD statements described below as are\n         necessary for dump, diagnose  and/or  copy  operations.  The  JCL\n         statements needed as the minimum required for  creating  SUPRDUMP\n         as a PROC are statements 1 (coded without a PARM), 3 and 6.\n\n         \u00dd 1\u00a8 //stepdmp EXEC PGM=SUPRDUMP\u00dd,PARM='parameters'\u00a8          REQ\n         \u00dd 2\u00a8 //STEPLIB   DD DSN=loadlib,DISP=SHR\n              //          DD DSN=sas.loadlib,DISP=SHR\n         \u00dd 3\u00a8 //SYSPRINT  DD SYSOUT=output print class                 REQ\n         \u00dd 4\u00a8 //SYSUDUMP  DD SYSOUT=output print class\n         \u00dd 5\u00a8 //SYSUT1    DD Sequential input file                     REQ\n         \u00dd 6\u00a8 //SYSUT2    DD SYSOUT=output print class                 REQ\n         \u00dd 7\u00a8 //TAPECOPY  DD Output tape volume\n         \u00dd 8\u00a8 //CONFIG    DD SAS options files\n         \u00dd 9\u00a8 //SASHELP   DD SAS help file\n         \u00dd10\u00a8 //SASMSG    DD SAS message file\n         \u00dd11\u00a8 //DIAGNOSE  DD diagnostics file\n\n         \u00dd 1\u00a8  This  statement  is always required. The PARM field for the\n               program is as follows:\n\n               PARM='\u00ddC=\u00dd\u00c6\u00a8cnt\u00a8\u00dd,F=\u00bbA|B|C|H|R\u00ba\u00ddL|P\u00a8\u00a8\u00dd,N=files\u00a8\n                    \u00dd,S=skip\u00a8\u00dd,R=\u00bbleng|V\u00ba\u00a8\u00dd,T=title\u00a8\u00dd,D=diagrecs\u00a8'\n\n              The  PARM  consists  entirely of optional keyword parameters\n         which  may  be entered in any order. If a parameter is not coded,\n         the  comma  associated  with  that  parameter must be omitted. No\n         spaces are permitted in the PARM except in the title.  Individual\n         PARM parameters are described in Sections 5.1 through 5.7.\n\n         \u00dd 2\u00a8  This  DD statement is required  if the  program load module\n               is not in an automatically searched load module library and\n               a JOBLIB DD statement has not been  included  in  the  JCL.\n               loadlib is the PDS in which the load module of SUPRDUMP  is\n               a member.\n               If the TAPECOPY DD statement is coded then the SAS  loadlib\n               containing   the   SAS370  load  module  may  have  to   be\n               concatenated to STEPLIB DD statement if sas.loadlib  is not\n               an automatically called library.\n\n         \u00dd 3\u00a8  See section 6.3.\n\n         \u00dd 4\u00a8  For program/system ABENDS, SYSUDUMP provides a system dump.\n1                             SUPRDUMP                   JCL and PARM  5-2\n\n\n         \u00dd 5\u00a8  See section 6.1.\n\n         \u00dd 6\u00a8  See section 6.2.\n\n         \u00dd 7\u00a8  See section 6.4.\n\n         \u00dd 8\u00a8  See section 6.4\n\n         \u00dd 9\u00a8  See section 6.4\n\n         \u00dd10\u00a8  See section 6.4\n\n         \u00dd11\u00a8  See section 6.6\n\n         NOTE: DD statements which should not be coded, unless the user is\n               familiar  with  SAS  or message DMP020E  is  produced,  are\n               FT11F001, FT12F001, WORK and SYSIN. See \u00fc6.4  and  the  SAS\n               User's Guide for more details.\n\n\n                              SUPRDUMP                   JCL and PARM  5-3\n\n\n                \u00fc5.1 BLOCK COUNT PARAMETER          ,C=\n\n              This parameter specifies the number of blocks  to be printed\n         from  each  file  processed.  It  may  be null, or a one to eight\n         character number from 0 to 99999999 with leading zeros permitted.\n         However, the first character may be a minus or plus sign  instead\n         of numeric. If not coded, or if null  or  zero,  the  default  is\n         used.\n\n              The default prints  all  the  blocks of each file processed;\n         i.e., the entire  data  set,  starting  after the  skip parameter\n         (if that is coded), is printed.\n\n              If no sign or a minus sign is coded, the  program  reads  to\n         the end of the file to get the block sizes and the block count.\n\n              When  the  minus  sign is coded, multiple input tape volumes\n         may be specified  only  when  Standard  Label  (SL) processing is\n         specified. Concatenated  DD  statements may  not be coded.  Files\n         with variable length records may  not  be specified, 7-track tape\n         with data conversion may not be specified  and the parameter N is\n         ignored if coded.\n\n              With  a  negative  count,  a tape file is opened and printed\n         starting from the end of the input file. The blocks of the SYSUT2\n         file  will be in reverse order from those of SYSUT1. Care must be\n         taken in interpreting the program messages.\n\n              If  a  plus  sign is coded, the program will stop processing\n         each file after the specified  number  of blocks of the file have\n         been printed. Thus, the  block  count,  the  maximum  and minimum\n         block sizes  and the total  number  of  bytes  apply only  to the\n         blocks that have been read up to that point.\n\n\n                 \u00fc5.2 PRINT FORMAT PARAMETER       ,F=\n\n              The Format parameter specifies the type of printout; whether\n         EBCDIC or ASCII translated data, with or without HEX, ruler or no\n         ruler  line  under  each  text group. The second character of the\n         format parameter indicates either that printer control characters\n         occurring  in  the data will not be translated to blanks, or that\n         a  partial  block printout is requested.  If the F=format  is not\n         coded or  is  null,  the  default  is  C,  with control character\n         translation.\n\n\n\n                              SUPRDUMP                 JCL and PARM    5-4\n\n              Two   positional   sub-parameters  may  be  coded  for  this\n         parameter.  The  first  may be either A, B, C, H or R; the second\n         may be L or P.\n\n              If F=C is coded, the blocks are printed with character lines\n         only.  The  characters  are the EBCDIC representation of the data\n         bytes. F=C is the default.\n\n              If  F=R  is  coded,  the blocks are printed in groups of two\n         lines.  The  first line contains the EBCDIC representation of the\n         data  bytes.  The  second  line  is a ruler line for ease of data\n         location in the printout.\n\n              If  F=H  is  coded, the blocks are printed in groups of four\n         lines.   The  first  line  of  each  group  contains  the  EBCDIC\n         representation  of  the  data  bytes.  The second and third lines\n         contain  the  vertical  hex representation of the data bytes, and\n         the fourth line is the ruler line.\n\n              If  F=A  is  coded, the blocks are printed in groups of four\n         lines.  The first line of each group contains the ASCII character\n         representation  of  the  data  bytes.  The second and third lines\n         contain  the  vertical  hex representation of the data bytes. The\n         fourth line is the ruler line.\n\n              If  F=B  is  coded, the blocks are printed in groups of five\n         lines.  The first line of each group contains the ASCII character\n         representation  of  the data bytes. The second line of each group\n         contains  the  EBCDIC character representation of the data bytes.\n         The   third   and   fourth   lines   contain   the  vertical  hex\n         representation  of  the  data  bytes. The fifth line is the ruler\n         line.\n\n              If  L  is  not  coded  as  a  second  subparameter in the F=\n         parameter, all print characters with  hex values less than  X'40'\n         are translated  to  X'40' before they are output. This means that\n         the output  can  go  to  any  type  of  printer, including  those\n         that recognize and act on carriage control characters anywhere in\n         the  print  record (e.g., remote terminals). If L is coded as the\n         second suboption, no character translation to hex X'40' occurs.\n\n              If L is coded the printout should be routed only to printers\n         which  recognize carriage control characters in the first byte of\n         the print record line only (e.g., 3211, 3800, etc).\n\n             If P is coded as the second subparameter of the F= parameter,\n         only the number of characters specified by the  R=  parameter are\n         printed for each block requested by the C= parameter.\n\n              If  either  L  or  P  is  coded, the first suboption must be\n         explicitly coded.\n\n                              SUPRDUMP                   JCL and PARM  5-5\n\n                \u00fc5.3 NUMBER OF FILES PARAMETER     ,N=\n\n              The  N=nnn  parameter specifies the number of files from the\n         input tape(s)  that are to be printed. nnn may be omitted or must\n         be a 1 to 8 digit number  and have a value of from 0 to 99999999.\n         Leading zeroes may be used. If N= is not coded, or is null, or if\n         nnn is zero, the default N=1 is used. A value of nnn greater than\n         1 is valid only for BLP-processed tapes  in  forward  read  mode;\n         otherwise  the default N=1 is used.\n\n              If  N is greater than 1 the parameters specified in the PARM\n         apply to all tape files read  by  the program.  The file sequence\n         number is  printed  as  part  of  the  title,  starting  with the\n         second data set  read, and  the tapemark number is printed on the\n         tapemark indicator.\n\n              If  BLP  is coded in the LABEL parameter of  the  SYSUT1  DD\n         statement, the  file sequence number specified  is interpreted as\n         the physical position of the file on the  tape;  e.g.,  LABEL=(4,\n         BLP) means that the program will dump N files starting  with  the\n         one before the fourth tapemark on the first volume. With multiple\n         volumes,  if  N  is  not  satisfied,  the  program  will continue\n         with the first physical data set  on  the next and, if necessary,\n         any following volumes.\n\n              If, before the N count is satisfied in  a forward read mode,\n         two consecutive  tapemarks are encountered,  or  an 80-byte block\n         containing  \"EOV1\" in  its  first four bytes (end-of-volume label\n         record) had been read  and  a following tapemark  is encountered,\n         end-of-volume processing will print an end of volume message.  If\n         this is  the last volume, the program will halt.  If more volumes\n         are  specified,  the program  will  continue and process the next\n         volume.\n\n              End-of-volume processing is NOT triggered if two consecutive\n         tapemarks are encountered immediately following an  80-byte block\n         containing \"HDR1\" in its first four bytes (header  label record).\n         This  situation  is  interpreted  as  a  null  (dummy)  file, and\n         processing will continue past the two consecutive tapemarks.\n\n              In general, it is best to code the N= parameter when reading\n         an  unknown tape. A good value would be  3 times  the  number  of\n         expected data files.\n\n\n                              SUPRDUMP                 JCL and PARM    5-6\n\n\n                  \u00fc5.4 GROUP LENGTH PARAMETER     ,R=\n\n              The  number  of characters in each group of lines printed is\n         determined by the R=length parameter. This may be null,  or  must\n         be a 1 to 8 digit number  and have a value of from 0 to 99999999.\n         Leading zeroes may be used.\n\n              If no R= is coded, or if R= is null or zero,  the  LRECL  is\n         used for files on disk or on standard label (SL) tapes. A default\n         of 100 is used for all other data sets or when LRECL=0 (e.g. when\n         RECFM=U).\n\n              If  R  greater  than  100  is  specified,  the group will be\n         printed  as  two or more sets of lines with the maximum number of\n         characters in any line equal to 100.\n\n              If R=V is specified, SUPRDUMP tests the file for a  variable\n         length  record  format  by checking that the first four bytes  of\n         each block of data is a valid BDW (block descriptor word)  and is\n         equal to the number of bytes read.  If this criterion is not met,\n         SUPRDUMP will issue a warning message and will default  to  R=100\n         (unless the  data is JCL, i.e., the first two bytes of  the  data\n         set are \"//\", in which case it will default to R=80).\n\n              If  the file has a variable length record format, the length\n         of  each  character  group  printed will be determined by the RDW\n         (Record Descriptor Word) of each record in the block.\n\n                   \u00fc5.5 SKIP PARAMETER           ,S=\n\n              The  S=skip parameter specifies the number of blocks of data\n         to be skipped before printout is to start, where skip is a number\n         from 0 to 99999999. If S= is not coded or is coded  as null,  the\n         default of zero is taken.  If the skip parameter is equal  to  or\n         greater than the total number of blocks in the data set,  no data\n         will be printed. This applies to each file processed.\n\n                   \u00fc5.6 TITLE PARAMETER          ,T=\n\n              The  T=title  parameter  puts  the value of 'title' on every\n         page  of  the printout. The title may be up to 65 characters long\n         and  may  consist  of  any  of  the 256 hex characters except the\n         EBCDIC comma (X'6B'). The default, if T is not coded or is  coded\n         as null, is to print no title. If a quote (X'7D') or an ampersand\n         (X'50') is to be  coded in the title, two consecutive  quotes  or\n         ampersands must be included in \"title\".\n\n                              SUPRDUMP                   JCL and PARM  5-7\n\n\n                   \u00fc5.7 DIAGNOSTICS PARAMETER    ,D=\n\n              The  D=nnn parameter allows the user to control  the  number\n         of diagnostic records output to the DIAGNOSE file.  D= is ignored\n         if the input file is not a tape.  nnn indicates  that  the  first\n         nnn reads  issued against  the input tape will produce diagnostic\n         records in the DIAGNOSE file.  When  multiple files are processed\n         nnn  diagnostic records records  will  be  written for each file.\n         For a description of the diagnostic records see section 6.6.\n\n                              SUPRDUMP                          Files  6-1\n\n                       \u00fc6   FILES\n\n                       \u00fc6.1 INPUT FILE - SYSUT1\n\n              A physical sequential input file must always be specified in\n         the DD statement SYSUT1 in the JCL.\n\n             With standard label processing, multi-volume data sets may be\n         specified by multiple serial number specification in the VOL=SER=\n         parameter,  or  by  concatenation of  DD statements in SYSUT1. If\n         concatening DD statements, UNIT=AFF=SYSUT1 should be used in  the\n         second and succeeding DDs  to  prevent  multiple tape drives from\n         being allocated.\n\n              Multiple data sets, on one or more tape volumes, may be read\n         by SUPRDUMP, since the program does not use a standard IBM access\n         method  for  tape.  They  are  read  by  coding the  N=n  (n > 1)\n         parameter of the PARM and coding LABEL=(m,BLP,...) in the  SYSUT1\n         DD statement.\n\n              To print a tape label file, code LABEL=(n,BLP) in the SYSUT1\n         DD statement, where n is the label data set position on the tape.\n\n              When a SYSUT1 DD statement contains the BLP label type sub-\n         parameter for a tape file, no  DD statements may be concatenated\n         to it. To process multiple volumes, code VOL=SER=(aaaaaa,bbbbbb,\n         ...) in the SYSUT1 DD statement.\n\n              When CA-1  (Tape  Management System)  is installed, printing\n         multiple  data  sets will require an operator volume verification\n         for each data set  printed.  Code EXPDT=98000  in  the  JCL LABEL\n         parameter to prevent these verification prompts to the console.\n\n              If  the  label  type  is  other than BLP, the N parameter is\n         ignored and its default of 1 is taken.\n\n              The record format (RECFM) may be fixed, variable, undefined,\n         spanned, standard or any valid combination thereof.\n\n              SUPRDUMP can read tape blocks that are  up  to  65,520 bytes\n         long. Files whose  BLKSIZE  exceed  32K  are  flagged  by message\n         DMP027W warning  the  user  that  they  are  not  processable  by\n         standard IBM access methods.\n\n              DISP  and  file name identification (DSN, *, DATA, etc.) are\n         always  required in the SYSUT1 DD statement. For tape files,  the\n         DCB parameters RECFM, LRECL, and BLKSIZE are ignored if coded.\n\n              If  the same tape volume is used in multiple steps to access\n         multiple  files, the RETAIN subparameter of the JCL VOL parameter\n         should be coded in all steps except the last.\n\n\n                              SUPRDUMP                          Files  6-2\n\n              In a multi-step job, when changing the JCL LABEL  label type\n         subparameter on tape volume files in different steps  (e.g.  when\n         switching from SL to BLP processing) the VOL=REF= parameter  must\n         not be coded. If the tape volser was known before  the  job, then\n         it  must  be  explicitly coded (e.g., in a VOL=SER= parameter) in\n         the steps with different label values, and neither DISP=PASS  nor\n         VOL=REF= can be used.  If the tape is created in the job, it must\n         be catalogued to be  used in a subsequent step with  a  different\n         label type.  If it cannot be catalogued, a separate job  must  be\n         run to use SUPRDUMP.\n\n              If C=-nn is coded  for an  input tape file, it is opened and\n         read backwards.\n\n              For disk files, SUPRDUMP uses standard IBM  access  methods.\n         DCB information is not required.\n\n              To dump the directory of  a PDS (partitioned data set), code\n         the PDS name  (without a member name)  on the SYSUT1 DD statement\n         together with DCB=(RECFM=F,LRECL=256,BLKSIZE=256).\n\n              To dump  an  OS  CVOL, code  DSN=SYSCTLG  on  the  SYSUT1 DD\n         statement together  with  a  UNIT and VOLSER parameter specifying\n         where the catalog resides.\n\n                      \u00fc6.2 OUTPUT PRINT FILE - SYSUT2\n\n              The  program  generates a  physical  sequential output file,\n         SYSUT2.  Its DCB  attributes  are  predefined  in  the program as\n         RECFM=FBA,LRECL=133,BLKSIZE=4788.  If the SYSUT2 DD statement  is\n         not coded in the JCL, it is dynamically allocated as SYSOUT=*.\n\n              SYSUT2  is  a  printout  of  the  data blocks of the file(s)\n         requested. Printing of a given file stops when the count has been\n         satisfied or at the end of the file. The bytes of the blocks that\n         are printed  include the  BDWs  and  the  RDWs of variable record\n         format files.\n\n              SYSUT2   also   contains  an  indication  of  each  tapemark\n         encountered by the program.\n\n              SYSUT2  may  be  directed to any system device. The contents\n         and  format  of SYSUT2 depend on the parameters coded in the  JCL\n         PARM field.\n\n                           \u00fc6.3 SYSPRINT\n\n              SYSPRINT  is  the  SUPRDUMP  message  print file. The DCB is\n         coded in the  program  as  RECFM=FBA,LRECL=133,BLKSIZE=4788.  All\n         program messages, statistics, file characteristics, etc. are out-\n         put to this file. If SYSPRINT is not coded in the  JCL it will be\n         dynamically allocated as SYSOUT=*.\n\n\n                              SUPRDUMP                           Files 6-3\n\n\n                      \u00fc6.4 OUTPUT TAPE - TAPECOPY\n\n              This  output  tape  is  optional and is only created if a DD\n         statement containing the ddname TAPECOPY is specified in the JCL.\n         It must not be specified, however, if the  SAS software  product,\n         Release 6.07 is  not installed  on  your  system.  This  DD  must\n         specify a  tape  volume and the  input DD (SYSUT1) must also be a\n         tape volume.  The input may be  standard  labeled or  nonlabeled.\n         The output tape will contain an exact physical copy  of the input\n         tape volume (except as noted below).\n\n              It is recommended that the LABEL=(,BLP) parameter  be  coded\n         on the TAPECOPY DD statement. This allows the system to determine\n         whether the output tape volume is to be standard labeled or  non-\n         labeled depending on whether the input tape  volume  is  standard\n         labeled  or nonlabeled. If the input volume is  standard labeled,\n         then the VOL header label will not be copied to the  output  tape\n         volume if the output volume has been initialized  by  IEHINITT or\n         an equivalent tape initialization program (i.e. the output volume\n         will retain its own VOL header label). However, the remainder  of\n         the label records will be copied (i.e. the fields containing  the\n         DSN, creating job/step, etc. are copied).\n\n              All physical files and tapemarks on the input volume will be\n         copied to the output tape volume. Note, however, that the BLKSIZE\n         of any physical record (block) on the output tape  volume  cannot\n         exceed 32,767. Input  blocks  containing  more  than 32,767 bytes\n         will be truncated to 32,767  on the output volume.\n\n              When the TAPECOPY DD statement is specified, along with  the\n         normal SUPRDUMP messages, SAS messages summarizing the tape  copy\n         operation will also appear in a separate listing. These  messages\n         will include the first 80 bytes of the first  10  blocks of  each\n         physical file copied.\n\n              The TAPECOPY DD may necessitate concatenating an  additional\n         library to the  STEPLIB DD statement in  the  JCL.  See section 5\n         JCL statement \u00dd2\u00a8   for details.\n\n              When TAPECOPY is used, a region  of 2500K or greater must be\n         specified.\n\n              When the tape copy feature is invoked  by coding  the DDNAME\n         TAPECOPY, three more DD statements must be coded.  The  DD  names\n         are  CONFIG,  SASMSG  and  SASHELP.  See the SAS User's Guide for\n         details on coding these DDs.\n\n\n                              SUPRDUMP                          Files 6-4\n\n\n                      \u00fc6.5 OTHER FILES - FT11F001 FT12F001 WORK SYSIN\n\n             When the tape copy function is invoked by coding the TAPECOPY\n         DD statement 4 other files are dynamically allocated by SUPRDUMP.\n         This action is transparent to the user and he need have no  know-\n         ledge of these files. However, anyone familiar with the SAS soft-\n         ware product may wish to code these files, thereby overriding the\n         dynamic allocation of SUPRDUMP.  In particular,  one  may wish to\n         specify one's own SYSIN  control statements customizing  the tape\n         copy operation to a particular application.\n\n\n                      \u00fc6.6 DIAGNOSE FILE\n\n             The  DIAGNOSE file  is used primarily for debugging purposes,\n         to diagnose a tape drive or reel/cartridge problem.  The DIAGNOSE\n         DD statement  is  ignored if the input (SYSUT1) is not on a tape.\n         The diagnostic  records consist  of data returned to the SUPRDUMP\n         program  as a result of a SENSE command issued after a tape READ,\n         and the unit and channel status bytes following the READ command.\n         The  diagnostic  record  consists of 40 bytes.  For non-cartridge\n         tapes  the  first  24 bytes contain SENSE information, the next 8\n         bytes have  no  meaning, the next 2 byte are the unit and channel\n         status  (from  the  channel-status word (CSW) in the input/output\n         block (IOB))  as  the  result of the READ command, and the last 6\n         bytes contain  a  sequence  number in packed decimal format.  For\n         cartridge tapes,  the  first  32  bytes contain SENSE information\n         followed by the 2-byte unit and channel status and then an 6-byte\n         packed sequence number.\n\n              For a detailed description of the SENSE information returned\n         see  the  IBM  3420  Magnetic  Tape  Subsystem Descriptions  (for\n         non-cartridge  tapes)  and  the  IBM 3480 Magnetic Tape Subsystem\n         Reference  (for  cartridge  tapes). For a detailed description of\n         the unit and channel status information see the IBM Principles of\n         Operation  in conjunction with the above specific device manuals.\n         The  6-byte  sequence number  is reset to zero when a new file is\n         processed in a multi-file processing option (i.e., when N=m,\n         with m greater than 1).\n\n              The  DIAGNOSE file may be a disk or tape dataset or may be a\n         SYSOUT  file. When routed to a SYSOUT file the diagnostic records\n         are printed in vertical hex format (similar to format F=H without\n         an EBCDIC representation  of  the data bytes printed (see section\n         5.2).  A JCL  DCB  BLKSIZE  parameter must always be coded on the\n         DIAGNOSE DD statement.  When  the  file  is routed to SYSOUT, the\n         BLKSIZE must be a multiple of 80.  When  routed to a disk or tape\n         it must be a multiple of 40.\n\n\n                              SUPRDUMP                     Examples  7-1\n\n\n                      \u00fc7 EXAMPLES\n\n         The  following  examples are valid for sequential input files,\n         SYSUT1. The SYSUT1 DD statement is not shown in examples 1-12.\n\n\n          EXAMPLE 1 - Print an entire file in 100 byte groups, character\n                         format with no title.\n\n         //S1     EXEC  SUPRDUMP\n\n\n          EXAMPLE 2 - Same as Ex. 1 except print in groups of 250 bytes.\n\n         //S1     EXEC  SUPRDUMP,PARM='R=250'\n\n\n          EXAMPLE 3 - Same as Ex. 2 but skipping the first 10 blocks of\n                         data.\n\n         //S1     EXEC  SUPRDUMP,PARM='R=250,S=10'\n\n\n          EXAMPLE 4 - Same as Ex. 3 except print only 15 blocks.\n\n         //S1     EXEC  SUPRDUMP,PARM='R=250,S=10,C=15'\n\n\n          EXAMPLE 5 - Same as Ex. 4 but with a title.\n\n         //S1     EXEC  SUPRDUMP,PARM='R=250,S=10,C=15,T=title'\n\n\n          EXAMPLE 6 - Same as Ex. 4 but in character & ruler line format.\n\n         //S1     EXEC  SUPRDUMP,PARM='R=250,S=10,C=15,F=R'\n\n\n          EXAMPLE 7 - Same as Ex. 4 but in EBCDIC character & HEX format.\n\n         //S1     EXEC  SUPRDUMP,PARM='R=250,S=10,C=15,F=H'\n\n\n          EXAMPLE 8 - Same as Ex. 4 but in ASCII character and HEX format.\n\n         //S1     EXEC  SUPRDUMP,PARM='R=250,S=10,C=15,F=A'\n\n\n          EXAMPLE 9 - Same as Ex. 4 but in both ASCII and EBCDIC character\n                         and HEX format.\n\n         //S1     EXEC  SUPRDUMP,PARM='R=250,S=10,C=15,F=B'\n\n\n                              SUPRDUMP                      Examples  7-2\n\n\n\n          EXAMPLE 10 - Same as Ex. 8 without  carriage  control  character\n                       suppression.\n\n         //S1     EXEC  SUPRDUMP,PARM='R=250,S=10,C=15,F=AL'\n\n\n          EXAMPLE 11 - Same as Ex. 7 but printout for IBM variable  format\n                       records.\n\n         //S1     EXEC  SUPRDUMP,PARM='R=V,S=10,C=15,F=H'\n\n\n          NOTE: if the input file is not a variable format the R parameter\n                defaults to 100 (or 80 if the data is JCL).\n\n\n          EXAMPLE 12 - Same as Ex. 4 but stop processing  after  C and S\n                       parameters have been satisfied (after 25 blocks).\n\n         //S1     EXEC  SUPRDUMP,PARM='R=250,S=10,C=+15'\n\n\n         The following examples are valid only for files residing on tape.\n\n          EXAMPLE 13 - Print 12 blocks of data from tape starting from the\n                      end of the third logical data set on a labeled tape.\n\n         //S1     EXEC  SUPRDUMP,PARM='C=-12'\n         //SYSUT1 DD    Input tape file,...,LABEL=(3,SL)\n\n\n          EXAMPLE 14 - Print the first three blocks of data from the first\n                       five physical files on a tape.\n\n         //S1     EXEC  SUPRDUMP,PARM='N=5,C=3'\n         //SYSUT1 DD    Input tape file,...,\n         //      LABEL=(1,BLP,EXPDT=98000)\n\n           Note: EXPDT=98000 is installation dependent. It may be required\n                 for installations using the CA-1 tape management  package\n                 if BLP is coded or for an outside tape.\n\n          EXAMPLE 15 - Print the first three blocks of data from  the  6th\n                       through the 10th physical files on  a tape (labeled\n                       or unlabeled).\n\n         //S1     EXEC  SUPRDUMP,PARM='N=5,C=3'\n         //SYSUT1 DD    Input tape file,...,\n         //      LABEL=(6,BLP,EXPDT=98000)\n\n\n                              SUPRDUMP                     Examples  7-3\n\n\n          EXAMPLE 16 - Print all the blocks from the first physical file\n                       on a labeled tape; blocks  5,  6 and  7  from the\n                       eighth, all blocks from the fourth, and  the last\n                       eight blocks from the fifth.\n\n         //S1     EXEC  SUPRDUMP,PARM='R=80,F=R'\n         //SYSUT1 DD    Input tape file,...,\n         //      LABEL=(1,BLP,EXPDT=98000),DISP=OLD,\n         //      VOL=(,RETAIN,SER=000100)\n         //*  THE ABOVE IS AN 80 CHARACTER LABEL DATA SET\n         //****************************************************\n         //S2     EXEC  SUPRDUMP,PARM='R=80'\n         //SYSUT1 DD    Input tape file,...,\n         //      LABEL=(4,BLP,EXPDT=98000),DISP=OLD,\n         //      VOL=(,RETAIN,SER=000100)\n         //*  THE ABOVE IS ANOTHER 80 CHARACTER LABEL DATA SET\n         //****************************************************\n         //S3     EXEC  SUPRDUMP,PARM='R=V,F=H,S=4,C=3'\n         //SYSUT1 DD    Input tape file,...,\n         //      LABEL=(8,BLP,EXPDT=98000),DISP=OLD,\n         //      VOL=(,RETAIN,SER=000100)\n         //*  THE ABOVE IS A VARIABLE FORMAT DATA SET\n         //****************************************************\n         //S4     EXEC  SUPRDUMP,PARM='R=V,C=-8'\n         //SYSUT1 DD    Input tape file,...,\n         //       LABEL=(5,BLP,EXPDT=98000),DISP=OLD,\n         //       VOL=(,RETAIN,SER=000100),\n         //*  IF THE ABOVE IS NOT VARIABLE THEN R=100 IS USED\n         //*************\n\n         NOTE: Datasets 1 and 4 are label datasets;  5 and 8  are  assumed\n         variable datasets. NOTE: To ensure that the  tape volume  is kept\n         mounted between steps, RETAIN may be coded in the VOL parameter.\n\n                               SUPRDUMP                   Examples   7-4\n\n\n\n            EXAMPLE 17 - Print 2 blocks in hex format from the  9 physical\n                         data sets on a tape; copy the entire input volume\n                         to a tape volume described in TAPECOPY DD.\n\n         //S1     EXEC  SUPRDUMP,PARM='F=H,N=9,T=TAPECOPY,C=+2',\n         //           REGION=2500K\n         //STEPLIB DD   DSN=sas.loadlib,DISP=SHR\n         //SYSUT1  DD   DSN=INPUT.TAPE,UNIT=T6250,DISP=OLD,\n         //      LABEL=(1,BLP),VOL=SER=000100\n         //TAPECOPY  DD DSN=OUTPUT.TAPE,UNIT=T6250,\n         //        LABEL=(1,BLP,RETPD=3),DISP=(,KEEP)\n         //CONFIG  DD   DSN=sas.config.file,DISP=SHR,\n         //        DD   DSN=sas.my.config.file,DISP=SHR\n         //SASHELP DD   DSN=sas.helpfile,DISP=SHR\n         //SASMSG  DD   DSN=sas.message.file,DISP=SHR\n\n         NOTE: For a tape copy operation, the REGION  parameter should  be\n         coded with at least 2500K. Also, a STEPLIB is  coded  pointing to\n         the SAS loadlib. To allow the system to decide whether the output\n         tape volume  should be  labeled  or  nonlabeled, LABEL=(,BLP) has\n         been coded on the TAPECOPY  DD statement.  Finally, even though a\n         DSN has been coded on TAPECOPY the program will nevertheless copy\n         the DSN from the input  tape  volume header (if it exists) to the\n         output tape volume header label.\n\n\n            EXAMPLE 18 - Print all labels  and  the first 100 bytes of the\n                         first 5 blocks of each data set  on  tape  volume\n                         111111.\n\n         //S1     EXEC SUPRDUMP,PARM='R=100,F=CP,N=3,C=5,T=PARTIAL PRINT'\n         //SYSUT1 DD DSN=MYTAPE,UNIT=T6250,DISP=(OLD,KEEP),\n         //          LABEL=(1,BLP,EXPDT=98000),\n         //          VOL=SER=111111\n\n\n            EXAMPLE 19 - Print three blocks from all  datasets on two tape\n                         volumes.  It  is  assumed  that there are no more\n                         than 90 data sets on the two volumes.\n\n         //S1     EXEC SUPRDUMP,PARM='R=100,F=C,N=90,C=3,T=MULTIVOLUME'\n         //SYSUT1 DD DSN=MYTAPE,UNIT=T6250,DISP=(OLD,KEEP),\n         //          LABEL=(1,BLP,EXPDT=98000),\n         //          VOL=SER=(111111,222222)\n\n         NOTE:  N=90  means  that  up  to  30  labeled  data  sets  can be\n         displayed. The job will stop when 90 files have been processed or\n         at the end of the second volume, whichever occurs first.\n\n\n                               SUPRDUMP                  Examples     7-5\n\n\n            EXAMPLE 20 - Print 100 blocks from two concatenated  tape data\n                         sets. The data sets have different DSNs, but  the\n                         same DCB attributes.\n\n         //S1     EXEC SUPRDUMP,PARM='R=100,F=C,C=100,T=CONCATENATION'\n         //SYSUT1 DD DSN=MYTAPE,UNIT=T6250,DISP=(OLD,KEEP),\n         //          VOL=SER=(111111)\n         //       DD DSN=YOURTAPE,UNIT=AFF=SYSUT1,DISP=(OLD,KEEP),\n         //          VOL=SER=(222222)\n\n         NOTE:  Only files processed as standard label (SL) files  may  be\n         concatenated.\n\n            EXAMPLE 21 - Print all blocks from a tape file. Produce\n                         diagnostic records for the first 100 read\n                         operations issued against this tape.\n\n         //S1     EXEC SUPRDUMP,PARM='F=C,D=100'\n         //SYSUT1   DD DSN=MYTAPE,UNIT=T6250,DISP=(OLD,KEEP),\n         //          VOL=SER=(111111)\n         //DIAGNOSE DD SYSOUT=A,\n         //          DCB=BLKSIZE=8000\n\n\n                              SUPRDUMP                    Messages     8-1\n\n                              \u00fc8 MESSAGES\n\n\n              During the execution of SUPRDUMP four  types of messages are\n         output  to  the  SYSPRINT file. These are informational, warning,\n         error messages, and SAS tape copy messages.\n\n              Informational  messages  describe requested conditions, file\n         attributes, statistics and similar information.\n\n              Warning messages describe incorrect or missing parameters in\n         the PARM field or JCL. The program, however, attempts  to correct\n         the  errors and generate correct parameter  values.   Tape  label\n         problems may also produce warning messages.\n\n              Error messages describe conditions  that  caused the program\n         to halt before completion.\n\n              SAS messages which are  output  to the FT11F001 file are not\n         described here but may be  found in the appropiate SAS manual.\n\n              If  only informational and warning messages have been issued\n         by SUPRDUMP,  a  completion code of 0 is returned. Error messages\n         are  accompanied by various completion codes; 8, FF, system abend\n         codes and SAS error return codes.  8 means an error was  detected\n         that caused program execution to halt. FF means the SYSPRINT file\n         could not be allocated; hence no messages could be  produced  and\n         program execution is immediately halted.\n\n              Most  messages  produced  by  SUPRDUMP  are  prefixed by the\n         letters DMP. The general message format is:\n\n          DMPxxxy text\n\n          xxx     Message number\n          y       Message type\n\n                  y=I means an informational message\n                  y=W means a warning message\n                  y=E means an error message\n\n          text    Message text\n\n\n\n                              SUPRDUMP                      Messages 8-1.1\n\n              There  are  also unnumbered messages which are output to the\n         SYSUT2  file.  They  describe  the  BLKSIZE  of  each  block, the\n         tapemark positioning, etc. These messages will be described after\n         the numbered messages are described.\n\n              SUPRDUMP messages  are  available  as  an on-line TSO/E ISPF\n         dialog facility.  The dialog  is  invoked  via the   TSO/E  CLIST\n         SUPRDMSG.  Full  instructions  for  installing  this  dialog  are\n         contained in  Chapter 4 'Installation  Procedures'.   The  dialog\n         panels are self-explanatory  and  include  a  help  tutorial.  In\n         general,   each  on-line  message  text  is  identical   to   its\n         corresponding hardcopy description.\n\n\n                              SUPRDUMP                      Messages   8-2\n\n                              \u00fc8.1 NUMBERED MESSAGES\n\n         DMP000I PARM= xxxxxxxxxxxxxxxxxxxxxxxxx\n\n                 EXPLANATION: This message is printed with every execution\n                 of  SUPRDUMP. It repeats the characters coded in the PARM\n                 field in the JCL for the user's convenience.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n         DMP001E ERROR IN PARM FIELD OR JCL\n\n                 EXPLANATION: This message indicates that a critical error\n                 has  occurred  and  is always printed in conjunction with\n                 previous  critical  error  message(s). The previous error\n                 messages  may  deal  with  errors encountered in the PARM\n                 field or JCL.\n\n                 SYSTEM ACTION: Program end with a non-zero return code.\n\n                 PROGRAMMER RESPONSE: Correct the error(s) indicated in the\n                 previous error message(s).\n\n\n         DMP002I END OF FILE REACHED\n\n                 EXPLANATION:  This message is printed when the end of the\n                 input file has been reached and the C=count parameter has\n                 not been satisfied.\n\n                 SYSTEM ACTION: Normal program end.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n         DMP003E SYSUT1/2 DD STATEMENT MISSING\n\n                 EXPLANATION:  This critical message indicates that either\n                 the  input file has not been defined in the JCL with  the\n                 ddname of SYSUT1, or that SYSUT2 has not been defined  in\n                 the JCL and could not be dynamically allocated.\n\n                 SYSTEM ACTION: Program termination with return code of 8.\n\n                 PROGRAMMER RESPONSE: Supply the correct JCL DD statement.\n\n\n                              SUPRDUMP                       Messages  8-3\n\n         DMP004E KEYWORD PARAMETER NOT FOLLOWED BY = SIGN\n\n                 EXPLANATION:  This critical message indicates that one of\n                 the key word parameters in the PARM is not followed by an\n                 = sign.\n                 SYSTEM ACTION: Program termination with return code of 8.\n\n                 PROGRAMMER RESPONSE: Correct the parameter in error.\n\n\n         DMP005E INVALID OR DUPLICATE KEYWORD PARAMETER\n\n                 EXPLANATION:  This  critical  message  indicates  that  a\n                 character other than C, F, N, R, S or T has been coded as\n                 a key word parameter, or that one of the above parameters\n                 has been coded more than once.\n\n                 SYSTEM ACTION: Program termination with return code of 8.\n\n                 PROGRAMMER RESPONSE: Correct the parameter error.\n\n\n         DMP006E A PARAMETER LENGTH EXCEEDS MAXIMUM ALLOWABLE\n\n                 EXPLANATION:  This  message  is  produced when any of the\n                 parameters  listed  in  the PARM is more than 8 digits in\n                 length, or if the T=title parameter exceeds 65 characters\n                 in length.\n\n                 SYSTEM ACTION: Program terminates with return code of 8.\n\n                 PROGRAMMER RESPONSE: Correct the parameter in error.\n\n\n         DMP008E PARM VALUE NOT NUMERIC\n\n                 EXPLANATION:  This  message  is  produced when one of the\n                 parameters listed  in  the  PARM  has a non-numeric value\n                 after the equal sign.\n\n                 SYSTEM ACTION: Program terminates with return code of 8.\n\n                 PROGRAMMER RESPONSE: Correct the parameter in error.\n\n\n                              SUPRDUMP                       Messages  8-4\n\n         DMP009E INVALID VALUE SPECIFIED FOR FORMAT PARAMETER\n\n                 EXPLANATION:  This  message  is produced when a character\n                 other than A, B, C, H or R as the first sub-parameter has\n                 been coded or other than  L  or  P  has been coded as the\n                 second sub-parameter of the F parameter.\n\n                 SYSTEM ACTION: Program terminates with return code of 8.\n\n                 PROGRAMMER RESPONSE: Correct the F parameter in the PARM.\n\n\n         DMP010I NUMBER OF BLOCKS DUMPED = nnnnn\n\n                 EXPLANATION:  This message is produced once at the end of\n                 each  file  processed  where  nnn  is the total number of\n                 blocks  from the input file that were printed. nnn always\n                 is  less  than or equal to the number of blocks requested\n                 in the Count parameter coded in the PARM.\n\n                 SYSTEM ACTION: Normal program end.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n         DMP011I NUMBER OF BLOCKS TO BE SKIPPED = nnnnn\n\n                 EXPLANATION:  This  message  is  produced when the S=nnnn\n                 parameter  is coded and indicates that nnn blocks will be\n                 skipped  before  printing  begins. These blocks and their\n                 lengths are counted and processed in the block statistics\n                 (block  count, maximum block size, minimum blocksize, and\n                 last block size).\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n         DMP012I MINIMUM BLKSIZE = nnnnn, MAXIMUM BLKSIZE = mmmmm, LAST\n                 BLKSIZE = kkkkk, TOTAL NUMBER OF BYTES = jjjjjjjjj\n\n                 EXPLANATION:  This message is produced for each file that\n                 is  read.  nnnnn  is  the  size  of  the  smallest  block\n                 processed, excluding the last block. mmmmm is the size of\n                 the  largest block processed and kkkkk is the size of the\n                 last  block  processed.  jjjjjjjjj is the total number of\n                 bytes  in the blocks processed. If C=+count is not coded,\n                 the  program  will  process  every  block in the file. If\n                 C=+count  is coded, the program will stop processing that\n\n\n                              SUPRDUMP                      Messages   8-5\n\n                 file  after  the  S and C parameters are satisfied, or at\n                 the end of file, whichever occurs first.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n         DMP013I nnn FILES TO BE DUMPED (N PARAMETER IGNORED FOR NON-TAPE)\n\n                 EXPLANATION:  This message indicates that the program has\n                 been  requested to print the number of files specified in\n                 the  N=files  parameter.  See Section 5.3 NUMBER OF FILES\n                 Parameter for details of multiple tape file processing.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None\n\n\n         DMP014W DATA NOT VARIABLE FORMAT, R=100 WILL BE USED\n\n                 EXPLANATION:   This   message   indicates  that  R=V  was\n                 requested  but  the  program determined that the file did\n                 not  have  standard IBM variable-format records. (See IBM\n                 DATA ADMINISTRATION SERVICES GUIDE for  a  description of\n                 variable-format  records.)  The  default length of 100 is\n                 used to print out the blocks  except when the data is JCL\n                 (in which case R=80 is used).\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER  RESPONSE:  Inspect  the printout to determine\n                 the actual record format of the file.\n\n\n         DMP015I SKIP COUNT EQUALS OR EXCEEDS TOTAL BLOCK COUNT. NO BLOCKS\n                 DUMPED.\n\n                 EXPLANATION:  This  message  is  produced  when the value\n                 coded in the S=skip parameter is greater than or equal to\n                 the  total  number  of  blocks in the file. No blocks are\n                 printed for this file.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n                              SUPRDUMP                       Messages  8-6\n\n\n         DMP016I END OF VOLUME REACHED\n\n                 EXPLANATION:  This  message  is  produced with tape input\n                 files  when  the  N parameter is coded greater than 1 and\n                 an  end  of  volume  condition has been encountered.  The\n                 program will process the next tape volume(s) (if present)\n                 until the  N parameter has been satisfied.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n         DMP017I TAPE FILE WILL BE PROCESSED BACKWARDS.R=V AND N PARAMETER\n                 WILL BE IGNORED IF CODED.\n\n                 EXPLANATION:  This  message  indicates  that the backward\n                 option of the Count parameter has been specified. The use\n                 of  this  option  requires  that  the input file is a one\n                 volume  fixed-format  sequential tape file. Hence, R=V is\n                 defaulted to R=100 and the  N  parameter  is  ignored  if\n                 coded. The tape volume is opened and processed backwards.\n                 Caution is advised in interpreting the resulting messages\n                 when using this option.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n         DMP018I SUPRDUMP  STATISTICS  APPLY ONLY TO THE  NUMBER OF BLOCKS\n                 PROCESSED\n\n                 EXPLANATION:  This  message is issued when a plus sign is\n                 coded  in  the  C  parameter value. The + sign causes the\n                 program  to  stop  processing  a  file  if  the  S  and C\n                 parameters are satisfied.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n         DMP019I BLOCK NO. = nnnnn, NO. OF BYTES IN BLOCK = mmmmm\n\n                 EXPLANATION:  This  message is issued, when processing  a\n                 non-variable format file, when the length mmmmm  of block\n\n\n                              SUPRDUMP                        Messages 8-7\n\n                 nnnnn differs from the length of the previous block.   It\n                 is always printed for the first block except when R=V  is\n                 coded but the file is not variable;  then the  message is\n                 printed  for  the  second block. A maximum of ten DMP019I\n                 messages will be printed.  If a block number  other  than\n                 the first or last is printed for a fixed format file then\n                 the indicated block(s) is probably bad.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: Recreate the file if bad blocks  are\n                 found.\n\n         DMP020E UNABLE TO ALLOCATE FILE(S) FOR TAPE COPY (FT11F001, WORK,\n                 FT12F001, SYSIN)\n\n                 EXPLANATION:  This message is issued when the TAPECOPY DD\n                 statement has been coded in  the  JCL  but  SUPRDUMP  has\n                 been unable to dynamically allocate one  or  more  of the\n                 above files required for the tape copy operation.\n\n                 SYSTEM ACTION: Tape copy operation bypassed.\n\n                 PROGRAMMER RESPONSE: Code the required file  in  the  JCL\n                 and rerun the job.\n\n         DMP021I FILE OCCUPIES APPROXIMATELY nnn INCH(ES) OF TAPE\n\n                 EXPLANATION:  This message is issued once  at  the end of\n                 each  file  processed,   where   nnn  is  the approximate\n                 physical  length  of  the  file,  computed  from the tape\n                 density,  recording  mode  technique and number of bytes.\n                 Refer  to  IBM  3420  Models  4,  6,  and 8 Magnetic Tape\n                 Subsystems, GA32-0021, for more details.\n\n                 SYSTEM ACTION:  Normal program continuation.\n\n                 PROGRAMMER RESPONSE:  None.\n\n         DMP022I JOBNAME=jobname,PROCSTEPNAME=procstepname,JOBSTEPNAME=\n                 jobstepname\n\n                 EXPLANATION: This message is printed with every execution\n                 of SUPRDUMP. If the program is not executed from  a PROC,\n                 the PROCSTEPNAME=  becomes STEPNAME=.\n\n                 SYSTEM ACTION:  Normal program continuation.\n\n                 PROGRAMMER RESPONSE:  None.\n\n\n                              SUPRDUMP                       Messages 8-8\n\n\n         DMP023I APPROXIMATE TOTAL TAPE LENGTH OF PROCESSED FILES = nnnnnn\n                 INCH(ES)\n\n                 EXPLANATION: This message is printed with every execution\n                 of SUPRDUMP with multiple tape data sets. nnnnnnn  is the\n                 summation of the approximate  tape  lengths  of  all  the\n                 processed data sets on all tape volume(s).\n\n                 SYSTEM ACTION:  Normal program continuation.\n\n                 PROGRAMMER RESPONSE:  None.\n\n         DMP024W THE BLOCK COUNT IN THE TAPE TRAILER LABEL (nnnn) DOES NOT\n                 MATCH THE ACTUAL BLOCK COUNT (mmmm).\n\n                 EXPLANATION: This message is printed with every execution\n                 of SUPRDUMP with standard label tape processing and C=+cc\n                 not coded. This message indicates a possible problem with\n                 the tape data set. nnnn is the block count  on  the  tape\n                 trailer label  and  mmmm  is  the actual block count. The\n                 trailer labels of each volume  of a multi-volume standard\n                 label processed tape data set are checked for block count.\n\n                 SYSTEM ACTION:  Normal program continuation.\n\n                 PROGRAMMER RESPONSE:  Examine tape data set. It may need\n                 to be recreated.\n\n         DMP025I VOLUME SWITCHED TO VOLSER= vvvvvv AFTER BLOCK NUMBER nnn\n\n                 EXPLANATION:  This  message is  printed  for multi-volume\n                 data sets. vvvvvv  is  the next volume  serial number and\n                 nnn  is  the block count  of  the just-processed  volume.\n                 AFTER BLOCK NUMBER nnn is not printed for BLP processing.\n\n                 SYSTEM ACTION:  Normal program continuation.\n\n                 PROGRAMMER RESPONSE:  None.\n\n         DMP026E BLP PROCESSING FOR CONCATENATED TAPE FILES NOT ALLOWED\n                 (SPECIFY ALL VOLSERS IN SYSUT1 DD STATEMENT).\n\n                 EXPLANATION: This message is  printed when the SYSUT1 DD\n                 statement specifies BLP processing for concatenated tape\n                 files. This is not allowed; however, all the volumes  in\n                 the concatenation may be coded in the  VOL=SER parameter\n                 of the the SYSUT1 DD.\n\n                 SYSTEM ACTION: Program terminates with a return code of 8\n\n                 PROGRAMMER RESPONSE:  Recode  the  SYSUT1 DD statement to\n                 include all the VOLSERs  specified  in  the concatenation\n                 and remove all the concatenated DD statements.\n\n\n                              SUPRDUMP                       Messages  8-9\n\n         DMP027W BLKSIZE OF FILE EXCEEDS 32K - NOT PROCESSABLE USING\n                 STANDARD IBM ACCESS METHODS\n\n                 EXPLANATION: This message is printed when a tape file has\n                 a blocksize exceeding  32K.  See  message DMP012I for the\n                 maximum blocksize  found  in  the  data set. This message\n                 tells  the  user  that  programs  using  standard IBM I/O\n                 methods cannot process the data set properly.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: Take appropriate action.\n\n\n                              SUPRDUMP                       Messages 8-10\n\n\n         DMP040I VOLSER=volser,BLK CNT=nnnnnnn,SEQ NO=mmmmm,LABEL=lbl,\n                                       DEN=den,p-TRK,DSN=dsname\n                 RECFM=recfm,LRECL=lrecl,CREATION DATE:YY=yy,DDD=ddd,\n                                       EXPIRATION DATE:YY=yy,DDD=ddd\n\n                 EXPLANATION: This message is issued for each  input  file\n                 processed by SUPRDUMP.\n\n                 The following are in the first message line:\n\n                 \"volser\" is the first  (or only) volume  serial number of\n                 the storage device on which the file  resides. nnn is the\n                 number  of  blocks  in  the file except  when C=+count is\n                 specified,   when  it  is  only  the  number   of  blocks\n                 processed.  SEQ  NO=mmm  is  printed only  for tape files\n                 where mmm is the logical  or physical sequence number  of\n                 the file, depending on the JCL label parameter. If BLP is\n                 coded, it is the physical sequence number.  For all other\n                 label  parameters  (SL, SUL, AL, etc.)  it is the logical\n                 sequence number. \"lbl\" is the JCL label parameter  (coded\n                 or defaulted).  DEN=den  is  printed  for 3420 tape files\n                 where \"den\" is the actual tape density (only 800, 1600 or\n                 6250  BPI)  and  p-TRK  indicates  either  7  or  9-track\n                 recording mode. For 3480 tape cartridges, \"den\" is listed\n                 as  38000 BPI  and  18TRK recording mode. \"dsname\" is the\n                 file name specified  in  the JCL.\n\n                 The following are in the second line of the message. They\n                 have valid values only for disk  data sets,  or tape data\n                 sets run with standard label processing:\n\n                 \"recfm\"  is  the  record  format  of the file (F, V, or U\n                 only).  \"lrecl\"  is  the  logical record length.  For  SL\n                 processing,  CREATION  DATE is  the  Julian date  of tape\n                 creation. For BLP processing,  CREATION DATE  is  today's\n                 Julian date. EXPIRATION  DATE yy  and  ddd  is the Julian\n                 date of expiration if it exists.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n         DMP041I (C) COPYRIGHT JUNE 1984 BY M. KARLIN, N. LINDNER SUPRDUMP\n                 RELEASE x.y  date\n\n                 EXPLANATION: Copyright and release information.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n                                   SUPRDUMP                  Messages 8-11\n\n\n\n                              \u00fc8.2 UNNUMBERED MESSAGES\n\n\n         BLOCK nnnnn SIZE mmmmm   ----+----1----+----2---...---9----+----0\n\n                 EXPLANATION:  This  message  is  issued before each block\n                 printed in the SYSUT2 data set. nnnnn is the block number\n                 in  the  file being printed. mmmmm is the number of bytes\n                 in  the  block that is being printed. It includes the BDW\n                 and  RDWs  if any are present. A ruler line of length 100\n                 follows mmmmm.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n               nnnnn LEN mmmmm   format         ..........data..........\n\n                 EXPLANATION: This message is issued for each print group.\n                 For  F=C,  F=R  and F=H, format  is blanked out. For F=A,\n                 format  is  ASC  and  for F=B two lines are printed, with\n                 format  ASC  on  the  first  line  and  format EBC on the\n                 second.  nnnnn  is  the  group  number  within  the  file\n                 printout,  always starting from 1. mmmmm is the length of\n                 the  group.  It  is equal to the value specified in the R\n                 parameter  unless  R=V  is  coded and the records are IBM\n                 variable format.  In this case, in the first group of the\n                 block,  mmmmm  is the length specified in the RDW plus 4.\n                 In  all  other groups within the block it is the value of\n                 the RDW.\n\n                 With   format  blanked  out,  ...data...  is  the  EBCDIC\n                 representation  of the bytes. With format ASC, ...data...\n                 is the ASCII representation of the bytes, and with format\n                 EBC ...data... is the EBCDIC representation.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n                              SUPRDUMP                      Messages  8-12\n\n\n\n         TAPEMARK nnnnn  *************************************************\n\n                 EXPLANATION: This message is issued each time a  tapemark\n                 is encountered while printing blocks. When multiple files\n                 are printed (using the N parameter) a tapemark is printed\n                 between files. nnnnn is the number of the tapemark on the\n                 tape;  i.e., 1  for the first tapemark on the tape, 2 for\n                 the second, etc.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n         title            nnnnn\n\n                 EXPLANATION:  The  value  specified in the T parameter is\n                 written on each page printed in SYSUT2.  For single  data\n                 sets (N=1) and for the first file with N greater  than 1,\n                 nnnnn is blanked out. For all the other data  sets with N\n                 greater than one, nnnnn is the absolute position  of  the\n                 data set on the tape volume.\n\n                 NOTE:  for  single  tape  data  sets and for the first of\n                 multiple tape data sets the position of the file is given\n                 by the sequence number in message DMP040I.\n\n                 SYSTEM ACTION: Normal program continuation.\n\n                 PROGRAMMER RESPONSE: None.\n\n\n         UNABLE TO READ DATA IN BLOCK\n\n                 EXPLANATION:  A READ macro was issued by SUPRDUMP but the\n                 system returned no data to the  program.  This  indicates\n                 that a bad block has been read by the tape unit.\n\n                 SYSTEM ACTION: Program continuation.\n\n                 PROGRAMMER RESPONSE: Recreate the file.\n\n\n                              SUPRDUMP            TSO Considerations  B-1\n\n\n                              APPENDIX B\n\n\n                        \u00fc10 TSO CONSIDERATIONS\n\n              For  those  users  who  have  the ability to execute on-line\n         command lists (CLISTs) on TSO (Time Sharing Option) the following\n         sample command procedure, i.e., a prearranged executable sequence\n         of  TSO commands that can be invoked by issuing the EXEC command,\n         may be used to run the program SUPRDUMP.\n\n              A  working  knowledge  of  IBM  OS  TSO  Command Language is\n         required to understand this section.\n\n              Uppercase  letters  and  words  written in uppercase must be\n         coded  in  the  CLIST  exactly  as  they  appear.  The  following\n         characters must also be coded exactly as they appear:\n\n               ampersand     &\n               asterisk      *\n               parentheses   ()\n               apostrophe    '\n\n              Lowercase  letters, words and symbols appearing in the CLIST\n         represent variables for which specific information is substituted\n         when the parameter is coded.\n\n         \u00dd 1\u00a8 PROC 0 SYSUT1(),SYSUT2(*),SYSPRINT(*)\n         \u00dd 2\u00a8 CONTROL PROMPT,LIST\n         \u00dd 3\u00a8 FREE  DD(SYSUT1,SYSUT2,SYSPRINT)\n         \u00dd 4\u00a8 ALLOC DS(&SYSPRINT)   DD(SYSPRINT)\n         \u00dd 5\u00a8 ALLOC DS(&SYSUT1)     DD(SYSUT1)    SHR\n         \u00dd 6\u00a8 ALLOC DS(&SYSUT2)     DD(SYSUT2)    disp\n         \u00dd 7\u00a8 WRITE prompt to enter parm field\n         \u00dd 8\u00a8 READ  &PARM\n         \u00dd 9\u00a8 CALL  'loadlib(suprdump)'  '&PARM'\n         \u00dd10\u00a8 FREE  DD(SYSUT1,SYSUT2,SYSPRINT)\n         \u00dd11\u00a8 WRITE message to indicate CLIST has ended\n         \u00dd12\u00a8 RETURN\n\n         \u00dd 1\u00a8  This  statement  defines the  parameters that are passed to\n               the  command  procedure via the value-list parameter of the\n               EXEC  command.  0  in  the  PROC  statement  means  that no\n               positional  parameters  are  used. There are three  keyword\n               parameters coded in the PROC statement. They are:\n\n              SYSUT1   - This parameter gives   the DSN of the input file.\n                         It must be coded, with a DSN as its value,   when\n                         executing the CLIST.\n\n\n                              SUPRDUMP             TSO Considerations  B-2\n\n\n              SYSUT2   - This  parameter supplies the DSN of the file that\n                         will  contain  the  blocks dumped from SYSUT1. It\n                         has  been coded in the PROC with a default to the\n                         terminal.\n\n              SYSPRINT - This  parameter  supplies the DSN of the SYSPRINT\n                         file.  It has  been  coded  with a default to the\n                         terminal.\n\n         \u00dd 2\u00a8  This statement permits the CLIST to prompt the terminal for\n               input  and  to  display  the CLIST commands at the terminal\n               after symbolic substitution but before execution.\n\n         \u00dd 3\u00a8  This  statement  releases  (deallocates)  all of the listed\n               data  sets if they  were previously allocated. This is done\n               in preparation for allocating them in this CLIST.\n\n         \u00dd 4\u00a8  See \u00dd 3\u00a8 of section 5.\n\n         \u00dd 5\u00a8  See \u00dd 5\u00a8 of section 5.\n\n         \u00dd 6\u00a8  See \u00dd 6\u00a8 of section 5.\n\n         \u00dd 7\u00a8  This  statement sends text  of  the  user's choosing to the\n               terminal  to  prompt  the  user to enter a PARM. The prompt\n               should request the PARM in the form:\n                       'R=len,C=count,S=skip,...'\n\n         \u00dd 8\u00a8  This statement makes the PARM entered by the user available\n               to the CLIST.\n\n         \u00dd 9\u00a8  This statement will load and execute the program designated\n               by 'suprdump' residing  in executable (load module) form in\n               the load library designated by 'loadlib'.\n\n         \u00dd10\u00a8  This  statement  releases  all of the listed data sets that\n               had been allocated in this CLIST.\n\n         \u00dd11\u00a8  This  statement  sends  a message to terminal user that the\n               CLIST has completed its execution.\n\n         \u00dd12\u00a8  This statement returns control to the terminal user.\n\n              As  the  program  is  executing,  the data sets allocated as\n         DS(*) (statements 4 and 6) are displayed at the terminal.\n\n              It  must be remembered that this is just a sample CLIST. The\n         user  may  wish to modify it by adding/deleting/changing commands\n         to fit his own needs.\n\n\n                              SUPRDUMP              TSO Considerations B-3\n\n\n\n                             TSO EXAMPLES\n\n\n              In the following examples it is assumed that the CLIST above\n         is the member DUMP of the library USER.CLIST and that the program\n         load  module  resides  in  the  library  LOADLIB  under  the name\n         SUPRDUMP.  It  is  also assumed that the PARM field prompt \u00dd8\u00a8 is\n         ENTER  PARM  FIELD,  that the DISPositions of all the output data\n         sets  are  coded  OLD  and  that  the library USER.CLIST has been\n         ALLOCated to the ddname SYSPROC.\n\n\n              EXAMPLE TSO1\n\n              Dump every block from the file ALLCASES to the terminal.\n\n              DUMP SYSUT1('''ALLCASES''')\n\n              When the prompt ENTER PARM FIELD appears on the screen, type\n         'T=ALLCASES' and press the ENTER key.\n\n\n              EXAMPLE TSO2\n\n              Dump  3 blocks of data from the file ALLCASES after skipping\n         the first four blocks. Print the blocks in 80 character groups.\n\n              DUMP SYSUT1('''ALLCASES''')\n\n              When   ENTER   PARM   FIELD   appears  on  the  screen  type\n         'R=80,S=4,C=3' and press the ENTER KEY.\n\n\n                              SUPRDUMP                 Bibliography    C-1\n\n                           \u00fc11 BIBLIOGRAPHY\n\n\n              The  following publications contain concepts and terminology\n         that relate to the operation of the program SUPRDUMP:\n\n         IBM MVS JCL\n\n         IBM DATA PROCESSING GLOSSARY\n\n         IBM MVS System Programming Library: Data Administration (EXCP\n              MACRO)\n\n         IBM Magnetic Tape Labels and File Structure Administration\n\n         IBM MVS Data Admin. Services Guide (BSAM, RDW, BDW)\n\n         IBM TSO/E Command Language Reference (TSO Considerations)\n\n         IBM TSO/E Terminal User's Guide (TSO Considerations)\n\n         IBM MVS Linkage Editor and Loader (Installation Procedures)\n\n         IBM MVS Message Library: System Codes and Messages (return codes)\n\n         IBM 3803 Model 3, IBM 3420 Models 4, 6 and 8 Magnetic Tape Subsystem\n             Description (Sense and Status information)\n\n         IBM 3480 Magnetic Tape Subsystem Reference\n\n         IBM Principles of Operation (unit and channel status)\n\n         SAS User's Guide: Basics (TAPECOPY procedure)\n\n\n                              SUPRDUMP                     Glossary    G-1\n\n                             \u00fc12 GLOSSARY\n\n         This  glossary  provides a comprehensive vocabulary reference for\n              SUPRDUMP  users.  Some  of  these  terms  may have different\n              meanings  in  other contexts, or to people not familiar with\n              data processing usage.\n\n         Entries in this glossary are arranged in a letter-by-letter basis\n              -  that  is,  only  the  letters of the alphabet are used to\n              determine  sequence,  special  characters and spaces between\n              words are ignored.\n\n         The  entry  for  each  term consists of a single or multiple-word\n              term  or the abbreviation or acronym for a term, followed by\n              a   commentary.   If   the  term  can  be  abbreviated,  the\n              abbreviation  is  given in parentheses immediately following\n              the term.\n\n            ABEND.  The  program  SUPRDUMP could not continue because of a\n             violation of a system operation.\n\n            access methods. The BSAM IBM access method is used in SUPRDUMP\n             for  disk  data  sets.  For  tape  data sets an EXCP macro is\n             issued to obtain input data.\n\n            ASCII.  When  F=A  or  F=B  is  coded  in  the PARM, each byte\n             representation  is  interpreted  in  accordance with the ANSI\n             standard character set.\n\n            bad  block.  In  normal IBM access methods, a bad block is one\n             which  does  not  meet the requirements of the Access Methods\n             used. SUPRDUMP, however, does not use standard access methods\n             for tape so a bad block to the program is only one which  the\n             physical device cannot read.\n\n            block descriptor word (BDW). IBM places a four byte BDW at the\n             start  of  each  block  of  a variable length file. The   BDW\n             contains  the  block  length  and  is  used  by  SUPRDUMP  to\n             determine  if  the  file  is  variable  length,  when  R=V is\n             specified.\n\n            BLKSIZE.  The  lengths of the smallest, largest and last block\n             read  by  SUPRDUMP are  displayed  in  the  message  data set\n             SYSPRINT. While the largest block that can be written or read\n             by  IBM  standard  access  methods  is 32K, SUPRDUMP can read\n             blocks up to 64K.\n\n            BLP.  This  is a tape LABEL subparameter in JCL. When used, it\n             causes the IBM operating system to bypass label processing of\n             magnetic  tape and to treat each physical file of the tape as\n\n\n                              SUPRDUMP                      Glossary   G-2\n\n             data.\n\n            backward processing of tapes. If C=-nnn is coded and SYSUT1 is\n             a  tape  data  set,  the data set is opened backwards and nnn\n             blocks  are  printed. If SYSUT1 is other than tape, the minus\n             sign is ignored and the input data set is read from the start\n             with nnn blocks being printed.\n\n            block  count.  The  number  of blocks to be printed out by the\n             program.  The count is started after the skip block parameter\n             is satisfied.\n\n            carriage  control  character. Certain byte representations are\n             used  by  printers  to trigger form feed, line feed, carriage\n             return  and other printer control functions. SUPRDUMP changes\n             these  characters  to spaces whenever they occur in any print\n             position other than the first. This change is suppressed if L\n             is  specified  as  the  second  subparameter  of the F=format\n             parameter of the PARM.\n\n            data  portion  of block. For   non-variable-length-block files\n             it  is  the  entire  physical record (block). For  files with\n             variable  length  records it is the block minus the four-byte\n             BDW  at the start of each physical record minus any four-byte\n             RDWs  contained within the block. However SUPRDUMP treats all\n             bytes in the block, including the BDW and RDW, as data.\n\n            DCB.  SUPRDUMP does not use the standard sub-parameters of the\n             data control block (i.e., RECFM, LRECL, BLKSIZE) on SYSUT1.\n\n            density. This refers to the number of bytes per inch  recorded\n             on magnetic tape.   Tape  densities   of  800, 1600, 6250 and\n             38000 bpi are processed for data set tape length.\n\n            EBCDIC.   Unless   F=A   is  coded  in  the  PARM,  each  byte\n             representation  is  interpreted  in  accordance  with the IBM\n             Extended Binary Coded Decimal character set.\n\n            EXCP.  This  is  the  IBM  macro used by SUPRDUMP to read tape\n             files.  Its  use  enables SUPRDUMP to bypass the standard IBM\n             Sequential  Access Methods and thereby enables the program to\n             read tapes without knowing any of the DCB attributes.\n\n            input  file.  This  is  the file from which blocks are printed\n             according  to  the  SUPRDUMP criteria specified. The data set\n             organization must be sequential (PS).\n\n            LABEL.  This  parameter  of the JCL is used for tape files. It\n             indicates  the  data  set  on the tape to use by the Sequence\n             Number   subparameter   and   whether  or  not  to  do  label\n             processing.  For  installations  with the CA-1  tape handling\n             software  package,  coding  EXPDT=98000 removes the tape from\n             CA-1 processing.\n\n\n                              SUPRDUMP                       Glossary  G-3\n\n            logical/physical  file.  The  tape file to use is specified by\n             the   tape   file   sequence   number   coded  in  the  LABEL\n             subparameter.  If  SL  is  coded  in  the LABEL, the sequence\n             number  refers to the logical file (data file where the files\n             are  ordered as header, data, trailer, header, data, trailer,\n             etc.)  If  BLP  is  coded, the  sequence number refers to the\n             actual  physical  location of the file to be used, i.e., 1 is\n             header, 2 is data, 3 is trailer.\n\n            multiple  files. If the N parameter is coded for tape volumes,\n             multiple  data  sets on the tape(s)  may  be  printed  in one\n             execution of SUPRDUMP.\n\n            output file. One file, SYSUT2, is output by SUPRDUMP.\n\n            print  files.  SYSPRINT,  the  one  print  file available with\n             SUPRDUMP   is  always  required  for  program  operation  and\n             contains the program messages.\n\n            print  format.  There  are  five  separate  print  formats for\n             SYSUT2. These are character, character and ruler line, EBCDIC\n             character  with  vertical HEX and ruler line, ASCII character\n             with  vertical  HEX and ruler line, and both EBCDIC character\n             and  ASCII  character  with  vertical HEX and ruler line. The\n             print format is controlled by the F parameter in the PARM.\n\n            print group. The number of characters printed in each group is\n             controlled  by the R parameter. It may be any value from 1 to\n             the  blocksize.  If R=V is  specified  as  the value of the R\n             parameter, with  a variable  length file  the group length is\n             determined by each RDW encountered. With R=V and with a fixed\n             length file, the print group defaults to 100.\n\n            record  descriptor word (RDW). The four-byte RDW of a variable\n             length  record is used by SUPRDUMP, when R=V is specified, to\n             delimit the record group printed in SYSUT2.\n\n            recording mode technique. Magnetic tape is recorded with either\n             7, 9, or 18 tracks across the tape.\n\n            ruler  line.  This  is  a  line  placed under the print lines,\n             calibrated  from  1  to  100  or  less,  depending  on the R=\n             parameter.  It  is used to find the relative byte location of\n             any field within the record.\n\n            skip  block  parameter.  This  optional keyword PARM parameter\n             specifies  the  number  of  blocks  of the input file to skip\n             before  printing out the characters in the file. For example,\n             S=2  means to skip the first two blocks and start printout at\n             the third block of the data set.\n\n            SYSPRINT.  This  is  the  ddname of the SUPRDUMP message print\n             file.\n\n\n                              SUPRDUMP                      Glossary   G-4\n\n            SYSUDUMP.  This  is  the  ddname of the operating system abend\n             dump file.\n\n            SYSUT1. This is the ddname to be used for the input  file.  It\n             must be a sequential file.\n\n            SYSUT2.  This is the ddname of the file containing the printed\n             blocks from the input file.\n\n            TAPECOPY. This is the ddname of the output tape  which  is  an\n             exact physical copy of the input tape volume.\n\n            tapemark. This is a special one byte record placed on the tape\n             by the tape drive which indicates the end of a physical file.\n             It  is  indicated  on  the  printout by a line of asterisks.\n\n            title.  If  T=title  is  coded  in the PARM, the characters in\n             title  are  printed  at the top of each page of SYSUT2.\n\n            translation.  When the F= format parameter is either A or B, a\n             character line is printed where each character corresponds to\n             the  ASCII  translation of each data byte. If any value other\n             than  A  is coded, an EBCDIC translation of each data byte is\n             printed. If F=B is coded,  both an ASCII translated line  and\n             an EBCDIC translated line are printed.\n\n\n                              SUPRDUMP                          Index  I-1\n\n                               \u00fc13 INDEX\n\n\n            A subparameter  3-1,5-4,A-1\n            ABEND  5-1\n            access methods  5-7\n            ampersand  5-6\n            ASCII  5-3,5-4\n\n\n            backwards processing  3-1,5-3,5-7\n            B subparameter of F parameter  3-1,5-4,A-1\n            BDW  v,5-5,6-2\n            BLKSIZE  6-1,6-2,6-3\n                 last  v\n                 maximum  v,5-3\n                 minimum  v,5-3\n            block  5-7\n            BLOCK COUNT PARAMETER  5-3\n            block descriptor word  see BDW\n            BLP  5-5,6-1,6-2,6-3,7-3,G-3\n\n\n            C=  see BLOCK COUNT PARAMETER\n            C subparameter of F parameter  5-4\n            CA-1  6-1\n            carriage control  see print control characters\n            cartridge tapes  6-4\n            CLIST  B-1\n            completion codes  8-1\n            concatenated files  6-1\n            CONFIG  6-3\n            core memory required  2-1\n            CSW  (channel-status word)  6-4\n\n\n            D=  see DIAGNOSTICS PARAMETER\n            DCB  v,6-1\n            density 8-7\n            DIAGNOSE file  5-1,6-4\n            DIAGNOSTICS PARAMETER  5-7\n            directory  see PDS directory\n            DISP  6-1\n            DSCB  6-1\n            DSN  v\n            dummy  see null file\n\n\n            EBCDIC  5-3,5-4\n            end of volume  5-5\n            EOV1  5-5\n            error messages  8-1\n            EXCP macro  G-2\n            EXPDT  6-1,7-3\n\n\n                              SUPRDUMP                          Index  I-2\n\n            F=  see PRINT FORMAT PARAMETER\n            file sequence number  see logical/physical file\n            FT11F001  6-3\n            FT12F001  6-3\n\n\n            GROUP LENGTH PARAMETER  5-5\n\n\n            H subparameter of F parameter  5-4\n            HDR1  5-5\n\n            input file  see SYSUT1\n            installation procedure  5-3\n            IOB (input/output block)  6-4\n\n\n            JCL PROCedure  5-1\n            JCL (program)  5-1, 5-6\n            JOBLIB  5-1\n\n\n            L subparameter of F parameter  5-4\n            LABEL=(n,BLP)  6-1,6-2,6-3\n            label type  6-2\n            logical/physical file  G-3\n            LRECL  6-1\n\n\n            message file  see SYSPRINT\n            multiple reel file  5-5,6-1\n\n\n            N=  see NUMBER OF FILES PARAMETER\n            null file  5-5\n            NUMBER OF FILES PARAMETER  5-5\n\n\n            OS CVOL    6-1\n            output file  see SYSUT2\n\n\n            P subparameter of F parameter  5-4\n            PARM  v,5-3\n            partial block printing  5-4\n            PDS directory 6-1\n            PREFACE  5-4\n            printer control characters  5-3\n            PRINT FORMAT PARAMETER  5-3,5-4\n            print file  see SYSUT2\n\n\n            Quote  5-6\n\n\n                              SUPRDUMP                          Index  I-3\n\n            R subparameter of F parameter  5-4\n            R=  see GROUP LENGTH PARAMETER\n            RDW  v,5-6,6-2\n            RECFM   see record format\n            record descriptor word   see RDW\n            record format  6-1,6-2\n            recording mode  8-7\n            ruler line  5-4,G-3\n\n\n            S=   see SKIP PARAMETER\n            SAS  2-1,5-1,6-3,C-1\n            SASHELP 5-1,6-3,7-4\n            SASMSG  5-1,6-3,7-4\n            SAS370  5-1\n            sequential file  v,6-1,6-2\n            SENSE command  6-4\n            sense information  6-4\n            SKIP PARAMETER  5-6\n            SL  6-2\n            statistics  5-1\n            status (unit and channel)  6-4\n            STEPLIB  5-1\n            subparameters of F parameter\n                 A  5-4\n                 C  5-4\n                 H  5-4\n                 L  5-4\n                 R  5-4\n            SYSCTLG  6-2\n            SYSIN   6-3\n            SYSPRINT  5-1,6-2\n            system configuration  2-1\n            SYSUDUMP  5-1\n            SYSUT1  v,5-1,5-3,6-1,8-6\n            SYSUT2  v,5-1,5-3,6-1,6-2,8-1\n\n\n            T=  see TITLE PARAMETER\n            TAPECOPY  v,5-1,6-3,35\n            tape files  v,5-3,5-5,6-1\n            tape labels  v\n            tape length  5-4,8-7\n            tape management system  see CA-1\n            tapemark  v,6-1\n            TITLE PARAMETER  5-6\n            translation (ASCII TO EBCDIC)  v,5-3,5-4\n\n\n            V (R=V)  5-5,A-1,G-3\n            variable length records  v,5-3\n            vertical hex  5-4,A-1\n            VOL header  6-3\n            VOL=REF=    6-2\n            VOL=SER=    6-2\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT807/CBT.V500.FILE807.PDS/$$DOCS.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT807/CBT.V500.FILE807.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}