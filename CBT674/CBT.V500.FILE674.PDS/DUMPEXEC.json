{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "MA133", "INMTNODE": "MA133", "INMTUID": "N1", "INMFTIME": "20040510134327000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "MA133.TSO.SVCDUMPS.SYSEXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"MA133.TSO.SVCDUMPS.SYSEXEC": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 160, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "040129", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x05'", "DS1LSTAR": "b'\\x00\\x04\\n'", "DS1TRBAL": "b's\\x04'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x9b\\x80\\xb8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x9b\\x80\\xb8'", "b'X\\xf3\\x08\\xe8\\x00\\x00\\x01&\\x00\\x01\\x01+\\x00\\x00\\x00K'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$DOC": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00H\\x01\\x04\\x12\\x9f\\x01\\x04\\x12\\x9f\\x11X\\x00&\\x00\\t\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-05-08T00:00:00", "modifydate": "2004-05-08T11:58:48", "lines": 38, "newlines": 9, "modlines": 0, "user": "MA133"}, "text": "/*********************************************************************/\n/* Welcome to SVCDumps                                               */\n/*********************************************************************/\nTHESE UTILITIES ARE PROVIDED AS IS WITH NO WARRANTIES OR GUARANTEES OF\nANY KIND WHATSOEVER. USE AT YOUR OWN RISK!\n\nyou may contact me at: mvs@robinandmariette.com\nyou may recieve udpates at: http://www.robinandmariette.com/mvs/rexx/\n\nI tried a couple of freeware svcdump managers, and found they didn't\nmeet my needs. They were a bit dated, being written in clist or\nassembler. I decided to write one in rexx from scratch. Although the\nexternal interface may look similar to others you've seen, the internal\ncode has been written from scratch and is completely original.\n\nThis code will handle SVC dumps in either SYS1.DUMPxx format or using\nthe dynamic dump method by using the 'DD NAME=' operator command. The\nonly requirement with the dynamic method is that you specify a date\nand time in the dump dataset qualifiers so that the dump management\ncan be properly executed.\n\nYou can park your dumps on sms or non-sms packs. If you use non-sms,\nit is better if you specify a pool of candidate packs (see the $install\nmember for details) and install MXI off the cbttape. Using MXI will\nenable the dump manager to pick the pack with the most freespace,\nsimilar to what sms would do. If you don't want to use sms or the\nnon-sms pooling, you can specify just one non-sms pack for dump usage,\nand it is then up to you to ensure enough space is available.\n\nA flat file log is maintained of the dumps, and any processing of the\nlog, via batch or online, occurs via an ISPF private table shell. When\nthe batch or interactive processing is complete, only the updated\nrecords are copied back into the log, and even then only if you have the\nlatest timestamp than what is in the log. The log is thus properly\nmaintained in a shared environment. I find this method easier to manage\nand code than using a shared ISPF table approach.\n\nTo install, follow the steps in the $install member.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INSTALL": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x03\\x01\\x04\\t\\x9f\\x01\\x04\\x12\\x9f\\x12\\x04\\x00U\\x00\\x0c\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2004-04-08T00:00:00", "modifydate": "2004-05-08T12:04:03", "lines": 85, "newlines": 12, "modlines": 0, "user": "MA133"}, "text": "/*********************************************************************/\n/* Installation of SVCDumps                                          */\n/*********************************************************************/\n* decide if you are going to use the old standard SYS1.DUMPxx dump\n  datasets or the dynamic dumps set up with the 'DD NAME=' operator\n  command. this tool can handle either, but should you decide to use\n  dynamic dumps, ensure that the GETDPFX exec is set up to reflect the\n  dynamic name you choose. make sure you specify a date, time and\n  sequence number in your dump prefix name. you should not pick a prefix\n  length greater than 37 to allow room for work dataset suffixes.\n\n* if you will not be using sms volumes for the dump datasets, update\n  GETDVOL to place candidate, non-sms packs in a list for volume\n  pooling.  this will require that you download and install MXI (a\n  fantastic product you should not be without) from www.cbttape.org so\n  that the DUMPSPCE exec can determine which of the GETDVOL volumes has\n  the maximum freespace. if you don't want to use volume pooling, or\n  can't install MXI, just specify one volume in this member, and make\n  sure space is available on this pack by using aggressive archiving.\n\n  NOTE: for some reason using MXI rexx calls for the OMVS security\n  segment. if the SYSDUMP proc doesn't have access to this, you'll get\n  security warnings, but the exec still works.\n\n* review each of the other GET... execs and adjust to your shop\n  standards.  i should have used a parmlib for this, but coding little\n  functions was easier for this project.\n\n* review ISPSLIB(JOBCARD) to update the job card to your standards.\n\n* review each of the other members in ISPSLIB to use the tool of your\n  choice for the various maintenance tasks that svcdumps performs.\n\n* update exec SVCDUMPS to reflect your high level qualifiers and copy it\n  to a common SYSEXEC dataset so that it's available for the system\n  programmers. this is the ISPF interface exec.\n\n* review and update SYSDUMP proc and copy it to a system proclib. in\n  order for SYSDUMP to accurately determine the date/time on SYS1.DUMPxx\n  system dumps, the SYSDUMP proc should be assigned a security id that\n  can either issue the OPSCMD CA-OPS/MVS command processor, or the TSO/E\n  CONSOLE command, and the method of choice should be updated in member\n  GETDOPER. the proc will still work without these interfaces, but the\n  time stamps for the dumps in the log and ispf table will not always be\n  precise.\n\n* create a gdg base for SYSDUMP's SYSTSPRT dataset and update the JCL to\n  point to a stupid model DCB.  this allows you to review older output\n  from SYSDUMP, and also prevents multiple SYSDUMPs from running at the\n  same time due to the enq. this is desirable in a situation where\n  something's dumping over and over again.\n\n* install automation rules to start the SYSDUMP proc whenever a dump\n  occurs. there are two messages to intercept:\n  *IEA911E COMPLETE DUMP ON SYS1.DUMPxx 506\n   DUMPID=011 REQUESTED BY JOB (*MASTER*)\n   FOR ASID (0087)\n   INCIDENT TOKEN: PRODPLEX PROD     04/08/2004 18:50:03\n\n   IEA611I COMPLETE DUMP ON dynamic-dump-dataset-name\n   DUMPID=001 REQUESTED BY JOB (*MASTER*)\n   FOR ASID (004B)\n   INCIDENT TOKEN: TESTPLEX MLAC     04/20/2004 14:46:01\n   IEA650I SYSPLEX DUMP DIRECTORY ENTRY NOT PROCESSED\n\n  start it in the form of \"S SYSDUMP,PRM='DUMP=dump-name'\".  sample\n  ca-ops/mvs rules are in the opsmsg1 and opsmsg2 members.\n\n* if you don't use system archiving to manage these files, in the wee\n  hours of the morning, have automation start SYSDUMP with\n  PRM='PURGE=60,ARCH=3' to archive and purge dumps based on the number\n  of days old. see member opstod1. SYSDUMP will process commands in the\n  order you specify them, so you should do the purge followed by the\n  archive. if you reverse the order, you could expend cpu and io\n  archiving a dump, only to have the purge step delete it.\n\n* an hour or two later, start SYSDUMP with PRM='SYNC=Y' to syncronize\n  the dump log with the correct statuses, and to check for orphaned\n  dumps in the log and catalog. see member opstod2.\n\n* if you are at os/390 2.10, install UW75207 if you plan to use IPCS\n  with this product. this will ensure that the IPCSDDIR is freed when\n  you exit IPCS.\n\n* proceed to the $ivp member\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$IVP": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00Q\\x01\\x04\\x10o\\x01\\x04\\x12\\x9f\\x12\\x04\\x00$\\x00$\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2004-04-15T00:00:00", "modifydate": "2004-05-08T12:04:51", "lines": 36, "newlines": 36, "modlines": 0, "user": "MA133"}, "text": "this ivp assumes you have followed all the steps in $install.\n\n* take a dump of an address space using the 'dump comm=()' command.\n\n* ensure that SYSDUMP proc starts from the automation rules once message\n  IEA911E/IEA611I is issued (this may take a couple of minutes).\n\n* when SYSDUMP is complete, check to ensure that it created a new\n  dumplog dataset (as specified in GETDLOG() exec) with a dump entry of\n  your dump.\n\n* check the SYSTSPRT DD output of SYSDUMP and make sure there are no\n  errors or failures.\n\n* enter 'TSO SVCDUMPS' to go to your ISPF table.\n\n* enter 'HELP' to review the primary and line commands.\n\n* go back to the table display and select the dump with 'S'.\n\n* attempt a terse of the dump with option 'T'.\n\n* attempt to FTP the dump with option 'F'.\n\n* use the 'A' command to archive the dump to tape.\n\n* when the archive job finishes, enter 'SYNC' to clear the PEND status\n  of the dump.\n\n* use the 'R' command to recall the dump from tape.\n\n* when the recall job finishes, enter 'SYNC' to clear the PEND status\n  of the dump.\n\n* manually start \"S SYSDUMP,PRM='PURGE=60,ARCH=3'\" and ensure there are\n  no errors in the SYSTSPRT dataset.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPANAL": {"ttr": 25, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00 \\x01\\x04\\t/\\x01\\x04\\x10\\x7f\\x11D\\x00=\\x00(\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2004-04-01T00:00:00", "modifydate": "2004-04-16T11:44:20", "lines": 61, "newlines": 40, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg DumpIn .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN 'NOTAB',Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- this will perform an analysis of the dump passed.               -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nDumpIn = Strip(DumpIn,\"B\",\"'\")\nIf DumpIn = '' Then Signal Failure\n/* if it's a sys1.dump dataset, then copy it to our naming standard  */\n/* and clear the dump dataset for the next guy to use.               */\nIf Left(DumpIn,9) = 'SYS1.DUMP' & Length(DumpIn) = 11 Then Do\n  DumpIn = DumpCopy(DumpIn)\n  DumpIn = Strip(DumpIn,\"B\",\"'\")\nEnd\nIf DumpIn = 12 Then Signal Failure\n\nSay '>>>>>DUMPANAL: Performing analysis on' DumpIn\n\n/* clean up work datasets just in case they already exist.           */\nPrefix = Substr(DumpIn,1,LastPos('.',DumpIn))\nDDir = Prefix'DDIR'\nToc  = Prefix'ITOC'\nPrt  = Prefix'IPRT'\n\nx = Msg('OFF')\n\"DELETE '\"Toc\"'\"\n\"DELETE '\"Prt\"'\"\nx = Msg(x)\n\n/* analyze the dump using ipcs.                                      */\n\"%BLSCDDIR DSNAME(\"DDir\")\" GETDALOC(\"IPCS\")\n\"ALLOC F(IPCSDUMP) DA('\"DumpIn\"') SHR\"\n\"ALLOC F(IPCSTOC) DA('\"Toc\"') NEW CATALOG RELEASE\" ,\n  \"SPACE(1 1) TRACKS\" GETDALOC(\"TSO\")\n\"ALLOC F(IPCSPRNT) DA('\"Prt\"') NEW CATALOG RELEASE\" ,\n  \"SPACE(5 5) TRACKS\" GETDALOC(\"TSO\")\n\n\"%BLSCBSVA\" DumpIn\n\n\"FREE F(IPCSDUMP,IPCSTOC,IPCSPRNT,IPCSDDIR)\"\n\nSay '>>>>>DUMPANAL: Analysis complete'\n\nReturn DumpIn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPARCH": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x18\\x01\\x04\\t\\x7f\\x01\\x04\\x11O\\x117\\x00g\\x00G\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2004-04-06T00:00:00", "modifydate": "2004-04-23T11:37:18", "lines": 103, "newlines": 71, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg ArchDays .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN DumpTab,Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- this will run the archive for the dumps. pass the number of     -*/\n/*- days to archive.                                                -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nIf ArchDays = '' | Datatype(ArchDays) <> 'NUM' Then Signal Failure\n\n/* convert the dump log to an ispf table.                            */\nParse Value LOG2TAB() With DumpTab TimeOpened .\nIf DumpTab = 4  Then Return 4\nIf DumpTab = 12 Then Signal Failure\n\nSay '>>>>>DUMPARCH: Archiving dumps over' ArchDays 'days old'\n\nAddress ISPEXEC\n\"TBTOP\" DumpTab\nDo Forever\n  \"TBSKIP\" DumpTab \"NUMBER(1)\"\n  If RC > 0 Then Leave\n\n  If Hold = 'H' Then Iterate\n\n  Prefix = GETDPFX(Date,Time,Seq)\n  Parse Value DUMPSTAT(Prefix) With Status1 Status2 .\n  If Status1 = 'TAPE' Then Iterate\n\n  /* calculate the number of days old this dump is.                  */\n  Date2 = Left(Date('S'),2) || Date              /* make four digits */\n  Days = Date('B') - Date('B',Date2,'S')\n  If Days <= ArchDays Then Iterate\n\n  /* see if this dump has already been archived once.                */\n  If Status1 = 'DISK' & Status2 = 'TAPE' Then Call DeleteRecalled\n  Else Call ArchiveJob\n\n  /* update our table.                                               */\n  Status = 'TAPE'\n  Stamp = DUMPSTMP()\n  \"TBMOD\" DumpTab\nEnd\n\n/* copy the table back to the dump log.                              */\nCall TAB2LOG DumpTab TimeOpened\n\nSay '>>>>>DUMPARCH: Completed archive cycle'\n\nReturn 0\n/*-------------------------------------------------------------------*/\n/*- remove recalled datasets for previously archived dumps.         -*/\n/*-------------------------------------------------------------------*/\nDeleteRecalled:\n\nSay '>>>>>DUMPARCH:' Prefix'.DUMP has been previously archived' ,\n  'and recalled. Deleting recalled datasets'\n\nQuals = GETDQUAL()\nExcl = GETDEXCL() 'TAPE'               /* just to make sure */\nDo While Words(Quals) > 0\n  Parse Var Quals Qual Quals\n  If WordPos(Qual,Excl) > 0 Then Iterate\n  Dsn = Prefix'.'Qual\n  If Sysdsn(\"'\"Dsn\"'\") = 'DATASET NOT FOUND' Then Iterate\n  Address TSO \"DELETE '\"Dsn\"'\"\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- submit a job to archive the dump to tape.                       -*/\n/*-------------------------------------------------------------------*/\nArchiveJob:\n\nSay '>>>>>DUMPARCH:' Prefix'.DUMP is' Days 'days old'\n\n/* construct and submit the dump arch job. the dumparcj is used      */\n/* by dumpispf as well, that's why it's an external routine.         */\nIf DUMPARCJ(Prefix) = 12 Then Signal Failure\n\"VGET ZTEMPN SHARED\"; If RC <> 0 Then Signal Failure\nAddress TSO\n\"EXECIO * DISKR\" ZTEMPN \"(FINIS\"\nQueue ''\n\"SUBMIT *\"\nAddress ISPEXEC\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPARCJ": {"ttr": 770, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x001\\x01\\x04\\t\\x7f\\x01\\x04\\x11O\\x11A\\x009\\x00\\x19\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2004-04-06T00:00:00", "modifydate": "2004-04-23T11:41:31", "lines": 57, "newlines": 25, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Prefix .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN 'NOTAB',Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- this will construct an archive job. used by dumparch and dumpispf*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\n/* get a list of datasets that will be archived to tape. */\niDsn = 0\nQuals = GETDQUAL()\nExcl = GETDEXCL() 'TAPE'\nDo While Words(Quals) > 0\n  Parse Var Quals Qual Quals\n  If WordPos(Qual,Excl) > 0 Then Iterate\n  Dsn = Prefix'.'Qual\n  If Sysdsn(\"'\"Dsn\"'\") = 'DATASET NOT FOUND' Then Iterate\n  iDsn = iDsn + 1\n  Dsn.iDsn = Dsn\nEnd\nDsn.0 = iDsn\n\n/* construct the job to archive the datasets. */\nAddress ISPEXEC\n\"FTOPEN TEMP\";     If RC <> 0 Then Signal Failure\n\"FTINCL JOBCARD\";  If RC <> 0 Then Signal Failure\n\"FTINCL ARCH1\";    If RC <> 0 Then Signal Failure\n\nDo iDsn = 1 To Dsn.0\n  Dsn = Dsn.iDsn\n  \"FTINCL ARCH2\";  If RC <> 0 Then Signal Failure\nEnd\n\"FTINCL ARCH3\";    If RC <> 0 Then Signal Failure\nDo iDsn = 1 To Dsn.0\n  Dsn = Dsn.iDsn\n  \"FTINCL ARCH4\";  If RC <> 0 Then Signal Failure\nEnd\n\n\"FTINCL ARCH5\";    If RC <> 0 Then Signal Failure\n\"FTCLOSE\";         If RC <> 0 Then Signal Failure\n\nReturn 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPCLN": {"ttr": 27, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x004\\x01\\x04\\t\\x8f\\x01\\x04\\x10\\x7f\\x11R\\x00\\x17\\x00\\x0f\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2004-04-07T00:00:00", "modifydate": "2004-04-16T11:52:34", "lines": 23, "newlines": 15, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg DumpTab, Source\n/* clean up after an error was encountered somewhere.           */\n/* pass the name of the dump table if any, and the source rexx. */\nParse Var Source . Type Exec DD .\nSay '  ...in' Type Exec 'loaded from' DD\n\nAddress TSO                    /* clear up external data queue. */\n\"QSTACK\"; Stacks = RC;\nDo Stacks; \"DELSTACK\"; End;\n\nAddress ISPEXEC                /* clean up ispf junk.           */\n\"CONTROL ERRORS RETURN\"\n\"FTCLOSE\"\nIf DumpTab <> 'NOTAB' & DUMPTAB <> 12 Then Do\n  \"TBEND\" DumpTab\n  \"LIBDEF ISPTLIB\"\nEnd\n\nZISPFRC = 12                   /* set batch return code.        */\n\"VPUT ZISPFRC SHARED\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPCOPY": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01)\\x00!\\x01\\x04\\t\\x1f\\x01\\x04\\x11\\x1f\\x113\\x00P\\x000\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.41", "flags": 0, "createdate": "2004-03-31T00:00:00", "modifydate": "2004-04-20T11:33:21", "lines": 80, "newlines": 48, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg DumpIn .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN 'NOTAB',Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- copy a sys1.dumpxx to our naming standards and clear it.        -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nDumpIn = Strip(DumpIn,\"B\",\"'\")\nIf Left(DumpIn,9) <> 'SYS1.DUMP' & Length(DumpIn) <> 11 Then\n  Signal Failure\n\n/* dump date will get the date/time of the dump */\nParse Value DUMPDATE(DumpIn) With Date Time Title\nIf Date = 12 Then Signal Failure\nIf ListDsi(\"'\"DumpIn\"'\") > 4 Then Do\n  Say \"ListDsi failure for\" DumpIn\n  Say \"Reason is\" SYSREASON\n  Signal Failure\nEnd\n\n/* this is where the dataset name is built for the dump, based on the*/\n/* date and time quals passed Dyymmdd Thhmmss. builds a sequence     */\n/* number on the end similar to the way the DD NAME command does, so */\n/* that switching to dynamic dumps can share the same naming         */\n/* convention as SYS1.DUMPxx. this exec would only be called then for*/\n/* SYS1.DUMPxx datasets to convert them to the DD NAME names. this   */\n/* does not exactly mimic the dynamic dump method, but is close      */\n/* enough to be able to share naming conventions.                    */\nDumpOut = ''\nDo Seq = 1 To 99999\n  Prefix = GETDPFX(Date,Time,Seq)\n  Quals = GETDQUAL() 'DUMP'          /* double check DUMP at the end */\n  Do Words(Quals) > 0                /*   just before creating it.   */\n    Parse Var Quals Qual Quals\n    Dsn = Prefix'.'Qual\n    Sysdsn = Sysdsn(\"'\"Dsn\"'\")\n    If Sysdsn <> 'DATASET NOT FOUND' Then Iterate\n    If Left(Sysdsn,7) = 'INVALID' Then Signal Failure\n  End\n  DumpOut = Prefix'.DUMP'\n  Leave\nEnd\nIf DumpOut = '' Then Signal Failure\nSay '>>>>>DUMPCOPY: Copying' DumpIn 'to' DumpOut\n\n\"ALLOC F(DUMPOUT) DA('\"DumpOut\"') NEW CATALOG\" ,\n  \"SPACE(\"SYSUSED\")\" SYSUNITS GETDALOC(\"TSO\")\n\"ALLOC F(DUMPIN) DA('\"DumpIn\"') SHR\"\n\n/* allocate a ddir for ipcs to use. */\nDDir = Prefix || '.DDIR'\n\"%BLSCDDIR DSNAME(\"DDir\")\" GETDALOC(\"IPCS\")\n\n/* do ipcs. */\nQueue ,\n  \"COPYDUMP INFILE(DUMPIN) OUTFILE(DUMPOUT) NOPRINT NOCONFIRM CLEAR\"\nQueue \"END\"\n\"IPCS NOPARM\"\n\n\"FREE F(DUMPIN,DUMPOUT)\"\n\nSay '>>>>>DUMPCOPY: Completed copy'\n\nReturn DumpOut\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPDATE": {"ttr": 29, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x002\\x01\\x04\\t\\x7f\\x01\\x04\\x10\\x7f\\x11V\\x00v\\x00q\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2004-04-06T00:00:00", "modifydate": "2004-04-16T11:56:32", "lines": 118, "newlines": 113, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg DumpIn .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN 'NOTAB',Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- this exec will return the date and time captured for a dump     -*/\n/*- dataset by displaying them via the 'd d,t' command. pass the    -*/\n/*- dsn you are interested in like sys1.dump00 or just dump00.      -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n/*IEE853I 14.06.31 SYS1.DUMP TITLES 080\n  SYS1.DUMP DATA SETS AVAILABLE=002 AND FULL=001\n  CAPTURED DUMPS=0000, SPACE USED=00000000M, SPACE FREE=00000500M\n       DUMP00 TITLE=ZEBB02A ESTAE dump\n           DUMP TAKEN TIME=10.32.08 DATE=03/30/2004\n  NO DUMP DATA AVAILABLE FOR THE FOLLOWING EMPTY SYS1.DUMP DATA SETS:\n  01-02\n*/\n\nSay '>>>>>DDTDATE: Resolving date/time for' DumpIn\n\n/* make sure we have a valid dsn */\nDumpIn = Strip(DumpIn,\"B\",\"'\")\nIf Left(DumpIn,5) = 'SYS1.' Then DumpIn = Substr(DumpIn,6)\nParse Var DumpIn 'DUMP' Dump .\nIf Datatype(Dump) <> 'NUM' | Length(Dump) <> 2 Then Signal Failure\n\n/* issue the command via the console tso/e service or opsmvs command */\nMsg.0 = 0\nHow = GETDOPER()\nIf How = 'CONSOLE' Then Call GetFromConsole\nElse If How = 'OPSMVS' Then\n  \"OPSCMD COMMAND('D D,T') STOPEND(YES) CMDRESP(REXX) PREFIX(MSG)\"\n\n/* play with the results. look for the dsn we're interested in. */\nIf Msg.0 = 0 Then Return CurrentDateTime()\nFound = 0\nParse Value '' With Title Date Time\nDo iMsg = 1 To Msg.0\n  If Found = 0 Then Do\n    Parse Var Msg.iMsg 6 Dsn ' TITLE=' Title\n    If Dsn = DumpIn Then Do\n      Found = 1\n      Iterate\n    End\n  End\n  If Found Then Do\n    Parse Var Msg.iMsg 'DUMP TAKEN TIME=' Time ' DATE=' Date .\n    If Date = '' Then Iterate\n    Parse Var Time HH '.' MM '.' SS\n    Time = 'T' || HH || MM || SS\n    Parse Var Date MO '/' DA '/' YR\n    YR = Right(YR,2)\n    Date = 'D' || YR || MO || DA\n    Leave\n  End\nEnd\nIf Date = '' Then Return CurrentDateTime()\n\nSay '>>>>>DDTDATE: Resolved to' Date Time 'for dump' Title\n\nReturn Date Time Title\n/*-------------------------------------------------------------------*/\n/*- the console command failed. assume the dump occured right now   -*/\n/*- and return the current date and time.                           -*/\n/*-------------------------------------------------------------------*/\nCurrentDateTime:\n\nDate = 'D'Right(Date('S'),6)\nParse Value Time('N') With HH ':' MM ':' SS\nTime = 'T'HH || MM || SS\n\nSay '>>>>>DDTDATE: Unable to determine dump date/time from display' ,\n    'operator command (D D,T).'\nSay '>>>>>DDTDATE: Defaulted to' Date Time '(current date/time)'\nSay '>>>>>DDTDATE: Dump title is unknown'\n\nReturn Date Time 'UNKNOWN'\n/*-------------------------------------------------------------------*/\n/*- get the dump date/time from the tso console command.            -*/\n/*-------------------------------------------------------------------*/\nGetFromConsole:\n\nSaveDisp = Sysvar('SOLDISP')\n\"CONSPROF SOLDISPLAY(NO)\"\nIf RC > 0 Then Return CurrentDateTime()\n\"CONSOLE ACTIVATE\"\n\nGetMsg = 0\niMsg = 0\n\"CONSOLE SYSCMD(D D,T) CART(DDT)\"\nDo While GetMsg = 0\n  GetMsg = GetMsg('Resp.','SOL','DDT',,10)\n  If GetMsg = 0 Then Do iResp = 1 To Resp.0\n    iMsg = iMsg + 1\n    Msg.iMsg = Resp.iResp\n  End\nEnd\nMsg.0 = iMsg\n\n\"CONSOLE DEACTIVATE\"\n\"CONSPROF SOLDISPLAY(\"SaveDisp\")\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPEDJB": {"ttr": 31, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x08\\x01\\x04\\t/\\x01\\x04\\x10\\x7f\\x12\\x01\\x00(\\x00\\x1f\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2004-04-01T00:00:00", "modifydate": "2004-04-16T12:01:08", "lines": 40, "newlines": 31, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\n/* don't do the usual cleanup, just get out of this edit */\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress ISREDIT \"CANCEL\"\nReturn\n/*-------------------------------------------------------------------*/\n/*- this will edit an ipcs dump report and extract the jobname      -*/\n/*- associated with the dump. it's done with and edit macro so it   -*/\n/*- will be fairly fast. beats scanning each line with rexx.        -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nAddress ISREDIT\n\"MACRO\"\nIf RC > 0 Then Signal Failure\n\n\"FIND '0CPU STATUS:' 1 FIRST\"\n\"FIND ' JOB(' NEXT\"\n\"(LINE) = LINE .ZCSR\"\nParse Var Line ' JOB(' Job ')'\nIf Job = '' Then Signal Failure\n\nAddress ISPEXEC \"VPUT JOB SHARED\"\n\"CANCEL\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPFREC": {"ttr": 17, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x005\\x01\\x04\\t\\x8f\\x01\\x04\\t\\x9f\\x10W\\x00\\x08\\x00\\x08\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2004-04-07T00:00:00", "modifydate": "2004-04-08T10:57:35", "lines": 8, "newlines": 8, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this will format a log entry from the various fields passed. this */\n/* is in a common routine just for maintenance purposes. all fields  */\n/* are considered valid. lower case is preserved.                    */\nParse Arg Date, Time, Seq, Job, Status, Hold, Title, Stamp\nLogRec = Date Time Left(Seq,5) Left(Job,8) Left(Status,4) Hold Title\nLogRec = Overlay(Stamp,LogRec,156-Length(Stamp))\nReturn LogRec\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DUMPISPF": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00H\\x01\\x04\\t?\\x01\\x04\\x12O\\x13\\x01\\x01\\xcc\\x00G\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2004-05-03T13:01:48", "lines": 460, "newlines": 71, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN DumpTab,Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- The main exec routine.                                          -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nAddress ISPEXEC\n\"VGET ZAPPLID\"\nIf ZAPPLID \\= 'SD' Then Do\n  \"SELECT CMD(%DUMPISPF) NEWAPPL(SD) PASSLIB\"\n  Exit RC\nEnd\n\nParse Value LOG2TAB() With DumpTab TimeOpened .\nIf DumpTab = 4  Then Return 4\nIf DumpTab = 12 Then Signal Failure\nCall DisplayTable\nCall TAB2LOG DumpTab TimeOpened\n\nReturn 0\n/*-------------------------------------------------------------------*/\n/*- The main exec routine.                                          -*/\n/*-------------------------------------------------------------------*/\nDisplayTable:\n\nAddress ISPEXEC\n\"TBVCLEAR\" DumpTab           /* hide all deleted entries */\nHold = 'D'\n\"TBSARG\" DumpTab \"NAMECOND(HOLD,NE)\"\n\"TBSORT\" DumpTab \"FIELDS(DATE,N,D,TIME,N,D,SEQ,N,D)\"\n\n\"SETMSG MSG(SD000)\"\n\nCURSOR = 'LC'; CSRROW = 0; ZTDTOP = 0;\nScan = 'SCAN'                            /* set to 'all' for no scan */\nDo Forever\n  \"TBTOP\" DumpTab\n  \"TBSKIP\" DumpTab \"NUMBER(\"ZTDTOP\") NOREAD\"\n  \"TBDISPL\" DumpTab \"PANEL(SDMAIN1) POSITION(CRP) ROWID(ROW)\" ,\n    \"AUTOSEL(NO) CSRROW(\"CSRROW\") CURSOR(\"CURSOR\")\"\n  If RC > 8 Then Signal Failure\n  If RC > 4 Then Leave\n  CURSOR = 'ZCMD'\n\n  If ZCMD <> '' Then Do                  /* primary commands go here */\n    Upper ZCMD\n    Parse Var ZCMD Verb Rest\n    Verb = Word(ZCMD,1)\n    Select\n      When Verb = 'SYNC' Then Call Sync Rest\n      When Verb = 'SAVE' Then Call Save Rest\n      When Verb = 'SORT' Then Call Sort Rest\n      When Verb = 'SORTCOMP' Then Call Sorttb DumpTab\n      Otherwise Nop\n    End\n  End\n\n  Do While ZTDSELS > 0                      /* line commands go here */\n    Upper LC\n    If Status = 'PEND' & LC <> 'Y' Then \"SETMSG MSG(SD003)\"\n    Else If Hold = 'H' & WordPos(LC,'DD A AS R RS') > 0 Then\n      \"SETMSG MSG(SD004)\"\n    Else Select\n      When LC = 'S'  Then Call Select\n      When LC = 'N'  Then Call Notes\n      When LC = 'I'  Then Call Info\n      When LC = 'H'  Then Call Hold\n      When LC = 'DD' Then Call Delete\n      When LC = 'A'  Then Call Archive\n      When LC = 'AS' Then Call Archive 'SUBMIT'\n      When LC = 'R'  Then Call Recall\n      When LC = 'RS' Then Call Recall 'SUBMIT'\n      When LC = 'T'  Then Call Terse\n      When LC = 'TS' Then Call Terse 'SUBMIT'\n      When LC = 'F'  Then Call Ftp\n      When LC = 'TF' Then Call TerseFtp\n      When LC = 'IP' Then Call Ipcs\n      When LC = 'Y'  Then Call SyncOne\n      Otherwise \"SETMSG MSG(SD005)\"\n    End\n    If ZTDSELS > 1 Then \"TBDISPL\" DumpTab \"POSITION(CRP) ROWID(ROW)\"\n    Else ZTDSELS = 0\n    CURSOR = 'LC'\n  End\n  LC = ' '\n  \"TBGET\" DumpTab \"POSITION(CSRROW)\"       /* place cursor properly */\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- the user selected a dump. display the IPRT ipcs output dataset. -*/\n/*-------------------------------------------------------------------*/\nSelect:\n\nPrefix = GETDPFX(Date,Time,Seq)\nPrint = Prefix'.IPRT'\n\n\"CONTROL DISPLAY SAVE\"\n\"CONTROL ERRORS RETURN\"\n\"VIEW DATASET('\"Print\"')\"\nSaveRC = RC\n\"CONTROL ERRORS CANCEL\"\n\"CONTROL DISPLAY RESTORE\"\nIf SaveRC > 0 Then \"SETMSG MSG(SD012)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- the user wants to open a notes dataset for the dump.            -*/\n/*-------------------------------------------------------------------*/\nNotes:\n\nPrefix = GETDPFX(Date,Time,Seq)\nNotes = Prefix'.NOTES'\n\nSysdsn = Sysdsn(\"'\"Notes\"'\")\nIf Sysdsn = \"DATASET NOT FOUND\" Then Do\n  Address TSO\n  \"ALLOC F(NOTES) DA('\"Notes\"') NEW CATALOG\" ,\n    \"SPACE(4 2) TRACKS LRECL(133) RECFM(F B) DSORG(PS)\" ,\n    GETDALOC(\"TSO\")\n  \"FREE F(NOTES)\"\n  Address ISPEXEC\nEnd\n\n\"CONTROL DISPLAY SAVE\"\n\"CONTROL ERRORS RETURN\"\n\"EDIT DATASET('\"Notes\"')\"\nSaveRC = RC\n\"CONTROL ERRORS CANCEL\"\n\"CONTROL DISPLAY RESTORE\"\nIf SaveRC > 0 Then \"SETMSG MSG(SD012)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- the user wants info on the dataset. display the info panel.     -*/\n/*-------------------------------------------------------------------*/\nInfo:\n\nParse Var Title TITLE1 51 TITLE2\nParse Var Time HH 3 MM 5 SS\nTIMEN = HH':'MM':'SS\nDATEN = Left(Date('S'),2) || Date\nDATEN = Date('N',DATEN,'S')\n\"CONTROL DISPLAY SAVE\"\n\"ADDPOP\"\n\"DISPLAY PANEL(SDINFO)\"\n\"REMPOP\"\n\"CONTROL DISPLAY RESTORE\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- toggle the old value of the dump.                               -*/\n/*-------------------------------------------------------------------*/\nHold:\n\nIf Hold = 'H' Then Hold = ' '\nElse Hold = 'H'\nStamp = DUMPSTMP()\n\"TBMOD\" DumpTab\n\"SETMSG MSG(SD000)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- delete the dump (when the tab2log exec is called).              -*/\n/*-------------------------------------------------------------------*/\nDelete:\n\nHold = 'D'\nStamp = DUMPSTMP()\n\"TBMOD\" DumpTab\n\"SETMSG MSG(SD006)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- archive the dump.                                               -*/\n/*-------------------------------------------------------------------*/\nArchive:\nArg Submit .\n\nPrefix = GETDPFX(Date,Time,Seq)\nParse Value DUMPSTAT(Prefix) With Status1 Status2 .\nIf Status1 = 'DISK' & Status2 = 'TAPE' Then Do\n  x = Msg('OFF')\n  Address TSO \"DELETE '\"Prefix\".TAPE'\"\n  x = Msg(x)\nEnd\nElse If Status1 = 'TAPE' Then Do\n  \"SETMSG MSG(SD007)\"\n  Return\nEnd\n\nIf DUMPARCJ(Prefix) = 12 Then Signal Failure\nCall EditSubmit Submit\n\nStatus = 'PEND'\nStamp = DUMPSTMP()\n\"TBMOD\" DumpTab\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- recall the dump.                                                -*/\n/*-------------------------------------------------------------------*/\nRecall:\nArg Submit .\n\nPrefix = GETDPFX(Date,Time,Seq)\nIf Word(DUMPSTAT(Prefix),1) = 'DISK' Then Do\n  \"SETMSG MSG(SD008)\"\n  Return\nEnd\n\n\"FTOPEN TEMP\";     If RC <> 0 Then Signal Failure\n\"FTINCL JOBCARD\";  If RC <> 0 Then Signal Failure\n\"FTINCL RECALL\";   If RC <> 0 Then Signal Failure\n\"FTCLOSE\";         If RC <> 0 Then Signal Failure\n\nCall EditSubmit Submit\n\nStatus = 'PEND'\nHold = 'H'\nStamp = DUMPSTMP()\n\"TBMOD\" DumpTab\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- terse the dump.                                                 -*/\n/*-------------------------------------------------------------------*/\nTerse:\nArg Submit .\n\nPrefix = GETDPFX(Date,Time,Seq)\nSysdsn = Sysdsn(\"'\"Prefix\".TRS'\")\nIf Sysdsn = 'OK' Then Do\n  \"SETMSG MSG(SD009)\"\n  Return\nEnd\n\nParse Value DUMPSTAT(Prefix) With Status1 .\nIf Status1 = 'TAPE' Then Do\n  \"SETMSG MSG(SD010)\"\n  Return\nEnd\n\nIf ListDsi(\"'\"Prefix\".DUMP'\") > 4 Then Do\n  Say \"ListDsi failure for\" Prefix\".DUMP\"\n  Say \"Reason is\" SYSREASON\n  Signal Failure\nEnd\nIf SYSUNITS = \"CYLINDER\" Then SYSUNITS = \"CYL\"\nIf SYSUNITS = \"TRACK\" Then SYSUNITS = \"TRK\"\nSpace = \"SPACE=(\"SYSUNITS\",(\"SYSUSED%1.8\",\"SYSUSED%3\"),RLSE)\"\nAlloc = GETDALOC('JCL')\n\n\"FTOPEN TEMP\";     If RC <> 0 Then Signal Failure\n\"FTINCL JOBCARD\";  If RC <> 0 Then Signal Failure\n\"FTINCL TERSE\";    If RC <> 0 Then Signal Failure\n\"FTCLOSE\";         If RC <> 0 Then Signal Failure\n\nCall EditSubmit Submit\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- ftp the dump.                                                   -*/\n/*-------------------------------------------------------------------*/\nFtp:\n\nPrefix = GETDPFX(Date,Time,Seq)\nDsn = Prefix'.TRS'\nSysdsn = Sysdsn(\"'\"Dsn\"'\")\nIf Sysdsn = 'DATASET NOT FOUND' Then Do\n  \"SETMSG MSG(SD011)\"\n  Return\nEnd\n\n\"ADDPOP\"\n\"DISPLAY PANEL(SDFTP)\"\nSaveRC = RC\n\"REMPOP\"\nIf SaveRC > 0 Then Return\n\nFTPDIR = Strip(FTPDIR1) || Strip(FTPDIR2)\n\"FTOPEN TEMP\";     If RC <> 0 Then Signal Failure\n\"FTINCL JOBCARD\";  If RC <> 0 Then Signal Failure\n\"FTINCL FTP\";      If RC <> 0 Then Signal Failure\n\"FTCLOSE\";         If RC <> 0 Then Signal Failure\n\nCall EditSubmit\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- terse and ftp the dump.                                         -*/\n/*-------------------------------------------------------------------*/\nTerseFtp:\n\nPrefix = GETDPFX(Date,Time,Seq)\nSysdsn = Sysdsn(\"'\"Prefix\".TRS'\")\nIf Sysdsn = 'OK' Then Do\n  \"SETMSG MSG(SD009)\"\n  Return\nEnd\n\nParse Value DUMPSTAT(Prefix) With Status1 .\nIf Status1 = 'TAPE' Then Do\n  \"SETMSG MSG(SD010)\"\n  Return\nEnd\n\nIf ListDsi(\"'\"Prefix\".DUMP'\") > 4 Then Do\n  Say \"ListDsi failure for\" Prefix\".DUMP\"\n  Say \"Reason is\" SYSREASON\n  Signal Failure\nEnd\nIf SYSUNITS = \"CYLINDER\" Then SYSUNITS = \"CYL\"\nIf SYSUNITS = \"TRACK\" Then SYSUNITS = \"TRK\"\nSpace = \"SPACE=(\"SYSUNITS\",(\"SYSUSED%1.8\",\"SYSUSED%3\"),RLSE)\"\nAlloc = GETDALOC('JCL')\n\nDsn = Prefix'.TRS'\n\"ADDPOP\"\n\"DISPLAY PANEL(SDFTP)\"\nSaveRC = RC\n\"REMPOP\"\nIf SaveRC > 0 Then Return\n\nFTPDIR = Strip(FTPDIR1) || Strip(FTPDIR2)\n\"FTOPEN TEMP\";     If RC <> 0 Then Signal Failure\n\"FTINCL JOBCARD\";  If RC <> 0 Then Signal Failure\n\"FTINCL TERSE\";    If RC <> 0 Then Signal Failure\n\"FTINCL FTP\";      If RC <> 0 Then Signal Failure\n\"FTCLOSE\";         If RC <> 0 Then Signal Failure\n\nCall EditSubmit\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- invoke ipcs on the dump.                                        -*/\n/*-------------------------------------------------------------------*/\nIpcs:\n\nPrefix = GETDPFX(Date,Time,Seq)\nDDir = Prefix'.DDIR'\nParse Value DUMPSTAT(Prefix) With Status1 .\nIf Status1 = 'TAPE' Then Do\n  \"SETMSG MSG(SD010)\"\n  Return\nEnd\n\nAddress TSO \"%BLSCDDIR DSNAME('\"DDir\"')\"\n\"SETMSG MSG(SD013)\"\n\"SELECT CMD(%BLSCLIBD) NEWAPPL(BLSG) PASSLIB\"\nAddress TSO \"FREE F(IPCSDDIR)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- syncronize the status of one of the dumps.                      -*/\n/*-------------------------------------------------------------------*/\nSyncOne:\n\nPrefix = GETDPFX(Date,Time,Seq)\nParse Value DUMPSTAT(Prefix) With Status1 .\nIf Status1 = Status Then Return\n\nStatus = Status1\nStamp = DUMPSTMP()\n\"TBMOD\" DumpTab\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- sync the status of all of the dumps in the table.               -*/\n/*-------------------------------------------------------------------*/\nSync:\nArg Scope .\n\nIf Scope = 'ALL' Then Do\n  \"TBSTATS\" DumpTab \"ROWCURR(ROWS)\"\n  If Rows > 10 Then\n    Say 'Syncing all dumps, this may take a sec'\nEnd\n\n\"TBTOP\" DumpTab\nDo Forever\n  \"TBSKIP\" DumpTab \"NUMBER(1)\"\n  If RC > 0 Then Leave\n  If Scope <> 'ALL' & Status <> 'PEND' Then Iterate\n  Call SyncOne\nEnd\n\"SETMSG MSG(SD002)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- save the table and start all over again                         -*/\n/*-------------------------------------------------------------------*/\nSave:\n\nCall TAB2LOG DumpTab TimeOpened\nParse Value LOG2TAB() With DumpTab TimeOpened .\nIf DumpTab = 4 | DumpTab = 12 Then Signal Failure\n\n\"TBVCLEAR\" DumpTab           /* hide all deleted entries */\nHold = 'D'\n\"TBSARG\" DumpTab \"NAMECOND(HOLD,NE)\"\n\"TBSORT\" DumpTab \"FIELDS(DATE,N,D,TIME,N,D,SEQ,N,D)\"\n\"SETMSG MSG(SD001)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- sort by the passed fields.                                      -*/\n/*-------------------------------------------------------------------*/\nSort:\nArg By .\n\nIf By = '' Then By = 'DATE,N,D,TIME,N,D,SEQ,N,D'\nElse By = By',C,A'\n\"CONTROL ERRORS RETURN\"\n\"TBSORT\" DumpTab \"FIELDS(\"By\")\"\nSaveRC = RC\n\"CONTROL ERRORS CANCEL\"\nIf SaveRC > 0 Then \"SETMSG MSG(SD012)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- edit or submit whatever is in the file tailoring dataset.       -*/\n/*-------------------------------------------------------------------*/\nEditSubmit:\nArg Submit .\n\n\"VGET ZTEMPN SHARED\"\nIf RC <> 0 Then Signal Failure\n\nIf Submit = 'SUBMIT' Then Do\n  Address TSO\n  \"EXECIO * DISKR\" ZTEMPN \"(FINIS\"\n  Queue ''\n  \"SUBMIT *\"\n  Address ISPEXEC\nEnd\nElse Do\n  \"LMINIT DATAID(DATAID) DDNAME(\"ZTEMPN\")\"\n  \"CONTROL DISPLAY SAVE\"\n  \"EDIT DATAID(\"DATAID\")\"\n  \"CONTROL DISPLAY RESTORE\"\n  \"LMFREE DATAID(\"DATAID\")\"\nEnd\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPLOG": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\"\\x01\\x04\\t\\x8f\\x01\\x04\\x10\\x7f\\x12\\x04\\x00R\\x004\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2004-04-07T00:00:00", "modifydate": "2004-04-16T12:04:22", "lines": 82, "newlines": 52, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Disp .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN 'NOTAB',Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- This will allocate the dump log with the disp passed. if alloc  -*/\n/*- fails, it is retried until it gains access to it.               -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\n/* get the name of the log  and make sure it is allocated */\nLog = GETDLOG()\nCall AllocLog\n\nAddress TSO\nDo Retries = 1 To 20     /* 20 retries */\n  \"ALLOC F(LOG) DA('\"Log\"')\" Disp\n  If RC = 0 Then Leave\n\n  /* if foreground prompt the user */\n  If Sysvar('SYSENV') = 'FORE' Then Do\n    Address ISPEXEC\n    \"ADDPOP\"\n    \"DISPLAY PANEL(SDWAIT)\"\n    SaveRC = RC\n    \"REMPOP\"\n    Address TSO\n    If SaveRC > 0 Then Signal Failure\n    Retries = 1       /* keep prompting until user gives up */\n  End\n  /* if background wait and try again */\n  Else Do\n    Say '>>>>>DUMPLOG: Waiting for access to' Log\n    If GETDWAIT() > 0 Then Signal Failure\n  End\nEnd\nIf Retries > 20 Then Signal Failure\nIf Retries > 1 & Sysvar('SYSENV') = 'BACK' Then\n  Say '>>>>>DUMPLOG: Gained access to log after' Retries 'retries'\n\nReturn 0\n/*-------------------------------------------------------------------*/\n/*- allocate a new log.                                             -*/\n/*-------------------------------------------------------------------*/\nAllocLog:\n\nLog = Strip(Log,\"B\",\"'\")\nSysdsn = Sysdsn(\"'\"Log\"'\")\nIf Sysdsn = \"DATASET NOT FOUND\" Then Do\n  Say '>>>>>DUMPLOG: Allocating log file' Log\n\n  \"NEWSTACK\"              /* in case there's anything queued up */\n  Queue DUMPFREC(\"YYMMDD\",\"HHMMSS\",\"Seq\",\"Job\",\"Stat\",\"H\", ,\n    \"Title\",\"Time Stamp\")\n  Queue DUMPFREC(\"------\",\"------\",\"-----\",\"--------\",\"----\",\"-\", ,\n    Copies('-',100),\"------------------\")\n\n  \"ALLOC F(DUMPLOG) DA('\"Log\"') NEW CATALOG\" ,\n    \"SPACE(10 10) TRACKS LRECL(155) RECFM(F B) DSORG(PS)\" ,\n    GETDALOC(\"TSO\")\n  \"EXECIO\" Queued() \"DISKW DUMPLOG (FINIS\"\n  \"FREE F(DUMPLOG)\"\n  \"DELSTACK\"\nEnd\nElse If Sysdsn = \"UNAVAILABLE DATASET\" Then Return\nElse If Sysdsn <> \"OK\" Then Signal Failure\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPNTFY": {"ttr": 259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00$\\x01\\x04\\x10_\\x01\\x04\\x10\\x7f\\x12\\x08\\x00(\\x00$\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-04-14T00:00:00", "modifydate": "2004-04-16T12:08:24", "lines": 40, "newlines": 36, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* a little rexx to notify users that a dump occured. you can update */\n/* this to whatever process you want, such as email or ftping a log  */\n/* or sending an snmp trap (if you have the underlying software      */\n/* properly configured).                                             */\nArg Date,Time,Job,Title\n\n/* get a list of userids to notify. if you change this program to    */\n/* an email, you can change getdntfy to return to: and cc: stuff.    */\n/* getdntfy should return appropriate routing information on the     */\n/* external data queue that this rexx will be able to interpret.     */\n/* alternatively you can do everything here and dispense with        */\n/* getdntfy. i just put it there to keep customization consistent.   */\nCall GETDNTFY\nIf Queued() <> 1 Then Do\n  /* only want one record for tso notify */\n  Say '>>>>>DUMPNTFY: Expected 1 record on data stack, got' ,\n    Queued()'. Notify failed'\n  Do Queued(); Pull; End;\n  Return\nEnd\nPull Userids\n\n/* convert the date and time to something more palatteable. this will*/\n/* fail during rollover in the year 2100. send me an inter-galactic  */\n/* teleportaion contract for $1,000,000 credits/day + expences at    */\n/* that time, and i'll fix it. it may take several weeks of work tho.*/\nDate = Left(Date('S'),2) || Date\nDate = Date('N',Date,'S')\nParse Var Time HH 3 MM 5 SS\nTime = HH':'MM':'SS\n\n/* send the users a message.                                         */\nAddress TSO\n\"SEND 'An SVC Dump was taken on\" Date Time \"for job\" Job\"'\" ,\n  \"USER(\"Userids\") LOGON\"\n\"SEND '  Title:\" Strip(Left(Title,55))\"'\" ,\n  \"USER(\"Userids\") LOGON\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPPED": {"ttr": 261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00\\x18\\x01\\x04\\t/\\x01\\x04\\x10\\x7f\\x12\\x12\\x00D\\x00$\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "2004-04-01T00:00:00", "modifydate": "2004-04-16T12:12:18", "lines": 68, "newlines": 36, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg DumpIn .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN 'NOTAB',Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- Uh-oh! a dump occured. go see whaz up.                          -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nSay '>>>>>DUMPPED: Processing' DumpIn\n\nDumpIn = Strip(DumpIn,\"B\",\"'\")\nIf DumpIn = '' Then Signal Failure\n/* do an ipcs analysis on it. */\nDumpIn = DUMPANAL(DumpIn)\nIf DumpIn = 12 Then Signal Failure\n\n/* pull the title out of the dump. */\n\"ALLOC F(DUMPIN) DA('\"DumpIn\"') SHR REUSE\"\n\"EXECIO 1 DISKR DUMPIN (FINIS\"\n\"FREE F(DUMPIN)\"\nIf Queued() <> 1 Then Signal Failure\nPull 89 Title 188\n\nParse Value GETDDATE(DumpIn) With 'D' Date ' T' Time ' S' Seq .\nPrefix = Substr(DumpIn,1,LastPos('.',DumpIn))\nPrintDsn = Prefix || 'IPRT'\n\n/* try to find the job associated with the dump. */\nJob = ''\nIf Sysvar('SYSISPF') = 'ACTIVE' Then Do\n  Address ISPEXEC\n  \"EDIT DATASET('\"PrintDsn\"') MACRO(DUMPEDJB)\"\n  \"VGET JOB SHARED\"\nEnd\nIf Job = '' Then Job = 'UNKNOWN'\n\n/* get the time stamp and format a dump log record. */\nAddress TSO\nStamp = DUMPSTMP()\nLogRec = DUMPFREC(Date,Time,Seq,Job,'DISK',' ',Title,Stamp)\nQueue LogRec\n\n/* add it to the end of the dump log. */\nIf DUMPLOG(\"MOD\") = 12 Then Signal Failure\n\"EXECIO\" Queued() \"DISKW LOG (FINIS\"\n\"FREE F(LOG)\"\n\n/* do any notifies that the dump occured. */\nCall DUMPNTFY Date,Time,Job,Title\n\nSay '>>>>>DUMPPED: Processing complete'\n\nReturn 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPPURG": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x12\\x01\\x04\\t?\\x01\\x04\\x11\\x1f\\x104\\x008\\x00,\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2004-04-20T10:34:12", "lines": 56, "newlines": 44, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg PurgeDays .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN DumpTab,Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- purge any dumps over a number of days old.                      -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nIf PurgeDays = '' | Datatype(PurgeDays) <> 'NUM' Then Signal Failure\n\n/* convert the log to a table. */\nParse Value LOG2TAB() With DumpTab TimeOpened .\nIf DumpTab = 4  Then Return 4\nIf DumpTab = 12 Then Signal Failure\n\nSay '>>>>>DUMPPURG: Purging dumps over' PurgeDays 'days old'\n\nAddress ISPEXEC\n\"TBTOP\" DumpTab\nDo Forever\n  \"TBSKIP\" DumpTab \"NUMBER(1)\"\n  If RC > 0 Then Leave\n\n  If Hold = 'H' Then Iterate\n\n  Date2 = Left(Date('S'),2) || Date    /* make four digits */\n  Days = Date('B') - Date('B',Date2,'S')\n  If Days <= PurgeDays Then Iterate\n\n  Prefix = GETDPFX(Date,Time,Seq)\n  Say '>>>>>DUMPPURG: Deleting' Prefix'.*.' Days 'days old'\n  Hold = 'D'\n  Stamp = DUMPSTMP()\n  \"TBMOD\" DumpTab\nEnd\n\nCall TAB2LOG DumpTab TimeOpened\n\nSay '>>>>>DUMPPURG: Completed purge cycle'\n\nReturn 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPSPCE": {"ttr": 263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00B\\x01\\x04\\t\\x9f\\x01\\x04\\x10\\x7f\\x12\\x16\\x00R\\x00G\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2004-04-08T00:00:00", "modifydate": "2004-04-16T12:16:42", "lines": 82, "newlines": 71, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN 'NOTAB',Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- this will return a volume with the most freespace for pooling.  -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nEnv = Sysvar('SYSENV')\nVols = GETDVOL()\nIf Words(Vols) = 1 Then Do\n  Call LogMsg 'Only one volume found in exec GETDVOL().' ,\n    'Volume pooling will not be utilized.'\n  Return Vols\nEnd\n\n/* using MXI, get the free space for each volume and save the one    */\n/* with the most free space.                                         */\nMaxVol = ''\nMaxFree = 0\nDo While Length(Vols) > 0\n  Parse Var Vols Vol Vols\n  Free = ''\n  MxiRC = MxiRexx('Vtoc.','NOTITLES','DASD' Vol 'NOT(SMS)')\n  If MxiRC = 0 Then Do\n    If Vtoc.0 = 0 Then Do\n      Call LogMsg 'Volume' Vol 'not found.'\n      Iterate\n    End\n\n    If Vtoc.0 > 15 Then Parse Var Vtoc.15 'Free Tracks' Free .\n    If Free = '' Then Do\n      Call LogMsg 'Free tracks not found on line 15 of MXI',\n        'DASD command. Update this exec to increase performance.'\n      Do iVtoc = 1 To Vtoc.0\n        Parse Var Vtoc.iVtoc 'Free Tracks' Free .\n        If Free <> '' Then Leave\n      End\n    End\n\n    If Free = '' Then Do\n      Call LogMsg 'Unable to locate \"Free Tracks\" in MXI volume report.'\n      Iterate\n    End\n    If Free > MaxFree Then Do\n      MaxFree = Free\n      MaxVol = Vol\n    End\n  End\n  Else Call LogMsg 'MxiRexx RC=' MxiRC 'for volume' Vol\nEnd\n\nIf MaxVol = '' Then Do\n  Call LogMsg 'Unable to find the largest freespace volume.' ,\n    'Defaulting to first volume in exec GETDVOL().'\n  MaxVol = Word(GETDVOL(),1)\nEnd\n\nReturn MaxVol\n/*-------------------------------------------------------------------*/\n/*- just log messages for batch processes.                          -*/\n/*-------------------------------------------------------------------*/\nLogMsg:\nArg Msg\n\nIf Env = 'FORE' Then Return\nSay '>>>>>DUMPSPCE:' Msg\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPSTAT": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x05\\x01\\x04\\t\\x7f\\x01\\x04\\x11/\\x15Q\\x00\\x0f\\x00\\x0e\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-04-06T00:00:00", "modifydate": "2004-04-21T15:51:05", "lines": 15, "newlines": 14, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this little routine returns a list of statuses for the given pfx  */\n/* so you can tell if it's on tape or disk or what. it may be on     */\n/* both disk and tape if it was recalled from archive. i don't bother*/\n/* to delete the archive during a recall.                            */\nArg Prefix .\n\nStatus = ''\nSysdsn = Sysdsn(\"'\"Prefix\".DUMP'\")\nIf Sysdsn <> 'DATASET NOT FOUND' Then Status = Status 'DISK'\nSysdsn = Sysdsn(\"'\"Prefix\".TAPE'\")\nIf Sysdsn = 'VOLUME NOT ON SYSTEM' Then Status = Status 'TAPE'\nIf Status = '' Then Status = 'DELE'\n\nReturn Strip(Status)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPSTMP": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x04\\t\\x8f\\x01\\x04\\x11O\\x16Y\\x00\\t\\x00\\x0c\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-04-07T00:00:00", "modifydate": "2004-04-23T16:59:34", "lines": 9, "newlines": 12, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this will return a time stamp to keep track of the update status  */\n/* of individual records in the table/log. it combines the days      */\n/* since jan 1, 0001 concatenated with the long time value, with all */\n/* punctuation removed.                                              */\nTime = Translate(Time('L'),,':.')\nTime = Space(Time,0)\nTime = Right(Time,12,'0')\nReturn Right(Date('B'),6,'0') || Time\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DUMPSYNC": {"ttr": 265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x008\\x01\\x04\\x10?\\x01\\x04\\x10\\x7f\\x12\"\\x00u\\x00#\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2004-04-12T00:00:00", "modifydate": "2004-04-16T12:22:38", "lines": 117, "newlines": 35, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN DumpTab,Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- This will synconize the statuses of the log, and the log with   -*/\n/*- the system catalog. prevents orphaned catalog entries.          -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nSay '>>>>>DUMPSYNC: Start of dump log syncronization'\n\nAddress ISPEXEC\n/* convert the log to an ispf table. */\nParse Value LOG2TAB() With DumpTab TimeOpened .\nIf DumpTab = 4  Then Return 4\nIf DumpTab = 12 Then Signal Failure\n\n/* sync it */\nCall SyncLog\nCall SyncCat\n\n/* convert the table back to the log */\nCall TAB2LOG DumpTab TimeOpened\n\nSay '>>>>>DUMPSYNC: Dump log syncronization complete'\n\nReturn 0\n/*-------------------------------------------------------------------*/\n/*- syncs the log status with the actual status (disk, tape etc)    -*/\n/*-------------------------------------------------------------------*/\nSyncLog:\n\n\"TBTOP\" DumpTab\nDo Forever\n  \"TBSKIP\" DumpTab \"NUMBER(1)\"\n  If RC > 0 Then Leave\n\n  Prefix = GETDPFX(Date,Time,Seq)\n  Parse Value DUMPSTAT(Prefix) With Status1 .\n  If Status1 = Status & Status1 <> 'DELE' Then Iterate\n\n  Say '>>>>>DUMPSYNC: Updating' Prefix 'to' Status1 'status'\n\n  /* setting hold to D will remove all orphaned datasets in tab2log */\n  If Status1 = 'DELE' Then Hold = 'D'\n  Status = Status1\n  Stamp = DUMPSTMP()\n  \"TBMOD\" DumpTab\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- this will sync the catalog with the log. adds orphaned entries. -*/\n/*-------------------------------------------------------------------*/\nSyncCat:\n\nQuals = GETDQUAL()\nDataset = ''\n\"LMDINIT LISTID(LISTID) LEVEL(\"GETDPFX()\")\"\nDo Forever\n  \"LMDLIST LISTID(\"LISTID\") OPTION(LIST) DATASET(DATASET)\"\n  If RC > 0 Then Leave\n  /* make sure this is one of our datasets. don't delete anything else*/\n  LastQual = Substr(Dataset,LastPos('.',Dataset)+1)\n  If WordPos(LastQual,Quals) = 0 Then Iterate\n\n  /* see if what we found in the catalog is left in the table. */\n  \"TBTOP\" DumpTab\n  \"TBVCLEAR\" DumpTab\n  Parse Value GETDDATE(Dataset) With 'D' Date ' T' Time ' S' Seq .\n  \"TBGET\" DumpTab \"NOREAD\"\n  If RC = 0 Then Iterate\n\n  Say '>>>>>DUMPSYNC: Adding cataloged dump to dump log:'\n  Say '>>>>>DUMPSYNC:' Dataset\n\n  /* if the dump is still around, get the dump title. */\n  Prefix = GETDPFX(Date,Time,Seq)\n  DumpIn = Prefix'.DUMP'\n  If Sysdsn(\"'\"DumpIn\"'\") = 'OK' Then Do\n    Address TSO\n    \"ALLOC F(DUMPIN) DA('\"DumpIn\"') SHR REUSE\"\n    \"EXECIO 1 DISKR DUMPIN (FINIS\"\n    \"FREE F(DUMPIN)\"\n    Address ISPEXEC\n    If Queued() <> 1 Then Signal Failure\n    Pull 89 Title 188\n  End\n  Else Title = 'Orphaned dump'\n\n  /* if this is in delete status, set hold to 'D' to ensure that all */\n  /* other quals are cleaned up. handles when someone deletes the    */\n  /* dump but doesn't delete the other quals. these will be deleted  */\n  /* when the table is converted back to the log in tab2log.         */\n  Parse Value DUMPSTAT(Prefix) With Status .\n  If Status = 'DELE' Then Hold = 'D'\n  Job = 'UNKNOWN'\n  Stamp = DUMPSTMP()\n  \"TBADD\" DumpTab\nEnd\n\"LMDLIST LISTID(\"LISTID\") OPTION(FREE)\"\n\"LMDFREE LISTID(\"LISTID\")\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPVECT": {"ttr": 267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00(\\x01\\x04\\t?\\x01\\x04\\x10\\x7f\\x12#\\x00%\\x00,\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2004-04-16T12:23:28", "lines": 37, "newlines": 44, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Vars .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN 'NOTAB',Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- this is used by the SYSDUMP proc to call the functions asked    -*/\n/*- for in the parms. DUMP=SYS1.DUMPxx, ARCH=x, PURGE=x, SYNC=Y.    -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\n/* this will complete the commands passed in the order they were     */\n/* specified by the user.                                            */\nDo While Length(Vars) > 0\n  Parse Value \"\" With Dump Arch Purge Sync\n  Parse Var Vars Var '=' Val ',' Vars\n  Interpret Var '= \"'Val'\"'\n  If Dump  <> '' Then If DUMPPED(Dump)   = 12 Then Signal Failure\n  If Arch  <> '' Then If DUMPARCH(Arch)  = 12 Then Signal Failure\n  If Purge <> '' Then If DUMPPURG(Purge) = 12 Then Signal Failure\n  If Sync  = 'Y' Then If DUMPSYNC()      = 12 Then Signal Failure\nEnd\n\nReturn 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETDALOC": {"ttr": 269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00V\\x01\\x04\\t/\\x01\\x04\\x10\\x7f\\x12%\\x00\\x19\\x00\\x04\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2004-04-01T00:00:00", "modifydate": "2004-04-16T12:25:56", "lines": 25, "newlines": 4, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this will return the allocation info required by any dsn's used  */\n/* the dump analysis execs. can be sms or unit/vol or whatever.     */\n/* JCL is used when constructing JCL output, TSO when using TSO     */\n/* ALLOC command, IPCS when passing parms to the BLSCDDIR routine.  */\n/* if non-sms packs are used, call DUMPSPCE to get the volume with  */\n/* the largest freespace. non-sms volumes are listed in GETDVOL.    */\nArg Type .\nIf Type = 'JCL' Then\n  Return \"UNIT=3390,VOL=SER=\"DUMPSPCE()\nElse If Type = 'TSO' Then\n  Return \"UNIT(3390) VOL(\"DUMPSPCE()\")\"\nElse If Type = 'IPCS' Then\n  Return \"VOLUME(\"DUMPSPCE()\")\"\nElse Return ''\n\nIf Type = 'JCL' Then\n  Return \"STORCLAS=SCTECH,MGMTCLAS=MCPROD\"\nElse If Type = 'TSO' | Type = 'IPCS' Then\n  Return \"STORCLAS(SCTECH) MGMTCLAS(MCPROD)\"\nElse Return ''\n\n/* if you are using sms acs routines for all the dump working */\n/* datasets, then null is valid.                              */\nReturn ''\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETDDATE": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x003\\x01\\x04\\t\\x1f\\x01\\x04\\x11/\\x15C\\x00\\x12\\x00\\x1e\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2004-03-31T00:00:00", "modifydate": "2004-04-21T15:43:33", "lines": 18, "newlines": 30, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Dsn .\n/* set these to the qual numbers that contain the date and the time */\n/* within the dump dataset name. in the form of:                    */\n/* SYS1.sys.Dyymmdd.Thhmmss.Sxxxxx.DUMP                             */\n/* if the name changes, you should update this exec. this exec and  */\n/* GETDPFX() must be kept in sync.                                  */\nDateWord = 3\nTimeWord = 4\nSeqWord  = 5\n\nWordDsn = Dsn\nWordDsn = Translate(WordDsn,' ','.')\nDate = Word(WordDsn,DateWord)\nTime = Word(WordDsn,TimeWord)\nSeq  = Word(WordDsn,SeqWord)\n\nReturn Date Time Seq\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDEXCL": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\t\\x01\\x04\\t\\x7f\\x01\\x04\\x12O\\x12V\\x00\\n\\x00\\x04\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2004-04-06T00:00:00", "modifydate": "2004-05-03T12:56:09", "lines": 10, "newlines": 4, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this will return the low level quals of datasets that will be     */\n/* excluded from being archived to tape. leaving the IPRT dataset    */\n/* will allow you to continue to select the ipcs analysis output     */\n/* while other stuff has been sent to tape. the TRS dataset is the   */\n/* tersed dump and is excluded presumably because you will be        */\n/* transmitting it somewhere. there's no harm done archiving these   */\n/* either. it's totally up to you.                                   */\n/* may 3rd added 'notes' to exclude notes log datasets.              */\nReturn 'IPRT TRS TAPE NOTES'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDLOG": {"ttr": 271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00#\\x01\\x04\\t/\\x01\\x04\\x10\\x7f\\x126\\x00\\x04\\x00\\x01\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-04-01T00:00:00", "modifydate": "2004-04-16T12:36:23", "lines": 4, "newlines": 1, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this will return the name of the dump log dsn. can be pretty much */\n/* whatever name you want. recommend the same hlq as in GETDPFX.     */\nReturn \"SYS1.\"Mvsvar(\"SYSNAME\")\".DUMPS.LOG\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETDNTFY": {"ttr": 19, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x18\\x01\\x04\\x10_\\x01\\x04\\x10_\\x13W\\x00\\x04\\x00\\x03\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-04-14T00:00:00", "modifydate": "2004-04-14T13:57:18", "lines": 4, "newlines": 3, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* return a string of userids to be notified when a dump occurs.     */\nQueue 'MA133 MA005 MA904 MX082 MX105 MAH507'\nReturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDOPER": {"ttr": 273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00A\\x01\\x04\\t\\x9f\\x01\\x04\\x10\\x7f\\x127\\x00\\x0e\\x00\\n\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2004-04-08T00:00:00", "modifydate": "2004-04-16T12:37:41", "lines": 14, "newlines": 10, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this will return how to issue console commands (currenly only to  */\n/* get the results of the display dump command if you are using      */\n/* sys1.dumpxx datasets; if you are using dynamic dumps then this    */\n/* won't be used). return CONSOLE if the SYSDUMP stc is authorized to*/\n/* issue the tso/e console command, or return OPSMVS if it is        */\n/* authorized to use the CA-OPS/MVS OPSCMD command. if niether is    */\n/* authorized, it won't be able to get the dump date/time to place   */\n/* on the copied dump dataset name, and will default to current. no  */\n/* big deal, just that the date/time on the dataset name will not be */\n/* in sync with the date/time within the dump.                       */\nReturn 'OPSMVS'\nReturn 'CONSOLE'\nReturn 'NONE'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDPFX": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x07\\x01\\x04\\t\\x7f\\x01\\x04\\x11/\\x15C\\x00\\x17\\x00 \\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2004-04-06T00:00:00", "modifydate": "2004-04-21T15:43:07", "lines": 23, "newlines": 32, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* use this to set the prefix of your dump datasets based on the date*/\n/* time and sequence number. the prefix must not be any longer than  */\n/* 37 to make room for the DDIR.D and DDIR.I ipcs work datasets. this*/\n/* exec and GETDDATE() must be kept in sync.                         */\nArg Date, Time, Seq\n\nSysname = Mvsvar('SYSNAME')\n\n/* if i've passed nothing return a mask that corresponds to the dump */\n/* prefix below. this and the one below must be kept in sync.        */\nIf Length(Date||Time||Seq) = 0 Then\n  Return 'SYS1.'Sysname'.D%%%%%%.T%%%%%%.S%%%%%'\n\nIf Length(Date) = 6 Then Date = 'D'Date\nIf Length(Time) = 6 Then Time = 'T'Time\nIf Length(Seq)  < 6 Then Seq  = 'S'Right(Seq,5,'0')\n\n/* make sure we passed in the right stuff.                           */\nIf Length(Date) <> 7 & Length(Time) <> 7 & Length(Seq) <> 6 Then\n  Return ''\n\nReturn 'SYS1.'Sysname'.'Date'.'Time'.'Seq\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDQUAL": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00S\\x01\\x04\\t?\\x01\\x04\\x12O\\x12U\\x00\\x0b\\x00\\x01\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2004-05-03T12:55:53", "lines": 11, "newlines": 1, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this will return the low level quals of all possible files having */\n/* to do with the dumps.                                             */\n/*   DUMP = the actual svc dump                                      */\n/*   DDIR = the ipcs vsam work dataset created by the SYSDUMP proc   */\n/*   IPRT = the ipcs print analysis report                           */\n/*   ITOC = the ipcs table of contents for the above report          */\n/*   TAPE = the archived tape dataset                                */\n/*   TRS  = the tersed dump                                          */\n/*   NOTES= a dataset of notes on the dump, created by user          */\nReturn 'DUMP DDIR IPRT ITOC TAPE TRS NOTES'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDVOL": {"ttr": 275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x002\\x01\\x04\\t/\\x01\\x04\\x10\\x7f\\x12@\\x00\\x0c\\x00\\x05\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2004-04-01T00:00:00", "modifydate": "2004-04-16T12:40:32", "lines": 12, "newlines": 5, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this will return a series of volumes to be used by various dump  */\n/* execs. these must be non-sms volumes. if all the datasets used   */\n/* by these routines are managed by sms, then this won't be called. */\n/* see GETDPFX for the dataset name prefix that can be used in sms  */\n/* acs routines. exec DUMPSPCE will check these volumes and use the */\n/* one that has the greatest freespace. in order to use this        */\n/* feature, you must have MXI installed from www.cbttape.org. if you*/\n/* don't want to use MXI, and don't want to use SMS, then return    */\n/* just one volume from here, and make sure there is enough free    */\n/* space on it by archiving dumps off it aggresively.               */\nReturn 'SADUMP'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDWAIT": {"ttr": 277, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x007\\x01\\x04\\t\\x9f\\x01\\x04\\x10\\x7f\\x12A\\x00\\x13\\x00\\x0f\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-04-08T00:00:00", "modifydate": "2004-04-16T12:41:37", "lines": 19, "newlines": 15, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* when there is contention for the dump log dataset, the SYSDUMP    */\n/* stc will issue a wait and retry a number of times b4 giving up.   */\n/* since there is no standard rexx wait command, we have to resort   */\n/* to other ways of doing it. we have three choices that i know of:  */\n/* the CA-OPS/MVS OPSWAIT command, the unix system services (uss)    */\n/* sleep command, or an assembler program you can download off the   */\n/* cbttape (www.cbttape.org), file #322.                             */\n/* the ops version obviously requires ops/mvs be installed.          */\n/* the uss command requires access to the omvs security segment      */\n/*   for the SYSDUMP proc (which may not always be allowed).         */\n/* the sleep command requires you to download, assemble and install. */\n\"OPSWAIT 5\"             /* opsmvs ver */\nReturn RC\n\n\"BPXBATCH SH sleep 5\"   /* uss ver */\nReturn RC\n\nReturn Sleep(5)         /* cbttape ver */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOG2TAB": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00\\x08\\x01\\x04\\t?\\x01\\x04\\x11/\\x15F\\x00:\\x00#\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2004-04-21T15:46:08", "lines": 58, "newlines": 35, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN DumpTab,Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- this will convert the dump log to an ispf table for manipulation-*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\n/* create a unique table name based on the session number to allow   */\n/* table viewing in multiple split screens.                          */\nAddress ISPEXEC\n\"VGET ZSCREEN SHARED\"          /* this will allow split screen */\nDumpTab = 'SVCDUMP'ZSCREEN\n\n/* if you have nested calls to the ispf interface, tell the user     */\n/* all about it and get out. i guess i could allow the table to      */\n/* display, but i'd have to access the original timeopened and make  */\n/* sure i don't end the table on return etc. too much work.          */\n\"LIBDEF ISPTLIB LIBRARY ID(ISPPROF) STACK\"\n\"TBSTATS\" DumpTab \"STATUS3(STATUS3)\"\nIf Status3 = 2 Then Do                /* can't access table      */\n  Say 'The SVC dump table is currently unavailable.'\n  Say 'You may have already opened it in this ISPF split screen.'\n  Return 4\nEnd\n\nTimeOpened = DUMPSTMP()\n\"TBCREATE\" DumpTab \"KEYS(DATE TIME SEQ)\" ,\n  \"NAMES(JOB STATUS HOLD TITLE STAMP) NOWRITE\"\n\n/* read in the dump log so we can convert. */\nAddress TSO\nIf DUMPLOG(\"SHR\") = 12 Then Signal Failure\n\"EXECIO * DISKR LOG (STEM Log. FINIS\"\n\"FREE F(LOG)\"\n\n/* do the conversion. */\nAddress ISPEXEC\nDo iLog = 3 To Log.0   /* skip headings */\n  Parse Var Log.iLog Date Time Seq Job 29 30 Status 34 ,\n    35 Hold 36 37 Title 137 Stamp .\n  \"TBADD\" DumpTab\nEnd\n\nReturn DumpTab TimeOpened\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPSMSG1": {"ttr": 279, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00$\\x01\\x04\\x10o\\x01\\x04\\x10\\x7f\\x12V\\x00\\x16\\x00\\x0f\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-04-15T00:00:00", "modifydate": "2004-04-16T12:56:24", "lines": 22, "newlines": 15, "modlines": 0, "user": "MA133"}, "text": ")msg IEA911E\n/**********************************************************************/\n/*  Rule Function: To start the SYSDUMP proc when an SVC dump is      */\n/*                 captured.                                          */\n/*  Author:        Robin Murray                                       */\n/*  Installed:     April 2004                                         */\n/**********************************************************************/\n)proc\n/* IEA911E COMPLETE/PARTIAL DUMP ON SYS1.DUMP00                       */\n/* prevent a dump loop by bypassing if SYSDUMP itself abends.         */\nIf msg.jobname = 'SYSDUMP' then return 'NORMAL'\n\n/* only process the major wto.                                        */\nIf msg.mlwtomin = 1 then return 'NORMAL'\n\n/* start the dump processor with S SYSDUMP,PRM='DUMP=SYS1.DUMPxx'.    */\nParse var msg.text 'DUMP ON ' dump .\ndump = strip(dump)\nAddress OPER\n\"S SYSDUMP,PRM='DUMP=\"dump\"'\"\n\nReturn 'NORMAL'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPSMSG2": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x04\\x11\\x1f\\x01\\x04\\x11\\x1f\\x11R\\x00\\x16\\x00\\x16\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-04-20T00:00:00", "modifydate": "2004-04-20T11:52:37", "lines": 22, "newlines": 22, "modlines": 0, "user": "MA133"}, "text": ")msg IEA611I\n/**********************************************************************/\n/*  Rule Function: To start the SYSDUMP proc when an SVC dump is      */\n/*                 captured.                                          */\n/*  Author:        Robin Murray                                       */\n/*  Installed:     April 2004                                         */\n/**********************************************************************/\n)proc\n/* IEA611I COMPLETE DUMP ON SYS1.sys.DYYMMDD.THHMMSS.Sxxxxx.DUMP      */\n/* prevent a dump loop by bypassing if SYSDUMP itself abends.         */\nIf msg.jobname = 'SYSDUMP' then return 'NORMAL'\n\n/* only process the major wto.                                        */\nIf msg.mlwtomin = 1 then return 'NORMAL'\n\n/* start the dump processor with S SYSDUMP,PRM='DUMP=SYS1.DUMPxx'.    */\nParse var msg.text 'DUMP ON ' dump .\ndump = strip(dump)\nAddress OPER\n\"S SYSDUMP,PRM='DUMP=\"dump\"'\"\n\nReturn 'NORMAL'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPSTOD1": {"ttr": 23, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x04\\x10o\\x01\\x04\\x10\\x7f\\x11&\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-04-15T00:00:00", "modifydate": "2004-04-16T11:26:32", "lines": 12, "newlines": 12, "modlines": 0, "user": "MA133"}, "text": ")TOD 05:00:00\n)INIT\n/**********************************************************************/\n/*  Rule Function: To do a cleanup of the svc dumps. see the sysdump  */\n/*                 proc to see how it works.                          */\n/*  Author:        Robin Murray                                       */\n/*  Installed:     April 2004                                         */\n/**********************************************************************/\n)PROC\nAddress OPER\n\"S SYSDUMP,PRM='PURGE=60,ARCH=3'\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPSTOD2": {"ttr": 21, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00&\\x01\\x04\\x10o\\x01\\x04\\x10\\x7f\\x11&\\x00\\x0c\\x00\\x0b\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-04-15T00:00:00", "modifydate": "2004-04-16T11:26:26", "lines": 12, "newlines": 11, "modlines": 0, "user": "MA133"}, "text": ")TOD 07:00:00\n)INIT\n/**********************************************************************/\n/*  Rule Function: To do a sync of the svc dump log. see the sysdump  */\n/*                 proc to see how it works.                          */\n/*  Author:        Robin Murray                                       */\n/*  Installed:     April 2004                                         */\n/**********************************************************************/\n)PROC\nAddress OPER\n\"S SYSDUMP,PRM='SYNC=Y'\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SVCDUMPS": {"ttr": 514, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00H\\x01\\x04\\x10\\x7f\\x01\\x04\\x10\\x7f\\x12X\\x00\\x1a\\x00\\x18\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-04-16T00:00:00", "modifydate": "2004-04-16T12:58:48", "lines": 26, "newlines": 24, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* used to start the ispf interface to the svc dumps routines. copy */\n/* this to a common SYSEXEC lib so that sysprogs can access it.     */\nHlq = \"MA133.TSO.SVCDUMPS\"\n\nAddress TSO\n\"ALTLIB ACTIVATE APPLICATION(EXEC)\" ,\n  \"DSNAME('\"Hlq\".SYSEXEC')\"\n\nAddress ISPEXEC\n\"LIBDEF ISPMLIB DATASET ID('\"Hlq\".ISPMLIB') STACK\"\n\"LIBDEF ISPPLIB DATASET ID('\"Hlq\".ISPPLIB') STACK\"\n\"LIBDEF ISPSLIB DATASET ID('\"Hlq\".ISPSLIB') STACK\"\n\n\"CONTROL ERRORS RETURN\"\n\"SELECT CMD(%DUMPISPF) NEWAPPL(SD) PASSLIB\"\n\"CONTROL ERRORS CANCEL\"\n\n\"LIBDEF ISPSLIB\"\n\"LIBDEF ISPPLIB\"\n\"LIBDEF ISPMLIB\"\n\nAddress TSO\n\"ALTLIB DEACTIVATE APPLICATION(EXEC)\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSDUMP": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00\\x01\\x01\\x04\\t/\\x01\\x04\\x12\\x9f\\x12\\x16\\x00L\\x00+\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2004-04-01T00:00:00", "modifydate": "2004-05-08T12:16:01", "lines": 76, "newlines": 43, "modlines": 0, "user": "MA133"}, "text": "//SYSDUMP  PROC PRM=\n//*********************************************************************\n//* THIS IS THE SVC DUMP PROCESSOR AND MANAGER TASK. IT WILL BE STARTED\n//* WHEN OPS RULE IEA911E/IEA611I IS TRIGGERED WHEN AN SVC DUMP IS\n//* CAPTURED. ALSO TOD RULES SYSDUMP1 AND SYSDUMP2 WILL START THIS TASK\n//* TO PERFORM DUMP ARCHIVING, PURGING, AND SYNCRONIZATION.\n//*\n//* CAN BE STARTED WITH THE FOLLOWING PRM VALUES:\n//*   DUMP=SYS1.DUMPXX TO PROCESS AN SVC DUMP\n//*   PURGE=XX TO PURGE DUMPS THAT ARE OVER XX DAYS OLD\n//*   ARCH=XX TO SEND TO TAPE DUMPS THAT ARE OVER XX DAYS OLD\n//*   SYNC=Y TO SYNCRONIZE THE DUMP LOG WITH THE SYSTEM CATALOG\n//*\n//* EXAMPLES:\n//*   S SYSDUMP,PRM='DUMP=SYS1.DUMP02'\n//*   S SYSDUMP,PRM='PURGE=60,ARCH=3'\n//*   S SYSDUMP,PRM='SYNC=Y'\n//*\n//* SEE THE SYSEXEC DATASET FOR THE REXX EXECS THAT ARE USED.\n//*********************************************************************\n//SYSDUMP  EXEC PGM=IKJEFT1A,DYNAMNBR=256,REGION=8M,\n//         PARM='ISPSTART CMD(%DUMPVECT &PRM) BDISPMAX(1000)'\n//*********************************************************************\n//* ALLOCATE THE ISPF LIBRARIES FOR RUNNING IN BACKGROUND\n//*********************************************************************\n//ISPLLIB   DD  DSN=ISP.SISPLOAD,DISP=SHR\n//ISPMLIB   DD  DSN=ISP.SISPMENU,DISP=SHR\n//ISPPLIB   DD  DSN=ISP.SISPPENU,DISP=SHR\n//ISPSLIB   DD  DSN=MA133.TSO.SVCDUMPS.ISPSLIB,DISP=SHR\n//          DD  DSN=ISP.SISPSENU,DISP=SHR\n//ISPTLIB   DD  DISP=(,DELETE),\n//          UNIT=3390,SPACE=(TRK,(5,2,10),RLSE),\n//          LRECL=80,RECFM=FB,BLKSIZE=0\n//          DD  DSN=ISP.SISPTENU,DISP=SHR\n//ISPPROF   DD  DISP=(,DELETE),\n//          UNIT=3390,SPACE=(TRK,(5,2,10),RLSE),\n//          LRECL=80,RECFM=FB,BLKSIZE=0\n//*********************************************************************\n//* ALLOCATE THE IPCS CLIST LIB FOR PROCESSING THE DUMP\n//*********************************************************************\n//SYSPROC   DD  DSN=SYS1.SBLSCLI0,DISP=SHR\n//*********************************************************************\n//* ALLOCATE THE REXX LIB FOR MANAGING THE DUMPS\n//*********************************************************************\n//SYSEXEC   DD  DSN=MA133.TSO.SVCDUMPS.SYSEXEC,DISP=SHR\n//*********************************************************************\n//* YOU CAN SEE THE LOG OF THE LAST FEW RUNS OF SYSDUMP\n//*********************************************************************\n//SYSTSPRT  DD  DSN=SYS1.&SYSNAME..DUMPS.SYSTSPRT(+1),DISP=(,CATLG),\n//          UNIT=3390,VOL=SER=SADUMP,SPACE=(TRK,(5,5),RLSE),\n//          LRECL=133,RECFM=FB,DSORG=PS,DCB=SYS9.MODELDCB\n//*********************************************************************\n//* MAKE SURE ISPF WORK FILES ARE AVAILABLE IF EVER NEEDED\n//*********************************************************************\n//ISPCTL0   DD  DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//          DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)\n//ISPCTL1   DD  DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//          DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)\n//ISPCTL2   DD  DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//          DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)\n//ISPCTL3   DD  DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//          DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)\n//ISPCTL4   DD  DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//          DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)\n//ISPWRK1   DD  DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//          DCB=(LRECL=256,BLKSIZE=2560,RECFM=FB)\n//ISPWRK2   DD  DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//          DCB=(LRECL=256,BLKSIZE=2560,RECFM=FB)\n//ISPWRK3   DD  DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//          DCB=(LRECL=256,BLKSIZE=2560,RECFM=FB)\n//ISPWRK4   DD  DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//          DCB=(LRECL=256,BLKSIZE=2560,RECFM=FB)\n//ISPLOG    DD  SYSOUT=*,DCB=(LRECL=125,BLKSIZE=129,RECFM=VA)\n//SYSPRINT  DD  SYSOUT=*\n//SYSTERM   DD  SYSOUT=*\n//SYSTSIN   DD  DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TAB2LOG": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01,\\x007\\x01\\x04\\t?\\x01\\x04\\x11\\x1f\\x10X\\x00\\x96\\x002\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.44", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2004-04-20T10:58:37", "lines": 150, "newlines": 50, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg DumpTab TimeOpened .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Main_Routine()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source Source\nCall DUMPCLN DumpTab,Source\nReturn\n/*-------------------------------------------------------------------*/\n/*- this will convert the ispf table back to the dump log.          -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\n/* only process those entries that have been changed since opening.  */\nDigits = Digits()\nNumeric Digits Length(DUMPSTMP())\nAddress ISPEXEC\n\"TBTOP\" DumpTab\nDo Forever\n  \"TBSKIP\" DumpTab \"NUMBER(1)\"\n  If RC > 0 Then Leave\n  If Stamp < TimeOpened Then \"TBDELETE\" DumpTab\nEnd\nNumeric Digits Digits\n\n/* if there's nothing left to process, don't bother updating the log*/\n\"TBSTATS\" DumpTab \"ROWCURR(ROWS)\"\nIf Rows > 0 Then Do\n  If DUMPLOG(\"OLD\") = 12 Then Signal Failure\n  Call UpdateLog\n  Address TSO\n  \"EXECIO * DISKW LOG (STEM Out. FINIS\"\n  \"FREE F(LOG)\"\nEnd\nAddress ISPEXEC\n\"TBEND\" DumpTab\n\"LIBDEF ISPTLIB\"\n\nReturn 0\n/*-------------------------------------------------------------------*/\n/*- The main exec routine.                                          -*/\n/*-------------------------------------------------------------------*/\nUpdateLog:\n\n/* copy the heading lines to the output stems */\nAddress TSO\n\"EXECIO 2 DISKR LOG\"\niOut = 0\nDo Queued()\n  iOut = iOut + 1\n  Pull Out.iOut\nEnd\nOut.0 = iOut\n\n/* copy any updated log entries to the new log */\nAddress ISPEXEC\nDo Forever\n  Address TSO \"EXECIO 1 DISKR LOG\"\n  If RC > 0 Then Leave\n  Pull In\n  Parse Var In Date Time Seq LJob 29 30 LStatus 34 ,\n    35 LHold 36 37 LTitle 137 138 LStamp .\n\n  \"TBTOP\" DumpTab\n  \"TBGET\" DumpTab\n  /* if not found, or if found but log time is greater (which can   */\n  /* happen if someone else was processing the dump log while you   */\n  /* were messing with it), simply copy the log record back to the  */\n  /* log. only the record with the highest timestamp will be used.  */\n  If RC > 0 | (RC = 0 & Stamp < LStamp) Then Do\n    If RC = 0 Then \"TBDELETE\" DumpTab\n    iOut = iOut + 1\n    Out.iOut = In\n    Iterate\n  End\n\n  /* if this entry was deleted, don't bother to copy it. make sure  */\n  /* all the possible quals are deleted to keep in sync with catalog*/\n  If HOLD = 'D' Then Do\n    Call DeleteDump\n    \"TBDELETE\" DumpTab\n    Iterate\n  End\n\n  /* take the table entry values and override the log entry.        */\n  iOut = iOut + 1\n  Out.iOut = DUMPFREC(Date,Time,Seq,Job,Status,Hold,Title,Stamp)\n  \"TBDELETE\" DumpTab\nEnd\nOut.0 = iOut\nAddress TSO \"EXECIO 0 DISKR LOG (FINIS\"\n\n/* add in any table entries that have not been handled above. this  */\n/* can happen during a sync when catalog entries are found for which*/\n/* there are no log entries.                                        */\n\"TBTOP\" DumpTab\niOut = Out.0\nDo Forever\n  \"TBSKIP\" DumpTab \"NUMBER(1)\"\n  If RC > 0 Then Leave\n  If HOLD = 'D' Then Do\n    Call DeleteDump\n    Iterate\n  End\n  iOut = iOut + 1\n  Out.iOut = DUMPFREC(Date,Time,Seq,Job,Status,Hold,Title,Stamp)\nEnd\nOut.0 = iOut\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- delete all the bits that have to do with the dump.              -*/\n/*-------------------------------------------------------------------*/\nDeleteDump:\n\nQuals = GETDQUAL()\nPrefix = GETDPFX(Date,Time,Seq)\nx = Msg('OFF')\nDo While Words(Quals) > 0\n  Parse Var Quals Qual Quals\n  Address TSO \"DELETE '\"Prefix'.'Qual\"' PURGE\"\nEnd\nx = Msg(x)\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Only for debugging purposes.                                    -*/\n/*-------------------------------------------------------------------*/\nSayTab:\n\nSay 'Saying table...'\n\"TBTOP\" DumpTab\nDo Forever\n  \"TBSKIP\" DumpTab \"NUMBER(1)\"\n  If RC > 0 Then Leave\n  Say Date Time Seq Job Title Stamp\nEnd\nSay 'Say table complete'\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZPDSLIST": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\t\\x01\\x04\\x12\\x9f\\x01\\x04\\x12\\x9f\\x12\\x19\\x00'\\x00\\x12\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2004-05-08T00:00:00", "modifydate": "2004-05-08T12:19:09", "lines": 39, "newlines": 18, "modlines": 0, "user": "MA133"}, "text": "$DOC                     38  2004/05/08  2004/05/08 11:58:48  MA133\n$INSTALL                 85  2004/04/08  2004/05/08 12:04:03  MA133\n$IVP                     36  2004/04/15  2004/05/08 12:04:51  MA133\nDUMPANAL                 61  2004/04/01  2004/04/16 11:44:20  MA133\nDUMPARCH                103  2004/04/06  2004/04/23 11:37:18  MA133\nDUMPARCJ                 57  2004/04/06  2004/04/23 11:41:31  MA133\nDUMPCLN                  23  2004/04/07  2004/04/16 11:52:34  MA133\nDUMPCOPY                 80  2004/03/31  2004/04/20 11:33:21  MA133\nDUMPDATE                118  2004/04/06  2004/04/16 11:56:32  MA133\nDUMPEDJB                 40  2004/04/01  2004/04/16 12:01:08  MA133\nDUMPFREC                  8  2004/04/07  2004/04/08 10:57:35  MA133\nDUMPISPF                460  2004/04/02  2004/05/03 13:01:48  MA133\nDUMPLOG                  82  2004/04/07  2004/04/16 12:04:22  MA133\nDUMPNTFY                 40  2004/04/14  2004/04/16 12:08:24  MA133\nDUMPPED                  68  2004/04/01  2004/04/16 12:12:18  MA133\nDUMPPURG                 56  2004/04/02  2004/04/20 10:34:12  MA133\nDUMPSPCE                 82  2004/04/08  2004/04/16 12:16:42  MA133\nDUMPSTAT                 15  2004/04/06  2004/04/21 15:51:05  MA133\nDUMPSTMP                  9  2004/04/07  2004/04/23 16:59:34  MA133\nDUMPSYNC                117  2004/04/12  2004/04/16 12:22:38  MA133\nDUMPVECT                 37  2004/04/02  2004/04/16 12:23:28  MA133\nGETDALOC                 25  2004/04/01  2004/04/16 12:25:56  MA133\nGETDDATE                 18  2004/03/31  2004/04/21 15:43:33  MA133\nGETDEXCL                 10  2004/04/06  2004/05/03 12:56:09  MA133\nGETDLOG                   4  2004/04/01  2004/04/16 12:36:23  MA133\nGETDNTFY                  4  2004/04/14  2004/04/14 13:57:18  MA133\nGETDOPER                 14  2004/04/08  2004/04/16 12:37:41  MA133\nGETDPFX                  23  2004/04/06  2004/04/21 15:43:07  MA133\nGETDQUAL                 11  2004/04/02  2004/05/03 12:55:53  MA133\nGETDVOL                  12  2004/04/01  2004/04/16 12:40:32  MA133\nGETDWAIT                 19  2004/04/08  2004/04/16 12:41:37  MA133\nLOG2TAB                  58  2004/04/02  2004/04/21 15:46:08  MA133\nOPSMSG1                  22  2004/04/15  2004/04/16 12:56:24  MA133\nOPSMSG2                  22  2004/04/20  2004/04/20 11:52:37  MA133\nOPSTOD1                  12  2004/04/15  2004/04/16 11:26:32  MA133\nOPSTOD2                  12  2004/04/15  2004/04/16 11:26:26  MA133\nSVCDUMPS                 26  2004/04/16  2004/04/16 12:58:48  MA133\nSYSDUMP                  76  2004/04/01  2004/05/08 12:16:01  MA133\nTAB2LOG                 150  2004/04/02  2004/04/20 10:58:37  MA133\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT674/CBT.V500.FILE674.PDS/DUMPEXEC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT674/CBT.V500.FILE674.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}