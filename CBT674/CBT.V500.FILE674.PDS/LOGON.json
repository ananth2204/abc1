{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "MA133", "INMTNODE": "MA133", "INMTUID": "N1", "INMFTIME": "20040510134318000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 6400, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "MA133.TSO.LOGON", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"MA133.TSO.LOGON": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6400, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "040129", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x04'", "DS1LSTAR": "b'\\x00\\x02\\x04'", "DS1TRBAL": "b'\\xc7\\xe2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x9b\\x80\\xb8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x9b\\x80\\xb8'", "b'X\\xf3\\x10\\xe0\\x00\\x00\\x00D\\x00\\x07\\x00D\\x00\\x0e\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$BENEFIT": {"ttr": 24, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00R\\x01\\x04\\x07\\x0f\\x01\\x04\\x07O\\x178\\x00-\\x00?\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2004-03-10T00:00:00", "modifydate": "2004-03-14T17:38:52", "lines": 45, "newlines": 63, "modlines": 0, "user": "MA133"}, "text": "/*********************************************************************/\n/* Benefits of CatLibs                                               */\n/*********************************************************************/\nHere are some underlying benefits of using these parmlibs:\n\n* This method is quite efficient for allocating custom libraries. Some\n  methods require that all libs be allocated first, after which they are\n  examined, freed, then reallocated with custom libs ahead of the\n  original.  In many cases (depending on how you are reallocating) this\n  can only be done one library at a time, so if you have several libs to\n  be allocated for the same DD, the same free-and-reallocate process\n  must be performed multiple times.\n\n* CATLIBS is much more customizable for each user than many other\n  methods.  The number and variety of logon procs can be reduced since\n  we can customize a special environment for each user if necessary.\n\n* If a DSN in an include member is misspelled, accidentally deleted,\n  exclusively enqueued, or otherwise unavailable, this procedure will\n  recover from the condition and reallocate the DD, removing the\n  offending datasets from the concatenation. This will allow you to\n  logon despite problems with individual datasets. Provided the basic\n  datasets are available, you'll still be able to get to the system,\n  which means more availability, and gives you peace of mind in a\n  disaster recovery scenerio.\n\n* Product libraries are grouped into nice packages in separate members\n  of this parmlib. Removing a product from a logon proc is as simple as\n  commenting the include statement in the driver member. Other methods\n  require you to make updates in various areas, and the risk is high\n  that you'll make a mistake causing a JCL error at logon, or leave in a\n  library somewhere that should have been removed.\n\n* It helps to document what libraries correspond to what product. I\n  discovered, for instance, that we had LANRES datasets allocated to our\n  logon procs simply because that's what came with the system and it was\n  difficult to track down what the datasets were for. We don't use\n  LANRES and therefore don't need them allocated. Having product\n  parmlibs helps to self-document all datasets that are in use.\n\n* Only those products you actually use will be allocated to your logon\n  proc. It's senseless for Joe-user to have system programmer libraries\n  allocated!  This allows you to assign libraries more easily based on\n  their use.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$README": {"ttr": 265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00W\\x01\\x04\\x07O\\x01\\x04\\t\\x0f\\x12W\\x00\\x87\\x00\\x8d\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-03-14T00:00:00", "modifydate": "2004-03-30T12:57:57", "lines": 135, "newlines": 141, "modlines": 0, "user": "MA133"}, "text": "/*********************************************************************/\n/* Welcome to CatLibs                                                */\n/*********************************************************************/\nThe CATLIBS exec and the corresponding logon parmlibs will allocate the\nnecessary product libraries to your TSO session at logon time. The\nparmlib members contain lists of DDNames and corresponding DSNs that are\nrequired, one member for each product to be allocated.\n\nIt is set up to be very flexible and customizable by each individual\nuser. It does not require the user know anything about TSO or ISPF.\nMaintenance of logon procs is greatly simplified and self documenting.\nOnce you gain an understanding of this allocation procedure, see the\n$BENEFIT member for more information on why you might decide to use it.\n\nLet's walk thru what CATLIBS does. This is going to sound WAY more\ncomplicated than it is. Once you catch on, you will find it easy.\nHere's a blow by blow account of the steps it goes through:\n\n* Calls clist ISPFPROF, which must reside in the same library in which\n  CATLIBS resides. It's function is to allocate an ISPF profile library.\n  This is a required library and is equivalent to a cookie file in the\n  web world, where it stores settings and variables across logons.\n\n* Allocates a system logon parmlib and, if found, a user logon parmlib.\n  If the user parmlib is found, it will override the members in the\n  system parmlib. The various members in this parmlib will control what\n  libraries are allocated to your logon.\n\n* Reads in member $PRC2DRV (stands for 'Proc to Driver'). This member\n  contains a list of logon proc names (as defined by your shop) and a\n  corresponding 'driver' member, by convention starting with '@', such\n  as @BASIC. This driver member will be used to pick which products to\n  allocate to your logon. If your logon proc is not found in $PRC2DRV,\n  the driver name defaults to @BASIC.\n\n* Processes the driver member, which will have one of three\n  possible commands on each line:\n  > INCLUDE to include in a product parmlib member. This member will\n    list the DDs and DSNs required for a specific product (see below).\n  > MERGE to read in another driver member and merge it's contents\n    with the current one. This allows you to 'nest' driver members\n    so you can share their allocations and make maintenance easier.\n  > STARTCMD to refer to a parmlib member that holds the ISPF startup\n    command for your TSO session.\n  Examples:\n  > MERGE @BASIC to merge the current member with the @BASIC member.\n  > INCLUDE PRODUCT1 to include a product parmlib member.\n  > STARTCMD #BASIC to specify the ISPF start command member.\n  Take a look at a couple of these members now to see what I mean.\n  So the driver member @SPECIAL may look like this:\n    | INCLUDE FILEAID        * include the fileaid product\n    | MERGE @BASIC           * merge this driver with @BASIC\n    | STARTCMD #SPECIAL      * the ISPF startup member\n\n* Once all the driver members are processed, we will have a list of all\n  include members merged in from all driver members. Each include\n  statement refers to another member in the logon parmlib.\n  Example merged listing:\n    | INCLUDE PANVALET\n    | INCLUDE CYFUSION\n    | INCLUDE FILEAID\n  etc.\n\n* Reads in all the members to which the include commands refer.\n  These members contain the DDNAME and DSN that the particular\n  product requires.\n  Example merged include member contents from above:\n    | ISPLLIB 'SYSX.CAI.PAN.CAIISPL'     * from PANVALET\n    | ISPMLIB 'SYSX.CAI.PAN.CAIISPM'     * from PANVALET\n    | ISPPLIB 'SYSX.CAI.PAN.CAIISPP'     * from PANVALET\n    | ISPMLIB 'SYSX.CYFUSION.MSGS'       * from CYFUSION\n    | ISPPLIB 'SYSX.CYFUSION.PANELS'     * from CYFUSION\n    | ISPTLIB 'SYSX.CYFUSION.TABLES'     * from CYFUSION\n    | SYSEXEC 'SYSX.CYFUSION.EXECS'      * from CYFUSION\n    | SYSEXEC 'SYSX.FILEAID.SYSEXEC'     * from FILEAID\n  etc.\n  Once each include member has been read in, we will have one large list\n  of DDNAMEs and DSNs to be allocated, looking like the above example.\n\n* Converts this long list of DDs and DSNs above into TSO\n  allocate statements, which are then executed.\n  Example of TSO commands converted from above example list:\n    | ALLOC F(ISPLLIB) DA('SYSX.CAI.PAN.CAIISPL') SHR\n    | ALLOC F(ISPMLIB) DA( -\n    |    'SYSX.CAI.PAN.CAIISPM' -\n    |    'SYSX.CYFUSION.MSGS' -\n    |    ) SHR\n    | ALLOC F(ISPPLIB) DA( -\n    |    'SYSX.CAI.PAN.CAIISPP' -\n    |    'SYSX.CYFUSION.PANELS' -\n    |    ) SHR\n    | ALLOC F(SYSEXEC) DA( -\n    |    'SYSX.CYFUSION.EXECS' -\n    |    'SYSX.FILEAID.SYSEXEC' -\n    |    ) SHR\n  etc.\n\n* Lastly, reads the member specified by the *LAST* STARTCMD line in the\n  merged drivers of the third step. The commands found in this member\n  are executed. See member #SPECIAL to see an example. Normally this\n  would be used to start ISPF, but any valid TSO command can be executed\n  here, such as 'SDSF'. Also you can, for instance, place a LOGOFF\n  command after the ISPF start command to achieve an automatic logoff\n  when you exit ISPF.\n\n\nTo start using this, update your TSO logon proc to pass:\nPARM='EX ''MA133.TSO.LOGON(CATLIBS)'''\nin the TSO JCL. For example:\n    | //TSOBASIC PROC\n    | //TSOBASIC EXEC PGM=IKJEFT01,DYNAMNBR=256,\n    | //         PARM='EX ''MA133.TSO.LOGON(CATLIBS)'''\n    | //SYSLBC   DD DISP=SHR,DSN=SYS1.BRODCAST\n    | //SYSPRINT DD TERM=TS,SYSOUT=*\n    | //SYSTERM  DD TERM=TS,SYSOUT=*\n    | //SYSIN    DD TERM=TS\n\nYou can also run the same command directly from the TSO READY prompt if\nyou want to test this.\n\nSee the CATLIBS exec for more details on parms you can pass to override\nthe default behavior of the exec.\n\n/*********************************************************************/\n/* More Excruciating Details                                         */\n/*********************************************************************/\n* See member #BASIC for more details on startup members.\n* See member PRODUCT1  for more details on what else can be done with\n  include members.\n* See member USERFRST for more details on how to allocate your own\n  libraries ahead of the standard libs (details in member $USE).\n* See member USERLAST for more details on how to allocate your own\n  libraries at the end of the standard libs.\n* See member $USE in this library for examples on how to set up and\n  use user parmlibs, as well as benefits and drawbacks of using this.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$USE": {"ttr": 26, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00!\\x01\\x04\\x02\\x1f\\x01\\x04\\x07o\\x12W\\x009\\x00\\x82\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2004-01-21T00:00:00", "modifydate": "2004-03-16T12:57:21", "lines": 57, "newlines": 130, "modlines": 0, "user": "MA133"}, "text": "/*********************************************************************/\n/* CatLibs Parmlibs                                                  */\n/*********************************************************************/\nLogon parmlibs are used to allocate products and user datasets to your\nTSO session before ISPF is started. MA133.TSO.LOGON.system.PARMLIB is\nread by default, and userid.TSO.LOGON.PARMLIB is read if it is found.\nPDS members in the user parmlib will override the system parmlib\nmembers.\n\nTo customize your ISPF session to the way you want, simply allocate\nuserid.TSO.LOGON.PARMLIB with the same attributes as, but smaller than,\nMA133.TSO.LOGON.sys.PARMLIB (standard 80-column PDS). Then create\nmembers in this lib to make the logon exec do what you want.\n\nExamples:\n* To place your own set of libraries ahead of the standard libs, create\n  a member called USERFRST in your customized parmlib. Specify in here\n  all the extra libraries you need, including your buddy's libs, with\n  their corresponding DDs. Logon again and bob's your uncle. For\n  example, to add 'JOE.SYSPROC' at the start of the clist libraries,\n  specify in this member:\n    | SYSPROC 'JOE.SYSPROC'\n\n* To place your own set of libraries at the end of the standard libs,\n  create a member called USERLAST in your customized parmlib.\n\n* To test a new version of PRODUCTx, create a member called PRODUCTx in\n  your parmlib, and copy the PRODUCTx member from the system parmlib.\n  Update the dataset names to the new libraries and logon again. The\n  exec will automatically pick up *YOUR* PRODUCTx libraries.\n\n* To add a new product to your logon that is not in the standard logons,\n  create the product member in your parmlib, specifying the DDNAMEs and\n  DSNs required. Then copy the driver member you execute from this\n  parmlib (@BASIC or whatever), and add in your product library at the\n  spot you choose. See the $PRC2DRV member for details on what driver\n  members are for.\n\n* To change the way ISPF starts, create an override member that you\n  execute (such as #BASIC), and make your alterations to the ISPF\n  startup command there.  See the $README member for details on startup\n  members.\n\n* To create an automatic logoff command, so that when you exit ISPF\n  you are automatically logged off, create a custom STARTCMD member\n  (as in the previous example) and add a 'LOGOFF' command after the\n  ISPF start command. (There are other ways of acheiving the same\n  result, this is just to illustrate what you can do with this).\n\n* To create JCL that shows how the libs are allocated, you can pass\n  'WRITEJCL=Y' to the logon exec, e.g.:\n    | TSO EX 'MA133.TSO.LOGON(CATLIBS)' 'WRITEJCL=Y'\n  A dataset will be allocated and the DDs will be dumped to it, which\n  you can later edit. When run in this way, you can execute it from\n  within ISPF as no allocations will be performed. This can be used to\n  test your changes before you attempt to logon. It can also be used to\n  convert from using CatLibs if someone wants to do so at a later time.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CATLIBS": {"ttr": 28, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00R\\x01\\x04\\x05\\x1f\\x01\\x04\\x08\\x1f\\x147\\x02\\xb1\\x02\\xac\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2004-02-20T00:00:00", "modifydate": "2004-03-21T14:37:52", "lines": 689, "newlines": 684, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*-------------------------------------------------------------------*/\n/* call this with 'driver=drivermem,writejcl=anything,trace=anything'*/\n/* this must be done before signal novalue is set so the user won't  */\n/* have to remember to put quotes on the values.                     */\n/*-------------------------------------------------------------------*/\n/* this will take a parm string, break it up at each comma, and      */\n/* execute the result, so it will take:                              */\n/* WRITEJCL=Y,TRACE=Y,DRIVER=@BASE                                   */\n/* break the line into three commands, and interpret them to set the */\n/* fields to the values specified. this is a lazy way to pass parms, */\n/* but it works in a pinch.                                          */\n/*-------------------------------------------------------------------*/\nParse value '' with driver writejcl trace   /* init our vars */\nArg parms .\nDo while parms <> ''\n  Parse var parms parm ',' parms /* chop off at next comma           */\n  Interpret parm                 /* execute 'writejcl=y' or whatever */\nEnd\nIf writejcl = '' then writejcl = 0\nElse writejcl = 1\nIf trace = '' then trace = 0\nElse trace = 1\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\nSignal On Halt\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered.                                -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Halted on line\"          Sigl; Call Cleanup; Exit(12);\nCleanup:\nDo While Queued() > 0; Pull; End;\nCall Free_Logon_Parmlibs\nReturn\n/*-------------------------------------------------------------------*/\n/*- This exec is used to allocate product libraries to a tso/ispf   -*/\n/*- session.                                                        -*/\n/*-------------------------------------------------------------------*/\n/*- arguments to this exec:                                         -*/\n/*- * driver is the initial member and has a list of include members-*/\n/*-     to read in.                                                 -*/\n/*- * writejcl is used to generate jcl instead of doing allocates.  -*/\n/*-     it can be set to anything to turn this on. you can run this -*/\n/*-     exec from within ispf if you have this parm set as it won't -*/\n/*-     try to do any allocates.                                    -*/\n/*- * trace turns on internal messages to follow the logic.         -*/\n/*-     it can be set to anything to turn this on.                  -*/\n/*-------------------------------------------------------------------*/\n/*- parms to set below:                                             -*/\n/*- * allocUnit is the allocation unit for work datasets for non-sms-*/\n/*-     shops. can be set to storage group or null for sms shops.   -*/\n/*- * sysLogonParmlib is the system parmlib name that contains the  -*/\n/*-     prodcut include libs and driver members.                    -*/\n/*- * userLogonParmlib is the override lib name that allows         -*/\n/*-     individual users to customize their logon allocations.      -*/\n/*- * ispfProf is the clist/exec used to allocate the ispf ISPPROF  -*/\n/*-     dataset, and this must reside in it same libarary as this.  -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nAddress TSO\n\n/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n/*!! start of global variables that need to be reviewed.           !!*/\n/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n/* work allocation unit for non-sms shops. null it for sms, or else */\n/* set it to a storage group if you don't use acs routines.         */\nallocUnit = 'UNIT(3390)'\n\n/* the name this exec looks for to find a user override lib */\nuserLogonParmlib = \"'\"Sysvar('SYSUID')\".TSO.LOGON.PARMLIB'\"\n\n/* the name this exec looks for to find the system parm lib */\nsysLogonParmlib = ,\n  \"'MA133.TSO.LOGON.\"Mvsvar(\"SYSNAME\")\".PARMLIB'\"\nIf Sysdsn(sysLogonParmlib) <> 'OK' Then\n  sysLogonParmlib = \"'MA133.TSO.LOGON.PARMLIB'\"\nIf Sysdsn(sysLogonParmlib) <> 'OK' Then\n  sysLogonParmlib = userLogonParmlib\n\n/* the name this exec looks for to run the ISPF profile alloc clist*/\nispfProf = \"ISPFPROF\"\n/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n/*!! end   of global variables that need to be reviewed.           !!*/\n/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n\n/* make sure we're in a valid environ */\nIf writeJcL = 0 & Sysvar('SYSISPF') = 'ACTIVE' then do\n  Say 'This exec cannot be run from within ISPF.'\n  Say 'It will reallocate ISPF libraries.'\n  Say 'Specify WRITEJCL=Y to run within ISPF for testing purposes.'\n  Return\nEnd\n\n/* we're ready to rock */\nCall Allocate_Profile\nCall Allocate_Logon_Parmlibs\nCall Merge_Driver_Members\nCall Read_Include_Members\nCall Read_Startup_Member\nCall Free_Logon_Parmlibs\nCall Allocate_Tso_Libs\nCall Queue_Startup_Command\n\nReturn\n/*-------------------------------------------------------------------*/\n/* Allocate the parmlibs                                             */\n/*-------------------------------------------------------------------*/\nAllocate_Profile:\n\n/* assume that the ispf profile allocation exec is in the same      */\n/* dataset that CATLIBS is in. this is so we don't have to alloc an */\n/* initial SYSPROC to our logon.                                    */\nIf writejcl then return\nParse source . . . . logonLib .\n\"EX '\"logonLib\"(\"ispfProf\")'\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/* Allocate the parmlibs                                             */\n/*-------------------------------------------------------------------*/\nAllocate_Logon_Parmlibs:\n\n/* if there's a user parmlib, concat it ahead of the system parm */\nIf Sysdsn(userLogonParmlib) = \"OK\" Then\n  \"ALLOC F(SYSUT1) DA(\" ,\n    userLogonParmlib ,\n    sysLogonParmlib ,\n    \") SHR\"\nElse \"ALLOC F(SYSUT1) DA(\"sysLogonParmlib\") SHR\"\nIf RC > 0 then Signal Failure\n\n/* allocate the rest of the datasets required by iebptpch */\n\"ALLOC F(SYSUT2) NEW DELETE SPACE(2 2) TRACKS\" ,\n  \"DSORG(PS) RECFM(F B) LRECL(80)\"\nIf RC > 0 then Signal Failure\n\n\"ALLOC F(SYSPRINT) NEW DELETE REU\" ,\n  allocUnit \"SPACE(5 5) TRACKS\" ,\n  \"LRECL(121) DSORG(PS) RECFM(F B)\"\nIf RC > 0 then Signal Failure\n\n\"ALLOC F(SYSIN)  NEW DELETE REU\" ,\n  allocUnit \"SPACE(1 1) TRACKS\" ,\n  \"LRECL(80) DSORG(PS) RECFM(F B)\"\nIf RC > 0 then Signal Failure\n\nReturn\n/*-------------------------------------------------------------------*/\n/* free the parmlibs.                                                */\n/*-------------------------------------------------------------------*/\nFree_Logon_Parmlibs:\n\n/* free the iebptpch libs */\n\"FREE F(SYSUT1 SYSUT2 SYSPRINT SYSIN)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/* merge all the drivers to get a merged list of members to include. */\n/*-------------------------------------------------------------------*/\n/* this will take each MERGE command and read in the specified member*/\n/* so that the resultant include list is in the proper order. say:   */\n/*    @BASE has the following:                                       */\n/*      INCLUDE BASE1                                                */\n/*      INCLUDE BASE2                                                */\n/*    @DEVELOP has the following:                                    */\n/*      INCLUDE DEVELOP1                                             */\n/*      MERGE @BASE                                                  */\n/*      INCLUDE DEVELOP2                                             */\n/* the results of this merge would be:                               */\n/*      INCLUDE DEVELOP1                                             */\n/*      INCLUDE BASE1                                                */\n/*      INCLUDE BASE2                                                */\n/*      INCLUDE DEVELOP2                                             */\n/*-------------------------------------------------------------------*/\nMerge_Driver_Members:\n\nIf trace then Say 'Preparing to merge all driver members.'\n\ninitDriver = Proc_To_Driver()\n\nIf trace then Say 'Reading in initial driver' initDriver'.'\n\n/* read it in to driver.@develop.x as in above example */\nCall Load_Driver initDriver\nIf driver.initDriver.0 = 0 then do /* nothing got read missing member */\n  Say 'Initial driver' member 'is empty or not found.'\n  Signal Failure\nEnd\n\n/* start off a master include list as inclList.0.x */\nDo iDriver = 1 to driver.initDriver.0\n  inclList.0.iDriver = driver.initDriver.iDriver\nEnd\ninclList.0.0 = driver.initDriver.0\n\nIf trace then Say 'Reading in merged drivers.'\n\niCurrPass = 0\nmergeDone = 0\nstartMem = \"\"\nDo until mergeDone\n  Call Merge_Drivers\nEnd\n\nIf trace then do\n  Say 'Drivers merged. Listing follows...'\n  Do iInclList = 1 to inclList.iCurrPass.0\n    Say inclList.iCurrPass.iInclList\n  End\n  Say\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/* do this one at a time for each 'MERGE' command encountered.       */\n/*-------------------------------------------------------------------*/\n/* copy the array and bump up the second array index each time.      */\n/* copy the array and merge in the members to the new array like so: */\n/*   inclList.0.x for the first pass, then:                          */\n/*   inclList.1.x for the second, then:                              */\n/*   inclList.2.x for the third etc.                                 */\n/* this is the only way i could figure out how to do this quickly.   */\n/*-------------------------------------------------------------------*/\nMerge_Drivers:\n\nmergeDone = 1            /* merge is done when no more merges found*/\niPrevPass = iCurrPass\niCurrPass = iCurrPass + 1\niCurrIncl = 0\nDo iPrevIncl = 1 to inclList.iPrevPass.0\n  Parse var inclList.iPrevPass.iPrevIncl merge member .\n\n  /* store the last startup member found in the merge list for   */\n  /* later processing. just storing it for now.                  */\n  If merge = 'STARTCMD' then startMem = member\n\n  /* if this is not a merge statement, simply copy the previous  */\n  /* pass to the current array. if we did a merge already, then  */\n  /* that's all we do for this pass, we simply copy then pick    */\n  /* up the next merge in the next pass.                         */\n  If mergeDone = 0 | merge <> 'MERGE' then do\n    iCurrIncl = iCurrIncl + 1\n    inclList.iCurrPass.iCurrIncl = inclList.iPrevPass.iPrevIncl\n  End\n\n  Else do\n    /* if we already merged in this member (merged twice), there */\n    /* will be a driver.member.0 var already. prevents loops.    */\n    If Symbol('driver.'member'.0') = 'VAR' then do\n      Say 'Driver' member 'was included more than once. Skipped.'\n      Iterate\n    End\n    Call Load_Driver member    /* load up our new merged member */\n    If driver.member.0 = 0 then do\n      Say 'Driver' member 'empty or not found. Skipped.'\n      Iterate\n    End\n    mergeDone = 0         /* we ain't dun yit */\n    /* add the new merge member to the current array before adding */\n    /* the remaining previous pass records to the current array.   */\n    Do iDriver = 1 to driver.member.0\n      iCurrIncl = iCurrIncl + 1\n      inclList.iCurrPass.iCurrIncl = driver.member.iDriver\n    End\n  End\n\nEnd\ninclList.iCurrPass.0 = iCurrIncl\n/* may as well drop the previous one since it's useless now. */\nDrop inclList.iPrevPass.\n\nReturn\n/*-------------------------------------------------------------------*/\n/* load a driver member into memory.                                */\n/*-------------------------------------------------------------------*/\nLoad_Driver:\nArg member .\n\nIf trace then Say 'Reading in driver member' member'.'\n\n/* load up a driver member into an array for processing */\nDrop readMember.\nCall Add_Read_Member member\nCall Read_Members\nDo iRecord = 1 to record.0\n  driver.member.iRecord = record.iRecord\nEnd\ndriver.member.0 = record.0\n\nReturn\n/*-------------------------------------------------------------------*/\n/* read the proc-to-driver member and return an initial driver.     */\n/*-------------------------------------------------------------------*/\nProc_To_Driver:\n\n/* read in the proc-to-driver member */\nDrop readMember.\nCall Add_Read_Member '$PRC2DRV'\nCall Read_Members\n\nuserProc = Sysvar('SYSPROC')  /* find out what proc we're running */\n\n/* if the user's tsoproc matches one of the records, return it. */\nDo iRecord = 1 to record.0\n  Parse Var record.iRecord proc driver .\n  If proc = userProc Then Return driver\nEnd\n\nReturn '@BASIC'\n/*-------------------------------------------------------------------*/\n/* read the include members called from the driver members.          */\n/*-------------------------------------------------------------------*/\n/* we have a long list of product include members now. so now we have*/\n/* to read them in so that we end up with a long list of dds, e.g.:  */\n/*    ISPPLIB 'ISP.ISPPLIB'                                          */\n/*    ISPMLIB 'ISP.ISPMLIB'                                          */\n/*    ISPPLIB 'SYS2.SOMEPRODUCT.ISPPLIB'                             */\n/*    ISPMLIB 'SYS2.SOMEPRODUCT.ISPPLIB'                             */\n/*-------------------------------------------------------------------*/\nRead_Include_Members:\n\nIf trace then Say 'Reading in all include members.'\n\n/* add each include member to the list of members to be read */\n/* by iebptpch                                               */\nDrop readMember.\nCall Add_Read_Member 'USERFRST'\nDo iIncl = 1 to inclList.iCurrPass.0\n  Parse var inclList.iCurrPass.iIncl include member .\n  If include <> 'INCLUDE' then iterate\n  If Symbol('inclChk.'member) = 'VAR' then do\n    Say 'Include member' member 'was included more than once. Skipped.'\n    Iterate\n  End\n  inclChk.member = ''\n  Call Add_Read_Member member\nEnd\nCall Add_Read_Member 'USERLAST'\nCall Read_Members\nDrop inclChk.\nDrop inclList.\n\n/* make the dd's listed in the form of inclList.x */\nIf trace then Say 'Include members read. Listing follows...'\niInclList = 0\nDo iRecord = 1 to record.0\n  iInclList = iInclList + 1\n  inclList.iInclList = record.iRecord\n  If trace then Say inclList.iInclList\nEnd\ninclList.0 = iInclList\nIf trace then Say\n\nReturn\n/*-------------------------------------------------------------------*/\n/* convert the include list into dd name concatenations.             */\n/*-------------------------------------------------------------------*/\n/* form another set of arrays from the inclList.x above. they will be*/\n/*    ddNames.1 = 'ISPPLIB' (say)                                    */\n/*    ddNames.2 = 'ISPLLIB' as necessary, and each dd here will have */\n/* its own array as follows:                                         */\n/*    dd.ISPPLIB.1 = 'ISP.ISPPLIB'                                   */\n/*    dd.ISPPLIB.2 = 'SYS2.SOMEPRODUCT.ISPPLIB'                      */\n/*    dd.ISPLLIB.1 = 'ISP.ISPLLIB'                                   */\n/*    dd.ISPLLIB.2 = 'SYS2.SOMEPRODUCT.ISPLLIB'                      */\n/* at the end we simply loop thru ddNames.x, and for each one, loop  */\n/* thru dd.ddName.x to allocate the dds.                             */\n/*-------------------------------------------------------------------*/\nAllocate_Tso_Libs:\n\nIf trace then\n  Say 'Converting include list to DD names and' ,\n    'executing inline commands.'\n\n/* loop thru the dd and dsn list produced above */\niddNames = 0\nDo iInclList = 1 To inclList.0\n  Parse var inclList.iInclList ddName dsn .\n  /* if this is an OFF or ON command, it's not actually a DD but   */\n  /* really an inline command. OFF means you don't want to see the */\n  /* results, ON means you do. so to free a dataset that probably  */\n  /* isn't allocated you'd say \"OFF 'FREE F(XXX)'\". see the        */\n  /* PRODUCT product parm for more details.                        */\n  If ddName = \"OFF\" | ddName = \"ON\" then do\n    Parse var inclList.iInclList onOff action\n    Call Do_Inline_Command onOff action\n    Iterate\n  End\n\n  /* this is the first time we've seen this dd, start a new array */\n  /* in the form of dd.ddName.x */\n  If Symbol('dd.'ddName'.0') <> 'VAR' then do\n    If trace then Say 'Adding new DD name:' ddName\n    dd.ddName.0 = 0\n    iddNames = iddNames + 1\n    ddNames.iddNames = ddName\n  End\n\n  i = dd.ddName.0\n  i = i + 1\n  dd.ddName.0 = i\n  If Left(dsn,1) = '\"' then Interpret \"Dsn =\" dsn\n  dd.ddName.i = dsn\nEnd\nddNames.0 = iddNames\n/* inline commands may have specified USERVAR.x, drop them now */\n/* see PRODUCT product member for more details. */\nDrop UserVar.\n\nIf writejcl then do\n  Call Write_Jcl\n  Return\nEnd\n\nIf trace then Say 'Allocating libraries.'\n\n/* take each ddname found and allocate all the libs collected up */\n/* for that ddname.                                              */\nDo iddNames = 1 to ddNames.0\n  ddName = ddNames.iddNames\n  /* if the allocation fails, redrive it with the extra overhead */\n  /* of seeing if the datasets exist first */\n  If Do_Allocate(ddName) > 0 then Call Do_Allocate ddName 1\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/* do an inline command.                                             */\n/*-------------------------------------------------------------------*/\nDo_Inline_Command:\nArg onOff action\n\nIf writejcl then return\nIf trace then do\n  Say 'Executing inline command:'\n  Say action\nEnd\n\n/* turn message level off or on based on what user wants */\nx = Msg(onOff)\n/* turn off signal trapping so it's less prone to error. */\nSignal Off Novalue;Signal Off Failure;Signal Off Syntax\n\nInterpret action\n\n/* weez dun. set 'er back. */\nSignal On Syntax;Signal On Failure;Signal On Novalue\nx = Msg(x)\n\nReturn\n/*-------------------------------------------------------------------*/\n/* do the tso allocations.                                           */\n/*-------------------------------------------------------------------*/\n/* this will take a passed ddname and spin thru the dd.ddName.x array*/\n/* and execute a corresponding tso allocate command. if check is 1   */\n/* then we already tried this allocation and it failed. so this time */\n/* carefully check all the dsns to see if there's a problem with them*/\n/*-------------------------------------------------------------------*/\nDo_Allocate:\nArg ddName check .\nallocRet = 0\n\nIf trace then Say 'Processing allocation for' ddName\n\nIf check = 1 then Do\n  frame = Copies('!',79)\n  Say frame\n  Say 'Attempting to recover from allocation failure for DD' ddName'.'\n  Say 'Offending datasets will be removed from allocation.'\nEnd\n\nx = Msg('OFF')\n\"FREE F(\"ddName\")\"\nx = Msg(x)\n\n/* allocate a long string of datasets separated by a space, e.g. */\n/*  'sys1.ispplib' 'xyz.abc' 'a123.b123' etc.                    */\nalloc = \"\"\nDo iDD = 1 to dd.ddName.0\n  dsn = dd.ddName.iDD\n  If check = 1 then do\n    status = Sysdsn(dsn)\n    If status <> 'OK' then do\n      Say 'Dsn status for' dsn 'is' status'.'\n      Iterate\n    End\n  End\n  If trace then Say '    ' dsn\n  alloc = alloc || dsn || ' '\nEnd\n\n/* make sure there is something to allocate for this dd. there can be*/\n/* none when checking the dsns removed all datasets from this dd.    */\nIf alloc <> '' then do\n  \"ALLOC F(\"ddName\") DA(\"alloc\") SHR\"\n  allocRet = RC\nEnd\nElse Say 'No datasets to allocate to DD' ddName'. Skipping.'\n\nIf check = 1 then Do\n  Say 'Return code from recovered DD' ddName 'is:' allocRet\n  Say frame\n  Say\nEnd\n\nReturn allocRet\n/*-------------------------------------------------------------------*/\n/* read the last startup member read from the drivers members.       */\n/*-------------------------------------------------------------------*/\n/* the very last STARTCMD read from the @drivers was stored above.   */\n/* we have finished allocating all the ispf datasets, now it's time  */\n/* to read in whatever goodies are there.                            */\n/*-------------------------------------------------------------------*/\nRead_Startup_Member:\n\niStartCmd = 0\nIf startMem <> \"\" then do\n  If trace then\n    Say 'Last startup member read from merged drivers is:' startMem'.'\n  Drop readMember.\n  Call Add_Read_Member startMem\n  Call Read_Members\n  Do iRecord = 1 to record.0\n    iStartCmd = iStartCmd + 1\n    startCmd.iStartCmd = record.iRecord\n  End\n  If trace then do\n    If record.0 > 0 then\n      Say 'Startup member read.'\n    Else Say 'No commands found in startup member.'\n    Say\n  End\nEnd\nstartCmd.0 = iStartCmd\n\nIf startCmd.0 = 0 then do\n  If trace then Say \"No startup commands found, defaulting to 'ISPF'.\"\n  startCmd.0 = 1\n  startCmd.1 = 'ISPF NOLOGO'\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/* queue the startup commands to execute.                            */\n/*-------------------------------------------------------------------*/\n/* queue the commands to the external data queue so that they will   */\n/* run when this command finishes executing. this is to ensure that  */\n/* this large rexx with its many variables is all freed up before    */\n/* starting ispf. if we started ispf here, all that storage would    */\n/* be wasted while inside ispf.                                      */\n/*-------------------------------------------------------------------*/\nQueue_Startup_Command:\n\nIf writejcl then return\nIf trace then Say 'Issuing startup command.'\n\n/* make sure any continued commands (ending with '-' or '+') */\n/* are concatentated together to make up one big command. */\ncmd = ''\nDo iStartCmd = 1 to startCmd.0\n  cmd = cmd startCmd.iStartCmd\n  cmd = Strip(cmd)\n  lastChar = Right(cmd,1)\n  If lastChar <> '-' & lastChar /= '+' then do\n    Queue cmd\n    cmd = ''\n  End\n  else cmd = Strip(cmd,'T',lastChar)\nEnd\nDrop startCmd.\n\nReturn\n/*-------------------------------------------------------------------*/\n/* write out the jcl.                                                */\n/*-------------------------------------------------------------------*/\n/* just gonna write out the jcl so you can see what it is doing.     */\n/*-------------------------------------------------------------------*/\nWrite_Jcl:\n\nDo iddNames = 1 To ddNames.0\n  ddName = ddNames.iddNames\n  If dd.ddName.0 = 0 then iterate\n  dsn = dd.ddName.1\n  Call Write_Dsn_Status\n  dsn = Strip(dsn,\"B\",\"'\")\n  dsn = \"DD  DISP=SHR,DSN=\"dsn\n  Queue Overlay(dsn,\"//\"ddName,12)\n  Do iDsn = 2 to dd.ddName.0\n    dsn = dd.ddName.iDsn\n    Call Write_Dsn_Status\n    dsn = Strip(dsn,\"B\",\"'\")\n    dsn = \"DD  DISP=SHR,DSN=\"dsn\n    Queue Overlay(dsn,\"//\",12)\n  End\nEnd\n\nuserProc = Sysvar('SYSPROC')  /* find out what proc we're running */\n\noutputJcl = \"'\"Sysvar('SYSUID')\".\"userProc\".JCL'\"\nx = Msg('OFF')\n\"DELETE\" outputJcl\nx = Msg(x)\n\"ALLOC F(OUTPUT) DA(\"outputJcl\") NEW CATALOG\" ,\n  allocUnit \"SPACE(1 1) TRACKS\" ,\n  \"LRECL(80) DSORG(PS) RECFM(F B)\"\n\"EXECIO \" Queued() \"DISKW OUTPUT (FINIS\"\n\"FREE F(OUTPUT)\"\nSay 'JCL written to' outputJcl\n\nReturn\n/*-------------------------------------------------------------------*/\n/* check the status of the dsn as it is being written out            */\n/*-------------------------------------------------------------------*/\nWrite_Dsn_Status:\n\nstatus = sysdsn(dsn)\nIf status <> 'OK' then\n  Queue '//* following dataset status is:' status\n\nReturn\n/*-------------------------------------------------------------------*/\n/* add a member to the list to read in.                              */\n/*-------------------------------------------------------------------*/\nAdd_Read_Member:\nArg member\n\nIf Symbol('readMember.0') = 'LIT' Then readMember.0 = 0\nreadMember.0 = readMember.0 + 1\niReadMember = readMember.0\nreadMember.iReadMember = member\n\nReturn\n/*-------------------------------------------------------------------*/\n/* invoke ibm futility to read in a bunch of members.                */\n/*-------------------------------------------------------------------*/\n/* this will read in the members into a record.x array. comments and */\n/* blank lines are removed, along with iebptpch report headers. that */\n/* way i don't have to worry about these things in the rest of this. */\n/*-------------------------------------------------------------------*/\nRead_Members:\n\nDrop record.\nQueue '  PRINT TYPORG=PO,MAXNAME=200,MAXFLDS=200'\nDo iReadMember = 1 to readMember.0\n  Queue '  MEMBER NAME='readMember.iReadMember\n  Queue '  RECORD FIELD=(72)'\nEnd\n\"EXECIO\" Queued() \"DISKW SYSIN (FINIS\"\n\"CALL *(IEBPTPCH)\"\n\n/* tell user what happened if a non-zero return code occured */\nIf RC > 0 then do\n  Say 'Return code' RC 'from IEBPTPCH.'\n  Say 'Check for error messages in the output...'\n  \"EXECIO * DISKR SYSPRINT (STEM sysprint. FINIS\"\n  Do iSysprint = 1 To sysprint.0\n    If Left(sysprint.iSysprint,1) = '1' then iterate\n    Say Left(sysprint.iSysprint,79)\n  End\n  Say 'Output from IEBPTPCH complete.'\n  Say\nEnd\n\n/* queue everything up in the record.x array */\niRecord = 0\n\"EXECIO * DISKR SYSUT2 (FINIS\"\nDo while Queued() > 0\n  Pull header record\n  If header = 1 then iterate\n  If header = 'MEMBER' then iterate\n  If header = '' then iterate\n  If Left(header,1) = '*' then iterate\n  iRecord = iRecord + 1\n  record.iRecord = header record\n  Upper record.iRecord\nEnd\nrecord.0 = iRecord\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPFPROF": {"ttr": 22, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x04\\x01o\\x01\\x04\\x01o\\x16\\x03\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-01-16T00:00:00", "modifydate": "2004-01-16T16:03:31", "lines": 31, "newlines": 31, "modlines": 0, "user": "MA133"}, "text": "PROC 0 PROFDSN\n/*                                                                  */\n/* THIS EXEC ALLOCATES THE ISPF PROFILE AND ADD IT TO ISPTABL LIB   */\n/*                                                                  */\nIF &PROFDSN = &STR() THEN +\n  SET &PROFDSN = &STR('&SYSUID..ISPF.ISPPROF')\n\nCONTROL NOMSG NOFLUSH\nFREE  FI(ISPPROF)\nALLOC FI(ISPPROF) SHR DA(&PROFDSN.)\nIF &LASTCC \u00ac= 0 THEN DO\n  FREE FI(ISPCRTE)\n  CONTROL MSG\n  ATTRIB ISPCRTE DSORG(PO) RECFM(F B) LRECL(80) BLKSIZE(6160)\n  ALLOC FI(ISPPROF) DA(&PROFDSN.) SP(5,1) CYLINDERS DIR(20) +\n    USING(ISPCRTE)\n  IF &LASTCC = 0 THEN +\n    WRITE *** ISPF PROFILE DATA SET &PROFDSN. HAS BEEN CREATED\n  ELSE DO\n    WRITE  *** UNABLE TO ALLOCATE ISPF PROFILE DATA SET &PROFDSN.\n    FREE FI(ISPCRTE)\n    EXIT CODE(12)\n   END\n  FREE FI(ISPCRTE)\nEND\nCONTROL MSG FLUSH\n\nCONTROL NOMSG\nFREE  FI(ISPTABL)\nCONTROL MSG\nALLOC FI(ISPTABL) SHR DA(&PROFDSN.)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ZPDSLIST": {"ttr": 515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x005\\x01\\x04\\x05\\x0f\\x01\\x04\\x10\\x0f\\x10\\x11\\x00\\x05\\x00\\x04\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2004-02-19T00:00:00", "modifydate": "2004-04-09T10:11:35", "lines": 5, "newlines": 4, "modlines": 0, "user": "MA133"}, "text": "$BENEFIT                 45  2004/03/10  2004/03/14 17:38:52  MA133\n$README                 135  2004/03/14  2004/03/30 12:57:57  MA133\n$USE                     57  2004/01/21  2004/03/16 12:57:21  MA133\nCATLIBS                 689  2004/02/20  2004/03/21 14:37:52  MA133\nISPFPROF                 31  2004/01/16  2004/01/16 16:03:31  MA133\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT674/CBT.V500.FILE674.PDS/LOGON.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT674/CBT.V500.FILE674.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}