{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "MA133", "INMTNODE": "MA133", "INMTUID": "N1", "INMFTIME": "20040510134322000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 646646, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 13, "INMDSNAM": "MA133.TSO.SYSEXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"MA133.TSO.SYSEXEC": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 160, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "040129", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x14'", "DS1LSTAR": "b'\\x00\\r\\x04'", "DS1TRBAL": "b'd\\xce'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x9b\\x80\\xb8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x9b\\x80\\xb8'", "b'X\\xf3\\x15\\xa8\\x00\\x00\\x04\\xfb\\x00\\x02\\x04\\xfd\\x00\\x0b\\x00('", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$DOC": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00V\\x01\\x04\\x05_\\x01\\x04\\x10\\x0f\\x10\\x17\\x00\\x16\\x00\\x12\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-02-24T00:00:00", "modifydate": "2004-04-09T10:17:56", "lines": 22, "newlines": 18, "modlines": 0, "user": "MA133"}, "text": "/* not rexx */\n\nTHESE UTILITIES ARE PROVIDED AS IS WITH NO WARRANTIES OR GUARANTEES OF\nANY KIND WHATSOEVER. USE AT YOUR OWN RISK!\n\nthese are little utilities and useful tools i have built over the years.\nthey are free to anyone who wants to use them. the ZOOM exec i don't\ntake any credit for, it was downloaded from www.cbttape.org, file 671.\ni distribute it here with a couple of mods since i use it in one or two\nof my other execs.\n\nif you have any questions or problems with these execs, please contact\nme at the address below.\n\nthey have been tested using os/390 2.10. i will be testing them using\nz/os 1.4 as soon as possible. i'd be happy to help get them working at\nother levels and would appreciate any suggestions for improvement or any\nother feedback.\n\nyou may contact me at: mvs@robinandmariette.com\n\nyou may recieve udpates at: http://www.robinandmariette.com/Mvs/Rexx/\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$START": {"ttr": 17, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00@\\x00\\x94\\x15O\\x01\\x04\\x04o\\x12P\\x00\\x1a\\x00\\x1e\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1994-06-03T00:00:00", "modifydate": "2004-02-15T12:50:40", "lines": 26, "newlines": 30, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Whatever .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nReturn\n/*-------------------------------------------------------------------*/\n/*- The main exec routine.                                          -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nCall Whatever_Else\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$TBDISPL": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x002\\x00\\x94\\x08o\\x01\\x04\\x11/\\x10A\\x001\\x00$\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1994-03-27T00:00:00", "modifydate": "2004-04-21T10:41:32", "lines": 49, "newlines": 36, "modlines": 0, "user": "MA133"}, "text": "/*-------------------------------------------------------------------*/\n/* Use this routine as a model to display any ispf table.            */\n/* Place your own primary command and line commands in the areas     */\n/* provided. This model allows multiple line command selections.     */\n/* When all processing is complete, it will redisplay the table at   */\n/* the same position as the last display. One primary command is     */\n/* provided here, 'SORTCOMP' which will perform a complex sort on    */\n/* your table, promting the user to specify ascending and decending  */\n/* attributes for each column. See the 'SORTTB' exec for more.       */\n/* Change TabName to the table name you want to display.             */\n/*-------------------------------------------------------------------*/\n\nTabName = My_Table_Name\n\nDisplay_Table:\n\nAddress ISPEXEC\nCURSOR = 'LC'; CSRROW = 0; ZTDTOP = 0;\nDo Forever\n  \"TBTOP\" TabName\n  \"TBSKIP\" TabName \"NUMBER(\"ZTDTOP\") NOREAD\"\n  \"TBDISPL\" TabName \"PANEL(\"TabName\") POSITION(CRP) ROWID(ROW)\" ,\n    \"AUTOSEL(NO) CSRROW(\"CSRROW\") CURSOR(\"CURSOR\")\"\n  If RC > 4 Then Leave\n  CURSOR = 'ZCMD'\n\n  If ZCMD /= '' Then Do        /* primary commands go here */\n    Upper ZCMD\n    Select\n      When ZCMD = 'SORTCOMP' Then Call Sorttb TabName /* allows sort*/\n      Otherwise Nop\n    End\n  End\n\n  Do While ZTDSELS > 0       /* line commands go here */\n    Upper LC                 /* this loop allows multiple selecitons */\n    Select\n      When LC = 'S' Then Call Select\n      Otherwise Nop\n    End\n    If ZTDSELS > 1 Then \"TBDISPL\" TabName \"POSITION(CRP) ROWID(ROW)\"\n    Else ZTDSELS = 0\n    CURSOR = 'LC'\n  End\n  LC = ' '\n  \"TBGET\" DumpTab \"POSITION(CSRROW)\"       /* place cursor properly */\nEnd\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APARSTRP": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x002\\x01\\x03\\x11_\\x01\\x04\\t/\\x11\\x18\\x00&\\x00\\x18\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2003-04-25T00:00:00", "modifydate": "2004-04-01T11:18:32", "lines": 38, "newlines": 24, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/********************************************************************/\n/* this will run with eachmem to strip off the #\u00ac%$ing comments from*/\n/* ca-supplied fixes so that smp will be able to receive them.      */\n/* do 'tso eachmem apar-pds-name aparstrp'. can be called from      */\n/* exec ftppds to fix it up as soon as it's received.               */\n/********************************************************************/\nArg InDsn .\nAddress TSO\n\"ALLOC F(IN) DA(\"InDsn\") SHR\"\n\"EXECIO * DISKR IN (FINIS\"\n\"FREE F(IN)\"\n\nDo While Queued() > 0\n  Parse Pull Rec\n  /* save the ++apar or ++usermod or whatever for later */\n  If Left(Rec,2) = '++' & Left(Rec,5) <> '++VER' Then Do\n    Apar = Rec\n    Apar = Strip(Apar)\n    If Right(Apar,1) <> '.' Then Apar = Apar'.'\n    Iterate\n  End\n  /* we're passed the comments now */\n  If Left(Rec,5) = '++VER' Then Do\n    If Apar = '' Then Do\n      Say 'There is a problem with' InDsn'. Skipping.'\n      Iterate\n    End\n    Push Rec\n    Push Apar\n    \"ALLOC F(OUT) DA(\"InDsn\") SHR\"\n    \"EXECIO\" Queued() \"DISKW OUT (FINIS\"\n    \"FREE F(OUT)\"\n    Apar = ''\n  End\nEnd\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPRESS": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x00\\x08\\x01\\x04\\x04\\x8f\\x01\\x04\\x10\\x0f\\x10'\\x00l\\x00L\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "2004-02-17T00:00:00", "modifydate": "2004-04-09T10:27:08", "lines": 108, "newlines": 76, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Dsn Disp Echo .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nSay '*** Library compress failed!'\nIf Echo = '' & Symbol('Sysprint') = 'VAR' Then Do\n  Say 'Compress information written to' Sysprint\n  If Sysvar('SYSISPF') = 'ACTIVE' Then Call FDSN \"'\"Sysprint\"' B\"\nEnd\nReturn\n/*-------------------------------------------------------------------*/\n/*- This will compress a library. can be run as an edit macro or as -*/\n/*- a tso exec. disp is the disposition of the compressed lib (old  -*/\n/*- or shr). echo will write out the iebcopy messages to your screen-*/\n/*- if it is non-blank.                                             -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\n/* see if we're running as an edit macro */\nIf Sysvar('SYSISPF') = 'ACTIVE' Then Do\n  Address ISREDIT\n  \"MACRO (MACDISP MACECHO)\"\n  If RC = 0 Then Do\n    /* yep, load the vars */\n    Disp = MACDISP\n    Echo = MACECHO\n    \"(DSN) = DATASET\"\n    Dsn = \"'\"Dsn\"'\"\n  End\nEnd\nAddress TSO\n\n/* make sure our disp is ok */\nIf Disp = '' Then Disp = 'SHR'\nIf Disp /= 'OLD' & Disp /= 'SHR' Then Do\n  Say 'Invalid DISP passed:' Disp'. Must be OLD, SHR, or null.'\n  Signal Failure\nEnd\n\n/* if we're running as a batch job, just echo commands to systsprt */\nIf Echo = '' & Sysvar('SYSENV') = 'BACK' Then Echo = 'Y'\n\n/* make sure our dsn is ok */\nDsn = PrefDsn(Dsn)\nCall Check_Lib\n\n/* ready to rock */\n\"ALLOC F(PDS)   DA('\"Dsn\"')\" Disp \"REU\"\n\"ALLOC F(SYSIN) DA(ISPST2) NEW DELETE REU\" ,\n  \"UNIT(TEST)   SPACE(1)   TRACKS\" ,\n  \"LRECL(80)    DSORG(PS)  RECFM(F B)\"\n\n/* write results to a file if echo is set to no */\nIf Echo = '' Then Do\n  Sysprint = PrefDsn('SYSPRINT.COMPRESS')\n  If Sysdsn(\"'\"Sysprint\"'\") /= 'OK' Then\n    \"ALLOC F(SYSPRINT) DA('\"Sysprint\"') RECFM(F B A)\" ,\n      \"LRECL(121) SPACE(1 1) TRACK REUSE\"\n  Else \"ALLOC F(SYSPRINT) DA('\"Sysprint\"') SHR REUSE\"\nEnd\nElse \"ALLOC F(SYSPRINT) DA(*) REU\"\n\n/* do the compress */\nQueue '  COPY  I=((PDS,R)),O=PDS'\n\"EXECIO 1 DISKW SYSIN (FINIS\"\n\"TSOEXEC CALL *(IEBCOPY)\"\nSaveRC = RC\n\"FREE F(PDS SYSIN SYSPRINT)\"\nIf SaveRC > 4 Then Signal Failure\n\nSay \"Compress of '\"Dsn\"' successful.\"\n\nIf Echo = '' Then Do\n  x = Msg('OFF')\n  \"DELETE '\"Sysprint\"'\"\n  x = Msg(x)\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Double check that we're dealing with a valid lib                -*/\n/*-------------------------------------------------------------------*/\nCheck_Lib:\n\nCC = Listdsi(\"'\"Dsn\"'\")\nIf CC > 0 Then Do\n  Say \"ListDsi failed for '\"Dsn\"', CC=\"CC\", SYSREASON=\"SYSREASON\n  Signal Failure\nEnd\nIf SYSDSORG /= 'PO' Then Do\n  Say \"DSORG value of\" SYSDSORG \"must be PO for dataset '\"Dsn\"'\"\n  Signal Failure\nEnd\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELALL": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00B\\x01\\x04\\x11\\x9f\\x01\\x04\\x12\\x1f\\x14\\x13\\x00\\xb3\\x00~\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2004-04-28T00:00:00", "modifydate": "2004-04-30T14:13:42", "lines": 179, "newlines": 126, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*-------------------------------------------------------------------*/\n/*- this will delete all datasets beginning with the passed high    -*/\n/*- level qualifier. set gdgbases to 'Y' to remove the bases too.   -*/\n/*- set alias to Y to remove the single level hlq alias name. set   -*/\n/*- test to Y to see what this would do (takes no action).          -*/\n/*-------------------------------------------------------------------*/\nArg Hlq Gdgbases Alias Test .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn DeleteAll()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nReturn\n/*--------------------------------------------------------------------*/\n/* Read in all datasets and pull apart the list.                      */\n/*--------------------------------------------------------------------*/\nDeleteAll:\n\nIf Alias = 'Y' & (Pos('.',Hlq) > 0 | Length(Hlq) > 8) Then Do\n  Say 'You requested an alias be deleted,' ,\n    'but the alias name is invalid.'\n  Return 16\nEnd\n\nIf Alias = 'Y' & Gdgbases <> 'Y' Then Do\n  Say 'You requested an alias be deleted, but not gdgbases.'\n  Return 16\nEnd\n\nRetc = 0\n/* delete nonvsam and clusters first */\nCall Vector 1\n/* now go delete the gdg bases */\nIf Gdgbases = 'Y' Then Call Vector 2\n\nIf Alias = 'Y' Then Do\n  If Test = 'Y' Then Say \"DELETE '\"Hlq\"' ALIAS\"\n  Else Do\n    \"DELETE '\"Hlq\"' ALIAS\"\n    If RC <> 8 & RC > Retc Then Retc = RC\n  End\nEnd\n\nReturn Retc\n/*--------------------------------------------------------------------*/\n/* Read in all datasets and pull apart the list.                      */\n/*--------------------------------------------------------------------*/\nVector:\nArg Pass\n\nIf Sysvar('SYSISPF') = 'ACTIVE' & ,\n  (Pos('%',Hlq) > 0 | Pos('*',Hlq) > 0) Then Do\n  Call DelMask\n  Return\nEnd\n\nx=OutTrap('Idcams.')\n\"LISTC LEVEL(\"Hlq\")\"\nx=OutTrap('OFF')\nCall ProcessIdcams\n\nReturn\n/*--------------------------------------------------------------------*/\n/* Read in all datasets and pull apart the list.                      */\n/*--------------------------------------------------------------------*/\nProcessIdcams:\n\nDo iIdcams = 1 To Idcams.0\n  /* NONVSAM ------- MA133.SUPERC.LISTING.P211   */\n  /* CLUSTER ------- MA133.CICSTDV6.GENOL70.LIB3 */\n  /* GDG BASE ------ MA133.TEST                  */\n  Parse Var Idcams.iIdcams Type ' -' '- ' Dsn .\n  If Pass = 1 & (Type = 'NONVSAM' | Type = 'CLUSTER') Then Call DelDsn\n  If Pass = 2 & Type = 'GDG BASE' Then Call DelDsn\nEnd\n\nReturn\n/*--------------------------------------------------------------------*/\n/* Delete by 3.4 masking. takes a lot longer, but is more flexible.   */\n/*--------------------------------------------------------------------*/\nDelMask:\n\nAddress ISPEXEC\n\nIf Pass = 1 Then Do\n  If Test = 'Y' Then Do\n    Say 'Deleting by a mask and using the TEST' ,\n      'option will result in poor performance.'\n    Say 'The entire dataset list will have to be processed' ,\n      'multiple times.'\n    Say 'Slow progress will be marked with SCAN messages.'\n  End\n\n  Dsn = ''\n  \"LMDINIT LISTID(LISTID) LEVEL(\"Hlq\")\"\n  Do Forever\n    \"LMDLIST LISTID(\"LISTID\") OPTION(LIST) DATASET(DSN) STATS(YES)\"\n    If RC > 0 Then Leave\n    Select\n      When ZDLMIGR = 'YES' Then Call DelDsn\n      When ZDLDSORG = 'PS' Then Call DelDsn\n      When ZDLDSORG = 'PO' Then Call DelDsn\n      When ZDLDSORG = 'VS' & ZDLRECFM <> '?' Then Call DelDsn\n      Otherwise Nop\n    End\n  End\n  \"LMDLIST LISTID(\"LISTID\") OPTION(FREE)\"\n  \"LMDFREE LISTID(\"LISTID\")\"\nEnd\n\nIf Test = 'Y' Then Do\n  If Pass = 1 Then Say 'Scanning for tape datasets. Please be patient.'\n  Else Say 'Scanning for GDG bases. Please be patient.'\nEnd\n\n/* now get what's left over (tape, unknown stuff), or just process */\n/* gdg bases. can't tell the difference between bases, alias, or   */\n/* tape datasets with the variables that lmdlist sets, so have to  */\n/* do it in this round about, hokey way.                           */\nCount = 0\nTotal = 0\nDsn = ''\n\"LMDINIT LISTID(LISTID) LEVEL(\"Hlq\")\"\nDo Forever\n  \"LMDLIST LISTID(\"LISTID\") OPTION(LIST) DATASET(DSN)\"\n  If RC > 0 Then Leave\n  x=OutTrap('Idcams.')\n  Address TSO \"LISTC ENTRY('\"Dsn\"')\"\n  x=OutTrap('OFF')\n  Call ProcessIdcams\n\n  If Test = 'Y' Then Do\n    Count = Count + 1\n    If Count = 10 Then Do\n      Total = Total + Count\n      Count = 0\n      Say 'Scanned' Total 'datasets.'\n    End\n  End\n\nEnd\n\"LMDLIST LISTID(\"LISTID\") OPTION(FREE)\"\n\"LMDFREE LISTID(\"LISTID\")\"\n\nAddress TSO\n\nReturn\n/*--------------------------------------------------------------------*/\n/* Delete a dataset name.                                             */\n/*--------------------------------------------------------------------*/\nDelDsn:\n\nIf Symbol('DelDone.Dsn') = 'VAR' Then Return\nDelDone.Dsn = ''\n\nIf Test = 'Y' Then Do\n  Say \"DELETE '\"Dsn\"'\"\n  Return\nEnd\n\nx = Outtrap('Del.')\n\"DELETE '\"Dsn\"'\"\nIf RC <> 8 & RC > Retc Then Retc = RC\nx = Outtrap('OFF')\n\nDo iDel = 1 To Del.0; Say Del.iDel; End\nIf RC = 8 & Del.0 > 0 & Left(Del.1,9) = 'IKJ56232I' Then ,\n  \"DELETE '\"Dsn\"' NOSCRATCH\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUPMEM": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x001\\x01\\x04\\x11?\\x01\\x04\\x11\\x9f\\x15S\\x00\\xa5\\x01&\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2004-04-22T00:00:00", "modifydate": "2004-04-28T15:53:31", "lines": 165, "newlines": 294, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg DDName .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(-1);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(-1);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(-1);\nCleanup:\nReturn\n/*-------------------------------------------------------------------*/\n/*- The main exec routine.                                          -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nVolUnit = 'UNIT(3390) VOL(CHANGE)'\nVolUnit = ''\n\nHeader = Copies('*',72)\n\nx = Outtrap('Dsn.')\nSelect\n  When DDName = 'LINKLIST' Then \"%LISTLINK\"\n  When DDName = 'LPALIST'  Then \"%LISTLPA\"\n  Otherwise \"%LISTCNCT\" DDName\nEnd\nx = Outtrap('OFF')\n\nDo iDsn = 1 To Dsn.0\n  x = Outtrap('Mem.')\n  \"%LISTMEM '\"Dsn.iDsn\"'\"\n  x = Outtrap('OFF')\n  Do iMem = 1 To Mem.0\n    Parse Var Mem.iMem Mem Alias .\n    Mem = Translate(Mem,'?','{')\n    /* load Dsn.x.IEFBR14 with index */\n    Dsn.iDsn.Mem = iMem\n    /* load Dsn.x.y with IEFBR14 */\n    Dsn.iDsn.iMem = Mem Alias\n  End\n  Dsn.iDsn.0 = Mem.0\n  Dsn.iDsn.dbDel.0 = 0\nEnd\n\nSay Header\nSay '* The following' Dsn.0 ,\n  'datasets were found in concatenation' DDName':'\nSay Header\nDo iDsn = 1 To Dsn.0\n  Say Right(iDsn,4) Dsn.iDsn\nEnd\nSay Header\nSay\n\nSay Header\nSay '* The following duplicate members were found:'\nSay Header\nSay 'Member    Lib Dataset'\nDo iDsn = 1 To Dsn.0\n  Do iMem = 1 To Dsn.iDsn.0\n    Parse Var Dsn.iDsn.iMem Mem Alias .\n    If Mem = '$$$COIBM' Then Iterate\n    FoundSym = Symbol('FoundDup.Mem')\n    If FoundSym = 'BAD' Then Do\n      Say Left(Mem,8) Right(iDsn,4) Dsn.iDsn ,\n        'Must be checked manually.'\n      Iterate\n    End\n    If FoundSym = 'VAR' Then Iterate\n\n    Do jDsn = iDsn + 1 To Dsn.0\n      If Symbol('Dsn.'jDsn'.Mem') = 'LIT' Then Iterate\n      If FoundSym = 'LIT' Then Do\n        FoundDup.Mem = ''\n        FoundSym = 'VAR'\n        Rec = Left(Mem,8) Right(iDsn,4) Dsn.iDsn\n        Say Rec\n      End\n      Say Left(' ',8) Right(jDsn,4) Dsn.jDsn\n      iDel = Dsn.jDsn.dbDel.0 + 1\n      Dsn.jDsn.dbDel.0 = iDel\n      Dsn.jDsn.dbDel.iDel = Translate(Left(Mem,8),'{','?')\n      Dsn.jDsn.dbAlias.iDel = Alias\n      Dsn.jDsn.dbOrig.iDel = Dsn.iDsn\n    End\n  End\nEnd\nSay Header\nSay\n\n\nSay Header\nSay '* Summary of deletes:'\nSay Header\nRec = ' Lib Dataset'\nRec = Overlay(\"Deletes\",Rec,51)\nSay Rec\nDo iDsn = 1 To Dsn.0\n  If Dsn.iDsn.dbDel.0 = 0 Then Iterate\n  Rec = Right(iDsn,4) Dsn.iDsn\n  Rec = Overlay(Right(Dsn.iDsn.dbDel.0,4,' '),Rec,51)\n  Say Rec\nEnd\nSay Header\nSay\n\nSay Header\nSay '* Details of deletes:'\nSay Header\nDo iDsn = 2 To Dsn.0\n  Deletes = Dsn.iDsn.dbDel.0\n  If Deletes = 0 Then Iterate\n  Say ' ' Dsn.iDsn\", lib:\" iDsn\", deletions:\" Deletes\n  Say \"    Member   (Alias of) First library in concatenation\"\n  Queue \"LPDS '\"Dsn.iDsn\"'\"\n  Queue \"VERIFY : NOUPDATE\"\n  Do iDel = 1 To Deletes\n    Mem = Dsn.iDsn.dbDel.iDel\n    Alias = Dsn.iDsn.dbAlias.iDel\n    Rec = \"    \"Mem\n    If Alias <> '' Then\n      Rec = Overlay('('Alias')',Rec,14)\n    Rec = Overlay(Dsn.iDsn.dbOrig.iDel,Rec,25)\n    Say Rec\n    Queue 'DEL' Mem\n  End\n  Queue \"VERIFY : NOUPDATE\"\n  Queue 'END'\n  Queue ' '\n  Say\nEnd\nSay Header\nSay\n\nIf Queued() = 0 Then Do\n  Say 'Nothing to delete!'\n  Return\nEnd\n\nOutFile = \"'\"Sysvar(\"SYSUID\")\".DUPMEM.\"DDName\"'\"\nSay Header\nSay '* PDSMAN delete statements contained in' OutFile\nSay Header\nSay\n\nx = Msg('OFF')\n\"DELETE\" Outfile\nx = Msg(x)\n\n\"ALLOC F(OUT) DA(\"OutFile\") NEW CATALOG\" ,\n  \"LRECL(80) RECFM(F B) DSORG(PS) SPACE(1 1) TRACKS\" VolUnit\n\"EXECIO\" Queued() \"DISKW OUT (FINIS\"\n\"FREE F(OUT)\"\n\nIf Sysvar('SYSENV') = 'FORE' Then \"%FDSN\" OutFile\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EACHMEM": {"ttr": 19, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\'\\x000\\x01\\x00\"\\x1f\\x01\\x04\\x04\\x8f\\x16P\\x00Q\\x000\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.39", "flags": 0, "createdate": "2000-08-08T00:00:00", "modifydate": "2004-02-17T16:50:30", "lines": 81, "newlines": 48, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*-------------------------------------------------------------------*/\n/*- this exec will process each member of a pds and call the        -*/\n/*- passed rexx exec for each one. it's meant as a generalized      -*/\n/*- service to process all members of a pds. if runexec has parms   -*/\n/*- to pass, then pass the whole command in double quotes so i can  -*/\n/*- parse it out properly, eg:                                      -*/\n/*- %EACHMEM pds.dataset.name \"execname arg1 arg2\" 99               -*/\n/*- if you need to compress the lib every so often, pass the number -*/\n/*- of members to process between each compress in arg 'compress'.  -*/\n/*-------------------------------------------------------------------*/\nArg Dsn '\"' RunExec '\"' Compress .\nIf RunExec = '' Then Arg Dsn RunExec Compress .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall MainRoutine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nIf Sysvar('SYSISPF') = 'ACTIVE' Then Do\n  ZISPFRC = 12\n  Address ISPEXEC \"VPUT ZISPFRC SHARED\"\nEnd\nReturn\n/*-------------------------------------------------------------------*/\n/*- The main exec routine.                                          -*/\n/*-------------------------------------------------------------------*/\nMainRoutine:\n\nDsn = PrefDsn(Dsn)\n\n/* the number of members to process before compressing pds */\nIf Compress = '' Then Compress = 0\nIf Datatype(Compress) <> 'NUM' Then Do\n  Say 'Compress parm' Compress 'should be numeric!'\n  Say 'Defaulting to no compress.'\n  Compress = 0\nEnd\n\nx = Outtrap('Mem.')\n\"LISTD '\"Dsn\"' MEMBERS\"\nSaveRc = RC\nx = Outtrap('OFF')\nIf SaveRc > 0 Then Do\n  Say 'RC='SaveRC 'from LISTD command on dataset' Dsn\n  Signal Failure\nEnd\nDo iMem = 1 To Mem.0\n  If Mem.iMem = \"--MEMBERS--\" Then Leave\nEnd\n\nCount = 0\nDo iMem = iMem + 1 To Mem.0\n  Mem = Strip(Mem.iMem)\n  Say \"EACHMEM processing member\" Mem\n\n  DsnMem = \"'\"Dsn\"(\"Mem\")'\"\n\n  Signal OFF NOVALUE\n  Interpret 'Call' RunExec '\"'DsnMem'\"'\n  Signal ON NOVALUE\n\n  If Compress > 0 Then Count = Count + 1\n  If Count > Compress Then Do\n    Count = 0\n    \"%COMPRESS '\"Dsn\"'\"\n  End\nEnd\n\nIf Compress > 0 & Count > 0 Then \"%COMPRESS '\"Dsn\"'\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FC": {"ttr": 517, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x19\\x01\\x04\\x05\\x0f\\x01\\x04\\x05\\x1f\\x16!\\x00x\\x00w\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-02-19T00:00:00", "modifydate": "2004-02-20T16:21:19", "lines": 120, "newlines": 119, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Job Func\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nReturn\n/*-------------------------------------------------------------------*/\n/*- This exec will look for job documentation from the word pointed -*/\n/*- to by the cursor, or by the passed doc member.                  -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nParmlib = \"MA133.TSO.PARMLIB(FC)\"\n\nIf Length(Job) = 1 Then Do                  /* if job is one long    */\n  Func = Job                                /* assume it's the func  */\n  Job = ''\nEnd\n\nAddress ISPEXEC\nIf Job = '' Then Do                         /* user passed a job?    */\n  GETLINE = ''                              /* get cursor line.      */\n  \"VPUT GETLINE SHARED\"\n  \"SELECT CMD(%GETLINE)\"\n  \"VGET (CSR CSRP LINE SCRW PANEL) SHARED\"\n\n  Upper LINE\n  CmdPos = Pos('COMMAND',LINE)              /* cursor on cmd line?   */\n  If CmdPos = 0 | CmdPos > 3 Then Do\n    If Pos('//',LINE) > 0 & Pos(' JOB ',LINE) > 0 Then Do\n      Parse Var LINE '//' Job .             /* find the job          */\n      Job = Strip(Job)\n    End\n    Else Do\n      Do While CSRP > 1                     /* get the word from csr */\n        If Substr(Line,CSRP-1,1) = ' ' Then Leave\n        CSRP = CSRP - 1\n      End\n      Job = Word(Substr(Line,CSRP),1)\n      Job = Strip(Job,'L','/')              /* remove any slashes    */\n    End\n  End\nEnd\nAddress TSO\n\nIf Job = '' Then Do                         /* still can't find job? */\n  Say 'Enter the doc name you want to find...'\n  Pull Job\nEnd\nIf Job = '' Then Do                         /* give up.              */\n  Say 'Doc name is missing.'\n  Return\nEnd\n\n\"ALLOC F(IN) DA('\"Parmlib\"') SHR REUSE\"\n\"EXECIO * DISKR IN (STEM Dsn. FINIS\"\n\"FREE F(IN)\"\n\nSysname = Mvsvar('SYSNAME')\nEdit.0 = 0                                  /* add doc libs to search*/\nDo iDsn = 1 To Dsn.0\n  Dsn.iDsn = Strip(Dsn.iDsn)\n  Upper Dsn.iDsn\n  If Left(Dsn.iDsn,1) = '*' Then Iterate\n  Parse Var Dsn.iDsn Sys Dsn .\n  If Sys <> Sysname & Sys /= 'ALL' Then Iterate\n  Dsn = Strip(Dsn,\"B\",\"'\")\n  Call CheckDsn Dsn\nEnd\n\nIf Edit.0 = 0 Then Do\n  Say 'Doc' Job 'not found.'\n  Return\nEnd\n\nIf Edit.0 = 1 Then Do\n  Dsn = Edit.1 || \"(\" || Job || \")\"\n  Call FDSN \"'\"Dsn\"'\" Func\n  Return\nEnd\n\nSay Job 'was found in the following doc libraries...'\nDo iEdit = 1 To Edit.0\n  Say iEdit Edit.iEdit\nEnd\nSay 'Reply with a valid library number, or anything else to quit.'\nPull Reply\nReply = Strip(Reply)\nIf Datatype(Reply,'N') = 1 & Reply > 0 & Reply <= Edit.0 Then Do\n  Dsn = Edit.Reply || \"(\" || Job || \")\"\n  Call FDSN \"'\"Dsn\"'\" Func\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- check to see if the dsn exists and edit it                      -*/\n/*-------------------------------------------------------------------*/\nCheckDsn:\n\nArg Dsn\nCheckDsn = \"'\" || Dsn || \"(\" || Job || \")'\"\nIf SYSDSN(CheckDsn) <> 'OK' Then Return\niEdit = Edit.0\niEdit = iEdit + 1\nEdit.iEdit = Dsn\nEdit.0 = iEdit\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FD": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00U\\x01\\x04\\x04O\\x01\\x04\\x05_\\x139\\x00T\\x00Q\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-02-13T00:00:00", "modifydate": "2004-02-24T13:39:55", "lines": 84, "newlines": 81, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Dsn Func .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nReturn\n/*-------------------------------------------------------------------*/\n/*- This will find a dataset name from an edit session or any ispf  -*/\n/*- screen and perform the specified action on it.                  -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nAddress ISPEXEC\n\nEdit = 'Y'\n\"ISREDIT MACRO (DSN,FUNC)\"\nIf RC <> 0 Then Edit = 'N'\n\nIf Length(Dsn) = 1 Then Do\n  Func = Dsn\n  Dsn = ''\nEnd\nDsn = Prefdsn(Dsn)\n\nIf Dsn = '' & Edit = 'Y' Then Do\n  \"ISREDIT ZOOM\" Func\n  Exit RC\nEnd\n\nIf Dsn = '' Then Do          /* was the dsn passed? */\n  GETLINE = ''\n  \"VPUT GETLINE SHARED\"\n  \"SELECT CMD(%GETLINE)\"\n  \"VGET (CSR CSRP LINE SCRW PANEL) SHARED\"\n  Upper LINE\n\n  CmdPos = Pos('COMMAND',LINE)\n  If CmdPos = 0 | CmdPos > 3 Then Do\n    If Pos('DSNAME=',LINE) > 0 Then CSRP = Pos('DSNAME=',LINE) + 7\n    Else If Pos('DSN=',LINE) > 0 Then CSRP = Pos('DSN=',LINE) + 4\n\n    Valid = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$0123456789.-+()\"\n    Len = Length(LINE)\n    Beg = Verify(Reverse(LINE),Valid,\"N\",(Len - CSRP + 1))\n    If Beg = 0 Then Beg = 1\n    Else Beg = Len - Beg + 2\n    End = Verify(LINE,Valid,\"N\",CSRP)\n    If End = 0 Then End = Len + 1\n    Dsn = Substr(LINE,Beg,Abs(End-Beg))\n\n    If Right(Dsn,2) = '))' Then Dsn = Left(Dsn,Length(Dsn)-1)\n    If Left(Dsn,1) = '(' Then Dsn = Substr(Dsn,2)\n    If Right(Dsn,1) = ')' & Pos('(',Dsn) = 0 Then\n      Dsn = Left(Dsn,Length(Dsn)-1)\n  End\nEnd\n\nIf Dsn = '' Then Do\n  Say 'Enter the dataset name you want to use...'\n  Pull Dsn\n  Dsn = Prefdsn(Dsn)\nEnd\nIf Dsn = '' Then Do\n  Say 'Dataset name is missing.'\n  Return\nEnd\n\nIf Left(Dsn,1) <> \"'\" Then Dsn = \"'\"Dsn\"'\"\n\nCall FDSN Dsn Func\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FDSN": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x11\\x01\\x04\\x04O\\x01\\x04\\t\\x9f\\x16\\x07\\x01\\x1c\\x01\\r\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2004-02-13T00:00:00", "modifydate": "2004-04-08T16:07:11", "lines": 284, "newlines": 269, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Dsn Func .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturnCode = 0\nCall Main_Routine\n\nReturn ReturnCode\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nReturn\n/*-------------------------------------------------------------------*/\n/*- This exec works in conjunction with the FP, FJ, FC, FD, and ZOOM-*/\n/*- execs. a one char action code is passed with a dataset name, and-*/\n/*- the dataset is acted on by the function passed.                 -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nIf Dsn = '' Then Do\n  ReturnCode = 4\n  Return                          /* was the dsn passed? */\nEnd\n\nAddress ISPEXEC\n\"VGET ZAPPLID\"                    /*   Get current application ID */\nIf ZAPPLID \\= 'ISR' Then Do       /*   If ZAPPLID\\=ISR, re-invoke */\n  \"SELECT CMD(%FDSN\" Dsn Func\") NEWAPPL(ISR)\"\n  Exit RC                         /*   with NEWAPPL(ISR) so that  */\nEnd                               /*   pfkeys will be predictable */\n\nDsn = Prefdsn(Dsn)\n\n/* convert a gdg to the real name */\nParse Var Dsn '(' Gen ')'\nIf Datatype(Gen) = 'NUM' Then Do\n  Dsn = GdgRel(\"'\"Dsn\"'\")\n  If Dsn = '' Then Signal Failure\nEnd\n\n/* see if the user set a default action */\nFromProfile = 0\nIf Func = '' Then Do\n  \"VGET FDSNDEF PROFILE\"\n  If Rc = 0 Then Do\n    FromProfile = 1\n    Func = FDSNDEF\n  End\nEnd\n/* nope, default it to view the dataset */\nIf Func = '' Then Func = 'V'\n\nUpper Func                        /* translate the func to an action*/\nFunc = Left(Func,1)\nSelect\n  When Func = 'E' Then Func = 'Edit'\n  When Func = 'V' Then Func = 'View'\n  When Func = 'B' Then Func = 'Browse'\n  When Func = 'D' Then Func = 'Delete'\n  When Func = 'L' Then Func = 'Listcat'\n  When Func = 'X' Then Func = 'Level'\n  When Func = 'M' Then Func = 'Memlist'\n  When Func = 'P' Then Func = 'Pds'\n  When Func = 'Z' Then Func = 'Save'\n  When Func = 'C' Then Func = 'Command'\n  Otherwise Do\n    Say 'Function code' Func 'unknown...valid codes are:'\n    Say 'E for Edit'\n    Say 'V for View'\n    Say 'B for Browse'\n    Say 'D for Delete'\n    Say 'L for Listcat'\n    Say 'X for listcat level'\n    Say 'M for Member list (PDSs only)'\n    Say 'P for Pds-man (PDSs only)'\n    Say 'Z for Save a backup of a PDS with .SAVE on the end'\n    Say 'C to run a custom command (see FDCMD for more)'\n    If FromProfile Then Do\n      Say 'Removing default action' Func 'from ISPF profile.'\n      Say 'Run FDSNDEF again to reset.'\n      \"VERASE FDSNDEF PROFILE\"\n    End\n    Return\n  End\nEnd\n\n\"CONTROL ERRORS RETURN\"\nInterpret \"Call\" Func             /* call the appropriate routine */\n\"CONTROL ERRORS CANCEL\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Create a member list for the dataset.                           -*/\n/*-------------------------------------------------------------------*/\nMemlist:\n\nBracket = Pos('(',Dsn)\nIf Bracket > 0 Then Do\n  Dsn = Left(Dsn,Bracket-1)\nEnd\n\n\"LMINIT DATAID(DATAID) DATASET('\"Dsn\"')\"\nIf RC = 0 Then Do\n  \"MEMLIST DATAID(\"DATAID\")\"\n  ReturnCode = RC\n  Select\n    When RC =  8 Then Say Dsn \"- NO MEMBERS IN LIBRARY\"\n    When RC = 12 Then Say Dsn \"- NOT A PARTITIONED DATASET\"\n    When RC = 16 Then Say Dsn \"- DIALOG ERROR\"\n    When RC = 20 Then Say Dsn \"- SEVERE ERROR\"\n    Otherwise Nop\n  End\n  \"LMFREE DATAID(\"DATAID\")\"\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- View the dataset (default).                                     -*/\n/*-------------------------------------------------------------------*/\nView:\n\n\"VGET FDSNMAC SHARED\"\nIf RC = 0 & FDSNMAC <> '' Then Do\n  \"VIEW DATASET('\"Dsn\"') MACRO(\"FDSNMAC\")\"\n  ReturnCode = RC\n  \"VERASE FDSNMAC SHARED\"\nEnd\nElse Do\n  \"VIEW DATASET('\"Dsn\"')\"\n  ReturnCode = RC\nEnd\nSelect\n  When ReturnCode = 14 Then Say Dsn \"- DATA SET OR MEMBER IN USE\"\n  When ReturnCode = 16 Then Say Dsn \"- NO MEMBERS IN LIBRARY\"\n  When ReturnCode = 20 Then Call Browse\n  Otherwise Nop\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Edit the dataset.                                               -*/\n/*-------------------------------------------------------------------*/\nEdit:\n\n\"VGET FDSNMAC SHARED\"\nIf RC = 0 & FDSNMAC <> '' Then Do\n  \"EDIT DATASET('\"Dsn\"') MACRO(\"FDSNMAC\")\"\n  ReturnCode = RC\n  \"VERASE FDSNMAC SHARED\"\nEnd\nElse Do\n  \"EDIT DATASET('\"Dsn\"')\"\n  ReturnCode = RC\nEnd\nSelect\n  When ReturnCode = 14 Then Say Dsn \"- DATA SET OR MEMBER IN USE\"\n  When ReturnCode = 16 Then Say Dsn \"- NO MEMBERS IN LIBRARY\"\n  When ReturnCode = 20 Then Call Browse\n  Otherwise Nop\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Browse the dataset.                                             -*/\n/*-------------------------------------------------------------------*/\nBrowse:\n\n\"BROWSE DATASET('\"Dsn\"')\"\nReturnCode = RC\nSelect\n  When RC = 12 Then Say Dsn \"- ZERO LENGTH DATA\"\n  When RC = 14 Then Say Dsn \"- MEMBER NOT FOUND\"\n  When RC = 16 Then Say Dsn \"- NO MEMBERS IN LIBRARY\"\n  When RC = 20 Then Say Dsn \"- SEVERE ERROR\"\n  Otherwise Nop\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Do a listcat.                                                   -*/\n/*-------------------------------------------------------------------*/\nListcat:\n\nBracket = Pos('(',Dsn)\nIf Bracket > 0 Then Dsn = Left(Dsn,Bracket-1)\nAddress TSO \"LISTCAT ENTRY('\"Dsn\"') ALL\"\nReturnCode = RC\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Do a listcat level.                                             -*/\n/*-------------------------------------------------------------------*/\nLevel:\n\nBracket = Pos('(',Dsn)\nIf Bracket > 0 Then Dsn = Left(Dsn,Bracket-1)\n\nAddress TSO \"LISTCAT ENTRY('\"Dsn\"') ALL\"\nDsnR = Reverse(Dsn)\nParse Var DsnR LastQual '.'\nParse Var LastQual Ver 'V' Gen 'G'\nIf Datatype(Gen) = 'NUM' & Datatype(Ver) = 'NUM' & ,\n  Length(Gen) = 4 & Length(Ver) = 2 Then\n  Dsn = Left(Dsn,Length(Dsn)-9)\nAddress TSO \"LISTCAT LEVEL(\"Dsn\") ALL\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Run pdsman.                                                     -*/\n/*-------------------------------------------------------------------*/\nPds:\n\nBracket = Pos('(',Dsn)\nIf Bracket > 0 Then Dsn = Left(Dsn,Bracket-1)\n\n\"SELECT CMD(LPDS '\"Dsn\"')\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Run delete the dataset.                                         -*/\n/*-------------------------------------------------------------------*/\nDelete:\n\nBracket = Pos('(',Dsn)\nIf Bracket > 0 Then Dsn = Left(Dsn,Bracket-1)\n\nSay \"Do you really want to delete '\"Dsn\"'? (Y or N)\"\nPull Reply\nIf Left(Reply,1) = 'Y' Then ,\n  Address TSO \"DELETE '\"Dsn\"'\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Run a custom command against the dataset                        -*/\n/*-------------------------------------------------------------------*/\nCommand:\n\n\"VGET FDCMD PROFILE\"\nIf RC > 0 Then Do\n  Say 'Custom command not found - run FDCMD first.'\n  Return\nEnd\n\nPrompt = 0\nIf Word(FDCMD,1) = 'PROMPT' Then Do\n  Prompt = 1\n  FDCMD = Delword(FDCMD,1,1)\nEnd\n\nAddr = Word(FDCMD,1)\nFDCMD = Delword(FDCMD,1,1)\n\nDo While Pos('/',FDCMD) > 0\n  Parse Var FDCMD First '/' Last\n  FDCMD = Strip(First) \"'\"Dsn\"'\" Strip(Last)\nEnd\n\nIf Prompt Then Do\n  Say 'Run command \"'FDCMD'\"? (Y or N)'\n  Pull Answer\n  If Answer <> 'Y' Then Do\n    Say 'Command not run.'\n    Return\n  End\nEnd\n\nAddress Value Addr\nFDCMD\nIf RC > 0 Then Say 'Return code =' RC\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Save the library                                                -*/\n/*-------------------------------------------------------------------*/\nSave:\nCall SAVELIB \"'\"Dsn\"'\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FDSNCMD": {"ttr": 21, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00P\\x01\\x02\\x13o\\x01\\x04\\x04o\\x11Q\\x00\\x16\\x00\\x05\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-05-16T00:00:00", "modifydate": "2004-02-15T11:51:50", "lines": 22, "newlines": 5, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*********************************************************************/\n/* this clist works in conjunction with the FDSN clist to run a      */\n/* custom command against a dataset found anywhere on the screen.    */\n/* you set up the command here, then issue the 'fd c' command and    */\n/* point your cursor to the dataset. if you prefix your command with */\n/* 'prompt', you will be prompted before the command is actually run.*/\n/* in the next word, place the environment you want to address such  */\n/* as tso or ispexec or any other valid rexx environ. follow this    */\n/* with the command, placing a '/' in the position(s) you want the   */\n/* dataset name to appear (ah la 3.4). for example:                  */\n/* FDCMD PROMPT TSO ALTER / MGMTCLAS(MCTESTA)                        */\n/* will prompt you before executing the command (so you can check to */\n/* see that it's correct first), will address TSO, then issue the    */\n/* alter idcams command.                                             */\n/* this is useful if you have a bunch of datasets in a report that   */\n/* you want to do the same command to over and over (set a pfkey)    */\n/*********************************************************************/\nArg FDCMD\nAddress ISPEXEC\n\"VPUT FDCMD PROFILE\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FDSNDEF": {"ttr": 23, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x04\\x05\\x0f\\x01\\x04\\x05\\x0f\\x12D\\x00 \\x00 \\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-19T00:00:00", "modifydate": "2004-02-19T12:44:33", "lines": 32, "newlines": 32, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*********************************************************************/\n/* works with the FDSN exec to establish a default action. this is   */\n/* so you won't have to specify the same action command every time   */\n/* you run FDSN. optionally specify a one-time edit macro to run     */\n/* when asking for edit/view. this is intended more for programmatic */\n/* calls to run a macro for each member of a pds. the macro is not   */\n/* saved permanently and only runs once so that you won't run it by  */\n/* accident and screw up an important dataset.                       */\n/*********************************************************************/\nArg FDSNDEF FDSNMAC .\n\nIf Sysvar('SYSISPF') <> 'ACTIVE' Then Do\n  Say 'ISPF is not active for FDSN'\n  Return\nEnd\n\nAddress ISPEXEC\n\"VGET ZAPPLID\"                      /*   Get current application ID */\nIf ZAPPLID \\= 'ISR' Then Do         /*   If ZAPPLID\\=ISR, re-invoke */\n  \"SELECT CMD(%FDSNDEF\" FDSNDEF FDSNMAC\") NEWAPPL(ISR)\"\n  Exit RC                           /*   with NEWAPPL(ISR) so that  */\nEnd                                 /*   pfkeys will be predictable */\n\nAddress ISPEXEC\nIf FDSNDEF = '' Then \"VERASE FDSNDEF PROFILE\"\nElse \"VPUT FDSNDEF PROFILE\"\n\nIf FDSNMAC = '' Then \"VERASE FDSNMAC SHARED\"\nElse \"VPUT FDSNMAC SHARED\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FJ": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00 \\x01\\x04\\x05\\x0f\\x01\\x04\\x05\\x1f\\x16!\\x00\\x82\\x00\\x80\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-02-19T00:00:00", "modifydate": "2004-02-20T16:21:20", "lines": 130, "newlines": 128, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Job Func .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nReturn\n/*-------------------------------------------------------------------*/\n/*- This will find a job in the production jcl libraries.           -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nParmlib = \"MA133.TSO.PARMLIB(FJ)\"\n\nAddress ISPEXEC\n\"VERASE FJJOB SHARED\"\n\nIf Length(Job) = 1 Then Do\n  Func = Job\n  Job = ''\nEnd\n\nIf Job = '' Then Do\n  GETLINE = ''\n  \"VPUT GETLINE SHARED\"\n  \"SELECT CMD(%GETLINE)\"\n  \"VGET (CSR CSRP LINE SCRW PANEL) SHARED\"\n  UpperLine = Line\n  Upper UpperLine\n  CmdPos = Pos('COMMAND',UpperLine)\n  If CmdPos = 0 | CmdPos > 3 Then Do\n    If Pos('//',UpperLine) > 0 & Pos(' JOB ',UpperLine) > 0 Then Do\n      Parse Var UpperLine '//' Job .\n      Job = Strip(Job)\n    End\n    Else Do\n      Do While CSRP > 1\n        If Substr(Line,CSRP-1,1) = ' ' Then Leave\n        CSRP = CSRP - 1\n      End\n      Job = Word(Substr(Line,CSRP),1)\n      Job = Strip(Job,'L','/')\n    End\n  End\nEnd\n\nIf Job = '' Then Do\n  Say 'Enter the job name you want to find...'\n  Pull Job\nEnd\nIf Job = '' Then Do\n  Say 'Job name is missing.'\n  Return\nEnd\n\nAddress TSO\n\"ALLOC F(IN) DA('\"Parmlib\"') SHR REUSE\"\n\"EXECIO * DISKR IN (STEM Dsn. FINIS\"\n\"FREE F(IN)\"\nAddress ISPEXEC\n\nSysname = Mvsvar('SYSNAME')\nEdit.0 = 0                                  /* add doc libs to search*/\nDo iDsn = 1 To Dsn.0\n  Dsn.iDsn = Strip(Dsn.iDsn)\n  Upper Dsn.iDsn\n  If Left(Dsn.iDsn,1) = '*' Then Iterate\n  Parse Var Dsn.iDsn Sys Dsn .\n  If Sys <> Sysname & Sys /= 'ALL' Then Iterate\n  Dsn = Strip(Dsn,\"B\",\"'\")\n  Call CheckDsn Dsn\nEnd\n\nIf Edit.0 = 0 Then Do\n  Say 'Job' Job 'not found.'\n  Return\nEnd\n\nIf Edit.0 = 1 Then Do\n  Dsn = Edit.1 || \"(\" || Job || \")\"\n  If Func = 'G' Then Do\n    FJJOB = Dsn\n    \"VPUT FJJOB SHARED\"\n  End\n  Else Call FDSN \"'\"Dsn\"'\" Func\n  Return\nEnd\n\nSay Job 'was found in the following job libraries...'\nDo iEdit = 1 To Edit.0\n  Say iEdit Edit.iEdit\nEnd\nSay 'Reply with a valid library number, or anything else to quit.'\nPull Reply\nReply = Strip(Reply)\nIf Datatype(Reply,'N') = 1 & Reply > 0 & Reply <= Edit.0 Then Do\n  Dsn = Edit.Reply || \"(\" || Job || \")\"\n  If Func = 'G' Then Do\n    FJJOB = Dsn\n    \"VPUT FJJOB SHARED\"\n  End\n  Else Call FDSN \"'\"Dsn\"'\" Func\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- check to see if the dsn exists and edit it                      -*/\n/*-------------------------------------------------------------------*/\nCheckDsn:\n\nArg Dsn\nCheckDsn = \"'\" || Dsn || \"(\" || Job || \")'\"\nIf SYSDSN(CheckDsn) <> 'OK' Then Return\niEdit = Edit.0\niEdit = iEdit + 1\nEdit.iEdit = Dsn\nEdit.0 = iEdit\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FP": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x001\\x01\\x04\\x05\\x0f\\x01\\x04\\x05_\\x16@\\x01Y\\x01/\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2004-02-19T00:00:00", "modifydate": "2004-02-24T16:40:31", "lines": 345, "newlines": 303, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Proc Func .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturnCode = 0\nCall Main_Routine\n\nReturn ReturnCode\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nParse Source . . Exec .\nSay 'In exec' Exec\nReturn\n/*-------------------------------------------------------------------*/\n/*- This exec will find a proc to view. If invoked as an edit       -*/\n/*- macro, it will search any jcllib/proclib statements. if invoked -*/\n/*- outside edit, it will search only the system libs.              -*/\n/*- to communicate programatically these ispf vars are used:        -*/\n/*-   FPDSN the dataset that the proc was found in.                 -*/\n/*-   FPNEST set to 'Y' to use the proc list built previously.      -*/\n/*-   FPNEST0 the number of procs in FPNESTn.                       -*/\n/*-   FPNEST1-n the procs that were previously found.               -*/\n/*- this will allow a previously resolved jcllib concat sequence to -*/\n/*- be used to resolve nested procs and include members.            -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nParmlib = \"MA133.TSO.PARMLIB(FP)\"\n\nAddress ISPEXEC\nEdit = 'Y'                               /* see if we are editing   */\n\"ISREDIT MACRO (PROC,FUNC)\"\nIf RC = 20 Then Edit = 'N'\n\nIf Length(Proc) = 1 Then Do              /* if we passed a one char */\n  Func = Proc                            /* dsn, assume it's really */\n  Proc = ''                              /* the function.           */\nEnd\n\nProclib.0 = 0\n/* so what's the user pointing to anyway?? */\nUpper Proc\nIf Proc = '' Then Do                     /* was the proc passed?     */\n  If Edit = 'Y' Then Call Get_From_Edit\n  Else Call Get_From_Screen\nEnd\n\nIf Proc = '' Then Do                     /* still don't have a proc? */\n  Say 'Enter the proc name you want to find...'\n  Pull Proc\nEnd\nIf Proc = '' Then Do                     /* may as well give up.     */\n  ReturnCode = 4\n  Say 'Proc name is missing.'\n  Return\nEnd\n\nCall Create_Proclib_List\n\nDo iProclib = 1 To Proclib.0             /* now find the first in the*/\n  Dsn = \"'\"Proclib.iProclib\"(\"Proc\")'\"   /* search sequence          */\n  If Sysdsn(Dsn) = 'OK' Then Do\n    FPDSN = Dsn                          /* save it for calling guy  */\n    \"VPUT FPDSN SHARED\"\n    Call FDSN Dsn Func                   /* go func it               */\n    ReturnCode = RC\n    Return\n  End\nEnd\n\nReturnCode = 4\nSay 'Proc' Proc 'not found.'\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- create the list of proclibs to be used.                         -*/\n/*-------------------------------------------------------------------*/\nCreate_Proclib_List:\n\nUseNestedProcs = 'N'                     /* create list of proclibs  */\n\"VGET FPNEST SHARED\"\nIf RC = 0 & FPNEST = 'Y' Then Do         /* load from nested FP cmd  */\n  \"VGET FPNEST0 SHARED\"                  /* if this if the first time*/\n  If RC = 0 Then Do                      /* fpnest won't be inited   */\n    UseNestedProcs = 'Y'\n    Do iProclib = 0 To FPNEST0\n      \"VGET FPNEST\"iProclib \"SHARED\"\n      Proclib.iProclib = Value('FPNEST'iProclib)\n    End\n    Proclib.0 = FPNEST0\n  End\nEnd\n\nIf UseNestedProcs = 'N' Then Do          /* if we're not nested      */\n  If Edit = 'Y' Then Call Load_Proclibs  /* go find jcllib stuff     */\n  Call Add_Sys_Proclibs                  /* add the system proclibs  */\n  \"VGET FPNEST SHARED\"                   /* load to ispfvars         */\n  If RC = 0 & FPNEST = 'Y' Then Do\n    Do iProclib = 0 To Proclib.0\n      Interpret \"FPNEST\"iProclib \"=\" Proclib.iProclib\n      \"VPUT FPNEST\"iProclib \"SHARED\"\n    End\n    FPNEST0 = Proclib.0\n    \"VPUT FPNEST0 SHARED\"\n  End\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- We don't have a proc passed, and we aren't in edit. try to find -*/\n/*- the proc from the line the cursor is on the screen.             -*/\n/*-------------------------------------------------------------------*/\nGet_From_Screen:\n\nGETLINE = ''\n\"VPUT GETLINE SHARED\"\n\"SELECT CMD(%GETLINE)\"\n\"VGET (CSR CSRP LINE SCRW PANEL) SHARED\"\nUpper LINE\n\nCmdPos = Pos('COMMAND',LINE)               /* is cursor on cmd line? */\nIf CmdPos = 0 | CmdPos > 3 Then Call Parse_Out_Proc\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- We're in edit, so it's easier to get the line from edit cmds.   -*/\n/*-------------------------------------------------------------------*/\nGet_From_Edit:\n\nAddress ISREDIT\n\"(ROW,CSRP) = CURSOR\"\nIf ROW > 0 Then Do\n  \"(LINE) = LINE\" ROW\n  Call Parse_Out_Proc\nEnd\nAddress ISPEXEC\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Find the proc name from the line on the screen.                 -*/\n/*-------------------------------------------------------------------*/\nParse_Out_Proc:\n\nSelect\n  When Word(LINE,2) = 'EXEC' Then Do   /* do we have an exec?    */\n    Parse Var LINE ' EXEC ' Proc .\n    Parse Var Proc Proc ','\n    If Left(Proc,5) = 'PROC=' Then Parse Var Proc 'PROC=' Proc\n  End\n  When Word(LINE,2) = 'INCLUDE' & ,\n    Left(Word(LINE,3),7) = 'MEMBER=' Then Do\n    Parse Var LINE 'MEMBER=' Proc .\n  End\n  When Pos('WAS EXPANDED USING',LINE) > 0 Then Do\n    Parse Var LINE Proc 'WAS EXPANDED USING' ,\n      . 'LIBRARY' Proclib .\n    Proc = Word(Proc,Words(Proc))\n    Proc = Strip(Proc)\n    Call Add_Proclib Proclib\n  End\n  Otherwise Do\n    Do While CSRP > 1\n      If Substr(LINE,CSRP-1,1) = ' ' Then Leave\n      CSRP = CSRP - 1\n    End\n    Proc = Word(Substr(LINE,CSRP),1)\n    Proc = Strip(Proc,'L','/')\n\n    Valid = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$0123456789\"\n    Len = Length(LINE)\n    Beg = Verify(Reverse(LINE),Valid,\"N\",(Len - CSRP + 1))\n    If Beg = 0 Then Beg = 1; Else Beg = Len - Beg + 2\n    End = Verify(LINE,Valid,\"N\",CSRP); If End = 0 Then End = Len + 1\n    Proc = Substr(LINE,Beg,Abs(End-Beg))\n  End\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Put any user proclibs in the search order.                      -*/\n/*-------------------------------------------------------------------*/\nLoad_Proclibs:\n\nAddress ISREDIT\n\"(LAST) = LINENUM .ZLAST\"\nDo iLine = 1 To LAST\n  \"(JCL) = LINE\" iLine\n  JCL = Left(JCL,72)\n  Select\n    /* if it's a comment                 */\n    When Left(JCL,3) = '//*' Then Nop\n\n    /* see if there's a jcllib statement */\n    When Pos(' JCLLIB ',JCL) > 0 Then Call Process_Jcllib\n\n    /* see if there's a proclib statement */\n    When Word(JCL,1) = '//PROCLIB' Then Call Process_Easyproc\n\n    /* end if there's proc call statement */\n    When Word(JCL,2) = 'EXEC' Then Leave iLine\n\n    Otherwise Nop\n  End\nEnd\nAddress ISPEXEC\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Found a JCLLIB statement. Parse it out.                         -*/\n/*-------------------------------------------------------------------*/\nProcess_Jcllib:\n\nParse Var Jcl 'ORDER=' Proclibs .\nProclibs = Word(Proclibs,1)\nProclibs = Strip(Proclibs,'L','(')\nProclibs = Strip(Proclibs,'T',')')            /* strip last ) */\n\nDo While Pos(',',Proclibs) > 0\n  Parse Var Proclibs Proclib ',' Proclibs\n  Do While Proclib <> ''\n    Call Add_Proclib Proclib\n    Parse Var Proclibs Proclib ',' Proclibs\n  End\n  iLine = iLine + 1\n  \"(JCL) = LINE\" iLine\n  Parse Var JCL . Proclibs ')'                /* strip last ) */\n  Proclibs = Word(Proclibs,1)\nEnd\n\nCall Add_Proclib Proclibs    /* there should only be one here */\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Found a PROCLIB statement. Parse it out.                        -*/\n/*-------------------------------------------------------------------*/\nProcess_Easyproc:                          /* does not support  */\n                                           /* split lines!!!    */\nParse Var JCL 'DSN=' Proclib ','           /* get the first one */\nIf Proclib = '' Then Parse Var JCL 'DSNAME=' Proclib ','\nIf Proclib = '' Then Do\n  Say 'Unable to pull proclib from:'\n  Say JCL\n  Signal Failure\nEnd\n\nProclib = Word(Proclib,1)\nCall Add_Proclib Proclib\nDo iLine = iLine + 1 To LAST\n  \"(JCL) = LINE\" iLine\n  If Substr(JCL,1,3) = '//*' Then Iterate  /* skip comment*/\n  If Substr(JCL,1,3) <> '// ' Then Do      /* no others */\n    iLine = iLine - 1\n    Leave\n  End\n  Parse Var JCL 'DSN=' Proclib ',' .\n  If Proclib = '' Then Parse Var JCL 'DSNAME=' Proclib ','\n  Proclib = Word(Proclib,1)\n  Call Add_Proclib Proclib\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Add a proclib to the search list.                               -*/\n/*-------------------------------------------------------------------*/\nAdd_Proclib:\nArg Proclib .\nProclib = Strip(Proclib)\n\n/* if this is a symbolic, resolve it before adding it. this is used */\n/* when the proclib/jcllib has a symbolic set using the SET jcl stmt*/\n/* this won't work if you have a set statement that sets the same   */\n/* symbol twice. this will pick up the first one, but the jcl will  */\n/* use the last one.                                                */\nIf Edit = 'Y' Then Do\n  Address ISREDIT\n  \"(STATE) = USER_STATE\"            /* save what the user was doing */\n  \"RESET EXCLUDED\"                  /* reset the environ for me     */\n  Do While Pos('&',Proclib) > 0\n    Parse Var Proclib Prefix '&' Symbol '.' Suffix\n    \"EXCLUDE ALL\"\n    \"FIND '\"Symbol\"=' ALL\"          /* find any lines with symbol=  */\n    \"EXCLUDE '//*' 1 ALL\"           /* get rid of any comment lines */\n    \"CURSOR = 1 1\"\n    Do Forever\n      \"FIND '\"Symbol\"=' NEXT NX\"    /* look for //x set symbol=yyy  */\n      If RC > 0 Then Do\n        Say 'Unable to resolve symbolic variable' Symbol ,\n          'in proclib' Proclib\n        Proclib = ''\n        Leave\n      End\n      \"(SET) = LINE .ZCSR\"\n      Parse Var SET . 'SET' Operand .    /* make sure we have set   */\n      Parse Var Operand (Symbol) '=' Value\n      If Value = '' Then Iterate\n      Proclib = Prefix || Value || Suffix\n      Leave\n    End\n    \"RESET EXCLUDED FIND\"\n  End\n  \"USER_STATE = (STATE)\"\nEnd\nIf Proclib = '' Then Return\n\nDo x = 1 To Proclib.0\n  If Proclib = Proclib.x Then Return\nEnd\niProclib = Proclib.0\niProclib = iProclib + 1\nProclib.iProclib = Proclib\nProclib.0 = iProclib\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Add system proclibs to the search list.                         -*/\n/*-------------------------------------------------------------------*/\nAdd_Sys_Proclibs:\n\nAddress TSO\n\"ALLOC F(IN) DA('\"Parmlib\"') SHR REUSE\"\n\"EXECIO * DISKR IN (STEM Dsn. FINIS\"\n\"FREE F(IN)\"\nAddress ISPEXEC\n\nSysname = Mvsvar('SYSNAME')\nEdit.0 = 0                                  /* add doc libs to search*/\nDo iDsn = 1 To Dsn.0\n  Dsn.iDsn = Strip(Dsn.iDsn)\n  Upper Dsn.iDsn\n  If Left(Dsn.iDsn,1) = '*' Then Iterate\n  Parse Var Dsn.iDsn Sys Dsn .\n  If Sys <> Sysname & Sys /= 'ALL' Then Iterate\n  Dsn = Strip(Dsn,\"B\",\"'\")\n  Call Add_Proclib Dsn\nEnd\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FR": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00C\\x01\\x02\\x18o\\x01\\x04\\t/\\x12!\\x00\\x9e\\x00x\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2002-07-05T00:00:00", "modifydate": "2004-04-01T12:21:43", "lines": 158, "newlines": 120, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Rexx Func .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nReturn\n/*-------------------------------------------------------------------*/\n/*- This will find a Rexx in the sysproc/sysexec allocated libs.    -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nIf Length(Rexx) = 1 Then Do\n  Func = Rexx\n  Rexx = ''\nEnd\n\n/* if the rexx was not passed get it from the cursor */\nIf Rexx = '' Then Do\n  Address ISPEXEC\n  GETLINE = ''\n  \"VPUT GETLINE SHARED\"\n  \"SELECT CMD(%GETLINE)\"\n  \"VGET (CSR CSRP LINE SCRW PANEL) SHARED\"\n  UpperLine = Line\n  Upper UpperLine\n  CmdPos = Pos('COMMAND',UpperLine)\n  If CmdPos = 0 | CmdPos > 3 Then Do\n    Do While CSRP > 1\n      If Substr(Line,CSRP-1,1) = ' ' Then Leave\n      CSRP = CSRP - 1\n    End\n    Rexx = Word(Substr(Line,CSRP),1)\n  End\n  Address TSO\nEnd\nRexx = Translate(Rexx,,'%\"()')\nRexx = Translate(Rexx,,\"'\")\nRexx = Strip(Rexx)\n\n/* still can't find it, ask the user to supply one */\nIf Rexx = '' Then Do\n  Say 'Enter the Rexx/Clist name you want to find...'\n  Pull Rexx\nEnd\nIf Rexx = '' Then Do\n  Say 'Rexx/Clist name is missing.'\n  Return\nEnd\n\n/* get a list of possible libs to edit */\nEdit.0 = 0\nCall LoadConcat\nIf Edit.0 = 0 Then Do\n  Say 'Rexx/Clist' Rexx 'not found.'\n  Return\nEnd\n\n/* if we found only one lib, go func it */\nIf Edit.0 = 1 Then Do\n  Dsn = Word(Edit.1,1) || \"(\" || Rexx || \")\"\n  Call FDSN \"'\"Dsn\"'\" Func\n  Return\nEnd\n\n/* let the user choose which one to edit */\nSay Rexx 'was found in the following Rexx/Clist libraries...'\nDo iEdit = 1 To Edit.0\n  Say iEdit Edit.iEdit\nEnd\nSay 'Reply with a valid library number, or anything else to quit.'\nPull Reply\nReply = Strip(Reply)\nIf Datatype(Reply,'N') = 1 & Reply > 0 & Reply <= Edit.0 Then Do\n  Dsn = Word(Edit.Reply,1) || \"(\" || Rexx || \")\"\n  Call FDSN \"'\"Dsn\"'\" Func\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- check to see if the dsn(member) exists and add it to our list   -*/\n/*-------------------------------------------------------------------*/\nCheckDsn:\n\nArg Dsn DD .\nCheckDsn = \"'\" || Dsn || \"(\" || Rexx || \")'\"\nIf SYSDSN(CheckDsn) <> 'OK' Then Return\niEdit = Edit.0\niEdit = iEdit + 1\nEdit.iEdit = Overlay(DD,Dsn,50)\nEdit.0 = iEdit\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- go thru the sysproc/sysexec concatenations                      -*/\n/*-------------------------------------------------------------------*/\nLoadConcat:\n\nx = Outtrap('Dsn.')\n\"LISTA STATUS\"\nx = Outtrap('OFF')\n\nOldDD = ''\nDo iDsn = 1 To Dsn.0\n  Dsn = Dsn.iDsn\n  If Left(Dsn,1) = '-' Then Iterate\n  If Left(Dsn,1) = ' ' Then Iterate\n  If Pos('(',Dsn) > 0 Then Iterate /* for pds(mem) allocations */\n  Dsn = Strip(Dsn)\n\n  /* we know we'er working with a dataset now. */\n  /* look ahead to see if there's a dd.        */\n  iDD = iDsn + 1\n  DD = Dsn.iDD\n  Parse Var DD DD 'KEEP'\n  DD = Strip(DD)\n  If Words(DD) > 1 Then Iterate\n\n  Select\n    When DD = 'SYSEXEC' Then OldDD = DD  /* we're interested */\n    When DD = 'SYSPROC' Then OldDD = DD\n    When DD <> '' Then OldDD = ''        /* not interested */\n    Otherwise Nop\n  End\n  /* OldDD is something, so add it to our list */\n  If OldDD <> '' Then Call CheckDsn Dsn OldDD\nEnd\n\nReturn\n/* sample output from the lista status command */\n--DDNAME---DISP--\nMA133.TSO.PROD.SYSEXEC\n  SYSEXEC  KEEP\nSYS2.UTIL.REXX\n           KEEP\nSYS9.CYFUSION.EXECS\n           KEEP\nSYS9.SOFTPUB.EXEC\n           KEEP\nSYS9.XMITIP.NEW.EXEC\n           KEEP\nSYS1.SBPXEXEC\n           KEEP\nSYS9.CAI.OPSMVS.REXX\n           KEEP\nFFST.V120ESA.SEPWSRC1\n           KEEP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FS": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x04\\x05\\x0f\\x01\\x04\\x05\\x1f\\x16!\\x00u\\x00u\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-02-19T00:00:00", "modifydate": "2004-02-20T16:21:20", "lines": 117, "newlines": 117, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Source Func .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nReturn\n/*-------------------------------------------------------------------*/\n/*- This will find a Source in the production sas mxg libs.         -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nParmlib = \"MA133.TSO.PARMLIB(FS)\"\n\nAddress ISPEXEC\n\nIf Length(Source) = 1 Then Do\n  Func = Source\n  Source = ''\nEnd\n\nIf Source = '' Then Do\n  GETLINE = ''\n  \"VPUT GETLINE SHARED\"\n  \"SELECT CMD(%GETLINE)\"\n  \"VGET (CSR CSRP LINE SCRW PANEL) SHARED\"\n  UpperLine = Line\n  Upper UpperLine\n  CmdPos = Pos('COMMAND',UpperLine)\n  If CmdPos = 0 | CmdPos > 3 Then\n    Parse Var UpperLine 'SOURCLIB(' Source ')'\nEnd\n\nIf Source = '' Then Do\n  Say 'Enter the Source name you want to find...'\n  Pull Source\nEnd\nIf Source = '' Then Do\n  Say 'Source name is missing.'\n  Return\nEnd\n\nEdit.0 = 0\nCall CheckDsns\nIf Edit.0 = 0 Then Do\n  Say 'Source' Source 'not found.'\n  Return\nEnd\n\nIf Edit.0 = 1 Then Do\n  Dsn = Edit.1 || \"(\" || Source || \")\"\n  Call FDSN \"'\"Dsn\"'\" Func\n  Return\nEnd\n\nSay Source 'was found in the following Source libraries...'\nDo iEdit = 1 To Edit.0\n  Say iEdit Edit.iEdit\nEnd\nSay 'Reply with a valid library number, or anything else to quit.'\nPull Reply\nReply = Strip(Reply)\nIf Datatype(Reply,'N') = 1 & Reply > 0 & Reply <= Edit.0 Then Do\n  Dsn = Edit.Reply || \"(\" || Source || \")\"\n  Call FDSN \"'\"Dsn\"'\" Func\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- check halifax datasets                                          -*/\n/*-------------------------------------------------------------------*/\nCheckDsns:\n\nAddress TSO\n\"ALLOC F(IN) DA('\"Parmlib\"') SHR REUSE\"\n\"EXECIO * DISKR IN (STEM Dsn. FINIS\"\n\"FREE F(IN)\"\nAddress ISPEXEC\n\nSysname = Mvsvar('SYSNAME')\nDo iDsn = 1 To Dsn.0\n  Dsn.iDsn = Strip(Dsn.iDsn)\n  Upper Dsn.iDsn\n  If Left(Dsn.iDsn,1) = '*' Then Iterate\n  Parse Var Dsn.iDsn Sys Dsn .\n  If Sys <> Sysname & Sys /= 'ALL' Then Iterate\n  Dsn = Strip(Dsn,\"B\",\"'\")\n  Call CheckDsn Dsn\nEnd\n\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- check to see if the dsn exists and edit it                      -*/\n/*-------------------------------------------------------------------*/\nCheckDsn:\n\nArg Dsn\nCheckDsn = \"'\" || Dsn || \"(\" || Source || \")'\"\nIf SYSDSN(CheckDsn) <> 'OK' Then Return\niEdit = Edit.0\niEdit = iEdit + 1\nEdit.iEdit = Dsn\nEdit.0 = iEdit\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FTPPDS": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01>\\x00I\\x01\\x03\\x11\\x8f\\x01\\x04\\x12\\x9f\\x13\\x02\\x01F\\x00\\x94\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.62", "flags": 0, "createdate": "2003-04-28T00:00:00", "modifydate": "2004-05-08T13:02:49", "lines": 326, "newlines": 148, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nParse Arg ProfDsn Vars .  /* preserve lower case for password */\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nDo While Queued() > 0; Pull .; End;\nReturn\n/*********************************************************************/\n/* this rexx will copy a directory to a pds or a pds to a directory. */\n/* a profile dataset (80 col records) holds the parms for the ftp    */\n/* transfer. cut and paste the following parms from here to the prof.*/\n/* the default name is FTP.PROFILE, but you can pass another name.   */\n/*                                                                   */\n/*   Flow = \"SEND\"/\"RECEIVE\"              * the direction            */\n/*   Host = \"10.1.20.136\"                 * host name                */\n/*   User = \"ma133\"                       * user name                */\n/*   Pass = \"xxxxx\"                       * password                 */\n/*   Mail = \"email@junk.com\"              * email addr for anonymous */\n/*   Root = \"C:\\PTFS\\\"                    * the root dir to set      */\n/*   RDir = \"Unzip\"                       * remote directory - root  */\n/*   LPds = \"FTP.TESTPDS\"                 * the local pds            */\n/*   Type = \"I/A/E\"                       * type of data             */\n/*   Exit = \"FTPPDSXR\"                    * the dsn exit             */\n/*   Each = \"APARSTRP\"                    * run this afterwards      */\n/*   Run                                  * to run the ftp           */\n/*   Alc1 = \"TRACKS(10 10) DIR(5)\"        * to alloc a new one       */\n/*   Alc2 = \"LRECL(80) RECFM(F B) DSORG(PO)\"                         */\n/*                                                                   */\n/* 'Root' sets a prefix to all other RDir referred to so you won't   */\n/*   have to spell out the entire RDir for each xfer. leave it set   */\n/*   to null if you have not need to use it.                         */\n/* 'Exit' specifies a rexx exec to be called for each of the members */\n/*   of a directory. it's purpose is to parse the file name into a   */\n/*   valid member name and set the transfer mode to text or binary.  */\n/* 'Type', if specified, sets the type of transfer. you can set this */\n/*   for each individual member by specifying a type in an exit.     */\n/* 'Each', if specified, is a rexx exec to be run on all the members */\n/*   of the new pds as a 'post-processing' action.                   */\n/* 'Run', if specified, runs the previous ftp parms. this is to allow*/\n/*   multiple ftp transfers in one deck. you can respecify specific  */\n/*   parms such as host or local/remote files and place the run      */\n/*   command after each change.                                      */\n/* 'Pass' is the password. You can place this in the prof deck, pass */\n/*   it as a parm, or, for foreground use only, leave it null and    */\n/*   you will be prompted for it when needed.                        */\n/* 'Alc1' and 'Alc2' are used to allocate a new pds when receiving.  */\n/*   they are not checked or verified, are not prompted for, and     */\n/*   default to the above values.                                    */\n/*********************************************************************/\nMain_Routine:\n\nAddress TSO\nIf Pos('=',ProfDsn) > 0 Then Do\n  Vars = ProfDsn\n  ProfDsn = ''\nEnd\nIf ProfDsn = '' Then ProfDsn = \"'\"Sysvar(\"SYSUID\")\".FTP.PROFILE'\"\nUpper ProfDsn\n\n/* init the profile vars to null */\nParse Value '' With ,\n  Flow Host User Pass Mail Root RDir LPds Type Exit Each Alc1 Alc2\n\nEnvir = Sysvar('SYSENV')\n\nCall Process_Profile\n\nReturn\n/*********************************************************************/\n/* load the profile vars                                             */\n/*********************************************************************/\nProcess_Profile:\n\n\"ALLOC F(PROF) DA(\"ProfDsn\") SHR\"\n\"EXECIO * DISKR PROF (STEM Prof. FINIS\"\nIf RC > 0 Then Signal Failure\n\"FREE F(PROF)\"\n\n/* strip off any comments or blank lines from the end. */\nDo iProf = Prof.0 To 1 By -1\n  Prof.iProf = Strip(Prof.iProf)\n  If Left(Prof.iProf,1) = '*' | Prof.iProf = '' Then Iterate\n  Leave\nEnd\nProf.0 = iProf\n\n/* if the last command is not \"RUN\", add it */\nIf Prof.0 > 0 Then Do\n  iProf = Prof.0\n  Var = Word(Prof.iProf,1)\n  Upper Var\n  If Var <> 'RUN' Then Do\n    iProf = iProf + 1\n    Prof.iProf = 'RUN'\n    Prof.0 = iProf\n  End\nEnd\n\n/* go thru each of the commands in the profile and process them */\nDo iProf = 1 To Prof.0\n  Prof.iProf = Strip(Prof.iProf)\n  If Left(Prof.iProf,1) = '*' Then Iterate\n  Parse Var Prof.iProf Var '=' Val '*' .\n  If Var = '' Then Iterate\n  Upper Var\n  If Var = 'RUN' Then Do\n    Call Prime_Vars\n    Say 'Processing' Flow\n    Say '  Local PDS: ' LPds\n    Say '  Remote Dir:' Root || RDir\n    Say\n    If Flow = 'RECEIVE' Then Call Receive_Pds\n    Else Call Send_Pds\n  End\n  Else Do\n    Val = Strip(Val)\n    Interpret Var '=' Val\n  End\nEnd\n\nReturn\n/*********************************************************************/\n/* send a pds to a directory.                                        */\n/*********************************************************************/\nSend_Pds:\n\nx = Outtrap('Mem.')\n\"LISTD '\"Lpds\"' MEMBERS\"\nx = Outtrap('OFF')\nDo iMem = 1 To Mem.0\n  If Mem.iMem = \"--MEMBERS--\" Then Leave\nEnd\n\n/* queue commands to get the directory */\ndir = RDir\nIf Root <> \"\" Then dir = Root || dir\nQueue Host\nQueue User Pass\nQueue \"CD\" dir\nQueue \"LCD '\"LPds\"'\"\nIf Type <> \"\" Then Queue \"TYPE\" Type\nDo iMem = iMem + 1 To Mem.0\n  Mem = Strip(Mem.iMem)\n  /* call the exit to chop up the file name to a pds member */\n  Interpret \"Call\" Exit \"'\"Mem Lpds dir Type\"'\"\nEnd\nQueue 'QUIT'\n\nCall Do_Ftp\n\nReturn\n/*********************************************************************/\n/* receive a directory to a pds                                      */\n/*********************************************************************/\nReceive_Pds:\n\n/* go get an initial directory listing to process */\ndir = RDir\nIf Root <> \"\" Then dir = Root || dir\nQueue Host\nQueue User Pass\nQueue 'CD' dir\nQueue 'DIR (DISK'\nQueue 'QUIT'\nx = Outtrap(\"Junk\")\n\"FTP\"\nx = Outtrap(\"OFF\")\n\n/* read in the listing returned from above */\nFtpDOut = \"'\"Sysvar(\"SYSUID\")\".FTP.DIROUTP'\"\n\"ALLOC F(LIST) DA(\"FtpDOut\") SHR\"\n\"EXECIO * DISKR LIST (STEM List. FINIS\"\n\"FREE F(LIST)\"\n\n/* for testing purposes and parsing troubles, uncomment */\n/* Call FDSN FtpDOut 'V' */\nx = Msg('OFF')\n\"DELETE\" FtpDOut\nx = Msg(x)\n\n/* queue commands to get the directory */\nQueue Host\nQueue User Pass\nQueue \"CD\" dir\nQueue \"LCD '\"LPds\"'\"\nIf Type <> \"\" Then Queue \"TYPE\" Type\nDo iList = 1 To List.0\n  List = Strip(List.iList)\n  LastSpace = LastPos(' ',List)\n  File = Substr(List,LastSpace+1)\n  /* call the exit to chop up the file name to a pds member */\n  Interpret \"Call\" Exit \"'\"File dir Lpds Type\"'\"\nEnd\nQueue 'QUIT'\n\nCall Do_Ftp\n\n/* run a rexx on all the members */\nIf Each <> '' Then Call EACHMEM \"'\"LPds\"'\" Each\n\nReturn\n/*********************************************************************/\n/* do the queued ftp commands and browse the results                 */\n/*********************************************************************/\nDo_Ftp:\n\n/* go load the pds */\nx = Outtrap(\"Ftp.\")\n\"FTP\"\nx = Outtrap(\"OFF\")\n\nIf Envir = 'FORE' Then Do\n  /* browse the results */\n  FtpOut = \"'\"Sysvar(\"SYSUID\")\".FTP.OUT'\"\n  \"ALLOC F(FTP) DA(\"FtpOut\") NEW CATALOG\" ,\n    \"SPACE(5 5) TRACKS LRECL(80) RECFM(F B) DSORG(PS)\"\n  \"EXECIO * DISKW FTP (STEM Ftp. FINIS\"\n  \"FREE F(FTP)\"\n  Call FDSN FtpOut \"B\"\n  x = Msg('OFF')\n  \"DELETE\" FtpOut\n  x = Msg(x)\nEnd\n\nReturn\n/*********************************************************************/\n/* prime the profile vars                                            */\n/*********************************************************************/\nPrime_Vars:\n\n/* process any overrides from the passed parms. do this each time */\n/* so that each run will have the overrides applied.              */\nTVars = Vars\nDo While Words(TVars) > 0\n  Parse Var TVars Var '=' Val ',' TVars\n  Interpret Var '= \"'Val'\"'\nEnd\n\nIf Alc1 = '' Then Alc1 = \"TRACKS(10 10) DIR(5)\"\nIf Alc2 = '' Then Alc2 = \"LRECL(80) RECFM(F B) DSORG(PO)\"\n\n/* if the host prof var is null prompt for it */\nDo While Flow <> 'SEND' & Flow <> 'RECEIVE'\n  If Envir = 'BACK' Then Do\n    Say 'Invalid required value for \"Flow\":' Flow\n    Say 'Should be either \"SEND\" or \"RECEIVE\"'\n    Signal Failure\n  End\n  Say 'Enter the direction of the transfer or QUIT to exit:'\n  Say '  (Send or Receive)'\n  Parse Pull Flow .\n  If Flow = 'S' Then Flow = 'SEND'\n  If Flow = 'R' Then Flow = 'RECEIVE'\n  If Flow = 'QUIT' Then Exit\nEnd\n\n/* if the host prof var is null prompt for it */\nDo While Host = ''\n  If Envir = 'BACK' Then Do\n    Say '\"Host\" cannot be null'\n    Signal Failure\n  End\n  Say 'Enter host for ftp or QUIT to exit:'\n  Parse Pull Host .\n  If Host = 'QUIT' Then Exit\nEnd\n\n/* get a password if needed (may not be, depends on host) */\nIf User <> 'anonymous' Then Do\n  If Pass = '' & Envir <> 'BACK' Then Do\n    Say 'Enter password for' User 'on host' Host 'or QUIT to exit:'\n    Parse Pull Pass .\n    If Pass = 'QUIT' Then Exit\n  End\nEnd\nElse Pass = Mail\n\n/* get the local pds to dump the dir */\nDo While LPds = ''\n  If Envir = 'BACK' Then Do\n    Say '\"Lpds\" cannot be null'\n    Signal Failure\n  End\n  Say 'Enter existing pds in which to dump the dir or QUIT to exit:'\n  Parse Pull LPds .\n  If LPds = 'QUIT' Then Exit\nEnd\nLpds = PrefDsn(Lpds)\nStatus = Sysdsn(\"'\"LPds\"'\")\nIf Status = 'DATASET NOT FOUND' & Flow = 'RECEIVE' Then Do\n  \"ALLOC F(LPDS) DA('\"Lpds\"') NEW CATLG\" Alc1 Alc2\n  \"FREE F(LPDS)\"\n  Status = Sysdsn(\"'\"LPds\"'\")\nEnd\nIf Status <> 'OK' Then Do\n  Say 'Status of pds' LPds 'is' Status\n  Signal Failure\nEnd\n\n/* get the remote directory */\nDo While RDir = '' & Root = ''\n  If Envir = 'BACK' Then Do\n    Say '\"Rdir\" cannot be null'\n    Signal Failure\n  End\n  Say 'Enter directory on remote host or QUIT to exit:'\n  Parse Pull RDir .\n  If RDir = 'QUIT' Then Exit\nEnd\n\n/* if exit is null default it */\nIf Exit = '' Then Exit = \"FTPPDSX\" || Left(Flow,1)\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FTPPDSXR": {"ttr": 25, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x004\\x01\\x03\\x11\\x8f\\x01\\x04\\x04?\\x14P\\x00\"\\x00\\r\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2003-04-28T00:00:00", "modifydate": "2004-02-12T14:50:34", "lines": 34, "newlines": 13, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this will take a file name such as LO12345.txt and parse it to */\n/* a valid pds member name LO12345 and set the xfer mode to text  */\n/* or binary (for .BIN files). used with exec ftppds.             */\nParse Arg FileName .\nIf FileName = '.' | FileName = '..' Then Return\n\n/* save file name to upper case var */\nUpperFileName = FileName\nUpper UpperFileName\n\n/* make sure we can get it down to 8 chars or less */\nParse Var UpperFileName Member '.'\nIf Length(Member) > 8 Then Do\n  Say 'Unable to parse' FileName 'down to 8 chars. Skipping.'\n  Return\nEnd\n\n/* decide what type of xfer to make it. you can code whatever filters*/\n/* you like here to process out particular files you don't want      */\n/* to transfer or set modes based on different file extentions.      */\nSelect\n  When Pos('.TXT',UpperFileName) > 0 Then Type = 'A'\n  When Pos('.BIN',UpperFileName) > 0 Then Type = 'I'\n  Otherwise Do\n    Say 'Defaulting' FileName 'to binary type transfer'.\n    Type = 'I'\n  End\nEnd\n\nQueue 'TYPE' Type\nQueue 'GET' FileName Member '(REPLACE'\n\nReturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FTPPDSXS": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00Q\\x01\\x04\\x04/\\x01\\x04\\x08_\\x128\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-03-25T12:38:51", "lines": 11, "newlines": 11, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this will take a member name and return a file name. used with */\n/* the ftppds rexx. you can skip files here or change from text   */\n/* or binary based on the member name.                            */\nParse Arg Member . . Type .\nIf Member = \"\" Then Return\n\nIf Type = 'I' Then Queue \"PUT\" Member Member\".bin\"\nElse Queue \"PUT\" Member Member\".txt\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDGREL": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00@\\x01\\x04\\x05\\x0f\\x01\\x04\\x07\\x0f\\x13\\x08\\x00Q\\x00J\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2004-02-19T00:00:00", "modifydate": "2004-03-10T13:08:40", "lines": 81, "newlines": 74, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg GdgDsn .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nReturn Convert_Gdg()\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit '';\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit '';\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit '';\nCleanup:\nSay 'Unable to convert relative GDG' GdgDsn 'to a real name.'\nReturn\n/*-------------------------------------------------------------------*/\n/*- The main exec routine.                                          -*/\n/*-------------------------------------------------------------------*/\nConvert_Gdg:\n\nGdgDsn = PrefDsn(GdgDsn)\n\nParse Var GdgDsn Name '(' Gen ')'\nIf Datatype(Gen) <> 'NUM' Then Signal Failure\nIf Gen > 0 Then Do\n  Say 'Relative generation' Gen 'changed to generation 0.'\n  Gen = 0\nEnd\n\n/* list all gdgs */\nAddress TSO\nX=OUTTRAP(\"L.\")\n\"LISTCAT ENTRY('\"Name\"')\"\nX=OUTTRAP(\"OFF\")\n\n/* make sure we get a good return from the listcat */\nIf RC <> 0 Then Do\n  Say \"LISTCAT return code for\" GdgDsn \"=\" RC\n  Signal Failure\nEnd\n\n/* make sure we get some output from the listcat */\nIf L.0 < 1 Then Do\n  Say \"LISTCAT returned no entries for\" GdgDsn\n  Signal Failure\nEnd\n\n/* make the first line starts with GDG BASE */\n/* GDG BASE ------ MA133.TEST.GDG */\nIf Substr(L.1,1,8) <> \"GDG BASE\" Then Do\n  Say GdgDsn \"is not a gdg base.\"\n  Signal Failure\nEnd\n\n/* look for any nonvsam files returned from the list command */\n/* NONVSAM ------- MA133.TEST.GDG.G0007V00 */\niGen = 0\nDo iL = 1 to L.0\n  If Word(L.iL,1) <> 'NONVSAM' Then Iterate\n  /* pull the dataset name from the list command */\n  iGen = iGen + 1\n  Gen.iGen = Word(L.iL,(Words(L.iL)))\nEnd\nGen.0 = iGen\n\nIf Gen.0 = 0 Then Do\n  Say 'No generations exist for' GdgDsn\n  Signal Failure\nEnd\n\nWantGen = Gen.0 + Gen\n\nIf WantGen < 1 Then Do\n  Say 'Generation' Gen 'does not exist for' GdgDsn\n  Say 'Oldest generation is -'Gen.0\n  Signal Failure\nEnd\n\nReturn Gen.WantGen\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETLINE": {"ttr": 27, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x04\\x01\\x014\\x1f\\x01\\x04\\x04?\\x15\\x15\\x003\\x00&\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2001-12-07T00:00:00", "modifydate": "2004-02-12T15:15:04", "lines": 51, "newlines": 38, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/******************************************************************/\n/* this will return info on the line of the ispf screen that the  */\n/* cursor is currently parked on. it is useful for passing parms  */\n/* to an exec based on what the user is pointing to. this will    */\n/* vput the fields that are in all caps to pass the data.         */\n/******************************************************************/\nAddress ISPEXEC\n\nTcb    = Ptr(540)               /* TCB (EXEC command)    PSATOLD  */\nTcb    = Ptr(Tcb+132)           /* TCB (ISPTASK)         TCBOTC   */\nFsa    = Ptr(Tcb+112)           /* first save area       TCBFSA   */\nR1     = Ptr(Fsa+24)            /* ISPTASK's R1                   */\nTld    = Ptr(R1)                /* TLD address                    */\nTls    = Ptr(Tld+096)           /* screen buffer         TLDTLSP  */\nCSR    = Ptr(Tld+164)           /* relative cursor pos.  TLDCSR   */\nSCRW   = Ptr(Tld+192)           /* screen width          TLDCLSWD */\n\nPanelad= D2X(Tld+344)           /* address of the panelid         */\nPANEL  = Storage(Panelad,8)     /* name of the panel              */\n\nIf SCRW>0 Then CSRP = CSR//SCRW+1 /* cursor position in LINE      */\nElse CSRP = 1                   /* ISPSTRT                        */\n\nLinead = D2X(Tls+CSR-CSRP+1)    /* address of current LINE        */\nLINE   = Storage(Linead,SCRW)   /* text of current LINE           */\nValid  = Copies(' ',64)||Xrange('40'x,'FF'x)\nLINE   = Translate(LINE,Valid)\n\n\"VPUT (CSR CSRP LINE SCRW PANEL) SHARED\"\n\n\"VGET GETLINE SHARED\"\nIf GETLINE = 'DEBUG' Then Do\n  Say 'Tcb='D2X(Tcb) ,\n      'Fsa='D2X(Fsa) ,\n      'R1='D2X(R1),\n      'Tld='D2X(Tld) Storage(D2X(Tld),4)\n  Say 'Tls='D2X(Tls)\n  Say 'CSR='CSR ,\n      'CSRP='CSRP ,\n      'SCRW='SCRW ,\n      'Linead='Linead\n  Say 'LINE='LINE\n  Say 'Dumping Tld...'\n  Call DumpStor D2X(Tld) 400\n  Say 'Dumping screen...'\n  Call DumpStor D2X(Tls) 200\nEnd\n\nReturn\nPtr: Return C2D(Bitand(Storage(D2X(Arg(1)),4),'7FFFFFFF'x))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GO": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00X\\x00\\x943O\\x01\\x04\\x11/\\x10D\\x00)\\x00\\x0b\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1994-11-30T00:00:00", "modifydate": "2004-04-21T10:44:58", "lines": 41, "newlines": 11, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*********************************************************************/\n/* this allows you to run an exec while editing it. if there are     */\n/* outstanding changes to the exec, it will save them first.         */\n/*********************************************************************/\nAddress ISREDIT\n\"MACRO (PARMS)\"\n\"(DSN) = DATASET\"\n\"(MEM) = MEMBER\"\n\n/* save any outstanding changes before continuing */\n\"(CHG) = DATA_CHANGED\"\nIf CHG = 'YES' Then Do\n  \"SAVE\"\n  If RC > 4 Then Do\n    If MEM <> '' Then Do\n      Say \"SAVE failed, ya want I should compress this? (Y or N)\"\n      Pull Answer\n      If Substr(Answer,1,1) = 'Y' Then Do\n        \"COMPRESS\"\n        \"SAVE\"\n        If RC > 4 Then Do\n          Say \"SAVE still fails, aborting GO command...\"\n          Exit 8\n        End\n      End\n    End\n    Else Do\n      Say \"SAVE failed, aborting GO command...\"\n      Exit 8\n    End\n  End\nEnd\n\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nCommand = DSN\nIf MEM <> '' Then Command = Command || '(' || MEM || ')'\nAddress TSO \"EX '\"Command\"' '\"PARMS\"'\"\nIf RC > 0 Then Say \"Command ended with RC=\"RC\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTCNCT": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Q\\x01\\x04\\x11O\\x01\\x04\\x12\\x9f\\x12\\x15\\x004\\x004\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-04-23T00:00:00", "modifydate": "2004-05-08T12:15:51", "lines": 52, "newlines": 52, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*-------------------------------------------------------------------*/\n/*- list the concatenations for a passed dd name.                   -*/\n/*-------------------------------------------------------------------*/\nArg DDName .\n\nx = Outtrap('Dsn.')\n\"LISTA STATUS\"\nx = Outtrap('OFF')\n\nOldDD = ''\nDo iDsn = 1 To Dsn.0\n  Dsn = Dsn.iDsn\n  If Left(Dsn,1) = '-' Then Iterate\n  If Left(Dsn,1) = ' ' Then Iterate\n  If Pos('(',Dsn) > 0 Then Iterate /* for pds(mem) allocations */\n  Dsn = Strip(Dsn)\n\n  /* we know we'er working with a dataset now. */\n  /* look ahead to see if there's a dd.        */\n  iDD = iDsn + 1\n  DD = Dsn.iDD\n  Parse Var DD DD 'KEEP'\n  DD = Strip(DD)\n  If Words(DD) > 1 Then Iterate\n\n  If DD = DDName Then OldDD = DD        /* we're interested */\n  Else If DD /= '' Then OldDD = ''        /* not interested */\n\n  /* OldDD is something, so add it to our list */\n  If OldDD /= '' Then Say Dsn\nEnd\n\nReturn\n/* sample output from the lista status command */\n--DDNAME---DISP--\nMA133.TSO.PROD.SYSEXEC\n  SYSEXEC  KEEP\nSYS2.UTIL.REXX\n           KEEP\nSYS9.CYFUSION.EXECS\n           KEEP\nSYS9.SOFTPUB.EXEC\n           KEEP\nSYS9.XMITIP.NEW.EXEC\n           KEEP\nSYS1.SBPXEXEC\n           KEEP\nSYS9.CAI.OPSMVS.REXX\n           KEEP\nFFST.V120ESA.SEPWSRC1\n           KEEP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTLINK": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00T\\x01\\x04\\x11?\\x01\\x04\\x11O\\x14\\x10\\x00\\x16\\x00+\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-04-22T00:00:00", "modifydate": "2004-04-23T14:10:54", "lines": 22, "newlines": 43, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*-------------------------------------------------------------------*/\n/*- this will return the libraries that are in lla.                 -*/\n/*-------------------------------------------------------------------*/\nNUMERIC DIGITS 12\nCVT = C2X(Storage(10,4))\nLLT = C2X(Storage(D2X(X2D(CVT)+1244),4))\nLLTEYE = Storage(D2X(X2D(LLT)+0),4)\nLLTLEN = C2D(Storage(D2X(X2D(LLT)+4),4))\nDLENOFF = 8\nDSNOFF = 9\n\nDO LLTLEN\n  DLEN = C2D(Storage(D2X(X2D(LLT)+DLENOFF),1))\n  Dsn = Storage(D2X(X2D(LLT)+DSNOFF),DLEN)\n  Dsn = STRIP(Dsn)\n  Say Dsn\n  DLENOFF = DLENOFF + 45\n  DSNOFF = DSNOFF + 45\nEnd\n\nReturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTLPA": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00H\\x01\\x04\\x11?\\x01\\x04\\x11O\\x14\\x10\\x00\\x17\\x00(\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-04-22T00:00:00", "modifydate": "2004-04-23T14:10:48", "lines": 23, "newlines": 40, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*-------------------------------------------------------------------*/\n/*- this will return the datasets in the lpalist                    -*/\n/*-------------------------------------------------------------------*/\nNUMERIC DIGITS 12\nCVT = C2X(STORAGE(10,4))\nMSE = C2X(STORAGE(D2X(X2D(CVT)+1196),4))\nLPAT = C2X(STORAGE(D2X(X2D(MSE)+56),4))\nLPATEYE = STORAGE(D2X(X2D(LPAT)+0),4)\nLPATLEN = C2D(STORAGE(D2X(X2D(LPAT)+4),4))\nDLENOFF = 8\nDSNOFF = 9\n\nDO LPATLEN\n  DLEN = C2D(STORAGE(D2X(X2D(LPAT)+DLENOFF),1))\n  Dsn = STORAGE(D2X(X2D(LPAT)+DSNOFF),DLEN)\n  Dsn = STRIP(Dsn)\n  Say Dsn\n  DLENOFF = DLENOFF + 45\n  DSNOFF = DSNOFF + 45\nEnd\n\nReturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTMEM": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0b\\x00'\\x01\\x04\\x11?\\x01\\x04\\x11\\x7f\\x16\\x10\\x00,\\x00\\x17\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@\"", "ispf": {"version": "01.11", "flags": 0, "createdate": "2004-04-22T00:00:00", "modifydate": "2004-04-26T16:10:27", "lines": 44, "newlines": 23, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*-------------------------------------------------------------------*/\n/*- this will return a member list of a dsn that you pass           -*/\n/*-------------------------------------------------------------------*/\nArg Dsn .\n\nDsn = PrefDsn(Dsn)\nx = Outtrap('Mem.')\n\"LISTD '\"Dsn\"' MEMBERS\"\nx = Outtrap('OFF')\nDo iMem = 1 To Mem.0\n  If Mem.iMem = \"--MEMBERS--\" Then Leave\nEnd\n\n/* queue commands to get the directory */\nDo iMem = iMem + 1 To Mem.0\n  If Substr(Mem.iMem,3,1) <> ' ' Then Alias = Word(Mem.iMem,1)\n  Mem = Strip(Mem.iMem)\n  If Left(Mem,13) = 'THE FOLLOWING' Then Iterate\n\n  /* list the members and aliases. see listd members output to see */\n  Parse Var Mem First 'ALIAS(' Last\n  Mem = First Last\n  Mem = Translate(Mem,,'(,)')\n  Mem = Strip(Mem)\n  Do While Length(Mem) > 0\n    Parse Var Mem One Mem\n    If One = Alias Then Say One\n    Else Say Overlay(Alias,One,10)\n  End\nEnd\n\nReturn\n/* sample 'listd members' output */\ntso listd 'SYS9.XJSV3R1.LOADLIB' members\n\nSYS9.XJSV3R1.LOADLIB\n--RECFM-LRECL-BLKSIZE-DSORG\n  U     **    13030   PO\n--VOLUMES--\n  PRDOE1\n--MEMBERS--\n  XJS  ALIAS(XJSXRD,XJSXRS,XJSXSD,XJSXSS,XJSXTS,\n           XJSX4D,XJSX4S)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NJ": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00T\\x01\\x03\"o\\x01\\x04\\x05_\\x133\\x050\\x01\\t\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2003-08-14T00:00:00", "modifydate": "2004-02-24T13:33:54", "lines": 1328, "newlines": 265, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Job .\n\nTraceIt = 'N'\nTraceHead = Copies('*',79)\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nSignal Off Novalue\nSay 'iRpt='iRpt\nSay 'Line='Rpt.iRpt\nSay 'RptStmt='RptStmt\nSay 'OldRptStmt='OldRptStmt\nIf StackedCall = 'Y' Then Return\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"TBEND\" TabDsn\n\"TBEND\" TabPgm\n\"TBEND\" TabProc\n\"TBEND\" TabMsg\n\"TBEND\" TabPrt\n\"LIBDEF ISPTLIB\"\n\"LIBDEF ISPTABL\"\n\"CONTROL ERRORS CANCEL\"\nReturn\n/*-------------------------------------------------------------------*/\n/*- this exec will take a job passed to it and create a bunch of    -*/\n/*- ispf tables showing where datasets are used, sysout stuff, procs-*/\n/*- called, jclcheck errors etc etc. it calls jclcheck and then     -*/\n/*- chops up the reports to generate the tables. from the tables    -*/\n/*- you can select different lines to pop you into the jcl source   -*/\n/*- line. if there is a dataset on the line, you can edit it. see   -*/\n/*- the help panels for more detailed information.                  -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nAddress ISPEXEC\n\"VGET (ZSCREEN ZAPPLID ZUSER ZPREFIX)\"\nIf ZAPPLID \\= 'NJ' Then Do        /*   If ZAPPLID\\=NJ, re-invoke  */\n  \"SELECT CMD(%NJ\" Job\") NEWAPPL(NJ)\"\n  Exit RC                         /*   with NEWAPPL(NJ)  so that  */\nEnd                               /*   right/left cmds will work  */\n\n/* if we're stacked, just redisplay the tables */\nCall Is_Stacked\nIf StackedCall = 'N' Then Do\n  Call Get_A_Job\n  Call Refresh_Tables\nEnd\nCall Display_Tables\nCall Cleanup_Tables\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Find out if this is a stacked call                              -*/\n/*-------------------------------------------------------------------*/\nIs_Stacked:\n\nTabDsn = 'NJDSN'ZSCREEN\nTabPgm = 'NJPGM'ZSCREEN\nTabProc = 'NJPROC'ZSCREEN\nTabMsg = 'NJMSG'ZSCREEN\nTabPrt = 'NJPRT'ZSCREEN\n\n\"TBSTATS\" TabDsn \"STATUS2(STATUS2)\"\nIf Status2 = 2 | Status2 = 3 Then Do\n  StackedCall = 'Y'\n  \"VGET DSNJOB\"ZSCREEN \"PROFILE\"\n  DsnJob = Value('DSNJOB'ZSCREEN)\n  If Job <> '' Then \"SETMSG MSG(NJ009)\"\nEnd\nElse StackedCall = 'N'\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Get a job to work on.                                           -*/\n/*-------------------------------------------------------------------*/\nGet_A_Job:\n\n/* load up the source dataset from the FindJob command if all the */\n/* user passed was a job name. */\nIf Length(Job) < 9 Then Do\n  Call FJ Job 'G'\n  \"VGET FJJOB SHARED\"\n  If FJJOB = '' Then Exit(0)\n\n  Parse Var FJJOB JobPds '(' Member ')'\n  JobPds = \"'\"JobPds\"'\"\n  DsnJob = \"'\"FJJOB\"'\"\nEnd\n/* or else the user passed the full job name */\nElse Do\n  DsnJob = Job\n  If Left(DsnJob,1) <> \"'\" Then Do\n    If ZPREFIX <> '' Then DsnJob = \"'\"ZPREFIX\".\"DsnJob\"'\"\n    Else DsnJob = \"'\"DsnJob\"'\"\n  End\nEnd\n/* save the dataset name we're processing in an ispf var */\nInterpret \"DSNJOB\"ZSCREEN \"= DsnJob\"\n\"VPUT DSNJOB\"ZSCREEN \"PROFILE\"\n\n/* create a temp dataset name for saving jclcheck reports */\nParse Value Date() With Day Month .\nUpper Month\nParse Value Time() With Hour ':' Minute ':' Second\nQual = 'D'Day || Month'.T'Hour || Minute || Second\nDsnJck = \"'\"ZUSER\".NJ.JCHK.SYSPRINT.\"Qual\"'\"\n\n/* save the ispf profile dataset name for later use */\nMsg = Msg('OFF')\nLdsi = Listdsi('ISPPROF' 'FILE' 'NODIRECTORY')  /* find prof name */\nMsg = Msg(Msg)\nIf Ldsi > 4 Then Signal Failure\nDsnTab = \"'\"SYSDSNAME\"'\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- call jclcheck. has been tested with the following level/parms:  -*/\n/*-------------------------------------------------------------------*/\n/*designed for jclcheck Genlevel: 7.0 03 SP04\n  CALLING  PARAMETERS: AUTOPROC HCD TLMS(54) SMS VSAM TSOE LIST(OUT)\n                       PROCXREF RPT\n  DEFAULT  PARAMETERS: CTL,FULL,JOB,LIST,XREF,PXREF(RPT),RUNTIME,SYNTAX\n  OPTIONS IN EFFECT: AUTOPROC() CTLSCAN() FULLLIST JOB LIST(OUT) HCD\n                       RUNTIME TLMS(54) TSOE VSAM() XREF RPT\n                       PROC(PROC00) PROCXREF PXREF(RPT) SYNTAX\n  DERIVED OPTIONS IN EFFECT: MVSLEVEL(5)\n*/\nCreate_Jclcheck_Report:\n\nIf TraceIt = 'Y' Then JckDisp = 'CATALOG'\nElse JckDisp = 'DELETE'\n\nAddress TSO\n\"ALLOC F(OUT) DA(\"DsnJck\") NEW\" JckDisp ,\n  \"SPACE(3 3) TRACKS LRECL(133) RECFM(F B) DSORG(PS)\"\nIf RC > 0 Then Signal Failure\n\"%NJCHECK\" DsnJob \"LIST(OUT) PROCXREF RPT\"\nAddress ISPEXEC \"EDIT DATASET(\"DsnJck\") MACRO(NJEDRPT)\"\n\"EXECIO * DISKR OUT (STEM Rpt. FINIS\"\n\"FREE F(OUT)\"\nAddress ISPEXEC\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- process the resulting report1.                                  -*/\n/*-------------------------------------------------------------------*/\nProcess_Report1_Listing:\n\nIf Rpt.0 = 0 Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 1 Missing.'\n  Return\nEnd\nIf Substr(Rpt.1,41,10) <> ' REPORT 1 ' Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 1 Missing.'\n  Return\nEnd\n\nAddress TSO\n\"ALLOC F(JOB) DA(\"DsnJob\") SHR REUSE\"\nIf RC > 0 Then Signal Failure\n\"EXECIO * DISKR JOB (STEM Job. FINIS\"\n\"FREE F(JOB)\"\nAddress ISPEXEC\n\nOldJobStmt = ''\niJob = 0\nDo iRpt = 2 To Rpt.0\n  If Substr(Rpt.iRpt,2,1) = '*' & ,\n    Substr(Rpt.iRpt,41,8) = ' REPORT ' Then Leave\n\n  Parse Var Rpt.iRpt 2 JobStmt 7 8 JobCard 11 JobText\n  JobStmt = Strip(JobStmt)\n  JobCard = Strip(JobCard)\n  JobText = Strip(JobText)\n  If JobStmt = '' & JobCard = '' Then Iterate\n\n  If JobStmt <> '' Then OldJobStmt = JobStmt\n  If JobCard <> '' Then JobStmt = OldJobStmt'.'JobCard\n\n  Do iJob = iJob + 1 To Job.0\n    If JobText = Job.iJob Then Leave\n  End\n  JobPos.JobStmt = iJob\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- process the resulting report2.                                  -*/\n/*-------------------------------------------------------------------*/\nProcess_Report2_Merged:\n\nIf iRpt > Rpt.0 Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 2 Missing.'\n  Return\nEnd\nIf Substr(Rpt.iRpt,41,10) <> ' REPORT 2 ' Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 2 Missing.'\n  Return\nEnd\n\nRawSeq = 0\nProcPos.0 = 0\nInclPos.0 = 0\nOldRptStmt = 0\nOldStep = ''\nDo iRpt = iRpt + 1 To Rpt.0\n  If Substr(Rpt.iRpt,2,1) = '*' & ,\n    Substr(Rpt.iRpt,41,8) = ' REPORT ' Then Leave\n  RawSeq = RawSeq + 1\n\n  Parse Var Rpt.iRpt 2 RptStmt 7 8 RptCard 11 RptStep 20 RptProc 29 ,\n    38 RptText\n  RptStmt = Strip(RptStmt)\n  RptCard = Strip(RptCard)\n  RptStep = Strip(RptStep)\n  RptProc = Strip(RptProc)\n  /* don't strip rpttext until later, need to see leading blanks. */\n  If Word(RptText,1) = 'SUBSTITUTION' Then Iterate\n  If Pos('IN INPUT STREAM',RptText) > 0 Then Iterate\n\n  If RptStmt <> '' Then OldRptStmt = RptStmt\n  If RptCard <> '' Then RptStmt = OldRptStmt'.'RptCard\n\n  If TraceIt = 'Y' Then Call Process_Report2_Merged_Trace\n  Call Process_Report2_Merged_SetPos\n  If RptStmt = '' Then Iterate\n\n  /* ignore any comments, anything not a valid jcl statement */\n  If Left(RptText,2) <> '//' Then Iterate\n  If Substr(RptText,3,1) = '*' Then Iterate\n\n  /* see if this is a proc */\n  If Word(RptText,2) = 'EXEC' Then Do\n    Parse Value Word(RptText,3) With Proc ','\n    Proc = Strip(Proc)\n    If Left(Proc,4) = 'PGM=' Then Iterate\n\n    /* look ahead, skip extra exec lines, see what index we're at */\n    Do iRpt2 = iRpt + 1 To Rpt.0\n      If Substr(Rpt.iRpt,41,8) = ' REPORT ' Then Iterate iRpt\n      Parse Var Rpt.iRpt2 2 RptStmt2 7 39 NextProcIndex 41 45 Which 46\n      RptStmt2 = Strip(RptStmt2)\n      If RptStmt2 = '' Then Iterate\n      If Left(RptStmt2,1) = '.' Then Iterate\n      Leave\n    End\n    If Which <> 'X' Then Iterate\n    NextProcIndex = Strip(NextProcIndex,'L','0')\n    If Datatype(NextProcIndex,'N') <> 1 Then Iterate\n    If NextProcIndex <> ProcIndex + 1 Then Iterate\n\n    /* we know the proc index now, clean up old procs */\n    Do While ProcPos.0 >= NextProcIndex\n      iProcPos = ProcPos.0\n      If TraceIt = 'Y' Then ,\n        Say '  Dropping proc index' iProcPos '('ProcPos.0')'\n      Drop ProcPos.iProcPos\n      iProcPos = iProcPos - 1\n      ProcPos.0 = iProcPos\n    End\n    /* add the new proc now */\n    iProcPos = ProcPos.0\n    iProcPos = iProcPos + 1\n    ProcPos.0 = iProcPos\n    ProcPos.iProcPos = Proc '0'\n    If TraceIt = 'Y' Then ,\n      Say '  Added a proc index, index=' iProcPos '('ProcPos.iProcPos')'\n  End\n\n  /* if it's not a proc, maybe it's an include */\n  Else If Word(RptText,2) = 'INCLUDE' Then Do\n    Parse Value Word(RptText,3) With 'MEMBER=' Incl .\n    /* assume that it will all be on one line */\n    iRpt2 = iRpt + 1\n    Parse Var Rpt.iRpt2 42 NextInclIndex 44 45 Which 46\n    If Which <> 'I' Then Iterate\n\n    NextInclIndex = Strip(NextInclIndex,'L','0')\n    If Datatype(NextInclIndex,'N') <> 1 Then Iterate\n    If NextInclIndex <> InclIndex + 1 Then Iterate\n\n    /* clean up old includes */\n    Do While InclPos.0 >= NextInclIndex\n      iInclPos = InclPos.0\n      If TraceIt = 'Y' Then ,\n        Say '  Dropping incl index' iInclPos '('InclPos.0')'\n      Drop InclPos.iInclPos\n      iInclPos = iInclPos - 1\n      InclPos.0 = iInclPos\n    End\n    /* add the new one */\n    iInclPos = InclPos.0\n    iInclPos = iInclPos + 1\n    InclPos.0 = iInclPos\n    InclPos.iInclPos = Incl '0'\n    If TraceIt = 'Y' Then ,\n      Say '  Added a incl index, index=' iInclPos '('InclPos.iInclPos')'\n  End\nEnd\n\nIf TraceIt = 'Y' Then Say\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- save where each statement resides.                              -*/\n/*-------------------------------------------------------------------*/\nProcess_Report2_Merged_SetPos:\n\nProcIndex = 0; InclIndex = 0;\n\n/* source/pos will initially be set to the previous source/pos */\nSelect\n  /* a ctlcard extracted either from an instream or sysin dd */\n  When RptCard <> '' Then Do\n    If Source = '(Inline)' & Symbol('JobPos.'RptStmt) = 'VAR' Then ,\n      Pos = JobPos.RptStmt\n  End\n  /* either a proc or include */\n  When Left(RptText,1) = 'L' Then Do\n    Parse Var RptText 2 ProcIndex 5 InclIndex 8 Which 9\n    ProcIndex = Strip(ProcIndex)\n    InclIndex = Strip(InclIndex)\n    ProcIndex = Strip(ProcIndex,'L','0')\n    InclIndex = Strip(InclIndex,'L','0')\n    If ProcIndex = '' Then ProcIndex = 0\n    If InclIndex = '' Then InclIndex = 0\n    If TraceIt = 'Y' Then ,\n      Say '  Processing Proc/Incl, ProcIndex =' ProcIndex || ,\n          ', InclIndex =' InclIndex\n    /* make the rpttext look like a regular jcl statement now */\n    RptText = '//' || Substr(RptText,10)\n\n    If Which = 'I' Then Do\n      Parse Var InclPos.InclIndex Source Pos\n      Pos = Pos + 1\n      InclPos.InclIndex = Source Pos\n    End\n    Else Do\n      Parse Var ProcPos.ProcIndex Source Pos\n      Pos = Pos + 1\n      ProcPos.ProcIndex = Source Pos\n    End\n  End\n  /* an inline statement, only care if it's labeled */\n  When RptStmt <> '' Then Do\n    Source = '(Inline)'\n    Pos = JobPos.RptStmt\n  End\n  /* a continuation of a card, who cars about it? */\n  Otherwise Return\nEnd\n\nStep = RptStep\nIf RptProc <> '' Then Step = RptStep\".\"RptProc\nIf Step <> '' Then OldStep = Step\nIf RptCard <> '' Then Step = OldStep\n/* save the card image for later use */\nImag.RptStmt = RptText\n/* save the number of statements in an index for later */\nStmt.RptStmt = \"<\"Source\"> <\"Pos\"> <\"Step\"> <\"RawSeq\">\"\nIf TraceIt = 'Y' Then Say '  Current stmt in:' Source 'Pos:' Pos 'Step:' Step\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Save where each statement resides.                              -*/\n/*-------------------------------------------------------------------*/\nProcess_Report2_Merged_Trace:\n\nSay TraceHead\nSay 'TRACE Processing:'\nSay Left(Rpt.iRpt,79)\nSay '  RptStmt=' RptStmt\nSay '  RptStep=' RptStep\nSay '  RptProc=' RptProc\nSay '  RptText=' Left(RptText,68)\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- process the resulting report3.                                  -*/\n/*-------------------------------------------------------------------*/\nProcess_Report3_Datasets:\n\nDsns.0 = 0\nIf iRpt > Rpt.0 Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 3 Missing.'\n  Return\nEnd\nIf Substr(Rpt.iRpt,41,10) <> ' REPORT 3 ' Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 3 Missing.'\n  Return\nEnd\n\nIf TraceIt = 'Y' Then Do\n  Say TraceHead\n  Say 'Processing Dataset Report'\nEnd\n\niDsns = 0\nDo iRpt = iRpt + 1 To Rpt.0\n  If Substr(Rpt.iRpt,2,1) = '*' & ,\n    Substr(Rpt.iRpt,41,8) = ' REPORT ' Then Leave\n\n  Parse Var Rpt.iRpt 2 Dsn 46 55 DsnType 60 75 DsnDef 82 83 DsnDel 93 ,\n    102 DsnRef\n  Dsn = Strip(Dsn)\n  DsnType = Strip(DsnType)\n  DsnDef = Strip(DsnDef)\n  DsnDel = Strip(DsnDel)\n  DsnRef = Strip(DsnRef)\n  If Left(Dsn,10) = 'DATACLAS: ' Then Iterate\n  If Left(Dsn,10) = 'STORGRP:  ' Then Iterate\n  If DsnType = '' Then DsnType = '????'\n\n  If Dsn <> '' Then Do\n    If TraceIt = 'Y' Then Say '  Adding dataset' Dsn\n    iDsns = iDsns + 1\n    Dsns.iDsns = Dsn\n    Dsns.iDsns.dbType = DsnType\n    Dsns.iDsns.dbDef = DsnDef\n    Dsns.iDsns.dbDel = DsnDel\n    Dsns.iDsns.dbRef = ''\n  End\n  Dsns.iDsns.dbRef = Dsns.iDsns.dbRef DsnRef\nEnd\nDsns.0 = iDsns\n\nIf TraceIt = 'Y' Then Do\n  Say 'Added' Dsns.0 'datasets.'\n  Say TraceHead\n  Say\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- process the resulting report4.                                  -*/\n/*-------------------------------------------------------------------*/\nProcess_Report4_Program:\n\nPgms.0 = 0\nIf iRpt > Rpt.0 Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 4 Missing.'\n  Return\nEnd\nIf Substr(Rpt.iRpt,41,10) <> ' REPORT 4 ' Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 4 Missing.'\n  Return\nEnd\n\nIf TraceIt = 'Y' Then Do\n  Say TraceHead\n  Say 'Processing Program Report'\nEnd\n\niPgms = 0\nDo iRpt = iRpt + 1 To Rpt.0\n  If Substr(Rpt.iRpt,2,1) = '*' & ,\n    Substr(Rpt.iRpt,41,8) = ' REPORT ' Then Leave\n\n  Parse Var Rpt.iRpt 2 Pgm 10 20 PgmLib 79 PgmRef\n  Pgm = Strip(Pgm)\n  PgmLib = Strip(PgmLib)\n  PgmRef = Strip(PgmRef)\n  If PgmRef = '' Then Iterate\n\n  If Pgm <> '' Then Do\n    If TraceIt = 'Y' Then Say '  Adding program' Pgm\n    iPgms = iPgms + 1\n    Pgms.iPgms = Pgm\n    Pgms.iPgms.dbLib = PgmLib\n    Pgms.iPgms.dbRef = ''\n    Pgms.Pgm = iPgms\n  End\n\n  Do While Pos(')',PgmRef) > 0\n    Parse Var PgmRef PgmRef '(' ')' Remainder\n    PgmRef = PgmRef Remainder\n  End\n  Pgms.iPgms.dbRef = Pgms.iPgms.dbRef PgmRef\nEnd\nPgms.0 = iPgms\n\nIf TraceIt = 'Y' Then Do\n  Say 'Added' Pgms.0 'programs.'\n  Say TraceHead\n  Say\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- process the resulting report5.                                  -*/\n/*-------------------------------------------------------------------*/\nProcess_Report5_Reports:\n\nPrts.0 = 0\nIf iRpt > Rpt.0 Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 5 Missing.'\n  Return\nEnd\nIf Substr(Rpt.iRpt,41,10) <> ' REPORT 5 ' Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 5 Missing.'\n  Return\nEnd\n\nDDNot.1 = 'SYSUDUMP'\nDDNot.2 = 'SYSABEND'\nDDNot.3 = 'PLIDUMP'\nDDNot.4 = 'SORTMSG'\nDDNot.5 = 'ADRLOG'\nDDNot.0 = 5\n\niPrts = 0\nDo iRpt = iRpt + 1 To Rpt.0\n  If Substr(Rpt.iRpt,2,1) = '*' & ,\n    Substr(Rpt.iRpt,41,8) = ' REPORT ' Then Leave\n\n  Parse Var Rpt.iRpt 2 PrtRef 11 PrtStep 22 PrtProc 30 ,\n    32 PrtDD 40 42 PrtClass 43 52 PrtForm 56 69 PrtWtr 77 93 PrtDest\n  PrtRef = Strip(PrtRef)\n  PrtStep = Strip(PrtStep)\n  PrtProc = Strip(PrtProc)\n  PrtDD = Strip(PrtDD)\n  PrtForm = Strip(PrtForm)\n  PrtWtr = Strip(PrtWtr)\n  PrtDest = Strip(PrtDest)\n  Do iDDNot = 1 To DDNot.0\n    If PrtDD = DDNot.iDDNot Then Iterate iRpt\n  End\n  If PrtProc <> '' Then PrtStep = PrtStep'.'PrtProc\n\n  iPrts = iPrts + 1\n  Prts.iPrts = PrtRef\n  Prts.iPrts.dbStep = PrtStep\n  Prts.iPrts.dbDD = PrtDD\n  Prts.iPrts.dbClass = PrtClass\n  Prts.iPrts.dbForm = PrtForm\n  Prts.iPrts.dbWtr = PrtWtr\n  Prts.iPrts.dbDest = PrtDest\nEnd\nPrts.0 = iPrts\nDrop DDNot.\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- process the resulting report6.                                  -*/\n/*-------------------------------------------------------------------*/\nProcess_Report6_Error:\n\nMsgs.0 = 0\nIf iRpt > Rpt.0 Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 6 Missing.'\n  Return\nEnd\nIf Substr(Rpt.iRpt,41,10) <> ' REPORT 6 ' Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 6 Missing.'\n  Return\nEnd\n\nOldRef = ''\niMsgs = 0\nDo iRpt = iRpt + 1 To Rpt.0\n  If Substr(Rpt.iRpt,2,1) = '*' & ,\n    Substr(Rpt.iRpt,41,8) = ' REPORT ' Then Leave\n\n  Parse Var Rpt.iRpt 2 MsgRef 11 Msg 21 Text\n  Msg = Strip(Msg)\n  Text = Strip(Text)\n  MsgRef = Strip(MsgRef)\n  MsgRef = Strip(MsgRef,'B','.')\n  If MsgRef <> '' Then OldRef = MsgRef\n  Else If MsgRef = '' Then MsgRef = OldRef\n\n  iMsgs = iMsgs + 1\n  Msgs.iMsgs = Msg\n  Msgs.iMsgs.dbText = Text\n  Msgs.iMsgs.dbRef = MsgRef\nEnd\nMsgs.0 = iMsgs\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- process the resulting report11.                                 -*/\n/*-------------------------------------------------------------------*/\nProcess_Report11_Proc:\n\nProcs.0 = 0\nIf iRpt > Rpt.0 Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 11 Missing.'\n  Return\nEnd\nIf Substr(Rpt.iRpt,41,11) <> ' REPORT 11 ' Then Do\n  If TraceIt = 'Y' Then Say 'REPORT 11 Missing.'\n  Return\nEnd\n\nIf TraceIt = 'Y' Then Do\n  Say TraceHead\n  Say 'Processing Proc Report'\nEnd\n\niProcs = 0\nDone = 'N'\nPending = 'N'\nDo iRpt = iRpt + 1 To Rpt.0\n  If Substr(Rpt.iRpt,2,1) = '*' & ,\n    Substr(Rpt.iRpt,41,8) = ' REPORT ' Then Leave\n  If Substr(Rpt.iRpt,2,17) = 'SYMBOLICS DEFINED' Then Done = 'Y'\n  If Done = 'Y' Then Iterate\n\n  Parse Var Rpt.iRpt 2 Proc 10 22 Proclib 68 ProcRef\n  If Left(Proc,1) = '*' Then Do\n    Pending = 'N'\n    Iterate\n  End\n  If Left(Proc,1) = ' ' & Proc <> '' Then Do\n    Pending = 'N'\n    Iterate\n  End\n  If ProcRef = '' Then Iterate\n\n  Proc = Strip(Proc)\n  Proclib = Strip(Proclib)\n  ProcRef = Strip(ProcRef)\n  If Proc = '' & Pending = 'N' Then Iterate\n\n  If Proc <> '' Then Do\n    If TraceIt = 'Y' Then Say '  Adding proc' Proc\n    Pending = 'Y'\n    iProcs = iProcs + 1\n    Procs.iProcs = Proc\n    Procs.iProcs.dbLib = Proclib\n    Procs.iProcs.dbRef = ''\n  End\n\n  Procs.iProcs.dbRef = Procs.iProcs.dbRef ProcRef\nEnd\nProcs.0 = iProcs\n\nIf TraceIt = 'Y' Then Do\n  Say 'Added' Procs.0 'procs.'\n  Say TraceHead\n  Say\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Set the heading stuff to check.                                 -*/\n/*-------------------------------------------------------------------*/\nWrite_Results:\n\nIf TraceIt <> 'Y' Then Return\n\nDo iDsns = 1 To Dsns.0\n  Say Dsns.iDsns 'Type:' Dsns.iDsns.dbType 'Refs:' Dsns.iDsns.dbRef\n  Refs = Dsns.iDsns.dbRef\n  Do While Words(Refs) > 0\n    Parse Var Refs iStmt Refs\n    Parse Var Stmt.iStmt '<' Source '>' '<' Pos '>' '<' Step '>' ,\n      '<' RawSeq '>'\n    Say '  Located in stmt:' iStmt 'Source:' Source 'Pos:' Pos 'Step:' Step\n  End\n  Say\nEnd\n\nDo iPgms = 1 To Pgms.0\n  Say Pgms.iPgms Pgms.iPgms.dbLib\n  Refs = Pgms.iPgms.dbRef\n  Do While Words(Refs) > 0\n    Parse Var Refs iStmt Refs\n    Parse Var Stmt.iStmt '<' Source '>' '<' Pos '>' '<' Step '>' ,\n      '<' RawSeq '>'\n    Say '  Located in stmt:' iStmt 'Source:' Source 'Pos:' Pos 'Step:' Step\n  End\n  Say\nEnd\n\nDo iProcs = 1 To Procs.0\n  Say Procs.iProcs Procs.iProcs.dbLib\n  Refs = Procs.iProcs.dbRef\n  Do While Words(Refs) > 0\n    Parse Var Refs iStmt Refs\n    Parse Var Stmt.iStmt '<' Source '>' '<' Pos '>' '<' Step '>' ,\n      '<' RawSeq '>'\n    Say '  Located in stmt:' iStmt 'Source:' Source 'Pos:' Pos 'Step:' Step\n  End\n  Say\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Set the heading stuff to check.                                 -*/\n/*-------------------------------------------------------------------*/\nRefresh_Tables:\n\n\"ADDPOP\"\n\nSTATJCK = 'In progress...'\nSTATRPT = ''\nSTATTBL = ''\n\"CONTROL DISPLAY LOCK\"\n\"DISPLAY PANEL(NJSTAT)\"\nCall Create_Jclcheck_Report\n\nSTATJCK = 'Done.'\nSTATRPT = 'In progress...'\n\"CONTROL DISPLAY LOCK\"\n\"DISPLAY PANEL(NJSTAT)\"\nCall Process_Report1_Listing\nCall Process_Report2_Merged\nCall Process_Report3_Datasets\nCall Process_Report4_Program\nCall Process_Report5_Reports\nCall Process_Report6_Error\nCall Process_Report11_Proc\n/*Call Write_Results*/\n\nSTATRPT = 'Done.'\nSTATTBL = 'In progress...'\n\"CONTROL DISPLAY LOCK\"\n\"DISPLAY PANEL(NJSTAT)\"\nCall Create_Tables\n\n\"REMPOP\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- create the tables.                                              -*/\n/*-------------------------------------------------------------------*/\nCreate_Tables:\n\nIf StackedCall = 'Y' Then Do\n  Call Empty_Table TabDsn\n  Call Empty_Table TabPgm\n  Call Empty_Table TabProc\n  Call Empty_Table TabMsg\n  Call Empty_Table TabPrt\n  Call Load_Tables\n  Return\nEnd\n\n\"LIBDEF ISPTLIB DATASET ID(\"DsnTab\") STACK\"\n\"LIBDEF ISPTABL DATASET ID(\"DsnTab\") STACK\"\n\n\"TBCREATE\" TabDsn \"NAMES(DSN DD TYPE DISP STEP SOURCE POS RAWSEQ) NOWRITE\"\n\"TBCREATE\" TabPgm \"NAMES(PGM LIB STEP SOURCE POS RAWSEQ) NOWRITE\"\n\"TBCREATE\" TabProc \"NAMES(PROC LIB STEP SOURCE POS RAWSEQ) NOWRITE\"\n\"TBCREATE\" TabMsg \"NAMES(MSG TEXT1 TEXT2 STEP SOURCE POS RAWSEQ) NOWRITE\"\n\"TBCREATE\" TabPrt \"NAMES(DD CLASS FORM WTR DEST STEP SOURCE POS RAWSEQ) NOWRITE\"\n\nCall Load_Tables\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- empty an existing table                                         -*/\n/*-------------------------------------------------------------------*/\nEmpty_Table:\nArg EmptyTable\n\n\"TBBOTTOM\" EmptyTable \"NOREAD\"\nDo Forever\n  \"TBDELETE\" EmptyTable\n  If RC > 0 Then Leave\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- load up the tables                                              -*/\n/*-------------------------------------------------------------------*/\nLoad_Tables:\n\nDo iDsns = 1 To Dsns.0\n  DSN = Dsns.iDsns\n  TYPE = Dsns.iDsns.dbType\n  Refs = Dsns.iDsns.dbRef\n  Do While Words(Refs) > 0\n    Parse Var Refs iStmt Refs\n    Select\n      When iStmt = Dsns.iDsns.dbDef & iStmt = Dsns.iDsns.dbDel Then ,\n        DISP = 'DEF/DEL'\n      When iStmt = Dsns.iDsns.dbDef Then DISP = 'DEFINE'\n      When iStmt = Dsns.iDsns.dbDel Then DISP = 'DELETE'\n      Otherwise DISP = 'REFER'\n    End\n    iStmt = Strip(iStmt,'T','.')\n    Parse Var Stmt.iStmt '<' SOURCE '>' '<' POS '>' '<' STEP '>' ,\n      '<' RAWSEQ '>'\n    If Left(Imag.iStmt,2) = '//' Then Do\n      DD = Word(Imag.iStmt,1)\n      If Pos('.',DD) > 0 Then Parse Var DD '.' DD\n      Else DD = Strip(DD,'L','/')\n    End\n    Else DD = ''\n    \"TBADD\" TabDsn\n  End\nEnd\n\"TBSORT\" TabDsn \"FIELDS(RAWSEQ,N,A,DSN,C,A)\"\nTabSort.TabDsn = ''\nIf TraceIt <> 'Y' Then Drop Dsns.\n\nDo iPgms = 1 To Pgms.0\n  PGM = Pgms.iPgms\n  LIB = Pgms.iPgms.dbLib\n  Refs = Pgms.iPgms.dbRef\n  Do While Words(Refs) > 0\n    Parse Var Refs iStmt Refs\n    Parse Var Stmt.iStmt '<' SOURCE '>' '<' POS '>' '<' STEP '>' ,\n      '<' RAWSEQ '>'\n    \"TBADD\" TabPgm\n  End\nEnd\n\"TBSORT\" TabPgm \"FIELDS(RAWSEQ,N,A)\"\nTabSort.TabPgm = ''\nIf TraceIt <> 'Y' Then Drop Pgms.\n\nDo iProcs = 1 To Procs.0\n  PROC = Procs.iProcs\n  LIB = Procs.iProcs.dbLib\n  Refs = Procs.iProcs.dbRef\n  Do While Words(Refs) > 0\n    Parse Var Refs iStmt Refs\n    Parse Var Stmt.iStmt '<' SOURCE '>' '<' POS '>' '<' STEP '>' ,\n      '<' RAWSEQ '>'\n    \"TBADD\" TabProc\n  End\nEnd\n\"TBSORT\" TabProc \"FIELDS(RAWSEQ,N,A)\"\nTabSort.TabProc = ''\nIf TraceIt <> 'Y' Then Drop Procs.\n\nDo iMsgs = 1 To Msgs.0\n  MSG = Msgs.iMsgs\n  TEXT1 = Left(Msgs.iMsgs.dbText,63)\n  TEXT2 = Substr(Msgs.iMsgs.dbText,64)\n  iStmt = Msgs.iMsgs.dbRef\n  Parse Var Stmt.iStmt '<' SOURCE '>' '<' POS '>' '<' STEP '>' ,\n    '<' RAWSEQ '>'\n  \"TBADD\" TabMsg\nEnd\n\"TBSORT\" TabMsg \"FIELDS(RAWSEQ,N,A)\"\nTabSort.TabMsg = ''\nIf TraceIt <> 'Y' Then Drop Msgs.\n\nDo iPrts = 1 To Prts.0\n  STEP = Prts.iPrts.dbStep\n  DD = Prts.iPrts.dbDD\n  CLASS = Prts.iPrts.dbClass\n  FORM = Prts.iPrts.dbForm\n  WTR = Prts.iPrts.dbWtr\n  DEST = Prts.iPrts.dbDest\n  iStmt = Prts.iPrts\n  Parse Var Stmt.iStmt '<' SOURCE '>' '<' POS '>' '<' STEP '>' ,\n    '<' RAWSEQ '>'\n  \"TBADD\" TabPrt\nEnd\n\"TBSORT\" TabPrt \"FIELDS(RAWSEQ,N,A)\"\nTabSort.TabPrt = ''\nIf TraceIt <> 'Y' Then Drop Prts.\n\nIf TraceIt <> 'Y' Then Do\n  Drop Job.\n  Drop Rpt.\n  Drop Imag.\n  Drop Stmt.\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- clean tables up, remove libdefs                                 -*/\n/*-------------------------------------------------------------------*/\nCleanup_Tables:\n\nIf StackedCall = 'Y' Then Return\n\n\"TBEND\" TabDsn\n\"TBEND\" TabPgm\n\"TBEND\" TabProc\n\"TBEND\" TabMsg\n\"TBEND\" TabPrt\n\n\"LIBDEF ISPTLIB\"\n\"LIBDEF ISPTABL\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- display the table so user can play                              -*/\n/*-------------------------------------------------------------------*/\nDisplay_Tables:\n\nCall Setup_Panels\n\nMYCMDS = 'PASSTHRU'\nCURSOR = 'LC'; CSRROW = 0; CSRPOS = 1; ZTDTOP = 0\nDo Forever\n  Table = Panel.iPanel.dbTable\n  \"TBTOP\" Table\n  \"TBSKIP\" Table \"NUMBER(\"ZTDTOP\") NOREAD\"\n  \"TBDISPL\" Table \"PANEL(\"Panel.iPanel\") POSITION(CRP) ROWID(ROW)\" ,\n    \"AUTOSEL(NO) CSRROW(\"CSRROW\") CURSOR(\"CURSOR\") CSRPOS(\"CSRPOS\")\"\n  If RC > 4 Then Leave\n\n  CURSOR = 'ZCMD'\n  CSRPOS = 1\n\n  If ZCMD <> '' Then Do        /* primary commands go here */\n    Upper ZCMD\n    ZCMD = Strip(ZCMD)\n    Select\n      When Left(ZCMD,3) = 'DSN' Then iPanel = 1\n      When Left(ZCMD,3) = 'PGM' Then iPanel = 3\n      When Left(ZCMD,4) = 'PROC' Then iPanel = 5\n      When Left(ZCMD,3) = 'MSG' Then iPanel = 7\n      When Word(ZCMD,1) = 'RIGHT' Then Call Shift_Display 1\n      When Word(ZCMD,1) = 'LEFT' Then Call Shift_Display -1\n      When Word(ZCMD,1) = 'SORT' Then Call Sort_Table\n      When Word(ZCMD,1) = 'REFRESH' Then Do\n        Call Cleanup_Tables\n        Call Refresh_Tables\n      End\n      When Word(ZCMD,1) = 'L' | Word(ZCMD,1) = 'LOCATE' Then ,\n        Call Locate_Line\n      When Word(ZCMD,1) = 'F' | Word(ZCMD,1) = 'FIND' Then Do\n        Parse Var ZCMD . PNLFVALU\n        PNLFBOTM = 'N'\n        Call Find_Line\n      End\n      When Word(ZCMD,1) = 'RFIND' Then Call Find_Line\n      Otherwise \"SETMSG MSG(NJ008)\"\n    End\n  End\n\n  Do While ZTDSELS > 0       /* line commands go here */\n    Upper LC\n    GotoWhich = 'LC_Goto_Source'\n    If Pos('>',LC) > 0 Then Do\n      LC = Strip(LC,'B','>')\n      GotoWhich = 'LC_Goto_Dataset'\n    End\n    If LC = 'S' Then LC = 'V'\n    If LC = '~' Then GotoWhich = 'LC_Debug_Entry'\n\n    If Length(LC) = 1 Then Interpret 'Call' GotoWhich\n    Else If LC <> '' Then \"SETMSG MSG(NJ005)\"\n\n    If ZTDSELS > 1 Then \"TBDISPL\" Table \"POSITION(CRP) ROWID(ROW)\"\n    Else ZTDSELS = 0\n    CURSOR = 'LC'\n  End\n  LC = ' '\n  \"TBGET\" Table \"POSITION(CSRROW)\"          /* place cursor properly */\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- allow user to shift left/right on the panels                    -*/\n/*-------------------------------------------------------------------*/\nSetup_Panels:\n\nPanel.1 = 'NJDSNS1'\nPanel.2 = 'NJDSNS2'\nPanel.3 = 'NJPGMS1'\nPanel.4 = 'NJPGMS2'\nPanel.5 = 'NJPROCS1'\nPanel.6 = 'NJPROCS2'\nPanel.7 = 'NJMSGS1'\nPanel.8 = 'NJMSGS2'\nPanel.9 = 'NJPRTS1'\nPanel.0 = 9\n\nPanel.1.dbTable = TabDsn\nPanel.1.dbLeft = 'Y'\nPanel.2.dbTable = TabDsn\nPanel.2.dbLeft = 'N'\nPanel.3.dbTable = TabPgm\nPanel.3.dbLeft = 'Y'\nPanel.4.dbTable = TabPgm\nPanel.4.dbLeft = 'N'\nPanel.5.dbTable = TabProc\nPanel.5.dbLeft = 'Y'\nPanel.6.dbTable = TabProc\nPanel.6.dbLeft = 'N'\nPanel.7.dbTable = TabMsg\nPanel.7.dbLeft = 'Y'\nPanel.8.dbTable = TabMsg\nPanel.8.dbLeft = 'N'\nPanel.9.dbTable = TabPrt\nPanel.9.dbLeft = 'Y'\n\n\"VGET PNLINIT PROFILE\"\nDo iPanel = 1 To Panel.0\n  If Panel.iPanel = PNLINIT Then Leave\nEnd\nIf iPanel > Panel.0 Then iPanel = 1\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- shift the display left and right                                -*/\n/*-------------------------------------------------------------------*/\nShift_Display:\n\nArg How\nIf How = -1 Then Do Until Panel.iPanel.dbLeft = 'Y'\n  iPanel = iPanel - 1\n  If iPanel < 1 Then iPanel = Panel.0\nEnd\nElse Do\n  iPanel = iPanel + 1\n  If iPanel > Panel.0 Then iPanel = 1\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- sort the table by the specified heading                         -*/\n/*-------------------------------------------------------------------*/\nSort_Table:\n\nHow = Word(ZCMD,2)\nSelect\n  When Table = TabDsn Then Do\n    If How = 'DATASET' Then How = 'DSN'\n    Else If How = 'DDNAME' Then How = 'DD'\n    Select\n      When How = 'DSN' Then ,\n        \"TBSORT\" TabDsn \"FIELDS(DSN,C,A,RAWSEQ,N,A)\"\n      When How = 'DD' Then ,\n        \"TBSORT\" TabDsn \"FIELDS(DD,C,A,RAWSEQ,N,A)\"\n      When How = 'TYPE' Then ,\n        \"TBSORT\" TabDsn \"FIELDS(TYPE,C,A,DSN,C,A,RAWSEQ,N,A)\"\n      When How = 'DISP' Then ,\n        \"TBSORT\" TabDsn \"FIELDS(DISP,C,A,DSN,C,A,RAWSEQ,N,A)\"\n      When How = 'SOURCE' Then ,\n        \"TBSORT\" TabDsn \"FIELDS(SOURCE,C,A,DSN,C,A,RAWSEQ,N,A)\"\n      When How = 'STEP' Then ,\n        \"TBSORT\" TabDsn \"FIELDS(STEP,C,A,DSN,C,A,RAWSEQ,N,A)\"\n      When How = '' Then ,\n        \"TBSORT\" TabDsn \"FIELDS(RAWSEQ,N,A,DSN,C,A)\"\n      Otherwise \"SETMSG MSG(NJ012)\"\n    End\n  End\n  When Table = TabPgm Then Do\n    If How = 'LIBRARY' Then How = 'LIB'\n    Select\n      When How = 'PGM' Then ,\n        \"TBSORT\" TabPgm \"FIELDS(PGM,C,A,RAWSEQ,N,A)\"\n      When How = 'LIB' Then ,\n        \"TBSORT\" TabPgm \"FIELDS(LIB,C,A,PGM,C,A,RAWSEQ,N,A)\"\n      When How = 'SOURCE' Then ,\n        \"TBSORT\" TabPgm \"FIELDS(SOURCE,C,A,PGM,C,A,RAWSEQ,N,A)\"\n      When How = 'STEP' Then ,\n        \"TBSORT\" TabPgm \"FIELDS(STEP,C,A,PGM,C,A,RAWSEQ,N,A)\"\n      When How = '' Then ,\n        \"TBSORT\" TabPgm \"FIELDS(RAWSEQ,N,A)\"\n      Otherwise \"SETMSG MSG(NJ012)\"\n    End\n  End\n  When Table = TabProc Then Do\n    If How = 'LIBRARY' Then How = 'LIB'\n    Select\n      When How = 'PROC' Then ,\n        \"TBSORT\" TabProc \"FIELDS(PROC,C,A,RAWSEQ,N,A)\"\n      When How = 'LIB' Then ,\n        \"TBSORT\" TabProc \"FIELDS(LIB,C,A,PROC,C,A,RAWSEQ,N,A)\"\n      When How = 'SOURCE' Then ,\n        \"TBSORT\" TabProc \"FIELDS(SOURCE,C,A,PROC,C,A,RAWSEQ,N,A)\"\n      When How = 'STEP' Then ,\n        \"TBSORT\" TabProc \"FIELDS(STEP,C,A,RAWSEQ,N,A)\"\n      When How = '' Then ,\n        \"TBSORT\" TabProc \"FIELDS(RAWSEQ,N,A)\"\n      Otherwise \"SETMSG MSG(NJ012)\"\n    End\n  End\n  When Table = TabMsg Then Do\n    Select\n      When How = 'MSG' Then ,\n        \"TBSORT\" TabMsg \"FIELDS(MSG,C,A,RAWSEQ,N,A)\"\n      When How = 'TEXT' Then ,\n        \"TBSORT\" TabMsg \"FIELDS(TEXT1,C,A,RAWSEQ,N,A)\"\n      When How = 'SOURCE' Then ,\n        \"TBSORT\" TabMsg \"FIELDS(SOURCE,C,A,RAWSEQ,N,A)\"\n      When How = 'STEP' Then ,\n        \"TBSORT\" TabMsg \"FIELDS(STEP,C,A,RAWSEQ,N,A)\"\n      When How = '' Then ,\n        \"TBSORT\" TabMsg \"FIELDS(RAWSEQ,N,A)\"\n      Otherwise \"SETMSG MSG(NJ012)\"\n    End\n  End\n  When Table = TabPrt Then Do\n    If How = 'WRITER' Then How = 'WTR'\n    Else If How = 'DDNAME' Then How = 'DD'\n    Else If How = 'C' Then How = 'CLASS'\n    Select\n      When How = 'DD' Then ,\n        \"TBSORT\" TabPrt \"FIELDS(DD,C,A,RAWSEQ,N,A)\"\n      When How = 'CLASS' Then ,\n        \"TBSORT\" TabPrt \"FIELDS(CLASS,C,A,RAWSEQ,N,A)\"\n      When How = 'FORM' Then ,\n        \"TBSORT\" TabPrt \"FIELDS(FORM,C,A,RAWSEQ,N,A)\"\n      When How = 'WTR' Then ,\n        \"TBSORT\" TabPrt \"FIELDS(WTR,C,A,RAWSEQ,N,A)\"\n      When How = 'DEST' Then ,\n        \"TBSORT\" TabPrt \"FIELDS(DEST,C,A,RAWSEQ,N,A)\"\n      When How = 'SOURCE' Then ,\n        \"TBSORT\" TabPrt \"FIELDS(SOURCE,C,A,RAWSEQ,N,A)\"\n      When How = 'STEP' Then ,\n        \"TBSORT\" TabPrt \"FIELDS(STEP,C,A,RAWSEQ,N,A)\"\n      When How = '' Then ,\n        \"TBSORT\" TabPrt \"FIELDS(RAWSEQ,N,A)\"\n      Otherwise \"SETMSG MSG(NJ012)\"\n    End\n  End\n  Otherwise Nop\nEnd\nTabSort.Table = How\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- locate a line in the table                                      -*/\n/*-------------------------------------------------------------------*/\nLocate_Line:\n\nLocateIt = Word(ZCMD,2)\nIf TabSort.Table = '' Then Return\n\"TBTOP\" Table\nInterpret TabSort.Table \"='\"LocateIt\"*'\"\n\"TBSCAN\" Table \"ARGLIST(\"TabSort.Table\") CONDLIST(GE) POSITION(CRP)\"\nIf RC > 0 Then Do\n  \"TBBOTTOM\" Table \"POSITION(CRP)\"\n  ZTDTOP = CRP\n  Return\nEnd\n\nExactMatch = 'N'\nInterpret \"If Pos(LocateIt,\"TabSort.Table\") > 0 Then ExactMatch = 'Y    '\"\nIf ExactMatch = 'Y' Then ZTDTOP = CRP\nElse ZTDTOP = CRP - 1\nIf ZTDTOP < 0 Then ZTDTOP = 0\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- find a line in the table                                        -*/\n/*-------------------------------------------------------------------*/\nFind_Line:\n\nIf PNLFVALU = '' Then Do\n  \"SETMSG MSG(NJ001)\"\n  Return\nEnd\n\nFindFrom = ZTDTOP - 1\nFindTo = 999999\nFindPos = 0\nFindVars = PNLFVARS\nIf PNLFBOTM = 'Y' Then Do\n  PNLFBOTM = 'N'\n  FindTo = FindFrom + 1\n  FindFrom = 0\nEnd\nElse If ZCURINX > 0 Then Do\n  FindVarsPos = Pos(Strip(ZCURFLD),FindVars)\n  If FindVarsPos > 0 Then Do\n    FindVars = Substr(FindVars,FindVarsPos)\n    FindPos = ZCURPOS + 1\n  End\n  Else FindPos = 0\n  \"TBSKIP\" Table \"ROW(\"ZCURINX\") POSITION(CRP)\"\n  If RC = 0 Then FindFrom = CRP - 1\nEnd\n\"TBTOP\" Table\n\"TBSKIP\" Table \"NUMBER(\"FindFrom\") POSITION(CRP)\"\n\nDo Forever\n  \"TBSKIP\" Table \"NUMBER(1) POSITION(CRP)\"\n  If RC = 8 Then Do\n    PNLFBOTM = 'Y'\n    \"SETMSG MSG(NJ002)\"\n    Return\n  End\n  If CRP > FindTo Then Do\n    PNLFBOTM = 'N'\n    \"SETMSG MSG(NJ003)\"\n    Return\n  End\n  Else Do While Words(FindVars) > 0\n    Parse Var FindVars FindVar FindVars\n    VarVal = Value(FindVar)\n    FindPos = FindPos + 1\n    FindPos = Pos(PNLFVALU,VarVal,FindPos)\n    If FindPos = 0 Then Iterate\n    PNLFBOTM = 'N'\n    ZTDTOP = CRP\n    FindFrom = CRP\n    CURSOR = FindVar\n    CSRPOS = FindPos\n    \"SETMSG MSG(NJ004)\"\n    Return\n  End\n  FindVars = PNLFVARS\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- debug an entry in the table                                     -*/\n/*-------------------------------------------------------------------*/\nLC_Debug_Entry:\n\nSelect\n  When Table = TabDsn Then Do\n    Say \"DSN=\"DSN \"TYPE=\"TYPE \"STEP=\"STEP \"SOURCE=\"SOURCE \"POS=\"POS ,\n      \"RAWSEQ=\" RAWSEQ\n    If TraceIt = 'Y' Then Do\n      Say 'iDsns='iDsns\n      Say 'Dsns.iDsns.dbType='Dsns.iDsns.dbType\n      Say 'Dsns.iDsns.dbDef='Dsns.iDsns.dbDef\n      Say 'Dsns.iDsns.dbDel='Dsns.iDsns.dbDel\n      Say 'Dsns.iDsns.dbRef='Dsns.iDsns.dbRef\n    End\n  End\n  When Table = TabPgm Then Do\n    Say \"PGM=\"PGM \"LIB=\"LIB \"STEP=\"STEP \"SOURCE=\"SOURCE \"POS=\"POS ,\n      \"RAWSEQ=\" RAWSEQ\n    If TraceIt = 'Y' Then Do\n      Say 'iPgms='iPgms\n      Say 'Pgms.iPgms.dbLib='Pgms.iPgms.dbLib\n    End\n  End\n  When Table = TabProc Then Do\n    Say \"PROC=\"PROC \"LIB=\"LIB \"STEP=\"STEP \"SOURCE=\"SOURCE \"POS=\"POS ,\n      \"RAWSEQ=\" RAWSEQ\n    If TraceIt = 'Y' Then Do\n      Say 'iProcs='iProcs\n      Say 'Procs.iProcs.dbLib='Procs.iProcs.dbLib\n    End\n  End\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- find the jcl source line that produced this table line          -*/\n/*-------------------------------------------------------------------*/\nLC_Goto_Source:\n\n\"VPUT POS SHARED\"\nSOURCE = Strip(SOURCE)\nIf SOURCE <> '(Inline)' Then Do\n  \"TBTOP\" TabProc\n  PROC = SOURCE\n  \"TBSCAN\" TabProc \"ARGLIST(PROC)\"\n  If RC > 0 Then Do\n    Say 'TBSCAN RC='RC\n    Say 'Proc' SOURCE 'not found, internal bug. Call tech support.'\n    Return\n  End\n  DsnGoto = LIB'('PROC')'\nEnd\nElse DsnGoto = DsnJob\nDsnGoto = Strip(DsnGoto,\"B\",\"'\")\n\n/* need to implement our own version of edit/view/browse so we   */\n/* can control the command table left/right stuff under our appl */\nIf LC = 'E' | LC = 'V' Then Call LC_Goto_EditView\nElse \"SELECT CMD(%FDSN '\"DsnGoto\"'\" LC\") NEWAPPL(ISR)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- go to the dataset on the table line                             -*/\n/*-------------------------------------------------------------------*/\nLC_Goto_Dataset:\n\nDsnGoto = ''\nSelect\n  When Table = TabDsn Then DsnGoto = DSN\n  When Table = TabPgm Then Do\n    LC = 'B'\n    DsnGoto = LIB'('Strip(PGM)')'\n  End\n  When Table = TabProc Then DsnGoto = LIB'('Strip(PROC)')'\n  Otherwise Nop\nEnd\nIf DsnGoto = '' | Left(DsnGoto,1) = '&' Then Do\n  \"SETMSG MSG(NJ011)\"\n  Return\nEnd\n\n\"SELECT CMD(%FDSN '\"DsnGoto\"'\" LC\") NEWAPPL(ISR)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- edit/view the dataset on the table line                         -*/\n/*-------------------------------------------------------------------*/\nLC_Goto_EditView:\n\n\"CONTROL DISPLAY SAVE\"\n\"CONTROL ERRORS RETURN\"\nMYCMDS = ''\nIf LC = 'E' Then GotoType = 'EDIT'\nElse GotoType = 'VIEW'\n\nGoToType \"DATASET('\"DsnGoto\"') MACRO(NJEDIT)\"\nSaveRC = RC\nMYCMDS = 'PASSTHRU'\n\"CONTROL ERRORS CANCEL\"\n\"CONTROL DISPLAY RESTORE\"\n\nIf SaveRC > 8 Then Do\n  TERRLM = ZERRLM\n  Upper TERRLM\n  Pos = Pos('PRESS HELP',TERRLM)\n  If Pos > 0 Then ZERRLM = Left(ZERRLM,Pos-1)\n  TERRLM = ZERRLM\n  Upper TERRLM\n  Pos = Pos('ENTER HELP',TERRLM)\n  If Pos > 0 Then ZERRLM = Left(ZERRLM,Pos-1)\n  \"SETMSG MSG(NJ007)\"\nEnd\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NJCHECK": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x05\\x01\\x03\"_\\x01\\x04\\x05_\\x132\\x00 \\x00!\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2003-08-13T00:00:00", "modifydate": "2004-02-24T13:32:05", "lines": 32, "newlines": 33, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* this is a customized copy of caz1tjck supplied by ca   */\nArg Dsn Parm\n\n\"ALLOC F(SYSIN) DA(\"Dsn\") SHR REUS\"\n\"ALLOC F(SYSTERM) DA(*) REUS\"\n/*--------------------------------------------------------*/\n/*   if you have installed tlms support you need to       */\n/*   allocate the vmf file to your session to use tlms    */\n/*   option. change the following comment to reflect      */\n/*   the proper tlms file and uncomment it or else alloc  */\n/*   the vmf to your tso session at logon time.           */\n/*ALLOC FI(CAIVMFI) DA('XXXX.CAI.TLMS.VMF') SHR           */\n/*--------------------------------------------------------*/\n\n/*--------------------------------------------------------*/\n/* this assumes that jclcheck is in lla. you will have to */\n/* adjust this to call the proper library if necessary.   */\n/* review the jclcheck options to match your environ.     */\n/*--------------------------------------------------------*/\n\"CALL *(JCLCHECK) 'AUTOPROC HCD TLMS(54) SMS VSAM TSOE\" Parm\"'\"\n\n/*--------------------------------------------------------*/\n/*   if you have installed tlms support you need to       */\n/*   free the vmf file after checking the jcl.            */\n/*   if you have it preallocated don't worry about it.    */\n/*FREE FI(CAIVMFI)                                        */\n/*--------------------------------------------------------*/\n\"ALLOC F(SYSIN) DA(*) REUSE\"\n\"ALLOC F(SYSTERM) DA(*) REUSE\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NJEDIT": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00)\\x01\\x03\"o\\x01\\x04\\x05_\\x15D\\x00\\x0e\\x00\\x07\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2003-08-14T00:00:00", "modifydate": "2004-02-24T15:44:29", "lines": 14, "newlines": 7, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*********************************************************************/\n/* used with the nj command to locate a particular line in an edit   */\n/*********************************************************************/\nAddress ISPEXEC\n\"VGET POS SHARED\"\nIf RC > 0 Then Return\n\"VERASE POS SHARED\"\n\nAddress ISREDIT\n\"MACRO\"\n\"CURSOR =\" POS 1\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NJEDRPT": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00F\\x01\\x03#/\\x01\\x04\\x05_\\x12V\\x00M\\x00/\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2003-08-20T00:00:00", "modifydate": "2004-02-24T12:56:46", "lines": 77, "newlines": 47, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*********************************************************************/\n/* used by the nj command to chop up the jclcheck reports.           */\n/*********************************************************************/\nAddress ISREDIT\n\"MACRO\"\n\"(LAST) = LINENUM .ZLAST\"\nIf LAST = 0 Then Do\n  Say 'No report generated from JCLCHECK. Aborting.'\n  Return\nEnd\n\n\"FIND ' REPORT 1 ' FIRST\"\n\"(LINE) = LINENUM .ZCSR\"\nDo LINE - 1\n  \"DELETE 1\"\nEnd\n\n\"FIND 'SYMBOLICS DEFINED ' 2 FIRST\"\nIf RC = 0 Then Do\n  \"(LINE1) = LINENUM .ZCSR\"\n  If LINE1 > 0 Then Do\n    \"FIND '******************' 2 NEXT\"\n    \"(LINE2) = LINENUM .ZCSR\"\n    Do LINE2 - LINE1\n      \"DELETE\" LINE1\n    End\n  End\nEnd\n\n/* exclude all the jclcheck headings */\n\"X '           PAGE    ' 2 ALL\"\n\"X 'CA-JCLCHECK' 2 ALL\"\n\"X '-------------------' 2 ALL\"\n\"X '....+....1' 12 ALL\"\n\"X '  STMT  ' 2 ALL\"\n\"X '  NUM   ' 2 ALL\"\n\"X ' DSET ' 54 ALL\"\n\"X 'DSNAME         ' 2 ALL\"\n\"X 'PROGRAM   LIBRARY' 2 ALL\"\n\"X 'NAME      VOLUME ' 2 ALL\"\n\"X 'PROCEDURE   LIBRARY' 2 ALL\"\n\"X 'NAME        VOLUME ' 2 ALL\"\n\"X 'CAY6000 ' 2 ALL\"\n\"X '#####################' 2 ALL\"\n\n/* exclude all the blank lines */\n\"X '\"Copies(' ',133)\"' ALL\"\n\n/* exclude the comments from report 1 since they can change order */\n\"X ' //*' 11 ALL\"\n\"X ' //*' 37 ALL\"\n\n/* delete them */\n\"DELETE ALL X\"\n\n/* leave the first heading for each report */\n\"CURSOR = 1 1\"\n\"X 'COMPUTER ASSOCIATES' 2 ALL\"\n\"F 'COMPUTER ASSOCIATES' 2 FIRST\"\nDo Forever\n  \"F '*********************' 2 NEXT\"\n  If RC > 0 Then Leave\n  \"F 'COMPUTER ASSOCIATES' 2 NEXT\"\nEnd\n\"X '*********************' 2 ALL\"\n\n/* delete them */\n\"DELETE ALL X\"\n\n/* make the report breaks a little easier to read */\n\"C 'COMPUTER ASSOCIATES' '*******************' ALL 2\"\n\n\"SAVE\"\n\"END\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PREFDSN": {"ttr": 29, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x13\\x01\\x04\\x04O\\x01\\x04\\x04O\\x14(\\x00\\x15\\x00\\x13\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-02-13T00:00:00", "modifydate": "2004-02-13T14:28:13", "lines": 21, "newlines": 19, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*****************************************************************/\n/* this will take a fully or partially qualed dsn and return the */\n/* fully qualed name without quotes. this will allow you to man- */\n/* ipulate the dsn in other routines, and simply add the quotes  */\n/* to any tso/ispf external calls. helps to standardize how to   */\n/* handle dsns so that prefixs are added where necessary.        */\n/*****************************************************************/\nArg Dsn .\n\nIf Dsn = '' Then Return ''\n\nIf Left(Dsn,1) = \"'\" Then Do\n  Dsn = Strip(Dsn,\"B\",\"'\")\nEnd\nElse Do\n  Pref = Sysvar('SYSPREF')\n  If Pref <> '' Then Dsn = Pref\".\"Dsn\nEnd\n\nReturn Dsn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QUOTES": {"ttr": 31, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00I\\x00\\x930/\\x01\\x04\\x04?\\x158\\x00)\\x00\\x1a\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1993-10-29T00:00:00", "modifydate": "2004-02-12T15:38:49", "lines": 41, "newlines": 26, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*********************************************************************/\n/* just an edit macro to point out lines where uneven quotes are     */\n/*********************************************************************/\nReturn_Code = 0\nError_Text = 'Uneven number of quotes following this line:'\n\nAddress ISPEXEC\n\"ISREDIT MACRO\"\n\"ISREDIT RESET\"\n\"ISREDIT (LAST) = LINENUM .ZLAST\"\n\"ISREDIT UP MAX\"\n\nDo i = 1 To LAST\n  \"ISREDIT (DATA) = LINE \"i\n  Data_Temp = DATA\n  j = 0\n  Do While Pos('\"',Data_Temp) > 0\n    j = j + 1\n    Parse Var Data_Temp '\"' Data_Temp\n  End\n  If j > 0 & j // 2 > 0 Then Do\n    \"ISREDIT LINE_BEFORE \"i\" = NOTELINE '\"Error_Text\"'\"\n    Return_Code = 8\n  End\n  Data_Temp = DATA\n  j = 0\n  Do While Pos(\"'\",Data_Temp) > 0\n    j = j + 1\n    Parse Var Data_Temp \"'\" Data_Temp\n  End\n  If j > 0 & j // 2 > 0 Then Do\n    \"ISREDIT LINE_BEFORE \"i\" = NOTELINE '\"Error_Text\"'\"\n    Return_Code = 8\n  End\nEnd\n\n\"ISREDIT UP MAX\"\nIf Return_Code > 0 Then Msg_Text = 'Uneven quotes found'\nElse Msg_Text = 'No uneven quotes found'\n\"ISREDIT LINE_BEFORE 1 = MSGLINE '\"Msg_Text\"'\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RESTART": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x004\\x01\\x02\\tO\\x01\\x04\\x11\\x8f\\x16\\x03\\x00\\xf9\\x00\\xfe\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2002-04-04T00:00:00", "modifydate": "2004-04-27T16:03:34", "lines": 249, "newlines": 254, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/******************************************************************/\n/* this exec is to be used on the iof job summary display for     */\n/* scanning the messages dataset to find out if there are any     */\n/* datasets that need to be uncataloged for a restart of the job. */\n/* by default, it scans for all datasets, but you can pass the    */\n/* dataset prefixes you want scanned for (ie '%restart shr xfer'  */\n/* to check for shr and xfer datasets. passing 'rename' as one    */\n/* of the args will set up rename commands instead of delete.     */\n/******************************************************************/\nArg ArgPrefs\nAction = 'D'\nRenPos = Pos('RENAME',ArgPrefs)\nIf RenPos > 0 Then Do\n  Action = 'R'\n  Parse Var ArgPrefs ArgPrefs1 'RENAME' ArgPrefs2\n  ArgPrefs = Strip(ArgPrefs1) Strip(ArgPrefs2)\nEnd\nArgPrefs = Strip(ArgPrefs)\n\n/******************************************************************/\n/* break out the prefixes to the ones we want to check.           */\n/******************************************************************/\nPrefs = ArgPrefs\niPref = 0\nDo While Words(Prefs) > 0\n  Parse Var Prefs Pref Prefs\n  iPref = iPref + 1\n  Pref.iPref = Strip(Pref,'T','*')\nEnd\nPref.0 = iPref\n\n/******************************************************************/\n/* check to make sure user is on correct panel.                   */\n/******************************************************************/\nAddress IOF\n\"TSICOPY NAME(HELP) TO(REXX) SECTION(PANEL)\"\nIf HELP <> 'JOBSUM' Then Do\n  Say \"You must be on the 'IOF Job Summary' panel to run RESTART.\"\n  Return\nEnd\n\n/******************************************************************/\n/* get the jobname for the comment section of the job.            */\n/******************************************************************/\n\"1\"\n\"TSICOPY NAME(JOBNAME JOBID) TO(REXX) SECTION(PANEL)\"\n\"END\"\nJOBID = 'J'Right(JOBID,5)                    /* shorten the jobid */\n\n/******************************************************************/\n/* go to the job message dataset and read it in.                  */\n/******************************************************************/\n\"3 ALLOC DDNAME(MESSAGES)\"\nAddress TSO\n\"EXECIO * DISKR MESSAGES (STEM Msg. FINIS\"\n\"FREE F(MESSAGES)\"\n\n/******************************************************************/\n/* scan thru and check for cataloged messaqes, save the dsns.     */\n/******************************************************************/\niDsn = 0\niStep = 0\nDo iMsg = 1 To Msg.0\n  Parse Var Msg.iMsg Msgid .\n  Select\n    When Msgid = 'IEF236I' Then Do\n      Dsn.iStep.0 = iDsn\n      iDsn = 0\n      Parse Var Msg.iMsg . . . . PStep JStep\n      If JStep <> '' Then ,\n        Step = ' JOB STEP:' JStep ' PROC STEP:' PStep\n      Else Step = ' JOB STEP:' PStep\n      iStep = iStep + 1\n      Step.iStep = Step\n      Iterate\n    End\n    When Msgid = 'DSN' Then Do\n      Dsn = Word(Msg.iMsg,2)\n      If Left(Dsn,1) <> '(' Then Iterate\n      Parse Var Dsn '(' Dsn ')'\n      Dsn = Strip(Dsn)\n    End\n    When Msgid = 'IGD108I' Then Do\n      Parse Var Msg.iMsg . Dsn Disp ','\n      If Disp <> 'CATALOGED' Then Iterate\n    End\n    When Msgid = 'IEF285I' Then Do\n      If Word(Msg.iMsg,3) <> 'CATALOGED' Then Iterate\n      Dsn = Word(Msg.iMsg,2)\n    End\n    Otherwise Iterate\n  End\n  /****************************************************************/\n  /* check to ensure this isn't a work dsn.                       */\n  /****************************************************************/\n  If Left(Dsn,3) = 'SYS' Then Do\n    Parse Var Dsn 'SYS' Date '.T' Time '.'\n    If Length(Date) = 5 & Length(Time) = 6 & ,\n      Datatype(Date) = 'NUM' & Datatype(Time) = 'NUM' Then Iterate\n  End\n  /****************************************************************/\n  /* see if the dsn extracted matches one of the prefixes.        */\n  /****************************************************************/\n  If Pref.0 > 0 Then Do iPref = 1 To Pref.0\n    If Pos(Pref.iPref,Dsn) = 1 Then Do\n      iDsn = iDsn + 1\n      Dsn.iStep.iDsn = Strip(Dsn)\n      Leave\n    End\n  End\n  Else Do\n    iDsn = iDsn + 1\n    Dsn.iStep.iDsn = Strip(Dsn)\n  End\nEnd\nStep.0 = iStep\nDsn.iStep.0 = iDsn\n\n/******************************************************************/\n/* if there were no dsns found, there is nothing further to do.   */\n/******************************************************************/\nTotal = 0\nDo iStep = 1 To Step.0\n  Total = Total + Dsn.iStep.0\nEnd\n\nIf Total = 0 Then Do\n  If ArgPrefs = '' Then ,\n    Say 'There were no datasets found.'\n  Else Say 'There were no datasets that began with' ArgPrefs'.'\n  Return\nEnd\n\n/******************************************************************/\n/* build an idcams job to delete the found datasets. if the user  */\n/* has a valid job card in the list/log panel, use it, otherwise  */\n/* build a default job card.                                      */\n/******************************************************************/\nAddress IOF\nOut.0 = 0\nDo i = 1 To 4\n  \"TSICOPY NAME(ZLLGJOB\"i\") FROM(DIALOG) TO(REXX)\"\n  Jc = Value(\"ZLLGJOB\"i)\n  If RC > 0 | Jc = '' Then Leave\n  If Left(Jc,3) = '//*' Then Iterate\n  If Pos(\" JOB \",Jc) > 0 Then Do\n    Parse Var Jc ' JOB ' '(' Account ')'\n    If Account = \"\" Then Parse Var Jc \" JOB \" \"'\" Account \"'\"\n    Parse Var Account Account ','\n    /* adjust this to see if user has a valid account code in the */\n    /* job card. don't want to accept a default job card.         */\n    If Length(Account) <> 7 Then Leave\n  End\n  Call AddCard Jc\nEnd\n\n/******************************************************************/\n/* the user didn't have a valid job card, build the default.      */\n/******************************************************************/\nIf Out.0 = 0 Then Do\n  Name = Sysvar('SYSUID') || Action\n  Call AddCard \"//\"Name \"JOB (1005302),'DELETE/RENAME FILES',\"\n  Call AddCard \"//         MSGCLASS=X,CLASS=A\"\nEnd\n\n/******************************************************************/\n/* build the idcams step.                                         */\n/******************************************************************/\nCall AddCard \"//*\"\nCall AddCard \"//*  RESTART PROCESSING FOR JOB:\" JOBNAME \"JOBID:\" JOBID\nCall AddCard \"//*\"\nCall AddCard \"//DELREN   EXEC PGM=IDCAMS\"\nCall AddCard \"//SYSPRINT  DD  SYSOUT=*\"\nCall AddCard \"//SYSIN     DD  *\"\n\n/******************************************************************/\n/* add the datasets to delete.                                    */\n/******************************************************************/\nLlq = 'D'Left(DATE('O'),2) || ,\n   Substr(Date('O'),4,2) || ,\n   Right(Date('O'),2)\n\nDo iStep = 1 To Step.0\n  If Dsn.iStep.0 > 0 Then\n    Call AddCard \"  /* DSNS FROM\" Step.iStep \"*/\"\n  Do iDsn = 1 To Dsn.iStep.0\n    DsnStatus = Strip(Left(Sysdsn(\"'\"Dsn.iStep.iDsn\"'\"),20))\n    If DsnStatus <> 'OK' & DsnStatus <> 'VOLUME NOT ON SYSTEM' Then ,\n      Call AddCard \"  /* !!!!! STATUS FOR THE FOLLOWING IS:\" DsnStatus \"*/\"\n    If Action = 'R' Then Do\n      Call AddCard \"  ALTER\" Dsn.iStep.iDsn \"-\"\n      NewDsn = Dsn.iStep.iDsn\".\"Llq\n      If Length(NewDsn) > 44 Then\n        Call AddCard \"  /*     !!!!! THE FOLLOWING DSN IS TOO LONG */ -\"\n      Call AddCard \"    NEWNAME(\"NewDsn\")\"\n    End\n    Else Call AddCard \"  DELETE\" Dsn.iStep.iDsn\n  End\n  If Dsn.iStep.0 > 0 Then Call AddCard \" \"\nEnd\n\n/******************************************************************/\n/* finish job                                                     */\n/******************************************************************/\nCall AddCard \"/*\"\nCall AddCard \"//\"\n\n/******************************************************************/\n/* build a temp file to write out the job.                        */\n/******************************************************************/\nOutFile = \"'\"Sysvar('SYSUID')\".RESTART.T\"Time(Seconds)\"'\"\nx = Msg('OFF')\n\"DELETE\" OutFile\nx = Msg(x)\n\nAddress TSO\n\"ALLOC F(OUT) DA(\"OutFile\") NEW CATALOG\" ,\n  \"SPACE(3 2) TRACKS\" ,\n  \"LRECL(80) DSORG(PS) RECFM(F B)\"\n\"EXECIO * DISKW OUT (STEM Out. FINIS)\"\n\"FREE F(OUT)\"\n\n/******************************************************************/\n/* edit it and delete the temp file, user must submit it.         */\n/******************************************************************/\nAddress IOF\n\"TSIEXEC SELECT CMD(%FDSN \"OutFile\" E) NEWAPPL(ISR)\"\n\nAddress TSO\nx = Msg('OFF')\n\"DELETE\" OutFile\nx = Msg(x)\n\nAddress IOF\n\"TSIMSG INFO 'Complete' 'The restart command is complete'\"\nRC = 0\nReturn 0\n/******************************************************************/\n/* add a card to the job cards deck.                              */\n/******************************************************************/\nAddCard:\nArg Card\n\niOut = Out.0 + 1\nOut.0 = iOut\nOut.iOut = Card\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAVELIB": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00D\\x01\\x03\\x18O\\x01\\x04\\x04o\\x131\\x00G\\x00\\x89\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2003-07-03T00:00:00", "modifydate": "2004-02-15T13:31:44", "lines": 71, "newlines": 137, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg InLib Echo .\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall Main_Routine\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\nSay '*** Library copy failed!'\nReturn\n/*-------------------------------------------------------------------*/\n/*- This will save a library to libname.savelib. it's a quick and   -*/\n/*- dirty copy of a lib.                                            -*/\n/*-------------------------------------------------------------------*/\nMain_Routine:\n\nInLib = PrefDsn(InLib)\nOutLib = InLib\".SAVED\"\nIf Length(OutLib) > 44 Then Do\n  Say '*** Length of output library > 44 chars. Do it manually.'\n  Signal Failure\nEnd\nCall Check_Lib\n\nIf Sysdsn(\"'\"OutLib\"'\") <> 'DATASET NOT FOUND' Then Do\n  \"DELETE '\"OutLib\"'\"\n  If RC <> 0 Then Signal Failure\nEnd\n\n\"ALLOC F(SYSUT1) DA('\"InLib\"') SHR REU\"\n\"ALLOC F(SYSUT2) DA('\"OutLib\"') NEW CATALOG LIKE('\"InLib\"')\"\n\"ALLOC F(SYSIN) DA(ISPST2) NEW DELETE REU\" ,\n  \"UNIT(TEST)   SPACE(1)   TRACKS\" ,\n  \"LRECL(80)    DSORG(PS)  RECFM(F B)\"\nIf Echo = '' Then \"ALLOC F(SYSPRINT) DUMMY REU\"\nElse \"ALLOC F(SYSPRINT) DA(*) REU\"\n\nQueue '  COPY  I=((SYSUT1,R)),O=SYSUT2'\n\"EXECIO 1 DISKW SYSIN (FINIS\"\n\"TSOEXEC CALL *(IEBCOPY)\"\nSaveRC = RC\n\"FREE F(SYSUT1 SYSUT2 SYSIN SYSPRINT)\"\nIf SaveRC > 4 Then Signal Failure\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- Double check that we're dealing with a valid lib                -*/\n/*-------------------------------------------------------------------*/\nCheck_Lib:\n\nAddress TSO\nCC = Listdsi(\"'\"InLib\"'\")\nIf CC > 0 Then Do\n  Say \"ListDsi failed for '\"InLib\"', CC=\"CC\", SYSREASON=\"SYSREASON\n  Signal Failure\nEnd\nIf SYSDSORG <> 'PO' Then Do\n  Say 'DSORG value of' SYSDSORG 'must be PO'\n  Signal Failure\nEnd\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCREENS": {"ttr": 259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x02$\\x1f\\x01\\x02$\\x1f\\x14\\x10\\x00!\\x00!\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-08-29T00:00:00", "modifydate": "2002-08-29T14:10:53", "lines": 33, "newlines": 33, "modlines": 0, "user": "MA133"}, "text": "/* REXX - exec to list all active ISPF screens by name            */\n/* scammed and altered from a bunch of examples from:             */\n/* http://listserv.nd.edu/archives/ispf-l.html                    */\nAddress ISPEXEC\n\"VGET ZSCREEN SHARED\"\n\nTcb = Ptr(132+Ptr(540))       /* current ISPTASK TCB              */\nTcb = Ptr(Tcb+132)            /* ISPMAIN  tcb via tcbotc          */\nTcb = Ptr(Tcb+136)            /* ISPTASK  tcb via tcbltc          */\nDo While Tcb \\= 0\n  Parse Value Tldname(Tcb) With ScrNum ScrName\n  If ScrNum = ZSCREEN Then Active = '*'\n  Else Active = ''\n  Say 'TCB='d2x(Tcb) 'Screen number='ScrNum 'Screen name='ScrName Active\n  Tcb = Ptr(128+Tcb)          /* chain thru tcbntc                */\nEnd\nReturn\n\nTldname: Procedure\nSaveArea = Ptr(112+Arg(1))    /* get save area off tcb            */\nIf Storage(d2x(SaveArea+40),4) = 'ISPF' Then Do\n  R1 = Ptr(SaveArea+24)       /* reg1 is 24 into the save area    */\n  Tld = Ptr(R1)               /* reg1 is the pointer to the tld   */\n  Num = Tld+3                 /* the screen num is +3 into tld    */\n  Perm = Tld+841              /* the perm option is +841 into tld */\n  Name = Tld+852              /* the screen name is +852 into tld */\n  Return Translate(Storage(d2x(Num),1),' ','00'x) ,\n    Translate(Storage(d2x(Name),8),' ','00'x) ,\n    Translate(Bitand(Storage(d2x(Perm),1),'80'x),'PT','8000'x)\nEnd\nReturn ' '\n\nPtr: Return c2d(Bitand(Storage(d2x(Arg(1)),4),'7FFFFFFF'x))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SORTTB": {"ttr": 261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01.\\x00F\\x00\\x94\\x08_\\x01\\x04\\x04o\\x14\\x03\\x00|\\x00\\x16\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.46", "flags": 0, "createdate": "1994-03-26T00:00:00", "modifydate": "2004-02-15T14:03:46", "lines": 124, "newlines": 22, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*-------------------------------------------------------------------*/\n/* This sort routine is a generic routine that allows table sorting  */\n/* on all fields in a table. The table is queried to get a list of   */\n/* keys and names, and a temporary table is created to display them  */\n/* in a popup window. From here, the user may specify either 'A' for */\n/* ascending or 'D' for descending for each field.                   */\n/*-------------------------------------------------------------------*/\nArg Tab_Name\n\nSignal On Failure Name Exec_Failure\nSignal On Syntax  Name Exec_Failure\nSignal On Novalue Name Exec_Failure\n\nAddress TSO\n\"ALLOCATE F(SORTTB) NEW DELETE\" ,\n  \"SPACE(2) TRACKS DIR(5)\" ,\n  \"DSORG(PO) RECFM(F B) LRECL(80) BLKSIZE(3120)\"\n\nCall Load_Table\nCall Display_Table\nCall Sort_Table\n\nAddress TSO\n\"FREE F(SORTTB)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- The exec failed somewhere. Make sure everything is closed.      -*/\n/*-------------------------------------------------------------------*/\nExec_Failure:\nAddress ISPEXEC\nSay 'Internal error on line' sigl'. Sort failed. RC='RC\n\"CONTROL ERRORS RETURN\"\n\"TBEND SORTTB\"\n\"LIBDEF SORTTB\"\nAddress TSO\n\"FREE F(SORTTB)\"\nExit 12\n/*-------------------------------------------------------------------*/\n/*- Load up the table with the passed table's field names.          -*/\n/*-------------------------------------------------------------------*/\nLoad_Table:\n\nAddress ISPEXEC\n\"TBCREATE SORTTB NAMES(FIELD TYPE) LIBRARY(SORTTB) NOWRITE\"\n\"CONTROL ERRORS RETURN\"\n\"TBQUERY\" Tab_Name \"KEYS(KEYS) NAMES(NAMES)\"\nIf RC > 0 Then Signal Failure\n\"CONTROL ERRORS CANCEL\"\n\nIf KEYS <> '' Then KEYS = Substr(KEYS,2,Length(KEYS)-2)  /* strip'()'*/\nIf NAMES <> '' Then NAMES = Substr(NAMES,2,Length(NAMES)-2)\nVar_List = KEYS NAMES\n\nDo While Words(Var_List) > 0\n  Parse Var Var_List Var_Field Var_List\n  FIELD = Var_Field\n  TYPE = 'C'\n  \"TBADD SORTTB\"\nEnd\n\n\"TBSORT SORTTB FIELDS(FIELD,C,A)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/* Display the table.                                                */\n/*-------------------------------------------------------------------*/\nDisplay_Table:\n\nAddress ISPEXEC\nZTDTOP = 0\nSort_Parms = ''\n\"ADDPOP ROW(8) COLUMN(55)\"\nDo Forever\n  \"TBTOP SORTTB\"\n  \"TBSKIP SORTTB NUMBER(\"ZTDTOP\") NOREAD\"\n  \"TBDISPL SORTTB PANEL(SORTTB) POSITION(CRP) ROWID(ROW)\"\n  If RC > 4 Then Leave\n\n  Do While ZTDSELS > 0\n    Upper LC\n    Upper TYPE\n    Select\n      When LC = 'A' Then Call Update_Sort LC\n      When LC = 'D' Then Call Update_Sort LC\n      Otherwise \"TBPUT SORTTB\"\n    End\n    If ZTDSELS > 1 Then \"TBDISPL SORTTB POSITION(CRP) ROWID(ROW)\"\n    Else ZTDSELS = 0\n  End\n  LC = ' '\n\nEnd\n\"TBCLOSE SORTTB LIBRARY(SORTTB)\"\n\"LIBDEF SORTTB\"\n\"REMPOP\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/* Create the sort parms based on the user's line commands.          */\n/*-------------------------------------------------------------------*/\nUpdate_Sort:\nArg Sort_Dir\n\nSort_Parms = Sort_Parms\",\"FIELD\",\"TYPE\",\"Sort_Dir\nAddress ISPEXEC\n\"TBDELETE SORTTB\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/* Sort the table that was passed, based on the users input.         */\n/*-------------------------------------------------------------------*/\nSort_Table:\n\nSort_Parms = Strip(Sort_Parms,'L',',')\nIf Sort_Parms = '' Then Return\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"TBSORT\" Tab_Name \"FIELDS(\"Sort_Parms\")\"\n\"CONTROL ERRORS CANCEL\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRCHEDIT": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x01\\x03#O\\x01\\x04\\x05_\\x15C\\x00\\x0f\\x00\\x07\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-08-22T00:00:00", "modifydate": "2004-02-24T15:43:31", "lines": 15, "newlines": 7, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*********************************************************************/\n/* used with the srchgo edit macro to position to a certain point    */\n/* in the edit member.                                               */\n/*********************************************************************/\nAddress ISPEXEC\n\"VGET POS SHARED\"\nIf RC > 0 Then Return\n\"VERASE POS SHARED\"\n\nAddress ISREDIT\n\"MACRO\"\n\"CURSOR =\" POS 1\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRCHGO": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x10\\x01\\x03#O\\x01\\x04\\t\\x9f\\x16\\x08\\x00*\\x00\"\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2003-08-22T00:00:00", "modifydate": "2004-04-08T16:08:10", "lines": 42, "newlines": 34, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*********************************************************************/\n/* used in the srchfor dialogs (usually opt 3.14). set your search   */\n/* 'output mode' (on lower right corner of the srchfor main panel)   */\n/* to 'view'. when viewing the search results, set a pfkey to        */\n/* 'srchgo view' or 'srchgo edit' and place your cursor on one of the*/\n/* found lines and hit the pfkey.                                    */\n/*********************************************************************/\nAddress ISREDIT\n\"MACRO (EDITVIEW)\"\n\"(LINE) = LINE 2\"\nParse Var LINE ' SRCH DSN: ' Dsn .\nDsn = Strip(Dsn)\nIf Dsn = '' Then Do\n  Say 'Unable to determine SRCHFOR DSN.'\n  Return\nEnd\n\n\"(CSRNUM) = LINENUM .ZCSR\"\nMember = ''\nDo iLine = CSRNUM To 1 By -1\n  \"(LINE) = LINE\" iLine\n  If Pos('STRING(S) FOUND',LINE) > 0 Then Do\n    Member = Word(LINE,1)\n    Leave\n  End\nEnd\nIf Member /= '' Then Dsn = Dsn\"(\"Member\")\"\n\n\"(LINE) = LINE .ZCSR\"\nParse Var LINE 2 Pos 9\nPos = Strip(Pos)\nIf Pos = '' Then Pos = 1\nIf Datatype(Pos,'N') = 0 Then Pos = 1\n\nIf EditView = '' Then EditView = 'V'\nEditView = Left(EditView,1)\nFDSNMAC = 'SRCHEDIT'\nAddress ISPEXEC \"VPUT (POS FDSNMAC) SHARED\"\nCall FDSN \"'\"Dsn\"'\" EditView\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STARTINI": {"ttr": 263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x07\\x01\\x02$\\x9f\\x01\\x04\\x04\\x8f\\x12\\x06\\x002\\x00\\x06\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2002-09-06T00:00:00", "modifydate": "2004-02-17T12:06:07", "lines": 50, "newlines": 6, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/*********************************************************************/\n/* used with the 'startup' exec to start a bunch of ispf screens.    */\n/* allocate a dataset called userid.SS.COMMANDS, and place in this   */\n/* dataset one line for each startup command you want started.       */\n/*********************************************************************/\nAddress TSO\nStartDsn = \"'\"Sysvar('SYSUID')\".SS.COMMANDS'\"\nIf Sysdsn(StartDsn) <> 'OK' Then Do\n  Say StartDsn 'not found.'\n  Return\nEnd\n\nIf Listdsi(StartDsn) > 4 Then Do\n  Say StartDsn '- Undetermined error.'\n  Return\nEnd\n\nIf SYSDSORG <> 'PS' Then Do\n  Say StartDsn '- Bad Dsorg ('SYSDSORG')'\n  Return\nEnd\n\n\"ALLOC F(IN) DA(\"Startdsn\") SHR REUSE\"\n\"EXECIO * DISKR IN (STEM SS. FINIS\"\n\"FREE F(IN)\"\n\nx = Outtrap('Scn.')\nCall Screens                    /* get list of active app names */\nx = Outtrap('OFF')\nDo iScn = 1 To Scn.0\n  Parse Var Scn.iScn 'Screen name=' ScnName 49 .\n  ScnName = Strip(ScnName)\n  Scn.iScn = ScnName                    /* save only screen name     */\nEnd\n\nAddress ISPEXEC\nDo iSS = 1 To SS.0\n  SS.iSS = Strip(SS.iSS)\n  Do iScn = 1 To Scn.0\n    If Scn.iScn = SS.iSS Then Do\n      Say SS.iSS 'already started.'\n      Iterate iSS\n    End\n  End\n  Say 'Starting' SS.iSS\n  \"SELECT PGM(ISPSTRT) PARM(CMD(%STARTUP\" SS.iSS\"~SWAP~END) SUSPEND)\"\nEnd\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STARTUP": {"ttr": 265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x17\\x01\\x02(\\x0f\\x01\\x04\\x05\\x0f\\x12\\x16\\x01\\xca\\x01\\xcb\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-10-07T00:00:00", "modifydate": "2004-02-19T12:16:17", "lines": 458, "newlines": 459, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\nArg Command\n\nSignal On Failure\nSignal On Syntax\nSignal On Novalue\n\nCall StartApp\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- handle any problems encountered                                 -*/\n/*-------------------------------------------------------------------*/\nFailure: Say \"Failure occured on line\" Sigl; Call Cleanup; Exit(12);\nSyntax:  Say \"Syntax error on line\"    Sigl; Call Cleanup; Exit(12);\nNovalue: Say \"Novalue used on line\"    Sigl; Call Cleanup; Exit(12);\nCleanup:\n  Address ISPEXEC\n  \"CONTROL ERRORS RETURN\"\n  RC = 0\n  Do While RC = 0\n    \"TBEND STARTUP\"\n  End\n  \"LIBDEF ISPTLIB\"\n  \"LIBDEF ISPTABL\"\nReturn\n/*-------------------------------------------------------------------*/\n/*- see the bottom of this exec for documentation                   -*/\n/*-------------------------------------------------------------------*/\nStartApp:\nAddress ISPEXEC\n\n/* to rename temp screens, put a <6 char valid scrname prefix here */\nInitPrefix = 'INIT'\nInitPrefix = Strip(Left(InitPrefix,5))  /* in case user changes */\n/* allows extra ispf command to be appended to the end of the */\n/* startup command. can't use ; as it doesn't get passed in */\nStartDelim = '~'\n\n/* if user wants to edit table, make it so */\nIf Command = '/' Then Do     /* edit the table if / passed */\n  Call EditTable\n  Return\nEnd\n\n/* get a couple of vars for later use */\n\"VGET (ZSCRCUR ZSCRMAX ZDEL)\"\n\n/* get the current list of screens for later use */\nCall LoadScreens\n\n/* no parms passed, do swap list */\nIf Command = '' Then Do\n  Swap = \"SWAP LIST\"\n  \"DISPLAY PANEL(ISPBLANK) COMMAND(SWAP)\"\n  Return\nEnd\n\n/* the following allows you to append extra ispf command to the end  */\n/* of your startup command. the ~ is used in place of the ispf delim */\nParse Var Command Command (StartDelim) Parms\nParms = Translate(Parms,ZDEL,StartDelim)\n\n/* convert the command to app name */\nCall GetAppName\nIf AppName = 'LIST' | AppName = 'PREV' | AppName = 'NEXT' Then ,\n  AppName = AppName'1'\n\n/* go thru the screens to see if there an active match */\nDo iScn = 1 To Scn.0              /* from the LoadScreens rtn      */\n  If Scn.iScn <> AppName Then Iterate\n  Swap = \"SWAP\" AppName || ZDEL || Parms\n  \"DISPLAY PANEL(ISPBLANK) COMMAND(SWAP)\"  /* yup, swap to it.     */\n  Return\nEnd\n\nIf ZSCRCUR = ZSCRMAX Then Do\n  Say 'You have reached the maximum # of sessions ('Strip(ZSCRMAX)').'\n  Say 'Quit one of your other sessions before starting this one.'\n  Say 'A session list will now be displayed...'\n  Swap = \"SWAP LIST\"\n  \"DISPLAY PANEL(ISPBLANK) COMMAND(SWAP)\"\n  Return\nEnd\n\nCall TableLookaside               /* convert app name to command   */\n\n\"SELECT PGM(ISPSTRT)\" ,\n  \"PARM(\"Command || ZDEL ,\n    \"SCRNAME\" AppName \"PERM\"ZDEL ,\n    \"SCRNAME ON\"ZDEL ,\n    Parms\")\" ,\n  \"SUSPEND MODE(FSCR)\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- convert the passed parm to the command on the lookaside table   -*/\n/*-------------------------------------------------------------------*/\nTableLookaside:\n\nCall LibdefProfile             /* libdef the ispprof */\n\"CONTROL ERRORS RETURN\"\n\"TBOPEN STARTUP NOWRITE\"       /* see if there's a table */\nIf RC = 0 Then Do\n  \"TBVCLEAR STARTUP\"\n  TabName = AppName\n  \"TBGET STARTUP\"              /* find a match, load the command */\n  If RC = 0 Then Command = TabCmd\n  \"TBEND STARTUP\"\nEnd\n\"LIBDEF ISPTLIB\"               /* done */\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- convert the command to an acceptable screen name.               -*/\n/*-------------------------------------------------------------------*/\nGetAppName:\n\nParse Var Command \"PGM(\" AppName \")\"   /* use the pgm   name */\nIf AppName <> '' Then Return\n\nParse Var Command \"PANEL(\" AppName \")\" /* use the panel name */\nIf AppName <> '' Then Return\n\nParse Var Command \"CMD(\" AppName \")\"   /* use the cmd name   */\nAppName = Word(AppName,1)              /* remove the cmd parms */\nAppName = Translate(AppName,' ','%')   /* remove invalid scn chars */\nIf AppName <> '' Then Return\n\nAppName = Command                      /* have to scam a screen name*/\nIf Left(AppName,4) = 'TSO ' Then ,     /* strip off tso prefix */\n  AppName = Strip(Substr(AppName,4))\n\nAppName = Translate(AppName,' ',ZDEL)  /* get rid of semicolon */\nAppName = Word(AppName,1)              /* just get the command */\n\nAppName = Translate(AppName,'  ','%.') /* these aren't cool */\nDo While Words(AppName) > 1            /* slam it into one word */\n  Parse Var AppName Prefix Suffix\n  AppName = Prefix || Suffix\nEnd\n                                       /* numbers aren't cool */\nIf Datatype(Left(AppName,1)) = 'NUM' Then AppName = 'Q'AppName\nAppName = Strip(Left(AppName,8))       /* make it 8 chars long */\nIf Length(AppName) = 1 Then AppName = 'Q'AppName  /* at least 2 chars*/\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- if there are any blank screen names, these are the initial sess -*/\n/*-------------------------------------------------------------------*/\nLoadScreens:\n\nx = Outtrap('Scn.')\nCall Screens                    /* get list of active app names */\nx = Outtrap('OFF')\n\nActive = 0\niTemp = 0                      /* make a list of temp screen names */\nDo iScn = 1 To Scn.0\n  Parse Var Scn.iScn 'Screen number=' ScnNum ,\n    ' Screen name=' ScnName 49 ScnPerm 50 51 ScnAct\n  ScnName = Strip(ScnName)\n  Scn.iScn = ScnName                    /* save only screen name     */\n  If ScnAct = '*' Then Active = ScnNum  /* save active screen number */\n  If ScnPerm = 'T' Then Do\n    iTemp = iTemp + 1\n    Temp.iTemp = ScnNum iScn\n  End\n\n  If InitPrefix = '' Then Iterate\n\n  Parse Var ScnName (InitPrefix) iScnInit .\n  If iScnInit <> '' & Datatype(iScnInit) = 'NUM' Then ,\n    ScnInit.iScnInit = ''\nEnd\nTemp.0 = iTemp\n\nIf InitPrefix = '' Then Return\n\nDo iTemp = 1 To Temp.0          /* rename the temp screens to the   */\n  Do iScnInit = 1 To ZSCRMAX    /* init names. find next avail.     */\n    If Symbol('ScnInit.'iScnInit) = 'VAR' Then Iterate\n    Parse Var Temp.iTemp ScnNum iScn .\n    Scn.iScn = InitPrefix || iScnInit   /* save new value in scn list*/\n    ScnInit.iScnInit = ''               /* mark this number unavail  */\n    Swap = \"SWAP\" ScnNum || ZDEL\"SCRNAME\" Scn.iScn \"PERM\" ,\n      ZDEL\"SWAP\" Active\n    \"DISPLAY PANEL(ISPBLANK) COMMAND(SWAP)\"\n    Leave\n  End\nEnd\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- libdef the ispf profile dataset ahead of everything else        -*/\n/*-------------------------------------------------------------------*/\nLibdefProfile:\nArg Output\n\nMsg = Msg('OFF')\nLdsi = Listdsi('ISPPROF' 'FILE' 'NODIRECTORY')  /* find prof name */\nMsg = Msg(Msg)\nIf Ldsi > 4 Then Signal Failure\nProfDsn = SYSDSNAME\n\"LIBDEF ISPTLIB DATASET ID('\"ProfDsn\"') STACK\"  /* libdef isptlib */\n\nIf Output = 'Y' Then \"LIBDEF ISPTABL DATASET ID('\"ProfDsn\"') STACK\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- edit the startup command table.                                 -*/\n/*-------------------------------------------------------------------*/\nEditTable:\n\nCall LibdefProfile 'Y'\n\"TBSTATS STARTUP STATUS1(STATUS1) STATUS3(STATUS3)\"\nIf Status3 = 2 Then Do                /* can't access table      */\n  Say 'Startup table is currently unavailable.'\n  Say 'Are you updating it in another screen?'\n  \"LIBDEF ISPTLIB\"\n  \"LIBDEF ISPTABL\"\n  Return\nEnd\n\nProfTab = ProfDsn\"(STARTUP)\"            /* see if private copy */\nSdsn = Sysdsn(\"'\"ProfTab\"'\")\nIf Sdsn <> 'OK' Then Do                 /* no private copy yet */\n  If Status1 = 1 Then Call CopyTable    /* but it exists elsewhere */\n  Else Call CreateTable                 /* brand spanking new table*/\nEnd\n\n\"TBOPEN STARTUP WRITE\"                  /* now that we have one */\nCall DisplayTable                       /* let user play        */\n\"TBCLOSE STARTUP\"                       /* then save it         */\n\"LIBDEF ISPTLIB\"\n\"LIBDEF ISPTABL\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- display the table so user can play                              -*/\n/*-------------------------------------------------------------------*/\nDisplayTable:\n\nInserting = 0\nCsrrow = 0\nZTDTOP = 0\nDo Forever\n  \"TBTOP STARTUP\"\n  \"TBSKIP STARTUP NUMBER(\"ZTDTOP\") NOREAD\"\n  \"TBDISPL STARTUP PANEL(STARTUP) POSITION(CRP) ROWID(ROW)\" ,\n    \"AUTOSEL(NO) CURSOR(TABNAME) CSRROW(\"Csrrow\")\"\n  If RC > 4 Then Leave\n\n  If ZCMD <> '' Then Do        /* primary commands go here */\n    Upper ZCMD\n    Select\n      When ZCMD = 'SORT' Then Call SORTTB 'STARTUP'\n      Otherwise Nop\n    End\n  End\n\n  Do While ZTDSELS > 0       /* line commands go here */\n    Upper LC TabName TabCmd  /* this loop allows multiple selections */\n    Select\n      When LC = 'I' Then Do  /* user inserted a new command */\n        Inserting = 1\n        \"TBVCLEAR STARTUP\"\n        \"TBADD STARTUP\"\n      End\n      When LC = 'R' Then Do  /* user repeated a command */\n        Inserting = 1\n        TabName = ''\n        \"TBADD STARTUP\"\n      End\n      When LC = 'D' Then \"TBDELETE STARTUP\"  /* user deleted */\n      Otherwise Do                           /* just hit enter */\n        If TabName = '' Then \"TBDELETE STARTUP\"\n        Else \"TBMOD STARTUP\"\n      End\n    End\n    If ZTDSELS > 1 Then \"TBDISPL STARTUP POSITION(CRP) ROWID(ROW)\"\n    Else ZTDSELS = 0\n  End\n  LC = ' '\n  TabName = ''\n  \"TBGET STARTUP POSITION(CSRROW)\"         /* place cursor properly */\n  If Inserting = 0 & RC = 0 Then \"TBDELETE STARTUP\"\n  Inserting = 0\nEnd\nTabName = ''\n\"TBGET STARTUP\"\nIf RC = 0 Then \"TBDELETE STARTUP\"\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- copy the table from isptlib concat to ispprof for private copy. -*/\n/*-------------------------------------------------------------------*/\nCopyTable:\n\n\"TBOPEN STARTUP NOWRITE\"\n\"TBCREATE STARTUP2 KEYS(TABNAME) NAMES(TABCMD) WRITE\"\n\"TBTOP STARTUP\"\n\"TBSKIP STARTUP NUMBER(1)\"\nDo While RC = 0\n  \"TBADD STARTUP2\"\n  \"TBSKIP STARTUP NUMBER(1)\"\nEnd\n\"TBEND STARTUP\"\n\"TBCLOSE STARTUP2 NAME(STARTUP)\"\n\nSay 'Copied default table to your own private library in' ProfDsn\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- create a new table from scratch.                                -*/\n/*-------------------------------------------------------------------*/\nCreateTable:\n\n\"TBCREATE STARTUP KEYS(TABNAME) NAMES(TABCMD) WRITE\"\nTabName = 'TLMS';  TabCmd = 'TSO %TLMS'\n\"TBADD STARTUP\"\nTabName = 'DSL'; TabCmd = '1.3.4'\n\"TBADD STARTUP\"\nTabName = 'SF'; TabCmd = 'U314'\n\"TBADD STARTUP\"\nTabName = 'PARM1';\nTabCmd = \"CMD(%FDSN 'SYS1.PARMLIB' E) NEWAPPL(ISR)\"\n\"TBADD STARTUP\"\n\"TBCLOSE STARTUP\"\n\nSay 'Created a new startup table in' ProfDsn\nSay 'Move this table to a common ISPTLIB library to share it with others.'\n\nReturn\n/*-------------------------------------------------------------------*/\n/*- this is an application startup exec that combines the function- -*/\n/*- ality of different shortcut techniques that are available in    -*/\n/*- ISPF. to install:                                               -*/\n/*-   > place the following entry into your site/user cmds table:   -*/\n/*-     \"SS       0 SELECT CMD(%STARTUP &ZPARM)\"                    -*/\n/*-   > place the STARTUP panel in ISPPLIB concatenation            -*/\n/*-   > STARTUP, SCREENS, and FDSN rexx execs in SYSEXEC/SYSPROC    -*/\n/*-                                                                 -*/\n/*- to use, simply enter 'SS appname' where appname is anything you -*/\n/*- can enter on the ISPF 'START' command service:                  -*/\n/*-   > an option off the main menu (1.3.4)                         -*/\n/*-   > a tso command (tso %tlms)                                   -*/\n/*-   > an ispf command from a command table                        -*/\n/*-   > an ispf dialog service (cmd(%sdsf))                         -*/\n/*-   > etc. etc.                                                   -*/\n/*-                                                                 -*/\n/*- the SS command will start the new service in a new session, and -*/\n/*- create a default screen name to match it (using the SCRNAME ISPF-*/\n/*- command). the screen name it creates depends on what command you-*/\n/*- pass to it. it must parse out of the parms a valid screen name  -*/\n/*- that it can pass to the SCRNAME command.                        -*/\n/*-   > for an option such as 1.3.4, the screen name will be Q134   -*/\n/*-   > for a tso command such as TSO %TLMS, it will be TLMS        -*/\n/*-   > for an command table command, it will be the command name   -*/\n/*-   > for a dialog service such as CMD(%SDSF), it will be SDSF    -*/\n/*-   > etc. etc.                                                   -*/\n/*- there is no attempt to make the screen name unique. if there    -*/\n/*- are duplicate names, you can override the name manually on the  -*/\n/*- newly created screen.                                           -*/\n/*-                                                                 -*/\n/*- you can switch to the session you created by issuing the same   -*/\n/*- command again, or issuing the SS command with the screen name:  -*/\n/*-   > SS 1.3.4 will take you back to the 1.3.4 screen             -*/\n/*-   > SS Q134 will also take you there                            -*/\n/*-   > SS TSO %TLMS will take you back to the tlms screen          -*/\n/*-   > SS TLMS will also take you there                            -*/\n/*-   > etc. etc.                                                   -*/\n/*- obviously, it's much easier to use the short screen name. the   -*/\n/*- command will substitute a \"SWAP xxx\" command if it finds an     -*/\n/*- active session with the same name.                              -*/\n/*-                                                                 -*/\n/*- entering 'SS' with no parameters is the same as entering the    -*/\n/*- ispf 'SWAP LIST' command. you can then see the screen names     -*/\n/*- that this command created (as well as any others you created).  -*/\n/*-                                                                 -*/\n/*- so this one 'SS' command will combine the functionality of the  -*/\n/*- ISPF START, SCRNAME, SWAP LIST, and SWAP XXX commands, all in   -*/\n/*- one easy to remember command.                                   -*/\n/*-                                                                 -*/\n/*- but that's not all. this command will also support it's own     -*/\n/*- variation of the ISPF commands table. entering 'SS /' will      -*/\n/*- bring up a table on which you can enter a screen name followed  -*/\n/*- by any valid START command parameters. the 'SS' command will    -*/\n/*- search this table for a match and if found, start the service   -*/\n/*- using the specified screen name. therefore, you could create    -*/\n/*- entries such as:                                                -*/\n/*-   > TLMS     TSO %TLMS                                          -*/\n/*-   > SDSF     CMD(%SDSF)                                         -*/\n/*-   > DSL      1.3.4                                              -*/\n/*-   > PARM1    CMD(%FDSN 'SYS1.PARMLIB' E) NEWAPPL(ISR)           -*/\n/*- then, entering 'SS TLMS' will start the tlms command, or        -*/\n/*- entering 'SS PARM1' will pop you into edit of sys1.parmlib with -*/\n/*- the correct applid, so that pfkeys will be properly set.        -*/\n/*- entering 'SS DSL' will bring you to option 1.3.4 of the main    -*/\n/*- menu (i'm assuming that this will be the dataset list panel).   -*/\n/*-                                                                 -*/\n/*- at install time, the sysprog can create a default set of        -*/\n/*- commands. the table is always saved in the ISPF profile dataset.-*/\n/*- he can then move this table to a common ISPTLIB dataset so that -*/\n/*- everyone will have access to the default. after that, if anyone -*/\n/*- enters 'SS /', the default table will be copied to that user's  -*/\n/*- ISPF profile dataset, and end up having thier own personal copy -*/\n/*- of the table which they can customize to thier heart's content. -*/\n/*-                                                                 -*/\n/*- tip: the FDSN exec is shipped with this to use as a way to      -*/\n/*- start the Edit/View/Browse ISPF service with a NEWAPPL(ISR) so  -*/\n/*- that pfkeys will be set properly. to use this in the cmd table, -*/\n/*- put \"CMD(%FDSN 'my.dataset.name' x) NEWAPPL(ISR)\"   where x is  -*/\n/*- either E V or B for Edit View or Browse. see the FDSN exec for  -*/\n/*- details on other things you can do with this command.           -*/\n/*-                                                                 -*/\n/*- tip: it's better to put a dialog service in the table such as   -*/\n/*- CMD(), PGM() or PANEL() rather than an option or command off the-*/\n/*- main menu such as 1.3.4, TSO TLMS etc. since in the first case  -*/\n/*- when you exit from the application you end the entire session,  -*/\n/*- but in the second case you'll end up on the primary menu, so    -*/\n/*- you'll have to hit end again to exit the session.               -*/\n/*-                                                                 -*/\n/*- tip: by default, this exec will rename any temp screen names    -*/\n/*- it finds whenever it's run. this will rename the initial session-*/\n/*- and any session started with the SPLIT or manual START command. -*/\n/*- this behaviour can be turned off by setting InitPrefix to null  -*/\n/*- in the StartApp routine above.                                  -*/\n/*-                                                                 -*/\n/*- tip: go into ISPF general options and turn off \"Always show     -*/\n/*- split line\" in order to put each session in a full screen.      -*/\n/*-                                                                 -*/\n/*- tip: replace any pfkey settings to use 'SWAP NEXT' instead of   -*/\n/*- 'SWAP' so you can roll thru your sessions.                      -*/\n/*-                                                                 -*/\n/*- there's lots of room for performance improvments, one being to  -*/\n/*- open the table when ispf is started. that way the table won't   -*/\n/*- have to be reopened every time, the use count will just be      -*/\n/*- bounced. if the table isn't desired, you can comment out the    -*/\n/*- call to TableLookaside at around line 60 above.                 -*/\n/*-                                                                 -*/\n/*- for questions/comments contact Robin Murray at:                 -*/\n/*-   robin_murray@maritimelife.ca (semi-permanent contract pos) or -*/\n/*-   robinmurray@cyberdude.com (permanent email address)           -*/\n/*-   tel: 902-453-7300 x4177                                       -*/\n/*-                                                                 -*/\n/*- changes:                                                        -*/\n/*- 08/29/02:                                                       -*/\n/*- > removed code to allow screen number as people want to be able -*/\n/*-   to select an option from the main screen and there is no way  -*/\n/*-   to differentiate between the option and screen id.            -*/\n/*- > changed code to rename any screen that doesn't have the perm  -*/\n/*-   option on, regardless of the initial name                     -*/\n/*- > added the 'SCRNAME ON' command when a new session is created  -*/\n/*- 08/27/02:                                                       -*/\n/*- > added code to rename the blank and dslist screens to initx    -*/\n/*- > added code to enable using 'SS n' where n is a screen number  -*/\n/*-------------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SWIMACRO": {"ttr": 515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x01\\x01\\x02\\x02\\x9f\\x01\\x04\\x04o\\x14\\x07\\x00 \\x00\\x03\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2002-01-29T00:00:00", "modifydate": "2004-02-15T14:07:01", "lines": 32, "newlines": 3, "modlines": 0, "user": "MA133"}, "text": "/* rexx */\n/* set up the environment. errors set to return to protect edit sess. */\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO\"\n\n/* only do this for the production systems.                           */\n\"VGET ZSYSID SHARED\"\nIf ZSYSID <> 'PROD' & ZSYSID /= 'IPO1' Then Return\n\n/* my own little adjustment.                                          */\nIf Sysvar('SYSUID') = 'MA133' Then ,\n  \"ISREDIT RECOVERY ON\"\n\n/* if the dataset being edited matches, autosave off.                 */\n\"ISREDIT (DATASET) = DATASET\"\nSelect\n  When DATASET = 'SYS1.PARMLIB' Then \"ISREDIT AUTOSAVE OFF\"\n  When DATASET = 'SYS1.PROCLIB' Then \"ISREDIT AUTOSAVE OFF\"\n  When DATASET = 'SHR.SMS.CNTL' Then \"ISREDIT AUTOSAVE OFF\"\n/*When DATASET = 'SYS1.VTAMLST' Then \"ISREDIT AUTOSAVE OFF\"*/\n  Otherwise \"ISREDIT AUTOSAVE ON\"\nEnd\n\nReturn\n/**********************************************************************/\n/* this edit macro is set in the ispf configuration table as the site */\n/* wide initial macro, and therefore gets called on every edit session*/\n/* that is invoked on the system. be very cautious changing this exec.*/\n/* the ispf settings are in SMP210.MASTER.ISP.CONFIG.KEYWORD.         */\n/* this macro is set up to force autosave off for certain datasets.   */\n/**********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZOOM": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x005\\x01\\x014_\\x01\\x04\\x10?\\x17#\\x00\\xd2\\x00\\xe4\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2001-12-11T00:00:00", "modifydate": "2004-04-12T17:23:35", "lines": 210, "newlines": 228, "modlines": 0, "user": "MA133"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ZPDSLIST": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x007\\x01\\x04\\x05\\x0f\\x01\\x04\\x12\\x9f\\x13\\x07\\x00+\\x00\\x12\\x00\\x00\\xd4\\xc1\\xf1\\xf3\\xf3@@@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2004-02-19T00:00:00", "modifydate": "2004-05-08T13:07:37", "lines": 43, "newlines": 18, "modlines": 0, "user": "MA133"}, "text": "$DOC                     22  2004/02/24  2004/04/09 10:17:56  MA133\n$START                   26  1994/06/03  2004/02/15 12:50:40  MA133\n$TBDISPL                 49  1994/03/27  2004/04/21 10:41:32  MA133\nAPARSTRP                 38  2003/04/25  2004/04/01 11:18:32  MA133\nCOMPRESS                108  2004/02/17  2004/04/09 10:27:08  MA133\nDELALL                  179  2004/04/28  2004/04/30 14:13:42  MA133\nDUPMEM                  165  2004/04/22  2004/04/28 15:53:31  MA133\nEACHMEM                  81  2000/08/08  2004/02/17 16:50:30  MA133\nFC                      120  2004/02/19  2004/02/20 16:21:19  MA133\nFD                       84  2004/02/13  2004/02/24 13:39:55  MA133\nFDSN                    284  2004/02/13  2004/04/08 16:07:11  MA133\nFDSNCMD                  22  2002/05/16  2004/02/15 11:51:50  MA133\nFDSNDEF                  32  2004/02/19  2004/02/19 12:44:33  MA133\nFJ                      130  2004/02/19  2004/02/20 16:21:20  MA133\nFP                      345  2004/02/19  2004/02/24 16:40:31  MA133\nFR                      158  2002/07/05  2004/04/01 12:21:43  MA133\nFS                      117  2004/02/19  2004/02/20 16:21:20  MA133\nFTPPDS                  326  2003/04/28  2004/05/08 13:02:49  MA133\nFTPPDSXR                 34  2003/04/28  2004/02/12 14:50:34  MA133\nFTPPDSXS                 11  2004/02/11  2004/03/25 12:38:51  MA133\nGDGREL                   81  2004/02/19  2004/03/10 13:08:40  MA133\nGETLINE                  51  2001/12/07  2004/02/12 15:15:04  MA133\nGO                       41  1994/11/30  2004/04/21 10:44:58  MA133\nLISTCNCT                 52  2004/04/23  2004/05/08 12:15:51  MA133\nLISTLINK                 22  2004/04/22  2004/04/23 14:10:54  MA133\nLISTLPA                  23  2004/04/22  2004/04/23 14:10:48  MA133\nLISTMEM                  44  2004/04/22  2004/04/26 16:10:27  MA133\nNJ                     1328  2003/08/14  2004/02/24 13:33:54  MA133\nNJCHECK                  32  2003/08/13  2004/02/24 13:32:05  MA133\nNJEDIT                   14  2003/08/14  2004/02/24 15:44:29  MA133\nNJEDRPT                  77  2003/08/20  2004/02/24 12:56:46  MA133\nPREFDSN                  21  2004/02/13  2004/02/13 14:28:13  MA133\nQUOTES                   41  1993/10/29  2004/02/12 15:38:49  MA133\nRESTART                 249  2002/04/04  2004/04/27 16:03:34  MA133\nSAVELIB                  71  2003/07/03  2004/02/15 13:31:44  MA133\nSCREENS                  33  2002/08/29  2002/08/29 14:10:53  MA133\nSORTTB                  124  1994/03/26  2004/02/15 14:03:46  MA133\nSRCHEDIT                 15  2003/08/22  2004/02/24 15:43:31  MA133\nSRCHGO                   42  2003/08/22  2004/04/08 16:08:10  MA133\nSTARTINI                 50  2002/09/06  2004/02/17 12:06:07  MA133\nSTARTUP                 458  2002/10/07  2004/02/19 12:16:17  MA133\nSWIMACRO                 32  2002/01/29  2004/02/15 14:07:01  MA133\nZOOM                    210  2001/12/11  2004/04/12 17:23:35  MA133\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT674/CBT.V500.FILE674.PDS/SYSEXEC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT674/CBT.V500.FILE674.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}