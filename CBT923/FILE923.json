{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013447000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 20339956, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE923.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 20339956, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 20339956, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE923.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x015\\n'", "DS1TRBAL": "b']\\x80'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xc8'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xc8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\tD\\x00\\x02\\tP\\x00\\x0b\\x00\\xbe'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\tP\\x00\\x0c\\tX\\x00\\x0b\\x00x'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Y\\x00\\x03\\x01\\x141\\x1f\\x01\\x141\\x1f\\x156\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf9@@@'", "ispf": {"version": "04.89", "flags": 0, "createdate": "2014-11-07T00:00:00", "modifydate": "2014-11-07T15:36:03", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-489"}, "text": "REGULAR CBT TAPE - VERSION 489    FILE:  923\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT489.FILE923\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 23 MEMBERS COUNTED; CUMULATIVE SIZE IS 193,195 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/07/14    15:36:03    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00B\\x01\\x14(o\\x01\\x141\\x1f\\x12B\\x00\\x98\\x00p\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2014-10-13T00:00:00", "modifydate": "2014-11-07T12:42:42", "lines": 152, "newlines": 112, "modlines": 0, "user": "JOARMC"}, "text": "SQLite 3.8.7 for z/OS UNIX\n==========================\nThis is a port of the SQLite for use on z/OS.  The files in the UNIX\ndirectory were originally downloaded from\nhttp://www.sqlite.org/download.html on 2104-10-18T20:47:00Z (18 Oct 2014\nat 10:47 p.m. GMT time).  The files in the directory are the files from\nboth the sqlite-autoconf-3080700.tar.gz and the\nsqlite-amalgamation-3080700.zip .  They were orinally downloaded to my\nLinux/Intel machine at home. I combined them there and created a tar\nfile from the combined directory contents. I then uploaded the tar file\nto z/OS. I unwound the tar file into a UNIX directory using the command:\n\npax -ofrom=iso8859-1,to=ibm-1047 -rf \"//sqlite.v3r8m7.tar\"\n\nThis port was very simple due to the dilligence of the original author,\nDr. Richard Hipp, who had already implemented the EBCDIC logic. All that\nI did was a bit of packaging and verification on z/OS UNIX.\n\nMember in this library:\n-----------------------\n$$README - You're reading it.\n$README  - The generic README for SQLite\nASMACL   - Compile and link SQLITE3A\nCOBSQLTE - COBOL copy book for SQLite functions\nCOBTEST1 - JCL to run TESTCOB1 program\nCOBTEST2 - JCL to run TESTCOB2 program\nIGYWCL   - JCL to compile and link the TESTCOB1 and TESTCOB2 programs\nLINK     - General template JCL for linking SQLite into a program.\nLINKLIB  - TSO XMIT of the LINKLIB for SQLite 3.8.7\nPAXFULL  - Compressed PAX archive of the source & compiled programs.\nPAXRUN   - Compressed PAX archive of the \"run time\" compiled programs.\nPLICB    - JCL to compile the PL/I test program.\nPLISQLTE - PL/I %INCLUDE member for SQLite 3.8.7\nSQLITE3A - Assembler source for the \"normal\" CALL interface to SQLite.\nSQLITE3O - Object code from compiling the sqlite3.c program under UNIX.\nTESTCOB1 - COBOL source code for a test.\nTESTCOB2 - COBOL source code for a test.\nTESTDB   - Binary copy of a test SQLite for z/OS data base file.\nTSTPLI1  - PL/I source code for a test.\nUNPAX    - JCL to unwind one of the PAX archives in this library.\n\nContents of PAXRUN file:\n------------------------\n./\n./lib/\n./lib/pkgconfig/\n./lib/pkgconfig/sqlite3.pc\n./lib/libsqlite3.la\n./lib/libsqlite3.a\n./bin/\n./bin/sqlite3\n./include/\n./include/sqlite3.h\n./include/sqlite3ext.h\n./share/\n./share/man/\n./share/man/man1/\n./share/man/man1/sqlite3.1\n\nContents of PAXFULL file:\n-------------------------\nsqlite-v3r8m7/\nsqlite-v3r8m7/Makefile.am\nsqlite-v3r8m7/config.sub\nsqlite-v3r8m7/aclocal.m4\nsqlite-v3r8m7/depcomp\nsqlite-v3r8m7/sqlite3.1\nsqlite-v3r8m7/configure.ac\nsqlite-v3r8m7/README\nsqlite-v3r8m7/shell.c\nsqlite-v3r8m7/INSTALL\nsqlite-v3r8m7/config.guess\nsqlite-v3r8m7/missing\nsqlite-v3r8m7/tea/\nsqlite-v3r8m7/tea/pkgIndex.tcl.in\nsqlite-v3r8m7/tea/generic/\nsqlite-v3r8m7/tea/generic/tclsqlite3.c\nsqlite-v3r8m7/tea/aclocal.m4\nsqlite-v3r8m7/tea/configure.in\nsqlite-v3r8m7/tea/README\nsqlite-v3r8m7/tea/win/\nsqlite-v3r8m7/tea/win/nmakehlp.c\nsqlite-v3r8m7/tea/win/rules.vc\nsqlite-v3r8m7/tea/win/makefile.vc\nsqlite-v3r8m7/tea/tclconfig/\nsqlite-v3r8m7/tea/tclconfig/tcl.m4\nsqlite-v3r8m7/tea/tclconfig/install-sh\nsqlite-v3r8m7/tea/Makefile.in\nsqlite-v3r8m7/tea/license.terms\nsqlite-v3r8m7/tea/configure\nsqlite-v3r8m7/tea/doc/\nsqlite-v3r8m7/tea/doc/sqlite3.n\nsqlite-v3r8m7/sqlite3.c\nsqlite-v3r8m7/sqlite3.pc.in\nsqlite-v3r8m7/ltmain.sh\nsqlite-v3r8m7/install-sh\nsqlite-v3r8m7/sqlite3.h\nsqlite-v3r8m7/Makefile.in\nsqlite-v3r8m7/sqlite3ext.h\nsqlite-v3r8m7/configure\nsqlite-v3r8m7/do_config.jcl\nsqlite-v3r8m7/do_config.sh\nsqlite-v3r8m7/do_make.jcl\nsqlite-v3r8m7/sqlite-run/\nsqlite-v3r8m7/sqlite-run/lib/\nsqlite-v3r8m7/sqlite-run/lib/pkgconfig/\nsqlite-v3r8m7/sqlite-run/lib/pkgconfig/sqlite3.pc\nsqlite-v3r8m7/sqlite-run/lib/libsqlite3.la\nsqlite-v3r8m7/sqlite-run/lib/libsqlite3.a\nsqlite-v3r8m7/sqlite-run/bin/\nsqlite-v3r8m7/sqlite-run/bin/sqlite3\nsqlite-v3r8m7/sqlite-run/include/\nsqlite-v3r8m7/sqlite-run/include/sqlite3.h\nsqlite-v3r8m7/sqlite-run/include/sqlite3ext.h\nsqlite-v3r8m7/sqlite-run/share/\nsqlite-v3r8m7/sqlite-run/share/man/\nsqlite-v3r8m7/sqlite-run/share/man/man1/\nsqlite-v3r8m7/sqlite-run/share/man/man1/sqlite3.1\nsqlite-v3r8m7/config.log\nsqlite-v3r8m7/config.status\nsqlite-v3r8m7/.libs/\nsqlite-v3r8m7/.libs/libsqlite3.lai\nsqlite-v3r8m7/.libs/libsqlite3.a\nsqlite-v3r8m7/.libs/libsqlite3.la -> ../libsqlite3.la\nsqlite-v3r8m7/Makefile\nsqlite-v3r8m7/sqlite3.pc\nsqlite-v3r8m7/sqlite3\nsqlite-v3r8m7/.deps/\nsqlite-v3r8m7/.deps/shell.Po\nsqlite-v3r8m7/.deps/sqlite3.Plo\nsqlite-v3r8m7/sqlite3.o\nsqlite-v3r8m7/libtool\nsqlite-v3r8m7/libsqlite3.la\nsqlite-v3r8m7/$UPDATES\nsqlite-v3r8m7/shell.o\nsqlite-v3r8m7/$$README.txt\nsqlite-v3r8m7/$README.txt\nsqlite-v3r8m7/ASMACL.jcl\nsqlite-v3r8m7/COBSQLTE.cpy\nsqlite-v3r8m7/COBTEST1.jcl\nsqlite-v3r8m7/COBTEST2.jcl\nsqlite-v3r8m7/IGYWCL.jcl\nsqlite-v3r8m7/LINK.jcl\nsqlite-v3r8m7/PLICB.jcl\nsqlite-v3r8m7/PLISQLTE.pli\nsqlite-v3r8m7/SQLITE3A.s\nsqlite-v3r8m7/TESTCOB1.cbl\nsqlite-v3r8m7/TESTCOB2.cbl\nsqlite-v3r8m7/TSTPLI1.pli\nsqlite-v3r8m7/UNPAX.jcl\nsqlite-v3r8m7/cobtest2-db.pax.Z\nsqlite-v3r8m7/sqlite3.lo\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$README": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00\\x10\\x01\\x13#\\x9f\\x01\\x141\\x1f\\x12P\\x00\\xc9\\x00R\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "2013-08-27T00:00:00", "modifydate": "2014-11-07T12:50:10", "lines": 201, "newlines": 82, "modlines": 0, "user": "JOARMC"}, "text": "SQLITE 3.8.7 for z/OS\n=====================\n\nSqlite is a self-contained, server-less, zero-configuration,\ntransactional SQL database engine.  This is the standard sqlite library\nwhich is available on many UNIX and Linux systems. The code was compiled\nwith almost no changes. The code is dependent on z/OS UNIX System\nServices.  The original code supports EBCDIC in addition to the normal\nASCII. This distribution has been compiled to support EBCDIC characters\nand IEEE (BFP) floating point numbers. This latter is important because\nmost other z/OS languages use the historical HFP floating point.\n\nAt present, the code only has C language bindings on z/OS.  There is a\n\"shim\" or \"stub\" HLASM interface program which can be called from COBOL\nor PL/I to access the C subroutines. It is named SQLITE3A.  The\nparameters passed into this routine are the same ones as documented in\nthe sqlite C API, except that the first parameter is a C style\nnull-delimited character string which is the name of the C subroutine to\nbe invoked. In COBOL, this is a Z'...' character string. The COBSQLTE\nand PLISQLTE members are the COBOL COPY book and PL/I %INCLUDE members\nwhich define COBOL or PL/I variables which contain these strings. In the\ncase of COBOL, the underscore characters shown in the C API names are\nreplace by a dash because an underscore is not valid in a COBOL data\nname. The variable names are in upper case, but the values are in lower\ncase, due to the fact that the C subroutine names are in lower case.\n\nSqlite 3.8.7 is documented at http://sqlite.org, and this code runs as\ndescribed there. Therefore, no futher documentation is supplied at\npresent.  When the COBOL and PL/I bindings are done, those will be\ndocumented here.\n\nThis document does _not_ attempt to teach you how to use sqlite. It\nassumes you already know how to use it, or can learn it yourself. It\ndoes attempt to explain how to use it on z/OS by showing some COBOL and\nPL/I examples. If you have a C license, I strongly suggest writing your\ncode in C. It will be more understandable to most.\n\nWish list items.\n----------------\n1. At present, the file which contains the sqlite database must reside\n   in a UNIX subdirectory. This means that the user of sqlite must have\n   an z/OS UNIX identity.  I would like to be able to use a VSAM Linear\n   Dataset for storing the sqlite data at some time. Mainly due to the\n   number of shops which have not really embraced z/OS UNIX.  This may\n   be possible using a \"shim\" sqlite VFS as documented here:\n   http://sqlite.org/vfs.html which would use a VSAM LDS as the backing\n   store for a sqlite in-memory data base.\n\n2. Write a REXX interface.\n\n3. Write a batch program based on the sqlite3 UNIX command. This would\n   allow SQL commands to be run in a step in a batch job.\n\n4. JDBC for Java access.\n\n\nMembers in this library:\n------------------------\n- $README  - This member. The README in markdown format.\n\n- ASMACL   - The JCL to compile and link the SQLITE3A assembler program.\n             It would be wise to run this to recompile SQLITE3A on your\n             system, if at all possible.\n\n- COBSQLTE - The COBOL copy book which defines various SQLITE3 related\n             variables and initializes them.  The member contains a fair\n             number of comments on how to use SQLITE3A in a COBOL\n             program to invoke each of the 204(!) different sqlite\n             subroutines.\n\n- COBTEST1 - The JCL to run the TESTCOB1 program.\n             Unless you are running z/OS 2.1, you need to recompile\n             the program before running this test job. There are LE\n             dependencies.\n\n- COBTEST2 - The JCL to run the TESTCOB2 program.\n             Unless you are running z/OS 2.1, you need to recompile\n             the program before running this test job. There are LE\n             dependencies.\n\n- IGYWCL   - The JCL to compile and link the TESTCOB1 and TESTCOB2\n             program. You really need to recompile these program on\n             your system due to possible LE dependencies.\n\n- LINK     - The JCL to link the SQLITE3 object code into a LINKLIB.\n             This composite links in the C and LE library subroutines.\n\n- LINKLIB  - XMIT copy of the SQL387.LINKLIB library containing the\n             z/OS batch executable programs: SQLITE3A, TESTCOB1, and\n             TESTCOB2. However, these program will likely only run on\n             a z/OS 2.1 system due to COBOL dependencies on LE.\n\n- PAXFULL  - This is a compressed pax archive for the entire SQLITE3\n             application, Including all source code and make\n             information.\n\n- PAXRUN   - This is a compressed pax archive containing only the files\n             needed to use SQLITE. This is really all you need if you\n             want to develop C language programs which use SQLITE.  This\n             is not needed for COBOL or HLASM programs.\n\n- PLICB    - The JCL to compile a PL/I program.\n\n- PLISQLTE - The PL/I %INCLUDE member to define and initialize a number\n             of variables to ease the use of SQLITE3A.\n\n- SQLITE3A - LE enabled HLASM subroutine which presents an API to the\n             SQLITE3 C subroutines which is designed for use by COBOL or\n             PL/I code. It is composite (statically) bound with the C\n             object code.\n             This code has not been fully tested yet and may contain\n             errors.\n\n- SQLITE3O - The object code for SQLITE to be bound into the\n             application.  This was compiled on z/OS 1.13, but the C\n             compiler options were for compatibility with z/OS 1.11 or\n             higher.\n\n- TESTCOB1 - Example Enterprise COBOL program. It is very basic.  It\n             uses the SQLITE3A stub to invoke SQLITE3 operations.\n             If you look at this, you will realize that I am very\n             \"wordy\" and am definitely not an advanced COBOL programmer.\n\n- TESTCOB2 - Example Enterprise COBOL program. It is very basic.\n             It's main example is of how to retrieve a double\n             precision floating point number, COMP-2, from an\n             sqlite data base, converting it from BFP to HFP format.\n             The table is defined like:\n             CREATE TABLE xz (int INTEGER, fd DOUBLE);\n             This table can be created and loaded from a z/OS UNIX shell\n             prompt using the \"sqlite3\" UNIX command.\n\n             From my testing, it appears that sqlite, unlike most other\n             RDMS systems is case sensitive for the names of objects\n             such as columns and tables.\n\n- TESTDB   - A pax archive which contains the testdb.sqlite3 UNIX file\n             used by the TESTCOB2 program. This needs to be restored\n             to a subdirectory (/tmp in the example code). This can be\n             done with a UNIX command sequence such as:\n\n             cd /tmp\n             pax -rzf \"//sql387.cntl(testdb)\"\n\n- TSTPLI1  - Example Enterprise PL/I program. It is very basic.\n             It is functionally equivalent to TESTCOB1.\n             This is not working at present.\n             I don't normally program in PL/I because I have never\n             worked in a shop which used it.\n\n- UNPAX    - The JCL needed to unwind either the PAXFULL or PAXRUN\n             member into a z/OS UNIX subdirectory.\n\nNotes on the SQLITE3A interface program.\n----------------------------------------\n\nNotes on how to use SQLITE3A with COBOL.\n----------------------------------------\n1. One major oddity which can be quite confusing is that the C language\n   calling sequence is quite different from the normal COBOL calling\n   sequence. This difference is why many of the parameters being passed\n   to sqlite3 _must_ be BY VALUE instead of BY REFERENCE. In particular\n   things such as integers (COMP-?) and doubles must be passed BY VALUE.\n   Character strings are passed BY REFERENCE, but generally require that\n   they be terminated with by LOW-VALUES byte. In modern COBOLs, this\n   type of string can be initialized using the Z'value' construct.\n\n2. When reading the C API documentation, the main thing to remember is\n   that when you see a varible prefixed with an ampersand, you need to\n   pass it BY REFERENCE. If you see a variable suffixed with an\n   asterisk, this indicates that the variable name in COBOL needs to be\n   defined as USAGE POINTER. This is also passed BY VALUE.\n\n3. Another critical point is that when you see a function return an\n   \"int\", which is a 32 bit integer, or a name prefixed by an asterisk,\n   you receive these into a COBOL variable by using the phrase RETURNING\n   cobol-var-name.  All other types of returned variables, such as\n   double floating point, are received by inserting a BY REFERENCE\n   phrase as the second parameter in the CALL verb's USING clause.\n   Please review TESTCOB2 for an example.\n\n4. Unlike most z/OS languages, sqlite stores floating point numbers in\n   IEEE 754 format. On the z, this is called a BFP or Binary Floating\n   Point number. After retrieving a BFP number from sqlite, you will\n   likely need to call the function \"CONVERT-BFP-TO-HFP\". Likewise,\n   before sending a value to sqlite, you need to convert it to BFP by\n   calling the \"CONVERT-HFP-TO-BFP\" function.  The former is shown in\n   the TESTCOB2 example.  My suggestion is to define BFP number in your\n   COBOL as COMP-2 variables, perhaps suffixed with -BFP. Use COMP-2 for\n   your COBOL floating point number also, not COMP-1. Both of these\n   formats use an 8 bytes for storage.\n\n\nNotes on how to use SQLITE3A with PL/I.\n---------------------------------------\nNo notes at present. Mainly due to my lack of PL/I skills.\n\n\nNote: This member is in \"markdown\" compatible format. For more\ninformation on markdown, go to\nhttp://daringfireball.net/projects/markdown/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$UPDATES": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00G\\x01\\x141\\x1f\\x01\\x141\\x1f\\x12P\\x00\\x98\\x00\\x98\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-11-07T00:00:00", "modifydate": "2014-11-07T12:50:47", "lines": 152, "newlines": 152, "modlines": 0, "user": "JOARMC"}, "text": "This source was pulled from the fossil repository at\nhttp://www.sqlite.org/cgi/src . I am actually unsure if this is 3.8.7 or\n3.8.8. . The parts of the source say 3.8.7 while other parts say 3.8.8.\n\nThis distribution does _NOT_ include any SQLite documentation. You can\nread this on the web, or download it, from http://www.sqlite.org.\nIncluding it here seems redundant.\n\n2014-10-30 - Release 3.8.7.1\n============================\n\nSQLite version 3.8.7.1 is a bug-fix release.\n\nThe primary reason for this bug-fix release is to address a problem with\nupdating the value of fields at the end of a table that were added using\nALTER TABLE ADD COLUMN. This problem 1 first appeared in the 3.8.7\nrelease.\n\nAnother minor annoyance in the 3.8.7 release was the fact that the\nAndroid build tried to use the strchrnul() function from the standard C\nlibrary but that function is not available on Android. Android builds\nhad to add -DHAVE_STRCHRNUL=0 to work around the problem. This patch\nfixes that so that Android builds should now work without any changes.\n\nThe operation of PRAGMA journal_mode=TRUNCATE has been enhanced so that\nit invokes fsync() after truncating the journal file when PRAGMA\nsynchronous=FULL. This helps to preserve transaction durability in the\ncase of a power loss occurring shortly after commit.\n\nFinally, a couple of long-standing and obscure problems associated with\nrun UPDATE and DELETE on VIEWs were fixed.\n\nThe changes from 3.8.7 are minimal.\n\n2014-10-17 - Release 3.8.7\n==========================\n\nSQLite version 3.8.7 is a regularly scheduled maintenance release.\nUpgrading from all prior versions is recommended.\n\nMost of the changes from the previous release have been\nmicro-optimizations designed to help SQLite run a little faster. Each\nindividual optimization has an unmeasurably small performance impact.\nBut the improvements add up. Measured on a well-defined workload (which\nthe SQLite developers use as a proxy for a typical application workload)\nusing cachegrind on Linux and compiled with gcc 4.8.1 and -Os on x64\nlinux, the current release does over 20% more work for the same number\nof CPU cycles compared to the previous release. Cachegrind is not a real\nCPU, and the workload used for measurement is only a proxy. So your\nperformance may vary. We expect to see about half the measured and\nreported improvement in real-world applications. 10% is less than 20%\nbut it is still pretty good, we think.\n\nThis release includes a new set of C-language interfaces that have\nunsigned 64-bit instead of signed 32-bit length parameters. The new APIs\ndo not provide any new capabilities. But they do make it easier to write\napplications that are more resistant to integer overflow\nvulnerabilities.\n\nThis release also includes a new sorter that is able to use multiple\nthreads to help with large sort operations. (Sort operations are\nsometimes required to implement ORDER BY and/or GROUP BY clauses and are\nalmost always required for CREATE INDEX.) The multi-threads sorter is\nturned off by default and must be enabled using the PRAGMA threads SQL\ncommand. Note that the multi-threaded sorter provides faster real-time\nperformance for large sorts, but it also uses more CPU cycles and more\nenergy.\n\n2014-08-15 - Release 3.8.6\n==========================\n\nSQLite version 3.8.6 is a regularly scheduled maintenance release.\nUpgrading from all previous versions is recommended.\n\nThis release contains the usual assortment of obscure bug fixes. One\nbug, however, deserves special attention. A problem appeared in the\nCREATE INDEX command beginning with version 3.8.2 (2013-12-06) that\nallowed, under some circumstances, a UNIQUE index to be created on a\ncolumn that was not unique. Once the index was created, no new\nnon-unique entries could be inserted, but preexisting non-unique entries\nwould remain. See ticket 9a6daf340df99ba93c for further information. In\naddition to fixing this bug, the PRAGMA integrity_check command has been\nenhanced to detect non-uniqueness in UNIQUE indices, so that if this bug\ndid introduce any problems in databases, those problems can be easily\ndetected.\n\nOther noteworthy changes include the addition of support for hexadecimal\nintegers (ex: 0x1234), and performance enhancements to the IN operator\nwhich, according to mailing list reports, help some queries run up to\nfive times faster.\n\nVersion 3.8.6 uses 25% fewer CPU cycles than version 3.8.0 from\napproximately one year ago, according to valgrind and the\ntest/speedtest1.c test program. On the other hand, the compiled binary\nfor version 3.8.6 is about 5% larger than 3.8.0. The size increase is\ndue in part to the addition of new features such as WITHOUT ROWID tables\nand common table expressions.\n\n2014-06-04 - Release 3.8.5\n==========================\n\nSQLite version 3.8.5 is a regularly scheduled maintenance release.\nUpgrading from the previous version is recommended.\n\nVersion 3.8.5 fixes more than a dozen obscure bugs. None of these bugs\nshould be a problem for existing applications. Nor do any of the bugs\nrepresent a security vulnerability. Nevertheless, upgrading is\nrecommended to prevent future problems.\n\nIn addition to bug fixes, the 3.8.5 release adds improvements to the\nquery planner, especially regarding sorting using indices and handling\nOR terms in the WHERE clause for WITHOUT ROWID tables. The \".system\" and\n\".once\" dot-commands were added to the command-line interface. And there\nwere enhancements to the FTS4 and RTREE virtual tables. See the change\nlog for details.\n\n2014-04-03 - Release 3.8.4.3\n============================\n\nThe optimizations added in version 3.8.4 caused some queries that\ninvolve subqueries in the FROM clause, DISTINCT, and ORDER BY clauses,\nto give an incorrect result. See ticket 98825a79ce145 for details. This\nrelease adds a one-character change to a single line of code to fix the\nproblem.\n\n2014-03-26 - Release 3.8.4.2\n============================\n\nThe code changes that resulted in the performance improvements in\nversion 3.8.4 missed a single buffer overflow test, which could result\nin a read past the end of a buffer while searching a database that is\ncorrupted in a particular way. Version 3.8.4.2 fixes that problem using\na one-line patch.\n\nWe are not aware of any problems in version 3.8.4 when working with\nwell-formed database files. The problem fixed by this release only comes\nup when reading corrupt database files.\n\n2014-03-11 - Release 3.8.4.1\n============================\n\nSQLite version 3.8.4.1 is a patch against version 3.8.4 that fixes two\nminor issues:\n\nWork around a C-preprocessor macro conflict that causes compilation\nproblems for some configurations of Visual Studio.  Adjust the cost\ncomputation for the skip-scan optimization for improved performance.\nBoth of these issues came to light within minutes of tagging the\nprevious release. Neither issue is serious but they can be annoying.\nHence, the decision was made to do a quick patch release to address both\nissues.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE923": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Y\\x00P\\x01\\x141\\x1f\\x01\\x141\\x1f\\x155\\x00\\xc4\\x00\\xc4\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf9@@@'", "ispf": {"version": "04.89", "flags": 0, "createdate": "2014-11-07T00:00:00", "modifydate": "2014-11-07T15:35:50", "lines": 196, "newlines": 196, "modlines": 0, "user": "CBT-489"}, "text": "//***FILE 923 is from John McKown and is a port of SQLITE 3.8.7     *   FILE 923\n//*           to z/OS.  The current state of this package is        *   FILE 923\n//*           described below.  This is version 3.8.7 of SQLITE.    *   FILE 923\n//*           An older version of this port can be found on CBT     *   FILE 923\n//*           File 897.                                             *   FILE 923\n//*                                                                 *   FILE 923\n//*           email:  john.archie.mckown@gmail.com                  *   FILE 923\n//*                                                                 *   FILE 923\n//*           Please look at the description below:                 *   FILE 923\n//*                                                                 *   FILE 923\n//*     SQLITE 3.8.7 for z/OS                                       *   FILE 923\n//*     =====================                                       *   FILE 923\n//*                                                                 *   FILE 923\n//*     Sqlite is a self-contained, server-less,                    *   FILE 923\n//*     zero-configuration, transactional SQL database engine.      *   FILE 923\n//*     This is the standard sqlite library which is available      *   FILE 923\n//*     on many UNIX and Linux systems. The code was compiled       *   FILE 923\n//*     with almost no changes. The code is dependent on z/OS       *   FILE 923\n//*     UNIX System Services.  The original code supports EBCDIC    *   FILE 923\n//*     in addition to the normal ASCII. This distribution has      *   FILE 923\n//*     been compiled to support EBCDIC characters and IEEE         *   FILE 923\n//*     (BFP) floating point numbers. This latter is important      *   FILE 923\n//*     because most other z/OS languages use the historical HFP    *   FILE 923\n//*     floating point.                                             *   FILE 923\n//*                                                                 *   FILE 923\n//*     At present, the code only has C language bindings on        *   FILE 923\n//*     z/OS.  There is a \"shim\" or \"stub\" HLASM interface          *   FILE 923\n//*     program which can be called from COBOL or PL/I to           *   FILE 923\n//*     access the C subroutines. It is named SQLITE3A.  The        *   FILE 923\n//*     parameters passed into this routine are the same ones       *   FILE 923\n//*     as documented in the sqlite C API, except that the          *   FILE 923\n//*     first parameter is a C style null-delimited character       *   FILE 923\n//*     string which is the name of the C subroutine to be          *   FILE 923\n//*     invoked. In COBOL, this is a Z'...' character string.       *   FILE 923\n//*     The COBSQLTE and PLISQLTE members are the COBOL COPY        *   FILE 923\n//*     book and PL/I %INCLUDE members which define COBOL or        *   FILE 923\n//*     PL/I variables which contain these strings. In the case     *   FILE 923\n//*     of COBOL, the underscore characters shown in the C API      *   FILE 923\n//*     names are replace by a dash because an underscore is        *   FILE 923\n//*     not valid in a COBOL data name. The variable names are      *   FILE 923\n//*     in upper case, but the values are in lower case, due to     *   FILE 923\n//*     the fact that the C subroutine names are in lower case.     *   FILE 923\n//*                                                                 *   FILE 923\n//*     Sqlite 3.8.7 is documented at http://sqlite.org, and        *   FILE 923\n//*     this code runs as described there. Therefore, no futher     *   FILE 923\n//*     documentation is supplied at present.  When the COBOL       *   FILE 923\n//*     and PL/I bindings are done, those will be documented        *   FILE 923\n//*     here.                                                       *   FILE 923\n//*                                                                 *   FILE 923\n//*     This document does _not_ attempt to teach you how to        *   FILE 923\n//*     use sqlite. It assumes you already know how to use it,      *   FILE 923\n//*     or can learn it yourself. It does attempt to explain        *   FILE 923\n//*     how to use it on z/OS by showing some COBOL and PL/I        *   FILE 923\n//*     examples. If you have a C license, I strongly suggest       *   FILE 923\n//*     writing your code in C. It will be more understandable      *   FILE 923\n//*     to most.                                                    *   FILE 923\n//*                                                                 *   FILE 923\n//*     Wish list items.                                            *   FILE 923\n//*     ----------------                                            *   FILE 923\n//*     1. At present, the file which contains the sqlite           *   FILE 923\n//*        database must reside in a UNIX subdirectory. This        *   FILE 923\n//*        means that the user of sqlite must have an z/OS UNIX     *   FILE 923\n//*        identity.  I would like to be able to use a VSAM         *   FILE 923\n//*        Linear Dataset for storing the sqlite data at some       *   FILE 923\n//*        time. Mainly due to the number of shops which have       *   FILE 923\n//*        not really embraced z/OS UNIX.  This may be possible     *   FILE 923\n//*        using a \"shim\" sqlite VFS as documented here:            *   FILE 923\n//*        http://sqlite.org/vfs.html which would use a VSAM        *   FILE 923\n//*        LDS as the backing store for a sqlite in-memory data     *   FILE 923\n//*        base.                                                    *   FILE 923\n//*                                                                 *   FILE 923\n//*     2. Write a REXX interface.                                  *   FILE 923\n//*                                                                 *   FILE 923\n//*     3. Write a batch program based on the sqlite3 UNIX          *   FILE 923\n//*        command. This would allow SQL commands to be run in      *   FILE 923\n//*        a step in a batch job.                                   *   FILE 923\n//*                                                                 *   FILE 923\n//*     4. JDBC for Java access.                                    *   FILE 923\n//*                                                                 *   FILE 923\n//*     Members in this library:                                    *   FILE 923\n//*     ------------------------                                    *   FILE 923\n//*     - $README  - This member. The README in markdown            *   FILE 923\n//*                  format.                                        *   FILE 923\n//*                                                                 *   FILE 923\n//*     - ASMACL   - The JCL to compile and link the SQLITE3A       *   FILE 923\n//*                  assembler program.  It would be wise to        *   FILE 923\n//*                  run this to recompile SQLITE3A on your         *   FILE 923\n//*                  system, if at all possible.                    *   FILE 923\n//*                                                                 *   FILE 923\n//*     - COBSQLTE - The COBOL copy book which defines various      *   FILE 923\n//*                  SQLITE3 related variables and initializes      *   FILE 923\n//*                  them.  The member contains a fair number       *   FILE 923\n//*                  of comments on how to use SQLITE3A in a        *   FILE 923\n//*                  COBOL program to invoke each of the 204(!)     *   FILE 923\n//*                  different sqlite subroutines.                  *   FILE 923\n//*                                                                 *   FILE 923\n//*     - COBTEST1 - The JCL to run the TESTCOB1 program.           *   FILE 923\n//*                  Unless you are running z/OS 2.1, you need      *   FILE 923\n//*                  to recompile the program before running        *   FILE 923\n//*                  this test job. There are LE dependencies.      *   FILE 923\n//*                                                                 *   FILE 923\n//*     - COBTEST2 - The JCL to run the TESTCOB2 program.           *   FILE 923\n//*                  Unless you are running z/OS 2.1, you need      *   FILE 923\n//*                  to recompile the program before running        *   FILE 923\n//*                  this test job. There are LE dependencies.      *   FILE 923\n//*                                                                 *   FILE 923\n//*     - IGYWCL   - The JCL to compile and link the TESTCOB1       *   FILE 923\n//*                  and TESTCOB2 program. You really need to       *   FILE 923\n//*                  recompile these program on your system due     *   FILE 923\n//*                  to possible LE dependencies.                   *   FILE 923\n//*                                                                 *   FILE 923\n//*     - LINK     - The JCL to link the SQLITE3 object code        *   FILE 923\n//*                  into a LINKLIB.  This composite links in       *   FILE 923\n//*                  the C and LE library subroutines.              *   FILE 923\n//*                                                                 *   FILE 923\n//*     - LINKLIB  - XMIT copy of the SQL387.LINKLIB library        *   FILE 923\n//*                  containing the z/OS batch executable           *   FILE 923\n//*                  programs: SQLITE3A, TESTCOB1, and              *   FILE 923\n//*                  TESTCOB2. However, these program will          *   FILE 923\n//*                  likely only run on a z/OS 2.1 system due       *   FILE 923\n//*                  to COBOL dependencies on LE.                   *   FILE 923\n//*                                                                 *   FILE 923\n//*     - PAXFULL  - This is a compressed pax archive for the       *   FILE 923\n//*                  entire SQLITE3 application, Including all      *   FILE 923\n//*                  source code and make information.              *   FILE 923\n//*                                                                 *   FILE 923\n//*     - PAXRUN   - This is a compressed pax archive               *   FILE 923\n//*                  containing only the files needed to use        *   FILE 923\n//*                  SQLITE. This is really all you need if you     *   FILE 923\n//*                  want to develop C language programs which      *   FILE 923\n//*                  use SQLITE.  This is not needed for COBOL      *   FILE 923\n//*                  or HLASM programs.                             *   FILE 923\n//*                                                                 *   FILE 923\n//*     - PLICB    - The JCL to compile a PL/I program.             *   FILE 923\n//*                                                                 *   FILE 923\n//*     - PLISQLTE - The PL/I %INCLUDE member to define and         *   FILE 923\n//*                  initialize a number of variables to ease       *   FILE 923\n//*                  the use of SQLITE3A.                           *   FILE 923\n//*                                                                 *   FILE 923\n//*     - SQLITE3A - LE enabled HLASM subroutine which presents     *   FILE 923\n//*                  an API to the SQLITE3 C subroutines which      *   FILE 923\n//*                  is designed for use by COBOL or PL/I code.     *   FILE 923\n//*                  It is composite (statically) bound with        *   FILE 923\n//*                  the C object code.  This code has not been     *   FILE 923\n//*                  fully tested yet and may contain errors.       *   FILE 923\n//*                                                                 *   FILE 923\n//*     - SQLITE3O - The object code for SQLITE to be bound         *   FILE 923\n//*                  into the application.  This was compiled       *   FILE 923\n//*                  on z/OS 1.13, but the C compiler options       *   FILE 923\n//*                  were for compatibility with z/OS 1.11 or       *   FILE 923\n//*                  higher.                                        *   FILE 923\n//*                                                                 *   FILE 923\n//*     - TESTCOB1 - Example Enterprise COBOL program. It is        *   FILE 923\n//*                  very basic.  It uses the SQLITE3A stub to      *   FILE 923\n//*                  invoke SQLITE3 operations.  If you look at     *   FILE 923\n//*                  this, you will realize that I am very          *   FILE 923\n//*                  \"wordy\" and am definitely not an advanced      *   FILE 923\n//*                  COBOL programmer.                              *   FILE 923\n//*                                                                 *   FILE 923\n//*     - TESTCOB2 - Example Enterprise COBOL program. It is        *   FILE 923\n//*                  very basic.  It's main example is of how       *   FILE 923\n//*                  to retrieve a double precision floating        *   FILE 923\n//*                  point number, COMP-2, from an sqlite data      *   FILE 923\n//*                  base, converting it from BFP to HFP            *   FILE 923\n//*                  format.  The table is defined like:            *   FILE 923\n//*                  CREATE TABLE xz (int INTEGER, fd DOUBLE);      *   FILE 923\n//*                  This table can be created and loaded from      *   FILE 923\n//*                  a z/OS UNIX shell prompt using the             *   FILE 923\n//*                  \"sqlite3\" UNIX command.                        *   FILE 923\n//*                                                                 *   FILE 923\n//*                  From my testing, it appears that sqlite,       *   FILE 923\n//*                  unlike most other RDMS systems is case         *   FILE 923\n//*                  sensitive for the names of objects such as     *   FILE 923\n//*                  columns and tables.                            *   FILE 923\n//*                                                                 *   FILE 923\n//*     - TESTDB   - A pax archive which contains the               *   FILE 923\n//*                  testdb.sqlite3 UNIX file used by the           *   FILE 923\n//*                  TESTCOB2 program. This needs to be             *   FILE 923\n//*                  restored to a subdirectory (/tmp in the        *   FILE 923\n//*                  example code). This can be done with a         *   FILE 923\n//*                  UNIX command sequence such as:                 *   FILE 923\n//*                                                                 *   FILE 923\n//*                  cd /tmp                                        *   FILE 923\n//*                  pax -rzf \"//sql387.cntl(testdb)\"               *   FILE 923\n//*                                                                 *   FILE 923\n//*     - TSTPLI1  - Example Enterprise PL/I program. It is         *   FILE 923\n//*                  very basic.  It is functionally equivalent     *   FILE 923\n//*                  to TESTCOB1.  This is not working at           *   FILE 923\n//*                  present.  I don't normally program in PL/I     *   FILE 923\n//*                  because I have never worked in a shop          *   FILE 923\n//*                  which used it.                                 *   FILE 923\n//*                                                                 *   FILE 923\n//*     - UNPAX    - The JCL needed to unwind either the            *   FILE 923\n//*                  PAXFULL or PAXRUN member into a z/OS UNIX      *   FILE 923\n//*                  subdirectory.                                  *   FILE 923\n//*                                                                 *   FILE 923\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASMACL": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00X\\x01\\x13#\\x9f\\x01\\x14)\\x1f\\x16V\\x00\\x15\\x00\\x14\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2013-08-27T00:00:00", "modifydate": "2014-10-18T16:56:58", "lines": 21, "newlines": 20, "modlines": 0, "user": "JOARMC"}, "text": "//ASMACL   JOB   (H00000I),MCKOWN,\n//         CLASS=F,\n//         COND=(4,LT),\n//         MSGCLASS=H,\n//         NOTIFY=&SYSUID\n//PROCLIB   JCLLIB ORDER=(HLA.SASMSAM1)\n//SQLITE3A  EXEC   PROC=ASMACL,\n//  PARM.C=(GOFF,'LIST(133)',BATCH,\n//       'MACHINE(ZS-2)'),\n//  PARM.L=(CALL,LET,LIST,RENT,REUS,XREF,\n//    'AMODE=31','RMODE=ANY','CASE=MIXED','COMPAT=ZOSV1R12')\n//C.SYSLIB  DD\n//          DD     DISP=SHR,DSN=CEE.SCEEMAC\n//C.SYSIN   DD     DISP=SHR,DSN=&SYSUID..SQL387.CNTL(SQLITE3A)\n//L.SYSLMOD DD     DISP=SHR,DSN=&SYSUID..SQL387.LINKLIB\n//L.SYSIN   DD     *\n  INCLUDE SQLITE3O\n  NAME SQLITE3A(R)\n//L.SYSLIB DD    DISP=SHR,DSN=CEE.SCEELKED\n//L.SQLITE3O DD    DISP=SHR,DSN=&SYSUID..SQL387.CNTL(SQLITE3O)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COBSQLTE": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x05\\x01\\x13#\\x9f\\x01\\x13$o\\x15\\x00\\n)\\x03\\xd2\\te\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2013-08-27T00:00:00", "modifydate": "2013-09-03T15:00:05", "lines": 2601, "newlines": 978, "modlines": 2405, "user": "JOARMC"}, "text": "000100 01  SQLITE3-RETURN-VALUES.\n000200     05 SQLITE-ABORT                         PIC S9(9) COMP-5\n000300            VALUE IS 4 .\n000400     05 SQLITE-ABORT-ROLLBACK                PIC S9(9) COMP-5\n000500            VALUE IS 516 .\n000600     05 SQLITE-ACCESS-EXISTS                 PIC S9(9) COMP-5\n000700            VALUE IS 0 .\n000800     05 SQLITE-ACCESS-READ                   PIC S9(9) COMP-5\n000900            VALUE IS 2 .\n001000     05 SQLITE-ACCESS-READWRITE              PIC S9(9) COMP-5\n001100            VALUE IS 1 .\n001200     05 SQLITE-ALTER-TABLE                   PIC S9(9) COMP-5\n001300            VALUE IS 26 .\n001400     05 SQLITE-ANALYZE                       PIC S9(9) COMP-5\n001500            VALUE IS 28 .\n001600     05 SQLITE-ANY                           PIC S9(9) COMP-5\n001700            VALUE IS 5 .\n001800     05 SQLITE-ATTACH                        PIC S9(9) COMP-5\n001900            VALUE IS 24 .\n002000     05 SQLITE-AUTH                          PIC S9(9) COMP-5\n002100            VALUE IS 23 .\n002200     05 SQLITE-BLOB                          PIC S9(9) COMP-5\n002300            VALUE IS 4 .\n002400     05 SQLITE-BUSY                          PIC S9(9) COMP-5\n002500            VALUE IS 5 .\n002600     05 SQLITE-BUSY-RECOVERY                 PIC S9(9) COMP-5\n002700            VALUE IS 261 .\n002800     05 SQLITE-CANTOPEN                      PIC S9(9) COMP-5\n002900            VALUE IS 14 .\n003000     05 SQLITE-CANTOPEN-FULLPATH             PIC S9(9) COMP-5\n003100            VALUE IS 782 .\n003200     05 SQLITE-CANTOPEN-ISDIR                PIC S9(9) COMP-5\n003300            VALUE IS 526 .\n003400     05 SQLITE-CANTOPEN-NOTEMPDIR            PIC S9(9) COMP-5\n003500            VALUE IS 270 .\n003600     05 SQLITE-CHECKPOINT-FULL               PIC S9(9) COMP-5\n003700            VALUE IS 1 .\n003800     05 SQLITE-CHECKPOINT-PASSIVE            PIC S9(9) COMP-5\n003900            VALUE IS 0 .\n004000     05 SQLITE-CHECKPOINT-RESTART            PIC S9(9) COMP-5\n004100            VALUE IS 2 .\n004200     05 SQLITE-CONFIG-COVRNG-INDEX-SCN       PIC S9(9) COMP-5\n004300            VALUE IS 20 .\n004400     05 SQLITE-CONFIG-GETMALLOC              PIC S9(9) COMP-5\n004500            VALUE IS 5 .\n004600     05 SQLITE-CONFIG-GETMUTEX               PIC S9(9) COMP-5\n004700            VALUE IS 11 .\n004800     05 SQLITE-CONFIG-GETPCACHE              PIC S9(9) COMP-5\n004900            VALUE IS 15 .\n005000     05 SQLITE-CONFIG-GETPCACHE2             PIC S9(9) COMP-5\n005100            VALUE IS 19 .\n005200     05 SQLITE-CONFIG-HEAP                   PIC S9(9) COMP-5\n005300            VALUE IS 8 .\n005400     05 SQLITE-CONFIG-LOG                    PIC S9(9) COMP-5\n005500            VALUE IS 16 .\n005600     05 SQLITE-CONFIG-LOOKASIDE              PIC S9(9) COMP-5\n005700            VALUE IS 13 .\n005800     05 SQLITE-CONFIG-MALLOC                 PIC S9(9) COMP-5\n005900            VALUE IS 4 .\n006000     05 SQLITE-CONFIG-MEMSTATUS              PIC S9(9) COMP-5\n006100            VALUE IS 9 .\n006200     05 SQLITE-CONFIG-MMAP-SIZE              PIC S9(9) COMP-5\n006300            VALUE IS 22 .\n006400     05 SQLITE-CONFIG-MULTITHREAD            PIC S9(9) COMP-5\n006500            VALUE IS 2 .\n006600     05 SQLITE-CONFIG-MUTEX                  PIC S9(9) COMP-5\n006700            VALUE IS 10 .\n006800     05 SQLITE-CONFIG-PAGECACHE              PIC S9(9) COMP-5\n006900            VALUE IS 7 .\n007000     05 SQLITE-CONFIG-PCACHE                 PIC S9(9) COMP-5\n007100            VALUE IS 14 .\n007200     05 SQLITE-CONFIG-PCACHE2                PIC S9(9) COMP-5\n007300            VALUE IS 18 .\n007400     05 SQLITE-CONFIG-SCRATCH                PIC S9(9) COMP-5\n007500            VALUE IS 6 .\n007600     05 SQLITE-CONFIG-SERIALIZED             PIC S9(9) COMP-5\n007700            VALUE IS 3 .\n007800     05 SQLITE-CONFIG-SINGLETHREAD           PIC S9(9) COMP-5\n007900            VALUE IS 1 .\n008000     05 SQLITE-CONFIG-SQLLOG                 PIC S9(9) COMP-5\n008100            VALUE IS 21 .\n008200     05 SQLITE-CONFIG-URI                    PIC S9(9) COMP-5\n008300            VALUE IS 17 .\n008400     05 SQLITE-CONSTRAINT                    PIC S9(9) COMP-5\n008500            VALUE IS 19 .\n008600     05 SQLITE-CONSTRAINT-CHECK              PIC S9(9) COMP-5\n008700            VALUE IS 275 .\n008800     05 SQLITE-CONSTRAINT-COMMITHOOK         PIC S9(9) COMP-5\n008900            VALUE IS 531 .\n009000     05 SQLITE-CONSTRAINT-FOREIGNKEY         PIC S9(9) COMP-5\n009100            VALUE IS 787 .\n009200     05 SQLITE-CONSTRAINT-FUNCTION           PIC S9(9) COMP-5\n009300            VALUE IS 1043 .\n009400     05 SQLITE-CONSTRAINT-NOTNULL            PIC S9(9) COMP-5\n009500            VALUE IS 1299 .\n009600     05 SQLITE-CONSTRAINT-PRIMARYKEY         PIC S9(9) COMP-5\n009700            VALUE IS 1555 .\n009800     05 SQLITE-CONSTRAINT-TRIGGER            PIC S9(9) COMP-5\n009900            VALUE IS 1811 .\n010000     05 SQLITE-CONSTRAINT-UNIQUE             PIC S9(9) COMP-5\n010100            VALUE IS 2067 .\n010200     05 SQLITE-CONSTRAINT-VTAB               PIC S9(9) COMP-5\n010300            VALUE IS 2323 .\n010400     05 SQLITE-COPY                          PIC S9(9) COMP-5\n010500            VALUE IS 0 .\n010600     05 SQLITE-CORRUPT                       PIC S9(9) COMP-5\n010700            VALUE IS 11 .\n010800     05 SQLITE-CORRUPT-VTAB                  PIC S9(9) COMP-5\n010900            VALUE IS 267 .\n011000     05 SQLITE-CREATE-INDEX                  PIC S9(9) COMP-5\n011100            VALUE IS 1 .\n011200     05 SQLITE-CREATE-TABLE                  PIC S9(9) COMP-5\n011300            VALUE IS 2 .\n011400     05 SQLITE-CREATE-TEMP-INDEX             PIC S9(9) COMP-5\n011500            VALUE IS 3 .\n011600     05 SQLITE-CREATE-TEMP-TABLE             PIC S9(9) COMP-5\n011700            VALUE IS 4 .\n011800     05 SQLITE-CREATE-TEMP-TRIGGER           PIC S9(9) COMP-5\n011900            VALUE IS 5 .\n012000     05 SQLITE-CREATE-TEMP-VIEW              PIC S9(9) COMP-5\n012100            VALUE IS 6 .\n012200     05 SQLITE-CREATE-TRIGGER                PIC S9(9) COMP-5\n012300            VALUE IS 7 .\n012400     05 SQLITE-CREATE-VIEW                   PIC S9(9) COMP-5\n012500            VALUE IS 8 .\n012600     05 SQLITE-CREATE-VTABLE                 PIC S9(9) COMP-5\n012700            VALUE IS 29 .\n012800     05 SQLITE-DBCONFIG-ENABLE-FKEY          PIC S9(9) COMP-5\n012900            VALUE IS 1002 .\n013000     05 SQLITE-DBCONFIG-ENABLE-TRIGGER       PIC S9(9) COMP-5\n013100            VALUE IS 1003 .\n013200     05 SQLITE-DBCONFIG-LOOKASIDE            PIC S9(9) COMP-5\n013300            VALUE IS 1001 .\n013400     05 SQLITE-DBSTATUS-CACHE-HIT            PIC S9(9) COMP-5\n013500            VALUE IS 7 .\n013600     05 SQLITE-DBSTATUS-CACHE-MISS           PIC S9(9) COMP-5\n013700            VALUE IS 8 .\n013800     05 SQLITE-DBSTATUS-CACHE-USED           PIC S9(9) COMP-5\n013900            VALUE IS 1 .\n014000     05 SQLITE-DBSTATUS-CACHE-WRITE          PIC S9(9) COMP-5\n014100            VALUE IS 9 .\n014200     05 SQLITE-DBSTATUS-LOOKASIDE-HIT        PIC S9(9) COMP-5\n014300            VALUE IS 4 .\n014400     05 SQLITE-DBSTAT-LKASD-MISS-FULL        PIC S9(9) COMP-5\n014500            VALUE IS 6 .\n014600     05 SQLITE-DBSTAT-LKASD-MISS-SIZE        PIC S9(9) COMP-5\n014700            VALUE IS 5 .\n014800     05 SQLITE-DBSTATUS-LOOKASIDE-USED       PIC S9(9) COMP-5\n014900            VALUE IS 0 .\n015000     05 SQLITE-DBSTATUS-MAX                  PIC S9(9) COMP-5\n015100            VALUE IS 9 .\n015200     05 SQLITE-DBSTATUS-SCHEMA-USED          PIC S9(9) COMP-5\n015300            VALUE IS 2 .\n015400     05 SQLITE-DBSTATUS-STMT-USED            PIC S9(9) COMP-5\n015500            VALUE IS 3 .\n015600     05 SQLITE-DELETE                        PIC S9(9) COMP-5\n015700            VALUE IS 9 .\n015800     05 SQLITE-DENY                          PIC S9(9) COMP-5\n015900            VALUE IS 1 .\n016000     05 SQLITE-DETACH                        PIC S9(9) COMP-5\n016100            VALUE IS 25 .\n016200     05 SQLITE-DONE                          PIC S9(9) COMP-5\n016300            VALUE IS 101 .\n016400     05 SQLITE-DROP-INDEX                    PIC S9(9) COMP-5\n016500            VALUE IS 10 .\n016600     05 SQLITE-DROP-TABLE                    PIC S9(9) COMP-5\n016700            VALUE IS 11 .\n016800     05 SQLITE-DROP-TEMP-INDEX               PIC S9(9) COMP-5\n016900            VALUE IS 12 .\n017000     05 SQLITE-DROP-TEMP-TABLE               PIC S9(9) COMP-5\n017100            VALUE IS 13 .\n017200     05 SQLITE-DROP-TEMP-TRIGGER             PIC S9(9) COMP-5\n017300            VALUE IS 14 .\n017400     05 SQLITE-DROP-TEMP-VIEW                PIC S9(9) COMP-5\n017500            VALUE IS 15 .\n017600     05 SQLITE-DROP-TRIGGER                  PIC S9(9) COMP-5\n017700            VALUE IS 16 .\n017800     05 SQLITE-DROP-VIEW                     PIC S9(9) COMP-5\n017900            VALUE IS 17 .\n018000     05 SQLITE-DROP-VTABLE                   PIC S9(9) COMP-5\n018100            VALUE IS 30 .\n018200     05 SQLITE-EMPTY                         PIC S9(9) COMP-5\n018300            VALUE IS 16 .\n018400     05 SQLITE-ERROR                         PIC S9(9) COMP-5\n018500            VALUE IS 1 .\n018600     05 SQLITE-FAIL                          PIC S9(9) COMP-5\n018700            VALUE IS 3 .\n018800     05 SQLITE-FCNTL-BUSYHANDLER             PIC S9(9) COMP-5\n018900            VALUE IS 15 .\n019000     05 SQLITE-FCNTL-CHUNK-SIZE              PIC S9(9) COMP-5\n019100            VALUE IS 6 .\n019200     05 SQLITE-FCNTL-FILE-POINTER            PIC S9(9) COMP-5\n019300            VALUE IS 7 .\n019400     05 SQLITE-FCNTL-LOCKSTATE               PIC S9(9) COMP-5\n019500            VALUE IS 1 .\n019600     05 SQLITE-FCNTL-MMAP-SIZE               PIC S9(9) COMP-5\n019700            VALUE IS 18 .\n019800     05 SQLITE-FCNTL-OVERWRITE               PIC S9(9) COMP-5\n019900            VALUE IS 11 .\n020000     05 SQLITE-FCNTL-PERSIST-WAL             PIC S9(9) COMP-5\n020100            VALUE IS 10 .\n020200     05 SQLITE-FCNTL-PWRSAFE-OVERWRITE       PIC S9(9) COMP-5\n020300            VALUE IS 13 .\n020400     05 SQLITE-FCNTL-PRAGMA                  PIC S9(9) COMP-5\n020500            VALUE IS 14 .\n020600     05 SQLITE-FCNTL-SIZE-HINT               PIC S9(9) COMP-5\n020700            VALUE IS 5 .\n020800     05 SQLITE-FCNTL-SYNC-OMITTED            PIC S9(9) COMP-5\n020900            VALUE IS 8 .\n021000     05 SQLITE-FCNTL-TEMPFILENAME            PIC S9(9) COMP-5\n021100            VALUE IS 16 .\n021200     05 SQLITE-FCNTL-VFSNAME                 PIC S9(9) COMP-5\n021300            VALUE IS 12 .\n021400     05 SQLITE-FCNTL-WIN32-AV-RETRY          PIC S9(9) COMP-5\n021500            VALUE IS 9 .\n021600     05 SQLITE-FLOAT                         PIC S9(9) COMP-5\n021700            VALUE IS 2 .\n021800     05 SQLITE-FORMAT                        PIC S9(9) COMP-5\n021900            VALUE IS 24 .\n022000     05 SQLITE-FULL                          PIC S9(9) COMP-5\n022100            VALUE IS 13 .\n022200     05 SQLITE-FUNCTION                      PIC S9(9) COMP-5\n022300            VALUE IS 31 .\n022400     05 SQLITE-GET-LOCKPROXYFILE             PIC S9(9) COMP-5\n022500            VALUE IS 2 .\n022600     05 SQLITE-IGNORE                        PIC S9(9) COMP-5\n022700            VALUE IS 2 .\n022800     05 SQLITE-INDEX-CONSTRAINT-EQ           PIC S9(9) COMP-5\n022900            VALUE IS 2 .\n023000     05 SQLITE-INDEX-CONSTRAINT-GE           PIC S9(9) COMP-5\n023100            VALUE IS 32 .\n023200     05 SQLITE-INDEX-CONSTRAINT-GT           PIC S9(9) COMP-5\n023300            VALUE IS 4 .\n023400     05 SQLITE-INDEX-CONSTRAINT-LE           PIC S9(9) COMP-5\n023500            VALUE IS 8 .\n023600     05 SQLITE-INDEX-CONSTRAINT-LT           PIC S9(9) COMP-5\n023700            VALUE IS 16 .\n023800     05 SQLITE-INDEX-CONSTRAINT-MATCH        PIC S9(9) COMP-5\n023900            VALUE IS 64 .\n024000     05 SQLITE-INSERT                        PIC S9(9) COMP-5\n024100            VALUE IS 18 .\n024200     05 SQLITE-INTEGER                       PIC S9(9) COMP-5\n024300            VALUE IS 1 .\n024400     05 SQLITE-INTERNAL                      PIC S9(9) COMP-5\n024500            VALUE IS 2 .\n024600     05 SQLITE-INTERRUPT                     PIC S9(9) COMP-5\n024700            VALUE IS 9 .\n024800     05 SQLITE-IOCAP-ATOMIC                  PIC S9(9) COMP-5\n024900            VALUE IS 1 .\n025000     05 SQLITE-IOCAP-ATOMIC1K                PIC S9(9) COMP-5\n025100            VALUE IS 4 .\n025200     05 SQLITE-IOCAP-ATOMIC16K               PIC S9(9) COMP-5\n025300            VALUE IS 64 .\n025400     05 SQLITE-IOCAP-ATOMIC2K                PIC S9(9) COMP-5\n025500            VALUE IS 8 .\n025600     05 SQLITE-IOCAP-ATOMIC32K               PIC S9(9) COMP-5\n025700            VALUE IS 128 .\n025800     05 SQLITE-IOCAP-ATOMIC4K                PIC S9(9) COMP-5\n025900            VALUE IS 16 .\n026000     05 SQLITE-IOCAP-ATOMIC512               PIC S9(9) COMP-5\n026100            VALUE IS 2 .\n026200     05 SQLITE-IOCAP-ATOMIC64K               PIC S9(9) COMP-5\n026300            VALUE IS 256 .\n026400     05 SQLITE-IOCAP-ATOMIC8K                PIC S9(9) COMP-5\n026500            VALUE IS 32 .\n026600     05 SQLITE-IOCAP-PWRSAFE-OVERWRITE       PIC S9(9) COMP-5\n026700            VALUE IS 4096 .\n026800     05 SQLITE-IOCAP-SAFE-APPEND             PIC S9(9) COMP-5\n026900            VALUE IS 512 .\n027000     05 SQLITE-IOCAP-SEQUENTIAL              PIC S9(9) COMP-5\n027100            VALUE IS 1024 .\n027200     05 SQLITE-IOCAP-UNDEL-WHEN-OPEN         PIC S9(9) COMP-5\n027300            VALUE IS 2048 .\n027400     05 SQLITE-IOERR                         PIC S9(9) COMP-5\n027500            VALUE IS 10 .\n027600     05 SQLITE-IOERR-ACCESS                  PIC S9(9) COMP-5\n027700            VALUE IS 3338 .\n027800     05 SQLITE-IOERR-BLOCKED                 PIC S9(9) COMP-5\n027900            VALUE IS 2826 .\n028000     05 SQLITE-IOERR-CHECKRESERVEDLOCK       PIC S9(9) COMP-5\n028100            VALUE IS 3594 .\n028200     05 SQLITE-IOERR-CLOSE                   PIC S9(9) COMP-5\n028300            VALUE IS 4106 .\n028400     05 SQLITE-IOERR-DELETE                  PIC S9(9) COMP-5\n028500            VALUE IS 2570 .\n028600     05 SQLITE-IOERR-DELETE-NOENT            PIC S9(9) COMP-5\n028700            VALUE IS 5898 .\n028800     05 SQLITE-IOERR-DIR-CLOSE               PIC S9(9) COMP-5\n028900            VALUE IS 4362 .\n029000     05 SQLITE-IOERR-DIR-FSYNC               PIC S9(9) COMP-5\n029100            VALUE IS 1290 .\n029200     05 SQLITE-IOERR-FSTAT                   PIC S9(9) COMP-5\n029300            VALUE IS 1802 .\n029400     05 SQLITE-IOERR-FSYNC                   PIC S9(9) COMP-5\n029500            VALUE IS 1034 .\n029600     05 SQLITE-IOERR-LOCK                    PIC S9(9) COMP-5\n029700            VALUE IS 3850 .\n029800     05 SQLITE-IOERR-MMAP                    PIC S9(9) COMP-5\n029900            VALUE IS 6154 .\n030000     05 SQLITE-IOERR-NOMEM                   PIC S9(9) COMP-5\n030100            VALUE IS 3082 .\n030200     05 SQLITE-IOERR-RDLOCK                  PIC S9(9) COMP-5\n030300            VALUE IS 2314 .\n030400     05 SQLITE-IOERR-READ                    PIC S9(9) COMP-5\n030500            VALUE IS 266 .\n030600     05 SQLITE-IOERR-SEEK                    PIC S9(9) COMP-5\n030700            VALUE IS 5642 .\n030800     05 SQLITE-IOERR-SHMLOCK                 PIC S9(9) COMP-5\n030900            VALUE IS 5130 .\n031000     05 SQLITE-IOERR-SHMMAP                  PIC S9(9) COMP-5\n031100            VALUE IS 5386 .\n031200     05 SQLITE-IOERR-SHMOPEN                 PIC S9(9) COMP-5\n031300            VALUE IS 4618 .\n031400     05 SQLITE-IOERR-SHMSIZE                 PIC S9(9) COMP-5\n031500            VALUE IS 4874 .\n031600     05 SQLITE-IOERR-SHORT-READ              PIC S9(9) COMP-5\n031700            VALUE IS 522 .\n031800     05 SQLITE-IOERR-TRUNCATE                PIC S9(9) COMP-5\n031900            VALUE IS 1546 .\n032000     05 SQLITE-IOERR-UNLOCK                  PIC S9(9) COMP-5\n032100            VALUE IS 2058 .\n032200     05 SQLITE-IOERR-WRITE                   PIC S9(9) COMP-5\n032300            VALUE IS 778 .\n032400     05 SQLITE-LAST-ERRNO                    PIC S9(9) COMP-5\n032500            VALUE IS 4 .\n032600     05 SQLITE-LIMIT-ATTACHED                PIC S9(9) COMP-5\n032700            VALUE IS 7 .\n032800     05 SQLITE-LIMIT-COLUMN                  PIC S9(9) COMP-5\n032900            VALUE IS 2 .\n033000     05 SQLITE-LIMIT-COMPOUND-SELECT         PIC S9(9) COMP-5\n033100            VALUE IS 4 .\n033200     05 SQLITE-LIMIT-EXPR-DEPTH              PIC S9(9) COMP-5\n033300            VALUE IS 3 .\n033400     05 SQLITE-LIMIT-FUNCTION-ARG            PIC S9(9) COMP-5\n033500            VALUE IS 6 .\n033600     05 SQLITE-LIMIT-LENGTH                  PIC S9(9) COMP-5\n033700            VALUE IS 0 .\n033800     05 SQLITE-LIMIT-LIKE-PATTERN-LEN        PIC S9(9) COMP-5\n033900            VALUE IS 8 .\n034000     05 SQLITE-LIMIT-SQL-LENGTH              PIC S9(9) COMP-5\n034100            VALUE IS 1 .\n034200     05 SQLITE-LIMIT-TRIGGER-DEPTH           PIC S9(9) COMP-5\n034300            VALUE IS 10 .\n034400     05 SQLITE-LIMIT-VARIABLE-NUMBER         PIC S9(9) COMP-5\n034500            VALUE IS 9 .\n034600     05 SQLITE-LIMIT-VDBE-OP                 PIC S9(9) COMP-5\n034700            VALUE IS 5 .\n034800     05 SQLITE-LOCK-EXCLUSIVE                PIC S9(9) COMP-5\n034900            VALUE IS 4 .\n035000     05 SQLITE-LOCK-NONE                     PIC S9(9) COMP-5\n035100            VALUE IS 0 .\n035200     05 SQLITE-LOCK-PENDING                  PIC S9(9) COMP-5\n035300            VALUE IS 3 .\n035400     05 SQLITE-LOCK-RESERVED                 PIC S9(9) COMP-5\n035500            VALUE IS 2 .\n035600     05 SQLITE-LOCK-SHARED                   PIC S9(9) COMP-5\n035700            VALUE IS 1 .\n035800     05 SQLITE-LOCKED                        PIC S9(9) COMP-5\n035900            VALUE IS 6 .\n036000     05 SQLITE-LOCKED-SHAREDCACHE            PIC S9(9) COMP-5\n036100            VALUE IS 262 .\n036200     05 SQLITE-MISMATCH                      PIC S9(9) COMP-5\n036300            VALUE IS 20 .\n036400     05 SQLITE-MISUSE                        PIC S9(9) COMP-5\n036500            VALUE IS 21 .\n036600     05 SQLITE-MUTEX-FAST                    PIC S9(9) COMP-5\n036700            VALUE IS 0 .\n036800     05 SQLITE-MUTEX-RECURSIVE               PIC S9(9) COMP-5\n036900            VALUE IS 1 .\n037000     05 SQLITE-MUTEX-STATIC-LRU              PIC S9(9) COMP-5\n037100            VALUE IS 6 .\n037200     05 SQLITE-MUTEX-STATIC-LRU2             PIC S9(9) COMP-5\n037300            VALUE IS 7 .\n037400     05 SQLITE-MUTEX-STATIC-MASTER           PIC S9(9) COMP-5\n037500            VALUE IS 2 .\n037600     05 SQLITE-MUTEX-STATIC-MEM              PIC S9(9) COMP-5\n037700            VALUE IS 3 .\n037800     05 SQLITE-MUTEX-STATIC-MEM2             PIC S9(9) COMP-5\n037900            VALUE IS 4 .\n038000     05 SQLITE-MUTEX-STATIC-OPEN             PIC S9(9) COMP-5\n038100            VALUE IS 4 .\n038200     05 SQLITE-MUTEX-STATIC-PMEM             PIC S9(9) COMP-5\n038300            VALUE IS 7 .\n038400     05 SQLITE-MUTEX-STATIC-PRNG             PIC S9(9) COMP-5\n038500            VALUE IS 5 .\n038600     05 SQLITE-NOLFS                         PIC S9(9) COMP-5\n038700            VALUE IS 22 .\n038800     05 SQLITE-NOMEM                         PIC S9(9) COMP-5\n038900            VALUE IS 7 .\n039000     05 SQLITE-NOTADB                        PIC S9(9) COMP-5\n039100            VALUE IS 26 .\n039200     05 SQLITE-NOTFOUND                      PIC S9(9) COMP-5\n039300            VALUE IS 12 .\n039400     05 SQLITE-NOTICE                        PIC S9(9) COMP-5\n039500            VALUE IS 27 .\n039600     05 SQLITE-NOTICE-RECOVER-ROLLBACK       PIC S9(9) COMP-5\n039700            VALUE IS 539 .\n039800     05 SQLITE-NOTICE-RECOVER-WAL            PIC S9(9) COMP-5\n039900            VALUE IS 283 .\n040000     05 SQLITE-NULL                          PIC S9(9) COMP-5\n040100            VALUE IS 5 .\n040200     05 SQLITE-OK                            PIC S9(9) COMP-5\n040300            VALUE IS 0 .\n040400     05 SQLITE-OPEN-AUTOPROXY                PIC S9(9) COMP-5\n040500            VALUE IS 32 .\n040600     05 SQLITE-OPEN-CREATE                   PIC S9(9) COMP-5\n040700            VALUE IS 4 .\n040800     05 SQLITE-OPEN-DELETEONCLOSE            PIC S9(9) COMP-5\n040900            VALUE IS 8 .\n041000     05 SQLITE-OPEN-EXCLUSIVE                PIC S9(9) COMP-5\n041100            VALUE IS 16 .\n041200     05 SQLITE-OPEN-FULLMUTEX                PIC S9(9) COMP-5\n041300            VALUE IS 65536 .\n041400     05 SQLITE-OPEN-MAIN-DB                  PIC S9(9) COMP-5\n041500            VALUE IS 256 .\n041600     05 SQLITE-OPEN-MAIN-JOURNAL             PIC S9(9) COMP-5\n041700            VALUE IS 2048 .\n041800     05 SQLITE-OPEN-MASTER-JOURNAL           PIC S9(9) COMP-5\n041900            VALUE IS 16384 .\n042000     05 SQLITE-OPEN-MEMORY                   PIC S9(9) COMP-5\n042100            VALUE IS 128 .\n042200     05 SQLITE-OPEN-NOMUTEX                  PIC S9(9) COMP-5\n042300            VALUE IS 32768 .\n042400     05 SQLITE-OPEN-PRIVATECACHE             PIC S9(9) COMP-5\n042500            VALUE IS 262144 .\n042600     05 SQLITE-OPEN-READONLY                 PIC S9(9) COMP-5\n042700            VALUE IS 1 .\n042800     05 SQLITE-OPEN-READWRITE                PIC S9(9) COMP-5\n042900            VALUE IS 2 .\n043000     05 SQLITE-OPEN-SHAREDCACHE              PIC S9(9) COMP-5\n043100            VALUE IS 131072 .\n043200     05 SQLITE-OPEN-SUBJOURNAL               PIC S9(9) COMP-5\n043300            VALUE IS 8192 .\n043400     05 SQLITE-OPEN-TEMP-DB                  PIC S9(9) COMP-5\n043500            VALUE IS 512 .\n043600     05 SQLITE-OPEN-TEMP-JOURNAL             PIC S9(9) COMP-5\n043700            VALUE IS 4096 .\n043800     05 SQLITE-OPEN-TRANSIENT-DB             PIC S9(9) COMP-5\n043900            VALUE IS 1024 .\n044000     05 SQLITE-OPEN-URI                      PIC S9(9) COMP-5\n044100            VALUE IS 64 .\n044200     05 SQLITE-OPEN-WAL                      PIC S9(9) COMP-5\n044300            VALUE IS 524288 .\n044400     05 SQLITE-PERM                          PIC S9(9) COMP-5\n044500            VALUE IS 3 .\n044600     05 SQLITE-PRAGMA                        PIC S9(9) COMP-5\n044700            VALUE IS 19 .\n044800     05 SQLITE-PROTOCOL                      PIC S9(9) COMP-5\n044900            VALUE IS 15 .\n045000     05 SQLITE-RANGE                         PIC S9(9) COMP-5\n045100            VALUE IS 25 .\n045200     05 SQLITE-READ                          PIC S9(9) COMP-5\n045300            VALUE IS 20 .\n045400     05 SQLITE-READONLY                      PIC S9(9) COMP-5\n045500            VALUE IS 8 .\n045600     05 SQLITE-READONLY-CANTLOCK             PIC S9(9) COMP-5\n045700            VALUE IS 520 .\n045800     05 SQLITE-READONLY-RECOVERY             PIC S9(9) COMP-5\n045900            VALUE IS 264 .\n046000     05 SQLITE-READONLY-ROLLBACK             PIC S9(9) COMP-5\n046100            VALUE IS 776 .\n046200     05 SQLITE-REINDEX                       PIC S9(9) COMP-5\n046300            VALUE IS 27 .\n046400     05 SQLITE-REPLACE                       PIC S9(9) COMP-5\n046500            VALUE IS 5 .\n046600     05 SQLITE-ROLLBACK                      PIC S9(9) COMP-5\n046700            VALUE IS 1 .\n046800     05 SQLITE-ROW                           PIC S9(9) COMP-5\n046900            VALUE IS 100 .\n047000     05 SQLITE-SAVEPOINT                     PIC S9(9) COMP-5\n047100            VALUE IS 32 .\n047200     05 SQLITE-SCHEMA                        PIC S9(9) COMP-5\n047300            VALUE IS 17 .\n047400     05 SQLITE-SELECT                        PIC S9(9) COMP-5\n047500            VALUE IS 21 .\n047600     05 SQLITE-SET-LOCKPROXYFILE             PIC S9(9) COMP-5\n047700            VALUE IS 3 .\n047800     05 SQLITE-SHM-EXCLUSIVE                 PIC S9(9) COMP-5\n047900            VALUE IS 8 .\n048000     05 SQLITE-SHM-LOCK                      PIC S9(9) COMP-5\n048100            VALUE IS 2 .\n048200     05 SQLITE-SHM-NLOCK                     PIC S9(9) COMP-5\n048300            VALUE IS 8 .\n048400     05 SQLITE-SHM-SHARED                    PIC S9(9) COMP-5\n048500            VALUE IS 4 .\n048600     05 SQLITE-SHM-UNLOCK                    PIC S9(9) COMP-5\n048700            VALUE IS 1 .\n048800     05 SQLITE-STATIC                        PIC S9(9) COMP-5\n048900            VALUE IS 0 .\n049000     05 SQLITE-STATUS-MALLOC-COUNT           PIC S9(9) COMP-5\n049100            VALUE IS 9 .\n049200     05 SQLITE-STATUS-MALLOC-SIZE            PIC S9(9) COMP-5\n049300            VALUE IS 5 .\n049400     05 SQLITE-STATUS-MEMORY-USED            PIC S9(9) COMP-5\n049500            VALUE IS 0 .\n049600     05 SQLITE-STATUS-PGCACHE-OVERFLOW       PIC S9(9) COMP-5\n049700            VALUE IS 2 .\n049800     05 SQLITE-STATUS-PGCACHE-SIZE           PIC S9(9) COMP-5\n049900            VALUE IS 7 .\n050000     05 SQLITE-STATUS-PGCACHE-USED           PIC S9(9) COMP-5\n050100            VALUE IS 1 .\n050200     05 SQLITE-STATUS-PARSER-STACK           PIC S9(9) COMP-5\n050300            VALUE IS 6 .\n050400     05 SQLITE-STATUS-SCRATCH-OVERFLOW       PIC S9(9) COMP-5\n050500            VALUE IS 4 .\n050600     05 SQLITE-STATUS-SCRATCH-SIZE           PIC S9(9) COMP-5\n050700            VALUE IS 8 .\n050800     05 SQLITE-STATUS-SCRATCH-USED           PIC S9(9) COMP-5\n050900            VALUE IS 3 .\n051000     05 SQLITE-STMTSTATUS-AUTOINDEX          PIC S9(9) COMP-5\n051100            VALUE IS 3 .\n051200     05 SQLITE-STMTSTATUS-FULLSCAN-STP       PIC S9(9) COMP-5\n051300            VALUE IS 1 .\n051400     05 SQLITE-STMTSTATUS-SORT               PIC S9(9) COMP-5\n051500            VALUE IS 2 .\n051600     05 SQLITE-SYNC-DATAONLY                 PIC S9(9) COMP-5\n051700            VALUE IS 16 .\n051800     05 SQLITE-SYNC-FULL                     PIC S9(9) COMP-5\n051900            VALUE IS 3 .\n052000     05 SQLITE-SYNC-NORMAL                   PIC S9(9) COMP-5\n052100            VALUE IS 2 .\n052200     05 SQLITE-TESTCTRL-ALWAYS               PIC S9(9) COMP-5\n052300            VALUE IS 13 .\n052400     05 SQLITE-TESTCTRL-ASSERT               PIC S9(9) COMP-5\n052500            VALUE IS 12 .\n052600     05 SQLITE-TESTCTRL-B9-MALLOC-HKS        PIC S9(9) COMP-5\n052700            VALUE IS 10 .\n052800     05 SQLITE-TESTCTRL-BITVEC-TEST          PIC S9(9) COMP-5\n052900            VALUE IS 8 .\n053000     05 SQLITE-TESTCTRL-EXPLAIN-STMT         PIC S9(9) COMP-5\n053100            VALUE IS 19 .\n053200     05 SQLITE-TESTCTRL-FAULT-INSTALL        PIC S9(9) COMP-5\n053300            VALUE IS 9 .\n053400     05 SQLITE-TESTCTRL-FIRST                PIC S9(9) COMP-5\n053500            VALUE IS 5 .\n053600     05 SQLITE-TESTCTRL-ISKEYWORD            PIC S9(9) COMP-5\n053700            VALUE IS 16 .\n053800     05 SQLITE-TESTCTRL-LAST                 PIC S9(9) COMP-5\n053900            VALUE IS 19 .\n054000     05 SQLITE-TESTCTRL-LOCALTIME-FLT        PIC S9(9) COMP-5\n054100            VALUE IS 18 .\n054200     05 SQLITE-TESTCTRL-OPTIMIZATIONS        PIC S9(9) COMP-5\n054300            VALUE IS 15 .\n054400     05 SQLITE-TESTCTRL-PENDING-BYTE         PIC S9(9) COMP-5\n054500            VALUE IS 11 .\n054600     05 SQLITE-TESTCTRL-PRNG-RESET           PIC S9(9) COMP-5\n054700            VALUE IS 7 .\n054800     05 SQLITE-TESTCTRL-PRNG-RESTORE         PIC S9(9) COMP-5\n054900            VALUE IS 6 .\n055000     05 SQLITE-TESTCTRL-PRNG-SAVE            PIC S9(9) COMP-5\n055100            VALUE IS 5 .\n055200     05 SQLITE-TESTCTRL-RESERVE              PIC S9(9) COMP-5\n055300            VALUE IS 14 .\n055400     05 SQLITE-TESTCTRL-SCRATCHMALLOC        PIC S9(9) COMP-5\n055500            VALUE IS 17 .\n055600     05 SQLITE-TEXT                          PIC S9(9) COMP-5\n055700            VALUE IS 3 .\n055800     05 SQLITE-TOOBIG                        PIC S9(9) COMP-5\n055900            VALUE IS 18 .\n056000     05 SQLITE-TRANSACTION                   PIC S9(9) COMP-5\n056100            VALUE IS 22 .\n056200     05 SQLITE-TRANSIENT                     PIC S9(9) COMP-5\n056300            VALUE IS -1 .\n056400     05 SQLITE-UPDATE                        PIC S9(9) COMP-5\n056500            VALUE IS 23 .\n056600     05 SQLITE-UTF16                         PIC S9(9) COMP-5\n056700            VALUE IS 4 .\n056800     05 SQLITE-UTF16-ALIGNED                 PIC S9(9) COMP-5\n056900            VALUE IS 8 .\n057000     05 SQLITE-UTF16BE                       PIC S9(9) COMP-5\n057100            VALUE IS 3 .\n057200     05 SQLITE-UTF16LE                       PIC S9(9) COMP-5\n057300            VALUE IS 2 .\n057400     05 SQLITE-UTF8                          PIC S9(9) COMP-5\n057500            VALUE IS 1 .\n057600     05 SQLITE-VERSION                       PIC X(6)\n057700            VALUE IS \"3.7.17\" .\n057800     05 SQLITE-VERSION-NUMBER                PIC S9(9) COMP-5\n057900            VALUE IS 3007017 .\n058000     05 SQLITE-VTAB-CONSTRAINT-SUPPORT       PIC S9(9) COMP-5\n058100            VALUE IS 1 .\n058200     05 SQLITE-WARNING                       PIC S9(9) COMP-5\n058300            VALUE IS 28 .\n058400 01  SQLITE3-FUNCTION-NAMES.\n058500*\n058600     05 SQLITE3A                        PIC X(8)\n058700            VALUE IS 'SQLITE3A'.\n058800*\n058900     05 SQLITE3-AGGREGATE-CONTEXT       PIC X(26)\n059000            VALUE IS Z'sqlite3_aggregate_context'.\n059100* This function returns a pointer which in COBOL\n059200* would be USAGE POINTER. You should assign\n059300* the result to the variable using the RETURNING clause\n059400* CALL SQLITE3 USING BY REFERENCE SQLITE3-AGGREGATE-CONTEXT\n059500*      <other call parameters as documented>\n059600*      RETURNING pointer-result-variable\n059700* END-CALL\n059800*\n059900     05 SQLITE3-AGGREGATE-COUNT         PIC X(24)\n060000            VALUE IS Z'sqlite3_aggregate_count'.\n060100* This function returns an integer which in COBOL\n060200* would be PIC S9(9) COMP-5. You should assign\n060300* the result to the variable using the RETURNING clause\n060400* CALL SQLITE3 USING BY REFERENCE SQLITE3-AGGREGATE-COUNT\n060500*      <other call parameters as documented>\n060600*      RETURNING integer-result-variable\n060700* END-CALL\n060800*\n060900     05 SQLITE3-AUTO-EXTENSION          PIC X(23)\n061000            VALUE IS Z'sqlite3_auto_extension'.\n061100* This function returns an integer which in COBOL\n061200* would be PIC S9(9) COMP-5. You should assign\n061300* the result to the variable using the RETURNING clause\n061400* CALL SQLITE3 USING BY REFERENCE SQLITE3-AUTO-EXTENSION\n061500*      <other call parameters as documented>\n061600*      RETURNING integer-result-variable\n061700* END-CALL\n061800*\n061900     05 SQLITE3-BACKUP-FINISH           PIC X(22)\n062000            VALUE IS Z'sqlite3_backup_finish'.\n062100* This function returns an integer which in COBOL\n062200* would be PIC S9(9) COMP-5. You should assign\n062300* the result to the variable using the RETURNING clause\n062400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BACKUP-FINISH\n062500*      <other call parameters as documented>\n062600*      RETURNING integer-result-variable\n062700* END-CALL\n062800*\n062900     05 SQLITE3-BACKUP-INIT             PIC X(20)\n063000            VALUE IS Z'sqlite3_backup_init'.\n063100* This function returns a pointer which in COBOL\n063200* would be USAGE POINTER. You should assign\n063300* the result to the variable using the RETURNING clause\n063400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BACK-INIT\n063500*      <other call parameters as documented>\n063600*      RETURNING pointer-result-variable\n063700* END-CALL\n063800*\n063900     05 SQLITE3-BACKUP-PAGECOUNT        PIC X(25)\n064000            VALUE IS Z'sqlite3_backup_pagecount'.\n064100* This function returns an integer which in COBOL\n064200* would be PIC S9(9) COMP-5. You should assign\n064300* the result to the variable using the RETURNING clause\n064400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BACKUP-PAGECOUNT\n064500*      <other call parameters as documented>\n064600*      RETURNING integer-result-variable\n064700* END-CALL\n064800*\n064900     05 SQLITE3-BACKUP-REMAINING        PIC X(25)\n065000            VALUE IS Z'sqlite3_backup_remaining'.\n065100* This function returns an integer which in COBOL\n065200* would be PIC S9(9) COMP-5. You should assign\n065300* the result to the variable using the RETURNING clause\n065400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BACKUP-REMAINING\n065500*      <other call parameters as documented>\n065600*      RETURNING integer-result-variable\n065700* END-CALL\n065800*\n065900     05 SQLITE3-BACKUP-STEP             PIC X(20)\n066000            VALUE IS Z'sqlite3_backup_step'.\n066100* This function returns an integer which in COBOL\n066200* would be PIC S9(9) COMP-5. You should assign\n066300* the result to the variable using the RETURNING clause\n066400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BACKUP-STEP\n066500*      <other call parameters as documented>\n066600*      RETURNING integer-result-variable\n066700* END-CALL\n066800*\n066900     05 SQLITE3-BIND-BLOB               PIC X(18)\n067000            VALUE IS Z'sqlite3_bind_blob'.\n067100* This function returns an integer which in COBOL\n067200* would be PIC S9(9) COMP-5. You should assign\n067300* the result to the variable using the RETURNING clause\n067400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-BLOB\n067500*      <other call parameters as documented>\n067600*      RETURNING integer-result-variable\n067700* END-CALL\n067800*\n067900     05 SQLITE3-BIND-DOUBLE             PIC X(20)\n068000            VALUE IS Z'sqlite3_bind_double'.\n068100* This function returns an integer which in COBOL\n068200* would be PIC S9(9) COMP-5. You should assign\n068300* the result to the variable using the RETURNING clause\n068400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-DOUBLE\n068500*      <other call parameters as documented>\n068600*      RETURNING integer-result-variable\n068700* END-CALL\n068800*\n068900     05 SQLITE3-BIND-INT                PIC X(17)\n069000            VALUE IS Z'sqlite3_bind_int'.\n069100* This function returns an integer which in COBOL\n069200* would be PIC S9(9) COMP-5. You should assign\n069300* the result to the variable using the RETURNING clause\n069400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-INT\n069500*      <other call parameters as documented>\n069600*      RETURNING integer-result-variable\n069700* END-CALL\n069800*\n069900     05 SQLITE3-BIND-INT64              PIC X(19)\n070000            VALUE IS Z'sqlite3_bind_int64'.\n070100* This function returns an integer which in COBOL\n070200* would be PIC S9(9) COMP-5. You should assign\n070300* the result to the variable using the RETURNING clause\n070400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-INT64\n070500*      <other call parameters as documented>\n070600*      RETURNING integer-result-variable\n070700* END-CALL\n070800*\n070900     05 SQLITE3-BIND-NULL               PIC X(18)\n071000            VALUE IS Z'sqlite3_bind_null'.\n071100* This function returns an integer which in COBOL\n071200* would be PIC S9(9) COMP-5. You should assign\n071300* the result to the variable using the RETURNING clause\n071400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-NULL\n071500*      <other call parameters as documented>\n071600*      RETURNING integer-result-variable\n071700* END-CALL\n071800*\n071900     05 SQLITE3-BIND-PARAMETER-COUNT    PIC X(29)\n072000            VALUE IS Z'sqlite3_bind_parameter_count'.\n072100* This function returns an integer which in COBOL\n072200* would be PIC S9(9) COMP-5. You should assign\n072300* the result to the variable using the RETURNING clause\n072400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-PARAMETER-COUNT\n072500*      <other call parameters as documented>\n072600*      RETURNING integer-result-variable\n072700* END-CALL\n072800*\n072900     05 SQLITE3-BIND-PARAMETER-INDEX    PIC X(29)\n073000            VALUE IS Z'sqlite3_bind_parameter_index'.\n073100* This function returns an integer which in COBOL\n073200* would be PIC S9(9) COMP-5. You should assign\n073300* the result to the variable using the RETURNING clause\n073400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-PARAMETER-INDEX\n073500*      <other call parameters as documented>\n073600*      RETURNING integer-result-variable\n073700* END-CALL\n073800*\n073900     05 SQLITE3-BIND-PARAMETER-NAME     PIC X(28)\n074000            VALUE IS Z'sqlite3_bind_parameter_name'.\n074100* This function returns a pointer which in COBOL\n074200* would be USAGE POINTER. You should assign\n074300* the result to the variable using the RETURNING clause\n074400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-PARAMETER-NAME\n074500*      <other call parameters as documented>\n074600*      RETURNING pointer-result-variable\n074700* END-CALL\n074800*\n074900     05 SQLITE3-BIND-TEXT               PIC X(18)\n075000            VALUE IS Z'sqlite3_bind_text'.\n075100* This function returns an integer which in COBOL\n075200* would be PIC S9(9) COMP-5. You should assign\n075300* the result to the variable using the RETURNING clause\n075400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-TEXT\n075500*      <other call parameters as documented>\n075600*      RETURNING integer-result-variable\n075700* END-CALL\n075800*\n075900     05 SQLITE3-BIND-TEXT16             PIC X(20)\n076000            VALUE IS Z'sqlite3_bind_text16'.\n076100* This function returns an integer which in COBOL\n076200* would be PIC S9(9) COMP-5. You should assign\n076300* the result to the variable using the RETURNING clause\n076400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-TEXT16\n076500*      <other call parameters as documented>\n076600*      RETURNING integer-result-variable\n076700* END-CALL\n076800*\n076900     05 SQLITE3-BIND-VALUE              PIC X(19)\n077000            VALUE IS Z'sqlite3_bind_value'.\n077100* This function returns an integer which in COBOL\n077200* would be PIC S9(9) COMP-5. You should assign\n077300* the result to the variable using the RETURNING clause\n077400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-VALUE\n077500*      <other call parameters as documented>\n077600*      RETURNING integer-result-variable\n077700* END-CALL\n077800*\n077900     05 SQLITE3-BIND-ZEROBLOB           PIC X(22)\n078000            VALUE IS Z'sqlite3_bind_zeroblob'.\n078100* This function returns an integer which in COBOL\n078200* would be PIC S9(9) COMP-5. You should assign\n078300* the result to the variable using the RETURNING clause\n078400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BIND-ZEROBLOB\n078500*      <other call parameters as documented>\n078600*      RETURNING integer-result-variable\n078700* END-CALL\n078800*\n078900     05 SQLITE3-BLOB-BYTES              PIC X(19)\n079000            VALUE IS Z'sqlite3_blob_bytes'.\n079100* This function returns an integer which in COBOL\n079200* would be PIC S9(9) COMP-5. You should assign\n079300* the result to the variable using the RETURNING clause\n079400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BLOB-BYTES\n079500*      <other call parameters as documented>\n079600*      RETURNING integer-result-variable\n079700* END-CALL\n079800*\n079900     05 SQLITE3-BLOB-CLOSE              PIC X(19)\n080000            VALUE IS Z'sqlite3_blob_close'.\n080100* This function returns an integer which in COBOL\n080200* would be PIC S9(9) COMP-5. You should assign\n080300* the result to the variable using the RETURNING clause\n080400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BLOB-CLOSE\n080500*      <other call parameters as documented>\n080600*      RETURNING integer-result-variable\n080700* END-CALL\n080800*\n080900     05 SQLITE3-BLOB-OPEN               PIC X(18)\n081000            VALUE IS Z'sqlite3_blob_open'.\n081100* This function returns an integer which in COBOL\n081200* would be PIC S9(9) COMP-5. You should assign\n081300* the result to the variable using the RETURNING clause\n081400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BLOB-OPEN\n081500*      <other call parameters as documented>\n081600*      RETURNING integer-result-variable\n081700* END-CALL\n081800*\n081900     05 SQLITE3-BLOB-READ               PIC X(18)\n082000            VALUE IS Z'sqlite3_blob_read'.\n082100* This function returns an integer which in COBOL\n082200* would be PIC S9(9) COMP-5. You should assign\n082300* the result to the variable using the RETURNING clause\n082400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BLOB-READ\n082500*      <other call parameters as documented>\n082600*      RETURNING integer-result-variable\n082700* END-CALL\n082800*\n082900     05 SQLITE3-BLOB-REOPEN             PIC X(20)\n083000            VALUE IS Z'sqlite3_blob_reopen'.\n083100* This function returns an integer which in COBOL\n083200* would be PIC S9(9) COMP-5. You should assign\n083300* the result to the variable using the RETURNING clause\n083400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BLOB-REOPEN\n083500*      <other call parameters as documented>\n083600*      RETURNING integer-result-variable\n083700* END-CALL\n083800*\n083900     05 SQLITE3-BLOB-WRITE              PIC X(19)\n084000            VALUE IS Z'sqlite3_blob_write'.\n084100* This function returns an integer which in COBOL\n084200* would be PIC S9(9) COMP-5. You should assign\n084300* the result to the variable using the RETURNING clause\n084400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BLOB-WRITE\n084500*      <other call parameters as documented>\n084600*      RETURNING integer-result-variable\n084700* END-CALL\n084800*\n084900     05 SQLITE3-BUSY-HANDLER            PIC X(21)\n085000            VALUE IS Z'sqlite3_busy_handler'.\n085100* This function returns an integer which in COBOL\n085200* would be PIC S9(9) COMP-5. You should assign\n085300* the result to the variable using the RETURNING clause\n085400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BUSY-HANDLER\n085500*      <other call parameters as documented>\n085600*      RETURNING integer-result-variable\n085700* END-CALL\n085800*\n085900     05 SQLITE3-BUSY-TIMEOUT            PIC X(21)\n086000            VALUE IS Z'sqlite3_busy_timeout'.\n086100* This function returns an integer which in COBOL\n086200* would be PIC S9(9) COMP-5. You should assign\n086300* the result to the variable using the RETURNING clause\n086400* CALL SQLITE3 USING BY REFERENCE SQLITE3-BUSY-TIMEOUT\n086500*      <other call parameters as documented>\n086600*      RETURNING integer-result-variable\n086700* END-CALL\n086800*\n086900     05 SQLITE3-CANCEL-AUTO-EXTENSION   PIC X(30)\n087000            VALUE IS Z'sqlite3_cancel_auto_extension'.\n087100* This function returns an integer which in COBOL\n087200* would be PIC S9(9) COMP-5. You should assign\n087300* the result to the variable using the RETURNING clause\n087400* CALL SQLITE3 USING BY REFERENCE SQLITE3-CANCEL-AUTO-EXTENSION\n087500*      <other call parameters as documented>\n087600*      RETURNING integer-result-variable\n087700* END-CALL\n087800*\n087900     05 SQLITE3-CHANGES                 PIC X(16)\n088000            VALUE IS Z'sqlite3_changes'.\n088100* This function returns an integer which in COBOL\n088200* would be PIC S9(9) COMP-5. You should assign\n088300* the result to the variable using the RETURNING clause\n088400* CALL SQLITE3 USING BY REFERENCE SQLITE3-CHANGES\n088500*      <other call parameters as documented>\n088600*      RETURNING integer-result-variable\n088700* END-CALL\n088800*\n088900     05 SQLITE3-CLEAR-BINDINGS          PIC X(23)\n089000            VALUE IS Z'sqlite3_clear_bindings'.\n089100* This function returns an integer which in COBOL\n089200* would be PIC S9(9) COMP-5. You should assign\n089300* the result to the variable using the RETURNING clause\n089400* CALL SQLITE3 USING BY REFERENCE SQLITE3-CLEAR-BINDINGS\n089500*      <other call parameters as documented>\n089600*      RETURNING integer-result-variable\n089700* END-CALL\n089800*\n089900     05 SQLITE3-CLOSE                   PIC X(14)\n090000            VALUE IS Z'sqlite3_close'.\n090100* This function returns an integer which in COBOL\n090200* would be PIC S9(9) COMP-5. You should assign\n090300* the result to the variable using the RETURNING clause\n090400* CALL SQLITE3 USING BY REFERENCE SQLITE3-CLOSE\n090500*      <other call parameters as documented>\n090600*      RETURNING integer-result-variable\n090700* END-CALL\n090800*\n090900     05 SQLITE3-CLOSE-V2                PIC X(17)\n091000            VALUE IS Z'sqlite3_close_v2'.\n091100* This function returns an integer which in COBOL\n091200* would be PIC S9(9) COMP-5. You should assign\n091300* the result to the variable using the RETURNING clause\n091400* CALL SQLITE3 USING BY REFERENCE SQLITE3-CLOSE-VW\n091500*      <other call parameters as documented>\n091600*      RETURNING integer-result-variable\n091700* END-CALL\n091800*\n091900     05 SQLITE3-COLLATION-NEEDED        PIC X(25)\n092000            VALUE IS Z'sqlite3_collation_needed'.\n092100* This function returns an integer which in COBOL\n092200* would be PIC S9(9) COMP-5. You should assign\n092300* the result to the variable using the RETURNING clause\n092400* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLLATION-NEEDED\n092500*      <other call parameters as documented>\n092600*      RETURNING integer-result-variable\n092700* END-CALL\n092800*\n092900     05 SQLITE3-COLLATION-NEEDED16      PIC X(27)\n093000            VALUE IS Z'sqlite3_collation_needed16'.\n093100* This function returns an integer which in COBOL\n093200* would be PIC S9(9) COMP-5. You should assign\n093300* the result to the variable using the RETURNING clause\n093400* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLLATION-NEEDED16\n093500*      <other call parameters as documented>\n093600*      RETURNING integer-result-variable\n093700* END-CALL\n093800*\n093900     05 SQLITE3-COLUMN-BLOB             PIC X(20)\n094000            VALUE IS Z'sqlite3_column_blob'.\n094100* This function returns a pointer which in COBOL\n094200* would be USAGE POINTER. You should assign\n094300* the result to the variable using the RETURNING clause\n094400* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-BLOB\n094500*      <other call parameters as documented>\n094600*      RETURNING pointer-result-variable\n094700* END-CALL\n094800*\n094900     05 SQLITE3-COLUMN-BYTES            PIC X(21)\n095000            VALUE IS Z'sqlite3_column_bytes'.\n095100* This function returns an integer which in COBOL\n095200* would be PIC S9(9) COMP-5. You should assign\n095300* the result to the variable using the RETURNING clause\n095400* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-BYTES\n095500*      <other call parameters as documented>\n095600*      RETURNING integer-result-variable\n095700* END-CALL\n095800*\n095900     05 SQLITE3-COLUMN-BYTES16          PIC X(23)\n096000            VALUE IS Z'sqlite3_column_bytes16'.\n096100* This function returns an integer which in COBOL\n096200* would be PIC S9(9) COMP-5. You should assign\n096300* the result to the variable using the RETURNING clause\n096400* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-BYTES16\n096500*      <other call parameters as documented>\n096600*      RETURNING integer-result-variable\n096700* END-CALL\n096800*\n096900     05 SQLITE3-COLUMN-COUNT            PIC X(21)\n097000            VALUE IS Z'sqlite3_column_count'.\n097100* This function returns an integer which in COBOL\n097200* would be PIC S9(9) COMP-5. You should assign\n097300* the result to the variable using the RETURNING clause\n097400* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-COUNT\n097500*      <other call parameters as documented>\n097600*      RETURNING integer-result-variable\n097700* END-CALL\n097800*\n097900     05 SQLITE3-COLUMN-DATABASE-NAME    PIC X(29)\n098000            VALUE IS Z'sqlite3_column_database_name'.\n098100* This function returns a pointer which in COBOL\n098200* would be USAGE POINTER. You should assign\n098300* the result to the variable using the RETURNING clause\n098400* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-DATABASE-NAME\n098500*      <other call parameters as documented>\n098600*      RETURNING pointer-result-variable\n098700* END-CALL\n098800*\n098900     05 SQLITE3-COLUMN-DATABASE-NAME16  PIC X(32)\n099000            VALUE IS Z'sqlite3_column_database_name16'.\n099100* This function returns a pointer which in COBOL\n099200* would be USAGE POINTER. You should assign\n099300* the result to the variable using the RETURNING clause\n099400* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-DATABASE-NAME16\n099500*      <other call parameters as documented>\n099600*      RETURNING pointer-result-variable\n099700* END-CALL\n099800*\n099900     05 SQLITE3-COLUMN-DECLTYPE         PIC X(24)\n100000            VALUE IS Z'sqlite3_column_decltype'.\n100100* This function returns a pointer which in COBOL\n100200* would be USAGE POINTER. You should assign\n100300* the result to the variable using the RETURNING clause\n100400* CALL SQLITE3 USING BY REFERENCE SQLITE3-DECLTYPE\n100500*      <other call parameters as documented>\n100600*      RETURNING pointer-result-variable\n100700* END-CALL\n100800*\n100900     05 SQLITE3-COLUMN-DECLTYPE16       PIC X(26)\n101000            VALUE IS Z'sqlite3_column_decltype16'.\n101100* This function returns a pointer which in COBOL\n101200* would be USAGE POINTER. You should assign\n101300* the result to the variable using the RETURNING clause\n101400* CALL SQLITE3 USING BY REFERENCE SQLITE3-DECLTYPE16\n101500*      <other call parameters as documented>\n101600*      RETURNING pointer-result-variable\n101700* END-CALL\n101800*\n101900     05 SQLITE3-COLUMN-DOUBLE           PIC X(22)\n102000            VALUE IS Z'sqlite3_column_double'.\n102100* Data is returned as a PIC USAGE COMP-2 in the second\n102200* parameter passed, BY REFERENCE, to SQLITE3A. This parameter is\n102300* inserted before the ones documented in the C API.\n102400* CALL SQLITE3 USING\n102500*              BY REFERENCE SQLITE3-COLUMN-DOUBLE\n102600*              BY REFERENCE double-result-variable\n102700*              <other call parameters as documented>\n102800* END-CALL\n102900* Before using this value, you must convert it from BFP to HFP.\n103000* See the CONVERT-BFP-TO-HFP function below.\n103100*\n103200     05 SQLITE3-COLUMN-INT              PIC X(19)\n103300            VALUE IS Z'sqlite3_column_int'.\n103400* This function returns an integer which in COBOL\n103500* would be PIC S9(9) COMP-5. You should assign\n103600* the result to the variable using the RETURNING clause\n103700* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-INT\n103800*      <other call parameters as documented>\n103900*      RETURNING integer-result-variable\n104000* END-CALL\n104100*\n104200     05 SQLITE3-COLUMN-INT64            PIC X(21)\n104300            VALUE IS Z'sqlite3_column_int64'.\n104400* Data is returned as a PIC S9(18) COMP-5 in the second\n104500* parameter passed, BY REFERENCE, to SQLITE3A. This parameter is\n104600* inserted before the ones documented in the C API.\n104700* This function returns a pointer which in COBOL\n104800* would be USAGE POINTER. You should assign\n104900* the result to the variable using the RETURNING clause\n105000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-INT64\n105100*      BY REFERENCE int64-returned-value\n105200*      <other call parameters as documented>\n105300* END-CALL\n105400*\n105500     05 SQLITE3-COLUMN-NAME             PIC X(20)\n105600            VALUE IS Z'sqlite3_column_name'.\n105700* This function returns a pointer which in COBOL\n105800* would be USAGE POINTER. You should assign\n105900* the result to the variable using the RETURNING clause\n106000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-NAME\n106100*      <other call parameters as documented>\n106200*      RETURNING pointer-result-variable\n106300* END-CALL\n106400*\n106500     05 SQLITE3-COLUMN-NAME16           PIC X(22)\n106600            VALUE IS Z'sqlite3_column_name16'.\n106700* This function returns a pointer which in COBOL\n106800* would be USAGE POINTER. You should assign\n106900* the result to the variable using the RETURNING clause\n107000* CALL SQLITE3 USING BY REFERENCE SQLITE3- COLUMN-NAME16\n107100*      <other call parameters as documented>\n107200*      RETURNING pointer-result-variable\n107300* END-CALL\n107400*\n107500     05 SQLITE3-COLUMN-ORIGIN-NAME      PIC X(27)\n107600            VALUE IS Z'sqlite3_column_origin_name'.\n107700* This function returns a pointer which in COBOL\n107800* would be USAGE POINTER. You should assign\n107900* the result to the variable using the RETURNING clause\n108000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-ORIGIN-NAME\n108100*      <other call parameters as documented>\n108200*      RETURNING pointer-result-variable\n108300* END-CALL\n108400*\n108500     05 SQLITE3-COLUMN-ORIGIN-NAME16    PIC X(29)\n108600            VALUE IS Z'sqlite3_column_origin_name16'.\n108700* This function returns a pointer which in COBOL\n108800* would be USAGE POINTER. You should assign\n108900* the result to the variable using the RETURNING clause\n109000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-ORIGIN-NAME16\n109100*      <other call parameters as documented>\n109200*      RETURNING pointer-result-variable\n109300* END-CALL\n109400*\n109500     05 SQLITE3-COLUMN-TABLE-NAME       PIC X(26)\n109600            VALUE IS Z'sqlite3_column_table_name'.\n109700* This function returns a pointer which in COBOL\n109800* would be USAGE POINTER. You should assign\n109900* the result to the variable using the RETURNING clause\n110000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-TABLE-NAME\n110100*      <other call parameters as documented>\n110200*      RETURNING pointer-result-variable\n110300* END-CALL\n110400*\n110500     05 SQLITE3-COLUMN-TABLE-NAME16     PIC X(28)\n110600            VALUE IS Z'sqlite3_column_table_name16'.\n110700* This function returns a pointer which in COBOL\n110800* would be USAGE POINTER. You should assign\n110900* the result to the variable using the RETURNING clause\n111000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-TABLE-NAME16\n111100*      <other call parameters as documented>\n111200*      RETURNING pointer-result-variable\n111300* END-CALL\n111400*\n111500     05 SQLITE3-COLUMN-TEXT             PIC X(20)\n111600            VALUE IS Z'sqlite3_column_text'.\n111700* This function returns a pointer which in COBOL\n111800* would be USAGE POINTER. You should assign\n111900* the result to the variable using the RETURNING clause\n112000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-TEXT\n112100*      <other call parameters as documented>\n112200*      RETURNING pointer-result-variable\n112300* END-CALL\n112400*\n112500     05 SQLITE3-COLUMN-TEXT16           PIC X(22)\n112600            VALUE IS Z'sqlite3_column_text16'.\n112700* This function returns a pointer which in COBOL\n112800* would be USAGE POINTER. You should assign\n112900* the result to the variable using the RETURNING clause\n113000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-TEXT16\n113100*      <other call parameters as documented>\n113200*      RETURNING pointer-result-variable\n113300* END-CALL\n113400*\n113500     05 SQLITE3-COLUMN-TYPE             PIC X(20)\n113600            VALUE IS Z'sqlite3_column_type'.\n113700*\n113800* This function returns an integer which in COBOL\n113900* would be PIC S9(9) COMP-5. You should assign\n114000* the result to the variable using the RETURNING clause\n114100* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-TYPE\n114200*      <other call parameters as documented>\n114300*      RETURNING integer-result-variable\n114400* END-CALL\n114500     05 SQLITE3-COLUMN-VALUE            PIC X(21)\n114600            VALUE IS Z'sqlite3_column_value'.\n114700* This function returns a pointer which in COBOL\n114800* would be USAGE POINTER. You should assign\n114900* the result to the variable using the RETURNING clause\n115000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COLUMN-VALUE\n115100*      <other call parameters as documented>\n115200*      RETURNING pointer-result-variable\n115300* END-CALL\n115400*\n115500     05 SQLITE3-COMMIT-HOOK             PIC X(20)\n115600            VALUE IS Z'sqlite3_commit_hook'.\n115700* This function returns a pointer which in COBOL\n115800* would be USAGE POINTER. You should assign\n115900* the result to the variable using the RETURNING clause\n116000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COMMIT-HOOK\n116100*      <other call parameters as documented>\n116200*      RETURNING pointer-result-variable\n116300* END-CALL\n116400*\n116500     05 SQLITE3-COMPILEOPTION-GET       PIC X(26)\n116600            VALUE IS Z'sqlite3_compileoption_get'.\n116700* This function returns a pointer which in COBOL\n116800* would be USAGE POINTER. You should assign\n116900* the result to the variable using the RETURNING clause\n117000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COMPILEOPTION-GET\n117100*      <other call parameters as documented>\n117200*      RETURNING pointer-result-variable\n117300* END-CALL\n117400*\n117500     05 SQLITE3-COMPILEOPTION-USED      PIC X(27)\n117600            VALUE IS Z'sqlite3_compileoption_used'.\n117700*\n117800* This function returns an integer which in COBOL\n117900* would be PIC S9(9) COMP-5. You should assign\n118000* the result to the variable using the RETURNING clause\n118100* CALL SQLITE3 USING BY REFERENCE SQLITE3-COMPILEOPTION-USED\n118200*      <other call parameters as documented>\n118300*      RETURNING integer-result-variable\n118400* END-CALL\n118500     05 SQLITE3-COMPLETE                PIC X(17)\n118600            VALUE IS Z'sqlite3_complete'.\n118700* This function returns an integer which in COBOL\n118800* would be PIC S9(9) COMP-5. You should assign\n118900* the result to the variable using the RETURNING clause\n119000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COMPLETE\n119100*      <other call parameters as documented>\n119200*      RETURNING integer-result-variable\n119300* END-CALL\n119400*\n119500     05 SQLITE3-COMPLETE16              PIC X(19)\n119600            VALUE IS Z'sqlite3_complete16'.\n119700* This function returns an integer which in COBOL\n119800* would be PIC S9(9) COMP-5. You should assign\n119900* the result to the variable using the RETURNING clause\n120000* CALL SQLITE3 USING BY REFERENCE SQLITE3-COMPLETE16\n120100*      <other call parameters as documented>\n120200*      RETURNING integer-result-variable\n120300* END-CALL\n120400*\n120500     05 SQLITE3-CONFIG                  PIC X(15)\n120600            VALUE IS Z'sqlite3_config'.\n120700* This function returns an integer which in COBOL\n120800* would be PIC S9(9) COMP-5. You should assign\n120900* the result to the variable using the RETURNING clause\n121000* CALL SQLITE3 USING BY REFERENCE SQLITE3-CONFIG\n121100*      <other call parameters as documented>\n121200*      RETURNING integer-result-variable\n121300* END-CALL\n121400*\n121500     05 SQLITE3-CONTEXT-DB-HANDLE       PIC X(26)\n121600            VALUE IS Z'sqlite3_context_db_handle'.\n121700* This function returns a pointer which in COBOL\n121800* would be USAGE POINTER. You should assign\n121900* the result to the variable using the RETURNING clause\n122000* CALL SQLITE3 USING BY REFERENCE SQLITE3-CONTEXT-DB-HANDLE\n122100*      <other call parameters as documented>\n122200*      RETURNING pointer-result-variable\n122300* END-CALL\n122400*\n122500     05 SQLITE3-CREATE-COLLATION        PIC X(25)\n122600            VALUE IS Z'sqlite3_create_collation'.\n122700* This function returns an integer which in COBOL\n122800* would be PIC S9(9) COMP-5. You should assign\n122900* the result to the variable using the RETURNING clause\n123000* CALL SQLITE3 USING BY REFERENCE SQLITE3-CREATE-COLLATION\n123100*      <other call parameters as documented>\n123200*      RETURNING integer-result-variable\n123300* END-CALL\n123400*\n123500     05 SQLITE3-CREATE-COLLATION-V2     PIC X(28)\n123600            VALUE IS Z'sqlite3_create_collation_v2'.\n123700* This function returns an integer which in COBOL\n123800* would be PIC S9(9) COMP-5. You should assign\n123900* the result to the variable using the RETURNING clause\n124000* CALL SQLITE3 USING BY REFERENCE SQLITE3-CREATE-COLLATION-V2\n124100*      <other call parameters as documented>\n124200*      RETURNING integer-result-variable\n124300* END-CALL\n124400*\n124500     05 SQLITE3-CREATE-COLLATION16      PIC X(27)\n124600            VALUE IS Z'sqlite3_create_collation16'.\n124700* This function returns an integer which in COBOL\n124800* would be PIC S9(9) COMP-5. You should assign\n124900* the result to the variable using the RETURNING clause\n125000* CALL SQLITE3 USING BY REFERENCE SQLITE3-CREATE-COLLATION16\n125100*      <other call parameters as documented>\n125200*      RETURNING integer-result-variable\n125300* END-CALL\n125400*\n125500     05 SQLITE3-CREATE-FUNCTION         PIC X(24)\n125600            VALUE IS Z'sqlite3_create_function'.\n125700* This function returns an integer which in COBOL\n125800* would be PIC S9(9) COMP-5. You should assign\n125900* the result to the variable using the RETURNING clause\n126000* CALL SQLITE3 USING BY REFERENCE SQLITE3-CREATE-FUNCTION\n126100*      <other call parameters as documented>\n126200*      RETURNING integer-result-variable\n126300* END-CALL\n126400*\n126500     05 SQLITE3-CREATE-FUNCTION-V2      PIC X(27)\n126600            VALUE IS Z'sqlite3_create_function_v2'.\n126700* This function returns an integer which in COBOL\n126800* would be PIC S9(9) COMP-5. You should assign\n126900* the result to the variable using the RETURNING clause\n127000* CALL SQLITE3 USING BY REFERENCE SQLITE3-CREATE-FUNCTION-V2\n127100*      <other call parameters as documented>\n127200*      RETURNING integer-result-variable\n127300* END-CALL\n127400*\n127500     05 SQLITE3-CREATE-FUNCTION16       PIC X(26)\n127600            VALUE IS Z'sqlite3_create_function16'.\n127700* This function returns an integer which in COBOL\n127800* would be PIC S9(9) COMP-5. You should assign\n127900* the result to the variable using the RETURNING clause\n128000* CALL SQLITE3 USING BY REFERENCE SQLITE3-CREATE-FUNCTION16\n128100*      <other call parameters as documented>\n128200*      RETURNING integer-result-variable\n128300* END-CALL\n128400*\n128500     05 SQLITE3-CREATE-MODULE           PIC X(22)\n128600            VALUE IS Z'sqlite3_create_module'.\n128700* This function returns an integer which in COBOL\n128800* would be PIC S9(9) COMP-5. You should assign\n128900* the result to the variable using the RETURNING clause\n129000* CALL SQLITE3 USING BY REFERENCE SQLITE3-CREATE-MODULE\n129100*      <other call parameters as documented>\n129200*      RETURNING integer-result-variable\n129300* END-CALL\n129400*\n129500     05 SQLITE3-CREATE-MODULE-V2        PIC X(25)\n129600            VALUE IS Z'sqlite3_create_module_v2'.\n129700* This function returns an integer which in COBOL\n129800* would be PIC S9(9) COMP-5. You should assign\n129900* the result to the variable using the RETURNING clause\n130000* CALL SQLITE3 USING BY REFERENCE SQLITE3-CREATE-MODULE-V2\n130100*      <other call parameters as documented>\n130200*      RETURNING integer-result-variable\n130300* END-CALL\n130400*\n130500     05 SQLITE3-DATA-COUNT              PIC X(19)\n130600            VALUE IS Z'sqlite3_data_count'.\n130700* This function returns an integer which in COBOL\n130800* would be PIC S9(9) COMP-5. You should assign\n130900* the result to the variable using the RETURNING clause\n131000* CALL SQLITE3 USING BY REFERENCE SQLITE3-DATA-COUNT\n131100*      <other call parameters as documented>\n131200*      RETURNING integer-result-variable\n131300* END-CALL\n131400*\n131500     05 SQLITE3-DB-CONFIG               PIC X(18)\n131600            VALUE IS Z'sqlite3_db_config'.\n131700* This function returns an integer which in COBOL\n131800* would be PIC S9(9) COMP-5. You should assign\n131900* the result to the variable using the RETURNING clause\n132000* CALL SQLITE3 USING BY REFERENCE SQLITE3-DB-CONFIG\n132100*      <other call parameters as documented>\n132200*      RETURNING integer-result-variable\n132300* END-CALL\n132400*\n132500     05 SQLITE3-DB-FILENAME             PIC X(20)\n132600            VALUE IS Z'sqlite3_db_filename'.\n132700* This function returns a pointer which in COBOL\n132800* would be USAGE POINTER. You should assign\n132900* the result to the variable using the RETURNING clause\n133000* CALL SQLITE3 USING BY REFERENCE SQLITE3-DB-FILENAME\n133100*      <other call parameters as documented>\n133200*      RETURNING pointer-result-variable\n133300* END-CALL\n133400*\n133500     05 SQLITE3-DB-HANDLE               PIC X(18)\n133600            VALUE IS Z'sqlite3_db_handle'.\n133700* This function returns a pointer which in COBOL\n133800* would be USAGE POINTER. You should assign\n133900* the result to the variable using the RETURNING clause\n134000* CALL SQLITE3 USING BY REFERENCE SQLITE3-DB-HANDLE\n134100*      <other call parameters as documented>\n134200*      RETURNING pointer-result-variable\n134300* END-CALL\n134400*\n134500     05 SQLITE3-DB-MUTEX                PIC X(17)\n134600            VALUE IS Z'sqlite3_db_mutex'.\n134700* This function returns a pointer which in COBOL\n134800* would be USAGE POINTER. You should assign\n134900* the result to the variable using the RETURNING clause\n135000* CALL SQLITE3 USING BY REFERENCE SQLITE3-DB-MUTEX\n135100*      <other call parameters as documented>\n135200*      RETURNING pointer-result-variable\n135300* END-CALL\n135400*\n135500     05 SQLITE3-DB-READONLY             PIC X(20)\n135600            VALUE IS Z'sqlite3_db_readonly'.\n135700* This function returns an integer which in COBOL\n135800* would be PIC S9(9) COMP-5. You should assign\n135900* the result to the variable using the RETURNING clause\n136000* CALL SQLITE3 USING BY REFERENCE SQLITE3-DB-READONLY\n136100*      <other call parameters as documented>\n136200*      RETURNING integer-result-variable\n136300* END-CALL\n136400*\n136500     05 SQLITE3-DB-RELEASE-MEMORY       PIC X(26)\n136600            VALUE IS Z'sqlite3_db_release_memory'.\n136700* This function returns an integer which in COBOL\n136800* would be PIC S9(9) COMP-5. You should assign\n136900* the result to the variable using the RETURNING clause\n137000* CALL SQLITE3 USING BY REFERENCE SQLITE3-DB-RELEASE-MEMORY\n137100*      <other call parameters as documented>\n137200*      RETURNING integer-result-variable\n137300* END-CALL\n137400*\n137500     05 SQLITE3-DB-STATUS               PIC X(18)\n137600            VALUE IS Z'sqlite3_db_status'.\n137700* This function returns an integer which in COBOL\n137800* would be PIC S9(9) COMP-5. You should assign\n137900* the result to the variable using the RETURNING clause\n138000* CALL SQLITE3 USING BY REFERENCE SQLITE3-DB-STATUS\n138100*      <other call parameters as documented>\n138200*      RETURNING integer-result-variable\n138300* END-CALL\n138400*\n138500     05 SQLITE3-DECLARE-VTAB            PIC X(21)\n138600            VALUE IS Z'sqlite3_declare_vtab'.\n138700* This function returns an integer which in COBOL\n138800* would be PIC S9(9) COMP-5. You should assign\n138900* the result to the variable using the RETURNING clause\n139000* CALL SQLITE3 USING BY REFERENCE SQLITE3-DECLARE-VTAB\n139100*      <other call parameters as documented>\n139200*      RETURNING integer-result-variable\n139300* END-CALL\n139400*\n139500     05 SQLITE3-ENABLE-LOAD-EXTENSION   PIC X(30)\n139600            VALUE IS Z'sqlite3_enable_load_extension'.\n139700* This function returns an integer which in COBOL\n139800* would be PIC S9(9) COMP-5. You should assign\n139900* the result to the variable using the RETURNING clause\n140000* CALL SQLITE3 USING BY REFERENCE SQLITE3-ENABLE-LOAD-EXTENSION\n140100*      <other call parameters as documented>\n140200*      RETURNING integer-result-variable\n140300* END-CALL\n140400*\n140500     05 SQLITE3-ENABLE-SHARED-CACHE     PIC X(28)\n140600            VALUE IS Z'sqlite3_enable_shared_cache'.\n140700* This function returns an integer which in COBOL\n140800* would be PIC S9(9) COMP-5. You should assign\n140900* the result to the variable using the RETURNING clause\n141000* CALL SQLITE3 USING BY REFERENCE SQLITE3-ENABLE-SHARED-CACHE\n141100*      <other call parameters as documented>\n141200*      RETURNING integer-result-variable\n141300* END-CALL\n141400*\n141500     05 SQLITE3-ERRCODE                 PIC X(16)\n141600            VALUE IS Z'sqlite3_errcode'.\n141700* This function returns an integer which in COBOL\n141800* would be PIC S9(9) COMP-5. You should assign\n141900* the result to the variable using the RETURNING clause\n142000* CALL SQLITE3 USING BY REFERENCE SQLITE3-ERRCODE\n142100*      <other call parameters as documented>\n142200*      RETURNING integer-result-variable\n142300* END-CALL\n142400*\n142500     05 SQLITE3-ERRMSG                  PIC X(15)\n142600            VALUE IS Z'sqlite3_errmsg'.\n142700* This function returns a pointer which in COBOL\n142800* would be USAGE POINTER. You should assign\n142900* the result to the variable using the RETURNING clause\n143000* CALL SQLITE3 USING BY REFERENCE SQLITE3-ERRMSG\n143100*      <other call parameters as documented>\n143200*      RETURNING pointer-result-variable\n143300* END-CALL\n143400*\n143500     05 SQLITE3-ERRMSG16                PIC X(17)\n143600            VALUE IS Z'sqlite3_errmsg16'.\n143700* This function returns a pointer which in COBOL\n143800* would be USAGE POINTER. You should assign\n143900* the result to the variable using the RETURNING clause\n144000* CALL SQLITE3 USING BY REFERENCE SQLITE3-ERRMSG16\n144100*      <other call parameters as documented>\n144200*      RETURNING pointer-result-variable\n144300* END-CALL\n144400*\n144500     05 SQLITE3-ERRSTR                  PIC X(15)\n144600            VALUE IS Z'sqlite3_errstr'.\n144700* This function returns a pointer which in COBOL\n144800* would be USAGE POINTER. You should assign\n144900* the result to the variable using the RETURNING clause\n145000* CALL SQLITE3 USING BY REFERENCE SQLITE3-ERRSTR\n145100*      <other call parameters as documented>\n145200*      RETURNING pointer-result-variable\n145300* END-CALL\n145400*\n145500     05 SQLITE3-EXEC                    PIC X(13)\n145600            VALUE IS Z'sqlite3_exec'.\n145700* This function returns an integer which in COBOL\n145800* would be PIC S9(9) COMP-5. You should assign\n145900* the result to the variable using the RETURNING clause\n146000* CALL SQLITE3 USING BY REFERENCE SQLITE3-EXEC\n146100*      <other call parameters as documented>\n146200*      RETURNING integer-result-variable\n146300* END-CALL\n146400*\n146500     05 SQLITE3-EXPIRED                 PIC X(16)\n146600            VALUE IS Z'sqlite3_expired'.\n146700* This function returns an integer which in COBOL\n146800* would be PIC S9(9) COMP-5. You should assign\n146900* the result to the variable using the RETURNING clause\n147000* CALL SQLITE3 USING BY REFERENCE SQLITE3-EXPIRED\n147100*      <other call parameters as documented>\n147200*      RETURNING integer-result-variable\n147300* END-CALL\n147400*\n147500     05 SQLITE3-EXTENDED-ERRCODE        PIC X(25)\n147600            VALUE IS Z'sqlite3_extended_errcode'.\n147700* This function returns an integer which in COBOL\n147800* would be PIC S9(9) COMP-5. You should assign\n147900* the result to the variable using the RETURNING clause\n148000* CALL SQLITE3 USING BY REFERENCE SQLITE3-EXTENDED-ERRCODE\n148100*      <other call parameters as documented>\n148200*      RETURNING integer-result-variable\n148300* END-CALL\n148400*\n148500     05 SQLITE3-EXTENDED-RESULT-CODES   PIC X(30)\n148600            VALUE IS Z'sqlite3_extended_result_codes'.\n148700* This function returns an integer which in COBOL\n148800* would be PIC S9(9) COMP-5. You should assign\n148900* the result to the variable using the RETURNING clause\n149000* CALL SQLITE3 USING BY REFERENCE SQLITE3-EXTENDED-RESULT-CODES\n149100*      <other call parameters as documented>\n149200*      RETURNING integer-result-variable\n149300* END-CALL\n149400*\n149500     05 SQLITE3-FILE-CONTROL            PIC X(21)\n149600            VALUE IS Z'sqlite3_file_control'.\n149700* This function returns an integer which in COBOL\n149800* would be PIC S9(9) COMP-5. You should assign\n149900* the result to the variable using the RETURNING clause\n150000* CALL SQLITE3 USING BY REFERENCE SQLITE3-FILE-CONTROL\n150100*      <other call parameters as documented>\n150200*      RETURNING integer-result-variable\n150300* END-CALL\n150400*\n150500     05 SQLITE3-FINALIZE                PIC X(17)\n150600            VALUE IS Z'sqlite3_finalize'.\n150700* This function returns an integer which in COBOL\n150800* would be PIC S9(9) COMP-5. You should assign\n150900* the result to the variable using the RETURNING clause\n151000* CALL SQLITE3 USING BY REFERENCE SQLITE3-FINIALIZE\n151100*      <other call parameters as documented>\n151200*      RETURNING integer-result-variable\n151300* END-CALL\n151400*\n151500     05 SQLITE3-FREE                    PIC X(13)\n151600            VALUE IS Z'sqlite3_free'.\n151700* This function does not return anything at all.\n151800* CALL SQLITE3 USING BY REFERENCE SQLITE3-FREE\n151900*      <other call parameters as documented>\n152000* END-CALL\n152100*\n152200     05 SQLITE3-FREE-TABLE              PIC X(19)\n152300            VALUE IS Z'sqlite3_free_table'.\n152400* This function does not return anything at all.\n152500* CALL SQLITE3 USING BY REFERENCE SQLITE3-FREE-TABLE\n152600*      <other call parameters as documented>\n152700* END-CALL\n152800*\n152900     05 SQLITE3-GET-AUTOCOMMIT          PIC X(23)\n153000            VALUE IS Z'sqlite3_get_autocommit'.\n153100* This function returns an integer which in COBOL\n153200* would be PIC S9(9) COMP-5. You should assign\n153300* the result to the variable using the RETURNING clause\n153400* CALL SQLITE3 USING BY REFERENCE SQLITE3-GET-AUTOCOMMIT\n153500*      <other call parameters as documented>\n153600*      RETURNING integer-result-variable\n153700* END-CALL\n153800*\n153900     05 SQLITE3-GET-AUXDATA             PIC X(20)\n154000            VALUE IS Z'sqlite3_get_auxdata'.\n154100* This function returns a pointer which in COBOL\n154200* would be USAGE POINTER. You should assign\n154300* the result to the variable using the RETURNING clause\n154400* CALL SQLITE3 USING BY REFERENCE SQLITE3-GET-AUXDATA\n154500*      <other call parameters as documented>\n154600*      RETURNING pointer-result-variable\n154700* END-CALL\n154800*\n154900     05 SQLITE3-GET-TABLE               PIC X(18)\n155000            VALUE IS Z'sqlite3_get_table'.\n155100* This function returns an integer which in COBOL\n155200* would be PIC S9(9) COMP-5. You should assign\n155300* the result to the variable using the RETURNING clause\n155400* CALL SQLITE3 USING BY REFERENCE SQLITE3-GET-TABLE\n155500*      <other call parameters as documented>\n155600*      RETURNING integer-result-variable\n155700* END-CALL\n155800*\n155900     05 SQLITE3-GLOBAL-RECOVER          PIC X(23)\n156000            VALUE IS Z'sqlite3_global_recover'.\n156100* This function returns an integer which in COBOL\n156200* would be PIC S9(9) COMP-5. You should assign\n156300* the result to the variable using the RETURNING clause\n156400* CALL SQLITE3 USING BY REFERENCE SQLITE3-GLOBAL-RECOVER\n156500*      <other call parameters as documented>\n156600*      RETURNING integer-result-variable\n156700* END-CALL\n156800*\n156900     05 SQLITE3-INITIALIZE              PIC X(19)\n157000            VALUE IS Z'sqlite3_initialize'.\n157100* This function returns an integer which in COBOL\n157200* would be PIC S9(9) COMP-5. You should assign\n157300* the result to the variable using the RETURNING clause\n157400* CALL SQLITE3 USING BY REFERENCE SQLITE3-INITIALIZE\n157500*      <other call parameters as documented>\n157600*      RETURNING integer-result-variable\n157700* END-CALL\n157800*\n157900     05 SQLITE3-INTERRUPT               PIC X(18)\n158000            VALUE IS Z'sqlite3_interrupt'.\n158100* This function does not return anything at all.\n158200* CALL SQLITE3 USING BY REFERENCE SQLITE3-INTERRUPT\n158300*      <other call parameters as documented>\n158400* END-CALL\n158500*\n158600     05 SQLITE3-LAST-INSERT-ROWID       PIC X(26)\n158700            VALUE IS Z'sqlite3_last_insert_rowid'.\n158800* Data is returned as a PIC S9(18) COMP-5 in the second\n158900* parameter passed, BY REFERENCE, to SQLITE3A. This parameter is\n159000* inserted before the ones documented in the C API.\n159100* This function returns a pointer which in COBOL\n159200* would be USAGE POINTER. You should assign\n159300* the result to the variable using the RETURNING clause\n159400* CALL SQLITE3 USING BY REFERENCE SQLITE3-LAST-INSERT-ROWID\n159500*      BY REFERENCE int64-returned-value\n159600*      <other call parameters as documented>\n159700* END-CALL\n159800*\n159900     05 SQLITE3-LIBVERSION              PIC X(19)\n160000            VALUE IS Z'sqlite3_libversion'.\n160100* This function returns a pointer which in COBOL\n160200* would be USAGE POINTER. You should assign\n160300* the result to the variable using the RETURNING clause\n160400* CALL SQLITE3 USING BY REFERENCE SQLITE3-LIBVERSION\n160500*      <other call parameters as documented>\n160600*      RETURNING pointer-result-variable\n160700* END-CALL\n160800*\n160900     05 SQLITE3-LIBVERSION-NUMBER       PIC X(26)\n161000            VALUE IS Z'sqlite3_libversion_number'.\n161100* This function returns an integer which in COBOL\n161200* would be PIC S9(9) COMP-5. You should assign\n161300* the result to the variable using the RETURNING clause\n161400* CALL SQLITE3 USING BY REFERENCE SQLITE3-LIBVERSION-NUMBER\n161500*      <other call parameters as documented>\n161600*      RETURNING integer-result-variable\n161700* END-CALL\n161800*\n161900     05 SQLITE3-LIMIT                   PIC X(14)\n162000            VALUE IS Z'sqlite3_limit'.\n162100* This function returns an integer which in COBOL\n162200* would be PIC S9(9) COMP-5. You should assign\n162300* the result to the variable using the RETURNING clause\n162400* CALL SQLITE3 USING BY REFERENCE SQLITE3-LIMIT\n162500*      <other call parameters as documented>\n162600*      RETURNING integer-result-variable\n162700* END-CALL\n162800*\n162900     05 SQLITE3-LOAD-EXTENSION          PIC X(23)\n163000            VALUE IS Z'sqlite3_load_extension'.\n163100* This function returns an integer which in COBOL\n163200* would be PIC S9(9) COMP-5. You should assign\n163300* the result to the variable using the RETURNING clause\n163400* CALL SQLITE3 USING BY REFERENCE SQLITE3-LOAD-EXTENSION\n163500*      <other call parameters as documented>\n163600*      RETURNING integer-result-variable\n163700* END-CALL\n163800*\n163900     05 SQLITE3-LOG                     PIC X(12)\n164000            VALUE IS Z'sqlite3_log'.\n164100* This function does not return anything at all.\n164200* CALL SQLITE3 USING BY REFERENCE SQLITE3-LOG\n164300*      <other call parameters as documented>\n164400* END-CALL\n164500*\n164600     05 SQLITE3-MALLOC                  PIC X(15)\n164700            VALUE IS Z'sqlite3_malloc'.\n164800* This function returns a pointer which in COBOL\n164900* would be USAGE POINTER. You should assign\n165000* the result to the variable using the RETURNING clause\n165100* CALL SQLITE3 USING BY REFERENCE SQLITE3-MALLOC\n165200*      <other call parameters as documented>\n165300*      RETURNING pointer-result-variable\n165400* END-CALL\n165500*\n165600     05 SQLITE3-MEMORY-ALARM            PIC X(21)\n165700            VALUE IS Z'sqlite3_memory_alarm'.\n165800* This function returns an integer which in COBOL\n165900* would be PIC S9(9) COMP-5. You should assign\n166000* the result to the variable using the RETURNING clause\n166100* CALL SQLITE3 USING BY REFERENCE SQLITE3-MEMORY-ALARM\n166200*      <other call parameters as documented>\n166300*      RETURNING integer-result-variable\n166400* END-CALL\n166500*\n166600     05 SQLITE3-MEMORY-HIGHWATER        PIC X(25)\n166700            VALUE IS Z'sqlite3_memory_highwater'.\n166800* Data is returned as a PIC S9(18) COMP-5 in the second\n166900* parameter passed, BY REFERENCE, to SQLITE3A. This parameter is\n167000* inserted before the ones documented in the C API.\n167100* This function returns a pointer which in COBOL\n167200* would be USAGE POINTER. You should assign\n167300* the result to the variable using the RETURNING clause\n167400* CALL SQLITE3 USING BY REFERENCE SQLITE3-MEMORY-HIGHWATER\n167500*      BY REFERENCE int64-returned-value\n167600*      <other call parameters as documented>\n167700* END-CALL\n167800*\n167900     05 SQLITE3-MEMORY-USED             PIC X(20)\n168000            VALUE IS Z'sqlite3_memory_used'.\n168100* Data is returned as a PIC S9(18) COMP-5 in the second\n168200* parameter passed, BY REFERENCE, to SQLITE3A. This parameter is\n168300* inserted before the ones documented in the C API.\n168400* This function returns a pointer which in COBOL\n168500* would be USAGE POINTER. You should assign\n168600* the result to the variable using the RETURNING clause\n168700* CALL SQLITE3 USING BY REFERENCE SQLITE3-MEMORY-USED\n168800*      BY REFERENCE int64-returned-value\n168900*      <other call parameters as documented>\n169000* END-CALL\n169100*\n169200     05 SQLITE3-MPRINTF                 PIC X(16)\n169300            VALUE IS Z'sqlite3_mprintf'.\n169400* This function returns a pointer which in COBOL\n169500* would be USAGE POINTER. You should assign\n169600* the result to the variable using the RETURNING clause\n169700* CALL SQLITE3 USING BY REFERENCE SQLITE3-MPRINTF\n169800*      <other call parameters as documented>\n169900*      RETURNING pointer-result-variable\n170000* END-CALL\n170100*\n170200     05 SQLITE3-MUTEX-ALLOC             PIC X(20)\n170300            VALUE IS Z'sqlite3_mutex_alloc'.\n170400* This function returns a pointer which in COBOL\n170500* would be USAGE POINTER. You should assign\n170600* the result to the variable using the RETURNING clause\n170700* CALL SQLITE3 USING BY REFERENCE SQLITE3-MUTEX-ALLOC\n170800*      <other call parameters as documented>\n170900*      RETURNING pointer-result-variable\n171000* END-CALL\n171100*\n171200     05 SQLITE3-MUTEX-ENTER             PIC X(20)\n171300            VALUE IS Z'sqlite3_mutex_enter'.\n171400* This function does not return anything at all.\n171500* CALL SQLITE3 USING BY REFERENCE SQLITE3-MUTEX-ENTER\n171600*      <other call parameters as documented>\n171700* END-CALL\n171800*\n171900     05 SQLITE3-MUTEX-FREE              PIC X(19)\n172000            VALUE IS Z'sqlite3_mutex_free'.\n172100* This function does not return anything at all.\n172200* CALL SQLITE3 USING BY REFERENCE SQLITE3-MUTEX-FREE\n172300*      <other call parameters as documented>\n172400* END-CALL\n172500*\n172600     05 SQLITE3-MUTEX-LEAVE             PIC X(20)\n172700            VALUE IS Z'sqlite3_mutex_leave'.\n172800* This function does not return anything at all.\n172900* CALL SQLITE3 USING BY REFERENCE SQLITE3-MUTEX-LEAVE\n173000*      <other call parameters as documented>\n173100* END-CALL\n173200*\n173300     05 SQLITE3-MUTEX-TRY               PIC X(18)\n173400            VALUE IS Z'sqlite3_mutex_try'.\n173500* This function returns an integer which in COBOL\n173600* would be PIC S9(9) COMP-5. You should assign\n173700* the result to the variable using the RETURNING clause\n173800* CALL SQLITE3 USING BY REFERENCE SQLITE3-MUTEX-TRY\n173900*      <other call parameters as documented>\n174000*      RETURNING integer-result-variable\n174100* END-CALL\n174200*\n174300     05 SQLITE3-NEXT-STMT               PIC X(18)\n174400            VALUE IS Z'sqlite3_next_stmt'.\n174500* This function returns a pointer which in COBOL\n174600* would be USAGE POINTER. You should assign\n174700* the result to the variable using the RETURNING clause\n174800* CALL SQLITE3 USING BY REFERENCE SQLITE3-NEXT-STMT\n174900*      <other call parameters as documented>\n175000*      RETURNING pointer-result-variable\n175100* END-CALL\n175200*\n175300     05 SQLITE3-OPEN                    PIC X(13)\n175400            VALUE IS Z'sqlite3_open'.\n175500* This function returns an integer which in COBOL\n175600* would be PIC S9(9) COMP-5. You should assign\n175700* the result to the variable using the RETURNING clause\n175800* CALL SQLITE3 USING BY REFERENCE SQLITE3-OPEN\n175900*      <other call parameters as documented>\n176000*      RETURNING integer-result-variable\n176100* END-CALL\n176200*\n176300     05 SQLITE3-OPEN-V2                 PIC X(16)\n176400            VALUE IS Z'sqlite3_open_v2'.\n176500* This function returns an integer which in COBOL\n176600* would be PIC S9(9) COMP-5. You should assign\n176700* the result to the variable using the RETURNING clause\n176800* CALL SQLITE3 USING BY REFERENCE SQLITE3-OPEN-V2\n176900*      <other call parameters as documented>\n177000*      RETURNING integer-result-variable\n177100* END-CALL\n177200*\n177300     05 SQLITE3-OPEN16                  PIC X(15)\n177400            VALUE IS Z'sqlite3_open16'.\n177500* This function returns an integer which in COBOL\n177600* would be PIC S9(9) COMP-5. You should assign\n177700* the result to the variable using the RETURNING clause\n177800* CALL SQLITE3 USING BY REFERENCE SQLITE3-OPEN16\n177900*      <other call parameters as documented>\n178000*      RETURNING integer-result-variable\n178100* END-CALL\n178200*\n178300     05 SQLITE3-OS-END                  PIC X(15)\n178400            VALUE IS Z'sqlite3_os_end'.\n178500* This function returns an integer which in COBOL\n178600* would be PIC S9(9) COMP-5. You should assign\n178700* the result to the variable using the RETURNING clause\n178800* CALL SQLITE3 USING BY REFERENCE SQLITE3-OS-END\n178900*      <other call parameters as documented>\n179000*      RETURNING integer-result-variable\n179100* END-CALL\n179200*\n179300     05 SQLITE3-OS-INIT                 PIC X(16)\n179400            VALUE IS Z'sqlite3_os_init'.\n179500* This function returns an integer which in COBOL\n179600* would be PIC S9(9) COMP-5. You should assign\n179700* the result to the variable using the RETURNING clause\n179800* CALL SQLITE3 USING BY REFERENCE SQLITE3-OS-INIT\n179900*      <other call parameters as documented>\n180000*      RETURNING integer-result-variable\n180100* END-CALL\n180200*\n180300     05 SQLITE3-OVERLOAD-FUNCTION       PIC X(26)\n180400            VALUE IS Z'sqlite3_overload_function'.\n180500* This function returns an integer which in COBOL\n180600* would be PIC S9(9) COMP-5. You should assign\n180700* the result to the variable using the RETURNING clause\n180800* CALL SQLITE3 USING BY REFERENCE SQLITE3-OVERLOAD-FUNCTION\n180900*      <other call parameters as documented>\n181000*      RETURNING integer-result-variable\n181100* END-CALL\n181200*\n181300     05 SQLITE3-PREPARE                 PIC X(16)\n181400            VALUE IS Z'sqlite3_prepare'.\n181500* This function returns an integer which in COBOL\n181600* would be PIC S9(9) COMP-5. You should assign\n181700* the result to the variable using the RETURNING clause\n181800* CALL SQLITE3 USING BY REFERENCE SQLITE3-PREPARE\n181900*      <other call parameters as documented>\n182000*      RETURNING integer-result-variable\n182100* END-CALL\n182200*\n182300     05 SQLITE3-PREPARE-V2              PIC X(19)\n182400            VALUE IS Z'sqlite3_prepare_v2'.\n182500* This function returns an integer which in COBOL\n182600* would be PIC S9(9) COMP-5. You should assign\n182700* the result to the variable using the RETURNING clause\n182800* CALL SQLITE3 USING BY REFERENCE SQLITE3-PREPARE-V2\n182900*      <other call parameters as documented>\n183000*      RETURNING integer-result-variable\n183100* END-CALL\n183200*\n183300     05 SQLITE3-PREPARE16               PIC X(18)\n183400            VALUE IS Z'sqlite3_prepare16'.\n183500* This function returns an integer which in COBOL\n183600* would be PIC S9(9) COMP-5. You should assign\n183700* the result to the variable using the RETURNING clause\n183800* CALL SQLITE3 USING BY REFERENCE SQLITE3-PREPARE16\n183900*      <other call parameters as documented>\n184000*      RETURNING integer-result-variable\n184100* END-CALL\n184200*\n184300     05 SQLITE3-PREPARE16-V2            PIC X(21)\n184400            VALUE IS Z'sqlite3_prepare16_v2'.\n184500* This function returns an integer which in COBOL\n184600* would be PIC S9(9) COMP-5. You should assign\n184700* the result to the variable using the RETURNING clause\n184800* CALL SQLITE3 USING BY REFERENCE SQLITE3-PREPARE16-V2\n184900*      <other call parameters as documented>\n185000*      RETURNING integer-result-variable\n185100* END-CALL\n185200*\n185300     05 SQLITE3-PROFILE                 PIC X(16)\n185400            VALUE IS Z'sqlite3_profile'.\n185500* This function returns a pointer which in COBOL\n185600* would be USAGE POINTER. You should assign\n185700* the result to the variable using the RETURNING clause\n185800* CALL SQLITE3 USING BY REFERENCE SQLITE3-PROFILE\n185900*      <other call parameters as documented>\n186000*      RETURNING pointer-result-variable\n186100* END-CALL\n186200*\n186300     05 SQLITE3-PROGRESS-HANDLER        PIC X(25)\n186400            VALUE IS Z'sqlite3_progress_handler'.\n186500* This function does not return anything at all.\n186600* CALL SQLITE3 USING BY REFERENCE SQLITE3-PROGRESS-HANDLER\n186700*      <other call parameters as documented>\n186800* END-CALL\n186900*\n187000     05 SQLITE3-RANDOMNESS              PIC X(19)\n187100            VALUE IS Z'sqlite3_randomness'.\n187200* This function returns an integer which in COBOL\n187300* would be PIC S9(9) COMP-5. You should assign\n187400* the result to the variable using the RETURNING clause\n187500* CALL SQLITE3 USING BY REFERENCE SQLITE3-RANDOMNESS\n187600*      <other call parameters as documented>\n187700*      RETURNING integer-result-variable\n187800* END-CALL\n187900*\n188000     05 SQLITE3-REALLOC                 PIC X(16)\n188100            VALUE IS Z'sqlite3_realloc'.\n188200* This function returns a pointer which in COBOL\n188300* would be USAGE POINTER. You should assign\n188400* the result to the variable using the RETURNING clause\n188500* CALL SQLITE3 USING BY REFERENCE SQLITE3-REALLOC\n188600*      <other call parameters as documented>\n188700*      RETURNING pointer-result-variable\n188800* END-CALL\n188900*\n189000     05 SQLITE3-RELEASE-MEMORY          PIC X(23)\n189100            VALUE IS Z'sqlite3_release_memory'.\n189200* This function returns an integer which in COBOL\n189300* would be PIC S9(9) COMP-5. You should assign\n189400* the result to the variable using the RETURNING clause\n189500* CALL SQLITE3 USING BY REFERENCE SQLITE3-RELEASE-MEMORY\n189600*      <other call parameters as documented>\n189700*      RETURNING integer-result-variable\n189800* END-CALL\n189900*\n190000     05 SQLITE3-RESET                   PIC X(14)\n190100            VALUE IS Z'sqlite3_reset'.\n190200* This function returns an integer which in COBOL\n190300* would be PIC S9(9) COMP-5. You should assign\n190400* the result to the variable using the RETURNING clause\n190500* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESET\n190600*      <other call parameters as documented>\n190700*      RETURNING integer-result-variable\n190800* END-CALL\n190900*\n191000     05 SQLITE3-RESET-AUTO-EXTENSION    PIC X(29)\n191100            VALUE IS Z'sqlite3_reset_auto_extension'.\n191200* This function returns an integer which in COBOL\n191300* would be PIC S9(9) COMP-5. You should assign\n191400* the result to the variable using the RETURNING clause\n191500* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESET-AUTO-EXTENSION\n191600*      <other call parameters as documented>\n191700*      RETURNING integer-result-variable\n191800* END-CALL\n191900*\n192000     05 SQLITE3-RESULT-BLOB             PIC X(20)\n192100            VALUE IS Z'sqlite3_result_blob'.\n192200* This function does not return anything at all.\n192300* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-BLOB\n192400*      <other call parameters as documented>\n192500* END-CALL\n192600*\n192700     05 SQLITE3-RESULT-DOUBLE           PIC X(22)\n192800            VALUE IS Z'sqlite3_result_double'.\n192900* This function does not return anything at all.\n193000* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-DOUBLE\n193100*      <other call parameters as documented>\n193200* END-CALL\n193300*\n193400     05 SQLITE3-RESULT-ERROR            PIC X(21)\n193500            VALUE IS Z'sqlite3_result_error'.\n193600* This function does not return anything at all.\n193700* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-ERROR\n193800*      <other call parameters as documented>\n193900* END-CALL\n194000*\n194100     05 SQLITE3-RESULT-ERROR-CODE       PIC X(26)\n194200            VALUE IS Z'sqlite3_result_error_code'.\n194300* This function does not return anything at all.\n194400* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-ERROR-CODE\n194500*      <other call parameters as documented>\n194600* END-CALL\n194700*\n194800     05 SQLITE3-RESULT-ERROR-NOMEM      PIC X(27)\n194900            VALUE IS Z'sqlite3_result_error_nomem'.\n195000* This function does not return anything at all.\n195100* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-ERROR-NOMEM\n195200*      <other call parameters as documented>\n195300* END-CALL\n195400*\n195500     05 SQLITE3-RESULT-ERROR-TOOBIG     PIC X(28)\n195600            VALUE IS Z'sqlite3_result_error_toobig'.\n195700* This function does not return anything at all.\n195800* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-ERROR-TOOBIG\n195900*      <other call parameters as documented>\n196000* END-CALL\n196100*\n196200     05 SQLITE3-RESULT-ERROR16          PIC X(23)\n196300            VALUE IS Z'sqlite3_result_error16'.\n196400* This function does not return anything at all.\n196500* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-ERROR16\n196600*      <other call parameters as documented>\n196700* END-CALL\n196800*\n196900     05 SQLITE3-RESULT-INT              PIC X(19)\n197000            VALUE IS Z'sqlite3_result_int'.\n197100* This function does not return anything at all.\n197200* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-INT\n197300*      <other call parameters as documented>\n197400* END-CALL\n197500*\n197600     05 SQLITE3-RESULT-INT64            PIC X(21)\n197700            VALUE IS Z'sqlite3_result_int64'.\n197800* This function does not return anything at all.\n197900* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-INT64\n198000*      <other call parameters as documented>\n198100* END-CALL\n198200*\n198300     05 SQLITE3-RESULT-NULL             PIC X(20)\n198400            VALUE IS Z'sqlite3_result_null'.\n198500* This function does not return anything at all.\n198600* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-NULL\n198700*      <other call parameters as documented>\n198800* END-CALL\n198900*\n199000     05 SQLITE3-RESULT-TEXT             PIC X(20)\n199100            VALUE IS Z'sqlite3_result_text'.\n199200* This function does not return anything at all.\n199300* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-TEXT\n199400*      <other call parameters as documented>\n199500* END-CALL\n199600*\n199700     05 SQLITE3-RESULT-TEXT16           PIC X(22)\n199800            VALUE IS Z'sqlite3_result_text16'.\n199900* This function does not return anything at all.\n200000* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-TEXT16\n200100*      <other call parameters as documented>\n200200* END-CALL\n200300*\n200400     05 SQLITE3-RESULT-TEXT16BE         PIC X(24)\n200500            VALUE IS Z'sqlite3_result_text16be'.\n200600* This function does not return anything at all.\n200700* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-TEXT16BE\n200800*      <other call parameters as documented>\n200900* END-CALL\n201000*\n201100     05 SQLITE3-RESULT-TEXT16LE         PIC X(24)\n201200            VALUE IS Z'sqlite3_result_text16le'.\n201300* This function does not return anything at all.\n201400* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-TEXT16LE\n201500*      <other call parameters as documented>\n201600* END-CALL\n201700*\n201800     05 SQLITE3-RESULT-VALUE            PIC X(21)\n201900            VALUE IS Z'sqlite3_result_value'.\n202000* This function does not return anything at all.\n202100* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-VALUE\n202200*      <other call parameters as documented>\n202300* END-CALL\n202400*\n202500     05 SQLITE3-RESULT-ZEROBLOB         PIC X(24)\n202600            VALUE IS Z'sqlite3_result_zeroblob'.\n202700* This function does not return anything at all.\n202800* CALL SQLITE3 USING BY REFERENCE SQLITE3-RESULT-ZEROBLOB\n202900*      <other call parameters as documented>\n203000* END-CALL\n203100*\n203200     05 SQLITE3-ROLLBACK-HOOK           PIC X(22)\n203300            VALUE IS Z'sqlite3_rollback_hook'.\n203400* This function returns a pointer which in COBOL\n203500* would be USAGE POINTER. You should assign\n203600* the result to the variable using the RETURNING clause\n203700* CALL SQLITE3 USING BY REFERENCE SQLITE3-ROLLBACK-HOOK\n203800*      <other call parameters as documented>\n203900*      RETURNING pointer-result-variable\n204000* END-CALL\n204100*\n204200     05 SQLITE3-RTREE-GEOMETRY-CALLBK   PIC X(32)\n204300            VALUE IS Z'sqlite3_rtree_geometry_callback'.\n204400* This function returns an integer which in COBOL\n204500* would be PIC S9(9) COMP-5. You should assign\n204600* the result to the variable using the RETURNING clause\n204700* CALL SQLITE3 USING BY REFERENCE SQLITE3-RTREE-GEOMETRY-CALLBK\n204800*      <other call parameters as documented>\n204900*      RETURNING integer-result-variable\n205000* END-CALL\n205100*\n205200     05 SQLITE3-SET-AUTHORIZER          PIC X(23)\n205300            VALUE IS Z'sqlite3_set_authorizer'.\n205400* This function returns an integer which in COBOL\n205500* would be PIC S9(9) COMP-5. You should assign\n205600* the result to the variable using the RETURNING clause\n205700* CALL SQLITE3 USING BY REFERENCE SQLITE3-SET-AUTHORIZER\n205800*      <other call parameters as documented>\n205900*      RETURNING integer-result-variable\n206000* END-CALL\n206100*\n206200     05 SQLITE3-SET-AUXDATA             PIC X(20)\n206300            VALUE IS Z'sqlite3_set_auxdata'.\n206400* This function does not return anything at all.\n206500* CALL SQLITE3 USING BY REFERENCE SQLITE3-SET-AUXDATA\n206600*      <other call parameters as documented>\n206700* END-CALL\n206800*\n206900     05 SQLITE3-SHUTDOWN                PIC X(17)\n207000            VALUE IS Z'sqlite3_shutdown'.\n207100* This function returns an integer which in COBOL\n207200* would be PIC S9(9) COMP-5. You should assign\n207300* the result to the variable using the RETURNING clause\n207400* CALL SQLITE3 USING BY REFERENCE SQLITE3-SHUTDOWN\n207500*      <other call parameters as documented>\n207600*      RETURNING integer-result-variable\n207700* END-CALL\n207800*\n207900     05 SQLITE3-SLEEP                   PIC X(14)\n208000            VALUE IS Z'sqlite3_sleep'.\n208100* This function returns an integer which in COBOL\n208200* would be PIC S9(9) COMP-5. You should assign\n208300* the result to the variable using the RETURNING clause\n208400* CALL SQLITE3 USING BY REFERENCE SQLITE3-SLEEP\n208500*      <other call parameters as documented>\n208600*      RETURNING integer-result-variable\n208700* END-CALL\n208800*\n208900     05 SQLITE3-SNPRINTF                PIC X(17)\n209000            VALUE IS Z'sqlite3_snprintf'.\n209100* This function returns a pointer which in COBOL\n209200* would be USAGE POINTER. You should assign\n209300* the result to the variable using the RETURNING clause\n209400* CALL SQLITE3 USING BY REFERENCE SQLITE3-SNPRINTF\n209500*      <other call parameters as documented>\n209600*      RETURNING pointer-result-variable\n209700* END-CALL\n209800*\n209900     05 SQLITE3-SOFT-HEAP-LIMIT         PIC X(24)\n210000            VALUE IS Z'sqlite3_soft_heap_limit'.\n210100* This function does not return anything at all.\n210200* CALL SQLITE3 USING BY REFERENCE SQLITE3-SOFT-HEAP-LIMIT\n210300*      <other call parameters as documented>\n210400* END-CALL\n210500*\n210600     05 SQLITE3-SOFT-HEAP-LIMIT64       PIC X(26)\n210700            VALUE IS Z'sqlite3_soft_heap_limit64'.\n210800* Data is returned as a PIC S9(18) COMP-5 in the second\n210900* parameter passed, BY REFERENCE, to SQLITE3A. This parameter is\n211000* inserted before the ones documented in the C API.\n211100* This function returns a pointer which in COBOL\n211200* would be USAGE POINTER. You should assign\n211300* the result to the variable using the RETURNING clause\n211400* CALL SQLITE3 USING BY REFERENCE SQLITE3-SOFT-HEAP-LIMIT64\n211500*      BY REFERENCE int64-returned-value\n211600*      <other call parameters as documented>\n211700* END-CALL\n211800*\n211900     05 SQLITE3-SOURCEID                PIC X(17)\n212000            VALUE IS Z'sqlite3_sourceid'.\n212100* This function returns a pointer which in COBOL\n212200* would be USAGE POINTER. You should assign\n212300* the result to the variable using the RETURNING clause\n212400* CALL SQLITE3 USING BY REFERENCE SQLITE3-SOURCEID\n212500*      <other call parameters as documented>\n212600*      RETURNING pointer-result-variable\n212700* END-CALL\n212800*\n212900     05 SQLITE3-SQL                     PIC X(12)\n213000            VALUE IS Z'sqlite3_sql'.\n213100* This function returns a pointer which in COBOL\n213200* would be USAGE POINTER. You should assign\n213300* the result to the variable using the RETURNING clause\n213400* CALL SQLITE3 USING BY REFERENCE SQLITE3-SQL\n213500*      <other call parameters as documented>\n213600*      RETURNING pointer-result-variable\n213700* END-CALL\n213800*\n213900     05 SQLITE3-STATUS                  PIC X(15)\n214000            VALUE IS Z'sqlite3_status'.\n214100* This function returns an integer which in COBOL\n214200* would be PIC S9(9) COMP-5. You should assign\n214300* the result to the variable using the RETURNING clause\n214400* CALL SQLITE3 USING BY REFERENCE SQLITE3-STATUS\n214500*      <other call parameters as documented>\n214600*      RETURNING integer-result-variable\n214700* END-CALL\n214800*\n214900     05 SQLITE3-STEP                    PIC X(13)\n215000            VALUE IS Z'sqlite3_step'.\n215100* This function returns an integer which in COBOL\n215200* would be PIC S9(9) COMP-5. You should assign\n215300* the result to the variable using the RETURNING clause\n215400* CALL SQLITE3 USING BY REFERENCE SQLITE3-STEP\n215500*      <other call parameters as documented>\n215600*      RETURNING integer-result-variable\n215700* END-CALL\n215800*\n215900     05 SQLITE3-STMT-BUSY               PIC X(18)\n216000            VALUE IS Z'sqlite3_stmt_busy'.\n216100* This function returns an integer which in COBOL\n216200* would be PIC S9(9) COMP-5. You should assign\n216300* the result to the variable using the RETURNING clause\n216400* CALL SQLITE3 USING BY REFERENCE SQLITE3-STMT-BUSY\n216500*      <other call parameters as documented>\n216600*      RETURNING integer-result-variable\n216700* END-CALL\n216800*\n216900     05 SQLITE3-STMT-READONLY           PIC X(22)\n217000            VALUE IS Z'sqlite3_stmt_readonly'.\n217100* This function returns an integer which in COBOL\n217200* would be PIC S9(9) COMP-5. You should assign\n217300* the result to the variable using the RETURNING clause\n217400* CALL SQLITE3 USING BY REFERENCE SQLITE3-STMT-READONLY\n217500*      <other call parameters as documented>\n217600*      RETURNING integer-result-variable\n217700* END-CALL\n217800*\n217900     05 SQLITE3-STMT-STATUS             PIC X(20)\n218000            VALUE IS Z'sqlite3_stmt_status'.\n218100* This function returns an integer which in COBOL\n218200* would be PIC S9(9) COMP-5. You should assign\n218300* the result to the variable using the RETURNING clause\n218400* CALL SQLITE3 USING BY REFERENCE SQLITE3-STMT-STATUS\n218500*      <other call parameters as documented>\n218600*      RETURNING integer-result-variable\n218700* END-CALL\n218800*\n218900     05 SQLITE3-STRGLOB                 PIC X(16)\n219000            VALUE IS Z'sqlite3_strglob'.\n219100* This function returns an integer which in COBOL\n219200* would be PIC S9(9) COMP-5. You should assign\n219300* the result to the variable using the RETURNING clause\n219400* CALL SQLITE3 USING BY REFERENCE SQLITE3-STRGLOB\n219500*      <other call parameters as documented>\n219600*      RETURNING integer-result-variable\n219700* END-CALL\n219800*\n219900     05 SQLITE3-STRICMP                 PIC X(16)\n220000            VALUE IS Z'sqlite3_stricmp'.\n220100* This function returns an integer which in COBOL\n220200* would be PIC S9(9) COMP-5. You should assign\n220300* the result to the variable using the RETURNING clause\n220400* CALL SQLITE3 USING BY REFERENCE SQLITE3-STRICMP\n220500*      <other call parameters as documented>\n220600*      RETURNING integer-result-variable\n220700* END-CALL\n220800*\n220900     05 SQLITE3-STRNICMP                PIC X(17)\n221000            VALUE IS Z'sqlite3_strnicmp'.\n221100* This function returns an integer which in COBOL\n221200* would be PIC S9(9) COMP-5. You should assign\n221300* the result to the variable using the RETURNING clause\n221400* CALL SQLITE3 USING BY REFERENCE SQLITE3-STRNICMP\n221500*      <other call parameters as documented>\n221600*      RETURNING integer-result-variable\n221700* END-CALL\n221800*\n221900     05 SQLITE3-TABLE-COLUMN-METADATA   PIC X(30)\n222000            VALUE IS Z'sqlite3_table_column_metadata'.\n222100* This function returns an integer which in COBOL\n222200* would be PIC S9(9) COMP-5. You should assign\n222300* the result to the variable using the RETURNING clause\n222400* CALL SQLITE3 USING BY REFERENCE SQLITE3-TABLE-COLUMN-METADATA\n222500*      <other call parameters as documented>\n222600*      RETURNING integer-result-variable\n222700* END-CALL\n222800*\n222900     05 SQLITE3-TEST-CONTROL            PIC X(21)\n223000            VALUE IS Z'sqlite3_test_control'.\n223100* This function returns an integer which in COBOL\n223200* would be PIC S9(9) COMP-5. You should assign\n223300* the result to the variable using the RETURNING clause\n223400* CALL SQLITE3 USING BY REFERENCE SQLITE3-TEST-CONTROL\n223500*      <other call parameters as documented>\n223600*      RETURNING integer-result-variable\n223700* END-CALL\n223800*\n223900     05 SQLITE3-THREAD-CLEANUP          PIC X(23)\n224000            VALUE IS Z'sqlite3_thread_cleanup'.\n224100* This function does not return anything at all.\n224200* CALL SQLITE3 USING BY REFERENCE SQLITE3-THREAD-CLEANUP\n224300*      <other call parameters as documented>\n224400* END-CALL\n224500*\n224600     05 SQLITE3-THREADSAFE              PIC X(19)\n224700            VALUE IS Z'sqlite3_threadsafe'.\n224800* This function returns an integer which in COBOL\n224900* would be PIC S9(9) COMP-5. You should assign\n225000* the result to the variable using the RETURNING clause\n225100* CALL SQLITE3 USING BY REFERENCE SQLITE3-THREADSAFE\n225200*      <other call parameters as documented>\n225300*      RETURNING integer-result-variable\n225400* END-CALL\n225500*\n225600     05 SQLITE3-TOTAL-CHANGES           PIC X(22)\n225700            VALUE IS Z'sqlite3_total_changes'.\n225800* This function returns an integer which in COBOL\n225900* would be PIC S9(9) COMP-5. You should assign\n226000* the result to the variable using the RETURNING clause\n226100* CALL SQLITE3 USING BY REFERENCE SQLITE3-TOTAL-CHANGES\n226200*      <other call parameters as documented>\n226300*      RETURNING integer-result-variable\n226400* END-CALL\n226500*\n226600     05 SQLITE3-TRACE                   PIC X(14)\n226700            VALUE IS Z'sqlite3_trace'.\n226800* This function returns a pointer which in COBOL\n226900* would be USAGE POINTER. You should assign\n227000* the result to the variable using the RETURNING clause\n227100* CALL SQLITE3 USING BY REFERENCE SQLITE3-TRACE\n227200*      <other call parameters as documented>\n227300*      RETURNING pointer-result-variable\n227400* END-CALL\n227500*\n227600     05 SQLITE3-TRANSFER-BINDINGS       PIC X(26)\n227700            VALUE IS Z'sqlite3_transfer_bindings'.\n227800* This function returns an integer which in COBOL\n227900* would be PIC S9(9) COMP-5. You should assign\n228000* the result to the variable using the RETURNING clause\n228100* CALL SQLITE3 USING BY REFERENCE SQLITE3-TRANSFER-BINDINGS\n228200*      <other call parameters as documented>\n228300*      RETURNING integer-result-variable\n228400* END-CALL\n228500*\n228600     05 SQLITE3-UPDATE-HOOK             PIC X(20)\n228700            VALUE IS Z'sqlite3_update_hook'.\n228800* This function returns a pointer which in COBOL\n228900* would be USAGE POINTER. You should assign\n229000* the result to the variable using the RETURNING clause\n229100* CALL SQLITE3 USING BY REFERENCE SQLITE3-UPDATE-HOOK\n229200*      <other call parameters as documented>\n229300*      RETURNING pointer-result-variable\n229400* END-CALL\n229500*\n229600     05 SQLITE3-URI-BOOLEAN             PIC X(20)\n229700            VALUE IS Z'sqlite3_uri_boolean'.\n229800* This function returns an integer which in COBOL\n229900* would be PIC S9(9) COMP-5. You should assign\n230000* the result to the variable using the RETURNING clause\n230100* CALL SQLITE3 USING BY REFERENCE SQLITE3-URI-BOOLEAN\n230200*      <other call parameters as documented>\n230300*      RETURNING integer-result-variable\n230400* END-CALL\n230500*\n230600     05 SQLITE3-URI-INT64               PIC X(18)\n230700            VALUE IS Z'sqlite3_uri_int64'.\n230800* Data is returned as a PIC S9(18) COMP-5 in the second\n230900* parameter passed, BY REFERENCE, to SQLITE3A. This parameter is\n231000* inserted before the ones documented in the C API.\n231100* This function returns a pointer which in COBOL\n231200* would be USAGE POINTER. You should assign\n231300* the result to the variable using the RETURNING clause\n231400* CALL SQLITE3 USING BY REFERENCE SQLITE3-URI-INT64\n231500*      BY REFERENCE int64-returned-value\n231600*      <other call parameters as documented>\n231700* END-CALL\n231800*\n231900     05 SQLITE3-URI-PARAMETER           PIC X(22)\n232000            VALUE IS Z'sqlite3_uri_parameter'.\n232100* This function returns a pointer which in COBOL\n232200* would be USAGE POINTER. You should assign\n232300* the result to the variable using the RETURNING clause\n232400* CALL SQLITE3 USING BY REFERENCE SQLITE3-URI-PARAMETER\n232500*      <other call parameters as documented>\n232600*      RETURNING pointer-result-variable\n232700* END-CALL\n232800*\n232900     05 SQLITE3-USER-DATA               PIC X(18)\n233000            VALUE IS Z'sqlite3_user_data'.\n233100* This function returns a pointer which in COBOL\n233200* would be USAGE POINTER. You should assign\n233300* the result to the variable using the RETURNING clause\n233400* CALL SQLITE3 USING BY REFERENCE SQLITE3-USER-DATA\n233500*      <other call parameters as documented>\n233600*      RETURNING pointer-result-variable\n233700* END-CALL\n233800*\n233900     05 SQLITE3-VALUE-BLOB              PIC X(19)\n234000            VALUE IS Z'sqlite3_value_blob'.\n234100* This function returns a pointer which in COBOL\n234200* would be USAGE POINTER. You should assign\n234300* the result to the variable using the RETURNING clause\n234400* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-BLOB\n234500*      <other call parameters as documented>\n234600*      RETURNING pointer-result-variable\n234700* END-CALL\n234800*\n234900     05 SQLITE3-VALUE-BYTES             PIC X(20)\n235000            VALUE IS Z'sqlite3_value_bytes'.\n235100* This function returns an integer which in COBOL\n235200* would be PIC S9(9) COMP-5. You should assign\n235300* the result to the variable using the RETURNING clause\n235400* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-BYTES\n235500*      <other call parameters as documented>\n235600*      RETURNING integer-result-variable\n235700* END-CALL\n235800*\n235900     05 SQLITE3-VALUE-BYTES16           PIC X(22)\n236000            VALUE IS Z'sqlite3_value_bytes16'.\n236100* This function returns an integer which in COBOL\n236200* would be PIC S9(9) COMP-5. You should assign\n236300* the result to the variable using the RETURNING clause\n236400* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-BYTES16\n236500*      <other call parameters as documented>\n236600*      RETURNING integer-result-variable\n236700* END-CALL\n236800*\n236900     05 SQLITE3-VALUE-DOUBLE            PIC X(21)\n237000            VALUE IS Z'sqlite3_value_double'.\n237100* Data is returned as a PIC S9(18) COMP-5 in the second\n237200* parameter passed, BY REFERENCE, to SQLITE3A. This parameter is\n237300* inserted before the ones documented in the C API.\n237400* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-DOUBLE\n237500*      BY REFERENCE double-result-variable\n237600*      <other call parameters as documented>\n237700* END-CALL\n237800* Before using this value, you must convert it from BFP to HFP.\n237900* See the CONVERT-BFP-TO-HFP function below.\n238000*\n238100     05 SQLITE3-VALUE-INT               PIC X(18)\n238200            VALUE IS Z'sqlite3_value_int'.\n238300* This function returns an integer which in COBOL\n238400* would be PIC S9(9) COMP-5. You should assign\n238500* the result to the variable using the RETURNING clause\n238600* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-INT\n238700*      <other call parameters as documented>\n238800*      RETURNING integer-result-variable\n238900* END-CALL\n239000*\n239100     05 SQLITE3-VALUE-INT64             PIC X(20)\n239200            VALUE IS Z'sqlite3_value_int64'.\n239300* Data is returned as a PIC S9(18) COMP-5 in the second\n239400* parameter passed, BY REFERENCE, to SQLITE3A. This parameter is\n239500* inserted before the ones documented in the C API.\n239600* This function returns a pointer which in COBOL\n239700* would be USAGE POINTER. You should assign\n239800* the result to the variable using the RETURNING clause\n239900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-INT64\n240000*      BY REFERENCE int64-returned-value\n240100*      <other call parameters as documented>\n240200* END-CALL\n240300*\n240400     05 SQLITE3-VALUE-NUMERIC-TYPE      PIC X(27)\n240500            VALUE IS Z'sqlite3_value_numeric_type'.\n240600* This function returns an integer which in COBOL\n240700* would be PIC S9(9) COMP-5. You should assign\n240800* the result to the variable using the RETURNING clause\n240900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-NUMERIC-TYPE\n241000*      <other call parameters as documented>\n241100*      RETURNING integer-result-variable\n241200* END-CALL\n241300*\n241400     05 SQLITE3-VALUE-TEXT              PIC X(19)\n241500            VALUE IS Z'sqlite3_value_text'.\n241600* This function returns a pointer which in COBOL\n241700* would be USAGE POINTER. You should assign\n241800* the result to the variable using the RETURNING clause\n241900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-TEXT\n242000*      <other call parameters as documented>\n242100*      RETURNING pointer-result-variable\n242200* END-CALL\n242300*\n242400     05 SQLITE3-VALUE-TEXT16            PIC X(21)\n242500            VALUE IS Z'sqlite3_value_text16'.\n242600* This function returns a pointer which in COBOL\n242700* would be USAGE POINTER. You should assign\n242800* the result to the variable using the RETURNING clause\n242900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-TEXT16\n243000*      <other call parameters as documented>\n243100*      RETURNING pointer-result-variable\n243200* END-CALL\n243300*\n243400     05 SQLITE3-VALUE-TEXT16BE          PIC X(23)\n243500            VALUE IS Z'sqlite3_value_text16be'.\n243600* This function returns a pointer which in COBOL\n243700* would be USAGE POINTER. You should assign\n243800* the result to the variable using the RETURNING clause\n243900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-TEXT16BE\n244000*      <other call parameters as documented>\n244100*      RETURNING pointer-result-variable\n244200* END-CALL\n244300*\n244400     05 SQLITE3-VALUE-TEXT16LE          PIC X(23)\n244500            VALUE IS Z'sqlite3_value_text16le'.\n244600* This function returns a pointer which in COBOL\n244700* would be USAGE POINTER. You should assign\n244800* the result to the variable using the RETURNING clause\n244900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-TEXT16LE\n245000*      <other call parameters as documented>\n245100*      RETURNING pointer-result-variable\n245200* END-CALL\n245300*\n245400     05 SQLITE3-VALUE-TYPE              PIC X(19)\n245500            VALUE IS Z'sqlite3_value_type'.\n245600* This function returns an integer which in COBOL\n245700* would be PIC S9(9) COMP-5. You should assign\n245800* the result to the variable using the RETURNING clause\n245900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VALUE-TYPE\n246000*      <other call parameters as documented>\n246100*      RETURNING integer-result-variable\n246200* END-CALL\n246300*\n246400     05 SQLITE3-VFS-FIND                PIC X(17)\n246500            VALUE IS Z'sqlite3_vfs_find'.\n246600* This function returns a pointer which in COBOL\n246700* would be USAGE POINTER. You should assign\n246800* the result to the variable using the RETURNING clause\n246900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VFS-FIND\n247000*      <other call parameters as documented>\n247100*      RETURNING pointer-result-variable\n247200* END-CALL\n247300*\n247400     05 SQLITE3-VFS-REGISTER            PIC X(21)\n247500            VALUE IS Z'sqlite3_vfs_register'.\n247600* This function returns an integer which in COBOL\n247700* would be PIC S9(9) COMP-5. You should assign\n247800* the result to the variable using the RETURNING clause\n247900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VFS-REGISTER\n248000*      <other call parameters as documented>\n248100*      RETURNING integer-result-variable\n248200* END-CALL\n248300*\n248400     05 SQLITE3-VFS-UNREGISTER          PIC X(23)\n248500            VALUE IS Z'sqlite3_vfs_unregister'.\n248600* This function returns an integer which in COBOL\n248700* would be PIC S9(9) COMP-5. You should assign\n248800* the result to the variable using the RETURNING clause\n248900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VFS-UNREGISTER\n249000*      <other call parameters as documented>\n249100*      RETURNING integer-result-variable\n249200* END-CALL\n249300*\n249400     05 SQLITE3-VMPRINTF                PIC X(17)\n249500            VALUE IS Z'sqlite3_vmprintf'.\n249600* This function returns a pointer which in COBOL\n249700* would be USAGE POINTER. You should assign\n249800* the result to the variable using the RETURNING clause\n249900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VMPRINTF\n250000*      <other call parameters as documented>\n250100*      RETURNING pointer-result-variable\n250200* END-CALL\n250300*\n250400     05 SQLITE3-VSNPRINTF               PIC X(18)\n250500            VALUE IS Z'sqlite3_vsnprintf'.\n250600* This function returns a pointer which in COBOL\n250700* would be USAGE POINTER. You should assign\n250800* the result to the variable using the RETURNING clause\n250900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VSNPRINTF\n251000*      <other call parameters as documented>\n251100*      RETURNING pointer-result-variable\n251200* END-CALL\n251300*\n251400     05 SQLITE3-VTAB-CONFIG             PIC X(20)\n251500            VALUE IS Z'sqlite3_vtab_config'.\n251600* This function returns an integer which in COBOL\n251700* would be PIC S9(9) COMP-5. You should assign\n251800* the result to the variable using the RETURNING clause\n251900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VTAB-CONFIG\n252000*      <other call parameters as documented>\n252100*      RETURNING integer-result-variable\n252200* END-CALL\n252300*\n252400     05 SQLITE3-VTAB-ON-CONFLICT        PIC X(25)\n252500            VALUE IS Z'sqlite3_vtab_on_conflict'.\n252600* This function returns an integer which in COBOL\n252700* would be PIC S9(9) COMP-5. You should assign\n252800* the result to the variable using the RETURNING clause\n252900* CALL SQLITE3 USING BY REFERENCE SQLITE3-VTAB-ON-CONFLICT\n253000*      <other call parameters as documented>\n253100*      RETURNING integer-result-variable\n253200* END-CALL\n253300*\n253400     05 SQLITE3-WAL-AUTOCHECKPOINT      PIC X(27)\n253500            VALUE IS Z'sqlite3_wal_autocheckpoint'.\n253600* This function returns an integer which in COBOL\n253700* would be PIC S9(9) COMP-5. You should assign\n253800* the result to the variable using the RETURNING clause\n253900* CALL SQLITE3 USING BY REFERENCE SQLITE3-WAL-AUTOCHECKPOINT\n254000*      <other call parameters as documented>\n254100*      RETURNING integer-result-variable\n254200* END-CALL\n254300*\n254400     05 SQLITE3-WAL-CHECKPOINT          PIC X(23)\n254500            VALUE IS Z'sqlite3_wal_checkpoint'.\n254600* This function returns an integer which in COBOL\n254700* would be PIC S9(9) COMP-5. You should assign\n254800* the result to the variable using the RETURNING clause\n254900* CALL SQLITE3 USING BY REFERENCE SQLITE3-WAL-CHECKPOINT\n255000*      <other call parameters as documented>\n255100*      RETURNING integer-result-variable\n255200* END-CALL\n255300*\n255400     05 SQLITE3-WAL-CHECKPOINT-V2       PIC X(26)\n255500            VALUE IS Z'sqlite3_wal_checkpoint_v2'.\n255600* This function returns an integer which in COBOL\n255700* would be PIC S9(9) COMP-5. You should assign\n255800* the result to the variable using the RETURNING clause\n255900* CALL SQLITE3 USING BY REFERENCE SQLITE3-WAL-CHECKPOINT-V2\n256000*      <other call parameters as documented>\n256100*      RETURNING integer-result-variable\n256200* END-CALL\n256300*\n256400     05 SQLITE3-WAL-HOOK                PIC X(17)\n256500            VALUE IS Z'sqlite3_wal_hook'.\n256600* This function returns a pointer which in COBOL\n256700* would be USAGE POINTER. You should assign\n256800* the result to the variable using the RETURNING clause\n256900* CALL SQLITE3 USING BY REFERENCE SQLITE3-WAL-HOOK\n257000*      <other call parameters as documented>\n257100*      RETURNING pointer-result-variable\n257200*\n257300* END-CALL\n257400     05 CONVERT-BFP-TO-HFP              PIC X(19)\n257500            VALUE IS Z'convert_bfp_to_hfp'.\n257600* This function should be called after retrieving a double\n257700* floating point result and before using it in COBOL.\n257800* This is because COBOL uses HFP whereas sqlite stores in BFP.\n257900* Data is returned as a PIC USAGE COMP-2 in the second\n258000* parameter passed, BY REFERENCE, to SQLITE3A. This unusual\n258100* calling sequence is used because it is how C works, and to be\n258110* consistent with the other functions in this package.\n258200* CALL SQLITE3 USING BY REFERENCE CONVERT-BFP-TO-HFP\n258300*      BY REFERENCE double-result-variable\n258400*      <other call parameters as documented>\n258500* END-CALL\n258600*\n258700     05 CONVERT-HFP-TO-BFP              PIC X(19)\n258800            VALUE IS Z'convert_hfp_to_bfp'.\n258900* This function should be called after using a COMP-2 in COBOL\n259000* but before sending it to sqlite to store.\n259100* This is because COBOL uses HFP whereas sqlite stores in BFP.\n259200* Data is returned as a PIC USAGE COMP-2 in the second\n259210* parameter passed, BY REFERENCE, to SQLITE3A. This unusual\n259220* calling sequence is used because it is how C works, and to be\n259230* consistent with the other functions in this package.\n259500* CALL SQLITE3 USING BY REFERENCE CONVERT-BFP-TO-HFP\n259600*      BY REFERENCE double-result-variable\n259700*      <other call parameters as documented>\n259800* END-CALL\n259900*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBTEST1": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00%\\x01\\x13#\\x9f\\x01\\x14)\\x1f\\x16W\\x00\\r\\x00\\r\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2013-08-27T00:00:00", "modifydate": "2014-10-18T16:57:25", "lines": 13, "newlines": 13, "modlines": 0, "user": "JOARMC"}, "text": "//COBTEST1 JOB (H000009),COBTEST1,\n//         CLASS=F,\n//         MSGCLASS=H,\n//         NOTIFY=&SYSUID\n//COBTEST1 EXEC PGM=TESTCOB1,\n//         REGION=0M,\n//         PARM='/POSIX(ON)'\n//STEPLIB  DD   DISP=SHR,DSN=&SYSUID..SQL387.LINKLIB\n//SYSOUT   DD   SYSOUT=*,OUTLIM=2000\n//STDOUT   DD   SYSOUT=*,OUTLIM=2000\n//STDERR   DD   SYSOUT=*,OUTLIM=2000\n//CEEDUMP  DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COBTEST2": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00)\\x01\\x13$o\\x01\\x14)\\x1f\\x16W\\x00\\r\\x00\\r\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2013-09-03T00:00:00", "modifydate": "2014-10-18T16:57:29", "lines": 13, "newlines": 13, "modlines": 0, "user": "JOARMC"}, "text": "//COBTEST2 JOB (H000009),COBTEST2,\n//         CLASS=F,\n//         MSGCLASS=H,\n//         NOTIFY=&SYSUID\n//COBTEST2 EXEC PGM=TESTCOB2,\n//         REGION=0M,\n//         PARM='/POSIX(ON)'\n//STEPLIB  DD   DISP=SHR,DSN=&SYSUID..SQL387.LINKLIB\n//SYSOUT   DD   SYSOUT=*,OUTLIM=2000\n//STDOUT   DD   SYSOUT=*,OUTLIM=2000\n//STDERR   DD   SYSOUT=*,OUTLIM=2000\n//CEEDUMP  DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IGYWCL": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00A\\x01\\x13#\\x9f\\x01\\x14)\\x1f\\x16W\\x00\\x1c\\x00\\x12\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2013-08-27T00:00:00", "modifydate": "2014-10-18T16:57:41", "lines": 28, "newlines": 18, "modlines": 0, "user": "JOARMC"}, "text": "//IGYWCL   JOB  ACCOUNT,'COBOL COMPILE',\n//         CLASS=F,\n//         MSGCLASS=H,\n//         NOTIFY=&SYSUID\n//PROCLIB  JCLLIB ORDER=(IGY510.SIGYPROC)\n//SCEELKED SET  SCEELKED=CEE.SCEELKED Change as needed.\n//TESTCOB1 EXEC IGYWCL,\n//         LNGPRFX='IGY510',\n//         PARM.LKED=(LET,LIST,XREF,MAP,CALL)\n//COBOL.SYSIN DD DISP=SHR,DSN=&SYSUID..SQL387.CNTL(TESTCOB1)\n//COBOL.SYSLIB DD DISP=SHR,DSN=CEE.SCEESAMP\n//             DD DISP=SHR,DSN=&SYSUID..SQL387.CNTL\n//LKED.SYSLIB DD\n//            DD DISP=SHR,DSN=&SYSUID..SQL387.LINKLIB\n//            DD DISP=SHR,DSN=&SCEELKED\n//LKED.SYSLMOD DD DSN=&SYSUID..SQL387.LINKLIB,DISP=SHR\n//*\n//TESTCOB2 EXEC IGYWCL,\n//         LNGPRFX='IGY510',\n//         PARM.LKED=(LET,LIST,XREF,MAP,CALL)\n//COBOL.SYSIN DD DISP=SHR,DSN=&SYSUID..SQL387.CNTL(TESTCOB2)\n//COBOL.SYSLIB DD DISP=SHR,DSN=CEE.SCEESAMP\n//             DD DISP=SHR,DSN=&SYSUID..SQL387.CNTL\n//LKED.SYSLIB DD\n//            DD DISP=SHR,DSN=&SYSUID..SQL387.LINKLIB\n//            DD DISP=SHR,DSN=&SCEELKED\n//LKED.SYSLMOD DD DSN=&SYSUID..SQL387.LINKLIB,DISP=SHR\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LINK": {"ttr": 1806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x17\\x01\\x13#\\x9f\\x01\\x13#\\x9f\\x10\\x19\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2013-08-27T00:00:00", "modifydate": "2013-08-27T10:19:17", "lines": 14, "newlines": 14, "modlines": 0, "user": "JOARMC"}, "text": "//LINK     JOB ACCOUNT,PROGRAMMER,\n//         CLASS=?,                  <== CHANGE\n//         MSGCLASS=?,               <== CHANGE\n//         NOTIFY=&SYSUID\n//         SET LINKLIB=?             <== OUTPUT LINK LIBRARY NAME\n//         SET THISLIB=?             <== THIS DATA SET\n//         SET SCEELKED=CEE.SCEELKED <== MAY NEED TO BE CHANGED\n//LINK     EXEC PGM=IEWL,\n//         PARM='LET,LIST,XREF,CALL,ALIASES=ALL'\n//SYSLMOD  DD   DISP=SHR,DSN=&LINKLIB(SQLITE3)\n//SYSLIN   DD   DISP=SHR,DSN=&THISLIB(SQLITE3O)\n//SYSLIB   DD   DISP=SHR,DSN=&SCEELKED\n//SYSPRINT DD   SYSOUT=*\n//SYSUT1   DD   SPACE=(CYL,(10,10))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LINKLIB": {"ttr": 1808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03W\\x00#\\x01\\x141\\x1f\\x01\\x141\\x1f\\x08DU\\x0cU\\x0c\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "03.87", "flags": 0, "createdate": "2014-11-07T00:00:00", "modifydate": "2014-11-07T08:44:23", "lines": 21772, "newlines": 21772, "modlines": 0, "user": "JOARMC"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "PAXFULL": {"ttr": 10758, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x03W \\x00\\x01\\x141\\x1f\\x01\\x141\\x1f\\x12I\\xff\\xff\\xff\\xff\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@\\x00\\x01\\xa6\\x1a\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00'", "ispf": {"version": "03.87", "flags": 32, "createdate": "2014-11-07T00:00:00", "modifydate": "2014-11-07T12:49:00", "lines": 65535, "newlines": 65535, "modlines": 0, "user": "JOARMC"}, "mimetype": "application/x-compress", "datatype": "binary", "extension": ".x-compress"}, "PAXRUN": {"ttr": 54785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03W\\x00#\\x01\\x141\\x1f\\x01\\x141\\x1f\\x08D^\\x80^\\x80\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "03.87", "flags": 0, "createdate": "2014-11-07T00:00:00", "modifydate": "2014-11-07T08:44:23", "lines": 24192, "newlines": 24192, "modlines": 0, "user": "JOARMC"}, "mimetype": "application/x-compress", "datatype": "binary", "extension": ".x-compress"}, "PLICB": {"ttr": 64518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00V\\x01\\x13#_\\x01\\x14)\\x1f\\x16W\\x00\\x13\\x00\\x14\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2013-08-23T00:00:00", "modifydate": "2014-10-18T16:57:56", "lines": 19, "newlines": 20, "modlines": 0, "user": "JOARMC"}, "text": "//IBMZCB   JOB   (H00000I),MCKOWN,\n//         CLASS=F,\n//         COND=(4,LT),\n//         MSGCLASS=H,\n//         REGION=0M,\n//         NOTIFY=&SYSUID\n//PROCLIB   JCLLIB ORDER=(IEL390.SIBMZPRC)\n//TESTPLI1  EXEC   PROC=IBMZCB,\n//  LNGPRFX=IEL390,\n//  PARM.PLI='INC',\n//  PARM.BIND=(CALL,LET,LIST,RENT,REUS,XREF,\n//    'AMODE=31','RMODE=ANY','CASE=MIXED','COMPAT=ZOSV1R11')\n//PLI.SYSLIB DD     DISP=SHR,DSN=&SYSUID..SQL387.CNTL\n//           DD     DISP=SHR,DSN=CEE.SCEEMAC\n//PLI.SYSIN DD     DISP=SHR,DSN=&SYSUID..SQL387.CNTL(TESTPLI1)\n//BIND.SYSLMOD DD  DISP=SHR,DSN=&SYSUID..SQL387.LINKLIB\n//BIND.SYSIN DD    *\n  NAME TESTPLI1(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PLISQLTE": {"ttr": 64520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00Y\\x01\\x13#\\x9f\\x01\\x13$\\x0f\\x16#\\x03\\xd6\\x03\\xd2\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2013-08-27T00:00:00", "modifydate": "2013-08-28T16:23:59", "lines": 982, "newlines": 978, "modlines": 0, "user": "JOARMC"}, "text": " DCL   01  SQLITE3_RETURN_VALUES STATIC,\n           05 SQLITE_ABORT                         BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_ABORT_ROLLBACK                BIN FIXED(31,0)\n                  INIT( 516 ),\n           05 SQLITE_ACCESS_EXISTS                 BIN FIXED(31,0)\n                  INIT( 0 ),\n           05 SQLITE_ACCESS_READ                   BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_ACCESS_READWRITE              BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_ALTER_TABLE                   BIN FIXED(31,0)\n                  INIT( 26 ),\n           05 SQLITE_ANALYZE                       BIN FIXED(31,0)\n                  INIT( 28 ),\n           05 SQLITE_ANY                           BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_ATTACH                        BIN FIXED(31,0)\n                  INIT( 24 ),\n           05 SQLITE_AUTH                          BIN FIXED(31,0)\n                  INIT( 23 ),\n           05 SQLITE_BLOB                          BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_BUSY                          BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_BUSY_RECOVERY                 BIN FIXED(31,0)\n                  INIT( 261 ),\n           05 SQLITE_CANTOPEN                      BIN FIXED(31,0)\n                  INIT( 14 ),\n           05 SQLITE_CANTOPEN_FULLPATH             BIN FIXED(31,0)\n                  INIT( 782 ),\n           05 SQLITE_CANTOPEN_ISDIR                BIN FIXED(31,0)\n                  INIT( 526 ),\n           05 SQLITE_CANTOPEN_NOTEMPDIR            BIN FIXED(31,0)\n                  INIT( 270 ),\n           05 SQLITE_CHECKPOINT_FULL               BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_CHECKPOINT_PASSIVE            BIN FIXED(31,0)\n                  INIT( 0 ),\n           05 SQLITE_CHECKPOINT_RESTART            BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_CONFIG_COVRNG_INDEX_SCN       BIN FIXED(31,0)\n                  INIT( 20 ),\n           05 SQLITE_CONFIG_GETMALLOC              BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_CONFIG_GETMUTEX               BIN FIXED(31,0)\n                  INIT( 11 ),\n           05 SQLITE_CONFIG_GETPCACHE              BIN FIXED(31,0)\n                  INIT( 15 ),\n           05 SQLITE_CONFIG_GETPCACHE2             BIN FIXED(31,0)\n                  INIT( 19 ),\n           05 SQLITE_CONFIG_HEAP                   BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_CONFIG_LOG                    BIN FIXED(31,0)\n                  INIT( 16 ),\n           05 SQLITE_CONFIG_LOOKASIDE              BIN FIXED(31,0)\n                  INIT( 13 ),\n           05 SQLITE_CONFIG_MALLOC                 BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_CONFIG_MEMSTATUS              BIN FIXED(31,0)\n                  INIT( 9 ),\n           05 SQLITE_CONFIG_MMAP_SIZE              BIN FIXED(31,0)\n                  INIT( 22 ),\n           05 SQLITE_CONFIG_MULTITHREAD            BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_CONFIG_MUTEX                  BIN FIXED(31,0)\n                  INIT( 10 ),\n           05 SQLITE_CONFIG_PAGECACHE              BIN FIXED(31,0)\n                  INIT( 7 ),\n           05 SQLITE_CONFIG_PCACHE                 BIN FIXED(31,0)\n                  INIT( 14 ),\n           05 SQLITE_CONFIG_PCACHE2                BIN FIXED(31,0)\n                  INIT( 18 ),\n           05 SQLITE_CONFIG_SCRATCH                BIN FIXED(31,0)\n                  INIT( 6 ),\n           05 SQLITE_CONFIG_SERIALIZED             BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_CONFIG_SINGLETHREAD           BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_CONFIG_SQLLOG                 BIN FIXED(31,0)\n                  INIT( 21 ),\n           05 SQLITE_CONFIG_URI                    BIN FIXED(31,0)\n                  INIT( 17 ),\n           05 SQLITE_CONSTRAINT                    BIN FIXED(31,0)\n                  INIT( 19 ),\n           05 SQLITE_CONSTRAINT_CHECK              BIN FIXED(31,0)\n                  INIT( 275 ),\n           05 SQLITE_CONSTRAINT_COMMITHOOK         BIN FIXED(31,0)\n                  INIT( 531 ),\n           05 SQLITE_CONSTRAINT_FOREIGNKEY         BIN FIXED(31,0)\n                  INIT( 787 ),\n           05 SQLITE_CONSTRAINT_FUNCTION           BIN FIXED(31,0)\n                  INIT( 1043 ),\n           05 SQLITE_CONSTRAINT_NOTNULL            BIN FIXED(31,0)\n                  INIT( 1299 ),\n           05 SQLITE_CONSTRAINT_PRIMARYKEY         BIN FIXED(31,0)\n                  INIT( 1555 ),\n           05 SQLITE_CONSTRAINT_TRIGGER            BIN FIXED(31,0)\n                  INIT( 1811 ),\n           05 SQLITE_CONSTRAINT_UNIQUE             BIN FIXED(31,0)\n                  INIT( 2067 ),\n           05 SQLITE_CONSTRAINT_VTAB               BIN FIXED(31,0)\n                  INIT( 2323 ),\n           05 SQLITE_COPY                          BIN FIXED(31,0)\n                  INIT( 0 ),\n           05 SQLITE_CORRUPT                       BIN FIXED(31,0)\n                  INIT( 11 ),\n           05 SQLITE_CORRUPT_VTAB                  BIN FIXED(31,0)\n                  INIT( 267 ),\n           05 SQLITE_CREATE_INDEX                  BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_CREATE_TABLE                  BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_CREATE_TEMP_INDEX             BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_CREATE_TEMP_TABLE             BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_CREATE_TEMP_TRIGGER           BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_CREATE_TEMP_VIEW              BIN FIXED(31,0)\n                  INIT( 6 ),\n           05 SQLITE_CREATE_TRIGGER                BIN FIXED(31,0)\n                  INIT( 7 ),\n           05 SQLITE_CREATE_VIEW                   BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_CREATE_VTABLE                 BIN FIXED(31,0)\n                  INIT( 29 ),\n           05 SQLITE_DBCONFIG_ENABLE_FKEY          BIN FIXED(31,0)\n                  INIT( 1002 ),\n           05 SQLITE_DBCONFIG_ENABLE_TRIGGER       BIN FIXED(31,0)\n                  INIT( 1003 ),\n           05 SQLITE_DBCONFIG_LOOKASIDE            BIN FIXED(31,0)\n                  INIT( 1001 ),\n           05 SQLITE_DBSTATUS_CACHE_HIT            BIN FIXED(31,0)\n                  INIT( 7 ),\n           05 SQLITE_DBSTATUS_CACHE_MISS           BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_DBSTATUS_CACHE_USED           BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_DBSTATUS_CACHE_WRITE          BIN FIXED(31,0)\n                  INIT( 9 ),\n           05 SQLITE_DBSTATUS_LOOKASIDE_HIT        BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_DBSTAT_LKASD_MISS_FULL        BIN FIXED(31,0)\n                  INIT( 6 ),\n           05 SQLITE_DBSTAT_LKASD_MISS_SIZE        BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_DBSTATUS_LOOKASIDE_USED       BIN FIXED(31,0)\n                  INIT( 0 ),\n           05 SQLITE_DBSTATUS_MAX                  BIN FIXED(31,0)\n                  INIT( 9 ),\n           05 SQLITE_DBSTATUS_SCHEMA_USED          BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_DBSTATUS_STMT_USED            BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_DELETE                        BIN FIXED(31,0)\n                  INIT( 9 ),\n           05 SQLITE_DENY                          BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_DETACH                        BIN FIXED(31,0)\n                  INIT( 25 ),\n           05 SQLITE_DONE                          BIN FIXED(31,0)\n                  INIT( 101 ),\n           05 SQLITE_DROP_INDEX                    BIN FIXED(31,0)\n                  INIT( 10 ),\n           05 SQLITE_DROP_TABLE                    BIN FIXED(31,0)\n                  INIT( 11 ),\n           05 SQLITE_DROP_TEMP_INDEX               BIN FIXED(31,0)\n                  INIT( 12 ),\n           05 SQLITE_DROP_TEMP_TABLE               BIN FIXED(31,0)\n                  INIT( 13 ),\n           05 SQLITE_DROP_TEMP_TRIGGER             BIN FIXED(31,0)\n                  INIT( 14 ),\n           05 SQLITE_DROP_TEMP_VIEW                BIN FIXED(31,0)\n                  INIT( 15 ),\n           05 SQLITE_DROP_TRIGGER                  BIN FIXED(31,0)\n                  INIT( 16 ),\n           05 SQLITE_DROP_VIEW                     BIN FIXED(31,0)\n                  INIT( 17 ),\n           05 SQLITE_DROP_VTABLE                   BIN FIXED(31,0)\n                  INIT( 30 ),\n           05 SQLITE_EMPTY                         BIN FIXED(31,0)\n                  INIT( 16 ),\n           05 SQLITE_ERROR                         BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_FAIL                          BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_FCNTL_BUSYHANDLER             BIN FIXED(31,0)\n                  INIT( 15 ),\n           05 SQLITE_FCNTL_CHUNK_SIZE              BIN FIXED(31,0)\n                  INIT( 6 ),\n           05 SQLITE_FCNTL_FILE_POINTER            BIN FIXED(31,0)\n                  INIT( 7 ),\n           05 SQLITE_FCNTL_LOCKSTATE               BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_FCNTL_MMAP_SIZE               BIN FIXED(31,0)\n                  INIT( 18 ),\n           05 SQLITE_FCNTL_OVERWRITE               BIN FIXED(31,0)\n                  INIT( 11 ),\n           05 SQLITE_FCNTL_PERSIST_WAL             BIN FIXED(31,0)\n                  INIT( 10 ),\n           05 SQLITE_FCNTL_PWRSAFE_OVERWRITE       BIN FIXED(31,0)\n                  INIT( 13 ),\n           05 SQLITE_FCNTL_PRAGMA                  BIN FIXED(31,0)\n                  INIT( 14 ),\n           05 SQLITE_FCNTL_SIZE_HINT               BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_FCNTL_SYNC_OMITTED            BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_FCNTL_TEMPFILENAME            BIN FIXED(31,0)\n                  INIT( 16 ),\n           05 SQLITE_FCNTL_VFSNAME                 BIN FIXED(31,0)\n                  INIT( 12 ),\n           05 SQLITE_FCNTL_WIN32_AV_RETRY          BIN FIXED(31,0)\n                  INIT( 9 ),\n           05 SQLITE_FLOAT                         BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_FORMAT                        BIN FIXED(31,0)\n                  INIT( 24 ),\n           05 SQLITE_FULL                          BIN FIXED(31,0)\n                  INIT( 13 ),\n           05 SQLITE_FUNCTION                      BIN FIXED(31,0)\n                  INIT( 31 ),\n           05 SQLITE_GET_LOCKPROXYFILE             BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_IGNORE                        BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_INDEX_CONSTRAINT_EQ           BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_INDEX_CONSTRAINT_GE           BIN FIXED(31,0)\n                  INIT( 32 ),\n           05 SQLITE_INDEX_CONSTRAINT_GT           BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_INDEX_CONSTRAINT_LE           BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_INDEX_CONSTRAINT_LT           BIN FIXED(31,0)\n                  INIT( 16 ),\n           05 SQLITE_INDEX_CONSTRAINT_MATCH        BIN FIXED(31,0)\n                  INIT( 64 ),\n           05 SQLITE_INSERT                        BIN FIXED(31,0)\n                  INIT( 18 ),\n           05 SQLITE_INTEGER                       BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_INTERNAL                      BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_INTERRUPT                     BIN FIXED(31,0)\n                  INIT( 9 ),\n           05 SQLITE_IOCAP_ATOMIC                  BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_IOCAP_ATOMIC1K                BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_IOCAP_ATOMIC16K               BIN FIXED(31,0)\n                  INIT( 64 ),\n           05 SQLITE_IOCAP_ATOMIC2K                BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_IOCAP_ATOMIC32K               BIN FIXED(31,0)\n                  INIT( 128 ),\n           05 SQLITE_IOCAP_ATOMIC4K                BIN FIXED(31,0)\n                  INIT( 16 ),\n           05 SQLITE_IOCAP_ATOMIC512               BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_IOCAP_ATOMIC64K               BIN FIXED(31,0)\n                  INIT( 256 ),\n           05 SQLITE_IOCAP_ATOMIC8K                BIN FIXED(31,0)\n                  INIT( 32 ),\n           05 SQLITE_IOCAP_PWRSAFE_OVERWRITE       BIN FIXED(31,0)\n                  INIT( 4096 ),\n           05 SQLITE_IOCAP_SAFE_APPEND             BIN FIXED(31,0)\n                  INIT( 512 ),\n           05 SQLITE_IOCAP_SEQUENTIAL              BIN FIXED(31,0)\n                  INIT( 1024 ),\n           05 SQLITE_IOCAP_UNDEL_WHEN_OPEN         BIN FIXED(31,0)\n                  INIT( 2048 ),\n           05 SQLITE_IOERR                         BIN FIXED(31,0)\n                  INIT( 10 ),\n           05 SQLITE_IOERR_ACCESS                  BIN FIXED(31,0)\n                  INIT( 3338 ),\n           05 SQLITE_IOERR_BLOCKED                 BIN FIXED(31,0)\n                  INIT( 2826 ),\n           05 SQLITE_IOERR_CHECKRESERVEDLOCK       BIN FIXED(31,0)\n                  INIT( 3594 ),\n           05 SQLITE_IOERR_CLOSE                   BIN FIXED(31,0)\n                  INIT( 4106 ),\n           05 SQLITE_IOERR_DELETE                  BIN FIXED(31,0)\n                  INIT( 2570 ),\n           05 SQLITE_IOERR_DELETE_NOENT            BIN FIXED(31,0)\n                  INIT( 5898 ),\n           05 SQLITE_IOERR_DIR_CLOSE               BIN FIXED(31,0)\n                  INIT( 4362 ),\n           05 SQLITE_IOERR_DIR_FSYNC               BIN FIXED(31,0)\n                  INIT( 1290 ),\n           05 SQLITE_IOERR_FSTAT                   BIN FIXED(31,0)\n                  INIT( 1802 ),\n           05 SQLITE_IOERR_FSYNC                   BIN FIXED(31,0)\n                  INIT( 1034 ),\n           05 SQLITE_IOERR_LOCK                    BIN FIXED(31,0)\n                  INIT( 3850 ),\n           05 SQLITE_IOERR_MMAP                    BIN FIXED(31,0)\n                  INIT( 6154 ),\n           05 SQLITE_IOERR_NOMEM                   BIN FIXED(31,0)\n                  INIT( 3082 ),\n           05 SQLITE_IOERR_RDLOCK                  BIN FIXED(31,0)\n                  INIT( 2314 ),\n           05 SQLITE_IOERR_READ                    BIN FIXED(31,0)\n                  INIT( 266 ),\n           05 SQLITE_IOERR_SEEK                    BIN FIXED(31,0)\n                  INIT( 5642 ),\n           05 SQLITE_IOERR_SHMLOCK                 BIN FIXED(31,0)\n                  INIT( 5130 ),\n           05 SQLITE_IOERR_SHMMAP                  BIN FIXED(31,0)\n                  INIT( 5386 ),\n           05 SQLITE_IOERR_SHMOPEN                 BIN FIXED(31,0)\n                  INIT( 4618 ),\n           05 SQLITE_IOERR_SHMSIZE                 BIN FIXED(31,0)\n                  INIT( 4874 ),\n           05 SQLITE_IOERR_SHORT_READ              BIN FIXED(31,0)\n                  INIT( 522 ),\n           05 SQLITE_IOERR_TRUNCATE                BIN FIXED(31,0)\n                  INIT( 1546 ),\n           05 SQLITE_IOERR_UNLOCK                  BIN FIXED(31,0)\n                  INIT( 2058 ),\n           05 SQLITE_IOERR_WRITE                   BIN FIXED(31,0)\n                  INIT( 778 ),\n           05 SQLITE_LAST_ERRNO                    BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_LIMIT_ATTACHED                BIN FIXED(31,0)\n                  INIT( 7 ),\n           05 SQLITE_LIMIT_COLUMN                  BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_LIMIT_COMPOUND_SELECT         BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_LIMIT_EXPR_DEPTH              BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_LIMIT_FUNCTION_ARG            BIN FIXED(31,0)\n                  INIT( 6 ),\n           05 SQLITE_LIMIT_LENGTH                  BIN FIXED(31,0)\n                  INIT( 0 ),\n           05 SQLITE_LIMIT_LIKE_PATTERN_LEN        BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_LIMIT_SQL_LENGTH              BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_LIMIT_TRIGGER_DEPTH           BIN FIXED(31,0)\n                  INIT( 10 ),\n           05 SQLITE_LIMIT_VARIABLE_NUMBER         BIN FIXED(31,0)\n                  INIT( 9 ),\n           05 SQLITE_LIMIT_VDBE_OP                 BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_LOCK_EXCLUSIVE                BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_LOCK_NONE                     BIN FIXED(31,0)\n                  INIT( 0 ),\n           05 SQLITE_LOCK_PENDING                  BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_LOCK_RESERVED                 BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_LOCK_SHARED                   BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_LOCKED                        BIN FIXED(31,0)\n                  INIT( 6 ),\n           05 SQLITE_LOCKED_SHAREDCACHE            BIN FIXED(31,0)\n                  INIT( 262 ),\n           05 SQLITE_MISMATCH                      BIN FIXED(31,0)\n                  INIT( 20 ),\n           05 SQLITE_MISUSE                        BIN FIXED(31,0)\n                  INIT( 21 ),\n           05 SQLITE_MUTEX_FAST                    BIN FIXED(31,0)\n                  INIT( 0 ),\n           05 SQLITE_MUTEX_RECURSIVE               BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_MUTEX_STATIC_LRU              BIN FIXED(31,0)\n                  INIT( 6 ),\n           05 SQLITE_MUTEX_STATIC_LRU2             BIN FIXED(31,0)\n                  INIT( 7 ),\n           05 SQLITE_MUTEX_STATIC_MASTER           BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_MUTEX_STATIC_MEM              BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_MUTEX_STATIC_MEM2             BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_MUTEX_STATIC_OPEN             BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_MUTEX_STATIC_PMEM             BIN FIXED(31,0)\n                  INIT( 7 ),\n           05 SQLITE_MUTEX_STATIC_PRNG             BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_NOLFS                         BIN FIXED(31,0)\n                  INIT( 22 ),\n           05 SQLITE_NOMEM                         BIN FIXED(31,0)\n                  INIT( 7 ),\n           05 SQLITE_NOTADB                        BIN FIXED(31,0)\n                  INIT( 26 ),\n           05 SQLITE_NOTFOUND                      BIN FIXED(31,0)\n                  INIT( 12 ),\n           05 SQLITE_NOTICE                        BIN FIXED(31,0)\n                  INIT( 27 ),\n           05 SQLITE_NOTICE_RECOVER_ROLLBACK       BIN FIXED(31,0)\n                  INIT( 539 ),\n           05 SQLITE_NOTICE_RECOVER_WAL            BIN FIXED(31,0)\n                  INIT( 283 ),\n           05 SQLITE_NULL                          BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_OK                            BIN FIXED(31,0)\n                  INIT( 0 ),\n           05 SQLITE_OPEN_AUTOPROXY                BIN FIXED(31,0)\n                  INIT( 32 ),\n           05 SQLITE_OPEN_CREATE                   BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_OPEN_DELETEONCLOSE            BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_OPEN_EXCLUSIVE                BIN FIXED(31,0)\n                  INIT( 16 ),\n           05 SQLITE_OPEN_FULLMUTEX                BIN FIXED(31,0)\n                  INIT( 65536 ),\n           05 SQLITE_OPEN_MAIN_DB                  BIN FIXED(31,0)\n                  INIT( 256 ),\n           05 SQLITE_OPEN_MAIN_JOURNAL             BIN FIXED(31,0)\n                  INIT( 2048 ),\n           05 SQLITE_OPEN_MASTER_JOURNAL           BIN FIXED(31,0)\n                  INIT( 16384 ),\n           05 SQLITE_OPEN_MEMORY                   BIN FIXED(31,0)\n                  INIT( 128 ),\n           05 SQLITE_OPEN_NOMUTEX                  BIN FIXED(31,0)\n                  INIT( 32768 ),\n           05 SQLITE_OPEN_PRIVATECACHE             BIN FIXED(31,0)\n                  INIT( 262144 ),\n           05 SQLITE_OPEN_READONLY                 BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_OPEN_READWRITE                BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_OPEN_SHAREDCACHE              BIN FIXED(31,0)\n                  INIT( 131072 ),\n           05 SQLITE_OPEN_SUBJOURNAL               BIN FIXED(31,0)\n                  INIT( 8192 ),\n           05 SQLITE_OPEN_TEMP_DB                  BIN FIXED(31,0)\n                  INIT( 512 ),\n           05 SQLITE_OPEN_TEMP_JOURNAL             BIN FIXED(31,0)\n                  INIT( 4096 ),\n           05 SQLITE_OPEN_TRANSIENT_DB             BIN FIXED(31,0)\n                  INIT( 1024 ),\n           05 SQLITE_OPEN_URI                      BIN FIXED(31,0)\n                  INIT( 64 ),\n           05 SQLITE_OPEN_WAL                      BIN FIXED(31,0)\n                  INIT( 524288 ),\n           05 SQLITE_PERM                          BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_PRAGMA                        BIN FIXED(31,0)\n                  INIT( 19 ),\n           05 SQLITE_PROTOCOL                      BIN FIXED(31,0)\n                  INIT( 15 ),\n           05 SQLITE_RANGE                         BIN FIXED(31,0)\n                  INIT( 25 ),\n           05 SQLITE_READ                          BIN FIXED(31,0)\n                  INIT( 20 ),\n           05 SQLITE_READONLY                      BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_READONLY_CANTLOCK             BIN FIXED(31,0)\n                  INIT( 520 ),\n           05 SQLITE_READONLY_RECOVERY             BIN FIXED(31,0)\n                  INIT( 264 ),\n           05 SQLITE_READONLY_ROLLBACK             BIN FIXED(31,0)\n                  INIT( 776 ),\n           05 SQLITE_REINDEX                       BIN FIXED(31,0)\n                  INIT( 27 ),\n           05 SQLITE_REPLACE                       BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_ROLLBACK                      BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_ROW                           BIN FIXED(31,0)\n                  INIT( 100 ),\n           05 SQLITE_SAVEPOINT                     BIN FIXED(31,0)\n                  INIT( 32 ),\n           05 SQLITE_SCHEMA                        BIN FIXED(31,0)\n                  INIT( 17 ),\n           05 SQLITE_SELECT                        BIN FIXED(31,0)\n                  INIT( 21 ),\n           05 SQLITE_SET_LOCKPROXYFILE             BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_SHM_EXCLUSIVE                 BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_SHM_LOCK                      BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_SHM_NLOCK                     BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_SHM_SHARED                    BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_SHM_UNLOCK                    BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_STATIC                        BIN FIXED(31,0)\n                  INIT( 0 ),\n           05 SQLITE_STATUS_MALLOC_COUNT           BIN FIXED(31,0)\n                  INIT( 9 ),\n           05 SQLITE_STATUS_MALLOC_SIZE            BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_STATUS_MEMORY_USED            BIN FIXED(31,0)\n                  INIT( 0 ),\n           05 SQLITE_STATUS_PGCACHE_OVERFLOW       BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_STATUS_PGCACHE_SIZE           BIN FIXED(31,0)\n                  INIT( 7 ),\n           05 SQLITE_STATUS_PGCACHE_USED           BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_STATUS_PARSER_STACK           BIN FIXED(31,0)\n                  INIT( 6 ),\n           05 SQLITE_STATUS_SCRATCH_OVERFLOW       BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_STATUS_SCRATCH_SIZE           BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_STATUS_SCRATCH_USED           BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_STMTSTATUS_AUTOINDEX          BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_STMTSTATUS_FULLSCAN_STP       BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_STMTSTATUS_SORT               BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_SYNC_DATAONLY                 BIN FIXED(31,0)\n                  INIT( 16 ),\n           05 SQLITE_SYNC_FULL                     BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_SYNC_NORMAL                   BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_TESTCTRL_ALWAYS               BIN FIXED(31,0)\n                  INIT( 13 ),\n           05 SQLITE_TESTCTRL_ASSERT               BIN FIXED(31,0)\n                  INIT( 12 ),\n           05 SQLITE_TESTCTRL_B9_MALLOC_HKS        BIN FIXED(31,0)\n                  INIT( 10 ),\n           05 SQLITE_TESTCTRL_BITVEC_TEST          BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_TESTCTRL_EXPLAIN_STMT         BIN FIXED(31,0)\n                  INIT( 19 ),\n           05 SQLITE_TESTCTRL_FAULT_INSTALL        BIN FIXED(31,0)\n                  INIT( 9 ),\n           05 SQLITE_TESTCTRL_FIRST                BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_TESTCTRL_ISKEYWORD            BIN FIXED(31,0)\n                  INIT( 16 ),\n           05 SQLITE_TESTCTRL_LAST                 BIN FIXED(31,0)\n                  INIT( 19 ),\n           05 SQLITE_TESTCTRL_LOCALTIME_FLT        BIN FIXED(31,0)\n                  INIT( 18 ),\n           05 SQLITE_TESTCTRL_OPTIMIZATIONS        BIN FIXED(31,0)\n                  INIT( 15 ),\n           05 SQLITE_TESTCTRL_PENDING_BYTE         BIN FIXED(31,0)\n                  INIT( 11 ),\n           05 SQLITE_TESTCTRL_PRNG_RESET           BIN FIXED(31,0)\n                  INIT( 7 ),\n           05 SQLITE_TESTCTRL_PRNG_RESTORE         BIN FIXED(31,0)\n                  INIT( 6 ),\n           05 SQLITE_TESTCTRL_PRNG_SAVE            BIN FIXED(31,0)\n                  INIT( 5 ),\n           05 SQLITE_TESTCTRL_RESERVE              BIN FIXED(31,0)\n                  INIT( 14 ),\n           05 SQLITE_TESTCTRL_SCRATCHMALLOC        BIN FIXED(31,0)\n                  INIT( 17 ),\n           05 SQLITE_TEXT                          BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_TOOBIG                        BIN FIXED(31,0)\n                  INIT( 18 ),\n           05 SQLITE_TRANSACTION                   BIN FIXED(31,0)\n                  INIT( 22 ),\n           05 SQLITE_TRANSIENT                     BIN FIXED(31,0)\n                  INIT( -1 ),\n           05 SQLITE_UPDATE                        BIN FIXED(31,0)\n                  INIT( 23 ),\n           05 SQLITE_UTF16                         BIN FIXED(31,0)\n                  INIT( 4 ),\n           05 SQLITE_UTF16_ALIGNED                 BIN FIXED(31,0)\n                  INIT( 8 ),\n           05 SQLITE_UTF16BE                       BIN FIXED(31,0)\n                  INIT( 3 ),\n           05 SQLITE_UTF16LE                       BIN FIXED(31,0)\n                  INIT( 2 ),\n           05 SQLITE_UTF8                          BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_VERSION                  CHAR(6) VARYINGZ\n                  INIT( \"3.7.17\" ),\n           05 SQLITE_VERSION_NUMBER                BIN FIXED(31,0)\n                  INIT( 3007017 ),\n           05 SQLITE_VTAB_CONSTRAINT_SUPPORT       BIN FIXED(31,0)\n                  INIT( 1 ),\n           05 SQLITE_WARNING                       BIN FIXED(31,0)\n                  INIT( 28 );\n DCL   01  SQLITE3_FUNCTION_NAMES STATIC,\n           05 SQLITE3                         CHAR(8) VARYINGZ\n                  INIT( 'SQLITE3'),\n           05 SQLITE3_AGGREGATE_CONTEXT       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_aggregate_context'),\n           05 SQLITE3_AGGREGATE_COUNT         CHAR(24) VARYINGZ\n                  INIT( 'sqlite3_aggregate_count'),\n           05 SQLITE3_AUTO_EXTENSION          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_auto_extension'),\n           05 SQLITE3_BACKUP_FINISH           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_backup_finish'),\n           05 SQLITE3_BACKUP_INIT             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_backup_init'),\n           05 SQLITE3_BACKUP_PAGECOUNT        CHAR(25) VARYINGZ\n                  INIT( 'sqlite3_backup_pagecount'),\n           05 SQLITE3_BACKUP_REMAINING        CHAR(25) VARYINGZ\n                  INIT( 'sqlite3_backup_remaining'),\n           05 SQLITE3_BACKUP_STEP             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_backup_step'),\n           05 SQLITE3_BIND_BLOB               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_bind_blob'),\n           05 SQLITE3_BIND_DOUBLE             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_bind_double'),\n           05 SQLITE3_BIND_INT                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_bind_int'),\n           05 SQLITE3_BIND_INT64              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_bind_int64'),\n           05 SQLITE3_BIND_NULL               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_bind_null'),\n           05 SQLITE3_BIND_PARAMETER_COUNT    CHAR(29) VARYINGZ\n                  INIT( 'sqlite3_bind_parameter_count'),\n           05 SQLITE3_BIND_PARAMETER_INDEX    CHAR(29) VARYINGZ\n                  INIT( 'sqlite3_bind_parameter_index'),\n           05 SQLITE3_BIND_PARAMETER_NAME     CHAR(28) VARYINGZ\n                  INIT( 'sqlite3_bind_parameter_name'),\n           05 SQLITE3_BIND_TEXT               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_bind_text'),\n           05 SQLITE3_BIND_TEXT16             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_bind_text16'),\n           05 SQLITE3_BIND_INIT               CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_bind_INIT'),\n           05 SQLITE3_BIND_ZEROBLOB           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_bind_zeroblob'),\n           05 SQLITE3_BLOB_BYTES              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_blob_bytes'),\n           05 SQLITE3_BLOB_CLOSE              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_blob_close'),\n           05 SQLITE3_BLOB_OPEN               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_blob_open'),\n           05 SQLITE3_BLOB_READ               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_blob_read'),\n           05 SQLITE3_BLOB_REOPEN             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_blob_reopen'),\n           05 SQLITE3_BLOB_WRITE              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_blob_write'),\n           05 SQLITE3_BUSY_HANDLER            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_busy_handler'),\n           05 SQLITE3_BUSY_TIMEOUT            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_busy_timeout'),\n           05 SQLITE3_CHANGES                 CHAR(16) VARYINGZ\n                  INIT( 'sqlite3_changes'),\n           05 SQLITE3_CLEAR_BINDINGS          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_clear_bindings'),\n           05 SQLITE3_CLOSE                   CHAR(14) VARYINGZ\n                  INIT( 'sqlite3_close'),\n           05 SQLITE3_CLOSE_V2                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_close_v2'),\n           05 SQLITE3_COLLATION_NEEDED        CHAR(25) VARYINGZ\n                  INIT( 'sqlite3_collation_needed'),\n           05 SQLITE3_COLLATION_NEEDED16      CHAR(27) VARYINGZ\n                  INIT( 'sqlite3_collation_needed16'),\n           05 SQLITE3_COLUMN_BLOB             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_column_blob'),\n           05 SQLITE3_COLUMN_BYTES            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_column_bytes'),\n           05 SQLITE3_COLUMN_BYTES16          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_column_bytes16'),\n           05 SQLITE3_COLUMN_COUNT            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_column_count'),\n           05 SQLITE3_COLUMN_DECLTYPE         CHAR(24) VARYINGZ\n                  INIT( 'sqlite3_column_decltype'),\n           05 SQLITE3_COLUMN_DECLTYPE16       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_column_decltype16'),\n           05 SQLITE3_COLUMN_DOUBLE           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_column_double'),\n           05 SQLITE3_COLUMN_INT              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_column_int'),\n           05 SQLITE3_COLUMN_INT64            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_column_int64'),\n           05 SQLITE3_COLUMN_NAME             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_column_name'),\n           05 SQLITE3_COLUMN_NAME16           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_column_name16'),\n           05 SQLITE3_COLUMN_TABLE_NAME       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_column_table_name'),\n           05 SQLITE3_COLUMN_TABLE_NAME16     CHAR(28) VARYINGZ\n                  INIT( 'sqlite3_column_table_name16'),\n           05 SQLITE3_COLUMN_TEXT             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_column_text'),\n           05 SQLITE3_COLUMN_TEXT16           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_column_text16'),\n           05 SQLITE3_COLUMN_TYPE             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_column_type'),\n           05 SQLITE3_COLUMN_INIT             CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_column_init'),\n           05 SQLITE3_COMMIT_HOOK             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_commit_hook'),\n           05 SQLITE3_COMPILEOPTION_GET       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_compileoption_get'),\n           05 SQLITE3_COMPILEOPTION_USED      CHAR(27) VARYINGZ\n                  INIT( 'sqlite3_compileoption_used'),\n           05 SQLITE3_COMPLETE                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_complete'),\n           05 SQLITE3_COMPLETE16              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_complete16'),\n           05 SQLITE3_CONFIG                  CHAR(15) VARYINGZ\n                  INIT( 'sqlite3_config'),\n           05 SQLITE3_CONTEXT_DB_HANDLE       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_context_db_handle'),\n           05 SQLITE3_CREATE_COLLATION        CHAR(25) VARYINGZ\n                  INIT( 'sqlite3_create_collation'),\n           05 SQLITE3_CREATE_COLLATION_V2     CHAR(28) VARYINGZ\n                  INIT( 'sqlite3_create_collation_v2'),\n           05 SQLITE3_CREATE_COLLATION16      CHAR(27) VARYINGZ\n                  INIT( 'sqlite3_create_collation16'),\n           05 SQLITE3_CREATE_FUNCTION         CHAR(24) VARYINGZ\n                  INIT( 'sqlite3_create_function'),\n           05 SQLITE3_CREATE_FUNCTION_V2      CHAR(27) VARYINGZ\n                  INIT( 'sqlite3_create_function_v2'),\n           05 SQLITE3_CREATE_FUNCTION16       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_create_function16'),\n           05 SQLITE3_CREATE_MODULE           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_create_module'),\n           05 SQLITE3_CREATE_MODULE_V2        CHAR(25) VARYINGZ\n                  INIT( 'sqlite3_create_module_v2'),\n           05 SQLITE3_DATA_COUNT              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_data_count'),\n           05 SQLITE3_DB_CONFIG               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_db_config'),\n           05 SQLITE3_DB_FILENAME             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_db_filename'),\n           05 SQLITE3_DB_HANDLE               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_db_handle'),\n           05 SQLITE3_DB_MUTEX                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_db_mutex'),\n           05 SQLITE3_DB_READONLY             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_db_readonly'),\n           05 SQLITE3_DB_RELEASE_MEMORY       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_db_release_memory'),\n           05 SQLITE3_DB_STATUS               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_db_status'),\n           05 SQLITE3_DECLARE_VTAB            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_declare_vtab'),\n           05 SQLITE3_ENABLE_LOAD_EXTENSION   CHAR(30) VARYINGZ\n                  INIT( 'sqlite3_enable_load_extension'),\n           05 SQLITE3_ENABLE_SHARED_CACHE     CHAR(28) VARYINGZ\n                  INIT( 'sqlite3_enable_shared_cache'),\n           05 SQLITE3_ERRCODE                 CHAR(16) VARYINGZ\n                  INIT( 'sqlite3_errcode'),\n           05 SQLITE3_ERRMSG                  CHAR(15) VARYINGZ\n                  INIT( 'sqlite3_errmsg'),\n           05 SQLITE3_ERRMSG16                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_errmsg16'),\n           05 SQLITE3_ERRSTR                  CHAR(15) VARYINGZ\n                  INIT( 'sqlite3_errstr'),\n           05 SQLITE3_EXEC                    CHAR(13) VARYINGZ\n                  INIT( 'sqlite3_exec'),\n           05 SQLITE3_EXPIRED                 CHAR(16) VARYINGZ\n                  INIT( 'sqlite3_expired'),\n           05 SQLITE3_EXTENDED_ERRCODE        CHAR(25) VARYINGZ\n                  INIT( 'sqlite3_extended_errcode'),\n           05 SQLITE3_EXTENDED_RESULT_CODES   CHAR(30) VARYINGZ\n                  INIT( 'sqlite3_extended_result_codes'),\n           05 SQLITE3_FILE_CONTROL            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_file_control'),\n           05 SQLITE3_FINALIZE                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_finalize'),\n           05 SQLITE3_FREE                    CHAR(13) VARYINGZ\n                  INIT( 'sqlite3_free'),\n           05 SQLITE3_FREE_TABLE              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_free_table'),\n           05 SQLITE3_GET_AUTOCOMMIT          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_get_autocommit'),\n           05 SQLITE3_GET_AUXDATA             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_get_auxdata'),\n           05 SQLITE3_GET_TABLE               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_get_table'),\n           05 SQLITE3_GLOBAL_RECOVER          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_global_recover'),\n           05 SQLITE3_INITIALIZE              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_initialize'),\n           05 SQLITE3_INTERRUPT               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_interrupt'),\n           05 SQLITE3_LAST_INSERT_ROWID       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_last_insert_rowid'),\n           05 SQLITE3_LIBVERSION              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_libversion'),\n           05 SQLITE3_LIBVERSION_NUMBER       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_libversion_number'),\n           05 SQLITE3_LIMIT                   CHAR(14) VARYINGZ\n                  INIT( 'sqlite3_limit'),\n           05 SQLITE3_LOAD_EXTENSION          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_load_extension'),\n           05 SQLITE3_LOG                     CHAR(12) VARYINGZ\n                  INIT( 'sqlite3_log'),\n           05 SQLITE3_MALLOC                  CHAR(15) VARYINGZ\n                  INIT( 'sqlite3_malloc'),\n           05 SQLITE3_MEMORY_ALARM            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_memory_alarm'),\n           05 SQLITE3_MEMORY_HIGHWATER        CHAR(25) VARYINGZ\n                  INIT( 'sqlite3_memory_highwater'),\n           05 SQLITE3_MEMORY_USED             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_memory_used'),\n           05 SQLITE3_MPRINTF                 CHAR(16) VARYINGZ\n                  INIT( 'sqlite3_mprintf'),\n           05 SQLITE3_MUTEX_ALLOC             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_mutex_alloc'),\n           05 SQLITE3_MUTEX_ENTER             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_mutex_enter'),\n           05 SQLITE3_MUTEX_FREE              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_mutex_free'),\n           05 SQLITE3_MUTEX_LEAVE             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_mutex_leave'),\n           05 SQLITE3_MUTEX_TRY               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_mutex_try'),\n           05 SQLITE3_NEXT_STMT               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_next_stmt'),\n           05 SQLITE3_OPEN                    CHAR(13) VARYINGZ\n                  INIT( 'sqlite3_open'),\n           05 SQLITE3_OPEN_V2                 CHAR(16) VARYINGZ\n                  INIT( 'sqlite3_open_v2'),\n           05 SQLITE3_OPEN16                  CHAR(15) VARYINGZ\n                  INIT( 'sqlite3_open16'),\n           05 SQLITE3_OS_END                  CHAR(15) VARYINGZ\n                  INIT( 'sqlite3_os_end'),\n           05 SQLITE3_OS_INIT                 CHAR(16) VARYINGZ\n                  INIT( 'sqlite3_os_init'),\n           05 SQLITE3_OVERLOAD_FUNCTION       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_overload_function'),\n           05 SQLITE3_PREPARE                 CHAR(16) VARYINGZ\n                  INIT( 'sqlite3_prepare'),\n           05 SQLITE3_PREPARE_V2              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_prepare_v2'),\n           05 SQLITE3_PREPARE16               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_prepare16'),\n           05 SQLITE3_PREPARE16_V2            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_prepare16_v2'),\n           05 SQLITE3_PROFILE                 CHAR(16) VARYINGZ\n                  INIT( 'sqlite3_profile'),\n           05 SQLITE3_PROGRESS_HANDLER        CHAR(25) VARYINGZ\n                  INIT( 'sqlite3_progress_handler'),\n           05 SQLITE3_RANDOMNESS              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_randomness'),\n           05 SQLITE3_REALLOC                 CHAR(16) VARYINGZ\n                  INIT( 'sqlite3_realloc'),\n           05 SQLITE3_RELEASE_MEMORY          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_release_memory'),\n           05 SQLITE3_RESET                   CHAR(14) VARYINGZ\n                  INIT( 'sqlite3_reset'),\n           05 SQLITE3_RESET_AUTO_EXTENSION    CHAR(29) VARYINGZ\n                  INIT( 'sqlite3_reset_auto_extension'),\n           05 SQLITE3_RESULT_BLOB             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_result_blob'),\n           05 SQLITE3_RESULT_DOUBLE           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_result_double'),\n           05 SQLITE3_RESULT_ERROR            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_result_error'),\n           05 SQLITE3_RESULT_ERROR_CODE       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_result_error_code'),\n           05 SQLITE3_RESULT_ERROR_NOMEM      CHAR(27) VARYINGZ\n                  INIT( 'sqlite3_result_error_nomem'),\n           05 SQLITE3_RESULT_ERROR_TOOBIG     CHAR(28) VARYINGZ\n                  INIT( 'sqlite3_result_error_toobig'),\n           05 SQLITE3_RESULT_ERROR16          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_result_error16'),\n           05 SQLITE3_RESULT_INT              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_result_int'),\n           05 SQLITE3_RESULT_INT64            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_result_int64'),\n           05 SQLITE3_RESULT_NULL             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_result_null'),\n           05 SQLITE3_RESULT_TEXT             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_result_text'),\n           05 SQLITE3_RESULT_TEXT16           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_result_text16'),\n           05 SQLITE3_RESULT_TEXT16BE         CHAR(24) VARYINGZ\n                  INIT( 'sqlite3_result_text16be'),\n           05 SQLITE3_RESULT_TEXT16LE         CHAR(24) VARYINGZ\n                  INIT( 'sqlite3_result_text16le'),\n           05 SQLITE3_RESULT_INIT             CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_result_INIT'),\n           05 SQLITE3_RESULT_ZEROBLOB         CHAR(24) VARYINGZ\n                  INIT( 'sqlite3_result_zeroblob'),\n           05 SQLITE3_ROLLBACK_HOOK           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_rollback_hook'),\n           05 SQLITE3_RTREE_GEOMETRY_CALLBK   CHAR(32) VARYINGZ\n                  INIT( 'sqlite3_rtree_geometry_callback'),\n           05 SQLITE3_SET_AUTHORIZER          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_set_authorizer'),\n           05 SQLITE3_SET_AUXDATA             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_set_auxdata'),\n           05 SQLITE3_SHUTDOWN                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_shutdown'),\n           05 SQLITE3_SLEEP                   CHAR(14) VARYINGZ\n                  INIT( 'sqlite3_sleep'),\n           05 SQLITE3_SNPRINTF                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_snprintf'),\n           05 SQLITE3_SOFT_HEAP_LIMIT         CHAR(24) VARYINGZ\n                  INIT( 'sqlite3_soft_heap_limit'),\n           05 SQLITE3_SOFT_HEAP_LIMIT64       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_soft_heap_limit64'),\n           05 SQLITE3_SOURCEID                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_sourceid'),\n           05 SQLITE3_SQL                     CHAR(12) VARYINGZ\n                  INIT( 'sqlite3_sql'),\n           05 SQLITE3_STATUS                  CHAR(15) VARYINGZ\n                  INIT( 'sqlite3_status'),\n           05 SQLITE3_STEP                    CHAR(13) VARYINGZ\n                  INIT( 'sqlite3_step'),\n           05 SQLITE3_STMT_BUSY               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_stmt_busy'),\n           05 SQLITE3_STMT_READONLY           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_stmt_readonly'),\n           05 SQLITE3_STMT_STATUS             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_stmt_status'),\n           05 SQLITE3_STRGLOB                 CHAR(16) VARYINGZ\n                  INIT( 'sqlite3_strglob'),\n           05 SQLITE3_STRICMP                 CHAR(16) VARYINGZ\n                  INIT( 'sqlite3_stricmp'),\n           05 SQLITE3_STRNICMP                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_strnicmp'),\n           05 SQLITE3_TEST_CONTROL            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_test_control'),\n           05 SQLITE3_THREAD_CLEANUP          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_thread_cleanup'),\n           05 SQLITE3_THREADSAFE              CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_threadsafe'),\n           05 SQLITE3_TOTAL_CHANGES           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_total_changes'),\n           05 SQLITE3_TRACE                   CHAR(14) VARYINGZ\n                  INIT( 'sqlite3_trace'),\n           05 SQLITE3_TRANSFER_BINDINGS       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_transfer_bindings'),\n           05 SQLITE3_UPDATE_HOOK             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_update_hook'),\n           05 SQLITE3_URI_BOOLEAN             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_uri_boolean'),\n           05 SQLITE3_URI_INT64               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_uri_int64'),\n           05 SQLITE3_URI_PARAMETER           CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_uri_parameter'),\n           05 SQLITE3_USER_DATA               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_user_data'),\n           05 SQLITE3_INIT_BLOB               CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_INIT_blob'),\n           05 SQLITE3_INIT_BYTES              CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_INIT_bytes'),\n           05 SQLITE3_INIT_BYTES16            CHAR(22) VARYINGZ\n                  INIT( 'sqlite3_INIT_bytes16'),\n           05 SQLITE3_INIT_DOUBLE             CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_INIT_double'),\n           05 SQLITE3_INIT_INT                CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_INIT_int'),\n           05 SQLITE3_INIT_INT64              CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_INIT_int64'),\n           05 SQLITE3_INIT_NUMERIC_TYPE       CHAR(27) VARYINGZ\n                  INIT( 'sqlite3_INIT_numeric_type'),\n           05 SQLITE3_INIT_TEXT               CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_INIT_text'),\n           05 SQLITE3_INIT_TEXT16             CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_INIT_text16'),\n           05 SQLITE3_INIT_TEXT16BE           CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_INIT_text16be'),\n           05 SQLITE3_INIT_TEXT16LE           CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_INIT_text16le'),\n           05 SQLITE3_INIT_TYPE               CHAR(19) VARYINGZ\n                  INIT( 'sqlite3_INIT_type'),\n           05 SQLITE3_VFS_FIND                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_vfs_find'),\n           05 SQLITE3_VFS_REGISTER            CHAR(21) VARYINGZ\n                  INIT( 'sqlite3_vfs_register'),\n           05 SQLITE3_VFS_UNREGISTER          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_vfs_unregister'),\n           05 SQLITE3_VMPRINTF                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_vmprintf'),\n           05 SQLITE3_VSNPRINTF               CHAR(18) VARYINGZ\n                  INIT( 'sqlite3_vsnprintf'),\n           05 SQLITE3_VTAB_CONFIG             CHAR(20) VARYINGZ\n                  INIT( 'sqlite3_vtab_config'),\n           05 SQLITE3_VTAB_ON_CONFLICT        CHAR(25) VARYINGZ\n                  INIT( 'sqlite3_vtab_on_conflict'),\n           05 SQLITE3_WAL_AUTOCHECKPOINT      CHAR(27) VARYINGZ\n                  INIT( 'sqlite3_wal_autocheckpoint'),\n           05 SQLITE3_WAL_CHECKPOINT          CHAR(23) VARYINGZ\n                  INIT( 'sqlite3_wal_checkpoint'),\n           05 SQLITE3_WAL_CHECKPOINT_V2       CHAR(26) VARYINGZ\n                  INIT( 'sqlite3_wal_checkpoint_v2'),\n           05 SQLITE3_WAL_HOOK                CHAR(17) VARYINGZ\n                  INIT( 'sqlite3_wal_hook');\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SQLITE3A": {"ttr": 65028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00\\x13\\x01\\x13#\\x9f\\x01\\x13$o\\x14\\x18\\x02\\r\\x01_\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "2013-08-27T00:00:00", "modifydate": "2013-09-03T14:18:13", "lines": 525, "newlines": 351, "modlines": 0, "user": "JOARMC"}, "text": "*PROCESS ALIGN,NOCOMPAT\n*PROCESS DXREF,FLAG(ALIGN,CONT,RECORD)\n*PROCESS NOFOLD,NOINFO,PC(DATA,GEN,MCALL)\n*PROCESS RA2,NORLD,MXREF,RXREF,USING(MAP,WARN(13))\n*WARNING - THIS PROGRAM REQUIRES THE HIGH-LEVEL ASSEMBLER\n*          AS WELL AS LE/370\n*          THIS PROGRAM IS RE-ENTRANT.\n         PUSH  PRINT\n         MACRO\n&LBL     MKFUNC &NAME\n         LCLC   &SUFFIX,&IGNORE\n&LBL     DS     0F\n         DC     A(__$&SYSNDX)\n         LCLA   &K\n&K       SETA   K'&NAME\n         DC     A(&K)\n         DC     V(###&SYSNDX)\n         DC     C'&NAME',X'00'\n         DS     0F\n         EXTRN  ###&SYSNDX\n###&SYSNDX ALIAS C'&NAME'\n__$&SYSNDX EQU  *\n         MEND\n         PRINT OFF,NOGEN\n         IEABRCX DEFINE\n         IEABRCX DISABLE\n         POP   PRINT\n         YREGS\nBASE     LOCTR\nMKFUNC   LOCTR\nLOCAL    LOCTR\nBASE     LOCTR\n         GBLC  &LABEL\nSQLITE3A CEEENTRY PPA=SQLITE3A_PPA,                                    X\n               MAIN=NO,                                                X\n               AUTO=DSASIZE,                                           X\n               BASE=R11\n         DROP  R11\n         USING CEECAA,R12\n         USING CEEDSA,R13\n         LARL  R10,LTORG\n         USING LTORG,R10\n         J     GO\nGOBACK   DS    0H\n         CEETERM RC=RETURN_CODE\n*              MODIFIER=MODIFIER\n*              MF=(E,CEETERM_BLOCK)\nGO       DS    0H\n         LHI   R15,21             SQLITE_MISUSE\n         ST    R15,RETURN_CODE    SAVE\n         LTR   R9,R1              ANY PARM\n         JZ    GOBACK             NO - ABORT\n         LA    R1,CALLX\n         LARL  R15,CEE3INF\n         L     R15,0(,R15)\n         CALL  (15),(SYS,ENV,MEMBER,GPID,FC),VL,                       X\n               MF=(E,(1))\n         TM    ENV+1,X'40'        POSIX(ON)?\n         JO    POSIX_ON\n         LHI   R15,21             SQLITE_MISUSE\n         ST    R15,RETURN_CODE    SAVE\n         J     GOBACK\nPOSIX_ON DS    0H\n         L     R8,0(,R9)          PICK UP POINTER TO FUNCTION NAME\n         LARL  R7,FUNCTION\n         LHI   R15,21             SQLITE_MISUSE\n         ST    R15,RETURN_CODE    SAVE\n         SLR   R6,R6\nFINDFUNC DS    0H\n         ICM   R6,B'0011',6(R7)   PICK UP LENGTH\n         JM    GOBACK\n         EX    R6,CLC_FUNC\n         JE    FND_FUNC\n         L     R7,0(,R7)\n         J     FINDFUNC\n*        J     GOBACK\nFND_FUNC DS    0H\n         L     R15,8(,R7)         VECTOR TO ROUTINE\n         LA    R1,4(,R9)          POINT PAST FIRST PARM\n         TM    0(R7),X'80'        INT64?\n         JNO   DO_CALL\n         LA    R1,8(,R9)\nDO_CALL  DS    0H\n         CEEPCALL (15),MF=(E,)    CALL ROUTINE\n         ST    R15,RETURN_CODE\n         AGO   .NEWCOD2\n         CLI   0(R7),0\n         JZ    GOBACK\n         L     R1,4(,R9)          POINT TO SECOND PARM\n         TM    0(R7),X'80'        INT64\n         JO    INT64\n         TM    0(R7),X'40'        DOUBLE\n         JO    DOUBLE\n         J     GOBACK\nDOUBLE   DS    0H\n         LD    0,0(,R1)           GET ALREADY STORED RESULT\n         THDR 0,0                 CONVERT LONG BFP TO LONG HFP\n         STD   0,0(,R1)           PUT IT BACK WHERE i GOT IT\n         J     GOBACK\nINT64    DS    0H\n         STM   R15,R0,0(R1)       STORE VALUE\n.NEWCOD2 ANOP\n         J     GOBACK\nLTORG    DS    0D\n         LTORG *\nCLC_FUNC CLC   0(0,R8),12(R7)\nMKFUNC   LOCTR\nFUNCTION DS    0F\n*        MKFUNC sqlite3_activate_cerod\n*        MKFUNC sqlite3_activate_see\n         MKFUNC sqlite3_aggregate_context\n         MKFUNC sqlite3_aggregate_count\n         MKFUNC sqlite3_auto_extension\n         MKFUNC sqlite3_backup_finish\n         MKFUNC sqlite3_backup_init\n         MKFUNC sqlite3_backup_pagecount\n         MKFUNC sqlite3_backup_remaining\n         MKFUNC sqlite3_backup_step\n         MKFUNC sqlite3_bind_blob\n         MKFUNC sqlite3_bind_double\n         MKFUNC sqlite3_bind_int\n         MKFUNC sqlite3_bind_int64\n         MKFUNC sqlite3_bind_null\n         MKFUNC sqlite3_bind_parameter_count\n         MKFUNC sqlite3_bind_parameter_index\n         MKFUNC sqlite3_bind_parameter_name\n         MKFUNC sqlite3_bind_text\n         MKFUNC sqlite3_bind_text16\n         MKFUNC sqlite3_bind_value\n         MKFUNC sqlite3_bind_zeroblob\n         MKFUNC sqlite3_blob_bytes\n         MKFUNC sqlite3_blob_close\n         MKFUNC sqlite3_blob_open\n         MKFUNC sqlite3_blob_read\n         MKFUNC sqlite3_blob_reopen\n         MKFUNC sqlite3_blob_write\n         MKFUNC sqlite3_busy_handler\n         MKFUNC sqlite3_busy_timeout\n         MKFUNC sqlite3_cancel_auto_extension\n         MKFUNC sqlite3_changes\n         MKFUNC sqlite3_clear_bindings\n         MKFUNC sqlite3_close\n         MKFUNC sqlite3_close_v2\n         MKFUNC sqlite3_collation_needed\n         MKFUNC sqlite3_collation_needed16\n         MKFUNC sqlite3_column_blob\n         MKFUNC sqlite3_column_bytes\n         MKFUNC sqlite3_column_bytes16\n         MKFUNC sqlite3_column_count\n         MKFUNC sqlite3_column_database_name\n         MKFUNC sqlite3_column_database_name16\n         MKFUNC sqlite3_column_decltype\n         MKFUNC sqlite3_column_decltype16\n         MKFUNC sqlite3_column_double,DOUBLE\n         MKFUNC sqlite3_column_int\n         MKFUNC sqlite3_column_int64,INT64\n         MKFUNC sqlite3_column_name\n         MKFUNC sqlite3_column_name16\n         MKFUNC sqlite3_column_origin_name\n         MKFUNC sqlite3_column_origin_name16\n         MKFUNC sqlite3_column_table_name\n         MKFUNC sqlite3_column_table_name16\n         MKFUNC sqlite3_column_text\n         MKFUNC sqlite3_column_text16\n         MKFUNC sqlite3_column_type\n         MKFUNC sqlite3_column_value\n         MKFUNC sqlite3_commit_hook\n         MKFUNC sqlite3_compileoption_get\n         MKFUNC sqlite3_compileoption_used\n         MKFUNC sqlite3_complete\n         MKFUNC sqlite3_complete16\n         MKFUNC sqlite3_config\n         MKFUNC sqlite3_context_db_handle\n         MKFUNC sqlite3_create_collation\n         MKFUNC sqlite3_create_collation_v2\n         MKFUNC sqlite3_create_collation16\n         MKFUNC sqlite3_create_function\n         MKFUNC sqlite3_create_function_v2\n         MKFUNC sqlite3_create_function16\n         MKFUNC sqlite3_create_module\n         MKFUNC sqlite3_create_module_v2\n         MKFUNC sqlite3_data_count\n*        MKFUNC sqlite3_data_directory\n         MKFUNC sqlite3_db_config\n         MKFUNC sqlite3_db_filename\n         MKFUNC sqlite3_db_handle\n         MKFUNC sqlite3_db_mutex\n         MKFUNC sqlite3_db_readonly\n         MKFUNC sqlite3_db_release_memory\n         MKFUNC sqlite3_db_status\n         MKFUNC sqlite3_declare_vtab\n         MKFUNC sqlite3_enable_load_extension\n         MKFUNC sqlite3_enable_shared_cache\n         MKFUNC sqlite3_errcode\n         MKFUNC sqlite3_errmsg\n         MKFUNC sqlite3_errmsg16\n         MKFUNC sqlite3_errstr\n         MKFUNC sqlite3_exec\n         MKFUNC sqlite3_expired\n         MKFUNC sqlite3_extended_errcode\n         MKFUNC sqlite3_extended_result_codes\n         MKFUNC sqlite3_file_control\n         MKFUNC sqlite3_finalize\n         MKFUNC sqlite3_free\n         MKFUNC sqlite3_free_table\n         MKFUNC sqlite3_get_autocommit\n         MKFUNC sqlite3_get_auxdata\n         MKFUNC sqlite3_get_table\n         MKFUNC sqlite3_global_recover\n         MKFUNC sqlite3_initialize\n         MKFUNC sqlite3_interrupt\n*        MKFUNC sqlite3_key\n         MKFUNC sqlite3_last_insert_rowid,INT64\n         MKFUNC sqlite3_libversion\n         MKFUNC sqlite3_libversion_number\n         MKFUNC sqlite3_limit\n         MKFUNC sqlite3_load_extension\n         MKFUNC sqlite3_log\n         MKFUNC sqlite3_malloc\n         MKFUNC sqlite3_memory_alarm\n         MKFUNC sqlite3_memory_highwater,INT64\n         MKFUNC sqlite3_memory_used,INT64\n         MKFUNC sqlite3_mprintf\n         MKFUNC sqlite3_mutex_alloc\n         MKFUNC sqlite3_mutex_enter\n         MKFUNC sqlite3_mutex_free\n*        MKFUNC sqlite3_mutex_held\n         MKFUNC sqlite3_mutex_leave\n*        MKFUNC sqlite3_mutex_notheld\n         MKFUNC sqlite3_mutex_try\n         MKFUNC sqlite3_next_stmt\n         MKFUNC sqlite3_open\n         MKFUNC sqlite3_open_v2\n         MKFUNC sqlite3_open16\n         MKFUNC sqlite3_os_end\n         MKFUNC sqlite3_os_init\n         MKFUNC sqlite3_overload_function\n         MKFUNC sqlite3_prepare\n         MKFUNC sqlite3_prepare_v2\n         MKFUNC sqlite3_prepare16\n         MKFUNC sqlite3_prepare16_v2\n         MKFUNC sqlite3_profile\n         MKFUNC sqlite3_progress_handler\n         MKFUNC sqlite3_randomness\n         MKFUNC sqlite3_realloc\n*        MKFUNC sqlite3_rekey\n         MKFUNC sqlite3_release_memory\n         MKFUNC sqlite3_reset\n         MKFUNC sqlite3_reset_auto_extension\n         MKFUNC sqlite3_result_blob\n         MKFUNC sqlite3_result_double\n         MKFUNC sqlite3_result_error\n         MKFUNC sqlite3_result_error_code\n         MKFUNC sqlite3_result_error_nomem\n         MKFUNC sqlite3_result_error_toobig\n         MKFUNC sqlite3_result_error16\n         MKFUNC sqlite3_result_int\n         MKFUNC sqlite3_result_int64\n         MKFUNC sqlite3_result_null\n         MKFUNC sqlite3_result_text\n         MKFUNC sqlite3_result_text16\n         MKFUNC sqlite3_result_text16be\n         MKFUNC sqlite3_result_text16le\n         MKFUNC sqlite3_result_value\n         MKFUNC sqlite3_result_zeroblob\n         MKFUNC sqlite3_rollback_hook\n         MKFUNC sqlite3_rtree_geometry_callback\n         MKFUNC sqlite3_set_authorizer\n         MKFUNC sqlite3_set_auxdata\n         MKFUNC sqlite3_shutdown\n         MKFUNC sqlite3_sleep\n         MKFUNC sqlite3_snprintf\n         MKFUNC sqlite3_soft_heap_limit\n         MKFUNC sqlite3_soft_heap_limit64,INT64\n         MKFUNC sqlite3_sourceid\n         MKFUNC sqlite3_sql\n         MKFUNC sqlite3_status\n         MKFUNC sqlite3_step\n         MKFUNC sqlite3_stmt_busy\n         MKFUNC sqlite3_stmt_readonly\n         MKFUNC sqlite3_stmt_status\n         MKFUNC sqlite3_strglob\n         MKFUNC sqlite3_stricmp\n         MKFUNC sqlite3_strnicmp\n         MKFUNC sqlite3_table_column_metadata\n*        MKFUNC sqlite3_temp_directory\n         MKFUNC sqlite3_test_control\n         MKFUNC sqlite3_thread_cleanup\n         MKFUNC sqlite3_threadsafe\n         MKFUNC sqlite3_total_changes\n         MKFUNC sqlite3_trace\n         MKFUNC sqlite3_transfer_bindings\n*        MKFUNC sqlite3_unlock_notify\n         MKFUNC sqlite3_update_hook\n         MKFUNC sqlite3_uri_boolean\n         MKFUNC sqlite3_uri_int64,INT64\n         MKFUNC sqlite3_uri_parameter\n         MKFUNC sqlite3_user_data\n         MKFUNC sqlite3_value_blob\n         MKFUNC sqlite3_value_bytes\n         MKFUNC sqlite3_value_bytes16\n         MKFUNC sqlite3_value_double,DOUBLE\n         MKFUNC sqlite3_value_int\n         MKFUNC sqlite3_value_int64,INT64\n         MKFUNC sqlite3_value_numeric_type\n         MKFUNC sqlite3_value_text\n         MKFUNC sqlite3_value_text16\n         MKFUNC sqlite3_value_text16be\n         MKFUNC sqlite3_value_text16le\n         MKFUNC sqlite3_value_type\n*        MKFUNC sqlite3_version\n         MKFUNC sqlite3_vfs_find\n         MKFUNC sqlite3_vfs_register\n         MKFUNC sqlite3_vfs_unregister\n         MKFUNC sqlite3_vmprintf\n         MKFUNC sqlite3_vsnprintf\n         MKFUNC sqlite3_vtab_config\n         MKFUNC sqlite3_vtab_on_conflict\n         MKFUNC sqlite3_wal_autocheckpoint\n         MKFUNC sqlite3_wal_checkpoint\n         MKFUNC sqlite3_wal_checkpoint_v2\n         MKFUNC sqlite3_wal_hook\n*\n* Emulate the function of the MKFUNC macro for two\n* routines written in HLASM and not C.\n*\n*        MKFUNC convert_bfp_to_hfp\n         DC     A(CHTB)           Next entry\n         DC     A(L'CBTHS)        Length of name\n         DC     V(CBTHR)          addr of routine\nCBTHS    DC     C'convert_bfp_to_hfp',X'00'\nCHTB     DS     0F\n*\n*        MKFUNC convert_hfp_to_bfp\n         DC     A(EOL)            Next entry\n         DC     A(L'CHTBS)        Length of name\n         DC     V(CHTBR)          addr of routine\nCHTBS    DC     C'convert_hfp_to_bfp',X'00'\nEOL      DS     0F\n         DC    3F'-1'             END OF LIST INDICATOR\nBASE     LOCTR\nCEE3INF  DC    V(CEE3INF)\nSQLITE3A_PPA CEEPPA LIBRARY=NO,                                        X\n               PPA2=YES,                                               X\n               EXTPROC=YES,                                            X\n               TSTAMP=YES,                                             X\n               PEP=YES,                                                X\n               INSTOP=NO,                                              X\n               EXITDSA=NO,                                             X\n               OWNEXM=YES,                                             X\n               EPNAME=SQLITE3A,                                        X\n               VER=1,                                                  X\n               REL=1,                                                  X\n               MOD=0,                                                  X\n               DSA=YES\nBASE     LOCTR\n         CEEDSA\n* DYNAMIC AREA IS DEFINED HERE.\n* THIS IS WITHIN A DSECT, SO NO DATA IS REALLY INITIALIZED\nCALLX    DS    30A\nSYS      DS    F\n* BIT MEANING\n*    0\n*    CURRENTLY EXECUTING IN THE CICS ENVIRONMENT\n*    1\n*    CURRENTLY EXECUTING IN A CICS_PIPI ENVIRONMENT\n*    2-3\n*    RESERVED FOR OTHER SPECIFIC CICS ENVIRONMENTS\n*    4\n*    CURRENTLY EXECUTING IN A TSO ENVIRONMENT\n*    5\n*    CURRENTLY EXECUTING IN A BATCH ENVIRONMENT\n*    6\n*    CURRENTLY EXECUTING IN A Z/OS UNIX ENVIRONMENT\n*    7-28\n*    RESERVED FOR FUTURE USE\n*    29\n*    CURRENTLY EXECUTING ON Z/VSE(TM)\n*    30\n*    CURRENTLY EXECUTING ON Z/OS\n*    31\n*    PREVIOUSLY INDICATED AS EXECUTING ON Z/OS.E\n*\nENV      DS    F\n*\nMEMBER   DS    F\n*\nGPID     DS    F\nFC       DS    F\nRETURN_CODE DS F\nMODIFIER DS    F\n*EETERM_BLOCK CEETERM MF=L\nDSASIZE  EQU   *-CEEDSA\n         CEECAA\n         END   SQLITE3A\n*PROCESS ALIGN,NOCOMPAT\n*PROCESS DXREF,FLAG(ALIGN,CONT,RECORD)\n*PROCESS NOFOLD,NOINFO,PC(DATA,GEN,MCALL)\n*PROCESS RA2,NORLD,MXREF,RXREF,USING(MAP,WARN(13))\n*WARNING - THIS PROGRAM REQUIRES THE HIGH-LEVEL ASSEMBLER\n*          AS WELL AS LE/370\n*          THIS PROGRAM IS RE-ENTRANT.\n*CBTHR Convert BFP to HFP subroutine\n* R1 points to a C-like calling sequence.\n* R1 +0(8) contains an 8 byte BFP number\n* R1 +8(4) contains a pointer to where to store the HFP\n*\n* This may look a bit strange. Well, it does to me. But\n* the LD loads a bit pattern into a floating point register\n* at this point, the hardware doesn't know if it loaded a\n* BFP or HFP value. The programmer must know that and use\n* the appropriate BFP or HFP opcodes to manipulate the value\n* in the floating register. The same is true of the STD\n* instruction.\n*\n* The other strangeness is likely the calling sequence. I decided\n* to use the C language calling sequence instead of the normal\n* OS calling sequence simply to be consistent with the sqlite3_\n* subroutines. Hope that's not too confusing.\n*\n         PUSH  PRINT\n         PRINT OFF,NOGEN\n         IEABRCX DEFINE\n         IEABRCX DISABLE\n         POP   PRINT\n         YREGS\nCBTHR    CEEENTRY PPA=CBTHR_PPA,                                       X\n               MAIN=NO,                                                X\n               AUTO=DSASIZE,                                           X\n               BASE=R11\n         DROP  R11\n         LR    R9,R1                     Save R1 at entry\n         LD    0,0(,R1)                  Load BFP value\n         THDR  2,0                       Convert to HFP\n         L     R2,8(,R1)                 Point to return area\n         STD   2,0(,R2)\n         SLR   R15,R15\n         SLR   R0,R0\n         CEETERM RC=(15),MODIFIER=(0)\nCBTHR_PPA CEEPPA LIBRARY=NO,                                           X\n               PPA2=YES,                                               X\n               EXTPROC=YES,                                            X\n               TSTAMP=YES,                                             X\n               PEP=YES,                                                X\n               INSTOP=NO,                                              X\n               EXITDSA=NO,                                             X\n               OWNEXM=YES,                                             X\n               EPNAME=CBTHR,                                           X\n               VER=1,                                                  X\n               REL=1,                                                  X\n               MOD=0,                                                  X\n               DSA=YES\n         CEEDSA\n* DYNAMIC AREA IS DEFINED HERE.\n* THIS IS WITHIN A DSECT, SO NO DATA IS REALLY INITIALIZED\nRETURN_CODE DS F\nMODIFIER DS    F\nDSASIZE  EQU   *-CEEDSA\n         CEECAA\n         END   CBTHR\n*PROCESS ALIGN,NOCOMPAT\n*PROCESS DXREF,FLAG(ALIGN,CONT,RECORD)\n*PROCESS NOFOLD,NOINFO,PC(DATA,GEN,MCALL)\n*PROCESS RA2,NORLD,MXREF,RXREF,USING(MAP,WARN(13))\n*WARNING - THIS PROGRAM REQUIRES THE HIGH-LEVEL ASSEMBLER\n*          AS WELL AS LE/370\n*          THIS PROGRAM IS RE-ENTRANT.\n*CHTBR Convert HFP to BFP subroutine\n* R1 points to a C-like calling sequence.\n* R1 +0(8) contains an 8 byte HFP number\n* R1 +8(4) contains a pointer to where to store the BFP\n*\n* This may look a bit strange. Well, it does to me. But\n* the LD loads a bit pattern into a floating point register\n* at this point, the hardware doesn't know if it loaded a\n* BFP or HFP value. The programmer must know that and use\n* the appropriate BFP or HFP opcodes to manipulate the value\n* in the floating register. The same is true of the STD\n* instruction.\n*\n* The other strangeness is likely the calling sequence. I decided\n* to use the C language calling sequence instead of the normal\n* OS calling sequence simply to be consistent with the sqlite3_\n* subroutines. Hope that's not too confusing.\n*\n         PUSH  PRINT\n         PRINT OFF,NOGEN\n         IEABRCX DEFINE\n         IEABRCX DISABLE\n         POP   PRINT\n         YREGS\nCHTBR    CEEENTRY PPA=CHTBR_PPA,                                       X\n               MAIN=NO,                                                X\n               AUTO=DSASIZE,                                           X\n               BASE=R11\n         DROP  R11\n         LR    R9,R1                     Save R1 at entry\n         LD    0,0(,R1)                  Load BFP value\n         TBDR  2,0,0                     Convert to BFP, round to 0\n         L     R2,8(,R1)                 Point to return area\n         STD   2,0(,R2)\n         SLR   R15,R15\n         SLR   R0,R0\n         CEETERM RC=(15),MODIFIER=(0)\nCHTBR_PPA CEEPPA LIBRARY=NO,                                           X\n               PPA2=YES,                                               X\n               EXTPROC=YES,                                            X\n               TSTAMP=YES,                                             X\n               PEP=YES,                                                X\n               INSTOP=NO,                                              X\n               EXITDSA=NO,                                             X\n               OWNEXM=YES,                                             X\n               EPNAME=CHTBR,                                           X\n               VER=1,                                                  X\n               REL=1,                                                  X\n               MOD=0,                                                  X\n               DSA=YES\n         CEEDSA\n* DYNAMIC AREA IS DEFINED HERE.\n* THIS IS WITHIN A DSECT, SO NO DATA IS REALLY INITIALIZED\nRETURN_CODE DS F\nMODIFIER DS    F\nDSASIZE  EQU   *-CEEDSA\n         CEECAA\n         END   CHTBR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SQLITE3O": {"ttr": 65281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x141\\x1f\\x01\\x141\\x1f\\x08D^\\xac^\\xac\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-11-07T00:00:00", "modifydate": "2014-11-07T08:44:27", "lines": 24236, "newlines": 24236, "modlines": 0, "user": "JOARMC"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TESTCOB1": {"ttr": 75015, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x009\\x01\\x13#\\x9f\\x01\\x141\\x1f\\x12(\\x01\\xbc\\x01\\xa3\\x01\\x8a\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "2013-08-27T00:00:00", "modifydate": "2014-11-07T12:28:39", "lines": 444, "newlines": 419, "modlines": 394, "user": "JOARMC"}, "text": "000100 PROCESS DYNAM,NAME,PGMNAME(COMPAT)\n000200 PROCESS ADV,AWO,NOC(W),FSRT,FLAG(I,I)\n000300 PROCESS INTDATE(ANSI),LANG(EN),LIB,LIST,MAP\n000400 PROCESS NONUM,NUMPROC(PFD),OBJ,APOST\n000500 PROCESS RENT,NOSEQ,SOURCE,NOSSRANGE,\n000600 PROCESS NOTERM,NOTEST,VBREF,\n000700 PROCESS XREF(FULL),ZWB,FASTSRT,AR(E)\n000800 ID DIVISION.\n000900 PROGRAM-ID. 'TESTCOB1'.\n001000 AUTHOR. JOHN MCKOWN.\n001100 INSTALLATION. CBT Tape.\n001200 DATE-WRITTEN.\n001300 DATE-COMPILED.\n001400 SECURITY. NONE.\n001500*\n001600 ENVIRONMENT DIVISION.\n001700 CONFIGURATION SECTION.\n001800 SOURCE-COMPUTER. IBM-370.\n001900 OBJECT-COMPUTER. IBM-370.\n002000 SPECIAL-NAMES.\n002100 INPUT-OUTPUT SECTION.\n002200 FILE-CONTROL.\n002300 I-O-CONTROL.\n002400*    APPLY WRITE-ONLY ON REPORT1-FD.\n002500*\n002600 DATA DIVISION.\n002700 FILE SECTION.\n002800\n002900*\n003000 WORKING-STORAGE SECTION.\n003100 COPY COBSQLTE .\n003200 01  CEE3DMP-PARAMETERS.\n003300     05 CEE3DMP-TITLE              PIC X(80)\n003400        VALUE 'TEST DUMP'.\n003500     05 CEE3DMP-OPTIONS            PIC X(255)\n003600        VALUE 'NOTRACE NOENTRY'.\n003700 01  LE-FC.\n003800     02  CONDITION-TOKEN-VALUE.\n003900     COPY  CEEIGZCT.\n004000         03  CASE-1-CONDITION-ID.\n004100             04  SEVERITY    PIC S9(4) BINARY.\n004200             04  MSG-NO      PIC S9(4) BINARY.\n004300         03  CASE-2-CONDITION-ID\n004400                   REDEFINES CASE-1-CONDITION-ID.\n004500             04  CLASS-CODE  PIC S9(4) BINARY.\n004600             04  CAUSE-CODE  PIC S9(4) BINARY.\n004700         03  CASE-SEV-CTL    PIC X.\n004800         03  FACILITY-ID     PIC XXX.\n004900     02  I-S-INFO            PIC S9(9) BINARY.\n005000*\n005100 LOCAL-STORAGE SECTION.\n005200 01  LS-FULLWORD-RETURN.\n005300     05  LS-LIBVERSION-POINTER   POINTER.\n005400     05  LS-LIBVERSION-BINVALUE  REDEFINES LS-LIBVERSION-POINTER\n005500                                 PIC S9(9) COMP-5.\n005600 77  LS-LILIAN               PIC S9(9) COMP-5.\n005700 77  LS-GMT-SECS-1           USAGE COMP-2.\n005800 77  LS-GMT-SECS-2           USAGE COMP-2.\n005900 77  LS-GMT-SECS-3           USAGE COMP-2.\n006000 77  LS-GMT-SECS-4           USAGE COMP-2.\n006100 77  LS-GMT-SECS-5           USAGE COMP-2.\n006200 77  LS-GMT-SECS-6           USAGE COMP-2.\n006300 77  LS-DB                   USAGE IS POINTER.\n006400 77  LS-INSERT-STMT          USAGE IS POINTER.\n006500 77  LS-SELECT-STMT          USAGE IS POINTER.\n006600 77  LS-ZERO                 PIC S9(9) COMP-5\n006700                             VALUE IS ZERO.\n006800 77  LS-RC                   PIC S9(9) COMP-5.\n006900 77  LS-SQL-RC               PIC S9(9) COMP-5.\n007000 77  SQL-ZCHAR               PIC X(255).\n007100 77  LS-I                    PIC S9(9) COMP-5.\n007200 77  LS-RECORD-COUNT         PIC S9(9) COMP-5.\n007300 77  LS-MINUS-ONE            PIC S9(9) COMP-5\n007400        VALUE IS -1.\n007500 77  LS-ONE                  PIC S9(9) COMP-5\n007600        VALUE IS 1.\n007700 77  LS-LIBVERSION-LENGTH    PIC S9(9) COMP-5\n007800        VALUE IS 0.\n007900 LINKAGE SECTION.\n008000 01  MVS-PARM.\n008100     05 MVS-PARM-LENGTH      PIC S9(4) COMP-5.\n008200     05 MVS-PARM-VALUE       PIC X(32760).\n008300 77  LINKAGE-LIBVERSION      PIC X(101).\n008400* MVS-PARM-VALUE LENGTH IS REALLY ONLY THE NUMBER OF CHARACTERS\n008500* CONTAINED IN MVS-PARM-LENGTH. YOU NEED TO USE REFERENCE\n008600* MODIFICATION TO MAKE SURE YOU DON'T EXCEED THE ACTUAL LENGTH\n008700* PASSED TO THIS PROGRAM.\n008800*\n008900 PROCEDURE DIVISION USING MVS-PARM.\n009000 START-UP.\n009100**\n009200** How to access the data when SQLITE returns a\n009300** pointer. The following shows how to get the pointer\n009400** and then determine the length of the C \"string\"\n009500** which ends with a LOW-VALUES (0x00).\n009600     CALL 'SQLITE3A' USING SQLITE3-LIBVERSION\n009700          RETURNING LS-LIBVERSION-POINTER\n009800     END-CALL\n009900     IF LS-LIBVERSION-POINTER NOT EQUAL TO NULL THEN\n010000        SET ADDRESS OF LINKAGE-LIBVERSION TO LS-LIBVERSION-POINTER\n010100*\n010200* Get the length of the returned string by finding the first\n010300* LOW-VALUE (0x00). Probably not as efficient as calling the\n010400* C \"strlen\" routine, but is \"pure\" COBOL.\n010500        MOVE ZERO TO LS-LIBVERSION-LENGTH\n010600        INSPECT LINKAGE-LIBVERSION\n010700                TALLYING LS-LIBVERSION-LENGTH\n010800                FOR CHARACTERS BEFORE INITIAL LOW-VALUE\n010900*\n011000* If you're interested, this is how to call \"strlen\". It requires\n011100* that CEE.SCEELKED be available for dynamic calling or linking\n011200* depending on the compile option DYNAM or NODYNAM, respectively.\n011300*       CALL    'STRLEN' USING BY VALUE LS-LIBVERSION-POINTER\n011400*               RETURNING LS-LIBVERSION-LENGTH\n011500*       END-CALL\n011600        DISPLAY \"Sqlite version is \"\n011700                LINKAGE-LIBVERSION(1:LS-LIBVERSION-LENGTH)\n011800                UPON SYSOUT\n011900     END-IF\n012000     CALL 'SQLITE3A' USING SQLITE3-INITIALIZE\n012100     RETURNING LS-SQL-RC\n012200     END-CALL\n012300D    DISPLAY 'INITIALIZE LS-SQL-RC=' LS-SQL-RC\n012400D            UPON SYSOUT\n012500     IF LS-SQL-RC NOT = SQLITE-OK THEN\n012600        DISPLAY 'SQLITE-INITIALIZE FAILED. RC='\n012700            RETURN-CODE\n012800            UPON SYSOUT\n012900        GOBACK\n013000     END-IF\n013100     .\n013200 INITIALIZE-SQLITE.\n013300*\n013400* Note: in my testing, this creates a z/OS UNIX file in\n013500* the /tmp subdirectory, with the name testcob1.sqlite3 .\n013600* That is, the data base name is actually the UNIX file name.\n013700* This can be absolute, as in my example, or relative to the\n013800* user's UNIX $HOME directory if the value does not start with\n013900* a slash character. This is the norm for UNIX file names.\n014000*\n014100* Note that a prefix of a tilde, ~/, does not expand to the user's\n014200* $HOME as it would in a UNIX shell.\n014300* Again, in my testing, the OPEN fails with SQLITE-CANTOPEN (14).\n014400*\n014500     MOVE Z'/tmp/testcob1.sqlite3' TO SQL-ZCHAR\n014600     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-OPEN\n014700          BY REFERENCE SQL-ZCHAR\n014800          BY REFERENCE LS-DB\n014900          RETURNING LS-SQL-RC\n015000     END-CALL\n015100     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n015200        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n015300        DISPLAY 'SQLITE3-OPEN FAILED. RC='\n015400           LS-SQL-RC UPON SYSOUT\n015500        GOBACK\n015600     END-IF\n015700     .\n015800 DROP-TABLE.\n015900     MOVE Z'DROP TABLE xz' TO SQL-ZCHAR\n016000     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-EXEC\n016100          BY VALUE LS-DB\n016200          BY REFERENCE SQL-ZCHAR\n016300          BY VALUE LS-ZERO\n016400          BY VALUE LS-ZERO\n016500          BY VALUE LS-ZERO\n016600          RETURNING LS-SQL-RC\n016700     END-CALL\n016800     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n016900        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n017000        DISPLAY 'DROP TABLE  FAILED. RC='\n017100           LS-SQL-RC UPON SYSOUT\n017200     END-IF\n017300     .\n017400 CREATE-TABLE.\n017500     MOVE Z'CREATE TABLE xz(N INTEGER)' TO SQL-ZCHAR\n017600     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-EXEC\n017700          BY VALUE LS-DB\n017800          BY REFERENCE SQL-ZCHAR\n017900          BY VALUE LS-ZERO\n018000          BY VALUE LS-ZERO\n018100          BY VALUE LS-ZERO\n018200          RETURNING LS-SQL-RC\n018300     END-CALL\n018400D    DISPLAY 'CREATE TABLE RC=' LS-SQL-RC UPON SYSOUT\n018500     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n018600        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n018700        DISPLAY 'CREATE TABLE  FAILED. RC='\n018800           LS-SQL-RC UPON SYSOUT\n018900        GOBACK\n019000     END-IF\n019100     .\n019200 CREATE-INDEX.\n019300     MOVE Z'CREATE INDEX r1 ON xz(N)' TO SQL-ZCHAR\n019400     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-EXEC\n019500          BY VALUE LS-DB\n019600          BY REFERENCE SQL-ZCHAR\n019700          BY VALUE LS-ZERO\n019800          BY VALUE LS-ZERO\n019900          BY VALUE LS-ZERO\n020000          RETURNING LS-SQL-RC\n020100     END-CALL\n020200D    DISPLAY 'CREATE TABLE RC=' RETURN-CODE UPON SYSOUT\n020300     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n020400        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n020500        DISPLAY 'CREATE TABLE  FAILED. RC='\n020600           LS-SQL-RC UPON SYSOUT\n020700        GOBACK\n020800     END-IF\n020900     .\n021000 PREPARE-INSERT.\n021100     MOVE Z'INSERT INTO xz(N) VALUES(?)' TO SQL-ZCHAR\n021200     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-PREPARE\n021300          BY VALUE LS-DB\n021400          BY REFERENCE SQL-ZCHAR\n021500          BY VALUE LS-MINUS-ONE\n021600          BY REFERENCE LS-INSERT-STMT\n021700          BY VALUE LS-ZERO\n021800          RETURNING LS-SQL-RC\n021900     END-CALL\n022000D    DISPLAY 'PREPARE INSERT RC=' LS-SQL-RC UPON SYSOUT\n022100     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n022200        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n022300        DISPLAY 'PREPARE OF INSERT FAILED. RC='\n022400           LS-SQL-RC UPON SYSOUT\n022500        GOBACK\n022600     END-IF\n022700     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-CHANGES\n022800          BY VALUE LS-DB\n022900          RETURNING LS-SQL-RC\n023000     END-CALL\n023100     DISPLAY 'CHANGES BEFORE BEGIN=' LS-SQL-RC\n023200       UPON SYSOUT\n023300     .\n023400 BEGIN-TRANSACTION.\n023500     MOVE Z'BEGIN TRANSACTION' TO SQL-ZCHAR\n023600     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-EXEC\n023700          BY VALUE LS-DB\n023800          BY REFERENCE SQL-ZCHAR\n023900          BY VALUE LS-ZERO\n024000          BY VALUE LS-ZERO\n024100          BY VALUE LS-ZERO\n024200          RETURNING LS-SQL-RC\n024300     END-CALL\n024400D    DISPLAY 'BEGIN TRANSACTION RC=' LS-SQL-RC UPON SYSOUT\n024500     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n024600        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n024700        DISPLAY 'BEGIN TRANSACTION. RC='\n024800           LS-SQL-RC UPON SYSOUT\n024900        GOBACK\n025000     END-IF\n025100     CALL 'CEEGMT' USING LS-LILIAN, LS-GMT-SECS-1, LE-FC\n025200     .\n025300 INSERT-VALUES.\n025400*\n025500* Inline PERFORM to insert values.\n025600     PERFORM VARYING LS-I FROM 0 BY 1 UNTIL LS-I >= 50000\n025700* Bind the host variable contents to the prepared statement\n025800     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-BIND-INT\n025900          BY VALUE LS-INSERT-STMT\n026000          BY VALUE LS-ONE\n026100          BY VALUE LS-I\n026200          RETURNING LS-SQL-RC\n026300     END-CALL\n026400D    DISPLAY 'INSERT BIND RC=' LS-SQL-RC UPON SYSOUT\n026500     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n026600        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n026700        DISPLAY 'INSERT BIND FAILED. RC='\n026800           LS-SQL-RC UPON SYSOUT\n026900        GOBACK\n027000     END-IF\n027100* Actually insert the data.\n027200     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-STEP\n027300          BY VALUE LS-INSERT-STMT\n027400          RETURNING LS-SQL-RC\n027500     END-CALL\n027600D    DISPLAY 'INSERT STEP RC=' LS-SQL-RC\n027700D            ' VALUE=' LS-I\n027800D            UPON SYSOUT\n027900     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n028000        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n028100        DISPLAY 'INSERT (STEP) FAILED. RC='\n028200           LS-SQL-RC UPON SYSOUT\n028300        GOBACK\n028400     END-IF\n028500* Do a \"reset\" to reset the prepared statement for reuse.\n028600     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-RESET\n028700          BY VALUE LS-INSERT-STMT\n028800          RETURNING LS-SQL-RC\n028900     END-CALL\n029000D    DISPLAY 'INSERT RESET RC=' LS-SQL-RC UPON SYSOUT\n029100     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n029200        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n029300        DISPLAY 'RESET FAILED. RC='\n029400           LS-SQL-RC UPON SYSOUT\n029500        GOBACK\n029600     END-IF\n029700     END-PERFORM\n029800* End of INSERT loop\n029900     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-CHANGES\n030000          BY VALUE LS-DB\n030100          RETURNING LS-SQL-RC\n030200     END-CALL\n030300     DISPLAY 'CHANGES BEFORE COMMIT=' LS-SQL-RC\n030400             UPON SYSOUT\n030500* Finalize the prepared statement to release resources.\n030600     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-FINALIZE\n030700          BY VALUE LS-INSERT-STMT\n030800          RETURNING LS-SQL-RC\n030900     END-CALL\n031000*    MOVE RETURN-CODE TO LS-SQL-RC\n031100D    DISPLAY 'INSERT FINIALIZE RC=' LS-SQL-RC UPON SYSOUT\n031200     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n031300        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n031400        DISPLAY 'FINALIZE FAILED. RC='\n031500           LS-SQL-RC UPON SYSOUT\n031600        GOBACK\n031700     END-IF\n031800     .\n031900 COMMIT-TRANSACTION.\n032000* Commit the data just inserted.\n032100     MOVE Z'COMMIT TRANSACTION' TO SQL-ZCHAR\n032200     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-EXEC\n032300          BY VALUE LS-DB\n032400          BY REFERENCE SQL-ZCHAR\n032500          BY VALUE LS-ZERO\n032600          BY VALUE LS-ZERO\n032700          BY VALUE LS-ZERO\n032800          RETURNING LS-SQL-RC\n032900     END-CALL\n033000D    DISPLAY 'COMMIT EXEC RC=' LS-SQL-RC UPON SYSOUT\n033100     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n033200        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n033300        DISPLAY 'DROP TABLE  FAILED. RC='\n033400           LS-SQL-RC UPON SYSOUT\n033500        GOBACK\n033600     END-IF\n033700     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-CHANGES\n033800          BY VALUE LS-DB\n033900          RETURNING LS-SQL-RC\n034000     END-CALL\n034100     DISPLAY 'CHANGES AFTER COMMIT=' LS-SQL-RC\n034200             UPON SYSOUT\n034300     .\n034400 GET-TIMING-1.\n034500     CALL 'CEEGMT' USING LS-LILIAN, LS-GMT-SECS-2, LE-FC\n034600     SUBTRACT LS-GMT-SECS-1 FROM LS-GMT-SECS-2\n034700              GIVING LS-GMT-SECS-4.\n034800     DISPLAY 'TIME DIFFERENCE #1=' LS-GMT-SECS-4\n034900             UPON SYSOUT\n035000     .\n035100 PREPARE-SELECT.\n035200     MOVE Z'SELECT N FROM xz;' TO SQL-ZCHAR\n035300     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-PREPARE\n035400          BY VALUE LS-DB\n035500          BY REFERENCE SQL-ZCHAR\n035600          BY VALUE LS-MINUS-ONE\n035700          BY REFERENCE LS-SELECT-STMT\n035800          BY VALUE LS-ZERO\n035900          RETURNING LS-SQL-RC\n036000     END-CALL\n036100*    MOVE RETURN-CODE TO LS-SQL-RC\n036200D    DISPLAY 'SELECT PREPARE RC=' LS-SQL-RC UPON SYSOUT\n036300     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n036400        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n036500        DISPLAY 'PREPARE OF SELECT FAILED. RC='\n036600           LS-SQL-RC UPON SYSOUT\n036700        GOBACK\n036800     END-IF\n036900     .\n037000 SETUP-SELECT-LOOP.\n037100     CALL 'CEEGMT' USING LS-LILIAN, LS-GMT-SECS-4, LE-FC\n037200     MOVE ZERO TO LS-SQL-RC\n037300     MOVE ZERO TO LS-I\n037400     MOVE ZERO TO LS-RECORD-COUNT\n037500     .\n037600 SELECT-LOOP.\n037700* Inline PERFORM to insert values.\n037800     PERFORM UNTIL LS-SQL-RC NOT = 0\n037900* Bind the host variable contents to the prepared statement\n038000D    DISPLAY 'LS-RECORD-COUNT=' LS-RECORD-COUNT UPON SYSOUT\n038100D    DISPLAY 'LS-ONE=' LS-ONE UPON SYSOUT\n038200     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-STEP\n038300          BY VALUE LS-SELECT-STMT\n038400          RETURNING LS-SQL-RC\n038500     END-CALL\n038600D    DISPLAY 'SELECT STEP RC=' LS-SQL-RC UPON SYSOUT\n038700     EVALUATE LS-SQL-RC\n038800     WHEN SQLITE-OK\n038900D         DISPLAY 'SQLITE-OK' UPON SYSOUT\n039000          ADD +1 TO LS-RECORD-COUNT\n039100          MOVE 0 TO LS-SQL-RC\n039200     WHEN SQLITE-ROW\n039300D         DISPLAY 'SQLITE-ROW' UPON SYSOUT\n039400          ADD +1 TO LS-RECORD-COUNT\n039500D         CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-COLUMN-INT\n039600D              BY VALUE LS-SELECT-STMT\n039700D              BY VALUE LS-ZERO\n039800D              RETURNING LS-I\n039900D         END-CALL\n040000D         DISPLAY 'GOT VALUE ' LS-I ' ON CALL ' LS-RECORD-COUNT\n040100D                 UPON SYSOUT\n040200          MOVE 0 TO LS-SQL-RC\n040300     WHEN SQLITE-DONE\n040400D         DISPLAY 'SQLITE-DONE' UPON SYSOUT\n040500          MOVE +4 TO LS-SQL-RC\n040600     WHEN OTHER\n040700D         DISPLAY 'OTHER' UPON SYSOUT\n040800          DISPLAY 'SELECT FAILED ERROR=' LS-SQL-RC\n040900                  'COUNT=' LS-RECORD-COUNT\n041000                  UPON SYSOUT\n041100          MOVE +8 TO LS-SQL-RC\n041200     END-EVALUATE\n041300     END-PERFORM\n041400* End of INSERT loop\n041500* Finalize the prepared statement to release resources.\n041600     CALL 'SQLITE3A' USING BY REFERENCE SQLITE3-FINALIZE\n041700          BY VALUE LS-SELECT-STMT\n041800          RETURNING LS-SQL-RC\n041900     END-CALL\n042000D    DISPLAY 'SELECT FINALIZE RC=' LS-SQL-RC UPON SYSOUT\n042100     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n042200        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n042300        DISPLAY 'FINALIZE FAILED. RC='\n042400           LS-SQL-RC UPON SYSOUT\n042500        GOBACK\n042600     END-IF\n042700     .\n042800\n042900 GET-TIMING-2.\n043000     CALL 'CEEGMT' USING LS-LILIAN, LS-GMT-SECS-5, LE-FC\n043100     SUBTRACT LS-GMT-SECS-4 FROM LS-GMT-SECS-5\n043200              GIVING LS-GMT-SECS-6.\n043300     DISPLAY 'SELECT TIME=' LS-GMT-SECS-6 ' '\n043400             LS-RECORD-COUNT ' ROWS SELECTED.'\n043500             UPON SYSOUT\n043600     .\n043700\n043800 SHUTDOWN.\n043900     CALL 'SQLITE3A' USING SQLITE3-SHUTDOWN\n044000          RETURNING LS-SQL-RC\n044100     END-CALL\n044200     GOBACK\n044300     .\n044400 END PROGRAM 'TESTCOB1'.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TESTCOB2": {"ttr": 75269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x18\\x01\\x13$_\\x01\\x14\\x07\\x0f\\x08\\x04\\x01\\x06\\x01\\xca\\x00a\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2013-09-02T00:00:00", "modifydate": "2014-03-11T08:04:18", "lines": 262, "newlines": 458, "modlines": 97, "user": "JOARMC"}, "text": "000100 PROCESS DYNAM,NAME,PGMNAME(COMPAT)\n000200 PROCESS ADV,AWO,NOC(W),FSRT,FLAG(I,I)\n000300 PROCESS INTDATE(ANSI),LANG(EN),LIB,LIST,MAP\n000400 PROCESS NONUM,NUMPROC(PFD),OBJ,APOST\n000500 PROCESS RENT,NOSEQ,SOURCE,NOSSRANGE,\n000600 PROCESS NOTERM,NOTEST,VBREF,\n000700 PROCESS XREF(FULL),ZWB,FASTSRT,AR(E)\n000800 ID DIVISION.\n000900 PROGRAM-ID. 'TESTCOB2'.\n001000 AUTHOR. JOHN MCKOWN.\n001100 INSTALLATION. CBT Tape.\n001200 DATE-WRITTEN.\n001300 DATE-COMPILED.\n001400 SECURITY. NONE.\n001500*\n001600* This program is designed to open a existing SQLITE file\n001700* which contains one or more tables. It will then display\n001800* the name of each table and the contents of every row\n001900* within each table.\n002000 ENVIRONMENT DIVISION.\n002100 CONFIGURATION SECTION.\n002200 SOURCE-COMPUTER. IBM-370.\n002300 OBJECT-COMPUTER. IBM-370.\n002400 SPECIAL-NAMES.\n002500 INPUT-OUTPUT SECTION.\n002600 FILE-CONTROL.\n002700 I-O-CONTROL.\n002800*    APPLY WRITE-ONLY ON REPORT1-FD.\n002900*\n003000 DATA DIVISION.\n003100 FILE SECTION.\n003200\n003300*\n003400 WORKING-STORAGE SECTION.\n003500 COPY COBSQLTE .\n003600 01  CEE3DMP-PARAMETERS.\n003700     05 CEE3DMP-TITLE              PIC X(80)\n003800        VALUE 'TEST DUMP'.\n003900     05 CEE3DMP-OPTIONS            PIC X(255)\n004000        VALUE 'NOTRACE NOENTRY'.\n004100 01  LE-FC.\n004200     02  CONDITION-TOKEN-VALUE.\n004300     COPY  CEEIGZCT.\n004400         03  CASE-1-CONDITION-ID.\n004500             04  SEVERITY    PIC S9(4) BINARY.\n004600             04  MSG-NO      PIC S9(4) BINARY.\n004700         03  CASE-2-CONDITION-ID\n004800                   REDEFINES CASE-1-CONDITION-ID.\n004900             04  CLASS-CODE  PIC S9(4) BINARY.\n005000             04  CAUSE-CODE  PIC S9(4) BINARY.\n005100         03  CASE-SEV-CTL    PIC X.\n005200         03  FACILITY-ID     PIC XXX.\n005300     02  I-S-INFO            PIC S9(9) BINARY.\n005400*\n005500 LOCAL-STORAGE SECTION.\n005600 01  LS-FULLWORD-RETURN.\n005700     05  LS-SOURCEID-POINTER     POINTER.\n005800     05  LS-SOURCEID-BINVALUE    REDEFINES LS-SOURCEID-POINTER\n005900                                 PIC S9(9) COMP-5.\n006000 77  LS-COLUMN-NUMBER        PIC S9(9) COMP-5.\n006100 77  LS-DATABASE-NAME        PIC X(255).\n006200 77  LS-DB                   USAGE IS POINTER.\n006300 77  LS-INSERT-STMT          USAGE IS POINTER.\n006400 77  LS-SELECT-STMT          USAGE IS POINTER.\n006500 77  LS-ZERO                 PIC S9(9) COMP-5\n006600                             VALUE IS ZERO.\n006700 77  LS-RC                   PIC S9(9) COMP-5.\n006800 77  LS-SQL-RC               PIC S9(9) COMP-5.\n006900 77  SQL-ZCHAR               PIC X(255).\n007000 77  LS-I                    PIC S9(9) COMP-5.\n007100 77  LS-RECORD-COUNT         PIC S9(9) COMP-5.\n007200 77  LS-MINUS-ONE            PIC S9(9) COMP-5\n007300        VALUE IS -1.\n007400 77  LS-ONE                  PIC S9(9) COMP-5\n007500        VALUE IS 1.\n007600 77  LS-SOURCEID-LENGTH      PIC S9(9) COMP-5.\n007700 77  LS-DOUBLE-BFP           USAGE COMP-2.\n007800 77  LS-DOUBLE-HFP           USAGE COMP-2.\n007900 77  LS-OPEN-FLAGS           PIC S9(9) COMP-5.\n008000 77  LS-NULL                 POINTER VALUE IS NULL.\n008100 LINKAGE SECTION.\n008200 01  MVS-PARM.\n008300     05 MVS-PARM-LENGTH      PIC S9(4) COMP-5.\n008400     05 MVS-PARM-VALUE       PIC X(32760).\n008500 77  LINKAGE-SOURCEID        PIC X(101).\n008600* MVS-PARM-VALUE LENGTH IS REALLY ONLY THE NUMBER OF CHARACTERS\n008700* CONTAINED IN MVS-PARM-LENGTH. YOU NEED TO USE REFERENCE\n008800* MODIFICATION TO MAKE SURE YOU DON'T EXCEED THE ACTUAL LENGTH\n008900* PASSED TO THIS PROGRAM.\n009000*\n009100 PROCEDURE DIVISION USING MVS-PARM.\n009200 START-UP.\n009300**\n009400** How to access the data when SQLITE returns a\n009500** pointer. The following shows how to get the pointer\n009600** and then determine the length of the C \"string\"\n009700** which ends with a LOW-VALUES (0x00).\n009800     CALL SQLITE3A USING SQLITE3-LIBVERSION\n009900          RETURNING LS-SOURCEID-POINTER\n010000     END-CALL\n010100     IF LS-SOURCEID-POINTER NOT EQUAL TO NULL THEN\n010200        SET ADDRESS OF LINKAGE-SOURCEID TO LS-SOURCEID-POINTER\n010300*\n010400* Get the length of the returned string by finding the first\n010500* LOW-VALUE (0x00). Probably not as efficient as calling the\n010600* C \"strlen\" routine, but is \"pure\" COBOL.\n010700        INSPECT LINKAGE-SOURCEID\n010800                TALLYING LS-SOURCEID-LENGTH\n010900                FOR CHARACTERS BEFORE INITIAL LOW-VALUE\n011000*\n011100* If you're interested, this is how to call \"strlen\". It requires\n011200* that CEE.SCEELKED be available for dynamic calling or linking\n011300* depending on the compile option DYNAM or NODYNAM, respectively.\n011400*       CALL    'STRLEN' USING BY VALUE LS-SOURCEID-POINTER\n011500*               RETURNING LS-SOURCEID-LENGTH\n011600*       END-CALL\n011700        DISPLAY \"Sqlite version is \"\n011800                LINKAGE-SOURCEID(1:LS-SOURCEID-LENGTH)\n011900                UPON SYSOUT\n012000     END-IF\n012100     CALL SQLITE3A USING SQLITE3-INITIALIZE\n012200     RETURNING LS-SQL-RC\n012300     END-CALL\n012400D    DISPLAY 'INITIALIZE LS-SQL-RC=' LS-SQL-RC\n012500D            UPON SYSOUT\n012600     IF LS-SQL-RC NOT = SQLITE-OK THEN\n012700        DISPLAY 'SQLITE-INITIALIZE FAILED. RC='\n012800            RETURN-CODE\n012900            UPON SYSOUT\n013000        GOBACK\n013100     END-IF\n013200     .\n013300 INITIALIZE-SQLITE.\n013400*\n013500* Note: in my testing, this creates a z/OS UNIX file in\n013600* the /tmp subdirectory, with the name testcob2.sqlite3 .\n013700* That is, the data base name is actually the UNIX file name.\n013800* This can be absolute, as in my example, or relative to the\n013900* user's UNIX $HOME directory if the value does not start with\n014000* a slash character. This is the norm for UNIX file names.\n014100*\n014200* Note that a prefix of a tilde, ~/, does not expand to the user's\n014300* $HOME as it would in a UNIX shell.\n014400* Again, in my testing, the OPEN fails with SQLITE-CANTOPEN (14).\n014500*\n014600     IF MVS-PARM-LENGTH IS GREATER THAN 254 THEN\n014700        DISPLAY 'INPUT DATA BASE NAME IS TOO LONG.'\n014800                ' LENGTH=' MVS-PARM-LENGTH\n014900                UPON SYSOUT\n015000        MOVE +16 TO RETURN-CODE\n015100     END-IF\n015200     IF MVS-PARM-LENGTH IS EQUAL TO ZERO THEN\n015300        MOVE Z'/tmp/testcob2.sqlite3' TO SQL-ZCHAR\n015400     ELSE\n015500        MOVE MVS-PARM-VALUE(1:MVS-PARM-LENGTH) TO\n015600             SQL-ZCHAR\n015700        MOVE LOW-VALUES TO\n015800             SQL-ZCHAR(MVS-PARM-LENGTH + 1:1)\n015900     END-IF\n016000     MOVE SQLITE-OPEN-READONLY TO LS-OPEN-FLAGS\n016100     CALL SQLITE3A USING BY REFERENCE SQLITE3-OPEN-V2\n016200          BY REFERENCE SQL-ZCHAR\n016300          BY REFERENCE LS-DB\n016400          BY VALUE LS-OPEN-FLAGS\n016500          BY VALUE LS-NULL\n016600          RETURNING LS-SQL-RC\n016700     END-CALL\n016800     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n016900        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n017000        DISPLAY 'SQLITE3-OPEN FAILED. RC='\n017100           LS-SQL-RC UPON SYSOUT\n017200        MOVE +16 TO RETURN-CODE\n017300        GOBACK\n017400     END-IF\n017500     .\n017600 PREPARE-SELECT.\n017700     MOVE Z'SELECT int,fd FROM xz;' TO SQL-ZCHAR\n017800     CALL SQLITE3A USING BY REFERENCE SQLITE3-PREPARE-V2\n017900          BY VALUE LS-DB\n018000          BY REFERENCE SQL-ZCHAR\n018100          BY VALUE LS-MINUS-ONE\n018200          BY REFERENCE LS-SELECT-STMT\n018300          BY VALUE LS-ZERO\n018400          RETURNING LS-SQL-RC\n018500     END-CALL\n018600*    MOVE RETURN-CODE TO LS-SQL-RC\n018700D    DISPLAY 'SELECT PREPARE RC=' LS-SQL-RC UPON SYSOUT\n018800     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n018900        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n019000        DISPLAY 'PREPARE OF SELECT FAILED. RC='\n019100           LS-SQL-RC UPON SYSOUT\n019200        GOBACK\n019300     END-IF\n019400     .\n019500 SELECT-LOOP.\n019600     MOVE +0 TO LS-SQL-RC\n019700     PERFORM UNTIL LS-SQL-RC IS NOT EQUAL TO ZERO\n019800       DISPLAY 'SQLITE3-STEP' UPON SYSOUT\n019900       CALL SQLITE3A USING\n020000            BY REFERENCE SQLITE3-STEP\n020100            BY VALUE LS-SELECT-STMT\n020200            RETURNING LS-SQL-RC\n020300       END-CALL\n020400       DISPLAY 'LS-SQL-RC=' LS-SQL-RC UPON SYSOUT\n020500       EVALUATE LS-SQL-RC\n020600       WHEN SQLITE-ROW\n020700            MOVE +0 TO LS-COLUMN-NUMBER\n020800            DISPLAY 'SQLITE-ROW' UPON SYSOUT\n020900            CALL SQLITE3A USING\n021000                 BY REFERENCE SQLITE3-COLUMN-INT\n021100                 BY VALUE LS-SELECT-STMT\n021200                 BY VALUE LS-COLUMN-NUMBER\n021300                 RETURNING LS-I\n021400            END-CALL\n021500            MOVE +1 TO LS-COLUMN-NUMBER\n021600            CALL SQLITE3A USING\n021700                 BY REFERENCE SQLITE3-COLUMN-DOUBLE\n021800                 BY REFERENCE LS-DOUBLE-BFP\n021900                 BY VALUE LS-SELECT-STMT\n022000                 BY VALUE LS-COLUMN-NUMBER\n022100            END-CALL\n022200            CALL SQLITE3A USING\n022300                 BY REFERENCE CONVERT-BFP-TO-HFP\n022400                 BY VALUE LS-DOUBLE-BFP\n022500                 BY REFERENCE LS-DOUBLE-HFP\n022600            END-CALL\n022700*           MOVE -1.999 TO LS-DOUBLE-HFP\n022800            DISPLAY 'FETCHED DATA int=' LS-I\n022900                    ' fd=' LS-DOUBLE-HFP\n023000                    UPON SYSOUT\n023100            MOVE +0 TO LS-SQL-RC\n023200       WHEN SQLITE-OK\n023300            DISPLAY 'SQLITE-OK' UPON SYSOUT\n023400            MOVE +0 TO LS-SQL-RC\n023500       WHEN SQLITE-DONE\n023600            DISPLAY 'SQLITE-DONE' UPON SYSOUT\n023700            MOVE +4 TO LS-SQL-RC\n023800       WHEN OTHER\n023900            DISPLAY 'SQLITE-OTHER ' LS-SQL-RC UPON SYSOUT\n024000            MOVE -2 TO LS-SQL-RC\n024100     END-EVALUATE\n024200     END-PERFORM\n024300     CALL SQLITE3A USING\n024400          BY REFERENCE SQLITE3-FINALIZE\n024500          BY VALUE LS-SELECT-STMT\n024600          RETURNING LS-SQL-RC\n024700     END-CALL\n024800D    DISPLAY 'SELECT FINALIZE RC=' LS-SQL-RC UPON SYSOUT\n024900     IF LS-SQL-RC IS NOT EQUAL TO SQLITE-OK AND\n025000        LS-SQL-RC IS NOT EQUAL TO SQLITE-DONE THEN\n025100        DISPLAY 'FINALIZE FAILED. RC='\n025200           LS-SQL-RC UPON SYSOUT\n025300        GOBACK\n025400     END-IF\n025500     .\n025600 SHUTDOWN.\n025700     CALL SQLITE3A USING SQLITE3-SHUTDOWN\n025800          RETURNING LS-SQL-RC\n025900     END-CALL\n026000     GOBACK\n026100     .\n026200 END PROGRAM 'TESTCOB2'.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TESTDB": {"ttr": 75274, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x14(o\\x01\\x14(o\\x19\"$:$:\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-10-13T00:00:00", "modifydate": "2014-10-13T19:22:34", "lines": 9274, "newlines": 9274, "modlines": 0, "user": "JOARMC"}, "mimetype": "application/x-compress", "datatype": "binary", "extension": ".x-compress"}, "TSTPLI1": {"ttr": 79111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x13#_\\x01\\x13#\\x9f\\x10 \\x00\\x05\\x00\\x01\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-08-23T00:00:00", "modifydate": "2013-08-27T10:20:43", "lines": 5, "newlines": 1, "modlines": 0, "user": "JOARMC"}, "text": "%PROCESS CODEPAGE(1147),GOFF,NONAME,SOURCE,INCLUDE;\n TSTPLI1: PROC OPTIONS(MAIN);\n %INCLUDE PLISQLTE;\n RETURN;\n END TSTPLI1;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNPAX": {"ttr": 79113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x19\\x01\\x13#\\x9f\\x01\\x14)\\x1f\\x16Y\\x00\\x17\\x00\\x13\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2013-08-27T00:00:00", "modifydate": "2014-10-18T16:59:19", "lines": 23, "newlines": 19, "modlines": 0, "user": "JOARMC"}, "text": "//UNPAX    JOB ACCOUNT,PROGRAMMER,\n//         CLASS=?,                  <== CHANGE\n//         MSGCLASS=?,               <== CHANGE\n//         NOTIFY=&SYSUID\n//         SET  SBPXEXEC=SYS1.SBPXEXEC <=== CHANGE?\n//UNPAX    EXEC PGM=IKJEFT01,\n//         REGION=0M\n//SYSEXEC  DD   DISP=SHR,DSN=&SBPXEXEC\n//* THE ABOVE CONTAINS THE OSHELL REXX PROGRAM\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n /* change the subdirectory in the two commands\n    below to where you want to put SQLITE */\nMKDIR '/where/to/put/sqlite' MODE(7,5,5)\nOSHELL cd /where/to/put/sqlite; +\n       pax -rzf \"//'this.pds.library(PAXFULL)'\"\n /* Change PAXFULL to PAXRUN if desired */\n /* Run the following, changing as needed, to restore\n    the testcob2.sqlite3 data base file used by the\n    TESTCOB2 example program. */\nOSHELL cd /tmp; pax -rzf \"//this.pds.library(TESTDB)\"\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT923/FILE923.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT923", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}