{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012027000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE435.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE435.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\r'", "DS1TRBAL": "b'\\x0c\\xc0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03)\\x00\\x06\\x03)\\x00\\x0e\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"@FILE435": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x08?\\x00\\x992_\\x081\\x00\\x13\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "1999-11-21T08:31:00", "lines": 19, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 435 is from David North of Los Angeles, California        *   FILE 435\n//*           and is a Fixed Blocked LRECL=80 conversion of         *   FILE 435\n//*           Frank Clarke's REXX execs that are on File 433.       *   FILE 435\n//*           Frank's execs are in VB-255 format.                   *   FILE 435\n//*                                                                 *   FILE 435\n//*           This conversion was performed with David North's      *   FILE 435\n//*           utilities that are on File 155.  After the            *   FILE 435\n//*           conversion, the execs were still in VB-255 format,    *   FILE 435\n//*           but the lines were folded so they fit into an         *   FILE 435\n//*           80-byte width.  I copied the members over to an       *   FILE 435\n//*           actual FB-80 dataset.  (SG - 11/99)                   *   FILE 435\n//*                                                                 *   FILE 435\n//*   From:     \"North, David (USI)\" <david.north@unistudios.com>   *   FILE 435\n//*                                                                 *   FILE 435\n//*             Technical Services Group                            *   FILE 435\n//*             Dave North                                          *   FILE 435\n//*             3429 Downing Ave.                                   *   FILE 435\n//*             Glendale, CA. 91208                                 *   FILE 435\n//*                                                                 *   FILE 435\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x990\\x7f\\x00\\x990\\x7f\\t@\\x00\\x16\\x00\\x0e\\x00\\x00\\xc9\\xe2\\xc3\\xc8\\xf8\\xf9@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-11-03T00:00:00", "modifydate": "1999-11-03T09:40:00", "lines": 22, "newlines": 14, "modlines": 0, "user": "ISCH89"}, "text": " There are thirteen (13) routines in this set:  ALIST, BLOX, DFLTHLQ,\n FCXREF, FIRSTIME, FTINIT, SQRT, LA, SQUASH, TRAPOUT, MEMBERS, TBLOOK,\n and X2B.  Some of these are subroutines (DFLTHLQ, FTINIT, TRAPOUT) and\n are not designed to run stand-alone.  The others (except BLOX) produce\n HELP text if the first parameter is a \"?\"; BLOX shows its HELP text if\n -no- parameters are passed.\n\n  ALIST         produces a scrollable list of the datasets allocated to\n                the specified DDNames.  {ALIST ?}\n  BLOX          creates 8x7 block letters from text you specify\n  DFLTHLQ       subrtn\n  FCXREF        does a member-crossref by DDName {FCXREF ?}\n  FIRSTIME      controls once-pre-period executions {FIRSTIME ?}\n  FTINIT        subrtn; used by FIRSTIME\n  LA            LISTA to the queue {LA ?}\n  MEMBERS       memberlist to the queue {MEMBERS ?}\n  SQRT          Square root\n  SQUASH        compose IEBCOPY JCL for the current dataset {SQUASH ?}\n  TBLOOK        examine any ISPF table {TBLOOK ?}\n  TRAPOUT       subrtn; save TRACE output into a Sysouttrap\n  X2B           hex-to-binary; used by BLOX\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALIST": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x0c\\x00\\x00\\x00\\x93\\x12?\\x00\\x99(\\x8f\\x143\\x01e\\x009\\x00\\x00\\xc9\\xe2\\xc3\\xc8\\xf8\\xf9@@@@'", "ispf": {"version": "02.12", "flags": 0, "createdate": "1993-05-03T00:00:00", "modifydate": "1999-10-15T14:33:00", "lines": 357, "newlines": 57, "modlines": 0, "user": "ISCH89"}, "text": "/* REXX    ALIST      Display the user's current allocations\n\n                    Written by Frank Clarke, Oldsmar, FL\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n   |                                                                 |\n   |          WARNING: EMBEDDED COMPONENTS.                          |\n   |                                                                 |\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n*/\naddress TSO                            /* default address            */\ntv = \"\"\nsignal on syntax\nparse source sys_id how_invokt exec_name DD_nm DS_nm as_invokt cmd_env,\n                          addr_spc usr_tokn\nif ds_nm <> \"?\" then do                /* explicit invocation        */\n   say exec_name \"cannot be invoked explicitly.\"\n   say \" \"\n   say \"   It must be part of your SYSPROC or SYSEXEC allocation,\"\n   say \"   and invoked implicitly because it requires ISPF facilities\"\n   say \"   and these are incompatible with a command library which is\"\n   say \"   not part of your defined environment.\"\n   say \" \"\n   exit\n   end\nif Sysvar(\"sysispf\") = \"NOT ACTIVE\" then do\n   arg line\n   line = line \"((  RESTARTED\"         /* tell the next invocation   */\n   \"ISPSTART CMD(\"exec_name line\")\"    /* Invoke ISPF if nec.    */\n   exit                                /* ...and restart it          */\n   end\n\narg target \"((\" opts\nopts = Strip( opts , \"T\" , \")\" )       /* clip trailing paren        */\nif Word(target,1) = \"?\" then call HELP /* ...and don't come back     */\n\nparse var opts \"TRACE\" tv .\nparse value tv \"O\"  with tv .\nrc = Trace(tv)\naddress ISPEXEC                        /* default address for ISPF   */\n\"CONTROL ERRORS RETURN\"\n\ncall A_INIT                            /*                           -*/\ncall B_GET_ALLOCATIONS                 /*                           -*/\ncall C_LOAD_TABLE                      /*                           -*/\ncall D_TABLE_OPS                       /*                           -*/\ncall E_REDO_ALLOC                      /*                           -*/\n\nexit                                   /*@ ALIST                     */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   address TSO\n\n   restarted = WordPos(\"RESTARTED\",opts)>0/* called from READY-mode ? */\n   parse value \"0       ISR00000    YES\"   with,\n               got_one   zerrhm     zerralrm     zerrsm zerrlm\n   t_nam = \"T\"Right(Time(s),5,0)       /* T32855 maybe              #*/\n   tk_globalvars = \" \"\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nB_GET_ALLOCATIONS:                     /*@                           */\n   address TSO\n\n   tgt_list = \"\"\n\n   do ii = 1 to Words(target)          /* for every target spec      */\n      this_tgt = Word(target,ii)\n      if this_tgt = \"ISPF\" then,       /* expand ISPF                */\n         tgt_list = tgt_list \"ISPPLIB ISPMLIB ISPSLIB ISPTLIB\",\n                             \"ISPTABL ISPLLIB ISPPROF\"\n      else,\n      if this_tgt = \"CMDS\" |,          /* expand CMDS                */\n         this_tgt = \"COMMANDS\" then,\n         tgt_list = tgt_list \"SYSPROC SYSEXEC\"\n      else,                            /* just add to the list       */\n         tgt_list = tgt_list this_tgt\n   end                                 /* ii                         */\n\n   ln.=\"\"                              /* setup array                */\n   rc = Outtrap(\"ln.\")                 /* open trap                  */\n   \"LISTA ST\"\n   rc = Outtrap(\"off\")                 /* close trap                 */\n\n   dds_to_realloc = \"\"\n   ds_stack.=\"\"\n   redo_alloc = \"0\"\n\nreturn                                 /*@ B_GET_ALLOCATIONS         */\n/*\n.  ----------------------------------------------------------------- */\nC_LOAD_TABLE:                          /*@                           */\n   address ISPEXEC\n\n   \"TBCREATE \" t_nam \" NAMES(DDNAME DSNAME DISP) NOWRITE\"\n                                          /* Build DDName stack      */\n   do jj = 1 to ln.0,                  /* for each trapped line      */\n      until Substr(ln.jj,1,1) <> \"-\"   /* ...skip the header         */\n   end                                 /* jj                         */\n\n   do ii = jj to ln.0                  /* for each trapped line      */\n      if Substr(ln.ii,1,1) = ' ' then do /* it's a DDname            */\n         if Substr(ln.ii,3,1) <> \" \" then do\n            ddname = Word(ln.ii,1)     /* DDName                     */\n            disp = Word(ln.ii,2)       /*  ...and DISP               */\n            end\n         if tgt_list = \"\" |,           /* (all DDNames)              */\n            WordPos(ddname,tgt_list) > 0 then do\n            \"TBADD\" t_nam              /* add to table              #*/\n            got_one = \"1\"\n            ds_stack.ddname = ds_stack.ddname dsname\n            end\n         end                           /* DDname                     */\n      else dsname = Word(ln.ii,1)      /* it's a DSName              */\n   end                                 /* ii                         */\n\nreturn                                 /*@ C_LOAD_TABLE              */\n/*\n.  ----------------------------------------------------------------- */\nD_TABLE_OPS:                           /*@                           */\n   address ISPEXEC\n\n   if got_one then do\n      call DEIMBED                     /* expose the panel          -*/\n      $ddn = $ddn.PLIB\n      \"LIBDEF ISPPLIB LIBRARY ID(\"$ddn\") STACK\"\n\n      \"TBTOP\" t_nam                    /*                            */\n      \"CONTROL DISPLAY SAVE\"           /* In case of re-invocation   */\n      do forever\n         \"TBDISPL\" t_nam \"PANEL(FCALLOC) CURSOR(ACTION) AUTOSEL(NO)\"\n         if rc > 4 then leave\n         do ztdsels\n            curact = Translate(action)\n            select\n               when curact = \"E\" then do /* Edit                     */\n                  \"CONTROL DISPLAY SAVE\" /* in case we Edit or Browse */\n                  \"EDIT DATASET('\"dsname\"')\"\n                  save_rc = rc\n                  \"CONTROL DISPLAY RESTORE\" /* return from Edit or Browse */\n                  if save_rc > 0 then,\n                     \"SETMSG MSG(ISRZ002)\"\n                  end                  /* Edit                       */\n               when curact = \"V\" then do /* View                     */\n                  \"CONTROL DISPLAY SAVE\" /* in case we Edit or Browse */\n                  \"VIEW DATASET('\"dsname\"') CONFIRM(NO)\"\n                  save_rc = rc\n                  \"CONTROL DISPLAY RESTORE\" /* return from Edit or Browse */\n                  if save_rc > 0 then,\n                     \"SETMSG MSG(ISRZ002)\"\n                  end                  /* View                       */\n               when curact = \"B\" then do /* Browse                   */\n                  \"CONTROL DISPLAY SAVE\" /* in case we Edit or Browse */\n                  \"BROWSE DATASET('\"dsname\"')\"\n                  save_rc = rc\n                  \"CONTROL DISPLAY RESTORE\" /* return from Edit or Browse */\n                  if save_rc > 0 then,\n                     \"SETMSG MSG(ISRZ002)\"\n                  end                  /* Browse                     */\n               when curact = \"C\" then do /* CLONE                    */\n                  \"CONTROL DISPLAY SAVE\"\n                  address TSO \"CLONE '\"dsname\"' ISPF\"\n                  if rc <> 0 then do\n                     ZERRSM = \"RC =\"rc\n                     ZERRLM = \"CLONE ended abnormally\"\n                     address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n                     end\n                  \"CONTROL DISPLAY RESTORE\"\n                  end                  /* CLONE                      */\n               when curact = \"F\" then do /* Free                     */\n                  redo_alloc = \"1\"\n                  if WordPos(ddname,dds_to_realloc) = 0 then,/* new DDName */\n                     dds_to_realloc = dds_to_realloc ddname\n                  dsid = WordPos(dsname,ds_stack.ddname) /* in the list ? */\n                  if dsid > 0 then,\n                     ds_stack.ddname = DelWord(ds_stack.ddname,dsid,1)\n                  end                  /* Free                       */\n               when curact = \"X\" then do /* UnDisplay                */\n                  \"TBDELETE\" t_nam     /* drop this row              */\n                  end                  /* UnDisplay                  */\n               otherwise nop\n            end                        /* Select                     */\n            if ztdsels = 1 then,       /* never do the last one      */\n               ztdsels = 0\n            else \"TBDISPL\" t_nam       /* next row                  #*/\n         end                           /* ztdsels                    */\n         action = \"\"                   /* clear for re-display       */\n      end                              /* forever                    */\n      \"CONTROL DISPLAY RESTORE\"        /* In case of re-invocation   */\n\n      \"LIBDEF ISPPLIB\"\n      \"TBCLOSE\" t_nam\n      address TSO \"FREE FI(\"$ddn\")\"\n      end                              /* got_one                    */\n   else do\n      \"TBEND\" t_nam                    /*                           #*/\n      ZERRSM = \"No datasets\"           /* short message              */\n      ZERRLM = \"No datasets were allocated as specified/implied.\"\n      \"SETMSG MSG(ISRZ002)\"\n      end\n\nreturn                                 /*@ D_TABLE_OPS               */\n/*\n.  ----------------------------------------------------------------- */\nE_REDO_ALLOC:                          /*@                           */\n   address TSO                         /* ready for some TSO work    */\n\n   if redo_alloc then do\n      do fidx = 1 to Words(dds_to_realloc)/* for each DDName         */\n         ddname = Word(dds_to_realloc,fidx) /* grab it */\n         alloc_list = \"\"               /* initialize                 */\n\n         if Words(ds_stack.ddname) > 0 then,\n         do didx = 1 to Words(ds_stack.ddname) /* for each DSName    */\n            alloc_list = alloc_list \"'\"Word(ds_stack.ddname,didx)\"'\"\n         end\n\n         if alloc_list <> \"\" then,     /*  re-ALLOC                  */\n            \"ALLOC FI(\"ddname\") DA(\"alloc_list\") SHR REU\"\n         else \"FREE FI(\"ddname\")\"\n      end                              /* fidx                       */\n   end                                 /* redo_alloc                 */\n\nreturn                                 /*@ E_REDO_ALLOC              */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO \"CLEAR\"\nsay \"                                                                 \"\nsay \"  ALIST         displays a scrollable list of allocated datasets.\"\nsay \"                The list may be limited to specific DDNames or   \"\nsay \"                specific sets of DDNames.                        \"\nsay \"                                                                 \"\nsay \"  Syntax:   ALIST     <ddname-list> <CMDS> <ISPF>                \"\nsay \"                      < ? >                                      \"\nsay \"                                                                 \"\nsay \"            <ddname-list> is a blank-delimited list of filenames \"\nsay \"                      to be displayed.                           \"\nsay \"            <CMDS> is equivalent to 'SYSPROC SYSEXEC'            \"\nsay \"            <ISPF> is equivalent to 'ISPPLIB ISPMLIB ISPSLIB     \"\nsay \"                      ISPTLIB ISPLLIB ISPPROF ISPTABL'           \"\nsay \"                                                                 \"\nsay \"   ALIST may be invoked from READY-mode.                         \"\nsay \"                                                                 \"\nexit                                   /*@ HELP                      */\n\n/* ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = \"REXX error\" rc \"in line\" sigl\":\" errortext(rc)\n   say errormsg\n   say sourceline(sigl)\n   trace \"?r\"\n   nop\nexit                                   /*@ SYNTAX                    */\n/*\n   Parse out the embedded components at the back of the source code.\n.  ----------------------------------------------------------------- */\nDEIMBED: Procedure expose,             /*@                           */\n   (tk_globalvars)  ddnlist  $ddn.  daid.\n\n   address TSO\n\n   fb80po.0  = \"NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)\",\n                   \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   parse value \"\"   with  ddnlist $ddn.  daid.\n\n   lastln   = sourceline()\n   currln   = lastln                   /*                            */\n   if Left(sourceline(currln),2) <> \"*/\" then return\n\n   currln = currln - 1                 /* previous line              */\n   \"NEWSTACK\"\n   do while sourceline(currln) <> \"/*\"\n      text = sourceline(currln)        /* save with a short name !   */\n      if Left(text,3) = \")))\" then do  /* package the queue          */\n         parse var text \")))\" ddn mbr .   /* PLIB PANL001  maybe     */\n         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */\n            ddnlist = ddnlist ddn      /* keep track                 */\n            $ddn = ddn || Random(999)\n            $ddn.ddn = $ddn\n            \"ALLOC FI(\"$ddn\")\" fb80po.0\n            address ISPEXEC \"LMINIT DATAID(DAID) DDNAME(\"$ddn\")\"\n            daid.ddn = daid\n            end\n         daid = daid.ddn\n         address ISPEXEC \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n         do queued()\n            parse pull line\n            address ISPEXEC \"LMPUT DATAID(\"daid\") MODE(INVAR)\",\n                            \"DATALOC(LINE) DATALEN(80)\"\n         end\n         address ISPEXEC \"LMMADD DATAID(\"daid\") MEMBER(\"mbr\")\"\n         address ISPEXEC \"LMCLOSE DATAID(\"daid\")\"\n         end                           /* package the queue          */\n      else push text                   /* onto the top of the stack  */\n      currln = currln - 1              /* previous line              */\n   end                                 /* while                      */\n   \"DELSTACK\"\n\nreturn                                 /*@ DEIMBED                   */\n/*\n)))PLIB  FCALLOC\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH)\n  ! TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)\n)BODY EXPAND(||)\n%|-| Current Allocations |-|\n%COMMAND ===>_ZCMD\n                                                              %SCROLL ===>_AMT +\n+\n+    DDName     DSName                                             Disp\n)MODEL\n_Z+ !DDNAME  + !DSNAME                                          + !DISP        +\n)INIT\n  .ZVARS = '(ACTION)'\n  .HELP  = FCALLOCH\n)REINIT\n  IF (&MSG = ' ')\n     &ACTION = ' '\n     REFRESH (&ACTION)\n)END\n)))PLIB  FCALLOCH\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH)  SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)   SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH)\n  ! TYPE(OUTPUT) INTENS(HIGH)  SKIP(ON)\n  @ TYPE(OUTPUT) INTENS(LOW)   SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%TUTORIAL \u00a6-\u00a6 Current Allocations \u00a6-\u00a6 TUTORIAL\n%Next Selection ===>_ZCMD\n\n+\n    Panel FCALLOC shows the current allocations for the DDNames you\n    specified (or ALL DDNames).\n\n    For each shown dataset you may select among several actions:\n\n        %B+-%BROWSE  +Browse the selected dataset.\n\n        %E+-%EDIT    +Edit the selected dataset.\n\n        %V+-%VIEW    +View the selected dataset.\n\n        %C+-%CLONE   +You may make a copy (either filled or empty) of the\n                      selected dataset.\n\n        %F+-%FREE    +This is effective only for DDNames which are not under\n                      the control of ISPF since those files are necessarily\n                      OPEN while ISPF is active.\n\n)PROC\n)END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BLOX": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x00\\x00\\x924?\\x00\\x980?\\tA\\x00\\xd6\\x00j\\x00\\x00\\xc6\\xf9\\xc3\\xd3\\xc1\\xd9\\xd2@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "1992-12-08T00:00:00", "modifydate": "1998-10-30T09:41:00", "lines": 214, "newlines": 106, "modlines": 0, "user": "F9CLARK"}, "text": "/* REXX    BLOX   create block letters from an input string.\n                for each of eight lines\n                   for each letter in string\n                      get pattern for letter\n                      get sub-pattern for this line\n                      build slug\n                      attach to line\n                   write the line\n\n                Written by Frank Clarke, Oldsmar, FL\n\n                Components:\n                   REXX:  X2B   convert hexpair-to-binary\n*/\naddress TSO\nsignal on syntax\n\ntv=\"\" ; odsn=\"\"                        /* ensure values              */\nsav = \"\"\nparse upper arg instr \"((\" parms       /* get parameters             */\nif instr=\"\" & parms=\"\" then call HELP  /* no parms at all            */\nparms = Strip(parms,T,\")\")             /* clip trailing paren        */\n\nparse value  KEYWD(\"TRACE\")  \"O\"  with  tv  .\nodsn       = KEYWD(\"OUTPUT\")           /* output to file ?           */\n\nprompt     = \\SWITCH(\"NOPROMPT\")\ndiagnose   = SWITCH(\"DIAGNOSE\")\ninstr      = Strip(instr)              /* clean the input            */\nrc = Trace(tv)\n\nif odsn <> \"\" then do                  /* was a value                */\n   \"ALLOC FI(BLOXDD) DA(\"odsn\") SHR REU\"\n   if rc > 0 then do                   /* doesn't exist ?            */\n      \"ALLOC FI(BLOXDD) DA(\"odsn\") NEW REU SPACE(1) TRACKS\",\n           \" RECFM(V B) LRECL(121) BLKSIZE(1210) UNIT(SYSDA)\"\n      if rc > 0 then do                /* ...and couldn't create it! */\n         say \"Allocation failed for \"odsn\".\"\n         exit\n         end                           /* alloc NEW                  */\n      end                              /* alloc SHR                  */\n   end                                 /* alloc dataset              */\nelse \"ALLOC FI(BLOXDD) DA(*) SHR REU\"  /* to the terminal            */\n\ncall SET_PATN                          /*                           -*/\nif tv = \"O\" then \"CLEAR\"               /* clear screen               */\n\nif instr = \"\" then do                  /* no input ?                 */\n   say \":\"                             /* initial prompt             */\n   \"NEWSTACK\"\n   pull instr\n   \"DELSTACK\"\n   end\n\ndo forever\n   do while instr <> \"\"\n      if length(instr) > 8 then do     /* too long                   */\n         parse var instr instr 9 sav   /* save the excess            */\n         end\n\n      do i = 1 to 7                    /* for 7 lines                */\n         outline=\"\"                    /* clear it                   */\n         do j = 1 to Length(instr)     /* for each letter            */\n            ltr = Substr(instr,j,1)    /* isolate it                 */\n            ltrpos = Pos(ltr,choices)  /* where in the array ?       */\n            if ltrpos = 0 then ltrpos = 47 /* set to blank           */\n            byte = Substr(patn.ltrpos,i*2-1,2)\n            if diagnose then say \"X2B(\"byte\")\"\n            slug = X2B(byte)           /* character-to-binary        */\n            slug = Translate(slug,\" \",\"0\") /* off -> blank           */\n            slug = Translate(slug,ltr,\"1\") /* on -> letter           */\n            outline = outline slug     /* splice to the line         */\n         end                           /* j for length(instr)        */\n         queue outline                 /* into the queue             */\n      end                              /* i for 7 lines              */\n      instr = \"\"\n      queue \" \"                        /* blank line                 */\n      queue \" \"                        /* blank line                 */\n\n      rc = Trace(\"O\")\n      rc = Trace(tv)\n      if sav <> \"\" then do             /* was there excess ?         */\n         instr = sav                   /* restore it                 */\n         sav = \"\"                      /* indicate \"no excess\"       */\n         end\n   end                                 /* while instr filled         */\n\n   if prompt then,\n   if instr = \"\" then do               /* no more input ?            */\n      say \":\"                          /* prompt for more            */\n      \"NEWSTACK\"\n      pull instr\n      \"DELSTACK\"\n      end\n   if instr = \"\" then leave            /* prompt was refused         */\nend                                    /* forever                    */\n\nrc = Trace(\"O\")\nrc = Trace(tv)\n\"EXECIO\" queued() \"DISKW BLOXDD (FINIS\"  /* flush to output          */\n\nexit\n/*\n.  ----------------------------------------------------------------- */\nSET_PATN:                              /*@                           */\n   patn.=\"\"                               /* storage for patterns       */\n   patn.1  = \"081422417F4141\"   /*  A   */\n   patn.2  = \"7E41417E41417E\"   /*  B   */\n   patn.3  = \"3E41404040413E\"   /*  C   */\n   patn.4  = \"7C42414141427C\"   /*  D   */\n   patn.5  = \"7F40407C40407F\"   /*  E   */\n   patn.6  = \"7F40407C404040\"   /*  F   */\n   patn.7  = \"7E41404047417E\"   /*  G   */\n   patn.8  = \"4141417F414141\"   /*  H   */\n   patn.9  = \"1C08080808081C\"   /*  I   */\n   patn.10 = \"7F02020202423C\"   /*  J   */\n   patn.11 = \"41424478444241\"   /*  K   */\n   patn.12 = \"4040404040407F\"   /*  L   */\n   patn.13 = \"41635549414141\"   /*  M   */\n   patn.14 = \"41615149454341\"   /*  N   */\n   patn.15 = \"3E41414141413E\"   /*  O   */\n   patn.16 = \"7E41417E404040\"   /*  P   */\n   patn.17 = \"3E41414145423D\"   /*  Q   */\n   patn.18 = \"7E41417E444241\"   /*  R   */\n   patn.19 = \"3E41403E01413E\"   /*  S   */\n   patn.20 = \"7F080808080808\"   /*  T   */\n   patn.21 = \"4141414141413E\"   /*  U   */\n   patn.22 = \"41414141221408\"   /*  V   */\n   patn.23 = \"41414141494936\"   /*  W   */\n   patn.24 = \"41221408142241\"   /*  X   */\n   patn.25 = \"41221408080808\"   /*  Y   */\n   patn.26 = \"7F02040810207F\"   /*  Z   */\n   patn.27 = \"3E43454951613E\"   /*  0   */\n   patn.28 = \"0818080808083E\"   /*  1   */\n   patn.29 = \"3E41020408103E\"   /*  2   */\n   patn.30 = \"7F020C0201413E\"   /*  3   */\n   patn.31 = \"2040487F080808\"   /*  4   */\n   patn.32 = \"7F40407E01017E\"   /*  5   */\n   patn.33 = \"0408103E41413E\"   /*  6   */\n   patn.34 = \"7F020408080808\"   /*  7   */\n   patn.35 = \"3E41413E41413E\"   /*  8   */\n   patn.36 = \"3E41413E040810\"   /*  9   */\n   patn.37 = \"22227F227F2222\"   /*  #   */\n   patn.38 = \"143E403E013E14\"   /*  $   */\n   patn.39 = \"21522408122542\"   /*  %   */\n   patn.40 = \"0018241825423D\"   /*  &   */\n   patn.41 = \"0022143E142200\"   /*  *   */\n   patn.42 = \"04081010100804\"   /*  (   */\n   patn.43 = \"10080404040810\"   /*  )   */\n   patn.44 = \"0000003E000000\"   /*  -   */\n   patn.45 = \"00181800181800\"   /*  :   */\n   patn.46 = \"00000000000000\"   /*blank */\n   patn.47 = \"00181800181808\"   /*  ;   */\n   patn.48 = \"3E410104080008\"   /*  ?   */\n   choices =\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#$%&*()-: ;?\"\nreturn                                 /*@ SET_PATN                  */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\n\"CLEAR\"                                /* clear screen               */\nsay \"                                                                 \"\nsay \" BLOX is a REXX routine which will build 8x7 block letters       \"\nsay \"   from text you specify.                                        \"\nsay \"                                                                 \"\nsay \" BLOX can handle strings to length=8 and will write either to    \"\nsay \"   the screen-face or to a file you name.  Syntax for BLOX is:   \"\nsay \"      BLOX <string>  <options>                                   \"\nsay \"                                                                 \"\nsay \"      <options>:  OUTPUT output-dsname                           \"\nsay \"                                                                 \"\nexit                                   /*@ HELP                      */\n\n/*-------------------------------------------------------------------*/\nKEYWD: Procedure expose,               /*@                           */\n       kw parms\narg kw .\nif Wordpos(kw,parms) = 0 then,\n   kw_val = \"\"\nelse,\nif Wordpos(kw,parms) = 1 then,\n   kwa = kw\" \"\nelse kwa = \" \"kw\" \"\nparse var parms . value(kwa)  kw_val .\nif kw_val <> \"\" then parms = Delword(parms,Wordpos(value(kw),parms),2)\nreturn kw_val                          /*@ KEYWD                     */\n\n/*-------------------------------------------------------------------*/\nSWITCH:                                /*@                           */\narg kw .\nsw_val  = Wordpos(value(kw),parms) > 0\nif sw_val  then parms = Delword(parms,Wordpos(value(kw),parms),1)\nreturn sw_val                          /*@ SWITCH                    */\n\n/*-------------------------------------------------------------------*/\nSYNTAX:                                /*@                           */\n   errormsg = \"REXX error\" rc \"in line\" sigl\":\" errortext(rc)\n   say errormsg\n   say sourceline(sigl)\n   Trace \"?R\"\n   nop\nexit                                   /*@ SYNTAX                    */\n\n/*    Work area for creating new patterns:                           */\n\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFLTHLQ": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x18\\x9f\\x00\\x990\\x7f\\t\\x19\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xe2\\xc3\\xc8\\xf8\\xf9@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-07-08T00:00:00", "modifydate": "1999-11-03T09:19:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "ISCH89"}, "text": "/* REXX    DFLTHLQ    Provide default high level qualifier and hlq for\n                      each site.  Primarly for use with REXXSKEL.\n*/\naddress TSO\n\nline = \"  \"                            /* dflt-hlq site hlq ....  */\n\nif sysvar(\"SYSNEST\") = \"YES\" then\n   push line\nelse\n   say  line\n\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FCXREF": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x19\\x00\\x00\\x00\\x940o\\x00\\x99)_\\x16\\x17\\x03\\xe9\\x027\\x00\\x00\\xc9\\xe2\\xc3\\xc8\\xf8\\xf9@@@@'", "ispf": {"version": "02.25", "flags": 0, "createdate": "1994-11-02T00:00:00", "modifydate": "1999-10-22T16:17:00", "lines": 1001, "newlines": 567, "modlines": 0, "user": "ISCH89"}, "text": "/* REXX    FCXREF     produces a side-by-side list  of member names\n                      in a set of concatenated libraries.\n           |**-***-***-***-***-***-***-***-***-***-***-***-***-**|\n           |                                                     |\n           |  WARNING: EMBEDDED COMPONENTS.                      |\n           |              See text following TOOLKIT_INIT        |\n           |                                                     |\n           |**-***-***-***-***-***-***-***-***-***-***-***-***-**|\n\n            Each library is LISTD'd to develop a list of members.\n            This list is then annotated with an indicator of the\n            source dataset, and the whole is sorted.  The resultant\n            list is processed to provide one report line per member\n            either with or without headers.  Three report formats\n            are available:\n              (a) with the member name positioned on the line\n                  beneath the header for its origin dataset;\n              (b) with member statistics positioned on the line\n                  beneath the header for its origin dataset (STATS);\n              (c) with the dataset number (only) appearing on the\n                  line in a standard position (COMPACT).\n\n            Because it makes each column so wide, STATS is practical\n            only when the number of datasets being cross-referenced\n            is fewer than 8.\n\n            In rare instances, a large number of datasets allocated to\n            a DDName may make the standard listing format impractical.\n            Selecting COMPACT in this case provides a much narrower\n            report style in which page 1 is devoted to merely listing\n            the dataset names for which the list was done.  Subsequent\n            pages list the member-name at the left margin, and next to\n            it (a) numeric indicator(s) of the source dataset(s) in\n            which it appears.  In this format, a count of how many\n            datasets contain each member is also provided.\n\n           Written by Frank Clarke\n\n     Impact Analysis\n.    SYSPROC   DFLTHLQ\n.    SYSPROC   LA\n.    SYSPROC   MEMBERS\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     19950504 fxc made output dataset FBA.\n     19960514 fxc upgrade to REXXSKEL;\n     19980302 fxc upgrade from v.960506 to v.19971030; DECOMM;\n                  RXSKLY2K;\n     19990908 fxc use MEMBERS to develop alias lists; drop E_ and F_;\n                  enable call-from-READY;\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.19971030      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall DEIMBED                           /*                           -*/\ncall A_INIT                            /*                           -*/\n\ndo forever\nif ddn <> \"\" then do\n   \"NEWSTACK\"\n   \"LA\" ddn \"((STACK\"                  /* call LA, return stack      */\n   pull dsnstr                         /* retrieve stack             */\n   \"DELSTACK\"\n   if monitor then say,\n      \"LA:\" dsnstr\n   dsn. = \"\"                           /* set up array               */\n   dsn.0 = words(dsnstr)               /* how many dsnames ?         */\n   do ii = 1 to dsn.0\n      dsn.ii = \"'\"Word(dsnstr,ii)\"'\"\n   end\n   call B_STEM_PNL                     /* load to screen variables  -*/\n   end\n\np_name = exec_name\".PLIB\"              /* de-imbedded panels         */\nif sw.0interactive then do\n   if sw.0do_hdr then hdr = \"Y\"\n             else hdr = \"N\"\n   ddn = \"\"\n   address ISPEXEC \"LIBDEF ISPPLIB DATASET ID(\"p_name\") STACK\"\n   address ISPEXEC \"DISPLAY PANEL(GETLIBS)\"\n   save_rc = rc\n   address ISPEXEC \"LIBDEF ISPPLIB\"\n   if save_rc = 8 then exit            /* user pushed PF3            */\n   if ddn <> \"\" then iterate           /* re-do the loop             */\n   sw.0do_hdr = hdr = \"Y\"\n   call C_PNL_STEM                     /* convert panel variables   -*/\n   end\n   leave                               /* don't re-do the loop       */\nend                                    /* forever                    */\nrc = Outtrap(\"zz.\")\naddress TSO \"DELETE\" exec_name\".PLIB\"\nrc = Outtrap(\"OFF\")\nrc = trace(\"O\"); rc = trace(tv)\n\n                     /* no line-mode output when BROWSE is available */\nif outdsn = \"\" & sw.inispf then,\n   parse value 1                 exec_name\".$TMP\" with,\n               sw.0interactive   outdsn  .\n\n   /* COMPACT display puts the membername and count on each line and\n      adds markers by dataset; STATS/normal show either member-stats\n      or the member-name in each column. */\nif outdsn <> \"\" then do\n   outlen = (dsn.0 * (collen+1))  + margin\n\n   outlen = Max(outlen,60)             /* never shorter than 60      */\n   orig_msg = Msg(\"off\")\n   \"DELETE\" outdsn \"SCR PURGE\"\n   \"ALLOC FI(OUT) DA(\"outdsn\") NEW CATALOG UNIT(SYSDA) SPACE(20 20)\",\n       \" TRACKS RECFM(F B A) LRECL(\"outlen\") BLKSIZE(0) REU\"\n   msg_stat = Msg(orig_msg)\n   outop = \"QUEUE\"\n   end\nelse outop = \"SAY\"\n\ncall D_LOAD_SORTIN                     /*                           -*/\n\nsay \"Starting sort,\" midx \"items.\"\n\nrc = Outtrap(\"sort.\")\n\"ALLOC FI(SORTOUT) DA(TEMPSRT) SHR REU\"\n\"ALLOC FI(SYSOUT)  DUMMY  REU \"\n\n\"ALLOC FI(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n       \" LRECL(80) BLKSIZE(800) RECFM(F B) REU\"\nqueue \" SORT  FIELDS=(1,12,CH,A)\"\n\"EXECIO\" queued() \"DISKW SYSIN (FINIS\"\n\nsortprm =\"MSG=CC\"                      /* suppress messages          */\naddress LINKMVS \"SORT   sortprm\"\n\"EXECIO    *      DISKR SORTOUT (STEM MLIST. FINIS\"\n\n\"FREE  FI(SORTIN SORTOUT SYSOUT)\"\n\"ALLOC FI(SYSIN)   DA(*) SHR REU\"\n\"DELETE TEMPSRT SCR PURGE\"\nrc = Outtrap(\"off\")\n\nsay \"Finished sort,\" mlist.0 \"items.\"\n\nif sw.0compact then call HC_SHORTHDR; else, /*                      -*/\nif sw.0stats then call HS_STATHDR      /*                           -*/\nelse call HA_STANDARD_HDR              /* gen report header lines   -*/\n\nif lpp=\"\" then,\nif outdsn=\"\" then pagelim = 22         /* 22 for term, 60 for print  */\nelse if \\sw.0do_hdr then pagelim = 0\nelse pagelim = 60\n\ncall Q_COMPOSE                         /* finish report             -*/\n\nif outdsn <> \"\" then do                /* output to dataset          */\n   \"EXECIO\" queued() \"DISKW OUT (FINIS\"/* pump entire queue          */\n   end\n\"FREE FI(OUT)\"\n\nif sw.0interactive & outdsn <> \"\" then,\n   address ISPEXEC \"BROWSE DATASET(\"outdsn\")\"\n\nexit                                   /*@ FCXREF                    */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if parms=\"\" then call HELP          /*                           -*/\n   ddn=\"\"                              /* guarantee values           */\n\n   if SWITCH(\"ISPF\") then,\n   if \\sw.inispf then do\n      \"ISPSTART CMD(\"exec_name argline\")\" /* Invoke ISPF             */\n      exit\n      end\n   else sw.0interactive = \"1\"          /* ISPF was active            */\n   else sw.0interactive = \"0\"          /* ISPF was not requested     */\n\n   sw.0dup_only  = SWITCH(\"CONFLICTS\")\n   sw.0compact   = SWITCH(\"COMPACT\")\n   sw.0stats     = SWITCH(\"STATS\")\n   if sw.0stats & sw.0compact then do\n      helpmsg = \"STATS and COMPACT are mutually exclusive\"\n      call HELP                        /*                           -*/\n      end\n   else if sw.0stats then,             /* stats-display              */\n           parse value \"16 11\" with collen margin .\n   else if sw.0compact then,           /* presence-display           */\n           parse value \" 2 17\" with collen margin .\n   else parse value \"10  2\" with collen margin .  /* name-display    */\n\n   ddn      = KEYWD(\"DDNAME\")          /* Input via DDName ?         */\n   outdsn   = KEYWD(\"OUTPUT\")          /* Output to a dataset ?      */\n   lpp      = KEYWD(\"LPP\")             /* lines-per-page             */\n   sw.0do_hdr = \\SWITCH(\"NOHDR\")       /* Headers or not ?           */\n   kill_switch = \"THE FOLLOWING ALIAS NAMES EXIST\"\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  Convert variables of the form: dsn.1, dsn.2, ..., dsn.n ;\n.  to variables of the form: dsn1, dsn2, ..., dsnn.\n.  ----------------------------------------------------------------- */\nB_STEM_PNL:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   list = dsn.1 dsn.2 dsn.3 dsn.4 dsn.5 dsn.6 dsn.7,\n          dsn.8 dsn.9 dsn.10 dsn.11 dsn.12\n   if list = \"\" then exit\n   parse var list xrdsn1 xrdsn2 xrdsn3 xrdsn4 xrdsn5 xrdsn6,\n                  xrdsn7 xrdsn8 xrdsn9 xrdsn10 xrdsn11 xrdsn12 .\n\nreturn                                 /*@ B_STEM_PNL                */\n/*\n.  Convert variables of the form: dsn1, dsn2, ..., dsnn ;\n.  to variables of the form: dsn.1, dsn.2, ..., dsn.n.\n.  ----------------------------------------------------------------- */\nC_PNL_STEM:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   dsnstr = xrdsn1 xrdsn2 xrdsn3 xrdsn4 xrdsn5 xrdsn6 xrdsn7,\n            xrdsn8 xrdsn9 xrdsn10 xrdsn11 xrdsn12\n   if dsnstr = \"\" then exit            /* no DSNames                 */\n   dsn.0 = Words(dsnstr)\n   do i = 1 to dsn.0                   /* for each list item         */\n      dsn.i = Word(dsnstr,i)           /* isolate                    */\n      if Substr(dsn.i,1,1)  <>  \"'\" then,/* quoted ?                 */\n         dsn.i = \"'\"Userid()\".\"dsn.i\"'\" /* no, attach userid.        */\n   end\n   dsnstr = \"\"                         /* clear work area            */\n   do i = 1 to dsn.0\n      dsnstr = dsnstr dsn.i            /* splice dsn to dsnstr       */\n   end\n   dsnstr = Translate(dsnstr,\" \",\"'\" ) /* translate all quotes away  */\n\nreturn                                 /*@ C_PNL_STEM                */\n/*\n.  ----------------------------------------------------------------- */\nD_LOAD_SORTIN:                         /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value \"0\" with midx  lvls.           /* set up array        */\n\n   \"NEWSTACK\"                          /* isolate prior queues       */\n   do dsix = 1 to dsn.0                /* for all dsnames            */\n      if Sysdsn(dsn.dsix) <> \"OK\" then,\n         iterate                       /* skip it, get next dsn      */\n      \"NEWSTACK\"\n      \"MEMBERS\" dsn.dsix \"((STACK LINE ALIAS\"\n      pull mbrlist\n      \"DELSTACK\"\n\n      lvls.dsix = Translate(Word(dsnstr,dsix),\" \",\".\")   /* zap dots */\n\n      do Words(mbrlist)                /* each member/alias          */\n         parse var mbrlist   mbr  mbrlist      /* isolate mbrname    */\n         if Right(mbr,3) = \"(*)\" then do   /* it's an ALIAS          */\n            parse var mbr  mbr \"(\"\n            queue  mbr  dsix  \"*\"\n            end                        /* ALIAS                      */\n         else queue mbr dsix           /* not an ALIAS               */\n      end\n   end                                 /* dsix                       */\n\n   midx  = queued()                    /* how many lines ?           */\n   \"ALLOC FI(SORTIN) DA(TEMPSRT) RECFM(F B) SPACE(5 2) TRACK NEW REU\",\n      \" LRECL(16) BLKSIZE(0)\"\n   if rc > 4 then do\n      \"ALLOC FI(SORTIN) DA(TEMPSRT) SHR REU\"\n      end\n   \"EXECIO\" midx \"DISKW SORTIN (FINIS\"\n   \"DELSTACK\"                          /* restore prior queues       */\n\nreturn                                 /*@ D_LOAD_SORTIN             */\n/*\n.  Build standard (not STATS, not COMPACT) header records:\n.  \" | ........ | ........ | ........ | ..etc\"\n.  that is: starts with \" | \" plus qualifier padded to l=10, repeat\n.  for all datasets.\n.  ----------------------------------------------------------------- */\nHA_STANDARD_HDR:                       /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   slug       = Right(\"\",collen)\"|\"\n   sluglen    = Length(slug)\n\n   base_line = \" |\"Copies(slug,dsn.0)  /* leader = 2 bytes           */\n\n   do ii = 1 to dsn.0\n      rdsn.ii  = Reverse(lvls.ii)      /* CEXE TSET 54321TD, maybe ? */\n   end\n\n   more = \"1\"\n   do while more\n\n      more = \"0\"\n      hdrline = base_line              /* start of line              */\n\n      do ii = 1 to dsn.0\n         parse var rdsn.ii tlvl rdsn.ii /* TSET maybe                */\n         tlvl  = Reverse(tlvl)         /* TEST maybe                 */\n         pos = ((ii-1) * sluglen) + 4  /* 4, 15, 26, 37, maybe       */\n         hdrline = Overlay( Left(tlvl,8) , hdrline , pos , 8 )\n         if rdsn.ii <> \"\" then more = \"1\" /* do another cycle        */\n      end\n\n      push hdrline                     /* place on top of the stack  */\n\n   end                                 /* while more                 */\n\n   hdrline = base_line                 /* start separator line       */\n   hdrline = Translate(hdrline,\"-\",\" \")\n   hdrline = Translate(hdrline,\"+\",\"|\")\n   hdrline = Overlay(\" \",hdrline,1,1)\n   queue hdrline\n\n   hidx = 0; hdr.=\"\"                   /* set up array               */\n   do queued()                         /* hdrlines in stack          */\n      pull hdrline                     /* pull topmost               */\n      hidx = hidx + 1                  /* increment index            */\n      hdr.hidx = hdrline               /* load to array              */\n   end\n   hdr.1 = Overlay(\"1\",hdr.1)          /* page eject                 */\n   hdr.0 = hidx                        /* how many header lines ?    */\n\nreturn                                 /*@ HA_STANDARD_HDR           */\n/*\n.  build header records:\n.  This routine builds header records for the \"COMPACT\" display:\n.  starts with \"          |    |\" plus room for dataset identifier,\n.  padded to l=3, repeat for all datasets.  Total length = 17 + 3\n.  per dataset.\n.  ----------------------------------------------------------------- */\nHC_SHORTHDR:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   base_line = \"          |    |\"      /* leader = 16 bytes          */\n   hdrline = base_line                 /* start of line              */\n   sluglen = 3\n\n   queue hdrline                       /* place on bottom of stack   */\n\n   hidx = 0; hdr.=\"\"                   /* set up array               */\n   do queued()                         /* hdrlines in stack          */\n      pull hdrline                     /* pull topmost               */\n      hidx = hidx + 1                  /* increment index            */\n      hdr.hidx = hdrline               /* load to array              */\n   end\n   hdr.1 = Overlay(\"1\",hdr.1)          /* page eject                 */\n\n   hdrline = Copies(\"-\",outlen)        /* all dashes                 */\n   hdrline = Overlay(base_line,hdrline) /* overlay bars              */\n   hdrline = Overlay(\"|\",hdrline,outlen) /* last char = bar          */\n   hdrline = Translate(hdrline,\"-\",\" \")\n   hdrline = Translate(hdrline,\"+\",\"|\") /* bars become pluses        */\n   hdrline = Overlay(\" \",hdrline,1,1)\n\n   hidx = hidx + 1                     /* increment index            */\n   hdr.hidx = hdrline                  /* add to array               */\n   hdr.0 = hidx                        /* how many header lines ?    */\n   call HCA_TITLE_PG                   /* put up dsn list           -*/\n\nreturn                                 /*@ HC_SHORTHDR               */\n/*\n.    Since the headers do not indicate the dataset name, we need a\n.    title page which cross-references the indicators \"(12)\" to the\n.    dataset name, e.g.:\n.        (12) =   \"TTGTCBS.DOCLIB.BLG.LETTERS\"\n.    These lines have to be PUSHed onto the top of the stack so that\n.    they are written first.\n.  ----------------------------------------------------------------- */\nHCA_TITLE_PG:                          /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   asa = \" \"\n   do i = dsn.0 to 1 by -1             /* for each dataset           */\n      line = asa\"      (\"Right(i,2)\")  = \"Word(dsnstr,i)\n      push line                        /* WRITE                      */\n   end\n\n   asa = \"1\"\n   line = asa\"    Compact member cross reference \"\n   push line                           /* WRITE                      */\n\nreturn                                 /*@ HCA_TITLE_PG              */\n/*\n.  build header records (STATS=\"1\") :\n.  This routine builds header records for the \"STATS\" display:\n.  starts with \"          |\" plus room for member statistics,\n.  padded to l=16, repeat for all datasets.  Total length = 13 + 16\n.  per dataset.\n.  ----------------------------------------------------------------- */\nHS_STATHDR:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   slug       = Right(\"\",collen)\"|\"\n   sluglen    = Length(slug)\n   base_line = \"          |\"Copies(slug,dsn.0) /* leader = 11 bytes  */\n\n   do ii = 1 to dsn.0\n      rdsn.ii  = Reverse(lvls.ii)      /* CEXE TSET 54321TD, maybe ? */\n   end\n\n   more = \"1\"\n   do while more\n\n      more = \"0\"\n      hdrline = base_line              /* start of line              */\n\n      do ii = 1 to dsn.0\n         parse var rdsn.ii tlvl rdsn.ii /* TSET maybe                */\n         tlvl  = Reverse(tlvl)         /* TEST maybe                 */\n         pos = ((ii-1) * sluglen) + 13 /* 13, 30, 47     maybe       */\n         hdrline = Overlay( Left(tlvl,8) , hdrline , pos , 8 )\n         if rdsn.ii <> \"\" then more = \"1\" /* do another cycle        */\n      end\n\n      push hdrline                     /* place on top of the stack  */\n\n   end                                 /* while more                 */\n\n   hdrline = base_line                 /* start separator line       */\n   hdrline = Translate(hdrline,\"-\",\" \")\n   hdrline = Translate(hdrline,\"+\",\"|\")\n   hdrline = Overlay(\" \",hdrline,1,1)\n   queue hdrline                       /* after headers              */\n\n   hidx = 0; hdr.=\"\"                   /* set up array               */\n   do queued()                         /* hdrlines in stack          */\n      pull hdrline                     /* pull topmost               */\n      hidx = hidx + 1                  /* increment index            */\n      hdr.hidx = hdrline               /* load to array              */\n   end\n   hdr.1 = Overlay(\"1\",hdr.1)          /* page eject                 */\n   hdr.0 = hidx                        /* how many header lines ?    */\n\nreturn                                 /*@ HS_STATHDR                */\n/*\n.   input is a stack, MLIST., with entries of the form:\n.                 NAME # {*}\n.   sorted by name and #\n.\n.   Output (for STATS='0') is a line of 'n' 10-char compartments\n.   separated by vertical bars.  'n' is not larger than the largest\n.   '#'.  The 'name' is placed in a compartment as indicated by '#'.\n.\n.   Output (for STATS='1') is a line of 'n' 16-char compartments\n.   separated by vertical bars.  'n' is not larger than the largest\n.   '#'.  The member statistics are placed in a compartment as\n.   indicated by '#'.  The membername is placed at the far left of\n.   the line.\n.\n.   Output (for COMPACT='1') is a line of 'n' 2-char compartments\n.   separated by blanks.  The dataset number is placed in a\n.   compartment as indicated by '#'.  The membername and the number\n.   of occurences is placed at the far left of the line.\n.  ----------------------------------------------------------------- */\nQ_COMPOSE:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if sw.0stats then call QA_LMOPEN    /*                           -*/\n   wait_for_enter=\"0\"                  /* prompting switch           */\n   line = base_line                    /* init                       */\n   call QP_NEWPAGE                     /* first set of headers      -*/\n\n   save_mbr = word(mlist.1,1)          /* avoid initial break        */\n   if sw.0compact | sw.0stats then,    /* ... load 1st membername    */\n      line = Overlay(save_mbr,line,2,8)\n\n   ind = \"\"                            /* \"*\" if ALIAS               */\n   occurs = 0                          /* members per line           */\n   do mx = 1 to mlist.0                /* for each list item         */\n\n      parse var mlist.mx mbr pos ind . /* get name and position      */\n      if save_mbr <> mbr then do       /* if name break              */\n         if sw.0compact then,\n            line = Overlay(Right(occurs,2),line,13,2)\n         if sw.0dup_only & occurs=1 then nop /* skip                 */\n         else call QQ_PUMPLINE         /* write the line at break   -*/\n         latest_date = \"\"\n         line = base_line\n         occurs = 0\n         save_mbr = mbr                /* store new name             */\n         if sw.0compact | sw.0stats then,\n            line = Overlay(mbr,line,2,8)\n         end                           /* if name break              */\n\n      spot = ((pos-1) * sluglen) +  margin + 2\n\n      if sw.0compact then,\n         line = Overlay(Right(pos,2,0)||ind,line,spot-1,collen+1)\n      else,\n      if sw.0stats then do\n         call QS_GET_STATS             /*                           -*/\n         line = Overlay(Left(mstat,collen),line,spot,collen-2)\n         end\n      else,\n         line = Overlay(Left(mbr,collen)||ind,line,spot,collen-2)\n      occurs = occurs + 1              /* count it                   */\n\n   end                                 /* mx                         */\n\n   if sw.0compact then,\n      line = Overlay(Right(occurs,2),line,13,2)\n\n   if sw.0dup_only & occurs=1 then nop /* skip                       */\n   else call QQ_PUMPLINE               /* write the line at break   -*/\n\n   if sw.0stats then call QZ_LMCLOSE   /*                           -*/\n\nreturn                                 /*@ Q_COMPOSE                 */\n/*\n.  ----------------------------------------------------------------- */\nQA_LMOPEN:                             /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   do lmx = 1 to dsn.0\n      \"LMINIT DATAID(LMID\"lmx\") DATASET(\"dsn.lmx\")\"\n      \"LMOPEN DATAID(\"Value(\"LMID\"lmx)\")\"\n   end\n\n   latest_date = \"\"\n\nreturn                                 /*@ QA_LMOPEN                 */\n/*\n.  ----------------------------------------------------------------- */\nQP_NEWPAGE:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if wait_for_enter then pull         /* wait for KB enter          */\n   if outdsn=\"\" then do\n      wait_for_enter=\"1\"               /* was initially off          */\n      \"CLEAR\"                          /* clear the screen           */\n      end\n\n   do hidx = 1 to hdr.0                /* for each header line       */\n      if outop = \"QUEUE\" then,\n         queue hdr.hidx ; else,\n         say   hdr.hidx\n   end\n   linect = hdr.0                      /* indicate lines used        */\n\nreturn                                 /*@ QP_NEWPAGE                */\n/*\n.  ----------------------------------------------------------------- */\nQQ_PUMPLINE:                           /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if sw.0stats then call QQA_AGE      /* who's newest              -*/\n   if linect = pagelim then call QP_NEWPAGE /* page break           -*/\n\n   if outop = \"QUEUE\" then,\n      queue line    ; else,\n      say   line\n\n   linect = linect + 1                 /* indicate line used         */\n\nreturn                                 /*@ QQ_PUMPLINE               */\n/*\n.  Input is <latest_date>; find any stats slug which matches and tag\n.  it with an * to indicate \"most recent copy\".\n.  ----------------------------------------------------------------- */\nQQA_AGE:                               /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   if occurs = 1 then return           /* nothing to compare         */\n   if \\Datatype(Left(latest_date,1),\"W\") then return  /* no stats    */\n\n   rc = Trace(\"O\"); rc = Trace(tv)\n\n   complen = Length(latest_date)\n   do ibx = 1 to dsn.0\n      start = ((ibx-1) * sluglen) + 13\n      mslug = Substr(line,start,complen)  /* acquire statistics      */\n      if latest_date = mslug then,\n         line = Overlay(\">\",line,start-1,1)  /* mark it              */\n   end                                 /* ibx                        */\n\nreturn                                 /*@ QQA_AGE                   */\n/*\n.  Input is <mbr> and <pos>; get ISPF statistics for <mbr> in dataset\n.  dsn.<pos>; load to variable <mstat> and return.\n.  ----------------------------------------------------------------- */\nQS_GET_STATS:                          /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"LMMFIND DATAID(\"Value(\"LMID\"pos)\") MEMBER(\"mbr\")  STATS(YES)\"\n   mstat = zlmdate zlmtime             /* 02/27/98 15:22    l=14+2   */\n   if mstat = \"\" then,\n      if ind = \"*\" then mstat = \"(alias)\"\n      else mstat = \"(no stats)\"\n   if latest_date < mstat then,\n      latest_date = mstat\n\nreturn                                 /*@ QS_GET_STATS              */\n/*\n.  ----------------------------------------------------------------- */\nQZ_LMCLOSE:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   do lmx = 1 to dsn.0\n      \"LMCLOSE DATAID(\"Value(\"LMID\"lmx)\")\"\n      \"LMFREE  DATAID(LMID\"lmx\")\"\n   end\n\nreturn                                 /*@ QZ_LMCLOSE                */\n/*\n   Parse out the embedded components at the back of the source code.\n.  ----------------------------------------------------------------- */\nDEIMBED: Procedure expose,             /*@                           */\n   exec_name ddnlist branch tv monitor\n   trace O\n   address TSO\n\n   fb80po.0  = \"NEW CATALOG UNIT(sysda) SPACE(5 5) TRACKS DIR(40)\",\n               \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   fb80po.1  = \"SHR\"                   /* if it already exists...    */\n   ddnlist = \"\"\n\n   lastln   = sourceline()\n   currln   = lastln                   /*                            */\n   if Left(sourceline(currln),2) <> \"*/\" then return\n\n   currln = currln - 1                 /* previous line              */\n   \"NEWSTACK\"\n   do while sourceline(currln) <> \"/*\"\n      text = sourceline(currln)        /* save with a short name !   */\n      if Left(text,3) = \")))\" then do  /* package the queue          */\n         parse var text \")))\" ddn mbr .   /* PLIB PANL001  maybe     */\n         outdsn = exec_name\".\"ddn\n         stat = Sysdsn(outdsn) = \"OK\"\n         if \\stat then do              /* doesn't exist              */\n            \"ALLOC FI(\"ddn\") DA(\"outdsn\") REU\" fb80po.0\n            \"FREE  FI(\"ddn\")\"\n            end                        /*                            */\n         if Pos(ddn,ddnlist) = 0 then, /* doesn't exist              */\n            ddnlist = ddnlist ddn      /* keep track                 */\n         \"ALLOC FI(\"ddn\") DA(\"outdsn\"(\"mbr\"))  SHR REU\"\n         \"EXECIO\"  queued() \"DISKW\"  ddn \"(FINIS\"\n         end                           /* package the queue          */\n      else push text                   /* onto the top of the stack  */\n      currln = currln - 1              /* previous line              */\n   end                                 /* while                      */\n   \"DELSTACK\"\n\nreturn                                 /*@ DEIMBED                   */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nsay \"  FCXREF  :::::::::::::                                          \"\nsay \"       produces a side-by-side list of member names in a set of  \"\nsay \"       concatenated libraries.                                   \"\nsay \"                                                                 \"\nsay \"  SYNTAX :  FCXREF   <DDNAME input-filename>                     \"\nsay \"                     <OUTPUT output-dsname>                      \"\nsay \"                     <NOHDR>                                     \"\nsay \"                     <LPP lines-per-page>                        \"\nsay \"                     <ISPF>                                      \"\nsay \"                     <CONFLICTS>                                 \"\nsay \"                     <COMPACT | STATS>                           \"\nsay \"                                                                 \"\nsay \"  Parameters which may be specified:                             \"\nsay \"          <DDNAME ddname> :  the datasets associated with the    \"\nsay \"            specified ddname are examined to produce a           \"\nsay \"            cross-reference list of the member names.            \"\nsay \"                                                                 \"\nsay \"          <OUTPUT outdsn> :  the resultant report is written to  \"\nsay \"            DSN=outdsn.  This dataset will be deleted if it      \"\nsay \"            exists and recreated with an appropriate LRECL.  By  \"\nsay \"            default, output is to the monitor.                   \"\nsay \"                                                                 \"\nsay \"          <NOHDR> :  all header lines (except the initial set)   \"\nsay \"            are suppressed.                                      \"\nsay \"                                                                 \"\nsay \"          <LPP lines-per-page> specifies the page length.        \"\nsay \"                                                                 \"\nsay \"          <ISPF> :  causes FCXREF to run as an ISPF dialog.      \"\nsay \"                                                                 \"\nsay \"          <CONFLICTS> : instructs FCXREF to show only lines      \"\nsay \"            where a membername exists in more than one dataset.  \"\nsay \"                                                                 \"\nsay \"          <STATS>  :  the date and time of last modification is  \"\nsay \"            shown for each member.                               \"\nsay \"                                                                 \"\nsay \"          <COMPACT>:  for cases in which many datasets are to be \"\nsay \"            matched, listing the membernames side-by-side        \"\nsay \"            may produce a listing too wide to be printed.        \"\nsay \"            COMPACT formats the listing as follows:              \"\nsay \"              -- a header page is printed, listing all the       \"\nsay \"                 datasets and assigning an index number to each. \"\nsay \"              -- membernames are listed once down the left       \"\nsay \"                 margin with a count of occurrences.  The balance\"\nsay \"                 of the line consists of numeric references to   \"\nsay \"                 the datasets listed on the first page.          \"\nsay \"                                                                 \"\nsay \"            In COMPACT-mode, the LRECL of the output dataset is  \"\nsay \"               LR = 3x + 16, where x = number of datasets.       \"\nsay \"            The minimum LRECL is 60.                             \"\nsay \"                                                                 \"\nsay \"            In expanded-mode, the LRECL of the output dataset is \"\nsay \"               LR = 11x + 2, where x = number of datasets.       \"\nsay \"                                                                 \"\nsay \"            In STATS-mode, the LRECL of the output dataset is    \"\nsay \"               LR = 17x + 2, where x = number of datasets.       \"\nsay \"                                                                 \"\nsay \"            Therefore, if the number of datasets exceeds 7, STATS\"\nsay \"            will produce a dataset too wide to be printed:       \"\nsay \"                        ((8x17) + 2 = 138);                      \"\nsay \"            if the number of datasets exceeds 11, only a         \"\nsay \"            'compact' list will be printable:                    \"\nsay \"                        ((12x11) + 2 = 134);                     \"\nsay \"            if the number exceeds 39, a printable list cannot be \"\nsay \"            produced:                                            \"\nsay \"                        ((40x3) + 16 = 136).                     \"\nsay \"            In any case, if the number of partitioned datasets   \"\nsay \"            concatenated to a single DDName gets near 39, you    \"\nsay \"            have other more urgent problems.                     \"\nsay \"                                                                 \"\npull\n\"CLEAR\"\nsay \"   Debugging tools provided include:                             \"\nsay \"                                                                 \"\nsay \"        MONITOR:  displays key information throughout processing.\"\nsay \"                  Displays most paragraph names upon entry.      \"\nsay \"                                                                 \"\nsay \"        USEHLQ:   causes dataset prefix to be altered as         \"\nsay \"                  specified.  (Not used by\" exec_name\".)         \"\nsay \"                                                                 \"\nsay \"        NOUPDT:   by-pass all update logic.  (Not used by        \"\nsay \"                  \"exec_name\".)                                  \"\nsay \"                                                                 \"\nsay \"        BRANCH:   show all paragraph entries.                    \"\nsay \"                                                                 \"\nsay \"        TRACE tv: will use value following TRACE to place        \"\nsay \"                  the execution in REXX TRACE Mode.              \"\nsay \"                                                                 \"\nsay \"                                                                 \"\nsay \"   Debugging tools can be accessed in the following manner:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options\"\nsay \"                                                                 \"\nsay \"   For example:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R\"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   $a#y = sigl                         /* where was I called from ?  */\n   do $b#x = $a#y to 1 by -1           /* inch backward to label     */\n      if Right(Word(Sourceline($b#x),1),1) = \":\" then do\n         parse value sourceline($b#x) with $l#n \":\" . /* Paragraph   */\n         leave ; end                   /*                name        */\n   end                                 /* $b#x                       */\n\n   select\n      when brparm = \"NAME\" then return($l#n) /* Return full name     */\n      when brparm = \"ID\"      then do  /*        Return prefix       */\n         parse var $l#n $l#n \"_\" .     /* get the prefix             */\n         return($l#n)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left($l#n,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg,\n                \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg,\n                \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   address TSO \"CLEAR\"\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\n   address TSO \"CLEAR\"\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                 as_invokt  cmd_env  addr_spc  usr_tokn\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   \"NEWSTACK\"\n   \"DFLTHLQ\"  ; pull hlq.  hlqdata\n   \"DELSTACK\"\n\n   do while hlqdata <> \"\"\n      parse var hlqdata site hlq.site hlqdata\n   end\n\n   tk_hlq  = KEYWD(\"USEHLQ\")\n   parse value tk_hlq hlq.node with hlq . /* default to prod         */\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n/*\n)))PLIB GETLIBS\n)ATTR\n  % TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)  INTENS(LOW) SKIP(ON)\n  _ TYPE(INPUT) INTENS(HIGH)\n  \" TYPE(TEXT)  COLOR(YELLOW) SKIP(ON)\n  @ TYPE(TEXT)  INTENS(LOW)  COLOR(YELLOW) SKIP(ON)\n  ! TYPE(INPUT) INTENS(HIGH) COLOR(PINK) CAPS(OFF) JUST(ASIS)\n  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(ASIS)\n  # TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n@Unsupported \u00a6-\u00a6 %Member Cross-Reference@ \u00a6-\u00a6\n%COMMAND ===>_ZCMD\n\n+   Output DSN ===>$OUTDSN\n+  Page Length ===>$LPP+ (lines)\n+    Headers ? ===>$Z+   (Y or N)\n+\n+      Specify input#DDNAME+===>$DDN     +\n+  #or+enter/verify dataset names below:\n%===>$XRDSN1\n%===>$XRDSN2\n%===>$XRDSN3\n%===>$XRDSN4\n%===>$XRDSN5\n%===>$XRDSN6\n%===>$XRDSN7\n%===>$XRDSN8\n%===>$XRDSN9\n%===>$XRDSN10\n%===>$XRDSN11\n%===>$XRDSN12\n+\n)INIT\n .ZVARS = '(HDR)'\n &ZCMD = &Z\n)PROC\n VER(&XRDSN1,DSNAME)\n VER(&XRDSN2,DSNAME)\n VER(&XRDSN3,DSNAME)\n VER(&XRDSN4,DSNAME)\n VER(&XRDSN5,DSNAME)\n VER(&XRDSN6,DSNAME)\n VER(&XRDSN7,DSNAME)\n VER(&XRDSN8,DSNAME)\n VER(&XRDSN9,DSNAME)\n VER(&XRDSN10,DSNAME)\n VER(&XRDSN11,DSNAME)\n VER(&XRDSN12,DSNAME)\n VER(&DDN,NAME)\n VER(&LPP,NUM)\n VER(&OUTDSN,DSNAME)\n &HDRA = TRUNC(&HDR,1)\n VER(&HDRA,LIST,Y,N)\n    &NOHDR = TRANS(&HDR N,NOHDR Y,HDR)\n VPUT (XRDSN1 XRDSN2 XRDSN3 XRDSN4 XRDSN5 XRDSN6)\n VPUT (XRDSN7 XRDSN8 XRDSN9 XRDSN10 XRDSN11 XRDSN12)\n)END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIRSTIME": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00\\x00\\x00\\x921\\x8f\\x00\\x990\\x7f\\t\\x03\\x01\\xa4\\x00#\\x00\\x00\\xc9\\xe2\\xc3\\xc8\\xf8\\xf9@@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "1992-11-13T00:00:00", "modifydate": "1999-11-03T09:03:00", "lines": 420, "newlines": 35, "modlines": 0, "user": "ISCH89"}, "text": "/* REXX  FIRSTIME    Do a process if for the first time <whenever>.\n\n                Written by Frank Clarke, Oldsmar, FL\n\n     Impact Analysis\n.    SYSPROC   FTINIT\n\n     Modification History\n     19950221 fxc \"THIS WEEK\" doesn't work because 'this' was in lower\n                  case and was being compared against upper case text\n     19950329 fxc failed on \"this wednesday\" because no check was being\n                  done other than 'is today the right day?'; any other\n                  day produced HELP text\n     19960612 fxc squeeze space out of line before rewriting; lack of\n                  this caused an odd failure in which the data\n                  continually got longer with each iteration until it\n                  was lost off the end of the file; upgrade to REXXSKEL;\n     19970212 fxc recognize NOUPD and NOUPDT as being equivalent;\n                  upgrade from v.960606 to v.970113;\n     19980604 fxc upgrade from v.970113 to v.19980225;\n                  RXSKLY2K; DECOMM; standardize;\n     19991103 fxc drop support for NOUPD\n\n*/\naddress TSO                            /* REXXSKEL ver.19980225      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\ncall B_GET_FTC                         /*                           -*/\ncall C_CHECK_FTC                       /*                           -*/\ncall D_WRITE_FTC                       /*                           -*/\n\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   run = \"0\"                           /* off by default             */\n   weekdays = \"SUNDAY MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY\"\n\n   \"NEWSTACK\"\n   call FTINIT                         /*                           -*/\n   pull ftc\n   \"DELSTACK\"\n\n   parse upper value  Date(\"B\") Date(\"S\") Date(\"W\") with,\n                      daily     sdate     dayname .\n   day_idx = daily//7\n   weekly  = daily - day_idx           /* start of the week          */\n   monthly = Left(sdate,6)             /* current month - YYYYMM     */\n   annual  = Left(sdate,4)             /* current year  - YYYY       */\n                                       /* parse parms                */\n   parse var parms token1 rest\n   if token1 = \"THIS\" then,            /* token-1 may be \"this\"      */\n      parse var rest  token1 rest      /* 1st rem token is t-scale   */\n\nreturn                                 /*@ A_INIT                    */\n/*\n   Read the user's personal FTC file (contains info about when this\n   routine was last run).\n.  ----------------------------------------------------------------- */\nB_GET_FTC:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"NEWSTACK\"                          /* fence off a buffer         */\n   \"ALLOC FI(CTL) DA(\"ftc\") SHR REU\"\n   if rc <> 0 then do\n      \"ALLOC FI(CTL) DA(\"ftc\") NEW CATALOG UNIT(SYSDA) SPACE(1) TRACKS \",\n             \"RECFM(V B) LRECL(255) BLKSIZE(3120)\"\n      if rc <> 0 then do\n         say \"CTL would not allocate either NEW or SHR.\"\n         exit 8\n         end\n      call BA_GENLINE                  /* establish line            -*/\n      end\n   else do\n      \"EXECIO 1 DISKR CTL (FINIS\"\n      pull line\n      line = Space(line,1)             /* condense                   */\n      end\n   \"DELSTACK\"                          /* purge the buffer           */\n   if monitor then say \"Contents of\" ftc\":\" line\n\nreturn                                 /*@ B_GET_FTC                 */\n/*\n   FTC was non-existent; build a new one.\n.  ----------------------------------------------------------------- */\nBA_GENLINE:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   line = \"D:\"0 \"W:\"0 \"M:\"0 \"A:\"0 \"D0:\"0 ,\n          \"D1:\"0 \"D2:\"0 \"D3:\"0 \"D4:\"0 \"D5:\"0 \"D6:\"0\n   push line\n   \"EXECIO 1 DISKW CTL (FINIS\"\n\nreturn                                 /*@ BA_GENLINE                */\n/*\n.  ----------------------------------------------------------------- */\nC_CHECK_FTC:                           /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   select                              /* what kind of check ?       */\n      when token1 = \"TODAY\" |,\n           token1 = \"DAY\"   |,\n           token1 = \"DAILY\" then do\n         parse var line front \"D:\" last_x back\n         if last_x < daily then do\n            line = front \"D:\"daily back\n            run=\"1\"\n            end\n         end                           /* Daily                      */\n      when token1 = \"WEEK\"  |,\n           token1 = \"WEEKLY\" then do\n         parse var line front \"W:\" last_x back\n         if last_x < weekly then do\n            line = front \"W:\"weekly back\n            run=\"1\"\n            end\n         end                           /* Weekly                     */\n      when token1 = \"MONTH\" |,\n           token1 = \"MONTHLY\" then do\n         parse var line front \"M:\" last_x back\n         if last_x < monthly then do\n            line = front \"M:\"monthly   back\n            run=\"1\"\n            end\n         end                           /* Monthly                    */\n      when token1 = \"YEAR\"  |,\n           token1 = \"ANNUALLY\" |,\n           token1 = \"YEARLY\" then do\n         parse var line front \"A:\" last_x back\n         if last_x < annual then do\n            line = front \"A:\"annual back\n            run=\"1\"\n            end\n         end                           /* Annually                   */\n      when Wordpos(token1,weekdays) >  0 then do\n         if token1 <> dayname then,    /* restricted to specific day */\n            update = \"0\"               /* not the right day...       */\n         else do                       /* we can run today           */\n            parse var line front \"D0:\" last.0 \"D1:\" last.1 \"D2:\" last.2,\n                    \"D3:\" last.3 \"D4:\" last.4 \"D5:\" last.5 \"D6:\" last.6,\n                    back               /* Monday=0, Tuesday=1, Sunday=6 */\n            if last.day_idx < daily then do\n               last.day_idx = daily\n               line = front \"D0:\"last.0 \"D1:\"last.1 \"D2:\"last.2,\n                            \"D3:\"last.3 \"D4:\"last.4 \"D5:\"last.5,\n                            \"D6:\"last.6 back\n               run=\"1\"\n               end                     /* file LT current            */\n            end                        /* we can run today           */\n         end                           /* Specific day               */\n      otherwise do\n         \"CLEAR\"\n         helpmsg = \"ERR ===> Cycle indicator '\"token1\"' not recognized.\"\n         call HELP\n         update = \"0\"                  /* don't write to CTL         */\n         end\n   end                                 /* select                     */\n\n   if run then do                      /* to run or not to run ?     */\n      if monitor then say \"Running command:\" rest\n      address TSO rest\n      end\n   else,\n      if monitor then say \"Ignoring command:\" rest\n\nreturn                                 /*@ C_CHECK_FTC               */\n/*\n.  ----------------------------------------------------------------- */\nD_WRITE_FTC:                           /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if update then do                   /* to updt or not to updt ?   */\n      if monitor then,\n         say \"Replace FTC with <\"line\">\"\n      line = Space(line,1)\n      push line\n      \"EXECIO 1 DISKW CTL (FINIS\"\n      end\n   else,\n      if monitor then,\n         say \"FTC was not replaced\"\n   \"FREE FI(CTL)\"\n\nreturn                                 /*@ D_WRITE_FTC               */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\n   update = \\noupdt\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n. ------------------------------------------------------------------ */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nsay \"  FIRSTIME    controls execution of once-per-period events.      \"\nsay \"                                                                 \"\nsay \"  Syntax:  FIRSTIME <cycle-indicator>                            \"\nsay \"                    <command-to-execute>                         \"\nsay \"                                                                 \"\nsay \"    <cycle indicator> may be any ONE of the following:           \"\nsay \"          <THIS DAY>, <THIS WEEK>, <THIS MONTH>, <THIS YEAR>,    \"\nsay \"               <DAILY>, <WEEKLY>, <MONTHLY>, <YEARLY>,           \"\nsay \"               <ANNUALLY>, <MONDAY>, <TUESDAY>, <WEDNESDAY>,     \"\nsay \"               <THURSDAY>, <FRIDAY>, <SATURDAY>, <SUNDAY>.       \"\nsay \"                                                                 \"\nsay \"    <command-to-execute> may be any TSO command which the user   \"\nsay \"          is authorized to issue.                                \"\nsay \"                                                                 \"\nsay \"    When a day-of-the-week is specified as the cycle-indicator,  \"\nsay \"      execution will occur ONLY on that day.                     \"\npull\n\"CLEAR\"\nsay \"   Debugging tools provided include:\"\nsay \"                                                                 \"\nsay \"        MONITOR:  displays key information throughout processing.\"\nsay \"                  Displays most paragraph names upon entry.\"\nsay \"                                                                 \"\nsay \"        NOUPDT:   by-pass all update logic.\"\nsay \"                                                                 \"\nsay \"        BRANCH:   show all paragraph entries.\"\nsay \"                                                                 \"\nsay \"        TRACE tv: will use value following TRACE to place\"\nsay \"                  the execution in REXX TRACE Mode.\"\nsay \"                                                                 \"\nsay \"                                                                 \"\nsay \"   Debugging tools can be accessed in the following manner:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options\"\nsay \"                                                                 \"\nsay \"   For example:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R\"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nreturn                                 /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   $a#y = sigl                         /* where was I called from ?  */\n   do $b#x = $a#y to 1 by -1           /* inch backward to label     */\n      if Right(Word(Sourceline($b#x),1),1) = \":\" then do\n         parse value sourceline($b#x) with $l#n \":\" . /* Paragraph   */\n         leave ; end                   /*                name        */\n   end                                 /* $b#x                       */\n\n   select\n      when brparm = \"NAME\" then return($l#n) /* Return full name     */\n      when brparm = \"ID\"      then do  /*        Return prefix       */\n         parse var $l#n $l#n \"_\" .     /* get the prefix             */\n         return($l#n)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left($l#n,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   address TSO \"CLEAR\"\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\n   address TSO \"CLEAR\"\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm  as_invokt,\n                  cmd_env  addr_spc  usr_tokn\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   \"NEWSTACK\"\n   \"DFLTHLQ\"  ; pull hlq.  hlqdata\n   \"DELSTACK\"\n\n   do while hlqdata <> \"\"\n      parse var hlqdata site hlq.site hlqdata\n   end\n\n   tk_hlq  = KEYWD(\"USEHLQ\")\n   parse value tk_hlq hlq.node with hlq . /* default to prod         */\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt hlq\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FTINIT": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x93'\\x7f\\x00\\x97\\x04?\\x10F\\x00\\x07\\x00\\x06\\x00\\x00\\xc4\\xe3\\xc3\\xc6\\xe7\\xc3\\xf1@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-10-04T00:00:00", "modifydate": "1997-02-12T10:46:00", "lines": 7, "newlines": 6, "modlines": 0, "user": "DTCFXC1"}, "text": "/* REXX    FTINIT     User-specific initialization for FIRSTIME\n                Written by Frank Clarke, HAS, Inc.\n*/\nftc = \"'\"Userid()\".FTC'\"\nif Sysvar(\"SYSNEST\") = \"NO\"  then say  ftc\n                             else push ftc\nreturn(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LA": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x98\\x15o\\x00\\x992?\\x13\\x06\\x01\\x88\\x01c\\x00\\x00\\xc4\\xc5\\xd5\\xd6\\xd9\\xe3\\xc8@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1998-06-05T00:00:00", "modifydate": "1999-11-19T13:06:00", "lines": 392, "newlines": 355, "modlines": 0, "user": "DENORTH"}, "text": "/* REXX     LA  v.2    LISTA ST into a stack for one DDName\n                       or to screen (with or without DCB info)\n                       for one DDName or all of them.\n\n                Written by Frank Clarke, Oldsmar, FL\n\n     Impact Analysis\n.\n\n     Modification History\n     19980605 fxc standardized; added REXXSKEL v.19980225; DECOMM;\n                  version 2 will deliver all dsnames for any or all\n                  ddnames;\n\n*/\naddress TSO                            /* REXXSKEL ver.19980225      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\ncall B_DDN_LIST                        /*                           -*/\ncall C_FIND_DSNS                       /*                           -*/\n\nif sw.0stack + sw.0list = 0 then exit\nif \\sw.0list  then,\n   if dsnstr <> \"\" then push dsnstr    /* load stack                 */\nif queued() = 0 then,\n   if sw.0list then\n      push ddname\": (empty)\"\n   else,\n      push \"(empty)\"\n\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit                                   /*@                           */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   call AA_KEYWDS                      /*                           -*/\n   parse value \"\" with,\n         dsnstr  dc.  ln.  start.  end.  ddn.\n   parse value \"0 0 0 0 0 0 0 0 0 0 0\" with,\n         ii   ddnx  ddn#   dsnx  .\n   if \\sw.nested then sw.0stack = \"0\"\n\n   parse var parms ddname\n   ddname = Space(ddname,1)\n\n   rc = Outtrap(\"ln.\")                 /* open trap                  */\n   \"LISTA ST\"\n   rc = Outtrap(\"OFF\")                 /* close trap                 */\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nAA_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n\nreturn                                 /*@ AA_KEYWDS                 */\n/*\n.  ----------------------------------------------------------------- */\nB_DDN_LIST:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n                                       /* Build DDName stack         */\n   do trapx = 1 to ln.0                /* for each trapped line      */\n\n      if Left(ln.trapx,1) <> \"\" then,  /* DSName                     */\n         iterate                       /* pick it up later           */\n\n      if Substr(ln.trapx,3,1) <> \" \" then do /* new DDName           */\n         ddn#       = ddn# + 1         /* DDName index               */\n         ddn.ddn#   = Word(ln.trapx,1) /* save DDName                */\n         start.ddn# = trapx - 1        /* 1st dsn on previous line   */\n         end.ddn#   = trapx - 1        /* ...maybe the last one, too */\n         end\n      else if Left(ln.trapx,1) = \" \" then,    /* concatenated DSName */\n         end.ddn#   = trapx - 1        /* new end-point              */\n\n   end                                 /* trapx                      */\n\nreturn                                 /*@ B_DDN_LIST                */\n/*\n   Given: array of DDNames (ddn.), the location of the 1st DSName\n   for the DDName (start.) and the last DSName (end.); produce the\n   requested output.\n.  ----------------------------------------------------------------- */\nC_FIND_DSNS:                           /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if \\sw.nested then \"CLEAR\"\n\n   do ddnx = 1 to ddn#                 /* for all ddnames            */\n      if Wordpos(ddn.ddnx,ddname) > 0 |, /* target DDName ?          */\n         ddname = \"\" then do           /*   or none specified        */\n         wrkddn = ddn.ddnx             /* save for printing          */\n\n         do dsnx = start.ddnx to end.ddnx by 2 /* for each DSName    */\n            if sw.0stack then do       /* STACK requested            */\n               if sw.0detail then queue Left(wrkddn,8) ln.dsnx; else,\n               dsnstr = dsnstr ln.dsnx /* form one-line list         */\n               end\n            else,\n            if sw.0list then do        /* LIST requested             */\n               dsnstr = dsnstr ln.dsnx /* form one-line list         */\n               end\n            else,\n            if sw.0dcb then do         /* DCB requested              */\n               rc = Outtrap(\"dc.\")     /* open trap                  */\n               \"LISTD '\"ln.dsnx\"'\"     /* LISTD to trap              */\n               parse var dc.3,         /* delivered DCB              */\n                         recfm,\n                         lrecl,\n                         blksize,\n                         dsorg .       /* ...and clip off the rest.  */\n               slug = Left(recfm,3),   /* must all be equal          */\n                      Right(lrecl,4),  /* must all be equal          */\n                      Right(blksize,7), /* right-justify             */\n                      dsorg            /* must all be equal          */\n               say Left(Left(wrkddn,10), /* DDName                   */\n                        ln.dsnx,50),   /* DSName                     */\n                   slug                /* DCB                        */\n               rc = Outtrap(\"off\")     /* close trap                 */\n               end\n            else,                      /* not STACK, not DCB         */\n               say Left(Left(wrkddn,10), /* DDName                   */\n                        ln.dsnx,50)    /* DSName                     */\n            wrkddn=\"\"                  /* group-indicate             */\n         end                           /* dsnx                       */\n         if sw.0list then do\n            queue ddn.ddnx\":\" dsnstr\n            dsnstr = \"\"\n            end\n\n         end                           /* ddn = ddname               */\n   end                                 /* ddnx                       */\n\nreturn                                 /*@ C_FIND_DSNS               */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   address TSO\n\n   sw.0dcb     = SWITCH(\"DCB\")\n   sw.0detail  = SWITCH(\"DETAIL\")\n   sw.0stack   = SWITCH(\"STACK\")\n   sw.0list    = SWITCH(\"LIST\")\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO \"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\nsay \"  \"ex_nam\"  (v.2) Allocation List to stack or display            \"\nsay \"                                                                 \"\nsay \"  Syntax:   \"ex_nam\"  <ddname-list>  ((  <options>               \"\nsay \"                                                                 \"\nsay \"            <options>   may contain any of:                      \"\nsay \"                        DCB    STACK    DETAIL   LIST            \"\nsay \"                                                                 \"\nsay \"            DCB       produces a list of DSNames + DCBs.  DCB is \"\nsay \"                      only appropriate for DISPLAY (that is,     \"\nsay \"                      not STACK).                                \"\nsay \"                                                                 \"\nsay \"            STACK     returns information to a calling routine   \"\nsay \"                      via the data stack.  The format depends on \"\nsay \"                      other options.  STACK is ignored unless    \"\nsay \"                      invocation is via an independent caller.   \"\nsay \"                                                                 \"\nsay \"            STACK and DCB are mutually exclusive.                \"\nsay \"                                                                 \"\nsay \" more....                                                        \"\npull\n\"CLEAR\"\nsay \"            DETAIL   If present, this requests the output be     \"\nsay \"                      returned in two-column format with the     \"\nsay \"                      first column being a group-indicated DDName\"\nsay \"                      and the second column the DSName.          \"\nsay \"                     If not present, the output is returned as a \"\nsay \"                      string containing the fully-qualified,     \"\nsay \"                      unquoted list of DSNames allocated to the  \"\nsay \"                      specified DDName.                          \"\nsay \"                                                                 \"\nsay \"            LIST     If present, this requests the output be     \"\nsay \"                      returned one line per DDName in the format \"\nsay \"                          <ddn>: <dsnlist>                       \"\nsay \"                      The DSNames are unquoted fully-qualified.  \"\nsay \"                                                                 \"\nsay \"            DETAIL and LIST are mutually exclusive.              \"\nsay \"                                                                 \"\nsay \" more....                                                        \"\npull\n\"CLEAR\"\nsay \"   Debugging tools provided include:\"\nsay \"                                                                 \"\nsay \"        MONITOR:  displays key information throughout processing.\"\nsay \"                  Displays most paragraph names upon entry.\"\nsay \"                                                                 \"\nsay \"        BRANCH:   show all paragraph entries.\"\nsay \"                                                                 \"\nsay \"        TRACE tv: will use value following TRACE to place\"\nsay \"                  the execution in REXX TRACE Mode.\"\nsay \"                                                                 \"\nsay \"                                                                 \"\nsay \"   Debugging tools can be accessed in the following manner:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options\"\nsay \"                                                                 \"\nsay \"   For example:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R\"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   $a#y = sigl                         /* where was I called from ?  */\n   do $b#x = $a#y to 1 by -1           /* inch backward to label     */\n      if Right(Word(Sourceline($b#x),1),1) = \":\" then do\n         parse value sourceline($b#x) with $l#n \":\" . /* Paragraph   */\n         leave ; end                   /*                name        */\n   end                                 /* $b#x                       */\n\n   select\n      when brparm = \"NAME\" then return($l#n) /* Return full name     */\n      when brparm = \"ID\"      then do  /*        Return prefix       */\n         parse var $l#n $l#n \"_\" .     /* get the prefix             */\n         return($l#n)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left($l#n,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   address TSO \"CLEAR\"\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\n   address TSO \"CLEAR\"\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\" ,\nerrortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm  as_invokt  ,\ncmd_env  addr_spc  usr_tokn\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   \"NEWSTACK\"\n   \"DFLTHLQ\"  ; pull hlq.  hlqdata\n   \"DELSTACK\"\n\n   do while hlqdata <> \"\"\n      parse var hlqdata site hlq.site hlqdata\n   end\n\n   tk_hlq  = KEYWD(\"USEHLQ\")\n   parse value tk_hlq hlq.node with hlq . /* default to prod         */\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt hlq\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMBERS": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x932?\\x00\\x99\\x19\\x0f\\x11\\x13\\x01t\\x00\\\\\\x00\\x00\\xc9\\xe2\\xc3\\xc8\\xf8\\xf9@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1993-11-19T00:00:00", "modifydate": "1999-07-09T11:13:00", "lines": 372, "newlines": 92, "modlines": 0, "user": "ISCH89"}, "text": "/* REXX    MEMBERS    Produce a concise member-list for a PO dataset.\n                      MEMBERS will return its output to the terminal\n                      (by default), or via the stack (option STACK)\n                      either as a vertical list (option LIST) or as a\n                      single line (option LINE).\n\n           Written by Frank Clarke, Oldsmar, FL\n\n     Modification History\n     19941026 FXC a dataset with no members should return the string\n                  \"(EMPTY)\"; current version fails by sending the\n                  message \"Invalid DSName\".\n     19960410 fxc upgrade to REXXSKEL; handle aliases: if \"ALIAS\" is\n                  specified in <opts> aliasnames are returned in the\n                  same way as the main membernames and immediately\n                  following their main member, and have \"(*)\"\n                  appended;\n     19970820 bab upgrade to REXXSKEL from ver.960119 to ver.970818;\n                  correct problem when Alias Names exists w/o true\n                  names.\n     19971108 fxc upgrade from ver.970818 to v.19971030; y2k\n                  compliance; decomm; restore in-line HELP text;\n                  minor cosmetics;\n\n*/\naddress TSO                            /* REXXSKEL ver.19971030      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\nif info = \"\" then call HELP            /*                           -*/\n\ncall A_INIT                            /*                           -*/\n                                   if \\sw.0error_found then,\ncall B_LISTD                           /*                           -*/\n                                   if \\sw.0error_found then,\ncall C_BUILD                           /*                           -*/\n\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit                                   /*@ MEMBERS                   */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if sw.0list + sw.0line <> 1 then,\n      parse value \"0 1\" with sw.0list sw.0line\n   parse var info  dsname info\n   parse value \"0\" with sw.0error_found .\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nB_LISTD:                               /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   trc = Outtrap(\"L.\")\n   \"LISTD\" dsname \"M\"\n   trc = Outtrap(\"OFF\")\n   if l.0 < 7 then,\n   if sw.0stack then queue \"(EMPTY)\"   /* no members !               */\n   else do\n      say \"No members in\" dsname\n      exit\n      end\n\n   do ii = 1 to l.0 until Word(l.ii,1) = \"--MEMBERS--\"\n   end\n\n   /*\n      Process the memberlist bottom-up.  <slug> is formed of \"anything\n      accumulated so far\" preceeded by the line above it.  When the\n      first 3 bytes of <slug> is blank, it's part of an aliaslist;\n      keep it.  When the first three bytes are NOT blank, a member\n      name has been found; push the accumulated data onto the stack\n      and reinitialize <slug>.\n   */\n   slug = \"\"\n   do bx = L.0 to ii+1  by  -1\n      slug = L.bx Strip(slug)\n      if Left(slug,3) <> \"\" then do; push slug; slug = \"\"; end\n   end\n\nreturn                                 /*@ B_LISTD                   */\n/*\n   The memberlist has been pushed onto the stack.\n.  ----------------------------------------------------------------- */\nC_BUILD:                               /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value 0               with ,\n               no_more_q  stak .\n\n/*  The phrase \"THE FOLLOWING ALIAS NAMES EXIST WITHOUT TRUE NAMES\"\n    indicates aliases are in the PDS without true member names to match\n    on.  Skip this line and remaining lines in queue for member names\n                                           Change add on 970820, BAB */\n   do queued()\n      pull full_qline\n      if no_more_q then iterate        /* Clear the queue out        */\n      if POS(\"THE FOLLOWING ALIAS NAMES\",full_qline) > 0 then do\n         no_more_q = 1 ; iterate\n         end\n      parse var full_qline mbr . \"ALIAS(\" aliaslist \")\"\n      call CA_STORE                    /* put the mbr on the list   -*/\n\n      if sw.0alias then,\n      if aliaslist <> \"\" then do\n         /* diagnose here */           /*                            */\n         aliaslist = Translate(aliaslist , \" \" , \",\")\n         do while aliaslist  <> \"\"\n            parse var aliaslist mbr aliaslist\n            mbr = mbr\"(*)\"\n            call CA_STORE              /*                           -*/\n         end                           /* while aliaslist not blank  */\n         end\n   end\n\n   if stak <> \"\" then,                 /* we loaded it               */\n      if sw.0stack then,\n         queue stak\n      else,\n         say stak\n\nreturn                                 /*@ C_BUILD                   */\n/*\n   Given: <mbr> and <aliaslist>\n.  ----------------------------------------------------------------- */\nCA_STORE:                              /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if sw.0line then,                   /* LINE                       */\n      stak = stak mbr\n   else,                               /* LIST vertically            */\n      if sw.0stack then,               /* sw.0list & sw.0stack       */\n         queue    mbr\n      else,                            /* sw.0list & \\sw.0stack      */\n         say      mbr\n\nreturn                                 /*@ CA_STORE                  */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\n   sw.0alias = SWITCH(\"ALIAS\")         /* show aliases               */\n   sw.0stack = SWITCH(\"STACK\")         /* return via the stack       */\n   sw.0list  = SWITCH(\"LIST\")          /* arrange in a vertical list */\n   sw.0line  = SWITCH(\"LINE\")          /* arrange on one line        */\n\nreturn                                 /*@ LOCAL_PREINIT             */\n\n/*-------------------------------------------------------------------*/\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nsay \"  MEMBERS       Produces a concise member-list for a PO dataset. \"\nsay \"                MEMBERS will return its output to the terminal   \"\nsay \"                (by default), or via the stack (option STACK)    \"\nsay \"                either as a vertical list (option LIST) or as a  \"\nsay \"                single line (option LINE), default=LINE.         \"\nsay \"                                                                 \"\nsay \"  Syntax:   MEMBERS   <dsname>  <(( options>                     \"\nsay \"                      <options> are separated from <dsname> by   \"\nsay \"                      a double open parenthesis '(('.            \"\nsay \"                                                                 \"\nsay \"            <STACK>   causes the resultant member list to be     \"\nsay \"                      returned via the stack.  If STACK is not   \"\nsay \"                      specified, return is to the terminal.      \"\nsay \"            <LIST>    causes the returned value(s) to be         \"\nsay \"                      presented one member per line (a vertical  \"\nsay \"                      list).                                     \"\nsay \"            <LINE>    causes the returned value(s) to be         \"\nsay \"                      presented as a single string containing all\"\nsay \"                      the members in order.                      \"\nsay \"            <ALIAS>   requests that alias entries also be        \"\nsay \"                      returned.  MEMBERS ignores aliases by      \"\nsay \"                      default.  Alias entries returned by MEMBERS\"\nsay \"                      will have '(*)' appended to the aliasname. \"\npull\n\"CLEAR\"\nsay \"   Debugging tools provided include:\"\nsay \"                                                                 \"\nsay \"        BRANCH:   show all paragraph entries.\"\nsay \"                                                                 \"\nsay \"        TRACE tv: will use value following TRACE to place\"\nsay \"                  the execution in REXX TRACE Mode.\"\nsay \"                                                                 \"\nsay \"                                                                 \"\nsay \"   Debugging tools can be accessed in the following manner:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options\"\nsay \"                                                                 \"\nsay \"   For example:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R\"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n\n/* ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   $a#y = sigl                         /* where was I called from ?  */\n   do $b#x = $a#y to 1 by -1           /* inch backward to label     */\n      if Right(Word(Sourceline($b#x),1),1) = \":\" then do\n         parse value sourceline($b#x) with $l#n \":\" . /* Paragraph   */\n         leave ; end                   /*                name        */\n   end                                 /* $b#x                       */\n\n   select\n      when brparm = \"NAME\" then return($l#n) /* Return full name     */\n      when brparm = \"ID\"      then do  /*        Return prefix       */\n         parse var $l#n $l#n \"_\" .     /* get the prefix             */\n         return($l#n)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left($l#n,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n\n/* ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n\n/* ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n\n/* ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n\n/* ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n\n/* ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n\n/* ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   address TSO \"CLEAR\"\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\n   address TSO \"CLEAR\"\nreturn                                 /*@ SS                        */\n\n/* ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n\n/* ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n\n/* ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm  as_invokt,\n                   cmd_env  addr_spc  usr_tokn\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   \"NEWSTACK\"\n   \"DFLTHLQ\"  ; pull hlq.  hlqdata\n   \"DELSTACK\"\n\n   do while hlqdata <> \"\"\n      parse var hlqdata site hlq.site hlqdata\n   end\n\n   tk_hlq  = KEYWD(\"USEHLQ\")\n   parse value tk_hlq hlq.node with hlq . /* default to prod         */\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SQRT": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x96\\x02_\\x00\\x96\\x02_\"\\x04\\x00\\x18\\x00\\x13\\x00\\x00\\xc4\\xe3\\xc3\\xc6\\xe7\\xc3\\xf1@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1996-01-25T00:00:00", "modifydate": "1996-01-25T22:04:00", "lines": 24, "newlines": 19, "modlines": 0, "user": "DTCFXC1"}, "text": "                                       /* REXX external subroutine   */\n/* ----------------------------------------------------------------- */\nSQRT:                                  /*@                           */\narg nbr .                              /* 2.25 maybe                 */\nparse var nbr whole \".\" frac           /* 2 25                       */\nif \u00acDatatype(whole,\"W\") then whole = 0\nif \u00acDatatype(frac ,\"W\") then frac  = 0; else frac = \".\"frac\nif Length(whole)//2 = 0 then parse var whole base 3 tail\n                        else parse var whole base 2 tail\nroot = (base/2) * (10**(Length(tail)%2)) + frac\nnumeric digits 12                      /*                            */\nlastdiff = 0                           /*                            */\ndo forever                             /*                            */\n   diff = nbr - root**2                /*                            */\n   if diff = 0 then leave              /*                            */\n   if diff = lastdiff then leave       /*                            */\n   lastdiff = diff                     /*                            */\n   root  =  root + ((diff/2) /root)    /*                            */\nend                                    /*                            */\nif Pos(\".\",root) > 0 then,             /*                            */\nroot = Strip(root , \"T\" , \"0\")         /*                            */\nroot = Strip(root , \"T\" , \".\")         /*                            */\nif Sysvar(\"Sysnest\") = \"NO\" then say root; else,\nreturn root                            /*@ SQRT                      */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SQUASH": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x08\\x00\\x00\\x00\\x96\\x19\\x0f\\x00\\x992?\\x13\\x08\\x01e\\x01\\x1c\\x00\\x00\\xc4\\xc5\\xd5\\xd6\\xd9\\xe3\\xc8@@@'", "ispf": {"version": "02.08", "flags": 0, "createdate": "1996-07-08T00:00:00", "modifydate": "1999-11-19T13:08:00", "lines": 357, "newlines": 284, "modlines": 0, "user": "DENORTH"}, "text": "/* REXX    SQUASH     Submit a job to compress a dataset.\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n   |                                                                 |\n   |          WARNING: EMBEDDED COMPONENTS.                          |\n   |                      See text following TOOLKIT_INIT            |\n   |                                                                 |\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n\n           Written by Chris Lewis 19960708\n\n     Impact Analysis\n.    SYSPROC   DFLTHLQ\n.    SYSPROC   TRAPOUT\n.    ISPSLIB   SQUASH\n\n     Modification History\n     19980505 fxc RXSKLY2K; upgrade from v.960702 to v.19980225;\n                  DECOMM;\n     19990712 fxc adapted for PMU\n\n*/\naddress ISPEXEC                        /* REXXSKEL ver.19980225      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\nparse value reverse(info) with dsn .   /* take parm over ZDSN        */\ndsn = reverse(dsn)\n\nif dsn = \"\" | dsn = \"''\" then do\n   helpmsg = \"Dataset Name Required\"\n   call HELP\n   end\n\nif left(dsn,1) = \"'\" then              /* dataset should be in TSO   */\n   dsn = strip(dsn,,\"'\")               /* format; must be fully      */\nelse                                   /* qualified and unquoted for */\n   dsn = userid()\".\"dsn                /* the JCL.                   */\n\ncall DEIMBED                           /* extract SLIB(SQUASH)      -*/\n\"LIBDEF  ISPSLIB  DATASET  ID(\"exec_name\".SLIB)  STACK\"\n\"FTOPEN TEMP\"\n\"FTINCL SQUASH\"\n\"FTCLOSE\"\n\"LIBDEF  ISPSLIB\"\nmstat = Msg(\"OFF\"); address TSO \"DELETE\" exec_name\".SLIB\"; mstat = Msg(mstat)\n\n\"VGET (ZTEMPN ZTEMPF)\"\n\nif monitor then do\n   \"LMINIT DATAID(DDNID) DDNAME(\"ztempn\")\"\n   \"EDIT DATAID(\"DDNID\")\"\n   end\n\nif noupdt then nop\nelse\n   address TSO \"submit '\"ztempf\"'\"\n\nexit                                   /*@ SQUASH                    */\n/*\n   Parse out the embedded components at the back of the source code.\n\n   The components are enclosed in a comment whose start and end are on\n   individual lines for easier recognition.\n\n   Each component is identified by a triple-close-paren \")))\" in\n   column 1 followed by a DDName and a membername.  The text of the\n   component begins on the next line.\n\n   There are no restrictions on the DDName, but the DSName which will\n   be generated for each component type is <exec_name.DDName>.  It is\n   up to the programmer to add the code to properly LIBDEF each\n   component type.\n.  ----------------------------------------------------------------- */\nDEIMBED: Procedure expose,             /*@                           */\n   exec_name ddnlist branch tv monitor\n\n   address TSO\n\n   fb80po.0  = \"NEW CATALOG UNIT(sysda) SPACE(5 5) TRACKS DIR(40) RECFM(F \"||,\n\"B) LRECL(80) BLKSIZE(0)\"\n   fb80po.1  = \"SHR\"                      /* if it already exists...    */\n   ddnlist = \"\"\n\n   lastln   = sourceline()\n   currln   = lastln                   /*                            */\n   if Left(sourceline(currln),2) <> \"*/\" then return\n\n   currln = currln - 1                 /* previous line              */\n   \"NEWSTACK\"\n   do while sourceline(currln) <> \"/*\"\n      text = sourceline(currln)        /* save with a short name !   */\n      if Left(text,3) = \")))\" then do  /* package the queue          */\n         parse var text \")))\" ddn mbr .   /* PLIB PANL001  maybe     */\n         outdsn = exec_name\".\"ddn\n         stat = Sysdsn(outdsn) = \"OK\"\n         if \u00acstat then do              /* doesn't exist              */\n            \"ALLOC FI(\"ddn\") DA(\"outdsn\") REU\" fb80po.0\n            \"FREE  FI(\"ddn\")\"\n            end                        /*                            */\n         if Pos(ddn,ddnlist) = 0 then, /* doesn't exist              */\n            ddnlist = ddnlist ddn      /* keep track                 */\n         \"ALLOC FI(\"ddn\") DA(\"outdsn\"(\"mbr\"))  SHR REU\"\n         \"EXECIO\"  queued() \"DISKW\"  ddn \"(FINIS\"\n         end                           /* package the queue          */\n      else push text                   /* onto the top of the stack  */\n      currln = currln - 1              /* previous line              */\n   end                                 /* while                      */\n   \"DELSTACK\"\n\nreturn                                 /*@ DEIMBED                   */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@ HELP                      */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\n\nsay \"  SQUASH        Submit a job to compress a dataset.              \"\nsay \"                                                                 \"\nsay \"  Syntax:   SQUASH    <dsn>              -  TSO Format           \"\nsay \"                                                                 \"\nsay \"            To squeeze the dataset you are currently in, add     \"\nsay \"            the following to your command table:                 \"\nsay \"                                                                 \"\nsay \"            VERB     T  ACTION                                   \"\nsay \"                           DESCRIPTION                           \"\nsay \"            -------- -  ---------------------------------------- \"\nsay \"            SQUASH   2  SELECT CMD(%SQUASH '&ZDSN' &ZPARM)       \"\nsay \"                           SUBMIT A JOB TO COMPRESS A DATASET    \"\nsay \"                                                                 \"\nsay \"            NOTE:  Any parm is taken in preference to ZDSN.  The \"\nsay \"                   program will take the last parm as the dsn to \"\nsay \"                   compress.                                     \"\nsay \"            NOTE:  Option MONITOR will display the JCL prior to  \"\nsay \"                   submission.                                   \"\nsay \"                   Option NOUPDT will stop automatic submission  \"\nsay \"                   of the JCL.                                   \"\nsay \"                                                                 \"\npull\n\"CLEAR\"\nsay \"   Debugging tools provided include:\"\nsay \"                                                                 \"\nsay \"        MONITOR:  displays key information throughout processing.\"\nsay \"                  Displays most paragraph names upon entry.\"\nsay \"                                                                 \"\nsay \"        NOUPDT:   by-pass all update logic.\"\nsay \"                                                                 \"\nsay \"        BRANCH:   show all paragraph entries.\"\nsay \"                                                                 \"\nsay \"        TRACE tv: will use value following TRACE to place\"\nsay \"                  the execution in REXX TRACE Mode.\"\nsay \"                                                                 \"\nsay \"                                                                 \"\nsay \"   Debugging tools can be accessed in the following manner:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options\"\nsay \"                                                                 \"\nsay \"   For example:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R\"\n\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   $a#y = sigl                         /* where was I called from ?  */\n   do $b#x = $a#y to 1 by -1           /* inch backward to label     */\n      if Right(Word(Sourceline($b#x),1),1) = \":\" then do\n         parse value sourceline($b#x) with $l#n \":\" . /* Paragraph   */\n         leave ; end                   /*                name        */\n   end                                 /* $b#x                       */\n\n   select\n      when brparm = \"NAME\" then return($l#n) /* Return full name     */\n      when brparm = \"ID\"      then do  /*        Return prefix       */\n         parse var $l#n $l#n \"_\" .     /* get the prefix             */\n         return($l#n)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left($l#n,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   address TSO \"CLEAR\"\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\n   address TSO \"CLEAR\"\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\" ,\nerrortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm  as_invokt  ,\ncmd_env  addr_spc  usr_tokn\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if WordPos(\"?\",parms) > 0 then call HELP    /* I won't be back    */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   \"NEWSTACK\"\n   \"DFLTHLQ\"  ; pull hlq.  hlqdata\n   \"DELSTACK\"\n\n   do while hlqdata <> \"\"\n      parse var hlqdata site hlq.site hlqdata\n   end\n\n   tk_hlq  = KEYWD(\"USEHLQ\")\n   parse value tk_hlq hlq.node with hlq . /* default to prod         */\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt hlq\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n/*\n)))SLIB SQUASH\n&JOB1\n&JOB2\n&JOB3\n&JOB4\n//* -------------------------------------- ISPSLIB(SQUASH) */\n//SQUASH   EXEC PGM=IEBCOPY\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(80,(60,45))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(256,(15,1)),DCB=KEYLEN=8\n//SYSIN     DD *\n     COPY  OUTDD=INOUT,INDD=INOUT\n//INOUT     DD DISP=SHR,DSN=&DSN\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBLOOK": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\n\\x00\\x00\\x00\\x98!\\x0f\\x00\\x992?\\x13\\x08\\x02\\x8c\\x02h\\x00\\x00\\xc4\\xc5\\xd5\\xd6\\xd9\\xe3\\xc8@@@'", "ispf": {"version": "02.10", "flags": 0, "createdate": "1998-07-29T00:00:00", "modifydate": "1999-11-19T13:08:00", "lines": 652, "newlines": 616, "modlines": 0, "user": "DENORTH"}, "text": "/* REXX    TBLOOK     Display any ISPF table\n\n           Written by Frank Clarke, Oldsmar FL\n\n     Impact Analysis\n.    SYSPROC   DFLTHLQ\n.    SYSPROC   TRAPOUT\n.    SYSPROC   LA\n\n     Modification History\n     19951016 fxc upgrade REXXSKEL (950824); activate 'IN datasetname';\n     19980211 fxc leave table OPEN if it was found that way; enable\n                  SORT;\n     19980602 fxc enable Find/Locate\n     19980729 fxc upgrade from v.960119 to v.19980225;\n                  RXSKLY2K; DECOMM;\n     19991101 fxc use VIO for the panel library similar to the method\n                  used by DEIMBED.\n\n*/\naddress TSO                            /* REXXSKEL ver.19980225      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\n                                   if \\sw.0error_found then,\ncall B_BUILD_PANELS                    /*                           -*/\n\nexit                                   /*@ TBLOOK                    */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch  then call BRANCH\n   address ISPEXEC\n\n   \"CONTROL ERRORS RETURN\"             /* I'll handle my own.        */\n   alloc.0   = \"NEW CATALOG UNIT(VIO) SPACE(2 2) TRACKS DIR(5)\",\n               \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   parse value \"\" with,\n      pfkey  thisds  keynames  varnames\n\n   call AA_KEYWDS                      /*                           -*/\n\n   parse var info  tblid .\n   if tblid = \"\" then do               /* tablename not specified ?  */\n      helpmsg = \"Tablename must be specified.\"\n      call HELP; end\n\n   if tblds = \"\" then do\n      \"TBSTATS\" tblid \"STATUS2(s2)\"\n      if rc > 0 then do\n         zerrlm  = exec_name \"(\"BRANCH(\"ID\")\")\",\n                   zerrlm\n         \"SETMSG  MSG(ISRZ002)\"\n         sw.0error_found = \"1\" ; return\n         end\n      if s2 > 1 then do\n         sw.0leave_open = \"1\"\n         return\n         end\n      call AB_LISTA                    /*                           -*/\n      end\n   else do\n      if Left(tblds,1) <> \"'\" then tblds = Userid()\".\"tblds  /*\nfully-qualified  */\n                              else tblds = Strip(tblds,,\"'\") /* unquoted\n      */\n      end\n\n   do ii = 1 to Words(tblds)\n      parse var tblds thisds tblds\n      if Sysdsn(\"'\"thisds\"(\"tblid\")'\") = \"OK\" then leave\n   end                                 /* ii                         */\n\n   if Sysdsn(\"'\"thisds\"(\"tblid\")'\") <> \"OK\" then do\n      say tblid \"not found in ISPTLIB\"\n      sw.0error_found = \"1\" ; return\n      end\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nAA_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value  KEYWD(\"TBLIB\") KEYWD(\"IN\") with,\n                tblds    .\n\nreturn                                 /*@ AA_KEYWDS                 */\n/*\n   No <tblds> was specified.  Search area is ISPTLIB.\n.  ----------------------------------------------------------------- */\nAB_LISTA:                              /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"NEWSTACK\"\n   \"LA ISPTLIB ((STACK\"\n   pull tblds\n   \"DELSTACK\"\n\nreturn                                 /*@ AB_LISTA                  */\n/*\n.  ----------------------------------------------------------------- */\nB_BUILD_PANELS:                        /*@                           */\n   if branch  then call BRANCH\n   address ISPEXEC\n\n   call BA_ALLOC_PNL                   /*                           -*/\n                                   if \\sw.0error_found then,\n   call BB_OPEN                        /*                           -*/\n                                   if \\sw.0error_found then,\n   call BC_LOAD_PANELS                 /*                           -*/\n                                   if \\sw.0error_found then,\n   call BD_SHOW_TABLE                  /*                           -*/\n\n   if sw.0leave_open then nop; else,\n      \"TBEND\"  tblid\n\nreturn                                 /*@ B_BUILD_PANELS            */\n/*\n.  ----------------------------------------------------------------- */\nBA_ALLOC_PNL:                          /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   mstat = Msg(\"OFF\")\n   $ddn = \"$PNL\"Random(999)\n   \"ALLOC FI(\"$ddn\") REU\" alloc.0\n   address ISPEXEC \"LMINIT DATAID(DAID) DDNAME(\"$ddn\")\"\n   rc = Msg(mstat)                     /* restore                    */\n\nreturn                                 /*@ BA_ALLOC_PNL              */\n/*\n.  ----------------------------------------------------------------- */\nBB_OPEN:                               /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   if sw.0leave_open then return\n\n   \"CONTROL ERRORS RETURN\"\n   if thisds <> \"\" then,\n      \"LIBDEF ISPTLIB DATASET ID('\"thisds\"') STACK\"\n\n   \"TBSTATS\" tblid \"STATUS1(s1) STATUS2(s2)\"\n   if rc = 20 then do\n      say tblid \"is not a valid ISPF table\"\n      sw.0error_found = \"1\"\n      end ; else,\n   if thisds <> \"\" & s1 > 1 then do\n      say \"Table\" tblid \"not available.\"\n      sw.0error_found = \"1\"\n      end ; else,\n   if s2 = 1 then,                     /* not open                   */\n      \"TBOPEN\" tblid \"NOWRITE\"\n\n   if thisds <> \"\" then,\n      \"LIBDEF  ISPTLIB\"\n\nreturn                                 /*@ BB_OPEN                   */\n/*\n   Build the panels for the table display.\n.  ----------------------------------------------------------------- */\nBC_LOAD_PANELS:                        /*@                           */\n   if branch  then call BRANCH\n   address TSO\n\n   call BCA_GETNAMES                   /*                           -*/\n   call BCH_HEADERS                    /*                           -*/\n\n   \"NEWSTACK\"\n   call BCP_LOADP1                     /*                           -*/\n   call BCQ_LOADP2                     /*                           -*/\n   \"DELSTACK\"\n\nreturn                                 /*@ BC_LOAD_PANELS            */\n/*\n.  ----------------------------------------------------------------- */\nBCA_GETNAMES:                          /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBQUERY\" tblid \"KEYS(keynames) NAMES(varnames)\"\n   parse var keynames \"(\" keynames \")\"\n   parse var varnames \"(\" varnames \")\"\n   keynmes = keynames\n   varnmes = varnames\n   allnames = keynames varnames\n\nreturn                                 /*@ BCA_GETNAMES              */\n/*\n.  ----------------------------------------------------------------- */\nBCH_HEADERS:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   cols   = \"\"                         /* P1 column header           */\n   slug   = \" S\"                       /* P1 column header           */\n   dashes = \" -\"\n   zees   = \"14\"x\"Z\"\n   ccol   = \"\"\n   do forever\n      if allnames = \"\" then leave\n      parse var allnames var allnames  /* next field name            */\n      slug  = slug Left(var,8)\n      if Length(slug) > 78 then leave  /* too long for display       */\n      cols   = slug\n      dashes = dashes \"--------\"\n      zees   =   zees\"?Z       \"\n      ccol   = ccol var\n   end                                 /* forever                    */\n\nreturn                                 /*@ BCH_HEADERS               */\n/*\n.  ----------------------------------------------------------------- */\nBCP_LOADP1:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   queue \")ATTR                                                     \"\n   queue \" #    TYPE(TEXT)    INTENS(HIGH)                          \"\n   queue \" 14   TYPE(INPUT)   INTENS(LOW)   PAD('.')   CAPS(ON)     \"\n   queue \" ?    TYPE(OUTPUT)  INTENS(HIGH)  SKIP(ON)                \"\n   queue \")BODY EXPAND(||)                                          \"\n   queue \"+|-|-#TABLE\" tblid \"(\"thisds\")+-|-|                       \"\n   queue \"%COMMAND ===>_Z                                           \"\n   queue \"+       SORT <fld>,<typ>,<dir>  <fld>    L fld=value / F5=refind \"\n   queue cols\n   queue dashes\n   queue \")MODEL                                                    \"\n   queue zees\n   queue \")INIT                                                     \"\n   queue \"  .ZVARS='( ZCMD          $S$ +                           \"\n   queue \" \"ccol \")'\"\n   queue \"  &ZSCROLLA = 'CSR'                                       \"\n   queue \"  &$S$ = ' '                                              \"\n   queue \")REINIT                                                   \"\n   queue \")PROC                                                     \"\n   queue \"   IF (.PFKEY = 'PF05')                                   \"\n   queue \"       &PFKEY = 'F5'                                      \"\n   queue \"       .RESP = END                                        \"\n   queue \")END                                                      \"\n   \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n   do queued()\n      parse pull line\n      \"LMPUT DATAID(\"daid\") MODE(INVAR) DATALOC(LINE) DATALEN(80)\"\n   end\n   \"LMMADD DATAID(\"daid\") MEMBER(P1)\"\n   \"LMCLOSE DATAID(\"daid\")\"\n\nreturn                                 /*@ BCP_LOADP1                */\n/*\n.  ----------------------------------------------------------------- */\nBCQ_LOADP2:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   queue \")ATTR                                                     \"\n   queue \"  14   TYPE(INPUT) INTENS(LOW) PAD('.') CAPS(ON)          \"\n   queue \"  ?    TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)                 \"\n   queue \"  #    TYPE(TEXT) INTENS(HIGH)                            \"\n   queue \")BODY EXPAND(||)                                          \"\n   queue \"+|-|-#TABLE\" tblid \"(\"thisds\")+-|-|                       \"\n   queue \"%COMMAND ===>_Z                                           \"\n   queue \"+                                                         \"\n   queue \"#VARIABLE  T  VALUE+                                      \"\n   queue \"+                                                         \"\n   queue \")MODEL                                                    \"\n   queue \"?Z        ?Z ?Z                                           \"\n   queue \")INIT                                                     \"\n   queue \"  .ZVARS='( ZCMD          XVAR XTYPE XVALUE )'            \"\n   queue \"  &ZSCROLLA = 'CSR'                                       \"\n   queue \")END                                                      \"\n   \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n   do queued()\n      parse pull line\n      \"LMPUT DATAID(\"daid\") MODE(INVAR) DATALOC(LINE) DATALEN(80)\"\n   end\n   \"LMMADD DATAID(\"daid\") MEMBER(P2)\"\n   \"LMCLOSE DATAID(\"daid\")\"\n\nreturn                                 /*@ BCQ_LOADP2                */\n/*\n.  ----------------------------------------------------------------- */\nBD_SHOW_TABLE:                         /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"LIBDEF  ISPPLIB  LIBRARY  ID(\"$ddn\") STACK\"\n   \"VGET (ZPF05) PROFILE\"\n   save_f5 = zpf05\n   do forever\n                               zpf05 = \"END\"  ; \"VPUT (ZPF05) PROFILE\"\n      \"TBDISPL\" tblid \"PANEL(P1)\"\n      disp_rc = rc\n                               zpf05 = save_f5; \"VPUT (ZPF05) PROFILE\"\n      if disp_rc > 8 then do\n         zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n                  zerrlm ,\n                  \"K:\"keynmes \"N:\"varnmes\n         \"SETMSG  MSG(ISRZ002)\"\n         sw.0error_found = \"1\"\n         leave\n         end\n      if disp_rc = 8 then,\n         if pfkey = \"F5\" then call Z_REFIND        /*               -*/\n                         else leave\n      if zcmd <> \"\" then do\n         call BDC_ZCMD                 /*                           -*/\n         end ; else,\n      do ztdsels\n         \"TBGET\" tblid \"SAVENAME(xvars)\"\n         call BDA_BUILD_ROW\n         call BDB_SHOW_ROW\n         if ztdsels = 1 then,          /* never do the last one      */\n            ztdsels = 0\n         else \"TBDISPL\" tblid          /* next row                  #*/\n      end                              /* ztdsels                    */\n      action = \"\"                      /* clear for re-display       */\n   end                                 /* forever                    */\n   \"LIBDEF  ISPPLIB\"\n\nreturn                                 /*@ BD_SHOW_TABLE             */\n/*\n.  ----------------------------------------------------------------- */\nBDA_BUILD_ROW:                          /*@                           */\n   if branch  then call BRANCH\n   address ISPEXEC\n\n   \"TBCREATE XTABLE NOWRITE REPLACE NAMES(XVAR XTYPE XVALUE)\"\n   parse var xvars \"(\" xvars \")\"\n   xtype = \"K\"\n   keynames = keynmes\n   do while keynames <> \"\"\n      parse var keynames xvar keynames\n      xvalue = Value(xvar)\n      \"TBADD  XTABLE\"\n   end                                 /* keynames                   */\n   xtype = \"N\"\n   varnames = varnmes\n   do while varnames <> \"\"\n      parse var varnames xvar varnames\n      xvalue = Value(xvar)\n      \"TBADD  XTABLE\"\n   end                                 /* varnames                   */\n   xtype = \"S\"\n   do while xvars    <> \"\"\n      parse var xvars    xvar xvars\n      xvalue = Value(xvar)\n      \"TBADD  XTABLE\"\n   end                                 /* xvars                      */\n\nreturn                                 /*@ BDA_BUILD_ROW             */\n/*\n.  ----------------------------------------------------------------- */\nBDB_SHOW_ROW: Procedure expose,        /*@                           */\n      branch\n   if branch  then call BRANCH\n   address ISPEXEC\n\n   \"CONTROL DISPLAY SAVE\"\n   \"TBTOP   XTABLE\"\n   \"TBDISPL XTABLE PANEL(P2)\"\n   \"TBEND   XTABLE\"\n   \"CONTROL DISPLAY RESTORE\"\n\nreturn                                 /*@ BDB_SHOW_ROW              */\n/*\n.  ----------------------------------------------------------------- */\nBDC_ZCMD:                              /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   parse var zcmd  verb  text\n   if verb = \"SORT\" then do\n      zerrlm    = \"ZERRLM not yet set.\"\n      sortspec  = \"\"\n      do while text <> \"\"\n         parse var text  spec text\n         parse var spec  fldnm \",\" fldtyp \",\" sortdir\n         parse value  fldtyp \"C\"  with  fldtyp  .\n         parse value sortdir \"A\"  with sortdir  .\n         sortspec = sortspec fldnm\",\"fldtyp\",\"sortdir\n      end                              /* text                       */\n      sortspec = Space(sortspec,1)     /* squeeze out extra blanks   */\n      sortspec = Translate(sortspec,\",\",\" \")    /* blanks to commas  */\n      \"TBSORT\" tblid \"FIELDS(\"sortspec\")\"\n      if rc > 0 then do\n         zerrsm  = \"TBSORT failed.\"\n         zerrlm  = exec_name \"(\"BRANCH(\"ID\")\")\",\n                   zerrlm\n         \"SETMSG  MSG(ISRZ002)\"\n         end\n      end  ; else,                     /* SORT                       */\n   if Wordpos(Left(verb,1),\"F L\") > 0 then do\n      parse var text  fld . \"=\" val .\n      \"TBVCLEAR\" tblid\n      $z$ = Value(fld,val\"*\")          /* load value                 */\n      \"TBSARG\" tblid \"NAMECOND(\"fld\",EQ)\"\n      \"TBTOP\" tblid\n      call Z_TBSCAN                    /*                           -*/\n      end                              /* L LOCATE F FIND            */\n\nreturn                                 /*@ BDC_ZCMD                  */\n/*\n   Position the cursor, then TBSCAN\n.  ----------------------------------------------------------------- */\nZ_REFIND:                              /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBSKIP\" tblid \"ROW(\"lastfnd\") NOREAD\"\n   call Z_TBSCAN                       /*                           -*/\n   pfkey = \"\"                          /* prevent re-use             */\n\nreturn                                 /*@ Z_REFIND                  */\n/*\n   The table is positioned to find a row and the argument is set.\n.  ----------------------------------------------------------------- */\nZ_TBSCAN:                              /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBSCAN\" tblid \"ROWID(LASTFND) POSITION(LASTCRP)\"\n   if rc = 8 then do                   /* not found                  */\n      zerrsm = \"Not found\"\n      if pfkey = \"F5\" then,\n         zerrlm = \"End of table encountered.\"\n      else,\n         zerrlm = \"No rows found to match\" fld\"=\"val\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      address ISPEXEC \"SETMSG  MSG(ISRZ002)\"\n      end                              /* not found                  */\n   \"TBSKIP\" tblid \"ROW(\"lastfnd\") NOREAD\"\n\nreturn                                 /*@ Z_TBSCAN                  */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\n   sw.0DIAGNOSE    = SWITCH(\"DIAGNOSE\")\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n. -------------------------------------------------------------------*/\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nsay \"  TBLOOK        Displays any specified table.                    \"\nsay \"                                                                 \"\nsay \"  Syntax:   TBLOOK    <table-name>                               \"\nsay \"                      <TBLIB table-library-name>  (or)           \"\nsay \"                      <IN    table-library-name>                 \"\nsay \"                                                                 \"\npull\n\"CLEAR\"\nsay \"   Debugging tools provided include:\"\nsay \" \"\nsay \"        BRANCH:   show all paragraph entries.\"\nsay \" \"\nsay \"        TRACE tv: will use value following TRACE to place\"\nsay \"                  the execution in REXX TRACE Mode.\"\nsay \" \"\nsay \" \"\nsay \"   Debugging tools can be accessed in the following manner:\"\nsay \" \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options\"\nsay \" \"\nsay \"   For example:\"\nsay \" \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R\"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   $a#y = sigl                         /* where was I called from ?  */\n   do $b#x = $a#y to 1 by -1           /* inch backward to label     */\n      if Right(Word(Sourceline($b#x),1),1) = \":\" then do\n         parse value sourceline($b#x) with $l#n \":\" . /* Paragraph   */\n         leave ; end                   /*                name        */\n   end                                 /* $b#x                       */\n\n   select\n      when brparm = \"NAME\" then return($l#n) /* Return full name     */\n      when brparm = \"ID\"      then do  /*        Return prefix       */\n         parse var $l#n $l#n \"_\" .     /* get the prefix             */\n         return($l#n)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left($l#n,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   address TSO \"CLEAR\"\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\n   address TSO \"CLEAR\"\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\" ,\nerrortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Requires DFLTHLQ.  Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm  as_invokt  ,\ncmd_env  addr_spc  usr_tokn\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   \"NEWSTACK\"\n   \"DFLTHLQ\"  ; pull hlq.  hlqdata\n   \"DELSTACK\"\n\n   do while hlqdata <> \"\"\n      parse var hlqdata site hlq.site hlqdata\n   end\n\n   tk_hlq  = KEYWD(\"USEHLQ\")\n   parse value tk_hlq  hlq.node   with  hlq  .  /* default to prod   */\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt hlq\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRAPOUT": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x13\\x00\\x00\\x00\\x95\\x12/\\x00\\x95'\\x7f\\x143\\x00\\x15\\x00\\x0c\\x00\\x00\\xc4\\xe3\\xc3\\xc6\\xe7\\xc3\\xf1@@@\"", "ispf": {"version": "01.19", "flags": 0, "createdate": "1995-05-02T00:00:00", "modifydate": "1995-10-04T14:33:00", "lines": 21, "newlines": 12, "modlines": 0, "user": "DTCFXC1"}, "text": "/* Rexx */ /* This is REXX EXEC \"TRAPOUT\" to trap line output */\naddress TSO\nrc=trace(\"O\")\n\"EXECUTIL TE\"\nParse arg TSOCMD     /* A TSO Command will be the input parm */\nrc = Outtrap(\"OUT.\")  /* Turn on outtrap, to rexx stem OUT. */\n(TSOCMD) \"((TRACE R\"    /* Do the command */\nrc = Outtrap(\"OFF\")\n\nIf OUT.0 > 0 Then Do             /* If any output, write to the file */\n   dsdate = Right(date(\"S\"),6)           /* 950118 maybe               */\n   dstime = time()\n   parse var dstime th \":\" tm \":\" ts .\n   dstime = Right(th,2,0)Right(tm,2,0)Right(ts,2,0)\n   dsn = \"TRAPOUT.D\"dsdate\".T\"dstime\".TRCLIST\"\n   X = Msg(\"OFF\");\"DEL\" dsn ;X= Msg(\"ON\")\n   \"ALLOC FI(TRAPOUT) DA(\"dsn\") NEW CATALOG REU SP(5,5) CYL \",\n            \"RECFM(V B) LRECL(255) BLKSIZE(0)\"\n   \"EXECIO\" out.0 \"DISKW TRAPOUT (STEM OUT. FINIS\"\n   \"FREE  FI(TRAPOUT)\"\n   end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "X2B": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x940\\x0f\\x00\\x940\\x0f\\x195\\x00j\\x00\\x01\\x00\\x00\\xc4\\xe3\\xc3\\xc6\\xe7\\xc3\\xf1@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-10-27T00:00:00", "modifydate": "1994-10-27T19:35:00", "lines": 106, "newlines": 1, "modlines": 0, "user": "DTCFXC1"}, "text": "/* REXX    X2B        Hexadecimal-to-Binary converter fills in a gap\n                      in the conversion routines built into REXX.\n\n           Input to this subroutine is a hexadecimal string (length\n           2n).  Output is a binary string (length 8n).\n\n                Written by Frank Clarke, Oldsmar, FL\n\n*/\naddress TSO                            /*                            */\nsignal on syntax                       /*                            */\ntv = ''                                /*                            */\narg parms \"((\" opts                    /*                            */\nopts = Strip(opts,T,\")\")               /* clip trailing paren        */\n                                       /*                            */\nparse var opts \"TRACE\" tv .            /*                            */\nif tv \u00ac= '' then rc = trace(tv)        /*                            */\nbroken = SWITCH(BROKEN)                /*                            */\nif broken then spacer = \" \"            /*                            */\n          else spacer = \"\"             /*                            */\n                                       /*                            */\nif parms = '' then call HELP           /*                            */\nif Word(parms,1) = '?' then call HELP  /*                            */\n                                       /*                            */\nparse var parms hex_str                /*                            */\nhex_str = Space(hex_str,0)             /*                            */\nbits.  = \"?\"                           /*                            */\nbits.0 = \"0000\"                        /*                            */\nbits.1 = \"0001\"                        /*                            */\nbits.2 = \"0010\"                        /*                            */\nbits.3 = \"0011\"                        /*                            */\nbits.4 = \"0100\"                        /*                            */\nbits.5 = \"0101\"                        /*                            */\nbits.6 = \"0110\"                        /*                            */\nbits.7 = \"0111\"                        /*                            */\nbits.8 = \"1000\"                        /*                            */\nbits.9 = \"1001\"                        /*                            */\nbits.A = \"1010\"                        /*                            */\nbits.B = \"1011\"                        /*                            */\nbits.C = \"1100\"                        /*                            */\nbits.D = \"1101\"                        /*                            */\nbits.E = \"1110\"                        /*                            */\nbits.F = \"1111\"                        /*                            */\nret_str = ''                           /*                            */\n                                       /*                            */\ndo while hex_str \u00ac= ''                 /*                            */\n   parse var hex_str hi 2 lo 3 hex_str /* F 4 C1D5 maybe             */\n   ret_str = ret_str || spacer || bits.hi || bits.lo\nend                                    /*                            */\n                                       /*                            */\nret_str = Strip(ret_str)               /*                            */\nif Sysvar(Sysnest) = \"YES\" then,       /*                            */\n   return ret_str                      /*                            */\nelse say  ret_str                      /*                            */\n                                       /*                            */\nexit                                   /*                            */\n                                       /*                            */\n/*-------------------------------------------------------------------*/\nHELP:                                  /*@                           */\nsay \"HELP for\" Sysvar(Sysicmd) \"not available\"\nexit                                   /*@ HELP                      */\naddress TSO \"CLEAR\"                    /*                            */\nsay \"                                                                 \"\n                                       /*\n       ........      .........\n                     ...\n\n       Syntax:   ........  .........\n                           ...\n\n                 ...........\n                 ...\n                                                                     */\nsay \"                                                                 \"\nexit                                   /*@ HELP                      */\n                                       /*                            */\n/*-------------------------------------------------------------------*/\nKEYWD: Procedure expose,               /*@                           */\n       kw parms                        /*                            */\narg kw .                               /*                            */\nif Wordpos(kw,parms) = 0 then,         /*                            */\n   kw_val = ''                         /*                            */\nelse,                                  /*                            */\nif Wordpos(kw,parms) = 1 then,         /*                            */\n   kwa = kw\" \"                         /*                            */\nelse kwa = \" \"kw\" \"                    /*                            */\nparse var parms . value(kwa)  kw_val .\nif kw_val <> '' then parms = Delword(parms,Wordpos(value(kw),parms),2)\nreturn kw_val                          /*@ KEYWD                     */\n                                       /*                            */\n/*-------------------------------------------------------------------*/\nSWITCH:                                /*@                           */\narg kw .                               /*                            */\nsw_val  = Wordpos(value(kw),parms) > 0\nif sw_val  then parms = Delword(parms,Wordpos(value(kw),parms),1)\nreturn sw_val                          /*@ SWITCH                    */\n                                       /*                            */\n/*-------------------------------------------------------------------*/\nSYNTAX:                                /*@                           */\n   errormsg = \"REXX error\" rc \"in line\" sigl\":\" errortext(rc)\n   say errormsg                        /*                            */\n   say sourceline(sigl)                /*                            */\n   trace \"?r\"                          /*                            */\n   nop                                 /*                            */\nexit                                   /*@ SYNTAX                    */\n                                       /*                            */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT435/FILE435.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT435", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}