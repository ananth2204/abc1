{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "T311LBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20171218115401000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 32720, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "T311LBD.ZSTART.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"T311LBD.ZSTART.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 32720, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 32760, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "170352", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x03'", "DS1LSTAR": "b'\\x00\\x05\\x02'", "DS1TRBAL": "b'x\\xdc'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\r\\xf0\\x00\\x04\\x97\\xe0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\r\\xf0\\x00\\x04\\x97\\xe0\\xd8'", "b'X\\x9f\\x83\\xb8\\x00\\x00\\x01Q\\x00\\x0b\\x01R\\x00\\x01\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$READ": {"ttr": 4, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Y\\x01\\x16\\x11\\x0f\\x01\\x16\\x11\\x1f\\x05\\x15\\x00\\x05\\x00\\x04\\x00\\x00\\xe9\\xe2\\xe3\\xc1\\xd9\\xe3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-04-19T00:00:00", "modifydate": "2016-04-20T05:15:59", "lines": 5, "newlines": 4, "modlines": 0, "user": "ZSTART"}, "text": "The contents of this PDS are:\n\n   $DOC     - short documentation on the exec and zstart\n   $CHANGES - Change History\n   ZSTART   - the rexx code with imbedded panels\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CHANGES": {"ttr": 261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x009\\x01\\x16\\x11\\x1f\\x01\\x174o\\x060\\x00\\x1c\\x00\\t\\x00\\x00\\xe9\\xe2\\xe3\\xc1\\xd9\\xe3@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2016-04-20T00:00:00", "modifydate": "2017-12-12T06:30:39", "lines": 28, "newlines": 9, "modlines": 0, "user": "ZSTART"}, "text": "Change History:\n\n12/12/17 - v2.3 Fix typo on panel\n08/16/17 - v2.2 Make variable lines scrollable\n03/14/17 - v2.1 Change to use VIO for temp d/s\n05/02/16 - v2.0 Removes and adds back \"ISPF;\"\n           command, ensuring \"ISPF;\" is always\n           the 1st command in ZSTART.\n04/25/16 - v1.7 Wordsmith on Panel\n04/23/16 - v1.6 Data Lost Prevention\n         - If cview is 1 or 2 and row 7 is >\n           71 then change cview to 2 or 3\n04/22/16 - v1.5 New Function\n         - Add save into ISPPROF as well as\n           default ISRPROF\n04/21/16 - v1.4 Bug fix\n         - Fix bug if user add ending ;\n04/21/16 - v1.3 Update\n         - Save/Use CVIEW in profile\n04/21/16 - v1.2 Update\n         - Add compact views\n04/20/16 - v1.1 Update\n         - Add version\n         - Improved parse for short zstart\n           variables\n         - Add message indicating creating\n           zstart variable\n04/19/16 - v1.0 Creation\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$DOC": {"ttr": 6, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00 \\x01\\x16\\x11\\x0f\\x01\\x16\\x14\\x0f\\x12#\\x00 \\x00\\x19\\x00\\x00\\xe9\\xe2\\xe3\\xc1\\xd9\\xe3@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2016-04-19T00:00:00", "modifydate": "2016-05-19T12:23:20", "lines": 32, "newlines": 25, "modlines": 0, "user": "ZSTART"}, "text": "IBM has provided since z/OS 2.1 in ISPF the ability to define a set of ISPF\ncommands to be invoked each time ISPF starts. This list is stored in the ISPF\nProfile Variable ZSTART under the ISR Profile.  This list can be considered\nsimilar to the Windows Startup Folder.\n\nTo simplify reviewing and updating this startup list a new ISPF dialog is being\nmade available using the ZSTART REXX exec that is access on any ISPF command\nline:  TSO %ZSTART\n\nThe format of the startup list is:\n\n  1. Multiple commands on a line must be separated by a colon (;)\n  2. TSO Commands must be prefixed by TSO\n     - the same as is required when manually invoked under ISPF\n  3. ISPF commands require no prefix\n\nSample:\n\n  Start 3.4;start QW;Swap 1\n\nThis sample will create three ISPF screens. The first is the default\nISPF Primary Options Menu, and then it will start a second session\nwith ISPF 3.4. After starting the ISPF 3.4 display it will start a\nthird session with MVS QuickRef and then Swap back to the first\nsession.\n\nIF ISPF is started with an option (e.g. ISPF 3.4) then the ZSTART\nvariable startup list will be ignored.\n\nNote: When the variable is saved the string \"ISPF;\" will be prefixed\nto it as that is a requirement but there is no need for it in this\ndialog.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZSTART": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x175/\\x01\\x175/\\x05S\\x02\\xdc\\x02\\xdc\\x00\\x00\\xe9\\xe2\\xe3\\xc1\\xd9\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-12-18T00:00:00", "modifydate": "2017-12-18T05:53:47", "lines": 732, "newlines": 732, "modlines": 0, "user": "ZSTART"}, "text": "/* --------------------  rexx procedure  -------------------- */\n ver = '2.3'\n/* Name:      zstart                                          *\n *                                                            *\n * Function:  Create/Update the ISPF Profile variable         *\n *            ZSTART which is used each time ISPF Starts      *\n *            to setup the ISPF envionrment.                  *\n *                                                            *\n * Syntax:    %zstart option                                  *\n *                                                            *\n * Notes:     1. option is used internally to pass the        *\n *               zstart variable info so it can be            *\n *               saved under the ISP profile.                 *\n *               option must start with ISP: and then         *\n *               the zstart values                            *\n *            2. The ISPF panel is included inline at the     *\n *               end of this exec and is loaded dynamically   *\n *               by the loadispf subroutine                   *\n *            3. Each variable line is scrollable upto        *\n *               1024 characters                              *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *            Bruce Koss (Collaborator)                       *\n *                                                            *\n * History:                                                   *\n *            12/12/17 - v2.3 Fix typo on panel               *\n *            08/16/17 - v2.2 Make variable lines scrollable  *\n *            03/14/17 - v2.1 Change to use VIO for temp d/s  *\n *            05/02/16 - v2.0 Removes and adds back \"ISPF;\"   *\n *                       command, ensuring \"ISPF;\" is always  *\n *                       the 1st command in ZSTART.           *\n *            04/25/16 - v1.7 Wordsmith on Panel              *\n *            04/23/16 - v1.6 Data Lost Prevention            *\n *                     - If cview is 1 or 2 and row 7 is >    *\n *                       71 then change cview to 2 or 3       *\n *            04/22/16 - v1.5 New Function                    *\n *                     - Add save into ISPPROF as well as     *\n *                       default ISRPROF                      *\n *            04/21/16 - v1.4 Bug fix                         *\n *                     - Fix bug if user add ending ;         *\n *            04/21/16 - v1.3 Update                          *\n *                     - Save/Use CVIEW in profile            *\n *            04/21/16 - v1.2 Update                          *\n *                     - Add compact views                    *\n *            04/20/16 - v1.1 Update                          *\n *                     - Add version                          *\n *                     - Improved parse for short zstart      *\n *                       variables                            *\n *                     - Add message indicating creating      *\n *                       zstart variable                      *\n *            04/19/16 - v1.0 Creation                        *\n *                                                            *\n * ---------------------------------------------------------- */\n\n parse arg options\n\n parse value '' with null\n\n/* -------------------------------------------- *\n * Check for applid of ISR and get there is not *\n * BUT Do not do this if called with options    *\n * -------------------------------------------- */\n Address ISPExec\n if left(options,4) /= \"ISP:\" then do\n    \"Vget (Zapplid)\"\n    \"Control Errors Return\"\n    if zapplid <> \"ISR\" then do\n       \"Select CMD(%\"sysvar('sysicmd') options \") Newappl(isr)\"\n       exit 0\n       end\n    end\n else do\n      parse value options with \"ISP:\"zstart\n      'Vput zstart profile'\n      zedsmsg = \"Saved\"\n      zedlmsg = \"The ZSTART ISPF Profile variable\" ,\n                \"has been saved and will be used\" ,\n                \"the next time ISPF starts.\"\n      \"Setmsg msg(isrz001)\"\n      Exit 0\n      end\n\n/* ------------------------------ *\n * Load the ISPF Panels and start *\n * ------------------------------ */\n load_info = loadispf()\n\n/* ------------------------------------ *\n * Get ISPF Variables from the Profile: *\n * ZSTART - ispf startup variable       *\n * CVIEW  - commands per row            *\n * ------------------------------------ */\n 'vget (zstart cview) profile'\n if datatype(cview) /= 'NUM' then cview = 1\n ocview = cview\n if length(zstart) = 0 then create = 1\n                       else create = 0\n\n/* ------------------------------------------- *\n * ReStart - label to restart if cview changed *\n * ------------------------------------------- */\nReStart:\n/* ------------------------------------------------------------- *\n * Check for length of zstart and create if not found. Otherwise *\n * process zstart commands onto the rows based on the cview      *\n * value.                                                        *\n *                                                               *\n * Remove ISPF; from zstart prefix if there - will add back later*\n * ------------------------------------------------------------- */\n if left(translate(zstart),5) = \"ISPF;\" then\n    zstart = substr(zstart,6)\n if length(zstart) = 0\n    then z1 = zstart\n    else Select\n   /* ------------------- *\n    * One command per row *\n    * ------------------- */\n    When cview = 1 then do\n         parse value zstart with z1';'z2\n         parse value z2 with z2';'z3\n         parse value z3 with z3';'z4\n         parse value z4 with z4';'z5\n         parse value z5 with z5';'z6\n         parse value z6 with z6';'z7\n         if right(z7,1) = ';' then\n            z7 = left(z7,length(z7)-1)\n         status = \"updated\"\n        /* ------------------------------------------ *\n         * Check for length and reset cview if needed *\n         * ------------------------------------------ */\n         if length(z7) > 71 then do\n            cview = 2\n            reset = 1\n            zedsmsg = \"Reflow\"\n            zedlmsg = \"Columns per Row of 1 would result\" ,\n                      \"in data truncation so changed to 2.\"\n            signal restart\n            end\n         if reset = 1 then \"Setmsg msg(isrz001)\"\n         end\n   /* -------------------- *\n    * Two commands per row *\n    * -------------------- */\n    When cview = 2 then do\n         parse value zstart with w1';'w2';'zstart\n         if length(w2) > 0\n            then z1 = w1';'w2\n            else z1 = w1\n         parse value zstart with w1';'w2';'zstart\n         if length(w2) > 0\n            then z2 = w1';'w2\n            else z2 = w1\n         parse value zstart with w1';'w2';'zstart\n         if length(w2) > 0\n            then z3 = w1';'w2\n            else z3 = w1\n         parse value zstart with w1';'w2';'zstart\n         if length(w2) > 0\n            then z4 = w1';'w2\n            else z4 = w1\n         parse value zstart with w1';'w2';'zstart\n         if length(w2) > 0\n            then z5 = w1';'w2\n            else z5 = w1\n         parse value zstart with w1';'w2';'zstart\n         if length(w2) > 0\n            then z6 = w1';'w2\n            else z6 = w1\n         parse value zstart with w1';'w2';'zstart\n         if length(w2) > 0\n            then z7 = w1';'w2\n            else z7 = w1\n         status = \"updated\"\n        /* ------------------------------------------ *\n         * Check for length and reset cview if needed *\n         * ------------------------------------------ */\n         if length(z7) > 71 then do\n            cview = 3\n            reset = 1\n            zedsmsg = \"Reflow\"\n            zedlmsg = \"Columns per Row of 2 would result\" ,\n                      \"in data truncation so changed to 3.\"\n            signal restart\n            end\n         if reset = 1 then \"Setmsg msg(isrz001)\"\n         end\n   /* ---------------------- *\n    * Three commands per row *\n    * ---------------------- */\n    When cview = 3 then do\n         parse value zstart with w1';'w2';'w3';'zstart\n         wx = null\n         Select\n            when length(w1) > 0 & length(w2) > 0 & length(w3) > 0\n                 then wx = w1';'w2';'w3\n            when length(w1) > 0 & length(w2) > 0\n                 then wx = w1';'w2\n            when length(w1) > 0\n                 then wx = w1\n            otherwise nop\n            end\n            z1 = wx\n         parse value zstart with w1';'w2';'w3';'zstart\n         wx = null\n         Select\n            when length(w1) > 0 & length(w2) > 0 & length(w3) > 0\n                 then wx = w1';'w2';'w3\n            when length(w1) > 0 & length(w2) > 0\n                 then wx = w1';'w2\n            when length(w1) > 0\n                 then wx = w1\n            otherwise nop\n            end\n            z2 = wx\n         parse value zstart with w1';'w2';'w3';'zstart\n         wx = null\n         Select\n            when length(w1) > 0 & length(w2) > 0 & length(w3) > 0\n                 then wx = w1';'w2';'w3\n            when length(w1) > 0 & length(w2) > 0\n                 then wx = w1';'w2\n            when length(w1) > 0\n                 then wx = w1\n            otherwise nop\n            end\n            z3 = wx\n         parse value zstart with w1';'w2';'w3';'zstart\n         wx = null\n         Select\n            when length(w1) > 0 & length(w2) > 0 & length(w3) > 0\n                 then wx = w1';'w2';'w3\n            when length(w1) > 0 & length(w2) > 0\n                 then wx = w1';'w2\n            when length(w1) > 0\n                 then wx = w1\n            otherwise nop\n            end\n            z4 = wx\n         parse value zstart with w1';'w2';'w3';'zstart\n         wx = null\n         Select\n            when length(w1) > 0 & length(w2) > 0 & length(w3) > 0\n                 then wx = w1';'w2';'w3\n            when length(w1) > 0 & length(w2) > 0\n                 then wx = w1';'w2\n            when length(w1) > 0\n                 then wx = w1\n            otherwise nop\n            end\n            z5 = wx\n         parse value zstart with w1';'w2';'w3';'zstart\n         wx = null\n         Select\n            when length(w1) > 0 & length(w2) > 0 & length(w3) > 0\n                 then wx = w1';'w2';'w3\n            when length(w1) > 0 & length(w2) > 0\n                 then wx = w1';'w2\n            when length(w1) > 0\n                 then wx = w1\n            otherwise nop\n            end\n            z6 = wx\n         parse value zstart with w1';'w2';'w3';'zstart\n         wx = null\n         Select\n            when length(w1) > 0 & length(w2) > 0 & length(w3) > 0\n                 then wx = w1';'w2';'w3\n            when length(w1) > 0 & length(w2) > 0\n                 then wx = w1';'w2\n            when length(w1) > 0\n                 then wx = w1\n            otherwise nop\n            end\n            z7 = wx\n         status = \"updated\"\n         end\n    otherwise nop\n    end\n\n if create = 1 then\n    status = \"created\"\n\n do forever\n parse value '' with null reset\n \"Display Panel(zstart)\"\n drc = rc\n if translate(zcmd) = 'CANCEL' then do\n    zedsmsg = \"Cancelled\"\n    zedlmsg = \"The ZSTART ISPF Profile variable\" ,\n              \"has been NOT been\" status\".\"\n    \"Setmsg msg(isrz001)\"\n    leave\n    end\n if drc = 0 then\n   if ocview /= cview then do\n      ocview = cview\n      if right(z1,1) = ';' then z1 = left(z1,length(z1)-1)\n      if z2 /= '' then zstart = z1';'z2\n         if right(zstart,1) = ';' then\n            zstart = left(zstart,length(zstart)-1)\n      if z3 /= '' then zstart = zstart';'z3\n         if right(zstart,1) = ';' then\n            zstart = left(zstart,length(zstart)-1)\n      if z4 /= '' then zstart = zstart';'z4\n         if right(zstart,1) = ';' then\n            zstart = left(zstart,length(zstart)-1)\n      if z5 /= '' then zstart = zstart';'z5\n         if right(zstart,1) = ';' then\n            zstart = left(zstart,length(zstart)-1)\n      if z6 /= '' then zstart = zstart';'z6\n         if right(zstart,1) = ';' then\n            zstart = left(zstart,length(zstart)-1)\n      if z7 /= '' then zstart = zstart';'z7\n         if right(zstart,1) = ';' then\n            zstart = left(zstart,length(zstart)-1)\n      signal ReStart\n      end\n if rc = 8 then zcmd = \"SAVE\"\n if zcmd = 'SAVE' then do\n    if translate(left(z1,5)) /= 'ISPF;'\n       then zstart = \"ISPF;\"z1\n       else zstart = z1\n    if z2 /= '' then zstart = zstart';'z2\n    if z3 /= '' then zstart = zstart';'z3\n    if z4 /= '' then zstart = zstart';'z4\n    if z5 /= '' then zstart = zstart';'z5\n    if z6 /= '' then zstart = zstart';'z6\n    if z7 /= '' then zstart = zstart';'z7\n    'vput (zstart cview) profile'\n    options = \"ISP:\"zstart\n    \"Select CMD(%\"sysvar('sysicmd') options \") Newappl(isp)\"\n    leave\n    end\n end\n\n/* ------------------------------------ *\n * Now free up the loadispf allocations *\n * and exit the dialog                  *\n * ------------------------------------ */\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n       if libd = \"ALTLIBC\" then lib = \"CLIST\"\n                           else lib = \"EXEC\"\n       Address TSO,\n         \"Altlib Deact Application(\"lib\")\"\n       end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n    end\n exit\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    rc = loadispf()                                 *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          Address ISPEXEC                                   *\n *          do until length(load_info) = 0                    *\n *             parse value load_info with dd libd load_info   *\n *             if left(libd,6) = \"ALTLIB\" then do             *\n *                if libd = \"ALTLIBC\" then lib = \"CLIST\"      *\n *                                    else lib = \"EXEC\"       *\n *                Address TSO,                                *\n *                  \"Altlib Deact Application(\"lib\")\"         *\n *                end                                         *\n *             else \"libdef\" libd                             *\n *             address tso \"free f(\"dd\")\"                     *\n *             end                                            *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\n LoadISPF: Procedure\n\n parse value \"\" with null kmsg kpanel kskel first returns ,\n                     kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n last_line = sourceline()\n do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n    end\n rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n    end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n clistdd = \"lc\"random(999)\n execdd  = \"le\"random(999)\n msgdd   = \"lm\"random(999)\n paneldd = \"lp\"random(999)\n skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd ALTLIBC)\n    end\n if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd ALTLIBE)\n    end\n if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd ISPMLIB)\n    end\n if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd ISPPLIB)\n    end\n if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd ISPSLIB)\n    end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n       if first = 1 then call add_it\n       type = \"Clist\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">EXEC \" then do\n       if first = 1 then call add_it\n       type = \"Exec\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,5) = \">MSG \" then do\n       if first = 1 then call add_it\n       type = \"Msg\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,7) = \">PANEL \" then do\n       if first = 1 then call add_it\n       type = \"Panel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">SKEL \" then do\n       if first = 1 then call add_it\n       type = \"Skel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n           \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n           \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n           \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n           \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n           \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      end\n    end\n if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n if kclist <> null then do\n    Address TSO,\n    \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n    end\n if kexec <> null then do\n    Address TSO,\n    \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n    end\n if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n    end\n if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n    end\n if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n    end\n return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\n Add_It:\n Select\n    When type = \"Clist\" then\n         \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n         \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n         \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n         \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n         \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n    end\n type = null\n return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\n Alloc_DD:\n arg dd\n Address TSO\n if pos(left(dd,2),\"lc le\") > 0 then\n \"Alloc f(\"dd\") unit(vio) spa(5,5) dir(1)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n else\n \"Alloc f(\"dd\") unit(vio) spa(5,5) dir(1)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n return\n\n/* --------------------------------- *\n * Start of the inline ISPF Elements *\n * --------------------------------- */\n>START\n>PANEL ZSTART\n)Attr Default(@+_)\n  + TYPE(TEXT)  INTENS(LOW)  SKIP(ON) COLOR(GREEN)\n  _ type(input)  caps(off)\n  $ type(input)  caps(off) hilite(uscore)\n  # TYPE(OUTPUT) INTENS(Low ) CAPS(OFF) JUST(ASIS )\n)Body expand(\\\\)\n+-\\-\\-(@ZSTART - ISPF Profile Variable V&ver+)-\\-\\-\n@Command ===>_ZCMD / /\n+\\ \\@Commands Per Row_z+(1 to 3)\n+\n+  Edit the ISPF Profile variable@ZSTART+which is used at ISPF startup.\n+                                                                       @Scroll\n+ $z1                                                                    #z +\n+ $z2                                                                    #z +\n+ $z3                                                                    #z +\n+ $z4                                                                    #z +\n+ $z5                                                                    #z +\n+ $z6                                                                    #z +\n+ $z7                                                                    #z +\n+\n+  The@ZSTART+variable may contain any ISPF commands and each is separated\n+  by a semi-colon@';'+if more than one command is on a line. A line\n+  ending semi-colon is NOT required. For example:\n+\n+           @START 3.4;START 6;SWAP 1\n+\n+  This will start 3 split screens: ISPF Primary Menu, ISPF 3.4 and ISPF 6.\n+\n  @Note:+Lines are scrollable up to 1024 characters.\n)INIT\n .zvars = '(cview zi1 zi2 zi3 zi4 zi5 zi6 zi7)'\n .CURSOR = 'ZCMD'\n .Help = zstarth\n)PROC\n)Field\n Field(z1) ind(zi1,'<>') len(1024)\n Field(z2) ind(zi2,'<>') len(1024)\n Field(z3) ind(zi3,'<>') len(1024)\n Field(z4) ind(zi4,'<>') len(1024)\n Field(z5) ind(zi5,'<>') len(1024)\n Field(z6) ind(zi6,'<>') len(1024)\n Field(z7) ind(zi7,'<>') len(1024)\n)END\n>PANEL ZSTARTH\n)Attr Default(@+_)\n   + TYPE(TEXT)  INTENS(LOW)  SKIP(ON) COLOR(GREEN)\n)Body expand(\\\\)\n@Tutorial+-\\-\\-(@ZSTART - ISPF Profile Variable+)-\\-\\-@Tutorial\n+Command ===>_zcmd\n+\n+  The@ZSTART+ISPF Profile variable allows starting up multiple split screens\n+  at ISPF invocation.\n+\n+  Be aware that each@ZSTART+command is placed on separate lines in the display\n+  for easy editing. Use Commands Per Row to change this. Scroll Right/Left\n+  is enable per row up to 1024 characters.\n+\n+  The variable may contain any ISPF command with each separated by the\n+  delimiter (;), then start the logical screens or execute primary commands\n+  separated by a semi-colon (;). The@ISPF;+prefix will be added when saved.\n+\n+  All ISPF or TSO commands may be coded. TSO commands should start with TSO.\n+\n+  The following example invokes ISPF 3.4, starts a split screen and executes\n+  a REXX program called WHEREAMI\n+\n+   @3.4;START;TSO %WHEREAMI\n+\n+  To save the entries, press@F3+(END) and to@not+save the entries, type in\n+ @CANCEL.\n)PROC\n &zcont = zstarth\n)END\n>END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT314/CBT.V500.FILE314.PDS/ZSTART.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT314/CBT.V500.FILE314.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}