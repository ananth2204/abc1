{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "T311LBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20160531181300000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 32760, "INMRECFM": "VB", "INMDIR": 6, "INMDSNAM": "T311LBD.LIONEL.EXEC", "INMMEMBR": "T311LBD.LIONEL.EXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"T311LBD.LIONEL.EXEC": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 32760, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 32760, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "160152", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x01,'", "DS1LSTAR": "b'\\x01V\\x04'", "DS1TRBAL": "b'O\\x8e'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x1b\\x80\\x00\\x04\\x98\\xd0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x1b\\x80\\x00\\x04\\x98\\xd0\\xd8'", "b'X\\x9f\\x8f\\x88\\x00\\x00\\x0f`\\x00\\x01\\x0fy\\x00\\x04\\x01{'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"TXT2CSV": {"ttr": 87555, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00 \\x01\\x10#_\\x01\\x16\\x15/\\x13\\x11\\x018\\x01\\x1b\\x00\\x00\\xe3\\xf3\\xf1\\xf1\\xd3\\xc2\\xc4@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2010-08-23T00:00:00", "modifydate": "2016-05-31T13:11:20", "lines": 312, "newlines": 283, "modlines": 0, "user": "T311LBD"}, "text": "        /* --------------------  rexx procedure  -------------------- */\n        ver = \"0.6\"\n        /* Name:      txt2csv                                         *\n         *                                                            *\n         * Function:  program to convert a text file to csv format    *\n         *                                                            *\n         * Syntax:    %txt2csv input_dsn output_dsn c1 c2 ... / opt's *\n         *            or                                              *\n         *            txt2csv inputfile outputfile c1 c1 ... / opt's  *\n         *                                                            *\n         *            if z/OS:                                        *\n         *            input_dsn   sequential or pds member            *\n         *            output_dsn  sequential file to be created       *\n         *                                                            *\n         *            both accept DD:ddname to use a DD for input     *\n         *            or output                                       *\n         *                                                            *\n         *            if z/VM                                         *\n         *            inputfile   fn ft fm of input                   *\n         *            outputfile  fn ft fm of output                  *\n         *                        and '=' may be used for each fileid *\n         *                            except for the fn               *\n         *                                                            *\n         *            c1 etc      column start position               *\n         *                        (if preceeded by - then the column  *\n         *                         is eliminated in the output)       *\n         *            *           compacts blanks and convert them to *\n         *                        the csv delimiter                   *\n         *            /           a delimeter for following options   *\n         *            debug       optional - also abbreviated         *\n         *            csv csvchar desired csv separator 'csvchar'     *\n         *                        instead of defaulted comma, it must *\n         *                        be quoted when special character    *\n         *                                                            *\n         * Author:    Lionel B. Dyck                                  *\n         *            E-Mail: lbdyck@gmail.com                        *\n         *                                                            *\n         * History:                                                   *\n         *            05/31/16 - v0.6 minor bug fix                   *\n         *                       thanks to Larry Slaten               *\n         *            08/25/10 - v0.5 minor bug fix                   *\n         *            08/23/10 - v0.4 add support for z/VM usage      *\n         *                     - remove extraneous trailing comma's   *\n         *                     - csv default character ',' now can be *\n         *                       overriden by a parm / csv ';'        *\n         *                       (update from Orazio Scaggion)        *\n         *                     - '*' instead of column start positions*\n         *                       causes compaction and replacing of   *\n         *                       blanks with csv character.           *\n         *                       (update from Orazio Scaggion)        *\n         *            02/03/09 - v0.3 remove leading blank            *\n         *                     - add version to report                *\n         *            01/15/08 - v0.2 (update from David Clark)       *\n         *                     - add code so that a colm prefixed by  *\n         *                       a - will be skipped ex 2 8 -15 30    *\n         *                       this would bypass data in 15-29     *\n         *            01/08/08 - v0.1 converted from csvedit rexx code*\n         *                                                            *\n         * ---------------------------------------------------------- */\n\n         parse source with a b c d e os\n         if os /= 'CMS' then os = ''\n\n        /* -------------------- *\n         * Setup Default Values *\n         * -------------------- */\n         parse value \"\" with null inputdd outputdd out. csv  ,\n                             ifn ift ifm ofn oft ofm\n         outc  = 0\n         wrkdd = \"CSV\"random(99)random(99)\n         sep_default = \",\"\n\n        /* -------------------------- *\n         * Parse Execution Parameters *\n         * -------------------------- */\n         if os = '' then\n         arg input output columns \"/\"debug\n         else do\n              arg ifn ift ifm ofn oft ofm columns \"/\"debug\n              if oft = \"=\" then oft = ift\n              if ofm = \"=\" then ofm = ifm\n              end\n\n        /* -------------------------- *\n         * Check for input parameters *\n         * -------------------------- */\n         if os = ''\n            then if length(input) = 0 then do\n                say 'Invalid syntax - correct syntax is:'\n                say ' '\n                say '%txt2csv input_dsn output_dsn col1 col2 col3 ...'\n                exit 8\n                end\n         if os /= ''\n            then if length(ifn) = 0 then do\n                say 'Invalid syntax - correct syntax is:'\n                say ' '\n                say 'txt2csv infn inft infm outfn outft outfm col1 col2 ...'\n                exit 8\n                end\n\n        /* -------------------- *\n         * Keep the user posted *\n         * -------------------- */\n         Say \"TXT2CSV Processing has started. Version\"  ver ,\n             date() time()\n\n        /* ------------------- *\n         * Validate Parameters *\n         * ------------------- */\n         pos_debug = 0\n         do i = 1 to words(debug)\n            if abbrev('DEBUG',word(debug,i),1)\n            then do\n                 trace \"?i\"\n                 pos_debug = i\n                 leave\n                 end\n         end\n         if pos_debug <> 0\n         then csv = strip(delword(debug,pos_debug,1))\n         else csv = strip(debug)\n\n         pos_csv = wordpos('CSV',csv)\n         if pos_csv <> 0\n         then do\n              csv = strip(delword(csv,pos_csv,1))\n              qt = left(csv,1)\n        /* check if csv is quoted by open and close parentheses or by\n                                  single or double quotation marks   */\n              if pos(qt,x2c('4d7d7f')) <> 0\n              then csv = substr(csv,2,1) /* pair of quotes assumed */\n              else csv = left(csv,1)     /* else it is not quoted  */\n              end\n         else csv = sep_default\n         sep = csv\n\n         if pos('*',columns) <> 0\n         then ignore_columns = \"and column values being ignored\"\n         else ignore_columns = null\n         Say \"CSV character:\" sep\n         Say \"  \" ignore_columns\n\n         if os = '' then\n         if input <> null then do\n            if left(input,3) = \"DD:\"\n               then do\n                    parse value input with \"DD:\"inputdd\n                    input = null\n                    Say \"Using Input DD:\" inputdd\n                    end\n               else if sysdsn(input) <> \"OK\" then do\n                    say \"Error: Input DSN\" sysdsn(input)\n                    exit 16\n                    end\n                    else Say \"Using Input DSN:\" input\n            end\n\n         if os = '' then do\n         if output <> null then do\n            if left(output,3) = \"DD:\" then do\n               parse value output with \"DD:\"outputdd\n               output = null\n               end\n            if output = null\n               then Say \"Using Output DD: \" outputdd\n               else Say \"Using Output DSN:\" output\n            end\n         if outputdd = null\n            then if sysdsn(output) = \"OK\"\n            then do\n                 Say \"The output file\" output\n                 Say \"currently exists - please rerun with a new\" ,\n                     \"output data set name\"\n                 exit 16\n                 end\n                 end\n\n        /* ---------------------- *\n         * Read in the Input File *\n         * ---------------------- */\n         if os = '' then do\n         if inputdd = null\n            then do\n                 \"Alloc f(\"wrkdd\") shr reuse ds(\"input\")\"\n                 \"Execio * diskr\" wrkdd \"(finis stem in.\"\n                 \"Free  f(\"wrkdd\")\"\n                 end\n            else \"Execio * diskr\" inputdd \"(finis stem in.\"\n            end\n            else 'pipe <' ifn ift ifm '| stem in.'\n\n         Say in.0 \"Input records read in for processing\"\n\n        /* --------------------------------------------------------- *\n         * Validate the provided input                               *\n         * - test to ensure columns are sequential in order           *\n         * --------------------------------------------------------- */\n         if ignore_columns = null then,\n         do col = words(columns) to 1 by -1\n            ce  = abs(word(columns,col))       /* dgc */\n            cm  = col - 1\n            if cm < 1 then cm = col\n            cp  = word(columns,cm)\n            if cp > ce then do\n               msg = \"Column\" col \"value is not greater than the\" ,\n                      \"column\" col-1 \"value.\"\n               call do_msg\n               end\n            end\n\n        /* --------------------------------------------------------- *\n         * Now begin CSV conversion                                  *\n         * --------------------------------------------------------- */\n         line = 0\n         do forever\n            line = line + 1\n            if line > in.0 then leave\n            data = in.line\n            record = null\n            if ignore_columns = null then,\n            do col = 1 to words(columns)\n               if word(columns,col) < 0 then iterate       /* dgc */\n               if abs(word(columns,col)) <> null then      /* dgc */\n                  call do_csv word(columns,col) word(columns,col+1)\n               end\n            else /* ignore_columns <> null */ ,\n               record = translate(space(data,1),sep,\" \")\n            if left(record,1) = sep then\n               record = substr(record,2)\n            record   = strip(record,'t')\n            outc     = outc + 1\n            if right(record,1) = sep then\n               record = left(record,length(record)-1)\n            if right(record,1) = sep then\n               record = left(record,length(record)-1)\n            out.outc = record\n            end\n\n        /* ----------------------- *\n         * Process the output file *\n         * ----------------------- */\n         out.0 = outc\n         Say out.0 \"Output records processed\"\n\n         if os = '' then do\n         if outputdd = null then do\n            lrecl = 80\n            do i = 1 to out.0\n               lrecl = max(lrecl,length(out.i))\n               end\n            Say \"Creating Output file:\" output\n            \"Alloc f(\"wrkdd\") new ds(\"output\")\" ,\n               \"Recfm(v b) Lrecl(\"lrecl+4\") Blksize(0)\"\n            \"Execio * diskw \"wrkdd\" (finis stem out.\"\n            \"Free  f(\"wrkdd\")\"\n            end\n         else \"Execio * diskw \"outputdd\" (finis stem out.\"\n            end\n         if os = 'CMS' then do\n              'pipe  stem out. | >' ofn oft ofm\n              end\n\n        /* --------------------------------------------------------- *\n         * Processing completed - inform the user.                   *\n         * --------------------------------------------------------- */\n         Say  \"CSV Conversion completed.\"\n         Say  \"The file is now ready for download or\"\n         Say  \"e-mail for import into Excel or other tool.\"\n        Exit 0\n\n        /* --------------------------------------------------------- *\n         * Extract CSV Column Data                                   *\n         * Then test it:                                             *\n         *   - begins with a zero       = set to =\"xxx\"              *\n         *   - contains a comma         = enclose in double quotes   *\n         *   - contains a blank         = enclose in double quotes   *\n         *   - contains the sep char    = enclose in double quotes   *\n         *   - insert comma between values                           *\n         * --------------------------------------------------------- */\n         Do_CSV:\n           arg start next\n           start = abs(start)                   /* dgc */\n           if next = null then\n              work = strip(substr(data,start))\n           else do\n                next = abs(next)                /* dgc */\n                work = strip(substr(data,start,next-start))\n                end\n           if length(work) = 0 then work = \" \"\n\n           Select\n             When pos(\",\",work) > 0 then work = '\"'work'\"'\n             When pos(\" \",work) > 0 then work = '\"'work'\"'\n             When pos(sep,work) > 0 then work = '\"'work'\"'\n             When left(work,1) = \"0\" then do\n                  if lz = \"YES\" then\n                     work = '=\"'work'\"'\n                  end\n             otherwise nop\n             end\n\n           work = work\"\"sep\n           record = record\"\"work\n           return\n\n        /* --------------------------------------------------------- *\n         * Issue message and redisplay prompt                        *\n         * --------------------------------------------------------- */\n         do_msg:\n            Say msg\n            exit 16\n", "mimetype": "text/x-pascal", "datatype": "ebcdic", "extension": ".p"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT314/CBT.V500.FILE314.PDS/TXT2CSV.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT314/CBT.V500.FILE314.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}