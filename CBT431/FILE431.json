{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012013000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 7936110, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE431.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 7936110, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 7936110, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE431.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00z\\n'", "DS1TRBAL": "b'Q\\x8c'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\x13\\x00\\t\\x03\\x1b\\x00\\x0b\\x00{'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01o\\x01\\x02\\x01o\\t\\x01\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-16T00:00:00", "modifydate": "2002-01-16T09:01:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 441    FILE:  431\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT441.FILE431\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 16 MEMBERS COUNTED; CUMULATIVE SIZE IS 75,550 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/16/02    09:01:00    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99)\\x9f\\x00\\x990_\\tY\\x005\\x003\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-10-26T00:00:00", "modifydate": "1999-11-01T09:59:00", "lines": 53, "newlines": 51, "modlines": 0, "user": "SBGOLOB"}, "text": "README for Distributions in This Directory\n\nMarch 25, 1998\n\nContents:\n\nBRACKETS - ISPF usermod and associated TSO facilities for\n           displaying and editing square brackets on a 3270\n\nBRACKET4 - ISPF Version 4 version of BRACKETS\n\nTSOREXX  - utilities to emulate CLIST functions PROC and WRITENR\n           in REXX execs\n\nInstructions:\n\n FTP the appropriate distribution file to your MVS system first.\n\n Use something like the following:\n\n To FTP foo.distrib.cntl (source distribution):\n\n  ftp this.ftp.site.com\n  anonymous\n  password@myhost.mydomain\n  cd /this/ftp/directory\n  get foo.distrib.cntl FOO.DISTRIB.CNTL\n  quit\n\n To FTP foo.distobj.cntl (object distribution):\n\n  ftp this.ftp.site.com\n  anonymous\n  password@myhost.mydomain\n  cd /this/ftp/directory\n  binary\n  locsite recfm=fb lrecl=80 blksize=6160\n  get foo.distobj.cntl FOO.DISTOBJ.CNTL\n  quit\n\n Please note that the *source* distribution is probably stored as a\n RECFM=VB LRECL=259 file, to save space and speed up file transfer.\n The *object* distribution is stored as RECFM=FB LRECL=80 because\n there's no other way to store combination EBCDIC and object text\n in a binary file.\n\n Either of these is one large JCL stream that executes the IEBUPDTE\n utility to build several PDS's.  These PDS's are generally named\n with a convention like:\n\n FOO.INSTALL.CNTL    JCL to complete the build, readmes, miscellany\n FOO.INSTALL.CLIST   CLISTs and REXX execs\n FOO.INSTALL.PANEL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE431": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x99\\x08?\\x01\\x001_\\x11F\\x00&\\x00\\x02\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2000-11-10T11:46:00", "lines": 38, "newlines": 2, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 431 is from Stephen Bacher of Charles Stark Draper        *   FILE 431\n//*           Laboratory in Cambridge, Massachusetts.  This         *   FILE 431\n//*           file contains several of Steve's large packages,      *   FILE 431\n//*           with each package as a separate member of this        *   FILE 431\n//*           pds.                                                  *   FILE 431\n//*                                                                 *   FILE 431\n//*           Steve Bacher <seb@draper.com>                         *   FILE 431\n//*                                                                 *   FILE 431\n//*           Charles Stark Draper Laboratory                       *   FILE 431\n//*           555 Technology Square                                 *   FILE 431\n//*           Cambridge, MA 02139                                   *   FILE 431\n//*           (617) 258-1525                                        *   FILE 431\n//*                                                                 *   FILE 431\n//*      Contents of this file (thus far)                           *   FILE 431\n//*                                                                 *   FILE 431\n//*   BRACKETS 01.00  1999/11/01  1999/11/01  9:58  1134 SEB        *   FILE 431\n//*   BRACKET4 01.00  1999/10/26  1999/10/26 20:09  2302 SEB        *   FILE 431\n//*   GOPHER   01.00  1999/10/26  1999/10/26 19:56 19968 SEB        *   FILE 431\n//*   IPCSDIST 01.00  1997/09/30  1997/09/30 21:35 14365 SEB        *   FILE 431\n//*   NNMVS    01.00  1999/10/26  1999/10/26 20:09 29952 SEB        *   FILE 431\n//*   TSOREXX  01.00  1999/10/26  1999/10/26 20:09  3218 SEB        *   FILE 431\n//*   XDIS     01.00  2000/03/28  2000/03/28 18:22  4066 SEB        *   FILE 431\n//*   XDIS$$   01.00  2000/03/28  2000/03/28 18:14    16 SBGOLOB    *   FILE 431\n//*   XDISNOTE 01.02  2000/03/28  2000/03/28 18:17    22 SBGOLOB    *   FILE 431\n//*   XRXVARS  01.00  2000/03/16  2000/03/16 17:51   246 SBGOLOB    *   FILE 431\n//*   XRXVARS# 01.01  2000/03/16  2000/03/16 18:35    38 SBGOLOB    *   FILE 431\n//*   XR991214 01.02  2000/03/16  2000/03/16 18:29    95 SBGOLOB    *   FILE 431\n//*                                                                 *   FILE 431\n//*      BRACKETS - An ISPF Mod to enable the writing of square     *   FILE 431\n//*                 brackets.                                       *   FILE 431\n//*      BRACKET4 - The same ISPF Mod for ISPF Version 4.           *   FILE 431\n//*      GOPHER   - An MVS Gopher Server                            *   FILE 431\n//*      NNMVS    - MVS NNTP News Reader                            *   FILE 431\n//*      TSOREXX  - A REXX function package to simulate the         *   FILE 431\n//*                 CLIST commands PROC and WRITENR.                *   FILE 431\n//*      XDIS     - A disassembler                                  *   FILE 431\n//*      XRXVARS  - Program to display all active REXX variables.   *   FILE 431\n//*                                                                 *   FILE 431\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BRACKETS": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x990_\\x00\\x990_\\tX\\x04n\\x04n\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-01T00:00:00", "modifydate": "1999-11-01T09:58:00", "lines": 1134, "newlines": 1134, "modlines": 0, "user": "SEB"}, "text": "//JOBNAME JOB ACCOUNT,'NAME'\n//*------------------------------------------------------------------*/\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis. All warranties,   */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed. Such modifications should  */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*------------------------------------------------------------------*/\n//*\n//*    TSO/ISPF square brackets support\n//*\n//*  Version: 1\n//*\n//* Author: Steve Bacher <seb@draper.com>\n//*\n//* Date: 15 Jul 1993\n//*\n//*-------------------------------------------------------------------\n//*\n//* This job creates the distribution libraries (PDS's).\n//*\n//* Run this JCL to create the PDS's, after customizing to suit.\n//* (Obviously, put in a good JOB statement first.)\n//* To customize the JCL, change the defaults on the //MDLOAD PROC\n//* statement to your liking, particularly the PREFIX default.\n//* You might also want to change the final qualifiers of the PDS's\n//* created - to do this, find the // EXEC MDLOAD statements and\n//* change the value of the TO parameter.\n//*\n//* See the $$README file (of the CNTL PDS, first in this stream)\n//* for the rest of the installation instructions.\n//*\n//MDLOAD PROC CLS='*',BS='6160',U='3380',V='',\n//      TRK1='30',TRK2='10',DIR='35',RLSE='RLSE',\n//      PREFIX='SYS8.BRACKETS.'\n//*\n//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=&CLS\n//SYSUT2 DD DISP=(NEW,CATLG,DELETE),DSN=&PREFIX.&TO,\n//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=&BS),\n//  SPACE=(TRK,(&TRK1,&TRK2,&DIR),&RLSE),UNIT=&U,VOL=SER=&V\n//*\n//  PEND\n//*\n//CNTL     EXEC MDLOAD,TRK1='5',TRK2='1',TO='CNTL'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=$$README\n\nTSO/ISPF Square Brackets Support\n\nThis support consists of 3 SMP/E usermods to ISPF (currently written\nfor ISPF and ISPF/PDF V3R3), plus a REXX exec called \"BRACKETS\".\n\nTo install these utilities:\n\n(1) Receive and apply the usermods in the CNTL dataset.  Change the\n    SYSMOD ID's to whatever you want, but be sure to modify the\n    references across all three.  Change the FMIDs of the ISPF and\n    ISPF/PDF products to match your site.  Note that the distribution\n    library for the new terminal translate tables is ADLOAD; either\n    create an SMP/E DDDEF for this distlib or change the JCLIN to\n    reflect a different distlib of your choice.\n\n(2) Install the BRACKETS exec in the CLIST or EXEC library of your\n    choice.  Install the BRACKETS help similarly.\n\n(3) Send all gripes, compliments and suggestions to seb@draper.com.\n\n./ ADD NAME=BRACKET1\n++USERMOD(BRACKET1) /* ISPF 3.3 ISPF ASCII TERMINAL TYPE USERMOD\n**********************************************************************\n***                                                                ***\n***  This usermod creates an ISPF terminal translate table         ***\n***  (called ISPX7171) associated with a terminal type we call     ***\n***  \"ASCII\" on the ISPF option 0.1 panel.  This terminal type     ***\n***  supports square brackets.                                     ***\n***                                                                ***\n***  Also required is BRACKET2, which creates the corresponding    ***\n***  ISPF/PDF terminal translate table ISRX7171; and BRACKET3,     ***\n***  which modifies the ISPF option 0.1 panels to support this.    ***\n***                                                                ***\n********************************************************************/.\n++VER(Z038) FMID(HIF3302).\n++IF FMID(HDV3302) THEN REQ(BRACKET2) /* ISRX7171 module       */ .\n++IF FMID(JIF3310) THEN REQ(BRACKET3) /* ISPF option 0.1 panels */ .\n++JCLIN.\n//LKED EXEC PGM=IEWL,PARM='LIST,LET,RENT,REUS'\n//SYSPRINT DD SYSOUT=A\n//SYSLMOD DD DISP=SHR,DSN=ISP.V3R3M0.ISPLOAD\n//ADLOAD  DD DISP=SHR,DSN=DST2.ADLOAD\n//SYSLIN DD *\n   ORDER ISPX7171\n   ENTRY ISPX7171\n   INCLUDE ADLOAD(ISPX7171)\n NAME ISPX7171(R)\n/*\n++SRC(ISPX7171) DISTLIB(ADSOURCE) DISTMOD(ADLOAD).\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ISPF 3.3.0 \"ASCII\" ISPF terminal translate table.                   *\n* Also see ISRX7171 for ISPF/PDF terminal translation.                *\n* Reference: ISPF and ISPF/PDF Planning and Customizing (SC34-4257-01)*\n*                                                                     *\n* Copied from ISPOWNTT (in SAMPLIB) and modified.                     *\n*                                                                     *\n***********************************************************************\n*\nISPX7171 CSECT\nTTID     DC    CL8'ISPX7171'\nUPPP     DC    AL4(TTUPP)\nLOWP     DC    AL4(TTLOW)\nVALP     DC    AL4(TTVAL)\nALBP     DC    AL4(TTALB)\nETOP     DC    A(0)\nGSCP     DC    A(0)\nGSMP     DC    AL4(TTGSM)\nGSSP     DC    A(0)\nEDIP     DC    A(0)\nEDOP     DC    A(0)\nDPRP     DC    A(0)\nTBIP     DC    A(0)\nTBOP     DC    A(0)\nESCV     DC    X'00000000'\nALPP     DC    AL4(TTALP)\nCOLP     DC    AL4(0)              No non-EBCDIC collating - SEB\n*\n*\nTTUPP    DC    X'0001020304050607'     (X'00' TO X'07')\n         DC    X'40090A0B0C0D0E0F'     (X'08' TO X'0F')\n         DC    X'1011121314151617'     (X'10' TO X'17')\n         DC    X'18191A1B4040401F'     (X'18' TO X'1F')\n         DC    X'2021222324252627'     (X'20' TO X'27')\n         DC    X'28292A2B2C2D2E2F'     (X'28' TO X'2F')\n         DC    X'3031323334353637'     (X'30' TO X'37')\n         DC    X'38393A3B3C3D3E3F'     (X'38' TO X'3F')\n         DC    X'4041424344454647'     (X'40' TO X'47')\n         DC    X'48494A4B4C4D4E4F'     (X'48' TO X'4F')\n         DC    X'5051525354555657'     (X'50' TO X'57')\n         DC    X'58595A5B5C5D5E5F'     (X'58' TO X'5F')\n         DC    X'6061626364656667'     (X'60' TO X'67')\n         DC    X'68696A6B6C6D6E6F'     (X'68' TO X'6F')\n         DC    X'7071727374757677'     (X'70' TO X'77')\n         DC    X'78797A7B7C7D7E7F'     (X'78' TO X'7F')\n         DC    X'80C1C2C3C4C5C6C7'     (X'80' TO X'87')\n         DC    X'C8C98A8B8C8D8E8F'     (X'88' TO X'8F')\n         DC    X'90D1D2D3D4D5D6D7'     (X'90' TO X'97')\n         DC    X'D8D99A9B9C9D9E9F'     (X'98' TO X'9F')\n         DC    X'A0A1E2E3E4E5E6E7'     (X'A0' TO X'A7')\n         DC    X'E8E9AAABACADAEAF'     (X'A8' TO X'AF')\n         DC    X'B0B1B2B3B4B5B6B7'     (X'B0' TO X'B7')\n         DC    X'B8B9BABBBCBDBEBF'     (X'B8' TO X'BF')\n         DC    X'C0C1C2C3C4C5C6C7'     (X'C0' TO X'C7')\n         DC    X'C8C9CACBCCCDCECF'     (X'C8' TO X'CF')\n         DC    X'D0D1D2D3D4D5D6D7'     (X'D0' TO X'D7')\n         DC    X'D8D9DADBDCDDDEDF'     (X'D8' TO X'DF')\n         DC    X'E0E1E2E3E4E5E6E7'     (X'E0' TO X'E7')\n         DC    X'E8E9EAEBECEDEEEF'     (X'E8' TO X'EF')\n         DC    X'F0F1F2F3F4F5F6F7'     (X'F0' TO X'F7')\n         DC    X'F8F9FAFBFCFDFEFF'     (X'F8' TO X'FF')\n*\n*\nTTLOW    DC    X'0001020304050607'     (X'00' TO X'07')\n         DC    X'40090A0B0C0D0E0F'     (X'08' TO X'0F')\n         DC    X'1011121314151617'     (X'10' TO X'17')\n         DC    X'18191A1B4040401F'     (X'18' TO X'1F')\n         DC    X'2021222324252627'     (X'20' TO X'27')\n         DC    X'28292A2B2C2D2E2F'     (X'28' TO X'2F')\n         DC    X'3031323334353637'     (X'30' TO X'37')\n         DC    X'38393A3B3C3D3E3F'     (X'38' TO X'3F')\n         DC    X'4041424344454647'     (X'40' TO X'47')\n         DC    X'48494A4B4C4D4E4F'     (X'48' TO X'4F')\n         DC    X'5051525354555657'     (X'50' TO X'57')\n         DC    X'58595A5B5C5D5E5F'     (X'58' TO X'5F')\n         DC    X'6061626364656667'     (X'60' TO X'67')\n         DC    X'68696A6B6C6D6E6F'     (X'68' TO X'6F')\n         DC    X'7071727374757677'     (X'70' TO X'77')\n         DC    X'78797A7B7C7D7E7F'     (X'78' TO X'7F')\n         DC    X'8081828384858687'     (X'80' TO X'87')\n         DC    X'88898A8B8C8D8E8F'     (X'88' TO X'8F')\n         DC    X'9091929394959697'     (X'90' TO X'97')\n         DC    X'98999A9B9C9D9E9F'     (X'98' TO X'9F')\n         DC    X'A0A1A2A3A4A5A6A7'     (X'A0' TO X'A7')\n         DC    X'A8A9AAABACADAEAF'     (X'A8' TO X'AF')\n         DC    X'B0B1B2B3B4B5B6B7'     (X'B0' TO X'B7')\n         DC    X'B8B9BABBBCBDBEBF'     (X'B8' TO X'BF')\n         DC    X'C0C1C2C3C4C5C6C7'     (X'C0' TO X'C7')\n         DC    X'C8C9CACBCCCDCECF'     (X'C8' TO X'CF')\n         DC    X'D0D1D2D3D4D5D6D7'     (X'D0' TO X'D7')\n         DC    X'D8D9DADBDCDDDEDF'     (X'D8' TO X'DF')\n         DC    X'E0E1E2E3E4E5E6E7'     (X'E0' TO X'E7')\n         DC    X'E8E9EAEBECEDEEEF'     (X'E8' TO X'EF')\n         DC    X'F0F1F2F3F4F5F6F7'     (X'F0' TO X'F7')\n         DC    X'F8F9FAFBFCFDFEFF'     (X'F8' TO X'FF')\n*\n*\nTTVAL    DC    X'FFFFFFFFFFFFFFFF'     (X'00' TO X'07')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'08' TO X'0F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'10' TO X'17')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'18' TO X'1F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'20' TO X'27')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'28' TO X'2F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'30' TO X'37')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'38' TO X'3F')\n         DC    X'00FFFFFFFFFFFFFF'     (X'40' TO X'47')\n         DC    X'FFFFFF0000000000'     (X'48' TO X'4F') X'4A' cent sign\n         DC    X'00FFFFFFFFFFFFFF'     (X'50' TO X'57')\n         DC    X'FFFF000000000000'     (X'58' TO X'5F')\n         DC    X'0000FFFFFFFFFFFF'     (X'60' TO X'67')\n         DC    X'FFFFFF0000000000'     (X'68' TO X'6F') X'6A' dbl v bar\n         DC    X'FFFFFFFFFFFFFFFF'     (X'70' TO X'77')\n         DC    X'FF00000000000000'     (X'78' TO X'7F')\n         DC    X'FF00000000000000'     (X'80' TO X'87')\n         DC    X'0000FFFFFFFFFFFF'     (X'88' TO X'8F')\n         DC    X'FF00000000000000'     (X'90' TO X'97')\n         DC    X'0000FFFFFFFFFFFF'     (X'98' TO X'9F')\n         DC    X'FF00000000000000'     (X'A0' TO X'A7')\n         DC    X'0000FFFFFF00FFFF'     (X'A8' TO X'AF') X'AD' lbracket\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B0' TO X'B7')\n         DC    X'FFFFFFFFFF00FFFF'     (X'B8' TO X'BF') X'BD' rbracket\n         DC    X'0000000000000000'     (X'C0' TO X'C7')\n         DC    X'0000FFFFFFFFFFFF'     (X'C8' TO X'CF')\n         DC    X'0000000000000000'     (X'D0' TO X'D7')\n         DC    X'0000FFFFFFFFFFFF'     (X'D8' TO X'DF')\n         DC    X'00FF000000000000'     (X'E0' TO X'E7')\n         DC    X'0000FFFFFFFFFFFF'     (X'E8' TO X'EF')\n         DC    X'0000000000000000'     (X'F0' TO X'F7')\n         DC    X'0000FFFFFFFFFFFF'     (X'F8' TO X'FF')\n*\n*\nTTGSM    DC    X'0101010101010101'     (X'00' TO X'07')\n         DC    X'0101010101010101'     (X'08' TO X'0F')\n         DC    X'0101010101010101'     (X'10' TO X'17')\n         DC    X'0101010101010101'     (X'18' TO X'1F')\n         DC    X'0101010101010101'     (X'20' TO X'27')\n         DC    X'0101010101010101'     (X'28' TO X'2F')\n         DC    X'0101010101010101'     (X'30' TO X'37')\n         DC    X'0101010101010101'     (X'38' TO X'3F')\n         DC    X'0001010101010101'     (X'40' TO X'47')\n         DC    X'0101010202020202'     (X'48' TO X'4F') X'4A' is P'.'\n         DC    X'0201010101010101'     (X'50' TO X'57')\n         DC    X'0101020202020202'     (X'58' TO X'5F')\n         DC    X'0202010101010101'     (X'60' TO X'67')\n         DC    X'0101010202020202'     (X'68' TO X'6F') X'6A' is P'.'\n         DC    X'0101010101010101'     (X'70' TO X'77')\n         DC    X'0102020202020202'     (X'78' TO X'7F')\n         DC    X'0110101010101010'     (X'80' TO X'87')\n         DC    X'1010010101010101'     (X'88' TO X'8F')\n         DC    X'0110101010101010'     (X'90' TO X'97')\n         DC    X'1010010101010101'     (X'98' TO X'9F')\n         DC    X'0102101010101010'     (X'A0' TO X'A7')\n         DC    X'1010010101020101'     (X'A8' TO X'AF') X'AD' is P'$'\n         DC    X'0101010101010101'     (X'B0' TO X'B7')\n         DC    X'0101010101020101'     (X'B8' TO X'BF') X'BD' is P'$'\n         DC    X'0220202020202020'     (X'C0' TO X'C7')\n         DC    X'2020010101010101'     (X'C8' TO X'CF')\n         DC    X'0220202020202020'     (X'D0' TO X'D7')\n         DC    X'2020010101010101'     (X'D8' TO X'DF')\n         DC    X'0201202020202020'     (X'E0' TO X'E7')\n         DC    X'2020010101010101'     (X'E8' TO X'EF')\n         DC    X'4040404040404040'     (X'F0' TO X'F7')\n         DC    X'4040010101010101'     (X'F8' TO X'FF')\n*\n*\nTTALP    DC    X'FFFFFFFFFFFFFFFF'     (X'00' TO X'07')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'08' TO X'0F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'10' TO X'17')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'18' TO X'1F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'20' TO X'27')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'28' TO X'2F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'30' TO X'37')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'38' TO X'3F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'40' TO X'47')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'48' TO X'4F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'50' TO X'57')\n         DC    X'FFFFFF00FFFFFFFF'     (X'58' TO X'5F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'60' TO X'67')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'68' TO X'6F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'70' TO X'77')\n         DC    X'FFFFFF0000FFFFFF'     (X'78' TO X'7F')\n         DC    X'FF00000000000000'     (X'80' TO X'87')\n         DC    X'0000FFFFFFFFFFFF'     (X'88' TO X'8F')\n         DC    X'FF00000000000000'     (X'90' TO X'97')\n         DC    X'0000FFFFFFFFFFFF'     (X'98' TO X'9F')\n         DC    X'FFFF000000000000'     (X'A0' TO X'A7')\n         DC    X'0000FFFFFFFFFFFF'     (X'A8' TO X'AF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B0' TO X'B7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B8' TO X'BF')\n         DC    X'FF00000000000000'     (X'C0' TO X'C7')\n         DC    X'0000FFFFFFFFFFFF'     (X'C8' TO X'CF')\n         DC    X'FF00000000000000'     (X'D0' TO X'D7')\n         DC    X'0000FFFFFFFFFFFF'     (X'D8' TO X'DF')\n         DC    X'FFFF000000000000'     (X'E0' TO X'E7')\n         DC    X'0000FFFFFFFFFFFF'     (X'E8' TO X'EF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'F0' TO X'F7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'F8' TO X'FF')\n*\n*\nTTALB    DC    X'FFFFFFFFFFFFFFFF'     (X'00' TO X'07')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'08' TO X'0F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'10' TO X'17')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'18' TO X'1F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'20' TO X'27')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'28' TO X'2F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'30' TO X'37')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'38' TO X'3F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'40' TO X'47')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'48' TO X'4F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'50' TO X'57')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'58' TO X'5F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'60' TO X'67')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'68' TO X'6F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'70' TO X'77')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'78' TO X'7F')\n         DC    X'FF00000000000000'     (X'80' TO X'87')\n         DC    X'0000FFFFFFFFFFFF'     (X'88' TO X'8F')\n         DC    X'FF00000000000000'     (X'90' TO X'97')\n         DC    X'0000FFFFFFFFFFFF'     (X'98' TO X'9F')\n         DC    X'FFFF000000000000'     (X'A0' TO X'A7')\n         DC    X'0000FFFFFFFFFFFF'     (X'A8' TO X'AF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B0' TO X'B7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B8' TO X'BF')\n         DC    X'FF00000000000000'     (X'C0' TO X'C7')\n         DC    X'0000FFFFFFFFFFFF'     (X'C8' TO X'CF')\n         DC    X'FF00000000000000'     (X'D0' TO X'D7')\n         DC    X'0000FFFFFFFFFFFF'     (X'D8' TO X'DF')\n         DC    X'FFFF000000000000'     (X'E0' TO X'E7')\n         DC    X'0000FFFFFFFFFFFF'     (X'E8' TO X'EF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'F0' TO X'F7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'F8' TO X'FF')\n*\n*\n         AGO   .NOTTCOL                Skip it - SEB\nTTCOL    DC    X'0001020304050607'     (X'00' TO X'07')\n         DC    X'08090A0B0C0D0E0F'     (X'08' TO X'0F')\n         DC    X'1011121314151617'     (X'10' TO X'17')\n         DC    X'18191A1B1C1D1E1F'     (X'18' TO X'1F')\n         DC    X'2021222324252627'     (X'20' TO X'27')\n         DC    X'28292A2B2C2D2E2F'     (X'28' TO X'2F')\n         DC    X'3031323334353637'     (X'30' TO X'37')\n         DC    X'38393A3B3C3D3E3F'     (X'38' TO X'3F')\n         DC    X'4041424344454647'     (X'40' TO X'47')\n         DC    X'48494A4B4C4D4E4F'     (X'48' TO X'4F')\n         DC    X'5051525354555657'     (X'50' TO X'57')\n         DC    X'58595A5B5C5D5E5F'     (X'58' TO X'5F')\n         DC    X'6061626364656667'     (X'60' TO X'67')\n         DC    X'68696A6B6C6D6E6F'     (X'68' TO X'6F')\n         DC    X'7071727374757677'     (X'70' TO X'77')\n         DC    X'78797A7B7C7D7E7F'     (X'78' TO X'7F')\n         DC    X'8081828384858687'     (X'80' TO X'87')\n         DC    X'88898A8B8C8D8E8F'     (X'88' TO X'8F')\n         DC    X'9091929394959697'     (X'90' TO X'97')\n         DC    X'98999A9B9C9D9E9F'     (X'98' TO X'9F')\n         DC    X'A0A1A2A3A4A5A6A7'     (X'A0' TO X'A7')\n         DC    X'A8A9AAABACADAEAF'     (X'A8' TO X'AF')\n         DC    X'B0B1B2B3B4B5B6B7'     (X'B0' TO X'B7')\n         DC    X'B8B9BABBBCBDBEBF'     (X'B8' TO X'BF')\n         DC    X'C0C1C2C3C4C5C6C7'     (X'C0' TO X'C7')\n         DC    X'C8C9CACBCCCDCECF'     (X'C8' TO X'CF')\n         DC    X'D0D1D2D3D4D5D6D7'     (X'D0' TO X'D7')\n         DC    X'D8D9DADBDCDDDEDF'     (X'D8' TO X'DF')\n         DC    X'E0E1E2E3E4E5E6E7'     (X'E0' TO X'E7')\n         DC    X'E8E9EAEBECEDEEEF'     (X'E8' TO X'EF')\n         DC    X'F0F1F2F3F4F5F6F7'     (X'F0' TO X'F7')\n         DC    X'F8F9FAFBFCFDFEFF'     (X'F8' TO X'FF')\n.NOTTCOL ANOP  ,                       Skip it - SEB\n         END\n./ ADD NAME=BRACKET2\n++USERMOD(BRACKET2) /* ISPF 3.3 PDF ASCII TERMINAL TYPE USERMOD\n**********************************************************************\n***                                                                ***\n***  This usermod creates an ISPF/PDF terminal translate table     ***\n***  (called ISRX7171) associated with a terminal type we call     ***\n***  \"ASCII\" on the ISPF option 0.1 panel.  This terminal type     ***\n***  supports square brackets.                                     ***\n***                                                                ***\n***  Also required is BRACKET1, which creates the corresponding    ***\n***  ISPF terminal translate table ISPX7171; and BRACKET3,         ***\n***  which modifies the ISPF option 0.1 panels to support this.    ***\n***                                                                ***\n********************************************************************/.\n++VER(Z038) FMID(HDV3302).\n++IF FMID(HIF3302) THEN REQ(BRACKET1) /* ISPX7171 module       */ .\n++IF FMID(JIF3310) THEN REQ(BRACKET3) /* ISPF option 0.1 panels */ .\n++JCLIN.\n//LKED EXEC PGM=IEWL,PARM='LIST,LET,RENT,REUS'\n//SYSPRINT DD SYSOUT=A\n//SYSLMOD DD DISP=SHR,DSN=ISR.V3R3M0.ISRLOAD\n//ADLOAD  DD DISP=SHR,DSN=DST2.ADLOAD\n//SYSLIN DD *\n   ENTRY ISRX7171\n   INCLUDE ADLOAD(ISRX7171)\n NAME ISRX7171(R)\n/*\n++SRC(ISRX7171) DISTLIB(ADSOURCE) DISTMOD(ADLOAD).\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ISPF 3.3.0 \"ASCII\" ISPF/PDF terminal translate table.               *\n* Also see ISPX7171 for ISPF terminal translation.                    *\n* Reference: ISPF and ISPF/PDF Planning and Customizing (SC34-4257-01)*\n*                                                                     *\n* Copied from ISROWNTT (in SAMPLIB) and modified.                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nISRX7171 CSECT\nTTID     DC    CL8'ISRX7171'\nVDSN     DC    AL4(TTVDSN)\nIDSN     DC    AL4(TTIDSN)\nHEXP     DC    AL4(TTHEX)\nNUMP     DC    AL4(TTNUM)\nALNP     DC    AL4(TTALN)\nDUMMY1   DC    A(0)\nETOP     DC    AL4(TTETO)\nGSCP     DC    AL4(TTGSC)\nDUMMY2   DC    A(0)\nGSSP     DC    AL4(TTGSS)\nEDIP     DC    A(0)\nEDOP     DC    A(0)\nUPPP     DC    AL4(TTUPP)\nLOWP     DC    AL4(TTLOW)\nDUMMY3   DC    A(0)\nDUMMY4   DC    A(0)\nDUMMY5   DC    A(0)\nDUMMY6   DC    A(0)\n*\n*\nTTVDSN   DC    X'FFFFFFFFFFFFFFFF'     (X'00' TO X'07')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'08' TO X'0F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'10' TO X'17')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'18' TO X'1F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'20' TO X'27')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'28' TO X'2F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'30' TO X'37')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'38' TO X'3F')\n         DC    X'00FFFFFFFFFFFFFF'     (X'40' TO X'47')\n         DC    X'FFFFFFFFFFFF00FF'     (X'48' TO X'4F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'50' TO X'57')\n         DC    X'FFFFFF0000FFFFFF'     (X'58' TO X'5F')\n         DC    X'00FFFFFFFFFFFFFF'     (X'60' TO X'67')\n         DC    X'FFFFFFFFFF00FFFF'     (X'68' TO X'6F')  OY08618\n         DC    X'FFFFFFFFFFFFFFFF'     (X'70' TO X'77')\n         DC    X'FFFF000000FFFFFF'     (X'78' TO X'7F')\n         DC    X'FF00000000000000'     (X'80' TO X'87')\n         DC    X'0000FFFFFFFFFFFF'     (X'88' TO X'8F')\n         DC    X'FF00000000000000'     (X'90' TO X'97')\n         DC    X'0000FFFFFFFFFFFF'     (X'98' TO X'9F')\n         DC    X'FFFF000000000000'     (X'A0' TO X'A7')\n         DC    X'0000FFFFFFFFFFFF'     (X'A8' TO X'AF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B0' TO X'B7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B8' TO X'BF')\n         DC    X'FF00000000000000'     (X'C0' TO X'C7')\n         DC    X'0000FFFFFFFFFFFF'     (X'C8' TO X'CF')\n         DC    X'FF00000000000000'     (X'D0' TO X'D7')\n         DC    X'0000FFFFFFFFFFFF'     (X'D8' TO X'DF')\n         DC    X'FFFF000000000000'     (X'E0' TO X'E7')\n         DC    X'0000FFFFFFFFFFFF'     (X'E8' TO X'EF')\n         DC    X'0000000000000000'     (X'F0' TO X'F7')\n         DC    X'0000FFFFFFFFFFFF'     (X'F8' TO X'FF')\n*\n*\nTTIDSN   DC    X'0000000000000000'     (X'00' TO X'07')\n         DC    X'0000000000000000'     (X'08' TO X'0F')\n         DC    X'0000000000000000'     (X'10' TO X'17')\n         DC    X'0000000000000000'     (X'18' TO X'1F')\n         DC    X'0000000000000000'     (X'20' TO X'27')\n         DC    X'0000000000000000'     (X'28' TO X'2F')\n         DC    X'0000000000000000'     (X'30' TO X'37')\n         DC    X'0000000000000000'     (X'38' TO X'3F')\n         DC    X'0000000000000000'     (X'40' TO X'47')\n         DC    X'0000000000004E00'     (X'48' TO X'4F')\n         DC    X'0000000000000000'     (X'50' TO X'57')\n         DC    X'0000005B5C000000'     (X'58' TO X'5F')\n         DC    X'6000000000000000'     (X'60' TO X'67')\n         DC    X'00000000006D0000'     (X'68' TO X'6F')\n         DC    X'0000000000000000'     (X'70' TO X'77')\n         DC    X'00007A7B7C000000'     (X'78' TO X'7F')\n         DC    X'0081828384858687'     (X'80' TO X'87')\n         DC    X'8889000000000000'     (X'88' TO X'8F')\n         DC    X'0091929394959697'     (X'90' TO X'97')\n         DC    X'9899000000000000'     (X'98' TO X'9F')\n         DC    X'0000A2A3A4A5A6A7'     (X'A0' TO X'A7')\n         DC    X'A8A9000000000000'     (X'A8' TO X'AF')\n         DC    X'0000000000000000'     (X'B0' TO X'B7')\n         DC    X'0000000000000000'     (X'B8' TO X'BF')\n         DC    X'00C1C2C3C4C5C6C7'     (X'C0' TO X'C7')\n         DC    X'C8C9000000000000'     (X'C8' TO X'CF')\n         DC    X'00D1D2D3D4D5D6D7'     (X'D0' TO X'D7')\n         DC    X'D8D9000000000000'     (X'D8' TO X'DF')\n         DC    X'0000E2E3E4E5E6E7'     (X'E0' TO X'E7')\n         DC    X'E8E9000000000000'     (X'E8' TO X'EF')\n         DC    X'F0F1F2F3F4F5F6F7'     (X'F0' TO X'F7')\n         DC    X'F8F9000000000000'     (X'F8' TO X'FF')\n*\n*\nTTHEX    DC    X'FFFFFFFFFFFFFFFF'     (X'00' TO X'07')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'08' TO X'0F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'10' TO X'17')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'18' TO X'1F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'20' TO X'27')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'28' TO X'2F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'30' TO X'37')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'38' TO X'3F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'40' TO X'47')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'48' TO X'4F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'50' TO X'57')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'58' TO X'5F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'60' TO X'67')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'68' TO X'6F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'70' TO X'77')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'78' TO X'7F')\n         DC    X'FF000000000000FF'     (X'80' TO X'87')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'88' TO X'8F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'90' TO X'97')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'98' TO X'9F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'A0' TO X'A7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'A8' TO X'AF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B0' TO X'B7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B8' TO X'BF')\n         DC    X'FF000000000000FF'     (X'C0' TO X'C7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'C8' TO X'CF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'D0' TO X'D7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'D8' TO X'DF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'E0' TO X'E7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'E8' TO X'EF')\n         DC    X'0000000000000000'     (X'F0' TO X'F7')\n         DC    X'0000FFFFFFFFFFFF'     (X'F8' TO X'FF')\n*\n*\nTTNUM    DC    X'FFFFFFFFFFFFFFFF'     (X'00' TO X'0F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'08' TO X'0F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'10' TO X'17')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'18' TO X'1F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'20' TO X'27')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'28' TO X'2F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'30' TO X'37')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'38' TO X'3F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'40' TO X'47')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'48' TO X'4F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'50' TO X'57')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'58' TO X'5F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'60' TO X'67')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'68' TO X'6F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'70' TO X'77')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'78' TO X'7F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'80' TO X'87')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'88' TO X'8F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'90' TO X'97')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'98' TO X'9F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'A0' TO X'A7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'A8' TO X'AF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B0' TO X'B7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B8' TO X'BF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'C0' TO X'C7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'C8' TO X'CF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'D0' TO X'D7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'D8' TO X'DF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'E0' TO X'E7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'E8' TO X'EF')\n         DC    X'0000000000000000'     (X'F0' TO X'F7')\n         DC    X'0000FFFFFFFFFFFF'     (X'F8' TO X'FF')\n*\n*\nTTALN    DC    X'FFFFFFFFFFFFFFFF'     (X'00' TO X'0F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'08' TO X'0F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'10' TO X'17')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'18' TO X'1F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'20' TO X'27')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'28' TO X'2F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'30' TO X'37')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'38' TO X'3F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'40' TO X'47')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'48' TO X'4F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'50' TO X'57')\n         DC    X'FFFFFF00FFFFFFFF'     (X'58' TO X'5F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'60' TO X'67')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'68' TO X'6F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'70' TO X'77')\n         DC    X'FFFFFF0000FFFFFF'     (X'78' TO X'7F')\n         DC    X'FF00000000000000'     (X'80' TO X'87')\n         DC    X'0000FFFFFFFFFFFF'     (X'88' TO X'8F')\n         DC    X'FF00000000000000'     (X'90' TO X'97')\n         DC    X'0000FFFFFFFFFFFF'     (X'98' TO X'9F')\n         DC    X'FFFF000000000000'     (X'A0' TO X'A7')\n         DC    X'0000FFFFFFFFFFFF'     (X'A8' TO X'AF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B0' TO X'B7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B8' TO X'BF')\n         DC    X'FF00000000000000'     (X'C0' TO X'C7')\n         DC    X'0000FFFFFFFFFFFF'     (X'C8' TO X'CF')\n         DC    X'FF00000000000000'     (X'D0' TO X'D7')\n         DC    X'0000FFFFFFFFFFFF'     (X'D8' TO X'DF')\n         DC    X'FFFF000000000000'     (X'E0' TO X'E7')\n         DC    X'0000FFFFFFFFFFFF'     (X'E8' TO X'EF')\n         DC    X'0000000000000000'     (X'F0' TO X'F7')\n         DC    X'0000FFFFFFFFFFFF'     (X'F8' TO X'FF')\n*\n*\nTTETO    DC    X'1515151515151515'     (X'00' TO X'0F')\n         DC    X'1515151515151515'     (X'08' TO X'0F')\n         DC    X'1515151515151515'     (X'10' TO X'17')\n         DC    X'1515151515151515'     (X'18' TO X'1F')\n         DC    X'1515151515151515'     (X'20' TO X'27')\n         DC    X'1515151515151515'     (X'28' TO X'2F')\n         DC    X'1515151515151515'     (X'30' TO X'37')\n         DC    X'1515151515151515'     (X'38' TO X'3F')\n         DC    X'4015151515151515'     (X'40' TO X'47')\n         DC    X'1515154B4C4D4E4F'     (X'48' TO X'4F') 4A cent sign\n         DC    X'5015151515151515'     (X'50' TO X'57')\n         DC    X'15155A5B5C5D5E5F'     (X'58' TO X'5F')\n         DC    X'6061151515151515'     (X'60' TO X'67')\n         DC    X'1515156B6C6D6E6F'     (X'68' TO X'6F') 6A broken v bar\n         DC    X'1515151515151515'     (X'70' TO X'77')\n         DC    X'15797A7B7C7D7E7F'     (X'78' TO X'7F')\n         DC    X'1581828384858687'     (X'80' TO X'87')\n         DC    X'8889151515151515'     (X'88' TO X'8F')\n         DC    X'1591929394959697'     (X'90' TO X'97')\n         DC    X'9899151515151515'     (X'98' TO X'9F')\n         DC    X'15A1A2A3A4A5A6A7'     (X'A0' TO X'A7')\n         DC    X'A8A9151515AD1515'     (X'A8' TO X'AF') AD left bracket\n         DC    X'1515151515151515'     (X'B0' TO X'B7')\n         DC    X'1515151515BD1515'     (X'B8' TO X'BF') BD rightbracket\n         DC    X'C0C1C2C3C4C5C6C7'     (X'C0' TO X'C7')\n         DC    X'C8C9151515151515'     (X'C8' TO X'CF')\n         DC    X'D0D1D2D3D4D5D6D7'     (X'D0' TO X'D7')\n         DC    X'D8D9151515151515'     (X'D8' TO X'DF')\n         DC    X'E015E2E3E4E5E6E7'     (X'E0' TO X'E7')  OY08618\n         DC    X'E8E9151515151515'     (X'E8' TO X'EF')\n         DC    X'F0F1F2F3F4F5F6F7'     (X'F0' TO X'F7')\n         DC    X'F8F9151515151515'     (X'F8' TO X'FF')\n*\n*\nTTGSC    DC    X'00'                   (X'00')\n         DC    X'01'                   (X'01')\n         DC    X'02'                   (X'02')\n         DC    X'04'                   (X'03')\n         DC    X'08'                   (X'04')\n         DC    X'10'                   (X'05')\n         DC    X'20'                   (X'06')\n         DC    X'40'                   (X'07')\n         DC    X'80'                   (X'08')\n         DC    X'FF'                   (X'09')\n         DC    X'30'                   (X'0A')\n         DC    X'7F'                   (X'0B')\n         DC    X'FF'                   (X'0C')\n         DC    X'FF'                   (X'0D')\n         DC    X'FF'                   (X'0E')\n         DC    X'FF'                   (X'0F')\n         DC    X'40'                   (X'10')\n         DC    X'20'                   (X'11')\n         DC    X'10'                   (X'12')\n         DC    X'30'                   (X'13')\n         DC    X'FF'                   (X'14')\n         DC    X'FF'                   (X'15')\n         DC    X'FF'                   (X'16')\n*\n*\nTTGSS    DC    X'FFFFFFFFFFFFFFFF'     (X'00' TO X'0F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'08' TO X'0F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'10' TO X'17')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'18' TO X'1F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'20' TO X'27')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'28' TO X'2F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'30' TO X'37')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'38' TO X'3F')\n         DC    X'40FFFFFFFFFFFFFF'     (X'40' TO X'47')\n         DC    X'FFFFFF0105FFFFFF'     (X'48' TO X'4F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'50' TO X'57')\n         DC    X'FFFFFF02FFFFFF0B'     (X'58' TO X'5F')\n         DC    X'10FFFFFFFFFFFFFF'     (X'60' TO X'67')\n         DC    X'FFFFFFFFFFFF06FF'     (X'68' TO X'6F')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'70' TO X'77')\n         DC    X'FFFFFF070AFF00FF'     (X'78' TO X'7F')\n         DC    X'FF81828384858687'     (X'80' TO X'87')\n         DC    X'8889FFFFFFFFFFFF'     (X'88' TO X'8F')\n         DC    X'FF91929394959697'     (X'90' TO X'97')\n         DC    X'9899FFFFFFFFFFFF'     (X'98' TO X'9F')\n         DC    X'FFFFA2A3A4A5A6A7'     (X'A0' TO X'A7')\n         DC    X'A8A9FFFFFFFFFFFF'     (X'A8' TO X'AF')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B0' TO X'B7')\n         DC    X'FFFFFFFFFFFFFFFF'     (X'B8' TO X'BF')\n         DC    X'FFC1C2C3C4C5C6C7'     (X'C0' TO X'C7')\n         DC    X'C8C9FFFFFFFFFFFF'     (X'C8' TO X'CF')\n         DC    X'FFD1D2D3D4D5D6D7'     (X'D0' TO X'D7')\n         DC    X'D8D9FFFFFFFFFFFF'     (X'D8' TO X'DF')\n         DC    X'FFFFE2E3E4E5E6E7'     (X'E0' TO X'E7')\n         DC    X'E8E9FFFFFFFFFFFF'     (X'E8' TO X'EF')\n         DC    X'F0F1F2F3F4F5F6F7'     (X'F0' TO X'F7')\n         DC    X'F8F9FFFFFFFFFFFF'     (X'F8' TO X'FF')\n*\n*\n* THE FOLLOWING LABEL CHANGED FROM 'TTLOW' TO 'TTUPP' FOR OY08282\n* ALSO, ENTRIES WERE CHANGED FROM X'C1' TO X'E9'.  THEY WOULD HAVE\n* CHANGED UPPERCASE A-Z TO LOWERCASE.\n*\nTTUPP    DC    X'0001020304050607'     (X'00' TO X'07')  OY08282\n         DC    X'08090A0B0C0D0E0F'     (X'08' TO X'0F')\n         DC    X'1011121314151617'     (X'10' TO X'17')\n         DC    X'18191A1B1C1D1E1F'     (X'18' TO X'1F')\n         DC    X'2021222324252627'     (X'20' TO X'27')\n         DC    X'28292A2B2C2D2E2F'     (X'28' TO X'2F')\n         DC    X'3031323334353637'     (X'30' TO X'37')\n         DC    X'38393A3B3C3D3E3F'     (X'38' TO X'3F')\n         DC    X'4041424344454647'     (X'40' TO X'47')\n         DC    X'48494A4B4C4D4E4F'     (X'48' TO X'4F')\n         DC    X'5051525354555657'     (X'50' TO X'57')\n         DC    X'58595A5B5C5D5E5F'     (X'58' TO X'5F')\n         DC    X'6061626364656667'     (X'60' TO X'67')\n         DC    X'68696A6B6C6D6E6F'     (X'68' TO X'6F')\n         DC    X'7071727374757677'     (X'70' TO X'77')\n         DC    X'78797A7B7C7D7E7F'     (X'78' TO X'7F')\n         DC    X'80C1C2C3C4C5C6C7'     (X'80' TO X'87')\n         DC    X'C8C98A8B8C8D8E8F'     (X'88' TO X'8F')\n         DC    X'90D1D2D3D4D5D6D7'     (X'90' TO X'97')\n         DC    X'D8D99A9B9C9D9E9F'     (X'98' TO X'9F')\n         DC    X'A0A1E2E3E4E5E6E7'     (X'A0' TO X'A7')\n         DC    X'E8E9AAABACADAEAF'     (X'A8' TO X'AF')\n         DC    X'B0B1B2B3B4B5B6B7'     (X'B0' TO X'B7')\n         DC    X'B8B9BABBBCBDBEBF'     (X'B8' TO X'BF')\n         DC    X'C0C1C2C3C4C5C6C7'     (X'C0' TO X'C7')  OY08282\n         DC    X'C8C9CACBCCCDCECF'     (X'C8' TO X'CF')  OY08282\n         DC    X'D0D1D2D3D4D5D6D7'     (X'D0' TO X'D7')  OY08282\n         DC    X'D8D9DADBDCDDDEDF'     (X'D8' TO X'DF')  OY08282\n         DC    X'E0E1E2E3E4E5E6E7'     (X'E0' TO X'E7')  OY08282\n         DC    X'E8E9EAEBECEDEEEF'     (X'E8' TO X'EF')  OY08282\n         DC    X'F0F1F2F3F4F5F6F7'     (X'F0' TO X'F7')\n         DC    X'F8F9FAFBFCFDFEFF'     (X'F8' TO X'FF')\n*\n*\nTTLOW    DC    X'0001020304050607'     (X'00' TO X'07')\n         DC    X'08090A0B0C0D0E0F'     (X'08' TO X'0F')\n         DC    X'1011121314151617'     (X'10' TO X'17')\n         DC    X'18191A1B1C1D1E1F'     (X'18' TO X'1F')\n         DC    X'2021222324252627'     (X'20' TO X'27')\n         DC    X'28292A2B2C2D2E2F'     (X'28' TO X'2F')\n         DC    X'3031323334353637'     (X'30' TO X'37')\n         DC    X'38393A3B3C3D3E3F'     (X'38' TO X'3F')\n         DC    X'4041424344454647'     (X'40' TO X'47')\n         DC    X'48494A4B4C4D4E4F'     (X'48' TO X'4F')\n         DC    X'5051525354555657'     (X'50' TO X'57')\n         DC    X'58595A5B5C5D5E5F'     (X'58' TO X'5F')\n         DC    X'6061626364656667'     (X'60' TO X'67')\n         DC    X'68696A6B6C6D6E6F'     (X'68' TO X'6F')\n         DC    X'7071727374757677'     (X'70' TO X'77')\n         DC    X'78797A7B7C7D7E7F'     (X'78' TO X'7F')\n         DC    X'8081828384858687'     (X'80' TO X'87')\n         DC    X'88898A8B8C8D8E8F'     (X'88' TO X'8F')\n         DC    X'9091929394959697'     (X'90' TO X'97')\n         DC    X'98999A9B9C9D9E9F'     (X'98' TO X'9F')\n         DC    X'A0A1A2A3A4A5A6A7'     (X'A0' TO X'A7')\n         DC    X'A8A9AAABACADAEAF'     (X'A8' TO X'AF')\n         DC    X'B0B1B2B3B4B5B6B7'     (X'B0' TO X'B7')\n         DC    X'B8B9BABBBCBDBEBF'     (X'B8' TO X'BF')\n         DC    X'C081828384858687'     (X'C0' TO X'C7')\n         DC    X'8889CACBCCCDCECF'     (X'C8' TO X'CF')\n         DC    X'D091929394959697'     (X'D0' TO X'D7')\n         DC    X'9899DADBDCDDDEDF'     (X'D8' TO X'DF')\n         DC    X'E0E1A2A3A4A5A6A7'     (X'E0' TO X'E7')\n         DC    X'A8A9EAEBECEDEEEF'     (X'E8' TO X'EF')\n         DC    X'F0F1F2F3F4F5F6F7'     (X'F0' TO X'F7')\n         DC    X'F8F9FAFBFCFDFEFF'     (X'F8' TO X'FF')\n         END\n*  CHANGE ACTIVITY\n*\n*  OY08282 - 870909 - COMPILER ERROR RESULT BECAUSE THERE ARE TWO\n*            'TTLOW' LABELS AND NO 'TTUPP' LABEL.  ALSO, TTUPP ENTRIES\n*            IN THE RANGE X'C1' TO X'E9' CHANGED TO ASSURE UPPERCASE\n*            CHARACTERS REMAIN IN UPPERCASE.  GT4045-SFG\n*\n*  OY08618 - 879010 - IN TRANSLATE TABLE TTVDSN, FIELDS X'6D' AND X'6E'\n*            ARE REVERSED.  IN TTETO, ENTRY FOR X'E1' SHOULD BE X'15'\n*            INSTEAD OF X'E1'.  GT4045-SFG\n*\n./ ADD NAME=BRACKET3\n++USERMOD(BRACKET3) /* ISPF 3.3 ISPF OPTION 0.1 TERMINAL TYPE USERMOD\n**********************************************************************\n***                                                                ***\n***  This usermod updates the ISPF option 0.1 panels to allow      ***\n***  entry of a terminal type called \"ASCII\" that supports         ***\n***  square brackets.                                              ***\n***                                                                ***\n***  Also required is BRACKET1, which creates the required ISPF    ***\n***  terminal translate table ISPX7171; and BRACKET2, which creates***\n***  the required ISPF/PDF terminal translate table ISRX7171.      ***\n***                                                                ***\n***  Corresponding V3R2 usermod:  #SPF335                          ***\n***  Corresponding V3R1 usermod:  #SPF311 (the option 0.1 part)    ***\n***                                                                ***\n********************************************************************/.\n++VER(Z038) FMID(JIF3310).\n++IF FMID(HIF3302) THEN REQ(BRACKET1) /* ISPX7171 module       */ .\n++IF FMID(HDV3302) THEN REQ(BRACKET2) /* ISRX7171 module       */ .\n++PNLENU(ISPOPT1).\n)ATTR\n  \\ TYPE(INPUT) INTENS(HIGH) PAD(NULLS)\n)BODY\n%------------------------  TERMINAL CHARACTERISTICS  ---------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+TERMINAL TYPE    %===>_ZTERM   +(3277   - 3275/3277 terminal)\n+                                (3277A  - 3275/3277 with APL keyboard)\n+                                (3278   - 3276/3278/3279/3290 terminal)\n+                                (3278A  - 3276/3278/3279 APL keyboard)\n+                                (3278T  - 3276/3278/3279 TEXT keyboard)\n+                                (3290A  - 3290 with APL keyboard)\n+                                (ASCII  - VT100, PC, or other ASCII keyboard)\n+\n+NUMBER OF PF KEYS%===>_ZKEYS+   (12 or 24)\n+\n+INPUT FIELD PAD  %===>\\Z+       (N - Nulls)  (B - Blanks)  (Special Character-\n+                                    must not be the same as COMMAND DELIMITER)\n+\n+COMMAND DELIMITER%===>_Z+       (Special character for command stacking)+\n+\n+SCREEN FORMAT    %===>_ZSF +    (Select one of the following:)\n+ (3278 Model 5 only)            (DATA - Format based on data width)\n+                                (STD  - Always format 24 lines by 80 chars)\n+                                (MAX  - Always format 27 lines by 132 chars)\n+\n)INIT\n  .HELP = ISP05100\n  .ZVARS = '(ZPADC ZDEL)'\n  &ZSF  = TRANS (&ZFMT D,DATA S,STD M,MAX P,PART *,' ')\n)PROC\n IF (.RESP = ENTER)\n   IF (&ZVERB \u00ac= ' ')\n     .MSG = ISPZ002                      /* INVALID COMMAND            */\n   ELSE\n     IF (&ZCMD \u00ac= ' ')\n       .MSG = ISPZ001                    /* INVALID COMMAND            */\n VER (&ZTERM NB LIST 3277,3277A,3278,3278A,3278T,           /* BRACKET3 */\n                     3278CF,3277KN,3278KN,3290A,ASCII)      /* BRACKET3 */\n &ZCHARLM = TRANS(&ZTERM\n                  3277  ,  ISP3277\n                  3277A ,  ISP3277A\n                  3278  ,  ISP3278\n                  3278A ,  ISP3278A\n                  3290A ,  ISP3278A\n                  ASCII ,  ISPX7171                         /* BRACKET3 */\n                  3278T ,  ISP3278T\n                  3278CF,  ISP3278C\n                  3277KN,  ISP3277K\n                  3278KN,  ISP3278K)\n\n VER (&ZKEYS NB LIST 12,24)\n\n IF  (&ZTERM = 3278T)\n   VER (&ZSF LIST STD,DATA,MAX MSG=ISPO005)\n\n VER (&ZPADC NB,MSG=ISPP190)\n IF (&ZDEL = &ZPADC) .MSG = ISPO003\n IF (&ZPADC = LIST A,C,D,E,F,G,H,I,J,K,L,M,O,P,Q,R,S,T,U,V,W,X,Y,Z,\n                  0,1,2,3,4,5,6,7,8,9)\n   .MSG = ISPP195\n IF (&ZDEL  = LIST A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,\n                  0,1,2,3,4,5,6,7,8,9,'.','=')\n   .MSG = ISPP195\n\n VER (&ZSF,NONBLANK)\n &ZFMT = TRUNC (&ZSF,1)\n VER (&ZFMT,LIST  D,S,M,P)\n\n VER (&ZDEL NB PICT C)\n\n IF (.MSG \u00ac= ' ')\n   .RESP = ENTER\n)END\n/* 5685-054 (C) COPYRIGHT IBM CORP. 1980, 1991                                */\nUsermods:\nBRACKET3 - SEB1525 - Support for ASCII terminal type (ISPX7171) added.\n  The following 2 lines were removed from the body to make room for our\n  enhancements (we don't have 3290's, so we can do this):\n------------------------------------------------------------------------\n+ (3290 Only)                    (PART - Format using hardware partitions.\n+                                        Effective the next ISPF invocation.)\n------------------------------------------------------------------------\n++PNLENU(ISPOPT3A).\n)ATTR\n@ TYPE(INPUT) CAPS(OFF)\n)BODY\n%------------------------ PF KEY DEFINITIONS AND LABELS ------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+NUMBER OF PF KEYS%===>_ZKEYS+                       TERMINAL TYPE%===>_ZTERM  +\n+\n+PF1 %===>@ZPF13\n+PF2 %===>@ZPF14\n+PF3 %===>@ZPF15\n+PF4 %===>@ZPF16\n+PF5 %===>@ZPF17\n+PF6 %===>@ZPF18\n+PF7 %===>@ZPF19\n+PF8 %===>@ZPF20\n+PF9 %===>@ZPF21\n+PF10%===>@ZPF22\n+PF11%===>@ZPF23\n+PF12%===>@ZPF24\n+\n+PF1  LABEL%===>@ZPFL13  +  PF2  LABEL%===>@ZPFL14  +  PF3  LABEL%===>@ZPFL15  +\n+PF4  LABEL%===>@ZPFL16  +  PF5  LABEL%===>@ZPFL17  +  PF6  LABEL%===>@ZPFL18  +\n+PF7  LABEL%===>@ZPFL19  +  PF8  LABEL%===>@ZPFL20  +  PF9  LABEL%===>@ZPFL21  +\n+PF10 LABEL%===>@ZPFL22  +  PF11 LABEL%===>@ZPFL23  +  PF12 LABEL%===>@ZPFL24  +\n+\n+Press%ENTER+key to save changes.  Enter%END+command to save changes and exit.\n)INIT\n  .HELP = ISP05300\n  .CURSOR = ZCMD\n)PROC\n IF (.RESP = ENTER)\n   IF (&ZVERB \u00ac= ' ')\n     .MSG = ISPZ002\n   ELSE\n     IF (&ZCMD \u00ac= ' ')\n       .MSG = ISPZ001\n VER (&ZKEYS NB LIST 12,24 MSG=ISPO004)\n\n VER (&ZTERM NB LIST 3277,3277A,3278,3278A,3278T,3278CF,3277KN,3278KN,3290A\n         ASCII                                                     /* #SPF356 */\n         MSG=ISPO004)\n\n &ZCHARLM = TRANS(&ZTERM\n                  3277  ,  ISP3277\n                  3277A ,  ISP3277A\n                  3278  ,  ISP3278\n                  3278A ,  ISP3278A\n                  3290A ,  ISP3278A\n                  ASCII ,  ISPX7171                        /* BRACKET3 */\n                  3278T ,  ISP3278T\n                  3278CF,  ISP3278C\n                  3277KN,  ISP3277K\n                  3278KN,  ISP3278K)\n\n IF (&ZPF13 = ' ')\n   &ZPF13 = HELP\n IF (&ZPF14 = ' ')\n   &ZPF14 = SPLIT\n IF (&ZPF15 = ' ')\n   &ZPF15 = END\n IF (&ZPF16 = ' ')\n   &ZPF16 = RETURN\n IF (&ZPF17 = ' ')\n   &ZPF17 = RFIND\n IF (&ZPF18 = ' ')\n   &ZPF18 = RCHANGE\n IF (&ZPF19 = ' ')\n   &ZPF19 = UP\n IF (&ZPF20 = ' ')\n   &ZPF20 = DOWN\n IF (&ZPF21 = ' ')\n   &ZPF21 = SWAP\n IF (&ZPF22 = ' ')\n   &ZPF22 = LEFT\n IF (&ZPF23 = ' ')\n   &ZPF23 = RIGHT\n IF (&ZPF24 = ' ')\n   &ZPF24 = RETRIEVE\n VPUT ( ZPF13 ZPF14 ZPF15 ZPF16 ZPF17 ZPF18 ) PROFILE\n VPUT ( ZPF19 ZPF20 ZPF21 ZPF22 ZPF23 ZPF24 ) PROFILE\n VPUT ( ZPFL13 ZPFL14 ZPFL15 ZPFL16 ZPFL17 ZPFL18 ) PROFILE\n VPUT ( ZPFL19 ZPFL20 ZPFL21 ZPFL22 ZPFL23 ZPFL24 ) PROFILE\n IF (.MSG \u00ac= ' ')\n   .RESP = ENTER\n)END\n/* 5685-054 (C) COPYRIGHT IBM CORP. 1980, 1991                                */\nUsermods:\nBRACKET3 - SEB1525 - Support for ASCII terminal type (ISPX7171) added.\n++PNLENU(ISPOPT3B).\n)ATTR\n@ TYPE(INPUT) CAPS(OFF)\n)BODY\n%---------------- PF KEY DEFINITIONS AND LABELS - PRIMARY KEYS -----------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+NUMBER OF PF KEYS%===>_ZKEYS+                       TERMINAL TYPE%===>_ZTERM  +\n+\n+PF13%===>@ZPF13\n+PF14%===>@ZPF14\n+PF15%===>@ZPF15\n+PF16%===>@ZPF16\n+PF17%===>@ZPF17\n+PF18%===>@ZPF18\n+PF19%===>@ZPF19\n+PF20%===>@ZPF20\n+PF21%===>@ZPF21\n+PF22%===>@ZPF22\n+PF23%===>@ZPF23\n+PF24%===>@ZPF24\n+\n+PF13 LABEL%===>@ZPFL13  +  PF14 LABEL%===>@ZPFL14  +  PF15 LABEL%===>@ZPFL15  +\n+PF16 LABEL%===>@ZPFL16  +  PF17 LABEL%===>@ZPFL17  +  PF18 LABEL%===>@ZPFL18  +\n+PF19 LABEL%===>@ZPFL19  +  PF20 LABEL%===>@ZPFL20  +  PF21 LABEL%===>@ZPFL21  +\n+PF22 LABEL%===>@ZPFL22  +  PF23 LABEL%===>@ZPFL23  +  PF24 LABEL%===>@ZPFL24  +\n+\n+Press%ENTER+key to display alternate keys.  Enter%END+command to exit.\n)INIT\n  .HELP = ISP05300\n  .CURSOR = ZCMD\n)PROC\n IF (.RESP = ENTER)\n   IF (&ZVERB \u00ac= ' ')\n     .MSG = ISPZ002\n   ELSE\n     IF (&ZCMD \u00ac= ' ')\n       .MSG = ISPZ001\n VER (&ZKEYS NB LIST 12,24 MSG=ISPO004)\n\n VER (&ZTERM NB LIST 3277,3277A,3278,3278A,3278T,3278CF,3277KN,3278KN,3290A\n         ASCII                                                     /* #SPF356 */\n         MSG=ISPO004)\n\n &ZCHARLM = TRANS(&ZTERM\n                  3277  ,  ISP3277\n                  3277A ,  ISP3277A\n                  3278  ,  ISP3278\n                  3278A ,  ISP3278A\n                  3290A ,  ISP3278A\n                  ASCII ,  ISPX7171                        /* BRACKET3 */\n                  3278T ,  ISP3278T\n                  3278CF,  ISP3278C\n                  3277KN,  ISP3277K\n                  3278KN,  ISP3278K)\n\n IF (&ZPF13 = ' ')\n   &ZPF13 = HELP\n IF (&ZPF14 = ' ')\n   &ZPF14 = SPLIT\n IF (&ZPF15 = ' ')\n   &ZPF15 = END\n IF (&ZPF16 = ' ')\n   &ZPF16 = RETURN\n IF (&ZPF17 = ' ')\n   &ZPF17 = RFIND\n IF (&ZPF18 = ' ')\n   &ZPF18 = RCHANGE\n IF (&ZPF19 = ' ')\n   &ZPF19 = UP\n IF (&ZPF20 = ' ')\n   &ZPF20 = DOWN\n IF (&ZPF21 = ' ')\n   &ZPF21 = SWAP\n IF (&ZPF22 = ' ')\n   &ZPF22 = LEFT\n IF (&ZPF23 = ' ')\n   &ZPF23 = RIGHT\n IF (&ZPF24 = ' ')\n   &ZPF24 = RETRIEVE\n VPUT ( ZPF13 ZPF14 ZPF15 ZPF16 ZPF17 ZPF18 ) PROFILE\n VPUT ( ZPF19 ZPF20 ZPF21 ZPF22 ZPF23 ZPF24 ) PROFILE\n VPUT ( ZPFL13 ZPFL14 ZPFL15 ZPFL16 ZPFL17 ZPFL18 ) PROFILE\n VPUT ( ZPFL19 ZPFL20 ZPFL21 ZPFL22 ZPFL23 ZPFL24 ) PROFILE\n IF (.MSG \u00ac= ' ')\n   .RESP = ENTER\n)END\n/* 5685-054 (C) COPYRIGHT IBM CORP. 1980, 1991                                */\nUsermods:\nBRACKET3 - SEB1525 - Support for ASCII terminal type (ISPX7171) added.\n./ ENDUP\n?!\n//EXEC     EXEC MDLOAD,TRK1='5',TRK2='1',TO='EXEC'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=BRACKETS\n/* REXX.  Use this in conjunction with ISPF \"ASCII\" terminal table on\n          a non-extended-attributes terminal. */\ntrace off\nsignal on failure\naddress TSO\narg junk\nif junk = \"OFF\" then do\n address TSO \"TERM NOCHAR\"\nend\nelse if junk = \"3179\" then do\n address TSO,\n \"TERM CHAR((X'BA' X'AD') (X'BB' X'BD') (X'AD' X'BA') (X'BD' X'BB'))\"\nend\nelse if junk \\= \"\" then do\n say \"Invalid value\" junk\nend\nelse do\n address TSO,\n \"TERM CHAR((X'41' X'AD') (X'42' X'BD') (X'AD' X'41') (X'BD' X'42'))\"\nend\nexit\n./ ENDUP\n?!\n//HELP     EXEC MDLOAD,TRK1='5',TRK2='1',TO='HELP'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=BRACKETS\n)F Function -\n\n   The BRACKETS exec changes the terminal character translation of your\n   TSO session to display square brackets properly on a 3278 terminal.\n   Note that this works properly ONLY on such a terminal.  Do not use\n   this on any other type of terminal.\n\n   Use this exec under ISPF when you are on a 3278 terminal and you\n   have set your terminal type (option 0.1) to ASCII in order to edit\n   and browse square brackets.  If you set your terminal type to ASCII\n   without using this exec, you will see odd-looking characters in\n   bracket positions.  The character translation effected by the\n   BRACKETS exec allows you to see actual brackets.\n\n   From any ISPF command line, type:  TSO %BRACKETS\n\n   Note:  If you execute BRACKETS from READY mode and then enter ISPF,\n   ISPF will turn off character translation, and you will have to\n   re-execute BRACKETS.\n\n)X Syntax -\n\n   %BRACKETS  {OFF}\n\n    Required: none\n\n    Defaults: no operand\n\n)O Operands -\n\n)P          - BRACKETS with no operand turns translation on.\n              BRACKETS OFF turns translation off.\n              BRACKETS 3179 turns translation on for a 3179 terminal,\n                but this does not have the desired effect under ISPF.\n\n./ ENDUP\n?!\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BRACKET4": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99)\\x9f\\x00\\x99)\\x9f \\t\\x08\\xfe\\x08\\xfe\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-10-26T00:00:00", "modifydate": "1999-10-26T20:09:00", "lines": 2302, "newlines": 2302, "modlines": 0, "user": "SEB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "GOPHER": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99)\\x9f\\x00\\x99)\\x9f\\x19VN\\x00N\\x00\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-10-26T00:00:00", "modifydate": "1999-10-26T19:56:00", "lines": 19968, "newlines": 19968, "modlines": 0, "user": "SEB"}, "text": "//JOBNAME JOB ACCOUNT,'NAME'\n//*------------------------------------------------------------------*/\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis. All warranties,   */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed. Such modifications should  */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*------------------------------------------------------------------*/\n//*\n//*    GOPHER - MVS Gopher Client and Server\n//*\n//*  Version: 3  Release: 1\n//*\n//* Author: Steve Bacher <seb@draper.com>\n//*\n//* Date: 21 Mar 1996\n//*\n//*-------------------------------------------------------------------\n//*\n//* This job creates the distribution libraries (PDS's).\n//*\n//* Run this JCL to create the PDS's, after customizing to suit.\n//* (Obviously, put in a good JOB statement first.)\n//* To customize the JCL, change the defaults on the //MDLOAD PROC\n//* statement to your liking, particularly the PREFIX default.\n//* You might also want to change the final qualifiers of the PDS's\n//* created - to do this, find the // EXEC MDLOAD statements and\n//* change the value of the TO parameter.\n//*\n//* See the $$README file (of the CNTL PDS, first in this stream)\n//* for the rest of the installation instructions.\n//*\n//MDLOAD PROC CLS='*',BS='6160',U='SYSDA',V='',\n//      TRK1='60',TRK2='10',DIR='35',RLSE='RLSE',\n//      PREFIX='GOPHER.INSTALL.'\n//*\n//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=&CLS\n//SYSUT2 DD DISP=(NEW,CATLG,DELETE),DSN=&PREFIX.&TO,\n//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=&BS),\n//  SPACE=(TRK,(&TRK1,&TRK2,&DIR),&RLSE),UNIT=&U,VOL=SER=&V\n//*\n//  PEND\n//*\n//CNTL     EXEC MDLOAD,BS='6160',TRK1='10',TRK2='1',TO='CNTL'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=$$README\n\n------------------------------------------------------------------------\n\n Copyright (c) The Charles Stark Draper Laboratory, Inc.,1992,1993,1994\n\n MVS Gopher Server originally by Shawn Hart (Univ. of Delaware).\n\n This software is provided on an \"AS IS\" basis.  All warranties,\n including the implied warranties of merchantability and fitness,\n are expressly denied.\n\n Provided this copyright notice is included, this software may\n be freely distributed and not offered for sale.\n\n Changes or modifications may be made and used only by the maker\n of same, and not further distributed.  Such modifications should\n be mailed to the author for consideration for addition to the\n software and incorporation in subsequent releases.\n\n------------------------------------------------------------------------\n\n MVS Gopher Client\n\n Original Author:          Steve Bacher  <seb@draper.com>\n\n MVS Gopher Server\n\n Original Author:          Shawn Hart    <shart@indial1.io.com>\n\n Various enhancements and customizations to both the client and the\n server have been contributed by:\n\n    Steve Bacher   <seb@draper.com>\n    Lou Joseph     <cwmy5c@irishmvs.cc.nd.edu>\n    Denis DeLaRoca <csp1dwd@mvs.oac.ucla.edu>\n    Dwight Cook    <sysdc@uokmvsa.backbone.uoknor.edu>\n    Rachna Agrawal <rachna@clemson.clemson.edu>\n\n------------------------------------------------------------------------\n\n Contents of PDS's belonging to Gopher distribution:\n\n Member     PDS Type    Description\n\n $$README   CNTL        This file\n $CHANGES   CNTL        Changes since the last release\n ACCESS     CNTL        Sample server access file\n ALLOAD     CNTL        JCL to allocate additional Gopher libraries\n COMPILE    CNTL        JCL to compile *** SOURCE DISTRIBUTION ONLY ***\n GOPHERD    CNTL        JCL to run the GOPHER server in batch (No TSO)\n GOPHERT    CNTL        JCL to run the GOPHER server in batch (w. TSO)\n HELP       CNTL        TSO Help for Gopher client\n INSTALLC   CNTL        How to install the GOPHER MVS client\n INSTALLS   CNTL        How to install the GOPHER MVS server\n LINKC      CNTL        JCL to linkedit the client load module\n LINKS      CNTL        JCL to linkedit the server load modules\n LINKX      CNTL        JCL to linkedit the auxiliary load modules\n MENU       CNTL        Initial Gopher server menu\n PARMS      CNTL        Sample Gopher startup parameters\n SECURE     CNTL        Discussion about making secure REXX scripts\n GOPHER     CLIST       Exec by which users invoke the Gopher client\n NNMFIUCV   CLIST       Exec to check for multiple socket applications\n REXXTEST   CLIST       REXX exec to test the REXX interface with\n TSOHELP    CLIST       Sample REXX exec for Gopher TSO HELP menu hole\n G...       CLIST       REXX exec helpers\n GGM...     PANEL       ISPF regular panels\n ABOUT...   ABOUT       \"About This Gopher\" text\n GG...      H           C headers      *** SOURCE DISTRIBUTION ONLY ***\n GG...      C           C source       *** SOURCE DISTRIBUTION ONLY ***\n GG...      OBJ         Object modules *** OBJECT DISTRIBUTION ONLY ***\n\n--------------------------------------------------------------------\n\nWhere to Go from Here:\n\n To install the GOPHER MVS client, read member INSTALLC.\n\n To install the GOPHER MVS server, read member INSTALLS.\n\nNote:\n\n You may install only the client, only the server, or both the\n client and the server.  It is purely up to what your needs are.\n\n--------------------------------------------------------------------\n\n Questions?  Comments?  Suggestions?  Gripes?  Please email to...\n\n Steve Bacher      <seb@draper.com>\n\n./ ADD NAME=$CHANGES\nChanges:\n\n November 93 - Version 3 Release 1\n\n             Server Enhancements\n\n             Support for binary files, including image files, in the\n             remote FTP gateway.  Most file types are supported for\n             the server, and the client will support some binary types,\n             although they cannot be viewed or printed well.\n\n             The REXX interface has been completely redesigned.  It is\n             not compatible with the previous version, but migration\n             should be easy.  Among other things, you can now run REXX\n             execs from a non-TSO-environment server, which will allow\n             multithreading of client requests that trigger REXX execs.\n\n             The access file now supports wildcarding in the file name\n             specifications.  Because of this, you must stop and\n             restart the gopher server when you change the access file.\n             The rules are processed differently.\n\n             Additional logging (via write-to-programmer) in a mode\n             compatible with the format produced by the U of Minn\n             gopher daemon.\n\n             Rudimentary support for gopher+ has been added on an\n             experimental basis.  Do not rely on this, because it is\n             not complete by any means.\n\n             Client Enhancements\n\n             Printing allows destination in the form nodename.userid.\n\n             INITFILE keyword added for a differently named GOPHERRC.\n\n 07 Aug 93 - Version 2 Release 2\n\n             Remote FTP Gateway\n             Enhanced CSO client option\n             Configurable GOPHERRC: domain and telnet may be specified\n             Object-code-only distribution for those without C compilers\n             Improvements to TSO GOPHER exec for users without XPROC\n              or without C runtime in linklist\n             DD:ddname(member) works now for nested PDS member\n              references, making installing the ABOUT PDS simpler\n             \"E\" and \"P\" work without \"S\" having to be done first\n\n 20 Mar 93 - Version 2 Release 1\n\n             Improved browse function\n             Printing support\n             Bookmark support\n             New commands: PRT, INFO, MENU, BOOKMARK\n             Configurable startup parameter file\n             Ability to run multiple servers on same MVS\n\n 07 Dec 92 - Customizations to support SNS/TCPAccess\n\n 19 Oct 92 - Improvements in initial startup and GOPHERRC customization\n\n./ ADD NAME=ACCESS\n!\n! Format of entries:\n!\n! filename (fully qualified, all uppercase, no quotes)\n! can be \"DD:DDNAME\" or \"EXEC:EXECNAME\"\n!\n! followed by names of hosts which are authorized to access the data.\n! If no host name list is present, all hosts are authorized\n!\n! You may specify the same file name more than once, if you need\n! more lines to put host names on.\n!\n! Individual PDS members must be specified separately.  A PDS without\n! a member name establishes access only to the PDS directory.\n!\n! Note that the default directory MUST be in this table.\n!\n! Also note that in the case of EXECs, the EXEC must live in the\n! library allocated to GGEXEC in the Gopher server JCL.\n!\n! *** ANY DATA SET REFERENCED BY ANY EXEC IN THAT LIBRARY IS FULLY\n! *** ACCESSIBLE TO GOPHER REGARDLESS OF THIS TABLE!  USE THIS TABLE\n! *** TO GOVERN CONTROL TO THE EXEC ITSELF!!!\n\n!\n! below is default directory spec, which MUST be in this table\n!\nDD:GGGOPHER\n\n!\n! Use the following for \"About This Gopher\".\n! Free free to specify the name of your MVS client host(s)\n! for information pertinent to MVS only.  mvs1 and mvs2 are examples.\n!\nDD:GGABOUT\nDD:GGABOUT(ABOUT)\nDD:GGABOUT(ABOUTC)                                mvs1 mvs2\nDD:GGABOUT(ABOUTCD)                               mvs1 mvs2\nDD:GGABOUT(ABOUTCF)                               mvs1 mvs2\nDD:GGABOUT(ABOUTCO)                               mvs1 mvs2\nDD:GGABOUT(ABOUTCQ)                               mvs1 mvs2\nDD:GGABOUT(ABOUTCS)                               mvs1 mvs2\nDD:GGABOUT(ABOUTCSC)                              mvs1 mvs2\nDD:GGABOUT(ABOUTCSL)                              mvs1 mvs2\nDD:GGABOUT(ABOUTCSM)                              mvs1 mvs2\nDD:GGABOUT(ABOUTCSR)                              mvs1 mvs2\nDD:GGABOUT(ABOUTCSW)                              mvs1 mvs2\nDD:GGABOUT(ABOUTCSX)                              mvs1 mvs2\nDD:GGABOUT(ABOUTCX)                               mvs1 mvs2\nDD:GGABOUT(ABOUTS)                                mvs1 mvs2\nDD:GGABOUT(ABOUTSA)                               mvs1 mvs2\nDD:GGABOUT(ABOUTSP)                               mvs1 mvs2\nDD:GGABOUT(ABOUTW)\nDD:GGABOUT(FAQ)\n\n!\n! Here's how to do REXX execs.  Note - no arguments, only exec names\n!\nEXEC:CHECKLST                     client1 client2 mvs\nEXEC:WAISDIR\nEXEC:WAISLIST\nEXEC:WAISSRCH\n\nANY.PUBLIC.SEQ.DS\nANY.SEMI.PUBLIC.SEQ.DS            goodclient1 goodclient2\nANY.SEMI.PUBLIC.SEQ.DS            goodclient3 goodclient4\n\n! PDS without member name provides access to directory only\n! All member names must be explicitly listed to be accessible.\n\nANY.PUBLIC.PDS\nANY.PUBLIC.PDS(MEMBER1)\nANY.PUBLIC.PDS(MEMBER2)\nANY.PUBLIC.PDS(MEMBER3)\nANY.PUBLIC.PDS(MEMBER4)\n\n\nANY.SEMI.PUBLIC.PDS               goodclient1 goodclient2\nANY.SEMI.PUBLIC.PDS               goodclient3 goodclient4\nANY.SEMI.PUBLIC.PDS(MEMBER1)      goodclient1\nANY.SEMI.PUBLIC.PDS(MEMBER2)      goodclient2\nANY.SEMI.PUBLIC.PDS(MEMBER3)      goodclient3\nANY.SEMI.PUBLIC.PDS(MEMBER4)      goodclient4\n\n./ ADD NAME=ALLOAD\n//JOBNAME  JOB ACCOUNT,'NAME'\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*\n//* Allocate GOPHER load and object libraries before install\n//*\n//GGALLOC PROC U='3380',V=''\n//*\n//IEFBR14  EXEC PGM=IEFBR14\n//ALLOCDD  DD   DISP=(NEW,CATLG,DELETE),DSN=&LIB,\n//         DCB=(RECFM=&RF,LRECL=&LR,BLKSIZE=&BS),\n//         SPACE=(&BS,(&PRI,&SEC,&DIR)),UNIT=&U,VOL=SER=&V\n//*\n//         PEND\n//*\n//* The ALLOCL step allocates the load library from which the\n//* executable program will be run.  If you intend to place the\n//* executable into an existing library, you can skip this step.\n//* Otherwise, the name must match the name used on the LOADLIB\n//* parameter of the GGLINK procedure in the LINK* JCL steps.\n//*\n//* If you want separate libraries for the client and the server,\n//* just duplicate this step and give the LIB's different names.\n//*\n//* The ALLOCO step allocates the object library into which the\n//* source modules will be compiled.  This library is required\n//* for the compile and link steps, but is not required for run\n//* time execution.  However, you may wish to keep the object\n//* library around in case there are fixes for which you will be\n//* recompiling individual Gopher source modules.\n//*\n//ALLOCL   EXEC GGALLOC,PRI=50,SEC=50,DIR=35,RF=U,LR=,BS=6233,\n//         LIB='GOPHER.LOAD'\n//ALLOCO   EXEC GGALLOC,PRI=50,SEC=50,DIR=35,RF=FB,LR=80,BS=2960,\n//         LIB='GOPHER.INSTALL.OBJ'\n//*\n./ ADD NAME=COMPILE\n//JOBNAME  JOB ACCOUNT,'NAME'\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*********************************************************************\n//*\n//* Compile some or all GOPHER C/370 sources to make the SYSLIN input\n//* to the linkedit of the executable Gopher load module(s).\n//*\n//GGCC   PROC MEMBER=,\n//            SRCLIB='GOPHER.INSTALL.C',         GOPHER C source PDS\n//            HDRLIB='GOPHER.INSTALL.H',         GOPHER C headers PDS\n//            OBJLIB='GOPHER.INSTALL.OBJ',       GOPHER object library\n//            COMMHDR='TCPIP.COMMMAC',           C/370 TCP/IP headers\n//            C370HDR='SYS1.EDCHDRS',            C/370 standard headers\n//            SYSMSGS='SYS1.EDCMSGS',            C/370 messages file\n//            SYSMSGM='EDCMSGE',                 C/370 message member\n//            VIOUNIT=VIO,                       Temporary disk unit\n//            OUTCLAS='*',                          SYSOUT class\n//            CPARMS='SOURCE EXPMAC NOAGGR NOXREF', Compile parameters\n//            TEST=TEST                             TEST or NOTEST\n//*\n//CCOMP     EXEC PGM=EDCCOMP,PARM='MARGINS(1,72) &TEST &CPARMS'\n//SYSMSGS   DD DISP=SHR,DSN=&SYSMSGS(&SYSMSGM)\n//SYSIN     DD DISP=SHR,DSN=&SRCLIB(&MEMBER)\n//SYSLIN    DD DISP=OLD,DSN=&OBJLIB(&MEMBER)\n//SYSLIB    DD DISP=SHR,DSN=&COMMHDR\n//          DD DISP=SHR,DSN=&C370HDR\n//USERLIB   DD DISP=SHR,DSN=&HDRLIB\n//SYSPRINT  DD SYSOUT=&OUTCLAS\n//SYSCPRT   DD SYSOUT=&OUTCLAS\n//SYSUT1    DD DSN=&&SYSUT1,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT4    DD DSN=&&SYSUT4,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT6    DD DSN=&&SYSUT6,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT7    DD DSN=&&SYSUT7,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT8    DD DSN=&&SYSUT8,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT9    DD DSN=&&SYSUT9,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)\n//SYSUT10   DD SYSOUT=&OUTCLAS\n//*\n//         PEND\n//*\n//GGACCES  EXEC GGCC,MEMBER=GGACCES\n//GGALLOC  EXEC GGCC,MEMBER=GGALLOC\n//GGASVC   EXEC GGCC,MEMBER=GGASVC\n//GGBARF   EXEC GGCC,MEMBER=GGBARF\n//GGBIN    EXEC GGCC,MEMBER=GGBIN\n//GGBKMGR  EXEC GGCC,MEMBER=GGBKMGR\n//GGCLIEN  EXEC GGCC,MEMBER=GGCLIEN\n//GGCLRTX  EXEC GGCC,MEMBER=GGCLRTX\n//GGCONN   EXEC GGCC,MEMBER=GGCONN\n//GGCSO    EXEC GGCC,MEMBER=GGCSO\n//GGDBM    EXEC GGCC,MEMBER=GGDBM\n//GGDFAIL  EXEC GGCC,MEMBER=GGDFAIL\n//GGDIR    EXEC GGCC,MEMBER=GGDIR\n//GGDISC   EXEC GGCC,MEMBER=GGDISC\n//GGDISPL  EXEC GGCC,MEMBER=GGDISPL\n//GGDSOPT  EXEC GGCC,MEMBER=GGDSOPT\n//GGDUMP   EXEC GGCC,MEMBER=GGDUMP\n//GGESRVR  EXEC GGCC,MEMBER=GGESRVR\n//GGFREEM  EXEC GGCC,MEMBER=GGFREEM\n//GGFTP    EXEC GGCC,MEMBER=GGFTP\n//GGGETDS  EXEC GGCC,MEMBER=GGGETDS\n//GGGETM   EXEC GGCC,MEMBER=GGGETM\n//GGGOFOR  EXEC GGCC,MEMBER=GGGOFOR\n//GGGSRVL  EXEC GGCC,MEMBER=GGGSRVL\n//GGIERR   EXEC GGCC,MEMBER=GGIERR\n//GGIGET   EXEC GGCC,MEMBER=GGIGET\n//GGINFO   EXEC GGCC,MEMBER=GGINFO\n//GGISPF   EXEC GGCC,MEMBER=GGISPF\n//GGIVGET  EXEC GGCC,MEMBER=GGIVGET\n//GGIVPUT  EXEC GGCC,MEMBER=GGIVPUT\n//GGMENU   EXEC GGCC,MEMBER=GGMENU\n//GGMTFER  EXEC GGCC,MEMBER=GGMTFER\n//GGOUTS   EXEC GGCC,MEMBER=GGOUTS\n//GGOUTTX  EXEC GGCC,MEMBER=GGOUTTX\n//GGPMSG   EXEC GGCC,MEMBER=GGPMSG\n//GGPROC   EXEC GGCC,MEMBER=GGPROC\n//GGREXX   EXEC GGCC,MEMBER=GGREXX\n//GGSERVE  EXEC GGCC,MEMBER=GGSERVE\n//GGSLEEP  EXEC GGCC,MEMBER=GGSLEEP\n//GGSOCKT  EXEC GGCC,MEMBER=GGSOCKT\n//GGSOPT   EXEC GGCC,MEMBER=GGSOPT\n//GGSTASK  EXEC GGCC,MEMBER=GGSTASK\n//GGTEMP   EXEC GGCC,MEMBER=GGTEMP\n//GGTNET   EXEC GGCC,MEMBER=GGTNET\n//GGTSO    EXEC GGCC,MEMBER=GGTSO\n//GGTYPE   EXEC GGCC,MEMBER=GGTYPE\n//GGUNALC  EXEC GGCC,MEMBER=GGUNALC\n//GGVIEW   EXEC GGCC,MEMBER=GGVIEW\n//GGVTX    EXEC GGCC,MEMBER=GGVTX\n//GGWAIS   EXEC GGCC,MEMBER=GGWAIS\n//GGWHOIS  EXEC GGCC,MEMBER=GGWHOIS\n//GGWTO    EXEC GGCC,MEMBER=GGWTO\n//GGXTX    EXEC GGCC,MEMBER=GGXTX\n//XGALLOC  EXEC GGCC,MEMBER=XGALLOC\n//XGCALL   EXEC GGCC,MEMBER=XGCALL\n//XGSLEEP  EXEC GGCC,MEMBER=XGSLEEP\n//XGWTO    EXEC GGCC,MEMBER=XGWTO\n//*\n./ ADD NAME=GOPHERD\n//GOPHERD  PROC MODULE=GGSERVER,\n//         STEPLIB='GOPHER.LOAD',\n//         EXECLIB='GOPHER.EXEC',\n//         ACCESS='GOPHER.ACCESS',\n//         ABOUT='GOPHER.ABOUT',\n//         MENU='GOPHER.MENU',\n//         PARMS='GOPHER.PARMS',\n//         VIO=SYSVIO,\n//         STDERR='*',\n//         STDOUT='*',\n//         GPARM=\n//*\n//*********************************************************************\n//*                                                                   *\n//* GOPHER daemon, by Shawn Hart (U.Del.) and Steve Bacher (D.Lab.)   *\n//*                                                                   *\n//* Straight batch (no TSO access)                                    *\n//*                                                                   *\n//*********************************************************************\n//*\n//GOPHERD  EXEC PGM=&MODULE,PARM='&GPARM'\n//STEPLIB  DD   DISP=SHR,DSN=&STEPLIB\n//GGEXEC   DD   DISP=SHR,DSN=&EXECLIB\n//SYSTSPRT DD   UNIT=&VIO,SPACE=(TRK,(100,100)),RECFM=VBA,LRECL=255\n//SYSERR   DD   SYSOUT=&STDERR\n//SYSPRINT DD   SYSOUT=&STDOUT\n//SYSTSIN  DD   DUMMY\n//SYSIN    DD   DUMMY\n//GGDEBUG  DD   SYSOUT=*\n//GGABOUT  DD   DISP=SHR,DSN=&ABOUT\n//GGACCESS DD   DISP=SHR,DSN=&ACCESS\n//GGGOPHER DD   DISP=SHR,DSN=&MENU\n//GGPARMS  DD   DISP=SHR,DSN=&PARMS\n./ ADD NAME=GOPHERT\n//GOPHERD  PROC MODULE=GGSERVER,\n//         STEPLIB='GOPHER.LOAD',\n//         EXECLIB='GOPHER.EXEC',\n//         ACCESS='GOPHER.ACCESS',\n//         ABOUT='GOPHER.ABOUT',\n//         MENU='GOPHER.MENU',\n//         PARMS='GOPHER.PARMS',\n//         VIO=SYSVIO,\n//         STDERR='*',\n//         STDOUT='*',\n//         GPARM=\n//*\n//*********************************************************************\n//*                                                                   *\n//* GOPHER daemon, by Shawn Hart (U.Del.) and Steve Bacher (D.Lab.)   *\n//*                                                                   *\n//* Batch with TSO environment - required only to run REXX execs      *\n//* that use TSO services                                             *\n//*                                                                   *\n//*********************************************************************\n//*\n//GOPHERD  EXEC PGM=IKJEFT01,DYNAMNBR=128,REGION=8M,\n//         PARM='&MODULE &GPARM'\n//STEPLIB  DD   DISP=SHR,DSN=&STEPLIB\n//GGEXEC   DD   DISP=SHR,DSN=&EXECLIB\n//SYSTSPRT DD   UNIT=&VIO,SPACE=(TRK,(100,100)),RECFM=VBA,LRECL=255\n//SYSERR   DD   SYSOUT=&STDERR\n//SYSPRINT DD   SYSOUT=&STDOUT\n//SYSTSIN  DD   DUMMY\n//SYSIN    DD   DUMMY\n//GGDEBUG  DD   SYSOUT=*\n//GGABOUT  DD   DISP=SHR,DSN=&ABOUT\n//GGACCESS DD   DISP=SHR,DSN=&ACCESS\n//GGGOPHER DD   DISP=SHR,DSN=&MENU\n//GGPARMS  DD   DISP=SHR,DSN=&PARMS\n./ ADD NAME=HELP\n)F Function -\n\n GOPHER is a distributed document delivery service, or, more generally,\n a networked information retrieval service.  It allows you to access\n numerous types of data on various hosts in a transparent fashion.\n GOPHER presents you with a hierarchical display of information sources\n which are accessed via a client/server communications link.\n\n There are GOPHER clients for all common hardware platforms.  The MVS\n version runs as an ISPF dialog application.\n\n When you use the GOPHER client, information about your use of GOPHER\n is stored in a data set called GOPHERRC.  If you don't have one,\n GOPHER will create it for you.  You can specify a different name\n for this data set with the INITFILE keyword.\n\n You can save Gopher information in bookmark files.  See the\n help for operand BOOKMARK for details.\n\n For more information on customizing your GOPHER environment, get\n into Gopher and select \"About This GOPHER\".\n\n)I GOPHLOC          - local GOPHER help goes in member GOPHLOC\n\n)X Syntax -\n\n   %GOPHER\n              LOCAL\n              BOOKMARK(datasetname)\n              INITFILE(gopherrcname)\n              SERVER(hostname)\n              PATH(pathname)\n              PORT(portnumber)\n              DESCRIPTION(text)\n              FORCE\n              DEBUG\n              TEST\n\n   Required:  none\n\n   Defaults:  INITFILE defaults to tsouserid.GOPHERRC\n\n)O Operands -\n\n))LOCAL\n\n              Specify LOCAL if you want to enter GOPHER in \"serverless\"\n              mode - i.e. start up with your private GOPHER menu.\n              Specifying LOCAL accomplishes two things:\n\n               (1) It sets the server to \"-\", meaning local access.\n                   Therefore, you must also provide a path, either\n                   via the PATH operand or via a \"localmenu:\" spec\n                   in your GOPHERRC file.\n\n               (2) It allows you to use GOPHER even if there are\n                   other TCP/IP socket applications active elsewhere\n                   in your TSO session.  However, it will not allow\n                   you to connect to any GOPHER servers, even if you\n                   have a local menu item that points to one.\n\n              For information on how to set up GOPHER menus, get into\n              GOPHER and select \"About This Gopher\".\n\n))BOOKMARK(datasetname)\n\n              The name of a data set containing Gopher bookmarks,\n              using normal TSO data set naming conventions.\n\n              You can create bookmarks in GOPHER by using the \"B\"\n              selection code next to a menu item, or by using the\n              BOOKMARK command while browsing an entry.  GOPHER will\n              append an entry for the selected item to the end of\n              the data set that you specify when asked.\n\n              To access this bookmark in a Gopher session, you can use\n              the MENU command from any Gopher menu display, or you can\n              start Gopher with a specific bookmark file.\n\n))INITFILE(gopherrcname)\n\n              The name of a data set containing startup information,\n              commonly referred to as your \"GOPHERRC\" file.  If this\n              file does not exist, it will be automatically created.\n              The default for this name is tsouserid.GOPHERRC.\n\n))SERVER(hostname)\n\n              The host name (or IP address) of a Gopher server.\n              If this is not given, GOPHER looks in your GOPHERRC\n              to find what server to connect to.  If it can't find\n              an appropriate specification, you will have to enter\n              a server name on the startup panel.\n\n              A server name of a single minus sign (-) is a special\n              case, signifying local (serverless) access to your\n              own private GOPHER data.  In this case, you must tell\n              GOPHER where your menu is, either via the PATH operand\n              or in the GOPHERRC file.\n\n))PATH(pathname)\n\n              The path name to be passed to the Gopher server, or\n              used in local access as your initial menu.  Although\n              the exact interpretation of the pathname string varies\n              depending on the server, both the MVS server and the\n              local GOPHER access feature interpret the pathname\n              as the FULLY QUALIFIED WITHOUT QUOTES name of an MVS\n              data set containing a gopher menu.  For information\n              about the format of a gopher menu, see operand MENU.\n\n))PORT(portnumber)\n\n              You should never need to specify this field unless\n              someone has set up a special kind of Gopher server that\n              requires a unique port number.  In such a case, you\n              would generally use this along with the SERVER operand.\n\n))DESCRIPTION(text)\n\n              A text string giving the heading to be displayed for\n              the initial directory of Gopher goodies.  Normally\n              either the Gopher server or the Gopher client will\n              have a default value for this, or you can specify\n              a description of your liking in your GOPHERRC file.\n              You can also use this to override the description\n              generated when you use the BOOKMARK operand to start up.\n\n))FORCE\n\n              GOPHER tries to determine if there is a TCP/IP socket\n              application active elsewhere in your TSO environment\n              before starting up, to prevent TCP/IP errors.  If it\n              tells you that there is another client active but in\n              truth there is none and you know it, you can use the\n              FORCE keyword to make GOPHER proceed whether it finds\n              this to be the case or not.\n\n              Using the LOCAL operand is one way to avoid this entire\n              scenario.  However, that won't allow you to access any\n              Gopher servers on the network.\n\n))DEBUG\n\n              Set debugging mode on.  You must preallocate a file to\n              ddname GGDEBUG for this to work.  This can be allocated\n              to the terminal or a log file.  When debug mode is on,\n              messages describing memory allocation and deallocation\n              and GOPHER queries sent are dumped to the debug file.\n\n))TEST\n\n              Activate C/370 interactive test (INSPECT).  GOPHER must\n              have been compiled with the TEST option for this to be\n              effective.  Note that you can also issue the TEST command\n              inside GOPHER to get to INSPECT, again provided that\n              GOPHER was compiled with the TEST option.\n\n./ ADD NAME=INSTALLC\n\n Directions for Installing the GOPHER MVS Client\n\n where @ is the install prefix from the unload and $ is a system prefix\n\n Summary:\n\n 1. (all users)      Customize @.H      - GGUSER\n 2. (all users)      Customize @.CNTL   - ALLOAD\n 3. (all users)      Customize @.CNTL   - COMPILE\n 4. (all users)      Customize @.CNTL   - LINKC\n 5. (all users)      Customize @.CLIST  - GOPHER\n 6. (if not ISPF V3) Edit      @.PANEL  - GGMP*\n 7. (all users)      Submit    @.CNTL   - ALLOAD   ==> $.LOAD, @.OBJ\n 8. (all users)      Submit    @.CNTL   - COMPILE  --> @.OBJ(*)\n 9. (all users)      Submit    @.CNTL   - LINKC    --> $.LOAD(GG*)\n 10.(REXX users)     Submit    @.CNTL   - LINKX    --> $.LOAD(XG*)\n 11.(all users)      Install   @.CNTL   - HELP     --> $.HELP(GOPHER)\n 12.(all users)      Install   @.CLIST  - GOPHER   --> $.CLIST(GOPHER)\n 13.(all users)      Install   @.CLIST  - NNMFIUCV --> $.CLIST(NNMFIUCV)\n 14.(REXX users)     Install   @.CLIST  - *        --> $.CLIST(*)\n 15.(all users)      Install   @.PANEL  - *        --> $.PANEL(*)\n 16.(all users)      Install   @.ABOUT  - *        --> $.ABOUT(*)\n\n System libraries to be updated:\n\n $.LOAD  - specified in .CNTL(ALLOAD)\n $.OBJ   - specified in .CNTL(ALLOAD)\n $.HELP  - your existing logon-time TSO HELP  (SYSHELP) library\n $.CLIST - your existing logon-time TSO CLIST (SYSPROC) library\n $.PANEL - your existing logon-time ISPF PANEL (ISPPLIB) library\n $.ABOUT - a new PDS you make yourself, or use the install copy\n\n Assuming you have unloaded all the install PDS's:\n\n 1. Customize the GGUSER header file as shown by the comments therein.\n Note in particular the defines for your TCP/IP and your C compiler.\n There are changes to the linkedit JCL that are related to these.\n\n 2,3,4. Customize the ALLOAD, COMPILE and LINKC JCL members to reflect\n your local conventions.  Note:  If you intend to place the executable\n into an existing library, you can suppress that part of the ALLOAD JCL.\n The name of the data set created must match across both members.\n\n *********************************************************************\n\n IMPORTANT:  If you are running TCP/IP V2R2 or higher on MVS, you must\n change the following library names in the compile and link JCL:\n\n   TCPIP.COMMMAC   should be changed to  TCPIP.SEZACMAC\n   TCPIP.COMMTXT   should be changed to  TCPIP.SEZACMTX\n\n If you are using SNS/TCPAccess, use these library names, or\n whatever names are defined at your installation:\n\n   TCPIP.COMMMAC   should be changed to  SNSTCP.V110.H\n   TCPIP.COMMTXT   should be changed to  SNSTCP.V110.CILIB\n\n If you are using SAS/C, change CEESTART to MAIN in the linkedit\n ENTRY control statement.\n\n *********************************************************************\n\n Note:  If you have defined C370V1 in the GGUSER header file, you must\n also include the system linklist load library or libraries containing\n ISPLINK, ISPEXEC and IKJEFF18 when linking.  Otherwise you may delete\n the lines from the linkedit JCL that reference them.\n\n Note:  You need not include the PASCAL libraries or the AMPZMVSB\n module if you are using TCP/IP Version 2 or higher, in which case\n you must also define TCPIPV2 in the GGUSER headerfile.\n\n 5. Customize the GOPHER exec to define the names of the MVS libraries\n to contain the panel and load library members.  The load library must\n be the one specified in the ALLOAD JCL, if you are creating it anew.\n Observe the comments relating to the use of LIBDEF and ISPF APPLIDs.\n\n It is in the GOPHER exec that you will also customize the name of the\n default Gopher server.  Note that the user's GOPHERRC file gets built\n from the contents of this exec.\n\n You may configure the GOPHER exec to use XPROC to parse the operands\n given to it by the TSO user.  If you don't have XPROC, you should get\n it, because the user can take advantage of all the power of TSO CLIST\n style parsing if you do.  The GOPHER exec contains some code that\n emulates full TSO parsing, but it isn't as robust or flexible as true\n XPROC parsing.  You can get XPROC from ftp.mic.ucla.edu in directory\n /pub/mvs/util, as part of the TSOREXX distribution.\n\n If the C/370 runtime library is not in the link list or otherwise\n available to ISPF at execution time, you may arrange for it to be\n allocated via LIBDEF in the GOPHER exec by setting \"crunlibs\".\n\n 6. If you are running ISPF Version 2 or earlier, edit the GOPHER panels\n whose names begin \"GGMP...\".  These are popups, and will not work\n under ISPF Version 2 unless you change the )BODY line.  Remove the\n WINDOW(...) parameter from the )BODY line of each panel so that the\n line just says )BODY or )BODY EXPAND(``), as the case may be.\n\n 7. Submit the ALLOAD JCL to allocate the load library from which the\n executable program will be run, as well as the object library in which\n the compiled object modules will be stored.\n\n 8. Submit the COMPILE JCL to compile all the C sources and create the\n required object modules in the object library built in the above step.\n Note that this compiles all the modules for both the client and the\n server.  If you are installing both, you need not repeat this step.\n\n 9. Submit the LINKC JCL to create the executable Gopher load module\n from the object modules created in the above step.  This will create\n or replace the load module GGCLIENT.\n\n Note:  The linkedit must complete with a return code of zero.  If not,\n don't use the resultant load module.  Check the libraries you specified\n on the link step to see what went wrong.\n\n In the future, if you have to recompile individual modules, you can use\n the same JCL to compile only those modules, and the link will include\n the new modules in the existing executable load module.  To do this,\n you must retain the object library built above.\n\n 10. Submit the LINKX JCL to create the auxiliary Gopher load modules\n from the object modules created in the above step.  This will create\n or replace load modules named XG..., used by the REXX interface.\n\n 11. Copy the help member (HELP) from the CNTL PDS into your local TSO\n HELP library under the name GOPHER.  You may also create an additional\n HELP member called GOPHLOC containing information local to your site,\n if you wish.\n\n 12. Copy the GOPHER exec from the CLIST PDS into your local TSO CLIST\n library under the name GOPHER.  You may install it in a REXX exec\n library allocated to SYSEXEC if that is your convention for REXX execs\n as opposed to CLISTs.\n\n 13. If you install the GOPHER exec, you must also install\n the NNMFIUCV exec in the same library.  This exec implements a rude\n check for an existing TCP/IP socket application (e.g. another GOPHER)\n in a different PIE MultiTSO session.  It prevents your users from\n crashing TCP/IP, so it is highly recommended that you make use of it.\n\n 14. Install the remainder of the execs in a library that will be\n accessible to the client in local mode (possibly the same library).\n These execs are required by the new REXX interface.\n\n 15. Copy all the members of the panel PDS into the ISPF panel library\n specified in the GOPHER exec.\n\n 16. Create the \"About This Gopher\" PDS from the ABOUT PDS.  This has\n all the text users should see when they select the \"About This Gopher\"\n item from the MVS client.  It also contains all the documentation you\n need about setting up the client and the server, as well as creating\n menus and REXX execs for use with MVS Gopher.  You may have already\n done this as part of the server install, but it should also be\n available from the client in \"local\" (serverless) mode, so that is\n why I mention it here.\n\n--------------------------------------------------------------------\n\n Note:  Make sure that the C/370 run time library is available,\n either in the system link list or in the ISPLLIB concatenation,\n before attempting to run GOPHER.  See above under customization\n of the GOPHER exec.\n\n./ ADD NAME=INSTALLS\n\n Directions for Installing the GOPHER MVS Server\n\n where @ is the install prefix from the unload and $ is a system prefix\n\n Summary:\n\n 1. (all users)      Customize @.H      - GGUSER\n 2. (all users)      Customize @.CNTL   - ALLOAD\n 3. (all users)      Customize @.CNTL   - COMPILE\n 4. (all users)      Customize @.CNTL   - LINKC\n 5. (all users)      Submit    @.CNTL   - ALLOAD   ==> $.LOAD, @.OBJ\n 6. (all users)      Submit    @.CNTL   - COMPILE  --> @.OBJ(*)\n 7. (all users)      Submit    @.CNTL   - LINKC    --> $.LOAD(GG*)\n 8. (REXX users)     Submit    @.CNTL   - LINKX    --> $.LOAD(XG*)\n 9. (all users)      Install   @.ABOUT  - *        --> $.ABOUT(*)\n 10.(all users)      Create    access file         ... DD:GGACCESS\n 11.(all users)      Create    startup parameters  ... DD:GGPARMS\n 12.(REXX users)     Create    REXX exec PDS       ... DD:GGEXEC\n 13.(REXX users)     Install   @.CLIST  - *        --> $.CLIST(*)\n 14.(all users)      Create    started task JCL    --> SYS1.PROCLIB\n 15.(all users)      Update    TCP/IP profile      --> TCPIP.TCPIP.PROFI\n\n System libraries to be updated:\n\n $.LOAD  - specified in .CNTL(ALLOAD)\n $.OBJ   - specified in .CNTL(ALLOAD)\n $.ABOUT - a new PDS you make yourself, or use the install copy\n\n Assuming you have unloaded all the install PDS's:\n\n 1. Customize the GGUSER header file as shown by the comments therein.\n Note in particular the defines for your TCP/IP and your C compiler.\n There are changes to the linkedit JCL that are related to these.\n\n 2,3,4. Customize the ALLOAD, COMPILE and LINKS JCL members to reflect\n your local conventions.  Note:  If you intend to place the executable\n into an existing library, you can suppress that part of the ALLOAD JCL.\n The name of the data set created must match across both members.\n\n *********************************************************************\n\n IMPORTANT:  If you are running TCP/IP V2R2 or higher on MVS, you must\n change the following library names in the compile and link JCL:\n\n   TCPIP.COMMMAC   should be changed to  TCPIP.SEZACMAC\n   TCPIP.COMMTXT   should be changed to  TCPIP.SEZACMTX\n\n If you are using SNS/TCPAccess, use these library names, or\n whatever names are defined at your installation:\n\n   TCPIP.COMMMAC   should be changed to  SNSTCP.V110.H\n   TCPIP.COMMTXT   should be changed to  SNSTCP.V110.CILIB\n\n If you are using SAS/C, change CEESTART to MAIN in the linkedit\n ENTRY control statement.\n\n *********************************************************************\n\n Note:  If you have defined C370V1 in the GGUSER header file, you must\n also include the system linklist load library containing IKJEFF18\n when linking.  Otherwise you may delete the line from the linkedit\n JCL that references it.\n\n Note:  You need not include the PASCAL libraries or the AMPZMVSB\n module if you are using TCP/IP Version 2 or higher, in which case\n you must also define TCPIPV2 in the GGUSER headerfile.\n\n 5. Submit the ALLOAD JCL to allocate the load library from which the\n executable program will be run, as well as the object library in which\n the compiled object modules will be stored.\n\n 6. Submit the COMPILE JCL to compile all the C sources and create the\n required object modules in the object library built in the above step.\n Note that this compiles all the modules for both the client and the\n server.  If you are installing both, you need not repeat this step.\n\n 7. Submit the LINKS JCL to create the executable Gopher load modules\n from the object modules created in the above step.  This will create\n or replace the load modules GGSERVER and GGSTASK.\n\n Note:  The linkedit must complete with a return code of zero.  If not,\n don't use the resultant load module.  Check the libraries you specified\n on the link step to see what went wrong.\n\n In the future, if you have to recompile individual modules, you can use\n the same JCL to compile only those modules, and the link will include\n the new modules in the existing executable load module.  To do this,\n you must retain the object library built above.\n\n 8. Submit the LINKX JCL to create the auxiliary Gopher load modules\n from the object modules created in the above step.  This will create\n or replace load modules named XG..., used by the REXX interface.\n\n 9. Create the \"About This Gopher\" PDS from the ABOUT PDS.  This has\n all the text users should see when they select the \"About This Gopher\"\n item from the MVS client.  It also contains all the documentation you\n need about setting up the client and the server, as well as creating\n menus and REXX execs for use with MVS Gopher.  You may have already\n done this as part of the client install.\n\n Note that member MENU contains the line PATH=DD:GGABOUT(ABOUT).  This\n works now (it didn't use to), so there is no need to change it as long\n as you have the GGABOUT DD statement in your server JCL pointing to\n your ABOUT PDS (see below).\n\n 10. Create your Gopher access file.  See the instructions in the\n \"About This Gopher\" PDS, member ABOUTSA, for a description of the\n format.  A sample member is in member ACCESS of this CNTL PDS.\n\n 11. Create your Gopher startup parameter file.  This is not required,\n but may be used to change compiled-in defaults.  See the PARMS member\n for a default.\n\n 12. Allocate a PDS to hold Gopher REXX execs.  This is required only\n if you plan to use the REXX interface for driver scripts.  See the\n TSOHELP exec in the CLIST PDS of the distribution for a sample\n application.\n\n 13. Install all of the execs in the CLIST PDS in the library created\n above.  These execs, with the exception of GOPHER and NNMFIUCV,\n are required by the new REXX interface.\n\n 14. Create the MVS Gopher started task JCL from either of the samples\n given in GOPHERD and GOPHERT.  The GOPHERT is recommended so that you\n can use REXX execs that issue TSO commands, but you may not want to\n use this for security reasons.  Either way, customize liberally.\n\n Started task parameters:\n\n MODULE=GGSERVER            the Gopher server load module in STEPLIB\n STEPLIB='GOPHER.LOAD'      the load library containing the above\n EXECLIB='GOPHER.EXEC'      the PDS containing server REXX execs\n ACCESS='GOPHER.ACCESS'     the installation access file (sequential)\n ABOUT='GOPHER.ABOUT'       the PDS containing \"About This Gopher\" info\n MENU='GOPHER.MENU'         the initial gopher menu (sequential)\n PARMS='GOPHER.PARMS'       the server startup file (sequential)\n GPARM=                     the server EXEC parms (e.g. -d for debug)\n\n Note: if you specify GPARM='-D', a GGDEBUG DD must be included.\n\n You are strongly recommended to create 2 started tasks:  one for\n non-REXX requests with MTFTASKS set to 8, and one for REXX requests\n with MTFTASKS set to 1 (because of TSO/E multitasking bugs).\n Give each a different port number in the GGPARMS configuration file\n allocated to it.  See sample below.\n\n 15. Add the name of the Gopher server started task (the name as it\n appears in SYS1.PROCLIB, not necessarily \"GOPHER\") to the MVS TCPIP\n profile data set (or have your MVS TCP/IP system programmer do it).\n In the examples below, let's say you've called it GOPHSRV.  Add this\n in 2 places:\n\n   (a) under AUTOLOG, so that TCP/IP will start the Gopher server\n       automatically (a la inetd for unix) when a client connects.\n       Just add the name to the list (e.g. GOPHSRV).\n\n   (b) under PORT, so nobody can spoof the Gopher port.  The format\n       here is:   70 TCP GOPHSRV\n\n Repeat both for whatever number of Gopher server started tasks you\n create (with different port numbers).\n\n--------------------------------------------------------------------\n\n Note:  Make sure that the C/370 run time library is available,\n either in the system link list or in the STEPLIB concatenation,\n before attempting to run GOPHER.\n\n--------------------------------------------------------------------\n\nFollowing is an example of how to define two Gopher servers.\n\n'SYS1.PROCLIB(GOPHSRV)' - the primary gopher server (port 70)\n                          will not run any REXX execs\n\n//GOPHERD  PROC MODULE=GGSERVER,\n//         STEPLIB='GOPHER.LOAD',\n//         ACCESS='GOPHER.ACCESS(ACCESS)',\n//         PARMS='GOPHER.ACCESS(PARMS)',\n//         MENU='GOPHER.ACCESS(MENU)',\n//         STDERR='*',\n//         STDOUT='*',\n//         GPARM=\n//*\n//GOPHERD  EXEC PGM=&MODULE,PARM='&GPARM'\n//STEPLIB  DD   DISP=SHR,DSN=&STEPLIB\n//SYSERR   DD   SYSOUT=&STDERR\n//SYSPRINT DD   SYSOUT=&STDOUT\n//SYSIN    DD   DUMMY\n//GGDEBUG  DD   SYSOUT=*\n//GGACCESS DD   DISP=SHR,DSN=&ACCESS\n//GGPARMS  DD   DISP=SHR,DSN=&PARMS\n//GGGOPHER DD   DISP=SHR,DSN=&MENU\n\n'SYS1.PROCLIB(GOPHSRV2)' - the secondary gopher server (port 1570)\n                           will run REXX execs\n\n//GOPHERD2 PROC MODULE=GGSERVER,\n//         STEPLIB='GOPHER.LOAD',\n//         EXECLIB='GOPHER.EXEC',\n//         ACCESS='GOPHER.ACCESS(ACCESS2)',\n//         PARMS='GOPHER.ACCESS(PARMS2)',\n//         MENU='GOPHER.ACCESS(MENU2)',\n//         VIO=VIO,\n//         STDERR='*',\n//         STDOUT='*',\n//         GPARM=\n//*\n//GOPHERD2 EXEC PGM=IKJEFT01,DYNAMNBR=128, PARM='&MODULE &GPARM'\n//STEPLIB  DD   DISP=SHR,DSN=&STEPLIB\n//SYSEXEC  DD   DISP=SHR,DSN=&EXECLIB  /* needed for %-invoked execs */\n//GGEXEC   DD   DISP=SHR,DSN=&EXECLIB\n//SYSTSPRT DD   UNIT=&VIO,SPACE=(TRK,(100,100)),RECFM=VBA,LRECL=255\n//SYSERR   DD   SYSOUT=&STDERR\n//SYSPRINT DD   SYSOUT=&STDOUT\n//SYSTSIN  DD   DUMMY\n//SYSIN    DD   DUMMY\n//GGDEBUG  DD   SYSOUT=*\n//GGACCESS DD   DISP=SHR,DSN=&ACCESS\n//GGPARMS  DD   DISP=SHR,DSN=&PARMS\n//GGGOPHER DD   DISP=SHR,DSN=&MENU\n\n'GOPHER.ACCESS(PARMS)' - startup parameters used by the primary server\n\nmtftasks  8    (this is the default)\nport      70   (this is the default too)\n\n'GOPHER.ACCESS(PARMS2)'- startup parameters used by the secondary server\n\nmtftasks  1       Force single threading to prevent TSO burpages\nport      1570    Must be different from primary server's port\n\n-----------------------------------------------------------------------\n\nI have not included members ACCESS, ACCESS2, MENU and MENU2, but you\nwill find samples elsewhere in this distribution.  ACCESS and ACCESS2\ncan be the same, except that you don't need the REXX execs to be in\nACCESS since ACCESS can't run REXX execs.  MENU and MENU2 should be\nthe same, since you may want to configure various Gopher clients\non other machines to try both MVS servers, but it's up to you.\n\n./ ADD NAME=LINKC\n//JOBNAME  JOB ACCOUNT,'NAME'\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*********************************************************************\n//*\n//* Linkedit an executable Gopher load module.\n//*\n//GGLINK PROC LOADLIB='GOPHER.LOAD',             Executable load library\n//            OBJLIB='GOPHER.INSTALL.OBJ',       Input object PDS\n//            PLIBASE='SYS1.PLIBASE',            PL/1   link library\n//            EDCBASE='SYS1.SEDCBASE',           C/370  link library\n//            IBMBASE='SYS1.SIBMBASE',           PL/1+C common library\n//            COMMTXT='TCPIP.COMMTXT',           TCP/IP link library\n//            VIOUNIT=VIO,                       Temporary disk unit\n//            OUTCLAS='*',                          SYSOUT class\n//            LPARMS='LIST,LET,MAP',                Linkedit parameters\n//            TEST=TEST                             TEST or NOTEST\n//*\n//LKED      EXEC PGM=IEWL,PARM='AMODE(31),RMODE(ANY),&TEST,&LPARMS'\n//SYSPRINT  DD SYSOUT=&OUTCLAS\n//DUMMYDD   DD DUMMY,DSN=&OBJLIB          needed to prevent JCL errors\n//SYSLIB    DD DISP=SHR,DSN=&PLIBASE\n//          DD DISP=SHR,DSN=&EDCBASE\n//          DD DISP=SHR,DSN=&IBMBASE\n//          DD DISP=SHR,DSN=&COMMTXT\n//SYSLMOD   DD DISP=SHR,DSN=&LOADLIB\n//SYSUT1    DD DSN=&&SYSUT1,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//          SPACE=(32000,(30,30))\n//*\n//         PEND\n//*\n//*\n//* Link GOPHER load module. Like SMP/E, expect return code 8 when\n//* doing this from scratch.  Additional one-or-two-module links\n//* will just replace the corresponding parts of the load module.\n//*\n//GGLINK EXEC GGLINK\n//LKED.SYSLIN DD DISP=SHR,DSN=&OBJLIB(GGACCES)\n//            DD DISP=SHR,DSN=&OBJLIB(GGALLOC)\n//            DD DISP=SHR,DSN=&OBJLIB(GGASVC)\n//            DD DISP=SHR,DSN=&OBJLIB(GGBARF)\n//            DD DISP=SHR,DSN=&OBJLIB(GGBIN)\n//            DD DISP=SHR,DSN=&OBJLIB(GGBKMGR)\n//            DD DISP=SHR,DSN=&OBJLIB(GGCLIEN)\n//            DD DISP=SHR,DSN=&OBJLIB(GGCLRTX)\n//            DD DISP=SHR,DSN=&OBJLIB(GGCONN)\n//            DD DISP=SHR,DSN=&OBJLIB(GGCSO)\n//            DD DISP=SHR,DSN=&OBJLIB(GGDBM)\n//            DD DISP=SHR,DSN=&OBJLIB(GGDFAIL)\n//            DD DISP=SHR,DSN=&OBJLIB(GGDIR)\n//            DD DISP=SHR,DSN=&OBJLIB(GGDISC)\n//            DD DISP=SHR,DSN=&OBJLIB(GGDISPL)\n//            DD DISP=SHR,DSN=&OBJLIB(GGDSOPT)\n//            DD DISP=SHR,DSN=&OBJLIB(GGDUMP)\n//            DD DISP=SHR,DSN=&OBJLIB(GGESRVR)\n//            DD DISP=SHR,DSN=&OBJLIB(GGFREEM)\n//            DD DISP=SHR,DSN=&OBJLIB(GGFTP)\n//            DD DISP=SHR,DSN=&OBJLIB(GGGETDS)\n//            DD DISP=SHR,DSN=&OBJLIB(GGGETM)\n//            DD DISP=SHR,DSN=&OBJLIB(GGGOFOR)\n//            DD DISP=SHR,DSN=&OBJLIB(GGGSRVL)\n//            DD DISP=SHR,DSN=&OBJLIB(GGIERR)\n//            DD DISP=SHR,DSN=&OBJLIB(GGIGET)\n//            DD DISP=SHR,DSN=&OBJLIB(GGINFO)\n//            DD DISP=SHR,DSN=&OBJLIB(GGISPF)\n//            DD DISP=SHR,DSN=&OBJLIB(GGIVGET)\n//            DD DISP=SHR,DSN=&OBJLIB(GGIVPUT)\n//            DD DISP=SHR,DSN=&OBJLIB(GGMENU)\n//            DD DISP=SHR,DSN=&OBJLIB(GGMTFER)\n//            DD DISP=SHR,DSN=&OBJLIB(GGOUTS)\n//            DD DISP=SHR,DSN=&OBJLIB(GGOUTTX)\n//            DD DISP=SHR,DSN=&OBJLIB(GGPMSG)\n//            DD DISP=SHR,DSN=&OBJLIB(GGPROC)\n//            DD DISP=SHR,DSN=&OBJLIB(GGREXX)\n//            DD DISP=SHR,DSN=&OBJLIB(GGSLEEP)\n//            DD DISP=SHR,DSN=&OBJLIB(GGSOCKT)\n//            DD DISP=SHR,DSN=&OBJLIB(GGSOPT)\n//            DD DISP=SHR,DSN=&OBJLIB(GGTEMP)\n//            DD DISP=SHR,DSN=&OBJLIB(GGTNET)\n//            DD DISP=SHR,DSN=&OBJLIB(GGTSO)\n//            DD DISP=SHR,DSN=&OBJLIB(GGTYPE)\n//            DD DISP=SHR,DSN=&OBJLIB(GGUNALC)\n//            DD DISP=SHR,DSN=&OBJLIB(GGVIEW)\n//            DD DISP=SHR,DSN=&OBJLIB(GGVTX)\n//            DD DISP=SHR,DSN=&OBJLIB(GGWAIS)\n//            DD DISP=SHR,DSN=&OBJLIB(GGWHOIS)\n//            DD DISP=SHR,DSN=&OBJLIB(GGWTO)\n//            DD DISP=SHR,DSN=&OBJLIB(GGXTX)\n//            DD *\n ENTRY   CEESTART\n NAME    GGCLIENT(R)\n/*\n./ ADD NAME=LINKS\n//JOBNAME  JOB ACCOUNT,'NAME'\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*********************************************************************\n//*\n//* Linkedit an executable Gopher load module.\n//*\n//GGLINK PROC LOADLIB='GOPHER.LOAD',             Executable load library\n//            OBJLIB='GOPHER.INSTALL.OBJ',       Input object PDS\n//            PLIBASE='SYS1.PLIBASE',            PL/1   link library\n//            EDCBASE='SYS1.SEDCBASE',           C/370  link library\n//            IBMBASE='SYS1.SIBMBASE',           PL/1+C common library\n//            COMMTXT='TCPIP.COMMTXT',           TCP/IP link library\n//            VIOUNIT=VIO,                       Temporary disk unit\n//            OUTCLAS='*',                          SYSOUT class\n//            LPARMS='LIST,LET,MAP',                Linkedit parameters\n//            TEST=TEST                             TEST or NOTEST\n//*\n//LKED      EXEC PGM=IEWL,PARM='AMODE(31),RMODE(ANY),&TEST,&LPARMS'\n//SYSPRINT  DD SYSOUT=&OUTCLAS\n//DUMMYDD   DD DUMMY,DSN=&OBJLIB          needed to prevent JCL errors\n//SYSLIB    DD DISP=SHR,DSN=&PLIBASE\n//          DD DISP=SHR,DSN=&EDCBASE\n//          DD DISP=SHR,DSN=&IBMBASE\n//          DD DISP=SHR,DSN=&COMMTXT\n//SYSLMOD   DD DISP=SHR,DSN=&LOADLIB\n//SYSUT1    DD DSN=&&SYSUT1,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//          SPACE=(32000,(30,30))\n//*\n//         PEND\n//*\n//* Link GOPHER server subtask module.\n//*\n//GGLINK EXEC GGLINK\n//LKED.SYSLIN DD DISP=SHR,DSN=&OBJLIB(GGSTASK)\n//            DD DISP=SHR,DSN=&OBJLIB(GGACCES)\n//            DD DISP=SHR,DSN=&OBJLIB(GGALLOC)\n//            DD DISP=SHR,DSN=&OBJLIB(GGASVC)\n//            DD DISP=SHR,DSN=&OBJLIB(GGBARF)\n//            DD DISP=SHR,DSN=&OBJLIB(GGDFAIL)\n//            DD DISP=SHR,DSN=&OBJLIB(GGDUMP)\n//            DD DISP=SHR,DSN=&OBJLIB(GGFREEM)\n//            DD DISP=SHR,DSN=&OBJLIB(GGFTP)\n//            DD DISP=SHR,DSN=&OBJLIB(GGGETM)\n//            DD DISP=SHR,DSN=&OBJLIB(GGGSRVL)\n//            DD DISP=SHR,DSN=&OBJLIB(GGIERR)\n//            DD DISP=SHR,DSN=&OBJLIB(GGISPF)\n//            DD DISP=SHR,DSN=&OBJLIB(GGIVPUT)\n//            DD DISP=SHR,DSN=&OBJLIB(GGOUTS)\n//            DD DISP=SHR,DSN=&OBJLIB(GGPMSG)\n//            DD DISP=SHR,DSN=&OBJLIB(GGPROC)\n//            DD DISP=SHR,DSN=&OBJLIB(GGREXX)\n//            DD DISP=SHR,DSN=&OBJLIB(GGSOCKT)\n//            DD DISP=SHR,DSN=&OBJLIB(GGTEMP)\n//            DD DISP=SHR,DSN=&OBJLIB(GGTSO)\n//            DD DISP=SHR,DSN=&OBJLIB(GGTYPE)\n//            DD DISP=SHR,DSN=&OBJLIB(GGUNALC)\n//            DD DISP=SHR,DSN=&OBJLIB(GGWTO)\n//            DD *\n INCLUDE SYSLIB(EDCMTFS)\n ENTRY   CEESTART\n NAME    GGSTASK(R)\n/*\n//*\n//* Link GOPHER server main module.\n//*\n//GGLINKS EXEC GGLINK\n//LKED.SYSLIN DD DISP=SHR,DSN=&OBJLIB(GGSERVE)\n//            DD DISP=SHR,DSN=&OBJLIB(GGACCES)\n//            DD DISP=SHR,DSN=&OBJLIB(GGFREEM)\n//            DD DISP=SHR,DSN=&OBJLIB(GGGETM)\n//            DD DISP=SHR,DSN=&OBJLIB(GGMTFER)\n//            DD *\n ENTRY   CEESTART\n NAME    GGSERVER(R)\n/*\n./ ADD NAME=LINKX\n//JOBNAME  JOB ACCOUNT,'NAME'\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*********************************************************************\n//*\n//* Linkedit auxiliary Gopher executables.\n//*\n//GGLINK PROC LOADLIB='GOPHER.LOAD',             Executable load library\n//            OBJLIB='GOPHER.INSTALL.OBJ',       Input object PDS\n//            PLIBASE='SYS1.PLIBASE',            PL/1   link library\n//            EDCBASE='SYS1.SEDCBASE',           C/370  link library\n//            IBMBASE='SYS1.SIBMBASE',           PL/1+C common library\n//            EDCSPC='SYS1.SEDCSPC',             C/370 sysprog library\n//            VIOUNIT=VIO,                       Temporary disk unit\n//            OUTCLAS='*',                          SYSOUT class\n//            LPARMS='LIST,LET,MAP',                Linkedit parameters\n//            TEST=TEST                             TEST or NOTEST\n//*\n//LKED      EXEC PGM=IEWL,PARM='AMODE(31),RMODE(ANY),&TEST,&LPARMS'\n//SYSPRINT  DD SYSOUT=&OUTCLAS\n//DUMMYDD   DD DUMMY,DSN=&OBJLIB          needed to prevent JCL errors\n//SYSLIB    DD DISP=SHR,DSN=&EDCSPC\n//          DD DISP=SHR,DSN=&PLIBASE\n//          DD DISP=SHR,DSN=&EDCBASE\n//          DD DISP=SHR,DSN=&IBMBASE\n//SYSLMOD   DD DISP=SHR,DSN=&LOADLIB\n//SYSUT1    DD DSN=&&SYSUT1,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//          SPACE=(32000,(30,30))\n//*\n//         PEND\n//*\n//* Link GOPHER client and server auxiliary modules.\n//*\n//XGALLOC EXEC GGLINK\n//LKED.SYSLIN  DD DISP=SHR,DSN=&OBJLIB(XGALLOC)\n//             DD DISP=SHR,DSN=&OBJLIB(GGASVC)\n//             DD *\n ENTRY    XGALLOC\n NAME     XGALLOC(R)\n/*\n//XGSLEEP EXEC GGLINK\n//LKED.SYSLIN  DD DISP=SHR,DSN=&OBJLIB(XGSLEEP)\n//             DD DISP=SHR,DSN=&OBJLIB(GGSLEEP)\n//             DD DISP=SHR,DSN=&OBJLIB(GGASVC)\n//             DD *\n ENTRY    CEESTART\n NAME     XGSLEEP(R)\n/*\n//XGWTO   EXEC GGLINK\n//LKED.SYSLIN  DD DISP=SHR,DSN=&OBJLIB(XGWTO)\n//             DD DISP=SHR,DSN=&OBJLIB(GGWTO)\n//             DD DISP=SHR,DSN=&OBJLIB(GGASVC)\n//             DD *\n ENTRY    CEESTART\n NAME     XGWTO(R)\n/*\n./ ADD NAME=MENU\ngopher_menu\n\nTYPE=FILE\nNAME=About This Gopher\nPATH=DD:GGABOUT(ABOUT)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=TSO HELP (Sample Illustrating the REXX Interface)\nPATH=EXEC:TSOHELP\nHOST=+\nEND\n\nTYPE=DIRECTORY\nNAME=Library/Information Services\nPATH=SYS0008.GOPHER.LIBRARY(LIBRS)\nHOST=MVS.UDEL.EDU\nEND\n\nTYPE=TELNET\nNAME=UDINFO - University of Delaware Information\nHOST=UDINFO.UDEL.EDU\nEND\n\nTYPE=DIRECTORY\nNAME=Network and System Services Computer Systems\nPATH=SYS0008.GOPHER.DIR(UDTELNET)\nHOST=MVS.UDEL.EDU\nEND\n\nTYPE=DIRECTORY\nNAME=Weather Across the Country\nPATH=1/Weather\nHOST=mermaid.micro.umn.edu\nPORT=150\nEND\n\nTYPE=DIRECTORY\nNAME=Other Gopher and Information Servers\nPATH=1/Other Gopher and Information Servers\nHOST=gopher.micro.umn.edu\nEND\n\nTYPE=DIRECTORY\nNAME=How to use BITNET LISTSERV Servers\nPATH=SYS0008.GOPHER.DIR(LISTSERV)\nHOST=MVS.UDEL.EDU\nEND\n\nTYPE=DIRECTORY\nNAME=University of Delaware Newspapers\nPATH=SYS0008.GOPHER.DIR(PAPERS)\nHOST=MVS.UDEL.EDU\nEND\n\n/*\n./ ADD NAME=PARMS\n!\n! MVS Gopher Sample Startup Parameter File\n!\n! All entries in this file have the format:   variable value comments\n!\n! These are the possible values and their default settings:\n!\n! mtftasks 1    Number of concurrent subtasks to handle client requests\n! port     70   The TCP port number by which clients connect\n! qlength  20   Queue length for TCP server listen function\n! timeout  60   Connection timeout specified when socket is closed\n! domain   .DRAPER.COM     The suffix to be appende to bald host names\n\nmtftasks 1    Number of concurrent subtasks to handle client requests\nport     70   The TCP port number by which clients connect\nqlength  20   Queue length for TCP subtask creation\ntimeout  60   Connection timeout specified when socket is closed\n\n./ ADD NAME=SECURE\nThe following discussion is included by permission of the participants.\n\nFrom: SEB1525@MVS.draper.com (Steve Bacher)\nSubject: Secure Rexx?\nOrganization: Draper Laboratory\nDate: Fri, 19 Nov 1993 16:13:00 GMT\n\nHas anyone given any thought to what would be needed to evaluate the\n\"security\" of REXX?\n\nI'm thinking of what you'd have to do to prove that it was OK to have\na REXX script running behind an anonymous FTP or gopher server, for\nexample.  We know that commands like vi and utilities like PostScript\nare questionable because they provide shell escapes.  What could you\nsay about a REXX script on such a system?\n\nTo start, I'd suggest that you would want to disable the INTERPRET\nstatement, so that a remote user could not cause a REXX exec to\ninvoke arbitrary code.  You might also want to restrict the ADDRESS\ninstruction, perhaps limiting it to a set of known address environments.\n\nAny other ideas?  Apologies if this question is somewhat Unix-centric.\n\n\n--\nSteve Bacher (Batchman)                 Draper Laboratory\nInternet: seb@draper.com                Cambridge, MA, USA\n\n\nDate: Fri, 19 Nov 1993 13:56:11 -0500\nFrom: \"Stephen E. Bacher\" <seb@DRAPER.COM>\nSubject: Re: Secure Rexx?\n\nI would rephrase the question \"Is a given program written in\nlanguage X secure?\"  The answer can be one of \"yes\", \"no\", or\n\"cannot be determined\".  Only programs that returned answer\nnumber one would be eligible for secure environments.\n\nKeep in mind that security is a relative term.  Since we cannot\nprove beyond the shadow of a doubt that something is 100% impregnable,.\none must adopt a \"reasonable person\" approach.  Just as you wouldn't\nprotect your house with the same arsenal as is used to protect our\nnuclear launchers.\n\nWhat I mean is that if you know that if you connect to a gopher server\nat foo.bar.edu, say, and you know that if you pass it a selector string\nof \"exec:open-sesame:some-rexx-script\", the server will execute the\nscript some-rexx-script with a parameter of open-sesame with the\nprivileges of the gopher daemon at foo.bar.edu.  Depending on the\npowers of that daemon, it could go off and execute a command that\nupdated your college transcript, or something.  That is kind of\nfarfetched, and suggests that the gopher was not set up very securely\nin and of itself, but there are all kinds of possibilities.\n\nOne thing that a gopher daemon MIGHT be able to do is to update its\nown gopher menu tree.  That could be a risk.\n\nNote that the script might not even be one set up by the gopher guys.\nOf course, we'll cover that particular hole.  Note that I don't want\nto go into more detail about just how much security is theirs and\nhow much is, or will be, ours - there will be time for that when we\nrelease our mods to the UMn gopher server (at least I hope we do).\n\n\n\nFrom: Anders Christensen <anders@lise.unit.no>\nDate: Tue, 23 Nov 1993 22:04:23 +0100\nTo: \"Stephen E. Bacher\" <seb@draper.com>\nSubject: Re: Secure Rexx?\n\n\n> I am specifically concerned about using REXX scripts in a server\n> environment where they will be in the role of delivering publicly\n> available information.  Any user could pass a request to have the\n> server run that REXX exec, so it is imperative that what the exec\n> can do be constrained.\n\nI'd say that it's somewhat impossible to have a secure Rexx script,\nthe reason is this: In addition to INTERPRET you would have to disable\nseveral other constructs:\n\n 1) The ADDRESS keyword instruction and commands should be disabled. As\n    long as one can do things like:\n\n      address system 'echo' var '>/tmp/foo.rexx; rexx /tmp/foo.rexx'\n\n    then ADDRESS is just as insecure as INTERPRET.\n\n 2) For language level 3.50 and above, LINEOUT() and CHAROUT() should\n    be disabled. Consider the possibility that the program is fooled\n    to run code writing to files related to security (.rhosts,\n    .forward, .login, etc). That could easily be the first step of an\n    attack at the account. Besides:\n\n      lineout('myfile',var); say 'myfile'()\n\n    is just as insecure as INTERPRET.\n\n 3) There are also some files which should not be readable for the\n    whole world. Security is related to files that contain keys for\n    encryption (e.g. .xauthority). Thus, maybe LINEIN() and CHARIN()\n    should be restricted too.\n\nThis results in a Rexx interpreter that cannot execute commands, or\nread or write files. Such a mode is of very limited value. There may\nbe other things to disable too:\n\n 4) SAA REXX contains rxfuncadd() and friends in order to dynamically\n    load code into the intepreter. It provides lots of 'interesting'\n    possibilties.\n\n 5) External functions should perhaps be disabled. Although you can\n    verify the contents of the external function like you verify the\n    contents of the main program, you cannot enable external functions\n    that are not Rexx scripts.\n\n 6) Most implementations contains many extra builtin functions, some\n    which may be used as security backdoors. Just consider what can be\n    done with the DIAG() bifs under CMS. In the same manner, you'd\n    have to disable OPTIONS, since it too, is able to perform random\n    operations, depending only on the implementation of the\n    interpreter.\n\n 7) The VALUE() bif can be dangerous when used with it's third\n    parameter, since under some implementations it can be used to set\n    environment variables. Suppose you have a 'secure' command, but\n    the user is able to set PATH (under Unix) ...\n\n 8) Interactive tracing ... really lots of interesting possiblities!\n    (And remember to disable TRACE() too!)\n\n 9) You have to insulate the stack from effects done by the program.\n    Suppose the user just pushes commands to the stack and exits. Most\n    Unix version would not suffer from this, but CMS could probably be\n    fooled.\n\nI believe that the resulting interpreter would be fairly useless. The\nclue is probably to write secure _scripts_, rather than secure\n_interpreters_; and the main features are:\n\n 1) Never run any external functions or commands that might be\n    compromised.\n\n 2) Check (and double-check) the format and contents of all data read\n    from external sources, like files, the keyboard, parameter- and\n    option-values, or the network.\n\nOn the other hand, there are several 'features' about Rexx that makes\nme nervous with respect to so-called secure programming, or provable\nprograms. Consider the following part of a long Rexx program:\n\n     'test -f /etc/passwd'\n     if rc=0 then\n         do_something\n\nThe do_something part may perfectly well be called also whenever rc\nwas something else than zero. Just assume CALL ON HALT, and the\nfollowing code somewhere else:\n\n     halt:\n         rc = 0   /* or more likely: a command */\n         return\n\nConsequently, the value of RC becomes undefined at all clause\nboundaries (strictly speaking). Thus, one can not use CALL ON HALT in\n'secure' scripts. Another source of constant despair is arithmetic.\nConsider the seemingly good-natured loop (where an evil eternal loop\nmay be lurking!):\n\n     do i=5 to 15\n        say i\n        end\n\nHow can this loop become non-ending? By setting NUMERIC DIGITS to 1.\nWhen i has the value 9 and is incremented, it gets the values 1E1.\nWhen 1E1 is incremented by 1, it becomes 1E1 ... and thus the eternal\nloop. Therefore, if you want to prove a Rexx program, you have to\nguard against all cases where this may happen: either when NUMERIC\nDIGITS is too low, or when the control variable becomes to high.\nFrankly, this is completely impossible to handle.\n\nThese are some of the examples I stumbled across when I was writing\nthe trip test.  ... Rexx is a very strange languages ... :-)\n\nRegards,\n-anders\n\n\n./ ENDUP\n?!\n//ABOUT    EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='ABOUT'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=ABOUT\ngopher_menu\n\nTYPE=FILE\nNAME=What Is Gopher?\nPATH=(ABOUTW)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=Gopher FAQ (Frequently Asked Questions) List\nPATH=(FAQ)\nHOST=+\nEND\n\nTYPE=DIRECTORY\nNAME=Using The Gopher MVS Client\nPATH=(ABOUTC)\nHOST=+\nEND\n\nTYPE=DIRECTORY\nNAME=Administering the Gopher MVS Server\nPATH=(ABOUTS)\nHOST=+\nEND\n\n\n./ ADD NAME=ABOUTC\ngopher_menu\n\nTYPE=FILE\nNAME=Overview - Using Gopher on MVS\nPATH=(ABOUTCO)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=Directory Mode - Viewing a Gopher Directory\nPATH=(ABOUTCD)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=File Mode - Browsing a Gopher File\nPATH=(ABOUTCF)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=Index Mode - Executing a Gopher Query\nPATH=(ABOUTCQ)\nHOST=+\nEND\n\nTYPE=DIRECTORY\nNAME=Customizing Your Gopher Startup\nPATH=(ABOUTCS)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=MVS Gopher Frequently Asked Questions (FAQ) List\nPATH=(MVSFAQ)\nHOST=+\nEND\n\n./ ADD NAME=ABOUTCD\nDirectory Mode - Viewing a Gopher Directory\n\nWhen you are viewing a Gopher menu (directory), you may perform any\nof the following actions:\n\n * Scroll up and down via the normal ISPF UP and DOWN commands or PFK's\n   to view all the items in the menu\n\n * Scroll left and right via the normal ISPF LEFT and RIGHT commands or\n   PFK's to be able to read the entirety of long names on the menu\n\n * Type one of the following letters to the left of a menu item and\n   press ENTER:\n\n   S - Select the item for viewing or processing\n   E - Extract the contents of the item to a file\n   P - Print the contents of the item to a system printer\n   B - Save the entry as a bookmark (in a bookmark file)\n   D - Delete this entry from the bookmark file *** not yet supported **\n   Q - Display the item as a file, even if it isn't (\"Query\")\n   I - Display the internal Information of the menu item\n\n * Enter one of the following commands on the command line:\n\n   MENU - load a data set containing Gopher menu entries (e.g. bookmark)\n   OPTions - set client processing options\n   QUIT - exit Gopher entirely\n\n   or any standard ISPF command.\n\nWhen you select an item, what happens next depends on the type of the\nitem you have selected.\n\nFor a File type, you are placed in browse mode on the data.\n\nFor a Directory type, you get another Gopher menu (directory).\n\nFor an Index type, you see a panel asking you to enter a search string\nof some kind, after which a Gopher menu (directory) of results appears.\n\nFor a TELNET type, a telnet session is started, for which you must\nenter a login name at the appropriate time.\n\nFor a TN3270 type, a tn3270 session is started, for which you must\nenter a login name at the appropriate time.\n\nFor a CSO type, you are placed in a phonebook lookup session.\n\nFor a BookManager type, you are placed in BookManager READ/MVS (tm).\n\nFor a binary type, you are placed in browse mode on the binary data.\nThis is generally not useful, though.\n\n./ ADD NAME=ABOUTCF\nBrowse Mode - Viewing a File in Gopher\n\nWhen you are viewing a Gopher file, you are placed in \"browse mode\".\nThis is very similar to normal ISPF data set browse, except that:\n\n * In addition to most browse commands, you may issue any of the\n   following commands:\n\n   EXT or EXTRACT   - copy the current contents to a file\n   PRT or PRNT      - print the current data to SYSOUT.\n   BOOK or BOOKMARK - Save the entry as a bookmark (in a bookmark file).\n   INFO             - Display the internal Information for this item\n   OPT or OPTIONs   - Set Gopher client processing options\n   QUIT             - terminates Gopher entirely.\n\n   Note that PRT is different from PRINT, which is a built-in ISPF\n   command that prints the current physical screen image.\n\n * The following ISPF browse commands are the only ones that are\n   ***not*** supported under GOPHER:\n\n  HEX\n  BROWSE\n  SUBMIT\n  LOCATE .label\n  .<string> (to assign a label)\n  FIND P'generic-string'\n  DISPLAY CC/NOCC\n\n./ ADD NAME=ABOUTCO\nThe following is modified from Allan Tuchman's XGOPHER help.\n\nGopher on MVS is an ISPF dialog interface to the Gopher\ninformation delivery system from the University of Minnesota.\n\nIf your Gopher environment has not been customized by the system\nprogrammer who installed it, Gopher will start up with an initial\npanel asking you to specify the name of the Gopher server host, as\nwell as some other fields which you would normally leave alone.\nOtherwise, you will see the main menu of the default Gopher server\ndefined at your installation.\n\nAssuming that the top-level path points to a valid Gopher menu,\nthe initial display will show the top level directory of\ngopher information available.  Selecting an item from this\nlist will fetch the contents of a file, subdirectory, or\nother information.  The directory display may be updated to\nshow the new subdirectory.\n\nTo select an item, type \"S\" in front of it and press ENTER.  This\nputs you into ISPF BROWSE mode on the text of the item.  You may also\ntype \"Q\" in front of an item to see it in text format even if it is a\ndirectory.  Or you may type \"E\" in front of it to extract it into a\nfile, or \"P\" to print it - but you may do this more easily via the\nEXTract command or PRT command from within BROWSE.\n\nType \"I\" in front of the item to view the internal menu information.\nThis is sometimes helpful if you are not sure why you are having\ntrouble accessing an item.\n\nType \"B\" in front of the item to save it in a bookmark file.  You will\nbe prompted to supply the name of a bookmark data set; the default is\nGOPHER.BOOKMARK under your TSO prefix.  You may retrieve bookmarks at a\nlater date by typing \"MENU GOPHER.BOOKMARK\" - or whatever data set name\nyou used - or you can put a pointer to the bookmark data set in your\nprivate Gopher menu (for which you need to learn how to edit your\nGOPHERRC file).\n\nSome gopher file types are not supported by the current client.\nThese will not appear on your menus.  Furthermore, you may not\nbe permitted to access some items, depending upon the server\nand the host from which you are trying to access them.  These\nrestrictions do not apply to local mode, where you can access\nanything that you have local permission to read.\n\nThe Gopher MVS client is written by Steve Bacher at Draper Laboratory\n(copyright 1992).\n\n./ ADD NAME=ABOUTCQ\nIndex Mode - Executing a Gopher Query\n\nWhen you select a Gopher \"index\" or \"query\" option, you are expected\nto enter some sort of search string.  A typical application is a\nphone book lookup, or a keyword search of some archive.\n\nYou will see a popup panel (or just a plain panel if you are running\nan old version of ISPF) that asks you to enter a search string.  Just\ntype it in and press ENTER.  What format the string needs to be in\ndepends totally on the service that is going to process it.\n\nWhat you get back is a directory with a list of \"hits\" or whatever\nis appropriate for the data you requested.  This is just like any\nother Gopher directory.\n\nWith the original Gopher protocol, there was no mechanism for\ndefining an index/query that returned file data immediately.\nMVS Gopher supports an experimental \"whois\" type that does this.\nHowever, since it was only spottily implemented by other Gophers,\nand not always the right way (in the humble opinion of the author\nor the MVS client), it is not likely that you will see such an option\non your Gopher screen.\n\n./ ADD NAME=ABOUTCS\ngopher_menu\n\nType=FILE\nName=Customizing Your Gopher Startup\nPath=(ABOUTCSC)\nHost=+\nEnd\n\nType=FILE\nName=What Happens When You Start Up Gopher\nPath=(ABOUTCSW)\nHost=+\nEnd\n\nType=FILE\nName=Requesting Local (Serverless) Access\nPath=(ABOUTCSL)\nHost=+\nEnd\n\nType=FILE\nName=The GOPHERRC File\nPath=(ABOUTCSR)\nHost=+\nEnd\n\nType=FILE\nName=Defining GOPHER Menus\nPath=(ABOUTCSM)\nHost=+\nEnd\n\nType=DIRECTORY\nName=REXX Exec Interface\nPath=(ABOUTR)\nHost=+\nEnd\n\n./ ADD NAME=ABOUTCSC\n\n=======================================================================\n\n Customizing Your Gopher Startup\n\n=======================================================================\n\n When you use the GOPHER client, information about your use of GOPHER\n is stored in a data set called GOPHERRC.  If you don't have one,\n GOPHER will create it for you.\n\n Your default startup menu will contain a single item pointing to a\n GOPHER server on your host system, whether such a server is available\n or not.  However, you can ask GOPHER to display a different startup\n menu for you.  This startup menu may have entries for the GOPHER\n server on the host system and one for your own private (local) data,\n which the GOPHER client accesses without querying a server.\n\n To get GOPHER to set up a different startup menu, you must edit the\n GOPHERRC file.  Note that you may set up the GOPHER startup menu to\n include a pointer to your local data - but you have to create that\n local data in order to use it.\n\n Editing the GOPHERRC file should be easy.  Just follow the\n instructions in the comments of the file itself.  For information\n about the contents of GOPHERRC, see \"The GOPHERRC File.\"\n\n You may also specify a different startup file when you invoke\n the MVS GOPHER client via the INITFILE keyword - e.g.\n\n   GOPHER INITFILE(SOME.OTHER.RC)\n\n If the data set does not yet exist, it will be created.  You may\n then edit that data set without altering your usual GOPHERRC setup.\n\n./ ADD NAME=ABOUTCSL\n\n=======================================================================\n\n Requesting Local (Serverless) Access\n\n=======================================================================\n\n The LOCAL operand on the GOPHER command is a convenient way of\n requesting \"local\" serverless mode.  Specify LOCAL on the GOPHER\n command if you want to enter GOPHER in \"serverless\" mode - i.e.\n start up with your private GOPHER menu.  Specifying LOCAL\n accomplishes two things:\n\n  (1) It sets the server to \"-\", meaning local access.  Therefore, you\n      must also provide a path, either via the PATH operand on the\n      GOPHER command or via a \"localmenu:\" spec in your GOPHERRC file,\n      so that GOPHER knows where to look for your private data.  The\n      path is a data set name, FULLY QUALIFIED WITHOUT QUOTES.\n\n  (2) It allows you to use GOPHER even if there are other TCP/IP socket\n      applications active elsewhere in your TSO session.  However, it\n      will not allow you to connect to any GOPHER servers, even if you\n      have a local menu item that points to one.\n\n If you do not specify a server and there is no specification in\n your GOPHERRC file for one, then GOPHER will display a startup\n ISPF panel asking you to specify a server name and, optionally,\n a path name.  (Don't touch the port number!)\n./ ADD NAME=ABOUTCSM\n\n=======================================================================\n\n Defining Gopher Menus\n\n=======================================================================\n\n This is a description of how to define GOPHER menus that can be used\n either for your own private data or by the GOPHER server administrator\n on MVS to define publicly accessible data.\n\n Bear in mind that the menu may be used to specify data meaningful to\n a server other than MVS.  Therefore, the descriptions here should be\n interpreted in two ways:\n\n (1) how to define MVS-resident information resources\n\n (2) how to request information resources from other GOPHER servers\n\n------------------------------------------------------------------------\n\n How To Define MVS-Resident Information Resources\n\n The Gopher server (and the Gopher client, in \"local\" mode) determines\n how to return information to the client via menus.  These menus are\n plain MVS data sets with a particular structure.\n\n An MVS gopher menu is a sequential data set or PDS member with the\n following format:\n\n * the first line contains the string GOPHER_MENU\n   (in upper, lower or mixed case)\n\n * the rest of the file contains blocks of information like this:\n\n   TYPE=type\n   NAME=name\n   PATH=path\n   HOST=host\n   PORT=port\n   END\n\n   For compatibility with earlier versions of the MVS Gopher server,\n   the following are also accepted:\n\n   DISPLAY=      is equivalent to NAME=\n   SELECTOR=     is equivalent to PATH=\n\n   Explanations\n\n   TYPE=type\n\n   The type of Gopher entity (FILE, DIRECTORY, INDEX, etc.).\n   In other words, one of the following:\n\n   FILE      - the item is an MVS data set with text to be displayed.\n               The path name is the file name or a REXX exec spec.\n   DIRECTORY - the item is another Gopher directory.\n               The path name is the file name or a REXX exec spec.\n   INDEX     - the item is a full text search item, which means that\n               the client will query the user for a search string\n               which will be passed to the server along with the\n               pathname.  For the MVS server.  it only makes sense for\n               the pathname to be a REXX exec specification.  The path\n               and the user's string are given to the host, which\n               returns a menu of selections.  See also WHOIS.\n   TELNET    - the item is a Telnet server.\n               The path name is ignored.  The port number should be\n               omitted or set to 0, unless an alternate TELNET port\n               is required by the server referenced by HOST.\n   TN3270    - the item is a TN3270 server.  This is like TELNET\n               except that it takes you to a full-screen IBM mainframe\n               terminal session.\n   CSO       - the item is a CSO phonebook server.  This is a campus\n               information protocol that is not an Internet standard,\n               but may be available at some universities.\n   WHOIS     - the item is a \"whois\" query.  This is similar to the\n               INDEX type, except that the server returns a file\n               rather than a menu.  This is not (yet) an official\n               part of the Gopher protocol, though it does appear in\n               certain (patched) versions of other implementations.\n   BINARY    - the item is a binary file.  Such a file may be browsed\n               or copied, but it is probably of little use.\n   BOOKMANAGER - the item is a BookManager READ/MVS (tm) document.\n\n   NAME=name\n\n   The descriptive string that will appear in the Gopher client's\n   display of menu selections for this item.  Make this as human as\n   possible.  Case is preserved.\n\n   PATH=path\n\n   The pathname to be passed to the Gopher server to retrieve the\n   item.  See below for a fuller description.\n\n   HOST=host\n\n   The name of the Gopher server host that will process the request.\n   See below for a fuller description.\n\n   PORT=port\n\n   The TCP/IP port to connect to.  For Gopher, this should always be\n   port 70 (except for a TELNET or TN3270 type, whose port defaults to\n   the standard TELNET port if zero or omitted).  If this is omitted,\n   then the default port number is taken.\n\n   END\n\n   Formerly required to keep menu entries separate.  However, a comment\n   line (any line starting with '*', '#' or '!' in the first column)\n   will be interpreted as a menu entry separator, so that Gopher menu\n   bookmark files may be ported from Unix systems.\n\nMore about Path Names\n\n Note that the format of a path depends on which Gopher server is\n going to be processing the entry, as defined by the HOST= field.\n If the entry is going to a different Gopher server, then the\n pathname format depends on that server.  For example, a Unix server\n would expect a Unix file name with a slash.\n\n In general, a selector string for an MVS Gopher server has the format:\n\n   t/path\n\n where \"t\" is the one-character Gopher type, and \"path\" is usually an\n MVS data set name but may be other things, as indicated below.\n\n It may seem redundant to include the type character when the same\n information is in the TYPE= line in the menu entry.  But it really\n isn't, because the Gopher server doesn't see the TYPE= stuff when\n a client sends it a request.  The \"t\" character really tells the\n server what format to use when retrieving the data.  It is especially\n important when the data must be rerieved in binary rather than text\n In fact, the type does not need to match the TYPE= type.  In some\n cases it is best to specify a binary type (9) in the selector string\n along with some other kind of type.\n\n If the selector string does not begin with a type character followed\n by a slash, then the MVS gopher server will make a best guess as to\n what the type of the item is.  For data sets, it will look inside and\n return the data set as a Gopher menu if it is an MVS PDS or if it is\n a text file whose first line says \"GOPHER_MENU\".  Otherwise it will\n return it as a text file.  It will never return it as a binary file.\n\n Examples:\n\n  SYS1.MACLIB(OPEN)         -  identifies a text file.\n  0/SYS1.MACLIB(OPEN)       -  also identifies a text file.\n  1/GOPHER.MENUS(THINGS)    -  identifies a menu.\n\n This is required if you want to serve a binary file:\n\n  9/SYSB.RANDOM.BITS        -  identifies a binary file.\n\n Gopher has no other way of telling that the data must be\n transmitted in binary format.\n\n To be more specific about the path names for the MVS gopher server:\n\n * A fully qualified MVS data set name, without quotes, identifying\n   a sequential text data set or PDS member.  If TYPE=FILE, this is\n   text.  If TYPE=DIRECTORY, this is a gopher menu as described above.\n\n * A fully qualified MVS data set name, without quotes, identifying a\n   PDS (no member).  This causes the MVS Gopher server to return a\n   list of member names of the PDS in Gopher directory format.  This\n   should be used only with TYPE=DIRECTORY.  Member aliases are\n   included in the resulting list.\n\n * A member name enclosed in parentheses.  This is treated as\n   a full PDS member.  In other words, the MVS Gopher server will use\n   the name of the PDS in which the menu itself was found.\n   This allows you to move PDS's full of Gopher menus around without\n   having to worry about changing all the path names.  This happens\n   only when the menu itself is a PDS member and the host is the\n   same as the local host (MVS for the server, - for local mode).\n   Specifying HOST=+ is recommended for this.\n\n   Each member is treated as a Gopher FILE.  The NAME field is\n   set to the member name.  If you want to do anything fancier\n   than this, you will have to construct your own Gopher menu.\n\n * A string \"DD:ddname\" or \"DD:ddname(member)\", identifying a file by\n   MVS ddname a la C/370.  Valid with either TYPE=FILE or\n   TYPE=DIRECTORY, so the ddname can point to text or a menu.\n   However, if the ddname happens to be allocated to a PDS, it does\n   NOT work like a directory above - it's just illegal and will\n   probably cause lossage.\n\n * A string \"EXEC:execname args\", which specifies the name of a\n   REXX exec to be executed to return the data.  Valid with any\n   and all types.  To learn more about how to make use of this\n   feature, please go back to the \"About This Gopher\" tree and\n   read up on using REXX execs with MVS Gopher.\n\n   If you are using your own private GOPHER data via local access\n   and you want to run REXX execs, you must have a \"localexec:\"\n   line in your GOPHERRC file identifying your REXX exec library.\n\n * A string \"FTPn:ftpstuff\", which specifies a remote host, a file or\n   directory to be fetched via anonymous FTP to that remote host, and\n   the type of the file (n) to be returned.  This is valid with any\n   Gopher type, but will be most useful with the FILE type (n = 0,\n   TYPE=0); the DIRECTORY type (n = 1, TYPE=1); the BINARY type (n = 9,\n   TYPE=9); the IMAGE type (n = g, TYPE=g); and possibly others.\n\n * A string \"FTPVMn:ftpstuff\", which is like FTPn except that the remote\n   host is a VM/CMS machine running the \"FAL\" FTP server.\n\n   For all of the above...\n\n   Note that the HOST= and PORT= must still point to the MVS gopher\n   server, which performs the remote FTP for you.\n\n   In the PATH= field, an \"FTPn:\" style selector string may take one\n   of the following forms:\n\n     ftpn:host\n     ftpn:host:path\n     ftpn:host:user:path\n     ftpn:host:user:pass:path\n\n   If path is omitted, then path is the current directory of the remote\n   anonymous FTP session.\n   If user is omitted, defaults to \"anonymous\".\n   If pass is omitted, defaults to \"gopher@localhost.domain.qualifier\".\n\n   The syntax is defined to let path always be the last item\n   just in case the path name contains a colon.\n\n   For the VM variants, the directory is a minidisk specification, and\n   the file is in the format minidisk/filename.filemode (no filetype).\n\n   Examples:\n\n   A directory type request...\n\n    ftp1:boombox.micro.umn.edu:/pub/gopher/mvs\n    ftpvm1:vm1.nodak.edu:powerl\n\n   A file type request...\n\n    ftp0:some.place.else.com:guest:guestpassword:/blah/README\n    ftpvm0:vm1.nodak.edu:powerl/faq3.ann6000\n\nMore About Host Names\n\n You may find that some Gopher servers insist on appending the\n network's domain name to local server hostnames.  You should check\n with your network gurus to make sure that this will work with your\n TCP/IP host lookup.  The MVS server will accept hostnames either\n with or without the domain name appended - this applies to the\n specification of hostnames in the Gopher access table as well -\n but other Gopher servers may not.\n\nTwo special cases:\n\n A plus sign (HOST=+) means that the host is the same host as the one\n that is looking at the directory entry - i.e. the server that is\n serving up this menu.  The Gopher server simply plugs in its own host\n name at that point.  This is NOT part of the Gopher protocol, but\n merely a server hack.\n\n A minus sign (HOST=-) means that access to this item will be in\n \"local\" (serverless) mode.  This is recognized only by the MVS Gopher\n client.  It means that the client will do the retrieval itself,\n without asking a server to do it.  When you use this type, the port\n number must be 70.\n\n The directory-processing code, when invoked in \"local mode\", will\n treat HOST=+ as HOST=- since the current host is the local mode\n operation in that case.  Therefore, using HOST=+ is recommended\n so that one can port one's local GOPHER menus to the public server\n at some point.\n\n A REXX exec that generates menus dynamically can use - as a hostname,\n but not +.\n\n------------------------------------------------------------------------\n\n How To Request Information Resources From Other GOPHER Servers\n\nRather than describe the standard format of a Gopher menu here,\nI recommend that you go to your nearest Unix box and type\n\n  man gopherd\n\nThat should tell you all you need to know about Unix gopher servers.\nIf your gopher server is on some other kind of machine, then go find\nthe documentation for that machine's Gopher menus.\n\nThe purpose of the above exercise is primarily to determine the format\nof a path name understood by a given Gopher server.  Once you know that,\nyou can build a Gopher menu the MVS Gopher will understand, according to\nthe format described in the top section.  Set the host to point to\nthe other Gopher server, who will interpret the other items in the menu.\n\n------------------------------------------------------------------------\n\nDynamic Generation of GOPHER Menus\n\n If you want to be able to generate a Gopher menu dynamically,\n you can do this via the REXX interface.  You also must understand\n the Gopher protocol.  A Gopher menu is really a text representation\n of the actual protocol, which goes like this:\n\n filetype name -tab- path -tab- host -tab- port\n\n where -tab- is the EBCDIC (on MVS) or ASCII (on other box) tab\n character, and filetype is a single character.  The filetypes\n supported by the MVS Gopher server are:\n\n 0 - flat file\n 1 - directory\n 2 - CSO\n 3 - error\n 7 - index\n 8 - TELNET\n 9 - binary\n T - TN3270\n w - whois (experimental)\n i - comment (unselectable menu line)\n b - BookManager format\n\n A REXX exec that wants to generate a Gopher menu must output lines\n in this format.  For more information, go back to the Gopher tree\n for \"About This Gopher\" and look up information on the REXX interface.\n\n./ ADD NAME=ABOUTCSR\n\n=======================================================================\n\n The GOPHERRC File\n\n=======================================================================\n\n When you use the GOPHER client, you need a file called GOPHERRC\n which stores information about your use of GOPHER.  If you don't\n have one, GOPHER will create it for you.  The file initially\n contains:\n\n    the initial path/name/host/port specification, which tells\n    GOPHER what to display on startup.  By default this is the\n    standard GOPHER server info on MVS.  However, you can add\n    to your GOPHERRC a specification for local GOPHER by\n    editing GOPHERRC and activating one of the following:\n\n    - the other \"initial:\" spec which points to your own startup menu,\n      overriding the one you'd get otherwise\n\n    - the localmenu: and localexec: lines.\n\n    - the telnet:, bookmgr: and domain: lines.\n\n    localmenu: is equivalent to specifying an alternate initial:\n    spec of host=- (dash) and path=localmenu_name.  When you use\n    the LOCAL operand of the GOPHER command, localmenu: is what\n    GOPHER looks for as the pathname if you don't provide one on\n    the command.\n\n    localexec: is required if you want to use your own library of\n    GOPHER rexx execs.  This is valid for LOCAL access only.\n\n    telnet: is required if you want to use a telnet command other\n    than TELNET.  For example, UCLA's XTELNET is recommended if\n    you have it (and if you don't have it, then get it).\n\n    bookmgr: is required if your BookManager READ/MVS command is\n    other than \"BOOKMGR\".  Note, however, that whatever command\n    you specify must take a BOOK('data-set-name') argument.\n\n    domain: is required if your installation hasn't configured\n    the Gopher client to reference the correct local domain.\n    This may be the case if you are using the object-code-only\n    distribution, for example.  Normally when GOPHERRC is built\n    upon your first use of the GOPHER client, this value should\n    be set correctly.  There should never be any need to change it,\n    assuming that it works properly, which you'll find out right\n    away if it doesn't.\n\n    Some option defaults may be stored in the GOPHERRC file;\n    others are remembered in your ISPF profile.\n\n    Note that bookmarks are not stored in your GOPHERRC file.\n    They are stored in separate bookmark data sets, whose names\n    the client user must specify.  Do not attempt to load your\n    GOPHERRC file as a bookmark file!\n\n    If you have a newly created GOPHERRC file, you can read the\n    comments to guide you in customizing the file.\n\n    You may also specify a different startup file when you invoke\n    the MVS GOPHER client via the INITFILE keyword - e.g.\n\n      GOPHER INITFILE(SOME.OTHER.RC)\n\n    If the data set does not yet exist, it will be created.\n\n./ ADD NAME=ABOUTCSW\n\n=======================================================================\n\n What Happens When You Start Up GOPHER?\n\n=======================================================================\n\n What you see when you start up GOPHER depends on what you have\n specified, either on the command line or in the GOPHERRC file.\n In general, command operands override GOPHERRC specifications.\n\n GOPHER does its thing by connecting to a Gopher server somewhere\n on your network.  If you do not specify otherwise, this server is\n assumed to be MVS (the host where you are running this client).\n The default GOPHERRC file specifies this as the server.\n The startup menu you see is the one defined by the administrator\n of that server.\n\n You can request a different server or a different startup menu,\n either by modifying the GOPHERRC file or by specifying command\n operands.  The SERVER operand tells GOPHER to get a startup menu\n from a different server, and the PATH operand tells GOPHER what\n startup menu to request (the contents of the path depend on what\n server you point to and what it's looking for, but it is typically\n the name of a file on that system that contains a Gopher menu).\n\n You can also use GOPHER to access your own private data by requesting\n \"local\" (serverless) mode.  A server name of a single dash \"-\" means\n local access.  In this case, you must provide a path name so that\n GOPHER knows where to look for your data.  The path name is the name\n of a data set containing your GOPHER menu - it must be FULLY QUALIFIED\n AND WITHOUT QUOTES.  The path name can be provided either as a command\n operand or in the GOPHERRC file.\n./ ADD NAME=ABOUTR\ngopher_menu\n\nType=0\nName=REXX Interface Overview\nPath=(ABOUTRO)\nHost=+\nPort=+\nEnd\n\nType=0\nName=Specifying Hostname and Port\nPath=(ABOUTRP)\nHost=+\nPort=+\nEnd\n\nType=0\nName=REXX Interface Reference\nPath=(ABOUTRR)\nHost=+\nPort=+\nEnd\n\n./ ADD NAME=ABOUTRO\n=======================================================================\n\nREXX Exec Interface Overview\n\n=======================================================================\n\nYou can request the MVS Gopher server to retrieve information\ndynamically by executing a REXX exec.  To request this, you define a\nmenu entry with a PATH= field that looks like one of these:\n\nPATH=0/EXEC:execname args          (to return a \"file\")\nPATH=1/EXEC:execname args          (to return a \"menu\")\nPATH=7/EXEC:execname args          (to do a search and return a \"menu\")\nPATH=EXEC:execname args            (the old style, still supported)\n\nIn all of the above, the REXX exec identified by \"execname\" is\nexecuted, along with the arguments \"args\" given.  For example:\n\nPATH=0/EXEC:MYEXEC ANY ARGS\n\nwill cause the MYEXEC exec to be executed with \"ANY ARGS\" as the\nsingle argument string.\n\nIf the TYPE is INDEX, the search string submitted by the user will be\nappended to the args separated by a blank.  The exec must be able to\ndeal with this.\n\nREXX Execs must be in a PDS allocated to DD GGEXEC.  This ddname\nneeds to be present in the Gopher server's JCL.\n\nNote that you do not need the /* REXX */ comment at the beginning of\nREXX execs used by gopher (though it does not hurt to include it!),\nbecause they are invoked by the IRXEXEC facility and not the standard\nTSO CLIST/EXEC search.\n\nYou can also use the EXEC: interface from the MVS Gopher client in\n\"local\" (serverless) mode.  For local mode, the GOPHER command will\nallocate the GGEXEC file to the REXX exec library specified on the\n\"localexec:\" line in your GOPHERRC file, if you have activated it.\nOtherwise you will not be able to use REXX execs in local mode.\n\nNow, how does the REXX exec return data to the Gopher server?\n\nFirst of all, it depends on the TYPE that the exec is expected\nto return, which has nothing to do with HOW the returning is done.\n\nSecond of all, it does it using various internal interfaces which\nyou don't have to know about or understand.  Some REXX functions\nhave already been provided for you to use that will do the dirty\nwork for you.\n\nSo, first let's talk about how the exec returns data, and then\nabout what it is expected to return.\n\nHow to return data\n\nThe REXX exec must return data by writing it to the data stack\nbetween a call to GOPEN and a call to GCLOSE.\n\nExample:\n\n parse arg myargs, gopherargs\n call gopen gopherargs\n do while more_data_to_get\n  some_data = get_some_data()\n  if some_data = \"\" then queue \" \"\n  else queue some_data\n end\n call gclose gopherargs\n\nNote:  It is recommended that you not queue any null lines.\nAlthough this will not result in failure, the null lines are\nlikely to disappear for reasons I would rather not go into here.\n\nIf the gopher server is run straight batch rather than as a TSO job, then\nyou cannot run REXX execs that require a TSO environment.\n\nIf the Gopher server is a TSO-in-batch job (i.e. EXEC PGM=IKJEFT01),\nthen you can issue TSO commands from the exec.  To get the output,\nthough, you need to use OUTTRAP around them.  The GTSOTRAP routine is\nprovided to do this for you.  If the command issues TPUTs instead of\nPUTLINEs, though, you are out of luck.\n\nNote that a Gopher server running in TSO mode will almost certainly be a\nsingle-threading server, to prevent more than one client from running in\nthe same TSO environment at the same time.\n\nIf you want to run a PL/1 program that writes to SYSPRINT, or a FORTRAN\nor assembler program, etc., you can allocate the SYSPRINT or FT06F001\nor whatever file to a temporary and dump the temporary to the stack.\nThe problem with both PL/1 and FORTRAN programs is that, like TSO\ncommands, they must be run in a single-threading Gopher server, because\notherwise you may run into a conflict if two clients try to write to\nthe same DDNAME.\n\nIf, on the other hand, your program is a C/370 program that writes to\nstdout or stderr, you can avoid this problem by using redirection,\nas in this example using a C program called HELLO:\n\n for stdout:\n\n   stdout = grabtemp()\n   call gcall \"HELLO\", args \"> DD:\"stdout\n   call gopen gopherargs\n   \"EXECIO * DISKR\" stdout \"(FINIS)\"\n   call ungrab stdout\n   call gclose gopherargs\n\n for stderr:\n\n   stderr = grabtemp()\n   call gcall \"HELLO\", args \"2> DD:\"stderr\n   call gopen gopherargs\n   \"EXECIO * DISKR\" stderr \"(FINIS)\"\n   call ungrab stderr\n   call gclose gopherargs\n\n For multiple output, use >> instead of > in your parameter list.\n\n Note that the C program must reside in a library allocated to\n STEPLIB in the gopher server JCL.  Of course, you can use the TSO\n CALL command if you're using the single-threaded TSO server, but\n then you wouldn't be worrying about this issue anyway.\n\n Recommended JCL for executing the Gopher server may be found\n elsewhere in the installation materials, or your MVS system\n programmer has probably already installed a Gopher server or two in\n 'SYS1.PROCLIB' or the equivalent with the correct allocation.\n\nWhat it is expected to return\n\n OK - now the good stuff.  This depends on the TYPE on the menu entry\n that your exec is trying to fulfill.  Some gopher protocol basics:\n\n A Gopher menu is really a text representation of the actual protocol,\n which goes like this:\n\n filetype name -tab- path -tab- host -tab- port\n\n where -tab- is the EBCDIC (on MVS) or ASCII (on other box) tab\n character, and filetype is a single character.  The filetypes\n supported by the MVS Gopher server include:\n\n 0 - flat file\n 1 - directory\n 7 - index\n\n There are also other types, including binary types, but you won't be\n able to use those with REXX execs, at least not now.\n\n To generate the equivalent of a Gopher menu, you must output data\n in the above format.  Now for the details...\n\nTYPE=FILE\n\nJust return the straight data.  Try to avoid null lines because C/370\nbelieves they don't exist and will throw them away.  Change all null\nlines to lines containing one blank as you write them out (you're used\nto doing this if you are queueing output on the stack) and you will\nhave no problems.\n\nTYPE=DIRECTORY\n\nYou must return lines that fit the gopher protocol format as above.\n\nFor example, if you want to generate a Gopher menu on the fly that\nis equivalent to this:\n\n type=file\n name=This is my description\n path=some.gopher.path\n host=sun1.sanjuan.com\n port=70\n\nthen you output a line that looks like this:\n\n  0This is my description!some.gopher.path!sun1.sanjuan.com!70\n\n(each ! is really a tab (EBCDIC hex 05) character)\n\nwhere \"0\" is the type (file in this example, but would be \"1\" for\ntype=directory, \"7\" for typeindex, etc.)\n\nHere's the REXX code that might do this:\n\n name = \"This is my description\"\n path = \"some.gopher.path\"\n host = \"sun1.sanjuan.com\"\n port = 70\n tab  = '05'x\n queue \"0\"||name||tab||path||tab||host||tab||port\n\nSee \"Specifying Hostname and Port\" for more information.\n\n./ ADD NAME=ABOUTRP\n\n=======================================================================\n\nSpecifying the Right Host Name\n\n=======================================================================\n\nMost of the time you will probably want to generate a menu item\nthat points back to your MVS host, not some other host.  It may\neven redrive your selfsame REXX exec with new arguments.  And if\nthe exec was invoked in local (serverless) mode, you want the item\nto get driven in the same mode, probably.\n\nThe question is - what's the easiest way to identify what\nthe \"same server\" is?  One way is to hardcode the server name (e.g.\n\"MVS.DRAPER.COM\"), but this is not sufficiently general because:\n\n(1) the server name or location may change\n(2) you can't distribute the exec to other Gopher users\n(3) it won't work the same way in \"local mode\"\n\nSo, you need a way to know what the name of your selfsame host is.\nThe MVS Gopher server can use HOST=+, but you can't, as that isn't\npart of the Gopher protocol.  So what do you do?\n\nYou have the same problem with the Gopher port number.  You usually\nwant it to be the same as the one by which your REXX exec was invoked.\n\nUse the functions ghost() and gport() to return the current host\nname and port number.  So in a typical Gopher exec, you might have:\n\n parse arg myargs, gopherargs\n host = ghost(gopherargs)\n port = gport(gopherargs)\n\nNote: the functions hostname() and port() are also available for\ncompatibility with earlier releases of the MVS Gopher.  However, ghost()\nand gport() are recommended.  All of them are required to take\ngopherargs as their argument, or else they may not work properly.\n\nNote that a plus sign \"+\" will not work when creating a hostname for a\nGopher menu item.  The plus sign is a hack interpreted by the Gopher\nserver when it sees it on a menu.  It is *not* part of the Gopher\nprotocol and therefore cannot be sent over.\n\nHowever, the minus sign \"-\" will work, as the Gopher client\nin local mode will interpret it at the protocol level\n(which DOES NOT IMPLY THAT IT IS A PART OF THE STANDARD\nGOPHER PROTOCOL, PROPOSED OR OTHERWISE - THIS IS JUST A\nLOCAL HACK MODIFICATION).\n\nMore details on the REXX interface are in the REXX Interface Reference.\n\n./ ADD NAME=ABOUTRR\n        MVS Gopher (Version 3) - New REXX Interface\n\nThe REXX interface for the MVS gopher server has been completely\nrewritten.  Features:\n\n        It is much easier to write REXX execs that work without\n        needing arcane facilities.\n\n        The right hostname and port are automatically taken care of.\n\n        Execs do not require a TSO environment, so they can be run\n        from a truly multitasking non-TSO Gopher server.\n\nHere is how it works.\n\nA REXX exec is invoked from a Gopher menu option by defining a\nGopher menu item something like this:\n\n        Type=t (whatever type)\n        Name=the name of your option\n        Path=n/EXEC:execname parameters\n        Host=mvs.draper.com\n        Port=pn\n\nwhere:\n\n        t is the type to be asked for by the client\n        (0 = text, 1 = menu, 7 =- index, etc.).\n\n        n is the type to be returned by the exec\n        (0 = text, 1 = menu, 9 = binary, etc.).\n        Usually (but not always) this will match \"t\".\n\n        pn is the port number (70 for the primary gopher server,\n        1570 for the secondary, if you follow the recommended\n        conventions for two gopher servers).\n\n        execname is the name of the exec (1-8 characters).  It\n        must be a member of the PDS allocated to DDname GGEXEC\n        in the gopher server started task JCL.\n\n        parameters are arguments, if any, passed to the exec.\n\nFor the path name, the n/ part may be omitted for compatibility\nwith the old style of REXX exec invocation.  The purpose of the\nn/ part is to identify the type:  0/ means return text data,\n1/ means return a menu, 9/ means return binary data, etc.\nIf this is omitted, text data is assumed - of course, if the\ngopher client originally asked for a menu, then the output will\nbe assumed to be in gopher menu format.\n\nThe REXX exec itself will work like this:\n\nIt takes two argument values, which can be parsed thusly:\n\n parse arg rexxargs, gopherargs\n\n\"rexxargs\" is whatever follows \"EXEC:execname\" in the\nmenu item.  For type 7 (index), the search string that the\nclient user typed in gets appended to the value in the path,\nseparated by a space.\n\n\"gopherargs\" is a string that contains information needed by\nthe exec to communicate with Gopher.  You don't need to know\nthe format of this, since all you will do is pass it to a\nseries of REXX functions that are provided as part of the\nGopher - REXX interface.  These functions must be stored in\nthe DDname GGEXEC PDS (you can use concatenated PDS's if you\nlike).  These functions are:\n\n        GCALL\n        GCLOSE\n        GHOST\n        GNOTIFY\n        GOPEN\n        GPORT\n        GRAB\n        GRABTEMP\n        GREAD\n        GTSOTRAP\n        UNGRAB\n\nFor compatibility with the instructions given in previous\nversions of the MVS gopher, the following functions are\nalso provided:\n\n        HOSTNAME                (obsolete, use GHOST)\n        PORT                    (obsolete, use GPORT)\n\nHowever, they now take a gopherargs argument:\n\n        hostname(gopherargs)\n        port(gopherargs)\n\nInstallation note:  You must be running at least TSO/E 2.3.1\nto use GCALL, and you need to install the XGALLOC program\nin a library allocated to STEPLIB in the gopher server\nstarted task JCL - this is used by GRAB, GRABTEMP and UNGRAB.\n\nIf you cannot use one or more of GCALL or the GRAB family,\nyou can still run the REXX interface, but you must use the\nTSO \"ALLOCATE\", \"FREE\" and \"CALL\" commands.  That means you\nmust run a server that runs IKJEFT01 and single-threads.\n\nGREAD and GTSOTRAP are merely conveniences for the programmer.\nNote that GTSOTRAP by its nature, unlike the others, actually\nrequires a TSO environment to be present.\n\nExplanation:\n\n        GCALL    - call a compiled (assembler, C, etc.) program\n        GCLOSE   - write out and close GOPHER text output stream\n        GHOST    - return the hostname of the current menu item\n        GNOTIFY  - log a write-to-programmer message to syslog\n        GOPEN    - open GOPHER text output stream\n        GRAB     - allocate an existing data set\n        GRABTEMP - allocate a temporary data set\n        GREAD    - read contents of a file onto the stack\n        GTSOTRAP - direct output of a TSO command onto the stack\n        UNGRAB   - unallocate a file\n\nNote the routines that write stuff onto the stack, and also the\nfact that there is no \"GWRITE\" routine.  Why?  Because the way to\nsend Gopher data remains the same as it was in earlier versions:\nyou queue it onto the REXX data stack.  The difference is that\nyou call the GOPEN and GCLOSE routines to manage the stack - you\ndo not need to fool around with EXECIO or SYSTSPRT.  In fact,\nSYSTSPRT is not even used anymore.\n\nMany of these functions take gopherargs as an argument, because\ngopherargs contains the information they need to function.\n\nWhy the funny routines?\n\nWell, for one thing, to make it easier for you to write your REXX\ncode.  But also to enforce certain things.  When you are working in a\nmultitasking environment, there are some things that you may be used to\ndoing that you cannot do.  Chief among them is that you cannot use\nhardcoded or preset ddnames.  There may be several gopher execs running\nsimultaneously and your execs can blow each other (and gopher) away if\nyou do.  That is why we provide allocation routines - they generate\nunique ddnames and return them to your exec, and you are supposed to\nuse those ddnames and no other.\n\nAlso, this frees you from the necessity of having a TSO environment,\nwhere you cannot use commands like ALLOCATE.\n\nDetailed Descriptions\n\nGCALL    - call a compiled (assembler, C, etc.) program\n\nSyntax:  call gcall modulename, parameters\n\nReturns: the return code from the specified module\n         in REXX variable \"RESULT\" (as per the REXX \"call\" statement)\n\nExample:  call gcall \"IEFBR14\", \"SIZE=200K\"\n          say \"Return code is\" result\n\nGCLOSE   - write out and close GOPHER text output stream\n\nSyntax:    call gclose gopherargs\n\nReturns:   nothing of interest\n\nExample:   parse arg foo bar baz , gopherargs\n           call gopen gopherargs\n           queue \"This is some Gopher data.\"\n           queue \"This is some more Gopher data.\"\n           call gclose gopherargs\n\nGHOST    - return the hostname of the current menu item\n\nSyntax:    host = ghost(gopherargs)\n\nReturns:   the hostname of the MVS gopher server that invoked you\n\nExample:   parse arg foo bar baz , gopherargs\n           tab = x'05'\n           type = \"0\"\n           name = \"Cool Stuff\"\n           path = \"0/EXEC:KOOLS\" foo\n           host = ghost(gopherargs)\n           port = gport(gopherargs)\n           queue  type || name || tab || path || tab || host || tab || port\n\nGNOTIFY  - send a write-to-programmer log message to the system log\n\nSyntax:    call gnotify \"GGMVSnnn message text\"\n\nReturns:   nothing\n\nComments:  If you have disabled logging in the server, you probably don't\n           want to be using this either.\n\nExample:   call gnotify ,\n            \"GGMVS999 The Gopher server is experiencing grave lossage.\"\n\nGOPEN    - open GOPHER text output stream\n\nSyntax:    call gopen gopherargs\n\nReturns:   nothing of interest\n\nExample:   parse arg foo bar baz , gopherargs\n           call gopen gopherargs\n           queue \"This is some Gopher data.\"\n           queue \"This is some more Gopher data.\"\n           call gclose gopherargs\n\nGRAB     - allocate an existing data set\n\nSyntax:    newddname = grab(datasetname,disposition)\n           datasetname is a fully qualified MVS name (quotes optional)\n           disposition is one of: SHR OLD MOD NEW\n\nReturns:   a unique ddname (null string if allocation failed)\n\nComments:  GRAB stands for \"Gopher Resource Allocation in Batch\"\n\nExample:   infodd = grab(\"GOPHER.INFO.DATA\",\"SHR\")\n           if infodd = \"\" then exit 12 /* fail */\n           call gopen gopherargs\n           call gread infodd\n           call gclose gopherargs\n           call ungrab infodd\n\nGRABTEMP - allocate a temporary data set\n\nSyntax:    newddname = grabtemp()\n\nReturns:   a unique ddname (null string if allocation failed)\n\nComments:  GRABTEMP stands for \"Gopher Resource Allocator in Batch to\n           Touch Empty Memory Pages\"\n\nExample:   tempdd = grabtemp()\n           if tempdd = \"\" then exit 12 /* fail */\n           \"newstack\"\n           queue \"hi there\"\n           queue \"bye\"\n           queue \"\"\n           \"EXECIO * DISKW\" tempdd \"(FINIS)\"\n           call ungrab tempdd\n\nGREAD    - read contents of a file onto the stack\n\nSyntax:    call gread ddname\n\nReturns:   nothing of interest\n\nComments:  ddname should have been set by call to GRAB or GRABTEMP first\n\nExample:   infodd = grab(\"GOPHER.INFO.DATA\",\"SHR\")\n           if infodd = \"\" then exit 12 /* fail */\n           call gopen gopherargs\n           call gread infodd\n           call gclose gopherargs\n           call ungrab infodd\n\nGTSOTRAP - direct output of a TSO command onto the stack\n\nSyntax:    call gtsotrap tsocommandstring, gopherargs\n\nReturns:   the return code from the TSO command\n\nComments:  TSO environment is required.  Note that this routine\n           does gopen and gclose internally.  DO NOT CALL GOPEN\n           OR GCLOSE IF YOU USE THIS ROUTINE.\n\nExample:   parse arg stuff, gopherargs\n           call gtsotrap \"LISTD\" stuff \"M ST\", gopherargs\n\nUNGRAB   - unallocate a file\n\nSyntax:    call ungrab ddname\n\nReturns:   return code from dynamic unallocation\n\nExample:   infodd = grab(\"GOPHER.INFO.DATA\",\"SHR\")\n           if infodd = \"\" then exit 12 /* fail */\n           call gopen gopherargs\n           call gread infodd\n           call gclose gopherargs\n           call ungrab infodd\n\nAn Example for You to Play With\n\nThis \"REXXTEST\" gopher menu item allows you to poke around and\nsee what is really going on in the REXX world  Try it.\n\nTYPE=0\nNAME=Test the REXX Interface on port 70 (MVS Gopher server 1)\nPATH=EXEC:REXXTEST\nHOST=+\nPORT=70\nEND\n\nTYPE=0\nNAME=Test the REXX Interface on port 1570 (MVS Gopher server 2)\nPATH=EXEC:REXXTEST\nHOST=+\nPORT=1570\nEND\n\nand here is the REXXTEST exec:\n\n/* REXX */\n\nparse arg args, gopherargs\nparse version rexx_version\nparse source rexx_source\n\ncall gopen gopherargs\n\nqueue \"PARSE VERSION returns:\" rexx_version\nqueue \"PARSE SOURCE  returns:\" rexx_source\nqueue \"Argument 1 is.........\" args\nqueue \"Gopherargs are........\" gopherargs\n\ncall gclose gopherargs\n\nreturn\n\n./ ADD NAME=ABOUTS\ngopher_menu\n\nTYPE=FILE\nNAME=Creating MVS Gopher Menus\nPATH=(ABOUTCSM)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=MVS Gopher Access Table\nPATH=(ABOUTSA)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=MVS Gopher Startup Parameters\nPATH=(ABOUTSP)\nHOST=+\nEND\n\nTYPE=DIRECTORY\nNAME=REXX Exec Interface\nPATH=(ABOUTR)\nHOST=+\nEND\n\n./ ADD NAME=ABOUTSA\n\n          Format of entries in the Gopher Access Table\n\n  Each entry in the table is a single line containing, in the most\n  general sense, a filename followed by a list of hostnames.\n\n  The filename (fully qualified, all uppercase, no quotes)\n  can be a fully qualified MVS data set name, or a string like\n  DD:DDNAME or EXEC:EXECNAME.  It can also contain an asterisk\n  for a wildcard specification - see below for more details.\n\n  The hostnames are names of TCP/IP machines which are authorized to\n  access the data.  If no host name list is present, all hosts are\n  authorized to access the specified filename.\n\n  You may specify the same file name more than once, if you need more\n  lines to put additional host names on.  There is no syntactic\n  convention for continuing a long line, so this is how you would do\n  it.  This allows multiple entries for a path specifying different\n  hosts, so the MVS administrator doesn't have to worry about running\n  out of room on a line.\n\n  Individual PDS members are specified separately.  A PDS without\n  a member name establishes access only to the PDS directory.\n  However, you can use wildcarding to specify access to all members\n  of a given PDS:  just put an asterisk in place of the member name.\n  For example, SYS1.SOME.PDS(*) would define access to all members\n  of SYS1.SOME.PDS.\n\n  Note that the default directory (DD:GGGOPHER) MUST be in this table.\n  You could use this entry to define access to the top-level server.\n\n  Also note that in the case of EXECs, the EXEC must live in the\n  library allocated to GGEXEC in the Gopher server JCL.  (Of course;\n  how could it be executed otherwise?)\n\n  *** ANY DATA SET REFERENCED BY ANY EXEC IN THAT LIBRARY, AS WELL AS\n  *** ANY EXEC INVOKED BY THE FIRST EXEC, IS FULLY ACCESSIBLE TO GOPHER\n  *** REGARDLESS OF THIS TABLE!  USE THIS TABLE TO GOVERN CONTROL TO\n  *** THE EXEC ITSELF!!!\n\nHow Wildcards Are Handled\n\nIn prior versions of MVS Gopher, the access file was read each time a\nclient request came in and the format was limited to:\n\n dsname        host1 host2 host3\n\nThe file was read until an entry that matched both the path and the\nhost was found.  If no such entry existed the access was denied.  Doing\nit this way also allowed for multiple entries for a path specifying\ndifferent hosts, so the MVS administrator didn't have to worry about\nrunning out of room on a line.\n\nIn V3, the access file contains lines that are read into memory and\nsorted into an appropriate order.  The format is:\n\n pathspec     hostspec1 hostspec2 hostspec3\n\n\"pathspec\" may be a wildcard expression.  Currently, the only wildcard\nsyntax is a single asterisk (\"*\" character) somewhere in the pathspec.\n\n \"hostspecn\" is a hostname, as before.\n\nAccess Rule Prioritization\n\nSince with wildcards, a path can match more than one rule, with possible\nconflicting results, an algorithm has been established for picking the\nappropriate access rule.\n\nEach rule is given two weight values - a major weight and a minor\nweight.  You can see these weights printed out by the server when the\nserver is started up.\n\nThe major weight is set to the actual length of the pathname in\ncharacters, excepting wildcard characters.  This represents the number\nof explicit characters in the pathspec that matches the target name.\nThe minor weight is set to the number of characters preceding the\nasterisk (the entire length of the path if no wildcard).  The rules are\nthen sorted in descending order of major and minor weight.  We will\nrefer to this major and minor weight as a \"weight-pair\".\n\nWhen a client request comes in, a search is done until a rule is found\nthat matches the path - in other words, the highest weight-pair\nassociated with a matching rule is found.  Then, all the rules with the\nsame weight-pair as that rule are tested.  If the request matches ANY\nof these rules and succeeds (i.e. one of these rules has both a\nmaatching path and a matching host), the access is allowed.  If the\nrequest does not match any of these rules, the access is denied - no\nrules of other weight-pairs are checked.\n\nConsider this example:\n\n foo.bar.baz  host0\n foo.*.baz    host1 host2 host3\n foo.bar.*    host4 host5 host6\n foo.*        host7 host8 host9\n *.baz        host10 host11 host12\n foo.xxx.*    host13 host14 host15\n\nThe above rules have the following weights:\n\n Pathname     Major  Minor\n\n foo.bar.baz   11     11\n foo.bar.*      8      8\n foo.xxx.*      8      8\n foo.*.baz      8      4\n foo.*          4      4\n *.baz          4      0\n\nWe've displayed the rules above in the order in which they will be\nsearched.  They could have been specified in any order in the\naccess file.  The only time the order in the access file matters\nis for rules of the same weight-pair.\n\nNow, if a client requests to see a file, here's what happens.\n\nIf the request is for file foo.bar.baz, the first rule, with weight-pair\n11-11, matches.  This is the obvious case where we have an exact match\nwith no wildcards, which always is \"best\".\n\nSo, the only host that can access foo.bar.baz is host0, because there\nis an explicit rule governing it, the \"foo.bar.baz\" rule, which \"wins\".\n\nIf, on the other hand, the request is for file foo.bar.mumble.baz, all\nexcept two of the rules apply.  \"foo.bar.baz\" and \"foo.xxx.*\" do not\nmatch, but all the other rules do in this case.  However, only the\nrules of the \"best\" weight-pair will apply.  Here the highest\nweight-pair among the eligible rules is 8-8, because we have a pathname\nmatch with \"foo.bar.*\".  Therefore, only rules of weight-pair 8-8 will\nbe considered.  Since the only rule of weight-pair 8-8 that matches the\nclient's requested file name is the \"foo.bar.*\" rule, the only hosts\nthat can access this file are host4, host5, and host6.\n\nLooking at it another way, \"foo.bar.*\" is a \"better\" match than\n\"foo.*.baz\", \"foo.*\" or \"*.baz\", even though they all potentially\nmatch, so we apply the \"foo.bar.*\" rule and do whatever it says.\n\nNow, consider a request for foo.bar.mumble.  That could match any of\n\"foo.bar.*\" or \"foo.*\" - but, as we have seen, \"foo.bar.*\" is a more\npowerful match, as proven by its weight-pair.  Therefore,\nfoo.bar.mumble can be accessed by host4, host5 and host6.  Note that\nhost7, host8 and host9 cannot access it, even though it would seem to\nmatch the \"foo.*\" rule, because the \"foo.bar.*\" rule takes precedence.\n\nIn cases where more than one rule with a given weight-pair should\nmatch a given file, the first one that finds a matching host wins,\nas with Gopher v2.  This allows you to continue to specify the same\nfile name with multiple host strings.\n\n./ ADD NAME=ABOUTSP\n\n MVS Gopher Startup Parameter File\n\n The Gopher server started task may contain a DD statement pointing\n to DDname GGPARMS.  If so, this file contains startup parameters\n for that invocation of the server.  If such a file does not exist,\n the defaults (as in the header file GGUSER) are used.\n\n One possible use of this feature is to have more than one MVS Gopher\n server running, with different port numbers.  This may prevent some\n bottlenecking situations.\n\n All entries in this file have the format:   variable value comments\n\n These are the possible values and their default settings:\n\n mtftasks 1    Number of concurrent subtasks to handle client requests\n port     70   The TCP port number by which clients connect\n qlength  20   Queue length for TCP server listen function\n timeout  60   Connection timeout specified when socket is closed\n domain   .DRAPER.COM     The suffix to be appende to bald host names\n\nYou may notice that the TELNET command may be set in this file too.\nThat was probably a misunderstanding, as it's the client, not the\nserver, that controls how telnets are to be done.\n\n./ ADD NAME=ABOUTW\nWhat is Gopher?\n\nFor more information, read the FAQ, posted to USENET newsgroups\ncomp.infosystems.gopher and news.answers every two weeks.\n\nThe information contained here is borrowed therefrom in large part.\n\nGopher is a client/server protocol for building a distributed\ninformation delivery service.  While providing a delivery vehicle for\nlocal information, Gopher also facilitates access to other Gopher and\ninformation servers on the Internet.\n\nGopher servers and clients can be obtained via anonymous ftp to\nboombox.micro.umn.edu.  Look in the directory /pub/gopher.\n\n     There are clients for the following systems.  For the latest\n     directory information, see the FAQ.\n\n      Unix Curses & Emacs\n      Xwindows\n      Macintosh Hypercard\n      Macintosh Application\n      DOS w/Clarkson Driver\n      NeXTstep\n      VM/CMS\n      VMS\n      MVS\n\n     There are also a number of public telnet login sites available.\n     See the FAQ for more information.\n\n     There are servers for the following systems.  For the latest\n     directory information, see the FAQ.\n\n       Unix\n       VMS\n       Macintosh\n       VM/CMS\n       MVS\n\n\nPapers and articles describing Gopher:\n\n     _The_Internet_Gopher_, \"ConneXions\", July 1992, Interop.\n\n     _Exploring_Internet_GopherSpace_ \"The Internet Society News\", v1n2 1992,\n\n     (You can subscribe to the Internet Society News by sending e-mail to\n      isoc@nri.reston.va.us)\n\n     _The_Internet_Gopher_Protocol_, Proceedings of the Twenty-Third\n          IETF, CNRI, Section 5.3\n\n     _Internet_Gopher_, Proceedings of Canadian Networking '92\n\n     _The_Internet_Gopher_, INTERNET: Getting Started, SRI\n          International, Section 10.5.5\n\n     _Tools_help_Internet_users_discover_on-line_treasures, Computerworld,\n          July 20, 1992\n\n     _TCP/IP_Network_Administration_, O'Reilly.\n\n      Balakrishan, B. (Oct 1992)\n        \"SPIGopher: Making SPIRES databases accessible through the\n      Gopher protocol\".  SPIRES Fall '92 Workshop, Chapel Hill, North\n      Carolina.\n\n      Tomer, C.  Information Technology Standards for Libraries,\n      _Journal of the American Society for Information Science_,\n      43(8):566-570, Sept 1992.\n\n\n./ ADD NAME=FAQ\nFrom: gopher@boombox.micro.umn.edu (UofMN Gopher Team)\nSubject: Gopher (comp.infosystems.gopher) Frequently Asked Questions (FAQ)\nSummary: Common Questions and Answers about the Internet Gopher, a\n        client/server protocol for making a world wide information\n        service, with many implementations.\nOrganization: University of Minnesota, Twin Cities\nDate: Thu, 23 Sep 1993 14:58:54 GMT\n\nArchive-name: gopher-faq\nLast-modified: 1993/08/16\n\nCommon Questions and Answers about the Internet Gopher, a\nclient/server protocol for making a world wide information service,\nwith many implementations.  Posted to comp.infosystems.gopher,\ncomp.answers, and news.answers every two weeks.\n\nThe most recent version of this FAQ can be gotten through gopher, or\nvia anonymous ftp:\n\nrtfm.mit.edu:/pub/usenet/news.answers/gopher-faq\n\nThose without FTP access should send e-mail to mail-server@rtfm.mit.edu\nwith \"send usenet/news.answers/finding-sources\" in the body to find out\nhow to do FTP by e-mail.\n\n-------------------------------------------------------------------\nList of questions in the Gopher FAQ:\n\nQ0:  What is Gopher?\nQ1:  Where can I get Gopher software?\nQ2:  What do I need to access Gopher?\nQ3:  Where are there publicly available logins for Gopher?\nQ4:  How can I add to the information in gopher?\nQ5:  Who Develops Gopher Software?\nQ6:  How can I set up a \"CSO\" phone book server?  Where is the software?\nQ7:  Why can't I access the University of Minnesota's UPI news?\nQ9:  What are the type characters for the different Gopher Objects?\nQ10: When I do full-text searches I always get every document back, Why?\nQ11: When I try to build the UNIX software I get an error from make:\n     \"Must be a separator on rules line #. Stop\"  Why?\nQ12: What is the relationship between Gopher and (WAIS, WWW, ftp)?\nQ13: Are papers or articles describing Gopher available?\nQ14: On a DECstation I get the error message \"/etc/svc.conf no such file\n     or directory\" when running the gopherd server, why?\nQ15: The boolean searching terms don't work for my full-text index, why?\nQ16: When linking the Unix gopher server with WAIS I get undefined symbols,\nQ18: Why don't my WAIS indexes work?  I never get anything back for searches.\n     or Why do I get \"Dangling file\" error messages in my logfile?\nQ19: My gopher server doesn't work under inetd, why?\nQ20: This is not a bug report, just a curiosity. I managed to install\nQ21: Help!  I have PC-NFS and want to use the PC-Gopher client.  How?\nQ22: How do I nuke a hung TCP connection?  I can't restart my UNIX\n     gopher server unless I get rid of it, and I don't want to reboot!\nQ23: Is there somewhere I can retrieve a list of announced gopher\n     links?  I'd like to keep a local, up-to-date list of available gopher\n     holes without requiring our users to gopher to umn just to scan\n     GopherSpace.\nQ24: Why doesn't my unix gopher client display ISO-Latin-1 characters\nQ25: What is veronica?\nQ26: What e-mail/usenet discussions lists are active for Gopher?\nQ27: How do I get my Gopher (whois/cso/library catalog) listed in gopher menus?\nQ28: Where is the registered list of gopher+ view types?\n\n-------------------------------------------------------------------\nQ0:  What is Gopher?\n\nA0:  The Internet Gopher client/server provides a distributed\n     information delivery system around which a world/campus-wide\n     information system (CWIS) can readily be constructed.   While\n     providing a delivery vehicle for local information,  Gopher\n     facilitates access to other Gopher and information servers\n     throughout the world.\n\n-------------------------------------------------------------------\nQ1:  Where can I get Gopher software?\n\nA1:  via anonymous ftp to boombox.micro.umn.edu.  Look in the directory\n     /pub/gopher\n\n--------------------------------------------------------------------\nQ2:  What do I need to access Gopher?\n\nA2:  You will need a gopher \"client\" program that runs on your local PC\n     or workstation\n\n     There are clients for the following systems.  The directory\n     following the name is the location of the client on the anonymous\n     ftp site boombox.micro.umn.edu (134.84.132.2) in the directory\n     /pub/gopher.\n\n      Unix Curses & Emacs   :  /pub/gopher/Unix/gopher+2.0.tar.Z\n      Xwindows (athena)     :  /pub/gopher/Unix/xgopher.1.3.tar.Z\n      Xwindows (Motif)      :  /pub/gopher/Unix/moog\n      Xwindows (Xview)      :  /pub/gopher/Unix/xvgopher\n      Macintosh Hypercard   :  /pub/gopher/Macintosh-TurboGopher/old-versions *\n      Macintosh Application :  /pub/gopher/Macintosh-TurboGopher/ *\n      DOS w/Clarkson Driver :  /pub/gopher/PC_client/\n      NeXTstep              :  /pub/gopher/NeXT/\n      VM/CMS                :  /pub/gopher/Rice_CMS/ or /pub/gopher/VieGOPHER/\n      VMS                   :  /pub/gopher/VMS/\n      OS/2 2.0              :  /pub/gopher/os2/\n      MVS/XA                :  /pub/gopher/mvs/\n\n     Many other clients and servers have been developed by others, the\n     following is an attempt at a comprehensive list.\n\n      A Microsoft Windows Winsock client \"The Gopher Book\"\n       sunsite.unc.edu:/pub/micro/pc-stuff/ms-windows/winsock/apps/gophbook.zip\n\n      A Macintosh Application, \"MacGopher\".\n        ftp.cc.utah.edu:/pub/gopher/Macintosh *\n\n      Another Macintosh application, \"GopherApp\".\n        ftp.bio.indiana.edu:/util/gopher/gopherapp *\n\n      A port of the UNIX curses client for DOS with PC/TCP\n        oac.hsc.uth.tmc.edu:/public/dos/misc/dosgopher.exe\n\n      A port of the UNIX curses client for PC-NFS\n         bcm.tmc.edu:/nfs/gopher.exe\n\n      A beta version of the PC Gopher client for Novell's LAN Workplace\n      for DOS\n         lennon.itn.med.umich.edu:/dos/gopher\n\n      A VMS DECwindows client for use with Wollongong or UCX\n         job.acs.ohio-state.edu:XGOPHER_CLIENT.SHARE\n\n\n     * Note: these Macintosh clients require MacTCP.\n\n     Most of the above clients can also be fetched via a gopher client\n     itself.  Put the following on a gopher server:\n\n       Type=1\n       Host=boombox.micro.umn.edu\n       Port=70\n       Path=\n       Name=Gopher Software Distribution.\n\n\n     Or point your gopher client at boombox.micro.umn.edu, port 70 and\n     look in the gopher directory.\n\n\n     There are also a number of public telnet login sites available.\n     The University of Minnesota operates one on the machine\n     \"consultant.micro.umn.edu\" (134.84.132.4) See Q3 for more\n     information about this.  It is recommended that you run the client\n     software instead of logging into the public telnet login sites.  A\n     client uses the custom features of the local machine (mouse,\n     scroll bars, etc.)  A local client is also faster.\n\n---------------------------------------------------------------------\nQ3:  Where are there publicly available logins for Gopher?\n\nA3:  Here is a short list, use the site closest to you to minimize\n     network lag.\n\n     Public Logins:\n\n     Hostname                  IP#              Login   Area\n     ------------------------- ---------------  ------  -------------\n     consultant.micro.umn.edu  134.84.132.4     gopher  North America\n     ux1.cso.uiuc.edu          128.174.5.59     gopher  North America\n     panda.uiowa.edu           128.255.40.201   panda   North America\n     gopher.msu.edu            35.8.2.61        gopher  North America\n     gopher.ebone.net          192.36.125.2     gopher  Europe\n     info.anu.edu.au           150.203.84.20    info    Australia\n     gopher.chalmers.se        129.16.221.40    gopher  Sweden\n     tolten.puc.cl             146.155.1.16     gopher  South America\n     ecnet.ec                  157.100.45.2     gopher  Ecuador\n     gan.ncc.go.jp             160.190.10.1     gopher  Japan\n\n     It is recommended that you run the client software instead of\n     logging into the public login sites.  A client uses the\n     custom features of the local machine (mouse, scroll bars, etc.)\n     and gives faster response.\n\n---------------------------------------------------------------------\nQ4:  How can I add to the information in gopher?\n\nA4:  You can do this by running a gopher server.  Servers are available\n     for a number of systems.  Use anonymous ftp to\n     boombox.micro.umn.edu (134.84.132.2) and look in /pub/gopher.  The\n     following servers are available there:\n\n       Unix      : /pub/gopher/Unix/gopher+2.0.tar.Z\n       VMS       : /pub/gopher/VMS/\n       Macintosh : /pub/gopher/Mac_server/\n       VM/CMS    : /pub/gopher/Rice_CMS/ or /pub/gopher/Vienna_CMS/\n       MVS       : /pub/gopher/mvs/\n       DOS PC    : /pub/gopher/PC_server/\n\n\n     When you have your server ready you can publish it to the world by\n     sending e-mail to the maintainters of the \"Other gophers\" list.\n     See Q27 for details.\n\n---------------------------------------------------------------------\nQ5:  Who Develops Gopher Software?\n\nA5:  Gopher was originally developed in April 1991 by the University\n     of Minnesota Microcomputer, Workstation, Networks Center to help\n     our campus find answers to their computer questions.\n\n     It has since grown into a full-fledged World Wide Information\n     System used by a large number of sites in the world.\n\n     Many people have contributed to the project, too numerous to\n     count.\n\n     The people behind the much of the gopher software can be reached\n     via e-mail at gopher@boombox.micro.umn.edu, or via paper mail:\n\n      Internet Gopher Developers\n      100 Union St. SE #190\n      Minneapolis, MN 55455  USA\n\n     Or via FAX at:\n\n      +1 (612) 625-6817\n\n---------------------------------------------------------------------\nQ6:  How can I set up a \"CSO\" phone book server?  Where is the software?\n\nA6:  CSO phone book servers are also known as \"qi\" servers.  The\n     software implementation can be gotten via anonymous ftp from\n     uxc.cso.uiuc.edu (128.174.5.50) as /pub/qi.tar.Z.  You may also\n     see this referred to as \"ph\", which is what most of the clients\n     are called.  A collected set of clients for Macs, PCs, VMS, VM,\n     etc, are in the /pub/ph.tar.Z file.\n\n     There is also an archive of the mailing list for qi/ph software on\n     the same machine.  It's in /pub/info-ph.archive. You may join the\n     list by sending email to info-ph-request@uxc.cso.uiuc.edu.\n\n     This software is supported by Paul Pomes <p-pomes@uiuc.edu>\n     Contact him for more information.\n\n-------------------------------------------------------------------\nQ7:  Why can't I access the University of Minnesota's UPI news?\n\nA7:  The University of Minnesota has a site license for UPI news, we\n     are not allowed to distribute it off of our campus.  We get our\n     UPI news from Clarinet.  For more information about getting UPI\n     news send mail to info@clarinet.com.  For information about\n     setting up your own gopher-UPI server search the gopher-news\n     archive for UPI.\n\n-------------------------------------------------------------------\nQ9:  What are the type characters for the different Gopher Objects?\n\nA9:  Normal IDs.\n\n     0       Item is a file\n     1       Item is a directory\n     2       Item is a CSO (qi) phone-book server\n     3       Error\n     4       Item is a BinHexed Macintosh file.\n     5       Item is DOS binary archive of some sort.\n     6       Item is a UNIX uuencoded file.\n     7       Item is an Index-Search server.\n     8       Item points to a text-based telnet session.\n     9       Item is a binary file!  Client must read until the connection\n                 closes.  Beware.\n     T       TN3270 connection.\n\n     Experimental IDs.\n\n     s       Sound type.  Data stream is a mulaw sound.\n     g       GIF type.\n     M       MIME type.  Item contains MIME data.\n     h       html type.\n     I       Image type.\n     i       \"inline\" text type (used by panda).\n\n-------------------------------------------------------------------\nQ10: When I do full-text searches I always get every document back, Why?\n\nA10: This is a problem occasionally encountered with Unix full-text\n     indexes.  It is caused by setting up the link incorrectly to a\n     gindexd port.\n\n     The Path= field should be *blank* when pointing to a gindexd\n     index.\n\n     Otherwise the client will send the path to the gindexd daemon,\n     which interprets everything as a keyword.  This path is\n     likely to contain a pathname that is common to all of the indexed\n     files.  Thus a search generates hits on everything.\n\n     Note that gindexd isn't used much anymore, this question does not\n     apply if you are using the built in indexing in the Unix gopher\n     server.\n\n-------------------------------------------------------------------\nQ11: When I try to build the UNIX software I get an error from make:\n     \"Must be a separator on rules line #. Stop\"  Why?\n\nA11: This is a problem with older makes that don't understand the \"include\"\n     keyword.  One easy way to cope with this problem is compiling GNU\n     make, which does understand the include keyword.\n\n     If this is too difficult, remove the line:\n\n      include Makefile.config\n\n     from all the Makefiles and paste in a copy of Makefile.config at\n     the top of each Makefile.\n\n     Or, instead of pasting you can make the client/server by going\n     into the appropriate directory and typing:\n\n      make -f ../Makefile.config -f Makefile\n\n-------------------------------------------------------------------\nQ12: What is the relationship between Gopher and (WAIS, WWW, ftp)?\n\nA12: Gopher is intimately intertwined with these other systems.\n     As shipped the Unix gopher server has the capability to:\n\n       - Search local WAIS indices.\n       - Query remote WAIS servers and funnel the results to gopher\n         clients.\n       - Query remote ftp sites and funnel the results to gopher\n         clients.\n       - Be queried by WWW (World Wide Web) clients either using\n         built in gopher querying or using native http querying.\n\n-------------------------------------------------------------------\nQ13: Are papers or articles describing Gopher available?\n\nA13: Gopher has a whole chapter devoted to it in :\n\n     _The_Whole_Internet_users_guide_and_catalog by Ed Krol\n     (publisher O'Reilley & Associates, Inc; ISBN: 1-56592-025-2).\n     (Editors note: ...Great book, go out and buy a bunch!)\n\n     _The_Internet_Passport: NorthWestNet's Guide to Our World Online\"\n     By Jonathan Kochmer and NorthWestNet. Published by NorthWestNet,\n     Bellevue, WA. 1993. 516 pp. ISBN 0-9635281-0-6.\n     Contact info: passport@nwnet.net, or (206) 562-3000\n\n     _A_Students_Guide_to_UNIX by Harley Hahn. (publisher McGraw Hill,\n     Inc.; 1993 ISBN 0-07-025511-3)\n\n     _Intelligent_Information_Retrieval:_The_Case_of_Astronomy_and_\n     _Related_Space_Sciences (A. Heck and F. Murtagh, editors). Published\n     by Kluwer Academic Publishers, P.O. box 17, 3300 AA Dordrecht, the\n     Netherlands. ISBN: 0-7923-2295-9\n\n     Other references include:\n\n     _The_Internet_Gopher_, \"ConneXions\", July 1992, Interop.\n\n     _Exploring_Internet_GopherSpace_ \"The Internet Society News\", v1n2 1992,\n\n     (You can subscribe to the Internet Society News by sending e-mail to\n      isoc@nri.reston.va.us)\n\n     _The_Internet_Gopher_Protocol_, Proceedings of the Twenty-Third\n          IETF, CNRI, Section 5.3\n\n     _Internet_Gopher_, Proceedings of Canadian Networking '92\n\n     _The_Internet_Gopher_, INTERNET: Getting Started, SRI\n          International, Section 10.5.5\n\n     _Tools_help_Internet_users_discover_on-line_treasures, Computerworld,\n          July 20, 1992\n\n     _TCP/IP_Network_Administration_, O'Reilly.\n\n      Balakrishan, B. (Oct 1992)\n        \"SPIGopher: Making SPIRES databases accessible through the\n      Gopher protocol\".  SPIRES Fall '92 Workshop, Chapel Hill, North\n      Carolina.\n\n      Tomer, C.  Information Technology Standards for Libraries,\n      _Journal of the American Society for Information Science_,\n      43(8):566-570, Sept 1992.\n\n\n-------------------------------------------------------------------\nQ14: On a DECstation I get the error message \"/etc/svc.conf no such file\n     or directory\" when running the gopherd server, why?\n\nA14: This is caused by the chroot() call in gopherd.  It can be easily\n     fixed by running gopherd with the -c option.\n\n     Alternatively you can copy /etc/svc.conf into a directory named\n     \"etc\" inside the gopher-data directory.\n-------------------------------------------------------------------\nQ15: The boolean searching terms don't work for my full-text index, why?\n\nA15: This is probably because the searching is being provided by WAIS.\n     WAIS opts to return all documents that contain a search phrase\n     within certain limits.  WAIS searches do return the documents with\n     the highest \"score\" at the top, those documents will have the\n     closest relevance.\n\n     Alternatively you could get a booleanized version of wais from\n     ftp.bio.indiana.edu, or get the new freeWAIS.\n\n-------------------------------------------------------------------\nQ16: When linking the Unix gopher server with WAIS I get undefined\n     symbols,\n       such as:\n\n         log_file_name\n         logfile\n         PrintStatus\n         find_value\n         Sources\n         NumSources\n\nA17: This happens if you make gopherd before linking in the WAIS ir/ui\n     directories.  The fix is to \"make clean\" or remove\n     gopherd/{waisgopher.o,Waisindex.o} and then remake gopherd.  Or\n     link the ir/ui directories first.\n-------------------------------------------------------------------\nQ18: Why don't my WAIS indexes work?  I never get anything back for searches.\n     or Why do I get \"Dangling file\" error messages in my logfile?\n\nA18: The problem could be in the server.  The server should be run\n     using the -c option if you want WAIS to work.  Another solution is to\n     patch the WAIS code so that it doesn't check the files on the disk.\n     Search the gopher-news archive for \"dangling\".  This will turn up a\n     single document with the patch.\n\n-------------------------------------------------------------------\nQ19: My gopher server doesn't work under inetd, why?\n\nA19: It could be that your inetd server only supports a limited amount\n     of arguments.  For instance, the maximum number of arguments to an\n     inetd server is 5.  You can get around this by combining arguments: i.e.\n\n       gopherd -I -c\n\n     becomes:\n\n       gopherd -Ic\n\n     You may also leave the port specifier off of the command line.\n     The gopher server automagically finds out the port it's running on.\n\n-------------------------------------------------------------------\nQ20: This is not a bug report, just a curiousity. I managed to install\n     gopher on my PC, more or less by myself, which is a pretty good\n     accomplishment, for someone who hasn't installed hardly anything on a\n     PC. I then proceeded to load my PC/TCP kernel, ETHDRV, and try to\n     start up gopher. It said it couldn't initialize that stack(?). I have\n     to load this whenever I use PC/TCP. Incredibly, when I did not load\n     ETHDRV, Gopher came up immediately and telneted to our local server.\n     How does it know what kernel to load?\n\nA20 Dr. Science says,\n\n     The Internet Gopher program is not actually computer program at\n     all, but a collection of magical incantations handed down from Dark\n     Age conjurors.  It works by sending magical \"demons\" through the air,\n     which scour the world for information, and then return to cast\n     illusions containing the answer.\n\n     When you use the Gopher, your computer isn't actually doing\n     anything at all.  Instead, these demons have mesmerized you with an\n     evil magical spell, which was invoked by the pattern of\n     finger-movements peculiar to the typing of the letters G-O-P-H-E-R on\n     your keyboard.  This spell transmits demonic information directly to\n     your brain.\n\n     Scientists aren't certain of the long-term effects of demonic\n     mesmirization, although former presidents have suffered only minor\n     medical side-effects from it.  Indeed, since Magic and Science are\n     usually opposed to each other, most Scientists are usually\n     close-minded about such issues, and will usually respond with some\n     vacuous non-answer about \"packet drivers\", \"stacks\", and other such\n     jargon.\n\n     Unlike conventional scientists, Dr. Science is very open-minded and\n     is willing to deal with such issues in a frank and honest manner.\n     This is why people come to him with questions, and why they've learned\n     to rely on and live by his answers.\n\n     Dr. Science\n         \"I'm not a real doctor;  I have a Master's Degree....  in SCIENCE!\"\n\n:-) :-) :-) :-)\nThere's always room for a little humor in a FAQ..\n-------------------------------------------------------------------\nQ21: Help!  I have PC-NFS and want to use the PC-Gopher client.  How?\n\nA21: Use a piece of software called PKTMUX, available at fine ftp\n     sites everywhere.  This will let you use any packet driver\n     application.\n\n     Or, aquire a client that supports PC-NFS.  See Q2.\n-------------------------------------------------------------------\nQ22: How do I nuke a hung TCP connection?  I can't restart my UNIX\n     gopher server unless I get rid of it, and I don't want to reboot!\n\nA22:\n\nHere is an example of using dbx to change a socket from CLOSING to\nCLOSED.\n\n # netstat -A|grep CLOSING\n c4bc5100 tcp        0     11  mymachine.gopher 129.89.8.4.70  CLOSING\n # dbx -k /vmunix /dev/mem\n ...\n (dbx) 0xc4bc5100+8/1X                  -- display contents of PCB+8\n c4bc5108:   00000007\n (dbx) assign 0xc4bc5108=0              -- zero it\n 0\n (dbx) q\n\nAfter a minute or two, the CLOSED socket should disappear.\n-------------------------------------------------------------------\nQ23: Is there somewhere I can retrieve a list of announced gopher\n     links?  I'd like to keep a local, up-to-date list of available gopher\n     holes without requiring our users to gopher to umn just to scan\n     GopherSpace.\n\nA23: In the Unix client/server distribution is a perl script called\n     \"gopherdist\". Gopherdist can fetch the contents of any point in\n     GopherSpace.\n\n     To dump the contents of all the North American links from\n     gopher.tc.umn.edu do the following:\n\n     % gopherdist gopher.tc.umn.edu 70 \"1/Other Gopher and Information\n       Servers/North America\" > .Links\n-------------------------------------------------------------------\nQ24: Why doesn't my unix gopher client display ISO-Latin-1 characters\n     properly?  BTW I'm using a Sun workstation..\n\nA24: It is the client's problem, the server is perfectly 8-bit transparent.\n     The BSD curses library uses bit 8 in order to remember, whether a\n     character has been displayed reverse. So use just /usr/5bin/cc and\n     you get the System V curses version which is 8 bit clean.\n\n     Note that this may be a problem under other versions of UNIX too...\n\n-------------------------------------------------------------------\nQ25: What is veronica?\n\nA25: veronica:  Very Easy Rodent-Oriented Net-wide Index to\n     Computerized Archives.\n\n     veronica offers a keyword search of most gopher-server menu titles\n     in the entire gopher web.  As archie is to ftp archives, veronica\n     is to gopherspace.  A veronica search produces a menu of gopher\n     items, each of which is a direct pointer to a gopher data source.\n     Because veronica is accessed through a gopher client, it is easy\n     to use, and gives access to all types of data supported by the\n     gopher protocol.\n\n     To try veronica, select it from the \"Other Gophers\" menu on\n     Minnesota's gopher server, or point your gopher at:\n\n     Name=veronica (search menu items in most of GopherSpace)\n     Type=1\n     Port=70\n     Path=1/veronica\n     Host=futique.scs.unr.edu\n\n------------------------------------------------------------------\nQ26: What e-mail discussions lists are active for Gopher?\n\nA26: There are a couple of places where Gopher software and\n     development is discussed.\n\n     The USENET newsgroup comp.infosystems.gopher is the biggest\n     discussion list.\n\n     Gopher discussion also takes place on the mailing list\n     gopher-news.  To subscribe send a message to:\n\n       gopher-news-request@boombox.micro.umn.edu\n\n\n     A mailing list for VMS developers is also available, send e-mail\n     to listserv@trln.lib.unc.edu with a message that contains\n\n        sub VMSgopher-L firstname lastname\n\n     A mailing list for MVS gopher developers and users is also\n     available.  To subscribe to the list, send mail to\n     LISTSERVER@LISTS.ACS.OHIO-STATE.EDU containing:\n\n         SUBSCRIBE MVSGOPHER firstname lastname\n\n\n------------------------------------------------------------------\nQ27: How do I get my Gopher (whois/cso/library catalog) listed in gopher menus?\n\nA27: If your gopher server is in Europe, send mail to:\n\n        gopher@ebone.net\n\n     Otherwise send mail to:\n\n        gopher@boombox.micro.umn.edu\n\n     with the following information:\n\n       The Server's Name (as it will appear on the menu)\n       The Hostname\n       The Port Number\n       An Administrative contact\n       A Selector String (optional)\n\n\n     The list of CSO nameservers is maintained at Notre Dame by Joel Cooper.\n     Any updates to the list should be sent to cooper@utopia.cc.nd.edu.\n\n     The list of WHOIS servers is maintained at MIT by Matt Power.  Any\n     updates to the list should be sent to mhpower@athena.mit.edu.\n\n     The Gopher to X.500 gateway is maintained  at U. Michigan by Tim Howes.\n     Any comments should be sent to tim@umich.edu.\n\n     The list of Internet Accessible Libraries is is currently a\n     collaborative effort between Marie-Christine Mahe at Yale\n     University, Lou Rosenfeld at the University of Michigan, and\n     Billy Barron at the University of Texas in Dallas.  Barry Bouwsma\n     steadily contributes many obscure foreign library listings.\n\n     Error corrections and additions are always welcome, and should be\n     sent to:\n\n       GOPHLIB@GOPHER.YALE.EDU.\n\n------------------------------------------------------------------\nQ28: Where is the registered list of gopher+ view types?\n\nA28: It's available via anonymous ftp from\n\n        isi.edu\n\n      in the directory\n\n        /in-notes/mime\n\n\n--\n | Paul Lindner | lindner@boombox.micro.umn.edu   | Slipping into madness\n |              | Computer & Information Services | is good for the sake\n | Gophermaster | University of Minnesota         | of comparison.\n///// / / /    /////// / / / /  /  /  /   /      //// / / / /  /  /  /   /\n\n\n./ ADD NAME=MVSFAQ\nMVS Gopher Frequently Asked Questions List\n\nJanuary 16, 1994\n\nThis list addresses common questions and problems about the MVS\nGopher client and server.  I hope to update this list and repost\nit to MVSGOPHER on a regular basis, time permitting.\n\nNote that some items describe restrictions or misfeatures that\nclearly ought to be rectified.  Rest assured that there is a\n\"wish list\" and these will be included in future releases, but\nonly as time permits.\n\nThanks to those too numerous to name individually for helping me\nto come up with answers to problems with the installation of MVS\nGopher on various systems.\n\nPlease feel free to submit additional questions (and answers) to me\nfor inclusion or correction.\n\n        - Steve Bacher (Batchman)       <seb@draper.com>\n        - Draper Laboratory\n\n----------------------------------------------------------------------\n\nSummary of Changes:\n\n 04 Aug 1993 - added question Q-0\n               updated email addresses\n               public distribution clarified\n 04 Aug 1993 - FAL changed to HAL\n 10 Aug 1993 - V2R2 is on boombox now\n               Added note about MTF and C/370 V1\n 13 Aug 1993 - Another FTP site\n               More info about the MVSGOPHER list itself\n 17 Aug 1993 - Answer to KILL -38 question\n               Removed specific reference to VM LISTSERV\n 31 Dec 1993 - Updated for V3\n 16 Jan 1994 - new email address for Shawn Hart; no longer prerelease\n\n----------------------------------------------------------------------\n\nSummary of Questions:\n\nQ-0: Why the MVSGOPHER mailing list?\nQ-1: What is Gopher?\nQ-2: Where can I get the MVS Gopher?\nQ-3: How do I get software from SERVICE@USCMVSA?\nQ-4. What do I need to run the MVS Gopher?\nQ-5. Do I need XPROC?  Where can I get it?\nQ-6. Who wrote the MVS Gopher?\nQ-7. Do I have to pay for MVS Gopher?  Who owns it?\nQ-8. Can I use REXX in MVS Gopher?\nQ-9. What is this multitasking problem?\nQ-10. Won't Gopher chew up a lot of CPU resources?\nQ-11. What do I have to do to TCP/IP to use the Gopher client?\nQ-12. What do I have to do to TCP/IP to use the Gopher server?\nQ-13. How do I connect to a different server from the MVS client?\nQ-14. Why can't I run more than one MVS TCP/IP client from TSO?\nQ-15. Where can I get XTELNET?\nQ-16. How do I specify that the MVS Gopher client should use XTELNET?\nQ-17. I get PANEL NOT FOUND errors after using the MVS Gopher.\nQ-18. I get garbage on my screen when Gopher can't open my EXTRACT file.\nQ-19. When I try to run the MVS Gopher Server, I get gethostname errors.\nQ-20. I can't access the \"About This Gopher\" item of the MVS server.\nQ-21. How do I stop the server?\nQ-22. I can't compile Gopher because...\nQ-23. I can't linkedit Gopher because...\nQ-24. I can't run the Gopher server because...\nQ-25. I can't run the Gopher client because...\nQ-26. I can't run the Gopher server or client because...\nQ-27. I get an 0C1 ABEND when I try to run the server/client\nQ-28. I can't figure out how to define the main Gopher menu to the server.\nQ-29. Why doesn't the Gopher client honor my additional parameters,\nQ-30. Why can't I attention out of the Gopher client?\nQ-31. Why do I have to \"S\" (select) an item before I can \"E\" (extract) it?\nQ-32. Where's the tutorial?\nQ-33. What's the deal with the \"w\" type?\nQ-34. How can I debug a Gopher server REXX exec?\nQ-35. What hostname and port hacks?\nQ-36. What MVS file types does the Gopher server support?\nQ-37: How can I display square brackets while viewing text?\nQ-38: How can I make the client start up at a specific bookmark file?\nQ-39: Can I set up client items that do anything my users would want?\n\n----------------------------------------------------------------------\n\nQ-0: Why the MVSGOPHER mailing list?\n\nA. It's much harder to get a USENET newsgroup started than a private\nmailing list.  The procedure for creating a new newsgroup is\nconsiderably more formal and involves lots of voting.\n\nIt's true that we could use comp.infosystems.gopher or IBMTCP-L, but\nboth of those have plenty of traffic as it is, and there are issues\npertaining to MVS Gopher that would bore the other readers.\n\nIt is possible to gateway mailing lists to newsgroups locally.\n\nList servers offer the following options that the user can control\nvia email. One may choose to have mail delivered...\n(1) as usual - that is, as mail is sent to the list it is resent\n    to you; this seems to be what you object to\n(2) you may receive a digest - daily, weekly, monthly, your choice -\n    where all mail distributed is sent to you as a package\n(3) opt NOT to receive email and instead persuse the distributed mail\n    at your convenience using special commands  sent to the server\n    by email; you can opt to read only new mail (since a certain date),\n    only mail about certain topics, from certain people, whatever you\n    choose;\n\nShould a newsgroup be set up, a list server will also allow all email\nsent to it to automatically be posted to the newsgroup.\n\nSo, if you're not already on the list, you can join by sending a\nmessage with \"SUBSCRIBE MVSGOPHER yourfirstname yourlastname\" to\nLISTSERVER@LISTS.ACS.OHIO-STATE.EDU.\n\n----------------------------------------------------------------------\n\nQ-1: What is Gopher?\n\nA. Gopher is a distributed information delivery service.  That sounds\nquite boring, which is why people prefer the name \"gopher\".  The\noriginal Gopher came out of the University of Minnesota and ran\non Unix machines.  Subsequently it has been ported to virtually\nevery known architecture, both clients and servers.  Thus, a Gopher\nclient on MVS can access data being served by any other kind of\nmachine, and a Gopher server on MVS can allow clients on any\nplatform to read mainframe data.\n\nIf you really want to know all about Gopher, read the Gopher FAQ\nposting on the comp.infosystems.gopher newsgroup.  This FAQ, and\nthe mailing list that owns it, are for Gopher on MVS only.\n\n----------------------------------------------------------------------\n\nQ-2: Where can I get the MVS Gopher?\n\nA. The MVS Gopher client and server is available via anonymous FTP from:\n\n boombox.micro.umn.edu          /pub/gopher/mvs\n ftp.mic.ucla.edu               /pub/mvs/gopher\n info2.rus.uni-stuttgart.de     /pub/comm/infosystems/gopher/mvs\n\nLatest MVS Gopher on boombox.micro.umn.edu:       Version 2 Release 2\nLatest MVS Gopher on ftp.mic.ucla.edu:            Version 3 Release 1\nLatest MVS Gopher on info2.rus.uni-stuttgart.de:  Version 2 Release 2\n\nAlthough the entire Gopher package is included in the single giant\nJCL stream that the distribution consists of, you don't have to\ninstall it all.  You can install just the server or just the client\nif that's all you're interested in.  The README file for the latest\nversion/release explains how to FTP the distributions.\n\nYou also have the choice of getting either the C language source or the\nprecompiled object code.  Also, the UCLA site has more up-to-date\nreleases, including beta releases.  The boombox version is frequently a\nrelease or two behind, since it is intended to be the \"reliable\" version.\n\n----------------------------------------------------------------------\n\nQ-3: How do I get software from SERVICE@USCMVSA?\n\nA. You can't.  This service was discontinued on August 31, 1993.\nUse the FTP site at ftp.mic.ucla.edu instead.  For more information,\ncontact Leonard Woren <ldw@usc.edu>.\n\n----------------------------------------------------------------------\n\nQ-4. What do I need to run the MVS Gopher?\n\nA. C/370 Version 2 (SAS/C support is not currently available but\nis under development)\n\n Note:  C/370 Version 1 may be OK for the client, but the server\n definitely needs C370 version 2.\n\nIBM TCP/IP or Interlink SNS/TCPaccess\n\nISPF V2R2 or higher.  V3 for best results, otherwise you\nmay be forced to do a lot of hand-hacking of the panels.\n\nTSO/E V2 or higher to use the REXX interface.  Some of the new\ncapabilities in the MVS Gopher V3 REXX interface require REXX 3.46,\nwhich is available with TSO/E V2.3.1.\n\nIf you don't have any C compiler, you can get the object code\ndistribution (see answer to above question).  However, in that\ncase, you must have the IBM C/370 runtime library installed,\nsince the object code was compiled with C/370 Version 2.\nAlso, you must be running IBM TCP/IP (HAL) V2 and ISPF V3.\n\n----------------------------------------------------------------------\n\nQ-5. Do I need XPROC?  Where can I get it?\n\nA. Until recently, you needed XPROC if you wanted to be able to\n   pass parameters to the GOPHER client TSO command (REXX exec).\n   Now, there is some REXX parsing code that can simulate the\n   TSO parameter extraction.  But you're still better off using\n   XPROC if you want truly robust parsing.\n\n   XPROC is available from ftp.mic.ucla.edu (the same as one of\n   the Gopher source sites, if you're sharp-eyed), in directory\n   /pub/mvs/util. It's in the TSOREXX distribution, which also\n   includes the XWRITENR utility (which emulates TSO CLIST\n   WRITENR for REXX execs).\n\n----------------------------------------------------------------------\n\nQ-6. Who wrote the MVS Gopher?\n\nA. The MVS Gopher Server was originally by Shawn Hart at the\n   University of Delaware.  Subsequently, Steve Bacher made\n   enhancements to it, and also wrote the client.  Shawn Hart\n   is currently at shart@indial1.io.com.\n\n   Various enhancements and customizations to both the client and\n   the server have been contributed by:\n\n    Lou Joseph     <cwmy5c@irishmvs.cc.nd.edu>\n    Denis DeLaRoca <csp1dwd@mvs.oac.ucla.edu>\n    Dwight Cook    <sysdc@uokmvsa.backbone.uoknor.edu>\n    Rachna Agrawal <rachna@clemson.clemson.edu>\n\n----------------------------------------------------------------------\n\nQ-7. Do I have to pay for MVS Gopher?  Who owns it?\n\nA. MVS Gopher is distributed publicly for free, but is not in\n   the public domain.\n\n   Here is the standard disclaimer:\n\n Copyright (c) The Charles Stark Draper Laboratory, Inc.,1992,1993,1994\n\n MVS Gopher Server originally by Shawn Hart (Univ. of Delaware).\n\n This software is provided on an \"AS IS\" basis.  All warranties,\n including the implied warranties of merchantability and fitness,\n are expressly denied.\n\n Provided this copyright notice is included, this software may\n be freely distributed and not offered for sale.\n\n Changes or modifications may be made and used only by the maker\n of same, and not further distributed.  Such modifications should\n be mailed to the author for consideration for addition to the\n software and incorporation in subsequent releases.\n\n----------------------------------------------------------------------\n\nQ-8. Can I use REXX in MVS Gopher?\n\nA. The server has a REXX interface:  you can define menu items\n   which fire up REXX execs in the server's address space.\n   However, beware of the multitasking problem.\n\n   MVS Gopher V3 has a completely reworked interface which\n   solves the \"multitasking problem\" by allowing REXX execs\n   to run outside of a TSO environment.  However, TSO/E 2.3.1\n   is required for this (see Q-4).\n\n   Also, the client is driven by a REXX exec as a TSO command.\n\n----------------------------------------------------------------------\n\nQ-9. What is this multitasking problem?\n\nA. Due to TSO/E architectural limitations, a Gopher server that runs\n   REXX execs in a TSO environment must be single-threading.  However,\n   you can run more than one Gopher server at a time, so this is not a\n   show-stopper.  You can run a multithreading Gopher server that\n   services only files, and a singlethreading Gopher server that\n   services files and REXX exec services.  You simply set up different\n   GGPARMS files - one says \"MTFTASKS 1\" and the other says \"MTFTASKS 8\"\n   or whatever number you want.  They must also have differing port\n   numbers (e.g. one at port 70 and one at port 1570).\n\n   MVS APAR OY20253 addresses multitasking problems with TSO services.\n   For TSO/Extensions V2R3, just to take one instance, PTFs UY35936 and\n   UY35937 address these, but have a long PE chain against them.\n   Upgrading TSO/E from V2R3 to V2R4 might help resolve these, but\n   you're still stuck with the basic design of TSO, which is definitely\n   not friendly to concurrency.  Take ddnames (please).  Dynamic\n   allocation that uses preset ddnames is clearly not going to work\n   well in a concurrent TSO environment.\n\n   The most obvious difficulty used to be that the Gopher-REXX\n   interface requires that REXX execs write to SYSTSPRT.  Clearly more\n   than one can't do this at the same time.  This has changed in MVS\n   Gopher V3, which has a completely new REXX interface.  This solves\n   the \"multitasking problem\" by allowing REXX execs to run without a\n   TSO environment.  Note that TSO/E 2.3.1 is required for this (see\n   Q-4).  Also, if you want to write REXX execs that use TSO services\n   or call programs that require specific ddnames, you are still stuck\n   with the need to run them under a single-threading Gopher server.\n\n----------------------------------------------------------------------\n\nQ-10. Won't Gopher chew up a lot of CPU resources?\n\nA. The client won't, because it's just an ISPF dialog program\n   that makes a lot of short, brief network connections.  If you're\n   still running V1, though, you will use up a lot of CPU in the ISPF\n   browse interface, which was totally rewritten in V2.\n\n   The server does somewhat more work, but (unlike the CMS gopher\n   server, which is written in REXX), it's written in C, so it's\n   reasonably fast.  However, if you write REXX execs to serve some\n   Gopher items, they will obviously chew up CPU resources, depending\n   on what they do.\n\n   If you want to get an idea of usage, start with the gopher server\n   log, which you can see as part of the regular output of the gopher\n   server (e.g. via SDSF).  Also, if you have enabled them, you can use\n   the write-to-programmer messages issued by the Gopher server, which\n   are compatible with the UMn-format messages (I don't believe that\n   the look and feel of these messages has been patented yet).\n\n----------------------------------------------------------------------\n\nQ-11. What do I have to do to TCP/IP to use the Gopher client?\n\nA. No special action is required for the client.  However, if\n   your users are likely to run more than one TCP/IP client\n   socket application from the same TSO session, then make sure\n   that you have the \"IUCVMULT\" PTF for IBM's HAL.  See Q-14.\n\n----------------------------------------------------------------------\n\nQ-12. What do I have to do to TCP/IP to use the Gopher server?\n\nA. For IBM (HAL) TCP/IP...\n\n   The following is from the installation instructions for the server:\n\n   Add the name of the Gopher server started task (the name as it\n   appears in SYS1.PROCLIB, not necessarily \"GOPHER\") to the MVS TCPIP\n   profile data set (or have your MVS TCP/IP system programmer do it).\n   In the examples below, let's say you've called it GOPHSRV.  Add this\n   in 2 places:\n\n   (a) under AUTOLOG, so that TCP/IP will start the Gopher server\n       automatically (a la inetd for unix) when a client connects.\n       Just add the name to the list (e.g. GOPHSRV).\n\n   (b) under PORT, so nobody can spoof the Gopher port.  The format\n       here is:   70 TCP GOPHSRV\n\n   Repeat both for whatever number of Gopher server started tasks you\n   create (with different port numbers).\n\n   For Interlink SNS/TCP...\n\n   By permission of the author:\n\n   posted to IBMTCP-L on 27 May 1993 by Lou Joseph\n   <CWMY5C%IRISHMVS.CC.ND.EDU@uicvm.uic.edu>\n\n   I have looked further and found another place where\n   the hostname is given.  I think that this one is more likely to be used\n   by gethostname().  It is in member DNRALCnn in SNSTCP.V110.PARM.  Here is\n   a copy of our DNRALC01:\n\n   ACSS      IRISHMVS.CC.ND.EDU. OUR SNS/TCP SUBSYSTEM NAME\n   LOOPBACK  127.0.0.1           SNS/TCP LOCAL HOST NAME\n   LOCALHOST 127.0.0.1           SNS/TCP LOCAL HOST NAME\n\n   ACSS is the SNS/TCPaccess Subsystem Name.  Note that there is a period\n   after the EDU in the first line.\n\n   Lou\n\n   Lou Joseph                             CWMY5C@IRISHMVS.BITNET\n   Office of University Computing         Louis.Joseph.2@ND.EDU\n   University of Notre Dame\n   Room G005 CCMB\n   Notre Dame, IN 46556                   (219) 631-7055\n\n----------------------------------------------------------------------\n\nQ-13. How do I connect to a different server from the MVS client?\n\nA. Use the syntax GOPHER SERVER(other.server.host).  You should have\n   XPROC available for your GOPHER command to parse this in the most\n   reliable fashion (see Q-5).\n\n   You can also connect to another server by modifying your GOPHERRC\n   data set (or specifying an alternate one with the INITFILE keyword,\n   new in Gopher V3).  Your default GOPHERRC file will have a section\n   in it that looks something like this:\n\n   Initial:\n\n   Type=DIRECTORY\n   Name=Primary (Root) Gopher Menu\n   Path=\n   Host=mvs.draper.com\n   Port=70\n   End\n\n   Just remove that section (or comment it out by sticking \"#\" characters\n   in front of the lines) and Gopher will prompt you for a server name.\n   Or else you can replace the value of the Host= line with the server\n   you want to connect to.  For example, change\n\n   Host=mvs.draper.com\n\n   to\n\n   Host=testhost.elsewhere.com\n\n----------------------------------------------------------------------\n\nQ-14. Why can't I run more than one MVS TCP/IP client from TSO?\n\nA. (sigh) Do you really want to know?\n\n  IBM TCP/IP for MVS has had difficulties in managing more than one\n  active client application per MVS/TSO address space.\n\n  There were several parts to this problem:\n\n  (1) Applications that use C language sockets cannot coexist with\n      each other\n\n  (2) Applications that use C language sockets cannot coexist with\n      applications that use the Pascal-based interface\n\n  (3) Applications that use the Pascal-based interface cannot\n      coexist with each other\n\n  As a consequence of (2) and (3), if an application using the\n  Pascal-based interface is active, no other client application,\n  either Pascal-based or socket-based, can be active in the same\n  MVS address space.\n\n  In TCP/IP for MVS Version 2 Release 1,\n  IBM has partially solved (1), but has not solved (2) or (3).\n\n  The solution involved creating a new module called IUCVMULT which would\n  be loaded into the environment to track IUCV identifications within an\n  address space.  IUCVMULT is a serially reusable module, so that there\n  is one shared copy per address space.  Since IUCVMULT is loaded by the\n  first call to a C socket routine, the first C socket application in the\n  address space must hang around, which is potentially disastrous.\n\n  This solution has several weaknesses:\n\n          * The aforementioned requirement that IUCVMULT must be loaded\n            in such a way as to allow all clients to see the same copy.\n\n          * It does not address the problem of non-socket applications.\n\n          * The requirement for the first socket application to remain\n            active as long as the user needs to run any socket clients\n            carries the potential for disaster.  It means that a user\n            cannot start application X, then start application Y, then\n            terminate application X without crashing application Y.\n            It also requires the user to remember which application\n            was brought in \"first\", when in the ideal world the user\n            should not even have to know if a given application is a\n            TCP/IP client or not.\n\n          * In a multiple-job-step-TCB environment (e.g. IMS), or a\n            multi-session vendor product like TSC's PIE MultiTSO, which\n            creates multiple job step TCB's with separate job pack areas,\n            it is possible to have TCP/IP socket applications under\n            different sessions at the same time with distinct copies\n            of IUCVMULT.  This produces disastrous results, as it\n            has been known to cause the TCP/IP address space to crash.\n\n  IBM shipped PTF UN13465 for APAR PL83602.  Results showed that we were\n  able to run our C socket application, fire up FTP while it was active,\n  and not crash the socket application.  However, firing up a second FTP\n  in this environment caused an ABEND.\n\n  One way to get around this, once you have the IUCVMULT fix, is\n  to use Denis DeLaRoca's XTELNET instead of TELNET.\n\n----------------------------------------------------------------------\n\nQ-15. Where can I get XTELNET?\n\nA. From ftp.mic.ucla.edu, directory /pub/mvs/xtelnet.\n\n----------------------------------------------------------------------\n\nQ-16. How do I specify that the MVS Gopher client should use XTELNET?\n\nA. If you have V2R2, you can put the following line in your\n   GOPHERRC file:\n\n   Telnet: XTELNET\n\n   If you want to make this change for everyone, then you must install\n   the Gopher client in such a way as to insure that all GOPHERRC\n   files are built in the correct way.  There is code in the GOPHER\n   exec that sets the value of the TELNET command, as well as a few\n   other things.  Use that to establish XTELNET as a default.\n\n----------------------------------------------------------------------\n\nQ-17. I get PANEL NOT FOUND errors after using the MVS Gopher.\n\nA. You're using ISPF LIBDEF.  LIBDEF is broken because it blows away\n   previously set LIBDEFs.  LIBDEF should be used only for testing\n   ISPF applications, not production.  Copy the ISPF panels and\n   the GGCLIENT load module into production libraries - i.e. the\n   ones all TSO users get at logon time - and ditch LIBDEF.  For\n   more information, try contacting the SHARE ISPF project to hear\n   their whole sad story.\n\n----------------------------------------------------------------------\n\nQ-18. I get garbage on my screen when Gopher can't open my EXTRACT file.\n\nA: The problem is that CBIPO, at least up through 92A, ships a\n   broken C/370 runtime -- they installed all the FMIDs, so you get\n   execution error messages in Kanji.  perror() calls to stderr are\n   what are affected.\n\n   In other words, you have FMID JCLB212 installed instead of JDL1214,\n   JCLB212 is the Kanji messages feature.  JDL1214 is the messages for\n   the Common Library.  For C without PL/1, apparently you weren't\n   supposed to install a separate FMID for messages at all.\n\n   Solution 1:  Install JDL1214 and hope it clobbers the other one!\n                (But it won't.)\n   Solution 2:  Uninstall JCLB212.\n   Solution 3:  Order C/370 from IBM and start over from scratch.\n\n   Neither of the above has been tried by anyone, to my knowledge.\n\n   Also see Q-22.\n\n----------------------------------------------------------------------\n\nQ-19. When I try to run the MVS Gopher Server, I get gethostname errors.\n\nA. Thanks to Mike Porter at the University of Delaware for this reply,\n   posted to IBMTCP-L on 27 May 1993.\n\nOne problem we've been seeing with 'gopher' and 'gethostname'\nreally has nothing to do with either.  Its just that this is\nthe most common socket application our users run.  (finger\ndoesn't work either - for instance, nor will any socket call.)\n\nI spent some time tracking down the problem, but got lost in the\nplatform support code.  What seems to happen is a control block\nthat is created once per session gets left around when an address\nspace terminates.  All future attempts to do an IUCV_set will fail\nuntil an IPL occurs.\n\nThis is sort of like the old 'can't run two tcp/ip applications\nfrom the same address space', but not exactly.  The old problem\nwould clear up when the user would log off, but in this case,\napparently MVS needs to be ipled.  Perhaps the resource manager is\nnot cleaning up like it should?\n\nOne way to see if this is the problem is to run MVPXDISP (its in\nSEZALINK, and needs to be authorized, so add it to the auth. cmd\nlist and update the tso parms.  And no, it won't run in batch).\n\nThis is the output received for a user that can't run gopher:\n\nMVPMVP656I MVPXDISP: VMCF: Pending count=1 Flags=40000000.\nMVPMVP655I MVPXDISP: IUCV: Connections=1, Max=255.\nMVPMVP662I MVPXDISP: IUCV: Ctl flags=00000000 Appl flags=00000000.\nMVPMVP650I MVPXDISP: User MIS0175  Asid 00A5.                   *****\nMVPMVP651I MVPXDISP: Data @ 0302A5C0 Sm=00 Cr0=000000E3 Flags=38.\nMVPMVP652I MVPXDISP: Client of the VMCF address space.\nMVPMVP652I MVPXDISP: Client of IUCV.\nMVPMVP653I MVPXDISP:  IUCV mask=F8F8, Pending Ctl=0000, Appl=0820.\nMVPMVP654I MVPXDISP: VMCF: Buf=002E9030, Len=00000118, Flgs=00 User=\n                     Key=80.\n\nA talk with level 1 yields a solution of 'use another userid' or\n'ipl' (stopping and restarting the tcpip address space doesn't\nhelp since the data appears to be associated with the subsystem).\n\nA: Here's something for SNS/TCP users with gethostname problems:\n\n From:    Lou Joseph <CWMY5C%IRISHMVS.CC.ND.EDU@uicvm.uic.edu>\n Subject: Re: gethostname under MVS\n\n There is a configuration member in SNSTCP.V110.SAMP named ACPCONFG.  It\n has to be customized, assembled and linked into SNSTCP.V110.LOAD.\n There is a MACRO ACFHOST in ACFCONFG with keywords MEMBER and DOMAIN.\n We have MEMBER=IRISHMVS and DOMAIN=CC.ND.EDU.\n\n That's the only place I could find where the local host name is set.\n\n Lou\n\n---\n\n(In the old days I used to require that you stick the host name into\nthe source code somewhere, but that kind of went away when I realized\nthat gethostname() would do it.  So I don't remember where or how I\nwould insert the host name now. - seb)\n\n----------------------------------------------------------------------\n\nQ-20. I can't access the \"About This Gopher\" item of the MVS server.\n\nA. This is because of a limitation that has been fixed in V2R3 of\n   MVS Gopher.  In the distributed installation instructions, it\n   suggets that the \"About This Gopher\" PDS is to be referenced in\n   the menu as PATH=DD:GGABOUT(ABOUT).  This is what's in the\n   sample server JCL.\n\n   However, if you do this, then the subentries of this menu\n   won't work, because they use the PATH=(MEMBER) feature, which\n   didn't work when the current PDS was specified using the DD:\n   format.  V2R3 allows this.  But in the meantime, read the\n   note in the installation instructions that says to change\n   the menu entry from PATH=DD:GGABOUT(ABOUT) to\n   PATH=DATA.SET.NAME(ABOUT), where DATA.SET.NAME is the name\n   of your \"ABOUT\" PDS.\n\n----------------------------------------------------------------------\n\nQ-21. How do I stop the server?\n\n   The MVS Gopher server, being a plain C program, doesn't understand\n   operator \"STOP\" commands.  Just use the operator \"CANCEL\" command\n   from the console.  For example, if you installed it as GOPHSRV in\n   'SYS1.PROCLIB' you would start it via:\n\n    START GOPHSRV     or    S GOPHSRV\n\n   and you would stop it by\n\n    CANCEL GOPHSRV    or    C GOPHSRV\n\n   It'll come down with a system 222 ABEND, which looks ugly, but is\n   really quite harmless.\n\n----------------------------------------------------------------------\n\nQ-22. I can't compile Gopher because...\n\nQ. It says it can't find the header file \"time.h\".\n\nA: Leonard Woren had this problem with C/370 1.1 and then again with\n   V2.  The problem is that C/370 is shipped with TIME as a MAC, which\n   collides with the MVS TIME macro when C/370 is installed in the same\n   zone as MVS.  The CBIPO build ignores the error message about this,\n   and ships a non-usable C/370.  There's a PTF which adds EDCMTIME\n   with an MALIAS of TIME to fix this problem.  The PTF for HCCM202 is\n   UN12293.  Note that spc.h has the same problem, which is fixed by\n   UN17425 (EDCMSPC).  Also note that CBIPO, at least up through 92A,\n   ships a broken C/370 runtime -- they installed all the FMIDs, so you\n   get execution error messages in Kanji.  See Q-18.\n\n----------------------------------------------------------------------\n\nQ-23. I can't linkedit Gopher because...\n\nQ. I get TABLE OVERFLOW ... TOO MANY EXTERNAL SYMBOLS IN ESD\n\nA. The SYSLIB should point to 'TCPIP.COMMTXT' or 'TCPIP.SEZACMTX'\n   depending on the level of TCP/IP.  If you're pointing it at\n   'TCPIP.COMMMAC' or 'TCPIP.SEZACMAC', then of course your link\n   is going to lose big.\n\nQ. it says that ATEXIT is multiply defined\n\nA. Under certain circumstances, people get a linkage editor warning\n   when they build Gopher, saying that ATEXIT is multiply defined.  It\n   is because the C/370 MTF (multitasking) library has a different\n   atexit() from the normal C library.  Make sure that the linkedit of\n   load module GGSTASK has the INCLUDE SYSLIB(EDCMTFS) control\n   statement, and that the linkedit of load module GGSERVER (or\n   GGSERVE, in Gopher V3) does *not* have an INCLUDE SYSLIB(EDCMTFS)\n   control statement.\n\nQ. it can't find FCNTL or MTF or mtf.h\n\nA. You can't use C/370 V1 with the server.  Get C/370 V2 or stick\n   with the client only.  If you stick with the client and your\n   problem is that include file mtf.h is not found, then you'll\n   have to remove that line from header file GG before continuing.\n\n----------------------------------------------------------------------\n\nQ-24. I can't run the Gopher server because...\n\nQ. it gets an 0Cx abend\n\nA. Did you just install TCP/IP 2.2.1 and forget to relink your Gopher\n   with the 2.2.1 TCP/IP routines?\n\nQ. it gets \"The GIVESOCKET timed out\"\n\nA. Not sure, but this went away for some users when they\n   upgraded their TCP/IP...\n\nQ. I get: TCPIP severed IUCV path. Reason 'KILL -38 '\n\nA. Chuck Sechler <TS0258@ohstmvsa.acs.ohio-state.edu> says:\n   We get this every time we shut down the system.  When we shut down,\n   we do not CANCEL GOPHER, but we stop TCPIP.  I always assumed that\n   this severed a connection with GOPHER, which led to the KILL -38\n   message.  This also leads to an ABEND for GOPHER of A03, which seems\n   plausible.\n\nQ. the subtasks get weird abends\n\nA. Make sure that you're not running REXX exec requests from a\n   server that runs under s TSO environment and is multithreading\n   (MTFTASKS > 1).  See Q-8.\n\nQ. I get EINVAL errors on GIVESOCKET and/or ABENDA03\n\nA. Perhaps you are running SIMTCPIP from SIMWARE, which relinks\n   the entire Gopher module?  In effect, this is running TCPIP 2.1\n   with a Gopher that has TCPIP 2.2 stuff linked in.\n\nQ. I get gethostname() failures\n\nA. See Q-19.  If that doesn't apply, make sure you've got the\n   latest MVS Gopher, because I've fixed a lot of bugs in this.\n   One user had been linking their Gopher with the wrong copy of\n   CMMVSYS, which defines the IBM TCP/IP address space name!\n\nQ. I'm getting 001 ABENDS on the SYSTSPRT file.\n\nA. You need to debug your REXX execs (see Q-34).  You could be\n   allocating not enough space in your server JCL to hold a lot\n   of output, or there could be trash being spewed out by your\n   REXX exec.\n\n   Actually, this whole problem will go away if you get MVS Gopher V3,\n   which has a whole new REXX interface.  But you'll have to stop\n   writing to SYSTSPRT.\n\nQ. I get \"Unknown host MVS.DRAPER.COM\"\n\nA. You need to configure the server.  You can do this by specifying\n   \"DOMAIN my.actual.site\" in the GGPARMS startup file in the server.\n   If you have the source code distribution, you can also accomplish\n   this by changing the value of the MY_DOMAIN_SUFFIX preprocessor\n   variable in the GGUSER header file.\n\n----------------------------------------------------------------------\n\nQ-25. I can't run the Gopher client because...\n\nQ. I get \"The parallel load module was not found.  Could not set up\n   the TCP environment.\"\n\nA. You need C/370 V2 and you must make sure that you linkedit the\n   server with the \"INCLUDE SYSLIB(EDCMTFS)\" line.\n\nQ. I get \"Unknown host MVS.DRAPER.COM\"\n\nA. You need to configure the client.  You can do this by modifying\n   the GOPHERRC file (or modifying the code in the GOPHER exec that\n   creates the GOPHERRC file for new users), or, if you have the\n   source code distribution, by changing the value of the\n   MY_DOMAIN_SUFFIX preprocessor variable in the GGUSER header file.\n\nQ. I get \"Unknown host FOO.MYDOMAIN.NAME\"\n\nA. You need to talk to whoever maintains your MVS TCP/IP site and\n   ask about host tables and domain name servers.  Tell them that\n   MVS socket applications are not recognizing hostnames with the\n   local domain name included when they do gethostname() calls,\n   and gethostbyname() is not working when the domain name is\n   included.  If that doesn't help, try changing the value of the\n   APPEND_DOMAIN_NAME_TO_SELF preprocessor variable in the GGUSER\n   header file - but this may cause other servers to become\n   impossible to reach.\n\n----------------------------------------------------------------------\n\nQ-26. I can't run the Gopher server or client because...\n\nQ. It won't let me see files that I'm sure I've put in the\n   ACCESS file.  Or other random garbage.  Or not seeing CR/LF's.\n\nA. There could be a problem with ASCII-EBCDIC translation.\n   Or you could be communicating with a VM/CMS Gopher that has problems\n   talking to MVS because of problems with the ASCII/EBCDIC translation\n   at their end.  For example, CMS Gopher prior to version 2.4.  If so,\n   make sure that the site in question gets a new CMS gopher from\n   troth@ricevm1.rice.edu.\n\n   If you want to tweak your own translation, ask Doron Shikmoni\n   <P85025@BARILVM.BITNET> about usermods to the TCP/IP translate tables.\n\n   Also keep in mind that with MVS Gopher V3, you must stop and\n   restart your Gopher server whenever you make a change to the\n   access file.  And, since the access file is processed quite\n   differently from the way it was in V2, you should reread the\n   description of the access rule processing and make sure that\n   you understand what it is doing.\n\n----------------------------------------------------------------------\n\nQ-27. I get an 0C1 ABEND when I try to run the server/client\n   right after I linkedited it.\n\nA. Possibilities:\n\n   Could be you don't have the C runtime library present in the system\n   link list or STEPLIB.  This could apply to C/370 or SAS/C.  For the\n   client, you can do this via ISPLLIB or LIBDEF (but see Q-17).  For\n   the server, you can use STEPLIB.  But the best answer is to pester\n   your MVS systems programmer to put the C runtimes in linklist.\n\n----------------------------------------------------------------------\n\nQ-28. I can't figure out how to define the main Gopher menu to the server.\n\nA. In the Gopher server JCL, there's a DD statement for DDname\n   GGGOPHER.  This has to point to a sequential data set (or a member\n   of a PDS) containing an MVS Gopher menu.  You could also specify the\n   main menu (again in the MVS Gopher menu format) as instream (DD *)\n   data - if you were running the Gopher server from a batch job, which\n   you would do only for testing.\n\n----------------------------------------------------------------------\n\nQ-29. Why doesn't the Gopher client honor my additional parameters,\n   like when I type SERVER(blah)?\n\nA. Did you set up your GOPHER exec to use a different ISPF APPLID?\n   There is a misfeature in Gopher V1 and V2 that results from\n   the use of the ISPF profile pool to pass values from the GOPHER\n   command to the client load module.  Gopher V3 finally solved this\n   problem by using an in-storage temporary ISPF table to pass the\n   values around.\n\n   To get around this in V2, stop using the APPLID, or use an APPLID of\n   ISR.  Or always invoke GOPHER from inside ISPF, rather than typing\n   the command from READY mode.\n\n----------------------------------------------------------------------\n\nQ-30. Why can't I attention out of the Gopher client?\n\nA. Because IBM C/370 is broken.  There is a zap for the IBMBLIIA\n   load module that will at least let you attention out of the\n   C/370 Gopher client.  It won't allow you to abort a single\n   connection/transfer, though.  This didn't happen when we were\n   all writing applications in 370 assembler language...\n\n   Here's the zap for C/370 V2...\n\n   NAME IBMBLIIA IBMBLII1\n   VER 2250 0A60\n   REP 2250 1BFF\n\n   Usual disclaimers apply.\n\n   Note:  If your edition of IBMBLIIA doesn't match, then look for\n   the 0A60 (SVC 96, STAX) macro invocation that gets passed a\n   nonzero register 1 value, and zap it as above.\n\n----------------------------------------------------------------------\n\nQ-31. Why do I have to \"S\" (select) an item before I can \"E\" (extract) it?\n\nA. This was fixed in V2R3, which should be out by the\n   time you've caught up with all your real work and get around to\n   reading this FAQ in your spare time.\n\n----------------------------------------------------------------------\n\nQ-32. Where's the tutorial?\n\nA. What tutorial? :-)\n\n   Use the \"About This Gopher\" item to find out about using\n   the Gopher client.  OK, this isn't much of an answer, but\n   isn't Gopher a much more pleasant way to read stuff than\n   ISPF tutorial panels?  Also, there's a TSO HELP member.\n\n----------------------------------------------------------------------\n\nQ-33. What's the deal with the \"w\" type?\n\nA. The \"w\" (WHOIS) type was put in to handle WHOIS-type\n   applications, which are like type 7 (index) except that\n   they return a file instead of a directory.  This type was\n   proposed early on and implemented in the UMn Unix Gopher\n   via a patch, but nowhere else.  Even the implementations\n   of \"w\" in UMn and the MVS Gopher didn't agree with each other.\n   The \"w\" type died out of lack of interest and the general\n   belief that gopher+ would handle the same needs.  Well,\n   gopher+ is still a ways away for the MVS gopher...\n\n   Keener eyes among you will claim to notice gopher+ support\n   in the V3 MVS gopher.  It's only the groundwork for possible\n   future support.  No promises.  Let me just say that if a\n   gopher+ client talks to the MVS Gopher server, it might get\n   a little more than the V2 Gopher server would have given it.\n\n----------------------------------------------------------------------\n\nQ-34. How can I debug a Gopher server REXX exec?\n\nA. It ain't easy.  The easiest thing is just to run the exec from\n   TSO and see what it does, after allocating file SYSTSPRT to\n   the terminal (or wherever).  Remember, in V2, your exec must be\n   writing to SYSTSPRT to return data to the Gopher server.\n   But in V3 your exec uses a different means of returning data.\n   You must be sure to include the REXX library with all the\n   gopher-related execs if you try to test it out at your terminal.\n   Best thing is to allocate this same library to SYSEXEC.  At least\n   with V3, if anything bad happens, it will try to write to the real\n   terminal in foreground, and to the file SYSTSPRT in background.\n   And since SYSTSPRT will not be swallowed up by Gopher, you might\n   actually be able to view it if you include an appropriate DD\n   statement in your proc.  But don't do that unless you're running\n   the single-tasking server, please.\n\n   At least the Gopher server log displays return codes from IRXEXEC.\n   Return codes from IRXEXEC are documented in the TSO/E REXX\n   Reference.  Error codes in the range 20000-20099 indicate\n   that the REXX interpreter detected a syntax error.  The return\n   code is 20000 plus the error (presumably the Cowlishaw error number).\n\n   Another possibility is to run the exec from your MVS Gopher client\n   in \"local\" (serverless) mode.  Allocate your Gopher REXX exec\n   library to dd GGEXEC (or use the specification in the GOPHERRC file)\n   and specify HOST=- to fire it up.  If you are using V2 or earlier,\n   make sure that the hacks used to specify the hostname and port are\n   appropriate (i.e. they return \"-\" and \"70\").\n\n----------------------------------------------------------------------\n\nQ-35. What hostname and port hacks?\n\nA. Er, see the \"About this Gopher\" PDS for details.  I confess\n   that the REXX stuff was complicated and difficult to handle.\n   But with V3, it has been redesigned (incompatibly) to make it\n   somewhat easier, if still complicated.  In any case, you can\n   use the sample TSOHELP application as a starting point.\n\n----------------------------------------------------------------------\n\nQ-36. What MVS file types does the Gopher server support?\n\nA. The Gopher server can serve MVS sequential data sets and\n   PDS members.  It will also serve PDS's, treating them as\n   Gopher directories of members - but this is of limited use,\n   as it will display merely the 8-character member names as\n   Gopher files.\n\n   In addition, the Gopher server recognizes exec:foo as a\n   call to a REXX exec called foo, and ftp0: and ftp1: as\n   invocations of a Gopher-to-FTP gateway (ftp0 to get a\n   remote file, ftp1 to get a remote directory).\n\n   With V3, Gopher also supports other file types, including\n   binary data.  This is mainly useful for the FTP gateway,\n   though it does not support compressed files.  Also, the MVS\n   client can obviously do very little with binary or graphical\n   or sound files.  The feature will prove highly beneficial for\n   clients on other machines that talk to the MVS server.  I have\n   even pulled down a newer version of the Macintosh TurboGopher\n   client through the MVS gopher ftp gateway.\n\n   Gopher will not support other MVS file types directly, but\n   you can code a REXX exec to access such files (e.g. VSAM\n   data sets or DB2 data bases).\n\n----------------------------------------------------------------------\n\nQ-37: How can I display square brackets while viewing text?\n\nA: By issuing the following command once in ISPF:\n\nFor a 3179:\n\n TERM CHAR((X'BA' X'AD') (X'BB' X'BD') (X'AD' X'BA') (X'BD' X'BB'))\n\nFor a 3278 or 3180:\n\n TERM CHAR((X'41' X'AD') (X'42' X'BD') (X'AD' X'41') (X'BD' X'42'))\n\nIf what you're seeing instead of brackets are vowels with diaeresis\nmarks on them, then you are in TN3270, on a 7171, or using a terminal\ntype of \"APL\" - otherwise the brackets would be being translated to\nsomething incorrect.  So you've got half the job done, since the code\npoints are right.  The other half is to issue that TERMINAL command.\nYou can't do it from READY because as soon as ISPF starts up, it will\ntrash any VTAM character translations you did before.\n\nIf, on the other hand, you're seeing dots, or whatever the \"DISP\"\ncharacter is set to, then you need a fix to ISPF.  You can get the\npackage that implements the fix by ftp from ftp.mic.ucla.edu, directory\n/pub/mvs/util, item BRACKETS.\n\n----------------------------------------------------------------------\n\nQ-38: How can I make the client start up at a specific bookmark file?\n\nA: Just changing the GOPHERRC file to point to the bookmark dataset\n   that has the right menu won't work too well, unless you specify the\n   LOCAL option when you start up gopher.  But you don't want to do\n   this - I will explain.\n\nAlso, changing the gopher exec is the wrong thing to do.  You should\nbe able to change only the gopherrc file and still have it do what you\nwant it to do.\n\nDid you set localmenu in the read_gopherrc routine?  If you didn't,\nthen it gets cleared before gopherrc is read.  I tried this, setting\nlocalmenu in the read_gopherrc routine, and it works for me.  This is\nnot the right approach, though.  And there is another problem.\nSpecifying LOCAL means that your gopher cannot make any network\nconnections, which is not going to make it very useful.\n\nBookmark support is fairly new, and I do not yet have a good way of\nhaving your gopherrc file set you up easily to reference a particular\nbookmark.  This will take some additional documentation or fixing of\nthe code.  Meanwhile, here is what to do:\n\nIn the gopherrc file, when it is first created, you will see a section\nthat says\n\ninitial:\n#\nType=DIRECTORY\nName=primary (root) gopher menu (or something like that)\nPath=\nHost=mvs.localdomainname.com\nPort=70\nEnd\n\nChange the above so that Name= reads whatever you want the title to\ndisplay, Path= contains the fully qualified (but without single quotes)\nname of your bookmark file, and (most important to remember this)\nHost=- (hyphen).  If you do not change the host=, then you will get an\nerror from the gopher server, who will complain that it is not\nauthorized to deliver the contents of that directory to your doorstep.\nHost=- insures that the operation on that menu alone is \"local\" - do\nnot specify the LOCAL operand on your gopher invocation.\n\n----------------------------------------------------------------------\n\nQ-39: Can I set up client items that do anything my users would want?\n\nA: Well, er, you're not supposed to, but - yeah, you can.\n   Using a combination of HOST=- (local-mode menu items), private menus\n   (bookmarks or gopherrc file hacking) and the EXEC:rexxexecname path\n   syntax, you can set up a private gopher that lets you do anything\n   you want.  Read the \"Using Gopher on MVS\" stuff in \"About This Gopher\",\n   as well as the HELP file (operand LOCAL).\n\n./ ENDUP\n?!\n//CLIST    EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='CLIST'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=GCALL\n/* REXX.  Usage: call gcall \"MODULE\", \"parameter list\"\n *        Replaces TSO \"CALL\" command.\n *        Module must be in linklist or steplib.\n */\n\nparse arg gmodule, gparam\n\nlinklen = d2c(length(gparam),2)\nlinkparm = linklen || gparam\n\naddress LINKPGM gmodule \"LINKPARM\"\nreturn rc\n\n./ ADD NAME=GCLOSE\n/* REXX.  Usage:  call gclose\n * Note: we cannot use DD SYSTSPRT in a multitasking environment,\n * so do not invoke this function with a null parameter unless\n * you have no choice.\n */\n\nparse arg gopherargs\n\nfile_to_close = gfile(gopherargs) /* defined below */\n\n/* The old way, which required that the caller not queue null lines\n * queue \"\"\n * \"EXECIO * DISKW\" file_to_close \"(FINIS)\"\n */\n\nif queued() = 0 then queue \" \"\n\"EXECIO\" queued() \"DISKW\" file_to_close \"(FINIS)\"\niorc = rc\n\n\"delstack\"\n\nif iorc <> 0 then do\n call gnotify ,\n     \"GGMVS003 EXECIO return code\" iorc \"in GCLOSE of\" file_to_close\nend\n\nreturn\n\ngfile: parse arg gopherargs\n\n parse var gopherargs \"OUTDD=\" outdd \";\"\n if outdd = \"\" then outdd = \"SYSTSPRT\"\n return outdd\n\n./ ADD NAME=GHOST\nghost: parse arg gopherargs\n\n /* Although it should not be necessary with the new MVS Gopher,\n  * configure the default host name to match your site.\n  */\n\n parse var gopherargs \"HOST=\" host \";\"\n if host = \"\" then return \"MVS.DRAPER.COM\"\n return host\n\n./ ADD NAME=GNOTIFY\n/* REXX.  Usage:  call gnotify \"GGMVSnnn\" message-text */\n\ngnotify: parse arg message\ncall gcall \"XGWTO\", message\nreturn\n\n./ ADD NAME=GOPEN\n/* REXX.  Usage:  call gopen */\n\n\"newstack\"\n\nreturn\n\n./ ADD NAME=GOPHER\n/* REXX. GOPHER client.  Author: Steve Bacher <seb@draper.com>, with\n *       additions by Dwight Cook <SYSDC@uokmvsa.backbone.uoknor.edu>\n */\n\n/* *** Customize the following lines for your installation.\n * If ggmpanel is set to \"\", it will not be LIBDEF'd.\n */\n\nggmprefix        = \"GOPHER\"\nggmpanelsuffix   = \"PANELS\"\nggmloadsuffix    = \"LOAD\"\nggmlmod          = \"GGCLIENT\"\nggmpanel         = ggmprefix\".\"ggmpanelsuffix\nggmload          = ggmprefix\".\"ggmloadsuffix\nggmappl          = \"ISR\"\nggmdefaulthost   = \"micro.umn.edu\" /* initialize GOPHERRC with this  */\nggmdefaulttelnet = \"TELNET\"\nggmdefaultbkmgr  = \"BOOKMGR\"\nggmdefaultdomain = \".DRAPER.COM\"\ngophermeister    = \"\"              /* TSOid of Gopher's Big Brother  */\nxprocavailable   = 0               /* set to 1 if XPROC is available */\ncrunlibs         = \"\"              /* if C run-time must be LIBDEF'd */\n\ntrace off\nsignal on novalue\nstacked   = 0\nlibdeffed = 0\nparse arg args\n\"ISPQRY\"\nif rc > 0 then do\n parse source . . execname . execds .\n if execds = \"?\" then\n  icmd = \"%\"execname args\n else\n  icmd = \"EX '\"execds\"(\"execname\")'\" quote(args)\n call startispf ggmappl, icmd\n exit\nend\n\nif xprocavailable then do\n\n save_prompt = prompt(\"ON\")\n \"XPROC 0 TEST DEBUG FORCE LOCAL BOOKMARK() INITFILE()\n          SERVER() PORT() PATH() DESCRIPTION()\"\n if rc <> 0 then exit rc\n call prompt save_prompt\n\nend\n\nelse do /* XPROC not available */\n\n bookmark = \"\"\n initfile = \"\"\n server = \"\"\n port = 70\n path  =\n description =\n local =\n force =\n test  =\n debug =\n uargs = translate(args)\n if wordpos(\"LOCAL\",uargs) > 0 then local = \"LOCAL\"\n if wordpos(\"FORCE\",uargs) > 0 then force = \"FORCE\"\n if wordpos(\"TEST\" ,uargs) > 0 then test  = \"TEST\"\n if wordpos(\"DEBUG\",uargs) > 0 then debug = \"DEBUG\"\n\n /* Limited-function parsing courtesy Dwight Cook */\n\n bookopen = 'BOOKMARK('\n initopen = 'INITFILE('\n servopen = 'SERVER('\n pathopen = 'PATH('\n portopen = 'PORT('\n descopen = 'DESCRIPTION('\n closparn = ')'\n parse var uargs (bookopen) bookmark    (closparn)\n parse var uargs (initopen) initfile    (closparn)\n parse var uargs (servopen) server      (closparn)\n parse var uargs (pathopen) path        (closparn)\n parse var uargs (portopen) port        (closparn)\n parse var uargs (descopen) description (closparn)\n if port = \"\" then port = 70\n\nend\n\nsignal on failure\nsignal on halt\n\ncall check_for_other_socket_app\ncall read_gopherrc\ncall validate_operands\ncall libdef\ncall let_me_know\ncall ggm_dialog\ncall unlibdef\n\ncleanup:\nif libdeffed then call unlibdef\nif stacked then \"DELSTACK\"\nexit\nerror:failure:halt:say \"GOPHER: Severe lossage.\"\nsay \"Statement:\" sourceline(sigl)\nexit\n\n/*********************************************************************/\n\nvalidate_operands:\n\n/*\n * Logic that determines what to display on startup:\n * If gopherrc file does not exist, create it from default\n * (default has everything commented out except for a\n *  one-item \"initial\" menu pointing to the MVS server)\n * Read gopherrc (in case operands need fields therein)\n * Command operands override gopherrc specs:\n * if LOCAL given then server = \"-\", see below for SERVER(-)\n * if SERVER(host) given then startup host=SERVER, path=PATH, etc.\n *  (no gopherrc referenced)\n * if SERVER(-) given then either PATH must be given or\n *  the gopherrc's localmenu: must be given,\n *  otherwise look at gopherrc\n *   if LOCAL given and initial: present then extract startup menu\n *    but remember that there will be no server access possible\n *   else nothing given, this is an error, barf\n * if no SERVER, look at gopherrc:\n *   if initial: given then extract startup menu from there\n *   else if localmenu: given then use that menu (SERVER=-)\n *   else nothing given, display ISPF panel asking for host/path\n */\n\nif local = \"LOCAL\" then do\n if server <> \"\" then do\n  say \"GOPHER: SERVER cannot be specified when LOCAL is specified.\"\n  exit 12\n end\n server = \"-\"\nend\n\nif bookmark <> \"\" then do\n if server <> \"\" & local = \"\" then do\n  say \"GOPHER: SERVER cannot be specified when BOOKMARK is specified.\"\n  exit 12\n end\n if path <> \"\" then do\n  say \"GOPHER: PATH cannot be specified when BOOKMARK is specified.\"\n  exit 12\n end\n server = \"-\"\n if left(bookmark,1) = \"'\" then path = strip(bookmark,\"B\",\"'\")\n else do\n  tsoprefix = sysvar(\"SYSPREF\")\n  if tsoprefix = \"\" then path = bookmark\n  else path = tsoprefix\".\"bookmark\n end\n if description = \"\" then description = \"Bookmark\" path\nend\n\nggpath = \"\"\ngghost = \"\"\nggport = port\nggdesc = description\n\nif server <> \"\" then do\n if server = \"-\" then do\n  gghost = server\n  if path <> \"\" then do\n   ggpath = path\n  end\n  else if localmenu <> \"\" then do\n   ggpath = localmenu\n   if ggdesc = \"\" then ggdesc = \"Local Private Gopher Menu\"\n  end\n  else if local = \"LOCAL\" & initial <> \"\" then do\n   gghost = \"\"\n   call use_initial_spec\n   if gghost <> \"-\" then do\n    say \"Gopher: Cannot determine path for local access.\"\n    say \"        Either specify PATH(pathname), activate\"\n    say \"        the localmenu: line in\" gopherrc \", or set\"\n    say \"        the initial: line in\" gopherrc \"for local access.\"\n    exit 12\n   end\n  end\n  else do\n   say \"Gopher: Cannot determine path for local access.\"\n   say \"        Either specify PATH(pathname) or activate\"\n   say \"        the localmenu: or initial: line in \"gopherrc\".\"\n   exit 12\n  end\n end\n else do\n  gghost = server\n  ggpath = path\n  ggdesc = description\n  ggport = port\n  nop  /* use provided server, host, path, etc. */\n end\nend\nelse do       /* no server given on command */\n if localmenu <> \"\" then do\n  gghost = \"-\"\n  ggpath = localmenu\n  if ggdesc = \"\" then ggdesc = \"Local Private Gopher Menu\"\n end\n else if initial <> \"\" then do\n  call use_initial_spec\n end\n else do\n  /* this is nominally illegal, but should cause gopher to\n     display the hackish startup menu */\n  gghost = \"\"\n  ggpath = \"\"\n end\nend\n\nif telnet = \"\" then ggtelnet = ggmdefaulttelnet\nelse ggtelnet = telnet\n\nif bookmgr = \"\" then ggbkmgr = ggmdefaultbkmgr\nelse ggbkmgr = bookmgr\n\nif domain = \"\" then ggdomain = ggmdefaultdomain\nelse ggdomain = domain\n\nreturn\n\n/*********************************************************************/\n\nuse_initial_spec:\n\n if initial = \"*temp*\" then do\n  /* we're eventually not going to do it this way really */\n  /* initial_type is ignored - only \"DIRECTORY\" is valid anyway */\n  if initial_name <> \"\" & ggdesc = \"\" then ggdesc = initial_name\n  if initial_host <> \"\" & gghost = \"\" then gghost = initial_host\n  if initial_path <> \"\" & ggpath = \"\" then ggpath = initial_path\n  if initial_port <> \"\" & ggport = \"\" then ggport = initial_port\n end\n else do\n  ggpath = initial\n  if ggdesc = \"\" then ggdesc = \"Local Private Gopher Menu\"\n end\n\nreturn\n\n/*********************************************************************/\n\nread_gopherrc:\n\nlocalmenu = \"\"\nlocalexec = \"\"\ntelnet    = \"\"\nbookmgr   = \"\"\ndomain    = \"\"\ninitial   = \"\"\ninitial_type = \"\"\ninitial_name = \"\"\ninitial_host = \"\"\ninitial_path = \"\"\ninitial_port = \"\"\nnew_gopherrc = 0\nif initfile = \"\" then gopherrc = \"'\"userid()\".GOPHERRC'\"\nelse gopherrc = initfile\ngopherrc = \"'\"userid()\".GOPHERRC'\"\ngopherdcb = \"RECFM(V B) LRECL(255) BLKSIZE(6233) DSORG(PS)\"\ngopherrc_status = sysdsn(gopherrc)\nselect\n when gopherrc_status = \"OK\" then nop\n when gopherrc_status = \"DATASET NOT FOUND\" then do\n  address TSO \"ALLOC DA(\"gopherrc\") T SP(1 1)\" gopherdcb\n  if rc <> 0 then do\n   say \"Error: Cannot create\" gopherrc\n   exit rc\n  end\n  new_gopherrc = 1\n end\n otherwise do\n  say \"Error: Cannot access\" gopherrc\":\" gopherrc_status\n  exit 16\n end\nend\n\naddress TSO \"ALLOC FI(GOPHERRC) DA(\"gopherrc\") OLD REU\"\nif rc <> 0 then exit rc\n\nif new_gopherrc = 0 then do\n \"EXECIO * DISKR GOPHERRC (FINIS STEM GOPHERRC.)\"\n execiorc = rc\n if execiorc <> 0 then do\n  say \"Error: Cannot read\" gopherrc\n  address TSO \"FREE FI(GOPHERRC)\"\n  exit execiorc\n end\n if gopherrc.0 = 0 then new_gopherrc = 1\nend\n\nif new_gopherrc then call initialize_gopherrc\n\naddress TSO \"FREE FI(GOPHERRC)\"\n\ncollecting_initial = 0\ndo i = 1 to gopherrc.0\n gline = gopherrc.i\n if gline = \"\" then iterate\n if left(gline,1) = '#' then iterate\n parse var gline ghead \":\" gtext\n ghead = translate(strip(ghead,\"B\"))\n gtext = strip(gtext,\"B\")\n if collecting_initial then do\n  parse var gline ghead \"=\" gtext\n  ghead = translate(strip(ghead,\"B\"))\n  gtext = strip(gtext,\"B\")\n  select\n   when ghead = \"TYPE\" then initial_type = gtext\n   when ghead = \"NAME\" then initial_name = gtext\n   when ghead = \"PATH\" then initial_path = gtext\n   when ghead = \"HOST\" then initial_host = gtext\n   when ghead = \"PORT\" then initial_port = gtext\n   when ghead = \"END\"  then do\n    collecting_initial = 0\n    initial = \"*temp*\"\n   end\n   otherwise do\n    say \"Error in \"gopherrc\": INITIAL: not terminated by END\"\n    say \"Line where error was detected:\"\n    say gline\n    exit 8\n   end\n  end\n end\n else select\n  when ghead = \"LOCALMENU\"   then localmenu = gtext\n  when ghead = \"LOCALEXEC\"   then localexec = gtext\n  when ghead = \"TELNET\"      then telnet    = gtext\n  when ghead = \"BOOKMGR\"     then bookmgr   = gtext\n  when ghead = \"DOMAIN\"      then domain    = gtext\n  when ghead = \"INITIAL\"     then do\n   if gtext = \"\" then collecting_initial = 1\n   else initial = gtext\n  end\n  otherwise do\n   say \"Warning, gopherrc field ignored:\" ghead\n  end\n end\nend\n\nreturn\n\n/*********************************************************************/\n\nggm_dialog:\n\ntbputvars = \"GGHOST GGPORT GGPATH GGDESC GGDOMAIN GGTELNET GGBKMGR\"\n\naddress ISPEXEC \"TBCREATE GOPHERVT NAMES(\"tbputvars\") NOWRITE REPLACE\"\nif rc > 4 then do; call ispf_error rc; exit rc; end\naddress ISPEXEC \"TBADD GOPHERVT\"\nif rc > 8 then do; call ispf_error rc; exit rc; end\n\nparm = \"\"\nif test  = \"TEST\"  then parm = parm \"-t\"\nif debug = \"DEBUG\" then parm = parm \"-d\"\nif local = \"LOCAL\" then parm = parm \"-l\"\nif gghost <> \"\"    then parm = parm \"-q\"\n\nzerrmsg = \"\"\nzerrsm  = \"\"\nzerrlm  = \"\"\n\naddress ISPEXEC \"VPUT (ZERRMSG ZERRSM ZERRLM)\"\n\nif ggmappl = \"\" then applsource = \"\"\nelse applsource = \"NEWAPPL(\"ggmappl\") PASSLIB\"\n\nif ggmload = \"\" then selstring = \"PGM(\"ggmlmod\") PARM(\"parm\")\"\nelse selstring = \"CMD(CALL '\"ggmload\"(\"ggmlmod\")'\" quote(parm)\")\"\n\naddress ISPEXEC \"SELECT\" applsource selstring\n\nif rc <> 0 then say \"Return code from\" ggmlmod \"program is\" rc\n\n/* Table was supposed to be closed in the program, but just in case */\n\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\naddress ISPEXEC \"TBCLOSE GOPHERVT\"  /* don't bother checking rc */\n\naddress ISPEXEC \"VGET (ZERRSM ZERRLM)\"\nif zerrsm <> \"\" then do\n say zerrmsg\":\" zerrsm\n say zerrlm\nend\n\nreturn\n\n/*********************************************************************/\n\nlibdef:\nif crunlibs <> \"\" then do\n address ISPEXEC \"LIBDEF ISPLLIB DATASET ID(\"crunlibs\")\"\n if rc <> 0 then do; call ispf_error rc; exit rc; end\nend\nif ggmpanel <> \"\" then do\n address ISPEXEC \"LIBDEF ISPPLIB DATASET ID('\"ggmpanel\"')\"\n if rc <> 0 then do; call ispf_error rc; exit rc; end\nend\nif localexec <> \"\" then do\n address TSO \"ALLOC FI(GGEXEC) SHR REU DA('\"localexec\"')\"\n if rc <> 0 then exit rc\nend\nlibdeffed = 1\nreturn\n\n/*********************************************************************/\n\nunlibdef:\nif localexec <> \"\" then do\n address TSO \"FREE FI(GGEXEC)\"\nend\nif ggmpanel <> \"\" then do\n address ISPEXEC \"LIBDEF ISPPLIB DATASET\"\n if rc <> 0 then call ispf_error rc\nend\nif crunlibs <> \"\" then do\n address ISPEXEC \"LIBDEF ISPLLIB DATASET\"\n if rc <> 0 then call ispf_error rc\nend\nlibdeffed = 0\nreturn\n\n/*********************************************************************/\n\ninitialize_gopherrc:\n\n say \"Initializing new GOPHERRC file \"gopherrc\"...\"\n do i = sigl while sourceline(i) <> \"_BEGIN_\"\n end\n gx = 0\n do i = i+1 by 1\n  gline = sourceline(i)\n  if gline = \"_END_\" then leave\n  gpos = pos(\"ggmdefaulthost\",gline)\n  if gpos > 0 then gline = substr(gline,1,gpos-1) || ggmdefaulthost\n  gpos = pos(\"ggmdefaulttelnet\",gline)\n  if gpos > 0 then gline = substr(gline,1,gpos-1) || ggmdefaulttelnet\n  gpos = pos(\"ggmdefaultbkmgr\",gline)\n  if gpos > 0 then gline = substr(gline,1,gpos-1) || ggmdefaultbkmgr\n  gpos = pos(\"ggmdefaultdomain\",gline)\n  if gpos > 0 then gline = substr(gline,1,gpos-1) || ggmdefaultdomain\n  gx = gx + 1\n  gopherrc.gx = gline\n end\n gopherrc.0 = gx\n \"EXECIO * DISKW GOPHERRC (FINIS STEM GOPHERRC.)\"\n say \"New GOPHERRC file initialized.\"\n\nreturn\n\n/*\n\n_BEGIN_\n#\n#\n# Default \"gopherrc\" file, created by the MVS Gopher client.\n#\n# Uncomment desired fields by removing the initial \"# \" from them.\n#\n# Beware - the Gopher client may update this file with bookmarks.\n#          You can delete it at any time and it will be recreated\n#          from the default settings, but you'll lose your bookmarks.\n#\n######################################################################\n#\n# If you want local (serverless) gopher access, then use the following\n# lines, specifying full qualified (no quotes) data set names:\n#\n# localmenu: name_of_initial_gopher_menu\n# localexec: name_of_pds_of_rexx_execs\n#\n# Specifying localmenu: is equivalent to specifying an initial: section\n# with host set to \"-\" and path set to the value of localmenu.\n#\n# You cannot use your own REXX execs, however, unless you specify\n# localexec: as above.  You don't need one to use the other, though.\n#\n######################################################################\n#\n# The following is used by the Gopher client at startup to determine\n# how the initial menu will appear.\n#\n# You may want to change the host to the one appropriate for your site.\n#\ninitial:\n#\nType=DIRECTORY\nName=Primary (Root) Gopher Menu\nPath=\nHost=ggmdefaulthost\nPort=70\nEnd\n#\n# Alternatively, if you want your own private Gopher data:\n#\n# initial:\n#\n# Type=0\n# Name=My Own Private Gopherhole\n# Path=userid.GOPHER.MENU\n# Host=-\n# End\n#\n# In which case you should create a data set called userid.GOPHER.MENU\n# (or whatever name you choose that appears in the \"Path=\" line above)\n# that looks like this.  (NOT in the gopherrc file!)\n#\n#\n# gopher_menu\n#\n# TYPE=DIRECTORY\n# NAME=Public GOPHER Server at ggmdefaulthost\n# PATH=\n# HOST=ggmdefaulthost\n# END\n#\n# TYPE=DIRECTORY\n# NAME=Private GOPHER\n# PATH=userid.ANOTHER.GOPHER.MENU\n# HOST=-\n# END\n#\n# and then you need yet another menu, similar in format to this one,\n# in userid.ANOTHER.GOPHER.MENU.  Get the idea?\n#\n######################################################################\n#\n# These fields are used by the Gopher client to set defaults.\n#\nTelnet: ggmdefaulttelnet\nBookmgr: ggmdefaultbkmgr\nDomain: ggmdefaultdomain\n#\n######################################################################\n_END_\n\n*/\n\n/*********************************************************************/\n\ncheck_for_other_socket_app:\n\n if local = \"LOCAL\" then return\n\n call nnmfiucv      /* FIND IUCVMULT in another PIE MultiTSO session */\n\n if result = 0 then return\n\n say,\n \"A TCP/IP socket application appears active in another PIE session.\"\n if force = \"FORCE\" then do\n  say \"Proceeding anyhow, because you said FORCE.\"\n  return\n end\n say \"To proceed at this point would be potentially disastrous.\"\n say \"If you want to use GOPHER anyway, use one of these operands:\"\n say \"  FORCE  -  if I'm mistaken and it's really safe to make a\"\n say \"            TCP/IP connection.\"\n say \"  LOCAL  -  if you just want local (serverless) access.\"\n say \"Terminating.\"\n\nexit 16\n\n/*********************************************************************/\n\nispf_error: parse arg ispfrc\n\nsay \"GOPHER: ISPF dialog service error detected on line\" sigl\nsay sourceline(sigl)\nsay\nsay zerrmsg\":\" zerrsm\nsay zerrlm\nsay\nsay \"Return code =\" ispfrc\nsay\n\nreturn ispfrc\n\n/*********************************************************************/\n\n/*\n * The following function starts ISPF from READY mode.\n * Beware:  splitting the screen starts up an identical copy of the\n *          application, which may not be desirable.\n */\n\nstartispf: parse arg startappl, startcmd\nif startappl = \"\" then,\n \"ISPSTART CMD(\"startcmd\")\"\nelse,\n \"ISPSTART NEWAPPL(\"startappl\") CMD(\"startcmd\")\"\nreturn\n\n/* The following function implements Big Brother mode. */\n\nlet_me_know:\nif gophermeister = \"\" | gophermeister = userid() then return\nparse source . . execname . execds .\ncall outtrap \"X.\"\naddress TSO,\n \"SEND\" quote(execds\"(\"execname\")\" date(\"U\") time()\" \"),\n        \"U(\"gophermeister\") LOGON\"\ncall outtrap \"OFF\"\nreturn\n\n/* The following function enquotes a string. */\n\nquote: parse arg string\nix = 1\ndo forever\n ix = pos(\"'\",string,ix)\n if ix = 0 then return \"'\"string\"'\"\n string = insert(\"'\",string,ix)\n ix=ix+2\nend\n\n./ ADD NAME=GPORT\ngport: parse arg gopherargs\n\n /* Although it should not be necessary with the new MVS Gopher,\n  * configure the default port number to match your site.\n  */\n\n parse var gopherargs \"PORT=\" port \";\"\n if port = \"\" then return \"1570\"\n return port\n\n./ ADD NAME=GRAB\n/* GRAB: Gopher REXX Allocator in Batch\n *       Usage: ddname = grab(dsname,disp{,ddname})\n */\ntrace off\nsignal on novalue\n\nparse arg dsname, disp, ddname\ndsname = strip(dsname,\"B\")\ndisp   = strip(disp  ,\"B\")\nddname = strip(ddname,\"B\")\nmsg1   = \"\"\nmsg2   = \"\"\n\ndsname = strip(dsname,\"B\",\"'\")\n\ndo forever\n address linkmvs \"XGALLOC DSNAME DDNAME DISP MSG1 MSG2\"\n if rc <> 0 then do\n  if pos(\" IN USE\",msg1) > 0 | pos(\" IN USE\",msg2) > 0 then do\n   call gsleep 2\n   iterate\n  end\n  if msg1 <> \"\" then call gnotify \"GGMVS004\" msg1\n  if msg2 <> \"\" then call gnotify \"GGMVS005\" msg2\n end\n leave\nend\nreturn ddname\n\ngsleep: parse arg seconds\ncall gnotify \"GGMVS008\" ,\n     \"GRAB:\" dsname \"in use.  Retrying in\" seconds \"seconds...\"\ncall gcall \"XGSLEEP\", seconds\nreturn\n./ ADD NAME=GRABTEMP\n/* GRAB: Gopher REXX Allocator in Batch to Touch Empty Memory Pages\n *       Usage: ddname = grabtemp({ddname})\n*/\ntrace off\nsignal on novalue\n\nparse arg ddname\n\ndsname = \"\"\ndisp   = \"NEW\"\nddname = strip(ddname,\"B\")\nmsg1   = \"\"\nmsg2   = \"\"\n\naddress linkmvs \"XGALLOC DSNAME DDNAME DISP MSG1 MSG2\"\nif rc <> 0 then do\n if msg1 <> \"\" then call gnotify \"GGMVS004\" msg1\n if msg2 <> \"\" then call gnotify \"GGMVS005\" msg2\nend\nreturn ddname\n./ ADD NAME=GREAD\n/* REXX.  Usage:  call gread ddname\n */\n\nparse arg ddname\n\nline. =\nline.0 =\n\n\"EXECIO * DISKR\" ddname \"(FINIS STEM LINE.)\"\n\ndo i = 1 to line.0\n if line.i = \"\" then queue \" \"; else queue line.i\nend\n\nreturn\n\n./ ADD NAME=GTSOTRAP\n/* REXX */\n\nparse arg tsocommand, gopherargs\n\nx = outtrap(\"LINE.\")\naddress TSO tsocommand\narc = rc\nx = outtrap(\"OFF\")\ncall gopen gopherargs\ndo i = 1 to line.0\n if line.i = \"\" then queue \" \";else queue line.i\nend\ncall gclose gopherargs\n\nreturn arc\n./ ADD NAME=HOSTNAME\n/* REXX */\n\nparse arg gopherargs\n\nreturn ghost(gopherargs)\n\n./ ADD NAME=NNMFIUCV\n/* REXX.  This exec scans the job pack queues for IUCVMULT and returns\n * with an error code if IUCVMULT is already loaded under a\n * different TCB. This can only happen under PIE MultiTSO or a\n * similar product that makes multiple job step TCB's.\n */\n\ntrace off\nsignal on novalue\n\nsearch_name = \"IUCVMULT\"\ncount = 0\nfoundtcb. = \"\"\ncurrent_tcb  = getword24(\"21C\")\ncurrent_job_step_tcb = getword24(current_tcb,\"7C\")\ncurrent_ascb = getword24(\"224\")\ncurrent_asxb = getword31(current_ascb,\"6C\")\nfirst_tcb    = getword24(current_asxb,\"4\")\ntcb = first_tcb\nmotherflag = 0\ndo forever\n if motherflag = 0 then do\n  call process\n  daughter_tcb = getword24(tcb,\"88\")\n  if daughter_tcb \\= \"00000000\" then do\n   tcb = daughter_tcb\n   iterate\n  end\n end\n motherflag = 0\n sister_tcb = getword24(tcb, \"80\")\n if sister_tcb \\= \"00000000\" then do\n  tcb = sister_tcb\n  iterate\n end\n mother_tcb = getword24(tcb, \"84\")\n if mother_tcb \\= \"00000000\" then do\n  tcb = mother_tcb\n  motherflag = 1\n  iterate\n end\n leave\nend\n\nif count = 0 then return 0\nproblem = 0\ndo i = 1 to count\n if foundtcb.i = current_job_step_tcb then do\n  /*\n  say search_name \"is already loaded under current TCB at \"foundtcb.i\".\"\n  */\n end\n else do\n  /*\n  say search_name \"is loaded under different TCB at \"foundtcb.i\".\"\n  */\n  problem = 1\n end\nend\n\nif problem = 1 then return 1\n\nelse return 0\n\nprocess:\n\n jpq = getword31(tcb,\"2C\")\n cde = jpq\n do while cde \\= \"00000000\"\n  cde_contents = storage(cde,32)\n  cde_name = substr(cde_contents,9,8)\n  cde_epa  = substr(cde_contents,9,8)\n  if search_name = cde_name then do\n   count = count + 1\n   foundtcb.count = tcb\n  end\n  cde = getword31(cde,\"0\")\n end\n\nreturn\n\ngetword31: parse arg addr, offset\ntemp1 = x2d(addr)\nif offset = \"\" then temp2 = 0\nelse temp2 = x2d(offset)\nreturn c2x(storage(d2x(temp1+temp2),4))\n\ngetword24: parse arg addr, offset\ntemp1 = x2d(addr)\nif offset = \"\" then temp2 = 0\nelse temp2 = x2d(offset)\nreturn \"00\"c2x(storage(d2x(temp1+temp2+1),3))\n\n./ ADD NAME=PORT\n/* REXX */\n\nparse arg gopherargs\n\nreturn gport(gopherargs)\n\n./ ADD NAME=REXXTEST\n/* REXX */\n\nparse arg args, gopherargs\nparse version rexx_version\nparse source rexx_source\n\ncall gopen gopherargs\n\nqueue \"PARSE VERSION returns:\" rexx_version\nqueue \"PARSE SOURCE  returns:\" rexx_source\nqueue \"Argument 1 is.........\" args\nqueue \"Gopherargs are........\" gopherargs\n\ncall gclose gopherargs\n\nreturn\n\n./ ADD NAME=TSOHELP\n/* REXX */\n\n/* This exec provides a sample TSO HELP application.\n   The gopher menu item will look something like this:\n\nTYPE=DIRECTORY\nNAME=TSO HELP\nPATH=EXEC:TSOHELP\nHOST=+\nEND\n\nwhere \"TSOHELP\" is the name of this exec.\n\nThis exec generates a series of lower-level menus, giving the user\na choice of how much help data to search (IBM only, local installation\nhelp, etc.).  This particular sample is Draper Lab's own, so you will\nneed to change it.\n\n */\n\ntrace off\nsignal on novalue\n\nhost = hostname()\nport = \"70\"\ntab  = '05'x\n\nhelpfiles.        = \"'SYS1.HELP'\"\nhelpfiles.sys1    = \"'SYS1.HELP'\"\nhelpfiles.draper  = \"'CSD.CMD.HELP' 'CSD.PP.HELP' 'SYS1.HELP'\"\nhelpfiles.proglib = \"'PROGLIB.CMD.HELP'\"\n\nparse arg helplib command type extra\n\nif helplib = \"\" then,\n     call display_top_menus\nelse call set_up_help helplib,command,type,extra\n\nreturn 0\n\n/*------------------------------------------------------------------*/\n\ndisplay_top_menus:\n\n call start_output\n call menu_out \"SYS1\",  \"COMMANDS\",\"DIRECTORY\",\"Regular IBM TSO Help\"\n call menu_out \"DRAPER\",\"COMMANDS\",\"DIRECTORY\",\"IBM and Draper TSO Help\"\n call menu_out \"PROGLIB\",\"PROGLIB\" ,\"DIRECTORY\",\"PROGLIB TSO Help\"\n call end_output\n\nreturn\n\n/*------------------------------------------------------------------*/\n\nset_up_help:  parse arg helplib,command,type,extra\n\n call outtrap \"TSO.\"\n \"ALLOC FI(SYSHELP) SHR REU DA(\"helpfiles.helplib\")\"\n allocrc = rc\n call outtrap \"OFF\"\n if allocrc <> 0 then do\n  call start_output\n  do i = 1 to tso.0\n   call menu_out \"ERROR\",\"ERROR\",\"DIRECTORY\",tso.i\n  end\n  call end_output\n end\n else do\n  select\n   when type = \"FILE\"      then call specific_help command,extra\n   when type = \"DIRECTORY\" then call general_help  command,extra\n   when type = \"INDEX\"     then call index_help    extra\n   otherwise                    call specific_help command\n end\n\nreturn\n\n/*------------------------------------------------------------------*/\n\nindex_help:\n\n /* This intermediate one-element directory is necessary because\n  * the Gopher INDEX format only returns directories, not files.\n  */\n\n parse upper arg commands\n call start_output\n do while commands <> \"\"\n  parse var commands command commands\n  call menu_out helplib,command,\"FILE\",\"Complete help for\" command\n  call menu_out helplib,command,\"FILE\",\"Function help only\",\"FUNCTION\"\n  call menu_out helplib,command,\"FILE\",\"Syntax help only\",\"SYNTAX\"\n  call menu_out helplib,command,\"FILE\",\"Operands help only\",\"OPERANDS\"\n end\n call end_output\n\nreturn\n\n/*------------------------------------------------------------------*/\n\ngeneral_help:\n\nparse arg command,extra\n\ncall get_help_text command,extra\n\ncall start_output\n\ncall menu_out helplib,\"*\",\"INDEX\",\"Help for a specific TSO command\"\n\ndo i = 1 to help.0\n parse var help.i helpname helpdesc\n if helpdesc <> \"\" & ,\n    length(helpname) <= 8 & ,\n    helpname < \"0\" & ,\n    verify(helpname,\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789W#$\") = 0 ,\n    then do\n\n  /*\n   * Draper help has a series of \"$...\" members which are like\n   * sublevel COMMANDS members.  This hack supports that.\n   */\n\n  if left(helpname,1) = \"$\" then do\n   call menu_out helplib,helpname,\"DIRECTORY\",helpdesc\n  end\n  else do\n   call menu_out helplib,helpname,\"FILE\",helpdesc\n  end\n end\nend\n\ncall end_output\n\nreturn\n\n/*------------------------------------------------------------------*/\n\nspecific_help:\n\nparse arg command,extra\n\ncall get_help_text command,extra\n\ncall start_output\n\ndo i = 1 to help.0\n call text_output help.i\nend\n\ncall end_output\n\nreturn\n\n/*------------------------------------------------------------------*/\n\nget_help_text:\n\nparse arg helpcmd,helpargs\n\nhelp. =\n\ncall outtrap \"HELP.\"\n\naddress TSO \"HELP\" helpcmd helpargs\n\ncall outtrap \"OFF\"\n\nreturn\n\n/*------------------------------------------------------------------*/\n\nmenu_out: parse arg mlib,mname,mtype,mdesc,mops\n\n select\n  when mtype = \"FILE\"      then gtype = \"0\"\n  when mtype = \"DIRECTORY\" then gtype = \"1\"\n  when mtype = \"INDEX\"     then gtype = \"7\"\n  otherwise do\n   call menu_out \"ERROR\",\"ERROR\",\"DIRECTORY\", \"Unknown type:\" mtype\n  end\n end\n\n gname = left(mname,9)\"--\" mdesc\n gpath = \"EXEC:TSOHELP\" mlib mname mtype mops\n out = gtype || gname || tab || gpath || tab || host || tab || port\n queue out\n\nreturn\n\n/*------------------------------------------------------------------*/\n\ntext_output: parse arg text\n\n if text = \"\" then queue \" \"\n else queue text\n\nreturn\n\n/*------------------------------------------------------------------*/\n\nstart_output:\n\n\"newstack\"\n\nreturn\n\n/*------------------------------------------------------------------*/\n\nend_output:\n\nqueue \"\"\n\n\"EXECIO * DISKW SYSTSPRT (FINIS)\"\n\n\"delstack\"\n\nreturn\n\n./ ADD NAME=UNGRAB\n/* UNGRAB: Utterly Negate Gopher REXX Allocator in Batch\n *       Usage: call ungrab ddname {,FREE/DELETE}\n */\ntrace off\nsignal on novalue\n\nparse arg ddname\ndsname = \"\"\ndisp   = \"\"\nif disp = \"\" then disp = \"FREE\"\nmsg1   = \"\"\nmsg2   = \"\"\n\naddress linkmvs \"XGALLOC DSNAME DDNAME DISP MSG1 MSG2\"\nif rc <> 0 then do\n if msg1 <> \"\" then call gnotify \"GGMVS006\" msg1\n if msg2 <> \"\" then call gnotify \"GGMVS007\" msg2\n return rc\nend\nreturn 0\n./ ENDUP\n?!\n//H        EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='H'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=GG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* --------------------- \"gg.h\" include member --------------------- */\n\n#pragma linkage(ispexec,OS)\n#pragma linkage(isplink,OS)\n#pragma linkage(ikjeff18,OS)\n#pragma linkage(ikjeftsr,OS)\n#pragma linkage(irxexec,OS)\n#pragma linkage(cmxlate,OS)\n\n/****** Installation-customized defines. *****************************/\n\n#include \"gguser.h\"\n\n#ifndef  C370V1\n#ifndef  C370V2\n#ifndef  SASC\n install_error_neither_C370V1_C370V2_nor_SASC_was_defined;\n#endif\n#endif\n#endif\n\n#ifndef  TCPIPV1\n#ifndef  TCPIPV2\n#ifndef  SNSTCPIP\n install_error_neither_TCPIPV1_TCPIPV2_nor_SNSTCPIP_was_defined;\n#endif\n#endif\n#endif\n\n#ifndef  ISPFV2\n#ifndef  ISPFV3\n install_error_neither_ISPFV2_nor_ISPFV3_was_defined;\n#endif\n#endif\n\n#define  MVS\n\n#ifdef   SNSTCPIP\n#undef   USE_CMXLATE\n#ifndef  I370\n#define  SNSC370\n#endif\n#endif\n\n#ifdef   I370\n#undef   USE_CMXLATE\n#endif\n\n/****** Clean up compiler warnings BEFORE time.h gets 'em ************/\n\n#ifndef  SASC\n#define  localtime            LOCALTIM\n#endif\n\n/****** Include all header files that are necessary. *****************/\n\n#ifndef SNSTCPIP\n#include <manifest.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <tcperrno.h>\n#include <fcntl.h>\n#endif\n\n#include <sys/socket.h>\n#include <netdb.h>\n#include <sys/uio.h>\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stddef.h>\n#include <time.h>\n\n#ifdef SNSTCPIP\n#include <acs.h>\n#include <inet.h>\n#include <sockcfg.h>\n#include <serrno.h>\n#endif\n\n#ifndef  SASC\n#include <ctest.h>\n#endif\n\n#ifdef   C370V2\n#undef   ENOMEM\n#include <mtf.h>\n#endif\n\n#ifdef   SASC\n#include \"ggsasc.h\"\n#endif\n\n/****** Version-dependent stuff **************************************/\n\n#ifdef   C370V1\n#undef   FETCH\n#endif\n\n#ifdef   C370V2\n#define  FETCH\n#endif\n\n#ifdef   TCPIPV1\n#define  TCP_DEBUG            tcp_debug\n#endif\n\n#ifdef   TCPIPV2\n#define  TCP_DEBUG            sock_debug\n#endif\n\n#ifdef   SNSTCPIP\n#define  TCP_DEBUG            /* I don't know how to debug in SNS */\n#endif\n\n#ifdef   GOPHER_DEBUG\n#define  TCP_DEBUG_ON         TCP_DEBUG(1)\n#define  TCP_DEBUG_OFF        TCP_DEBUG(0)\n#else\n#define  TCP_DEBUG_ON         /* */\n#define  TCP_DEBUG_OFF        /* */\n#endif\n\n/****** Preprocessor bookkeeping *************************************/\n\n#define  Bool                 char\n#define  Fool                 unsigned int /* for function arguments */\n#ifndef  TRUE\n#define  TRUE                 1\n#endif\n#ifndef  FALSE\n#define  FALSE                0\n#endif\n\n#define  GOPHER_FILE          '0'\n#define  GOPHER_DIRECTORY     '1'\n#define  GOPHER_MENU          '1'\n#define  GOPHER_CSO           '2'\n#define  GOPHER_ERROR         '3'\n#define  GOPHER_MAC_BINHEX    '4'\n#define  GOPHER_DOS_BINARCH   '5'\n#define  GOPHER_UUENCODE      '6'\n#define  GOPHER_WAIS          '7'\n#define  GOPHER_INDEX         '7'\n#define  GOPHER_TELNET        '8'\n#define  GOPHER_TN3270        'T'\n#define  GOPHER_BINARY        '9'\n#define  GOPHER_REDUNDANT     '+'\n#define  GOPHER_WHOIS         'w'\n#define  GOPHER_IMAGE         'I'\n#define  GOPHER_BOOKMANAGER   'b'\n#define  GOPHER_COMMENT       'i'\n#define  GOPHER_UNKNOWN       '\\0'\n#define  COMMANDSIZE          12\n#define  INTERNET_SIZE        256\n#define  RBUFSIZE             512\n#define  OUTBUFSIZE           1024\n#define  READ_BYTES           1024\n#define  SERVER_BUF_MSGSIZE   1024\n#define  CLIENT_BUF_MSGSIZE   1024\n#define  TEXT_BYTES           1024\n#define  GOPHER_PORT_NUMBER   70\n#define  GOPHER_HOST_LENGTH   MAXHOSTNAMELEN\n#define  GOPHER_PATH_LENGTH   512\n#define  GOPHER_DESC_LENGTH   256\n#define  SOCKET_GETCHAR_ERROR (-1)\n#define  SOCKET_NO_MORE       (-2)\n#define  SOCKET_READ_NOTHING  (-3)\n#define  NO_VALUE             (-1)\n#define  OUT_PLUS             (-2)\n#define  Rstruc               register struct\n#define  RGGCB                register GGCB\n#define  RRECV                register RECV\n#define  REXTR                register EXTRACTION\n#define  RINFO                register GOPHERINFO\n#define  RCONN                register CONNECTION\n#define  EQUAL                !strcmp\n#define  UNEQUAL              strcmp\n#define  COPY(A,B)            strncpy((A),(B),sizeof(A)-1)\n#define  DUMMY_FILE_POINTER   (FILE *)(-1)\n#define  MAX_INT              (int)0x7fffffff\n#define  LOCATE_INT           (int)0x7ffffffe\n#define  CARRIAGE_RETURN      '\\r'\n#define  FIND_NEXT            'N'\n#define  FIND_FIRST           'F'\n#define  FIND_LAST            'L'\n#define  FIND_PREV            'P'\n#define  FIND_ALL             'A'\n#define  FIND_CHARS           '\\0'\n#define  FIND_WORD            'W'\n#define  FIND_PREFIX          'P'\n#define  FIND_SUFFIX          'S'\n#define  FIND_CAPS            '\\0'\n#define  FIND_ASIS            'A'\n#define  FIND_HEX             'X'\n#define  FIND_GENERIC         'P'\n#define  FIND_BADFORM         '\\0'\n#define  FIND_UNQUOTED        'U'\n#define  FIND_QUOTED          'Q'\n#define  FIND_C               'C'\n#define  FIND_X               'X'\n#define  FIND_T               'T'\n#define  FIND_P               'P'\n#define  DATAOUT_LOW          0x01\n#define  DATAOUT_HIGH         0x02\n#define  DATAIN_LOW           0x03\n#define  DATAIN_HIGH          0x04\n#define  DATAOUT_BLUE         DATAOUT_LOW\n#define  DATAOUT_GREEN        0x05\n#define  DATAOUT_PINK         0x06\n#define  DATAOUT_RED          0x07\n#define  DATAOUT_TURQ         0x08\n#define  DATAOUT_WHITE        DATAOUT_HIGH\n#define  DATAOUT_YELLOW       0x09\n#define  DATAIN_BLUE          0x0a\n#define  DATAIN_GREEN         DATAIN_LOW\n#define  DATAIN_PINK          0x0b\n#define  DATAIN_RED           DATAIN_HIGH\n#define  DATAIN_TURQ          0x0c\n#define  DATAIN_WHITE         0x0d\n#define  DATAIN_YELLOW        0x0e\n\n#ifdef   I370\n#define  LINE_FEED            0x15\n#define  EtoA                 htoncs\n#define  AtoE                 ntohcs\n#else\n#define  LINE_FEED            0x25\n#ifdef   SNSTCPIP\n#define  EtoA                 etoa\n#define  AtoE                 atoe\n#else\n#define  EtoA(x)              ebcdictoascii\u00ddx\u00a8\n#define  AtoE(x)              asciitoebcdic\u00ddx\u00a8\n#define  ebcdictoascii        ebcdicto\n#define  asciitoebcdic        asciitoe\n#endif\n#endif\n\n#ifdef   USE_CMXLATE\n#define  EBCDIC_TO_ASCII(A,B) cmxlate((A),ebcdictoascii,(B))\n#define  ASCII_TO_EBCDIC(A,B) cmxlate((A),asciitoebcdic,(B))\n#else\n#ifdef   SNSC370\n#define  EBCDIC_TO_ASCII(A,B) EtoA(A,B)\n#define  ASCII_TO_EBCDIC(A,B) AtoE(A,B)\n#else\n#define  EBCDIC_TO_ASCII(A,B) {int _i; \\\n                               for (_i=0; _i<(B); ++_i) \\\n                                   (A)\u00dd_i\u00a8 = EtoA((A)\u00dd_i\u00a8); \\\n                              }\n#define  ASCII_TO_EBCDIC(A,B) {int _i; \\\n                               for (_i=0; _i<(B); ++_i) \\\n                                   (A)\u00dd_i\u00a8 = AtoE((A)\u00dd_i\u00a8); \\\n                              }\n#endif\n#endif\n\n#ifdef  TCPIPV1\n#define REPORT_TCP_ERROR(A)  /* */\n#endif\n\n#ifdef  TCPIPV2\n#define REPORT_TCP_ERROR(A)  tcperror(A)\n#endif\n\n#ifdef  SNSTCPIP\n#define REPORT_TCP_ERROR(A)  fprintf(stderr,\\\n                                    \"\\nTCP error on %s: errno = %d\\n\",\\\n                                    A,GET_ERRNO)\n#endif\n\n#ifdef  SNSC370\n#define Accept(A,B,C)        accept((A),(struct sockaddr *)(B),(C))\n#define Bind(A,B,C)          bind((A),(struct sockaddr *)(B),(C))\n#define Connect(A,B,C)       connect((A),(struct sockaddr *)(B),(C))\n#define Gethostbyaddr(A,B,C) gethostbyaddr((char *)(A),(B),(C))\n#define Getpeername(A,B,C)   getpeername((A),(struct sockaddr *)(B),(C))\n#define Getsockname(A,B,C)   getsockname((A),(struct sockaddr *)(B),(C))\n#define Getsockopt(A,B,C,D,E) getsockopt((A),(B),(C),(char *)(D),(E))\n#define EWOULDBLOCK          (ESWOULDBLOCK+s0skcfg.errnobase)\n#else\n#define Accept               accept\n#define Bind                 bind\n#define Connect              connect\n#define Gethostbyaddr        gethostbyaddr\n#define Getpeername          getpeername\n#define Getsockname(A,B,C)   getsockname((A),(char *)(B),(C))\n#define Getsockopt           getsockopt\n#endif\n\n#ifdef  FETCH\n#define ISPLINK              (gp->isplink_pointer)\n#define ISPEXEC              (gp->ispexec_pointer)\n#else\n#define ISPLINK              isplink\n#define ISPEXEC              ispexec\n#endif\n\n#ifdef   ISPFV3\n#define  ZERRLM_SIZE          513\n#else\n#define  ZERRLM_SIZE          73\n#endif\n\n#define  GOPHER_MSGID_OK    \"GGMVS001\"\n#define  GOPHER_MSGID_ERROR \"GGMVS002\"\n\n#define  NOTIFY_MSG   1\n#define  WARNING_MSG  2\n#define  CRITICAL_MSG 3\n\n#define  WARN1(X)           GGpmsg(gp,NOTIFY_MSG,NULL,X)\n#define  WARN2(X,Y)         GGpmsg(gp,NOTIFY_MSG,NULL,X,Y)\n#define  WARN3(X,Y,Z)       GGpmsg(gp,NOTIFY_MSG,NULL,X,Y,Z)\n#define  WARN4(X,Y,Z,W)     GGpmsg(gp,NOTIFY_MSG,NULL,X,Y,Z,W)\n#define  ERR1(X)            GGpmsg(gp,WARNING_MSG,NULL,X)\n#define  ERR2(X,Y)          GGpmsg(gp,WARNING_MSG,NULL,X,Y)\n#define  ERR3(X,Y,Z)        GGpmsg(gp,WARNING_MSG,NULL,X,Y,Z)\n#define  ERR4(X,Y,Z,W)      GGpmsg(gp,WARNING_MSG,NULL,X,Y,Z,W)\n#define  CRIT1(X)           GGpmsg(gp,CRITICAL_MSG,NULL,X)\n#define  CRIT2(X,Y)         GGpmsg(gp,CRITICAL_MSG,NULL,X,Y)\n#define  CRIT3(X,Y,Z)       GGpmsg(gp,CRITICAL_MSG,NULL,X,Y,Z)\n\n#define  GETMAIN(P,T,S,F)   GGgetm(gp,(char **)&(P),(sizeof(T))*(S),F)\n#define  FREEMAIN(P,F)      if (P) {GGfreem(gp,(char *)P,F);}\n#define  GOPHERSEND(X,Y)    if (!(GGesrvr(X,Y),\\\n                                  GGsockt(X,Y))) return FALSE\n#define  CLEAR(X)           memset(X,0,sizeof(*X))\n#define  ISPF(X)            GGispf(gp,X)\n#define  VGET(X,Y)          GGivget(gp,X,Y,sizeof(Y))\n#define  VGETS(X,Y,Z)       GGivget(gp,X,Y,Z)\n#define  VPUT(X,Y)          GGivput(gp,X,Y,-1)\n#define  VPUTS(X,Y,Z)       GGivput(gp,X,Y,Z)\n#define  IGET(X)            GGiget(gp,X)\n#define  IPUT(X,Y)          {char _iput\u00dd16\u00a8;\\\n                             sprintf(_iput,\"%d\",(Y));\\\n                             VPUT(X,_iput);}\n#ifndef I370\n#define  WRITE_FILEMODE     \"w,recfm=vb,lrecl=259,blksize=6233\"\n#define  APPEND_FILEMODE    \"a,recfm=vb,lrecl=259,blksize=6233\"\n#define  FTPTEMP_FILEMODE   \"w,recfm=vb,lrecl=23444,blksize=23448\"\n#define  FTPBIN_FILEMODE   \"wb,recfm=vb,lrecl=23444,blksize=23448\"\n#define  BKMGRBIN_FILEMODE \"wb,recfm=fb,lrecl=4096,blksize=8192\"\n#define  SYSOUT_FILEMODE    \"w,recfm=vba,lrecl=133\"\n#define  OPEN_TEXT_FILE_FOR_WRITE(F)     fopen((F),WRITE_FILEMODE)\n#define  OPEN_TEXT_FILE_FOR_APPEND(F)    fopen((F),APPEND_FILEMODE)\n#define  OPEN_SYSOUT_FILE(F)             fopen((F),SYSOUT_FILEMODE)\n#define  OPEN_FTP_TEMP_FILE(F)           fopen((F),FTPTEMP_FILEMODE)\n#define  OPEN_FTP_BINARY_FILE(F)         fopen((F),FTPBIN_FILEMODE)\n#define  OPEN_BOOKMANAGER_BINARY_FILE(F) fopen((F),BKMGRBIN_FILEMODE)\n#define  OPEN_TEXT_FILE_FOR_WRITE_OR_APPEND(F,B)  \\\n         fopen((F),(B) ? APPEND_FILEMODE : WRITE_FILEMODE)\n#define  OPEN_OUTPUT_FILE_FOR_WRITE_OR_APPEND(F,B)  \\\n         fopen((F),(B) ? \"a\" : WRITE_FILEMODE)\n#define  TEST_IF_FILE_EXISTS(P,F)  (P=fopen((F),\"r\"))\n#define  CLEANUP_IF_FILE_EXISTS(P) (void)fclose(P)\n#else\n#define  WRITE_FILEMODE     \"w,recfm=v,reclen=255,blksize=6233\"\n#define  APPEND_FILEMODE    \"a,recfm=v,reclen=255,blksize=6233\"\n#define  FTPTEMP_FILEMODE   \"w,recfm=v,reclen=23444,blksize=23448\"\n#define  FTPBIN_FILEMODE   \"wb,recfm=v,reclen=23444,blksize=23448\"\n#define  SYSOUT_FILEMODE    \"w,recfm=v,reclen=133,print=yes\"\n#define  FILEMODE             \"recfm=v,reclen=255,blksize=6233\"\n#define  FILEMODE_A           \"recfm=v,reclen=133,print=yes\"\n#define  FILEMODE_T           \"recfm=v,reclen=512,blksize=23440\"\n#define  FILEMODE_BM          \"recfm=fb,reclen=4096,blksize=8192\"\n#define  OPEN_TEXT_FILE_FOR_WRITE(F)  afopen((F),\"w\",\"seq\",FILEMODE)\n#define  OPEN_TEXT_FILE_FOR_APPEND(F) afopen((F),\"a\",\"seq\",FILEMODE)\n#define  OPEN_SYSOUT_FILE(F)          afopen((F),\"w\",\"seq\",FILEMODE_A)\n#define  OPEN_FTP_TEMP_FILE(F)        afopen((F),\"w\",\"seq\",FILEMODE_T)\n#define  OPEN_FTP_BINARY_FILE(F)      afopen((F),\"wb\",\"seq\",FILEMODE_T)\n#define  OPEN_BOOKMANAGER_BINARY_FILE(F) \\\n                                      afopen((F),\"wb\",\"seq\",FILEMODE_BM)\n#define  OPEN_TEXT_FILE_FOR_WRITE_OR_APPEND(F,B)  \\\n         afopen((F),(B)?\"a\":\"w\",\"seq\",FILEMODE)\n#define  OPEN_OUTPUT_FILE_FOR_WRITE_OR_APPEND(F,B)  \\\n         afopen((F),(B)?\"a\":\"w\",\"seq\",FILEMODE)\n#define  TEST_IF_FILE_EXISTS(F,P)  (access((F),0) == 0)\n#define  CLEANUP_IF_FILE_EXISTS(P) /* */\n#endif\n\n#define uppercase_in_place(C) {char *__cp;\\\n                     for(__cp=C;*__cp;__cp++) *__cp = toupper(*__cp);}\n\n#define lowercase_in_place(C) {char *__cp;\\\n                     for(__cp=C;*__cp;__cp++) *__cp = tolower(*__cp);}\n\n#define strip_trailing_in_place(C) {char *__cp;\\\n                     for(__cp=strchr((C),'\\0');\\\n                         __cp>C && isspace(*(__cp-1)); __cp--);\\\n                     *__cp='\\0';}\n\n#define strip_trailing_junk_in_place(C) {char *__cp;\\\n                     for(__cp=strchr((C),'\\0');\\\n                         __cp>C && !isgraph(*(__cp-1)); __cp--);\\\n                     *__cp='\\0';}\n\n#define copy_uppercase(A,B) {char *__cA,*__cB;\\\n                     for (__cA=A,__cB=B; *__cB;__cA++,__cB++)\\\n                         *__cA = toupper(*__cB);\\\n                     *__cA='\\0';}\n\n#define copy_lowercase(A,B) {char *__cA,*__cB;\\\n                     for (__cA=A,__cB=B; *__cB;__cA++,__cB++)\\\n                         *__cA = tolower(*__cB);\\\n                     *__cA='\\0';}\n\n#define copy_uppercase(A,B) {char *__cA,*__cB;\\\n                     for (__cA=A,__cB=B; *__cB;__cA++,__cB++)\\\n                         *__cA = toupper(*__cB);\\\n                     *__cA='\\0';}\n\n#define copy_uppercase_and_strip_trailing(A,B,C) {char *__cA,*__cB;\\\n                     for (__cA=A,__cB=B; *__cB;__cA++,__cB++)\\\n                         *__cA = toupper(*__cB);\\\n                     for (; __cA>A && isspace(*(__cA-1)); __cA--);\\\n                     *__cA='\\0';C=__cA;}\n\n#define copy_lowercase_and_strip_trailing(A,B,C) {char *__cA,*__cB;\\\n                     for (__cA=A,__cB=B; *__cB;__cA++,__cB++)\\\n                         *__cA = tolower(*__cB);\\\n                     for (; __cA>A && isspace(*(__cA-1)); __cA--);\\\n                     *__cA='\\0';C=__cA;}\n\n#define skip_leading_space(C)     (C) + strspn((C),\" \")\n#define skip_whitespace(C)        (C) + strspn((C),\" \\t\")\n#define skip_ISPF_whitespace(C)   (C) + strspn((C),\" ,\\t\")\n#define find_whitespace(A,B)      if (!(A=strpbrk((B),\" \\t\")))\\\n                                     A = strchr((B),'\\0');\n#define find_ISPF_whitespace(A,B) if (!(A=strpbrk((B),\" ,\\t\")))\\\n                                     A = strchr((B),'\\0');\n\n#define SPRINTF_IP_ADDRESS(A,B)  sprintf((A),\"%d.%d.%d.%d\",\\\n                                   (*(((unsigned char *)(&(B)))+0)),\\\n                                   (*(((unsigned char *)(&(B)))+1)),\\\n                                   (*(((unsigned char *)(&(B)))+2)),\\\n                                   (*(((unsigned char *)(&(B)))+3)))\n\n/****** Data and structure definitions. ******************************/\n\nenum accreq         {ACCESS_LOAD, ACCESS_CHECK, ACCESS_FREE};\nenum dstype         {PDS, SEQ, UNK, JES};\nenum extreq         {EXTRACT_IT, PRINT_IT, BOOKMARK_IT, BOOKMANAGE_IT};\nenum gohow          {AS_NORMAL, AS_FILE, AS_NOTHING};\nenum iomode         {NOCR, CRLF, RBIN};\nenum gostat         {STATUS_OK, STATUS_EOF, STATUS_ERROR};\nenum option         {OPTION_ALL, OPTION_VIEW, OPTION_OTHER};\nenum ostype         {DEFAULT_OS, VM_OS};\nenum scroll         {NO_SCROLL, UP, DOWN, LEFT, RIGHT, LOCATE};\nenum tmpfun         {TEMP_CREATE, TEMP_OPEN, TEMP_CLOSE, TEMP_REMOVE};\nenum retval         {\n                     SERVER_READ_OK,\n                     SERVER_READ_ERROR,\n                     SERVER_BUFFER_ERROR,\n                     SERVER_NO_MORE,\n                     SERVER_READ_NOTHING\n                    };\n\ntypedef unsigned int        IPADDRESS;\ntypedef int                 SOCKETNO;\ntypedef char                GOPHERTYPE;\ntypedef struct _textunit    TEXTUNIT;\ntypedef struct textline     TEXTLINE;\ntypedef struct texthdr      TEXTHDR;\ntypedef struct accessvector ACCESSVECTOR;\ntypedef struct connection   CONNECTION;\ntypedef struct extraction   EXTRACTION;\ntypedef struct gopherinfo   GOPHERINFO;\ntypedef struct gopherplus   GOPHERPLUS;\ntypedef struct ggcb         GGCB;\ntypedef struct recvstruct   RECV;\ntypedef struct menuitem     MENUITEM;\ntypedef struct sysout       SYSOUT;\ntypedef struct tempfile     TEMPFILE;\ntypedef enum   accreq       ACCREQ;\ntypedef enum   dstype       DSTYPE;\ntypedef enum   extreq       EXTREQ;\ntypedef enum   gohow        GOHOW;\ntypedef enum   gostat       GOSTAT;\ntypedef enum   iomode       IOMODE;\ntypedef enum   option       OPTION;\ntypedef enum   ostype       OSTYPE;\ntypedef enum   retval       RETVAL;\ntypedef enum   scroll       SCROLL;\ntypedef enum   tmpfun       TMPFUN;\n\n#ifndef ACCESSRULE\n#define ACCESSRULE  void\n#endif\n\nstruct textline  {\n                  struct textline    *next;\n                  short               text_length;\n                  short               tab_expanded_text_length;\n                  char               *tab_expanded_text;\n                  char                text\u00dd1\u00a8;  /* dummy */\n                 };\n\nstruct texthdr   {\n                  int                 text_line_count;\n                  TEXTLINE           *text_body_line;\n                  short               text_max_length;\n                  short               text_max_tab_expanded_length;\n                  TEXTLINE           *first_text_line;\n                  TEXTLINE           *current_text_line;\n                  TEXTLINE           *last_text_line;\n                 };\n\nstruct _textunit {\n                  unsigned short         key;\n                  unsigned short         num;\n                  struct {\n                          unsigned short len;\n                          char           prm\u00dd80\u00a8;\n                         }               ent;\n                 };\n\nstruct sysout    {\n                  int        copies;\n                  char       class  \u00dd2\u00a8;\n                  char       dest   \u00dd9\u00a8;\n                  char       userid \u00dd9\u00a8;\n                  char       forms  \u00dd5\u00a8;\n                  char       ucs    \u00dd5\u00a8;\n                 };\n\nstruct accessvector {\n                     int          rulecount;\n                     int          nextrule;\n                     ACCESSRULE  *accessrule\u00dd1\u00a8;\n                    };\n\nstruct tempfile {\n                 FILE        *fp;\n                 char         ddname\u00dd12\u00a8;\n                 char         dsname\u00ddL_tmpnam\u00a8;\n                 IOMODE       crmode;\n                };\n\nstruct extraction {\n                   int                   from_number;\n                   int                   to_number;\n                   int                   count;\n                   DSTYPE                mode;\n                   void                (*closer)();\n                   Bool                  appending;\n                   Bool                  blanking;\n                   Bool                  tab_expanding;\n                   EXTREQ                ex;\n                   char                  panelname     \u00dd9\u00a8;\n                   char                  dsname       \u00dd65\u00a8;\n                   char                  separator    \u00dd81\u00a8;\n                   char                  member_prefix \u00dd9\u00a8;\n                   char                  ddname        \u00dd9\u00a8;\n                   char                  member        \u00dd9\u00a8;\n                  };\n\nstruct gopherinfo {\n                   GOPHERTYPE            type;\n                   int                   port;\n                   TEXTHDR               thdr;\n                   char                  path \u00ddGOPHER_PATH_LENGTH+1\u00a8;\n                   char                  host \u00ddGOPHER_HOST_LENGTH+1\u00a8;\n                   char                  desc \u00ddGOPHER_DESC_LENGTH+1\u00a8;\n                   char                  plus;\n                   char                  bmds \u00dd65\u00a8; /* bookmark file */\n                  };\n\nstruct menuitem {\n    char          type;                  /* type of record to send   */\n    char          desc     \u00ddGOPHER_DESC_LENGTH+1\u00a8;\n    char          select   \u00ddGOPHER_PATH_LENGTH+1\u00a8;\n    char          hostname \u00ddGOPHER_HOST_LENGTH+1\u00a8;\n    int           port;                  /* host port to connect to  */\n    char          gopherplus;            /* null, '+' or '?' for ASK */\n   };\n\nstruct connection  {\n             char   *server_buf;\n             char   *client_buf;\n              int    mybufl;\n              int    nbytes;\n              int    ibuflen;\n              int    bytes_returned;\n              int    buf_index;\n         SOCKETNO    ns;\n             Bool    time_to_go_home;\n             Bool    server_has_nothing;\n             Bool    server_finished_replying;\n             Bool    sending_text;\n             Bool    receiving_text;\n             Bool    dont_read;\n             Bool    connected_to_server;\n             Bool    connection_broken;\n             Bool    closing_connection;\n             Bool    is_ftp;\n             char    server_hostname \u00ddMAXHOSTNAMELEN+1\u00a8;\n             char    buf \u00ddREAD_BYTES\u00a8;\n                   };\n\nstruct Ftp {\n            FILE                 *outfp;\n            FILE                 *errfp;\n            char                 *myname;\n            struct hostent       *server_hostent;\n            struct hostent       *client_hostent;\n            int                   backlog;\n            int                   myport;\n            SOCKETNO              listensocket;\n            Bool                  verboseflag;\n            Bool                  replaceflag;\n            Bool                  listflag;\n            Bool                  nlstflag;\n            Bool                  binary;\n            Bool                  control_socket_opened;\n            Bool                  listen_socket_opened;\n            Bool                  accept_socket_opened;\n            GOPHERTYPE            type;\n            OSTYPE                os;\n            IPADDRESS             hostaddress;\n            CONNECTION            control_connection;\n            CONNECTION            data_connection;\n            struct sockaddr_in    bindsock;\n            struct sockaddr_in    consock;\n            char                  ftphack \u00dd16\u00a8;\n            char                  host \u00dd257\u00a8;\n            char                  user \u00dd257\u00a8;\n            char                  pass \u00dd257\u00a8;\n            char                  path \u00dd257\u00a8;\n            char                  client_hostname \u00dd257\u00a8;\n            char                  server_hostname \u00dd257\u00a8;\n           };\n\nstruct gopherplus {\n                   int            dummy;   /* nothing yet */\n                  };\n\nstruct recvstruct {\n    int             sockfd;   /* socket descriptor for socket call */\n    int             outlen;\n    int             myport;\n    int             bytes_read;\n    Bool            binary;\n    GOSTAT          readstatus;\n    FILE           *outfp;    /* used by local (non-socket) interface*/\n    FILE           *readfile;                 /* declare the file... */\n    char           *fileptr;\n    char           *wargptr;\n    char           *mytelnet;\n    char           *mybkmgr;\n    char           *mydomain;\n    ACCESSVECTOR   *accvector;\n    GOPHERPLUS     *gopherplus;\n    TEMPFILE       *temp;\n    Bool          (*openfun)();\n    Bool          (*readfun)();\n    Bool          (*closefun)();\n    struct hostent  clienthostent;\n    char            pathtype;\n    char            myname  \u00ddMAXHOSTNAMELEN+1\u00a8;\n    char            hostname\u00ddMAXHOSTNAMELEN+1\u00a8;  /* client host name */\n    char            hosttest\u00ddMAXHOSTNAMELEN+1\u00a8;  /* client host name */\n    char            buffer  \u00ddRBUFSIZE\u00a8; /* client's character string */\n    char            dsname  \u00ddRBUFSIZE\u00a8;\n    char            sockbuf \u00ddOUTBUFSIZE\u00a8;    /* socket output buffer */\n   };\n\nstruct ggcb {\n             char    *gopher_command;\n             char    *extract_separator_line;\n             char    *mytelnet;\n             char    *mybkmgr;\n             char    *mydomain;\n             FILE    *debug_file;\n             FILE    *extract_file;\n             RECV    *recvp;\n       EXTRACTION    *extractionp;\n       GOPHERINFO    *ginfo;\n#ifdef FETCH\n              int   (*isplink_pointer)();\n              int   (*ispexec_pointer)();\n#endif\n              int     ispfrc;\n              int     text_find_left_bound;\n              int     text_find_right_bound;\n              int     myport;\n             Bool     test_mode;\n             Bool     debug_mode;\n             Bool     quit;\n             Bool     local_mode;\n             Bool     extract_tab_expanding;\n             Bool     extract_appending;\n             Bool     extract_blank_before_separator;\n             Bool     extract_write_error;\n             Bool     extract_close_error;\n             Bool     warn_overwrite;\n             Bool     warn_append;\n             Bool     setmsg;\n             Bool     autoscroll;\n             Bool     autocursor;\n             Bool     setcursor;\n             Bool     printing;\n        IPADDRESS     client_ip_address;\n        IPADDRESS     server_ip_address;\n          TEXTHDR     thdr;\n       CONNECTION     gopher_connection;\n             char     client_ip_addrstr   \u00dd16\u00a8;\n             char     server_ip_addrstr   \u00dd16\u00a8;\n             char     ggserver            \u00ddMAXHOSTNAMELEN+1\u00a8;\n             char     ggclient            \u00ddMAXHOSTNAMELEN+1\u00a8;\n             char     client_hostname     \u00ddMAXHOSTNAMELEN+1\u00a8;\n             char     server_hostname     \u00ddMAXHOSTNAMELEN+1\u00a8;\n             char     text_find_string    \u00dd81\u00a8;\n             char     text_dispchar;\n             char     text_find_what;\n             char     text_find_type;\n             char     text_find_trans;\n             char     current_bookmark_ds \u00dd65\u00a8;\n            };\n\n#ifndef I370\nextern  char          ebcdictoascii\u00dd\u00a8;\nextern  char          asciitoebcdic\u00dd\u00a8;\n#endif\n\n#ifndef FETCH\nextern  int           isplink();\nextern  int           ispexec();\n#endif\n\n/****** Procedure and function declarations. *************************/\n\nextern Bool         GGacces (RECV *, ACCREQ);\nextern DSTYPE       GGalloc (char *, char *, DSTYPE, int);\nextern void         GGbarf  (RECV *, char *);\nextern Bool         GGbin   (GGCB *, GOPHERINFO *, GOHOW);\nextern Bool         GGbkmgr (GGCB *, GOPHERINFO *, GOHOW);\nextern void         GGclrtx (GGCB *, GOPHERINFO *);\nextern Bool         GGconn  (GGCB *, CONNECTION *);\nextern Bool         GGcso   (GGCB *, GOPHERINFO *, GOHOW);\nextern Bool         GGdbm   (GGCB *, GOPHERINFO *);\nextern void         GGdfail (int,    __S99parms *);\nextern Bool         GGdir   (GGCB *, GOPHERINFO *, GOHOW);\nextern void         GGdisc  (GGCB *, CONNECTION *);\nextern int          GGdispl (GGCB *, char *);\nextern void         GGdsopt (GGCB *, char *);\nextern void         GGdump  (GGCB *, char *, char *, int);\nextern void         GGesrvr (GGCB *, CONNECTION *);\nextern void         GGfreem (GGCB *, char *,char *);\nextern Bool         GGftp   (RECV *, struct Ftp *);\nextern FILE        *GGgetds (GGCB *, EXTRACTION *);\nextern void         GGgetm  (GGCB *, char **,int,char *);\nextern Bool         GGgofor (GGCB *, GOPHERINFO *, GOHOW);\nextern Bool         GGgsrvl (GGCB *, CONNECTION *, char **, IOMODE);\nextern void         GGierr  (GGCB *);\nextern int          GGiget  (GGCB *, char *);\nextern Bool         GGinfo  (GGCB *, GOPHERINFO *);\nextern Bool         GGispf  (GGCB *, char *);\nextern Bool         GGivget (GGCB *, char *, char *,int);\nextern Bool         GGivput (GGCB *, char *, char *,int);\nextern Bool         GGmenu  (GGCB *, char *);\nextern void         GGmtfer (int,    char*);\nextern Bool         GGouts  (RECV *, char *, int);\nextern TEXTLINE    *GGouttx (GGCB *, char *, GOPHERINFO *, int);\nextern Bool         GGproc  (RECV *, int);\nextern int          GGrexx  (RECV *, char *, char *);\nextern int          GGsleep (int);\nextern Bool         GGsockt (GGCB *, CONNECTION *);\nextern void         GGsopt  (GGCB *, OPTION);\nextern FILE        *GGtemp  (RECV *, TEMPFILE *, TMPFUN);\nextern Bool         GGtnet  (GGCB *, GOPHERINFO *, GOHOW);\nextern int          GGtso   (char *);\nextern char        *GGtype  (GOPHERTYPE);\nextern Bool         GGunalc (char *);\nextern void         GGview  (GGCB *, GOPHERINFO *, TEXTHDR *, char *);\nextern Bool         GGvtx   (GGCB *, GOPHERINFO *, GOHOW);\nextern Bool         GGwais  (GGCB *, GOPHERINFO *, GOHOW);\nextern Bool         GGwhois (GGCB *, GOPHERINFO *, GOHOW);\nextern int          GGwto   (char *);\nextern Bool         GGxlist (GGCB *, char *);\nextern Bool         GGxtx   (GGCB *, GOPHERINFO *, EXTREQ);\n\n#ifndef SUPPRESS_V_DECLARATION\nextern void         GGpmsg  (GGCB *, int, char *, char *, ...);\n#endif\n\n/*********************************************************************/\n\nstatic char copyright_notice\u00dd\u00a8 =\n   \"Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993   \\n\\\n    GOPHER server due to Shawn Hart at the University of Delaware.  \\n\\\n    GOPHER client due to Steve Bacher at Draper Laboratory.         \\n\\\n    SAS modifications due to Dale Ingold at SAS Institute, Inc.     \\n\\\n                                                                    \\n\\\n    GOPHER server due to Shawn Hart at the University of Delaware.  \\n\\\n                                                                    \\n\\\n    This software is provided on an 'AS IS' basis.  All warranties, \\n\\\n    including the implied warranties of merchantability and fitness,\\n\\\n    are expressly denied.                                           \\n\\\n                                                                    \\n\\\n    Provided this copyright notice is included, this software may   \\n\\\n    be freely distributed and not offered for sale.                 \\n\\\n                                                                    \\n\\\n    Changes or modifications may be made and used only by the maker \\n\\\n    of same, and not further distributed.  Such modifications should\\n\\\n    be mailed to the author for consideration for addition to the   \\n\\\n    software and incorporation in subsequent releases.\";\n\n/*********************************************************************/\n\n./ ADD NAME=GGRX\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* -------------------- \"ggrx.h\" include member -------------------- */\n\n#define PARAMETER   unsigned int\n#define LASTPARM(X) ((unsigned int)(X) | 0x80000000)\n\n#define INVOKE_EXEC_AS_COMMAND            (unsigned int)0x80000000\n#define INVOKE_EXEC_AS_EXTERNAL_FUNCTION  (unsigned int)0x40000000\n#define INVOKE_EXEC_AS_SUBROUTINE         (unsigned int)0x20000000\n#define RETURN_EXTENDED_RETURN_CODES      (unsigned int)0x10000000\n\n/* the following take W as a work block extension address. */\n\n#define EXEC_INVOKED_AS_COMMAND(W)            ((W)->flags && 0x7fffffff)\n#define EXEC_INVOKED_AS_EXTERNAL_FUNCTION(W)  ((W)->flags && 0xbfffffff)\n#define EXEC_INVOKED_AS_SUBROUTINE(W)         ((W)->flags && 0xdfffffff)\n#define EXEC_RETURNS_EXTENDED_RETURN_CODES(W) ((W)->flags && 0xefffffff)\n\ntypedef int (*Rexxfun)();\n\nstruct envblock {\n                 char                 id      \u00dd8\u00a8;   /* \"ENVBLOCK\" */\n                 char                 version \u00dd4\u00a8;   /* \"0200\"     */\n                 int                  length;        /* 320        */\n                 struct parmblock    *parmblock;\n                 void                *userfield;\n                 struct workblockext *workblok_ext;\n                 void                *irxexte;\n                 void                *error_call_addr;\n                 void                *reserved;\n                 char                 error_msgid \u00dd8\u00a8;\n                 char                 primary_error_message    \u00dd80\u00a8;\n                 char                 alternate_error_message \u00dd160\u00a8;\n /* The following fields are valid in TSO/E 2.3.1 (?) and higher. */\n                 void                *compgmtb;\n                 void                *attnrout_parmptr;\n                };\n\nstruct parmblock {\n                  char                id       \u00dd8\u00a8;  /* \"IRXPARMS\" */\n                  char                version  \u00dd4\u00a8;  /* \"0200\"     */\n                  char                language \u00dd3\u00a8;\n                  char                reserved \u00dd1\u00a8;\n                  void               *modnamet;\n                  void               *subcomtb;\n                  void               *packtb;\n                  char                parsetok \u00dd8\u00a8;\n                  unsigned int        flags;\n                  unsigned int        masks;\n                  int                 subpool;\n                  char               *addrspn \u00dd8\u00a8;\n                  char                END \u00dd8\u00a8;       /* 8X'FF'     */\n                 };\n\nstruct workblockext {\n                     struct execblock    *execblk;\n                     void                *argtable;\n                     unsigned int         flags;\n                     struct instblock    *instblk;\n                     struct cppl         *cppl;\n                     struct evalblock    *evalblock;\n                     char                *workarea;\n                     void                *userfield;\n /* The following fields are valid in TSO/E 2.3.1 (?) and higher. */\n                     void                *rtproc;\n                     char                *source_address;\n                     char                *source_length;\n                    };\n\nstruct instblock {\n                  int dummy;\n                 };\n\nstruct evalblock {\n                  int dummy;\n                 };\n\nstruct execblock {\n                  char       acryn  \u00dd8\u00a8;       /* \"IRXEXECB\" */\n                  int        length;\n                  int        reserved1;\n                  char       member \u00dd8\u00a8;\n                  char       ddname \u00dd8\u00a8;\n                  char       subcom \u00dd8\u00a8;\n                  char      *dsnptr;\n                  int        dsnlen;\n                 };\n\nstruct shvblock {\n                 struct shvblock    *shvnext;\n                 int                 shvuser;\n                 char                shvcode;\n                 char                shvret;\n                 short               reserved;\n                 int                 shvbufl;\n                 char               *shvnama;\n                 int                 shvnaml;\n                 char               *shvvala;\n                 int                 shvvall;\n                };\n\nstruct cppl {\n             void    *cpplcbuf;\n             void    *cpplupt;\n             void    *cpplpscb;\n             void    *cpplect;\n            };\n\n\n/* --------------------- end of \"ggrx.h\" include ------------------- */\n\n./ ADD NAME=GGSASC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* ------------------- \"ggsasc.h\" include member ------------------- */\n\n#ifdef SASC\n\n#define I370\n\n#include <dynam.h>\n\n#define FETCH\n\n/*\n * DEBUG is an automatic preprocessor symbol set by SAS/C if the DEBUG\n * option is specified.\n */\n\n#ifdef DEBUG\n#define ACTUAL_OR_INLINE __actual\n#else\n#define ACTUAL_OR_INLINE __inline\n#endif\n\n ACTUAL_OR_INLINE void (*fetch( const char *modname ))()\n {\n   void (*fpp)();\n\n   loadm( modname, &fpp );\n   return( fpp );\n }\n\n ACTUAL_OR_INLINE int (*release( void (*fpp)() ))\n {\n   unloadm( fpp );\n   return( 0 );\n }\n\n\n#ifndef __SVC99\n\n  #define __SVC99  1\n\n  #include <code.h>\n\n  struct __S99struc\n    {\n      unsigned char   __S99RBLN;  /* length of request block..20      */\n      unsigned char   __S99VERB;  /* verb code                        */\n      unsigned short  __S99FLAG1; /* FLAGS1 field of SVC99 Req Block  */\n      unsigned short  __S99ERROR; /* error code field                 */\n      unsigned short  __S99INFO;  /* information reason code          */\n      void           *__S99TXTPP; /* address of text unit pointer list*/\n      int             __reserved; /* reserved..will always be 0       */\n      unsigned int    __S99FLAG2; /* FLAGS2 field..can only be filled */\n                                  /* in by APF authorized programs    */\n    };\n\n  typedef struct __S99struc __S99parms;\n\n  ACTUAL_OR_INLINE int svc99(__S99parms* svc99parmlist)\n    { return( (_ldregs(R1, &svc99parmlist),\n               _code(0, 0x9680, 0x1000),\n               _code(0, 0x0a63),\n               _stregs(R15) ) );\n    }\n\n#endif\n\n#define FALSE 0\n#define TRUE  1\n\n#include <lcio.h>\n\n#define  MAXHOSTNAMELEN     64\n\n#define  __ctest(X)  fprintf(stderr,\\\n                     \"GGMVS: CTEST is not supported by this compiler.\")\n\n#endif\n\n./ ADD NAME=GGSVC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* ------------------- \"ggsvc.h\" include member -------------------- */\n\n/*\n *  Usage:   SVC(SVC_NUMBER   svcnumber,\n *               SVC_REGISTER register15,\n *               SVC_REGISTER register0,\n *               SVC_REGISTER register1)\n *\n */\n\n#define SVC_NUMBER             unsigned char\n#define SVC_REGISTER           unsigned int\n\n#define SVC(_num,_r15,_r00,_r01) GGasvc((SVC_NUMBER)     (_num),\\\n                                        (SVC_REGISTER *) (_r15),\\\n                                        (SVC_REGISTER *) (_r00),\\\n                                        (SVC_REGISTER *) (_r01))\nextern void GGasvc (SVC_NUMBER,\n                    SVC_REGISTER *,\n                    SVC_REGISTER *,\n                    SVC_REGISTER *);\n\n/* -------------------- end of \"ggsvc.h\" include ------------------- */\n\n./ ADD NAME=GGSVC99\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* ------------------ \"ggsvc99.h\" include member ------------------- */\n\n /********************************************************************/\n /*                                                                  */\n /* The contents of this header are taken from the IBM assembler     */\n /* macros IEFZB4D0 and IEFZB4D2, which are                          */\n /* (C) Copyright IBM Corp.  1981, 1990                              */\n /*                                                                  */\n /********************************************************************/\n\n#define  S99VRBAL  0x01             /* ALLOCATION                    */\n#define  S99VRBUN  0x02             /* UNALLOCATION                  */\n#define  S99VRBCC  0x03             /* CONCATENATION                 */\n#define  S99VRBDC  0x04             /* DECONCATENATION               */\n#define  S99VRBRI  0x05             /* REMOVE IN-USE                 */\n#define  S99VRBDN  0x06             /* DDNAME ALLOCATION             */\n#define  S99VRBIN  0x07             /* INFORMATION RETRIEVAL         */\n#define  S99NOCNV  0x40             /* ALLOC FUNCTION-DO NOT USE AN  */\n                                    /* EXISTING ALLOCATION TO SATISFY*/\n                                    /* THE REQUEST                   */\n#define  DALDDNAM   0x0001          /* DDNAME                        */\n#define  DALDSNAM   0x0002          /* DSNAME                        */\n#define  DALMEMBR   0x0003          /* MEMBER NAME                   */\n#define  DALSTATS   0x0004          /* DATA SET STATUS               */\n#define  DALNDISP   0x0005          /* DATA SET DISPOSITION          */\n#define  DALTRK     0x0007          /* TRACK SPACE TYPE              */\n#define  DALBLKLN   0x0009          /* BLOCK LENGTH                  */\n#define  DALPRIME   0x000a          /* PRIMARY SPACE ALLOCATION      */\n#define  DALSECND   0x000b          /* SECONDARY SPACE ALLOCATION    */\n#define  DALDIR     0x000c          /* DIRECTORY BLOCK ALLOCATION    */\n#define  DALSYSOU   0x0018          /* SYSOUT                        */\n#define  DALSFMNO   0x001a          /* SYSOUT FORMS NUMBER           */\n#define  DALCOPYS   0x001d          /* SYSOUT COPIES                 */\n#define  DALUCS     0x0029          /* UNIVERSAL CHARACTER SET       */\n#define  DALBLKSZ   0x0030          /* DCB BLOCKSIZE                 */\n#define  DALDSORG   0x003c          /* DATA SET ORGANIZATION         */\n#define  DALLRECL   0x0042          /* DCB LOGICAL RECORD LENGTH     */\n#define  DALRECFM   0x0049          /* DCB RECORD FORMAT             */\n#define  DALPERMA   0x0052          /* PERMANENTLY ALLOCATED ATTRIB  */\n#define  DALRTDDN   0x0055          /* RETURN DDNAME                 */\n#define  DALRTDSN   0x0056          /* RETURN DSNAME                 */\n#define  DALRTORG   0x0057          /* RETURN D.S. ORGANIZATION      */\n#define  DALSUSER   0x0058          /* SYSOUT REMOTE WORKSTATION     */\n#define  DALUSRID   0x0063          /* SYSOUT USER ID                */\n#define  DUNDDNAM   0x0001          /* DDNAME                        */\n#define  DUNDSNAM   0x0002          /* DSNAME                        */\n#define  DUNUNALC   0x0007          /* UNALLOC OPTION                */\n#define  SHR        0x08\n#define  NEW        0x04\n#define  MOD        0x02\n#define  OLD        0x01\n#define  KEEP       0x08\n#define  DELETE     0x04\n#define  CATLG      0x02\n#define  UNCATLG    0x01\n#define  RECFM_F    0x80\n#define  RECFM_V    0x40\n#define  RECFM_U    0xc0\n#define  RECFM_D    0x20\n#define  RECFM_T    0x20\n#define  RECFM_B    0x10\n#define  RECFM_S    0x08\n#define  RECFM_A    0x04\n#define  RECFM_M    0x02\n#define  RECFM_FB   (RECFM_F | RECFM_B)\n#define  RECFM_VB   (RECFM_V | RECFM_B)\n#define  DSORG_PS   0x4000\n#define  DSORG_PO   0x0200\n\n/* ------------------- end of \"ggsvc99.h\" include ------------------ */\n\n./ ADD NAME=GGUSER\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* ------------------- \"gguser.h\" include member ------------------- */\n\n/* Include file for locally customized values. */\n\n/* Define levels of C/370 and TCP/IP.  This controls support for\n * fetching of non-C load modules and socket error reporting.\n */\n\n/* #define  C370V1    /* define this if C/370 Version 1 */\n   #define  C370V2    /* define this if C/370 Version 2 or higher */\n/* #define  SASC      /* define this if SAS/C compiler */\n\n/* #define  TCPIPV1   /* define this if TCP/IP Version 1 */\n   #define  TCPIPV2   /* define this if TCP/IP Version 2 or higher */\n/* #define  SNSTCPIP  /* define this if SNS/TCPAccess    */\n\n/* #define  ISPFV2    /* define this if ISPF Version 2 or earlier */\n   #define  ISPFV3    /* define this if ISPF Version 3 or later   */\n\n/*\n * If you know about the IBM TCP/IP \"CMXLATE\" function, and you want\n * to use it, set the define accordingly.\n * SNS/TCP users should NOT set this define.\n */\n\n   #define USE_CMXLATE\n/* #undef  USE_CMXLATE */\n\n/*\n * Define this if you want DEST, FORMS and UCB for print requests.\n * Undefine it if you don't (you get just CLASS and COPIES).\n */\n\n   #define FULLSYSOUT\n/* #undef  FULLSYSOUT */\n\n/* Define the following defaults for your installation. */\n/* Use XTELNET if you like the CSOCK package from UCLA. */\n\n   #define  TELNET_COMMAND_NAME     \"TELNET\"\n/* #define  TELNET_COMMAND_NAME     \"XTELNET\" */\n\n   #define  BOOKMGR_COMMAND_NAME    \"BOOKMGR\"\n\n/* Define the following if you want to use the autologin */\n/* feature of XTELNET (i.e. XTELNET -l userid(/password) */\n\n/* #define  XTELNET_AUTOLOGIN */\n   #undef   XTELNET_AUTOLOGIN\n\n/* Define this if the server host name set by the \"+\" frob\n * should have the domain name appended.  Note that this will\n * affect how the hostname needs to be specified for a\n * Path=(pdsmember) specification - it must match the local host\n * the way it is generated here.  Of course, host=+ will do it anyway.\n */\n\n   #define  APPEND_DOMAIN_NAME_TO_SELF\n/* #undef   APPEND_DOMAIN_NAME_TO_SELF */\n\n/* Define the following if you want logging messages */\n/* sent as write-to-programmer messages to SYSLOG.   */\n\n   #define  LOG_GOPHER_ACCESSES\n/* #undef   LOG_GOPHER_ACCESSES */\n\n/*\n * Turn on for TCP-level debugging output (you probably don't want to\n * unless your TCP/IP stuff is really broken and I can't help you).\n */\n\n/* #define GOPHER_DEBUG       */\n   #undef  GOPHER_DEBUG\n\n/*\n * Turn on for MTF-level debugging output.\n */\n\n/* #define DEBUGMTF    */\n   #undef  DEBUGMTF\n\n/*\n * Turn on to debug the access table matching rules.\n */\n\n/* #define ACCESS_DEBUG */\n   #undef  ACCESS_DEBUG\n\n/* Server and MTF stuff. */\n\n/* #define  MTF_TASKS           8 */\n#define  MTF_TASKS           1  /* lest REXX multitasking lossage */\n#define  TCP_QUEUE_LENGTH   20\n#define  SERV_TCP_PORT      70\n#define  CONNECT_TIME_OUT   60\n#define  DEFAULT_DIRECTORY  \"DD:GGGOPHER\"\n#define  ACCESS_TABLE       \"DD:GGACCESS\"\n#define  DEBUG_FILE         \"DD:GGDEBUG\"\n#define  PARAMETER_FILE     \"DD:GGPARMS\"\n#define  MY_DOMAIN_SUFFIX   \".DRAPER.COM\"\n#define  GOPHER_ADMIN       \"batchman@draper.com\"\n\n/* note: could get MY_DOMAIN_SUFFIX from TCPIP startup - what call? */\n\n/* Client stuff. */\n\n#define  INITIAL_TYPE   GOPHER_DIRECTORY\n#define  INITIAL_PORT   GOPHER_PORT_NUMBER\n#define  INITIAL_PATH   \"\"\n#define  INITIAL_HOST   \"MVS.DRAPER.COM\"\n#define  INITIAL_DESC   \"Root\"\n\n/********************************************************************/\n/**** You probably should not modify anything below this point.  ****/\n/********************************************************************/\n\n/* Server and client stuff. */\n\n#define  IDENT_HOST_FROB    \"+\"\n#define  LOCAL_HOST_FROB    \"-\"\n\n/********************************************************************/\n/* following are MVS file type identifiers.  They must appear at the\n   beginning of the file they're identifying.                        */\n/********************************************************************/\n\n#define  MENUIDENT    \"GOPHER_MENU\"\n#define  INDEXIDENT   \"GOPHER_INDEX\"\n\n/********************************************************************/\n/*  following are tokens for menu GOPHER identifiers.    */\n/********************************************************************/\n\n#define  TOKTYPE      \"TYPE\"\n#define  TYPETOK      0\n#define  TOKNAME      \"NAME\"\n#define  NAMETOK      1\n#define  TOKPATH      \"PATH\"\n#define  PATHTOK      2\n#define  TOKHOST      \"HOST\"\n#define  HOSTTOK      3\n#define  TOKPORT      \"PORT\"\n#define  PORTTOK      4\n#define  TOKEND       \"END\"\n#define  ENDTOK       5\n#define  TOKCOMMENT1  '*'\n#define  TOKCOMMENT2  '#'\n#define  TOKCOMMENT3  '!'\n#define  COMMENTTOK   6\n#define  TOKDISPLAY   \"DISPLAY\"\n#define  DISPLAYTOK   7\n#define  TOKSELECT    \"SELECTOR\"\n#define  SELECTTOK    8\n#define  NULLTOK      9\n\n/********************************************************************/\n/*  types of   \"types\" - operands of the TYPE keyword in directories.*/\n/********************************************************************/\n\n#define  TYPEFILE        \"FILE\"\n#define  TYPEMENU        \"DIRECTORY\"\n#define  TYPECSO         \"CSO\"\n#define  TYPEINDEX       \"INDEX\"\n#define  TYPETELNET      \"TELNET\"\n#define  TYPETN3270      \"TN3270\"\n#define  TYPEBINARY      \"BINARY\"\n#define  TYPEWHOIS       \"WHOIS\"\n#define  TYPEBOOKMANAGER \"BOOKMANAGER\"\n\n/********************************************************************/\n/*  used by the REXX Interface                                      */\n/********************************************************************/\n\n  /* Be sure to include all 8 bytes, including blanks, in below */\n\n#define  REXX_EXEC_LIBRARY_DDNAME   \"GGEXEC  \"\n#define  REXX_EXEC_SUBCOM           \"        \"\n\n./ ENDUP\n?!\n//C        EXEC MDLOAD,BS='6160',TRK1='25',TRK2='1',TO='C'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=GGACCES\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@ACCES\")\n#pragma  csect(static,\"GG$ACCES\")\n\n#define ACCESSRULE        struct accessrule\n\n#include \"gg.h\"\n\n#define RULEPTRSIZE       sizeof(ACCESSRULE *)\n#define ACCFILESIZE       63\n\n/*===================================================================*/\n\nstruct accessrule {\n                   int       number;\n                   int       hostcount;\n                   int       hosttextlen;\n                   int       major_weight;\n                   int       minor_weight;\n                   int       part1len;\n                   int       part2len;\n                   Bool      wildcard;\n                   char      accfile   \u00ddACCFILESIZE+1\u00a8;\n                   char      filepart1 \u00ddACCFILESIZE+1\u00a8;\n                   char      filepart2 \u00ddACCFILESIZE+1\u00a8;\n                   char      hosttext  \u00dd1\u00a8;\n                  };\n\n/*\n * There are three logical entry points:\n *\n *  load_access_rules is called from the server main task.\n *  check_access_rules is called from the server subtask.\n *  free_access_rules is called from the server main task.\n *\n */\n\n/*===================================================================*/\n\nstatic GGCB dummy_ggcb;\n\nstatic GGCB *\nget_dummy_ggcb()\n{\n GGCB *gp;\n\n gp = &dummy_ggcb;\n CLEAR(gp);\n\n /* Uncomment the following to see GETMAIN and FREEMAIN debugging. */\n /* gp->debug_file = stderr; */\n\n return gp;\n}\n\n/*===================================================================*/\n\nstatic void\nruledump(ACCESSRULE **rulep)\n{\n char       *op;\n ACCESSRULE *rule = *rulep;\n\n fprintf(stderr,\"Access rule at %8.8X\\n\\n\",rulep);\n fprintf(stderr,\"number........%d\\n\", rule->number);\n fprintf(stderr,\"hostcount.....%d\\n\", rule->hostcount);\n fprintf(stderr,\"hosttextlen...%d\\n\", rule->hosttextlen);\n fprintf(stderr,\"major_weight..%d\\n\", rule->major_weight);\n fprintf(stderr,\"minor_weight..%d\\n\", rule->minor_weight);\n fprintf(stderr,\"part1len......%d\\n\", rule->part1len);\n fprintf(stderr,\"part2len......%d\\n\", rule->part2len);\n fprintf(stderr,\"wildcard......%d\\n\", rule->wildcard);\n fprintf(stderr,\"accfile.......%s\\n\", rule->accfile);\n fprintf(stderr,\"filepart1.....%s\\n\", rule->filepart1);\n fprintf(stderr,\"filepart2.....%s\\n\", rule->filepart2);\n for (op = rule->hosttext; *op; op += strlen(op)+1) {\n   fprintf(stderr,\"host: %s\\n\", op);\n }\n fprintf(stderr,\"\\n\");\n}\n\n/*===================================================================*/\n\nstatic ACCESSRULE **\nget_access_rule(RRECV *R,\n                int    textlen\n               )\n{\n GGCB          *gp    = NULL;\n ACCESSVECTOR  *oldav = NULL;\n ACCESSVECTOR  *newav = NULL;\n ACCESSRULE   **rulep = NULL;\n int            howbig;\n int            oldcount;\n int            newcount;\n int            oldnext;\n\n gp = get_dummy_ggcb();\n\n oldav = R->accvector;\n oldcount = oldav ? oldav->rulecount : 0;\n oldnext  = oldav ? oldav->nextrule  : 0;\n\n if (!oldav || oldav->nextrule >= oldav->rulecount) {\n   newcount = oldcount + 100;\n   howbig = sizeof(struct accessvector)+RULEPTRSIZE*newcount;\n   GETMAIN(newav, char, howbig, \"access rule vector\");\n   if (!newav) return NULL;\n   if (oldav) {\n     oldcount = oldav->rulecount;\n     memcpy(newav->accessrule, oldav->accessrule, RULEPTRSIZE*oldcount);\n     FREEMAIN(oldav,\"old access rule vector\");\n   }\n   newav->rulecount = newcount;\n   newav->nextrule  = oldnext;\n   R->accvector = newav;\n }\n else {\n   newav = oldav;\n }\n rulep = &newav->accessrule\u00ddnewav->nextrule\u00a8;\n newav->nextrule++;\n GETMAIN(*rulep,char,sizeof(ACCESSRULE)+textlen,\"access rule\");\n return rulep;\n}\n\n/*===================================================================*/\n\n/* Check for wildcarding and assign weights accordingly.\n *\n * Rule Weighting, Wildcarding and Prioritization\n *\n * Since with wildcards, a path can match more than\n * one rule, with possible conflicting results, we\n * establish an algorithm for picking the appropriate rule.\n *\n * Each rule is given a weight equal to the number of\n * explicit characters in the pathspec that matches the\n * target name.  The rules with the highest weight will\n * be used - there may be more than one.  Consider\n *\n * foo.bar.baz host0\n * foo.*.baz   host1 host2 host3\n * foo.bar.*   host4 hsot5 host6\n * foo.*       host7 host8 host9\n * *.baz       host10 host11 host12\n *\n * The above rules have weight 11, 8, 8, 4, 4 respectively.\n * For file foo.bar.baz, the first rule (with weight 11)\n * supersedes, obviously.  For file foo.bar.mumble.baz,\n * all the rules except the first apply, so only the rules of\n * weight 8 (the maximum among the ones that match) will apply.\n * Now, to choose between the two rules, pick which one?\n *\n * Let's say the ones with the leftmost matching stuff\n * so that a minor weight equal to the length of the part\n * before the wildcard is used.  (subweight of 11,4,8,4,0)\n *\n * (We could sort the rules as they are loaded; then\n * the first matching rule would apply)\n *\n * So for example:\n *\n * path            major weight    minor weight\n * foo.bar.baz     11              11\n * foo.bar.*       8               8\n * foo.*.baz       8               4\n * foo.*           4               4\n * *.baz           4               0\n *\n * would be in the above order.\n */\n\nstatic Bool\nweigh_rule(ACCESSRULE *rule)\n{\n Bool      rc = FALSE;\n char     *star;\n int       filelen = strlen(rule->accfile);\n\n /* Set the weights for a non-wildcard path first. */\n\n star = strchr(rule->accfile,'*'); /* Locate wildcard character */\n if (!star) {\n   rule->wildcard = FALSE;\n   rule->major_weight = filelen;\n   rule->minor_weight = filelen;\n   return TRUE;\n }\n\n rule->wildcard = TRUE;\n rule->part1len = star - rule->accfile;\n rule->part2len = filelen - rule->part1len - 1;\n rule->major_weight = filelen - 1;\n rule->minor_weight = rule->part1len;\n\n strncpy(rule->filepart1, rule->accfile, rule->part1len);\n strncpy(rule->filepart2, star + 1,      rule->part2len);\n\n if (strchr(rule->filepart2,'*')) {\n   fprintf(stderr,\"Multiple wildcard *'s not allowed: %s\\n\",\n                  rule->accfile);\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/*===================================================================*/\n\nstatic int\ncompare_rule_weights(rule1,rule2)\nregister const void *rule1;\nregister const void *rule2;\n{\n register int major_weight_1 = (*(ACCESSRULE **)rule1)->major_weight;\n register int minor_weight_1 = (*(ACCESSRULE **)rule1)->minor_weight;\n register int major_weight_2 = (*(ACCESSRULE **)rule2)->major_weight;\n register int minor_weight_2 = (*(ACCESSRULE **)rule2)->minor_weight;\n\n /* This returns rules in descending order of major weight, and\n  * in descending order of minor weight within that.\n  */\n\n return (major_weight_2 == major_weight_1)\n         ? (minor_weight_2 - minor_weight_1)\n         : (major_weight_2 - major_weight_1);\n\n}\n\n/*===================================================================*/\n\nstatic void\nsort_rules(RRECV *R)\n{\n int              rx;\n ACCESSRULE      *rule;\n\n if (R->accvector) {\n   qsort(R->accvector->accessrule,R->accvector->nextrule,RULEPTRSIZE,\n         compare_rule_weights);\n   for (rx = 0; rx < R->accvector->nextrule; rx++) {\n     rule = R->accvector->accessrule\u00ddrx\u00a8;\n     rule->number = rx;\n   }\n }\n\n}\n\n/*===================================================================*/\n\nstatic Bool\nload_access_rules(RRECV *R)\n{\n char        *ip;\n char        *op;\n char        *rest_of_line;\n FILE        *afp;\n ACCESSRULE  *rule;\n ACCESSRULE **rulep;\n int          rulenumber;\n int          n;\n int          hostcount;\n Bool         rc;\n char         accline  \u00ddRBUFSIZE\u00a8;\n char         accfile  \u00ddRBUFSIZE\u00a8;\n char         acchost  \u00ddRBUFSIZE\u00a8;\n\n /* If non-socket interface, bypass the authorization check. */\n\n if (R->outfp) return TRUE;\n\n /* Load rules from the access file.  Each rule consists of a\n  * pathname followed by a list of hostnames.\n  * The pathname will be (dataset), EXEC:execname, or DD:file\n  * - wildcards are also possible.\n  */\n\n rc = TRUE;\n rulenumber = 0;\n\n afp = fopen(ACCESS_TABLE,\"r\");\n if (!afp) {\n   perror(ACCESS_TABLE);\n   fflush(stderr);\n   return FALSE;\n }\n\n for (;;) {\n   fgets(accline, sizeof(accline), afp);\n   if (ferror(afp)) {\n     fprintf(stderr,\"Error reading access table %s\\n\",ACCESS_TABLE);\n     rc = FALSE;\n     break;\n   }\n   if (feof(afp)) break;\n   uppercase_in_place(accline); /* format is: filename machine(s)   */\n   ip = accline;                      /* Start scan pointer         */\n   *accfile = '\\0';                   /* Clear access file name     */\n   sscanf(ip,\"%s %n\",accfile,&n);     /* Get file name, bump scan   */\n   if (!*accfile) continue;           /* Ignore blank lines         */\n   if (*accfile == '!' ) continue;    /* Ignore comment lines       */\n   rulenumber++;\n   if (strlen(accfile) > sizeof(rule->accfile)-1) {\n     fprintf(stderr,\"Access rule file name exceeds %d characters\\n\",\n                    sizeof(rule->accfile)-1);\n     fprintf(stderr,\"Cannot load rule: %s\\n\\n\",accline);\n     rc = FALSE;\n     continue;\n   }\n   rest_of_line = ip + n;\n   rulep = get_access_rule(R,strlen(rest_of_line));\n   if (!rulep) break;\n   rule = *rulep;\n   if (!rule) break;\n   CLEAR(rule);\n   rule->number = rulenumber;\n   rule->hosttextlen = strlen(rest_of_line);\n   strncpy(rule->accfile, accfile, sizeof(rule->accfile));\n\n   /* Loop over access host ids  */\n   for (ip = rest_of_line, op = rule->hosttext;;ip += n) {\n     *acchost = '\\0';               /* Clear word before scanf    */\n     sscanf(ip,\"%s %n\",acchost,&n); /* Get next word, bump scan   */\n     if (!*acchost) break;          /* exit loop if no more hosts */\n     strcpy(op,acchost);\n     op += strlen(acchost) + 1;\n     rule->hostcount++;\n   }\n\n   if (!weigh_rule(rule)) {\n     fprintf(stderr,\"Cannot load rule: %s\\n\\n\",accline);\n     rc = FALSE;\n     continue;\n   }\n\n }\n\n (void)fclose(afp);\n\n sort_rules(R);\n\n if (R->accvector) {\n   int rx;\n   for (rx = 0; rx < R->accvector->nextrule; rx++) {\n#ifdef ACCESS_DEBUG\n     ruledump(&R->accvector->accessrule\u00ddrx\u00a8);\n#endif\n     rule = R->accvector->accessrule\u00ddrx\u00a8;\n     fprintf(stderr,\"Rule %d (%d,%d): %s\\n\",\n      rule->number,rule->major_weight,rule->minor_weight,rule->accfile);\n   }\n }\n\n fflush(stderr);\n\n return rc;\n}\n\n/*===================================================================*/\n\nstatic Bool\nfree_access_rules(RRECV *R)\n{\n GGCB    *gp = NULL;\n int      i;\n if (!R->accvector) return TRUE;\n\n gp = get_dummy_ggcb();\n\n for (i = 0; i < R->accvector->nextrule; i++) {\n   FREEMAIN(R->accvector->accessrule\u00ddi\u00a8,\"access rule\");\n }\n FREEMAIN(R->accvector,\"access rule vector\");\n\n return TRUE;\n}\n\n/*===================================================================*/\n\nstatic Bool\nmatch(char *file,\n      ACCESSRULE *rule)\n{\n int   len;\n\n if (rule->wildcard) {\n  len = strlen(file);\n  return (rule->part1len <= len\n       && rule->part2len <= len\n   && !memcmp(file,                   rule->filepart1,rule->part1len)\n   && !memcmp(file+len-rule->part2len,rule->filepart2,rule->part2len));\n }\n else return EQUAL(file,rule->accfile);\n}\n\n/*===================================================================*/\n\nstatic Bool\ncheck_access_rules(RRECV *R,\n                   char  *fptr)\n{\n char       *cp;\n char       *hostp;\n ACCESSRULE *rule;\n int         rx;\n int         this_major_weight;\n int         this_minor_weight;\n Bool        rc;\n Bool        matched;\n char        filetest \u00ddRBUFSIZE\u00a8;\n\n /* If non-socket interface, bypass the authorization check. */\n\n if (R->outfp) return TRUE;\n\n /* Check that the server is allowed to return data from the file\n  * specified to this routine.  Note that this could be the name of\n  * an exec.  The name will be (dataset), EXEC:execname, or DD:file\n  * - we look at only the first part, whitespace-delimited.\n  * Entries in the file authorization table look as above.\n  */\n\n rc = FALSE;\n filetest\u00dd0\u00a8 = '\\0';\n sscanf(fptr,\"%s\",filetest);\n\n if (!R->accvector) {\n   fprintf(stderr,\"No rules, cannot authorize: %s\\n\",filetest);\n   fflush(stderr);\n   return FALSE;\n }\n\n /* The algorithm is this:\n  *\n  * The rules have already been sorted in descending weight order.\n  * Try each rule until one that matches the file is found, whether\n  * or not the hosts match.  Save the major and minor weights of that\n  * rule, because all rules with that set of weights will be tried to\n  * look for a file-and-host match.  So, proceed from that point,\n  * trying each rule until one of the following occurs:\n  *\n  * - ran out of rules with same weights - fail\n  * - found a file and a host that match - succeed\n  *\n  * Even if a non-match is found, we keep checking because\n  * there may be more than one entry in the access table\n  * for this file, so that more host names can be given.\n  */\n\n for (rx = 0; rx < R->accvector->nextrule; rx++) {\n   rule = R->accvector->accessrule\u00ddrx\u00a8;\n   if (match(filetest,rule)) {\n     matched = TRUE;\n     this_major_weight = rule->major_weight;\n     this_minor_weight = rule->minor_weight;\n#ifdef ACCESS_DEBUG\n     fprintf(stderr,\"Rule %d (%d, %d): file name matches %s\\n\",\n                    rule->number,rule->major_weight,rule->minor_weight,\n                    rule->accfile);\n#endif\n     for (;rx < R->accvector->nextrule; rx++) {\n       rule = R->accvector->accessrule\u00ddrx\u00a8;\n       if (rule->major_weight != this_major_weight\n        || rule->minor_weight != this_minor_weight) break;\n#ifdef ACCESS_DEBUG\n       fprintf(stderr,\"Trying rule %d (%d, %d): %s\\n\",\n              rule->number,rule->major_weight, rule->minor_weight,\n              rule->accfile);\n#endif\n       if (!matched && !match(filetest,rule)) continue;\n       matched = FALSE;\n       if (!*rule->hosttext) {\n#ifdef ACCESS_DEBUG\n         fprintf(stderr,\"This rule matches for all host names\\n\");\n#endif\n         rc = TRUE;\n         break;\n       }\n       else {\n         for (hostp=rule->hosttext; *hostp; hostp+=strlen(hostp)+1) {\n           if (EQUAL(R->hostname,hostp)\n            || EQUAL(R->hosttest,hostp)) {   /* if hostname matches */\n#ifdef ACCESS_DEBUG\n             fprintf(stderr,\"This rule matches host name %s\\n\",hostp);\n#endif\n             rc = TRUE;\n             break;\n           }\n         }\n         if (rc) break;\n       }\n     }       /* end for */\n     break;  /* at end of this, we either got it or we don't */\n   }         /* end if match */\n }           /* end for */\n\n if (!rc) {\n   fprintf(stderr,\"Not authorized from %s: '%s'\\n\",\n                  R->hosttest, filetest);\n }\n\n fflush(stderr);\n\n return rc;\n}\n\n/*===================================================================*/\n\nBool\nGGacces(RRECV  *R,\n        ACCREQ  req\n       )\n{\n\n switch (req) {\n   case ACCESS_LOAD:  return load_access_rules(R);\n   case ACCESS_CHECK: return check_access_rules(R,R->fileptr);\n   case ACCESS_FREE:  return free_access_rules(R);\n }\n\n}\n\n./ ADD NAME=GGALLOC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@ALLOC\")\n#pragma  csect(static,\"GG$ALLOC\")\n#include \"gg.h\"\n#include \"ggsvc99.h\"\n\n/****** Allocate a data set. *****************************************/\n\nDSTYPE\nGGalloc(dsname,ddname,wanted_type,nitems)\nchar   *dsname;\nchar   *ddname;\nDSTYPE  wanted_type;\nint     nitems;\n{\n int             i;\n int             rc;\n DSTYPE          return_type;\n Bool            try_new;\n short           primary_allocation   ;\n short           secondary_allocation ;\n short           directory_blocks     ;\n short           dsorg                ;\n __S99parms      stuff99; /* No \"struct\", despite manual */\n TEXTUNIT       *tu \u00dd17\u00a8;\n TEXTUNIT        tu_dsn;\n TEXTUNIT        tu_ddn;\n TEXTUNIT        tu_member;\n TEXTUNIT        tu_stat;\n TEXTUNIT        tu_disp;\n TEXTUNIT        tu_perm;\n TEXTUNIT        tu_rtddn;\n TEXTUNIT        tu_rtorg;\n TEXTUNIT        tu_block;\n TEXTUNIT        tu_prime;\n TEXTUNIT        tu_sec;\n TEXTUNIT        tu_dir;\n TEXTUNIT        tu_recfm;\n TEXTUNIT        tu_lrecl;\n TEXTUNIT        tu_blksz;\n TEXTUNIT        tu_dsorg;\n char           *lparp;\n char           *rparp;\n char           *qp;\n FILE           *mfile;\n char            dsnseq \u00dd81\u00a8;\n char            member \u00dd81\u00a8;\n char            what_to_open \u00dd81\u00a8;\n\n try_new = FALSE;\n\n memset((char *)&stuff99,0,sizeof(__S99parms));\n\n strcpy(member,\"\");\n strcpy(dsnseq,dsname);\n if (*dsnseq == '\\'') {    /* strip off single quotes if any */\n   strcpy(dsnseq,dsname+1);\n   if ((qp = strchr(dsnseq,'\\''))) *qp = '\\0';\n }\n lparp = strchr(dsnseq,'(');\n rparp = strchr(dsnseq,')');\n if (lparp && rparp && (lparp < rparp) && (*(rparp+1) == '\\0')) {\n   *lparp = '\\0';            /* makes dsnseq the seq part only */\n   *rparp = '\\0';            /* turns member into a string     */\n   strcpy(member, lparp+1);\n   wanted_type = PDS;\n }\n\n for (;;) {\n\n   stuff99.__S99RBLN   = 20;\n   stuff99.__S99VERB   = S99VRBAL;\n   stuff99.__S99FLAG1  = S99NOCNV << 8;\n   stuff99.__S99ERROR  = 0;\n   stuff99.__S99INFO   = 0;\n   stuff99.__S99TXTPP  = tu;\n   stuff99.__S99FLAG2  = 0;\n\n   i = 0;\n\n   tu\u00ddi++\u00a8 = &tu_dsn;\n\n   tu_dsn.key        = DALDSNAM;\n   tu_dsn.num        = 1;\n   tu_dsn.ent.len    = strlen(dsnseq);\n   copy_uppercase(tu_dsn.ent.prm,dsnseq);\n\n   tu\u00ddi++\u00a8 = &tu_stat;\n\n   tu_stat.key      = DALSTATS;\n   tu_stat.num      = 1;\n   tu_stat.ent.len  = 1;\n   *tu_stat.ent.prm = (try_new ? NEW : SHR);\n\n   tu\u00ddi++\u00a8 = &tu_disp;\n\n   tu_disp.key      = DALNDISP;\n   tu_disp.num      = 1;\n   tu_disp.ent.len  = 1;\n   *tu_disp.ent.prm = (try_new ? CATLG : KEEP);\n\n   tu\u00ddi++\u00a8 = &tu_rtorg;\n\n   tu_rtorg.key     = DALRTORG;\n   tu_rtorg.num     = 1;\n   tu_rtorg.ent.len = 2;\n\n   if (*member) {\n\n     tu\u00ddi++\u00a8 = &tu_member;\n\n     tu_member.key     = DALMEMBR;\n     tu_member.num     = 1;\n     tu_member.ent.len = strlen(member);\n     copy_uppercase(tu_member.ent.prm,member);\n\n   }\n\n   if (ddname && *ddname) {\n\n     tu\u00ddi++\u00a8 = &tu_ddn;\n\n     tu_ddn.key     = DALDDNAM;\n     tu_ddn.num     = 1;\n     tu_ddn.ent.len = strlen(ddname);\n     copy_uppercase(tu_ddn.ent.prm,ddname);\n\n     tu\u00ddi++\u00a8 = &tu_perm;\n\n     tu_perm.key     = DALPERMA;\n     tu_perm.num     = 0;\n\n   }\n   else {\n\n     tu\u00ddi++\u00a8 = &tu_rtddn;\n\n     tu_rtddn.key     = DALRTDDN;\n     tu_rtddn.num     = 1;\n     tu_rtddn.ent.len = 8;\n     memset(tu_rtddn.ent.prm,' ',8);\n\n   }\n\n   if (try_new) {\n\n     switch (wanted_type) {\n       case PDS:\n                 primary_allocation   = (short)nitems;\n                 secondary_allocation = primary_allocation;\n                 directory_blocks     = ((short)nitems/(12*36)+1) * 36;\n                 dsorg                = DSORG_PO;\n                 break;\n       case SEQ:\n       default:\n                 primary_allocation   = (short)nitems;\n                 secondary_allocation = primary_allocation;\n                 directory_blocks     = 0;\n                 dsorg                = DSORG_PS;\n                 break;\n     }\n\n     tu\u00ddi++\u00a8 = &tu_block;\n\n     tu_block.key     = DALBLKLN;\n     tu_block.num     = 1;\n     tu_block.ent.len = 3;\n     memset(tu_block.ent.prm,0,3);\n     *(short *)(tu_block.ent.prm+1) = 6233;\n\n     tu\u00ddi++\u00a8 = &tu_prime;\n\n     tu_prime.key     = DALPRIME;\n     tu_prime.num     = 1;\n     tu_prime.ent.len = 3;\n     memset(tu_prime.ent.prm,0,3);\n     *(short *)(tu_prime.ent.prm+1) = primary_allocation;\n\n     tu\u00ddi++\u00a8 = &tu_sec;\n\n     tu_sec.key     = DALSECND;\n     tu_sec.num     = 1;\n     tu_sec.ent.len = 3;\n     memset(tu_sec.ent.prm,0,3);\n     *(short *)(tu_sec.ent.prm+1) = secondary_allocation;\n\n     tu\u00ddi++\u00a8 = &tu_dir;\n\n     tu_dir.key     = DALDIR;\n     tu_dir.num     = 1;\n     tu_dir.ent.len = 3;\n     memset(tu_dir.ent.prm,0,3);\n     *(short *)(tu_dir.ent.prm+1) = directory_blocks;\n\n     tu\u00ddi++\u00a8 = &tu_recfm;\n\n     tu_recfm.key        = DALRECFM;\n     tu_recfm.num        = 1;\n     tu_recfm.ent.len    = 1;\n     *tu_recfm.ent.prm   = RECFM_VB;\n\n     tu\u00ddi++\u00a8 = &tu_lrecl;\n\n     tu_lrecl.key        = DALLRECL;\n     tu_lrecl.num        = 1;\n     tu_lrecl.ent.len    = 2;\n     *(short *)tu_lrecl.ent.prm   = 259;\n\n     tu\u00ddi++\u00a8 = &tu_blksz;\n\n     tu_blksz.key        = DALBLKSZ;\n     tu_blksz.num        = 1;\n     tu_blksz.ent.len    = 2;\n     *(short *)tu_blksz.ent.prm   = 6233;\n\n     tu\u00ddi++\u00a8 = &tu_dsorg;\n\n     tu_dsorg.key        = DALDSORG;\n     tu_dsorg.num        = 1;\n     tu_dsorg.ent.len    = 2;\n     *(short *)tu_dsorg.ent.prm   = dsorg;\n\n   }\n\n   tu\u00ddi\u00a8 = (void *)0x80000000;\n\n   rc = svc99(&stuff99);\n\n   /* added info-code check per Duane Weaver uncataloged temp files */\n\n   if (rc == 0 && stuff99.__S99ERROR == 0 && stuff99.__S99INFO == 0) {\n     if (!(ddname && *ddname)) {\n       memcpy(ddname,(char *)tu_rtddn.ent.prm,8);\n       *(ddname+8) = ' ';\n       *(strchr(ddname,' ')) = '\\0';\n     }\n     switch (tu_rtorg.ent.prm\u00dd0\u00a8) {\n       case 0x40:  return_type = SEQ; break;\n       case 0x02:  return_type = PDS; break;\n       default:    return_type = UNK; break;\n     }\n     if (wanted_type == SEQ && return_type != SEQ) {\n       fprintf(stderr,\"%s: not a sequential data set\\n\",dsname);\n     }\n     if (wanted_type == PDS && return_type != PDS) {\n       fprintf(stderr,\"%s: not a partitioned data set\\n\",dsname);\n     }\n     if (return_type == PDS && *member) return SEQ;\n     else return return_type;\n   }\n   else if (!try_new && nitems != 0 && stuff99.__S99ERROR == 0x1708) {\n    try_new = TRUE;\n    continue;\n   }\n   else {\n     GGdfail(rc,&stuff99);\n     return UNK;\n   }\n }\n}\n\n./ ADD NAME=GGASVC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@ASVC\")\n#pragma  csect(static,\"GG$ASVC\")\n\n#include \"gg.h\"\n#include \"ggsvc.h\"\n\n#define HEX(A)      0x##A\n#define I4(A,B,C,D) HEX(A), HEX(B), HEX(C), HEX(D)\n#define I2(A,B)     HEX(A), HEX(B)\n\n/*\n *  Usage:   SVC(SVC_NUMBER   svcnumber,\n *               SVC_REGISTER register15,\n *               SVC_REGISTER register0,\n *               SVC_REGISTER register1)\n *\n * This routine invokes the specified SVC with the specified contents\n * of registers 15, 0 and 1, and fills in the returned values of those\n * registers on return from the SVC.  That is why the caller must pass\n * the register words by reference.\n */\n\nvoid\nGGasvc(SVC_NUMBER     num,\n       SVC_REGISTER  *r15,\n       SVC_REGISTER  *r00,\n       SVC_REGISTER  *r01\n      )\n{\n void               (*svccode)();\n\nstatic char  assembler_code\u00dd\u00a8 = {\n   I4(90,ec,d0,0c), /* 0000       STM  14,12,12(13)  */\n   I2(18,3f),       /* 0004       LR   3,15          */\n   I4(98,47,10,00), /* 0006       LM   4,7,0(1)      */\n   I4(58,f0,50,00), /* 000A       L    15,0(,5)      */\n   I4(58,00,60,00), /* 000E       L    0,0(,6)       */\n   I4(58,10,70,00), /* 0012       L    1,0(,7)       */\n   I4(44,40,30,2c), /* 0016       EX   4,EXSVC       */\n   I4(50,f0,50,00), /* 001A       ST   15,0(,5)      */\n   I4(50,00,60,00), /* 001E       ST   0,0(,6)       */\n   I4(50,10,70,00), /* 0022       ST   1,0(,7)       */\n   I4(98,ec,d0,0c), /* 0026       LM   14,12,12(13)  */\n   I2(07,fe),       /* 002A       BR   14            */\n   I2(0a,00)        /* 002C EXSVC SVC  0             */\n  };\n\n svccode = (void (*)()) assembler_code;\n (*svccode)(num,r15,r00,r01);\n\n return;\n}\n\n./ ADD NAME=GGBARF\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@BARF\")\n#pragma  csect(static,\"GG$BARF\")\n\n#include \"gg.h\"\n\nvoid\nGGbarf(RECV  *R,\n       char  *message)\n{\n char        temp \u00dd257\u00a8;\n\n if (!R->outfp) fprintf(stderr,\"Barfing: %s\\n\", message);\n\n if (R->gopherplus) {\n   if (!GGouts(R,\"--1<\" GOPHER_ADMIN \">\", OUT_PLUS)) return;\n   if (!GGouts(R,message,                 NO_VALUE)) return;\n }\n else {\n   /* the number should be 3 (ERROR) but some clients may not show it\n    *             |\n    *             V\n    */\n   sprintf(temp, \"1%s.\\t0\\t0\\t0\", message);\n   (void)GGouts(R,temp,NO_VALUE);\n }\n return;\n}\n\n./ ADD NAME=GGBIN\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@BIN  \")\n#pragma  csect(static,\"GG$BIN  \")\n#include \"gg.h\"\n\n/****** Display a binary file retrieved from the server. *************/\n\nBool\nGGbin(gp,ip,how)\nRGGCB     *gp;\nRINFO     *ip;\nGOHOW      how;\n{\n TEXTHDR  *texthdrp;\n char      title \u00dd81\u00a8;\n\n switch (how) {\n   case AS_NOTHING: return;\n   default:         break;\n }\n\n texthdrp = (ip ? &ip->thdr : &gp->thdr);\n\n if (!ip) sprintf(title, \"GopherServer:%s \",gp->ggserver);\n else     strncpy(title, ip->desc, sizeof(title));\n\n GGview(gp,ip,texthdrp,title);\n\n return;\n}\n\n./ ADD NAME=GGBKMGR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@BKMGR\")\n#pragma  csect(static,\"GG$BKMGR\")\n#include \"gg.h\"\n\n/****** Display a BookManager (C) IBM file from the server. **********/\n\nBool\nGGbkmgr(gp,ip,how)\nRGGCB     *gp;\nRINFO     *ip;\nGOHOW      how;\n{\n int       tsorc;\n Bool      ok = FALSE;\n FILE     *tempfile = NULL;\n char      ddname  \u00dd 12\u00a8;\n char      tempdsn \u00dd257\u00a8;\n char      command \u00dd257\u00a8;\n\n switch (how) {\n   case AS_NOTHING: return;\n   default:         break;\n }\n\n /* Create temporary file to hold binary BookManager data. */\n\n if (!tmpnam(tempdsn)) {\n   ERR1(\"Could not create temporary file for BookManager\");\n   return FALSE;\n }\n\n strcpy(ddname,\"dd:\");\n\n if (GGalloc(tempdsn,ddname+3,SEQ,500) != SEQ) {\n   ERR2(\"The temporary file %s could not be allocated.\",\n         tempdsn);\n   return FALSE;\n }\n\n tempfile = OPEN_BOOKMANAGER_BINARY_FILE(ddname);\n if (!tempfile) {\n   perror(tempdsn);\n   ERR2(\"The temporary file %s could not be opened.\", tempdsn);\n   return FALSE;\n }\n\n /* Write binary text data to temporary file.              */\n\n ok = TRUE;\n\n if (ip->thdr.first_text_line) {\n   gp->extract_file = tempfile;\n   if (!GGxtx(gp,ip,BOOKMANAGE_IT)) {\n     ERR2(\"Error writing to temporary BookManager file %s\",tempdsn);\n     ok = FALSE;\n   }\n }\n else {\n   ERR1(\"The retrieved BookManager file is empty.\");\n   ok = FALSE;\n }\n\n if (fclose(tempfile) < 0) {\n   ERR2(\"The temporary BookManager file %s could not be closed.\",\n         tempdsn);\n   return FALSE;\n }\n\n (void)GGunalc(ddname+3);\n\n if (ok) {\n\n   sprintf(command,\"%s BOOK(%s)\",gp->mybkmgr,tempdsn);\n\n   if ((tsorc = GGtso(command)) != 0) {\n     ERR3(\"Command \\\"%s\\\" returned code %d\", command, tsorc);\n   }\n\n   /* Remove temporary file. */\n\n   if (remove(tempdsn) < 0) {\n     ERR2(\"The temporary BookManager file %s could not be removed.\",\n           tempdsn);\n   }\n\n }\n\n ISPF(\"CONTROL DISPLAY REFRESH\");\n\n return ok;\n}\n\n./ ADD NAME=GGCLIEN\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#ifdef SASC\n#pragma  runopts(EXECOPS)\n#else\n#pragma  runopts(heap(8k,8k,anywhere,))\n#endif\n\n#pragma  csect(code,  \"GG@CLIEN\")\n#pragma  csect(static,\"GG$CLIEN\")\n#include \"gg.h\"\n\n#ifdef I370\nchar * _style = \"tso:\";\n#endif\n\n/*********************************************************************/\n\nstatic void\ntrap_ispf_command(gp,verb,action)\nRGGCB            *gp;\nchar             *verb;\nchar             *action;\n{\n char             zcttrunc \u00dd16\u00a8;\n char             zctact   \u00dd64\u00a8;\n char             zctdesc \u00dd128\u00a8;\n\n if (!VPUT(\"ZCTVERB \",verb)) return;\n\n if (!ISPF(\"TBTOP ISPCMDS\")) return;\n if (!ISPF(\"TBSCAN ISPCMDS ARGLIST(ZCTVERB)\")) return;\n if (!VGET(\"ZCTACT \",zctact))  return;\n if (UNEQUAL(zctact,action)) {\n   VGET(\"ZCTTRUNC \",zcttrunc);\n   VGET(\"ZCTDESC  \",zctdesc );\n   if (!ISPF(\"TBTOP ISPCMDS\")) return;\n   VPUT(\"ZCTACT   \",action  );\n   VPUT(\"ZCTTRUNC \",zcttrunc);\n   VPUT(\"ZCTDESC  \",zctdesc );\n   if (!ISPF(\"TBADD ISPCMDS\")) return;\n }\n\n return;\n}\n\n/*********************************************************************/\n\nstatic Bool\ngo_for_it(gp,ip)\nRGGCB    *gp;\nRINFO    *ip;\n{\n\n VGET(\"GGHOST \",ip->host);\n VGET(\"GGPATH \",ip->path);\n VGET(\"GGDESC \",ip->desc);\n ip->port = IGET(\"GGPORT \");\n ip->type = INITIAL_TYPE;\n if (!*ip->path) strcpy(ip->path,INITIAL_PATH);\n if (!*ip->host) strcpy(ip->host,INITIAL_HOST);\n if (!*ip->desc) strcpy(ip->desc,INITIAL_DESC);\n if (ip->port == 0) ip->port = INITIAL_PORT;\n *ip->bmds = '\\0';\n return GGgofor(gp,ip,AS_NORMAL);\n\n}\n\n/*********************************************************************/\n\nint\nmain(argc,argv)\nint      argc;\nchar   **argv;\n{\n GGCB         *gp;\n GOPHERINFO   *ip;\n CONNECTION   *sp;\n char         *p;\n int           i;\n int           exitrc;\n Bool          bypass_startup;\n GGCB          gg;\n char          ggdomain \u00dd129\u00a8;\n char          ggtelnet \u00dd129\u00a8;\n char          ggbkmgr  \u00dd129\u00a8;\n char          zerrsm   \u00dd25\u00a8;\n char          zerrlm   \u00ddZERRLM_SIZE\u00a8;\n\n exitrc = 0;\n gp = &gg;\n CLEAR(gp);\n\n GETMAIN(ip, GOPHERINFO, 1, \"top-level gopherinfo struct\");\n if (!ip) {\n   fprintf(stderr,\"Not enough memory to start up GOPHER\\n\");\n   exit(16);\n }\n\n CLEAR(ip);\n gp->ginfo = ip;\n\n for (i = 1; i < argc; i++) {\n   p = argv\u00ddi\u00a8;\n   if (*p == '-') {\n     while (*++p) {\n       switch (toupper(*p)) {\n         case 'T': gp->test_mode  = TRUE; break;\n         case 'D': gp->debug_mode = TRUE; break;\n         case 'L': gp->local_mode = TRUE; break;\n         case 'Q': bypass_startup = TRUE; break;\n         default:  fprintf(stderr,\"GGMVS: Bad parameter flag %c\\n\",*p);\n                   exitrc = 8;\n       }\n     }\n   }\n   else {\n     fprintf(stderr,\"GGMVS: Bad parameter string %s\\n\",p);\n     exitrc = 8;\n   }\n }\n\n if (gp->test_mode) __ctest(NULL);\n\n if (gp->debug_mode) {\n   if (!(gp->debug_file = fopen(DEBUG_FILE,\"w\"))) {\n     perror(DEBUG_FILE);\n     exitrc = 4;\n   }\n }\n\n GGclrtx(gp,NULL); /* Clear text */\n GGclrtx(gp,ip);   /* Clear text */\n\n /* These may be overridden from gopherrc. */\n\n gp->myport   = SERV_TCP_PORT;\n gp->mytelnet = TELNET_COMMAND_NAME;\n gp->mybkmgr  = BOOKMGR_COMMAND_NAME;\n gp->mydomain = MY_DOMAIN_SUFFIX;\n\n sp = &gp->gopher_connection;\n\n GETMAIN(sp->server_buf,    char,SERVER_BUF_MSGSIZE+4,\"server buffer\");\n GETMAIN(sp->client_buf,    char,CLIENT_BUF_MSGSIZE+4,\"client buffer\");\n GETMAIN(gp->gopher_command,char,CLIENT_BUF_MSGSIZE+4,\"gopher command\");\n\n#ifdef FETCH\n gp->isplink_pointer = (int (*) ())fetch(\"ISPLINK\");\n gp->ispexec_pointer = (int (*) ())fetch(\"ISPEXEC\");\n#endif\n\n if (!ISPF(\"CONTROL ERRORS RETURN\")) exitrc = 20;\n\n else {\n\n   exitrc = 0;\n   trap_ispf_command(gp,\"RFIND\",\"&YRFIND\");  /* enable RFIND */\n\n   ISPF(\"TBGET GOPHERVT\");    /* get Gopher startup variables */\n   ISPF(\"TBCLOSE GOPHERVT\");  /* ... in case of split screen gophers */\n\n   VGET(\"GGDOMAIN \",ggdomain);\n   VGET(\"GGTELNET \",ggtelnet);\n   VGET(\"GGBKMGR  \",ggbkmgr );\n   if (*ggdomain) gp->mydomain = ggdomain;\n   if (*ggtelnet) gp->mytelnet = ggtelnet;\n   if (*ggbkmgr)  gp->mybkmgr  = ggbkmgr;\n\n   GGsopt(gp,OPTION_ALL);      /* set options */\n\n   if (bypass_startup) {       /* use values put in table by exec */\n     (void)go_for_it(gp,ip);\n   }\n   else {\n     VPUT(\"ZCMD \",\"\");\n     while (GGdispl(gp,\"GGM     \") == 0\n         && !gp->quit\n         && !go_for_it(gp,ip)) ;\n   }\n }\n\n if (gp->setmsg) {\n   VGET(\"ZERRSM \",zerrsm);\n   VGET(\"ZERRLM \",zerrlm);\n   fprintf(stderr,\"%s: %s\\n\",zerrsm,zerrlm);\n   gp->setmsg = FALSE;\n }\n\n if (sp->connected_to_server) {\n   GGdisc(gp,sp);            /* disconnect from gopher server */\n }\n\n FREEMAIN(gp->gopher_command,\"gopher command\");\n FREEMAIN(sp->server_buf,    \"server buffer\");\n FREEMAIN(sp->client_buf,    \"client buffer\");\n FREEMAIN(ip,                \"top-level gopherinfo struct\");\n\n #define FINAL_CLOSE(A,B) \\\n   if (A) { \\\n            if (fclose(A) < 0) fprintf(stderr,B); \\\n          }\n\n FINAL_CLOSE(gp->debug_file, \"Error closing debug file\\n\");\n\n exit(exitrc);\n}\n\n./ ADD NAME=GGCLRTX\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@CLRTX\")\n#pragma  csect(static,\"GG$CLRTX\")\n#include \"gg.h\"\n\n/****** Clear text. **************************************************/\n\nvoid\nGGclrtx(gp,ip)\nRGGCB  *gp;\nRINFO  *ip;\n{\n register TEXTHDR   *thp;\n register TEXTLINE  *tp1;\n register TEXTLINE  *tp2;\n\n /* If info is not specified, use main ggcb, else info's text */\n\n thp = (ip ? &ip->thdr : &gp->thdr);\n\n tp1 = thp->first_text_line;\n while (tp1) {\n  tp2 = tp1->next;\n  FREEMAIN(tp1,\"text line\");\n  tp1 = tp2;\n }\n\n CLEAR(thp);\n\n return;\n\n}\n\n./ ADD NAME=GGCONN\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@CONN \")\n#pragma  csect(static,\"GG$CONN \")\n#include \"gg.h\"\n\n/****** Get client hostname and IP address. **************************/\n\nstatic Bool\nget_client_hostname(gp)\nRGGCB              *gp;\n{\n struct hostent    *client_hp;\n int                gethostnamerc;\n int                hostlen;\n int                domslen;\n\n gethostnamerc = gethostname(gp->client_hostname,MAXHOSTNAMELEN);\n if (gethostnamerc < 0) {\n   fprintf(stderr,\"GGMVS: gethostname() failed, don't know my name\\n\");\n   return FALSE;\n }\n\n#ifdef APPEND_DOMAIN_NAME_TO_SELF\n\n hostlen = strlen(gp->client_hostname);\n domslen = strlen(gp->mydomain);\n if (hostlen <= domslen ||\n    memcmp(gp->client_hostname+hostlen-domslen,gp->mydomain,domslen)) {\n   strncat(gp->client_hostname,gp->mydomain,domslen);\n }\n\n#endif\n\n uppercase_in_place(gp->client_hostname);\n\n client_hp = gethostbyname(gp->client_hostname);\n if (!client_hp) {\n   fprintf(stderr,\n           \"GGMVS: gethostbyname(%s) failed, can't get my name\\n\",\n           gp->client_hostname);\n   return FALSE;\n }\n\n strcpy(gp->ggclient,gp->client_hostname);\n strcpy(gp->client_hostname, client_hp->h_name);\n gp->client_ip_address = *(IPADDRESS *)client_hp->h_addr;\n\n return TRUE;\n\n}\n\n/****** Connect to news server. **************************************/\n\nBool\nGGconn(gp,sp)\nRGGCB *gp;\nRCONN *sp;\n{\n char              *lp;\n char              *cp;\n RECV              *R;\n struct hostent    *server_hp;\n struct sockaddr_in bindsock;\n struct sockaddr_in consock;\n int                bindrc;\n int                connrc;\n int                ip_part_1;\n int                ip_part_2;\n int                ip_part_3;\n int                ip_part_4;\n char               tempdsn \u00ddL_tmpnam\u00a8;\n\n if (sp->connected_to_server) {\n   GGdisc(gp,sp);         /* Disconnect from gopher server */\n }\n\n sp->closing_connection = FALSE;\n sp->buf_index          = -1;\n sp->bytes_returned     = 0;\n sp->receiving_text     = FALSE;\n sp->is_ftp             = FALSE;\n\n if (!*gp->ggserver) {\n   ERR1(\n   \"No host server defined in Gopher menu.  Cannot make a connection.\");\n   return FALSE;\n }\n\n uppercase_in_place(gp->ggserver);\n\n /* If server is \"local hack\", then establish local mode,\n  * open temporary file and return.\n  */\n\n if (!strcmp(gp->ggserver, LOCAL_HOST_FROB)) {\n\n   if (gp->ginfo->port != GOPHER_PORT_NUMBER) {\n     ERR3(\"Server name %s is permitted only with port number %d.\",\n          LOCAL_HOST_FROB, GOPHER_PORT_NUMBER);\n     return FALSE;\n   }\n\n   GETMAIN(gp->recvp, RECV, 1, \"local recv struct\");\n   if (!gp->recvp) {\n     CRIT1(\"Can't get memory for local host struct\");\n     return FALSE;\n   }\n   R = gp->recvp;\n   CLEAR(R);\n\n   R->myport   = gp->myport;\n   R->mytelnet = gp->mytelnet;\n   R->mybkmgr  = gp->mybkmgr;\n   R->mydomain = gp->mydomain;\n\n   if (!tmpnam(tempdsn)) {\n     CRIT1(\"Can't create temporary file for local access\");\n     return FALSE;\n   }\n\n   /* Create temporary file for writing and reading. */\n\n   R->outfp = fopen(tempdsn,\"w+,type=memory\");\n   if (!R->outfp) {\n     perror(tempdsn);\n     CRIT1(\"Can't open temporary file for local access\");\n     return FALSE;\n   }\n\n   sp->connected_to_server = TRUE;\n   sp->time_to_go_home     = FALSE;\n   sp->connection_broken   = FALSE;\n\n   GGesrvr(gp,sp);   /* Clean up any stray responses from server. */\n\n   return TRUE;\n }\n\n /* Disallow network connections if started up in local mode. */\n\n if (gp->local_mode) {\n   ERR1(\"Network connections are not allowed in local mode.\");\n   return FALSE;\n }\n\n /* Determine the local path name. Do only if making net conn. */\n\n if (!*gp->client_hostname) {\n   if (!get_client_hostname(gp)) return FALSE;\n }\n\n /* Get server name and address.  */\n\n if (strchr(gp->ggserver,'.') &&\n     gp->ggserver\u00ddstrspn(gp->ggserver,\".0123456789\")\u00a8 == '\\0') {\n   ip_part_1 = ip_part_2 = ip_part_3 = ip_part_4 = 32767;\n   strcpy(gp->server_hostname, gp->ggserver);\n   strcpy(sp->server_hostname, gp->ggserver);\n   sscanf(gp->ggserver,\"%d.%d.%d.%d\",\n                       &ip_part_1,&ip_part_2,&ip_part_3,&ip_part_4);\n   if (ip_part_1 > 255 ||\n       ip_part_2 > 255 ||\n       ip_part_3 > 255 ||\n       ip_part_4 > 255) {\n     ERR2(\"Syntax error in server network address: %s\", gp->ggserver);\n     return FALSE;\n   }\n   gp->server_ip_address = (IPADDRESS) ((ip_part_1 << 24) +\n                                        (ip_part_2 << 16) +\n                                        (ip_part_3 <<  8) +\n                                        (ip_part_4      ));\n }\n else {\n   server_hp = gethostbyname(gp->ggserver);\n   if (!server_hp) {\n     ERR2(\n\"Unknown host %s - gethostbyname() could not resolve the server name.\",\n          gp->ggserver);\n     return FALSE;\n   }\n   strcpy(gp->server_hostname, server_hp->h_name);\n   strcpy(sp->server_hostname, server_hp->h_name);\n   gp->server_ip_address = *(IPADDRESS *)server_hp->h_addr;\n }\n\n SPRINTF_IP_ADDRESS(gp->server_ip_addrstr, gp->server_ip_address);\n SPRINTF_IP_ADDRESS(gp->client_ip_addrstr, gp->client_ip_address);\n\n VPUT(\"GGSERVER \",gp->ggserver);\n VPUT(\"GGCLIENT \",gp->ggclient);\n VPUT(\"GGSERVIP \",gp->server_ip_addrstr);\n VPUT(\"GGCLIEIP \",gp->client_ip_addrstr);\n\n consock.sin_family       = AF_INET;\n consock.sin_port         = htons(gp->ginfo->port);\n consock.sin_addr.s_addr  = gp->server_ip_address;\n\n bindsock.sin_family      = AF_INET;\n bindsock.sin_port        = 0;\n bindsock.sin_addr.s_addr = INADDR_ANY;\n\n sp->ns = socket(AF_INET, SOCK_STREAM, 0);\n if (sp->ns < 0) {\n   REPORT_TCP_ERROR(gp->ggserver);\n   ERR2(\"TCP/IP error: socket() failed to make socket for server %s.\",\n        gp->ggserver);\n   return FALSE;\n }\n\n bindrc = Bind(sp->ns, &bindsock, sizeof(bindsock));\n if (bindrc < 0) {\n   REPORT_TCP_ERROR(gp->ggserver);\n   ERR2(\"TCP/IP error: bind() failed for socket %d\", sp->ns);\n   return FALSE;\n }\n\n ISPF(\"CONTROL DISPLAY LOCK\");\n ISPF(\"DISPLAY PANEL(GGMLCONN)\");\n\n if (gp->debug_file) {\n   fprintf(gp->debug_file,\n           \"Client %s (%s) connecting to GOPHER server on %s (%s)\\n\",\n           gp->client_hostname, gp->client_ip_addrstr,\n           gp->server_hostname, gp->server_ip_addrstr);\n }\n\n connrc = Connect(sp->ns, &consock, sizeof(consock));\n if (connrc < 0) {\n   REPORT_TCP_ERROR(gp->ggserver);\n   ERR2(\"TCP/IP failure: connect() failed to connect to server %s.\",\n        gp->ggserver);\n   return FALSE;\n }\n\n sp->connected_to_server = TRUE;\n sp->time_to_go_home     = FALSE;\n sp->connection_broken   = FALSE;\n sp->server_has_nothing  = FALSE;\n sp->dont_read           = FALSE;\n\n GGesrvr(gp,sp);   /* Clean up any stray responses from server. */\n\n return TRUE;\n\n}\n\n./ ADD NAME=GGCSO\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@CSO\")\n#pragma  csect(static,\"GG$CSO\")\n#include \"gg.h\"\n\n /********************************************************************\n  *\n  * The CSO code is due to:\n  *\n  * Lou Joseph     <cwmy5c@irishmvs.cc.nd.edu>\n  * Rachna Agrawal <rachna@clemson.clemson.edu>\n  *\n  ********************************************************************/\n\n/****** Gopher CSO interface. ************************************/\n\nBool\nGGcso(gp,ip,as_file)\nRGGCB   *gp;\nRINFO   *ip;\nGOHOW    as_file;\n{\n RCONN  *sp;\n char   *lp;\n char   *rdel = \":\";\n char   *rtoken;\n char   *rtok\u00dd5\u00a8;\n char   *rstr\u00dd14\u00a8;\n int     a;              /* field counter */\n int     b;              /* field counter */\n int     c;              /* field counter */\n int     d;              /* field counter */\n int     e_index_i;\n Bool    got_some;\n char    ggcsoq\u00dd14\u00a8\u00dd256\u00a8;\n char    ggcsoqt\u00dd256\u00a8;   /* temporary storage for name field *UND* */\n char    e_index_c\u00dd10\u00a8;\n char    sep\u00dd80\u00a8 = \"--------------------\";\n\n sp = &gp->gopher_connection;\n\n strcpy(gp->ggserver,ip->host);     /* Specify server to connect to */\n\n /***** set up fields command to server ***** start ******************/\n\n strcpy(gp->gopher_command,\"fields\");\n\n /***** set up fields command to server ***** end   ******************/\n\n gp->ginfo = ip;\n if (!GGconn(gp,sp)) return FALSE;   /* Connect to CSO server */\n GOPHERSEND(gp,sp);                  /* Send socket command */\n GGclrtx(gp,ip);                     /* Clear text */\n\n for (d = 0; d < 4;  d++) rtok\u00ddd\u00a8 = \"\";\n for (d = 0; d < 14; d++) rstr\u00ddd\u00a8 = \"\";\n\n sp->receiving_text = TRUE;\n got_some = FALSE;\n a = 0;           /* controls that each field is output only once */\n b = 0;           /* counts the server line */\n c = 0;           /* counts number of tokens in each new line */\n d = 0;           /* counts that only some of the fields are saved */\n\n /****** put name field first ** start ** *UND* */\n GETMAIN(rstr\u00ddd\u00a8,char,strlen(\"name\")+1,\"CSO field string\");\n strcpy(rstr\u00ddd\u00a8, \"name\");\n ++d;\n /****** put name field first ** end   ** *UND* */\n\n do {\n   if (GGgsrvl(gp,sp,&lp,NOCR)) {              /* Get server line  */\n     if (lp) {\n       ++b;\n       if (b == 2) {\n          a = 1;\n          b = 0;\n       }      /* end if  (b == 2) */\n       if (a == 1) {                              /* if new entry */\n          c = 0;\n          rtoken = strtok(lp,rdel);\n          while (rtoken != NULL) {\n              rtok\u00ddc\u00a8 = rtoken;\n              ++c;\n              rtoken = strtok(NULL,rdel);\n          }      /* end while  */\n          a = 0;\n          if (d < 14)  {\n            if (strcmp(rtok\u00dd2\u00a8,\"name\") != 0) {  /* *UND*  skip name */\n              GETMAIN(rstr\u00ddd\u00a8,char,strlen(rtok\u00dd2\u00a8)+1,\n                      \"CSO field string\");\n              if (!rstr\u00ddd\u00a8) break;\n              strcpy(rstr\u00ddd\u00a8, rtok\u00dd2\u00a8);\n              ++d;\n            }                                   /* *UND*  skip name */\n          }\n       }    /* end if new entry */\n       got_some = TRUE;\n       if (lp\u00dd0\u00a8 != '-' && strncmp(lp,\"200\",3) >= 0) break;\n     }        /* end if lp */\n   }      /* end if GGgsrvl */\n } while (lp);                            /* until no more lines */\n\n if (!got_some) {\n   WARN2(\"No data available from server %s.\\n\",gp->ggserver);\n   return FALSE;\n }\n\n sp->receiving_text = FALSE;\n\n VPUT(\"FNAME1 \", rstr\u00dd0\u00a8  );\n VPUT(\"FNAME2 \", rstr\u00dd1\u00a8  );\n VPUT(\"FNAME3 \", rstr\u00dd2\u00a8  );\n VPUT(\"FNAME4 \", rstr\u00dd3\u00a8  );\n VPUT(\"FNAME5 \", rstr\u00dd4\u00a8  );\n VPUT(\"FNAME6 \", rstr\u00dd5\u00a8  );\n VPUT(\"FNAME7 \", rstr\u00dd6\u00a8  );\n VPUT(\"FNAME8 \", rstr\u00dd7\u00a8  );\n VPUT(\"FNAME9 \", rstr\u00dd8\u00a8  );\n VPUT(\"FNAME10 \",rstr\u00dd9\u00a8  );\n VPUT(\"FNAME11 \",rstr\u00dd10\u00a8 );\n VPUT(\"FNAME12 \",rstr\u00dd11\u00a8 );\n VPUT(\"FNAME13 \",rstr\u00dd12\u00a8 );\n VPUT(\"FNAME14 \",rstr\u00dd13\u00a8 );\n\n ISPF(\"VGET (FVALUE1) PROFILE\");\n\n if (GGdispl(gp,\"GGMCSO  \") > 0) return FALSE;\n\n VGET(\"FVALUE1 \", ggcsoq\u00dd0\u00a8  );\n VGET(\"FVALUE2 \", ggcsoq\u00dd1\u00a8  );\n VGET(\"FVALUE3 \", ggcsoq\u00dd2\u00a8  );\n VGET(\"FVALUE4 \", ggcsoq\u00dd3\u00a8  );\n VGET(\"FVALUE5 \", ggcsoq\u00dd4\u00a8  );\n VGET(\"FVALUE6 \", ggcsoq\u00dd5\u00a8  );\n VGET(\"FVALUE7 \", ggcsoq\u00dd6\u00a8  );\n VGET(\"FVALUE8 \", ggcsoq\u00dd7\u00a8  );\n VGET(\"FVALUE9 \", ggcsoq\u00dd8\u00a8  );\n VGET(\"FVALUE10 \",ggcsoq\u00dd9\u00a8  );\n VGET(\"FVALUE11 \",ggcsoq\u00dd10\u00a8 );\n VGET(\"FVALUE12 \",ggcsoq\u00dd11\u00a8 );\n VGET(\"FVALUE13 \",ggcsoq\u00dd12\u00a8 );\n VGET(\"FVALUE14 \",ggcsoq\u00dd13\u00a8 );\n\n /***** set up query command to server ****** start ******************/\n strcpy(gp->gopher_command,\"query \");\n if (!*ip->path) {\n    for (a = 0; a < 14; a++)\n        if (strlen(ggcsoq\u00dda\u00a8) != 0) {\n          if (strcmp(rstr\u00dda\u00a8, \"name\") == 0) {           /* *UND* */\n           strcpy(ggcsoqt, ggcsoq\u00dda\u00a8);                  /* *UND* */\n           rtoken = strtok(ggcsoqt,\" \");                /* *UND* */\n           while (rtoken != NULL) {                     /* *UND* */\n             strcat(gp->gopher_command + 6, rstr\u00dda\u00a8);   /* *UND* */\n             strcat(gp->gopher_command, \"=\\\"\");         /* *UND* */\n             strcat(gp->gopher_command, rtoken);        /* *UND* */\n             strcat(gp->gopher_command, \"\\\" \");         /* *UND* */\n             rtoken = strtok(NULL, \" \");                /* *UND* */\n           }     /* end while  */                       /* *UND* */\n          }                                             /* *UND* */\n          else {                                        /* *UND* */\n           strcat(gp->gopher_command + 6, rstr\u00dda\u00a8);\n           strcat(gp->gopher_command, \"=\\\"\");\n           strcat(gp->gopher_command, ggcsoq\u00dda\u00a8);\n           strcat(gp->gopher_command, \"\\\" \");\n          }                                             /* *UND* */\n        }\n }\n else {\n    sprintf(gp->gopher_command + 6,\"%s\\t\",ip->path);\n    for (a = 0; a < 14; a++) {\n          if (strcmp(rstr\u00dda\u00a8, \"name\") == 0) {           /* *UND* */\n           strcpy(ggcsoqt, ggcsoq\u00dda\u00a8);                  /* *UND* */\n           rtoken = strtok(ggcsoqt,\" \");                /* *UND* */\n           while (rtoken != NULL) {                     /* *UND* */\n             strcat(gp->gopher_command + 6, rstr\u00dda\u00a8);   /* *UND* */\n             strcat(gp->gopher_command, \"=\\\"\");         /* *UND* */\n             strcat(gp->gopher_command, rtoken);        /* *UND* */\n             strcat(gp->gopher_command, \"\\\" \");         /* *UND* */\n             rtoken = strtok(NULL, \" \");                /* *UND* */\n           }     /* end while  */                       /* *UND* */\n          }                                             /* *UND* */\n          else {                                        /* *UND* */\n        strcat(gp->gopher_command + 6, rstr\u00dda\u00a8);\n        strcat(gp->gopher_command,\" =\\\"\");\n        strcat(gp->gopher_command, ggcsoq\u00dda\u00a8);\n        strcat(gp->gopher_command, \"\\\" \");\n          }                                             /* *UND* */\n    }\n }\n strcat(gp->gopher_command,\" return all\");\n\n /***** set up query command to server ******* end *******************/\n\n GOPHERSEND(gp,sp);               /* Send socket command */\n GGclrtx(gp,ip);                  /* Clear text */\n\n sp->receiving_text = TRUE;\n got_some = FALSE;\n e_index_i = 2;\n sprintf(e_index_c,\":%u:\",e_index_i);\n do {\n   if (GGgsrvl(gp,sp,&lp,NOCR)) {           /* Get server line */\n     if (lp) {\n       if (strstr(lp,e_index_c) != NULL) {  /* if new entry */\n         (void)GGouttx(gp,sep,ip,NO_VALUE); /* Output separator */\n         ++e_index_i;                       /* Increment index  */\n         sprintf(e_index_c,\":%u:\",e_index_i);\n       }\n       got_some = TRUE;\n       (void)GGouttx(gp,lp,ip,NO_VALUE);    /* Output text line */\n       if (lp\u00dd0\u00a8 != '-' && strncmp(lp,\"200\",3) >= 0) break;\n     }\n   }\n } while (lp);                              /* until no more lines */\n\n if (!got_some) {\n   WARN2(\"No data available from server %s.\\n\",gp->ggserver);\n   return FALSE;\n }\n\n /* Send quit command        */\n\n sp->receiving_text = FALSE;\n strcpy(gp->gopher_command,\"quit\");\n GOPHERSEND(gp,sp);                   /* Send socket command */\n\n /* Read Bye message         */\n\n sp->receiving_text = TRUE;\n\n (void)GGgsrvl(gp,sp,&lp,NOCR);       /* Get server line */\n\n if (sp->connected_to_server) {\n   (void)GGdisc(gp,sp);   /* Disconnect from CSO server */\n }\n\n GGvtx(gp,ip,as_file);    /* display text from CSO server */\n\n for (d = 0; d < 14; d++) {\n   if (*rstr\u00ddd\u00a8) {\n     FREEMAIN(rstr\u00ddd\u00a8,\"CSO field string\");\n   }\n }\n\n return TRUE;\n\n}\n\n./ ADD NAME=GGDBM\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DBM  \")\n#pragma  csect(static,\"GG$DBM  \")\n#include \"gg.h\"\n\n/****** Delete a bookmark from a bookmark data set. ******************/\n\nBool\nGGdbm(gp,ip)\nRGGCB   *gp;\nRINFO   *ip;\n{\n FILE   *xfp;\n char   *bufptr;\n char    test   \u00dd  6\u00a8;\n char    dsname \u00dd129\u00a8;\n char    buffer \u00ddRBUFSIZE\u00a8;\n\n if (!*ip->bmds) {\n   WARN1(\"Delete not possible.  This entry is not from a bookmark.\");\n   return FALSE;\n }\n\n VPUT(\"GGMDBMDS \",ip->bmds);\n VPUT(\"GGMDBMSU \",ip->desc);\n\n ISPF(\"ADDPOP\");\n\n if (GGdispl(gp,\"GGMPDBM \") > 0) {\n   WARN1(\"Deletion cancelled, because you pressed END.\");\n   ISPF(\"REMPOP\");\n   return FALSE;\n }\n\n ISPF(\"REMPOP\");\n\n sprintf(dsname,\"'%s'\",ip->bmds);\n xfp = fopen(dsname,\"r\");\n if (!xfp) {\n   perror(dsname);\n   ERR2(\"Cannot access bookmark data set %s.\",dsname);\n   return FALSE;\n }\n\n for (;;) {\n   *buffer = '\\0';\n   fgets(buffer,sizeof(buffer),xfp);\n   if (ferror(xfp)) {\n     ERR2(\"Error reading bookmark data set %s.\",dsname);\n     break;\n   }\n   if (feof(xfp)) break;\n   if ((bufptr=strchr(buffer,'\\n'))) *bufptr = '\\0';\n   bufptr = skip_whitespace(buffer);\n   CLEAR(test);\n   memcpy(test,bufptr,5);\n   uppercase_in_place(test);\n\n   /*\n   if      (EQUAL(test,\"TYPE=\"))\n   else if (EQUAL(test,\"NAME=\"))\n   else if (EQUAL(test,\"PATH=\"))\n   else if (EQUAL(test,\"HOST=\"))\n   else if (EQUAL(test,\"PORT=\"))\n   else if (EQUAL(test,\"END\"  ))\n\n   */\n\n }\n\n (void)fclose(xfp);\n\n ERR1(\"Bookmark deletion is not yet supported, sorry.\");\n return FALSE;\n\n}\n\n./ ADD NAME=GGDFAIL\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DFAIL\")\n#pragma  csect(static,\"GG$DFAIL\")\n#include \"gg.h\"\n\n/****** Retrieve allocation failure messages. ************************/\n\nvoid\nGGdfail(rc,p99)\nint            rc;\n__S99parms    *p99;\n{\n int           zero = 0;\n unsigned int  dfid = 0x40320000;\n struct {\n         short first_level_msg_len;\n         short first_level_msg_offset;\n         char  first_level_msg\u00dd251\u00a8;\n         short second_level_msg_len;\n         short second_level_msg_offset;\n         char  second_level_msg\u00dd251\u00a8;\n        }      dfbuffer;\n\n static int (*ikjeff18_pointer)() = NULL;\n\n#ifndef FETCH\n extern int *ikjeff18();\n#endif\n\n if (!ikjeff18_pointer) {\n#ifdef FETCH\n   ikjeff18_pointer = (int (*)())fetch(\"IKJEFF18\");\n#else\n   ikjeff18_pointer = (int (*)())ikjeff18;\n#endif\n }\n\n dfbuffer.first_level_msg_len = 4;\n dfbuffer.second_level_msg_len = 4;\n\n if (ikjeff18_pointer) {\n   if ((*ikjeff18_pointer)(p99,&rc,&zero,&dfid,&zero,&dfbuffer)) {\n     fprintf(stderr,\"IKJEFF18 returned a nonzero return code\\n\");\n   }\n   if (dfbuffer.first_level_msg_len > 0) {\n     fprintf(stderr,\"%*.*s\\n\",\n                    dfbuffer.first_level_msg_len-4,\n                    dfbuffer.first_level_msg_len-4,\n                    dfbuffer.first_level_msg);\n   }\n   if (dfbuffer.second_level_msg_len > 0) {\n     fprintf(stderr,\"%*.*s\\n\",\n                    dfbuffer.second_level_msg_len-4,\n                    dfbuffer.second_level_msg_len-4,\n                    dfbuffer.second_level_msg);\n   }\n }\n else {\n#ifdef FETCH\n   fprintf(stderr,\"GGMVS: Cannot fetch IKJEFF18\\n\");\n#else\n   fprintf(stderr,\"Cannot call IKJEFF18, not linked with GGMVS\\n\");\n#endif\n }\n return;\n}\n\n./ ADD NAME=GGDIR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DIR  \")\n#pragma  csect(static,\"GG$DIR  \")\n#include \"gg.h\"\n\n/*********************************************************************/\n\nstatic Bool\nvalid_code(c)\nchar       c;\n{\n\n switch (c) {\n   case GOPHER_FILE:\n   case GOPHER_DIRECTORY:\n   case GOPHER_TELNET:\n   case GOPHER_TN3270:\n   case GOPHER_WAIS:\n   case GOPHER_WHOIS:\n   case GOPHER_CSO:\n   case GOPHER_ERROR:\n   case GOPHER_BOOKMANAGER:\n   case GOPHER_MAC_BINHEX:\n   case GOPHER_DOS_BINARCH:\n   case GOPHER_BINARY:\n   case GOPHER_COMMENT:\n                           return TRUE;\n   default:                return FALSE;\n  }\n\n}\n\n/*********************************************************************/\n\nstatic Bool\nprocess_s_selection(gp,ip)\nRGGCB              *gp;\nRINFO              *ip;\n{\n\n GGgofor(gp,ip,AS_NORMAL);\n return TRUE;\n}\n\n/*********************************************************************/\n\nstatic Bool\nprocess_i_selection(gp,ip)\nRGGCB              *gp;\nRINFO              *ip;\n{\n\n if (!GGinfo(gp,ip)) return FALSE;\n GGvtx(gp,NULL,AS_FILE);\n return TRUE;\n}\n\n/*********************************************************************/\n\nstatic Bool\nprocess_b_selection(gp,ip)\nRGGCB              *gp;\nRINFO              *ip;\n{\n\n if (!GGinfo(gp,ip)) return FALSE;\n gp->extract_file = NULL;\n GGxtx(gp,ip,BOOKMARK_IT);\n return TRUE;\n}\n\n/*********************************************************************/\n\nstatic Bool\nprocess_d_selection(gp,ip)\nRGGCB              *gp;\nRINFO              *ip;\n{\n\n return GGdbm(gp,ip);\n}\n\n/*********************************************************************/\n\nstatic Bool\nprocess_e_selection(gp,ip)\nRGGCB              *gp;\nRINFO              *ip;\n{\n\n if (!ip->thdr.first_text_line) {\n   GGgofor(gp,ip,AS_NOTHING);\n }\n if (!ip->thdr.first_text_line) return FALSE;\n gp->extract_file = NULL;\n GGxtx(gp,ip,EXTRACT_IT);\n return TRUE;\n}\n\n/*********************************************************************/\n\nstatic Bool\nprocess_p_selection(gp,ip)\nRGGCB              *gp;\nRINFO              *ip;\n{\n\n if (!ip->thdr.first_text_line) {\n   GGgofor(gp,ip,AS_NOTHING);\n }\n if (!ip->thdr.first_text_line) return FALSE;\n gp->extract_file = NULL;\n GGxtx(gp,ip,PRINT_IT);\n return TRUE;\n}\n\n/*********************************************************************/\n\nstatic Bool\nprocess_q_selection(gp,ip)\nRGGCB              *gp;\nRINFO              *ip;\n{\n\n GGgofor(gp,ip,AS_FILE);\n return TRUE;\n}\n\n/*********************************************************************/\n\nstatic Bool\ndisplay_dynamic_area(gp,ip,infoarray,entrycount)\nRGGCB               *gp;\nRINFO               *ip;\nGOPHERINFO          *infoarray;\nint                  entrycount;\n{\n GOPHERINFO         *iap;\n int                 depth;\n int                 ggglvl;\n int                 dynsize;\n int                 topitem;\n int                 bottomitem;\n int                 last_item_selected;\n int                 dti;\n int                 gii;\n int                 prc;\n int                 l;\n int                 command_index;\n int                 zscrolln;\n int                 leftcol;\n int                 maxcol;\n int                 menucursor;\n Bool                selok;\n Bool                cmdok;\n Bool                is_max;\n Bool                is_csr;\n char               *gggdyna;\n char               *rowp;\n char               *cp;\n char                gggcmd     \u00dd72\u00a8;\n char                zverb       \u00dd9\u00a8;\n char                zscrolla    \u00dd9\u00a8;\n char                command    \u00ddCOMMANDSIZE\u00a8;\n char                ggghead    \u00dd81\u00a8;\n char                rowmessage \u00dd81\u00a8;\n\n /* Get depth of dynamic area (number of rows to display on screen) */\n\n ISPF(\"PQUERY PANEL(GGMDIR) AREANAME(GGGDYNA) DEPTH(GGGDEPTH)\");\n if (gp->ispfrc != 0) return FALSE;\n depth = IGET(\"GGGDEPTH \");\n\n /* Get storage for ISPF dynamic area variable to be constructed. */\n\n dynsize = 80*depth;\n GETMAIN(gggdyna, char, dynsize+1, \"GGGDYNA buffer\");\n if (!gggdyna) return FALSE;\n\n /* Loop displaying the panel until END pressed. */\n\n last_item_selected = -1;\n strcpy(gggcmd,\"\");\n topitem    = 0;\n leftcol    = 0;\n menucursor = 0;\n prc        = 0;\n maxcol     = 0;\n for (gii = 0; gii < entrycount; gii++) {\n   l = strlen(infoarray\u00ddgii\u00a8.desc);\n   if (maxcol < l) maxcol = l;\n }\n\n while (prc == 0) {\n\n /* Fill in the dynamic area with rows, one for each gopher item. */\n\n   memset(gggdyna,' ',dynsize);\n   menucursor = 0;\n\n   for (dti = 0,       gii = topitem,     rowp = gggdyna;\n        dti < depth && gii < entrycount;\n        dti++,         gii++,             rowp += 80) {\n     iap = &infoarray\u00ddgii\u00a8;\n     if (gp->autocursor && gii == last_item_selected) {\n       menucursor = rowp + 2 - gggdyna;\n     }\n     if (iap->type == GOPHER_COMMENT\n      || iap->type == GOPHER_ERROR)\n       rowp\u00dd 0\u00a8 = DATAOUT_HIGH;          /* selection code protected */\n     else\n       rowp\u00dd 0\u00a8 = DATAIN_HIGH;           /* selection code attribute */\n     rowp\u00dd 1\u00a8 = ' ';                     /* selection code field     */\n     rowp\u00dd 2\u00a8 = DATAOUT_GREEN;           /* icon attribute           */\n     memcpy(&rowp\u00dd 3\u00a8,GGtype(iap->type),9);\n     rowp\u00dd12\u00a8 = DATAOUT_HIGH;            /* description attribute    */\n     l = strlen(iap->desc) - leftcol;\n     if (l > 0) memcpy(&rowp\u00dd13\u00a8, iap->desc + leftcol, l>67 ? 67 : l);\n   }\n\n   if (rowp < gggdyna + dynsize) {\n     rowp\u00dd0\u00a8 = DATAOUT_HIGH;\n     memset(&rowp\u00dd1\u00a8, '-',79);\n   }\n\n   bottomitem = gii - 1;\n   if (topitem > bottomitem) strcpy(rowmessage,\"\");\n   else sprintf(rowmessage, \" %d-%d of %d\",\n                            topitem + 1, bottomitem + 1, entrycount);\n   memset(ggghead,' ',79);\n   ggghead\u00dd79\u00a8 = '\\0';\n   strcpy(ggghead,\"GOPHER - \");\n   strncpy(ggghead+9,ip->desc,70);\n   *strchr(ggghead,'\\0') = ' ';\n   memcpy(ggghead+79-strlen(rowmessage),rowmessage,strlen(rowmessage));\n\n   if (menucursor > 0) {\n     IPUT(\"GGGCSR \", menucursor);\n   }\n   else VPUT(\"GGGCSR \", \"0\");\n   VPUTS(\"GGGHEAD \",ggghead,79);\n   VPUTS(\"GGGDYNA \",gggdyna, dynsize);\n   VPUT (\"GGGCMD \" ,gggcmd);\n\n   if ((prc=GGdispl(gp,\"GGMDIR  \")) > 8) break;\n\n   VGETS(\"GGGDYNA \" , gggdyna, dynsize);\n   VGET (\"ZVERB \"   , zverb);\n   VGET (\"ZSCROLLA \", zscrolla);\n   zscrolln = IGET(\"ZSCROLLN \");\n   ggglvl   = IGET(\"GGGLVL \");\n   last_item_selected = -1;\n\n   /* Process selections. */\n\n   for (gii = topitem,     rowp = gggdyna;\n        gii <= bottomitem;\n        gii++,             rowp += 80) {\n     iap = &infoarray\u00ddgii\u00a8;\n     switch (toupper(rowp\u00dd1\u00a8)) {\n       case ' ':  continue;\n       case 'S':  selok = process_s_selection(gp,iap); break;\n       case 'E':  selok = process_e_selection(gp,iap); break;\n       case 'P':  selok = process_p_selection(gp,iap); break;\n       case 'Q':  selok = process_q_selection(gp,iap); break;\n       case 'I':  selok = process_i_selection(gp,iap); break;\n       case 'B':  selok = process_b_selection(gp,iap); break;\n   /*  case 'D':  selok = process_d_selection(gp,iap); break; */\n       default:\n        ERR1(\"Unknown selection code.  Type one of the listed codes.\");\n                  selok = FALSE;                       break;\n     }\n     if (selok) last_item_selected = gii;\n     if (gp->quit) break;\n   }\n\n   /* Process command if any. */\n\n   VGET(\"GGGCMD \",gggcmd);\n   if (*gggcmd) {\n     cmdok = TRUE;\n     memset(command,' ',COMMANDSIZE);\n     command_index = 0;\n     for (cp = gggcmd; *cp && !isspace(*cp); cp++) {\n       if (cp >= gggcmd+COMMANDSIZE) {\n         ERR1(\n \"Invalid command.  Try \\\"OPTIONS\\\", \\\"MENU bookmarkname\\\", \\\"QUIT\\\"\");\n         cmdok = FALSE;\n       }\n       command\u00ddcommand_index++\u00a8 = toupper(*cp);\n     }\n     while (*cp && isspace(*cp)) cp++;\n     if      (!memcmp(command,\"QUIT    \",8)) gp->quit = TRUE;\n     else if (!memcmp(command,\"MENU    \",8)) GGmenu(gp,cp);\n     else if (!memcmp(command,\"OPT     \",8)\n           || !memcmp(command,\"OPTION  \",8)\n           || !memcmp(command,\"OPTIONS \",8)) GGdsopt(gp,cp);\n     else if (!memcmp(command,\"TEST    \",8)) {\n                                              gp->test_mode = TRUE;\n                                              __ctest(NULL);\n                                             }\n     else {\n       ERR1(\n \"Unknown command.  Try \\\"OPTIONS\\\", \\\"MENU bookmarkname\\\", \\\"QUIT\\\"\");\n       cmdok = FALSE;\n     }\n     if (cmdok) strcpy(gggcmd,\"\");\n   }\n\n   if (gp->quit) break;\n\n   if (last_item_selected >= 0 && gp->autoscroll) {\n     topitem = last_item_selected;\n   }\n\n   /* Process scroll request if any. */\n\n   is_max = EQUAL(zscrolla,\"MAX\");\n   is_csr = zscrolla\u00dd0\u00a8 == 'C';\n   if      (EQUAL(zverb,\"DOWN\")) {\n     if (is_max) topitem = entrycount - ggglvl;\n     else        topitem += zscrolln;\n   }\n   else if (EQUAL(zverb,\"UP\")) {\n     if (is_max) topitem = 0;\n     else        topitem -= zscrolln;\n   }\n   else if (EQUAL(zverb,\"LEFT\")) {\n     if (is_max) leftcol = 0;\n     else        leftcol -= zscrolln;\n   }\n   else if (EQUAL(zverb,\"RIGHT\")) {\n     if (is_csr) zscrolln -= 13;\n     if (is_max) leftcol = maxcol - 67;\n     else        leftcol += zscrolln;\n   }\n   else if (EQUAL(zverb,\"RETURN\")) {\n     gp->quit = TRUE;\n     break;\n   }\n   if (topitem < 0)          topitem = 0;\n   if (topitem > entrycount) topitem = entrycount;\n   if (leftcol < 0)          leftcol = 0;\n   if (leftcol > maxcol)     leftcol = maxcol;\n\n } /* end while prc == 0 */\n\n return;\n\n}\n\n/****** Gopher a directory. ******************************************/\n\nBool\nGGdir(gp,ip,how)\nRGGCB      *gp;\nRINFO      *ip;\nGOHOW       how;\n{\n int            entrycount;\n int            i;\n int            copysize;\n char           typechar;\n char           savechar;\n char          *p;\n char          *q;\n char          *r;\n TEXTLINE      *tp;\n GOPHERINFO    *infoarray;\n GOPHERINFO    *iap;\n char           temp \u00dd16\u00a8;\n\n switch (how) {\n   case AS_FILE:    GGvtx(gp,ip,AS_FILE);  /* display text as is */\n                    return TRUE;\n   case AS_NOTHING: return TRUE;           /* prepare for extract */\n   case AS_NORMAL:\n   default:         break;\n }\n\n /* The text chain contains the data from the server, which should be\n  * in the following format:\n  *\n  * nDescription\u00acPath\u00acfoo\u00acbar\n  *\n  * where the \"n\" in the beginning is a digit and \u00ac means a tab char.\n  *\n  * Logic:\n  *\n  * Build an array of gopherinfo structs from the text records.\n  * Display them as an ISPF dynamic area pseudotable.\n  * Let the user select them, and run GGgofor on each one\n  * with a struct gopherinfo built from the contents.\n  *\n  */\n\n /* Determine size of array of gopherinfo structs.  This is equal to\n  * the number of text records with a valid code in the first byte.\n  */\n\n entrycount = 0;\n for (tp = ip->thdr.first_text_line; tp; tp = tp->next) {\n   if (valid_code(tp->text\u00dd0\u00a8)) entrycount++;\n }\n\n if (entrycount == 0) {\n   ERR1(\"There seems to be no information in this directory.\\n\");\n   return FALSE;\n }\n\n /* Allocate an array of structs to hold the stuff. */\n\n GETMAIN(infoarray, struct gopherinfo, entrycount,\"gopherinfo array\");\n\n if (!infoarray) {\n   ERR2(\"Not enough memory for %d gopher directory entries\\n\",\n        entrycount);\n   return FALSE;\n }\n\n /* Build the array entries. */\n\n iap = infoarray;\n for (tp = ip->thdr.first_text_line; tp; tp = tp->next) {\n   typechar = tp->text\u00dd0\u00a8;\n   if (valid_code(typechar)) {\n     r = &tp->text\u00ddtp->text_length\u00a8;\n     savechar = *r;\n     *r = '\\t';\n     memset(iap,0,sizeof(struct gopherinfo));\n     iap->port = GOPHER_PORT_NUMBER;\n     iap->type = (GOPHERTYPE)typechar;\n     p = &tp->text\u00dd1\u00a8;\n     q = strchr(p,'\\t');\n     copysize = sizeof(iap->desc)-1;\n     if (copysize > q-p) copysize = q-p;\n     memcpy(iap->desc,p,copysize);\n     if (q < r) {\n       p = q+1;\n       q = strchr(p,'\\t');\n       copysize = sizeof(iap->path)-1;\n       if (copysize > q-p) copysize = q-p;\n       memcpy(iap->path,p,copysize);\n       if (q < r) {\n         p = q+1;\n         q = strchr(p,'\\t');\n         copysize = sizeof(iap->host)-1;\n         if (copysize > q-p) copysize = q-p;\n         memcpy(iap->host,p,copysize);\n         if (q < r) {\n           p = q+1;\n           q = strchr(p,'\\t');\n           memset(temp,0,sizeof(temp));\n           copysize = sizeof(temp)-1;\n           if (copysize > q-p) copysize = q-p;\n           memcpy(temp,p,copysize);\n           iap->port = atoi(temp);\n         }\n       }\n     }\n     strcpy(iap->bmds,gp->current_bookmark_ds);\n     *r = savechar;\n     iap++;\n   }\n }\n\n if (gp->debug_mode) {\n   for (iap = infoarray, i = entrycount; i > 0; iap++, i--) {\n     fprintf(gp->debug_file,\"GGdir: type = %d\\n\",iap->type);\n     fprintf(gp->debug_file,\"GGdir: port = %d\\n\",iap->port);\n     fprintf(gp->debug_file,\"GGdir: path = %s\\n\",iap->path);\n     fprintf(gp->debug_file,\"GGdir: host = %s\\n\",iap->host);\n     fprintf(gp->debug_file,\"GGdir: desc = %s\\n\",iap->desc);\n     fprintf(gp->debug_file,\"GGdir: bmds = %s\\n\",iap->bmds);\n     fprintf(gp->debug_file,\"\\n\");\n   }\n }\n\n display_dynamic_area(gp,ip,infoarray,entrycount);\n\n FREEMAIN(infoarray,\"gopherinfo array\");\n\n return TRUE;\n}\n\n./ ADD NAME=GGDISC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DISC \")\n#pragma  csect(static,\"GG$DISC \")\n#include \"gg.h\"\n\n/****** Disconnect from gopher server. ********************************/\n\nvoid\nGGdisc(gp,sp)\nRGGCB *gp;\nRCONN *sp;\n{\n RECV *R;\n\n /* If local mode, close temporary file and return. */\n\n if ((R=gp->recvp)) {\n   if (R->outfp) {\n     if (fclose(R->outfp) < 0) {\n       CRIT1(\"Error closing local mode temporary file\");\n     }\n     R->outfp = NULL;\n   }\n   sp->connected_to_server = FALSE;\n   FREEMAIN(gp->recvp,\"local mode recv struct\");\n   gp->recvp = NULL;\n   return;\n }\n\n sp->closing_connection = TRUE;\n\n if (sp->connection_broken) {\n   if (gp->debug_file) {\n     fprintf(gp->debug_file,\n  \"Client %s (%s) connection with gopher server on %s (%s) was lost\\n\",\n          gp->client_hostname,\n          gp->client_ip_addrstr,\n          gp->server_hostname,\n          gp->server_ip_addrstr);\n   }\n   sp->connected_to_server = FALSE;\n }\n else {\n\n   if (gp->debug_file) {\n     fprintf(gp->debug_file,\n      \"Client %s (%s) disconnecting from gopher server on %s (%s)\\n\",\n          gp->client_hostname,\n          gp->client_ip_addrstr,\n          gp->server_hostname,\n          gp->server_ip_addrstr);\n   }\n\n   VPUT(\"GGSOLDER \",gp->server_hostname);\n   VPUT(\"GGSOLDIP \",gp->server_ip_addrstr);\n   ISPF(\"CONTROL DISPLAY LOCK\");\n   ISPF(\"DISPLAY PANEL(GGMLDISC)\");\n\n   GGesrvr(gp,sp);                   /* End server read */\n\n   sp->connected_to_server = FALSE;\n\n   if (close(sp->ns) < 0) {\n     ERR2(\"TCP/IP error: close() failed to disconnect from server %s.\",\n          gp->ggserver);\n   }\n }\n\n return;\n}\n\n./ ADD NAME=GGDISPL\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DISPL\")\n#pragma  csect(static,\"GG$DISPL\")\n#include \"gg.h\"\n\n#ifdef FETCH\n#define VL_BIT(X) ((unsigned int)(X) | 0x80000000)\n#else\n#define VL_BIT(X) (X)\n#endif\n\n/****** Display ISPF panel. ******************************************/\n\nint\nGGdispl(gp,pan8)\nRGGCB  *gp;\nchar   *pan8;\n{\n\n if (gp->setmsg)\n      gp->ispfrc = ISPLINK(\"DISPLAY \", pan8, VL_BIT(\"ISRZ002 \"));\n else gp->ispfrc = ISPLINK(\"DISPLAY \", VL_BIT(pan8));\n\n if (gp->ispfrc > 8) GGierr(gp);   /* display ISPF error */\n gp->setmsg = FALSE;\n return gp->ispfrc;\n}\n\n./ ADD NAME=GGDSOPT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DSOPT\")\n#pragma  csect(static,\"GG$DSOPT\")\n#include \"gg.h\"\n\n/****** Set options. *************************************************/\n\nstatic void\nsetoptions(gp,panelname,which)\nRGGCB     *gp;\nchar      *panelname;\nOPTION     which;\n{\n\n while (GGdispl(gp,panelname) == 0) {\n   GGsopt(gp,which);               /* Actually set options */\n }\n\n return;\n}\n\n/****** Option ... set GOPHER default processing options. ***********/\n\nvoid\nGGdsopt(gp,option)\nRGGCB  *gp;\nchar   *option;\n{\n Bool   force_choice = FALSE;\n char   ggchoice \u00dd9\u00a8;\n\n static char *message = \"Invalid choice;\\\nMove the cursor to a selection (or type S next to it) and press ENTER.\";\n\n for (;;) {\n   if (!force_choice && option && *option) {\n     strncpy(ggchoice,option,sizeof(ggchoice)-1);\n   }\n   else {\n     ISPF(\"ADDPOP\");\n     if (GGdispl(gp,\"GGMPOPT \") > 0) {\n       ISPF(\"REMPOP\");\n       break;\n     }\n     VGET(\"GGCHOICE \",ggchoice);\n     if (*ggchoice == '?') ERR1(message);\n     ISPF(\"REMPOP\");\n   }\n   if      (EQUAL(ggchoice,\"1\")) setoptions(gp,\"GGMOPT1 \",OPTION_VIEW);\n   else if (EQUAL(ggchoice,\"2\")) setoptions(gp,\"GGMOPT2 \",OPTION_OTHER);\n   else {\n     ERR1(message);\n     force_choice = TRUE;\n     continue;\n   }\n   break;\n }\n\n return;\n\n}\n\n./ ADD NAME=GGDUMP\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DUMP \")\n#pragma  csect(static,\"GG$DUMP \")\n#include \"gg.h\"\n\n/****** Dump some data. **********************************************/\n\nvoid\nGGdump(GGCB *gp,\n       char *label,\n       char *p,\n       int   r)\n{\n int         i;\n\n if (!gp->debug_file) return;\n switch (r) {\n   case -2: fprintf(gp->debug_file,\"%s:  %d\\n\",label,(int)p); return;\n   case -1: r = strlen(p); break;\n }\n fprintf(gp->debug_file,\"%s:   (%d characters)\\n\",label,r);\n fprintf(gp->debug_file, \"---------------------------------------\"\n                         \"--------------------------------------\\n\");\n for (i=0;i<r;i++) {\n   if (isprint(p\u00ddi\u00a8)) fprintf(gp->debug_file,\"%c\",p\u00ddi\u00a8);\n   else               fprintf(gp->debug_file,\"<0x%2.2x>\",p\u00ddi\u00a8);\n }\n fprintf(gp->debug_file,\"\\n\");\n fprintf(gp->debug_file, \"---------------------------------------\"\n                         \"--------------------------------------\\n\");\n return;\n\n}\n\n./ ADD NAME=GGESRVR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@ESRVR\")\n#pragma  csect(static,\"GG$ESRVR\")\n#include \"gg.h\"\n\n/****** End server read. *********************************************/\n\nvoid\nGGesrvr(gp,sp)\nRGGCB  *gp;\nRCONN  *sp;\n{\n char  *lp;\n Bool   found_more_server_data = FALSE;\n\n if (!gp) return;\n GGclrtx(gp,NULL);                     /* Clear text */\n if (gp->recvp) return;                /* Skip if non-socket */\n\n while (GGgsrvl(gp,sp,&lp,NOCR)) {     /* Get server line */\n   if (!lp) break;\n   found_more_server_data = TRUE;\n   (void)GGouttx(gp,lp,NULL,NO_VALUE); /* Output text line */\n }\n\n if (found_more_server_data) {\n   ERR1(\"More data was returned by the GOPHER server than expected.\");\n   GGvtx(gp,NULL,TRUE);                /* View text */\n }\n\n return;\n}\n\n./ ADD NAME=GGFREEM\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@FREEM\")\n#pragma  csect(static,\"GG$FREEM\")\n#include \"gg.h\"\n\n/****** Free memory. *************************************************/\n\nvoid\nGGfreem(gp,stuff,whatfor)\nRGGCB  *gp;\nchar   *stuff;\nchar   *whatfor;\n{\n\n free(stuff);\n if (gp && gp->debug_file) {\n   fprintf(gp->debug_file,\"GGfreem: freed memory for %s\\n\", whatfor);\n }\n return;\n\n}\n\n./ ADD NAME=GGFTP\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@FTP\")\n#pragma  csect(static,\"GG$FTP\")\n\n#include \"gg.h\"\n\n /* Logic: use basic FTP protocol to get a directory or a file and\n  *        write the results to the passed file pointer.\n  *        Note: does not use PASV (win).\n  */\n\n#define  IPPORT_FTPD    20                /* FTP data port */\n#define  IPPORT_FTP     21                /* FTP control port */\n#define  SHOW(A)        fprintf(stderr,\"%s\\n\",(A))\n#define  BLATHER        if (F->verboseflag) fprintf\n#define  FLOSE          cleanup(F); return(FALSE)\n#define  FSEND(A,B)     if (!fsend(F,CS,(A),(B))) {FLOSE;}\n#define  FRECV()        if (!frecv(F,CS,TRUE))    {FLOSE;}\n#define  FEXPECT(A)     if (!fexpect(F,A))        {FLOSE;}\n\n/* ---- Format an FTP port address. -------------------------------- */\n\nstatic void\nport_address(\n             struct Ftp  *F,         /* needed by BLATHER macro */\n             IPADDRESS    addrnum,\n             int          portnum,\n             char        *c\n            )\n{\n char                    *ap = (char *)&addrnum;\n char                    *pp = (char *)&portnum;\n\n BLATHER(stderr,\"port_address: addrnum=%8.8X, portnum=%8.8X\\n\",\n                addrnum,portnum);\n\n sprintf(c,\"%d,%d,%d,%d,%d,%d\", (unsigned char)*(ap+0),\n                                (unsigned char)*(ap+1),\n                                (unsigned char)*(ap+2),\n                                (unsigned char)*(ap+3),\n                                (unsigned char)*(pp+2),\n                                (unsigned char)*(pp+3));\n\n return;\n}\n\n/* ---- Close socket. ---------------------------------------------- */\n\nstatic Bool\nftp_close(\n          struct Ftp  *F,\n          SOCKETNO     s\n         )\n{\n\n BLATHER(stderr,\"Closing socket %d\\n\",s);\n\n if (close(s) < 0) {\n   REPORT_TCP_ERROR(\"close\");\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/* ---- Connect to the FTP server host. ---------------------------- */\n\nstatic SOCKETNO\nftp_connect(\n            struct Ftp  *F,\n            char        *ftphost\n           )\n{\n SOCKETNO                ftpsock;\n int                     bindrc;\n int                     listrc;\n int                     connrc;\n char                    ipstring\u00dd65\u00a8;\n\n ftpsock = -1;\n gethostname(F->client_hostname,sizeof(F->client_hostname));\n F->client_hostent = gethostbyname(F->client_hostname);\n if (!F->client_hostent) {\n   REPORT_TCP_ERROR(\"gethostbyname for client hostname\");\n   return -1;\n }\n F->hostaddress = *(IPADDRESS *)F->client_hostent->h_addr_list\u00dd0\u00a8;\n\n SPRINTF_IP_ADDRESS(ipstring,F->hostaddress);\n BLATHER(stderr,\"client %s \u00dd%s\u00a8\\n\",F->client_hostname,ipstring);\n\n ftpsock = socket(AF_INET, SOCK_STREAM, 0);\n if (ftpsock < 0) {\n   REPORT_TCP_ERROR(\"socket\");\n   return -1;\n }\n\n F->bindsock.sin_family      = AF_INET;\n F->bindsock.sin_port        = 0;\n F->bindsock.sin_addr.s_addr = F->hostaddress;\n\n bindrc = Bind(ftpsock,&F->bindsock,sizeof(F->bindsock));\n if (bindrc < 0) {\n   REPORT_TCP_ERROR(\"bind for client\");\n   return -1;\n }\n\n F->server_hostent = gethostbyname(ftphost);\n if (!F->server_hostent) {\n   fprintf(F->errfp,\"gethostbyname: unknown host %s\\n\",ftphost);\n   return -1;\n }\n F->hostaddress = *(IPADDRESS *)F->server_hostent->h_addr;\n strcpy(F->server_hostname,ftphost);\n SPRINTF_IP_ADDRESS(ipstring,F->hostaddress);\n BLATHER(stderr,\"server %s \u00dd%s\u00a8\\n\",F->server_hostname,ipstring);\n\n F->consock.sin_family      = AF_INET;\n F->consock.sin_port        = htons(IPPORT_FTP);\n F->consock.sin_addr.s_addr = F->hostaddress;\n\n connrc = Connect(ftpsock,&F->consock,sizeof(F->consock));\n if (connrc < 0) {\n   REPORT_TCP_ERROR(ftphost);\n   return -1;\n }\n\n return ftpsock;\n}\n\n/* --- Get a response from the FTP server. ------------------ */\n\nstatic Bool\nfrecv(F,S,doread)\nstruct Ftp   *F;\nCONNECTION   *S;\nBool          doread;\n{\n\n S->dont_read = !doread;\n if (!GGgsrvl(NULL,S,NULL,NOCR)) return FALSE;\n if (S->time_to_go_home)    return FALSE;\n if (S->server_has_nothing) return TRUE;\n if (F->verboseflag) SHOW(S->server_buf);\n return TRUE;\n\n}\n\n/* --- Send a request to the FTP server. ----------------------- */\n\nstatic Bool\nfsend(F,S,text,arg)\nstruct Ftp  *F;\nCONNECTION  *S;\nchar        *text;\nchar        *arg;\n{\n\n /* check if there's anything pending from the server before sending */\n\n (void)frecv(F,S,FALSE);\n sprintf(S->client_buf,text,arg);\n if (F->verboseflag) SHOW(S->client_buf);\n return GGsockt(NULL,S);\n}\n\n/* --- Retrieve a response and insure it was the expected one. -- */\n\nstatic Bool\nfexpect(F,mesid)\nstruct Ftp   *F;\nchar         *mesid;\n{\n CONNECTION  *S = &F->control_connection;\n\n for (;;) {\n   if (!frecv(F,S,TRUE)) return FALSE;\n   if (S->server_buf\u00dd0\u00a8 == '\\0') continue;\n   if (S->server_buf\u00dd0\u00a8 == ' ')  continue;\n   if (strlen(S->server_buf) > 3) {\n     if (!memcmp(mesid,S->server_buf,3)) {\n       if (S->server_buf\u00dd3\u00a8 == '-')  continue;\n       if (S->server_buf\u00dd3\u00a8 == '\\0') break;\n       if (S->server_buf\u00dd3\u00a8 == ' ')  break;\n     }\n   }\n   fprintf(F->errfp,\"Unexpected FTP response from %s:\\n%s\\n\",\n                    F->server_hostname, S->server_buf);\n   return FALSE;\n }\n\n return TRUE;\n}\n\n/*================================================================*/\n\nstatic GOPHERTYPE\nviewtype(char *fname)\n{\n int           len = strlen(fname);\n int           i;\n\n#define SUFFIX_TO_TYPE(A,B)  i = sizeof(A)-1; \\\n                             if (len > i && !memcmp(fname+len-i,A,i)) \\\n                                return B;\n\n SUFFIX_TO_TYPE(\".gif\"  ,GOPHER_IMAGE);\n SUFFIX_TO_TYPE(\".pict\" ,GOPHER_IMAGE);\n SUFFIX_TO_TYPE(\".tiff\" ,GOPHER_IMAGE);\n SUFFIX_TO_TYPE(\".jpg\"  ,GOPHER_IMAGE);\n SUFFIX_TO_TYPE(\".jpeg\" ,GOPHER_IMAGE);\n SUFFIX_TO_TYPE(\".hqx\"  ,GOPHER_MAC_BINHEX);\n SUFFIX_TO_TYPE(\".arc\"  ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".exe\"  ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".EXE\"  ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".gz\"   ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".gzip\" ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".hqx\"  ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".snd\"  ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".tar\"  ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".Z\"    ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".zip\"  ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".zoo\"  ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".au\"   ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".au.\"  ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".gsm\"  ,GOPHER_BINARY);\n SUFFIX_TO_TYPE(\".netdata\" ,GOPHER_BINARY);\n\n return GOPHER_FILE;\n}\n\n/*================================================================*/\n\nstatic Bool\nls_to_gopher(struct Ftp *F,\n             char       *buf,\n             int        *lenp\n            )\n\n{\n#define     NUMBER_OF_WORDS  12\n char      *outnamep;\n char      *word\u00ddNUMBER_OF_WORDS\u00a8;\n char      *cp;\n char      *ep;\n char      *name;\n char      *symlink;\n char       mode;\n int        i;\n int        maxwords;\n char       outtype;\n char       vmname  \u00dd 33\u00a8;\n char       empath  \u00dd513\u00a8;\n char       rfile   \u00dd513\u00a8;\n char       outname \u00dd513\u00a8;\n char       outpath \u00dd513\u00a8;\n\n for (i = 0; i < NUMBER_OF_WORDS; i++) word\u00ddi\u00a8 = \"\";\n\n /* Loop setting word\u00dd...\u00a8 pointers to words in the buffer. */\n\n buf\u00dd*lenp\u00a8 = '\\0';\n\n /* Count the number of whitespace-delimited words on the line. */\n\n for (i = 0, cp = skip_whitespace(buf);\n      i < NUMBER_OF_WORDS;\n      cp = skip_whitespace(ep)) {\n   word\u00ddi++\u00a8 = cp;\n   ep = strchr(cp,' ');\n   if (!ep) break;\n }\n\n maxwords = i;\n\n /*\n  * Normal Unix-style ls output:\n  *\n  * 0     1     2     3     4     5     6    7\n  * mode  block user  size  month day   time name\n  *\n  * or\n  *\n  * 0     1     2     3     4     5     6    7     8\n  * mode  block user  group size  month day  time  name\n  *\n  * or\n  *\n  * 0     1     2     3     4     5     6    7     8     9    10\n  * mode  block user  group size  month day  time  name  -->  real\n  *\n  *\n  * VM/CMS server output:\n  *\n  * 0     1     2     3     4     5     6    7     8\n  * fname fmode ftype stuff stuff stuff date time  disk?\n  *\n  */\n\n if (maxwords < 8) return FALSE;\n else if (F->os == VM_OS) {\n   if ((ep=strchr(word\u00dd0\u00a8,' '))) *ep = '\\0';\n   if ((ep=strchr(word\u00dd1\u00a8,' '))) *ep = '\\0';\n   sprintf(vmname,\"%s.%s\",word\u00dd0\u00a8,word\u00dd1\u00a8);\n   mode    = '-';\n   name    = vmname;\n   symlink = \"\";\n }\n else {\n   mode = *word\u00dd0\u00a8;\n   symlink = \"\";\n   if      (maxwords == 8)     name = word\u00dd7\u00a8;\n   else if (isdigit(*word\u00dd4\u00a8)) name = word\u00dd8\u00a8;\n   else                        name = word\u00dd7\u00a8;\n   if (mode == 'l' || mode == 'L') {\n     ep = strstr(name,\" -> \");\n     if (ep) {\n       *ep = '\\0';\n       symlink = skip_whitespace(ep+3);\n     }\n   }\n }\n\n BLATHER(stderr,\"maxwords=%d,name=%s,mode=%c,symlink=%s\\n\",\n                maxwords,name,mode,symlink);\n\n if (!*name) return FALSE;\n\n#define PATH_SIZE_LIMIT 40\n\n if (strlen(F->path) > PATH_SIZE_LIMIT) {\n   strcpy(empath, F->path + strlen(F->path) - PATH_SIZE_LIMIT);\n }\n else {\n   strcpy(empath, F->path);\n }\n\n /*\n  * Replace a symbolic link by the file to which it points.  E.g.:\n  *\n  * /any-path     ->  /absolute/path      ==>  /absolute/path\n  * /foo/bar/baz  ->  relative/path       ==>  /foo/bar/relative/path\n  * /foo/bar/baz/ ->  relative/path       ==>  /foo/bar/relative/path\n  * foobar        ->  relative/path       ==>  relative/path\n  *\n  */\n\n if (*symlink) {\n   if (symlink\u00dd0\u00a8 == '/')  strcpy(rfile,symlink);\n   else {\n     if (name\u00dd0\u00a8 == '/')     strcpy(rfile,name);\n     else                    sprintf(rfile,\"%s/%s\",F->path,name);\n     /* strcpy(rfile,F->path); */\n     cp = strrchr(rfile,'/');\n     if (cp && *(cp+1) == '\\0') {\n       *cp = '\\0';\n       cp = strrchr(rfile,'/');\n     }\n     if (!cp) cp = rfile-1;\n     strcpy(cp+1,symlink);\n   }\n   sprintf(outname,\"%s: %s:     %s -> %s\",F->host,empath,name,symlink);\n }\n else {\n   if (name\u00dd0\u00a8 == '/')     strcpy(rfile,name);\n   else                    sprintf(rfile,\"%s/%s\",F->path,name);\n   sprintf(outname,\"%s: %s:     %s\",F->host,empath,name);\n }\n\n switch (mode) {\n   case '-': outtype = viewtype(rfile); break;\n   case 'd':\n   case 'D': outtype = GOPHER_MENU; break;\n   case 'l':\n   case 'L': outtype = GOPHER_MENU; break;\n   default:  BLATHER(stderr,\"Unknown mode '%c'\\n\",mode); return FALSE;\n }\n\n if (strlen(outname) > 255) outnamep = outname + strlen(outname) - 255;\n else                       outnamep = outname;\n\n sprintf(outpath,\"%s%c:%s:%s:%s:%s\",\n                 F->ftphack, outtype, F->host, F->user, F->pass, rfile);\n\n sprintf(buf,\"%c%s\\t%s\\t%s\\t%d\\n\",\n             outtype, outnamep, outpath, F->myname, F->myport);\n\n (*lenp) = strlen(buf);\n\n return TRUE;\n}\n\n/*================================================================*/\n\nstatic int\nemit(struct Ftp *F,\n     char       *buf,\n     int         len\n    )\n{\n int             fwriterc;\n Bool            got_a_record;\n char            newbuf \u00dd23448\u00a8;\n\n   memcpy(newbuf,buf,len);\n\n   if (F->listflag) {\n     got_a_record = ls_to_gopher(F,newbuf,&len);\n   }\n   else if (F->binary) {\n     got_a_record = TRUE;\n   }\n   else {\n     newbuf\u00ddlen++\u00a8 = '\\n';\n     got_a_record = TRUE;\n   }\n   if (got_a_record) {\n     fwriterc = fwrite(newbuf,1,len,F->outfp);\n     if (fwriterc < len) {\n       fprintf(stderr,\"Error writing to FTP output file\\n\");\n     }\n   }\n   else fwriterc = 0;\n\n   return fwriterc;\n\n}\n\n/*================================================================*/\n\nstatic void\ncleanup(struct Ftp *F)\n{\n CONNECTION        *CS = &F->control_connection;\n CONNECTION        *DS = &F->data_connection;\n\n if (F->listen_socket_opened) {\n   (void)ftp_close(F,F->listensocket);\n   F->listen_socket_opened = FALSE;\n }\n\n if (F->accept_socket_opened) {\n   (void)ftp_close(F,DS->ns);\n   F->accept_socket_opened = FALSE;\n }\n\n if (F->control_socket_opened) {\n   (void)ftp_close(F,CS->ns);\n   F->control_socket_opened = FALSE;\n }\n\n}\n\n/*================================================================*/\n\nBool\nGGftp(RECV        *R,\n      struct Ftp  *F\n     )\n{\n CONNECTION          *CS = &F->control_connection;\n CONNECTION          *DS = &F->data_connection;\n char                *ftpgetf = NULL;\n char                *ftproot = NULL;\n char                *cp;\n Bool                 rc = FALSE;\n int                  socksize;\n int                  accept_count;\n int                  bytes_to_write;\n int                  fwriterc;\n int                  bytes_written;\n IOMODE               crmode;\n struct sockaddr_in   datasocket;\n struct sockaddr_in   controlsocket;\n char                 port                  \u00dd81\u00a8;\n char                 control_server_buffer \u00ddSERVER_BUF_MSGSIZE+4\u00a8;\n char                 data_server_buffer    \u00ddSERVER_BUF_MSGSIZE+4\u00a8;\n char                 control_client_buffer \u00ddCLIENT_BUF_MSGSIZE+4\u00a8;\n char                 data_client_buffer    \u00ddCLIENT_BUF_MSGSIZE+4\u00a8;\n\n CLEAR(&datasocket);\n CLEAR(&controlsocket);\n CS->buf_index  = -1;\n DS->buf_index  = -1;\n CS->is_ftp     = TRUE;\n DS->is_ftp     = TRUE;\n CS->server_buf = control_server_buffer;\n DS->server_buf = data_server_buffer;\n CS->client_buf = control_client_buffer;\n DS->client_buf = data_client_buffer;\n F->myname      = R->myname;\n F->myport      = R->myport;\n F->control_socket_opened = FALSE;\n F->listen_socket_opened  = FALSE;\n F->accept_socket_opened  = FALSE;\n\n switch (F->type) {\n   case GOPHER_DIRECTORY:\n                         F->listflag = TRUE;  F->binary = FALSE; break;\n   case GOPHER_MAC_BINHEX:\n   case GOPHER_DOS_BINARCH:\n   case GOPHER_IMAGE:\n   case GOPHER_BINARY:\n   case GOPHER_BOOKMANAGER:\n                         F->listflag = FALSE; F->binary = TRUE;  break;\n   case GOPHER_FILE:\n   default:\n                         F->listflag = FALSE; F->binary = FALSE; break;\n }\n\n switch (F->os) {\n   case VM_OS: if ((cp=strchr(F->path,'/'))) {\n                *cp = '\\0';\n                ftproot = F->path;\n                ftpgetf = cp + 1;\n               }\n               else {\n                ftproot = F->path;\n                ftpgetf = \"\";\n               }\n               break;\n   default:    ftproot = \"\";\n               ftpgetf = F->path;\n               break;\n }\n\n CS->ns = ftp_connect(F,F->host);\n if (CS->ns < 0) {FLOSE;}\n F->control_socket_opened = TRUE;\n\n BLATHER(stderr,\"Connected to %s (socket %d).\\n\", F->host, CS->ns);\n\n FEXPECT(\"220\");  /* server ready */\n\n FSEND(\"USER %s\",F->user);\n FEXPECT(\"331\");  /* password required */\n\n FSEND(\"PASS %s\",F->pass);\n FEXPECT(\"230\");  /* user logged in */\n\n /* must issue RETR command but open data connection first */\n\n F->listensocket = socket(AF_INET, SOCK_STREAM, 0);\n if (F->listensocket < 0) {\n   REPORT_TCP_ERROR(\"data socket\");\n   FLOSE;\n }\n F->listen_socket_opened = TRUE;\n\n listen(F->listensocket,1); /* accept only one connection */\n\n /* get port number of data connection */\n\n socksize = sizeof(struct sockaddr);\n Getsockname(F->listensocket,&datasocket,&socksize);\n socksize = sizeof(struct sockaddr);\n Getsockname(CS->ns,&controlsocket,&socksize);\n datasocket.sin_addr.s_addr = controlsocket.sin_addr.s_addr;\n\n port_address(F,datasocket.sin_addr.s_addr,datasocket.sin_port,port);\n\n FSEND(\"PORT %s\", port);\n FEXPECT(\"200\");  /* command successful */\n\n if (F->binary) {\n   crmode = RBIN;\n   FSEND(\"TYPE %s\",\"I\");          /* image type */\n }\n else {\n   crmode = NOCR;\n   FSEND(\"TYPE %s\",\"A\");          /* ascii type */\n }\n FEXPECT(\"200\");  /* type set to ... */\n\n if (*ftproot) {\n   FSEND(\"CWD %s\", ftproot);\n   FEXPECT(\"250\");  /* current working dir set to ... */\n }\n\n if (F->listflag) {\n   if (!*ftpgetf) {FSEND(\"LIST\", NULL);}\n   else           {FSEND(\"LIST %s\", ftpgetf);}\n }\n else if (F->nlstflag) {\n   if (!*ftpgetf) {FSEND(\"NLST\", NULL);}\n   else           {FSEND(\"NLST %s\", ftpgetf);}\n }\n else {\n   FSEND(\"RETR %s\", ftpgetf);\n }\n if (F->os == VM_OS && (F->listflag || F->nlstflag)) {\n   FEXPECT(\"125\");  /* List started OK */\n }\n else {\n   FEXPECT(\"150\");  /* data connection for... */\n }\n\n accept_count = 0;\n DS->ns = Accept(F->listensocket,NULL,&accept_count);\n if (DS->ns < 0) {\n   REPORT_TCP_ERROR(\"accept\");\n   FLOSE;\n }\n F->accept_socket_opened = TRUE;\n\n /* get data from data connection */\n\n bytes_to_write = 0;\n bytes_written = 0;\n DS->time_to_go_home = FALSE;\n DS->server_has_nothing = FALSE;\n for (;;) {\n   if (!GGgsrvl(NULL,DS,NULL,crmode)) {FLOSE;}\n   if (DS->time_to_go_home || DS->server_has_nothing) break;\n   if (crmode == RBIN) bytes_to_write = DS->nbytes;\n   else                bytes_to_write = strlen(DS->server_buf)-1;\n   fwriterc = emit(F,DS->server_buf,bytes_to_write);\n   bytes_written += fwriterc;\n }\n\n /* Close the data socket before waiting for the server to return\n  * connection acknowledgement.  The VM server enforces this.\n  */\n\n (void)ftp_close(F,DS->ns);\n F->accept_socket_opened = FALSE;\n\n if (F->os == VM_OS) {\n   FEXPECT(\"250\");  /* ... completed successfully */\n }\n else {\n   FEXPECT(\"226\");  /* transfer complete */\n }\n\n FSEND(\"QUIT\",NULL);\n FEXPECT(\"221\");  /* goodbye */\n\n cleanup(F);\n return TRUE;\n\n}\n\n./ ADD NAME=GGGETDS\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@GETDS\")\n#pragma  csect(static,\"GG$GETDS\")\n#include \"gg.h\"\n#include \"ggsvc99.h\"\n\n/****** Function to close sequential data set after extraction. ******/\n\nstatic void\nclose_seq(gp,ep,xfp,final)\nRGGCB       *gp;\nEXTRACTION  *ep;\nFILE        *xfp;\nFool         final;\n{\n\n if (fclose(xfp) < 0) {\n   /* perror(ep->dsname); */\n   ERR2(\"An error occurred closing %s.\", ep->dsname);\n   gp->extract_close_error = TRUE;\n }\n\n}\n\n/****** Function to close partitioned data set after extraction. *****/\n\nstatic void\nclose_pds(gp,ep,xfp,final)\nRGGCB       *gp;\nEXTRACTION  *ep;\nFILE        *xfp;\nFool         final;\n{\n\n if (final) {\n   (void)GGunalc(ep->ddname);     /* Unallocate the PDS */\n }\n else {\n   if (fclose(xfp) < 0) {\n     /* perror(ep->dsname); */\n     ERR2(\"An error occurred closing %s.\", ep->dsname);\n     gp->extract_close_error = TRUE;\n   }\n }\n\n}\n\n/****** Function to close SYSOUT print file after printing. **********/\n\nstatic void\nclose_jes(gp,ep,xfp,final)\nRGGCB       *gp;\nEXTRACTION  *ep;\nFILE        *xfp;\nFool         final;\n{\n\n if (fclose(xfp) < 0) {\n   /* perror(ep->dsname); */\n   ERR2(\"An error occurred closing %s.\", ep->dsname);\n   gp->extract_close_error = TRUE;\n }\n if (final) {\n   (void)GGunalc(ep->ddname);     /* Unallocate the SYSOUT file */\n }\n\n}\n\n/****** Allocate SYSOUT file. ****************************************/\n\nstatic Bool\nallocate_sysout(ep,sp)\nregister EXTRACTION   *ep;\nregister SYSOUT       *sp;\n{\n int          i;\n int          rc;\n char        *cp;\n __S99parms   stuff99;   /* The manual has it wrong.  No \"struct\". */\n TEXTUNIT    *tu \u00dd 8\u00a8;\n TEXTUNIT     tu_sysout;\n TEXTUNIT     tu_copies;\n TEXTUNIT     tu_dest;\n TEXTUNIT     tu_userid;\n TEXTUNIT     tu_forms;\n TEXTUNIT     tu_ucs;\n TEXTUNIT     tu_rtddn;\n\n CLEAR(&stuff99);\n\n stuff99.__S99RBLN   = 20;\n stuff99.__S99VERB   = S99VRBAL;\n stuff99.__S99FLAG1  = S99NOCNV << 8;\n stuff99.__S99ERROR  = 0;\n stuff99.__S99INFO   = 0;\n stuff99.__S99TXTPP  = tu;\n stuff99.__S99FLAG2  = 0;\n\n i = 0;\n\n tu\u00ddi++\u00a8 = &tu_sysout;\n\n tu_sysout.key        = DALSYSOU;\n tu_sysout.num        = 1;\n tu_sysout.ent.len    = 1;\n tu_sysout.ent.prm\u00dd0\u00a8 = toupper(sp->class\u00dd0\u00a8);\n\n tu\u00ddi++\u00a8 = &tu_copies;\n\n tu_copies.key        = DALCOPYS;\n tu_copies.num        = 1;\n tu_copies.ent.len    = 1;\n tu_copies.ent.prm\u00dd0\u00a8 = (unsigned char)sp->copies;\n\n if (sp->dest\u00dd0\u00a8 > ' ') {\n\n  tu\u00ddi++\u00a8 = &tu_dest;\n\n  tu_dest.key          = DALSUSER;\n  tu_dest.num          = 1;\n  copy_uppercase_and_strip_trailing(tu_dest.ent.prm,sp->dest,cp);\n  tu_dest.ent.len      = cp - tu_dest.ent.prm;\n\n }\n\n if (sp->userid\u00dd0\u00a8 > ' ') {\n\n  tu\u00ddi++\u00a8 = &tu_userid;\n\n  tu_userid.key        = DALUSRID;\n  tu_userid.num        = 1;\n  copy_uppercase_and_strip_trailing(tu_userid.ent.prm,sp->userid,cp);\n  tu_userid.ent.len    = cp - tu_userid.ent.prm;\n\n }\n\n if (sp->forms\u00dd0\u00a8 > ' ') {\n\n  tu\u00ddi++\u00a8 = &tu_forms;\n\n  tu_forms.key         = DALSFMNO;\n  tu_forms.num         = 1;\n  copy_uppercase_and_strip_trailing(tu_forms.ent.prm,sp->forms,cp);\n  tu_forms.ent.len     = cp - tu_forms.ent.prm;\n\n }\n\n if (sp->ucs\u00dd0\u00a8 > ' ') {\n\n  tu\u00ddi++\u00a8 = &tu_ucs;\n\n  tu_ucs.key           = DALUCS;\n  tu_ucs.num           = 1;\n  copy_uppercase_and_strip_trailing(tu_ucs.ent.prm,sp->ucs,cp);\n  tu_ucs.ent.len       = cp - tu_ucs.ent.prm;\n\n }\n\n tu\u00ddi++\u00a8 = &tu_rtddn;\n\n tu_rtddn.key         = DALRTDDN;\n tu_rtddn.num         = 1;\n tu_rtddn.ent.len     = 8;\n memset(tu_rtddn.ent.prm,' ',8);\n\n tu\u00ddi\u00a8 = (void *)0x80000000;\n\n rc = svc99(&stuff99);\n\n if (rc == 0) {\n   memcpy(ep->ddname,(char *)tu_rtddn.ent.prm,8);\n   ep->ddname\u00dd8\u00a8 = ' ';\n   *(strchr(ep->ddname,' ')) = '\\0';\n   return TRUE;\n }\n else {\n   GGdfail(rc,&stuff99);\n   return FALSE;\n }\n}\n\n/****** Prompt user for the name of a data set to extract into. ******/\n\nFILE *\nGGgetds(gp,ep)\nRGGCB  *gp;\nREXTR  *ep;\n{\n FILE       *xfp;\n char       *bufptr;\n Bool        asked_for;\n Bool        do_warn;\n Bool        is_not_gopher_menu;\n SYSOUT      sys;\n char        ggexdsn \u00dd65\u00a8;    /* data set name for extraction  */\n char        ggbmdsn \u00dd65\u00a8;    /* data set name for bookmark    */\n char        ggexapp  \u00dd4\u00a8;    /* YES or NO for append mode     */\n char        ggextab  \u00dd4\u00a8;    /* YES or NO for tab expansion   */\n char        ggexblk  \u00dd4\u00a8;    /* YES or NO for blank after sep */\n char        ggexsep \u00dd81\u00a8;    /* Separator line (optional)     */\n char        ggexpmp  \u00dd9\u00a8;    /* PDS member name prefix        */\n char        ggexscl  \u00dd2\u00a8;    /* Print SYSOUT class name       */\n char        ggexsco  \u00dd4\u00a8;    /* Print SYSOUT copies number    */\n char        ggexsde \u00dd18\u00a8;    /* Print SYSOUT destination      */\n char        ggexsus \u00dd18\u00a8;    /* Print SYSOUT userid           */\n char        ggexsfo  \u00dd5\u00a8;    /* Print SYSOUT forms            */\n char        ggexsuc  \u00dd5\u00a8;    /* Print SYSOUT UCS              */\n char        ddname   \u00dd9\u00a8;\n char        member   \u00dd9\u00a8;\n char        pdspec  \u00dd32\u00a8;\n char        quoted_dsname \u00dd67\u00a8;\n char        formatted_number \u00dd11\u00a8;\n char        buffer \u00ddRBUFSIZE\u00a8;\n\n xfp = NULL;\n asked_for = TRUE;\n\n#ifdef FULLSYSOUT\n VPUT(\"GGALLPR \",\"Y\");\n#else\n VPUT(\"GGALLPR \",\"\");\n#endif\n\n ISPF(\"ADDPOP\");\n\n while (!xfp) {\n\n   /* Keep asking for a dsname until one works or END pressed. */\n\n   if (GGdispl(gp,ep->panelname) > 0) {\n     WARN1(\"Request cancelled, because you pressed END.\");\n     asked_for = FALSE;\n     xfp = NULL;\n     break;\n   }\n\n   switch (ep->ex) {\n     case EXTRACT_IT:\n                      VGET(\"GGEXDSN \",ggexdsn);\n                      VGET(\"GGEXTAB \",ggextab);\n                      if (ep->mode == PDS) {\n                        VGET(\"GGEXPMP \",ggexpmp);\n                      }\n                      else {\n                        VGET(\"GGEXAPP \",ggexapp);\n                        VGET(\"GGEXBLK \",ggexblk);\n                        VGET(\"GGEXSEP \",ggexsep);\n                      }\n                      break;\n     case PRINT_IT:\n                      VGET(\"GGEXSCL \",ggexscl);\n                      VGET(\"GGEXSCO \",ggexsco);\n#ifdef FULLSYSOUT\n                      VGET(\"GGEXSDE \",ggexsde);\n                      VGET(\"GGEXSUS \",ggexsus);\n                      VGET(\"GGEXSFO \",ggexsfo);\n                      VGET(\"GGEXSUC \",ggexsuc);\n#else\n                      *ggexsde = '\\0';\n                      *ggexsus = '\\0';\n                      *ggexsfo = '\\0';\n                      *ggexsuc = '\\0';\n#endif\n                      VGET(\"GGEXBLK \",ggexblk);\n                      VGET(\"GGEXSEP \",ggexsep);\n                      break;\n     case BOOKMARK_IT:\n                      VGET(\"GGBMDSN \",ggbmdsn);\n                      break;\n   }\n\n   if (ep->mode == PDS) {\n\n     ep->closer = close_pds;\n     ep->appending = FALSE;\n     ep->blanking  = FALSE;\n     strcpy(ep->separator,\"\");\n     strcpy(ep->ddname,\"\");\n     strcpy(ep->member_prefix,ggexpmp);\n\n     /* Note: panel forces fully-qualified name to pass to allocate */\n\n     if (ggexdsn\u00dd0\u00a8 != '\\'') {\n       strcpy(quoted_dsname,\"'\");\n       strcat(quoted_dsname,ggexdsn);\n       strcat(quoted_dsname,\"'\");\n     }\n     else strcpy(quoted_dsname,ggexdsn);\n\n     /* Check if PDS already exists. */\n\n     if (gp->warn_overwrite) {\n       if (TEST_IF_FILE_EXISTS(xfp,quoted_dsname)) {\n         CLEANUP_IF_FILE_EXISTS(xfp);\n         xfp = NULL;\n         if (GGdispl(gp,\"GGMPEXPW\") > 0) {\n           WARN1(\"Operation cancelled, because you pressed END.\");\n           break;\n         }\n       }\n     }\n\n     if (GGalloc(ggexdsn,ep->ddname,PDS,ep->count) != PDS) {\n       ERR2(\"Allocation failed for data set %s.\", ggexdsn);\n       xfp = NULL;\n       continue;\n     }\n     strcpy(ep->dsname, ggexdsn);\n     ep->tab_expanding = (ggextab\u00dd0\u00a8 == 'Y');\n     do_warn = (ep->appending ? gp->warn_append : gp->warn_overwrite);\n   }\n   else if (ep->mode == JES) {\n     if (strlen(ggexsde) > 8) {\n       ERR2(\"SYSOUT destination is too long: %s\", ggexsde);\n       xfp = NULL;\n       continue;\n     }\n     if (strlen(ggexsus) > 8) {\n       ERR2(\"SYSOUT userid is too long: %s\", ggexsus);\n       xfp = NULL;\n       continue;\n     }\n     ep->closer = close_jes;\n     strcpy(ep->separator, ggexsep);\n     sprintf(ep->dsname,\"SYSOUT class %s\",ggexscl);\n     strcpy(sys.class, ggexscl);\n     sys.copies = atoi(ggexsco);\n     if (sys.copies < 1) sys.copies = 1;\n     strcpy(sys.dest,  ggexsde);\n     strcpy(sys.userid,ggexsus);\n     strcpy(sys.forms, ggexsfo);\n     strcpy(sys.ucs,   ggexsuc);\n     ep->appending     = FALSE;\n     ep->blanking      = (ggexblk\u00dd0\u00a8 == 'Y');\n     ep->tab_expanding = TRUE;\n     do_warn = FALSE;\n   }\n   else if (ep->ex == BOOKMARK_IT) {\n     ep->closer = close_seq;\n     strcpy(ep->separator, \"\");\n     strcpy(ep->dsname,    ggbmdsn);\n     strcpy(ggexdsn,       ggbmdsn);\n     ep->appending       = TRUE;\n     ep->blanking        = FALSE;\n     ep->tab_expanding   = FALSE;\n     do_warn = FALSE;\n   }\n   else {\n     ep->closer = close_seq;\n     strcpy(ep->separator, ggexsep);\n     strcpy(ep->dsname,    ggexdsn);\n     ep->appending      = (ggexapp\u00dd0\u00a8 == 'Y');\n     ep->blanking       = (ggexblk\u00dd0\u00a8 == 'Y');\n     ep->tab_expanding  = (ggextab\u00dd0\u00a8 == 'Y');\n     do_warn = (ep->appending ? gp->warn_append : gp->warn_overwrite);\n   }\n\n   /* check if the dataset already exists */\n\n   if (ep->ex == BOOKMARK_IT) {\n     is_not_gopher_menu = FALSE;\n     if (TEST_IF_FILE_EXISTS(xfp,ggexdsn)) {\n       /* check that it is a gopher menu */\n       CLEANUP_IF_FILE_EXISTS(xfp);\n       xfp = fopen(ggexdsn,\"r\");\n       if (xfp) {\n         *buffer = '\\0';\n         fgets(buffer,sizeof(buffer),xfp);\n         if (*buffer) {\n           if ((bufptr=strchr(buffer,'\\n'))) *bufptr = '\\0';\n           uppercase_in_place(buffer);\n           bufptr = skip_whitespace(buffer);\n           if (!EQUAL(bufptr,MENUIDENT)) is_not_gopher_menu = TRUE;\n         }\n         (void)fclose(xfp);\n         xfp = NULL;\n       }\n       if (is_not_gopher_menu) {\n         WARN2(\"Not a gopher bookmark or menu file: %s\",ep->dsname);\n         break;\n       }\n       ep->appending = TRUE;\n     }\n     else {\n       ep->appending = FALSE;\n     }\n   }\n   else if (ep->mode != JES) {\n     if (do_warn) {\n       if (TEST_IF_FILE_EXISTS(xfp,ggexdsn)) {\n         CLEANUP_IF_FILE_EXISTS(xfp);\n         xfp = NULL;\n         if (GGdispl(gp,\"GGMPEXOW\") > 0) {\n           WARN1(\"Operation cancelled, because you pressed END.\");\n           break;\n         }\n       }\n     }\n   }\n\n   if (ep->mode == JES) {\n     if (allocate_sysout(ep,&sys)) {\n       sprintf(ggexdsn,\"dd:%s\",ep->ddname);\n     }\n     else *ggexdsn = '\\0';\n   }\n\n   if (ep->mode == PDS) {\n     xfp = DUMMY_FILE_POINTER;\n     break;\n   }\n\n   if (*ggexdsn) {\n\n     if (ep->mode == JES) {\n       xfp = OPEN_SYSOUT_FILE(ggexdsn);\n     }\n     else {\n       xfp = OPEN_TEXT_FILE_FOR_WRITE_OR_APPEND(ggexdsn,ep->appending);\n     }\n\n     if (!xfp) {\n#ifdef SNSTCPIP\n       fprintf(stderr,\"Open failure: errno=%d\\n\",GET_ERRNO);\n#else\n       fprintf(stderr,\"Open failure: errno=%d\\n\",errno);\n#endif\n       perror(ggexdsn);\n       ERR2(\"Cannot open data set %s.\", ep->dsname);\n     }\n   }\n }\n\n ISPF(\"REMPOP\");\n\n return xfp;\n\n}\n\n./ ADD NAME=GGGETM\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@GETM \")\n#pragma  csect(static,\"GG$GETM \")\n#include \"gg.h\"\n\n/****** Get memory. **************************************************/\n\nvoid\nGGgetm(gp,pointer,howmuch,whatfor)\nRGGCB *gp;\nchar **pointer;\nint    howmuch;\nchar  *whatfor;\n{\n\n *pointer = (char *)malloc(howmuch);\n\n if (!*pointer) {\n   fprintf(stderr,\"GGgetm: Cannot obtain %d bytes of memory for %s\\n\",\n                  howmuch,whatfor);\n }\n else if (gp && gp->debug_file) {\n   fprintf(gp->debug_file,\"GGgetm: got %d bytes of memory for %s\\n\",\n                           howmuch,whatfor);\n }\n return;\n\n}\n\n./ ADD NAME=GGGOFOR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@GOFOR\")\n#pragma  csect(static,\"GG$GOFOR\")\n#include \"gg.h\"\n\n/********************************************************************/\n\nstatic Bool\nconnect_and_get_data_from_gopher_server(gp,sp,ip,crmode)\nRGGCB     *gp;\nRCONN     *sp;\nRINFO     *ip;\nIOMODE     crmode;\n{\n char     *lp;\n Bool      got_some;\n\n strcpy(gp->ggserver,ip->host);     /* Specify server to connect to */\n strcpy(gp->gopher_command,ip->path);   /* Specify command to issue */\n gp->ginfo = ip;\n sp->receiving_text = FALSE;\n\n if (!GGconn(gp,sp)) return FALSE;   /* Connect to gopher server */\n GOPHERSEND(gp,sp);                  /* Send socket command */\n GGclrtx(gp,ip);                    /* Clear text */\n\n sp->receiving_text = TRUE;\n got_some = FALSE;\n while (GGgsrvl(gp,sp,&lp,crmode)) {  /* Get server line */\n   if (!lp) break;\n   got_some = TRUE;\n   (void)GGouttx(gp,lp,ip,            /* Output text line */\n                 crmode == RBIN ? sp->nbytes : NO_VALUE);\n }\n\n if (!got_some) {\n   WARN2(\"No data available from server %s.\\n\",gp->ggserver);\n   return FALSE;\n }\n\n return TRUE;\n}\n\n/****** Gopher it. ***************************************************/\n\nBool\nGGgofor(gp,ip,how)\nRGGCB  *gp;\nRINFO  *ip;\nGOHOW   how;\n{\n RCONN *sp = &gp->gopher_connection;\n Bool (*fun)(GGCB *, GOPHERINFO *, GOHOW);\n Bool   con = FALSE;\n Bool   rc  = TRUE;\n IOMODE cr;\n char   savebook\u00dd63\u00a8;\n\n   /* (1) send initial path string to initial host\n    * (2) get back data from host\n    * (3) if it is a gopher directory, then do:\n    *      - display \"table\" of items\n    *      - for each item selected, call GGgofor recursively\n    *     else browse the file data\n    * (4) bye\n    */\n\n if (gp->debug_mode) {\n   fprintf(gp->debug_file,\"GGgofor: type = %c\\n\",ip->type);\n   fprintf(gp->debug_file,\"GGgofor: port = %d\\n\",ip->port);\n   fprintf(gp->debug_file,\"GGgofor: path = %s\\n\",ip->path);\n   fprintf(gp->debug_file,\"GGgofor: host = %s\\n\",ip->host);\n   fprintf(gp->debug_file,\"GGgofor: desc = %s\\n\",ip->desc);\n   fprintf(gp->debug_file,\"GGgofor: bmds = %s\\n\",ip->bmds);\n }\n\n switch (ip->type) {\n   case GOPHER_FILE:       fun = GGvtx;   con = TRUE;  cr = CRLF; break;\n   case GOPHER_DIRECTORY:  fun = GGdir;   con = TRUE;  cr = CRLF; break;\n   case GOPHER_TELNET:     fun = GGtnet;  con = FALSE; cr = CRLF; break;\n   case GOPHER_TN3270:     fun = GGtnet;  con = FALSE; cr = CRLF; break;\n   case GOPHER_WAIS:       fun = GGwais;  con = FALSE; cr = CRLF; break;\n   case GOPHER_WHOIS:      fun = GGwhois; con = FALSE; cr = CRLF; break;\n   case GOPHER_CSO:        fun = GGcso;   con = FALSE; cr = NOCR; break;\n   case GOPHER_BOOKMANAGER:fun = GGbkmgr; con = TRUE;  cr = RBIN; break;\n   case GOPHER_MAC_BINHEX:\n   case GOPHER_DOS_BINARCH:\n   case GOPHER_BINARY:     fun = GGbin;   con = TRUE;  cr = RBIN; break;\n   case GOPHER_ERROR:      return TRUE;\n   case GOPHER_COMMENT:    return TRUE;\n   default:\n        ERR2(\"Sorry, accessing an item of type %s is not supported\",\n             GGtype(ip->type));\n        return FALSE;\n }\n\n if (con) {\n   rc = connect_and_get_data_from_gopher_server(gp,sp,ip,cr);\n }\n else rc = TRUE;\n\n /* Insure no connection is active once we do the real thing. */\n\n if (sp->connected_to_server) {\n   (void)GGdisc(gp,sp);     /* Disconnect from gopher server */\n }\n\n if (!rc) return FALSE;     /* Fail if could not get data */\n\n strcpy(savebook,gp->current_bookmark_ds);\n if (EQUAL(ip->host, LOCAL_HOST_FROB)) {\n   strncpy(gp->current_bookmark_ds,ip->path,sizeof(savebook));\n }\n else {\n   strcpy(gp->current_bookmark_ds,\"\");\n }\n\n rc = (fun)(gp,ip,how);\n\n strcpy(gp->current_bookmark_ds,savebook);\n\n return rc;\n\n}\n\n./ ADD NAME=GGGSRVL\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@GSRVL\")\n#pragma  csect(static,\"GG$GSRVL\")\n#include \"gg.h\"\n\n/****** Input one character from the server. *************************/\n\nstatic int\nsocket_getchar(sp,crmode)\nRCONN         *sp;\nIOMODE         crmode;\n{\n int           readrc;\n\n if (sp->buf_index == -1 || sp->buf_index >= sp->bytes_returned - 1) {\n   sp->buf_index = -1;\n   if (sp->dont_read) return SOCKET_NO_MORE;\n   TCP_DEBUG_ON;\n   readrc = read(sp->ns, sp->buf, READ_BYTES);\n   TCP_DEBUG_OFF;\n   if (readrc == -1) {\n     sp->connection_broken = TRUE;\n     return SOCKET_GETCHAR_ERROR;\n   }\n   else if (readrc == 0) {\n     sp->connection_broken = FALSE;\n     return SOCKET_READ_NOTHING;\n   }\n   else {\n     if (crmode != RBIN) {\n       ASCII_TO_EBCDIC(sp->buf,readrc);\n     }\n     sp->bytes_returned = readrc;\n   }\n }\n return sp->buf\u00dd++sp->buf_index\u00a8;\n}\n\n/****** Input one data line at a time from the server. ***************/\n\nstatic RETVAL\nsocket_from_server(gp,sp,crmode)\nRGGCB             *gp;\nRCONN             *sp;\nIOMODE             crmode;\n{\n char             *s_buf       = sp->server_buf;\n int               s_bytes     = SERVER_BUF_MSGSIZE;\n int               s_buf_index = 0;\n int               previous_character = -1;\n int               character;\n\n /* Get characters from the server until LF is reached. */\n\n for (;;) {\n   sp->nbytes = s_buf_index;\n   if (crmode == RBIN && s_buf_index >= s_bytes) break;\n   character = socket_getchar(sp,crmode);\n   if (character == LINE_FEED && crmode != RBIN) break;\n   if (character == SOCKET_GETCHAR_ERROR)  return SERVER_READ_ERROR;\n   if (character == SOCKET_NO_MORE)        return SERVER_NO_MORE;\n   if (character == SOCKET_READ_NOTHING)   return SERVER_READ_NOTHING;\n   previous_character = character;\n   if (s_buf_index >= s_bytes) {\n     fprintf(stderr,\n             \"Error: More than %d bytes received without Line Feed.\\n\",\n             s_bytes);\n     if (gp && gp->debug_file) {\n       GGdump(gp,\"Data collected so far\",sp->server_buf,s_bytes);\n     }\n     return SERVER_BUFFER_ERROR;\n   }\n   if (crmode != RBIN && character == '\\0' && !sp->is_ftp) {\n     fprintf(stderr,\n   \"Warning: null character found in server data, changed to blank\\n\");\n     character = ' ';\n   }\n   s_buf\u00dds_buf_index++\u00a8 = (unsigned char)character;\n }\n s_buf\u00dds_buf_index\u00a8 = '\\0';\n return SERVER_READ_OK;\n}\n\n/****** Get server line. *********************************************/\n\nBool\nGGgsrvl(gp,sp,pointer,crmode)\nRGGCB  *gp;\nRCONN  *sp;\nchar  **pointer;\nIOMODE  crmode;\n{\n RRECV *R;\n char  *sbufp;\n char  *p;\n int    scan_count;\n Bool   something_to_print;\n RETVAL sfs;\n\n if (pointer) *pointer = NULL;\n\n /* If local mode, read from temporary file until EOF. */\n\n if (gp && (R=gp->recvp) && !sp->is_ftp) {\n   if (!R->outfp) {\n     CRIT1(\"Can't read data locally, non-socket not connected\\n\");\n     return FALSE;\n   }\n   if (crmode == RBIN) {\n     sp->nbytes =\n       fread(sp->server_buf,sizeof(char),SERVER_BUF_MSGSIZE,R->outfp);\n     if (ferror(R->outfp)) {\n       CRIT1(\"Error reading local non-socket data\\n\");\n       sp->time_to_go_home = TRUE;\n       return FALSE;\n     }\n     if (sp->nbytes <= 0) return FALSE;\n     if (pointer) *pointer = sp->server_buf;\n     return TRUE;\n   }\n   else {\n     fgets(sp->server_buf, SERVER_BUF_MSGSIZE, R->outfp);\n     if (ferror(R->outfp)) {\n       CRIT1(\"Error reading local non-socket data\\n\");\n       sp->time_to_go_home = TRUE;\n       return FALSE;\n     }\n     if ((p=strchr(sp->server_buf,'\\n'))) *p = '\\0';\n     if (pointer) *pointer = sp->server_buf;\n     if (feof(R->outfp)) return FALSE;\n     return TRUE;\n   }\n }\n\n if (sp->is_ftp) {\n\n   sp->time_to_go_home = FALSE;\n   sp->server_has_nothing = FALSE;\n\n   switch (socket_from_server(gp,sp,crmode)) {\n     case SERVER_READ_OK:      return TRUE;\n     case SERVER_READ_NOTHING: if (crmode == RBIN) sp->dont_read = TRUE;\n                               else sp->server_has_nothing = TRUE;\n                               return TRUE;\n     case SERVER_NO_MORE:      sp->server_has_nothing = TRUE;\n                               return TRUE;\n     case SERVER_READ_ERROR:   fprintf(stderr,\n     \"Lost server connection.  Failure reading data from server %s.\\n\",\n                                       sp->server_hostname);\n                               sp->time_to_go_home = TRUE;\n                               return FALSE;\n     case SERVER_BUFFER_ERROR: fprintf(stderr,\n  \"Read error.  No linefeed character found in data from server %s.\\n\",\n                                    sp->server_hostname);\n                               sp->time_to_go_home = TRUE;\n                               return FALSE;\n   }\n }\n\n if (!sp->receiving_text) return TRUE;\n if (sp->server_finished_replying) sp->dont_read = TRUE;\n\n sfs = socket_from_server(gp,sp,crmode);\n switch (sfs) {\n   case SERVER_READ_OK:      break;\n   case SERVER_READ_NOTHING: if (crmode == RBIN) sp->dont_read = TRUE;\n                             else sp->time_to_go_home = TRUE;\n                             break;\n   case SERVER_READ_ERROR:   ERR2(\n     \"Lost server connection.  Failure reading data from server %s.\",\n                                  sp->server_hostname);\n                             sp->time_to_go_home = TRUE;\n                             break;\n   case SERVER_BUFFER_ERROR: ERR2(\n \"Read error.  No linefeed character found in data from server %s.\",\n                                  sp->server_hostname);\n                             sp->time_to_go_home = TRUE;\n                             break;\n   case SERVER_NO_MORE:      sp->server_has_nothing = TRUE;\n                             break;\n }\n\n if (sp->time_to_go_home) return FALSE;\n if (sp->dont_read && sp->server_has_nothing) return TRUE;\n\n something_to_print = TRUE;\n sbufp = sp->server_buf;\n\n if (sp->sending_text && crmode != RBIN) {\n   if (*sbufp == '.') {\n     switch (*(sbufp+1)) {\n        case CARRIAGE_RETURN:\n        case LINE_FEED:\n        case '\\0':\n                  sp->server_finished_replying = TRUE;\n                  something_to_print = FALSE;\n                  break;\n        case '.':\n                  break;\n        default:  if (gp) {\n                   GGdump(gp,\"Warning, bad period in line from server\",\n                             sbufp,strlen(sbufp));\n                  }\n                  break;\n     }\n   }\n }\n\n sp->sending_text = TRUE;\n\n if (something_to_print) {\n   /* Last character of output buffer is a CR without LF. */\n   if (crmode != RBIN) {\n     p = sbufp + strlen(sbufp)-1;\n     if (p >= sbufp) {\n       if (*p == CARRIAGE_RETURN) *p = '\\0';\n       else if (crmode == CRLF) {\n         /* Last character of output buffer had better be a LF. */\n         if (gp && gp->debug_file) {\n           fprintf(gp->debug_file,\n   \"Warning: No carriage return in data from server (%d bytes):\\n%s\\n\",\n                 strlen(sbufp), sbufp);\n         }\n         CRIT2(\n\"Carriage return expected but not seen in data from server %s.\",\n               sp->server_hostname);\n       }\n       *(p+1) = '\\0';\n       sp->nbytes = (p+1) - sbufp;\n     }\n   }\n   if (pointer) *pointer = sbufp;\n }\n\n if (sp->time_to_go_home) return FALSE;\n else return TRUE;\n}\n\n./ ADD NAME=GGIERR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@IERR \")\n#pragma  csect(static,\"GG$IERR \")\n#include \"gg.h\"\n\n/****** ISPF error handler. ******************************************/\n\nvoid\nGGierr(gp)\nRGGCB *gp;\n{\n char  errbuf\u00dd\u00a8 = \"DISPLAY PANEL(ISPTERM)\";\n int   errlen;\n\n errlen = strlen(errbuf);\n if (ISPEXEC(&errlen,errbuf) > 8) {\n   fprintf(stderr,\n\"\\n*** Severe ISPF error, cannot even display ISPTERM error panel.\\n\");\n   fprintf(stderr,\n\"\\n*** Return code from ISPF service is %d\\n\",gp->ispfrc);\n   return;\n }\n}\n\n./ ADD NAME=GGIGET\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@IGET \")\n#pragma  csect(static,\"GG$IGET \")\n#include \"gg.h\"\n\n/****** Retrieve the value of an ISPF variable into an integer. ******/\n\nint\nGGiget(gp,varname)\nRGGCB *gp;\nchar  *varname;\n{\n char  varbuf \u00dd16\u00a8;\n int   vcopy_length = 16;\n\n if (!strchr(varname,' ')) {\n   fprintf(stderr,\"GGiget: no blank passed in variable name %s\\n\",\n                  varname);\n   return FALSE;\n }\n\n gp->ispfrc = ISPLINK(\"VCOPY\",varname,&vcopy_length,varbuf,\"MOVE\");\n switch (gp->ispfrc) {\n   case  0:\n           varbuf\u00ddvcopy_length\u00a8 = '\\0';\n           return atoi(varbuf);\n   case  8:\n           return 0;\n   case 16:\n           fprintf(stderr,\n                   \"Error: ISPF variable buffer too short to get %s\\n\",\n                   varname);\n           return 0;\n   default:\n           GGierr(gp);   /* handle ISPF error */\n           return 0;\n }\n}\n\n./ ADD NAME=GGINFO\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@INFO \")\n#pragma  csect(static,\"GG$INFO \")\n#include \"gg.h\"\n\n/****** Gopher it. ***************************************************/\n\nBool\nGGinfo(gp,ip)\nRGGCB *gp;\nRINFO *ip;\n{\n char  buf \u00dd513\u00a8;\n\n if (!ip) {\n   ERR1(\"Info is not available - this is not a Gopher item.\");\n   return FALSE;\n }\n\n GGclrtx(gp,NULL);\n\n sprintf(buf,\"\");                  GGouttx(gp,buf,NULL,NO_VALUE);\n sprintf(buf,\"Type=%c%c\",\n              ip->type,ip->plus);  GGouttx(gp,buf,NULL,NO_VALUE);\n sprintf(buf,\"Name=%s\",ip->desc);  GGouttx(gp,buf,NULL,NO_VALUE);\n sprintf(buf,\"Path=%s\",ip->path);  GGouttx(gp,buf,NULL,NO_VALUE);\n sprintf(buf,\"Host=%s\",ip->host);  GGouttx(gp,buf,NULL,NO_VALUE);\n sprintf(buf,\"Port=%d\",ip->port);  GGouttx(gp,buf,NULL,NO_VALUE);\n sprintf(buf,\"End\");               GGouttx(gp,buf,NULL,NO_VALUE);\n\n return TRUE;\n}\n\n./ ADD NAME=GGISPF\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@ISPF \")\n#pragma  csect(static,\"GG$ISPF \")\n#include \"gg.h\"\n\n/****** Call ISPF service. *******************************************/\n\nBool\nGGispf(gp,ispfbuf)\nRGGCB *gp;\nchar  *ispfbuf;\n{\n int   ispflen = strlen(ispfbuf);\n\n if (!gp) return TRUE;\n\n#ifndef ISPFV2\n if (gp->test_mode) {\n#endif\n   if (ispflen >= 6 && (!memcmp(ispfbuf,\"ADDPOP\",6) ||\n                        !memcmp(ispfbuf,\"REMPOP\",6))) {\n     gp->ispfrc = 0;\n     return TRUE;\n   }\n#ifndef ISPFV2\n }\n#endif\n\n gp->ispfrc = ISPEXEC(&ispflen,ispfbuf);\n if (gp->ispfrc > 8) {\n\n   /* Ignore ADDPOP and REMPOP errors, especially if they are due to\n      ISPF V3 not being active. */\n\n   if (gp->ispfrc == 20 && !gp->debug_mode && ispflen >= 6 &&\n       (!memcmp(ispfbuf,\"ADDPOP\",6) ||\n        !memcmp(ispfbuf,\"REMPOP\",6))) return TRUE;\n\n   GGierr(gp);             /* handle ISPF error */\n   return FALSE;\n }\n return TRUE;\n}\n\n./ ADD NAME=GGIVGET\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@IVGET\")\n#pragma  csect(static,\"GG$IVGET\")\n#include \"gg.h\"\n\n/****** Retrieve the value of an ISPF variable. **********************/\n\nBool\nGGivget(gp,varname,varbuf,varbuflen)\nRGGCB  *gp;\nchar   *varname;\nchar   *varbuf;\nint     varbuflen;\n{\n int    vcopy_length;\n\n if (!strchr(varname,' ')) {\n   fprintf(stderr,\"GGivget: no blank passed in variable name %s\\n\",\n                  varname);\n   return FALSE;\n }\n\n /*\n  * If varbuflen is negative, that means that the value is not to be\n  * treated as a C string, and the null character is not to be\n  * appended to the resulting value.  This is used for hex values\n  * (like addresses) that are stored in ISPF table row variables.\n  */\n\n if (varbuflen < 0)  vcopy_length = -varbuflen;\n else vcopy_length = varbuflen;\n\n /* Note that on entry, vcopy_length is an integer that contains\n  * the length of the buffer.  On return it is updated to the length\n  * of the value returned.  Since we have to stick a null character\n  * on the end of it for C, the actual buffer passed must be at least\n  * one character longer than the length as defined to ISPF.\n  */\n\n gp->ispfrc = ISPLINK(\"VCOPY\",varname,&vcopy_length,varbuf,\"MOVE\");\n switch (gp->ispfrc) {\n   case  0:\n           if (varbuflen >= 0)\n              varbuf\u00ddvcopy_length\u00a8 = '\\0';\n           return TRUE;\n   case  8:\n           strcpy(varbuf,\"\");\n           return TRUE;\n   case 16:\n           fprintf(stderr,\n                   \"Error: ISPF variable buffer too short to get %s\\n\",\n                   varname);\n           return FALSE;\n   default:\n           GGierr(gp);   /* handle ISPF error */\n           return FALSE;\n }\n}\n\n./ ADD NAME=GGIVPUT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@IVPUT\")\n#pragma  csect(static,\"GG$IVPUT\")\n#include \"gg.h\"\n\n/****** Set the value of an ISPF variable. ***************************/\n\nBool\nGGivput(gp,varname,varbuf,varlen)\nRGGCB  *gp;\nchar   *varname;\nchar   *varbuf;\nint     varlen;\n{\n int    vreplace_length = (varlen < 0 ? strlen(varbuf) : varlen);\n\n gp->ispfrc = ISPLINK(\"VREPLACE\",varname,&vreplace_length,varbuf);\n switch (gp->ispfrc) {\n   case  0:\n           return TRUE;\n   case 16:\n           fprintf(stderr,\n                   \"Error: ISPF variable buffer too short to put %s\\n\",\n                   varname);\n           return FALSE;\n   default:\n           GGierr(gp);   /* handle ISPF error */\n           return FALSE;\n }\n}\n\n./ ADD NAME=GGMENU\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@MENU \")\n#pragma  csect(static,\"GG$MENU \")\n#include \"gg.h\"\n\n/****** Display Gopher menu in data set. *****************************/\n\nBool\nGGmenu(gp,pp)\nRGGCB *gp;\nchar  *pp;\n{\n GOPHERINFO   *ip;\n GOPHERINFO   *saveip;\n char         *cp;\n Bool          rc;\n char          zprefix    \u00dd9\u00a8;\n char          temp     \u00dd129\u00a8;\n char          savebook  \u00dd63\u00a8;\n\n if (!*pp) {\n   ERR1(\"You must supply a data set name for a Gopher menu.\");\n   return FALSE;\n }\n\n if (strlen(pp) >= sizeof(temp)) {\n   ERR1(\"Gopher menu name too long\");\n   return FALSE;\n }\n\n GETMAIN(ip, struct gopherinfo, 1, \"menu gopherinfo struct\");\n if (!ip) {\n   ERR2(\"Not enough memory to load Gopher menu %s\",pp);\n   return FALSE;\n }\n\n CLEAR(ip);\n\n copy_uppercase(temp,pp);\n\n if (temp\u00dd0\u00a8 == '\\'') {\n   strcpy(ip->path, temp+1);\n   cp = &ip->path\u00ddstrlen(ip->path)-1\u00a8;\n   if (*cp == '\\'') *cp = '\\0';\n }\n else {\n   VGET(\"ZPREFIX \",zprefix);\n   if (!*zprefix) sprintf(ip->path,\"'%s'\",pp);\n   else sprintf(ip->path,\"%s.%s\",zprefix,pp);\n }\n\n ip->type  = GOPHER_MENU;\n sprintf(ip->desc,\"User menu %s\",ip->path);\n strcpy (ip->host, \"-\");\n ip->port  = SERV_TCP_PORT;\n saveip    = gp->ginfo;\n gp->ginfo = ip;\n strcpy(savebook,gp->current_bookmark_ds);\n strncpy(gp->current_bookmark_ds,ip->path,sizeof(savebook));\n\n rc = GGgofor(gp,ip,AS_NORMAL);\n\n gp->ginfo = saveip;\n strcpy(gp->current_bookmark_ds,savebook);\n\n FREEMAIN(ip,\"menu gopherinfo struct\");\n\n return rc;\n}\n\n./ ADD NAME=GGMTFER\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@MTFER\")\n#pragma  csect(static,\"GG$MTFER\")\n#include \"gg.h\"\n\n/*********************************************************************/\n\nvoid\nGGmtfer(\n        int     rc,\n        char   *kind)\n{\n char    *ermsg;\n\n switch (rc) {\n   case MTF_OK:\n        ermsg = NULL;\n        break;\n   case EINACTIVE:\n        ermsg = \"MTF is inactive\";\n        break;\n   case ESUBCALL:\n        ermsg = \"The MTF call was issued from a subtask\";\n        break;\n   case EWRONGOS:\n        ermsg = \"MTF is not supported under CMS, IMS, CICS, or DB2\";\n        break;\n   case EACTIVE:\n        ermsg = \"MTF has already been initialized and is active\";\n        break;\n   case ENAME2LNG:\n        ermsg = \"The parallel module name is longer than 8 characters\";\n        break;\n   case ETASKNUM:\n        ermsg = \"The number of tasks specified is invalid\";\n        break;\n   case ENOMEM:\n        ermsg = \"Insufficient storage for MTF internal areas\";\n        break;\n   case EMODFIND:\n        ermsg = \"The parallel load module was not found\";\n        break;\n   case EMODREAD:\n        ermsg = \"The parallel load module was not sucessfully read\";\n        break;\n   case EMODFMT:\n        ermsg = \"The parallel load module format is invalid\";\n        break;\n   case EAUTOALC:\n        ermsg = \"Automatic allocation of standard stream DD failed\";\n        break;\n   case ETASKFAIL:\n        ermsg = \"The attempt to attach task(s) has failed\";\n        break;\n   case ETASKABND:\n        ermsg = \"One or more subtasks have abnormally terminated\";\n        break;\n   case EBADLNKG:\n        ermsg = \"TSCHED has been invoked via invalid linkage\";\n        break;\n   case ETASKID:\n        ermsg = \"The task ID specified is not valid\";\n        break;\n   case EENTRY:\n        ermsg = \"The parallel function was not in the parallel module\";\n        break;\n   default:\n        ermsg = \"Unknown MTF error\";\n        break;\n }\n\n if (ermsg) {\n   fprintf(stderr,\"GGserve: %s error code %d:\\n %s\\n\", kind, rc, ermsg);\n }\n\n return;\n\n}\n\n./ ADD NAME=GGOUTS\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@OUTS\")\n#pragma  csect(static,\"GG$OUTS\")\n\n#include \"gg.h\"\n\n/*\n * This is a Gopher server routine that outputs data to a socket.\n * If the \"socket\" is actually a file pointer, then output is\n * written to the file pointer.\n *\n */\n\n/*=================================================================*/\n\nBool\nGGouts(RRECV *R,\n       char  *text,\n       int    outlen)\n{\n char        *outp;\n int          len;\n int          reallen;\n Bool         rc;\n Bool         binary;\n char         outbuf \u00dd515\u00a8;  /* hold an output character string */\n\n switch (R->pathtype) {\n   case GOPHER_MAC_BINHEX:\n   case GOPHER_DOS_BINARCH:\n   case GOPHER_IMAGE:\n   case GOPHER_BINARY:\n   case GOPHER_BOOKMANAGER:\n                         binary = TRUE;   break;\n   default:              binary = FALSE;  break;\n }\n\n if (outlen == NO_VALUE) outlen = text ? strlen(text) : 0;\n else if (outlen == OUT_PLUS) {\n   outlen = text ? strlen(text) : 0;\n   binary = FALSE;\n   if (!R->outfp)\n      fprintf(stderr,\"GGouts: %*.*s\\n\", outlen, outlen, text);\n }\n else binary = TRUE;\n\n if (R->outfp) {             /* if using non-socket interface */\n   if (text) {\n     if (fwrite(text, sizeof(char), outlen, R->outfp) < 0) {\n       fprintf(stderr,\"Error writing to output file\\n\");\n       return FALSE;\n     }\n     if (!binary) {\n       if (fputc('\\n',R->outfp) < 0) {\n         fprintf(stderr,\"Error writing to output file\\n\");\n         return FALSE;\n       }\n     }\n   }\n   return TRUE;\n }\n\n if (binary) {\n   if (!text) {\n     outp = \"\";\n     len = 0;\n   }\n   else {\n     outp = text;\n     len = outlen;\n   }\n   reallen = len;\n }\n else {\n   outp = outbuf;\n   if (!text) {\n     outbuf\u00dd0\u00a8 = '.';\n     len = 1;\n   }\n   else {\n     len = strlen(text);\n     if (len >= sizeof(outbuf)-3) len = sizeof(outbuf)-3;\n     if (text\u00dd0\u00a8 == '.') {\n       outbuf\u00dd0\u00a8 = '.';\n       memcpy(outbuf+1,text,len);\n       len++;\n     }\n     else {\n       memcpy(outbuf,text,len);\n     }\n   }\n   outbuf\u00ddlen  \u00a8 = CARRIAGE_RETURN;\n   outbuf\u00ddlen+1\u00a8 = LINE_FEED;\n   outbuf\u00ddlen+2\u00a8 = '\\0';\n   reallen = len + 2;\n\n   EBCDIC_TO_ASCII(outbuf,reallen);\n\n }\n\n rc = TRUE;\n\n if (R->outlen + reallen > sizeof(R->sockbuf)) {\n\n   if (write(R->sockfd,R->sockbuf,R->outlen) < 0) {\n     REPORT_TCP_ERROR(\"SEND\");\n     rc = FALSE;\n   }\n   R->outlen = 0;\n }\n\n memcpy(R->sockbuf + R->outlen, outp, reallen);\n R->outlen += reallen;\n\n if (!text) {  /* flush socket */\n   if (write(R->sockfd,R->sockbuf,R->outlen) < 0) {\n     REPORT_TCP_ERROR(\"SEND\");\n     rc = FALSE;\n   }\n }\n return rc;\n}\n\n./ ADD NAME=GGOUTTX\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@OUTTX\")\n#pragma  csect(static,\"GG$OUTTX\")\n#include \"gg.h\"\n\n/****** Output a line of text retrieved from the server. *************/\n\nTEXTLINE *\nGGouttx(gp,line,ip,len)\nRGGCB     *gp;\nchar      *line;\nRINFO     *ip;\nint        len;\n{\n TEXTHDR  *thp;\n TEXTLINE *tp;\n short     line_length;\n short     total_text_length;\n short     tab_expansion_length;\n Bool      tabs_present;\n char     *p;\n char     *q;\n char     *t;\n int       e;\n int       u;\n\n static char tab_expansion_buffer\u00dd8*TEXT_BYTES\u00a8;\n\n thp = (ip ? &ip->thdr : &gp->thdr);\n\n /* If line starts with double period, make it a single period. */\n\n if (len != NO_VALUE) {\n  line_length = len;\n  tabs_present = FALSE;\n  total_text_length = line_length + 1;\n }\n else {\n\n   if (ip && !memcmp(line,\"..\",2)) line++;\n\n   /* Add this line to the current queue of server text lines. */\n   /* First, expand tabs in the line. */\n\n   line_length = strlen(line);\n   t = strchr(line,'\\t');\n   if (!t) {\n     tabs_present = FALSE;\n     total_text_length = line_length + 1;\n   }\n   else {\n     tabs_present = TRUE;\n     p = line;\n     q = line + line_length;\n     e = 0;\n     memset(tab_expansion_buffer,' ',sizeof(tab_expansion_buffer));\n     for (;;) {\n       u = t - p;\n       if (u > 0) {\n         memcpy(tab_expansion_buffer+e,p,u);\n         e += u;\n       }\n       if (t == q) break;\n       e = e / 8 * 8 + 8;\n       p = t+1;\n       t = strchr(p,'\\t');\n       if (!t) t = q;\n     }\n     tab_expansion_length = e;\n     tab_expansion_buffer\u00ddtab_expansion_length\u00a8 = '\\0';\n     total_text_length = line_length + tab_expansion_length + 1;\n   }\n }\n\n GETMAIN(tp, char, offsetof(struct textline, text) + total_text_length,\n                   \"text line\");\n\n if (!tp) {\n   ERR1(\"There is not enough virtual storage to process server text.\");\n   return NULL;\n }\n\n tp->next = NULL;\n tp->text_length = line_length;\n memcpy(tp->text,line,line_length);\n tp->text\u00ddline_length\u00a8 = '\\0';\n if (tabs_present) {\n   tp->tab_expanded_text_length = tab_expansion_length;\n   tp->tab_expanded_text = tp->text + line_length;\n   strcpy(tp->tab_expanded_text,tab_expansion_buffer);\n }\n else {\n   tp->tab_expanded_text_length = line_length;\n   tp->tab_expanded_text = tp->text;\n }\n\n if (!thp->last_text_line) {\n   thp->first_text_line   = tp;\n   thp->text_body_line    = tp;\n   thp->current_text_line = tp;\n }\n else thp->last_text_line->next = tp;\n\n thp->last_text_line = tp;\n thp->text_line_count++;\n\n if (thp->text_max_length < tp->text_length)\n     thp->text_max_length = tp->text_length;\n if (thp->text_max_tab_expanded_length < tp->tab_expanded_text_length)\n     thp->text_max_tab_expanded_length = tp->tab_expanded_text_length;\n\n return tp;\n\n}\n\n./ ADD NAME=GGPMSG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#define  SUPPRESS_V_DECLARATION\n#pragma  csect(code,  \"GG@PMSG \")\n#pragma  csect(static,\"GG$PMSG \")\n#include \"gg.h\"\n\n/****** Set an ISPF message, or write to SYSOUT if batch mode. *******/\n\nvoid\nGGpmsg(gp,msgtype,msghelp,msgformat) /* also ... for sprintf args */\nRGGCB *gp;\nint    msgtype;\nchar  *msghelp;\nchar  *msgformat;\n{\n va_list     argp;\n char       *cp;\n char        zerrsm    \u00dd25\u00a8;\n char        zerrhm     \u00dd9\u00a8;\n char        zerralrm   \u00dd4\u00a8;\n char        zerrlm   \u00ddZERRLM_SIZE\u00a8;\n char        buf      \u00dd257\u00a8;\n\n va_start(argp,msgformat);\n vsprintf(buf,msgformat,argp);\n va_end(argp);\n\n cp = strchr(buf,';');\n if (cp) {\n  *cp = '\\0';\n  strncpy(zerrsm,buf, sizeof(zerrsm));\n  strncpy(zerrlm,cp+1,sizeof(zerrlm));\n }\n else {\n  strcpy(zerrsm,\"\");\n  strncpy(zerrlm,buf,sizeof(zerrlm));\n }\n\n zerrsm\u00ddsizeof(zerrsm)-1\u00a8 = '\\0';\n zerrlm\u00ddsizeof(zerrlm)-1\u00a8 = '\\0';\n\n if (msghelp) strcpy(zerrhm, msghelp);\n else         strcpy(zerrhm, \"*\"    );\n\n switch (msgtype) {\n   case NOTIFY_MSG:    strcpy(zerralrm,\"NO \"); break;\n   case WARNING_MSG:\n   case CRITICAL_MSG:\n   default:            strcpy(zerralrm,\"YES\"); break;\n }\n\n VPUT(\"ZERRSM \",  zerrsm);\n VPUT(\"ZERRLM \",  zerrlm);\n VPUT(\"ZERRHM \",  zerrhm);\n VPUT(\"ZERRALRM \",zerralrm);\n\n gp->setmsg = TRUE;\n\n return;\n}\n\n./ ADD NAME=GGPROC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@PROC\")\n#pragma  csect(static,\"GG$PROC\")\n\n#include \"gg.h\"\n\n/*=================================================================*/\n\n/****************************************************/\n/* This routine \"cleans\" a string by removing the   */\n/* leading spaces and trailing spaces and non-      */\n/* graphical characters.                            */\n/****************************************************/\n\nstatic char *\ntrim_leading_and_trailing_space(char *string)\n{\n char *str;\n\n /*  first clean up the beginning of the string... */\n\n str = skip_leading_space(string);\n\n /*    now look at the end of the string... */\n\n strip_trailing_junk_in_place(str);\n\n return str;\n}\n\n/*=================================================================*/\n\nstatic void\nupcase_and_append_domain_name(RECV *R,\n                              char *hostname)\n{\n int   hostlen;\n int   domslen;\n\n if (EQUAL(hostname,LOCAL_HOST_FROB)) return;\n\n uppercase_in_place(hostname);\n\n#ifdef APPEND_DOMAIN_NAME_TO_SELF\n hostlen = strlen(hostname);\n domslen = strlen(R->mydomain);\n if (hostlen <= domslen ||\n     memcmp(hostname+hostlen-domslen, R->mydomain, domslen)) {\n   strncat(hostname, R->mydomain, domslen);\n }\n#endif\n return;\n}\n\n/*=================================================================*/\n\nstatic Bool\ninsure_my_name(RECV *R)\n{\n\n /* Determine the local path name, if not already set. */\n\n if (!*R->myname) {\n   if (gethostname(R->myname,MAXHOSTNAMELEN) < 0) {\n     fprintf(stderr,\"GOPHER:gethostname() failed, can't get my name\\n\");\n     GGbarf(R,\"Oops, the GOPHER server had an attack of amnesia\");\n     return FALSE;\n   }\n   upcase_and_append_domain_name(R,R->myname);\n }\n\n return TRUE;\n\n}\n\n/*=================================================================*/\n\nstatic void\nlog_it(RRECV *R,\n       char  *resource,\n       Bool   rc)\n{\n int          count = 0;\n int          tempsize;\n int          wtotempsize;\n Bool         temp_allocated = FALSE;\n char        *type;\n char        *temp;\n char        *wtotemp;\n struct tm   *now;\n time_t       ltime;\n char         datestr \u00dd 65\u00a8;\n\n /* The format of a gopher log entry, as generated by the mother of\n  * all gophers, is:\n  *\n  * Mon Oct 11 14:07:05 1993 13780 support4 : retrieved file foo/bar\n  *\n  */\n\n if (R->outfp) return;\n\n if (!*resource) {\n   if (rc) temp = \"Root Connection\";\n   else    temp = \"error - Root Connection\";\n }\n else {\n   type = GGtype(R->pathtype);\n   if (type\u00dd0\u00a8 == ' ') type = \"Comment\";\n   tempsize = strlen(resource) + strlen(type) + 24;\n   temp = (char *)malloc(tempsize);\n   if (!temp) temp = \"(Error, could not malloc storage for message)\";\n   temp_allocated = TRUE;\n   sprintf(temp,\"%s %c%s %s\",\n                rc ? \"retrieved\" : \"error  - \",\n                tolower(type\u00dd0\u00a8), type+1, resource);\n }\n\n time(&ltime);\n now = localtime(&ltime);\n strftime(datestr,sizeof(datestr)-1,\"%a %b %d %H:%M:%S %Y\",now);\n\n wtotempsize = strlen(temp) + 200;\n wtotemp = (char *)malloc(wtotempsize);\n if (wtotemp) {\n   sprintf(wtotemp,\"%s %s %d %s : %s\",\n                   rc ? GOPHER_MSGID_OK : GOPHER_MSGID_ERROR,\n                   datestr,\n                   count,\n                   /* R->hostname, suppressed for privacy reasons */\n                   \"{}\",\n                   temp);\n   GGwto(wtotemp);\n   free(wtotemp);\n }\n\n if (temp_allocated) free(temp);\n\n}\n\n/*=================================================================*/\n\nstatic Bool\nauthorized_file(RRECV *R)\n{\n return GGacces(R,ACCESS_CHECK);  /* uses R->fileptr as argument */\n}\n\n/*=================================================================*/\n\n/* Generic routine to begin getting data from a gopher resource. */\n\nstatic Bool\ngopher_open(RECV *R)\n{\n char            *opentype;\n\n if (R->openfun) return (R->openfun)(R);\n\n if (R->binary)  opentype = \"rb\";\n else            opentype = \"rb,type=record\";\n\n if (!(R->readfile=fopen(R->buffer,opentype))) {\n   perror(R->buffer);\n   return FALSE;\n }\n return TRUE;\n\n}\n\n/*=================================================================*/\n\n/* Generic routine to stop getting data from a gopher resource. */\n\nstatic Bool\ngopher_close(RECV *R)\n{\n\n if (R->closefun) return (R->closefun)(R);\n\n if (!R->readfile) return FALSE;\n if (fclose(R->readfile) != 0) {\n   fprintf(stderr,\"GGproc: Error closing file %s\\n\",R->fileptr);\n   return FALSE;\n }\n else return TRUE;\n\n}\n\n/*=================================================================*/\n\n/* Generic routine to get text data from a gopher resource. */\n\nstatic Bool\ngopher_read(RECV *R)\n{\n char            *cp;\n\n if (R->readfun) return (R->readfun)(R);\n\n memset(R->buffer,0,RBUFSIZE);\n\n if (R->binary) {\n   R->bytes_read = fread(R->buffer,sizeof(char),RBUFSIZE,R->readfile);\n }\n else {\n   (void)fread(R->buffer,RBUFSIZE,1,R->readfile);\n }\n if (ferror(R->readfile)) {\n   fprintf(stderr,\"GGproc: gopher_read: Error reading file\\n\");\n   R->readstatus = STATUS_ERROR;\n   return FALSE;\n }\n else if (feof(R->readfile)) {\n   R->readstatus = STATUS_EOF;\n   return FALSE;\n }\n if (!R->binary) {\n   if ((cp=strchr(R->buffer,'\\n'))) *cp = '\\0';\n   strip_trailing_in_place(R->buffer);\n }\n R->readstatus = STATUS_OK;\n return TRUE;\n\n}\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*            This routine figures out what type of parm line      */\n/*            the current line is.  We'll return the token         */\n/*            type to the caller.                                  */\n/*                                                                 */\n/*            INPUT:   buffer  pointer to first line of file       */\n/*                       (Note: string must be null terminated!    */\n/*            OUTPUT:   Type of token.  (See in include file...)   */\n/*******************************************************************/\n\nstatic int\nmenukeywd(char  *buffer,\n          char  *token,\n          char  *operand)\n{\n char           *cp;\n char           *tokval;\n char           *oprval;\n char           *tokptr;\n char            tokstr\u00dd256\u00a8;\n\n strcpy(token,\"\");\n strcpy(operand,\"\");\n switch (buffer\u00dd0\u00a8) {\n   case TOKCOMMENT1:\n   case TOKCOMMENT2:\n   case TOKCOMMENT3: return COMMENTTOK;\n }\n strcpy(tokstr,buffer);\n cp = strchr(tokstr,'=');\n if (cp) {\n   *cp = '\\0';\n   strcpy(operand,cp+1);\n }\n tokptr = skip_leading_space(tokstr);\n uppercase_in_place(tokptr);\n strcpy(token,tokptr);\n\n /*********/\n /*  now look at the tokens to see if we have a weener... */\n /*********/\n\n if(EQUAL(tokptr,TOKTYPE)) return(TYPETOK);\n if(EQUAL(tokptr,TOKNAME)) return(NAMETOK);\n if(EQUAL(tokptr,TOKPATH)) return(PATHTOK);\n if(EQUAL(tokptr,TOKHOST)) return(HOSTTOK);\n if(EQUAL(tokptr,TOKPORT)) return(PORTTOK);\n if(EQUAL(tokptr,TOKEND))  return(ENDTOK);\n\n /* for back compatibility with the old MVS GOPHER server */\n\n if(EQUAL(tokptr,TOKDISPLAY)) return(DISPLAYTOK);\n if(EQUAL(tokptr,TOKSELECT))  return(SELECTTOK);\n if(EQUAL(tokptr,TOKSELECT))  return(SELECTTOK);\n\n return(NULLTOK);\n\n}\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*   This routine sends a file to the calling client.              */\n/*   It assumes the file is a text formatted file.                 */\n/*   INPUT:   buffer    pointer to the already read line...        */\n/*            readfile  file we're going to read from..            */\n/*            maxlen    size of the buffer.                        */\n/*            sockfd    socket descriptor for client.              */\n/*                                                                 */\n/*   OUTPUT:   send the file to the client                         */\n/*******************************************************************/\nstatic void\nsendafile(RECV *R)\n{\n\n /*******/\n /*   send the first line (cause we already read it) */\n /*******/\n\n if (!GGouts(R,R->buffer,NO_VALUE)) return;\n\n /*******/\n /*   get the rest of the lines of the file and send them... */\n /*******/\n\n for (;;) {\n   gopher_read(R);\n   switch (R->readstatus) {\n     case STATUS_ERROR:\n      (void)GGouts(R,\"<<<*** I/O ERROR ON MVS FILE ***>>>\",NO_VALUE);\n      return;\n     case STATUS_EOF:\n      break;\n     default:\n      if (!GGouts(R,R->buffer,NO_VALUE)) return;\n      continue;\n   }\n   break;\n }\n}\n\n/*=================================================================*/\n\nstatic void\nsenderrors(RECV *R)\n{\n\n for (;;) {\n   gopher_read(R);\n   switch (R->readstatus) {\n     case STATUS_ERROR:\n      (void)GGouts(R,\"<<<*** I/O ERROR ON MVS FILE ***>>>\",NO_VALUE);\n      return;\n     case STATUS_EOF:\n      break;\n     default:\n      if (R->pathtype == GOPHER_MENU) GGbarf(R,R->buffer);\n      else (void)GGouts(R,R->buffer,NO_VALUE);\n      continue;\n   }\n   break;\n }\n}\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*   This routine formats a menu file into gopher data & sends it  */\n/*   to the client.                                                */\n/*   INPUT:   buffer    pointer to the already read line...        */\n/*            readfile  file we're going to read from..            */\n/*            maxlen    size of the buffer.                        */\n/*            sockfd    socket descriptor for client               */\n/*                                                                 */\n/*   OUTPUT:   send the menu to the client                         */\n/*******************************************************************/\n\n#define MENU_STUFF_SIZE GOPHER_DESC_LENGTH + \\\n                        GOPHER_PATH_LENGTH + \\\n                        GOPHER_HOST_LENGTH + 20\n\nstatic void\nsendamenu(RECV *R)\n{\n char           *operptr;\n char           *tot;                    /*pointer for strtok   */\n char           *cp;\n int             kindotoken;\n int             i;\n char            token   \u00dd133\u00a8;\n char            operand \u00dd133\u00a8;\n char            outbuf  \u00ddMENU_STUFF_SIZE\u00a8;\n char            uphost  \u00ddGOPHER_HOST_LENGTH+1\u00a8;\n MENUITEM        menu;\n\n CLEAR(&menu);\n for (;;) {\n   gopher_read(R);\n   if (R->readstatus != STATUS_OK) break;  /* error or end of file */\n   if (!*R->buffer) continue;\n   kindotoken = menukeywd(R->buffer,token,operand);\n   switch(kindotoken) {\n     case TYPETOK:\n          operptr = skip_whitespace(operand);\n          tot = strtok(operptr,\" \");\n          i = strlen(tot);\n          menu.gopherplus = '\\0';\n          if (i > 1) {\n            cp = &tot\u00ddi-1\u00a8;\n            switch (*cp) {\n              case '+': /* regular gopher+ item */\n              case '?': /* ASK block item */\n                        menu.gopherplus = *cp;\n                        *cp = '\\0';\n                        i--;\n                        break;\n              default:  break;\n            }\n          }\n          if (i == 1) menu.type = *tot;\n          else {\n            uppercase_in_place(tot);\n            if      (EQUAL(tot,TYPEFILE))   menu.type = GOPHER_FILE;\n            else if (EQUAL(tot,TYPEMENU))   menu.type = GOPHER_MENU;\n            else if (EQUAL(tot,TYPECSO))    menu.type = GOPHER_CSO;\n            else if (EQUAL(tot,TYPEINDEX))  menu.type = GOPHER_INDEX;\n            else if (EQUAL(tot,TYPETELNET)) menu.type = GOPHER_TELNET;\n            else if (EQUAL(tot,TYPETN3270)) menu.type = GOPHER_TN3270;\n            else if (EQUAL(tot,TYPEBINARY)) menu.type = GOPHER_BINARY;\n            else if (EQUAL(tot,TYPEWHOIS))  menu.type = GOPHER_WHOIS;\n            else if (EQUAL(tot,TYPEBOOKMANAGER))\n                                        menu.type = GOPHER_BOOKMANAGER;\n            else                        menu.type = GOPHER_ERROR;\n          }\n          break;\n     case NAMETOK:\n     case DISPLAYTOK:\n          strncpy(menu.desc, operand, sizeof(menu.desc));\n          break;\n     case PATHTOK:\n     case SELECTTOK:\n          operptr = skip_whitespace(operand);\n          strncpy(menu.select, operptr, sizeof(menu.select));\n          break;\n     case HOSTTOK:\n          *menu.hostname = '\\0';\n          if (EQUAL(operptr,IDENT_HOST_FROB)) {  /* HOST=+  */\n            strncpy(menu.hostname, R->myname, sizeof(menu.hostname));\n          }\n          else {\n            operptr = skip_whitespace(operand);\n            strncpy(menu.hostname, operptr, sizeof(menu.hostname));\n          }\n          strcpy(uphost, menu.hostname);\n          upcase_and_append_domain_name(R,uphost);\n\n          break;\n     case PORTTOK:\n          operptr = skip_whitespace(operand);\n          if (EQUAL(operptr,IDENT_HOST_FROB))    /* PORT=+  */\n               menu.port = R->myport;\n          else menu.port = atoi(operptr);\n          break;\n     case ENDTOK:\n     case COMMENTTOK:\n          if (menu.port == 0) {\n            switch (menu.type) {\n              case GOPHER_TELNET: break;\n              case GOPHER_TN3270: break;\n              default: menu.port = GOPHER_PORT_NUMBER; break;\n            }\n          }\n          /* If host is local and path is in the form \"(member)\",\n           * and current dsname is a PDS, then use same PDS:\n           * i.e. turn PATH=(FOOBAR) into PATH=AA.BB.CC(FOOBAR)\n           */\n          if (*R->myname\n           && EQUAL(uphost, R->myname)\n           && *menu.select == '('        /* ) */\n           && (cp = strchr(R->dsname,'(' /* ) */ ))) {\n            memcpy(outbuf, R->dsname, (cp-R->dsname));\n            strcpy(outbuf+(cp-R->dsname), menu.select);\n            strncpy(menu.select, outbuf, sizeof(menu.select));\n          }\n          if (menu.type && *menu.desc && *menu.hostname) {\n            sprintf(outbuf,\"%c%s\\t%s\\t%s\\t%d%c%c\",\n                           menu.type,menu.desc,\n                           menu.select,menu.hostname,menu.port,\n                           menu.gopherplus ? '\\t' : '\\0',\n                           menu.gopherplus);\n            if (!GGouts(R,outbuf,NO_VALUE)) return;\n          }\n          fflush(stdout);\n          CLEAR(&menu);\n          break;\n     default:\n          break;\n       }\n   }\n}\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*            This routine determines what type of gopher file     */\n/*            we've opened.  We'll return the file type to the     */\n/*            caller.                                              */\n/*                                                                 */\n/*            INPUT:   ident   pointer to first line of file       */\n/*                                                                 */\n/*            OUTPUT:   MENU   file type is a menu                 */\n/*                      FILE   file type is a file                 */\n/*                      BINARY file type is binary                 */\n/*                      INDEX  file type is an INDEX (not done)    */\n/*******************************************************************/\n\nstatic char\ngetftype(RECV *R)\n{\n char *bufptr;\n char  buffer\u00ddRBUFSIZE\u00a8;\n\n /* If a type was found in the path, use that type. */\n\n if (R->pathtype) return R->pathtype;\n\n /**********/\n /*    else, convert the string to upper case...   */\n /*********/\n copy_uppercase(buffer,R->buffer);\n bufptr = skip_leading_space(buffer);\n\n /**********/\n /*   return the type of file.                     */\n /*********/\n\n if      (EQUAL(bufptr,MENUIDENT))  R->pathtype = GOPHER_MENU;\n else if (EQUAL(bufptr,INDEXIDENT)) R->pathtype = GOPHER_INDEX;\n else /* dunno, assume it's file */ R->pathtype = GOPHER_FILE;\n\n return(R->pathtype);\n\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_directory(RECV *R)\n{\n FILE              *dirfile;\n char              *cp;\n char              *mp;\n int                i;\n short              block_count;\n short              bump_amount;\n Bool               reject;\n Bool               no_more;\n char               dirblk  \u00dd256\u00a8;\n char               pdsspec \u00dd256\u00a8;\n char               entry   \u00dd256\u00a8;\n\n /* The local path name is required for this function. */\n\n if (!(dirfile=fopen(R->buffer,\"rb,recfm=u,lrecl=256\"))) {\n   perror(R->buffer);\n   printf(\"Can't open PDS directory:%s\\n\",R->dsname);\n   GGbarf(R,\"Sorry, the GOPHER server can't open the directory\");\n   return(FALSE);\n }\n\n while (!feof(dirfile)) {\n\n   no_more = FALSE;\n\n   do {\n     memset(dirblk,0x00,256);\n     fread(dirblk,256,1,dirfile);\n     if (feof(dirfile)) break;\n     if (ferror(dirfile)) {\n       printf(\"Can't read PDS directory:%s\\n\", R->fileptr);\n       GGbarf(R,\"Sorry, the GOPHER server can't read the directory\");\n       fclose(dirfile);\n       return FALSE;\n     }\n     mp = dirblk;\n     block_count = *(short *)mp - 2;   /* # bytes in dir block */\n     mp += 2;                        /* addr of dir block data */\n     while (block_count > 0) {\n       if (!memcmp(mp,\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\",8)) break;\n       reject = FALSE;\n       /*\n        * Uncomment this if you want to skip aliases.\n        * It is recommended that you let aliases through, since\n        * they often have better names (e.g. TSO HELP files)\n        *\n        * if ((mp\u00dd11\u00a8 & 0x80) != 0) {\n        *   fprintf(stderr,\"Skipping alias:  %-8.8s\\n\",mp);\n        *   reject = TRUE;\n        * }\n        */\n       if (!reject) {\n         strcpy(pdsspec, R->dsname);\n         cp = strchr(pdsspec, '\\0');\n         *(cp++) = '(';\n         for (i = 0; i < 8 && mp\u00ddi\u00a8 != ' '; cp++, i++) *cp = mp\u00ddi\u00a8;\n         *(cp++) = ')';\n         *cp = '\\0';\n         sprintf(entry,\"0%8.8s\\t%s\\t%s\\t%d\",\n                       mp, pdsspec, R->myname, SERV_TCP_PORT);\n         (void)GGouts(R,entry,NO_VALUE);\n       }\n       bump_amount = 12 + ((mp\u00dd11\u00a8 & 0x1f) * 2);\n       mp += bump_amount;\n       block_count -= bump_amount;\n     }\n   } while(!no_more);\n }\n\n fclose(dirfile);\n return TRUE;\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_flat_file(RECV *R)\n{\n\n if (!gopher_open(R)) {\n   printf(\"INVALID! requested:%s\\n\",R->fileptr);\n   GGbarf(R,\"Sorry, the GOPHER server couldn't open the file\");\n   return(FALSE);\n }\n\n /* A gopher+ client wants a success indication plus \"-1\", which\n    means the following data is delivered in dot-stuffing mode. */\n\n if (R->gopherplus) {\n   if (!GGouts(R,\"+-1\",OUT_PLUS)) return FALSE;\n }\n\n /************/\n /*  get the first line and see what type of file we've got.      */\n /************/\n\n gopher_read(R);\n if (R->readstatus == STATUS_OK) {\n\n  /************/\n  /*  Now let's go do whatever we need to for this file type.    */\n  /************/\n\n   switch (getftype(R)) {\n\n     case GOPHER_MENU:\n                 sendamenu(R);\n                 break;\n     case GOPHER_FILE:\n     default:\n                 sendafile(R);\n                 break;\n   }\n\n }\n\n if (!gopher_close(R)) {\n   GGbarf(R,\"Sorry, the GOPHER server couldn't close the file\");\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_error_file(RECV *R)\n{\n\n if (!gopher_open(R)) {\n   printf(\"INVALID! requested:%s\\n\",R->fileptr);\n   GGbarf(R,\"Sorry, the GOPHER server couldn't open the file\");\n   return(FALSE);\n }\n\n senderrors(R);\n\n if (!gopher_close(R)) {\n   GGbarf(R,\"Sorry, the GOPHER server couldn't close the file\");\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_binary_file(RECV *R)\n{\n Bool rc;\n\n if (!gopher_open(R)) {\n   printf(\"INVALID! requested:%s\\n\",R->fileptr);\n   GGbarf(R,\"Sorry, the GOPHER server couldn't open the binary file\");\n   return(FALSE);\n }\n\n /* A gopher+ client wants a success indication plus \"-2\", which\n    means the following data is delivered in dump-till-close mode. */\n\n rc = TRUE;\n\n if (R->gopherplus) {\n   if (!GGouts(R,\"+-2\",OUT_PLUS)) rc = FALSE;\n }\n\n while (rc) {\n   gopher_read(R);\n   if (R->bytes_read > 0) {\n     if (!GGouts(R,R->buffer,R->bytes_read)) {\n       rc = FALSE;\n       break;\n     }\n   }\n   switch (R->readstatus) {\n     case STATUS_ERROR:\n      (void)GGouts(R,\"<<<*** I/O ERROR ON MVS FILE ***>>>\",NO_VALUE);\n      rc = FALSE;\n      break;\n     case STATUS_EOF:\n      rc = TRUE;\n      break;\n     default:\n      rc = TRUE;\n      continue;\n   }\n   break;\n }\n\n if (!gopher_close(R)) {\n   GGbarf(R,\"Sorry, the GOPHER server couldn't close the file\");\n   return FALSE;\n }\n\n return rc;\n\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_as_file(RECV *R)\n{\n\n switch (R->pathtype) {\n   case GOPHER_MAC_BINHEX:\n   case GOPHER_DOS_BINARCH:\n   case GOPHER_IMAGE:\n   case GOPHER_BINARY:\n   case GOPHER_BOOKMANAGER:\n             R->binary = TRUE;\n             return get_binary_file(R);\n   default:\n             R->binary = FALSE;\n             return get_flat_file(R);\n }\n\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_exec_data(RECV *R)\n{\n\n GGCB              *gp = NULL;     /* for GETMAIN and FREEMAIN */\n char              *command;\n char              *commandargs;\n int                rexxrc;\n int                cmdlen;\n int                scan_count;\n int                i;\n Bool               rc;\n char               exectest\u00ddRBUFSIZE\u00a8;\n\n  /*\n   * Menu item should look like this:\n   *\n   * exec:rexxname any args\n   *\n   * The exec should write output to SYSTSPRT.  Normal TSO command\n   * output will be captured by the SYSTSPRT allocation only if\n   * the Gopher server is run as a batch job.\n   *\n   * If this was sent by the client with a type 7 or type w, then\n   * additional args will appear at the end delimited by a space.\n   */\n\n rc = TRUE;\n scan_count = 0;\n\n if (R->wargptr) {\n   cmdlen = strlen(R->fileptr) + strlen(R->wargptr) + 4;\n   GETMAIN(command, char, cmdlen, \"REXX command buffer\");\n   if (!command) {\n     printf(\"Cannot allocate %d bytes of memory for exec\\n\", cmdlen);\n     GGbarf(R,\"Oops, the GOPHER server ran out of memory\");\n     return FALSE;\n   }\n   else sprintf(command,\"%s %s\",R->fileptr,R->wargptr);\n }\n else {\n   cmdlen = 0;\n   command = R->fileptr;\n }\n\n *exectest = '\\0';\n sscanf(command, \"%s %n\", exectest, &scan_count);\n if (strlen(exectest) > 8) {\n   GGbarf(R,\"Sorry, name of exec is too long\");\n   return FALSE;\n }\n commandargs = command + scan_count;\n\n if (rc) {\n\n   rexxrc = GGrexx(R,exectest,commandargs);\n\n   if (!R->outfp) printf(\"Return code from %s exec is %d\\n\",\n                         exectest, rexxrc);\n\n   if (rexxrc != 0) {\n     GGbarf(R,\"Sorry, the Gopher server was unable to run the exec\");\n     rc = FALSE;\n   }\n   else {\n     rc = get_as_file(R);         /* Display what the exec wrote */\n   }\n\n   if (R->temp) (void)GGtemp(R,R->temp,TEMP_REMOVE);\n\n }\n\n if (cmdlen > 0) FREEMAIN(command, \"REXX command buffer\");\n return rc;\n\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_ftp_data(RECV        *R,\n             GOPHERTYPE   ftptype,\n             char        *resource,\n             OSTYPE       ftpos,\n             char        *ftpprefix\n            )\n{\n  /*\n   * FTP hack.  The syntax is:\n   * ftp0:host:path\n   * ftp0:host:user:path\n   * ftp0:host:user:pass:path\n   * ftp1:host\n   * ftp1:host:path\n   * ftp1:host:user:path\n   * ftp1:host:user:pass:path\n   *\n   * ftpvm0:vmhost:disk/path\n   * ftpvm1:vmhost:disk\n   *\n   * ftp0 means ftp a file.\n   * ftp1 means ftp a directory.\n   * Obviously, ftp0:host cannot exist, because that will always\n   *            look for a remote FTP directory.\n   *\n   * If path is omitted, then path is remote ftp current directory\n   * If user is omitted, defaults to \"anonymous\".\n   * If pass is omitted, defaults to \"client@localhost.domain.qual\"\n   *\n   * The syntax is defined to let path always be the last item\n   * just in case the path name contains a colon.\n   *\n   * For backward compatibility for a very short time, the form\n   * ftp:host(other stuff) will be permitted.  When this is used,\n   * due to the limitations of the Gopher protocol, the only way to\n   * let the server know that a directory instead of a file is wanted\n   * is to append \"/\" to the end of the path.\n   *\n   * And, of course, if the path is omitted then that's got to be a\n   * directory request as well.\n   *\n   * Note for the FTP options\n   *       No authorized-file check is done, because we assume that\n   *       any file available via anonymous ftp is wide open to the\n   *       world to begin with.  Besides, we can't possibly specify\n   *       every remote file in the entire universe, now, can we?\n   */\n\n char              *ftpword1;\n char              *ftpword2;\n char              *ftpword3;\n char              *ftpword4;\n char              *cp;\n GOPHERTYPE         savetype;\n struct Ftp        *F;\n Bool               ftpok;\n IOMODE             crmode;\n struct Ftp         ftp;\n TEMPFILE           outtemp;\n TEMPFILE           errtemp;\n\n ftpok    = FALSE;\n ftpword1 = R->fileptr;\n ftpword2 = \"\";\n ftpword3 = \"\";\n ftpword4 = \"\";\n\n F = &ftp;\n CLEAR(F);\n\n cp = strchr(ftpword1,':');\n if (cp) {\n   *cp = '\\0';\n   ftpword2 = cp + 1;\n   cp = strchr(ftpword2,':');\n   if (cp) {\n     *cp = '\\0';\n     ftpword3 = cp + 1;\n     cp = strchr(ftpword3,':');\n     if (cp) {\n       *cp = '\\0';\n       ftpword4 = cp + 1;\n     }\n   }\n }\n strncpy(F->host, ftpword1, sizeof(F->host));\n if (*ftpword2) {\n   if (*ftpword3) {\n     if (*ftpword4) {\n       strncpy(F->user, ftpword2, sizeof(F->user));\n       strncpy(F->pass, ftpword3, sizeof(F->pass));\n       strncpy(F->path, ftpword4, sizeof(F->path));\n     }\n     else {\n       strncpy(F->user, ftpword2, sizeof(F->user));\n       strncpy(F->path, ftpword3, sizeof(F->path));\n     }\n   }\n   else {\n     strncpy(F->path, ftpword2, sizeof(F->path));\n   }\n }\n\n /* Set defaults for path, user and pass if omitted.\n  * Note that the password is set to client@site.  If the site is\n  * the \"local\" frob, then set it to the domain name, minus the\n  * initial dot that should be there if you configured your MVS\n  * gopher properly.\n  */\n\n if (!*F->path) strcpy(F->path,\"/\");\n if (!*F->user) strcpy(F->user,\"anonymous\");\n if (!*F->pass) {\n\n   /* should this be foo.draper.com@mvs.draper.com\n    * or gopher@foo.draper.com?\n    *\n    * sprintf(F->pass,\"%s@%s\",R->hostname,\n    *   EQUAL(R->myname,LOCAL_HOST_FROB) ? R->mydomain+1 : R->myname);\n    * or\n    * sprintf(F->pass,\"gopher@%s\",R->hostname);\n    *\n    */\n\n   strcpy(F->pass,\"gopher@\");\n\n#ifdef BLAB_MACHINE_NAME_TO_THE_WORLD\n\n   if (*R->hostname)  strcat(F->pass,R->hostname);\n   else if (EQUAL(R->myname,LOCAL_HOST_FROB))\n                      strcat(F->pass,R->mydomain+1);\n   else               strcat(F->pass,R->myname);\n\n#else\n\n   strcat(F->pass,R->mydomain+1);\n\n#endif\n\n }\n\n F->os = ftpos;\n strcpy(F->ftphack, ftpprefix);\n\n switch (ftptype) {\n   case GOPHER_UNKNOWN: /* compatibility mode */\n            cp = F->path + strlen(F->path) - 1;\n            if (*cp == '/') {\n              *cp = '\\0';\n              F->type = GOPHER_DIRECTORY;\n            }\n            else F->type = GOPHER_FILE;\n            crmode = CRLF;\n            break;\n   case GOPHER_MAC_BINHEX:\n   case GOPHER_DOS_BINARCH:\n   case GOPHER_IMAGE:\n   case GOPHER_BINARY:\n   case GOPHER_BOOKMANAGER:\n            F->type = ftptype;\n            crmode = RBIN;\n            break;\n   default:\n            F->type = ftptype;\n            crmode = CRLF;\n            break;\n }\n\n R->pathtype = F->type;\n\n /* Set resource name for logging.  This is to conform with the\n  * UMn Gopher syntax and also to suppress usernames and passwords.\n  */\n\n sprintf(resource,\"ftp:%s@%s\",F->host,F->path);\n\n /* Create temporary files for FTP output. */\n\n CLEAR(&outtemp);\n CLEAR(&errtemp);\n outtemp.crmode = crmode;\n errtemp.crmode = CRLF;\n (void)GGtemp(R,&outtemp,TEMP_CREATE);\n (void)GGtemp(R,&errtemp,TEMP_CREATE);\n F->outfp = GGtemp(R,&outtemp,TEMP_OPEN);\n F->errfp = GGtemp(R,&errtemp,TEMP_OPEN);\n\n if (!F->outfp || !F->errfp) {\n   GGbarf(R,\n   \"Sorry, the GOPHER server couldn't service the remote FTP request\");\n   return FALSE;\n }\n\n if (!memcmp(ftpprefix,\"FTPDEBUG\",8)) F->verboseflag = TRUE;\n\n ftpok = GGftp(R,F);\n\n fflush(F->outfp);\n fflush(F->errfp);\n\n /* Close temporary files. */\n\n F->outfp = GGtemp(R,&outtemp,TEMP_CLOSE);\n F->errfp = GGtemp(R,&errtemp,TEMP_CLOSE);\n\n if (!F->outfp || !F->errfp) {\n   GGbarf(R,\n   \"Sorry, the GOPHER server couldn't service the remote FTP request\");\n   return FALSE;\n }\n\n if (ftpok) {\n   savetype = R->pathtype;\n   if (R->pathtype == GOPHER_MENU) R->pathtype = GOPHER_UNKNOWN;\n   strcpy(R->buffer, outtemp.dsname);\n   ftpok = get_as_file(R);\n   if (savetype != GOPHER_UNKNOWN) R->pathtype = savetype;\n }\n else {\n   strcpy(R->buffer, errtemp.dsname);\n   R->binary = FALSE;\n   ftpok = get_error_file(R);\n }\n\n /* Remove temporary files. */\n\n (void)GGtemp(R,&outtemp,TEMP_REMOVE);\n (void)GGtemp(R,&errtemp,TEMP_REMOVE);\n\n return ftpok;\n\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_info(RRECV *R,\n         char  *resource)\n{\n int               hacksize;      /* length of hack prefix before : */\n Bool              rc;            /* return value */\n DSTYPE            dsntype;       /* SEQ, PDS or UNK */\n char             *p;\n char             *q;\n char             *colonptr;\n char              ddname    \u00dd  9\u00a8;\n char              hackprefix\u00dd 17\u00a8;\n\n *ddname     = '\\0';\n *hackprefix = '\\0';\n\n /*\n  * Process special hacks here.\n  *\n  * For example, if the file name begins with \"exec:\", then\n  * execute the specified REXX exec.\n  *\n  * Hackless names are processed as files.  \"dd:\" is not a\n  * special hack but the normal C/370 DDname reference.\n  *\n  */\n\n colonptr = strchr(R->fileptr,':');\n if (colonptr) {\n   hacksize = colonptr - R->fileptr;\n   if (hacksize > 0 && hacksize < sizeof(hackprefix)) {\n     for (p = hackprefix, q = R->fileptr;\n          hacksize > 0;\n          p++, q++, hacksize--) *p = toupper(*q);\n     *p = '\\0';\n   }\n }\n\n if (EQUAL(hackprefix,\"EXEC\")) {\n  /*\n   * REXX exec, which must reside in GGEXEC DD.\n   */\n   if (!authorized_file(R)) {\n     GGbarf(R,\"Sorry, the GOPHER server won't run the exec for you\");\n     rc = FALSE;\n   }\n   else {\n     R->fileptr = colonptr + 1;  /* point to exec itself */\n     rc = get_exec_data(R);\n   }\n }\n else\n if (EQUAL(hackprefix,\"DD\")) {\n  /*\n   * C/370 style ddname.  Assume sequential file - cannot be a PDS\n   * because I don't feel like trying to determine that right now.\n   */\n   if (!authorized_file(R)) {\n     GGbarf(R,\"Sorry, the GOPHER server won't read the DD for you\");\n     rc = FALSE;\n   }\n   else {\n     strcpy(R->buffer,R->fileptr); /* still points to \"DD:xxxxxxxx\" */\n     strcpy(R->dsname,R->buffer);  /* needed for PATH=(member) check */\n     dsntype = SEQ;\n     rc = get_as_file(R);\n   }\n }\n else\n if (strlen(hackprefix) == 4 && !memcmp(hackprefix,\"FTP\",3)) {\n   R->fileptr = colonptr + 1;  /* point to ftp locator */\n   rc = get_ftp_data(R,hackprefix\u00dd3\u00a8,resource,DEFAULT_OS,\"FTP\");\n }\n else\n if (strlen(hackprefix) == 9 && !memcmp(hackprefix,\"FTPDEBUG\",8)) {\n   R->fileptr = colonptr + 1;  /* point to ftp locator */\n   rc = get_ftp_data(R,hackprefix\u00dd8\u00a8,resource,DEFAULT_OS,\"FTPDEBUG\");\n }\n else\n if (strlen(hackprefix) == 6 && !memcmp(hackprefix,\"FTPVM\",5)) {\n   R->fileptr = colonptr + 1;  /* point to ftp locator */\n   rc = get_ftp_data(R,hackprefix\u00dd5\u00a8,resource,VM_OS,\"FTPVM\");\n }\n else {\n   /* Regular file name without \":\" hack, or with invalid \":\" hack.\n    * Check to see that the file name is on our \"official\" list.\n    */\n   if (!authorized_file(R)) {\n     GGbarf(R,\"Sorry, the GOPHER server won't let you see the file\");\n     rc = FALSE;\n   }\n   else {\n\n   /* Dynamically allocate data set and use generated ddname.\n    * Note that we have to allocate the data set name to a ddname and\n    * then open the ddname to prevent C/370 from barfing on otherwise\n    * valid data set names like those with hyphens in them.  But this\n    * also lets us determine if the data set is sequential or a PDS.\n    */\n     strcpy(R->dsname,R->fileptr);\n     dsntype = GGalloc(R->dsname,ddname,UNK,0);\n     sprintf(R->buffer,\"DD:%s\",ddname);\n     switch (dsntype) {\n       case SEQ: rc = get_as_file(R); break;\n       case PDS: rc = get_directory(R); break;\n       default:\n               printf(\"INVALID! requested:%s\\n\",R->fileptr);\n               GGbarf(R,\n               \"Sorry, the GOPHER server couldn't allocate the file\");\n               rc = FALSE;\n     }\n   }\n }\n\n GGunalc(ddname);  /* free the ddname if set */\n\n return rc;\n\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_the_info(RRECV *R, char *resource, char *plusptr)\n{\n\n if (EQUAL(plusptr,\"+\") || EQUAL(plusptr,\"+0\")) {\n   return get_info(R,resource);\n }\n else {\n   GGbarf(R,\n       \"Sorry, there is no gopher+ support available for this item.\");\n   return FALSE;\n }\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_adm_info(RRECV *R, char *resource, char *plusptr)\n{\n\n GGbarf(R,\n  \"Sorry, there is no extended information available for this item.\");\n return FALSE;\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_dir_info(RRECV *R, char *resource, char *plusptr)\n{\n\n GGbarf(R,\n  \"Sorry, there is no extended information available for this menu.\");\n return FALSE;\n}\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*   This routine Processes the file the user requested.           */\n/*   If it's a menu, we'll form a menu line, if it's a             */\n/*   file, we'll just send it as is.                               */\n/*                                                                 */\n/*   INPUT:   filename  pointer to the file name to open           */\n/*            sockfd    socket descriptor for the client           */\n/*                                                                 */\n/*   OUTPUT:   print \"gopher\" lines.                               */\n/*             TRUE  - file printed ok.                            */\n/*             FALSE - Error reading or writing                    */\n/*******************************************************************/\n\nBool\nGGproc(RECV *R,\n       int  in_local_mode\n      )\n{\n Bool              rc;            /* return value */\n char             *tabptr;\n char             *plusptr;\n char              resource\u00ddRBUFSIZE+1\u00a8;\n\n /************/\n /*  First, strip off any \"bad\" characters from the arguments. */\n /************/\n\n /*\n  * Break the argument up into one or two pieces delimited by tab.\n  * Note that the tab is returned both by an index search item and\n  * by a gopher+ item.  We have to assume that a client capable of\n  * returning gopher+ items will never return a search string that\n  * begins with one of the gopher+ characters.\n  */\n\n R->gopherplus = NULL;\n\n R->fileptr = R->buffer;        /* filename passed in buffer */\n\n tabptr = strchr(R->fileptr,'\\t');\n if (tabptr) {\n   plusptr = tabptr + 1;\n   switch (*plusptr) {\n     case '+':\n     case '!':\n     case '$': R->gopherplus = (GOPHERPLUS *)R; /* temporary */\n               break;\n     default:  break;\n   }\n   *tabptr = '\\0';\n   R->fileptr = trim_leading_and_trailing_space(R->fileptr);\n   R->wargptr = trim_leading_and_trailing_space(tabptr+1);\n }\n else {\n   R->fileptr = trim_leading_and_trailing_space(R->fileptr);\n   R->wargptr = NULL;\n }\n\n strncpy(resource,R->fileptr,sizeof(resource)-1);\n\n if (!*R->fileptr) {\n   R->fileptr = DEFAULT_DIRECTORY;\n }\n\n /* If the *second* character of the path name is a \"/\", then\n  * the first character is a gopher type.\n  * If the first character of the path name is a \"/\", then\n  * strip it off and punt with the rest of the file name.\n  * If the first character is numeric, assume it's a gopher type.\n  * Use the rest of the file name.\n  * Otherwise, punt with the entire file name.\n  */\n\n R->pathtype = '\\0';\n\n if (strlen(R->fileptr) >= 2 && R->fileptr\u00dd1\u00a8 == '/') {\n   R->pathtype = R->fileptr\u00dd0\u00a8;\n   R->fileptr += 2;\n }\n else if (R->fileptr\u00dd0\u00a8 == '/') {\n   R->fileptr++;\n }\n else {\n   switch (*R->fileptr) {\n     case '0':\n     case '1':\n     case '2':\n     case '3':\n     case '4':\n     case '5':\n     case '6':\n     case '7':\n     case '8':\n     case '9':  R->pathtype = R->fileptr\u00dd0\u00a8; R->fileptr++; break;\n     default:   break;\n   }\n }\n\n if (!R->outfp) printf(\"%s: requested:%s;\\n\",R->hostname,R->fileptr);\n\n (void)insure_my_name(R);  /* get host name now before we need it */\n\n if (R->gopherplus) {\n   if (!R->outfp)\n      printf(\"Responding to %s request for gopher+ %s<tab>%s\\n\",\n             R->hostname,R->fileptr,plusptr);\n   switch (*plusptr) {\n     case '+':  rc = get_the_info(R,resource,plusptr);   break;\n     case '!':  rc = get_adm_info(R,resource,plusptr);   break;\n     case '$':  rc = get_dir_info(R,resource,plusptr);   break;\n     default:   GGbarf(R,\"Error, bad Gopher+ request\");\n                rc = FALSE; break;\n   }\n }\n else rc = get_info(R,resource);\n\n if (!rc) {\n   fflush(stdout);\n   fflush(stderr);\n }\n\n if (!in_local_mode) {\n   (void)GGouts(R,NULL,NO_VALUE);      /* send terminating dot */\n }\n\n#ifdef LOG_GOPHER_ACCESSES\n\n log_it(R,resource,rc);\n\n#endif\n\n return rc;\n\n}\n\n./ ADD NAME=GGREXX\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@REXX\")\n#pragma  csect(static,\"GG$REXX\")\n\n#include \"gg.h\"\n#include \"ggrx.h\"\n\n#define NUMBER_OF_REXX_ARGS    2\n#define DIE \\\n  GGbarf(R,\"Sorry, the GOPHER server had a problem with the exec\");\\\n  rexxrc = 999\n\n/*===================================================================*/\n\nstatic void\nload_function(Rexxfun *rfunp,\n              char    *function_name)\n{\n\n if (!*rfunp) {\n   (*rfunp) = (Rexxfun)fetch(function_name);\n   if (!*rfunp) fprintf(stderr,\"Cannot fetch %s\\n\",function_name);\n }\n\n return;\n}\n\n/*===================================================================*/\n\nstatic void\nunload_function(Rexxfun *rfunp)\n{\n\n if (*rfunp) {\n   release((void (*)())(*rfunp));\n   (*rfunp) = (Rexxfun)0;\n }\n\n return;\n}\n\n/*===================================================================*/\n\nint\nGGrexx(RECV *R,\n       char *exectest,\n       char *commandargs\n      )\n{\n GGCB              *gp = NULL;     /* for GETMAIN and FREEMAIN */\n unsigned int       bitflags;\n int                rexxrc = 0;\n int                irxexecrc;\n int                i;\n Rexxfun            irxexec;\n FILE              *fp;\n char               gopherargs\u00dd1025\u00a8;\n PARAMETER          parameter\u00dd11\u00a8;\n struct execblock   execblk;\n struct {\n         struct {\n                 char   *argstring_ptr;\n                 int     argstring_length;\n                }        argstring\u00ddNUMBER_OF_REXX_ARGS\u00a8;\n         int             argstring_end;\n        }                arguments;\n\n irxexec = NULL;\n\n load_function(&irxexec,\"IRXEXEC\");\n if (!irxexec) {\n   DIE;\n }\n\n /* old interface: allocate SYSTSPRT, run the exec, expecting it to\n  * write to SYSTSPRT, then specify on return that the file SYSTSPRT\n  * is to be read to get the gopher output.\n  */\n\n /* new interface: allocate a new file, run the exec, expecting it\n  * to write to that file, then specify on return that the file\n  * is to be read to get the gopher output.\n  */\n\n /* newer interface: run the exec, expecting it\n  * to queue data to the data stack, then take each line on the\n  * data stack and GGouts() it.  On return, no file.\n  */\n\n /* Give the exec an empty SYSTSPRT file to write into.\n  * Then when we read it we can see only what was added.\n  * Since IRXEXEC doesn't close SYSTSPRT, we can't remove it\n  * and reallocate it.\n  */\n\n /* Create a temporary file. */\n\n if (!R->temp) {\n\n   GETMAIN(R->temp, struct tempfile, 1, \"REXX temp file struct\");\n   if (!R->temp) {\n     fprintf(stderr,\"GGrexx: Cannot get a temp file struct\\n\");\n     DIE;\n   }\n\n   CLEAR(R->temp);\n   R->temp->crmode = CRLF;  /* for now, just assume non-binary */\n\n   (void)GGtemp(R,R->temp,TEMP_CREATE);\n\n }\n\n fp = GGtemp(R,R->temp,TEMP_OPEN);\n\n if (!fp) {\n   printf(\"Cannot open temporary file for REXX exec\\n\");\n   DIE;\n }\n\n /* Open for write + close = clear it out */\n\n else if (fclose(fp) < 0) {\n   printf(\"Cannot close temporary file for REXX exec\\n\");\n   DIE;\n }\n\n if (rexxrc != 0) return rexxrc;\n\n /* Set up parameters for IRXEXEC:\n  *\n  * Param 1  -  address of EXECBLK\n  * Param 2  -  address of arguments\n  * Param 3  -  bitflags\n  * Param 4  -  address of INSTBLK\n  * Param 5  -  address of CPPL\n  * Param 6  -  address of EVALBLOCK\n  * Param 7  -  address of 8-byte work area\n  * Param 8  -  address of user field\n  * Param 9  -  address of environment block\n  * Param 10 -  return code\n  */\n\n /* set up exec block */\n\n CLEAR(&execblk);\n execblk.length = sizeof(execblk);\n memcpy (execblk.acryn, \"IRXEXECB\", 8);\n strncpy(execblk.member,exectest,8);\n for (i=0;i<8;i++) {\n   if (execblk.member\u00ddi\u00a8 == '\\0')\n       execblk.member\u00ddi\u00a8 = ' ';\n }\n /* We may have just clobbered this, so do this after... */\n\n memcpy (execblk.ddname, REXX_EXEC_LIBRARY_DDNAME, 8);\n memcpy (execblk.subcom, REXX_EXEC_SUBCOM, 8);\n\n /* set up arguments  */\n\n sprintf(gopherargs,\"OUTDD=%s;HOST=%s;PORT=%d;CLIENT=%s\",\n                    R->temp->ddname+3,\n                    R->myname,\n                    R->myport,\n                    R->hostname);\n\n arguments.argstring\u00dd0\u00a8.argstring_ptr    = commandargs;\n arguments.argstring\u00dd0\u00a8.argstring_length = strlen(commandargs);\n arguments.argstring\u00dd1\u00a8.argstring_ptr    = gopherargs;\n arguments.argstring\u00dd1\u00a8.argstring_length = strlen(gopherargs);\n arguments.argstring_end                 = 0xffffffff;\n\n /* Invoke the rexx exec */\n\n bitflags = (unsigned int)(INVOKE_EXEC_AS_COMMAND +\n                           RETURN_EXTENDED_RETURN_CODES);\n\n parameter\u00dd 1\u00a8 =   (PARAMETER)&execblk;\n parameter\u00dd 2\u00a8 =   (PARAMETER)&arguments;\n parameter\u00dd 3\u00a8 =   (PARAMETER)bitflags;\n parameter\u00dd 4\u00a8 =   (PARAMETER)NULL;  /* no INSTBLK */\n parameter\u00dd 5\u00a8 =   (PARAMETER)NULL;  /* no CPPL    */\n parameter\u00dd 6\u00a8 =   (PARAMETER)NULL;  /* no eval block */\n parameter\u00dd 7\u00a8 =   (PARAMETER)NULL;  /* no work area */\n parameter\u00dd 8\u00a8 =   (PARAMETER)NULL;  /* no user field, last parm */\n parameter\u00dd 9\u00a8 =   (PARAMETER)NULL;  /* no environment block */\n parameter\u00dd10\u00a8 =   (PARAMETER)0;     /* return code */\n\n if (!R->outfp) {\n   printf(\"Executing:%s %s\\n\", exectest, commandargs);\n   printf(\"Gopherargs:%s\\n\",gopherargs);\n }\n\n irxexecrc = (*irxexec) (\n                         &parameter\u00dd1\u00a8,\n                         &parameter\u00dd2\u00a8,\n                         &parameter\u00dd3\u00a8,\n                         &parameter\u00dd4\u00a8,\n                         &parameter\u00dd5\u00a8,\n                         &parameter\u00dd6\u00a8,\n                         &parameter\u00dd7\u00a8,\n                         LASTPARM(&parameter\u00dd8\u00a8), /* old REXX */\n                         &parameter\u00dd9\u00a8,\n                         LASTPARM(&parameter\u00dd10\u00a8) /* new REXX */\n                        );\n\n if (irxexecrc != 0) {\n   fprintf(stderr,\"Return code from IRXEXEC is %d\\n\", irxexecrc);\n   rexxrc = irxexecrc;\n }\n else {\n   rexxrc = irxexecrc;              /* old REXX */\n   /* rexxrc = parameter\u00dd10\u00a8; */    /* new REXX */\n   strcpy(R->buffer,R->temp->ddname);\n   R->fileptr = R->buffer;          /* Prepare for get-as-file */\n   R->openfun  = NULL;\n   R->readfun  = NULL;\n   R->closefun = NULL;\n }\n\n unload_function(&irxexec);\n\n return rexxrc;\n\n}\n\n./ ADD NAME=GGSERVE\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*\n ***********************************************************************\n *                                                                     *\n * GOPHER server, based on the simple TCP/IP server from Shawn Hart at *\n * the University of Delaware.                                         *\n *                                                                     *\n ***********************************************************************\n *\n *  This server follows the GOPHER protocols defined by UMN.\n *  For more information, see the ANONYMOUS FTP site at\n *  BOOMBOX.MICRO.UMN.EDU.\n *\n ***********************************************************************\n *\n * November 1992 - parameters may be passed to the server:\n *\n * -d              run in debug mode\n *\n ***********************************************************************\n *\n * December 1992 - support for SNS/TCPAccess compilation\n *\n ***********************************************************************\n */\n\n#pragma  csect(code,  \"GG@SERVE\")\n#pragma  csect(static,\"GG$SERVE\")\n#include \"gg.h\"\n\n/********************************************************************/\n\nstatic int\ntcpsetup(int          port,\n         int          qlen,\n         int          mtftasks,\n         FILE        *debugfp)\n{\n int                  tinitrc;             /* loop counter*/\n int                  sockfd;              /* loop counter*/\n int                  x;                   /* loop counter*/\n struct linger        l;                   /* linger for setsockopt */\n struct sockaddr_in   server;          /*server address information */\n\n /*    initialize the MTF  environment.                   */\n\n if (debugfp) {\n   fprintf(debugfp,\"tinit...\\n\");\n   fflush(debugfp);\n }\n\n tinitrc = tinit(\"GGSTASK\", mtftasks);\n\n if (tinitrc != MTF_OK) {\n   GGmtfer(tinitrc, \"TINIT\");\n   return -1;\n }\n\n /*       open a TCP socket...                            */\n\n if (debugfp) {\n   fprintf(debugfp,\"socket...\\n\");\n   fflush(debugfp);\n }\n\n if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n   REPORT_TCP_ERROR(\"SOCKET - \");\n   return -1;\n };\n\n /*  set the linger option on so we wait for data to be sent... */\n\n l.l_onoff  =  1;\n l.l_linger =100;           /* wait 100 seconds before giving up */\n\n if (debugfp) {\n   fprintf(debugfp,\"setsockopt (%d, SO_LINGER)...\\n\",sockfd);\n   fflush(debugfp);\n }\n\n if (setsockopt(sockfd,SOL_SOCKET,SO_LINGER,(char *)&l,sizeof(l))\n     < 0) {\n   REPORT_TCP_ERROR(\"SETSOCKOPT - \");\n   return -1;\n }\n\n /*    now bind our local address so that the client can send to us */\n\n memset((char *)&server, 0, sizeof(server));\n server.sin_family           =   AF_INET;\n server.sin_addr.s_addr      =   INADDR_ANY;\n server.sin_port             =   htons(port);\n\n if (debugfp) {\n   fprintf(debugfp,\"bind (%d)...\\n\",sockfd);\n   fflush(debugfp);\n }\n\n if (Bind(sockfd, &server, sizeof(server)) < 0) {\n   REPORT_TCP_ERROR(\"BIND - \");\n   return -1;\n }\n\n /*    now set length of the connection queue... */\n\n if (debugfp) {\n   fprintf(debugfp,\"listen (sockfd=%d, qlen=%d)...\\n\",sockfd,qlen);\n   fflush(debugfp);\n }\n\n if (listen(sockfd,qlen) != 0) {\n   REPORT_TCP_ERROR(\"LISTEN -\");\n   return -1;\n }\n\n return sockfd;\n\n}\n\n\n/********************************************************************/\n/*\n*   This routine waits for an exception on the socket.  When one\n*   occurs (by a subtask's \"TAKESOCKET\"!) we'll close our (the main\n*   task's) connection to it.\n*\n*               INPUT   s   pointer to socket descripter.\n*               OUTPUT  rc  -1 = connection timed out...\n*                            0 = an excption occured!\n*/\n/********************************************************************/\n\n#ifdef SNSTCPIP\n\nstatic int\nclosesock(int              newsockfd,\n          int              timeout,\n          FILE            *debugfp)\n{\n if (debugfp) {\n   fprintf(debugfp,\"close (%d)...\\n\",newsockfd);\n   fflush(debugfp);\n }\n\n if (close(newsockfd) < 0) REPORT_TCP_ERROR(\"CLOSE -\");\n return 0;\n}\n\n#else\n\nstatic int\nclosesock(int              newsockfd,\n          int              timeout,\n          FILE            *debugfp)\n{\n int                       temps;\n struct sockaddr           clientaddress;\n int                       addrlen;\n int                       maxfdpl;\n struct fd_set             readmask;\n struct fd_set             writmask;\n struct fd_set             exepmask;\n int                       rc;\n struct timeval            time;\n\n temps = newsockfd;\n time.tv_sec = timeout;\n time.tv_usec = 0;\n maxfdpl = temps + 1;\n\n FD_ZERO(&readmask);\n FD_ZERO(&writmask);\n FD_ZERO(&exepmask);\n FD_SET(temps, &exepmask);\n\n if (debugfp) {\n   fprintf(debugfp,\"select (maxfdpl=%d)...\\n\",maxfdpl);\n   fflush(debugfp);\n }\n\n rc = select(maxfdpl, &readmask, &writmask, &exepmask, &time);\n\n if (rc < 0) {\n   REPORT_TCP_ERROR(\"SELECT - \");\n   return rc;\n }\n else {\n   if (rc == 0) fprintf(stdout,\"The GIVESOCKET timed out!\\n\");\n\n   if (debugfp) {\n     fprintf(debugfp,\"close (%d)...\\n\",newsockfd);\n     fflush(debugfp);\n   }\n\n   if (close(newsockfd) < 0) REPORT_TCP_ERROR(\"CLOSE -\");\n   return rc;\n }\n}\n\n#endif\n\n/********************************************************************/\n/*\n*       This routine starts a subtask, passing control of a socket\n*       to it.  It then waits for the subtask to take the socket and\n*       then closes the socket.\n*\n*       INPUT: newsockfd - socket descriptor to give to subtask.\n*/\n/********************************************************************/\n\nstatic Bool\nspawn(\n      int           newsockfd,\n      int           timeout,\n      RECV         *recvp,\n      FILE         *debugfp)\n{\n int                tschedrc;\n#ifdef SNSTCPIP\n unsigned long      token;\n#else\n struct clientid    clid;\n char               mysname\u00dd8\u00a8;\n#endif\n\n if (debugfp) {\n   fprintf(debugfp,\"getclientid...\\n\");\n   fflush(debugfp);\n }\n\n#ifdef SNSTCPIP\n\n token = closepass(newsockfd);\n if (debugfp) {\n   fprintf(debugfp,\"token = %X\\n\",token);\n   fflush(debugfp);\n }\n\n#else\n\n memset(&clid,0,sizeof(clid));\n if(getclientid(AF_INET,&clid) < 0) {\n   REPORT_TCP_ERROR(\"GETCLIENTID\");\n   return FALSE;\n }\n\n if (debugfp) {\n   fprintf(debugfp,\"client name = %8.8s, subtaskname = %8.8s\\n\",\n                   clid.name, clid.subtaskname);\n   fflush(debugfp);\n }\n\n clid.domain = AF_INET;\n memcpy(mysname,clid.subtaskname,8);\n memcpy(clid.subtaskname,\"        \",8);\n\n if (debugfp) {\n   fprintf(debugfp,\"givesocket (%d)...\\n\",newsockfd);\n   fflush(debugfp);\n }\n\n if(givesocket(newsockfd,&clid) != 0) {\n   REPORT_TCP_ERROR(\"GIVESOCKET\");\n   return FALSE;\n }\n memcpy(clid.subtaskname,mysname,8);\n\n if (debugfp) {\n   fprintf(debugfp,\"client name = %8.8s, subtaskname = %8.8s\\n\",\n                   clid.name, clid.subtaskname);\n   fflush(debugfp);\n }\n\n#endif\n\n if (debugfp) {\n   fprintf(debugfp,\"tsched...\\n\");\n   fflush(debugfp);\n }\n\n tschedrc = tsched(MTF_ANY,\"GGSRECV\",\n#ifdef SNSTCPIP\n                           token,\n#else\n                           newsockfd,\n                           clid,\n#endif\n                           recvp,\n                           (debugfp ? 1 : 0));\n\n if (debugfp) {\n   fprintf(debugfp,\"tsched completed...rc=%d\\n\",tschedrc);\n   fflush(debugfp);\n }\n\n if (tschedrc != 0) {\n   GGmtfer(tschedrc,\"TSCHED\");\n   return FALSE;\n }\n\n if (closesock(newsockfd,timeout,debugfp) < 0) {\n   REPORT_TCP_ERROR(\"close socket\");\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/******************************************************************/\n\nstatic Bool\nnumparm(\n        char *pvar,\n        char *pval,\n        int  *ivalp\n       )\n{\n if (*(pval + strspn(pval,\"0123456789\"))) {\n   fprintf(stdout,\"Non-numeric value given for %s: %s\\n\",\n                  pvar, pval);\n   return FALSE;\n }\n else {\n  *ivalp = atoi(pval);\n  return TRUE;\n }\n}\n\n/******************************************************************/\n\nint\nmain(int            argc,\n         char     **argv)\n{\n int                trc;               /* return code */\n int                x;                 /* loop counter*/\n int                sockfd;            /* connection socket...*/\n int                newsockfd;         /* new connection socket...*/\n int                clientlen;         /* new connection socket...*/\n int                i;\n int                n;\n int                ival;\n char               cval;\n char              *p;\n char              *cp;\n FILE              *debugfp;\n FILE              *pfp;\n struct sockaddr_in client;            /* client address information */\n#ifndef SNSTCPIP\n struct clientid    clid;              /* client info for givesocket */\n#endif\n RECV               recvtemplate;\n int                mtftasks;\n int                port;\n int                qlength;\n int                timeout;\n char               telnet   \u00dd257\u00a8;\n char               bookmgr  \u00dd257\u00a8;\n char               domain   \u00dd257\u00a8;\n char               pline    \u00ddRBUFSIZE\u00a8;\n char               pvar     \u00ddRBUFSIZE\u00a8;\n char               pval     \u00ddRBUFSIZE\u00a8;\n char               buffer   \u00dd255\u00a8;      /* buffer for input/output*/\n\n/******************************************************************/\n/* Set parameter defaults.                                        */\n/******************************************************************/\n\n mtftasks     = MTF_TASKS;\n port         = SERV_TCP_PORT;\n qlength      = TCP_QUEUE_LENGTH;\n timeout      = CONNECT_TIME_OUT;\n COPY(telnet,   TELNET_COMMAND_NAME);\n COPY(bookmgr,  BOOKMGR_COMMAND_NAME);\n COPY(domain,   MY_DOMAIN_SUFFIX);\n\n/******************************************************************/\n/* Process server parameters.                                     */\n/******************************************************************/\n\n debugfp = NULL;\n\n for (i = 1; i < argc; i++) {\n   p = argv\u00ddi\u00a8;\n   if (*p == '-') {\n     while (*++p) {\n       switch (toupper(*p)) {\n         case 'D':  debugfp = fopen(DEBUG_FILE,\"w\");\n                    break;\n         default:   break;\n       }\n     }\n   }\n }\n\n/******************************************************************/\n/*         Read startup parameters from parameter file.           */\n/******************************************************************/\n\n/*\n * If dd:GGPARMS is present, then read parameters therefrom.\n * If not, then use defaults.  In any case, defaults will be\n * assigned where a corresponding parameter file line isn't found,\n *\n * Syntax of parameter file lines:\n *\n * VARIABLE value   comments\n *\n * e.g.\n *\n * MTFTASKS    8    the number of tasks\n *\n * Comments are indicated by \"!\" in col 1.\n *\n */\n\n pfp = fopen(PARAMETER_FILE,\"r\");\n if (!pfp) {\n   perror(PARAMETER_FILE);\n   fprintf(stdout,\n           \"No parameter file.  Using all installed defaults.\\n\");\n   fflush(stderr);\n }\n else {\n   for (;;) {\n     fgets(pline, sizeof(pline), pfp);\n     if (ferror(pfp)) {\n       fprintf(stderr,\"Error reading parameters from %s\\n\",\n                      PARAMETER_FILE);\n       fflush(stderr);\n       break;\n     }\n     if (feof(pfp)) break;\n     cp = pline;                     /* Start parameter scan       */\n     if (*cp == '!') continue;       /* Skip comment               */\n     *pvar = '\\0';                   /* Clear parameter variable   */\n     sscanf(cp,\"%s %n\",pvar,&n);     /* Get parameter, bump scan   */\n     if (!*pvar) continue;           /* If nothing on line, skip   */\n     uppercase_in_place(pvar);       /* Fold variable name         */\n     cp += n;                        /* Bump to next word in file  */\n     *pval = '\\0';                   /* Clear parameter value      */\n     sscanf(cp,\"%s %n\",pval,&n);     /* Get next word, bump scan   */\n     if (!*pval) {\n       fprintf(stdout,\"Parameter error: value missing for %s\\n\",\n                      pvar);\n       continue;\n     }\n     fprintf(stderr,\"Setting %s to '%s' (%d)\\n\",pvar,pval,ival);\n     if      (EQUAL(pvar,\"MTFTASKS\" )) {\n                                        if (numparm(pvar,pval,&ival))\n                                           mtftasks = ival;\n                                       }\n     else if (EQUAL(pvar,\"PORT\"     )) {\n                                        if (numparm(pvar,pval,&ival))\n                                           port     = ival;\n                                       }\n     else if (EQUAL(pvar,\"QLENGTH\"  )) {\n                                        if (numparm(pvar,pval,&ival))\n                                           qlength  = ival;\n                                       }\n     else if (EQUAL(pvar,\"TIMEOUT\"  )) {\n                                        if (numparm(pvar,pval,&ival))\n                                           timeout  = ival;\n                                       }\n     else if (EQUAL(pvar,\"TELNET\"   )) {\n                                        uppercase_in_place(pval);\n                                        COPY(telnet,pval);\n                                       }\n     else if (EQUAL(pvar,\"BOOKMGR\"  )) {\n                                        uppercase_in_place(pval);\n                                        COPY(bookmgr,pval);\n                                       }\n     else if (EQUAL(pvar,\"DOMAIN\"   )) {\n                                        uppercase_in_place(pval);\n                                        COPY(domain,pval);\n                                       }\n     else {\n       fprintf(stdout,\"Unknown parameter, %s.  Skipping.\\n\",pvar);\n     }\n   }\n   (void)fclose(pfp);\n }\n\n/******************************************************************/\n/*         display parameter values in effect                     */\n/******************************************************************/\n\n /* Set defaults to pass to the subtask. */\n\n CLEAR(&recvtemplate);\n\n recvtemplate.myport       = port;\n recvtemplate.mytelnet     = telnet;\n recvtemplate.mybkmgr      = bookmgr;\n recvtemplate.mydomain     = domain;\n recvtemplate.accvector    = NULL; /* set when access table loaded */\n\n fprintf(stdout,\"Parameter values in effect:\\n\\n\");\n fprintf(stdout,\"MTFTASKS = %d\\n\", mtftasks);\n fprintf(stdout,\"QLENGTH  = %d\\n\", qlength);\n fprintf(stdout,\"TIMEOUT  = %d\\n\", timeout);\n fprintf(stdout,\"PORT     = %d\\n\", recvtemplate.myport);\n fprintf(stdout,\"TELNET   = %s\\n\", recvtemplate.mytelnet);\n fprintf(stdout,\"BOOKMGR  = %s\\n\", recvtemplate.mybkmgr);\n fprintf(stdout,\"DOMAIN   = %s\\n\", recvtemplate.mydomain);\n fprintf(stdout,\"\\n\");\n\n fflush(stdout);\n\n/******************************************************************/\n/*         load the access table                                  */\n/******************************************************************/\n\n if (!GGacces(&recvtemplate,ACCESS_LOAD)) {\n   fprintf(stdout,\"Could not load the access table!\\n\");\n   exit(16);\n }\n\n/******************************************************************/\n/*         set up the connection to the socket...                 */\n/******************************************************************/\n\n sockfd = tcpsetup(port,qlength,mtftasks,debugfp);\n if (sockfd < 0) {\n   fprintf(stdout,\"Could not set up the TCP/IP environment!\\n\");\n   exit(16);\n }\n\n/******************************************************************/\n/*         Now loop, waiting for a connection request.            */\n/******************************************************************/\n\n clientlen = sizeof(client);\n x = 0;\n for (;;) {\n\n   if (debugfp) {\n     fprintf(debugfp,\"accept (%d)...\\n\",sockfd);\n     fflush(debugfp);\n   }\n\n   if ((newsockfd=Accept(sockfd,&client,&clientlen)) == -1) {\n     REPORT_TCP_ERROR(\"ACCEPT - \");\n     exit(8);\n   }\n   if (debugfp) {\n     fprintf(debugfp,\"newsockfd=%d...\\n\",newsockfd);\n     fflush(debugfp);\n   }\n\n   x++;\n   if (!spawn(newsockfd,timeout,&recvtemplate,debugfp)) {\n     fprintf(stdout,\"spawn failed for socket %d\\n\",newsockfd);\n     exit(8);\n   }\n   else {\n     if (debugfp) {\n       fprintf(debugfp,\"spawn OK for socket %d\\n\",newsockfd);\n       fflush(debugfp);\n     }\n   }\n }\n\n/******************************************************************/\n/*         Wait for all pending tasks to complete (should never   */\n/*         run, since I haven't added PURGE support yet...)       */\n/*         then shut down subtasks.                               */\n/******************************************************************/\n\n if (debugfp) {\n   fprintf(debugfp,\"tsyncro...\\n\");\n   fflush(debugfp);\n }\n\n trc = tsyncro(MTF_ALL);\n if (trc != 0) {\n   GGmtfer(trc,\"TSYNCRO\");\n }\n\n if (debugfp) {\n   fprintf(debugfp,\"tterm...\\n\");\n   fflush(debugfp);\n }\n\n trc = tterm();\n if (trc != 4) {\n   GGmtfer(trc,\"TTERM\");\n   exit(8);\n }\n\n (void)GGacces(&recvtemplate,ACCESS_FREE);  /* free access table */\n\n if (debugfp) fclose(debugfp);\n\n exit(0);\n\n}\n./ ADD NAME=GGSLEEP\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@SLEEP\")\n#pragma  csect(static,\"GG$SLEEP\")\n\n#include \"gg.h\"\n#include \"ggsvc.h\"\n\n#define STIMER_SVC     47\n\nint\nGGsleep(int    seconds)\n{\n int           hundredths_of_a_second;\n SVC_REGISTER  reg15;\n SVC_REGISTER  reg0;\n SVC_REGISTER  reg1;\n\n hundredths_of_a_second = seconds * 100;\n\n reg15 = (SVC_REGISTER) 0;\n reg0  = (SVC_REGISTER) 0x91000000;\n reg1  = (SVC_REGISTER) &hundredths_of_a_second;\n\n SVC(STIMER_SVC,&reg15,&reg0,&reg1);\n\n return (int)reg15;\n\n}\n\n./ ADD NAME=GGSOCKT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@SOCKT\")\n#pragma  csect(static,\"GG$SOCKT\")\n#include \"gg.h\"\n\n/****** Output one data line for the server. *************************/\n\nBool\nGGsockt(gp,sp)\nRGGCB  *gp;\nRCONN  *sp;\n{\n RECV  *R;\n char  *s_buf;\n int    gopher_bytes;\n int    writrc;\n Bool   procok;\n\n /* Before sending a request to the server, do a cleanup operation\n  * to make sure that no more responses are coming from the server.\n  * This is done by GGservr here, but it is now done outside so that\n  * the FTP gateway can call this routine without linkind it in.\n  *\n  *  GGesrvr(gp,sp);           -- End server read --\n  *\n  */\n\n /* If local mode, call server subtask processor with command. */\n\n if (gp && (R=gp->recvp) && !sp->is_ftp) {\n   if (!R->outfp) {\n     CRIT1(\"Can't send data locally, non-socket not connected\");\n     return FALSE;\n   }\n   strncpy(R->buffer, gp->gopher_command, sizeof(R->buffer)-1);\n   strcpy(R->myname, LOCAL_HOST_FROB);  /* used by PDS feature */\n\n   /* allocate SYSTSPRT file, used by REXX EXEC interface */\n\n   if (GGtso(\n     \"ALLOC FI(SYSTSPRT) T SP(100 100) REL REU DEL\"\n     \" RECFM(V B) LRECL(1024) BLKSIZE(32760)\"\n             ) != 0) {\n     fprintf(stderr,\n       \"Warning: Cannot allocate temporary SYSTSPRT file.\\n\");\n     fprintf(stderr,\n       \"         Some interfaces may not work properly.\\n\");\n   }\n\n   procok = GGproc(R,TRUE);\n\n   /* free SYSTSPRT file, used by REXX EXEC interface */\n\n   (void)GGunalc(\"SYSTSPRT\");\n\n   /* Prepare to read from the beginning of the file */\n\n   if (fseek(R->outfp, 0, SEEK_SET) != 0) {\n     CRIT1(\"Can't reposition to start of local file\");\n     return FALSE;\n   }\n   return TRUE;   /* used to return procok but want to see barfs */\n }\n\n if (gp) {\n   gopher_bytes = strlen(gp->gopher_command);\n   memcpy(sp->client_buf,gp->gopher_command,gopher_bytes);\n }\n else {\n   gopher_bytes = strlen(sp->client_buf);\n }\n\n sp->client_buf\u00ddgopher_bytes\u00a8   = CARRIAGE_RETURN;\n sp->client_buf\u00ddgopher_bytes+1\u00a8 = LINE_FEED;\n\n if (!sp->is_ftp        &&\n     sp->receiving_text &&\n     gopher_bytes == 1  &&\n     sp->client_buf\u00dd0\u00a8 == '.') {\n   sp->receiving_text = FALSE;\n }\n\n if (gp && gp->debug_mode)\n    GGdump(gp,\"Writing to server\",sp->client_buf,gopher_bytes+2);\n\n EBCDIC_TO_ASCII(sp->client_buf,gopher_bytes+2);\n\n writrc = write(sp->ns, sp->client_buf, gopher_bytes+2);\n if (writrc < 0) {\n   sp->connection_broken = TRUE;\n   if (gp) {\n     CRIT2(\"TCP/IP error: write() failed to send data to server %s.\",\n           gp->ggserver);\n   }\n   else {\n     fprintf(stderr,\n             \"TCP/IP error: write() failed to send data to server %s.\",\n             sp->server_hostname);\n   }\n   return FALSE;\n }\n\n if (sp->is_ftp) return TRUE;\n\n /* Prepare server for read. */\n\n sp->server_has_nothing       = FALSE;\n sp->server_finished_replying = FALSE;\n sp->sending_text             = FALSE;\n sp->dont_read                = FALSE;\n\n ISPF(\"CONTROL DISPLAY LOCK\");\n ISPF(\"DISPLAY PANEL(GGMLSOCK)\");\n\n return TRUE;\n}\n\n./ ADD NAME=GGSOPT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@SOPT \")\n#pragma  csect(static,\"GG$SOPT \")\n#include \"gg.h\"\n\n#define BOOLOPTSET(A,B,C) \\\n   switch (A\u00dd0\u00a8) { \\\n     case  'n': \\\n     case  'N':   B = FALSE; break; \\\n     case  'y': \\\n     case  'Y':   B = TRUE; break; \\\n     case '\\0': \\\n     default:     B = C; break; \\\n   }\n\n/****** Set options that are stored in ISPF profile. *****************/\n\nvoid\nGGsopt(gp,which)\nRGGCB *gp;\nOPTION which;\n{\n int   arrows;\n char  ggextpow \u00dd  4\u00a8;\n char  ggextpap \u00dd  4\u00a8;\n char  ggscroll \u00dd  4\u00a8;\n char  ggcursor \u00dd  4\u00a8;\n\n if (which == OPTION_ALL) {\n   ISPF(\"VGET (GGEXTPOW GGEXTPAP GGSCROLL GGCURSOR) PROFILE\");\n }\n\n if (which == OPTION_ALL || which == OPTION_OTHER) {\n   VGET(\"GGEXTPOW \", ggextpow);\n   VGET(\"GGEXTPAP \", ggextpap);\n   BOOLOPTSET(ggextpow, gp->warn_overwrite, TRUE);\n   BOOLOPTSET(ggextpap, gp->warn_append,    TRUE);\n }\n\n if (which == OPTION_ALL || which == OPTION_VIEW) {\n   VGET(\"GGSCROLL \", ggscroll);\n   VGET(\"GGCURSOR \", ggcursor);\n   BOOLOPTSET(ggscroll, gp->autoscroll, TRUE);\n   BOOLOPTSET(ggcursor, gp->autocursor, FALSE);\n }\n\n return;\n}\n\n./ ADD NAME=GGSTASK\n\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GGSTASK \")\n#pragma  csect(static,\"GG$TASK \")\n#include \"gg.h\"\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*                                                                 */\n/*    this is a debugging routine;  it looks at the status of a    */\n/*    socket.                                                      */\n/*******************************************************************/\n\nstatic void\nlookatsocket(int sockfd)\n{\n int             rc;                       /* return code */\n int             length;                   /* length variable */\n int             option;\n int             x;\n struct linger   l;                        /* linger structure */\n char            buffer\u00ddRBUFSIZE\u00a8;\n\n length = sizeof(l);\n if (Getsockopt(sockfd,SOL_SOCKET, SO_LINGER,&l,&length)==0) {\n   printf(\"l_onoff=%d\\n\",l.l_onoff);\n   printf(\"l_linger=%d\\n\",l.l_linger);\n }\n else REPORT_TCP_ERROR(\"GETSOCKOPT\");\n\n length = sizeof(option);\n if (Getsockopt(sockfd,SOL_SOCKET, SO_ERROR,&option,&length)==0) {\n   printf(\"so_error=%d\\n\",option);\n }\n else REPORT_TCP_ERROR(\"GETSOCKOPT\");\n\n if (fcntl(sockfd,F_SETFL,FNDELAY)!=0) REPORT_TCP_ERROR(\"FCNTL\");\n\n length = recv(sockfd,buffer,sizeof(buffer)-1,0);\n if (length == -1) {\n   if (errno != EWOULDBLOCK) REPORT_TCP_ERROR(\"recv\");\n }\n else {\n   buffer\u00ddsizeof(buffer)-1\u00a8 = 0;\n   printf(\"buffer =%s\\n\",buffer);\n   for (x=0;x<length;x++) printf(\"%x \",buffer\u00ddx\u00a8);\n   printf(\"\\n\");\n }\n\n}\n\n/*******************************************************************/\n\n/**************************************************************/\n/*    this routine processes the data once a connection       */\n/*    has been accepted.  It just takes the data sent by the  */\n/*    client and prints it to sysprint, then sends it back    */\n/*    to the client.                                          */\n/*                                                            */\n/*             INPUT:   newsockfd  - socket descriptor        */\n/*                      clid       - takesocket structure...  */\n/**************************************************************/\n\nvoid\nGGSrecv(\n#ifdef SNSTCPIP\n unsigned long      token,\n#else\n int                newsockfd,\n struct clientid    clid,\n#endif\n RECV              *recvtp,\n int                is_debug\n       )\n{\n RECV              *R;\n struct hostent    *hostentp;\n char              *bufptr;   /* pointer into buffer strings         */\n char              *cp;\n char              *hp;\n char             **halias;\n struct tm         *tmp;\n int                retcode;  /* return code                         */\n int                len;      /* length of the buffer we're sent     */\n int                addrlen;  /* length of client address socket     */\n int                hostlen;\n int                domslen;\n int                buflen;\n time_t             timeval;\n struct sockaddr_in clientaddress; /* address of client              */\n RECV               r;\n char               outbuf\u00ddRBUFSIZE\u00a8;  /* hold an output string */\n char               echobuf\u00ddRBUFSIZE\u00a8;\n char               timestamp\u00dd20\u00a8;\n\n /* Initialize recv struct with values passed from main task. */\n\n R = &r;\n memcpy(R, recvtp, sizeof(RECV));\n\n#ifdef SNSTCPIP\n\n if (is_debug) {\n   fprintf(stdout,\"openold (token=%X)...\\n\",token);\n   fflush(stdout);\n }\n s0skcfg.exitfunc = NULL; /* Set exit address to NULL */\n R->sockfd = openold(token);\n if (is_debug) {\n   fprintf(stdout,\"sockfd from openold is %d\\n\", R->sockfd);\n   fflush(stdout);\n }\n if(R->sockfd < 0) {\n   REPORT_TCP_ERROR(\"OPENOLD\");\n   fflush(stderr);\n   return;\n }\n\n#else\n\n if (is_debug) {\n   fprintf(stdout,\"takesocket (newsockfd=%d)...\\n\",newsockfd);\n   fprintf(stdout,\"name is %8.8s, subtaskname is %8.8s\\n\",\n                  clid.name,clid.subtaskname);\n   fflush(stdout);\n }\n\n R->sockfd = takesocket(&clid,newsockfd);\n if (is_debug) {\n   fprintf(stdout,\"sockfd from takesocket is %d\\n\", R->sockfd);\n   fflush(stdout);\n }\n if(R->sockfd < 0) {\n   REPORT_TCP_ERROR(\"TAKESOCKET\");\n   return;\n }\n\n#endif\n\n time(&timeval);\n tmp = localtime(&timeval);\n sprintf(timestamp,\"%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d\",\n         tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_year,\n         tmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n\n if (is_debug) {\n   fprintf(stdout,\"getpeername...\\n\");\n   fflush(stdout);\n }\n\n addrlen = sizeof(clientaddress);\n if(Getpeername(R->sockfd,&clientaddress,&addrlen)!=0) {\n   REPORT_TCP_ERROR(\"GETPEERNAME\");\n   printf(\"could not determine client address for socket %d\\n\",\n          R->sockfd);\n }\n\n /* Try to get the name of the client host.\n  * First initialize the hostname to a printable representation of\n  * the IP address in case we can't get a hostname.\n  * We use curlies instead of the traditional squares because of\n  * the ancient 3270's that will be displaying this stuff.\n  */\n\n strcpy(R->hostname,\"{\");\n SPRINTF_IP_ADDRESS(R->hostname+1, clientaddress.sin_addr);\n strcat(R->hostname,\"}\");\n\n if (is_debug) {\n   fprintf(stdout,\"gethostbyaddr...\\n\");\n   fflush(stdout);\n }\n\n hostentp = Gethostbyaddr(&clientaddress.sin_addr,\n                          sizeof(clientaddress.sin_addr),\n                          AF_INET);\n\n if (hostentp && hostentp->h_name) {\n   memcpy(&R->clienthostent, hostentp, sizeof(struct hostent));\n   strcpy(R->hostname,hostentp->h_name);\n   uppercase_in_place(R->hostname);\n }\n\n strcpy(R->hosttest,R->hostname);\n\n hostlen = strlen(R->hosttest);\n domslen = strlen(R->mydomain);\n if (hostlen > domslen) {\n   hp = R->hosttest + hostlen - domslen;\n   if (!memcmp(hp, R->mydomain, domslen)) *hp = '\\0';\n }\n\n printf(\"%s Connection from %s (%s, aka %s).  Socket %d\\n\",\n        timestamp,\n        inet_ntoa(clientaddress.sin_addr), R->hostname, R->hosttest,\n        R->sockfd);\n\n R->buffer\u00dd0\u00a8 = '\\0';\n bufptr = R->buffer;\n\n/***********************/\n/*  NOTE:  sometimes, if timing is right, RECV can return a 0 length */\n/* record when a connection is closed by the client!!  below is a   */\n/* hack to check for a 0 length record, and then terminate this     */\n/* connection if we got one.                                        */\n/***********************/\n\n#define RECV_SIZE       (sizeof(R->buffer)-1)\n\n for (;;) {\n   if (is_debug) {\n     fprintf(stdout,\"recv (sock=%d,size=%d)...\\n\",R->sockfd,RECV_SIZE);\n     fflush(stdout);\n   }\n   if ((len=recv(R->sockfd,outbuf,RECV_SIZE,0)) <= 0) {\n     REPORT_TCP_ERROR(\"RECV - \");\n     printf(\"%s tcp error! len=%d\\n\",R->hostname, len);\n     break;\n   }\n   *(outbuf+(len))=0;    /*make sure it's null terminated...*/\n   ASCII_TO_EBCDIC(outbuf,len);\n   if (is_debug) {\n     int i;\n     fprintf(stdout,\"recv length = %d\\n\",len);\n     for (i=0;i<len;i++) {\n       if (isprint(outbuf\u00ddi\u00a8)) fprintf(stdout,\"%c\",outbuf\u00ddi\u00a8);\n       else                    fprintf(stdout,\"<0x%2.2x>\",outbuf\u00ddi\u00a8);\n     }\n     fprintf(stdout,\"\\n\");\n     fflush(stdout);\n   }\n   if (strlen(R->buffer) + strlen(outbuf) >= sizeof(R->buffer)) {\n     fprintf(stderr, \"\\nError: More than %d bytes seen without CRLF\\n\",\n             RECV_SIZE);\n     len = 0;\n     break;\n   }\n   strcat(R->buffer,outbuf);\n   bufptr=R->buffer+(strlen(R->buffer)-2);\n   if (*bufptr == CARRIAGE_RETURN && *(bufptr+1) == LINE_FEED) break;\n   /* hack for broken Mac Mosaic client */\n   if (*bufptr == LINE_FEED && *(bufptr+1) == CARRIAGE_RETURN) break;\n }\n\n if (len < 0) {\n   fprintf(stderr,\"%s %s Error reading %s\\n\",timestamp,R->hostname);\n }\n else if (len == 0) {\n   fprintf(stderr,\"%s %s Null input from %s\\n\",timestamp,R->hostname);\n }\n else {\n   strcpy(echobuf,R->buffer);\n   buflen = strlen(echobuf);\n   if (buflen == 0) *echobuf = '\\n';\n   else if (buflen == 1) {\n     cp = echobuf;\n     if (*cp == CARRIAGE_RETURN || *cp == LINE_FEED) *cp = '\\n';\n   }\n   else {\n     cp = echobuf + buflen - 2;\n     if (*cp == CARRIAGE_RETURN && *(cp+1) == LINE_FEED) {\n       *cp = '\\n';\n       *(cp+1) = '\\0';\n     }\n     else {\n       cp++;\n       if (*cp == CARRIAGE_RETURN || *cp == LINE_FEED) *cp = '\\n';\n     }\n   }\n   fprintf(stderr,\"%s %s Client data:%s\",\n                  timestamp,R->hostname,echobuf);\n   (void)GGproc(R,FALSE);\n }\n\n fflush(stdout);\n fflush(stderr);\n\n#ifdef DEBUGMTF\n lookatsocket(R->sockfd);\n#endif\n\n if (is_debug) {\n   fprintf(stdout,\"close (%d)...\\n\",R->sockfd);\n   fflush(stdout);\n }\n\n if(close(R->sockfd)<0) REPORT_TCP_ERROR(\"CLOSE - \");\n\n}\n./ ADD NAME=GGTEMP\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@TEMP\")\n#pragma  csect(static,\"GG$TEMP\")\n\n#include \"gg.h\"\n\n/*===================================================================*/\n\nvoid\nshow_amrc(FILE *fp)\n{\n __amrc_type A;\n\n A = *__amrc;\n\n#define Z fprintf(stderr\n\n Z,\"GGtemp: errno = %d, fp = %8.8x\\n\", errno, fp);\n Z,\"GGtemp: __amrc follows\\n\");\n Z,\"        __error.........%d\\n\", A.__code.__error);\n Z,\"        __syscode.......%d\\n\", A.__code.__abend.__syscode);\n Z,\"        __rc............%d\\n\", A.__code.__abend.__rc);\n Z,\"        __fdbk_fill.....%d\\n\", A.__code.__feedback.__fdbk_fill);\n Z,\"        __rc............%d\\n\", A.__code.__feedback.__rc);\n Z,\"        __ftncd.........%d\\n\", A.__code.__feedback.__ftncd);\n Z,\"        __fdbk..........%d\\n\", A.__code.__feedback.__fdbk);\n Z,\"        __svc99_info....%d\\n\", A.__code.__alloc.__svc99_info);\n Z,\"        __svc99_error...%d\\n\", A.__code.__alloc.__svc99_error);\n Z,\"        __RBA...........%d\\n\", A.__RBA);\n Z,\"        __last_op.......%d\\n\", A.__last_op);\n Z,\"        __len_fill......%d\\n\", A.__msg.__len_fill);\n Z,\"        __len...........%d\\n\", A.__msg.__len);\n Z,\"        __str...........%s\\n\", A.__msg.__str+5);\n Z,\"        __parmr0........%d\\n\", A.__msg.__parmr0);\n Z,\"        __parmr1........%d\\n\", A.__msg.__parmr1);\n Z,\"        __fill2.0.......%d\\n\", A.__msg.__fill2\u00dd0\u00a8);\n Z,\"        __fill2.1.......%d\\n\", A.__msg.__fill2\u00dd1\u00a8);\n Z,\"        __str2..........%s\\n\", A.__msg.__str2+5);\n\n return;\n}\n/*===================================================================*/\n\nFILE *\nGGtemp(RECV     *R,\n       TEMPFILE *T,\n       TMPFUN    tempfunction\n      )\n{\n Bool            ok = FALSE;\n\n switch (tempfunction) {\n   case TEMP_CREATE:\n        T->fp = NULL;\n        strcpy(T->ddname,\"dd:\");\n        if (!tmpnam(T->dsname)) {\n          fprintf(stderr, \"GGtemp: Can't create temporary file\\n\");\n        }\n        else if (GGalloc(T->dsname,T->ddname+3,SEQ,500) != SEQ) {\n          fprintf(stderr, \"GGtemp: Can't allocate temporary file\\n\");\n        }\n        else ok = TRUE;\n        break;\n   case TEMP_OPEN:\n        if (T->crmode == RBIN) T->fp = OPEN_FTP_BINARY_FILE(T->ddname);\n        else                   T->fp = OPEN_FTP_TEMP_FILE(T->ddname);\n        if (!T->fp) {\n          perror(T->dsname);\n          fprintf(stderr, \"GGtemp: Can't open temporary file\\n\");\n        }\n        else ok = TRUE;\n        break;\n   case TEMP_CLOSE:\n        if (!T->fp) {\n          fprintf(stderr, \"GGtemp: Temporary file is not open\\n\");\n        }\n        else if (fclose(T->fp) != 0) {\n          perror(T->dsname);\n          fprintf(stderr, \"GGtemp: Can't close temporary file\\n\");\n        }\n        else ok = TRUE;\n        break;\n   case TEMP_REMOVE:\n        T->fp = NULL;\n        GGunalc(T->ddname+3);\n        if (remove(T->dsname) != 0) {\n          fprintf(stderr, \"GGtemp: Can't remove temporary file\\n\");\n        }\n        else ok = TRUE;\n        break;\n\n }\n if (!ok) {\n   GGbarf(R, \"Sorry, the GOPHER server couldn't service the request\");\n }\n return T->fp;\n\n}\n\n./ ADD NAME=GGTNET\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@TNET \")\n#pragma  csect(static,\"GG$TNET \")\n#include \"gg.h\"\n\n/* Additional code by Denis De La Roca <denis@mvs.oac.ucla.edu> */\n\n/****** Gopher TELNET interface. *************************************/\n\nBool\nGGtnet(gp,ip,how)\nRGGCB *gp;\nRINFO *ip;\nGOHOW  how;\n{\n int   tsorc;\n int   cnt          = 0;\n char *userid       = NULL;\n char *password     = NULL;\n char  tpath  \u00dd128\u00a8;\n char  tsocmd \u00dd256\u00a8;\n char  tstuff \u00dd256\u00a8;\n\n switch (how) {\n   case AS_NORMAL: break;\n   default:\n            ERR1(\"TELNET interface cannot be viewed as a file.\");\n            return FALSE;\n }\n\n ISPF(\"CONTROL DISPLAY LINE\");\n\n /* Parse userid/password for Xtelnet's autologin */\n\n#ifdef XTELNET_AUTOLOGIN\n\n if (EQUAL(gp->mytelnet, \"XTELNET\") && *ip->path) {\n\n   strcpy(tpath, ip->path);\n   userid = tpath;\n   password = strchr(tpath, ',');\n   if (password) {\n     *password = '\\0';\n     password = strchr(password + 1, ':');\n     if (password) {\n       if (!memcmp(password - 7, \"assword\", 7)) password += 2;\n       else                                     password = NULL;\n     }\n   }\n   cnt += sprintf(tsocmd+cnt, \"%s -l %s\", gp->mytelnet, userid);\n   if (password)\n      cnt += sprintf(tsocmd+cnt, \"/%s\", password);\n   cnt += sprintf(tsocmd+cnt, \" %s\", ip->host);\n   if (ip->port > 0)\n      cnt += sprintf(tsocmd+cnt, \" %d\", ip->port);\n }\n\n else { /* IBM's Telnet does not support autologin */\n\n#endif\n\n   /* Print note only if we have non-null path */\n\n   if (*ip->path) {\n     fprintf(stderr,\"Note: Login as user: %s\\n\\n\", ip->path);\n   }\n\n   if (ip->port==0) sprintf(tsocmd,\"%s %s\",gp->mytelnet,ip->host);\n   else sprintf(tsocmd,\"%s %s %d\",gp->mytelnet,ip->host,ip->port);\n\n#ifdef XTELNET_AUTOLOGIN\n\n }\n\n#endif\n\n if ((tsorc = GGtso(tsocmd)) != 0) {\n   ERR3(\"Command \\\"%s\\\" returned code %d\", tsocmd, tsorc);\n }\n\n ISPF(\"CONTROL DISPLAY REFRESH\");\n\n return TRUE;\n}\n\n./ ADD NAME=GGTSO\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n /********************************************************************/\n /*                                                                  */\n /* Thanks to Michael Van Norman for this code.                      */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@TSO  \")\n#pragma  csect(static,\"GG$TSO  \")\n#include \"gg.h\"\n\n#pragma linkage(ikjeftsr,OS)\n\n#define _IKJEFTSR_FLAGS_AUTH        0x00000000\n#define _IKJEFTSR_FLAGS_COMMAND     0x00000001\n#define _IKJEFTSR_FLAGS_DUMP        0x00000100\n#define _IKJEFTSR_FLAGS_NODUMP      0x00000000\n#define _IKJEFTSR_FLAGS_PROGRAM     0x00000002\n#define _IKJEFTSR_FLAGS_UNAUTH      0x00010000\n\n/****** Issue TSO command. *******************************************/\n\nint\nGGtso(command)\nchar        *command;\n{\n int         flags         = _IKJEFTSR_FLAGS_COMMAND +\n                             _IKJEFTSR_FLAGS_UNAUTH;\n int         commandLength = strlen(command);\n int         rc            = 0;\n int         returnCode    = 0;\n int         reasonCode    = 0;\n int         abendCode     = 0;\n\n static int (*ikjeftsr)() = NULL;\n\n if (!ikjeftsr) {\n   int tsoEntryAddress;\n\n   tsoEntryAddress = 0x00000010;    /* Address of CVT */\n   tsoEntryAddress = *(int *)(tsoEntryAddress);\n   tsoEntryAddress += 0x9C;/*       /* Offset of TVT in CVT */\n   tsoEntryAddress = *(int *)(tsoEntryAddress);\n   tsoEntryAddress += 0x10;/*       /* TSVTASF-TSVT (from IKJTSVT) */\n   tsoEntryAddress = *(int *)(tsoEntryAddress);\n#ifndef SASC\n   ikjeftsr = (int (*)())(tsoEntryAddress);\n#else\n   ikjeftsr = (__ibmos int (*)())(tsoEntryAddress);\n#endif\n }\n\n if (!ikjeftsr) {\n   fprintf(stderr,\n           \"Cannot execute TSO commands, can't fetch IKJEFTSR.\\n\");\n   return -2;\n }\n\n rc = (*ikjeftsr)(&flags, command, &commandLength,\n                          &returnCode, &reasonCode,\n                          (int *)((int)(&abendCode) | 0x80000000));\n\n if (rc != 0) {\n   if (rc > 4) {\n     fprintf(stderr,\"Command failed:%s\\n\",command);\n     if (rc == 20 && reasonCode == 40)\n          fprintf(stderr,\"Command was not found.\\n\");\n     else fprintf(stderr,\n             \"rc=%d,returncode=%d,reasoncode=%d,abendcode=%8.8x\\n\",\n             rc, returnCode, reasonCode, abendCode);\n   }\n   if (abendCode != 0) rc = -1;\n   else rc = returnCode;\n }\n\n return rc;\n}\n\n./ ADD NAME=GGTYPE\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@TYPE \")\n#pragma  csect(static,\"GG$TYPE \")\n#include \"gg.h\"\n\n/*********************************************************************/\n\nchar *\nGGtype(GOPHERTYPE t)\n{\n\n switch (t) {\n   case GOPHER_FILE:        return \"File     \";\n   case GOPHER_DIRECTORY:   return \"Directory\";\n   case GOPHER_CSO:         return \"Cso      \";\n   case GOPHER_ERROR:       return \"Error    \";\n   case GOPHER_MAC_BINHEX:  return \"Binhex   \";\n   case GOPHER_DOS_BINARCH: return \"Binarch  \";\n   case GOPHER_UUENCODE:    return \"Uuencode \";\n   case GOPHER_WAIS:        return \"Index    \";\n   case GOPHER_TELNET:      return \"Telnet   \";\n   case GOPHER_TN3270:      return \"TN3270   \";\n   case GOPHER_BINARY:      return \"Binary   \";\n   case GOPHER_IMAGE:       return \"Image    \";\n   case GOPHER_BOOKMANAGER: return \"BookMgr  \";\n   case GOPHER_COMMENT:     return \"         \";\n   case GOPHER_REDUNDANT:   return \"Redundant\";\n   case GOPHER_WHOIS:       return \"Whois    \";\n   default:                 return \"Unknown  \";\n }\n}\n\n./ ADD NAME=GGUNALC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@UNALC\")\n#pragma  csect(static,\"GG$UNALC\")\n#include \"gg.h\"\n#include \"ggsvc99.h\"\n\n/****** Unallocate a data set. ***************************************/\n\nBool\nGGunalc(ddname)\nchar   *ddname;\n{\n __S99parms   stuff99;   /* The manual has it wrong.  No \"struct\". */\n int          rc;\n TEXTUNIT    *tu \u00dd2\u00a8;\n TEXTUNIT     tu_ddn;\n TEXTUNIT     tu_una;\n\n if (!ddname || !*ddname) return TRUE;   /* if no ddname to free */\n\n CLEAR(&stuff99);\n\n stuff99.__S99RBLN   = 20;\n stuff99.__S99VERB   = S99VRBUN;\n stuff99.__S99FLAG1  = 0;\n stuff99.__S99ERROR  = 0;\n stuff99.__S99INFO   = 0;\n stuff99.__S99TXTPP  = tu;\n stuff99.__S99FLAG2  = 0;\n\n tu\u00dd0\u00a8 = &tu_ddn;\n tu\u00dd1\u00a8 = &tu_una;\n *(int *)&tu\u00dd1\u00a8 |= 0x80000000;\n\n tu_ddn.key     = DUNDDNAM;\n tu_ddn.num     = 1;\n tu_ddn.ent.len = strlen(ddname);\n copy_uppercase(tu_ddn.ent.prm,ddname);\n\n tu_una.key     = DUNUNALC;\n tu_una.num     = 0;\n\n rc = svc99(&stuff99);\n\n if (rc == 0) return TRUE;\n else if (stuff99.__S99ERROR == 0x0438) /* not freed, is not allocated*/\n         return TRUE;\n else {\n   GGdfail(rc,&stuff99);\n   return FALSE;\n }\n}\n\n./ ADD NAME=GGVIEW\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@VIEW \")\n#pragma  csect(static,\"GG$VIEW \")\n#include \"gg.h\"\n\nstruct cmddesc {\n                char    command_name\u00ddCOMMANDSIZE\u00a8;\n                Bool    (*command_processor)();\n               };\n\nstruct browser {\n          GOPHERINFO    *ip;\n          TEXTHDR       *thp;            /* text header pointer      */\n          TEXTLINE     **tv;             /* text vector              */\n               char     *bda;            /* dynamic area address     */\n               char     *work;           /* find work area address   */\n               char     *firstpos;       /* beginning of actual data */\n               char     *lastpos;        /* end of actual data       */\n               int       depth;          /* dynamic area depth       */\n               int       lvl;            /* last visible line        */\n               int       size;           /* dynamic area size        */\n               int       more_rows;      /* Scroll request row count */\n               int       rowfactor;      /* # physical rows per line */\n               int       screenbump;     /* # physical rows * width  */\n               int       top;            /* top row number           */\n               int       total;          /* total number of rows     */\n               int       coloff;         /* offset from LEFT/RIGHT   */\n               int       cols;           /* 1 if COLS done, else 0   */\n               int       maxlen;         /* maximum text length      */\n               int       maxcoloff;      /* maximum right scroll     */\n               int       find_count;     /* used by FIND ALL         */\n               int       find_row;       /* row where last found     */\n               int       find_col;       /* col where last found     */\n               int       found_row;      /* row where last found     */\n               int       found_col;      /* col where last found     */\n               int       csrpos;         /* cursor position          */\n               int       find_csrpos;    /* col where last found     */\n               int       found_left;     /* pos left of found string */\n               int       found_right;    /* pos right of found string*/\n               Bool      override_scroll;/* set by some commands     */\n               Bool      highlighted;    /* set if FIND highlights   */\n               Bool      reinit_browse;  /* set if text changed      */\n               Bool      exit_browse;    /* set if browse must exit  */\n               Bool      find_hit_end;   /* top/bottom of data reach */\n               char      cursor     \u00dd9\u00a8; /* cursor field name        */\n               char      find_cursor\u00dd9\u00a8; /* row where last found     */\n               char      title     \u00dd81\u00a8; /* title                    */\n               char      cols_line \u00dd81\u00a8; /* cols line                */\n               char      zcmd      \u00dd81\u00a8; /* command input            */\n              };\n\n/******* EXTRACT command **********************************************/\n\nstatic Bool\nprocess_extract_command(gp,bp,operands)\nRGGCB               *gp;\nstruct browser      *bp;\nchar                *operands;\n{\n RINFO              *ip = bp->ip;\n\n gp->extract_file = NULL;\n\n ISPF(\"CONTROL DISPLAY SAVE\");\n (void)GGxtx(gp,ip,EXTRACT_IT);                   /* Extract text */\n ISPF(\"CONTROL DISPLAY RESTORE\");\n\n return TRUE;\n}\n\n/******* PRINT command ************************************************/\n\nstatic Bool\nprocess_print_command(gp,bp,operands)\nRGGCB               *gp;\nstruct browser      *bp;\nchar                *operands;\n{\n RINFO              *ip = bp->ip;\n\n gp->extract_file = NULL;\n\n ISPF(\"CONTROL DISPLAY SAVE\");\n (void)GGxtx(gp,ip,PRINT_IT);                   /* Print text */\n ISPF(\"CONTROL DISPLAY RESTORE\");\n\n return TRUE;\n}\n\n/******* INFO command. ************************************************/\n\nstatic Bool\nprocess_info_command(gp,bp,operands)\nRGGCB               *gp;\nstruct browser      *bp;\nchar                *operands;\n{\n RINFO              *ip = bp->ip;\n\n if (!GGinfo(gp,ip)) return FALSE;\n\n ISPF(\"CONTROL DISPLAY SAVE\");\n (void)GGvtx(gp,NULL,TRUE);              /* View text */\n ISPF(\"CONTROL DISPLAY RESTORE\");\n\n return TRUE;\n}\n\n/******* BOOKMARK command. ********************************************/\n\nstatic Bool\nprocess_bookmark_command(gp,bp,operands)\nRGGCB               *gp;\nstruct browser      *bp;\nchar                *operands;\n{\n RINFO              *ip = bp->ip;\n\n if (!GGinfo(gp,ip)) return FALSE;\n\n gp->extract_file = NULL;\n\n ISPF(\"CONTROL DISPLAY SAVE\");\n (void)GGxtx(gp,ip,BOOKMARK_IT);       /* save as bookmark */\n ISPF(\"CONTROL DISPLAY RESTORE\");\n\n return TRUE;\n}\n\n/******* OPTIONS command **********************************************/\n\nstatic Bool\nprocess_options_command(gp,bp,operands)\nRGGCB               *gp;\nstruct browser      *bp;\nchar                *operands;\n{\n\n GGdsopt(gp,operands);\n\n return TRUE;\n}\n\n/******* QUIT command *************************************************/\n\nstatic Bool\nprocess_quit_command(gp,bp,operands)\nRGGCB               *gp;\nstruct browser      *bp;\nchar                *operands;\n{\n\n gp->quit = TRUE;\n\n return TRUE;\n}\n\n/******* COLS command *************************************************/\n\nstatic Bool\nprocess_cols_command(gp,bp,operands)\nRGGCB               *gp;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n bp->cols = 1;\n *bp->cols_line = '\\0';\n bp->reinit_browse = TRUE;\n return TRUE;\n}\n\n/******* RESET command ************************************************/\n\nstatic Bool\nprocess_reset_command(gp,bp,operands)\nRGGCB               *gp;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n bp->cols = 0;\n *bp->cols_line = '\\0';\n bp->reinit_browse = TRUE;\n return TRUE;\n}\n\n/******* DISPLAY command **********************************************/\n\nstatic Bool\nprocess_display_command(gp,bp,operands)\nRGGCB               *gp;\nRstruc browser      *bp;\nchar                *operands;\n{\n unsigned int        u;\n\n switch (strlen(operands)) {\n   case 1: gp->text_dispchar = operands\u00dd0\u00a8;\n           break;\n   case 2: if (1 != sscanf(operands,\"%x\",&u)) {\n             ERR1(\"Invalid hex character representation.\");\n             return FALSE;\n           }\n           gp->text_dispchar = u;\n           break;\n   default:\n           ERR1(\"A single character must be specified.\");\n           return FALSE;\n }\n bp->reinit_browse = TRUE;\n return TRUE;\n}\n\n/******* LOCATE command ***********************************************/\n\nstatic Bool\nprocess_locate_command(gp,bp,operands)\nRGGCB               *gp;\nRstruc browser      *bp;\nchar                *operands;\n{\n int                 locnum;\n char                junk\u00dd72\u00a8;\n\n if (1 != sscanf(operands, \"%d %s\", &locnum, junk)) {\n   ERR1(\"The LOCATE command requires a line number.\");\n   return FALSE;\n }\n\n bp->top = locnum;\n bp->more_rows = 0;\n bp->override_scroll = TRUE;\n bp->reinit_browse = TRUE;\n return TRUE;\n}\n\n/***** Helper functions for FIND **************************************/\n\n/*--------------------------------------------------------------------*\n * Get quoted FIND string.                                            *\n *--------------------------------------------------------------------*/\n\nstatic char *\nget_quoted_find_string(gp,cp,qform)\nRGGCB               *gp;\nregister char       *cp;\nchar                *qform;\n{\n char                quote     = *cp;\n char                termchar  = '\\0';\n\n for (cp++;;cp++) {\n   if (*cp == quote) {\n     switch (*(cp+1)) {\n       case '\\0':\n       case ' ':  termchar = '\\0'; break;\n       case 'c':\n       case 'C':  termchar = 'C' ; break;\n       case 't':\n       case 'T':  termchar = 'T' ; break;\n       case 'x':\n       case 'X':  termchar = 'X' ; break;\n       case 'p':\n       case 'P':  termchar = 'P' ; break;\n       default:   continue;\n     }\n     if (termchar) {\n       switch (*(cp+2)) {\n         case '\\0':\n         case ' ':  break;\n         default:   continue;\n       }\n       if (*qform != FIND_QUOTED) {\n         ERR1(\n      \"Invalid string; Do not surround a quoted string with letters.\");\n         *qform = FIND_BADFORM;\n         return NULL;\n       }\n       else {\n         switch (termchar) {\n           case 'C': *qform = FIND_C; break;\n           case 'T': *qform = FIND_T; break;\n           case 'X': *qform = FIND_X; break;\n           case 'P': *qform = FIND_P; break;\n         }\n         *cp = '\\0'; /* kill the quote because it's the character */\n         cp++;       /* that the caller will kill, not the quote */\n       }\n     }\n     break;\n   }\n   else if (!*cp) {\n     ERR1(\n     \"Missing quote; The FIND command requires balanced quote marks.\");\n     *qform = FIND_BADFORM;\n     return NULL;\n   }\n }\n return cp;\n}\n\n/*--------------------------------------------------------------------*\n * Get FIND operand.                                                  *\n *--------------------------------------------------------------------*/\n\nstatic char *\nget_find_operand(gp,opp,qform)\nRGGCB           *gp;\nchar           **opp;\nchar            *qform;\n{\n register char  *cp    = skip_ISPF_whitespace(*opp);\n char           *start = NULL;\n\n if (!*cp) return NULL;\n if (*cp == '\\'' || *cp == '\"') {\n   start = cp+1;\n   *qform = FIND_QUOTED;\n   if (!(cp = get_quoted_find_string(gp,cp,qform))) return NULL;\n }\n else if ((*(cp+1) == '\\'' || *(cp+1) == '\"')) {\n   switch (*cp) {\n     case 'c':\n     case 'C': *qform = FIND_C; break;\n     case 't':\n     case 'T': *qform = FIND_T; break;\n     case 'x':\n     case 'X': *qform = FIND_X; break;\n     case 'p':\n     case 'P': *qform = FIND_P; break;\n     default:  *qform = FIND_UNQUOTED; break;\n   }\n   if (*qform != FIND_UNQUOTED) {\n     cp++;\n     start = cp+1;\n     if (!(cp = get_quoted_find_string(gp,cp,qform))) return NULL;\n   }\n   else {\n     start = cp;\n     find_ISPF_whitespace(cp,start);\n   }\n }\n else {\n   start = cp;\n   *qform = FIND_UNQUOTED;\n   find_ISPF_whitespace(cp,start);\n }\n if (*cp) {\n   *cp  = '\\0';\n   *opp = cp+1;\n }\n else *opp = cp;\n return start;\n}\n\n/*--------------------------------------------------------------------*\n * Find it.                                                           *\n *--------------------------------------------------------------------*/\n\n#define REND                 (r+(*tpp)->tab_expanded_text_length)\n#define PRECEDED_BY_VERBIAGE (q>r && isalnum(*(q-1)))\n#define FOLLOWED_BY_VERBIAGE (q+findlen<REND && isalnum(*(q+findlen)))\n\nstatic Bool\nfind_it(gp,bp,find_string,findlen,\n                          find_type,find_what,find_trans,\n                          find_left_bound,find_right_bound)\nRGGCB             *gp;\nRstruc browser    *bp;\nchar              *find_string;\nint                findlen;\nchar               find_type;      /* chars word prefix suffix */\nchar               find_what;      /* next prev first last all */\nchar               find_trans;     /* caps asis generic        */\nint                find_left_bound;\nint                find_right_bound;\n{\n TEXTLINE        **tpp;\n char             *p;\n char             *q;\n char             *r;\n int               row  = bp->find_row;\n int               col  = bp->find_col;\n int               lcol = find_left_bound - 1;\n int               rcol = find_right_bound - 1;\n int               ecol;\n int               complen;\n Bool              backward_find;\n\n switch (find_what) {\n   case FIND_NEXT:\n                    if (bp->find_hit_end) {\n                      bp->find_hit_end = FALSE;\n                      row = 0;\n                      col = lcol;\n                    }\n                    else if (EQUAL(bp->find_cursor,\"GGBDYNA\")) {\n                      row = bp->top+((bp->find_csrpos-1)/80)-bp->cols-1;\n                      col = (bp->find_csrpos-1) % 80 + bp->coloff;\n                      if (++col >= bp->maxlen) {\n                        row++;\n                        col = lcol;\n                      }\n                    }\n                    else {\n                      row = bp->top - 1;\n                      if (row < 0) row = 0;\n                      col = lcol;\n                    }\n                    backward_find = FALSE;\n                    break;\n   case FIND_PREV:\n                    if (bp->find_hit_end) {\n                      bp->find_hit_end = FALSE;\n                      row = bp->total - 1;\n                      col = rcol;\n                    }\n                    else if (EQUAL(bp->find_cursor,\"GGBDYNA\")) {\n                      row = bp->top+((bp->find_csrpos-1)/80)-bp->cols-1;\n                      col = (bp->find_csrpos-1) % 80 + bp->coloff;\n                      if (--col < 0) {\n                        row--;\n                        col = rcol;\n                      }\n                    }\n                    else {\n                      row = bp->total - 1;\n                      col = rcol;\n                    }\n                    backward_find = TRUE;\n                    break;\n   case FIND_FIRST:\n                    bp->find_hit_end = FALSE;\n                    row = 0;\n                    col = lcol;\n                    backward_find = FALSE;\n                    break;\n   case FIND_LAST:\n                    bp->find_hit_end = FALSE;\n                    row = bp->total - 1;\n                    col = rcol;\n                    backward_find = TRUE;\n                    break;\n   case FIND_ALL:\n                    col++;\n                    backward_find = FALSE;\n                    break;\n }\n\n if (!backward_find) { /* forward find */\n   if (col < lcol) col = lcol;\n   else if (col > rcol) {\n     col = lcol;\n     row++;\n   }\n   for (tpp = &bp->tv\u00ddrow\u00a8; row < bp->total; tpp++, col=lcol, row++) {\n     ecol = (*tpp)->tab_expanded_text_length - 1;\n     if (ecol > rcol) ecol = rcol;\n     if (col > ecol) continue;\n     p = (*tpp)->tab_expanded_text;\n     if (find_trans == FIND_CAPS) {\n       copy_uppercase(bp->work,p);\n       r = bp->work;\n     }\n     else r = p;\n     complen = ecol-col+1;\n     for (q = r + col;;q++) {\n       q = memchr(q,find_string\u00dd0\u00a8,complen);\n       if (!q) break;\n       col = q - r;\n       complen = ecol-col+1;\n       if (complen < findlen) break;\n       if (!memcmp(q,find_string,findlen)) {\n         switch (find_type) {\n           case FIND_CHARS:  break;\n           case FIND_WORD:\n                if (PRECEDED_BY_VERBIAGE || FOLLOWED_BY_VERBIAGE)\n                    continue;\n                break;\n           case FIND_PREFIX:\n                if (PRECEDED_BY_VERBIAGE || !FOLLOWED_BY_VERBIAGE)\n                    continue;\n                break;\n           case FIND_SUFFIX:\n                if (!PRECEDED_BY_VERBIAGE || FOLLOWED_BY_VERBIAGE)\n                   continue;\n                break;\n         }\n         bp->find_row = row;\n         bp->find_col = col;\n         return TRUE;\n       }\n     }\n   }\n   bp->find_row = 0;\n   bp->find_col = 0;\n   bp->find_hit_end = TRUE;\n   return FALSE;\n }\n else { /* backward find */\n   if (row >= bp->total) row = bp->total - 1;\n   if (col > rcol-findlen+1) col = rcol-findlen+1;\n   else if (col < lcol) {\n     col = rcol-findlen+1;\n     row--;\n   }\n   for (tpp=&bp->tv\u00ddrow\u00a8; row >= 0; tpp--, col=rcol-findlen+1, row--) {\n     ecol = (*tpp)->tab_expanded_text_length - 1;\n     if (ecol > rcol) ecol = rcol;\n     if (col > ecol) col = ecol;\n     p = (*tpp)->tab_expanded_text;\n     if (find_trans == FIND_CAPS) {\n       copy_uppercase(bp->work,p);\n       r = bp->work;\n     }\n     else r = p;\n     for (q = r + col; q >= r; q--) {\n       if (!memcmp(q,find_string,findlen)) {\n         switch (find_type) {\n           case FIND_CHARS:  break;\n           case FIND_WORD:\n                if (PRECEDED_BY_VERBIAGE || FOLLOWED_BY_VERBIAGE)\n                    continue;\n                break;\n           case FIND_PREFIX:\n                if (PRECEDED_BY_VERBIAGE || !FOLLOWED_BY_VERBIAGE)\n                    continue;\n                break;\n           case FIND_SUFFIX:\n                if (!PRECEDED_BY_VERBIAGE || FOLLOWED_BY_VERBIAGE)\n                   continue;\n                break;\n         }\n         col = q - r;\n         bp->find_row = row;\n         bp->find_col = col;\n         return TRUE;\n       }\n     }\n   }\n   bp->find_row = bp->total - 1;\n   bp->find_col = bp->maxlen;\n   bp->find_hit_end = TRUE;\n   return FALSE;\n }\n}\n\n/********* FIND command ***********************************************/\n\nstatic Bool\nprocess_find_command(gp,bp,operands)\nRGGCB               *gp;\nRstruc browser      *bp;\nchar                *operands;\n{\n char        *find_operand \u00dd64\u00a8;\n char        *show_type;\n char        *cp;\n char        *opcopy;\n char        *op;\n char        *p;\n char        *q;\n int          find_operand_count = 0;\n int          ox;\n int          find_left_bound;\n int          find_right_bound;\n int          n;\n int          len;\n int          findlen;\n Bool         finderror              = FALSE;\n Bool         out_of_bounds          = FALSE;\n Bool         hit_end                = FALSE;\n Bool         find_string_given      = FALSE;\n Bool         find_what_given        = FALSE;\n Bool         find_type_given        = FALSE;\n Bool         find_left_bound_given  = FALSE;\n Bool         find_right_bound_given = FALSE;\n char         find_what;      /* next prev first last all */\n char         find_type;      /* chars word prefix suffix */\n char         find_trans;     /* caps asis generic        */\n char         find_form;      /* unquoted quoted c x t p  */\n char         ff;             /* unquoted quoted c x t p  */\n char         find_qform   \u00dd64\u00a8;\n char         operand_copy \u00dd81\u00a8;\n char         find_string  \u00dd81\u00a8;\n char         temp         \u00dd81\u00a8;\n char         show_string \u00dd129\u00a8;\n char         shortmsg    \u00dd129\u00a8;\n char         longmsg     \u00dd129\u00a8;\n\n strcpy(operand_copy,operands);\n\n for (ox = 0, opcopy = operand_copy; ox < 64; ox++) {\n   ff = FIND_UNQUOTED;\n   op = get_find_operand(gp,&opcopy,&ff);\n   if (ff == FIND_BADFORM) return FALSE;\n   if (!op) break;\n   find_operand\u00ddox\u00a8 = op;\n   find_qform\u00ddox\u00a8 = ff;\n   find_operand_count++;\n }\n\n if (find_operand_count == 0) {\n   if (!*gp->text_find_string) {\n     ERR1(\"The first FIND command requires an operand.\");\n     return FALSE;\n   }\n   strcpy(find_string,gp->text_find_string);\n   find_what        = gp->text_find_what;\n   find_type        = gp->text_find_type;\n   find_trans       = gp->text_find_trans;\n   find_left_bound  = gp->text_find_left_bound;\n   find_right_bound = gp->text_find_right_bound;\n }\n else {\n   find_what        = FIND_NEXT;\n   find_type        = FIND_CHARS;\n   find_trans       = FIND_CAPS;\n   find_left_bound  = 1;\n   find_right_bound = bp->maxlen;\n   for (ox = 0; ox < find_operand_count; ox++) {\n     op = find_operand\u00ddox\u00a8;\n     ff = find_qform\u00ddox\u00a8;\n     if (ff != FIND_UNQUOTED) {\n       if (find_string_given) finderror = TRUE;\n       else {\n         strcpy(find_string,op);\n         find_form = ff;\n         find_string_given = TRUE;\n       }\n     }\n     else {\n       copy_uppercase(temp,op);\n       if (EQUAL(temp,\"*\")) {\n         if (find_string_given) finderror = TRUE;\n         else {\n           strcpy(find_string,gp->text_find_string);\n           find_form = ff;\n           find_string_given = TRUE;\n         }\n       }\n       else if (find_operand_count == 1) {\n         strcpy(find_string,op);\n         find_form = ff;\n         find_string_given = TRUE;\n       }\n       else if (EQUAL(temp,\"NEXT\")) {\n         if (find_what_given) finderror = TRUE;\n         else {\n           find_what = FIND_NEXT;\n           find_what_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"PREV\")) {\n         if (find_what_given) finderror = TRUE;\n         else {\n           find_what = FIND_PREV;\n           find_what_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"FIRST\")) {\n         if (find_what_given) finderror = TRUE;\n         else {\n           find_what = FIND_FIRST;\n           find_what_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"LAST\")) {\n         if (find_what_given) finderror = TRUE;\n         else {\n           find_what = FIND_LAST;\n           find_what_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"ALL\")) {\n         if (find_what_given) finderror = TRUE;\n         else {\n           find_what = FIND_ALL;\n           find_what_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"CHARS\")) {\n         if (find_type_given) finderror = TRUE;\n         else {\n           find_type = FIND_CHARS;\n           find_type_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"WORD\")) {\n         if (find_type_given) finderror = TRUE;\n         else {\n           find_type = FIND_WORD;\n           find_type_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"PREFIX\") || EQUAL(temp,\"PRE\")) {\n         if (find_type_given) finderror = TRUE;\n         else {\n           find_type = FIND_PREFIX;\n           find_type_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"SUFFIX\") || EQUAL(temp,\"SUF\")) {\n         if (find_type_given) finderror = TRUE;\n         else {\n           find_type = FIND_SUFFIX;\n           find_type_given = TRUE;\n         }\n       }\n       else if (*(temp+strspn(temp,\"0123456789\")) == '\\0') {\n         if (find_left_bound_given) {\n           if (find_right_bound_given) finderror = TRUE;\n           else {\n             find_right_bound = atoi(temp);\n             if (find_right_bound > bp->maxlen) out_of_bounds = TRUE;\n             find_right_bound_given = TRUE;\n           }\n         }\n         else {\n           find_left_bound  = atoi(temp);\n             if (find_right_bound < 1) out_of_bounds = TRUE;\n           find_left_bound_given = TRUE;\n         }\n       }\n       else {\n         if (find_string_given) finderror = TRUE;\n         else {\n           strcpy(find_string,op);\n           find_form = ff;\n           find_string_given = TRUE;\n         }\n       }\n     }\n   }\n }\n\n if (out_of_bounds) {\n   ERR2(\"Invalid bound; Bounds must lie between 1 and %d\", bp->maxlen);\n   return FALSE;\n }\n if (finderror) {\n   ERR1(\"Put string in quotes; Conflicting or unknown parameter.\");\n   return FALSE;\n }\n len = strlen(find_string);\n if (find_string_given) bp->find_hit_end = FALSE;\n if (find_left_bound_given && find_right_bound_given\n     && find_left_bound > find_right_bound) {\n   n = find_left_bound;\n   find_left_bound = find_right_bound;\n   find_right_bound = n;\n }\n else if (find_left_bound_given && !find_right_bound_given) {\n   find_right_bound = find_left_bound + len - 1;\n }\n if (find_string_given) {\n   switch (find_form) {\n     case FIND_UNQUOTED:  find_trans = FIND_CAPS;    break;\n     case FIND_QUOTED:    find_trans = FIND_CAPS;    break;\n     case FIND_C:         find_trans = FIND_ASIS;    break;\n     case FIND_T:         find_trans = FIND_CAPS;    break;\n     case FIND_P:         find_trans = FIND_GENERIC; break;\n     case FIND_X:         find_trans = FIND_HEX;\n        if (len % 2 != 0) {\n          ERR1(\"Odd number of characters in hex string.\");\n          return FALSE;\n        }\n        if (len != strspn(find_string,\"0123456789abcdefABCDEF\")) {\n          ERR1(\"Invalid (non-hex) characters in hex string.\");\n          return FALSE;\n        }\n        for (p = find_string, q = find_string; *p; p += 2, *q++) {\n          sprintf(temp,\"0x%2.2s\",p);\n          sscanf(temp,\"%x\",&n);\n          *q = (char)n;\n        }\n        *q = '\\0';\n        len = strlen(find_string);\n        break;\n   }\n }\n\n /* Store parameters for next Repeat Find operation. */\n\n strcpy(gp->text_find_string,find_string);\n switch (find_what) {\n   case FIND_PREV:\n   case FIND_LAST:  gp->text_find_what = FIND_PREV; break;\n   default:         gp->text_find_what = FIND_NEXT; break;\n }\n gp->text_find_type        = find_type;\n gp->text_find_trans       = find_trans;\n gp->text_find_left_bound  = find_left_bound;\n gp->text_find_right_bound = find_right_bound;\n\n if (!*find_string) {\n   ERR1(\"A null string is not allowed for the FIND command.\");\n   return FALSE;\n }\n\n if (bp->total == 0) {\n   ERR1(\"There is no text to search.\");\n   return FALSE;\n }\n\n strcpy(bp->zcmd,\"\");\n\n switch (find_type) {\n   case FIND_CHARS:   show_type = \"Chars\";  break;\n   case FIND_WORD:    show_type = \"Word\";   break;\n   case FIND_PREFIX:  show_type = \"Prefix\"; break;\n   case FIND_SUFFIX:  show_type = \"Suffix\"; break;\n   default:           show_type = \"Text\";   break;\n }\n\n switch (find_trans) {\n   case FIND_ASIS:    strcpy(show_string+0,\"C'\");\n                      strcpy(show_string+2,find_string);\n                      strcat(show_string,\"'\");\n                      break;\n   case FIND_GENERIC: strcpy(show_string+0,\"P'\");\n                      strcpy(show_string+2,find_string);\n                      strcat(show_string,\"'\");\n                      break;\n   case FIND_HEX:     strcpy(show_string+0,\"X'\");\n                      for (p=find_string,q=show_string+2;*p;p++,q+=2) {\n                        sprintf(q,\"%2.2X\",*p);\n                      }\n                      strcat(show_string,\"'\");\n                      break;\n   case FIND_CAPS:\n   default:           strcpy(show_string+0,\"'\");\n                      strcpy(show_string+1,find_string);\n                      strcat(show_string,\"'\");\n                      break;\n }\n\n switch (find_trans) {\n   case FIND_CAPS:\n        uppercase_in_place(find_string);\n        break;\n   case FIND_GENERIC:\n        ERR1(\"The P'string' generic format is not supported.\");\n        return FALSE;\n }\n\n hit_end = bp->find_hit_end;\n findlen = strlen(find_string);\n\n if (find_what == FIND_ALL) {\n   bp->find_count = 0;\n   if (!find_it(gp,bp,find_string,findlen,\n                                  find_type,FIND_FIRST,find_trans,\n                                  find_left_bound, find_right_bound)) {\n     sprintf(shortmsg,\"No %s %s found\",show_type,show_string);\n     sprintf(longmsg,\n             \"%s %s - not found within columns %d to %d\",\n             show_type,show_string,find_left_bound,find_right_bound);\n     ERR3(\"%24s;%s\",shortmsg,longmsg);\n     return FALSE;\n   }\n   bp->found_row = bp->find_row;\n   bp->found_col = bp->find_col;\n   bp->find_count = 1;\n   while (find_it(gp,bp,find_string,findlen,\n                        find_type,FIND_ALL,find_trans,\n                        find_left_bound, find_right_bound)) {\n         bp->find_count++;\n   }\n   bp->find_hit_end = FALSE;\n }\n else {\n   if (!find_it(gp,bp,find_string,findlen,\n                                  find_type,find_what,find_trans,\n                                  find_left_bound, find_right_bound)) {\n     if (hit_end) {\n       sprintf(shortmsg,\"No %s %s found\",show_type,show_string);\n       sprintf(longmsg,\n               \"%s %s - not found within columns %d to %d\",\n               show_type,show_string,find_left_bound,find_right_bound);\n       ERR3(\"%24s;%s\",shortmsg,longmsg);\n       return FALSE;\n     }\n     else if (gp->text_find_what == FIND_PREV) {\n       sprintf(shortmsg,\"Top of data reached\");\n       sprintf(longmsg,\n            \"%s %s not found.  Use RFIND to continue from bottom.\",\n             show_type, show_string);\n       ERR3(\"%24s;%s\",shortmsg,longmsg);\n     }\n     else {\n       sprintf(shortmsg,\"Bottom of data reached\");\n       sprintf(longmsg,\n               \"%s %s not found.  Use RFIND to continue from top.\",\n             show_type, show_string);\n       ERR3(\"%24s;%s\",shortmsg,longmsg);\n     }\n     return FALSE;\n   }\n   bp->found_row = bp->find_row;\n   bp->found_col = bp->find_col;\n }\n if (bp->found_row + 1 < bp->top\n  || bp->found_row + 1 >= bp->top + bp->lvl - bp->cols) {\n   bp->top = bp->found_row + 1 - 1;\n   if (bp->top < 0) bp->top = 0;\n }\n if (bp->found_col < bp->coloff) {\n   bp->coloff = bp->found_col;\n   *bp->cols_line = '\\0';\n }\n else if (bp->found_col+len > bp->coloff+80) {\n   bp->coloff = bp->found_col + len - 80;\n   if (bp->coloff < 0) bp->coloff = 0;\n   *bp->cols_line = '\\0';\n }\n strcpy(bp->cursor, \"GGBDYNA\");\n bp->csrpos = 80 * (bp->found_row - bp->top+bp->cols + 1)\n              + bp->found_col - bp->coloff + 1;\n bp->found_left = bp->csrpos;\n bp->found_right = bp->found_left + len;\n bp->reinit_browse = TRUE;\n\n if (find_what == FIND_ALL) {\n   sprintf(shortmsg,\"%d %s %s\",bp->find_count,show_type,show_string);\n   sprintf(longmsg,\n           \"%s %s found %d times within columns %d to %d\",\n           show_type,show_string,bp->find_count,\n           find_left_bound,find_right_bound);\n   WARN3(\"%24s;%s\",shortmsg,longmsg);\n }\n else {\n   sprintf(shortmsg,\"%s %s found\",show_type,show_string);\n   sprintf(longmsg,\n           \"Search for %s %s within columns %d to %d was successful\",\n           show_type,show_string, find_left_bound,find_right_bound);\n   WARN3(\"%24s;%s\",shortmsg,longmsg);\n }\n bp->find_row = bp->found_row;\n bp->find_col = bp->found_col;\n return TRUE;\n}\n\n/************ Fill browse dynamic area. *******************************/\n\nstatic void\nfill_browse_dynamic_area(gp,bp)\nRGGCB              *gp;\nRstruc browser     *bp;\n{\n struct textline  **tpp  = NULL;\n register char     *cp   = NULL;\n register char     *p;\n char              *q;\n char              *r;\n int                i;\n int                j;\n char               temp\u00dd12\u00a8;\n\n static char  top_of_data_line\u00dd81\u00a8 = \"\\\n********************************* Top of data \\\n**********************************\";\n\n static char  bottom_of_data_line\u00dd81\u00a8 = \"\\\n******************************** Bottom of data \\\n********************************\";\n\n bp->lastpos = bp->bda + bp->size;\n bp->total = bp->thp->text_line_count;\n memset(bp->bda,' ',bp->size);\n\n if      (bp->more_rows == -MAX_INT)\n         bp->top = 0;\n else if (bp->more_rows == MAX_INT)\n         bp->top = bp->total + 2 - bp->lvl + bp->cols;\n else    bp->top += bp->more_rows;\n\n if (bp->top < 0) bp->top = 0;\n if (bp->top > bp->total) bp->top = bp->total + 1;\n i  = bp->top;\n p  = bp->bda;\n\n if (bp->cols > 0) {\n   if (!*bp->cols_line) {\n     for (j=bp->coloff+1,r=bp->cols_line; j<=bp->coloff+80; j++,r++) {\n       if (j%10 == 0) {\n         sprintf(temp,\"%d\",j%100);\n         *r = temp\u00dd0\u00a8;\n       }\n       else if (j%5 == 0) *r = '+';\n       else *r = '-';\n     }\n   }\n   memcpy(p,bp->cols_line,80);\n   p += 80;\n }\n\n if (i == 0) {\n   memcpy(p,top_of_data_line,80);\n   p += 80;\n   i++;\n }\n\n bp->firstpos = p;\n\n for (tpp=&bp->tv\u00ddi-1\u00a8;i<=bp->total && p<bp->lastpos;i++,tpp++,p+=80) {\n   if ((*tpp)->tab_expanded_text_length > bp->coloff) {\n     cp = (*tpp)->tab_expanded_text + bp->coloff;\n     for (j = 0, q = p; *cp && j < 80; j++, q++, cp++) {\n       if (*cp > 0xf9 || *cp < 0x40) *q = gp->text_dispchar;\n       else *q = *cp;\n     }\n   }\n }\n\n if (p < bp->lastpos) memcpy(p,bottom_of_data_line,80);\n\n return;\n}\n\n/************ Highlight browse text. **********************************/\n\nstatic void\nhighlight_browse_text(gp,bp)\nRGGCB              *gp;\nRstruc browser     *bp;\n{\n char              *p;\n\n bp->highlighted = FALSE;\n\n if (bp->found_left) {\n   if (EQUAL(bp->cursor,\"GGBDYNA\")) {\n     for (p = bp->bda + bp->found_left - 1; p >= bp->firstpos; p--) {\n       if (*p == ' ') {\n         *p = DATAOUT_HIGH;\n         bp->highlighted = TRUE;\n         break;\n       }\n     }\n     for (p = bp->bda + bp->found_right - 1; p <= bp->lastpos; p++) {\n      if (*p == ' ') {\n        *p = DATAOUT_LOW;\n         bp->highlighted = TRUE;\n         break;\n       }\n     }\n   }\n }\n\n bp->found_left = 0;\n bp->found_right = 0;\n\n return;\n}\n\n/************ Display browse data. ************************************/\n\nstatic void\ndisplay_browse_data(gp,bp)\nRGGCB              *gp;\nRstruc browser     *bp;\n{\n struct cmddesc    *cdp;\n char              *cp;\n char              *operands;\n int                displayrc;\n int                zscrolln;\n int                leftcol;\n int                rightcol;\n int                command_index;\n Bool               command_processed_ok;\n Bool               is_max;\n Bool               is_scroll_word;\n Bool               is_scroll_cursor;\n SCROLL             scroll_amount;\n char               command    \u00ddCOMMANDSIZE+1\u00a8;\n char               zverb      \u00dd16\u00a8;\n char               zscrolla   \u00dd16\u00a8;\n char               longmsg    \u00dd73\u00a8;\n char               ggbtitle  \u00dd129\u00a8;\n char               ggbmsg     \u00dd81\u00a8;\n char               temp1      \u00dd81\u00a8;\n char               temp2      \u00dd81\u00a8;\n\nstatic struct cmddesc browse_commands\u00dd\u00a8 = {\n                          {\"L          \",process_locate_command   },\n                          {\"LOC        \",process_locate_command   },\n                          {\"LOCATE     \",process_locate_command   },\n                          {\"F          \",process_find_command     },\n                          {\"FIND       \",process_find_command     },\n                          {\"RFIND      \",process_find_command     },\n                          {\"YRFIND     \",process_find_command     },\n                          {\"COL        \",process_cols_command     },\n                          {\"COLS       \",process_cols_command     },\n                          {\"RES        \",process_reset_command    },\n                          {\"RESET      \",process_reset_command    },\n                          {\"NOCOL      \",process_reset_command    },\n                          {\"NOCOLS     \",process_reset_command    },\n                          {\"DISP       \",process_display_command  },\n                          {\"DISPL      \",process_display_command  },\n                          {\"DISPLAY    \",process_display_command  },\n                          {\"EXT        \",process_extract_command  },\n                          {\"EXTR       \",process_extract_command  },\n                          {\"EXTRACT    \",process_extract_command  },\n                          {\"PRT        \",process_print_command    },\n                          {\"PRNT       \",process_print_command    },\n                          {\"PRINT      \",process_print_command    },\n                          {\"INFO       \",process_info_command     },\n                          {\"BOOK       \",process_bookmark_command },\n                          {\"BOOKMARK   \",process_bookmark_command },\n                          {\"OPT        \",process_options_command  },\n                          {\"OPTION     \",process_options_command  },\n                          {\"OPTIONS    \",process_options_command  },\n                          {\"QUIT       \",process_quit_command     },\n                          {\"           \",NULL}\n                         };\n\n bp->more_rows = 0;\n bp->override_scroll = FALSE;\n bp->exit_browse     = FALSE;\n memset (ggbtitle, '-', 80);\n strcpy (ggbtitle, \"Browse - \");\n memcpy (ggbtitle + 9, bp->title, strlen(bp->title));\n *(ggbtitle + 9 + strlen(bp->title)) = ' ';\n\n if (!gp->setmsg) {\n   leftcol = bp->coloff + 1;\n   rightcol = bp->coloff + 80;\n   if (bp->top > bp->total) strcpy(temp1,\"\");\n   else sprintf(temp1, \" Line %d of %d,\", bp->top, bp->total);\n   if (bp->maxlen <= 80)\n        sprintf(temp2,\" Cols %d-%d\",leftcol,rightcol);\n   else sprintf(temp2,\" Cols %d-%d of %d\",leftcol,rightcol,bp->maxlen);\n   strcpy(ggbmsg,temp1);\n   strcat(ggbmsg,temp2);\n   strcpy (ggbtitle + 79 - strlen(ggbmsg), ggbmsg);\n }\n\n VPUT (\"GGBTITLE \",ggbtitle);\n VPUT (\"ZCMD \"    ,bp->zcmd);\n VPUTS(\"GGBDYNA \" ,bp->bda, bp->size);\n VPUT (\"GGBCUR \"  ,bp->cursor);\n IPUT (\"GGBPOS \"  ,bp->csrpos);\n VPUT (\"YRFIND \"  ,\"ALIAS FIND\");\n\n displayrc = GGdispl(gp,\"GGMVIEW \");\n if (displayrc > 0) bp->exit_browse = TRUE;\n\n VPUT (\"YRFIND \"  ,\"\");\n VGET (\"GGBCUR \" ,bp->cursor);\n VGET (\"ZCMD \"   ,bp->zcmd);\n bp->lvl    = IGET(\"GGBLVL \");\n bp->csrpos = IGET(\"GGBPOS \");\n strip_trailing_in_place(bp->cursor);\n strcpy(bp->find_cursor, bp->cursor);\n bp->find_csrpos = bp->csrpos;\n strcpy(bp->cursor,\"\");\n bp->csrpos = 1;\n if (bp->highlighted) bp->reinit_browse = TRUE;\n else                 bp->reinit_browse = FALSE;\n\n if (*bp->zcmd) {\n   memset(command,' ',COMMANDSIZE);\n   command_index = 0;\n   for (cp = bp->zcmd; *cp && !isspace(*cp); cp++) {\n     if (cp >= bp->zcmd+COMMANDSIZE) {\n       ERR1(\n\"Enter EXTract, PRT, BOOKmark, INFO, OPTions, or a browse command.\");\n       command_processed_ok = FALSE;\n     }\n     command\u00ddcommand_index++\u00a8 = toupper(*cp);\n   }\n   while (*cp && isspace(*cp)) cp++;\n   for (cdp=browse_commands; *cdp->command_name != ' '; cdp++) {\n     if (!memcmp(command,cdp->command_name,COMMANDSIZE-1)) {\n       command_processed_ok = (cdp->command_processor)(gp,bp,cp);\n       cdp = NULL;\n       break;\n     }\n   }\n   if (cdp) {\n     ERR1(\n\"Enter EXTract, PRT, BOOKmark, INFO, OPTions, or a browse command.\");\n     command_processed_ok = FALSE;\n   }\n   if (command_processed_ok) strcpy(bp->zcmd,\"\");\n }\n\n if (gp->quit || bp->exit_browse) return;\n\n /* Check scroll request (ZSCROLLA direction, ZSCROLLN number).\n  * Skip this if something was done by a command which causes\n  * its own pseudo-scrolling to happen (like LOCATE).\n  */\n\n if (!bp->override_scroll) {\n\n   VGET(\"ZVERB \"   , zverb);\n   VGET(\"ZSCROLLA \", zscrolla);\n   zscrolln = IGET(\"ZSCROLLN \");\n   is_max = FALSE;\n   is_scroll_word = FALSE;\n   is_scroll_cursor = FALSE;\n\n   switch (zscrolla\u00dd0\u00a8) {\n     case 'P':\n     case 'H':\n     case 'D':  is_scroll_word = TRUE;\n                break;\n     case 'C':  is_scroll_word = TRUE;\n                is_scroll_cursor = TRUE;\n                break;\n     case 'M':  is_max = TRUE;\n                break;\n   }\n\n   if      (EQUAL(zverb,\"DOWN\"))  scroll_amount = DOWN;\n   else if (EQUAL(zverb,\"UP\"))    scroll_amount = UP;\n   else if (EQUAL(zverb,\"LEFT\"))  scroll_amount = LEFT;\n   else if (EQUAL(zverb,\"RIGHT\")) scroll_amount = RIGHT;\n   else                           scroll_amount = NO_SCROLL;\n\n   switch (scroll_amount) {\n     case NO_SCROLL:\n          bp->more_rows = 0;\n          break;\n     case DOWN:\n          if (is_max) bp->more_rows = MAX_INT;\n          else if (is_scroll_word)\n                      bp->more_rows = zscrolln - bp->cols;\n          else        bp->more_rows = zscrolln;\n          bp->reinit_browse = TRUE;\n          break;\n     case UP:\n          if (is_max) bp->more_rows = -MAX_INT;\n          else if (is_scroll_cursor)\n                      bp->more_rows = -zscrolln;\n          else if (is_scroll_word)\n                      bp->more_rows = -zscrolln - bp->cols;\n          else        bp->more_rows = -zscrolln;\n          bp->reinit_browse = TRUE;\n          break;\n     case LEFT:\n          if (is_max) bp->coloff = 0;\n          else        bp->coloff -= zscrolln;\n          if (bp->coloff < 0) bp->coloff = 0;\n          *bp->cols_line = '\\0';\n          bp->more_rows = 0;\n          bp->reinit_browse = TRUE;\n          break;\n     case RIGHT:\n          if (is_max) bp->coloff = bp->maxcoloff;\n          else        bp->coloff += zscrolln;\n          if (bp->coloff > bp->maxcoloff) bp->coloff = bp->maxcoloff;\n          *bp->cols_line = '\\0';\n          bp->more_rows = 0;\n          bp->reinit_browse = TRUE;\n          break;\n   }\n }\n\n return;\n}\n\n/****** View text in full screen mode (BROWSE replacement) ***********/\n\nvoid\nGGview(gp,ip,texthdrp,title)\nRGGCB               *gp;\nRINFO               *ip;\nTEXTHDR             *texthdrp;\nchar                *title;\n{\n TEXTLINE           *tp;\n TEXTLINE          **tv;\n TEXTLINE          **textvector;\n struct browser     *bp;\n struct browser      browserstruct;\n\n GETMAIN(textvector,TEXTLINE *,texthdrp->text_line_count,\"text vector\");\n if (!textvector) {\n   ERR1(\"Not enough memory to display text.\");\n   return;\n }\n\n bp = &browserstruct;\n CLEAR(bp);\n bp->ip  = ip;\n bp->thp = texthdrp;\n bp->tv  = textvector;\n strcpy(bp->title,title);\n bp->more_rows = -MAX_INT;   /* set initial request to scroll up max */\n bp->top       = 0;\n bp->find_row  = -1;\n bp->find_col  = -1;\n bp->csrpos    = 1;\n strcpy(bp->cursor,\"\");\n bp->reinit_browse = TRUE;\n\n /* Collect text line pointers, skipping suppressed lines. */\n\n bp->maxlen = 0;\n for (tp=texthdrp->first_text_line, tv=textvector; tp; tp=tp->next) {\n   if (tp->text_length >= 0) {\n     *(tv++) = tp;\n     if (bp->maxlen < tp->tab_expanded_text_length)\n         bp->maxlen = tp->tab_expanded_text_length;\n   }\n }\n bp->maxcoloff = bp->maxlen - 80;\n if (bp->maxcoloff < 0) bp->maxcoloff = 0;\n\n GETMAIN(bp->work, char, bp->maxlen+1, \"browse work string\");\n if (!bp->work) return;\n\n ISPF(\"PQUERY PANEL(GGMVIEW) AREANAME(GGBDYNA) DEPTH(GGBDEPTH)\");\n if (gp->ispfrc != 0) return;\n bp->depth = IGET(\"GGBDEPTH \");\n bp->size = bp->depth * 80;\n GETMAIN(bp->bda, char, bp->size+1, \"browse dynamic area\");\n if (!bp->bda) return;\n\n if (!gp->text_dispchar) gp->text_dispchar = '.';\n\n do {\n   if (bp->reinit_browse) {\n     fill_browse_dynamic_area(gp,bp);\n     highlight_browse_text(gp,bp);\n   }\n   display_browse_data(gp,bp);\n } while (!gp->quit && !bp->exit_browse);\n\n FREEMAIN(bp->work,\"browse work string\");\n FREEMAIN(bp->bda, \"browse dynamic area\");\n FREEMAIN(textvector, \"text vector\");\n\n return;\n}\n\n./ ADD NAME=GGVTX\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@VTX  \")\n#pragma  csect(static,\"GG$VTX  \")\n#include \"gg.h\"\n\n/****** View the lines of text retrieved from the server. ************/\n\nBool\nGGvtx(gp,ip,how)\nRGGCB     *gp;\nRINFO     *ip;\nGOHOW      how;\n{\n TEXTHDR  *texthdrp;\n char      title \u00dd81\u00a8;\n\n switch (how) {\n   case AS_NOTHING: return;\n   default:         break;\n }\n\n texthdrp = (ip ? &ip->thdr : &gp->thdr);\n\n if (!ip) sprintf(title, \"GopherServer:%s \",gp->ggserver);\n else     strncpy(title, ip->desc, sizeof(title));\n\n GGview(gp,ip,texthdrp,title);\n\n return;\n}\n\n./ ADD NAME=GGWAIS\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@WAIS \")\n#pragma  csect(static,\"GG$WAIS \")\n#include \"gg.h\"\n\n/****** Gopher WAIS interface. *************************************/\n\nBool\nGGwais(gp,ip,how)\nRGGCB   *gp;\nRINFO   *ip;\nGOHOW    how;\n{\n RCONN  *sp = &gp->gopher_connection;\n char   *lp;\n char    ggwaisq \u00dd256\u00a8;\n\n strcpy(gp->ggserver,ip->host);     /* Specify server to connect to */\n strcpy(ggwaisq,\"\");\n ISPF(\"VGET (GGWAISQ) PROFILE\");\n if (GGdispl(gp,\"GGMPWAIS\") > 0) return FALSE;\n VGET(\"GGWAISQ \",ggwaisq);\n\n if (!*ip->path) strcpy(gp->gopher_command, ggwaisq);\n else            sprintf(gp->gopher_command,\"%s\\t%s\",ip->path,ggwaisq);\n\n gp->ginfo = ip;\n\n if (!GGconn(gp,sp)) return FALSE;  /* Connect to gopher server */\n GOPHERSEND(gp,sp);                 /* Send socket command */\n GGclrtx(gp,ip);                    /* Clear text */\n sp->receiving_text = TRUE;\n\n while (GGgsrvl(gp,sp,&lp,CRLF))  {   /* Get server line */\n   if (!lp) break;\n   (void)GGouttx(gp,lp,ip,NO_VALUE);  /* Output text line */\n }\n if (sp->time_to_go_home) {\n   WARN2(\"No data available from server %s.\\n\",gp->ggserver);\n   return FALSE;\n }\n\n if (sp->connected_to_server) {\n   (void)GGdisc(gp,sp);           /* Disconnect from gopher server */\n }\n\n GGdir(gp,ip,how); /* display entries returned from WAIS server */\n\n return TRUE;\n\n}\n\n./ ADD NAME=GGWHOIS\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@WHOIS\")\n#pragma  csect(static,\"GG$WHOIS\")\n#include \"gg.h\"\n\n/****** Gopher WHOIS/FINGER interface. *****************************/\n\nBool\nGGwhois(gp,ip,how)\nRGGCB  *gp;\nRINFO  *ip;\nGOHOW   how;\n{\n RCONN *sp = &gp->gopher_connection;\n char  *lp;\n Bool   got_some;\n char   ggwhoisq \u00dd256\u00a8;\n\n strcpy(gp->ggserver,ip->host);     /* Specify server to connect to */\n strcpy(ggwhoisq,\"\");\n ISPF(\"VGET (GGWHOISQ) PROFILE\");\n if (GGdispl(gp,\"GGMPWHOI\") > 0) return FALSE;\n VGET(\"GGWHOISQ \",ggwhoisq);\n\n if (!*ip->path) strcpy(gp->gopher_command, ggwhoisq);\n else            sprintf(gp->gopher_command,\"%s\\t%s\",ip->path,ggwhoisq);\n\n gp->ginfo = ip;\n\n if (!GGconn(gp,sp)) return FALSE;   /* Connect to gopher server */\n GOPHERSEND(gp,sp);                  /* Send socket command */\n GGclrtx(gp,ip);                     /* Clear text */\n\n sp->receiving_text = TRUE;\n got_some = FALSE;\n while (GGgsrvl(gp,sp,&lp,CRLF)) {   /* Get server line */\n   if (!lp) break;\n   got_some = TRUE;\n   (void)GGouttx(gp,lp,ip,NO_VALUE); /* Output text line */\n }\n\n if (!got_some) {\n   WARN2(\"No data available from server %s.\\n\",gp->ggserver);\n   return FALSE;\n }\n\n if (sp->connected_to_server) {\n   (void)GGdisc(gp,sp);         /* Disconnect from gopher server */\n }\n\n GGvtx(gp,ip,how);      /* display text from WHOIS/FINGER server */\n\n return TRUE;\n\n}\n\n./ ADD NAME=GGWTO\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@WTO\")\n#pragma  csect(static,\"GG$WTO\")\n\n#include \"gg.h\"\n#include \"ggsvc.h\"\n\n#define WTOTEXTLENGTH  251\n#define WTOSVC         35\n\n#define WRITE_TO_PROGRAMMER 1\n\nint\nGGwto(char    *message)\n{\n char         *cp;\n SVC_REGISTER  reg15;\n SVC_REGISTER  reg0;\n SVC_REGISTER  reg1;\n struct        {\n                short   wtolen;\n                short   wtodum;\n                char    wtotext\u00ddWTOTEXTLENGTH+5\u00a8;\n                char    routecodestuff\u00dd9\u00a8;\n               }        wto;\n\n CLEAR(&wto);\n strncpy(wto.wtotext,message,WTOTEXTLENGTH);\n wto.wtolen = strlen(wto.wtotext) + 4;\n wto.wtodum = 0;\n\n#ifdef WRITE_TO_PROGRAMMER\n\n wto.wtodum = 0x8000;\n cp = wto.wtotext + strlen(wto.wtotext);\n cp\u00dd0\u00a8 = 0x00;\n cp\u00dd1\u00a8 = 0x00;\n cp\u00dd2\u00a8 = 0x00;\n cp\u00dd3\u00a8 = 0x20;\n\n#else\n\n wto.wtodum = 0;\n\n#endif\n\n\n reg15 = (SVC_REGISTER) 0;\n reg0  = (SVC_REGISTER) 0;\n reg1  = (SVC_REGISTER) &wto;\n\n SVC(WTOSVC,&reg15,&reg0,&reg1);\n\n return (int)reg15;\n\n}\n\n./ ADD NAME=GGXTX\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /* GOPHER client due to Steve Bacher at Draper Laboratory.          */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@XTX  \")\n#pragma  csect(static,\"GG$XTX  \")\n#include \"gg.h\"\n\n#define XFPUTC(A)     gp->extract_write_error = (fputc((A),xfp) == EOF)\n\n#define XFWRITE(A,B)  fwrite((A),(B),1,xfp), \\\n                      gp->extract_write_error = (ferror(xfp) != 0)\n#define XWRITE(A)     XFWRITE(A,strlen(A))\n\n#define NEWLINE       if (ex != BOOKMANAGE_IT) XFPUTC('\\n')\n\n/****** Extract the lines of server text into a data set. ************/\n\nBool\nGGxtx(gp,ip,ex)\nRGGCB         *gp;\nRINFO         *ip;\nEXTREQ         ex;\n{\n FILE         *xfp;\n TEXTHDR      *thp;\n TEXTLINE     *tp;\n EXTRACTION   *ep;\n char         *cp;\n int           l;\n int           linelen;\n Bool          final;\n EXTRACTION    the_extraction;\n\n thp = (ip && ex != BOOKMARK_IT ? &ip->thdr : &gp->thdr);\n\n /* Set article data for message. */\n\n if (ip) {\n   IPUT(\"GGTNUM \" ,ip->type);\n   VPUT(\"GGTSUBJ \",ip->desc);\n }\n\n if (ex == BOOKMANAGE_IT) {\n   xfp = gp->extract_file;\n   ep = &the_extraction;\n   CLEAR(ep);\n   ep->ex = ex;\n   gp->extract_tab_expanding          = ep->tab_expanding;\n   gp->extract_appending              = ep->appending;\n   gp->extract_blank_before_separator = ep->blanking;\n   gp->extract_separator_line         = ep->separator;\n }\n else if (gp->extract_file) {\n   ISPF(\"CONTROL DISPLAY LOCK\");\n     switch (ex) {\n       case PRINT_IT: ISPF(\"DISPLAY PANEL(GGMLPRN2)\"); break;\n       default:       ISPF(\"DISPLAY PANEL(GGMLEXN2)\"); break;\n     }\n   xfp = gp->extract_file;\n   ep = gp->extractionp;\n }\n else {\n\n   ep = &the_extraction;\n   CLEAR(ep);\n   switch (ex) {\n     case EXTRACT_IT:  ep->mode = SEQ;\n                       strcpy(ep->panelname,\"GGMPEXDS\");\n                       break;\n     case PRINT_IT:    ep->mode = JES;\n                       strcpy(ep->panelname,\"GGMPPRDS\");\n                       break;\n     case BOOKMARK_IT: ep->mode = SEQ;\n                       strcpy(ep->panelname,\"GGMPBMDS\");\n                       break;\n   }\n   ep->ex = ex;\n\n   if (ip) VPUT(\"GGTSUBJ \",ip->desc);\n   else    VPUT(\"GGTSUBJ \",\"\");\n\n   if (!((xfp=GGgetds(gp,ep)))) return FALSE;\n\n   gp->extract_tab_expanding          = ep->tab_expanding;\n   gp->extract_appending              = ep->appending;\n   gp->extract_blank_before_separator = ep->blanking;\n   gp->extract_separator_line         = ep->separator;\n }\n\n gp->extract_write_error = FALSE;\n gp->extract_close_error = FALSE;\n\n /* If a bookmark, then write gopher menu header only if this is\n  * a new data set (not appending).\n  */\n\n if (ep->ex == BOOKMARK_IT && !ep->appending) {\n   XWRITE(MENUIDENT);\n   NEWLINE;\n }\n\n /* If append mode, and a separator line was specified, use it. */\n\n if (gp->extract_appending) {\n   NEWLINE;\n   if (gp->extract_separator_line && *gp->extract_separator_line) {\n     XWRITE(gp->extract_separator_line);\n     NEWLINE;\n     if (gp->extract_blank_before_separator) {NEWLINE;}\n   }\n }\n\n switch (ex) {\n   case EXTRACT_IT:    linelen = 251;  break;\n   case PRINT_IT:      linelen = 120;  break;\n   case BOOKMARK_IT:   linelen = 251;  break;\n   case BOOKMANAGE_IT: linelen = 4096; break;\n }\n\n for (tp = thp->first_text_line;\n      tp && !gp->extract_write_error;\n      tp = tp->next) {\n   if (tp->text_length == 0) {\n     NEWLINE;\n   }\n   else if (tp->text_length > 0) {\n     if (gp->extract_tab_expanding) {\n       cp = tp->tab_expanded_text;\n       l  = tp->tab_expanded_text_length;\n     }\n     else {\n       cp = tp->text;\n       l  = tp->text_length;\n     }\n     for (; l>0 && !gp->extract_write_error; cp+=linelen, l-=linelen) {\n       XFWRITE(cp,(l > linelen ? linelen : l));\n       NEWLINE;\n     }\n   }\n }\n\n if (!gp->extract_write_error && ferror(xfp))\n    gp->extract_write_error = TRUE;\n\n if (ex != BOOKMANAGE_IT) {\n   if (!gp->extract_appending || !gp->extract_file) {\n     switch (ex) {\n       case PRINT_IT:     final = TRUE;  break;\n       default:           final = FALSE; break;\n     }\n     (ep->closer)(gp,ep,xfp,final);   /* Close the file */\n     if (gp->extract_close_error) return FALSE;\n   }\n }\n\n if (!gp->extract_file) {\n   if (gp->extract_write_error) {\n     ERR2(\"An error occurred writing to %s.\", ep->dsname);\n     gp->extract_write_error = TRUE;\n   }\n   else switch (ex) {\n     case EXTRACT_IT:\n          WARN2(\"Current text extracted into %s.\", ep->dsname);\n          break;\n     case PRINT_IT:\n          WARN2(\"Current text printed to %s.\", ep->dsname);\n          break;\n     case BOOKMARK_IT:\n          WARN2(\"Item stored as bookmark in %s.\", ep->dsname);\n          break;\n   }\n }\n if (gp->extract_write_error) return FALSE;\n else return TRUE;\n}\n\n./ ADD NAME=XGALLOC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*\n ***********************************************************************\n *                                                                     *\n * This is not a main program, nor a subroutine to be linked into an   *\n * existing program, but a routine which is to be called from a        *\n * REXX exec as follows:                                               *\n *                                                                     *\n *  dsn = \"name.of.data.set\"  -- or null to create a temporary         *\n *  dnn = \"ddname\"            -- or null to generate a unique one      *\n *  disp = \"SHR\"              -- or \"OLD\", \"NEW\", \"FREE\" or \"DELETE\"   *\n *  msg1 = \"\"                 -- to be set with an error message       *\n *  msg2 = \"\"                 -- to be set with an error message       *\n *                                                                     *\n *  address LINKMVS \"XGALLOC DSN DDN DISP MSG1 MSG2\"                   *\n *                                                                     *\n *  In addition to possibly updating the indicated variables, this     *\n *  routine returns a return code, which becomes the value of \"RC\".    *\n *                                                                     *\n *  The purpose of this routine is to provide a way for REXX execs     *\n *  to perform allocation and unallocation of data sets from a non-TSO *\n *  environment.  The LINKMVS (or ATTCHMVS) interface allows it to     *\n *  update the specified REXX variables by setting values for the      *\n *  passed parameters without calling REXX routines directly.          *\n *                                                                     *\n *  Use of this routine requires TSO/REXX 3.46 or higher.              *\n *                                                                     *\n ***********************************************************************\n */\n\n#pragma environment(XGALLOC)\n#pragma linkage(ikjeff18,OS)\n\n#include \"gg.h\"\n#include \"ggsvc.h\"\n#include \"ggsvc99.h\"\n\n#include <spc.h>\n\nenum disposition {DISP_SHR,DISP_OLD,DISP_MOD,\n                  DISP_NEW,DISP_KEEP,DISP_DELETE};\n\n#define set2(A,B)   *(short *)(A) = B\n#define set3(A,B)   memset(A,0,3); *(short *)(A+1) = B\n\nstruct varstring {\n                  short   len;\n                  char    text\u00dd1\u00a8;\n                 };\n\ntypedef struct varstring VARSTRING;\ntypedef int              (*ENTRYPOINT) ();\n\n/*--------------------------------------------------------------------*/\n\nstatic ENTRYPOINT\nggload(char   *module)\n{\n char          eploc\u00dd9\u00a8;\n SVC_REGISTER  reg15;\n SVC_REGISTER  reg0;\n SVC_REGISTER  reg1;\n\n#define LOAD_SVC  8\n\n memset(eploc,' ',8);\n memcpy(eploc,module,strlen(module));\n\n reg15 = (SVC_REGISTER) 0;\n reg0  = (SVC_REGISTER) &eploc;\n reg1  = (SVC_REGISTER) 0;\n\n SVC(LOAD_SVC,&reg15,&reg0,&reg1);\n\n return (ENTRYPOINT)reg0;\n\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic void\nallocfail(rc,p99,msg1,msg2)\nint            rc;\n__S99parms    *p99;\nchar          *msg1;\nchar          *msg2;\n{\n int           zero = 0;\n unsigned int  dfid = 0x40320000;\n struct {\n         short first_level_msg_len;\n         short first_level_msg_offset;\n         char  first_level_msg\u00dd251\u00a8;\n         short second_level_msg_len;\n         short second_level_msg_offset;\n         char  second_level_msg\u00dd251\u00a8;\n        }      dfbuffer;\n\n static ENTRYPOINT ikjeff18_pointer = NULL;\n\n strcpy(msg1,\"\");\n strcpy(msg2,\"\");\n\n if (!ikjeff18_pointer) {\n   ikjeff18_pointer = ggload(\"IKJEFF18\");\n }\n\n dfbuffer.first_level_msg_len = 4;\n dfbuffer.second_level_msg_len = 4;\n\n if (ikjeff18_pointer) {\n   if ((*ikjeff18_pointer)(p99,&rc,&zero,&dfid,&zero,&dfbuffer)) {\n     strcpy(msg1,\"IKJEFF18 returned a nonzero return code\");\n   }\n   if (dfbuffer.first_level_msg_len > 0) {\n     strncpy(msg1, dfbuffer.first_level_msg,\n                   dfbuffer.first_level_msg_len-4);\n   }\n   if (dfbuffer.second_level_msg_len > 0) {\n     strncpy(msg2, dfbuffer.second_level_msg,\n                   dfbuffer.second_level_msg_len-4);\n   }\n }\n else {\n   strcpy(msg1,\"XGALLOC cannot load IKJEFF18\");\n }\n return;\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic void\nsetmsg(msgvar,string)\nVARSTRING *msgvar;\nchar  *string;\n{\n\n msgvar->len = strlen(string);\n memcpy(msgvar->text,string,msgvar->len);\n return;\n}\n\n/*--------------------------------------------------------------------*/\n\nint\nXGALLOC()\n{\n VARSTRING      **reg1;\n VARSTRING       *dsnvar;\n VARSTRING       *ddnvar;\n VARSTRING       *dispvar;\n VARSTRING       *msg1var;\n VARSTRING       *msg2var;\n int              i;\n int              rc;\n int              disp99_1;\n int              disp99_2;\n Bool             unal;\n enum disposition disp;\n short            primary_allocation    = 0;\n short            secondary_allocation  = 0;\n short            directory_blocks      = 0;\n short            dsorg                 = 0;\n char             recfm                 = 0;\n short            lrecl                 = 0;\n short            blocksize             = 0;\n __S99parms       stuff99; /* No \"struct\", despite manual */\n TEXTUNIT        *return_dsname_tup = NULL;\n TEXTUNIT        *return_ddname_tup = NULL;\n TEXTUNIT        *tup \u00dd32\u00a8;\n TEXTUNIT         tu  \u00dd32\u00a8;\n char            *lparp;\n char            *rparp;\n char             dsname  \u00dd81\u00a8;\n char             ddname   \u00dd9\u00a8;\n char             dispname \u00dd9\u00a8;\n char             member  \u00dd81\u00a8;\n char             msg1   \u00dd256\u00a8;\n char             msg2   \u00dd256\u00a8;\n\n reg1 = (VARSTRING **)edcxregs(1);\n\n dsnvar  = reg1\u00dd0\u00a8;\n ddnvar  = reg1\u00dd1\u00a8;\n dispvar = reg1\u00dd2\u00a8;\n msg1var = reg1\u00dd3\u00a8;\n msg2var = reg1\u00dd4\u00a8;\n\n memset((char *)&stuff99,0,sizeof(__S99parms));\n strcpy(msg1,\"\");\n strcpy(msg2,\"\");\n\n if (dsnvar->len > 56) {\n   setmsg(msg1var,\"DSNAME argument cannot be longer than 56\");\n   return 16;\n }\n if (ddnvar->len > 8) {\n   setmsg(msg1var,\"DDNAME argument cannot be longer than 8\");\n   return 16;\n }\n if (dispvar->len > 8) {\n   setmsg(msg1var,\"DISP must be SHR/OLD/MOD/NEW/FREE/KEEP/DELETE\");\n   return 16;\n }\n\n strncpy(dsname,dsnvar->text,dsnvar->len);\n strncpy(ddname,ddnvar->text,ddnvar->len);\n strncpy(dispname,dispvar->text,dispvar->len);\n uppercase_in_place(dsname);\n uppercase_in_place(ddname);\n uppercase_in_place(dispname);\n\n if      (!strcmp(dispname,\"SHR\"))    disp = DISP_SHR;\n else if (!strcmp(dispname,\"OLD\"))    disp = DISP_OLD;\n else if (!strcmp(dispname,\"MOD\"))    disp = DISP_MOD;\n else if (!strcmp(dispname,\"NEW\"))    disp = DISP_NEW;\n else if (!strcmp(dispname,\"FREE\"))   disp = DISP_KEEP;\n else if (!strcmp(dispname,\"KEEP\"))   disp = DISP_KEEP;\n else if (!strcmp(dispname,\"DELETE\")) disp = DISP_DELETE;\n else {\n   setmsg(msg1var,\"DISP must be SHR/OLD/MOD/NEW/FREE/KEEP/DELETE\");\n   return 16;\n }\n\n switch (disp) {\n   case DISP_SHR:     unal=FALSE; disp99_1=SHR; disp99_2=KEEP; break;\n   case DISP_OLD:     unal=FALSE; disp99_1=OLD; disp99_2=KEEP; break;\n   case DISP_MOD:     unal=FALSE; disp99_1=MOD; disp99_2=CATLG; break;\n   case DISP_NEW:     unal=FALSE; disp99_1=NEW; disp99_2=CATLG; break;\n   case DISP_KEEP:    unal=TRUE; disp99_2=KEEP; break;\n   case DISP_DELETE:  unal=TRUE; disp99_2=DELETE; break;\n }\n\n switch (disp) {\n   case DISP_MOD:\n   case DISP_NEW:\n                 primary_allocation   = 100;\n                 secondary_allocation = primary_allocation;\n                 dsorg                = DSORG_PS;\n                 recfm                = RECFM_VB;\n                 lrecl                = 256;\n                 blocksize            = 23440;\n                 break;\n }\n\n strcpy(member,\"\");\n lparp = strchr(dsname,'(');\n rparp = strchr(dsname,')');\n if (lparp && rparp && (lparp < rparp) && (*(rparp+1) == '\\0')) {\n   *lparp = '\\0';            /* makes dsname the seq part only */\n   *rparp = '\\0';            /* turns member into a string     */\n   strcpy(member, lparp+1);\n }\n\n stuff99.__S99RBLN   = 20;\n stuff99.__S99VERB   = unal ? S99VRBUN : S99VRBAL;\n stuff99.__S99FLAG1  = S99NOCNV << 8;\n stuff99.__S99ERROR  = 0;\n stuff99.__S99INFO   = 0;\n stuff99.__S99TXTPP  = tup;\n stuff99.__S99FLAG2  = 0;\n\n for (i=0; i<32; i++) tup\u00ddi\u00a8 = &tu\u00ddi\u00a8;\n\n i = 0;\n\n if (*dsname) {\n   tu\u00ddi\u00a8.key        = unal ? DUNDSNAM : DALDSNAM;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = strlen(dsname);\n   copy_uppercase(tu\u00ddi\u00a8.ent.prm,dsname);\n   i++;\n }\n else if (!unal) {\n   tu\u00ddi\u00a8.key        = DALRTDSN;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = 44;\n   memset(tu\u00ddi\u00a8.ent.prm,' ',44);\n   return_dsname_tup = &tu\u00ddi\u00a8;\n   i++;\n }\n if (*member) {\n   tu\u00ddi\u00a8.key        = DALMEMBR;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = strlen(member);\n   copy_uppercase(tu\u00ddi\u00a8.ent.prm,member);\n   i++;\n }\n if (*ddname) {\n   tu\u00ddi\u00a8.key        = unal ? DUNDDNAM : DALDDNAM;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = strlen(ddname);\n   copy_uppercase(tu\u00ddi\u00a8.ent.prm,ddname);\n   i++;\n   if (!unal) {\n     tu\u00ddi\u00a8.key      = DALPERMA;\n     tu\u00ddi\u00a8.num      = 0;\n     i++;\n   }\n }\n else if (!unal) {\n   tu\u00ddi\u00a8.key        = DALRTDDN;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = 8;\n   memset(tu\u00ddi\u00a8.ent.prm,' ',8);\n   return_ddname_tup = &tu\u00ddi\u00a8;\n   i++;\n }\n if (unal) {\n   tu\u00ddi\u00a8.key        = DUNUNALC;\n   tu\u00ddi\u00a8.num        = 0;\n   i++;\n }\n else {\n   tu\u00ddi\u00a8.key        = DALSTATS;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = 1;\n   tu\u00ddi\u00a8.ent.prm\u00dd0\u00a8 = disp99_1;\n   i++;\n   tu\u00ddi\u00a8.key        = DALNDISP;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = 1;\n   tu\u00ddi\u00a8.ent.prm\u00dd0\u00a8 = disp99_2;\n   i++;\n }\n if (recfm) {\n   tu\u00ddi\u00a8.key        = DALRECFM;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = 1;\n   tu\u00ddi\u00a8.ent.prm\u00dd0\u00a8 = recfm;\n   i++;\n }\n if (lrecl) {\n   tu\u00ddi\u00a8.key        = DALLRECL;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = 2;\n   set2(tu\u00ddi\u00a8.ent.prm,lrecl);\n   i++;\n }\n if (blocksize) {\n   tu\u00ddi\u00a8.key        = DALBLKSZ;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = 2;\n   set2(tu\u00ddi\u00a8.ent.prm,blocksize);\n   i++;\n }\n if (blocksize) {\n   tu\u00ddi\u00a8.key        = DALBLKLN;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = 3;\n   set3(tu\u00ddi\u00a8.ent.prm,blocksize);\n   i++;\n }\n if (primary_allocation) {\n   tu\u00ddi\u00a8.key        = DALPRIME;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = 3;\n   set3(tu\u00ddi\u00a8.ent.prm,primary_allocation);\n   i++;\n }\n if (secondary_allocation) {\n   tu\u00ddi\u00a8.key        = DALSECND;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = 3;\n   set3(tu\u00ddi\u00a8.ent.prm,secondary_allocation);\n   i++;\n }\n if (dsorg) {\n   tu\u00ddi\u00a8.key        = DALDSORG;\n   tu\u00ddi\u00a8.num        = 1;\n   tu\u00ddi\u00a8.ent.len    = 2;\n   set2(tu\u00ddi\u00a8.ent.prm,dsorg);\n   i++;\n }\n\n tup\u00ddi\u00a8 = (void *)0x80000000;\n\n rc = svc99(&stuff99);\n\n if (rc == 0) {\n   if (return_dsname_tup) {\n     memcpy(dsnvar->text,(char *)return_dsname_tup->ent.prm,64);\n     dsnvar->len = return_dsname_tup->ent.len;\n   }\n   if (return_ddname_tup) {\n     memcpy(ddnvar->text,(char *)return_ddname_tup->ent.prm,8);\n     ddnvar->len = return_ddname_tup->ent.len;\n   }\n }\n else {\n   allocfail(rc,&stuff99,msg1,msg2);\n }\n setmsg(msg1var,msg1);\n setmsg(msg2var,msg2);\n return rc;\n}\n\n./ ADD NAME=XGCALL\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1995          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma runopts(noargparse,noredir)\n\n#include <stdio.h>\n#include \"gg.h\"\n\nmain(int argc, char **argv) {\n\n return system(argv\u00dd1\u00a8);\n\n}\n\n./ ADD NAME=XGSLEEP\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#include <stdio.h>\n#include \"gg.h\"\n\nmain(int argc, char **argv) {\n int     seconds = 0;\n\n if (argc > 1) seconds = atoi(argv\u00dd1\u00a8);\n\n if (seconds == 0) seconds = 1;\n\n return GGsleep(seconds);\n\n}\n\n./ ADD NAME=XGWTO\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma runopts(noargparse,noredir)\n\n#include <stdio.h>\n#include \"gg.h\"\n\nmain(int argc, char **argv) {\n char   *message;\n\n if (argc < 2) message = \"(No message)\";\n else message = argv\u00dd1\u00a8;\n\n return GGwto(message);\n\n}\n\n./ ENDUP\n?!\n//PANELS   EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='PANELS'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=GGM\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) CAPS(OFF)\n ! TYPE(TEXT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(``)\n%-`-`-  MVS Gopher Client -`-`-\n%COMMAND ===>_ZCMD\n+\n%Gopher server host name+(or IP address) %===>_GGHOST\n+\n%Initial path%===>\u00acGGPATH\n%Port number %===>_GGPORT\n+\n+Note:  You may specify a dash%-+as the Gopher server host name if\n        you want to use your own private Gopher data without making\n        a connection to a server.  If you do, you must specify the\n        name of your private Gopher menu in the initial path.\n        This name must be UNQUOTED AND FULLY QUALIFIED.\n        Alternatively, you may allocate your initial Gopher menu\n        to file GGGOPHER.\n\n        Any menu entries must also specify a dash in the host field;\n        otherwise they will require server access, as usual.\n\n        To use the REXX interface, you must allocate file GGEXEC to\n        your library of Gopherable REXX execs.\n\n+Press!END+key to leave this menu.\n)INIT\n &ZCMD = &Z\n IF (&GGPORT = &Z) &GGPORT = 70\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER (&GGHOST,NB)\n VER (&GGPORT,NUM)\n VPUT (GGHOST GGPATH GGPORT) PROFILE\n)END\n./ ADD NAME=GGMCSO\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n       @   TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY\n+\n%Command ===>\u00acZCMD\n+\n+Enter name to search for:\n+\n@FNAME1             +==>\u00acFVALUE1\n@FNAME2             +==>\u00acFVALUE2\n@FNAME3             +==>\u00acFVALUE3\n@FNAME4             +==>\u00acFVALUE4\n@FNAME5             +==>\u00acFVALUE5\n@FNAME6             +==>\u00acFVALUE6\n@FNAME7             +==>\u00acFVALUE7\n@FNAME8             +==>\u00acFVALUE8\n@FNAME9             +==>\u00acFVALUE9\n@FNAME10            +==>\u00acFVALUE10\n@FNAME11            +==>\u00acFVALUE11\n@FNAME12            +==>\u00acFVALUE12\n@FNAME13            +==>\u00acFVALUE13\n@FNAME14            +==>\u00acFVALUE14\n\n+Press%ENTER+to submit search request.\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n &ZWINTTL = 'CSO Nameserver User Name Search'\n &END = PFK(END)\n .CURSOR = FVALUE1\n)PROC\n IF  (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VPUT (FVALUE1 FVALUE2 FVALUE3 FVALUE4 FVALUE5 FVALUE6 FVALUE7) PROFILE\n VPUT (FVALUE8 FVALUE9 FVALUE10 FVALUE11 FVALUE12) PROFILE\n VPUT (FVALUE13 FVALUE14) PROFILE\n)END\n./ ADD NAME=GGMDIR\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n ~ TYPE(INPUT) INTENS(HIGH)  CAPS(OFF) JUST(LEFT)\n \u00ac TYPE(INPUT) INTENS(HIGH)  CAPS(OFF) JUST(LEFT)\n ! TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF) JUST(RIGHT) COLOR(YELLOW)\n # TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF) JUST(RIGHT) COLOR(BLUE)\n @ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(RIGHT) COLOR(PINK)\n ? TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF) JUST(LEFT)  COLOR(TURQ) PAD('.')\n |  AREA(DYNAMIC) EXTEND(ON) SCROLL(ON)\n \\  AREA(DYNAMIC) EXTEND(OFF) SCROLL(OFF)\n 01 TYPE(DATAOUT) INTENS(LOW)\n 02 TYPE(DATAOUT) INTENS(HIGH)\n 03 TYPE(DATAIN)  INTENS(LOW)\n 04 TYPE(DATAIN)  INTENS(HIGH)\n 05 TYPE(DATAOUT) COLOR(GREEN)\n 06 TYPE(DATAOUT) COLOR(PINK)\n 07 TYPE(DATAOUT) COLOR(RED)\n 08 TYPE(DATAOUT) COLOR(TURQ)\n 09 TYPE(DATAOUT) COLOR(YELLOW)\n 0A TYPE(DATAIN)  COLOR(BLUE)\n 0B TYPE(DATAIN)  COLOR(PINK)\n 0C TYPE(DATAIN)  COLOR(TURQ)\n 0D TYPE(DATAIN)  COLOR(WHITE)\n 0E TYPE(DATAIN)  COLOR(YELLOW)\n)BODY EXPAND(``)\n%&GGGHEAD\n%COMMAND ===>~GGGCMD                                          %SCROLL ===>\u00acGAMT+\n+\n+%S+Select%Q+Query%E+Extract%P+Print%B+Bookmark%I+Info\n -------------------------------------------------------------------------------\n|GGGDYNA                                                                       |\n)INIT\n IF (&GAMT = &Z) &GAMT = CSR\n IF (&GGGCSR \u00ac= 0)\n  .CURSOR = GGGDYNA\n  .CSRPOS = &GGGCSR\n)PROC\n &GGGLVL = LVLINE(GGGDYNA)\n VPUT (GAMT) PROFILE\n)END\n./ ADD NAME=GGMLCONN\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Gopher Server Connection -`-`-\n+\n+             Client name: &CLIENT\n+\n+\n+             Connection is in progress for Gopher server at:\n              &SERVER\n+\n+\n                                 % Please wait.\n+\n+\n)INIT\n&CLIENT = '&GGCLIENT (&GGCLIEIP)'\n&SERVER = '&GGSERVER (&GGSERVIP)'\n)PROC\n)END\n./ ADD NAME=GGMLDISC\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Gopher Server Connection -`-`-\n+\n+\n+         Disconnection is in progress from the Gopher server at:\n          &GGSOLDER (&GGSOLDIP)\n+\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=GGMLEXN2\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Gopher Server Connection -`-`-\n+\n+Description: &GGTSUBJ\n+\n+Extracting to: &GGEXDSN\n+&MEMSTUFF\n+\n                                 % Please wait.\n+\n)INIT\n IF (&GGEXMEM = &Z) &MEMSTUFF = &Z\n ELSE               &MEMSTUFF = 'Member: &GGEXMEM'\n)PROC\n)END\n./ ADD NAME=GGMLPRN2\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Gopher Server Connection -`-`-\n+\n+Description: &GGTSUBJ\n+\n+Printing to SYSOUT class: &GGEXSCL\n+&MEMSTUFF\n+\n                                 % Please wait.\n+\n)INIT\n IF (&GGEXMEM = &Z) &MEMSTUFF = &Z\n ELSE               &MEMSTUFF = 'Member: &GGEXMEM'\n)PROC\n)END\n./ ADD NAME=GGMLSOCK\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Gopher Server Connection -`-`-\n+\n+             Client:  &CLIENT\n+\n+             Connection successful.\n+\n+             Retrieving data from Gopher server at:\n              &SERVER\n+\n+\n                                 % Please wait.\n+\n+\n)INIT\n&CLIENT = '&GGCLIENT (&GGCLIEIP)'\n&SERVER = '&GGSERVER (&GGSERVIP)'\n)PROC\n)END\n./ ADD NAME=GGMOPT1\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n)BODY EXPAND(``)\n%-`-`- GOPHER - Directory Viewing Options -`-`-\n%Command ===>_ZCMD\n+\n+Scroll last selected menu item to top? (YES/NO)%==>_Z  +\n+Put cursor at last selected menu item? (YES/NO)%==>_Z  +\n\n\n+Press%ENTER+to change options.  Press%&END+(or type%END+command) when done.\n)INIT\n .ZVARS  = '(GGSCROLL GGCURSOR)'\n .CURSOR = ZCMD\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGSCROLL GGCURSOR) PROFILE\n &GGSCROLL = TRANS(TRUNC(&GGSCROLL,1)  Y,YES N,NO *,YES)\n &GGCURSOR = TRANS(TRUNC(&GGCURSOR,1)  Y,YES N,NO *,NO )\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n IF (.RESP = ENTER)\n  &GGSCROLL = TRUNC(&GGSCROLL,1)\n  &GGCURSOR = TRUNC(&GGCURSOR,1)\n  VER(&GGSCROLL,NB,LIST,Y,N)\n  VER(&GGCURSOR,NB,LIST,Y,N)\n VPUT (GGSCROLL GGCURSOR) PROFILE\n)END\n./ ADD NAME=GGMOPT2\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n)BODY EXPAND(``)\n%-`-`- GOPHER - Miscellaneous Options -`-`-\n%Command ===>_ZCMD\n+\n%EXTRACT prompting options:\n\n+Warning panel before writing over an existing dataset?%==>_Z  +\n+Warning panel before appending to an existing dataset?%==>_Z  +\n\n\n+Press%ENTER+to change options.  Press%&END+(or type%END+command) when done.\n)INIT\n .ZVARS  = '(GGEXTPOW GGEXTPAP)'\n .CURSOR = ZCMD\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGEXTPOW GGEXTPAP) PROFILE\n &GGEXTPOW = TRANS(TRUNC(&GGEXTPOW,1) Y,YES N,NO *,YES)\n &GGEXTPAP = TRANS(TRUNC(&GGEXTPAP,1) Y,YES N,NO *,YES)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n IF (.RESP = ENTER)\n  &GGEXTPOW = TRUNC(&GGEXTPOW,1)\n  &GGEXTPAP = TRUNC(&GGEXTPAP,1)\n  VER(&GGEXTPOW,NB,LIST,Y,N)\n  VER(&GGEXTPAP,NB,LIST,Y,N)\n VPUT (GGEXTPOW GGEXTPAP) PROFILE\n)END\n./ ADD NAME=GGMPBMDS\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,10)\n+\n%Command ===>\u00acZCMD\n+\n%&SUBJECT\n+\n+Bookmark data set ===>_GGBMDSN\n\n+(Note: Data set must be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n\n+Press%&END (END)+to cancel the bookmark request.\n)INIT\n .CURSOR = GGBMDSN\n &ZWINTTL = 'Append bookmark'\n &SUBJECT = '&GGTSUBJ'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGBMDSN) PROFILE\n IF (&GGBMDSN = &Z) &GGBMDSN = 'GOPHER.BOOKMARK'\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&GGBMDSN,NB,DSNAME)\n VPUT (GGBMDSN) PROFILE\n)END\n./ ADD NAME=GGMPCSO\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,10)\n+\n%Command ===>\u00acZCMD\n+\n+Enter name to search for:\n+\n%===>\u00acGGCSOQ\n\n+Press%ENTER+to submit search request.\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n &ZWINTTL = 'CSO Nameserver User Name Search'\n &END = PFK(END)\n .CURSOR = GGCSOQ\n)PROC\n IF  (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER (&GGCSOQ,NB)\n VPUT (GGCSOQ) PROFILE\n)END\n./ ADD NAME=GGMPDBM\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,13)\n+\n%Command ===>\u00acZCMD\n+\n+Remove bookmark from data set &GGMDBMDS:\n+\n%&GGMDBMSU\n+\n+Press%ENTER+to update &GGMDBMDS.\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n .ALARM = YES\n &ZWINTTL = 'Delete Bookmark'\n &END = PFK(END)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n)END\n./ ADD NAME=GGMPEXDS\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,16)\n+\n%Command ===>\u00acZCMD\n+\n%&SUBJECT\n+\n+Save to data set ===>_GGEXDSN\n+Expand tab characters?       ===>_Z  +\n\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n\n+Append to end of data set?   ===>_Z  +\n+Blank line after separator?  ===>_Z  +\n+Separator line between items (append mode only...blank for none):\n+>\u00acZ                                                                       +<\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .ZVARS = '(GGEXTAB GGEXAPP GGEXBLK GGEXSEP)'\n .CURSOR = GGEXDSN\n &ZWINTTL = 'Extract text'\n &SUBJECT = '&GGTSUBJ'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGEXDSN GGEXTAB GGEXAPP GGEXBLK GGEXSEP) PROFILE\n &GGEXTAB = TRANS(&GGEXTAB Y,YES N,NO ' ',NO)\n &GGEXAPP = TRANS(&GGEXAPP Y,YES N,NO ' ',NO)\n &GGEXBLK = TRANS(&GGEXBLK Y,YES N,NO ' ',NO)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&GGEXDSN,NB,DSNAME)\n &GGEXTAB = TRUNC(&GGEXTAB,1)\n VER(&GGEXTAB,NB,LIST,Y,N)\n &GGEXAPP = TRUNC(&GGEXAPP,1)\n VER(&GGEXAPP,NB,LIST,Y,N)\n &GGEXBLK = TRUNC(&GGEXBLK,1)\n VER(&GGEXBLK,NB,LIST,Y,N)\n VPUT (GGEXDSN GGEXTAB GGEXAPP GGEXBLK GGEXSEP) PROFILE\n)END\n./ ADD NAME=GGMPEXNG\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,14)\n+\n%Command ===>\u00acZCMD\n+\n+Save to data set ===>_GGEXDSN\n\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n\n+Append to end of data set?   ===>_Z  +\n+Blank line after separator?  ===>_Z  +\n+Separator line between items (append mode only...blank for none):\n+>\u00acZ                                                                       +<\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .ZVARS = '(GGEXAPP GGEXBLK GGEXSEP)'\n .CURSOR = GGEXDSN\n &ZWINTTL = 'Extract item listing'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGEXDSN GGEXAPP GGEXBLK GGEXSEP) PROFILE\n &GGEXAPP = TRANS(&GGEXAPP Y,YES N,NO ' ',NO)\n &GGEXBLK = TRANS(&GGEXBLK Y,YES N,NO ' ',NO)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&GGEXDSN,NB,DSNAME)\n &GGEXAPP = TRUNC(&GGEXAPP,1)\n VER(&GGEXAPP,NB,LIST,Y,N)\n &GGEXBLK = TRUNC(&GGEXBLK,1)\n VER(&GGEXBLK,NB,LIST,Y,N)\n VPUT (GGEXDSN GGEXAPP GGEXBLK GGEXSEP) PROFILE\n)END\n./ ADD NAME=GGMPEXNP\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY EXPAND(``) WINDOW(77,14)\n+\n%Command ===>\u00acZCMD\n+\n+Data set name%===>_GGEXPDS\n+Member prefix%===>_GGEXPMP + (item number appended - default is%#+)\n\n+Note: The dataset must be a PDS (old or new) with RECFM=VB and LRECL=259.\n\n+Expand tab characters?      %===>_Z  +\n\n+From item number%===>_GGEXAN1         + (blank for first item in table)\n+To   item number%===>_GGEXAN2         + (blank for last item in table)\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .ZVARS = '(GGEXTAB)'\n .CURSOR = ZCMD\n &ZWINTTL = 'Log text of items to PDS members'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGEXPDS GGEXPMP GGEXTAB) PROFILE\n &GGEXTAB = TRANS(&GGEXTAB Y,YES N,NO ' ',NO)\n IF (&GGEXPMP = &Z) &GGEXPMP = '#'\n &GGEXAN1 = &Z\n &GGEXAN2 = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n &GGEXTAB = TRUNC(&GGEXTAB,1)\n VER(&GGEXTAB,NB,LIST,Y,N)\n VER(&GGEXPDS,NB,DSNAME)\n &TEMP1 = TRUNC(&GGEXPDS,1)\n &TEMP2 = .TRAIL\n IF (&TEMP1 = '''')\n  &GGEXDSN = TRUNC(&TEMP2,'''')\n ELSE\n  &GGEXDSN = '&ZPREFIX..&GGEXPDS'\n  VER(&GGEXPMP,NB,NAME)\n VER(&GGEXAN1,NUM)\n VER(&GGEXAN2,NUM)\n VPUT (GGEXPDS GGEXPMP GGEXTAB) PROFILE\n)END\n./ ADD NAME=GGMPEXNS\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY EXPAND(``) WINDOW(77,17)\n+\n%Command ===>\u00acZCMD\n+\n+Data set name%===>_GGEXSEQ\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n+\n+Expand tab characters?      %===>_Z  +\n+\n+Append to end of data set?  %===>_Z  +\n+Blank line after separator? %===>_Z  +\n+Separator line before each item (leave blank for none):\n+>\u00acZ                                                                       +<\n\n+From item number%===>_GGEXAN1         + (blank for first item in table)\n+To   item number%===>_GGEXAN2         + (blank for last item in table)\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .ZVARS = '(GGEXTAB GGEXAPP GGEXBLK GGEXSEP)'\n .CURSOR = ZCMD\n &ZWINTTL = 'Log text of items to sequential file'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGEXSEQ GGEXTAB GGEXAPP GGEXBLK GGEXSEP) PROFILE\n &GGEXTAB = TRANS(&GGEXTAB Y,YES N,NO ' ',NO)\n &GGEXAPP = TRANS(&GGEXAPP Y,YES N,NO ' ',NO)\n &GGEXBLK = TRANS(&GGEXBLK Y,YES N,NO ' ',NO)\n &GGEXAN1 = &Z\n &GGEXAN2 = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&GGEXSEQ,NB,DSNAME)\n &GGEXDSN = &GGEXSEQ\n &GGEXTAB = TRUNC(&GGEXTAB,1)\n VER(&GGEXTAB,NB,LIST,Y,N)\n &GGEXAPP = TRUNC(&GGEXAPP,1)\n VER(&GGEXAPP,NB,LIST,Y,N)\n &GGEXBLK = TRUNC(&GGEXBLK,1)\n VER(&GGEXBLK,NB,LIST,Y,N)\n VER(&GGEXAN1,NUM)\n VER(&GGEXAN2,NUM)\n VPUT (GGEXSEQ GGEXTAB GGEXAPP GGEXBLK GGEXSEP) PROFILE\n)END\n./ ADD NAME=GGMPEXNT\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,10)\n+\n%Command ===>\u00acZCMD\n+\n+Move cursor to choice (or type%S+next to choice) and press%ENTER+to select:\n+\n_A%1+- List%titles+of items in table\n_B%2+- Log %text  +of items to%sequential file+\n_C%3+- Log %text  +of items to%members of PDS+\n+\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .CURSOR = ZCMD\n &ZWINTTL = 'Extract Gopher items - titles or text'\n &END = PFK(END)\n &ZCMD = &Z\n &A = &Z\n &B = &Z\n &C = &Z\n)PROC\n VER(&ZCMD,LIST,1,2,3)\n IF (&ZCMD \u00ac= &Z)\n  &GGCHOICE = TRANS(&ZCMD 1 1 2 2 3 3 * ?)\n ELSE\n  &TEMP = '&A/&B/&C'\n  IF (&TEMP = '//')\n   &GGCHOICE = TRANS(.CURSOR A 1 B 2 C 3 * ?)\n  ELSE\n   &GGCHOICE = TRANS(&TEMP  'S//' 1\n                            '1//' 1\n                            '/S/' 2\n                            '/2/' 2\n                            '//S' 3\n                            '//3' 3\n                               * ?\n                   )\n)END\n./ ADD NAME=GGMPEXN1\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,14)\n+\n%Command ===>\u00acZCMD\n+\n+Save to data set ===>_GGEXDSN\n\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n\n+Append to end of data set?   ===>_Z  +\n+Blank line after separator?  ===>_Z  +\n+Separator line between items (append mode only...blank for none):\n+>\u00acZ                                                                       +<\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .ZVARS = '(GGEXAPP GGEXBLK GGEXSEP)'\n .CURSOR = GGEXDSN\n &ZWINTTL = 'Extract Gopher item listing'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGEXDSN GGEXAPP GGEXBLK GGEXSEP) PROFILE\n &GGEXAPP = TRANS(&GGEXAPP Y,YES N,NO ' ',NO)\n &GGEXBLK = TRANS(&GGEXBLK Y,YES N,NO ' ',NO)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&GGEXDSN,NB,DSNAME)\n &GGEXAPP = TRUNC(&GGEXAPP,1)\n VER(&GGEXAPP,NB,LIST,Y,N)\n &GGEXBLK = TRUNC(&GGEXBLK,1)\n VER(&GGEXBLK,NB,LIST,Y,N)\n VPUT (GGEXDSN GGEXAPP GGEXBLK GGEXSEP) PROFILE\n)END\n./ ADD NAME=GGMPEXOW\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,10)\n+\n%Command ===>\u00acZCMD\n+\n+Dataset already exists:\n+\n%&GGEXDSN\n+\n+Press%ENTER+to%&ACTION\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n .ALARM = YES\n &ZWINTTL = 'Extract To Existing Data Set'\n &END = PFK(END)\n &APP = TRUNC(&GGEXAPP,1)\n IF (&APP = Y) &ACTION = 'append to the end of the data set.'\n ELSE          &ACTION = 'overwrite the current data set.'\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n)END\n./ ADD NAME=GGMPEXPW\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,13)\n+\n%Command ===>\u00acZCMD\n+\n+Partitioned dataset already exists:\n+\n%&GGEXDSN\n+\n+If member names are generated that match existing members\n+of this PDS, they will be%overwritten.+\n+\n+Press%ENTER+to proceed to use this PDS.\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n .ALARM = YES\n &ZWINTTL = 'Extract To Members of Existing PDS'\n &END = PFK(END)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n)END\n./ ADD NAME=GGMPOPT\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,10)\n+\n%Command ===>\u00acZCMD\n+\n+Move cursor to choice (or type%S+next to choice) and press%ENTER+to select:\n+\n_Z%1+- Display viewing options\n_Z%2+- Other options\n+\n+Press%&END (END)+to return to the previous panel.\n)INIT\n .ZVARS = '(S1 S2)'\n .CURSOR = ZCMD\n &ZWINTTL = 'Customize user options'\n &END = PFK(END)\n &ZCMD = &Z\n &S1   = &Z\n &S2   = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z)\n  &GGCHOICE = TRANS(&ZCMD 1 1 2 2 * ?)\n ELSE\n  &TEMP = '&S1/&S2'\n  IF (&TEMP = '/')\n   &GGCHOICE = TRANS(.CURSOR S1 1 S2 2 * ?)\n  ELSE\n   &GGCHOICE = TRANS(&TEMP  'S/' 1\n                            '1/' 1\n                            '/S' 2\n                            '/2' 2\n                               * ?\n                   )\n)END\n./ ADD NAME=GGMPPRDS\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n #   TYPE(TEXT)  INTENS(LOW)\n @   TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(LEFT)\n)BODY WINDOW(77,12)\n+\n%Command ===>\u00acZCMD\n+\n%&SUBJECT\n+\n+SYSOUT class ===>_Z+        Number of copies ===>_Z  +\n#Destination  ===>@DESTUSR           #  Forms ===>@Z   #   UCS ===>@Z   +\n\n+(Note: Print data will be released to SYSOUT immediately.)\n\n\n+Press%&END (END)+to cancel the print request.\n)INIT\n .ZVARS = '(GGEXSCL GGEXSCO GGEXSFO GGEXSUC)'\n .CURSOR = GGEXSCL\n &ZWINTTL = 'Print text'\n &SUBJECT = '&GGTSUBJ'\n &END = PFK(END)\n &ZCMD = &Z\n &GGEXSCO = 1\n &PVARS = 'GGEXSCL'\n IF (&GGALLPR \u00ac= &Z)\n  &PVARS = '&PVARS GGEXSDE GGEXSUS GGEXSFO GGEXSUC'\n  .ATTRCHAR('#') = 'TYPE(TEXT)   INTENS(LOW)'\n  .ATTRCHAR('@') = 'TYPE(INPUT)  INTENS(HIGH) CAPS(ON)  JUST(LEFT)'\n ELSE\n  .ATTRCHAR('#') = 'TYPE(TEXT)   INTENS(NON)'\n  .ATTRCHAR('@') = 'TYPE(OUTPUT) INTENS(NON)'\n VGET (&PVARS) PROFILE\n &DESTUSR = &GGEXSDE\n IF (&GGEXSDE \u00ac= &Z)\n  IF (&GGEXSUS \u00ac= &Z)\n   &DESTUSR = '&GGEXSDE..&GGEXSUS'\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&GGEXSCL,NB)\n IF (&GGEXSCO = &Z) &GGEXSCO = 1\n VER(&GGEXSCO,NUM)\n VER(&GGEXSCO,RANGE,1,255)\n &GGEXSDE = TRUNC(&DESTUSR,'.')\n &GGEXSUS = .TRAIL\n VPUT (&PVARS) PROFILE\n)END\n./ ADD NAME=GGMPWAIS\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,10)\n+\n%Command ===>\u00acZCMD\n+\n+Enter index search query:\n+\n%===>\u00acGGWAISQ\n\n+Press%ENTER+to submit search request.\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n &ZWINTTL = 'GOPHER Full Text Index Search'\n &END = PFK(END)\n .CURSOR = GGWAISQ\n)PROC\n IF  (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER (&GGWAISQ,NB)\n VPUT (GGWAISQ) PROFILE\n)END\n./ ADD NAME=GGMPWHOI\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,10)\n+\n%Command ===>\u00acZCMD\n+\n+Enter name to search for:\n+\n%===>\u00acGGWHOISQ\n\n+Press%ENTER+to submit search request.\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n &ZWINTTL = 'WHOIS/FINGER User Name Search'\n &END = PFK(END)\n .CURSOR = GGWHOISQ\n)PROC\n IF  (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER (&GGWHOISQ,NB)\n VPUT (GGWHOISQ) PROFILE\n)END\n./ ADD NAME=GGMVIEW\n)ATTR DEFAULT(%+_)\n/*                                                                   */\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993     */\n/*                                                                   */\n/* This software is provided on an \"AS IS\" basis.  All warranties,   */\n/* including the implied warranties of merchantability and fitness,  */\n/* are expressly denied.                                             */\n/*                                                                   */\n/* Provided this copyright notice is included, this software may     */\n/* be freely distributed and not offered for sale.                   */\n/*                                                                   */\n/* Changes or modifications may be made and used only by the maker   */\n/* of same, and not further distributed.  Such modifications should  */\n/* be mailed to the author for consideration for addition to the     */\n/* software and incorporation in subsequent releases.                */\n/*                                                                   */\n \u00ac  TYPE(INPUT)  INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n #  TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(RIGHT)\n \\  TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n |  AREA(DYNAMIC) EXTEND(ON) SCROLL(ON) USERMOD(05)\n 01 TYPE(DATAOUT) INTENS(LOW)\n 02 TYPE(DATAOUT) INTENS(HIGH)\n 03 TYPE(DATAIN)  INTENS(LOW)\n 04 TYPE(DATAIN)  INTENS(HIGH)\n)BODY\n\\GGBTITLE\n%COMMAND ===>\u00acZCMD                                            %SCROLL ===>_Z   +\n|GGBDYNA                                                                       |\n)INIT\n .ZVARS = GGMBROSC\n IF (&GGMBROSC = &Z) &GGMBROSC = CSR\n .CURSOR = &GGBCUR\n .CSRPOS = &GGBPOS\n)PROC\n &GGBCUR = .CURSOR\n &GGBPOS = .CSRPOS\n &GGBLVL = LVLINE(GGBDYNA)\n VPUT (GGMBROSC) PROFILE\n)END\n./ ENDUP\n?!\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IPCSDIST": {"ttr": 9992, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x97'?\\x00\\x97'?!58\\x1d8\\x1d\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-30T00:00:00", "modifydate": "1997-09-30T21:35:00", "lines": 14365, "newlines": 14365, "modlines": 0, "user": "SEB"}, "text": "//JOBNAME JOB ACCOUNT,'NAME'\n//*------------------------------------------------------------------*/\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1995    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis. All warranties,   */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed. Such modifications should  */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*------------------------------------------------------------------*/\n//*\n//*    IPCS Verb Exits, ISPF Panels and CLISTs\n//*\n//*\n//* Author: Steve Bacher <seb@draper.com>\n//*\n//* Date: 26 Sep 1997\n//*\n//*-------------------------------------------------------------------\n//*\n//* This job creates the distribution libraries (PDS's).\n//*\n//* Run this JCL to create the PDS's, after customizing to suit.\n//* (Obviously, put in a good JOB statement first.)\n//* To customize the JCL, change the defaults on the //MDLOAD PROC\n//* statement to your liking, particularly the PREFIX default.\n//* You might also want to change the final qualifiers of the PDS's\n//* created - to do this, find the // EXEC MDLOAD statements and\n//* change the value of the TO parameter.\n//*\n//* See the $$README file (of the CNTL PDS, first in this stream)\n//* for the rest of the installation instructions.\n//*\n//MDLOAD PROC CLS='*',BS='6160',U='SYSDA',V='',\n//      TRK1='30',TRK2='10',DIR='35',RLSE='RLSE',\n//      PREFIX='SYS8.IPCS.'\n//*\n//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=&CLS\n//SYSUT2 DD DISP=(NEW,CATLG,DELETE),DSN=&PREFIX.&TO,\n//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=&BS),\n//  SPACE=(TRK,(&TRK1,&TRK2,&DIR),&RLSE),UNIT=&U,VOL=SER=&V\n//*\n//  PEND\n//*\n//CNTL     EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='CNTL'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=$$README\nThis distribution contains IPCS CLISTs, panels, and verb exits.\n\nYou must assemble the verb exits and store the resultant load modules\nin a library allocated to ISPLLIB and/or referenced in an IPCS\n\"TASKLIB\" library.\n\nYou must also insure that the CLISTs are accessible in the SYSPROC\nconcatenation, the panels are accessible in the ISPPLIB concatenation,\netc.\n\nNote that these are made available AS IS.  There are a few references\nto utilities local to Draper, e.g.:\n\n XDELETE = replacement for IBM's \"DELETE\" command\n XDSTAT  = reports on status of an MVS data set\n XLC     = replacement for IBM's \"LISTC\"  command\n\n XPROC   = available from your friendly MVS FTP site, probably\n the same one you got this stuff from.  Some of the REXX execs use it.\n If you don't have it, get it - it's worth it.\n\nYou should make suitable changes to the CLISTs that reference these.\n\n=======================================================================\n\nOther warnings:\n\nThese were written originally for an MVS/XA system and then\nmigrated to MVS/ESA.  All caveats apply.\n\nThe stuff that runs under IPCS is in CLIST, because I wrote them\nbefore IPCS had full REXX support.  The handful of REXX execs are\nthings that run as TSO commands, even if from within ISPF or IPCS.\n\nFor the stuff that references fields in SWA control blocks, like the\nJFCB, you must be running with SWA below the line.  I have no idea\nhow to process SWA above the line from IPCS, and IBM has not been\nany help in this area either.\n\n=======================================================================\n\nIf you have any questions, feel free to send email to:\n\n Steve Bacher <batchman@draper.com>\n\n./ ENDUP\n?!\n//CLIST    EXEC MDLOAD,BS='6160',TRK1='20',TRK2='1',TO='CLIST'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=ACTIVE\nPROC 0 +\n       XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nELSE CONTROL NOMSG\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nEVAL 224.%+24 SIGNED LENGTH(2) CLIST(S(ASID)) ACTIVE\nIF &LASTCC = 12 THEN DO\n WRITE Unable to access ASID in active main storage.\n EXIT C(12) Q\nEND\nSETDEF ACTIVE ASID(&ASID)\n./ ADD NAME=BINARY\nPROC 1 NUMBER XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nELSE CONTROL NOMSG\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nINTEGER &NUMBER UNSIGNED CLIST(S(FIXNUM))\nCONTROL NOFLUSH\nERROR DO\n ERROR OFF\n WRITE Value out of range or invalid, &NUMBER\n EXIT C(12) Q\nEND\nIF &FIXNUM < 0 | &FIXNUM > 255 THEN DO\n WRITE Value out of range, &NUMBER\n EXIT C(12) Q\nEND\nERROR OFF\nSET I = 1\nSET J = 128\nDO WHILE &J > 0\n SET B&I = &FIXNUM / &J\n SET FIXNUM = &FIXNUM // &J\n SET I = &I + 1\n SET J = &J / 2\nEND\nSET BINARY = &STR(&B1&B2&B3&B4&B5&B6&B7&B8)\nIF &SYSNEST = NO THEN NOTE '&BINARY' ASIS\nEXIT CODE(&BINARY)\n./ ADD NAME=BROWSE\n/* REXX. Usage: BROWSE address otherparms        */\n/*       See OBROWSE for old version.            */\n/*\nsay \"browse\"\ntrace r\nif sysvar(\"syspcmd\") \\= \"IPCS\" then do\n  say \"*** You must be in IPCS to use this CLIST. ***\"\n  exit 16\nend\n */\nsignal on halt\nparse arg addr parms\nif addr \\= \"\" then do\n address ISPEXEC \"SELECT PGM(BLSGSCMD) PARM(EQ X \"addr\")\"\n if rc \\= 0  then do; say \"Error, bad IPCS environment\";exit rc;end\n parms = \"PANEL(STORAGE)\" parms\nend\nelse do\n parms = \"PANEL(POINTER)\" parms\nend\naddress ISPEXEC,\n        \"SELECT PGM(BLSLDISP) NEWAPPL(BLSL) PASSLIB PARM(\"parms\")\"\nif rc \\= 0  then do; say \"Error, bad IPCS environment\";exit rc;end\nexit rc\nhalt:exit\n./ ADD NAME=CPUID\n/* rexx (this takes 72 msec vs. CLIST OCPUID's 430 msec */\n\npccavt = c2d(storage(d2x(c2d(storage(10,4))+764),4))\ndo cpu = 0 to 15\n pccapointer = c2d(storage(d2x(pccavt+(cpu*4)),4))\n if pccapointer ^= 0 then do\n  cpuserial = storage(d2x(pccapointer+4) ,8)\n  cpuid     = storage(d2x(pccapointer+12),4)\n  say\n  say \"CPU #\"cpu\" ID = \"cpuid\n  say \"CPU #\"cpu\" serial number = \"cpuserial\n end\nend\nexit\n./ ADD NAME=DCB\nPROC 1 DCBADDRESS TCBADDRESS(21C.%) XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nIF &SUBSTR(1:4,&DCBADDRESS    ) = &SUBSTR(1:4,DCB()) THEN +\n SET DCBADDRESS = &SUBSTR(5:&LENGTH(&STR(&DCBADDRESS))-1,&DCBADDRESS)\nIF &STR(&DCBADDRESS) ^= DCB THEN +\n EQ DCB &DCBADDRESS L(96) NODROP\nEVAL &DCBADDRESS L(96) CLIST(S(DCB))\nIF &LASTCC ^= 0 THEN DO\n NOTE 'Error: DCB at &DCBADDRESS not accessible.' ASIS\n EXIT C(12) Q\nEND\n%DUMPCB DCB &DCBADDRESS 96\nCONTROL NOFLUSH\nSET ERROK = N\nERROR DO\n SET CC = &LASTCC\n IF &ERROK = Y THEN RETURN\n ERROR OFF\n IF &CC = 12 THEN DO\n  NOTE 'Error accessing storage - DCB processing terminated.' ASIS\n  EXIT C(12) Q\n END\n WRITE Major error processing &SYSSCMD subcommand - LASTCC=&CC\n EXIT C(16) Q\nEND\n/*\n/* First get DSORG.  This determines DCB type as well.\n/*\nEVAL &DCBADDRESS+1A L(2) HEX CLIST(S(DSORG))\nSELECT &STR(&DSORG)\n WHEN (&STR(8000)) SET DSORG = IS\n WHEN (&STR(8100)) SET DSORG = ISU\n WHEN (&STR(4000)) SET DSORG = PS\n WHEN (&STR(4100)) SET DSORG = PSU\n WHEN (&STR(2000)) SET DSORG = DA\n WHEN (&STR(2100)) SET DSORG = DAU\n WHEN (&STR(1000)) SET DSORG = CX\n WHEN (&STR(0200)) SET DSORG = PO\n WHEN (&STR(0300)) SET DSORG = POU\n WHEN (&STR(0080)) SET DSORG = GS\n WHEN (&STR(0040)) SET DSORG = TX\n WHEN (&STR(0020)) SET DSORG = TQ\n WHEN (&STR(0008)) SET DSORG = VSAM\n WHEN (&STR(0004)) SET DSORG = TR\n WHEN (&STR(0000)) SET DSORG = NONE\n OTHERWISE         SET DSORG = &STR(X''&DSORG'')\nEND\n/*\n/* Get record format.\n/*\nEVAL &DCBADDRESS+24 L(1) HEX CLIST(S(HEXRF))\nSET CC = 0\nSET ERROK = Y\n%BINARY X'&HEXRF'\nSET ERROK = N\nSET BINRF = &SUBSTR(2:9,&EVAL(100000000+&CC))\nSELECT &SUBSTR(1:3,&BINRF)\n WHEN (&STR(000)) SET RECFM = ?\n WHEN (&STR(001)) SET RECFM = D\n WHEN (&STR(010)) SET RECFM = V\n WHEN (&STR(011)) SET RECFM = VT\n WHEN (&STR(100)) SET RECFM = F\n WHEN (&STR(101)) SET RECFM = FT\n WHEN (&STR(110)) SET RECFM = U\n WHEN (&STR(111)) SET RECFM = UT\nEND\nIF &SUBSTR(4,&BINRF) = 1 THEN SET RECFM = &RECFM.B\nIF &SUBSTR(5,&BINRF) = 1 THEN SET RECFM = &RECFM.S\nIF &SUBSTR(6,&BINRF) = 1 THEN SET RECFM = &RECFM.A\nIF &SUBSTR(7,&BINRF) = 1 THEN SET RECFM = &RECFM.M\nIF &RECFM = ? THEN SET RECFM = X''&HEXRF''\n/*\n/* Get KEYLEN if low-order bit of RECFM byte is on.\n/*\nIF &SUBSTR(8,&BINRF) = 1 THEN DO\n EVAL &DCBADDRESS+10 L(1) UNS CLIST(S(KEYLEN))\n SET KEYLENEQ = &STR(,KEYLEN=&EVAL(&KEYLEN))\nEND\nELSE SET KEYLENEQ =\n/*\n/* Get other DCB attributes.\n/*\nEVAL &DCBADDRESS+3E L(2) SIG CLIST(S(BLKSIZE))\nEVAL &DCBADDRESS+52 L(2) SIG CLIST(S(LRECL))\n/*\n/* Display basic DCB attributes.\n/*\nNOTE +\n 'RECFM=&RECFM,LRECL=&LRECL,BLKSIZE=&BLKSIZE,DSORG=&DSORG&KEYLENEQ' +\n ASIS\nNOTE SPACE(1)\n/*\n/* Now see if dataset is open.  Certain fields are in different places\n/* depending on this.\n/*\nSET CC = 0\nSET ERROK = Y\nCOMPARE ADDRESS(&DCBADDRESS+30) WITH(VALUE(X'10')) MASK(X'10') LENGTH(1)\nSET ERROK = N\nIF &CC = 0 THEN DO /* dataset is open */\n EVAL &DCBADDRESS+2D           L(3) PTR CLIST(S(DEBADDRESS))\n EVAL &DEBADDRESS..+1          L(3) PTR CLIST(S(TCBADDRESS)\n EVAL &DCBADDRESS+28           L(2) HEX CLIST(S(TOFF))\n EVAL &TCBADDRESS..+C%+&TOFF+4 L(8) CHAR CLIST(S(DDNAME))\n NOTE 'Dataset is open - DEB at &DEBADDRESS, TCB at &TCBADDRESS' ASIS\n NOTE 'DDNAME is &DDNAME' ASIS\n EVAL &TCBADDRESS..+C%+&TOFF+C L(3) PTR CLIST(S(JFCBADDR))\n SET CC = 0\n SET ERROK = Y\n EVAL &JFCBADDR..+10 L(44) CHAR CLIST(S(DSNAME))\n IF &CC = 12 THEN GOTO SKIPJFCB\n EVAL &JFCBADDR..+3C L(8)  CHAR CLIST(S(MEMBER))\n IF &CC = 12 THEN GOTO SKIPJFCB\n EVAL &JFCBADDR..+86 L(6)  CHAR CLIST(S(VOLUME))\n IF &CC = 12 THEN GOTO SKIPJFCB\n SET ERROK = N\n NOTE 'DSNAME is &DSNAME' ASIS\n IF &STR(&MEMBER) ^= THEN +\n  NOTE 'MEMBER is &MEMBER' ASIS\n NOTE 'VOLUME is &VOLUME' ASIS\n SKIPJFCB:+\n SET OPEN = Y\nEND\nELSE DO\n EVAL &DCBADDRESS+28 L(8) CHAR CLIST(S(DDNAME))\n EVAL &DCBADDRESS+28 L(2) HEX CLIST(S(TOFF))\n IF &SUBSTR(1,&TOFF ) = 0 THEN DO\n  NOTE 'Dataset is not open' ASIS\n  EVAL 21C.%+C%+&TOFF+4 L(8) CHAR CLIST(S(DDNAME))\n  NOTE 'DDNAME is &DDNAME' ASIS\n  EVAL 21C.%+C%+&TOFF+C L(3) PTR CLIST(S(JFCBADDR))\n  SET CC = 0\n  SET ERROK = Y\n  EVAL &JFCBADDR..+10 L(44) CHAR CLIST(S(DSNAME))\n  IF &CC = 12 THEN GOTO SKIPJ2\n  EVAL &JFCBADDR..+3C L(8)  CHAR CLIST(S(MEMBER))\n  IF &CC = 12 THEN GOTO SKIPJ2\n  EVAL &JFCBADDR..+86 L(6)  CHAR CLIST(S(VOLUME))\n  IF &CC = 12 THEN GOTO SKIPJ2\n  SET ERROK = N\n  NOTE 'DSNAME is &DSNAME' ASIS\n  IF &STR(&MEMBER) ^= THEN +\n   NOTE 'MEMBER is &MEMBER' ASIS\n  NOTE 'VOLUME is &VOLUME' ASIS\n  SKIPJ2:+\n END\n ELSE DO\n  NOTE 'Dataset is closed' ASIS\n  NOTE 'DDNAME is &DDNAME' ASIS\n END\n SET OPEN = N\nEND\nNOTE SPACE(1)\nEVAL &DCBADDRESS+00 L(4) HEX CLIST(S(Z))\nNOTE 'RELAD  &SUBSTR(1:16,&Z        )  TTRN of current PDS member' ASIS\nEVAL &DCBADDRESS+05 L(8) HEX CLIST(S(Z))\nNOTE 'FDAD   &Z  MBBCCHHR of record just read or written' ASIS\nEVAL &DCBADDRESS+10 L(1) UNS CLIST(S(Z))\nNOTE 'KEYLE  &SUBSTR(1:16,&Z                )  Key length' ASIS\nEVAL &DCBADDRESS+14 L(1) UNS CLIST(S(Z))\nNOTE 'BUFNO  &SUBSTR(1:16,&Z                )  Buffer number' ASIS\nEVAL &DCBADDRESS+15 L(3) PTR CLIST(S(Z))\nNOTE 'BUFCB  &Z            Address of buffer pool control block' ASIS\nEVAL &DCBADDRESS+18 L(2) SIG CLIST(S(Z))\nNOTE 'BUFL   &SUBSTR(1:16,&Z                )  Buffer length' ASIS\nEVAL &DCBADDRESS+1C L(4) PTR CLIST(S(Z))\nNOTE 'IOBAD  &Z          Address of IOB for chained scheduling' ASIS\nEVAL &DCBADDRESS+20 L(1) HEX CLIST(S(Z))\nNOTE 'BFTEK  &SUBSTR(1:16,&Z                )  Buffering technique' ASIS\nEVAL &DCBADDRESS+21 L(3) PTR CLIST(S(Z))\nNOTE 'EODAD  &Z            Address of end-of-data routine' ASIS\nEVAL &DCBADDRESS+25 L(3) HEX CLIST(S(Z))\nNOTE 'EXLST  &Z            Address of exit list' ASIS\nEVAL &DCBADDRESS+34 L(1) HEX CLIST(S(Z))\nNOTE 'OPTCD  &SUBSTR(1:16,&Z                )  Option codes' ASIS\nEVAL &DCBADDRESS+39 L(3) PTR CLIST(S(Z))\nNOTE 'SYNAD  &Z            Address of SYNAD routine' ASIS\nEVAL &DCBADDRESS+45 L(3) PTR CLIST(S(Z))\nNOTE 'IOBA   &Z            Address of IOB or ICB' ASIS\nEVAL &DCBADDRESS+50 L(2) UNS CLIST(S(Z))\nNOTE 'DIRCT  &SUBSTR(1:16,&Z                )  +\nBytes used in last directory block' ASIS\nEVAL &DCBADDRESS+48 L(1) UNS CLIST(S(Z))\nNOTE 'NCP    &SUBSTR(1:16,&Z                )  +\nNumber of channel programs' ASIS\nIF &DSORG = PS THEN DO\n EVAL &DCBADDRESS+48 L(4) PTR CLIST(S(Z))\n NOTE 'EOBAD  &Z          Address of last byte of current buffer' ASIS\n EVAL &DCBADDRESS+4C L(4) PTR CLIST(S(R))\n NOTE 'RECAD  &R          Address of current or next logical record' +\n      ASIS\n IF &LRECL = 0 THEN SET RECLEN = &BLKSIZE\n ELSE SET RECLEN = &LRECL\n SET CC = 0\n NOTE SPACE(1)\n IF &CC = 0 THEN DO\n  SET ERROK = Y\n  %DUMPCB LAST_LOGICAL_RECORD &R..-&RECLEN.N &RECLEN &XTRACE\n  IF &CC = 0 THEN DO\n   %DUMPCB NEXT_LOGICAL_RECORD &R..          &RECLEN &XTRACE\n  END\n  SET ERROK = N\n END\nEND\n./ ADD NAME=DOTCBS\nPROC 1 COMMAND PARMS() ARGUMENTPOSITIONAL XTRACE\n/*********************************************************************/\n/*                                                                   */\n/* Function: This CLIST executes an IPCS subcommand or CLIST for all */\n/*           TCBs in a memory contained in the dump being analyzed.  */\n/*           In this way it is similar to RUNCHAIN.  The CLIST is    */\n/*           executed with the specified parameters plus the keyword */\n/*           \"TCB(address)\", where the TCB address is provided for   */\n/*           each TCB.                                               */\n/*                                                                   */\n/* SYNTAX:   %DOTCBS command P('...')                                */\n/*                                                                   */\n/*********************************************************************/\nCONTROL NOCAPS\n/**********************************************************************/\n/*                                                                    */\n/* Get the current ASID.                                              */\n/*                                                                    */\n/**********************************************************************/\n%GETASID &XTRACE\nSET ASID = &LASTCC\n\nEVAL 224. PTR CLIST(S(ASCBADDR))\nEVAL &ASCBADDR..+6C PTR CLIST(S(ASXBADDR))\nIF &LASTCC=12 THEN DO\n NOTE '==> Error: ASXB not available for ASID(&ASID)' ASIS\n EXIT C(16) Q\nEND\n\nEVAL &ASXBADDR..+5 LE(3) PTR CLIST(S(TCBADDR))\nIF &LASTCC=12 THEN DO\n L &ASXBADDR..+5 LE(3) PTR\n NOTE '==> Error: TCB&TCBCTR not available for ASID(&ASID)' ASIS\n EXIT C(16) Q\nEND\n\nIF &TCBADDR = 0 THEN DO\n NOTE SPACE(1)\n NOTE '--- No TCB''s to process for &NRSTR(&COMMAND).' ASIS\n EXIT\nEND\n\n/******************************************************************/\n/* Process all TCBs for this address space                        */\n/******************************************************************/\n\nCONTROL NOFLUSH\n\nNOTE SPACE(1)\n\nDO WHILE &TCBADDR^=0\n INTEGER X'&TCBADDR' PTR CLIST(S(TCBADDR))\n\n IF &ARGUMENTPOSITIONAL = THEN +\n  SET CMDSTR = &NRSTR(&COMMAND TCB(&TCBADDR..) &PARMS)\n ELSE +\n  SET CMDSTR = &NRSTR(&COMMAND &TCBADDR &PARMS)\n\n NOTE SPACE(1)\n NOTE '--- &NRSTR(&COMMAND) --- TCB at &TCBADDR.. ---' ASIS\n WRITE &NRSTR(&CMDSTR)\n NOTE SPACE(1)\n &NRSTR(&CMDSTR)\n WRITE\n\n EVAL &TCBADDR..+75 LE(3) PTR CLIST(S(TCBADDR))\n IF &LASTCC=12 THEN DO\n  NOTE '==> Error: Cannot access next TCB pointer from &TCBADDR for +\n                   ASID(&ASID)' ASIS\n  EXIT C(4)\n END\nEND\n\nEXIT\n\n./ ADD NAME=DUMP\nPROC 1 ADDRESS LENGTHVALUE() XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nSET LP = &SUBSTR(1,())\nSET RP = &SUBSTR(2,())\nSET L = &LENGTH(&STR(&ADDRESS))\nIF &SUBSTR(&L,&ADDRESS) = &STR(&RP) THEN DO\n SET I = 0\n DO WHILE &I LT &L-1\n  SET I = &I + 1\n  IF &SUBSTR(&I,&ADDRESS) = &STR(&LP) THEN DO\n   SET &CB = &SUBSTR(1:&I-1,&ADDRESS)\n   IF &LENGTHVALUE = THEN DO\n    IF &STR(&CB) = TCB THEN SET LENGTHVALUE = 376\n    ELSE SET LENGTHVALUE = 256\n   END\n   %DUMPCB &CB &SUBSTR(&I+1:&L-1,&ADDRESS) &LENGTHVALUE\n   EXIT C(&LASTCC)\n  END\n END /* Do while */\nEND\nELSE DO\n IF &LENGTHVALUE = THEN SET LENGTHVALUE = 256\n %DUMPCB DUMPDATA &ADDRESS &LENGTHVALUE\nEND\n./ ADD NAME=DUMPCB\nPROC 3 CBNAME CBADDRESS CBLENGTH OFFSET(0) TITLE() NOTITLE NOSKIP XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nIF &NRSTR(&TITLE&NOTITLE) = THEN +\n SET TITLE = &NRSTR(&CBNAME at &CBADDRESS)\nIF &NOSKIP = THEN NOTE SPACE(1)\nIF &LASTCC ^= 0 THEN EXIT C(4)\nINTEGER &CBLENGTH SIGNED CLIST(S(CBLENGTH))\nIF &LASTCC = 12 THEN DO\n WRITE Invalid length value, &CBLENGTH\n EXIT Q\nEND\nEVAL &CBADDRESS L(&CBLENGTH) HEX CLIST(S(CBHEX))\nIF &LASTCC = 12 THEN GOTO ERROR\nEVAL &CBADDRESS L(&CBLENGTH) CHAR CLIST(S(CBCHAR))\nIF &LASTCC = 12 THEN GOTO ERROR\nEQ TEMP$$$$ &CBADDRESS+0\nEVALSYM TEMP$$$$ CLIST(ADDRESS(CBADDRESS) POSITION(CBPOSITION))\nINTEGER X'&CBADDRESS'  SIGNED CLIST(S(V))\nINTEGER X'&CBPOSITION' SIGNED CLIST(S(P))\nSET V = &V + &P\nINTEGER &V PTR CLIST(S(CBADDRESS))\nIF &NOTITLE = THEN DO\n NOTE '&TITLE' ASIS\n IF &LASTCC ^= 0 THEN EXIT C(4)\n IF &NOSKIP = THEN NOTE SPACE(1)\n IF &LASTCC ^= 0 THEN EXIT C(4)\nEND\nDO J = 0 TO &CBLENGTH-1 BY 16\n SET HOWLONG = &CBLENGTH - &J\n IF &HOWLONG > 16 THEN SET HOWLONG = 16\n EVAL &CBADDRESS..+&J.N L(&HOWLONG) HEX CLIST(S(HEXLINE))\n IF &LASTCC = 12 THEN GOTO ERROR\n SET HEXLINE = &SUBSTR(1:32,&HEXLINE                                )\n EVAL &CBADDRESS..+&J.N L(&HOWLONG) CHAR CLIST(S(CHARLINE) ENQUOTE)\n IF &LASTCC = 12 THEN GOTO ERROR\n SET CHARLINE = &SUBSTR(2:&LENGTH(&NRSTR(&CHARLINE))-1,&NRSTR(&CHARLINE)\n SET CURRENT_OFFSET = &J+(&OFFSET)\n IF &CURRENT_OFFSET < 0 THEN DO\n  INTEGER &EVAL(0-(&CURRENT_OFFSET)) PTR(6) CLIST(S(LABEL))\n  SET SIGN = &STR(-)\n END\n ELSE DO\n  INTEGER &CURRENT_OFFSET PTR(6) CLIST(S(LABEL))\n  SET SIGN = &STR(+)\n END\n INTEGER &V PTR(8) CLIST(S(X))\n NOTE ' &SIGN&LABEL  &X  &SUBSTR(01:08,&HEXLINE) +\n                         &SUBSTR(09:16,&HEXLINE) +\n                         &SUBSTR(17:24,&HEXLINE) +\n                         &SUBSTR(25:32,&HEXLINE)  *+\n                         &NRSTR(&CHARLINE)*' ASIS\n IF &LASTCC ^= 0 THEN EXIT C(4)\n SET V = &V + 16\nEND\nNOTE SPACE(1)\nEXIT\nERROR:+\nNOTE 'Error: &CBNAME at &CBADDRESS not available (length &CBLENGTH)' ASI\nEXIT C(12) Q\nEND\n./ ADD NAME=DUMPRB\nPROC 0 TCB() XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n/* Code to extract current TCB\nIF &STR(&TCB) = THEN DO\n SET TCB = 0\n EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))\n IF &TCB = 0 THEN DO\n  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))\n  IF &TCB = 0 THEN DO\n   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))\n   IF &TCB = 0 THEN DO\n    NOTE 'TCB unavailable' ASIS\n    EXIT C(12) Q\n   END\n  END\n END\nEND\n/* End code to extract current TCB\n%DUMPCB RB_PREFIX &TCB+0%-40 64\n%DUMPCB RB &TCB+0% 240\nEXIT\n./ ADD NAME=ENQ\nPROC 1 R1 XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n\nNOTE 'ENQ (SVC 56) info: +\n      MVS/XA Debugging Handbook, Vol. 1 - p. 5-31' +\n     SPACE(1) ASIS\n\nTCBX YITADDR &R1\nSET E1 = &STR(&YITHEX)\nTCBX YITADDR &E1..-20\nSET E2 = &STR(&YITHEX)\n\nDO UNTIL &DO_IT_AGAIN = 4\n SYSCALL DO_IT &E1 &E2\n SET DO_IT_AGAIN = &LASTCC\n TCBX YITADDR &E1..+20\n SET E1 = &STR(&YITHEX)\nEND\n\nEXIT\n\nDO_IT: PROC 2 E1 E2\n\n/*\n/* Stupid code to get around SYSREF lossage.\n/*\nSET SYSDVAL =\nREADDVAL ENQPLIST ENQMASID BITS +\n         FLAGBITS RNAMELEN ENQPARMS +\n         ENQRCODE QNAMEPTR RNAMEPTR UCB_WORD\n\nSYSCALL ISET ENQPLIST &E1 L(20) DUMPCB\n\nSYSCALL EXTRACT ENQPLIST FLAGBITS  0 L(1)    DUMP\nSYSCALL EXTRACT ENQPLIST RNAMELEN  1 L(1)    DUMP\nSYSCALL EXTRACT ENQPLIST ENQPARMS  2 L(1)    DUMP\nSYSCALL EXTRACT ENQPLIST ENQRCODE  3 L(1)    DUMP\nSYSCALL EXTRACT ENQPLIST QNAMEPTR  4 L(4)    DUMP\nSYSCALL EXTRACT ENQPLIST RNAMEPTR  8 L(4)    DUMP\nSYSCALL EXTRACT ENQPLIST UCB_WORD 12 L(4)    DUMP\n\nNOTE SPACE(1)\n\nSYSCALL SETBITS BITS FLAGBITS\nSET MASID = N\nSET END_OF_LIST = N\nIF &SUBSTR(1,&BITS) = 1 THEN DO\n NOTE '  End-of-list indicator on '  ASIS\n SET END_OF_LIST = Y\nEND\nIF &SUBSTR(2,&BITS) = 1 THEN DO\n NOTE '  Old options are in effect' ASIS\n GOTO SKIP_OTHER_BITS\nEND\nIF &SUBSTR(3,&BITS) = 1 THEN NOTE '  Reserved bit on!!!!!!!'     ASIS\nIF &SUBSTR(4,&BITS) = 1 THEN NOTE '  Resource owned shared'      ASIS\nELSE                         NOTE '  Resource owned exclusively' ASIS\nIF &SUBSTR(5,&BITS) = 1 THEN DO\n NOTE '  MASID prefix present'       ASIS\n SET MASID = Y\nEND\nIF &SUBSTR(6:7,&BITS) = &STR(01) THEN DO\n NOTE '  Generic DEQ requested'  ASIS\nEND\nIF &SUBSTR(8,&BITS) = 1 THEN NOTE '  TCB=... requested        '  ASIS\n\nSKIP_OTHER_BITS:+\nIF &MASID = Y THEN DO\n\n SYSCALL ISET ENQMASID &E2 L(20) DUMPCB\n\nEND\n\nSYSCALL SETBITS BITS ENQPARMS\nIF &SUBSTR(1,&BITS) = 1 THEN NOTE '  Shared request' ASIS\nELSE NOTE '  Exclusive request' ASIS\nSELECT &SUBSTR(2,&BITS)&SUBSTR(5,&BITS)\n WHEN (00)  NOTE '  SCOPE=STEP' ASIS\n WHEN (01)  NOTE '  RESERVE (see UCB_WORD for UCB address)' ASIS\n WHEN (10)  NOTE '  SCOPE=SYSTEM' ASIS\n WHEN (11)  NOTE '  SCOPE=SYSTEMS' ASIS\nEND\n\nIF &SUBSTR(3,&BITS) = 1 THEN NOTE '  Obsolete bit on!!!!!!!'     ASIS\nIF &SUBSTR(4,&BITS) = 1 THEN NOTE '  Step-must-complete (SMC)'   ASIS\nSELECT &SUBSTR(6:8,&BITS)\n WHEN (000)  NOTE '  RET=NONE   ' ASIS\n WHEN (001)  NOTE '  RET=HAVE   ' ASIS\n WHEN (010)  NOTE '  RET=CHNG   ' ASIS\n WHEN (011)  NOTE '  RET=USE    ' ASIS\n WHEN (100)  NOTE '  ECB=...    ' ASIS\n WHEN (111)  NOTE '  RET=TEST   ' ASIS\n OTHERWISE   NOTE 'Invalid ENQPARMS:  &BITS'\nEND\n\nNOTE SPACE(1)\nSET QNAMEPTRDOT = &STR(&QNAMEPTR..)\nSYSCALL FIXUP QNAMEPTRDOT\nEVAL &QNAMEPTRDOT L(8) CHAR CLIST(S(QNAME))\nIF &LASTCC = 12 THEN DO\n NOTE 'QNAME at &QNAMEPTRDOT (length 8) is not accessible in dump.' ASIS\n EVAL &QNAMEPTRDOT L(8) CHAR CLIST(S(QNAME)) ACTIVE\n IF &LASTCC = 0 THEN DO\n  NOTE 'On the current (active) system it is:  &NRSTR(&QNAME)' ASIS\n  NOTE SPACE(1)\n END\nEND\nELSE DO\n NOTE 'QNAME:  &NRSTR(&QNAME)' ASIS\nEND\n\nINTEGER X'&RNAMELEN' UNS CLIST(S(RNAMELNN))\nIF &RNAMELNN = 0 THEN DO\n NOTE 'RNAME length is zero' ASIS\nEND\nELSE DO\n SET RNAMEPTRDOT = &STR(&RNAMEPTR..)\n SYSCALL FIXUP RNAMEPTRDOT\n EVAL &RNAMEPTRDOT L(&RNAMELNN) CHAR CLIST(S(RNAME))\n IF &LASTCC = 12 THEN DO\n  NOTE 'RNAME at &RNAMEPTRDOT (length &RNAMELNN) is not accessible' ASIS\n END\n ELSE DO\n  NOTE 'RNAME:  &NRSTR(&RNAME)' ASIS\n  EVAL &RNAMEPTRDOT L(&RNAMELNN) HEX CLIST(S(RNAMEX))\n  NOTE '        (&RNAMEX)' ASIS\n END\nEND\n\nIF &END_OF_LIST = Y THEN RETURN CODE(4)\nELSE RETURN CODE(0)\n\nEND DO_IT\n\nEXTRACT: PROC 3 STRING VAR OFFSET LENGTHVALUE(4) DUMP\n SET VARNAME = &STR(&VAR)\n SYSREF VAR STRING\n SET X = 2*&OFFSET+1\n ERROR RETURN CODE(&LASTCC)\n SET VAR = &SUBSTR(&X:&X+2*&LENGTHVALUE-1,&STRING)\n IF &LASTCC = 932 THEN DO\n  NOTE 'Error: Unable to extract &LENGTHVALUE bytes at offset &OFFSET +\n               from data: &STRING' SPACE(1) ASIS\n END\n ELSE DO\n  IF &DUMP = DUMP THEN DO\n   NOTE '&VARNAME:  &VAR' ASIS\n  END\n END\nEND\n\nISET: PROC 2 CLISTVAR FIELD DUMPCB +\n             LENGTHVALUE(4) PTR POINTER SIGNED UNSIGNED\n SET TITLE = &STR(&CLISTVAR) /* before SYSREFfing\n SYSREF CLISTVAR\n SET CLISTVAR = &STR(<<<no_value>>>)\n IF &SYSINDEX(.,&FIELD) ^= 0 THEN DO\n  SYSCALL FIXUP FIELD\n END\n EVAL &FIELD L(&LENGTHVALUE) &PTR &POINTER &SIGNED &UNSIGNED +\n      CLIST(S(CLISTVAR))\n IF &LASTCC ^= 0 THEN DO\n  NOTE 'Error: &NRSTR(&TITLE) at &NRSTR(&FIELD) not accessible.' ASIS\n  EXIT C(12) Q\n END\n IF &DUMPCB = DUMPCB THEN %DUMPCB &TITLE &FIELD &LENGTHVALUE\n RETURN\nEND\n\nFIXUP: PROC 1 AFIELD\n SYSREF AFIELD\n SET I = &SYSINDEX(.,&AFIELD)\n IF &I = 9 THEN DO\n  SET I = &SYSINDEX(&SUBSTR(1,&AFIELD),89ABCDEF)\n  IF &I ^= 0 THEN DO\n   SET AFIELD = +\n      &SUBSTR(&I,01234567)&SUBSTR(2:&LENGTH(&STR(&AFIELD)),&AFIELD)\n  END\n END\nEND\n\nSETBITS: PROC 2 BITS FROMWHAT\n SYSREF BITS FROMWHAT\n %BINARY X'&FROMWHAT'\n SET R = &LASTCC\n SET L = &LENGTH(&STR(&R))\n SET BITS = &SUBSTR(&L+1:&L+8,00000000&R)\nEND\n./ ADD NAME=EQREGS\n00010002PROC 1 REQUESTBLOCKADDRESS ACTIVE LIST\n00020000IF &STR(&SYSPCMD) ^= IPCS THEN DO\n00030000  WRITE *** YOU MUST BE IN IPCS TO USE THIS CLIST. ***\n00040000  EXIT C(16) Q\n00050000END\n00060001IF &LIST = LIST THEN CONTROL LIST\n00070001EQ REGS &REQUESTBLOCKADDRESS+20 L(64) &ACTIVE\n00080001EQ R0   &REQUESTBLOCKADDRESS+20 L(4)  &ACTIVE\n00090001EQ R1   &REQUESTBLOCKADDRESS+24 L(4)  &ACTIVE\n00100001EQ R2   &REQUESTBLOCKADDRESS+28 L(4)  &ACTIVE\n00110001EQ R3   &REQUESTBLOCKADDRESS+2C L(4)  &ACTIVE\n00120001EQ R4   &REQUESTBLOCKADDRESS+30 L(4)  &ACTIVE\n00130001EQ R5   &REQUESTBLOCKADDRESS+34 L(4)  &ACTIVE\n00140001EQ R6   &REQUESTBLOCKADDRESS+38 L(4)  &ACTIVE\n00150001EQ R7   &REQUESTBLOCKADDRESS+3C L(4)  &ACTIVE\n00160001EQ R8   &REQUESTBLOCKADDRESS+40 L(4)  &ACTIVE\n00170001EQ R9   &REQUESTBLOCKADDRESS+44 L(4)  &ACTIVE\n00180001EQ R10  &REQUESTBLOCKADDRESS+48 L(4)  &ACTIVE\n00190001EQ R11  &REQUESTBLOCKADDRESS+4C L(4)  &ACTIVE\n00200001EQ R12  &REQUESTBLOCKADDRESS+50 L(4)  &ACTIVE\n00210001EQ R13  &REQUESTBLOCKADDRESS+54 L(4)  &ACTIVE\n00220001EQ R14  &REQUESTBLOCKADDRESS+58 L(4)  &ACTIVE\n00230001EQ R15  &REQUESTBLOCKADDRESS+5C L(4)  &ACTIVE\n./ ADD NAME=GETASID\nPROC 0 LIST XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n/*\n/* This CLIST returns the ASID as a return code.\n/*\nISPQRY\nIF &LASTCC = 20 THEN DO\n WRITE ISPF services not available, assuming current ASID is correct.\n EXIT\nEND\nDO WHILE ETERNITY=ETERNITY\n ISPEXEC DISPLAY PANEL(IPCASID) /* Choose an ASID. */\n SELECT &LASTCC\n  WHEN (0) DO\n            IF &STR(&OTHASID) ^= &STR() THEN DO\n             INTEGER &OTHASID UNS CLIST(S(IPASID))\n            END\n            IF &STR(&IPASID) = &STR() THEN DO\n             SET IPASID = &STR(N/A)\n            END\n            ELSE DO\n             SETDEF ASID(&IPASID)\n             IF &LIST = LIST THEN WRITE ASID is &IPASID\n             EXIT C(&IPASID)\n            END\n           END\n  WHEN (8) DO\n            EXIT QUIT C(0)\n           END\n  OTHERWISE DO\n             ISPEXEC DISPLAY PANEL(ISPTERM)\n             EXIT QUIT C(0)\n            END\n END\nEND\n./ ADD NAME=GETSSVT\nPROC 0 ACTIVE XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\n/*SE CONTROL NOMSG\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n\n/**********************************************************************/\n/*                                                                    */\n/* This CLIST finds the SSVT and similar control blocks.              */\n/*                                                                    */\n/**********************************************************************/\n\nEVAL 10.?+128 L(4) PTR &ACTIVE   /* Get JESCT pointer from CVT  */+\n              CLIST(S(JESCTP))\nIF &LASTCC = 12 THEN DO\n NOTE 'JESCT pointer not available from CVT.' ASIS\n GOTO EXIT\nEND\nIF &JESCTP = 00000000 THEN DO\n NOTE 'There is no JESCT.' ASIS\n GOTO EXIT\nEND\nEQ JESCT &JESCTP.. L(112) &ACTIVE\nEVAL &JESCTP.+18 L(4) PTR &ACTIVE /* Get SSCVT pointer from JESCT */ +\n                 CLIST(S(SSCVTP))\nIF &LASTCC = 12 THEN DO\n NOTE 'SSCVT pointer not available from JESCT.' ASIS\n GOTO EXIT\nEND\nIF &SSCVTP = 00000000 THEN DO\n NOTE 'There is no SSCVT.' ASIS\n GOTO EXIT\nEND\nEQ SSCVT &SSCVTP.. L(36) &ACTIVE\nEVAL &SSCVTP..+10 L(4) PTR &ACTIVE  /* Get SSVT pointer from SSCVT */ +\n                  CLIST(S(SSVTP))\nIF &LASTCC = 12 THEN DO\n NOTE 'SSVT pointer not available from SSCVT.' ASIS\n GOTO EXIT\nEND\nIF &SSVTP = 000000 THEN DO\n NOTE 'There is no SSVT.' ASIS\n GOTO EXIT\nEND\nEQ SSVT &SSVTP.. L(260) &ACTIVE\nEXIT:+\nLISTSYM    (JESCT SSCVT SSVT)              &ACTIVE\nEXIT\n./ ADD NAME=HEADER\n\n/**********************************************************************/\n/*                                                                    */\n/* Updated for ESA header format.                                     */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 0 EQUATEPREFIX() WHERE XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nCONTROL NOFLUSH\nSET ERROK = N\nERROR DO\n SET CC = &LASTCC\n IF &ERROK = Y THEN RETURN CODE(&CC)\n ELSE GOTO ERROR_ERROR_ERROR\nEND\nIF &WHERE = WHERE THEN +\n IF &STR(&EQUATEPREFIX) = &STR() THEN +\n  SET EQUATEPREFIX = HEADERREGISTERWHERE\nIF &STR(&EQUATEPREFIX) ^= &STR() THEN +\n SET SREP = &STR(EQUATEPREFIX(&EQUATEPREFIX))\nELSE SET SREP =\nEVAL 0. HEADER L(2) CHAR CLIST(S(TEMP))\nIF &STR(&TEMP) ^= DR THEN DO\n NOTE 'Warning: Header+0 not C''DR'' - not an SP/3 (ESA) dump.' ASIS\nEND\nERROR OFF\nSET HDRASID  = &STR(N/A)\nSET HDRASIDX = &STR(N/A)\nSET HASID    = &STR(N/A)\nSET HASIDX   = &STR(N/A)\nSET PROGRAM  = &STR(N/A)\n/* Offset of SDUMP common section... */\nEVAL 168. HEADER L(2) HEX CLIST(S(COMMOFF))\nIF &STR(&COMMOFF) ^= &STR(0000) THEN DO\n NOTE SPACE(1)\n NOTE '======================= Information from common section +\n       ======================' ASIS\n NOTE SPACE(1)\n EVAL &COMMOFF..+48 HEADER L(2) UNS CLIST(S(PASID))\n INTEGER &PASID PTR(4) CLIST(S(PASIDX))\n EVAL &COMMOFF..+4A HEADER L(2) UNS CLIST(S(SASID))\n INTEGER &SASID PTR(4) CLIST(S(SASIDX))\n EVAL &COMMOFF..+4C HEADER L(2) UNS CLIST(S(HASID))\n INTEGER &HASID PTR(4) CLIST(S(HASIDX))\n NOTE 'ASID''s: Primary= &PASID (X''&PASIDX'')  +\n       Secondary= &SASID (X''&SASIDX'')  +\n       Home= &HASID (X''&HASIDX'')+\n      ' ASIS\nEND\nNOTE SPACE(1)\nNOTE '======================= Information from dump header +\n      =========================' ASIS\nNOTE SPACE(1)\nSET HDRASID  = &STR(&HASID)\nSET HDRASIDX = &STR(&HASIDX)\nEVAL 24. HEADER L(1) HEX CLIST(S(TEMP))\nSELECT &STR(&TEMP)\n WHEN (01)  SET TYPE = &STR(a stand-alone dump)\n WHEN (02)  SET TYPE = &STR(an SVC dump)\n WHEN (03)  SET TYPE = &STR(a SYSMDUMP)\n WHEN (04)  SET TYPE = &STR(a SLIP dump)\n OTHERWISE  SET TYPE = &STR(an unknown (X''&TEMP'') kind of dump)\nEND\nEVAL 40. HEADER L(8) CHAR CLIST(S(PROGRAM))\nNOTE 'This is &TYPE for ASID &HDRASID (X''&HDRASIDX'') +\n      requested by program &PROGRAM..' ASIS\n\n/**********************************************************************/\n/*                                                                    */\n/* Cross-check the header ASID with the current ASCB ASID and the     */\n/* ASID as established by IPCS.                                       */\n/*                                                                    */\n/**********************************************************************/\n\nSET DEFASCB = &STR(*unavail)\nSET DEFASID = &STR(***)\nSET DEFASIDX = &STR(****)\nEVALDEF CLIST(QUALIFICATION(KWAL))\n/*  IF &SUBSTR(1:6,&NRSTR(&KWAL      )) = &STR(NOCPU ) THEN DO\n/*   SET KWAL = &SUBSTR(7:&LENGTH(&NRSTR(&KWAL)),&NRSTR(&KWAL))\n/*  END\nSET KX = &SYSINDEX(&SUBSTR(1:5,ASID()),&NRSTR(&KWAL)\nIF &KX ^= 0 THEN DO\n SET QA = &SUBSTR(&KX+5:&LENGTH(&NRSTR(&KWAL))-1,&NRSTR(&KWAL))\n INTEGER &NRSTR(&QA) UNS    CLIST(S(DEFASID))\n INTEGER &NRSTR(&QA) PTR(4) CLIST(S(DEFASIDX))\nEND\nELSE DO\n NOTE 'Warning: No ASID qualification defined via SETDEF.' ASIS\n /* cannot do note... quotes */\n WRITE Current qualification is:  \"&NRSTR(&KWAL)\"\n NOTE SPACE(1)\nEND\nSET CURASCB = &STR(*unavail)\nSET CURASID = &STR(***)\nSET CURASIDX = &STR(****)\nEVAL 224. PTR CLIST(S(CURASCB))\nIF &LASTCC ^= 0 THEN DO\n NOTE 'Error:  PSA ASCB pointer not accessible at 224.' ASIS\nEND\nELSE DO\n EVAL 224.?+24 L(2) UNS CLIST(S(CURASID))\n IF &LASTCC ^= 0 THEN DO\n  NOTE 'Error:  Couldn''t get ASID from the current ASCB.' ASIS\n END\n ELSE DO\n  INTEGER &CURASID PTR(4) CLIST(S(CURASIDX))\n END\nEND\nSET SYSDVAL = /* STUPID_SYSREF_LOSSAGE */\nREADDVAL HDRASCB HDRJOBN CURJOBN DEFASCB DEFJOBN +\n         HDRASIDC CURASIDC DEFASIDC\nSYSCALL EDITN HDRASID HDRASIDC\nSYSCALL EDITN CURASID CURASIDC\nSYSCALL EDITN DEFASID DEFASIDC\nSYSCALL GET_ASCB HDRASCB &HDRASID &HDRASIDX\nSYSCALL GET_ASCB DEFASCB &DEFASID &DEFASIDX\nSYSCALL GET_JOBNAME HDRJOBN &HDRASCB\nSYSCALL GET_JOBNAME CURJOBN &CURASCB\nSYSCALL GET_JOBNAME DEFJOBN &DEFASCB\n\nNOTE SPACE(1)\nNOTE 'ASID from SETDEF set by IPCS... &DEFASIDC (X''&DEFASIDX'')    +\n     Jobname:  &DEFJOBN' ASIS\nNOTE 'ASID from the current ASCB..... &CURASIDC (X''&CURASIDX'')    +\n     Jobname:  &CURJOBN' ASIS\nNOTE 'ASID from the dump header...... &HDRASIDC (X''&HDRASIDX'')    +\n     Jobname:  &HDRJOBN' ASIS\n\n/*  EVAL 10. HEADER L(8) HEX CLIST(S(TEMP))\n/*  NOTE SPACE(1)\n/*  NOTE 'Time of dump:  &TEMP' ASIS\n\n/*  /* Process SDUMP/SYSMDUMP data\n/*\n/*  EVAL 130. HEADER L(2) HEX CLIST(S(SDMPOFF))\n/*  IF &STR(&SDMPOFF) ^= &STR(0000) THEN DO\n/*   NOTE SPACE(1)\n/*   NOTE '------------------- SDUMP/SYSMDUMP data follows +\n/*         -----------------' ASIS\n/*   NOTE SPACE(1)\n/*   EVAL &SDMPOFF..+0 HEADER L(4) HEX CLIST(S(TEMP))\n/*   NOTE 'CVT address:  &TEMP' ASIS\n/*  END\n\n/* Process SLIP-dump-only data\n\nERROR DO\n SET CC = &LASTCC\n IF &ERROK = Y THEN RETURN CODE(&CC)\n ELSE GOTO ERROR_ERROR_ERROR\nEND\nEVAL 16C. HEADER L(2) HEX CLIST(S(SLIPOFF))\nIF &STR(&SLIPOFF) ^= &STR(0000) THEN DO\n NOTE SPACE(1)\n NOTE '-------------------- SLIP dump data follows +\n       ---------------------' ASIS\n NOTE SPACE(1)\n EVAL &SLIPOFF..+0 HEADER L(8) HEX CLIST(S(TEMP))\n NOTE 'PSW at entry to SLIP:  &SUBSTR(1:8,&TEMP) &SUBSTR(9:16,&TEMP)' +\n      ASIS\n NOTE SPACE(1)\n SET NSI = &SUBSTR(9:16,&TEMP)\n %WHERE &NSI.. STACK ID('ABEND LOCATION (SLIP DUMP HEADER)')\n NOTE SPACE(1)\n NOTE 'Registers at time of SLIP...' ASIS\n EVAL &SLIPOFF..+10 HEADER L(64) HEX CLIST(S(TEMP))\n /* %SHOWREGS &TEMP STACK(YES) ID('SLIP DUMP HEADER') &XTRACE\n SET CC = 0\n SET ERROK = Y\n EVALSYM SLIPREGSFROMDUMPHEADER\n SET ERROK = N\n IF &CC ^= 0 THEN DO\n  %SHOWREGS &TEMP STACK(YES) ID('SLIP DUMP HEADER') &SREP &XTRACE\n  EQ SLIPREGSFROMDUMPHEADER &SLIPOFF..+10 HEADER L(64)\n END\n ELSE DO\n  %SHOWREGS &TEMP &SREP &XTRACE\n END\n NOTE SPACE(1)\n ERROR OFF\n SET A = &SUBSTR(1,&NSI)\n DO I = 1 TO 8\n  IF &A = &SUBSTR(&I,89ABCDEF) THEN DO\n   SET NSI = &SUBSTR(&I,01234567)&SUBSTR(2:8,&NSI)\n   SET I = 9\n  END\n END\n\n %DUMPCB INSTRUCTIONS_PRECEDING_PSW_ADDRESS &NSI..-20 32 OFFSET(-32) +\n         NOSKIP TITLE('Instructions preceding PSW address')\n %DUMPCB INSTRUCTIONS_FOLLOWING_PSW_ADDRESS &NSI..    32 +\n         NOSKIP TITLE('Instructions following PSW address')\n\n IF &WHERE = WHERE THEN SYSCALL DO_WHERE &EQUATEPREFIX\n\nEND\n\n/* Process SDWA data\n\nERROR DO\n SET CC = &LASTCC\n IF &ERROK = Y THEN RETURN CODE(&CC)\n ELSE GOTO ERROR_ERROR_ERROR\nEND\nEVAL 174. HEADER L(2) HEX CLIST(S(SDWAOFF))\nIF &STR(&SDWAOFF) ^= &STR(0000) THEN DO\n NOTE SPACE(1)\n NOTE '---------------------- SDWA data follows +\n       ----------------------- ' ASIS\n NOTE SPACE(1)\n EVAL 176. HEADER L(2) SIG CLIST(S(SDWALEN))\n\n EVAL &SDWAOFF..+04 HEADER L(4) HEX CLIST(S(TEMP))\n NOTE 'Completion code:        &TEMP' ASIS\n EVAL &SDWAOFF..+68 HEADER L(8) HEX CLIST(S(TEMP))\n NOTE 'PSW at time of error:   &SUBSTR(1:8,&TEMP) &SUBSTR(9:16,&TEMP)' +\n      ASIS\n NOTE SPACE(1)\n SET NSI = &SUBSTR(9:16,&TEMP)\n %WHERE &NSI.. STACK ID('ABEND LOCATION (DUMP HEADER SDWA)')\n NOTE SPACE(1)\n NOTE 'Registers at time of abend...' ASIS\n EVAL &SDWAOFF..+18 HEADER L(64) HEX CLIST(S(TEMP))\n SET CC = 0\n SET ERROK = Y\n EVALSYM SDWAREGSFROMDUMPHEADER\n SET ERROK = N\n IF &CC ^= 0 THEN DO\n  %SHOWREGS &TEMP STACK(YES) ID('DUMP HEADER SDWA') &SREP &XTRACE\n  EQ SDWAREGSFROMDUMPHEADER &SDWAOFF..+18 HEADER L(64)\n END\n ELSE DO\n  %SHOWREGS &TEMP &SREP &XTRACE\n END\n /*  EVAL &SDWAOFF..+58 HEADER L(8) CHAR CLIST(S(TEMP))\n /*  NOTE 'Abending program name:  &TEMP' ASIS\n /*  EVAL &SDWAOFF..+60 HEADER L(4) PTR  CLIST(S(TEMP))\n /*  NOTE 'Entry point of above:   &TEMP' ASIS\n /*  NOTE SPACE(1)\n ERROR OFF\n SET A = &SUBSTR(1,&NSI)\n DO I = 1 TO 8\n  IF &A = &SUBSTR(&I,89ABCDEF) THEN DO\n   SET NSI = &SUBSTR(&I,01234567)&SUBSTR(2:8,&NSI)\n   SET I = 9\n  END\n END\n\n %DUMPCB INSTRUCTIONS_PRECEDING_PSW_ADDRESS &NSI..-20 32 OFFSET(-32) +\n         TITLE('Instructions preceding PSW address')\n %DUMPCB INSTRUCTIONS_FOLLOWING_PSW_ADDRESS &NSI..    32 +\n         TITLE('Instructions following PSW address')\n\n IF &WHERE = WHERE THEN SYSCALL DO_WHERE &EQUATEPREFIX\n\nEND\n\nEXIT\n\nDO_WHERE: PROC 1 EQUATEPREFIX\n DO &I = 0 TO 15\n  %WHERE &EQUATEPREFIX&I\n END\nRETURN\nEND DO_WHERE\n\nERROR_ERROR_ERROR:+\nERROR OFF\nIF &CC = 12 THEN DO\n NOTE 'Error accessing storage - HEADER processing terminated.' ASIS\n EXIT C(12) Q\nEND\nWRITE Major error processing &SYSSCMD subcommand - LASTCC=&CC\nEXIT C(16) Q\n\nGET_ASCB: PROC 3 AVAR ASIDN ASIDX\n SYSREF AVAR\n SET AVAR = &STR(*unavail)\n\n IF &DATATYPE(&STR(&ASIDN)) ^= NUM THEN DO\n  NOTE 'Cannot get ASCB for this ASID: &ASIDN' ASIS\n  RETURN CODE(16)\n END\n\n/**********************************************************************/\n/*                                                                    */\n/* Get the ASCB for this ASID.  Note that instead of using the PSA's  */\n/* ASCBNEW or ASCBOLD pointer, we use the ASID to index into the ASVT */\n/* to find it.  In that way you can map the TCB chain from the ASID   */\n/* that you requested using SETDEF.                                   */\n/*                                                                    */\n/**********************************************************************/\n\n EVAL CVT+22C L(4) PTR CLIST(S(ASVTADDR))\n IF &LASTCC ^= 0 THEN DO\n  NOTE '==> Error: ASVT address not available from CVT+22C' ASIS\n  RETURN CODE(16)\n END\n EVAL &ASVTADDR..+204 L(4) UNS CLIST(S(ASVTMAXU))\n IF &LASTCC ^= 0 THEN DO\n  NOTE '==> Error: ASVTMAXU not available from ASVT at &ASVTADDR' ASIS\n  RETURN CODE(16)\n END\n IF &ASIDN > &ASVTMAXU THEN DO\n  NOTE '==> Error: ASID &ASID is invalid, greater than maximum' ASIS\n  RETURN CODE(16)\n END\n SET ASVTOFFS = &ASIDN*4\n EVAL &ASVTADDR..+20C+&ASVTOFFS.N L(4) PTR CLIST(S(ASCBADDR))\n IF &LASTCC ^= 0 THEN DO\n  NOTE '==> Error: ASCB address not available at 224.' ASIS\n  RETURN CODE(16)\n END\n SELECT &SUBSTR(1,&ASCBADDR)\n  WHEN (8|9|A|B|C|D|E|F) DO\n   NOTE '==> Error: ASID &ASID is not assigned.' ASIS\n   RETURN CODE(16)\n  END\n END\n\n SET AVAR = &STR(&ASCBADDR)\n RETURN CODE(0)\nEND\n\nGET_JOBNAME: PROC 2 JOBNAME ASCBADDR\n SYSREF JOBNAME\n SET JOBNAME = &STR(*unavail)\n IF &STR(&ASCBADDR) = &STR(*unavail) THEN RETURN\n EVAL &ASCBADDR..+AC L(4) PTR CLIST(S(JOBNAMEADDR))\n IF &LASTCC = 12 THEN RETURN\n IF &STR(&JOBNAMEADDR) = &STR(00000000) THEN DO\n  EVAL &ASCBADDR..+B0 L(4) PTR CLIST(S(JOBNAMEADDR))\n  IF &LASTCC = 12 THEN RETURN\n END\n EVAL &JOBNAMEADDR.. L(8) CHAR CLIST(S(JOBNAME))\n RETURN\nEND\n\nEDITN: PROC 2 ASID ASIDC\n SYSREF ASID ASIDC\n SET E = &STR(   &ASID)\n SET L = &LENGTH(&STR(&E))\n SET ASIDC = &SUBSTR(&L-2:&L,&E)\nEND /* EDITN */\n./ ADD NAME=HELPSUB\n\n/**********************************************************************/\n/*                                                                    */\n/* This CLIST displays HELP for a subcommand of a command processor.  */\n/*                                                                    */\n/* Example:  HELP IPCS EVAL                                           */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 2 COMMAND SUBCOMMAND ALL FUNCTION SYNTAX OPERANDS XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nIF &NRSTR(&SUBCOMMAND) = &STR(*) THEN DO\n SET SUBCOMMAND =\n SET ALL        =\n SET FUNCTION   =\n SET SYNTAX     =\n SET OPERANDS   =\nEND\nTSOEXEC TEST 'SYS1.CMDLIB(HELP)' C\nHELP &SUBCOMMAND &ALL &FUNCTION &SYNTAX &OPERANDS\nIF &XTRACE = THEN CONTROL NOMSG\nGET 64 EQ(NEWECT)\nCONTROL MSG\nCOPY 1R?+C? NEWECT L(64)\nCOPY NEWECT 1R?+C P\nNEWECT+C=C'&SUBSTR(1:8,&NRSTR(&COMMAND        ))'\nNEWECT+14=C'&SUBSTR(1:8,&NRSTR(&SUBCOMMAND        ))'\nRUN\n./ ADD NAME=IDUMP\nPROC 1 ADDRESS COUNT() LENGTHVALUE() OFFSET(0) TITLE() ACTIVE XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nIF &LENGTHVALUE = THEN SET LENGTHVALUE = 2147483647\nIF &NRSTR(&TITLE) = THEN SET TITLE = &NRSTR(Instructions at &ADDRESS)\nNOTE SPACE(1)\nEQ TEMP$$$$ &ADDRESS+0 &ACTIVE\nIF &LASTCC = 12 THEN EXIT\nEVALSYM TEMP$$$$ CLIST(ADDRESS(ADDRESS) POSITION(POSITION)) &ACTIVE\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: Unable to evaluate address &ADDRESS' ASIS\n EXIT C(12) Q\nEND\nINTEGER X'&ADDRESS'  SIGNED CLIST(S(V))\nINTEGER X'&POSITION' SIGNED CLIST(S(P))\nINTEGER X'&OFFSET'   SIGNED CLIST(S(O))\nSET V = &V + &P\nNOTE '&TITLE' ASIS\nNOTE SPACE(1)\nSET I = 0\nSET ILENGTH = 1\nLOOP:+\nIF &COUNT = 0 THEN EXIT\nIF &I GE &LENGTHVALUE THEN EXIT\nINTEGER &V PTR CLIST(S(ADDRESS))\nEVAL &ADDRESS.. L(1) UNS CLIST(S(OPCODE)) &ACTIVE\nIF &LASTCC = 12 THEN GOTO ERROR\nIF      &OPCODE LT  64  THEN SET ILENGTH = 2\nELSE IF &OPCODE GE 192  THEN SET ILENGTH = 6\nELSE                         SET ILENGTH = 4\nEVAL &ADDRESS.. L(&ILENGTH) HEX CLIST(S(INSTR)) &ACTIVE\nSET HEXLINE = &SUBSTR(1:32,&INSTR                                 )\nEVAL &ADDRESS.. L(&ILENGTH) CHAR CLIST(S(CHARLINE) ENQUOTE) &ACTIVE\nIF &LASTCC = 12 THEN GOTO ERROR\nSET CHARLINE = &SUBSTR(2:&LENGTH(&NRSTR(&CHARLINE))-1,&NRSTR(&CHARLINE)\nSET CURRENT_OFFSET = &I+&O\nIF &CURRENT_OFFSET < 0 THEN DO\n INTEGER &EVAL(0-(&CURRENT_OFFSET)) PTR(6) CLIST(S(LABEL))\n SET SIGN = &STR(-)\nEND\nELSE DO\n INTEGER &CURRENT_OFFSET PTR(6) CLIST(S(LABEL))\n SET SIGN = &STR(+)\nEND\nINTEGER &V PTR(8) CLIST(S(X))\nNOTE ' &X  &SIGN&LABEL  +\n                        &SUBSTR(1:4,&HEXLINE) +\n                        &SUBSTR(5:8,&HEXLINE) +\n                        &SUBSTR(9:31,&HEXLINE) *+\n                        &NRSTR(&CHARLINE)*' ASIS\nIF &LASTCC ^= 0 THEN EXIT\nSET I = &I + &ILENGTH\nSET V = &V + &ILENGTH\nIF &COUNT ^= THEN SET COUNT = &COUNT - 1\nGOTO LOOP\nERROR:+\nNOTE 'Error: Instructions at &ADDRESS not available (length &ILENGTH)' +\n     ASIS\nEXIT C(12) Q\nEND\n./ ADD NAME=IP\n\n/**********************************************************************/\n/*                                                                    */\n/* This CLIST initiates the ISPF/IPCS dialog.                         */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 0 VOLUME() XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&VOLUME) ^= THEN SET V = VOL(&STR(&VOLUME))\nELSE SET V =\n\n/* Make sure that IPCS CLISTs are allocated.\n\nCONTROL NOFLUSH\nSET SYSOUTTRAP = 999\n%IPBLSTST\nSET RC = &LASTCC\nSET SYSOUTTRAP = 0\nIF &RC ^= 4 THEN DO\n WRITE\n WRITE You cannot use this CLIST because 'SYSPGMR.CMD.CLIST'\n WRITE is not allocated to SYSPROC.  Please fix your XSETUP.\n EXIT C(12)\nEND\nCONTROL FLUSH\n\nIF &SYSISPF = ACTIVE THEN DO\n\n ISPEXEC VGET (ZSCREEN)\n\n /* ALLOC F(BLSPANL&ZSCREEN) DA('SYS1.SBLSPNL0') &V SHR REU\n /* ALLOC F(BLSSKEL&ZSCREEN) DA('SYS1.SBLSKEL0') &V SHR REU\n /* ALLOC F(BLSMSG&ZSCREEN)  DA('SYS1.SBLSMSG0') &V SHR REU\n /* ALLOC F(BLSTABL&ZSCREEN) DA('SYS1.SBLSTBL0') &V SHR REU\n /*\n /* ISPEXEC LIBDEF ISPPLIB LIBRARY ID(BLSPANL&ZSCREEN)\n /* ISPEXEC LIBDEF ISPSLIB LIBRARY ID(BLSSKEL&ZSCREEN)\n /* ISPEXEC LIBDEF ISPMLIB LIBRARY ID(BLSMSG&ZSCREEN)\n /* ISPEXEC LIBDEF ISPTLIB LIBRARY ID(BLSTABL&ZSCREEN)\n\n ISPEXEC SELECT CMD(%IPPRIM &XTRACE) NEWAPPL(ISR) PASSLIB\n\n /* ISPEXEC LIBDEF ISPPLIB\n /* ISPEXEC LIBDEF ISPSLIB\n /* ISPEXEC LIBDEF ISPMLIB\n /* ISPEXEC LIBDEF ISPTLIB\n\nEND\nELSE DO\n XPDF SELECT('CMD(%IP VOL(''&VOLUME'') &XTRACE)')\n /* XCMD ISPSTART CMD(%IP VOL('&VOLUME') &XTRACE)\nEND\n./ ADD NAME=IPBLSTST\n/* ESA version only. */\n/* This returns code 4 if found, code 12 if not found (obviously!). */\nEXIT CODE(4)\n./ ADD NAME=IPCLEAR\n/* REXX */\n   /**************************************************************/\n   /*       Clear SYS1.DUMP without save                         */\n   /**************************************************************/\n trace off\n address ISPEXEC\n \"VGET (IPDSN)\"\n ipact = \"CLEAR\"\n \"DISPLAY PANEL(IPCONF)\"\n if rc \\= 0 then do\n  \"SETMSG MSG(IP001)\"  /* &IPDSN not cleared */\n  exit\n end\n \"SELECT PGM(BLSGSCMD) PARM(SETDEF NODSN)\"\n \"SELECT PGM(BLSGSCMD) PARM(DROPDUMP DSN(\"ipdsn\"))\"\n\n if left(ipdsn,6) = \"'SYS1.\" then do\n  iebcc = ipclrdmp(strip(ipdsn,\"B\",\"'\"))\n  if iebcc = 0 then\n   \"SETMSG MSG(IP002)\"  /* &IPDSN has been cleared */\n  else say \"Clear failed\"\n end\n else do\n  address TSO \"XDELETE\" ipdsn\n  ipccc = rc\n  if ipccc = 0 then\n   \"SETMSG MSG(IP008)\"  /* &IPDSN has been deleted */\n  else\n   \"SETMSG MSG(IP009)\"   /* &IPDSN delete failed, RC=... */\n end\n\n ipdsn = \"\"\n \"VPUT (IPDSN)\"\n\n exit\n\n./ ADD NAME=IPCLRDMP\n/* REXX */\naddress TSO\narg sys1dump\n\n/* Clear out SYS1.DUMP data set. */\n\nsignal on error\n\"ALLOC FI(CLRUT2) DA('\"sys1dump\"') SHR REU\"\n\"ALLOC FI(CLRPRINT) DUMMY REU\"\n\"ALLOC FI(CLRIN) DUMMY REU\"\ncall listdsi \"'\"sys1dump\"'\"\nif length(sysrecfm) > 1 then sysrecfm = spread(sysrecfm)\n\"ALLOC FI(CLRUT1) DUMMY REU DSORG(PS)\",\n       \"RECFM(\"sysrecfm\") LRECL(\"syslrecl\") BLKSIZE(\"sysblksize\")\"\nsignal off error\n\"XINV IEBGENER\",\n    \"SYSPRINT(CLRPRINT) SYSIN(CLRIN) SYSUT1(CLRUT1) SYSUT2(CLRUT2)\"\niebcc = rc\nif iebcc \\= 0 then do\n \"ALLOC FI(CLRPRINT) DA(*) REU\"\n \"XINV IEBGENER\",\n       \"SYSPRINT(CLRPRINT) SYSIN(CLRIN) SYSUT1(CLRUT1) SYSUT2(CLRUT2)\"\n iebcc = rc\nend\n\"FREE FI(CLRUT1,CLRUT2,CLRIN,CLRPRINT)\"\n\n/* Clear out AUTOMATE dump listing. */\n\n\"ALLOC FI(CLRLIST) REU DA('AUTOMATE.\"sys1dump\".IPCSLIST')\"\nif rc = 0 then do\n \"newstack\"\n queue sys1dump \"cleared by\" userid() \"on\" date(\"U\") \"at\" time()\n \"EXECIO 1 DISKW CLRLIST (FINIS\"\n \"delstack\"\n \"FREE FI(CLRLIST)\"\nend\n\nreturn iebcc\n\nspread: parse arg string\nspret = \"\"\ndo i = 1 to length(string)\n spret = spret substr(string,i,1)\nend\nreturn spret\n\nerror:return 12\n./ ADD NAME=IPCMD\nPROC 0\nCONTROL ASIS\nISPEXEC CONTROL DISPLAY LINE START(1)\nWRITE Enter command:\nREAD\nISPEXEC SELECT PGM(BLSGSCMD) PARM(&NRSTR(&SYSDVAL))\nISPEXEC CONTROL DISPLAY REFRESH\n./ ADD NAME=IPCSEXEC\n\n/**********************************************************************/\n/*                                                                    */\n/* Use this CLIST to invoke IPCS subcommands from within ISPF, not    */\n/* necessarily under the IPCS dialog.  Syntax:                        */\n/*                                                                    */\n/* IPCSEXEC CMD('IPCS subcommand')                                    */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 0 CMD()\nCONTROL NOFLUSH NOCAPS\nIF &NRSTR(&CMD) ^= THEN DO\n SET CMD_SUPPLIED = Y\nEND\nELSE DO\n SET CMD_SUPPLIED = N\nEND\nLOOP:+\nIF &CMD_SUPPLIED = N THEN DO\n WRITE IPCSEXEC\n READ\n SET CMD = &NRSTR(&SYSDVAL)\n IF &SYSCAPS(&NRSTR(&CMD)) = END THEN EXIT\nEND\nISPEXEC SELECT PGM(BLSGSCMD) PARM(&NRSTR(&CMD))\nIF &CMD_SUPPLIED = N THEN DO\n GOTO LOOP\nEND\n./ ADD NAME=IPCSTSO\nPROC 0 XTRACE CMD()\nIF &XTRACE=XTRACE THEN CONTROL CONLIST SYMLIST LIST\nGLOBAL ZG0 ZG1 ZG2 ZG3 ZG4 ZG5 ZG6 ZG7 ZG8 ZG9 ZGA ZGB ZGC ZGD ZGE ZGF\nISPEXEC CONTROL DISPLAY LINE\nSET ZSYSDVAL = &NRSTR(&SYSDVAL)\nIF &NRSTR(&CMD) ^= THEN DO\n &NRSTR(&CMD)\n EXIT\nEND\nCONTROL NOFLUSH PROMPT\nERROR DO\n  WRITE *** ERROR - LASTCC = &LASTCC\n  SET ERRORFLAG = 1\n  RETURN\nEND\nLOOP:SET ERRORFLAG = 0\nIF &STR(&SYSSCMD) = END THEN WRITE IPCSTSO\nIF &STR(&SYSPCMD) = IPCS THEN WRITE IPCSTSO\nELSE IF &STR(&SYSSCMD) ^= THEN WRITE IPCSTSO/&SYSPCMD\nELSE IF &STR(&SYSPCMD) = XED      | +\n        &STR(&SYSPCMD) = TESTFORT | +\n        &STR(&SYSPCMD) = ACCOUNT  | +\n        &STR(&SYSPCMD) = OPER     | +\n        &STR(&SYSPCMD) = OPERATOR | +\n        &STR(&SYSPCMD) = ACF      | +\n        &STR(&SYSPCMD) = IPCS     | +\n        &STR(&SYSPCMD) = ECHO     | +\n        &STR(&SYSPCMD) = EDIT     | +\n        &STR(&SYSPCMD) = E        THEN WRITE IPCSTSO/&SYSPCMD\nELSE WRITE IPCSTSO/READY\nSET ZSYSDVAL = &NRSTR(&SYSDVAL)\nREAD\nIF &NRSTR(&SYSDVAL) = &STR(==) THEN DO\n WRITE *** CHANGE OPTIONS IF DESIRED ***\n WRITE &STR(&CMD)                                           /*\n READ\n SET CMD=&NRSTR(&SYSDVAL)\nEND\nIF &NRSTR(&SYSDVAL) = THEN GOTO LOOP\nSET CMDDVAL = &NRSTR(&SYSDVAL)\nIF &SUBSTR(1,&NRSTR(&SYSDVAL )) = ? THEN DO\n WRITE IPCSTSO: NO INFORMATION AVAILABLE\n GOTO LOOP\nEND\nREADDVAL VERB\nIF &NRSTR(&VERB) = END THEN GOTO ENDITALL\nIF &NRSTR(&CMDDVAL) NE &STR(=) THEN SET CMD=&NRSTR(&CMDDVAL)\nSET SYSDVAL = /* CLEAR GLOBAL VARIABLES */\nREADDVAL ZG0 ZG1 ZG2 ZG3 ZG4 ZG5 ZG6 ZG7 ZG8 ZG9 ZGA ZGB ZGC ZGD ZGE ZGF\nSET SYSDVAL = &NRSTR(&ZSYSDVAL)\nIF &STR(&CMD) ^= THEN IF &ERRORFLAG = 0 THEN &CMD\nSET ZSYSDVAL = &NRSTR(&SYSDVAL)\nGOTO LOOP\nENDITALL:+\nIF &ERRORFLAG = 1 THEN GOTO LOOP\nSET SYSDVAL= /* DUMMY STMT TO KILL CLIST NATURALLY */\n./ ADD NAME=IPDCAT\n\n/**********************************************************************/\n/*                                                                    */\n/* This CLIST invokes an ISPF dialog which displays all the datasets  */\n/* ending in DUMP in your catalog.                                    */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 0 APPL(BLSG) XTRACE\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOCAPS\n\n/******************************************************************/\n/* Create table to contain catalog output.                        */\n/******************************************************************/\n\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC TBCREATE IPDCATBL +\n                 KEYS() +\n                 NAMES(DCASEL DCADSN DCAVOL) +\n                 NOWRITE REPLACE\nIF &LASTCC > 4 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n GOTO EXIT\nEND\n\n/******************************************************************/\n/* Get the catalog entries.                                       */\n/******************************************************************/\n\nXLC * SUF(DUMP) VOL NOINFORM DISK WORKDS(&SYSUID..$$IPDCAT.XLCWORK)\n\nALLOC F(XLCWORK) DA('&SYSUID..$$IPDCAT.XLCWORK') REU\n\nOPENFILE XLCWORK\nCONTROL NOFLUSH\nERROR DO\n SET CC = &LASTCC\n IF &CC = 400 THEN GOTO CLOSEIT\n IF &CC < 16 THEN RETURN\n WRITE *** Error in IPDCAT CLIST - LASTCC = &CC\n EXIT Q\nEND\n\n/******************************************************************/\n/* Create a table line for this dump.                             */\n/******************************************************************/\n\nGETLDMP:+\nGETFILE XLCWORK\nSET SYSDVAL = &NRSTR(&XLCWORK)\nREADDVAL JUNKNUMBER ENTRYTYPE DSNAME VOLSER\nIF &STR(&JUNKNUMBER) = THEN GOTO CLOSEIT\nSET CC = 0\nISPEXEC TBVCLEAR IPDCATBL\nIF &CC ^= 0 THEN GOTO REDISP\nSET DCASEL =\nSET DCADSN = &STR(&DSNAME)\nSET DCAVOL = &STR(&VOLSER)\nSET CC = 0\nISPEXEC TBADD IPDCATBL\nIF &CC > 4 THEN DO\n SET CC = 0\n ISPEXEC DISPLAY PANEL(ISPTERM)\n IF &CC > 0 THEN DO\n  WRITE *** Aargh!  Can't even display panel ISPTERM. Is nothing sacred?\n  EXIT Q\n END\n GOTO EXIT\nEND\nGOTO GETLDMP\n\nCLOSEIT:+\nERROR OFF\nCONTROL FLUSH\nCLOSFILE XLCWORK\nFREE F(XLCWORK) /*DELETE\n\n/******************************************************************/\n/* Display the table.                                             */\n/******************************************************************/\n\nREDISP:+\nISPEXEC TBTOP IPDCATBL\nIF &LASTCC ^= 0 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n GOTO EXIT\nEND\nSET TABLECC = 0\nDO WHILE &TABLECC < 8\n IF &TABLECC = 4 THEN DO /* ISPEXEC TBDISPL\n  WRITE Multiple table entries not allowed\n  SET DCASEL =\n  GOTO REDISP\n END\n ISPEXEC TBTOP IPDCATBL\n ISPEXEC TBDISPL IPDCATBL PANEL(IPDCATBL)\n SET TABLECC = &LASTCC\n IF &TABLECC > 8 THEN DO\n  ISPEXEC DISPLAY PANEL(ISPTERM)\n  GOTO EXIT\n END\n IF &TABLECC < 8 THEN DO\n  SET DCASEL = &STR(&SYSCAPS(&DCASEL))\n  IF &DCASEL = THEN DO\n  END\n  ELSE IF &DCASEL = S THEN DO\n   ISPEXEC CONTROL DISPLAY SAVE\n   SET IPDDSN = &STR(&DCADSN)\n   ISPEXEC VPUT (IPDDSN) PROFILE\n   ISPEXEC SELECT CMD(%IPDSN D(&IPDDSN)) NEWAPPL(&APPL) PASSLIB\n   ISPEXEC CONTROL DISPLAY RESTORE\n  END\n  ELSE IF &DCASEL = H THEN DO\n   ISPEXEC CONTROL DISPLAY SAVE\n   HRECALL '&DCADSN' NOWAIT\n   ISPEXEC CONTROL DISPLAY RESTORE\n  END\n  ELSE IF &DCASEL = P THEN DO\n   ISPEXEC CONTROL DISPLAY SAVE\n   ISPEXEC SELECT PGM(BLSGSCMD) NEWAPPL(&APPL) PASSLIB +\n                  PARM(DROPDUMP DSN('&DCADSN'))\n   XDELETE '&DCADSN'\n   SET DELCC = &LASTCC\n   IF &DELCC = 0 THEN DO\n    ISPEXEC TBDELETE IPDCATBL\n    SET IPSMSG = &STR(Dump deleted.)\n    SET IPLMSG = &STR('&DCADSN' has been dropped and deleted.)\n    ISPEXEC SETMSG MSG(IPZ000)\n   END\n   ELSE DO\n    SET IPSMSG = &STR(Delete failed.)\n    SET IPLMSG = &STR(Return code from XDELETE is &DELCC..)\n    ISPEXEC SETMSG MSG(IPZ000)\n   END\n   ISPEXEC CONTROL DISPLAY RESTORE\n  END\n  ELSE DO\n   SET IPSMSG = &STR(Invalid select code)\n   SET IPLMSG = &STR(The only valid selection codes are S, P and H.)\n   ISPEXEC SETMSG MSG(IPZ001)\n  END\n END\nEND\nISPEXEC TBEND IPDCATBL\nEXIT:+\nEXIT\n./ ADD NAME=IPDEB\n\n/**********************************************************************/\n/*                                                                    */\n/* This CLIST invokes an ISPF DIALOG which displays a list of DEB's   */\n/* and their associated DCB's, etc.                                   */\n/*                                                                    */\n/* The positional parameter is a TCB address (see IPTCB).             */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 1 TCBADDR XTRACE\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOFLUSH NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n WRITE *** You must be in IPCS to use this CLIST. ***\n EXIT C(16) Q\nEND\nEVAL &TCBADDR+9 L(3) PTR CLIST(S(DEBADDR))\nIF &LASTCC=12 THEN DO\n NOTE 'IPDEB: Error accessing TCB at &TCBADDR' ASIS\n EXIT C(16) Q\nEND\nIF &DEBADDR = 0 THEN DO\n SET IPSMSG = &STR(NO OPEN DATA SETS)\n SET IPLMSG = &STR(TCB at &TCBADDR has no open data sets.)\n ISPEXEC SETMSG MSG(IPZ001)\n EXIT C(4)\nEND\n/******************************************************************/\n/* Create table to contain DEBs for this TCB                      */\n/******************************************************************/\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC TBCREATE IPDEBTBL +\n        KEYS() +\n        NAMES(DEBSEL DEBEXIT IDBADDR DEBAM DEBOPT +\n              DEBDCB DCBDDN DCBDSN DCBMEM) +\n        NOWRITE REPLACE\nIF &LASTCC > 4 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n GOTO EXIT\nEND\n\n/******************************************************************/\n/* Process all DEBs for this address space                        */\n/******************************************************************/\n\nDO WHILE &DEBADDR^=0\n ISPEXEC TBVCLEAR IPDEBTBL\n EVAL &DEBADDR..-03 LE(1) UNS CLIST(S(DEBAM))\n EVAL &DEBADDR..+0C LE(1) UNS CLIST(S(DEBOPT))\n EVAL &DEBADDR..+19 LE(3) PTR CLIST(S(DEBDCB))\n EVAL &DEBADDR..+01 LE(3) PTR CLIST(S(DEBTCB))\n\n/******************************************************************/\n/* Get stuff from the DEB.                                        */\n/******************************************************************/\n\nIF      &DEBAM =   0 THEN SET DEBAM = UNKNOWN\nELSE IF &DEBAM =   1 THEN SET DEBAM = VSAM\nELSE IF &DEBAM =   2 THEN SET DEBAM = EXCP\nELSE IF &DEBAM =   4 THEN SET DEBAM = TCAM\nELSE IF &DEBAM =   8 THEN SET DEBAM = GAM\nELSE IF &DEBAM =  16 THEN SET DEBAM = BTAM\nELSE IF &DEBAM =  32 THEN SET DEBAM = SAMBPAM\nELSE IF &DEBAM =  64 THEN SET DEBAM = BDAM\nELSE IF &DEBAM = 128 THEN SET DEBAM = ISAM\nELSE IF &DEBAM = 129 THEN SET DEBAM = JES2\nELSE IF &DEBAM = 130 THEN SET DEBAM = VTAM\nELSE IF &DEBAM = 132 THEN SET DEBAM = TCAMAPP\n\nSET DEBOPT = &DEBOPT // 16\nIF      &DEBOPT =  0 THEN SET DEBOPT = INPUT\nELSE IF &DEBOPT = 15 THEN SET DEBOPT = OUTPUT\nELSE IF &DEBOPT =  3 THEN SET DEBOPT = INOUT\nELSE IF &DEBOPT =  7 THEN SET DEBOPT = OUTIN\nELSE IF &DEBOPT =  1 THEN SET DEBOPT = RDBACK\nELSE IF &DEBOPT =  4 THEN SET DEBOPT = UPDAT\n\n/******************************************************************/\n/* Get DCB stuff.                                                 */\n/******************************************************************/\n\nSET TIOTOFFSET =\nSET DCBDDN     =\nSET DCBDSN     =\nSET DCBMEM     =\nSET JFCBADDR   =\n\nEVAL &DEBDCB..+28 LE(2) SIGNED CLIST(S(TIOTOFFSET))\nEQ $TIOTENTRY &DEBTCB..+C?+&TIOTOFFSET.N+0 POS(0) L(20)\nEVAL $TIOTENTRY+4 L(8) CHAR CLIST(S(DCBDDN))\nEVAL $TIOTENTRY+C L(3) PTR CLIST(S(JFCBADDR))\nEQ $JFCB &JFCBADDR..+10 POS(0) L(176)\nEVAL $JFCB+0 L(44) CHAR CLIST(S(DCBDSN))\nEVAL $JFCB+2C L(8) CHAR CLIST(S(DCBMEM))\n\nSET IDBADDR = &STR(&DEBADDR)\n\nISPEXEC TBADD IPDEBTBL\nIF &LASTCC ^= 0 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n EXIT\nEND\n\n/**********************************************************************/\n/*                                                                    */\n/* Determine if another DEB is chained. If so, prepare to process it. */\n/* In any case, set the chain pointer.                                */\n/*                                                                    */\n/**********************************************************************/\n\n EVAL &DEBADDR..+5 LE(3) PTR CLIST(S(DEBADDR))\n IF &LASTCC=12 THEN DO\n  NOTE '==> Error: Next DEB not available from DEB(&DEBADDR)'\n  EXIT C(4)\n END\nEND\n\n/******************************************************************/\n/* Display the table of DEB's.                                   */\n/******************************************************************/\n\nREDISP:+\nISPEXEC TBTOP IPDEBTBL\nIF &LASTCC ^= 0 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n GOTO EXIT\nEND\nSET H1 = &STR(+\n Sel/IPCS Clist //Address  Acsmeth Openopt DCB     Ddname   )\nSET M1 = &STR(+\n _Z+/_DEBEXIT  +//!IDBADDR!DEBAM  !DEBOPT !DEBDCB !DCBDDN   )\nSET H2 = &STR(+\n Sel/IPCS Clist // Ddname   Member   Dsname)\nSET M2 = &STR(+\n _Z+/_DEBEXIT  +//!DCBDDN  !DCBMEM  !DCBDSN)\nSET DEBHEAD = &NRSTR(&H1)\nSET DEBMODL = &NRSTR(&M1)\nSET DEBNUM = 1\nSET TABLECC = 0\nDO WHILE &TABLECC < 8\n IF &TABLECC = 4 THEN DO /* ISPEXEC TBDISPL\n  WRITE Multiple table entries not allowed\n  SET DEBSEL =\n  SET DEBEXIT =\n  GOTO REDISP\n END\n ELSE ISPEXEC TBDISPL IPDEBTBL PANEL(IPDEBTBL)\n SET TABLECC = &LASTCC\n IF &TABLECC > 8 THEN DO\n  ISPEXEC DISPLAY PANEL(ISPTERM)\n  GOTO EXIT\n END\n IF &TABLECC < 8 THEN DO\n  SET DEBSEL  = &STR(&SYSCAPS(&DEBSEL))\n  SET DEBEXIT = &STR(&SYSCAPS(&DEBEXIT))\n  IF &STR(&DEBSEL&DEBEXIT) ^= THEN DO\n   ISPEXEC CONTROL DISPLAY SAVE\n   IF &DEBSEL = THEN DO\n    IF &STR(&DEBEXIT) ^= THEN +\n    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%&DEBEXIT DCB(&DEBDCB..) &XTRACE)\n   END\n   ELSE DO\n    ISPEXEC SETMSG MSG(IPZ002)\n    SET DEBSEL =\n    SET DEBEXIT =\n    GOTO REDISP\n   END\n   ISPEXEC CONTROL DISPLAY RESTORE\n  END\n  IF &NRSTR(&DEBCMD) ^= THEN DO\n   ISPEXEC CONTROL DISPLAY SAVE\n   ISPEXEC SELECT PGM(BLSGSCMD) PARM(&DEBCMD)\n   ISPEXEC CONTROL DISPLAY RESTORE\n  END\n END\nEND\nISPEXEC TBEND IPDEBTBL\nGOTO EXIT\nEXIT:+\nISPEXEC CONTROL DISPLAY REFRESH\nEXIT\n./ ADD NAME=IPDFS\n PROC 0 XTRACE\n IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n ELSE CONTROL NOLIST\n CONTROL NOCAPS\n   /**************************************************************/\n   /*      IPCS Dialogs: Set defaults                            */\n   /**************************************************************/\n ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPDFSI)\n IF &LASTCC < 12 THEN +\n   ISPEXEC VGET (IPDSN IPQUAL IPCON IPDSP IPFLG IPPRI IPTER IPVER)\n IF &LASTCC < 12 THEN DO\n   ISPEXEC DISPLAY PANEL(IPDEF)\n   IF &LASTCC ^= 0 THEN EXIT\n   ISPEXEC SELECT PGM(BLSGSCMD) +\n           PARM(SETDEF &IPQUAL &IPROUTE &IPCNTRL DISPLAY(&IPDSP) NOLIST)\n END\n EXIT\n/***********************************************************************\n/*\n/* Source:\n/*\n/* \"MVS/XA2.1.2 Installation and User's Guide\"\n/* IBM International Systems Centers\n/* GG24-1596-1\n/* (c) Copyright International Business Machines Corporation 1983, 1984\n/*\n/* Page 162\n/*\n/***********************************************************************\n./ ADD NAME=IPDFSI\n PROC 0 XTRACE\n IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n CONTROL NOFLUSH NOCAPS\n   /**************************************************************/\n   /*      IPCS Dialogs: Get current defaults                    */\n   /**************************************************************/\n EVALDEF DIALOG(CONFIRM(IPCON) DISPLAY(IPDSP) FLAG(IPFLG) +\n                PRINT(IPPRI) TERMINAL(IPTER) VERIFY(IPVER))\n IF &LASTCC > 8 THEN EXIT\n EVALDEF DIALOG(QUALIFICATION(IPQUAL))\n IF &LASTCC < 16 THEN SET MAXCC = 0\n ISPEXEC VPUT (IPQUAL IPCON IPDSP IPFLG IPPRI IPTER IPVER) PROFILE\n EXIT\n/***********************************************************************\n/*\n/* Source:\n/*\n/* \"MVS/XA2.1.2 Installation and User's Guide\"\n/* IBM International Systems Centers\n/* GG24-1596-1\n/* (c) Copyright International Business Machines Corporation 1983, 1984\n/*\n/* Page 161\n/*\n/***********************************************************************\n./ ADD NAME=IPDLEVAL\nPROC 1 EDDSN XTRACE\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOCAPS\nEVALDUMP GT DATASET(&EDDSN) +\n         CLIST (BLOCKS(DLDBLKS) BYTES(DLDBYTES) +\n                SOURCE(DLDSRC) QUAL(DLDQUAL))\nSET EVALDUMPCC = &LASTCC\nIF &EVALDUMPCC = 0 THEN DO\n ISPEXEC VPUT (DLDBLKS DLDBYTES DLDSRC DLDQUAL) SHARED\n SET VPUTCC = &LASTCC\n IF &VPUTCC ^= 0 THEN WRITE VPUT returned with code &VPUTCC..\nEND\nEXIT CODE(&EVALDUMPCC)\n./ ADD NAME=IPDLIST\n\n/**********************************************************************/\n/*                                                                    */\n/* This CLIST invokes an ISPF dialog which displays LISTDUMP output.  */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 0 APPL(BLSG) XTRACE\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOCAPS\n\n/******************************************************************/\n/* Create table to contain LISTDUMP output.                       */\n/******************************************************************/\n\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC TBCREATE IPDLDTBL +\n                 KEYS() +\n                 NAMES(DLDSEL DLDDSN DLDQUAL DLDBLKS DLDBYTES) +\n                 NOWRITE REPLACE\nIF &LASTCC > 4 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n GOTO EXIT\nEND\n\n/******************************************************************/\n/* Create a table line for this dump.                             */\n/******************************************************************/\n\nSET EDDSN = '$'\nGETLDMP:+\nISPEXEC TBVCLEAR IPDLDTBL\nISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPDLEVAL &EDDSN)\nIF &LASTCC ^= 0 THEN GOTO REDISP\nISPEXEC VGET (DLDSRC DLDQUAL DLDBLKS DLDBYTES) SHARED\nIF &STR(&DLDSRC) = THEN DO\n WRITE Error: I couldn't get the dump data from IPDLEVAL.\n EXIT\nEND\nIF &SUBSTR(1:6,&DLDSRC      ) = DSNAME THEN DO\n SET DLDDSN = &SUBSTR(8:&LENGTH(&STR(&DLDSRC))-1,&DLDSRC)\nEND\nSET EDDSN = &STR(&DLDDSN)\nSET DLDSEL =\nISPEXEC VPUT (DLDSEL DLDDSN DLDQUAL DLDBLKS DLDBYTES)\nISPEXEC TBADD IPDLDTBL\nIF &LASTCC > 4 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n GOTO EXIT\nEND\nGOTO GETLDMP\n\n/******************************************************************/\n/* Display the table.                                             */\n/******************************************************************/\n\nREDISP:+\nISPEXEC TBTOP IPDLDTBL\nIF &LASTCC ^= 0 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n GOTO EXIT\nEND\nSET TABLECC = 0\nDO WHILE &TABLECC < 8\n IF &TABLECC = 4 THEN DO /* ISPEXEC TBDISPL\n  WRITE Multiple table entries not allowed\n  SET DLDSEL =\n  GOTO REDISP\n END\n ISPEXEC TBTOP IPDLDTBL\n ISPEXEC TBDISPL IPDLDTBL PANEL(IPDLDTBL)\n SET TABLECC = &LASTCC\n IF &TABLECC > 8 THEN DO\n  ISPEXEC DISPLAY PANEL(ISPTERM)\n  GOTO EXIT\n END\n IF &TABLECC < 8 THEN DO\n  SET DLDSEL  = &STR(&SYSCAPS(&DLDSEL))\n  IF &DLDSEL = THEN DO\n  END\n  ELSE IF &DLDSEL = S THEN DO\n   ISPEXEC CONTROL DISPLAY SAVE\n   SET IPDDSN = &STR(&DLDDSN)\n   ISPEXEC VPUT (IPDDSN) PROFILE\n   ISPEXEC SELECT CMD(%IPDSN D(&IPDDSN)) NEWAPPL(&APPL) PASSLIB\n   ISPEXEC CONTROL DISPLAY RESTORE\n  END\n  ELSE IF &DLDSEL = P THEN DO\n   ISPEXEC CONTROL DISPLAY SAVE\n   ISPEXEC SELECT PGM(BLSGSCMD) NEWAPPL(&APPL) +\n                  PARM(SETDEF NODSN) PASSLIB\n   ISPEXEC SELECT PGM(BLSGSCMD) NEWAPPL(&APPL) +\n                  PARM(DROPDUMP DSN(&DLDDSN)) PASSLIB\n   IF &SUBSTR(1:6,&DLDDSN      ) = &STR('SYS1.) THEN DO\n    ALLOC FI(CLRPRINT) DUMMY REU\n    ALLOC FI(CLRIN) DUMMY REU\n    ALLOC FI(CLRUT1) DUMMY REU +\n                     RECFM(F) LRECL(4104) BLKSIZE(4104) DSORG(PS)\n    ALLOC FI(CLRUT2) DA(&DLDDSN) SHR REU\n    XINV IEBGENER +\n         SYSPRINT(CLRPRINT) SYSIN(CLRIN) SYSUT1(CLRUT1) SYSUT2(CLRUT2)\n    SET IEBCC = &LASTCC\n    IF &IEBCC = 0 THEN DO\n     ISPEXEC TBDELETE IPDLDTBL\n     SET IPSMSG = &STR(Dump cleared.)\n     SET IPLMSG = &STR(&DLDDSN has been dropped and cleared.)\n     ISPEXEC SETMSG MSG(IPZ000)\n    END\n    ELSE DO\n     SET IPSMSG = &STR(Clear failed.)\n     SET IPLMSG = &STR(Return code from IEBGENER is &IEBCC..)\n     ISPEXEC SETMSG MSG(IPZ000)\n    END\n    FREE FI(CLRUT1,CLRUT2,CLRIN,CLRPRINT)\n   END\n   ELSE DO\n    IF &XTRACE = THEN CONTROL NOMSG\n    FREE DA(&DLDDSN)\n    CONTROL MSG\n    XDELETE &DLDDSN\n    SET DELCC = &LASTCC\n    IF &DELCC = 0 THEN DO\n     ISPEXEC TBDELETE IPDLDTBL\n     SET IPSMSG = &STR(Dump deleted.)\n     SET IPLMSG = &STR(&DLDDSN has been dropped and deleted.)\n     ISPEXEC SETMSG MSG(IPZ000)\n    END\n    ELSE DO\n     SET IPSMSG = &STR(Delete failed.)\n     SET IPLMSG = &STR(Return code from XDELETE is &DELCC..)\n     ISPEXEC SETMSG MSG(IPZ000)\n    END\n   END\n   ISPEXEC CONTROL DISPLAY RESTORE\n  END\n  ELSE IF &DLDSEL = H THEN DO\n   HRECALL &DLDDSN\n  END\n  ELSE IF &DLDSEL = A THEN DO\n   SET MSGID = IPZ001\n   XDSTAT &DLDDSN NORECALL\n   SELECT &LASTCC\n    WHEN (0) DO\n     SET MSGID = IPZ000\n     SET IPSMSG = &STR(Dataset exists.)\n     SET IPLMSG = &STR(&DLDDSN exists and is online.)\n    END\n    WHEN (4) DO\n     SET IPSMSG = &STR(Member not found.)\n     SET IPLMSG = &STR(&DLDDSN contains a nonexistent member.)\n    END\n    WHEN (8) DO\n     SET IPSMSG = &STR(Dataset not cataloged.)\n     SET IPLMSG = &STR(&DLDDSN was not found in catalog.)\n    END\n    WHEN (12) DO\n     SET IPSMSG = &STR(Volume not available.)\n     SET IPLMSG = &STR(&DLDDSN is on an unavailable DASD volume.)\n    END\n    WHEN (16) DO\n     SET IPSMSG = &STR(Dataset not on DASD.)\n     SET IPLMSG = &STR(&DLDDSN is on a non-DASD device.)\n    END\n    WHEN (20) DO\n     SET IPSMSG = &STR(Dataset not on volume.)\n     SET IPLMSG = &STR(+\n          &DLDDSN is not on the volume specified in the catalog.)\n    END\n    WHEN (24) DO\n     SET IPSMSG = &STR(Dataset not a PDS.)\n     SET IPLMSG = &STR(+\n         &DLDDSN is sequential but a member name is specified.)\n    END\n    WHEN (28) DO\n     SET IPSMSG = &STR(Allocation error.)\n     SET IPLMSG = &STR(Some kind of error occurred wrt &DLDDSN..)\n    END\n    WHEN (32) DO\n     SET IPSMSG = &STR(Invalid dataset name.)\n     SET IPLMSG = &STR(&DLDDSN is a syntactically invalid name.)\n    END\n    WHEN (36) DO\n     SET IPSMSG = &STR(Dataset in use.)\n     SET IPLMSG = &STR(&DLDDSN is in use, cannot verify member name.)\n    END\n    WHEN (40) DO\n     SET IPSMSG = &STR(Dataset is migrated.)\n     SET IPLMSG = &STR(&DLDDSN is migrated.  Use H to HRECALL it.)\n    END\n    OTHERWISE DO\n     SET IPSMSG = &STR(Dataset status unknown.)\n     SET IPLMSG = &STR(XDSTAT returned code of &SYSSELECT for &DLDDSN..)\n    END\n   END\n   ISPEXEC SETMSG MSG(&MSGID)\n  END\n  ELSE DO\n   SET IPSMSG = &STR(Invalid select code)\n   SET IPLMSG = &STR(The only valid selection codes are H,A,S,P.)\n   ISPEXEC SETMSG MSG(IPZ001)\n  END\n END\nEND\nISPEXEC TBEND IPDLDTBL\nEXIT:+\nEXIT\n./ ADD NAME=IPDSCAN\n/* This REXX exec invokes an ISPF dialog which displays SYSDSCAN output.\n   Updated for MVS/ESA. */\naddress TSO\nsignal on halt\nsignal on failure\n/* bug in IPCS/REXX interface... */\n/* parse arg ipcsrexxbugarg             */\n/* \"XPROC IPCSREXXBUGARG 0 APPL(BLSG)\"  */\n\"XPROC 0 APPL(BLSG)\"\nif rc > 0 then exit\nn_appl = appl\ncall outtrap \"line.\"\n\"SYSDSCAN 0:99\"\nsdscc = rc\ncall outtrap \"OFF\"\nmaxlines = line.0\nif sdscc > 4 then do\n say \"*** Error: Return code from SYSDSCAN is\" sdscc\n say \"*** Output follows:\"\n say\n do i = 1 to line.0; say line.i;end\n say\n exit sdscc\nend\n/******************************************************************/\n/* Create table to contain SYSDSCAN output.                       */\n/******************************************************************/\naddress ISPEXEC\nsignal off error\n\"CONTROL ERRORS RETURN\"\n\"TBCREATE IPSDSTBL\",\n         \"KEYS()\",\n         \"NAMES(SDSSEL SDSDUMP SDSDATE SDSTIME SDSTITLE)\",\n         \"NOWRITE REPLACE\"\nif rc > 4 then signal error\nsignal on error\n/******************************************************************/\n/* Inspect all command output.                                    */\n/******************************************************************/\ndo i = 1 to line.0\n /******************************************************************/\n /* Determine if PROFILE MSGID was active.                         */\n /******************************************************************/\n if abbrev(line.i,\"BLS\",3) | ,\n    abbrev(line.i,\"IKJ\",3) then off = 10\n else off = 0\n outline = line.i\n if off > 0 then interpret \"parse var outline prefix\" off+1 \"outline\"\n else prefix = \"\"\n/**********************************************************************/\n/* Check if this is an error message or a dump data set message.      */\n/**********************************************************************/\n if sdscc > 0 then do\n  if abbrev(prefix,\"IKJ\",3) | \\abbrev(outline,\"SYS1\",4) then do\n   if pos(\"NOT IN CATALOG\",outline) = 0 then say prefix || outline\n   iterate i\n  end\n end\n/**********************************************************************/\n/* Check if the dump title goes across lines.                         */\n/**********************************************************************/\n title2 = \"\"\n do while i < line.0\n  nxtline = value(\"line.\" || i+1)\n  if verify(nxtline,\" \") <= 2 then leave\n  i = i + 1\n  title2 = title2 || strip(nxtline)\n end\n/******************************************************************/\n/* Create a table line for this dump.                             */\n/******************************************************************/\n \"TBVCLEAR IPSDSTBL\"\n sdssel = \"\"\n sdsdump = substr(outline,1,11)\n if translate(substr(outline,13,8)) = \"IS EMPTY\" then do\n  sdsdate = \"\"\n  sdstime = \"\"\n  sdstitle = \"---Empty---\"\n end\n else do\n  l = length(outline)\n  sdsdate = substr(outline,14,10)\n  sdstime = substr(outline,25,5) || \" \"\n  if right(strip(outline),1) = \"+\" then\n   sdstitle = strip(substr(outline,32),\"T\",\"+\") || title2\n  else sdstitle = substr(outline,32)\n end\n \"TBADD IPSDSTBL\"\nend i\nredisp:\n\"TBTOP IPSDSTBL\"\ntablecc = 0\ndo while tablecc < 8\n if tablecc = 4 then do /* ISPEXEC TBDISPL */\n  say \"Multiple table entries not allowed\"\n  sdssel =\n  signal redisp\n end\n \"TBTOP IPSDSTBL\"\n signal off error\n \"TBDISPL IPSDSTBL PANEL(IPSDSTBL)\"\n tablecc = rc\n if tablecc > 8 then signal error\n signal on error\n if tablecc < 8 then do\n  upper sdssel\n  if sdssel = \"\" then nop\n  else if sdssel = \"S\" then do\n   if sdsdate = \"\" then do\n    ipsmsg = \"Empty dump dataset\"\n    iplmsg = \"Requested dump dataset is empty, cannot be selected.\"\n    \"SETMSG MSG(IPZ001)\"\n   end\n   else do\n    \"CONTROL DISPLAY SAVE\"\n    ipddsn = \"'\"sdsdump\"'\"\n    \"VPUT (IPDDSN) PROFILE\"\n    parse var sdsdate imonth \"/\" iday    \"/\" iyear\n    parse var sdstime ihour  \":\" iminute \":\" isecond\n    iyear = right(iyear,2)\n    iminute = strip(iminute)\n    if isecond = \"\" then isecond = \"00\"\n    ipnewdsn = sdsdump || \".D\" || iyear || imonth  || iday    || ,\n                          \".T\" || ihour || iminute || isecond || ,\n                          \".DUMP\"\n    /*\n    address TSO\n    \"ALLOC DA(\"ipddsn\")\" ,\n           \"RECFM(F) LRECL(4160) BLKSIZE(4160) DSORG(PS) SHR\"\n    */\n    call tso_command \"%IPDSN D(\"ipddsn\") T(\"ipnewdsn\")\"\n    /* don't mark it processed...\n       sdssel =\n       sdsdate =\n       sdstime =\n       sdstitle = \"---Processed---\"\n       \"tbput ipsdstbl\"\n    */\n    address ISPEXEC\n    \"CONTROL DISPLAY RESTORE\"\n   end\n  end\n  else if sdssel = \"N\" then do\n   if sdsdate = \"\" then do\n    ipsmsg = \"Empty dump dataset\"\n    iplmsg = \"Requested dump dataset is empty, cannot be selected.\"\n    \"SETMSG MSG(IPZ001)\"\n   end\n   else do\n    \"CONTROL DISPLAY SAVE\"\n    ipddsn = \"'\"sdsdump\"'\"\n    \"VPUT (IPDDSN) PROFILE\"\n    call tso_command \"%IPDSN D(\"ipddsn\") NEW\"\n    \"CONTROL DISPLAY RESTORE\"\n   end\n  end\n  else if sdssel = \"P\" then do\n   if sdsdate = \"\" then do\n    ipsmsg = \"Empty dump dataset\"\n    iplmsg = \"Requested dump dataset is empty, cannot be selected.\"\n    \"SETMSG MSG(IPZ001)\"\n   end\n   else do\n    \"CONTROL DISPLAY SAVE\"\n    call ipcs_command \"SETDEF NODSN\"\n    call ipcs_command \"DROPDUMP DSN('\"sdsdump\"')\"\n    iebcc = ipclrdmp(sdsdump)\n    signal on error\n    address ISPEXEC\n    if iebcc = 0 then do\n     sdssel =\n     sdsdate =\n     sdstime =\n     sdstitle = \"---Purged---\"\n     \"TBPUT IPSDSTBL\"\n     ipsmsg = \"Dump cleared.\"\n     iplmsg = \"'\"sdsdump\"' has been dropped and cleared.\"\n     \"SETMSG MSG(IPZ000)\"\n    end\n    else do\n     ipsmsg = \"Clear failed.\"\n     iplmsg = \"Return code from IPCLRDMP exec is \"iebcc\".\"\n     \"SETMSG MSG(IPZ000)\"\n    end\n    \"CONTROL DISPLAY RESTORE\"\n   end\n  end\n  else if sdssel = \"B\" then do\n   \"CONTROL DISPLAY SAVE\"\n   autdsn = \"'AUTOMATE.\"sdsdump\".IPCSLIST'\"\n   signal off error\n   \"BROWSE DATASET(\"autdsn\")\"\n   if rc > 0 then \"DISPLAY PANEL(ISPTERM)\"\n   signal on error\n   \"CONTROL DISPLAY RESTORE\"\n  end\n  else do\n   ipsmsg = \"Invalid select code\"\n   iplmsg = \"Valid selection codes are: S, N, P.\"\n   \"SETMSG MSG(IPZ001)\"\n  end\n end\nend\n\"TBEND IPSDSTBL\"\nexit\n\nerror:\nsignal off error\nif address() = \"ISPEXEC\" then \"DISPLAY PANEL(ISPTERM)\"\nsignal exit\nexit:halt:failure:\nif datatype(sigl,\"W\") then say sourceline(sigl)\": rc=\" rc\nexit\n\ntso_command: arg cmd\naddress ISPEXEC\nsignal off error\n\"SELECT CMD(\"cmd\") NEWAPPL(\"n_appl\") PASSLIB\"\nsignal on error\nreturn\n\nipcs_command: arg cmd\naddress ISPEXEC\nsignal off error\n\"SELECT PGM(BLSGSCMD) NEWAPPL(\"n_appl\") PARM(\"cmd\") PASSLIB\"\nsignal on error\nreturn\n./ ADD NAME=IPDSN\n PROC 0 NEWAPPL(BLSG) DUMPDATASET() TODATASET() SYS1DUMP(Y) NEW XTRACE\n IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n CONTROL NOCAPS\n /*\n /**********************************************************************\n /*      IPCS Dialogs: Open dumpdataset\n /**********************************************************************\n WRITE DUMPDATASET=&STR(&DUMPDATASET)\n IF &STR(&DUMPDATASET) = THEN DO\n  ISPEXEC VGET (IPDSN IPUDD IPFI)\n  SET V = 0\n END\n ELSE DO\n  WRITE V=&V\n  SET IPDSN = &STR('&DUMPDATASET')\n  IF &NEW = NEW THEN SET IPUDD = NO\n  ELSE SET IPUDD = YES\n  SET IPFI =\n END\n SET V = &SYSINDEX(&STR(:),&IPDSN)\n WRITE IPDSN=&STR(&IPDSN)\n WRITE IPUDD=&STR(&IPUDD)\n WRITE IPFI =&STR(&IPFI)\n WRITE V=&V\n IF &STR(&IPDSN) = 1 THEN DO\n   /* active main storage - don't open any dump data set */\n   /* don't ISPEXEC SELECT PGM(BLSGSCMD) PARM(DROPDUMP ACTIVE)\n   SET FILEORDSN = ACTIVE\n END\n ELSE IF &STR(&IPDSN) = 0 THEN DO\n   /* open preallocated file  (DSN not known)\n   SET FILEORDSN = &STR(FILE('&IPFI'))\n END\n ELSE IF &V ^= 0 THEN DO\n   SET VIPVOL = &SUBSTR(1:&V-1,&IPDSN)\n   SET VIPDSN = &SUBSTR(&V+1:&LENGTH(&STR(&IPDSN)),&IPDSN)\n   ALLOC FI(VIPDD) SHR REU DA(&VIPDSN) VOL(&VIPVOL)\n   IF &LASTCC ^= 0 THEN EXIT C(12)\n   SET IPFI = VIPDD\n   SET FILEORDSN = &STR(FILE(&IPFI))\n END\n ELSE IF &SYS1DUMP = N && +\n         &SUBSTR(1:10,&IPDSN          ) = 'SYS1.DUMP THEN DO\n  SET NGTODATASET = &STR(&TODATASET)\n  SET NGNEWAPPL   = &STR(&NEWAPPL)\n  SYSCALL COPY_FROM_SYS1 /* may change IPDSN */\n  IF &LASTCC ^= 0 THEN EXIT C(12)\n END\n ELSE DO\n   /* open by dsname\n   SET FILEORDSN = &STR(DSNAME(&IPDSN))\n END\n IF &STR(&FILEORDSN) = ACTIVE THEN DO\n  ISPEXEC SELECT PGM(BLSGSCMD) PARM(%ACTIVE)\n  SET OPENCC = 0\n END\n ELSE DO\n  ISPEXEC SELECT PGM(BLSGSCMD) PARM(SETDEF &FILEORDSN)\n  IF &IPUDD = NO THEN DO\n    ISPEXEC SELECT PGM(BLSGSCMD) PARM(DROPD &FILEORDSN)\n    ISPEXEC CONTROL DISPLAY LINE\n    ISPEXEC SELECT PGM(BLSGSCMD) PARM(OPEN &FILEORDSN)\n    SET OPENCC = &LASTCC\n    ISPEXEC CONTROL DISPLAY REFRESH\n  END\n  ELSE SET OPENCC = 0\n END\n\n IF &OPENCC ^= 0 THEN EXIT C(&OPENCC)\n\n /**********************************************************************\n /*      Get dumptitle\n /**********************************************************************\n IF &STR(&IPDSN) ^= 1 THEN DO\n   ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPDSNI)\n   ISPEXEC VGET (IPTIT)\n   SET &L = &LENGTH(&NRSTR(&IPTIT))+1\n   IF &L > 65 THEN DO\n     SET IPTIT1 = &SUBSTR(1:65,&NRSTR(&IPTIT))\n     IF &L > 130 THEN +\n         SET IPTIT2 = &SUBSTR(67:130,'&NRSTR(&IPTIT)')\n     ELSE IF &L > 66 THEN +\n         SET IPTIT2 = &SUBSTR(67:&L,'&NRSTR(&IPTIT)')\n     ELSE +\n         SET IPTIT2 = &STR()\n   END\n   ELSE DO\n     SET IPTIT1 = &NRSTR(&IPTIT)\n     SET IPTIT2 =\n   END\n END\n ELSE DO\n   SET IPTIT1 = &STR(NONE)\n   SET IPTIT2 = &STR(      (Active main storage has been requested))\n END\n ISPEXEC VPUT (IPDSN IPTIT1 IPTIT2)\n\n /**********************************************************************\n /*      Get correct ASID\n /**********************************************************************\n\n ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPVASID &XTRACE)\n ISPEXEC VGET (IPASID IPASIDX IPASCB IPJOBN) SHARED\n\n /**********************************************************************\n /*      Display dump-options panel\n /**********************************************************************\n\n ISPEXEC SELECT PANEL(IPDAN)\n\n EXIT C(0)\n\n COPY_FROM_SYS1: PROC 0\n  NGLOBAL NGTODATASET NGNEWAPPL IPDSN\n  SET ERROR = 0\n  SET IPNEWDSN = &STR(&TODATASET)\n  ISPEXEC VPUT (IPNEWDSN)\n  ISPEXEC CONTROL DISPLAY SAVE\n  ISPEXEC DISPLAY PANEL(IPSYS1)  /* sets IPNEWDSN\n  IF &LASTCC ^= 0 THEN EXIT C(12)\n  IF &NRSTR(&IPNEWDSN) ^= &STR() THEN DO\n   XDELETE &IPNEWDSN NOINFORM\n   ISPEXEC SELECT PGM(BLSGSCMD) NEWAPPL(&NEWAPPL) +\n                  PARM(DROPDUMP DSN(&IPDSN)) PASSLIB\n   ALLOC FI(CPYPRINT) DUMMY REU\n   ALLOC FI(CPYIN) DUMMY REU\n   ALLOC FI(CPYUT1) DA(&IPDSN) SHR REU\n   ALLOC FI(CPYUT2) DA(&IPNEWDSN) LIKE(&IPDSN) REU\n   WRITE *** Copy from &IPDSN to &IPNEWDSN in progress\n   XINV IEBGENER +\n        SYSPRINT(CPYPRINT) SYSIN(CPYIN) SYSUT1(CPYUT1) SYSUT2(CPYUT2)\n   IF &LASTCC ^= 0 THEN DO\n    SET IPSMSG = &STR(Copy failed.)\n    SET IPLMSG = &STR(Copy of &IPDSN to &IPNEWDSN unsuccessful.)\n    ISPEXEC SETMSG MSG(IPZ000)\n    SET ERROR = 12\n   END\n   ELSE DO\n    FREE F(CPYPRINT CPYIN CPYUT1 CPYUT2)\n    ALLOC FI(CLRPRINT) DUMMY REU\n    ALLOC FI(CLRIN) DUMMY REU\n    ALLOC FI(CLRUT1) DUMMY REU +\n                     RECFM(F) LRECL(4104) BLKSIZE(4104) DSORG(PS)\n    ALLOC FI(CLRUT2) DA(&IPDSN) SHR REU\n   WRITE *** Clear of &IPDSN in progress\n    XINV IEBGENER +\n         SYSPRINT(CLRPRINT) SYSIN(CLRIN) SYSUT1(CLRUT1) SYSUT2(CLRUT2)\n    SET IEBCC = &LASTCC\n    IF &IEBCC ^= 0 THEN DO\n     SET IPSMSG = &STR(Clear failed.)\n     SET IPLMSG = &STR(Return code from IEBGENER is &IEBCC..)\n     ISPEXEC SETMSG MSG(IPZ000)\n     SET ERROR = 0\n    END\n    FREE FI(CLRUT1,CLRUT2,CLRIN,CLRPRINT)\n    IF &ERROR = 0 THEN DO\n     SET IPDSN = &STR(&IPNEWDSN)\n     SET IPNEWDSN =\n     ISPEXEC VPUT (IPDSN IPNEWDSN)\n    END\n   END\n  END\n  ELSE DO  /* &IPNEWDSN is blank ... */\n   ISPEXEC VPUT (IPDSN IPNEWDSN)\n  END\n  ISPEXEC CONTROL DISPLAY RESTORE\n  SET FILEORDSN = &STR(DSNAME(&IPDSN))\n  RETURN CODE(&ERROR)\n END COPY_FROM_SYS1\n\n/***********************************************************************\n/*\n/* Source:\n/*\n/* \"MVS/XA2.1.2 Installation and User's Guide\"\n/* IBM International Systems Centers\n/* GG24-1596-1\n/* (c) Copyright International Business Machines Corporation 1983, 1984\n/*\n/* Page 159\n/*\n/***********************************************************************\n./ ADD NAME=IPDSNI\n PROC 0 XTRACE\n IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n CONTROL NOCAPS\n   /**************************************************************/\n   /*    Get dumptitle                                           */\n   /**************************************************************/\n EVAL TITLE DIALOG(STORAGE(IPTIT))\n IF &LASTCC = 0 THEN +\n  ISPEXEC VPUT (IPTIT) SHARED\n EXIT\n/***********************************************************************\n/*\n/* Source:\n/*\n/* \"MVS/XA2.1.2 Installation and User's Guide\"\n/* IBM International Systems Centers\n/* GG24-1596-1\n/* (c) Copyright International Business Machines Corporation 1983, 1984\n/*\n/* Page 158\n/*\n/***********************************************************************\n./ ADD NAME=IPFORM\n PROC 0 XTRACE\n IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n CONTROL NOFLUSH NOCAPS\n /**************************************************************/\n /*        Format dump                                         */\n /**************************************************************/\n ISPEXEC VGET (ZTEMPF IPDSN)\n REPEAT:+\n ISPEXEC DISPLAY PANEL(IPFORM)\n IF &LASTCC ^= 0 THEN EXIT\n ISPEXEC VGET (IPD)\n IF &IPD = P THEN DO\n   /**************************************************************/\n   /*        Print formatted dump                                */\n   /**************************************************************/\n   ISPEXEC FTOPEN TEMP\n   ISPEXEC FTINCL IPPRINT\n   ISPEXEC FTCLOSE\n   SUBMIT '&ZTEMPF'\n   ISPEXEC SETMSG MSG(IP005)\n END\n ELSE DO\n   /**************************************************************/\n   /*      Display formatted dump                                */\n   /**************************************************************/\n   SET BS = &STR(ISPEXEC SELECT PGM(BLSGSCMD) PARM)\n   SET NG = &STR(Not valid for display output)\n   IF &STR(.&IPP12)  ^= . THEN DO\n     &BS(VERBEXIT DAEDATA)\n     &BS(VERBEXIT SUMDUMP)\n   END\n   IF .&STR(&IPP1)   ^= . THEN &BS(VERBEXIT ASMDATA)\n   IF .&STR(&IPP2)   ^= . THEN &BS(NOTE 'CPUDATA &NG' ASIS)\n   IF .&STR(&IPP3)   ^= . THEN &BS(VERBEXIT CVTMAP)\n   IF .&STR(&IPP4)   ^= . THEN &BS(VERBEXIT GRSTRACE)\n   IF .&STR(&IPP5)   ^= . THEN &BS(VERBEXIT LOGDATA)\n   IF .&STR(&IPP6)   ^= . THEN &BS(NOTE 'LPAMAP &NG' ASIS)\n   IF .&STR(&IPP7)   ^= . THEN &BS(VERBEXIT MTRACE)\n   IF .&STR(&IPP8)   ^= . THEN &BS(VERBEXIT NUCMAP '&IPSORT')\n   IF .&STR(&IPP9)   ^= . THEN &BS(VERBEXIT RSMDATA)\n   IF .&STR(&IPP10)  ^= . THEN &BS(VERBEXIT SRMDATA)\n   IF .&STR(&IPP11)  ^= . THEN &BS(VERBEXIT VTAMMAP)\n   IF .&STR(&IPIOS)  ^= . THEN &BS(VERBEXIT IOSDATA '&IPIOS')\n   IF .&STR(&IPTRC)  ^= . THEN &BS(VERBEXIT TRACE '&IPTRC')\n   IF .&STR(&IPVSM)  ^= . THEN &BS(VERBEXIT VSMDATA '&IPVSM')\n   IF .&STR(&IPPRT1) ^= . THEN &BS(NOTE 'PRINT keyword &NG' ASIS)\n   IF .&STR(&IPCVT)  ^= . THEN &BS(NOTE 'CVT keyword &NG' ASIS)\n   IF .&STR(&IPSEG)  ^= . THEN &BS(NOTE 'SEGTAB keyword &NG' ASIS)\n END\n GOTO REPEAT\n/***********************************************************************\n/*\n/* Source:\n/*\n/* \"MVS/XA2.1.2 Installation and User's Guide\"\n/* IBM International Systems Centers\n/* GG24-1596-1\n/* (c) Copyright International Business Machines Corporation 1983, 1984\n/*\n/* Page 163\n/*\n/***********************************************************************\n./ ADD NAME=IPHEADER\n PROC 0 XTRACE\n IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n CONTROL NOCAPS\n ISPEXEC SELECT PGM(BLSGSCMD) PARM(%GETASID &XTRACE)\n IF &IPASID = 0 THEN EXIT\n CONTROL NOFLUSH\n ISPEXEC SELECT PGM(BLSGSCMD) PARM(%HEADER &XTRACE)\n./ ADD NAME=IPMOVE\n PROC 0 XTRACE\n IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n CONTROL NOCAPS\n   /****************************************************************/\n   /*  Move dump dataset.  Compare IPSAVE, which saves SYS1 dump   */\n   /****************************************************************/\n ISPEXEC VGET (ZYEAR ZMONTH ZDAY IPSF IPDSN)\n SET IPACT = &STR(Move and clear)\n SET IPSDSCN1 =\n SET IPSDSCN2 =\n IF &SUBSTR(1:10,&IPDSN          ) = 'SYS1.DUMP THEN DO\n  SET SYS1P = T\n  SET SYSOUTTRAP = 2\n  SYSDSCAN &SUBSTR(11:12,&IPDSN            )\n  SET SYSOUTTRAP = 0\n  SET IPSDSCN1 = &NRSTR(&SYSOUTLINE1\n  SET IPSDSCN2 = &NRSTR(&SYSOUTLINE2\n END\n ELSE SET SYS1P = NIL\n ISPEXEC DISPLAY PANEL(IPMOVE)\n IF &LASTCC NE 0 THEN DO\n   ISPEXEC SETMSG MSG(IP003)   /* &IPDSN not cleared */\n   EXIT\n END\n SET SYSDVAL = &STR(&IPSDSN)\n READDVAL IPSDSN  /* Strip quotes */\n IF &STR(&IPSDSN) = THEN DO\n  /*  IPSDSN = &STR(&SYSUID..DUMP&IPSF..D&ZYEAR.&ZMONTH.&ZDAY..SVCDUMP)\n  WRITE Error - no dump dataset name specified.\n  EXIT Q\n END\n ISPEXEC SELECT PGM(BLSGSCMD) +\n                PARM(%IPMOVEIT &IPDSN '&IPSDSN' &SYS1P &XTRACE)\n EXIT\n\n./ ADD NAME=IPMOVEIT\nPROC 3 OLDDSN NEWDSN SYS1P XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS NOFLUSH\nEVALDEF CLIST(SOURCE(SAVESRC))\nERROR GOTO CLEANUP\nSYSCALL DO_IT &OLDDSN &NEWDSN &SYS1P\nCLEANUP: ERROR OFF\nIF &STR(&SAVESRC) = &STR(DSNAME(&OLDDSN)) THEN SETDEF NODSN\nELSE SETDEF &SAVESRC\n\nEXIT\n\nDO_IT: PROC 3 OLDDSN NEWDSN SYS1P\n\n SETDEF DSN(&OLDDSN)\n SYSCALL SAVE_CONTENTS &OLDDSN &NEWDSN\n SETDEF NODSN\n DROPDUMP DSN(&OLDDSN)\n ALLOC DA(&NEWDSN) LIKE(&OLDDSN) CYL SPACE(10 10)\n WRITE Copying &OLDDSN to &NEWDSN\n WRITE\n NOTE SPACE(1)\n NOTE 'Copying '&OLDDSN' to '&NEWDSN'' ASIS\n NOTE SPACE(1)\n COPYDUMP OUTDATASET(&NEWDSN) +\n          INDATASET (&OLDDSN) +\n          NOCONFIRM\n SET COPYDUMPCC = &LASTCC\n SELECT &COPYDUMPCC\n  WHEN (0) DO\n  END\n  OTHERWISE DO\n   SET IPSMSG = &STR(COPYDUMP failed.)\n   SET IPLMSG = &STR(&OLDDSN not copied to &NEWDSN, COPYDUMP +\n                      error code &COPYDUMPCC..)\n   ISPEXEC SETMSG MSG(IPZ000)\n   RETURN CODE(&COPYDUMPCC)\n  END\n END\n SYSCALL RESTORE_CONTENTS &OLDDSN &NEWDSN\n IF &SYS1P = T THEN DO\n  ALLOC FI(CLRPRINT) DUMMY REU\n  ALLOC FI(CLRIN) DUMMY REU\n  ALLOC FI(CLRUT1) DUMMY REU +\n                   RECFM(F) LRECL(4104) BLKSIZE(4104) DSORG(PS)\n  ALLOC FI(CLRUT2) DA(&OLDDSN) SHR REU\n  XINV IEBGENER +\n       SYSPRINT(CLRPRINT) SYSIN(CLRIN) SYSUT1(CLRUT1) SYSUT2(CLRUT2)\n  SET IEBCC = &LASTCC\n  IF &IEBCC = 0 THEN DO\n   SET IPSMSG = &STR(Dump moved.)\n   SET IPLMSG = &STR(&OLDDSN copied to &NEWDSN and cleared.)\n   ISPEXEC SETMSG MSG(IPZ000)\n  END\n  ELSE DO\n   SET IPSMSG = &STR(Copied, not moved.)\n   SET IPLMSG = &STR(&OLDDSN clear failed, IEBGENER code &IEBCC..)\n   ISPEXEC SETMSG MSG(IPZ000)\n  END\n  FREE FI(CLRUT1,CLRUT2,CLRIN,CLRPRINT)\n END\n ELSE DO\n  NOTE SPACE(1)\n  SYSCALL TSO_COMMAND CMD('XDELETE '&OLDDSN'')\n  NOTE SPACE(1)\n  SET DELCC = &LASTCC\n  IF &DELCC = 0 THEN DO\n   SET IPSMSG = &STR(Dump moved.)\n   SET IPLMSG = &STR(&OLDDSN copied to &NEWDSN and deleted.)\n   ISPEXEC SETMSG MSG(IPZ000)\n  END\n  ELSE DO\n   SET IPSMSG = &STR(Copied, not moved.)\n   SET IPLMSG = &STR(&OLDDSN delete failed, XDELETE code &DELCC..)\n   ISPEXEC SETMSG MSG(IPZ000)\n  END\n END\n\nEND DO_IT\n\n\nNGLOBAL TEMP_CLIST_NAME\n\n\nSAVE_CONTENTS: PROC 2 OLDDSN NEWDSN\n\nEVALDEF CLIST(DECIMAL +\n              CONFIRM      (EVALDEFCONFIRM      ) +\n              DISPLAY      (EVALDEFDISPLAY      ) +\n              DATASET      (EVALDEFDATASET      ) +\n              FLAG         (EVALDEFFLAG         ) +\n              LENGTH       (EVALDEFLENGTH       ) +\n              PRINT        (EVALDEFPRINT        ) +\n              PROBLEM      (EVALDEFPROBLEM      ) +\n              QUALIFICATION(EVALDEFQUALIFICATION) +\n              TERMINAL     (EVALDEFTERMINAL     ) +\n              TEST         (EVALDEFTEST         ) +\n              VERIFY       (EVALDEFVERIFY       ) +\n             )\n\nSET TEMP_CLIST_NAME = &STR('&SYSUID..$$$$TEMP.IPMOVE.CLIST')\nSET STAT = &SYSDSN(&TEMP_CLIST_NAME)\nIF &STAT = OK THEN SET DISP = OLD\nELSE SET DISP = NEW\nALLOC F(IPSVDUMP) DA(&TEMP_CLIST_NAME) T SP(50 50) &DISP REU +\n      RECFM(V B) LRECL(255) BLKSIZE(6233) DSORG(PS)\nOPENFILE IPSVDUMP OUTPUT\nCONTROL NOFLUSH\nERROR DO\n SET CC = &LASTCC\n IF &CC = 12 AND &MIGHTFAIL = Y THEN RETURN\n WRITE Error processing IPCS subcommand &SYSSCMD - return code &CC\n WRITENR Continue ((Y)/N) ?\n CONTROL CAPS\n READ ANS\n CONTROL NOCAPS\n IF &ANS = N THEN GOTO DIE\n ELSE RETURN\nEND\nSET IPSVDUMP = &STR(PROC 0 XTRACE)\nPUTFILE IPSVDUMP\nSET IPSVDUMP = &STR(+\n               IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST)\nPUTFILE IPSVDUMP\nSET IPSVDUMP = &STR(CONTROL NOCAPS NOFLUSH)\nPUTFILE IPSVDUMP\nSET IPSVDUMP = &STR(SETDEF DSN(&NEWDSN) &EVALDEFQUALIFICATION +)\nPUTFILE IPSVDUMP\nSET IPSVDUMP = &STR(+\n           &EVALDEFCONFIRM +\n           DISPLAY(&EVALDEFDISPLAY) +\n           FLAG(&EVALDEFFLAG) +\n           LENGTH(&EVALDEFLENGTH) +\n           &EVALDEFPRINT +\n           &EVALDEFPROBLEM +\n           &EVALDEFTERMINAL +\n           &EVALDEFTEST +\n           &EVALDEFVERIFY +\n  )\nPUTFILE IPSVDUMP\nSET EVALSYMBOL = @\nSET GE = &STR(GE)\nLOOP:+\nCONTROL LIST\nSET CC = 0\nSET MIGHTFAIL = Y\nEVALSYM &GE &EVALSYMBOL +\n        CLIST(HEXADECIMAL +\n              ADDRESS      (EVALSYMADDRESS      ) +\n              SYMBOL       (EVALSYMSYMBOL       ) +\n             )\nIF &CC = 0 THEN DO\n SET MIGHTFAIL = N\n EVALSYM &EVALSYMSYMBOL +\n         CLIST(DECIMAL +\n               DATATYPE     (EVALSYMDATATYPE     ) +\n               DIMENSION    (EVALSYMDIMENSION    ) +\n               DROP         (EVALSYMDROP         ) +\n               ENTRY        (EVALSYMENTRY        ) +\n               LENGTH       (EVALSYMLENGTH       ) +\n               POSITION     (EVALSYMPOSITION     ) +\n               QUALIFICATION(EVALSYMQUALIFICATION) +\n               REMARK       (EVALSYMREMARK       ) +\n              )\n SELECT &STR(&EVALSYMSYMBOL &EVALSYMDROP)\n  WHEN (COMMON NODROP   | CVT NODROP   | GDA NODROP| PRIVATE NODROP +\n      | PRIVATEX NODROP | TITLE NODROP | X NODROP  | X DROP) DO\n\n   NOTE 'Skipping '&OLDDSN' ==> &EVALSYMSYMBOL' ASIS\n  END\n  OTHERWISE DO\n   IF &NRSTR(&EVALSYMREMARK) ^= THEN DO\n    SET FUCK_ME_HARDER = &NRSTR(&EVALSYMREMARK)\n/*  SYSCALL QUOTIFY FUCK_ME_HARDER\n    SET EVALSYMREMARK = &NRSTR(&FUCK_ME_HARDER)\n    SET REMARK = &NRSTR(REMARK('&EVALSYMREMARK'))\n   END\n   ELSE +\n    SET REMARK =\n   IF &NRSTR(&EVALSYMDIMENSION) > 0 THEN +\n    SET DIMENSION = &NRSTR(DIMENSION(&EVALSYMDIMENSION))\n   ELSE +\n    SET DIMENSION =\n   SET IPSVDUMP = &STR(+\n       NOTE 'Restoring '&NEWDSN' ==> &EVALSYMSYMBOL' ASIS)\n   PUTFILE IPSVDUMP\n   SET IPSVDUMP = &STR(+\n    EQ &EVALSYMSYMBOL &EVALSYMADDRESS.. +\n       &EVALSYMDATATYPE +\n       &DIMENSION +\n       &EVALSYMDROP +\n       ENTRY(&EVALSYMENTRY) +\n       LENGTH(&EVALSYMLENGTH) +\n       POSITION(&EVALSYMPOSITION) +\n       &QUALIFICATION +\n       &NRSTR(&REMARK) +\n      )\n   PUTFILE IPSVDUMP\n   NOTE 'Saving   '&OLDDSN' ==> &EVALSYMSYMBOL' ASIS\n  END\n END\n SET EVALSYMBOL = &NRSTR(&EVALSYMSYMBOL)\n SET GE = &STR(GT)\n GOTO LOOP\nEND\nRETURN:+\nCONTROL NOCONLIST NOSYMLIST\nERROR OFF\nCLOSFILE IPSVDUMP\nTSO FREE F(IPSVDUMP)\nRETURN\nDIE:+\nWRITE DYING...\nERROR OFF\nCLOSFILE IPSVDUMP\nTSO FREE F(IPSVDUMP)\nEXIT CODE(16)\n\nEND SAVE_CONTENTS\n\n\nRESTORE_CONTENTS: PROC 2 OLDDSN NEWDSN\n\n EXEC &TEMP_CLIST_NAME '&XTRACE'\n\nEND RESTORE_CONTENTS\n\n\nTSO_COMMAND: PROC 0 CMD()\n\n SET CMDL = &NRSTR(&CMD)\n SYSCALL QUOTIFY CMDL\n/*                                                */\n/* SET TSOANS = &STR()                            */\n/* DO WHILE &TSOANS ^= Y && &TSOANS ^= N          */\n/*  WRITENR &NRSTR(&CMDL) (Y/N) ?                 */\n/*  READ TSOANS                                   */\n/*  IF &NRSTR(&TSOANS) = N THEN RETURN CODE(0)    */\n/*  IF &NRSTR(&TSOANS) ^= Y THEN DO               */\n/*   WRITE WHAT?                                  */\n/*  END                                           */\n/* END                                            */\n/*                                                */\n NOTE '&NRSTR(&CMDL)' ASIS\n SET SYSOUTTRAP = 32767\n &NRSTR(&CMD)\n SET RC = &LASTCC\n DO I = 1 TO &SYSOUTLINE\n  SET LINE = &SYSNSUB(2,&&SYSOUTLINE&I)\n  SYSCALL QUOTIFY LINE\n  NOTE '&NRSTR(&LINE)' ASIS\n END\n SET SYSOUTTRAP = 0\n RETURN CODE(&RC)\n\nEND TSO_COMMAND\n\nQUOTIFY: PROC 1 IN\nSYSREF IN\nIF &SYSINDEX(',&NRSTR(&IN)) = 0 THEN DO\n RETURN\nEND\nSET L = &LENGTH(&NRSTR(&IN))\nDO N = 1 TO &L\n SET C = &SUBSTR(&N,&NRSTR(&IN))\n IF &NRSTR(&C) = ' THEN DO\n  SET OUT = &NRSTR(&OUT)''\n END\n ELSE SET OUT = &NRSTR(&OUT&C)\nEND\nSET IN = &NRSTR(&OUT)\nRETURN\n\nEND QUOTIFY\n\n./ ADD NAME=IPPRIM\n/**********************************************************************/\n/*                                                                    */\n/*                  IPCS Dialogs Initialization                       */\n/*                                                                    */\n/* PFK settings are in 'SYSPGMR.CMD.TABLE(IPCSPROF)', so they         */\n/* do not have to be set here.  This enables this CLIST to run under  */\n/* APPLID ISR, so ZTRAIL can be passed from the selection menu.       */\n/*                                                                    */\n/**********************************************************************/\n PROC 0 APPL(BLSG) XTRACE\n IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n CONTROL NOFLUSH NOCAPS\n ISPEXEC VGET (ZTRAIL) SHARED\n ISPEXEC SELECT +\n     PGM(BLSG) +\n     PARM(CMD(%IPPRIM2 O('&ZTRAIL') &XTRACE) NEWAPPL(&APPL) PASSLIB) +\n     NEWAPPL(&APPL) +\n     PASSLIB\n SET MYCC = &LASTCC\n IF &MYCC > 4 THEN DO\n  ISPEXEC DISPLAY PANEL(IPERROR)\n  EXIT\n END\n EXIT\n/***********************************************************************\n/*\n/* Source:\n/*\n/* \"MVS/XA2.1.2 Installation and User's Guide\"\n/* IBM International Systems Centers\n/* GG24-1596-1\n/* (c) Copyright International Business Machines Corporation 1983, 1984\n/*\n/* Page 158\n/*\n/***********************************************************************\n./ ADD NAME=IPPRIM2\nPROC 0 OPT() XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nIF &STR(&OPT) ^= THEN SET OPT = &STR( OPT(&OPT))\nELSE SET OPT =\nISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPPRIM3 &XTRACE)\nISPEXEC VGET (IPDDSN) SHARED\nIF &SUBSTR(1:7,&IPDDSN       ) = &SUBSTR(1:7,DSNAME()) THEN DO\n SET SYSDVAL = &SUBSTR(7:&LENGTH(&STR(&IPDDSN)),&IPDDSN)\n READDVAL IPDDSN\nEND\nELSE SET IPDDSN =\nISPEXEC VPUT (IPDDSN) SHARED\nISPEXEC SELECT PANEL(IPPRIM)&OPT\nEXIT\n./ ADD NAME=IPPRIM3\nPROC 0 XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nEVALDEF DIALOG(SOURCE(IPDDSN))\nISPEXEC VPUT (IPDDSN) SHARED\nEXIT\n./ ADD NAME=IPRB\n\n/**********************************************************************/\n/*                                                                    */\n/* This CLIST invokes an ISPF dialog which displays a list of RB's.   */\n/*                                                                    */\n/* The positional parameter is a TCB address (see IPTCB).             */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 1 TCBADDR XTRACE\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOFLUSH NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n WRITE *** You must be in IPCS to use this CLIST. ***\n EXIT C(16) Q\nEND\nEVAL &TCBADDR+1 L(3) PTR CLIST(S(RBADDR))\nIF &LASTCC=12 THEN DO\n NOTE 'IPRB: Error accessing TCB at &TCBADDR' ASIS\n EXIT C(16) Q\nEND\n/******************************************************************/\n/* Create table to contain RBs for this TCB                       */\n/******************************************************************/\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC TBCREATE IPRBTBL +\n        KEYS() +\n        NAMES(IRBSEL IRBEXIT IRBADDR IRBTYPE +\n              IRBNAME IRBINT IRBPSW1 IRBPSW2 IRBWHERE +\n              IRBREG0 IRBREG1 IRBREG2 IRBREG3 IRBREG4 IRBREG5 +\n              IRBREG6 IRBREG7 IRBREG8 IRBREG9 IRBREGA IRBREGB +\n              IRBREGC IRBREGD IRBREGE IRBREGF) +\n        NOWRITE REPLACE\nIF &LASTCC > 4 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n GOTO EXIT\nEND\n\n/******************************************************************/\n/* Process all RBs for this address space                         */\n/******************************************************************/\n\nDO WHILE &RBADDR^=0\n ISPEXEC TBVCLEAR IPRBTBL\n INTEGER X'&RBADDR' PTR DIALOG(S(IRBADDR))\n EVAL &RBADDR..-01 LE(1) HEX DIALOG(S(IRBINT))\n EVAL &RBADDR..+10 LE(4) PTR DIALOG(S(IRBPSW1))\n EVAL &RBADDR..+14 LE(4) PTR DIALOG(S(IRBPSW2))\n\n /******************************************************************/\n /* Figure out the RB type.                                        */\n /******************************************************************/\n\n  COMPARE ADDR(&RBADDR..+A) LE(1) +\n          WITH(VALUE(X'00')) MASK(X'E0')        /* Is it a PRB?\n  IF &LASTCC = 0 THEN +\n   SET IRBTYPE = PRB\n  ELSE DO\n   COMPARE ADDR(&RBADDR..+A) LE(1) +\n           WITH(VALUE(X'C0')) MASK(X'E0')        /* Is it an SVRB?\n   IF &LASTCC = 0 THEN +\n    SET IRBTYPE = SVRB\n   ELSE DO\n    COMPARE ADDR(&RBADDR..+A) LE(1) +\n            WITH(VALUE(X'60')) MASK(X'E0')        /* Is it a TIRB?\n    IF &LASTCC = 0 THEN +\n     SET IRBTYPE = TIRB\n    ELSE DO\n     COMPARE ADDR(&RBADDR..+A) LE(1) +\n             WITH(VALUE(X'40')) MASK(X'E0')        /* Is it an IRB?\n     IF &LASTCC = 0 THEN +\n      SET IRBTYPE = IRB\n     ELSE DO\n      COMPARE ADDR(&RBADDR..+A) LE(1) +\n              WITH(VALUE(X'80')) MASK(X'E0')        /* Is it an SIRB?\n      IF &LASTCC = 0 THEN +\n       SET IRBTYPE = SIRB\n      ELSE +\n       SET IRBTYPE = ???\n    END\n   END\n  END\n END\n\n/**********************************************************************/\n/*                                                                    */\n/* Resolve the PSW address.                                           */\n/*                                                                    */\n/**********************************************************************/\n\n SYSCALL IPRBWHR &IRBPSW2\n ISPEXEC VGET (IRBWHERE)\n\n /******************************************************************/\n /* Try to get a module name to identify this RB.                  */\n /******************************************************************/\n\n SET IRBNAME = &STR(********)\n\n /* To extract the CDE module name, RB must be a PRB, else no sale. */\n\nGETCDE:+\n COMPARE ADDRESS(&RBADDR..+A) LENGTH(1) WITH(VALUE(X'00')) MASK(X'E0')\n IF &LASTCC = 0 THEN DO\n  EVAL &RBADDR..+D LE(3) PTR CLIST(S(CDEADDR))\n  IF &CDEADDR ^= 0 THEN DO\n   EVAL &CDEADDR..+8 LE(8) CHAR CLIST(S(IRBNAME))\n  END\n END\n\n/**********************************************************************/\n/*                                                                    */\n/* Get the registers.                                                 */\n/*                                                                    */\n/**********************************************************************/\n\n EVAL &RBADDR..+20 L(4) HEX CLIST(S(IRBREG0))\n EVAL &RBADDR..+24 L(4) HEX CLIST(S(IRBREG1))\n EVAL &RBADDR..+28 L(4) HEX CLIST(S(IRBREG2))\n EVAL &RBADDR..+2C L(4) HEX CLIST(S(IRBREG3))\n EVAL &RBADDR..+30 L(4) HEX CLIST(S(IRBREG4))\n EVAL &RBADDR..+34 L(4) HEX CLIST(S(IRBREG5))\n EVAL &RBADDR..+38 L(4) HEX CLIST(S(IRBREG6))\n EVAL &RBADDR..+3C L(4) HEX CLIST(S(IRBREG7))\n EVAL &RBADDR..+40 L(4) HEX CLIST(S(IRBREG8))\n EVAL &RBADDR..+44 L(4) HEX CLIST(S(IRBREG9))\n EVAL &RBADDR..+48 L(4) HEX CLIST(S(IRBREGA))\n EVAL &RBADDR..+4C L(4) HEX CLIST(S(IRBREGB))\n EVAL &RBADDR..+50 L(4) HEX CLIST(S(IRBREGC))\n EVAL &RBADDR..+54 L(4) HEX CLIST(S(IRBREGD))\n EVAL &RBADDR..+58 L(4) HEX CLIST(S(IRBREGE))\n EVAL &RBADDR..+5C L(4) HEX CLIST(S(IRBREGF))\n\n/**********************************************************************/\n/*                                                                    */\n/* Add this RB info to the table.                                     */\n/*                                                                    */\n/**********************************************************************/\n\n ISPEXEC TBADD IPRBTBL\n IF &LASTCC > 4 THEN DO\n  ISPEXEC DISPLAY PANEL(ISPTERM)\n  GOTO EXIT\n END\n\n/**********************************************************************/\n/*                                                                    */\n/* Determine if another RB is chained.  If so, prepare to process it. */\n/* In any case, set the chain pointer.                                */\n/*                                                                    */\n/**********************************************************************/\n\n COMPARE ADDR(&RBADDR..+B) LE(1) +\n         WITH(VALUE(X'80')) MASK(X'80') /* Does NEXTRB point to TCB?\n IF &LASTCC = 0 THEN DO\n  SET RBADDR = &STR(000000)\n END\n ELSE DO\n  EVAL &RBADDR..+1D LE(3) PTR CLIST(S(RBADDR))\n  IF &LASTCC=12 THEN DO\n   NOTE '==> Error: Next RB not available from RB(&RBADDR)'\n   EXIT C(4)\n  END\n END\nEND\n\n/******************************************************************/\n/* Display the table of RB's.                                    */\n/******************************************************************/\n\nREDISP:+\nISPEXEC TBTOP IPRBTBL\nIF &LASTCC ^= 0 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n GOTO EXIT\nEND\nSET TABLECC = 0\nDO WHILE &TABLECC < 8\n IF &TABLECC = 4 THEN DO /* ISPEXEC TBDISPL\n  WRITE Multiple table entries not allowed\n  SET IRBSEL =\n  SET IRBEXIT =\n  GOTO REDISP\n END\n ELSE ISPEXEC TBDISPL IPRBTBL PANEL(IPRBTBL)\n SET TABLECC = &LASTCC\n IF &TABLECC > 8 THEN DO\n  ISPEXEC DISPLAY PANEL(ISPTERM)\n  GOTO EXIT\n END\n IF &TABLECC < 8 THEN DO\n  SET IRBSEL  = &STR(&SYSCAPS(&IRBSEL))\n  SET IRBEXIT = &STR(&SYSCAPS(&IRBEXIT))\n  IF &STR(&IRBSEL&IRBEXIT) ^= THEN DO\n   ISPEXEC CONTROL DISPLAY SAVE\n   IF &IRBSEL = THEN DO\n    IF &STR(&IRBEXIT) ^= THEN +\n    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%&IRBEXIT RB(&IRBADDR..) &XTRACE)\n   END\n   ELSE DO\n    ISPEXEC SETMSG MSG(IPZ002)\n    SET IRBSEL =\n    SET IRBEXIT =\n    GOTO REDISP\n   END\n   ISPEXEC CONTROL DISPLAY RESTORE\n  END\n  IF &NRSTR(&IRBCMD) ^= THEN DO\n   ISPEXEC CONTROL DISPLAY SAVE\n   ISPEXEC SELECT PGM(BLSGSCMD) PARM(&IRBCMD)\n   ISPEXEC CONTROL DISPLAY RESTORE\n  END\n END\nEND\nISPEXEC TBEND IPRBTBL\nGOTO EXIT\nEXIT:+\nISPEXEC CONTROL DISPLAY REFRESH\nEXIT\n\nIPRBWHR:PROC 1 ADDRESS\n\n/******************************************************************/\n/*                                                                */\n/* Process an RB PSW address.                                     */\n/*                                                                */\n/* This is done by means of executing a TCB exit routine that     */\n/* determines the load module and offset, returning it in ISPF    */\n/* variables VITPLACE, VITNAME and VITLOC.                        */\n/*                                                                */\n/******************************************************************/\n\n SET I = &SYSINDEX(&SUBSTR(1,&ADDRESS),89ABCDEF)\n IF &I ^= 0 THEN +\n  SET ADDRESS = &SUBSTR(&I,01234567)&SUBSTR(2:8,&ADDRESS)\n TCBEXIT VITWHR &ADDRESS..\n IF &LASTCC ^= 0 THEN DO\n  WRITE Error: TCB exit VITWHR unable to process address &ADDRESS..\n  SET IRBWHERE = &STR(*ERROR*)\n END\n ELSE DO\n  ISPEXEC VGET (VITNAME VITPLACE VITLOC VITOFF) SHARED\n  SET VGETCC = &LASTCC\n  IF &VGETCC ^= 0 THEN DO\n   WRITE Error: Return code from VGET was &VGETCC..\n   SET IRBWHERE = &STR(*ERROR*)\n  END\n  ELSE IF &NRSTR(&VITNAME) = UNAVAILABLE THEN DO\n   SET IRBWHERE = UNAVAILABLE\n  END\n  ELSE DO\n   SET IRBWHERE = &SUBSTR(1:8,&VITNAME        )&STR(+&VITOFF)\n  END\n END\n ISPEXEC VPUT (IRBWHERE)\n\nEND IPRBWHR\n\n./ ADD NAME=IPSHOW\nPROC 1 EXPRESSION\nCONTROL NOCAPS\nTCBEXIT YITADDR &NRSTR(&EXPRESSION) POSITION(+0)\nIF &LASTCC = 0 THEN DO\n WRITE &NRSTR(&EXPRESSION) is at &YITHEX..\nEND\nELSE DO\n WRITE Erroneous address: &NRSTR(&EXPRESSION)\nEND\nEXIT\n./ ADD NAME=IPTBDISP\nPROC 1 TBPREF +\n       THING(TCB) +\n       ADDRESS(UNKNOWN) +\n       EXTRA() +\n       SCOMMAND('%IPTBDUM') +\n       SEL(&TBPREF.SEL) TABLE(&TBPREF.TBL) PANEL(&TABLE.) +\n       XTRACE\n/**********************************************************************/\n/* General-purpose IP... table displayer                              */\n/**********************************************************************/\n\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nDISP:+\nISPEXEC CONTROL ERRORS CANCEL\nISPEXEC TBTOP &TABLE\nREDISP:+\nSET TABLECC = 0\nDO WHILE &TABLECC < 8\n IF &TABLECC = 4 THEN DO\n  ISPEXEC SETMSG MSG(IPZ003)\n  GOTO REDISP\n END\n ELSE DO\n  ISPEXEC TBDISPL &TABLE PANEL(&PANEL)\n END\n SET TABLECC = &LASTCC\n IF &TABLECC < 8 THEN DO\n  IF &NRSTR(&TBLCMD) ^= THEN SYSCALL SUBCOMMAND TBLCMD\n  SET &&SEL =\n END\n IF &NRSTR(&ZCMD) ^= THEN SYSCALL SUBCOMMAND ZCMD\n SET ZCMD =\nEND\nISPEXEC TBEND &TABLE\nISPEXEC CONTROL DISPLAY REFRESH\nEXIT\n\nSUBCOMMAND: PROC 1 CMD\n SYSREF CMD\n ISPEXEC CONTROL DISPLAY SAVE\n ISPEXEC CONTROL ERRORS RETURN\n ISPEXEC SELECT PGM(BLSGSCMD) PARM(&NRSTR(&CMD))\n ISPEXEC CONTROL ERRORS CANCEL\n ISPEXEC CONTROL DISPLAY RESTORE\n RETURN\nEND\n./ ADD NAME=IPTCB\n\n/**********************************************************************/\n/*                                                                    */\n/* This CLIST invokes an ISPF dialog which displays a list of TCB's.  */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 0 XTRACE\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n WRITE *** You must be in IPCS to use this CLIST. ***\n EXIT C(16) Q\nEND\n\n/**********************************************************************/\n/*                                                                    */\n/* Get the desired ASID.                                              */\n/*                                                                    */\n/**********************************************************************/\n\n%GETASID &XTRACE\nSET ASID = &LASTCC\nINTEGER &ASID PTR(4) CLIST(S(ASIDX))\nINTEGER &ASID UNS    CLIST(S(ASIDN))\n\n/*  EVAL 224. PTR CLIST(S(ASCBADDR))\n/*  IF &LASTCC ^= 0 THEN DO\n/*   NOTE '==> Error: ASCB address not available at 224.' ASIS\n/*   EXIT C(16) Q\n/*  END\n\n/**********************************************************************/\n/*                                                                    */\n/* Get the ASCB for this ASID.  Note that instead of using the PSA's  */\n/* ASCBNEW or ASCBOLD pointer, we use the ASID to index into the ASVT */\n/* to find it.  In that way you can map the TCB chain from the ASID   */\n/* that you requested using SETDEF.                                   */\n/*                                                                    */\n/**********************************************************************/\n\nCONTROL NOFLUSH\nEVALSYM CVT\nIF &LASTCC = 12 THEN DO\n EQ CVT 10.%\nEND\n\nEVAL CVT+22C L(4) PTR CLIST(S(ASVTADDR))\nEVAL 10.%+22C L(4) PTR CLIST(S(ASVTADDR))\nIF &LASTCC ^= 0 THEN DO\n NOTE '==> Error: ASVT address not available from CVT+22C' ASIS\n EXIT C(16) Q\nEND\nEVAL &ASVTADDR..+204 L(4) UNS CLIST(S(ASVTMAXU))\nIF &LASTCC ^= 0 THEN DO\n NOTE '==> Error: ASVTMAXU not available from ASVT at &ASVTADDR' ASIS\n EXIT C(16) Q\nEND\nIF &ASIDN > &ASVTMAXU THEN DO\n NOTE '==> Error: ASID &ASID is invalid, greater than maximum' ASIS\n EXIT C(16) Q\nEND\nSET ASVTOFFS = &ASIDN*4\nEVAL &ASVTADDR..+20C+&ASVTOFFS.N L(4) PTR CLIST(S(ASCBADDR))\nIF &LASTCC ^= 0 THEN DO\n NOTE '==> Error: ASCB address not available at 224.' ASIS\n EXIT C(16) Q\nEND\nSELECT &SUBSTR(1,&ASCBADDR)\n WHEN (8|9|A|B|C|D|E|F) DO\n  NOTE '==> Error: ASID &ASID is not assigned.' ASIS\n  EXIT C(16) Q\n END\nEND\n\nEVAL &ASCBADDR..+AC L(4) PTR CLIST(S(JOBNAMEADDR))\nIF &STR(&JOBNAMEADDR) = &STR(00000000) THEN DO\n EVAL &ASCBADDR..+B0 L(4) PTR CLIST(S(JOBNAMEADDR))\nEND\nEVAL &JOBNAMEADDR.. L(8) CHAR CLIST(S(JOBNAME))\n\nEVAL &ASCBADDR..+6C PTR CLIST(S(ASXBADDR))\nIF &LASTCC=12 THEN DO\n NOTE '==> Error: ASXB not available for ASID(&ASID)' ASIS\n EXIT C(16) Q\nEND\nSET TCBCTR = 1\nEVAL &ASXBADDR..+5 LE(3) PTR CLIST(S(TCBADDR))\nIF &LASTCC=12 THEN DO\n L &ASXBADDR..+5 LE(3) PTR\n NOTE '==> Error: TCB&TCBCTR not available for ASID(&ASID)' ASIS\n EXIT C(16) Q\nEND\n\n/******************************************************************/\n/* Create table to contain TCBs for this address space            */\n/******************************************************************/\n\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC TBCREATE IPTCBTBL +\n                 KEYS() +\n                 NAMES(ITTSEL ITTEXIT ITTADDR ITTNAME +\n                       ITTSTUFF +\n                       ITTCOMP ITTRTWA +\n                       ITTMOM ITTKID ITTSIS) +\n                 NOWRITE REPLACE\nIF &LASTCC > 4 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n GOTO EXIT\nEND\n\n/******************************************************************/\n/* Process all TCBs for this address space                        */\n/******************************************************************/\n\nDO WHILE &TCBADDR^=0\n ISPEXEC TBVCLEAR IPTCBTBL\n INTEGER X'&TCBADDR' PTR DIALOG(S(ITTADDR))\n SET MAXCC = 0\n EVAL &TCBADDR..+10 LE(4) HEX DIALOG(S(ITTCOMP))\n EVAL &TCBADDR..+E0 LE(4) PTR DIALOG(S(ITTRTWA))\n EVAL &TCBADDR..+85 LE(3) PTR DIALOG(S(ITTMOM))\n EVAL &TCBADDR..+89 LE(3) PTR DIALOG(S(ITTKID))\n EVAL &TCBADDR..+81 LE(3) PTR DIALOG(S(ITTSIS))\n\n EVAL &TCBADDR..+7D LE(3) PTR CLIST(S(JSTCB))\n EVAL &TCBADDR..+20 LE(2) UNS CLIST(S(NONDISP))\n\n IF &MAXCC = 12 THEN DO\n  NOTE '==> Error: Cannot access TCB at &TCBADDR for ASID(&ASID)' ASIS\n  GOTO REDISP\n END\n\n /******************************************************************/\n /* Determine if this TCB is nondispatchable or a job step TCB     */\n /******************************************************************/\n\n IF &STR(&JSTCB) = &STR(&TCBADDR) THEN DO\n  SET JOBSTEPTCB = J\n END\n ELSE DO\n  SET JOBSTEPTCB = &STR( )\n END\n\n IF &NONDISP ^= 0 THEN DO\n  SET NONDISPATCHABLE = N\n END\n ELSE DO\n  SET NONDISPATCHABLE = &STR( )\n END\n\n SET ITTSTUFF = &STR(&JOBSTEPTCB&NONDISPATCHABLE)\n\n /******************************************************************/\n /* Try to get a module name to identify this TCB.                 */\n /******************************************************************/\n\n EVAL &TCBADDR..+01 LE(3) PTR CLIST(S(RBADDR))\n IF &LASTCC = 12 THEN DO\n  NOTE '==> Error: Cannot get RB pointer from TCB at &TCBADDR' ASIS\n  GOTO NOCDE\n END\n\n SET ITTNAME = &STR(********)\n\n /* To extract the CDE module name, RB must be a PRB, else no sale. */\n\nGETCDE:+\n COMPARE ADDRESS(&RBADDR..+A) LENGTH(1) WITH(VALUE(X'00')) MASK(X'E0')\n SET COMPCC = &LASTCC\n IF &COMPCC = 12 THEN DO\n  NOTE '==> Error: RB at &RBADDR not available for TCB at &TCBADDR' ASIS\n  GOTO NOCDE\n END\n IF &COMPCC = 0 THEN DO\n  EVAL &RBADDR..+D LE(3) PTR CLIST(S(CDEADDR))\n  IF &CDEADDR ^= 0 THEN GOTO GOTCDE\n END\n\n COMPARE ADDR(&RBADDR..+B) LE(1) +\n         WITH(VALUE(X'80')) MASK(X'80') /* Does NEXTRB point to TCB?\n IF &LASTCC = 0 THEN GOTO NOCDE\n EVAL &RBADDR..+1D PTR LE(3) CLIST(S(RBADDR))\n GOTO GETCDE\n\nGOTCDE:+\n EVAL &CDEADDR..+8 LE(8) CHAR CLIST(S(ITTNAME))\n\nNOCDE:+\n IF &ITTCOMP = 0 THEN SET ITTCOMP =\n IF &ITTRTWA = 0 THEN SET ITTRTWA =\n IF &ITTMOM  = 0 THEN SET ITTMOM  =\n IF &ITTKID  = 0 THEN SET ITTKID  =\n IF &ITTSIS  = 0 THEN SET ITTSIS  =\n\n ISPEXEC TBADD IPTCBTBL\n IF &LASTCC > 4 THEN DO\n  ISPEXEC DISPLAY PANEL(ISPTERM)\n  GOTO EXIT\n END\n SET &TCBCTR=&TCBCTR+1\n SYSCALL GET_NEXT_TCB TCBADDR ASID\n IF &LASTCC = 12 THEN EXIT\nEND\n\n/******************************************************************/\n/* Display the table of TCB's.                                    */\n/******************************************************************/\n\nREDISP:+\nISPEXEC TBTOP IPTCBTBL\nIF &LASTCC ^= 0 THEN DO\n ISPEXEC DISPLAY PANEL(ISPTERM)\n GOTO EXIT\nEND\nSET TABLECC = 0\nDO WHILE &TABLECC < 8\n IF &TABLECC = 4 THEN DO /* ISPEXEC TBDISPL\n  WRITE Multiple table entries not allowed\n  SET ITTSEL =\n  SET ITTEXIT =\n  GOTO REDISP\n END\n ELSE ISPEXEC TBDISPL IPTCBTBL PANEL(IPTCBTBL)\n SET TABLECC = &LASTCC\n IF &TABLECC > 8 THEN DO\n  ISPEXEC DISPLAY PANEL(ISPTERM)\n  GOTO EXIT\n END\n IF &TABLECC < 8 THEN DO\n  SET ITTSEL  = &STR(&SYSCAPS(&ITTSEL))\n  SET ITTEXIT = &STR(&SYSCAPS(&ITTEXIT))\n  IF &STR(&ITTSEL&ITTEXIT) ^= THEN DO\n   ISPEXEC CONTROL DISPLAY SAVE\n   IF &ITTSEL = THEN DO\n    IF &STR(&ITTEXIT) ^= THEN +\n    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%&ITTEXIT TCB(&ITTADDR..) &XTRACE)\n   END\n   ELSE IF &ITTSEL = R THEN DO\n    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPRB   &ITTADDR.. &XTRACE)\n   END\n   ELSE IF &ITTSEL = D THEN DO\n    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPDEB  &ITTADDR.. &XTRACE)\n   END\n   ELSE IF &ITTSEL = V THEN DO\n    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPVS &ITTADDR &XTRACE)\n   END\n   ELSE DO\n    ISPEXEC SETMSG MSG(IPZ002)\n    SET ITTSEL =\n    SET ITTEXIT =\n    GOTO REDISP\n   END\n   ISPEXEC CONTROL DISPLAY RESTORE\n  END\n  IF &NRSTR(&ITTCMD) ^= THEN DO\n   ISPEXEC CONTROL DISPLAY SAVE\n   ISPEXEC SELECT PGM(BLSGSCMD) PARM(&ITTCMD)\n   ISPEXEC CONTROL DISPLAY RESTORE\n  END\n END\nEND\nISPEXEC TBEND IPTCBTBL\nGOTO EXIT\nEXIT:+\nISPEXEC CONTROL DISPLAY REFRESH\nEXIT\n\nGET_NEXT_TCB: PROC 2 TCBADDR ASID\n SYSREF TCBADDR ASID\n /* This is the old way, which doesn't get all the TCBs. */\n /*\n /*EVAL &TCBADDR..+75 LE(3) PTR CLIST(S(TCBADDR))\n /*IF &LASTCC=12 THEN DO\n /* NOTE '==> Error: Cannot access next TCB pointer from &TCBADDR for +\n /*                  ASID(&ASID)' ASIS\n /* RETURN CODE(4)\n /*END\n /*RETURN CODE(0)\n\n/**********************************************************************/\n/*                                                                    */\n/* Correct logic to get all the TCB's:                                */\n/*                                                                    */\n/* Start from the top (chain through mothers till no more), and...    */\n/*                                                                    */\n/*  PROCESS:                                                          */\n/*  Process this TCB                                                  */\n/*  Get daughter (+88)                                                */\n/*   Yes -> PROCESS                                                   */\n/*   No...                                                            */\n/*  GETSIS:                                                           */\n/*  Get sister (+80)                                                  */\n/*   Yes -> PROCESS                                                   */\n/*   No...                                                            */\n/*  Get mother (+84)                                                  */\n/*   Yes -> GETSIS                                                    */\n/*   No -> exit                                                       */\n/*                                                                    */\n/**********************************************************************/\n\n EVAL &TCBADDR..+89 LE(3) PTR CLIST(S(NTCBADDR)) /* daughter TCB */\n IF &LASTCC = 12 THEN GOTO ERROR\n IF &NTCBADDR ^= 0 THEN GOTO PROCESS\nGETSIS:+\n EVAL &TCBADDR..+81 LE(3) PTR CLIST(S(NTCBADDR)) /* sister TCB */\n IF &LASTCC = 12 THEN GOTO ERROR\n IF &NTCBADDR ^= 0 THEN GOTO PROCESS\n EVAL &TCBADDR..+85 LE(3) PTR CLIST(S(NTCBADDR)) /* mother TCB */\n IF &LASTCC = 12 THEN GOTO ERROR\n IF &NTCBADDR ^= 0 THEN DO\n  SET TCBADDR = &STR(&NTCBADDR)\n  GOTO GETSIS\n END\nPROCESS: +\n SET TCBADDR = &STR(&NTCBADDR)\n RETURN\nERROR: +\n  NOTE '==> Error: Cannot access next TCB pointer from &TCBADDR for +\n                   ASID(&ASID)' ASIS\n  RETURN CODE(12)\n\nEND /* GET_NEXT_TCB */\n\n./ ADD NAME=IPVASID\nPROC 0 XTRACE\nNGLOBAL ACTIVE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nSET SETDEFASID = none\nSET SYSDVAL = &STR(*** **** ****** ******** +\n                   *** **** ****** ******** +\n                   *** **** ****** ********)\nREADDVAL DEFASID DEFASIDX DEFASCB DEFJOBN +\n         CURASID CURASIDX CURASCB CURJOBN +\n         HDRASID HDRASIDX HDRASCB HDRJOBN\nEVALDEF CLIST(QUAL(DEFQUAL) DATASET(DEFDATASET))\nIF &STR(&DEFDATASET) = ACTIVE THEN DO\n SET ACTIVE = ACTIVE\nEND\nIF &SUBSTR(1:4,&DEFQUAL    ) = ASID THEN DO\n SET SETDEFASID = &SUBSTR(6:&LENGTH(&STR(&DEFQUAL))-1,&DEFQUAL)\n INTEGER &SETDEFASID UNS    CLIST(S(DEFASID))\n INTEGER &SETDEFASID PTR(4) CLIST(S(DEFASIDX))\n SYSCALL GET_ASCB DEFASCB &DEFASID &DEFASIDX\n SYSCALL GET_JOBNAME DEFJOBN &DEFASCB\nEND\nEVAL 224. PTR CLIST(S(CURASCB)) &ACTIVE\nIF &LASTCC ^= 0 THEN DO\n NOTE  'Error:  PSA ASCB pointer not accessible at 224.' ASIS\n IF &ACTIVE = THEN DO\n  NOTE '        Dump may be unusable (possibly not a SYSMDUMP).' ASIS\n END\n NOTE SPACE(1)\n EXIT C(12) Q\nEND\nEVAL 224.?+24 L(2) UNS CLIST(S(CURASID)) &ACTIVE\nIF &LASTCC ^= 0 THEN DO\n NOTE  'Error:  Couldn''t get ASID from the current ASCB.' ASIS\n IF &ACTIVE = THEN DO\n  NOTE '        Dump may be unusable (possibly not a SYSMDUMP).' ASIS\n END\n NOTE SPACE(1)\n EXIT C(12) Q\nEND\nELSE DO\n INTEGER &CURASID PTR(4) CLIST(S(CURASIDX))\n SYSCALL GET_JOBNAME CURJOBN &CURASCB\nEND\nIF &ACTIVE = THEN DO\n /* Offset of SDUMP common section... */\n EVAL 168. HEADER L(2) HEX CLIST(S(COMMOFF))\n IF &STR(&COMMOFF) ^= &STR(0000) THEN DO\n  EVAL &COMMOFF..+48 HEADER L(2) UNS CLIST(S(PASID))\n  INTEGER &PASID PTR(4) CLIST(S(PASIDX))\n  EVAL &COMMOFF..+4A HEADER L(2) UNS CLIST(S(SASID))\n  INTEGER &SASID PTR(4) CLIST(S(SASIDX))\n  EVAL &COMMOFF..+4C HEADER L(2) UNS CLIST(S(HASID))\n  INTEGER &HASID PTR(4) CLIST(S(HASIDX))\n  SET HDRASID = &HASID\n  INTEGER &HDRASID PTR(4) CLIST(S(HDRASIDX))\n END\n SYSCALL GET_ASCB HDRASCB &HDRASID &HDRASIDX\n SYSCALL GET_JOBNAME HDRJOBN &HDRASCB\nEND\nISPEXEC VPUT (DEFASID DEFASIDX DEFASCB DEFJOBN +\n              CURASID CURASIDX CURASCB CURJOBN +\n              HDRASID HDRASIDX HDRASCB HDRJOBN) SHARED\nSET IPASID  = &STR(&DEFASID)\nSET IPASIDX = &STR(&DEFASIDX)\nSET IPASCB  = &STR(&DEFASCB)\nSET IPJOBN  = &STR(&DEFJOBN)\nISPEXEC DISPLAY PANEL(IPCASID) /* choose ASID */\nIF &LASTCC > 8 THEN ISPEXEC DISPLAY PANEL(ISPTERM)\nIF &STR(&OTHASID) ^= &STR() THEN DO\n INTEGER &OTHASID UNS    CLIST(S(IPASID))\n INTEGER &OTHASID PTR(4) CLIST(S(IPASIDX))\n SET IPASCB = &STR(*UNSET*)\n SET IPJOBN = &STR(*UNSET*)\nEND\nISPEXEC VPUT (IPASID IPASIDX IPASCB IPJOBN) SHARED\nEXIT C(0)\n\n/*IF &SETDEFASID ^= &IPASID THEN DO\n/* NOTE 'Warning:  The ASID found in the current ASCB'              ASIS\n/* NOTE '          does not match the one that IPCS specified.'     ASIS\n/* NOTE '          IPDSN is setting the ASID for IPCS to &IPASID'   ASIS\n/* NOTE '          instead of its present setting of &SETDEFASID..' ASIS\n/* SETDEF ASID(&IPASID)\n/*END\n\nGET_ASCB: PROC 3 AVAR ASIDN ASIDX\n SYSREF AVAR\n SET AVAR = &STR(******)\n IF &STR(&ASIDN) = &STR(***) THEN RETURN CODE(16)\n\n/**********************************************************************/\n/*                                                                    */\n/* Get the ASCB for this ASID.  Note that instead of using the PSA's  */\n/* ASCBNEW or ASCBOLD pointer, we use the ASID to index into the ASVT */\n/* to find it.  In that way you can map the TCB chain from the ASID   */\n/* that you requested using SETDEF.                                   */\n/*                                                                    */\n/**********************************************************************/\n\n IF &ACTIVE = ACTIVE THEN +\n  EVAL 10.%+22C L(4) PTR CLIST(S(ASVTADDR))\n ELSE +\n  EVAL CVT+22C L(4) PTR CLIST(S(ASVTADDR))\n IF &LASTCC ^= 0 THEN DO\n  NOTE '==> Error: ASVT address not available from CVT+22C' ASIS\n  RETURN CODE(16)\n END\n EVAL &ASVTADDR..+204 L(4) UNS CLIST(S(ASVTMAXU))\n IF &LASTCC ^= 0 THEN DO\n  NOTE '==> Error: ASVTMAXU not available from ASVT at &ASVTADDR' ASIS\n  RETURN CODE(16)\n END\n IF &ASIDN > &ASVTMAXU THEN DO\n  NOTE '==> Error: ASID &ASID is invalid, greater than maximum' ASIS\n  RETURN CODE(16)\n END\n SET ASVTOFFS = &ASIDN*4\n EVAL &ASVTADDR..+20C+&ASVTOFFS.N L(4) PTR CLIST(S(ASCBADDR))\n IF &LASTCC ^= 0 THEN DO\n  NOTE '==> Error: ASCB address not available at 224.' ASIS\n  RETURN CODE(16)\n END\n SELECT &SUBSTR(1,&ASCBADDR)\n  WHEN (8|9|A|B|C|D|E|F) DO\n   NOTE '==> Error: ASID &ASID is not assigned.' ASIS\n   RETURN CODE(16)\n  END\n END\n SET AVAR = &STR(&ASCBADDR)\n RETURN CODE(0)\nEND\n\nGET_JOBNAME: PROC 2 JOBNAME ASCBADDR\n SYSREF JOBNAME\n SET JOBNAME = &STR(********)\n IF &STR(&ASCBADDR) = &STR(******) THEN RETURN CODE(16)\n EVAL &ASCBADDR..+AC L(4) PTR CLIST(S(JOBNAMEADDR))\n IF &STR(&JOBNAMEADDR) = &STR(00000000) THEN DO\n  EVAL &ASCBADDR..+B0 L(4) PTR CLIST(S(JOBNAMEADDR))\n END\n EVAL &JOBNAMEADDR.. L(8) CHAR CLIST(S(JOBNAME))\n RETURN\nEND\n\n/* GET_JOBNAME: PROC 1 IPASID ACTIVE\n/*  SET IPASIDX = &STR(**)\n/*  SET IPJOBN  = unavail.\n/*  ERROR GOTO VPUT_IT_ANYWAY\n/*  INTEGER &IPASID PTR DIALOG(S(IPASIDX))\n/*  EVAL 224.?+AC PTR CLIST(S(ASCBJBNI)) &ACTIVE\n/*  IF &ASCBJBNI ^= 0 THEN DO\n/*   EVAL 224.?+AC? LE(8) CHAR CLIST(S(IPJOBN)) &ACTIVE\n/*  END\n/*  ELSE DO\n/*   EVAL 224.?+B0 PTR CLIST(S(ASCBJBNM)) &ACTIVE\n/*   IF &ASCBJBNM ^= 0 THEN DO\n/*    EVAL 224.?+B0? LE(8) CHAR CLIST(S(IPJOBN)) &ACTIVE\n/*   END\n/*  END\n/*  VPUT_IT_ANYWAY: ERROR OFF\n/*  ISPEXEC VPUT (IPASID IPASIDX IPJOBN) SHARED\n/* END\n./ ADD NAME=IPVIEW\nPROC 0 XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nELSE CONTROL NOLIST\nCONTROL NOCAPS\nISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPTCB &XTRACE)\nEXIT C(&LASTCC)\n./ ADD NAME=IPVS\n\n/**********************************************************************/\n/*                                                                    */\n/* VS - Virtual Storage Control Block Analysis                        */\n/*                                                                    */\n/* Reference: MVS/XA SLL: Virtual Storage Management, Part I          */\n/*            LY28-1790-0                                             */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 1 TCB XTRACE\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOFLUSH NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n WRITE *** You must be in IPCS to use this CLIST. ***\n EXIT C(16) Q\nEND\n\nEVAL 10.%+230 LE(4) PTR CLIST(S(GDA))\n\nEVAL &GDA..+6C LE(4) PTR DIALOG(S(GDACSA  )) /* lowest addr of CSA\nEVAL &GDA..+70 LE(4) PTR DIALOG(S(GDACSASZ)) /* size of CSA\nEVAL &GDA..+7C LE(4) PTR DIALOG(S(GDAECSA )) /* lowest addr of ECSA\nEVAL &GDA..+80 LE(4) PTR DIALOG(S(GDAECSAS)) /* size of ECSA\nEVAL &GDA..+8C LE(4) PTR DIALOG(S(GDACSACV)) /* CSA converted to SQA\nEVAL &GDA..+90 LE(4) PTR DIALOG(S(GDASQA  )) /* lowest addr of SQA\nEVAL &GDA..+94 LE(4) PTR DIALOG(S(GDASQASZ)) /* size of SQA\nEVAL &GDA..+98 LE(4) PTR DIALOG(S(GDAESQA )) /* lowest addr of ESQA\nEVAL &GDA..+9C LE(4) PTR DIALOG(S(GDAESQAS)) /* size of ESQA\nEVAL &GDA..+A0 LE(4) PTR DIALOG(S(GDAPVT  )) /* lowest addr of private\nEVAL &GDA..+A4 LE(4) PTR DIALOG(S(GDAPVTSZ)) /* size of private\nEVAL &GDA..+A8 LE(4) PTR DIALOG(S(GDAEPVT )) /* lowest addr of eprivate\nEVAL &GDA..+AC LE(4) PTR DIALOG(S(GDAEPVTS)) /* size of eprivate\n\nISPEXEC VPUT (+\n  GDACSA GDACSASZ GDAECSA GDAECSAS GDACSACV GDASQA GDASQASZ GDAESQA +\n  GDAESQAS GDAPVT GDAPVTSZ GDAEPVT GDAEPVTS +\n             ) SHARED\n\nSET VVTCB = &STR(&TCB)\nISPEXEC VPUT (VVTCB) SHARED\nISPEXEC CONTROL ERRORS CANCEL\nISPEXEC SELECT PANEL(IPVS)\nISPEXEC CONTROL ERRORS RETURN\n\n./ ADD NAME=IPVSAE\nPROC 1 TCBADDR XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\n\n/******************************************************************/\n/* Create table of AE's for this TCB                              */\n/******************************************************************/\n\nISPEXEC TBCREATE AETBL +\n        KEYS() +\n        NAMES(AESEL AEADDR AETYPE +\n              AENEXT AEPREV AEAREA EAEAREA AESIZE AEAREAN AESIZEN +\n             ) +\n        NOWRITE REPLACE\n\n/******************************************************************/\n/* Extract pointers to the AE's from the TCB                      */\n/******************************************************************/\n\nEVAL &TCBADDR..+9C L(4) PTR CLIST(S(TCBAE))\nIF &LASTCC > 0 THEN DO\n NOTE 'Error: TCBAE not available for TCB at &TCBADDR..' ASIS\n EXIT C(16) Q\nEND\n\nEVAL &TCBADDR..+12C L(4) PTR CLIST(S(TCBEAE))\nIF &LASTCC > 0 THEN DO\n NOTE 'Error: TCBEAE not available for TCB at &TCBADDR..' ASIS\n EXIT C(16) Q\nEND\n\n/**********************************************************************/\n/* Process all the AE's                                               */\n/**********************************************************************/\n\nSYSCALL PROCESS_AE &TCBAE &XTRACE\nSYSCALL PROCESS_AE &TCBEAE EXTENDED &XTRACE\n\n%IPTBDISP AE ADDR(&TCBADDR)\n\nEXIT\n\n\nPROCESS_AE: PROC 1 AEADDR EXTENDED XTRACE\n\n DO WHILE &STR(&AEADDR) ^= &STR(00000000)\n\n  EVAL &AEADDR..+00 LE(4)            PTR     CLIST(S(AENEXT))\n  EVAL &AEADDR..+04 LE(4)            PTR     CLIST(S(AEPREV))\n  EVAL &AEADDR..+08 LE(4)            SIGNED  CLIST(S(AEAREAN))\n  EVAL &AEADDR..+0C LE(4)            SIGNED  CLIST(S(AESIZEN))\n  INTEGER &AEAREAN                   PTR(8)  CLIST(S(AEAREA))\n  INTEGER &AESIZEN                   PTR     CLIST(S(AESIZE))\n  INTEGER &EVAL(&AEAREAN + &AESIZEN) PTR(8)  CLIST(S(EAEAREA))\n\n /*********************************************************************/\n /* Add AE info to the table.                                         */\n /*********************************************************************/\n\n  IF &EXTENDED = EXTENDED THEN SET AETYPE = ABOVE\n  ELSE SET AETYPE = BELOW\n  ISPEXEC TBADD AETBL\n\n /*********************************************************************/\n /* Chain to next AE.                                                 */\n /*********************************************************************/\n\n  SET AEADDR = &STR(&AENEXT)\n END\n\nEND PROCESS_AE\n\n./ ADD NAME=IPVSCMAP\n\n/**********************************************************************/\n/*                                                                    */\n/* This CLIST produces a table displaying allocated CSA storage.      */\n/*                                                                    */\n/* Reference: MVS/XA SLL: Virtual Storage Management, Part I          */\n/*            LY28-1790-0                                             */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 1 TCBADDRESS XTRACEVALUE\nNGLOBAL TCBADDR XTRACE +\n        ZERRSM ZERRLM ZERRMSG ZERRHM ZERRALRM +\n        CMAPSEL +\n        CMAPSPID CMAPKEY +\n        CMAPLOC +\n        CMAPAREA CMAPAREE CMAPSIZE +\n        CMAPARNA CMAPARNE CMAPSIZN\n\nIF &XTRACEVALUE ^= THEN DO\n CONTROL LIST CONLIST SYMLIST\n SET XTRACE = XTRACE\nEND\nELSE SET XTRACE =\nCONTROL NOCAPS\nSET TCBADDR = &STR(&TCBADDRESS..)\n\n/******************************************************************/\n/* Create table to contain all virtual storage info               */\n/******************************************************************/\n\nISPEXEC TBCREATE CMAPTBL +\n        KEYS() +\n        NAMES(CMAPSEL +\n              CMAPSPID CMAPKEY +\n              CMAPLOC +\n              CMAPAREA CMAPAREE CMAPSIZE +\n              CMAPARNA CMAPARNE CMAPSIZN +\n             ) +\n        NOWRITE REPLACE\n\nEVALSYM GDA\nIF &LASTCC = 12 THEN DO\n EQ GDA CVT+230?\nEND\nEVAL GDA+88 LE(4) UNS CLIST(S(GDASPT))\nIF &LASTCC = 12 | &GDASPT = 0 THEN DO\n NOTE 'Error: No valid GDASPT pointer.' ASIS\n EXIT C(12) Q\nEND\n\nDO &SP = 0 TO 3\n DO &PK = 0 TO 15\n  SET N = &GDASPT+4+(24*&PK+384*&SP)\n  INTEGER &EVAL(&N+0)  PTR(8) CLIST(S(P0))\n  INTEGER &EVAL(&N+4)  PTR(8) CLIST(S(P4))\n  INTEGER &EVAL(&N+8)  PTR(8) CLIST(S(P8))\n  INTEGER &EVAL(&N+12) PTR(8) CLIST(S(P12))\n  INTEGER &EVAL(&N+16) PTR(8) CLIST(S(P16))\n  INTEGER &EVAL(&N+20) PTR(8) CLIST(S(P20))\n  SET SPTADDR = &STR(&P0)\n  SELECT &SP\n   WHEN (0) SET CMAPSPID = 227\n   WHEN (1) SET CMAPSPID = 228\n   WHEN (2) SET CMAPSPID = 231\n   WHEN (3) SET CMAPSPID = 241\n  END\n  SET CMAPKEY = &PK\n  EVAL &P0   LE(4) UNS CLIST(S(NSPTFBDQE))\n  EVAL &P4   LE(4) UNS CLIST(S(NSPTLBDQE))\n  EVAL &P8   LE(4) UNS CLIST(S(NSPTFADQE))\n  EVAL &P12  LE(4) UNS CLIST(S(NSPTLADQE))\n  EVAL &P16  LE(4) UNS CLIST(S(NSPTFEDQE))\n  EVAL &P20  LE(4) UNS CLIST(S(NSPTLEDQE))\n  INTEGER &NSPTFBDQE PTR(8) CLIST(S(SPTFBDQE))\n  INTEGER &NSPTLBDQE PTR(8) CLIST(S(SPTLBDQE))\n  INTEGER &NSPTFADQE PTR(8) CLIST(S(SPTFADQE))\n  INTEGER &NSPTLADQE PTR(8) CLIST(S(SPTLADQE))\n  INTEGER &NSPTFEDQE PTR(8) CLIST(S(SPTFEDQE))\n  INTEGER &NSPTLEDQE PTR(8) CLIST(S(SPTLEDQE))\n\n  IF &NSPTFBDQE ^= &N+0  | &NSPTLBDQE ^= &N+0  THEN DO\n   SYSCALL PROCESS_DQE BELOW &P0  00  &XTRACE\n  END\n  IF &NSPTFADQE ^= &N+8  | &NSPTLADQE ^= &N+8  THEN DO\n   SYSCALL PROCESS_DQE ANY   &P0  08  &XTRACE\n  END\n  IF &NSPTFEDQE ^= &N+16 | &NSPTLBDQE ^= &N+16 THEN DO\n   SYSCALL PROCESS_DQE ABOVE &P0  10  &XTRACE\n  END\n END\nEND\n\n%IPTBDISP CMAP &XTRACE\n\nEXIT C(0)\n\n\nPROCESS_DQE: PROC 3 DQETYPE P OFFSET\n\n SET LOCATIVE =\n SYSCALL ADDRESSIFY LOCATIVE &P..+&OFFSET\n\n EVAL &LOCATIVE..+0 LE(4) PTR CLIST(S(DQEADDR))\n EVAL &LOCATIVE..+4 LE(4) PTR CLIST(S(DQELADDR))\n\n DO UNTIL &STR(&DQEADDR) = &STR(&DQELADDR) +\n     WHILE &STR(&DQEADDR) ^= &STR(&LOCATIVE)\n  EVAL &DQEADDR..+00 LE(4) PTR    CLIST(S(DQENEXT))\n  EVAL &DQEADDR..+04 LE(4) PTR    CLIST(S(DQEPREV))\n  EVAL &DQEADDR..+08 LE(4) PTR    CLIST(S(DQEFFQE))\n  EVAL &DQEADDR..+0C LE(4) PTR    CLIST(S(DQELFQE))\n  EVAL &DQEADDR..+10 LE(4) SIGNED CLIST(S(DQEAREA))\n  EVAL &DQEADDR..+14 LE(4) SIGNED CLIST(S(DQESIZE))\n\n/**********************************************************************/\n/* Set table variables from DQE info.                                 */\n/**********************************************************************/\n\n  SET CMAPLOC  = &STR(&DQETYPE)\n\n/**********************************************************************/\n/* For each DQE, process all FQE's                                    */\n/**********************************************************************/\n\n  SYSCALL PROCESS_FQE &DQEADDR &DQEAREA &DQESIZE &DQEFFQE &DQELFQE\n\n/**********************************************************************/\n/* Chain to next DQE.                                                 */\n/**********************************************************************/\n\n  SET DQEADDR = &STR(&DQENEXT)\n\n END\n\nEND PROCESS_DQE\n\n\nPROCESS_FQE: PROC 5 DQEADDR DQEAREA DQESIZE DQEFFQE DQELFQE\n\n/**********************************************************************/\n/* If there are no FQE's, the entire area defined by this DQE is      */\n/* allocated.  Add it to the table as a single entry (e.g. 4K block). */\n/**********************************************************************/\n\n IF &STR(&DQEFFQE) = &STR(&DQEADDR) THEN DO\n  SET CMAPARNA = &DQEAREA\n  SET CMAPSIZN = &DQESIZE\n  SYSCALL TBADD\n END\n\n ELSE DO\n  SET ALLOCAREA = &DQEAREA\n  SET ALLOCEND = &DQEAREA + &DQESIZE\n  SET FQEADDR = &STR(&DQEFFQE)\n  DO UNTIL &STR(&A)        = &STR(&DQELFQE) +\n     WHILE &STR(&FQEADDR) ^= &STR(&DQEADDR)\n   EVAL &FQEADDR..+00 LE(4) SIGNED CLIST(S(FQEAREA))\n   EVAL &FQEADDR..+04 LE(4) SIGNED CLIST(S(FQESIZE))\n   EVAL &FQEADDR..+08 LE(4) PTR    CLIST(S(FQENEXT))\n\n/**********************************************************************/\n/* Since the FQE's map chunks of free storage, interpolate where the  */\n/* allocated storage is and create table entries for the allocated    */\n/* storage, not the free storage.                                     */\n/**********************************************************************/\n\n   SET CMAPSIZN = &FQEAREA - &ALLOCAREA\n   IF &CMAPSIZN ^= 0 THEN DO\n    SET CMAPARNA = &ALLOCAREA\n    SYSCALL TBADD\n   END\n\n   SET ALLOCAREA = &FQEAREA + &FQESIZE\n\n/**********************************************************************/\n/* Chain to next FQE.                                                 */\n/**********************************************************************/\n\n   SET A = &STR(&FQEADDR)\n   SET FQEADDR = &STR(&FQENEXT)\n  END\n\n/**********************************************************************/\n/* Check last possible unfreed chunk.                                 */\n/**********************************************************************/\n\n  SET CMAPSIZN = &ALLOCEND - &ALLOCAREA\n  IF &CMAPSIZN ^= 0 THEN DO\n   SET CMAPARNA = &ALLOCAREA\n   SYSCALL TBADD\n  END\n\n END\n\nEND PROCESS_FQE\n\nTBADD: PROC 0\n SET CMAPARNE = &CMAPARNA + &CMAPSIZN\n INTEGER &CMAPARNA PTR(8) CLIST(S(CMAPAREA))\n INTEGER &CMAPARNE PTR(8) CLIST(S(CMAPAREE))\n INTEGER &CMAPSIZN PTR    CLIST(S(CMAPSIZE))\n\n WRITE +\n       &CMAPTYPE &CMAPSPID &CMAPKEY +\n       &CMAPLOC &CMAPAREA &CMAPAREE &CMAPSIZE\n\n ISPEXEC TBADD CMAPTBL\n RETURN\nEND\n\nADDRESSIFY: PROC 2 NEWADDRESS OLDADDRESS\n SYSREF NEWADDRESS\n TCBEXIT YITADDR &NRSTR(&OLDADDRESS) POSITION(+0)\n IF &LASTCC ^= 0 THEN DO\n  NOTE 'Invalid address: &NRSTR(&OLDADDRESS)' ASIS\n  EXIT C(16) Q\n END\n SET NEWADDRESS = &STR(&YITHEX)\n RETURN\nEND ADDRESSIFY\n\n./ ADD NAME=IPVSCSA\nPROC 1 TCBADDR XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nEVALSYM GDA\nIF &LASTCC = 12 THEN DO\n EQ GDA CVT+230?\nEND\nEVAL GDA+88 LE(4) UNS CLIST(S(GDASPT))\nIF &LASTCC = 12 | &GDASPT = 0 THEN DO\n NOTE 'Error: No valid GDASPT pointer.' ASIS\n EXIT C(12) Q\nEND\n\nISPEXEC TBCREATE SPTTBL +\n        KEYS() +\n        NAMES(SPTSEL SPTADDR SPTSP SPTPK +\n              SPTFBDQE SPTLBDQE +\n              SPTFADQE SPTLADQE +\n              SPTFEDQE SPTLEDQE +\n             ) +\n        NOWRITE REPLACE\n\nDO &SP = 0 TO 3\n DO &PK = 0 TO 15\n  /* SET TOTALOFF = 24*&SP + 96*&PK\n  SET TOTALOFF = 24*&PK + 384*&SP\n  SET N = &GDASPT+4+&TOTALOFF\n  INTEGER &EVAL(&N+0)  PTR(8) CLIST(S(P0))\n  INTEGER &EVAL(&N+4)  PTR(8) CLIST(S(P4))\n  INTEGER &EVAL(&N+8)  PTR(8) CLIST(S(P8))\n  INTEGER &EVAL(&N+12) PTR(8) CLIST(S(P12))\n  INTEGER &EVAL(&N+16) PTR(8) CLIST(S(P16))\n  INTEGER &EVAL(&N+20) PTR(8) CLIST(S(P20))\n  SET SPTSEL =\n  SET SPTADDR = &STR(&P0)\n  SELECT &SP\n   WHEN (0) SET SPTSP = 227\n   WHEN (1) SET SPTSP = 228\n   WHEN (2) SET SPTSP = 231\n   WHEN (3) SET SPTSP = 241\n  END\n  SET SPTPK = &PK\n  EVAL &P0   LE(4) UNS CLIST(S(NSPTFBDQE))\n  EVAL &P4   LE(4) UNS CLIST(S(NSPTLBDQE))\n  EVAL &P8   LE(4) UNS CLIST(S(NSPTFADQE))\n  EVAL &P12  LE(4) UNS CLIST(S(NSPTLADQE))\n  EVAL &P16  LE(4) UNS CLIST(S(NSPTFEDQE))\n  EVAL &P20  LE(4) UNS CLIST(S(NSPTLEDQE))\n  INTEGER &NSPTFBDQE PTR(8) CLIST(S(SPTFBDQE))\n  INTEGER &NSPTLBDQE PTR(8) CLIST(S(SPTLBDQE))\n  INTEGER &NSPTFADQE PTR(8) CLIST(S(SPTFADQE))\n  INTEGER &NSPTLADQE PTR(8) CLIST(S(SPTLADQE))\n  INTEGER &NSPTFEDQE PTR(8) CLIST(S(SPTFEDQE))\n  INTEGER &NSPTLEDQE PTR(8) CLIST(S(SPTLEDQE))\n\n  SET MISSING = 0\n  IF &NSPTFBDQE = &N+0 && &NSPTLBDQE = &N+0 THEN DO\n   SET SPTFBDQE =\n   SET SPTLBDQE =\n   SET MISSING = &MISSING+1\n  END\n  IF &NSPTFADQE = &N+8 && &NSPTLADQE = &N+8 THEN DO\n   SET SPTFADQE =\n   SET SPTLADQE =\n   SET MISSING = &MISSING+1\n  END\n  IF &NSPTFEDQE = &N+16 && &NSPTLEDQE = &N+16 THEN DO\n   SET SPTFEDQE =\n   SET SPTLEDQE =\n   SET MISSING = &MISSING+1\n  END\n\n  IF &MISSING < 3 THEN DO\n   ISPEXEC TBADD SPTTBL\n  END\n END\nEND\n\nTCBX YITADDR GDA POS(+0)\n%IPTBDISP SPT ADDRESS(&YITHEX)\n\nEXIT\n\n./ ADD NAME=IPVSDQE\nPROC 0 THING() POINTER() ADDRESS() EXTRA() XTRACE\nIF &XTRACE = XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOCAPS\n\nSET POINTER = &STR(&&&POINTER)\nSET ADDRESS = &STR(&&&ADDRESS)\nIF &STR(&EXTRA) ^= THEN DO\n SET SYSDVAL = &NRSTR(&EXTRA)\n READDVAL X1 X2\n SET AMP = &&\n SET EXTRA = &NRSTR(,&X1 at &AMP.&X2)\nEND\n\n/**********************************************************************/\n/* Get the variables from the current table row.                      */\n/**********************************************************************/\n\nISPEXEC TBGET &THING.TBL\n\n/**********************************************************************/\n/* Create a table to hold the DQE entries.                            */\n/**********************************************************************/\n\nISPEXEC TBCREATE DQETBL +\n        KEYS() +\n        NAMES(DQESEL DQETYPE DQEADDR +\n              DQEFFQE DQELFQE DQEAREA DQESIZE +\n             ) +\n        NOWRITE REPLACE\n\n/**********************************************************************/\n/* Access information from SPQA or SPT.  We retrieve info from the    */\n/* DFE's chained thereoff, and create a table of DQE's.               */\n/*                                                                    */\n/* There are 3 queues of DQE's.                                       */\n/*                                                                    */\n/* (In the following, \"Thing\" is SPSA (for private) or SPT (for CSA). */\n/*                                                                    */\n/* Thing + 00 ==> first DQE for storage backed below 16M              */\n/* Thing + 04 ==> last  DQE for storage backed below 16M              */\n/* Thing + 08 ==> first DQE for storage backed anywhere               */\n/* Thing + 0C ==> last  DQE for storage backed anywhere               */\n/* Thing + 10 ==> first DQE for storage backed above 16M (????)       */\n/* Thing + 14 ==> last  DQE for storage backed above 16M (????)       */\n/*                                                                    */\n/**********************************************************************/\n\n/**********************************************************************/\n/* For each DQE queue, process all DQE's.                             */\n/**********************************************************************/\n\nSYSCALL PROCESS_DQE BELOW &POINTER 00\nSYSCALL PROCESS_DQE ANY   &POINTER 08\nSYSCALL PROCESS_DQE ABOVE &POINTER 10\n\n/******************************************************************/\n/* Display the table of DQE's                                     */\n/******************************************************************/\n\n%IPTBDISP DQE THING(&THING) ADDRESS(&ADDRESS) EXTRA('&EXTRA')\n\nEXIT\n\nPROCESS_DQE: PROC 3 DQETYPE P OFFSET\n\n TCBEXIT YITADDR &P..+&OFFSET+0 POS(+0)\n SET LOCATIVE = &STR(&YITHEX)\n EVAL &LOCATIVE..+0 LE(4) PTR CLIST(S(DQEADDR))\n EVAL &LOCATIVE..+4 LE(4) PTR CLIST(S(DQELADDR))\n\n DO UNTIL &STR(&DQEADDR) = &STR(&DQELADDR) +\n     WHILE &STR(&DQEADDR) ^= &STR(&LOCATIVE)\n  SET A = &STR(&DQEADDR)\n  SET T = &STR(&DQETYPE)\n  ISPEXEC TBVCLEAR DQETBL\n  SET DQEADDR = &STR(&A)\n  SET DQETYPE = &STR(&T)\n  EVAL &DQEADDR..+00 LE(4) PTR DIALOG(S(DQENEXT))\n  EVAL &DQEADDR..+04 LE(4) PTR DIALOG(S(DQEPREV))\n  EVAL &DQEADDR..+08 LE(4) PTR DIALOG(S(DQEFFQE))\n  EVAL &DQEADDR..+0C LE(4) PTR DIALOG(S(DQELFQE))\n  EVAL &DQEADDR..+10 LE(4) PTR DIALOG(S(DQEAREA))\n  EVAL &DQEADDR..+14 LE(4) HEX DIALOG(S(DQESIZE))\n\n/**********************************************************************/\n/* Add DQE info to the table.                                         */\n/**********************************************************************/\n\n  IF &DQEFFQE = &DQELFQE && &DQEFFQE = &DQEADDR THEN DO\n   SET DQEFFQE =\n   SET DQELFQE =\n  END\n\n  ISPEXEC TBADD DQETBL\n\n/**********************************************************************/\n/* Chain to next DQE.                                                 */\n/**********************************************************************/\n\n  SET DQEADDR = &STR(&DQENEXT)\n\n END\n\nEND PROCESS_DQE\n./ ADD NAME=IPVSFQE\n\n/**********************************************************************/\n/*                                                                    */\n/* This CLIST is invoked by IPVVDQE.  Table DQETBL must be open.      */\n/*                                                                    */\n/* Reference: MVS/XA SLL: Virtual Storage Management, Part I          */\n/*            LY28-1790-0                                             */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 0 XTRACE\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\n\n/**********************************************************************/\n/* Get the variables from the current table row.                      */\n/**********************************************************************/\n\nISPEXEC TBGET DQETBL\nIF &STR(&DQEFFQE) = THEN DO\n ISPEXEC SETMSG MSG(IPZ005)\n EXIT\nEND\n\n/**********************************************************************/\n/* Access information from FQE's.\n/**********************************************************************/\n\nISPEXEC TBCREATE FQETBL +\n        KEYS() +\n        NAMES(FQESEL FQEADDR +\n              FQEAREA FQESIZE +\n              EFQEAREA +\n             ) +\n        NOWRITE REPLACE\n\n/**********************************************************************/\n/* For each DQE queue, process all FQE's                              */\n/**********************************************************************/\n\nIF &STR(&DQEFFQE) = &STR(&DQEADDR) THEN DO\n GOTO DISP\nEND\n\nSET FQEADDR = &STR(&DQEFFQE)\nDO UNTIL &STR(&A)        = &STR(&DQELFQE) +\n   WHILE &STR(&FQEADDR) ^= &STR(&DQEADDR)\n INTEGER X'&FQEADDR' PTR DIALOG(S(FQEADDR))\n SET A = &STR(&FQEADDR)\n ISPEXEC TBVCLEAR FQETBL\n SET FQEADDR = &STR(&A)\n EVAL &FQEADDR..+00 LE(4) PTR CLIST(S(FQEAREA))\n EVAL &FQEADDR..+04 LE(4) HEX CLIST(S(FQESIZE))\n EVAL &FQEADDR..+08 LE(4) PTR CLIST(S(FQENEXT))\n\n TCBEXIT YITADDR &FQEAREA..+&FQESIZE POS(+0)\n SET EFQEAREA = &SUBSTR(1:8,&YITHEX        )\n\n ISPEXEC TBADD FQETBL\n\n/**********************************************************************/\n/* Chain to next FQE.                                                 */\n/**********************************************************************/\n\n SET A = &STR(&FQEADDR)\n SET FQEADDR = &STR(&FQENEXT)\n\nEND\n\n/******************************************************************/\n/* Display the table of DE's                                      */\n/******************************************************************/\n\nDISP:+\n%IPTBDISP FQE ADDRESS(&DQEADDR) &XTRACE\n   SET SELCMD = &STR(%DUMPCB AREA &FQEAREA.. X'&FQESIZE')\n\n./ ADD NAME=IPVSLSQA\nPROC 1 TCBADDR XTRACE\n/**********************************************************************/\n/* This subprocedure analyzes local system queue area virtual storage.*/\n/**********************************************************************/\n\nNGLOBAL ASCBLDA\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\n\n/**********************************************************************/\n/* LSQA areas are accessed as follows:                                */\n/* ASCB -> LDA -> AQAT,SQAT                                           */\n/* TCB -> AE                                                          */\n/**********************************************************************/\n\nEVAL 224.?+30 L(4) PTR CLIST(S(ASCBLDA))\nIF &LASTCC=12 THEN DO\n NOTE 'IPVSM: Error accessing ASCBLDA at 224.?+30' ASIS\n EXIT C(16) Q\nEND\n\n/******************************************************************/\n/* Create table of DFE's for this LDA                             */\n/******************************************************************/\n\nISPEXEC TBCREATE DFETBL +\n        KEYS() +\n        NAMES(DFESEL DFEADDR DFETYPE DFESPID +\n              DFEANEXT DFEAPREV DFESNEXT DFESPREV DFEAREA DFESIZE +\n              DFEAREAN DFESIZEN +\n             ) +\n        NOWRITE REPLACE\n\n/******************************************************************/\n/* Extract pointers from the LDA                                  */\n/******************************************************************/\n\nEVAL &ASCBLDA..+04 L(4) PTR CLIST(S(LDASQAT))\nEVAL &ASCBLDA..+08 L(4) PTR CLIST(S(LDAAQAT))\nEVAL &ASCBLDA..+1C L(4) PTR CLIST(S(LDAESQAT))\nEVAL &ASCBLDA..+20 L(4) PTR CLIST(S(LDAEAQAT))\nEVAL &ASCBLDA..+0C L(4) PTR CLIST(S(LDAADF))   /* -> first  DFE\nEVAL &ASCBLDA..+10 L(4) PTR CLIST(S(LDAADL))   /* -> last   DFE\nEVAL &ASCBLDA..+24 L(4) PTR CLIST(S(LDAEADF))  /* -> first EDFE\nEVAL &ASCBLDA..+28 L(4) PTR CLIST(S(LDAEADL))  /* -> last  EDFE\nEVAL &ASCBLDA..+34 L(4) PTR CLIST(S(LDAFBQAF)) /* -> first  FBQE\nEVAL &ASCBLDA..+38 L(4) PTR CLIST(S(LDAFBQAL)) /* -> last   FBQE\nEVAL &ASCBLDA..+44 L(4) PTR CLIST(S(LDAEBQAF)) /* -> first EFBQE\nEVAL &ASCBLDA..+48 L(4) PTR CLIST(S(LDAEBQAL)) /* -> last  EFBQE\n\n/**********************************************************************/\n/* Process all the DFE's                                              */\n/**********************************************************************/\n\nSYSCALL PROCESS_DFE &LDAADF &LDAADL &XTRACE\nSYSCALL PROCESS_DFE &LDAEADF &LDAEADL EXTENDED &XTRACE\n\n%IPTBDISP DFE THING(LDA) ADDR(&ASCBLDA)\n\nEXIT\n\n\nPROCESS_DFE: PROC 2 FIRSTDFE LASTDFE EXTENDED XTRACE\n SET DFEADDR = &STR(&FIRSTDFE)\n DO UNTIL &STR(&A)        = &STR(&FIRSTDFE) +\n\n  INTEGER X'&DFEADDR' PTR DIALOG(S(DFEADDR))\n  SET A = &STR(&DFEADDR)\n  ISPEXEC TBVCLEAR DFETBL\n  SET DFEADDR = &STR(&A)\n  EVAL &DFEADDR..+00 LE(4) PTR DIALOG(S(DFEANEXT))\n  EVAL &DFEADDR..+04 LE(4) PTR DIALOG(S(DFEAPREV))\n  EVAL &DFEADDR..+08 LE(4) PTR DIALOG(S(DFESNEXT))\n  EVAL &DFEADDR..+0C LE(4) PTR DIALOG(S(DFESPREV))\n  EVAL &DFEADDR..+10 LE(4) PTR DIALOG(S(DFEAREA))\n  EVAL &DFEADDR..+14 LE(4) PTR DIALOG(S(DFESIZE))\n  EVAL &DFEADDR..+10 LE(4) SIG DIALOG(S(DFEAREAN))\n  EVAL &DFEADDR..+14 LE(4) SIG DIALOG(S(DFESIZEN))\n\n/**********************************************************************/\n/* Add DFE info to the table.                                         */\n/**********************************************************************/\n\n  IF &DFEAREAN = 0 && &DFESIZEN = 0 THEN SET DFETYPE = DUMMY\n  ELSE SET DFETYPE =\n  SET DFESPID = &STR(   )\n  IF &EXTENDED = EXTENDED THEN SET DFETYPE = E&DFETYPE\n  ISPEXEC TBADD DFETBL\n\n/**********************************************************************/\n/* Chain to next DFE.                                                 */\n/**********************************************************************/\n\n  SET DFEADDR = &STR(&DFEANEXT)\n  SET A       = &STR(&DFEADDR)\n END\n\nEND PROCESS_DFE\n\n./ ADD NAME=IPVSPMAP\n\n/**********************************************************************/\n/*                                                                    */\n/* This CLIST produces a table displaying allocated virtual storage.  */\n/*                                                                    */\n/* Reference: MVS/XA SLL: Virtual Storage Management, Part I          */\n/*            LY28-1790-0                                             */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 1 TCBADDRESS SUBPOOLLIST() LINEMODEVALUE XTRACEVALUE\nNGLOBAL TCBADDR SUBPOOLS XTRACE LINEMODE +\n        ZERRSM ZERRLM ZERRMSG ZERRHM ZERRALRM +\n        PMAPSEL PMAPTYPE PMAPTCB PMAPSPID PMAPKEY PMAPSHR PMAPLOC +\n        PMAPAREA PMAPAREE PMAPSIZE +\n        PMAPARNA PMAPARNE PMAPSIZN\n\nIF &XTRACEVALUE ^= THEN DO\n CONTROL LIST CONLIST SYMLIST\n SET XTRACE = XTRACE\nEND\nELSE SET XTRACE =\nCONTROL NOCAPS\nSET LINEMODE = &STR(&LINEMODEVALUE)\nSET TCBADDR  = &STR(&TCBADDRESS..)\nSET SUBPOOLS = &STR(&SUBPOOLLIST)\n\nIF &LINEMODE ^= THEN DO\n NOTE SPACE(1)\n NOTE '--- IPCS Virtual Storage Map for TCB at &TCBADDRESS.. ---' ASIS\n NOTE SPACE(1)\n NOTE 'Type  Owner TCB  Subpool Key Shared  Location  +\n       From      To        Size' ASIS\n NOTE SPACE(1)\nEND\n\n/**********************************************************************/\n/* Access subpools by SPQE.  There are 3 pointers to SPQE's in TCB:   */\n/*                                                                    */\n/* TCBSWA    -> SPQE chain for subpools 236 & 237 (SWA)               */\n/* TCBUKYSP  -> SPQE chain for subpools 229 & 230 (auth. user keys)   */\n/* TCBMSS    -> SPQE chain for other subpools (user)                  */\n/*                                                                    */\n/**********************************************************************/\n\nEVAL &TCBADDR+18 L(4) PTR CLIST(S(TCBMSS))\nIF &LASTCC=12 THEN DO\n NOTE 'PMAP: Error accessing TCBMSS at &TCBADDR+18' ASIS\n EXIT C(16) Q\nEND\n\nEVAL &TCBADDR+F8 L(4) PTR CLIST(S(TCBSWA))\nIF &LASTCC=12 THEN DO\n NOTE 'PMAP: Error accessing TCBSWA at &TCBADDR+F8' ASIS\n EXIT C(16) Q\nEND\n\nEVAL &TCBADDR+10C L(4) PTR CLIST(S(TCBUKYSP))\nIF &LASTCC=12 THEN DO\n NOTE 'PMAP: Error accessing TCBUKYSP at &TCBADDR+10C' ASIS\n EXIT C(16) Q\nEND\n\n/******************************************************************/\n/* Create table to contain all virtual storage info               */\n/******************************************************************/\n\nIF &LINEMODE = THEN +\n ISPEXEC TBCREATE PMAPTBL +\n         KEYS() +\n         NAMES(PMAPSEL +\n               PMAPTYPE PMAPTCB PMAPSPID PMAPKEY PMAPSHR PMAPLOC +\n               PMAPAREA PMAPAREE PMAPSIZE +\n               PMAPARNA PMAPARNE PMAPSIZN +\n              ) +\n         NOWRITE REPLACE\n\n/**********************************************************************/\n/* For each SPQE queue, process all SPQE's                            */\n/**********************************************************************/\n\nSYSCALL PROCESS_SPQE USR &TCBMSS\nSYSCALL PROCESS_SPQE AUK &TCBUKYSP\nSYSCALL PROCESS_SPQE SWA &TCBSWA\n\nIF &LINEMODE = THEN +\n %IPTBDISP PMAP ADDRESS(&TCBADDR) &XTRACE\n\nEXIT C(0)\n\nPROCESS_SPQE: PROC 2 PTYPE PADDR\n\n SET SPQEADDR = &STR(&PADDR)\n\n DO WHILE &SPQEADDR ^= 0\n  EVAL &SPQEADDR..+11 LE(1) UNS DIALOG(S(SPQEID))\n  IF &STR(&SUBPOOLS) ^= THEN DO\n   SELECT &SPQEID\n    WHEN (&SUBPOOLS)\n    OTHERWISE GOTO SKIPSP\n   END\n  END\n  INTEGER X'&SPQEADDR' PTR DIALOG(S(SPQEADDR))\n  EVAL &SPQEADDR..+08 LE(4) PTR DIALOG(S(SPQESPQA))\n  EVAL &SPQEADDR..+0C LE(4) PTR DIALOG(S(SPQETCB))\n  EVAL &SPQEADDR..+12 LE(1) UNS CLIST(S(KEYTIMES16))\n  SET SPQEKEY = &KEYTIMES16 / 16\n  COMPARE ADDR(&SPQEADDR..+13) WITH(VALUE(X'80')) LE(1) MASK(X'80')\n  IF &LASTCC = 0 THEN SET SPQESHR = YES\n  ELSE SET SPQESHR = NO\n\n/**********************************************************************/\n/* Set table variables from SPQE info.                                */\n/**********************************************************************/\n\n  SET PMAPSEL  =\n  SET PMAPTYPE = &STR(&PTYPE)\n  SET PMAPTCB  = &STR(&SPQETCB)\n  SET PMAPSPID = &STR(&SPQEID)\n  SET PMAPKEY  = &STR(&SPQEKEY)\n  SET PMAPSHR  = &STR(&SPQESHR)\n\n/**********************************************************************/\n/* Process info from SPQA and DQE queue for this SPQE.                */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Access information from SPQA.  We retrieve information from the    */\n/* DFE's chained thereoff, and create a table of DQE's.               */\n/*                                                                    */\n/* There are 3 queues of DQE's.                                       */\n/*                                                                    */\n/* SPQA + 00  ==> first DQE for storage backed below 16M              */\n/* SPQA + 04  ==> last  DQE for storage backed below 16M              */\n/* SPQA + 08  ==> first DQE for storage backed anywhere               */\n/* SPQA + 0C  ==> last  DQE for storage backed anywhere               */\n/* SPQA + 10  ==> first DQE for storage backed above 16M (????)       */\n/* SPQA + 14  ==> last  DQE for storage backed above 16M (????)       */\n/*                                                                    */\n/**********************************************************************/\n\n/**********************************************************************/\n/* For each DQE queue, process all DQE's                              */\n/**********************************************************************/\n\n  SYSCALL PROCESS_DQE BELOW &SPQESPQA 00\n  SYSCALL PROCESS_DQE ANY   &SPQESPQA 08\n  SYSCALL PROCESS_DQE ABOVE &SPQESPQA 10\n\n\n\n/**********************************************************************/\n/* Chain to next SPQE.                                                */\n/**********************************************************************/\n\n  SKIPSP:+\n  EVAL &SPQEADDR..+00 LE(4) PTR CLIST(S(SPQEADDR))\n  IF &LASTCC=12 THEN DO\n   NOTE '==> Error: Next SPQE not available from &SPQEADDR' ASIS\n   EXIT C(4)\n  END\n\n END\n\nEND PROCESS_SPQE\n\nPROCESS_DQE: PROC 3 DQETYPE SPQESPQA OFFSET\n\n SET LOCATIVE =\n SYSCALL ADDRESSIFY LOCATIVE &SPQESPQA..+&OFFSET\n\n EVAL &LOCATIVE..+0 LE(4) PTR CLIST(S(DQEADDR))\n EVAL &LOCATIVE..+4 LE(4) PTR CLIST(S(DQELADDR))\n\n DO UNTIL &STR(&DQEADDR) = &STR(&DQELADDR) +\n     WHILE &STR(&DQEADDR) ^= &STR(&LOCATIVE)\n  INTEGER X'&DQEADDR' PTR CLIST(S(DQEADDR))\n  EVAL &DQEADDR..+00 LE(4) PTR    CLIST(S(DQENEXT))\n  EVAL &DQEADDR..+04 LE(4) PTR    CLIST(S(DQEPREV))\n  EVAL &DQEADDR..+08 LE(4) PTR    CLIST(S(DQEFFQE))\n  EVAL &DQEADDR..+0C LE(4) PTR    CLIST(S(DQELFQE))\n  EVAL &DQEADDR..+10 LE(4) SIGNED CLIST(S(DQEAREA))\n  EVAL &DQEADDR..+14 LE(4) SIGNED CLIST(S(DQESIZE))\n\n/**********************************************************************/\n/* Set table variables from DQE info.                                 */\n/**********************************************************************/\n\n  SET PMAPLOC  = &STR(&DQETYPE)\n\n/**********************************************************************/\n/* For each DQE, process all FQE's                                    */\n/**********************************************************************/\n\n  SYSCALL PROCESS_FQE &DQEADDR &DQEAREA &DQESIZE &DQEFFQE &DQELFQE\n\n/**********************************************************************/\n/* Chain to next DQE.                                                 */\n/**********************************************************************/\n\n  SET DQEADDR = &STR(&DQENEXT)\n\n END\n\nEND PROCESS_DQE\n\n\nPROCESS_FQE: PROC 5 DQEADDR DQEAREA DQESIZE DQEFFQE DQELFQE\n\n/**********************************************************************/\n/* If there are no FQE's, the entire area defined by this DQE is      */\n/* allocated.  Add it to the table as a single entry (e.g. 4K block). */\n/**********************************************************************/\n\n IF &STR(&DQEFFQE) = &STR(&DQEADDR) THEN DO\n  SET PMAPARNA = &DQEAREA\n  SET PMAPSIZN = &DQESIZE\n  SYSCALL TBADD\n END\n\n ELSE DO\n  SET ALLOCAREA = &DQEAREA\n  SET ALLOCEND = &DQEAREA + &DQESIZE\n  SET FQEADDR = &STR(&DQEFFQE)\n  DO UNTIL &STR(&A)        = &STR(&DQELFQE) +\n     WHILE &STR(&FQEADDR) ^= &STR(&DQEADDR)\n   INTEGER X'&FQEADDR' PTR DIALOG(S(FQEADDR))\n   EVAL &FQEADDR..+00 LE(4) SIGNED CLIST(S(FQEAREA))\n   EVAL &FQEADDR..+04 LE(4) SIGNED CLIST(S(FQESIZE))\n   EVAL &FQEADDR..+08 LE(4) PTR    CLIST(S(FQENEXT))\n\n   IF &FQESIZE > 16777215 THEN DO\n    WRITE DQEADDR = &DQEADDR\n    WRITE FQEADDR = &FQEADDR\n    EVAL &FQEADDR..+00 LE(4) PTR    CLIST(S(FQEAREAP))\n    WRITE +0 FQEAREA = &FQEAREAP\n    EVAL &FQEADDR..+04 LE(4) PTR    CLIST(S(FQESIZEP))\n    WRITE +4 FQESIZE = &FQESIZEP\n    WRITE +8 FQENEXT = &FQENEXT\n   END\n\n/**********************************************************************/\n/* Since the FQE's map chunks of free storage, interpolate where the  */\n/* allocated storage is and create table entries for the allocated    */\n/* storage, not the free storage.                                     */\n/**********************************************************************/\n\n   SET PMAPSIZN = &FQEAREA - &ALLOCAREA\n   IF &PMAPSIZN ^= 0 THEN DO\n    SET PMAPARNA = &ALLOCAREA\n    SYSCALL TBADD\n   END\n\n   SET ALLOCAREA = &FQEAREA + &FQESIZE\n\n/**********************************************************************/\n/* Chain to next FQE.                                                 */\n/**********************************************************************/\n\n   SET A = &STR(&FQEADDR)\n   SET FQEADDR = &STR(&FQENEXT)\n  END\n\n/**********************************************************************/\n/* Check last possible unfreed chunk.                                 */\n/**********************************************************************/\n\n  SET PMAPSIZN = &ALLOCEND - &ALLOCAREA\n  IF &PMAPSIZN ^= 0 THEN DO\n   SET PMAPARNA = &ALLOCAREA\n   SYSCALL TBADD\n  END\n\n END\n\nEND PROCESS_FQE\n\nTBADD: PROC 0\n SET PMAPARNE = &PMAPARNA + &PMAPSIZN\n INTEGER &PMAPARNA PTR(8) CLIST(S(PMAPAREA))\n INTEGER &PMAPARNE PTR(8) CLIST(S(PMAPAREE))\n INTEGER &PMAPSIZN PTR    CLIST(S(PMAPSIZE))\n IF &LENGTH(&STR(&PMAPTCB)) = 8 && +\n    &SUBSTR(1:2,&PMAPTCB) = &STR(00) THEN DO\n  SET PMAPTCB = &SUBSTR(3:8,&PMAPTCB)\n END\n IF &LINEMODE ^= THEN +\n  NOTE ' &PMAPTYPE   &PMAPTCB      &PMAPSPID    &PMAPKEY   +\n        &PMAPSHR      &PMAPLOC   &PMAPAREA  &PMAPAREE   &PMAPSIZE +\n       ' ASIS\n ELSE +\n  ISPEXEC TBADD PMAPTBL\n RETURN\nEND\n\nADDRESSIFY: PROC 2 NEWADDRESS OLDADDRESS\n SYSREF NEWADDRESS\n TCBEXIT YITADDR &NRSTR(&OLDADDRESS) POSITION(+0)\n IF &LASTCC ^= 0 THEN DO\n  NOTE 'Invalid address: &NRSTR(&OLDADDRESS)' ASIS\n  EXIT C(16) Q\n END\n SET NEWADDRESS = &STR(&YITHEX)\n RETURN\nEND ADDRESSIFY\n\n./ ADD NAME=IPVSPVT\n\nPROC 1 TCBADDR XTRACE\n\n/**********************************************************************/\n/* This procedure analyzes private area virtual storage.              */\n/**********************************************************************/\n\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nSET TCBADDR = &STR(&TCBADDR..)\n\n/**********************************************************************/\n/* Access subpools by SPQE.  There are 3 pointers to SPQE's in TCB:   */\n/*                                                                    */\n/* TCBSWA    -> SPQE chain for subpools 236 & 237 (SWA)               */\n/* TCBUKYSP  -> SPQE chain for subpools 229 & 230 (auth. user keys)   */\n/* TCBMSS    -> SPQE chain for other subpools (user)                  */\n/*                                                                    */\n/**********************************************************************/\n\nEVAL &TCBADDR+18 L(4) PTR CLIST(S(TCBMSS))\nIF &LASTCC=12 THEN DO\n NOTE 'IPVSM: Error accessing TCBMSS at &TCBADDR+18' ASIS\n EXIT C(16) Q\nEND\n\nEVAL &TCBADDR+F8 L(4) PTR CLIST(S(TCBSWA))\nIF &LASTCC=12 THEN DO\n NOTE 'IPVSM: Error accessing TCBSWA at &TCBADDR+F8' ASIS\n EXIT C(16) Q\nEND\n\nEVAL &TCBADDR+10C L(4) PTR CLIST(S(TCBUKYSP))\nIF &LASTCC=12 THEN DO\n NOTE 'IPVSM: Error accessing TCBUKYSP at &TCBADDR+10C' ASIS\n EXIT C(16) Q\nEND\n\n/******************************************************************/\n/* Create table to contain subpool ID's for this TCB              */\n/******************************************************************/\n\nISPEXEC TBCREATE SPQETBL +\n        KEYS() +\n        NAMES(SPQESEL SPQEQTYP SPQEADDR +\n              SPQESPQA SPQETCB SPQEID SPQEKEY SPQESHR +\n             ) +\n        NOWRITE REPLACE\n\n/**********************************************************************/\n/* For each SPQE queue, process all SPQE's                            */\n/**********************************************************************/\n\nSYSCALL PROCESS_SPQE MSS &TCBMSS    &XTRACE\nSYSCALL PROCESS_SPQE SWA &TCBSWA    &XTRACE\nSYSCALL PROCESS_SPQE AUK &TCBUKYSP  &XTRACE\n\n/******************************************************************/\n/* Display the table of SPQE's                                   */\n/******************************************************************/\n\n%IPTBDISP SPQE ADDRESS(&TCBADDR)\n\nEXIT\n\n\nPROCESS_SPQE: PROC 2 SPQEQTYP SPQEADDR XTRACE\n\n DO WHILE &SPQEADDR ^= 0\n  INTEGER X'&SPQEADDR' PTR DIALOG(S(SPQEADDR))\n  SET A = &STR(&SPQEADDR)\n  SET Q = &STR(&SPQEQTYP)\n  ISPEXEC TBVCLEAR SPQETBL\n  SET SPQEADDR = &STR(&A)\n  SET SPQEQTYP = &STR(&Q)\n  EVAL &SPQEADDR..+08 LE(4) PTR DIALOG(S(SPQESPQA))\n  EVAL &SPQEADDR..+0C LE(4) PTR DIALOG(S(SPQETCB))\n  EVAL &SPQEADDR..+11 LE(1) UNS DIALOG(S(SPQEID))\n  EVAL &SPQEADDR..+12 LE(1) UNS CLIST(S(KEYTIMES16))\n  SET SPQEKEY = &KEYTIMES16 / 16\n  COMPARE ADDR(&SPQEADDR..+13) WITH(VALUE(X'80')) LE(1) MASK(X'80')\n  IF &LASTCC = 0 THEN SET SPQESHR = YES\n  ELSE SET SPQESHR = NO\n\n/**********************************************************************/\n/* Add SPQE info to the table.                                        */\n/**********************************************************************/\n\n  ISPEXEC TBADD SPQETBL\n\n/**********************************************************************/\n/* Chain to next SPQE.                                                */\n/**********************************************************************/\n\n  EVAL &SPQEADDR..+00 LE(4) PTR CLIST(S(SPQEADDR))\n  IF &LASTCC=12 THEN DO\n   NOTE '==> Error: Next SPQE not available from &SPQEADDR' ASIS\n   EXIT C(4)\n  END\n END\nEND\n./ ADD NAME=IPVSSA\nPROC 1 TCBADDR XTRACE\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOFLUSH NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n WRITE *** You must be in IPCS to use this CLIST. ***\n EXIT C(16) Q\nEND\nEVAL &TCBADDR+138?+14 PTR CLIST(S(VSSAPTR))\nIF &LASTCC = 12 THEN GOTO FAIL\nIF &VSSAPTR = 0 THEN GOTO FAIL\nTCBEXIT IEAVSSA1 &TCBADDR\nEXIT\nFAIL: NOTE 'No vector stuff for TCB at &TCBADDR.' ASIS\nEXIT\n./ ADD NAME=IPVSSPT\nPROC 0 THING(SPT) ADDRESS(&SPTADDR) EXTRA() XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\n\n/**********************************************************************/\n/* Get the variables from the current table row.                      */\n/**********************************************************************/\n\nISPEXEC TBGET &THING.TBL\n\n/**********************************************************************/\n/* Create a table to hold the DQE entries.                            */\n/**********************************************************************/\n\nISPEXEC TBCREATE DQETBL +\n        KEYS() +\n        NAMES(DQESEL DQETYPE DQEADDR +\n              DQEFFQE DQELFQE DQEAREA DQESIZE +\n             ) +\n        NOWRITE REPLACE\n\n/**********************************************************************/\n/* Access information from SPQA or SPT.  We retrieve info from the    */\n/* DFE's chained thereoff, and create a table of DQE's.               */\n/*                                                                    */\n/* There are 3 queues of DQE's.                                       */\n/*                                                                    */\n/* (In the following, \"Thing\" is SPSA (for private) or SPT (for CSA). */\n/*                                                                    */\n/* Thing + 00 ==> first DQE for storage backed below 16M              */\n/* Thing + 04 ==> last  DQE for storage backed below 16M              */\n/* Thing + 08 ==> first DQE for storage backed anywhere               */\n/* Thing + 0C ==> last  DQE for storage backed anywhere               */\n/* Thing + 10 ==> first DQE for storage backed above 16M (????)       */\n/* Thing + 14 ==> last  DQE for storage backed above 16M (????)       */\n/*                                                                    */\n/**********************************************************************/\n\n/**********************************************************************/\n/* For each DQE queue, process all DQE's.                             */\n/**********************************************************************/\n\nSYSCALL PROCESS_DQE BELOW &ADDRESS 00\nSYSCALL PROCESS_DQE ANY   &ADDRESS 08\nSYSCALL PROCESS_DQE ABOVE &ADDRESS 10\n\n/******************************************************************/\n/* Display the table of DQE's                                     */\n/******************************************************************/\n\n%IPTBDISP DQE THING(&THING) ADDRESS(&ADDRESS) EXTRA('&EXTRA')\n\nEXIT\n\n\nPROCESS_DQE: PROC 3 DQETYPE P OFFSET\n\n TCBEXIT YITADDR &P..+&OFFSET+0 POS(+0)\n SET LOCATIVE = &STR(&YITHEX)\n EVAL &LOCATIVE..+0 LE(4) PTR CLIST(S(DQEADDR))\n EVAL &LOCATIVE..+4 LE(4) PTR CLIST(S(DQELADDR))\n\n DO UNTIL &STR(&DQEADDR) = &STR(&DQELADDR) +\n     WHILE &STR(&DQEADDR) ^= &STR(&LOCATIVE)\n  SET A = &STR(&DQEADDR)\n  SET T = &STR(&DQETYPE)\n  ISPEXEC TBVCLEAR DQETBL\n  SET DQEADDR = &STR(&A)\n  SET DQETYPE = &STR(&T)\n  EVAL &DQEADDR..+00 LE(4) PTR DIALOG(S(DQENEXT))\n  EVAL &DQEADDR..+04 LE(4) PTR DIALOG(S(DQEPREV))\n  EVAL &DQEADDR..+08 LE(4) PTR DIALOG(S(DQEFFQE))\n  EVAL &DQEADDR..+0C LE(4) PTR DIALOG(S(DQELFQE))\n  EVAL &DQEADDR..+10 LE(4) PTR DIALOG(S(DQEAREA))\n  EVAL &DQEADDR..+14 LE(4) HEX DIALOG(S(DQESIZE))\n\n/**********************************************************************/\n/* Add DQE info to the table.                                         */\n/**********************************************************************/\n\n  IF &DQEFFQE = &DQELFQE && &DQEFFQE = &DQEADDR THEN DO\n   SET DQEFFQE =\n   SET DQELFQE =\n  END\n\n  ISPEXEC TBADD DQETBL\n\n/**********************************************************************/\n/* Chain to next DQE.                                                 */\n/**********************************************************************/\n\n  SET DQEADDR = &STR(&DQENEXT)\n\n END\n\nEND PROCESS_DQE\n./ ADD NAME=IPVSSPTO\n\n/**********************************************************************/\n/*                                                                    */\n/* Old version of IPVSSPTT, tries to display ALL subpool data.  !!!   */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 1 TCBADDR XTRACE\nNGLOBAL SPTTADDR\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nEVALSYM GDA\nIF &LASTCC = 12 THEN DO\n NOTE 'The GDA symbol (global data area) is not defined.' ASIS\n EXIT C(12) Q\nEND\nEVALDUMP CLIST(DSN(EVALDUMPDSN))\nIF &STR(&EVALDUMPDSN) ^= ACTIVE THEN DO\n NOTE SPACE(1)\n NOTE 'Warning: Viewing active SPTT.  It''s not in the dump!' ASIS\n NOTE SPACE(1)\nEND\nEVAL 10.?+230?+D4 LE(4) PTR CLIST(S(GDASPTT)) ACTIVE\nIF &LASTCC = 12 | &GDASPTT = 0 THEN DO\n NOTE 'Error: No valid GDASPTT pointer.' ASIS\n EXIT C(12) Q\nEND\n\nINTEGER X'&GDASPTT' UNS CLIST(S(NGDASPTT))\n\n NOTE SPACE(1)\n NOTE 'SPTT at &GDASPTT' ASIS\n NOTE SPACE(1)\n\nDO &SPNO = 0 TO 255\n\n EVAL &GDASPTT..+4+&SPNO.N L(1) UNS CLIST(S(SPINDEX)) ACTIVE\n INTEGER &EVAL(&NGDASPTT+260+10*(&SPINDEX-1)) PTR CLIST(S(SPTTADDR))\n\n NOTE SPACE(1)\n NOTE 'Data for subpool &SPNO at &SPTTADDR (index is &SPINDEX)' ASIS\n NOTE SPACE(1)\n\n SYSCALL SHOW SPTT     00 HEX L(10) T('Subpool translation table entry')\n NOTE SPACE(1)\n\n SYSCALL SHOW SPTTTYPE 00 HEX L(1) T('Type of storage')\n SYSCALL SHOW SPTTOWN  01 HEX L(1) T('Storage ownership')\n SYSCALL SHOW SPTTCHAR 02 HEX L(1) T('Storage characteristics')\n SYSCALL SHOW SPTTFLGS 04 HEX L(1) T('Miscellaneous flags')\n SYSCALL SHOW SPTTKEY  05 UNS L(1) T('Specific key if one exists')\n SYSCALL SHOW SPTTSPID 07 UNS L(1) T('Internal subpool ID')\n\n END\n\n\nEXIT\n\nSHOW: PROC 2 NAME OFFSET TITLE() LENGTHVALUE(4) +\n             POINTER PTR CHARACTER SIGNED UNSIGNED HEX\n\n CONTROL MSG\n INTEGER X'&SPTTADDR'   SIGNED CLIST(S(V1))\n INTEGER X'&OFFSET'     SIGNED CLIST(S(V2))\n INTEGER &EVAL(&V1+&V2) PTR(8) CLIST(S(V3))\n\n EVAL &V3          L(&LENGTHVALUE) CLIST(S(DATA)) ACTIVE +\n                   &POINTER &PTR &CHARACTER &SIGNED &UNSIGNED &HEX\n SET EVALCC = &LASTCC\n IF &EVALCC ^= 0 THEN SET DATA = &STR(LASTCC=&EVALCC)\n\n NOTE '&SUBSTR(1:8,&V3         ) +\n       &SUBSTR(1:8,&NAME       ) +\n       &SUBSTR(1:16,&NRSTR(&DATA                ))  &NRSTR(&TITLE)' ASIS\n\nEND SHOW\n\n./ ADD NAME=IPVSSPTT\nPROC 1 TCBADDR SUBPOOL() GDAADDRESS() XTRACE\nNGLOBAL SPTTADDR\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nIF &SUBPOOL ^= THEN DO\n SYSCALL DO_ONE &SUBPOOL GDASPTT(&GDAADDRESS)\n EXIT\nEND\nEVALSYM GDA\nIF &LASTCC = 12 THEN DO\n NOTE 'The GDA symbol (global data area) is not defined.' ASIS\n EXIT C(12) Q\nEND\nEVALDUMP CLIST(DSN(EVALDUMPDSN))\nIF &STR(&EVALDUMPDSN) ^= ACTIVE THEN DO\n SET WARNING = &STR(+\n                  Warning: Viewing active SPTT.  It's not in the dump!)\nEND\nELSE SET WARNING =\nEVAL 10.?+230?+D4 LE(4) PTR CLIST(S(GDASPTT)) ACTIVE\nIF &LASTCC = 12 | &GDASPTT = 0 THEN DO\n NOTE 'Error: No valid GDASPTT pointer.' ASIS\n EXIT C(12) Q\nEND\n\nDISPLAY:+\nISPEXEC DISPLAY PANEL(IPVSSPTT) /* sets SPNO */\nIF &LASTCC ^= 0 THEN EXIT\n\nISPEXEC SELECT PGM(BLSGSCMD) MODE(FSCR) +\n               PARM(%IPVSSPTT &TCBADDR SUBPOOL(&SPNO) GDA(&GDASPTT) +\n                              &XTRACE)\n\n\nGOTO DISPLAY\n\nDO_ONE: PROC 1 SPNO GDASPTT()\n\n /* Stupid code to get around SYSREF lossage.\n SET SYSDVAL =\n READDVAL SPTT SPTTTYPE SPTTOWN SPTTCHAR SPTTFLGS SPTTKEY SPTTSPID BITS\n\n INTEGER X'&GDASPTT' UNS CLIST(S(NGDASPTT))\n\n EVAL &GDASPTT..+4+&SPNO.N L(1) UNS CLIST(S(SPINDEX)) ACTIVE\n INTEGER &EVAL(&NGDASPTT+260+10*(&SPINDEX-1)) PTR CLIST(S(SPTTADDR))\n\n NOTE SPACE(1)\n NOTE 'Data for subpool &SPNO at &SPTTADDR (index is &SPINDEX)' ASIS\n NOTE SPACE(1)\n\n SYSCALL SHOW SPTT     00 HEX L(10) T('Subpool translation table entry')\n NOTE SPACE(1)\n\n SYSCALL SHOW SPTTTYPE 00 HEX L(1) T('Type of storage')\n SYSCALL SHOW SPTTOWN  01 HEX L(1) T('Storage ownership')\n SYSCALL SHOW SPTTCHAR 02 HEX L(1) T('Storage characteristics')\n SYSCALL SHOW SPTTFLGS 04 HEX L(1) T('Miscellaneous flags')\n SYSCALL SHOW SPTTKEY  05 UNS L(1) T('Specific key if one exists')\n SYSCALL SHOW SPTTSPID 07 UNS L(1) T('Internal subpool ID')\n\n SYSCALL SETBITS BITS SPTTCHAR\n IF &SUBSTR(1,&BITS) = 1 THEN SET SPTTFIX  =&STR(Fixed, )\n ELSE                         SET SPTTFIX  =&STR(Pageable, )\n IF &SUBSTR(2,&BITS) = 1 THEN SET SPTTPROT =&STR(fetch protected, )\n ELSE                         SET SPTTPROT =&STR(non-fetch protected, )\n IF &SUBSTR(3,&BITS) = 1 THEN SET SPTTVABV =&STR(allocated above 16M, )\n ELSE                         SET SPTTVABV =\n IF &SUBSTR(4,&BITS) = 1 THEN SET SPTTVBLW =&STR(allocated below 16M, )\n ELSE                         SET SPTTVBLW =\n IF &SUBSTR(5,&BITS) = 1 THEN SET SPTTREAL =&STR(backed anywhere, )\n ELSE                         SET SPTTREAL =&STR(backed below 16M, )\n IF &SUBSTR(6,&BITS) = 1 THEN SET SPTTFBQE =&STR(allocate high to low, )\n ELSE                         SET SPTTFBQE =&STR(allocate low to high, )\n IF &SUBSTR(7,&BITS) = 0 THEN SET SPTTK    =&STR(no specific key\n ELSE DO\n  IF &SUBSTR(8,&BITS) = 1 THEN SET SPTTK   =&STR(use TCB key\n  ELSE                         SET SPTTK   =&STR(use PSW key\n END\n\n SYSCALL SETBITS BITS SPTTFLGS\n NOTE SPACE(1)\n IF &SUBSTR(1,&BITS)=1 THEN +\n      SET SPTTDEF  = &STR(Subpool ID defined, )\n ELSE SET SPTTDEF  = &STR(Subpool ID undefined, )\n IF &SUBSTR(2,&BITS)=1 THEN +\n      SET SPTTAUTH = &STR(authorization required, )\n ELSE SET SPTTAUTH = &STR(no authorization required, )\n IF &SUBSTR(3,&BITS)=1 THEN +\n      SET SPTTEXTK = &STR(key can be externally specified, )\n ELSE SET SPTTEXTK = &STR(key cannot be externally specified, )\n IF &SUBSTR(4,&BITS)=1 THEN +\n      SET SPTTSPFM = &STR(can be subpool freed, )\n ELSE SET SPTTSPFM = &STR(cannot be subpool freed, )\n IF &SUBSTR(5,&BITS)=1 THEN +\n      SET SPTTGLSP = &STR(allowed on global entry, )\n ELSE SET SPTTGLSP = &STR(not allowed on global entry, )\n IF &SUBSTR(6,&BITS)=1 THEN +\n      SET SPTTROPT = &STR(real option can be externally specified, )\n ELSE SET SPTTROPT = &STR(real option cannot be externally specified, )\n IF &SUBSTR(7,&BITS)=1 THEN +\n      SET SPTTCONV = &STR(pages can be converted from another subpool, )\n ELSE SET SPTTCONV = &STR(+\n                       pages cannot be converted from another subpool, )\n IF &SUBSTR(8,&BITS)=1 THEN +\n    SET SPTTBACK = &STR(only first page is to be backed at GETMAIN time)\n ELSE SET SPTTBACK = &STR(all pages are to be backed at GETMAIN time)\n\n IF &SYSINDEX(undefined,&STR(&SPTTDEF)) ^= 0 THEN DO\n  NOTE SPACE(1)\n  NOTE 'This subpool (&SPNO) is undefined.' ASIS\n  NOTE SPACE(1)\n  RETURN\n END\n\n NOTE 'Storage characteristics:' SPACE(1) ASIS\n NOTE SPACE(1)\n NOTE '&SPTTFIX.&SPTTPROT.&SPTTV.&SPTTREAL' ASIS\n NOTE '&SPTTFBQE.&SPTTK' ASIS\n NOTE SPACE(1)\n NOTE '&SPTTDEF.&SPTTAUTH' ASIS\n NOTE '&SPTTEXTK.&SPTTSPFM' ASIS\n NOTE '&SPTTGLSP.&SPTTROPT' ASIS\n NOTE '&SPTTCONV' ASIS\n NOTE '&SPTTBACK' ASIS\n NOTE SPACE(1)\n\nEND\n\n\nSHOW: PROC 2 VAR  OFFSET TITLE() LENGTHVALUE(4) +\n             POINTER PTR CHARACTER SIGNED UNSIGNED HEX\n\n SET NAME = &STR(&VAR)\n SYSREF VAR\n INTEGER X'&SPTTADDR'   SIGNED CLIST(S(V1))\n INTEGER X'&OFFSET'     SIGNED CLIST(S(V2))\n INTEGER &EVAL(&V1+&V2) PTR(8) CLIST(S(V3))\n\n EVAL &V3          L(&LENGTHVALUE) CLIST(S(DATA)) ACTIVE +\n                   &POINTER &PTR &CHARACTER &SIGNED &UNSIGNED &HEX\n SET EVALCC = &LASTCC\n IF &EVALCC ^= 0 THEN SET DATA = &STR(LASTCC=&EVALCC)\n ELSE SET VAR = &NRSTR(&DATA)\n SELECT &POINTER&PTR&CHARACTER&SIGNED&UNSIGNED&HEX\n  WHEN (HEX)        SET DAT2 = &NRSTR(X\"&DATA\")\n  WHEN (CHARACTER)  SET DAT2 = &NRSTR(C\"&DATA\")\n  WHEN (SIGNED) DO\n   SELECT &LENGTHVALUE\n    WHEN (2)  SET DAT2 = &NRSTR(H\"&DATA\")\n    WHEN (4)  SET DAT2 = &NRSTR(F\"&DATA\")\n    OTHERWISE SET DAT2 = &NRSTR(&DATA)\n   END\n  END\n  WHEN (UNSIGNED) DO\n   SELECT &LENGTHVALUE\n    WHEN (1)  SET DAT2 = &NRSTR(YL1(&DATA))\n    WHEN (2)  SET DAT2 = &NRSTR(Y(&DATA))\n    WHEN (3)  SET DAT2 = &NRSTR(AL3(&DATA))\n    WHEN (4)  SET DAT2 = &NRSTR(A(&DATA))\n    OTHERWISE SET DAT2 = &NRSTR(&DATA)\n   END\n  END\n  OTHERWISE       SET DAT2 = &NRSTR(&DATA)\n END\n\n IF &LENGTH(&NRSTR(&DAT2)) > 16 THEN DO\n  NOTE '&SUBSTR(1:8,&V3         ) +\n        &SUBSTR(1:8,&NAME       ) +\n        &NRSTR(&DAT2)' ASIS\n  NOTE '                                    &NRSTR(&TITLE)' ASIS\n END\n ELSE DO\n  NOTE '&SUBSTR(1:8,&V3         ) +\n        &SUBSTR(1:8,&NAME       ) +\n        &SUBSTR(1:16,&NRSTR(&DAT2                ))  &NRSTR(&TITLE)' +\n        ASIS\n END\n\nEND SHOW\n\n\nSETBITS: PROC 2 BITS FROMWHAT\n SYSREF BITS FROMWHAT\n %BINARY X'&FROMWHAT'\n SET R = &LASTCC\n SET L = &LENGTH(&STR(&R))\n SET BITS = &SUBSTR(&L+1:&L+8,00000000&R)\nEND\n./ ADD NAME=IPVSSQA\nPROC 1 TCBADDR XTRACE\n/**********************************************************************/\n/* This procedure analyzes global system queue area virtual storage.  */\n/**********************************************************************/\n\nNGLOBAL CVTGDA\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nEVAL CVT+230 LE(4) PTR CLIST(S(CVTGDA))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error, GDA pointer not available' ASIS\n EXIT C(12) Q\nEND\n\n/******************************************************************/\n/* Create table of DFE's for this GDA                             */\n/******************************************************************/\n\nISPEXEC TBCREATE DFETBL +\n        KEYS() +\n        NAMES(DFESEL DFEADDR DFETYPE DFESPID +\n              DFEANEXT DFEAPREV DFESNEXT DFESPREV DFEAREA DFESIZE +\n             ) +\n        NOWRITE REPLACE\n\n/******************************************************************/\n/* Extract pointers from the GDA                                  */\n/******************************************************************/\n\n/* --- Subpool 245 (SQA) non-extended queue anchors --- */\n\nEVAL &CVTGDA..+004 L(4) PTR CLIST(S(GDASQAT5)) /* -> SQAT\nEVAL &CVTGDA..+008 L(4) PTR CLIST(S(GDAAQAT5)) /* -> AQATINDX\nEVAL &CVTGDA..+00C L(4) PTR CLIST(S(GDAADF45)) /* -> first DFE on addr q\nEVAL &CVTGDA..+010 L(4) PTR CLIST(S(GDAADL45)) /* -> last  DFE on addr q\nEVAL &CVTGDA..+014 L(4) PTR CLIST(S(GDASZF45)) /* -> first DFE on size q\nEVAL &CVTGDA..+018 L(4) PTR CLIST(S(GDASZL45)) /* -> last  DFE on size q\n\n/* --- Subpool 245 (SQA) extended queue anchors --- */\n\nEVAL &CVTGDA..+01C L(4) PTR CLIST(S(GDAESQT5)) /* -> SQAT\nEVAL &CVTGDA..+020 L(4) PTR CLIST(S(GDAEAQT5)) /* -> AQATINDX\nEVAL &CVTGDA..+024 L(4) PTR CLIST(S(GDAEADF5)) /* -> first DFE on addr q\nEVAL &CVTGDA..+028 L(4) PTR CLIST(S(GDAEADL5)) /* -> last  DFE on addr q\nEVAL &CVTGDA..+02C L(4) PTR CLIST(S(GDAESDF5)) /* -> first DFE on size q\nEVAL &CVTGDA..+030 L(4) PTR CLIST(S(GDAESDL5)) /* -> last  DFE on size q\n\n/* --- Subpool 226 (SQA) non-extended queue anchors --- */\n\nEVAL &CVTGDA..+034 L(4) PTR CLIST(S(GDASQAT6)) /* -> SQAT\nEVAL &CVTGDA..+038 L(4) PTR CLIST(S(GDAAQAT6)) /* -> AQATINDX\nEVAL &CVTGDA..+03C L(4) PTR CLIST(S(GDAADF26)) /* -> first DFE on addr q\nEVAL &CVTGDA..+040 L(4) PTR CLIST(S(GDAADL26)) /* -> last  DFE on addr q\nEVAL &CVTGDA..+044 L(4) PTR CLIST(S(GDASZF26)) /* -> first DFE on size q\nEVAL &CVTGDA..+048 L(4) PTR CLIST(S(GDASZL26)) /* -> last  DFE on size q\n\n/* --- Subpool 239 (SQA) non-extended queue anchors --- */\n\nEVAL &CVTGDA..+0E4 L(4) PTR CLIST(S(GDASQAT9)) /* -> SQAT\nEVAL &CVTGDA..+0E8 L(4) PTR CLIST(S(GDAAQAT9)) /* -> AQATINDX\nEVAL &CVTGDA..+0EC L(4) PTR CLIST(S(GDAADF39)) /* -> first DFE on addr q\nEVAL &CVTGDA..+0F0 L(4) PTR CLIST(S(GDAADL39)) /* -> last  DFE on addr q\nEVAL &CVTGDA..+0F4 L(4) PTR CLIST(S(GDASZF39)) /* -> first DFE on size q\nEVAL &CVTGDA..+0F8 L(4) PTR CLIST(S(GDASZL39)) /* -> last  DFE on size q\n\n/* --- Subpool 239 (SQA) extended queue anchors --- */\n\nEVAL &CVTGDA..+0FC L(4) PTR CLIST(S(GDAESQT9)) /* -> SQAT\nEVAL &CVTGDA..+100 L(4) PTR CLIST(S(GDAEAQT9)) /* -> AQATINDX\nEVAL &CVTGDA..+104 L(4) PTR CLIST(S(GDAEADF9)) /* -> first DFE on addr q\nEVAL &CVTGDA..+108 L(4) PTR CLIST(S(GDAEADL9)) /* -> last  DFE on addr q\nEVAL &CVTGDA..+10C L(4) PTR CLIST(S(GDAESZF9)) /* -> first DFE on size q\nEVAL &CVTGDA..+110 L(4) PTR CLIST(S(GDAESZL9)) /* -> last  DFE on size q\n\n/**********************************************************************/\n/* Process all the DFE's                                              */\n/**********************************************************************/\n\nSYSCALL PROCESS_DFE &GDAADF45 &GDAADL45 245          &XTRACE\nSYSCALL PROCESS_DFE &GDAEADF5 &GDAEADL5 245 EXTENDED &XTRACE\nSYSCALL PROCESS_DFE &GDAADF26 &GDAADL26 226          &XTRACE\nSYSCALL PROCESS_DFE &GDAADF39 &GDAADL39 239          &XTRACE\nSYSCALL PROCESS_DFE &GDAEADF9 &GDAEADL9 239 EXTENDED &XTRACE\n\n%IPTBDISP DFE THING(GDA) ADDR(&CVTGDA)\n\nEXIT\n\n\nPROCESS_DFE: PROC 3 FIRSTDFE LASTDFE SUBPOOL EXTENDED XTRACE\n SET DFEADDR = &STR(&FIRSTDFE)\n IF &STR(&DFEADDR) = 0 THEN RETURN\n DO UNTIL &STR(&A)        = &STR(&FIRSTDFE) +\n\n  INTEGER X'&DFEADDR' PTR DIALOG(S(DFEADDR))\n  SET A = &STR(&DFEADDR)\n  ISPEXEC TBVCLEAR DFETBL\n  SET DFEADDR = &STR(&A)\n  EVAL &DFEADDR..+00 LE(24) HEX CLIST(S(STUFF))\n  SET DFEANEXT = &SUBSTR(01:08,&STUFF)\n  SET DFEAPREV = &SUBSTR(09:16,&STUFF)\n  SET DFESNEXT = &SUBSTR(17:24,&STUFF)\n  SET DFESPREV = &SUBSTR(25:32,&STUFF)\n  SET DFEAREA  = &SUBSTR(33:40,&STUFF)\n  SET DFESIZE  = &SUBSTR(41:48,&STUFF)\n\n/**********************************************************************/\n/* Add DFE info to the table.                                         */\n/**********************************************************************/\n\n  IF &STR(&DFEAREA&DFESIZE) = 0000000000000000 THEN SET DFETYPE = DUMMY\n  ELSE SET DFETYPE =\n  SET DFESPID = &SUBPOOL\n  IF &EXTENDED = EXTENDED THEN SET DFETYPE = E&DFETYPE\n  ISPEXEC TBADD DFETBL\n/*WRITE +\n        &DFESEL &DFEADDR &DFETYPE &DFESPID +\n        &DFEANEXT &DFEAPREV &DFESNEXT &DFESPREV &DFEAREA &DFESIZE +\n\n/**********************************************************************/\n/* Chain to next DFE.                                                 */\n/**********************************************************************/\n\n  SET DFEADDR = &STR(&DFEANEXT)\n  SET A       = &STR(&DFEADDR)\n END\n\nEND PROCESS_DFE\n\n./ ADD NAME=LINKLIST\nPROC 0 DEBUG XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n/***********************************************************************\n/*                                                                     *\n/* This CLIST displays the current link list libraries and volumes.    *\n/*                                                                     *\n/***********************************************************************\nEVAL 10.%+8%+2D L(3) PTR CLIST(S(DEB))  /* DEB for SYS1.LINKLIB DCB */\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: DEB for SYS1.LINKLIB DCB not available' SPACE(1) ASIS\n EXIT C(12) Q\nEND\nIF &DEBUG = DEBUG THEN WRITE DEB=&DEB\nEVAL 10.%+4DC   L(4) PTR CLIST(S(LLT))  /* Link list table          */\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: LLT (CVT+4DC) pointer not available' SPACE(1) ASIS\n EXIT C(12) Q\nEND\nIF &DEBUG = DEBUG THEN WRITE LLT=&LLT\nEVAL &DEB..+4   L(1) UNS CLIST(S(CATS)) /* Bytes in AM sec = # concats\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: Unable to access concat count from DEB at &DEB' +\n      SPACE(1) ASIS\n EXIT C(12) Q\nEND\nIF &DEBUG = DEBUG THEN WRITE CATS=&CATS\nSET CATS = &CATS + 1 /* Add a byte for zeroth extent */\nIF &DEBUG = DEBUG THEN WRITE CATS=&CATS\nEVAL &DEB..+10  L(1) HEX CLIST(S(EXTENTS)) /* Total number of extents\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: Unable to access # of extents from DEB at &DEB' +\n      SPACE(1) ASIS\n EXIT C(12) Q\nEND\nIF &DEBUG = DEBUG THEN WRITE EXTENTS=&EXTENTS\n/* Get the concatenation extent pointers, following the extent entries\nEVAL &DEB..+20+&EXTENTS.0 L(&CATS) HEX CLIST(S(CONCATS))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: Unable to get concatenation extent pointers from +\n              DEB AT &DEB for X''&EXTENTS'' extents' SPACE(1) ASIS\n EXIT C(12) Q\nEND\nIF &DEBUG = DEBUG THEN WRITE CONCATS=&CONCATS\nEVAL &LLT..+4 L(4) SIGNED CLIST(S(LINKNO))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: Unable to get # of linklist libs from LLT at &LLT' +\n              SPACE(1) ASIS\n EXIT C(12) Q\nEND\nIF &DEBUG = DEBUG THEN WRITE LINKNO=&LINKNO\nSET I = 1\nSET O = 8\nDO WHILE &I LE &LINKNO\n EVAL &LLT..+&O.N+0 L(1) HEX CLIST(S(LIBLEN))\n EVAL &LLT..+&O.N+1 L(X'&LIBLEN') CHAR CLIST(S(LINKDS&I))\n SET O = &O + 45\n SET I = &I + 1\nEND\nSET I = 1\nSET J = 1\nSET CATBYTE =\nDO WHILE &I LE &CATS\n IF &DEBUG = DEBUG THEN DO\n  EVAL &DEB..+20+&CATBYTE.0 L(16) CLIST(S(JUNK))\n  WRITE CATBYTE=&SUBSTR(1:2,&CATBYTE  )  &NRSTR(&JUNK)\n END\n EVAL &DEB..+21+&CATBYTE.0 L(3) PTR CLIST(S(UCB))\n EVAL &UCB..+1C L(6) CHAR CLIST(S(VOL))\n EVAL &UCB..+D  L(3) CHAR CLIST(S(DEV))\n SET LINKDS = &STR(&&LINKDS&I)\n NOTE '&LINKDS - &VOL (&DEV)'\n SET CATBYTE = &SUBSTR(&J:&J+1,&CONCATS)\n SET I = &I + 1\n SET J = &J + 2\nEND /* Loop for all extents */\n./ ADD NAME=LISTASID\n PROC 0 ASID() ACTIVE XTRACE\n/*********************************************************************/\n/* REFER   IPO1.CMDPROC(LISTASID)                                    */\n/* COMPID  SYSTEMS                                                   */\n/* DOC     This CLIST executes under IPCS to display the jobnames    */\n/*         for the active ASIDs in the dump being analyzed.          */\n/*         Optionally, it checks only the specified ASID.            */\n/* CHANGED by S. BACHER 11/10/82 - new keywords added for list       */\n/*         by S. BACHER 11/07/84 - new keywords added for XA         */\n/*         by S. BACHER 07/10/85 - list keywords removed, uses NOTE  */\n/*                                                                   */\n/*********************************************************************/\n NGLOBAL FIRST_ASID_NOT_ASSIGNED LAST_ASID_NOT_ASSIGNED\n /******************************************************************/\n /* Set up environment                                             */\n /******************************************************************/\n IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\n CONTROL NOCAPS\n IF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\n END\n /******************************************************************/\n /* Initialization                                                 */\n /******************************************************************/\n SET &RCODE=0                       /* Set return code             */\n EQUATE ASVTADDR 4C.%+22C% PTR LE(4) &ACTIVE /* Address of ASVT    */\n EVAL ASVTADDR+204 LENGTH(4) &ACTIVE /* Contents of ASVTMAXU       */+\n      UNS CLIST(S(ASVTMAXU))\n SET &MEMCTR=0                      /* Total memories              */\n SET &ACTCTR=0                      /* Active memories             */\n SET &TSOCTR=0                      /* TSO users                   */\n /******************************************************************/\n /* Process the ASID, if any, and insure that it is valid          */\n /******************************************************************/\n IF &ACTIVE = ACTIVE THEN DO\n  IF &STR(&ASID) ^= THEN DO\n   WRITE Error: ASID and ACTIVE are mutually exclusive keywords\n   SET RCODE = 8\n   GOTO EXIT\n  END\n  SET ASID = 1\n  SET ENDASID = &ASVTMAXU\n  GOTO GOTASID\n END\n IF &ASID ^= THEN DO\n  INTEGER &ASID UNSIGNED CLIST(S(ASID))\n  IF &LASTCC ^= 0 THEN DO\n   WRITE ==> Error: An Invalid ASID (&ASID) was specified.\n   SET RCODE = 12\n   GOTO EXIT\n  END\n END\n IF &ASID^=   AND                   /* ASID specified and          */+\n   &ASID^=0 THEN                    /* ASID is non-zero            */+\n   IF &ASID>&ASVTMAXU THEN          /* Insure valid ASID           */+\n     DO\n       WRITE ==> Error: ASID(&ASID) is greater than +\n         max users (&ASVTMAXU)\n       SET &RCODE=8                 /* Error return code           */\n       GOTO EXIT\n     END\n   ELSE                             /* Have valid ASID             */+\n     SET &ENDASID=&ASID             /* End of loop control         */\n ELSE                               /* Use all possible ASIDS      */+\n   DO\n     SET &ASID=1                    /* First ASID to check         */\n     SET &ENDASID=&ASVTMAXU         /* Last ASID to check          */\n   END\n /******************************************************************/\n /* Set up the header and page control                             */\n /******************************************************************/\n GOTASID:+\n SET Z=&STR(***    Display of ASIDs(&ASID:&ENDASID) and jobnames  -\n                                                  )\n SET Z=&SUBSTR(1:64,&Z)&STR(***)\n NOTE '*************************************************************+\n ******' PAGE\n NOTE '&Z' ASIS\n NOTE '*************************************************************+\n ******'\n NOTE SPACE(1)\n SET FIRST_ASID_NOT_ASSIGNED =\n SET LAST_ASID_NOT_ASSIGNED =\n /******************************************************************/\n /* Loop through the specified or all ASIDs                        */\n /******************************************************************/\n DO WHILE &ASID^=&ENDASID+1         /* Check each ASID             */\n   SET &MEMCTR=&MEMCTR+1            /* Count total memories        */\n   IF &ACTIVE = ACTIVE THEN         /* ASID keyword                */+\n    SET MEM = ACTIVE                /* ASID keyword                */\n   ELSE                             /* ASID keyword                */+\n    SET &MEM=ASID(&ASID)            /* ASID keyword                */\n   SET &ASVTOFFS = &ASID*4          /* Offset into entries of ASVT */\n   EVAL ASVTADDR+20C+&ASVTOFFS.N &ACTIVE PTR L(4) CLIST(S(ASVTENTRY))\n   IF &LASTCC = 12 THEN DO\n    NOTE 'Error: ASVT entry not available for ASID(&ASID)' ASIS\n    GOTO EXITASID\n   END\n   SET ZASID = &SUBSTR(2:4,&EVAL(&ASID+1000))\n   INTEGER &ASID PTR(4) CLIST(S(HEXASID)\n   IF &SUBSTR(1:2,&ASVTENTRY)=80 THEN /* If memory is not assigned */+\n     DO\n       /* NOTE 'ASID&ZASID (X''&HEXASID'') not assigned' ASIS\n       SET LAST_ASID_NOT_ASSIGNED = &STR(&ZASID (X''&HEXASID''))\n       IF &STR(&FIRST_ASID_NOT_ASSIGNED) = &STR() THEN +\n         SET FIRST_ASID_NOT_ASSIGNED = &STR(&LAST_ASID_NOT_ASSIGNED)\n     END\n   ELSE                             /* Memory is assigned          */+\n     DO\n\n       SYSCALL LIST_UNASSIGNED_ASIDS_SO_FAR\n\n       SET &ACTCTR=&ACTCTR+1        /* Count active memories       */\n       SET ASCBADDR = &SUBSTR(3:8,&ASVTENTRY) /* Address of ASCB   */\n       EQ ASCB &ASCBADDR.. STRUCTURE(ASCB) &MEM /* Equate the ASCB */\n       COMPARE ADDRESS(ASCB+3C)     /* Address of TSB, if any      */+\n         LE(4) WITH(VALUE(X'00000000')) &ACTIVE\n       IF &LASTCC=0 THEN            /* Must not be TSO user        */+\n         SET &TSO=Job name          /* Indicate no TSO user        */\n       ELSE                          /* Must be TSO user           */+\n         DO\n           SET &TSO=TSO user         /* Indicate TSO user          */\n           SET &TSOCTR=&TSOCTR+1     /* Count TSO users            */\n         END\n       EVAL ASCB+B0 L(4) &MEM PTR CLIST(S(ASCBJBNS)) /* Jobnameptr */\n       IF &ASCBJBNS=0 THEN DO       /* Check if valid pointer      */\n         SET JOBNAME = &STR(not avail)\n       END\n       ELSE DO                       /* Have valid jobname         */\n         EVAL &ASCBJBNS.. L(8) CHAR &MEM CLIST(S(JOBNAME))\n         IF &LASTCC = 12 THEN SET JOBNAME = &STR(no access)\n       END\n       SET IJOBNAME =\n       EVAL ASCB+AC L(4) &MEM PTR CLIST(S(ASCBJBNI))\n       IF &ASCBJBNI=0 THEN DO       /* Check if valid pointer      */\n       END\n       ELSE DO                       /* Have valid jobname         */\n         EVAL &ASCBJBNI.. L(8) CHAR &MEM CLIST(S(IJOBNAME))\n         SET IJOBNAME = &STR(INIT:  &IJOBNAME)\n       END\n       EVAL ASCB+2B &MEM L(1) UNS CLIST(S(DP)) /* Dispatching prty */\n       NOTE 'ASID&ZASID (X''&HEXASID'')  +\n            &TSO:  &SUBSTR(1:9,&JOBNAME         )  +\n            DP:  &DP  &IJOBNAME' +\n            ASIS\n     END\n   EXITASID:+\n   SET &ASID=&ASID+1                 /* STEP TO NEXT ASID          */\n END                                 /* END OF ASID CHECK LOOP     */\n\n SYSCALL LIST_UNASSIGNED_ASIDS_SO_FAR\n\n EXIT: NOTE 'Total ASIDs processed=&MEMCTR;  +\n       Active=&ACTCTR;  TSO users=&TSOCTR' SPACE(1) ASIS\n       NOTE SPACE(1)\n       EXIT CODE(&RCODE)\n\nLIST_UNASSIGNED_ASIDS_SO_FAR: PROC 0\n\n IF &STR(&LAST_ASID_NOT_ASSIGNED) ^= &STR() THEN DO\n   SET SYSDVAL = &STR(&FIRST_ASID_NOT_ASSIGNED)\n   READDVAL NASID1\n   SET SYSDVAL = &STR(&LAST_ASID_NOT_ASSIGNED)\n   READDVAL NASID2\n   IF &NASID1 = &NASID2 THEN DO\n     NOTE 'ASID&FIRST_ASID_NOT_ASSIGNED not assigned' ASIS\n   END\n   ELSE IF &NASID1 = &NASID2-1 THEN DO\n     NOTE 'ASID&FIRST_ASID_NOT_ASSIGNED not assigned' ASIS\n     NOTE 'ASID&LAST_ASID_NOT_ASSIGNED not assigned' ASIS\n   END\n   ELSE DO\n     SET ANARANGE = &STR(&FIRST_ASID_NOT_ASSIGNED thru +\n                         &LAST_ASID_NOT_ASSIGNED)\n     NOTE '-----------------' ASIS\n     NOTE 'ASID&ANARANGE not assigned' ASIS\n     NOTE '-----------------' ASIS\n   END\n   SET FIRST_ASID_NOT_ASSIGNED =\n   SET LAST_ASID_NOT_ASSIGNED =\n END\n\nEND /* LIST_UNASSIGNED_ASIDS_SO_FAR */\n\n./ ADD NAME=LISTDSAB\nPROC 0 TCB() ACTIVE BACKWARDS XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n/* Code to extract current TCB\nIF &STR(&TCB) = THEN DO\n SET TCB = 0\n EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))\n IF &TCB = 0 THEN DO\n  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))\n  IF &TCB = 0 THEN DO\n   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))\n   IF &TCB = 0 THEN DO\n    NOTE 'TCB unavailable' ASIS\n    EXIT C(12) Q\n   END\n  END\n END\n SET TCB = &STR(&TCB..)\nEND\n/* End code to extract current TCB\nEVAL &TCB+B4 L(4) &ACTIVE CLIST(STORAGE(JSCB)\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: JSCB pointer in TCB at &TCB could not be accessed.' ASIS\n EXIT C(12) Q\nEND\nIF &JSCB = 0 THEN DO\n NOTE 'TCB at &TCB has no JSCB.' ASIS\n EXIT C(12) Q\nEND\nEVAL &JSCB..+15C L(4) &ACTIVE CLIST(STORAGE(JSCBACT))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: JSCBACT ptr in JSCB at &JSCB cannot be accessed.' ASIS\n EXIT C(12) Q\nEND\nIF &JSCBACT ^= 0 THEN SET JSCB = &JSCBACT\nEVAL &JSCB..+140 L(4) &ACTIVE CLIST(STORAGE(QDB))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: QDB pointer in JSCB at &JSCB cannot be accessed.' ASIS\n EXIT C(12) Q\nEND\nIF &QDB = 0 THEN DO\n NOTE 'JSCB at &JSCB has no QDB.' ASIS\n EXIT C(12) Q\nEND\nIF &BACKWARDS ^= THEN +\n EVAL &QDB..+10 L(4) &ACTIVE CLIST(STORAGE(DSAB))\nELSE +\n EVAL &QDB..+0C L(4) &ACTIVE CLIST(STORAGE(DSAB))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: DSAB pointer in QDB at &QDB cannot be accessed.' ASIS\n EXIT C(12) Q\nEND\nIF &DSAB = 0 THEN DO\n NOTE 'QDB at &QDB has no DSAB.' ASIS\n EXIT C(12) Q\nEND\nERROR\nNOTE SPACE(1)\nNOTE 'DSAB ADDR--SIOT ADDR--DDNAME---VOL---DEV--JFCB ADDR--DSNAME' ASIS\nNOTE SPACE(1)\nDO UNTIL &DSAB = 0\n EVAL &DSAB..+40         L(4)  PTR  &ACTIVE CLIST(STORAGE(SIOT))\n IF &SIOT = 0 THEN DO\n  EVAL &DSAB..+15        L(3)  PTR  &ACTIVE CLIST(STORAGE(SIOT))\n  IF &SIOT = 0 THEN DO\n   NOTE 'Error: No SIOT for DSAB at &DSAB..' ASIS\n   EXIT C(12) Q\n  END\n  INTEGER X'&SIOT' UNS CLIST(S(SIOTN))\n  INTEGER &EVAL(&SIOTN+16) PTR CLIST(S(SIOT))\n END\n EVAL &SIOT..+04         L(8)  CHAR &ACTIVE CLIST(STORAGE(DDNAME))\n EVAL &SIOT..+20         L(3)  UNSI &ACTIVE CLIST(STORAGE(JFCBPTRN))\n INTEGER &EVAL(&JFCBPTRN+16)   PTR          CLIST(STORAGE(JFCBPTR))\n EVAL &JFCBPTR..+0       L(44) CHAR &ACTIVE CLIST(STORAGE(DSNAME))\n EVAL &JFCBPTR..+2C      L(8)  CHAR &ACTIVE CLIST(STORAGE(MEMBER))\n EVAL &JFCBPTR..+76      L(6)  CHAR &ACTIVE CLIST(STORAGE(VOLSER))\n EVAL &SIOT..+40         L(1)  UNS  &ACTIVE CLIST(STORAGE(SIOUCNVT)\n SET UNIT = &STR(   )\n IF &SIOUCNVT = 0 THEN DO\n  EVAL &SIOT..+41        L(3)  PTR  &ACTIVE CLIST(STORAGE(UCBPTR))\n  IF &UCBPTR ^= 0 THEN DO\n   EVAL &UCBPTR..+D      L(3)  CHAR &ACTIVE CLIST(STORAGE(UNIT))\n  END\n END\n SET SYSDVAL = &NRSTR(&DSNAME &MEMBER)\n READDVAL DSNAME MEMBER\n IF &NRSTR(&MEMBER) ^= THEN SET DSNAME = &NRSTR(&DSNAME(&MEMBER))\n INTEGER X'&DSAB'    PTR LENGTH(8) CLIST(S(DSAB8))\n INTEGER X'&SIOT'    PTR LENGTH(8) CLIST(S(SIOT8))\n INTEGER X'&JFCBPTR' PTR LENGTH(6) CLIST(S(JFCB8))\n NOTE '&NRSTR(&DSAB8  &SIOT8  &DDNAME &VOLSER &UNIT  &JFCB8 &DSNAME)' +\n      ASIS\n IF &BACKWARDS ^= THEN +\n  EVAL &DSAB..+8 L(4) &ACTIVE CLIST(S(DSAB))\n ELSE +\n  EVAL &DSAB..+4 L(4) &ACTIVE CLIST(S(DSAB))\nEND\nEXIT\n./ ADD NAME=LISTREGS\nPROC 0 ASID() TCB() ACTIVE XTRACE\n/*********************************************************************/\n/*                                                                   */\n/* Function: This CLIST executes under IPCS to display the registers */\n/*           for all TCBs and RBs in a memory contained in the dump  */\n/*           being analyzed.  It also displays the module name, if   */\n/*           available, for all PRBs and the interrupt code for all  */\n/*           RBs.  Optionally, it lists the above data for a specific*/\n/*           ASID.                                                   */\n/* CHANGED:  By S. BACHER 11/10/82 - New keywords added for LIST     */\n/*           By S. BACHER 11/07/84 - XA \"ACTIVE\" support             */\n/*           By S. BACHER 10/10/85 - Support for map by TCB          */\n/*                                                                   */\n/* SYNTAX:   %LISTREGS  |ASID(#) / ACTIVE| |TCB(tcbaddr)| |XTRACE|   */\n/*                                                                   */\n/*              ASID   - ASID to list registers from                 */\n/*              ACTIVE - List registers from active storage          */\n/*              TCB(tcbaddr) - List this TCB only; default=all TCB's */\n/*              XTRACE - List control statements of the CLIST        */\n/*                                                                   */\n/*********************************************************************/\n/******************************************************************/\n/* Initialization                                                 */\n/******************************************************************/\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nSET &RCODE=0                       /* Set return code             */\n/******************************************************************/\n/* Process the \"ACTIVE\" keyword                                   */\n/******************************************************************/\nIF &ACTIVE = ACTIVE THEN DO        /* Active specified            */\n  IF &STR(&ASID) ^= THEN DO        /* If so, ASID must be omitted */\n    WRITE ==> Error: ASID and ACTIVE are mutually exclusive keywords\n    SET &RCODE=8                   /* Error return code           */\n    GOTO EXIT\n  END\n  SET &MEM=ACTIVE                  /* Set subcommand keyword      */\n  GOTO GOTASID                     /* Bypass ASID processing      */\nEND\n/******************************************************************/\n/* Process the ASID                                               */\n/******************************************************************/\nIF &ASID =   |                     /* No ASID specified or        */+\n  &ASID=0 THEN                     /* specified ASID=0            */+\n  DO\n   EVALDEF CLIST(QUAL(DEFQUAL))    /* Get SETDEF qualification    */\n   IF &SUBSTR(1:4,&DEFQUAL    ) = ASID THEN DO\n    SET ASID = &SUBSTR(6:&LENGTH(&STR(&DEFQUAL))-1,&DEFQUAL)\n    INTEGER &ASID UNS CLIST(S(ASID))\n   END                             /* If ASID qualified, use it   */\n   ELSE DO                         /* Otherwise...                */\n    EVAL 2. HEADER LENGTH(2) UNS   /* Current ASID, if any        */+\n            CLIST(S(ASID))         /* Save the value              */\n   END\n   IF &ASID=0 THEN DO              /* If absolute dump            */\n    SET &ASID=1                    /* default to 1, else          */\n   END                             /* use current virtual value   */\n  END\nELSE                               /* Use specified value         */\nSET &MEM=ASID(&ASID)               /* Set subcommand keyword      */\n/******************************************************************/\n/* Locate the ASVT and insure that the ASID is valid              */\n/******************************************************************/\nEQUATE ASVTADDR 4C.%+22C% PTR LE(4)/* Address of ASVT             */\nEVAL ASVTADDR+204 LENGTH(4) UNS    /* Contents of ASVTMAXU        */+\n     CLIST(S(ASVTMAXU))            /* Save the value              */\nIF &ASID>&ASVTMAXU THEN            /* Insure valid ASID           */+\n  DO\n    WRITE ==> Error: &MEM is greater than max users (&ASVTMAXU)\n    SET &RCODE=8                   /* Error return code           */\n    GOTO EXIT\n  END\nELSE                               /* Have valid ASID             */\n/******************************************************************/\n/* Insure that this memory is assigned                            */\n/******************************************************************/\nSET &ASVTOFFS=&ASID*4              /* Offset into entries of ASVT */\nCOMPARE ADDR(ASVTADDR+20C+&ASVTOFFS.N) /* Insure memory assigned  */+\n  LENGTH(1) WITH(VALUE(X'80'))\nIF &LASTCC=0 THEN                  /* Not assigned                */+\n  DO\n    WRITE ==> Error: &MEM is not assigned\n    SET &RCODE=8                   /* Set return code             */\n    GOTO EXIT\n  END\nELSE                               /* Memory is assigned          */\n/******************************************************************/\n/* Set up the header and page control                             */\n/******************************************************************/\nGOTASID:+\nNOTE '*************************************************************+\n******' PAGE\nIF &STR(&TCB) ^= THEN +\n NOTE '***    Display of all RB registers for &MEM TCB &TCB     ***' +\n      ASIS\nELSE +\n NOTE '***    Display of all TCB and RB registers for &MEM  -\n       ***' ASIS\nNOTE '*************************************************************+\n******'\n/******************************************************************/\n/* Locate the ASCB, ASXB, and 1st TCB for this memory             */\n/******************************************************************/\nSET &TCBCTR=1                      /* Count of TCBs               */\nIF &STR(&TCB) ^= THEN DO\n EQ TCBADDR &TCB PTR &MEM LENGTH(4)\n EVALSYM TCBADDR CLIST(ADDR(TCBADDR))\n SET TCBADDR = &SUBSTR(3:8,&TCBADDR)\n GOTO PROCTCB\nEND\nIF &ACTIVE = ACTIVE THEN           /* Get active ASCB address     */+\n EQ ASCBADDR 224.% ACTIVE          /* from current storage, or    */\nELSE                               /* get ASCB address for ASID   */+\n EQ ASCBADDR ASVTADDR+20C+&ASVTOFFS.N% &MEM  /* ASCB address      */\nEVAL ASCBADDR+6C% L(4) &MEM        /* ASXB address                */\nIF &LASTCC=12 THEN                 /* Must not be available       */+\n  DO\n    NOTE '==> Error: ASXB not available for &MEM' ASIS\n    SET &RCODE=4                   /* Set return code             */\n    GOTO EXIT\n  END\nELSE                               /* ASXB storage is available   */\nEQ ASXBADDR ASCBADDR+6C% PTR &MEM  /* Address of ASXB             */+\n  LENGTH(4)\nEVAL ASXBADDR+4% LENGTH(4) &MEM    /* 1st TCB address             */\nIF &LASTCC=12 THEN                 /* Must not be available       */+\n  DO\n    NOTE '==> Error: TCB&TCBCTR not available for &MEM' ASIS\n    SET &RCODE=4                   /* Set return code             */\n    GOTO EXIT\n  END\nELSE                               /* TCB storage is available    */\nEVAL ASXBADDR+5  LENGTH(3) &MEM    /* Save the TCB address in a   */+\n     CLIST(S(TCBADDR))             /*   symbolic variable         */\nEQ TCBADDR ASXBADDR+4% PTR &MEM    /* TCB address                 */+\n  LENGTH(4)\n/******************************************************************/\n/* Process all TCBs for this address space                        */\n/******************************************************************/\nPROCTCB:+\nDO WHILE &TCBADDR^=0               /* Loop for all TCBs           */\n  EQ TCB&TCBCTR TCBADDR STRUCTURE(TCB)\n  NOTE '*** TCB&TCBCTR    --Display of general registers--' SPACE(2) ASI\n  EVAL TCBADDR+30 L(64) HEX &MEM CLIST(S(REGISTERS))\n  %SHOWREGS &REGISTERS\n  NOTE SPACE(1)\n  /****************************************************************/\n  /* Find the 1st RB address for this TCB                         */\n  /****************************************************************/\n  SET &RBERR=0                     /* No RBs missing for this TCB */\n  SET &RBCTR=1                     /* Initialize RB counter       */\n  EVAL TCBADDR+1  L(3) &MEM        /* Save RB address in          */+\n       CLIST(S(RBADDR))            /*   symbolic variable         */\n  IF &LASTCC=12 THEN               /* If RB address not available */+\n    DO\n      NOTE '==> Error: RB&RBCTR not available for &MEM'\n      SET &RCODE=4                 /* Set return code             */\n      SET &RBERR=1                 /* Indicate break in RB chain  */\n    END\n  ELSE                             /* 1st RB is available         */\n  EQ RBADDR TCBADDR+0% PTR &MEM L(4) /* RB address                */\n  /****************************************************************/\n  /* Process all RBs for this TCB                                 */\n  /****************************************************************/\n  DO WHILE &RBADDR^=&TCBADDR AND    /* Until last RB found  and   */+\n    &RBERR=0                        /* RB chain not broken        */\n    SET CDENAME = &STR(*None*)\n    EVAL RBADDR-2 LEN(2) &MEM       /* Obtain contents of RBINTCOD*/+\n         UNS CLIST(S(RBINTCOD))     /*   and save the value       */\n    IF &LASTCC = 12 THEN DO\n     NOTE 'Error: RBINTCOD for RB at &RBADDR not available' ASIS\n     GOTO SKIPRB\n    END\n    COMPARE ADDRESS(RBADDR+A) LENGTH(1) &MEM /* Test for PRB      */+\n      WITH(VALUE(X'00')) MASK(X'E0')\n    IF &LASTCC=0 THEN +\n      DO\n        SET &RBTYPE=PRB\n        COMPARE ADDR(RBADDR+C) LEN(4) &MEM /* Test for CDE address*/+\n          WITH(VALUE(X'00000000')) MASK(X'00FFFFFF')\n        IF &LASTCC=0 THEN\n        ELSE +\n          DO\n            EVAL RBADDR+C%+8 LENGTH(8) CHAR &MEM CLIST(S(CDENAME))\n            IF &LASTCC = 12 THEN SET CDENAME = &STR(*Unavailable*)\n          END\n      END\n    ELSE +\n      DO\n        COMPARE ADDRESS(RBADDR+A) LE(1) &MEM /* Test for SVRB     */+\n          WITH(VALUE(X'C0')) MASK(X'E0')\n        IF &LASTCC=0 THEN +\n          SET &RBTYPE=SVRB\n        ELSE +\n          DO\n            COMPARE ADDRESS(RBADDR+A) LE(1) &MEM /* Test for TIRB */+\n              WITH(VALUE(X'60')) MASK(X'E0')\n            IF &LASTCC=0 THEN +\n              SET &RBTYPE=TIRB\n            ELSE +\n              DO\n                COMPARE ADDRESS(RBADDR+A) LE(1) &MEM /* IRB test  */+\n                  WITH(VALUE(X'40')) MASK(X'E0')\n                IF &LASTCC=0 THEN +\n                  SET &RBTYPE=IRB\n                ELSE +\n                  DO\n                    COMPARE ADDRESS(RBADDR+A) LE(1) &MEM /* SIRB   */+\n                      WITH(VALUE(X'80')) MASK(X'E0')\n                    IF &LASTCC=0 THEN +\n                      SET &RBTYPE=SIRB\n                    ELSE +\n                      DO\n                        NOTE '==> Error: RBFTP not recognizable'\n                        SET &RCODE=4   /* Set return code          */\n                        SET &RBTYPE=RB\n                      END\n                  END\n              END\n          END\n      END\n    INTEGER &RBINTCOD PTR(2) CLIST(S(RBINTHEX))\n    EVAL RBADDR+10 L(4) CLIST(S(RBOPSW1))\n    EVAL RBADDR+14 L(4) CLIST(S(RBOPSW2))\n    SET RBSHORT = &STR(RB&RBCTR(&RBTYPE))\n    SET RBHEADER = &STR(RB&RBCTR(&RBTYPE) +\n                        IC(&RBINTCOD,X''&RBINTHEX'') +\n                        PSW(&RBOPSW1 &RBOPSW2)\n    IF &RBTYPE=RB THEN +\n      NOTE '&RBSHORT  --No module name or non-recognizable RB--' SP AS\n    IF &RBTYPE=PRB THEN +\n     NOTE '&RBSHORT  Module name: &CDENAME' ASIS\n/*  ELSE DO\n     NOTE '*** &RBHEADER --General registers--' SP(1) ASIS\n     EVAL RBADDR+20 L(64) HEX &MEM CLIST(S(REGISTERS))\n     %SHOWREGS &REGISTERS\n/*  END\n    SET &RBCTR=&RBCTR+1            /* Plus 1 to RB counter        */\n\n    COMPARE ADDR(RBADDR+B) LE(1) +\n         WITH(VALUE(X'80')) MASK(X'80') /* Does NEXTRB point to TCB?\n    IF &LASTCC = 0 THEN DO\n     SET RBADDR = &STR(000000)\n     SET RBERR = 2                 /* RB chain ended\n    END\n    ELSE DO\n     EVAL RBADDR+1D LE(3) PTR CLIST(S(RBADDR))\n     IF &LASTCC=12 THEN            /* If RB address not available */+\n       DO\n         NOTE '==> Error: RB&RBCTR not available for &MEM'\n         SET &RCODE=4              /* Set return code             */\n         SET &RBERR=1              /* RB chain now broken         */\n       END                         /* Set return code             */\n     ELSE\n     EQ RBADDR RBADDR+1C% PTR &MEM /* Next RB address            */+\n        LENGTH(4)\n    END\n\nSKIPRB:+\n  END                              /* End of RB loop              */\n  IF &STR(&TCB) ^= THEN GOTO EXIT  /* If only 1 TCB wanted, quit  */\n  SET &TCBCTR=&TCBCTR+1            /* Plus 1 to TCB counter       */\n  EVAL TCBADDR+75 L(3) &MEM        /* Save next TCB address in    */+\n       CLIST(S(TCBADDR))           /*   symbolic variable         */\n  IF &LASTCC=12 THEN               /* If TCB address not available*/+\n    DO\n      NOTE '==> Error: TCB&TCBCTR not available for &MEM'\n      SET &RCODE=4\n      GOTO EXIT\n    END\n  ELSE\n  EQ TCBADDR TCBADDR+74% PTR &MEM  /* Next TCB address            */+\n    LENGTH(4)\nEND                                /* End of TCB loop             */\n/******************************************************************/\n/* Cleanup and exit here                                          */\n/******************************************************************/\nEXIT: NOTE SPACE(1)\nEXIT CODE(&RCODE)\n./ ADD NAME=LISTSIOT\nPROC 0 TCB() ACTIVE XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n/* Code to extract current TCB\nIF &STR(&TCB) = THEN DO\n SET TCB = 0\n EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))\n IF &TCB = 0 THEN DO\n  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))\n  IF &TCB = 0 THEN DO\n   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))\n   IF &TCB = 0 THEN DO\n    NOTE 'TCB unavailable' ASIS\n    EXIT C(12) Q\n   END\n  END\n END\nEND\nIF &SYSINDEX(.,&TCB) = 0 THEN SET TCB = &STR(&TCB..)\n/* End code to extract current TCB\nEVAL &TCB+B4 L(4) &ACTIVE CLIST(STORAGE(JSCB)\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: JSCB pointer in TCB at &TCB could not be accessed.' ASIS\n EXIT C(12) Q\nEND\nIF &JSCB = 0 THEN DO\n NOTE 'TCB at &TCB has no JSCB.' ASIS\n EXIT C(12) Q\nEND\nEVAL &JSCB..+148 L(4) &ACTIVE CLIST(STORAGE(SCT))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: SCT pointer in JSCB at &JSCB cannot be accessed.' ASIS\n EXIT C(12) Q\nEND\nIF &SCT = 0 THEN DO\n NOTE 'JSCB at &JSCB has no SCT.' ASIS\n EXIT C(12) Q\nEND\nEVAL &SCT..+10+C L(3) PTR &ACTIVE CLIST(STORAGE(SIOT))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: SIOT pointer in SCT at &SCT cannot be accessed.' ASIS\n EXIT C(12) Q\nEND\nIF &SIOT = 0 THEN DO\n NOTE 'SCT at &SCT has no SIOT.' ASIS\n EXIT C(12) Q\nEND\nERROR DO\n WRITE LASTCC = &LASTCC\n WRITE SUBCOMMAND = &STR(&SYSPCMD)\n RETURN\nEND\nNOTE SPACE(1)\nNOTE 'SIOT ADDR--DDNAME---VOL---DEV--JFCB ADDR--DSNAME' ASIS\nNOTE SPACE(1)\nINTEGER X'&SIOT' UNS CLIST(S(SIOTN))\nINTEGER &EVAL(&SIOTN+16) PTR CLIST(S(SIOT))\nDO UNTIL &SIOT = 0\n EVAL &SIOT..+04         L(8)  CHAR &ACTIVE CLIST(STORAGE(DDNAME))\n EVAL &SIOT..+20         L(3)  UNSI &ACTIVE CLIST(STORAGE(JFCBPTRN))\n INTEGER &EVAL(&JFCBPTRN+16)   PTR          CLIST(STORAGE(JFCBPTR))\n EVAL &JFCBPTR..+0       L(44) CHAR &ACTIVE CLIST(STORAGE(DSNAME))\n EVAL &JFCBPTR..+2C      L(8)  CHAR &ACTIVE CLIST(STORAGE(MEMBER))\n EVAL &JFCBPTR..+76      L(6)  CHAR &ACTIVE CLIST(STORAGE(VOLSER))\n EVAL &SIOT..+40         L(1)  UNS  &ACTIVE CLIST(STORAGE(SIOUCNVT)\n SET UNIT = &STR(   )\n IF &SIOUCNVT = 0 THEN DO\n  EVAL &SIOT..+41        L(3)  PTR  &ACTIVE CLIST(STORAGE(UCBPTR))\n  IF &UCBPTR ^= 0 THEN DO\n   EVAL &UCBPTR..+D      L(3)  CHAR &ACTIVE CLIST(STORAGE(UNIT))\n  END\n END\n SET SYSDVAL = &NRSTR(&DSNAME &MEMBER)\n READDVAL DSNAME MEMBER\n IF &NRSTR(&MEMBER) ^= THEN SET DSNAME = &NRSTR(&DSNAME(&MEMBER))\n INTEGER X'&SIOT'    PTR LENGTH(8) CLIST(S(SIOT8))\n INTEGER X'&JFCBPTR' PTR LENGTH(6) CLIST(S(JFCB8))\n NOTE '&NRSTR(&SIOT8  &DDNAME &VOLSER &UNIT  &JFCB8 &DSNAME)' ASIS\n EVAL &SIOT..+98 L(4) CLIST(S(SIOT))\nEND\nEXIT\n./ ADD NAME=LISTTIOT\nPROC 0 TCB() ACTIVE XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n/* Code to extract current TCB\nIF &STR(&TCB) = THEN DO\n SET TCB = 0\n EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))\n IF &TCB = 0 THEN DO\n  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))\n  IF &TCB = 0 THEN DO\n   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))\n   IF &TCB = 0 THEN DO\n    NOTE 'TCB unavailable' ASIS\n    EXIT C(12) Q\n   END\n  END\n END\nEND\nIF &SYSINDEX(.,&TCB) = 0 THEN SET TCB = &STR(&TCB..)\n/* End code to extract current TCB\nEVAL &TCB+D L(3) &ACTIVE CLIST(STORAGE(TIOTPTR))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: TIOT pointer in TCB at &TCB could not be accessed.' ASIS\n EXIT C(12) Q\nEND\nIF &TIOTPTR = 0 THEN DO\n NOTE 'TCB at &TCB has no TIOT.' ASIS\n EXIT C(12) Q\nEND\nEVAL &TIOTPTR.. L(24) CHAR CLIST(S(TIOTDATA))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: TIOT data at &TIOTPTR could not be accessed.' ASIS\n EXIT C(12) Q\nEND\nSET JOBNAME  = &SUBSTR( 1: 8,&NRSTR(&TIOTDATA))\nSET STEPNAME = &SUBSTR( 9:16,&NRSTR(&TIOTDATA))\nSET PROCSTEP = &SUBSTR(17:24,&NRSTR(&TIOTDATA))\nINTEGER X'&TIOTPTR' UNSIGNED CLIST(STORAGE(TIOTPTRN))\nSET TIOTENTRYPTRN = &TIOTPTRN+24\nNOTE SPACE(1)\nNOTE '*** TIOT at &TIOTPTR - Jobname=&JOBNAME +\n     Stepname=&STEPNAME Procstep=&PROCSTEP ***' ASIS\nNOTE SPACE(1)\nCONTINUE:+\nINTEGER &TIOTENTRYPTRN POINTER CLIST(STORAGE(TIOTENTRYPTR))\nEVAL &TIOTENTRYPTR.. L(20) HEX &ACTIVE CLIST(STORAGE(TIOTENTRY))\nSET TIOTLENGTH = &SUBSTR(1:2,&TIOTENTRY)\nINTEGER X'&TIOTLENGTH' UNSIGNED CLIST(STORAGE(TIOTLENGTH))\nIF &TIOTLENGTH = 0 THEN GOTO END\nSET TIOESSTA = &SUBSTR(3,&TIOTENTRY)\nIF &TIOESSTA >= 0 AND &TIOESSTA <= 7 THEN DO\n EVAL &TIOTENTRYPTR..+4  L(8)  CHAR &ACTIVE CLIST(STORAGE(DDNAME))\n EVAL &TIOTENTRYPTR..+11 L(3)  PTR  &ACTIVE CLIST(STORAGE(UCBPTR))\n EVAL &TIOTENTRYPTR..+C  L(3)  UNSI &ACTIVE CLIST(STORAGE(JFCBPTRN))\n INTEGER &EVAL(&JFCBPTRN+16)   PTR          CLIST(STORAGE(JFCBPTR))\n EVAL &JFCBPTR..+0       L(44) CHAR &ACTIVE CLIST(STORAGE(DSNAME))\n EVAL &JFCBPTR..+2C      L(8)  CHAR &ACTIVE CLIST(STORAGE(MEMBER))\n EVAL &JFCBPTR..+76      L(6)  CHAR &ACTIVE CLIST(STORAGE(VOLSER))\n EVAL &UCBPTR..+D        L(3)  CHAR &ACTIVE CLIST(STORAGE(UNIT))\n SET SYSDVAL = &NRSTR(&DSNAME &MEMBER)\n READDVAL DSNAME MEMBER\n IF &NRSTR(&MEMBER) ^= THEN SET DSNAME = &NRSTR(&DSNAME(&MEMBER))\n NOTE '&NRSTR(&DDNAME &VOLSER &UNIT &DSNAME)' ASIS\n IF &LASTCC ^= 0 THEN GOTO END\nEND\nSET TIOTENTRYPTRN = &TIOTENTRYPTRN + &TIOTLENGTH\nGOTO CONTINUE\nEND:+\nEXIT\n./ ADD NAME=MAP\nPROC 0 XTRACE TCBADDRESS(0.) LIBRARY(SYSPGMR.CMD.LOAD)\n/***********************************************************************\n/*                                                                     *\n/* Author: S. BACHER                                                   *\n/*                                                                     *\n/***********************************************************************\nIF &XTRACE=XTRACE THEN CONTROL CONLIST SYMLIST LIST MSG\nIF &STR(&SYSPCMD) = IPCS THEN DO\n /* VERBEXIT XIPMAP\n TCBEXIT XITMAP &TCBADDRESS\nEND\nELSE DO\n XCMD /XIPMAP/ LIB('&LIBRARY') NOF\nEND\n./ ADD NAME=NOTEPAD\nPROC 0 +\n       XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nEVALSYM IPCSNOTEPADCOUNT CLIST(DEC LEN(COUNT))\nIF &COUNT = THEN DO\n NOTE '*** Note pad empty ***' ASIS\nEND\nELSE DO\n SET N = 0\n DO WHILE &N LE &COUNT\n  EVALSYM IPCSNOTEPAD&N CLIST(ENQUOTE REMARK(NOTE))\n  NOTE &NRSTR(&NOTE) ASIS\n  SET N = &N+1\n END\nEND\n./ ADD NAME=NOTES\nPROC 0 XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nSET N = 0\nEVALSYM IPCSNOTEPADCOUNT CLIST(DEC LEN(N))\nIF &N = THEN SET N = 0\nSET N = &N+1\nEQ IPCSNOTEPAD&N 0. REMARK(+\n'--------- &SYSUID - &SYSDATE - &SYSSTIME ----------'+\n)\nWRITE No more than 80 chars per line, please.  Hit ENTER when finished.\nLOOP:+\nWRITENR >\nREAD\nIF &LENGTH(&NRSTR(&SYSDVAL)) = 0 THEN GOTO FINISH\nIF &LENGTH(&NRSTR(&SYSDVAL)) > 80 THEN DO\n WRITE Input too long; reenter.\n GOTO LOOP\nEND\nSET N = &N+1\nSET I = 0\nSET L = &LENGTH(&NRSTR(&SYSDVAL))\nSET MSG =\nDO WHILE &I LT &L\n SET I = &I+1\n SET C = &SUBSTR(&I,&NRSTR(&SYSDVAL))\n IF &NRSTR(&C) = ' THEN SET MSG = &NRSTR(&MSG)''\n ELSE SET MSG = &NRSTR(&MSG&C)\nEND\nEQ IPCSNOTEPAD&N 0. REMARK('&NRSTR(&MSG)')\nGOTO LOOP\nFINISH:+\nEQ IPCSNOTEPADCOUNT 0. LENGTH(&N)\nEND\n./ ADD NAME=PIEMAP\nPROC 0 TCB() FORCE ACTIVE DUMP XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n/* Code to extract current TCB\nIF &STR(&TCB) = THEN DO\n SET TCB = 0\n EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))\n IF &TCB = 0 THEN DO\n  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))\n  IF &TCB = 0 THEN DO\n   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))\n   IF &TCB = 0 THEN DO\n    NOTE 'TCB unavailable' ASIS\n    EXIT C(12) Q\n   END\n  END\n END\nEND\nIF &SYSINDEX(.,&TCB) = 0 THEN SET TCB = &STR(&TCB..)\n/* End code to extract current TCB\n\nSET TCBJSTCB = 00000000\nSYSCALL ISET TCBJSTCB &TCB+7C L(4) PTR &ACTIVE\nSET TCBOTC =\nSYSCALL ISET TCBOTC &TCBJSTCB..+84 L(4) PTR &ACTIVE\nIF &TCBOTC = 0 THEN DO\n NOTE 'PIE is not active in this environment.' ASIS\n EXIT C(4)\nEND\nSET PIETCB = &STR(&TCBOTC..)\nSET TCBUSER = 00000000\nSYSCALL ISET TCBUSER &PIETCB+A8 L(4) PTR &ACTIVE\nSET SCVT = &STR(&TCBUSER..)\nIF &STR(&TCBUSER) = &STR(00000000) THEN DO\n NOTE 'TCB at &PIETCB has no TCBUSER (i.e. PIE SCVT) field.' ASIS\n NOTE 'Try another TCB, maybe.' ASIS\n EXIT C(4)\nEND\nSET SCVT_EYECATCHER = &STR(something other than C'SCVT')\nSYSCALL ISET SCVT_EYECATCHER &SCVT+0 L(4) CHAR &ACTIVE\nNOTE '---- PIE SCVT at &SCVT ----' ASIS SPACE(1)\nNOTE SPACE(1)\nIF &STR(&SCVT_EYECATCHER) ^= SCVT THEN DO\n NOTE +\n 'Warning:  SCVT eyecatcher not SCVT, but &NRSTR(&SCVT_EYECATCHER)' +\n      ASIS\n NOTE SPACE(1)\nEND\nSET SWKEY =\nSYSCALL ISET SWKEY  &SCVT+A2 L(4) CHAR &ACTIVE\nSET SWCHAR =\nSYSCALL ISET SWCHAR &SCVT+A7 L(1) CHAR &ACTIVE\nSET JMKEY =\nSYSCALL ISET JMKEY  &SCVT+310 L(4) CHAR &ACTIVE\n\nNOTE '    Switch Key .......... &NRSTR(&SWKEY)'     ASIS\nNOTE '    Switch Character .... \"&NRSTR(&SWCHAR)\"'  ASIS\nNOTE '    Jump Key ............ &NRSTR(&JMKEY)'     ASIS\n\n/**********************************************************************/\n/*                                                                    */\n/* Chain through the STCB's.                                          */\n/*                                                                    */\n/**********************************************************************/\n\nSET SCVT_STCB_POINTER =\nIF &FORCE = FORCE THEN SET FIRST_STCB = N\nELSE SET FIRST_STCB = Y\nSYSCALL ISET SCVT_STCB_POINTER &SCVT+4 L(4) PTR &ACTIVE\nDO WHILE &SCVT_STCB_POINTER ^= 0\n SET STCB = &STR(&SCVT_STCB_POINTER..)\n SET STCB_EYECATCHER = &STR(something other than C'STCB')\n SYSCALL ISET STCB_EYECATCHER &STCB+0 L(4) CHAR &ACTIVE\n IF &STR(&STCB_EYECATCHER) ^= STCB THEN DO\n  NOTE +\n  'Warning:  STCB eyecatcher not STCB, but &NRSTR(&STCB_EYECATCHER)' +\n       ASIS\n  NOTE SPACE(1)\n END\n NOTE SPACE(1)\n\n SET TCB = 000000\n SYSCALL ISET TCB &STCB+D L(3) PTR &ACTIVE\n SYSCALL DO_TCB_STUFF &TCB &ACTIVE &DUMP\n IF &LASTCC = 0 THEN SET STATUS = active\n ELSE SET STATUS = pending\n\n SET SESSION_ID =\n SYSCALL ISET SESSION_ID &STCB+84 L(1) CHAR &ACTIVE\n SET SESSION_ID_HEX =\n SYSCALL ISET SESSION_ID_HEX &STCB+84 L(1) HEX &ACTIVE\n IF &FIRST_STCB = Y THEN DO\n  SET FIRST_STCB = N\n  NOTE 'Warning:  First STCB in chain not shown, probably invalid.' ASIS\n END\n ELSE DO\n  NOTE '---- PIE STCB at &STCB ---- +\n        Session number &SESSION_ID (X''&SESSION_ID_HEX'') is &STATUS' +\n       ASIS\n  NOTE SPACE(1)\n\n  SET PTCB =\n  SYSCALL ISET PTCB &STCB+C L(4) PTR &ACTIVE NOCHECK\n\n  SET PECT =\n  SYSCALL ISET PECT &STCB+10 L(4) PTR &ACTIVE NOCHECK\n\n  IF &STR(&PECT) ^= &STR(00000000) THEN DO\n   SET PCMD =\n   SYSCALL ISET PCMD &PECT.+C L(8) CHAR &ACTIVE NOCHECK\n  END\n  ELSE SET PCMD = &STR(********)\n\n  SET NOTE =\n  SYSCALL ISET NOTE &STCB+A2 L(100) CHAR &ACTIVE NOCHECK\n\n  NOTE 'TCB...&NRSTR(&PTCB)   ECT...&NRSTR(&PECT)   +\n       Command: &NRSTR(&PCMD)' ASIS\n  NOTE 'Note:    &NRSTR(&NOTE)' ASIS SPACE(1)\n\n END\n\n IF &DUMP = DUMP THEN DO\n  %DUMPCB STCB &STCB X'330'\n END\n\n /* get next STCB...\n SYSCALL ISET SCVT_STCB_POINTER &STCB+4 L(4) PTR &ACTIVE\n\nEND\n\n/**********************************************************************/\n/*                                                                    */\n/* Chain through daughters of the PIE TCB.  These should all be       */\n/* job step TCB's for the TMP.  This is probably not necessary to     */\n/* do, because they won't tell us anything the STCB's won't tell us.  */\n/*                                                                    */\n/**********************************************************************/\n/*\n/*  SET TCB =\n/*  SYSCALL ISET TCB &PIETCB+89 L(3) PTR &ACTIVE\n/*  DO WHILE &TCB ^= 0\n/*   SYSCALL DO_TCB_STUFF &TCB &ACTIVE &DUMP\n/*   /* get next (sister) TCB ...\n/*   SYSCALL ISET TCB &TCB..+81 L(3) PTR &ACTIVE\n/*  END\n\nNOTE SPACE(1)\nEXIT\n\nISET: PROC 2 CLISTVAR FIELD ACTIVE NOCHECK +\n             LENGTHVALUE(4) PTR POINTER SIGNED UNSIGNED CHARACTER HEX\n SET TITLE = &STR(&CLISTVAR) /* before SYSREFfing\n SYSREF CLISTVAR\n SET PREVIOUS_VALUE = &NRSTR(&CLISTVAR)\n IF &SYSINDEX(.,&FIELD) = 9 THEN DO\n  SYSCALL FIXUP FIELD\n END\n EVAL &FIELD L(&LENGTHVALUE) &PTR &POINTER &SIGNED &UNSIGNED +\n                             &CHARACTER &HEX &ACTIVE +\n      CLIST(S(CLISTVAR))\n IF &LASTCC ^= 0 THEN DO\n  NOTE 'Error: &NRSTR(&TITLE) at &NRSTR(&FIELD) not accessible.' ASIS\n  EXIT C(12) Q\n END\n IF &NOCHECK = THEN DO\n  IF &NRSTR(&CLISTVAR) = &NRSTR(&PREVIOUS_VALUE) THEN DO\n   NOTE +\n 'Error: &NRSTR(&TITLE) at &NRSTR(&FIELD) is &NRSTR(&PREVIOUS_VALUE).' +\n        ASIS\n   EXIT C(12) Q\n  END\n END\n RETURN\nEND\n\nFIXUP: PROC 1 AFIELD\n SYSREF AFIELD\n SET I = &SYSINDEX(&SUBSTR(1,&AFIELD),89ABCDEF)\n IF &I ^= 0 THEN DO\n  SET AFIELD = +\n      &SUBSTR(&I,01234567)&SUBSTR(2:&LENGTH(&STR(&AFIELD)),&AFIELD)\n END\nEND\n\nDO_TCB_STUFF: PROC 1 TCB ACTIVE DUMP\n SET RB = 000000\n SYSCALL ISET RB &TCB..+1 L(3) PTR &ACTIVE\n SET HERE = &STR(TCB &TCB and RB &RB)\n SET CDE =\n SYSCALL ISET CDE &RB..+D L(3) PTR &ACTIVE\n IF &CDE = 0 THEN DO\n  IF &DUMP ^= THEN DO\n   NOTE 'CDE for &HERE does not exist.  Inactive PIE session.' ASIS\n  END\n  RETURN CODE(4)\n END\n ELSE DO\n  SET CDENAME =\n  SYSCALL ISET CDENAME &CDE..+8 L(8) CHAR &ACTIVE\n  IF &DUMP ^= THEN DO\n   NOTE 'CDE for &HERE is &NRSTR(&CDENAME).' ASIS\n  END\n  RETURN CODE(0)\n END\nEND\n./ ADD NAME=QUOTE\n/* The following function enquotes a string. */\nquote:\nparse arg string\nix = 1\ndo forever\n ix = pos(\"'\",string,ix)\n if ix = 0 then return \"'\"string\"'\"\n string = insert(\"'\",string,ix)\n ix=ix+2\nend\n./ ADD NAME=REGS\nPROC 0 RBADDR() TCBADDR() XTRACE\n/***********************************************************************\n/*                                                                     *\n/* Author: S. BACHER                                                   *\n/*                                                                     *\n/***********************************************************************\nIF &XTRACE=XTRACE THEN CONTROL CONLIST SYMLIST LIST MSG\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nIF &STR(&RBADDR&TCBADDR) = THEN DO\n EVALSYM REGS CLIST(S(DUMMY))\n IF &LASTCC ^= 0 THEN DO\n  NOTE +\n  'REGS not defined - issue REGS RB(rbaddress) or TCB(tcbaddress).' +\n       ASIS\n  EXIT C(0)\n END\n EVALSYM RB CLIST(ADDRESS(RBADDR))\n EVALSYM TCB CLIST(ADDRESS(TCBADDR))\n IF &RBADDR ^= && &TCBADDR ^= THEN DO\n  NOTE 'Both RB and TCB defined, using RB.' ASIS\n  SET TCBADDR =\n END\n SET REGNO = 0\n SET I = 1\n DO WHILE &REGNO < 16\n  EVAL R&REGNO LE(4) CLIST(S(REG&REGNO))\n  SET REGNO = &REGNO+1\n END\n IF &STR(&RBADDR) ^= THEN +\n NOTE 'Registers for RB at &RBADDR..' ASIS\n ELSE +\n NOTE 'Registers for TCB at &TCBADDR..' ASIS\nEND\nELSE IF &STR(&TCBADDR) ^= THEN DO\n SET L = &LENGTH(&STR(&TCBADDR))\n IF &SUBSTR(&L,&TCBADDR) = . THEN SET TCBADDR = &SUBSTR(1:&L-1,&TCBADDR)\n EQ TCB &TCBADDR.. STRUCTURE(TCB)\n SET TCBREGS = &STR(XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                    )\n INTEGER X'&TCBADDR' UNSIGNED CLIST(S(DECIMALTCBADDR))\n SET DECREGADDR = &DECIMALTCBADDR+48\n INTEGER &DECREGADDR PTR CLIST(S(TCBREGADDR))\n EVAL &TCBREGADDR.. LE(64) HEX CLIST(S(TCBREGS))\n EQ REGS &TCBREGADDR.. LE(64)\n SET REGNO = 0\n SET I = 1\n DO WHILE &REGNO < 16\n  SET REG&REGNO = &SUBSTR(&I:&I+7,&TCBREGS)\n  INTEGER &DECREGADDR PTR CLIST(S(REGADDR))\n  EQ R&REGNO &REGADDR.. LE(4)\n  STACK &REGADDR..? REMARK('Register &REGNO (TCB=&TCBADDR..)')\n  SET I = &I+8\n  SET REGNO = &REGNO+1\n  SET DECREGADDR = &DECREGADDR+4\n END\n NOTE 'Registers for TCB at &TCBADDR..' ASIS\nEND\nELSE DO\n SET L = &LENGTH(&STR(&RBADDR))\n IF &SUBSTR(&L,&RBADDR) = . THEN SET RBADDR = &SUBSTR(1:&L-1,&RBADDR)\n EQ RB &RBADDR.. STRUCTURE(RB)\n SET RBREGS = &STR(XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                   )\n INTEGER X'&RBADDR' UNSIGNED CLIST(S(DECIMALRBADDR))\n SET DECREGADDR = &DECIMALRBADDR+32\n INTEGER &DECREGADDR PTR CLIST(S(RBREGADDR))\n EVAL &RBREGADDR.. LE(64) HEX CLIST(S(RBREGS))\n EQ REGS &RBREGADDR.. LE(64)\n SET REGNO = 0\n SET I = 1\n DO WHILE &REGNO < 16\n  SET REG&REGNO = &SUBSTR(&I:&I+7,&RBREGS)\n  INTEGER &DECREGADDR PTR CLIST(S(REGADDR))\n  EQ R&REGNO &REGADDR.. LE(4)\n  STACK &REGADDR..? REMARK('Register &REGNO (RB=&RBADDR..)')\n  SET I = &I+8\n  SET REGNO = &REGNO+1\n  SET DECREGADDR = &DECREGADDR+4\n END\n NOTE 'Registers for RB at &RBADDR..' ASIS\nEND\nNOTE SPACE(1)\nNOTE &STR(' R0 = &REG0  R1 = &REG1  R2 = &REG2  R3 = &REG3')\nNOTE &STR(' R4 = &REG4  R5 = &REG5  R6 = &REG6  R7 = &REG7')\nNOTE &STR(' R8 = &REG8  R9 = &REG9  R10= &REG10  R11= &REG11')\nNOTE &STR(' R12= &REG12  R13= &REG13  R14= &REG14  R15= &REG15')\nNOTE SPACE(1)\nEXIT\n./ ADD NAME=REXXCB\nPROC 0 ECT(ECT) TCB(21C.?) XTRACE\nNGLOBAL ENVBLOCK_P ECTEXT_P PARMBLOCK_P WORKBLOCKEXTENSION_P +\n        MODNAMET_P SUBCOMTB_P PACKTB_P EXECBLK_P INSTBLK_P EVALBLOCK_P\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOFLUSH NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n WRITE *** You must be in IPCS to use this CLIST. ***\n EXIT C(16) Q\nEND\n\nNOTE SPACE(1)\n\nIF &XTRACE = THEN CONTROL NOMSG\nDROPSYM (ENVBLOCK ECTEXT PARMBLOCK WORKBLOCKEXTENSION +\n         MODNAMET SUBCOMTB PACKTB EXECBLK INSTBLK EVALBLOCK) NOSUMMARY\nCONTROL MSG\n\nSYSCALL BLOCK ENVBLOCK            &ECT.+30                L(288)\nSYSCALL BLOCK ECTEXT              &ECT.+34                L(256)\nIF &ENVBLOCK_P = Y THEN DO\n SYSCALL BLOCK PARMBLOCK           ENVBLOCK+10             L(64)\n SYSCALL BLOCK WORKBLOCKEXTENSION  ENVBLOCK+18             L(32)\n IF &PARMBLOCK_P = Y THEN DO\n  SYSCALL BLOCK MODNAMET            PARMBLOCK+10            L(112)\n  SYSCALL BLOCK SUBCOMTB            PARMBLOCK+14            L(36)\n  SYSCALL BLOCK PACKTB              PARMBLOCK+18            L(48)\n END\n IF &WORKBLOCKEXTENSION_P = Y THEN DO\n  SYSCALL BLOCK EXECBLK             WORKBLOCKEXTENSION+00   L(48)\n  SYSCALL BLOCK INSTBLK             WORKBLOCKEXTENSION+0C   L(128)\n  SYSCALL BLOCK EVALBLOCK           WORKBLOCKEXTENSION+14   L(256)\n END\nEND\n\nLISTSYM (ENVBLOCK ECTEXT PARMBLOCK WORKBLOCKEXTENSION +\n         MODNAMET SUBCOMTB PACKTB EXECBLK INSTBLK EVALBLOCK)\n\nNOTE SPACE(1)\n\nSYSCALL LIST ENVBLOCK\nSYSCALL LIST ECTEXT\nSYSCALL LIST PARMBLOCK\nSYSCALL LIST WORKBLOCKEXTENSION\nSYSCALL LIST MODNAMET\nSYSCALL LIST SUBCOMTB\nSYSCALL LIST PACKTB\nSYSCALL LIST EXECBLK\nSYSCALL LIST INSTBLK\nSYSCALL LIST EVALBLOCK\nNOTE SPACE(1)\nNOTE 'End of REXX control block listing.' ASIS\nNOTE SPACE(1)\n\nBLOCK: PROC 2 BLOCKNAME BLOCKADDRESS LENGTHVALUE(256)\nEVAL &BLOCKADDRESS L(4) HEX CLIST(S(BLOCKTEST))\nIF &STR(&BLOCKTEST) = &STR(00000000) THEN DO\n NOTE 'There is no &BLOCKNAME (the pointer at &BLOCKADDRESS is zero).' +\n      ASIS\n SET &&BLOCKNAME._P = N\nEND\nELSE DO\n EQ &BLOCKNAME &BLOCKADDRESS.? L(&LENGTHVALUE)\n SET &&BLOCKNAME._P = Y\nEND\nRETURN\nEND BLOCK\n\nLIST: PROC 1 LBLOCK\nIF &SYSNSUB(2,&&&LBLOCK._P) = Y THEN DO\n NOTE SPACE(1)\n L &LBLOCK MODULE DISPLAY(NOREQUEST)\nEND\nRETURN\nEND LIST\n./ ADD NAME=RTM\n\n/**********************************************************************/\n/*                                                                    */\n/* Updated for ESA.  RTM2WA now above the line.                       */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 0 TCB() RTWA() ACTIVE XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nIF &NRSTR(&RTWA) ^= THEN DO\n SET RTWAPTR = &NRSTR(&RTWA)\n SET X = &SYSINDEX(.,&NRSTR(&RTWAPTR))\n IF &X = 0 THEN SET RTWAPTR = &RTWAPTR\n ELSE SET RTWAPTR = &SUBSTR(1:&X,&NRSTR(&RTWAPTR))\n GOTO PROCESS\nEND\n/* Code to extract current TCB\nIF &STR(&TCB) = THEN DO\n SET TCB = 0\n EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))\n IF &TCB = 0 THEN DO\n  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))\n  IF &TCB = 0 THEN DO\n   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))\n   IF &TCB = 0 THEN DO\n    NOTE 'TCB unavailable' ASIS\n    EXIT C(12) Q\n   END\n  END\n END\n SET TCB = &STR(&TCB..)\nEND\n/* End code to extract current TCB\nEVAL &TCB+E0 L(4) &ACTIVE CLIST(STORAGE(RTWAPTR))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: RTWA pointer in TCB at &TCB could not be accessed.' ASIS\n EXIT C(12) Q\nEND\nIF &RTWAPTR = 0 THEN DO\n NOTE 'TCB at &TCB has no RTM.' ASIS\n EXIT C(12) Q\nEND\nPROCESS:+\nEQ RTM2WA &RTWAPTR.. L(1308)\nNOTE SPACE(1)\nNOTE 'RTM2WA at &RTWAPTR..' ASIS\nNOTE SPACE(1)\nCONTROL NOFLUSH\nSET SUBCMD =\nERROR DO\n SET CC = &LASTCC\n IF &SUBCMD = EVALSYM THEN RETURN\n ERROR OFF\n IF &CC = 12 THEN DO\n  NOTE 'Error accessing RTM2WA storage for RTWA at &RTWAPTR..' ASIS\n  WRITE *** Severe error - LASTCC = &CC\n  EXIT C(12) Q\n END\nEND\nEVAL RTM2WA+0 L(4) CHAR CLIST(S(TEMP))\nIF &STR(&TEMP) NE RTM2 THEN DO\n NOTE 'Error: RTM work area not equal to C''RTM2'', but ''&TEMP''' ASIS\nEND\nEVAL RTM2WA+10 L(4) HEX CLIST(S(RTCB))\nEVAL RTM2WA+14 L(4) HEX CLIST(S(RSVRB))\nNOTE 'TCB for this RTWA is at &RTCB., SVRB is at &RSVRB..'  ASIS\nNOTE SPACE(1)\nEVAL RTM2WA+1C L(4) HEX CLIST(S(TEMP))\nNOTE 'Completion code..........&TEMP'   ASIS\nEVAL RTM2WA+7C L(8) HEX CLIST(S(TEMP))\nNOTE 'PSW.............&SUBSTR(1:8,&TEMP) &SUBSTR(9:16,&TEMP)' ASIS\nNOTE SPACE(1)\nSET NSI = &SUBSTR(9:16,&TEMP)\n%WHERE &NSI.. STACK ID('ABEND LOCATION (RTWA=&RTWAPTR)')\nNOTE SPACE(1)\nEVAL RTM2WA+3C L(64) HEX CLIST(S(TEMP))\nNOTE 'Registers at time of abend....'   ASIS\nSET CC = 0\nSET SUBCMD = EVALSYM\nEVALSYM RTMREGSAT&RTWAPTR\nSET SUBCMD =\nIF &CC ^= 0 THEN DO\n %SHOWREGS &TEMP STACK(RTM2WA+3C) ID(RTWA=&RTWAPTR)\n EQ RTMREGSAT&RTWAPTR &RTWAPTR..\nEND\nELSE DO\n %SHOWREGS &TEMP /* Don't stack - already done */\nEND\nEVAL RTM2WA+8C L(8) CHAR CLIST(S(TEMP))\nNOTE 'Abending program name:  &TEMP' ASIS\nEVAL RTM2WA+94 L(4) PTR  CLIST(S(TEMP))\nNOTE 'Entry point of above:   &TEMP' ASIS\nNOTE SPACE(1)\nSET I = 0\nSET A = &SUBSTR(1,&NSI)\nDO WHILE &I LT 8\n SET I = &I + 1\n IF &A = &SUBSTR(&I,89ABCDEF) THEN DO\n  SET NSI = &SUBSTR(&I,01234567)&SUBSTR(2:8,&NSI)\n  GOTO DOIT\n END\nEND\nDOIT:+\nERROR OFF\n%DUMPCB INSTRUCTIONS_PRECEDING_PSW_ADDRESS &NSI..-20 32 OFFSET(-32) +\n        TITLE('Instructions preceding PSW address')\n%DUMPCB INSTRUCTIONS_FOLLOWING_PSW_ADDRESS &NSI..    32 +\n        TITLE('Instructions following PSW address')\nEXIT\n./ ADD NAME=RUNSAVE\nPROC 0 FIRSTADDR(&TCBADDR.+70%) TCBADDR(21C.%)\n/***********************************************************************\n/*                                                                     *\n/* AUTHOR: S. BACHER                                                   *\n/*                                                                     *\n/* THIS CLIST DEFINES ALL SAVE AREAS IN THE CURRENT SAVE AREA CHAIN    *\n/* STARTING FROM THE TCB'S SAVE AREA FIELD.                            *\n/*                                                                     *\n/* (SAVEAREA001, SAVEAREA002, ETC.)                                    *\n/*                                                                     *\n/* THIS IS THE ORIGINAL \"SAVEAREA\" CLIST; THE NEW \"SAVEAREA\" CLIST     *\n/* IS AN IPCS VERB EXIT INTERFACE WHICH GIVES MORE INFORMATION.        *\n/*                                                                     *\n/***********************************************************************\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** YOU MUST BE IN IPCS TO USE THIS CLIST. ***\n  EXIT C(16) Q\nEND\nRUNCHAIN ADDR(&FIRSTADDR) LINK(8) NAME(SAVEAREA) LENGTH(72)\n./ ADD NAME=S\n/* REXX */\nif sysvar(\"syspcmd\") \\= \"IPCS\" then do\n say \"*** You must be in IPCS to use this exec. ***\"\n exit 16\nend\naddress TSO\narg dumpdataset argjunk\nnew = abbrev(\"NEW\",argjunk,1)\ndo while dumpdataset = \"?\" | dumpdataset = \"\"\n \"%X SYSDSCAN | %GREP -vi ' IS EMPTY'\"\n call xwritenr \"Enter dump data set number (or name) ==>\"\n parse external dumpdataset\nend\nif datatype(dumpdataset,\"W\") then\n dump = \"'SYS1.DUMP\" || right(dumpdataset,2,\"0\") || \"'\"\nelse\n dump = dumpdataset\nif new then queue \"DROPDUMP DATASET(\"dump\")\"\nx = listdsi(dump)\nif x > 0 then do\n say dump\" not available.  Reason:\"\n say sysmsglvl2\n exit\nend\nif syslrecl \\= 4160 then do\n say \"Can't use \"dump\", LRECL not 4160.\"\n exit\nend\nif \\abbrev(sysrecfm,\"F\") then do\n say \"Can't use \"dump\", RECFM not fixed.\"\n exit\nend\nqueue \"SETDEF DSN(\"dump\") LEN(32) FLAG(ERROR) TERMINAL NOPRINT NOCONFIR\"\nqueue \"%HEADER\"\n./ ADD NAME=SA\nPROC 0 TCB() ADDRESS() XTRACE\n/***********************************************************************\n/*                                                                     *\n/* Author: S. BACHER                                                   *\n/*                                                                     *\n/* This CLIST displays all save areas in the current save area chain   *\n/* starting from the specified value.                                  *\n/*                                                                     *\n/***********************************************************************\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n /* Code to extract current TCB\nIF &STR(&TCB&ADDRESS) = THEN DO\n SET TCB = 0\n EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))\n IF &TCB = 0 THEN DO\n  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))\n  IF &TCB = 0 THEN DO\n   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))\n   IF mTCB = 0 THEN DO\n    NOTE 'TCB unavailable' ASIS\n    EXIT C(12) Q\n   END\n  END\n END\n SET TCB = &STR(&TCB..)\nEND\nIF &STR(&ADDRESS) = THEN DO\n EVAL &TCB+70 PTR CLIST(S(ADDRESS))\n IF &ADDRESS = 0 THEN DO\n  NOTE 'TCB at &TCB has no save area pointer.' ASIS\n  EXIT Q\n END\nEND\n/*\n/* Code suppressed...\n/*\n/* Now that we have the save area address, follow the chain upwards\n/* until we get to the highest one.\n/*\n/*   SET PREVADDR =\n/*   CHAIN:+\n/*   IF &STR(&PREVADDR) ^= THEN DO\n/*    EVAL &ADDRESS+8 PTR CLIST(S(LSA))\n/*    IF &STR(&PREVADDR) ^= &STR(&LSA) THEN DO\n/*     NOTE 'Stopping due to invalid back chain' ASIS\n/*     WRITE ADDRESS=&ADDRESS, LSA=&LSA, PREVADDR=&PREVADDR\n/*     NOTE SPACE(1)\n/*     GOTO GOTIT\n/*    END\n/*   END\n/*   EVAL &ADDRESS+4 PTR CLIST(S(HSA))\n/*   IF &STR(&HSA) = 0 THEN GOTO GOTIT\n/*   SET PREVADDR = &STR(&ADDRESS)\n/*   SET ADDRESS = &STR(&HSA)\n/*   GOTO CHAIN\nGOTIT:+\nTCBX YITSAV &ADDRESS\n./ ADD NAME=SAVEAREA\nPROC 0 TCB() XTRACE\n/***********************************************************************\n/*                                                                     *\n/* Author: S. BACHER                                                   *\n/*                                                                     *\n/* This CLIST displays all save areas in the current save area chain   *\n/* starting from the TCB's save area field.                            *\n/*                                                                     *\n/***********************************************************************\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) = IPCS THEN DO\n /* Code to extract current TCB\n IF &STR(&TCB) = THEN DO\n  SET TCB = 0\n  EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))\n  IF &TCB = 0 THEN DO\n   EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))\n   IF &TCB = 0 THEN DO\n    EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))\n    IF &TCB = 0 THEN DO\n     NOTE 'TCB unavailable' ASIS\n     EXIT C(12) Q\n    END\n   END\n  END\n END\n /* End code to extract current TCB\n IF &SYSINDEX(.,&STR(&TCB)) = 0 THEN SET TCB = &STR(&TCB..)\n TCBX XITSAV &TCB\n SET CC = &LASTCC\n IF &CC ^= 0 THEN DO\n  WRITE XITSAV TCB exit error code &CC..\n END\nEND\nELSE DO\n IF &NRSTR(&TCB) ^= && &NRSTR(&TCB) ^= &STR(*) THEN +\n  WRITE Warning: TCB operand ignored in active mode.\n XCMD XITSAV\nEND\n./ ADD NAME=SETACF\nPROC 0 ACCVTP() ACTIVE XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n\n/* Get ASID from ASVT */\n/*  EVAL 224.%+24 L(2) UNS &ACTIVE CLIST(S(ASIDFROMASVT))\n/*  IF &LASTCC = 12 THEN DO\n/*   NOTE 'Error: Unable to access ASID from ASVT.' SPACE(1) ASIS\n/*   EXIT C(12) Q\n/*  END\n/* SET ASIDINDEX = &ASIDFROMASVT*32 /* Convert to index to ACFASVT */\n\n%GETASID &XTRACE\nSET ASID = &LASTCC\nINTEGER &ASID PTR(4) CLIST(S(ASIDX))\nINTEGER &ASID UNS    CLIST(S(ASIDN))\nSET ASIDINDEX = &ASIDN*32 /* Convert to index to ACFASVT */\n\nIF &STR(&ACCVTP) ^= THEN DO\n IF &SUBSTR(&LENGTH(&STR(&ACCVTP)),&ACCVTP) = . THEN +\n  SET ACCVTP = &SUBSTR(1:&LENGTH(&STR(&ACCVTP))-1,&ACCVTP)\n GOTO GOTACCVT\nEND\n\nEVAL 10.%+128%+19 L(3) PTR &ACTIVE   /* Look for ACCVT via subsys   */+\n                  CLIST(S(JESCTP))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: Unable to access JESCT via CVT.' SPACE(1) ASIS\n EXIT C(12) Q\nEND\nLOOP:+\nEVAL &JESCTP..+8 L(4) CHAR &ACTIVE   /* Extract subsystem ID        */+\n                 CLIST(S(SUBSYSID))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: Unable to access subsystem ID from JESCT at &JESCTP..' +\n      SPACE(1) ASIS\n EXIT C(12) Q\nEND\nIF &NRSTR(&SUBSYSID) = ACF2 THEN     /* Loop until ACF2 subsystem   */+\n GOTO GOTACF2\nEVAL &JESCTP..+5 L(3) PTR &ACTIVE    /* Chain thru subsys entries   */+\n                 CLIST(S(JESCTP))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: Unable to access next JESCT from JESCT at &JESCTP..' +\n      SPACE(1) ASIS\n EXIT C(12) Q\nEND\nIF &JESCTP = 0 THEN DO\n NOTE 'The ACF2 subsystem is not active.' ASIS\n EXIT C(4)\nEND\nGOTO LOOP                            /* When found, set ACCVT addr  */\nGOTACF2:+\nEVAL       &JESCTP..+15       L(3)     PTR &ACTIVE CLIST(S(ACCVTP)  )\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: ACCVT unavailable.' ASIS\n GOTO EXIT\nEND\nIF &ACCVT = 0 THEN DO\n NOTE 'There is no ACCVT.' ASIS\n GOTO EXIT\nEND\n\nGOTACCVT:SET DUMMY = NOTHING\n\nEQ ACCVT   &ACCVTP..          L(512)       &ACTIVE\nEVAL       &ACCVTP..+65       L(3)     UNS &ACTIVE CLIST(S(ACFASVTN))\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: ACFASVT unavailable.' ASIS\n GOTO EXIT\nEND\nIF &ACFASVTP = 0 THEN DO\n NOTE 'There is no ACFASVT.' ASIS\n GOTO EXIT\nEND\nINTEGER    &EVAL(&ACFASVTN+&ASIDINDEX) PTR         CLIST(S(ACFASVTP))\nEQ ACFASVT &ACFASVTP..        L(32)        &ACTIVE\nEVAL       ACFASVT+1D         L(3)     PTR &ACTIVE CLIST(S(ACUCBP)  )\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: ACUCB unavailable.' ASIS\n GOTO EXIT\nEND\nIF &ACUCBP = 0 THEN DO\n NOTE 'There is no ACUCB.' ASIS\n GOTO EXIT\nEND\nEQ ACUCB   &ACUCBP..          L(192)       &ACTIVE\nEVAL       ACUCB+1D           L(3)     PTR &ACTIVE CLIST(S(LIDRECP) )\nIF &LASTCC = 12 THEN DO\n NOTE 'Error: LIDREC unavailable.' ASIS\n GOTO EXIT\nEND\nIF &LIDRECP = 0 THEN DO\n NOTE 'There is no LIDREC.' ASIS\n GOTO EXIT\nEND\nEQ LIDREC  &LIDRECP..         L(192)       &ACTIVE\nEXIT:+\nLISTSYM    (ACCVT ACFASVT ACUCB LIDREC)    &ACTIVE\nIF &ACTIVE = THEN DO\n STACK    ACCVT   REM('ACCVT'  )\n STACK    ACFASVT REM('ACFASVT')\n STACK    ACUCB   REM('ACUCB'  )\n STACK    LIDREC  REM('LIDREC' )\nEND\n./ ADD NAME=SHOWREGS\nPROC 1 REGS STACK() ID() OTHERSTUFF() EQUATEPREFIX() XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nSET I = 1\nSET REGOFF = 0\nDO &REGNO = 0 TO 15\n SET REGISTER_CONTENTS = &SUBSTR(&I:&I+7,&REGS)\n SET REG&REGNO = &STR(&REGISTER_CONTENTS)\n SELECT &SUBSTR(1,&REGISTER_CONTENTS)\n  WHEN (8) SET REGISTER_CONTENTS=&STR(0&SUBSTR(2:8,&REGISTER_CONTENTS))\n  WHEN (9) SET REGISTER_CONTENTS=&STR(1&SUBSTR(2:8,&REGISTER_CONTENTS))\n  WHEN (A) SET REGISTER_CONTENTS=&STR(2&SUBSTR(2:8,&REGISTER_CONTENTS))\n  WHEN (B) SET REGISTER_CONTENTS=&STR(3&SUBSTR(2:8,&REGISTER_CONTENTS))\n  WHEN (C) SET REGISTER_CONTENTS=&STR(4&SUBSTR(2:8,&REGISTER_CONTENTS))\n  WHEN (D) SET REGISTER_CONTENTS=&STR(5&SUBSTR(2:8,&REGISTER_CONTENTS))\n  WHEN (E) SET REGISTER_CONTENTS=&STR(6&SUBSTR(2:8,&REGISTER_CONTENTS))\n  WHEN (F) SET REGISTER_CONTENTS=&STR(7&SUBSTR(2:8,&REGISTER_CONTENTS))\n END\n IF &STR(&EQUATEPREFIX) ^= &STR() THEN DO\n  EQ &EQUATEPREFIX&REGNO &REGISTER_CONTENTS..\n END\n IF &STR(&STACK) ^= THEN DO\n/*STACK &STACK+&REGOFF.N? &OTHERSTUFF REMARK('Register &REGNO (&ID)')\n  STACK &REGISTER_CONTENTS.. &OTHERSTUFF +\n       REMARK('&SUBSTR(1:20,(&ID)                    ) Register &REGNO')\n END\n SET I = &I+8\n SET REGOFF = &REGOFF+4\nEND\nNOTE SPACE(1)\nNOTE &STR(' R0 = &REG0  R1 = &REG1  R2 = &REG2  R3 = &REG3')\nNOTE &STR(' R4 = &REG4  R5 = &REG5  R6 = &REG6  R7 = &REG7')\nNOTE &STR(' R8 = &REG8  R9 = &REG9  R10= &REG10  R11= &REG11')\nNOTE &STR(' R12= &REG12  R13= &REG13  R14= &REG14  R15= &REG15')\nNOTE SPACE(1)\n./ ADD NAME=SSN\nPROC 0 ACTIVE XTRACE\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nEVAL 224.%+24 L(2) &ACTIVE           /* Get ASID from ASVT          */\nSET ASIDINDEX = &LASTCC*32           /* Convert to index to ACFASVT */\nEVAL 10.%+128%+19 L(3) PTR &ACTIVE   /* Get a subsystem entry       */+\n                  CLIST(S(SUBSYSP))\nSET SUBSYSP = &STR(00&SUBSYSP)\nLOOP:+\nEVAL &SUBSYSP..+8 L(4) CHAR &ACTIVE  /* Extract subsystem ID        */+\n                 CLIST(S(SUBSYSID))\nNOTE 'Subsystem: &NRSTR(&SUBSYSID)' ASIS\n%DUMPCB SUBSYSTEM &SUBSYSP.. 36\nEVAL &SUBSYSP..+4 L(4) PTR &ACTIVE   /* Chain thru subsys entries   */+\n                 CLIST(S(SUBSYSP))\nIF &SUBSYSP = 0 THEN DO\n NOTE ''\n NOTE 'End of subsystem table.' ASIS\n EXIT\nEND\nGOTO LOOP\n./ ADD NAME=SUM\nPROC 0 XTRACE\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n WRITE *** You must be in IPCS to use this CLIST. ***\n EXIT C(16) Q\nEND\n/******************************************************************/\n/* Get the current ASID                                           */\n/******************************************************************/\n%GETASID\nSET ASID = &LASTCC\nNOTE SPACE(1)\nNOTE '*** SUM - User summary of TCB''s and RB''s for ASID &ASID ***' ASI\nNOTE SPACE(1)\n/******************************************************************/\n/* Locate the ASCB, ASXB, and 1st TCB for this memory             */\n/******************************************************************/\nEVALDEF CLIST(DATASET(DEFDS))\nIF &STR(&DEFDS) = ACTIVE THEN +\n EVAL 224.                           PTR CLIST(S(ASCBADDR))\nELSE +\n EVAL 10.%+22C%+20C+&EVAL(4*&ASID)N  PTR CLIST(S(ASCBADDR))\nEVAL &ASCBADDR..+6C                  PTR CLIST(S(ASXBADDR))\nIF &LASTCC=12 THEN DO\n NOTE '==> Error: ASXB not available for ASID(&ASID)' ASIS\n EXIT C(4)\nEND\nSET TCBCTR=1\nEVAL &ASXBADDR..+5 LE(3) PTR CLIST(S(TCBADDR))\nIF &LASTCC=12 THEN DO\n L &ASXBADDR..+5 LE(3) PTR\n NOTE '==> Error: TCB&TCBCTR not available for ASID(&ASID)' ASIS\n EXIT C(4)\nEND\n/******************************************************************/\n/* Process all TCBs for this address space                        */\n/******************************************************************/\nDO WHILE &TCBADDR^=0\n EQ TCB&TCBCTR &TCBADDR.. STRUCTURE(TCB)\n /* STACK &TCBADDR.. REM('TCB&TCBCTR AT &TCBADDR')\n INTEGER X'&TCBADDR'         SIGNED CLIST(S(TCBADDRN))\n EVAL &TCBADDR..+48 LE(64) HEX CLIST(S(TCBREGS))\n EQ TCB&TCBCTR.REGS &TCBADDR..+48 LE(4) ENTRIES(0:15) HEX\n EVAL &TCBADDR..+10 LE(4) HEX CLIST(S(TCBCOMP))\n EVAL &TCBADDR..+70 LE(4) PTR CLIST(S(TCBSAVE))\n NOTE '*** TCB&TCBCTR at &TCBADDR - Compcode = &TCBCOMP - +\n      Savearea = &TCBSAVE' ASIS\n NOTE SPACE(1)\n SET REGNO = 0\n SET I = 1\n DO WHILE &REGNO < 16\n  SET REG&REGNO = &SUBSTR(&I:&I+7,&TCBREGS)\n  SET I = &I+8\n  SET REGNO = &REGNO+1\n END\n NOTE &STR('R0 = &REG0  R1 = &REG1  R2 = &REG2  R3 = &REG3')\n NOTE &STR('R4 = &REG4  R5 = &REG5  R6 = &REG6  R7 = &REG7')\n NOTE &STR('R8 = &REG8  R9 = &REG9  R10= &REG10  R11= &REG11')\n NOTE &STR('R12= &REG12  R13= &REG13  R14= &REG14  R15= &REG15')\n NOTE SPACE(1)\n /****************************************************************/\n /* Find the 1st RB address for this TCB                         */\n /****************************************************************/\n SET RCODE=0\n SET RBERR=0\n SET RBCTR=1\n EVAL &TCBADDR..+1 LE(3) PTR CLIST(S(RBADDR))\n IF &LASTCC=12 THEN DO\n  NOTE ' ==> Error: RB&RBCTR not available for ASID(&ASID)' ASIS\n  SET &RCODE=4\n  SET &RBERR=1\n END\n EQ TCB&TCBCTR.RB&RBCTR &RBADDR.. STRUCTURE(RB)\n /* STACK &RBADDR.. REM('TCB&TCBCTR.RB&RBCTR AT &RBADDR')\n /****************************************************************/\n /* Process all RBs for this TCB                                 */\n /****************************************************************/\n DO WHILE &RBADDR^=&TCBADDR\n  SET MODNAME =\n  SET RBINTCOD = &STR((not available))\n  EVAL &RBADDR..-2 LE(2) HEX CLIST(S(RBINTCOD))\n  COMPARE ADDRESS(&RBADDR..+A) LE(1) +\n          WITH(VALUE(X'00')) MASK(X'E0')\n  IF &LASTCC=0 THEN DO\n   SET &RBTYPE=PRB\n   EVAL &RBADDR..+D LE(3) PTR CLIST(S(CDEADDR))\n   IF &CDEADDR = 000000 THEN SET MODNAME = &STR(*UNKNOWN*)\n   ELSE EVAL &CDEADDR..+8 LE(8) CHAR CLIST(S(MODNAME))\n  END\n  ELSE DO\n   COMPARE ADDRESS(&RBADDR..+A) LE(1) +\n           WITH(VALUE(X'C0')) MASK(X'E0')\n   IF &LASTCC=0 THEN DO\n    SET &RBTYPE=SVRB\n   END\n   ELSE DO\n    COMPARE ADDRESS(&RBADDR..+A) LE(1) +\n            WITH(VALUE(X'60')) MASK(X'E0')\n    IF &LASTCC=0 THEN DO\n     SET &RBTYPE=TIRB\n    END\n    ELSE DO\n     COMPARE ADDRESS(&RBADDR..+A) LE(1) +\n             WITH(VALUE(X'40')) MASK(X'E0')\n     IF &LASTCC=0 THEN DO\n      SET &RBTYPE=IRB\n     END\n     ELSE DO\n      COMPARE ADDRESS(&RBADDR..+A) LE(1) +\n              WITH(VALUE(X'80')) MASK(X'E0')\n      IF &LASTCC=0 THEN DO\n       SET &RBTYPE=SIRB\n      END\n      ELSE DO\n       EVAL &RBADDR..+A LE(1) HEX CLIST(S(RBFTP))\n       IF &LASTCC=12 THEN SET RBFTP = &STR((not accessible))\n       NOTE ' ==> Error: RBFTP &RBFTP for RB&RBCTR not recognizable' ASI\n       SET &RCODE=4\n       SET &RBTYPE=RB\n      END\n     END\n    END\n   END\n  END\n  IF &STR(&MODNAME) = THEN SET MODDISP = &STR(NO CDE)\n  ELSE SET MODDISP = &STR(CDE &MODNAME)\n  NOTE ' *** &RBTYPE TCB&TCBCTR.RB&RBCTR. at &RBADDR - Int &RBINTCOD - +\n       &MODDISP' ASIS\n  SET RBOPSW = &STR((XXXXXX)(XXXXXX))\n  EVAL &RBADDR..+10 LE(8) HEX CLIST(S(RBOPSW))\n  NOTE ' *** PSW is &SUBSTR(1:8,&RBOPSW) &SUBSTR(9:16,&RBOPSW)' ASIS\n  NOTE SPACE(1)\n  SET RBREGS = &STR(XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+\n                    )\n  EVAL &RBADDR..+20 LE(64) HEX CLIST(S(RBREGS))\n  EQ TCB&TCBCTR.RB&RBCTR.REGS &RBADDR..+20 LE(4) ENTRIES(0:15) HEX\n  SET REGNO = 0\n  SET I = 1\n  DO WHILE &REGNO < 16\n   SET REG&REGNO = &SUBSTR(&I:&I+7,&RBREGS)\n   SET I = &I+8\n   SET REGNO = &REGNO+1\n  END\n  NOTE &STR(' R0 = &REG0  R1 = &REG1  R2 = &REG2  R3 = &REG3')\n  NOTE &STR(' R4 = &REG4  R5 = &REG5  R6 = &REG6  R7 = &REG7')\n  NOTE &STR(' R8 = &REG8  R9 = &REG9  R10= &REG10  R11= &REG11')\n  NOTE &STR(' R12= &REG12  R13= &REG13  R14= &REG14  R15= &REG15')\n  NOTE SPACE(1)\n  SET &RBCTR=&RBCTR+1\n  EVAL &RBADDR..+1D LE(3) PTR CLIST(S(RBADDR))\n  IF &LASTCC=12 THEN DO\n   NOTE '==> Error: TCB&TCBCTR.RB&RBCTR not available for ASID(&ASID)' +\n        ASIS\n   SET RCODE=4\n   SET RBERR=1\n  END\n END\n /* End of RB loop */\n SET &TCBCTR=&TCBCTR+1\n EVAL &TCBADDR..+75 LE(3) PTR CLIST(S(TCBADDR))\n IF &LASTCC=12 THEN DO\n  NOTE '==> Error: TCB&TCBCTR not available for ASID(&ASID)' ASIS\n  EXIT C(4)\n END\nEND\nEXIT\n./ ADD NAME=SVCTABLE\nPROC 0 SVC() +\n       XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n\n/**********************************************************************/\n/*                                                                    */\n/* CVTABEND -> SCVT -> SVCTABLE                                       */\n/*                                                                    */\n/**********************************************************************/\n\nEQ SCVT 10.%+C8? L(184)\nEQ SVCTABLE SCVT+84? L(8) ENTRIES(256)\nIF &STR(&SVC) ^= THEN DO\n INTEGER &SVC UNSIGNED CLIST(S(SVCNO))\n IF &LASTCC ^= 0 THEN DO\n  WRITE Invalid SVC number, &SVC\n  EXIT\n END\n EVAL SVCTABLE+&EVAL(8*&SVCNO)N L(8) HEX CLIST(S(SVCENTRY))\n IF &LASTCC ^= 0 THEN DO\n  WRITE Unable to access storage at SVCTABLE+&EVAL(8*&SVCNO)\n  EXIT\n END\n NOTE 'SVC entry for SVC &SVCNO' ASIS\n NOTE SPACE(1)\n NOTE '&SUBSTR(1:8,&SVCENTRY) &SUBSTR(9:16,&SVCENTRY)' ASIS\nEND\nELSE DO\n LISTSYM (SCVT SVCTABLE)\nEND\n./ ADD NAME=SVC99RB\nPROC 1 SVC99RBPTR XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n\nNOTE 'DYNALLOC info: +\n      MVS/XA SPL: System Macros and Facilities, Vol. 1 - p. 1-235' +\n     SPACE(1) ASIS\n\n/*\n/* Stupid code to get around SYSREF lossage.\n/*\nSET SYSDVAL =\nREADDVAL SVC99RBADDRESS SVC99RB TEXTUNITSPTR TEXTUNITS TEXTUNITPTR\n\nSYSCALL ISET SVC99RBADDRESS  &SVC99RBPTR                   PTR DUMPCB\nSYSCALL ISET SVC99RB         &SVC99RBADDRESS..    L( 20)       DUMPCB\nSYSCALL ISET TEXTUNITSPTR    &SVC99RBADDRESS..+8           PTR\n\nIF &SUBSTR( 1: 2,&SVC99RB) +\n   &SUBSTR( 5: 8,&SVC99RB) +\n   &SUBSTR(25:32,&SVC99RB) +\n   &SUBSTR(33:40,&SVC99RB)+\n   ^= &STR(14 0000 00000000 00000000) THEN DO\n NOTE 'Warning: unusual values in SVC99 request block!' ASIS\nEND\n\nINTEGER X'&SUBSTR(3:4,&SVC99RB)' UNS CLIST(S(VERBCODE))\nSELECT &VERBCODE\n WHEN (1)  SET VERB = &STR(S99VRBAL - DSNAME allocation\n WHEN (2)  SET VERB = &STR(S99VRBUN - deallocation\n WHEN (3)  SET VERB = &STR(S99VRBCC - concatenation\n WHEN (4)  SET VERB = &STR(S99VRBDC - deconcatenation\n WHEN (5)  SET VERB = &STR(S99VRBRI - remove in-use attribute\n WHEN (6)  SET VERB = &STR(S99VRBDN - DDNAME allocation\n WHEN (7)  SET VERB = &STR(S99VRBIN - information retrieval\n OTHERWISE SET VERB = &STR(Unknown verb code &VERBCODE)\nEND\nNOTE 'Verb code: &VERBCODE (&VERB)' ASIS\n\nDO I = 1 TO 2147483647 +\n   UNTIL &OUT = Y\n SYSCALL ISET TEXTUNITPTR &TEXTUNITSPTR..+&EVAL(4*(&I-1))N  PTR\n SET TEXTUNITPTR&I = &NRSTR(&TEXTUNITPTR)\n SET TUCOUNT = &I\n SELECT &SUBSTR(1,&TEXTUNITPTR)\n  WHEN (8|9|A|B|C|D|E|F) SET OUT = Y\n END\nEND\n\nSYSCALL ISET TEXTUNITS &TEXTUNITSPTR.. L(&EVAL(&TUCOUNT*4)) DUMPCB\n\nDO I = 1 TO &TUCOUNT\n SET TEXTUNITPTR = &STR(&SYSNSUB(2,&&TEXTUNITPTR&I))\n IF &TEXTUNITPTR ^= 0 THEN DO\n  SET TEXTUNITPTR = &STR(&TEXTUNITPTR..)\n  SYSCALL FIXUP TEXTUNITPTR\n  SYSCALL DUMP_TEXT_UNIT &TEXTUNITPTR &VERBCODE\n END\nEND\n\nNOTE '*** End of SVC 99 text units. ***' SPACE(1) ASIS\n\nEXIT\n\nDUMP_TEXT_UNIT: PROC 2 TUADDRESS VERBCODE\n\n EVAL &TUADDRESS+0 HEX L(2) CLIST(S(TUCODE))\n IF &LASTCC ^= 0 THEN GOTO ERROR\n EVAL &TUADDRESS+2 UNS L(2) CLIST(S(TUCOUNT))\n IF &LASTCC ^= 0 THEN GOTO ERROR\n SET I = 4\n DO WHILE &TUCOUNT > 0\n  EVAL &TUADDRESS+&I.N+0 UNS L(2) CLIST(S(TULENGTH))\n  IF &LASTCC ^= 0 THEN GOTO ERROR\n  SET I = &I+&TULENGTH+2\n  SET TUCOUNT = &TUCOUNT-1\n END\n\n SYSCALL DESCRIBE_TEXT_UNIT &VERBCODE &TUADDRESS &TUCODE &TUCOUNT\n %DUMPCB TEXT_UNIT &TUADDRESS &EVAL(&I) NOTITLE\n\n RETURN CODE(0)\n\n ERROR:+\n NOTE 'Error accessing text unit data at &TUADDRESS..' ASIS SPACE(1)\n RETURN CODE(12)\n\nEND\n\nISET: PROC 2 CLISTVAR FIELD DUMPCB +\n             LENGTHVALUE(4) PTR POINTER SIGNED UNSIGNED\n SET TITLE = &STR(&CLISTVAR) /* before SYSREFfing\n SYSREF CLISTVAR\n SET CLISTVAR = &STR(<<<no_value>>>)\n IF &SYSINDEX(.,&FIELD) ^= 0 THEN DO\n  SYSCALL FIXUP FIELD\n END\n EVAL &FIELD L(&LENGTHVALUE) &PTR &POINTER &SIGNED &UNSIGNED +\n      CLIST(S(CLISTVAR))\n IF &LASTCC ^= 0 THEN DO\n  NOTE 'Error: &NRSTR(&TITLE) at &NRSTR(&FIELD) not accessible.' ASIS\n  EXIT C(12) Q\n END\n IF &DUMPCB = DUMPCB THEN %DUMPCB &TITLE &FIELD &LENGTHVALUE\n RETURN\nEND\n\nFIXUP: PROC 1 AFIELD\n SYSREF AFIELD\n SET I = &SYSINDEX(.,&AFIELD)\n IF &I = 9 THEN DO\n  SET I = &SYSINDEX(&SUBSTR(1,&AFIELD),89ABCDEF)\n  IF &I ^= 0 THEN DO\n   SET AFIELD = +\n       &SUBSTR(&I,01234567)&SUBSTR(2:&LENGTH(&STR(&AFIELD)),&AFIELD)\n  END\n END\nEND\n\nDESCRIBE_TEXT_UNIT: PROC 4 VERBCODE TUADDRESS TUCODE TUCOUNT\n\n SET TUSTUFF=&STR(Unknown text unit key &TUCODE)\n SELECT &VERBCODE\n  WHEN (1) DO\n   SELECT &TUCODE\n    WHEN (0001) SET TUSTUFF=&STR(DALDDNAM - DD name\n    WHEN (0002) SET TUSTUFF=&STR(DALDSNAM - data set name\n    WHEN (0003) SET TUSTUFF=&STR(DALMEMBR - member or GDG number\n    WHEN (0004) SET TUSTUFF=&STR(DALSTATS - data set status\n    WHEN (0005) SET TUSTUFF=&STR(DALNDISP - normal disposition\n    WHEN (0006) SET TUSTUFF=&STR(DALCDISP - conditional disposition\n    WHEN (0007) SET TUSTUFF=&STR(DALTRK   - space allocation in tracks\n    WHEN (0008) SET TUSTUFF=&STR(+\n    DALCYL   - space allocation in cylinders\n    WHEN (0009) SET TUSTUFF=&STR(DALBLKLN - average data block length\n    WHEN (000A) SET TUSTUFF=&STR(DALPRIME - primary space quantity\n    WHEN (000B) SET TUSTUFF=&STR(DALSECND - secondary space quantity\n    WHEN (000C) SET TUSTUFF=&STR(DALDIR   - number of directory blocks\n    WHEN (000D) SET TUSTUFF=&STR(DALRLSE  - release unused space\n    WHEN (000E) SET TUSTUFF=&STR(+\n    DALSPFRM - specific allocated space format\n    WHEN (000F) SET TUSTUFF=&STR(+\n    DALROUND - allocation in whole cylinders\n    WHEN (0010) SET TUSTUFF=&STR(DALVLSER - volume serial numbers\n    WHEN (0011) SET TUSTUFF=&STR(DALPRIVT - private volume use attribute\n    WHEN (0012) SET TUSTUFF=&STR(DALVLSEQ - volume sequence number\n    WHEN (0013) SET TUSTUFF=&STR(DALVLCNT - volume count\n    WHEN (0014) SET TUSTUFF=&STR(DALVLRDS - volume reference to data set\n    WHEN (0015) SET TUSTUFF=&STR(DALUNIT  - unit specification\n    WHEN (0016) SET TUSTUFF=&STR(DALUNCNT - unit count\n    WHEN (0017) SET TUSTUFF=&STR(DALPARAL - parallel mounting\n    WHEN (0018) SET TUSTUFF=&STR(DALSYSOU - SYSOUT data set class\n    WHEN (0019) SET TUSTUFF=&STR(DALSPGNM - SYSOUT program name\n    WHEN (001A) SET TUSTUFF=&STR(DALSFMNO - SYSOUT form number\n    WHEN (001B) SET TUSTUFF=&STR(DALOUTLM - SYSOUT OUTLIM\n    WHEN (001C) SET TUSTUFF=&STR(DALCLOSE - free data set at close\n    WHEN (001D) SET TUSTUFF=&STR(DALCOPYS - SYSOUT copies count\n    WHEN (001E) SET TUSTUFF=&STR(DALLABEL - type of volume label\n    WHEN (001F) SET TUSTUFF=&STR(DALDSSEQ - relative position for tape\n    WHEN (0020) SET TUSTUFF=&STR(DALPASPR - password protection\n    WHEN (0021) SET TUSTUFF=&STR(DALINOUT - input only or output only\n    WHEN (0022) SET TUSTUFF=&STR(DALEXPDT - expiration date\n    WHEN (0023) SET TUSTUFF=&STR(DALRETPD - retention period\n    WHEN (0024) SET TUSTUFF=&STR(DALDUMMY - dummy data set\n    WHEN (0025) SET TUSTUFF=&STR(DALFCBIM - FCB image\n    WHEN (0026) SET TUSTUFF=&STR(DALFCBAV - FCB verify\n    WHEN (0027) SET TUSTUFF=&STR(DALQNAME - TPROCESS macro, TCAM proc.\n    WHEN (0028) SET TUSTUFF=&STR(DALTERM  - time sharing terminal\n    WHEN (0029) SET TUSTUFF=&STR(DALUCS   - universal character set\n    WHEN (002A) SET TUSTUFF=&STR(DALUFOLD - UCS fold mode\n    WHEN (002B) SET TUSTUFF=&STR(DALUVRFY - UCS verify\n    WHEN (002C) SET TUSTUFF=&STR(DALDCBDS - DCB from data set label\n    WHEN (002D) SET TUSTUFF=&STR(DALDCBDD - DCB from allocated DD name\n    WHEN (0058) SET TUSTUFF=&STR(DALSUSER - SYSOUT remote work station\n    WHEN (0059) SET TUSTUFF=&STR(DALSHOLD - SYSOUT hold queue\n    WHEN (005E) SET TUSTUFF=&STR(DALMSVGP - MSS virtual volume group\n    WHEN (005F) SET TUSTUFF=&STR(DALSSNM  - subsystem data set\n    WHEN (0060) SET TUSTUFF=&STR(DALSSPRM - subsystem-defined parameters\n    WHEN (0061) SET TUSTUFF=&STR(DALPROT  - RACF protection\n    WHEN (0063) SET TUSTUFF=&STR(DALUSRID - SYSOUT route to userid\n    WHEN (0064) SET TUSTUFF=&STR(DALBURST - 3800 burster/trimmer/stacker\n    WHEN (0065) SET TUSTUFF=&STR(+\n    DALCHARS - 3800 character arrangement table\n    WHEN (0066) SET TUSTUFF=&STR(DALCOPYG - 3800 copy groups\n    WHEN (0067) SET TUSTUFF=&STR(DALFFORM - 3800 forms overlay\n    WHEN (0068) SET TUSTUFF=&STR(+\n    DALFCNT  - 3800 forms overlay # of copies\n    WHEN (0069) SET TUSTUFF=&STR(+\n    DALMMOD  - 3800 copy modification module\n    WHEN (006A) SET TUSTUFF=&STR(DALMTRC  - copymod table reference char\n    WHEN (006C) SET TUSTUFF=&STR(DALDEFER - defer volume mounting\n    WHEN (8002) SET TUSTUFF=&STR(+\n    DALOUTPT - refer to OUTPUT JCL statement\n    WHEN (002E) SET TUSTUFF=&STR(DALBFALN - buffer alignment\n    WHEN (002F) SET TUSTUFF=&STR(DALBFTEK - buffering technique\n    WHEN (0030) SET TUSTUFF=&STR(DALBLKSZ - blocksize\n    WHEN (0031) SET TUSTUFF=&STR(DALBUFIN - receiving buffer count\n    WHEN (0032) SET TUSTUFF=&STR(DALBUFL  - buffer length\n    WHEN (0033) SET TUSTUFF=&STR(DALBUFMX - buffer count per line\n    WHEN (0034) SET TUSTUFF=&STR(DALBUFNO - buffer count per DCB\n    WHEN (0035) SET TUSTUFF=&STR(DALBUFOF - buffer offset\n    WHEN (0036) SET TUSTUFF=&STR(DALBUFOU - sending buffer count\n    WHEN (0037) SET TUSTUFF=&STR(DALBUFRQ - buffer count per GET macro\n    WHEN (0038) SET TUSTUFF=&STR(DALBUFSZ - line group buffer size\n    WHEN (0039) SET TUSTUFF=&STR(DALCODE  - paper tape code\n    WHEN (003A) SET TUSTUFF=&STR(+\n    DALCPRI  - relative sending and receiving priority\n    WHEN (003B) SET TUSTUFF=&STR(DALDEN   - magnetic tape density\n    WHEN (003C) SET TUSTUFF=&STR(DALDSORG - data set organization\n    WHEN (003D) SET TUSTUFF=&STR(DALEROPT - I/O error options\n    WHEN (003E) SET TUSTUFF=&STR(DALGNCP  - GAM-I/O count per WAIT macro\n    WHEN (003F) SET TUSTUFF=&STR(+\n    DALINTVL - line polling interval per group\n    WHEN (0040) SET TUSTUFF=&STR(DALKYLEN - key length\n    WHEN (0041) SET TUSTUFF=&STR(DALLIMCT - search limit\n    WHEN (0042) SET TUSTUFF=&STR(DALLRECL - logical record length\n    WHEN (0043) SET TUSTUFF=&STR(DALMODE  - card punch reader mode\n    WHEN (0044) SET TUSTUFF=&STR(DALNCP   - number of channel programs\n    WHEN (0045) SET TUSTUFF=&STR(DALOPTCD - option code\n    WHEN (0046) SET TUSTUFF=&STR(DALPCIR  - receiving PCI relationship\n    WHEN (0047) SET TUSTUFF=&STR(DALPCIS  - sending PCI relationship\n    WHEN (0048) SET TUSTUFF=&STR(DALPRTSP - printer line spacing\n    WHEN (0049) SET TUSTUFF=&STR(DALRECFM - record format\n    WHEN (004A) SET TUSTUFF=&STR(+\n    DALRSRVF - first buffer's reserve byte count\n    WHEN (004B) SET TUSTUFF=&STR(+\n    DALRSRVS - secondary buffer's reserve byte count\n    WHEN (004C) SET TUSTUFF=&STR(DALSOWA  - TCAM input work area size\n    WHEN (004D) SET TUSTUFF=&STR(DALSTACK - card punch stacker bin\n    WHEN (004E) SET TUSTUFF=&STR(DALTHRSH - message queue threshold\n    WHEN (004F) SET TUSTUFF=&STR(+\n    DALTRTCH - 7-track tape recording technique\n    WHEN (0051) SET TUSTUFF=&STR(DALIPLTX - TCAM NCP name\n    WHEN (0054) SET TUSTUFF=&STR(DALDIAGN - OPEN/CLOSE/EOV trace option\n    WHEN (005A) SET TUSTUFF=&STR(DALFUNC  - card punch/reader type\n    WHEN (005B) SET TUSTUFF=&STR(DALFRID  - input to 3886 char. reader\n    WHEN (0050) SET TUSTUFF=&STR(+\n    DALPASSW - password for protected data set\n    WHEN (0052) SET TUSTUFF=&STR(DALPERMA - permanently allocated\n    WHEN (0053) SET TUSTUFF=&STR(DALCNVRT - convertible\n    WHEN (0055) SET TUSTUFF=&STR(DALRTDDN - return ddname\n    WHEN (0056) SET TUSTUFF=&STR(DALRTDSN - return data set name\n    WHEN (0057) SET TUSTUFF=&STR(DALRTORG - return DSORG\n    WHEN (005C) SET TUSTUFF=&STR(DALSSREQ - subsystem data set\n    WHEN (005D) SET TUSTUFF=&STR(DALRTVOL - return volume serial\n    WHEN (0062) SET TUSTUFF=&STR(DALSSATT - subsystem SYSIN data set\n   END\n  END\n  WHEN (2) DO\n   SELECT &TUCODE\n    WHEN (0001) SET TUSTUFF=&STR(DUNDDNAM - DD name\n    WHEN (0002) SET TUSTUFF=&STR(DUNDSNAM - data set name\n    WHEN (0003) SET TUSTUFF=&STR(DUNMEMBR - PDS member\n    WHEN (0005) SET TUSTUFF=&STR(DUNOVDSP - overriding disposition\n    WHEN (0007) SET TUSTUFF=&STR(+\n    DUNUNALC - free even if permanently allocated\n    WHEN (0008) SET TUSTUFF=&STR(+\n    DUNREMOV - remove in-use attribute even if perm\n    WHEN (000A) SET TUSTUFF=&STR(DUNOVSNH - NOHOLD overrides for SYSOUT\n    WHEN (0018) SET TUSTUFF=&STR(DUNOVCLS - overriding SYSOUT class\n    WHEN (0058) SET TUSTUFF=&STR(+\n    DUNOVSUS - overriding remote workstation\n    WHEN (0059) SET TUSTUFF=&STR(DUNOVSHQ - HOLD overrides for SYSOUT\n   END\n  END\n  WHEN (3) DO\n   SELECT &TUCODE\n    WHEN (0001) SET TUSTUFF=&STR(DCCDDNAM - DD name to be concatenated\n    WHEN (0004) SET TUSTUFF=&STR(DCCPERMC - permanently concatenated\n   END\n  END\n  WHEN (4) DO\n   SELECT &TUCODE\n    WHEN (0001) SET TUSTUFF=&STR(DCDDDNAM - DD name to be deconcatenated\n   END\n  END\n  WHEN (5) DO\n   SELECT &TUCODE\n    WHEN (0001) SET TUSTUFF=&STR(DRITCBAD - specify TCB address\n    WHEN (0002) SET TUSTUFF=&STR(DRICURNT - current and higher tasks\n   END\n  END\n  WHEN (6) DO\n   SELECT &TUCODE\n    WHEN (0001) SET TUSTUFF=&STR(DDNDDNAM - DD name\n    WHEN (0002) SET TUSTUFF=&STR(DDNRTDUM - return dummy indication\n   END\n  END\n  WHEN (7) DO\n   SELECT &TUCODE\n    WHEN (0001) SET TUSTUFF=&STR(DINDDNAM - DD name\n    WHEN (0002) SET TUSTUFF=&STR(DINDSNAM - data set name\n    WHEN (0004) SET TUSTUFF=&STR(DINRTDDN - return DD name\n    WHEN (0005) SET TUSTUFF=&STR(DINRTDSN - return data set name\n    WHEN (0006) SET TUSTUFF=&STR(DINRTMEM - return PDS member name\n    WHEN (0007) SET TUSTUFF=&STR(DINRTSTA - return data set status\n    WHEN (0008) SET TUSTUFF=&STR(DINRTNDP - return normal disposition\n    WHEN (0009) SET TUSTUFF=&STR(DINRTCDP - return cond. disposition\n    WHEN (000A) SET TUSTUFF=&STR(DINRTORG - return DSORG\n    WHEN (000B) SET TUSTUFF=&STR(+\n    DINRTLIM - return # of resources to free\n    WHEN (000C) SET TUSTUFF=&STR(+\n    DINRTATT - return special attribute indications\n    WHEN (000D) SET TUSTUFF=&STR(+\n    DINRTLST - return last relative entry indication\n    WHEN (000E) SET TUSTUFF=&STR(DINRTTYP - return type (terminal/dummy)\n    WHEN (000F) SET TUSTUFF=&STR(DINRELNO - relative request number\n   END\n  END\n END\n NOTE 'Text unit at &TUADDRESS - &NRSTR(&TUSTUFF)' SPACE(1) ASIS\nEND\n\n./ ADD NAME=TESTEVAL\nPROC 0 +\n       XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nSET EVALDEFCONFIRM          =  &STR(*** not set by IPCS ***)\nSET EVALDEFDISPLAY          =  &STR(*** not set by IPCS ***)\nSET EVALDEFDATASET          =  &STR(*** not set by IPCS ***)\nSET EVALDEFFLAG             =  &STR(*** not set by IPCS ***)\nSET EVALDEFLENGTH           =  &STR(*** not set by IPCS ***)\nSET EVALDEFPRINT            =  &STR(*** not set by IPCS ***)\nSET EVALDEFPROBLEM          =  &STR(*** not set by IPCS ***)\nSET EVALDEFQUALIFICATION    =  &STR(*** not set by IPCS ***)\nSET EVALDEFTERMINAL         =  &STR(*** not set by IPCS ***)\nSET EVALDEFTEST             =  &STR(*** not set by IPCS ***)\nSET EVALDEFVERIFY           =  &STR(*** not set by IPCS ***)\nSET EVALDUMPBLOCKS          =  &STR(*** not set by IPCS ***)\nSET EVALDUMPBYTES           =  &STR(*** not set by IPCS ***)\nSET EVALDUMPDATASET         =  &STR(*** not set by IPCS ***)\nSET EVALDUMPQUALIFICATION   =  &STR(*** not set by IPCS ***)\nSET EVALMAPADDRESS          =  &STR(*** not set by IPCS ***)\nSET EVALMAPANALYSIS         =  &STR(*** not set by IPCS ***)\nSET EVALMAPDATATYPE         =  &STR(*** not set by IPCS ***)\nSET EVALMAPDIMENSION        =  &STR(*** not set by IPCS ***)\nSET EVALMAPENTRY            =  &STR(*** not set by IPCS ***)\nSET EVALMAPFLAG             =  &STR(*** not set by IPCS ***)\nSET EVALMAPLENGTH           =  &STR(*** not set by IPCS ***)\nSET EVALMAPPOSITION         =  &STR(*** not set by IPCS ***)\nSET EVALMAPQUALIFICATION    =  &STR(*** not set by IPCS ***)\nSET EVALSYMADDRESS          =  &STR(*** not set by IPCS ***)\nSET EVALSYMDATATYPE         =  &STR(*** not set by IPCS ***)\nSET EVALSYMDIMENSION        =  &STR(*** not set by IPCS ***)\nSET EVALSYMDROP             =  &STR(*** not set by IPCS ***)\nSET EVALSYMENTRY            =  &STR(*** not set by IPCS ***)\nSET EVALSYMLENGTH           =  &STR(*** not set by IPCS ***)\nSET EVALSYMPOSITION         =  &STR(*** not set by IPCS ***)\nSET EVALSYMQUALIFICATION    =  &STR(*** not set by IPCS ***)\nSET EVALSYMREMARK           =  &STR(*** not set by IPCS ***)\nSET EVALSYMSYMBOL           =  &STR(*** not set by IPCS ***)\nSET EVALUATEPROTECTION      =  &STR(*** not set by IPCS ***)\nSET EVALUATESTORAGE         =  &STR(*** not set by IPCS ***)\nCONTROL NOFLUSH\nERROR DO\n SET CC = &LASTCC\n RETURN\nEND\nWRITE\nWRITE This clist demonstrates the use of the IPCS subcommands\nWRITE that place data into CLISTs or ISPF dialog variables.\nWRITE\nWRITE First, we will demonstrate how \"EVALDEF\" works.\nWRITE\nSYSCALL ASKDORH EVALDEFTYPE\nWRITE\nSET CC = 0\nEVALDEF CLIST(&EVALDEFTYPE +\n              CONFIRM      (EVALDEFCONFIRM      ) +\n              DISPLAY      (EVALDEFDISPLAY      ) +\n              DATASET      (EVALDEFDATASET      ) +\n              FLAG         (EVALDEFFLAG         ) +\n              LENGTH       (EVALDEFLENGTH       ) +\n              PRINT        (EVALDEFPRINT        ) +\n              PROBLEM      (EVALDEFPROBLEM      ) +\n              QUALIFICATION(EVALDEFQUALIFICATION) +\n              TERMINAL     (EVALDEFTERMINAL     ) +\n              TEST         (EVALDEFTEST         ) +\n              VERIFY       (EVALDEFVERIFY       ) +\n             )\nIF &CC ^= 0 THEN WRITE EVALDEF returned code &CC\nWRITE CONFIRM       = \"&NRSTR(&EVALDEFCONFIRM)\"\nWRITE DISPLAY       = \"&NRSTR(&EVALDEFDISPLAY)\"\nWRITE DATASET       = \"&NRSTR(&EVALDEFDATASET)\"\nWRITE FLAG          = \"&NRSTR(&EVALDEFFLAG)\"\nWRITE LENGTH        = \"&NRSTR(&EVALDEFLENGTH)\"\nWRITE PRINT         = \"&NRSTR(&EVALDEFPRINT)\"\nWRITE PROBLEM       = \"&NRSTR(&EVALDEFPROBLEM)\"\nWRITE QUALIFICATION = \"&NRSTR(&EVALDEFQUALIFICATION)\"\nWRITE TERMINAL      = \"&NRSTR(&EVALDEFTERMINAL)\"\nWRITE TEST          = \"&NRSTR(&EVALDEFTEST)\"\nWRITE VERIFY        = \"&NRSTR(&EVALDEFVERIFY)\"\nWRITE\nWRITE Next, we will demonstrate how \"EVALDUMP\" works.\nWRITE\nIF &NRSTR(&EVALDEFDATASET) = NODSNAME THEN DO\n WRITE We cannot demonstrate EVALDUMP because there is no current +\n       dump data set.\nEND\nELSE DO\n SYSCALL ASKDORH EVALDUMPTYPE\n WRITE\n SET CC = 0\n EVALDUMP &EVALDEFDATASET +\n          CLIST(&EVALDUMPTYPE +\n                BLOCKS       (EVALDUMPBLOCKS       ) +\n                BYTES        (EVALDUMPBYTES        ) +\n                DATASET      (EVALDUMPDATASET      ) +\n                QUALIFICATION(EVALDUMPQUALIFICATION) +\n               )\n IF &CC ^= 0 THEN WRITE EVALDUMP returned code &CC\n WRITE BLOCKS        = \"&NRSTR(&EVALDUMPBLOCKS)\"\n WRITE BYTES         = \"&NRSTR(&EVALDUMPBYTES)\"\n WRITE DATASET       = \"&NRSTR(&EVALDUMPDATASET)\"\n WRITE QUALIFICATION = \"&NRSTR(&EVALDUMPQUALIFICATION)\"\nEND\nWRITE\nWRITE Next, we will demonstrate how \"EVALMAP\" works.\nWRITE\nSYSCALL ASKDORH EVALMAPTYPE\nWRITE\nSET CC = 0\nEVALMAP 0. +\n        CLIST(&EVALMAPTYPE +\n              ADDRESS      (EVALMAPADDRESS      ) +\n              ANALYSIS     (EVALMAPANALYSIS     ) +\n              DATATYPE     (EVALMAPDATATYPE     ) +\n              DIMENSION    (EVALMAPDIMENSION    ) +\n              ENTRY        (EVALMAPENTRY        ) +\n              FLAG         (EVALMAPFLAG         ) +\n              LENGTH       (EVALMAPLENGTH       ) +\n              POSITION     (EVALMAPPOSITION     ) +\n              QUALIFICATION(EVALMAPQUALIFICATION) +\n             )\nIF &CC ^= 0 THEN WRITE EVALMAP returned code &CC\nWRITE ADDRESS       = \"&NRSTR(&EVALMAPADDRESS)\"\nWRITE ANALYSIS      = \"&NRSTR(&EVALMAPANALYSIS)\"\nWRITE DATATYPE      = \"&NRSTR(&EVALMAPDATATYPE)\"\nWRITE DIMENSION     = \"&NRSTR(&EVALMAPDIMENSION)\"\nWRITE ENTRY         = \"&NRSTR(&EVALMAPENTRY)\"\nWRITE FLAG          = \"&NRSTR(&EVALMAPFLAG)\"\nWRITE LENGTH        = \"&NRSTR(&EVALMAPLENGTH)\"\nWRITE POSITION      = \"&NRSTR(&EVALMAPPOSITION)\"\nWRITE QUALIFICATION = \"&NRSTR(&EVALMAPQUALIFICATION)\"\nWRITE\nWRITE Next, we will demonstrate how \"EVALSYM\" works.\nWRITE\nSYSCALL ASKDORH EVALSYMTYPE\nWRITE\nASKBOL:+\nWRITENR Enter symbol name or ? ===>\nCONTROL CAPS\nREAD EVALSYMBOL\nCONTROL NOCAPS\nIF &NRSTR(&EVALSYMBOL) = THEN GOTO ASKBOL\nIF &NRSTR(&EVALSYMBOL) = ? THEN DO\n WRITE A list of symbols follows:\n WRITE\n LISTSYM\n GOTO ASKBOL\nEND\nWRITE\nSET CC = 0\nEVALSYM &EVALSYMBOL +\n        CLIST(&EVALSYMTYPE UNQUOTE +\n              ADDRESS      (EVALSYMADDRESS      ) +\n              DATATYPE     (EVALSYMDATATYPE     ) +\n              DIMENSION    (EVALSYMDIMENSION    ) +\n              DROP         (EVALSYMDROP         ) +\n              ENTRY        (EVALSYMENTRY        ) +\n              LENGTH       (EVALSYMLENGTH       ) +\n              POSITION     (EVALSYMPOSITION     ) +\n              QUALIFICATION(EVALSYMQUALIFICATION) +\n              REMARK       (EVALSYMREMARK       ) +\n              SYMBOL       (EVALSYMSYMBOL       ) +\n             )\nIF &CC ^= 0 THEN WRITE EVALSYM returned code &CC\nWRITE ADDRESS       = \"&NRSTR(&EVALSYMADDRESS)\"\nWRITE DATATYPE      = \"&NRSTR(&EVALSYMDATATYPE)\"\nWRITE DIMENSION     = \"&NRSTR(&EVALSYMDIMENSION)\"\nWRITE DROP          = \"&NRSTR(&EVALSYMDROP)\"\nWRITE ENTRY         = \"&NRSTR(&EVALSYMENTRY)\"\nWRITE LENGTH        = \"&NRSTR(&EVALSYMLENGTH)\"\nWRITE POSITION      = \"&NRSTR(&EVALSYMPOSITION)\"\nWRITE QUALIFICATION = \"&NRSTR(&EVALSYMQUALIFICATION)\"\nWRITE REMARK        = \"&NRSTR(&EVALSYMREMARK)\"\nWRITE SYMBOL        = \"&NRSTR(&EVALSYMSYMBOL)\"\nWRITE\nWRITE Next, we will demonstrate how \"EVALUATE\" works.\nWRITE\nWRITE\nSET CC = 0\nLISTSYM X\nWRITE\nEVALUATE X +\n        CLIST(UNQUOTE +\n              PROTECTION   (EVALUATEPROTECTION  ) +\n              STORAGE      (EVALUATESTORAGE     ) +\n             )\nIF &CC ^= 0 THEN WRITE EVALUATE returned code &CC\nWRITE PROTECTION    = \"&NRSTR(&EVALUATEPROTECTION)\"\nWRITE STORAGE       = \"&NRSTR(&EVALUATESTORAGE)\"\nWRITE\nWRITE\nWRITE TESTEVAL ended.\nWRITE\n\nASKDORH: PROC 1 VAR\n SYSREF VAR\n DO UNTIL &OK = Y\n  SET OK = Y\n  WRITENR Enter \"D(ecimal)\" or \"H(exadecimal)\" ===>\n  READ DH\n  SELECT &SYSCAPS(&SUBSTR(1,&NRSTR(&DH )))\n   WHEN (D)     SET VAR = DECIMAL\n   WHEN (H | X) SET VAR = HEXADECIMAL\n   OTHERWISE SET OK = N\n  END\n END\nEND ASKDORH\n./ ADD NAME=TSOCB\nPROC 0 REXX TCB(21C.?) SHOW XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOFLUSH NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n WRITE *** You must be in IPCS to use this CLIST. ***\n EXIT C(16) Q\nEND\nSET ECT_P = N\nIF &SHOW = SHOW THEN DO\n LISTSYM (ECT PSCB UPT RLGB)\n LISTSYM (LWA TSVT)\n EXIT\nEND\nSET SYSDVAL =\nREADDVAL TSVT LWA PSCB\nEVALDEF CLIST(DATASET(DSORACT))\nIF &STR(&DSORACT) = ACTIVE THEN DO\n EQ CVT 10.%\nEND\nEQ TSVT CVT+9C?\nIF &LASTCC=12 THEN DO\n NOTE 'The TSVT is not available +\n      (possibly because the CVT is not available).' ASIS\n NOTE SPACE(1)\nEND\nELSE SET TSVT = TSVT\nEQ LWA 224.?+6C?+14? L(128)\nIF &LASTCC=12 THEN DO\n NOTE 'The LWA is not available +\n      (possibly because the ASCB or ASXB is not available).' ASIS\n NOTE SPACE(1)\nEND\nELSE SET LWA = LWA\nEVAL &TCB+B4?+15C?+108 L(4) PTR CLIST(S(PSCBADDRESS))\n/*AL &TCB+B4?+108 L(4) PTR CLIST(S(PSCBADDRESS))\nIF &LASTCC=12 THEN DO\n NOTE 'The PSCB is not available +\n      (possibly because the TCB or JSCB is not available).' ASIS\n NOTE SPACE(1)\nEND\nELSE IF &PSCBADDRESS = 0 THEN DO\n NOTE 'No PSCB - there is no TSO environment.' ASIS\n NOTE SPACE(1)\nEND\nELSE DO\n SET PSCB = PSCB\n EQ PSCB &PSCBADDRESS.. L(64)\n EQ UPT  PSCB+34? L(24)\n EQ RLGB PSCB+30? L(260)\n IF &LWA = LWA THEN DO\n  EVAL LWA+20 L(4) CLIST(S(LWAECTPTR))\n  EVAL RLGB+100 L(4) CLIST(S(RLGBECTPTR))\n  IF &LWAECTPTR ^= &RLGBECTPTR THEN DO\n   NOTE 'Warning: ECT addresses in LWA and RLGB do not match.' ASIS\n   IF &LWAECTPTR = 00000000 && &RLGBECTPTR ^= 00000000 THEN DO\n    NOTE 'Using ECT pointer from RLGB (&RLGBECTPTR), +\n          not LWA (&LWAECTPTR).' ASIS\n    EQ ECT  RLGB+100? L(64)\n    SET ECT_P = Y\n   END\n   ELSE +\n   IF &LWAECTPTR ^= 00000000 && &RLGBECTPTR = 00000000 THEN DO\n    NOTE 'Using ECT pointer from LWA (&LWAECTPTR), +\n         not RLGB (&RLGBECTPTR).' ASIS\n    EQ ECT  LWA+20? L(64)\n    SET ECT_P = Y\n   END\n   ELSE DO\n    NOTE 'Using ECT pointer from LWA (&LWAECTPTR), +\n         not RLGB (&RLGBECTPTR).' ASIS\n    EQ ECT  LWA+20? L(64)\n    SET ECT_P = Y\n   END\n  END\n  ELSE DO\n   EQ ECT  RLGB+100? L(64)\n   SET ECT_P = Y\n  END\n END\n LISTSYM (ECT PSCB UPT RLGB)\n STACK    ECT  REM('ECT'  )\n STACK    PSCB REM('PSCB' )\n STACK    UPT  REM('UPT'  )\n STACK    RLGB REM('RLGB' )\nEND\nLISTSYM (LWA TSVT)\nSTACK    LWA  REM('LWA'  )\nSTACK    TSVT REM('TSVT' )\n\nIF &ECT_P = Y THEN +\n SYSCALL GETREXX &REXX &XTRACE\nEXIT\n\nGETREXX: PROC 0 REXX XTRACE\nEVAL ECT+30 L(4) HEX CLIST(S(ENVBLOCK))\nEVAL ECT+34 L(4) HEX CLIST(S(ECTEXT))\nIF &STR(&ENVBLOCK&ECTEXT) = &STR(0000000000000000) THEN DO\n NOTE SPACE(1)\n NOTE 'REXX is not active in this environment.' ASIS\n NOTE SPACE(1)\n RETURN\nEND\nIF &REXX = REXX THEN DO\n %REXXCB ECT(ECT) &XTRACE\nEND\nELSE DO\n NOTE SPACE(1)\n NOTE 'For REXX control blocks, execute the REXXCB clist,' ASIS\n NOTE '    or execute TSOCB with the REXX operand.       ' ASIS\n NOTE SPACE(1)\nEND\nRETURN\nEND GETREXX\n./ ADD NAME=TSODATA\nPROC 0 +\n       ALL CURRENT ERROR TCBERROR ANOMALY +\n       ASIDLIST() +\n       JOBNAME() +\n       JOBLIST() +\n       ECT() +\n       LWA STACK +\n       SYMBOLS() +\n       XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\n\n  FROB: PROC 1 IT\n  SET NAME_OF_IT = &STR(&IT)\n  SYSREF IT\n  IF &STR(&IT) ^= THEN SET IT = &NAME_OF_IT(&IT)\n  ELSE SET IT =\n  RETURN\n  END /* FROB */\n\n  UNDOT: PROC 1 IT\n  SET NAME_OF_IT = &STR(&IT)\n  SYSREF IT\n  SET L = &LENGTH(&NRSTR(&IT))\n  IF &L < 2 THEN RETURN\n  IF &SUBSTR(&L,&NRSTR(&IT)) = . THEN +\n   SET IT = &SUBSTR(1:&L-1,&NRSTR(&IT))\n  RETURN\n  END /* UNDOT */\n\nSYSCALL UNDOT ECT\nSYSCALL UNDOT SYMBOLS\n\nSYSCALL FROB ASIDLIST\nSYSCALL FROB JOBNAME\nSYSCALL FROB JOBLIST\nSYSCALL FROB ECT\nSYSCALL FROB SYMBOLS\n\nCONTROL LIST\n\nVERBEXIT TSODATA +\n         '&ALL &CURRENT &ERROR &TCBERROR &ANOMALY +\n          &ASIDLIST &JOBNAME &JOBLIST &ECT &LWA &STACK &SYMBOLS'\n\n./ ADD NAME=VSM\nPROC 0 DUMP NODUMP XTRACE\nIF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST\nCONTROL NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n  WRITE *** You must be in IPCS to use this CLIST. ***\n  EXIT C(16) Q\nEND\nEVAL 224. PTR CLIST(S(ASCB)\nIF &LASTCC ^= 0 THEN DO\n NOTE 'Error accessing ASCB at 224.%' ASIS\n EXIT C(12) Q\nEND\nEVAL &ASCB..+30 PTR CLIST(S(ASCBLDA))\nIF &LASTCC ^= 0 THEN DO\n NOTE 'Error accessing ASCBLDA at &ASCB..+30' ASIS\n EXIT C(12) Q\nEND\nEQ LDA &ASCBLDA.. L(264)\n\nIF &DUMP&NODUMP = DUMP THEN %DUMPCB LDA &ASCBLDA.. 264\n\n/**********************************************************************/\n/*                                                                    */\n/* Format the LDA (VSM local data area).  This contains control info  */\n/* about address-space-related virtual storage and VSM control block  */\n/* pointers.                                                          */\n/*                                                                    */\n/**********************************************************************/\n\nCONTROL NOFLUSH\nERROR DO\n ERROR OFF\n NOTE 'Error accessing LDA storage at &ASCBLDA.. somewhere' ASIS\n EXIT C(12) Q\nEND\nEVAL &ASCBLDA..+04 PTR CLIST(S(LDASQAT))  /* Address of the LSQA SQAT */\nEQ SQAT &LDASQAT.. L(12)\nIF &DUMP&NODUMP = DUMP THEN %DUMPCB SQAT &LDASQAT.. 12\n\n/**********************************************************************/\n/*                                                                    */\n/* Format the SQAT (size queue anchor table).                         */\n/*                                                                    */\n/**********************************************************************/\n\nEVAL SQAT+4 SIG CLIST(S(SQATCNT)) /* Number of entries in the table */\nEVAL SQAT+8 SIG CLIST(S(SQATMAXS)) /* Maximum size in the table */\nNOTE '&EVAL(&SQATCNT) entries in SQAT (max size &EVAL(&SQATMAXS))' ASIS\n\n\n/**********************************************************************/\n/*                                                                    */\n/* Format each SQAT entry.                                            */\n/*                                                                    */\n/**********************************************************************/\n\nSET I = 0\nDO WHILE &I LT &SQATCNT\n NOTE         'Entry &EVAL(&I+1) of SQAT' ASIS\n SET BS = &STR(                )\n SET OFFSET = 12+(8*&I)\n EVAL SQAT+&OFFSET.N SIG CLIST(S(SQATSZ)) /* Lower bound of free space\n NOTE '&BS.Lower bound of free space size:  &SQATSZ' ASIS\n EVAL SQAT+&EVAL(&OFFSET+4)N PTR CLIST(S(SQATDFE))\n  /* Address of the first DFE on the size queue GE size of lower bound\n NOTE '&BS.DFE address:  &SQATDFE' ASIS\n SET I = &I + 1\nEND\nEVAL &ASCBLDA..+08 PTR CLIST(S(LDAAQAT))  /* Address of the LSQA AQAT */\nEQ AQAT &LDAAQAT.. L(722)\nIF &DUMP&NODUMP = DUMP THEN %DUMPCB AQAT &LDAAQAT.. 722\n\n/**********************************************************************/\n/*                                                                    */\n/* Format the AQAT (address queue anchor table).                      */\n/*                                                                    */\n/**********************************************************************/\n\n./ ADD NAME=VSSA\nPROC 0 TCB() XTRACE\nIF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST\nCONTROL NOFLUSH NOCAPS\nIF &STR(&SYSPCMD) ^= IPCS THEN DO\n WRITE *** You must be in IPCS to use this CLIST. ***\n EXIT C(16) Q\nEND\nIF &STR(&TCB) = THEN DO\n SET TCB = 0\n EVAL 21D. L(3) HEX CLIST(S(TCB))\n IF &TCB = 0 THEN DO\n  EVAL 219. L(3) HEX CLIST(S(TCB))\n  IF &TCB = 0 THEN DO\n   EVAL 224.?+6C?+5 L(3) HEX CLIST(S(TCB))\n   IF &TCB = 0 THEN DO\n    NOTE 'TCB unavailable' ASIS\n    EXIT C(12) Q\n   END\n  END\n END\nEND\nELSE DO\n TCBEXIT YITADDR &NRSTR(&TCB) POSITION(+0)\n IF &LASTCC ^= 0 THEN DO\n  NOTE 'Invalid TCB address: &NRSTR(&TCB)' ASIS\n  EXIT C(12) Q\n END\n SET TCB = &STR(&YITHEX)\nEND\nEVAL &TCB..+138?+14 PTR CLIST(S(VSSAPTR))\nIF &LASTCC = 12 THEN GOTO FAIL\nIF &VSSAPTR = 0 THEN GOTO FAIL\nTCBEXIT IEAVSSA1 &TCB\nEXIT\nFAIL: NOTE 'No vector stuff for TCB at &TCB..' ASIS\nEXIT\n./ ADD NAME=WHERE\nPROC 1 ADDRESS STACK ID(WHERE) ASID() XTRACE\n/***********************************************************************\n/*                                                                     *\n/* Author: S. Bacher                                                   *\n/*                                                                     *\n/* This CLIST displays the module and relative location within module  *\n/* of an address.  The address is the single positional parameter and  *\n/* must consist of a single hexadecimal value (optionally terminated   *\n/* with a period).                                                     *\n/*                                                                     *\n/* The following control blocks are searched for the address:          *\n/*                                                                     *\n/*   Job pack area for the job step TCB of the current ASID (CDE's)    *\n/*   Pageable link pack area (LPDE's)                                  *\n/*   Modified link pack area (CDE's)                                   *\n/*   Nucleus map (NUCMAP)                                              *\n/*                                                                     *\n/***********************************************************************\nIF &XTRACE=XTRACE THEN CONTROL CONLIST SYMLIST LIST MSG\nIF &STR(&SYSPCMD) = IPCS THEN DO\n SET L = &LENGTH(&STR(&ADDRESS))\n IF (&L = 9 && &SUBSTR(&L,&ADDRESS) = .) | +\n    (&L = 8 && &SUBSTR(1,&ADDRESS) > 7) THEN DO\n  SET I = 0\n  SET A = &SUBSTR(1,&ADDRESS)\n  DO WHILE &I LT 8\n   SET I = &I + 1\n   IF &A = &SUBSTR(&I,89ABCDEF) THEN DO\n    SET ADDRESS = &SUBSTR(&I,01234567)&SUBSTR(2:&L,&ADDRESS)\n    GOTO DOIT\n   END\n  END\n END\n DOIT:+\n IF &STACK NE THEN STACK &ADDRESS. REMARK('&ID')\n IF &STR(&ASID) ^= THEN SET XASID = &STR(ASID(&ASID))\n ELSE SET XASID =\n TCBEXIT XITWHR &ADDRESS POS(0) &XASID\nEND\nELSE DO\n XCMD \"XIPWHR &ADDRESS\" LIB('SYSPGMR.CMD.LOAD') NOF\nEND\n./ ENDUP\n?!\n//PANEL    EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='PANEL'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=DQETBL\n)Attr\n   ^ type(input ) intens(high) caps(on ) just(asis )\n   ! type(output) intens(low ) caps(off) just(asis )\n   @ type(output) intens(high) caps(off) just(right)\n)Body  Expand(\\\\)\n%-\\-\\- IPCS - DQE Table for &THING at &ADDRESS &EXTRA              -\\-\\-\n%Subcommand ===>_ZCMD                              \\ \\%Scroll ===>_AMT +\n\n%Primary command: +Any IPCS subcommand.\n%Line commands:   %S+(select FQE's)\n\n%  Type    DQE addr   First FQE  Last FQE   Area     Size\n+\n)Model\n^Z+!Z     !Z         !Z         !Z         !Z       !Z\n)Init\n .ZVARS='(DQESEL DQETYPE DQEADDR DQEFFQE DQELFQE DQEAREA DQESIZE)'\n &amt = CSR\n &ZTDMARK = '........................................+\n             .......................................'\n)Reinit\n)Proc\n &TBLCMD = &Z\n VER(&DQESEL,LIST,S,X)\n IF (&DQESEL = S)\n  &TBLCMD = '%IPVSFQE'\n IF (&DQESEL = X)\n  &TBLCMD = '%IPVSFQE XTRACE'\n)End\n./ ADD NAME=FQETBL\n)Attr\n   ^ type(input ) intens(high) caps(on ) just(asis )\n   ! type(output) intens(low ) caps(off) just(asis )\n   @ type(output) intens(high) caps(off) just(right)\n)Body  Expand(\\\\)\n%-\\-\\- IPCS - FQE Table for DQE at &ADDRESS -\\-\\-\n%Subcommand ===>_ZCMD                              \\ \\%Scroll ===>_AMT +\n\n%Primary command: +Any IPCS subcommand.\n%Line commands:   %L+(list) %D+(dump)\n\n%          FQE addr     From     To        Size\n+\n)Model\n^Z+       !Z           !Z       !Z        !Z\n)Init\n .ZVARS='(FQESEL FQEADDR FQEAREA EFQEAREA FQESIZE)'\n &amt = CSR\n &ZTDMARK = '........................................+\n             .......................................'\n)Reinit\n)Proc\n &TBLCMD = &Z\n VER(&FQESEL,LIST,L,D)\n IF (&FQESEL = L)\n  &TBLCMD = 'LIST &FQEAREA. L(X''&FQESIZE'')'\n IF (&FQESEL = D)\n  &TBLCMD = '%DUMPCB AREA &FQEAREA. X''&FQESIZE'''\n)End\n./ ADD NAME=SPQETBL\n)Attr\n   ^ type(input ) intens(high) caps(on ) just(asis )\n   ! type(output) intens(low ) caps(off) just(asis )\n   @ type(output) intens(high) caps(off) just(right)\n)Body  Expand(\\\\)\n%-\\-\\- IPCS - SPQE Table for TCB at &ADDRESS -\\-\\-\n%Subcommand ===>_ZCMD                              \\ \\%Scroll ===>_AMT +\n\n%Primary command: +Any IPCS subcommand.\n%Line commands:   %S+(select DQE's)\n\n%  Qtype   SPQE addr  SPQA addr  Owning TCB Subpool  Key  Shared\n+\n)Model\n^Z+!Z     !Z         !Z         !Z         @Z  +   @Z  +  !Z\n)Init\n .ZVARS='(SPQESEL SPQEQTYP SPQEADDR SPQESPQA SPQETCB SPQEID SPQEKEY SPQESHR)'\n &amt = CSR\n &ZTDMARK = '........................................+\n             .......................................'\n)Reinit\n)Proc\n &TBLCMD = &Z\n VER(&SPQESEL,LIST,S,X)\n IF (&SPQESEL = S,X)\n  &TBLCMD = '%IPVSDQE THING(SPQE) POINTER(SPQESPQA) ADDRESS(SPQEADDR) +\n                      EXTRA(''SPQA SPQESPQA'')'\n  IF (&SPQESEL = X)\n   &TBLCMD = '&TBLCMD XTRACE'\n)End\n./ ADD NAME=SPTTBL\n)Attr\n   ^ type(input ) intens(high) caps(on ) just(asis )\n   ! type(output) intens(low ) caps(off) just(asis )\n   @ type(output) intens(high) caps(off) just(right)\n)Body  Expand(\\\\)\n%-\\-\\- IPCS - SPT Table for GDA at &ADDRESS -\\-\\-\n%Subcommand ===>_ZCMD                              \\ \\%Scroll ===>_AMT +\n\n%Primary command: +Any IPCS subcommand.\n%Line commands:   %S+(select DQE's)\n\n%  SPT addr  Subpool  Key    BELOW-DQE's      ANYWHERE-DQE's      ABOVE-DQE's\n+\n)Model\n^Z+!Z          @Z  @Z   +!Z       !Z       !Z       !Z       !Z       !Z\n)Init\n .ZVARS = '(SPTSEL SPTADDR SPTSP SPTPK +\n            SPTFBDQE SPTLBDQE SPTFADQE SPTLADQE SPTFEDQE SPTLEDQE)'\n &amt = CSR\n &ZTDMARK = '........................................+\n             .......................................'\n)Reinit\n)Proc\n &TBLCMD = &Z\n VER(&SPTSEL,LIST,S,X)\n IF (&SPTSEL = S,X)\n  &TBLCMD = '%IPVSDQE THING(SPT) POINTER(SPTADDR) +\n                      ADDRESS(SPTADDR) EXTRA('''')'\n  IF (&SPTSEL = X)\n   &TBLCMD = '%IPVSDQE XTRACE'\n)End\n./ ADD NAME=IPCASID\n)ATTR\n       \\   TYPE(OUTPUT) CAPS(OFF) INTENS(HIGH) JUST(RIGHT)\n)BODY\n%--------------------  IPCS - Choose an ASID  ----------------------------------\n%COMMAND ===>_ZCMD\n+\n  Type an%S+next to one of the address spaces displayed, or\n  enter an ASID number (ddd or X'xxx') in the field provided.\n\n%      ASID NUMBER         ASCB     JOBNAME   DESCRIPTION\n\n_Z\\DEFASID%(X'&DEFASIDX') +&DEFASCB%&DEFJOBN +Assigned by IPCS (SETDEF)\n_Z\\CURASID%(X'&CURASIDX') +&CURASCB%&CURJOBN +From current ASCB\n_Z\\HDRASID%(X'&HDRASIDX') +&HDRASCB%&HDRJOBN +From dump header\n\n%Other ASID if desired ===>_OTHASID+\n\n\n)INIT\n .ZVARS = '(DEFSEL CURSEL HDRSEL)'\n .CURSOR = ZCMD\n &OTHASID = &Z\n &DEFSEL = &Z\n &CURSEL = &Z\n &HDRSEL = &Z\n IF (&IPASID = &DEFASID) &DEFSEL = S\n IF (&IPASID = &CURASID) &CURSEL = S\n IF (&IPASID = &HDRASID) &HDRSEL = S\n IF (&DEFASID = '***')   &DEFSEL = '-'\n IF (&CURASID = '***')   &CURSEL = '-'\n IF (&HDRASID = '***')   &HDRSEL = '-'\n &TEMP = '&DEFSEL.&CURSEL.&HDRSEL'\n IF (&TEMP = SSS,SS-,S-S,S--)\n  &IPASID  = &DEFASID\n  &IPASIDX = &DEFASIDX\n  &IPASCB  = &DEFASCB\n  &IPJOBN  = &DEFJOBN\n  VPUT (IPASID IPASIDX IPASCB IPJOBN) SHARED\n  .RESP = ENTER\n IF (&TEMP = -SS,-S-)\n  &IPASID  = &CURASID\n  &IPASIDX = &CURASIDX\n  &IPASCB  = &CURASCB\n  &IPJOBN  = &CURJOBN\n  VPUT (IPASID IPASIDX IPASCB IPJOBN) SHARED\n  .RESP = ENTER\n IF (&TEMP = --S)\n  &IPASID  = &HDRASID\n  &IPASIDX = &HDRASIDX\n  &IPASCB  = &HDRASCB\n  &IPJOBN  = &HDRJOBN\n  VPUT (IPASID IPASIDX IPASCB IPJOBN) SHARED\n  .RESP = ENTER\n)PROC\n IF (&ZCMD ^= &Z) .MSG = ISPZ001\n IF (&OTHASID ^= &Z)\n  &IPASID  = &Z\n  &IPASIDX = &Z\n  &IPASCB  = &Z\n  &IPJOBN  = &Z\n ELSE\n  VER (&DEFSEL,LIST,S,'-')\n  VER (&CURSEL,LIST,S,'-')\n  VER (&HDRSEL,LIST,S,'-')\n  IF (&DEFSEL ^= S)\n   IF (&CURSEL ^= S)\n    IF (&HDRSEL ^= S)\n     .CURSOR = DEFSEL\n     .MSG = IPZ007\n  IF (&DEFSEL = S)\n   IF (&CURSEL = S)\n    IF (&DEFASID ^= &CURASID)\n     .CURSOR = DEFSEL\n     .MSG = IPZ006\n   IF (&HDRSEL = S)\n    IF (&DEFASID ^= &HDRASID)\n     .CURSOR = DEFSEL\n     .MSG = IPZ006\n   &IPASID  = &DEFASID\n   &IPASIDX = &DEFASIDX\n   &IPASCB  = &DEFASCB\n   &IPJOBN  = &DEFJOBN\n  IF (&CURSEL = S)\n   IF (&HDRSEL = S)\n    IF (&CURASID ^= &HDRASID)\n     .CURSOR = CURSEL\n     .MSG = IPZ006\n   &IPASID  = &CURASID\n   &IPASIDX = &CURASIDX\n   &IPASCB  = &CURASCB\n   &IPJOBN  = &CURJOBN\n  IF (&HDRSEL = S)\n   &IPASID  = &HDRASID\n   &IPASIDX = &HDRASIDX\n   &IPASCB  = &HDRASCB\n   &IPJOBN  = &HDRJOBN\n  VPUT (IPASID IPASIDX IPASCB IPJOBN) SHARED\n)END\n./ ADD NAME=IPCMD\n%------------------  IPCS - Command Entry --------------------------------------\n%IPCS COMMAND ===>_ICMD\n%\n+Dumptitle:%&IPTIT1\n+          %&IPTIT2\n%\n%---------------------IPCS Commands+and Abbreviations%--------------------------\n+\n+\n%ASMCHECK,+ASMK       |%LIST,    +L                                            +\n%COMCHECK,+COMK       |%LISTDUMP,+LDMP                                         +\n%COMPARE, +COMP       |%LISTMAP, +LMAP                                         +\n%DROPMAP, +DROPM      |%LISTSYM, +LSYM                                         +\n%DROPSYM, +DROPS      |%SCAN     +                                             +\n%ENQCHECK,+ENQK       |%SETDEF,  +SETD                                         +\n%EQUATE,  +EQ         |%STACK    +                                             +\n%FIND,    +F          |%STATUS,  +ST                                           +\n%FINDMOD, +FMOD       |%TCBEXIT, +TCBX                                         +\n%FINDUCB, +FINDU      |%TSO      +                                             +\n%IOSCHECK,+IOSK       |%VERBEXIT,+VERBX                                        +\n)INIT\n  .HELP = IPHNONE\n  .CURSOR = ICMD\n)PROC\n  &SEL = 'PGM(BLSGSCMD) PARM(&ICMD)'\n  VER (&ICMD,NONBLANK)\n  &FIRST6 = TRUNC(&ICMD,6)\n  &FIRST5 = TRUNC(&ICMD,5)\n  &REST5 = .TRAIL\n  IF (&FIRST5 = HELP)\n   IF (&FIRST6 ^= HELP)\n    &ICMD = 'HELP,&REST5'\n)END\n\n  Source:\n\n  \"MVS/XA2.1.2 Installation and User's Guide\"\n  IBM International Systems Centers\n  GG24-1596-1\n  (c) Copyright International Business Machines Corporation 1983, 1984\n\n  Page 157\n\n./ ADD NAME=IPCONF\n%------------------  IPCS CONFIRMATION -----------------------------------------\n%COMMAND ===>_ZCMD\n+\n+ Dataset:%&IPDSN\n+\n+ Dumptitle:%&IPTIT1\n+           %&IPTIT2\n+\n+\n+ INSTRUCTION:\n+\n+\n+   Press%ENTER+to confirm request to%&IPACT..\n+\n+   Press%END to cancel request.\n+\n)PROC\n  IF (&ZCMD ^= ' ') .MSG = ISPZ001\n)END\n\n  Source:\n\n  \"MVS/XA2.1.2 Installation and User's Guide\"\n  IBM International Systems Centers\n  GG24-1596-1\n  (c) Copyright International Business Machines Corporation 1983, 1984\n\n  Page 157\n\n./ ADD NAME=IPDAN\n%------------------  IPCS - PRIMARY SELECTION PANEL  ---------------------------\n%SELECT OPTION ===>_ZCMD                                     +Job:%&IPJOBN\n%                                                           +ASID:%&ASIDJUNK\n+Dumptitle:%&IPTIT1\n+          %&IPTIT2\n%\n%   H %HEADER  +- Display dump header diagnostic information   %(CSDL)\n%   V %VIEW    +- View task control blocks in ISPF table format%(CSDL)\n%   A +ANALYSIS - IPCS dump component data analysis\n%   B +BROWSE   - Browse dump\n%   D +SETDEF   - Review and change IPCS defaults\n%   F +FORMAT   - View or print formatted dump\n%   I +IPCS     - Enter IPCS commands\n%   L +LISTDUMP - Display dump inventory\n%   S +SUMMARY  - View or print dump summary\n%\n%&IPDT+&IPDANLT\n%&IPDC+&IPDANLC\n%\n+JOB STATEMENT INFORMATION (required for options &IPDANJO) :\n% ===>_ZLLGJOB1\n% ===>_ZLLGJOB2\n% ===>_ZLLGJOB3\n% ===>_ZLLGJOB4\n)INIT\n  .HELP = IPHNONE\n  VGET (IPASID IPASIDX) SHARED\n  &ASIDJUNK = '&IPASID (X''&IPASIDX'')'\n  IF (&IPDSN = &Z)\n    .RESP = END\n  IF (&IPDSN = 0,1)\n    &IPDT = '     '\n    &IPDANLT = ''\n    &IPDC = '     '\n    &IPDANLC = ''\n    &IPDANJO = 'F,S'\n  IF (&IPDSN ^= 0,1,&Z)\n    &IPDT = '   M '\n    &IPDANLT = 'MOVE     - Move &IPDSN'\n    &IPDC = '   C '\n    &IPDANLC = 'CLEAR    - Clear &IPDSN'\n    &IPDANJO = 'C,F,M,S'\n)REINIT\n  VGET (IPASID IPASIDX) SHARED\n  REFRESH(IPJOBN,IPASID,IPASIDX,ASIDJUNK)\n)PROC\n  IF (&IPDSN = 0,1)\n    &SEL = TRANS( TRUNC (&ZCMD,'.')\n                  A,'PGM(BLSGDCDA) NEWAPPL(BLSL) PASSLIB'\n                  B,'PGM(BLSLDISP) NEWAPPL(BLSL) PASSLIB'\n                  D,'CMD(IPDFS)    MODE(FSCR)'\n                  F,'CMD(IPFORM)   MODE(FSCR)'\n                  H,'CMD(IPHEADER) MODE(FSCR)'\n                 HT,'CMD(IPHEADER XTRACE) MODE(FSCR)'\n                  I,'PANEL(IPCMD)'\n                  L,'PGM(BLSGDUIN) NEWAPPL(BLSL) PASSLIB'\n                  S,'PANEL(IPSUM)'\n                  V,'CMD(IPVIEW)   MODE(FSCR)'\n                 VT,'CMD(IPVIEWXTRACE)   MODE(FSCR)'\n                ' ',' '\n                  *,'?' )\n  IF (&IPDSN ^= 0,1)\n    &SEL = TRANS( TRUNC (&ZCMD,'.')\n                  A,'PGM(BLSGDCDA) NEWAPPL(BLSL) PASSLIB'\n                  B,'PGM(BLSLDISP) NEWAPPL(BLSL) PASSLIB'\n                  C,'CMD(IPCLEAR)  MODE(FSCR)'\n                  D,'CMD(IPDFS)    MODE(FSCR)'\n                  F,'CMD(IPFORM)   MODE(FSCR)'\n                  H,'CMD(IPHEADER) MODE(FSCR)'\n                 HT,'CMD(IPHEADER XTRACE) MODE(FSCR)'\n                  I,'PANEL(IPCMD)'\n                  L,'PGM(BLSGDUIN) NEWAPPL(BLSL) PASSLIB'\n                  S,'PANEL(IPSUM)'\n                  M,'CMD(IPMOVE)   MODE(FSCR)'\n                 MT,'CMD(IPMOVE XTRACE)   MODE(FSCR)'\n                  V,'CMD(IPVIEW)   MODE(FSCR)'\n                 VT,'CMD(IPVIEWXTRACE)   MODE(FSCR)'\n                ' ',' '\n                  *,'?' )\n  &ZTRAIL = .TRAIL\n)END\n\n  Source:\n\n  \"MVS/XA2.1.2 Installation and User's Guide\"\n  IBM International Systems Centers\n  GG24-1596-1\n  (c) Copyright International Business Machines Corporation 1983, 1984\n\n  Page 153\n\n./ ADD NAME=IPDCATBL\n)Attr\n   @ type(output) intens(low ) caps(off) just(asis )\n   ? type(output) intens(low ) caps(off) just(right)\n   ! type(output) intens(high) caps(off) just(asis )\n)Body  Expand(\\\\)\n%-\\-\\- IPCS - System Dumps in Your Catalog -\\-\\-\n%Command ===>_zcmd                                 \\ \\%Scroll ===>_amt +\n%\n+Selection codes: %S+- select dump for IPCS processing\n+                 %P+- purge and clear dump\n+                 %H+- HSM-recall dump dataset\n%   Name                                              Volume\n+\n)Model\n_Z!DCADSN                                             @DCAVOL\n)Init\n  .ZVARS = '(DCASEL)'\n  &amt = CSR\n  &ZTDMARK = &Z\n)Reinit\n)Proc\n  IF (&ZCMD ^= &Z) .MSG = ISPZ001\n)End\n./ ADD NAME=IPDEBTBL\n)Attr\n   ! type(output) intens(low ) caps(off) just(asis )\n)Body  Expand(\\\\)\n%-\\-\\- IPCS - DEB Table for TCB at &TCBADDR -\\-\\-\n%Subcommand ===>_DEBCMD                            \\ \\%Scroll ===>_AMT +\n%\n%Primary commands: %?+- toggle row display between DEB info and DCB info (DSN).\n                   %Other+- any IPCS subcommand.\n%Line commands:   +None\n%IPCS CLIST:      +Any command or CLIST that takes a DCB(addr) operand.\n%\n&DEBHEAD\n+\n)Model\n&DEBMODL\n)Init\n  &amt = CSR\n  .ZVARS = '(DEBSEL)'\n  &ZTDMARK = '........................................+\n              .......................................'\n)Reinit\nIF (&DEBCMD = ?)\n &DEBCMD = &Z\n IF (&DEBNUM = 1)\n  &DEBHEAD = '&H2'\n  &DEBMODL = '&M2'\n  &NEWNUM = 2\n IF (&DEBNUM = 2)\n  &DEBHEAD = '&H1'\n  &DEBMODL = '&M1'\n  &NEWNUM = 1\n &DEBNUM = &NEWNUM\nREFRESH(DEBHEAD,DEBMODL,DEBNUM)\n)Proc\nIF (&DEBCMD = ?)\n &DEBCMD = &Z\n IF (&DEBNUM = 1)\n  &DEBHEAD = '&H2'\n  &DEBMODL = '&M2'\n  &NEWNUM = 2\n IF (&DEBNUM = 2)\n  &DEBHEAD = '&H1'\n  &DEBMODL = '&M1'\n  &NEWNUM = 1\n &DEBNUM = &NEWNUM\n)End\n See 'SYSPGMR.CMD.CLIST(IPDEB)' for table header and model lines.\n./ ADD NAME=IPDEF\n%------------------  IPCS - DEFAULT VALUES -------------------------------------\n%COMMAND ===>_ZCMD\n+\n+Dumptitle:%&IPTIT1\n+          %&IPTIT2\n+\n+  Address space  %==>_IPQUAL\n+\n+  Message routing%==>_IPROUTE\n+\n+  Message control%==>_IPCNTRL\n+\n+  Display content%==>_IPDSP\n+\n+\n+\n+Press%ENTER+to update defaults.\n+\n+Press%END+to exit without an update.\n)INIT\n  &IPCNTRL = 'FLAG(&IPFLG) &IPCON &IPVER'\n  &IPROUTE = '&IPPRI &IPTER'\n)PROC\n  IF (&ZCMD ^= ' ') .MSG = ISPZ001\n  IF (&IPDSP=' ') &IPDSP='NOMACHINE REMARK REQUEST NOSTORAGE SYMBOL'\n)END\n\n  Source:\n\n  \"MVS/XA2.1.2 Installation and User's Guide\"\n  IBM International Systems Centers\n  GG24-1596-1\n  (c) Copyright International Business Machines Corporation 1983, 1984\n\n  Page 156\n\n./ ADD NAME=IPDLDTBL\n)Attr\n   @ type(output) intens(low ) caps(off) just(asis )\n   ? type(output) intens(low ) caps(off) just(right)\n   ! type(output) intens(high) caps(off) just(asis )\n)Body  Expand(\\\\)\n%-\\-\\- IPCS - Current Dump Directory Contents -\\-\\-\n%Command ===>_zcmd                                 \\ \\%Scroll ===>_amt +\n%\n+Selection codes: %S+- select dump for IPCS processing\n+                 %P+- purge and clear dump\n+                 %H+- HRECALL dump dataset\n+                 %A+- display availability of dump dataset\n+\n%   Name                                            Qualification     Blocks\n+\n)Model\n_Z!DLDDSN                                          @DLDQUAL          ?DLDBLKS\n)Init\n  .ZVARS = '(DLDSEL)'\n  &amt = CSR\n  &ZTDMARK = &Z\n)Reinit\n)Proc\n  IF (&ZCMD ^= &Z) .MSG = ISPZ001\n)End\nNotes:\n DLDBYTES is part of the table but not displayed - we have no room.\n./ ADD NAME=IPERROR\n%----------------------------  IPCS DIALOG ERROR  ------------------------------\n%COMMAND ===>_ZCMD                                                             +\n%\n%\n%******************************************************************************\n%*+                                                                          %*\n%*+ %Dialog program BLSG ended with return code &MYCC..                      %*\n%*+                                                                          %*\n%*+  IPCS dialog support may be used only in an ISPF Version 2 session       %*\n%*+  started under control of the IPCS TSO command.                          %*\n%*+                                                                          %*\n%*+                                                                          %*\n%*+  Press%ENTER+key to terminate the dialog.                                %*\n%*+                                                                          %*\n%******************************************************************************\n)INIT\n)PROC\n  IF (&ZCMD ^= ' ') .MSG = ISPZ001      /* INVALID COMMAND            */\n  .RESP = END\n)END\n./ ADD NAME=IPFORM\n%------------------  IPCS - PRINT DUMP -----------------------------------------\n%COMMAND ===>_ZCMD\n+Dumptitle:%&IPTIT1\n+          %&IPTIT2\n+\n+  Outputdevice :%===>_Z+ (P for printer / blank for display)\n+\n%>_Z+ ASMDATA  |IOSDATA %===>_IPIOS                                            +\n%>_Z+ CPUDATA  |          ACTVUCBS,ALLUCB,SMGRBLKS,EXCEPTION\n%>_Z+ CVTMAP   |PRINT   %===>_IPPRT1                                           +\n%>_Z+ GRSTRACE |        %===>_IPPRT2                                           +\n%>_Z+ LOGDATA  |          CURRENT,NUCLEUS,SQA,CSA,\n%>_Z+ LPAMAP   |          STORAGE=ASID(as1,...)=(bbbbbbbb,eeeeeeee)\n%>_Z+ MTRACE   |          JOBNAME=(job1,....)                                  +\n%>_Z+ NUCMAP   |TRACE   %===>_IPTRC                                            +\n%>_Z+ RSMDATA  |          ALL,CURRENT,ASID(as1,...),JOBNAME(job1,...)          +\n%>_Z+ SRMDATA  |VSMDATA %===>_IPVSM                                            +\n%>_Z+ VTAMMAP  |          ALL,CURRENT,ERROR,TCBERROR,NOGLOBAL,\n%>_Z+ SUMDUMP  |          ASIDLIST(as1,...),JOBNAME(job1,...)                  +\n+  CVT-address   %===>_IPCVT     +\n+  SEGTAB-address%===>_IPSEG     +      Sort? %===>_IPZ+\n+\n+Press%END+to exit without output\n)INIT\n  &ZCMD = ' '\n  .ZVARS = '(IPD,IPP1,IPP2,IPP3,IPP4,IPP5,IPP6,IPP7,IPP8,IPP9,+\n             IPP10,IPP11,IPP12)'\n  .CURSOR = IPD\n)PROC\n  IF (&ZCMD ^= ' ') .MSG = ISPZ001\n  VER  (&IPD,LIST,' ',P)\n  &IPSORT = TRANS(TRUNC(&IPZ,1) ' ',' ' Y,SORT N,' ')\n  VPUT (IPP1,IPP2,IPP3,IPP4,IPP5,IPP6,IPP7,IPP8,IPP9,\n        IPP10,IPP11,IPP12) PROFILE\n  VPUT (IPIOS,IPPRT1,IPPRT2,IPTRC,IPVSM,IPD,IPSORT) PROFILE\n)END\n\n  Source:\n\n  \"MVS/XA2.1.2 Installation and User's Guide\"\n  IBM International Systems Centers\n  GG24-1596-1\n  (c) Copyright International Business Machines Corporation 1983, 1984\n\n  Page 154\n\n./ ADD NAME=IPHNONE\n%---------------------------- IPCS - TUTORIAL ----------------------------------\n%SELECTION ===>_ZCMD                                                           +\n%\n%                   --------------------------------------\n                    | INTERACTIVE PROBLEM CONTROL SYSTEM |\n                    --------------------------------------\n+\n%      ******************************************************************\n       *                                                                *\n       *   There is no tutorial available for the function you are      *\n       *   currently executing.  Refer to the IPCS manual or the        *\n       *   HELP member for IPCS for more information.                   *\n       *                                                                *\n       *  +Press%END key+to terminate the tutorial and return to IPCS. %*\n       *                                                                *\n       ******************************************************************\n\n)INIT\n)PROC\n)END\n./ ADD NAME=IPMOVE\n%------------------  IPCS CONFIRMATION -----------------------------------------\n%COMMAND ===>_ZCMD\n+\n+Dumptitle:%&IPTIT1\n+          %&IPTIT2\n+\n+  Dataset:%&IPDSN\n+\n+  &IPSDSCN1\n+  &IPSDSCN2\n+\n+  New dump dataset name ===>_IPSDSN                              +\n+\n+\n+  The old dump dataset will be copied to the new one and then cleared.\n+\n+    Press%ENTER+to confirm request to move and clear.\n+\n+    Press%END to cancel request.\n+\n)INIT\n  IF  (&IPSDSN = &Z)\n   &IPSDSN = 'Z&ZYEAR&ZMONTH&ZDAY..XXXXXXXX.XXXXXXXX.XXXXX.DUMP'\n  .CURSOR = IPSDSN\n)PROC\n  IF  (&ZCMD ^= ' ') .MSG = ISPZ001\n  VER (&IPSDSN,NB,DSNAME)\n  &TEMP = TRUNC(&IPSDSN,1)\n  IF (&TEMP ^= '''')\n    &IPSDSN = '''&ZPREFIX..&IPSDSN'''\n)END\n\n  Compare panel IPSAVE.\n\n./ ADD NAME=IPPRIM\n%------------------  IPCS - INITIALIZATION -------------------------------------\n%SELECT OPTION ===>_ZCMD\n%\n%   B+(blank)     - Perform IPCS functions on a dump dataset\n%\n%   A +ACTIVE     - Perform IPCS functions on active main storage\n%   C +CATALOG    - List dump datasets in your catalog\n%   L +LISTDUMP   - List dump datasets in dump directory\n%   S +SYSDSCAN   - List titles of SYS1.DUMPnn datasets\n%   I +IBM        - Invoke IBM IPCS dialog\n%   X +EXIT       - Terminate IPCS Dialog\n+\n+Press%END+to terminate IPCS session\n+\n+...............................................................................\n+\n%DUMP DATASET (mandatory for option Blank)\n+\n+   SYS1.DUMPnn SUFFIX%===>_Z +\n+   OTHER DATASET NAME%===>_IPDDSN\n+\n+USE EXISTING DDIR-ENTRY FOR THIS DUMP%===>_IPUDD +(YES or NO)\n%\n)INIT\n  .ZVARS = '(IPSF)'\n  .HELP = TIPPRIM\n  .CURSOR = ZCMD\n  &IPFI = ' '\n  IF (&IPDDSN ^= ' ')\n    &IPDSN = ' '\n  IF (&IPDSN ^= ' ',0,1)\n    &IPDDSN = '&IPDSN'\n  IF (&IPDDSN ^= ' ')\n    &IPSF = ' '\n  IF (&IPDDSN = ' ')\n    IF (&IPSF = ' ')\n      &IPSF = 00\n    &TEMP = TRUNC(&IPSF,1)\n    IF (&IPSF = &TEMP)\n      &IPSF = '0&IPSF'\n  &IPUDD = 'YES'\n  &IPDSN = ' '\n)PROC\n  &IPAMS = TRANS(TRUNC(&ZCMD,'.') A,YES AT,YES *,NO)\n  &IPUDD = TRANS(TRUNC(&IPUDD,1) ' ',' ' N,NO *,YES)\n\n  &IPDSN = 0\n  &IPFI = ' ' /* we don't use file name */\n  IF (&ZCMD ^= ' ',T,B,BT)\n    &IPDSN = 1\n  IF (&ZCMD = ' ',T,B,BT)\n    IF (&IPDDSN ^= ' ')\n      IF (&IPSF ^= ' ') .MSG = IP007\n      &IPDSN = &IPDDSN\n    IF (&IPDDSN = ' ')\n      &TEMP = TRUNC(&IPSF,1)\n      IF (&IPSF = &TEMP)\n        &IPSF = '0&IPSF'\n      VER (&IPSF,NB,PICT,'NN')\n      VER (&IPSF,NB,RANGE,0,9)\n      &IPDSN = '''SYS1.DUMP&IPSF'''\n  IF (&IPDSN ^= ' ',0,1)\n    &TEMP = TRUNC(&IPDSN,':')\n    IF (&TEMP = &IPDSN)\n     &TEMP = TRUNC(&IPDSN,1)\n     IF (&TEMP ^= '''')\n       &IPDSN = '''&ZPREFIX..&IPDSN'''\n  VPUT (IPSF,IPDDSN) PROFILE\n  VPUT (IPDSN,IPFI) SHARED\n  &SEL = TRANS( TRUNC (&ZCMD,'.')\n              ' ','CMD(IPDSN)          MODE(FSCR)'\n                B,'CMD(IPDSN)          MODE(FSCR)'\n                T,'CMD(IPDSN   XTRACE) MODE(LINE)'\n               BT,'CMD(IPDSN   XTRACE) MODE(LINE)'\n                A,'CMD(IPDSN)          MODE(FSCR)'\n               AT,'CMD(IPDSN   XTRACE) MODE(LINE)'\n                C,'CMD(IPDCAT)         MODE(FSCR)'\n               CT,'CMD(IPDCAT  XTRACE) MODE(LINE)'\n                L,'CMD(IPDLIST)        MODE(FSCR) PASSLIB NEWAPPL(ISR)'\n               LT,'CMD(IPDLIST XTRACE) MODE(LINE) PASSLIB NEWAPPL(ISR)'\n                S,'CMD(IPDSCAN)        MODE(FSCR) PASSLIB NEWAPPL(ISR)'\n               ST,'CMD(IPDSCAN XTRACE) MODE(LINE) PASSLIB NEWAPPL(ISR)'\n                I,'PANEL(BLSPPRIM) NEWAPPL(BLSG) PASSLIB'\n                X,'EXIT'\n                *,'?' )\n  &ZTRAIL = .TRAIL\n)END\n\n  Source:\n\n  \"MVS/XA2.1.2 Installation and User's Guide\"\n  IBM International Systems Centers\n  GG24-1596-1\n  (c) Copyright International Business Machines Corporation 1983, 1984\n\n  Page 152\n\n./ ADD NAME=IPRBTBL\n)Attr\n   ! type(output) intens(low ) caps(off) just(asis )\n   @ type(output) intens(high) caps(off) just(asis )\n)Body  Expand(\\\\)\n%-\\-\\- IPCS - RB Table for TCB at &TCBADDR -\\-\\-\n%Subcommand ===>_IRBCMD                            \\ \\%Scroll ===>_AMT +\n   %IPCS CLIST:   +Any command or CLIST that takes an RB(addr) operand.\n%  /IPCS Clist //Address  Type  CDE name  IC  PSW                Where\n+\n)Model\n_Z+/_IRBEXIT  +//!Z      !Z    !IRBNAME  @Z  !IRBPSW1 !IRBPSW2  !IRBWHERE\n\n              @R0  !IRBREG0   @R1  !IRBREG1   @R2  !IRBREG2   @R3  !IRBREG3\n              @R4  !IRBREG4   @R5  !IRBREG5   @R6  !IRBREG6   @R7  !IRBREG7\n              @R8  !IRBREG8   @R9  !IRBREG9   @R10 !IRBREGA   @R11 !IRBREGB\n              @R12 !IRBREGC   @R13 !IRBREGD   @R14 !IRBREGE   @R15 !IRBREGF\n\n)Init\n  .ZVARS = '(IRBSEL IRBADDR IRBTYPE IRBINT)'\n  &amt = CSR\n  &ZTDMARK = '........................................+\n              .......................................'\n  &R0 = 'R0 ='\n  &R1 = 'R1 ='\n  &R2 = 'R2 ='\n  &R3 = 'R3 ='\n  &R4 = 'R4 ='\n  &R5 = 'R5 ='\n  &R6 = 'R6 ='\n  &R7 = 'R7 ='\n  &R8 = 'R8 ='\n  &R9 = 'R9 ='\n  &R10= 'R10='\n  &R11= 'R11='\n  &R12= 'R12='\n  &R13= 'R13='\n  &R14= 'R14='\n  &R15= 'R15='\n)Reinit\n)Proc\n  VPUT (IRBSEL IRBEXIT IRBADDR IRBNAME IRBINT IRBPSW1 IRBPSW2) SHARED\n)End\n%Primary command: +Any IPCS subcommand.\n%Line commands:   +None\n./ ADD NAME=IPSAVE\n%------------------  IPCS CONFIRMATION -----------------------------------------\n%COMMAND ===>_ZCMD\n+\n+Dumptitle:%&IPTIT1\n+          %&IPTIT2\n+\n+  Dataset:%&IPDSN\n+\n+  &IPSDSCN1\n+  &IPSDSCN2\n+\n+  New dump dataset name ===>_IPSDSN                              +\n+\n+\n%  Note:+ The above new dataset will be created as new via batch job.\n+\n+\n+    Press%ENTER+to confirm request to save and clear.\n+\n+    Press%END to cancel request.\n+\n)INIT\n  IF  (&IPSDSN = &Z)\n   &IPSDSN = 'Z&ZYEAR&ZMONTH&ZDAY..XXXXXXXX.XXXXXXXX.XXXXX.DUMP'\n  .CURSOR = IPSDSN\n)PROC\n  IF  (&ZCMD ^= ' ') .MSG = ISPZ001\n  VER (&IPSDSN,NB,DSNAME)\n  &TEMP = TRUNC(&IPSDSN,1)\n  IF (&TEMP ^= '''')\n    &IPSDSN = '''&ZPREFIX..&IPSDSN'''\n)END\n\n  Source:\n\n  \"MVS/XA2.1.2 Installation and User's Guide\"\n  IBM International Systems Centers\n  GG24-1596-1\n  (c) Copyright International Business Machines Corporation 1983, 1984\n\n  Page 157\n\n  Copied from panel IPCONF.\n\n./ ADD NAME=IPSDSTBL\n)Attr\n   @ type(output) intens(low ) caps(off) just(asis )\n   ! type(output) intens(high) caps(off) just(asis )\n)Body  Expand(\\\\)\n%-\\-\\- IPCS - Current System Dumps -\\-\\-\n%Command ===>_zcmd                                 \\ \\%Scroll ===>_amt +\n%\n+Selection codes: %S+- select old dump for IPCS processing\n+                 %N+- select new dump for IPCS processing\n+                 %B+- browse AUTOMATE dump listing\n+                 %P+- purge and clear dump\n+\n%  Name        Date       Time   Title\n+\n)Model\n_Z!Z          @Z         @Z     @Z\n)Init\n  .ZVARS = '(SDSSEL SDSDUMP SDSDATE SDSTIME SDSTITLE)'\n  &amt = CSR\n  &ZTDMARK = &Z\n)Reinit\n)Proc\n  IF (&ZCMD ^= &Z) .MSG = ISPZ001\n)End\n./ ADD NAME=IPSUM\n%------------------  IPCS - SUMMARY COMMAND ------------------------------------\n%COMMAND ===>_ZCMD\n+Dumptitle:%&IPTIT1\n+          %&IPTIT2\n+\n+    %blank+Display Summary\n+    %P    +Print Summary\n+\n%  ADDRESS SPACE SELECTION :\n%>_Z+ ALL         all address spaces\n%>_Z+ CURRENT     active at time of dump\n%>_Z+ ERROR       error indicators on\n%>_Z+ TCBERROR    containing TCB in error\n%>_Z+ JOBLIST  %===>_IPJOB                                 +(separate by commas)\n%>_Z+ ASIDLIST %===>_IPASID                                +(separate by commas)\n%  REPORT OPTIONS :\n%>_Z+ KEYFIELD    key fields of ASCB, TCB and RB\n%>_Z+ TCBSUMMARY  summary of TCBs\n%>_Z+ JOBSUMMARY  status of address spaces by jobname\n%>_Z+ FORMAT      all major control blocks\n%>_Z+ REGISTERS   display registers per TCB/RB\n+\n+Press%END+to exit without summary\n)INIT\n  .HELP = IPHNONE\n  .ZVARS = '(IPA1,IPA2,IPA3,IPA4,IPA5,IPA6,IPR1,IPR2,IPR3,IPR4,IPR5)'\n  &IPAS = ' '\n  &IPRS = ' '\n)PROC\n  VER (&ZCMD,LIST,' ',P,MSG=ISPZ001)\n  IF (&IPA1^= ' ') &IPAS = 'ALL '\n  IF (&IPA1 = ' ')\n    IF (&IPA2^= ' ') &IPAS = 'CURRENT '\n    IF (&IPA3^= ' ') &IPAS = '&IPAS ERROR '\n    IF (&IPA4^= ' ') &IPAS = '&IPAS TCBERROR '\n    IF (&IPA5^= ' ') &IPAS = '&IPAS JOBLIST(&IPJOB) '\n    IF (&IPA6^= ' ') &IPAS = '&IPAS ASIDLIST(&IPASID) '\n  IF (&IPR1^= ' ') &IPRS = 'KEYFIELD '\n  IF (&IPR2^= ' ') &IPRS = '&IPRS TCBSUMMARY '\n  IF (&IPR3^= ' ') &IPRS = '&IPRS JOBSUMMARY '\n  IF (&IPR4^= ' ') &IPRS = '&IPRS FORMAT '\n  IF (&IPR5^= ' ') &IPRS = '&IPRS REGISTERS '\n  VPUT (IPA1,IPA2,IPA3,IPA4,IPA5,IPA6,IPR1,IPR2,IPR3,IPR4,IPR5) PROFILE\n  VPUT (IPAS,IPRS) PROFILE\n  &ZSEL = TRANS(TRUNC(&ZCMD,'.')\n          P,'CMD(IPPSUM) MODE(FSCR)'\n        ' ','PGM(BLSGSCMD) PARM(SUMM &IPAS &IPRS)'\n        '*','?')\n)END\n\n  Source:\n\n  \"MVS/XA2.1.2 Installation and User's Guide\"\n  IBM International Systems Centers\n  GG24-1596-1\n  (c) Copyright International Business Machines Corporation 1983, 1984\n\n  Page 155\n\n./ ADD NAME=IPSYS1\n%------------------  IPCS - COPY &IPDSN ----------------------------------------\n%COMMAND ===>_ZCMD\n+\n+\n+  Dataset:%&IPDSN\n+\n+  New dump dataset name ===>_IPNEWDSN                            +\n+\n+\n%  Note:+ The above new dataset will be created ON LINE.\n+\n+    (Leave blank to continue using &IPDSN as your dump dataset.)\n+\n+\n+    Press%ENTER+to confirm request to copy and clear &IPDSN..\n+\n+    Press%END to cancel request.\n+\n)INIT\n  .CURSOR = IPNEWDSN\n)PROC\n  IF  (&ZCMD ^= ' ') .MSG = ISPZ001\n  VER (&IPNEWDSN,DSNAME)\n  IF (&IPNEWDSN ^= &Z)\n   &TEMP = TRUNC(&IPNEWDSN,1)\n   IF (&TEMP ^= '''')\n    &IPNEWDSN = '''&ZPREFIX..&IPNEWDSN'''\n)END\n./ ADD NAME=IPTCBTBL\n)Attr\n   ! type(output) intens(low ) caps(off) just(asis )\n   ? type(output) intens(high) caps(off) just(asis )\n)Body  Expand(\\\\)\n%-\\-\\- IPCS - TCB Table for ASID &ASID, job &JOBNAME -\\-\\-\n%Subcommand ===>_ITTCMD                            \\ \\%Scroll ===>_AMT +\n%\n%Primary commands:+Any IPCS subcommand\n%Line commands:   %R+- display RB's;%D+- display DEB's;%V+- display VSM\n%IPCS CLIST:      +Any command or CLIST that takes a TCB(addr) operand.\n+\n%Sel/IPCS Clist // Address  Module   * Compcode  RTWA     Mother Daughter Sister\n+\n)Model\n _Z+/_ITTEXIT  +//!ITTADDR!ITTNAME ?Z  ?ITTCOMP ?ITTRTWA !ITTMOM !ITTKID !ITTSIS\n)Init\n  .ZVARS = '(ITTSEL ITTSTUFF)'\n  &amt = CSR\n  &ZTDMARK = '+\n* J = Job step TCB;  N = nondispatchable ......................................+\n             '\n)Reinit\n)Proc\n  VPUT (ITTSEL ITTEXIT ITTADDR ITTNAME ITTCOMP ITTRTWA\n        ITTMOM ITTKID ITTSIS) SHARED\n)End\n./ ADD NAME=IPVS\n%--------------------  IPCS Virtual Storage Management -------------------------\n%SELECTION ===>_ZCMD                                                           +\n+\n   %1+- PVT-MAP - Map of allocated private area virtual storage\n   %2+- PVT-CBS - Private area control blocks (SPQE, DQE, FQE)\n   %3+- LSQA-AE - LSQA allocation elements (AE)\n   %4+- LSQA-CB - LSQA control blocks (LDA, DFE)\n   %5+- CSA-MAP - Map of allocated CSA virtual storage\n   %6+- CSA-CBS - CSA control blocks (SPT, DQE, FQE)\n\n   %8+- SQA-CBS - SQA control blocks (GDA, DFE)\n   %9+- SPTT    - Subpool translation table\n\n                                            %CSA: +&GDACSA (size &GDACSASZ)\n+   TCB address      %===>_VVTCB   +        %ECSA:+&GDAECSA (size &GDAECSAS)\n+   Subpool selection%===>_VVSPLIST+        %SQA: +&GDASQA (size &GDASQASZ)\n                                            %ESQA:+&GDAESQA (size &GDAESQAS)\n                                            %PVT: +&GDAPVT (size &GDAPVTSZ)\n                                            %EPVT:+&GDAEPVT (size &GDAEPVTS)\n)INIT\n .CURSOR = ZCMD\n)PROC\n &VVTCB = TRUNC(&VVTCB,'.')\n VER(&VVTCB,NB,HEX)\n &TEMP1 = TRUNC(&ZCMD,'.')\n &ZTRAIL = .TRAIL\n &TEMP2 = TRUNC(&TEMP1,1)\n &TEMP3 = .TRAIL\n IF (&TEMP3 = T)\n  &TEMP1   = &TEMP2\n  &P       = '%'\n  &XTRACE  = 'XTRACE'\n  &MODE    = 'LINE'\n ELSE\n  &P       = ''\n  &XTRACE  = ''\n  &MODE    = 'FSCR'\n &ZSEL=TRANS(&TEMP1\n             1 ,IPVSPMAP\n             2 ,IPVSPVT\n             3 ,IPVSAE\n             4 ,IPVSLSQA\n             5 ,IPVSCMAP\n             6 ,IPVSCSA\n\n             8 ,IPVSSQA\n             9 ,IPVSSPTT\n             ' ',' '\n             *,'?')\n IF (&ZSEL ^= ' ','?')\n  &STUFF = '&VVTCB &XTRACE'\n  IF (&VVSPLIST ^= &Z)\n   &STUFF = '&VVTCB SUBPOOL(&VVSPLIST) &XTRACE'\n  &ZSEL = 'PGM(BLSGSCMD) PARM(&P.&ZSEL &STUFF) MODE(&MODE)'\n)END\n./ ADD NAME=IPVSCSA1\n)BODY EXPAND(\\\\)\n%-\\-\\-  CSA Viewing Parameters -\\-\\-\n%COMMAND ===>_ZCMD                                                             +\n%\n+\n+  Subpool number%===>_Z  +   (227, 228, 231, 241)\n+\n+  Storage key   %===>_Z +    (0-15)\n+\n)INIT\n .ZVARS = '(CSASP CSAPK)'\n)PROC\n IF (&ZCMD ^= &Z) .MSG = ISPZ001\n VER (&CSASP,NB,LIST,227,228,231,241)\n VER (&CSAPK,NB,RANGE,0,15)\n)END\n./ ADD NAME=IPVSROWS\n%-------------------- TABLE ROW WARNING ----------------------------------------\n%COMMAND ===>_ZCMD                                                             +\n%\n+   There are more than &ROWCOUNT rows generated for this table so far.\n+\n+\n+   Press ENTER to continue, or press END key to show the table so far.\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=IPVSSPTT\n%--------------------  IPCS SUBPOOL TRANSLATION TABLE INFO ---------------------\n%COMMAND ===>_ZCMD                                                             +\n%\n%&WARNING\n%\n+\n+Enter subpool number (0-255)%===>_Z  +\n)INIT\n .ZVARS = '(SPNO)'\n .CURSOR = SPNO\n)PROC\n IF (&ZCMD ^= &Z) .MSG = ISPZ001\n VER(&SPNO,NB,RANGE,0,255)\n)END\n./ ADD NAME=TIPPRIM\n%TUTORIAL ---------  IPCS - INITIALIZATION ---------------------------- TUTORIAL\n%OPTION ===>_ZCMD\n\n+ This is the IPCS primary option menu you see when you enter the command%IP.+\n\n\n+ The following topics will be displayed only if selected by letter:\n\n%   B+(blank)     - Perform IPCS functions on a dump dataset\n%   A+ ACTIVE     - Perform IPCS functions on active main storage\n%   C+ CATALOG    - List dump datasets in your catalog\n%   L+ LISTDUMP   - List dump datasets in dump directory\n%   S+ SYSDSCAN   - List titles of SYS1.DUMPnn datasets\n%   I+ IBM        - Invoke IBM IPCS dialog\n)INIT\n)PROC\n     &ZSEL = TRANS( &ZCMD\n                B,*TIPPRIMB\n                A,*TIPPRIMA\n                C,*TIPPRIMC\n                L,*TIPPRIML\n                S,*TIPPRIMS\n                I,*BLSPHELP\n                *,'?'\n                )\n)END\n./ ADD NAME=TIPPRIMA\n%---------------------------- IPCS - TUTORIAL ----------------------------------\n%SELECTION ===>_ZCMD                                                           +\n%\n%                   --------------------------------------\n                    | INTERACTIVE PROBLEM CONTROL SYSTEM |\n                    --------------------------------------\n+\n%      ******************************************************************\n       *                                                                *\n       *   There is no tutorial available for the function you are      *\n       *   currently executing.  Refer to the IPCS manual or the        *\n       *   HELP member for IPCS for more information.                   *\n       *                                                                *\n       *  +Press%END key+to terminate the tutorial and return to IPCS. %*\n       *                                                                *\n       ******************************************************************\n\n)INIT\n)PROC\n)END\n./ ADD NAME=TIPPRIMB\n%---------------------------- IPCS - TUTORIAL ----------------------------------\n%SELECTION ===>_ZCMD                                                           +\n%\n%                   --------------------------------------\n                    | INTERACTIVE PROBLEM CONTROL SYSTEM |\n                    --------------------------------------\n+\n%      ******************************************************************\n       *                                                                *\n       *   There is no tutorial available for the function you are      *\n       *   currently executing.  Refer to the IPCS manual or the        *\n       *   HELP member for IPCS for more information.                   *\n       *                                                                *\n       *  +Press%END key+to terminate the tutorial and return to IPCS. %*\n       *                                                                *\n       ******************************************************************\n\n)INIT\n)PROC\n)END\n./ ADD NAME=TIPPRIMC\n%---------------------------- IPCS - TUTORIAL ----------------------------------\n%SELECTION ===>_ZCMD                                                           +\n%\n%                   --------------------------------------\n                    | INTERACTIVE PROBLEM CONTROL SYSTEM |\n                    --------------------------------------\n+\n%      ******************************************************************\n       *                                                                *\n       *   There is no tutorial available for the function you are      *\n       *   currently executing.  Refer to the IPCS manual or the        *\n       *   HELP member for IPCS for more information.                   *\n       *                                                                *\n       *  +Press%END key+to terminate the tutorial and return to IPCS. %*\n       *                                                                *\n       ******************************************************************\n\n)INIT\n)PROC\n)END\n./ ADD NAME=TIPPRIML\n%---------------------------- IPCS - TUTORIAL ----------------------------------\n%SELECTION ===>_ZCMD                                                           +\n%\n%                   --------------------------------------\n                    | INTERACTIVE PROBLEM CONTROL SYSTEM |\n                    --------------------------------------\n+\n%      ******************************************************************\n       *                                                                *\n       *   There is no tutorial available for the function you are      *\n       *   currently executing.  Refer to the IPCS manual or the        *\n       *   HELP member for IPCS for more information.                   *\n       *                                                                *\n       *  +Press%END key+to terminate the tutorial and return to IPCS. %*\n       *                                                                *\n       ******************************************************************\n\n)INIT\n)PROC\n)END\n./ ADD NAME=TIPPRIMS\n%---------------------------- IPCS - TUTORIAL ----------------------------------\n%SELECTION ===>_ZCMD                                                           +\n%\n%                   --------------------------------------\n                    | INTERACTIVE PROBLEM CONTROL SYSTEM |\n                    --------------------------------------\n+\n%      ******************************************************************\n       *                                                                *\n       *   There is no tutorial available for the function you are      *\n       *   currently executing.  Refer to the IPCS manual or the        *\n       *   HELP member for IPCS for more information.                   *\n       *                                                                *\n       *  +Press%END key+to terminate the tutorial and return to IPCS. %*\n       *                                                                *\n       ******************************************************************\n\n)INIT\n)PROC\n)END\n./ ENDUP\n?!\n//SKEL     EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='SKEL'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=IPPRINT\n)SEL  &ZLLGJOB1 ^= &Z\n&ZLLGJOB1\n)ENDSEL\n)SEL  &ZLLGJOB2 ^= &Z\n&ZLLGJOB2\n)ENDSEL\n)SEL  &ZLLGJOB3 ^= &Z\n&ZLLGJOB3\n)ENDSEL\n)SEL  &ZLLGJOB4 ^= &Z\n&ZLLGJOB4\n)ENDSEL\n/*JOBPARM LINES=9999\n//************************\n//* PRINT SYS1.DUMP      *\n//************************\n//PRDMP  EXEC PGM=IKJEFT01,REGION=4096K,PARM=AMDPRDMP\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//PRINTER  DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n//TAPE     DD DISP=SHR,DSN=&IPDSN\n//SYSIN    DD *\n)SEL &IPP11 ^= &Z\n  DAEDATA\n  SUMDUMP\n)ENDSEL\n)SEL &IPP1 ^= &Z\n  ASMDATA\n)ENDSEL\n)SEL &IPP2 ^= &Z\n  CPUDATA\n)ENDSEL\n)SEL &IPP3 ^= &Z\n  CVTMAP\n)ENDSEL\n)SEL &IPP4 ^= &Z\n  GRSTRACE\n)ENDSEL\n)SEL &IPP5 ^= &Z\n  LOGDATA\n)ENDSEL\n)SEL &IPP6 ^= &Z\n  LPAMAP &IPSORT\n)ENDSEL\n)SEL &IPP7 ^= &Z\n  MTRACE\n)ENDSEL\n)SEL &IPP8 ^= &Z\n  NUCMAP &IPSORT\n)ENDSEL\n)SEL &IPP9 ^= &Z\n  RSMDATA\n)ENDSEL\n)SEL &IPP10 ^= &Z\n  SRMDATA\n)ENDSEL\n)SEL &IPP11 ^= &Z\n  VTAMMAP\n)ENDSEL\n)SEL &IPIOS ^= &Z\n  IOSDATA &IPIOS\n)ENDSEL\n)SEL &IPTRC ^= &Z\n  TRACE &IPTRC\n)ENDSEL\n)SEL &IPVSM ^= &Z\n  VSMDATA &IPVSM\n)ENDSEL\n)SEL &IPPRT1 ^= &Z\n  PRINT &IPPRT1 &IPPRT2\n)ENDSEL\n)SEL &IPCVT ^= &Z\n  CVT = &IPCVT\n)ENDSEL\n)SEL &IPSEG ^= &Z\n  SEGTAB = &IPSEG\n)ENDSEL\n  END\n/*\n)CM\n)CM Source:\n)CM\n)CM \"MVS/XA2.1.2 Installation and User's Guide\"\n)CM IBM International Systems Centers\n)CM GG24-1596-1\n)CM (c) Copyright International Business Machines Corporation 1983, 1984\n)CM\n)CM Page 165\n)CM\n./ ADD NAME=IPPSUM\n)SEL  &ZLLGJOB1 ^= &Z\n&ZLLGJOB1\n)ENDSEL\n)SEL  &ZLLGJOB2 ^= &Z\n&ZLLGJOB2\n)ENDSEL\n)SEL  &ZLLGJOB3 ^= &Z\n&ZLLGJOB3\n)ENDSEL\n)SEL  &ZLLGJOB4 ^= &Z\n&ZLLGJOB4\n)ENDSEL\n//*******************\n//* PRINT SUMMARY   *\n//*******************\n//PRDMP  EXEC PGM=IKJEFT01,REGION=4096K,PARM=AMDPRDMP\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//PRINTER  DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n//TAPE     DD DISP=SHR,DSN=&IPDSN\n//SYSIN    DD *\n  SUMMARY &IPAS\n          &IPRS\n  END\n/*\n)CM\n)CM Source:\n)CM\n)CM \"MVS/XA2.1.2 Installation and User's Guide\"\n)CM IBM International Systems Centers\n)CM GG24-1596-1\n)CM (c) Copyright International Business Machines Corporation 1983, 1984\n)CM\n)CM Page 167\n)CM\n./ ADD NAME=IPSAVE\n)SEL  &ZLLGJOB1 ^= &Z\n&ZLLGJOB1\n)ENDSEL\n)SEL  &ZLLGJOB2 ^= &Z\n&ZLLGJOB2\n)ENDSEL\n)SEL  &ZLLGJOB3 ^= &Z\n&ZLLGJOB3\n)ENDSEL\n)SEL  &ZLLGJOB4 ^= &Z\n&ZLLGJOB4\n)ENDSEL\n//***********************\n//* SAVE SYS1.DUMP      *\n//***********************\n//PRDMP  EXEC PGM=IKJEFT01,REGION=2048K,PARM=AMDPRDMP\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//PRINTER  DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n//            DSN=&IPSDSN,\n//            SPACE=(CYL,(25,15),RLSE),\n//            DCB=(RECFM=F,LRECL=4104,BLKSIZE=4104)\n//TAPE     DD DISP=SHR,DSN=&IPDSN\n//SYSIN    DD *\n  END\n/*\n)CM\n)CM Source:\n)CM\n)CM \"MVS/XA2.1.2 Installation and User's Guide\"\n)CM IBM International Systems Centers\n)CM GG24-1596-1\n)CM (c) Copyright International Business Machines Corporation 1983, 1984\n)CM\n)CM Page 169\n)CM\n)CM Originally appeared as \"IPTAPE\" but was changed to save to DASD.\n)CM\n./ ADD NAME=IPTAPE\n)SEL  &ZLLGJOB1 ^= &Z\n&ZLLGJOB1\n)ENDSEL\n)SEL  &ZLLGJOB2 ^= &Z\n&ZLLGJOB2\n)ENDSEL\n)SEL  &ZLLGJOB3 ^= &Z\n&ZLLGJOB3\n)ENDSEL\n)SEL  &ZLLGJOB4 ^= &Z\n&ZLLGJOB4\n)ENDSEL\n//***********************\n//* SAVE SYS1.DUMP      *\n//***********************\n//PRDMP  EXEC PGM=IKJEFT01,REGION=2048K,PARM=AMDPRDMP\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//PRINTER  DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//SYSUT2   DD DISP=(NEW,CATLG),DSN=&IPSDSN,UNIT=TAPE\n//TAPE     DD DISP=SHR,DSN=&IPDSN\n//SYSIN    DD *\n  END\n/*\n)CM\n)CM Source:\n)CM\n)CM \"MVS/XA2.1.2 Installation and User's Guide\"\n)CM IBM International Systems Centers\n)CM GG24-1596-1\n)CM (c) Copyright International Business Machines Corporation 1983, 1984\n)CM\n)CM Page 169\n)CM\n./ ENDUP\n?!\n//ASM      EXEC MDLOAD,BS='6160',TRK1='10',TRK2='1',TO='ASM'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=$$INDEX\n***********************************************************************\n*                                                                     *\n*  This PDS contains assembler source for IPCS exit routines that     *\n*  may be used by IPCS subcommands TCBEXIT, ASCBEXIT, and VERBEXIT,   *\n*  as well as supporting routines therefor.                           *\n*                                                                     *\n*  Note especially subroutine XABDGET, which is designed to permit    *\n*  IPCS exits that use it to run as both IPCS exits and READY-mode    *\n*  live-storage analyzers.                                            *\n*                                                                     *\n*  Oh yeah, it also contains other SYSPGMR goodies.                   *\n*                                                                     *\n***********************************************************************\n./ ADD NAME=VITWHR\n         TITLE 'VITWHR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'VITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *\n* REALLY A TCB ADDRESS AFTER ALL), REPORTS ON WHAT LOAD MODULE THE    *\n* ADDRESS LIVES IN AS WELL AS THE OFFSET.  UNLIKE THE XITWHR EXIT,    *\n* HOWEVER, THIS ROUTINE DOES NOT DISPLAY THE INFO, BUT RETURNS THE    *\n* VALUES AS ISPF SHARED VARIABLES.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    POINTER TO CDE\nR8       EQU   8    USED IN NUCMAP SCANNING\nR9       EQU   9    USED IN NUCMAP SCANNING\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nVITWHR   CSECT\n         SAVE  (14,12),,VITWHR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING VITWHR,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\n* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.\n* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES\n* THE CORRECT ASID, ETC.\n         SPACE 1\n         XR    R0,R0\n         ST    R0,ADPLCOM1         CLEAR XIPSWHR COMMUNICATION FIELD\n         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE\n         LR    R1,R4               GET ADDRESS OF ABDPL\n         SPACE 1\n         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE\n         SPACE 1\n         MVI   VITPLACE,C' '\n         MVC   VITPLACE+1(L'VITPLACE-1),VITPLACE\n         MVI   VITNAME,C' '\n         MVC   VITNAME+1(L'VITNAME-1),VITNAME\n         MVI   VITLOC,C' '\n         MVC   VITLOC+1(L'VITLOC-1),VITLOC\n         MVI   VITOFF,C' '\n         MVC   VITOFF+1(L'VITOFF-1),VITOFF\n*\n* SET VITPLACE = THE AREA WHERE IT WAS FOUND: JPA/PLPA/MLPA/NUC/ERR\n*\n         MVC   VITPLACE(4),ADPLFMT1\n         CLI   VITPLACE,C' '\n         BE    VITERROR\n         CLI   VITPLACE,C'E'\n         BE    VITERRNP\n         B     VITOK\nVITERROR DS    0H                  ERROR - MODULE NOT FOUND\n         MVC   VITPLACE(11),=C'UNAVAILABLE'\nVITERRNP DS    0H                  STORAGE ERROR - RETAIN VITPLACE\n         MVC   VITNAME(11),=C'UNAVAILABLE'\n         MVC   VITLOC(11),=C'UNAVAILABLE'\n         B     VITSET\nVITOK    DS    0H\n*\n* SET VITNAME = THE NAME OF THE LOAD MODULE\n*\n         MVC   VITNAME(8),ADPLCOM1\n*\n* SET VITLOC = THE DECIMAL OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE\n*\n         L     R0,ADPLFMT2\n         CVD   R0,DOUBLE\n         UNPK  VITLOC(10),DOUBLE\n         OI    VITLOC+9,X'F0'\n*\n* SET VITOFF = THE HEX OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE\n*\n         L     R0,ADPLFMT2\n         ST    R0,DOUBLE\n         UNPK  VITOFF(9),DOUBLE(5)\n         TR    VITOFF(8),HEXTBL\n         MVC   VITOFF+8(8),=CL8'         '\n         LA    R1,VITOFF\n         LA    R15,7\nVOLOOP   DS    0H\n         CLI   0(R1),C'0'\n         BNE   VOLEND\n         LA    R1,1(,R1)\n         BCT   R15,VOLOOP\nVOLEND   DS    0H\n         MVC   VITOFF(8),0(R1)\n         SPACE 1\nVITSET   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* OK, NOW INVOKE ISPF DIALOG SERVICES TO SET THE THREE VALUES AS      *\n* ISPF DIALOG VARIABLES.                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LOAD  EPLOC==CL8'ISPLINK'\n         ST    R0,@ISPLINK\n*\n* ISPEXEC VDEFINE (VITNAME VITPLACE VITLOC VITOFF)\n*\n         LA    R1,=C'VDEFINE '\n         ST    R1,ISPPARMS+0\n         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'\n         ST    R1,ISPPARMS+4\n         LA    R1,VITPLACE\n         ST    R1,ISPPARMS+8\n         LA    R1,=C'CHAR '\n         ST    R1,ISPPARMS+12\n         LA    R1,=F'11'\n         ST    R1,ISPPARMS+16\n         OI    ISPPARMS+16,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC VPUT (VITNAME VITPLACE VITLOC VITOFF) SHARED\n*\n         LA    R1,=C'VPUT    '\n         ST    R1,ISPPARMS+0\n         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'\n         ST    R1,ISPPARMS+4\n         LA    R1,=C'SHARED '\n         ST    R1,ISPPARMS+8\n         OI    ISPPARMS+8,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC VDELETE (VITNAME VITPLACE VITLOC VITOFF)\n*\n         LA    R1,=C'VDELETE '\n         ST    R1,ISPPARMS+0\n         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'\n         ST    R1,ISPPARMS+4\n         OI    ISPPARMS+4,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* GOODBYE\n*\n         DELETE EPLOC==CL8'ISPLINK '\n*\n* RETURN TO CALLER\n*\n         B     RETURN0\n         SPACE 2\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION\nOUTSAVE  DS    A\n         SPACE 1\n@ISPLINK DS    A                   ADDRESS OF ISPLINK\nISPPARMS DS    6A                  PARMS FOR ISPLINK\n         SPACE 1\nVITPLACE DS    CL11                VALUE OF ISPF VARIABLE\nVITNAME  DS    CL11                VALUE OF ISPF VARIABLE\nVITLOC   DS    CL11                VALUE OF ISPF VARIABLE\nVITOFF   DS    CL11                VALUE OF ISPF VARIABLE\n         DS    CL8                 PADDING\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORK AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IHACDE\n         EJECT\n         IHAXTLST\n         EJECT\n         IHALPDE\n         EJECT\n         IKJTCB\n         EJECT\n         IKJTSVT\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=XABDGET\n         TITLE 'XABDGET  - VERB EXIT INTERFACE MODULE'\n***********************************************************************\n*                                                                     *\n* XABDGET  - VERB EXIT INTERFACE MODULE                               *\n*                                                                     *\n* THIS MODULE HAS SEVERAL ENTRY POINTS, ALL USED TO ENABLE A PROGRAM  *\n* TO RUN AS A TSO COMMAND PROCESSOR OR AN IPCS VERB EXIT:             *\n*                                                                     *\n* XABDGET - DETERMINE IF THE PROGRAM WAS INVOKED AS A VERB EXIT AND   *\n*           RETURN THE ADDRESS OF THE ABDPL IF SO, OTHERWISE BUILD    *\n*           A FAKE ABDPL AND RETURN ITS ADDRESS.                      *\n* XABDFRE - FREE THE FAKE ABDPL BUILT BY XABDGET.                     *\n* XABDMEM - FAKE STORAGE ACCESS ROUTINE.                              *\n* XABDPRT - FAKE OUTPUT WRITING ROUTINE.                              *\n*                                                                     *\n* (THERE MAY BE OTHERS, LIKE A FAKE FORMATTER, IN THE FUTURE.)        *\n*                                                                     *\n* NOTE: CURRENTLY THERE IS NO \"XABDFRE\" ENTRY POINT - THE XABDGET     *\n*       EP WITH R1 = 0 IS A GET REQUEST, ELSE A FREE REQUEST.         *\n*                                                                     *\n* 09/26/1997 SEB1525 - replaced XPUTLINE with direct call to PUTLINE  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    NUMBER OF ELEMNTS IN PARAMETER LIST\nR4       EQU   4    ADDRESS OF ABDPL\nR5       EQU   5    ADDRESS OF ABDPL EXTENSION\nR6       EQU   6    ADDRESS OF OUTPUT BUFFER\nR7       EQU   7    .\nR8       EQU   8    SAVED PARM POINTER\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXABDGET  CSECT\n         SPACE 1\n         SAVE  (14,12),,XABDGET_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XABDGET,R12\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* XABDGET IS CALLED WITH R1 CONTAINING:                               *\n*    THE ADDRESS OF THE FAKE ABDPL, IF IT IS TO BE FREED.             *\n*    ZEROES, IF AN ABDPL IS TO BE OBTAINED.                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   R1,R1\n         BNZ   FREEPL\n         EJECT\nGETPL    DS    0H                  R1 = 0, GET AN ABDPL\n         SPACE 1\n         L     R1,4(,R13)          GET SA WHERE CALLER SAVED REGS\n         L     R1,24(,R1)          GET R1 PASSED TO CALLER\n         LR    R8,R1               SAVE FOR FUTURE USE\n         LR    R2,R1               POINT TO FIRST PARM\n* COUNT # OF PARMS PASSED.  IF GE 7, ASSUME CALLED AS VERB EXIT.\n         LA    R0,6                INITIALIZE PARAMETER COUNT\n         LA    R3,1                CLEAR PARAMETER COUNT\nPARMLOOP TM    0(R2),X'80'         IF VL BIT (LAST PARM ADDR) FOUND,\n         BO    LASTPARM            THEN WE GOT IT\n         LA    R3,1(,R3)\n         LA    R2,4(,R2)           ELSE BUMP POINTER\n         BCT   R0,PARMLOOP         AND CONTINUE LOOPING\nLASTPARM LTR   R0,R0               IF LESS THAN 7 PARMS (R0 ^= 0)\n         BNZ   GETFAKE             THEN NOT INVOKED AS VERB EXIT\n         L     R15,X'21C'          -> TCB\n         L     R15,X'B4'(,R15)     -> JSCB\n         L     R15,X'15C'(,R15)    -> ACTIVE JSCB\n         L     R15,X'108'(,R15)    -> PSCB\n         C     R15,8(,R1)          IF PARM 3 -> PSCB (INVOKED AS CMD)\n******** BE    GETFAKE             THEN NOT INVOKED AS VERB EXIT\n         BNE   RETURN0             ELSE RETURN, R1 -> ABDPL\n         SPACE 1\n* ELSE WE HAVE TO BUILD OUR OWN FAKE ABDPL\n         SPACE 1\nGETFAKE  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* WE ACQUIRE A WORK AREA WITH THE FOLLOWING CONTIGUOUS AREAS:         *\n*                                                                     *\n*   THE ABDPL                                                         *\n*   THE ABDPL EXTENSION                                               *\n*   OUR OWN AREA, INCLUDING OUTPUT BUFFER, CPPL, AND LOTS OF OTHERS.  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         GETMAIN R,LV=TOTAREAL     GET STORAGE FOR ABDPL ET AL.\n         LR    R4,R1               SAVE ITS ADDRESS\n         USING ABDPL,R4\n         LA    R5,ADPLLEN(,R4)     ADDRESS THE EXTENSION\n         USING ADPLEXTN,R5\n         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA\n         USING OURAREA,R6\n*\n* INITIALIZE ABDPL\n*\n         XC    ABDPL(ADPLLEN),ABDPL\n         L     R15,X'21C'          ->TCB\n         ST    R15,ADPLTCB         SET TCB OF CURRENT TASK\n         L     R15,X'224'          ->ASCB\n         LH    R15,X'24'(,R15)     ASID\n         STH   R15,ADPLASID        ADDRESS SPACE IDENTIFIER\n         MVI   ADPLFLAG,ADPLSYTM   SET VS1 BIT (REALLY \"FAKE\" BIT)\n         LA    R15,OURBUF\n         ST    R15,ADPLBUF         ADDRESS OF OUTPUT BUFFER\n         L     R15,=V(XABDPRT)\n         ST    R15,ADPLPRNT        ADDRESS OF PRINT ROUTINE\n         L     R15,X'10'\n         ST    R15,ADPLCVT         ADDRESS OF CVT\n         L     R15,=V(XABDMEM)\n         ST    R15,ADPLMEMA        ADDRESS OF MEMORY ACCESS ROUTINE\n*        L     R15,=V(XABDFMT)\n*        ST    R15,ADPLFRMT        ADDRESS OF FORMAT ROUTINE\n*\n         ST    R5,ADPLEXT          ADDRESS OF EXTENSION\n*        L     R15,=V(XABDSRV)\n*        ST    R15,ADPLSERV        ADDRESS OF SERVICES ROUTER\n*\n* INITIALIZE ADPL EXTENSION\n*\n         XC    ADPLEXTN(ADPLEXTL),ADPLEXTN\n* CHECK # OF PARMS PASSED.  IF 4, ASSUME CPPL PASSED\n         L     R15,X'21C'          GET TCB ADDRESS\n         L     R15,X'B4'(,R15)     GET JSCB ADDRESS\n         L     R15,X'15C'(,R15)    GET ADDRESS OF ACTIVE JSCB\n         L     R15,X'108'(,R15)    GET ADDRESS OF PSCB\n         CH    R3,=H'4'            IF AT LEAST 4 PARMS\n         BL    NOTTSOCP            AND\n         C     R15,8(,R8)          PARM 3 -> PSCB (INVOKED AS CMD)\n         BNE   NOTTSOCP            THEN\n         ST    R8,ADPLCPPL          INPUT PARM -> CPPL\n         L     R1,0(,R8)            POINT TO COMMAND BUFFER\n         LH    R14,0(,R1)           GET LENGTH OF COMMAND BUFFER\n         LH    R15,2(,R1)           GET OFFSET TO FIRST OPERAND\n         LA    R15,4(R15,R1)        ABSOLUTE ADDRESS OF OPERAND\n         ST    R15,ADPLOPTR         SET ADDRESS OF OPERANDS BUFFER\n         ALR   R14,R1               POINT TO END OF COMMAND BUFFER\n         SR    R14,R15              SUBTRACT OFFSET TO FIRST OPERAND\n         STH   R14,ADPLOPLN         SET LENGTH OF VERB OPERAND LIST\n         B     AFTTSOCP            ELSE\nNOTTSOCP DS    0H                   ...BUILD OUR OWN CPPL\n         ST    R15,CPPLPSCB         SAVE PSCB ADDRESS\n         MVC   CPPLUPT,X'34'(R15)   SAVE UPT ADDRESS\n         L     R15,X'30'(,R15)      GET ADDRESS OF RELOGON BUFFER\n         L     R15,X'100'(,R15)     GET ADDRESS OF ECT\n         ST    R15,CPPLECT          SAVE ECT ADDRESS\n         XC    CPPLCBUF,CPPLCBUF    NO COMMAND BUFFER\n         LA    R1,OURCPPL\n         ST    R1,ADPLCPPL          SET CPPL ADDRESS\n         L     R1,0(,R8)            ASSUME FIRST PARM IS A CALL PARM\n         LA    R15,2(,R1)           ADDRESS OF PARM TEXT\n         ST    R15,ADPLOPTR         SET ADDRESS OF OPERANDS BUFFER\n         LH    R14,0(,R1)           GET LENGTH OF PARM FIELD\n         STH   R14,ADPLOPLN         SET LENGTH OF VERB OPERAND LIST\nAFTTSOCP DS    0H\n         L     R1,ADPLCPPL\n         MVC   IOPLUPT,CPPLUPT-OURCPPL(R1) PTR TO UPT\n         MVC   IOPLECT,CPPLECT-OURCPPL(R1) PTR TO ECT\n         LA    R0,ECB\n         ST    R0,IOPLECB              PTR TO USER'S ECB\n         LA    R0,1                DEFINE 1 MESSAGE SEGMENT\n         LA    R1,MSGHDR\n         STM   R0,R1,OLD           SET UP OUTPUT LINE DESCRIPTOR\n*\n* INITIALIZE OUTPUT BUFFER TO BLANKS\n*\n         MVI   OURBUFB,C' '        BLANK REQUIRED FOR PUTLINE\n         MVI   OURBUF,C' '\n         MVC   OURBUF+1(OURBUFL-1),OURBUF\n         EJECT\n         LR    R1,R4               SET ABDPL POINTER FOR RETURN\n         B     RETURN0\n         EJECT\nFREEPL   DS    0H                  R1 -> ABDPL TO BE FREED\n         SPACE 1\n         TM    ADPLFLAG-ABDPL(R1),ADPLSYTM  IF VS1/FAKE FLAG SET,\n         BZ    RETURN0             THEN\n         FREEMAIN R,LV=TOTAREAL,A=(1) FREE IT\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 1\nRETURN   DS    0H                  RETURN\n         SPACE 1\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *\n*                                 R1 CONTAINS ABDPL POINTER           *\n***********************************************************************\n         SPACE 1\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         ST    R1,24(,R13)         STORE ABDPL PTR (R1) IN SAVE AREA\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES, ETC.                                                  *\n***********************************************************************\n         SPACE 1\n         LTORG\n         SPACE 3\n         DROP  R12\n         TITLE 'XABDPRT  - VERB EXIT FAKE OUTPUT PRINT ROUTINE'\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nXABDPRT  CSECT\n         SPACE 1\n         SAVE  (14,12),,XABDPRT\n         LR    R12,R15\n         USING XABDPRT,R12\n         LR    R4,R1               SAVE ABDPL ADDRESS\n         USING ABDPL,R4\n         L     R5,ADPLEXT\n         USING ADPLEXTN,R5\n         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA\n         USING OURAREA,R6\n         SPACE 1\n         ST    R13,OURSAVE+4       SET UP SAVE AREA\n         LA    R1,OURSAVE\n         ST    R1,8(,R13)\n         LR    R13,R1\n         SPACE 1\n         TR    OURBUF(OURBUFL),PRTTRTBL  FIX ALL BAD CHARACTERS\n         SPACE 1\n         LA    R0,OURBUFL+1        LENGTH OF OUTPUT BUFFER\n         LA    R1,OURBUFB          THE OUTPUT BUFFER\n         BAL   R14,PUTLINE         Call PUTLINE to display line\n         LTR   R15,R15             IF PUTLINE FAILED\n         BZ    PRTPUTOK            THEN\n         LA    R1,400(,R15)         ABEND WITH PUTLINE RC + 400\n         ABEND (1),DUMP\n         SPACE 1\nPRTPUTOK DS    0H\n         MVI   OURBUF,C' '         CLEAR OUTPUT BUFFER TO BLANKS\n         MVC   OURBUF+1(OURBUFL-1),OURBUF\n         B     PRTRET0\n         EJECT\nPRTRET4  DS    0H                  RETURN WITH CODE 4\n         LA    R15,4               SET RETURN CODE TO FOUR\n         B     PRTRET\nPRTRET0  DS    0H                  RETURN WITH CODE 0\n         XR    R15,R15             SET RETURN CODE TO ZERO\n******** B     PRTRET\nPRTRET   DS    0H                  RETURN\n         SPACE 1\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *\n***********************************************************************\n         SPACE 1\n         L     R13,4(,R13)         RESTORE SAVE AREA POINTER\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nLENPUTL  EQU   *-MPTLIST\n*\nPRTTRTBL DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'.........`:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         TITLE 'PUTLINE SUBROUTINE'\n         SPACE\nPUTLINE  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine displays messages to the TSO user using the TSO        *\n* PUTLINE service routine.  At entry R1 contains the address of the   *\n* message to be displayed, and R0 contains the length of the message. *\n* The message is assumed to begin with a message ID unless            *\n* the first character is blank, in which case the initial blank is    *\n* stripped off by PUTLINE anyhow.                                     *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,PUTLIN14        Save return register\n         LTR   R15,R0              Load length value\n         BNP   PUTLRET             If zero, don't do anything\n         BCTR  R15,0               Else reduce length for execute\n         LTR   R1,R1               If R1 is zero,\n         BZ    PUTIT               then message already set up.\n         EX    R15,MVCPUT          Else move message to work area\nPUTIT    DS    0H\n         LA    R15,5(,R15)         Restore length + 4 for header\n         SLL   R15,16              Shift length into left half of hdr\n         STCM  R15,15,MSGHDR       Put zeroes into right half of hdr\n         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM\nPUTRETRY DS    0H\n         XC    ECB,ECB             Clear ECB\n         PUTLINE PARM=PTLIST,                                          X\n               MF=(E,IOPL),                                            X\n               OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15             If PUTLINE OK\n         BZ    PUTLRET             then return\n         CH    R15,=H'8'           Else if attention interrupt\n         BE    PUTLRET             then OK\n         CH    R15,=H'12'          Else if pending 2nd level message\n         BE    PUTL12              then OK\nPUTERROR DS    0H                  Else PUTLINE error\n         CVD   R15,OURWORK\n         UNPK  OURWORK(2),OURWORK(8)\n         OI    OURWORK+1,X'F0'\n         MVC   PUTWA+1(L'PUTFMSG1),PUTFMSG1\n         MVC   PUTWA+1+L'PUTFMSG1(2),OURWORK\n         MVC   PUTWA+1+L'PUTFMSG1+2(L'PUTFMSG2),PUTFMSG2\n         TPUT  PUTWA+1,L'PUTFMSG1+2+L'PUTFMSG2\n         LA    R1,MSGWA\n         LH    R0,MSGHDR\n         SH    R0,=H'4'\n         TPUT  (1),(0),R           Try to display original message\nPUTLRET  L     R14,PUTLIN14        Restore return register\n         BR    R14                 Return\n*\nPUTL12   DS    0H                  Try putting out pending 2nd level ms\n         XC    ECB,ECB             Clear ecb\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(0,TERM,SINGLE,INFOR)\n         B     PUTRETRY\n*\nMVCPUT   MVC   MSGWA(*-*),0(R1)    Executed\n*\nPUTFMSG1 DC    C'*** XABDGET: PUTLINE error code '\nPUTFMSG2 DC    C' trying to issue the following message:'\n         EJECT\n         LTORG\n         EJECT\n         TITLE 'XABDMEM  - VERB EXIT FAKE MEMORY ACCESS ROUTINE'\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nXABDMEM  CSECT\n         SPACE 1\n         SAVE  (14,12),,XABDMEM\n         LR    R12,R15\n         USING XABDMEM,R12\n         LR    R4,R1               SAVE ABDPL ADDRESS\n         USING ABDPL,R4\n         L     R5,ADPLEXT\n         USING ADPLEXTN,R5\n         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA\n         USING OURAREA,R6\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* FOR NOW, JUST RETURN THE ADDRESS AS IS.                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         B     MEMRET0             RETURN OK, ADDRESS IN R0\n         SPACE 1\n         EJECT\nMEMRET4  DS    0H                  RETURN WITH CODE 4\n         LA    R15,4               SET RETURN CODE TO FOUR\n         B     MEMRET\nMEMRET0  DS    0H                  RETURN WITH CODE 0\n         XR    R15,R15             SET RETURN CODE TO ZERO\n******** B     MEMRET\nMEMRET   DS    0H                  RETURN\n         SPACE 1\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *\n*                                 R0 CONTAINS ADDRESS OF DATA         *\n***********************************************************************\n         SPACE 1\n         STM   R15,R0,16(R13)      STORE VALUES IN SAVE AREA\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n         LTORG\n***********************************************************************\n* MAP OF THE ADDITIONAL AREA FOLLOWING ABDPL AND ADPLEXT              *\n***********************************************************************\n         SPACE 1\nOURAREA  DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nOURSAVE  DS    9D                  SAVE AREA IF NEEDED\nOURWORK  DS    D                   MISCELLANEOUS WORKAREA\nPUTLIN14 DS    A                   PUTLINE SAVE AREA\nOURPLIST DS    0A                  PARAMETER LIST\nOURPARM1 DS    A                   PARAMETER 1\nOURPARM2 DS    A                   PARAMETER 2\nOURPARM3 DS    A                   PARAMETER 3\nOURPARM4 DS    A                   PARAMETER 4\nOURCPPL  DS    0F       TSO COMMAND PROCESSOR PARAMETER LIST\nCPPLCBUF DS    A        PTR TO COMMAND BUFFER\nCPPLUPT  DS    A        PTR TO UPT\nCPPLPSCB DS    A        PTR TO PSCB\nCPPLECT  DS    A        PTR TO ECT\n*\nIOPL     DS    0A\n*\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n*\nECB      DS    F                   ECB for TSO routines\n*\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n*\nOLD      DS    0F                  PUTLINE output line descriptor\nOLDF1    DS    F'1'                Number of message segments\nOLDMSG   DS    A(*-*)              Address of the first message segment\n*\nMSGHDR   DS    F                   PUTLINE message header\nMSGWA    DS    CL256               PUTLINE message work area\nPUTWA    DS    CL256               PUTLINE message work area\n*\n         SPACE 1\nOURBUFB  DS    CL1                 LEADING BLANK REQUIRED FOR XPUTLINE\nOURBUF   DS    CL133               OUTPUT BUFFER\nOURBUFL  EQU   *-OURBUF\n         SPACE 1\n         DS    0D                  ALIGN TO DOUBLEWORD\n         SPACE 2\nOURAREAL EQU   *-OURAREA           LENGTH OF OUR AREA\n         EJECT\n         BLSABDPL\n         EJECT\n***********************************************************************\n* ADDITIONAL EQUATES                                                  *\n***********************************************************************\n         SPACE 1\nTOTAREAL EQU   ADPLLEN+ADPLEXTL+OURAREAL\n         SPACE 1\n         END\n./ ADD NAME=XIPMAP\n         TITLE 'XIPMAP - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN-ABDPL(,R1)  STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA-ABDPL(,R1) GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         EJECT\n         MACRO\n&SYM     GDUMP &REG,&PLACE,&FILL=' ',&STG=DOUBLE\n         AIF   ('&REG' EQ '*').NOSTORE\n&SYM     ST    &REG,&STG               REGISTER CONTENTS TO BE DUMPED\n         AGO   .AFT\n.NOSTORE ANOP\n&SYM     DS    0H                      CONTENTS OF STORAGE TO BE DUMPED\n.AFT     ANOP\n         UNPK  &PLACE.(9),&STG.(5)\n         TR    &PLACE.(8),HEXTBL\n         MVI   &PLACE.+8,C&FILL\n         MEND\n         TITLE 'XIPMAP - IPCS VERB EXIT TO MAP TCB TREE CONTROL BLOCKS'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    TCB POINTER\nR4       EQU   4    ABDPL ADDRESS\nR5       EQU   5    LLS POINTER\nR6       EQU   6    RB POINTER\nR7       EQU   7    CDE POINTER\nR8       EQU   8    DEB POINTER\nR9       EQU   9    DCB POINTER\nR10      EQU   10   JPQ POINTER\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXIPMAP   CSECT\n         SAVE  (14,12),,XIPMAP-&SYSDATE-&SYSTIME\n         LR    R12,R15\n         USING XIPMAP,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ADDRESS OF ABDPL\n         USING ABDPL,R4\n         L     R11,ADPLBUF         ESTABLISH ADDRESSABILITY TO\n         USING LINEDSCT,R11            OUTPUT BUFFER\n         XC    WHRADDR,WHRADDR\n         XC    FIRSTTCB,FIRSTTCB\n         EJECT\n*\n* Instead of using the low-core pointer to get to the TCB,\n* use the ASID to locate the ASCB (via the ASVT) and get the\n* first TCB from there.  In that way, setting the ASID via\n* SETDEF will affect which address space gets mapped.\n*\n*        LA    R3,X'21C'           ADDRESS OF CVTTCBP\n*        GSTOR R3,4,ERRET=BAD21C   GET PSATOLD FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB\n*        LTR   R3,R3               IF POINTER AT 21C IS ZEROES,\n*        BNZ   FINDTOP             THEN...\n*        MVI   LINE,C' '\n*        MVC   LINE+1(L'LINE-1),LINE\n*        MVC   LINE(L'TRY218),TRY218\n*        BAL   R14,OUTPUT\n*        LA    R3,X'218'\n*        GSTOR R3,4,ERRET=BAD218   GET PSATNEW FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB\n*        LTR   R3,R3               IF POINTER AT 218 IS ZEROES,\n*        BNZ   FINDTOP             THEN...\n*        MVI   LINE,C' '\n*        MVC   LINE+1(L'LINE-1),LINE\n*        MVC   LINE(L'TRY224),TRY224\n*        BAL   R14,OUTPUT\n*\n* Try to get ASCB.  Instead of relying on the low-core pointer,\n* use the ASID to locate it via the ASVT.  In that way, setting\n* the ASID with SETDEF will cause this exit to pick up the right one.\n*\n*----------------------------------------------------------------------\n*        LA    R3,X'224'            TRY VIA ASCB\n*        GSTOR R3,4,ERRET=BAD224   GET PSA'S ASCB PTR FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT ASCB\n*        GSTOR R3,X'70',ERRET=BADASCB   GET CURRENT ASCB FROM DUMP\n*----------------------------------------------------------------------\n         L     R3,ADPLCVT          Get CVT pointer\n         LA    R3,X'22C'(,R3)      CVT+22C -> ASVT\n         GSTOR R3,4,ERRET=BADCVT   Get loc of CVT's ASVT ptr from dump\n         L     R3,0(,R3)           Load address of CVT's ASVT pointer\n         LH    R2,ADPLASID         Get the current ASID\n         SLA   R2,2                Multiply by 4 making index into ASVT\n         LA    R3,X'20C'(R2,R3)    Point to ASCB address for this ASID\n         GSTOR R3,4,ERRET=BADASVT  Get ASCB address from dump\n         L     R3,0(,R3)           Load the ASCB address\n         GSTOR R3,X'70',ERRET=BADASCB   Get the ASCB from dump\n         L     R3,X'6C'(,R3)       GET POINTER TO ASXB\n         GSTOR R3,8,ERRET=BADASXB  GET ASXB FROM DUMP\n         L     R3,4(,R3)           GET 1ST TCB ADDRESS FROM ASXB\n         ST    R3,FIRSTTCB         Save it for module findings\nFINDTOP  DS    0H                  SCAN FOR TOP TCB\n         LR    R2,R3               SAVE ACTUAL TCB ADDRESS\n         GSTOR R3,X'8C',ERRET=BADTCB GET CURRENT TCB FROM DUMP\n         ICM   R15,15,X'84'(R3)    ADDRESS OF MOTHER TCB\n         BZ    USETCB              IF NONE, THIS IS THE TOP TCB\n         LR    R3,R15              IF THERE IS A MOTHER,\n         B     FINDTOP             THEN GO FIND ITS MOTHER OR USE IT\nUSETCB   DS    0H                  START WITH THIS TCB\n         LR    R3,R2               GET ACTUAL TCB ADDRESS AGAIN\n         SPACE 1\n*******                            (WE DON'T DO THIS ANY MORE)\n*******  L     R3,X'7C'(,R3)       GET POINTER TO TCBJSTCB\n*******\n*\n         BAL   R14,OUTPUT          Print a blank line\n         MVC   LINE(L'HIMSG),HIMSG\n         LH    R2,ADPLASID\n         GDUMP R2,LINE+L'HIMSG     FORMAT AND PRINT ASID\n         BAL   R14,OUTPUT          PRINT \"HI THERE\" MESSAGE\n         BAL   R14,OUTPUT          Print a blank line\n*\nDOIT     DS    0H\n         BAL   R14,PROCESS\n         ICM   R3,15,COPYTCB+X'88' DAUGHTER TCB\n         BNZ   DOIT\nNODTR    DS    0H                  ELSE\n         ICM   R3,15,COPYTCB+X'80' SISTER TCB\n         BNZ   DOIT\nNOSISTER DS    0H                  ELSE\n         ICM   R3,15,COPYTCB+X'84' MOTHER TCB\n         BZ    NOMORE              IF NONE, FINISHED WITH TCB TREE\n         GSTOR R3,X'8C',ERRET=BADTCB ELSE GET MOTHER TCB FROM DUMP\n         MVC   COPYTCB(X'8C'),0(R3) SAVE TCB STORAGE\n         B     NODTR               PROCESS ITS SISTER, ETC.\nNOMORE   DS    0H\n         B     RETURN0\n         EJECT\nPROCESS  DS    0H                  R3 = ADDRESS OF TCB BEING PROCESSED\n         SPACE\n         ST    R14,PRCSSAVE        SAVE RETURN REGISTER\n         BAL   R14,OUTPUT          PRINT A BLANK LINE\n         MVC   LINE(L'TCBMSG),TCBMSG\n         GDUMP R3,LINE+L'TCBMSG    FORMAT AND PRINT TCB ADDRESS\n         BAL   R14,OUTPUT          PRINT \"PROCESSING TCB\"\n         GSTOR R3,256,ERRET=BADTCB GET TCB ITSELF FROM DUMP\n         MVC   COPYTCB(256),0(R3)  SAVE TCB STORAGE FOR FUTURE USE\n         ICM   R6,15,COPYTCB+X'10' PICK UP COMPLETION CODE\n         BZ    NOTCBCMP            IF THERE IS ONE, THEN...\n         MVC   LINE(L'CMPMSG),CMPMSG\n         GDUMP R6,LINE+L'CMPMSG               FORMAT IT AND PRINT IT\n         MVC   LINE+L'CMPMSG+9(L'RTM2MSG),RTM2MSG\n         ICM   R6,15,COPYTCB+X'E0'            PICK UP ADDRESS OF RTM2WA\n         GDUMP R6,LINE+L'CMPMSG+9+L'RTM2MSG   FORMAT IT AND PRINT IT\n         BAL   R14,OUTPUT          PRINT COMPLETION CODE\nNOTCBCMP DS    0H\n         L     R6,COPYTCB+0        ADDRESS OF RB\n         MVC   LINE(L'RBMSG),RBMSG\n         GDUMP R6,LINE+L'RBMSG     FORMAT AND PRINT RB ADDRESS\n         BAL   R14,OUTPUT          PRINT \"PROCESSING RB\"\nRBLOOP   DS    0H\n         LR    R2,R6               SAVE TRUE RB ADDRESS\n         SH    R6,=H'32'           POINT TO RB PREFIX\n         BM    BADRB               IF MAKES IT GO NEGATIVE, BAD ADDR\n         GSTOR R6,96,ERRET=BADRB   GET RB FROM DUMP\n         MVC   RBPREFIX(96),0(R6)  MAKE A COPY OF IT\n         GDUMP R2,LINE+0           FORMAT AND PRINT RB ADDRESS\n         TM    COPYRB+X'0A',X'C0'  CHECK RB TYPE\n         BZ    PRB\n         BO    SVRB\n         LA    R1,=CL8'(IRB)'\n         B     RBTYPE\nSVRB     LA    R1,=CL8'(SVRB)'\nRBTYPE   DS    0H\n         MVC   LINE+10(8),0(R1)    MOVE RB TYPE\n         B     RBOUT\nPRB      DS    0H\n         XR    R7,R7\n         ICM   R7,7,COPYRB+X'0D'   ADDRESS OF RBCDE\n         BNZ   GOTACDE             IF ZERO, THEN...\n         TM    COPYRB+X'0C',X'04'   IF REQUESTED BY SYNCH MACRO\n         BZ    NOCDE                 THEN\n         MVC   LINE+10(8),=CL8'(SYNCH)'   SAY SO\n         B     RBOUT                 ELSE\nNOCDE    MVC   LINE+10(8),=CL8'(NO CDE)'  JUST SAY NO CDE\n         B     RBOUT\nGOTACDE  DS    0H\n         MVC   LINE+10(8),=CL8'(*N/A*)' IN CASE CDE NOT AVAILABLE\n         GSTOR R7,32,ERRET=RBOUT   GET CDE FROM DUMP\n         MVC   LINE+10(8),CDNAME-CDENTRY(R7) CDE NAME\nRBOUT    DS    0H\n         MVC   LINE+21(4),=C'INT='\n         UNPK  LINE+25(3),COPYRB-1(2) INTERRUPT CODE\n         TR    LINE+25(2),HEXTBL\n         MVI   LINE+27,C' '\n         MVC   LINE+29(4),=C'PSW='\n         UNPK  LINE+33(9),COPYRB+X'10'(5) LEFT HALF OF RBOPSW\n         TR    LINE+33(8),HEXTBL\n         MVI   LINE+41,C' '\n         UNPK  LINE+42(9),COPYRB+X'14'(5) RIGHT HALF OF RBOPSW\n         TR    LINE+42(8),HEXTBL\n         MVI   LINE+50,C' '\n         L     R0,COPYRB+X'14'     GET RIGHT HALF OF PSW\n         BAL   R14,FINDMOD         LOCATE MODULE WHERE IT IS\n         BAL   R14,OUTPUT          PRINT CDE NAME TO IDENTIFY RB\nRBNEXT   DS    0H\n         TM    COPYRB+X'0B',X'80'  IF NEXTRB POINTS TO TCB\n         BO    ENDRB               THEN NO MORE RB'S. ELSE\n         XR    R6,R6\n         ICM   R6,7,COPYRB+X'1D'   ADDRESS OF NEXT RB\n         B     RBLOOP\nBADRB    DS    0H                  RB STORAGE NOT AVAILABLE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'RBERRMSG),RBERRMSG\n         GDUMP R6,LINE+L'RBERRMSG  FORMAT AND PRINT ADDRESS OF RB\n         BAL   R14,OUTPUT\nENDRB    DS    0H\n         ICM   R10,15,COPYTCB+X'2C' ADDRESS OF JOB PACK QUEUE\n         BZ    ENDCDE\n         MVC   LINE(L'JPQMSG),JPQMSG\n         BAL   R14,OUTPUT          PRINT \"MAPPING JOB PACK QUEUE\"\nCDELOOP  DS    0H\n         BAL   R14,DUMPCDE         WRITE OUT CDE INFO\n         ICM   R10,15,0(R10)\n         BNZ   CDELOOP\nENDCDE   DS    0H\nTCB2LOOP DS    0H\n         ICM   R5,15,COPYTCB+X'24' ADDRESS OF LOAD LIST ELEMENTS\n         BZ    ENDLLS\n         MVC   LINE(L'LLSMSG),LLSMSG\n         BAL   R14,OUTPUT          PRINT \"MAPPING LOAD LIST\"\nLLSLOOP  DS    0H\n         GSTOR R5,16,ERRET=BADLLS  GET LLS FROM DUMP\n         L     R2,0(,R5)           SAVE ADDRESS OF NEXT LLS\n         L     R10,4(,R5)          CDE FOR LOAD LIST ENTRY\n         BAL   R14,DUMPCDE         WRITE OUT CDE INFO\nNEXTLLS  DS    0H\n         LTR   R5,R2               GET ADDRESS OF NEXT LLS\n         BZ    ENDLLS\n         B     LLSLOOP\nBADLLS   DS    0H                  ERROR ACCESSING LLS\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'LLSERMSG),LLSERMSG\n         GDUMP R5,LINE+L'LLSERMSG\n         BAL   R14,OUTPUT\n         SPACE 1\nENDLLS   DS    0H\n         ICM   R8,15,COPYTCB+X'08' ADDRESS OF DEB\n         BNZ   GOTDEBS\n         MVC   LINE(L'NODEBS),NODEBS\n         BAL   R14,OUTPUT          PRINT \"NO OPEN DATA SETS\"\n         B     ENDDEB\nGOTDEBS  DS    0H\n         MVC   LINE(L'DEBMSG),DEBMSG\n         GDUMP R8,LINE+L'DEBMSG    FORMAT AND PRINT ADDRESS OF DEB\n         BAL   R14,OUTPUT          PRINT \"MAPPING DEB CHAIN\"\nDEBLOOP  DS    0H\n         MVC   LINE(4),=C'DEB='\n         GDUMP R8,LINE+4           FORMAT AND PRINT ADDRESS OF DEB\n         GSTOR R8,32,ERRET=BADDEB  GET DEB FROM DUMP\n         MVC   COPYDEB(32),0(R8)   MAKE A COPY OF IT\n         L     R9,COPYDEB+X'18'    ADDRESS OF DCB FOR THIS DEB\n         N     R9,=X'00FFFFFF'     CLEAR HIGH ORDER BYTE\n         MVC   LINE+14(4),=C'DCB='\n         GDUMP R9,LINE+18          FORMAT AND PRINT ADDRESS OF DCB\n         GSTOR R9,X'30',ERRET=BADDCB GET DCB FROM DUMP\n         L     R2,COPYTCB+X'0C'    ADDRESS OF TIOT\n         AH    R2,X'28'(,R9)       ADD TIOT OFFSET FROM DCB\n         GSTOR R2,20,ERRET=BADTIOT GET TIOT ENTRY FROM DUMP\n         MVC   LINE+28(8),4(R2)    DDNAME FROM TIOT\n         MVI   LINE+36,C' '\n         ICM   R9,7,X'C'(R2)       POINTER TO JFCB FROM TIOT\n         LA    R9,X'10'(,R9)       ADDRESS OF JFCB\n         GSTOR R9,176,ERRET=BADJFCB GET JFCB FROM DUMP\n         MVC   LINE+37(44),0(R9)   DSNAME\n         LA    R1,LINE+37+44-1\nDSNLOOP  CLI   0(R1),C' '\n         BNE   DSNEND\n         BCTR  R1,0\n         B     DSNLOOP\nDSNEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME\n         CLI   44(R9),C' '         IF THERE IS A MEMBER NAME IN JFCB\n         BE    NOMEMBER            THEN\n         MVI   1(R1),C'('\n         MVC   2(8,R1),44(R9)\n         LA    R1,9(,R1)\nMEMLOOP  CLI   0(R1),C' '\n         BNE   MEMEND\n         BCTR  R1,0\n         B     MEMLOOP\nMEMEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN MEMBER\n         LA    R1,1(,R1)\n         MVI   0(R1),C')'\nNOMEMBER DS    0H                  R1 POINTS TO LAST NONBLANK\n         TM    COPYDEB+X'08',X'01' IF CONCATENATED DATA SETS,\n         BZ    PRINTDEB            THEN...\n         MVC   2(7,R1),=C' ET AL.'  LET ME KNOW\n         B     PRINTDEB\nBADDCB   DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+14(L'DCBERMSG),DCBERMSG\n         GDUMP R9,LINE+14+L'DCBERMSG\n         B     PRINTDEB\nBADTIOT  DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+28(L'TIOERMSG),TIOERMSG\n         GDUMP R2,LINE+28+L'TIOERMSG\n         B     PRINTDEB\nBADJFCB  DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+37(L'JFERRMSG),JFERRMSG\n         GDUMP R9,LINE+37+L'JFERRMSG\n         B     PRINTDEB\nPRINTDEB DS    0H\n         BAL   R14,OUTPUT          PRINT DEB=ADDR DCB=ADDR DDNAME\n         B     NEXTDEB             GO TO NEXT DEB\nBADOTHER DS    0H                  ERROR ACCESSING STORAGE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ERRMSG),ERRMSG\n         BAL   R14,OUTPUT\n******** B     NEXTDEB\nNEXTDEB  DS    0H\n         XR    R8,R8\n         ICM   R8,7,COPYDEB+5      ADDRESS OF NEXT DEB\n         BZ    ENDDEB\n         B     DEBLOOP\nBADDEB   DS    0H                  ERROR ACCESSING DEB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'DEBERMSG),DEBERMSG\n         GDUMP R8,LINE+L'DEBERMSG\n         BAL   R14,OUTPUT\nENDDEB   DS    0H\nENDPROC  DS    0H\n         L     R14,PRCSSAVE        RETURN\n         BR    R14\n         EJECT\nDUMPCDE  DS    0H                  THIS ROUTINE DUMPS A CDE\n*\n* THIS SUBROUTINE FORMATS AND WRITES OUT CDE INFORMATION,\n* ON ENTRY R10 CONTAINS THE ADDRESS OF THE CDE.\n*\n         SPACE 1\n         ST    R14,DCDESAVE        SAVE RETURN REGISTER\n         ST    R10,DOUBLE          CDE ADDRESS\n         GSTOR R10,32,ERRET=BADCDE GET CDE FROM DUMP\n         USING CDENTRY,R10\n         GDUMP *,LNCDADDR          FORMAT AND PRINT ADDRESS OF CDE\n         MVC   LNCDNAME(8),CDNAME   CDE NAME\n         MVC   LNCDEPEQ(3),=C'EP='\n         GDUMP *,LNCDEPA,STG=CDENTPT ENTRY POINT FROM CDE\n         TM    CDATTR,CDREN\n         BZ    NOTRENT\n         MVC   LNCDRENT,=C'RENT'\nNOTRENT  TM    CDATTR,CDSER\n         BZ    NOTREUS\n         MVC   LNCDREUS,=C'REUS'\nNOTREUS  TM    CDATTR2,CDEANYM\n         BZ    NOTANY\n         MVC   LNCDANY,=C'ANY'\nNOTANY   TM    CDATTR2,CDOLY\n         BZ    NOTOVLY\n         MVC   LNCDOVLY,=C'OVLY'\nNOTOVLY  TM    CDATTR2,CDSYSLIB\n         BZ    NOTSYSL\n         MVC   LNCDSYSL,=C'SYSLIB'\nNOTSYSL  TM    CDATTR2,CDAUTH\n         BZ    NOTAUTH\n         MVC   LNCDAUTH,=C'AUTH'\nNOTAUTH  DS    0H\n         B     OUTCDE\nBADCDE   DS    0H                  CDE STORAGE NOT AVAILABLE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CDERRMSG),CDERRMSG\n         GDUMP R10,LINE+L'CDERRMSG FORMAT AND PRINT CDE ADDRESS\nOUTCDE   BAL   R14,OUTPUT          PRINT CDE MODULE NAME\n         L     R14,DCDESAVE        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         EJECT\nBAD21C   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER21CMSG),ER21CMSG\n         GDUMP R3,LINE+L'ER21CMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBAD218   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER218MSG),ER218MSG\n         GDUMP R3,LINE+L'ER218MSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBAD224   DS    0H                  ERROR ACCESSING ASCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER224MSG),ER224MSG\n         GDUMP R3,LINE+L'ER224MSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADTCB   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'TCBERMSG),TCBERMSG\n         GDUMP R3,LINE+L'TCBERMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADASCB  DS    0H                  ERROR ACCESSING ASCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASCBEMSG),ASCBEMSG\n         GDUMP R3,LINE+L'ASCBEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADASXB  DS    0H                  ERROR ACCESSING ASXB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASXBEMSG),ASXBEMSG\n         GDUMP R3,LINE+L'ASXBEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADCVT   DS    0H                  ERROR ACCESSING ASXB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CVTEMSG),CVTEMSG\n         GDUMP R3,LINE+L'CVTEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADCASVT DS    0H                  ERROR ACCESSING ASXB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CASVEMSG),CASVEMSG\n         GDUMP R3,LINE+L'CASVEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADASVT  DS    0H                  ERROR ACCESSING ASXB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASVTEMSG),ASVTEMSG\n         GDUMP R3,LINE+L'ASVTEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ERRMSG),ERRMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nFINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME\n*                                  R0 CONTAINS ADDRESS TO SEARCH ON\n         ST    R14,FMSAVE\n         LTR   R0,R0               IF AMODE 31 BIT IS NOT ON\n         BM    FMASIS              THEN\n         N     R0,=X'00FFFFFF'      CLEAR HIGH-ORDER BYTE FOR 24-BIT AD\nFMASIS   DS    0H\n         ICM   R15,15,WHRADDR\n         BNZ   FMGOTWHR\n         ST    R0,FMWORK\n         LOAD  EPLOC==CL8'XIPSWHR',ERRET=FMNF\n         ST    R0,WHRADDR\n         LR    R15,R0\n         L     R0,FMWORK\nFMGOTWHR DS    0H\n         L     R14,FIRSTTCB        Get address of first TCB\n         ST    R14,ADPLCOM1        Set first-TCB pointer for XIPSWHR\n         LR    R1,R4               POINT TO ABDPL\n         BASSM R14,R15             CALL XIPSWHR TO GET MODULE NAME\n         CLI   ADPLFMT1,C' '       IF NOT FOUND...\n         BE    FMNF\n         CLI   ADPLFMT1,C'E'       IF STORAGE ERROR...\n         BE    FMERR\n         MVC   LINE+52(16),ADPLCOM1\n         B     FMRET\nFMERR    DS    0H\n         MVC   LINE+52(16),=CL16'(STORAGE ERROR) '\n         B     FMRET\nFMNF     DS    0H\n         MVC   LINE+52(16),=CL16'(UNKNOWN)       '\nFMRET    DS    0H\n         L     R14,FMSAVE\n         BR    R14\n         EJECT\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT-ABDPL(,R1) GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15\n         BNZ   RETURN0\n         L     R11,ADPLBUF-ABDPL(,R1)  POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         ICM   R15,R15,WHRADDR\n         BZ    NODELETE\n         DELETE EPLOC==CL8'XIPSWHR'\nNODELETE DS    0H\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nHIMSG    DC    C'                 MAP FOR ASID '\nTCBMSG   DC    C'*** P R O C E S S I N G   T C B *** - '\nCMPMSG   DC    C'*** COMPCODE='\nRTM2MSG  DC    C' RTWA AT '\nRBMSG    DC    C'---MAPPING RBS - '\nJPQMSG   DC    C'---MAPPING CDES FROM JOB PACK QUEUE'\nLLSMSG   DC    C'---MAPPING CDES FROM LOAD LIST'\nNODEBS   DC    C'---TASK HAS NO OPEN DATA SETS'\nDEBMSG   DC    C'---MAPPING DEBS - '\nTRY218   DC    C'PSATOLD TCB POINTER IS ZEROES, USING PSATNEW POINTER'\nTRY224   DC    C'PSATNEW TCB POINTER IS ZEROES, USING ASXB POINTER'\nERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'\nER21CMSG DC    C'ERROR - PSATOLD UNAVAILABLE'\nER218MSG DC    C'ERROR - PSATNEW UNAVAILABLE'\nER224MSG DC    C'ERROR - ASCB UNAVAILABLE'\nTCBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR TCB AT '\nASCBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASCB AT '\nASXBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASXB AT '\nRBERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR RB AT '\nCDERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR CDE AT '\nLLSERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR LLS AT '\nDEBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR DEB AT '\nDCBERMSG DC    C'DCB UNAVAILABLE AT '\nTIOERMSG DC    C'TIOT ENTRY UNAVAILABLE AT '\nJFERRMSG DC    C'JFCB UNAVAILABLE AT '\nCVTEMSG  DC    C'CVT ASVT POINTER UNAVAILABLE AT '\nCASVEMSG DC    C'ASVT ADDRESS UNAVAILABLE AT '\nASVTEMSG DC    C'ASVT ASCB POINTER UNAVAILABLE AT '\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nPRCSSAVE DS    A                   SAVE AREA FOR PROCESS SUBROUTINE\nDCDESAVE DS    A                   SAVE AREA FOR DUMPCDE SUBROUTINE\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nFMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE\nFMWORK   DS    A                   WORK AREA FOR FINDMOD SUBROUTINE\nWHRADDR  DS    A                   ADDRESS OF XIPSWHR LOAD MODULE\nFIRSTTCB DS    A                   Address of first TCB to search\n         SPACE 1\nCOPYTCB  DS    CL256               COPY OF MOST OF TCB\nCOPYDEB  DS    CL32                COPY OF MOST OF DEB\nRBPREFIX DS    CL32                COPY OF RB PREFIX\nCOPYRB   DS    CL64                COPY OF MOST OF RB\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINEDSCT DSECT ,                   MAP THE OUTPUT BUFFER\nLINE     DS    CL132               WORD AREA FOR OUTPUT LINES\n         ORG   LINE\nLNCDADDR DS    CL8                 ADDRESS OF CONTROL BLOCK\n         DS    CL2\nLNCDNAME DS    CL8                 NAME\n         DS    CL3\nLNCDEPEQ DS    C'EP='              \"EP=\"\nLNCDEPA  DS    CL8                 ENTRY POINT\n         DS    CL3                 FOLLOWED BY ATTRIBUTES\nLNCDRENT DS    C'RENT'\n         DS    CL1\nLNCDREUS DS    C'REUS'\n         DS    CL1\nLNCDANY  DS    C'ANY'\n         DS    CL1\nLNCDOVLY DS    C'OVLY'\n         DS    CL1\nLNCDSYSL DS    C'SYSLIB'\n         DS    CL1\nLNCDAUTH DS    C'AUTH'\n         DS    CL1\n         ORG\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         BLSABDPL\n         SPACE 1\n         IHACDE\n         SPACE 1\n         END\n./ ADD NAME=XIPSWHR\n         TITLE 'XIPSWHR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'XIPSWHR - VERB EXIT SUBROUTINE TO LOCATE AN ADDRESS'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE IS INVOKED FROM IPCS VERB EXITS TO RETURN           *\n* INFORMATION ABOUT AN ADDRESS.                                       *\n*                                                                     *\n* ON ENTRY REGISTER 1 POINTS TO THE ABDPL (EXIT PARAMETER LIST),      *\n*      AND REGISTER 0 CONTAINS THE ADDRESS TO BE SEARCHED FOR.        *\n*                                                                     *\n* In addition, the following field must be filled in by the caller:   *\n*                                                                     *\n*    ADPLCOM1 - 4 bytes - the address of the first TCB to search,     *\n*                         or zeroes if not known.                     *\n*                                                                     *\n* ON RETURN THE FOLLOWING FIELDS OF THE PARAMETER LIST ARE FILLED:    *\n*                                                                     *\n*    ADPLCOM1 - 8 BYTES - THE NAME OF THE MODULE IT WAS FOUND IN.     *\n*                                                                     *\n*    ADPLCOM3 - 8 BYTES - EBCDIC REPRESENTATION OF THE OFFSET,        *\n*                         INCLUDING LEADING PLUS SIGN.                *\n*                                                                     *\n*    ADPLFMT1 - ONE OF THE FOLLOWING 4-CHARACTER VALUES:              *\n*                                                                     *\n*    \"JPA \"  -  THE ADDRESS IS IN A MODULE IN THE JOB PACK AREA.      *\n*    \"PLPA\"  -  THE ADDRESS IS IN A PAGEABLE LINK PACK AREA MODULE.   *\n*    \"MLPA\"  -  THE ADDRESS IS IN A MODULE IN THE MLPA.               *\n*    \"NUC \"  -  THE ADDRESS IS IN THE NUCLEUS.                        *\n*    \"ERR \"  -  A STORAGE ERROR OCCURRED TRYING TO LOCATE IT.         *\n*    \"    \"  -  BLANK IF THE ADDRESS WAS NOT FOUND.                   *\n*                                                                     *\n*    ADPLFMT2 - THE BINARY VALUE OF THE OFFSET.                       *\n*                                                                     *\n* NOTE: THIS ROUTINE MUST BE INVOKED VIA LINK OR LOAD/BASSM,          *\n*       SINCE IT RUNS IN AMODE 31.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3    DUMP STORAGE ACCESS REGISTER\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    INPUT ADDRESS TO BE SEARCHED FOR\nR6       EQU   6    POINTER TO TCB\nR7       EQU   7    POINTER TO CDE\nR8       EQU   8    USED IN NUCMAP SCANNING\nR9       EQU   9    USED IN NUCMAP SCANNING\nR10      EQU   10   .\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXIPSWHR  CSECT\nXIPSWHR  AMODE 31\nXIPSWHR  RMODE 24\n         SAVE  (14,12),,XIPSWHR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XIPSWHR,R12\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LR    R5,R0               SAVE INPUT ADDRESS PARAMETER\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         EJECT\n         N     R5,=X'7FFFFFFF'     CLEAR HIGH ORDER BIT OF ADDRESS\n         MVC   ADPLFMT1(4),=C'    '\n         EJECT\n*\n* If a TCB address has been provided by the caller, it will be in\n* the ADPLCOM1 field and nonzero.  In this case, use that as the\n* first TCB to search, since that should have been chosen to work\n* with the current ASID.\n*\n         ICM   R6,15,ADPLCOM1      Get communication word TCB address\n         BNZ   GOT1TCB             If provided, skip TCB search\n         EJECT\n*\n* We don't do this anymore.  Must go by current ASID.\n*\n* FIRST SEARCH THE JOB PACK AREA.\n*        SPACE 1\n*        LA    R6,X'21C'           ADDRESS OF CVTTCBP\n*        GSTOR R6,4                GET PSATOLD FROM DUMP\n*        L     R6,0(,R6)           ADDRESS OF CURRENT TCB\n*        LTR   R6,R6               IF POINTER AT 21C IS ZEROES,\n*        BNZ   GOT1TCB             THEN...\n*        LA    R6,X'218'\n*        GSTOR R6,4                GET PSATNEW FROM DUMP\n*        L     R6,0(,R6)           ADDRESS OF CURRENT TCB\n*        LTR   R6,R6               IF POINTER AT 218 IS ZEROES,\n*        BNZ   GOT1TCB             THEN...\n*        LA    R6,X'224'            TRY VIA ASCB\n*        GSTOR R6,4                GET PSA'S ASCB PTR FROM DUMP\n*        L     R6,0(,R6)           ADDRESS OF CURRENT ASCB\n*        GSTOR R6,X'70'            GET CURRENT ASCB FROM DUMP\n*        L     R6,X'6C'(,R6)       GET POINTER TO ASXB\n*        GSTOR R6,8                GET ASXB FROM DUMP\n*        L     R6,4(,R6)           GET 1ST TCB ADDRESS FROM ASXB\n*\n         L     R6,ADPLCVT          Get CVT pointer\n         LA    R6,X'22C'(,R6)      CVT+22C -> ASVT\n         GSTOR R6,4                Get loc of CVT's ASVT ptr from dump\n         L     R6,0(,R6)           Load address of CVT's ASVT pointer\n         LH    R2,ADPLASID         Get the current ASID\n         SLA   R2,2                Multiply by 4 making index into ASVT\n         LA    R6,X'20C'(R2,R6)    Point to ASCB address for this ASID\n         GSTOR R6,4                Get ASCB address from dump\n         L     R6,0(,R6)           Load the ASCB address\n         GSTOR R6,X'70'            Get the ASCB from dump\n         L     R6,X'6C'(,R6)       GET POINTER TO ASXB\n         GSTOR R6,8                GET ASXB FROM DUMP\n         L     R6,4(,R6)           GET 1ST TCB ADDRESS FROM ASXB\n*\nGOT1TCB  DS    0H                  SCAN FOR TOP TCB\n         SPACE 1\n         GSTOR R6,X'A0'            GET MOST OF THIS TCB FROM DUMP\n         USING TCB,R6\n*\n* WE DON'T GO DIRECTLY TO THE JOB STEP TCB ANY MORE, SINCE UNDER\n* PIE/SESSIONS THERE MAY BE MORE THAN ONE.  INSTEAD, WE GO TO THE\n* TOP OF THE TCB TREE EVERY TIME, AND THEN DESCEND LEVELS UNTIL\n* WE FIND THE LEVEL WITH THE JOB STEP TCB'S.  ALL THE SISTERS IN\n* THAT LEVEL ARE THEN PROCESSED.\n*\n****     LA    R6,TCBJSTCB         POINTER TO JOB STEP TCB\n****     GSTOR R6,4                GET TCBJSTCB FROM DUMP\n****     L     R6,0(,R6)           ADDRESS OF JOB STEP TCB\n****     GSTOR R6,X'A0'            GET MOST OF JSTCB FROM DUMP\n****     L     R7,TCBJPQ           ADDRESS OF FIRST CDE IN JOB PACK Q\n****     LTR   R7,R7               IF NO CDE'S IN JOB PACK QUEUE\n****     BNZ   LOOPCDE             THEN...\n*\n* IF JSTCB HAS NO JOB PACK QUEUE, THIS MAY BE A DUMP OF JES2 OR\n* SOMETHING WHERE THE JSTCB IS NOT THE TCB WITH THE JPQ.  WE MUST\n* THEN SEARCH FOR THE TCB WITH THE GOODS.\n*\nFINDTOP  DS    0H\n         L     R7,TCBOTC           GET ADDRESS OF MOTHER TCB\n         LTR   R7,R7               IF ZERO, THEN...\n         BZ    TRYJPQ               THIS IS THE TOP TCB\n         LR    R6,R7               ELSE GET ADDRESS OF THIS TCB\n         GSTOR R6,X'A0'            GET MOST OF THIS TCB FROM DUMP\n         B     FINDTOP             CONTINUE SEARCHING FOR TOP TCB\nTRYJPQ   DS    0H                  R6 --> TOP TCB FROM DUMP\n         MVC   COPYTCB(X'A0'),0(R6)\n         LA    R6,COPYTCB\n         L     R7,TCBJPQ           OK, TRY THE JOB PACK QUEUE HERE\n         LTR   R7,R7               IF WE GOT ONE,\n         BNZ   LOOPCDE             THEN GO TO SCAN IT.\n         L     R7,TCBLTC           ELSE GET NEXT DAUGHTER TASK\n         LTR   R7,R7               IF NONE,\n         BZ    ENDCDE              THEN GIVE UP, NO JOB PACK FOUND\n         LR    R6,R7               ELSE...\n         GSTOR R6,X'A0'            GET IT FROM THE DUMP\n         B     TRYJPQ              AND TRY IT AGAIN.\nLOOPCDE  DS    0H                  LOOP THROUGH CDE'S\n         LTR   R7,R7               UNTIL NO MORE\n         BZ    ENDCDE\n         GSTOR R7,32               GET CDE FROM DUMP\n         MVC   COPYCDE(32),0(R7)   COPY INTO OUR WORK AREA\n         LA    R7,COPYCDE\n         USING CDENTRY,R7\n         TM    CDATTR,CDMIN        IF THIS IS A MINOR CDE,\n         BO    CONTCDE             THEN SKIP IT\n         L     R3,CDXLMJP          ELSE GET ADDRESS OF EXTENT LIST\n         LTR   R3,R3               IF NONE\n         BZ    CONTCDE             THEN SKIP THIS CDE, GO TO NEXT ONE\n         GSTOR R3,16               GET XTLST FROM DUMP\n         USING XTLST,R3\n         L     R0,XTLMSBAA         GET LOAD POINT\n         N     R0,=X'7FFFFFFF'\n         XR    R1,R1\n         ICM   R1,7,XTLMSBLN       GET MODULE LENGTH\n         ALR   R1,R0               CONVERT IT TO LOAD END POINT\n         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT\n         BH    CONTCDE             THEN THIS IS NOT THE ONE\n         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END\n         BNH   CONTCDE             THEN THIS IS NOT THE ONE\n         LR    R2,R5               ELSE ADDRESS MINUS LOAD POINT\n         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE\n         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'JPA ' TELL WHERE IT WAS FOUND\n         MVC   ADPLCOM1(8),CDNAME   PUT MODULE NAME IN RETURN FIELD\n         B     FORMAT              GO TO FORMAT OFFSET AND RETURN\nCONTCDE  DS    0H\n         L     R7,CDCHAIN          GET ADDRESS OF NEXT CDE IN CHAIN\n         B     LOOPCDE             CONTINUE LOOPING\nENDCDE   DS    0H                  SCANNED ALL OF JPQ - NOT FOUND YET\n         SPACE 1\nJSSISTER DS    0H\n         L     R7,TCBNTC           GET SISTER TASK\n         LTR   R7,R7               IF NONE,\n         BZ    NOSISTER            THEN THROUGH WITH SISTER TASKS\n         LR    R6,R7               ELSE...\n         GSTOR R6,X'A0'            GET IT FROM THE DUMP\n         MVC   COPYTCB(X'A0'),0(R6)\n         LA    R6,COPYTCB\n         L     R7,TCBJPQ           TRY THE JOB PACK QUEUE HERE\n         LTR   R7,R7               IF WE GOT ONE,\n         BNZ   LOOPCDE             THEN GO TO SCAN IT\n         B     JSSISTER            ELSE TRY NEXT SISTER\nNOSISTER DS    0H\n         L     R7,TCBLTC           GET NEXT DAUGHTER TASK\n         LTR   R7,R7               IF NONE,\n         BZ    ENDJSTS             THEN GIVE UP, NO JOB PACK FOUND\n         LR    R6,R7               ELSE...\n         GSTOR R6,X'A0'            GET IT FROM THE DUMP\n         B     TRYJPQ              AND TRY IT AGAIN.\nENDJSTS  DS    0H                  NO MORE JOB STEP TCB'S\n         EJECT\n* THEN SEARCH THE LINK PACK AREA.\n         SPACE 1\n         L     R3,ADPLCVT          ADDRESS OF CVT\n         USING CVT,R3\n         LA    R3,CVTLPDIR         POINTER TO LPA DIRECTORY\n         GSTOR R3,3                GET CVTLPDIR FROM DUMP\n         XR    R7,R7\n         ICM   R7,7,0(R3)          ADDRESS OF LPA DIRECTORY\n         USING LPDE,R7\nLOOPLPDE DS    0H                  LOOP THROUGH LPDE'S\n         LA    R2,LPDEXTAD+4       GET TRUE ADDR OF NEXT LPDE IN CHAIN\n         GSTOR R7,40               GET LPA DIRECTORY FROM DMP\n         ICM   R0,15,LPDENTP       UNTIL NO MORE\n         BZ    ENDLPDE\n         TM    LPDEATTR,LPDEMIN    IF THIS IS A MINOR LPDE,\n         BO    CONTLPDE            THEN SKIP IT\n         L     R0,LPDEXTAD         GET LOAD POINT\n         N     R0,=X'7FFFFFFF'\n         ICM   R1,15,LPDEXTLN      GET MODULE LENGTH\n         ALR   R1,R0               CONVERT IT TO LOAD END POINT\n         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT\n         BH    CONTLPDE            THEN THIS IS NOT THE ONE\n         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END\n         BNH   CONTLPDE            THEN THIS IS NOT THE ONE\n         LR    R1,R5               ELSE ADDRESS MINUS LOAD POINT\n         SR    R1,R0                GIVES OFFSET WITHIN PLPA MODULE\n         ST    R1,ADPLFMT2         PUT OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'PLPA' TELL WHERE IT WAS FOUND\n         MVC   ADPLCOM1(8),LPDENAME PUT MODULE NAME IN RETURN FIELD\n         B     FORMAT\nCONTLPDE DS    0H\n         LR    R7,R2               GET (SAVED) ADDRESS OF NEXT LPDE\n         B     LOOPLPDE            CONTINUE LOOPING\nENDLPDE  DS    0H                  SCANNED ALL PLPA - NOT FOUND YET\n         EJECT\n* THEN SEARCH THE MLPA.\n         SPACE 1\n         L     R3,ADPLCVT          ADDRESS OF CVT\n         USING CVT,R3\n         LA    R3,CVTQLPAQ         POINTER TO MLPA CDE'S\n         GSTOR R3,4                GET ADDR OF 1ST LPAQ CDE FROM DUMP\n         L     R3,0(,R3)           ADDRESS OF POINTER TO 1ST LPA Q CDE\n         GSTOR R3,4                GET ADDR OF 1ST LPAQ CDE FROM DUMP\n         L     R7,0(,R3)           ADDRESS OF FIRST CDE IN LPA Q\nLOOPMLPA DS    0H                  LOOP THROUGH CDE'S\n         LTR   R7,R7               UNTIL NO MORE\n         BZ    ENDMLPA\n         GSTOR R7,32               GET CDE FROM DUMP\n         MVC   COPYCDE(32),0(R7)   COPY INTO OUR WORK AREA\n         LA    R7,COPYCDE\n         USING CDENTRY,R7\n         TM    CDATTR,CDMIN        IF THIS IS A MINOR CDE,\n         BO    CONTMLPA            THEN SKIP IT\n         L     R3,CDXLMJP          ELSE GET ADDRESS OF EXTENT LIST\n         GSTOR R3,16               GET XTLST FROM DUMP\n         USING XTLST,R3\n         L     R0,XTLMSBAA         GET LOAD POINT\n         N     R0,=X'7FFFFFFF'\n         XR    R1,R1\n         ICM   R1,7,XTLMSBLN       GET MODULE LENGTH\n         ALR   R1,R0               CONVERT IT TO LOAD END POINT\n         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT\n         BH    CONTMLPA            THEN THIS IS NOT THE ONE\n         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END\n         BNH   CONTMLPA            THEN THIS IS NOT THE ONE\n         LR    R2,R5               ELSE ADDRESS MINUS LOAD POINT\n         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE\n         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'MLPA' TELL WHERE IT WAS FOUND\n         MVC   ADPLCOM1(8),CDNAME   PUT MODULE NAME IN RETURN FIELD\n         B     FORMAT\nCONTMLPA DS    0H\n         L     R7,CDCHAIN          GET ADDRESS OF NEXT CDE IN CHAIN\n         B     LOOPMLPA            CONTINUE LOOPING\nENDMLPA  DS    0H                  SCANNED ALL MLPA - NOT FOUND YET\n         EJECT\n* THEN SEARCH THE NUCLEUS MAP.\n         SPACE 1\n         L     R3,ADPLCVT          ADDRESS OF CVT\n         USING CVT,R3\n         LA    R3,CVTNUCMP         POINTER TO NUCLEUS MAP\n         GSTOR R3,4                GET ADDR OF NUCMAP FROM DUMP\n         L     R3,0(,R3)           ADDRESS OF NUCMAP\n         LR    R2,R5               SET ADDRESS FOR COMPARISONS\n         LR    R7,R3               SAVE DUMP ADDRESS\n         GSTOR R3,16               GET NUCMAP HEADER FROM DUMP\n         L     R9,X'08'(,R3)       GET ADDRESS OF LAST NUCMAP ENTRY\n         LA    R8,16               SET NUCMAP ENTRY INCREMENT\nLOOPNUC  DS    0H                  LOOP THROUGH CDE'S\n         BXH   R7,R8,ENDNUC        BUMP TO NEXT NUCMAP ENTRY UNTIL LAST\n         LR    R3,R7               GET ADDRESS OF NUCMAP ENTRY\n         GSTOR R3,16               GET NUCMAP ENTRY FROM DUMP\n         TM    X'0C'(R3),X'10'     IF THIS IS NOT A CSECT ENTRY\n         BNO   LOOPNUC             THEN CONTINUE\n         L     R0,X'08'(,R3)       GET LOCATION OF NUCLEUS CSECT\n         CR    R2,R0               IF ADDRESS LESS THAN NUC CSECT LOC\n         BL    LOOPNUC             THEN THIS IS NOT THE ONE\n         XR    R1,R1\n         ICM   R1,7,X'0D'(R3)      GET LENGTH\n         ALR   R1,R0               ADD LOC GIVING END POINT\n         CR    R2,R1               IF ADDRESS NOT LESS THAN END POINT\n         BNL   LOOPNUC             THEN THIS IS NOT THE ONE\n*                                  ELSE ADDRESS MINUS LOAD POINT\n         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE\n         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'NUC ' TELL WHERE IT WAS FOUND\n         MVC   ADPLCOM1(8),0(R3)    PUT MODULE NAME IN RETURN FIELD\n         B     FORMAT\nENDNUC   DS    0H\n         SPACE 1\n* IF ALL FAILS, NOT FOUND.\n         SPACE 1\n         B     NOTFOUND\n         EJECT\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         SPACE 1\n         MVC   ERRBUG(L'BUGMSG),BUGMSG\n         STCM  R0,15,OFFWORK\n         UNPK  ERRWORK(9),OFFWORK(5)\n         TR    ERRWORK(8),HEXTBL\n         MVI   ERRWORK+8,C' '\n         LA    R1,ERRBUG\n         LA    R0,L'ERRBUG\n         TPUT  (1),(0),R\n         SPACE 1\n         XR    R2,R2\n         ST    R2,ADPLFMT2         PUT NO OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'ERR ' TELL WHY IT WAS NOT FOUND\n         MVI   ADPLCOM1,C' '        PUT BLANKS IN RETURN FIELD\n         MVC   ADPLCOM1+1(7),ADPLCOM1\n         B     FORMAT\n         EJECT\nNOTFOUND DS    0H\n         SPACE 1\n         XR    R2,R2\n         ST    R2,ADPLFMT2         PUT NO OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'    ' TELL WHERE IT WAS NOT FOUND\n         MVI   ADPLCOM1,C' '        PUT BLANKS IN RETURN FIELD\n         MVC   ADPLCOM1+1(7),ADPLCOM1\n         B     FORMAT\n         EJECT\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BASSM R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nFORMAT   DS    0H                  FORMAT OFFSET AND RETURN\n         MVI   ADPLCOM3,C'+'       BEGIN FORMATTING OFFSET FIELD\n         MVI   ADPLCOM3+1,C' '     CLEAR OFFSET RETURN FIELD TO BLANKS\n         MVC   ADPLCOM3+2(6),ADPLCOM3+1\n         UNPK  OFFWORK(7),ADPLFMT2+1(4) FORMAT OFFSET FIELD IN WORKAREA\n         TR    OFFWORK(6),HEXTBL\n         LA    R0,5                SKIP OVER LEADING ZEROES\n         LA    R1,OFFWORK\nOFFLOOP  DS    0H\n         CLI   0(R1),C'0'\n         BNE   OFFEND\n         LA    R1,1(,R1)\n         BCT   R0,OFFLOOP\nOFFEND   DS    0H\n         LA    R15,OFFWORK+5\n         SR    R15,R1\n         EX    R15,OFFMOVE\n         B     RETURN\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BSM   0,R14               RETURN IN CALLER'S ADDRESSING MODE\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\nOFFMOVE  MVC   ADPLCOM3+1(*-*),0(R1) MOVE FORMATTED OFFSET TO FIELD\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nBUGMSG   DC    C'XIPSWHR: STORAGE NOT AVAILABLE AT ADDRESS '\nERRMSG   DC    C'XIPSWHR: ERROR ACCESSING STORAGE IN MODULE SEARCH.'\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nCOPYCDE  DS    CL32                WORK AREA FOR CDE'S\nCOPYTCB  DS    CL(X'A0')           WORK AREA FOR TCB'S\nOFFWORK  DS    CL8                 WORK AREA TO BUILD OFFSET\nERRBUG   DS    CL(L'BUGMSG+9)\nERRWORK  EQU   *-9,9,C'C'\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL132               WORD AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IHACDE\n         EJECT\n         IHAXTLST\n         EJECT\n         IHALPDE\n         EJECT\n         IKJTCB\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=XIPWHR\n         TITLE 'XIPWHR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'XIPWHR - IPCS VERB EXIT TO TELL WHERE AN ADDRESS IS'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3    DUMP STORAGE ACCESS REGISTER\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    POINTER TO CDE\nR8       EQU   8    USED IN NUCMAP SCANNING\nR9       EQU   9    USED IN NUCMAP SCANNING\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXIPWHR   CSECT\n         SAVE  (14,12),,XIPWHR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XIPWHR,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\n* EXTRACT THE PARAMETER (MUST BE AN ADDRESS).\n         SPACE 1\n         L     R5,ADPLOPTR         GET ADDRESS OF OPERAND FIELD\n         LTR   R5,R5               IF ZERO,\n         BZ    MISSING              THEN MISSING\n         LH    R6,ADPLOPLN         GET LENGTH OF OPERAND FIELD\n         LTR   R6,R6               IF ZERO,\n         BNP   MISSING              THEN MISSING\n         LA    R1,0(R5,R6)         POINT TO END OF OPERAND FIELD\n         BCTR  R1,0                POINT TO LAST CHARACTER OF OPERAND\n         CLI   0(R1),C'.'          IF A PERIOD\n         BNE   NOTPD               THEN\n         BCTR  R6,0                 REDUCE LENGTH BY 1\nNOTPD    LTR   R6,R6               IF REMAINING LENGTH IS ZERO\n         BNP   INVALID             THEN BAD ADDRESS\n         CH    R6,=H'8'            IF MORE THAN 8 CHARACTERS,\n         BH    TOOLONG              THEN TOO LONG\n         BCTR  R6,0                ELSE REDUCE FOR EXECUTES\n         EX    R6,TRTOP            SCAN FOR VALID HEX CHARACTERS\n         BNZ   INVALID             IF BAD CHARACTERS, INVALID\n         EX    R6,MVCOP            ELSE MOVE OPERAND TO SAFE AREA\n         EX    R6,TROP             TRANSLATE ABCDEF TO FAFBFCFDFEFF\n         LA    R6,1(,R6)           ADD 1 FOR PACKING EXTRA BYTE\n         EX    R6,PACKOP           CREATE FULLWORD HEX ADDRESS FIELD\n*                                  THIS SETS FIELD \"ADDRESS\"\n         EJECT\n         XR    R0,R0\n         ST    R0,ADPLCOM1         Clear XIPSWHR communication word\n         L     R0,ADDRESS          GET BINARY ADDRESS VALUE\n         LR    R1,R4               GET ADDRESS OF ABDPL\n         SPACE 1\n         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE\n         SPACE 1\n         UNPK  LINE+00(9),ADDRESS(5)\n         TR    LINE+00(8),HEXTBL\n         MVI   LINE+08,C'.'\n         CLC   ADPLFMT1(4),=C'    '\n         BE    NOTFOUND\n         CLC   ADPLFMT1(4),=C'JPA '\n         BE    INJPA\n         CLC   ADPLFMT1(4),=C'PLPA'\n         BE    INPLPA\n         CLC   ADPLFMT1(4),=C'MLPA'\n         BE    INMLPA\n         CLC   ADPLFMT1(4),=C'NUC '\n         BE    INNUC\n         CLC   ADPLFMT1(4),=C'ERR '\n         BE    INERROR\n         B     INLIMBO\n         EJECT\nNOTFOUND DS    0H\n         SPACE 1\n         MVC   LINE+09(L'NFMSG),NFMSG\n         B     ERROUT\n         EJECT\nINERROR  DS    0H\n         SPACE 1\n         MVC   LINE+09(L'ERMSG),ERMSG\n         B     ERROUT\n         SPACE 1\nINVALID  MVC   LINE(L'INVMSG),INVMSG\n         B     ERROUT\n         SPACE 1\nTOOLONG  MVC   LINE(L'TLMSG),TLMSG\n         B     ERROUT\n         SPACE 1\nMISSING  MVC   LINE(L'MISSMSG),MISSMSG\n         B     ERROUT\n         SPACE 1\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVC   LINE(L'ERMSG),ERMSG\nERROUT   DS    0H\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 1\nINJPA    DS    0H\n         SPACE 1\n         MVC   LINE+09(L'JPAMSG),JPAMSG\n         MVC   LINE+09+L'JPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'JPAMSG+08,C' '\n         MVC   LINE+09+L'JPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'JPAMSG+10,C' '\n         MVC   LINE+09+L'JPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINPLPA   DS    0H\n         SPACE 1\n         MVC   LINE+09(L'PLPAMSG),PLPAMSG\n         MVC   LINE+09+L'PLPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'PLPAMSG+08,C' '\n         MVC   LINE+09+L'PLPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'PLPAMSG+10,C' '\n         MVC   LINE+09+L'PLPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINMLPA   DS    0H\n         SPACE 1\n         MVC   LINE+09(L'MLPAMSG),MLPAMSG\n         MVC   LINE+09+L'MLPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'MLPAMSG+08,C' '\n         MVC   LINE+09+L'MLPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'MLPAMSG+10,C' '\n         MVC   LINE+09+L'MLPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINNUC    DS    0H\n         SPACE 1\n         MVC   LINE+09(L'NUCMSG),NUCMSG\n         MVC   LINE+09+L'NUCMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'NUCMSG+08,C' '\n         MVC   LINE+09+L'NUCMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'NUCMSG+10,C' '\n         MVC   LINE+09+L'NUCMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINLIMBO  DS    0H\n         SPACE 1\n         MVC   LINE+09(L'LIMBOMSG),LIMBOMSG\n         MVC   LINE+09+LIMBOFF(4),ADPLFMT1\n         MVC   LINE+09+L'LIMBOMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'LIMBOMSG+08,C' '\n         MVC   LINE+09+L'LIMBOMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'LIMBOMSG+10,C' '\n         MVC   LINE+09+L'LIMBOMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\nTRTOP    TRT   0(*-*,R5),VALTBL    SCAN FOR VALID HEX CHARACTERS\nMVCOP    MVC   OPWORK(*-*),0(R5)   MOVE OPERAND TO SAFE AREA\nTROP     TR    OPWORK(0),FTBL      TRANSLATE ABCDEF TO FAFBFCFDFEFF\nPACKOP   PACK  ADDRESS(5),OPWORK(0) CREATE BINARY VALUE FROM OPERAND\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nMISSMSG  DC    C'ADDRESS OPERAND MISSING'\nTLMSG    DC    C'ADDRESS OPERAND TOO LONG'\nINVMSG   DC    C'ADDRESS OPERAND SYNTAX ERROR'\nJPAMSG   DC    C'  FOUND IN JPA MODULE '\nPLPAMSG  DC    C'  FOUND IN PLPA MODULE '\nMLPAMSG  DC    C'  FOUND IN MLPA MODULE '\nNUCMSG   DC    C'  FOUND IN NUCLEUS CSECT '\nNFMSG    DC    C'  NOT FOUND IN JPA, LPA OR NUCLEUS'\nERMSG    DC    C'  STORAGE ERROR - UNABLE TO FIND MODULE'\nLIMBOMS1 DC    C'  FOUND IN '\nLIMBOMS2 DC    CL4'    '\nLIMBOMS3 DC    C' MODULE '\nLIMBOMSG EQU   LIMBOMS1,*-LIMBOMS1,C'C'\nLIMBOFF  EQU   LIMBOMS2-LIMBOMS1\n         SPACE\nVALTBL   DC    256YL1(1)\n         ORG   VALTBL+X'81'\n         DC    6YL1(0)             LOWER CASE ABCDEF\n         ORG   VALTBL+C'A'\n         DC    6YL1(0)             UPPER CASE ABCDEF\n         ORG   VALTBL+C'0'\n         DC    10YL1(0)            0123456789\n         ORG\n         SPACE\nFTBL     DC    256YL1(*-FTBL)\n         ORG   FTBL+X'81'\n         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF\n         ORG   FTBL+C'A'\n         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF\n         ORG\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nADDRESS  DS    A                   THE ADDRESS TO BE SEARCHED ON\n         DS    XL1                 PADDING FOR CONVERSION\nOPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IHACDE\n         EJECT\n         IHAXTLST\n         EJECT\n         IHALPDE\n         EJECT\n         IKJTCB\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=XITMAP\n         TITLE 'XITMAP - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN-ABDPL(,R1)  STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA-ABDPL(,R1) GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         EJECT\n         MACRO\n&SYM     GDUMP &REG,&PLACE,&FILL=' ',&STG=DOUBLE\n         AIF   ('&REG' EQ '*').NOSTORE\n&SYM     ST    &REG,&STG               REGISTER CONTENTS TO BE DUMPED\n         AGO   .AFT\n.NOSTORE ANOP\n&SYM     DS    0H                      CONTENTS OF STORAGE TO BE DUMPED\n.AFT     ANOP\n         UNPK  &PLACE.(9),&STG.(5)\n         TR    &PLACE.(8),HEXTBL\n         MVI   &PLACE.+8,C&FILL\n         MEND\n         TITLE 'XITMAP - IPCS TCB EXIT TO MAP RB CONTROL BLOCKS'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    TCB POINTER\nR4       EQU   4    ABDPL ADDRESS\nR5       EQU   5    LLS POINTER\nR6       EQU   6    RB POINTER\nR7       EQU   7    CDE POINTER\nR8       EQU   8    DEB POINTER\nR9       EQU   9    DCB POINTER\nR10      EQU   10   JPQ POINTER\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXITMAP   CSECT\n         SAVE  (14,12),,XITMAP-&SYSDATE-&SYSTIME\n         LR    R12,R15\n         USING XITMAP,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ADDRESS OF ABDPL\n         USING ABDPL,R4\n         L     R11,ADPLBUF         ESTABLISH ADDRESSABILITY TO\n         USING LINEDSCT,R11            OUTPUT BUFFER\n         XC    WHRADDR,WHRADDR\n         XC    FIRSTTCB,FIRSTTCB\n         EJECT\n         L     R3,ADPLTCB          GET TCB PASSED FOR TCB EXIT\n         LTR   R3,R3               IF TCB ADDRESS IS ZERO\n         BZ    SCANTREE            THEN SCAN TCB TREE FOR ALL TASKS,\n         BAL   R14,PROCESS         ELSE JUST PROCESS THIS ONE\n         B     RETURN0             AND RETURN.\n         SPACE 1\nSCANTREE DS    0H                  PROCESS ALL TCB'S...\n*\n*\n* Instead of using the low-core pointer to get to the TCB,\n* use the ASID to locate the ASCB (via the ASVT) and get the\n* first TCB from there.  In that way, setting the ASID via\n* SETDEF will affect which address space gets mapped.\n*\n*        LA    R3,X'21C'           ADDRESS OF CVTTCBP\n*        GSTOR R3,4,ERRET=BAD21C   GET PSATOLD FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB\n*        LTR   R3,R3               IF POINTER AT 21C IS ZEROES,\n*        BNZ   FINDTOP             THEN...\n*        MVI   LINE,C' '\n*        MVC   LINE+1(L'LINE-1),LINE\n*        MVC   LINE(L'TRY218),TRY218\n*        BAL   R14,OUTPUT\n*        LA    R3,X'218'\n*        GSTOR R3,4,ERRET=BAD218   GET PSATNEW FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB\n*        LTR   R3,R3               IF POINTER AT 218 IS ZEROES,\n*        BNZ   FINDTOP             THEN...\n*        MVI   LINE,C' '\n*        MVC   LINE+1(L'LINE-1),LINE\n*        MVC   LINE(L'TRY224),TRY224\n*        BAL   R14,OUTPUT\n*\n* Try to get ASCB.  Instead of relying on the low-core pointer,\n* use the ASID to locate it via the ASVT.  In that way, setting\n* the ASID with SETDEF will cause this exit to pick up the right one.\n*\n*----------------------------------------------------------------------\n*        LA    R3,X'224'            TRY VIA ASCB\n*        GSTOR R3,4,ERRET=BAD224   GET PSA'S ASCB PTR FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT ASCB\n*        GSTOR R3,X'70',ERRET=BADASCB   GET CURRENT ASCB FROM DUMP\n*----------------------------------------------------------------------\n         L     R3,ADPLCVT          Get CVT pointer\n         LA    R3,X'22C'(,R3)      CVT+22C -> ASVT\n         GSTOR R3,4,ERRET=BADCVT   Get loc of CVT's ASVT ptr from dump\n         L     R3,0(,R3)           Load address of CVT's ASVT pointer\n         LH    R2,ADPLASID         Get the current ASID\n         SLA   R2,2                Multiply by 4 making index into ASVT\n         LA    R3,X'20C'(R2,R3)    Point to ASCB address for this ASID\n         GSTOR R3,4,ERRET=BADASVT  Get ASCB address from dump\n         L     R3,0(,R3)           Load the ASCB address\n         GSTOR R3,X'70',ERRET=BADASCB   Get the ASCB from dump\n         L     R3,X'6C'(,R3)       GET POINTER TO ASXB\n         GSTOR R3,8,ERRET=BADASXB  GET ASXB FROM DUMP\n         L     R3,4(,R3)           GET 1ST TCB ADDRESS FROM ASXB\n         ST    R3,FIRSTTCB         Save for future module findings\nFINDTOP  DS    0H                  SCAN FOR TOP TCB\n         LR    R2,R3               SAVE ACTUAL TCB ADDRESS\n         GSTOR R3,X'8C',ERRET=BADTCB GET CURRENT TCB FROM DUMP\n         ICM   R15,15,X'84'(R3)    ADDRESS OF MOTHER TCB\n         BZ    USETCB              IF NONE, THIS IS THE TOP TCB\n         LR    R3,R15              IF THERE IS A MOTHER,\n         B     FINDTOP             THEN GO FIND ITS MOTHER OR USE IT\nUSETCB   DS    0H                  START WITH THIS TCB\n         LR    R3,R2               GET ACTUAL TCB ADDRESS AGAIN\n         SPACE 1\n*******                            (WE DON'T DO THIS ANY MORE)\n*******  L     R3,X'7C'(,R3)       GET POINTER TO TCBJSTCB\n*******\n*\n         BAL   R14,OUTPUT          Print a blank line\n         MVC   LINE(L'HIMSG),HIMSG\n         LH    R2,ADPLASID\n         GDUMP R2,LINE+L'HIMSG     FORMAT AND PRINT ASID\n         BAL   R14,OUTPUT          PRINT \"HI THERE\" MESSAGE\n         BAL   R14,OUTPUT          Print a blank line\n*\nDOIT     DS    0H\n         BAL   R14,PROCESS\n         ICM   R3,15,COPYTCB+X'88' DAUGHTER TCB\n         BNZ   DOIT\nNODTR    DS    0H                  ELSE\n         ICM   R3,15,COPYTCB+X'80' SISTER TCB\n         BNZ   DOIT\nNOSISTER DS    0H                  ELSE\n         ICM   R3,15,COPYTCB+X'84' MOTHER TCB\n         BZ    NOMORE              IF NONE, FINISHED WITH TCB TREE\n         GSTOR R3,X'8C',ERRET=BADTCB ELSE GET MOTHER TCB FROM DUMP\n         MVC   COPYTCB(X'8C'),0(R3) SAVE TCB STORAGE\n         B     NODTR               PROCESS ITS SISTER, ETC.\nNOMORE   DS    0H\n         B     RETURN0\n         EJECT\nPROCESS  DS    0H                  R3 = ADDRESS OF TCB BEING PROCESSED\n         SPACE\n         ST    R14,PRCSSAVE        SAVE RETURN REGISTER\n         BAL   R14,OUTPUT          PRINT A BLANK LINE\n         MVC   LINE(L'TCBMSG),TCBMSG\n         GDUMP R3,LINE+L'TCBMSG    FORMAT AND PRINT TCB ADDRESS\n         BAL   R14,OUTPUT          PRINT \"PROCESSING TCB\"\n         GSTOR R3,256,ERRET=BADTCB GET TCB ITSELF FROM DUMP\n         MVC   COPYTCB(256),0(R3)  SAVE TCB STORAGE FOR FUTURE USE\n         ICM   R6,15,COPYTCB+X'10' PICK UP COMPLETION CODE\n         BZ    NOTCBCMP            IF THERE IS ONE, THEN...\n         MVC   LINE(L'CMPMSG),CMPMSG\n         GDUMP R6,LINE+L'CMPMSG               FORMAT IT AND PRINT IT\n         MVC   LINE+L'CMPMSG+9(L'RTM2MSG),RTM2MSG\n         ICM   R6,15,COPYTCB+X'E0'            PICK UP ADDRESS OF RTM2WA\n         GDUMP R6,LINE+L'CMPMSG+9+L'RTM2MSG   FORMAT IT AND PRINT IT\n         BAL   R14,OUTPUT          PRINT COMPLETION CODE\nNOTCBCMP DS    0H\n         L     R6,COPYTCB+0        ADDRESS OF RB\n         MVC   LINE(L'RBMSG),RBMSG\n         GDUMP R6,LINE+L'RBMSG     FORMAT AND PRINT RB ADDRESS\n         BAL   R14,OUTPUT          PRINT \"PROCESSING RB\"\nRBLOOP   DS    0H\n         LR    R2,R6               SAVE TRUE RB ADDRESS\n         SH    R6,=H'32'           POINT TO RB PREFIX\n         BM    BADRB               IF IT MAKES IT GO NEGATIVE, BAD ADDR\n         GSTOR R6,96,ERRET=BADRB   GET RB FROM DUMP\n         MVC   RBPREFIX(96),0(R6)  MAKE A COPY OF IT\n         GDUMP R2,LINE+0           FORMAT AND PRINT RB ADDRESS\n         TM    COPYRB+X'0A',X'C0'  CHECK RB TYPE\n         BZ    PRB\n         BO    SVRB\n         LA    R1,=CL8'(IRB)'\n         B     RBTYPE\nSVRB     LA    R1,=CL8'(SVRB)'\nRBTYPE   DS    0H\n         MVC   LINE+10(8),0(R1)    MOVE RB TYPE\n         B     RBOUT\nPRB      DS    0H\n         XR    R7,R7\n         ICM   R7,7,COPYRB+X'0D'   ADDRESS OF RBCDE\n         BNZ   GOTACDE             IF ZERO, THEN...\n         TM    COPYRB+X'0C',X'04'   IF REQUESTED BY SYNCH MACRO\n         BZ    NOCDE                 THEN\n         MVC   LINE+10(8),=CL8'(SYNCH)'   SAY SO\n         B     RBOUT                 ELSE\nNOCDE    MVC   LINE+10(8),=CL8'(NO CDE)'  JUST SAY NO CDE\n         B     RBOUT\nGOTACDE  DS    0H\n         MVC   LINE+10(8),=CL8'(*N/A*)' IN CASE CDE NOT AVAILABLE\n         GSTOR R7,32,ERRET=RBOUT   GET CDE FROM DUMP\n         MVC   LINE+10(8),CDNAME-CDENTRY(R7) CDE NAME\nRBOUT    DS    0H\n         MVC   LINE+21(4),=C'INT='\n         UNPK  LINE+25(3),COPYRB-1(2) INTERRUPT CODE\n         TR    LINE+25(2),HEXTBL\n         MVI   LINE+27,C' '\n         MVC   LINE+29(4),=C'PSW='\n         UNPK  LINE+33(9),COPYRB+X'10'(5) LEFT HALF OF RBOPSW\n         TR    LINE+33(8),HEXTBL\n         MVI   LINE+41,C' '\n         UNPK  LINE+42(9),COPYRB+X'14'(5) RIGHT HALF OF RBOPSW\n         TR    LINE+42(8),HEXTBL\n         MVI   LINE+50,C' '\n         L     R0,COPYRB+X'14'     GET RIGHT HALF OF PSW\n         BAL   R14,FINDMOD         LOCATE MODULE WHERE IT IS\n         BAL   R14,OUTPUT          PRINT CDE NAME TO IDENTIFY RB\nRBNEXT   DS    0H\n         TM    COPYRB+X'0B',X'80'  IF NEXTRB POINTS TO TCB\n         BO    ENDRB               THEN NO MORE RB'S. ELSE\n         XR    R6,R6\n         ICM   R6,7,COPYRB+X'1D'   ADDRESS OF NEXT RB\n         B     RBLOOP\nBADRB    DS    0H                  RB STORAGE NOT AVAILABLE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'RBERRMSG),RBERRMSG\n         GDUMP R6,LINE+L'RBERRMSG  FORMAT AND PRINT ADDRESS OF RB\n         BAL   R14,OUTPUT\nENDRB    DS    0H\n         ICM   R10,15,COPYTCB+X'2C' ADDRESS OF JOB PACK QUEUE\n         BZ    ENDCDE\n         MVC   LINE(L'JPQMSG),JPQMSG\n         BAL   R14,OUTPUT          PRINT \"MAPPING JOB PACK QUEUE\"\nCDELOOP  DS    0H\n         BAL   R14,DUMPCDE         WRITE OUT CDE INFO\n         ICM   R10,15,0(R10)\n         BNZ   CDELOOP\nENDCDE   DS    0H\nTCB2LOOP DS    0H\n         ICM   R5,15,COPYTCB+X'24' ADDRESS OF LOAD LIST ELEMENTS\n         BZ    ENDLLS\n         MVC   LINE(L'LLSMSG),LLSMSG\n         BAL   R14,OUTPUT          PRINT \"MAPPING LOAD LIST\"\nLLSLOOP  DS    0H\n         GSTOR R5,16,ERRET=BADLLS  GET LLS FROM DUMP\n         L     R2,0(,R5)           SAVE ADDRESS OF NEXT LLS\n         L     R10,4(,R5)          CDE FOR LOAD LIST ENTRY\n         BAL   R14,DUMPCDE         WRITE OUT CDE INFO\nNEXTLLS  DS    0H\n         LTR   R5,R2               GET ADDRESS OF NEXT LLS\n         BZ    ENDLLS\n         B     LLSLOOP\nBADLLS   DS    0H                  ERROR ACCESSING LLS\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'LLSERMSG),LLSERMSG\n         GDUMP R5,LINE+L'LLSERMSG\n         BAL   R14,OUTPUT\n         SPACE 1\nENDLLS   DS    0H\n         ICM   R8,15,COPYTCB+X'08' ADDRESS OF DEB\n         BNZ   GOTDEBS\n         MVC   LINE(L'NODEBS),NODEBS\n         BAL   R14,OUTPUT          PRINT \"NO OPEN DATA SETS\"\n         B     ENDDEB\nGOTDEBS  DS    0H\n         MVC   LINE(L'DEBMSG),DEBMSG\n         GDUMP R8,LINE+L'DEBMSG    FORMAT AND PRINT ADDRESS OF DEB\n         BAL   R14,OUTPUT          PRINT \"MAPPING DEB CHAIN\"\nDEBLOOP  DS    0H\n         MVC   LINE(4),=C'DEB='\n         GDUMP R8,LINE+4           FORMAT AND PRINT ADDRESS OF DEB\n         GSTOR R8,32,ERRET=BADDEB  GET DEB FROM DUMP\n         MVC   COPYDEB(32),0(R8)   MAKE A COPY OF IT\n         L     R9,COPYDEB+X'18'    ADDRESS OF DCB FOR THIS DEB\n         N     R9,=X'00FFFFFF'     CLEAR HIGH ORDER BYTE\n         MVC   LINE+14(4),=C'DCB='\n         GDUMP R9,LINE+18          FORMAT AND PRINT ADDRESS OF DCB\n         GSTOR R9,X'30',ERRET=BADDCB GET DCB FROM DUMP\n         L     R2,COPYTCB+X'0C'    ADDRESS OF TIOT\n         AH    R2,X'28'(,R9)       ADD TIOT OFFSET FROM DCB\n         GSTOR R2,20,ERRET=BADTIOT GET TIOT ENTRY FROM DUMP\n         MVC   LINE+28(8),4(R2)    DDNAME FROM TIOT\n         MVI   LINE+36,C' '\n         ICM   R9,7,X'C'(R2)       POINTER TO JFCB FROM TIOT\n         LA    R9,X'10'(,R9)       ADDRESS OF JFCB\n         GSTOR R9,176,ERRET=BADJFCB GET JFCB FROM DUMP\n         MVC   LINE+37(44),0(R9)   DSNAME\n         LA    R1,LINE+37+44-1\nDSNLOOP  CLI   0(R1),C' '\n         BNE   DSNEND\n         BCTR  R1,0\n         B     DSNLOOP\nDSNEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME\n         CLI   44(R9),C' '         IF THERE IS A MEMBER NAME IN JFCB\n         BE    NOMEMBER            THEN\n         MVI   1(R1),C'('\n         MVC   2(8,R1),44(R9)\n         LA    R1,9(,R1)\nMEMLOOP  CLI   0(R1),C' '\n         BNE   MEMEND\n         BCTR  R1,0\n         B     MEMLOOP\nMEMEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN MEMBER\n         LA    R1,1(,R1)\n         MVI   0(R1),C')'\nNOMEMBER DS    0H                  R1 POINTS TO LAST NONBLANK\n         TM    COPYDEB+X'08',X'01' IF CONCATENATED DATA SETS,\n         BZ    PRINTDEB            THEN...\n         MVC   2(7,R1),=C' ET AL.'  LET ME KNOW\n         B     PRINTDEB\nBADDCB   DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+14(L'DCBERMSG),DCBERMSG\n         GDUMP R9,LINE+14+L'DCBERMSG\n         B     PRINTDEB\nBADTIOT  DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+28(L'TIOERMSG),TIOERMSG\n         GDUMP R2,LINE+28+L'TIOERMSG\n         B     PRINTDEB\nBADJFCB  DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+37(L'JFERRMSG),JFERRMSG\n         GDUMP R9,LINE+37+L'JFERRMSG\n         B     PRINTDEB\nPRINTDEB DS    0H\n         BAL   R14,OUTPUT          PRINT DEB=ADDR DCB=ADDR DDNAME\n         B     NEXTDEB             GO TO NEXT DEB\nBADOTHER DS    0H                  ERROR ACCESSING STORAGE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ERRMSG),ERRMSG\n         BAL   R14,OUTPUT\n******** B     NEXTDEB\nNEXTDEB  DS    0H\n         XR    R8,R8\n         ICM   R8,7,COPYDEB+5      ADDRESS OF NEXT DEB\n         BZ    ENDDEB\n         B     DEBLOOP\nBADDEB   DS    0H                  ERROR ACCESSING DEB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'DEBERMSG),DEBERMSG\n         GDUMP R8,LINE+L'DEBERMSG\n         BAL   R14,OUTPUT\nENDDEB   DS    0H\nENDPROC  DS    0H\n         L     R14,PRCSSAVE        RETURN\n         BR    R14\n         EJECT\nDUMPCDE  DS    0H                  THIS ROUTINE DUMPS A CDE\n*\n* THIS SUBROUTINE FORMATS AND WRITES OUT CDE INFORMATION,\n* ON ENTRY R10 CONTAINS THE ADDRESS OF THE CDE.\n*\n         SPACE 1\n         ST    R14,DCDESAVE        SAVE RETURN REGISTER\n         ST    R10,DOUBLE          CDE ADDRESS\n         GSTOR R10,32,ERRET=BADCDE GET CDE FROM DUMP\n         USING CDENTRY,R10\n         GDUMP *,LNCDADDR          FORMAT AND PRINT ADDRESS OF CDE\n         MVC   LNCDNAME(8),CDNAME   CDE NAME\n         MVC   LNCDEPEQ(3),=C'EP='\n         GDUMP *,LNCDEPA,STG=CDENTPT ENTRY POINT FROM CDE\n         TM    CDATTR,CDREN\n         BZ    NOTRENT\n         MVC   LNCDRENT,=C'RENT'\nNOTRENT  TM    CDATTR,CDSER\n         BZ    NOTREUS\n         MVC   LNCDREUS,=C'REUS'\nNOTREUS  TM    CDATTR2,CDEANYM\n         BZ    NOTANY\n         MVC   LNCDANY,=C'ANY'\nNOTANY   TM    CDATTR2,CDOLY\n         BZ    NOTOVLY\n         MVC   LNCDOVLY,=C'OVLY'\nNOTOVLY  TM    CDATTR2,CDSYSLIB\n         BZ    NOTSYSL\n         MVC   LNCDSYSL,=C'SYSLIB'\nNOTSYSL  TM    CDATTR2,CDAUTH\n         BZ    NOTAUTH\n         MVC   LNCDAUTH,=C'AUTH'\nNOTAUTH  DS    0H\n         B     OUTCDE\nBADCDE   DS    0H                  CDE STORAGE NOT AVAILABLE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CDERRMSG),CDERRMSG\n         GDUMP R10,LINE+L'CDERRMSG FORMAT AND PRINT CDE ADDRESS\nOUTCDE   BAL   R14,OUTPUT          PRINT CDE MODULE NAME\n         L     R14,DCDESAVE        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         EJECT\nBAD21C   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER21CMSG),ER21CMSG\n         GDUMP R3,LINE+L'ER21CMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBAD218   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER218MSG),ER218MSG\n         GDUMP R3,LINE+L'ER218MSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBAD224   DS    0H                  ERROR ACCESSING ASCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER224MSG),ER224MSG\n         GDUMP R3,LINE+L'ER224MSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADTCB   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'TCBERMSG),TCBERMSG\n         GDUMP R3,LINE+L'TCBERMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADASCB  DS    0H                  ERROR ACCESSING ASCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASCBEMSG),ASCBEMSG\n         GDUMP R3,LINE+L'ASCBEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADASXB  DS    0H                  ERROR ACCESSING ASXB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASXBEMSG),ASXBEMSG\n         GDUMP R3,LINE+L'ASXBEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADCVT   DS    0H\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CVTEMSG),CVTEMSG\n         GDUMP R3,LINE+L'CVTEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADCASVT DS    0H\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CASVEMSG),CASVEMSG\n         GDUMP R3,LINE+L'CASVEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADASVT  DS    0H\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASVTEMSG),ASVTEMSG\n         GDUMP R3,LINE+L'ASVTEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\n         EJECT\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ERRMSG),ERRMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nFINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME\n*                                  R0 CONTAINS ADDRESS TO SEARCH ON\n         ST    R14,FMSAVE\n         LTR   R0,R0               IF AMODE 31 BIT IS NOT ON\n         BM    FMASIS              THEN\n         N     R0,=X'00FFFFFF'      CLEAR HIGH-ORDER BYTE FOR 24-BIT AD\nFMASIS   DS    0H\n         ICM   R15,15,WHRADDR\n         BNZ   FMGOTWHR\n         ST    R0,FMWORK\n         LOAD  EPLOC==CL8'XIPSWHR',ERRET=FMNF\n         ST    R0,WHRADDR\n         LR    R15,R0\n         L     R0,FMWORK\nFMGOTWHR DS    0H\n         L     R14,FIRSTTCB\n         ST    R14,ADPLCOM1        Get first TCB address for XIPSWHR\n         LR    R1,R4               POINT TO ABDPL\n         BASSM R14,R15             CALL XIPSWHR TO GET MODULE NAME\n         CLI   ADPLFMT1,C' '       IF NOT FOUND...\n         BE    FMNF\n         CLI   ADPLFMT1,C'E'       IF STORAGE ERROR...\n         BE    FMERR\n         MVC   LINE+52(16),ADPLCOM1\n         B     FMRET\nFMERR    DS    0H\n         MVC   LINE+52(16),=CL16'(STORAGE ERROR) '\n         B     FMRET\nFMNF     DS    0H\n         MVC   LINE+52(16),=CL16'(UNKNOWN)       '\nFMRET    DS    0H\n         L     R14,FMSAVE\n         BR    R14\n         EJECT\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT-ABDPL(,R1) GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15\n         BNZ   RETURN0\n         L     R11,ADPLBUF-ABDPL(,R1)  POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         ICM   R15,R15,WHRADDR\n         BZ    NODELETE\n         DELETE EPLOC==CL8'XIPSWHR'\nNODELETE DS    0H\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nHIMSG    DC    C'                 MAP FOR ASID '\nTCBMSG   DC    C'*** P R O C E S S I N G   T C B *** - '\nCMPMSG   DC    C'*** COMPCODE='\nRTM2MSG  DC    C' RTM2 AT '\nRBMSG    DC    C'---MAPPING RBS - '\nJPQMSG   DC    C'---MAPPING CDES FROM JOB PACK QUEUE'\nLLSMSG   DC    C'---MAPPING CDES FROM LOAD LIST'\nNODEBS   DC    C'---TASK HAS NO OPEN DATA SETS'\nDEBMSG   DC    C'---MAPPING DEBS - '\nTRY218   DC    C'PSATOLD TCB POINTER IS ZEROES, USING PSATNEW POINTER'\nTRY224   DC    C'PSATNEW TCB POINTER IS ZEROES, USING ASXB POINTER'\nERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'\nER21CMSG DC    C'ERROR - PSATOLD UNAVAILABLE'\nER218MSG DC    C'ERROR - PSATNEW UNAVAILABLE'\nER224MSG DC    C'ERROR - ASCB UNAVAILABLE'\nTCBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR TCB AT '\nASCBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASCB AT '\nASXBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASXB AT '\nRBERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR RB AT '\nCDERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR CDE AT '\nLLSERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR LLS AT '\nDEBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR DEB AT '\nDCBERMSG DC    C'DCB UNAVAILABLE AT '\nTIOERMSG DC    C'TIOT ENTRY UNAVAILABLE AT '\nJFERRMSG DC    C'JFCB UNAVAILABLE AT '\nCVTEMSG  DC    C'CVT ASVT POINTER UNAVAILABLE AT '\nCASVEMSG DC    C'ASVT ADDRESS UNAVAILABLE AT '\nASVTEMSG DC    C'ASVT ASCB POINTER UNAVAILABLE AT '\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nPRCSSAVE DS    A                   SAVE AREA FOR PROCESS SUBROUTINE\nDCDESAVE DS    A                   SAVE AREA FOR DUMPCDE SUBROUTINE\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nFMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE\nFMWORK   DS    A                   WORK AREA FOR FINDMOD SUBROUTINE\nWHRADDR  DS    A                   ADDRESS OF XIPSWHR LOAD MODULE\nFIRSTTCB DS    A                   First TCB address\n         SPACE 1\nCOPYTCB  DS    CL256               COPY OF MOST OF TCB\nCOPYDEB  DS    CL32                COPY OF MOST OF DEB\nRBPREFIX DS    CL32                COPY OF RB PREFIX\nCOPYRB   DS    CL64                COPY OF MOST OF RB\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINEDSCT DSECT ,                   MAP THE OUTPUT BUFFER\nLINE     DS    CL132               WORD AREA FOR OUTPUT LINES\n         ORG   LINE\nLNCDADDR DS    CL8                 ADDRESS OF CONTROL BLOCK\n         DS    CL2\nLNCDNAME DS    CL8                 NAME\n         DS    CL3\nLNCDEPEQ DS    C'EP='              \"EP=\"\nLNCDEPA  DS    CL8                 ENTRY POINT\n         DS    CL3                 FOLLOWED BY ATTRIBUTES\nLNCDRENT DS    C'RENT'\n         DS    CL1\nLNCDREUS DS    C'REUS'\n         DS    CL1\nLNCDANY  DS    C'ANY'\n         DS    CL1\nLNCDOVLY DS    C'OVLY'\n         DS    CL1\nLNCDSYSL DS    C'SYSLIB'\n         DS    CL1\nLNCDAUTH DS    C'AUTH'\n         DS    CL1\n         ORG\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         BLSABDPL\n         SPACE 1\n         IHACDE\n         SPACE 1\n         END\n./ ADD NAME=XITSAV\n         TITLE 'XITSAV - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   ('&LENGTH' EQ '(0)').GOTLEN\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'XITSAV - IPCS TCB EXIT TO DISPLAY SAVE AREA TRACE'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3    DUMP STORAGE ACCESS REGISTER\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    ADDRESS OF PREVIOUS SAVE AREA (COMPARE WITH HSA)\nR8       EQU   8    TRUE ADDRESS OF CURRENT SAVE AREA\nR9       EQU   9    ADDRESS OF DATA WHERE SAVEAREA'S R15 POINTS\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXITSAV   CSECT\n         SAVE  (14,12),,XITSAV_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XITSAV,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ADDRESS OF ABDPL\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\nPROCESS  DS    0H\n         SPACE 1\n         LOAD  EP=XIPSWHR          LOAD ADDRESS SEARCH ROUTINE\n         ST    R0,WHRADDR\n         SPACE 1\n         L     R3,ADPLTCB          R3 = ADDRESS OF TCB\n         USING TCB,R3\n         XR    R7,R7               INITIALIZE HSA POINTER\n         LA    R3,TCBFSA           POINTER TO ADDRESS OF FIRST SAVEAREA\n         GSTOR R3,4                GET TCBFSA FROM DUMP\n         ICM   R3,15,0(R3)         ADDRESS OF FIRST SAVE AREA\n         BNZ   LOOP                IF NONE, THEN...\n         MVC   LINE(L'NOSAMSG),NOSAMSG SAY SO\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 1\nLOOP     DS    0H\n         LTR   R3,R3               UNTIL NO MORE\n         BZ    ENDLOOP\n         MVC   LINE(L'SAMSG),SAMSG \"SAVE AREA AT \"\n         LR    R8,R3               TRUE ADDRESS OF THIS SAVE AREA\n         ST    R8,OPWORK           DISPLAY IT\n         UNPK  LINESAA+0(9),OPWORK(5)\n         TR    LINESAA+0(8),HEXTBL\n         MVI   LINESAA+8,C'.'\n         GSTOR R3,72,ERRET=SANA    GET SAVE AREA FROM DUMP\n         MVC   COPYSA(72),0(R3)    COPY INTO OUR WORK AREA\nCONTLOOP DS    0H\n         SPACE\n         MVC   LINEL1(4),=C'WD1='\n         UNPK  LINEN1(9),SAWD1(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'HSA='\n         UNPK  LINEN2(9),SAHSA(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'LSA='\n         UNPK  LINEN3(9),SALSA(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         BAL   R14,OUTPUT\n         C     R7,SAHSA            CHECK HSA POINTER\n         BE    HSAOK               IF IT DOESN'T MATCH, THEN...\n         MVC   LINEL1(L'IBCMSG),IBCMSG\n         BAL   R14,OUTPUT          NOTE INVALID BACK CHAIN\nHSAOK    DS    0H\n         LR    R7,R8               SET PREVIOUS-SAVE-AREA ADDRESS\n         MVC   LINEL1(4),=C'R14='\n         UNPK  LINEN1(9),SAR14(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         L     R0,SAR14\n         BAL   R14,FINDMOD         RESOLVE RETURN ADDRESS\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R15='\n         UNPK  LINEN1(9),SAR15(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         L     R0,SAR15\n         BAL   R14,FINDMOD         RESOLVE ENTRY ADDRESS\n         SPACE 1\n         L     R9,FMWHERE          ADDRESS THAT HAS BEEN RESOLVED\n         LTR   R9,R9               IF ZERO, IGNORE IT\n         BZ    NOEP\n         GSTOR R9,8,ERRET=NOEP     TRY TO GET ENTRY POINT DATA\n         ICM   R0,15,0(R9)         GET ENTRY POINT INSTRUCTION\n         N     R0,=X'FFFFF000'     AND OUT THE DISPLACEMENT\n         CL    R0,=X'47F0F000'     IF IT IS NOT A BRANCH-AROUND\n         BNE   NOEP                THEN NO EP DATA\n         XR    R2,R2               CLEAR INSERT REG\n         IC    R2,4(,R9)           GET LENGTH OF IDENTIFIER\n         LTR   R2,R2               IF ZERO\n         BZ    NOEP                THEN NO EP DATA\n         CH    R2,=Y(EPLENGTH)     SET MAXIMUM LENGTH THAT WE CAN SHOW\n         BNH   SETMAX\n         LA    R2,EPLENGTH\nSETMAX   DS    0H\n         LA    R9,4\n         A     R9,FMWHERE          POINT TO IDENTIFIER STUFF\n         LA    R0,1+3(,R2)         SET LENGTH+1 AND PREPARE TO...\n         N     R0,=X'FFFFFFFC'     ....ROUND UP TO FULLWORD BOUNDARY\n         GSTOR R9,(0),ERRET=NOEP   GET DATA FOR THE LENGTH NEEDED\n         MVC   LINEEP1(6),=CL6'AT EP '\n         BCTR  R2,0                REDUCE LENGTH FOR EXECUTE\n         EX    R2,EPMVC            TRANSLATE EP DATA\nNOEP     DS    0H\n         SPACE 1\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R0 ='\n         UNPK  LINEN1(9),SAR00(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R1 ='\n         UNPK  LINEN1(9),SAR01(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R2 ='\n         UNPK  LINEN2(9),SAR02(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R3 ='\n         UNPK  LINEN3(9),SAR03(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R4 ='\n         UNPK  LINEN4(9),SAR04(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         MVC   LINEL1(4),=C'R5 ='\n         UNPK  LINEN1(9),SAR05(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R6 ='\n         UNPK  LINEN2(9),SAR06(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R7 ='\n         UNPK  LINEN3(9),SAR07(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R8 ='\n         UNPK  LINEN4(9),SAR08(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         MVC   LINEL1(4),=C'R9 ='\n         UNPK  LINEN1(9),SAR09(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R10='\n         UNPK  LINEN2(9),SAR10(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R11='\n         UNPK  LINEN3(9),SAR11(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R12='\n         UNPK  LINEN4(9),SAR12(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         BAL   R14,OUTPUT          JUST A BLANK LINE\n         SPACE\n         L     R3,SALSA            GET ADDRESS OF NEXT SAVE AREA\n         B     LOOP                CONTINUE LOOPING\n         SPACE 1\nSANA     DS    0H                  SAVE AREA NOT AVAILABLE FROM DUMP\n         SPACE 1\n         MVC   LINE+L'SAMSG+08+2(L'SANAMSG),SANAMSG\n         BAL   R14,OUTPUT\n         B     ERROUT\n         SPACE 1\nENDLOOP  DS    0H\n         B     RETURN0\n         SPACE 2\nEPMVC    MVC   LINEEP2(0),1(R9)    EXECUTED\n         EJECT\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVC   LINE(L'ERRMSG),ERRMSG\n******** B     ERROUT\n         SPACE 1\nERROUT   DS    0H\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nFINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME\n*                                  R0 CONTAINS ADDRESS TO SEARCH ON\n         ST    R0,FMWHERE          STORE ADDRESS TO BE RESOLVED\n         LTR   R0,R0               IF ADDRESS IS ZEROES,\n         BZR   R14                 THEN PRINT NOTHING, NOT AN EP\n         ST    R14,FMSAVE\n         NI    FMWHERE,B'01111111' TURN OFF HIGH-ORDER BIT FOR ADDRESS\nFMDOIT   DS    0H\n         XR    R0,R0\n         ST    R0,ADPLCOM1\n         L     R0,FMWHERE\n         LR    R1,R4\n         L     R15,WHRADDR\n         BALR  R14,R15\n         CLI   ADPLFMT1,C' '\n         BE    FMNF\n         MVC   LINEMOD(16),ADPLCOM1\n         B     FMRET\nFMNF     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IF ADDRESS UNKNOWN, MAYBE THE HIGH-ORDER BYTE IS CONFUSING THE      *\n* ADDRESS SEARCH ROUTINE.  SO WE SET IT TO ZEROES AND TRY AGAIN.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   FMWHERE,X'00'       IF IT'S ALREADY A 24-BIT ADDRESS\n         BE    FMFAIL              THEN DON'T TRY AGAIN\n         MVI   FMWHERE,X'00'       ELSE CHANGE IT TO A 24-BIT ADDRESS\n         B     FMDOIT               TRY AGAIN WITH 0 IN H.O.BYTE\nFMFAIL   DS    0H                  ELSE GIVE UP\n         MVC   LINEMOD(16),=CL16'(UNKNOWN)       '\n         XC    FMWHERE,FMWHERE\nFMRET    DS    0H\n         L     R14,FMSAVE\n         BR    R14\n         EJECT\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         LTR   R15,R15             IF LINE NOT PRINTED\n         BNZ   RETURN0             THEN...\nNORETYET DS    0H\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         DELETE EP=XIPSWHR\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'\nNOSAMSG  DC    C'NO SAVE AREA CHAIN FOR THIS TCB'\nIBCMSG   DC    C'*** INVALID BACK CHAIN ***'\nSANAMSG  DC    C'STORAGE UNAVAILABLE'\nSAMSG    DC    C'SAVE AREA AT '\n         SPACE\nVALTBL   DC    256YL1(1)\n         ORG   VALTBL+X'81'\n         DC    6YL1(0)             LOWER CASE ABCDEF\n         ORG   VALTBL+C'A'\n         DC    6YL1(0)             UPPER CASE ABCDEF\n         ORG   VALTBL+C'0'\n         DC    10YL1(0)            0123456789\n         ORG\n         SPACE\nFTBL     DC    256YL1(*-FTBL)\n         ORG   FTBL+X'81'\n         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF\n         ORG   FTBL+C'A'\n         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF\n         ORG\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nFMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE\nFMWHERE  DS    A                   ADDRESS PASSED TO FINDMOD SUBROUTINE\nWHRADDR  DS    A                   ADDRESS OF XIPSWHR, SEARCH ROUTINE\n         DS    XL1                 PADDING FOR CONVERSION\nOPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION\nCOPYSA   DS    18F                 WORK AREA FOR SAVE AREA\n         ORG   COPYSA\nSAWD1    DS    F                   00 = FIRST WORD\nSAHSA    DS    F                   04 = HSA\nSALSA    DS    F                   08 = LSA\nSAR14    DS    F                   0C = REG14\nSAR15    DS    F                   10 = REG15\nSAR00    DS    F                   14 = REG0\nSAR01    DS    F                   18 = REG1\nSAR02    DS    F                   1C = REG2\nSAR03    DS    F                   20 = REG3\nSAR04    DS    F                   24 = REG4\nSAR05    DS    F                   28 = REG5\nSAR06    DS    F                   2C = REG6\nSAR07    DS    F                   30 = REG7\nSAR08    DS    F                   34 = REG8\nSAR09    DS    F                   38 = REG9\nSAR10    DS    F                   3C = REG10\nSAR11    DS    F                   40 = REG11\nSAR12    DS    F                   44 = REG12\n         ORG\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         ORG   LINE\n         DS    CL(L'SAMSG)         \"SAVE AREA AT \"\nLINESAA  DS    CL8                 ADDRESS OF SAVE AREA\n         DS    CL2                 \"  \"\nLINEL1   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN1   DS    CL8                 \"NNNNNNNN\"\nLINEB1   DS    CL1                 \" \"\nLINEL2   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN2   DS    CL8                 \"NNNNNNNN\"\nLINEB2   DS    CL1                 \" \"\nLINEL3   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN3   DS    CL8                 \"NNNNNNNN\"\nLINEB3   DS    CL1                 \" \"\nLINEL4   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN4   DS    CL8                 \"NNNNNNNN\"\nLINEB4   DS    CL1                 \" \"\nLINEL5   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN5   DS    CL8                 \"NNNNNNNN\"\nLINEB5   DS    CL1                 \" \"\n         ORG   LINEL2\n         DS    CL1\nLINEMOD  DS    CL16                \"WHERE\" DATA\n         DS    CL1\nLINEEP1  DS    CL6                 \"AT EP \"\nLINEEP2  DS    CL(EPLENGTH)\n         SPACE 1\nEPLENGTH EQU   78-(LINEEP2-LINE)\n         ORG\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IKJTCB\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=XITWHR\n         TITLE 'XITWHR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'XITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3    DUMP STORAGE ACCESS REGISTER\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    POINTER TO CDE\nR8       EQU   8    USED IN NUCMAP SCANNING\nR9       EQU   9    USED IN NUCMAP SCANNING\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXITWHR   CSECT\n         SAVE  (14,12),,XITWHR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XITWHR,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\n* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.\n* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES\n* THE CORRECT ASID, ETC.\n         SPACE 1\n         XR    R0,R0\n         ST    R0,ADPLCOM1         Clear communication word\n         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE\n         LR    R1,R4               GET ADDRESS OF ABDPL\n         SPACE 1\n         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE\n         SPACE 1\n         UNPK  LINE+00(9),ADPLTCB(5)\n         TR    LINE+00(8),HEXTBL\n         MVI   LINE+08,C'.'\n         CLC   ADPLFMT1(4),=C'    '\n         BE    NOTFOUND\n         CLC   ADPLFMT1(4),=C'JPA '\n         BE    INJPA\n         CLC   ADPLFMT1(4),=C'PLPA'\n         BE    INPLPA\n         CLC   ADPLFMT1(4),=C'MLPA'\n         BE    INMLPA\n         CLC   ADPLFMT1(4),=C'NUC '\n         BE    INNUC\n         CLC   ADPLFMT1(4),=C'ERR '\n         BE    INERROR\n         B     INLIMBO\n         EJECT\nNOTFOUND DS    0H\n         SPACE 1\n         MVC   LINE+09(L'NFMSG),NFMSG\n         B     ERROUT\n         EJECT\nINERROR  DS    0H\n         SPACE 1\n         MVC   LINE+09(L'ERMSG),ERMSG\n         B     ERROUT\n         SPACE 1\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVC   LINE(L'ERMSG),ERMSG\nERROUT   DS    0H\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 1\nINJPA    DS    0H\n         SPACE 1\n         MVC   LINE+09(L'JPAMSG),JPAMSG\n         MVC   LINE+09+L'JPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'JPAMSG+08,C' '\n         MVC   LINE+09+L'JPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'JPAMSG+10,C' '\n         MVC   LINE+09+L'JPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINPLPA   DS    0H\n         SPACE 1\n         MVC   LINE+09(L'PLPAMSG),PLPAMSG\n         MVC   LINE+09+L'PLPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'PLPAMSG+08,C' '\n         MVC   LINE+09+L'PLPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'PLPAMSG+10,C' '\n         MVC   LINE+09+L'PLPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINMLPA   DS    0H\n         SPACE 1\n         MVC   LINE+09(L'MLPAMSG),MLPAMSG\n         MVC   LINE+09+L'MLPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'MLPAMSG+08,C' '\n         MVC   LINE+09+L'MLPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'MLPAMSG+10,C' '\n         MVC   LINE+09+L'MLPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINNUC    DS    0H\n         SPACE 1\n         MVC   LINE+09(L'NUCMSG),NUCMSG\n         MVC   LINE+09+L'NUCMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'NUCMSG+08,C' '\n         MVC   LINE+09+L'NUCMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'NUCMSG+10,C' '\n         MVC   LINE+09+L'NUCMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINLIMBO  DS    0H\n         SPACE 1\n         MVC   LINE+09(L'LIMBOMSG),LIMBOMSG\n         MVC   LINE+09+LIMBOFF(4),ADPLFMT1\n         MVC   LINE+09+L'LIMBOMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'LIMBOMSG+08,C' '\n         MVC   LINE+09+L'LIMBOMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'LIMBOMSG+10,C' '\n         MVC   LINE+09+L'LIMBOMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nJPAMSG   DC    C'  FOUND IN JPA MODULE '\nPLPAMSG  DC    C'  FOUND IN PLPA MODULE '\nMLPAMSG  DC    C'  FOUND IN MLPA MODULE '\nNUCMSG   DC    C'  FOUND IN NUCLEUS CSECT '\nNFMSG    DC    C'  NOT FOUND IN JPA, LPA OR NUCLEUS'\nERMSG    DC    C'  STORAGE ERROR - UNABLE TO FIND MODULE'\nLIMBOMS1 DC    C'  FOUND IN '\nLIMBOMS2 DC    CL4'    '\nLIMBOMS3 DC    C' MODULE '\nLIMBOMSG EQU   LIMBOMS1,*-LIMBOMS1,C'C'\nLIMBOFF  EQU   LIMBOMS2-LIMBOMS1\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IHACDE\n         EJECT\n         IHAXTLST\n         EJECT\n         IHALPDE\n         EJECT\n         IKJTCB\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=YITADDR\n         TITLE 'YITADDR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BASSM R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'YITADDR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *\n* REALLY A TCB ADDRESS AFTER ALL), RETURNS THE HEX ADDRESS AS A       *\n* CLIST VARIABLE.                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nYITADDR  CSECT\n         SAVE  (14,12),,YITADDR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING YITADDR,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\n* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.\n* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES\n* THE CORRECT ASID, ETC.\n         SPACE 1\n         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE\n         LR    R1,R4               GET ADDRESS OF ABDPL\n         MVI   YITHEX,C' '\n         MVC   YITHEX+1(L'YITHEX-1),YITHEX\n*\n* SET YITHEX = THE VALUE\n*\n         ST    R0,DOUBLE\n         UNPK  YITHEX(9),DOUBLE(5)\n         TR    YITHEX(8),HEXTBL\n         SPACE 1\nYITSET   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* OK, NOW INVOKE THE CLIST VARIABLE ACCESS FACILITY TO SET THE        *\n* VALUE AS A CLIST VARIABLE.                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R14,CENTRY\n         LA    R15,CNAMEA\n         LA    R0,CNAMEL\n         LA    R1,CVALUEA\n         LA    R2,CVALUEL\n         LA    R3,CTOKEN\n         STM   R14,R3,CPARM1\n         L     R1,ADPLCPPL\n         USING CPPL,R1\n         L     R1,CPPLECT\n         DROP  R1\n         ST    R1,CPARM7\n         OI    CPARM7,X'80'\n         LA    R0,TSVEUPDT\n         ST    R0,CENTRY\n         XR    R0,0\n         ST    R0,CNAMEA           ADDRESS OF VARIABLE NAME\n         ST    R0,CNAMEL           LENGTH OF VARIABLE NAME\n         ST    R0,CVALUEA          ADDRESS OF VARIABLE VALUE\n         ST    R0,CVALUEL          LENGTH OF VARIABLE VALUE\n*\n* SET YITHEX\n*\n         LA    R14,=C'YITHEX'\n         LA    R15,6\n         LA    R0,YITHEX\n         LA    R1,L'YITHEX\n         STM   R14,R1,CNAMEA\n         BAL   R2,CALL441\n*\n* RETURN TO CALLER\n*\n         B     RETURN0\n         SPACE 2\nCALL441  DS    0H\n         LA    R1,CPARM1           POINT TO PARAMETER LIST\n         L     R15,X'10'               GET ADDRESS OF CVT\n         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE\n         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441\n         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE\n         LTR   R15,R15             IF RETURN CODE IS ZERO\n         BZR   R2                  THEN EVERYTHING IS OK\n         MVC   LINE(L'ERR441),ERR441\n         CVD   R15,DOUBLE\n         UNPK  LINE+L'ERR441(2),DOUBLE\n         OI    LINE+L'ERR441+1,X'F0'\n         BAL   R14,OUTPUT\n         BR    R2\n         SPACE 2\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BASSM R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nERR441   DC    C'YITADDR: CLIST VARIABLE ACCESS FACILITY ERROR '\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION\nOUTSAVE  DS    A\n         SPACE 1\nCPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS\n         SPACE 1\nCPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE\nCPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME\nCPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME\nCPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE\nCPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE\nCPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)\nCPARM7   DS    A                   POINTER TO IPCS'S ECT\n         SPACE 1\nCENTRY   DC    A(TSVEUPDT)         ENTRY CODE FOR VARIABLE UPDATE\nCNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME\nCNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME\nCVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME\nCVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE\nCTOKEN   DC    A(0)                TOKEN (NOT USED)\n         SPACE 1\nYITHEX   DS    CL8                 VALUE OF CLIST VARIABLE\n         DS    CL4                 PADDING\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         EJECT\n         IKJTCB\n         EJECT\n         IKJTSVT\n         EJECT\n         IKJCPPL\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=YITSAV\n         TITLE 'YITSAV - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   ('&LENGTH' EQ '(0)').GOTLEN\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'YITSAV - IPCS TCB EXIT TO DISPLAY SAVE AREA TRACE'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3    DUMP STORAGE ACCESS REGISTER\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    ADDRESS OF PREVIOUS SAVE AREA (COMPARE WITH HSA)\nR8       EQU   8    TRUE ADDRESS OF CURRENT SAVE AREA\nR9       EQU   9    ADDRESS OF DATA WHERE SAVEAREA'S R15 POINTS\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nYITSAV   CSECT\n         SAVE  (14,12),,YITSAV_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING YITSAV,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ADDRESS OF ABDPL\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\nPROCESS  DS    0H\n         SPACE 1\n         LOAD  EP=XIPSWHR          LOAD ADDRESS SEARCH ROUTINE\n         ST    R0,WHRADDR\n         SPACE 1\n         XR    R7,R7               INITIALIZE HSA POINTER\n         ICM   R3,15,ADPLTCB       ADDRESS OF FIRST SAVE AREA\n         BNZ   LOOP                IF NONE, THEN...\n         MVC   LINE(L'NOSAMSG),NOSAMSG SAY SO\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 1\nLOOP     DS    0H\n         LTR   R3,R3               UNTIL NO MORE\n         BZ    ENDLOOP\n         MVC   LINE(L'SAMSG),SAMSG \"SAVE AREA AT \"\n         LR    R8,R3               TRUE ADDRESS OF THIS SAVE AREA\n         ST    R8,OPWORK           DISPLAY IT\n         UNPK  LINESAA+0(9),OPWORK(5)\n         TR    LINESAA+0(8),HEXTBL\n         MVI   LINESAA+8,C'.'\n         GSTOR R3,72,ERRET=SANA    GET SAVE AREA FROM DUMP\n         MVC   COPYSA(72),0(R3)    COPY INTO OUR WORK AREA\nCONTLOOP DS    0H\n         SPACE\n         MVC   LINEL1(4),=C'WD1='\n         UNPK  LINEN1(9),SAWD1(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'HSA='\n         UNPK  LINEN2(9),SAHSA(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'LSA='\n         UNPK  LINEN3(9),SALSA(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         BAL   R14,OUTPUT\n         C     R7,SAHSA            CHECK HSA POINTER\n         BE    HSAOK               IF IT DOESN'T MATCH, THEN...\n         MVC   LINEL1(L'IBCMSG),IBCMSG\n         BAL   R14,OUTPUT          NOTE INVALID BACK CHAIN\nHSAOK    DS    0H\n         LR    R7,R8               SET PREVIOUS-SAVE-AREA ADDRESS\n         MVC   LINEL1(4),=C'R14='\n         UNPK  LINEN1(9),SAR14(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         L     R0,SAR14\n         BAL   R14,FINDMOD         RESOLVE RETURN ADDRESS\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R15='\n         UNPK  LINEN1(9),SAR15(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         L     R0,SAR15\n         BAL   R14,FINDMOD         RESOLVE ENTRY ADDRESS\n         SPACE 1\n         L     R9,FMWHERE          ADDRESS THAT HAS BEEN RESOLVED\n         LTR   R9,R9               IF ZERO, IGNORE IT\n         BZ    NOEP\n         GSTOR R9,8,ERRET=NOEP     TRY TO GET ENTRY POINT DATA\n         ICM   R0,15,0(R9)         GET ENTRY POINT INSTRUCTION\n         N     R0,=X'FFFFF000'     AND OUT THE DISPLACEMENT\n         CL    R0,=X'47F0F000'     IF IT IS NOT A BRANCH-AROUND\n         BNE   NOEP                THEN NO EP DATA\n         XR    R2,R2               CLEAR INSERT REG\n         IC    R2,4(,R9)           GET LENGTH OF IDENTIFIER\n         LTR   R2,R2               IF ZERO\n         BZ    NOEP                THEN NO EP DATA\n         CH    R2,=Y(EPLENGTH)     SET MAXIMUM LENGTH THAT WE CAN SHOW\n         BNH   SETMAX\n         LA    R2,EPLENGTH\nSETMAX   DS    0H\n         LA    R9,4\n         A     R9,FMWHERE          POINT TO IDENTIFIER STUFF\n         LA    R0,1+3(,R2)         SET LENGTH+1 AND PREPARE TO...\n         N     R0,=X'FFFFFFFC'     ....ROUND UP TO FULLWORD BOUNDARY\n         GSTOR R9,(0),ERRET=NOEP   GET DATA FOR THE LENGTH NEEDED\n         MVC   LINEEP1(6),=CL6'AT EP '\n         BCTR  R2,0                REDUCE LENGTH FOR EXECUTE\n         EX    R2,EPMVC            TRANSLATE EP DATA\nNOEP     DS    0H\n         SPACE 1\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R0 ='\n         UNPK  LINEN1(9),SAR00(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R1 ='\n         UNPK  LINEN1(9),SAR01(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R2 ='\n         UNPK  LINEN2(9),SAR02(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R3 ='\n         UNPK  LINEN3(9),SAR03(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R4 ='\n         UNPK  LINEN4(9),SAR04(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         MVC   LINEL1(4),=C'R5 ='\n         UNPK  LINEN1(9),SAR05(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R6 ='\n         UNPK  LINEN2(9),SAR06(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R7 ='\n         UNPK  LINEN3(9),SAR07(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R8 ='\n         UNPK  LINEN4(9),SAR08(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         MVC   LINEL1(4),=C'R9 ='\n         UNPK  LINEN1(9),SAR09(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R10='\n         UNPK  LINEN2(9),SAR10(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R11='\n         UNPK  LINEN3(9),SAR11(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R12='\n         UNPK  LINEN4(9),SAR12(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         BAL   R14,OUTPUT          JUST A BLANK LINE\n         SPACE\n         L     R3,SALSA            GET ADDRESS OF NEXT SAVE AREA\n         B     LOOP                CONTINUE LOOPING\n         SPACE 1\nSANA     DS    0H                  SAVE AREA NOT AVAILABLE FROM DUMP\n         SPACE 1\n         MVC   LINE+L'SAMSG+08+2(L'SANAMSG),SANAMSG\n         BAL   R14,OUTPUT\n         B     ERROUT\n         SPACE 1\nENDLOOP  DS    0H\n         B     RETURN0\n         SPACE 2\nEPMVC    MVC   LINEEP2(0),1(R9)    EXECUTED\n         EJECT\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVC   LINE(L'ERRMSG),ERRMSG\n******** B     ERROUT\n         SPACE 1\nERROUT   DS    0H\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nFINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME\n*                                  R0 CONTAINS ADDRESS TO SEARCH ON\n         ST    R0,FMWHERE          STORE ADDRESS TO BE RESOLVED\n         LTR   R0,R0               IF ADDRESS IS ZEROES,\n         BZR   R14                 THEN PRINT NOTHING, NOT AN EP\n         ST    R14,FMSAVE\n         NI    FMWHERE,B'01111111' TURN OFF HIGH-ORDER BIT FOR ADDRESS\nFMDOIT   DS    0H\n         XR    R0,R0\n         ST    R0,ADPLCOM1\n         L     R0,FMWHERE\n         LR    R1,R4\n         L     R15,WHRADDR\n         BASSM R14,R15\n         CLI   ADPLFMT1,C' '\n         BE    FMNF\n         MVC   LINEMOD(16),ADPLCOM1\n         B     FMRET\nFMNF     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IF ADDRESS UNKNOWN, MAYBE THE HIGH-ORDER BYTE IS CONFUSING THE      *\n* ADDRESS SEARCH ROUTINE.  SO WE SET IT TO ZEROES AND TRY AGAIN.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   FMWHERE,X'00'       IF IT'S ALREADY A 24-BIT ADDRESS\n         BE    FMFAIL              THEN DON'T TRY AGAIN\n         MVI   FMWHERE,X'00'       ELSE CHANGE IT TO A 24-BIT ADDRESS\n         B     FMDOIT               TRY AGAIN WITH 0 IN H.O.BYTE\nFMFAIL   DS    0H                  ELSE GIVE UP\n         MVC   LINEMOD(16),=CL16'(UNKNOWN)       '\n         XC    FMWHERE,FMWHERE\nFMRET    DS    0H\n         L     R14,FMSAVE\n         BR    R14\n         EJECT\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         LTR   R15,R15             IF LINE NOT PRINTED\n         BNZ   RETURN0             THEN...\nNORETYET DS    0H\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         DELETE EP=XIPSWHR\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'\nNOSAMSG  DC    C'SAVEA AREA POINTER IS ZERO'\nIBCMSG   DC    C'*** INVALID BACK CHAIN ***'\nSANAMSG  DC    C'STORAGE UNAVAILABLE'\nSAMSG    DC    C'SAVE AREA AT '\n         SPACE\nVALTBL   DC    256YL1(1)\n         ORG   VALTBL+X'81'\n         DC    6YL1(0)             LOWER CASE ABCDEF\n         ORG   VALTBL+C'A'\n         DC    6YL1(0)             UPPER CASE ABCDEF\n         ORG   VALTBL+C'0'\n         DC    10YL1(0)            0123456789\n         ORG\n         SPACE\nFTBL     DC    256YL1(*-FTBL)\n         ORG   FTBL+X'81'\n         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF\n         ORG   FTBL+C'A'\n         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF\n         ORG\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nFMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE\nFMWHERE  DS    A                   ADDRESS PASSED TO FINDMOD SUBROUTINE\nWHRADDR  DS    A                   ADDRESS OF XIPSWHR, SEARCH ROUTINE\n         DS    XL1                 PADDING FOR CONVERSION\nOPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION\nCOPYSA   DS    18F                 WORK AREA FOR SAVE AREA\n         ORG   COPYSA\nSAWD1    DS    F                   00 = FIRST WORD\nSAHSA    DS    F                   04 = HSA\nSALSA    DS    F                   08 = LSA\nSAR14    DS    F                   0C = REG14\nSAR15    DS    F                   10 = REG15\nSAR00    DS    F                   14 = REG0\nSAR01    DS    F                   18 = REG1\nSAR02    DS    F                   1C = REG2\nSAR03    DS    F                   20 = REG3\nSAR04    DS    F                   24 = REG4\nSAR05    DS    F                   28 = REG5\nSAR06    DS    F                   2C = REG6\nSAR07    DS    F                   30 = REG7\nSAR08    DS    F                   34 = REG8\nSAR09    DS    F                   38 = REG9\nSAR10    DS    F                   3C = REG10\nSAR11    DS    F                   40 = REG11\nSAR12    DS    F                   44 = REG12\n         ORG\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         ORG   LINE\n         DS    CL(L'SAMSG)         \"SAVE AREA AT \"\nLINESAA  DS    CL8                 ADDRESS OF SAVE AREA\n         DS    CL2                 \"  \"\nLINEL1   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN1   DS    CL8                 \"NNNNNNNN\"\nLINEB1   DS    CL1                 \" \"\nLINEL2   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN2   DS    CL8                 \"NNNNNNNN\"\nLINEB2   DS    CL1                 \" \"\nLINEL3   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN3   DS    CL8                 \"NNNNNNNN\"\nLINEB3   DS    CL1                 \" \"\nLINEL4   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN4   DS    CL8                 \"NNNNNNNN\"\nLINEB4   DS    CL1                 \" \"\nLINEL5   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN5   DS    CL8                 \"NNNNNNNN\"\nLINEB5   DS    CL1                 \" \"\n         ORG   LINEL2\n         DS    CL1\nLINEMOD  DS    CL16                \"WHERE\" DATA\n         DS    CL1\nLINEEP1  DS    CL6                 \"AT EP \"\nLINEEP2  DS    CL(EPLENGTH)\n         SPACE 1\nEPLENGTH EQU   78-(LINEEP2-LINE)\n         ORG\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IKJTCB\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=YITWHR\n         TITLE 'YITWHR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'YITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *\n* REALLY A TCB ADDRESS AFTER ALL), REPORTS ON WHAT LOAD MODULE THE    *\n* ADDRESS LIVES IN AS WELL AS THE OFFSET.  UNLIKE THE XITWHR EXIT,    *\n* HOWEVER, THIS ROUTINE DOES NOT DISPLAY THE INFO, BUT RETURNS THE    *\n* VALUES AS CLIST VARIABLES (JEEZ, I HOPE THIS WORKS).                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    POINTER TO CDE\nR8       EQU   8    USED IN NUCMAP SCANNING\nR9       EQU   9    USED IN NUCMAP SCANNING\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nYITWHR   CSECT\n         SAVE  (14,12),,YITWHR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING YITWHR,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\n* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.\n* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES\n* THE CORRECT ASID, ETC.\n         SPACE 1\n         XR    R0,R0\n         ST    R0,ADPLCOM1         Clear communication word\n         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE\n         LR    R1,R4               GET ADDRESS OF ABDPL\n         SPACE 1\n         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE\n         SPACE 1\n         MVI   YITPLACE,C' '\n         MVC   YITPLACE+1(L'YITPLACE-1),YITPLACE\n         MVI   YITNAME,C' '\n         MVC   YITNAME+1(L'YITNAME-1),YITNAME\n         MVI   YITLOC,C' '\n         MVC   YITLOC+1(L'YITLOC-1),YITLOC\n*\n* SET YITPLACE = THE AREA WHERE IT WAS FOUND: JPA/PLPA/MLPA/NUC/ERR\n*\n         MVC   YITPLACE(4),ADPLFMT1\n         CLI   YITPLACE,C' '\n         BE    YITERROR\n         CLI   YITPLACE,C'E'\n         BE    YITERRNP\n         B     YITOK\nYITERROR DS    0H                  ERROR - MODULE NOT FOUND\n         MVC   YITPLACE(11),=C'UNAVAILABLE'\nYITERRNP DS    0H                  STORAGE ERROR - RETAIN YITPLACE\n         MVC   YITNAME(11),=C'UNAVAILABLE'\n         MVC   YITLOC(11),=C'UNAVAILABLE'\n         B     YITSET\nYITOK    DS    0H\n*\n* SET YITNAME = THE NAME OF THE LOAD MODULE\n*\n         MVC   YITNAME(8),ADPLCOM1\n*\n* SET YITLOC = THE OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE\n*\n         L     R0,ADPLFMT2\n         CVD   R0,DOUBLE\n         UNPK  YITLOC(10),DOUBLE\n         OI    YITLOC+9,X'F0'\n         SPACE 1\nYITSET   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* OK, NOW INVOKE THE CLIST VARIABLE ACCESS FACILITY TO SET THE        *\n* THREE VALUES AS CLIST VARIABLES.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R14,CENTRY\n         LA    R15,CNAMEA\n         LA    R0,CNAMEL\n         LA    R1,CVALUEA\n         LA    R2,CVALUEL\n         LA    R3,CTOKEN\n         STM   R14,R3,CPARM1\n         OI    CPARM6,X'80'\n         LA    R0,TSVEUPDT\n         ST    R0,CENTRY\n         XR    R0,0\n         ST    R0,CNAMEA           ADDRESS OF VARIABLE NAME\n         ST    R0,CNAMEL           LENGTH OF VARIABLE NAME\n         ST    R0,CVALUEA          ADDRESS OF VARIABLE VALUE\n         ST    R0,CVALUEL          LENGTH OF VARIABLE VALUE\n*\n* SET YITPLACE\n*\n         LA    R14,=C'YITPLACE'\n         LA    R15,8\n         LA    R0,YITPLACE\n         LA    R1,L'YITPLACE\n         STM   R14,R1,CNAMEA\n         BAL   R2,CALL441\n*\n* SET YITNAME\n*\n         LA    R14,=C'YITNAME'\n         LA    R15,7\n         LA    R0,YITNAME\n         LA    R1,L'YITNAME\n         STM   R14,R1,CNAMEA\n         BAL   R2,CALL441\n*\n* SET YITLOC\n*\n         LA    R14,=C'YITLOC'\n         LA    R15,6\n         LA    R0,YITLOC\n         LA    R1,L'YITLOC\n         STM   R14,R1,CNAMEA\n         BAL   R2,CALL441\n*\n* RETURN TO CALLER\n*\n         B     RETURN0\n         SPACE 2\nCALL441  DS    0H\n         LA    R1,CPARM1           POINT TO PARAMETER LIST\n         L     R15,X'10'               GET ADDRESS OF CVT\n         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE\n         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441\n         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE\n         LTR   R15,R15             IF RETURN CODE IS ZERO\n         BZR   R2                  THEN EVERYTHING IS OK\n         MVC   LINE(L'ERR441),ERR441\n         CVD   R15,DOUBLE\n         UNPK  LINE+L'ERR441(2),DOUBLE\n         OI    LINE+L'ERR441+1,X'F0'\n         BAL   R14,OUTPUT\n         BR    R2\n         SPACE 2\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nERR441   DC    C'YITWHR: CLIST VARIABLE ACCESS FACILITY ERROR '\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION\nOUTSAVE  DS    A\n         SPACE 1\nCPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS\n         SPACE 1\nCPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE\nCPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME\nCPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME\nCPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE\nCPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE\nCPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)\n         SPACE 1\nCENTRY   DC    A(TSVEUPDT)         ENTRY CODE FOR VARIABLE UPDATE\nCNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME\nCNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME\nCVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME\nCVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE\nCTOKEN   DC    A(0)                TOKEN (NOT USED)\n         SPACE 1\nYITPLACE DS    CL11                VALUE OF CLIST VARIABLE\nYITNAME  DS    CL11                VALUE OF CLIST VARIABLE\nYITLOC   DS    CL11                VALUE OF CLIST VARIABLE\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IHACDE\n         EJECT\n         IHAXTLST\n         EJECT\n         IHALPDE\n         EJECT\n         IKJTCB\n         EJECT\n         IKJTSVT\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ENDUP\n?!\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NNMVS": {"ttr": 15879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99)\\x9f\\x00\\x99)\\x9f \\tu\\x00u\\x00\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-10-26T00:00:00", "modifydate": "1999-10-26T20:09:00", "lines": 29952, "newlines": 29952, "modlines": 0, "user": "SEB"}, "text": "//JOBNAME JOB ACCOUNT,'NAME'\n//*------------------------------------------------------------------*/\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis. All warranties,   */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed. Such modifications should  */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*------------------------------------------------------------------*/\n//*\n//*    NNMVS - MVS NNTP News Reader\n//*\n//*  Version: 3  Release: 2\n//*\n//* Author: Steve Bacher <seb@draper.com>\n//*\n//* Date: 13 Aug 1993\n//*\n//*-------------------------------------------------------------------\n//*\n//* This job creates the distribution libraries (PDS's).\n//*\n//* Run this JCL to create the PDS's, after customizing to suit.\n//* (Obviously, put in a good JOB statement first.)\n//* To customize the JCL, change the defaults on the //MDLOAD PROC\n//* statement to your liking, particularly the PREFIX default.\n//* You might also want to change the final qualifiers of the PDS's\n//* created - to do this, find the // EXEC MDLOAD statements and\n//* change the value of the TO parameter.\n//*\n//* See the $$README file (of the CNTL PDS, first in this stream)\n//* for the rest of the installation instructions.\n//*\n//MDLOAD PROC CLS='*',BS='6160',U='3380',V='',\n//      TRK1='60',TRK2='10',DIR='35',RLSE='RLSE',\n//      PREFIX='NNMVS.INSTALL.'\n//*\n//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=&CLS\n//SYSUT2 DD DISP=(NEW,CATLG,DELETE),DSN=&PREFIX.&TO,\n//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=&BS),\n//  SPACE=(TRK,(&TRK1,&TRK2,&DIR),&RLSE),UNIT=&U,VOL=SER=&V\n//*\n//  PEND\n//*\n//CNTL     EXEC MDLOAD,BS='6160',TRK1='10',TRK2='1',TO='CNTL'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=$$README\n\n------------------------------------------------------------------------\n\n Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992, 1993\n\n SAS enhancements copyright (c) 1992 SAS Institute, Inc.\n\n This software is provided on an \"AS IS\" basis.  All warranties,\n including the implied warranties of merchantability and fitness,\n are expressly denied.\n\n Provided this copyright notice is included, this software may\n be freely distributed and not offered for sale.\n\n Changes or modifications may be made and used only by the maker\n of same, and not further distributed.  Such modifications should\n be mailed to the author for consideration for addition to the\n software and incorporation in subsequent releases.\n\n------------------------------------------------------------------------\n\n MVS NNTP News Reader - Version 3 Release 2\n\n Author:          Steve Bacher <seb1525@mvs.draper.com>\n Enhancements by: Dale Ingold  <snoddi@mvs.sas.com>\n\n------------------------------------------------------------------------\n\n New Features and Changes in member $CHANGES of the distribution.\n\n------------------------------------------------------------------------\n\n Contents of PDS's belonging to NNMVS distribution:\n\n Member     PDS Type    Description\n\n $$README   CNTL        This file\n $CHANGES   CNTL        New features and changes\n $MISC      CNTL        Miscellaneous gotchas and installation notes\n ALLOAD     CNTL        JCL to allocate NNMVS load and object libraries\n AUTH       CNTL        Sample server authorization file\n COMPILE    CNTL        JCL to compile *** SOURCE DISTRIBUTION ONLY ***\n GRAMMAR    CNTL        Description of NNMVS batch expression syntax\n HELP       CNTL        Description of NNMVS batch language\n LINK       CNTL        JCL to linkedit the load module\n NNMVS      CNTL        JCL to run NNMVS in batch\n NNMVSHLP   CNTL        TSO HELP for the NNMVSP version of the exec\n NNMFIUCV   CLIST       Exec to check for multiple socket applications\n NNMVS      CLIST       Exec by which users invoke the news reader\n NNMVSC     CLIST       CLIST by which users invoke the news reader\n NNMVSL     CLIST       CLIST to run multiple-news-server ISPF dialog\n NNMVSP     CLIST       Exec using XPROC to parse CLIST-style parms\n NNMMAIL    CLIST       Exec called by news reader to send mail\n NNM...     PANEL       ISPF regular panels\n TNNM...    PANEL       ISPF tutorial panels\n NNM..      H           C headers      *** SOURCE DISTRIBUTION ONLY ***\n NNM..      C           C source       *** SOURCE DISTRIBUTION ONLY ***\n NN...      OBJ         Object modules *** OBJECT DISTRIBUTION ONLY ***\n\n--------------------------------------------------------------------\n\n Directions:\n\n Assuming the PDS's have been created:\n\n 1. Customize the ALLOAD and COMPILE JCL members to reflect your\n local conventions.  Note:  If you intend to place the executable into\n an existing library, you can suppress that part of the ALLOAD JCL.\n The name of the data set created must match across both members.\n\n 2. Customize the NNUSER header file as shown by the comments therein.\n Note in particular the defines for your TCP/IP and your C compiler.\n There are changes to the linkedit JCL that are related to these.\n\n 3. Choose which exec you want to use:\n\n    NNMVS - the traditional REXX exec, not much parameter passing\n    NNMVSP - REXX exec that uses XPROC to parse CLIST-style parms\n    NNMVSC - CLIST that accepts CLIST-style parameters\n\n If you don't have XPROC (the utility that allows a REXX exec to parse\n CLIST-style parameters), you can get it from ftp.mic.ucla.edu in the\n directory /pub/mvs/utils, part of the TSOREXX distribution.  I highly\n recommend that you get the TSOREXX distribution, which contains both\n XPROC and XWRITENR, if you do a lot of conversion from CLIST to REXX.\n\n If you really can't or won't get XPROC, you can use the CLIST, but\n keep in mind that there are some things the CLIST just can't do that\n the REXX exec can.  Refer to the comments therein for more details.\n\n Customize whichever of the above you pick to define the names of the\n MVS libraries to contain the panel and load library members.  The load\n library must be the one specified in the ALLOAD JCL, if you are\n creating it anew.  Observe the comments relating to the use of LIBDEF\n and ISPF APPLIDs.\n\n Note that if you install one of the REXX execs, you must also install\n the NNMFIUCV exec in the same library.  This exec implements a crude\n check for an existing TCP/IP socket application (e.g. another NNMVS)\n in a different PIE MultiTSO session.  It prevents your users from\n crashing TCP/IP, so it is highly recommended that you make use of it.\n\n 4. Customize the NNMMAIL exec to invoke your local mailer, or\n otherwise insure that messages sent via MAIL or REPLY arrive at their\n intended destination.\n\n 5. If you are running ISPF Version 2 or earlier, edit the NNMVS panels\n whose names begin \"NNMP...\".  These are popups, and will not work\n under ISPF Version 2 unless you change the )BODY line.  Remove the\n WINDOW(...) parameter from the )BODY line of each panel so that the\n line just says )BODY or )BODY EXPAND(``), as the case may be.\n\n Note:  You may wish to customize the TNNMSERV tutorial panel to\n include the names of all available NNTP servers at your site.\n\n Now, to install:\n\n 6. Submit the ALLOAD JCL to allocate the load library from which the\n executable program will be run, as well as the object library in which\n the compiled object modules will be stored.\n\n 7. Submit the COMPILE JCL to compile all the C sources and create the\n required object modules in the object library built in the above step.\n\n 8. Submit the LINK JCL to create the executable NNMVS load module\n from the object modules created in the above step.  This will create\n or replace the load module NNMMAIN.\n\n Note:  The linkedit must complete with a return code of zero.  If not,\n don't use the resultant load module.  Check the libraries you specified\n on the link step to see what went wrong.\n\n In the future, if you have to recompile individual modules, you can use\n the same JCL to compile only those modules, and the link will include\n the new modules in the existing executable load module.  To do this,\n you must retain the object library built above.\n\n *********************************************************************\n\n IMPORTANT:  If you are running TCP/IP V2R2 or higher on MVS, you must\n change the following library names in the compile and link JCL:\n\n   TCPIP.COMMMAC   should be changed to  TCPIP.SEZACMAC\n   TCPIP.COMMTXT   should be changed to  TCPIP.SEZACMTX\n\n *********************************************************************\n\n Note:  If you have defined C370V1 in the NNUSER header file, you must\n also include the system linklist load library or libraries containing\n ISPLINK, ISPEXEC and IKJEFF18 when linking.  Otherwise you may delete\n the lines from the linkedit JCL that reference them.\n\n Note:  You need not include the PASCAL libraries or the AMPZMVSB\n module if you are using TCP/IP Version 2 or higher, in which case\n you must also define TCPIPV2 in the NNUSER headerfile.\n\n 9. Copy the HELP member of the CNTL library into the data set which\n will be allocated to ddname NNBATHLP by the NNMVS batch mode JCL\n procedure.  This data set contains the text printed by the batch HELP\n command.  The distributed proc calls this 'NNMVS.HELP' - change it to\n match the name of your data set (sequential, or member of a PDS).\n\n 10. Copy the NNMVS (or NNMVSC or NNMVSP) and NNMMAIL execs into your\n installation CLIST or REXX library.  Also copy the NNMVSL exec if\n you want access to Leonard Woren's experimental multiple-server dialog.\n\n 11. If you use the NNMVSP version of the exec, copy the NNMVSHLP\n member of the CNTL PDS into your installation TSO HELP library\n under the same name as you gave the exec, so folks can type HELP xxx\n where xxx is the name of the exec.  If you have local help that you\n want to include (like names of local servers, posting guidelines,\n or whatever), create a HELP member called NNMVSLOC and install it\n in the same library.\n\n 12. Copy all the members of the panel PDS into the ISPF panel library\n specified in the NNMVS exec.\n\n--------------------------------------------------------------------\n\n Note:  Make sure that the C/370 run time library is available,\n either in the system link list or in the ISPLLIB concatenation,\n before attempting to run NNMVS.\n\n If the C/370 runtime library is not in the link list or otherwise\n available to ISPF at execution time, you may arrange for it to be\n allocated via LIBDEF in the NNMVS exec (I haven't tried this).\n\n--------------------------------------------------------------------\n\n Questions?  Comments?  Suggestions?  Gripes?  Requests?  Musings?\n\n You can communicate all of these via the LISTSERV mailing list\n NNMVS-L, maintained at VM.USC.EDU.  To get on this list, send mail to\n LISTSERV@USCVM (or LISTSERV@VM.USC.EDU) with the following line in\n the message body:\n\n   SUBSCRIBE NNMVS-L firstname lastname\n\n Please keep in mind that further requests (e.g. to unsubscribe from\n the list) must be sent to the LISTSERV address, *not* to the list.\n The response you'll get from the SUBSCRIBE message will tell you\n about this and more - so be sure to save it.\n\n--------------------------------------------------------------------\n\n Please email all other correspondence to...\n\n Steve Bacher      <seb@draper.com>\n\n./ ADD NAME=$CHANGES\n\n New Features in V3 R2\n\n  New commands:\n\n   ROT13 (while viewing an article) toggles \"rot13\" encoding on and off.\n\n   RESCAN (from newsgroup or article display) updates the status of\n          all newsgroups by refetching the server's active file\n\n  New selection codes:\n\n   $ on a newsgroup fetches unread articles and sorts them by subject\n\n   @ on a newsgroup fetches all articles and sorts them by subject\n\n  Miscellaneous improvements:\n\n   more accurate locked \"getting more articles\" displays\n\n   fixed bug going to next article and following the subject thread\n\n New Features in V3\n\n  Newsgroup article management is radically different, which should\n  result in improvements in response time and memory usage, as well\n  as avoiding out-of-memory abends.\n\n  A new pseudo-browse interface replaces the BRIF code, enabling\n  more commands while browsing a news article.\n\n  The PRT command is implemented, similar to EXTRACT except that it\n  prints to the SYSOUT class of your choice.\n\n  You have the option of letting the cursor remain next to the most\n  recently selected newsgroup or article.\n\n  New commands to simplify debugging have been added.\n\n  Additional installation-time customization for different levels\n  of ISPF.\n\n  Miscellaneous bug fixes and feature tweaks.\n\n Latest Fixes to V2 R4\n\n NNMCLRNG.C: - Fix memory leak when exiting from NNMVS.\n\n NNMDLANG.C: - Fix 0C4 in \"new newsgroups\" function when the server\n               has duplicate entries in the active.times file.\n\n             - Check for bad output from news server's active file\n               in the NNTP LIST command, adjust counts and display a\n               nasty message so the user can nag the administrator.\n\n NNMBPEXT.C: - Fix bug whereby all article headers were being\n               retrieved even when EXTRACT UNREAD was requested\n               in a batch job, causing excessive resource usage\n               and memory blowouts.\n\n New Features In V2 R4\n\n * Memory usage has been improved significantly.\n\n * Handling of missing/expired articles has been improved.\n\n * Miscellaneous Bug Fixes\n\n * Enhancements to NNMVSP Exec\n\n New Features In V2 R3 M2\n\n * New commands:\n\n - SORT Subject / Number - in article viewing mode, you may use this\n   command to sort the article display by subject or return it to the\n   default article-number order.  Note that this may require a lot of\n   processing, both to retrieve article titles and to perform the\n   sorting, which tries to match messages up with \"re:\" replies.\n   When the LOCATE command is issued from an article display in this\n   mode, it takes a character string rather than a number.\n\n - QUIT - from almost any panel, terminates NNMVS immediately.\n   It works like repeated END's, which means that it will save\n   your NEWSRC file.  (QUIT from display-new-newsgroups or\n   display-bogus-newsgroups skips updating NEWSRC, though, for\n   your protection.)\n\n * Miscellaneous changes:\n\n   The MARKALL and UNMARKALL commands now prompt you as to whether\n   you want to mark all the articles in the newsgroup or just the\n   ones currently shown in the table.\n\n * The extra blank line that used to appear at the bottom of articles\n   is gone.  There may be some effects on article extraction,\n   particularly when append mode is used, but in general this means\n   that what you get is more like what is really out there.\n\n * In POST and MAIL, the format of the inserted message and the\n   dashed line separating the signature from the body have been\n   changed to be more in accordance with standard practice.\n\n * Even more tweaking of missing article handling.  It's better\n   than it was, and may even be considered acceptable now.\n\n * Removed Features\n\n   Apologies:  The PATH variable in batch has been removed.\n   It was of dubious value (I'm sure you don't miss it).\n   Basically, we needed the slot to implement subject sorting.\n\n New Features In V2 R3 M1\n\n * A user option to turn automatic scrolling on or off in the\n   newsgroup and article display tables has been added.\n\n * In POST and MAIL, headers are no longer inserted into the text of\n   your reply.  Instead, a message of the form\n    \"In article <messageid> on <date>, <author> writes:\"\n   is inserted.\n\n * Remaining bugs and pitfalls of missing articles are finally\n   cleared up (hopefully).\n\n * The ONLY and FIND commands in article display mode will cause\n   fetching of article headers if you are in \"A\" (all articles) mode.\n\n * An OPTION operand has been added to the NNMVS exec, and support has\n   been added to NNMVS so that you will go directly to the requested\n   option if you use this and provide a number of other values.\n\n * An attempt to protect users from crashing TCP/IP with multiple\n   copies of socket applications is included.\n\n New Features In V2 R3\n\n * New Commands for Controlling Newsgroup and Article Displays\n\n   Note: In the following descriptions of operands, \"strings\" are\n   unquoted single words or strings quoted with either single or double\n   quotes.  Case is ignored.\n\n   The following new commands are available on the newsgroup display:\n\n     ORDER {Alphabetic/List} - specify the order in which the groups are\n     listed.  The initial setting is A (alphabetic).  You may change to\n     L (list) to view the newsgroups in the same order as the NNTP\n     server's active file (what the NNTP \"LIST\" command returns).\n\n     ONLY \"string\" - limit the newsgroup display to newsgroups with\n     \"string\" in the name.  Type ONLY with no operands to restore\n     the display to all newsgroups (or registered, depending).\n\n     FIND \"string\" {NEXT/PREV/FIRST/LAST} - position the newsgroup\n     display to the next, previous, first or last group which has\n     \"string\" in the name.  FIND with no operands repeats the find.\n\n   The following new commands are available on the article display:\n\n     ONLY \"string\" - limit the article display to articles with\n     \"string\" in the subject.  Type ONLY with no operands to restore\n     the display to all articles (read or unread, depending).\n\n     FIND \"string\" {NEXT/PREV/FIRST/LAST} - position the article\n     display to the next, previous, first or last article which has\n     \"string\" in the subject.  FIND with no operands repeats the find.\n\n * New Options for Navigating Article Views\n\n   The following new commands are available from article browse:\n\n     NEXTU or NU - like NEXT but goes to the next unread article.\n\n     NEXTT or NT - like NEXT but goes to the next article currently in\n                   the table.  When you use ONLY to filter the article\n                   display, NEXTT honors the filter.  NEXT doesn't.\n\n     NEXTS or NS - like NEXT but goes to the next article in the current\n                   subject thread.\n\n     PREVU(PU), PREVT(PT), PREVS(PS) are analogous to the above.\n\n     FIRSTSUBJ or FS - goes to the first article in the current\n                       subject thread.\n     LASTSUBJ or LS  - goes to the last article in the current\n                       subject thread.\n     NEWSUBJ or NS   - goes to the first unread article of a subject\n                       other than the current thread.\n     SUBJECT or SUBJ - displays or changes the current subject.\n\n * Prompting to Protect Existing Data Sets on EXTRACT\n\n   When you use the EXTRACT command, if the data set already exists\n   you will get a pop-up asking you to confirm that you want to\n   reuse the data set.  Simply press ENTER to do so.\n\n * Changes To Commands\n\n   The NNTP command may now be specified like this:\n\n     NNTP   - by itself, puts you in the NNTP panel, as before\n     NNTP nntp-command   - executes NNTP command immediately\n\n     For example:  NNTP GROUP COMP.LANG.LISP\n                   NNTP HELP\n\n   The OPTIONS command has been changed to take you to a menu of\n   general options.  The RFC822 header settings are now option 1.\n   You can type OPT 1 to go directly there if you don't want to\n   see the extra panel.  Also, in BROWSE, you can type HEADERS\n   (or HEADER) instead of OPTION to go directly to the RFC822\n   header setting panel.\n\n   In addition to RFC822 header display options, you may now specify\n   how you want screen displays to tell you about operations in process.\n   (There are some fancy new ways that NNMVS can do this.)\n   You can also control the prompting for overwriting on EXTRACT.\n\n * Changes to Selection Codes\n\n   When you select \"A\" to see all the articles in a newsgroup,\n   NNMVS will fill in the title lines.  No more empty lines.\n   To save processing, it will get only those that are necessary\n   to fill your screen.  Scrolling down (or up) will get the next\n   batch - this will appear to be slower.\n\n   Also, only those articles that have actually been fetched (not\n   just the headers) will be retained in the table when you switch\n   back to using \"S\" to look at the articles in the newsgroup.\n\n   Note that whether you select \"A\" or \"S\" will affect subject\n   searches.  If you selected \"S\", subject searches will be limited\n   to unread or already-retrieved articles.  If you selected \"A\",\n   subject searches will retrieve previously read articles, and\n   potentially take longer.\n\n   You can select \"N\" to view only new (unseen) articles.  \"N\" is\n   like \"S\" except that articles are removed from the display once\n   they are read whenever you reenter the article display or change\n   the viewing criteria.\n\n   The \"Z\" option, which will remain undocumented for now, is similar\n   to the \"A\" option except that it retrieves NO articles headers,\n   read or unread.  Good for quick entry into a huge newsgroup, but\n   not very good at recording the correct status of the articles.\n\n   You can select \"C\" to cancel an article by posting a control request\n   to the server.  You must be the original author (poster) of the\n   article to be allowed to cancel it.  Cancellation is implemented\n   by sending a control message to the NNTP server.\n\n * POST, FOLLOWUP and REPLY now allow you to specify a Reply-to email\n   address and a signature file.  In addition, you may specify a\n   Followup-to list of newsgroups on POST or FOLLOWUP.\n\n * FOLLOWUP and REPLY now follow the RFC1036 rules for generating\n   the default lists of newsgroups to post to and mail address to\n   reply to.  FOLLOWUP even checks if the Followup-to: header says\n   \"poster\" or contains an email address, and strongly suggests\n   that you email instead of posting.  Since BITNET postings dont\n   conform to RFC standards, the actual From: address is displayed\n   for REPLY in case you need to type it in.\n\n * New Batch mode variable CHECKPOINT allows you to control whether the\n   NEWSRC file gets rewritten on every change or just at the end of a\n   batch run.  Good for preventing NEWSRC wipeouts on 322 abends.\n\n * Support for Multiple NNMVS's in a Single TSO Session\n   (assuming that they're talking to two different servers and\n   that you have the required TCP/IP multitasking socket support\n   APAR from IBM).\n\n   Basically, it dynamically generates a ddname for the newsrc file,\n   and you can specify different newsrc files, so there you go.\n\n   Warning:  PIE users - DO NOT run 2 NNMVS's from different PIE\n   sessions - the IBM TCP/IP fix doesn't work for this!  Use ISPF\n   split screen to do it.\n\n * Optional Driver CLIST and REXX exec using XPROC to specify\n   parameters in CLIST-style Syntax\n\n   See installation instructions for details.\n\n./ ADD NAME=$MISC\n\nMiscellaneous Notes and Gotchas\n\n========================================================================\n\n * C/370 Kanji Feature\n\n If your C/370 was not installed properly (e.g. you assumed that CBIPO\n would take care of everything - you wretched fool!), it is possible\n that you have the wrong national language for messages.  This will\n become apparent as soon as you fail to open a file, since the C/370\n perror() function will write gibberish to stderr.  To fix this, bug\n your MVS systems programmer to reinstall C/370, e.g. with JDL1214\n and without JCLB212 (for V2R1).  It may be more complicated than that.\n\n========================================================================\n\n * C/370 Attention Handling\n\nC/370 doesn't handle PA1 (attention) interrupts properly - in fact,\nit completely screws them up, so you end up in an unbreakable loop\nwhen you try to break out of a C/370 application running under ISPF\nthat uses the TCP/IP socket library.\n\nAs a temporary circumvention, you should apply a zap to module IBMBLIIA\nin your run-time load library.  The zap for C/370 V2R1, for example,\nlooks like this:\n\n   NAME IBMBLIIA IBMBLII1\n   VER 2250 0A60\n   REP 2250 1BFF\n\n  I.E., find the SVC 96 (STAX) instruction and NOP it.\n\n  Go ahead and apply it (preferably to a copy of IBMBLIIA in a user\n  library from which you run your favorite C/370 application, like\n  NNMVS, for example).  Now you can feel free to do anything you like,\n  because you can always attention out.\n\n  If you find that you need this zap, please make sure that IBM hears\n  from you about the problem.   The more customers they hear from, the\n  more likely it is that something will be done to fix it.\n\n  Be aware that this turns off attention handling entirely - but this\n  has turned out to be the only desirable behavior.  Note that SIGINT\n  handling has never worked in C/370.  If you don't believe this, then\n  just compile and run the sample program in member SIGFAIL.\n\n./ ADD NAME=ALLOAD\n//JOBNAME  JOB ACCOUNT,'NAME'\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//* Allocate NNMVS load and object libraries before install\n//*\n//NNALLOC PROC U='3380',V=''\n//*\n//IEFBR14  EXEC PGM=IEFBR14\n//ALLOCDD  DD   DISP=(NEW,CATLG,DELETE),DSN=&LIB,\n//         DCB=(RECFM=&RF,LRECL=&LR,BLKSIZE=&BS),\n//         SPACE=(&BS,(&PRI,&SEC,&DIR)),UNIT=&U,VOL=SER=&V\n//*\n//         PEND\n//*\n//* The ALLOCL step allocates the load library from which the\n//* executable program will be run.  If you intend to place the\n//* executable into an existing library, you can skip this step.\n//* Otherwise, the name must match the name used on the LOADLIB\n//* parameter of the NNLINK procedure in the COMPILE JCL.\n//*\n//* The ALLOCO step allocates the object library into which the\n//* source modules will be compiled.  This library is required\n//* for the compile and link steps, but is not required for run\n//* time execution.  However, you may wish to keep the object\n//* library around in case there are fixes for which you will be\n//* recompiling individual NNMVS source modules.\n//*\n//ALLOCL   EXEC NNALLOC,PRI=50,SEC=50,DIR=35,RF=U,LR=,BS=6233,\n//         LIB='NNMVS.LOAD'\n//ALLOCO   EXEC NNALLOC,PRI=500,SEC=100,DIR=70,RF=FB,LR=80,BS=2960,\n//         LIB='NNMVS.INSTALL.OBJ'\n//*\n./ ADD NAME=AUTH\n#\n# This file is used by NNTP clients (NNMVS) on this system to connect\n# to news servers that require authentication, according to the new\n# NNTO authorization protocol.  It is ignored if the news server does\n# not support this protocol.  If the news server supports it, the user\n# must be defined in the server host's /etc/passwd file and its uid\n# must be the same as the uid of the user \"nntp\" - otherwise the server\n# will disconnect the client.\n#\n# A server given here without a user or password will be accepted\n# by NNMVS without an attempt to gain the server's authorization.\n#\n# serverhost  user  password\n#\n  AUTHHOST    NNTP  JOSHUA\n  NOAUTHHOST\n./ ADD NAME=COMPILE\n//JOBNAME  JOB ACCOUNT,'NAME'\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*********************************************************************\n//*\n//* Compile some or all NNMVS C/370 sources to make the SYSLIN input\n//* to the linkedit of the executable NNMMAIN load module.\n//*\n//NNCCL  PROC MEMBER=,\n//            SRCLIB='NNMVS.INSTALL.C',          NNMVS C source PDS\n//            HDRLIB='NNMVS.INSTALL.H',          NNMVS C headers PDS\n//            OBJLIB='NNMVS.INSTALL.OBJ',        NNMVS C headers PDS\n//            COMMHDR='TCPIP.COMMMAC',           C/370 TCP/IP headers\n//            C370HDR='SYS1.EDCHDRS',            C/370 standard headers\n//            SYSMSGS='SYS1.EDCMSGS',            C/370 messages file\n//            SYSMSGM='EDCMSGE',                 C/370 message member\n//            VIOUNIT=VIO,                       Temporary disk unit\n//            OUTCLAS='*',                          SYSOUT class\n//            CPARMS='SOURCE EXPMAC NOAGGR NOXREF', Compile parameters\n//            TEST=TEST                             TEST or NOTEST\n//*\n//CCOMP     EXEC PGM=EDCCOMP,PARM='MARGINS(1,72) &TEST &CPARMS'\n//SYSMSGS   DD DISP=SHR,DSN=&SYSMSGS(&SYSMSGM)\n//SYSIN     DD DISP=SHR,DSN=&SRCLIB(&MEMBER)\n//SYSLIN    DD DISP=OLD,DSN=&OBJLIB(&MEMBER)\n//SYSLIB    DD DISP=SHR,DSN=&COMMHDR\n//          DD DISP=SHR,DSN=&C370HDR\n//USERLIB   DD DISP=SHR,DSN=&HDRLIB\n//SYSPRINT  DD SYSOUT=&OUTCLAS\n//SYSCPRT   DD SYSOUT=&OUTCLAS\n//SYSUT1    DD DSN=&&SYSUT1,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT4    DD DSN=&&SYSUT4,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT6    DD DSN=&&SYSUT6,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT7    DD DSN=&&SYSUT7,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT8    DD DSN=&&SYSUT8,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT9    DD DSN=&&SYSUT9,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)\n//SYSUT10   DD SYSOUT=&OUTCLAS\n//*\n//         PEND\n//*\n//NNMADDNG EXEC NNCCL,MEMBER=NNMADDNG\n//NNMADJUA EXEC NNCCL,MEMBER=NNMADJUA\n//NNMALLAV EXEC NNCCL,MEMBER=NNMALLAV\n//NNMALLOC EXEC NNCCL,MEMBER=NNMALLOC\n//NNMAUTH  EXEC NNCCL,MEMBER=NNMAUTH\n//NNMBATCH EXEC NNCCL,MEMBER=NNMBATCH\n//NNMBBEXP EXEC NNCCL,MEMBER=NNMBBEXP\n//NNMBCONN EXEC NNCCL,MEMBER=NNMBCONN\n//NNMBDECL EXEC NNCCL,MEMBER=NNMBDECL\n//NNMBFLUS EXEC NNCCL,MEMBER=NNMBFLUS\n//NNMBGCMD EXEC NNCCL,MEMBER=NNMBGCMD\n//NNMBGDO  EXEC NNCCL,MEMBER=NNMBGDO\n//NNMBGEXP EXEC NNCCL,MEMBER=NNMBGEXP\n//NNMBGTOK EXEC NNCCL,MEMBER=NNMBGTOK\n//NNMBPDEC EXEC NNCCL,MEMBER=NNMBPDEC\n//NNMBPDER EXEC NNCCL,MEMBER=NNMBPDER\n//NNMBPELS EXEC NNCCL,MEMBER=NNMBPELS\n//NNMBPEXE EXEC NNCCL,MEMBER=NNMBPEXE\n//NNMBPEXT EXEC NNCCL,MEMBER=NNMBPEXT\n//NNMBPFOR EXEC NNCCL,MEMBER=NNMBPFOR\n//NNMBPHEL EXEC NNCCL,MEMBER=NNMBPHEL\n//NNMBPIF  EXEC NNCCL,MEMBER=NNMBPIF\n//NNMBPLIS EXEC NNCCL,MEMBER=NNMBPLIS\n//NNMBPMAR EXEC NNCCL,MEMBER=NNMBPMAR\n//NNMBPNNT EXEC NNCCL,MEMBER=NNMBPNNT\n//NNMBPPUT EXEC NNCCL,MEMBER=NNMBPPUT\n//NNMBPQUE EXEC NNCCL,MEMBER=NNMBPQUE\n//NNMBPQUI EXEC NNCCL,MEMBER=NNMBPQUI\n//NNMBPREG EXEC NNCCL,MEMBER=NNMBPREG\n//NNMBPSET EXEC NNCCL,MEMBER=NNMBPSET\n//NNMBPVAR EXEC NNCCL,MEMBER=NNMBPVAR\n//NNMBSOUT EXEC NNCCL,MEMBER=NNMBSOUT\n//NNMBSYNT EXEC NNCCL,MEMBER=NNMBSYNT\n//NNMBTEXT EXEC NNCCL,MEMBER=NNMBTEXT\n//NNMBTRAS EXEC NNCCL,MEMBER=NNMBTRAS\n//NNMBVGET EXEC NNCCL,MEMBER=NNMBVGET\n//NNMBVPUT EXEC NNCCL,MEMBER=NNMBVPUT\n//NNMBXFAR EXEC NNCCL,MEMBER=NNMBXFAR\n//NNMBXFNG EXEC NNCCL,MEMBER=NNMBXFNG\n//NNMCAR   EXEC NNCCL,MEMBER=NNMCAR\n//NNMCLRNG EXEC NNCCL,MEMBER=NNMCLRNG\n//NNMCLRTX EXEC NNCCL,MEMBER=NNMCLRTX\n//NNMCNRF  EXEC NNCCL,MEMBER=NNMCNRF\n//NNMCONN  EXEC NNCCL,MEMBER=NNMCONN\n//NNMCOPY  EXEC NNCCL,MEMBER=NNMCOPY\n//NNMDCAN  EXEC NNCCL,MEMBER=NNMDCAN\n//NNMDFAIL EXEC NNCCL,MEMBER=NNMDFAIL\n//NNMDISC  EXEC NNCCL,MEMBER=NNMDISC\n//NNMDISPL EXEC NNCCL,MEMBER=NNMDISPL\n//NNMDLANG EXEC NNCCL,MEMBER=NNMDLANG\n//NNMDMAIL EXEC NNCCL,MEMBER=NNMDMAIL\n//NNMDMENU EXEC NNCCL,MEMBER=NNMDMENU\n//NNMDNG   EXEC NNCCL,MEMBER=NNMDNG\n//NNMDNNTP EXEC NNCCL,MEMBER=NNMDNNTP\n//NNMDOIT  EXEC NNCCL,MEMBER=NNMDOIT\n//NNMDPOST EXEC NNCCL,MEMBER=NNMDPOST\n//NNMDSOPT EXEC NNCCL,MEMBER=NNMDSOPT\n//NNMDUMP  EXEC NNCCL,MEMBER=NNMDUMP\n//NNMESRVR EXEC NNCCL,MEMBER=NNMESRVR\n//NNMESTNG EXEC NNCCL,MEMBER=NNMESTNG\n//NNMFREEM EXEC NNCCL,MEMBER=NNMFREEM\n//NNMGETDS EXEC NNCCL,MEMBER=NNMGETDS\n//NNMGETM  EXEC NNCCL,MEMBER=NNMGETM\n//NNMGSRVL EXEC NNCCL,MEMBER=NNMGSRVL\n//NNMIERR  EXEC NNCCL,MEMBER=NNMIERR\n//NNMIGET  EXEC NNCCL,MEMBER=NNMIGET\n//NNMINIT  EXEC NNCCL,MEMBER=NNMINIT\n//NNMISPF  EXEC NNCCL,MEMBER=NNMISPF\n//NNMIVGET EXEC NNCCL,MEMBER=NNMIVGET\n//NNMIVPUT EXEC NNCCL,MEMBER=NNMIVPUT\n//NNMMAIN  EXEC NNCCL,MEMBER=NNMMAIN\n//NNMMARR  EXEC NNCCL,MEMBER=NNMMARR\n//NNMMARU  EXEC NNCCL,MEMBER=NNMMARU\n//NNMNNTP  EXEC NNCCL,MEMBER=NNMNNTP\n//NNMONRF  EXEC NNCCL,MEMBER=NNMONRF\n//NNMOUTTX EXEC NNCCL,MEMBER=NNMOUTTX\n//NNMPICK  EXEC NNCCL,MEMBER=NNMPICK\n//NNMPMSG  EXEC NNCCL,MEMBER=NNMPMSG\n//NNMPNG   EXEC NNCCL,MEMBER=NNMPNG\n//NNMQAR   EXEC NNCCL,MEMBER=NNMQAR\n//NNMQNG   EXEC NNCCL,MEMBER=NNMQNG\n//NNMRARH  EXEC NNCCL,MEMBER=NNMRARH\n//NNMRART  EXEC NNCCL,MEMBER=NNMRART\n//NNMRBFM  EXEC NNCCL,MEMBER=NNMRBFM\n//NNMRECON EXEC NNCCL,MEMBER=NNMRECON\n//NNMRPERR EXEC NNCCL,MEMBER=NNMRPERR\n//NNMSAVE  EXEC NNCCL,MEMBER=NNMSAVE\n//NNMSOCKT EXEC NNCCL,MEMBER=NNMSOCKT\n//NNMSOPT  EXEC NNCCL,MEMBER=NNMSOPT\n//NNMSORT  EXEC NNCCL,MEMBER=NNMSORT\n//NNMSSRVR EXEC NNCCL,MEMBER=NNMSSRVR\n//NNMSTRLC EXEC NNCCL,MEMBER=NNMSTRLC\n//NNMSUMAT EXEC NNCCL,MEMBER=NNMSUMAT\n//NNMTSO   EXEC NNCCL,MEMBER=NNMTSO\n//NNMUNALC EXEC NNCCL,MEMBER=NNMUNALC\n//NNMUPDT  EXEC NNCCL,MEMBER=NNMUPDT\n//NNMVAR   EXEC NNCCL,MEMBER=NNMVAR\n//NNMVIEW  EXEC NNCCL,MEMBER=NNMVIEW\n//NNMVNG   EXEC NNCCL,MEMBER=NNMVNG\n//NNMVTX   EXEC NNCCL,MEMBER=NNMVTX\n//NNMXARTT EXEC NNCCL,MEMBER=NNMXARTT\n//NNMXARTX EXEC NNCCL,MEMBER=NNMXARTX\n//NNMXLIST EXEC NNCCL,MEMBER=NNMXLIST\n//NNMXTX   EXEC NNCCL,MEMBER=NNMXTX\n//*\n./ ADD NAME=GRAMMAR\n\n        Grammar for NNMVS batch mode expressions.\n\n/*-------------------------------------------------------------------*/\n\nexp         :       choice\n            :       \"IF\" exp \"THEN\" exp \"ELSE\" exp\n                                       /* IF flag THEN any ELSE any */\n\nchoice      :       relation\n            :       choice logop relation   /* flag | flag -> flag  */\n\nrelation    :       value\n            :       value relop value       /* any > any   -> flag  */\n\nvalue       :       quantity\n            :       quantity quantity       /* any any    -> string */\n\nquantity    :       term\n            :       quantity addop term     /* num + num  -> number */\n\nterm        :       factor\n            :       term mulop factor       /* num * num -> number  */\n\nfactor      :       constant\n            :       variable                /* FOO, if declared     */\n            :       unop factor             /* - number  -> number  */\n            :       \"(\" exp \")\"             /* (a + b * c > d | e ) */\n\nconstant    :       number\n            :       string\n            :       flag\n\nunop        :       \"+\"\n            :       \"-\"\n            :       \"!\"\n            :       \"\u00ac\"\n\naddop       :       \"+\"\n            :       \"-\"\n\nmulop       :       \"*\"\n            :       \"/\"\n\nlogop       :       \"&\"\n            :       \"|\"\n\n\nrelop       :       \"=\"\n            :       \">\"\n            :       \"<\"\n            :       \"==\"\n            :       \">=\"\n            :       \"<=\"\n            :       \"!=\"\n            :       \"!>\"\n            :       \"!<\"\n            :       \"\u00ac=\"\n            :       \"\u00ac>\"\n            :       \"\u00ac<\"\n            :       \"IN\"\n\nvariable    :       \u00dda-z\u00a8*\n\nnumber      :       \u00dd0-9\u00a8*\n\nstring      :       \"\"...\"\"\n\nflag        :       \"TRUE\"\n            :       \"FALSE\"\n            :       \"ON\"\n            :       \"OFF\"\n            :       \"YES\"\n            :       \"NO\"\n./ ADD NAME=HELP\n                    NNMVS Batch Mode Help\n\n The following commands are available:\n\n Top-Level Commands (in top-level mode, picking newsgroups)\n\n   FOR ALL | REGISTERED | UNREGISTERED {WHEN filter} commandlist;\n\n      where filter is any flag expression, evaluated per newsgroup,\n      and commandlist is a single command or DO; commands; END;\n      and the commands are per-newsgroup commands.\n\n Per-Newsgroup Commands (in newsgroup mode, picking articles)\n\n   REGISTER\n   DEREGISTER\n   EXTRACT ALL | READ | UNREAD\n   QUERY\n   FOR ALL | READ | UNREAD | num {TO num} {WHEN filter} commandlist\n\n      where filter is any flag expression, evaluated per article,\n      and commandlist is a single command or DO; commands; END\n      and the commands are per-article commands.\n\n Per-Article Commands (in article mode)\n\n   MARK {READ | UNREAD}\n   LIST\n   EXTRACT\n   QUERY\n\n Miscellaneous Commands\n\n   IF condition THEN commandlist; {ELSE commandlist;}\n\n      where condition is any flag expression,\n      and commandlist is a single command or DO; commands; END;\n      and the commands are of the same mode as the one in which\n      the IF occurs.\n\n   PUT stringexpression               # writes to output file\n   EXEC stringexpression              # executes system command\n   NNTP stringexpression              # transmits NNTP request\n   QUIT                               # terminates NNMVS\n   VARS                               # dumps current variables\n\n   {SET} variable { = } expression\n\n     Variable must be builtin or declared (see DECLARE below)\n\n   DECLARE variable {STRING | NUMBER | FLAG}\n\n     Note:  DECLARE is the only command which is executed immediately.\n            All other commands are parsed and then the entire command\n            stream is executed only if no errors were detected.\n\n Built-in Variables\n\n LOCALPATH (string)  - the hosts's local path name\n DATETIME  (string)  - a time stamp\n SERVER    (string)  - the name of the NNTP server host.  Must be set\n                       by the user before attempting a connection.\n OUTFILE   (string)  - the name of an alternate output file for the\n                       PUT commands and any commands (like NNTP) that\n                       write text.  The default setting, \"\", uses the\n                       NNBATOUT DD.  The value may be a data set name\n                       (appended to) or in the form DD:ddname.\n SERVERLIST (flag)   - default is TRUE.  Normally NNMVS will ask for\n                       the current list of newsgroups from the NNTP\n                       server when it begins processing newsgroups.\n                       If you want to suppress this and just use the\n                       groups named in NEWSRC, set SERVERLIST to FALSE.\n                       Note that this may not save time, and in fact\n                       may result in more processing, since NNMVS will\n                       issue a GROUP request to each group requested\n                       when it has not issued a LIST request.\n AUTOREGISTER (flag) - default is FALSE.  If this is set to TRUE,\n                       new newsgroups will automatically be registered\n                       in the NEWSRC file; otherwise they will be added\n                       as unregistered newsgroups.\n AUTODELETE   (flag) - default is TRUE.  If this is set to TRUE,\n                       bogus newsgroups (groups in the NEWSRC file that\n                       are not known to the server) will be deleted\n                       from the NEWSRC file.  Set this to FALSE to keep\n                       such newsgroups in NEWSRC anyway.\n ERROR        (flag) - set to TRUE whenever an NNMVS batch command\n                       operation fails.  This is reset by each NNMVS\n                       batch command, so grab it early.\n EXACTCASE    (flag) - default is FALSE.  When this is FALSE, string\n                       comparisons and tests succeed regardless of upper\n                       or lower case.  When this is set to TRUE, string\n                       comparisons and tests succeed only if the strings\n                       match exactly.  Thus, \"a\" = \"A\" when EXACTCASE is\n                       FALSE, but not when EXACTCASE is TRUE.\n\n Variables meaningful to the EXTRACT command:\n\n TABEXPAND    (flag) - default is TRUE.  Controls whether tab characters\n                       are to be expanded on EXTRACT.  (Note that tabs\n                       are always expanded on PUT and LIST.)\n APPEND       (flag) - default is TRUE.  Controls how articles are to be\n                       extracted to sequential files by EXTRACT.\n                       If APPEND is set to FALSE, existing sequential\n                       files will be overwritten.  This option is not\n                       applicable to partitioned data sets (PDS's).\n SEPARATOR  (string) - default is the null string.  If this is set to\n                       a value other than the null string, the value\n                       will be written between articles as a separator\n                       line.  Meaningful only when APPEND is TRUE.\n BLANKSEP     (flag) - default is FALSE.  If TRUE, a blank line will be\n                       generated before the separator line when it us\n                       written out between articles.  Otherwise the\n                       separator line, if used, will follow the end of\n                       the preceding article immediately.  Meaningful\n                       only when SEPARATOR and APPEND are set.\n AUTOMARK     (flag) - default is TRUE.  When this is TRUE, the EXTRACT\n                       operation will mark unread articles READ upon\n                       successful extraction.  It has no effect on\n                       read articles or articles that failed extraction.\n                       Set it to FALSE to prevent EXTRACT from marking\n                       extracted articles read.\n\n Variables meaningful in per-newsgroup mode and modes below:\n\n GROUP      (string) - the name of the current newsgroop.\n REGISTERED (flag)   - TRUE if newsgroup is registered.\n NEWGROUP   (flag)   - TRUE if newsgroup is a new group (found by the\n                       server LIST request but not in NEWSRC).\n NOSUCHGROUP (flag)  - TRUE if the newsgroup is \"bogus\" (in NEWSRC but\n                       not found by the server LIST request).\n COUNT      (number) - the total number of articles in the newsgroup.\n UNREAD     (number) - the total number of new (unread) articles in the\n                       newsgroup since the last time NNMVS used this\n                       NEWSRC file.\n FIRST      (number) - the number of the first article in the group.\n LAST       (number) - the number of the last article in the group.\n\n Variables meaningful in per-article mode and modes below:\n\n NUMBER     (number) - the current article number.\n READ       (flag)   - TRUE if article has already been read.\n MISSING    (flag)   - TRUE if article cannot be retrieved from server.\n SUBJECT    (string) - text of the Subject: header.\n DATE       (string) - text of the Date: header, with day name removed.\n FROM       (string) - text of From: header, author of the article.\n MESSAGEID  (string) - text of the Message-ID: header.\n\n Expression Syntax\n\n Expressions can be string expressions, number expressions, or\n flag expressions.  They can contain constants, variables, and\n arithmetic or logical expressions.  Strings may be concatenated\n by placing one next to another, e. g. \"foo\" \"bar\".\n\n String constants are enclosed in double quotes, with the backslash\n acting as an escape with which to enclose embedded double quotes.\n\n Numeric constants are integers only.\n\n Flag constants may be represented as TRUE FALSE ON OFF YES NO.\n\n Arithmetic operators:  + - * / as well as unary + and -\n Logical    operators:  & |     as well as unary !\n Relational operators:  = != > < >= <= !> !<\n (Note: == is an alias for =, and \u00ac may be used wherever ! is.)\n\n For strings, the additional relational operator IN is available, e.g.\n\n   \"foo\" IN SUBJECT\n\n The notation (IF expression THEN expression ELSE expression) is\n allowed within expressions.\n\n The following synonyms are accepted:\n\n   AND OR NOT EQ NE GT LT GE LE NG NL\n\n The character # marks the beginning of a comment.\n\nExtracting Files\n\n EXTRACT writes the contents of one or more news articles out to a file\n whose name is determined from a table allocated to DDname NNEXTTAB.\n\n The format of the extract table is one line per newsgroup as follows:\n\n  groupname filename\n\n where filename is a FULLY QUALIFIED name (quotes ignored) of one of\n the following formats:\n\n  sequential data set name\n  wildcarded sequential data set name\n  wildcarded partitioned data set name\n\n \"Wildcarded\" means that there is an asterisk \"*\" in a strategic\n position in the file name.  It must be preceded by at least one\n alphanumeric character and may not be followed by one.\n\n When the extraction is done, the asterisk is replaced with the number\n of the article, zero padded on the left to fill out that segment of\n the name.\n\n Examples:\n\n  comp.group.one   MYID.COMP.GROUP.SEQ.FOO*\n  comp.group.two   MYID.COMP.GROUP.SEQ.ALL\n  comp.group.three MYID.COMP.GROUP.THREE.PDS(X*)\n  comp.group.four  MYID.COMP.GROUP.NUMBER*.PDS(ANYMEM)\n\n So...\n\n  comp.windows.x  SEB1525.COMP.WINDOWS.X.TEXT.#*\n\n defines a series of sequential data sets\n COMP.WINDOWS.X.TEXT.#0000001\n COMP.WINDOWS.X.TEXT.#0000002\n\n etc.\n\n PDS members can be expressed this way:\n\n  comp.os.vms     COMP.OS.VMS.PDS(VMS*)\n\n which gives\n\n  COMP.OS.VMS.PDS(VMS00001)\n  COMP.OS.VMS.PDS(VMS00002)\n\n etc.  If the article number takes more digits, it steals some\n character positions away from the characters immediately preceding\n the asterisk.  For example, using the above model:\n\n  COMP.OS.VMS.PDS(VM142857)\n\n The file need not already exist.  If it does not, NNMVS will attempt\n to guess the appropriate size when it allocates it, as the EXTRACT\n command does in foreground.\n\n./ ADD NAME=LINK\n//JOBNAME  JOB ACCOUNT,'NAME'\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*********************************************************************\n//*\n//* Linkedit the executable NNMVS load module.\n//*\n//NNLINK PROC LOADLIB='NNMVS.LOAD',              Executable load library\n//            OBJLIB='NNMVS.INSTALL.OBJ',        Input object PDS\n//            PLIBASE='SYS1.PLIBASE',            PL/1   link library\n//            EDCBASE='SYS1.SEDCBASE',           C/370  link library\n//            IBMBASE='SYS1.SIBMBASE',           PL/1+C common library\n//            COMMTXT='TCPIP.COMMTXT',           TCP/IP link library\n//            VIOUNIT=VIO,                       Temporary disk unit\n//            OUTCLAS='*',                          SYSOUT class\n//            LPARMS='LIST,LET,MAP',                Linkedit parameters\n//            TEST=NOTEST                           TEST or NOTEST\n//*\n//LKED      EXEC PGM=IEWL,PARM='AMODE(31),&TEST,&LPARMS'\n//SYSPRINT  DD SYSOUT=&OUTCLAS\n//SYSLIB    DD DISP=SHR,DSN=&PLIBASE\n//          DD DISP=SHR,DSN=&EDCBASE\n//          DD DISP=SHR,DSN=&IBMBASE\n//          DD DISP=SHR,DSN=&COMMTXT\n//SYSLMOD   DD DISP=SHR,DSN=&LOADLIB\n//SYSUT1    DD DSN=&&SYSUT1,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//          SPACE=(32000,(30,30))\n//*\n//         PEND\n//*\n//*\n//* Link NNMMAIN load module.\n//*\n//NNLINK EXEC NNLINK\n//LKED.SYSLIN DD DISP=SHR,DSN=&OBJLIB(NNMADDNG)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMADJUA)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMALLAV)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMALLOC)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMAUTH)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBATCH)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBBEXP)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBCONN)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBDECL)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBFLUS)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBGCMD)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBGDO)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBGEXP)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBGTOK)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPDEC)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPDER)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPELS)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPEXE)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPEXT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPFOR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPHEL)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPIF)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPLIS)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPMAR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPNNT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPPUT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPQUE)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPQUI)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPREG)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPSET)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBPVAR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBSOUT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBSYNT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBTEXT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBTRAS)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBVGET)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBVPUT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBXFAR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMBXFNG)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMCAR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMCLRNG)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMCLRTX)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMCNRF)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMCONN)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMCOPY)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDCAN)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDFAIL)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDISC)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDISPL)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDLANG)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDMAIL)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDMENU)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDNG)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDNNTP)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDOIT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDPOST)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDSOPT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMDUMP)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMESRVR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMESTNG)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMFREEM)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMGETDS)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMGETM)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMGSRVL)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMIERR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMIGET)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMINIT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMISPF)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMIVGET)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMIVPUT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMMAIN)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMMARR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMMARU)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMNNTP)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMONRF)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMOUTTX)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMPICK)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMPMSG)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMPNG)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMQAR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMQNG)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMRARH)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMRART)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMRBFM)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMRECON)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMRPERR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMSAVE)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMSOCKT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMSOPT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMSORT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMSSRVR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMSTRLC)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMSUMAT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMTSO)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMUNALC)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMUPDT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMVAR)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMVIEW)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMVNG)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMVTX)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMXARTT)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMXARTX)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMXLIST)\n//            DD DISP=SHR,DSN=&OBJLIB(NNMXTX)\n//            DD *\n ENTRY   CEESTART\n NAME    NNMMAIN(R)\n/*\n./ ADD NAME=NNMVS\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//NNMVS    PROC DEBUG=,                 say DEBUG=D for debugging\n//             LOADLIB='NNMVS.LOAD',    must match LOADLIB in LINK job\n//             HELP='NNMVS.HELP',              for batch HELP command\n//             NEWSRC='USERID.BATCH.NEWSRC',   separate NEWSRC file\n//             EXTTAB='USERID.NNMVS.EXTTAB'    table used by EXTRACT\n//*\n//* NNMVS batch mode.\n//*\n//NN       EXEC PGM=NNMMAIN,PARM='-B&DEBUG'\n//STEPLIB  DD   DISP=SHR,DSN=&LOADLIB\n//NNNEWSRC DD   DISP=OLD,DSN=&NEWSRC\n//NNEXTTAB DD   DISP=SHR,DSN=&EXTTAB\n//NNBATHLP DD   DISP=SHR,DSN=&HELP\n//SYSPRINT DD   SYSOUT=*\n//SYSERR   DD   SYSOUT=*\n//NNBATOUT DD   SYSOUT=*,DCB=(RECFM=VB,LRECL=255)\n//NNDEBUG  DD   SYSOUT=*\n//NNBATIN  DD   DDNAME=SYSIN\n//*\n//         PEND NNMVS\n./ ADD NAME=NNMVSHLP\n)F Function -\n\n NNMVS is a newsreader for reading and posting articles in USENET\n newsgroups.\n\n NNMVS is an NNTP (network news transfer protocol) client that accesses\n USENET news from a host machine elsewhere on your network that is\n running an NNTP news server, and displays the news via ISPF.  You must\n tell NNMVS where this news server is; it does not know otherwise.\n\n NNMVS remembers which articles you have read in a \"newsrc\" data set.\n You specify the name of this data set on the primary menu, along\n with the name of the news server host.  Note that both of these\n are given useful defaults when you start up NNMVS.\n\n If you have never used NNMVS before, you use the blank or L option to\n build up your NEWSRC file from a list retrieved from the server.\n Then, to limit the list to your favorite newsgroups, you can register\n (subscribe to) the ones you want while viewing the newsgroup list.\n\n You can use L or blank all the time to enter NNMVS.  However,\n once you have used and built a NEWSRC file, you may wish to use a\n different entry option to reduce startup time.\n You can avoid retrieving the whole list by using the R option\n to view only registered (subscribed) newsgroups, or the A option to\n view all newsgroups listed in your NEWSRC file.\n\n The disadvantage to using A or R is that you do not get the latest\n additions to the news system when the newsgroup list shows up.\n But there are ways to get around this.  For example, you can use the\n N option to get a list of newsgroups added since the last time you\n retrieved the newsgroup list (i.e. used L or N).\n\n If you want to go to a particular newsgroup directly, you can do so\n via the G option.  When you use this, you must provide the name of\n the desired newsgroup.\n\n)I NNMVSLOC          - local NNMVS help goes in member NNMVSLOC\n\n)X Syntax -\n\n   %NNMVS\n              SERVER('news server host')\n              GROUP('newsgroup name')\n              NEWSRC('data set name')\n              OPTION(A/G/L/N/O/P/R/X)\n              REGISTERSTATUS(Yes/No/Prompt)\n              FORCE\n              DEBUG\n              TEST\n              BATCH\n              BATCHIN('batch input file name')\n              BATCHOUT('batch output file name')\n              NEW\n              OLD\n\n   Required:  none\n\n   Defaults:  User is prompted (via ISPF panel) for all omitted values\n\n   Notes:     If OPTION is given, then direct entry into the news\n              reader occurs, without display of the NNMVS primary menu.\n              However, if so, then SERVER and NEWSRC are required, and\n              GROUP is also required if OPTION(G) is specified.\n\n              If BATCH is given, then NEWSRC is required.\n\n)O Operands -\n\n))SERVER('news server host')\n\n              The hostname of the machine running the news server.\n              Note that an IP address may be specified, but this\n              is obviously not recommended.\n\n              If an asterisk \"*\" is specified as the server name,\n              an experimental dialog is invoked which displays an\n              ISPF table of news servers with associated NEWSRC\n              data set names.  You select the news server you want\n              (or add a line associating that server with a specific\n              NEWSRC file).  This feature is courtesy of Leonard Woren\n              (LDW@MVSA.USC.EDU, SHARE installation code USC).\n\n))GROUP('newsgroup name')\n\n              The name of a specific newsgroup you want to see,\n              rather than the list of all newsgroups.  If you specify\n              this, it will merely fill in the corresponding field of\n              the NNMVS primary menu, unless you also specify the\n              keyword OPTION(G) and values for SERVER and NEWSRC.\n\n))NEWSRC('data set name')\n\n              The name of your \"newsrc\" file, a sequential data set\n              which keeps track of which articles you've already read\n              in which newsgroups.  If this data set does not exist,\n              NNMVS will create it.\n\n              It is a good idea to use the same NEWSRC file all the\n              time for one news server, but to use separate NEWSRC\n              files for different news servers (should there be any).\n\n              If you specify this, it will merely fill in the\n              corresponding field of the NNMVS primary menu, unless\n              you also specify values for SERVER and OPTION.\n\n              If an asterisk \"*\" is specified as the NEWSRC name,\n              an experimental dialog is invoked which displays an\n              ISPF table of news servers with associated NEWSRC\n              data set names.  You select the news server you want\n              (or add a line associating that server with a specific\n              NEWSRC file).  This feature is courtesy of Leonard Woren\n              (LDW@MVSA.USC.EDU, SHARE installation code USC).\n\n))OPTION(A/G/L/N/O/P/R/X)\n\n              The initial option to start up NNMVS without seeing\n              the primary menu, where the meanings of the letters\n              are those as displayed on the menu:\n\n              L - List all newsgroups from server\n              N - List new newsgroups from server since last N or L\n              A - Show items from all newsgroups listed in NEWSRC file\n              R - Show items from registered newsgroups in NEWSRC file\n              G - Go directly to the newsgroup named by operand GROUP\n              P - Enter native NNTP protocol commands\n              O - Specify NNMVS options defaults\n              X - Exit NNMVS\n\n              If you specify this, you must also specify values for\n              SERVER and NEWSRC.  Also, if you specify OPTION(G), you\n              must provide a value for the GROUP keyword.\n\n))REGISTERSTATUS(Yes/No/Prompt)\n\n              When you specify OPTION(R), NNMVS decides whether to\n              get the current status of each registered newsgroup,\n              since it doesn't get that information for free as it\n              does when you use the \"L\" (list) option.  Therefore,\n              it normally prompts you with a popup asking you if it\n              is OK to do this, since it takes time.\n\n              Specify REGISTERSTATUS(Y) to tell NNMVS to go ahead and\n              do this.  REGISTERSTATUS(N) says not to.  The default,\n              REGISTERSTATUS(P), tells NNMVS to prompt as it would if\n              you selected option R from the primary menu.\n\n))FORCE\n\n              NNMVS tries to determine if there is a TCP/IP socket\n              application active elsewhere in your TSO environment\n              before starting up, to prevent TCP/IP errors.  If it\n              tells you that there is another client active but in\n              truth there is none and you know it, you can use the\n              FORCE keyword to make NNMVS proceed whether it finds\n              this to be the case or not.\n\n))DEBUG\n\n              Set debugging mode on.  You must preallocate a file to\n              ddname NNDEBUG for this to work.  This can be allocated\n              to the terminal or a log file.  When debug mode is on,\n              messages describing memory allocation and deallocation\n              and NNTP commands sent are dumped to the debug file.\n\n))TEST\n\n              Activate C/370 interactive test (INSPECT).  NNMVS must\n              have been compiled with the TEST option for this to be\n              effective.  Note that you can also issue the TEST command\n              inside NNMVS to get to INSPECT, again provided that NNMVS\n              was compiled with the TEST option.\n))BATCH\n\n              Invoke NNMVS in batch mode.  When BATCH is specified,\n              NEWSRC must also be specified.  The files specified by\n              BATCHIN and BATCHOUT are allocated and you supply\n              NNMVS batch commands in the BATCHIN file (typically the\n              terminal).  You specify the news server via the command\n\n              server = \"foobar\";\n\n              where foobar should be replaced with the actual name of\n              the NNTP server host.\n\n              Note that no batch commands will be executed until the\n              entire batch language program is read in and EOF is met.\n\n              For help with the batch language, execute NNMVS in batch\n              mode and supply the command \"HELP\".\n\n))BATCHIN('batch input file name')\n\n              the data set allocated for input to NNMVS batch mode.\n              Default is * (the terminal).\n\n              Note that no batch commands will be executed until the\n              entire batch language program is read in and EOF is met.\n\n              For help with the batch language, execute NNMVS in batch\n              mode and supply the command \"HELP\".\n\n))BATCHOUT('batch output file name')\n\n              the data set allocated for output from NNMVS batch mode.\n              Default is * (the terminal).\n\n              For help with the batch language, execute NNMVS in batch\n              mode and supply the command \"HELP\".\n\n))NEW\n\n              Use a new (testing) release of NNMVS.  This is dependent\n              upon your installation's procedures for providing\n              parallel releases of software for users to run online in\n              test mode.\n\n))OLD\n\n              Use an old (backup) release of NNMVS.  This is dependent\n              upon your installation's procedures for providing\n              parallel releases of software for users to run online in\n              test mode.\n\n./ ADD NAME=SIGFAIL\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n\nstatic void\nhandler() {\n printf(\"SIGINT handler has been called.\\n\");\n exit(8);\n}\n\nstatic int\nask(question)\nchar *question;\n{\n char ans\u00dd81\u00a8;\n\n for (;;) {\n   printf(\"%s\",question);\n   fgets(ans,79,stdin);\n   switch (ans\u00dd0\u00a8) {\n     case 'y':\n     case 'Y': return 1;\n     case 'n':\n     case 'N': return 0;\n     default: printf(\"Bad answer, %s\\n\",ans);\n              continue;\n   }\n }\n}\n\nmain(argc,argv)\nint argc;\nchar **argv;\n{\n int sigp;\n int loopp;\n int i;\n\n printf(\n  \"This program demonstrates that SIGINT is not handled on MVS.\\n\");\n printf(\n  \"It does NOT prove or disprove anything about attention handling\\n\");\n printf(\n  \"in C/370 in general, except possibly for how output to stdout\\n\");\n printf(\n  \"and stderr are affected by an attention interruption.\\n\\n\");\n printf(\n  \"At the end of the program, a line of output is written to each\\n\");\n printf(\n  \"of the two output files.  If you see either one, that means that\\n\");\n printf(\n  \"C/370 has intercepted the attention, but you will observe that\\n\");\n printf(\n  \"it has not been handled by a SIGINT routine and it also has not\\n\");\n printf(\n  \"allowed the program to be terminated by the operating system.\\n\\n\");\n\n sigp  = ask(\"Do you want to signal abort on interrupts? (y or n)\");\n loopp = ask(\"Do you want to loop forever without output? (y or n)\");\n\n if (sigp) {\n   printf(\"Doing signal(SIGINT,handler)\\n\");\n   if (signal(SIGINT,handler) == SIG_ERR)\n       perror(\"Could not set SIGINT\");\n }\n\n printf(\"OK, hit PA1 now\\n\");\n\n if (loopp) {\n   for (;;) ;\n }\n else {\n   for (i=0;i<5000;i++) {\n    printf(\"I=%d\\n\",i);\n   }\n }\n printf(\"I'm finished (on stdout)\\n\");\n fprintf(stderr,\"I'm finished (on stderr)\\n\");\n}\n\n./ ENDUP\n?!\n//CLIST    EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='CLIST'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=NNMFIUCV\n/* REXX.  This exec scans the job pack queues for IUCVMULT and returns\n * with an error code if IUCVMULT is already loaded under a\n * different TCB. This can only happen under PIE MultiTSO or a\n * similar product that makes multiple job step TCB's.\n */\n\ntrace off\nsignal on novalue\n\nsearch_name = \"IUCVMULT\"\ncount = 0\nfoundtcb. = \"\"\ncurrent_tcb  = getword24(\"21C\")\ncurrent_job_step_tcb = getword24(current_tcb,\"7C\")\ncurrent_ascb = getword24(\"224\")\ncurrent_asxb = getword31(current_ascb,\"6C\")\nfirst_tcb    = getword24(current_asxb,\"4\")\ntcb = first_tcb\nmotherflag = 0\ndo forever\n if motherflag = 0 then do\n  call process\n  daughter_tcb = getword24(tcb,\"88\")\n  if daughter_tcb \\= \"00000000\" then do\n   tcb = daughter_tcb\n   iterate\n  end\n end\n motherflag = 0\n sister_tcb = getword24(tcb, \"80\")\n if sister_tcb \\= \"00000000\" then do\n  tcb = sister_tcb\n  iterate\n end\n mother_tcb = getword24(tcb, \"84\")\n if mother_tcb \\= \"00000000\" then do\n  tcb = mother_tcb\n  motherflag = 1\n  iterate\n end\n leave\nend\n\nif count = 0 then return 0\nproblem = 0\ndo i = 1 to count\n if foundtcb.i = current_job_step_tcb then do\n  /*\n  say search_name \"is already loaded under current TCB at \"foundtcb.i\".\"\n  */\n end\n else do\n  /*\n  say search_name \"is loaded under different TCB at \"foundtcb.i\".\"\n  */\n  problem = 1\n end\nend\n\nif problem = 1 then return 1\n\nelse return 0\n\nprocess:\n\n jpq = getword31(tcb,\"2C\")\n cde = jpq\n do while cde \\= \"00000000\"\n  cde_contents = storage(cde,32)\n  cde_name = substr(cde_contents,9,8)\n  cde_epa  = substr(cde_contents,9,8)\n  if search_name = cde_name then do\n   count = count + 1\n   foundtcb.count = tcb\n  end\n  cde = getword31(cde,\"0\")\n end\n\nreturn\n\ngetword31: parse arg addr, offset\ntemp1 = x2d(addr)\nif offset = \"\" then temp2 = 0\nelse temp2 = x2d(offset)\nreturn c2x(storage(d2x(temp1+temp2),4))\n\ngetword24: parse arg addr, offset\ntemp1 = x2d(addr)\nif offset = \"\" then temp2 = 0\nelse temp2 = x2d(offset)\nreturn \"00\"c2x(storage(d2x(temp1+temp2+1),3))\n\n./ ADD NAME=NNMVS\n/* REXX. Syntax:  NNMVS  (we'll do the rest)   */\n\n/*********************************************************************/\n/*                                                                   */\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     */\n/*                                                                   */\n/* This software is provided on an \"AS IS\" basis.  All warranties,   */\n/* including the implied warranties of merchantability and fitness,  */\n/* are expressly denied.                                             */\n/*                                                                   */\n/* Provided this copyright notice is included, this software may     */\n/* be freely distributed and not offered for sale.                   */\n/*                                                                   */\n/* Changes or modifications may be made and used only by the maker   */\n/* of same, and not further distributed.  Such modifications should  */\n/* be mailed to the author for consideration for addition to the     */\n/* software and incorporation in subsequent releases.                */\n/*                                                                   */\n/*********************************************************************/\n\n/* *** Customize the following lines for your installation. *** */\n/*                                                              */\n/* Note:  If you wish to specify a different ISPF APPLID for    */\n/* NNMVS, you will have to use the SELECT service to invoke     */\n/* the load module.  If so, uncomment the LIBDEF's for ISPLLIB  */\n/* and the SELECT call, and comment out the TSO CALL call.      */\n/*                                                              */\n/* Note:  If you choose a panel library that is in TSO users'   */\n/* default ISPF allocations, you can remove the LIBDEF call.    */\n/*                                                              */\n\nnnmprefix      = \"NNMVS\"\nnnmpanelsuffix = \"ISPPLIB\"\nnnmloadsuffix  = \"LOAD\"\nnnmlmod        = \"NNMMAIN\"\nnnmpanel       = nnmprefix\".\"nnmpanelsuffix\nnnmload        = nnmprefix\".\"nnmloadsuffix\nnnmappl        = \"ISR\"\n\ntrace off\nsignal on novalue\nlibdeffed = 0\nparse arg args\n\"ISPQRY\"\nif rc > 0 then do\n parse source . . execname . execds .\n if execds = \"?\" then\n  icmd = \"%\"execname args\n else\n  icmd = \"EX '\"execds\"(\"execname\")'\" quote(args)\n call startispf \"NEWAPPL(\"nnmappl\") CMD(\"icmd\")\"\n exit\nend\nsignal on failure\nsignal on halt\ntestparm = \"-\"\nif wordpos(\"TEST\", translate(args)) > 0 then testparm = testparm || \"t\"\nelse ,\nif wordpos(\"DEBUG\",translate(args)) > 0 then testparm = testparm || \"d\"\nelse testparm = \"\"\n\nif find_iucvmult() <> 0 then do\n say,\n\"A TCP/IP socket application may be active elsewhere in your session.\"\n say \"Please terminate the other application before trying this one.\"\n exit\nend\n\ncall libdef\ncall nnm_dialog\n\ncleanup:\nif libdeffed then call unlibdef\nexit\nerror:failure:halt:say \"NNMVS: Severe lossage.\"\nsay \"Statement:\" sourceline(sigl)\nexit\n\nnnm_dialog:\n\naddress TSO \"CALL\" \"'\"nnmload\"(\"nnmlmod\")'\" quote(testparm)\n/*\n * address ISPEXEC,\n *         \"SELECT PGM(\"nnmlmod\") PARM(\"quote(testparm)\")\",\n *         \"NEWAPPL(\"nnmappl\") PASSLIB\"\n */\nif rc \\= 0 then say \"Return code from\" nnmlmod \"program is\" rc\nreturn\n\nlibdef:\naddress ISPEXEC \"LIBDEF ISPPLIB DATASET  ID('\"nnmpanel\"')\"\n/*\n * address ISPEXEC \"LIBDEF ISPLLIB DATASET  ID('\"nnmload\"')\"\n */\nlibdeffed = 1\nreturn\n\nunlibdef:\n/*\n * address ISPEXEC \"LIBDEF ISPLLIB DATASET\"\n */\naddress ISPEXEC \"LIBDEF ISPPLIB DATASET\"\nlibdeffed = 0\nreturn\n\n/*\n * The following function starts ISPF from READY mode.\n * Beware:  splitting the screen starts up an identical copy of the\n *          application, which may not be desirable.\n */\n\nstartispf: parse arg string\n\"ISPSTART\" string\nreturn\n\n/* The following function enquotes a string. */\n\nquote: parse arg string\nix = 1\ndo forever\n ix = pos(\"'\",string,ix)\n if ix = 0 then return \"'\"string\"'\"\n string = insert(\"'\",string,ix)\n ix=ix+2\nend\n\nfind_iucvmult: procedure\n\ncall nnmfiucv\n\nreturn result\n\n./ ADD NAME=NNMVSC\nPROC 0 TEST DEBUG BATCH +\n       SERVER() GROUP() NEWSRC() OPTION() REGISTERSTATUS()\n\n/*********************************************************************/\n/*                                                                   */\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     */\n/*                                                                   */\n/* This software is provided on an \"AS IS\" basis.  All warranties,   */\n/* including the implied warranties of merchantability and fitness,  */\n/* are expressly denied.                                             */\n/*                                                                   */\n/* Provided this copyright notice is included, this software may     */\n/* be freely distributed and not offered for sale.                   */\n/*                                                                   */\n/* Changes or modifications may be made and used only by the maker   */\n/* of same, and not further distributed.  Such modifications should  */\n/* be mailed to the author for consideration for addition to the     */\n/* software and incorporation in subsequent releases.                */\n/*                                                                   */\n/*********************************************************************/\n\n/**********************************************************************/\n/*                                                                    */\n/* This is the CLIST version of the NNMVS driver.  You may wish to    */\n/* use this in place of the REXX version if:                          */\n/*                                                                    */\n/* - you don't have REXX (huh???)                                     */\n/* - you don't have XPROC (you can probably get it from the same      */\n/*   place you got NNMVS)                                             */\n/* - you are experiencing RACF/ACF2/other-security-system problems    */\n/*   trying to define access to the NNTP authorization file with      */\n/*   program pathing rules or the equivalent                          */\n/*                                                                    */\n/* The disadvantages are:                                             */\n/*                                                                    */\n/* - You can use the CLIST from READY mode only implicitly.  In other */\n/*   words, a user won't be able to type EXEC 'library.clist(NNMVS)'  */\n/*   from READY mode - it must be in SYSPROC and executed by name.    */\n/*                                                                    */\n/* - You don't get the check for multiple TCP/IP applications.        */\n/*                                                                    */\n/* Of course, even if you don't have XPROC, you may still want to use */\n/* the REXX exec instead - you just have to take out the XPROC call   */\n/* and forget about being able to pass parameters to the exec.  That  */\n/* isn't such a great loss, since none of the params are required.    */\n/*                                                                    */\n/**********************************************************************/\n\n/* *** Customize the following lines for your installation. *** */\n/*                                                              */\n/* Note:  If you wish to specify a different ISPF APPLID for    */\n/* NNMVS, you will have to use the SELECT service to invoke     */\n/* the load module.  If so, uncomment the LIBDEF's for ISPLLIB  */\n/* and the SELECT call, and comment out the TSO CALL call.      */\n/*                                                              */\n/* Note:  If you choose a panel library that is in TSO users'   */\n/* default ISPF allocations, you can remove the LIBDEF call.    */\n/*                                                              */\n\nSET NNMCLIST       = NNMVS     /* name of this CLIST */\nSET NNMPREFIX      = NNMVS\nSET NNMPANELSUFFIX = ISPPLIB\nSET NNMLOADSUFFIX  = LOAD\nSET NNMLMOD        = NNMMAIN\nSET NNMPANEL       = &STR(&NNMPREFIX..&NNMPANELSUFFIX)\nSET NNMLOAD        = &STR(&NNMPREFIX..&NNMLOADSUFFIX)\nSET NNMAPPL        = ISR\n\nCONTROL NOCAPS\n\nSET STACKED = N\nSET LIBDEFFED = N\nISPQRY\nIF &LASTCC > 0 THEN DO\n SET ICMD = &NRSTR(&NNMCLIST &TEST &DEBUG &BATCH +\n                   SERVER('&SERVER') GROUP('&GROUP') +\n                   NEWSRC('&NEWSRC') OPTION('&OPTION') +\n                   REGISTERSTATUS('&REGISTERSTATUS'))\n ISPSTART NEWAPPL(&NNMAPPL) CMD(&NRSTR(&ICMD))\n EXIT\nEND\n\nIF &NRSTR(&OPTION) \u00ac= &STR() THEN DO\n IF &LENGTH(&NRSTR(&OPTION)) \u00ac= 1 +\n  | &SYSINDEX(&NRSTR(&OPTION),TDB) \u00ac= 0 THEN DO\n  WRITE NNMVS: Invalid option, &NRSTR(&OPTION).\n  EXIT CODE(12)\n END\n IF &NRSTR(&SERVER) = &STR() THEN DO\n  WRITE NNMVS: SERVER required when OPTION specified.\n  EXIT CODE(12)\n END\n IF &NRSTR(&NEWSRC) = &STR() THEN DO\n  WRITE NNMVS: NEWSRC required when OPTION specified.\n  EXIT CODE(12)\n END\n IF &NRSTR(&OPTION) = G && &NRSTR(&GROUP) = &STR() THEN DO\n  WRITE NNMVS: GROUP required when OPTION(G) specified.\n  EXIT CODE(12)\n END\n IF &NRSTR(REGISTERSTATUS) = &STR() THEN SET REGISTERSTATUS = PROMPT\nEND\n\nSET TESTPARM = &STR(-)\nIF &TEST  = TEST  THEN SET TESTPARM = &STR(&TESTPARM.t)\nIF &DEBUG = DEBUG THEN SET TESTPARM = &STR(&TESTPARM.d)\nIF &BATCH = BATCH THEN SET TESTPARM = &STR(&TESTPARM.b)\n\nISPEXEC LIBDEF ISPPLIB DATASET ID('&NNMPANEL')\n\n/* ISPEXEC LIBDEF ISPLLIB DATASET ID('&NNMLOAD')\n\nSET LIBDEFFED = Y\n\nIF &NRSTR(&SERVER) NE THEN DO\n SET NNSERVER = &NRSTR(&SERVER)\n ISPEXEC VPUT (NNSERVER)\nEND\n\nIF &NRSTR(&GROUP) NE THEN DO\n SET NNGROUPI = &NRSTR(&GROUP)\n ISPEXEC VPUT (NNGROUPI)\nEND\n\nIF &NRSTR(&NEWSRC) NE THEN DO\n SET NNNEWSRF = &NRSTR(&NEWSRC)\n ISPEXEC VPUT (NNNEWSRF)\nEND\n\nSET VPUTVARS =\n\nIF &NRSTR(&SERVER) \u00ac= &STR() THEN DO\n SET NNSERVER = &NRSTR(&SERVER)\n SET VPUTVARS = &STR(&VPUTVARS NNSERVER)\nEND\n\nIF &NRSTR(&GROUP) \u00ac= &STR() | &NRSTR(&OPTION) = G THEN DO\n SET NNGROUPI = &NRSTR(&GROUP)\n SET VPUTVARS = &STR(&VPUTVARS NNGROUPI)\nEND\n\nIF &NRSTR(&NEWSRC) \u00ac= &STR() THEN DO\n SET NNNEWSRF = &NRSTR(&NEWSRC)\n SET L = &LENGTH(&NRSTR(&NEWSRC))\n IF   &SUBSTR(1,&NEWSRC) = &STR(') +\n   && &SUBSTR(&L,&NEWSRC) = &STR(') THEN DO\n  SET NNNEWSRC = &SUBSTR(2:&L-1,&NRSTR(&NEWSRC))\n END\n ELSE SET NNNEWSRC = &NRSTR(&SYSPREF..&NEWSRC)\n SET VPUTVARS = &STR(&VPUTVARS NNNEWSRF NNNEWSRC)\nEND\n\nIF &NRSTR(&REGISTERSTATUS) \u00ac= &STR() THEN DO\n SET NNREGNNG = &SUBSTR(1,&NRSTR(&REGISTERSTATUS)\n SET VPUTVARS = &STR(&VPUTVARS NNREGNNG)\nEND\n\nIF &STR(VPUTVARS) \u00ac= &STR() THEN DO\n ISPEXEC VPUT (VPUTVARS) PROFILE\nEND\n\nIF &NRSTR(&OPTION) \u00ac= &STR() THEN DO\n SET TESTPARM = &NRSTR(&TESTPARM.&OPTION)\nEND\n\nCALL '&NNMLOAD(&NNMLMOD)' '&NRSTR(&TESTPARM)'\n/*\n/* address ISPEXEC,\n/* ISPEXEC SELECT PGM(&NNMLMOD) PARM('&NRSTR(&TESTPARM)') +\n/*         NEWAPPL(&NNMAPPL) PASSLIB\n/*\nIF &LASTCC NE 0 THEN DO\n WRITE Return code from &NNMLMOD program is &LASTCC\nEND\n\nIF &LIBDEFFED = Y THEN DO\n\n /* ISPEXEC LIBDEF ISPLLIB DATASET\n\n ISPEXEC LIBDEF ISPPLIB DATASET\n SET LIBDEFFED = N\nEND\n\nEXIT\n\n./ ADD NAME=NNMVSL\n/* REXX.  From Leonard D. Woren <ldw@mvsa.usc.edu>.\n *        Modified by SEB to remove MSGS file and other stuff...\n *\n */\ntrace off\nsignal on failure\nsignal on novalue\n\n\"XPROC 0 DEBUG LIST NEW OLD\"\nif rc <> 0 then return rc\n\nIf debug = 'DEBUG' Then Trace I\nIf list  = 'LIST'  Then Trace C\nAddress ISPEXEC\n\nnnmvs_command = \"%NNMVSP\" new old\npanel_name    = \"NNL\"\nprof = \"ISPPROF\"\nAddress TSO \"PIECHECK\"\npiecc = Rc\nSelect\n   When(piecc =   0) Then Nop   /* not under pie */\n   When(piecc =  12) Then Nop   /* no piecheck cmd ==> not under pie */\n   When(piecc = 241) Then Nop   /* pie session 1 */\n   Otherwise         prof = 'IS1PROF'\n   End  /* select */\n\n\"CONTROL ERRORS RETURN\"\n\"TBOPEN NNLIST WRITE LIBRARY(\"prof\") SHARE\"\nIf Rc > 8 then signal ispf_error\nIf Rc = 0 Then \"TBTOP NNLIST\"\nElse Do\n   \"TBCREATE NNLIST WRITE LIBRARY(\"prof\") NAMES(SERVER NEWSRC)\"\n   If Rc \u00ac= 0 Then signal ispf_error\n   End\ncsr = \"\"\ndispcc = 0\n\n\nDo Forever\n   \"TBQUERY NNLIST ROWNUM(ROWNUM)\"\n   If Rc > 8 then signal ispf_error\n   If rownum = 0 Then Do\n      server = \"\"\n      newsrc = \"\"\n      \"TBADD NNLIST\"\n      If RC > 8 then signal ispf_error\n      csr = \"CURSOR(SERVER) CSRROW(1)\"\n      End\n\n   \"TBTOP   NNLIST\"\n   If Rc > 8 then signal ispf_error\n   nnsel = \"\"\n   If dispcc = 4 Then \"TBDISPL NNLIST\"\n                 Else \"TBDISPL NNLIST PANEL(\"panel_name\")\" csr\n   dispcc = Rc\n   csr = \"\"\n\n   If dispcc = 8 Then Do\n      \"TBCLOSE NNLIST PAD(50) LIBRARY(\"prof\")\"\n      If Rc > 8 then signal ispf_error\n      return 0\n      End\n\n   If (dispcc \u00ac= 0 & dispcc \u00ac= 4) Then Do\n      Say \"TBDISPL Rc =\" dispcc\n      Say zerrsm\n      Say zerrlm\n      \"TBCLOSE NNLIST PAD(50) LIBRARY(\"prof\")\"\n      If Rc > 8 then signal ispf_error\n      return 16\n      End\n\n   If zcmd = \"\" Then Do  /* look for line commands */\n      Upper nnsel\n      Select\n         When (nnsel = \"\" ) Then \"TBPUT NNLIST\"\n         When (nnsel = \"D\") Then Do\n            /*\n            \"CONTROL DISPLAY SAVE\"\n            \"DISPLAY PANEL(NNLDEL)\"\n            delcc = Rc\n            \"CONTROL DISPLAY RESTORE\"\n            if delcc > 8 then signal ispf_error\n            If delcc = 0 Then */ \"TBDELETE NNLIST\"\n            Iterate\n            End\n         When (nnsel = \"I\") Then Do\n            server = \"\"\n            newsrc = \"\"\n            \"TBADD NNLIST\"\n            if Rc > 8 then signal ispf_error\n            \"TBQUERY NNLIST POSITION(NEWROW)\"\n            if Rc > 8 then signal ispf_error\n            csr = \"CURSOR(SERVER) CSRROW(\"newrow\")\"\n            Iterate\n            End\n         When (nnsel = \"R\") Then Do\n            \"TBADD NNLIST\"\n            if Rc > 8 then signal ispf_error\n            \"TBQUERY NNLIST POSITION(NEWROW)\"\n            if Rc > 8 then signal ispf_error\n            csr = \"CURSOR(SERVER) CSRROW(\"newrow\")\"\n            Iterate\n            End\n         When (nnsel = \"S\") Then Do\n            \"TBCLOSE NNLIST PAD(50) LIBRARY(\"prof\")\"\n            cc = Rc\n            if cc > 8 then signal ispf_error\n            If cc \u00ac= 0 Then Say \"TBCLOSE rc =\" cc\n            operands = \"\"\n            If server \u00ac= \"\" Then operands =          \"SERVER(\"server\")\"\n            If newsrc \u00ac= \"\" Then operands = operands \"NEWSRC(\"newsrc\")\"\n            Address TSO nnmvs_command operands\n            return 0\n            End\n         Otherwise Do\n            badsel = nnsel\n            zerrsm   = badsel \"invalid\"\n            zerrlm   = badsel \"is not a valid line command\"\n            zerralrm = \"YES\"\n            zerrhm   = \"*\"\n            \"SETMSG MSG(ISRZ002)\"\n            If Rc > 8 Then signal ispf_error\n            End\n         End /* select */\n      End  /* zcmd = \"\" */\nElse Do  /* zcmd \u00ac= \"\" */\n      badcmd = Word(zcmd,1)\n      zerrsm   = \"Invalid command\"\n      zerrlm   = badcmd \"is not a valid primary command\"\n      zerralrm = \"YES\"\n      zerrhm   = \"*\"\n      \"SETMSG MSG(ISRZ002)\"\n      If Rc > 8 Then signal ispf_error\n      End  /* zcmd \u00ac= \"\" */\n   End  /* main loop */\n\nreturn 0\n\n/* ISPF dialog error handling. */\n\nispf_error:\naddress ISPEXEC \"DISPLAY PANEL(ISPTERM)\"\nsignal cleanup\n\nerror:failure:halt:say \"NNMVSL: Severe lossage.\"\nsay \"Statement:\" sourceline(sigl)\nexit\n./ ADD NAME=NNMVSP\n/* REXX. Syntax:  NNMVS  (see XPROC for the rest)   */\n\n/*********************************************************************/\n/*                                                                   */\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     */\n/*                                                                   */\n/* This software is provided on an \"AS IS\" basis.  All warranties,   */\n/* including the implied warranties of merchantability and fitness,  */\n/* are expressly denied.                                             */\n/*                                                                   */\n/* Provided this copyright notice is included, this software may     */\n/* be freely distributed and not offered for sale.                   */\n/*                                                                   */\n/* Changes or modifications may be made and used only by the maker   */\n/* of same, and not further distributed.  Such modifications should  */\n/* be mailed to the author for consideration for addition to the     */\n/* software and incorporation in subsequent releases.                */\n/*                                                                   */\n/*********************************************************************/\n\n/* *** Customize the following lines for your installation. *** */\n/*                                                              */\n/* If nnmpanel is set to \"\", it will not be LIBDEF'd.           */\n/* If nnmload  is set to \"\", it will not be LIBDEF'd.           */\n/*                                                              */\n\nsave_prompt = prompt(\"ON\")\n\"XPROC 0 TEST DEBUG FORCE NEW OLD BATCH BATCHIN(*) BATCHOUT(*)\n         SERVER() GROUP() NEWSRC() OPTION() REGISTERSTATUS()\"\nif rc <> 0 then exit rc\ncall prompt save_prompt\n\nselect\n when new = \"NEW\" then do\n  nnmprefix      = \"NNMVS\"     /* or use \"new\" (testing) parameters */\n  nnmpanelsuffix = \"ISPPLIB\"   /* or use \"new\" (testing) parameters */\n  nnmloadsuffix  = \"LOAD\"      /* or use \"new\" (testing) parameters */\n  nnmlmod        = \"NNMMAIN\"   /* or use \"new\" (testing) parameters */\n end\n when old = \"OLD\" then do\n  nnmprefix      = \"NNMVS\"     /* or use \"old\" (backup) parameters */\n  nnmpanelsuffix = \"ISPPLIB\"   /* or use \"old\" (backup) parameters */\n  nnmloadsuffix  = \"LOAD\"      /* or use \"old\" (backup) parameters */\n  nnmlmod        = \"NNMMAIN\"   /* or use \"old\" (backup) parameters */\n end\n otherwise do\n  nnmprefix      = \"NNMVS\"\n  nnmpanelsuffix = \"ISPPLIB\"\n  nnmloadsuffix  = \"LOAD\"\n  nnmlmod        = \"NNMMAIN\"\n end\nend\n\nnnmpanel       = nnmprefix\".\"nnmpanelsuffix\nnnmload        = nnmprefix\".\"nnmloadsuffix\nnnmappl        = \"ISR\"\nbatchhelp      = \"'\"nnmprefix\".HELP.TEXT'\"\nnnmvswizard    = \"Steve Bacher <seb@draper.com>\"   /* next of kin */\nnnmvsmeister   = \"\"               /* TSOID of NNMVS's Big Brother */\n\ntrace off\nsignal on novalue\nlibdeffed = 0\n\nif batch = \"\" then do\n \"ISPQRY\"\n if rc > 0 then do\n  parse arg args\n  parse source . . execname . execds .\n  if execds = \"?\" then\n   icmd = \"%\"execname args\n  else\n   icmd = \"EX '\"execds\"(\"execname\")'\" quote(args)\n  call startispf \"NEWAPPL(\"nnmappl\") CMD(\"icmd\")\"\n  exit\n end\nend\n\nsignal on failure\nsignal on halt\n\nif option <> \"\" then do\n if length(option) <> 1 | pos(option,\"TDB\") <> 0 then do\n  say \"NNMVS: Invalid option, \"option\".\"\n  exit 12\n end\n if server = \"\" then do\n  say \"NNMVS: SERVER is required when OPTION is specified.\"\n  exit 12\n end\n if newsrc = \"\" then do\n  say \"NNMVS: NEWSRC is required when OPTION is specified.\"\n  exit 12\n end\n if option = \"G\" & group = \"\" then do\n  say \"NNMVS: GROUP is required when OPTION(G) is specified.\"\n  exit 12\n end\n if registerstatus = \"\" then registerstatus = \"PROMPT\"\nend\n\ntestparm = \"-\"\nif test  = \"TEST\"  then testparm = testparm || \"t\"\nif debug = \"DEBUG\" then testparm = testparm || \"d\"\nif batch = \"BATCH\" then testparm = testparm || \"b\"\n\nif find_iucvmult() <> 0 then do\n say,\n\"A TCP/IP socket application may be active elsewhere in your session.\"\n if force = \"FORCE\" then do\n  say \"Proceeding anyhow, because you specified the FORCE keyword.\"\n end\n else do\n  say \"Please terminate the other application before trying this one.\"\n  say \"Or, if you are sure it's OK, try again with the FORCE keyword.\"\n  exit 8\n end\nend\n\nif batch <> \"\" then call nnm_batch\nelse do\n call libdef\n call nnm_dialog\nend\n\ncleanup:\nif libdeffed then call unlibdef\nexit\n\nerror:    say \"NNMVS:  Lossage has occurred.\"\n          say \"Statement:\" sourceline(sigl)\n          if nnmvswizard <> \"\" then say \"Please notify\" nnmvswizard\".\"\n          signal cleanup\nfailure:  say \"NNMVS:  A failure has eventuated.\"\n          say \"Statement:\" sourceline(sigl)\n          if nnmvswizard <> \"\" then say \"Please notify\" nnmvswizard\".\"\n          signal cleanup\nhalt:     say \"NNMVS:  A halt has been detected.\"\n          signal cleanup\n\nnnm_dialog:\n\n/* SERVER(*) --> (USC) Leonard Woren's server-table dialog */\n\nif server = \"*\" | newsrc = \"*\" then do\n nnmvsl_cmd = \"%NNMVSL\" new old\n address ISPEXEC \"SELECT CMD(\"nnmvsl_cmd\") PASSLIB NEWAPPL(\"nnmappl\")\"\n return\nend\n\nvputvars = \"\"\n\nif server <> \"\" then do\n nnserver = server\n vputvars = vputvars \"NNSERVER\"\nend\n\nif group <> \"\" | option = \"G\" then do\n nngroupi = group\n vputvars = vputvars \"NNGROUPI\"\nend\n\nif newsrc <> \"\" then do\n nnnewsrf = newsrc\n if left(newsrc,1) = \"'\" then nnnewsrc = strip(newsrc,\"B\",\"'\")\n else nnnewsrc = sysvar(\"SYSPREF\")\".\"newsrc\n vputvars = vputvars \"NNNEWSRF NNNEWSRC\"\nend\n\nif registerstatus <> \"\" then do\n nnregnng = left(registerstatus,1)\n vputvars = vputvars \"NNREGNNG\"\nend\n\nif vputvars <> \"\" then do\n address ISPEXEC \"VPUT (\"vputvars\") PROFILE\"\nend\n\nif option <> \"\" then do\n testparm = testparm || option\nend\n\ncall let_me_know\n\nzerrmsg = \"\"\nzerrsm  = \"\"\nzerrlm  = \"\"\n\nif nnmload = \"\" then do\n address ISPEXEC \"SELECT NEWAPPL(\"nnmappl\") PASSLIB\" ,\n                 \"PGM(\"nnmlmod\") PARM(\"testparm\")\"\nend\nelse do\n command = \"CALL '\"nnmload\"(\"nnmlmod\")'\" quote(testparm)\n address ISPEXEC \"SELECT NEWAPPL(\"nnmappl\") PASSLIB CMD(\"command\")\"\nend\n\nif rc <> 0 then say \"Return code from\" nnmlmod \"program is\" rc\n\naddress ISPEXEC \"VGET (ZERRSM ZERRLM)\"\nif zerrsm  <> \"\" then do\n say zerrmsg\":\" zerrsm\n say zerrlm\nend\n\nreturn\n\nnnm_batch:\n\nif newsrc = \"\" then do\n say \"NNMVS: NEWSRC is required when BATCH is specified.\"\n exit 12\nend\n\nif server <> \"\" ,\n | group  <> \"\" ,\n | registerstatus <> \"\" ,\n | option <> \"\" then do\n say \"NNMVS: SERVER, GROUP, OPTION, REGISTERSTATUS not valid\",\n            \"when BATCH is specified.\"\n exit 12\nend\n\naddress TSO \"ALLOC FI(NNBATIN)  DA(\"batchin\")  SHR REU\"\nif rc <> 0 then return\naddress TSO \"ALLOC FI(NNBATOUT) DA(\"batchout\") OLD REU\"\nif rc <> 0 then return\naddress TSO \"ALLOC FI(NNBATHLP) DA(\"batchhelp\") SHR REU\"\nif rc <> 0 then return\naddress TSO \"ALLOC FI(NNNEWSRC) DA(\"newsrc\")   OLD REU\"\nif rc <> 0 then return\n\ncall let_me_know \"BATCH\"\n\naddress TSO \"CALL '\"nnmload\"(\"nnmlmod\")'\" quote(testparm)\nnrc = rc\naddress TSO \"FREE FI(NNBATIN NNBATOUT NNBATHLP NNNEWSRC)\"\n\nif nrc <> 0 then say \"Return code from\" nnmlmod \"program is\" nrc\n\nreturn\n\nlet_me_know:\nif nnmvsmeister = \"\" | nnmvsmeister = userid() then return\nparse arg letarg\nparse source . . execname . execds .\ncall outtrap \"X.\"\naddress TSO,\n \"SEND\" quote(execds\"(\"execname\")\" letarg date(\"U\") time()\" \"),\n        \"U(\"nnmvsmeister\") LOGON\"\ncall outtrap \"OFF\"\nreturn\n\nlibdef:\nif nnmpanel <> \"\" then do\n address ISPEXEC \"LIBDEF ISPPLIB DATASET ID('\"nnmpanel\"')\"\n if rc <> 0 then do; call ispf_error rc; exit rc; end\nend\nif nnmload <> \"\" then do\n address ISPEXEC \"LIBDEF ISPLLIB DATASET ID('\"nnmload\"')\"\n if rc <> 0 then do; call ispf_error rc; exit rc; end\nend\nlibdeffed = 1\nreturn\n\nunlibdef:\nif nnmload <> \"\" then do\n address ISPEXEC \"LIBDEF ISPLLIB DATASET\"\n if rc <> 0 then call ispf_error rc\nend\nif nnmpanel <> \"\" then do\n address ISPEXEC \"LIBDEF ISPPLIB DATASET\"\n if rc <> 0 then call ispf_error rc\nend\nlibdeffed = 0\nreturn\n\nispf_error: parse arg ispfrc\n\nsay \"NNMVS: ISPF dialog service error detected...\"\nsay\nsay zerrmsg\":\" zerrsm\nsay zerrlm\nsay\n\nreturn ispfrc\n\n/*\n * The following function starts ISPF from READY mode.\n * Beware:  splitting the screen starts up an identical copy of the\n *          application, which may not be desirable.\n */\n\nstartispf: parse arg string\n\"ISPSTART\" string\nreturn\n\n/* The following function enquotes a string. */\n\nquote: parse arg string\nix = 1\ndo forever\n ix = pos(\"'\",string,ix)\n if ix = 0 then return \"'\"string\"'\"\n string = insert(\"'\",string,ix)\n ix=ix+2\nend\n\n/* The following function scans the job pack queues for IUCVMULT and\n * returns with an error code if IUCVMULT is already loaded under a\n * different TCB. This can only happen under PIE MultiTSO or a\n * similar product that makes multiple job step TCB's.\n */\n\nfind_iucvmult: procedure\n\ncall nnmfiucv\n\nreturn result\n\n./ ADD NAME=NNMMAIL\n/* REXX */\n\n/*********************************************************************/\n/*                                                                   */\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     */\n/*                                                                   */\n/* This software is provided on an \"AS IS\" basis.  All warranties,   */\n/* including the implied warranties of merchantability and fitness,  */\n/* are expressly denied.                                             */\n/*                                                                   */\n/* Provided this copyright notice is included, this software may     */\n/* be freely distributed and not offered for sale.                   */\n/*                                                                   */\n/* Changes or modifications may be made and used only by the maker   */\n/* of same, and not further distributed.  Such modifications should  */\n/* be mailed to the author for consideration for addition to the     */\n/* software and incorporation in subsequent releases.                */\n/*                                                                   */\n/*********************************************************************/\n\n/**********************************************************************/\n/*                                                                    */\n/* Argument 1: mail data set                                          */\n/* Argument 2: recipient(s)                                           */\n/*                                                                    */\n/**********************************************************************/\n\ntrace off\naddress TSO\n\n/* Tailor these to your installation requirements. */\n\nlocal_userid    = userid()\nlocal_domain    = \"MVS\"\nlocal_origin    = \"mvs.draper.com\"\nlocal_smtp_node = \"SMTPSRV\"\n\nparse arg maildsn to\n\nif pos(\"@\",to) = 0 then to = to\"@\"local_origin\nelse do\n parse var to before \"<\" after \">\" junk\n if after <> \"\" then to = after\nend\n\n\"ALLOC FI(NNMMAILI) SHR REU DA(\"maildsn\")\"\nif rc \\= 0 then return rc\n\"EXECIO * DISKR NNMMAILI (FINIS STEM IN.)\"\nif rc \\= 0 then return rc\n\"newstack\"\nsay   \"HELO\" local_domain\nqueue \"HELO\" local_domain\nsay   \"MAIL FROM:<\"local_userid\"@\"local_origin\">\"\nqueue \"MAIL FROM:<\"local_userid\"@\"local_origin\">\"\nsay   \"RCPT TO:<\"to\">\"\nqueue \"RCPT TO:<\"to\">\"\nqueue \"DATA\"\ndo i = 1 to in.0\n if left(in.i,1) = \".\" then queue \".\"in.i\n else if in.i = \"\" then queue \" \"\n else queue in.i\nend\nqueue \".\"\nqueue \"QUIT\"\nqueue \"\"\n\"EXECIO * DISKW NNMMAILI (FINIS)\"\nif rc \\= 0 then return rc\n\"delstack\"\n\"FREE FI(NNMMAILI)\"\n\n\"TRANSMIT\" local_domain\".\"local_smtp_node,\n           \"DATASET(\"maildsn\") NOEPILOG NOLOG NOPROLOG\"\n\nreturn 0\n\n/* The following function enquotes a string. */\nquote:\nparse arg string\nix = 1\ndo forever\n ix = pos(\"'\",string,ix)\n if ix = 0 then return \"'\"string\"'\"\n string = insert(\"'\",string,ix)\n ix=ix+2\nend\n./ ENDUP\n?!\n//H        EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='H'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=NN\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* --------------------- \"nn.h\" include member --------------------- */\n\n#pragma linkage(ispexec,OS)\n#pragma linkage(isplink,OS)\n#pragma linkage(ikjeff18,OS)\n\n/****** Installation-customized defines. *****************************/\n\n#include \"nnuser.h\"\n\n#ifndef  C370V1\n#ifndef  C370V2\n#ifndef  SASC\n install_error_neither_C370V1_C370V2_nor_SASC_was_defined;\n#endif\n#endif\n#endif\n\n#ifndef  TCPIPV1\n#ifndef  TCPIPV2\n#ifndef  SNSTCP\n install_error_neither_TCPIPV1_nor_TCPIPV2_nor_SNSTCP_was_defined;\n#endif\n#endif\n#endif\n\n#ifndef  ISPFV2\n#ifndef  ISPFV3\n install_error_neither_ISPFV2_nor_ISPFV3_was_defined;\n#endif\n#endif\n\n#define  MVS\n\n#ifdef  SNSTCPIP\n#ifndef I370\n#define SNSC370\n#endif\n#endif\n\n#ifdef C370V2\n#pragma checkout(suspend)\n#endif\n\n/****** Clean up compiler warnings BEFORE time.h gets 'em ************/\n\n#ifndef  SASC\n#define  localtime            LOCALTIM\n#endif\n\n/****** Include all header files that are necessary. *****************/\n\n#include <manifest.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n/*\n#include <tcperrno.h>\n*/\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stddef.h>\n#include <time.h>\n/*\n#include <signal.h>\n*/\n\n#ifndef  SASC\n#include <ctest.h>\n#endif\n\n#ifdef   SASC\n#include \"nnsasc.h\"\n#endif\n\n/****** Version-dependent stuff **************************************/\n\n#ifdef   C370V1\n#undef   FETCH\n#endif\n\n#ifdef   C370V2\n#define  FETCH\n#endif\n\n#ifdef   TCPIPV1\n#define  TCP_DEBUG            tcp_debug\n#endif\n\n#ifdef   TCPIPV2\n#define  TCP_DEBUG            sock_debug\n#endif\n\n#ifdef   DEBUG\n#define  TCP_DEBUG_ON         TCP_DEBUG(1)\n#define  TCP_DEBUG_OFF        TCP_DEBUG(0)\n#else\n#define  TCP_DEBUG_ON         /* */\n#define  TCP_DEBUG_OFF        /* */\n#endif\n\n#ifdef   ISPFV3\n#define  ZERRLM_SIZE          513\n#else\n#define  ZERRLM_SIZE          73\n#endif\n\n/****** Preprocessor bookkeeping *************************************/\n\n#ifndef  MAX\n#define  MAX(A,B)             ((A) > (B) ? (A) : (B))\n#endif\n#ifndef  MIN\n#define  MIN(A,B)             ((A) < (B) ? (A) : (B))\n#endif\n\n#define  Bool                 char\n#define  Fool                 unsigned int /* for function arguments */\n\n#define  COMMANDSIZE          12\n\n#define  READ_BYTES           1024\n#define  SERVER_BUF_MSGSIZE   1024\n#define  CLIENT_BUF_MSGSIZE   1024\n#define  TEXT_BYTES           1024\n#define  INTERNET_SIZE        256\n\n#define  GROUP_NAME_SIZE      255\n\n#define  NNTP_PORT_NUMBER     119\n\n#define  SOCKET_GETCHAR_ERROR (-1)\n#define  SOCKET_NO_MORE       (-2)\n#define  SOCKET_READ_NOTHING  (-3)\n\n#define  NO_NNTP_MESSAGE_NUM  (-1)\n#define  NO_VALUE             (-1)\n#define  PHONY_NEWS_ARTICLE   (-1)\n\n#define  Rstruc               register struct\n\n#define  EQUAL                !strcmp\n#define  UNEQUAL              strcmp\n\n#define  NEWSRC_ORDER         'N'\n#define  NNTP_LIST_ORDER      'L'\n#define  ALPHABETICAL_ORDER   'A'\n\n#define  FIND_NEXT            'N'\n#define  FIND_FIRST           'F'\n#define  FIND_LAST            'L'\n#define  FIND_PREV            'P'\n#define  FIND_ALL             'A'\n#define  FIND_CHARS           '\\0'\n#define  FIND_WORD            'W'\n#define  FIND_PREFIX          'P'\n#define  FIND_SUFFIX          'S'\n#define  FIND_CAPS            '\\0'\n#define  FIND_ASIS            'A'\n#define  FIND_HEX             'X'\n#define  FIND_GENERIC         'P'\n#define  FIND_BADFORM         '\\0'\n#define  FIND_UNQUOTED        'U'\n#define  FIND_QUOTED          'Q'\n#define  FIND_C               'C'\n#define  FIND_X               'X'\n#define  FIND_T               'T'\n#define  FIND_P               'P'\n\n#define  MAX_INT               (int)0x7fffffff\n#define  LOCATE_INT            (int)0x7ffffffe\n\n#define  SELECTION_ALL        'A'\n#define  SELECTION_REG        'R'\n#define  SELECTION_NNTP       'P'\n#define  SELECTION_GROUP      'G'\n#define  SELECTION_LIST       'L'\n#define  SELECTION_NEWG       'N'\n#define  SELECTION_OPTS       'O'\n#define  SELECTION_EXIT       'X'\n#define  SELECTION_LIST_DISCONNECT  'Z'\n\n#define  NO_ACTION            '\\0'\n#define  READ                 'R'\n#define  RETRIEVED            'V'\n#define  EXTRACTED            'X'\n#define  PRINTED              'P'\n#define  UNREAD               'U'\n#define  MISSING              'M'\n#define  ERROR                'E'\n#define  CANCELLED            'C'\n\n#define  CARRIAGE_RETURN      ('\\r')\n\n#ifdef   MVS\n#ifdef   I370\n#define  LINE_FEED            (0x15)\n#else\n#define  LINE_FEED            (0x25)\n#endif\n#else\n#define  LINE_FEED            (0x0a)\n#endif\n\n#ifdef   MVS\n#ifdef   I370\n#define  EtoA                 htoncs\n#define  AtoE                 ntohcs\n#else\n#ifdef   SNSTCPIP\n#define  EtoA                 etoa\n#define  AtoE                 atoe\n#else\n#define  EtoA(x)              ebcdictoascii\u00ddx\u00a8\n#define  AtoE(x)              asciitoebcdic\u00ddx\u00a8\n#define  ebcdictoascii        ebcdicto\n#define  asciitoebcdic        asciitoe\n#endif\n#endif\n#endif\n\n#ifdef SNSC370\n#define EBCDIC_TO_ASCII(A,B) EtoA(A,B)\n#define ASCII_TO_EBCDIC(A,B) AtoE(A,B)\n#else\n#define EBCDIC_TO_ASCII(A,B) {int _i; \\\n                              for (_i=0; _i<(B); ++_i) \\\n                                  (A)\u00dd_i\u00a8 = EtoA((A)\u00dd_i\u00a8); \\\n                             }\n#define ASCII_TO_EBCDIC(A,B) {int _i; \\\n                              for (_i=0; _i<(B); ++_i) \\\n                                  (A)\u00dd_i\u00a8 = AtoE((A)\u00dd_i\u00a8); \\\n                             }\n#endif\n\n#ifdef TCPIPV1\n#define REPORT_TCP_ERROR(A)  /* */\n#endif\n\n#ifdef TCPIPV2\n#define REPORT_TCP_ERROR(A)  tcperror(A)\n#endif\n\n#ifdef SNSTCPIP\n#define REPORT_TCP_ERROR(A)  fprintf(stderr,\\\n                                    \"\\nTCP error on %s: errno = %d\\n\",\\\n                                    A,GET_ERRNO)\n#endif\n\n#ifdef SNSC370\n#define Accept(A,B,C)        accept((A),(struct sockaddr *)(B),(C))\n#define Bind(A,B,C)          bind((A),(struct sockaddr *)(B),(C))\n#define Connect(A,B,C)       connect((A),(struct sockaddr *)(B),(C))\n#define Gethostbyaddr(A,B,C) gethostbyaddr((char *)(A),(B),(C))\n#define Getpeername(A,B,C)   getpeername((A),(struct sockaddr *)(B),(C))\n#define Getsockopt(A,B,C,D)  getsockopt((A),(B),(char *)(C),(D))\n#define EWOULDBLOCK          ESWOULDBLOCK\n#define errno                GET_ERRNO\n#else\n#define Accept               accept\n#define Bind                 bind\n#define Connect              connect\n#define Gethostbyaddr        gethostbyaddr\n#define Getpeername          getpeername\n#define Getsockopt           getsockopt\n#endif\n\n#ifdef   FETCH\n#define  ISPLINK              (np->isplink_pointer)\n#define  ISPEXEC              (np->ispexec_pointer)\n#else\n#define  ISPLINK              isplink\n#define  ISPEXEC              ispexec\n#endif\n\n#ifndef I370\n\n#define  WRITE_FILEMODE     \"w,recfm=vb,lrecl=259,blksize=6233\"\n#define  APPEND_FILEMODE    \"a,recfm=vb,lrecl=259,blksize=6233\"\n#define  SYSOUT_FILEMODE    \"w,recfm=vba,lrecl=133\"\n#define  FILEMODE             \"recfm=vb,lrecl=259,blksize=6233\"\n#define  FILEMODE_A           \"recfm=vba,lrecl=133\"\n\n#define  OPEN_TEXT_FILE_FOR_WRITE(F)  \\\n         fopen((F),WRITE_FILEMODE)\n\n#define  OPEN_TEXT_FILE_FOR_APPEND(F)  \\\n         fopen((F),APPEND_FILEMODE)\n\n#define  OPEN_TEXT_FILE_FOR_WRITE_OR_APPEND(F,B)  \\\n         fopen((F),(B) ? APPEND_FILEMODE : WRITE_FILEMODE)\n\n#define  OPEN_OUTPUT_FILE_FOR_WRITE_OR_APPEND(F,B)  \\\n         fopen((F),(B) ? \"a\" : WRITE_FILEMODE)\n\n#define  OPEN_SYSOUT_FILE(F)  \\\n         fopen((F),SYSOUT_FILEMODE)\n\n#define  TEST_IF_FILE_EXISTS(P,F)  (P=fopen((F),\"r\"))\n#define  CLEANUP_IF_FILE_EXISTS(P) (void)fclose(P)\n\n#else\n\n#define  WRITE_FILEMODE     \"w,recfm=v,reclen=255,blksize=6233\"\n#define  APPEND_FILEMODE    \"a,recfm=v,reclen=255,blksize=6233\"\n#define  SYSOUT_FILEMODE    \"w,recfm=v,reclen=133,print=yes\"\n#define  FILEMODE             \"recfm=v,reclen=255,blksize=6233\"\n#define  FILEMODE_A           \"recfm=v,reclen=133,print=yes\"\n\n#define  OPEN_TEXT_FILE_FOR_WRITE(F)  \\\n         afopen((F),\"w\",\"seq\",FILEMODE)\n\n#define  OPEN_TEXT_FILE_FOR_APPEND(F)  \\\n         afopen((F),\"a\",\"seq\",FILEMODE)\n\n#define  OPEN_TEXT_FILE_FOR_WRITE_OR_APPEND(F,B)  \\\n         afopen((F),(B)?\"a\":\"w\",\"seq\",FILEMODE)\n\n#define  OPEN_OUTPUT_FILE_FOR_WRITE_OR_APPEND(F,B)  \\\n         afopen((F),(B)?\"a\":\"w\",\"seq\",FILEMODE)\n\n#define  OPEN_SYSOUT_FILE(F)  \\\n         afopen((F),\"w\",\"seq\",FILEMODE_A)\n\n#define  TEST_IF_FILE_EXISTS(F,P)  (access((F),0) == 0)\n#define  CLEANUP_IF_FILE_EXISTS(P) /* */\n\n#endif\n\n#define ebdtoasc(C) {char *__cp;\\\n                     for(__cp = C;*__cp;__cp++) *__cp = EtoA(*__cp);}\n\n#define asctoebd(C) {char *__cp;\\\n                     for(__cp = C;*__cp;__cp++) *__cp = AtoE(*__cp);}\n\n#define uppercase_in_place(C) {char *__cp;\\\n                     for(__cp=C;*__cp;__cp++) *__cp = toupper(*__cp);}\n\n#define lowercase_in_place(C) {char *__cp;\\\n                     for(__cp=C;*__cp;__cp++) *__cp = tolower(*__cp);}\n\n#define strip_trailing_in_place(C) {char *__cp;\\\n                     for(__cp=strchr((C),'\\0');\\\n                         __cp>C && isspace(*(__cp-1)); __cp--);\\\n                     *__cp='\\0';}\n\n#define uppercase_and_strip_trailing_in_place(C) {char *__cp;\\\n                     for(__cp=C;*__cp;__cp++) *__cp = toupper(*__cp);\\\n                     for(; __cp>C && isspace(*(__cp-1)); __cp--);\\\n                     *__cp='\\0';}\n\n#define lowercase_and_strip_trailing_in_place(C) {char *__cp;\\\n                     for(__cp=C;*__cp;__cp++) *__cp = tolower(*__cp);\\\n                     for(; __cp>C && isspace(*(__cp-1)); __cp--);\\\n                     *__cp='\\0';}\n\n#define copy_uppercase(A,B) {char *__cA,*__cB;\\\n                     for (__cA=A,__cB=B; *__cB;__cA++,__cB++)\\\n                         *__cA = toupper(*__cB);\\\n                     *__cA='\\0';}\n\n#define copy_lowercase(A,B) {char *__cA,*__cB;\\\n                     for (__cA=A,__cB=B; *__cB;__cA++,__cB++)\\\n                         *__cA = tolower(*__cB);\\\n                     *__cA='\\0';}\n\n#define copy_uppercase_and_strip_trailing(A,B,C) {char *__cA,*__cB;\\\n                     for (__cA=A,__cB=B; *__cB;__cA++,__cB++)\\\n                         *__cA = toupper(*__cB);\\\n                     for (; __cA>A && isspace(*(__cA-1)); __cA--);\\\n                     *__cA='\\0';C=__cA;}\n\n#define copy_lowercase_and_strip_trailing(A,B,C) {char *__cA,*__cB;\\\n                     for (__cA=A,__cB=B; *__cB;__cA++,__cB++)\\\n                         *__cA = tolower(*__cB);\\\n                     for (; __cA>A && isspace(*(__cA-1)); __cA--);\\\n                     *__cA='\\0';C=__cA;}\n\n#define skip_whitespace(C)        (C) + strspn((C),\" \\t\")\n#define skip_ISPF_whitespace(C)   (C) + strspn((C),\" ,\\t\")\n#define find_whitespace(A,B)      if (!(A=strpbrk((B),\" \\t\")))\\\n                                     A = strchr((B),'\\0');\n#define find_ISPF_whitespace(A,B) if (!(A=strpbrk((B),\" ,\\t\")))\\\n                                     A = strchr((B),'\\0');\n\n#define  DATAOUT_LOW          0x01\n#define  DATAOUT_HIGH         0x02\n#define  DATAIN_LOW           0x03\n#define  DATAIN_HIGH          0x04\n#define  DATAOUT_BLUE         DATAOUT_LOW\n#define  DATAOUT_GREEN        0x05\n#define  DATAOUT_PINK         0x06\n#define  DATAOUT_RED          0x07\n#define  DATAOUT_TURQ         0x08\n#define  DATAOUT_WHITE        DATAOUT_HIGH\n#define  DATAOUT_YELLOW       0x09\n#define  DATAIN_BLUE          0x0a\n#define  DATAIN_GREEN         DATAIN_LOW\n#define  DATAIN_PINK          0x0b\n#define  DATAIN_RED           DATAIN_HIGH\n#define  DATAIN_TURQ          0x0c\n#define  DATAIN_WHITE         0x0d\n#define  DATAIN_YELLOW        0x0e\n\n#define  S99VRBAL  0x01             /* ALLOCATION                    */\n#define  S99VRBUN  0x02             /* UNALLOCATION                  */\n#define  S99VRBCC  0x03             /* CONCATENATION                 */\n#define  S99VRBDC  0x04             /* DECONCATENATION               */\n#define  S99VRBRI  0x05             /* REMOVE IN-USE                 */\n#define  S99VRBDN  0x06             /* DDNAME ALLOCATION             */\n#define  S99VRBIN  0x07             /* INFORMATION RETRIEVAL         */\n#define  S99NOCNV  0x40             /* ALLOC FUNCTION-DO NOT USE AN  */\n                                    /* EXISTING ALLOCATION TO SATISFY*/\n                                    /* THE REQUEST                   */\n#define  DALDDNAM   0x0001          /* DDNAME                        */\n#define  DALDSNAM   0x0002          /* DSNAME                        */\n#define  DALMEMBR   0x0003          /* MEMBER NAME                   */\n#define  DALSTATS   0x0004          /* DATA SET STATUS               */\n#define  DALNDISP   0x0005          /* DATA SET DISPOSITION          */\n#define  DALTRK     0x0007          /* TRACK SPACE TYPE              */\n#define  DALBLKLN   0x0009          /* BLOCK LENGTH                  */\n#define  DALPRIME   0x000a          /* PRIMARY SPACE ALLOCATION      */\n#define  DALSECND   0x000b          /* SECONDARY SPACE ALLOCATION    */\n#define  DALDIR     0x000c          /* DIRECTORY BLOCK ALLOCATION    */\n#define  DALSYSOU   0x0018          /* SYSOUT                        */\n#define  DALSFMNO   0x001a          /* SYSOUT FORMS NUMBER           */\n#define  DALCOPYS   0x001d          /* SYSOUT COPIES                 */\n#define  DALUCS     0x0029          /* UNIVERSAL CHARACTER SET       */\n#define  DALBLKSZ   0x0030          /* DCB BLOCKSIZE                 */\n#define  DALDSORG   0x003c          /* DATA SET ORGANIZATION         */\n#define  DALLRECL   0x0042          /* DCB LOGICAL RECORD LENGTH     */\n#define  DALRECFM   0x0049          /* DCB RECORD FORMAT             */\n#define  DALPERMA   0x0052          /* PERMANENTLY ALLOCATED ATTRIB  */\n#define  DALRTDDN   0x0055          /* RETURN DDNAME                 */\n#define  DALRTDSN   0x0056          /* RETURN DSNAME                 */\n#define  DALRTORG   0x0057          /* RETURN D.S. ORGANIZATION      */\n#define  DALSUSER   0x0058          /* SYSOUT REMOTE WORKSTATION     */\n#define  DUNDDNAM   0x0001          /* DDNAME                        */\n#define  DUNDSNAM   0x0002          /* DSNAME                        */\n#define  DUNUNALC   0x0007          /* UNALLOC OPTION                */\n\n#define  SHR        0x08\n#define  NEW        0x04\n#define  MOD        0x02\n#define  OLD        0x01\n#define  KEEP       0x08\n#define  DELETE     0x04\n#define  CATLG      0x02\n#define  UNCATLG    0x01\n#define  RECFM_F    0x80\n#define  RECFM_V    0x40\n#define  RECFM_U    0xc0\n#define  RECFM_D    0x20\n#define  RECFM_T    0x20\n#define  RECFM_B    0x10\n#define  RECFM_S    0x08\n#define  RECFM_A    0x04\n#define  RECFM_M    0x02\n#define  RECFM_FB   (RECFM_F | RECFM_B)\n#define  RECFM_VB   (RECFM_V | RECFM_B)\n#define  DSORG_PS   0x4000\n#define  DSORG_PO   0x0200\n\n/************************ Newsgroup status ***************************/\n\n#define NO_SUCH_GROUP             0x80\n#define NEW_GROUP                 0x40\n#define GROUP_FROM_NEWSRC         0x20\n#define GROUP_LISTED              0x10\n#define GROUP_SELECTED_UNREAD     0x08\n#define GROUP_SELECTED_READ       0x04\n#define GROUP_ERROR               0x02\n#define GROUP_IN_TABLE            0x01\n\n#define GROUP_SELECTED    (GROUP_SELECTED_UNREAD | GROUP_SELECTED_READ)\n\n/* Note that the test GroupSelected means unread OR read, but the\n * assignment SetGroupSelected means set unread AND read selected\n * assignment OffGroupSelected means set unread AND read unselected.\n */\n\n#define NoSuchGroup(X)            ((X)->status & NO_SUCH_GROUP)\n#define NewGroup(X)               ((X)->status & NEW_GROUP)\n#define GroupFromNewsrc(X)        ((X)->status & GROUP_FROM_NEWSRC)\n#define GroupListed(X)            ((X)->status & GROUP_LISTED)\n#define GroupSelectedUnread(X)    ((X)->status & GROUP_SELECTED_UNREAD)\n#define GroupSelectedRead(X)      ((X)->status & GROUP_SELECTED_READ)\n#define GroupError(X)             ((X)->status & GROUP_ERROR)\n#define GroupInTable(X)           ((X)->status & GROUP_IN_TABLE)\n\n#define GroupSelected(X)          ((X)->status & GROUP_SELECTED)\n\n#define SetNoSuchGroup(X)          (X)->status |= NO_SUCH_GROUP\n#define SetNewGroup(X)             (X)->status |= NEW_GROUP\n#define SetGroupFromNewsrc(X)      (X)->status |= GROUP_FROM_NEWSRC\n#define SetGroupListed(X)          (X)->status |= GROUP_LISTED\n#define SetGroupSelectedUnread(X)  (X)->status |= GROUP_SELECTED_UNREAD\n#define SetGroupSelectedRead(X)    (X)->status |= GROUP_SELECTED_READ\n#define SetGroupError(X)           (X)->status |= GROUP_ERROR\n#define SetGroupInTable(X)         (X)->status |= GROUP_IN_TABLE\n\n#define SetGroupSelected(X)        (X)->status |= GROUP_SELECTED\n\n#define OffNoSuchGroup(X)          (X)->status &= ~NO_SUCH_GROUP\n#define OffNewGroup(X)             (X)->status &= ~NEW_GROUP\n#define OffGroupFromNewsrc(X)      (X)->status &= ~GROUP_FROM_NEWSRC\n#define OffGroupListed(X)          (X)->status &= ~GROUP_LISTED\n#define OffGroupSelectedUnread(X)  (X)->status &= ~GROUP_SELECTED_UNREAD\n#define OffGroupSelectedRead(X)    (X)->status &= ~GROUP_SELECTED_READ\n#define OffGroupError(X)           (X)->status &= ~GROUP_ERROR\n#define OffGroupInTable(X)         (X)->status &= ~GROUP_IN_TABLE\n\n#define OffGroupSelected(X)        (X)->status &= ~GROUP_SELECTED\n\n#define GroupListedOnly(X)        (GroupListed(X) && !GroupSelected(X))\n#define GroupFromNNTP(X)          (GroupListed(X) || GroupSelected(X))\n#define GroupFromNewsrcOnly(X)    (GroupFromNewsrc(X) && \\\n                                   !GroupListed(X) && \\\n                                   !GroupSelected(X))\n#define BogusGroup(X)             (!GroupListed(X) && !GroupSelected(X))\n\n#define ClearGroupStatus(X)        (X)->status = 0x00\n#define NullGroupStatus(X)        ((X)->status == 0x00)\n\n/************************* Article status ****************************/\n\n#define NO_SUCH_ARTICLE           0x80\n#define ARTICLE_ABSENT            0x40\n#define ARTICLE_ERROR             0x20\n#define ARTICLE_BAD_DATA          0x10\n#define ARTICLE_HEAD_RETRIEVED    0x08\n#define ARTICLE_BODY_RETRIEVED    0x04\n\n#define ARTICLE_RETRIEVED         (ARTICLE_HEAD_RETRIEVED | \\\n                                   ARTICLE_BODY_RETRIEVED)\n\n#define NoSuchArticle(X)          ((X)->status & NO_SUCH_ARTICLE)\n#define ArticleAbsent(X)          ((X)->status & ARTICLE_ABSENT)\n#define ArticleError(X)           ((X)->status & ARTICLE_ERROR)\n#define ArticleBadData(X)         ((X)->status & ARTICLE_BAD_DATA)\n#define ArticleHeadRetrieved(X)   ((X)->status & ARTICLE_HEAD_RETRIEVED)\n#define ArticleBodyRetrieved(X)   ((X)->status & ARTICLE_BODY_RETRIEVED)\n\n#define SetNoSuchArticle(X)        (X)->status |= NO_SUCH_ARTICLE\n#define SetArticleAbsent(X)        (X)->status |= ARTICLE_ABSENT\n#define SetArticleError(X)         (X)->status |= ARTICLE_ERROR\n#define SetArticleBadData(X)       (X)->status |= ARTICLE_BAD_DATA\n#define SetArticleHeadRetrieved(X) (X)->status |= ARTICLE_HEAD_RETRIEVED\n#define SetArticleBodyRetrieved(X) (X)->status |= ARTICLE_BODY_RETRIEVED\n\n#define OffNoSuchArticle(X)        (X)->status &=~NO_SUCH_ARTICLE\n#define OffArticleAbsent(X)        (X)->status &=~ARTICLE_ABSENT\n#define OffArticleError(X)         (X)->status &=~ARTICLE_ERROR\n#define OffArticleBadData(X)       (X)->status &=~ARTICLE_BAD_DATA\n#define OffArticleHeadRetrieved(X) (X)->status &=~ARTICLE_HEAD_RETRIEVED\n#define OffArticleBodyRetrieved(X) (X)->status &=~ARTICLE_BODY_RETRIEVED\n\n#define ArticleRetrieved(X)       ((X)->status & ARTICLE_RETRIEVED)\n#define SetArticleRetrieved(X)     (X)->status |= ARTICLE_RETRIEVED\n#define OffArticleRetrieved(X)     (X)->status &= ~ARTICLE_RETRIEVED\n\n#define ClearArticleStatus(X)      (X)->status = 0x00\n#define NullArticleStatus(X)      ((X)->status == 0x00)\n\n/************************* Article vector ****************************/\n\n/*\n * *** IMPORTANT! *** The hack of storing a vector of VARKs (which are\n * both pointers and status bits) depends on malloc() returning storage\n * for a struct on a doubleword boundary on MVS.  This allows us to\n * treat the low-order 3 bits of the pointer as trash so that we can\n * store status bits in it.  If this is not true, then this whole\n * technique will collapse like a house of cards, or else you should\n * stick a dummy double element into the newsarticle struct to make it\n * so.\n */\n\n/*\n * Each article \"pointer\" (VARK) looks like this:\n *\n * -------------------------------------\n * |                       |   |   |   |\n * | pointer to article    | . | . | . |\n * |                       |   |   |   |\n * -------------------------------------\n *                           \u00ac   \u00ac   \u00ac\n * where pointer is one of   |   |   |\n * NULL - no article         |   |   '--- 1 = Read, 0 = Unread\n * MISSING - article missing |   |   |\n * or the actual pointer     |   '------} 1 = Eligible, 0 = Ineligible\n *                           |\n *                           '----------} 1 = I know, 0 = I don't know\n *\n *                                        10 = Ineligible (not in table)\n *                                        11 = Eligible (in table)\n *                                        00 = Don't know yet\n *                                        01 cannot occur\n *\n */\n\n#define  VARK                  unsigned int\n\n#define  GETVARK(X,Y)          ((X)->article_vector\\\n                                \u00dd(Y)-(X)->vector_first\u00a8)\n#define  GETVARKFIRST(X)       ((X)->article_vector\u00dd0\u00a8)\n#define  GETVARKLAST(X)        ((X)->article_vector\\\n                                \u00dd(X)->article_vector_len-1\u00a8)\n\n#define  VARK2PARTICLE(X)      (struct newsarticle *) \\\n                                (((unsigned int)(X)) & 0xfffffff8)\n#define  VARK2NUMBER(X,Y)      (((Y)-(X)->article_vector) \\\n                                + (X)->vector_first)\n#define  VARK2BITS(X)          ((unsigned int)(X) & 0x00000007)\n#define  VARK2READNESS(X)      ((unsigned int)(X) & 0x00000001)\n#define  VARK2ELIGIBILITY(X)   ((unsigned int)(X) & 0x00000002)\n#define  VARK2KNOWLEDGE(X)     ((unsigned int)(X) & 0x00000004)\n\n#define  V_READNESS(X,Y)       VARK2READNESS(GETVARK(X,Y))\n#define  V_ELIGIBILITY(X,Y)    VARK2ELIGIBILITY(GETVARK(X,Y))\n#define  V_KNOWLEDGE(X,Y)      VARK2KNOWLEDGE(GETVARK(X,Y))\n\n#define  V_NULL_ARTICLE        (struct newsarticle *)0\n#define  V_MISSING_ARTICLE     (struct newsarticle *)np\n#define  VARKMISSING           (unsigned int)np\n#define  VARKNULL              (unsigned int)0\n\n#define  V_UNREAD_BIT          0x00000000\n#define  V_READ_BIT            0x00000001\n#define  V_INELIGIBLE_BIT      0x00000000\n#define  V_ELIGIBLE_BIT        0x00000002\n#define  V_UNKNOWN_BIT         0x00000000\n#define  V_KNOWN_BIT           0x00000004\n\n#define  V_KNOWN_ELIGIBLE      (V_KNOWN_BIT + V_ELIGIBLE_BIT)\n#define  V_KNOWN_INELIGIBLE    (V_KNOWN_BIT + V_INELIGIBLE_BIT)\n\n#define  SetUnread(X)          X &= ~V_READ_BIT\n#define  SetRead(X)            X |= V_READ_BIT\n#define  SetNull(X)            X = VARKNULL\n\n /* Note that whenever you set something missing, you also set it\n  * ineligible for table display.\n  */\n\n#define  SetMissing(X)         X = (VARK)\\\n                                   (VARKMISSING | \\\n                                    VARK2READNESS(X) | \\\n                                    V_KNOWN_INELIGIBLE)\n#define  SetMissingUnread(X)   X = (VARK)\\\n                                   (VARKMISSING | \\\n                                    V_UNREAD_BIT | \\\n                                    V_KNOWN_INELIGIBLE)\n#define  SetMissingRead(X)     X = (VARK)\\\n                                   (VARKMISSING | \\\n                                    V_READ_BIT | \\\n                                    V_KNOWN_INELIGIBLE)\n#define  SetEligible(X)        X |= V_ELIGIBLE_BIT\n#define  SetIneligible(X)      X &= ~V_ELIGIBLE_BIT\n#define  SetKnown(X)           X |= V_KNOWN_BIT\n#define  SetUnknown(X)         X &= ~V_KNOWN_BIT\n#define  SetKnownEligible(X)   SetKnown(X), SetEligible(X)\n#define  SetKnownIneligible(X) SetKnown(X), SetIneligible(X)\n\n/* to get exact readness, use: VARK2READNESS(X) == V_whatever */\n\n#define  IsRead(X)            ((X) & V_READ_BIT)\n#define  IsUnread(X)          (!IsRead(X))\n#define  IsEligible(X)        ((X) & V_ELIGIBLE_BIT)\n#define  IsIneligible(X)      (!IsEligible(X))\n#define  IsKnown(X)           ((X) & V_KNOWN_BIT)\n#define  IsUnknown(X)         (!IsKnown(X))\n#define  IsKnownEligible(X)   ((X)&V_KNOWN_ELIGIBLE==V_KNOWN_ELIGIBLE)\n#define  IsKnownIneligible(X) ((X)&V_KNOWN_ELIGIBLE==V_KNOWN_INELIGIBLE)\n\n#define  IsNull(X)            (VARK2PARTICLE(X) == V_NULL_ARTICLE)\n#define  IsMissing(X)         (VARK2PARTICLE(X) == V_MISSING_ARTICLE)\n#define  IsPresent(X)         (!IsMissing(X))\n#define  IsMissingUnread(X)   (IsMissing(X) && IsUnread(X))\n#define  IsMissingRead(X)     (IsMissing(X) && IsRead(X))\n#define  IsPresentUnread(X)   (IsPresent(X) && IsUnread(X))\n#define  IsPresentRead(X)     (IsPresent(X) && IsRead(X))\n\n#define  NOTIFY_MSG   1\n#define  WARNING_MSG  2\n#define  CRITICAL_MSG 3\n\n#define  WARN1(X)           NNMpmsg(np,NOTIFY_MSG,NULL,X)\n#define  WARN2(X,Y)         NNMpmsg(np,NOTIFY_MSG,NULL,X,Y)\n#define  WARN3(X,Y,Z)       NNMpmsg(np,NOTIFY_MSG,NULL,X,Y,Z)\n#define  WARN4(X,Y,Z,W)     NNMpmsg(np,NOTIFY_MSG,NULL,X,Y,Z,W)\n#define  ERR1(X)            NNMpmsg(np,WARNING_MSG,NULL,X)\n#define  ERR2(X,Y)          NNMpmsg(np,WARNING_MSG,NULL,X,Y)\n#define  ERR3(X,Y,Z)        NNMpmsg(np,WARNING_MSG,NULL,X,Y,Z)\n#define  ERR4(X,Y,Z,W)      NNMpmsg(np,WARNING_MSG,NULL,X,Y,Z,W)\n#define  CRIT1(X)           NNMpmsg(np,CRITICAL_MSG,NULL,X)\n#define  CRIT2(X,Y)         NNMpmsg(np,CRITICAL_MSG,NULL,X,Y)\n#define  CRIT3(X,Y,Z)       NNMpmsg(np,CRITICAL_MSG,NULL,X,Y,Z)\n\n#define  MSG(X)             (MSG_is_obsolete,)\n\n#define  GETMAIN(Ptr,Typ,Siz,For) \\\n         NNMgetm(np,(char **)&(Ptr),(sizeof(Typ))*(Siz),For)\n\n#define  FREEMAIN(Ptr,For)    if (Ptr) {NNMfreem(np,(char *)Ptr,For);}\n\n/****** Data and structure definitions. ******************************/\n\nenum scroll         {NO_SCROLL, UP, DOWN, LEFT, RIGHT, LOCATE};\nenum extreq         {EXTRACT_IT, PRINT_IT};\nenum data_set_type  {PDS, SEQ, UNK, JES};\nenum choose_reason  {RETRIEVE, MARK_ONLY};\n\nenum list_option    {LIST_ALL,\n                     LIST_NEW,\n                     LIST_ALL_DISCONNECT,\n                     LIST_ALL_RESCAN\n                    };\n\nenum socket_retval  {\n                     SERVER_READ_OK,\n                     SERVER_READ_ERROR,\n                     SERVER_BUFFER_ERROR,\n                     SERVER_NO_MORE\n                    };\n\nenum display_retval {\n                     DISPLAY_REPEAT,\n                     DISPLAY_EXIT,\n                     DISPLAY_ERROR,\n                     DISPLAY_FAILURE\n                    };\n\n\n\nenum user_option    {\n                     OPTION_ALL,\n                     OPTION_HEADER,\n                     OPTION_OTHER,\n                     OPTION_VIEW\n                    };\n\nenum article_cookie {\n                     NULL_ARTICLE_COOKIE  ,\n                     UNREAD_THIS_ARTICLE  ,\n                     NEXT_ARTICLE         ,\n                     PREV_ARTICLE         ,\n                     NEXT_TABLED_ARTICLE  ,\n                     PREV_TABLED_ARTICLE  ,\n                     NEXT_UNREAD_ARTICLE  ,\n                     PREV_UNREAD_ARTICLE  ,\n                     NEXT_THREAD_ARTICLE  ,\n                     PREV_THREAD_ARTICLE  ,\n                     FIRST_THREAD_ARTICLE ,\n                     LAST_THREAD_ARTICLE  ,\n                     NEW_THREAD_ARTICLE   ,\n                     REDISPLAY_ARTICLE\n                    };\n\ntypedef  struct   _textunit     TEXTUNIT;\ntypedef  unsigned int           IPADDRESS;\ntypedef  enum     scroll        SCROLL;\ntypedef  enum     extreq        EXTREQ;\n\nstruct textline    {\n                    struct textline    *next;\n                    short               text_length;\n                    short               tab_expanded_text_length;\n                    char               *tab_expanded_text;\n                    char                text\u00dd1\u00a8;  /* dummy */\n                   };\n\nstruct texthdr     {\n                    int                   text_line_count;\n                    short                 text_max_length;\n                    short                 text_max_tab_expanded_length;\n                    struct textline      *text_body_line;\n                    struct textline      *first_text_line;\n                    struct textline      *current_text_line;\n                    struct textline      *last_text_line;\n                   };\n\n/* see note on newsarticle struct under article vector stuff */\n\nstruct newsarticle {\n                    char                 *from;\n                    char                 *subject;\n                    char                 *date;\n                    char                 *message_id;\n                    char                 *csubject;\n                    int                   number;\n                    char                  action;\n                    char                  status;\n                    struct texthdr        thdr;\n                   };\n\nstruct newsgroup   {\n                    struct newsgroup     *next;\n                    struct newsgroup     *next2;\n                    struct newsgroup     *next3;\n                    char                 *saved_newsrc_line;\n                    VARK                 *article_vector;\n                    VARK                **sort_vector;\n                    int                   low_number;\n                    int                   high_number;\n                    int                   vector_first;\n                    int                   vector_last;\n                    int                   article_count;\n                    int                   unread_count;\n                    int                   sort_count;\n                    int                   article_vector_len;\n                    int                   registered;\n                    char                  status;\n                    char                  saved_newsrc_data \u00dd12\u00a8;\n                    char                  name \u00dd1\u00a8; /* dummy len */\n                   };\n\nstruct cmddesc   {\n                  char    command_name\u00ddCOMMANDSIZE\u00a8;\n                  Bool    (*command_processor)();\n                 };\n\nstruct seldesc   {\n                  char    selection_code;\n                  Bool    (*selection_processor)();\n                 };\n\nstruct tabledesc {\n                  char   *command_variable;\n        struct cmddesc   *first_cmddesc;\n        struct seldesc   *first_seldesc;\n        struct cmddesc   *next_cmddesc;\n                 };\n\nstruct tablevector {\n                    struct tabledesc *newsgroup_display_table;\n                    struct tabledesc *article_display_table;\n                    struct tabledesc *text_display_table;\n                   };\n\nstruct _textunit {\n                  unsigned short         key;\n                  unsigned short         num;\n                  struct {\n                          unsigned short len;\n                          char           prm\u00dd80\u00a8;\n                         }               ent;\n                 };\n\nstruct extraction {\n                   int                   from_article_number;\n                   int                   to_article_number;\n                   int                   article_count;\n                   enum data_set_type    mode;\n                   void                (*closer)();\n                   Bool                  appending;\n                   Bool                  blanking;\n                   Bool                  tab_expanding;\n                   Bool                  ejecting;\n                   Bool                  formfeeding;\n                   char                  panelname     \u00dd9\u00a8;\n                   char                  dsname       \u00dd65\u00a8;\n                   char                  separator    \u00dd81\u00a8;\n                   char                  member_prefix \u00dd9\u00a8;\n                   char                  ddname        \u00dd9\u00a8;\n                   char                  member        \u00dd9\u00a8;\n                  };\n\nstruct countdown  {\n                   Bool                  do_update;\n                   int                   done;\n                   int                   to_do;\n                  };\n\nstruct nncb {\n             char    *server_buf;\n             char    *client_buf;\n             char    *nntp_command;\n             char    *nntp_message_text;\n             char    *extract_separator_line;\n struct newsgroup    *first_newsgroup;\n struct newsgroup    *current_newsgroup;\n struct newsgroup    *last_newsgroup;\n struct newsgroup    *first_newsgroup_alt;\n struct newsgroup    *last_added_newsgroup;\n struct tablevector  *display_table_vector;\n struct extraction   *extractionp;\n             FILE    *debug_file;\n             FILE    *newsrc_file;\n             FILE    *extract_file;\n             FILE    *batch_infile;\n             FILE    *batch_outfile;\n             void    *batch_hook;\n#ifdef FETCH\n              int   (*isplink_pointer)();\n              int   (*ispexec_pointer)();\n#endif\n  struct newsarticle *article_being_viewed;\n              VARK  **top_sorted_article;\n              VARK  **current_sortvark;\n              int     top_article;\n              int     ispfrc;\n              int     nntp_message_num;\n              int     socknum;\n              int     g_bytes_returned;\n              int     g_buf_index;\n              int     new_newsgroup_count;\n              int     article_rows;\n              int     updatefreq;      /* ddi */\n              int     text_find_left_bound;\n              int     text_find_right_bound;\n enum article_cookie  another_article;\n   struct texthdr     thdr;\n        IPADDRESS     client_ip_address;\n        IPADDRESS     server_ip_address;\n             time_t   lasttime;           /* ddi */\n             time_t   firstime;           /* ddi */\n             Bool     test_mode;\n             Bool     debug_mode;\n             Bool     batch_mode;\n             Bool     quit;\n             Bool     time_to_go_home;\n             Bool     server_has_something_pending;\n             Bool     server_finished_replying;\n             Bool     sending_text;\n             Bool     receiving_text;\n             Bool     something_to_print;\n             Bool     dont_read;\n             Bool     connected_to_server;\n             Bool     connection_broken;\n             Bool     closing_connection;\n             Bool     reconnect_in_progress;\n             Bool     posting_allowed;\n             Bool     newsgroup_selected;\n             Bool     newsgroup_not_found;\n             Bool     newsgroup_order_changed;\n             Bool     brand_new_newsrc;\n             Bool     newsgroup_criterion_changed;\n             Bool     show_all_newsgroups;\n             Bool     following_up;\n             Bool     extract_tab_expanding;\n             Bool     extract_appending;\n             Bool     extract_blank_before_separator;\n             Bool     extract_ejecting;\n             Bool     extract_formfeeding;\n             Bool     extract_write_error;\n             Bool     extract_close_error;\n             Bool     please_locate_group;\n             Bool     please_find_group;\n             Bool     repeat_find;\n             Bool     article_criterion_changed;\n             Bool     article_repeat_find;\n             Bool     article_text_not_found;\n             Bool     warn_overwrite;\n             Bool     warn_append;\n             Bool     dont_reissue_socket_command;\n             Bool     show_all_articles;\n             Bool     update_adding_newsgroups;\n             Bool     update_rewriting_newsrc;\n             Bool     update_retrieving_articles;\n             Bool     bypass_header_retrieval;\n             Bool     unread_articles_only;\n             Bool     setmsg;\n             Bool     newsgroup_autoscroll;\n             Bool     article_autoscroll;\n             Bool     sort_by_subject;\n             Bool     xhdr_not_available;\n             Bool     newsgroup_autocursor;\n             Bool     article_autocursor;\n             Bool     setcursor;\n             Bool     printing;\n             Bool     dont_reconnect;\n             char     newsgroup_order;\n             char     newsgroup_find_option;\n             char     article_find_option;\n             char     preselection;\n             char     barchar;                /* ddi */\n             char     text_dispchar;\n             char     text_find_what;\n             char     text_find_type;\n             char     text_find_trans;\n             char     newsrc_to_open          \u00dd 12\u00a8;\n             char     nnrfcopt                \u00dd  2\u00a8;\n             char     nnrfcinc                \u00dd256\u00a8;\n             char     nnrfcexc                \u00dd256\u00a8;\n             char     maildsn                 \u00dd 64\u00a8;\n             char     messageid               \u00dd128\u00a8;\n             char     nnregnng                \u00dd  9\u00a8;\n             char     nngroup                 \u00ddGROUP_NAME_SIZE+1\u00a8;\n             char     nnserver                \u00ddMAXHOSTNAMELEN+1\u00a8;\n             char     nnclient                \u00ddMAXHOSTNAMELEN+1\u00a8;\n             char     client_hostname         \u00ddMAXHOSTNAMELEN+1\u00a8;\n             char     client_ip_addrstr       \u00dd16\u00a8;\n             char     server_hostname         \u00ddMAXHOSTNAMELEN+1\u00a8;\n             char     server_ip_addrstr       \u00dd16\u00a8;\n             char     g_buf                   \u00ddREAD_BYTES\u00a8;\n             char     newsgroup_locate_string \u00ddGROUP_NAME_SIZE+1\u00a8;\n             char     newsgroup_only_string   \u00ddGROUP_NAME_SIZE+1\u00a8;\n             char     newsgroup_find_string   \u00ddGROUP_NAME_SIZE+1\u00a8;\n             char     article_only_string     \u00ddGROUP_NAME_SIZE+1\u00a8;\n             char     article_find_string     \u00ddGROUP_NAME_SIZE+1\u00a8;\n             char     lastNGdate              \u00dd7\u00a8;      /* ddi */\n             char     lastNGtime              \u00dd7\u00a8;      /* ddi */\n             char     selsubj                 \u00dd81\u00a8;     /* ddi */\n             char     text_find_string        \u00ddGROUP_NAME_SIZE+1\u00a8;\n            };\n\n#ifdef MVS\n#ifndef I370\nextern char                 ebcdictoascii\u00dd\u00a8;\nextern char                 asciitoebcdic\u00dd\u00a8;\n#endif\n#endif\n\n#ifndef FETCH\nextern int                  isplink();\nextern int                  ispexec();\n#endif\n\n/****** Procedure and function declarations. *************************/\n\nextern struct newsgroup   *NNMaddng(struct nncb *, char *);\nextern void                NNMadjua(struct nncb *, struct newsgroup *,\n                                                        int, int, int);\nextern void                NNMallav(struct nncb *, struct newsgroup *,\n                                                             int, int);\nextern Bool                NNMalloc(char *, char *, enum data_set_type,\n                                                                  int);\nextern Bool                NNMauth (struct nncb *);\nextern int                 NNMbatch(struct nncb *);\nextern void                NNMbtext(struct nncb *, struct texthdr *,\n                                                               FILE *);\nextern Bool                NNMcar  (struct nncb *,struct newsgroup *,\n                                       int,VARK *,struct newsarticle **,\n                                       struct countdown *,\n                                       enum choose_reason);\nextern void                NNMclrng(struct nncb *);\nextern void                NNMclrtx(struct nncb *,struct newsarticle *);\nextern void                NNMcnrf (struct nncb *, char *, Fool);\nextern Bool                NNMconn (struct nncb *);\nextern char               *NNMcopy (struct nncb *, char *);\nextern Bool                NNMdcan (struct nncb *,struct newsgroup *,\n                                                  struct newsarticle *);\nextern void                NNMdfail(int,__S99parms *);\nextern void                NNMdisc (struct nncb *);\nextern int                 NNMdispl(struct nncb *, char *);\nextern Bool                NNMdlang(struct nncb *, enum list_option);\nextern void                NNMdmail(struct nncb *,struct newsgroup *,\n                                                  struct newsarticle *);\nextern enum display_retval NNMdmenu(struct nncb *, Bool (**)());\nextern struct newsgroup   *NNMdng  (struct nncb *,\n                                           struct newsgroup *, char *);\nextern void                NNMdnntp(struct nncb *, char *);\nextern void                NNMdoit (struct nncb *,\n                                            struct newsarticle *, Fool);\nextern void                NNMdpost(struct nncb *,struct newsgroup *,\n                                                  struct newsarticle *);\nextern void                NNMdsopt(struct nncb *,char *);\nextern void                NNMdump (struct nncb *,char *, char *, int);\nextern void                NNMesrvr(struct nncb *);\nextern Bool                NNMestng(struct nncb *, char *);\nextern void                NNMfreem(struct nncb *,char *,char *);\nextern FILE               *NNMgetds(struct nncb *,struct extraction *);\nextern void                NNMgetm (struct nncb *,char **,int,char *);\nextern Bool                NNMgsrvl(struct nncb *, char **);\nextern void                NNMierr (struct nncb *);\nextern int                 NNMiget (struct nncb *, char *);\nextern void                NNMimsg (struct nncb *, char *);\nextern void                NNMinit (struct nncb *);\nextern Bool                NNMispf (struct nncb *, char *);\nextern Bool                NNMivget(struct nncb *, char *, char *,int);\nextern Bool                NNMivput(struct nncb *, char *, char *,int);\nextern void                NNMmarr(struct nncb *, struct newsgroup *,\n                                                                VARK *);\nextern void                NNMmaru(struct nncb *, struct newsgroup *,\n                                                                VARK *);\nextern void                NNMnntp (struct nncb *);\nextern void                NNMonrf (struct nncb *, char *);\nextern struct textline    *NNMouttx(struct nncb *, char *,\n                                                  struct newsarticle *);\nextern Bool                NNMpick (struct nncb *,struct newsarticle *);\nextern Bool                NNMpng  (struct nncb *,struct newsgroup *,\n                                                             Fool,Fool);\nextern Bool                NNMqar  (struct nncb *,struct newsarticle *);\nextern void                NNMqng  (struct nncb *,struct newsgroup *);\nextern struct newsarticle *NNMrarh (struct nncb *,struct newsgroup *,\n                                         VARK *,int,struct countdown *);\nextern int                 NNMrart (struct nncb *,struct newsgroup *,\n                                                             Fool,Fool);\nextern void                NNMrbfm (struct nncb *);\nextern Bool                NNMrecon(struct nncb *);\nextern void                NNMrperr(struct nncb *);\nextern Bool                NNMsave (struct nncb *,char *);\nextern Bool                NNMsockt(struct nncb *);\nextern void                NNMsopt (struct nncb *, enum user_option);\nextern Bool                NNMsort (struct nncb *,struct newsgroup *);\nextern void                NNMssrvr(struct nncb *);\nextern char               *NNMstrlc(char *, char *);\nextern Bool                NNMsumat(char *, char *);\nextern int                 NNMtso  (char *);\nextern Bool                NNMunalc(char *);\nextern void                NNMupdt (struct nncb *,struct countdown *,\n                                                  char *);\nextern Bool                NNMvar  (struct nncb *,struct newsgroup *);\nextern void                NNMview (struct nncb *,struct newsgroup *,\n                                                  struct newsarticle *,\n                                                  struct texthdr *,\n                                                  char *);\nextern Bool                NNMvng  (struct nncb *);\nextern void                NNMvtx  (struct nncb *,struct newsgroup *,\n                                                  struct newsarticle *);\nextern Bool                NNMxartt(struct nncb *,struct newsgroup *,\n                                                  enum data_set_type);\nextern Bool                NNMxartx(struct nncb *,struct newsgroup *,\n                                                  enum data_set_type);\nextern Bool                NNMxlist(struct nncb *,enum data_set_type);\nextern Bool                NNMxtx  (struct nncb *,struct newsarticle *,\n                                                  Fool);\n\n#ifndef SUPPRESS_V_DECLARATION\nextern void                NNMpmsg (struct nncb *,int,char *,char *,\n                                                                  ...);\n#endif\n\n#ifdef C370V2\n#pragma checkout(resume)\n#endif\n\n./ ADD NAME=NNBATCH\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* ------------------ \"nnbatch.h\" include member ------------------- */\n\n/* Include file for NNMVS batch mode operations. */\n\n\n#define FIRST_ARTICLE_IN_RANGE             (-1)\n#define LAST_ARTICLE_IN_RANGE              (2147483647)\n\n#define MIN_RESERVED_WORD_LENGTH 2\n#define MAX_RESERVED_WORD_LENGTH 10\n\n#define ANYTYPE     void *\n\n#define PEEK()      (NNMbgtok(np,bp,TOKEN_PEEK) ? &bp->nextok : NULL)\n#define EAT()       (void)NNMbgtok(np,bp,TOKEN_READ)\n\n#define SETA(X,Y)   NNMbvput(np,bp,(X),NUMBER_SYMTYPE,(ANYTYPE)(Y))\n#define SETB(X,Y)   NNMbvput(np,bp,(X),FLAG_SYMTYPE,  (ANYTYPE)(Y))\n#define SETC(X,Y)   NNMbvput(np,bp,(X),STRING_SYMTYPE,(ANYTYPE)(Y))\n\n#define GETA(X)     (int)   NNMbvget(np,bp,(X),NUMBER_SYMTYPE)\n#define GETB(X)     (Fool)  NNMbvget(np,bp,(X),FLAG_SYMTYPE)\n#define GETC(X)     (char *)NNMbvget(np,bp,(X),STRING_SYMTYPE)\n\ntypedef struct newscmd *(*CommandParser)   ();\ntypedef void            (*CommandExecutor) ();\n\nenum tokentype        {NO_TOKEN,\n                       EOL_TOKEN,\n                       EOF_TOKEN,\n                       AND_TOKEN,\n                       OR_TOKEN,\n                       NOT_TOKEN,\n                       GT_TOKEN,\n                       LT_TOKEN,\n                       EQ_TOKEN,\n                       NE_TOKEN,\n                       GE_TOKEN,\n                       LE_TOKEN,\n                       LPAR_TOKEN,\n                       RPAR_TOKEN,\n                       PLUS_TOKEN,\n                       MINUS_TOKEN,\n                       TIMES_TOKEN,\n                       OVER_TOKEN,\n                       SEMI_TOKEN,\n                       WORD_TOKEN,\n                       NUMBER_TOKEN,\n                       STRING_TOKEN,\n                       ERROR_TOKEN\n                      };\n\nenum tokenfunc        {\n                       TOKEN_PEEK,\n                       TOKEN_READ,\n                       TOKEN_FLUSH\n                      };\n\nenum batchmode        {\n                       INITIAL_MODE,\n                       PER_NEWSGROUP_MODE,\n                       PER_ARTICLE_MODE,\n                       TEXT_MODE,\n                       ERROR_MODE,\n                       ANY_MODE\n                      };\n\nenum marking_mode     {\n                       MARKING_READ,\n                       MARKING_UNREAD\n                      };\n\nenum extracting_mode  {\n                       NO_EXTRACTING_MODE,\n                       EXTRACTING_ALL,\n                       EXTRACTING_READ,\n                       EXTRACTING_UNREAD\n                      };\n\nenum which_newsgroups {\n                       NO_NEWSGROUPS,\n                       ALL_NEWSGROUPS,\n                       REGISTERED_NEWSGROUPS,\n                       UNREGISTERED_NEWSGROUPS,\n                       NAMED_NEWSGROUPS,\n                       MASKED_NEWSGROUPS\n                      };\n\nenum which_articles   {\n                       NO_ARTICLES,\n                       ALL_ARTICLES,\n                       READ_ARTICLES,\n                       UNREAD_ARTICLES,\n                       RANGED_ARTICLES\n                      };\n\nenum symtype          {\n                       NO_SYMTYPE,\n                       STRING_SYMTYPE,\n                       NUMBER_SYMTYPE,\n                       FLAG_SYMTYPE\n                      };\n\n/*-------------------------------------------------------------------*\n * Define structures to handle expressions computed at run time.\n *-------------------------------------------------------------------*/\n\n#include \"nnptree.h\"   /* Grammar to handle general expressions */\n\n/*-------------------------------------------------------------------*\n * newsgroup_crit: defines criteria for selecting newsgroups.\n *                 Corresponds to xxx in:\n *                   FOR xxx WHEN (yyy) DO zzz\n *                 in top-level mode.\n *-------------------------------------------------------------------*/\n\nstruct newsgroup_crit {\n                       enum which_newsgroups     which;\n                       struct ptree             *groups;\n                      };\n\n/*-------------------------------------------------------------------*\n * article_crit: defines criteria for selecting articles.\n *               Corresponds to xxx in:\n *                 FOR xxx WHEN (yyy) DO zzz\n *               in per-newsgroup mode.\n *-------------------------------------------------------------------*/\n\nstruct article_crit {\n                       enum which_articles       which;\n                       struct ptree             *first;\n                       struct ptree             *last;\n                      };\n\n/*-------------------------------------------------------------------*\n * for_newsgroups: defines what to do for each newsgroup and which\n *                 newsgroups were selected.  Corresponds to:\n *                   FOR xxx WHEN (yyy) DO zzz\n *                 in top-level mode.\n *-------------------------------------------------------------------*/\n\nstruct for_newsgroups {\n                       struct ptree             *filter;\n                       struct newsgroup_crit     crit;\n                       struct cmdtree           *treep;\n                      };\n\n/*-------------------------------------------------------------------*\n * for_articles:   defines what to do for each article and which\n *                 articles were selected.  Corresponds to:\n *                   FOR xxx WHEN (yyy) DO zzz\n *                 in per-newsgroup mode.\n *-------------------------------------------------------------------*/\n\nstruct for_articles   {\n                       struct ptree             *filter;\n                       struct article_crit       crit;\n                       struct cmdtree           *treep;\n                      };\n\n/*-------------------------------------------------------------------*\n * OK, here are defined the kinds of commands.\n *-------------------------------------------------------------------*/\n\nstruct initial_mode_cmd        {\n                                struct for_newsgroups       fors;\n                               };\n\nstruct per_newsgroup_mode_cmd  {\n                                struct for_articles         fors;\n                               };\n\nstruct if_cmd                  {\n                                struct ptree               *condition;\n                                struct cmdtree             *thencmds;\n                                struct cmdtree             *elsecmds;\n                               };\n\nstruct set_cmd                 {\n                                struct ptree               *ptreep;\n                                char *                      set_symbol;\n                                enum symtype                set_type;\n                               };\n\nstruct mark_cmd                {\n                                enum marking_mode           marking;\n                               };\n\nstruct extract_cmd             {\n                                enum extracting_mode        extracting;\n                               };\n\nstruct miscellaneous_cmd       {\n                                struct ptree               *ptreep;\n                               };\n\nunion some_mode_cmd   {\n                       struct initial_mode_cmd       icmd;\n                       struct per_newsgroup_mode_cmd ncmd;\n                       struct if_cmd                 fcmd;\n                       struct set_cmd                scmd;\n                       struct mark_cmd               rcmd;\n                       struct extract_cmd            xcmd;\n                       struct miscellaneous_cmd      mcmd;\n                      };\n\n/*-------------------------------------------------------------------*\n * newscmd:   defines format of operations to perform on something.\n *-------------------------------------------------------------------*/\n\nstruct newscmd        {\n                       enum batchmode            mode;\n                       CommandExecutor           proc;\n                       union some_mode_cmd       cmd;\n                      };\n\nstruct cmdtree        {\n                       struct cmdtree *next;\n                       struct newscmd *cmd;\n                      };\n\n#define MAX_SYMBOL_LENGTH      16\n\n/*-------------------------------------------------------------------*\n * symtab:    defines symbol table that holds values of variables.\n *            The complete symbol table is a classic binary tree of\n *            symtab structs.\n *\n * To allocate, take length of variable value string,\n * then add that to offsetof(struct symtab,symval) to get total.\n *-------------------------------------------------------------------*/\n\nstruct symtab {\n               char            symvar\u00ddMAX_SYMBOL_LENGTH\u00a8;\n               struct symtab  *left;\n               struct symtab  *right;\n               enum symtype    type;\n               int             symnum;\n               int             vallen;\n               char            symval\u00dd1\u00a8;      /* dummy for alloc */\n              };\n\nstruct token {\n              enum tokentype   type;\n              char             string \u00dd260\u00a8;\n              int              number;\n             };\n\nstruct batch {\n              struct cmdtree     *treetop;\n              struct cmdtree     *treebottom;\n              struct symtab      *symtabp;\n              struct newsgroup   *gp;\n              VARK               *vp;\n              struct newscmd     *ifcmd;\n              char               *inchar;\n              char               *reserved_words;\n              char               *outfilename;\n              FILE               *outfp;\n              int                 input_errors;\n              int                 request_errors;\n              enum batchmode      mode;\n              enum data_set_type  extractds_mode;\n              CommandParser       endproc;\n              jmp_buf             jump;\n              struct token        curtok;\n              struct token        nextok;\n              Bool                exactcase;\n              Bool                syntax_error;\n              Bool                runtime_error;\n              Bool                eof;\n              Bool                quit;\n              Bool                stop_at_newline;\n              Bool                tokens_read;\n              Bool                newsgroups_retrieved;\n              char                inline          \u00dd260\u00a8;\n              char                extractds        \u00dd81\u00a8;\n              char                extractds_part1  \u00dd81\u00a8;\n              char                extractds_part2  \u00dd81\u00a8;\n              char                extractds_member \u00dd81\u00a8;\n             };\n\nextern ANYTYPE         NNMbbexp(struct nncb *, struct batch *,\n                                          struct ptree *,enum symtype);\nextern Bool            NNMbconn(struct nncb *, struct batch *);\nextern struct symtab  *NNMbdecl(struct nncb *, struct batch *, char *,\n                                                enum symtype, ANYTYPE);\nextern void            NNMbflus(struct nncb *, struct batch *);\nextern CommandParser   NNMbgcmd(struct nncb *, struct batch *);\nextern struct cmdtree *NNMbgdo (struct nncb *, struct batch *,\n                                                       enum batchmode);\nextern struct ptree   *NNMbgexp(struct nncb *, struct batch *,\n                                                         enum symtype);\nextern Bool            NNMbgtok(struct nncb *, struct batch *,\n                                                       enum tokenfunc);\nextern FILE           *NNMbsout(struct nncb *, struct batch *);\nextern void            NNMbsynt(struct nncb *, struct batch *,\n                                                  char *, int, char *);\nextern void            NNMbtras(struct nncb *, struct batch *, char *);\nextern ANYTYPE         NNMbvget(struct nncb *, struct batch *, char *,\n                                                         enum symtype);\nextern void            NNMbvput(struct nncb *, struct batch *, char *,\n                                                enum symtype, ANYTYPE);\nextern void            NNMbxfar (struct nncb *, struct batch *,\n                                                      struct newscmd *);\nextern void            NNMbxfng (struct nncb *, struct batch *,\n                                                      struct newscmd *);\n\n./ ADD NAME=NNPTREE\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* ----------------- \"nnptree.h\" include member -------------------- */\n\n#define ALLOC(X,Y)   GETMAIN(X,struct Y,1,#Y);\\\n                     if (!(X)) longjmp(bp->jump,ERROR_GETMAIN_FAILURE)\n#define ERR(X)       (NNMbsynt(np,bp,bp->curtok.string,0,X),\\\n                      longjmp(bp->jump,ERROR_BAD_EXPRESSION))\n#define LOSE         longjmp(bp->jump,ERROR_SCAN_ERROR)\n\n#define ERROR_NONE              0\n#define ERROR_TYPE_MISMATCH     1\n#define ERROR_ZERODIVIDE        2\n#define ERROR_GETMAIN_FAILURE   3\n#define ERROR_BAD_EXPRESSION    4\n#define ERROR_SCAN_ERROR        5\n\n/*-------------------------------------------------------------------*\n * ptree: defines structure of expressions used by various commands,\n * including SET, PUT and NNTP.  When these commands are parsed,\n * a ptree structure is built to be interpreted when the command is\n * executed.  The structure represents one of the following:\n *\n * - a string expression (concatenated strings or string vars)\n * - a numeric expression (number, number var or arithmetic expr)\n * - a flag expression (flag, flag var or logical expr)\n *\n *-------------------------------------------------------------------*/\n\n/*-------------------------------------------------------------------*\n * treetype: type of an expression tree.\n *-------------------------------------------------------------------*/\n\nenum treetype   {\n                 NO_TREETYPE,\n                 STRING_TREETYPE,\n                 NUMBER_TREETYPE,\n                 FLAG_TREETYPE\n                };\n\n/*-------------------------------------------------------------------*\n * rhstype:  type of an expression subtree, based on the RHS of a\n *           production.  Defines the structure of the components\n *           that make up this subtree.  Note that the types are\n *           meaningful only within a given production (LHS) type.\n *-------------------------------------------------------------------*/\n\nenum rhstype    {\n                 NO_RHSTYPE,\n                 RHSTYPE_A,\n                 RHSTYPE_B,\n                 RHSTYPE_C,\n                 RHSTYPE_D,\n                 RHSTYPE_E\n                };\n\n/*-------------------------------------------------------------------*\n * optype:  type of an operator\n *-------------------------------------------------------------------*/\n\nenum optype     {\n                 NO_OP,\n                 AND_OP,\n                 OR_OP,\n                 NOT_OP,\n                 IN_OP,\n                 EQ_OP,\n                 NE_OP,\n                 GT_OP,\n                 LT_OP,\n                 GE_OP,\n                 LE_OP,\n                 ADD_OP,\n                 SUB_OP,\n                 MUL_OP,\n                 DIV_OP\n                };\n\n/*-------------------------------------------------------------------*\n * These types correspond to production LHS's.\n *-------------------------------------------------------------------*/\n\ntypedef struct exp        *       Exp;\ntypedef struct choice     *       Choice;\ntypedef struct relation   *       Relation;\ntypedef struct value      *       Value;\ntypedef struct quantity   *       Quantity;\ntypedef struct term       *       Term;\ntypedef struct factor     *       Factor;\ntypedef struct unop       *       Unop;\ntypedef struct addop      *       Addop;\ntypedef struct mulop      *       Mulop;\ntypedef struct logop      *       Logop;\ntypedef struct relop      *       Relop;\ntypedef struct constant   *       Constant;\ntypedef struct variable   *       Variable;\ntypedef struct number     *       Number;\ntypedef struct string     *       String;\ntypedef struct flag       *       Flag;\n\n/*-------------------------------------------------------------------*\n * The following define the top-down LR(1) grammar.\n *-------------------------------------------------------------------*/\n\nstruct exp      {\n                 enum rhstype           r;\n                 enum symtype           s;\n                 union {\n                        struct {\n                                Choice          choice1;\n                               }        a;\n                        struct {\n                                /* \"IF\" */\n                                Exp             exp1;\n                                /* \"THEN\" */\n                                Exp             exp2;\n                                /* \"ELSE\" */\n                                Exp             exp3;\n                               }        b;\n                       }                u;\n                };\n\nstruct choice   {\n                 enum rhstype           r;\n                 enum symtype           s;\n                 union {\n                        struct {\n                                Relation        relation1;\n                               }        a;\n                        struct {\n                                Choice          choice1;\n                                Logop           logop2;\n                                Relation        relation3;\n                               }        b;\n                       }                u;\n                };\n\nstruct relation {\n                 enum rhstype           r;\n                 enum symtype           s;\n                 union {\n                        struct {\n                                Value           value1;\n                               }        a;\n                        struct {\n                                Value           value1;\n                                Relop           relop2;\n                                Value           value3;\n                               }        b;\n                       }                u;\n                };\n\nstruct value    {\n                 enum rhstype           r;\n                 enum symtype           s;\n                 union {\n                        struct {\n                                Quantity        quantity1;\n                               }        a;\n                        struct {\n                                Value           value1;\n                                Quantity        quantity2;\n                               }        b;\n                       }                u;\n                };\n\nstruct quantity {\n                 enum rhstype           r;\n                 enum symtype           s;\n                 union {\n                        struct {\n                                Term            term1;\n                               }        a;\n                        struct {\n                                Quantity        quantity1;\n                                Addop           addop2;\n                                Term            term3;\n                               }        b;\n                       }                u;\n                };\n\nstruct term     {\n                 enum rhstype           r;\n                 enum symtype           s;\n                 union {\n                        struct {\n                                Factor          factor1;\n                               }        a;\n                        struct {\n                                Term            term1;\n                                Mulop           mulop2;\n                                Factor          factor3;\n                               }        b;\n                       }                u;\n                };\n\nstruct factor   {\n                 enum rhstype           r;\n                 enum symtype           s;\n                 union {\n                        struct {\n                                Constant        constant1;\n                               }        a;\n                        struct {\n                                Variable        variable1;\n                               }        b;\n                        struct {\n                                Unop            unop1;\n                                Factor          factor2;\n                               }        c;\n                        struct {\n                                /* \"(\" */\n                                Exp             exp1;\n                                /* \")\" */\n                               }        d;\n                       }                u;\n                };\n\nstruct constant {\n                 enum rhstype           r;\n                 enum symtype           s;\n                 union {\n                        struct {\n                                Number          number1;\n                               }        a;\n                        struct {\n                                String          string1;\n                               }        b;\n                        struct {\n                                Flag            flag1;\n                               }        c;\n                       }                u;\n                };\n\nstruct unop     {\n                 enum optype            op1;    /* + - ! \u00ac */\n                };\n\nstruct addop    {\n                 enum optype            op1;    /* + - */\n                };\n\nstruct mulop    {\n                 enum optype            op1;    /* * / */\n                };\n\nstruct logop    {\n                 enum optype            op1;    /* AND OR */\n                };\n\nstruct relop    {\n                 enum optype            op1;    /* EQ GT LE NE IN... */\n                };\n\nstruct variable {\n                 enum symtype           s;\n                 char *                 variable1;\n                };\n\nstruct number   {\n                 enum symtype           s;\n                 int                    number1;\n                };\n\nstruct string   {\n                 enum symtype           s;\n                 char                  *string1;\n                };\n\nstruct flag     {\n                 enum symtype           s;\n                 Fool                   flag1;  /* ON OFF TRUE FALSE */\n                };\n\n/*-------------------------------------------------------------------*\n * thing: describes entity to be returned from a ptree at run time\n *-------------------------------------------------------------------*/\n\nstruct thing    {\n                 ANYTYPE                val;    /* char *, int, Fool */\n                 enum symtype           typ;    /* string/number/flag*/\n                };\n\n/*-------------------------------------------------------------------*\n * ptree: expression tree.  Root of string/number/flag expression\n *-------------------------------------------------------------------*/\n\nstruct ptree    {\n                 enum symtype           type;   /* string/number/flag*/\n                 Exp                    exp1;   /* actual expression */\n                };\n\n./ ADD NAME=NNSASC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* ------------------- \"nnsasc.h\" include member ------------------- */\n\n#ifdef SASC\n\n#define I370\n\n#include <dynam.h>\n\n#define FETCH\n\n __inline void (*fetch( const char *modname ))()\n {\n   void (**fpp)();\n\n   loadm( modname, &fpp );\n   return( *fpp );\n }\n\n __inline int (*release( void (*fpp)() ))\n {\n   unloadm( fpp );\n   return( 0 );\n }\n\n\n#ifndef __SVC99\n\n  #define __SVC99  1\n\n  #include <code.h>\n\n  struct __S99struc\n    {\n      unsigned char   __S99RBLN;  /* length of request block..20      */\n      unsigned char   __S99VERB;  /* verb code                        */\n      unsigned short  __S99FLAG1; /* FLAGS1 field of SVC99 Req Block  */\n      unsigned short  __S99ERROR; /* error code field                 */\n      unsigned short  __S99INFO;  /* information reason code          */\n      void           *__S99TXTPP; /* address of text unit pointer list*/\n      int             __reserved; /* reserved..will always be 0       */\n      unsigned int    __S99FLAG2; /* FLAGS2 field..can only be filled */\n                                  /* in by APF authorized programs    */\n    };\n\n  typedef struct __S99struc __S99parms;\n\n  __inline int svc99(__S99parms* svc99parmlist)\n    { return( (_ldregs(R1, &svc99parmlist),\n               _code(0, 0x9680, 0x1000),\n               _code(0, 0x0a63),\n               _stregs(R15) ) );\n    }\n\n#endif\n\n#define FALSE 0\n#define TRUE  1\n\n#include <lcio.h>\n\n#define  MAXHOSTNAMELEN     64\n\n#define  __ctest(X)  fprintf(stderr,\\\n                     \"NNMVS: CTEST is not supported by this compiler.\")\n\n#endif\n\n./ ADD NAME=NNUSER\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* ------------------- \"nnuser.h\" include member ------------------- */\n\n/* Include file for locally customized values. */\n\n/* Define levels of C/370 and TCP/IP.  This controls support for\n * fetching of non-C load modules and socket error reporting.\n */\n\n/* #define  C370V1    /* define this if C/370 Version 1 */\n   #define  C370V2    /* define this if C/370 Version 2 or higher */\n/* #define  SASC      /* define this if SAS/C compiler */\n\n/* #define  TCPIPV1   /* define this if TCP/IP Version 1 */\n   #define  TCPIPV2   /* define this if TCP/IP Version 2 or higher */\n/* #define  SNSTCPIP  /* define this if SNS/TCPAccess    */\n\n/* #define  ISPFV2    /* define this if ISPF Version 2 or earlier */\n   #define  ISPFV3    /* define this if ISPF Version 3 or later\n\n/* Define the following defaults for your installation. */\n\n/*\n * Specify the \"user name\" portion of the \"Sender:\" address generated\n * by posting and mailing requests.\n *\n */\n\n#define NNMVS_NAME  \"NNMVS\"\n\n/*\n * Specify the name of the authorization file used to pass AUTHINFO\n * requests to the server, if the server requires.  This file should\n * be readable only by NNMVS if possible.  See the sample authorization\n * file (AUTH) for the format.\n *\n */\n\n/* #define AUTHFILE    \"SYS4.NNTP.SYS\"  */\n   #undef  AUTHFILE\n\n/*\n * Turn on for TCP-level debugging output (you probably don't want to\n * unless your TCP/IP stuff is really broken and I can't help you).\n */\n\n/* #define DEBUG       */\n   #undef  DEBUG\n\n/*\n * Define this if you want DEST, FORMS and UCS for print requests.\n * Undefine it if you don't (you get just CLASS and COPIES).\n */\n\n/* #define FULLSYSOUT  */\n   #undef  FULLSYSOUT\n\n/*\n * Define this if you want to be able to do automatic reconnection from\n * anywhere at any time.  The default is to be able to do automatic\n * reconnection from anywhere *except* when the list of newsgroups\n * is being built, to protect newsrc from being wiped out.\n */\n\n/* #define RECONNECT_AND_MAYBE_DESTROY_NEWSRC  */\n   #undef  RECONNECT_AND_MAYBE_DESTROY_NEWSRC\n\n./ ENDUP\n?!\n//C        EXEC MDLOAD,BS='6160',TRK1='50',TRK2='1',TO='C'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=NNMADDNG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@ADDNG\")\n#pragma  csect(static,\"NN$ADDNG\")\n\n#include \"nn.h\"\n\n#define KEEP_NEWSGROUPS_IN_ALPHABETICAL_ORDER\n\n/****** Create a new newsgroup. **************************************/\n\nstatic struct newsgroup *\nnew_newsgroup(np,gname)\nRstruc nncb         *np;\nchar                *gname;\n{\n struct newsgroup   *gp;\n int                 gsize;\n char                temp \u00dd128\u00a8;\n\n gsize = offsetof(struct newsgroup, name) + strlen(gname) + 1;\n\n sprintf(temp, \"newsgroup %s\", gname);\n GETMAIN(gp, char, gsize, temp);\n\n if (!gp) {\n   ERR2(\"There is not enough memory to add newsgroup %s.\",gname);\n   return NULL;\n }\n\n memset(gp, 0, gsize);\n strcpy(gp->name, gname);\n ClearGroupStatus(gp);\n\n np->last_added_newsgroup = gp;\n\n return gp;\n\n}\n\n/****** Add newsgroup. ***********************************************/\n\nstruct newsgroup *\nNNMaddng(np,gname)\nRstruc nncb         *np;\nchar                *gname;\n{\n Rstruc newsgroup   *gp;\n struct newsgroup   *prev_gp;\n struct newsgroup   *next_gp;\n int                 s;\n\n /* If there are no newsgroups yet, make this the first one.       */\n /* If the newsgroup is currently in the newsgroup list, reuse it. */\n /* Otherwise add it. */\n\n if (np->first_newsgroup == NULL) {\n   if ((gp=new_newsgroup(np,gname))) {\n     np->first_newsgroup   = gp;\n     np->current_newsgroup = gp;\n     np->last_newsgroup    = gp;\n   }\n   return gp;\n }\n\n prev_gp = NULL;\n next_gp = NULL;\n\n\n#ifdef KEEP_NEWSGROUPS_IN_ALPHABETICAL_ORDER\n\n /* Chances are this newsgroup will be right after the last one that\n    we added.  Check there first. */\n\n gp = np->last_added_newsgroup;         /* search from last added  */\n if (!gp || strcmp(gname,gp->name) < 0) /* unless ours precedes it */\n     gp = np->first_newsgroup;          /* then search from top    */\n\n for (; gp; gp = gp->next) {\n   s = strcmp(gname,gp->name);\n   if (s == 0)     { /* equal */\n     np->current_newsgroup = gp;\n     return gp;\n   }\n   else if (s < 0) { /* ours is less than theirs */\n     next_gp = gp;\n     break;\n   }\n   else            { /* ours is still greater */\n     prev_gp = gp;\n     next_gp = NULL;\n   }\n }\n\n#else\n\n /* keep newsgroups in NEWSRC order - not currently implemented */\n\n for (gp = np->first_newsgroup;\n      gp && strcmp(gname,gp->name) != 0;\n      gp = gp->next) ;\n\n if (gp) {   /* newsgroup already in list */\n   np->current_newsgroup = gp;\n   return gp;\n }\n\n next_gp = NULL;\n prev_gp = np->last_newsgroup;\n\n#endif\n\n /* newsgroup not in list - add it now */\n\n if ((gp=new_newsgroup(np,gname))) {\n\n   if (next_gp == NULL) np->last_newsgroup = gp;\n   else                 gp->next = next_gp;\n   if (prev_gp == NULL) np->first_newsgroup = gp;\n   else                 prev_gp->next = gp;\n\n   np->current_newsgroup = gp;\n }\n\n return gp;\n}\n\n./ ADD NAME=NNMADJUA\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@ADJUA\")\n#pragma  csect(static,\"NN$ADJUA\")\n#include \"nn.h\"\n\n/****** Adjust unread articles. **************************************/\n\nvoid\nNNMadjua(np,gp,count,first,last)\nRstruc nncb       *np;\nRstruc newsgroup  *gp;\nint                count;   /* estimated article count        */\nint                first;   /* estimated first article number */\nint                last;    /* estimated last  article number */\n{\n VARK             *vp;\n VARK             *vpfirst;\n VARK             *vplast;\n char             *nlp;\n\n /* logic:\n  * case\n  *   last article number went up:      increment unread count\n  *                                     update high number\n  *                                     no need for new vector\n  * <<< but if there already is a vector, then reallocate it >>>\n  * <<< (fix for rescan) >>>\n  *   last article number went down:    need an article vector to\n  *    see what newsrc says about which now-gone items were unread\n  *\n  * case\n  *   first article number went up:      need an article vector to\n  *    see what newsrc says about which now-gone items were unread\n  *   first article number went down:    impossible, nothing to do\n  *\n  */\n\n /* Do not change gp->high_number.  The caller of NNMadjua does this.\n    NNMallav needs to see the old value. */\n\n if (last > gp->high_number) {\n   gp->unread_count += (last - gp->high_number);\n   if (gp->article_vector) {        /* if already an article vector */\n     NNMallav(np,gp,first,last);    /* then reallocate it */\n   }\n }\n\n if (last < gp->high_number || first > gp->low_number) {\n\n   /* Recent or oldest articles were cancelled or expired */\n   /* Reset the count, since no GROUP request may be associated */\n\n   /*\n    * If NNTP LIST overriding NEWSRC spec, there is an unparsed\n    * newsrc line.  If it's just of the form \"<nnn\" with nothing else,\n    * and nnn is less than the new \"low number\" from LIST,\n    * then bypass allocation of an article vector.  Just set the\n    * unread count to the new high and low number.\n    */\n\n   if ((nlp=gp->saved_newsrc_line)\n    && *nlp == '<'\n    && !*(nlp+1 + strspn(nlp+1,\"0123456789\\n\"))\n    && atoi(nlp+1) < first) {\n     gp->unread_count  = count;\n   }\n\n   /*\n    * If the article count didn't come from the NNTP GROUP command,\n    * then estimate it from the NNTP LIST or NEWSRC range, but only\n    * if an article vector was allocated.\n    */\n\n   else {\n\n     NNMallav(np,gp,first,last);    /* Allocate article vector */\n\n     if (gp->article_vector && !GroupSelected(gp)) {\n       gp->article_count = 0;\n       vpfirst = &GETVARKFIRST(gp);\n       vplast  = &GETVARKLAST(gp);\n       for (vp = vpfirst; vp <= vplast; vp++) {\n         if (IsPresent(*vp)) gp->article_count++;\n       }\n     }\n   }\n }\n else {\n   gp->article_count = count;\n }\n\n /* No last minute adjustment of unread count,\n  * since this produces bad results later.\n  * If the user doesn't like this, hack the newsgroup display, not\n  * the newsgroup structure.  What about saving back to newsrc?\n  */\n\n /*\n  * if (gp->unread_count > gp->article_count)\n  *     gp->unread_count = gp->article_count;\n  */\n\n return;\n}\n\n./ ADD NAME=NNMALLAV\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@ALLAV\")\n#pragma  csect(static,\"NN$ALLAV\")\n#include \"nn.h\"\n\n/****** Parse NEWSRC line. *******************************************/\n\nstatic void\nparse_newsrc_line(np,gp)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\n{\n register char      *nlp                  = gp->saved_newsrc_line;\n int                 newsrc_number1       = 0;\n int                 newsrc_number2       = 0;\n int                 previous_number2     = 0;\n int                 newsrc_scan_count    = 0;\n int                 i;\n int                 imin;\n int                 imax;\n\n /*\n  * Reset the unread count, throwing away the \"newsrc_unread\" value.\n  * Initially the whole article vector is unread, and we make each\n  * article read if it says so in the rest of the newsrc line.\n  * Anything outside of the range of the article vector is GONE,\n  * so we consider it READ (i.e. not unread).\n  */\n\n gp->unread_count = gp->vector_last - gp->vector_first + 1;\n\n /* If there is no newsrc line to parse, that's all.  This used to be\n    first in this routine, but that caused missing articles outside of\n    the vector range not to be un-unread. */\n\n if (!nlp) {\n   if (np->debug_file)\n      fprintf(np->debug_file,\"NNMallav: no saved newsrc line for %s\\n\",\n                             gp->name);\n   return;\n }\n\n /* get next number thing */\n\n while (*nlp) {\n\n   previous_number2 = newsrc_number2;\n\n   while (*nlp && isspace(*nlp)) nlp++;\n\n   switch (*nlp) {\n     case '\\0': newsrc_number1 = MAX_INT;\n                newsrc_number2 = 0;\n                break;\n     case '<':  sscanf(nlp,\" <%d %n\",    &newsrc_number2,\n                                         &newsrc_scan_count);\n                newsrc_number1 = 1;\n                nlp += newsrc_scan_count;\n                break;\n     case '|':  sscanf(nlp,\" |%d=%d %n\", &newsrc_number1,\n                                         &newsrc_number2,\n                                         &newsrc_scan_count);\n                nlp += newsrc_scan_count;\n                break;\n     case '{':  nlp = strchr(++nlp,'}');\n                if (nlp) nlp++;\n                continue;\n     case '#':  nlp = strchr(++nlp,'#');\n                if (nlp) nlp++;\n                continue;\n     default:   sscanf(nlp,\" %d %n\",     &newsrc_number1,\n                                         &newsrc_scan_count);\n                newsrc_number2 = newsrc_number1;\n                nlp += newsrc_scan_count;\n                break;\n   }\n\n   /*\n    * For this range of articles marked unread, if it's in the range\n    * of the article vector, we do nothing (should have been UNREAD).\n    */\n\n   /*\n    * For this range of articles marked read, if it's in the range\n    * of the article vector, we mark the status accordingly.\n    * If it's outside of the range of the article vector,\n    * do nothing - it's just missing somehow.\n    */\n\n   imax = MAX(newsrc_number1,gp->vector_first);\n   imin = MIN(newsrc_number2,gp->vector_last);\n   for (i = imax; i <= imin; i++) {\n     SetRead(GETVARK(gp,i));\n     gp->unread_count--;\n   }\n\n } /* end while */\n\n /* We're finished parsing the newsrc line, so free it. */\n\n if (gp->saved_newsrc_line != gp->saved_newsrc_data) {\n   FREEMAIN(gp->saved_newsrc_line,\"parsed newsrc line\");\n }\n\n gp->saved_newsrc_line = NULL;\n gp->saved_newsrc_data\u00dd0\u00a8 = '\\0';\n\n return;\n}\n\n/****** Allocate articles for newsgroup. *****************************/\n\nvoid\nNNMallav(np,gp,first,last)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nint                  first;\nint                  last;\n{\n VARK               *oldvp    = gp->article_vector;\n VARK               *newvp    = NULL;\n int                 oldfirst = gp->vector_first;\n int                 oldlast  = gp->vector_last;\n int                 newfirst = first;\n int                 newlast  = last;\n int                 oldvlen;\n int                 newvlen;\n int                 anum;\n int                 commonfirst;\n int                 commonlast;\n\n/*\n * if an article vector already exists, then:\n *\n * all articles from new.first to old.first - 1 (impossible?) are\n *  set from their newsrc status, or else \"unread\"\n * all articles from old.first to new.first - 1 are UN-UNREAD.\n * all articles from old.last + 1 to new.last are:\n *  set to \"unread\" if > old.high_number\n *   (remember, we don't reset those until after the artvec hacking)\n *  set to \"missing\" (\"read\") if <= old.high_number\n *   (or unknown, or ???)\n * all articles from new.last + 1 to old.last are UN-UNREAD.\n */\n\n if (np->debug_file) {\n   fprintf(np->debug_file,\n           \"NNMallav: asking for article vector for %s (%d, %d)\\n\",\n           gp->name, first, last);\n }\n\n if (oldfirst == newfirst && oldlast == newlast) return;\n\n newvlen = (last == 0 ? 0 : last - first + 1);\n\n if (newvlen > 0) {\n\n   GETMAIN(newvp, VARK, newvlen, \"article vector\");\n\n   if (!newvp) {\n     fprintf(stderr,\"Error allocating %d-article vector for %s\\n\",\n                    newvlen, gp->name);\n     ERR1(\"There is not enough virtual memory available to proceed.\");\n     return;\n   }\n\n   memset(newvp, 0, newvlen * sizeof(VARK));\n\n }\n\n else {\n   newfirst = 2147483647;\n   newlast  = 0;\n }\n\n if (oldvp) {  /* if article vector already exists */\n\n   commonfirst = MAX(oldfirst, newfirst);\n   commonlast  = MIN(oldlast,  newlast);\n\n  /*\n   * copy the vector slots over from the old vector\n   */\n\n   for (anum=commonfirst; anum <= commonlast; anum++) {\n     newvp\u00ddanum-newfirst\u00a8 = oldvp\u00ddanum-oldfirst\u00a8;\n   }\n\n  /*\n   * all articles from new.first to old.first - 1 (impossible?) are\n   *  set from their newsrc status, or else \"unread\"\n   * Rationale: buggy newsrc didn't account for existing items\n   * can't set from newsrc until NNMpnrl is executed, so set them\n   * to good old missing-unread\n   */\n\n   for (anum = newfirst; anum <= newlast && anum < oldfirst; anum++) {\n     SetMissingUnread(newvp\u00ddanum-newfirst\u00a8);\n   }\n\n  /*\n   * all articles from old.first to new.first - 1 are UN-UNREAD.\n   * Rationale: old items have expired or been cancelled.\n   * Since they fall out of the vector, they don't get an explicit\n   * status, but they do have to be removed from the unread count.\n   */\n\n   for (anum = oldfirst; anum <= oldlast && anum < newfirst; anum++) {\n     if (IsUnread(oldvp\u00ddanum-oldfirst\u00a8)) {\n       gp->unread_count--;\n     }\n   }\n\n  /*\n   * all articles from old.last + 1 to new.last are:\n   *  set to \"unread\" if > old.high_number\n   *   Rationale: new items came in since last time we looked\n   *  set to \"missing\" (\"read\") if <= old.high_number\n   *   Rationale: items in range but don't exist, cancelled/expired\n   */\n\n   for (anum = MAX(newfirst, oldlast + 1); anum <= newlast; anum++) {\n     if (anum > gp->high_number) SetUnread(newvp\u00ddanum-newfirst\u00a8);\n     else                        SetMissingRead(newvp\u00ddanum-newfirst\u00a8);\n   }\n\n  /*\n   * all articles from new.last + 1 to old.last are UN-UNREAD.\n   * Rationale: old items have expired or been cancelled.\n   * Since they fall out of the vector, they don't get an explicit\n   * status, but they do have to be removed from the unread count.\n   */\n\n   for (anum = MAX(oldfirst, newlast + 1); anum <= oldlast; anum++) {\n     if (IsUnread(oldvp\u00ddanum-oldfirst\u00a8)) {\n       gp->unread_count--;\n     }\n   }\n\n   FREEMAIN(oldvp,\"old article vector\");\n\n }\n else {      /* no old article vector */\n\n  /*\n   * initialize the vector to all unknown and unread\n   */\n\n   for (anum = newfirst; anum <= newlast; anum++) {\n     SetNull(newvp\u00ddanum-newfirst\u00a8);\n   }\n\n }\n\n oldvlen = gp->article_vector_len;\n\n gp->article_vector     = newvp;\n gp->article_vector_len = newvlen;\n gp->vector_first       = first;\n gp->vector_last        = last;\n\n /* If this is the first time that we have allocated the article\n  * vector, initialize it from the saved newsrc line if there is one.\n  * i.e. if the article vector is being allocated for the first time.\n  */\n\n if (oldvlen == 0) {\n   parse_newsrc_line(np,gp);\n }\n\n return;\n\n}\n\n./ ADD NAME=NNMALLOC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@ALLOC\")\n#pragma  csect(static,\"NN$ALLOC\")\n#include \"nn.h\"\n\n/****** Allocate a data set. *****************************************/\n\nBool\nNNMalloc(dsname,ddname,type,nitems)\nchar                      *dsname;\nchar                      *ddname;\nenum data_set_type         type;\nint                        nitems;\n{\n int          i;\n int          rc;\n Bool         try_new;\n short        primary_allocation   ;\n short        secondary_allocation ;\n short        directory_blocks     ;\n short        dsorg                ;\n __S99parms   stuff99;   /* The manual has it wrong.  No \"struct\". */\n TEXTUNIT    *tu \u00dd17\u00a8;\n TEXTUNIT     tu_dsn;\n TEXTUNIT     tu_ddn;\n TEXTUNIT     tu_member;\n TEXTUNIT     tu_stat;\n TEXTUNIT     tu_disp;\n TEXTUNIT     tu_perm;\n TEXTUNIT     tu_rtddn;\n TEXTUNIT     tu_rtorg;\n TEXTUNIT     tu_block;\n TEXTUNIT     tu_prime;\n TEXTUNIT     tu_sec;\n TEXTUNIT     tu_dir;\n TEXTUNIT     tu_recfm;\n TEXTUNIT     tu_lrecl;\n TEXTUNIT     tu_blksz;\n TEXTUNIT     tu_dsorg;\n char        *lparp;\n char        *rparp;\n char         dsnseq \u00dd81\u00a8;\n char         member \u00dd81\u00a8;\n\n try_new = FALSE;\n\n memset((char *)&stuff99,0,sizeof(__S99parms));\n\n strcpy(member,\"\");\n strcpy(dsnseq,dsname);\n lparp = strchr(dsnseq,'(');\n rparp = strchr(dsnseq,')');\n if (lparp && rparp && (lparp < rparp) && (*(rparp+1) == '\\0')) {\n   *lparp = '\\0';            /* makes dsnseq the seq part only */\n   *rparp = '\\0';            /* turns member into a string     */\n   strcpy(member, lparp+1);\n   type = PDS;\n }\n\n for (;;) {\n\n   stuff99.__S99RBLN   = 20;\n   stuff99.__S99VERB   = S99VRBAL;\n   stuff99.__S99FLAG1  = S99NOCNV << 8;\n   stuff99.__S99ERROR  = 0;\n   stuff99.__S99INFO   = 0;\n   stuff99.__S99TXTPP  = tu;\n   stuff99.__S99FLAG2  = 0;\n\n   i = 0;\n\n   tu\u00ddi++\u00a8 = &tu_dsn;\n\n   tu_dsn.key        = DALDSNAM;\n   tu_dsn.num        = 1;\n   tu_dsn.ent.len    = strlen(dsnseq);\n   copy_uppercase(tu_dsn.ent.prm,dsnseq);\n\n   tu\u00ddi++\u00a8 = &tu_stat;\n\n   tu_stat.key      = DALSTATS;\n   tu_stat.num      = 1;\n   tu_stat.ent.len  = 1;\n   *tu_stat.ent.prm = (try_new ? NEW : SHR);\n\n   tu\u00ddi++\u00a8 = &tu_disp;\n\n   tu_disp.key      = DALNDISP;\n   tu_disp.num      = 1;\n   tu_disp.ent.len  = 1;\n   *tu_disp.ent.prm = (try_new ? CATLG : KEEP);\n\n   tu\u00ddi++\u00a8 = &tu_rtorg;\n\n   tu_rtorg.key     = DALRTORG;\n   tu_rtorg.num     = 1;\n   tu_rtorg.ent.len = 2;\n\n   if (*member) {\n\n     tu\u00ddi++\u00a8 = &tu_member;\n\n     tu_member.key     = DALMEMBR;\n     tu_member.num     = 1;\n     tu_member.ent.len = strlen(member);\n     copy_uppercase(tu_member.ent.prm,member);\n\n   }\n\n   if (ddname && *ddname) {\n\n     tu\u00ddi++\u00a8 = &tu_ddn;\n\n     tu_ddn.key     = DALDDNAM;\n     tu_ddn.num     = 1;\n     tu_ddn.ent.len = strlen(ddname);\n     copy_uppercase(tu_ddn.ent.prm,ddname);\n\n     tu\u00ddi++\u00a8 = &tu_perm;\n\n     tu_perm.key     = DALPERMA;\n     tu_perm.num     = 0;\n   }\n   else {\n\n     tu\u00ddi++\u00a8 = &tu_rtddn;\n\n     tu_rtddn.key     = DALRTDDN;\n     tu_rtddn.num     = 1;\n     tu_rtddn.ent.len = 8;\n     memset(tu_rtddn.ent.prm,' ',8);\n\n   }\n\n   if (try_new) {\n\n     switch (type) {\n       case PDS:\n                 primary_allocation   = (short)nitems;\n                 secondary_allocation = primary_allocation;\n                 directory_blocks     = (short)((nitems/(12*36)+1)*36);\n                 dsorg                = DSORG_PO;\n                 break;\n       case SEQ:\n       default:\n                 primary_allocation   = (short)nitems;\n                 secondary_allocation = primary_allocation;\n                 directory_blocks     = 0;\n                 dsorg                = DSORG_PS;\n                 break;\n     }\n\n     tu\u00ddi++\u00a8 = &tu_block;\n\n     tu_block.key     = DALBLKLN;\n     tu_block.num     = 1;\n     tu_block.ent.len = 3;\n     memset(tu_block.ent.prm,0,3);\n     *(short *)(tu_block.ent.prm+1) = 6233;\n\n     tu\u00ddi++\u00a8 = &tu_prime;\n\n     tu_prime.key     = DALPRIME;\n     tu_prime.num     = 1;\n     tu_prime.ent.len = 3;\n     memset(tu_prime.ent.prm,0,3);\n     *(short *)(tu_prime.ent.prm+1) = primary_allocation;\n\n     tu\u00ddi++\u00a8 = &tu_sec;\n\n     tu_sec.key     = DALSECND;\n     tu_sec.num     = 1;\n     tu_sec.ent.len = 3;\n     memset(tu_sec.ent.prm,0,3);\n     *(short *)(tu_sec.ent.prm+1) = secondary_allocation;\n\n     tu\u00ddi++\u00a8 = &tu_dir;\n\n     tu_dir.key     = DALDIR;\n     tu_dir.num     = 1;\n     tu_dir.ent.len = 3;\n     memset(tu_dir.ent.prm,0,3);\n     *(short *)(tu_dir.ent.prm+1) = directory_blocks;\n\n     tu\u00ddi++\u00a8 = &tu_recfm;\n\n     tu_recfm.key        = DALRECFM;\n     tu_recfm.num        = 1;\n     tu_recfm.ent.len    = 1;\n     *tu_recfm.ent.prm   = RECFM_VB;\n\n     tu\u00ddi++\u00a8 = &tu_lrecl;\n\n     tu_lrecl.key        = DALLRECL;\n     tu_lrecl.num        = 1;\n     tu_lrecl.ent.len    = 2;\n     *(short *)tu_lrecl.ent.prm   = 259;\n\n     tu\u00ddi++\u00a8 = &tu_blksz;\n\n     tu_blksz.key        = DALBLKSZ;\n     tu_blksz.num        = 1;\n     tu_blksz.ent.len    = 2;\n     *(short *)tu_blksz.ent.prm   = 6233;\n\n     tu\u00ddi++\u00a8 = &tu_dsorg;\n\n     tu_dsorg.key        = DALDSORG;\n     tu_dsorg.num        = 1;\n     tu_dsorg.ent.len    = 2;\n     *(short *)tu_dsorg.ent.prm   = dsorg;\n\n   }\n\n   tu\u00ddi\u00a8 = (void *)0x80000000;\n\n   rc = svc99(&stuff99);\n\n   if (rc == 0) {\n     if (!(ddname && *ddname)) {\n       memcpy(ddname,(char *)tu_rtddn.ent.prm,8);\n       *(ddname+8) = ' ';\n       *(strchr(ddname,' ')) = '\\0';\n     }\n     if (type == SEQ &&\n         tu_rtorg.ent.prm\u00dd0\u00a8 != 0x40) {\n       fprintf(stderr,\"%s: not a sequential data set\\n\",dsname);\n       return FALSE;\n     }\n     if (type == PDS &&\n         tu_rtorg.ent.prm\u00dd0\u00a8 != 0x02) {\n       fprintf(stderr,\"%s: not a partitioned data set\\n\",dsname);\n       return FALSE;\n     }\n     return TRUE;\n   }\n   else if (!try_new && nitems != 0 && stuff99.__S99ERROR == 0x1708) {\n    try_new = TRUE;\n    continue;\n   }\n   else {\n     NNMdfail(rc,&stuff99);\n     return FALSE;\n   }\n }\n}\n\n./ ADD NAME=NNMAUTH\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@AUTH \")\n#pragma  csect(static,\"NN$AUTH \")\n#include \"nn.h\"\n\n/****** Send authorization to news server. ***************************/\n\nBool\nNNMauth(np)\nRstruc nncb *np;\n{\n\n#ifdef AUTHFILE\n\n char              *lp;\n FILE              *fp;\n int                display_rc;\n Bool               auth_error;\n Bool               connection_probably_closed;\n char               authdd    \u00dd12\u00a8;\n char               authline \u00dd260\u00a8;\n char               host      \u00dd65\u00a8;\n char               user      \u00dd65\u00a8;\n char               pass      \u00dd65\u00a8;\n\n /* Send authorization.\n  *\n  * NNTP numbers must be the following as defined in C News source:\n  *\n  * OK_AUTHSYS    280  authorization system OK\n  * OK_AUTH       281  authorization OK\n  * NEED_AUTHINFO 380  authorization is required\n  * NEED_AUTHDATA 381  <type> authorization data required (e.g. PASS)\n  * ERR_NOAUTH    480  authorization required for command\n  * ERR_AUTHSYS   481  authorization system invalid\n  * ERR_AUTHREJ   482  authorization data rejected\n  * ERR_CMDSYN    501  command syntax error\n  * ERR_COMMAND   500  command not implemented\n  * ERR_ACCESS    502  access to server denied\n  * ERR_AUTHBAD   580  authorization failed\n  *\n  * Me:     AUTHINFO USER username\n  * Server: 381 PASS required\n  *     or: 482 Authorization already completed\n  *     or: 500 Command not recognized\n  *\n  * If 482, server does not accept our attempt to gain authorization.\n  *\n  * If 500, authorization is not needed or the server has never\n  * heard of authorization.  Either way, we proceed as \"authorized\".\n  *\n  * If 381 ...\n  *\n  * Me:     AUTHINFO PASS password\n  * Server: 281 Authorization OK\n  *     or: 482 authorization data rejected\n  *     or: 502 access to server denied\n  *     or: 580 authorization failed\n  *\n  * If 502, the server has disconnected me and I should return FALSE.\n  * Otherwise, everything is OK, and I should return TRUE.\n  *\n  */\n\n lp = \"None - local system error accessing authorization file\";\n\n auth_error = FALSE;\n connection_probably_closed = FALSE;\n *host   = '\\0';\n *user   = '\\0';\n *pass   = '\\0';\n\n /* Read user and pass from auth file */\n\n strcpy(authdd,\"dd:\");\n\n if (!NNMalloc(AUTHFILE,authdd+3,SEQ,0)) {  /* allocate as SHR */\n   auth_error = TRUE;\n }\n else {\n   if (!(fp=fopen(authdd,\"r\"))) {\n     perror(AUTHFILE);\n     auth_error = TRUE;\n   }\n   else {\n     for (;;) {\n       fgets(authline,sizeof(authline),fp);\n       if (feof(fp)) break;\n       if (ferror(fp)) {\n         fprintf(stderr,\"Error reading %s\\n\",AUTHFILE);\n         auth_error = TRUE;\n         break;\n       }\n       if (authline\u00dd0\u00a8 == '#') continue;      /* ignore comments */\n       *host = '\\0';\n       *user = '\\0';\n       *pass = '\\0';\n       sscanf(authline,\"%s %s %s\", host,user,pass);\n       uppercase_in_place(host);\n       if (EQUAL(host,np->nnserver)) break;\n     };\n     fclose(fp);\n   }\n   (void)NNMunalc(authdd+3);\n }\n\n if (!auth_error) {\n   if (*user == '\\0') return TRUE;  /* Don't do auth if no username */\n   sprintf(np->nntp_command,\"AUTHINFO USER %s\", user);\n   if (!NNMsockt(np)) return FALSE; /* Send socket command to server */\n   if (!NNMgsrvl(np,&lp)) return FALSE;  /* Get server line */\n   switch (np->nntp_message_num) {\n     case 381: /* PASS required */\n               break;\n     case 500: /* Command not recognized */\n               /* server does not support AUTHINFO - all clients OK */\n               return TRUE;\n     default:  NNMrperr(np);       /* Report protocol error */\n               auth_error = TRUE;\n               break;\n   }\n }\n\n if (!auth_error) {\n   sprintf(np->nntp_command,\"AUTHINFO PASS %s\", pass);\n   if (!NNMsockt(np)) return FALSE; /* Send socket command to server */\n   if (!NNMgsrvl(np,&lp)) return FALSE;  /* Get server line */\n   switch (np->nntp_message_num) {\n     case 281: /* authorization OK */\n               return TRUE;\n     case 502: /* access to server denied */\n               /* Also, we have been disconnected at this point. */\n               connection_probably_closed = TRUE;\n               auth_error = TRUE;\n               break;\n     default:  NNMrperr(np);       /* Report protocol error */\n               auth_error = TRUE;\n               break;\n   }\n }\n\n NNMesrvr(np);                   /* End server read */\n\n if (auth_error) {\n\n   if (connection_probably_closed) {\n     ERR2(\"Authorization failed;\\\nThe NNTP server at %s refuses to authorize you.  \\\nSome news operations may fail.\",\\\n          np->nnserver);\n     np->connection_broken = TRUE;\n     NNMdisc(np);                  /* Complete disconnection */\n     return FALSE;\n   }\n   else {\n     if (np->batch_mode) {\n       fprintf(stderr,\n        \"NNMVS could not obtain authorization from the NNTP server.\\n\");\n       fprintf(stderr,\n        \"NNMVS will proceed, but some news operations may fail.\\n\");\n       fprintf(stderr,\n        \"The response from server %s was:\\n\\n%s\\n\\n\", np->nnserver,lp);\n       return TRUE;\n     }\n     else {\n       NNMivput(np,\"NNSERVER \",np->nnserver,-1);\n       NNMivput(np,\"NNSRVRSP \",lp,          -1);\n       (void)NNMispf(np,\"ADDPOP \");\n       (void)NNMispf(np,\"DISPLAY PANEL(NNMPAUTH)\");\n       display_rc = np->ispfrc;\n       (void)NNMispf(np,\"REMPOP \");\n       if (display_rc == 0) return TRUE;\n       else {\n         NNMdisc(np);\n         return FALSE;\n       }\n     }\n   }\n\n }\n\n else return TRUE;\n\n#else\n\n return TRUE;  /* no authorization file defined */\n\n#endif\n\n}\n\n./ ADD NAME=NNMBATCH\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BATCH\")\n#pragma  csect(static,\"NN$BATCH\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Parse command. ***********************************************/\n\nstatic void\nparse_command(np,bp,proc)\nRstruc nncb         *np;\nRstruc batch        *bp;\nCommandParser        proc;\n{\n Rstruc newscmd     *cmdp = NULL;\n struct cmdtree     *treep;\n\n cmdp = (proc)(np,bp);\n\n if (!cmdp) return;\n\n /* If a newscmd structure was returned, add it to the cmd tree. */\n\n GETMAIN(treep, struct cmdtree, 1, \"command tree\");\n if (!treep) {\n   bp->input_errors++;\n   return;\n }\n\n treep->next = NULL;\n treep->cmd  = cmdp;\n\n if (bp->treebottom == NULL) bp->treetop = treep;\n else               bp->treebottom->next = treep;\n bp->treebottom = treep;\n\n return;\n}\n\n/****** Process requests. ********************************************/\n\nstatic void\nprocess_requests(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n Rstruc cmdtree     *treep;\n\n if (bp->treetop == NULL) {\n   fprintf(np->batch_outfile, \"There is no processing to be done.\\n\");\n }\n\n for (treep = bp->treetop; treep; treep = treep->next) {\n   bp->runtime_error = FALSE;\n   (treep->cmd->proc) (np,bp,treep->cmd);\n   if (ferror(np->batch_outfile)) {\n     fprintf(stderr,\"*** Error writing to batch output file ***\\n\");\n   }\n   SETB(\"ERROR\",bp->runtime_error);\n }\n\n return;\n\n}\n\n/****** Flag unmatched END. ******************************************/\n\nstatic struct newscmd *\nflag_unmatched_end(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n NNMbsynt(np,bp,NULL,0,\"END without matching DO seen\");\n\n return NULL;\n}\n\n/****** Flag invalid ISPLINK call. ***********************************/\n\nstatic int\nflag_invalid_isplink_call(service,argument)\nchar  *service;\nchar  *argument;\n{\n fprintf(stderr,\n         \"*** Attempt to call ISPLINK in batch mode:\\n%8.8s %8.8s\\n\",\n         service, argument);\n\n return 20;\n}\n\n/****** Flag invalid ISPEXEC call. ***********************************/\n\nstatic int\nflag_invalid_ispexec_call(lenp,buf)\nint   *lenp;\nchar  *buf;\n{\n fprintf(stderr,\"*** Attempt to call ISPEXEC in batch mode:\\n%*.*s\\n\",\n                *lenp, *lenp, buf);\n return 20;\n}\n\n/****** NNMVS batch mode. ********************************************/\n\nint\nNNMbatch(np)\nRstruc nncb         *np;\n{\n struct batch       *bp;\n char               *timep;\n char               *cp;\n CommandParser       proc;\n time_t              ltime;\n struct batch        batch_struct;\n\n static char         reserved_words \u00dd\u00a8 = {\n \"AND       DECLARE   DEREGISTERDO        ELSE      \"\n \"END       EQ        EXEC      EXTRACT   FALSE     \"\n \"FOR       GE        GT        HELP      IF        \"\n \"IN        LE        LT        MARK      NE        \"\n \"NNTP      NO        NOT       OFF       ON        \"\n \"OR        PUT       QUERY     QUIT      REGISTER  \"\n \"SET       THEN      TO        TRUE      VARS      \"\n \"WHEN      YES                \"                     };\n\n if (!(np->batch_infile && np->batch_outfile)) {\n   fprintf(stderr,\"NNMVS: Batch operation failed.  Terminated.\\n\");\n   return 16;\n }\n\n#ifdef FETCH\n\n   np->isplink_pointer = (int (*) ())flag_invalid_isplink_call;\n   np->ispexec_pointer = (int (*) ())flag_invalid_ispexec_call;\n\n#endif\n\n time(&ltime);\n timep = ctime(&ltime);\n if ((cp=strchr(timep,'\\n'))) *cp = '\\0';\n\n fprintf(np->batch_outfile,\"NNMVS news client at %s - %s\\n\\n\",\n                           np->client_hostname, timep);\n\n bp = &batch_struct;\n np->batch_hook = bp;\n memset(bp,0,sizeof(struct batch));\n bp->reserved_words = reserved_words;\n bp->mode           = INITIAL_MODE;\n bp->curtok.type    = NO_TOKEN;\n bp->nextok.type    = NO_TOKEN;\n bp->endproc        = flag_unmatched_end;\n\n#undef  TRUE\n#define TRUE (void *)(1)\n\n /* Declare built-in variables along with initial values. */\n\n /* globally valid */\n\n NNMbdecl(np,bp,\"LOCALPATH\",    STRING_SYMTYPE, np->client_hostname);\n NNMbdecl(np,bp,\"DATETIME\",     STRING_SYMTYPE, timep      );\n NNMbdecl(np,bp,\"SERVER\",       STRING_SYMTYPE, \"\"         );\n NNMbdecl(np,bp,\"OUTFILE\",      STRING_SYMTYPE, \"\"         );\n NNMbdecl(np,bp,\"SERVERLIST\",   FLAG_SYMTYPE,   TRUE       );\n NNMbdecl(np,bp,\"AUTOREGISTER\", FLAG_SYMTYPE,   FALSE      );\n NNMbdecl(np,bp,\"AUTODELETE\",   FLAG_SYMTYPE,   TRUE       );\n NNMbdecl(np,bp,\"AUTOMARK\",     FLAG_SYMTYPE,   TRUE       );\n NNMbdecl(np,bp,\"ERROR\",        FLAG_SYMTYPE,   FALSE      );\n NNMbdecl(np,bp,\"EXACTCASE\",    FLAG_SYMTYPE,   FALSE      );\n NNMbdecl(np,bp,\"TABEXPAND\",    FLAG_SYMTYPE,   TRUE       );\n NNMbdecl(np,bp,\"APPEND\",       FLAG_SYMTYPE,   TRUE       );\n NNMbdecl(np,bp,\"SEPARATOR\",    STRING_SYMTYPE, \"\"         );\n NNMbdecl(np,bp,\"BLANKSEP\",     FLAG_SYMTYPE,   FALSE      );\n NNMbdecl(np,bp,\"CHECKPOINT\",   FLAG_SYMTYPE,   TRUE       );\n\n /* for newsgroups only */\n\n NNMbdecl(np,bp,\"GROUP\",        STRING_SYMTYPE, \"\"         );\n NNMbdecl(np,bp,\"REGISTERED\",   FLAG_SYMTYPE,   FALSE      );\n NNMbdecl(np,bp,\"NEWGROUP\",     FLAG_SYMTYPE,   FALSE      );\n NNMbdecl(np,bp,\"NOSUCHGROUP\",  FLAG_SYMTYPE,   FALSE      );\n NNMbdecl(np,bp,\"COUNT\",        NUMBER_SYMTYPE, 0          );\n NNMbdecl(np,bp,\"UNREAD\",       NUMBER_SYMTYPE, 0          );\n NNMbdecl(np,bp,\"FIRST\",        NUMBER_SYMTYPE, 0          );\n NNMbdecl(np,bp,\"LAST\",         NUMBER_SYMTYPE, 0          );\n\n /* for articles only */\n\n NNMbdecl(np,bp,\"NUMBER\",       NUMBER_SYMTYPE, 0          );\n NNMbdecl(np,bp,\"READ\",         FLAG_SYMTYPE,   FALSE      );\n NNMbdecl(np,bp,\"MISSING\",      FLAG_SYMTYPE,   FALSE      );\n NNMbdecl(np,bp,\"SUBJECT\",      STRING_SYMTYPE, \"\"         );\n NNMbdecl(np,bp,\"DATE\",         STRING_SYMTYPE, \"\"         );\n NNMbdecl(np,bp,\"FROM\",         STRING_SYMTYPE, \"\"         );\n NNMbdecl(np,bp,\"MESSAGEID\",    STRING_SYMTYPE, \"\"         );\n\n do {\n   if ((proc = NNMbgcmd(np,bp))) {\n     parse_command(np,bp,proc);\n   }\n } while (!bp->eof);\n\n if (bp->input_errors > 0) {\n   fprintf(np->batch_outfile, \"\\nNo processing due to input errors.\\n\");\n   return 12;\n }\n\n else {\n\n   fprintf(np->batch_outfile, \"\\n\\nOpening NEWSRC...\\n\\n\");\n   strcpy(np->newsrc_to_open,\"DD:NNNEWSRC\");\n   NNMonrf(np,NULL);                             /* Open NEWSRC file */\n   fprintf(np->batch_outfile, \"\\n\\nProcessing requests...\\n\\n\");\n   process_requests(np,bp);\n   fprintf(np->batch_outfile, \"\\n\\nClosing NEWSRC...\\n\\n\");\n   NNMcnrf(np,NULL,(Fool)TRUE);                /* Close  NEWSRC file */\n\n }\n\n /* Clean up any outfile hacking that may have been done. */\n\n SETC(\"OUTFILE\",\"\");\n (void)NNMbsout(np,bp);     /* Set output file */\n\n np->batch_hook = NULL;\n\n return bp->request_errors;\n\n}\n\n./ ADD NAME=NNMBBEXP\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BBEXP\")\n#pragma  csect(static,\"NN$BBEXP\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n#define CLEAR_THING(X) memset((char *)&X, 0, sizeof(struct thing))\n\nstatic void from_exp      ();\nstatic void from_choice   ();\nstatic void from_relation ();\nstatic void from_value    ();\nstatic void from_quantity ();\nstatic void from_term     ();\nstatic void from_factor   ();\nstatic void from_unop     ();\nstatic void from_addop    ();\nstatic void from_mulop    ();\nstatic void from_logop    ();\nstatic void from_relop    ();\nstatic void from_constant ();\nstatic void from_variable ();\nstatic void from_number   ();\nstatic void from_string   ();\nstatic void from_flag     ();\n\n/****** Free old value when replacing it with a new value. ***********/\n\n#define free_old_value(A,B)  /* */\n\n/* Do nothing yet.  This may not have been a malloc'd value...\n *\n *  static void\n *  free_old_value(np,tp)\n *  Rstruc nncb         *np;\n *  Rstruc thing        *tp;\n *  {\n *\n * if (tp->typ == STRING_SYMTYPE) {\n * FREEMAIN((char *)tp->val,\"old intermediate expression string value\");\n * tp->val = NULL;\n * }\n *\n * return;\n * }\n */\n\n/****** Case-insensitive string compare. *****************************/\n\nstatic int\nUstrcmp(a,b)\nregister char  *a;\nregister char  *b;\n{\n register char  A;\n register char  B;\n\n while (*a || *b) {\n   A = toupper(*a++);\n   B = toupper(*b++);\n   if (A > B) return 1;\n   if (A < B) return -1;\n }\n\n return 0;\n}\n\n/****** Case-insensitive string search. ******************************/\n\nstatic char *\nUstrstr(b,a)\nregister char  *b;\nregister char  *a;\n{\n register char *aa;\n register char *bb;\n\n if (!*a) return strchr(b,'\\0');\n for (;;) {\n   while (*b && toupper(*a) != toupper(*b)) b++;\n   if (!*b) return NULL;\n   aa = a;\n   bb = b;\n   while (*aa && *bb && toupper(*aa) == toupper(*bb)) {\n     aa++;\n     bb++;\n   }\n   if (!*aa) return a;\n   b++;\n }\n}\n\n/****** Concatenate string values. ***********************************/\n\nstatic void\ncat(np,bp,tp,tp1,tp2)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nRstruc thing        *tp1;\nRstruc thing        *tp2;\n{\n char               *strdata1;\n char               *strdata2;\n char               *newstr;\n int                 newlen;\n\n /* for now, just do a lot of getmains and freemains */\n\n free_old_value(np,tp);\n\n strdata1 = (char *)tp1->val;\n strdata2 = (char *)tp2->val;\n\n if (*strdata1 == '\\0') {\n   tp->val = (ANYTYPE)tp2->val;\n }\n else if (*strdata2 == '\\0') {\n   tp->val = (ANYTYPE)tp1->val;\n }\n else {\n\n   newlen = strlen(strdata1) + strlen(strdata2) + 1;\n\n   GETMAIN(newstr, 1, newlen, \"new concatenated string\");\n\n   if (!newstr) {\n     fprintf(np->batch_outfile,\n      \"Error, no storage to concatenate strings: %s, %s\\n\",\n             tp1->val, tp2->val);\n     longjmp(bp->jump,ERROR_GETMAIN_FAILURE);\n   }\n\n   strcpy(newstr,(char *)tp1->val);\n   strcat(newstr,(char *)tp2->val);\n\n   tp->val = (ANYTYPE)newstr;\n\n }\n\n tp->typ = STRING_SYMTYPE;\n free_old_value(np,tp1);\n free_old_value(np,tp2);\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nconvert_to_string(np,bp,tp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\n{\n Fool                tempflag;\n char                tempstr\u00dd17\u00a8;\n\n switch (tp->typ) {\n   case STRING_SYMTYPE: return;\n   case NUMBER_SYMTYPE:\n                        sprintf(tempstr, \"%d\", (int)tp->val);\n                        tp->val = (ANYTYPE)NNMcopy(np,tempstr);\n                        tp->typ = STRING_SYMTYPE;\n                        return;\n   case FLAG_SYMTYPE:\n                        tempflag = (Fool)tp->val;\n                        tp->val = tempflag ? (ANYTYPE)\"TRUE\"\n                                           : (ANYTYPE)\"FALSE\";\n                        tp->typ = STRING_SYMTYPE;\n                        return;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nconvert_to_number(np,bp,tp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\n{\n Fool                tempflag;\n\n switch (tp->typ) {\n   case NUMBER_SYMTYPE: return;\n   case FLAG_SYMTYPE:\n                        tempflag = (Fool)tp->val;\n                        tp->val = tempflag ? (ANYTYPE)1\n                                           : (ANYTYPE)0;\n                        tp->typ = NUMBER_SYMTYPE;\n                        return;\n   case STRING_SYMTYPE:\n   /* Note: This should be permitted if the string is all numerics,\n    *       but for now it is always an error.\n    * If permitted, call free_old_value before altering.\n    */\n                        fprintf(np->batch_outfile,\n             \"Type mismatch, cannot convert string to number: %s\\n\",\n                                tp->val);\n                        longjmp(bp->jump,ERROR_TYPE_MISMATCH);\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nconvert_to_flag(np,bp,tp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\n{\n\n switch (tp->typ) {\n   case FLAG_SYMTYPE:   return;\n   case NUMBER_SYMTYPE:\n   /* Note: This should be permitted if the number is 0 or 1,\n    *       but for now it is always an error.\n    */\n                        fprintf(np->batch_outfile,\n             \"Type mismatch, cannot convert number to flag: %d\\n\",\n                                tp->val);\n                        longjmp(bp->jump,ERROR_TYPE_MISMATCH);\n   case STRING_SYMTYPE:\n   /* Note: This should be permitted if the string is \"0\", \"1\",\n    *       \"TRUE\", \"FALSE\", \"ON\", \"OFF\", \"YES\", or \"NO\",\n    *       but for now it is always an error.\n    * If permitted, call free_old_value before altering.\n    */\n                        fprintf(np->batch_outfile,\n             \"Type mismatch, cannot convert string to flag: %s\\n\",\n                                tp->val);\n                        longjmp(bp->jump,ERROR_TYPE_MISMATCH);\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_number(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nNumber               p;\n{\n\n tp->val = (ANYTYPE)p->number1;\n tp->typ = NUMBER_SYMTYPE;\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_string(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nString               p;\n{\n\n tp->val = (ANYTYPE)p->string1;\n tp->typ = STRING_SYMTYPE;\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_flag(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nFlag                 p;\n{\n\n tp->val = (ANYTYPE)p->flag1;\n tp->typ = FLAG_SYMTYPE;\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_variable(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nVariable             p;\n{\n enum symtype        type;\n\n type = p->s;\n\n tp->val = (ANYTYPE)NNMbvget(np,bp,p->variable1,type);\n tp->typ = type;\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_constant(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nConstant             p;\n{\n\n switch (p->r) {\n   case RHSTYPE_A: from_number(np,bp,tp,p->u.a.number1); break;\n   case RHSTYPE_B: from_string(np,bp,tp,p->u.b.string1); break;\n   case RHSTYPE_C: from_flag  (np,bp,tp,p->u.c.flag1  ); break;\n }\n\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_factor(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nFactor               p;\n{\n struct thing        t1;\n\n switch (p->r) {\n   case RHSTYPE_A: from_constant(np,bp,tp,p->u.a.constant1); break;\n   case RHSTYPE_B: from_variable(np,bp,tp,p->u.b.variable1); break;\n   case RHSTYPE_C:\n                   CLEAR_THING(t1);\n                   from_factor(np,bp,&t1,p->u.c.factor2);\n                   switch (p->u.c.unop1->op1) {\n                     case ADD_OP:\n                                  convert_to_number(np,bp,&t1);\n                                  tp->val = t1.val;\n                                  tp->typ = NUMBER_SYMTYPE;\n                                  break;\n                     case SUB_OP:\n                                  convert_to_number(np,bp,&t1);\n                                  tp->val = (ANYTYPE)\n                                            (-((int)t1.val));\n                                  tp->typ = NUMBER_SYMTYPE;\n                                  break;\n                     case NOT_OP:\n                                  convert_to_flag(np,bp,&t1);\n                                  tp->val = (ANYTYPE)\n                                            (!((Fool)t1.val));\n                                  tp->typ = FLAG_SYMTYPE;\n                                  break;\n                   }\n                   break;\n   case RHSTYPE_D: from_exp(np,bp,tp,p->u.d.exp1); break;\n }\n\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_term(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nTerm                 p;\n{\n struct thing        t1;\n struct thing        t3;\n\n switch (p->r) {\n   case RHSTYPE_A: from_factor(np,bp,tp,p->u.a.factor1); break;\n   case RHSTYPE_B:\n                   CLEAR_THING(t1);\n                   CLEAR_THING(t3);\n                   from_term  (np,bp,&t1,p->u.b.term1  );\n                   from_factor(np,bp,&t3,p->u.b.factor3);\n                   convert_to_number(np,bp,&t1);\n                   convert_to_number(np,bp,&t3);\n                   switch (p->u.b.mulop2->op1) {\n                     case MUL_OP:\n                                  /* how to detect overflow? */\n                                  tp->val = (ANYTYPE)\n                                            ((int)t1.val * (int)t3.val);\n                                  break;\n                     case DIV_OP:\n                                  if ((int)t3.val == 0) {\n                                    fprintf(np->batch_outfile,\n                               \"Arithmetic error, division by zero\\n\");\n                                    longjmp(bp->jump,ERROR_ZERODIVIDE);\n                                  }\n                                  tp->val = (ANYTYPE)\n                                            ((int)t1.val / (int)t3.val);\n                                  break;\n                   }\n                   tp->typ = NUMBER_SYMTYPE;\n                   break;\n }\n\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_quantity(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nQuantity             p;\n{\n struct thing        t1;\n struct thing        t3;\n\n switch (p->r) {\n   case RHSTYPE_A: from_term(np,bp,tp,p->u.a.term1); break;\n   case RHSTYPE_B:\n                   CLEAR_THING(t1);\n                   CLEAR_THING(t3);\n                   from_quantity(np,bp,&t1,p->u.b.quantity1);\n                   from_term    (np,bp,&t3,p->u.b.term3);\n                   convert_to_number(np,bp,&t1);\n                   convert_to_number(np,bp,&t3);\n                   switch (p->u.b.addop2->op1) {\n                     case ADD_OP:\n                                  /* how to detect overflow? */\n                                  tp->val = (ANYTYPE)\n                                            ((int)t1.val + (int)t3.val);\n                                  break;\n                     case SUB_OP:\n                                  /* how to detect overflow? */\n                                  tp->val = (ANYTYPE)\n                                            ((int)t1.val - (int)t3.val);\n                                  break;\n                   }\n                   tp->typ = NUMBER_SYMTYPE;\n                   break;\n }\n\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_value(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nValue                p;\n{\n struct thing        t1;\n struct thing        t2;\n\n switch (p->r) {\n   case RHSTYPE_A: from_quantity(np,bp,tp,p->u.a.quantity1); break;\n   case RHSTYPE_B:\n                   CLEAR_THING(t1);\n                   CLEAR_THING(t2);\n                   from_value   (np,bp,&t1,p->u.b.value1);\n                   from_quantity(np,bp,&t2,p->u.b.quantity2);\n                   convert_to_string(np,bp,&t1);\n                   convert_to_string(np,bp,&t2);\n                   cat(np,bp,tp,&t1,&t2);\n                   break;\n }\n\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_relation(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nRelation             p;\n{\n enum optype         op;\n struct thing        t1;\n struct thing        t3;\n\n switch (p->r) {\n   case RHSTYPE_A: from_value(np,bp,tp,p->u.a.value1); break;\n   case RHSTYPE_B:\n        CLEAR_THING(t1);\n        CLEAR_THING(t3);\n        from_value(np,bp,&t1,p->u.b.value1);\n        from_value(np,bp,&t3,p->u.b.value3);\n        /* If either value is a string,\n         * or operation is \"IN\", do string compare.\n         * Otherwise do numeric compare.\n         * Note: Currently we are case sensitive.\n         *       This possibly should be changed, but\n         *       not now...\n         */\n        op = p->u.b.relop2->op1;\n        if (op == IN_OP\n         || t1.typ == STRING_SYMTYPE\n         || t3.typ == STRING_SYMTYPE) {\n          convert_to_string(np,bp,&t1);\n          convert_to_string(np,bp,&t3);\n          if (bp->exactcase) {\n            switch (op) {\n              case EQ_OP: tp->val = (ANYTYPE)\n                          (strcmp((char *)t1.val,(char *)t3.val) == 0);\n                          break;\n              case NE_OP: tp->val = (ANYTYPE)\n                          (strcmp((char *)t1.val,(char *)t3.val) != 0);\n                          break;\n              case GT_OP: tp->val = (ANYTYPE)\n                          (strcmp((char *)t1.val,(char *)t3.val) >  0);\n                          break;\n              case LT_OP: tp->val = (ANYTYPE)\n                          (strcmp((char *)t1.val,(char *)t3.val) <  0);\n                          break;\n              case GE_OP: tp->val = (ANYTYPE)\n                          (strcmp((char *)t1.val,(char *)t3.val) >= 0);\n                          break;\n              case LE_OP: tp->val = (ANYTYPE)\n                          (strcmp((char *)t1.val,(char *)t3.val) <= 0);\n                          break;\n              case IN_OP: tp->val = (ANYTYPE)\n                          (strstr((char *)t3.val,(char *)t1.val)!=NULL);\n                          break;\n            }\n          }\n          else {\n            switch (op) {\n              case EQ_OP: tp->val = (ANYTYPE)\n                         (Ustrcmp((char *)t1.val,(char *)t3.val) == 0);\n                          break;\n              case NE_OP: tp->val = (ANYTYPE)\n                         (Ustrcmp((char *)t1.val,(char *)t3.val) != 0);\n                          break;\n              case GT_OP: tp->val = (ANYTYPE)\n                         (Ustrcmp((char *)t1.val,(char *)t3.val) >  0);\n                          break;\n              case LT_OP: tp->val = (ANYTYPE)\n                         (Ustrcmp((char *)t1.val,(char *)t3.val) <  0);\n                          break;\n              case GE_OP: tp->val = (ANYTYPE)\n                         (Ustrcmp((char *)t1.val,(char *)t3.val) >= 0);\n                          break;\n              case LE_OP: tp->val = (ANYTYPE)\n                         (Ustrcmp((char *)t1.val,(char *)t3.val) <= 0);\n                          break;\n              case IN_OP: tp->val = (ANYTYPE)\n                         (Ustrstr((char *)t3.val,(char *)t1.val)!=NULL);\n                          break;\n            }\n          }\n        }\n        else {\n          convert_to_number(np,bp,&t1);\n          convert_to_number(np,bp,&t3);\n          switch (op) {\n            case EQ_OP: tp->val = (ANYTYPE)((int)t1.val == (int)t3.val);\n                        break;\n            case NE_OP: tp->val = (ANYTYPE)((int)t1.val != (int)t3.val);\n                        break;\n            case GT_OP: tp->val = (ANYTYPE)((int)t1.val >  (int)t3.val);\n                        break;\n            case LT_OP: tp->val = (ANYTYPE)((int)t1.val <  (int)t3.val);\n                        break;\n            case GE_OP: tp->val = (ANYTYPE)((int)t1.val >= (int)t3.val);\n                        break;\n            case LE_OP: tp->val = (ANYTYPE)((int)t1.val <= (int)t3.val);\n                        break;\n          }\n        }\n        tp->typ = FLAG_SYMTYPE;\n        break;\n }\n\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_choice(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nChoice               p;\n{\n struct thing        t1;\n struct thing        t3;\n\n switch (p->r) {\n   case RHSTYPE_A: from_relation(np,bp,tp,p->u.a.relation1); break;\n   case RHSTYPE_B:\n        CLEAR_THING(t1);\n        CLEAR_THING(t3);\n        from_choice  (np,bp,&t1,p->u.b.choice1);\n        from_relation(np,bp,&t3,p->u.b.relation3);\n        convert_to_flag(np,bp,&t1);\n        convert_to_flag(np,bp,&t3);\n        switch (p->u.b.logop2->op1) {\n          case AND_OP:\n                       tp->val = (ANYTYPE)\n                                 ((Fool)t1.val && (Fool)t3.val);\n                       break;\n          case OR_OP:\n                       tp->val = (ANYTYPE)\n                                 ((Fool)t1.val || (Fool)t3.val);\n                       break;\n        }\n        tp->typ = FLAG_SYMTYPE;\n        break;\n }\n\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nfrom_exp(np,bp,tp,p)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc thing        *tp;\nExp                  p;\n{\n struct thing        t1;\n struct thing        t2;\n struct thing        t3;\n\n switch (p->r) {\n   case RHSTYPE_A: from_choice(np,bp,tp,p->u.a.choice1); break;\n   case RHSTYPE_B:\n        CLEAR_THING(t1);\n        CLEAR_THING(t2);\n        CLEAR_THING(t3);\n        from_exp(np,bp,&t1,p->u.b.exp1);\n        from_exp(np,bp,&t2,p->u.b.exp2);\n        from_exp(np,bp,&t3,p->u.b.exp3);\n        convert_to_flag(np,bp,&t1);\n        if ((Fool)t1.val) {\n          tp->val = t2.val;\n          tp->typ = t2.typ;\n        }\n        else {\n          tp->val = t3.val;\n          tp->typ = t3.typ;\n        }\n        break;\n }\n\n return;\n}\n\n/****** Build object from ptree to return as run-time value. *********/\n\nANYTYPE\nNNMbbexp(np,bp,treep,type)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc ptree        *treep;\nenum symtype         type;\n{\n struct thing        it;\n\n CLEAR_THING(it);\n\n bp->exactcase = GETB(\"EXACTCASE\");\n\n /* Define return point for run-time errors during evaluation. */\n\n if (setjmp(bp->jump) != 0) {\n   bp->request_errors++;\n   bp->runtime_error = TRUE;\n   return NULL;\n }\n\n /* Get the value, whatever type it turns out to be. */\n\n from_exp(np,bp,&it,treep->exp1);\n\n /* Try to make the value match the requested type. */\n\n switch (type) {\n\n   case STRING_SYMTYPE: convert_to_string(np,bp,&it); break;\n   case NUMBER_SYMTYPE: convert_to_number(np,bp,&it); break;\n   case   FLAG_SYMTYPE: convert_to_flag  (np,bp,&it); break;\n\n }\n\n /* Return the value. */\n\n return it.val;\n\n}\n\n./ ADD NAME=NNMBCONN\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BCONN\")\n#pragma  csect(static,\"NN$BCONN\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Insure server name. ******************************************/\n\nstatic void\ninsure_server_name(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n char               *servername;\n\n if (!*np->nnserver) {\n   servername = GETC(\"SERVER\");\n   if (servername) {\n     strncpy(np->nnserver,servername,sizeof(np->nnserver));\n   }\n }\n\n return;\n}\n\n/****** Connect to server in batch mode. *****************************/\n\nBool\nNNMbconn(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n\n if (!np->connected_to_server) {\n   insure_server_name(np,bp);\n   if (!NNMconn(np)) {              /* Connect to server */\n     fprintf(np->batch_outfile,\"Server connection failed.\\n\");\n     return FALSE;\n   }\n }\n\n return np->connected_to_server;\n}\n\n./ ADD NAME=NNMBDECL\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BDECL\")\n#pragma  csect(static,\"NN$BDECL\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Validate a variable name. ************************************/\n\nstatic Bool\nvalidate(np,bp,var)\nRstruc nncb         *np;\nRstruc batch        *bp;\nchar                *var;\n{\n int                 varlen;\n char               *cp;\n char                vartest\u00ddMAX_RESERVED_WORD_LENGTH\u00a8;\n\n varlen = strlen(var);\n if (varlen < 1 || varlen > MAX_SYMBOL_LENGTH) {\n   ERR2(\n    \"A variable name must be between 1 and %d characters in length.\",\n        MAX_SYMBOL_LENGTH);\n   return FALSE;\n }\n\n if (varlen >= MIN_RESERVED_WORD_LENGTH\n  && varlen <= MAX_RESERVED_WORD_LENGTH) {\n\n   memset(vartest,' ',MAX_RESERVED_WORD_LENGTH);\n   memcpy(vartest,var,strlen(var));\n\n   for (cp = bp->reserved_words; *cp != ' '; cp += 10) {\n     if (memcmp(vartest,cp,MAX_RESERVED_WORD_LENGTH) == 0) {\n       ERR2(\n    \"The name %s is reserved and cannot be used as a variable name.\",\n            var);\n       return FALSE;\n     }\n   }\n }\n\n return TRUE;\n}\n\n/****** Declare a variable symbol. ***********************************/\n\nstruct symtab *\nNNMbdecl(np,bp,var,type,val)\nRstruc nncb         *np;\nRstruc batch        *bp;\nchar                *var;\nenum symtype         type;\nANYTYPE              val;\n{\n Rstruc symtab      *symp;\n Rstruc symtab     **sympref;\n struct symtab      *sympnew;\n struct symtab      *sympleft;\n struct symtab      *sympright;\n int                 minimum_value_length;\n int                 getlen;\n int                 comp;\n char                vartest\u00ddMAX_SYMBOL_LENGTH\u00a8;\n\n if (!validate(np,bp,var)) {\n   NNMbsynt(np,bp,var,0,\"Variable name cannot be declared\");\n   return NULL;\n }\n memset(vartest,'\\0',MAX_SYMBOL_LENGTH);\n memcpy(vartest,var,strlen(var));\n\n switch (type) {\n   case STRING_SYMTYPE: minimum_value_length = strlen((char *)val) + 1;\n                        break;\n   case NUMBER_SYMTYPE: minimum_value_length = 12;\n                        break;\n   case FLAG_SYMTYPE:   minimum_value_length = 6;\n                        break;\n }\n\n sympleft  = NULL;\n sympright = NULL;\n sympref   = &bp->symtabp;\n\n while ((symp=*sympref)) {\n   switch ((comp=memcmp(vartest, symp->symvar, MAX_SYMBOL_LENGTH))) {\n     case 0:   /* equal   */\n               NNMbsynt(np,bp,var,0,\n                        \"Variable being declared already exists\");\n               return NULL;\n     case 1:   /* greater */\n               sympref = &symp->right;\n               continue;\n     default:  /* less    */\n               sympref = &symp->left;\n               continue;\n   }\n }\n\n /* Allocate a new symbol table entry for this new symbol and\n  * add it to the tree.\n  */\n\n getlen = offsetof(struct symtab, symval) + minimum_value_length;\n\n GETMAIN(sympnew, char, getlen, \"new symbol table entry\");\n if (!sympnew) {\n   NNMbsynt(np,bp,var,0,\"Not enough storage to declare symbol\");\n   return NULL;\n }\n\n memcpy(sympnew->symvar, vartest, MAX_SYMBOL_LENGTH);\n sympnew->left   = sympleft;\n sympnew->right  = sympright;\n sympnew->vallen = minimum_value_length;\n *sympref        = sympnew;\n\n sympnew->type = type;\n\n switch (type) {\n   case STRING_SYMTYPE:\n                        strcpy(sympnew->symval,(char *)val);\n                        if (np->debug_file)\n                           fprintf(np->debug_file,\n                                   \"NNMbdecl: %s set to '%s'\\n\",\n                                   sympnew->symvar, sympnew->symval);\n                        break;\n   case NUMBER_SYMTYPE:\n                        sympnew->symnum = (int)val;\n                        if (np->debug_file)\n                           fprintf(np->debug_file,\n                                   \"NNMbdecl: %s set to %d\\n\",\n                                   sympnew->symvar, sympnew->symnum);\n                        break;\n   case FLAG_SYMTYPE:\n                        sympnew->symnum = (int)val ? 1 : 0;\n                        if (np->debug_file)\n                           fprintf(np->debug_file,\n                                   \"NNMbdecl: %s set to %s\\n\",\n                                   sympnew->symvar,\n                                   sympnew->symnum ? \"TRUE\" : \"FALSE\");\n                        break;\n }\n\n\n return sympnew;\n\n}\n\n./ ADD NAME=NNMBFLUS\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BFLUS\")\n#pragma  csect(static,\"NN$BFLUS\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Flush input line. ********************************************/\n\nvoid\nNNMbflus(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n\n /* This routine eats tokens, ignoring them, until it sees a\n    semicolon or a new line. */\n\n if (np->debug_file) {\n   fprintf(np->debug_file,\"Flushing rest of input line.\\n\");\n }\n\n bp->stop_at_newline = TRUE;\n\n for (;;) {\n   if (!NNMbgtok(np,bp,TOKEN_FLUSH)) break;  /* get token */\n   switch (bp->curtok.type) {\n     case EOF_TOKEN:\n     case EOL_TOKEN:\n     case SEMI_TOKEN:  break;\n     default:\n                       if (np->debug_file) {\n                         fprintf(np->debug_file,\"Ignoring token.\\n\");\n                       }\n                       continue;\n   }\n   break;\n }\n\n bp->stop_at_newline = FALSE;\n\n return;\n}\n\n./ ADD NAME=NNMBGCMD\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BGCMD\")\n#pragma  csect(static,\"NN$BGCMD\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n#define BATCHPARSER(X)   extern struct newscmd * \\\n                                     X (struct nncb *, struct batch *)\n\nBATCHPARSER (NNMbphel);       /* Parse batch HELP         command     */\nBATCHPARSER (NNMbpfor);       /* Parse batch FOR          command     */\nBATCHPARSER (NNMbpif );       /* Parse batch IF           command     */\nBATCHPARSER (NNMbpels);       /* Parse batch ELSE         command     */\nBATCHPARSER (NNMbpque);       /* Parse batch QUERY        command     */\nBATCHPARSER (NNMbpreg);       /* Parse batch REGISTER     command     */\nBATCHPARSER (NNMbpder);       /* Parse batch DEREGISTER   command     */\nBATCHPARSER (NNMbpset);       /* Parse batch SET          command     */\nBATCHPARSER (NNMbpput);       /* Parse batch PUT          command     */\nBATCHPARSER (NNMbpexe);       /* Parse batch EXEC         command     */\nBATCHPARSER (NNMbpqui);       /* Parse batch QUIT         command     */\nBATCHPARSER (NNMbpnnt);       /* Parse batch NNTP         command     */\nBATCHPARSER (NNMbplis);       /* Parse batch LIST         command     */\nBATCHPARSER (NNMbpmar);       /* Parse batch MARK         command     */\nBATCHPARSER (NNMbpext);       /* Parse batch EXTRACT      command     */\nBATCHPARSER (NNMbpvar);       /* Parse batch VARS         command     */\nBATCHPARSER (NNMbpdec);       /* Parse batch DECLARE      command     */\n\n/****** Get command. *************************************************/\n\nCommandParser\nNNMbgcmd(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n char               *cp;\n struct token       *tp;\n CommandParser       cproc;\n Bool                command_not_gotten = FALSE;\n Bool                assumed_set        = FALSE;\n\n for (;;) {\n\n   bp->stop_at_newline = FALSE;  /* read lines until token found */\n\n   if (!(tp = PEEK())) {                          /* peek token */\n      command_not_gotten = TRUE;\n   }\n   else switch (tp->type) {\n     case EOF_TOKEN:\n            EAT();\n            return FALSE; /* OK, no more commands to process */\n     case WORD_TOKEN:\n            break;        /* good, what a command should look like */\n     case EOL_TOKEN:\n     case SEMI_TOKEN:\n            EAT();\n            continue;     /* keep looping */\n     case STRING_TOKEN:\n            EAT();\n            NNMbsynt(np,bp,NULL,0,\n                     \"Quoted string where command name expected\");\n            command_not_gotten = TRUE;\n            break;\n     default:\n            EAT();\n            NNMbsynt(np,bp,tp->string,0,\n                     \"Invalid token where command name expected\");\n            command_not_gotten = TRUE;\n            break;\n   }\n   break; /* continue only when ';' found */\n }\n\n /* Determine what the command is.  If the command is not recognized,\n  * but it is the name of a declared variable, then assume it is SET\n  * and don't eat the token - let SET see it.\n  */\n\n if (!command_not_gotten) {\n  cp = tp->string;\n  if      (EQUAL(cp,\"HELP\"        )) cproc = NNMbphel;\n  else if (EQUAL(cp,\"FOR\"         )) cproc = NNMbpfor;\n  else if (EQUAL(cp,\"IF\"          )) cproc = NNMbpif ;\n  else if (EQUAL(cp,\"ELSE\"        )) cproc = NNMbpels;\n  else if (EQUAL(cp,\"QUERY\"       )) cproc = NNMbpque;\n  else if (EQUAL(cp,\"REGISTER\"    )) cproc = NNMbpreg;\n  else if (EQUAL(cp,\"DEREGISTER\"  )) cproc = NNMbpder;\n  else if (EQUAL(cp,\"SET\"         )) cproc = NNMbpset;\n  else if (EQUAL(cp,\"PUT\"         )) cproc = NNMbpput;\n  else if (EQUAL(cp,\"EXEC\"        )) cproc = NNMbpexe;\n  else if (EQUAL(cp,\"QUIT\"        )) cproc = NNMbpqui;\n  else if (EQUAL(cp,\"NNTP\"        )) cproc = NNMbpnnt;\n  else if (EQUAL(cp,\"LIST\"        )) cproc = NNMbplis;\n  else if (EQUAL(cp,\"MARK\"        )) cproc = NNMbpmar;\n  else if (EQUAL(cp,\"EXTRACT\"     )) cproc = NNMbpext;\n  else if (EQUAL(cp,\"VARS\"        )) cproc = NNMbpvar;\n  else if (EQUAL(cp,\"DECLARE\"     )) cproc = NNMbpdec;\n  else if (EQUAL(cp,\"END\"         )) cproc = bp->endproc;\n\n  else if (NNMbvget(np,bp,cp,NO_SYMTYPE)) { /* if declared var name */\n    assumed_set = TRUE;\n    cproc = NNMbpset;\n  }\n  else {\n    NNMbsynt(np,bp,cp,0, \"Command or variable name unknown\");\n    command_not_gotten = TRUE;\n  }\n }\n\n if (!(EQUAL(cp,\"ELSE\"))) bp->ifcmd = NULL; /*Disallow unmatched ELSE*/\n\n if (!assumed_set) EAT();  /* Swallow the command name if 'twas real */\n\n if (command_not_gotten) {\n   fprintf(np->batch_outfile, \"Rest of input line ignored.\\n\");\n   NNMbflus(np,bp);       /* Flush rest of tokens on input line */\n   return FALSE;\n }\n\n return cproc;\n\n}\n\n./ ADD NAME=NNMBGDO\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BGDO \")\n#pragma  csect(static,\"NN$BGDO \")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n#define MAGIC_END_COOKIE    (void *)(1)\n\n/****** Handle END command. ******************************************/\n\nstatic struct newscmd *\nhandle_end(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n\n NNMbflus(np,bp);  /* flush all tokens following END */\n\n return MAGIC_END_COOKIE;\n}\n\n/****** Get commands, parse them and add to command tree. ************/\n\nstatic struct cmdtree *\nget_multiple_commands(np,bp,mode)\nRstruc nncb         *np;\nRstruc batch        *bp;\nenum batchmode       mode;\n{\n Rstruc newscmd     *cmdp        = NULL;\n struct cmdtree     *treep       = NULL;\n struct cmdtree     *treetop     = NULL;\n struct cmdtree     *treebottom  = NULL;\n CommandParser       proc;\n CommandParser       save_endproc;\n enum batchmode      save_mode;\n Bool                bad_command = FALSE;\n Bool                end_found   = FALSE;\n\n save_mode    = bp->mode;\n bp->mode     = mode;\n\n save_endproc = bp->endproc;\n bp->endproc  = handle_end;\n\n while (!bp->eof) {\n\n   proc = NNMbgcmd(np,bp);   /* Get next command */\n   if (!proc) {              /* If invalid command, continue */\n     bad_command = TRUE;\n     continue;\n   }\n\n   cmdp = (proc)(np,bp);     /* Parse it returning command tree */\n   if (!cmdp) {              /* If syntax error, continue */\n     bad_command = TRUE;\n     continue;\n   }\n\n   if (cmdp == MAGIC_END_COOKIE) {  /* if END seen */\n     end_found = TRUE;\n     break;\n   }\n\n   /* If a newscmd structure was returned, add it to the cmd tree. */\n\n   GETMAIN(treep, struct cmdtree, 1, \"DO command tree\");\n   if (!treep) {\n     bp->input_errors++;\n     bad_command = TRUE;\n     continue;\n   }\n\n   treep->next = NULL;\n   treep->cmd  = cmdp;\n\n   if (treebottom == NULL) treetop = treep;\n   else                    treebottom->next = treep;\n   treebottom = treep;\n\n }\n\n bp->endproc = save_endproc;\n bp->mode    = save_mode;\n\n if (!end_found) {\n   NNMbsynt(np,bp,NULL,0,\"No END found to match DO\");\n }\n\n return treetop;\n}\n\n/****** Get a single command, parse it and make command tree. ********/\n\nstatic struct cmdtree *\nget_single_command(np,bp,mode)\nRstruc nncb         *np;\nRstruc batch        *bp;\nenum batchmode       mode;\n{\n Rstruc newscmd     *cmdp        = NULL;\n struct cmdtree     *treep       = NULL;\n struct token       *tp;\n CommandParser       proc;\n enum batchmode      save_mode;\n\n save_mode    = bp->mode;\n bp->mode     = mode;\n\n if (!(tp = PEEK())) return NULL;\n\n /* Handle null command (e.g. IF x THEN; ELSE; ) */\n\n if (tp->type == SEMI_TOKEN) return NULL;\n\n proc = NNMbgcmd(np,bp);   /* Get next command */\n if (!proc) return NULL;   /* If invalid command, error */\n\n cmdp = (proc)(np,bp);     /* Parse it returning command tree */\n if (!cmdp) return NULL;   /* If syntax error, error */\n\n bp->mode = save_mode;\n\n /* If a newscmd structure was returned, add it to the cmd tree. */\n\n GETMAIN(treep, struct cmdtree, 1, \"DO command tree\");\n if (!treep) {\n   bp->input_errors++;\n   return NULL;\n }\n\n treep->next = NULL;\n treep->cmd  = cmdp;\n\n return treep;\n}\n\n/****** Get keyword. *************************************************/\n\nstatic Bool\nget_keyword(np,bp,key)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nchar                        *key;\n{\n struct token               *tp;\n\n if ((tp = PEEK()) && tp->type == WORD_TOKEN && EQUAL(tp->string,key)) {\n   EAT();\n   return TRUE;\n }\n\n else return FALSE;\n\n}\n\n/****** Get a DO-END command group. **********************************/\n\nstruct cmdtree *\nNNMbgdo(np,bp,mode)\nRstruc nncb         *np;\nRstruc batch        *bp;\nenum batchmode       mode;\n{\n\n /* Look for DO (required).  When found, get commands until END seen.*/\n\n if (get_keyword(np,bp,\"DO\")) {\n   NNMbtras(np,bp,\"DO\");\n   return get_multiple_commands(np,bp,mode);\n }\n else return get_single_command(np,bp,mode);\n\n}\n\n./ ADD NAME=NNMBGEXP\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BGEXP\")\n#pragma  csect(static,\"NN$BGEXP\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\nstatic Exp              get_exp();\nstatic Choice           get_choice();\nstatic Relation         get_relation();\nstatic Value            get_value();\nstatic Quantity         get_quantity();\nstatic Term             get_term();\nstatic Factor           get_factor();\nstatic Unop             get_unop();\nstatic Addop            get_addop();\nstatic Mulop            get_mulop();\nstatic Logop            get_logop();\nstatic Relop            get_relop();\nstatic Constant         get_constant();\nstatic Variable         get_variable();\nstatic Number           get_number();\nstatic String           get_string();\nstatic Flag             get_flag();\n\nstatic Exp              make_exp();\nstatic Choice           make_choice();\nstatic Relation         make_relation();\nstatic Value            make_value();\nstatic Quantity         make_quantity();\nstatic Term             make_term();\nstatic Factor           make_factor();\nstatic Unop             make_unop();\nstatic Addop            make_addop();\nstatic Mulop            make_mulop();\nstatic Logop            make_logop();\nstatic Relop            make_relop();\nstatic Constant         make_constant();\nstatic Variable         make_variable();\nstatic Number           make_number();\nstatic String           make_string();\nstatic Flag             make_flag();\n\n/*-------------------------------------------------------------------*/\n\nstatic Bool\nis_reserved(bp,var)\nRstruc batch    *bp;\nchar            *var;\n{\n char          *cp;\n int            varlen = strlen(var);\n char           vartest\u00ddMAX_RESERVED_WORD_LENGTH\u00a8;\n\n if (varlen >= MIN_RESERVED_WORD_LENGTH\n  && varlen <= MAX_RESERVED_WORD_LENGTH) {\n\n   memset(vartest,' ',MAX_RESERVED_WORD_LENGTH);\n   memcpy(vartest,var,varlen);\n\n   for (cp = bp->reserved_words; *cp != ' '; cp += 10) {\n     if (memcmp(vartest,cp,MAX_RESERVED_WORD_LENGTH) == 0) {\n       return TRUE;\n     }\n   }\n }\n return FALSE;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Flag\nmake_flag(np,bp,type,v)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum symtype     type;\nFool             v;\n{\n Flag            p;\n\n ALLOC(p,flag);\n p->s     = type;\n p->flag1 = v;\n return p;\n\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic String\nmake_string(np,bp,type,v)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum symtype     type;\nchar            *v;\n{\n String          p;\n\n ALLOC(p,string);\n p->s       = type;\n p->string1 = NNMcopy(np,v);\n return p;\n\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Number\nmake_number(np,bp,type,v)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum symtype     type;\nint              v;\n{\n Number          p;\n\n ALLOC(p,number);\n p->s       = type;\n p->number1 = v;\n return p;\n\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Variable\nmake_variable(np,bp,type,v)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum symtype     type;\nchar            *v;\n{\n Variable        p;\n\n ALLOC(p,variable);\n p->s         = type;\n p->variable1 = NNMcopy(np,v);\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Relop\nmake_relop(np,bp,t)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum optype      t;\n{\n Relop           p;\n\n ALLOC(p,relop);\n p->op1 = t;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Logop\nmake_logop(np,bp,t)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum optype      t;\n{\n Logop           p;\n\n ALLOC(p,logop);\n p->op1 = t;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Mulop\nmake_mulop(np,bp,t)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum optype      t;\n{\n Mulop           p;\n\n ALLOC(p,mulop);\n p->op1 = t;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Addop\nmake_addop(np,bp,t)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum optype      t;\n{\n Addop           p;\n\n ALLOC(p,addop);\n p->op1 = t;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Unop\nmake_unop(np,bp,t)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum optype      t;\n{\n Unop            p;\n\n ALLOC(p,unop);\n p->op1 = t;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Constant\nmake_constant_a(np,bp,type,p1)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum symtype     type;\nNumber           p1;\n{\n Constant        p;\n\n ALLOC(p,constant);\n p->r           = RHSTYPE_A;\n p->s           = type;\n p->u.a.number1 = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Constant\nmake_constant_b(np,bp,type,p1)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum symtype     type;\nString           p1;\n{\n Constant        p;\n\n ALLOC(p,constant);\n p->r           = RHSTYPE_B;\n p->s           = type;\n p->u.b.string1 = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Constant\nmake_constant_c(np,bp,type,p1)\nRstruc nncb     *np;\nRstruc batch    *bp;\nenum symtype     type;\nFlag             p1;\n{\n Constant        p;\n\n ALLOC(p,constant);\n p->r         = RHSTYPE_C;\n p->s         = type;\n p->u.c.flag1 = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Factor\nmake_factor_a(np,bp,type,p1)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nConstant        p1;\n{\n Factor         p;\n\n ALLOC(p,factor);\n p->r             = RHSTYPE_A;\n p->s             = type;\n p->u.a.constant1 = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Factor\nmake_factor_b(np,bp,type,p1)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nVariable        p1;\n{\n Factor         p;\n\n ALLOC(p,factor);\n p->r             = RHSTYPE_B;\n p->s             = type;\n p->u.b.variable1 = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Factor\nmake_factor_c(np,bp,type,p1,p2)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nUnop            p1;\nFactor          p2;\n{\n Factor         p;\n\n ALLOC(p,factor);\n p->r             = RHSTYPE_C;\n p->s             = type;\n p->u.c.unop1     = p1;\n p->u.c.factor2   = p2;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Factor\nmake_factor_d(np,bp,type,p1)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nExp             p1;\n{\n Factor         p;\n\n ALLOC(p,factor);\n p->r        = RHSTYPE_D;\n p->s        = type;\n p->u.d.exp1 = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Term\nmake_term_a(np,bp,type,p1)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nFactor          p1;\n{\n Term           p;\n\n ALLOC(p,term);\n p->r           = RHSTYPE_A;\n p->s           = type;\n p->u.a.factor1 = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Term\nmake_term_b(np,bp,type,p1,p2,p3)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nTerm            p1;\nMulop           p2;\nFactor          p3;\n{\n Term           p;\n\n ALLOC(p,term);\n p->r           = RHSTYPE_B;\n p->s           = type;\n p->u.b.term1   = p1;\n p->u.b.mulop2  = p2;\n p->u.b.factor3 = p3;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Quantity\nmake_quantity_a(np,bp,type,p1)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nTerm            p1;\n{\n Quantity       p;\n\n ALLOC(p,quantity);\n p->r           = RHSTYPE_A;\n p->s           = type;\n p->u.a.term1   = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Quantity\nmake_quantity_b(np,bp,type,p1,p2,p3)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nQuantity        p1;\nAddop           p2;\nTerm            p3;\n{\n Quantity       p;\n\n ALLOC(p,quantity);\n p->r             = RHSTYPE_B;\n p->s             = type;\n p->u.b.quantity1 = p1;\n p->u.b.addop2    = p2;\n p->u.b.term3     = p3;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Value\nmake_value_a(np,bp,type,p1)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nQuantity        p1;\n{\n Value           p;\n\n ALLOC(p,value);\n p->r             = RHSTYPE_A;\n p->s             = type;\n p->u.a.quantity1 = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Value\nmake_value_b(np,bp,type,p1,p2)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nValue           p1;\nQuantity        p2;\n{\n Value          p;\n\n ALLOC(p,value);\n p->r             = RHSTYPE_B;\n p->s             = type;\n p->u.b.value1    = p1;\n p->u.b.quantity2 = p2;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Relation\nmake_relation_a(np,bp,type,p1)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nValue           p1;\n{\n Relation       p;\n\n ALLOC(p,relation);\n p->r           = RHSTYPE_A;\n p->s           = type;\n p->u.a.value1  = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Relation\nmake_relation_b(np,bp,type,p1,p2,p3)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nValue           p1;\nRelop           p2;\nValue           p3;\n{\n Relation       p;\n\n ALLOC(p,relation);\n p->r             = RHSTYPE_B;\n p->s             = type;\n p->u.b.value1    = p1;\n p->u.b.relop2    = p2;\n p->u.b.value3    = p3;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Choice\nmake_choice_a(np,bp,type,p1)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nRelation        p1;\n{\n Choice         p;\n\n ALLOC(p,choice);\n p->r             = RHSTYPE_A;\n p->s             = type;\n p->u.a.relation1 = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Choice\nmake_choice_b(np,bp,type,p1,p2,p3)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nChoice          p1;\nLogop           p2;\nRelation        p3;\n{\n Choice         p;\n\n ALLOC(p,choice);\n p->r             = RHSTYPE_B;\n p->s             = type;\n p->u.b.choice1   = p1;\n p->u.b.logop2    = p2;\n p->u.b.relation3 = p3;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Exp\nmake_exp_a(np,bp,type,p1)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nChoice          p1;\n{\n Exp            p;\n\n ALLOC(p,exp);\n p->r           = RHSTYPE_A;\n p->s           = type;\n p->u.a.choice1 = p1;\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Exp\nmake_exp_b(np,bp,type,p1,p2,p3)\nRstruc nncb    *np;\nRstruc batch    *bp;\nenum symtype    type;\nExp             p1;\nExp             p2;\nExp             p3;\n{\n Exp            p;\n\n ALLOC(p,exp);\n p->r        = RHSTYPE_B;\n p->s        = type;\n p->u.b.exp1 = p1;\n p->u.b.exp2 = p2;\n p->u.b.exp3 = p3;\n return p;\n}\n\n/*===================================================================*/\n\nstatic Flag\nget_flag(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct token       *tp;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case WORD_TOKEN:\n     if (EQUAL(tp->string,\"FALSE\") ||\n         EQUAL(tp->string,\"NO\"   ) ||\n         EQUAL(tp->string,\"OFF\"  )) {\n       EAT();\n       return make_flag(np,bp,FLAG_SYMTYPE,FALSE);\n     }\n     else\n     if (EQUAL(tp->string,\"TRUE\" ) ||\n         EQUAL(tp->string,\"YES\"  ) ||\n         EQUAL(tp->string,\"ON\"   )) {\n       EAT();\n       return make_flag(np,bp,FLAG_SYMTYPE,TRUE);\n     }\n   default:        return NULL;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic String\nget_string(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct token       *tp;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case STRING_TOKEN:\n            EAT();\n            return make_string(np,bp,STRING_SYMTYPE,tp->string);\n   default: return NULL;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Number\nget_number(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct token       *tp;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case NUMBER_TOKEN:\n            EAT();\n            return make_number(np,bp,NUMBER_SYMTYPE,tp->number);\n   default: return NULL;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Variable\nget_variable(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct token       *tp;\n enum symtype        type;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case WORD_TOKEN:\n            if (is_reserved(bp,tp->string)) return NULL;\n            EAT();\n            type = (enum symtype)NNMbvget(np,bp,tp->string,NO_SYMTYPE);\n            if (type == NO_SYMTYPE) ERR(\"variable not declared\");\n            return make_variable(np,bp,type,tp->string);\n   default: return NULL;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Constant\nget_constant(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n Number              a1;\n String              b1;\n Flag                c1;\n\n if ((a1 = get_number(np,bp)))\n    return make_constant_a(np,bp,NUMBER_SYMTYPE,a1);\n if ((b1 = get_string(np,bp)))\n    return make_constant_b(np,bp,STRING_SYMTYPE,b1);\n if ((c1 = get_flag(np,bp)))\n    return make_constant_c(np,bp,FLAG_SYMTYPE,c1);\n return NULL;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Addop\nget_addop(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct token       *tp;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case PLUS_TOKEN:  EAT(); return make_addop(np,bp,ADD_OP);\n   case MINUS_TOKEN: EAT(); return make_addop(np,bp,SUB_OP);\n   default:          return NULL;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Mulop\nget_mulop(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct token       *tp;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case TIMES_TOKEN:  EAT(); return make_mulop(np,bp,MUL_OP);\n   case OVER_TOKEN:   EAT(); return make_mulop(np,bp,DIV_OP);\n   default:           return NULL;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Logop\nget_logop(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct token       *tp;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case AND_TOKEN:  EAT(); return make_logop(np,bp,AND_OP);\n   case OR_TOKEN:   EAT(); return make_logop(np,bp,OR_OP);\n   case WORD_TOKEN:\n     if (EQUAL(tp->string,\"AND\")) {\n       EAT();\n       return make_logop(np,bp,AND_OP);\n     }\n     if (EQUAL(tp->string,\"OR\"))  {\n       EAT();\n       return make_logop(np,bp,OR_OP);\n     }\n     return NULL;\n   default:             return NULL;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Relop\nget_relop(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct token       *tp;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case EQ_TOKEN:  EAT(); return make_relop(np,bp,EQ_OP);\n   case NE_TOKEN:  EAT(); return make_relop(np,bp,NE_OP);\n   case GT_TOKEN:  EAT(); return make_relop(np,bp,GT_OP);\n   case LT_TOKEN:  EAT(); return make_relop(np,bp,LT_OP);\n   case GE_TOKEN:  EAT(); return make_relop(np,bp,GE_OP);\n   case LE_TOKEN:  EAT(); return make_relop(np,bp,LE_OP);\n   case WORD_TOKEN:\n     if (EQUAL(tp->string,\"IN\")) {EAT();\n                                  return make_relop(np,bp,IN_OP);}\n     if (EQUAL(tp->string,\"EQ\")) {EAT();\n                                  return make_relop(np,bp,EQ_OP);}\n     if (EQUAL(tp->string,\"NE\")) {EAT();\n                                  return make_relop(np,bp,NE_OP);}\n     if (EQUAL(tp->string,\"GT\")) {EAT();\n                                  return make_relop(np,bp,GT_OP);}\n     if (EQUAL(tp->string,\"LT\")) {EAT();\n                                  return make_relop(np,bp,LT_OP);}\n     if (EQUAL(tp->string,\"GE\")) {EAT();\n                                  return make_relop(np,bp,GE_OP);}\n     if (EQUAL(tp->string,\"LE\")) {EAT();\n                                  return make_relop(np,bp,LE_OP);}\n     return NULL;\n   default:       return NULL;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Unop\nget_unop(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct token       *tp;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case MINUS_TOKEN: EAT(); return make_unop(np,bp,SUB_OP);\n   case PLUS_TOKEN:  EAT(); return make_unop(np,bp,ADD_OP);\n   case NOT_TOKEN:   EAT(); return make_unop(np,bp,NOT_OP);\n   case WORD_TOKEN:\n     if (EQUAL(tp->string,\"NOT\")) {EAT();\n                                   return make_unop(np,bp,NOT_OP);}\n     return NULL;\n   default:          return NULL;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Bool\nget_word(np,bp,word)\nRstruc nncb         *np;\nRstruc batch        *bp;\nchar                *word;\n{\n struct token       *tp;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case WORD_TOKEN:\n                    if (EQUAL(tp->string,word)) {EAT(); return TRUE;}\n                    else return FALSE;\n   default:         return FALSE;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Bool\nget_lpar(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct token       *tp;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case LPAR_TOKEN: EAT(); return TRUE;\n   default: return FALSE;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Bool\nget_rpar(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct token       *tp;\n\n if (!(tp = PEEK())) LOSE;\n switch (tp->type) {\n   case RPAR_TOKEN: EAT(); return TRUE;\n   default: return FALSE;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Factor\nget_factor(np,bp)\nRstruc nncb     *np;\nRstruc batch    *bp;\n{\n Constant        a1;\n Variable        b1;\n Unop            c1;\n Factor          c2;\n Exp             d1;\n enum symtype    type;\n enum symtype    type2;\n\n /* a:  factor -> constant */\n\n if (a1 = get_constant(np,bp)) {\n   type = a1->s;\n   return make_factor_a(np,bp,type,a1);\n }\n\n /* b:  factor -> variable */\n\n if ((b1 = get_variable(np,bp))) {\n   type = b1->s;\n   return make_factor_b(np,bp,type,b1);\n }\n\n /* c:  factor -> unop factor */\n\n if ((c1 = get_unop(np,bp))) {\n   if (!(c2 = get_factor(np,bp))) ERR(\"expecting factor\");\n   type2 = c2->s;\n   switch (c1->op1) {\n     case SUB_OP:\n          if (type2 != NUMBER_SYMTYPE) ERR(\"not number expression\");\n          type = NUMBER_SYMTYPE;\n          break;\n     case ADD_OP:\n          if (type2 != NUMBER_SYMTYPE) ERR(\"not number expression\");\n          type = NUMBER_SYMTYPE;\n          break;\n     case NOT_OP:\n          if (type2 != FLAG_SYMTYPE)   ERR(\"not flag expression\");\n          type = FLAG_SYMTYPE;\n          break;\n   }\n   return make_factor_c(np,bp,type2,c1,c2);\n }\n\n /* d:  factor -> \"(\" exp \")\" */\n\n if (get_lpar(np,bp)) {\n   if (!(d1 = get_exp(np,bp))) ERR(\"expecting numeric expression\");\n   if (!get_rpar(np,bp))       ERR(\"expecting right parenthesis\");\n   type = d1->s;\n   return make_factor_d(np,bp,type,d1);\n }\n\n return NULL;\n\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Term\nget_term(np,bp)\nRstruc nncb     *np;\nRstruc batch    *bp;\n{\n Term            p;\n Factor          a1;\n Mulop           b2;\n Factor          b3;\n enum symtype    type;\n enum symtype    type1;\n enum symtype    type3;\n\n /* a:  term -> factor */\n\n if (!(a1 = get_factor(np,bp))) return NULL;\n\n type = a1->s;\n p = make_term_a(np,bp,type,a1);\n\n /* b:  term -> term mulop factor */\n\n for (;;) {\n\n   if (!(b2 = get_mulop(np,bp))) break;\n   if (!(b3 = get_factor(np,bp))) ERR(\"expecting numeric factor\");\n   type1 = p->s;\n   type3 = b3->s;\n   if (type1!=NUMBER_SYMTYPE) ERR(\"operand 1 not number expression\");\n   if (type3!=NUMBER_SYMTYPE) ERR(\"operand 2 not number expression\");\n   type = NUMBER_SYMTYPE;\n   p = make_term_b(np,bp,type,p,b2,b3);\n }\n\n return p;\n\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Quantity\nget_quantity(np,bp)\nRstruc nncb     *np;\nRstruc batch    *bp;\n{\n Quantity        p;\n Term            a1;\n Addop           b2;\n Term            b3;\n enum symtype    type;\n enum symtype    type1;\n enum symtype    type3;\n\n /* a:  quantity -> term */\n\n if (!(a1 = get_term(np,bp))) return NULL;\n\n type = a1->s;\n p = make_quantity_a(np,bp,type,a1);\n\n /* b:  quantity -> quantity addop term */\n\n for (;;) {\n\n   if (!(b2 = get_addop(np,bp))) break;\n   if (!(b3 = get_term(np,bp))) ERR(\"expecting numeric term\");\n   type1 = p->s;\n   type3 = b3->s;\n   if (type1!=NUMBER_SYMTYPE) ERR(\"operand 1 not number expression\");\n   if (type3!=NUMBER_SYMTYPE) ERR(\"operand 2 not number expression\");\n   type = NUMBER_SYMTYPE;\n   p = make_quantity_b(np,bp,type,p,b2,b3);\n }\n\n return p;\n\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Value\nget_value(np,bp)\nRstruc nncb     *np;\nRstruc batch    *bp;\n{\n Value           p;\n Quantity        a1;\n Quantity        b2;\n enum symtype    type;\n enum symtype    type1;\n enum symtype    type2;\n\n /* a:  value -> quantity */\n\n if (!(a1 = get_quantity(np,bp))) return NULL;\n\n type = a1->s;\n p = make_value_a(np,bp,type,a1);\n\n /* b:  value -> value quantity */\n\n for (;;) {\n\n   if (!(b2 = get_quantity(np,bp))) break;\n   type1 = p->s;\n   type2 = p->s;\n   type = STRING_SYMTYPE;\n   p = make_value_b(np,bp,type,p,b2);\n }\n\n return p;\n\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Relation\nget_relation(np,bp)\nRstruc nncb     *np;\nRstruc batch    *bp;\n{\n Relation        p;\n Value           a1;\n Relop           b2;\n Value           b3;\n enum symtype    type;\n enum symtype    type1;\n enum symtype    type3;\n\n /* a:  relation -> value */\n\n if (!(a1 = get_value(np,bp))) return NULL;\n\n type = a1->s;\n p = make_relation_a(np,bp,type,a1);\n\n /* b:  relation -> value relop value */\n\n if (!(b2 = get_relop(np,bp))) return p;\n if (!(b3 = get_value(np,bp)))\n    ERR(\"expecting string or numeric value\");\n type1 = a1->s;\n type3 = b3->s;\n switch (b2->op1) {\n   case IN_OP:\n     if (type1 != STRING_SYMTYPE)\n        ERR(\"operand 1 not string expression\");\n     if (type3 != STRING_SYMTYPE)\n        ERR(\"operand 3 not string expression\");\n     break;\n   case EQ_OP:\n   case NE_OP:\n     if (!((type1 == NUMBER_SYMTYPE && type3 == NUMBER_SYMTYPE)\n        || (type1 == STRING_SYMTYPE && type3 == STRING_SYMTYPE)\n        || (type1 == FLAG_SYMTYPE   && type3 == FLAG_SYMTYPE)))\n      ERR(\"operands are not both of the same type\");\n     break;\n   default:\n     if (!((type1 == NUMBER_SYMTYPE && type3 == NUMBER_SYMTYPE)\n        || (type1 == STRING_SYMTYPE && type3 == STRING_SYMTYPE)))\n      ERR(\"operands are not both numeric or both string expressions\");\n     break;\n }\n type = FLAG_SYMTYPE;\n p = make_relation_b(np,bp,type,a1,b2,b3);\n\n return p;\n\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Choice\nget_choice(np,bp)\nRstruc nncb     *np;\nRstruc batch    *bp;\n{\n Choice          p;\n Relation        a1;\n Logop           b2;\n Relation        b3;\n enum symtype    type;\n enum symtype    type1;\n enum symtype    type3;\n\n /* a:  choice -> relation */\n\n if (!(a1 = get_relation(np,bp))) return NULL;\n\n type = a1->s;\n p = make_choice_a(np,bp,type,a1);\n\n /* b:  choice -> choice logop relation */\n\n for (;;) {\n\n   if (!(b2 = get_logop(np,bp))) break;\n   if (!(b3 = get_relation(np,bp)))\n      ERR(\"expecting logical expression\");\n   type1 = p->s;\n   type3 = b3->s;\n   if (type1 != FLAG_SYMTYPE) ERR(\"operand 1 not logical expression\");\n   if (type3 != FLAG_SYMTYPE) ERR(\"operand 2 not logical expression\");\n   type = FLAG_SYMTYPE;\n   p = make_choice_b(np,bp,type,p,b2,b3);\n }\n\n return p;\n\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Exp\nget_exp(np,bp)\nRstruc nncb     *np;\nRstruc batch    *bp;\n{\n Choice          a1;\n Exp             b1;\n Exp             b2;\n Exp             b3;\n enum symtype    type;\n enum symtype    type1;\n enum symtype    type2;\n enum symtype    type3;\n\n /* b:  exp -> \"IF\" exp \"THEN\" exp \"ELSE\" exp */\n\n if (get_word(np,bp,\"IF\")) {\n   if (!(b1 = get_exp(np,bp)))    ERR(\"expecting expression\");\n   if (!(get_word(np,bp,\"THEN\"))) ERR(\"expecting THEN\");\n   if (!(b2 = get_exp(np,bp)))    ERR(\"expecting expression\");\n   if (!(get_word(np,bp,\"ELSE\"))) ERR(\"expecting ELSE\");\n   if (!(b3 = get_exp(np,bp)))    ERR(\"expecting expression\");\n   type1 = b1->s;\n   type2 = b2->s;\n   type3 = b3->s;\n   if (type1 != FLAG_SYMTYPE) ERR(\"operand 1 not logical expression\");\n   type = type2;\n   return make_exp_b(np,bp,type,b1,b2,b3);\n }\n\n /* a:  exp -> choice */\n\n if (!(a1 = get_choice(np,bp))) ERR(\"expecting IF or expression\");\n type = a1->s;\n return make_exp_a(np,bp,type,a1);\n\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Exp\nget_strtree(np,bp)\nRstruc nncb     *np;\nRstruc batch    *bp;\n{\n Exp             p;\n\n p = get_exp(np,bp);\n if (!p) {\n  NNMbsynt(np,bp,NULL,0,\"no expression found\");\n  return NULL;\n }\n\n return p;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Exp\nget_numtree(np,bp)\nRstruc nncb     *np;\nRstruc batch    *bp;\n{\n Exp             p;\n\n p = get_exp(np,bp);\n if (!p) {\n   NNMbsynt(np,bp,NULL,0,\"no expression found\");\n   return NULL;\n }\n switch (p->s) {\n   case STRING_SYMTYPE:\n        NNMbsynt(np,bp,NULL,0,\"numeric expression required\");\n        return NULL;\n   case NUMBER_SYMTYPE:\n   case FLAG_SYMTYPE:\n   default:             return p;\n }\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic Exp\nget_flagtree(np,bp)\nRstruc nncb     *np;\nRstruc batch    *bp;\n{\n Exp             p;\n\n p = get_exp(np,bp);\n if (!p) {\n   NNMbsynt(np,bp,NULL,0,\"no expression found\");\n   return NULL;\n }\n switch (p->s) {\n   case FLAG_SYMTYPE:  return p;\n   default:\n            NNMbsynt(np,bp,NULL,0,\"logical expression required\");\n            return NULL;\n }\n}\n\n/****** Get expression and build an expression tree. *****************/\n\nstruct ptree *\nNNMbgexp(np,bp,type)\nRstruc nncb         *np;\nRstruc batch        *bp;\nenum symtype         type;\n{\n struct ptree       *treep      = NULL;\n\n /* Define return point for syntax errors during parse. */\n\n switch (setjmp(bp->jump)) {\n   case ERROR_NONE:\n        break;\n   case ERROR_GETMAIN_FAILURE:\n        NNMbsynt(np,bp,NULL,0,\"Not enough memory to parse expression\");\n        return NULL;\n   default:\n        bp->syntax_error = TRUE;\n        return NULL;\n }\n\n switch (type) {\n   case STRING_SYMTYPE:\n                        GETMAIN(treep,struct ptree,1,\"string ptree\");\n                        if (treep) {\n                          treep->type = STRING_TREETYPE;\n                          treep->exp1 = get_strtree(np,bp);\n                        }\n                        break;\n   case NUMBER_SYMTYPE:\n                        GETMAIN(treep,struct ptree,1,\"number ptree\");\n                        if (treep) {\n                          treep->type = NUMBER_TREETYPE;\n                          treep->exp1 = get_numtree(np,bp);\n                        }\n                        break;\n   case FLAG_SYMTYPE:\n                        GETMAIN(treep,struct ptree,1,\"flag ptree\");\n                        if (treep) {\n                          treep->type       = FLAG_TREETYPE;\n                          treep->exp1 = get_flagtree(np,bp);\n                        }\n                        break;\n   default: NNMbsynt(np,bp,NULL,0,\"Invalid type passed to NNMbgexp\");\n            return NULL;\n }\n\n if (!treep) {\n   NNMbsynt(np,bp,NULL,0,\"No storage available to build expression\");\n   return NULL;\n }\n\n return treep;\n}\n\n./ ADD NAME=NNMBGTOK\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BGTOK\")\n#pragma  csect(static,\"NN$BGTOK\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Get input line. **********************************************/\n\nstatic char *\nget_input_line(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n char               *cp;\n\n for (;;) {\n   cp = fgets(bp->inline, sizeof(bp->inline), np->batch_infile);\n   if (!cp) {\n     if (ferror(np->batch_infile)) {\n       fprintf(stderr,\"\\n*** Error reading batch input file ***\\n\");\n       abort();\n     }\n     bp->eof = TRUE;\n     return NULL;\n   }\n   else if ((cp=strchr(cp,'\\n'))) *cp = '\\0';\n\n   /* Hack to allow standard entry of EOF from the terminal. */\n\n   if (EQUAL(bp->inline,\"/*\")) {\n     fprintf(np->batch_outfile, \"EOF (/*) signalled in input.\\n\");\n     bp->eof = TRUE;\n     return NULL;\n   }\n   fprintf(np->batch_outfile, \"%s\\n\", bp->inline);\n   if (bp->inline\u00dd0\u00a8 != '#') break;\n }\n return bp->inline;\n}\n\n/****** Show token, for debugging only. ******************************/\n\nstatic char *\ntoken_description(tokp)\nstruct token     *tokp;\n{\n char            *c;\n\n switch (tokp->type) {\n                     case NO_TOKEN:       c = \"no token\"; break;\n                     case EOL_TOKEN:      c = \"EOL\";      break;\n                     case EOF_TOKEN:      c = \"EOF\";      break;\n                     case AND_TOKEN:      c = \"AND\";      break;\n                     case OR_TOKEN:       c = \"OR\";       break;\n                     case NOT_TOKEN:      c = \"NOT\";      break;\n                     case GT_TOKEN:       c = \"GT\";       break;\n                     case LT_TOKEN:       c = \"LT\";       break;\n                     case EQ_TOKEN:       c = \"EQ\";       break;\n                     case NE_TOKEN:       c = \"NE\";       break;\n                     case GE_TOKEN:       c = \"GE\";       break;\n                     case LE_TOKEN:       c = \"LE\";       break;\n                     case LPAR_TOKEN:     c = \"LPAR\";     break;\n                     case RPAR_TOKEN:     c = \"RPAR\";     break;\n                     case PLUS_TOKEN:     c = \"PLUS\";     break;\n                     case MINUS_TOKEN:    c = \"MINUS\";    break;\n                     case TIMES_TOKEN:    c = \"TIMES\";    break;\n                     case OVER_TOKEN:     c = \"OVER\";     break;\n                     case SEMI_TOKEN:     c = \"SEMI\";     break;\n                     case WORD_TOKEN:     c = \"WORD\";     break;\n                     case NUMBER_TOKEN:   c = \"NUMBER\";   break;\n                     case STRING_TOKEN:   c = \"STRING\";   break;\n                     case ERROR_TOKEN:    c = \"ERROR\";    break;\n                     default:             c = \"?\";        break;\n                }\n return c;\n}\n\n/****** Get token. ***************************************************/\n\nstatic Bool\nget_token(np,bp,tokp,flushing)\nRstruc nncb         *np;\nRstruc batch        *bp;\nstruct token        *tokp;\nFool                 flushing;\n{\n char               *cp;\n char               *dp;\n char               *ep;\n int                 len;\n Bool                inquote;\n Bool                badtoken;\n\n /* If reached end of current line, get a line */\n\n do {\n   while (*bp->inchar == '\\0') {\n     if (bp->stop_at_newline) {\n       tokp->type = EOL_TOKEN;\n       strcpy(tokp->string,\"<**End Of Line**>\");\n       return TRUE;\n     }\n     bp->inchar = get_input_line(np,bp);\n     if (bp->inchar == NULL) {\n       tokp->type = EOF_TOKEN;\n       strcpy(tokp->string,\"<**End Of File**>\");\n       return TRUE;\n     }\n   }\n   while (isspace(*bp->inchar)) bp->inchar++;\n   if (*bp->inchar == '#') *bp->inchar = '\\0';\n } while (*bp->inchar == '\\0');\n\n memset(tokp->string, 0, sizeof(tokp->string));\n tokp->number = 0;\n bp->syntax_error = FALSE;\n badtoken = FALSE;\n\n cp = bp->inchar;\n if (isdigit(*cp)) {\n   ep = cp + strspn(cp,\"0123456789\");\n   len = ep - cp;\n   bp->inchar = ep;\n   if (len > 10) {\n     badtoken = TRUE;\n     if (flushing) tokp->type = ERROR_TOKEN;\n     else NNMbsynt(np,bp,cp,len,\"Number too long\");\n   }\n   else {\n     tokp->type = NUMBER_TOKEN;\n     memcpy(tokp->string, cp, len);\n     tokp->number = atoi(tokp->string);\n   }\n }\n else if (isalpha(*cp)) {\n   dp = tokp->string;\n   ep = dp + sizeof(tokp->string) - 1;\n   while (isalnum(*cp)) {\n     if (dp > ep) {\n       if (!badtoken) {\n         badtoken = TRUE;\n         if (flushing) tokp->type = ERROR_TOKEN;\n         else NNMbsynt(np,bp,cp,ep-cp, \"Word too long\");\n       }\n     }\n     else {\n       *(dp++) = toupper(*(cp++));\n     }\n   }\n   *dp = '\\0';\n   bp->inchar = cp;\n   tokp->type = badtoken ? ERROR_TOKEN : WORD_TOKEN;\n }\n else if (*cp == '\"') {\n   bp->inchar++;\n   cp = bp->inchar;\n   dp = tokp->string;\n   ep = tokp->string + sizeof(tokp->string) - 1;\n   inquote = TRUE;\n   while (inquote) {\n     switch (*cp) {\n       case '\\0': NNMbsynt(np,bp,NULL,0,\"Missing end quote\");\n                  inquote = FALSE;\n                  bp->inchar = cp;\n                  break;\n       case '\"' : inquote = FALSE;\n                  bp->inchar = cp+1;\n                  break;\n       case '\\\\': cp++;\n                  /* fall through */\n       default  : if (dp > ep) {\n                    if (!badtoken) {\n                      badtoken = TRUE;\n                      if (flushing) tokp->type = ERROR_TOKEN;\n                      else\n                       NNMbsynt(np,bp,NULL,0,\"Quoted string too long\");\n                    }\n                  }\n                  else *(dp++) = *(cp++);\n                  break;\n     }\n   }\n   *dp = '\\0';\n   tokp->type = badtoken ? ERROR_TOKEN : STRING_TOKEN;\n }\n else {\n   switch (*cp) {\n     case ';': bp->inchar++; tokp->type = SEMI_TOKEN;  break;\n     case '(': bp->inchar++; tokp->type = LPAR_TOKEN;  break;\n     case ')': bp->inchar++; tokp->type = RPAR_TOKEN;  break;\n     case '+': bp->inchar++; tokp->type = PLUS_TOKEN;  break;\n     case '-': bp->inchar++; tokp->type = MINUS_TOKEN; break;\n     case '*': bp->inchar++; tokp->type = TIMES_TOKEN; break;\n     case '/': bp->inchar++; tokp->type = OVER_TOKEN;  break;\n     case '&': bp->inchar++; tokp->type = AND_TOKEN;   break;\n     case '|': bp->inchar++; tokp->type = OR_TOKEN;    break;\n     case '>': bp->inchar++;\n               switch (*bp->inchar) {\n                 case '=': bp->inchar++; tokp->type = GE_TOKEN; break;\n                 default:                tokp->type = GT_TOKEN; break;\n               }\n               break;\n     case '<': bp->inchar++;\n               switch (*bp->inchar) {\n                 case '=': bp->inchar++; tokp->type = LE_TOKEN; break;\n                 case '>': bp->inchar++; tokp->type = NE_TOKEN; break;\n                 default:                tokp->type = LT_TOKEN; break;\n               }\n               break;\n     case '=': bp->inchar++;\n               switch (*bp->inchar) {\n                 case '=': bp->inchar++; tokp->type = EQ_TOKEN; break;\n                 default:                tokp->type = EQ_TOKEN; break;\n               }\n               break;\n     case '\u00ac':\n     case '!': bp->inchar++;\n               switch (*bp->inchar) {\n                 case '=': bp->inchar++; tokp->type = NE_TOKEN; break;\n                 case '<': bp->inchar++; tokp->type = GT_TOKEN; break;\n                 case '>': bp->inchar++; tokp->type = LT_TOKEN; break;\n                 default:                tokp->type = NOT_TOKEN; break;\n               }\n               break;\n     default:  if (flushing) tokp->type = ERROR_TOKEN;\n               else NNMbsynt(np,bp,cp,1,\n                             \"Invalid character, cannot scan\");\n               bp->inchar++;\n               break;\n   }\n   memcpy(tokp->string, cp, bp->inchar - cp); /* just in case */\n }\n\n if (np->debug_file) {\n   fprintf(np->debug_file,\"token = %s\", token_description(tokp));\n   switch (tokp->type) {\n     case NUMBER_TOKEN:\n              fprintf(np->debug_file, \"(%d,'%s')\\n\",\n                                      tokp->number, tokp->string);\n              break;\n     case WORD_TOKEN:\n     case STRING_TOKEN:\n     default:\n              fprintf(np->debug_file, \"(%s)\\n\", tokp->string);\n              break;\n   }\n }\n\n return TRUE;\n\n}\n\n/****** Get token. ***************************************************/\n\nBool\nNNMbgtok(np,bp,func)\nRstruc nncb         *np;\nRstruc batch        *bp;\nenum tokenfunc       func;\n{\n\n if (!bp->tokens_read) {\n   bp->inchar = get_input_line(np,bp);\n   bp->tokens_read = TRUE;\n   if (bp->inchar == NULL) { /* no input at all? */\n     bp->curtok.type = EOF_TOKEN;\n     bp->nextok.type = EOF_TOKEN;\n     return TRUE;\n   }\n }\n if (bp->curtok.type == EOF_TOKEN) {\n   NNMbsynt(np,bp,NULL,0, \"Attempt to read token past end of file\");\n   return FALSE;\n }\n\n switch (func) {\n   case TOKEN_PEEK:\n                     if (bp->nextok.type == NO_TOKEN) {\n                       return get_token(np,bp,&bp->nextok,FALSE);\n                     }\n                     else { /* token already peeked at */\n                       return TRUE;\n                     }\n   case TOKEN_READ:\n                     if (bp->nextok.type == NO_TOKEN) {\n                       return get_token(np,bp,&bp->curtok,FALSE);\n                     }\n                     else { /* token already peeked at */\n                       memcpy((char *)&bp->curtok,\n                              (char *)&bp->nextok,\n                              sizeof(struct token));\n                       bp->nextok.type = NO_TOKEN;\n                       return TRUE;\n                     }\n   case TOKEN_FLUSH:\n                     if (bp->nextok.type == NO_TOKEN) {\n                       return get_token(np,bp,&bp->curtok,TRUE);\n                     }\n                     else { /* token already peeked at */\n                       memcpy((char *)&bp->curtok,\n                              (char *)&bp->nextok,\n                              sizeof(struct token));\n                       bp->nextok.type = NO_TOKEN;\n                       return TRUE;\n                     }\n }\n\n}\n\n./ ADD NAME=NNMBPDEC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: DECLARE\n *\n * Syntax:  DECLARE variablename {STRING | NUMBER | FLAG}\n *\n * Mode:    any\n *\n * Function: Declares a variable that can be referenced later.\n *           Its type is specified as well.  The type can be:\n *\n *           * STRING - character string\n *           * NUMBER - integer\n *           * FLAG   - 1 or 0, TRUE or FALSE, ON or OFF, YES or NO\n *\n * Note: This command is processed at parse time only.  It is not an\n *       executable command.  No matter where it appears in the input\n *       command environment, it will be processed.  The only caveat\n *       is that a variable must be referenced by DECLARE prior to\n *       any appearance of it in the input stream.\n *\n * Examples:  DECLARE FOO STRING\n *            DECLARE BAR NUMBER\n *            DECLARE BAZ FLAG\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPDEC\")\n#pragma  csect(static,\"NN$BPDEC\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Parse batch DECLARE      command. ****************************/\n\nstruct newscmd *\nNNMbpdec(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n char               *var;\n enum symtype        type;\n ANYTYPE             val;\n\n /* Next token must be variable name.  */\n\n (void)NNMbgtok(np,bp,TOKEN_READ);          /* get token */\n if (bp->curtok.type != WORD_TOKEN) {\n   NNMbsynt(np,bp,NULL,0, \"Expected DECLARE variable name not seen\");\n   NNMbflus(np,bp);                         /* flush input tokens */\n   return NULL;\n }\n\n var = NNMcopy(np,bp->curtok.string);\n\n /* Next token must be one of the words STRING, NUMBER or FLAG.  */\n\n (void)NNMbgtok(np,bp,TOKEN_READ);          /* get token */\n if (bp->curtok.type != WORD_TOKEN) {\n   NNMbsynt(np,bp,NULL,0, \"Expected DECLARE type name not seen\");\n   NNMbflus(np,bp);                         /* flush input tokens */\n   return NULL;\n }\n\n if      (EQUAL(bp->curtok.string,\"STRING\")) {\n   type = STRING_SYMTYPE;\n   val  = (ANYTYPE)\"\";\n }\n else if (EQUAL(bp->curtok.string,\"NUMBER\")) {\n   type = NUMBER_SYMTYPE;\n   val  = (ANYTYPE)0;\n }\n else if (EQUAL(bp->curtok.string,\"FLAG\")) {\n   type = FLAG_SYMTYPE;\n   val  = (ANYTYPE)0;\n }\n else {\n  NNMbsynt(np,bp,bp->curtok.string,0,\n           \"DECLARE type not one of STRING, NUMBER or FLAG\");\n  return NULL;\n }\n\n if (!NNMbdecl(np,bp,var,type,val)) {\n  NNMbsynt(np,bp,var,0, \"Declaration failed\");\n  return NULL;\n }\n\n return NULL;\n}\n\n./ ADD NAME=NNMBPDER\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: DEREGISTER\n *\n * Syntax:  DEREGISTER\n *\n * Mode:    per_newsgroup\n *\n * Function: Deregisters the current newsgroup.\n *\n * Note: Arguments are not permitted.  If they are given, the\n *       function will not be performed.\n *\n * Examples:  DEREGISTER\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPDER\")\n#pragma  csect(static,\"NN$BPDER\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Execute batch DEREGISTER command. ****************************/\n\nstatic void\nNNMbxder(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n Rstruc newsgroup   *gp = bp->gp;\n\n gp->registered = 0;\n fprintf(np->batch_outfile,\"Newsgroup %s deregistered.\\n\",gp->name);\n NNMsave(np,NULL);    /* Checkpoint NEWSRC file */\n return;\n\n}\n\n/****** Parse batch DEREGISTER command. ****************************/\n\nstruct newscmd *\nNNMbpder(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp;\n\n bp->stop_at_newline = TRUE;\n NNMbtras(np,bp,\"DEREGISTER\");   /* Trash extraneous parameters */\n if (bp->syntax_error) return NULL;\n if (bp->mode != PER_NEWSGROUP_MODE) {\n   NNMbsynt(np,bp,NULL,0,\n            \"DEREGISTER is invalid outside of per-newsgroup mode\");\n   return NULL;\n }\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for DEREGISTER command\");\n if (cmdp) {\n   cmdp->mode = PER_NEWSGROUP_MODE;\n   cmdp->proc = NNMbxder;\n }\n return cmdp;\n}\n\n./ ADD NAME=NNMBPELS\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BPELS\")\n#pragma  csect(static,\"NN$BPELS\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Parse batch ELSE         command. ****************************/\n\nstruct newscmd *\nNNMbpels(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd             *cmdp       = NULL;\n struct cmdtree             *elsecmds   = NULL;\n\n cmdp = bp->ifcmd;\n bp->ifcmd = NULL;\n\n if (!cmdp) {\n   NNMbsynt(np,bp,NULL,0,\"ELSE without matching IF found\");\n }\n\n /* Get DO-END command group.  */\n\n elsecmds = NNMbgdo(np,bp,bp->mode);\n\n if (bp->syntax_error) return NULL;\n\n if (cmdp) cmdp->cmd.fcmd.elsecmds = elsecmds;\n\n return NULL;  /* cmdp was already returned by IF */\n\n}\n\n./ ADD NAME=NNMBPEXE\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: EXEC\n *\n * Syntax:  EXEC {datum}* ;\n *\n * Mode:    any (but see note)\n *\n * Function: Executes the TSO command built from the specified\n *           data items.  Items can be:\n *\n *           * text strings\n *           * integers\n *           * words representing variables that have values\n *\n * Note: When words are used, the values they represent must be\n *       valid for the mode in which the EXEC is executed.\n *\n * Note: Since the command can span input lines and the number of\n *       arguments is variable, the arguments MUST be terminated\n *       by a semicolon or end of file.\n *\n * Examples:  EXEC \"time\";\n *            EXEC \"SE 'I have \" UNREAD \" new items' USER(JRL)\";\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPEXE\")\n#pragma  csect(static,\"NN$BPEXE\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Execute batch EXEC       command. ****************************/\n\nstatic void\nNNMbxexe(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n char               *string;\n int                 rc;\n\n string = NNMbbexp(np,bp,cmdp->cmd.mcmd.ptreep,STRING_SYMTYPE);\n if (bp->runtime_error) {\n   fprintf(np->batch_outfile,\n           \"Command not executed due to errors building argument\\n\");\n }\n else {\n   fprintf(np->batch_outfile, \"Executing command:\\n%s\\n\\n\", string);\n   rc = NNMtso(string);\n   fprintf(np->batch_outfile, \"\\nReturn code: %d\\n\",rc);\n }\n\n return;\n}\n\n/****** Parse batch EXEC         command. ****************************/\n\nstruct newscmd *\nNNMbpexe(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp       = NULL;\n struct ptree       *treep      = NULL;\n\n treep = NNMbgexp(np,bp,STRING_SYMTYPE); /* Get data string struct */\n\n if (!treep) {\n   NNMbsynt(np,bp,NULL,0,\"Error in arguments to EXEC\");\n   return NULL;\n }\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for EXEC command\");\n\n if (cmdp) {\n   cmdp->mode = ANY_MODE;\n   cmdp->proc = NNMbxexe;\n   cmdp->cmd.mcmd.ptreep = treep;\n }\n\n return cmdp;\n}\n\n./ ADD NAME=NNMBPEXT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: EXTRACT\n *\n * Syntax:  In per-newsgroup mode: EXTRACT ALL / READ / UNREAD\n *          In per-article   mode: EXTRACT\n *\n * Mode:    per-newsgroup or per-article\n *\n * Function: EXTRACTs all, read, or unread articles in the current\n *           newsgroup; extracts the current article.\n *\n * Note:     The file into which the article(s) are extracted is\n *           specified by the contents of file DD:NNEXTTAB, which\n *           is a listing of newsgroups and filenames.  The filenames\n *           are expected to contain a wildcard asterisk, which is\n *           substituted with the article number.\n *\n * Examples:  EXTRACT\n *            EXTRACT ALL\n *            EXTRACT READ\n *            EXTRACT UNREAD\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPEXT\")\n#pragma  csect(static,\"NN$BPEXT\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/********** Extract this article. ************************************/\n\nstatic int\nextract_this_article(np,bp,gp,vp)\nRstruc nncb            *np;\nRstruc batch           *bp;\nRstruc newsgroup       *gp;\nVARK                   *vp;\n{\n Rstruc newsarticle    *ap;\n FILE                  *xfp;\n char                  *cp1;\n char                  *cp2;\n char                   ddname  \u00dd9\u00a8;\n char                   exdsn  \u00dd81\u00a8;\n char                   expds  \u00dd81\u00a8;\n char                   member \u00dd81\u00a8;\n char                   thing_to_open \u00dd81\u00a8;\n Bool                   automark;\n\n ap = VARK2PARTICLE(*vp);\n\n *member = '\\0';\n *ddname = '\\0';\n\n if (*bp->extractds_member) {\n\n   sprintf(member,\"%8.8d\",ap->number);\n   for (cp1=member,   cp2=bp->extractds_member;\n       *cp1=='0'  && *cp2;\n        cp1++,        cp2++) {\n     *cp1 = *cp2;\n   }\n\n   sprintf(exdsn, \"%s%s%s\", bp->extractds_part1, member,\n                            bp->extractds_part2);\n }\n else strcpy(exdsn,bp->extractds);\n\n automark = GETB(\"AUTOMARK\");\n\n np->extract_tab_expanding          = GETB(\"TABEXPAND\");\n np->extract_appending              = bp->extractds_mode == PDS\n                                      ? FALSE\n                                      : GETB(\"APPEND\");\n np->extract_blank_before_separator = GETB(\"BLANKSEP\");\n np->extract_separator_line         = GETC(\"SEPARATOR\");\n np->extract_write_error            = FALSE;\n np->extract_close_error            = FALSE;\n\n /* Preallocate the data set so that we don't run out of space\n  * and so that brain-damaged C/370 doesn't barf on hyphens.\n  * If it already exists, use the existing one.\n  */\n\n if (bp->extractds_mode == PDS) {\n\n   strcpy(expds,exdsn);\n   cp1 = strchr(expds,'(');\n   *cp1 = '\\0';\n   cp2 = strchr(cp1+1,')');\n   *cp2 = '\\0';\n\n   strcpy(member,cp1+1);\n\n   if (!NNMalloc(expds,ddname,PDS,gp->article_count)) {\n     fprintf(np->batch_outfile,\n             \"Could not allocate %s for extract.\\n\",expds);\n     bp->runtime_error = TRUE;\n     return 0;\n   }\n\n   sprintf(thing_to_open, \"dd:%s(%s)\", ddname, member);\n   sprintf(exdsn, \"%s(%s)\", expds, member);\n\n }\n else {\n   if (!NNMalloc(exdsn,ddname,SEQ,gp->article_count)) {\n     fprintf(np->batch_outfile,\n             \"Could not allocate %s for extract.\\n\",exdsn);\n     bp->runtime_error = TRUE;\n     return 0;\n   }\n\n   sprintf(thing_to_open, \"dd:%s\", ddname);\n\n }\n\n xfp = OPEN_TEXT_FILE_FOR_WRITE_OR_APPEND(thing_to_open,\n                                          np->extract_appending);\n\n if (!xfp) {\n   perror(exdsn);\n   fprintf(np->batch_outfile,\"Could not open %s for extract.\\n\",exdsn);\n   bp->runtime_error = TRUE;\n   return 0;\n }\n\n if (!NNMpick(np,ap)) {             /* Pick article */\n   fprintf(np->batch_outfile,\n           \"Error accessing article %d of %s.\\n\",ap->number,gp->name);\n   fprintf(np->batch_outfile,\n           \"Extraction into %s was not done.\\n\",exdsn);\n   bp->runtime_error = TRUE;\n }\n else {\n   NNMbtext(np,&ap->thdr,xfp);      /* Print text   */\n }\n\n if (fclose(xfp) < 0) {\n   fprintf(np->batch_outfile,\n           \"Error closing %s.\\n\", exdsn);\n   bp->runtime_error = TRUE;\n }\n\n (void)NNMunalc(ddname);\n\n if (bp->runtime_error ||\n     np->extract_write_error || np->extract_close_error) {\n   fprintf(np->batch_outfile,\n           \"Error extracting article %d of %s into %s.\\n\",\n           ap->number, gp->name, exdsn);\n   bp->runtime_error = TRUE;\n }\n else {\n   if (automark && IsUnread(*vp)) {\n     NNMmarr(np,gp,vp);\n     fprintf(np->batch_outfile,\n             \"Article %d of %s extracted into %s and marked read.\\n\",\n             ap->number, gp->name, exdsn);\n     NNMsave(np,NULL);   /* Checkpoint NEWSRC file */\n   }\n   else {\n     fprintf(np->batch_outfile,\n             \"Article %d of %s extracted into %s.\\n\",\n             ap->number, gp->name, exdsn);\n   }\n }\n\n return (bp->runtime_error ? 0 : 1);\n}\n\n/********** Extract articles. ****************************************/\n\nstatic int\nextract_articles(np,bp,gp,extracting)\nRstruc nncb            *np;\nRstruc batch           *bp;\nRstruc newsgroup       *gp;\nenum extracting_mode    extracting;\n{\n VARK                  *vp;\n VARK                  *vpfirst;\n VARK                  *vplast;\n int                    count;\n\n np->current_newsgroup   = gp;\n np->newsgroup_selected  = FALSE;\n np->show_all_articles   = TRUE;\n\n if (!GroupSelected(gp)) gp = NNMdng(np,gp,NULL);\n if (!gp) return 0;\n\n bp->gp = gp;\n count = 0;\n if (gp->article_vector) {\n   vpfirst = &GETVARKFIRST(gp);\n   vplast  = &GETVARKLAST(gp);\n   for (vp = vpfirst; vp <= vplast; vp++) {\n     int Number = VARK2NUMBER(gp,vp);\n     if ((extracting == EXTRACTING_ALL)\n      || (extracting == EXTRACTING_READ   && IsRead(*vp))\n      || (extracting == EXTRACTING_UNREAD && IsUnread(*vp))) {\n       if (NNMrarh(np,gp,vp,0,NULL)) { /* retrieve article hdr */\n         count += extract_this_article(np,bp,gp,vp);\n       }\n     }\n   }\n }\n\n return count;\n}\n\n/********** Get extract file. ****************************************/\n\nstatic Bool\nget_extract_file(np,bp,gp)\nRstruc nncb            *np;\nRstruc batch           *bp;\nRstruc newsgroup       *gp;\n{\n FILE                  *tabfp;\n char                  *asp;\n char                  *cp;\n char                  *cp1;\n char                  *cp2;\n char                  *lp;\n char                  *rp;\n int                    len;\n enum data_set_type     mode;\n Bool                   found_extract;\n char                   line    \u00dd260\u00a8;\n char                   tabname \u00dd260\u00a8;\n char                   tabds   \u00dd260\u00a8;\n\n strcpy(bp->extractds,\"\");\n\n /* Open the extract table. */\n\n if (!(tabfp = fopen(\"DD:NNEXTTAB\",\"r\"))) {\n   perror(\"extract table (ddname NNEXTTAB)\");\n   fprintf(np->batch_outfile,\"Could not open extract table.\\n\");\n   bp->runtime_error = TRUE;\n   return FALSE;\n }\n\n /* Search the extract table for a line that matches this newsgroup. */\n\n found_extract = FALSE;\n\n do {\n   fgets(line, sizeof line, tabfp);\n   if (feof(tabfp)) break;\n   if (ferror(tabfp)) {\n     fprintf(np->batch_outfile,\n             \"Error reading extract table (ddname NNEXTTAB)\");\n     break;\n   }\n   strcpy(tabname,\"\");\n   strcpy(tabds  ,\"\");\n   sscanf(line,\"%s %s\",tabname, tabds);\n   if (!*tabname) continue;\n   lowercase_in_place(tabname);\n   if (UNEQUAL(tabname, gp->name)) continue;\n   found_extract = TRUE;\n   if (!*tabds) {\n     fprintf(np->batch_outfile,\n     \"Extract table entry for group %s has no file name specified.\\n\",\n             gp->name);\n     break;\n   }\n } while (!found_extract);\n\n if (!found_extract) {\n   fprintf(np->batch_outfile,\n    \"Extract terminated for group %s, no entry in extract table.\\n\",\n     gp->name);\n   return FALSE;\n }\n\n if (fclose(tabfp) < 0) {\n   fprintf(stderr,\"Error closing extract table (ddname NNEXTTAB)\");\n   fprintf(np->batch_outfile,\"Could not close extract table\\n\");\n   bp->runtime_error = TRUE;\n   return FALSE;\n }\n\n if (*tabds == '!') {\n   fprintf(np->batch_outfile,\n           \"Extract suppressed for group %s ('!' in extract table).\\n\",\n           gp->name);\n   return FALSE;\n }\n\n /* Copy table dsn to extract dsn, upcasing and stripping all quotes */\n\n for (cp1 = tabds, cp2 = bp->extractds; *cp1; cp1++) {\n   if (*cp1 != '\\'') *cp2++ = toupper(*cp1);\n }\n *cp2 = '\\0';\n\n lp  = strchr(bp->extractds,'(');\n rp  = strchr(bp->extractds,')');\n asp = strchr(bp->extractds,'*');\n\n if (lp && rp) {\n   if (*(rp+1) != '\\0') {\n     fprintf(np->batch_outfile,\n             \"Misuse of parentheses in extract file template %s\\n\",\n             bp->extractds);\n     bp->runtime_error = TRUE;\n     return FALSE;\n   }\n   if (!asp) {\n     fprintf(np->batch_outfile,\n             \"Parentheses without '*' in extract file template %s\\n\",\n             bp->extractds);\n     fprintf(np->batch_outfile,\n             \"(cannot append multiple articles to same PDS member)\\n\");\n     bp->runtime_error = TRUE;\n     return FALSE;\n   }\n   mode = PDS;\n }\n else {\n   if (lp || rp) {\n     fprintf(np->batch_outfile,\n             \"Misuse of parentheses in extract file template %s\\n\",\n             bp->extractds);\n     bp->runtime_error = TRUE;\n     return FALSE;\n   }\n   mode = SEQ;\n }\n\n if (strchr(asp+1,'*')) {\n   fprintf(np->batch_outfile,\n           \"Too many '*' in extract file template %s\\n\",\n           bp->extractds);\n   bp->runtime_error = TRUE;\n   return FALSE;\n }\n\n if (asp) {\n   switch (*(asp+1)) {\n     case '\\0':\n     case ')':\n     case '(':\n     case '.':  break;\n     default:\n            fprintf(np->batch_outfile,\n                    \"Invalid use of '*' in extract file template %s\\n\",\n                    bp->extractds);\n            fprintf(np->batch_outfile,\n                    \"(must be followed by '.', ')' or end of name)\\n\");\n            bp->runtime_error = TRUE;\n            return FALSE;\n   }\n   for (cp = asp-1;\n        cp >= bp->extractds && (*cp != '(' && *cp != '.');\n        cp--);\n   cp++;\n   if (cp == asp) {\n     fprintf(np->batch_outfile,\n             \"Invalid use of '*' in extract file template %s\\n\",\n             bp->extractds);\n     fprintf(np->batch_outfile,\n             \"(must be preceded by an alphanumeric dsname char)\\n\");\n     bp->runtime_error = TRUE;\n     return FALSE;\n   }\n   len = cp - bp->extractds;\n   memcpy(bp->extractds_part1,  bp->extractds, len);\n   *(bp->extractds_part1 + len) = '\\0';\n   len = asp - cp;\n   memcpy(bp->extractds_member, cp, len);\n   *(bp->extractds_member + len) = '\\0';\n   strcpy(bp->extractds_part2,  asp+1);\n }\n else {\n   strcpy(bp->extractds_part1, bp->extractds);\n   strcpy(bp->extractds_part2, \"\");\n   strcpy(bp->extractds_member,\"\");\n }\n\n bp->extractds_mode = mode;\n\n return TRUE;\n}\n\n/********** Execute batch EXTRACT command. ***************************/\n\nstatic void\nNNMbxext(np,bp,cmdp)\nRstruc nncb            *np;\nRstruc batch           *bp;\nRstruc newscmd         *cmdp;\n{\n struct newsgroup      *gp    = bp->gp;\n int                    count = 0;\n enum extracting_mode   extracting;\n\n extracting = cmdp->cmd.xcmd.extracting;\n\n if (get_extract_file(np,bp,gp)) {\n   if (extracting == NO_EXTRACTING_MODE) {\n     count = extract_this_article(np,bp,gp,bp->vp);\n   }\n   else {\n     count = extract_articles(np,bp,gp,extracting);\n   }\n }\n if (bp->runtime_error) {\n   fprintf(np->batch_outfile, \"Extraction failed for %s.\\n\",\n                              gp->name);\n }\n else {\n   fprintf(np->batch_outfile, \"%d article%s extracted for %s.\\n\",\n                              count, count==1 ? \"\" : \"s\", gp->name);\n }\n\n return;\n\n}\n\n/****** Per-newsgroup mode EXTRACT. **********************************/\n\nstatic struct newscmd *\nparse_newsgroup_extract(np,bp)\nRstruc nncb            *np;\nRstruc batch           *bp;\n{\n struct newscmd        *cmdp       = NULL;\n enum extracting_mode   extracting = NO_EXTRACTING_MODE;\n\n /*\n  * Next token must be ALL, READ or UNREAD.\n  */\n\n if (NNMbgtok(np,bp,TOKEN_READ)) {  /* get token */\n   switch (bp->curtok.type) {\n     case WORD_TOKEN:\n                      if (EQUAL(bp->curtok.string,\"ALL\")) {\n                        extracting = EXTRACTING_ALL;\n                      }\n                      if (EQUAL(bp->curtok.string,\"READ\")) {\n                        extracting = EXTRACTING_READ;\n                      }\n                      else if (EQUAL(bp->curtok.string,\"UNREAD\")) {\n                        extracting = EXTRACTING_UNREAD;\n                      }\n                      break;\n     default:\n                      break;\n   }\n }\n\n if (extracting == NO_EXTRACTING_MODE) {\n   NNMbsynt(np,bp,bp->curtok.string,0,\n         \"EXTRACT in per-newsgroup mode requires ALL, READ or UNREAD\");\n }\n\n bp->stop_at_newline = TRUE;\n\n NNMbtras(np,bp,\"EXTRACT\"); /* Trash extraneous parameters */\n\n if (bp->syntax_error) return NULL;\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for EXTRACT command\");\n\n if (cmdp) {\n   cmdp->mode = PER_NEWSGROUP_MODE;\n   cmdp->proc = NNMbxext;\n   cmdp->cmd.xcmd.extracting = extracting;\n }\n\n return cmdp;\n}\n\n/****** Per-article mode EXTRACT. ************************************/\n\nstatic struct newscmd *\nparse_article_extract(np,bp)\nRstruc nncb            *np;\nRstruc batch           *bp;\n{\n struct newscmd        *cmdp       = NULL;\n bp->stop_at_newline = TRUE;\n\n NNMbtras(np,bp,\"EXTRACT\"); /* Trash extraneous parameters */\n\n if (bp->syntax_error) return NULL;\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for EXTRACT command\");\n\n if (cmdp) {\n   cmdp->mode = PER_ARTICLE_MODE;\n   cmdp->proc = NNMbxext;\n   cmdp->cmd.xcmd.extracting = NO_EXTRACTING_MODE;\n }\n\n return cmdp;\n}\n\n/****** Parse batch EXTRACT      command. ****************************/\n\nstruct newscmd *\nNNMbpext(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n\n switch (bp->mode) {\n   case PER_NEWSGROUP_MODE: return parse_newsgroup_extract (np,bp);\n   case PER_ARTICLE_MODE:   return parse_article_extract   (np,bp);\n   default:\n        NNMbsynt(np,bp,NULL,0,\n        \"EXTRACT belongs in per-newsgroup mode or per-article mode\");\n   return NULL;\n }\n\n}\n\n./ ADD NAME=NNMBPFOR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: FOR\n *\n * Syntax:  (1) in top-level mode...\n *\n *          FOR criterion {WHEN filter} DO;\n *          command(s);\n *          END;\n *\n *          where\n *\n *          criterion is one of: ALL\n *                               REGISTERED\n *                               UNREGISTERED\n *           * not implemented:  \"groupmask\"  (e.g. \"comp*\")\n *           * not implemented:  {NEWS}GROUP{S} \"groupnames\"\n *\n *          filter is any flag expression\n *\n *          commands are any commands for the appropriate mode\n *\n * Examples:\n *\n *   FOR ALL                  DO ... { per-newsgroup commands }\n *   FOR REGISTERED           DO ...\n *   FOR ... WHEN (READ = nn) DO ...\n *   FOR ... WHEN (UNREAD > nn) DO ...\n *   FOR ... WHEN (COUNT < nn) DO ...\n *   the following are not implemented:\n *   FOR \"comp.*\"             DO ...\n *   FOR GROUPS \"a.b.c d.e.f\" DO ...\n *   FOR NEWSGROUP \"a.b.c\" DO ...\n *\n * Syntax:  (2) in per-newsgroup mode...\n *\n *          FOR criterion {WHEN filter} DO;\n *          command(s);\n *          END;\n *\n *          where\n *\n *          criterion is one of: ALL\n *                               READ\n *                               UNREAD\n *                               i TO j  (i = number or FIRST,\n *                                       (j = number or LAST)\n *\n *          filter is any flag expression\n *\n *          commands are any commands for the appropriate mode\n *\n * Examples:\n *\n * FOR ALL WHEN \"foo\" IN SUBJECT DO ...\n * FOR UNREAD DO ...\n * FOR FIRST TO 10 DO ...\n *\n * Mode:    (1) top-level     (picking newsgroups)\n *          (2) per-newsgroup (picking articles)\n *\n * For (1), the commands between DO and END are in per-newsgroup mode.\n * For (2), the commands between DO and END are in per-article mode.\n *\n * Function: Defines operations to be performed on each newsgroup\n *           in a list of newsgroups (1), or on each article in a\n *           list of articles (2).\n *\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPFOR\")\n#pragma  csect(static,\"NN$BPFOR\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Get keyword. *************************************************/\n\nstatic Bool\nget_keyword(np,bp,key)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nchar                        *key;\n{\n struct token               *tp;\n\n if ((tp = PEEK()) && tp->type == WORD_TOKEN && EQUAL(tp->string,key)) {\n   EAT();\n   return TRUE;\n }\n\n else return FALSE;\n\n}\n\n/****** Parse initial-mode FOR for newsgroups. ***********************/\n\nstatic struct newscmd *\nparse_for_newsgroups(np,bp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\n{\n struct token               *tp;\n struct newscmd             *cmdp       = NULL;\n struct ptree               *filter     = NULL;\n struct cmdtree             *treep      = NULL;\n struct ptree               *groups     = NULL;\n enum which_newsgroups       which      = NO_NEWSGROUPS;\n\n /* Look for criterion, one of:\n  *                              ALL\n  *                              REGISTERED\n  *                              UNREGISTERED\n  *  (not implemented)           GROUPMASK group-mask-expression\n  *                              {NEWS}GROUP{S} group-name-expression\n  */\n\n if ((tp = PEEK())) {\n   switch (tp->type) {\n     case WORD_TOKEN:\n                         if      (EQUAL(tp->string,\"ALL\")) {\n                           EAT();\n                           which = ALL_NEWSGROUPS;\n                         }\n                         else if (EQUAL(tp->string,\"REGISTERED\")) {\n                           EAT();\n                           which = REGISTERED_NEWSGROUPS;\n                         }\n                         else if (EQUAL(tp->string,\"UNREGISTERED\")) {\n                           EAT();\n                           which = UNREGISTERED_NEWSGROUPS;\n                         }\n                         else if (EQUAL(tp->string,\"GROUP\")\n                               || EQUAL(tp->string,\"GROUPS\")\n                               || EQUAL(tp->string,\"NEWSGROUP\")\n                               || EQUAL(tp->string,\"NEWSGROUPS\")) {\n                           EAT();\n                           which = NAMED_NEWSGROUPS;\n                         }\n                         else if (EQUAL(tp->string,\"GROUPMASK\")\n                               || EQUAL(tp->string,\"NEWSGROUPMASK\")) {\n                           EAT();\n                           which = MASKED_NEWSGROUPS;\n                         }\n                         break;\n     case STRING_TOKEN:  if (strchr(tp->string,'*'))\n                              which = MASKED_NEWSGROUPS;\n                         else which = NAMED_NEWSGROUPS;\n                         break;\n     default:\n                         break;\n   }\n }\n\n switch (which) {\n   case NO_NEWSGROUPS:\n                           NNMbsynt(np,bp,NULL,0,\n  \"Missing FOR criterion - ALL, REGISTERED, UNREGISTERED, NEWSGROUPS\");\n                           break;\n   case NAMED_NEWSGROUPS:\n                           groups = NNMbgexp(np,bp,STRING_SYMTYPE);\n                           if (!groups) NNMbsynt(np,bp,NULL,0,\n                                      \"No valid group list specified\");\n                           break;\n   case MASKED_NEWSGROUPS:\n                           groups = NNMbgexp(np,bp,STRING_SYMTYPE);\n                           if (!groups) NNMbsynt(np,bp,NULL,0,\n                                      \"No valid group mask specified\");\n                           break;\n   default: break;\n }\n\n /* Look for WHEN.  If found, then look for filter, a flag expression.\n  */\n\n if (get_keyword(np,bp,\"WHEN\")) {\n   filter = NNMbgexp(np,bp,FLAG_SYMTYPE);\n   if (!filter) {\n     NNMbsynt(np,bp,NULL,0,\"No valid filter expression specified\");\n   }\n }\n\n /* Get DO-END command group.  */\n\n treep = NNMbgdo(np,bp,PER_NEWSGROUP_MODE);\n\n if (bp->syntax_error) return NULL;\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for FOR command\");\n\n if (cmdp) {\n   cmdp->mode = INITIAL_MODE;\n   cmdp->proc = NNMbxfng;\n   cmdp->cmd.icmd.fors.filter          = filter;\n   cmdp->cmd.icmd.fors.treep           = treep;\n   cmdp->cmd.icmd.fors.crit.which      = which;\n   cmdp->cmd.icmd.fors.crit.groups     = groups;\n }\n\n return cmdp;\n\n}\n\n/****** Parse per-newsgroup-mode FOR for articles. *******************/\n\nstatic struct newscmd *\nparse_for_articles(np,bp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\n{\n struct token               *tp;\n struct newscmd             *cmdp        = NULL;\n struct ptree               *filter      = NULL;\n struct cmdtree             *treep       = NULL;\n struct ptree               *first       = NULL;\n struct ptree               *last        = NULL;\n enum which_articles         which       = NO_ARTICLES;\n\n /* Look for criterion, one of:\n  *                              ALL\n  *                              READ\n  *                              UNREAD\n  *                              i/FIRST to j/LAST\n  *\n  * Note: FIRST and LAST will be variables at run time, making it\n  *       easier to handle them.  That way you can say things like\n  *       FIRST + 1 TO LAST - 3.\n  */\n\n if ((tp = PEEK())) {\n   switch (tp->type) {\n     case WORD_TOKEN:\n                         if      (EQUAL(tp->string,\"ALL\")) {\n                           EAT();\n                           which = ALL_ARTICLES;\n                         }\n                         else if (EQUAL(tp->string,\"READ\")) {\n                           EAT();\n                           which = READ_ARTICLES;\n                         }\n                         else if (EQUAL(tp->string,\"UNREAD\")) {\n                           EAT();\n                           which = UNREAD_ARTICLES;\n                         }\n                         else which = RANGED_ARTICLES;\n                         break;\n     default:            which = RANGED_ARTICLES;\n                         break;\n   }\n }\n\n switch (which) {\n   case NO_ARTICLES:\n                         NNMbsynt(np,bp,NULL,0,\n  \"Missing FOR criterion - ALL, READ, UNREAD, or n/FIRST to n/LAST\");\n                         break;\n   case RANGED_ARTICLES:\n                         first = NNMbgexp(np,bp,NUMBER_SYMTYPE);\n                         if (!first) NNMbsynt(np,bp,NULL,0,\n                                     \"No valid range start given\");\n                         if (get_keyword(np,bp,\"TO\")) {\n                           last = NNMbgexp(np,bp,NUMBER_SYMTYPE);\n                           if (!last) NNMbsynt(np,bp,NULL,0,\n                                      \"No valid range end given\");\n                         }\n                         else last = NULL;\n                         break;\n   default: break;\n }\n\n /* Look for WHEN.  If found, then look for filter, a flag expression.*/\n\n if (get_keyword(np,bp,\"WHEN\")) {\n   filter = NNMbgexp(np,bp,FLAG_SYMTYPE);\n   if (!filter) {\n     NNMbsynt(np,bp,NULL,0,\"No valid filter expression specified\");\n   }\n }\n\n /* Get DO-END command group.  */\n\n treep = NNMbgdo(np,bp,PER_ARTICLE_MODE);\n\n if (bp->syntax_error) return NULL;\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for FOR command\");\n\n if (cmdp) {\n   cmdp->mode = PER_NEWSGROUP_MODE;\n   cmdp->proc = NNMbxfar;\n   cmdp->cmd.ncmd.fors.filter     = filter;\n   cmdp->cmd.ncmd.fors.treep      = treep;\n   cmdp->cmd.ncmd.fors.crit.which = which;\n   cmdp->cmd.ncmd.fors.crit.first = first;\n   cmdp->cmd.ncmd.fors.crit.last  = last;\n }\n\n return cmdp;\n\n}\n\n/****** Parse batch FOR          command. ****************************/\n\nstruct newscmd *\nNNMbpfor(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n\n switch (bp->mode) {\n   case INITIAL_MODE:       return parse_for_newsgroups(np,bp);\n   case PER_NEWSGROUP_MODE: return parse_for_articles  (np,bp);\n   default: NNMbsynt(np,bp,NULL,0,\n                 \"FOR belongs in initial mode or per-newsgroup mode\");\n            return NULL;\n }\n\n}\n\n./ ADD NAME=NNMBPHEL\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: HELP\n *\n * Syntax:  HELP {word}*\n *\n * Mode:    any\n *\n * Function: Writes help information to the output file.\n *\n * Note: Words may be specified, but are currently ignored.  All\n *       arguments are flushed until a new line or ';' is seen.\n *\n * Examples:  HELP\n *            HELP FOR\n *            HELP \"anything\" (at all), it doesn't matter!\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPHEL\")\n#pragma  csect(static,\"NN$BPHEL\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Execute batch HELP       command. ****************************/\n\nstatic void\nNNMbxhel(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n FILE               *helpfp;\n char                helpline\u00dd257\u00a8;\n\n if (!(helpfp = fopen(\"DD:NNBATHLP\",\"r\"))) {\n   perror(\"ddname NNBATHLP\");\n   fprintf(np->batch_outfile,\n     \"\\n\\n*** Help not available - cannot open batch help file. ***\\n\");\n   return;\n }\n for (;;) {\n   fgets(helpline, sizeof(helpline), helpfp);\n   if (feof(helpfp))  break;\n   if (ferror(helpfp)) {\n     fprintf(np->batch_outfile,\n           \"\\n\\n*** Help terminated - error reading help file. ***\\n\");\n     break;\n   }\n   fprintf(np->batch_outfile,\"%s\",helpline);\n }\n fprintf(np->batch_outfile,\"\\n\");\n fclose(helpfp);\n\n return;\n}\n\n/****** Parse batch HELP         command. ****************************/\n\nstruct newscmd *\nNNMbphel(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp;\n\n bp->stop_at_newline = TRUE;\n\n while (NNMbgtok(np,bp,TOKEN_READ)) { /* Get token */\n   switch (bp->curtok.type) {\n     case EOF_TOKEN:\n     case EOL_TOKEN:\n     case SEMI_TOKEN: break;\n     default:         NNMbsynt(np,bp,bp->curtok.string,0,\n                               \"Extraneous parameter for HELP\");\n                      continue;\n   }\n   break;\n }\n\n if (bp->syntax_error) return NULL;\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for HELP command\");\n\n if (cmdp) {\n   cmdp->mode = ANY_MODE;\n   cmdp->proc = NNMbxhel;\n }\n\n return cmdp;\n\n}\n\n./ ADD NAME=NNMBPIF\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: IF\n *\n * Syntax:  IF condition THEN DO;\n *          command(s);\n *          END;\n *          ELSE DO;\n *          command(s);\n *          END;\n *\n *          where\n *\n *          condition is any flag expression\n *\n *          commands are any commands for the appropriate mode\n *\n * Examples:\n *\n *   IF AUTOREGISTER THEN DO ...\n *   IF SERVER != \"\" THEN DO ...\n *   IF (A = 1 | B = 2)  THEN DO ...\n *\n * Mode:    any (but see note)\n *\n * The commands between DO and END, for the THEN and ELSE groups,\n * must be in the appropriate mode.\n *\n * Function: If condition is true, executes commands in the first\n *           command group; otherwise executes commands in the second\n *           command group.\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPIF \")\n#pragma  csect(static,\"NN$BPIF \")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Execute commands. ********************************************/\n\nstatic void\nexecute_commands(np,bp,treep)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nstruct cmdtree              *treep;\n{\n\n for (; treep; treep = treep->next) {\n   bp->runtime_error = FALSE;\n   (treep->cmd->proc) (np,bp,treep->cmd);\n   SETB(\"ERROR\",bp->runtime_error);\n }\n\n return;\n}\n\n/****** Execute batch IF command. ************************************/\n\nstatic void\nNNMbxif(np,bp,cmdp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nRstruc newscmd              *cmdp;\n{\n struct ptree               *condition;\n struct cmdtree             *thencmds;\n struct cmdtree             *elsecmds;\n Fool                        condval;\n\n condition = cmdp->cmd.fcmd.condition;\n thencmds  = cmdp->cmd.fcmd.thencmds;\n elsecmds  = cmdp->cmd.fcmd.elsecmds;\n\n condval = (Fool) NNMbbexp(np,bp,condition,FLAG_SYMTYPE);\n if (bp->runtime_error) return;\n\n if (condval) execute_commands(np,bp,thencmds);\n else         execute_commands(np,bp,elsecmds);\n\n return;\n}\n\n/****** Get keyword. *************************************************/\n\nstatic Bool\nget_keyword(np,bp,key)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nchar                        *key;\n{\n struct token               *tp;\n\n if ((tp = PEEK())\n  && tp->type == WORD_TOKEN\n  && EQUAL(tp->string,key)) {\n   EAT();\n   return TRUE;\n }\n\n else return FALSE;\n\n}\n\n/****** Parse batch IF           command. ****************************/\n\nstruct newscmd *\nNNMbpif(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd             *cmdp       = NULL;\n struct ptree               *condition  = NULL;\n struct cmdtree             *thencmds   = NULL;\n\n /* Look for condition */\n\n condition = NNMbgexp(np,bp,FLAG_SYMTYPE);\n\n if (condition == NULL) {\n   NNMbsynt(np,bp,NULL,0,\"Missing IF condition\");\n   return NULL;\n }\n\n /* Look for THEN (required).  */\n\n if (!(get_keyword(np,bp,\"THEN\"))) {\n   NNMbsynt(np,bp,NULL,0,\"Missing THEN keyword\");\n   return NULL;\n }\n\n /* Get DO-END command group.\n  */\n\n thencmds = NNMbgdo(np,bp,bp->mode);\n\n if (bp->syntax_error) return NULL;\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for IF command\");\n\n if (cmdp) {\n   cmdp->mode = bp->mode;\n   cmdp->proc = NNMbxif;\n   cmdp->cmd.fcmd.condition  = condition;\n   cmdp->cmd.fcmd.thencmds   = thencmds;\n   cmdp->cmd.fcmd.elsecmds   = NULL;\n }\n\n /* Make sure any following ELSE is properly handled. */\n\n bp->ifcmd = cmdp;\n\n return cmdp;\n\n}\n\n./ ADD NAME=NNMBPLIS\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: LIST\n *\n * Syntax:  LIST\n *\n * Mode:    per_article\n *\n * Function: Lists the contents of the current news article.\n *\n * Note: Arguments are not permitted.  If they are given, the\n *       function will not be performed.\n *\n * Examples:  LIST\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPLIS\")\n#pragma  csect(static,\"NN$BPLIS\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/********** Execute batch LIST command. ******************************/\n\nstatic void\nNNMbxlis(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n Rstruc newsarticle *ap = VARK2PARTICLE(*bp->vp);\n\n NNMpick(np,ap);                  /* Pick article */\n\n NNMbtext(np,&ap->thdr,NULL);     /* Print text */\n\n return;\n\n}\n\n/****** Parse batch LIST command. ************************************/\n\nstruct newscmd *\nNNMbplis(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp;\n\n bp->stop_at_newline = TRUE;\n\n NNMbtras(np,bp,\"LIST\");   /* Trash extraneous parameters */\n\n if (bp->syntax_error) return NULL;\n\n if (bp->mode != PER_ARTICLE_MODE) {\n   NNMbsynt(np,bp,NULL,0,\"LIST is invalid outside of per-article mode\");\n   return NULL;\n }\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for LIST command\");\n\n if (cmdp) {\n   cmdp->mode = PER_ARTICLE_MODE;\n   cmdp->proc = NNMbxlis;\n }\n\n return cmdp;\n\n}\n\n./ ADD NAME=NNMBPMAR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: MARK\n *\n * Syntax:  MARK { READ / UNREAD }\n *\n * Default: MARK READ\n *\n * Mode:    per-article\n *\n * Function: Marks the article read or unread.\n *\n * Examples:  MARK\n *            MARK READ\n *            MARK UNREAD\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPMAR\")\n#pragma  csect(static,\"NN$BPMAR\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/********** Execute batch MARK command. ******************************/\n\nstatic void\nNNMbxmar(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n struct newsgroup   *gp   = bp->gp;\n VARK               *vp   = bp->vp;\n char               *what = \"not\";\n\n switch (cmdp->cmd.rcmd.marking) {\n   case MARKING_READ:   NNMmarr(np,gp,vp);\n                        what = \"read\";\n                        break;\n   case MARKING_UNREAD: NNMmaru(np,gp,vp);\n                        what = \"unread\";\n                        break;\n }\n\n fprintf(np->batch_outfile, \"Article %d of %s marked %s.\\n\",\n                            VARK2NUMBER(gp,vp), gp->name, what);\n\n NNMsave(np,NULL);   /* Checkpoint NEWSRC file */\n\n return;\n\n}\n\n/****** Parse batch MARK         command. ****************************/\n\nstruct newscmd *\nNNMbpmar(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp       = NULL;\n enum marking_mode   marking    = MARKING_READ;\n\n /* Next token, if present, must be READ or UNREAD.  */\n\n if (NNMbgtok(np,bp,TOKEN_READ)) {  /* get token */\n   switch (bp->curtok.type) {\n     case EOL_TOKEN:\n     case EOF_TOKEN:\n     case SEMI_TOKEN: marking = MARKING_READ;\n                      break;\n     case WORD_TOKEN: if (EQUAL(bp->curtok.string,\"READ\")) {\n                        marking = MARKING_READ;\n                      }\n                      else if (EQUAL(bp->curtok.string,\"UNREAD\")) {\n                        marking = MARKING_UNREAD;\n                      }\n                      else {\n                        NNMbsynt(np,bp,bp->curtok.string,0,\n                                 \"MARK operand must be READ or UNREAD\");\n                      }\n                      break;\n     default:         NNMbsynt(np,bp,bp->curtok.string,0,\n                               \"MARK operand must be READ or UNREAD\");\n                      break;\n   }\n }\n\n bp->stop_at_newline = TRUE;\n\n NNMbtras(np,bp,\"MARK\");   /* Trash extraneous parameters */\n\n if (bp->syntax_error) return NULL;\n\n if (bp->mode != PER_ARTICLE_MODE) {\n   NNMbsynt(np,bp,NULL,0,\"MARK is invalid outside of per-article mode\");\n   return NULL;\n }\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for MARK command\");\n\n if (cmdp) {\n   cmdp->mode = PER_ARTICLE_MODE;\n   cmdp->proc = NNMbxmar;\n   cmdp->cmd.rcmd.marking = marking;\n }\n\n return cmdp;\n}\n\n./ ADD NAME=NNMBPNNT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: NNTP\n *\n * Syntax:  NNTP {datum}* ;\n *\n * Mode:    any (but see notes)\n *\n * Function: Sends an NNTP protocol command to the server as built\n *           from the specified data items.  Items can be:\n *\n *           * text strings\n *           * integers\n *           * words representing variables that have values\n *\n * Note: When words are used, the values they represent must be\n *       valid for the mode in which the EXEC is executed.\n *\n * Note: The NNTP request must be appropriate for the mode active\n *       at the time the request is executed.\n *\n * Note: Since the command can span input lines and the number of\n *       arguments is variable, the arguments MUST be terminated\n *       by a semicolon or end of file.\n *\n * Examples:  NNTP \"HELP\";\n *            NNTP \"ARTICLE \" NUMBER;\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPNNT\")\n#pragma  csect(static,\"NN$BPNNT\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Execute batch NNTP       command. ****************************/\n\nstatic void\nNNMbxnnt(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n char               *string;\n\n string = NNMbbexp(np,bp,cmdp->cmd.mcmd.ptreep,STRING_SYMTYPE);\n if (bp->runtime_error) {\n   fprintf(np->batch_outfile,\n           \"NNTP command not sent due to errors building argument\\n\");\n   return;\n }\n\n if (!NNMbconn(np,bp)) {  /* Insure server name and connect to server */\n   fprintf(np->batch_outfile,\"NNTP command not executed:\\n%s\\n\\n\",\n                             string);\n   return;\n }\n\n fprintf(np->batch_outfile, \"NNTP command:\\n%s\\n\\n\", string);\n\n if (*string || np->receiving_text) {\n   if (strlen(string) > CLIENT_BUF_MSGSIZE) {\n     ERR1(\n   \"Requested NNTP command is longer than NNMVS is prepared to handle.\"\n         );\n   }\n   else {\n     strcpy(np->nntp_command,string);\n     NNMnntp(np);                       /* execute NNTP commands */\n   }\n }\n\n return;\n\n}\n\n/****** Parse batch NNTP         command. ****************************/\n\nstruct newscmd *\nNNMbpnnt(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp       = NULL;\n struct ptree       *treep      = NULL;\n\n treep = NNMbgexp(np,bp,STRING_SYMTYPE); /* Get data string struct */\n\n if (!treep) {\n   NNMbsynt(np,bp,NULL,0,\"Error in arguments to NNTP\");\n   return NULL;\n }\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for NNTP command\");\n\n if (cmdp) {\n   cmdp->mode = ANY_MODE;\n   cmdp->proc = NNMbxnnt;\n   cmdp->cmd.mcmd.ptreep = treep;\n }\n\n return cmdp;\n}\n\n./ ADD NAME=NNMBPPUT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: PUT\n *\n * Syntax:  PUT {datum}* ;\n *\n * Mode:    any (but see note)\n *\n * Function: Writes zero or more items of data to the output file,\n *           followed by a newline.  Items can be:\n *\n *           * text strings\n *           * integers\n *           * words representing variables that have values\n *\n * Note: When words are used, the values they represent must be\n *       valid for the mode in which the PUT is executed.\n *\n * Note: Since the command can span input lines and the number of\n *       arguments is variable, the arguments MUST be terminated\n *       by a semicolon or end of file.\n *\n * Examples:  PUT;\n *            PUT \"Hello, world\";\n *            PUT 666 \" is the number of the Beast.\";\n *            PUT \"I have \" UNREAD \" new items from server \" server \".\";\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPPUT\")\n#pragma  csect(static,\"NN$BPPUT\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Print text line. *********************************************/\n\nstatic Bool\nprint_text_line(fp,string)\nFILE           *fp;\nchar           *string;\n{\n char          *cp;\n int            l;\n\n for (cp = string, l = strlen(string); l > 0; cp += 251, l -= 251) {\n  fwrite(cp,(l>251 ? 251 : l),1,fp);\n  if (ferror(fp))            return FALSE;\n  if (fputc('\\n',fp) == EOF) return FALSE;\n }\n\n return TRUE;\n}\n\n/****** Execute batch PUT        command. ****************************/\n\nstatic void\nNNMbxput(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n struct ptree       *treep;\n char               *string;\n FILE               *fp;\n Bool                print_error;\n\n treep = cmdp->cmd.mcmd.ptreep;\n\n print_error = FALSE;\n\n if (!treep) {\n   fp = NNMbsout(np,bp);  /* Set output file */\n   fprintf(fp,\"\\n\");\n   if (ferror(fp)) print_error = TRUE;\n }\n else {\n   string = NNMbbexp(np,bp,treep,STRING_SYMTYPE);\n   if (bp->runtime_error) {\n     fprintf(np->batch_outfile,\n             \"\\n<<Put failed, error building argument>>\\n\");\n   }\n   else {\n     fp = NNMbsout(np,bp);  /* Set output file */\n     if (!print_text_line(fp,string)) print_error = TRUE;\n   }\n }\n\n if (print_error) {\n   fprintf(stderr,\"Error writing to outfile\\n\");\n   bp->runtime_error = TRUE;\n }\n\n return;\n\n}\n\n/****** Parse batch PUT          command. ****************************/\n\nstruct newscmd *\nNNMbpput(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp       = NULL;\n struct ptree       *treep      = NULL;\n\n /*\n  * Special case for PUT without arguments\n  *\n  */\n\n if (NNMbgtok(np,bp,TOKEN_PEEK)) {  /* Peek next token */\n   switch (bp->nextok.type) {\n     case EOF_TOKEN:\n     case EOL_TOKEN:\n     case SEMI_TOKEN:  treep = NULL;\n                       break;\n     default:\n                       treep = NNMbgexp(np,bp,STRING_SYMTYPE);\n                       if (!treep) {\n                         NNMbsynt(np,bp,NULL,0,\n                                  \"Error in arguments to PUT\");\n                         return NULL;\n                       }\n                       break;\n   }\n }\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for PUT command\");\n\n if (cmdp) {\n   cmdp->mode = ANY_MODE;\n   cmdp->proc = NNMbxput;\n   cmdp->cmd.mcmd.ptreep = treep;\n }\n\n return cmdp;\n}\n\n./ ADD NAME=NNMBPQUE\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: QUERY\n *\n * Syntax:  QUERY\n *\n * Mode:    per_newsgroup or per_article\n *\n * Function: Dumps the status of the current newsgroup or article.\n *\n * Examples:  QUERY\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPQUE\")\n#pragma  csect(static,\"NN$BPQUE\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Execute batch QUERY      command. ****************************/\n\nstatic void\nNNMbxque(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n\n switch (cmdp->mode) {\n   case PER_NEWSGROUP_MODE:  NNMqng(np,bp->gp);                 break;\n   case PER_ARTICLE_MODE:    NNMqar(np,VARK2PARTICLE(*bp->vp)); break;\n }\n\n return;\n}\n\n/****** Parse batch QUERY        command. ****************************/\n\nstruct newscmd *\nNNMbpque(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp;\n\n bp->stop_at_newline = TRUE;\n\n NNMbtras(np,bp,\"QUERY\");        /* Trash extraneous parameters */\n\n if (bp->syntax_error) return NULL;\n\n switch (bp->mode) {\n   case PER_NEWSGROUP_MODE:\n   case PER_ARTICLE_MODE:\n        break;\n   default:\n        NNMbsynt(np,bp,NULL,0,\n            \"QUERY is valid only in per-newsgroup or per-article mode\");\n   return NULL;\n }\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for QUERY command\");\n\n if (cmdp) {\n   cmdp->mode = bp->mode;\n   cmdp->proc = NNMbxque;\n }\n\n return cmdp;\n\n}\n\n./ ADD NAME=NNMBPQUI\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: QUIT\n *\n * Syntax:  QUIT\n *\n * Mode:    any\n *\n * Function: Terminates processing when it is seen.\n *\n * Note: Arguments are not permitted.  If they are given, the QUIT\n *       function will not be performed.\n *\n * Examples:  QUIT\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPQUI\")\n#pragma  csect(static,\"NN$BPQUI\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Execute batch QUIT       command. ****************************/\n\nstatic void\nNNMbxqui(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n\n bp->quit = TRUE;\n\n fprintf(np->batch_outfile,\"\\nQUIT signalled.  Processing ended.\\n\");\n\n return;\n\n}\n\n/****** Parse batch QUIT         command. ****************************/\n\nstruct newscmd *\nNNMbpqui(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp;\n\n bp->stop_at_newline = TRUE;\n\n NNMbtras(np,bp,\"QUIT\");   /* Trash extraneous parameters */\n\n if (bp->syntax_error) return NULL;\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for QUIT command\");\n\n if (cmdp) {\n   cmdp->mode = ANY_MODE;\n   cmdp->proc = NNMbxqui;\n }\n\n return cmdp;\n\n}\n\n./ ADD NAME=NNMBPREG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: REGISTER\n *\n * Syntax:  REGISTER\n *\n * Mode:    per_newsgroup\n *\n * Function: Registers the current newsgroup.\n *\n * Note: Arguments are not permitted.  If they are given, the\n *       function will not be performed.\n *\n * Examples:  REGISTER\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPREG\")\n#pragma  csect(static,\"NN$BPREG\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Execute batch REGISTER command. ******************************/\n\nstatic void\nNNMbxreg(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n Rstruc newsgroup   *gp = bp->gp;\n\n gp->registered = 1;\n\n fprintf(np->batch_outfile,\"Newsgroup %s registered.\\n\",gp->name);\n\n NNMsave(np,NULL);   /* Checkpoint NEWSRC file */\n\n return;\n\n}\n\n/****** Parse batch REGISTER command. ********************************/\n\nstruct newscmd *\nNNMbpreg(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp;\n\n bp->stop_at_newline = TRUE;\n\n NNMbtras(np,bp,\"REGISTER\");   /* Trash extraneous parameters */\n\n if (bp->syntax_error) return NULL;\n\n if (bp->mode != PER_NEWSGROUP_MODE) {\n   NNMbsynt(np,bp,NULL,0,\n            \"REGISTER is invalid outside of per-newsgroup mode\");\n   return NULL;\n }\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for REGISTER command\");\n\n if (cmdp) {\n   cmdp->mode = PER_NEWSGROUP_MODE;\n   cmdp->proc = NNMbxreg;\n }\n\n return cmdp;\n\n}\n\n./ ADD NAME=NNMBPSET\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: SET\n *\n * Syntax:  SET variablename {=} {value-datum}*\n *\n * Mode:    any (but see note)\n *\n * Function: Assigns a value to the specified variablename so\n *           that it can be referenced in later PUT statements or\n *           condition queries.  Value can be made up of:\n *\n *           * text strings\n *           * integers\n *           * words representing other variables that have values\n *\n * Note: When words are used, the values they represent must be\n *       valid for the mode in which the SET is executed.\n *\n * Note: Since the command can span input lines and the number of\n *       arguments is variable, the arguments MUST be terminated\n *       by a semicolon or end of file.\n *\n * Note: The type of the value is determined by the declared type\n *       of the variable being set.\n *\n * Examples:  SET SERVER \"foo.news.com\"\n *            SET COUNT = 1\n *            SET MESSAGE = \"There are \" UNREAD \"new items.\"\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPSET\")\n#pragma  csect(static,\"NN$BPSET\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Execute batch SET        command. ****************************/\n\nstatic void\nNNMbxset(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n char               *string;\n int                 number;\n Fool                flag;\n char               *var;\n\n var = cmdp->cmd.scmd.set_symbol;\n\n switch (cmdp->cmd.scmd.set_type) {\n   case STRING_SYMTYPE:\n        string = (char *)\n                 NNMbbexp(np,bp,cmdp->cmd.scmd.ptreep,STRING_SYMTYPE);\n        if (!bp->runtime_error) {\n          SETC(var,string);\n        }\n        break;\n   case NUMBER_SYMTYPE:\n        number = (int)\n                 NNMbbexp(np,bp,cmdp->cmd.scmd.ptreep,NUMBER_SYMTYPE);\n        if (!bp->runtime_error) {\n          SETA(var,number);\n        }\n        break;\n   case FLAG_SYMTYPE:\n        flag   = (Fool)\n                 NNMbbexp(np,bp,cmdp->cmd.scmd.ptreep,FLAG_SYMTYPE);\n        if (!bp->runtime_error) {\n          SETB(var,flag);\n        }\n        break;\n   default:\n        fprintf(np->batch_outfile,\n                \"Set of %s failed due to unrecognized var type\\n\", var);\n }\n if (bp->runtime_error) {\n   fprintf(np->batch_outfile,\n           \"Set of %s failed due to errors building value\\n\", var);\n }\n\n return;\n}\n\n/****** Parse batch SET          command. ****************************/\n\nstruct newscmd *\nNNMbpset(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp       = NULL;\n struct ptree       *treep      = NULL;\n char               *var        = NULL;\n enum symtype        type;\n\n /* Next token must be variable name.  */\n\n if (!NNMbgtok(np,bp,TOKEN_READ)) return NULL;   /* get token */\n if (bp->curtok.type != WORD_TOKEN) {\n   NNMbsynt(np,bp,NULL,0, \"Expected SET variable name not seen\");\n   NNMbflus(np,bp);                         /* flush input tokens */\n   return NULL;\n }\n\n var = NNMcopy(np,bp->curtok.string);\n\n /* Variable must have been declared, else it is not valid.  */\n\n if (!(type = (enum symtype)NNMbvget(np,bp,var,NO_SYMTYPE))) {\n   NNMbsynt(np,bp,var,0,\"Variable has not been declared\");\n   NNMbflus(np,bp);                         /* flush input tokens */\n   return NULL;\n }\n\n /*\n  * Next token must be either an equal sign or the first of a series\n  * of \"datums\".  If the latter, assume the former was present.\n  */\n\n if (!NNMbgtok(np,bp,TOKEN_PEEK)) return NULL;   /* Peek next token */\n if (bp->nextok.type == EQ_TOKEN) {\n   (void)NNMbgtok(np,bp,TOKEN_FLUSH);            /* Eat the '=' */\n }\n\n /*\n  * Rest of tokens define the string to which the variable must be set.\n  * Note that the type (returned by NNMbvget) is the type of the\n  * variable in question, defining the type of its value.\n  */\n\n treep = NNMbgexp(np,bp,type);  /* Get structure describing data */\n\n if (!treep) {\n   NNMbsynt(np,bp,NULL,0,\"Bad arguments to SET, need '=' or data\");\n   return NULL;\n }\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for SET command\");\n\n if (cmdp) {\n   cmdp->mode = ANY_MODE;\n   cmdp->proc = NNMbxset;\n   cmdp->cmd.scmd.ptreep     = treep;\n   cmdp->cmd.scmd.set_symbol = var;\n   cmdp->cmd.scmd.set_type   = type;\n }\n\n return cmdp;\n}\n\n./ ADD NAME=NNMBPVAR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*=====================================================================\n *\n * Command: VARS\n *\n * Syntax:  VARS\n *\n * Mode:    any\n *\n * Function: Displays all defined variables and their types and values.\n *\n * Examples:  VARS\n *\n *====================================================================*/\n\n#pragma  csect(code,  \"NN@BPVAR\")\n#pragma  csect(static,\"NN$BPVAR\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Dump variable name, type and value. **************************/\n\nstatic void\ndump_variable(np,bp,symp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc symtab       *symp;\n{\n\n if (!symp) return;\n\n fprintf(np->batch_outfile, \" %-16.16s  \", symp->symvar);\n\n switch (symp->type) {\n   case STRING_SYMTYPE:\n        fprintf(np->batch_outfile, \"STRING  %s\\n\", symp->symval);\n        break;\n   case NUMBER_SYMTYPE:\n        fprintf(np->batch_outfile, \"NUMBER  %d\\n\", symp->symnum);\n        break;\n   case FLAG_SYMTYPE:\n        fprintf(np->batch_outfile, \"FLAG    %s\\n\",\n                symp->symnum ? \"TRUE\" : \"FALSE\");\n        break;\n }\n\n return;\n}\n\n/****** Display variable. ********************************************/\n\nstatic void\ndisplay_variable(np,bp,symp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc symtab       *symp;\n{\n\n if (!symp) return;\n\n if (symp->left) display_variable(np,bp,symp->left);\n dump_variable(np,bp,symp);\n if (symp->right) display_variable(np,bp,symp->right);\n\n return;\n}\n\n/****** Execute batch VARS       command. ****************************/\n\nstatic void\nNNMbxvar(np,bp,cmdp)\nRstruc nncb         *np;\nRstruc batch        *bp;\nRstruc newscmd      *cmdp;\n{\n\n fprintf(np->batch_outfile, \"Current variables follow\\n\\n\");\n display_variable(np,bp,bp->symtabp);\n fprintf(np->batch_outfile, \"\\nEnd variable display\\n\");\n\n return;\n\n}\n\n/****** Parse batch VARS         command. ****************************/\n\nstruct newscmd *\nNNMbpvar(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n struct newscmd     *cmdp;\n\n bp->stop_at_newline = TRUE;\n\n NNMbtras(np,bp,\"VARS\");   /* Trash extraneous parameters */\n\n if (bp->syntax_error) return NULL;\n\n GETMAIN(cmdp, struct newscmd, 1, \"newscmd for VARS command\");\n\n if (cmdp) {\n   cmdp->mode = ANY_MODE;\n   cmdp->proc = NNMbxvar;\n }\n\n return cmdp;\n\n}\n\n./ ADD NAME=NNMBSOUT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BSOUT\")\n#pragma  csect(static,\"NN$BSOUT\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Set the output file from the OUTFILE variable. ***************/\n\nFILE *\nNNMbsout(np,bp)\nRstruc nncb         *np;\nRstruc batch        *bp;\n{\n char               *outfile;\n FILE               *outfp = NULL;\n FILE               *infp  = NULL;\n Bool                appending;\n\n outfile = GETC(\"OUTFILE\");\n if (!outfile) outfile = \"\";\n if (bp->outfilename && EQUAL(bp->outfilename,outfile)) {\n   if (!bp->outfp) outfp = np->batch_outfile;\n   else outfp = bp->outfp;\n }\n else {\n   if (bp->outfp) {\n     if (fclose(bp->outfp) < 0) {\n       fprintf(stderr,\"Error closing outfile\\n\");\n       bp->runtime_error = TRUE;\n     }\n     fprintf(np->batch_outfile,\"Ending output to %s\\n\",bp->outfilename);\n     bp->outfp = NULL;\n     bp->outfilename = NULL;\n   }\n   if (*outfile) {\n     if (TEST_IF_FILE_EXISTS(infp,outfile)) {\n       CLEANUP_IF_FILE_EXISTS(infp);\n       appending = TRUE;\n     }\n     else {\n       appending = FALSE;\n     }\n     outfp = OPEN_OUTPUT_FILE_FOR_WRITE_OR_APPEND(outfile,appending);\n     if (!outfp) {\n       perror(outfile);\n       fprintf(np->batch_outfile,\"Error: OUTFILE %s is not usable.\\n\",\n                                 outfile);\n       bp->runtime_error = TRUE;\n     }\n     else {\n       bp->outfp = outfp;\n       bp->outfilename = NNMcopy(np,outfile);\n       fprintf(np->batch_outfile,\"Beginning output to %s\\n\", outfile);\n     }\n   }\n   else {\n     outfp = np->batch_outfile;\n     bp->outfp = NULL;\n     bp->outfilename = NULL;\n   }\n }\n\n return outfp;\n}\n\n./ ADD NAME=NNMBSYNT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BSYNT\")\n#pragma  csect(static,\"NN$BSYNT\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Syntax error. ************************************************/\n\nvoid\nNNMbsynt(np,bp,cp,len,msg)\nRstruc nncb         *np;\nRstruc batch        *bp;\nchar                *cp;\nint                  len;\nchar                *msg;\n{\n\n if (cp && len == 0) len = strlen(cp);\n if (!cp) {\n   fprintf(np->batch_outfile, \"Syntax error: %s.\\n\", msg);\n }\n else {\n   fprintf(np->batch_outfile, \"Syntax error: %s.  Token: %*.*s\\n\",\n                              msg, len, len, cp);\n }\n\n bp->syntax_error = TRUE;\n bp->curtok.type  = ERROR_TOKEN;\n bp->nextok.type  = NO_TOKEN;\n bp->input_errors++;\n\n return;\n}\n\n./ ADD NAME=NNMBTEXT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BTEXT\")\n#pragma  csect(static,\"NN$BTEXT\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Print text lines. ********************************************/\n\nstatic int\nprint_text_lines(np,bp,fp,textp,linep,extracting)\nRstruc nncb         *np;\nRstruc batch        *bp;\nFILE                *fp;\nstruct textline     *textp;\nchar               **linep;\nFool                 extracting;\n{\n struct textline    *tp;\n char               *cp;\n int                 l;\n int                 write_error;\n Bool                tab_expanding;\n Bool                appending;\n Bool                blank_before_separator;\n char               *separator_line;\n\n if (!fp) return TRUE;\n\n if (extracting) {\n   tab_expanding           = np->extract_tab_expanding;\n   appending               = np->extract_appending;\n   blank_before_separator  = np->extract_blank_before_separator;\n   separator_line          = np->extract_separator_line;\n }\n else {\n   tab_expanding           = TRUE;\n   appending               = FALSE;\n   blank_before_separator  = FALSE;\n   separator_line          = \"\";\n }\n\n tab_expanding = extracting ? np->extract_tab_expanding\n                            : GETB(\"TABEXPAND\");\n write_error   = 0;\n\n /* If append mode, and a separator line was specified, use it. */\n\n while (appending && separator_line && *separator_line) {\n   if (fprintf(fp,\"%s\\n\",separator_line) < 0) {\n     *linep = separator_line;\n     write_error = 1;\n     break;\n   }\n   if (blank_before_separator) {\n     if (fprintf(fp,\"\\n\") < 0) {\n       *linep = \"<blank before separator>\";\n       write_error = 2;\n       break;\n     }\n   }\n   break;\n }\n\n for (tp=textp; tp && !write_error; tp=tp->next) {\n   if (tp->text_length == 0) {\n     if (fputc('\\n',fp) == EOF) {\n       *linep = \"<single newline character>\";\n       write_error = 3;\n       break;\n     }\n   }\n   else if (tp->text_length > 0) {\n     if (tab_expanding) {\n       cp = tp->tab_expanded_text;\n       l  = tp->tab_expanded_text_length;\n     }\n     else {\n       cp = tp->text;\n       l  = tp->text_length;\n     }\n     for (; l > 0; cp += 251, l -= 251) {\n       fwrite(cp,(l>251 ? 251 : l),1,fp);\n       if (ferror(fp)) {\n         *linep = cp;\n         write_error = 4;\n         break;\n       }\n       if (fputc('\\n',fp) == EOF) {\n         *linep = \"<single newline character>\";\n         write_error = 5;\n         break;\n       }\n     }\n   }\n }\n\n if (write_error) return write_error;\n if (ferror(fp)) {\n   *linep = \"<ferror occurred>\";\n   return -1;\n }\n else return 0;\n}\n\n/****** Process the lines of text retrieved from server. *************/\n\nvoid\nNNMbtext(np,thp,fp)\nRstruc nncb         *np;\nstruct texthdr      *thp;\nFILE                *fp;\n{\n Rstruc batch       *bp = np->batch_hook;\n int                 rc;\n char               *line;\n Fool                extracting;\n\n if (fp) {  /* file pointer passed :: called from EXTRACT command */\n   extracting = TRUE;\n }\n else {\n   fp = NNMbsout(np,bp);    /* set output file */\n   extracting = FALSE;\n }\n\n rc = print_text_lines(np,bp,fp,thp->first_text_line,&line,extracting);\n if (rc != 0) {\n   fprintf(stderr,\"Error %d writing text to outfile\\n\",rc);\n   fprintf(stderr,\"Line: %s\\n\",line);\n   bp->runtime_error = TRUE;\n }\n\n return;\n\n}\n\n./ ADD NAME=NNMBTRAS\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BTRAS\")\n#pragma  csect(static,\"NN$BTRAS\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Trash extraneous data in command line. ***********************/\n\nvoid\nNNMbtras(np,bp,name)\nRstruc nncb         *np;\nRstruc batch        *bp;\nchar                *name;\n{\n struct token       *tp;\n Bool                finished = FALSE;\n char                tmp\u00dd81\u00a8;\n\n /*\n  * Pull tokens until semicolon or EOF.  Note that EOL will not be\n  * considered the end of the datum stream, because the user may wish\n  * to specify a long list that takes several lines.  Therefore, an\n  * explicit semicolon is required to terminate the list.\n  */\n\n while (!finished && (tp = PEEK())) {\n   switch (tp->type) {\n     case EOL_TOKEN:\n     case EOF_TOKEN:\n     case SEMI_TOKEN: EAT();\n                      finished = TRUE;\n                      break;\n     default:         EAT();\n                      sprintf(tmp,\"Extraneous data in %s command\",name);\n                      NNMbsynt(np,bp,tp->string,0,tmp);\n                      break;\n   }\n }\n\n return;\n}\n\n./ ADD NAME=NNMBVGET\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BVGET\")\n#pragma  csect(static,\"NN$BVGET\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Report type mismatch error. **********************************/\n\nstatic void\ntype_error(np,var,type1,type2)\nRstruc nncb     *np;\nchar            *var;\nchar            *type1;\nchar            *type2;\n{\n\n ERR4(\"Type mismatch: \\\nCannot retrieve a value of type %s from %s variable %s.\",\n      type1,type2,var);\n\n return;\n\n}\n\n/****** Get a value from the symbol table. ***************************/\n\nANYTYPE\nNNMbvget(np,bp,var,type)\nRstruc nncb         *np;\nRstruc batch        *bp;\nchar                *var;\nenum symtype         type;\n{\n Rstruc symtab      *symp;\n int                 varlen;\n char                vartest\u00ddMAX_SYMBOL_LENGTH\u00a8;\n\n varlen = strlen(var);\n if (varlen < 1 || varlen > MAX_SYMBOL_LENGTH) {\n   ERR2(\n    \"A variable name must be between 1 and %d characters in length.\",\n        MAX_SYMBOL_LENGTH);\n   return FALSE;\n }\n\n memset(vartest,'\\0',MAX_SYMBOL_LENGTH);\n memcpy(vartest,var,varlen);\n\n symp = bp->symtabp;\n\n while (symp) {\n   switch (memcmp(vartest, symp->symvar, MAX_SYMBOL_LENGTH)) {\n     case 0:   /* equal   */\n               break;\n     case 1:   /* greater */\n               symp = symp->right;\n               continue;\n     default:  /* less    */\n               symp = symp->left;\n               continue;\n   }\n   break;\n }\n\n /* Special case, just to see if the variable exists or not. */\n\n if (type == NO_SYMTYPE)\n    return (symp ? (ANYTYPE)symp->type : (ANYTYPE)NO_SYMTYPE);\n\n if (!symp) {\n   ERR2(\"The variable %s has not been declared or set to a value.\",var);\n   return NULL;\n }\n\n /*------------------------------------------------------------------*\n  *                                                                  *\n  * Table of allowable type-to-type settings:                        *\n  *                                                                  *\n  * symp->type |   type      | result                                *\n  *____________|_____________|_________________________________      *\n  * STRING     |   STRING    | OK                                    *\n  *            |   NUMBER    | error                                 *\n  *            |   FLAG      | error                                 *\n  *____________|_____________|_________________________________      *\n  * NUMBER     |   STRING    | convert to string via sprintf %d      *\n  *            |   NUMBER    | OK                                    *\n  *            |   FLAG      | interpret as nonzero or zero          *\n  *____________|_____________|_________________________________      *\n  * FLAG       |   STRING    | convert to \"1\" or \"0\"                 *\n  *            |   NUMBER    | convert to 1 or 0                     *\n  *            |   FLAG      | OK                                    *\n  *            |             |                                       *\n  *------------------------------------------------------------------*/\n\n switch (symp->type) {\n   case STRING_SYMTYPE:\n        switch (type) {\n          case STRING_SYMTYPE: return (ANYTYPE)symp->symval;\n\n          case NUMBER_SYMTYPE: type_error(np,var,\"NUMBER\",\"STRING\");\n                               break;\n          case FLAG_SYMTYPE:   type_error(np,var,\"FLAG\",\"STRING\");\n                               break;\n        }\n        break;\n   case NUMBER_SYMTYPE:\n        switch (type) {\n          case STRING_SYMTYPE: sprintf(symp->symval,\"%d\",symp->symnum);\n                               return (ANYTYPE)symp->symval;\n\n          case NUMBER_SYMTYPE: return (ANYTYPE)symp->symnum;\n\n          case FLAG_SYMTYPE:   return (symp->symnum\n                                       ? (ANYTYPE)1 : (ANYTYPE)0);\n\n        }\n        break;\n   case FLAG_SYMTYPE:\n        switch (type) {\n          case STRING_SYMTYPE: return (symp->symnum\n                                       ? (ANYTYPE)\"1\" : (ANYTYPE)\"0\");\n\n          case NUMBER_SYMTYPE: return (symp->symnum\n                                       ? (ANYTYPE)1 : (ANYTYPE)0);\n\n          case FLAG_SYMTYPE:   return (symp->symnum\n                                       ? (ANYTYPE)1 : (ANYTYPE)0);\n\n        }\n        break;\n }\n\n return NULL;\n}\n\n./ ADD NAME=NNMBVPUT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BVPUT\")\n#pragma  csect(static,\"NN$BVPUT\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Report type mismatch error. **********************************/\n\nstatic void\ntype_error(np,var,type1,type2)\nRstruc nncb     *np;\nchar            *var;\nchar            *type1;\nchar            *type2;\n{\n\n ERR4(\"Type mismatch: \\\nCannot assign a value of type %s to %s variable %s.\",\n      type1,type2,var);\n\n return;\n\n}\n\n/****** Set value of symbol table entry. *****************************/\n\nstatic void\nset_value(np,sp,var,val,type)\nRstruc nncb     *np;\nstruct symtab   *sp;\nchar            *var;\nANYTYPE          val;\nenum symtype     type;\n{\n\n /*------------------------------------------------------------------*\n  *                                                                  *\n  * Table of allowable type-to-type settings:                        *\n  *                                                                  *\n  * sp->type   |   type      | result                                *\n  *____________|_____________|_________________________________      *\n  * STRING     |   STRING    | OK                                    *\n  *            |   NUMBER    | convert to string via sprintf %d      *\n  *            |   FLAG      | error                                 *\n  *____________|_____________|_________________________________      *\n  * NUMBER     |   STRING    | error                                 *\n  *            |   NUMBER    | OK                                    *\n  *            |   FLAG      | convert to 1 or 0                     *\n  *____________|_____________|_________________________________      *\n  * FLAG       |   STRING    | error                                 *\n  *            |   NUMBER    | interpret as nonzero or zero          *\n  *            |   FLAG      | OK                                    *\n  *            |             |                                       *\n  *------------------------------------------------------------------*/\n\n switch (sp->type) {\n   case STRING_SYMTYPE:\n        switch (type) {\n          case STRING_SYMTYPE: strcpy(sp->symval,(char *)val);\n                               break;\n          case NUMBER_SYMTYPE: sprintf(sp->symval,\"%d\",(int)val);\n                               break;\n          case FLAG_SYMTYPE:   type_error(np,var,\"FLAG\",\"STRING\");\n                               break;\n        }\n        break;\n   case NUMBER_SYMTYPE:\n        switch (type) {\n          case STRING_SYMTYPE: type_error(np,var,\"STRING\",\"NUMBER\");\n                               break;\n          case NUMBER_SYMTYPE: sp->symnum = (int)val;\n                               break;\n          case FLAG_SYMTYPE:   sp->symnum = (Fool)val ? 1 : 0;\n                               break;\n        }\n        break;\n   case FLAG_SYMTYPE:\n        switch (type) {\n          case STRING_SYMTYPE: type_error(np,var,\"STRING\",\"FLAG\");\n                               break;\n          case NUMBER_SYMTYPE: sp->symnum = (int)val ? 1 : 0;\n                               break;\n          case FLAG_SYMTYPE:   sp->symnum = (Fool)val ? 1 : 0;\n                               break;\n        }\n        break;\n }\n\n if (np->debug_file) {\n   switch (sp->type) {\n     case STRING_SYMTYPE:  fprintf(np->debug_file,\n                                   \"NNMbvput: %s set to '%s'\\n\",\n                                   sp->symvar, sp->symval);\n                           break;\n     case NUMBER_SYMTYPE:  fprintf(np->debug_file,\n                                   \"NNMbvput: %s set to %d\\n\",\n                                   sp->symvar, sp->symnum);\n                           break;\n     case FLAG_SYMTYPE:    fprintf(np->debug_file,\n                                   \"NNMbvput: %s set to %s\\n\",\n                                   sp->symvar,\n                                   sp->symnum ? \"TRUE\" : \"FALSE\");\n                           break;\n   }\n }\n\n return;\n}\n\n/****** Put a value into the symbol table. ***************************/\n\nvoid\nNNMbvput(np,bp,var,type,val)\nRstruc nncb         *np;\nRstruc batch        *bp;\nchar                *var;\nenum symtype         type;\nANYTYPE              val;\n{\n Rstruc symtab      *symp;\n Rstruc symtab     **sympref;\n struct symtab      *sympnew;\n struct symtab      *sympleft;\n struct symtab      *sympright;\n enum symtype        symptype;\n int                 varlen;\n int                 minimum_value_length;\n int                 getlen;\n int                 comp;\n Bool                symbol_found;\n char                vartest\u00ddMAX_SYMBOL_LENGTH\u00a8;\n\n varlen = strlen(var);\n if (varlen < 1 || varlen > MAX_SYMBOL_LENGTH) {\n   ERR2(\n    \"A variable name must be between 1 and %d characters in length.\",\n        MAX_SYMBOL_LENGTH);\n   return;\n }\n\n memset(vartest,'\\0',MAX_SYMBOL_LENGTH);\n memcpy(vartest,var,varlen);\n\n switch (type) {\n   case STRING_SYMTYPE: minimum_value_length = strlen((char *)val) + 1;\n                        break;\n   case NUMBER_SYMTYPE: minimum_value_length = 12;\n                        break;\n   case FLAG_SYMTYPE:   minimum_value_length = 6;\n                        break;\n }\n\n symbol_found = FALSE;\n\n sympleft  = NULL;\n sympright = NULL;\n sympref   = &bp->symtabp;\n\n while ((symp=*sympref)) {\n   switch ((comp=memcmp(vartest, symp->symvar, MAX_SYMBOL_LENGTH))) {\n     case 0:   /* equal   */\n               symbol_found = TRUE;\n               /* free this entry and allocate a new one if this one\n                  is too small to hold the requested value */\n               if (minimum_value_length > symp->vallen) {\n                 symptype  = symp->type;\n                 sympleft  = symp->left;\n                 sympright = symp->right;\n                 FREEMAIN(*sympref,\"old symbol table entry\");\n                 *sympref = NULL;\n                 break;\n               }\n               else {\n                 set_value(np,symp,var,val,type);\n                 return;\n               }\n     case 1:   /* greater */\n               sympref = &symp->right;\n               continue;\n     default:  /* less    */\n               sympref = &symp->left;\n               continue;\n   }\n }\n\n /* Symbol not found - not allowed, means variable not declared */\n\n if (!symbol_found) {\n   ERR2(\"The variable %s has not been declared or set to a value.\",var);\n   return;\n }\n\n getlen = offsetof(struct symtab, symval) + minimum_value_length;\n\n GETMAIN(sympnew, char, getlen, \"new symbol table entry\");\n if (!sympnew) {\n   ERR2(\"Cannot set variable: \\\nUnable to allocate storage to hold value for variable %s.\",\n        var);\n   return;\n }\n\n memcpy(sympnew->symvar, vartest, MAX_SYMBOL_LENGTH);\n sympnew->left   = sympleft;\n sympnew->right  = sympright;\n sympnew->vallen = minimum_value_length;\n sympnew->type   = symptype;\n *sympref        = sympnew;\n\n set_value(np,sympnew,var,val,type);\n\n return;\n\n}\n\n./ ADD NAME=NNMBXFAR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BXFAR\")\n#pragma  csect(static,\"NN$BXFAR\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Execute batch FOR articles command. **************************/\n\nstruct variablesave {\n                     int        number;\n                     Bool       read;\n                     Bool       missing;\n                     char      *subject;\n                     char      *date;\n                     char      *from;\n                     char      *messageid;\n                    };\n\n/****** Set article variables. ***************************************/\n\nstatic void\nset_article_variables(np,bp,vp,anum,vsp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nVARK                        *vp;\nint                          anum;\nstruct variablesave         *vsp;\n{\n Rstruc newsarticle         *ap = VARK2PARTICLE(*vp);\n\n vsp->number     = GETA(\"NUMBER\");\n vsp->read       = GETB(\"READ\");\n vsp->missing    = GETB(\"MISSING\");\n vsp->subject    = NNMcopy(np,GETC(\"SUBJECT\"));\n vsp->date       = NNMcopy(np,GETC(\"DATE\"));\n vsp->from       = NNMcopy(np,GETC(\"FROM\"));\n vsp->messageid  = NNMcopy(np,GETC(\"MESSAGEID\"));\n\n SETA(\"NUMBER\",       anum);\n SETB(\"READ\",         IsRead(*vp));\n if (IsMissing(*vp)) {\n   SETB(\"MISSING\",    TRUE);\n   SETC(\"SUBJECT\",    \"\");\n   SETC(\"DATE\",       \"\");\n   SETC(\"FROM\",       \"\");\n   SETC(\"MESSAGEID\",  \"\");\n }\n else {\n   SETB(\"MISSING\",    FALSE);\n   SETC(\"SUBJECT\",    ap->subject);\n   SETC(\"DATE\",       ap->date);\n   SETC(\"FROM\",       ap->from);\n   SETC(\"MESSAGEID\",  ap->message_id);\n }\n\n return ;\n}\n\n/****** Unset article variables. *************************************/\n\nstatic void\nunset_article_variables(np,bp,vsp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nstruct variablesave         *vsp;\n{\n\n SETA(\"NUMBER\",    vsp->number);\n SETB(\"READ\",      vsp->read);\n SETB(\"MISSING\",   vsp->missing);\n SETC(\"SUBJECT\",   vsp->subject);\n SETC(\"DATE\",      vsp->date);\n SETC(\"FROM\",      vsp->from);\n SETC(\"MESSAGEID\", vsp->messageid);\n\n FREEMAIN(vsp->subject,   \"saved copy of SUBJECT\");\n FREEMAIN(vsp->date,      \"saved copy of DATE\");\n FREEMAIN(vsp->from,      \"saved copy of FROM\");\n FREEMAIN(vsp->messageid, \"saved copy of MESSAGEID\");\n\n return;\n}\n\n/****** Reset newsgroup variables. ***********************************/\n\nstatic void\nreset_newsgroup_variables(np,bp,gp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nRstruc newsgroup            *gp;\n{\n\n SETA(\"COUNT\"      ,gp->article_count);\n SETA(\"UNREAD\"     ,gp->unread_count);\n SETA(\"FIRST\"      ,gp->low_number);\n SETA(\"LAST\"       ,gp->high_number);\n\n return ;\n}\n\n/****** Execute article commands. ************************************/\n\nstatic void\nexecute_article_commands(np,bp,vp,treep)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nVARK                        *vp;\nstruct cmdtree              *treep;\n{\n VARK                       *savevp;\n\n for (; treep; treep = treep->next) {\n   bp->runtime_error = FALSE;\n   savevp = bp->vp;\n   bp->vp = vp;\n   (treep->cmd->proc) (np,bp,treep->cmd);\n   bp->vp = savevp;\n   SETB(\"ERROR\",bp->runtime_error);\n }\n\n return;\n}\n\n/****** Test if article passes filter. *****************************/\n\nstatic Bool\npass_filter(np,bp,filter)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nstruct ptree                *filter;\n{\n Bool                        passes_filter;\n\n if (filter) {\n   passes_filter = (Fool)NNMbbexp(np,bp,filter,FLAG_SYMTYPE);\n   if (bp->runtime_error) {\n     bp->request_errors++;\n     passes_filter = FALSE;\n   }\n }\n else passes_filter = TRUE;\n\n return passes_filter;\n}\n\n/****** Test if article passes criterion. ****************************/\n\nstatic Bool\npass_criterion(np,bp,vp,anum,which,first,last)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nVARK                        *vp;\nint                          anum;\nenum which_articles          which;\nstruct ptree                *first;\nstruct ptree                *last;\n{\n int                         firstnum;\n int                         lastnum;\n\n switch (which) {\n   case ALL_ARTICLES:\n            return TRUE;\n   case READ_ARTICLES:\n            return (IsRead(*vp));\n   case UNREAD_ARTICLES:\n            return (IsUnread(*vp));\n   case RANGED_ARTICLES:\n            if (first)\n                 firstnum = (int)NNMbbexp(np,bp,first,NUMBER_SYMTYPE);\n            else firstnum = FIRST_ARTICLE_IN_RANGE;\n            if (last)\n                 lastnum  = (int)NNMbbexp(np,bp,last, NUMBER_SYMTYPE);\n            else lastnum  = firstnum;\n            return (anum >= firstnum && anum <= lastnum);\n   case NO_ARTICLES:\n            return FALSE;\n   default:\n            return FALSE;\n }\n\n}\n\n/****** Execute batch FOR articles command. **************************/\n\nvoid\nNNMbxfar(np,bp,cmdp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nRstruc newscmd              *cmdp;\n{\n Rstruc newsgroup           *gp;\n Rstruc newsarticle         *ap;\n VARK                       *vp;\n struct ptree               *filter;\n struct cmdtree             *treep;\n struct ptree               *first;\n struct ptree               *last;\n int                         anum;\n enum which_articles         which;\n struct variablesave         varsave;\n\n filter = cmdp->cmd.ncmd.fors.filter;\n treep  = cmdp->cmd.ncmd.fors.treep;\n which  = cmdp->cmd.ncmd.fors.crit.which;\n first  = cmdp->cmd.ncmd.fors.crit.first;\n last   = cmdp->cmd.ncmd.fors.crit.last;\n\n gp = bp->gp;\n\n /* Logic:  (1) apply \"which\" criteria\n  *         (2) set variables for articles remaining\n  *         (3) apply filters\n  * Rationale:  Variables must be set before filters can use them.\n  *             But criteria can be used to reduce the load.\n  */\n\n np->current_newsgroup   = gp;\n np->newsgroup_selected  = FALSE;\n\n if (!GroupSelected(gp)) gp = NNMdng(np,gp,NULL);\n if (!gp) return;\n\n bp->gp = gp;\n reset_newsgroup_variables(np,bp,gp);\n if (gp->article_vector) {\n   for (anum = gp->vector_first; anum <= gp->vector_last; anum++) {\n     vp = &GETVARK(gp,anum);\n     if (pass_criterion(np,bp,vp,anum,which,first,last)) {\n       if (NNMrarh(np,gp,vp,anum,NULL)) { /* retrieve article hdr */\n         set_article_variables(np,bp,vp,anum,&varsave);\n         if (pass_filter(np,bp,filter)) {\n           execute_article_commands(np,bp,vp,treep);\n         }\n         unset_article_variables(np,bp,&varsave);\n       }\n     }\n   }\n }\n\n np->current_newsgroup  = NULL;\n np->newsgroup_selected = FALSE;\n\n return;\n}\n\n./ ADD NAME=NNMBXFNG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@BXFNG\")\n#pragma  csect(static,\"NN$BXFNG\")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\nstruct variablesave {\n                     char      *group;\n                     Bool       registered;\n                     Bool       newgroup;\n                     Bool       nosuchgroup;\n                     int        count;\n                     int        unread;\n                     int        first;\n                     int        last;\n                    };\n\n/****** Set newsgroup variables. *************************************/\n\nstatic void\nset_newsgroup_variables(np,bp,gp,vsp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nRstruc newsgroup            *gp;\nstruct variablesave         *vsp;\n{\n\n vsp->group       = NNMcopy(np,GETC(\"GROUP\"));\n vsp->registered  = GETB(\"REGISTERED\");\n vsp->newgroup    = GETB(\"NEWGROUP\");\n vsp->nosuchgroup = GETB(\"NOSUCHGROUP\");\n vsp->count       = GETA(\"COUNT\");\n vsp->unread      = GETA(\"UNREAD\");\n vsp->first       = GETA(\"FIRST\");\n vsp->last        = GETA(\"LAST\");\n\n SETC(\"GROUP\"      ,gp->name);\n SETA(\"COUNT\"      ,gp->article_count);\n SETA(\"UNREAD\"     ,gp->unread_count);\n SETA(\"FIRST\"      ,gp->low_number);\n SETA(\"LAST\"       ,gp->high_number);\n SETB(\"REGISTERED\" ,(gp->registered > 0) ? TRUE : FALSE);\n\n if (NewGroup(gp)) {  /* if new newsgroup */\n   fprintf(np->batch_outfile,\"New newsgroup: %s (%d articles)\\n\",\n                             gp->name, gp->article_count);\n   gp->registered = -1;\n   SETB(\"NEWGROUP\",TRUE);\n }\n else if (gp->registered == -1) {  /* old way: if new newsgroup */\n   fprintf(np->batch_outfile,\"New newsgroup: %s (%d articles)\\n\",\n                             gp->name, gp->article_count);\n   SetNewGroup(gp);\n   SETB(\"NEWGROUP\",TRUE);\n }\n else {\n   OffNewGroup(gp);\n   SETB(\"NEWGROUP\",FALSE);\n }\n\n if (BogusGroup(gp)) {\n   fprintf(np->batch_outfile,\"Nonexistent newsgroup: %s\\n\", gp->name);\n   SetNoSuchGroup(gp);\n   SETB(\"NOSUCHGROUP\",TRUE);\n }\n else {\n   SETB(\"NOSUCHGROUP\",FALSE);\n }\n\n return ;\n}\n\n/****** Unset newsgroup variables. **********************************/\n\nstatic void\nunset_newsgroup_variables(np,bp,gp,vsp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nRstruc newsgroup            *gp;\nstruct variablesave         *vsp;\n{\n\n SETC(\"GROUP\"       ,vsp->group);\n SETB(\"REGISTERED\"  ,vsp->registered);\n SETB(\"NEWGROUP\"    ,vsp->newgroup);\n SETB(\"NOSUCHGROUP\" ,vsp->nosuchgroup);\n SETA(\"COUNT\"       ,vsp->count);\n SETA(\"UNREAD\"      ,vsp->unread);\n SETA(\"FIRST\"       ,vsp->first);\n SETA(\"LAST\"        ,vsp->last);\n\n FREEMAIN(vsp->group,\"saved copy of GROUP\");\n\n return ;\n}\n\n/****** See if new newsgroup. ****************************************/\n\nstatic void\nsee_if_new_newsgroup(np,bp,gp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nRstruc newsgroup            *gp;\n{\n\n if (NewGroup(gp)) {  /* if new newsgroup */\n\n   if (GETB(\"AUTOREGISTER\")) {\n     gp->registered = 1;\n     SETB(\"REGISTERED\",TRUE);\n     fprintf(np->batch_outfile,\n            \"Added newsgroup %s as REGISTERED\\n\", gp->name);\n   }\n   else {\n     gp->registered = 0;\n     SETB(\"REGISTERED\",FALSE);\n     fprintf(np->batch_outfile,\n            \"Added newsgroup %s as UNREGISTERED\\n\", gp->name);\n   }\n }\n\n return;\n}\n\n/****** See if bogus newsgroup. **************************************/\n\nstatic void\nsee_if_bogus_newsgroup(np,bp,gp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nRstruc newsgroup            *gp;\n{\n\n if (BogusGroup(gp)) {\n\n   if (GETB(\"AUTODELETE\")) {\n     SetNoSuchGroup(gp);\n     OffGroupListed(gp);\n     fprintf(np->batch_outfile, \"Deleted newsgroup %s\\n\", gp->name);\n   }\n   else {\n     SetGroupListed(gp);\n     fprintf(np->batch_outfile, \"Kept newsgroup %s\\n\", gp->name);\n   }\n }\n\n return;\n}\n\n/****** Execute newsgroup commands. **********************************/\n\nstatic void\nexecute_newsgroup_commands(np,bp,gp,treep)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nRstruc newsgroup            *gp;\nstruct cmdtree              *treep;\n{\n struct newsgroup           *savegp;\n\n for (; treep; treep = treep->next) {\n   bp->runtime_error = FALSE;\n   savegp = bp->gp;\n   bp->gp = gp;\n   (treep->cmd->proc) (np,bp,treep->cmd);\n   bp->gp = savegp;\n   SETB(\"ERROR\",bp->runtime_error);\n }\n\n return;\n}\n\n/****** Test if newsgroup passes filter. *****************************/\n\nstatic Bool\npass_filter(np,bp,gp,filter)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nRstruc newsgroup            *gp;\nstruct ptree                *filter;\n{\n Bool                        passes_filter;\n\n if (filter) {\n   passes_filter = (Fool)NNMbbexp(np,bp,filter,FLAG_SYMTYPE);\n   if (bp->runtime_error) {\n     bp->request_errors++;\n     passes_filter = FALSE;\n   }\n }\n else passes_filter = TRUE;\n\n return passes_filter;\n\n}\n\n/****** Match group name against group string. ***********************/\n\nstatic Bool\nmatch(name,string)\nchar    *name;\nchar    *string;\n{\n\n return FALSE;\n}\n\n/****** See if group name is in group string. ************************/\n\nstatic Bool\nin(name,string)\nchar    *name;\nchar    *string;\n{\n char   *s;\n char   *cp1;\n char   *cp2;\n char   *cp3;\n\n s = string;\n for (;;) {\n   cp1 = strstr(s,name);\n   if (!cp1) return FALSE;\n   cp2 = cp1-1;\n   if (cp2 < string || *cp2 == ' ' || *cp2 == '\\t' || *cp2 == ',') {\n     cp3 = cp1+strlen(name);\n     if (*cp3 == '\\0' || *cp3 == ' ' || *cp3 == '\\t' || *cp3 == ',') {\n       return TRUE;\n     }\n   }\n   s = cp1 + 1;\n   continue;\n }\n}\n\n/****** Test if newsgroup passes criterion. **************************/\n\nstatic Bool\npass_criterion(np,bp,gp,which,groups)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nRstruc newsgroup            *gp;\nenum which_newsgroups        which;\nstruct ptree                *groups;\n{\n char                       *groupstring;\n\n if (groups) {\n   groupstring = NNMbbexp(np,bp,groups,STRING_SYMTYPE);\n   lowercase_in_place(groupstring);\n }\n\n switch (which) {\n   case ALL_NEWSGROUPS:           return TRUE;\n   case REGISTERED_NEWSGROUPS:    return (gp->registered >  0);\n   case UNREGISTERED_NEWSGROUPS:  return (gp->registered == 0);\n   case NAMED_NEWSGROUPS:         return in(gp->name,groupstring);\n   case MASKED_NEWSGROUPS:\n fprintf(np->batch_outfile,\"Sorry, cannot handle MASKED_NEWSGROUPS.\\n\");\n                                  return match(gp->name,groupstring);\n   case NO_NEWSGROUPS:            return FALSE;\n   default:                       return FALSE;\n }\n\n}\n\n/****** Execute batch FOR newsgroups command. ************************/\n\nvoid\nNNMbxfng(np,bp,cmdp)\nRstruc nncb                 *np;\nRstruc batch                *bp;\nRstruc newscmd              *cmdp;\n{\n Rstruc newsgroup           *gp;\n struct ptree               *filter;\n struct cmdtree             *treep;\n struct ptree               *groups;\n enum which_newsgroups       which;\n struct variablesave         varsave;\n Bool                        serverlist;\n\n filter = cmdp->cmd.icmd.fors.filter;\n treep  = cmdp->cmd.icmd.fors.treep;\n which  = cmdp->cmd.icmd.fors.crit.which;\n groups = cmdp->cmd.icmd.fors.crit.groups;\n\n /* Connect to server. */\n\n if (!NNMbconn(np,bp)) {\n   fprintf(np->batch_outfile,\"No newsgroup commands executed.\\n\");\n   bp->request_errors++;\n   return;\n }\n\n /* Determine source of newsgroups - SERVER or NEWSRC. */\n /* If SERVERLIST is true, do an NNTP list.  Otherwise */\n /* use NEWSRC and do individual group requests...     */\n\n /* If we do get the newsgroups via LIST, do it only once. */\n\n serverlist = GETB(\"SERVERLIST\");\n\n if (serverlist) {\n   if (!bp->newsgroups_retrieved) {\n     if (!NNMdlang(np,LIST_ALL)) { /* get list of all grps fr server */\n       fprintf(np->batch_outfile,\"No newsgroups processed.\\n\");\n       bp->request_errors++;\n       return;\n     }\n     bp->newsgroups_retrieved = TRUE;\n   }\n }\n\n /* Logic:  (1) apply \"which\" criteria\n  *         (2) set variables for groups remaining\n  *         (3) apply filters\n  * Rationale:  Variables must be set before filters can use them.\n  *             But criteria can be used to reduce the load.\n  */\n\n /* The list of newsgroups has already been built from newsrc at this\n  * point.  Now, if the source is the server, then ask NNTP to get\n  * the current list of newsgroups and process it against the list\n  * from NEWSRC.  If the source is NEWSRC, then get the current status\n  * of each newsgroup via the NNTP \"group\" command (slow).\n  */\n\n /* Note that the position of see_if_new_newsgroup determines if new\n  * newsgroups are to be registered depending on AUTOREGISTER *after*\n  * the filtering or *before*.  If *after*, then all groups that are\n  * not handled get autoregistered as DEREGISTERED.\n  */\n\n for (gp = np->first_newsgroup; gp; gp = gp->next) {\n   if (pass_criterion(np,bp,gp,which,groups)) {\n     if (!serverlist) {\n       NNMdng(np,gp,NULL);             /* do newsgroup by address */\n       if (np->newsgroup_not_found) {\n         SetNoSuchGroup(gp);\n         gp->article_count = 0;\n         gp->unread_count  = 0;\n       }\n     }\n     set_newsgroup_variables(np,bp,gp,&varsave);\n     if (pass_filter(np,bp,gp,filter)) {\n       see_if_new_newsgroup(np,bp,gp);\n       see_if_bogus_newsgroup(np,bp,gp);\n       if (!NoSuchGroup(gp)) {\n         execute_newsgroup_commands(np,bp,gp,treep);\n       }\n     }\n     unset_newsgroup_variables(np,bp,gp,&varsave);\n   }\n }\n\n return;\n}\n\n./ ADD NAME=NNMCAR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@CAR  \")\n#pragma  csect(static,\"NN$CAR  \")\n#include \"nn.h\"\n\n/****** Choose article (Determine if it is eligible for display) *****/\n\nBool\nNNMcar(np,gp,anum,vp,app,cdp,carfun)\nRstruc nncb           *np;\nRstruc newsgroup      *gp;\nint                    anum;\nVARK                  *vp;\nstruct newsarticle   **app;\nstruct countdown      *cdp;\nenum choose_reason     carfun;\n{\n Rstruc newsarticle   *ap = NULL;\n Bool                  rc = FALSE;\n\n /* If vp is null, anum must be nonzero.\n  * If vp is provided, anum may be zero, in which case NNMrarh will\n  * figure out what it is if it needs to.  Not to worry here.\n  */\n\n if (!vp) vp = &GETVARK(gp,anum);\n\n if (IsUnknown(*vp)) {\n   if (np->show_all_articles        /* if \"A\"ll requested           */\n    || IsUnread(*vp)                /* or \"S\" and article not read  */\n    || (!np->unread_articles_only   /* or article already in table  */\n        && IsPresent(*vp)\n        && (ap=VARK2PARTICLE(*vp)) && ArticleRetrieved(ap))) {\n     if (*np->article_only_string) {\n       SetKnownIneligible(*vp);\n       if (!ap) ap = NNMrarh(np,gp,vp,anum,cdp);\n       if (ap && IsPresent(*vp)) {\n         if (NNMstrlc(ap->subject,np->article_only_string)) {\n           SetKnownEligible(*vp);\n           rc = TRUE;\n         }\n       }\n     }\n     else {                      /* no ONLY string */\n       if (carfun != MARK_ONLY) {\n         SetKnownIneligible(*vp);\n         if (!ap) ap = NNMrarh(np,gp,vp,anum,cdp);\n         if (ap && IsPresent(*vp)) {\n           SetKnownEligible(*vp);\n           rc = TRUE;\n         }\n       }\n       else {\n         ap = VARK2PARTICLE(*vp);\n         if (ap != V_NULL_ARTICLE && ap != V_MISSING_ARTICLE) {\n           rc = TRUE;  /* just return for marking, don't set up etc. */\n         }\n       }\n     }\n   }\n   else SetKnownIneligible(*vp);\n }\n\n if (IsEligible(*vp)) {\n   rc = TRUE;\n   if (!ap) ap = VARK2PARTICLE(*vp);\n }\n\n if (rc && app) *app = ap;\n return rc;\n}\n\n./ ADD NAME=NNMCLRNG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@CLRNG\")\n#pragma  csect(static,\"NN$CLRNG\")\n#include \"nn.h\"\n\n/****** Clear newsgroups. ********************************************/\n\nvoid\nNNMclrng(np)\nRstruc nncb           *np;\n{\n Rstruc newsgroup     *gp1;\n Rstruc newsgroup     *gp2;\n VARK                 *vp;\n VARK                 *vpfirst;\n VARK                 *vplast;\n\n np->newsgroup_selected = FALSE;\n np->new_newsgroup_count = 0;\n\n gp1 = np->first_newsgroup;\n while (gp1) {\n  gp2 = gp1->next;\n  if (gp1->article_vector) {\n    vpfirst = &GETVARKFIRST(gp1);\n    vplast  = &GETVARKLAST(gp1);\n    for (vp = vpfirst; vp <= vplast; vp++) {\n      if (IsPresent(*vp)) {\n        NNMclrtx(np,VARK2PARTICLE(*vp));\n      }\n    }\n  }\n  FREEMAIN(gp1->sort_vector,        \"newsgroup sort vector\");\n  FREEMAIN(gp1->article_vector,     \"newsgroup article vector\");\n  if (gp1->saved_newsrc_line != gp1->saved_newsrc_data) {\n    FREEMAIN(gp1->saved_newsrc_line,\"newsgroup newsrc line\");\n  }\n  FREEMAIN(gp1,                     \"newsgroup\");\n  gp1 = gp2;\n }\n\n np->first_newsgroup      = NULL;\n np->first_newsgroup_alt  = NULL;\n np->current_newsgroup    = NULL;\n np->last_newsgroup       = NULL;\n np->last_added_newsgroup = NULL;\n\n return;\n}\n\n./ ADD NAME=NNMCLRTX\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@CLRTX\")\n#pragma  csect(static,\"NN$CLRTX\")\n#include \"nn.h\"\n\n/****** Clear text. **************************************************/\n\nvoid\nNNMclrtx(np,ap)\nRstruc nncb           *np;\nRstruc newsarticle    *ap;\n\n{\n Rstruc texthdr       *thp;\n Rstruc textline      *tp1;\n Rstruc textline      *tp2;\n\n /* If article is not specified, use main nncb, else article's text */\n\n thp = (ap ? &ap->thdr : &np->thdr);\n\n tp1 = thp->first_text_line;\n while (tp1) {\n  tp2 = tp1->next;\n  FREEMAIN(tp1,\"text line\");\n  tp1 = tp2;\n }\n\n thp->text_body_line    = NULL;\n thp->first_text_line   = NULL;\n thp->current_text_line = NULL;\n thp->last_text_line    = NULL;\n thp->text_line_count   = 0;\n thp->text_max_length   = 0;\n thp->text_max_tab_expanded_length   = 0;\n\n return;\n\n}\n\n./ ADD NAME=NNMCNRF\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@CNRF \")\n#pragma  csect(static,\"NN$CNRF \")\n#include \"nn.h\"\n\n/*** Write to newsrc file. *******************************************/\n\nstatic Bool\nwrite_to_newsrc(np,newsrc_line,thing)\nRstruc nncb        *np;\nchar               *newsrc_line;\nchar               *thing;\n{\n char              *newlinep;\n Bool               write_ok = TRUE;\n\n if (!*thing) return TRUE;\n\n newlinep = strchr(thing,'\\n');\n if (newlinep) {\n   while (newlinep) {\n     strncat(newsrc_line,thing,newlinep-thing);\n     if (fprintf(np->newsrc_file,\"%s\\n\",newsrc_line) < 0)\n         write_ok = FALSE;\n     strcpy(newsrc_line,\"\");\n     thing = newlinep + 1;\n     newlinep = strchr(thing,'\\n');\n   }\n   strcat(newsrc_line,thing);\n   return write_ok;\n }\n\n if (strlen(newsrc_line) + strlen(thing) > 250) {\n   if (fprintf(np->newsrc_file,\"%s\\n\",newsrc_line) < 0)\n       write_ok = FALSE;\n   strcpy(newsrc_line,\" \");\n }\n strcat(newsrc_line,thing);\n return write_ok;\n}\n\n/****** Close NEWSRC file. *******************************************/\n\nvoid\nNNMcnrf(np,what_to_open,updating)\nRstruc nncb         *np;\nchar                *what_to_open;\nFool                 updating;\n{\n Rstruc newsgroup   *gp1;\n int                 newsrc_unread;\n int                 newsrc_topnum;\n int                 newsrc_count;\n register int        iv;\n int                 read0;\n int                 read1;\n int                 read2;\n int                 read3;\n Bool                write_ok;\n char                newsrc_line\u00dd257\u00a8;\n char                newsrc_numb\u00dd32\u00a8;\n\n write_ok = TRUE;\n\n /* If the file is currently open for input, close it first. */\n\n if (np->newsrc_file) {\n   if (fclose(np->newsrc_file) < 0) {\n     fprintf(stderr,\"%s: Error closing NEWSRC file\\n\",what_to_open);\n   }\n   np->newsrc_file = NULL;\n }\n\n if (!updating) return;\n\n /* Open the file for output.  This will empty it at first. */\n\n if (!what_to_open) what_to_open = np->newsrc_to_open;\n\n np->newsrc_file = fopen(what_to_open,\"w\");\n if (np->newsrc_file == NULL) {\n   perror(\"Cannot open NEWSRC file\");\n   return;\n }\n\n if (np->update_rewriting_newsrc) {\n   if (!np->batch_mode) {\n     (void)NNMispf(np,\"CONTROL DISPLAY LOCK\");\n     (void)NNMispf(np,\"DISPLAY PANEL(NNMLUNRC)\");\n   }\n }\n\n /* Write current status into the file. */\n\n /********************************************************************/\n /*                                                                  */\n /* Note:  The format used here is designed to be compatible with    */\n /*        the format used by ANU-NEWS.  This is not an attempt to   */\n /*        duplicate the \"look and feel\" of ANU-NEWS - it is just    */\n /*        to be compatible with the saved state of VAX NEWS users.  */\n /*                                                                  */\n /********************************************************************/\n\n /* First record: time of last update in hex, current newsgroup, blah */\n\n if (fprintf(np->newsrc_file,\"%.6s %.6s %s\\n\",\n            np->lastNGdate, np->lastNGtime,\n            np->current_newsgroup ? np->current_newsgroup->name : \" \")\n     < 0) write_ok = FALSE;\n\n for (gp1=np->first_newsgroup; gp1; gp1=gp1->next) {\n\n   if (!NoSuchGroup(gp1)) { /* Skip groups that don't really exist */\n\n    /* for each newsgroup, the following data...\n     * newsgroupname: (registration) \u00ddunread,topnum\u00a8 read-items\n     *\n     * if extended format, topnum = low_number\":\"high_number\n     * otherwise topnum = high_number\n     */\n\n     /*    write out gp1->low_number somewhere too? */\n\n     newsrc_unread = MAX(gp1->unread_count,0);\n     newsrc_topnum = gp1->high_number;\n     newsrc_count  = gp1->article_count;\n\n     /* The following is a hack for \"new newsgroups\" */\n     if (gp1->registered < 0) gp1->registered = 0;\n\n     sprintf(newsrc_line,\"%s: (%d) \u00dd%d,%d\u00a8\",\n          /* groupname */    gp1->name,\n          /* reg/prio  */    gp1->registered,\n          /* unread    */    newsrc_unread,\n          /* topnum    */    newsrc_topnum);\n\n /*\n  * All articles from 1 to low_number - 1 are \"read\" (expired, etc.)\n  * If there is an article vector,\n  *  All articles from 1 to vector_first - 1 are \"read\"\n  *  All articles from vector_last + 1 to high_number are \"read\"\n  * end\n  */\n\n     if (gp1->article_vector == NULL\n      && gp1->saved_newsrc_line != NULL) {\n       strcat(newsrc_line,\" \");\n       if (!write_to_newsrc(np,newsrc_line,gp1->saved_newsrc_line))\n           write_ok = FALSE;\n     }\n     else\n     if (gp1->article_vector == NULL\n   /* || newsrc_unread == newsrc_count */\n      || newsrc_unread == (gp1->vector_last - gp1->vector_first + 1)) {\n       sprintf(newsrc_numb, \" <%d\", gp1->low_number - 1);\n       strcat(newsrc_line, newsrc_numb);\n     }\n     else {\n       read0 = MAX(gp1->vector_first, gp1->low_number);\n       read1 = 0;\n       read2 = 0;\n       read3 = gp1->vector_last;\n       iv = read0;\n       if (IsUnread(GETVARK(gp1,iv))) {\n         sprintf(newsrc_numb, \" <%d\", read0 - 1);\n         strcat(newsrc_line, newsrc_numb);\n       }\n       while (iv <= read3) {\n         /* look for the first of a series of read articles */\n         while (iv <= read3 && IsUnread(GETVARK(gp1,iv))) iv++;\n         read1 = iv;\n         /* look for the last of a series of read articles */\n         while (iv <= read3 && IsRead(GETVARK(gp1,iv))) iv++;\n         read2 = iv-1;\n         if (read2 == read3) read2 = gp1->high_number;\n         if (read1 == read0)         sprintf(newsrc_numb,\" <%d\",read2);\n         else if (read1 >  read2)    *newsrc_numb = '\\0';\n         else if (read1 == read2)    sprintf(newsrc_numb,\" %d\" ,read2);\n         else if (read1 == read2-1)\n                            sprintf(newsrc_numb,\" %d %d\", read1,read2);\n         else               sprintf(newsrc_numb,\" |%d=%d\",read1,read2);\n         if (!write_to_newsrc(np,newsrc_line,newsrc_numb))\n             write_ok = FALSE;\n       }\n     }\n     if (*newsrc_line) {\n       if (fprintf(np->newsrc_file,\"%s\\n\",newsrc_line) < 0)\n           write_ok = FALSE;\n     }\n   }\n }\n\n /* Close the file, saving the contents. */\n\n if (!write_ok || ferror(np->newsrc_file)) {\n   fprintf(stderr,\n           \"%s: Error writing NEWSRC file.  Contents may be invalid.\\n\",\n           what_to_open);\n }\n\n if (fclose(np->newsrc_file) < 0) {\n   fprintf(stderr,\n           \"%s: Error closing NEWSRC file.  Contents may be invalid.\\n\",\n           what_to_open);\n }\n np->newsrc_file = NULL;\n\n return;\n}\n\n./ ADD NAME=NNMCONN\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@CONN \")\n#pragma  csect(static,\"NN$CONN \")\n#include \"nn.h\"\n\n/****** Internet address formatter. **********************************/\n\nstatic void\nformat_ip_address(ia,is)\nIPADDRESS   ia;\nchar       *is;\n{\n char *cp = (char *)&ia;\n\n sprintf(is,\"%d.%d.%d.%d\",*cp,*(cp+1),*(cp+2),*(cp+3));\n return;\n}\n\n/****** Connect to news server. **************************************/\n\nBool\nNNMconn(np)\nRstruc nncb *np;\n{\n char              *lp;\n struct hostent    *server_hp;\n struct sockaddr_in bindsock;       /* socket used by bind           */\n struct sockaddr_in consock;        /* socket used by connect        */\n int                bindsocklen;    /* size of bind socket           */\n int                consocklen;     /* size of connect socket        */\n int                bindrc;         /* the return code from bind     */\n int                connrc;         /* the return code from connect  */\n int                ip_part_1;\n int                ip_part_2;\n int                ip_part_3;\n int                ip_part_4;\n\n if (np->connected_to_server) {\n   NNMdisc(np);                /* Disconnect from news server */\n }\n\n np->closing_connection = FALSE;\n\n if (!*np->nnserver) {\n   ERR1(\"Server not defined;\\\nAn NNTP server name must be defined before a connection can be made.\"\n       );\n   return FALSE;\n }\n\n uppercase_in_place(np->nnserver);\n\n /* Get server name and address.\n  * The client name and address were gotten in NNMmain.\n  */\n\n if (strchr(np->nnserver,'.') &&\n     np->nnserver\u00ddstrspn(np->nnserver,\".0123456789\")\u00a8 == '\\0') {\n   ip_part_1 = ip_part_2 = ip_part_3 = ip_part_4 = 32767;\n   strcpy(np->server_hostname, np->nnserver);\n   sscanf(np->nnserver,\"%d.%d.%d.%d\",&ip_part_1,\n                                     &ip_part_2,\n                                     &ip_part_3,\n                                     &ip_part_4);\n   if (ip_part_1 > 255 ||\n       ip_part_2 > 255 ||\n       ip_part_3 > 255 ||\n       ip_part_4 > 255) {\n     ERR2(\"Syntax error in server network address: %s\", np->nnserver);\n     return FALSE;\n   }\n   np->server_ip_address = (IPADDRESS) ((ip_part_1 << 24) +\n                                        (ip_part_2 << 16) +\n                                        (ip_part_3 <<  8) +\n                                        (ip_part_4      ));\n }\n else {\n   server_hp = gethostbyname(np->nnserver);\n   if (!server_hp) {\n     ERR2(\n\"Unknown host %s - gethostbyname() could not resolve the server name.\",\n          np->nnserver);\n     return FALSE;\n   }\n   strcpy(np->server_hostname, server_hp->h_name);\n   np->server_ip_address = *(IPADDRESS *)server_hp->h_addr;\n }\n\n format_ip_address(np->server_ip_address, np->server_ip_addrstr);\n format_ip_address(np->client_ip_address, np->client_ip_addrstr);\n\n if (!np->batch_mode) {\n   (void)NNMivput(np,\"NNSERVER \",np->nnserver,-1);\n   (void)NNMivput(np,\"NNSERVIP \",np->server_ip_addrstr,-1);\n   (void)NNMivput(np,\"NNCLIENT \",np->nnclient,-1);\n   (void)NNMivput(np,\"NNCLIEIP \",np->client_ip_addrstr,-1);\n }\n\n consock.sin_family       = AF_INET;\n consock.sin_port         = htons(NNTP_PORT_NUMBER);\n consock.sin_addr.s_addr  = np->server_ip_address;\n\n bindsock.sin_family      = AF_INET;\n bindsock.sin_port        = 0;\n#ifdef SNSTCPIP\n bindsock.sin_addr.s_addr = INADDR_ANY;\n#else\n bindsock.sin_addr.s_addr = np->client_ip_address;\n#endif\n\n np->socknum = socket(AF_INET, SOCK_STREAM, 0);\n if (np->socknum < 0) {\n   REPORT_TCP_ERROR(np->nnserver);\n   ERR2(\"TCP/IP error: socket() failed to make socket for server %s.\",\n        np->nnserver);\n   return FALSE;\n }\n\n bindsocklen = sizeof(bindsock);\n bindrc = Bind(np->socknum, &bindsock, bindsocklen);\n if (bindrc < 0) {\n   REPORT_TCP_ERROR(np->nnserver);\n   ERR2(\"TCP/IP error: bind() failed to bind socket for server %s.\",\n        np->nnserver);\n   return FALSE;\n }\n\n if (np->batch_mode) {\n   fprintf(np->batch_outfile,\n           \"Client %s (%s) connecting to news server on %s (%s)\\n\",\n           np->client_hostname, np->client_ip_addrstr,\n           np->server_hostname, np->server_ip_addrstr);\n }\n else {\n   (void)NNMispf(np,\"CONTROL DISPLAY LOCK\");\n   (void)NNMispf(np,\"DISPLAY PANEL(NNMLCONN)\");\n }\n\n if (np->debug_file) {\n   fprintf(np->debug_file,\n           \"Client %s (%s) connecting to news server on %s (%s)\\n\",\n           np->client_hostname, np->client_ip_addrstr,\n           np->server_hostname, np->server_ip_addrstr);\n }\n\n consocklen = sizeof(consock);\n connrc = Connect(np->socknum, &consock, consocklen);\n\n if (connrc < 0) {\n   REPORT_TCP_ERROR(np->nnserver);\n   ERR2(\"TCP/IP failure: connect() failed to connect to server %s.\",\n        np->nnserver);\n   return FALSE;\n }\n\n np->connected_to_server = TRUE;\n np->time_to_go_home     = FALSE;\n np->connection_broken   = FALSE;\n np->xhdr_not_available  = FALSE;\n\n /* Now that the connection has been established, the news server\n  * is trying to send the first message:\n  * \"200 servername blah blah blah - posting allowed\"\n  * or\n  * \"201 servername blah blah blah - no posting allowed\"\n  * or\n  * \"502 servername won't talk to you - goodbye\"\n  * Receive that message.  Otherwise disconnect will fail.\n  *\n  * Read initial message from server.\n  */\n\n for (;;) {\n\n   NNMssrvr(np);                             /* Start server read */\n\n   if (!NNMgsrvl(np,&lp)) return FALSE;      /* Get server line */\n\n   switch (np->nntp_message_num) {\n     case 200: np->posting_allowed = TRUE;   break;\n     case 201: np->posting_allowed = FALSE;  break;\n     case 502: NNMrperr(np);                /* Report procotol error */\n               np->connection_broken = TRUE;\n               NNMdisc(np);                 /* Clean up connection   */\n               return FALSE;                /* and abandon attempt   */\n    default:   NNMrperr(np);                /* Report protocol error */\n               continue;                    /* and ignore bad data   */\n   }\n\n   break;\n\n }\n\n /* Clean up any other responses from server. */\n\n NNMesrvr(np);                             /* End server read */\n\n /* If server needs authorization, try to provide it.  Note that we\n  * currently do this even on a reconnect.  A future optimization\n  * could be to save the authorization info so that we don't have\n  * to retrieve it all over again - as long as we don't retain\n  * sensitive information in memory across ISPF displays.\n  */\n\n if (NNMauth(np)) return TRUE;                 /* Send authinfo */\n else return FALSE;\n\n}\n\n./ ADD NAME=NNMCOPY\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@COPY \")\n#pragma  csect(static,\"NN$COPY \")\n#include \"nn.h\"\n\n/****** Copy string to non-volatile memory. **************************/\n\nchar *\nNNMcopy(np,string)\nRstruc nncb *np;\nchar        *string;\n{\n int         len = strlen(string);\n char       *cp;\n\n /* cheapo one malloc per string right now */\n\n GETMAIN(cp,char,len+1,\"copy of string\");\n if (!cp) return NULL;\n strcpy(cp,string);\n\n return cp;\n}\n\n./ ADD NAME=NNMDCAN\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DCAN \")\n#pragma  csect(static,\"NN$DCAN \")\n#include \"nn.h\"\n\n#define NEWSGROUPS_LENGTH   256-sizeof(\"Newsgroups: \")\n#define SUBJECT_LENGTH      256-sizeof(\"Subject: \")\n#define PATH_LENGTH         256-sizeof(\"Path: \")\n#define FROM_LENGTH         256-sizeof(\"From: \")\n#define APPROVED_LENGTH     256-sizeof(\"Approved: \")\n#define CONTROL_LENGTH      256-sizeof(\"Control: \")\n#define CANCEL_LENGTH       128-sizeof(\"cancel \")\n\n/*\n * Note:  The algorithm for determining whether the user can cancel\n *        an article is:\n *\n *        (1) The article's FROM header must match the user's\n *            identification - i.e. userid@machine.host\n *\n *        - OR -\n *\n *        (2) if the article has an Approved: header, the user's\n *            identification must match the Approved: header.\n *            The assumption is that the Approved: header is the\n *            ID of the moderator of the newsgroup.\n *\n */\n\n/****** Collect additional article headers that we may need. *********/\n\nstatic void\nget_more_headers(np,ap,from,approved)\nRstruc nncb          *np;\nRstruc newsarticle   *ap;\nchar                 *from;\nchar                 *approved;\n{\n struct textline     *tp;\n struct texthdr      *thp;\n char                *cp;\n char                *newp;\n char                *colonp;\n int                  header_index;\n char                 the_header\u00ddINTERNET_SIZE\u00a8;\n\n strcpy(from, \"\");\n strcpy(approved, \"\");\n\n if (!ap) return;\n\n /* Grovel through headers looking for what we want.\n  */\n\n newp = NULL;\n thp = &ap->thdr;\n strcpy(the_header,\"\");\n for (tp=thp->first_text_line; tp; tp=tp->next) {\n   if (tp->text\u00dd0\u00a8 == '\\0') break;\n   if (tp->text\u00dd0\u00a8 == ' '\n    || tp->text\u00dd0\u00a8 == '\\t') {\n     cp = skip_whitespace(tp->text);\n     if (*cp == '\\0') break;\n   }\n   else {\n     header_index = 0;\n     colonp = strchr(tp->text,':');\n     if (!colonp) break;\n     strcpy(the_header,\"\");\n     for (cp = tp->text;cp<colonp;cp++) {\n       the_header\u00ddheader_index++\u00a8 = toupper(*cp);\n     }\n     the_header\u00ddheader_index\u00a8 = '\\0';\n     cp = skip_whitespace(colonp+1);\n   }\n   if      (EQUAL(the_header,\"FROM\"))\n           strncat(from,cp,FROM_LENGTH);\n   else if (EQUAL(the_header,\"APPROVED\"))\n           strncat(approved,cp,APPROVED_LENGTH);\n }\n\n lowercase_and_strip_trailing_in_place(from);\n lowercase_and_strip_trailing_in_place(approved);\n\n return;\n\n}\n\n/****** Cancel a news article. ***************************************/\n\nBool\nNNMdcan(np,gp,ap)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nRstruc newsarticle  *ap;\n{\n Bool                posted_ok     = FALSE;\n Bool                post_error    = FALSE;\n int                 prc;\n char               *lp;\n char               *cp;\n char               *article_check_field;\n struct tm          *nowtime;\n time_t              ltime;\n char                datestr\u00dd64\u00a8;\n char                midstr \u00dd64\u00a8;\n char                zuser   \u00dd9\u00a8;\n char                temp   \u00dd12\u00a8;\n char                post_message_id    \u00dd128\u00a8;\n char                post_subject       \u00ddSUBJECT_LENGTH\u00a8;\n char                post_path          \u00ddPATH_LENGTH\u00a8;\n char                post_newsgroups    \u00ddNEWSGROUPS_LENGTH\u00a8;\n char                post_from          \u00ddFROM_LENGTH\u00a8;\n char                post_control       \u00ddCONTROL_LENGTH\u00a8;\n char                post_grape_nuts    \u00ddCANCEL_LENGTH\u00a8;\n char                article_from       \u00ddFROM_LENGTH\u00a8;\n char                article_approved   \u00ddAPPROVED_LENGTH\u00a8;\n\n (void)NNMivget(np,\"ZUSER \",zuser,sizeof(zuser));\n\n /* assert ap is not null */\n\n strcpy (post_newsgroups, gp->name);\n sprintf(post_path,       \"%s!%s\", np->client_hostname, zuser);\n sprintf(post_grape_nuts, \"cancel %s\", ap->message_id);\n strcpy (post_subject,    post_grape_nuts);\n strcpy (post_control,    post_grape_nuts);\n sprintf(post_from,       \"%s@%s\", zuser, np->client_hostname);\n\n lowercase_in_place(post_from);\n\n get_more_headers(np,ap,article_from,article_approved);\n if ((cp=strpbrk(article_from,     \" \\t\"))) *cp = '\\0';\n if ((cp=strpbrk(article_approved, \" \\t\"))) *cp = '\\0';\n\n if (*article_approved) article_check_field = article_approved;\n else                   article_check_field = article_from;\n\n if (UNEQUAL(article_check_field, post_from)) {\n   ERR3(\"Cancel refused.  You, %s, are not %s.\",\n        post_from, article_check_field);\n   return FALSE;\n }\n\n /* Display confirmation panel containing the following info:\n  *\n  * newsgroup name  = NNCGROUP\n  * article number  = NNCNUM\n  * article subject = NNCSUBJ\n  * message ID      = NNCMSGID\n  */\n\n if (!np->batch_mode) {\n   sprintf(temp,\"%d\",ap->number);\n   (void)NNMivput(np,\"NNCGROUP \",gp->name,         -1);\n   (void)NNMivput(np,\"NNCNUM   \",temp,             -1);\n   (void)NNMivput(np,\"NNCSUBJ  \",ap->subject,      -1);\n   (void)NNMivput(np,\"NNCMSGID \",ap->message_id,   -1);\n   (void)NNMispf(np,\"ADDPOP\");\n   (void)NNMispf(np,\"DISPLAY PANEL(NNMPCAN)\");\n   prc = np->ispfrc;\n   (void)NNMispf(np,\"REMPOP\");\n   if (prc > 0) { /* see if user pressed END */\n     WARN1(\"Operation cancelled, because you pressed END.\");\n     return FALSE;\n   }\n }\n\n /* Start posting here.\n  *\n  * Me:     POST\n  * Server: 340 send article to be posted.  End with <CR-LF>.<CR-LF>\n  *     or: 440 posting not allowed\n  * If 430...\n  *\n  * See RFC850 for details.\n  *\n  * Me:     required_header: xxx\n  * ...\n  * Me:     <null line>\n  * Me:     <text with leading periods hacked>\n  * Me:     .\n  * Server: 240 article posted OK\n  *     or: 441 posting failed\n  */\n\n  /* See NNMDPOST for more information. */\n\n /* Get current date and time, and generate a message id from it.\n  * If the message id is a duplicate, loop around until it isn't.\n  */\n\n do {\n\n   time(&ltime);\n   nowtime = localtime(&ltime);\n   strftime(datestr,sizeof(datestr)-1,\"%a, %d %b %Y %H:%M %Z\",nowtime);\n   strftime(midstr, sizeof(midstr)-1, \"%Y%m%d%H%M%S\",nowtime);\n\n   sprintf(post_message_id, \"<%s%s@%s>\",\n                            midstr, zuser, np->client_hostname);\n\n } while (EQUAL(post_message_id,np->messageid));\n\n strcpy(np->messageid,post_message_id);\n\n posted_ok = FALSE;\n\n do {\n   strcpy(np->nntp_command,\"POST\");\n   if (!NNMsockt(np))     break;  /* Send socket command to server */\n   if (!NNMgsrvl(np,&lp)) break;  /* Get server line */\n   switch (np->nntp_message_num) {\n     case 340: post_error = FALSE;\n               break;\n     case 440: ERR2(\n       \"Cancellation failed.  Server %s did not accept the post.\",\n                    np->nnserver);\n               post_error = TRUE;\n               break;\n     default:  NNMrperr(np);       /* Report protocol error */\n               post_error = TRUE;\n               break;\n   }\n\n   if (post_error) break;\n\n   /* Assert np->server_finished_replying == TRUE\n    *     && np->receiving_text == TRUE\n    */\n\n   sprintf(np->nntp_command,\"Path: %s\", post_path);\n   if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n   sprintf(np->nntp_command,\"Newsgroups: %s\",post_newsgroups);\n   if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n   sprintf(np->nntp_command,\"Subject: %s\",post_subject);\n   if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n   sprintf(np->nntp_command,\"Message-ID: %s\", post_message_id);\n   if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n   sprintf(np->nntp_command,\"From: %s\", post_from);\n   if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n   sprintf(np->nntp_command,\"Date: %s\", datestr);\n   if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n   if (*article_approved) {\n     sprintf(np->nntp_command,\"Approved: %s\", article_approved);\n     if (!NNMsockt(np)) break;   /* Send socket command to server */\n   }\n\n   sprintf(np->nntp_command,\"Control: %s\", post_control);\n   if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n   strcpy(np->nntp_command,\"\");\n   if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n   strcpy(np->nntp_command,post_grape_nuts);\n   if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n   strcpy(np->nntp_command,\".\");\n   if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n   if (!NNMgsrvl(np,&lp)) break;  /* Get server line */\n   switch (np->nntp_message_num) {\n     case 240: posted_ok = TRUE;\n               break;\n     case 441: NNMclrtx(np,NULL);               /* Clear text */\n               NNMouttx(np,np->server_buf,NULL);/* Output text line */\n               NNMvtx(np,NULL,NULL);            /* View text */\n ERR2(\"Cancel failed.  Server %s rejected the post.\",np->nnserver);\n               posted_ok = FALSE;\n               break;\n     default:  NNMrperr(np);       /* Report protocol error */\n               posted_ok = FALSE;\n               break;\n   }\n\n   NNMesrvr(np);                   /* End server read */\n\n   break;\n\n } while(FALSE); /* one-time DO so I can break out of it */\n\n if (!posted_ok) return FALSE;\n\n WARN4(\"Cancel request for %s article %d sent to server %s.\",\n       gp->name, ap->number, np->nnserver);\n\n return TRUE;\n}\n\n./ ADD NAME=NNMDFAIL\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DFAIL\")\n#pragma  csect(static,\"NN$DFAIL\")\n#include \"nn.h\"\n\n/****** Retrieve allocation failure messages. ************************/\n\nvoid\nNNMdfail(rc,p99)\nint            rc;\n__S99parms    *p99;\n{\n int           zero = 0;\n unsigned int  dfid = 0x40320000;\n struct {\n         short first_level_msg_len;\n         short first_level_msg_offset;\n         char  first_level_msg\u00dd251\u00a8;\n         short second_level_msg_len;\n         short second_level_msg_offset;\n         char  second_level_msg\u00dd251\u00a8;\n        }      dfbuffer;\n\n static int (*ikjeff18_pointer)() = NULL;\n\n#ifndef FETCH\n extern int *ikjeff18();\n#endif\n\n if (!ikjeff18_pointer) {\n#ifdef FETCH\n   ikjeff18_pointer = (int (*)())fetch(\"IKJEFF18\");\n#else\n   ikjeff18_pointer = (int (*)())ikjeff18;\n#endif\n }\n\n dfbuffer.first_level_msg_len = 4;\n dfbuffer.second_level_msg_len = 4;\n\n if (ikjeff18_pointer) {\n   if ((*ikjeff18_pointer)(p99,&rc,&zero,&dfid,&zero,&dfbuffer)) {\n     fprintf(stderr,\"IKJEFF18 returned a nonzero return code\\n\");\n   }\n   if (dfbuffer.first_level_msg_len > 0) {\n     fprintf(stderr,\"%*.*s\\n\",\n                    dfbuffer.first_level_msg_len-4,\n                    dfbuffer.first_level_msg_len-4,\n                    dfbuffer.first_level_msg);\n   }\n   if (dfbuffer.second_level_msg_len > 0) {\n     fprintf(stderr,\"%*.*s\\n\",\n                    dfbuffer.second_level_msg_len-4,\n                    dfbuffer.second_level_msg_len-4,\n                    dfbuffer.second_level_msg);\n   }\n }\n else {\n#ifdef FETCH\n   fprintf(stderr,\"NNMVS: Cannot fetch IKJEFF18\\n\");\n#else\n   fprintf(stderr,\"Cannot call IKJEFF18, not linked with NNMVS\\n\");\n#endif\n }\n return;\n}\n\n./ ADD NAME=NNMDISC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DISC \")\n#pragma  csect(static,\"NN$DISC \")\n#include \"nn.h\"\n\n/****** Disconnect from news server. *********************************/\n\nvoid\nNNMdisc(np)\nRstruc nncb *np;\n{\n int closerc;\n\n np->reconnect_in_progress = FALSE;\n np->closing_connection    = TRUE;\n\n if (np->connection_broken) {\n   if (np->debug_file) {\n     fprintf(np->debug_file,\n    \"Client %s (%s) connection with news server on %s (%s) was lost\\n\",\n          np->client_hostname, np->client_ip_addrstr,\n          np->server_hostname, np->server_ip_addrstr);\n   }\n   if (np->batch_mode) {\n     fprintf(np->batch_outfile,\n    \"Client %s (%s) connection with news server on %s (%s) was lost\\n\",\n          np->client_hostname, np->client_ip_addrstr,\n          np->server_hostname, np->server_ip_addrstr);\n   }\n   np->connected_to_server   = FALSE;\n }\n else {\n\n   np->newsgroup_selected    = FALSE;\n   np->current_newsgroup     = NULL;\n\n   /* In case of some kind of protocol error, don't let things hang. */\n\n   NNMesrvr(np);         /* End server read */\n\n   if (np->debug_file) {\n     fprintf(np->debug_file,\n          \"Client %s (%s) disconnecting from news server on %s (%s)\\n\",\n          np->client_hostname, np->client_ip_addrstr,\n          np->server_hostname, np->server_ip_addrstr);\n   }\n\n   if (np->batch_mode) {\n     fprintf(np->batch_outfile,\n          \"Client %s (%s) disconnecting from news server on %s (%s)\\n\",\n          np->client_hostname, np->client_ip_addrstr,\n          np->server_hostname, np->server_ip_addrstr);\n   }\n   else {\n     (void)NNMivput(np,\"NNSOLDER \",np->server_hostname,-1);\n     (void)NNMivput(np,\"NNSOLDIP \",np->server_ip_addrstr,-1);\n     (void)NNMispf(np,\"CONTROL DISPLAY LOCK\");\n     (void)NNMispf(np,\"DISPLAY PANEL(NNMLDISC)\");\n\n   }\n\n   /* Send the server a QUIT request.  In the past we got away without\n    * doing this.  However, this is important for one reason:\n    * If the connection was lost before we attempt the disconnect,\n    * we want to know about it so that we don't attempt the close.\n    * The best way to find out is to try to send something.\n    * Fortunately, the protocol fits right in with that need.\n    */\n\n   strcpy(np->nntp_command,\"QUIT\");\n   if (!NNMsockt(np)) return;      /* Send socket command to server */\n\n   /* In case of some kind of protocol error, don't let things hang. */\n\n   NNMesrvr(np);                   /* End server read */\n\n   np->connected_to_server   = FALSE;\n\n   TCP_DEBUG_ON;\n   closerc = close(np->socknum);\n   TCP_DEBUG_OFF;\n\n   if (closerc < 0) {\n     ERR2(\"TCP/IP error: close() failed to disconnect from server %s.\",\n          np->nnserver);\n   }\n }\n\n return;\n}\n\n./ ADD NAME=NNMDISPL\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DISPL\")\n#pragma  csect(static,\"NN$DISPL\")\n#include \"nn.h\"\n\n#ifdef FETCH\n#define VL_BIT(X) ((unsigned int)(X) | 0x80000000)\n#else\n#define VL_BIT(X) (X)\n#endif\n\n/****** Display ISPF panel. ******************************************/\n\nint\nNNMdispl(np,pan8)\nRstruc nncb    *np;\nchar           *pan8;\n{\n\n if (np->setmsg) {\n   np->ispfrc = ISPLINK(\"DISPLAY \", pan8, VL_BIT(\"ISRZ002 \"));\n }\n else {\n   np->ispfrc = ISPLINK(\"DISPLAY \", VL_BIT(pan8));\n }\n\n if (np->ispfrc > 8) NNMierr(np);   /* display ISPF error */\n\n np->setmsg = FALSE;\n\n return np->ispfrc;\n}\n\n./ ADD NAME=NNMDLANG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DLANG\")\n#pragma  csect(static,\"NN$DLANG\")\n#include \"nn.h\"\n\nstruct nndynarea {\n                  struct newsgroup      *newsgroup;\n                  char                   sel_attr;\n                  char                   sel_field;\n                  char                   name_attr;\n                  char                   name\u00ddGROUP_NAME_SIZE\u00a8;\n                  char                   count_attr;\n                  int                    count;\n                 };\n\n/****** Set date and time of last LIST or NEWGROUPS command. *********/\n\nstatic void\nset_date_and_time(np)\nRstruc nncb      *np;\n{\n  time_t          timeval;\n  struct tm      *now;\n\n  time(&timeval);\n  now = localtime(&timeval);\n  now->tm_mon++;             /* adjust for # of months since Jan. */\n\n  sprintf(np->lastNGdate, \"%02d%02d%02d\",\n                          now->tm_year, now->tm_mon, now->tm_mday);\n  sprintf(np->lastNGtime, \"%02d%02d%02d\",\n                          now->tm_hour, now->tm_min, now->tm_sec );\n  return;\n}\n\n/****** Collect newsgroups using list from NEWSGROUPS request. *******/\n\nstatic Bool\ncollect_newsgroups(np,just_new_groups)\nRstruc nncb         *np;\nFool                 just_new_groups;\n{\n Rstruc newsgroup   *gp;\n struct newsgroup   *gpact;\n char               *lp;\n int                 list_first_article_number     = NO_VALUE;\n int                 list_last_article_number      = NO_VALUE;\n int                 ac;\n char                list_posting_allowed          = 'n';\n char                list_name\u00ddGROUP_NAME_SIZE\u00a8    = \"\";\n char                formatted_ac\u00dd12\u00a8;\n\n np->sending_text = TRUE;\n gpact = NULL;\n\n for (;;) {\n\n   if (!NNMgsrvl(np,&lp))    return FALSE;   /* Get server line */\n   if (lp == NULL)           break;\n   if (strcmp(lp,\".\") == 0)  break;\n\n   if (just_new_groups) {\n\n     /* Extract fields from response to \"NEWGROUPS\" socket request.\n        Note that only newsgroup names are returned. */\n\n     if (1 != sscanf(np->nntp_message_text, \"%s\", list_name)) {\n       NNMrbfm(np);   /* Report bad format message */\n       return FALSE;\n     }\n   }\n   else {\n\n     /* Extract fields from response to \"LIST\" socket request.\n        Note that no article count is provided. */\n\n     if (4 != sscanf(np->nntp_message_text, \"%s %d %d %c\",\n                                 list_name,\n                                &list_last_article_number,\n                                &list_first_article_number,\n                                &list_posting_allowed       )) {\n       NNMrbfm(np);   /* Report bad format message */\n       return FALSE;\n     }\n   }\n\n   if (just_new_groups) {\n     ac = NO_VALUE;\n     strcpy(formatted_ac,\"\");\n   }\n   else {\n     ac = list_last_article_number - list_first_article_number + 1;\n     sprintf(formatted_ac,\"%d\",ac);\n   }\n   if (!np->batch_mode) {\n     if (np->update_adding_newsgroups) {\n       (void)NNMivput(np,\"NNLCOUNT \",formatted_ac,-1);\n       (void)NNMivput(np,\"NNLGROUP \",list_name,   -1);\n       (void)NNMispf(np,\"CONTROL DISPLAY LOCK\");\n       (void)NNMispf(np,\"DISPLAY PANEL(NNMLADDG)\");\n     }\n   }\n\n   gp = NNMaddng(np,list_name);           /* Add newsgroup */\n\n   if (just_new_groups) {\n     np->new_newsgroup_count++;\n     ClearGroupStatus(gp);\n     SetNewGroup(gp);\n     gp->registered = -1;\n     continue;\n   }\n\n   /* Put group in the proper \"active file\" order */\n\n   if (gpact) gpact->next2 = gp;\n   else       np->first_newsgroup_alt = gp;\n   gp->next2 = NULL;\n   gpact = gp;\n\n   OffNoSuchGroup(gp);    /* came from LIST, must exist now */\n\n   if (NullGroupStatus(gp)) {\n     if (np->brand_new_newsrc) {\n       gp->registered = 0;     /* new news user, no autosubscribes */\n     }\n     else {\n       np->new_newsgroup_count++;\n       SetNewGroup(gp);\n       gp->registered = -1;\n     }\n   }\n\n   /*\n    * Logic:\n    * This code sets up newsgroups from NNTP LIST.\n    * They are already found in .newsrc (unless new newsgroups),\n    * and probably aren't GROUPed yet, but may have been.\n    * So there is a possibility of an article vector existing,\n    * but in most cases there won't be.\n    * The overriding principle here is that the active file knows\n    * best what's up to date, and is the arbiter of the\n    * low_number and high_number fields.  On the off chance\n    * that NEWSRC implied different values for these, the\n    * various adjustments in other routines should handle it.\n    */\n\n   if (GroupFromNewsrc(gp)\n    || GroupFromNNTP(gp)) {          /* Adjust unread articles */\n     NNMadjua(np,gp,ac,list_first_article_number,\n                       list_last_article_number);\n   }\n   else {\n     gp->unread_count = ac;\n   }\n\n   gp->low_number    = list_first_article_number;\n   gp->high_number   = list_last_article_number;\n   gp->article_count = ac;\n\n   SetGroupListed(gp);\n\n }\n\n np->dont_reconnect = FALSE;\n\n return TRUE;\n\n}\n\n/****** Display new newsgroups. **************************************/\n\nstatic Bool\ndisplay_new_newsgroups(np,just_new_groups)\nRstruc nncb           *np;\nFool                   just_new_groups;\n{\n Rstruc newsgroup     *gp;\n Rstruc nndynarea     *dp;\n struct nndynarea     *nndynarea_address;\n int                   nndynarea_length;\n int                   i;\n int                   prc;\n int                   nnlvl;\n int                   depth;\n int                   depthx80;\n int                   zscrolln;\n int                   topoff;\n int                   dynsize;\n char                 *cp;\n char                 *nndyna;\n char                 *nndyna_slice;\n Bool                  retval;\n Bool                  is_max;\n char                  savechar;\n char                  zverb    \u00dd9\u00a8;\n char                  zscrolla \u00dd9\u00a8;\n char                  zcmd    \u00dd81\u00a8;\n\n retval = TRUE;\n\n if (np->new_newsgroup_count == 0) return TRUE;\n\n /* Allocate a block of \"nndynarea\" new-newsgroup structures. */\n\n GETMAIN(nndynarea_address, struct nndynarea,\n         np->new_newsgroup_count,\"nndynarea\");\n\n if (!nndynarea_address) return FALSE;\n\n nndynarea_length = np->new_newsgroup_count * sizeof(struct nndynarea);\n\n dp = nndynarea_address;\n for (i = 0, gp = np->first_newsgroup; gp; gp = gp->next) {\n   if (NewGroup(gp)) {  /* if new newsgroup */\n     dp->newsgroup = gp;\n     strcpy(dp->name,gp->name);\n     dp->count = gp->article_count;\n     dp++;\n     i++;\n   }\n }\n\n if (i != np->new_newsgroup_count) {\n   fprintf(stderr,\n           \"Possible news server bug: %d new groups but %d NEWGROUPS\\n\",\n           i, np->new_newsgroup_count);\n }\n\n /* Preinitialize all newsgroups to unsubscribed. */\n\n for (dp = nndynarea_address; i > 0; dp++, i--) {\n   gp = dp->newsgroup;\n   gp->registered = 0;\n   OffNewGroup(gp);\n   dp->sel_attr   = DATAIN_HIGH;\n   dp->sel_field  = ' ';\n   dp->name_attr  = DATAOUT_LOW; /* since all unregistered init'ly */\n   dp->count_attr = DATAOUT_LOW;\n }\n\n /* Display new newsgroups in dynamic area panel. */\n\n (void)NNMispf(np,\n       \"PQUERY PANEL(NNMDNEWG) AREANAME(NNDYNA) DEPTH(NNDEPTH)\");\n if (np->ispfrc != 0) return FALSE;\n depth = NNMiget(np,\"NNDEPTH \");\n depthx80 = depth * 80;\n topoff  = 0;\n dynsize = 80*(np->new_newsgroup_count + depth) + 1;\n\n GETMAIN(nndyna, char, dynsize+1, \"NNDYNA buffer\");\n if (!nndyna) return FALSE;\n memset(nndyna,' ',dynsize);\n\n for (i = 0, cp=nndyna; i < np->new_newsgroup_count; i++, cp+=80) {\n   dp = &nndynarea_address\u00ddi\u00a8;\n   memset(cp,' ',80);\n   cp\u00dd 0\u00a8 = dp->sel_attr;\n   cp\u00dd 1\u00a8 = dp->sel_field;\n   cp\u00dd 2\u00a8 = dp->name_attr;\n   memcpy(&cp\u00dd3\u00a8,dp->name,strlen(dp->name));\n   if (!just_new_groups) {\n     cp\u00dd62\u00a8 = dp->count_attr;\n     sprintf(&cp\u00dd63\u00a8,\"%7d article%c\",dp->count,\n                                     dp->count == 1 ? ' ' : 's');\n     cp\u00dd79\u00a8 = ' ';\n   }\n }\n\n (void)NNMivput(np,\"NNDN1ST \",\"YES\",-1);\n\n do {\n   (void)NNMivput(np,\"ZCMD \",\"\",-1);\n   (void)NNMivput(np,\"NNDYNA \",nndyna+topoff*80,depthx80);\n   prc = NNMdispl(np,\"NNMDNEWG\");\n   if (prc > 8) break;\n   (void)NNMivget(np,\"ZCMD \",zcmd,sizeof(zcmd));\n   if (zcmd\u00dd0\u00a8 == 'Q'    /* QUIT   */\n    || zcmd\u00dd0\u00a8 == 'C') { /* CANCEL */\n     retval = FALSE;\n     break;\n   }\n   nnlvl = NNMiget(np,\"NNLVL \");\n   nndyna_slice = nndyna + topoff*80;\n   savechar = nndyna_slice\u00dddepthx80\u00a8;\n   (void)NNMivget(np,\"NNDYNA \",nndyna_slice,depthx80);\n   nndyna_slice\u00dddepthx80\u00a8 = savechar;\n   for (i = 0, cp=nndyna_slice; i < nnlvl; i++, cp+=80) {\n     if (i+topoff >= np->new_newsgroup_count) break;\n     dp = &nndynarea_address\u00ddi+topoff\u00a8;\n     gp = dp->newsgroup;\n     dp->sel_field = ' ';\n     switch (cp\u00dd1\u00a8) {\n       case 'r':\n       case 'R': gp->registered = 1;\n                 cp\u00dd1\u00a8 = ' ';\n                 cp\u00dd2\u00a8 = DATAOUT_HIGH;\n                 break;\n       case 'd':\n       case 'D': gp->registered = 0;\n                 cp\u00dd1\u00a8 = ' ';\n                 cp\u00dd2\u00a8 = DATAOUT_LOW;\n                 break;\n       case 'q':\n       case 'Q': NNMqng(np,gp);\n                 cp\u00dd1\u00a8 = ' ';\n                 break;\n       case ' ': break;\n       default:\n                 cp\u00dd1\u00a8 = '?';\n                 cp\u00dd2\u00a8 = DATAOUT_LOW;\n                 break;\n     }\n   }\n   (void)NNMivget(np,\"ZVERB \",zverb,sizeof(zverb));\n   (void)NNMivget(np,\"ZSCROLLA \",zscrolla,sizeof(zscrolla));\n   zscrolln = NNMiget(np,\"ZSCROLLN \");\n   is_max = EQUAL(zscrolla,\"MAX\");\n   if      (EQUAL(zverb,\"DOWN\")) {\n     if (is_max) topoff = np->new_newsgroup_count - nnlvl;\n     else        topoff += zscrolln;\n   }\n   else if (EQUAL(zverb,\"UP\")) {\n     if (is_max) topoff = 0;\n     else        topoff -= zscrolln;\n   }\n   if (topoff < 0)\n       topoff = 0;\n   if (topoff > np->new_newsgroup_count)\n       topoff = np->new_newsgroup_count;\n\n } while (prc == 0);\n\n FREEMAIN(nndyna,\"NNDYNA buffer\");\n FREEMAIN(nndynarea_address,\"nndynarea\");\n\n return retval;\n}\n\n/****** Display bogus newsgroups. ************************************/\n\nstatic Bool\ndisplay_bogus_newsgroups(np)\nRstruc nncb           *np;\n{\n Rstruc newsgroup     *gp;\n Rstruc nndynarea     *dp;\n struct nndynarea     *nndynarea_address;\n int                   nndynarea_length;\n int                   i;\n int                   prc;\n int                   nnlvl;\n int                   depth;\n int                   depthx80;\n int                   zscrolln;\n int                   topoff;\n int                   dynsize;\n int                   bogus_newsgroup_count;\n char                 *cp;\n char                 *k;\n char                 *nndyna;\n char                 *nndyna_slice;\n Bool                  retval;\n Bool                  is_max;\n char                  savechar;\n char                  zverb    \u00dd9\u00a8;\n char                  zscrolla \u00dd9\u00a8;\n char                  zcmd    \u00dd81\u00a8;\n\n retval = TRUE;\n\n bogus_newsgroup_count = 0;\n\n for (gp = np->first_newsgroup; gp; gp = gp->next) {\n   if (BogusGroup(gp)) bogus_newsgroup_count++;\n }\n\n if (bogus_newsgroup_count == 0) return TRUE;\n\n /* Allocate a block of \"nndynarea\" new-newsgroup structures. */\n\n GETMAIN(nndynarea_address, struct nndynarea,\n         bogus_newsgroup_count,\"nndynarea\");\n\n if (!nndynarea_address) return FALSE;\n\n nndynarea_length = bogus_newsgroup_count * sizeof(struct nndynarea);\n\n dp = nndynarea_address;\n for (i = 0, gp = np->first_newsgroup; gp; gp = gp->next) {\n   if (BogusGroup(gp)) {\n     SetNoSuchGroup(gp);\n     OffGroupFromNewsrc(gp);\n     dp->newsgroup = gp;\n     strcpy(dp->name,gp->name);\n     dp++;\n   }\n }\n\n for(dp = nndynarea_address, i=bogus_newsgroup_count; i>0; dp++, i--) {\n   dp->sel_attr   = DATAIN_HIGH;\n   dp->sel_field  = ' ';\n   dp->name_attr  = DATAOUT_LOW; /* since all unregistered init'ly */\n }\n\n /* Display bogus newsgroups in dynamic area panel. */\n\n (void)NNMispf(np,\n       \"PQUERY PANEL(NNMDBOGG) AREANAME(NNDYNA) DEPTH(NNDEPTH)\");\n if (np->ispfrc != 0) return FALSE;\n depth = NNMiget(np,\"NNDEPTH \");\n depthx80 = depth * 80;\n topoff  = 0;\n dynsize = 80*(bogus_newsgroup_count + depth) + 1;\n\n GETMAIN(nndyna, char, dynsize+1, \"NNDYNA buffer\");\n if (!nndyna) return FALSE;\n memset(nndyna,' ',dynsize);\n\n for (i = 0, cp=nndyna; i < bogus_newsgroup_count; i++, cp+=80) {\n   dp = &nndynarea_address\u00ddi\u00a8;\n   memset(cp,' ',80);\n   cp\u00dd 0\u00a8 = dp->sel_attr;\n   cp\u00dd 1\u00a8 = dp->sel_field;\n   cp\u00dd 2\u00a8 = dp->name_attr;\n   strncpy(&cp\u00dd3\u00a8,dp->name,67);\n   if ((k=memchr(&cp\u00dd3\u00a8,'\\0',67))) *k = ' ';\n   cp\u00dd70\u00a8 = DATAOUT_LOW;\n   memcpy(&cp\u00dd71\u00a8,\"         \",9);\n }\n\n (void)NNMivput(np,\"NNDB1ST \",\"YES\",-1);\n\n do {\n   (void)NNMivput(np,\"ZCMD \",\"\",-1);\n   (void)NNMivput(np,\"NNDYNA \",nndyna+topoff*80,depthx80);\n   prc = NNMdispl(np,\"NNMDBOGG\");\n   if (prc > 8) break;\n   (void)NNMivget(np,\"ZCMD \",zcmd,sizeof(zcmd));\n   if (zcmd\u00dd0\u00a8 == 'Q'    /* QUIT   */\n    || zcmd\u00dd0\u00a8 == 'C') { /* CANCEL */\n     retval = FALSE;\n     break;\n   }\n   nnlvl = NNMiget(np,\"NNLVL \");\n   nndyna_slice = nndyna + topoff*80;\n   savechar = nndyna_slice\u00dddepthx80\u00a8;\n   (void)NNMivget(np,\"NNDYNA \",nndyna_slice,depthx80);\n   nndyna_slice\u00dddepthx80\u00a8 = savechar;\n   for (i = 0, cp=nndyna_slice; i < nnlvl; i++, cp+=80) {\n     if (i+topoff >= bogus_newsgroup_count) break;\n     dp = &nndynarea_address\u00ddi+topoff\u00a8;\n     gp = dp->newsgroup;\n     dp->sel_field = ' ';\n     switch (cp\u00dd1\u00a8) {\n       case 'd':\n       case 'D': SetNoSuchGroup(gp);\n                 OffGroupFromNewsrc(gp);\n                 gp->low_number            = 0;\n                 gp->high_number           = 0;\n                 gp->unread_count          = 0;\n                 gp->article_count         = 0;\n                 gp->registered            = 0;\n                 cp\u00dd 1\u00a8 = ' ';\n                 cp\u00dd 2\u00a8 = DATAOUT_LOW;\n                 cp\u00dd70\u00a8 = DATAOUT_HIGH;\n                 memcpy(&cp\u00dd71\u00a8,\"Deleted  \",9);\n                 break;\n       case 'k':\n       case 'K': OffNoSuchGroup(gp);\n                 SetGroupFromNewsrc(gp);\n                 gp->low_number            = 0;\n                 gp->high_number           = 0;\n                 gp->unread_count          = 0;\n                 gp->article_count         = 0;\n                 cp\u00dd1\u00a8 = ' ';\n                 cp\u00dd70\u00a8 = DATAOUT_HIGH;\n                 memcpy(&cp\u00dd71\u00a8,\"Kept     \",9);\n                 break;\n       case 'q':\n       case 'Q': NNMqng(np,gp);\n                 cp\u00dd1\u00a8 = ' ';\n                 break;\n       case ' ':\n                 cp\u00dd1\u00a8 = ' ';\n                 cp\u00dd70\u00a8 = DATAOUT_LOW;\n                 break;\n       default:\n                 cp\u00dd1\u00a8 = '?';\n                 cp\u00dd70\u00a8 = DATAOUT_HIGH;\n                 memcpy(&cp\u00dd71\u00a8,\"What?    \",9);\n                 break;\n     }\n   }\n   (void)NNMivget(np,\"ZVERB \",zverb,sizeof(zverb));\n   (void)NNMivget(np,\"ZSCROLLA \",zscrolla,sizeof(zscrolla));\n   zscrolln = NNMiget(np,\"ZSCROLLN \");\n   is_max = EQUAL(zscrolla,\"MAX\");\n   if      (EQUAL(zverb,\"DOWN\")) {\n     if (is_max) topoff = bogus_newsgroup_count - nnlvl;\n     else        topoff += zscrolln;\n   }\n   else if (EQUAL(zverb,\"UP\")) {\n     if (is_max) topoff = 0;\n     else        topoff -= zscrolln;\n   }\n   if (topoff < 0)\n       topoff = 0;\n   if (topoff > bogus_newsgroup_count)\n       topoff = bogus_newsgroup_count;\n\n } while (prc == 0);\n\n FREEMAIN(nndyna,\"NNDYNA buffer\");\n FREEMAIN(nndynarea_address,\"nndynarea\");\n\n return retval;\n}\n\n/****** Option.....list all new newsgroups. **************************/\n\nstatic Bool\nlist_new(np)\nRstruc nncb *np;\n{\n char       *lp;\n char        mmddyy\u00dd9\u00a8;\n char        hhmmss\u00dd9\u00a8;\n\n lp = np->lastNGdate + strspn(np->lastNGdate,\"0\");\n if (*lp == '\\0') {\n   ERR1(\n\"There is no previous date in the NEWSRC file.  Select the List option.\"\n       );\n   return FALSE;\n }\n\n sprintf(np->nntp_command, \"NEWGROUPS %.6s %.6s\",\n                           np->lastNGdate, np->lastNGtime);\n\n if (!NNMsockt(np)) return FALSE;   /* Send socket command to server */\n\n#ifdef RECONNECT_AND_MAYBE_DESTROY_NEWSRC\n\n np->dont_reconnect = TRUE;         /* this is where DDI wanted it */\n\n#endif\n\n sprintf(mmddyy,\"%2.2s/%2.2s/%2.2s\",\n         &np->lastNGdate\u00dd2\u00a8, &np->lastNGdate\u00dd4\u00a8, &np->lastNGdate\u00dd0\u00a8);\n sprintf(hhmmss,\"%2.2s:%2.2s:%2.2s\",\n         &np->lastNGtime\u00dd0\u00a8, &np->lastNGtime\u00dd2\u00a8, &np->lastNGtime\u00dd4\u00a8);\n\n if (np->update_adding_newsgroups) {\n   if (!np->batch_mode) {\n     (void)NNMivput(np,\"NNNGDT \",mmddyy,-1);\n     (void)NNMivput(np,\"NNNGTM \",hhmmss,-1);\n     (void)NNMispf(np,\"CONTROL DISPLAY LOCK\");\n     (void)NNMispf(np,\"DISPLAY PANEL(NNMLNEWG)\");\n   }\n }\n\n if (!NNMgsrvl(np,&lp))             return FALSE; /* Get server line */\n if (np->nntp_message_num != 231)   NNMrperr(np);\n\n if (!collect_newsgroups(np,TRUE)) return FALSE;\n\n if (np->batch_mode) return TRUE;\n\n if (!display_new_newsgroups(np,TRUE)) return FALSE;\n\n set_date_and_time(np);\n\n if (np->new_newsgroup_count == 0) {\n   ERR3(\n\"No new newsgroups since last use of L or N option, on %s %s\",\n        mmddyy, hhmmss);\n   return FALSE;\n }\n\n return TRUE;\n}\n\n/****** Option.....list all known newsgroups. ************************/\n\nstatic Bool\nlist_all(np,just_rescan)\nRstruc nncb *np;\nFool         just_rescan;\n{\n char       *lp;\n\n strcpy(np->nntp_command,\"LIST\");\n if (!NNMsockt(np)) return FALSE;   /* Send socket command to server */\n\n if (!np->batch_mode) {\n   (void)NNMispf(np,\"CONTROL DISPLAY LOCK\");\n   (void)NNMispf(np,\"DISPLAY PANEL(NNMLLIST)\");\n }\n\n if (!NNMgsrvl(np,&lp))             return FALSE; /* Get server line */\n if (np->nntp_message_num != 215)   NNMrperr(np);\n\n if (!collect_newsgroups(np,FALSE)) return FALSE;\n\n if (np->batch_mode) return TRUE;\n\n if (!display_new_newsgroups(np,FALSE)) return FALSE;\n\n if (!display_bogus_newsgroups(np)) return FALSE;\n\n set_date_and_time(np);\n\n np->new_newsgroup_count = 0;\n\n if (just_rescan) return TRUE;\n\n np->show_all_newsgroups = TRUE;\n\n return NNMvng(np);                           /* View newsgroups */\n}\n\n/****** Fake disconnect. ********************************************/\n\nstatic void\nfake_disconnect(np)\nRstruc nncb         *np;\n{\n char               *dummy = \"503 Simulated disconnect.\";\n int                 index;\n\n /* fake a disconnect condition by sending an NNTP \"QUIT\".\n  * The next attempt to communicate with the socket will get\n  * the simulated response instead of what it expected.\n  */\n\n strcpy(np->nntp_command,\"QUIT\");\n if (!NNMsockt(np)) return;        /* Send socket command to server */\n\n index = strlen(dummy);\n strcpy(np->g_buf+1,dummy);\n np->g_buf\u00ddindex+1\u00a8 = CARRIAGE_RETURN;\n np->g_buf\u00ddindex+2\u00a8 = LINE_FEED;\n np->g_bytes_returned = index+3;\n np->g_buf_index = 0;\n\n return;\n}\n\n/****** List all or new groups. **************************************/\n\nBool\nNNMdlang(np,option)\nRstruc nncb      *np;\nenum list_option  option;\n{\n\n#ifndef RECONNECT_AND_MAYBE_DESTROY_NEWSRC\n\n /* Since an attempt to reconnect while reading data from the server\n  * will leave the news reader in an inconsistent state and possibly\n  * lead to destroyed newsrc file, we suppress all attempts to do an\n  * automatic reconnection while this is in progress.\n  */\n\n if (option != LIST_ALL_RESCAN) {\n   np->dont_reconnect = TRUE;\n }\n\n#endif\n\n switch (option) {\n   case LIST_ALL:            return list_all(np,FALSE);\n   case LIST_NEW:            return list_new(np);\n   case LIST_ALL_RESCAN:     return list_all(np,TRUE);\n   case LIST_ALL_DISCONNECT: fake_disconnect(np);\n                             return list_all(np,FALSE);\n }\n\n np->dont_reconnect = FALSE;\n\n}\n\n./ ADD NAME=NNMDMAIL\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DMAIL\")\n#pragma  csect(static,\"NN$DMAIL\")\n#include \"nn.h\"\n\n#define TO_LENGTH          256-sizeof(\"To: \")\n#define SUBJECT_LENGTH     256-sizeof(\"Subject: \")\n#define FROM_LENGTH        256-sizeof(\"From: \")\n#define REPLY_TO_LENGTH    256-sizeof(\"Reply-to: \")\n\n/****** Determine to whom to reply, according to RFC822 standards ****/\n\nstatic char *\nto_whom_to_reply(np,ap)\nRstruc nncb          *np;\nRstruc newsarticle   *ap;\n{\n struct textline     *tp;\n struct texthdr      *thp;\n char                *cp;\n char                *colonp;\n char                *resent_reply_to    = NULL;\n char                *resent_from        = NULL;\n char                *reply_to           = NULL;\n char                *from               = NULL;\n char                *resent_sender      = NULL;\n char                *sender             = NULL;\n int                  header_index;\n char                 the_header\u00ddINTERNET_SIZE\u00a8;\n\n if (!ap) return \"\";\n\n /* Since RFC1036 (Standard for Interchange of USENET Messages)\n  * seems to imply that RFC822 header format is OK, we would\n  * expect to do this.  In reality, headers like Reply-to: are\n  * often filled with the name of the mailing list (e.g. BITNET).\n  * Therefore, the user needs to have the option of using\n  * the From: header for replies.  Anyhow...\n  */\n\n /* Grovel through headers looking for likely candidates.  The official\n  * pecking order is:\n  *\n  * Resent-Reply-To:\n  * Resent-From:\n  * Reply-To:\n  * From:\n  * Resent-Sender:\n  * Sender:\n  *\n  * If none of the above, punt by returning a null string.\n  *\n  * NOTE: There is no provision in this code for continued headers.\n  *       If you want to handle continued headers, use the code in\n  *       NNMDPOST as a model.  You will have to allocate your own\n  *       storage to hold 'em.\n  */\n\n thp = &ap->thdr;\n strcpy(the_header,\"\");\n for (tp=thp->first_text_line; tp; tp=tp->next) {\n   if (tp->text\u00dd0\u00a8 == '\\0') break;\n   if (tp->text\u00dd0\u00a8 == ' '\n    || tp->text\u00dd0\u00a8 == '\\t') {\n     cp = skip_whitespace(tp->text);\n     if (*cp == '\\0') break;\n   }\n   else {\n     header_index = 0;\n     colonp = strchr(tp->text,':');\n     if (!colonp) break;\n     strcpy(the_header,\"\");\n     for (cp = tp->text;cp<colonp;cp++) {\n       the_header\u00ddheader_index++\u00a8 = toupper(*cp);\n     }\n     the_header\u00ddheader_index\u00a8 = '\\0';\n   }\n   cp = skip_whitespace(colonp+1);\n\n   if      (!strcmp(the_header,\"RESENT-REPLY-TO\")) resent_reply_to = cp;\n   else if (!strcmp(the_header,\"RESENT-FROM\"    )) resent_from     = cp;\n   else if (!strcmp(the_header,\"REPLY-TO\"       )) reply_to        = cp;\n   else if (!strcmp(the_header,\"FROM\"           )) from            = cp;\n   else if (!strcmp(the_header,\"RESENT-SENDER\"  )) resent_sender   = cp;\n   else if (!strcmp(the_header,\"SENDER\"         )) sender          = cp;\n }\n\n return (resent_reply_to ? resent_reply_to :\n         resent_from     ? resent_from     :\n         reply_to        ? reply_to        :\n         from            ? from            :\n         resent_sender   ? resent_sender   :\n         sender          ? sender          :\n         \"\");\n\n}\n\n/****** Reply to a news article by mail, or just mail a message ******/\n\nvoid\nNNMdmail(np,gp,ap)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nRstruc newsarticle  *ap;\n{\n Bool                filled       = FALSE;\n Bool                edit_error   = FALSE;\n Bool                mail_error   = FALSE;\n int                 l;\n int                 display_rc;\n FILE               *efp          = NULL;\n FILE               *mfp          = NULL;\n FILE               *sfp          = NULL;\n struct tm          *now;\n char               *cp;\n time_t              ltime;\n char                datestr \u00dd64\u00a8;\n char                midstr  \u00dd64\u00a8;\n char                zuser   \u00dd 9\u00a8;\n char                tempdsn \u00ddL_tmpnam\u00a8;\n char                outpdsn \u00ddL_tmpnam\u00a8;\n char                editstr \u00dd40+L_tmpnam\u00a8;\n char                edit_profile     \u00dd  9\u00a8;\n char                signature_file   \u00dd 64\u00a8;\n char                mail_message_id  \u00dd128\u00a8;\n char                zcmd             \u00dd 81\u00a8;\n char                nnmailfr         \u00ddFROM_LENGTH\u00a8;\n char                nnmailrt         \u00ddREPLY_TO_LENGTH\u00a8;\n char                mail_from        \u00ddFROM_LENGTH\u00a8;\n char                mail_to          \u00ddTO_LENGTH\u00a8;\n char                mail_subject     \u00ddSUBJECT_LENGTH\u00a8;\n char                mailline         \u00dd260\u00a8;\n char                sigline          \u00dd260\u00a8;\n char                mail_command     \u00dd260\u00a8;\n\n (void)NNMivget(np,\"ZUSER \",zuser,sizeof(zuser));\n\n if (ap) {\n   if (strlen(ap->subject) >= 3 &&\n       (!memcmp(ap->subject,\"Re:\",3) ||\n        !memcmp(ap->subject,\"re:\",3) ||\n        !memcmp(ap->subject,\"RE:\",3)))   strcpy(mail_subject,\"\");\n   else                                  strcpy(mail_subject,\"Re: \");\n   strncat(mail_subject, ap->subject, sizeof(mail_subject));\n }\n else strcpy(mail_subject,\"\");\n\n (void)NNMivput(np,\"NNMAILTO \",to_whom_to_reply(np,ap),-1);\n (void)NNMivput(np,\"NNMAILOT \",(ap ? ap->from : \"\")   ,-1);\n (void)NNMivput(np,\"NNMAILSJ \",mail_subject,-1);\n\n strcpy(outpdsn,\"\");\n\n /* Can't use this - C/370 compiler bug... */\n /* strcpy(tempdsn,ap ? \"\" : np->maildsn); */\n\n if (ap) strcpy(tempdsn,\"\");\n else    strcpy(tempdsn,np->maildsn);\n\n if (!*tempdsn) {\n   if (!tmpnam(tempdsn)) {\n     ERR1(\n\"A temporary data set name could not be created.  tmpnam() error.\");\n     return;\n   }\n   if (!(efp = OPEN_TEXT_FILE_FOR_WRITE(tempdsn))) {\n     ERR2(\"Error trying to open temp data set: %s\", tempdsn);\n     return;\n   }\n   if (fclose(efp) < 0) {\n     ERR2(\"Error trying to close temp data set: %s\", tempdsn);\n     return;\n   }\n   efp = NULL;\n   if (!ap) strcpy(np->maildsn,tempdsn);\n }\n\n while (NNMdispl(np,\"NNMQMAIL\") == 0) {\n\n   NNMivget(np,\"NNMAILTO \",mail_to,        sizeof(mail_to)        );\n   NNMivget(np,\"NNMAILSJ \",mail_subject,   sizeof(mail_subject)   );\n   NNMivget(np,\"NNMAILRT \",nnmailrt,       sizeof(nnmailrt)       );\n   NNMivget(np,\"NNMAILFR \",nnmailfr,       sizeof(nnmailfr)       );\n   NNMivget(np,\"NNMAILSF \",signature_file, sizeof(signature_file) );\n   NNMivget(np,\"NNEDPROF \",edit_profile,   sizeof(edit_profile)   );\n\n   (void)NNMivput(np,\"NNTEMPDS \",tempdsn,-1);\n\n   /* Insure that we can access the signature file, if given. */\n\n   if (*signature_file) {\n     if (!(sfp=fopen(signature_file,\"r\"))) {\n       perror(signature_file);\n       ERR2(\"Cannot open signature file %s.  Check that it is valid.\",\n             signature_file);\n       continue;\n     }\n   }\n   else sfp = NULL;\n\n   /* Fill temporary data set with message to which we are replying,\n    * if this is a REPLY request,\n    * and the contents of the signature file if any.\n    */\n\n   if (!filled) {\n     if (!(efp = OPEN_TEXT_FILE_FOR_WRITE(tempdsn))) {\n       ERR2(\"Error trying to open temp data set: %s\", tempdsn);\n       continue;\n     }\n     if (ap) {\n       np->extract_file            = efp;\n       np->extract_appending       = FALSE;\n       np->extract_separator_line  = FALSE;\n       np->extract_tab_expanding   = TRUE;\n       np->following_up            = TRUE;\n       fprintf(efp, \"In article %s,\\n%s writes:\\n\\n\",\n                    ap->message_id, ap->from);\n       (void)NNMxtx(np,ap,FALSE);            /* Extract article text */\n       np->following_up            = FALSE;\n       if (ferror(efp)) {\n         ERR2(\"Error trying to write to temp data set: %s\", tempdsn);\n         continue;\n       }\n     }\n\n     if (sfp) {\n       fprintf(efp,\"\\n-- \\n\",efp);\n       if (ferror(efp)) np->extract_write_error = TRUE;\n       for (;;) {\n         fgets(sigline,sizeof(sigline),sfp);\n         if (ferror(sfp)) {\n           ERR2(\n  \"Cannot read from signature file %s.  Check that it is valid.\",\n                signature_file);\n           break;\n         }\n         if (feof(sfp)) break;\n         if ((cp=strchr(sigline,'\\n'))) *cp = '\\0';\n         l = strlen(sigline);\n         fwrite(sigline,(l>251 ? 251 : l),1,efp);\n         if (ferror(efp)) {\n           np->extract_write_error = TRUE; break;\n         }\n         if (fputc('\\n',efp) == EOF) {\n           np->extract_write_error = TRUE; break;\n         }\n       }\n       (void)fclose(sfp);\n       if (ferror(efp)) {\n         ERR2(\"Error trying to write to temp data set: %s\", tempdsn);\n         continue;\n       }\n     }\n     if (fclose(efp) < 0) {\n       ERR2(\"Error trying to close temp data set: %s\", tempdsn);\n       continue;\n     }\n     filled = TRUE;\n   }\n\n   efp = NULL;\n\n#ifndef I370\n   sprintf(editstr,\"EDIT DATASET(%s) PROFILE(%s)\",tempdsn,edit_profile);\n#else\n   sprintf(editstr, \"EDIT DATASET('%s') PROFILE(%s)\",\n           tempdsn+4, edit_profile);\n#endif\n\n   edit_error = FALSE;\n\n   (void)NNMispf(np,editstr);\n   switch (np->ispfrc) {\n     case 0:  edit_error = FALSE;            break;\n     case 4:  ERR1(\n\"Edit ended without SAVE, mailing cancelled.  Reenter and SAVE to mail.\"\n                  );                         continue;\n     default: edit_error = TRUE;             break;\n   }\n\n   if (edit_error) continue;\n\n   /* Confirm mailing. */\n\n   (void)NNMispf (np,\"ADDPOP \");\n   display_rc = NNMdispl(np,\"NNMPCONM\");\n   (void)NNMispf (np,\"REMPOP \");\n   (void)NNMivget(np,\"ZCMD \",zcmd,sizeof(zcmd));\n   if (display_rc > 0) continue;\n   if (*zcmd == 'c' || *zcmd == 'C') {\n     (void)NNMivput(np,\"ZCMD \",\"\",-1);\n     ERR1(\"Mailing cancelled by user.  Reenter EDIT and SAVE to mail.\");\n     return;\n   }\n\n   if (!(efp = fopen(tempdsn,\"r\"))) {\n     ERR2(\"Error trying to open temp data set: %s\", tempdsn);\n     continue;\n   }\n\n   /* Get current date and time, and generate a message id from it.\n    * If the message id is a duplicate, loop around until it isn't.\n    */\n\n   do {\n\n     time(&ltime);\n     now = localtime(&ltime);\n     strftime(datestr,sizeof(datestr)-1,\"%a, %d %b %Y %H:%M %Z\",now);\n     strftime(midstr, sizeof(midstr)-1, \"%Y%m%d%H%M%S\",         now);\n\n     sprintf(mail_message_id,\"<%s%s@%s>\",\n                             midstr, zuser, np->client_hostname);\n\n   } while (EQUAL(mail_message_id,np->messageid));\n\n   strcpy(np->messageid,mail_message_id);\n\n   if (!*outpdsn) {\n     if (!tmpnam(outpdsn)) {\n     ERR1(\n\"A temporary data set name could not be created.  tmpnam() error.\"\n         );\n       continue;\n     }\n   }\n\n   if (!(mfp = OPEN_TEXT_FILE_FOR_WRITE(outpdsn))) {\n     ERR2(\"Error trying to open temp data set: %s\", outpdsn);\n     continue;\n   }\n\n   do {\n\n     if (*nnmailfr)\n          sprintf(mail_from,\"%s@%s (%s)\",\n                            zuser, np->client_hostname, nnmailfr);\n     else sprintf(mail_from,\"%s@%s\",\n                            zuser, np->client_hostname);\n\n     fprintf(mfp,\"From: %s\\n\",       mail_from);\n     fprintf(mfp,\"To: %s\\n\",         mail_to);\n     fprintf(mfp,\"Subject: %s\\n\",    mail_subject);\n     fprintf(mfp,\"Date: %s\\n\",       datestr);\n     fprintf(mfp,\"Message-ID: %s\\n\", mail_message_id);\n\n     /* insert optional headers here */\n\n     if (*nnmailrt) {\n       fprintf(mfp,\"Reply-to: %s\\n\", nnmailrt);\n     }\n\n     fprintf(mfp,\"Sender: MVS NNTP News Reader <%s@%s>\\n\",\n                 NNMVS_NAME, np->client_hostname);\n\n     if (ap) {\n    /*\n     * Uncomment this section when a references field in the\n     * newsarticle struct is added.  Will require total recompilation\n     *\n     * if (ap->references)\n     *  sprintf(np->nntp_command,\"References: %s %s\\n\",\n     *          ap->references, ap->message_id);\n     * else\n     */\n       fprintf(mfp,\"References: %s\\n\",ap->message_id);\n     }\n\n     /* By rights the following should be a null line.\n      * However, C/370 always makes it a single blank anyhow,\n      * and even if it were a null line (as SAS/C does),\n      * UCLA/MAIL would break.  Hence, make it a single blank.\n      */\n\n     fprintf(mfp,\" \\n\");\n\n     while (!feof(efp) && !ferror(efp)) {\n       fgets(mailline,sizeof(mailline),efp);\n       if (feof(efp)) break;\n       if (ferror(efp)) break;\n       if (*mailline && mailline\u00ddl=strlen(mailline)-1\u00a8 == '\\n')\n          mailline\u00ddl\u00a8 = '\\0';\n       fprintf(mfp,\"%s\\n\",mailline);\n     }\n\n     fclose(mfp);\n\n#ifndef I370\n     sprintf(mail_command,\"NNMMAIL %s %s\",outpdsn,mail_to);\n#else\n     sprintf(mail_command,\"NNMMAIL '%s' %s\",outpdsn+4,mail_to);\n#endif\n\n     if (NNMtso(mail_command) != 0) {\n       ERR1(\"Mail failed.  Failure trying to send your message.\");\n       mail_error = TRUE;\n     }\n\n     remove(outpdsn);\n\n     break;\n\n   } while(FALSE); /* one-time DO so I can break out of it */\n\n   if (!mail_error) {\n     (void)NNMivput(np,\"NNMAILID \",mail_message_id,-1);\n     WARN1(\"Your mail message has been sent, presumably successfully.\");\n     break;\n   }\n\n }\n\n if (!efp) return;\n\n if (ferror(efp)) {\n   ERR2(\"Error trying to read from temp data set: %s\", tempdsn);\n }\n\n if (fclose(efp) < 0) {\n   ERR2(\"Error trying to close temp data set: %s\", tempdsn);\n }\n\n if (ap) {\n   if (remove(tempdsn) < 0) {\n     ERR2(\"Error trying to delete temp data set: %s\", tempdsn);\n   }\n }\n\n return;\n}\n\n./ ADD NAME=NNMDMENU\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DMENU\")\n#pragma  csect(static,\"NN$DMENU\")\n#include \"nn.h\"\n\n/****** Report invalid or unsupported selection. *********************/\n\nstatic Bool\ndisplay_invalid_selection(np)\nRstruc nncb *np;\n{\n ERR1(\"Your selection is not valid.  Please choose an available one.\");\n return FALSE;\n}\n\n/****** Option.....set user options. *********************************/\n\nstatic Bool\ndisplay_set_options(np)\nRstruc nncb *np;\n{\n NNMdsopt(np,NULL);\n return FALSE;\n}\n\n/****** Option.....execute NNTP commands. ****************************/\n\nstatic Bool\ndisplay_nntp(np)\nRstruc nncb *np;\n{\n NNMdnntp(np,NULL);\n return FALSE;\n}\n\n/****** Option.....list ALL newsgroups from NEWSRC file. *************/\n\nstatic Bool\ndisplay_all_from_newsrc(np)\nRstruc nncb        *np;\n{\n\n if (np->newsgroup_order == NNTP_LIST_ORDER)\n    np->newsgroup_order = ALPHABETICAL_ORDER;\n np->show_all_newsgroups = TRUE;\n return NNMvng(np);                           /* View newsgroups */\n}\n\n/****** Option.....list REGISTERED newsgroups from NEWSRC file. ******/\n\nstatic Bool\ndisplay_reg_from_newsrc(np)\nRstruc nncb        *np;\n{\n char               nnrgans\u00dd4\u00a8;\n int                prc;\n Rstruc newsgroup  *gp;\n struct countdown   cd;\n\n /* Before viewing the newsgroup list, go through all the newsgroups\n  * and get the status of each one by selecting it.\n  * This is controlled by the NNREGNNG variable if an option was\n  * preselected and Y or N was specified for REGISTERSTATUS.\n  */\n\n nnrgans\u00dd0\u00a8 = 'P';\n if (np->preselection) {\n   switch (np->nnregnng\u00dd0\u00a8) {\n     case 'N': nnrgans\u00dd0\u00a8 = 'N'; break;\n     case 'Y': nnrgans\u00dd0\u00a8 = 'Y'; break;\n   }\n }\n\n if (nnrgans\u00dd0\u00a8 == 'P') {\n\n   /* Display panel asking if user really wants to do this. */\n\n   (void)NNMispf(np,\"ADDPOP\");\n   prc = NNMdispl(np,\"NNMPGREG\");\n   (void)NNMispf(np,\"REMPOP\");\n   if (prc > 0) return FALSE;  /* see if user pressed END */\n   (void)NNMivget(np,\"NNRGANS \",nnrgans,sizeof(nnrgans));\n\n }\n\n if (nnrgans\u00dd0\u00a8 == 'Y') {\n   if (np->updatefreq >= 0) {\n     cd.do_update = TRUE;\n     cd.done      = 0;\n     cd.to_do     = 0;\n     for (gp=np->first_newsgroup;gp;gp=gp->next) {\n       if (gp->registered) cd.to_do++;\n     }\n   }\n   for (gp=np->first_newsgroup;gp;gp=gp->next) {\n     if (gp->registered) {\n       if (np->updatefreq >= 0) {\n         (void)NNMivput(np,\"NNLGROUP \",gp->name,-1);\n         /*\n          * (void)NNMispf(np,\"CONTROL DISPLAY LOCK\");\n          * (void)NNMispf(np,\"DISPLAY PANEL(NNMLRETG)\");\n          */\n         NNMupdt(np,&cd,np->updatefreq > 0 ? \"NNMLRET2\" : \"NNMLRET3\");\n       }\n       NNMdng(np,gp,NULL);        /* do newsgroup by address */\n     }\n   }\n }\n\n if (np->newsgroup_order == NNTP_LIST_ORDER)\n    np->newsgroup_order = ALPHABETICAL_ORDER;\n np->show_all_newsgroups = FALSE;\n return NNMvng(np);                           /* View newsgroups */\n}\n\n/****** Option.....list all newsgroups. ******************************/\n\nstatic Bool\nlist_all_newsgroups(np)\nRstruc nncb       *np;\n{\n return NNMdlang(np,LIST_ALL);\n}\n\n/****** Option.....list all newsgroups with fake disconnect. *********/\n\nstatic Bool\nlist_all_newsgroups_with_fake_disconnect(np)\nRstruc nncb       *np;\n{\n return NNMdlang(np,LIST_ALL_DISCONNECT);\n}\n\n/****** Option.....list new newsgroups. ******************************/\n\nstatic Bool\nlist_new_newsgroups(np)\nRstruc nncb       *np;\n{\n return NNMdlang(np,LIST_NEW);\n}\n\n/****** Option.....retrieve articles from specified newsgroup. *******/\n\nstatic Bool\ndisplay_specific_newsgroup(np)\nRstruc nncb       *np;\n{\n Rstruc newsgroup *gp;\n\n np->newsgroup_selected = FALSE;\n\n /* The ISPF variable NNGROUPI contains the name of the newsgroup. */\n\n if (NNMivget(np,\"NNGROUPI \",np->nngroup,sizeof(np->nngroup))) {\n\n   lowercase_in_place(np->nngroup);\n\n   (void)NNMivput(np,\"NNGROUP \",np->nngroup,-1);\n\n   gp = NNMdng(np,NULL,np->nngroup);    /* do newsgroup by name */\n   if (!gp) {\n     (void)NNMivput(np,\"NNCURSOR \",\"NNGROUPI \",8);\n     return FALSE;\n   }\n\n   np->show_all_articles       = TRUE;\n   np->bypass_header_retrieval = FALSE;\n   np->unread_articles_only    = FALSE;\n\n   (void)NNMvar(np,gp);              /* View articles */\n }\n\n return TRUE;\n}\n\n/****** Display menu. ************************************************/\n\nenum display_retval\nNNMdmenu(np,selfunp)\nRstruc nncb   *np;\nBool        (**selfunp)();\n{\n char        zcmd\u00dd72\u00a8;\n char        new_nnserver\u00ddMAXHOSTNAMELEN\u00a8;\n Bool        server_changed = FALSE;\n\n *selfunp = NULL;\n\n if (np->preselection) {\n   zcmd\u00dd0\u00a8 = toupper(np->preselection);\n   np->preselection = SELECTION_EXIT;\n   (void)NNMispf(np,\n                 \"VGET (NNSERVER NNNEWSRC NNREGNNG NNGROUPI) PROFILE\");\n }\n else {\n\n   (void)NNMispf(np,\"CONTROL DISPLAY REFRESH\");\n\n   (void)NNMdispl(np,\"NNM     \");\n   if (np->ispfrc > 8) return DISPLAY_FAILURE;\n   if (np->ispfrc > 0) return DISPLAY_EXIT;\n   if (!NNMivget(np,\"ZCMD \",zcmd,sizeof(zcmd))) return DISPLAY_ERROR;\n }\n\n if (!NNMivget(np,\"NNSERVER \",new_nnserver,MAXHOSTNAMELEN)\n  || !NNMivget(np,\"NNREGNNG \",np->nnregnng,sizeof(np->nnregnng))) {\n   np->preselection = '\\0';\n   return DISPLAY_ERROR;\n }\n\n /* Note: selection functions return Bool value indicating whether\n  *       to rewrite NEWSRC file (TRUE) or not (FALSE).\n  *       See NNMMAIN for implementation of this.\n  */\n\n switch (zcmd\u00dd0\u00a8) {\n   case SELECTION_ALL:   *selfunp = display_all_from_newsrc;    break;\n   case SELECTION_REG:   *selfunp = display_reg_from_newsrc;    break;\n   case SELECTION_GROUP: *selfunp = display_specific_newsgroup; break;\n   case SELECTION_LIST:  *selfunp = list_all_newsgroups;        break;\n   case SELECTION_NEWG:  *selfunp = list_new_newsgroups;        break;\n   case SELECTION_NNTP:  *selfunp = display_nntp;               break;\n   case SELECTION_OPTS:  *selfunp = display_set_options;        break;\n   case SELECTION_EXIT:  return DISPLAY_EXIT;\n   case SELECTION_LIST_DISCONNECT:\n                 *selfunp = list_all_newsgroups_with_fake_disconnect;\n                 break;\n   default:              *selfunp = display_invalid_selection;\n                         np->preselection = '\\0';\n                         return DISPLAY_REPEAT;\n };\n\n /* If user typed a different server name, or this is the first time,\n    connect to the requested server. */\n\n if (UNEQUAL(new_nnserver,np->nnserver)) {\n   server_changed = TRUE;\n }\n if (!np->connected_to_server || np->connection_broken ||\n     server_changed) {\n   strcpy(np->nnserver,new_nnserver);\n   if (!NNMconn(np)) {                  /* Connect to news server */\n     (void)NNMivput(np,\"NNCURSOR \",\"NNSERVER \",8);\n     *selfunp = NULL;\n     np->preselection = '\\0';\n     return DISPLAY_ERROR;\n   }\n }\n\n return DISPLAY_REPEAT;\n}\n\n./ ADD NAME=NNMDNG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DNG  \")\n#pragma  csect(static,\"NN$DNG  \")\n#include \"nn.h\"\n\n/****** Process newsgroup by name or address. ************************/\n\nstruct newsgroup *\nNNMdng(np,gp,group)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *group;\n{\n int                 group_article_count         = NO_VALUE;\n int                 group_first_article_number  = NO_VALUE;\n int                 group_last_article_number   = NO_VALUE;\n char                group_name\u00ddGROUP_NAME_SIZE\u00a8 = \"\";\n\n /* Tell the server to select the requested newsgroup. */\n\n if (!NNMestng(np,gp ? gp->name : group)) /* Establish newsgroup */\n    return NULL;\n\n /* From the response to the \"GROUP xxx\" NNTP selection request,\n    extract the number of articles and the numbers of the\n    first and last articles, as well as the actual name. */\n\n if (4 != sscanf(np->nntp_message_text, \"%d %d %d %s\",\n                              &group_article_count,\n                              &group_first_article_number,\n                              &group_last_article_number,\n                               group_name)) {\n   NNMrbfm(np);   /* Report bad format message */\n   return NULL;\n }\n\n lowercase_in_place(group_name);\n\n if (!gp) gp = NNMaddng(np,group_name);   /* Add newsgroup */\n\n OffNoSuchGroup(gp);\n OffGroupError(gp);\n\n /* Logic:\n  * This code sets up a newsgroup from NNTP GROUP.\n  * They are already found in .newsrc (unless new newsgroups),\n  * and may or may not have already been LISTed.\n  * So there is a possibility of an article vector existing,\n  * but in most cases there won't be.\n  * The overriding principle here is that the active file knows\n  * best the actual range, but the GROUP command will return\n  * information about missing articles at either end of the list.\n  */\n\n if (GroupFromNewsrc(gp)\n  || GroupFromNNTP(gp)) {          /* Adjust unread articles */\n   NNMadjua(np,gp,group_article_count,\n                  group_first_article_number,\n                  group_last_article_number);\n }\n else {\n   gp->unread_count = group_article_count;\n }\n\n /* Allocate article vector */\n\n NNMallav(np,gp,group_first_article_number,group_last_article_number);\n\n gp->article_count = group_article_count;\n\n if (gp->article_vector) {\n   if (gp->low_number == 0\n    || gp->low_number > group_first_article_number\n    || !GroupFromNNTP(gp)) {\n       gp->low_number = group_first_article_number;\n   }\n   if (gp->high_number == 0\n    || gp->high_number < group_last_article_number) {\n       gp->high_number = group_last_article_number;\n   }\n }\n\n /*\n  *\n  * Don't know why this was here, but it is causing a bug with\n  * registering new groups, so take it out.\n  *\n  * if (!GroupFromNewsrc(gp)) {\n  *   gp->registered = 0;\n  * }\n  */\n\n if (np->show_all_articles) SetGroupSelected(gp);\n else                       SetGroupSelectedUnread(gp);\n\n return gp;\n}\n./ ADD NAME=NNMDNNTP\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DNNTP\")\n#pragma  csect(static,\"NN$DNNTP\")\n#include \"nn.h\"\n\n/****** Option ... process native NNTP protocol commands. ************/\n\nvoid\nNNMdnntp(np,command)\nRstruc nncb *np;\nchar        *command;\n{\n\n if (command && *command) {\n   strncpy(np->nntp_command, command, CLIENT_BUF_MSGSIZE);\n   NNMnntp(np);                    /* execute NNTP commands */\n }\n\n else while (NNMdispl(np,\"NNM0    \") == 0 && !np->quit) {\n\n   (void)NNMivget(np,\"NNCMD \",np->nntp_command,CLIENT_BUF_MSGSIZE);\n   if (np->ispfrc == 0) NNMnntp(np); /* execute NNTP commands */\n\n   if (np->quit) break;\n }\n\n return;\n}\n\n./ ADD NAME=NNMDOIT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DOIT \")\n#pragma  csect(static,\"NN$DOIT \")\n#include \"nn.h\"\n\n/****** Do it (whatever it is) to the article. ***********************/\n\nvoid\nNNMdoit(np,ap,whatfor)\nRstruc nncb          *np;\nRstruc newsarticle   *ap;\nFool                  whatfor;\n{\n Rstruc newsgroup    *gp;\n VARK                *vp;\n\n gp = np->current_newsgroup;\n vp = &GETVARK(gp,ap->number);\n\n switch (whatfor) {\n   case 'S':\n            NNMvtx(np,gp,ap);                 /* View text */\n            NNMmarr(np,gp,vp);                /* Make article read */\n            ap->action = READ;\n            break;\n   case 'E':\n            np->extract_write_error = FALSE;\n            np->extract_close_error = FALSE;\n            np->printing            = FALSE;\n            if (NNMxtx(np,ap,TRUE)) {         /* Extract text */\n              if (!np->extract_write_error &&\n                  !np->extract_close_error) {\n                NNMmarr(np,gp,vp);            /* Make article read */\n                ap->action = EXTRACTED;\n              }\n            }\n            break;\n   case 'P':\n            np->extract_write_error = FALSE;\n            np->extract_close_error = FALSE;\n            np->printing            = TRUE;\n            if (NNMxtx(np,ap,TRUE)) {         /* Print text */\n              if (!np->extract_write_error &&\n                  !np->extract_close_error) {\n                NNMmarr(np,gp,vp);            /* Make article read */\n                ap->action = PRINTED;\n              }\n            }\n            break;\n   case 'F':\n            NNMdpost(np,gp,ap);               /* Post followup */\n            ap->action = RETRIEVED;\n            break;\n   case 'R':\n            NNMdmail(np,gp,ap);               /* Mail reply */\n            ap->action = RETRIEVED;\n            break;\n   case 'C':\n            if (NNMdcan(np,gp,ap)) {          /* Cancel article */\n              ap->action = CANCELLED;\n            }\n            break;\n }\n\n np->top_article = ap->number;\n np->top_sorted_article = np->current_sortvark;\n\n return;\n}\n\n./ ADD NAME=NNMDPOST\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DPOST\")\n#pragma  csect(static,\"NN$DPOST\")\n#include \"nn.h\"\n\n#define NEWSGROUPS_LENGTH   256-sizeof(\"Newsgroups: \")\n#define SUBJECT_LENGTH      256-sizeof(\"Subject: \")\n#define PATH_LENGTH         256-sizeof(\"Path: \")\n#define FROM_LENGTH         256-sizeof(\"From: \")\n#define REPLY_TO_LENGTH     256-sizeof(\"Reply-to: \")\n#define FOLLOWUP_TO_LENGTH  256-sizeof(\"Followup-to: \")\n\n#define HEADCAT(A,B)        strncat((A),(B),NEWSGROUPS_LENGTH)\n\n#define READER_MUST_GENERATE_PATH\n\n/****** Make a comma delimited list out of user's newsgroup spec. ****/\n\nstatic void\nmake_comma_delimited_list(instring,outstring)\nchar                *instring;\nchar                *outstring;\n{\n char               *icp;\n char               *ocp;\n Bool                between;\n\n between = FALSE;\n icp = instring + strspn(instring,\" ,\");\n ocp = outstring;\n do {\n   switch (*icp) {\n     case '\\0': *ocp = '\\0'; break;\n     case ' ' :\n     case ',' :  between = TRUE; break;\n     default  :  if (between) {\n                   between = FALSE;\n                   *(ocp++) = ',';\n                 }\n                 *(ocp++) = tolower(*icp);\n                 break;\n   }\n } while (*icp++);\n\n}\n\n/****** Collect additional article headers that we may need. *********/\n\nstatic void\nget_more_headers(np,ap,newsgroups,followup_to)\nRstruc nncb          *np;\nRstruc newsarticle   *ap;\nchar                 *newsgroups;\nchar                 *followup_to;\n{\n struct textline     *tp;\n struct texthdr      *thp;\n char                *cp;\n char                *newp;\n char                *colonp;\n int                  header_index;\n char                 the_header\u00ddINTERNET_SIZE\u00a8;\n\n strcpy(newsgroups,  \"\");\n strcpy(followup_to, \"\");\n\n if (!ap) return;\n\n /* Grovel through headers looking for what we want.  */\n\n newp = NULL;\n thp = &ap->thdr;\n strcpy(the_header,\"\");\n for (tp=thp->first_text_line; tp; tp=tp->next) {\n   if (tp->text\u00dd0\u00a8 == '\\0') break;\n   if (tp->text\u00dd0\u00a8 == ' '\n    || tp->text\u00dd0\u00a8 == '\\t') {\n     cp = skip_whitespace(tp->text);\n     if (*cp == '\\0') break;\n   }\n   else {\n     header_index = 0;\n     colonp = strchr(tp->text,':');\n     if (!colonp) break;\n     strcpy(the_header,\"\");\n     for (cp = tp->text;cp<colonp;cp++) {\n       the_header\u00ddheader_index++\u00a8 = toupper(*cp);\n     }\n     the_header\u00ddheader_index\u00a8 = '\\0';\n     cp = skip_whitespace(colonp+1);\n   }\n   if      (EQUAL(the_header,\"NEWSGROUPS\"  )) HEADCAT(newsgroups, cp);\n   else if (EQUAL(the_header,\"FOLLOWUP-TO\" )) HEADCAT(followup_to,cp);\n }\n\n lowercase_and_strip_trailing_in_place(newsgroups);\n lowercase_and_strip_trailing_in_place(followup_to);\n\n return;\n\n}\n\n/****** Post a news article. *****************************************/\n\nvoid\nNNMdpost(np,gp,ap)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nRstruc newsarticle  *ap;\n{\n Bool                filled       = FALSE;\n Bool                edit_error   = FALSE;\n Bool                post_error   = FALSE;\n int                 l;\n int                 display_rc;\n char               *postdefault  = NULL;\n char               *lp;\n char               *cp;\n FILE               *efp          = NULL;\n FILE               *sfp          = NULL;\n struct tm          *now;\n time_t              ltime;\n char                datestr \u00dd64\u00a8;\n char                midstr  \u00dd64\u00a8;\n char                zuser   \u00dd 9\u00a8;\n char                temp    \u00dd12\u00a8;\n char                tempdsn \u00ddL_tmpnam\u00a8;\n char                editstr \u00dd40+L_tmpnam\u00a8;\n char                edit_profile     \u00dd  9\u00a8;\n char                signature_file   \u00dd 64\u00a8;\n char                post_message_id  \u00dd128\u00a8;\n char                zcmd             \u00dd 81\u00a8;\n char                post_subject     \u00ddSUBJECT_LENGTH\u00a8;\n char                post_path        \u00ddPATH_LENGTH\u00a8;\n char                post_newsgroups  \u00ddNEWSGROUPS_LENGTH\u00a8;\n char                post_followup_to \u00ddNEWSGROUPS_LENGTH\u00a8;\n char                post_from        \u00ddFROM_LENGTH\u00a8;\n char                nnpostng         \u00ddNEWSGROUPS_LENGTH\u00a8;\n char                nnpostrt         \u00ddREPLY_TO_LENGTH\u00a8;\n char                nnpostfo         \u00ddFOLLOWUP_TO_LENGTH\u00a8;\n char                nnpostfr         \u00ddFROM_LENGTH\u00a8;\n char                newsgroups       \u00ddNEWSGROUPS_LENGTH\u00a8;\n char                followup_to      \u00ddNEWSGROUPS_LENGTH\u00a8;\n char                postline         \u00dd260\u00a8;\n char                sigline          \u00dd260\u00a8;\n\n (void)NNMivget(np,\"ZUSER \",zuser,sizeof(zuser));\n\n if (ap) {\n   if (strlen(ap->subject) >= 3 &&\n       (!memcmp(ap->subject,\"Re:\",3) ||\n        !memcmp(ap->subject,\"re:\",3) ||\n        !memcmp(ap->subject,\"RE:\",3)))   strcpy(post_subject,\"\");\n   else                                  strcpy(post_subject,\"Re: \");\n   strncat(post_subject, ap->subject, sizeof(post_subject));\n }\n else strcpy(post_subject,\"\");\n\n sprintf(post_path,\"%s!%s\", np->client_hostname, zuser);\n\n (void)NNMivput(np,\"NNPOSTSJ \",post_subject,-1);\n if (ap) {\n   sprintf(temp,\"%d\",ap->number);\n   (void)NNMivput(np,\"NNPOSTHA \",temp,        -1);\n   (void)NNMivput(np,\"NNPOSTHG \",gp->name,    -1);\n }\n else {\n   (void)NNMivput(np,\"NNPOSTHA \",\"\",          -1);\n   (void)NNMivput(np,\"NNPOSTHG \",\"\"          ,-1);\n }\n\n /*\n  * Simple-minded and wrong - newsgroups to post to = current one\n  *\n  * (void)NNMivput(np,\"NNPOSTNG \",gp ? gp->name : \"\",-1);\n  *\n  * The correct way:  if we are following up an article, then\n  * if the Followup_to header is present, use that, else\n  * use the Newsgroups: header.  If not there, use the newsgroup name.\n  *\n  * If fresh post, use the newsgroup name.\n  */\n\n if (gp) {\n   if (ap) {  /* this is a followup */\n     strcpy(newsgroups, \"\");\n     strcpy(followup_to,\"\");\n     get_more_headers(np,ap,newsgroups,followup_to);\n     if      (EQUAL(followup_to,\"poster\")) {\n       ERR1(\n\"Followups are directed to the poster.  Suggest you use REPLY instead.\"\n           );\n       postdefault = \"\";\n     }\n     else if (strchr(followup_to,'@')) {\n       ERR1(\n\"Followup header contains mailing address.  Suggest you REPLY instead.\"\n           );\n       postdefault = \"\";\n     }\n     else if (*followup_to)  postdefault = followup_to;\n     else if (*newsgroups)   postdefault = newsgroups;\n     else                    postdefault = gp->name;\n   }\n   else {     /* this is a fresh posting */\n     postdefault = gp->name;\n   }\n }\n else {\n   postdefault = \"\";\n }\n\n (void)NNMivput(np,\"NNPOSTNG \",postdefault,-1);\n\n /* Can't use this - C/370 compiler bug... */\n /* strcpy(tempdsn,ap ? \"\" : np->maildsn); */\n\n if (ap) strcpy(tempdsn,\"\");\n else    strcpy(tempdsn,np->maildsn);\n\n if (!*tempdsn) {\n   if (!tmpnam(tempdsn)) {\n     ERR1(\n\"A temporary data set name could not be created.  tmpnam() error.\"\n         );\n     return;\n   }\n   if (!(efp = OPEN_TEXT_FILE_FOR_WRITE(tempdsn))) {\n     ERR2(\"Error trying to open temp data set: %s\", tempdsn);\n     return;\n   }\n   if (fclose(efp) < 0) {\n     ERR2(\"Error trying to close temp data set: %s\", tempdsn);\n     return;\n   }\n   efp = NULL;\n   if (!ap) strcpy(np->maildsn,tempdsn);\n }\n\n while (NNMdispl(np,\"NNMQPOST\") == 0) {\n\n   NNMivget(np,\"NNPOSTNG \",nnpostng,       sizeof(nnpostng));\n   NNMivget(np,\"NNPOSTRT \",nnpostrt,       sizeof(nnpostrt));\n   NNMivget(np,\"NNPOSTFO \",nnpostfo,       sizeof(nnpostfo));\n   NNMivget(np,\"NNPOSTFR \",nnpostfr,       sizeof(nnpostfr));\n   NNMivget(np,\"NNPOSTSJ \",post_subject,   sizeof(post_subject)   );\n   NNMivget(np,\"NNPOSTSF \",signature_file, sizeof(signature_file) );\n   NNMivget(np,\"NNEDPROF \",edit_profile,   sizeof(edit_profile)   );\n\n   /* Create correctly formatted newsgroup listing. */\n\n   make_comma_delimited_list(nnpostng,post_newsgroups);\n\n   make_comma_delimited_list(nnpostfo,post_followup_to);\n\n   (void)NNMivput(np,\"NNTEMPDS \",tempdsn,-1);\n\n   /* Insure that we can access the signature file, if given. */\n\n   if (*signature_file) {\n     if (!(sfp=fopen(signature_file,\"r\"))) {\n       perror(signature_file);\n       ERR2(\"Cannot open signature file %s.  Check that it is valid.\",\n             signature_file);\n       continue;\n     }\n   }\n   else sfp = NULL;\n\n   /* Fill temporary data set with message to which we are replying,\n    * if this is a FOLLOWUP request,\n    * and the contents of the signature file if any.\n    */\n\n   if (!filled) {\n     if (!(efp = OPEN_TEXT_FILE_FOR_WRITE(tempdsn))) {\n       ERR2(\"Error trying to open temp data set: %s\", tempdsn);\n       continue;\n     }\n     if (ap) {\n       np->extract_file            = efp;\n       np->extract_appending       = FALSE;\n       np->extract_separator_line  = FALSE;\n       np->extract_tab_expanding   = TRUE;\n       np->following_up            = TRUE;\n       fprintf(efp, \"In article %s,\\n%s writes:\\n\\n\",\n                    ap->message_id, ap->from);\n       (void)NNMxtx(np,ap,FALSE);            /* Extract article text */\n       np->following_up            = FALSE;\n       if (ferror(efp)) {\n         ERR2(\"Error trying to write to temp data set: %s\", tempdsn);\n         continue;\n       }\n     }\n     if (sfp) {\n       fprintf(efp,\"\\n-- \\n\",efp);\n       if (ferror(efp)) np->extract_write_error = TRUE;\n       for (;;) {\n         fgets(sigline,sizeof(sigline),sfp);\n         if (ferror(sfp)) {\n           ERR2(\n  \"Cannot read from signature file %s.  Check that it is valid.\",\n                signature_file);\n           break;\n         }\n         if (feof(sfp)) break;\n         if ((cp=strchr(sigline,'\\n'))) *cp = '\\0';\n         l = strlen(sigline);\n         fwrite(sigline,(l>251 ? 251 : l),1,efp);\n         if (ferror(efp)) {\n           np->extract_write_error = TRUE; break;\n         }\n         if (fputc('\\n',efp) == EOF) {\n           np->extract_write_error = TRUE; break;\n         }\n       }\n       (void)fclose(sfp);\n       if (ferror(efp)) {\n         ERR2(\"Error trying to write to temp data set: %s\", tempdsn);\n         continue;\n       }\n     }\n     if (fclose(efp) < 0) {\n       ERR2(\"Error trying to close temp data set: %s\", tempdsn);\n       continue;\n     }\n     filled = TRUE;\n   }\n\n   efp = NULL;\n\n#ifndef I370\n   sprintf(editstr,\"EDIT DATASET(%s) PROFILE(%s)\",tempdsn,edit_profile);\n#else\n   sprintf(editstr, \"EDIT DATASET('%s') PROFILE(%s)\",\n           tempdsn+4, edit_profile);\n#endif\n\n   edit_error = FALSE;\n\n   (void)NNMispf(np,editstr);\n   switch (np->ispfrc) {\n     case 0:  edit_error = FALSE;      break;\n     case 4:  ERR1(\n\"Edit ended without SAVE, posting cancelled.  Reenter and SAVE to post.\"\n                  );                         continue;\n     default: edit_error = TRUE;       break;\n   }\n\n   if (edit_error) continue;\n\n   /* Confirm posting. */\n\n   (void)NNMispf (np,\"ADDPOP \");\n   display_rc = NNMdispl(np,\"NNMPCONP\");\n   (void)NNMispf (np,\"REMPOP \");\n   (void)NNMivget(np,\"ZCMD \",zcmd,sizeof(zcmd));\n   if (display_rc > 0) continue;\n   if (*zcmd == 'c' || *zcmd == 'C') {\n     (void)NNMivput(np,\"ZCMD \",\"\",-1);\n     ERR1(\"Posting cancelled by user.  Reenter EDIT and SAVE to post.\");\n     return;\n   }\n\n   if (!(efp = fopen(tempdsn,\"r\"))) {\n     ERR2(\"Error trying to open temp data set: %s\", tempdsn);\n     continue;\n   }\n\n   /* Start posting here.\n    *\n    * Me:     POST\n    * Server: 340 send article to be posted.  End with <CR-LF>.<CR-LF>\n    *     or: 440 posting not allowed\n    * If 430...\n    *\n    * See RFC850 for details.\n    *\n    * Me:     required_header: xxx\n    * ...\n    * Me:     <null line>\n    * Read text from tempdsn\n    * Me:     <text with leading periods hacked>\n    * Me:     .\n    * Server: 240 article posted OK\n    *     or: 441 posting failed\n    */\n\n    /* See RFC 1036 for full information. */\n\n   /* Required headers - from, date, subject, newsgroups,\n    *                    message-id, path\n    */\n\n   /* Optional headers - reply-to, sender, followup-to, expires, xref,\n    *                    references, control, distribution, lines,\n    *                    organization, keywords, summary, approved\n    */\n\n\n   /* Get current date and time, and generate a message id from it.\n    * If the message id is a duplicate, loop around until it isn't.\n    */\n\n   do {\n\n     time(&ltime);\n     now = localtime(&ltime);\n     strftime(datestr,sizeof(datestr)-1,\"%a, %d %b %Y %H:%M %Z\",now);\n     strftime(midstr, sizeof(midstr)-1, \"%Y%m%d%H%M%S\",now);\n\n     sprintf(post_message_id,\"<%s%s@%s>\",\n                             midstr, zuser, np->client_hostname);\n\n   } while (EQUAL(post_message_id,np->messageid));\n\n   strcpy(np->messageid,post_message_id);\n\n   do {\n     strcpy(np->nntp_command,\"POST\");\n     if (!NNMsockt(np))     break;  /* Send socket command to server */\n     if (!NNMgsrvl(np,&lp)) break;  /* Get server line */\n     switch (np->nntp_message_num) {\n       case 340: post_error = FALSE;\n                 break;\n       case 440: ERR2(\n         \"Posting not allowed.  Server %s did not accept the post.\",\n                      np->nnserver);\n                 post_error = TRUE;\n                 break;\n       default:  NNMrperr(np);       /* Report protocol error */\n                 post_error = TRUE;\n                 break;\n     }\n\n     if (post_error) break;\n\n     /* Assert np->server_finished_replying == TRUE\n      *     && np->receiving_text == TRUE\n      */\n\n     if (*nnpostfr)\n          sprintf(post_from,\"%s@%s (%s)\",\n                            zuser, np->client_hostname, nnpostfr);\n     else sprintf(post_from,\"%s@%s\",\n                            zuser, np->client_hostname);\n\n#ifdef READER_MUST_GENERATE_PATH\n     sprintf(np->nntp_command,\"Path: %s\", post_path);\n     if (!NNMsockt(np)) break;   /* Send socket command to server */\n#endif\n\n     sprintf(np->nntp_command,\"Newsgroups: %s\",post_newsgroups);\n     if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n     sprintf(np->nntp_command,\"Subject: %s\",post_subject);\n     if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n     sprintf(np->nntp_command,\"Message-ID: %s\", post_message_id);\n     if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n     sprintf(np->nntp_command,\"From: %s\", post_from);\n     if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n     sprintf(np->nntp_command,\"Date: %s\", datestr);\n     if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n     /* insert optional headers here if we ever have any */\n\n     sprintf(np->nntp_command,\"Sender: MVS NNTP News Reader <%s@%s>\",\n                              NNMVS_NAME, np->client_hostname);\n     if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n     if (ap) {\n    /*\n     * Uncomment this section when a references field in the\n     * newsarticle struct is added.  Will require total recompilation\n     *\n     * if (ap->references)\n     *  sprintf(np->nntp_command,\"References: %s %s\",\n     *          ap->references, ap->message_id);\n     * else\n     */\n        sprintf(np->nntp_command,\"References: %s\",ap->message_id);\n       if (!NNMsockt(np)) break;   /* Send socket command to server */\n     }\n\n     /* optional headers */\n\n     if (*nnpostrt) {\n       sprintf(np->nntp_command,\"Reply-to: %s\", nnpostrt);\n       if (!NNMsockt(np)) break;   /* Send socket command to server */\n     }\n     if (*post_followup_to) {\n       sprintf(np->nntp_command,\"Followup-to: %s\", post_followup_to);\n       if (!NNMsockt(np)) break;   /* Send socket command to server */\n     }\n\n     strcpy(np->nntp_command,\"\");\n     if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n     while (!feof(efp) && !ferror(efp)) {\n       fgets(postline,sizeof(postline),efp);\n       if (feof(efp)) break;\n       if (ferror(efp)) break;\n       if (*postline && postline\u00ddl=strlen(postline)-1\u00a8 == '\\n')\n          postline\u00ddl\u00a8 = '\\0';\n       if (postline\u00dd0\u00a8 == '.') strcpy(np->nntp_command,\".\");\n       else                    strcpy(np->nntp_command,\"\");\n       strcat(np->nntp_command,postline);\n       if (!NNMsockt(np)) break;   /* Send socket command to server */\n     }\n\n     strcpy(np->nntp_command,\".\");\n     if (!NNMsockt(np)) break;   /* Send socket command to server */\n\n     if (!NNMgsrvl(np,&lp)) break;  /* Get server line */\n     switch (np->nntp_message_num) {\n       case 240: post_error = FALSE;\n                 break;\n       case 441: NNMclrtx(np,NULL);               /* Clear text */\n                 NNMouttx(np,np->server_buf,NULL);/* Output text line */\n                 NNMvtx(np,NULL,NULL);            /* View text */\n ERR2(\"Posting failed.  Server %s rejected the post.\",np->nnserver);\n                 post_error = TRUE;\n                 break;\n       default:  NNMrperr(np);       /* Report protocol error */\n                 post_error = TRUE;\n                 break;\n     }\n\n     NNMesrvr(np);                   /* End server read */\n\n     break;\n\n   } while(FALSE); /* one-time DO so I can break out of it */\n\n   if (!post_error) {\n     (void)NNMivput(np,\"NNPOSTID \",post_message_id,-1);\n     WARN2(\"Your article has been posted.  Message ID: %s\",\n           post_message_id);\n     break;\n   }\n\n }\n\n if (!efp) return;\n\n if (ferror(efp)) {\n   ERR2(\"Error trying to read from temp data set: %s\", tempdsn);\n }\n\n if (fclose(efp) < 0) {\n   ERR2(\"Error trying to close temp data set: %s\", tempdsn);\n }\n\n if (ap) {\n   if (remove(tempdsn) < 0) {\n     ERR2(\"Error trying to delete temp data set: %s\", tempdsn);\n   }\n }\n\n return;\n}\n\n./ ADD NAME=NNMDSOPT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DSOPT\")\n#pragma  csect(static,\"NN$DSOPT\")\n#include \"nn.h\"\n\n/****** Set options. *************************************************/\n\nstatic void\nset_options(np,panelname,which)\nRstruc nncb       *np;\nchar              *panelname;\nenum user_option   which;\n{\n\n while (NNMdispl(np,panelname) == 0) {\n   NNMsopt(np,which);               /* Actually set options */\n }\n\n return;\n}\n\n/****** Option ... set NNMVS default processing options. *************/\n\nvoid\nNNMdsopt(np,option)\nRstruc nncb *np;\nchar        *option;\n{\n Bool        asked_for;\n Bool        force_choice;\n char        nnchoice\u00dd9\u00a8;\n\n force_choice = FALSE;\n\n do {\n\n   asked_for = TRUE;\n\n   if (!force_choice && option && *option) {\n     strncpy(nnchoice,option,sizeof(nnchoice)-1);\n\n   }\n   else {\n\n     (void)NNMispf(np,\"ADDPOP\");\n     if (NNMdispl(np,\"NNMPOPT \") > 0) {\n       asked_for = FALSE;\n     }\n     else {\n       (void)NNMivget(np,\"NNCHOICE \",nnchoice,sizeof(nnchoice));\n       if (*nnchoice == '?') {\n         ERR1(\"Invalid choice;\\\nMove the cursor to a selection (or type S next to it) and press ENTER.\"\n             );\n       }\n     }\n\n     (void)NNMispf(np,\"REMPOP\");\n   }\n\n   if (asked_for) {\n\n     if      (EQUAL(nnchoice,\"1\")) {\n       set_options(np,\"NNMRFCH \",OPTION_HEADER);\n       break;\n     }\n     else if (EQUAL(nnchoice,\"2\")) {\n       set_options(np,\"NNMOPTS \",OPTION_OTHER);\n       break;\n     }\n     else if (EQUAL(nnchoice,\"3\")) {\n       set_options(np,\"NNMOPTT \",OPTION_VIEW);\n       break;\n     }\n     else {\n       ERR1(\"Invalid choice;\\\nMove the cursor to a selection (or type S next to it) and press ENTER.\"\n           );\n       force_choice = TRUE;\n       continue;\n     }\n   }\n\n } while (asked_for);\n\n return;\n\n}\n\n./ ADD NAME=NNMDUMP\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@DUMP \")\n#pragma  csect(static,\"NN$DUMP \")\n#include \"nn.h\"\n\n/****** Dump some data. **********************************************/\n\nvoid\nNNMdump(struct nncb *np, char *label, char *p,int r)\n{\n int i;\n\n if (!np->debug_file) return;\n\n if (r == -2) {\n   fprintf(np->debug_file,\"%s:  %d\\n\",label,(int)p);\n   return;\n }\n\n if (r == -1) r = strlen(p);\n\n fprintf(np->debug_file,\"%s:   (%d characters)\\n\",label,r);\n for (i=0;i<77;i++) fprintf(np->debug_file,\"-\");\n fprintf(np->debug_file,\"\\n\");\n for (i=0;i<r;i++) {\n   char c = *(p+i);\n   if (isprint(c))  fprintf(np->debug_file,\"%c\",c);\n   else             fprintf(np->debug_file,\"<0x%2.2x>\",c);\n }\n fprintf(np->debug_file,\"\\n\");\n for (i=0;i<77;i++) fprintf(np->debug_file,\"-\");\n fprintf(np->debug_file,\"\\n\");\n\n fflush(np->debug_file);\n\n return;\n\n}\n\n./ ADD NAME=NNMESRVR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@ESRVR\")\n#pragma  csect(static,\"NN$ESRVR\")\n#include \"nn.h\"\n\n/****** End server read. *********************************************/\n\nvoid\nNNMesrvr(np)\nRstruc nncb  *np;\n{\n char       *lp;\n Bool        found_more_server_data = FALSE;\n Bool        save_dont_reissue_socket_command;\n\n NNMclrtx(np,NULL);                    /* Clear text */\n\n save_dont_reissue_socket_command = np->dont_reissue_socket_command;\n np->dont_reissue_socket_command = TRUE;\n\n do {\n\n   if (NNMgsrvl(np,&lp)) {             /* Get server line */\n     if (lp) {\n       found_more_server_data = TRUE;\n       (void)NNMouttx(np,lp,NULL);     /* Output text line */\n     }\n   }\n\n } while (lp);\n\n if (found_more_server_data) {\n   ERR1(\n\"More data was returned by the news server than the client expected.\"\n       );\n   NNMvtx(np,NULL,NULL);               /* View text */\n }\n\n np->dont_reissue_socket_command = save_dont_reissue_socket_command;\n\n return;\n}\n\n./ ADD NAME=NNMESTNG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@ESTNG\")\n#pragma  csect(static,\"NN$ESTNG\")\n#include \"nn.h\"\n\n/****** Establish newsgroup. *****************************************/\n\nBool\nNNMestng(np,group)\nRstruc nncb        *np;\nchar               *group;\n{\n char              *lp;\n Bool               null_group_passed = FALSE;\n\n /* A null group means reissue the server command to select the\n    current newsgroup if it is necessary. */\n\n if (!group) {\n   null_group_passed = TRUE;\n   if (!np->current_newsgroup) {\n     fprintf(stderr,\"NNMestng: no current newsgroup\\n\");\n     return FALSE;\n   }\n   if (np->newsgroup_selected) return TRUE;\n   group = np->current_newsgroup->name;\n }\n\n np->newsgroup_not_found = FALSE;\n\n /* Send \"GROUP xxxx\" to news server. */\n\n strcpy(np->nntp_command,\"GROUP \");\n strcat(np->nntp_command,group);\n if (!NNMsockt(np)) return FALSE;    /* Send socket command to server */\n\n   /* Receive response.  Should be one of:\n    *   211 n f l s group selected\n    *   411 no such news group\n    */\n\n if (!NNMgsrvl(np,&lp)) return FALSE;  /* Get server line */\n switch (np->nntp_message_num) {\n   case 211:                           /* n f l s group selected */\n             break;\n   case 411:                               /* no such news group */\n             fprintf(stderr,\"%s: no such newsgroup\\n\",group);\n             ERR3(\"No such newsgroup.  %s is unknown to server %s.\",\n                  group, np->nnserver);\n             np->newsgroup_not_found = TRUE;\n             return FALSE;\n   default:\n             NNMrperr(np);        /* Report protocol error */\n             return FALSE;\n }\n\n np->newsgroup_selected = TRUE;\n\n return TRUE;\n\n}\n\n./ ADD NAME=NNMFREEM\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@FREEM\")\n#pragma  csect(static,\"NN$FREEM\")\n#include \"nn.h\"\n\n/****** Free memory. *************************************************/\n\nvoid\nNNMfreem(np,stuff,whatfor)\nRstruc nncb    *np;\nchar           *stuff;\nchar           *whatfor;\n{\n\n free(stuff);\n\n if (np->debug_file) {\n   fprintf(np->debug_file,\"NNMfreem: freed memory for %s\\n\", whatfor);\n }\n return;\n\n}\n\n./ ADD NAME=NNMGETDS\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@GETDS\")\n#pragma  csect(static,\"NN$GETDS\")\n#include \"nn.h\"\n\n#define DUMMY_FILE_POINTER_FOR_PDS  (FILE *)(-1)\n\nstruct sysout    {\n                  int        copies;\n                  char       class \u00dd2\u00a8;\n                  char       dest  \u00dd9\u00a8;\n                  char       forms \u00dd5\u00a8;\n                  char       ucs   \u00dd5\u00a8;\n                 };\n\n/****** Function to close sequential data set after extraction. ******/\n\nstatic void\nclose_seq(np,ep,xfp,final)\nRstruc nncb         *np;\nRstruc extraction   *ep;\nFILE                *xfp;\nFool                 final;\n{\n\n if (fclose(xfp) < 0) {\n   /* perror(ep->dsname); */\n   ERR2(\"An error occurred closing %s.\", ep->dsname);\n   np->extract_close_error = TRUE;\n }\n\n}\n\n/****** Function to close partitioned data set after extraction. *****/\n\nstatic void\nclose_pds(np,ep,xfp,final)\nRstruc nncb         *np;\nRstruc extraction   *ep;\nFILE                *xfp;\nFool                 final;\n{\n\n if (final) {\n   (void)NNMunalc(ep->ddname);     /* Unallocate the PDS */\n }\n else {\n   if (fclose(xfp) < 0) {\n     /* perror(ep->dsname); */\n     ERR2(\"An error occurred closing %s.\", ep->dsname);\n     np->extract_close_error = TRUE;\n   }\n }\n\n}\n\n/****** Function to close SYSOUT print file after printing. **********/\n\nstatic void\nclose_jes(np,ep,xfp,final)\nRstruc nncb         *np;\nRstruc extraction   *ep;\nFILE                *xfp;\nFool                 final;\n{\n\n if (fclose(xfp) < 0) {\n   /* perror(ep->dsname); */\n   ERR2(\"An error occurred closing %s.\", ep->dsname);\n   np->extract_close_error = TRUE;\n }\n if (final) {\n   (void)NNMunalc(ep->ddname);     /* Unallocate the SYSOUT file */\n }\n\n}\n\n/****** Allocate SYSOUT file. ****************************************/\n\nstatic Bool\nallocate_sysout(ep,sp)\nRstruc extraction   *ep;\nRstruc sysout       *sp;\n{\n int          i;\n int          rc;\n char        *cp;\n __S99parms   stuff99;   /* The manual has it wrong.  No \"struct\". */\n TEXTUNIT    *tu \u00dd 7\u00a8;\n TEXTUNIT     tu_sysout;\n TEXTUNIT     tu_copies;\n TEXTUNIT     tu_dest;\n TEXTUNIT     tu_forms;\n TEXTUNIT     tu_ucs;\n TEXTUNIT     tu_rtddn;\n\n memset((char *)&stuff99,0,sizeof(__S99parms));\n\n stuff99.__S99RBLN   = 20;\n stuff99.__S99VERB   = S99VRBAL;\n stuff99.__S99FLAG1  = S99NOCNV << 8;\n stuff99.__S99ERROR  = 0;\n stuff99.__S99INFO   = 0;\n stuff99.__S99TXTPP  = tu;\n stuff99.__S99FLAG2  = 0;\n\n i = 0;\n\n tu\u00ddi++\u00a8 = &tu_sysout;\n\n tu_sysout.key        = DALSYSOU;\n tu_sysout.num        = 1;\n tu_sysout.ent.len    = 1;\n tu_sysout.ent.prm\u00dd0\u00a8 = toupper(sp->class\u00dd0\u00a8);\n\n tu\u00ddi++\u00a8 = &tu_copies;\n\n tu_copies.key        = DALCOPYS;\n tu_copies.num        = 1;\n tu_copies.ent.len    = 1;\n tu_copies.ent.prm\u00dd0\u00a8 = (unsigned char)sp->copies;\n\n if (sp->dest\u00dd0\u00a8 > ' ') {\n\n  tu\u00ddi++\u00a8 = &tu_dest;\n\n  tu_dest.key          = DALSUSER;\n  tu_dest.num          = 1;\n  copy_uppercase_and_strip_trailing(tu_dest.ent.prm,sp->dest,cp);\n  tu_dest.ent.len      = cp - tu_dest.ent.prm;\n\n }\n\n if (sp->forms\u00dd0\u00a8 > ' ') {\n\n  tu\u00ddi++\u00a8 = &tu_forms;\n\n  tu_forms.key         = DALSFMNO;\n  tu_forms.num         = 1;\n  copy_uppercase_and_strip_trailing(tu_forms.ent.prm,sp->forms,cp);\n  tu_forms.ent.len     = cp - tu_forms.ent.prm;\n\n }\n\n if (sp->ucs\u00dd0\u00a8 > ' ') {\n\n  tu\u00ddi++\u00a8 = &tu_ucs;\n\n  tu_ucs.key           = DALUCS;\n  tu_ucs.num           = 1;\n  copy_uppercase_and_strip_trailing(tu_ucs.ent.prm,sp->ucs,cp);\n  tu_ucs.ent.len       = cp - tu_ucs.ent.prm;\n\n }\n\n tu\u00ddi++\u00a8 = &tu_rtddn;\n\n tu_rtddn.key         = DALRTDDN;\n tu_rtddn.num         = 1;\n tu_rtddn.ent.len     = 8;\n memset(tu_rtddn.ent.prm,' ',8);\n\n tu\u00ddi\u00a8 = (void *)0x80000000;\n\n rc = svc99(&stuff99);\n\n if (rc == 0) {\n   memcpy(ep->ddname,(char *)tu_rtddn.ent.prm,8);\n   ep->ddname\u00dd8\u00a8 = ' ';\n   *(strchr(ep->ddname,' ')) = '\\0';\n   return TRUE;\n }\n else {\n   NNMdfail(rc,&stuff99);\n   return FALSE;\n }\n}\n\n/****** Prompt user for the name of a data set to extract into. ******/\n\nFILE *\nNNMgetds(np,ep)\nRstruc nncb         *np;\nRstruc extraction   *ep;\n{\n FILE               *xfp;\n char               *panel_to_display;\n Bool                asked_for;\n struct sysout       sys;\n char                nnexdsn\u00dd65\u00a8;    /* data set name for extraction */\n char                nnexapp \u00dd4\u00a8;    /* YES or NO for append mode    */\n char                nnextab \u00dd4\u00a8;    /* YES or NO for tab expansion  */\n char                nnexblk \u00dd4\u00a8;    /* YES or NO for blank after sep*/\n char                nnexspa \u00dd4\u00a8;    /* YES or NO for page ejects    */\n char                nnexsep\u00dd81\u00a8;    /* Separator line (optional)    */\n char                nnexan1\u00dd16\u00a8;    /* From article number          */\n char                nnexan2\u00dd16\u00a8;    /* To   article number          */\n char                nnexpmp \u00dd9\u00a8;    /* PDS member name prefix       */\n char                nnexscl \u00dd2\u00a8;    /* Print SYSOUT class name      */\n char                nnexsco \u00dd4\u00a8;    /* Print SYSOUT copies number   */\n char                nnexsde \u00dd9\u00a8;    /* Print SYSOUT destination     */\n char                nnexsfo \u00dd5\u00a8;    /* Print SYSOUT forms           */\n char                nnexsuc \u00dd5\u00a8;    /* Print SYSOUT UCS             */\n char                quoted_dsname \u00dd67\u00a8;\n\n /* Display panel asking for data set name into which to extract. */\n\n xfp = NULL;\n asked_for = TRUE;\n\n (void)NNMispf(np,\"ADDPOP\");\n\n if (ep->mode == JES) {\n   (void)NNMivput(np,\"NNWHICH \",ep->panelname,-1);\n   (void)NNMivput(np,\"NNALLPR \",\n#ifdef FULLSYSOUT\n                     \"Y\",\n#else\n                     \"\",\n#endif\n                     -1);\n   panel_to_display = \"NNMPPRT \";\n }\n else panel_to_display = ep->panelname;\n\n while (!xfp) {\n\n   /* Keep asking for a dsname until one works or END pressed. */\n\n   if (NNMdispl(np,panel_to_display) > 0) {\n     asked_for = FALSE;\n     xfp = NULL;\n     break;\n   }\n\n   if (ep->mode == JES) {\n     (void)NNMivget(np,\"NNEXSCL \",nnexscl,sizeof(nnexscl));\n     (void)NNMivget(np,\"NNEXSCO \",nnexsco,sizeof(nnexsco));\n#ifdef FULLSYSOUT\n     (void)NNMivget(np,\"NNEXSDE \",nnexsde,sizeof(nnexsde));\n     (void)NNMivget(np,\"NNEXSFO \",nnexsfo,sizeof(nnexsfo));\n     (void)NNMivget(np,\"NNEXSUC \",nnexsuc,sizeof(nnexsuc));\n#else\n     *nnexsde = '\\0';\n     *nnexsfo = '\\0';\n     *nnexsuc = '\\0';\n#endif\n     (void)NNMivget(np,\"NNEXAN1 \",nnexan1,sizeof(nnexan1));\n     (void)NNMivget(np,\"NNEXAN2 \",nnexan2,sizeof(nnexan2));\n     (void)NNMivget(np,\"NNEXSPA \",nnexspa,sizeof(nnexspa));\n     (void)NNMivget(np,\"NNEXBLK \",nnexblk,sizeof(nnexblk));\n     (void)NNMivget(np,\"NNEXSEP \",nnexsep,sizeof(nnexsep));\n   }\n   else {\n     (void)NNMivget(np,\"NNEXDSN \",nnexdsn,sizeof(nnexdsn));\n     (void)NNMivget(np,\"NNEXTAB \",nnextab,sizeof(nnextab));\n     (void)NNMivget(np,\"NNEXAN1 \",nnexan1,sizeof(nnexan1));\n     (void)NNMivget(np,\"NNEXAN2 \",nnexan2,sizeof(nnexan2));\n     if (ep->mode == PDS) {\n       (void)NNMivget(np,\"NNEXPMP \",nnexpmp,sizeof(nnexpmp));\n     }\n     else {\n       (void)NNMivget(np,\"NNEXAPP \",nnexapp,sizeof(nnexapp));\n       (void)NNMivget(np,\"NNEXBLK \",nnexblk,sizeof(nnexblk));\n       (void)NNMivget(np,\"NNEXSEP \",nnexsep,sizeof(nnexsep));\n     }\n   }\n\n   if (ep->mode == PDS) {\n\n     ep->closer = close_pds;\n     ep->appending = FALSE;\n     ep->blanking  = FALSE;\n     strcpy(ep->separator,\"\");\n     strcpy(ep->ddname,\"\");\n     strcpy(ep->member_prefix,nnexpmp);\n\n     /* Note: panel forces fully-qualified name to pass to allocate */\n\n     if (nnexdsn\u00dd0\u00a8 != '\\'') {\n       strcpy(quoted_dsname,\"'\");\n       strcat(quoted_dsname,nnexdsn);\n       strcat(quoted_dsname,\"'\");\n     }\n     else strcpy(quoted_dsname,nnexdsn);\n\n     /* Check if PDS already exists. */\n\n     if (np->warn_overwrite) {\n       if (TEST_IF_FILE_EXISTS(xfp,quoted_dsname)) {\n         CLEANUP_IF_FILE_EXISTS(xfp);\n         xfp = NULL;\n         if (NNMdispl(np,\"NNMPEXPW\") > 0) {\n           WARN1(\"Operation cancelled, because you pressed END.\");\n           break;\n         }\n       }\n     }\n\n     if (!NNMalloc(nnexdsn,ep->ddname,PDS,ep->article_count)) {\n       ERR2(\"Allocation failed for data set %s.\", nnexdsn);\n       xfp = NULL;\n       continue;\n     }\n     strcpy(ep->dsname,    nnexdsn);\n     ep->tab_expanding = (nnextab\u00dd0\u00a8 == 'Y');\n   }\n   else if (ep->mode == JES) {\n     ep->closer = close_jes;\n     strcpy(ep->separator, nnexsep);\n     sprintf(ep->dsname,\"SYSOUT class %s\",nnexscl);\n     memset(&sys,0,sizeof(sys));\n     strcpy(sys.class, nnexscl);\n     sys.copies = atoi(nnexsco);\n     if (sys.copies < 1) sys.copies = 1;\n     strcpy(sys.dest,  nnexsde);\n     strcpy(sys.forms, nnexsfo);\n     strcpy(sys.ucs,   nnexsuc);\n     ep->ejecting      = (nnexspa\u00dd0\u00a8 == 'Y');\n     ep->appending     = FALSE;\n     ep->blanking      = (nnexblk\u00dd0\u00a8 == 'Y');\n     ep->tab_expanding = TRUE;\n   }\n   else {\n     ep->closer = close_seq;\n     strcpy(ep->separator, nnexsep);\n     strcpy(ep->dsname,    nnexdsn);\n     ep->appending      = (nnexapp\u00dd0\u00a8 == 'Y');\n     ep->blanking       = (nnexblk\u00dd0\u00a8 == 'Y');\n     ep->tab_expanding  = (nnextab\u00dd0\u00a8 == 'Y');\n   }\n\n   if (*nnexan1) ep->from_article_number = atoi(nnexan1);\n   else          ep->from_article_number = 0;\n   if (*nnexan2) ep->to_article_number   = atoi(nnexan2);\n   else          ep->to_article_number   = INT_MAX;\n\n   /* check if the dataset already exists */\n   /* (Wonder if this will compile.  Have fun, \"cc\"...) */\n\n   if (ep->mode != JES) {\n     if (ep->appending ? np->warn_append : np->warn_overwrite) {\n       if (TEST_IF_FILE_EXISTS(xfp,nnexdsn)) {\n         CLEANUP_IF_FILE_EXISTS(xfp);\n         xfp = NULL;\n         if (NNMdispl(np,\"NNMPEXOW\") > 0) {\n           WARN1(\"Operation cancelled, because you pressed END.\");\n           break;\n         }\n       }\n     }\n   }\n\n   if (ep->mode == JES) {\n     if (allocate_sysout(ep,&sys)) {\n       sprintf(nnexdsn,\"dd:%s\",ep->ddname);\n     }\n     else *nnexdsn = '\\0';\n   }\n\n   if (ep->mode == PDS) {\n     xfp = DUMMY_FILE_POINTER_FOR_PDS;\n     break;\n   }\n\n   if (*nnexdsn) {\n\n     if (ep->mode == JES) {\n       xfp = OPEN_SYSOUT_FILE(nnexdsn);\n     }\n     else {\n       xfp = OPEN_TEXT_FILE_FOR_WRITE_OR_APPEND(nnexdsn,ep->appending);\n     }\n\n     if (!xfp) {\n       fprintf(stderr,\"Open failure: errno=%d\\n\",errno);\n       perror(nnexdsn);\n       ERR2(\"Cannot open %s.\", ep->dsname);\n     }\n   }\n }\n\n (void)NNMispf(np,\"REMPOP\");\n\n return xfp;\n\n}\n\n./ ADD NAME=NNMGETM\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@GETM \")\n#pragma  csect(static,\"NN$GETM \")\n#include \"nn.h\"\n\n/****** Get memory. **************************************************/\n\nvoid\nNNMgetm(np,pointer,howmuch,whatfor)\nRstruc nncb    *np;\nchar          **pointer;\nint             howmuch;\nchar           *whatfor;\n{\n\n *pointer = (char *)malloc(howmuch);\n\n if (!*pointer) {\n   fprintf(stderr,\"NNMVS: Cannot obtain %d bytes of memory for %s\\n\",\n                  howmuch,whatfor);\n }\n else if (np->debug_file) {\n   fprintf(np->debug_file,\"NNMgetm: got %d bytes of memory for %s\\n\",\n                           howmuch,whatfor);\n }\n return;\n\n}\n\n./ ADD NAME=NNMGSRVL\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@GSRVL\")\n#pragma  csect(static,\"NN$GSRVL\")\n#include \"nn.h\"\n\n#define  GOT_NOTHING        0\n#define  GOT_SOMETHING      1\n#define  GOT_DISCONNECT     2\n#define  GOT_NOTAUTHORIZED  3\n\n/* separate this and call it NNMGAUTH eventually */\n\n/****** Send authorization to news server. ***************************/\n\nstatic Bool\nNNMgauth(np)\nRstruc nncb *np;\n{\n\n char              *lp;\n FILE              *fp;\n int                display_rc;\n Bool               auth_error;\n Bool               connection_probably_closed;\n char               nnauser   \u00dd65\u00a8;\n char               nnapass   \u00dd65\u00a8;\n\n /* NNTP numbers must be the following as defined in C News source:\n  *\n  * OK_AUTHSYS    280  authorization system OK\n  * OK_AUTH       281  authorization OK\n  * NEED_AUTHINFO 380  authorization is required\n  * NEED_AUTHDATA 381  <type> authorization data required (e.g. PASS)\n  * ERR_NOAUTH    480  authorization required for command\n  * ERR_AUTHSYS   481  authorization system invalid\n  * ERR_AUTHREJ   482  authorization data rejected\n  * ERR_CMDSYN    501  command syntax error\n  * ERR_COMMAND   500  command not implemented\n  * ERR_ACCESS    502  access to server denied\n  * ERR_AUTHBAD   580  authorization failed\n  *\n  * Me:     AUTHINFO USER username\n  * Server: 381 PASS required\n  *     or: 482 Authorization already completed\n  *     or: 500 Command not recognized\n  *\n  * If 482, server does not accept our attempt to gain authorization.\n  *\n  * If 500, authorization is not needed or the server has never\n  * heard of authorization.  Either way, we proceed as \"authorized\".\n  *\n  * If 381 ...\n  *\n  * Me:     AUTHINFO PASS password\n  * Server: 281 Authorization OK\n  *     or: 482 authorization data rejected\n  *     or: 502 access to server denied\n  *     or: 580 authorization failed\n  *\n  * If 502, the server has disconnected me and I should return FALSE.\n  * Otherwise, everything is OK, and I should return TRUE.\n  *\n  */\n\n lp = \"None - local system error accessing authorization file\";\n\n auth_error = FALSE;\n connection_probably_closed = FALSE;\n *nnauser   = '\\0';\n *nnapass   = '\\0';\n\n (void)NNMivget(np,\"NNAUSER \",nnauser,sizeof(nnauser));\n if (!*nnauser) {\n   (void)NNMivget(np,\"ZUSER \",nnauser,sizeof(nnauser));\n   lowercase_in_place(nnauser);\n   (void)NNMivput(np,\"NNAUSER \",nnauser,-1);\n }\n\n /* Read user and pass from terminal */\n /* temporary. change to panel */\n\n (void)NNMivput(np,\"NNSERVER \",np->nnserver,-1);\n (void)NNMispf(np,\"ADDPOP\");\n (void)NNMdispl(np,\"NNMPGAUT\");\n display_rc = np->ispfrc;\n (void)NNMispf(np,\"REMPOP\");\n if (display_rc != 0) return FALSE;\n (void)NNMivget(np,\"NNAUSER \",nnauser,sizeof(nnauser));\n (void)NNMivget(np,\"NNAPASS \",nnapass,sizeof(nnapass));\n sprintf(np->nntp_command,\"AUTHINFO USER %s\", nnauser);\n if (!NNMsockt(np)) return FALSE; /* Send socket command to server */\n if (!NNMgsrvl(np,&lp)) return FALSE;  /* Get server line */\n switch (np->nntp_message_num) {\n   case 381: /* PASS required */\n             break;\n   default:  NNMrperr(np);       /* Report protocol error */\n             auth_error = TRUE;\n             break;\n }\n\n if (!auth_error) {\n   sprintf(np->nntp_command,\"AUTHINFO PASS %s\", nnapass);\n   if (!NNMsockt(np)) return FALSE; /* Send socket command to server */\n   if (!NNMgsrvl(np,&lp)) return FALSE;  /* Get server line */\n   switch (np->nntp_message_num) {\n     case 281: /* authorization OK */\n               return TRUE;\n     case 502: /* access to server denied */\n               /* Also, we have been disconnected at this point. */\n               connection_probably_closed = TRUE;\n               auth_error = TRUE;\n               break;\n     default:  NNMrperr(np);       /* Report protocol error */\n               auth_error = TRUE;\n               break;\n   }\n }\n\n NNMesrvr(np);                   /* End server read */\n\n if (auth_error) {\n\n   if (connection_probably_closed) {\n     ERR2(\"Authorization failed;\\\nThe NNTP server at %s refuses to authorize you.  \\\nSome news operations may fail.\",\\\n          np->nnserver);\n     /* np->connection_broken = TRUE; */\n     /* NNMdisc(np); */               /* Complete disconnection */\n     return FALSE;\n   }\n   else {\n     if (np->batch_mode) {\n       fprintf(stderr,\n        \"NNMVS could not obtain authorization from the NNTP server.\\n\");\n       fprintf(stderr,\n        \"NNMVS will proceed, but some news operations may fail.\\n\");\n       fprintf(stderr,\n        \"The response from server %s was:\\n\\n%s\\n\\n\", np->nnserver,lp);\n       return FALSE;\n     }\n     else {\n       NNMivput(np,\"NNSRVRSP \",lp,          -1);\n       (void)NNMispf(np,\"ADDPOP \");\n       (void)NNMispf(np,\"DISPLAY PANEL(NNMPAUTH)\");\n       display_rc = np->ispfrc;\n       (void)NNMispf(np,\"REMPOP \");\n       if (display_rc == 0) return FALSE;\n       else {\n         /* NNMdisc(np); */\n         return FALSE;\n       }\n     }\n   }\n }\n\n return TRUE;\n\n}\n\n/****** Input one character from the server. *************************/\n\nstatic int\nsocket_getchar(np)\nRstruc nncb  *np;\n{\n int         readrc;\n\n if (np->g_buf_index == -1 ||\n     np->g_buf_index >= np->g_bytes_returned - 1) {\n   np->g_buf_index = -1;\n   if (np->dont_read) return(SOCKET_NO_MORE);\n   else {\n     TCP_DEBUG_ON;\n     readrc = read(np->socknum, np->g_buf, READ_BYTES);\n     TCP_DEBUG_OFF;\n     if (readrc == -1) {\n       np->connection_broken = TRUE;\n       return SOCKET_GETCHAR_ERROR;\n     }\n     else if (readrc == 0) {\n       np->connection_broken = TRUE;\n       return SOCKET_READ_NOTHING;\n     }\n     else {\n#ifdef MVS\n       ASCII_TO_EBCDIC(np->g_buf,readrc);\n#endif\n       np->g_bytes_returned = readrc;\n       if (np->debug_file) {\n         NNMdump(np,\"Data read from server\",np->g_buf,readrc);\n       }\n     }\n   }\n }\n return np->g_buf\u00dd++np->g_buf_index\u00a8;\n}\n\n/****** Input one data line at a time from the server. ***************/\n\nstatic enum socket_retval\nsocket_from_server(np)\nRstruc nncb *np;\n{\n char       *s_buf;\n int         s_bytes;\n int         s_buf_index;\n int         character;\n int         previous_character;\n\n s_buf   = np->server_buf;\n s_bytes = SERVER_BUF_MSGSIZE;\n\n /* Get characters from the server until CRLF is reached. */\n\n s_buf_index = 0;\n previous_character = -1;\n for (;;) {\n   character = socket_getchar(np);\n   if (character == LINE_FEED && previous_character == CARRIAGE_RETURN)\n      break;\n   if (character == SOCKET_GETCHAR_ERROR)  return(SERVER_READ_ERROR);\n   if (character == SOCKET_NO_MORE)        return(SERVER_NO_MORE);\n   if (character == SOCKET_READ_NOTHING)   return(SERVER_READ_ERROR);\n   previous_character = character;\n   if (s_buf_index >= s_bytes) {\n     fprintf(stderr,\"Error: np->server_buf overflowed.\\n\");\n     fprintf(stderr,\n             \"More than %d bytes collected without CR/LF seen.\\n\",\n             s_bytes);\n     if (np->debug_file) {\n       NNMdump(np,\"Data collected so far\",np->server_buf,s_bytes);\n     }\n     return(SERVER_BUFFER_ERROR);\n   }\n   if (character == '\\0') {\n     fprintf(stderr,\n\"Warning: null character found in data from server, changed to blank\\n\"\n            );\n     character = ' ';\n   }\n   s_buf\u00dds_buf_index++\u00a8 = (unsigned char)character;\n }\n s_buf\u00dds_buf_index\u00a8 = '\\0';\n return(SERVER_READ_OK);\n}\n\n/****** Try to reconnect. ********************************************/\n\nstatic Bool\ntry_to_reconnect(np)\nRstruc nncb     *np;\n{\n\n if (np->closing_connection || np->reconnect_in_progress) return FALSE;\n\n if (!NNMrecon(np)) return FALSE;      /* Reconnect to server */\n\n /* have to reissue most recently written command */\n\n if (np->dont_reissue_socket_command) {\n   NNMesrvr(np);           /* End server read */\n }\n else if (!NNMsockt(np)) { /* Send socket command to server */\n   return FALSE;\n }\n\n WARN2(\"Successfully reconnected to server %s after disconnect.\",\n       np->nnserver);\n return TRUE;\n\n}\n\n/****** Try to authorize. ********************************************/\n\nstatic Bool\ntry_to_authorize(np)\nRstruc nncb     *np;\n{\n char            save_command\u00ddCLIENT_BUF_MSGSIZE+4\u00a8;\n Bool            rc;\n\n if (np->closing_connection) return FALSE;\n\n NNMesrvr(np);           /* End server read */\n\n strcpy(save_command,np->nntp_command);\n rc = NNMgauth(np);                    /* Get authorization   */\n strcpy(np->nntp_command,save_command);\n if (!rc) return FALSE;\n\n /* have to reissue most recently written command */\n\n if (np->dont_reissue_socket_command) {\n   NNMesrvr(np);           /* End server read */\n }\n else if (!NNMsockt(np)) { /* Send socket command to server */\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/****** Try to get something. ****************************************/\n\nstatic int\ntry_to_get_something(np,pointer)\nRstruc nncb  *np;\nchar        **pointer;\n\n{\n char              *sbufp;\n char              *p;\n int                scan_count;\n Bool               authorization_required;  /* put this in nncb? */\n\n authorization_required = FALSE;\n\n switch (socket_from_server(np)) {\n   case SERVER_READ_OK:      break;\n   case SERVER_READ_ERROR:   ERR2(\n     \"Lost server connection.  Failure reading data from server %s.\",\n                                  np->nnserver);\n                             np->time_to_go_home = TRUE;\n                             break;\n   case SERVER_BUFFER_ERROR: ERR2(\n \"Read error.  No linefeed character found in data from server %s.\",\n                                  np->nnserver);\n                             np->time_to_go_home = TRUE;\n                             break;\n   case SERVER_NO_MORE:      np->server_has_something_pending = FALSE;\n                             break;\n }\n\n if (np->connection_broken)  return GOT_DISCONNECT;\n if (np->time_to_go_home)    return GOT_NOTHING;\n if (np->dont_read && !np->server_has_something_pending)\n                             return GOT_SOMETHING;\n\n np->something_to_print = TRUE;\n\n sbufp = np->server_buf;\n\n if (np->sending_text) {\n   if (*sbufp == '.') {\n     /*\n     NNMdump(np,\"Line that starts with a period\",sbufp,strlen(sbufp));\n     */\n     switch (*(sbufp+1)) {\n        case CARRIAGE_RETURN:\n        case LINE_FEED:\n        case '\\0':\n                  np->server_finished_replying = TRUE;\n               /* np->something_to_print = FALSE; */\n                  break;\n        case '.':\n                  break;\n        default:\n                  NNMdump(np,\"Warning, bad period in line from server\",\n                          sbufp,strlen(sbufp));\n                  break;\n     }\n   }\n   else /* nothing - still sending that there text */ ;\n\n   np->nntp_message_num  = NO_NNTP_MESSAGE_NUM;\n   np->nntp_message_text = sbufp;\n }\n else {\n       np->nntp_message_num = NO_NNTP_MESSAGE_NUM;\n       scan_count = 0;\n       sscanf(sbufp,\"%d %n\",&np->nntp_message_num,&scan_count);\n       np->nntp_message_text = sbufp + scan_count;\n       /*  NNMdump(np,\"message_num\", np->nntp_message_num, -2);  */\n       /*  NNMdump(np,\"message_text\",np->nntp_message_text,-1);  */\n       switch (np->nntp_message_num) {\n          case 205:\n          case 400:\n       /* case 502: */\n                   np->server_finished_replying = TRUE;\n                   np->time_to_go_home = TRUE;\n                   break;\n          case 503:\n                   np->server_finished_replying = TRUE;\n                   np->connection_broken = TRUE;\n                   np->time_to_go_home = TRUE;\n                   np->g_bytes_returned = 0;\n                   np->g_buf_index = -1;\n                   np->something_to_print = FALSE;\n                   break;\n          case 380:\n          case 480:\n                   authorization_required = TRUE;\n                   np->server_finished_replying = TRUE;\n                   np->connection_broken = FALSE;\n                   np->g_bytes_returned = 0;\n                   np->g_buf_index = -1;\n                   np->something_to_print = FALSE;\n                   break;\n          case 335:\n          case 340:\n                   np->server_finished_replying = TRUE;\n                   np->receiving_text = TRUE;\n                   break;\n          case 100:\n          case 199:\n          case 215:\n          case 220:\n          case 221:\n          case 222:\n          case 230:\n          case 231:\n                   np->sending_text = TRUE;\n                   break;\n          case NO_NNTP_MESSAGE_NUM:\n                   fprintf(stderr,\n    \"Error: No NNTP message ID number in response from server %s.\\n\",\n                                  np->nnserver);\n                   np->sending_text = TRUE;\n                   np->receiving_text = FALSE;\n                   break;\n          default:\n                   np->server_finished_replying = TRUE;\n                   break;\n   }\n }\n\n if (np->something_to_print) {\n   /* Last character of output buffer is a CR without LF. */\n   p = sbufp + strlen(sbufp)-1;\n   if (p >= sbufp) {\n     if (*p == CARRIAGE_RETURN) *p = '\\0';\n     else {\n       fprintf(stderr,\n   \"Warning: No carriage return in data from server (%d bytes):\\n%s\\n\",\n               strlen(sbufp), sbufp);\n         CRIT2(\n\"Carriage return expected but not seen in data from server %s.\",\n               np->nnserver);\n          }\n   }\n   *pointer = sbufp;\n }\n\n if (np->debug_file) {\n   NNMdump(np,\"Response from server\",sbufp,strlen(sbufp));\n }\n\n return (\n         np->connection_broken        ? GOT_DISCONNECT\n       : authorization_required       ? GOT_NOTAUTHORIZED\n       : np->time_to_go_home          ? GOT_NOTHING\n       :                                GOT_SOMETHING\n        );\n}\n\n/****** Get server line. *********************************************/\n\nBool\nNNMgsrvl(np,pointer)\nRstruc nncb  *np;\nchar        **pointer;\n{\n int                tries;\n Bool               retry;\n Bool               rc;\n\n *pointer = NULL;\n\n if (np->receiving_text) { /* as when POSTing a news item... */\n   return TRUE;\n }\n\n if (np->server_finished_replying) np->dont_read = TRUE;\n\n for (tries=0;tries<2;tries++) {\n\n   switch (try_to_get_something(np,pointer)) {\n     case GOT_SOMETHING:     return TRUE;\n     case GOT_NOTHING:       return FALSE;\n     case GOT_DISCONNECT:    if (try_to_reconnect(np)) continue;\n                             else return FALSE;\n     case GOT_NOTAUTHORIZED: if (try_to_authorize(np)) continue;\n                             else return FALSE;\n   }\n\n }\n\n}\n\n./ ADD NAME=NNMIERR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@IERR \")\n#pragma  csect(static,\"NN$IERR \")\n#include \"nn.h\"\n\n/****** ISPF error handler. ******************************************/\n\nvoid\nNNMierr(np)\nRstruc nncb *np;\n{\n char        errbuf\u00dd\u00a8 = \"DISPLAY PANEL(ISPTERM)\";\n int         errlen;\n\n if (np->batch_mode) {\n   fprintf(stderr,\"ISPF services cannot be called from batch mode.\\n\");\n   return;\n }\n\n errlen = strlen(errbuf);\n switch (ISPEXEC(&errlen,errbuf)) {\n   case  0:\n   case  4:\n   case  8: break;\n   default: fprintf(stderr,\n\"\\n*** Severe ISPF error, cannot even display ISPTERM error panel.\\n\");\n            fprintf(stderr,\n\"\\n*** Return code from ISPF service is %d\\n\",np->ispfrc);\n            break;\n }\n\n return;\n}\n\n./ ADD NAME=NNMIGET\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@IGET \")\n#pragma  csect(static,\"NN$IGET \")\n#include \"nn.h\"\n\n/****** Retrieve the value of an ISPF variable into an integer. ******/\n\nint\nNNMiget(np,varname)\nRstruc nncb *np;\nchar        *varname;\n{\n char        varbuf\u00dd16\u00a8;\n int         vcopy_length;\n\n if (!strchr(varname,' ')) {\n   fprintf(stderr,\"NNMiget: no blank passed in var name\\n\");\n   return FALSE;\n }\n\n vcopy_length = sizeof(varbuf);\n\n np->ispfrc = ISPLINK(\"VCOPY\",varname,&vcopy_length,varbuf,\"MOVE\");\n switch (np->ispfrc) {\n   case  0:\n           varbuf\u00ddvcopy_length\u00a8 = '\\0';\n           return atoi(varbuf);\n   case  8:\n           return 0;\n   case 16:\n           fprintf(stderr,\n                   \"Error: ISPF variable buffer too short to get %s\\n\",\n                   varname);\n           return 0;\n   default:\n           NNMierr(np);   /* handle ISPF error */\n           return 0;\n }\n}\n\n./ ADD NAME=NNMINIT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@INIT \")\n#pragma  csect(static,\"NN$INIT \")\n#include \"nn.h\"\n\n#define ARGSIZE            72\n\n#define clear_subject(X)   if ((X)->selsubj) {*(X)->selsubj = '\\0';}\n#define subjectlt(X)       subjectcmp(X) < 0\n#define NO_COMPARISON      TRUE\n#define subjectmatch       NNMsumat(_subj,_ap->subject)\n#define SEMI               ;\n#define NOTHINGFUN(A)      /* */\n#define ANYFUN(A)          SetUnknown(A)\n#define NOFUN(A)           /* */\n#define SETSUBJECTFUN(A)   _subj = set_subject(np,A->subject)\n#define NOSUBJECTFUN(A)    clear_subject(np)\n\n#define SEARCH_FIRST_TO_LAST(Apnew,Apold,Initfun,Compfun,Any) \\\n        SEARCH(Apnew,Apold,Initfun##FUN,Compfun,Any##FUN,\\\n         (_wp = _wpfirst SEMI _wp <= _wplast SEMI _wp++),\\\n         (_vp = _vpfirst SEMI _vp <= _vplast SEMI _vp++))\n\n#define SEARCH_LAST_TO_FIRST(Apnew,Apold,Initfun,Compfun,Any) \\\n        SEARCH(Apnew,Apold,Initfun##FUN,Compfun,Any##FUN,\\\n         (_wp = _wplast SEMI _wp >= _wpfirst SEMI _wp--),\\\n         (_vp = _vplast SEMI _vp >= _vpfirst SEMI _vp--))\n\n#define SEARCH_CURRENT_TO_FIRST(Apnew,Apold,Initfun,Compfun,Any) \\\n        SEARCH(Apnew,Apold,Initfun##FUN,Compfun,Any##FUN,\\\n (_wp = (np->current_sortvark-1) SEMI  _wp >= _wpfirst SEMI  _wp--),\\\n (_vp = &GETVARK(gp,Apold->number)-1 SEMI  _vp >= _vpfirst SEMI  _vp--))\n\n#define SEARCH_CURRENT_TO_LAST(Apnew,Apold,Initfun,Compfun,Any) \\\n        SEARCH(Apnew,Apold,Initfun##FUN,Compfun,Any##FUN,\\\n (_wp = (np->current_sortvark+1) SEMI  _wp <= _wplast SEMI  _wp++),\\\n (_vp = &GETVARK(gp,Apold->number)+1 SEMI  _vp <= _vplast SEMI  _vp++))\n\n#define SEARCH(Apnew,Apold,Initexp,Compexp,Anyexp,Forwp,Forvp) \\\n {\\\n  struct newsarticle  *_ap;\\\n  VARK                *_vp;\\\n  VARK                *_vpfirst;\\\n  VARK                *_vplast;\\\n  VARK               **_wp;\\\n  VARK               **_wpfirst;\\\n  VARK               **_wplast;\\\n  char                *_subj;\\\n\\\n  Initexp(Apold);\\\n  Apnew = NULL;\\\n   if (gp->sort_vector) {\\\n     _wpfirst = gp->sort_vector;\\\n     _wplast  = gp->sort_vector + gp->sort_count - 1;\\\n     for Forwp {\\\n       vp = *_wp;\\\n       Anyexp(*vp);\\\n       if (NNMcar(np,gp,0,vp,&_ap,&cd,RETRIEVE) && (Compexp)) {\\\n         np->current_sortvark = _wp;\\\n         Apnew = _ap;\\\n         break;\\\n       }\\\n     }\\\n   }\\\n   else if (gp->article_vector) {\\\n     _vpfirst = &GETVARKFIRST(gp);\\\n     _vplast  = &GETVARKLAST(gp);\\\n     for Forvp {\\\n       vp = _vp;\\\n       Anyexp(*vp);\\\n       if (NNMcar(np,gp,0,vp,&_ap,&cd,RETRIEVE) && (Compexp)) {\\\n         Apnew = _ap;\\\n         break;\\\n       }\\\n     }\\\n   }\\\n }\n\n#define ERROR_NEXT_ARTICLE              \\\n             \"There are no further articles in this newsgroup.\"\n#define ERROR_PREV_ARTICLE              \\\n             \"There are no previous articles in this newsgroup.\"\n#define ERROR_NEXT_TABLED_ARTICLE       \\\n \"There are no more news articles that satisfy the current criteria.\"\n#define ERROR_PREV_TABLED_ARTICLE       \\\n\"There are no previous news articles that satisfy the current criteria.\"\n#define ERROR_NEXT_UNREAD_ARTICLE       \\\n            \"There are no further unread articles in this newsgroup.\"\n#define ERROR_PREV_UNREAD_ARTICLE       \\\n           \"There are no previous unread articles in this newsgroup.\"\n#define ERROR_NEXT_THREAD_ARTICLE       \\\n   np->show_all_articles ? \\\n   \"There are no further articles on this subject in this newsgroup.\" \\\n   : \\\n   \"No further UNREAD articles on this subject in this newsgroup.\"\n#define ERROR_PREV_THREAD_ARTICLE       \\\n   np->show_all_articles ? \\\n  \"There are no previous articles on this subject in this newsgroup.\" \\\n   : \\\n  \"No previous UNREAD articles on this subject in this newsgroup.\"\n#define ERROR_FIRST_THREAD_ARTICLE      \\\n   np->show_all_articles ? \\\n  \"No other article could be found on this subject in this newsgroup.\" \\\n   : \\\n  \"No UNREAD article could be found on this subject in this newsgroup.\"\n#define ERROR_LAST_THREAD_ARTICLE       \\\n   np->show_all_articles ? \\\n  \"No other article could be found on this subject in this newsgroup.\" \\\n   : \\\n  \"No UNREAD article could be found on this subject in this newsgroup.\"\n#define ERROR_NEW_THREAD_ARTICLE        \\\n  \"There are no unread articles on other subjects in this newsgroup.\"\n\n#define CDSET cd.do_update = (np->updatefreq >= 0);\\\n              cd.done = 0;\\\n              if (cd.do_update && gp->article_vector) {\\\n                cd.to_do = 0;\\\n                for (vp = vpfirst; vp <= vplast; vp++) {\\\n                  if (IsNull(*vp)) cd.to_do++;\\\n                }\\\n              }\\\n              else cd.to_do = -1\n\nenum getop_option {\n                   GETOP_NOMORE,\n                   GETOP_ASIS,\n                   GETOP_UPPERCASE,\n                   GETOP_LOWERCASE,\n                   GETOP_INTEGER\n                  };\n\n/****** Get the next operand of the command. *************************/\n\nstatic Bool\ngetop(np,bufpp,argp,option)\nRstruc nncb            *np;\nchar                  **bufpp;\nchar                   *argp;\nenum getop_option       option;\n{\n register char         *icp;\n register char         *ocp;\n register int           olen;\n int                    maxlen;\n char                   quote;\n char                   work\u00dd12\u00a8;\n\n icp = skip_ISPF_whitespace(*bufpp);\n if (!*icp) {                          /* if reached end of buffer  */\n   *bufpp = icp;\n   switch (option) {\n     case GETOP_NOMORE:  return TRUE;            /* indicate no more */\n     case GETOP_INTEGER: ERR1(\"A numeric integer value is required.\");\n                         return FALSE;\n     default:            *argp = '\\0';  /* set operand to null string*/\n                         return TRUE;\n   }\n }\n\n /* icp points to next argument in buffer */\n\n if (option == GETOP_NOMORE) return FALSE;   /* too many operands */\n\n if (option == GETOP_INTEGER) {\n   ocp = work;\n   maxlen = sizeof(work);\n   quote = '\\0';\n  }\n else {\n   ocp = argp;\n   maxlen = ARGSIZE;\n   switch (*icp) {\n     case '\\'':\n     case '\"' :  quote = *icp; break;\n     default:    quote = '\\0'; break;\n   }\n }\n\n if (quote) {\n   for (icp++,olen=0; ; icp++,ocp++,olen++) {\n     if (!*icp) {\n       ERR1(\"Beginning quote mark not matched by ending quote mark.\");\n       *bufpp = icp;\n       return FALSE;\n     }\n     if (*icp == quote) {\n       if (*(++icp) != quote) {\n         *bufpp = icp;\n         break;\n       }\n     }\n     if (olen <= maxlen) {\n       switch (option) {\n         case GETOP_LOWERCASE:  *ocp = tolower(*icp); break;\n         case GETOP_UPPERCASE:  *ocp = toupper(*icp); break;\n         default:               *ocp = *icp;          break;\n       }\n     }\n   }\n   if (olen > maxlen) {\n     ERR2(\"An operand longer than %d characters is not valid.\", maxlen);\n     return FALSE;\n   }\n }\n else {\n   find_ISPF_whitespace(*bufpp,icp);\n   olen = *bufpp - icp;\n\n   if (olen > maxlen) {\n     ERR2(\"An operand longer than %d characters is not valid.\", maxlen);\n     return FALSE;\n   }\n\n   switch (option) {\n     case GETOP_LOWERCASE: while (olen--) *ocp++ = tolower(*icp++);\n                           break;\n     case GETOP_UPPERCASE: while (olen--) *ocp++ = toupper(*icp++);\n                           break;\n     default:              while (olen--) *ocp++ = *icp++;\n                           break;\n   }\n }\n\n *ocp = '\\0';\n\n if (option == GETOP_INTEGER) {\n   if (*(work + strspn(work,\"0123456789\"))) {\n     ERR1(\"A numeric integer value is required.\");\n     return FALSE;\n   }\n   *(int *)argp = atoi(work);\n }\n\n return TRUE;\n\n}\n\n/****** Subject compare, for locating by subject. ********************/\n\n/* May want to emulate NNMstrlc for more efficiency.  All that is\n * needed is to add code to NNMstrlc to strip re's.\n */\n\nstatic int\nsubjectcmp(a,b)\nchar        *a;\nchar        *b;\n{\n char       *c1;\n char       *c2;\n int         re_count_1;\n int         re_count_2;\n int         answer;\n char        s2\u00dd257\u00a8;\n\n /* arg 1 already lowercased */\n\n strncpy(s2,b,256);\n\n lowercase_and_strip_trailing_in_place(s2);\n\n c1 = a;\n c2 = s2;\n\n re_count_1 = 0;\n while (!memcmp(c1,\"re:\",3)) {\n   c1 = skip_whitespace(c1+3);\n   re_count_1++;\n }\n re_count_2 = 0;\n while (!memcmp(c2,\"re:\",3)) {\n   c2 = skip_whitespace(c2+3);\n   re_count_2++;\n }\n\n if ((answer=strcmp(c1,c2)) != 0) return answer;\n else return re_count_1 - re_count_2;\n\n}\n\n/****** Mark all articles read. **************************************/\n\nstatic Bool\nmark_all_articles_read(np,gp,prompt)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\nFool                  prompt;\n{\n int                  prc;\n VARK                *vp;\n VARK                *vpfirst;\n VARK                *vplast;\n\n /* Display panel asking if user really wants to do this. */\n\n if (prompt && !np->batch_mode) {\n   (void)NNMivput(np,\"NNMARK \",\"Read\",-1);\n   (void)NNMispf(np,\"ADDPOP\");\n   prc = NNMdispl(np,\"NNMPMARK\");\n   (void)NNMispf(np,\"REMPOP\");\n   if (prc > 0) { /* see if user pressed END */\n     WARN1(\"Operation cancelled, because you pressed END.\");\n     return TRUE;\n   }\n }\n\n if (gp->article_vector) {\n   vpfirst = &GETVARKFIRST(gp);\n   vplast  = &GETVARKLAST(gp);\n   for (vp = vpfirst; vp <= vplast; vp++) {\n     SetRead(*vp);\n   }\n }\n else {  /* no article vector, group was never selected */\n   if (gp->saved_newsrc_line\n    && gp->saved_newsrc_line != gp->saved_newsrc_data) {\n     FREEMAIN(gp->saved_newsrc_line,\"unparsed newsrc line\");\n   }\n   gp->saved_newsrc_line = gp->saved_newsrc_data;\n   sprintf(gp->saved_newsrc_data,\"<%d\",gp->high_number);\n }\n\n gp->unread_count = 0;\n\n WARN2(\"All of the articles in %s are now marked READ.\",\n       gp->name);\n\n return TRUE;\n}\n\n/****** Mark all articles unread. ************************************/\n\nstatic Bool\nmark_all_articles_unread(np,gp,prompt)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\nFool                  prompt;\n{\n int                  prc;\n int                  uc;\n VARK                *vp;\n VARK                *vpfirst;\n VARK                *vplast;\n\n /* Display panel asking if user really wants to do this. */\n\n if (prompt && !np->batch_mode) {\n   (void)NNMivput(np,\"NNMARK \",\"Unread\",-1);\n   (void)NNMispf(np,\"ADDPOP\");\n   prc = NNMdispl(np,\"NNMPMARK\");\n   (void)NNMispf(np,\"REMPOP\");\n   if (prc > 0) { /* see if user pressed END */\n     WARN1(\"Operation cancelled, because you pressed END.\");\n     return TRUE;\n   }\n }\n\n if (gp->article_vector) {\n   uc = 0;\n   vpfirst = &GETVARKFIRST(gp);\n   vplast  = &GETVARKLAST(gp);\n   for (vp = vpfirst; vp <= vplast; vp++) {\n     /* Note that we don't mark missing articles unread. */\n     if (IsPresent(*vp)) {\n       if (IsRead(*vp)) uc++;\n       SetUnread(*vp);\n     }\n   }\n   gp->unread_count += uc;\n }\n else {  /* no article vector, group was never selected */\n   if (gp->saved_newsrc_line\n    && gp->saved_newsrc_line != gp->saved_newsrc_data) {\n     FREEMAIN(gp->saved_newsrc_line,\"unparsed newsrc line\");\n   }\n   gp->saved_newsrc_line = gp->saved_newsrc_data;\n   strcpy(gp->saved_newsrc_data,\"<0\");\n   gp->unread_count = gp->article_count;\n }\n\n WARN2(\"All of the articles in %s are now marked UNREAD.\",\n       gp->name);\n\n return TRUE;\n}\n\n/****** Set subject. *************************************************/\n\nstatic char *\nset_subject(np,subj)\nRstruc nncb         *np;\nchar                *subj;\n{\n char               *s;\n\n if (*np->selsubj) return np->selsubj;\n\n strncpy(np->selsubj, subj, sizeof(np->selsubj)-1);\n s = np->selsubj;\n lowercase_and_strip_trailing_in_place(s);\n while (!memcmp(s,\"re:\",3)) {\n   s = skip_whitespace(s+3);\n }\n\n return s;\n\n}\n\n/****** Process newsgroup LOCATE command. ****************************/\n\nstatic Bool\nnewsgroup_locate_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n char                string\u00ddARGSIZE\u00a8;\n\n /*\n  * Pass back the group name to position to.  NNMVNG will do the rest.\n  */\n\n if (!getop(np,&rest,&string,GETOP_LOWERCASE)) return FALSE;\n\n if (!*string || !getop(np,&rest,NULL,GETOP_NOMORE)) {\n   ERR1(\"The LOCATE command requires exactly one operand.\");\n   return FALSE;\n }\n\n strcpy(np->newsgroup_locate_string, string);\n\n np->please_locate_group = TRUE;\n\n return TRUE;\n}\n\n/****** Process newsgroup ONLY command. ******************************/\n\nstatic Bool\nnewsgroup_only_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n char                string\u00ddARGSIZE\u00a8;\n\n if (!getop(np,&rest,&string,GETOP_LOWERCASE)) return FALSE;\n\n if (!getop(np,&rest,NULL,GETOP_NOMORE)) {\n   ERR1(\n\"The ONLY command may have only one operand.  Try quoting the string.\"\n       );\n   return FALSE;\n }\n\n strcpy(np->newsgroup_only_string, string);\n\n np->newsgroup_criterion_changed = TRUE;\n\n if (*np->newsgroup_only_string) {\n   WARN2(\n    \"To redisplay %s newsgroups, use ONLY command without operands.\",\n         (np->show_all_newsgroups ? \"all\" : \"all registered\"));\n }\n\n return TRUE;\n}\n\n/****** Process newsgroup FIND command. ******************************/\n\nstatic Bool\nnewsgroup_find_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n Bool                string_given;\n Bool                option_given;\n char                string \u00ddARGSIZE\u00a8;\n char                opt    \u00ddARGSIZE\u00a8;\n\n /*\n  * Pass back the group name to position to.  NNMVNG will do the rest.\n  */\n\n if (!getop(np,&rest,&string,GETOP_LOWERCASE)) return FALSE;\n if (!getop(np,&rest,&opt   ,GETOP_LOWERCASE)) return FALSE;\n\n if (!getop(np,&rest,NULL,GETOP_NOMORE)) {\n   ERR1(\n    \"Too many operands on the FIND command.  Try quoting the string.\");\n   return FALSE;\n }\n\n string_given = *string;\n option_given = *opt;\n\n if (string_given) {\n   strcpy(np->newsgroup_find_string,string);\n }\n else if (!*np->newsgroup_find_string) {\n   ERR1(\n      \"The FIND command requires a string the first time it is used.\");\n   return FALSE;\n }\n\n if (option_given) {\n   if      (EQUAL(opt,\"next\"  )) np->newsgroup_find_option = FIND_NEXT;\n   else if (EQUAL(opt,\"first\" )) np->newsgroup_find_option = FIND_FIRST;\n   else if (EQUAL(opt,\"prev\"  )) np->newsgroup_find_option = FIND_PREV;\n   else if (EQUAL(opt,\"last\"  )) np->newsgroup_find_option = FIND_LAST;\n   else {\n     ERR1(\"Unknown FIND option.  Specify NEXT, PREV, FIRST or LAST.\");\n     return FALSE;\n   }\n }\n else {\n   if (string_given)  np->newsgroup_find_option = FIND_NEXT;\n   else switch (np->newsgroup_find_option) {\n     case FIND_NEXT:  np->newsgroup_find_option = FIND_NEXT; break;\n     case FIND_PREV:  np->newsgroup_find_option = FIND_PREV; break;\n     case FIND_FIRST: np->newsgroup_find_option = FIND_NEXT; break;\n     case FIND_LAST:  np->newsgroup_find_option = FIND_PREV; break;\n     default:         np->newsgroup_find_option = FIND_NEXT; break;\n   }\n }\n\n np->please_find_group = TRUE;\n np->repeat_find = (!string_given && !option_given);\n\n return TRUE;\n}\n\n/****** Process newsgroup EXTRACT command. ***************************/\n\nstatic Bool\nnewsgroup_extract_command(np,gp,rest)\nRstruc nncb         *np;\nstruct newsgroup    *gp;\nchar                *rest;\n{\n\n if (!getop(np,&rest,NULL,GETOP_NOMORE)) {\n   ERR1(\"The EXTRACT command does not accept any operands.\");\n   return FALSE;\n }\n\n return NNMxlist(np,SEQ);  /* Extract newsgroup listing */\n\n}\n\n/****** Process newsgroup PRINT command. *****************************/\n\nstatic Bool\nnewsgroup_print_command(np,gp,rest)\nRstruc nncb         *np;\nstruct newsgroup    *gp;\nchar                *rest;\n{\n\n if (!getop(np,&rest,NULL,GETOP_NOMORE)) {\n   ERR1(\"The PRINT command does not accept any operands.\");\n   return FALSE;\n }\n\n return NNMxlist(np,JES);  /* Extract newsgroup listing */\n\n}\n\n/****** Process newsgroup REG command. *******************************/\n\nstatic Bool\nnewsgroup_reg_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n\n np->newsgroup_criterion_changed = TRUE;\n np->show_all_newsgroups = FALSE;\n if (*np->newsgroup_only_string) {\n   WARN2(\n    \"To redisplay %s newsgroups, use ONLY command without operands.\",\n         (np->show_all_newsgroups ? \"all\" : \"all registered\"));\n }\n\n return TRUE;\n}\n\n/****** Process newsgroup ALL command. *******************************/\n\nstatic Bool\nnewsgroup_all_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n\n np->newsgroup_criterion_changed = TRUE;\n np->show_all_newsgroups = TRUE;\n if (*np->newsgroup_only_string) {\n   WARN2(\n    \"To redisplay %s newsgroups, use ONLY command without operands.\",\n         (np->show_all_newsgroups ? \"all\" : \"all registered\"));\n }\n\n return TRUE;\n}\n\n/****** Process newsgroup ORDER command. *****************************/\n\nstatic Bool\nnewsgroup_order_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n char                string\u00ddARGSIZE\u00a8;\n char                order;\n\n /* Usage: ORDER A   -  display newsgroups in alphabetical order\n  *        ORDER L   -  display newsgroups in NNTP list order\n  *        ORDER N   -  display newsgroups in NEWSRC order\n  */\n\n if (!getop(np,&rest,&string,GETOP_ASIS)) return FALSE;\n\n if (!getop(np,&rest,NULL,GETOP_NOMORE)) {\n   ERR1(\n     \"The ORDER command requires one operand: Alphabetical or List.\");\n   return FALSE;\n }\n\n switch (string\u00dd0\u00a8) {\n   case 'a':\n   case 'A': order = ALPHABETICAL_ORDER;  break;\n   case 'l':\n   case 'L': order = NNTP_LIST_ORDER;     break;\n   case 'n':\n   case 'N': order = NEWSRC_ORDER;        break;\n   default:\n             ERR1(\n     \"The ORDER command requires one operand: Alphabetical or List.\");\n                                          return FALSE;\n }\n\n if (order == NEWSRC_ORDER) {\n   ERR1(\"Sorry, but NEWSRC order has not been implemented.\");\n   return FALSE;\n }\n\n if (order == NNTP_LIST_ORDER && !np->first_newsgroup_alt) {\n   ERR1(\n\"List order is valid only when newsgroup list retrieved from server.\"\n       );\n   return FALSE;\n }\n\n np->newsgroup_order_changed = TRUE;\n np->newsgroup_order = order;\n\n return TRUE;\n}\n\n/****** Process newsgroup RESCAN command. *DDI************************/\n\nstatic Bool\nnewsgroup_rescan_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n\n if (!NNMdlang(np,LIST_ALL_RESCAN)) return FALSE;\n\n /* Must turn off GroupSelected status so that NNMpng will call NNMdng\n  * when the group is later selected. Pretty nervous about this one.\n  * -DDI\n  */\n\n for (gp=np->first_newsgroup; gp; gp=gp->next) {\n   OffGroupSelected(gp);\n }\n\n return TRUE;\n}\n\n/****** Process article RESCAN command. *DDI**************************/\n\nstatic Bool\narticle_rescan_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n\n NNMdlang(np,LIST_ALL_RESCAN);\n np->current_newsgroup = gp;  /* undo NNMdlang's damage */\n NNMdng(np,gp,NULL);\n np->article_criterion_changed = TRUE;\n\n return TRUE;\n}\n\n/****** Process article LOCATE command. ******************************/\n\nstatic Bool\narticle_locate_command(np,gp,rest)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\nchar                 *rest;\n{\n struct newsarticle  *ap;\n VARK               **wp;\n VARK               **wpfirst;\n VARK               **wplast;\n int                  lnum;\n struct countdown     cd;\n char                 string\u00ddARGSIZE\u00a8;\n\n if (gp->sort_vector) {\n   if (!getop(np,&rest,&string,GETOP_LOWERCASE)) return FALSE;\n   if (!*string || !getop(np,&rest,NULL,GETOP_NOMORE)) {\n     ERR1(\"The LOCATE command requires exactly one operand.\");\n     return FALSE;\n   }\n   /* Position to article with subject closest to requested subject */\n   wpfirst = gp->sort_vector;\n   wplast  = gp->sort_vector + gp->sort_count - 1;\n   for (wp = wpfirst; wp < wplast; wp++) {\n     if (NNMcar(np,gp,0,*wp,&ap,&cd,RETRIEVE)\n      && subjectcmp(string,ap->subject) <= 0)\n         break;\n   }\n   np->current_sortvark = wp;\n   np->top_sorted_article = wp;\n }\n else {\n   if (!getop(np,&rest,(char *)&lnum,GETOP_INTEGER)) return FALSE;\n   if (!getop(np,&rest,NULL,GETOP_NOMORE)) {\n     ERR1(\"The LOCATE command requires exactly one operand.\");\n     return FALSE;\n   }\n   /* Position to article with number closest to requested number */\n   if (lnum < gp->vector_first) lnum = gp->vector_first;\n   if (lnum > gp->vector_last)  lnum = gp->vector_last;\n   np->top_article = lnum;\n }\n\n /* Note: We don't worry about whether that article, or any of the\n  * articles between the current one and this one, are in the table.\n  * When NNMvar regenerates the display, it will know that the top\n  * article has changed and will figure it out.\n  */\n\n return TRUE;\n}\n\n/****** Process article FIND command. ********************************/\n\nstatic Bool\narticle_find_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n int                 save_top_article;\n VARK              **save_top_sorted_article;\n struct newsarticle *ap;\n VARK               *vp;\n VARK               *vpfirst;\n VARK               *vplast;\n VARK              **wp;\n VARK              **wpfirst;\n VARK              **wplast;\n VARK              **found_sorted_article;\n int                 found_article;\n int                 findbump;\n int                 anum;\n Bool                string_given;\n Bool                option_given;\n char                string \u00ddARGSIZE\u00a8;\n char                option \u00ddARGSIZE\u00a8;\n struct countdown    cd;\n\n if (!getop(np,&rest,&string,GETOP_LOWERCASE)) return FALSE;\n if (!getop(np,&rest,&option,GETOP_LOWERCASE)) return FALSE;\n\n if (!getop(np,&rest,NULL,GETOP_NOMORE)) {\n   ERR1(\n    \"Too many operands on the FIND command.  Try quoting the string.\");\n   return FALSE;\n }\n\n string_given = *string;\n option_given = *option;\n\n if (string_given) {\n   strcpy(np->article_find_string,string);\n }\n else if (!*np->article_find_string) {\n   ERR1(\n      \"The FIND command requires a string the first time it is used.\");\n   return FALSE;\n }\n\n if (option_given) {\n   if      (EQUAL(option,\"next\" )) np->article_find_option = FIND_NEXT;\n   else if (EQUAL(option,\"first\")) np->article_find_option = FIND_FIRST;\n   else if (EQUAL(option,\"prev\" )) np->article_find_option = FIND_PREV;\n   else if (EQUAL(option,\"last\" )) np->article_find_option = FIND_LAST;\n   else {\n     ERR1(\"Unknown FIND option.  Specify NEXT, PREV, FIRST or LAST.\");\n     return FALSE;\n   }\n }\n else {\n   if (string_given) np->article_find_option = FIND_NEXT;\n   else switch (np->article_find_option) {\n     case FIND_NEXT:  np->article_find_option = FIND_NEXT; break;\n     case FIND_PREV:  np->article_find_option = FIND_PREV; break;\n     case FIND_FIRST: np->article_find_option = FIND_NEXT; break;\n     case FIND_LAST:  np->article_find_option = FIND_PREV; break;\n     default:         np->article_find_option = FIND_NEXT; break;\n   }\n }\n\n np->article_repeat_find = !string_given;\n\n /* do the find here */\n\n if (gp->sort_vector) {\n   save_top_sorted_article = np->top_sorted_article;\n   wpfirst = gp->sort_vector;\n   wplast  = gp->sort_vector + gp->sort_count - 1;\n   switch (np->article_find_option) {\n     case FIND_NEXT:\n                     findbump = 1;\n                     if (np->article_repeat_find) {\n                       if (np->article_text_not_found)\n                          np->top_sorted_article = wpfirst;\n                       else np->top_sorted_article++;\n                     }\n                     break;\n     case FIND_PREV:\n                     findbump = -1;\n                     if (np->article_repeat_find) {\n                       if (np->article_text_not_found)\n                          np->top_sorted_article = wplast;\n                       else np->top_sorted_article--;\n                     }\n                     break;\n     case FIND_FIRST:\n                     np->top_sorted_article = wpfirst;\n                     findbump = 1;\n                     break;\n     case FIND_LAST:\n                     np->top_sorted_article = wplast;\n                     findbump = -1;\n                     break;\n   }\n\n   found_sorted_article = NULL;\n   for (wp = np->top_sorted_article;\n        wp <= wplast && wp >= wpfirst; wp += findbump) {\n     /* ap = VARK2PARTICLE(**wp); */\n     if (NNMcar(np,gp,0,*wp,&ap,&cd,RETRIEVE)\n      && NNMstrlc(ap->subject,np->article_find_string)) {\n       found_sorted_article = wp;\n       break;\n     }\n   }\n   if (!found_sorted_article) {\n     np->top_sorted_article = save_top_sorted_article;\n     np->article_text_not_found = TRUE;\n   }\n   else {\n     np->top_sorted_article = found_sorted_article;\n     np->article_text_not_found = FALSE;\n   }\n }\n else {  /* not sorted */\n   save_top_article = np->top_article;\n   switch (np->article_find_option) {\n     case FIND_NEXT:\n                     findbump = 1;\n                     if (np->article_repeat_find) {\n                       if (np->article_text_not_found)\n                          np->top_article = gp->vector_first;\n                       else np->top_article++;\n                     }\n                     break;\n     case FIND_PREV:\n                     findbump = -1;\n                     if (np->article_repeat_find) {\n                       if (np->article_text_not_found)\n                          np->top_article = gp->vector_last;\n                       else np->top_article--;\n                     }\n                     break;\n     case FIND_FIRST:\n                     np->top_article = gp->vector_first;\n                     findbump = 1;\n                     break;\n     case FIND_LAST:\n                     np->top_article = gp->vector_last;\n                     findbump = -1;\n                     break;\n   }\n   if (!np->top_article) return FALSE;\n\n   vpfirst = &GETVARKFIRST(gp);\n   vplast  = &GETVARKLAST(gp);\n\n   CDSET;\n\n   found_article = 0;\n\n   for (anum = np->top_article;\n        anum <= gp->vector_last && anum >= gp->vector_first;\n        anum += findbump) {\n     if (NNMcar(np,gp,anum,NULL,&ap,&cd,RETRIEVE)\n      && NNMstrlc(ap->subject,np->article_find_string)) {\n       found_article = anum;\n       break;\n     }\n   }\n   if (found_article == 0) {\n     np->top_article = save_top_article;\n     np->article_text_not_found = TRUE;\n   }\n   else {\n     np->top_article = found_article;\n     np->article_text_not_found = FALSE;\n   }\n\n }\n\n if (np->article_text_not_found) {\n   ERR3(\"No %s articles with subject of: '%s'\",\n        (findbump > 0 ? \"more\" : \"previous\"),\n        np->article_find_string);\n }\n else {\n   WARN1(\"Article found;\\\nThe article whose subject contains the desired text tops the display.\");\n }\n\n return TRUE;\n\n}\n\n/****** Process article ONLY command. *******************************/\n\nstatic Bool\narticle_only_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n char                string\u00ddARGSIZE\u00a8;\n VARK               *vp;\n VARK               *vpfirst;\n VARK               *vplast;\n\n if (!getop(np,&rest,&string,GETOP_LOWERCASE)) return FALSE;\n\n if (!getop(np,&rest,NULL,GETOP_NOMORE)) {\n   ERR1(\n\"The ONLY command may have only one operand.  Try quoting the string.\"\n       );\n   return FALSE;\n }\n\n strcpy(np->article_only_string, string);\n\n if (gp->article_vector) {\n   vpfirst = &GETVARKFIRST(gp);\n   vplast  = &GETVARKLAST(gp);\n   for (vp = vpfirst; vp <= vplast; vp++) {\n     SetUnknown(*vp);\n   }\n }\n\n np->article_criterion_changed = TRUE;\n np->top_article = gp->vector_first;\n np->top_sorted_article = gp->sort_vector;\n if (*np->article_only_string) {\n   WARN1(\n\"To show articles with all subjects, use ONLY command with no operand.\"\n        );\n }\n\n return TRUE;\n}\n\n/****** Process article SORT command. *******************************/\n\nstatic Bool\narticle_sort_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n Bool                by_subject;\n char                string\u00ddARGSIZE\u00a8;\n\n /* Usage: SORT Subject\n  *        SORT Number\n  */\n\n if (!getop(np,&rest,&string,GETOP_ASIS)) return FALSE;\n\n if (!getop(np,&rest,NULL,GETOP_NOMORE)) {\n   ERR1(\"The SORT command requires one operand: Subject or Number.\");\n   return FALSE;\n }\n\n switch (string\u00dd0\u00a8) {\n   case 's':\n   case 'S': by_subject = TRUE;  break;\n   case 'n':\n   case 'N': by_subject = FALSE; break;\n   default:\n     ERR1(\"The SORT command requires one operand: Subject or Number.\");\n     return FALSE;\n }\n\n if (!gp->article_vector) {\n   ERR1(\"There are no articles in this newsgroup to sort.\");\n   return TRUE;\n }\n\n if (by_subject) {\n   if (!NNMsort(np,gp)) return FALSE;\n }\n else {\n   if (gp->sort_vector) {\n     FREEMAIN(gp->sort_vector,\"sort vector\");\n     gp->sort_vector = NULL;\n   }\n }\n\n np->article_criterion_changed = TRUE;\n np->top_article = 0;\n np->top_sorted_article = gp->sort_vector;\n\n return TRUE;\n}\n\n/****** Process article EXTRACT command. *****************************/\n\nstatic Bool\narticle_extract_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n Bool                asked_for;\n char                nnchoice\u00dd2\u00a8;\n\n if (!getop(np,&rest,NULL,GETOP_NOMORE)) {\n   ERR1(\"The EXTRACT command does not accept any operands.\");\n   return FALSE;\n }\n\n (void)NNMivput(np,\"NNLGROUP \",gp->name,-1);\n\n /* Display panel asking whether it's list of titles or log of text */\n\n asked_for = TRUE;\n\n (void)NNMispf(np,\"ADDPOP\");\n for (;;) {\n   if (NNMdispl(np,\"NNMPEXNT\") > 0) {\n     asked_for = FALSE;\n     break;\n   }\n   (void)NNMivget(np,\"NNCHOICE \",nnchoice,sizeof(nnchoice));\n   if (*nnchoice == '?') {\n     ERR1(\"Invalid choice;\\\nMove the cursor to a selection (or type S next to it) and press ENTER.\"\n         );\n   }\n   else break;\n }\n\n (void)NNMispf(np,\"REMPOP\");\n if (!asked_for) return TRUE;\n\n switch (*nnchoice) {\n   case '1':  return NNMxartt(np,gp,SEQ);\n   case '2':  return NNMxartx(np,gp,SEQ);\n   case '3':  return NNMxartx(np,gp,PDS);\n }\n\n return FALSE;\n}\n\n/****** Process article PRINT command. *******************************/\n\nstatic Bool\narticle_print_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n Bool                asked_for;\n char                nnchoice\u00dd2\u00a8;\n\n if (!getop(np,&rest,NULL,GETOP_NOMORE)) {\n   ERR1(\"The PRINT command does not accept any operands.\");\n   return FALSE;\n }\n\n (void)NNMivput(np,\"NNLGROUP \",gp->name,-1);\n\n /* Display panel asking whether it's list of titles or log of text */\n\n asked_for = TRUE;\n\n (void)NNMispf(np,\"ADDPOP\");\n for (;;) {\n   if (NNMdispl(np,\"NNMPPRNT\") > 0) {\n     asked_for = FALSE;\n     break;\n   }\n   (void)NNMivget(np,\"NNCHOICE \",nnchoice,sizeof(nnchoice));\n   if (*nnchoice == '?') {\n     ERR1(\"Invalid choice;\\\nMove the cursor to a selection (or type S next to it) and press ENTER.\"\n         );\n   }\n   else break;\n }\n\n (void)NNMispf(np,\"REMPOP\");\n if (!asked_for) return TRUE;\n\n switch (*nnchoice) {\n   case '1':  return NNMxartt(np,gp,JES);\n   case '2':  return NNMxartx(np,gp,JES);\n }\n\n return FALSE;\n}\n\n/****** Process article MARKALL command. *****************************/\n\nstatic Bool\narticle_markall_command(np,gp,rest)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\nchar                 *rest;\n{\n struct newsarticle  *ap;\n VARK                *vp;\n VARK                *vpfirst;\n VARK                *vplast;\n int                  prc;\n Bool                 allp;\n struct countdown     cd;\n char                 nnchoice\u00dd9\u00a8;\n\n if (!gp->article_vector) {\n   ERR1(\"There are no articles to mark.\");\n   return TRUE;\n }\n\n /* Display panel asking what user really wants to do. */\n\n strcpy(nnchoice,\"\");\n\n for (;;) {\n   (void)NNMivput(np,\"NNMARK \",\"Read\",-1);\n   (void)NNMispf(np,\"ADDPOP\");\n   prc = NNMdispl(np,\"NNMPMALL\");\n   (void)NNMispf(np,\"REMPOP\");\n   if (prc > 0) strcpy(nnchoice,\"3\");\n   else (void)NNMivget(np,\"NNCHOICE \",nnchoice,sizeof(nnchoice));\n   switch (nnchoice\u00dd0\u00a8) {\n     case '1': allp = TRUE;  break;\n     case '2': allp = FALSE; break;\n     case '3': ERR1(\"Operation cancelled by your request.\");\n               return TRUE;\n     default:\n                ERR1(\"Invalid choice;\\\nMove the cursor to a selection (or type S next to it) and press ENTER.\"\n         );\n                continue;\n   }\n   break;\n }\n\n /*\n  * This isn't really too good.  It means that ALL the articles\n  * will have to be retrieved in order to mark them read.\n  *\n  * A better way would be to set a flag in the VARK saying\n  * \"marked read\" rather than \"read\", so that future fetches\n  * would put the article in the table but set the action to\n  * \"read\".  We're going to need a \"cross-posted-read\" flag\n  * that's independent of fetching the article anyhow...\n  *\n  * How about this?  Add a new article status, ARTICLE_DUMMY,\n  * set when unique storage is allocated for a struct newsarticle\n  * but neither the headers nor the body have been retrieved.\n  * It would have null values in it, but:\n  *\n  * the action field could be set when article is marked (un)read\n  * the subject field could be set from an XHDR request\n  * likewise for date, etc. fields\n  *\n  * If NNMrarh is asked to retrieve such an article, it will fill\n  * it in with stuff.\n  *\n  * NNMcar could be modified to be asked to create dummy articles\n  * instead of retrieving headers for them.  This would be done if\n  * just going through and setting ap->actions or ap->subjects.\n  */\n\n vpfirst = &GETVARKFIRST(gp);\n vplast  = &GETVARKLAST(gp);\n\n CDSET;\n\n if (allp) {\n   mark_all_articles_read(np,gp,FALSE);\n   for (vp = vpfirst; vp <= vplast; vp++) {\n     if (NNMcar(np,gp,0,vp,&ap,&cd,MARK_ONLY)) { /* choose article */\n       if (ap) ap->action = READ;\n     }\n   }\n   gp->unread_count = 0;\n }\n else {\n   for (vp = vpfirst; vp <= vplast; vp++) {\n     if (NNMcar(np,gp,0,vp,&ap,&cd,MARK_ONLY)) { /* choose article */\n       NNMmarr(np,gp,vp);                /* mark article read */\n     }\n   }\n }\n\n return TRUE;\n}\n\n/****** Process article UNMARKALL command. ***************************/\n\nstatic Bool\narticle_unmarkall_command(np,gp,rest)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\nchar                 *rest;\n{\n struct newsarticle  *ap;\n VARK                *vp;\n VARK                *vpfirst;\n VARK                *vplast;\n int                  prc;\n Bool                 allp;\n char                 nnchoice\u00dd9\u00a8;\n struct countdown     cd;\n\n if (!gp->article_vector) {\n   ERR1(\"There are no articles to mark.\");\n   return TRUE;\n }\n\n /* Display panel asking what user really wants to do. */\n\n strcpy(nnchoice,\"\");\n\n for (;;) {\n   (void)NNMivput(np,\"NNMARK \",\"Unread\",-1);\n   (void)NNMispf(np,\"ADDPOP\");\n   prc = NNMdispl(np,\"NNMPMALL\");\n   (void)NNMispf(np,\"REMPOP\");\n   if (prc > 0) strcpy(nnchoice,\"3\");\n   else (void)NNMivget(np,\"NNCHOICE \",nnchoice,sizeof(nnchoice));\n   switch (nnchoice\u00dd0\u00a8) {\n     case '1': allp = TRUE;  break;\n     case '2': allp = FALSE; break;\n     case '3': ERR1(\"Operation cancelled by your request.\");\n               return TRUE;\n     default:\n                ERR1(\"Invalid choice;\\\nMove the cursor to a selection (or type S next to it) and press ENTER.\"\n         );\n                continue;\n   }\n   break;\n }\n\n /* see comments under previous function.  they apply here too */\n\n vpfirst = &GETVARKFIRST(gp);\n vplast  = &GETVARKLAST(gp);\n\n CDSET;\n\n if (allp) {\n   mark_all_articles_unread(np,gp,FALSE);\n   for (vp = vpfirst; vp <= vplast; vp++) {\n     if (NNMcar(np,gp,0,vp,&ap,&cd,MARK_ONLY)) { /* choose article */\n       if (ap) ap->action = UNREAD;\n     }\n   }\n   gp->unread_count = gp->article_count;\n }\n else {\n   for (vp = vpfirst; vp <= vplast; vp++) {\n     if (NNMcar(np,gp,0,vp,&ap,&cd,MARK_ONLY)) { /* choose article */\n       NNMmaru(np,gp,vp);                /* mark article read */\n     }\n   }\n }\n\n return TRUE;\n}\n\n/****** Process article TITLES command. ******************************/\n\nstatic Bool\narticle_titles_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n\n /* Actually, this probably ought to be a NOP, since we always ought to\n  * be retrieving article titles as we display a screenful.\n  * Since this command retrieves ALL titles, it's kind of wasteful.\n  */\n\n (void)NNMrart(np,gp,TRUE,TRUE); /* Retrieve *all* article titles */\n\n return TRUE;\n\n}\n\n/****** Process article QUERY command. *******************************/\n\nstatic Bool\narticle_query_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n\n NNMqng(np,gp);                          /* Query newsgroup */\n\n return TRUE;\n}\n\n/****** Process POST command. ****************************************/\n\nstatic Bool\ngeneral_post_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n\n NNMdpost(np,gp,NULL);      /* Do posting (no article up to follow) */\n\n return TRUE;\n}\n\n/****** Process MAIL command. ****************************************/\n\nstatic Bool\ngeneral_mail_command(np,gp,rest)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nchar                *rest;\n{\n\n NNMdmail(np,gp,NULL);      /* Do mailing (no article to to reply) */\n\n return TRUE;\n}\n\n/****** Process TEST command. ****************************************/\n\nstatic Bool\ngeneral_test_command(np,gp,rest)\nRstruc nncb         *np;\nstruct newsgroup    *gp;\nchar                *rest;\n{\n\n np->test_mode = TRUE;\n __ctest(rest);\n\n return TRUE;\n}\n\n/****** Process NNTP command. ****************************************/\n\nstatic Bool\ngeneral_nntp_command(np,gp,rest)\nRstruc nncb         *np;\nstruct newsgroup    *gp;\nchar                *rest;\n{\n\n (void)NNMdnntp(np,rest);      /* Do native NNTP */\n\n return TRUE;\n}\n\n/****** Process SAVE command. ****************************************/\n\nstatic Bool\ngeneral_save_command(np,gp,rest)\nRstruc nncb         *np;\nstruct newsgroup    *gp;\nchar                *rest;\n{\n\n return NNMsave(np,rest);  /* Save NEWSRC file */\n\n}\n\n/****** Process OPTIONS command. *************************************/\n\nstatic Bool\ngeneral_options_command(np,gp,rest)\nRstruc nncb         *np;\nstruct newsgroup    *gp;\nchar                *rest;\n{\n char                option\u00ddARGSIZE\u00a8;\n\n if (!getop(np,&rest,&option,GETOP_LOWERCASE)) return FALSE;\n\n NNMdsopt(np,option);         /* Do \"set options\" function */\n\n return TRUE;\n}\n\n/****** Process QUIT command. ****************************************/\n\nstatic Bool\ngeneral_quit_command(np,gp,rest)\nRstruc nncb         *np;\nstruct newsgroup    *gp;\nchar                *rest;\n{\n\n np->quit = TRUE;\n\n return TRUE;\n}\n\n/****** Process CRASHNNMVS command. **********************************/\n\nstatic Bool\ngeneral_crashnnmvs_command(np,gp,rest)\nRstruc nncb         *np;\nstruct newsgroup    *gp;\nchar                *rest;\n{\n\n fprintf(stderr,\"Terminating NNMVS with extreme prejudice.\\n\");\n\n exit(999);\n\n}\n\n/****** Process DEBUG command. ***************************************/\n\nstatic Bool\ngeneral_debug_command(np,gp,rest)\nRstruc nncb         *np;\nstruct newsgroup    *gp;\nchar                *rest;\n{\n\n if (!np->debug_mode) {\n\n   if (!(np->debug_file = fopen(\"dd:nndebug\",\"a\"))) {\n     perror(\"debug file (DD NNDEBUG)\");\n   }\n   else np->debug_mode = TRUE;\n }\n\n return TRUE;\n}\n\n/****** Process NODEBUG command. *************************************/\n\nstatic Bool\ngeneral_nodebug_command(np,gp,rest)\nRstruc nncb         *np;\nstruct newsgroup    *gp;\nchar                *rest;\n{\n\n if (np->debug_mode) {\n   if (np->debug_file) {\n     if (fclose(np->debug_file) < 0) {\n       fprintf(stderr,\"Error closing debug file (DD NNDEBUG)\\n\");\n     }\n     np->debug_file = NULL;\n   }\n   np->debug_mode = FALSE;\n }\n\n return TRUE;\n}\n\n/****** Process DISCONNECT command. *********************************/\n\nstatic Bool\ngeneral_disconnect_command(np,gp,rest)\nRstruc nncb         *np;\nstruct newsgroup    *gp;\nchar                *rest;\n{\n char               *dummy = \"503 Simulated disconnect.\";\n int                 index;\n\n /* fake a disconnect condition by sending an NNTP \"QUIT\".\n  * The next attempt to communicate with the socket will get\n  * the simulated response instead of what it expected.\n  */\n\n strcpy(np->nntp_command,\"QUIT\");\n if (!NNMsockt(np)) return FALSE;  /* Send socket command to server */\n\n index = strlen(dummy);\n strcpy(np->g_buf+1,dummy);\n np->g_buf\u00ddindex+1\u00a8 = CARRIAGE_RETURN;\n np->g_buf\u00ddindex+2\u00a8 = LINE_FEED;\n np->g_bytes_returned = index+3;\n np->g_buf_index = 0;\n\n return TRUE;\n}\n\n/****** Process newsgroup S selection. *******************************/\n\nstatic Bool\nnewsgroup_s_selection(np,gp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\n{\n\n np->show_all_articles       = FALSE;\n np->bypass_header_retrieval = FALSE;\n np->unread_articles_only    = FALSE;\n\n return(NNMpng(np,gp,FALSE,FALSE));                /* Pick newsgroup */\n\n}\n\n/****** Process newsgroup N selection. *******************************/\n\nstatic Bool\nnewsgroup_n_selection(np,gp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\n{\n\n np->show_all_articles       = FALSE;\n np->bypass_header_retrieval = FALSE;\n np->unread_articles_only    = TRUE;\n\n return(NNMpng(np,gp,FALSE,FALSE));                /* Pick newsgroup */\n\n}\n\n/****** Process newsgroup A selection. *******************************/\n\nstatic Bool\nnewsgroup_a_selection(np,gp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\n{\n\n np->show_all_articles       = TRUE;\n np->bypass_header_retrieval = FALSE;\n np->unread_articles_only    = FALSE;\n\n return(NNMpng(np,gp,FALSE,FALSE));                /* Pick newsgroup */\n\n}\n\n/****** Process newsgroup Z selection. *******************************/\n\nstatic Bool\nnewsgroup_z_selection(np,gp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\n{\n\n np->show_all_articles       = TRUE;\n np->bypass_header_retrieval = TRUE;\n np->unread_articles_only    = FALSE;\n\n return(NNMpng(np,gp,FALSE,FALSE));                /* Pick newsgroup */\n\n}\n\n/****** Process newsgroup $ selection. *******************************/\n\nstatic Bool\nnewsgroup_dollar_selection(np,gp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\n{\n\n np->show_all_articles       = FALSE;\n np->bypass_header_retrieval = FALSE;\n np->unread_articles_only    = FALSE;\n\n return(NNMpng(np,gp,TRUE,TRUE)); /* pick group, get titles, sort it */\n\n}\n\n/****** Process newsgroup @ selection. *******************************/\n\nstatic Bool\nnewsgroup_atsign_selection(np,gp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\n{\n\n np->show_all_articles       = TRUE;\n np->bypass_header_retrieval = FALSE;\n np->unread_articles_only    = FALSE;\n\n return(NNMpng(np,gp,TRUE,TRUE)); /* pick group, get titles, sort it */\n\n}\n\n/****** Process newsgroup Q selection. *******************************/\n\nstatic Bool\nnewsgroup_q_selection(np,gp)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\n{\n\n NNMqng(np,gp);                          /* Query newsgroup */\n\n return TRUE;\n}\n\n/****** Process newsgroup R selection. *******************************/\n\nstatic Bool\nnewsgroup_r_selection(np,gp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\n{\n\n gp->registered = 1;\n\n WARN2(\"Newsgroup %s registered (subscribed).\", gp->name);\n\n return TRUE;\n}\n\n/****** Process newsgroup D selection. *******************************/\n\nstatic Bool\nnewsgroup_d_selection(np,gp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\n{\n\n gp->registered = 0;\n\n WARN2(\"Newsgroup %s deregistered (unsubscribed).\", gp->name);\n\n return TRUE;\n}\n\n/****** Process newsgroup M selection. *******************************/\n\nstatic Bool\nnewsgroup_m_selection(np,gp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\n{\n\n return mark_all_articles_read(np,gp,TRUE);\n\n}\n\n/****** Process newsgroup U selection. *******************************/\n\nstatic Bool\nnewsgroup_u_selection(np,gp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\n{\n\n return mark_all_articles_unread(np,gp,TRUE);\n\n}\n\n/****** Process article E selection. *********************************/\n\nstatic Bool\narticle_e_selection(np,ap)\nRstruc nncb          *np;\nRstruc newsarticle   *ap;\n{\n\n np->extract_file = NULL;\n if (!NNMpick(np,ap)) return FALSE;\n NNMdoit(np,ap,'E');\n return TRUE;\n\n}\n\n/****** Process article F selection. *********************************/\n\nstatic Bool\narticle_f_selection(np,ap)\nRstruc nncb          *np;\nRstruc newsarticle   *ap;\n{\n\n if (!NNMpick(np,ap)) return FALSE;\n NNMdoit(np,ap,'F');\n return TRUE;\n\n}\n\n/****** Process article C selection. *********************************/\n\nstatic Bool\narticle_c_selection(np,ap)\nRstruc nncb          *np;\nRstruc newsarticle   *ap;\n{\n\n if (!NNMpick(np,ap)) return FALSE;\n NNMdoit(np,ap,'C');\n return TRUE;\n\n}\n\n/****** Process article M selection. *********************************/\n\nstatic Bool\narticle_m_selection(np,ap)\nRstruc nncb         *np;\nRstruc newsarticle  *ap;\n{\n Rstruc newsgroup   *gp = np->current_newsgroup;\n VARK               *vp = &GETVARK(gp,ap->number);\n\n NNMmarr(np,gp,vp);                          /* Make article read */\n\n return TRUE;\n}\n\n/****** Process article P selection. *********************************/\n\nstatic Bool\narticle_p_selection(np,ap)\nRstruc nncb          *np;\nRstruc newsarticle   *ap;\n{\n\n np->extract_file = NULL;\n if (!NNMpick(np,ap)) return FALSE;\n NNMdoit(np,ap,'P');\n return TRUE;\n\n}\n\n/****** Process article Q selection. *********************************/\n\nstatic Bool\narticle_q_selection(np,ap)\nRstruc nncb         *np;\nRstruc newsarticle  *ap;\n{\n\n return NNMqar(np,ap);\n}\n\n/****** Process article R selection. *********************************/\n\nstatic Bool\narticle_r_selection(np,ap)\nRstruc nncb          *np;\nRstruc newsarticle   *ap;\n{\n\n if (!NNMpick(np,ap)) return FALSE;\n NNMdoit(np,ap,'R');\n return TRUE;\n\n}\n\n/****** Process article S selection. *********************************/\n\nstatic Bool\narticle_s_selection(np,ap)\nRstruc nncb          *np;\nRstruc newsarticle   *ap;\n{\n Rstruc newsgroup    *gp = np->current_newsgroup;\n Rstruc newsarticle  *ap1 = ap;\n Rstruc newsarticle  *ap2 = NULL;\n VARK                *vp;\n VARK                *vpfirst;\n VARK                *vplast;\n VARK                *vp1;\n enum article_cookie  cookie;\n Bool                 save_show_all_articles;\n struct countdown     cd;\n\n np->extract_file = NULL;\n clear_subject(np);\n\n /* Continue as long as NEXT/PREV/UNREAD requests occur. */\n\n for (;;) {\n   if (!NNMpick(np,ap1)) return FALSE;  /* Pick article to process */\n   NNMdoit(np,ap1,'S');                 /* Process article */\n   cookie = np->another_article;\n   if (cookie == NULL_ARTICLE_COOKIE) break;\n   vpfirst = &GETVARKFIRST(gp);\n   vplast  = &GETVARKLAST(gp);\n   CDSET;\n   switch (cookie) {\n     case REDISPLAY_ARTICLE:\n          ap2 = NULL;\n          break;\n     case UNREAD_THIS_ARTICLE:\n          clear_subject(np);\n          vp1 = &GETVARK(gp,ap1->number);\n          NNMmaru(np,gp,vp1);            /* Make article unread */\n          return TRUE;\n     case NEXT_ARTICLE:\n          save_show_all_articles = np->show_all_articles;\n          np->show_all_articles = TRUE;\n          SEARCH_CURRENT_TO_LAST(ap2,ap1,NOSUBJECT,NO_COMPARISON,ANY);\n          np->show_all_articles = save_show_all_articles;\n          if (!ap2) ERR1(ERROR_NEXT_ARTICLE);\n          break;\n     case PREV_ARTICLE:\n          save_show_all_articles = np->show_all_articles;\n          np->show_all_articles = TRUE;\n          SEARCH_CURRENT_TO_FIRST(ap2,ap1,NOSUBJECT,NO_COMPARISON,ANY);\n          np->show_all_articles = save_show_all_articles;\n          if (!ap2) ERR1(ERROR_PREV_ARTICLE);\n          break;\n     case NEXT_TABLED_ARTICLE:\n          SEARCH_CURRENT_TO_LAST(ap2,ap1,NOSUBJECT,IsEligible(*vp),NO);\n          if (!ap2) ERR1(ERROR_NEXT_TABLED_ARTICLE);\n          break;\n     case PREV_TABLED_ARTICLE:\n          SEARCH_CURRENT_TO_FIRST(ap2,ap1,NOSUBJECT,IsEligible(*vp),NO);\n          if (!ap2) ERR1(ERROR_PREV_TABLED_ARTICLE);\n          break;\n     case NEXT_UNREAD_ARTICLE:\n          SEARCH_CURRENT_TO_LAST(ap2,ap1,NOSUBJECT,IsUnread(*vp),NO);\n          if (!ap2) ERR1(ERROR_NEXT_UNREAD_ARTICLE);\n          break;\n     case PREV_UNREAD_ARTICLE:\n          SEARCH_CURRENT_TO_FIRST(ap2,ap1,NOSUBJECT,IsUnread(*vp),NO);\n          if (!ap2) ERR1(ERROR_PREV_UNREAD_ARTICLE);\n          break;\n     case NEXT_THREAD_ARTICLE:\n          SEARCH_CURRENT_TO_LAST(ap2,ap1,SETSUBJECT,subjectmatch,NO);\n          if (!ap2) {\n            ERR1(ERROR_NEXT_THREAD_ARTICLE);\n            clear_subject(np);\n          }\n          break;\n     case PREV_THREAD_ARTICLE:\n          SEARCH_CURRENT_TO_FIRST(ap2,ap1,SETSUBJECT,subjectmatch,NO);\n          if (!ap2) {\n            ERR1(ERROR_PREV_THREAD_ARTICLE);\n            clear_subject(np);\n          }\n          break;\n     case FIRST_THREAD_ARTICLE:\n          SEARCH_FIRST_TO_LAST(ap2,ap1,SETSUBJECT,subjectmatch,NO);\n          if (!ap2) {\n            ERR1(ERROR_FIRST_THREAD_ARTICLE);\n            clear_subject(np);\n          }\n          break;\n     case LAST_THREAD_ARTICLE:\n          SEARCH_LAST_TO_FIRST(ap2,ap1,SETSUBJECT,subjectmatch,NO);\n          if (!ap2) {\n            ERR1(ERROR_LAST_THREAD_ARTICLE);\n            clear_subject(np);\n          }\n          break;\n     case NEW_THREAD_ARTICLE:\n          SEARCH_FIRST_TO_LAST(ap2,ap1,SETSUBJECT,\n                               IsUnread(*vp) && !subjectmatch,NO);\n          clear_subject(np);\n          if (!ap2) ERR1(ERROR_NEW_THREAD_ARTICLE);\n          else (void)set_subject(np,ap2->subject);\n          break;\n     default:\n          clear_subject(np);\n          ap2 = NULL;\n          break;\n   }\n\n   if (ap2) {\n     /* Bump display to article to be seen */\n     if (gp->sort_vector)\n          np->top_sorted_article = np->current_sortvark;\n     else np->top_article = ap2->number;\n     SetEligible(*vp); /* Force it eligible for display */\n     ap1 = ap2;\n   }\n }\n\n clear_subject(np);\n\n return TRUE;\n\n}\n\n/****** Process article U selection. *********************************/\n\nstatic Bool\narticle_u_selection(np,ap)\nRstruc nncb         *np;\nRstruc newsarticle  *ap;\n{\n Rstruc newsgroup   *gp = np->current_newsgroup;\n VARK               *vp = &GETVARK(gp,ap->number);\n\n NNMmaru(np,gp,vp);                         /* Make article unread */\n\n return TRUE;\n}\n\n/*********************************************************************/\n\nvoid\nNNMinit(np)\nRstruc nncb            *np;\n{\n\n static struct tabledesc newsgroup_display_table;\n static struct tabledesc article_display_table;\n static struct tabledesc text_display_table;\n static struct cmddesc   newsgroup_commands\u00dd\u00a8 = {\n                          {\"L          \",newsgroup_locate_command   },\n                          {\"LOC        \",newsgroup_locate_command   },\n                          {\"LOCATE     \",newsgroup_locate_command   },\n                          {\"F          \",newsgroup_find_command     },\n                          {\"FIND       \",newsgroup_find_command     },\n                          {\"EXT        \",newsgroup_extract_command  },\n                          {\"EXTRACT    \",newsgroup_extract_command  },\n                          {\"PRT        \",newsgroup_print_command    },\n                          {\"PRNT       \",newsgroup_print_command    },\n                          {\"REG        \",newsgroup_reg_command      },\n                          {\"REGISTER   \",newsgroup_reg_command      },\n                          {\"ALL        \",newsgroup_all_command      },\n                          {\"ONLY       \",newsgroup_only_command     },\n                          {\"ORDER      \",newsgroup_order_command    },\n                          {\"RESCAN     \",newsgroup_rescan_command   },\n                          {\"           \",NULL}\n                         };\n static struct cmddesc   article_commands\u00dd\u00a8 = {\n                          {\"L          \",article_locate_command     },\n                          {\"LOC        \",article_locate_command     },\n                          {\"LOCATE     \",article_locate_command     },\n                          {\"F          \",article_find_command       },\n                          {\"FIND       \",article_find_command       },\n                          {\"EXT        \",article_extract_command    },\n                          {\"EXTRACT    \",article_extract_command    },\n                          {\"PRT        \",article_print_command      },\n                          {\"PRNT       \",article_print_command      },\n                          {\"MARKALL    \",article_markall_command    },\n                          {\"UNMARKALL  \",article_unmarkall_command  },\n                          {\"TITLE      \",article_titles_command     },\n                          {\"TITLES     \",article_titles_command     },\n                          {\"ONLY       \",article_only_command       },\n                          {\"Q          \",article_query_command      },\n                          {\"QUERY      \",article_query_command      },\n                          {\"SORT       \",article_sort_command       },\n                          {\"RESCAN     \",article_rescan_command     },\n                          {\"           \",NULL}\n                         };\n\n static struct cmddesc   general_commands\u00dd\u00a8 = {\n                          {\"POST       \",general_post_command       },\n                          {\"MAIL       \",general_mail_command       },\n                          {\"TEST       \",general_test_command       },\n                          {\"NNTP       \",general_nntp_command       },\n                          {\"SAVE       \",general_save_command       },\n                          {\"OPTIONS    \",general_options_command    },\n                          {\"OPT        \",general_options_command    },\n                          {\"QUIT       \",general_quit_command       },\n                          {\"DEBUG      \",general_debug_command      },\n                          {\"NODEBUG    \",general_nodebug_command    },\n                          {\"DISCONNECT \",general_disconnect_command },\n                          {\"DISC       \",general_disconnect_command },\n                          {\"CRASHNNMVS \",general_crashnnmvs_command },\n                          {\"           \",NULL}\n                         };\n\n static struct seldesc   newsgroup_selections\u00dd\u00a8 = {\n                          {'S',newsgroup_s_selection },\n                          {'N',newsgroup_n_selection },\n                          {'A',newsgroup_a_selection },\n                          {'R',newsgroup_r_selection },\n                          {'D',newsgroup_d_selection },\n                          {'M',newsgroup_m_selection },\n                          {'U',newsgroup_u_selection },\n                          {'Q',newsgroup_q_selection },\n                       /* {'Z',newsgroup_z_selection }, */\n                          {'$',newsgroup_dollar_selection },\n                          {'@',newsgroup_atsign_selection },\n                          {' ',NULL}\n                         };\n static struct seldesc   article_selections\u00dd\u00a8 = {\n                          {'S',article_s_selection },\n                          {'E',article_e_selection },\n                          {'P',article_p_selection },\n                          {'M',article_m_selection },\n                          {'U',article_u_selection },\n                          {'F',article_f_selection },\n                          {'R',article_r_selection },\n                          {'Q',article_q_selection },\n                          {'C',article_c_selection },\n                          {' ',NULL}\n                         };\n\n static struct tablevector all_display_tables;\n\n newsgroup_display_table.command_variable   = \"NNGCMD \";\n newsgroup_display_table.first_cmddesc      = newsgroup_commands;\n newsgroup_display_table.next_cmddesc       = general_commands;\n newsgroup_display_table.first_seldesc      = newsgroup_selections;\n\n article_display_table.command_variable     = \"NNTCMD \";\n article_display_table.first_cmddesc        = article_commands;\n article_display_table.next_cmddesc         = general_commands;\n article_display_table.first_seldesc        = article_selections;\n\n text_display_table.command_variable        = \"ZCMD \";\n text_display_table.first_cmddesc           = NULL; /* filled later */\n text_display_table.next_cmddesc            = general_commands;\n text_display_table.first_seldesc           = NULL;\n\n all_display_tables.newsgroup_display_table = &newsgroup_display_table;\n all_display_tables.article_display_table   = &article_display_table;\n all_display_tables.text_display_table      = &text_display_table;\n\n np->display_table_vector = &all_display_tables;\n\n return;\n}\n./ ADD NAME=NNMISPF\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@ISPF \")\n#pragma  csect(static,\"NN$ISPF \")\n#include \"nn.h\"\n\n/****** Call ISPF service. *******************************************/\n\nBool\nNNMispf(np,ispfbuf)\nRstruc nncb *np;\nchar        *ispfbuf;\n{\n int         ispflen;\n\n ispflen = strlen(ispfbuf);\n\n#ifndef ISPFV2\n if (np->test_mode) {\n#endif\n   if (ispflen >= 6\n      && (memcmp(ispfbuf,\"ADDPOP\",6) == 0\n       || memcmp(ispfbuf,\"REMPOP\",6) == 0)) {\n     np->ispfrc = 0;\n     return TRUE;\n   }\n#ifndef ISPFV2\n }\n#endif\n\n np->ispfrc = ISPEXEC(&ispflen,ispfbuf);\n if (np->ispfrc > 8) {\n\n   /* Ignore ADDPOP and REMPOP errors, especially if they are due to\n      ISPF V3 not being active. */\n\n   if (np->ispfrc == 20\n    && np->debug_mode == FALSE\n    && ispflen >= 6\n    && (memcmp(ispfbuf,\"ADDPOP\",6) == 0\n     || memcmp(ispfbuf,\"REMPOP\",6) == 0)) {\n     return TRUE;\n   }\n\n   NNMierr(np);             /* handle ISPF error */\n   return FALSE;\n }\n return TRUE;\n}\n\n./ ADD NAME=NNMIVGET\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@IVGET\")\n#pragma  csect(static,\"NN$IVGET\")\n#include \"nn.h\"\n\n/****** Retrieve the value of an ISPF variable. **********************/\n\nBool\nNNMivget(np,varname,varbuf,varbuflen)\nRstruc nncb *np;\nchar        *varname;\nchar        *varbuf;\nint          varbuflen;\n{\n int         vcopy_length;\n\n if (!strchr(varname,' ')) {\n   fprintf(stderr,\"NNMivget: no blank passed in var name\\n\");\n   return FALSE;\n }\n\n /*\n  * If varbuflen is negative, that means that the value is not to be\n  * treated as a C string, and the null character is not to be\n  * appended to the resulting value.  This is used for hex values\n  * (like addresses) that are stored in ISPF table row variables.\n  */\n\n if (varbuflen < 0)  vcopy_length = -varbuflen;\n else vcopy_length = varbuflen;\n\n /* Note that on entry, vcopy_length is an integer that contains\n    the length of the buffer.  On return it is updated to the length\n    of the value returned.  Since we have to stick a null character\n    on the end of it for C, the actual buffer passed must be at least\n    one character longer than the length as defined to ISPF.\n */\n\n np->ispfrc = ISPLINK(\"VCOPY\",varname,&vcopy_length,varbuf,\"MOVE\");\n switch (np->ispfrc) {\n   case  0:\n           if (varbuflen >= 0) varbuf\u00ddvcopy_length\u00a8 = '\\0';\n           return TRUE;\n   case  8:\n           strcpy(varbuf,\"\");\n           return TRUE;\n   case 16:\n           fprintf(stderr,\n                   \"Error: ISPF variable buffer too short to get %s\\n\",\n                   varname);\n           return FALSE;\n   default:\n           NNMierr(np);   /* handle ISPF error */\n           return FALSE;\n }\n}\n\n./ ADD NAME=NNMIVPUT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@IVPUT\")\n#pragma  csect(static,\"NN$IVPUT\")\n#include \"nn.h\"\n\n/****** Set the value of an ISPF variable. ***************************/\n\nBool\nNNMivput(np,varname,varbuf,varlen)\nRstruc nncb *np;\nchar        *varname;\nchar        *varbuf;\nint         varlen;\n{\n int         vreplace_length;\n\n vreplace_length = (varlen < 0 ? strlen(varbuf) : varlen);\n\n np->ispfrc = ISPLINK(\"VREPLACE\",varname,&vreplace_length,varbuf);\n switch (np->ispfrc) {\n   case  0:\n           return TRUE;\n   case 16:\n           fprintf(stderr,\n                   \"Error: ISPF variable buffer too short to put %s\\n\",\n                   varname);\n           return FALSE;\n   default:\n           NNMierr(np);   /* handle ISPF error */\n           return FALSE;\n }\n}\n\n./ ADD NAME=NNMMAIN\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n /********************************************************************/\n /*                                                                  */\n /*                             NNMVS                                */\n /*                                                                  */\n /*                   MVS news reader dialog driver                  */\n /*                                                                  */\n /*                            Author:                               */\n /*                   Steve Bacher <seb@draper.com>                  */\n /*                                                                  */\n /*                    Enhancements contributed by:                  */\n /*                  Dale Ingold <snoddi@mvs.sas.com>                */\n /*                                                                  */\n /*                      Version: 3  Release: 1                      */\n /*                                                                  */\n /********************************************************************/\n\n#ifdef SASC\n#pragma  runopts(EXECOPS)\n#else\n#pragma  runopts(heap(8k,8k,anywhere,))\n#pragma  runopts(nospie,nostae)\n#endif\n\n#pragma  csect(code,  \"NN@MAIN \")\n#pragma  csect(static,\"NN$MAIN \")\n#include \"nn.h\"\n\n/*********************************************************************/\n\nstatic char copyright_notice\u00dd\u00a8 =\n   \"Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992   \\n\\\n                                                                    \\n\\\n    SAS enhancements copyright (c) 1992 SAS Institute, Inc.         \\n\\\n                                                                    \\n\\\n    This software is provided on an 'AS IS' basis.  All warranties, \\n\\\n    including the implied warranties of merchantability and fitness,\\n\\\n    are expressly denied.                                           \\n\\\n                                                                    \\n\\\n    Provided this copyright notice is included, this software may   \\n\\\n    be freely distributed and not offered for sale.                 \\n\\\n                                                                    \\n\\\n    Changes or modifications may be made and used only by the maker \\n\\\n    of same, and not further distributed.  Such modifications should\\n\\\n    be mailed to the author for consideration for addition to the   \\n\\\n    software and incorporation in subsequent releases.\";\n\n/*********************************************************************/\n\n#ifdef I370\nchar * _style = \"tso:\";\n#endif\n\n/*********************************************************************/\n\nstatic void\ntrap_ispf_command(np,verb,action)\nRstruc nncb      *np;\nchar             *verb;\nchar             *action;\n{\n char             zcttrunc \u00dd16\u00a8;\n char             zctact   \u00dd64\u00a8;\n char             zctdesc \u00dd128\u00a8;\n\n if (!NNMivput(np,\"ZCTVERB \",verb,-1)) return;\n\n if (!NNMispf(np,\"TBTOP ISPCMDS\")) return;\n if (!NNMispf(np,\"TBSCAN ISPCMDS ARGLIST(ZCTVERB)\")) return;\n if (!NNMivget(np,\"ZCTACT \",zctact,sizeof(zctact)))  return;\n if (UNEQUAL(zctact,action)) {\n   NNMivget(np,\"ZCTTRUNC \",zcttrunc, sizeof(zcttrunc));\n   NNMivget(np,\"ZCTDESC  \",zctdesc,sizeof(zctdesc));\n   if (!NNMispf(np,\"TBTOP ISPCMDS \")) return;\n   NNMivput(np,\"ZCTACT   \",action   ,-1);\n   NNMivput(np,\"ZCTTRUNC \",zcttrunc ,-1);\n   NNMivput(np,\"ZCTDESC  \",zctdesc  ,-1);\n   if (!NNMispf(np,\"TBADD ISPCMDS \")) return;\n }\n\n return;\n}\n\n/*********************************************************************/\n\nstatic Bool\nalloc_newsrc(newsrc_dsname,newsrc_ddname)\nchar           *newsrc_dsname;\nchar           *newsrc_ddname;\n{\n int            space;\n char          *lparp;\n char          *rparp;\n FILE          *mfile;\n char           dsnseq \u00dd81\u00a8;\n char           member \u00dd81\u00a8;\n char           what_to_open \u00dd81\u00a8;\n\n space = 2;\n strcpy(member,\"\");\n strcpy(dsnseq,newsrc_dsname);\n lparp = strchr(dsnseq,'(');\n rparp = strchr(dsnseq,')');\n if (lparp && rparp && (lparp < rparp) && (*(rparp+1) == '\\0')) {\n   *lparp = '\\0';            /* makes dsnseq the seq part only */\n   *rparp = '\\0';            /* turns member into a string     */\n   strcpy(member, lparp+1);\n   space = 10;\n }\n\n if (!NNMalloc(newsrc_dsname,newsrc_ddname,SEQ,space)) return FALSE;\n\n /* If the data set had a member specified, it may have been\n  * allocated as NEW, or the member may not exist.  Therefore,\n  * force the member to exist by opening it for output and closing\n  * it if it doesn't exist.  Then reallocate it as an existing\n  * data set to prevent a B14 abend when we try to write a new\n  * PDS + member for output and close it.\n  *\n  * Otherwise, make sure the data set is not empty by opening it\n  * in append mode - this also insures that it is writable.\n  */\n\n#ifdef SASC\n\n if (*member) {\n   sprintf(what_to_open, \"'%s(%s)'\", dsnseq, member);\n\n   /* SAS/C doesn't distinguish \"member not found\" from \"file not\n    * found\".  He also likes to complain a lot.\n    * -DDI\n    */\n\n   quiet(1);                         /* turn off stupid messages */\n   mfile = fopen(what_to_open,\"r\");\n   quiet(0);                         /* turn stupid messages back on */\n   if (!mfile && errno == ENFOUND) {        /* Member not found */\n     mfile = fopen(what_to_open,\"w\");   /* create new member */\n   }\n   if (!mfile) {\n     perror(what_to_open);\n     return FALSE;\n   }\n   else if (fclose(mfile) < 0) {\n     fprintf(stderr, \"Error closing %s\\n\", what_to_open);\n     return FALSE;\n   }\n   (void)NNMunalc(newsrc_ddname);\n   if (!NNMalloc(newsrc_dsname,newsrc_ddname,SEQ,0)) return FALSE;\n }\n else {\n   sprintf(what_to_open, \"dd:%s\", newsrc_ddname);\n\n   /* SAS/C treats an empty file as \"non-existent\", so we have to\n    * write out a blank so that NNMonrf can later open it for input\n    * successfully (even though nothing is there).  Bizarre, huh?\n    * -DDI\n    */\n\n   quiet(1);                         /* turn off stupid messages */\n   mfile = fopen(what_to_open,\"r\");  /* attempt to open for input */\n   quiet(0);                         /* turn stupid messages back on */\n   if (!mfile) {                     /* if open failed, must be empty */\n     mfile = fopen(what_to_open,\"w\");/* so open for output */\n     if (!mfile) {                   /* if that fails, give up */\n       perror(what_to_open);\n       return FALSE;\n     }\n     fputc(' ',mfile);               /* make it non-empty */\n   }\n   if (fclose(mfile) < 0) {          /* and close it either way */\n     fprintf(stderr, \"Error closing %s\\n\", what_to_open);\n     return FALSE;\n   }\n\n }\n\n#else\n\n if (*member) {\n   sprintf(what_to_open, \"'%s(%s)'\", dsnseq, member);\n   mfile = fopen(what_to_open,\"r\");\n   if (!mfile && errno == 104) {        /* Member not found */\n     mfile = fopen(what_to_open,\"w\");   /* create new member */\n   }\n   if (!mfile) {\n     perror(what_to_open);\n     return FALSE;\n   }\n   else if (fclose(mfile) < 0) {\n     fprintf(stderr, \"Error closing %s\\n\", what_to_open);\n     return FALSE;\n   }\n   (void)NNMunalc(newsrc_ddname);\n   if (!NNMalloc(newsrc_dsname,newsrc_ddname,SEQ,0)) return FALSE;\n }\n else {\n   sprintf(what_to_open, \"dd:%s\", newsrc_ddname);\n   mfile = fopen(what_to_open,\"a\");\n   if (!mfile) {\n     perror(what_to_open);\n     return FALSE;\n   }\n   else if (fclose(mfile) < 0) {\n     fprintf(stderr, \"Error closing %s\\n\", what_to_open);\n     return FALSE;\n   }\n }\n\n#endif\n\n return TRUE;\n}\n\n/*********************************************************************/\n\nint\nmain(argc,argv)\nint      argc;\nchar   **argv;\n\n{\n struct nncb            *np;\n char                   *p;\n Bool                  (*selection_processor)();\n struct hostent         *client_hp;\n int                     gethostnamerc;\n int                     exit_return_code;\n Bool                    display_continue;\n Bool                    ok_to_update_newsrc;\n struct nncb             nn;\n char                    newsrc_dsname  \u00dd65\u00a8;\n\n exit_return_code = 0;\n\n memset(&nn,0,sizeof(struct nncb));\n\n np = &nn;\n\n np->test_mode  = FALSE;\n np->debug_mode = FALSE;\n np->batch_mode = FALSE;\n np->preselection = '\\0';\n if (argc > 1) {\n   p = argv\u00dd1\u00a8;\n   if (*p == '-') {\n     while (*++p) {\n       switch (toupper(*p)) {\n         case 'T':  np->test_mode  = TRUE;    break;\n         case 'D':  np->debug_mode = TRUE;    break;\n         case 'B':  np->batch_mode = TRUE;    break;\n         case SELECTION_ALL:\n         case SELECTION_REG:\n         case SELECTION_NNTP:\n         case SELECTION_GROUP:\n         case SELECTION_LIST:\n         case SELECTION_NEWG:\n         case SELECTION_OPTS:\n         case SELECTION_EXIT:\n                    np->preselection = *p;    break;\n         default: fprintf(stderr,\"NNMVS: Bad parameter flag %c\\n\", *p);\n                  exit_return_code = 8;\n       }\n     }\n   }\n   else {\n     fprintf(stderr,\"NNMVS: Bad parameter string %s\\n\",p);\n     exit_return_code = 8;\n   }\n }\n\n if (np->test_mode) __ctest(NULL);\n\n if (np->debug_mode) {\n   if (!(np->debug_file = fopen(\"dd:nndebug\",\"w\"))) {\n     perror(\"debug file (DD NNDEBUG)\");\n     exit_return_code = 4;\n   }\n }\n else np->debug_file = NULL;\n\n if (np->batch_mode) {\n   if (!(np->batch_infile = fopen(\"dd:NNBATIN\",\"r\"))) {\n     perror(\"batch input file (dd:NNBATIN)\");\n   }\n   if (!(np->batch_outfile = fopen(\"dd:NNBATOUT\",\"w\"))) {\n     perror(\"batch output file (dd:NNBATOUT)\");\n   }\n }\n else {\n   np->batch_infile  = NULL;\n   np->batch_outfile = NULL;\n }\n\n /* This doesn't work, and may even make things worse.\n  * if (signal(SIGINT,attention_handler) == SIG_ERR) {\n  *   fprintf(stderr,\"Error: unable to establish attention handler.\\n\");\n  *   exit(27);\n  * }\n  */\n\n np->g_bytes_returned = 0;\n np->g_buf_index      = -1;\n\n /* Determine the local path name. */\n\n gethostnamerc = gethostname(np->client_hostname,MAXHOSTNAMELEN);\n if (gethostnamerc < 0) {\n   fprintf(stderr,\"NNMVS: gethostname() failed, don't know my name\\n\");\n   exit_return_code = 8;\n }\n else {\n   client_hp = gethostbyname(np->client_hostname);\n   if (!client_hp) {\n     fprintf(stderr,\n             \"NNMVS: gethostbyname() failed, can't get my name\\n\");\n     exit_return_code = 8;\n   }\n   else {\n     strcpy(np->nnclient,np->client_hostname);\n     strcpy(np->client_hostname, client_hp->h_name);\n     np->client_ip_address = *(IPADDRESS *)client_hp->h_addr;\n   }\n }\n\n strcpy(np->nnserver,\"\");\n np->connected_to_server   = FALSE;\n np->closing_connection    = FALSE;\n np->reconnect_in_progress = FALSE;\n np->receiving_text        = FALSE;\n np->newsgroup_selected    = FALSE;\n\n GETMAIN(np->server_buf,   char, SERVER_BUF_MSGSIZE+4,\"server buffer\");\n GETMAIN(np->client_buf,   char, CLIENT_BUF_MSGSIZE+4,\"client buffer\");\n GETMAIN(np->nntp_command, char, CLIENT_BUF_MSGSIZE+4,\"NNTP command\");\n\n if (exit_return_code > 4) /* nothing */;\n else if (np->batch_mode) {\n   exit_return_code = NNMbatch(np);\n }\n else {\n\n#ifdef FETCH\n\n   np->isplink_pointer = (int (*) ())fetch(\"ISPLINK\");\n   np->ispexec_pointer = (int (*) ())fetch(\"ISPEXEC\");\n\n#endif\n\n   if (!NNMispf(np,\"CONTROL ERRORS RETURN\")) exit_return_code = 20;\n\n   else {\n\n     NNMinit(np);  /* Set up command and selection code tables */\n\n     (void)NNMivput(np,\"ZCMD \"    ,\"\",-1);\n     (void)NNMivput(np,\"NNCURSOR \",\"\",-1);\n\n     trap_ispf_command(np,\"RFIND\",\"&YRFIND\");  /* enable RFIND */\n\n     NNMsopt(np,OPTION_ALL); /* Set options */\n\n     strcpy(np->newsrc_to_open,\"dd:\");\n\n     do {\n       NNMunalc(np->newsrc_to_open+3);\n       switch (NNMdmenu(np,&selection_processor)) {  /* Display menu */\n         case DISPLAY_REPEAT:\n         case DISPLAY_ERROR:   display_continue = TRUE;  break;\n         case DISPLAY_EXIT:\n         case DISPLAY_FAILURE: display_continue = FALSE; break;\n       }\n       if (display_continue\n        && selection_processor\n        && NNMivget(np,\"NNNEWSRC \",newsrc_dsname,sizeof(newsrc_dsname))\n        && alloc_newsrc(newsrc_dsname,np->newsrc_to_open+3)) {\n         NNMclrng(np);                          /* Clear newsgroups */\n         NNMclrtx(np,NULL);                     /* Clear text       */\n         NNMonrf(np,NULL);                      /* Open NEWSRC file */\n         (void)NNMivput(np,\"ZCMD \",\"\",-1);      /* Clear ZCMD field */\n\n         /* Call selected function. If returns TRUE, rewrite NEWSRC */\n\n         ok_to_update_newsrc = (*selection_processor)(np);\n         NNMcnrf(np,NULL,\n                 ok_to_update_newsrc); /* Close/rewrite NEWSRC file */\n       }\n     } while (display_continue && !np->quit);\n\n     exit_return_code = 0;\n\n   }\n\n }\n\n if (*np->maildsn) {\n   if (remove(np->maildsn) < 0) {\n     fprintf(stderr,\"NNMVS: Error removing mail dataset %s\\n\");\n   }\n }\n\n if (np->connected_to_server) {\n   NNMdisc(np);                 /* disconnect from news server */\n }\n\n NNMclrng(np);                  /* Clear newsgroups */\n\n FREEMAIN(np->nntp_command,\"nntp command\");\n FREEMAIN(np->server_buf,  \"server buffer\");\n FREEMAIN(np->client_buf,  \"client buffer\");\n\n #define FINAL_CLOSE(A,B) \\\n   if (A) { \\\n            if (fclose(A) < 0) fprintf(stderr,B); \\\n          }\n\n FINAL_CLOSE(np->newsrc_file   , \"Error closing newsrc file\\n\");\n FINAL_CLOSE(np->debug_file    , \"Error closing debug file\\n\");\n FINAL_CLOSE(np->batch_infile  , \"Error closing batch input file\\n\");\n FINAL_CLOSE(np->batch_outfile , \"Error closing batch output file\\n\");\n\n exit(exit_return_code);\n}\n\n./ ADD NAME=NNMMARR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@MARR \")\n#pragma  csect(static,\"NN$MARR \")\n#include \"nn.h\"\n\n/****** Make article read. *******************************************/\n\nvoid\nNNMmarr(np,gp,vp)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nregister VARK       *vp;\n{\n struct newsarticle *ap;\n\n if (IsUnread(*vp)) {\n   SetRead(*vp);\n   gp->unread_count--;\n }\n\n if (!IsNull(*vp) && !IsMissing(*vp)) {\n   ap = VARK2PARTICLE(*vp);\n   ap->action = READ;\n }\n\n return;\n}\n\n./ ADD NAME=NNMMARU\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@MARU \")\n#pragma  csect(static,\"NN$MARU \")\n#include \"nn.h\"\n\n/****** Make article unread. *****************************************/\n\nvoid\nNNMmaru(np,gp,vp)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nregister VARK       *vp;\n{\n struct newsarticle *ap;\n\n if (IsRead(*vp)) {\n   SetUnread(*vp);\n   gp->unread_count++;\n }\n\n if (!IsNull(*vp) && !IsMissing(*vp)) {\n   ap = VARK2PARTICLE(*vp);\n   ap->action = UNREAD;\n }\n\n return;\n}\n\n./ ADD NAME=NNMNNTP\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@NNTP \")\n#pragma  csect(static,\"NN$NNTP \")\n#include \"nn.h\"\n\n/****** Read server data. ********************************************/\n\nstatic Bool\nread_server_data(np)\nRstruc nncb         *np;\n{\n char               *lp;\n\n NNMclrtx(np,NULL);                   /* Clear text */\n\n do {\n\n   if (NNMgsrvl(np,&lp))              /* Get server line */\n     if (lp) {\n       (void)NNMouttx(np,lp,NULL);   /* Output text line */\n     }\n\n } while (lp);\n\n if (np->time_to_go_home) return FALSE;\n else return TRUE;\n}\n\n/************ Execute native NNTP protocol commands. *****************/\n\nvoid\nNNMnntp(np)\nRstruc nncb *np;\n{\n struct texthdr   saveth;\n\n /* np->nntp_command must contain NNTP command */\n\n if (!np->receiving_text && !*np->nntp_command) return;\n\n np->newsgroup_selected = FALSE;  /* in case we change server's state\n                                     with a command like \"GROUP xxx\" */\n\n memcpy(&saveth,&np->thdr,sizeof(struct texthdr));\n memset(&np->thdr,0,sizeof(struct texthdr));\n\n if (NNMsockt(np)) {              /* Send socket command to server */\n   if (read_server_data(np,NULL)) {           /* Read server data */\n     NNMvtx(np,NULL,NULL);                    /* View text        */\n   }\n   NNMclrtx(np,NULL);\n }\n memcpy(&np->thdr,&saveth,sizeof(struct texthdr));\n return;\n}\n\n./ ADD NAME=NNMONRF\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@ONRF \")\n#pragma  csect(static,\"NN$ONRF \")\n#include \"nn.h\"\n\n/****** Open NEWSRC file. ********************************************/\n\nvoid\nNNMonrf(np,what_to_open)\nRstruc nncb         *np;\nchar                *what_to_open;\n{\n char                newsrc_line\u00dd256\u00a8;\n char                newsrc_name\u00ddGROUP_NAME_SIZE\u00a8;\n Rstruc newsgroup   *gp;\n register char      *nlp;\n char               *temp;\n int                 sscanf_rc;\n int                 newsrc_registered;\n int                 newsrc_unread;\n int                 newsrc_topnum;\n int                 newsrc_scan_count;\n int                 newsrc_save_length;\n\n if (!what_to_open) what_to_open = np->newsrc_to_open;\n\n /* If the file does not exist, then create it. */\n\n newsrc_scan_count = 0;\n np->brand_new_newsrc = TRUE;\n\n errno = 0;\n\n if (!(np->newsrc_file = fopen(what_to_open,\"r\"))) {\n   if (errno == 104) {  /* Member not found */\n     if (!(np->newsrc_file = fopen(what_to_open,\"w\"))) {\n       perror(\"Cannot create NEWSRC PDS member\");\n     }\n     else if (fclose(np->newsrc_file) < 0) {\n       fprintf(stderr, \"Error closing %s\\n\", what_to_open);\n       np->newsrc_file = NULL;\n     }\n     else np->newsrc_file = fopen(what_to_open,\"r\");\n   }\n   else perror(\"Cannot open NEWSRC file\");\n }\n if (!np->newsrc_file) {\n   fprintf(stderr,\"Severe error, NEWSRC file cannot be opened.\\n\");\n   if (!np->batch_mode) {\n     (void)NNMdispl(np,\"NNMRCERR\");\n   }\n   exit(12);\n }\n\n np->new_newsgroup_count = 0;\n\n /* Read from the file, saving the state information. */\n\n /********************************************************************/\n /*                                                                  */\n /* Note:  The format used here is designed to be compatible with    */\n /*        the format used by ANU-NEWS.  This is not an attempt to   */\n /*        duplicate the \"look and feel\" of ANU-NEWS - it is just    */\n /*        to be compatible with the saved state of VAX NEWS users.  */\n /*                                                                  */\n /********************************************************************/\n\n if (feof(np->newsrc_file)) return;\n\n /* First line: time in hex digits of last \"registration\", and some\n  * other junk.  We now interpret this as the last time the status\n  * of the server's newsgroups was interrogated (LIST or NEWGROUPS)\n  * and save it.\n  */\n\n fgets(newsrc_line,sizeof(newsrc_line),np->newsrc_file);\n if (strlen(newsrc_line) >= 13)      /* if new format .newsrc file  */\n    sscanf(newsrc_line, \"%6c %6c\", &np->lastNGdate, &np->lastNGtime);\n\n if (feof(np->newsrc_file)) return;\n\n /* The rest of the file consists of information about newsgroups.\n    Read until end of file or one of the special markers is found. */\n\n fgets(newsrc_line,sizeof(newsrc_line),np->newsrc_file);\n\n while (!feof(np->newsrc_file)) {\n\n   if (EQUAL(newsrc_line,\"MARKLIST\\n\"))  break;\n   if (EQUAL(newsrc_line,\"KILLLIST\\n\"))  break;\n   if (EQUAL(newsrc_line,\"PROFILE\\n\"))   break;\n\n /* For each line, build a newsgroup entry and fill it in with\n    the values taken from the input line. */\n\n /* Right now we are not checking for {classname,classname} as we\n    don't know how, and it would complicate things. */\n\n   nlp = strchr(newsrc_line,':');\n   if (!nlp) nlp = strchr(newsrc_line,'\\n');\n   if (!nlp) {\n     fprintf(stderr,\"Bad name in newsrc file, ignored:\\n%s\\n\\n\",\n                    newsrc_line);\n     fgets(newsrc_line,sizeof(newsrc_line),np->newsrc_file);\n     continue;\n   }\n   memcpy(newsrc_name,newsrc_line,nlp-newsrc_line);\n   newsrc_name\u00ddnlp-newsrc_line\u00a8 = '\\0';\n   if (*nlp == '\\n' || *(nlp+1) == '\\n') sscanf_rc = 0;\n   else\n    sscanf_rc = sscanf(nlp,\": (%d) \u00dd%d,%d\u00a8 %n\",\n                             &newsrc_registered,\n                             &newsrc_unread,\n                             &newsrc_topnum,\n                             &newsrc_scan_count);\n\n   switch (sscanf_rc) {    /* Note use of switch WITHOUT break here. */\n      case EOF: newsrc_registered = 1;\n      case 0:   newsrc_registered = 1;\n      case 1:   newsrc_unread     = 0;\n      case 2:   newsrc_topnum     = 0;\n                nlp = NULL;\n      case 3:   break;\n      default:  break;\n   }\n\n   np->brand_new_newsrc = FALSE;\n\n   /* Allocate a newsgroup for this record. */\n\n   gp = NNMaddng(np,newsrc_name);     /* Add newsgroup */\n   if (!gp) {\n      fprintf(stderr,\"Cannot initialize newsgroup: %s\\n\",newsrc_name);\n      fgets(newsrc_line,sizeof(newsrc_line),np->newsrc_file);\n      continue;\n   }\n\n   /* Now, collect the information on what articles were read. */\n\n   SetGroupFromNewsrc(gp);\n   gp->low_number    = 1;             /* or new field from newsrc? */\n   gp->high_number   = newsrc_topnum;\n   gp->vector_first  = 0;\n   gp->vector_last   = 0;\n   gp->article_count = gp->high_number - gp->low_number + 1;\n   gp->unread_count  = newsrc_unread;\n   gp->registered    = newsrc_registered;\n\n   if (gp->registered == -1) {\n     SetNewGroup(gp);\n     gp->registered = 0;\n     np->new_newsgroup_count++;\n   }\n\n   /* At this early point, we just save the NEWSRC line and\n    * create the article vector later, when we really need it.\n    */\n\n   if (!nlp) {\n     fgets(newsrc_line,sizeof(newsrc_line),np->newsrc_file);\n     continue;\n   }\n\n   nlp += newsrc_scan_count;\n\n   /* Save the newsrc data (following the \u00ddunread,topnum\u00a8 spec) */\n\n   if (gp->saved_newsrc_line != gp->saved_newsrc_data) {\n     FREEMAIN(gp->saved_newsrc_line,\"stale saved newsrc line\");\n   }\n   if (*nlp == '\\0') nlp = \"\\n\";\n   newsrc_save_length = strlen(nlp) + 1;\n   if (newsrc_save_length <= sizeof(gp->saved_newsrc_data)) {\n     gp->saved_newsrc_line = gp->saved_newsrc_data;\n   }\n   else {\n     GETMAIN(gp->saved_newsrc_line,char,newsrc_save_length,\n             \"saved newsrc line\");\n     if (!gp->saved_newsrc_line) {\n       fprintf(stderr,\"Cannot save newsrc line for %s, terminating.\\n\",\n                      newsrc_name);\n       return;\n     }\n   }\n   strcpy(gp->saved_newsrc_line,nlp);\n\n   for (;;) {\n\n     fgets(newsrc_line,sizeof(newsrc_line),np->newsrc_file);\n     if (feof(np->newsrc_file)) break;\n     if (newsrc_line\u00dd0\u00a8 != ' ') break;\n     nlp = newsrc_line;\n     GETMAIN(temp,char,strlen(gp->saved_newsrc_line)+strlen(nlp)+1,\n                       \"saved newsrc line continuation\");\n     if (!temp) {\n       fprintf(stderr,\"Cannot save newsrc line for %s, terminating.\\n\",\n                      newsrc_name);\n       return;\n     }\n     strcpy(temp,gp->saved_newsrc_line);  /* should include newline */\n     strcat(temp,nlp);\n     if (gp->saved_newsrc_line != gp->saved_newsrc_data) {\n       FREEMAIN(gp->saved_newsrc_line,\"old saved newsrc line\");\n     }\n     gp->saved_newsrc_line = temp;\n\n   } /* end for - at this point we have no more newsrc continuations */\n\n } /* end while */\n\n /* At this point we have finished reading newsrc.\n    Ignore everything once MARKLIST, KILLLIST, or PROFILE is seen.\n    We don't handle any of that stuff. */\n\n return;\n}\n\n./ ADD NAME=NNMOUTTX\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@OUTTX\")\n#pragma  csect(static,\"NN$OUTTX\")\n#include \"nn.h\"\n\n/****** Output a line of text retrieved from the server. *************/\n\nstruct textline *\nNNMouttx(np,line,ap)\nRstruc nncb         *np;\nchar                *line;\nRstruc newsarticle  *ap;\n\n{\n struct texthdr     *thp;\n struct textline    *tp;\n short              line_length;\n short              total_text_length;\n short              tab_expansion_length;\n Bool               tabs_present;\n char              *p;\n char              *q;\n char              *t;\n int                e;\n int                u;\n\n static char        tab_expansion_buffer\u00dd8*TEXT_BYTES\u00a8;\n\n /* If article is not specified, use main nncb, else article's text */\n\n thp = (ap ? &ap->thdr : &np->thdr);\n\n /* If line starts with double period, make it a single period. */\n\n if (ap && memcmp(line,\"..\",2) == 0) line++;\n\n /* Add this line to the current queue of server text lines. */\n\n /* First, expand tabs in the line. */\n\n line_length = strlen(line);\n t = strchr(line,'\\t');\n if (!t) {\n   tabs_present = FALSE;\n   total_text_length = line_length + 1;\n }\n else {                                   /* expand tabs */\n   tabs_present = TRUE;\n   p = line;\n   q = line + line_length;\n   e = 0;\n   memset(tab_expansion_buffer,' ',sizeof(tab_expansion_buffer));\n   for (;;) {\n     u = t - p;\n     if (u > 0) {\n       memcpy(tab_expansion_buffer+e,p,u);\n       e += u;\n     }\n     if (t == q) break;\n     e = e / 8 * 8 + 8;\n     p = t+1;\n     t = strchr(p,'\\t');\n     if (!t) t = q;\n   }\n   tab_expansion_length = e;\n   tab_expansion_buffer\u00ddtab_expansion_length\u00a8 = '\\0';\n   total_text_length = line_length + tab_expansion_length + 1;\n }\n\n GETMAIN(tp, char, offsetof(struct textline, text) + total_text_length,\n                   \"text line\");\n\n if (!tp) {\n   ERR1(\"There is not enough virtual storage to process server text.\");\n   return NULL;\n }\n\n tp->next = NULL;\n tp->text_length = line_length;\n strcpy(tp->text,line);\n if (tabs_present) {\n   tp->tab_expanded_text_length = tab_expansion_length;\n   tp->tab_expanded_text = tp->text + line_length;\n   strcpy(tp->tab_expanded_text,tab_expansion_buffer);\n }\n else {\n   tp->tab_expanded_text_length = line_length;\n   tp->tab_expanded_text = tp->text;\n }\n\n if (!thp->last_text_line) {\n   thp->first_text_line   = tp;\n   thp->text_body_line    = tp;\n   thp->current_text_line = tp;\n }\n else thp->last_text_line->next = tp;\n\n thp->last_text_line = tp;\n thp->text_line_count++;\n\n if (thp->text_max_length < tp->text_length)\n     thp->text_max_length = tp->text_length;\n if (thp->text_max_tab_expanded_length < tp->tab_expanded_text_length)\n     thp->text_max_tab_expanded_length = tp->tab_expanded_text_length;\n\n return tp;\n\n}\n\n./ ADD NAME=NNMPICK\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@PICK \")\n#pragma  csect(static,\"NN$PICK \")\n#include \"nn.h\"\n\n/****** Collect text. ************************************************/\n\nstatic void\ncollect_text(np,ap)\nRstruc nncb         *np;\nRstruc newsarticle  *ap;\n{\n char               *lp;\n\n np->sending_text = TRUE;\n\n for (;;) {\n\n   if (!NNMgsrvl(np,&lp))         break; /* Get server line */\n   if (lp == NULL)                break;\n   if (strcmp(lp,\".\") == 0)       break;\n   if (!NNMouttx(np,lp,ap))       break; /* Output text line */\n\n }\n\n return;\n\n}\n\n/****** Maybe suppress header line. **********************************/\n\nstatic void\nmaybe_suppress_header_line(np,ap,tp,header_name)\nRstruc nncb         *np;\nRstruc newsarticle  *ap;\nRstruc textline     *tp;\nchar                *header_name;\n{\n char                temphdr\u00ddINTERNET_SIZE+2\u00a8;\n Bool                suppress;\n\n switch (np->nnrfcopt\u00dd0\u00a8) {\n   case '\\0':\n   case 'A':                /* show all RFC822 headers */\n              suppress = FALSE;\n              break;\n   case 'B':                /* show all except those in exclude list */\n              sprintf(temphdr,\" %s \",header_name);\n              if (strstr(np->nnrfcexc,temphdr)) suppress = TRUE;\n              else                              suppress = FALSE;\n              break;\n   case 'C':                /* show only those in include list */\n              sprintf(temphdr,\" %s \",header_name);\n              if (strstr(np->nnrfcinc,temphdr)) suppress = FALSE;\n              else                              suppress = TRUE;\n              break;\n   case 'D':                /* show none */\n              suppress = TRUE;\n              break;\n }\n\n if (suppress) {\n   if (tp->text_length >= 0) {\n     tp->text_length |= 0x8000;    /* force sign bit negative */\n     ap->thdr.text_line_count--;\n   }\n }\n else {\n   if (tp->text_length < 0) {\n     tp->text_length &= 0x7fff;    /* force sign bit positive */\n     ap->thdr.text_line_count++;\n   }\n }\n\n return;\n}\n\n/****** Apply header suppression.  ***********************************/\n\nstatic void\napply_header_suppression(np,ap)\nRstruc nncb         *np;\nRstruc newsarticle  *ap;\n{\n struct textline     *tp;\n struct texthdr      *thp;\n char                *cp;\n char                *colonp;\n int                  header_index;\n char                 header_name\u00ddINTERNET_SIZE\u00a8;\n\n thp = &ap->thdr;\n strcpy(header_name,\"\");\n for (tp=thp->first_text_line; tp; tp=tp->next) {\n   if (tp->text\u00dd0\u00a8 == '\\0') break;\n   if (tp->text\u00dd0\u00a8 == ' ' ||\n       tp->text\u00dd0\u00a8 == '\\t') {\n     cp = tp->text + strspn(tp->text,\" \\t\");\n     if (*cp == '\\0') break;\n   }\n   else {\n     header_index = 0;\n     colonp = strchr(tp->text,':');\n     if (!colonp) break;\n     strcpy(header_name,\"\");\n     for (cp = tp->text;cp<colonp;cp++) {\n       header_name\u00ddheader_index++\u00a8 = toupper(*cp);\n     }\n     header_name\u00ddheader_index\u00a8 = '\\0';\n   }\n   if (*header_name) {\n      maybe_suppress_header_line(np,ap,tp,header_name);\n   }\n }\n\n thp->text_body_line = tp;\n\n return;\n}\n\n/****** Pick article before processing. ******************************/\n\nBool\nNNMpick(np,ap)\nRstruc nncb          *np;\nRstruc newsarticle   *ap;\n{\n Rstruc newsgroup    *gp;\n char                *lp;\n char                 bad_status        = ERROR;\n Bool                 retval            = TRUE;\n Bool                 retrieve_header   = FALSE;\n Bool                 retrieve_body     = FALSE;\n\n np->another_article = NULL_ARTICLE_COOKIE;\n\n gp = np->current_newsgroup;\n\n if (!gp) {\n   CRIT1(\"No current newsgroup.  This should never happen.\");\n   return FALSE;\n }\n\n if (ap == V_NULL_ARTICLE) {\n   ERR1(\"This article does not exist - how could it be chosen?\");\n   return FALSE;\n }\n\n if (ap == V_MISSING_ARTICLE) {\n   ERR1(\"This article is missing - how could it be chosen?\");\n   return FALSE;\n }\n\n if (NoSuchArticle(ap)) {\n   ERR4(\"Article %d of %s does not exist in server %s.\",\n        ap->number, gp->name, np->nnserver);\n   retval = FALSE;\n }\n else if (ArticleAbsent(ap)) {\n   ERR4(\"Article %d of %s was not retrieved by server %s.\",\n        ap->number, gp->name, np->nnserver);\n   retval = FALSE;\n }\n else if (ArticleError(ap)) {\n   ERR4(\"Error getting article %d of %s from server %s.\",\n        ap->number, gp->name, np->nnserver);\n   retval = FALSE;\n }\n else {\n   retrieve_header = !ArticleHeadRetrieved(ap);\n   retrieve_body   = !ArticleBodyRetrieved(ap);\n }\n\n if (retrieve_header || retrieve_body) {\n\n   if (!NNMestng(np,NULL)) {           /* Establish newsgroup */\n     SetGroupError(gp);\n     OffGroupSelected(gp);\n     return FALSE;\n   }\n\n   if (retrieve_header) {\n     if (!NNMrarh(np,gp,NULL,ap->number,NULL)) {\n       ERR4(\"Article %d of %s could not be retrieved from server %s.\",\n            ap->number, gp->name, np->nnserver);\n       ap->action = MISSING;\n       return FALSE;\n     }\n   }\n\n   sprintf(np->nntp_command,\"BODY %d\",ap->number);\n   if (!NNMsockt(np))      return FALSE; /* Send socket cmd to server*/\n   if (!NNMgsrvl(np,&lp))  return FALSE; /* Get server line */\n   switch(np->nntp_message_num) {\n     case 220:       /* article retrieved - head and body follow    */\n               break;\n     case 221:       /* article retrieved - head follows            */\n               break;\n     case 222:       /* article retrieved - body follows            */\n               break;\n     case 423:       /* no such article number in this group        */\n               ERR4(\"Article %d of %s is missing from server %s.\",\n                    ap->number, gp->name, np->nnserver);\n               bad_status = MISSING;\n               retval = FALSE;\n               break;\n     case 430:       /* no such article found                       */\n               ERR4(\"Article %d of %s could not be found by server %s.\",\n                    ap->number, gp->name, np->nnserver);\n               bad_status = MISSING;\n               retval = FALSE;\n               break;\n     case 223:       /* article retrieved - request text separately */\n     case 412:       /* no newsgroup has been selected              */\n     case 420:       /* no current article has been selected        */\n     default:  NNMrperr(np);      /* Report protocol error */\n               retval = FALSE;\n               break;\n   }\n }\n\n if (retval == FALSE) {\n   ap->action = bad_status;\n   return FALSE;\n }\n\n SetArticleRetrieved(ap);\n ap->action = NO_ACTION;\n\n if (retrieve_body) {\n   if (!NNMouttx(np,\" \",ap)) return FALSE;    /* output text line */\n   collect_text(np,ap);\n }\n\n apply_header_suppression(np,ap);\n\n return TRUE;\n}\n\n./ ADD NAME=NNMPMSG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#define  SUPPRESS_V_DECLARATION\n#pragma  csect(code,  \"NN@PMSG \")\n#pragma  csect(static,\"NN$PMSG \")\n#include \"nn.h\"\n\n/****** Set an ISPF message, or write to SYSOUT if batch mode. *******/\n\nvoid\nNNMpmsg(np,msgtype,msghelp,msgformat) /* also ... for sprintf args */\nRstruc nncb *np;\nint          msgtype;\nchar        *msghelp;\nchar        *msgformat;\n{\n va_list     argp;\n char       *cp;\n char        zerrsm    \u00dd25\u00a8;\n char        zerrhm     \u00dd9\u00a8;\n char        zerralrm   \u00dd4\u00a8;\n char        zerrlm   \u00ddZERRLM_SIZE\u00a8;\n char        buf      \u00dd257\u00a8;\n\n va_start(argp,msgformat);\n vsprintf(buf,msgformat,argp);\n va_end(argp);\n\n cp = strchr(buf,';');\n if (cp) {\n  *cp = '\\0';\n  strncpy(zerrsm,buf, sizeof(zerrsm));\n  strncpy(zerrlm,cp+1,sizeof(zerrlm));\n }\n else {\n  strcpy(zerrsm,\"\");\n  strncpy(zerrlm,buf,sizeof(zerrlm));\n }\n\n zerrsm\u00ddsizeof(zerrsm)-1\u00a8 = '\\0';\n zerrlm\u00ddsizeof(zerrlm)-1\u00a8 = '\\0';\n\n if (msghelp) strcpy(zerrhm, msghelp);\n else         strcpy(zerrhm, \"*\"    );\n\n if (np->batch_mode) {\n   if (!*zerrsm) {\n     switch (msgtype) {\n       case NOTIFY_MSG:    strcpy(zerrsm,\"Note\");  break;\n       case WARNING_MSG:\n       case CRITICAL_MSG:\n       default:            strcpy(zerrsm,\"Error\"); break;\n     }\n   }\n   fprintf(np->batch_outfile,\"%s: %s\\n\", zerrsm, zerrlm);\n   return;\n }\n\n switch (msgtype) {\n   case NOTIFY_MSG:    strcpy(zerralrm,\"NO \"); break;\n   case WARNING_MSG:\n   case CRITICAL_MSG:\n   default:            strcpy(zerralrm,\"YES\"); break;\n }\n\n (void)NNMivput(np,\"ZERRSM \",  zerrsm,   -1);\n (void)NNMivput(np,\"ZERRLM \",  zerrlm,   -1);\n (void)NNMivput(np,\"ZERRHM \",  zerrhm,   -1);\n (void)NNMivput(np,\"ZERRALRM \",zerralrm, -1);\n\n np->setmsg = TRUE;\n\n return;\n}\n\n./ ADD NAME=NNMPNG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@PNG  \")\n#pragma  csect(static,\"NN$PNG  \")\n#include \"nn.h\"\n\n/****** Set articles missing based on XHDR info. *********************/\n\nstatic void\nset_articles_missing(np,gp,anum,xnum)\nRstruc nncb      *np;\nRstruc newsgroup *gp;\nint               anum;\nint               xnum;\n{\n VARK            *vp;\n\n while (anum < xnum) {\n   if (np->debug_file) {\n     fprintf(np->debug_file, \"Setting article %d missing\\n\",anum);\n   }\n   vp = &GETVARK(gp,anum);\n   if (IsUnread(*vp)) gp->unread_count--;\n   SetMissingRead(*vp);\n   anum++;\n }\n\n return;\n}\n\n/****** Do XHDR stuff for newsgroup. *********************************/\n\nstatic void\ndo_xhdr(np,gp,allp)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nBool                 allp;\n{\n char               *lp;\n char               *xhdr_subject;\n VARK               *vplow;\n VARK               *vphigh;\n VARK               *vpfirst;\n VARK               *vplast;\n int                 range;\n int                 xhdr_article_number;\n int                 scan_count;\n int                 xhdr_low;\n int                 xhdr_high;\n int                 anum;\n\n /* If we need to know about missing articles,\n  * we try to determine it via XHDR.\n  *\n  *    We don't do anything useful with the headers yet.  We should.\n  *    That requires doing something with the allocation of the\n  *    newsarticle structures.\n  *\n  * We use XHDR when:\n  *\n  * (1) the total article count is less than the difference between\n  *     the low and high count from the GROUP command\n  *\n  * (2) there are null (never-retrieved) articles\n  *\n  * Fine, but requires looping around the article vector.\n  * Now, if we only want unread articles, we don't want to XHDR\n  * the whole thing, so in that case we only do this if there are\n  * any null-and-unread articles.\n  *\n  * *** this is still no good because articles are set missing\n  * *** but cannot be set present if we don't know if they will\n  * *** be eligible or not.  I will HAVE to keep the subject and\n  * *** set the article pointer to a placeholder with the subject,\n  * *** which means more article structures allocated, but that is\n  * *** probably the best thing to do.\n  *\n  * Solution: we call this routine only when a group migrates\n  * from unselected to selected status - either when it goes\n  * from never-selected to selected-unread, from never-selected\n  * to selected-all, or from selected-unread to selected-all.\n  * The first of the above cases is where allp is set to false\n  * so that we don't XHDR the whole thing just for a few unread items.\n  *\n  */\n\n if (!gp->article_vector) return;\n if (np->xhdr_not_available) return;\n\n range = gp->vector_last - gp->vector_first + 1;\n if (range <= gp->article_count) return;\n\n vpfirst = &GETVARKFIRST(gp);\n vplast  = &GETVARKLAST(gp);\n\n if (allp) {\n   for (vplow = vpfirst; vplow <= vplast; vplow++) {\n     if (IsNull(*vplow)) break;\n   }\n   if (vplow > vplast) return; /* if no null articles */\n   for (vphigh = vplast; vphigh > vplow; vphigh--) {\n     if (IsNull(*vphigh)) break;\n   }\n }\n else {\n   for (vplow = vpfirst; vplow <= vplast; vplow++) {\n     if (IsNull(*vplow) && IsUnread(*vplow)) break;\n   }\n   if (vplow > vplast) return; /* if no null articles */\n   for (vphigh = vplast; vphigh > vplow; vphigh--) {\n     if (IsNull(*vphigh) && IsUnread(*vphigh)) break;\n   }\n }\n\n xhdr_low  = VARK2NUMBER(gp,vplow);\n xhdr_high = VARK2NUMBER(gp,vphigh);\n\n /* Send \"XHDR SUBJECT nnn-nnn\" to news server. */\n\n NNMestng(np,NULL);  /* set server \"GROUP\" if necessary */\n                     /* e.g. going from unread-only to all */\n\n sprintf(np->nntp_command,\"XHDR SUBJECT %d-%d\",xhdr_low,xhdr_high);\n if (!NNMsockt(np)) return;          /* Send socket command to server */\n\n if (!NNMgsrvl(np,&lp)) return;        /* Get server line */\n switch (np->nntp_message_num) {\n   case 221:                           /* subject fields follow */\n             np->xhdr_not_available = FALSE;\n             break;\n   case 500:                           /* command unrecognized  */\n             np->xhdr_not_available = TRUE;\n             break;\n   default:\n             NNMrperr(np);        /* Report protocol error */\n             return;\n }\n\n if (np->xhdr_not_available) return;\n\n /* assert np->sending_text == TRUE; */\n\n anum = xhdr_low;\n\n for (;;) {\n\n   if (!NNMgsrvl(np,&lp))    return;   /* Get server line */\n   if (lp == NULL)           break;\n   if (strcmp(lp,\".\") == 0)  break;\n\n   if (1 != sscanf(np->nntp_message_text, \"%d %n\",\n                   &xhdr_article_number, &scan_count)) {\n     NNMrbfm(np);   /* Report bad format message */\n     return;\n   }\n\n   xhdr_subject = np->nntp_message_text + scan_count;\n\n   if (np->debug_file) {\n     fprintf(np->debug_file,\"XHDR: article='%d', subject='%s'\\n\",\n                            xhdr_article_number, xhdr_subject);\n   }\n   set_articles_missing(np,gp,anum,xhdr_article_number);\n   anum = xhdr_article_number + 1;\n }\n\n set_articles_missing(np,gp,anum,xhdr_high);\n\n return;\n}\n\n/****** Pick newsgroup. **********************************************/\n\nBool\nNNMpng(np,gp,do_titles,do_sort)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\nFool                  do_titles;\nFool                  do_sort;\n{\n Rstruc newsgroup    *gp1;\n Bool                 result = TRUE;\n Bool                 was_selected_unread;\n Bool                 was_selected_read;\n\n np->current_newsgroup   = gp;\n np->newsgroup_selected  = FALSE;\n np->newsgroup_not_found = FALSE;\n\n was_selected_read   = GroupSelectedRead(gp);\n was_selected_unread = GroupSelectedUnread(gp);\n\n if (!np->batch_mode) {\n   (void)NNMivput(np,\"NNGROUP \",gp->name,-1);\n }\n\n if (GroupSelected(gp)) {\n   if (np->show_all_articles) {\n     SetGroupSelectedRead(gp);\n   }\n   gp1 = gp;\n }\n else {\n   gp1 = NNMdng(np,gp,NULL);  /* do newsgroup by address */\n }\n\n if (!gp1) {\n   result = FALSE;\n }\n else if (np->newsgroup_not_found) {\n   SetNoSuchGroup(gp);\n   gp->article_count = 0;\n   gp->unread_count  = 0;\n   result = FALSE;\n }\n else {\n   gp = gp1;;\n\n   if (!was_selected_read && GroupSelectedRead(gp)) {\n     do_xhdr(np,gp,TRUE);             /* do XHDR stuff for all */\n   }\n   else if (!was_selected_unread && GroupSelectedUnread(gp)) {\n     do_xhdr(np,gp,FALSE);            /* do XHDR stuff for unread */\n   }\n\n   if (do_titles) (void)NNMrart(np,gp,FALSE,TRUE);\n   if (do_sort)   (void)NNMsort(np,gp);\n\n   result = NNMvar(np,gp);                   /* View articles */\n }\n\n np->current_newsgroup = NULL;\n np->newsgroup_selected = FALSE;\n\n /* hack to position newsgroup display*/\n\n strcpy(np->nngroup, gp->name);\n\n return result;\n}\n\n./ ADD NAME=NNMQAR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@QAR  \")\n#pragma  csect(static,\"NN$QAR  \")\n#include \"nn.h\"\n\n#define OUT1(A)       (void)NNMouttx(np,(A),NULL)\n#define OUT2(A,B)     sprintf(temp,(A),(B)),     OUT1(temp)\n#define OUT3(A,B,C)   sprintf(temp,(A),(B),(C)), OUT1(temp)\n#define ADD1(A)       strcat(stat,(A))\n#define ADD2(A,B)     sprintf(temp,(A),(B)),     ADD1(temp)\n\n/****** Query article. ***********************************************/\n\nBool\nNNMqar(np,ap)\nRstruc nncb         *np;\nRstruc newsarticle  *ap;\n{\n Rstruc newsgroup   *gp;\n char                stat\u00dd129\u00a8;\n char                temp\u00dd129\u00a8;\n\n gp = np->current_newsgroup;\n\n if (!gp) {\n  CRIT1(\"No current newsgroup.  This should never happen.\");\n  return FALSE;\n }\n\n NNMclrtx(np,NULL);\n\n if (ap == V_NULL_ARTICLE) {\n   OUT1(\"Null article\");\n }\n\n else if (ap == V_MISSING_ARTICLE) {\n   OUT1(\"Missing article\");\n }\n\n else {\n\n   OUT1(\"\");\n   OUT3(\"  Struct at %8.8X: Article %d\", ap, ap->number);\n   OUT1(\"\");\n   OUT2(\"status.........................%2.2X\", ap->status);\n   if (NoSuchArticle(ap))          OUT1(\" NoSuchArticle\"        );\n   if (ArticleAbsent(ap))          OUT1(\" ArticleAbsent\"        );\n   if (ArticleError(ap))           OUT1(\" ArticleError\"         );\n   if (ArticleBadData(ap))         OUT1(\" ArticleBadData\"       );\n   if (ArticleHeadRetrieved(ap))   OUT1(\" ArticleHeadRetrieved\" );\n   if (ArticleBodyRetrieved(ap))   OUT1(\" ArticleBodyRetrieved\" );\n   strcpy(stat,\"action.........................\");\n   switch (ap->action) {\n     case NO_ACTION:             ADD1(\"NO_ACTION\");             break;\n     case READ:                  ADD1(\"READ\");                  break;\n     case RETRIEVED:             ADD1(\"RETRIEVED\");             break;\n     case EXTRACTED:             ADD1(\"EXTRACTED\");             break;\n     case PRINTED:               ADD1(\"PRINTED\");               break;\n     case UNREAD:                ADD1(\"UNREAD\");                break;\n     case MISSING:               ADD1(\"MISSING\");               break;\n     case ERROR:                 ADD1(\"ERROR\");                 break;\n     case CANCELLED:             ADD1(\"CANCELLED\");             break;\n     default:                    ADD2(\"%d\",ap->action);         break;\n   }\n   OUT1(stat);\n   OUT2(\"number.........................%d\",    ap->number);\n   OUT2(\"from...........................%s\",    ap->from);\n   OUT2(\"subject........................%s\",    ap->subject);\n   OUT2(\"date...........................%s\",    ap->date);\n   OUT2(\"message_id.....................%s\",    ap->message_id);\n\n   if (ap->csubject)\n     OUT2(\"csubject.......................%s\",  ap->csubject);\n   else\n     OUT1(\"csubject is NULL\");\n\n   OUT2(\"text line count................%d\", ap->thdr.text_line_count);\n   OUT2(\"text max length................%d\", ap->thdr.text_max_length);\n   OUT2(\"text max tab expanded length...%d\",\n                                ap->thdr.text_max_tab_expanded_length);\n   OUT2(\"text body line..............%8.8X\",ap->thdr.text_body_line);\n   OUT2(\"first text line.............%8.8X\",ap->thdr.first_text_line);\n   OUT2(\"current text line...........%8.8X\",ap->thdr.current_text_line);\n   OUT2(\"last text line..............%8.8X\",ap->thdr.last_text_line);\n\n }\n\n NNMvtx(np,NULL,NULL);\n\n return TRUE;\n}\n\n./ ADD NAME=NNMQNG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@QNG  \")\n#pragma  csect(static,\"NN$QNG  \")\n#include \"nn.h\"\n\n#define OUT1(A)       (void)NNMouttx(np,(A),NULL)\n#define OUT2(A,B)     sprintf(temp,(A),(B)),     OUT1(temp)\n#define OUT3(A,B,C)   sprintf(temp,(A),(B),(C)), OUT1(temp)\n#define ADD1(A)       strcat(stat,(A))\n#define ADD2(A,B)     sprintf(temp,(A),(B)),     ADD1(temp)\n\n/****** Query newsgroup. *********************************************/\n\nvoid\nNNMqng(np,gp)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\n{\n struct newsarticle *ap;\n int                 i;\n VARK               *vp;\n VARK               *vpfirst;\n VARK               *vplast;\n VARK              **wp;\n VARK              **wpfirst;\n VARK              **wplast;\n char                stat\u00dd129\u00a8;\n char                temp\u00dd129\u00a8;\n\n if (!gp) return;\n\n NNMclrtx(np,NULL);\n\n OUT1(\"\");\n OUT3(\"    Struct at %8.8X: Newsgroup '%s'\", gp, gp->name);\n OUT1(\"\");\n OUT2(\"next.......................%8.8X\", gp->next);\n OUT2(\"next2......................%8.8X\", gp->next2);\n OUT2(\"next3......................%8.8X\", gp->next3);\n OUT2(\"saved_newsrc_line..........%8.8X\", gp->saved_newsrc_line);\n OUT2(\"article_vector.............%8.8X\", gp->article_vector);\n OUT2(\"sort_vector................%8.8X\", gp->sort_vector);\n OUT2(\"low_number.................%d\",    gp->low_number);\n OUT2(\"high_number................%d\",    gp->high_number);\n OUT2(\"vector_first...............%d\",    gp->vector_first);\n OUT2(\"vector_last................%d\",    gp->vector_last);\n OUT2(\"article_count..............%d\",    gp->article_count);\n OUT2(\"unread_count...............%d\",    gp->unread_count);\n OUT2(\"sort_count.................%d\",    gp->sort_count);\n OUT2(\"article_vector_len.........%d\",    gp->article_vector_len);\n OUT2(\"registered.................%d\",    gp->registered);\n OUT2(\"saved_newsrc_data..........%s\",    gp->saved_newsrc_data);\n OUT2(\"status.....................%2.2X\", gp->status);\n if (NoSuchGroup(gp))         OUT1(\" NoSuchGroup\"           );\n if (NewGroup(gp))            OUT1(\" NewGroup\"              );\n if (GroupFromNewsrc(gp))     OUT1(\" GroupFromNewsrc\"       );\n if (GroupListed(gp))         OUT1(\" GroupListed\"           );\n if (GroupSelectedUnread(gp)) OUT1(\" GroupSelectedUnread\"   );\n if (GroupSelectedRead(gp))   OUT1(\" GroupSelectedRead\"     );\n if (GroupError(gp))          OUT1(\" GroupError\"            );\n if (GroupInTable(gp))        OUT1(\" GroupInTable\"          );\n OUT2(\"name.......................%s\",    gp->name);\n if (gp->saved_newsrc_line) {\n   OUT1(\"\");\n   OUT1(\"Saved newsrc line follows:\");\n   OUT1(\"\");\n   OUT1(gp->saved_newsrc_line);\n   OUT1(\"\");\n   OUT1(\"\");\n }\n\n if (gp->article_vector) {\n   OUT1(\"\");\n   OUT1(\"Article vector follows:\");\n   OUT1(\"\");\n   vpfirst = &GETVARKFIRST(gp);\n   vplast  = &GETVARKLAST(gp);\n   for (vp = vpfirst, i = gp->vector_first; vp <= vplast; vp++,i++) {\n     sprintf(stat,\" %10d: %8.8X    \",i,*vp);\n     ap = VARK2PARTICLE(*vp);\n     if (ap == V_NULL_ARTICLE)         ADD1(\"Null     \");\n     else if (ap == V_MISSING_ARTICLE) ADD1(\"Missing  \");\n     else                              ADD2(\"%8.8X \",ap);\n     if (IsKnown(*vp))                 ADD1(\"Known   \");\n     else                              ADD1(\"Unknown \");\n     if (IsEligible(*vp))              ADD1(\"Eligible   \");\n     else                              ADD1(\"Ineligible \");\n     if (IsRead(*vp))                  ADD1(\"Read   \");\n     else                              ADD1(\"Unread \");\n     OUT1(stat);\n   }\n }\n if (gp->sort_vector) {\n   OUT1(\"\");\n   OUT1(\"Sort vector follows:\");\n   OUT1(\"\");\n   wpfirst = gp->sort_vector;\n   wplast  = gp->sort_vector + gp->sort_count;\n   for (wp = wpfirst; wp < wplast; wp++) {\n     OUT3(\"     %8.8X: %8.8X\",*wp,**wp);\n   }\n }\n\n NNMvtx(np,NULL,NULL);\n\n return;\n}\n\n./ ADD NAME=NNMRARH\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@RARH \")\n#pragma  csect(static,\"NN$RARH \")\n#include \"nn.h\"\n\n/****** Get article. *************************************************/\n\nstatic struct newsarticle *\nget_article(np,gp,vp,anum,cdp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\nVARK                 *vp;\nint                   anum;\nstruct countdown     *cdp;\n{\n struct newsarticle  *ap;\n char                *lp;\n char                *cp;\n struct textline     *tp;\n int                  header_index;\n char                 header_name\u00ddINTERNET_SIZE\u00a8;\n\n if (anum <= 0) anum = VARK2NUMBER(gp,vp);\n\n SetUnknown(*vp);\n\n /* Allocate a struct newsarticle for this article */\n\n GETMAIN(ap, struct newsarticle, 1, \"news article\");\n if (!ap) {\n   ERR2(\"There is not enough memory to retrieve article %d.\", anum);\n   SetIneligible(*vp);\n   return NULL;\n }\n\n *vp = ((VARK)ap | VARK2BITS(*vp));\n\n memset(ap,0,sizeof(struct newsarticle));\n ClearArticleStatus(ap);\n ap->action = ERROR;\n ap->number = anum;\n\n if (!NNMestng(np,NULL)) {                 /* Establish newsgroup */\n   SetArticleError(ap);\n   SetIneligible(*vp);\n   return NULL;\n }\n\n tp = NULL;\n\n /* If user asked for screen updates, do them here. */\n\n NNMupdt(np,cdp,\"NNMLART2\");\n\n /* Ask for the head of the article by number. */\n /* (Is it better to ask by message-id? Dunno) */\n\n sprintf(np->nntp_command,\"HEAD %d\",ap->number);\n if (!NNMsockt(np)) return FALSE;  /* Send socket command to server */\n\n if (NNMgsrvl(np,&lp)) {           /* Get server line */\n   switch (np->nntp_message_num) {\n     case 221:          /* article retrieved, head follows         */\n               SetArticleHeadRetrieved(ap);\n               break;\n     case 423:          /*    no such article number in this group */\n               SetNoSuchArticle(ap);\n               ap->action = MISSING;\n               break;\n     case 430:          /*    no such article found                */\n               SetArticleAbsent(ap);\n               ap->action = MISSING;\n               break;\n     default:\n               SetArticleError(ap);\n               NNMrperr(np);        /* Report protocol error */\n               break;\n   }\n }\n\n if (!ArticleHeadRetrieved(ap)) {\n   if IsUnread(*vp) gp->unread_count--;\n   SetMissingRead(*vp);\n   return NULL;\n }\n\n /* Scan the text for headers and extract the subject and whatever. */\n\n ap->subject    = \"\";\n ap->from       = \"\";\n ap->message_id = \"\";\n ap->date       = \"\";\n\n np->sending_text = TRUE; /* Stuff following is header text */\n\n for (;;) {\n\n   if (!NNMgsrvl(np,&lp))            break;  /* Get server line */\n   if (lp == NULL)                   break;\n   if (np->server_finished_replying) break;\n   if (!(tp=NNMouttx(np,lp,ap)))     break;  /* Output text line */\n\n   if (*(cp=tp->tab_expanded_text) == ' ') continue;\n\n   header_name\u00dd0\u00a8 = '\\0';\n   header_index = 0;\n   while (*cp != ':') {\n     if (*cp == '\\0' || *cp == ' ') {\n       NNMdump(np,\"Warning, bad header line\",lp,strlen(lp));\n       SetArticleBadData(ap);\n       break;\n     }\n     else header_name\u00ddheader_index++\u00a8 = toupper(*cp++);\n   }\n\n   header_name\u00ddheader_index\u00a8 = '\\0';\n   cp = skip_whitespace(cp+1);\n   if      (EQUAL(header_name,\"FROM\")) {\n           ap->from = cp;\n   }\n   else if (EQUAL(header_name,\"SUBJECT\")) {\n           ap->subject = cp;\n   }\n   else if (EQUAL(header_name,\"MESSAGE-ID\")) {\n           ap->message_id = cp;\n   }\n   else if (EQUAL(header_name,\"DATE\")) {\n           cp = strpbrk(cp,\"0123456789\");\n           if (!cp) cp = \"*BAD DATE*\";\n           ap->date = cp;\n   }\n }\n\n /* Prepare ISPF variables for possible panel or message processing. */\n\n if (!np->batch_mode) {\n   (void)NNMivput(np,\"NNTSUBJ \" ,ap->subject,-1);\n }\n\n /* Since we retrieved the article, it can't be missing, can it? */\n\n SetKnown(*vp);\n ap->action = NO_ACTION;\n\n return ap;\n\n}\n\n/****** Retrieve article header. *************************************/\n\nstruct newsarticle *\nNNMrarh(np,gp,vp,anum,cdp)\nRstruc nncb          *np;\nRstruc newsgroup     *gp;\nVARK                 *vp;\nint                   anum;\nstruct countdown     *cdp;\n{\n Rstruc newsarticle  *ap;\n\n /* Note that either vp or anum may be null (zero), but NOT BOTH. */\n\n if (!vp) vp = &GETVARK(gp,anum);\n ap = VARK2PARTICLE(*vp);\n\n if (ap == V_NULL_ARTICLE)  return get_article(np,gp,vp,anum,cdp);\n else if (ap == V_MISSING_ARTICLE) return NULL;\n else                              return ap;\n\n}\n\n./ ADD NAME=NNMRART\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@RART \")\n#pragma  csect(static,\"NN$RART \")\n#include \"nn.h\"\n\n/****** Retrieve all article titles. *********************************/\n\nint\nNNMrart(np,gp,not_just_unread,not_just_only)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nFool                 not_just_unread;\nFool                 not_just_only;\n{\n struct newsarticle *ap;\n VARK               *vp;\n VARK               *vpfirst;\n VARK               *vplast;\n VARK              **wp;\n VARK              **wpfirst;\n VARK              **wplast;\n int                 count;\n struct countdown    cd;\n Bool                save_show_all_articles;\n char                save_article_only_char;\n\n np->bypass_header_retrieval = FALSE;\n\n if (!gp->article_vector) return 0;\n\n vpfirst = &GETVARKFIRST(gp);\n vplast  = &GETVARKLAST(gp);\n\n if (np->updatefreq < 0) {\n   cd.do_update = FALSE;\n   cd.done      = 0;\n   cd.to_do     = 0;\n }\n else {\n   cd.do_update = TRUE;\n   cd.done      = 0;\n   cd.to_do     = 0;\n   if (not_just_unread) {\n     for (vp = vpfirst; vp <= vplast; vp++) {\n       if (IsNull(*vp)) cd.to_do++;\n     }\n   }\n   else {\n     for (vp = vpfirst; vp <= vplast; vp++) {\n       if (IsNull(*vp) && IsUnread(*vp)) cd.to_do++;\n     }\n   }\n }\n\n if (not_just_unread) {\n   save_show_all_articles = np->show_all_articles;\n   np->show_all_articles = TRUE;\n }\n if (not_just_only) {\n   save_article_only_char = np->article_only_string\u00dd0\u00a8;\n   np->article_only_string\u00dd0\u00a8 = '\\0';\n }\n\n count = 0;\n\n if (gp->sort_vector) {\n   wpfirst = gp->sort_vector;\n   wplast  = gp->sort_vector + gp->sort_count - 1;\n   for (wp = wpfirst; wp <= wplast; wp++) {\n     SetUnknown(**wp);\n     if (NNMcar(np,gp,0,*wp,NULL,&cd,RETRIEVE)) { /* Choose article */\n       count++;\n     }\n   }\n }\n else {\n   for (vp = vpfirst; vp <= vplast; vp++) {\n     SetUnknown(*vp);\n     if (NNMcar(np,gp,0,vp,NULL,&cd,RETRIEVE)) { /* Choose article */\n       count++;\n     }\n   }\n }\n\n /*\n  * IMPORTANT: On return, articles are set eligible if their titles\n  * have been retrieved, even if we fudged the criteria.  We could\n  * reset them all to unknown, but NNMsort needs this information,\n  * so it is the responsibility of the caller of NNMrart to reset\n  * all the statuses if it called NNMrart with fudging turned on.\n  */\n\n if (not_just_unread) {\n   np->show_all_articles = save_show_all_articles;\n }\n if (not_just_only) {\n   np->article_only_string\u00dd0\u00a8 = save_article_only_char;\n }\n\n return count; /* number of eligible and retrieved, for NNMsort */\n}\n\n./ ADD NAME=NNMRBFM\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@RBFM \")\n#pragma  csect(static,\"NN$RBFM \")\n#include \"nn.h\"\n\n/****** Report bad format message. ***********************************/\n\nvoid\nNNMrbfm(np)\nRstruc nncb  *np;\n{\n\n NNMclrtx(np,NULL);                         /* Clear text */\n\n CRIT2(\"NNTP message from server %s has invalid format.\", np->nnserver);\n\n (void)NNMouttx(np,np->server_buf,NULL);    /* Output text line */\n NNMvtx(np,NULL,NULL);                      /* View text */\n\n return;\n}\n\n./ ADD NAME=NNMRECON\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@RECON\")\n#pragma  csect(static,\"NN$RECON\")\n#include \"nn.h\"\n\n/****** Reconnect to server. *****************************************/\n\nBool\nNNMrecon(np)\nRstruc nncb        *np;\n{\n struct newsgroup  *gp;\n char               save_command\u00ddCLIENT_BUF_MSGSIZE+4\u00a8;\n\n if (np->dont_reconnect) {\n   CRIT2(\n \"Disconnected from server %s.  Reconnection will not be attempted.\",\n         np->nnserver);\n   return FALSE;\n }\n\n np->connected_to_server   = FALSE;\n np->reconnect_in_progress = TRUE;\n\n if (!np->batch_mode) {\n   (void)NNMispf(np,\"CONTROL DISPLAY LOCK\");\n   (void)NNMispf(np,\"DISPLAY PANEL(NNMLRCON)\");\n }\n\n /*\n  * fprintf(stderr,\"Lost connection, possible timeout.\\n\");\n  * fprintf(stderr,\"Attempting reconnection to news server %s (%s)\\n\",\n  *                np->server_hostname,\n  *                np->server_ip_addrstr);\n  */\n\n if (!NNMconn(np)) {                 /* Connect to news server */\n   CRIT2(\"Reconnection failed to server %s after disconnect.\",\n         np->nnserver);\n   return FALSE;\n }\n\n /* If there is a current newsgroup and we're not currently trying\n  * to issue a \"GROUP\" command, then reestablish server's state.\n  */\n\n if ((gp=np->current_newsgroup)\n     && memcmp(np->nntp_command,\"GROUP \",6)) /* not \"GROUP\" */ {\n\n   if (!np->batch_mode) {\n     (void)NNMispf(np,\"CONTROL DISPLAY LOCK\");\n     (void)NNMispf(np,\"DISPLAY PANEL(NNMLRSNG)\");\n   }\n\n   strcpy(save_command,np->nntp_command);\n   /* Establish newsgroup */\n   if (!NNMestng(np,gp->name)) {\n     strcpy(np->nntp_command,save_command);\n     CRIT3(\n       \"Reselect of newsgroup %s failed during reconnection to %s.\",\n       gp->name, np->nnserver);\n     return FALSE;\n   }\n   strcpy(np->nntp_command,save_command);\n }\n np->reconnect_in_progress = FALSE;\n return TRUE;\n}\n\n./ ADD NAME=NNMRPERR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@RPERR\")\n#pragma  csect(static,\"NN$RPERR\")\n#include \"nn.h\"\n\n/****** Report protocol error. ***************************************/\n\nvoid\nNNMrperr(np)\nRstruc nncb  *np;\n{\n\n NNMclrtx(np,NULL);                         /* Clear text */\n\n CRIT2(\"NNTP protocol error.  Unexpected response by server %s.\",\n       np->nnserver);\n\n (void)NNMouttx(np,np->server_buf,NULL);    /* Output text line */\n NNMvtx(np,NULL,NULL);                      /* View text */\n\n return;\n}\n\n./ ADD NAME=NNMSAVE\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@SAVE \")\n#pragma  csect(static,\"NN$SAVE \")\n#include \"nn.h\"\n#include \"nnbatch.h\"\n\n/****** Save NEWSRC file. ********************************************/\n\nBool\nNNMsave(np,rest)\nRstruc nncb         *np;\nchar                *rest;\n{\n Rstruc batch       *bp;\n\n if (np->batch_mode) {\n   bp = np->batch_hook;\n   if (GETB(\"CHECKPOINT\") == FALSE) return TRUE;\n }\n\n NNMcnrf(np,NULL,TRUE);  /* Close NEWSRC file */\n\n /* Reopen the file for input.  Don't let anybody else sneak in. */\n\n if (!(np->newsrc_file = fopen(np->newsrc_to_open,\"r\"))) {\n   perror(\"Cannot reopen NEWSRC file\");\n }\n\n return TRUE;\n}\n\n./ ADD NAME=NNMSOCKT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@SOCKT\")\n#pragma  csect(static,\"NN$SOCKT\")\n#include \"nn.h\"\n\n/****** Output one data line for the server. *************************/\n\nBool\nNNMsockt(np)\nRstruc nncb    *np;\n{\n int            nntp_bytes;\n int            writrc;\n char          *s_buf;\n\n nntp_bytes = strlen(np->nntp_command);\n\n /* Before sending a request to the server, do a cleanup operation\n    to make sure that no more responses are coming from the server. */\n\n NNMesrvr(np);           /* End server read */\n\n memcpy(np->client_buf,np->nntp_command,nntp_bytes);\n np->client_buf\u00ddnntp_bytes  \u00a8 = CARRIAGE_RETURN;\n np->client_buf\u00ddnntp_bytes+1\u00a8 = LINE_FEED;\n\n if (np->receiving_text &&\n     nntp_bytes == 1    &&\n     np->client_buf\u00dd0\u00a8 == '.') {\n   np->receiving_text = FALSE;\n }\n\n if (np->debug_mode)\n    NNMdump(np,\"Writing to server\",np->client_buf,nntp_bytes+2);\n\n#ifdef MVS\n EBCDIC_TO_ASCII(np->client_buf,nntp_bytes+2);\n#endif\n\n writrc = write(np->socknum, np->client_buf, nntp_bytes+2);\n if (writrc < 0) {\n   np->connection_broken = TRUE;\n   if (!np->reconnect_in_progress) {\n     GETMAIN(s_buf,char,CLIENT_BUF_MSGSIZE+4,\"socket buffer\");\n     if (s_buf) {\n       memcpy(s_buf,np->client_buf,nntp_bytes+2);\n       if (NNMrecon(np)) {     /* Reconnect to server */\n         writrc = write(np->socknum, s_buf, nntp_bytes+2);\n       }\n       FREEMAIN(s_buf, \"old socket buffer\");\n     }\n   }\n }\n if (writrc < 0) {\n   CRIT2(\"TCP/IP error: write() failed to send data to server %s.\",\n         np->nnserver);\n   return FALSE;\n }\n\n NNMssrvr(np);      /* Start server read */\n\n return TRUE;\n}\n\n./ ADD NAME=NNMSOPT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@SOPT \")\n#pragma  csect(static,\"NN$SOPT \")\n#include \"nn.h\"\n\n#define BOOLOPTSET(A,B,C) \\\n   switch (A\u00dd0\u00a8) { \\\n     case  'n': \\\n     case  'N':   B = FALSE; break; \\\n     case  'y': \\\n     case  'Y':   B = TRUE; break; \\\n     case '\\0': \\\n     default:     B = C; break; \\\n   }\n\n/****** Set options that are stored in ISPF profile. *****************/\n\nvoid\nNNMsopt(np,which)\nRstruc nncb        *np;\nenum user_option    which;\n{\n int                arrows;\n char               tempinc \u00dd256\u00a8;\n char               tempexc \u00dd256\u00a8;\n char               nnmupdtf\u00dd 12\u00a8;\n char               nnextpow\u00dd  4\u00a8;\n char               nnextpap\u00dd  4\u00a8;\n char               nnupan  \u00dd  4\u00a8;\n char               nnuprn  \u00dd  4\u00a8;\n char               nnupra  \u00dd  4\u00a8;\n char               nnngscr \u00dd  4\u00a8;\n char               nnngcsr \u00dd  4\u00a8;\n char               nnarscr \u00dd  4\u00a8;\n char               nnarcsr \u00dd  4\u00a8;\n char               nnarrows\u00dd  2\u00a8;\n\n if (which == OPTION_ALL) {\n   NNMispf(np, \"VGET \\\n(NNRFCOPT NNRFCINC NNRFCEXC\\\n NNUPAN NNUPRN NNUPRA NNMUPDTF NNEXTPOW NNEXTPAP\\\n NNNGSCR NNNGCSR NNARSCR NNARCSR NNARROWS)\\\n PROFILE\");\n }\n\n if (which == OPTION_ALL || which == OPTION_HEADER) {\n\n   (void)NNMivget(np,\"NNRFCOPT \", np->nnrfcopt, sizeof(np->nnrfcopt));\n   (void)NNMivget(np,\"NNRFCINC \", tempinc, sizeof(tempinc));\n   (void)NNMivget(np,\"NNRFCEXC \", tempexc, sizeof(tempexc));\n\n   if (!*np->nnrfcopt) strcpy(np->nnrfcopt,\"A\");\n   sprintf(np->nnrfcinc,\" %s \",tempinc);\n   sprintf(np->nnrfcexc,\" %s \",tempexc);\n\n }\n\n if (which == OPTION_ALL || which == OPTION_OTHER) {\n\n   (void)NNMivget(np,\"NNUPAN \",   nnupan,   sizeof(nnupan  ));\n   (void)NNMivget(np,\"NNUPRN \",   nnuprn,   sizeof(nnuprn  ));\n   (void)NNMivget(np,\"NNUPRA \",   nnupra,   sizeof(nnupra  ));\n   (void)NNMivget(np,\"NNMUPDTF \", nnmupdtf, sizeof(nnmupdtf));\n   (void)NNMivget(np,\"NNEXTPOW \", nnextpow, sizeof(nnextpow));\n   (void)NNMivget(np,\"NNEXTPAP \", nnextpap, sizeof(nnextpap));\n\n   /* 5 is a \"reasonable\" default, according to DDI */\n\n   if      (nnmupdtf\u00dd0\u00a8 == '\\0')     np->updatefreq = 5;\n   else if (EQUAL(nnmupdtf, \"OFF\"))  np->updatefreq = -1;\n   else if (EQUAL(nnmupdtf, \"ON\"))   np->updatefreq = 0;\n   else                              np->updatefreq = atoi(nnmupdtf);\n\n   BOOLOPTSET(nnupan,   np->update_adding_newsgroups,    FALSE);\n   BOOLOPTSET(nnuprn,   np->update_rewriting_newsrc,     TRUE);\n   BOOLOPTSET(nnupra,   np->update_retrieving_articles,  TRUE);\n   BOOLOPTSET(nnextpow, np->warn_overwrite,              TRUE);\n   BOOLOPTSET(nnextpap, np->warn_append,                 TRUE);\n\n   if (!np->update_retrieving_articles) np->updatefreq = -1;\n\n }\n\n if (which == OPTION_ALL || which == OPTION_VIEW) {\n\n   (void)NNMivget(np,\"NNNGSCR \",  nnngscr,  sizeof(nnngscr ));\n   (void)NNMivget(np,\"NNNGCSR \",  nnngcsr,  sizeof(nnngcsr ));\n   (void)NNMivget(np,\"NNARSCR \",  nnarscr,  sizeof(nnarscr ));\n   (void)NNMivget(np,\"NNARCSR \",  nnarcsr,  sizeof(nnarcsr ));\n   (void)NNMivget(np,\"NNARROWS \", nnarrows, sizeof(nnarrows));\n\n   BOOLOPTSET(nnngscr,  np->newsgroup_autoscroll,        TRUE);\n   BOOLOPTSET(nnngcsr,  np->newsgroup_autocursor,       FALSE);\n   BOOLOPTSET(nnarscr,  np->article_autoscroll,          TRUE);\n   BOOLOPTSET(nnarcsr,  np->article_autocursor,         FALSE);\n\n   switch (nnarrows\u00dd0\u00a8) {\n     case  '1':\n     default:     arrows = 1;              break;\n     case  '2':   arrows = 2;              break;\n     case  '3':   arrows = 3;              break;\n   }\n\n   if (arrows != np->article_rows) {\n     np->article_rows = arrows;\n     np->article_criterion_changed = TRUE;\n   }\n }\n\n return;\n}\n\n./ ADD NAME=NNMSORT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@SORT \")\n#pragma  csect(static,\"NN$SORT \")\n#include \"nn.h\"\n\n/****** Compare articles by number. **********************************/\n\nstatic int\ncompare_articles_by_number(wp1,wp2)\nregister const void       *wp1;\nregister const void       *wp2;\n{\n return\n        (VARK2PARTICLE(**(VARK **)wp1))->number\n      - (VARK2PARTICLE(**(VARK **)wp2))->number\n       ;\n}\n\n/****** Compare articles by subject. *********************************/\n\nstatic int\ncompare_articles_by_subject(wp1,wp2)\nregister const void       *wp1;\nregister const void       *wp2;\n{\n int answer;\n\n answer = strcmp(\n                 (VARK2PARTICLE(**(VARK **)wp1))->csubject,\n                 (VARK2PARTICLE(**(VARK **)wp2))->csubject\n                );\n if (answer == 0) return compare_articles_by_number(wp1,wp2);\n else return answer;\n\n}\n\n/****** Make canonical subject. *************************************/\n\nstatic char *\nmake_canonical_subject(spp,subject)\nchar                 **spp;\nchar                  *subject;\n{\n char                 *ip;\n char                 *op;\n char                 *rp;\n int                   re_count;\n\n if (!*subject) return \"\";\n\n /* Scan past \"re\"s and count them up */\n\n rp = *spp;\n\n re_count = -1;\n ip = subject - 3;\n do {\n   ip = ip + 3 + strspn(ip + 3,\" \\t\");\n   re_count++;\n } while (!memcmp(ip,\"Re:\",3) ||\n          !memcmp(ip,\"re:\",3) ||\n       /* !memcmp(ip,\"rE:\",3) || - do you really expect this??? */\n          !memcmp(ip,\"RE:\",3));\n\n /* Copy subject to buffer while lowercasing. Sets op to last nonblank\n    character in buffer. */\n\n copy_lowercase_and_strip_trailing(rp,ip,op);\n\n /* Hack for prioritizing RE:'s.  Add a byte at the end to put\n  * subjects in order.  e.g.:\n  * Subject: Foo              --> \"foo\\0\"\n  * Subject: Re: Foo          --> \"foo\\001\\0\"\n  * Subject: Re: Re: Foo      --> \"foo\\002\\0\"\n  *\n  * This algorithm will break if there are more than 255 \"RE:\"s,\n  * but do you really think that's likely?\n  */\n\n if (re_count > 0) {\n   *op = (unsigned char) re_count;\n   op++;\n }\n *op = '\\0';\n\n *spp = op + 1;   /* Bump buffer pointer past our new end */\n\n return rp;\n\n}\n\n/****** Sort article table. *****************************************/\n\nBool\nNNMsort(np,gp)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\n{\n Rstruc newsarticle *ap;\n VARK               *vp;\n VARK               *vpfirst;\n VARK               *vplast;\n VARK              **wp;\n char               *sortbuf;\n char               *sp;\n int                 sortbufsize;\n int                 count;\n int                 i;\n\n if (!gp->article_vector) return TRUE;\n\n if (gp->sort_vector) {\n   FREEMAIN(gp->sort_vector,\"sort vector\");\n   gp->sort_vector = NULL;\n   gp->sort_count  = 0;\n }\n\n /* Retrieve article titles, read or unread, but ignoring any\n  * subject filtering.\n  */\n count = NNMrart(np,gp,FALSE,TRUE); /* Retrieve article titles */\n if (count == 0) return TRUE;\n\n GETMAIN(gp->sort_vector, VARK **, count, \"sort vector\");\n if (!gp->sort_vector) {\n   CRIT1(\"There is not enough memory to sort the newsgroup.\");\n   return FALSE;\n }\n\n gp->sort_count = count;\n\n vpfirst = &GETVARKFIRST(gp);\n vplast  = &GETVARKLAST(gp);\n wp = gp->sort_vector;\n sortbufsize = 0;\n for (vp = vpfirst; vp <= vplast; vp++) {\n   if (IsEligible(*vp)) {     /* i.e. if NNMrart retrieved it */\n     ap = VARK2PARTICLE(*vp);\n     if (*ap->subject) sortbufsize += strlen(ap->subject) + 1;\n     SetUnknown(*vp);         /* unfudge status as we go */\n     *(wp++) = vp;\n   }\n }\n\n if (sortbufsize > 0) {\n   GETMAIN(sortbuf, char, sortbufsize, \"sort-by-subject buffer\");\n   if (!sortbuf) {\n     CRIT1(\"There is not enough memory to sort articles by subject.\");\n     FREEMAIN(gp->sort_vector,\"sort vector\");\n     gp->sort_vector = NULL;\n     gp->sort_count  = 0;\n     return FALSE;\n   }\n }\n\n sp = sortbuf;\n for (wp = gp->sort_vector, i = gp->sort_count; i > 0; wp++, i--) {\n   ap = VARK2PARTICLE(**wp);\n   ap->csubject = make_canonical_subject(&sp,ap->subject);\n }\n\n qsort(gp->sort_vector, gp->sort_count, sizeof(VARK **),\n       compare_articles_by_subject);\n\n /* This isn't strictly necessary as long as no one tries to refer\n  * to ap->csubject outside of this module.\n  *\n for (wp = gp->sort_vector, i = gp->sort_count; i > 0; wp++, i--) {\n   ap = VARK2PARTICLE(**wp);\n   ap->csubject = NULL;\n }\n  *\n  */\n\n FREEMAIN(sortbuf,\"sort-by-subject buffer\");\n\n return TRUE;\n}\n\n./ ADD NAME=NNMSSRVR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@SSRVR\")\n#pragma  csect(static,\"NN$SSRVR\")\n#include \"nn.h\"\n\n/****** Start server read. *******************************************/\n\nvoid\nNNMssrvr(np)\nRstruc nncb  *np;\n{\n\n np->server_has_something_pending = TRUE;\n np->server_finished_replying     = FALSE;\n np->sending_text                 = FALSE;\n np->something_to_print           = FALSE;\n np->dont_read                    = FALSE;\n\n return;\n\n}\n\n./ ADD NAME=NNMSTRLC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@STRLC\")\n#pragma  csect(static,\"NN$STRLC\")\n#include \"nn.h\"\n\n/****** Case-insensitive string search. ******************************/\n\n  /* This differs from the Ustrstr function in NNMbbexp in that it only\n   * has to lowercase the \"b\" argument, not both.  The \"a\" argument\n   * is assumed to be all lower case already.\n   */\n\nchar *\nNNMstrlc(b,a)\nregister char  *b;\nregister char  *a;\n{\n register char *aa;\n register char *bb;\n\n if (!*a) return strchr(b,'\\0');\n\n for (;;) {\n\n   while (*b && (*a != tolower(*b))) b++;\n\n   if (!*b) return NULL;\n\n   for (aa = a, bb = b;\n        *aa && *bb && (*aa == tolower(*bb));\n        aa++, bb++) ;\n\n   if (!*aa) return a;\n\n   b++;\n }\n\n}\n\n./ ADD NAME=NNMSUMAT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@SUMAT\")\n#pragma  csect(static,\"NN$SUMAT\")\n#include \"nn.h\"\n\n/****** Subject matching code. ***************************************/\n\nBool\nNNMsumat(a,b)\nchar        *a;\nchar        *b;\n{\n char       *cp;\n char       *c1;\n char       *c2;\n char        bracket;\n char        s1\u00dd257\u00a8;\n char        s2\u00dd257\u00a8;\n\n strncpy(s1,a,256);\n strncpy(s2,b,256);\n\n lowercase_and_strip_trailing_in_place(s1);\n lowercase_and_strip_trailing_in_place(s2);\n\n c1 = skip_whitespace(s1);\n c2 = skip_whitespace(s2);\n\n if (!strcmp(c1,c2)) return TRUE;\n\n while (!memcmp(c1,\"re:\",3)) {\n   c1 = skip_whitespace(c1+3);\n   if (!strcmp(c1,c2)) return TRUE;\n }\n while (!memcmp(c2,\"re:\",3)) {\n   c2 = skip_whitespace(c2+3);\n   if (!strcmp(c1,c2)) return TRUE;\n }\n\n if ((cp=strstr(c1,\"(was:\" /*)*/ )) ||\n     (cp=strstr(c1,\"(was \" /*)*/ )) ||\n     (cp=strstr(c1,\"\u00ddwas \" /*)*/ )) ||\n     (cp=strstr(c1,\"\u00ddwas:\" /*)*/ ))) {\n   switch (*cp) {\n     case '(':  bracket = ')';  break;\n     case '\u00dd':  bracket = '\u00a8';  break;\n     default:   bracket = '\\0'; break;\n   }\n   c1 = skip_whitespace(cp+5);\n   if (!memcmp(c1,\"re:\",3)) c1 = skip_whitespace(c1+3);\n   if (!strcmp(c1,c2)) return TRUE;\n   cp = c1 + strlen(c1) - 1;\n   if (*cp == bracket) *cp = '\\0';\n   if (!strcmp(c1,c2)) return TRUE;\n }\n if ((cp=strstr(c2,\"(was:\" /*)*/ )) ||\n     (cp=strstr(c2,\"(was \" /*)*/ )) ||\n     (cp=strstr(c2,\"\u00ddwas \" /*)*/ )) ||\n     (cp=strstr(c2,\"\u00ddwas:\" /*)*/ ))) {\n   switch (*cp) {\n     case '(':  bracket = ')';  break;\n     case '\u00dd':  bracket = '\u00a8';  break;\n     default:   bracket = '\\0'; break;\n   }\n   c2 = skip_whitespace(cp+5);\n   if (!memcmp(c2,\"re:\",3)) c2 = skip_whitespace(c2+3);\n   if (!strcmp(c1,c2)) return TRUE;\n   cp = c2 + strlen(c2) - 1;\n   if (*cp == bracket) *cp = '\\0';\n   if (!strcmp(c1,c2)) return TRUE;\n }\n\n if (!strcmp(c1,c2)) return TRUE;\n\n return FALSE;\n\n}\n\n./ ADD NAME=NNMTSO\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n /********************************************************************/\n /*                                                                  */\n /* Thanks to Michael Van Norman for this code.                      */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@TSO  \")\n#pragma  csect(static,\"NN$TSO  \")\n#include \"nn.h\"\n\n#pragma linkage(ikjeftsr,OS)\n\n#define _IKJEFTSR_FLAGS_AUTH        0x00000000\n#define _IKJEFTSR_FLAGS_COMMAND     0x00000001\n#define _IKJEFTSR_FLAGS_DUMP        0x00000100\n#define _IKJEFTSR_FLAGS_NODUMP      0x00000000\n#define _IKJEFTSR_FLAGS_PROGRAM     0x00000002\n#define _IKJEFTSR_FLAGS_UNAUTH      0x00010000\n\n/****** Issue TSO command. *******************************************/\n\nint\nNNMtso(command)\nchar        *command;\n{\n int         flags         = _IKJEFTSR_FLAGS_COMMAND +\n                             _IKJEFTSR_FLAGS_UNAUTH;\n int         commandLength = strlen(command);\n int         rc            = 0;\n int         returnCode    = 0;\n int         reasonCode    = 0;\n int         abendCode     = 0;\n\n static int (*ikjeftsr)() = NULL;\n\n if (!ikjeftsr) {\n   /*\n   ikjeftsr = (int (*)())fetch(\"ikjeftsr\");\n   if (!ikjeftsr) {\n    */\n     /* #pragma linkage( tsoServiceFacility, OS )\n      * int (*tsoServiceFacility)( int *, char *, int *,\n      *                            int *, int *, int * );\n      */\n     int tsoEntryAddress;\n\n     tsoEntryAddress = 0x00000010;    /* Address of CVT */\n     tsoEntryAddress = *(int *)(tsoEntryAddress);\n     tsoEntryAddress += 0x9C;/*       /* Offset of TVT in CVT */\n     tsoEntryAddress = *(int *)(tsoEntryAddress);\n     tsoEntryAddress += 0x10;/*       /* TSVTASF-TSVT (from IKJTSVT) */\n     tsoEntryAddress = *(int *)(tsoEntryAddress);\n#ifndef SASC\n     ikjeftsr = (int (*)())(tsoEntryAddress);\n#else\n     ikjeftsr = (__ibmos int (*)())(tsoEntryAddress);\n#endif\n   /*\n   }\n   */\n }\n\n if (!ikjeftsr) {\n   fprintf(stderr,\n           \"Cannot execute TSO commands, can't fetch IKJEFTSR.\\n\");\n   return -2;\n }\n\n rc = (*ikjeftsr)(&flags, command, &commandLength,\n                          &returnCode, &reasonCode,\n                          (int *)((int)(&abendCode) | 0x80000000));\n\n if (rc != 0) {\n   if (rc > 4) {\n     fprintf(stderr,\"Command failed:%s\\n\",command);\n     if (rc == 20 && reasonCode == 40)\n          fprintf(stderr,\"Command was not found.\\n\");\n     else fprintf(stderr,\n             \"rc=%d,returncode=%d,reasoncode=%d,abendcode=%8.8x\\n\",\n             rc, returnCode, reasonCode, abendCode);\n   }\n   if (abendCode != 0) rc = -1;\n   else rc = returnCode;\n }\n\n return rc;\n}\n\n./ ADD NAME=NNMUNALC\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@UNALC\")\n#pragma  csect(static,\"NN$UNALC\")\n#include \"nn.h\"\n\n/****** Unallocate a data set. ***************************************/\n\nBool\nNNMunalc(ddname)\nchar         *ddname;\n{\n __S99parms   stuff99;   /* The manual has it wrong.  No \"struct\". */\n int          rc;\n TEXTUNIT    *tu \u00dd2\u00a8;\n TEXTUNIT     tu_ddn;\n TEXTUNIT     tu_una;\n\n if (!ddname ||\n     !*ddname) return TRUE;   /* if no ddname to free, do nothing */\n\n memset((char *)&stuff99,0,sizeof(__S99parms));\n\n stuff99.__S99RBLN   = 20;\n stuff99.__S99VERB   = S99VRBUN;\n stuff99.__S99FLAG1  = 0;\n stuff99.__S99ERROR  = 0;\n stuff99.__S99INFO   = 0;\n stuff99.__S99TXTPP  = tu;\n stuff99.__S99FLAG2  = 0;\n\n tu\u00dd0\u00a8 = &tu_ddn;\n tu\u00dd1\u00a8 = &tu_una;\n *(int *)&tu\u00dd1\u00a8 |= 0x80000000;\n\n tu_ddn.key     = DUNDDNAM;\n tu_ddn.num     = 1;\n tu_ddn.ent.len = strlen(ddname);\n copy_uppercase(tu_ddn.ent.prm,ddname);\n\n tu_una.key     = DUNUNALC;\n tu_una.num     = 0;\n\n rc = svc99(&stuff99);\n\n if (rc == 0) return TRUE;\n else if (stuff99.__S99ERROR == 0x0438) /* not freed, is not allocated*/\n         return TRUE;\n else {\n   NNMdfail(rc,&stuff99);\n   return FALSE;\n }\n}\n\n./ ADD NAME=NNMUPDT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@UPDT \")\n#pragma  csect(static,\"NN$UPDT \")\n#include \"nn.h\"\n\n/****** Update the screen as frequently as desired. ******************/\n\nvoid\nNNMupdt(np,cdp,screen)\nRstruc nncb           *np;\nstruct countdown      *cdp;\nchar                  *screen;\n{\n  int                  pct;\n  int                  barsize;\n  int                  l;\n  int                  timediff;\n  int                  h;\n  int                  m;\n  int                  s;\n  time_t               thistime;\n  char                 nnmbar\u00dd62\u00a8;\n  char                 nnmestm\u00dd9\u00a8;\n  char                 zhilite\u00dd9\u00a8;\n  char                 temp\u00dd8\u00a8;\n  char                 display_string\u00dd24\u00a8;\n\n  if (!cdp || !cdp->do_update || np->batch_mode) return;\n\n  time(&thistime);\n\n  if (cdp->done == 0) {\n    if (cdp->to_do == 0) return;\n    if (np->barchar == '\\0') {\n      (void)NNMivget(np,\"ZHILITE \",zhilite,sizeof(zhilite));\n      if (zhilite\u00dd0\u00a8 == 'Y') np->barchar = ' ';\n      else                   np->barchar = '@';\n    }\n    timediff = -1;                 /* don't display on initial call */\n    np->lasttime = thistime;\n    np->firstime = thistime;\n    memset(nnmestm,' ',sizeof(nnmestm));\n    (void)NNMivput(np, \"NNMESTM \", nnmestm, 0);\n  }\n  else {\n    timediff = (int)difftime(thistime, np->lasttime);\n  }\n\n  if (timediff >= np->updatefreq) {\n    memset(nnmbar,' ',sizeof(nnmbar));\n    nnmbar\u00dd0\u00a8 = '\u00ac';\n    if (cdp->to_do < 0) {\n      pct = 0;\n      barsize = 1;\n    }\n    else {\n      if (cdp->to_do < cdp->done) cdp->to_do = cdp->done;\n      pct = cdp->done * 100 / cdp->to_do;\n      barsize = pct * (sizeof(nnmbar) - 2) / 100 + 1;\n    }\n    memset(nnmbar+1, np->barchar, barsize-1);\n    nnmbar\u00ddbarsize++\u00a8 = '/';\n\n#if 1\n\n    /* This code adds the number of currently processed items to the  */\n    /* right of the bar until it won't fit anymore, then puts it      */\n    /* inside the bar.                                                */\n\n    l = sprintf(temp, \"%d\", cdp->done);\n    if (barsize + l < sizeof(nnmbar)) {\n      memcpy(&nnmbar\u00ddbarsize\u00a8, temp, l);\n    }\n    else {\n      memcpy(&nnmbar\u00ddbarsize-l-3\u00a8, temp, l);\n      if (np->barchar != ' ') {\n        nnmbar\u00ddbarsize-l-4\u00a8 = ' ';\n        nnmbar\u00ddbarsize-3\u00a8   = ' ';\n      }\n    }\n\n#else\n\n    /* This code adds the number of currently processed items to the  */\n    /* right of the bar until it will fit inside, then puts it there. */\n\n    l = sprintf(temp, \"%d\", cdp->done);\n    if (barsize - 4 < l + 2) {\n      memcpy(&nnmbar\u00ddbarsize\u00a8, temp, l);\n    }\n    else {\n      memcpy(&nnmbar\u00ddbarsize-l-3\u00a8, temp, l);\n      if (np->barchar != ' ') {\n        nnmbar\u00ddbarsize-l-4\u00a8 = ' ';\n        nnmbar\u00ddbarsize-3\u00a8   = ' ';\n      }\n    }\n\n#endif\n\n    (void)NNMivput(np, \"NNMBAR \",nnmbar,sizeof(nnmbar));\n\n    l = sprintf(temp, \"%d\", cdp->to_do);\n    (void)NNMivput(np, \"NNMCOUNT\", temp, l);\n\n    s = (cdp->to_do - cdp->done) * difftime(thistime, np->firstime)\n        / cdp->done;\n    if (s > 0) {\n      m = s / 60;  s = s % 60;\n      h = m / 60;  m = m % 60;\n      sprintf(nnmestm, \"%2.2d:%2.2d:%2.2d\", h, m, s);\n      (void)NNMivput(np, \"NNMESTM \", nnmestm, sizeof(nnmestm) - 1);\n    }\n\n    sprintf(display_string, \"DISPLAY PANEL(%s)\", screen);\n    (void)NNMispf(np, \"CONTROL DISPLAY LOCK\");\n    (void)NNMispf(np, display_string);\n    np->lasttime = thistime;\n  }\n\n  cdp->done++;\n\n  return;\n\n}\n\n./ ADD NAME=NNMVAR\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@VAR  \")\n#pragma  csect(static,\"NN$VAR  \")\n#include \"nn.h\"\n\n#define ROWCPY(A,B,C) {\\\n                       name_length = strlen(B); \\\n                       if (name_length > C) name_length = C; \\\n                       memcpy(&rowp\u00ddA\u00a8, B, name_length); \\\n                      }\n\nstruct ntdynarray {\n                   struct newsarticle    *article;\n                   VARK                 **sortvark;\n                   int                    number;\n                   char                   numstr \u00dd6\u00a8;\n                  };\n\n/****** Format screen line. ******************************************/\n\nstatic void\nformat_screen_line(ap,vp,ndp,wp)\nRstruc newsarticle    *ap;\nVARK                  *vp;\nRstruc ntdynarray     *ndp;\nVARK                 **wp;\n{\n ndp->sortvark = wp;\n ndp->article  = ap;\n ndp->number   = ap->number;\n sprintf(ndp->numstr, \"%5d\", ndp->number);\n if (ap->action == NO_ACTION) {\n  if (IsRead(*vp)) ap->action = READ;\n  else             ap->action = UNREAD;\n }\n return;\n}\n\n/****** View articles. ***********************************************/\n\nstatic Bool\nview_articles(np,gp,dynarray,nntdyna,depth,dynsize)\nRstruc nncb           *np;\nRstruc newsgroup      *gp;\nstruct ntdynarray     *dynarray;\nchar                  *nntdyna;\nint                    depth;\nint                    dynsize;\n{\n struct newsarticle   *ap;\n Rstruc ntdynarray    *ndp;\n Rstruc tabledesc     *tdp;\n Rstruc seldesc       *sdp;\n Rstruc cmddesc       *cdp;\n struct ntdynarray    *ntdynarray_start;\n struct ntdynarray    *ntdynarray_end;\n char                 *cp;\n char                 *rowp;\n char                 *act;\n VARK                 *vp;\n VARK                 *vpfirst;\n VARK                 *vplast;\n VARK                **wp;\n VARK                **wpfirst;\n VARK                **wplast;\n VARK                **save_top_sorted_article;\n int                   save_top_article;\n int                   display_total;\n int                   command_index;\n int                   prc;\n int                   nntlvl;\n int                   articles_per_screen;\n int                   scroll;\n int                   zscrolln;\n int                   rowincr;\n int                   rowbump;\n int                   actlen;\n int                   anum;\n int                   artcursor;\n int                   last_article_selected;\n short                 name_length;\n Bool                  is_max;\n Bool                  is_scroll_word;\n Bool                  rebuild_dynamic_array;\n Bool                  selection_processed_ok;\n Bool                  command_processed_ok;\n char                  aattr;\n char                  sel;\n struct countdown      cd;\n char                  tcmd        \u00dd72\u00a8;\n char                  nnthead     \u00dd81\u00a8;\n char                  nntcsr      \u00dd12\u00a8;\n char                  command      \u00ddCOMMANDSIZE\u00a8;\n char                  zverb        \u00dd9\u00a8;\n char                  zscrolla     \u00dd9\u00a8;\n char                  rowmessage  \u00dd81\u00a8;\n\n ntdynarray_start        = dynarray;\n rebuild_dynamic_array   = TRUE;\n scroll                  = 0;\n artcursor               = 0;\n last_article_selected   = -1;\n save_top_article        = 0;\n save_top_sorted_article = NULL;\n tdp = np->display_table_vector->article_display_table;\n strcpy(tcmd,\"\");\n strcpy(np->article_only_string,\"\");\n\n cd.do_update = (np->updatefreq >= 0);\n cd.done      = 0;\n cd.to_do     = -1;\n\n /* Loop displaying article titles until END. */\n\n do {\n\n  /* The very first time, all articles have a not-known-yet status.\n   * The normal article collections set knownness on the fly.\n   * When the article criterion changes (e.g. ONLY command),\n   * all articles are set to unknown.  This could also be done\n   * in processing for the ONLY command itself.\n   * If status has been changed (read->unread or vice versa),\n   * alter it here.  But do not change it if the status is read\n   * and the displayed status has been set to one of those\n   * funny values like \"Extracted\".\n   * This is needed because the newsgroup mark and unmark\n   * operations do not go through the ap actions.\n   */\n\n   if (np->article_criterion_changed) {\n     if (gp->sort_vector) (void)NNMsort(np,gp);\n     np->article_criterion_changed = FALSE;\n     rebuild_dynamic_array = TRUE;\n     if (gp->article_vector) {\n       vpfirst = &GETVARKFIRST(gp);\n       vplast  = &GETVARKLAST(gp);\n       for (vp = vpfirst; vp <= vplast; vp++) {\n         SetUnknown(*vp);\n         if (IsPresent(*vp) && (ap=VARK2PARTICLE(*vp))) {\n           if (IsRead(*vp)) {\n             if (ap->action == UNREAD\n              || ap->action == MISSING\n              || ap->action == ERROR\n              || ap->action == NO_ACTION) ap->action = READ;\n             else;\n           }\n           else ap->action = UNREAD;\n         }\n       }\n     }\n   } /* end if article criterion changed */\n\n   /*\n    * If necessary, rebuild the array of newsarticle pointers.\n    */\n\n   if (rebuild_dynamic_array) {\n     rebuild_dynamic_array = FALSE;\n     rowincr               = np->article_rows;\n     if (rowincr < 1) rowincr = 1;\n     rowbump               = 80 * rowincr;\n     articles_per_screen   = (depth-1)/rowincr + 1;\n     cd.do_update          = (np->updatefreq >= 0);\n     cd.done               = 0;\n     cd.to_do              = articles_per_screen;\n     if (cd.do_update && gp->article_vector\n                      && *np->article_only_string) {\n       cd.to_do = 0;\n       vpfirst = &GETVARKFIRST(gp);\n       vplast  = &GETVARKLAST(gp);\n       for (vp = vpfirst; vp <= vplast; vp++) {\n         if (IsNull(*vp))  cd.to_do++;\n       }\n     }\n     display_total         = articles_per_screen;\n     ndp                   = ntdynarray_start;\n\n     /* Process scroll, collecting (abs(scroll)) articles\n      * until the new top-of-display article is found.  Logic:\n      * If top article is logically past end, then OK.\n      * If top article is not eligible, move back up until we find\n      * an eligible one.\n      * If top article is first but still not eligible, move down\n      * until we find an eligible one.\n      * Then collect enough articles to fill the screen.\n      */\n\n     if (gp->sort_vector) {\n\n       wpfirst = gp->sort_vector;\n       wplast  = gp->sort_vector + gp->sort_count;\n\n       wp = np->top_sorted_article;\n\n       if (wp < wplast) {\n         for (; wp >= wpfirst; wp--)\n             if (NNMcar(np,gp,0,*wp,NULL,&cd,RETRIEVE)) break;\n       }\n\n       if (wp < wpfirst) {\n         for (wp = wpfirst; wp < wplast; wp++)\n             if (NNMcar(np,gp,0,*wp,NULL,&cd,RETRIEVE)) break;\n       }\n\n       if (scroll > 0) {\n         while (scroll > 0 && ++wp < wplast) {\n           if (NNMcar(np,gp,0,*wp,NULL,&cd,RETRIEVE)) scroll--;\n         }\n       }\n       else if (scroll < 0) {\n         while (scroll < 0 && --wp >= wpfirst) {\n           if (NNMcar(np,gp,0,*wp,NULL,&cd,RETRIEVE)) scroll++;\n         }\n         if (wp < wpfirst) wp = wpfirst;\n       }\n       np->top_sorted_article = wp;\n\n       for (; display_total > 0 && wp < wplast; wp++) {\n         if (NNMcar(np,gp,0,*wp,&ap,&cd,RETRIEVE)) {\n           format_screen_line(ap,*wp,ndp,wp);\n           display_total--;\n           ndp++;\n         }\n       }\n       ntdynarray_end = ndp;\n\n     }\n\n     else if (gp->article_vector) { /* not sorted */\n\n       anum = np->top_article;\n\n       if (anum <= gp->vector_last) {\n         for (; anum >= gp->vector_first; anum--)\n             if (NNMcar(np,gp,anum,NULL,NULL,&cd,RETRIEVE)) break;\n       }\n\n       if (anum < gp->vector_first) {\n         for (anum = gp->vector_first; anum <= gp->vector_last; anum++)\n             if (NNMcar(np,gp,anum,NULL,NULL,&cd,RETRIEVE)) break;\n       }\n\n       if (scroll > 0) {\n         while (scroll > 0 && ++anum <= gp->vector_last) {\n           if (NNMcar(np,gp,anum,NULL,NULL,&cd,RETRIEVE)) scroll--;\n         }\n       }\n       else if (scroll < 0) {\n         while (scroll < 0 && --anum >= gp->vector_first) {\n           if (NNMcar(np,gp,anum,NULL,NULL,&cd,RETRIEVE)) scroll++;\n         }\n         if (anum < gp->vector_first) anum = gp->vector_first;\n       }\n       np->top_article = anum;\n\n       for (; display_total > 0 && anum <= gp->vector_last; anum++) {\n         if (NNMcar(np,gp,anum,NULL,&ap,&cd,RETRIEVE)) {\n           vp = &GETVARK(gp,anum);\n           format_screen_line(ap,vp,ndp,NULL);\n           display_total--;\n           ndp++;\n         }\n       }\n       ntdynarray_end = ndp;\n\n     } /* end not sorted */\n\n     else { /* no article vector */\n\n       ntdynarray_end = ndp;\n       np->top_article = 0;\n\n     }\n\n   } /* end if rebuild_dynamic_array */\n\n   save_top_article = np->top_article;\n   save_top_sorted_article = np->top_sorted_article;\n   artcursor = 0;\n\n   /* Fill dynamic area with data for groups satisfying criterion. */\n\n   memset(nntdyna, ' ', dynsize);\n\n   for (ndp = ntdynarray_start, rowp = nntdyna;\n        ndp < ntdynarray_end;\n        ndp++) {\n     ap = ndp->article;\n     if (np->article_autocursor\n      && ndp->number == last_article_selected) {\n       artcursor = rowp + 2 - nntdyna;\n     }\n     rowp\u00dd 0\u00a8        = DATAIN_HIGH;     /* selection code attribute */\n     rowp\u00dd 1\u00a8        = ' ';             /* selection code field     */\n     rowp\u00dd 2\u00a8        = DATAOUT_BLUE;    /* article number attribute */\n     memcpy(&rowp\u00dd 3\u00a8, ndp->numstr, 5); /* article number           */\n     rowp\u00dd 8\u00a8        = DATAOUT_GREEN;   /* article title attribute  */\n     ROWCPY(9,ap->subject,60);          /* article title            */\n\n     switch (ap->action) {\n       case NO_ACTION: act = \"No action\"; aattr = DATAOUT_TURQ;   break;\n       case READ:      act = \"Read   \"  ; aattr = DATAOUT_BLUE;   break;\n       case RETRIEVED: act = \"Retrieved\"; aattr = DATAOUT_BLUE;   break;\n       case EXTRACTED: act = \"Extracted\"; aattr = DATAOUT_BLUE;   break;\n       case PRINTED:   act = \"Printed\"  ; aattr = DATAOUT_BLUE;   break;\n       case UNREAD:    act = \"Unread \"  ; aattr = DATAOUT_YELLOW; break;\n       case MISSING:   act = \"Missing\"  ; aattr = DATAOUT_TURQ;   break;\n       case ERROR:     act = \"Error  \"  ; aattr = DATAOUT_TURQ;   break;\n       case CANCELLED: act = \"Cancelled\"; aattr = DATAOUT_BLUE;   break;\n       default:        act = \"???????\"  , aattr = DATAOUT_TURQ;   break;\n     }\n     actlen = strlen(act);\n     memcpy(&rowp\u00dd68-actlen\u00a8,act,actlen);\n     rowp\u00dd68-actlen-1\u00a8 = aattr;\n\n     if (rowincr == 1) {\n       rowp\u00dd68\u00a8 = DATAOUT_GREEN;           /* article date attribute */\n       ROWCPY(69,ap->date,11);                      /* article date  */\n     }\n     else {\n       memset(&rowp\u00dd68\u00a8,' ',12);\n     }\n\n     if ((rowp+=80) >= nntdyna + dynsize) break;\n     if (rowincr >= 2) {\n       rowp\u00dd0\u00a8 = DATAOUT_GREEN;          /* article author attribute */\n       ROWCPY(9,ap->from,58);                    /* article author   */\n       rowp\u00dd59\u00a8 = DATAOUT_GREEN;           /* article date attribute */\n       ROWCPY(60,ap->date,20);                      /* article date  */\n       if ((rowp+=80) >= nntdyna + dynsize) break;\n       if (rowincr >= 3) {\n         rowp\u00dd0\u00a8 = DATAOUT_BLUE;\n         ROWCPY(9,ap->message_id,70);\n         if ((rowp+=80) >= nntdyna + dynsize) break;\n       }\n     }\n   } /* end for */\n\n   if (rowp < nntdyna + dynsize) {\n     rowp\u00dd0\u00a8 = DATAOUT_HIGH;\n     memset(&rowp\u00dd1\u00a8, '-',79);\n   }\n\n /* Format the heading line for the title display.\n  * Row message is \"Range mmmm-nnnn\", not \"m-n of p\", because\n  * we don't always know if we can get to all the articles.\n  */\n\n   if (!gp->article_vector) strcpy(rowmessage, \"\");\n   else sprintf(rowmessage, \" Range %d-%d\",\n                            gp->vector_first, gp->vector_last);\n\n   memset(nnthead, '-', 80);\n   *(nnthead+80) = '\\0';\n   strcpy(nnthead, \"Newsgroup: \");\n   name_length = strlen(gp->name);\n   if (name_length > 40) name_length = 40;\n   strncat(nnthead, gp->name, name_length);\n   *(strchr(nnthead,'\\0')) = ' ';\n   strcpy(nnthead + 79 - strlen(rowmessage), rowmessage);\n\n   if (artcursor > 0) {\n     sprintf(nntcsr,\"%d\",artcursor);\n     (void)NNMivput(np,\"NNTCSR \", nntcsr, -1);\n   }\n   else {\n     (void)NNMivput(np,\"NNTCSR \", \"0\", 1);\n   }\n\n   (void)NNMivput(np,\"NNTCMD \" , tcmd,    -1);\n   (void)NNMivput(np,\"NNTHEAD \", nnthead, -1);\n   (void)NNMivput(np,\"NNTDYNA \", nntdyna, dynsize);\n   (void)NNMivput(np,\"YRFIND \"  ,\"ALIAS FIND\",-1);\n\n   prc = NNMdispl(np,\"NNMDAR  \");\n   if (prc > 8) break;\n\n   (void)NNMivput(np,\"YRFIND \"  ,\"\",-1);\n   (void)NNMivget(np,\"NNTDYNA \" , nntdyna,  dynsize);\n   (void)NNMivget(np,\"ZVERB \"   , zverb,    sizeof(zverb));\n   (void)NNMivget(np,\"ZSCROLLA \", zscrolla, sizeof(zscrolla));\n   zscrolln = NNMiget(np,\"ZSCROLLN \");\n   nntlvl   = NNMiget(np,\"NNTLVL \");\n   scroll   = 0;\n\n   /* Process selections. */\n\n   save_top_article = np->top_article;\n   save_top_sorted_article = np->top_sorted_article;\n   np->top_article = 0;\n   np->top_sorted_article = NULL;\n   last_article_selected = -1;\n\n   for (ndp = ntdynarray_start, rowp = nntdyna;\n        ndp < ntdynarray_end && !np->quit;\n        ndp++,                  rowp += rowbump) {\n     sel = toupper(rowp\u00dd1\u00a8);\n     if (sel == ' ') continue;\n     for (sdp = tdp->first_seldesc; sdp->selection_code != ' '; sdp++) {\n       if (sel == sdp->selection_code) {\n         ap = ndp->article;\n         np->current_sortvark = ndp->sortvark;\n         selection_processed_ok = (sdp->selection_processor)(np,ap);\n         last_article_selected = ap->number;\n         sdp = NULL;\n         break;\n       }\n     }\n     if (sdp) {\n       ERR1(\"Unknown selection code.  Type one of the listed codes.\");\n       selection_processed_ok = FALSE;\n     }\n   }\n\n   if (np->quit) break;\n\n   if (np->top_article != 0 && np->article_autocursor)\n       last_article_selected = np->top_article;\n   if (np->top_article == 0 || !np->article_autoscroll)\n       np->top_article = save_top_article;\n   if (np->top_sorted_article == NULL || !np->article_autoscroll)\n       np->top_sorted_article = save_top_sorted_article;\n\n   /* Process command if any. */\n\n   strcpy(tcmd,\"\");\n\n   (void)NNMivget(np,tdp->command_variable,tcmd,sizeof(tcmd));\n\n   if (strcmp(tcmd,\"\") != 0) {\n\n     last_article_selected = -1;\n     memset(command,' ',COMMANDSIZE);\n     command_index = 0;\n     for (cp = tcmd; *cp && !isspace(*cp); cp++) {\n       if (cp >= tcmd+COMMANDSIZE) {\n         ERR1(\"Unknown command name.\");\n         command_processed_ok = FALSE;\n       }\n       command\u00ddcommand_index++\u00a8 = toupper(*cp);\n     }\n     while (*cp && isspace(*cp)) cp++;\n\n     for (cdp = tdp->first_cmddesc; *cdp->command_name != ' '; cdp++) {\n       if (!memcmp(command,cdp->command_name,COMMANDSIZE-1)) {\n         command_processed_ok = (cdp->command_processor)(np,gp,cp);\n         cdp = NULL;\n         break;\n       }\n     }\n     if (cdp) {\n       for (cdp=tdp->next_cmddesc; *cdp->command_name != ' '; cdp++) {\n         if (!memcmp(command,cdp->command_name,COMMANDSIZE-1)) {\n           command_processed_ok = (cdp->command_processor)(np,gp,cp);\n           cdp = NULL;\n           break;\n         }\n       }\n     }\n     if (cdp) {\n       ERR1(\"Unknown command name.\");\n       command_processed_ok = FALSE;\n     }\n\n     if (command_processed_ok) strcpy(tcmd,\"\");\n\n   }\n\n   if (np->quit) break;\n\n   if (np->top_article != save_top_article\n    || np->top_sorted_article != save_top_sorted_article)\n       rebuild_dynamic_array = TRUE;\n\n   /* Process scroll request if any. */\n\n   switch (zscrolla\u00dd0\u00a8) {\n     case 'P':\n     case 'H':\n     case 'C':\n     case 'D':  is_max = FALSE;\n                is_scroll_word = TRUE;\n                break;\n     case 'M':  is_max = TRUE;\n                break;\n     default:   is_max = FALSE;\n                is_scroll_word = FALSE;\n                break;\n   }\n\n   if      (EQUAL(zverb,\"DOWN\")) {\n     if (is_max)         {\n                          np->top_article = gp->vector_last;\n                          np->top_sorted_article = wplast - 1;\n                          scroll = -((nntlvl-1)/np->article_rows);\n                         }\n     else\n     if (is_scroll_word)  scroll = zscrolln/rowincr;\n     else                 scroll = zscrolln;\n   }\n   else if (EQUAL(zverb,\"UP\")) {\n     if (is_max)         {\n                          np->top_article = gp->vector_first;\n                          np->top_sorted_article = wpfirst;\n                          scroll = 0;\n                          rebuild_dynamic_array = TRUE;\n                         }\n     else\n     if (is_scroll_word)  scroll = -zscrolln/rowincr;\n     else                 scroll = -zscrolln;\n   }\n   else scroll = 0;\n\n   if (scroll != 0) rebuild_dynamic_array = TRUE;\n\n } while (prc == 0);\n\n return TRUE;\n\n}\n\n/****** View articles. ***********************************************/\n\nBool\nNNMvar(np,gp)\nRstruc nncb           *np;\nRstruc newsgroup      *gp;\n{\n struct ntdynarray    *dynarray;\n char                 *nntdyna;\n int                   depth;\n int                   dynsize;\n\n /* Get depth of dynamic area (number of rows to display on screen) */\n\n (void)NNMispf(np,\n       \"PQUERY PANEL(NNMDAR) AREANAME(NNTDYNA) DEPTH(NNTDEPTH)\");\n if (np->ispfrc != 0) return FALSE;\n depth = NNMiget(np,\"NNTDEPTH \");\n\n /* Allocate a block of \"ntdynarray\" article pointers, one element\n  * for each article currently being displayed.  This must be big\n  * enough to fill up the screen.  It is rebuilt every time the\n  * display changes, through scrolling or selection activity.\n  */\n\n GETMAIN(dynarray, struct ntdynarray, depth,\n         \"newsarticle dynamic array\");\n if (!dynarray) return FALSE;\n\n /* Get storage for ISPF dynamic area variable to be constructed. */\n\n dynsize = 80*depth;\n GETMAIN(nntdyna, char, dynsize+1, \"NNTDYNA buffer\");\n if (!nntdyna) return FALSE;\n\n np->top_article               = 0;\n np->top_sorted_article        = NULL;\n np->repeat_find               = FALSE;\n np->article_criterion_changed = TRUE;\n *np->selsubj                  = '\\0';\n\n if (!view_articles(np,gp,dynarray,nntdyna,depth,dynsize)) return FALSE;\n\n FREEMAIN(nntdyna,\"NNTDYNA buffer\");\n FREEMAIN(dynarray,\"newsarticle dynamic area\");\n\n return TRUE;\n\n}\n./ ADD NAME=NNMVIEW\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@VIEW \")\n#pragma  csect(static,\"NN$VIEW \")\n#include \"nn.h\"\n\nstruct browser {\n   struct newsgroup     *gp;\n   struct newsarticle   *ap;\n   struct texthdr       *thp;            /* text header pointer      */\n   struct textline     **tv;             /* text vector              */\n               char     *bda;            /* dynamic area address     */\n               char     *work;           /* find work area address   */\n               char     *firstpos;       /* beginning of actual data */\n               char     *lastpos;        /* end of actual data       */\n               int       depth;          /* dynamic area depth       */\n               int       lvl;            /* last visible line        */\n               int       size;           /* dynamic area size        */\n               int       more_rows;      /* Scroll request row count */\n               int       rowfactor;      /* # physical rows per line */\n               int       screenbump;     /* # physical rows * width  */\n               int       top;            /* top row number           */\n               int       total;          /* total number of rows     */\n               int       coloff;         /* offset from LEFT/RIGHT   */\n               int       cols;           /* 1 if COLS done, else 0   */\n               int       maxlen;         /* maximum text length      */\n               int       maxcoloff;      /* maximum right scroll     */\n               Bool      override_scroll;/* set by some commands     */\n               Bool      highlighted;    /* set if FIND highlights   */\n               Bool      reinit_browse;  /* set if text changed      */\n               Bool      exit_browse;    /* set if browse must exit  */\n               Bool      find_hit_end;   /* top/bottom of data reach */\n               int       find_count;     /* used by FIND ALL         */\n               int       find_row;       /* row where last found     */\n               int       find_col;       /* col where last found     */\n               int       found_row;      /* row where last found     */\n               int       found_col;      /* col where last found     */\n               int       csrpos;         /* cursor position          */\n               int       find_csrpos;    /* col where last found     */\n               int       found_left;     /* pos left of found string */\n               int       found_right;    /* pos right of found string*/\n               char      cursor     \u00dd9\u00a8; /* cursor field name        */\n               char      find_cursor\u00dd9\u00a8; /* row where last found     */\n               char      title     \u00dd81\u00a8; /* title                    */\n               char      cols_line \u00dd81\u00a8; /* cols line                */\n               char      zcmd      \u00dd81\u00a8; /* command input            */\n              };\n\n/******* torot13 ******************************************************/\n\nstatic char\ntorot13(c)\nchar    c;\n{\n char   d;\n if (!isalpha(c)) d = c;\n else switch (c) {\n   case 'a':   d = 'n'; break;\n   case 'b':   d = 'o'; break;\n   case 'c':   d = 'p'; break;\n   case 'd':   d = 'q'; break;\n   case 'e':   d = 'r'; break;\n   case 'f':   d = 's'; break;\n   case 'g':   d = 't'; break;\n   case 'h':   d = 'u'; break;\n   case 'i':   d = 'v'; break;\n   case 'j':   d = 'w'; break;\n   case 'k':   d = 'x'; break;\n   case 'l':   d = 'y'; break;\n   case 'm':   d = 'z'; break;\n   case 'n':   d = 'a'; break;\n   case 'o':   d = 'b'; break;\n   case 'p':   d = 'c'; break;\n   case 'q':   d = 'd'; break;\n   case 'r':   d = 'e'; break;\n   case 's':   d = 'f'; break;\n   case 't':   d = 'g'; break;\n   case 'u':   d = 'h'; break;\n   case 'v':   d = 'i'; break;\n   case 'w':   d = 'j'; break;\n   case 'x':   d = 'k'; break;\n   case 'y':   d = 'l'; break;\n   case 'z':   d = 'm'; break;\n   case 'A':   d = 'N'; break;\n   case 'B':   d = 'O'; break;\n   case 'C':   d = 'P'; break;\n   case 'D':   d = 'Q'; break;\n   case 'E':   d = 'R'; break;\n   case 'F':   d = 'S'; break;\n   case 'G':   d = 'T'; break;\n   case 'H':   d = 'U'; break;\n   case 'I':   d = 'V'; break;\n   case 'J':   d = 'W'; break;\n   case 'K':   d = 'X'; break;\n   case 'L':   d = 'Y'; break;\n   case 'M':   d = 'Z'; break;\n   case 'N':   d = 'A'; break;\n   case 'O':   d = 'B'; break;\n   case 'P':   d = 'C'; break;\n   case 'Q':   d = 'D'; break;\n   case 'R':   d = 'E'; break;\n   case 'S':   d = 'F'; break;\n   case 'T':   d = 'G'; break;\n   case 'U':   d = 'H'; break;\n   case 'V':   d = 'I'; break;\n   case 'W':   d = 'J'; break;\n   case 'X':   d = 'K'; break;\n   case 'Y':   d = 'L'; break;\n   case 'Z':   d = 'M'; break;\n }\n\n return d;\n}\n\n/******* EXTRACT command **********************************************/\n\nstatic Bool\nprocess_extract_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n Rstruc newsarticle *ap = bp->ap;\n\n if (!ap) (void)NNMivput(np,\"NNTNUM \",\"\",-1);\n np->extract_file = NULL;\n np->printing     = FALSE;\n (void)NNMispf(np,\"CONTROL DISPLAY SAVE\");\n (void)NNMxtx(np,ap,TRUE);                   /* Extract text */\n (void)NNMispf(np,\"CONTROL DISPLAY RESTORE\");\n\n return TRUE;\n}\n\n/******* PRINT command ************************************************/\n\nstatic Bool\nprocess_print_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n Rstruc newsarticle *ap = bp->ap;\n\n if (!ap) (void)NNMivput(np,\"NNTNUM \",\"\",-1);\n np->extract_file = NULL;\n np->printing     = TRUE;\n (void)NNMispf(np,\"CONTROL DISPLAY SAVE\");\n (void)NNMxtx(np,ap,TRUE);                   /* Print text */\n (void)NNMispf(np,\"CONTROL DISPLAY RESTORE\");\n\n return TRUE;\n}\n\n/******* UNREAD command ***********************************************/\n\nstatic Bool\nprocess_unread_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = UNREAD_THIS_ARTICLE;\n bp->exit_browse = TRUE;\n\n return TRUE;\n}\n\n/******* ROT13 command ************************************************/\n\nstatic Bool\nprocess_rot13_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n struct textline    *tp;\n char               *cp;\n char               *cpe;\n\n for (tp=bp->thp->text_body_line; tp; tp=tp->next) {\n   for (cp=tp->tab_expanded_text, cpe=cp+tp->tab_expanded_text_length;\n        cp < cpe;\n        cp++) {\n     *cp = torot13(*cp);\n   }\n }\n\n bp->reinit_browse = TRUE;\n\n return TRUE;\n}\n\n/******* REPLY command ************************************************/\n\nstatic Bool\nprocess_reply_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n (void)NNMispf(np,\"CONTROL DISPLAY SAVE\");\n NNMdmail(np,bp->gp,bp->ap);       /* Send mail message */\n (void)NNMispf(np,\"CONTROL DISPLAY RESTORE\");\n return TRUE;\n}\n\n/******* FOLLOWUP command *********************************************/\n\nstatic Bool\nprocess_followup_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n (void)NNMispf(np,\"CONTROL DISPLAY SAVE\");\n NNMdpost(np,bp->gp,bp->ap);       /* Post followup */\n (void)NNMispf(np,\"CONTROL DISPLAY RESTORE\");\n return TRUE;\n}\n\n/******* NEXT command *************************************************/\n\nstatic Bool\nprocess_next_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = NEXT_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* PREV command *************************************************/\n\nstatic Bool\nprocess_prev_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = PREV_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* NEXTU command ************************************************/\n\nstatic Bool\nprocess_nextu_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = NEXT_UNREAD_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* PREVU command ************************************************/\n\nstatic Bool\nprocess_prevu_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = PREV_UNREAD_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* NEXTT command ************************************************/\n\nstatic Bool\nprocess_nextt_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = NEXT_TABLED_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* PREVT command ************************************************/\n\nstatic Bool\nprocess_prevt_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = PREV_TABLED_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* NEXTSUBJ command *********************************************/\n\nstatic Bool\nprocess_nextsubj_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = NEXT_THREAD_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* PREVSUBJ command *********************************************/\n\nstatic Bool\nprocess_prevsubj_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = PREV_THREAD_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* FIRSTSUBJ command ********************************************/\n\nstatic Bool\nprocess_firstsubj_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = FIRST_THREAD_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* LASTSUBJ command *********************************************/\n\nstatic Bool\nprocess_lastsubj_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = LAST_THREAD_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* NEWSUBJ command **********************************************/\n\nstatic Bool\nprocess_newsubj_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n np->another_article = NEW_THREAD_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* SUBJECT command **********************************************/\n\nstatic Bool\nprocess_subject_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n /* If anything remaining on the command line, make it the new    */\n /* subject, otherwise just display the current subject.          */\n\n if (*operands) {\n   memset(np->selsubj,0,sizeof(np->selsubj));\n   strncpy(np->selsubj,operands,sizeof(np->selsubj)-1);\n WARN1(\n  \"Subject changed.  All subject searches will use the new subject.\");\n }\n else if (!*np->selsubj) {\n   WARN1(\n    \"No current subject has been set by a subject-related command.\");\n }\n else {\n   WARN2(\"Current subject: %s\", np->selsubj);\n }\n return TRUE;\n}\n\n/******* OPTIONS command **********************************************/\n\nstatic Bool\nprocess_options_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n NNMdsopt(np,operands);         /* Do \"set options\" function */\n np->another_article = REDISPLAY_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n/******* HEADERS command **********************************************/\n\nstatic Bool\nprocess_headers_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n NNMdsopt(np,\"1\");              /* Do \"set options 1\" function */\n np->another_article = REDISPLAY_ARTICLE;\n bp->exit_browse = TRUE;\n return TRUE;\n}\n\n\n/******* COLS command *************************************************/\n\nstatic Bool\nprocess_cols_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n bp->cols = 1;\n *bp->cols_line = '\\0';\n bp->reinit_browse = TRUE;\n return TRUE;\n}\n\n/******* RESET command ************************************************/\n\nstatic Bool\nprocess_reset_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n\n bp->cols = 0;\n *bp->cols_line = '\\0';\n bp->reinit_browse = TRUE;\n return TRUE;\n}\n\n/******* DISPLAY command **********************************************/\n\nstatic Bool\nprocess_display_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n unsigned int        u;\n\n switch (strlen(operands)) {\n   case 1: np->text_dispchar = operands\u00dd0\u00a8;\n           break;\n   case 2: if (1 != sscanf(operands,\"%x\",&u)) {\n             ERR1(\"Invalid hex character representation.\");\n             return FALSE;\n           }\n           np->text_dispchar = u;\n           break;\n   default:\n           ERR1(\"A single character must be specified.\");\n           return FALSE;\n }\n bp->reinit_browse = TRUE;\n return TRUE;\n}\n\n/******* LOCATE command ***********************************************/\n\nstatic Bool\nprocess_locate_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n int                 locnum;\n char                junk\u00dd72\u00a8;\n\n if (1 != sscanf(operands, \"%d %s\", &locnum, junk)) {\n   ERR1(\"The LOCATE command requires a line number.\");\n   return FALSE;\n }\n\n bp->top = locnum;\n bp->more_rows = 0;\n bp->override_scroll = TRUE;\n bp->reinit_browse = TRUE;\n return TRUE;\n}\n\n/***** Helper functions for FIND **************************************/\n\n/*--------------------------------------------------------------------*\n * Get quoted FIND string.                                            *\n *--------------------------------------------------------------------*/\n\nstatic char *\nget_quoted_find_string(np,cp,qform)\nRstruc nncb         *np;\nchar                *cp;\nchar                *qform;\n{\n char                quote     = *cp;\n char                termchar  = '\\0';\n\n for (cp++;;cp++) {\n   if (*cp == quote) {\n     switch (*(cp+1)) {\n       case '\\0':\n       case ' ':  termchar = '\\0'; break;\n       case 'c':\n       case 'C':  termchar = 'C' ; break;\n       case 't':\n       case 'T':  termchar = 'T' ; break;\n       case 'x':\n       case 'X':  termchar = 'X' ; break;\n       case 'p':\n       case 'P':  termchar = 'P' ; break;\n       default:   continue;\n     }\n     if (termchar) {\n       switch (*(cp+2)) {\n         case '\\0':\n         case ' ':  break;\n         default:   continue;\n       }\n       if (*qform != FIND_QUOTED) {\n         ERR1(\n      \"Invalid string; Do not surround a quoted string with letters.\");\n         *qform = FIND_BADFORM;\n         return NULL;\n       }\n       else {\n         switch (termchar) {\n           case 'C': *qform = FIND_C; break;\n           case 'T': *qform = FIND_T; break;\n           case 'X': *qform = FIND_X; break;\n           case 'P': *qform = FIND_P; break;\n         }\n         *cp = '\\0'; /* kill the quote because it's the character */\n         cp++;       /* that the caller will kill, not the quote  */\n       }\n     }\n     break;\n   }\n   else if (!*cp) {\n     ERR1(\n     \"Missing quote; The FIND command requires balanced quote marks.\");\n     *qform = FIND_BADFORM;\n     return NULL;\n   }\n }\n return cp;\n}\n\n/*--------------------------------------------------------------------*\n * Get FIND operand.                                                  *\n *--------------------------------------------------------------------*/\n\nstatic char *\nget_find_operand(np,opp,qform)\nRstruc nncb     *np;\nchar           **opp;\nchar            *qform;\n{\n char           *cp    = *opp;\n char           *start = NULL;\n\n cp = skip_ISPF_whitespace(cp);\n\n if (!*cp) return NULL;\n if (*cp == '\\'' || *cp == '\"') {\n   start = cp+1;\n   *qform = FIND_QUOTED;\n   if (!(cp = get_quoted_find_string(np,cp,qform))) return NULL;\n }\n else if ((*(cp+1) == '\\'' || *(cp+1) == '\"')) {\n   switch (*cp) {\n     case 'c':\n     case 'C': *qform = FIND_C; break;\n     case 't':\n     case 'T': *qform = FIND_T; break;\n     case 'x':\n     case 'X': *qform = FIND_X; break;\n     case 'p':\n     case 'P': *qform = FIND_P; break;\n     default:  *qform = FIND_UNQUOTED; break;\n   }\n   if (*qform != FIND_UNQUOTED) {\n     cp++;\n     start = cp+1;\n     if (!(cp = get_quoted_find_string(np,cp,qform))) return NULL;\n   }\n   else {\n     start = cp;\n     find_ISPF_whitespace(cp,start);\n   }\n }\n else {\n   start = cp;\n   *qform = FIND_UNQUOTED;\n   find_ISPF_whitespace(cp,start);\n }\n if (*cp) {\n   *cp  = '\\0';\n   *opp = cp+1;\n }\n else {\n   *opp = cp;\n }\n return start;\n}\n\n/*--------------------------------------------------------------------*\n * Find it.                                                           *\n *--------------------------------------------------------------------*/\n\n#define REND                 (r+(*tpp)->tab_expanded_text_length)\n#define PRECEDED_BY_VERBIAGE (q>r && isalnum(*(q-1)))\n#define FOLLOWED_BY_VERBIAGE (q+findlen<REND && isalnum(*(q+findlen)))\n\nstatic Bool\nfind_it(np,bp,find_string,findlen,\n                          find_type,find_what,find_trans,\n                          find_left_bound,find_right_bound)\nRstruc nncb       *np;\nRstruc browser    *bp;\nchar              *find_string;\nint                findlen;\nchar               find_type;      /* chars word prefix suffix */\nchar               find_what;      /* next prev first last all */\nchar               find_trans;     /* caps asis generic        */\nint                find_left_bound;\nint                find_right_bound;\n{\n struct textline **tpp;\n char             *p;\n char             *q;\n char             *r;\n int               row;\n int               col;\n int               complen;\n int               lcol;\n int               rcol;\n int               ecol;\n Bool              backward_find;\n\n lcol = find_left_bound - 1;\n rcol = find_right_bound - 1;\n row  = bp->find_row;\n col  = bp->find_col;\n\n switch (find_what) {\n   case FIND_NEXT:\n                    if (bp->find_hit_end) {\n                      bp->find_hit_end = FALSE;\n                      row = 0;\n                      col = lcol;\n                    }\n                    else if (EQUAL(bp->find_cursor,\"NNBDYNA\")) {\n                      row = bp->top+((bp->find_csrpos-1)/80)-bp->cols-1;\n                      col = (bp->find_csrpos-1) % 80 + bp->coloff;\n                      if (++col >= bp->maxlen) {\n                        row++;\n                        col = lcol;\n                      }\n                    }\n                    else {\n                      row = bp->top - 1;\n                      if (row < 0) row = 0;\n                      col = lcol;\n                    }\n                    backward_find = FALSE;\n                    break;\n   case FIND_PREV:\n                    if (bp->find_hit_end) {\n                      bp->find_hit_end = FALSE;\n                      row = bp->total - 1;\n                      col = rcol;\n                    }\n                    else if (EQUAL(bp->find_cursor,\"NNBDYNA\")) {\n                      row = bp->top+((bp->find_csrpos-1)/80)-bp->cols-1;\n                      col = (bp->find_csrpos-1) % 80 + bp->coloff;\n                      if (--col < 0) {\n                        row--;\n                        col = rcol;\n                      }\n                    }\n                    else {\n                      row = bp->total - 1;\n                      col = rcol;\n                    }\n                    backward_find = TRUE;\n                    break;\n   case FIND_FIRST:\n                    if (bp->find_hit_end) {\n                      bp->find_hit_end = FALSE;\n                    }\n                    row = 0;\n                    col = lcol;\n                    backward_find = FALSE;\n                    break;\n   case FIND_LAST:\n                    if (bp->find_hit_end) {\n                      bp->find_hit_end = FALSE;\n                    }\n                    row = bp->total - 1;\n                    col = rcol;\n                    backward_find = TRUE;\n                    break;\n   case FIND_ALL:\n                    col++;\n                    backward_find = FALSE;\n                    break;\n }\n\n if (backward_find == FALSE) {\n   /* forward find */\n   if (col < lcol) col = lcol;\n   else if (col > rcol) {\n     col = lcol;\n     row++;\n   }\n   for (tpp = &bp->tv\u00ddrow\u00a8; row < bp->total; tpp++, col=lcol, row++) {\n     ecol = (*tpp)->tab_expanded_text_length - 1;\n     if (ecol > rcol) ecol = rcol;\n     if (col > ecol) continue;\n     p = (*tpp)->tab_expanded_text;\n     if (find_trans == FIND_CAPS) {\n       copy_uppercase(bp->work,p);\n       r = bp->work;\n     }\n     else r = p;\n     complen = ecol-col+1;\n     for (q = r + col;;q++) {\n       q = memchr(q,find_string\u00dd0\u00a8,complen);\n       if (!q) break;\n       col = q - r;\n       complen = ecol-col+1;\n       if (complen < findlen) break;\n       if (!memcmp(q,find_string,findlen)) {\n         switch (find_type) {\n           case FIND_CHARS:  break;\n           case FIND_WORD:\n                if (PRECEDED_BY_VERBIAGE || FOLLOWED_BY_VERBIAGE)\n                    continue;\n                break;\n           case FIND_PREFIX:\n                if (PRECEDED_BY_VERBIAGE || !FOLLOWED_BY_VERBIAGE)\n                    continue;\n                break;\n           case FIND_SUFFIX:\n                if (!PRECEDED_BY_VERBIAGE || FOLLOWED_BY_VERBIAGE)\n                   continue;\n                break;\n         }\n         bp->find_row = row;\n         bp->find_col = col;\n         return TRUE;\n       }\n     }\n   }\n   bp->find_row = 0;\n   bp->find_col = 0;\n   bp->find_hit_end = TRUE;\n   return FALSE;\n }\n else {\n   /* backward find */\n   if (row >= bp->total) row = bp->total - 1;\n   if (col > rcol-findlen+1) col = rcol-findlen+1;\n   else if (col < lcol) {\n     col = rcol-findlen+1;\n     row--;\n   }\n   for (tpp=&bp->tv\u00ddrow\u00a8; row >= 0; tpp--, col=rcol-findlen+1, row--) {\n     ecol = (*tpp)->tab_expanded_text_length - 1;\n     if (ecol > rcol) ecol = rcol;\n     if (col > ecol) col = ecol;\n     p = (*tpp)->tab_expanded_text;\n     if (find_trans == FIND_CAPS) {\n       copy_uppercase(bp->work,p);\n       r = bp->work;\n     }\n     else r = p;\n     for (q = r + col; q >= r; q--) {\n       if (!memcmp(q,find_string,findlen)) {\n         switch (find_type) {\n           case FIND_CHARS:  break;\n           case FIND_WORD:\n                if (PRECEDED_BY_VERBIAGE || FOLLOWED_BY_VERBIAGE)\n                    continue;\n                break;\n           case FIND_PREFIX:\n                if (PRECEDED_BY_VERBIAGE || !FOLLOWED_BY_VERBIAGE)\n                    continue;\n                break;\n           case FIND_SUFFIX:\n                if (!PRECEDED_BY_VERBIAGE || FOLLOWED_BY_VERBIAGE)\n                   continue;\n                break;\n         }\n         col = q - r;\n         bp->find_row = row;\n         bp->find_col = col;\n         return TRUE;\n       }\n     }\n   }\n   bp->find_row = bp->total - 1;\n   bp->find_col = bp->maxlen;\n   bp->find_hit_end = TRUE;\n   return FALSE;\n }\n\n}\n\n/********* FIND command ***********************************************/\n\nstatic Bool\nprocess_find_command(np,bp,operands)\nRstruc nncb         *np;\nRstruc browser      *bp;\nchar                *operands;\n{\n char        *find_operand \u00dd64\u00a8;\n char        *show_type;\n char        *cp;\n char        *opcopy;\n char        *op;\n char        *p;\n char        *q;\n char         find_qform   \u00dd64\u00a8;\n Bool         finderror = FALSE;\n Bool         out_of_bounds = FALSE;\n int          find_operand_count;\n int          ox;\n int          find_left_bound;\n int          find_right_bound;\n int          n;\n int          len;\n int          findlen;\n char         find_what;      /* next prev first last all */\n char         find_type;      /* chars word prefix suffix */\n char         find_trans;     /* caps asis generic        */\n char         find_form;      /* unquoted quoted c x t p  */\n char         ff;             /* unquoted quoted c x t p  */\n Bool         hit_end                = FALSE;\n Bool         find_string_given      = FALSE;\n Bool         find_what_given        = FALSE;\n Bool         find_type_given        = FALSE;\n Bool         find_left_bound_given  = FALSE;\n Bool         find_right_bound_given = FALSE;\n char         operand_copy \u00dd81\u00a8;\n char         find_string  \u00dd81\u00a8;\n char         temp         \u00dd81\u00a8;\n char         show_string \u00dd129\u00a8;\n char         shortmsg    \u00dd129\u00a8;\n char         longmsg     \u00dd129\u00a8;\n\n strcpy(operand_copy,operands);\n\n find_operand_count = 0;\n for (ox = 0, opcopy = operand_copy; ox < 64; ox++) {\n   ff = FIND_UNQUOTED;\n   op = get_find_operand(np,&opcopy,&ff);\n   if (ff == FIND_BADFORM) return FALSE;\n   if (!op) break;\n   find_operand\u00ddox\u00a8 = op;\n   find_qform\u00ddox\u00a8 = ff;\n   find_operand_count++;\n }\n\n if (find_operand_count == 0) {\n   if (!*np->text_find_string) {\n     ERR1(\"The first FIND command requires an operand.\");\n     return FALSE;\n   }\n   strcpy(find_string,np->text_find_string);\n   find_what        = np->text_find_what;\n   find_type        = np->text_find_type;\n   find_trans       = np->text_find_trans;\n   find_left_bound  = np->text_find_left_bound;\n   find_right_bound = np->text_find_right_bound;\n }\n else {\n   find_what        = FIND_NEXT;\n   find_type        = FIND_CHARS;\n   find_trans       = FIND_CAPS;\n   find_left_bound  = 1;\n   find_right_bound = bp->maxlen;\n   for (ox = 0; ox < find_operand_count; ox++) {\n     op = find_operand\u00ddox\u00a8;\n     ff = find_qform\u00ddox\u00a8;\n     if (ff != FIND_UNQUOTED) {\n       if (find_string_given) finderror = TRUE;\n       else {\n         strcpy(find_string,op);\n         find_form = ff;\n         find_string_given = TRUE;\n       }\n     }\n     else {\n       copy_uppercase(temp,op);\n       if (EQUAL(temp,\"*\")) {\n         if (find_string_given) finderror = TRUE;\n         else {\n           strcpy(find_string,np->text_find_string);\n           find_form = ff;\n           find_string_given = TRUE;\n         }\n       }\n       else if (find_operand_count == 1) {\n         strcpy(find_string,op);\n         find_form = ff;\n         find_string_given = TRUE;\n       }\n       else if (EQUAL(temp,\"NEXT\")) {\n         if (find_what_given) finderror = TRUE;\n         else {\n           find_what = FIND_NEXT;\n           find_what_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"PREV\")) {\n         if (find_what_given) finderror = TRUE;\n         else {\n           find_what = FIND_PREV;\n           find_what_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"FIRST\")) {\n         if (find_what_given) finderror = TRUE;\n         else {\n           find_what = FIND_FIRST;\n           find_what_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"LAST\")) {\n         if (find_what_given) finderror = TRUE;\n         else {\n           find_what = FIND_LAST;\n           find_what_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"ALL\")) {\n         if (find_what_given) finderror = TRUE;\n         else {\n           find_what = FIND_ALL;\n           find_what_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"CHARS\")) {\n         if (find_type_given) finderror = TRUE;\n         else {\n           find_type = FIND_CHARS;\n           find_type_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"WORD\")) {\n         if (find_type_given) finderror = TRUE;\n         else {\n           find_type = FIND_WORD;\n           find_type_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"PREFIX\") || EQUAL(temp,\"PRE\")) {\n         if (find_type_given) finderror = TRUE;\n         else {\n           find_type = FIND_PREFIX;\n           find_type_given = TRUE;\n         }\n       }\n       else if (EQUAL(temp,\"SUFFIX\") || EQUAL(temp,\"SUF\")) {\n         if (find_type_given) finderror = TRUE;\n         else {\n           find_type = FIND_SUFFIX;\n           find_type_given = TRUE;\n         }\n       }\n       else if (*(temp+strspn(temp,\"0123456789\")) == '\\0') {\n         if (find_left_bound_given) {\n           if (find_right_bound_given) finderror = TRUE;\n           else {\n             find_right_bound = atoi(temp);\n             if (find_right_bound > bp->maxlen) out_of_bounds = TRUE;\n             find_right_bound_given = TRUE;\n           }\n         }\n         else {\n           find_left_bound  = atoi(temp);\n             if (find_right_bound < 1) out_of_bounds = TRUE;\n           find_left_bound_given = TRUE;\n         }\n       }\n       else {\n         if (find_string_given) finderror = TRUE;\n         else {\n           strcpy(find_string,op);\n           find_form = ff;\n           find_string_given = TRUE;\n         }\n       }\n     }\n   }\n }\n\n if (out_of_bounds) {\n   ERR2(\"Invalid bound; Bounds must lie between 1 and %d\", bp->maxlen);\n   return FALSE;\n }\n\n if (finderror) {\n   ERR1(\"Put string in quotes; Conflicting or unknown parameter.\");\n   return FALSE;\n }\n\n len = strlen(find_string);\n\n if (find_string_given) bp->find_hit_end = FALSE;\n\n if (find_left_bound_given && find_right_bound_given\n     && find_left_bound > find_right_bound) {\n   n = find_left_bound;\n   find_left_bound = find_right_bound;\n   find_right_bound = n;\n }\n else if (find_left_bound_given && !find_right_bound_given) {\n   find_right_bound = find_left_bound + len - 1;\n }\n\n if (find_string_given) {\n   switch (find_form) {\n     case FIND_UNQUOTED:  find_trans = FIND_CAPS;    break;\n     case FIND_QUOTED:    find_trans = FIND_CAPS;    break;\n     case FIND_C:         find_trans = FIND_ASIS;    break;\n     case FIND_T:         find_trans = FIND_CAPS;    break;\n     case FIND_P:         find_trans = FIND_GENERIC; break;\n     case FIND_X:         find_trans = FIND_HEX;\n        if (len % 2 != 0) {\n          ERR1(\"Odd number of characters in hex string.\");\n          return FALSE;\n        }\n        if (len != strspn(find_string,\"0123456789abcdefABCDEF\")) {\n          ERR1(\"Invalid (non-hex) characters in hex string.\");\n          return FALSE;\n        }\n        for (p = find_string, q = find_string; *p; p += 2, *q++) {\n          sprintf(temp,\"0x%2.2s\",p);\n          sscanf(temp,\"%x\",&n);\n          *q = (char)n;\n        }\n        *q = '\\0';\n        len = strlen(find_string);\n        break;\n   }\n }\n\n /* Store parameters for next Repeat Find operation. */\n\n strcpy(np->text_find_string,find_string);\n switch (find_what) {\n   case FIND_PREV:\n   case FIND_LAST:  np->text_find_what = FIND_PREV; break;\n   default:         np->text_find_what = FIND_NEXT; break;\n }\n np->text_find_type        = find_type;\n np->text_find_trans       = find_trans;\n np->text_find_left_bound  = find_left_bound;\n np->text_find_right_bound = find_right_bound;\n\n if (!*find_string) {\n   ERR1(\"A null string is not allowed for the FIND command.\");\n   return FALSE;\n }\n\n if (bp->total == 0) {\n   ERR1(\"There is no text to search.\");\n   return FALSE;\n }\n\n strcpy(bp->zcmd,\"\");\n\n switch (find_type) {\n   case FIND_CHARS:   show_type = \"Chars\";  break;\n   case FIND_WORD:    show_type = \"Word\";   break;\n   case FIND_PREFIX:  show_type = \"Prefix\"; break;\n   case FIND_SUFFIX:  show_type = \"Suffix\"; break;\n   default:           show_type = \"Text\";   break;\n }\n\n switch (find_trans) {\n   case FIND_ASIS:    strcpy(show_string+0,\"C'\");\n                      strcpy(show_string+2,find_string);\n                      strcat(show_string,\"'\");\n                      break;\n   case FIND_GENERIC: strcpy(show_string+0,\"P'\");\n                      strcpy(show_string+2,find_string);\n                      strcat(show_string,\"'\");\n                      break;\n   case FIND_HEX:     strcpy(show_string+0,\"X'\");\n                      for (p=find_string,q=show_string+2;*p;p++,q+=2) {\n                        sprintf(q,\"%2.2X\",*p);\n                      }\n                      strcat(show_string,\"'\");\n                      break;\n   case FIND_CAPS:\n   default:           strcpy(show_string+0,\"'\");\n                      strcpy(show_string+1,find_string);\n                      strcat(show_string,\"'\");\n                      break;\n }\n\n switch (find_trans) {\n   case FIND_CAPS:\n        uppercase_in_place(find_string);\n        break;\n   case FIND_GENERIC:\n        ERR1(\"The P'string' generic format is not supported.\");\n        return FALSE;\n }\n\n hit_end = bp->find_hit_end;\n findlen = strlen(find_string);\n\n if (find_what == FIND_ALL) {\n   bp->find_count = 0;\n   if (!find_it(np,bp,find_string,findlen,\n                                  find_type,FIND_FIRST,find_trans,\n                                  find_left_bound, find_right_bound)) {\n     sprintf(shortmsg,\"No %s %s found\",show_type,show_string);\n     sprintf(longmsg,\n             \"%s %s - not found within columns %d to %d\",\n             show_type,show_string,find_left_bound,find_right_bound);\n     ERR3(\"%24s;%s\",shortmsg,longmsg);\n     return FALSE;\n   }\n   bp->found_row = bp->find_row;\n   bp->found_col = bp->find_col;\n   bp->find_count = 1;\n   while (find_it(np,bp,find_string,findlen,\n                        find_type,FIND_ALL,find_trans,\n                        find_left_bound, find_right_bound)) {\n         bp->find_count++;\n   }\n   bp->find_hit_end = FALSE;\n }\n else {\n   if (!find_it(np,bp,find_string,findlen,\n                                  find_type,find_what,find_trans,\n                                  find_left_bound, find_right_bound)) {\n     if (hit_end) {\n       sprintf(shortmsg,\"No %s %s found\",show_type,show_string);\n       sprintf(longmsg,\n               \"%s %s - not found within columns %d to %d\",\n               show_type,show_string,find_left_bound,find_right_bound);\n       ERR3(\"%24s;%s\",shortmsg,longmsg);\n       return FALSE;\n     }\n     else if (np->text_find_what == FIND_PREV) {\n       sprintf(shortmsg,\"Top of data reached\");\n       sprintf(longmsg,\n            \"%s %s not found.  Use RFIND to continue from bottom.\",\n             show_type, show_string);\n       ERR3(\"%24s;%s\",shortmsg,longmsg);\n     }\n     else {\n       sprintf(shortmsg,\"Bottom of data reached\");\n       sprintf(longmsg,\n               \"%s %s not found.  Use RFIND to continue from top.\",\n             show_type, show_string);\n       ERR3(\"%24s;%s\",shortmsg,longmsg);\n     }\n     return FALSE;\n   }\n   bp->found_row = bp->find_row;\n   bp->found_col = bp->find_col;\n }\n\n if (bp->found_row + 1 < bp->top\n  || bp->found_row + 1 >= bp->top + bp->lvl - bp->cols) {\n   bp->top = bp->found_row + 1 - 1;\n   if (bp->top < 0) bp->top = 0;\n }\n\n if (bp->found_col < bp->coloff) {\n   bp->coloff = bp->found_col;\n   *bp->cols_line = '\\0';\n }\n else if (bp->found_col+len > bp->coloff+80) {\n   bp->coloff = bp->found_col + len - 80;\n   if (bp->coloff < 0) bp->coloff = 0;\n   *bp->cols_line = '\\0';\n }\n\n strcpy(bp->cursor, \"NNBDYNA\");\n bp->csrpos = 80 * (bp->found_row - bp->top+bp->cols + 1)\n              + bp->found_col - bp->coloff + 1;\n\n bp->found_left = bp->csrpos;\n bp->found_right = bp->found_left + len;\n bp->reinit_browse = TRUE;\n\n if (find_what == FIND_ALL) {\n   sprintf(shortmsg,\"%d %s %s\",bp->find_count,show_type,show_string);\n   sprintf(longmsg,\n           \"%s %s found %d times within columns %d to %d\",\n           show_type,show_string,bp->find_count,\n           find_left_bound,find_right_bound);\n   WARN3(\"%24s;%s\",shortmsg,longmsg);\n }\n else {\n   sprintf(shortmsg,\"%s %s found\",show_type,show_string);\n   sprintf(longmsg,\n           \"Search for %s %s within columns %d to %d was successful\",\n           show_type,show_string, find_left_bound,find_right_bound);\n   WARN3(\"%24s;%s\",shortmsg,longmsg);\n }\n\n bp->find_row = bp->found_row;\n bp->find_col = bp->found_col;\n return TRUE;\n}\n\n/************ Fill browse dynamic area. *******************************/\n\nstatic void\nfill_browse_dynamic_area(np,bp)\nRstruc nncb        *np;\nRstruc browser     *bp;\n{\n struct textline  **tpp  = NULL;\n register char     *cp   = NULL;\n register char     *p;\n char              *q;\n char              *r;\n int                i;\n int                j;\n char               temp\u00dd12\u00a8;\n\n static char  top_of_data_line\u00dd81\u00a8 = \"\\\n********************************* Top of data \\\n**********************************\";\n\n static char  bottom_of_data_line\u00dd81\u00a8 = \"\\\n******************************** Bottom of data \\\n********************************\";\n\n bp->lastpos = bp->bda + bp->size;\n bp->total = bp->thp->text_line_count;\n\n memset(bp->bda,' ',bp->size);\n\n if      (bp->more_rows == -MAX_INT)\n         bp->top = 0;\n else if (bp->more_rows == MAX_INT)\n         bp->top = bp->total + 2 - bp->lvl + bp->cols;\n else    bp->top += bp->more_rows;\n\n if (bp->top < 0) bp->top = 0;\n if (bp->top > bp->total) bp->top = bp->total + 1;\n\n i  = bp->top;\n p  = bp->bda;\n\n if (bp->cols > 0) {\n   if (!*bp->cols_line) {\n     for (j=bp->coloff+1,r=bp->cols_line; j<=bp->coloff+80; j++,r++) {\n       if (j%10 == 0) {\n         sprintf(temp,\"%d\",j%100);\n         *r = temp\u00dd0\u00a8;\n       }\n       else if (j%5 == 0) *r = '+';\n       else *r = '-';\n     }\n   }\n   memcpy(p,bp->cols_line,80);\n   p += 80;\n }\n\n if (i == 0) {\n   memcpy(p,top_of_data_line,80);\n   p += 80;\n   i++;\n }\n\n bp->firstpos = p;\n\n for (tpp=&bp->tv\u00ddi-1\u00a8;i<=bp->total && p<bp->lastpos;i++,tpp++,p+=80) {\n   if ((*tpp)->tab_expanded_text_length > bp->coloff) {\n     cp = (*tpp)->tab_expanded_text + bp->coloff;\n     for (j = 0, q = p; *cp && j < 80; j++, q++, cp++) {\n       if (*cp > 0xf9 || *cp < 0x40) *q = np->text_dispchar;\n       else *q = *cp;\n     }\n   }\n }\n\n if (p < bp->lastpos) {\n   memcpy(p,bottom_of_data_line,80);\n }\n\n return;\n}\n\n/************ Highlight browse text. **********************************/\n\nstatic void\nhighlight_browse_text(np,bp)\nRstruc nncb        *np;\nRstruc browser     *bp;\n{\n char              *p;\n\n bp->highlighted = FALSE;\n\n if (bp->found_left) {\n   if (EQUAL(bp->cursor,\"NNBDYNA\")) {\n     for (p = bp->bda + bp->found_left - 1; p >= bp->firstpos; p--) {\n       if (*p == ' ') {\n         *p = DATAOUT_HIGH;\n         bp->highlighted = TRUE;\n         break;\n       }\n     }\n     for (p = bp->bda + bp->found_right - 1; p <= bp->lastpos; p++) {\n      if (*p == ' ') {\n        *p = DATAOUT_LOW;\n         bp->highlighted = TRUE;\n         break;\n       }\n     }\n   }\n }\n\n bp->found_left = 0;\n bp->found_right = 0;\n\n return;\n}\n\n/************ Display browse data. ************************************/\n\nstatic void\ndisplay_browse_data(np,bp,tdp)\nRstruc nncb        *np;\nRstruc browser     *bp;\nRstruc tabledesc   *tdp;\n{\n Rstruc cmddesc    *cdp;\n char              *cp;\n char              *operands;\n int                displayrc;\n int                zscrolln;\n int                leftcol;\n int                rightcol;\n int                command_index;\n Bool               command_processed_ok;\n Bool               is_max;\n Bool               is_scroll_word;\n Bool               is_scroll_cursor;\n SCROLL             scroll_amount;\n char               command    \u00ddCOMMANDSIZE+1\u00a8;\n char               zverb      \u00dd16\u00a8;\n char               zscrolla   \u00dd16\u00a8;\n char               longmsg    \u00dd73\u00a8;\n char               nnbtitle   \u00dd81\u00a8;\n char               nnbmsg     \u00dd81\u00a8;\n char               temp1      \u00dd81\u00a8;\n char               temp2      \u00dd81\u00a8;\n\n bp->more_rows = 0;\n bp->override_scroll = FALSE;\n bp->exit_browse     = FALSE;\n\n memset (nnbtitle, '-', 80);\n strcpy (nnbtitle, \"Browse - \");\n memcpy (nnbtitle + 9, bp->title, strlen(bp->title));\n\n if (!np->setmsg) {\n   leftcol = bp->coloff + 1;\n   rightcol = bp->coloff + 80;\n   if (bp->top > bp->total) strcpy(temp1,\"\");\n   else sprintf(temp1, \" Line %d of %d,\", bp->top, bp->total);\n   if (bp->maxlen <= 80)\n        sprintf(temp2,\" Cols %d-%d\",leftcol,rightcol);\n   else sprintf(temp2,\" Cols %d-%d of %d\",leftcol,rightcol,bp->maxlen);\n   strcpy(nnbmsg,temp1);\n   strcat(nnbmsg,temp2);\n   strcpy (nnbtitle + 79 - strlen(nnbmsg), nnbmsg);\n }\n\n (void)NNMivput(np,\"NNBTITLE \",nnbtitle    ,-1);\n (void)NNMivput(np,\"ZCMD \"    ,bp->zcmd    ,-1);\n (void)NNMivput(np,\"NNBDYNA \" ,bp->bda     ,bp->size);\n (void)NNMivput(np,\"NNBCUR \"  ,bp->cursor  ,-1);\n sprintf(temp1,\"%d\",bp->csrpos);\n (void)NNMivput(np,\"NNBPOS  \" ,temp1       ,-1);\n (void)NNMivput(np,\"YRFIND \"  ,\"ALIAS FIND\",-1);\n\n displayrc = NNMdispl(np,\"NNMVIEW \");\n\n if (displayrc > 0) bp->exit_browse = TRUE;\n\n (void)NNMivput(np,\"YRFIND \"  ,\"\",-1);\n (void)NNMivget(np,\"NNBCUR  \" ,bp->cursor  , 8);\n (void)NNMivget(np,\"ZCMD    \" ,bp->zcmd     ,sizeof(bp->zcmd));\n bp->lvl    = NNMiget(np,\"NNBLVL  \");\n bp->csrpos = NNMiget(np,\"NNBPOS  \");\n\n strip_trailing_in_place(bp->cursor); /* try to fix UCLA find bug */\n\n strcpy(bp->find_cursor, bp->cursor);\n bp->find_csrpos = bp->csrpos;\n strcpy(bp->cursor,\"\");\n bp->csrpos = 1;\n if (bp->highlighted) bp->reinit_browse = TRUE;\n else                 bp->reinit_browse = FALSE;\n\n if (*bp->zcmd) {\n\n   memset(command,' ',COMMANDSIZE);\n   command_index = 0;\n   for (cp = bp->zcmd; *cp && !isspace(*cp); cp++) {\n     if (cp >= bp->zcmd+COMMANDSIZE) {\n       ERR1(\"Unknown command name.\");\n       command_processed_ok = FALSE;\n     }\n     command\u00ddcommand_index++\u00a8 = toupper(*cp);\n   }\n   while (*cp && isspace(*cp)) cp++;\n\n   for (cdp=tdp->first_cmddesc; *cdp->command_name != ' '; cdp++) {\n     if (!memcmp(command,cdp->command_name,COMMANDSIZE-1)) {\n       command_processed_ok = (cdp->command_processor)(np,bp,cp);\n       cdp = NULL;\n       break;\n     }\n     #define LASTAPCMD \"OPT \"\n     #define LASTAPLEN 4\n     else if (!bp->ap\n           && !memcmp(cdp->command_name,LASTAPCMD,LASTAPLEN))\n              break;\n   }\n   if (cdp) {\n     for (cdp=tdp->next_cmddesc; *cdp->command_name != ' '; cdp++) {\n       if (!memcmp(command,cdp->command_name,COMMANDSIZE-1)) {\n         command_processed_ok = (cdp->command_processor)(np,bp,cp);\n         cdp = NULL;\n         break;\n       }\n     }\n   }\n   if (cdp) {\n     ERR1(\"Unknown command name.\");\n     command_processed_ok = FALSE;\n   }\n\n   if (command_processed_ok) strcpy(bp->zcmd,\"\");\n\n }\n\n if (np->quit || bp->exit_browse) return;\n\n /* Check scroll request (ZSCROLLA direction, ZSCROLLN number).\n  * Skip this if something was done by a command which causes\n  * its own pseudo-scrolling to happen (like LOCATE).\n  */\n\n if (!bp->override_scroll) {\n\n   zscrolln = 0;\n\n   (void)NNMivget(np,\"ZVERB    \" ,  zverb    ,sizeof(zverb));\n   (void)NNMivget(np,\"ZSCROLLA \" ,  zscrolla ,sizeof(zscrolla));\n   zscrolln = NNMiget(np,\"ZSCROLLN \");\n\n   is_max = FALSE;\n   is_scroll_word = FALSE;\n   is_scroll_cursor = FALSE;\n\n   switch (zscrolla\u00dd0\u00a8) {\n     case 'P':\n     case 'H':\n     case 'D':  is_scroll_word = TRUE;\n                break;\n     case 'C':  is_scroll_word = TRUE;\n                is_scroll_cursor = TRUE;\n                break;\n     case 'M':  is_max = TRUE;\n                break;\n   }\n\n   if      (EQUAL(zverb,\"DOWN\"))  scroll_amount = DOWN;\n   else if (EQUAL(zverb,\"UP\"))    scroll_amount = UP;\n   else if (EQUAL(zverb,\"LEFT\"))  scroll_amount = LEFT;\n   else if (EQUAL(zverb,\"RIGHT\")) scroll_amount = RIGHT;\n   else                           scroll_amount = NO_SCROLL;\n\n\n   switch (scroll_amount) {\n     case NO_SCROLL:\n          bp->more_rows = 0;\n          break;\n     case DOWN:\n          if (is_max) bp->more_rows = MAX_INT;\n          else if (is_scroll_word)\n                      bp->more_rows = zscrolln - bp->cols;\n          else        bp->more_rows = zscrolln;\n          bp->reinit_browse = TRUE;\n          break;\n     case UP:\n          if (is_max) bp->more_rows = -MAX_INT;\n          else if (is_scroll_cursor)\n                      bp->more_rows = -zscrolln;\n          else if (is_scroll_word)\n                      bp->more_rows = -zscrolln - bp->cols;\n          else        bp->more_rows = -zscrolln;\n          bp->reinit_browse = TRUE;\n          break;\n     case LEFT:\n          if (is_max) bp->coloff = 0;\n          else        bp->coloff -= zscrolln;\n          if (bp->coloff < 0) bp->coloff = 0;\n          *bp->cols_line = '\\0';\n          bp->more_rows = 0;\n          bp->reinit_browse = TRUE;\n          break;\n     case RIGHT:\n          if (is_max) bp->coloff = bp->maxcoloff;\n          else        bp->coloff += zscrolln;\n          if (bp->coloff > bp->maxcoloff) bp->coloff = bp->maxcoloff;\n          *bp->cols_line = '\\0';\n          bp->more_rows = 0;\n          bp->reinit_browse = TRUE;\n          break;\n   }\n }\n\n return;\n}\n\n/*---*/\n\nstatic struct cmddesc browse_commands\u00dd\u00a8 = {\n                          {\"L          \",process_locate_command   },\n                          {\"LOC        \",process_locate_command   },\n                          {\"LOCATE     \",process_locate_command   },\n                          {\"F          \",process_find_command     },\n                          {\"FIND       \",process_find_command     },\n                          {\"RFIND      \",process_find_command     },\n                          {\"YRFIND     \",process_find_command     },\n                          {\"COL        \",process_cols_command     },\n                          {\"COLS       \",process_cols_command     },\n                          {\"RES        \",process_reset_command    },\n                          {\"RESET      \",process_reset_command    },\n                          {\"NOCOL      \",process_reset_command    },\n                          {\"NOCOLS     \",process_reset_command    },\n                          {\"DISP       \",process_display_command  },\n                          {\"DISPL      \",process_display_command  },\n                          {\"DISPLAY    \",process_display_command  },\n                          {\"EXT        \",process_extract_command  },\n                          {\"EXTR       \",process_extract_command  },\n                          {\"EXTRACT    \",process_extract_command  },\n                          {\"PRT        \",process_print_command    },\n                          {\"PRNT       \",process_print_command    },\n                          {\"PRINT      \",process_print_command    },\n                          {\"ROT13      \",process_rot13_command    },\n /* overrides general */  {\"OPTIONS    \",process_options_command  },\n /* overrides general */  {\"OPT        \",process_options_command  },\n /* overrides general */  {\"HEADERS    \",process_headers_command  },\n /* overrides general */  {\"HEADER     \",process_headers_command  },\n                          {\"UNREAD     \",process_unread_command   },\n                          {\"REPLY      \",process_reply_command    },\n                          {\"FOLLOWUP   \",process_followup_command },\n                          {\"NEXT       \",process_next_command     },\n                          {\"PREV       \",process_prev_command     },\n                          {\"NEXTU      \",process_nextu_command    },\n                          {\"NU         \",process_nextu_command    },\n                          {\"PREVU      \",process_prevu_command    },\n                          {\"PU         \",process_prevu_command    },\n                          {\"NEXTT      \",process_nextt_command    },\n                          {\"NT         \",process_nextt_command    },\n                          {\"PREVT      \",process_prevt_command    },\n                          {\"PT         \",process_prevt_command    },\n                          {\"NEXTS      \",process_nextsubj_command },\n                          {\"NEXTSUBJ   \",process_nextsubj_command },\n                          {\"NS         \",process_nextsubj_command },\n                          {\"PREVS      \",process_prevsubj_command },\n                          {\"PREVSUBJ   \",process_prevsubj_command },\n                          {\"PS         \",process_prevsubj_command },\n                          {\"FIRSTS     \",process_firstsubj_command},\n                          {\"FIRSTSUBJ  \",process_firstsubj_command},\n                          {\"FS         \",process_firstsubj_command},\n                          {\"LASTS      \",process_lastsubj_command },\n                          {\"LASTSUBJ   \",process_lastsubj_command },\n                          {\"LS         \",process_lastsubj_command },\n                          {\"NEWSUBJ    \",process_newsubj_command  },\n                          {\"SUBJECT    \",process_subject_command  },\n                          {\"SUBJ       \",process_subject_command  },\n                          {\"           \",NULL}\n                         };\n\n\n/****** View text in full screen mode (BROWSE replacement) ***********/\n\nvoid\nNNMview(np,gp,ap,texthdrp,title)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nRstruc newsarticle  *ap;\nstruct texthdr      *texthdrp;\nchar                *title;\n{\n Rstruc tabledesc   *tdp;\n struct textline    *tp;\n struct textline   **tv;\n struct textline   **textvector;\n struct browser     *bp;\n struct browser      browserstruct;\n\n GETMAIN(textvector, struct textline *,\n         texthdrp->text_line_count, \"text vector\");\n if (!textvector) {\n   ERR1(\"Not enough memory to display text.\");\n   return;\n }\n\n bp = &browserstruct;\n memset(bp,0,sizeof(struct browser));\n bp->gp = gp;\n bp->ap = ap;\n bp->thp = texthdrp;\n bp->tv = textvector;\n strcpy(bp->title,title);\n bp->more_rows = -MAX_INT;   /* set initial request to scroll up max */\n bp->top       = 0;\n bp->find_row  = -1;\n bp->find_col  = -1;\n bp->csrpos    = 1;\n strcpy(bp->cursor,\"\");\n bp->reinit_browse = TRUE;\n\n /* Collect text line pointers, skipping suppressed lines. */\n\n bp->maxlen = 0;\n for (tp=texthdrp->first_text_line, tv=textvector; tp; tp=tp->next) {\n   if (tp->text_length >= 0) {\n     *(tv++) = tp;\n     if (bp->maxlen < tp->tab_expanded_text_length)\n         bp->maxlen = tp->tab_expanded_text_length;\n   }\n }\n bp->maxcoloff = bp->maxlen - 80;\n if (bp->maxcoloff < 0) bp->maxcoloff = 0;\n\n GETMAIN(bp->work, char *, bp->maxlen+1, \"browse work string\");\n if (!bp->work) return;\n\n (void)NNMispf(np,\n         \"PQUERY PANEL(NNMVIEW) AREANAME(NNBDYNA) DEPTH(NNBDEPTH)\");\n if (np->ispfrc != 0) return;\n bp->depth = NNMiget(np,\"NNBDEPTH \");\n bp->size = bp->depth * 80;\n GETMAIN(bp->bda, char *, bp->size+1, \"browse dynamic area\");\n if (!bp->bda) return;\n\n if (!np->text_dispchar) np->text_dispchar = '.';\n\n tdp = np->display_table_vector->text_display_table;\n tdp->first_cmddesc = browse_commands;\n\n for (;;) {\n   if (bp->reinit_browse) {\n     fill_browse_dynamic_area(np,bp);\n     highlight_browse_text(np,bp);\n   }\n   display_browse_data(np,bp,tdp);\n   if (np->quit || bp->exit_browse) break;\n }\n\n FREEMAIN(bp->work,\"browse work string\");\n FREEMAIN(bp->bda,\"browse dynamic area\");\n FREEMAIN(textvector, \"text vector\");\n\n return;\n}\n\n./ ADD NAME=NNMVNG\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@VNG  \")\n#pragma  csect(static,\"NN$VNG  \")\n#include \"nn.h\"\n\nstruct ngdynarray {\n                   struct newsgroup      *newsgroup;\n                  };\n\n/****** Display newsgroups via ISPF dynamic area. ********************/\n\nBool\nNNMvng(np)\nRstruc nncb           *np;\n{\n Rstruc newsgroup     *gp;\n Rstruc ngdynarray    *ndp;\n struct ngdynarray    *ngdynarray_address;\n Rstruc tabledesc     *tdp;\n Rstruc seldesc       *sdp;\n Rstruc cmddesc       *cdp;\n char                 *cp;\n int                   next_offset;\n int                   command_index;\n int                   newsgroup_count;\n int                   display_total;\n int                   dti;\n int                   ngi;\n int                   prc;\n int                   nnglvl;\n int                   depth;\n int                   topgroup;\n int                   bottomgroup;\n int                   save_topgroup;\n int                   last_group_located;\n int                   last_group_selected;\n int                   groupcursor;\n int                   zscrolln;\n int                   dynsize;\n int                   framelength;\n int                   findbump;\n short                 name_length;\n Bool                  is_max;\n Bool                  selection_processed_ok;\n Bool                  command_processed_ok;\n Bool                  text_not_found;\n char                 *rowp;\n char                 *nngdyna;\n char                  sel;\n char                  tcmd     \u00dd72\u00a8;\n char                  nnghead  \u00dd81\u00a8;\n char                  nngline  \u00dd81\u00a8;\n char                  nngcsr   \u00dd12\u00a8;\n char                  command  \u00ddCOMMANDSIZE\u00a8;\n char                  zverb     \u00dd9\u00a8;\n char                  zscrolla  \u00dd9\u00a8;\n char                  rowmessage\u00dd81\u00a8;\n\n static char           dashes\u00dd65\u00a8 =\n    \"----------------------------------------------------------------\";\n\n tdp = np->display_table_vector->newsgroup_display_table;\n\n np->current_newsgroup           = NULL;\n np->newsgroup_selected          = FALSE;\n np->newsgroup_criterion_changed = TRUE;\n np->newsgroup_order_changed     = TRUE;\n text_not_found                  = FALSE;\n strcpy(np->newsgroup_only_string,\"\");\n\n /* Determine how many TOTAL newsgroups we have. */\n\n newsgroup_count = 0;\n for (gp = np->first_newsgroup; gp; gp = gp->next) newsgroup_count++;\n\n /* Allocate a block of \"ngdynarray\" newsgroup pointers, one element\n  * for each newsgroup that is currently displayed.  This must be\n  * big enough to hold all known newsgroups at maximum.\n  */\n\n if (newsgroup_count == 0) {\n   ERR1(\n     \"No newsgroups to display.  Use L option to get list from server.\"\n       );\n   return FALSE;\n }\n\n GETMAIN(ngdynarray_address, struct ngdynarray,\n         newsgroup_count, \"newsgroup dynamic array\");\n if (!ngdynarray_address) return FALSE;\n\n /* Get depth of dynamic area (number of rows to display on screen) */\n\n (void)NNMispf(np,\n       \"PQUERY PANEL(NNMDNG) AREANAME(NNGDYNA) DEPTH(NNGDEPTH)\");\n if (np->ispfrc != 0) return FALSE;\n depth = NNMiget(np,\"NNGDEPTH \");\n\n /* Get storage for ISPF dynamic area variable to be constructed. */\n\n dynsize = 80*depth;\n GETMAIN(nngdyna, char, dynsize+1, \"NNGDYNA buffer\");\n if (!nngdyna) return FALSE;\n memset(nngdyna,' ',dynsize);\n\n topgroup = 0;\n groupcursor = 0;\n last_group_located  = -1;\n last_group_selected = -1;\n\n strcpy(tcmd,\"\");\n\n memset(nngline,' ',80);\n nngline\u00dd 0\u00a8 = DATAOUT_HIGH;\n nngline\u00dd 1\u00a8 = 'S';\n nngline\u00dd 2\u00a8 = DATAOUT_LOW;\n memcpy(&nngline\u00dd 3\u00a8,\"select\",6);\n nngline\u00dd 9\u00a8 = DATAOUT_HIGH;\n nngline\u00dd10\u00a8 = 'A';\n nngline\u00dd11\u00a8 = DATAOUT_LOW;\n memcpy(&nngline\u00dd12\u00a8,\"all\",   3);\n nngline\u00dd15\u00a8 = DATAOUT_HIGH;\n nngline\u00dd16\u00a8 = 'R';\n nngline\u00dd17\u00a8 = DATAOUT_LOW;\n memcpy(&nngline\u00dd18\u00a8,\"reg\",   3);\n nngline\u00dd21\u00a8 = DATAOUT_HIGH;\n nngline\u00dd22\u00a8 = 'D';\n nngline\u00dd23\u00a8 = DATAOUT_LOW;\n memcpy(&nngline\u00dd24\u00a8,\"dereg\", 5);\n nngline\u00dd29\u00a8 = DATAOUT_HIGH;\n nngline\u00dd30\u00a8 = 'M';\n nngline\u00dd31\u00a8 = DATAOUT_LOW;\n memcpy(&nngline\u00dd32\u00a8,\"mark\",  4);\n nngline\u00dd36\u00a8 = DATAOUT_HIGH;\n nngline\u00dd37\u00a8 = 'U';\n nngline\u00dd38\u00a8 = DATAOUT_LOW;\n memcpy(&nngline\u00dd39\u00a8,\"unmark\",6);\n nngline\u00dd48\u00a8 = DATAOUT_HIGH;\n strcpy(&nngline\u00dd49\u00a8,\"Unread   Count   Range\");\n\n /* The last line above may be variable some day if we have to vary\n    the width of the numbers...  */\n\n /* Loop displaying newsgroups until END or criterion changed. */\n\n do {\n\n   /* If the newsgroup display criteria have changed, or this is the\n      first time through, build the array of newsgroup pointers.  */\n\n   if (np->newsgroup_criterion_changed || np->newsgroup_order_changed) {\n     ndp = ngdynarray_address;\n     display_total = 0;\n     topgroup = 0;\n     switch (np->newsgroup_order) {\n       case NNTP_LIST_ORDER:\n            gp = np->first_newsgroup_alt;\n            next_offset = (char *)&gp->next2 - (char *)gp;\n            break;\n       case ALPHABETICAL_ORDER:\n       default:\n            gp = np->first_newsgroup;\n            next_offset = (char *)&gp->next - (char *)gp;\n            break;\n     }\n     for (; gp; gp = *(struct newsgroup **)((int)gp + next_offset)) {\n       if (np->newsgroup_criterion_changed) {\n         OffGroupInTable(gp);   /* guilty until proven innocent */\n         if ((np->show_all_newsgroups && !NoSuchGroup(gp))\n          || gp->registered) {\n           if (!*np->newsgroup_only_string\n            || strstr(gp->name,np->newsgroup_only_string)) {\n             SetGroupInTable(gp);\n           }\n         }\n       }\n       if (GroupInTable(gp)) {\n         display_total++;\n         ndp->newsgroup = gp;\n         ndp++;\n       }\n     }\n   }\n\n   np->newsgroup_criterion_changed = FALSE;\n   np->newsgroup_order_changed     = FALSE;\n\n   /* Fill dynamic area with data for groups satisfying criterion. */\n\n   memset(nngdyna, ' ', dynsize);\n\n   for (dti = 0,       ngi = topgroup,        rowp = nngdyna;\n        dti < depth && ngi < display_total;\n        dti++,         ngi++,                 rowp += 80) {\n     ndp = &ngdynarray_address\u00ddngi\u00a8;\n     gp  = ndp->newsgroup;\n     rowp\u00dd 0\u00a8  = DATAIN_HIGH;     /* selection code attribute */\n     rowp\u00dd 1\u00a8  = ' ';             /* selection code field     */\n     rowp\u00dd 2\u00a8  = gp->registered\n                 ? (gp->unread_count ? DATAOUT_YELLOW : DATAOUT_TURQ)\n                 : (gp->unread_count ? DATAOUT_GREEN  : DATAOUT_BLUE);\n                                      /* newsgroup name attribute */\n     memset(&rowp\u00dd3\u00a8, '.', 40);\n     name_length = strlen(gp->name);\n     if (name_length > 40) name_length = 40;\n     memcpy(&rowp\u00dd3\u00a8, gp->name, name_length);\n     rowp\u00dd3+name_length\u00a8 = DATAOUT_BLUE;\n     rowp\u00dd43\u00a8 = DATAOUT_PINK;\n     rowp\u00dd44\u00a8 = gp->registered ? 'R' : ' ';\n     rowp\u00dd45\u00a8 = DATAOUT_HIGH;\n     if (gp->unread_count != 0)\n        sprintf(&rowp\u00dd46\u00a8, \"  %7d\", gp->unread_count);\n     rowp\u00dd55\u00a8 = DATAOUT_LOW;\n     if (gp->article_count == 0)\n        strcpy(&rowp\u00dd56\u00a8,\"      0                \");\n     else\n        sprintf(&rowp\u00dd56\u00a8, \"%7d %7d -%7d\",\n                gp->article_count, gp->low_number, gp->high_number);\n     rowp\u00ddstrlen(rowp)\u00a8 = ' ';\n\n     if (NoSuchGroup(gp)) {\n       memcpy(&rowp\u00dd46\u00a8,\"******* No such newsgroup *******\",33);\n     }\n\n   }\n\n   if (rowp < nngdyna + dynsize) {\n     rowp\u00dd0\u00a8 = DATAOUT_HIGH;\n     memset(&rowp\u00dd1\u00a8, '-',79);\n   }\n\n   bottomgroup = ngi - 1;\n\n   if (topgroup > bottomgroup) strcpy(rowmessage,\"\");\n   else sprintf(rowmessage, \"%d-%d of %d\",\n                       topgroup + 1, bottomgroup + 1, display_total);\n\n\n   framelength = (79 - strlen(rowmessage) - sizeof(\"Newsgroup Listing\")\n                 - 3) / 2;\n\n   sprintf(nnghead, \"%*.*s Newsgroup Listing %*.*s %s\",\n                    framelength, framelength, dashes,\n                    framelength, framelength, dashes,\n                    rowmessage);\n\n   if (last_group_selected >= 0 && np->newsgroup_autocursor) {\n     groupcursor = (last_group_selected - topgroup) * 80 + 2;\n   }\n\n   if (groupcursor > 0) {\n     sprintf(nngcsr,\"%d\",groupcursor);\n     (void)NNMivput(np,\"NNGCSR \", nngcsr, -1);\n   }\n   else {\n     (void)NNMivput(np,\"NNGCSR \", \"0\", 1);\n   }\n\n   (void)NNMivput(np,\"NNGCMD \",  tcmd,    -1);\n   (void)NNMivput(np,\"NNGHEAD \", nnghead, -1);\n   (void)NNMivput(np,\"NNGLINE \", nngline, -1);\n   (void)NNMivput(np,\"NNGDYNA \", nngdyna, dynsize);\n   (void)NNMivput(np,\"YRFIND \" , \"ALIAS FIND\",-1);\n\n   prc = NNMdispl(np,\"NNMDNG  \");\n   if (prc > 8) break;\n\n   /* (void)NNMispf(np,\"VGET (ZVERB ZSCROLLA ZSCROLLN)\"); */\n\n   (void)NNMivput(np,\"YRFIND \"  ,\"\",-1);\n   (void)NNMivget(np,\"NNGDYNA \" , nngdyna,  dynsize);\n   (void)NNMivget(np,\"ZVERB \"   , zverb,    sizeof(zverb));\n   (void)NNMivget(np,\"ZSCROLLA \", zscrolla, sizeof(zscrolla));\n   zscrolln = NNMiget(np,\"ZSCROLLN \");\n   nnglvl   = NNMiget(np,\"NNGLVL \");\n\n   /* Initialize what may be set by selection/command processors. */\n\n   strcpy(np->nngroup,\"\");\n   last_group_selected = -1;\n   last_group_located  = -1;\n   groupcursor = 0;\n   np->please_locate_group = FALSE;\n   np->please_find_group   = FALSE;\n\n   /* Process selections. */\n\n   for (ngi = topgroup,        rowp = nngdyna;\n        ngi <= bottomgroup  && !np->quit;\n        ngi++,                 rowp += 80) {\n     ndp = &ngdynarray_address\u00ddngi\u00a8;\n     gp = ndp->newsgroup;\n     sel = toupper(rowp\u00dd1\u00a8);\n     if (sel == ' ') continue;\n     for (sdp = tdp->first_seldesc; sdp->selection_code != ' '; sdp++) {\n       if (sel == sdp->selection_code) {\n         (void)NNMivput(np,\"NNGNAME \",gp->name, -1);\n         selection_processed_ok = (sdp->selection_processor)(np,gp);\n         sdp = NULL;\n         break;\n       }\n     }\n     if (sdp) {\n       ERR1(\"Unknown selection code.  Type one of the listed codes.\");\n       selection_processed_ok = FALSE;\n     }\n     else if (selection_processed_ok) {\n       if (*np->nngroup) last_group_located = ngi;\n       if (np->newsgroup_autocursor) last_group_selected = ngi;\n     }\n   }\n\n   if (np->quit) break;\n\n   /* Process command if any. */\n\n   strcpy(tcmd,\"\");\n\n   (void)NNMivget(np,tdp->command_variable,tcmd,sizeof(tcmd));\n\n   if (strcmp(tcmd,\"\") != 0) {\n\n     memset(command,' ',COMMANDSIZE);\n     command_index = 0;\n     for (cp = tcmd; *cp && !isspace(*cp); cp++) {\n       if (cp >= tcmd+COMMANDSIZE) {\n         ERR1(\"Unknown command name.\");\n         command_processed_ok = FALSE;\n       }\n       command\u00ddcommand_index++\u00a8 = toupper(*cp);\n     }\n     while (*cp && isspace(*cp)) cp++;\n\n     for (cdp=tdp->first_cmddesc; cdp->command_name\u00dd0\u00a8 != ' '; cdp++) {\n       if (!memcmp(command,cdp->command_name,COMMANDSIZE-1)) {\n         command_processed_ok = (cdp->command_processor)(np,NULL,cp);\n         cdp = NULL;\n         break;\n       }\n     }\n     if (cdp) {\n       for (cdp=tdp->next_cmddesc; cdp->command_name\u00dd0\u00a8 != ' '; cdp++) {\n         if (!memcmp(command,cdp->command_name,COMMANDSIZE-1)) {\n           command_processed_ok = (cdp->command_processor)(np,NULL,cp);\n           cdp = NULL;\n           break;\n         }\n       }\n     }\n\n     if (cdp) {\n       ERR1(\"Unknown command name.\");\n       command_processed_ok = FALSE;\n     }\n\n     if (command_processed_ok) strcpy(tcmd,\"\");\n\n   }\n\n   if (np->quit) break;\n\n   /* If locate to a specific group name was requested,\n      process before any scroll request.  */\n\n   if (last_group_located >= 0 && np->newsgroup_autoscroll) {\n     text_not_found = FALSE;\n     topgroup = last_group_located;\n   }\n   else if (np->please_locate_group) {\n     text_not_found = FALSE;\n     for (topgroup = 0, ndp = ngdynarray_address;\n          topgroup < display_total;\n          topgroup++,   ndp++) {\n       gp = ndp->newsgroup;\n       if (strcmp(gp->name,np->newsgroup_locate_string) >= 0) break;\n     }\n     if (topgroup == display_total) topgroup--;\n   }\n   else if (np->please_find_group) {\n     save_topgroup = topgroup;\n     switch (np->newsgroup_find_option) {\n       case FIND_NEXT:\n                       findbump = 1;\n                       if (np->repeat_find) {\n                         if (text_not_found) topgroup = 0;\n                         else topgroup++;\n                       }\n                       break;\n       case FIND_PREV:\n                       findbump = -1;\n                       if (np->repeat_find) {\n                         if (text_not_found) topgroup = bottomgroup;\n                         else topgroup--;\n                       }\n                       break;\n       case FIND_FIRST:\n                       topgroup = 0;\n                       findbump = 1;\n                       break;\n       case FIND_LAST:\n                       topgroup = display_total - 1;\n                       findbump = -1;\n                       break;\n     }\n     gp = NULL;\n     for (ndp = &ngdynarray_address\u00ddtopgroup\u00a8;\n          topgroup < display_total && topgroup >= 0;\n          topgroup += findbump, ndp += findbump) {\n       if (GroupInTable(ndp->newsgroup)\n        && strstr(ndp->newsgroup->name,np->newsgroup_find_string)) {\n         gp = ndp->newsgroup;\n         break;\n       }\n     }\n     if (!gp) {\n       topgroup = save_topgroup;\n       text_not_found = TRUE;\n       ERR3(\"No %s newsgroups with '%s' in name.\",\n            (findbump > 0 ? \"more\" : \"previous\"),\n            np->newsgroup_find_string);\n     }\n     else {\n       text_not_found = FALSE;\n   WARN1(\"Newsgroup found;\\\nThe newsgroup whose name contains the desired text tops the display.\");\n     }\n   }\n   else text_not_found = FALSE;\n\n   /* Process scroll request if any. */\n\n   is_max = EQUAL(zscrolla,\"MAX\");\n   if      (EQUAL(zverb,\"DOWN\")) {\n     if (is_max) topgroup = display_total - nnglvl + 1;\n     else        topgroup += zscrolln;\n   }\n   else if (EQUAL(zverb,\"UP\")) {\n     if (is_max) topgroup = 0;\n     else        topgroup -= zscrolln;\n   }\n   if (topgroup < 0)\n       topgroup = 0;\n   if (topgroup > display_total)\n       topgroup = display_total;\n\n } while (prc == 0);\n\n FREEMAIN(nngdyna,\"NNGDYNA buffer\");\n FREEMAIN(ngdynarray_address,\"newsgroup dynamic area\");\n\n return TRUE;\n\n}\n\n./ ADD NAME=NNMVTX\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@VTX  \")\n#pragma  csect(static,\"NN$VTX  \")\n#include \"nn.h\"\n\n/****** View the lines of text retrieved from the server. ************/\n\nvoid\nNNMvtx(np,gp,ap)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nRstruc newsarticle  *ap;\n{\n struct texthdr    *texthdrp;\n char               title     \u00dd81\u00a8;\n\n /* If article is not specified, use main nncb, else article's text */\n\n texthdrp = (ap ? &ap->thdr : &np->thdr);\n\n if (np->batch_mode) {\n   NNMbtext(np,texthdrp,NULL);\n   return;\n }\n\n if (ap) sprintf(title, \"%s:%d \",        gp->name, ap->number);\n else    sprintf(title, \"NewsServer:%s \",np->nnserver);\n\n NNMview(np,gp,ap,texthdrp,title);\n return;\n}\n\n./ ADD NAME=NNMXARTT\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@XARTT\")\n#pragma  csect(static,\"NN$XARTT\")\n#include \"nn.h\"\n\n#define FORCE_DISPLAY_TO_TOP_AFTER_EXTRACT\n\n/****** Emit an article title. ***************************************/\n\nstatic Bool\nemit_title(np,vp,xfp)\nRstruc nncb         *np;\nVARK                *vp;\nFILE                *xfp;\n{\n Rstruc newsarticle *ap = VARK2PARTICLE(*vp);\n char               *stat;\n\n if      IsMissing(*vp)  stat = \"Missing\";\n else if IsUnread(*vp)   stat = \"Unread\";\n else if IsRead(*vp)     stat = \"Read\";\n else                    stat = \"?\";\n\n if (np->article_rows == 1) {\n   fprintf(xfp,\"%7d %-51.51s %-8.8s %11.11s\\n\",\n                ap->number, ap->subject, stat, ap->date);\n }\n else {\n   fprintf(xfp,\"%7d %-51.51s %-8.8s\\n\",\n               ap->number, ap->subject, stat);\n }\n if (np->article_rows >= 2) {\n   fprintf(xfp,\"        %-51.51s %11.11s\\n\", ap->from, ap->date);\n }\n if (np->article_rows >= 3) {\n   fprintf(xfp,\"        %-51.51s\\n\", ap->message_id);\n }\n if (ferror(xfp)) return FALSE;\n else return TRUE;\n}\n\n/****** Extract article titles. **************************************/\n\nBool\nNNMxartt(np,gp,mode)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nenum data_set_type   mode;\n{\n FILE               *xfp;\n int                 count;\n VARK               *vp;\n VARK               *vpfirst;\n VARK               *vplast;\n VARK              **wp;\n VARK              **wpfirst;\n VARK              **wplast;\n struct extraction  *ep;\n struct extraction   the_extraction;\n\n if (!gp->article_vector) {\n   ERR2(\"Newsgroup %s contains no articles.\",gp->name);\n   return FALSE;\n }\n\n /* Display panel asking for data set name into which to extract. */\n\n ep = &the_extraction;\n memset(ep,0,sizeof(struct extraction));\n ep->mode = mode;\n if (ep->mode == JES)\n      strcpy(ep->panelname,\"NNMPPRN1\");\n else strcpy(ep->panelname,\"NNMPEXN1\");\n\n if (!((xfp=NNMgetds(np,ep)))) return TRUE;\n\n /* If append mode, and a separator line was specified, use it. */\n\n if (ep->appending && *ep->separator) {\n   fprintf(xfp,\"%s\\n\",ep->separator);\n   if (ep->blanking) fprintf(xfp,\"\\n\");\n }\n\n fprintf(xfp,\" Newsgroup: %-43.43s     Status   Date\\n\\n\", gp->name);\n\n count = NNMrart(np,gp,FALSE,FALSE);  /* Retrieve article titles */\n\n if (gp->sort_vector) {\n   wpfirst = gp->sort_vector;\n   wplast  = gp->sort_vector + gp->sort_count - 1;\n   for (wp = wpfirst; wp <= wplast; wp++) {\n     if (IsEligible(**wp)) {\n       if (!emit_title(np,*wp,xfp)) break;\n     }\n   }\n#ifdef FORCE_DISPLAY_TO_TOP_AFTER_EXTRACT\n   np->top_sorted_article = gp->sort_vector;\n#endif\n }\n else {\n   vpfirst = &GETVARKFIRST(gp);\n   vplast  = &GETVARKLAST(gp);\n   for (vp = vpfirst; vp <= vplast; vp++) {\n     if (IsEligible(*vp)) {\n       if (!emit_title(np,vp,xfp)) break;\n     }\n   }\n#ifdef FORCE_DISPLAY_TO_TOP_AFTER_EXTRACT\n   np->top_article = gp->vector_first;\n#endif\n }\n\n fprintf(xfp,\"\\n\");\n\n if (ferror(xfp)) {\n   ERR2(\"An output error occurred writing to %s.\", ep->dsname);\n }\n else {\n   WARN2(\"A list of titles has been written to %s.\", ep->dsname);\n }\n\n (ep->closer)(np,ep,xfp,TRUE);   /* Close the file */\n\n return TRUE;\n}\n\n./ ADD NAME=NNMXARTX\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* SAS enhancements copyright (c) 1992 SAS Institute, Inc.          */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@XARTX\")\n#pragma  csect(static,\"NN$XARTX\")\n#include \"nn.h\"\n\n/****** Extract an article. ******************************************/\n\nstatic Bool\nextract_it(np,gp,ep,vp,xfpp,newtopp)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nstruct extraction   *ep;\nVARK                *vp;\nFILE               **xfpp;\nint                 *newtopp;\n{\n struct newsarticle *ap;\n char               *cp1;\n char               *cp2;\n int                 anum;\n char                pdspec \u00dd32\u00a8;\n\n if (np->extract_write_error || np->extract_close_error) return FALSE;\n anum = VARK2NUMBER(gp,vp);\n if (anum > ep->to_article_number)                       return FALSE;\n if (anum < ep->from_article_number)                     return TRUE;\n if (!(NNMcar(np,gp,anum,vp,&ap,NULL,RETRIEVE)))         return TRUE;\n\n if (ep->mode == PDS) {\n   sprintf(ep->member,\"%8.8d\",anum);\n   for (cp1 = ep->member, cp2 = ep->member_prefix;\n        *cp1 == '0' && *cp2;\n        cp1++, cp2++) {\n     *cp1 = *cp2;\n   }\n   (void)NNMivput(np,\"NNEXMEM \",ep->member,-1);\n   sprintf(pdspec,\"dd:%s(%s)\",ep->ddname,ep->member);\n }\n else {\n   (void)NNMivput(np,\"NNEXMEM \",\" \",-1);\n }\n\n if (*newtopp == 0) *newtopp = anum;\n\n if (!NNMpick(np,ap)) {       /* Pick article to process */\n   fprintf(stderr,\"\\n*** Error accessing article %d\\n\",ap->number);\n   return TRUE;\n }\n\n if (ep->mode == PDS) {\n   (*xfpp) = OPEN_TEXT_FILE_FOR_WRITE(pdspec);\n   if (!(*xfpp)) {\n     perror(pdspec);\n     ERR3(\"Cannot open member %s of PDS %s.\", ep->member, ep->dsname);\n     return FALSE;\n   }\n }\n\n np->extract_file = (*xfpp);\n np->extractionp  = ep;\n\n NNMdoit(np,ap, ep->mode==JES ? 'P' : 'E'); /* Process article picked*/\n\n if (np->extract_write_error || np->extract_close_error) {\n   /*\n    * if (ep->mode == PDS) {\n    *   if (fclose((*xfpp)) < 0) {\n    *     /* perror(ep->dsname); */\n   /*   ERR2(\"An error occurred closing data set %s.\", ep->dsname);\n    *     np->extract_close_error = TRUE;\n    *   }\n    * }\n    */\n   *newtopp = ap->number;\n   return FALSE;\n }\n\n /* If not appending (always true for PDS), close was done in NNMxtx.*/\n\n if (ep->mode == SEQ) {\n   if (!ep->appending) {\n     (ep->closer)(np,ep,*xfpp,FALSE);   /* Close the file */\n     if (np->extract_close_error) {\n       *newtopp = ap->number;\n       return FALSE;\n     }\n     (*xfpp) = OPEN_TEXT_FILE_FOR_APPEND(ep->dsname);\n     if (!(*xfpp)) {\n       perror(ep->dsname);\n       ERR2(\"Unable to open file %s.\", ep->dsname);\n       np->extract_write_error = TRUE;\n       *newtopp = ap->number;\n       return FALSE;\n     }\n     ep->appending = TRUE;\n   }\n }\n return TRUE;\n\n}\n\n/****** Extract article text. ****************************************/\n\nBool\nNNMxartx(np,gp,mode)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nenum data_set_type   mode;\n{\n Rstruc newsarticle *ap;\n FILE               *xfp;\n struct extraction  *ep;\n VARK               *vp;\n VARK               *vpfirst;\n VARK               *vplast;\n VARK              **wp;\n VARK              **wpfirst;\n VARK              **wplast;\n int                 new_top_article = 0;\n struct extraction   the_extraction;\n\n if (!gp->article_vector) {\n   ERR2(\"Newsgroup %s contains no articles.\",gp->name);\n   return FALSE;\n }\n\n /* Display panel asking for data set name into which to extract. */\n\n ep = &the_extraction;\n memset(ep,0,sizeof(struct extraction));\n ep->mode = mode;\n ep->article_count = gp->article_count;\n switch (ep->mode) {\n   case PDS: strcpy(ep->panelname,\"NNMPEXNP\"); break;\n   case JES: strcpy(ep->panelname,\"NNMPPRNS\"); break;\n   case SEQ: strcpy(ep->panelname,\"NNMPEXNS\"); break;\n }\n\n if (!((xfp=NNMgetds(np,ep)))) return TRUE;\n\n np->extract_tab_expanding          = ep->tab_expanding;\n np->extract_appending              = ep->mode == PDS ? FALSE : TRUE;\n np->extract_ejecting               = ep->ejecting;\n np->extract_blank_before_separator = ep->blanking;\n np->extract_separator_line         = ep->separator;\n np->extract_write_error            = FALSE;\n np->extract_close_error            = FALSE;\n\n /* for each article (subject to range option), write */\n\n if (gp->sort_vector) {\n   wpfirst = gp->sort_vector;\n   wplast  = gp->sort_vector + gp->sort_count - 1;\n   for (wp = wpfirst; wp <= wplast; wp++) {\n     if (!extract_it(np,gp,ep,*wp,&xfp,&new_top_article)) break;\n   }\n }\n else {\n   vpfirst = &GETVARKFIRST(gp);\n   vplast  = &GETVARKLAST(gp);\n   for (vp = vpfirst; vp <= vplast; vp++) {\n     if (!extract_it(np,gp,ep,vp,&xfp,&new_top_article)) break;\n   }\n }\n\n if (np->extract_write_error || np->extract_close_error)\n    np->top_article = new_top_article;\n else if (new_top_article)\n    np->top_article = new_top_article;\n\n if (xfp) {\n   if      (np->extract_write_error) {\n     ERR2(\"An error occurred writing to %s.\", ep->dsname);\n   }\n   else if (np->extract_close_error) {\n     if (ep->mode == PDS) {\n     ERR3(\"Cannot store member %s in %s.  Check directory space.\",\n          ep->member, ep->dsname);\n     }\n     else ERR2(\"An error occurred closing %s.\", ep->dsname);\n   }\n   else {\n     WARN3(\"Articles from %s have been written to %s.\",\n           gp->name, ep->dsname);\n   }\n }\n\n (ep->closer)(np,ep,xfp,TRUE);   /* \"Close\" the PDS or the file */\n\n return TRUE;\n}\n\n./ ADD NAME=NNMXLIST\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@XLIST\")\n#pragma  csect(static,\"NN$XLIST\")\n#include \"nn.h\"\n\n/****** Extract newsgroup listing. ***********************************/\n\nstatic void\noutput_newsgroup_line(np,gp,xfp)\nRstruc nncb         *np;\nRstruc newsgroup    *gp;\nFILE                *xfp;\n{\n char                temp   \u00dd81\u00a8;\n\n if (gp->article_count == 0) strcpy(temp,\"\");\n else sprintf(temp,\"%7d - %7d\", gp->low_number, gp->high_number);\n\n fprintf(xfp,\"%*.*s %*.*s %c %7d %7d %s\\n\",\n         strlen(gp->name),\n         39,\n         gp->name,\n         39-strlen(gp->name),\n         39-strlen(gp->name),\n         \".........................................\",\n         (gp->registered ? 'R' : ' '),\n         gp->unread_count,\n         gp->article_count,\n         temp);\n\n return;\n\n}\n\n/****** Extract newsgroup listing. ***********************************/\n\nBool\nNNMxlist(np,mode)\nRstruc nncb         *np;\nenum data_set_type   mode;\n{\n Rstruc newsgroup   *gp;\n FILE               *xfp;\n struct extraction  *ep;\n char                temp   \u00dd72\u00a8;\n struct extraction   the_extraction;\n\n /* Display panel asking for data set name into which to extract. */\n\n ep = &the_extraction;\n memset(ep,0,sizeof(struct extraction));\n ep->mode = mode;\n if (ep->mode == JES)\n      strcpy(ep->panelname, \"NNMPPRNG\");\n else strcpy(ep->panelname, \"NNMPEXNG\");\n\n if (!((xfp=NNMgetds(np,ep)))) return TRUE;\n\n /* If append mode, and a separator line was specified, use it. */\n\n if (ep->appending && *ep->separator) {\n   fprintf(xfp,\"%s\\n\",ep->separator);\n   if (ep->blanking) fprintf(xfp,\"\\n\");\n }\n\n fprintf(xfp,\"\\\n  Newsgroup Listing                          Unread   Count      \\\n  Range\\n\\n\");\n\n switch (np->newsgroup_order) {\n   case NNTP_LIST_ORDER:\n        for (gp = np->first_newsgroup_alt; gp; gp = gp->next2) {\n          if (GroupInTable(gp)) {\n            output_newsgroup_line(np,gp,xfp);\n          }\n        }\n        break;\n\n   case NEWSRC_ORDER:        /* not implemented - fall through */\n   case ALPHABETICAL_ORDER:\n   default:                  /* default is alphabetical order */\n        for (gp = np->first_newsgroup; gp; gp = gp->next) {\n          if (GroupInTable(gp)) {\n            output_newsgroup_line(np,gp,xfp);\n          }\n        }\n        break;\n }\n\n fprintf(xfp,\"\\n\");\n\n if (ferror(xfp)){\n   ERR2(\"An error occurred writing to %s.\", ep->dsname);\n }\n else {\n   WARN2(\"A list of titles has been written to %s.\", ep->dsname);\n }\n\n (ep->closer)(np,ep,xfp,TRUE);     /* Close the file */\n\n return TRUE;\n\n}\n\n./ ADD NAME=NNMXTX\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"NN@XTX  \")\n#pragma  csect(static,\"NN$XTX  \")\n#include \"nn.h\"\n\n#define XFPUTC(A)     np->extract_write_error = (fputc((A),xfp) == EOF)\n\n#define XFWRITE(A,B)  fwrite((A),(B),1,xfp), \\\n                      np->extract_write_error = (ferror(xfp) != 0)\n\n/****** Extract the lines of server text into a data set. ************/\n\nBool\nNNMxtx(np,ap,headerstoo)\nRstruc nncb         *np;\nRstruc newsarticle  *ap;\nFool                 headerstoo;\n{\n FILE               *xfp;\n struct texthdr     *thp;\n struct textline    *tp;\n struct extraction  *ep;\n int                 l;\n int                 linelen;\n char               *cp;\n Bool                printing;\n char                formatted_number \u00dd11\u00a8;\n struct extraction   the_extraction;\n\n /* If article is not specified, use main nncb, else article's text */\n\n thp = (ap ? &ap->thdr : &np->thdr);\n\n printing = np->printing;\n np->printing = FALSE;\n\n /* Set article data for message. */\n\n if (ap) {\n   sprintf(formatted_number,\"%d\",ap->number);\n   (void)NNMivput(np,\"NNTNUM \",  formatted_number, -1);\n   (void)NNMivput(np,\"NNTSUBJ \", ap->subject,      -1);\n }\n else {\n   (void)NNMivput(np,\"NNTNUM \",  \"\", -1);\n   (void)NNMivput(np,\"NNTSUBJ \", \"\", -1);\n }\n\n if (np->extract_file) {\n   if (!np->following_up) {\n     (void)NNMispf(np,\"CONTROL DISPLAY LOCK\");\n     if (printing)\n        (void)NNMispf(np,\"DISPLAY PANEL(NNMLPRN2)\");\n     else\n        (void)NNMispf(np,\"DISPLAY PANEL(NNMLEXN2)\");\n   }\n   xfp = np->extract_file;\n   ep = np->extractionp;\n }\n else {\n\n   ep = &the_extraction;\n   memset(ep,0,sizeof(struct extraction));\n   if (printing) {\n     ep->mode = JES;\n     strcpy(ep->panelname,\"NNMPPRDS\");\n   }\n   else {\n     ep->mode = SEQ;\n     strcpy(ep->panelname,\"NNMPEXDS\");\n   }\n\n   if (!((xfp=NNMgetds(np,ep)))) return FALSE;\n\n   np->extract_tab_expanding          = ep->tab_expanding;\n   np->extract_appending              = ep->appending;\n   np->extract_ejecting               = ep->ejecting;\n   np->extract_blank_before_separator = ep->blanking;\n   np->extract_separator_line         = ep->separator;\n }\n\n /* If append mode, and a separator line was specified, use it. */\n\n np->extract_write_error = FALSE;\n np->extract_close_error = FALSE;\n\n if (np->extract_ejecting) {\n   XFPUTC('\\f');\n }\n\n if (np->extract_appending) {\n   XFPUTC('\\n');\n   if (np->extract_separator_line && *np->extract_separator_line) {\n     XFWRITE(np->extract_separator_line,\n             strlen(np->extract_separator_line));\n     XFPUTC('\\n');\n     if (np->extract_blank_before_separator) XFPUTC('\\n');\n   }\n }\n\n if      (headerstoo)               tp = thp->first_text_line;\n else if ((tp=thp->text_body_line)) tp = tp->next;\n\n linelen = (printing ? 120 : 251);\n\n for (; tp && !np->extract_write_error; tp = tp->next) {\n   if (tp->text_length == 0) {\n     if (np->following_up) XFPUTC('>');\n     XFPUTC('\\n');\n   }\n   else if (tp->text_length > 0) {\n     if (np->extract_tab_expanding) {\n       cp = tp->tab_expanded_text;\n       l  = tp->tab_expanded_text_length;\n     }\n     else {\n       cp = tp->text;\n       l  = tp->text_length;\n     }\n     for (; l>0 && !np->extract_write_error; cp+=linelen, l-=linelen) {\n       if (np->following_up) XFPUTC('>');\n       XFWRITE(cp,(l > linelen ? linelen : l));\n       XFPUTC('\\n');\n     }\n   }\n }\n\n if (!np->extract_write_error && ferror(xfp))\n    np->extract_write_error = TRUE;\n\n if (!np->following_up) {\n   if (!np->extract_appending || !np->extract_file) {\n     (ep->closer)(np,ep,xfp,printing);   /* Close the file */\n     if (np->extract_close_error) return FALSE;\n   }\n }\n if (!np->extract_file) {\n   if (np->extract_write_error) {\n     ERR2(\"An error occurred writing to %s.\",ep->dsname);\n     np->extract_write_error = TRUE;\n   }\n   else if (ap) {\n     WARN3(\"Article %d has been written to %s.\",ap->number,ep->dsname);\n   }\n   else {\n     WARN2(\"Displayed text has been written to %s.\",ep->dsname);\n   }\n }\n if (np->extract_write_error) return FALSE;\n else return TRUE;\n}\n\n./ ENDUP\n?!\n//PANELS   EXEC MDLOAD,BS='6160',TRK1='10',TRK2='1',TO='PANELS'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=NNL\n)ATTR\n ~ TYPE(INPUT)  INTENS(HIGH) PAD('_')\n # TYPE(INPUT)  INTENS(LOW)  CAPS(OFF)\n $ TYPE(INPUT)  INTENS(LOW)  CAPS(ON)\n)BODY\n%---------------  NETNEWS SERVER SELECTION MENU  -------------------------------\n%Command ===>_ZCMD                                            %Scroll ===>_AMT +\n%\n+Line commands:    %D+(Delete) %I+(Insert) %R+(Replicate) %S+(Select)\n%\n%    Server                                       NEWSRC dsname\n%    -------------------------------------------- ------------------------------\n)MODEL\n%~Z%#SERVER                                      $NEWSRC\n)INIT\n  .ZVARS = '(NNSEL)'\n  &AMT = &ZSCML\n)PROC\n  IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n  &ZSCML = &AMT\n  VPUT (ZSCML) PROFILE\n)END\n /* Panel due to Leonard D. Woren <ldw@mvsa.usc.edu>. */\n./ ADD NAME=NNM\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) CAPS(OFF)\n ! TYPE(TEXT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Viewer -`-`-\n%COMMAND ===>_ZCMD\n+\n+Select one of the following options:\n+\n+ %L+or%blank+   - List all newsgroups from server\n+ %N +NEWGROUPS  - List new newsgroups from server since last N or L\n+ %A +ALL        - Select items from all newsgroups listed in NEWSRC file\n+ %R +REGISTERED - Select items from registered newsgroups in NEWSRC file\n+ %G +GROUP      - Go directly to the newsgroup named below\n+ %NNTP+         - Enter native NNTP protocol commands\n+ %OPTions+      - Specify NNMVS defaults\n+ %X +EXIT       - Bye\n+\n%Newsgroup name +(if option G selected)%===>\u00acNNGROUPI\n+\n%News server host name+(or IP address) %===>_NNSERVER\n+\n%Name of NEWSRC data set               %===>_NNNEWSRF\n+\n+Press!END+key to leave this menu.\n)INIT\n .HELP = TNNM\n IF (&NNCURSOR = &Z)\n  IF (&NNSERVER = &Z)\n   .CURSOR = NNSERVER\n  ELSE\n   .CURSOR = ZCMD\n ELSE\n  .CURSOR = &NNCURSOR\n &ZCMD = &Z\n IF (&NNREGNNG = &Z) &NNREGNNG = PROMPT\n IF (&NNNEWSRF = &Z) &NNNEWSRF = NEWSRC\n)PROC\n IF   (&NNGROUPI \u00ac= &Z) VER(&ZCMD,NB)\n IF   (&ZCMD = ' ')  &ZCMD = 'L'      /* remove if you hate BLANK */\n &ZCMD = TRANS(&ZCMD A,A R,R L,L G,G N,N\n                     O,O OPT,O OPTIONS,O NNTP,P P,P X,X LD,Z *,?)\n IF   (&ZCMD \u00ac= 'X') VER (&NNSERVER,NB)\n IF   (&ZCMD = 'G')  VER (&NNGROUPI,NB)\n &NNREGNNG = TRUNC(&NNREGNNG,1)\n VER  (&NNREGNNG,NB,LIST,Y,N,P)\n VER  (&NNNEWSRF,NB,DSNAME)\n &TEMP1 = TRUNC(&NNNEWSRF,1)\n &TEMP2 = .TRAIL\n IF (&TEMP1 = '''')\n  &NNNEWSRC = TRUNC(&TEMP2,'''')\n ELSE\n  &NNNEWSRC = '&ZPREFIX..&NNNEWSRF'\n VPUT (NNGROUPI NNSERVER NNREGNNG NNNEWSRF) PROFILE\n)END\n./ ADD NAME=NNMDAR\n)ATTR DEFAULT(%+\\)\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n ~ TYPE(INPUT) INTENS(HIGH)  CAPS(OFF) JUST(LEFT)\n \u00ac TYPE(INPUT) INTENS(HIGH)  CAPS(OFF) JUST(LEFT)\n |  AREA(DYNAMIC) EXTEND(ON) SCROLL(ON)\n 01 TYPE(DATAOUT) INTENS(LOW)\n 02 TYPE(DATAOUT) INTENS(HIGH)\n 03 TYPE(DATAIN)  INTENS(LOW)\n 04 TYPE(DATAIN)  INTENS(HIGH)\n 05 TYPE(DATAOUT) COLOR(GREEN)\n 06 TYPE(DATAOUT) COLOR(PINK)\n 07 TYPE(DATAOUT) COLOR(RED)\n 08 TYPE(DATAOUT) COLOR(TURQ)\n 09 TYPE(DATAOUT) COLOR(YELLOW)\n 0A TYPE(DATAIN)  COLOR(BLUE)\n 0B TYPE(DATAIN)  COLOR(PINK)\n 0C TYPE(DATAIN)  COLOR(TURQ)\n 0D TYPE(DATAIN)  COLOR(WHITE)\n 0E TYPE(DATAIN)  COLOR(YELLOW)\n)BODY EXPAND(``)\n%&NNTHEAD\n%COMMAND ===>~NNTCMD                                          %SCROLL ===>\u00acNNTS+\n+                                                                              %\nArticle:%S+select%E+extract%P+print%M+mark%U+unmark%C+cancel%Status   Date\n _______________________________________________________________________________\n|NNTDYNA                                                                       |\n)INIT\n .HELP = TNNMT\n IF (&NNTS = &Z) &NNTS = CSR\n IF (&NNTCSR \u00ac= 0)\n  .CURSOR=NNTDYNA\n  .CSRPOS=&NNTCSR\n)PROC\n &NNTLVL = LVLINE(NNTDYNA)\n VPUT (NNTS) PROFILE\n)END\n./ ADD NAME=NNMDBOGG\n)ATTR DEFAULT(%+_)\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac  TYPE(INPUT)  INTENS(HIGH) CAPS(ON) JUST(LEFT)\n |  AREA(DYNAMIC) EXTEND(ON) SCROLL(ON)\n 01 TYPE(DATAOUT) INTENS(LOW)\n 02 TYPE(DATAOUT) INTENS(HIGH)\n 03 TYPE(DATAIN)  INTENS(LOW)\n 04 TYPE(DATAIN)  INTENS(HIGH)\n)BODY EXPAND(``)\n%-`-`- Unknown Newsgroups (found in NEWSRC but not by server) -`-`-\n%COMMAND ===>\u00acZCMD                                            %SCROLL ===>_AMT +\n\n+Groups displayed will be deleted from NEWSRC.  Scroll up/down to see all.\n+Type%K+to keep a group,%D+to delete. %&END+to accept. %QUIT+or%CANCEL+to abort.\n-------------------------------------------------------------------------------+\n|NNDYNA                                                                        |\n)INIT\n .HELP = TNNM\n &END = PFK(END)\n IF (&AMT = &Z) &AMT = CSR\n IF (&NNDB1ST = &Z)\n  &NNDB1ST = NO\n  .ALARM = YES\n)PROC\n VER (&ZCMD,LIST,QUIT,CAN,CANCEL)\n &NNLVL = LVLINE(NNDYNA)\n)END\n./ ADD NAME=NNMDNEWG\n)ATTR DEFAULT(%+_)\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac  TYPE(INPUT)  INTENS(HIGH) CAPS(ON) JUST(LEFT)\n |  AREA(DYNAMIC) EXTEND(ON) SCROLL(ON)\n 01 TYPE(DATAOUT) INTENS(LOW)\n 02 TYPE(DATAOUT) INTENS(HIGH)\n 03 TYPE(DATAIN)  INTENS(LOW)\n 04 TYPE(DATAIN)  INTENS(HIGH)\n)BODY EXPAND(``)\n%-`-`- New Newsgroups -`-`-\n%COMMAND ===>\u00acZCMD                                            %SCROLL ===>_AMT +\n\n+Type%R+to register a newsgroup; %D+to deregister. Scroll up/down to see all.\n+Registered group names highlighted. %&END+to accept. %QUIT+or%CANCEL+to abort.\n-------------------------------------------------------------------------------+\n|NNDYNA                                                                        |\n)INIT\n .HELP = TNNM\n &END = PFK(END)\n IF (&AMT = &Z) &AMT = CSR\n IF (&NNDN1ST = &Z)\n  &NNDN1ST = NO\n  .ALARM = YES\n)PROC\n VER (&ZCMD,LIST,QUIT,CAN,CANCEL)\n &NNLVL = LVLINE(NNDYNA)\n)END\n./ ADD NAME=NNMDNG\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n ~ TYPE(INPUT) INTENS(HIGH)  CAPS(OFF) JUST(LEFT)\n \u00ac TYPE(INPUT) INTENS(HIGH)  CAPS(OFF) JUST(LEFT)\n ! TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF) JUST(RIGHT) COLOR(YELLOW)\n # TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF) JUST(RIGHT) COLOR(BLUE)\n @ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(RIGHT) COLOR(PINK)\n ? TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF) JUST(LEFT)  COLOR(TURQ) PAD('.')\n |  AREA(DYNAMIC) EXTEND(ON) SCROLL(ON)\n \\  AREA(DYNAMIC) EXTEND(OFF) SCROLL(OFF)\n 01 TYPE(DATAOUT) INTENS(LOW)\n 02 TYPE(DATAOUT) INTENS(HIGH)\n 03 TYPE(DATAIN)  INTENS(LOW)\n 04 TYPE(DATAIN)  INTENS(HIGH)\n 05 TYPE(DATAOUT) COLOR(GREEN)\n 06 TYPE(DATAOUT) COLOR(PINK)\n 07 TYPE(DATAOUT) COLOR(RED)\n 08 TYPE(DATAOUT) COLOR(TURQ)\n 09 TYPE(DATAOUT) COLOR(YELLOW)\n 0A TYPE(DATAIN)  COLOR(BLUE)\n 0B TYPE(DATAIN)  COLOR(PINK)\n 0C TYPE(DATAIN)  COLOR(TURQ)\n 0D TYPE(DATAIN)  COLOR(WHITE)\n 0E TYPE(DATAIN)  COLOR(YELLOW)\n)BODY EXPAND(``)\n%&NNGHEAD\n%COMMAND ===>~NNGCMD                                          %SCROLL ===>\u00acNNGS+\n+\n\\NNGLINE                                                                       \\\n -------------------------------------------------------------------------------\n|NNGDYNA                                                                       |\n)INIT\n .HELP = TNNMG\n IF (&NNGS = &Z) &NNGS = CSR\n IF (&NNGCSR \u00ac= 0)\n  .CURSOR=NNGDYNA\n  .CSRPOS=&NNGCSR\n)PROC\n &NNGLVL = LVLINE(NNGDYNA)\n VPUT (NNGS) PROFILE\n)END\n./ ADD NAME=NNMLADDG\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n @ TYPE(OUTPUT) INTENS(LOW)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n+\n         Adding newsgroup:\n%        &NNLGROUP\n+\n         (Estimated number of articles...&NNLCOUNT)\n+        @NNDUMMY\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMLADD2\n)ATTR DEFAULT(|+_)\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ) HILITE(REVERSE)\n / TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ)\n * AREA(DYNAMIC)\n)BODY EXPAND(``)\n|-`-`-  MVS Network News Connection -`-`-\n+\n\n         Now adding newsgroups\n\n+\n         Percentage of news groups processed:\n         ------------------------------------------------------------\n        *NNMBAR                                                     *|&NNMCOUNT\n+        ------------------------------------------------------------\n        0%                          50%                              100%\n\n     This may take a long time, depending on the number of newsgroups.\n\n\n|                                  Please wait.\n\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMLADD3\n)ATTR DEFAULT(|+_)\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ) HILITE(REVERSE)\n / TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ)\n * AREA(DYNAMIC)\n)BODY EXPAND(``)\n|-`-`-  MVS Network News Connection -`-`-\n+\n\n         Now adding newsgroup:\n        |&NNLGROUP\n+\n         Percentage of news groups processed:\n         ------------------------------------------------------------\n        *NNMBAR                                                     *|&NNMCOUNT\n+        ------------------------------------------------------------\n        0%                          50%                              100%\n\n     This may take a long time, depending on the number of newsgroups.\n\n\n|                                  Please wait.\n\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMLARTS\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n+\n         Now retrieving the titles of the articles in newsgroup:\n%        &NNGROUP\n+\n     This may take a long time, depending on the number of articles.\n+\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMLART2\n)ATTR DEFAULT(|+_)\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ) HILITE(REVERSE)\n / TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ)\n * AREA(DYNAMIC)\n $ TYPE(TEXT) INTENS(LOW)\n # TYPE(OUTPUT) INTENS(HIGH)\n)BODY EXPAND(``)\n|-`-`-  MVS Network News Connection -`-`-\n+\n\n         Now retrieving the titles of the articles in newsgroup:\n        |&NNGROUP\n+\n         &MSG\n+        ------------------------------------------------------------\n        *NNMBAR                                                     *|&TODO\n+        ------------------------------------------------------------\n        0%                          50%                              100%\n\n        $Estimated time to completion:#NNMESTM +\n\n     This may take a long time, depending on the number of articles.\n\n\n|                                  Please wait.\n\n)INIT\n IF (&NNMESTM = &Z)\n   .ATTRCHAR($) = 'INTENS(NON)'\n   .ATTRCHAR(#) = 'INTENS(NON)'\n IF (&NNMCOUNT = -1)\n  &TODO = &Z\n  &MSG = 'Articles processed so far while searching:'\n ELSE\n  &TODO = &NNMCOUNT\n  &MSG = 'Percentage of articles processed so far:'\n)PROC\n)END\n./ ADD NAME=NNMLCONN\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n+             Client name: &NNCLIENT    Client IP address:  &NNCLIEIP\n+\n+\n+             Connection is in progress for news server at:\n              &NNSERVER (&NNSERVIP)\n+\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMLDISC\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n+\n+         Disconnection is in progress from the news server at:\n          &NNSOLDER (&NNSOLDIP)\n+\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMLEXN2\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n+Newsgroup: &NNLGROUP\n+\n+Article #:%&NNTNUM\n+Subject:   &NNTSUBJ\n+\n+Extracting to: &NNEXDSN\n+&MEMSTUFF\n+\n                                 % Please wait.\n+\n)INIT\n IF (&NNEXMEM = &Z) &MEMSTUFF = &Z\n ELSE               &MEMSTUFF = 'Member: &NNEXMEM'\n)PROC\n)END\n./ ADD NAME=NNMLLIST\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n+\n       A list of all newsgroups is being retrieved from the news server at:\n       &NNSERVER (&NNSERVIP)\n+\n     This may take a long time, depending on the number of newsgroups known.\n+\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMLNEWG\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n+\n       A list of new newsgroups since &NNNGDT &NNNGTM is being retrieved\n+      from the news server at:  &NNSERVER (&NNSERVIP)\n+\n     This may take a long time, depending on the number of newsgroups known.\n+\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMLPRN2\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n+Newsgroup: &NNLGROUP\n+\n+Article #:%&NNTNUM\n+Subject:   &NNTSUBJ\n+\n+Printing to SYSOUT class: &NNEXSCL\n+&MEMSTUFF\n+\n                                 % Please wait.\n+\n)INIT\n IF (&NNEXMEM = &Z) &MEMSTUFF = &Z\n ELSE               &MEMSTUFF = 'Member: &NNEXMEM'\n)PROC\n)END\n./ ADD NAME=NNMLRCON\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n        +Connection has apparently been lost to the news server at:\n        &NNSERVER (&NNSERVIP)\n+\n                +Reconnection to the server is in progress.\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMLRETG\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n+\n         Retrieving current status of newsgroup:\n%        &NNLGROUP\n+\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMLRET2\n)ATTR DEFAULT(|+_)\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ) HILITE(REVERSE)\n / TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ)\n * AREA(DYNAMIC)\n $ TYPE(TEXT) INTENS(LOW)\n # TYPE(OUTPUT) INTENS(HIGH)\n)BODY EXPAND(``)\n|-`-`-  MVS Network News Connection -`-`-\n+\n+\n+        Retrieving current status of registered newsgroups\n+\n+\n+        Percentage of registered newsgroups processed:\n+        ------------------------------------------------------------\n+       *NNMBAR                                                     *|&NNMCOUNT\n+        ------------------------------------------------------------\n+       0%                          50%                              100%\n+\n+       $Estimated time to completion:#NNMESTM +\n+\n)INIT\n IF (&NNMESTM = &Z)\n   .ATTRCHAR($) = 'INTENS(NON)'\n   .ATTRCHAR(#) = 'INTENS(NON)'\n)PROC\n)END\n./ ADD NAME=NNMLRET3\n)ATTR DEFAULT(|+_)\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ) HILITE(REVERSE)\n / TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ)\n * AREA(DYNAMIC)\n $ TYPE(TEXT) INTENS(LOW)\n # TYPE(OUTPUT) INTENS(HIGH)\n)BODY EXPAND(``)\n|-`-`-  MVS Network News Connection -`-`-\n+\n+\n+        Retrieving current status of newsgroup:\n|        &NNLGROUP\n+\n+        Percentage of registered newsgroups processed:\n+        ------------------------------------------------------------\n+       *NNMBAR                                                     *|&NNMCOUNT\n+        ------------------------------------------------------------\n+       0%                          50%                              100%\n+\n+       $Estimated time to completion:#NNMESTM +\n+\n)INIT\n IF (&NNMESTM = &Z)\n   .ATTRCHAR($) = 'INTENS(NON)'\n   .ATTRCHAR(#) = 'INTENS(NON)'\n)PROC\n)END\n./ ADD NAME=NNMLRSNG\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n+         Reconnection has been established to the news server at:\n          &NNSERVER (&NNSERVIP)\n+\n          Now reestablishing current newsgroup:\n%         &NNGROUP\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMLUNRC\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Connection -`-`-\n+\n+\n+                       Updating NEWSRC file &NNNEWSRF ...\n+\n+\n+\n%                                  Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./ ADD NAME=NNMOPTS\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n)BODY EXPAND(``)\n%-`-`- NNMVS - Article Retrieval Options -`-`-\n%Command ===>_ZCMD\n+\n%General options:\n\n+In-progress screen for adding newsgroups?  (YES/NO)%==>_Z  +\n+In-progress screen for rewriting NEWSRC?   (YES/NO)%==>_Z  +\n+In-progress screen for retrieving articles?(YES/NO)%==>_Z  +\n\n+Screen update frequency   %==>_Z       + (Enter%ON, OFF,+or%number+of seconds)\n\n%EXTRACT prompting options:\n\n+Warning panel before writing over an existing dataset?%==>_Z  +\n+Warning panel before appending to an existing dataset?%==>_Z  +\n\n+Press%ENTER+to change options.  Press%&END+(or type%END+command) when done.\n)INIT\n .ZVARS  = '(NNUPAN NNUPRN NNUPRA NNMUPDTF NNEXTPOW NNEXTPAP)'\n .HELP   = TNNMOPT\n .CURSOR = ZCMD\n &END = PFK(END)\n &ZCMD = &Z\n VGET (NNUPAN NNUPRN NNUPRA NNMUPDTF NNEXTPOW NNEXTPAP) PROFILE\n IF (&NNMUPDTF = &Z) &NNMUPDTF = '5'\n &NNUPAN   = TRANS(TRUNC(&NNUPAN,1)   Y,YES N,NO *,NO )\n &NNUPRN   = TRANS(TRUNC(&NNUPRN,1)   Y,YES N,NO *,YES)\n &NNUPRA   = TRANS(TRUNC(&NNUPRA,1)   Y,YES N,NO *,YES)\n &NNEXTPOW = TRANS(TRUNC(&NNEXTPOW,1) Y,YES N,NO *,YES)\n &NNEXTPAP = TRANS(TRUNC(&NNEXTPAP,1) Y,YES N,NO *,YES)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n IF (.RESP = ENTER)\n  VER(&NNMUPDTF,NB)\n  IF (&NNMUPDTF = '0')  &NNMUPDTF = 'ON'\n  IF (&NNMUPDTF = 'ON','OFF')\n  ELSE\n    VER(&NNMUPDTF,NUM)\n  &NNUPAN   = TRUNC(&NNUPAN,1)\n  &NNUPRN   = TRUNC(&NNUPRN,1)\n  &NNUPRA   = TRUNC(&NNUPRA,1)\n  &NNEXTPOW = TRUNC(&NNEXTPOW,1)\n  &NNEXTPAP = TRUNC(&NNEXTPAP,1)\n  VER(&NNUPAN  ,NB,LIST,Y,N)\n  VER(&NNUPRN  ,NB,LIST,Y,N)\n  VER(&NNUPRA  ,NB,LIST,Y,N)\n  VER(&NNEXTPOW,NB,LIST,Y,N)\n VPUT (NNUPAN NNUPRN NNUPRA NNMUPDTF NNEXTPOW NNEXTPAP) PROFILE\n)END\n./ ADD NAME=NNMOPTT\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n)BODY EXPAND(``)\n%-`-`- NNMVS - Table Viewing Options -`-`-\n%Command ===>_ZCMD\n+\n%Newsgroup table options:\n\n+Scroll last selected newsgroup to top? (YES/NO)%==>_Z  +\n+Put cursor at last selected newsgroup? (YES/NO)%==>_Z  +\n\n%Article table options:\n\n+Scroll last selected article to top?   (YES/NO)%==>_Z  +\n+Put cursor at last selected article?   (YES/NO)%==>_Z  +\n\n+Number of heading rows to display per article  %==>_Z+  (Enter%1, 2+or%3+only)\n\n\n+Press%ENTER+to change options.  Press%&END+(or type%END+command) when done.\n)INIT\n .ZVARS  = '(NNNGSCR NNNGCSR NNARSCR NNARCSR NNARROWS)'\n .HELP   = TNNMOPT\n .CURSOR = ZCMD\n &END = PFK(END)\n &ZCMD = &Z\n VGET (NNNGSCR NNNGCSR NNARSCR NNARCSR NNARROWS) PROFILE\n &NNNGSCR  = TRANS(TRUNC(&NNNGSCR,1)  Y,YES N,NO *,YES)\n &NNNGCSR  = TRANS(TRUNC(&NNNGCSR,1)  Y,YES N,NO *,NO)\n &NNARSCR  = TRANS(TRUNC(&NNARSCR,1)  Y,YES N,NO *,YES)\n &NNARCSR  = TRANS(TRUNC(&NNARCSR,1)  Y,YES N,NO *,NO)\n &NNARROWS = TRANS(&NNARROWS 1,1 2,2 3,3 *,1)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n IF (.RESP = ENTER)\n  &NNNGSCR  = TRUNC(&NNNGSCR,1)\n  &NNNGCSR  = TRUNC(&NNNGCSR,1)\n  &NNARSCR  = TRUNC(&NNARSCR,1)\n  &NNARCSR  = TRUNC(&NNARCSR,1)\n  VER(&NNNGSCR,NB,LIST,Y,N)\n  VER(&NNNGCSR,NB,LIST,Y,N)\n  VER(&NNARSCR,NB,LIST,Y,N)\n  VER(&NNARCSR,NB,LIST,Y,N)\n  VER(&NNARROWS,NB,LIST,1,2,3)\n VPUT (NNNGSCR NNNGCSR NNARSCR NNARCSR NNARROWS) PROFILE\n)END\n./ ADD NAME=NNMPAUTH\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n)BODY WINDOW(62,14)\n+\n%Command ===>_ZCMD\n+\n NNMVS could not obtain authorization from the NNTP server.\n You may proceed, but you should be aware that some news\n reading or posting operations may fail.\n\n The response from server &NNSERVER was:\n\n%&NNSRVRSP\n+\n Press%ENTER+to proceed.\n Press%END  +to return to the NNMVS primary menu.\n)INIT\n .HELP = TNNM\n &ZWINTTL = 'Server authorization failed'\n &END = PFK(END)\n &ZCMD = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n)END\n./ ADD NAME=NNMPCAN\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(64,14)\n+\n%Command ===>\u00acZCMD\n+\n+Newsgroup :%&NNCGROUP\n+Article:   %&NNCNUM\n+Message-ID:%&NNCMSGID\n+Subject:   %&NNCSUBJ\n\n\n+This action will forward a CANCEL request to the news server.\n+\n+Press%ENTER+to proceed to cancel this article.\n+\n+Press%&END (END)+to abandon the request and leave the article.\n)INIT\n .HELP = TNNM\n &ZWINTTL = 'Confirm Article Cancellation'\n &END = PFK(END)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n)END\n./ ADD NAME=NNMPCONM\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n)BODY WINDOW(49,10)\n+\n%Command ===>_ZCMD\n\n+To:     %&NNMAILTO\n+Subject:%&NNMAILSJ\n\n+Press%ENTER     +to mail this message.\n+Press%&END (END)+to return to the mail menu.\n+Enter%CANCEL    +to cancel the message.\n)INIT\n .HELP = TNNM\n &ZWINTTL = 'Confirm mailing'\n &END = PFK(END)\n &ZCMD = &Z\n)PROC\n VER(&ZCMD,LIST,CAN,CANCEL)\n)END\n./ ADD NAME=NNMPCONP\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n)BODY WINDOW(49,10)\n+\n%Command ===>_ZCMD\n\n+Newsgroups:%&NNPOSTNG\n+Subject:   %&NNPOSTSJ\n\n+Press%ENTER     +to post this article.\n+Press%&END (END)+to return to the posting menu.\n+Enter%CANCEL    +to cancel the post.\n)INIT\n .HELP = TNNM\n &ZWINTTL = 'Confirm posting'\n &END = PFK(END)\n &ZCMD = &Z\n)PROC\n VER(&ZCMD,LIST,CAN,CANCEL)\n)END\n./ ADD NAME=NNMPEXDS\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,16)\n+\n%Command ===>\u00acZCMD\n+\n+&NUMBER       %&SUBJECT\n+\n+Save to data set ===>_NNEXDSN\n+Expand tab characters?       ===>_Z  +\n\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n\n+Append to end of data set?   ===>_Z  +\n+Blank line after separator?  ===>_Z  +\n+Separator line between articles (append mode only...blank for none):\n+>\u00acZ                                                                       +<\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .HELP = TNNM\n .ZVARS = '(NNEXTAB NNEXAPP NNEXBLK NNEXSEP)'\n .CURSOR = NNEXDSN\n IF (&NNTNUM \u00ac= &Z)\n  &ZWINTTL = 'Extract from &NNGROUP'\n  &NUMBER  = 'Article &NNTNUM: '\n  &SUBJECT = '&NNTSUBJ'\n ELSE\n  &ZWINTTL = 'Extract text'\n  &NUMBER  = ' '\n  &SUBJECT = ' '\n &END = PFK(END)\n &ZCMD = &Z\n VGET (NNEXDSN NNEXTAB NNEXAPP NNEXBLK NNEXSEP) PROFILE\n &NNEXTAB = TRANS(&NNEXTAB Y,YES N,NO ' ',NO)\n &NNEXAPP = TRANS(&NNEXAPP Y,YES N,NO ' ',NO)\n &NNEXBLK = TRANS(&NNEXBLK Y,YES N,NO ' ',NO)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&NNEXDSN,NB,DSNAME)\n &NNEXTAB = TRUNC(&NNEXTAB,1)\n VER(&NNEXTAB,NB,LIST,Y,N)\n &NNEXAPP = TRUNC(&NNEXAPP,1)\n VER(&NNEXAPP,NB,LIST,Y,N)\n &NNEXBLK = TRUNC(&NNEXBLK,1)\n VER(&NNEXBLK,NB,LIST,Y,N)\n VPUT (NNEXDSN NNEXTAB NNEXAPP NNEXBLK NNEXSEP) PROFILE\n)END\n./ ADD NAME=NNMPEXNG\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,14)\n+\n%Command ===>\u00acZCMD\n+\n+Save to data set ===>_NNEXDSN\n\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n\n+Append to end of data set?   ===>_Z  +\n+Blank line after separator?  ===>_Z  +\n+Separator line between articles (append mode only...blank for none):\n+>\u00acZ                                                                       +<\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .HELP = TNNM\n .ZVARS = '(NNEXAPP NNEXBLK NNEXSEP)'\n .CURSOR = NNEXDSN\n &ZWINTTL = 'Extract newsgroup listing'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (NNEXDSN NNEXAPP NNEXBLK NNEXSEP) PROFILE\n &NNEXAPP = TRANS(&NNEXAPP Y,YES N,NO ' ',NO)\n &NNEXBLK = TRANS(&NNEXBLK Y,YES N,NO ' ',NO)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&NNEXDSN,NB,DSNAME)\n &NNEXAPP = TRUNC(&NNEXAPP,1)\n VER(&NNEXAPP,NB,LIST,Y,N)\n &NNEXBLK = TRUNC(&NNEXBLK,1)\n VER(&NNEXBLK,NB,LIST,Y,N)\n VPUT (NNEXDSN NNEXAPP NNEXBLK NNEXSEP) PROFILE\n)END\n./ ADD NAME=NNMPEXNP\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY EXPAND(``) WINDOW(77,14)\n+\n%Command ===>\u00acZCMD\n+\n+Data set name%===>_NNEXPDS\n+Member prefix%===>_NNEXPMP + (article number appended - default is%#+)\n\n+Note: The dataset must be a PDS (old or new) with RECFM=VB and LRECL=259.\n\n+Expand tab characters?      %===>_Z  +\n\n+From article number%===>_NNEXAN1      + (blank for first article in table)\n+To   article number%===>_NNEXAN2      + (blank for last article in table)\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .HELP = TNNM\n .ZVARS = '(NNEXTAB)'\n .CURSOR = ZCMD\n &ZWINTTL = 'Log text of articles in &NNGROUP to PDS members'\n &NUMBER = ' &NNTNUM: '\n &END = PFK(END)\n &ZCMD = &Z\n VGET (NNEXPDS NNEXPMP NNEXTAB) PROFILE\n &NNEXTAB = TRANS(&NNEXTAB Y,YES N,NO ' ',NO)\n IF (&NNEXPMP = &Z) &NNEXPMP = '#'\n &NNEXAN1 = &Z\n &NNEXAN2 = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n &NNEXTAB = TRUNC(&NNEXTAB,1)\n VER(&NNEXTAB,NB,LIST,Y,N)\n VER(&NNEXPDS,NB,DSNAME)\n &TEMP1 = TRUNC(&NNEXPDS,1)\n &TEMP2 = .TRAIL\n IF (&TEMP1 = '''')\n  &NNEXDSN = TRUNC(&TEMP2,'''')\n ELSE\n  &NNEXDSN = '&ZPREFIX..&NNEXPDS'\n  VER(&NNEXPMP,NB,NAME)\n VER(&NNEXAN1,NUM)\n VER(&NNEXAN2,NUM)\n VPUT (NNEXPDS NNEXPMP NNEXTAB) PROFILE\n)END\n./ ADD NAME=NNMPEXNS\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY EXPAND(``) WINDOW(77,17)\n+\n%Command ===>\u00acZCMD\n+\n+Data set name%===>_NNEXSEQ\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n+\n+Expand tab characters?      %===>_Z  +\n+\n+Append to end of data set?  %===>_Z  +\n+Blank line after separator? %===>_Z  +\n+Separator line before each article (leave blank for none):\n+>\u00acZ                                                                       +<\n\n+From article number%===>_NNEXAN1      + (blank for first article in table)\n+To   article number%===>_NNEXAN2      + (blank for last article in table)\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .HELP = TNNM\n .ZVARS = '(NNEXTAB NNEXAPP NNEXBLK NNEXSEP)'\n .CURSOR = ZCMD\n &ZWINTTL = 'Log text of articles in &NNGROUP to sequential file'\n &NUMBER = ' &NNTNUM: '\n &END = PFK(END)\n &ZCMD = &Z\n VGET (NNEXSEQ NNEXTAB NNEXAPP NNEXBLK NNEXSEP) PROFILE\n &NNEXTAB = TRANS(&NNEXTAB Y,YES N,NO ' ',NO)\n &NNEXAPP = TRANS(&NNEXAPP Y,YES N,NO ' ',NO)\n &NNEXBLK = TRANS(&NNEXBLK Y,YES N,NO ' ',NO)\n &NNEXAN1 = &Z\n &NNEXAN2 = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&NNEXSEQ,NB,DSNAME)\n &NNEXDSN = &NNEXSEQ\n &NNEXTAB = TRUNC(&NNEXTAB,1)\n VER(&NNEXTAB,NB,LIST,Y,N)\n &NNEXAPP = TRUNC(&NNEXAPP,1)\n VER(&NNEXAPP,NB,LIST,Y,N)\n &NNEXBLK = TRUNC(&NNEXBLK,1)\n VER(&NNEXBLK,NB,LIST,Y,N)\n VER(&NNEXAN1,NUM)\n VER(&NNEXAN2,NUM)\n VPUT (NNEXSEQ NNEXTAB NNEXAPP NNEXBLK NNEXSEP) PROFILE\n)END\n./ ADD NAME=NNMPEXNT\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,10)\n+\n%Command ===>\u00acZCMD\n+\n+Move cursor to choice (or type%S+next to choice) and press%ENTER+to select:\n+\n_A%1+- List%titles+of articles in table\n_B%2+- Log %text  +of articles to%sequential file+\n_C%3+- Log %text  +of articles to%members of PDS+\n+\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .HELP = TNNM\n .CURSOR = ZCMD\n &ZWINTTL = 'Extract news articles - titles or text'\n &END = PFK(END)\n &ZCMD = &Z\n &A = &Z\n &B = &Z\n &C = &Z\n)PROC\n VER(&ZCMD,LIST,1,2,3)\n IF (&ZCMD \u00ac= &Z)\n  &NNCHOICE = TRANS(&ZCMD 1 1 2 2 3 3 * ?)\n ELSE\n  &TEMP = '&A/&B/&C'\n  IF (&TEMP = '//')\n   &NNCHOICE = TRANS(.CURSOR A 1 B 2 C 3 * ?)\n  ELSE\n   &NNCHOICE = TRANS(&TEMP  'S//' 1\n                            '1//' 1\n                            '/S/' 2\n                            '/2/' 2\n                            '//S' 3\n                            '//3' 3\n                               * ?\n                   )\n)END\n./ ADD NAME=NNMPEXN1\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,14)\n+\n%Command ===>\u00acZCMD\n+\n+Save to data set ===>_NNEXDSN\n\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n\n+Append to end of data set?   ===>_Z  +\n+Blank line after separator?  ===>_Z  +\n+Separator line between articles (append mode only...blank for none):\n+>\u00acZ                                                                       +<\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .HELP = TNNM\n .ZVARS = '(NNEXAPP NNEXBLK NNEXSEP)'\n .CURSOR = NNEXDSN\n &ZWINTTL = 'Extract news article listing'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (NNEXDSN NNEXAPP NNEXBLK NNEXSEP) PROFILE\n &NNEXAPP = TRANS(&NNEXAPP Y,YES N,NO ' ',NO)\n &NNEXBLK = TRANS(&NNEXBLK Y,YES N,NO ' ',NO)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&NNEXDSN,NB,DSNAME)\n &NNEXAPP = TRUNC(&NNEXAPP,1)\n VER(&NNEXAPP,NB,LIST,Y,N)\n &NNEXBLK = TRUNC(&NNEXBLK,1)\n VER(&NNEXBLK,NB,LIST,Y,N)\n VPUT (NNEXDSN NNEXAPP NNEXBLK NNEXSEP) PROFILE\n)END\n./ ADD NAME=NNMPEXOW\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,10)\n+\n%Command ===>\u00acZCMD\n+\n+Dataset already exists:\n+\n%&NNEXDSN\n+\n+Press%ENTER+to%&ACTION\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n .HELP = TNNM\n .ALARM = YES\n &ZWINTTL = 'Extract To Existing Data Set'\n &END = PFK(END)\n &APP = TRUNC(&NNEXAPP,1)\n IF (&APP = Y) &ACTION = 'append to the end of the data set.'\n ELSE          &ACTION = 'overwrite the current data set.'\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n)END\n./ ADD NAME=NNMPEXPW\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,13)\n+\n%Command ===>\u00acZCMD\n+\n+Partitioned dataset already exists:\n+\n%&NNEXDSN\n+\n+If member names are generated that match existing members\n+of this PDS, they will be%overwritten.+\n+\n+Press%ENTER+to proceed to use this PDS.\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n .HELP = TNNM\n .ALARM = YES\n &ZWINTTL = 'Extract To Members of Existing PDS'\n &END = PFK(END)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n)END\n./ ADD NAME=NNMPGAUT\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n       @   TYPE(INPUT) INTENS(NON)  CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(64,14)\n+\n%Command ===>\u00acZCMD\n+\n+The NNTP server at &NNSERVER\n+requires authorization to perform this operation.\n+\n+Username (as known to NNTP server) ===>\u00acNNAUSER\n+Password (as known to NNTP server) ===>@NNAPASS\n+\n\n+Press%&END (END)+to abort the current request.\n)INIT\n .HELP = TNNM\n &ZWINTTL = 'Server Authorization Required'\n &NNAPASS = &Z\n &END = PFK(END)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&NNAUSER,NB)\n VER(&NNAPASS,NB)\n VPUT (NNAUSER) PROFILE\n)END\n./ ADD NAME=NNMPGREG\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,10)\n+\n%Command ===>\u00acZCMD\n+\n+Get current status of each newsgroup in your list?\n+(If you answer YES, it will take longer to start up.)\n+(If you answer NO, displayed status will be incomplete.)\n+\n%===>_Z  +\n\n+Press%&END (END)+to return to the previous panel.\n)INIT\n .HELP = TNNM\n .ZVARS = '(NNRGANS)'\n .CURSOR = NNRGANS\n &ZWINTTL = ''\n &END = PFK(END)\n &NNRGANS = Y\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n &NNRGANS = TRUNC(&NNRGANS,1)\n VER(&NNRGANS,NB,LIST,Y,N)\n)END\n./ ADD NAME=NNMPMALL\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(76,14)\n+\n%Command ===>\u00acZCMD\n+\n+Newsgroup:%&NNGNAME\n+\n+What exactly do you want to do?\n+\n_Z%*+Mark%all+articles in the newsgroup &NNMARK\n_Z%*+Mark%currently displayed+articles &NNMARK\n_Z%*+Cancel this request and return to previous panel\n\n+Move cursor to choice (or type%S+next to choice) and press%ENTER+to do it.\n+\n+Press%&END (END)+to cancel the request.\n)INIT\n .HELP = TNNM\n .ZVARS = '(S1 S2 S3)'\n .CURSOR = ZCMD\n &ZWINTTL = 'Confirm Marking All Articles in Newsgroup'\n &END = PFK(END)\n &ZCMD = &Z\n &S1   = &Z\n &S2   = &Z\n &S3   = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n &TEMP = '&S1/&S2/&S3'\n IF (&TEMP = '//')\n  &NNCHOICE = TRANS(.CURSOR S1 1 S2 2 S3 3 * ?)\n ELSE\n  &NNCHOICE = TRANS(&TEMP  'S//' 1\n                           '1//' 1\n                           '/S/' 2\n                           '/2/' 2\n                           '//S' 3\n                           '//3' 3\n                               * ?\n                  )\n)END\n./ ADD NAME=NNMPMARK\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,10)\n+\n%Command ===>\u00acZCMD\n+\n+Newsgroup:%&NNGNAME\n+\n+Be sure you really want to mark all articles%&NNMARK..\n+\n+Press%ENTER+to proceed with marking all articles.\n+\n+Press%&END (END)+to cancel the request.\n)INIT\n .HELP = TNNM\n &ZWINTTL = 'Confirm Marking All Articles in Newsgroup'\n &END = PFK(END)\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n)END\n./ ADD NAME=NNMPOPT\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,11)\n+\n%Command ===>\u00acZCMD\n+\n+Move cursor to choice (or type%S+next to choice) and press%ENTER+to select:\n+\n_Z%1+- RFC822 header display options\n_Z%2+- Article retrieval options\n_Z%3+- Table processing options\n+\n+Press%&END (END)+to return to the previous panel.\n)INIT\n .HELP = TNNMOPT\n .ZVARS = '(S1 S2 S3)'\n .CURSOR = ZCMD\n &ZWINTTL = 'Customize user options'\n &END = PFK(END)\n &ZCMD = &Z\n &S1   = &Z\n &S2   = &Z\n &S3   = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z)\n  &NNCHOICE = TRANS(&ZCMD 1 1 2 2 3 3 * ?)\n ELSE\n  &TEMP = '&S1/&S2/&S3'\n  IF (&TEMP = '//')\n   &NNCHOICE = TRANS(.CURSOR S1 1 S2 2 S3 3 * ?)\n  ELSE\n   &NNCHOICE = TRANS(&TEMP  'S//' 1\n                            '1//' 1\n                            '/S/' 2\n                            '/2/' 2\n                            '//S' 3\n                            '//3' 3\n                                * ?\n                   )\n)END\n./ ADD NAME=NNMPPRNT\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,9)\n+\n%Command ===>\u00acZCMD\n+\n+Move cursor to choice (or type%S+next to choice) and press%ENTER+to select:\n+\n_A%1+- Print%titles+of articles in table\n_B%2+- Print%text  +of articles\n+\n+Press%&END (END)+to cancel the print request.\n)INIT\n .HELP = TNNM\n .CURSOR = ZCMD\n &ZWINTTL = 'Print news articles - titles or text'\n &END = PFK(END)\n &ZCMD = &Z\n &A = &Z\n &B = &Z\n)PROC\n VER(&ZCMD,LIST,1,2)\n IF (&ZCMD \u00ac= &Z)\n  &NNCHOICE = TRANS(&ZCMD 1 1 2 2 * ?)\n ELSE\n  &TEMP = '&A/&B'\n  IF (&TEMP = '/')\n   &NNCHOICE = TRANS(.CURSOR A 1 B 2 * ?)\n  ELSE\n   &NNCHOICE = TRANS(&TEMP  'S/' 1\n                            '1/' 1\n                            '/S' 2\n                            '/2' 2\n                              * ?\n                   )\n)END\n./ ADD NAME=NNMPPRT\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n ~   TYPE(TEXT)  INTENS(HIGH)\n \\   TYPE(TEXT)  INTENS(LOW)\n {   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n }   TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(LEFT)\n #   TYPE(TEXT)  INTENS(LOW)\n @   TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(LEFT)\n)BODY WINDOW(77,19)\n+\n%Command ===>\u00acZCMD\n+\n+&NUMBER       %&SUBJECT\n+\n+SYSOUT class ===>_Z+   Number of copies ===>_Z  +\n#Destination  ===>@Z       #  Forms ===>@Z   #   UCS ===>@Z   +\n\n+(Note: Print data will be released to SYSOUT immediately.)\n+\n\\Page eject between articles?     ~===>}Z  +\n\\Blank line after separator?      ~===>}Z  +\n\\Separator line before each article (leave blank for none):\n\\>{Z                                                                       \\<\n\n\\From article number~===>}NNEXAN1      \\ (blank for first article in table)\n\\To   article number~===>}NNEXAN2      \\ (blank for last article in table)\n\n+Press%&END (END)+to cancel the print request.\n)INIT\n .HELP = TNNM\n .ZVARS =\n   '(NNEXSCL NNEXSCO NNEXSDE NNEXSFO NNEXSUC NNEXSPA NNEXBLK NNEXSEP)'\n .CURSOR = NNEXSCL\n &END = PFK(END)\n &ZCMD = &Z\n &NNEXSCO = 1\n &PVARS = 'NNEXSCL'\n IF (&NNALLPR \u00ac= &Z)\n  &PVARS = '&PVARS NNEXSDE NNEXSFO NNEXSUC'\n  .ATTRCHAR('#') = 'TYPE(TEXT)   INTENS(LOW)'\n  .ATTRCHAR('@') = 'TYPE(INPUT)  INTENS(HIGH) CAPS(ON)  JUST(LEFT)'\n ELSE\n  .ATTRCHAR('#') = 'TYPE(TEXT)   INTENS(NON)'\n  .ATTRCHAR('@') = 'TYPE(OUTPUT) INTENS(NON)'\n IF (&NNWHICH = NNMPPRNS)\n  .ATTRCHAR('~') = 'TYPE(TEXT)   INTENS(HIGH)'\n  .ATTRCHAR('\\') = 'TYPE(TEXT)   INTENS(LOW)'\n  .ATTRCHAR('{') = 'TYPE(INPUT)  INTENS(HIGH) CAPS(OFF) JUST(LEFT)'\n  .ATTRCHAR('}') = 'TYPE(INPUT)  INTENS(HIGH) CAPS(ON)  JUST(LEFT)'\n ELSE\n  .ATTRCHAR('~') = 'TYPE(TEXT)   INTENS(NON)'\n  .ATTRCHAR('\\') = 'TYPE(TEXT)   INTENS(NON)'\n  .ATTRCHAR('{') = 'TYPE(OUTPUT) INTENS(NON)'\n  .ATTRCHAR('}') = 'TYPE(OUTPUT) INTENS(NON)'\n IF (&NNWHICH = NNMPPRNG)\n  &ZWINTTL = 'Print newsgroup listing'\n IF (&NNWHICH = NNMPPRN1)\n  &ZWINTTL = 'Print news article listing'\n IF (&NNWHICH = NNMPPRDS)\n  IF (&NNTNUM \u00ac= &Z)\n   &ZWINTTL = 'Print from &NNGROUP'\n   &NUMBER  = 'Article &NNTNUM: '\n   &SUBJECT = '&NNTSUBJ'\n  ELSE\n   &ZWINTTL = 'Print text'\n   &NUMBER  = &Z\n   &SUBJECT = &Z\n ELSE\n  &NUMBER  = &Z\n  &SUBJECT = &Z\n IF (&NNWHICH = NNMPPRNS)\n  &PVARS = '&PVARS NNEXSPA NNEXBLK NNEXSEP'\n  &ZWINTTL = 'Print text of articles in &NNGROUP'\n  &NNEXSPA = TRANS(TRUNC(&NNEXSPA,1) Y,YES N,NO ' ',NO)\n  &NNEXBLK = TRANS(TRUNC(&NNEXBLK,1) Y,YES N,NO ' ',NO)\n  &NNEXSCO = 1\n  &NNEXAN1 = &Z\n  &NNEXAN2 = &Z\n VGET (&PVARS) PROFILE\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&NNEXSCL,NB)\n IF (&NNEXSCO = &Z) &NNEXSCO = 1\n VER(&NNEXSCO,NUM)\n VER(&NNEXSCO,RANGE,1,255)\n IF (&NNWHICH = NNMPPRNS)\n  &NNEXSPA = TRUNC(&NNEXSPA,1)\n  &NNEXBLK = TRUNC(&NNEXBLK,1)\n  VER(&NNEXSPA,NB,LIST,Y,N)\n  VER(&NNEXBLK,NB,LIST,Y,N)\n  VER(&NNEXAN1,NUM)\n  VER(&NNEXAN2,NUM)\n VPUT (&PVARS) PROFILE\n)END\n./ ADD NAME=NNMQMAIL\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY EXPAND(``)\n-`-`- Send a mail message or reply -`-`-\n%Command ===>\u00acZCMD\n+\n%Note:+This sends private mail to the individual sender named below.\n      +To transmit to the newsgroup, use the%POST+command, or use\n      +the%F (FOLLOWUP)+selection code.+\n+\n+&HEADING\n\n%Required Header Fields+\n\n+Mail to ===>\u00acNNMAILTO\n+Subject ===>\u00acNNMAILSJ\n\n%Optional Header Fields+\n\n+Reply to ==>\u00acNNMAILRT\n\n+Your human name ==>\u00acNNMAILFR\n+Signature file  ==>_NNMAILSF\n+Edit profile    ==>_NNEDPROF+\n\n+Press%ENTER+to proceed to the editor to compose the message.\n+Press%&END (END)+to cancel the mailing request.\n)INIT\n .HELP = TNNM\n IF (&NNMAILOT = &Z) &HEADING = 'New mail message'\n ELSE                &HEADING = 'Reply to message from &NNMAILOT'\n IF (&NNMAILTO = &Z) .CURSOR = NNMAILTO\n ELSE                .CURSOR = NNMAILSJ\n &ZWINTTL = 'Send a mail message or reply'\n &END = PFK(END)\n &ZCMD = &Z\n IF (&NNEDPROF = &Z) &NNEDPROF = TEXT\n /* IF (&NNMAILSF = &Z) &NNMAILSF = &NNPOSTSF */\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&NNMAILTO,NB)\n VER(&NNMAILSJ,NB)\n VER(&NNMAILSF,DSNAME)\n VER(&NNEDPROF,NAME)\n IF (&NNEDPROF = &Z) &NNEDPROF = TEXT\n VPUT (NNMAILRT NNMAILFR NNMAILSF NNEDPROF) PROFILE\n)END\n./ ADD NAME=NNMQPOST\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n/*                                                                   /*\n/* There seems to be some kind of bug in ISPF 3.3.  Substitution of  /*\n/* variables is not done before the first input field, so I could    /*\n/* not put the panel heading where I wanted it. ???                  /*\n/*                                                                   /*\n)BODY EXPAND(``)\n -`-`- Post to news server -`-`-\n%Command ===>\u00acZCMD\n\n%Note:+The fate of a posted news article is determined by the%news server+\n      %(&NNSERVER).\n\n+Posting:  &HEADING\n\n%Required Header Fields+\n\n+Newsgroups  ===>\u00acNNPOSTNG\n+Subject     ===>\u00acNNPOSTSJ\n\n%Optional Header Fields+\n\n+Reply To     ==>\u00acNNPOSTRT\n+Followup To  ==>\u00acNNPOSTFO\n\n+Your human name ==>\u00acNNPOSTFR\n+Signature file  ==>_NNPOSTSF\n+Edit profile    ==>_NNEDPROF+\n\n+Press%ENTER+to proceed to the editor to compose the article.\n+Press%&END (END)+to cancel the posting request.\n)INIT\n .HELP = TNNM\n IF (&NNPOSTHA = &Z)\n  &HEADING = 'New Article'\n ELSE\n  &HEADING = 'Followup to Article &NNPOSTHA in group &NNPOSTHG'\n IF (&NNPOSTNG = &Z) .CURSOR = NNPOSTNG\n ELSE                .CURSOR = NNPOSTSJ\n &END = PFK(END)\n &ZCMD = &Z\n IF (&NNEDPROF = &Z) &NNEDPROF = TEXT\n /* IF (&NNPOSTSF = &Z) &NNPOSTSF = &NNMAILSF */\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VER(&NNPOSTNG,NB)\n VER(&NNPOSTSJ,NB)\n VER(&NNPOSTSF,DSNAME)\n VER(&NNEDPROF,NAME)\n IF (&NNEDPROF = &Z) &NNEDPROF = TEXT\n VPUT (NNPOSTRT NNPOSTFR NNPOSTSF NNEDPROF) PROFILE\n)END\n./ ADD NAME=NNMRCERR\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Viewer -`-`-\n%COMMAND ===>_ZCMD\n+\n%  ` `  *** ERROR ***  ` ` +\n+\n% ` ` Unable to access the NEWSRC file, which is required. ` ` +\n+\n+ ` ` This file must be allocated to DDname%NNNEWSRC. ` ` +\n+\n+ ` ` The News Viewer cannot continue. ` ` +\n+\n+\n+ ` ` Press!ENTER+or!END+key to leave this panel. ` ` +\n)INIT\n .HELP = TNNM\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n)END\n./ ADD NAME=NNMRFCH\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n ! TYPE(TEXT) INTENS(LOW)\n ? TYPE(TEXT) INTENS(LOW)\n { TYPE(TEXT) INTENS(LOW)\n } TYPE(TEXT) INTENS(LOW)\n)BODY EXPAND(``)\n%-`-`- NNMVS - RFC822 Header Viewing Options -`-`-\n%Command ===>_ZCMD\n+\n+The current RFC822 header viewing option is highlighted.\n+Move cursor to choice (or type%S+next to choice) and press%ENTER+to change:\n+\n_A!Show all RFC822 headers\n_B?Show all RFC822 headers except those in Exclude List\n_C{Show the RFC822 headers in Include List only\n_D}Suppress RFC822 headers entirely\n+\n+Lists are header names separated by blanks.  Do%not+put%:+in header names.\n+\n%Include List ==>_NNRFCINC\n\n\n%Exclude List ==>_NNRFCEXC\n\n\n+Press%ENTER+to change options.  Press%&END+(or type%END+command) when done.\n)INIT\n .HELP = TNNMOPT\n .CURSOR = ZCMD\n &END = PFK(END)\n &ZCMD = &Z\n &A = &Z\n &B = &Z\n &C = &Z\n &D = &Z\n VGET (NNRFCOPT NNRFCINC NNRFCEXC) PROFILE\n IF (&NNRFCOPT = &Z) &NNRFCOPT = A\n IF (&NNRFCOPT = A) .ATTRCHAR(!) = 'INTENS(HIGH)'\n IF (&NNRFCOPT = B) .ATTRCHAR(?) = 'INTENS(HIGH)'\n IF (&NNRFCOPT = C) .ATTRCHAR({) = 'INTENS(HIGH)'\n IF (&NNRFCOPT = D) .ATTRCHAR(}) = 'INTENS(HIGH)'\n IF (&NNRFCOPT = B) .ATTR(NNRFCEXC) = 'INTENS(HIGH)'\n ELSE               .ATTR(NNRFCEXC) = 'INTENS(LOW)'\n IF (&NNRFCOPT = C) .ATTR(NNRFCINC) = 'INTENS(HIGH)'\n ELSE               .ATTR(NNRFCINC) = 'INTENS(LOW)'\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n IF (.RESP = ENTER)\n  &TEMP = '&A/&B/&C/&D'\n  IF (&TEMP = '///')\n   &NNCHOICE = TRANS(.CURSOR A A B B C C D D * ' ')\n  ELSE\n   &NNCHOICE = TRANS(&TEMP  'S///' A\n                            '/S//' B\n                            '//S/' C\n                            '///S' D\n                               * ?  )\n  IF (&NNCHOICE = '?')\n   &ZERRSM   = 'Invalid choice'\n   &ZERRLM   = 'Make exactly one selection with the cursor or type only one S.'\n   &ZERRALRM = YES\n   &ZERRHM   = '*'\n   .MSG = ISRZ002\n  ELSE\n   IF (&NNCHOICE \u00ac= &Z)\n    &NNRFCOPT = &NNCHOICE\n  VPUT (NNRFCOPT NNRFCINC NNRFCEXC) PROFILE\n)END\n./ ADD NAME=NNMVIEW\n)ATTR DEFAULT(%+_)\n/*                                                                   */\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993     */\n/*                                                                   */\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           */\n/*                                                                   */\n/* This software is provided on an \"AS IS\" basis.  All warranties,   */\n/* including the implied warranties of merchantability and fitness,  */\n/* are expressly denied.                                             */\n/*                                                                   */\n/* Provided this copyright notice is included, this software may     */\n/* be freely distributed and not offered for sale.                   */\n/*                                                                   */\n/* Changes or modifications may be made and used only by the maker   */\n/* of same, and not further distributed.  Such modifications should  */\n/* be mailed to the author for consideration for addition to the     */\n/* software and incorporation in subsequent releases.                */\n/*                                                                   */\n \u00ac  TYPE(INPUT)  INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n #  TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(RIGHT)\n \\  TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n |  AREA(DYNAMIC) EXTEND(ON) SCROLL(ON) USERMOD(05)\n 01 TYPE(DATAOUT) INTENS(LOW)\n 02 TYPE(DATAOUT) INTENS(HIGH)\n 03 TYPE(DATAIN)  INTENS(LOW)\n 04 TYPE(DATAIN)  INTENS(HIGH)\n)BODY\n\\NNBTITLE\n%COMMAND ===>\u00acZCMD                                            %SCROLL ===>_Z   +\n|NNBDYNA                                                                       |\n)INIT\n .ZVARS = NNMARTSC\n IF (&NNMARTSC = &Z) &NNMARTSC = CSR\n &TNNMTHR = 'NNMVIEW'\n .HELP = TNNMB1\n .CURSOR = &NNBCUR\n .CSRPOS = &NNBPOS\n)PROC\n &NNBCUR = .CURSOR\n &NNBPOS = .CSRPOS\n &NNBLVL = LVLINE(NNBDYNA)\n VPUT (NNMARTSC) PROFILE\n)END\n./ ADD NAME=NNM0\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Network News Client: NNTP Native Protocol Mode  -`-`-\n%COMMAND ===>_ZCMD\n+\n%NNTP command ===>_NNCMD\n\n\n+Press!END+key to leave this menu.\n)INIT\n .HELP = TNNM\n .CURSOR = NNCMD\n &ZCMD = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG=ISPZ001\n)END\n./ ADD NAME=TNNM\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%TUTORIAL -`-`-  MVS Network News Viewer -`-`- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n+NNMVS is an NNTP (network news transfer protocol)%news client+that runs on the\n IBM mainframe using ISPF services.  It retrieves news articles from an NNTP\n%news server+executing on a host machine elsewhere on your network.  You must\n tell NNMVS where this news server is; it does not know otherwise.\n\n+NNMVS remembers which articles you have read in a%\"newsrc\"+file, whose name\n defaults to%&ZPREFIX..NEWSRC+.  If you are a new user, you use the%L+or%blank+\n+option to build your NEWSRC file with a list retrieved from the server.  To\n limit the list to your favorite newsgroups, you can register (subscribe to)\n the ones you want while viewing the newsgroup list.  Once you have used NNMVS\n and built a NEWSRC file, you may wish to use a different entry option to reduce\n startup time.  You can avoid retrieving the whole list by using the%R+option to\n view only%registered+(subscribed) newsgroups, or the%A+option to view%all+\n newsgroups listed in your NEWSRC file.  You can use the%N+option to get a list\n of newsgroups added since the last time you retrieved the newsgroup list (i.e.\n used%L+or%N+).  The%G+option always goes directly to a specific newsgroup.\n\n+Press%ENTER+to proceed with the tutorial, or enter a selection code:\n    %1+- Information on news servers\n    %2+- Information on NNTP, as described by RFC 977\n)INIT\n)PROC\n &ZSEL = TRANS(&ZCMD,1,TNNMSERV,2,TNNMNNTP,*,?)\n &ZCONT = TNNM001\n)END\n./ ADD NAME=TNNMB1\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%TUTORIAL -`-`-  MVS Network News Viewer -`-`- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n+When you select an article for viewing, you are placed in browse mode.\n+You can use most NNMVS and ISPF BROWSE commands, plus the following commands:\n%NEXT+           - proceed directly to the next article in the newsgroup\n%NEXTSubj+ or%NS+- proceed directly to the next article on the same subject\n%NEXTT+    or%NT+- proceed directly to the next article in the current table\n%NEXTU+    or%NU+- proceed directly to the next unread article in the newsgroup\n%PREV+           - proceed directly to the previous article in the newsgroup\n%PREVSubj+ or%PS+- proceed directly to the previous article on the same subject\n%PREVT+    or%PT+- proceed directly to the previous article in the current table\n%PREVU+    or%PU+- proceed directly to the previous unread article in the group\n%FIRSTSubj+or%FS+- proceed directly to first unread article on the same subject\n%LASTSubj +or%LS+- proceed directly to last unread article on the same subject\n%NEWSUBJ+        - proceed directly to first unread article on different subject\n%SUBJECT+or%SUBJ+- display or change the current subject for subject searches\n%UNREAD+         - stop reading this article and mark it unread\n%EXTRACT+or%EXT+ - copy the article into a data set\n%PRT+or%PRNT+    - print the article to SYSOUT\n%ROT13+          - display \"ROT13\"-encoded text (toggle, do it again to reverse)\n%FOLLOWUP+       - post a follow-up news article, news server permitting\n%REPLY+          - send private mail to the originator of the news article\n%HEADERs+        - customize article header line display (same as OPTIONS 1)\n                          %(continued on next page)+\n)INIT\n IF (&TNNMTHR = NNMBROBF) &ZUP = ISR10000\n ELSE                     &ZUP = TNNM001\n &ZCONT = TNNMB2\n)PROC\n)END\n./ ADD NAME=TNNMB2\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%TUTORIAL -`-`-  MVS Network News Viewer -`-`- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n+All the commands of ISPF BROWSE are supported under NNMVS browse, except for:\n\n %HEX+\n %BROWSE+\n %SUBMIT+\n %LOCATE .label+\n %.<string>+(to assign a label)\n %FIND P'generic-string'+\n %DISPLAY CC/NOCC+\n\n+For NEXTSUBJ, PREVSUBJ, FIRSTSUBJ and LASTSUBJ, the current subject is that\n of the article being displayed.   Alphabetic case is ignored, and subjects\n with RE: and WAS: wrappers are taken into account.\n\n+Note that NNTP protocol displays also use browse mode.  When you are browsing\n such output, commands relevant to article selection or sending are not\n available.  This means that EXTRACT and PRT are the only commands other\n than browse and general NNMVS commands that you can use at such a time.\n)INIT\n)PROC\n)END\n./ ADD NAME=TNNMC\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1993     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%TUTORIAL -`-`-  MVS Network News Viewer -`-`- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n\n+The following commands are available from any of the display modes:\n\n %OPTIONS+or%OPT+- set user options (e.g. for display of message headers)\n %SAVE          +- checkpoint%newsrc+(otherwise, will not be updated until exit)\n %POST          +- compose a news article for sending, news server permitting\n %MAIL          +- compose a mail message for sending to an individual user\n %NNTP          +- enter native NNTP protocol mode (for debugging only)\n %DISCONNECT    +- force disconnection from news server (reconnect automatic)\n %QUIT          +- leave NNMVS, saving changes in NEWSRC file\n %CRASHNNMVS    +- terminate NNMVS immediately, saving nothing\n %DEBUG         +- enable NNMVS debug mode (ddname NNDEBUG must be allocated)\n %NODEBUG       +- deactivate NNMVS debug mode\n %TEST          +- enter C/370 test mode (INSPECT)\n\n+The following topics will be displayed next, or may be selected by number:\n\n%   1 + - The Newsgroup Display (Available Selection Codes and Commands)\n%   2 + - The Article Display   (Available Selection Codes and Commands)\n%   3 + - The Text Display      (Available Commands)\n%   4 + - Specifying User Options\n)INIT\n)PROC\n &ZSEL = TRANS(&ZCMD 1,TNNMG 2,TNNMT 3,TNNMB1 4,TNNMOPT *,?)\n &ZUP = TNNM\n)END\n./ ADD NAME=TNNMG\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%TUTORIAL -`-`-  MVS Network News Viewer -`-`- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n+In the%newsgroup+display, you may type a code in front of a newsgroup name:\n %S+ - select:      display articles, initially just those you haven't seen yet\n %N+ - new:         display unseen articles, removing seen ones from display\n %A+ - all:         display all articles, seen or unseen\n %R+ - register:    mark the newsgroup as one of your \"subscribed\" groups\n %D+ - deregister:  remove the newsgroup from your \"subscribed\" list\n %M+ - mark read:   tell the News Viewer you've seen everything in this group\n %U+ - mark unread: tell the News Viewer you haven't seen anything in this group\n %Q+ - query:       display newsgroup status (for debugging only)\n %&A+- &SELEC:      display unseen articles, sorted by subject\n %&B+- &AL:         display all articles, sorted by subject\n+You may type one of the following commands on the newsgroup command line:\n %EXTRACT+or%EXT+    - copy the current list of newsgroups into a data set\n %PRT+or%PRNT+       - print the current list of newsgroups to SYSOUT\n %LOCATE+or%LOC+or%L+- position display at or near given newsgroup name\n %FIND string option+- find NEXT, PREV, FIRST or LAST group containing string\n %ONLY string+       - show only groups containing string (null string for all)\n %REGISTER+or%REG+   - show registered (subscribed) newsgroups only\n %ALL+               - show all newsgroups (registered and unregistered)\n %ORDER Alpha/List+  - order groups alphabetically or by server's active file\n %RESCAN+            - update the status with the latest items from the server\n)INIT\n &A = '$'\n &B = '@'\n &SELEC  = '$elect'\n &AL     = '@ll'\n)PROC\n &ZUP   = TNNM001\n)END\n./ ADD NAME=TNNMNNTP\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%TUTORIAL -`-`-  MVS Network News Viewer -`-`- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n% ` `  NNTP (Network News Transfer Protocol)  ` `\n%\n+RFC 977, \"A Proposed Standard for the Stream-Based Transmission of News\",\n is the document that describes the Network News Transfer Protocol.\n\n You may also wish to read:\n\n RFC 1036, \"Standard for Interchange of USENET Messages\"\n\n The%NNTP+option from the main NNMVS menu, or the%NNTP+command from any\n NNMVS display command line, allows you to communicate directly with\n the NNTP server using the protocol language defined in RFC 977, subject\n to the support provided by the news server to which you are connected.\n)INIT\n)PROC\n &ZUP = TNNM\n)END\n./ ADD NAME=TNNMOPT\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%TUTORIAL -`-`-  MVS Network News Viewer -`-`- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n% ` `  Options  ` `\n%\n+The user options you set when you enter the OPTIONS command are remembered in\n your ISPF profile, as is typical of ISPF dialogs.  This is in contrast to\n newsgroup and article status information, which is stored in your NEWSRC file\n and not in your ISPF profile.\n\n The first set of options specifies handling of the message headers that appear\n in all news articles.  You may specify whether you want all header lines to be\n displayed, or just certain ones to be displayed, or certain ones NOT to be\n displayed, or none to be displayed.  The setting affects article extraction\n into files as well as viewing.\n\n+You may specify the frequency at which the News Viewer will update the screen\n for long-running processes, such as retrieving articles from large newsgroups.\n\n  %(continued on next page)+\n)INIT\n)PROC\n &ZUP = TNNM\n &ZCONT = TNNMOPT2\n)END\n./ ADD NAME=TNNMOPT2\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%TUTORIAL -`-`-  MVS Network News Viewer -`-`- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n% ` `  Options - Screen Update Frequency ` `\n%\n+You may specify the frequency at which the News Viewer will update the screen\n for long-running processes.  These include:\n\n   fetching the list of all newsgroups\n   fetching the headers for unread articles in a newsgroup\n   fetching the current status of registered newsgroup\n\n Specifying%ON+is the same as specifying a frequency of zero.  The initial\n default is%OFF,+but you may want to set it to%ON+or a number to experiment.\n\n When you use the%L+or%blank+option to fetch the list of all newsgroups, since\n the total number is not known, every newsgroup name will flash on the screen as\n it is read if the Update option is not%OFF.+ For slow terminals, this can\n greatly slow down the News Viewer; you should always specify%OFF+for slow\n terminals if you intend to do this.  While article titles are being fetched, if\n Update is%OFF,+nothing is displayed until all titles are retrieved.  Otherwise,\n a bar graph showing the progress will be displayed at the indicated interval;\n if Update is%ON+(the same as zero), the bar graph will be updated as every\n title is read.  An estimated time to completion will be displayed as well.\n)INIT\n)PROC\n &ZUP = TNNM\n)END\n./ ADD NAME=TNNMSERV\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%TUTORIAL -`-`-  MVS Network News Viewer -`-`- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n% ` `  News Servers  ` `\n%\n+Your NNMVS installation may already be configured to start you up with\n a default news server host.  If so, then you need do nothing special\n to tell NNMVS to connect to it.  Otherwise, you will need to provide the\n name of the host running an NNTP news server.\n\n+Ask your system administrator to tell you the hostname of the machine\n where an available news server is running.  You may need to ask the\n administrator of that host to grant you permission to access the news server\n from the MVS system where the News Viewer will be running as a client.\n\n+If NNMVS does not recognize the hostname, you may specify an IP address\n (four numbers separated by periods in the format nn.nn.nn.nn).\n)INIT\n)PROC\n &ZUP = TNNM\n)END\n./ ADD NAME=TNNMT\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* SAS enhancements copyright (c) 1992 SAS Institute, Inc.           /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%TUTORIAL -`-`-  MVS Network News Viewer -`-`- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n+In the%article+display, you may type these codes in front of an article number:\n %S+ - select:      browse the article text\n %E+ - extract:     copy the article into a data set\n %P+ - print:       print the article to SYSOUT\n %M+ - mark read:   tell the News Viewer you've already seen this article\n %U+ - mark unread: tell the News Viewer you haven't seen this article\n %F+ - followup:    post a follow-up news article, news server permitting\n %R+ - reply:       send private mail to the originator of the news article\n %C+ - cancel:      send article cancel request to server (author must be you)\n %Q+ - query:       display article status (for debugging only)\n+You may type one of the following commands on the article display command line:\n%LOCATE+or%LOC+or%L+  - position display at or near given article number\n%EXTRACT+or%EXT+      - copy titles or text of all articles into a data set\n%PRT+or%PRNT+         - print titles or text of all articles to SYSOUT\n%TITLES+or%TITLE+     - retrieve titles of all articles in table from the server\n%QUERY+               - display newsgroup status (for debugging only)\n%FIND string option+  - find NEXT, PREV, FIRST or LAST article with \"string\"\n%ONLY string       +  - limit display to articles with \"string\" in the subject\n%MARKALL+or%UNMARKALL+- mark all articles in this newsgroup read or unread\n%SORT Subject/Number +- sort article display by subject or by article number\n%RESCAN+              - update the status with the latest items from the server\n)INIT\n)PROC\n &ZUP   = TNNM001\n &TNNMTHR = &Z\n)END\n./ ADD NAME=TNNM001\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%TUTORIAL -`-`-  MVS Network News Viewer -`-`- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n+There are three kinds of displays created by the News Viewer:\n\n%   Newsgroups+ - which allows you to select newsgroups by name\n%   Articles  + - which allows you to select articles by name\n%   Text      + - which allows you to browse article text or NNTP output\n\n+Additional commands are available specific to each of the above modes.\n\n+The following topics will be displayed next, or may be selected by number:\n\n%   1 + - Commands Available From All Displays\n%   2 + - The Newsgroup Display (Available Selection Codes and Commands)\n%   3 + - The Article Display   (Available Selection Codes and Commands)\n%   4 + - The Text Display      (Available Commands)\n%   5 + - Specifying User Options\n)INIT\n)PROC\n &ZSEL = TRANS(&ZCMD 1,TNNMC 2,TNNMG 3,TNNMT 4,TNNMB1 5,TNNMOPT *,?)\n &ZUP = TNNM\n)END\n./ ENDUP\n?!\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOREXX": {"ttr": 28163, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x00\\x99)\\x9f\\x01\\x02\\x01o\\x08W\\x0c\\x99\\x0c\\x92\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-10-26T00:00:00", "modifydate": "2002-01-16T08:57:27", "lines": 3225, "newlines": 3218, "modlines": 0, "user": "SEB"}, "text": "//JOBNAME JOB ACCOUNT,'NAME'\n//*------------------------------------------------------------------*/\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1989    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis. All warranties,   */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed. Such modifications should  */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*------------------------------------------------------------------*/\n//*\n//*    TSO/REXX Utilities\n//*\n//*  Version: 1  Release: 1\n//*\n//* Author: Steve Bacher <seb@draper.com>\n//*\n//* Date: 15 Jul 1993\n//*\n//*-------------------------------------------------------------------\n//*\n//* This job creates the distribution libraries (PDS's).\n//*\n//* Run this JCL to create the PDS's, after customizing to suit.\n//* (Obviously, put in a good JOB statement first.)\n//* To customize the JCL, change the defaults on the //MDLOAD PROC\n//* statement to your liking, particularly the PREFIX default.\n//* You might also want to change the final qualifiers of the PDS's\n//* created - to do this, find the // EXEC MDLOAD statements and\n//* change the value of the TO parameter.\n//*\n//* See the $$README file (of the CNTL PDS, first in this stream)\n//* for the rest of the installation instructions.\n//*\n//MDLOAD PROC CLS='*',BS='6160',U='3380',V='',\n//      TRK1='15',TRK2='5',DIR='35',RLSE='RLSE',\n//      PREFIX='SYS8.TSOREXX.INSTALL.'\n//*\n//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=&CLS\n//SYSUT2 DD DISP=(NEW,CATLG,DELETE),DSN=&PREFIX.&TO,\n//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=&BS),\n//  SPACE=(TRK,(&TRK1,&TRK2,&DIR),&RLSE),UNIT=&U,VOL=SER=&V\n//*\n//  PEND\n//*\n//CNTL     EXEC MDLOAD,TRK1='5',TRK2='1',TO='CNTL'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=$$README\n\nTSO/REXX Utilities:  XPROC and XWRITENR\n\nXPROC provides the capability of the CLIST PROC statement for TSO REXX\nexecs.  Similarly, XWRITENR provides the capability of the CLIST WRITENR\nstatement for TSO REXX execs.\n\nTo install these utilities:\n\n(1) Pick a load library.  Probably you will need these to be in one of\n    your MVS system link list libraries, but you might want to put it\n    in a user library first.  The JCL (see next step) references this\n    library and assumes it already exists, so make sure that it exists\n    and that you can update it before you proceed.\n\n(2) Assemble and link all of the utilities.  The JCL is in the\n    corresponding member of the CNTL dataset (called either\n    SYS8.TSOREXX.INSTALL.CNTL or blah.CNTL, where blah is what you\n    changed the MDLOAD prefix to).\n\n    Before submitting the JCL, customize it so that it will run on your\n    system.  In particular, change the names of the referenced data sets\n    from SYS8.TSOREXX.INSTALL.ASM and SYS8.TSOREXX.LOAD to whatever you\n    are using.  The .ASM was created when you built this distribution.\n    The .LOAD was decided upon by you in step (1).\n    It was NOT allocated by building the distribution.\n\n(3) Install the TSO HELP files.  The HELP is in the corresponding member\n    of the HELP dataset (called either SYS8.TSOREXX.INSTALL.HELP or\n    blah.HELP, where blah is what you changed the MDLOAD prefix to).\n\n(4) Get the load modules into a system load library, refresh LLA if\n    applicable to your system, and enjoy.\n\n(5) Send all gripes, compliments and suggestions to seb@draper.com.\n\n./ ADD NAME=XPROC\n//ASSEMBLE  EXEC PGM=IEV90,PARM='LIST,NODECK,OBJECT'\n//SYSPRINT  DD SYSOUT=A\n//SYSPUNCH  DD DUMMY\n//SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB\n//SYSLIN    DD DISP=(,PASS),UNIT=SYSALLDA,SPACE=(1680,(10,50))\n//SYSUT1    DD UNIT=VIO,SPACE=(TRK,(100,100))\n//SYSIN     DD DISP=SHR,DSN=SYS8.TSOREXX.INSTALL.ASM(XPROC)\n//*\n//LINKEDIT  EXEC PGM=IEWL,PARM='LIST,LET,RENT,REUS,MAP',COND=(0,NE)\n//SYSPRINT  DD SYSOUT=A\n//SYSLMOD   DD DISP=SHR,DSN=SYS8.TSOREXX.LOAD(XPROC)\n//SYSLIN    DD DISP=(OLD,DELETE),DSN=*.ASSEMBLE.SYSLIN\n//SYSUT1    DD UNIT=VIO,SPACE=(TRK,(100,100))\n./ ADD NAME=XWRITENR\n//ASSEMBLE  EXEC PGM=IEV90,PARM='LIST,NODECK,OBJECT'\n//SYSPRINT  DD SYSOUT=A\n//SYSPUNCH  DD DUMMY\n//SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB\n//SYSLIN    DD DISP=(,PASS),UNIT=SYSALLDA,SPACE=(1680,(10,50))\n//SYSUT1    DD UNIT=VIO,SPACE=(TRK,(100,100))\n//SYSIN     DD DISP=SHR,DSN=SYS8.TSOREXX.INSTALL.ASM(XWRITENR)\n//*\n//LINKEDIT  EXEC PGM=IEWL,PARM='LIST,LET,RENT,REUS,MAP',COND=(0,NE)\n//SYSPRINT  DD SYSOUT=A\n//SYSLMOD   DD DISP=SHR,DSN=SYS8.TSOREXX.LOAD(XWRITENR)\n//SYSLIN    DD DISP=(OLD,DELETE),DSN=*.ASSEMBLE.SYSLIN\n//SYSUT1    DD UNIT=VIO,SPACE=(TRK,(100,100))\n./ ENDUP\n?!\n//ASM      EXEC MDLOAD,TRK1='5',TRK2='1',TO='ASM'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=XPROC\n         TITLE 'XPROC copyright notice'\n***********************************************************************\n*                                                                     *\n*   Copyright (c) 1989 The Charles Stark Draper Laboratory, Inc.      *\n*                                                                     *\n*   This program is provided on an \"as is\" basis.  It may be freely   *\n*   distributed as long as it is not offered for commercial sale,     *\n*   and as long as this copyright notice is included.                 *\n*                                                                     *\n***********************************************************************\n         TITLE 'XPROC macros'\n         MACRO\n&SYM     ERROR &MSG,&FLUSH=YES\n&SYM     L     R1,=A(&MSG)         Get address of error message\n         LA    R0,L'&MSG           Get length of error message\n         BAL   R14,PUTLINE         Display error message\n         AIF   ('&FLUSH' EQ 'NO').MEND\n         B     FLUSHIT             Fail\n.MEND    MEND\n         TITLE 'XPROC - CLIST-style command line parser for REXX'\n***********************************************************************\n*                                                                     *\n* XPROC    - CLIST-style command line parser for REXX                 *\n*                                                                     *\n* Author:  S. Bacher 06/89                                            *\n*                                                                     *\n* Syntax:  XPROC {inputvar} number {positional-parameter-variables}*  *\n*                                  {keyword-and-maybe-value-specs}*   *\n*                                                                     *\n*        where: \"inputvar\" is a valid CLIST/REXX variable name        *\n*               and the part of the command that follows \"inputvar\"   *\n*               looks exactly like the syntax of the CLIST \"PROC\"     *\n*               statement.                                            *\n*                                                                     *\n* Example: /* REXX */                                                 *\n*          PARSE ARG OPERANDS                                         *\n*          \"XPROC OPERANDS 2 FILE DSN VOL() SHR COUNT(1) KEY('A B')\"  *\n*                                                                     *\n*          Note that everything, including \"inputvar\", must be quoted *\n*          under REXX to prevent substitution.                        *\n*                                                                     *\n* Function:  To parse the value of a string (accessed as \"inputvar\")  *\n*            according to the PROC-style specifications and place     *\n*            the results in REXX variables.  If \"inputvar\" is         *\n*            omitted, the argument to the REXX exec is parsed.        *\n*                                                                     *\n* Return codes:                                                       *\n*                                                                     *\n* 0 - normal operation                                                *\n* 12 - error(s) occurred, prompting not possible                      *\n*                                                                     *\n* Note:  This can be used in CLISTs as well.  One use might be to     *\n*        parse a non-command-buffer line, e.g. edit macro text.       *\n*                                                               #TSO147\n* Change activity:                                              #TSO147\n*                                                               #TSO147\n* 10/24/89 - SEB1525 - Bug fix when bigger keyword area needed. #TSO147\n* 01/30/91 - SEB1525 - Extended to permit the specification of        *\n*                      options via the syntax keyword/option.         *\n*                      First option so supported is lowercase.        *\n* 04/13/92 - SEB1525 - Bug fix when prototype has quoted data.  #TSO159\n* 12/15/92 - SEB1525 - Pass REXX env block from ECT to IRXEXCOM #TSO162\n*                      to solve problem with IPCS/ISPF          #TSO162\n* 01/14/02 - SEB1525 - Pass ECT to IKJCT441 for IPCS/ISPF.      #TSO172\n*                      Fix developed by:                        #TSO172\n*                      Steven D. McGinty                        #TSO172\n*                      <sm122284@exchange.SanDiegoCA.ncr.com>   #TSO172\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    Miscellaneous uses\nR3       EQU   3    Used by SCAN and PUTLINE; other temporary uses\nR4       EQU   4    Positional parameter info\nR5       EQU   5    Positional parameter info\nR6       EQU   6    Keyword count\nR7       EQU   7    Address of IKJPARS PDL answer area\nR8       EQU   8    Used to loop through parameters\nR9       EQU   9    Dynamic base register\nR10      EQU   10   Static base register\nR11      EQU   11   Static base register\nR12      EQU   12   Static base register\nR13      EQU   13   Save area pointer\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXPROC    CSECT\nXPROC    AMODE 31\nXPROC    RMODE ANY\n         SAVE  (14,12),,XPROC_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XPROC,R12\n         LA    R11,4095(,R12)\n         USING XPROC+4095,R11\n         LA    R10,4095(,R11)\n         USING XPROC+4095+4095,R10\n*\n* Allocate storage to hold work area plus copies of positional and\n* keyword parameters.  Since the maximum length required to hold\n* all the parameters is obviously the length of the command buffer,\n* use that as the amount to add.\n*\n         LR    R2,R1               Save input parameter address\n         LA    R4,SIZDATD            Get length of basic workarea\n         L     R3,CPPLCBUF-CPPL(,R2) Point to command buffer\n         AH    R4,0(,R3)             Add length of command buffer\n         LR    R0,R4\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R9,R13\n         USING DATD,R9\n         ST    R4,DATDLEN          Save length of getmained area\n         LA    R0,WORDCOPY         Point to variable area\n         ST    R0,WORDPTR          Save address of it\n         MVC   CPPL(16),0(R2)      Set up our copy of CPPL\n         MVC   IOPLUPT,CPPLUPT     Pointer TO UPT\n         MVC   IOPLECT,CPPLECT     Pointer TO ECT\n         LA    R0,ECB\n         ST    R0,IOPLECB          Pointer to user's ECB\n         MVC   PTLIST(LENPUTL),MPTLIST Set up PUTLINE list form\n         LA    R0,1                Define 1 message segment\n         LA    R1,MSGHDR\n         STM   R0,R1,OLD           Make PUTLINE output line descriptor\n*                                  Initialize other data areas\n         STM   R11,R12,MYBASES     Base registers used in PARSE exits\n         MVI   FLAGS,X'00'         Clear flags\n         XR    R0,R0               Make a zero\n         ST    R0,APOSD\n         ST    R0,LPOSD\n         ST    R0,AKEYD\n         ST    R0,LKEYD\n         ST    R0,AKEYE\n         ST    R0,POSCOUNT\n         ST    R0,KEYCOUNT\n         ST    R0,PWADDR\n         ST    R0,PWLEN\n         ST    R0,VBUFADDR\n         ST    R0,VBUFLEN\n         ST    R0,ARGADDR\n         ST    R0,ARGLEN\n*\n         EJECT\n*\n***********************************************************************\n*\n* First, set things up so that SCAN can start scanning.  On entry to\n* the command, CPPLCBUF points to the command buffer.  Halfword 1 is\n* the length of the buffer plus 4, and halfword 2 is the offset of the\n* first operand (if any) past the command name in the buffer (set by\n* TSO's call to IKJSCAN).\n*\n***********************************************************************\n*\n         L     R2,CPPLCBUF\n         LR    R1,R2\n         AH    R1,0(,R2)\n         ST    R1,SCANEPTR         Save end of command buffer\n         LA    R1,4(,R2)\n         AH    R1,2(,R2)\n         ST    R1,SCANPTR          Initialize scan pointer\n         XR    R0,R0\n         ST    R0,PARCOUNT         Initialize parenthesis count\n*\n***********************************************************************\n*                                                                     *\n* Scan command buffer for first operand - must be input variable name *\n*                                                                     *\n***********************************************************************\n*\n         BAL   R14,SCAN            Return R15 -> arg\n         B     NOOPERANDS          No value\n         B     ARG1OK              Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     ERROR_NO_WANT_LP    \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     ERROR_NO_WANT_SL    \"/\" found\n         SPACE 1\nARG1OK   DS    0H\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Validate first argument as a variable name so that it can be used   *\n* to retrieve CLIST/REXX variable value.                              *\n*                                                                     *\n* We may not really have to do that here - just verify that it's not  *\n* a positional count.  If it is a positional count, set the address   *\n* and length of the input variable to zero (extension to XPROC will   *\n* get value to parse from REXX argument string in that case).         *\n*                                                                     *\n***********************************************************************\n*\n         LR    R3,R1               Save address\n         LR    R4,R2               Save length\n         CH    R2,=H'256'          If it's too long for EX instruction\n         BH    ERROR_FIRST_ARG     then first arg is invalid\n         BCTR  R2,0                Reduce for execute\n         EX    R2,TRTPOSCT         Scan for numerics\n         BNZ   NOTPOSCOUNT         If any non-numerics, not a count\n         XR    R0,R0               Else make a zero\n         ST    R0,PVARADDR         Clear address of the variable\n         ST    R0,PVARLEN          Clear length of the variable\n         B     ISACOUNT            Process this as the pos parm count\n         SPACE 1\nNOTPOSCOUNT DS 0H                  Not a count - assume a variable name\n         LR    R14,R3              Get address of variable name\n         LA    R1,PVAR             Point to place to build var name\n         ST    R1,PVARADDR         Save address of the variable\n         ST    R4,PVARLEN          Save length of the variable\n         BCTR  R4,0                Reduce for execute\n         EX    R4,MVCWORD          Move word to PVAR\n         EX    R4,UPWORD           Translate to uppercase\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Scan command buffer for next operand - must be count of positionals *\n*                                                                     *\n***********************************************************************\n*\n         BAL   R14,SCAN\n         B     NOPOSCOUNT          No value\n         B     ARG2OK              Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     ERROR_NO_WANT_LP    \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     ERROR_NO_WANT_SL    \"/\" found\n         SPACE 1\nARG2OK   DS    0H                  We have what should be a count...\n         LR    R3,R1               Get address of argument\n         LR    R4,R2               Get length of argument\nISACOUNT DS    0H                  Here for first non-alpha arg...\n*\n***********************************************************************\n*                                                                     *\n* Validate this argument as a number so that it can be used to count  *\n* the number of positional parameters.                                *\n*                                                                     *\n***********************************************************************\n*\n         BCTR  R4,0                Reduce for execute\n         CH    R4,=H'7'            If positional count more than 8 digs\n         BH    BADPOSCOUNT         then invalid value\n         EX    R4,TRTPOSCT         Scan for numerics\n         BNZ   BADPOSCOUNT         If any non-numerics, invalid value\n         EX    R4,PACKIT           Convert to numeric\n         CVB   R0,DOUBLE           Get binary value\n         ST    R0,POSCOUNT         Store positional parameter count\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* We are about to start collecting all parameter names, both          *\n* positional and keyword.  While we do this, we determine how much    *\n* space will be needed for IKJPARS control blocks.                    *\n*                                                                     *\n* Compute storage needed for the PCL (built by us):                   *\n*                                                                     *\n*   For initial overhead:            7                                *\n*   For each positional parameter:   56 + (2 * length(min(name,234))) *\n*   For each keyword with a value:   66 + (2 * length(min(name,237))) *\n*                                       + length(name)                *\n*   For each keyword without value:  11 + length(name)                *\n*                                                                     *\n* Compute storage reserved for the PDL (built by IKJPARS):            *\n*                                                                     *\n*   For initial overhead:            8                                *\n*   For each positional parameter:   8                                *\n*   For each keyword:                2                                *\n*   For each value subfield:         8                                *\n*                                                                     *\n***********************************************************************\n*\n         LA    R0,7                Set PCL amount to initial value\n         ST    R0,PCLLEN\n         XR    R0,R0               Set quoted-value-strings length\n         ST    R0,QVALLEN\n         LA    R0,8                Set PDL initial total length\n         ST    R0,PDLLEN\n*\n***********************************************************************\n*                                                                     *\n* Get storage to hold information for as many positional parameters   *\n* as we have defined.                                                 *\n*                                                                     *\n***********************************************************************\n*\n         ICM   R5,15,POSCOUNT      Get count of positional parameters\n         BZ    NOPOZZES            If zero, no positional parameters\n         MH    R5,=Y(POSDDATL)     Get total length to acquire\n         GETMAIN RC,LV=(R5),LOC=ANY Get storage\n         LTR   R15,R15             If GETMAIN failed,\n         BNZ   BADPOSCOUNT         then positional count too big\n         ST    R1,APOSD            Save address of this area\n         ST    R5,LPOSD            Save length of this area\n         LR    R4,R1               Address first entry in area\n         USING POSDDATA,R4\n*\n***********************************************************************\n*                                                                     *\n* Loop (positional-parameter-count) times, collecting variable names. *\n*                                                                     *\n***********************************************************************\n*\n         NI    FLAGS,255-FLAGPOSD  Not currently processing anything\n         NI    FLAGS,255-FLAGKEYD\n         XR    R0,R0               Zero out error fields\n         ST    R0,LASTADDR\n         ST    R0,LASTLEN\n         ST    R0,LASTAREA\n         L     R8,POSCOUNT         Get count of positional parameters\nPPLOOP   DS    0H                  R5 contains count of parms to get\n         BAL   R14,SCAN            Get a positional parame\n         B     PPMISSING           No value\n         B     PPADD               Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     PPLP                \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     PPSLASH             \"/\" found\n         SPACE 1\nPPLP     DS    0H                  \"(\" found when a positional expected\n         C     R8,POSCOUNT         If no pos. parms found yet\n         BE    ERROR_NO_WANT_LP    then this is truly an error; else\n*                                  (future extension, but error now)\n         L     R3,LASTADDR         Get address of last processed P.P.\n         L     R2,LASTLEN          Get length of last processed P.P.\n         B     ERROR_PP_WITH_LP    say value spec not allowed\n         SPACE 1\nPPSLASH  DS    0H                  \"/\" found when a positional expected\n         BAL   R14,DOOPTS          Process options\n         B     PPLOOP\n         SPACE 1\nPPADD    DS    0H                  Add a positional parameter\n*\n* Check parameter for validity, and (if it's OK) make uppercase copy\n* of it in our area.\n*\n         CH    R2,=H'255'          If too long\n         BH    ERROR_PARM_TOO_LONG then error\n         LR    R14,R1              Address\n         LR    R15,R2              Length\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,VERIFYP         Check syntax of parameter\n         BNZ   ERROR_PARM_INVALID  If bad, error\n         CLI   0(R14),C'0'         Must not begin with numeric\n         BNL   ERROR_PARM_INVALID  If bad, error\n         L     R1,WORDPTR          Get next available word slot\n         EX    R15,MVCWORD         Move word to slot\n         EX    R15,UPWORD          Translate to uppercase\n         LA    R0,1(R15,R1)        Update slot pointer\n         ST    R0,WORDPTR          for next time\n*\n* Check for duplicates. R1 -> new word, R15 = length-1\n*\n         L     R2,APOSD            Get address of first positional\n         LA    R0,1(,R15)          Get true length\nCDPPLOOP DS    0H                  Loop to check for duplicates\n         CR    R2,R4               until we hit current PP slot\n         BNL   CDPPLEND\n         C     R0,POSDLEN-POSDDATA(,R2)\n         BNE   CDPPNEXT            If lengths don't match, continue\n         L     R14,POSDADDR-POSDDATA(,R2) Point to old parameter\n         EX    R15,COMPWORD        If values are equal,\n         BE    ERROR_PARM_DUPLICATE then error\nCDPPNEXT LA    R2,POSDDATL(,R2)    Else continue\n         B     CDPPLOOP\nCDPPLEND DS    0H                  End loop to check for duplicates\n         LA    R2,1(,R15)          Get length\n         ST    R1,POSDADDR         Save address of this pos. parm.\n         ST    R2,POSDLEN          Save length of this pos. parm.\n         XR    R0,R0               Clear other fields\n         ST    R0,POSDPCEA\n         MVI   POSDFLGS,0\n         ST    R4,LASTAREA         Save for option/error processing\n         ST    R1,LASTADDR         Save for option/error processing\n         ST    R2,LASTLEN          Save for option/error processing\n         OI    FLAGS,FLAGPOSD      Say currently processing positional\n         NI    FLAGS,255-FLAGKEYD\n*\n* PCE length for positional param: 56 + (2 * length(min(name,234)))\n* PDE length for positional param: 8\n*\n         LR    R15,R2              Get length of positional parm name\n         CH    R15,=H'234'         If longer than 255-21\n         BNH   *+8                 then\n         LA    R15,255-21           set length to 255-21\n         ST    R15,POSDMAXL        Store this length\n         SLA   R15,1               2 * length(min(name,234))\n         LA    R15,56(,R15)        56 + (2 * length(min(name,234)))\n         ST    R15,POSDPCEL        Set length of PCE for this parameter\n         A     R15,PCLLEN          Accumulate PCL length\n         ST    R15,PCLLEN\n         LA    R1,8                Length of PDE for positional = 8\n         A     R1,PDLLEN           Accumulate PDL length\n         ST    R1,PDLLEN\n         LA    R4,POSDDATL(,R4)    Bump pointer\n         BCT   R8,PPLOOP           Loop until count exhausted\n         SPACE 1\nNOPOZZES DS    0H                  Here if no positional parameters\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Get storage to hold information for keyword and value parameters.   *\n* We don't know how much we'll need yet, so we'll get a chunk of it   *\n* and hope for the best.                                              *\n*                                                                     *\n***********************************************************************\n*\n         L     R5,KEYDINCR         Get estimated initial length\n         GETMAIN RC,LV=(R5),LOC=ANY Get storage\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         ST    R1,AKEYD            Save address of this area\n         ST    R5,LKEYD            Save length of this area\n         XR    R4,R4               Start things off\n         USING KEYDDATA,R4\n         LA    R0,0(R1,R5)         Point to end of area\n         ST    R0,AKEYE            Save address of end\n*\n***********************************************************************\n*                                                                     *\n* Loop collecting keywords and keyword/value pairs.                   *\n*                                                                     *\n***********************************************************************\n*\n         XR    R6,R6               Clear keyword count\nKVLOOP   DS    0H\n         BAL   R14,SCAN            Get a keyword parameter\n         B     KVEND               No more\n         B     KVADD               Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     KVLP                \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     KVSLASH             \"/\" found\n         SPACE 1\nKVLP     DS    0H                  \"(\" found when a keyword expected\n         LTR   R6,R6               If we've seen keyword parms already\n         BNZ   ERROR_NO_WANT_LP    then this is truly an error\n         ICM   R0,15,POSCOUNT      Else if no positional parameters\n         BZ    ERROR_NO_WANT_LP    then this is truly an error.  Else,\n*                                  (future extension, but error now)\n         L     R3,LASTADDR         Get address of last processed P.P.\n         L     R2,LASTLEN          Get length of last processed P.P.\n         B     ERROR_PP_WITH_LP    say value spec w/p.p. not allowed\n         SPACE 1\nKVSLASH  DS    0H                  \"/\" found when a keyword expected\n         BAL   R14,DOOPTS          Process options\n         B     KVLOOP\n         SPACE 1\nKVADD    DS    0H                  Add a keyword parameter\n         OI    FLAGS,FLAGKEYD      Say we're currently processing\n         NI    FLAGS,255-FLAGPOSD  keyword/value parameters\n         LTR   R4,R4               If we haven't got any keywords yet\n         BNZ   KVNZ                then\n         L     R4,AKEYD             point to first entry in area\n         B     KVA                  and do our stuff.\nKVNZ     DS    0H                  Else...\n         LA    R4,KEYDDATL(,R4)    Bump pointer\n         C     R4,AKEYE            If this takes us past end of buffer\n         BL    KVA                 then...                      #TSO147\n         STM   R1,R2,SCANRES       Store result of scan\n         L     R5,LKEYD             get length of current area\n         A     R5,KEYDINCR          increment it\n         GETMAIN RC,LV=(R5),LOC=ANY get storage\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         LR    R2,R1               Address of new key area\n         LR    R0,R2               Address of new key area\n         L     R14,AKEYD           Address of old key area\n         L     R1,LKEYD            Length of old key area\n         LR    R15,R1              Length of old key area\n         MVCL  R0,R14              Move old key data to new key data\n         LR    R4,R0               Point to slot in new key area\n         L     R1,AKEYD            Address of old key area\n         L     R0,LKEYD            Length of old key area\n         FREEMAIN RC,LV=(0),A=(1)  Free the old key area\n         ST    R2,AKEYD            Save address of new area\n         ST    R5,LKEYD            Save length of new area\n         LA    R0,0(R2,R5)         Point to end of area\n         ST    R0,AKEYE            Save address of end\n         LM    R1,R2,SCANRES       Load results of scan\nKVA      DS    0H\n*\n* Check parameter for validity, and (if it's OK) make uppercase copy\n* of it in our area.\n*\n         CH    R2,=H'255'          If too long\n         BH    ERROR_PARM_TOO_LONG then error\n         LR    R14,R1              Address\n         LR    R15,R2              Length\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,VERIFYP         Check syntax of parameter\n         BNZ   ERROR_PARM_INVALID  If bad, error\n         CLI   0(R14),C'0'         Must not begin with numeric\n         BNL   ERROR_PARM_INVALID  If bad, error\n         L     R1,WORDPTR          Get next available word slot\n         EX    R15,MVCWORD         Move word to slot\n         EX    R15,UPWORD          Translate to uppercase\n         LA    R0,1(R15,R1)        Update slot pointer\n         ST    R0,WORDPTR          for next time\n*\n* Check for duplicates. R1 -> new word, R15 = length-1\n*\n         ICM   R8,15,POSCOUNT      Get count of positionals\n         BZ    KVPPLEND            If none, don't check 'em, obviously\n         L     R2,APOSD            Get address of first positional\n         LA    R0,1(,R15)          Get true length\nKVPPLOOP DS    0H                  Loop to check for duplicates\n         C     R0,POSDLEN-POSDDATA(,R2)\n         BNE   KVPPNEXT            If lengths don't match, continue\n         L     R14,POSDADDR-POSDDATA(,R2) Point to old parameter\n         EX    R15,COMPWORD        If values are equal,\n         BE    ERROR_PARM_DUPLICATE then error\nKVPPNEXT LA    R2,POSDDATL(,R2)    Else continue\n         BCT   R8,KVPPLOOP         until no more positionals\nKVPPLEND DS    0H                  End loop to check for duplicates\n*                                  Now check against keywords so far\n         LTR   R8,R6               Get count of keywords\n         BZ    KVKWLEND            If none so far, don't check 'em\n         L     R2,AKEYD            Get address of first keyword\n         LA    R0,1(,R15)          Get true length\nKVKWLOOP DS    0H                  Loop to check for duplicates\n         C     R0,KEYWORDL-KEYDDATA(,R2)\n         BNE   KVKWNEXT            If lengths don't match, continue\n         L     R14,KEYWORDA-KEYDDATA(,R2) Point to old parameter\n         EX    R15,COMPWORD        If values are equal,\n         BE    ERROR_PARM_DUPLICATE then error\nKVKWNEXT LA    R2,KEYDDATL(,R2)    Else continue\n         BCT   R8,KVKWLOOP         until no more keywords\nKVKWLEND DS    0H                  End loop to check for duplicates\n         LA    R6,1(,R6)           Increment keyword count\n         LA    R2,1(,R15)          Get length\n         ST    R1,KEYWORDA         Save address of this pos. parm.\n         ST    R2,KEYWORDL         Save length of this pos. parm.\n         ST    R4,LASTAREA         Save for option/error processing\n         ST    R1,LASTADDR         Save for option/error processing\n         ST    R2,LASTLEN          Save for option/error processing\n         XR    R0,R0               Clear other keyword/value fields\n         ST    R0,KEYDVALA\n         ST    R0,KEYDVALL\n         ST    R0,KEYDPCEA\n         ST    R0,KEYDPCEL\n         ST    R0,KEYDMAXL\n         ST    R0,KEYSUBOF\n         MVI   KEYFLAGS,0\nKVOLOOP  DS    0H\n*\n* Now get the next thing, which might be a parenthesized default value\n* or a slashed keyword processing option\n*\n         BAL   R14,SCAN            Get a keyword parameter\n         B     KVFINEND            No more\n         B     KVFINADD            Unquoted name, it's another keyword\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     KVVALUE             \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     KVOPTION            \"/\" found\n         SPACE 1\nKVOPTION DS    0H                  We (probably) have a /option...\n         BAL   R14,DOOPTS          Process options\n         B     KVOLOOP\n         SPACE 1\nKVVALUE  DS    0H                  We (probably) have a value...\n         SPACE 1\n*\n* Scan for the value (can be any kind of string).\n*\n         BAL   R14,SCAN            Get a value string\n         B     KVNULL              End of buffer, value is null\n         B     KVWORD              Unquoted name, it's a value\n         B     KVSTRING            Quoted string found, it's a value\n         B     KVERROR             \"(\" found, should never happen\n         B     KVNULL              \")\" found, value is null\n         B     KVERROR             \"/\" found, should never happen\n         SPACE 1\nKVWORD   DS    0H                  Unquoted word is the value\n         ST    R1,KEYDVALA         Store address of default value\n         ST    R2,KEYDVALL         Store length of default value\n         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present\n         B     KVGETRP             Go get right paren\n         SPACE 1\nKVSTRING DS    0H                  Quoted string is the value\n         ST    R1,KEYDVALA         Store address of default value\n         ST    R2,KEYDVALL         Store length of default value\n         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present\n         OI    KEYFLAGS,KEYFQUOT   Indicate it's a quoted string\n         B     KVGETRP             Go get right paren\n         SPACE 1\nKVGETRP  DS    0H                  Time to terminate the value...\n*\n* Scan for the right parenthesis that ends the value spec\n*\n         BAL   R14,SCAN            Get a value string\n         B     KVFINEND            End of buffer\n         B     KVEXTRA             Unquoted name, shouldn't be there\n         B     KVEXTRA             Quoted string, shouldn't be there\n         B     KVERROR             \"(\" found, should never happen\n         B     KVFINLOP            \")\" found, OK, continue looping\n         B     KVERROR             \"/\" found, should never happen\n         SPACE 1\nKVEXTRA  DS    0H\n*                                  (future extension, but for now)\n         LR    R3,R1               Get address of extraneous data\n******** LR    R2,R2               Get length of extraneous data\n         LA    R1,MSG_EXTRANEOUS   Ignore extraneous info\n         LA    R0,L'MSG_EXTRANEOUS\n         BAL   R14,PUTLINE\n         B     KVGETRP             Keep looking for that right paren\n         SPACE 1\nKVNULL   DS    0H\n         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present\n         LA    R14,KVLOOP          (but it's null)\n         B     KVACCUM             Accumulate length, then get next KW\n         SPACE 1\nKVFINLOP DS    0H                  End keyword(value), another follows\n         LA    R14,KVLOOP          Proceed to KVLOOP after doing...\n         B     KVACCUM             accumulation for this keyword\n         SPACE 1\nKVFINADD DS    0H                  End this keyword, another follows\n         LA    R14,KVADD           Proceed to KVADD after doing...\n         B     KVACCUM             accumulation for this keyword\n         SPACE 1\nKVFINEND DS    0H                  End this keyword, no more follow\n         LA    R14,KVEND           Proceed to KVEND after doing...\n******** B     KVACCUM             accumulation for this keyword\n         SPACE 1\nKVACCUM  DS    0H\n*\n*   Calculate PCE and PDE lengths for keyword parameter\n*   For each keyword with a value:\n*     66 + (2 * length(min(name,237))) + length(name)\n*   For each keyword without value:\n*     11 + length(name)\n*\n* We're going to use the same storage to build unquoted values of\n* keywords, so add that length in too.\n*\n         STM   R1,R2,SCANRES       Save results of scan\n         L     R15,KEYWORDL        Get length of keyword name\n         TM    KEYFLAGS,KEYFDVAL   If a value specified\n         BNO   PCKWNVAL            then...\n         CH    R15,=H'237'         min(name,237)\n         BNH   *+8\n         LA    R15,237\n         ST    R15,KEYDMAXL        Save this length\n         SLA   R15,1               2 * length(min(name,237))\n         LA    R15,66(,R15)        66 + (2 * length(min(name,237)))\n         A     R15,KEYWORDL        66 + ... + length(name)\n         LA    R1,8                Accumulate PDL length for subfield\n         A     R1,PDLLEN\n         ST    R1,PDLLEN\n         TM    KEYFLAGS,KEYFQUOT   If value is quoted string\n         BNO   PCKWNEXT            then...\n         L     R1,KEYDVALL          accumulate value length\n         A     R1,QVALLEN\n         ST    R1,QVALLEN          (actual'll be less, but never more)\n         B     PCKWNEXT\nPCKWNVAL DS    0H                  No value specified...\n         LA    R15,11(,R15)        just 11 + length(name)\nPCKWNEXT DS    0H\n         ST    R15,KEYDPCEL        Save PCE length\n         A     R15,PCLLEN          Accumulate PCL length for keyword\n         ST    R15,PCLLEN\n         LA    R1,2                Accumulate PDL length for keyword\n         A     R1,PDLLEN\n         ST    R1,PDLLEN\n         LM    R1,R2,SCANRES       Load results of scan\n         BR    R14                 Go to KVADD or KVEND or KVLOOP\n         SPACE 1\nKVEND    DS    0H                  No more parameters of any kind\n         SPACE 1\n         ST    R6,KEYCOUNT         Save number of keywords\n         SPACE 1\n         EJECT\n***********************************************************************\n*                                                                     *\n* Prepare to build control blocks for IKJPARS for the parameters,     *\n* like so:                                                            *\n*                                                                     *\n*          IKJPARM                                                    *\n*                                                                     *\n*   For each positional parameter \"pp\":                               *\n*                                                                     *\n*          IKJIDENT 'POSITIONAL PARAMETER pp',                        *\n*                ASIS,   /* only if the /ASIS option is specified */  *\n*                CHAR,   /* only if /QUOTABLE option is specified */  *\n*                FIRST=ANY,OTHER=ANY,                                 *\n*                PROMPT='POSITIONAL PARAMETER pp'                     *\n*                                                                     *\n*   For each keyword parameter \"kv\" with a value \"val\";               *\n*                                                                     *\n*          IKJKEYWD                                                   *\n*          IKJNAME 'kv',SUBFLD=kvsubfld                               *\n*                                                                     *\n*   For each keyword parameter \"kw\" without a value:                  *\n*                                                                     *\n*          IKJKEYWD                                                   *\n*          IKJNAME 'kv'                                               *\n*                                                                     *\n*   For each keyword parameter \"kv\" with a value \"val\", as above:     *\n*                                                                     *\n* kvsubfld IKJSUBF                                                    *\n*          IKJIDENT 'VALUE FOR KEYWORD kv',                           *\n*                ASIS,   /* only if the /ASIS option is specified */  *\n*                CHAR,                                                *\n*                PROMPT='VALUE FOR KEYWORD kv'                        *\n*                                                                     *\n*          IKJENDP                                                    *\n*                                                                     *\n* Note that the default value from the specifications is not part of  *\n* the IKJPARS parameters.  Rather, the absence of the keyword is      *\n* detected after the call to PARSE and, at that point, the default    *\n* value is used if the terminal user did not provide one.             *\n*                                                                     *\n* Compute storage needed for the PCL (built by us):                   *\n*                                                                     *\n*   For initial overhead:            7                                *\n*   For each positional parameter:   56 + (2 * length(name))          *\n*   For each keyword with a value:   66 + (3 * length(name))          *\n*   For each keyword without value:  11 + length(name)                *\n*                                                                     *\n* Compute storage reserved for the PDL (built by IKJPARS):            *\n*                                                                     *\n*   For initial overhead:            8                                *\n*   For each positional parameter:   8                                *\n*   For each keyword:                2                                *\n*   For each value subfield:         8                                *\n*                                                                     *\n* We're going to use the same storage to build unquoted values of     *\n* keywords, so add that length in too.  Also, we want to include      *\n* storage for the final call to IKJCT441 to update all parameters.    *\n* How much storage is needed to build the parameter list:  9 words    *\n* for each parameter, plus 4 extra words = 13*4.                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\n* Get storage for the PCL plus dequoted value strings plus IKJCT441 PL\n*\n         L     R1,PDLLEN\n         LA    R1,7(,R1)           Round PDL length\n         N     R1,=X'FFFFFFF8'      up to doubleword boundary\n         ST    R1,PDLLEN           Store length of PDL\n         LA    R1,8\n         A     R1,QVALLEN          Quoted-string-length + fudge factor\n         ST    R1,QVALLEN          Store length of quoted-value area\n         A     R1,PCLLEN           Get length of PCL plus quoted area\n         L     R0,POSCOUNT         Get count of positional parameters\n         A     R0,KEYCOUNT         Add count of positional parameters\n         MH    R0,=Y(13*4)         Compute # of plists required\n         ST    R0,VUPLEN           Store length of IKJCTT41 parm list\n         AR    R0,R1               Add to total length\n         ST    R0,PWLEN            Store length of this area\n         GETMAIN RC,LV=(0),LOC=ANY Get it\n         LTR   R15,R15             If didn't get it, error\n         BNZ   GETMAIN_FAILURE\n         ST    R1,PWADDR           Save address thereof\n         LR    R4,R1               Initialize PCL entry pointer\n         LA    R5,8                Initialize PDL offset value\n         XR    R0,R0               Clear other PCE-related junk\n         ST    R0,FIRSTKEY\n         ST    R0,SUBTOSET\n*\n* Build the IKJPARM part of the PCL.\n*\n* PCE contents:  +0 (2)  Length of entire PCL\n*                +2 (2)  Length of PDL returned by PARSE\n*                +4 (2)  Offset in PDL to first IKJKEYWD PCE\n*                        (or to end-of-field indicator, i.e.\n*                        the x'0000' in an IKJSUBF or IKJENDP)\n*\n*        ...   ..,0(,R4)           Leave this unset for now...\n         L     R0,PDLLEN\n         STH   R0,2(,R4)           IKJPARM +2 (2) Length of PDL\n*        ...   ..,4(,R4)           Leave this unset for now...\n         LA    R4,6(,R4)           Bump past this PCE\n*\n* For each positional parameter, build an IKJIDENT PCE.\n*\n* PCE contents:  +0 (1)  Flags:  B'1001 0100' (IKJIDENT, PROMPT)\n*                +1 (1)  Flags:  B'0x00 0000' (x = 1 if ASIS, else 0)\n*                +2 (2)  Length of this PCE: 56 + 2*length(name)\n*                +4 (2)  Offset in PDL to PDE for this parameter\n*                +6 (1)  Flags:  B'0000 x000' (x = 1 if CHAR, else 0)\n*                +7 (1)  X'00' (FIRST=ANY)\n*                +8 (1)  X'00' (OTHER=ANY)\n*                +9 (2)  Length of 'POSITIONAL PARAMETER pp' + 4\n*                                  (25 + length(name))\n*                +B (2)  X'0012'\n*                +D (*)  'POSITIONAL PARAMETER pp' (21 + length(name))\n*                +* (1)  Length of 'POSITIONAL PARAMETER pp' - 1\n*                                  (20 + length(name))\n*                +* (*)  'POSITIONAL PARAMETER pp' (21 + length(name))\n*\n         ICM   R8,15,POSCOUNT      Get count of positionals\n         BZ    PBPPLEND            If none, skip\n         L     R2,APOSD            Get address of first positional\nPBPPLOOP DS    0H                  Loop to build PCE's\n         ST    R4,POSDPCEA-POSDDATA(,R2) Set address of PCE for this\n         MVI   0(R4),B'10010100'   +0 (1) Flags\n         TM    POSDFLGS-POSDDATA(R2),POSDASIS If /ASIS option given\n         BZ    PBPPNASI                       then\n         MVI   1(R4),B'01000000'   +1 (1) Flags\n         B     PBPPAEND                       else\nPBPPNASI MVI   1(R4),B'00000000'   +1 (1) Flags\nPBPPAEND DS    0H\n         L     R14,POSDPCEL-POSDDATA(,R2) Get length of PCE\n         STH   R14,2(,R4)          +2 (2) Length of this PCE\n         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this\n         TM    POSDFLGS-POSDDATA(R2),POSDCHAR If /QUOTABLE option given\n         BZ    PBPPNCHA                       then\n         MVI   6(R4),B'00001000'   +6 (1) Flags\n         B     PBPPCEND                       else\nPBPPNCHA MVI   6(R4),B'00000000'   +6 (1) Flags\nPBPPCEND DS    0H\n         MVI   7(R4),X'00'         +7 (1) X'00' (FIRST=ANY)\n         MVI   8(R4),X'00'         +8 (1) X'00' (OTHER=ANY)\n         L     R15,POSDMAXL-POSDDATA(,R2) Get length of name for prompt\n         LA    R0,25(,R15)         21 + length(name) + 4\n         STH   R0,9(,R4)           +9 (2) Length of '...' + 4\n         MVC   11(2,R4),=X'0012'   +B (2) X'0012'\n         MVC   13(21,R4),=C'POSITIONAL PARAMETER '\n         LA    R4,13+21(,R4)       Point to where to move param name\n         BCTR  R15,0               Reduce length for execute\n         L     R1,POSDADDR-POSDDATA(,R2) Get address of parameter name\n         EX    R15,MVCTOPCE        Move parameter name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R0,21(,R15)         21 + length(name) - 1\n         STC   R0,0(,R4)           Length of prompt data\n         MVC   1(21,R4),=C'POSITIONAL PARAMETER '\n         LA    R4,1+21(,R4)        Point to where to move param name\n         EX    R15,MVCTOPCE        Move parameter name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R5,8(,R5)           Increment PDE offset\n         LA    R2,POSDDATL(,R2)    Continue\n         BCT   R8,PBPPLOOP          until no more positionals\nPBPPLEND DS    0H                  End loop\n*\n* For each keyword parameter, build an IKJKEYWD PCE.\n*\n* PCE contents:  +0 (1)  Flags:  B'0100 0000' (IKJKEYWD)\n*                +1 (1)  Flags:  B'0000 0000'\n*                +2 (2)  Length of this PCE: 6\n*                +4 (2)  Offset in PDL to PDE for this parameter\n*\n* If the keyword has a value, build an IKJNAME PCE as follows:\n*\n* PCE contents:  +0 (1)  Flags:  B'0110 0100' (IKJNAME, has subfield)\n*                +1 (1)  Flags:  B'0000 0000'\n*                +2 (2)  Length of this PCE: 7 + length(name)\n*                +4 (1)  Length of keyword name minus 1\n*                +5 (*)  the keyword name\n*                +* (2)  offset (plus 1) in PCL to subfield PCE\n*\n* A subfield will be built as well.  But not now.\n*\n* If the keyword doesn't have a value, build an IKJNAME PCE as follows:\n*\n* PCE contents:  +0 (1)  Flags:  B'0110 0000' (IKJNAME, no subfield)\n*                +1 (1)  Flags:  B'0000 0000'\n*                +2 (2)  Length of this PCE: 5 + length(name)\n*                +4 (1)  Length of keyword name minus 1\n*                +5 (*)  the keyword name\n*\n         ICM   R8,15,KEYCOUNT      Get count of keywords\n         BZ    PBKWLEND            If none, skip\n         L     R2,AKEYD            Get address of first keyword\nPBKWLOOP DS    0H                  Loop to build PCE's\n*\n* Build IKJKEYWD PCE\n*\n         ICM   R0,15,FIRSTKEY      If this is first keyword\n         BNZ   *+8                 then\n         ST    R4,FIRSTKEY         set address of first keyword PCE\n         ST    R4,KEYDPCEA-KEYDDATA(,R2) Set address of PCE for this\n         MVI   0(R4),B'01000000'   +0 (1) Flags (IKJKEYWD)\n         MVI   1(R4),B'00000000'   +1 (1) Flags\n         LA    R0,6\n         STH   R0,2(,R4)           +2 (2) Length of this PCE\n         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this\n         LA    R4,6(,R4)           Bump PCE pointer\n*\n* Build IKJNAME PCE, format of which depends if with value or not.\n*\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFDVAL If a value specified\n         BNO   PBKWNVAL            then...\n         MVI   0(R4),B'01100100'   +0 (1) Flags (IKJNAME, has subfield)\n         MVI   1(R4),B'00000000'   +1 (1) Flags\n         L     R15,KEYWORDL-KEYDDATA(,R2) Get length of parameter name\n         LA    R0,7(,R15)                7 + length(name)\n         STH   R0,2(,R4)           +2 (2) Length of this PCE\n         BCTR  R15,0               Length minus 1 for store & execute\n         STC   R15,4(,R4)          +4 (1) Length of keyword name - 1\n         LA    R4,5(,R4)           Point to where to move keyword name\n         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCE\n         LA    R4,1(R15,R4)        Bump past name\n         ST    R4,KEYSUBOF-KEYDDATA(,R2) Save where to set subfield off\n*        ...   ...0(,R4)           Leave subfield offset out for now\n         LA    R4,2(,R4)           Bump to end of PCE\n         B     PBKWNEXT\nPBKWNVAL DS    0H                  No value specified...\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFASIS If /ASIS was specified\n         BO    ERROR_ASIS_NEEDS_VAL           then error\n         MVI   0(R4),B'01100000'   +0 (1) Flags (IKJNAME, no subfield)\n         MVI   1(R4),B'00000000'   +1 (1) Flags\n         L     R15,KEYWORDL-KEYDDATA(,R2) Get length of parameter name\n         LA    R0,5(,R15)                5 + length(name)\n         STH   R0,2(,R4)           +2 (2) Length of this PCE\n         BCTR  R15,0               Length minus 1 for store & execute\n         STC   R15,4(,R4)          +4 (1) Length of keyword name - 1\n         LA    R4,5(,R4)           Point to where to move keyword name\n         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCE\n         LA    R4,1(R15,R4)        Bump past name\n******** LA    R4,0(,R4)           Bump to end of PCE\nPBKWNEXT DS    0H\n         LA    R5,2(,R5)           Increment PDE offset\n         LA    R2,KEYDDATL(,R2)    Continue\n         BCT   R8,PBKWLOOP          until no more keywords\nPBKWLEND DS    0H                  End loop\n*\n* For each keyword parameter with a value, build subfield PCE's.\n*\n* Build an IKJSUBF PCE.\n*\n* PCE contents:  +0 (1)  Flags:  B'0000 0000' (end-of-field indicator)\n*                +1 (2)  Offset in PCL to next end-of-field indicator\n*                        (either the next IKJSUBF or the IKJENDP).\n*                        If the subfield had keywords, this would have\n*                        to point to the next IKJKEYWD PCE therein.\n*\n* Build an IKJIDENT PCE for the keyword value.\n*\n* PCE contents:  +0 (1)  Flags:  B'1001 0100' (IKJIDENT, PROMPT)\n*                +1 (1)  Flags:  B'0x00 0000' (x = 1 if ASIS, else 0)\n*                +2 (2)  Length of this PCE: 50 + 2*length(name)\n*                +4 (2)  Offset in PDL to PDE for this parameter\n*                +6 (1)  Flags:  B'0000 1000' (CHAR)\n*                +7 (1)  X'01' (FIRST= is not applicable)\n*                +8 (1)  X'01' (OTHER= is not applicable)\n*                +9 (2)  Length of 'VALUE FOR KEYWORD pp' + 4\n*                                  (22 + length(name))\n*                +B (2)  X'0012'\n*                +D (*)  'VALUE FOR KEYWORD pp' (18 + length(name))\n*                +* (1)  Length of 'VALUE FOR KEYWORD pp' - 1\n*                                  (17 + length(name))\n*                +* (*)  'VALUE FOR KEYWORD pp' (18 + length(name))\n*\n         ICM   R8,15,KEYCOUNT      Get count of keywords\n         BZ    PSKWLEND            If none, skip\n         L     R2,AKEYD            Get address of first keyword\nPSKWLOOP DS    0H                  Loop to build subfield PCE's\n         ICM   R14,15,KEYSUBOF-KEYDDATA(R2) Get where to put sub offset\n         BZ    PSNOSUB             If none, skip\n         LA    R0,1(,R4)           Get address of PCE we're building\n         S     R0,PWADDR           Convert to offset plus 1\n         STH   R0,0(,R14)          Set keyword PCE's subfield offset\n*\n* Build IKJSUBF PCE\n*\n         ICM   R1,15,SUBTOSET      If there's a previous IKJSUBF PCE\n         BZ    PSNSUBST            to set, then\n         LR    R0,R4                get address of this IKJSUBF PCE\n         S     R0,PWADDR            convert to offset\n         STH   R0,1(,R1)            set offset to next subfield\nPSNSUBST DS    0H\n         ST    R4,SUBTOSET         Set address of subfield to set\n         MVI   0(R4),B'00000000'   +0 (1) Flags (end-of-field indicator\n*        ...   ...,1(,R4)          +1 (1) Offset of next SUBF or ENDP\n         LA    R4,3(,R4)           Bump PCE pointer\n         MVI   0(R4),B'10010100'   +0 (1) Flags (IKJIDENT, PROMPT)\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFASIS If /ASIS option given\n         BZ    PSNASIS                        then\n         MVI   1(R4),B'01000000'   +1 (1) Flags\n         B     PSNAEND                        else\nPSNASIS  MVI   1(R4),B'00000000'   +1 (1) Flags\nPSNAEND  DS    0H\n         L     R15,KEYDMAXL-KEYDDATA(,R2) Get length of name for prompt\n         LR    R14,R15\n         SLA   R14,1               2 * length(name)\n         LA    R14,50(,R14)        50 + (2 * length(name))\n         STH   R14,2(,R4)          +2 (2) Length of this PCE\n         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this\n         MVI   6(R4),B'00001000'   +6 (1) Flags (CHAR)\n         MVI   7(R4),X'01'         +7 (1) X'01' (FIRST=n/a)\n         MVI   8(R4),X'01'         +8 (1) X'01' (OTHER=n/a)\n         LA    R0,22(,R15)         18 + length(name) + 4\n         STH   R0,9(,R4)           +9 (2) Length of '...' + 4\n         MVC   11(2,R4),=X'0012'   +B (2) X'0012'\n         MVC   13(18,R4),=C'VALUE FOR KEYWORD '\n         LA    R4,13+18(,R4)       Point to where to move keyword name\n         BCTR  R15,0               Length minus 1 for store & execute\n         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R0,18(,R15)         18 + length(name) - 1\n         STC   R0,0(,R4)           Length of prompt data\n         MVC   1(18,R4),=C'VALUE FOR KEYWORD '\n         LA    R4,1+18(,R4)        Point to where to move keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R5,8(,R5)           Increment PDE offset\nPSNOSUB  DS    0H\n         LA    R2,KEYDDATL(,R2)    Continue\n         BCT   R8,PSKWLOOP          until no more keywords\nPSKWLEND DS    0H                  End loop\n         SPACE 1\n*\n* Build the IKJENDP part of the PCL.\n*\n* PCE contents:  +0 (1)  Flags:  B'0000 0000' (end-of-field indicator)\n*\n         MVI   0(R4),B'00000000'   +0 (1) Flags\n         ICM   R1,15,SUBTOSET      If there's a previous IKJSUBF PCE\n         BZ    PENSUBST            to set, then\n         LR    R0,R4                get address of this IKJENDP PCE\n         S     R0,PWADDR            convert to offset\n         STH   R0,1(,R1)            set offset to next subfield\nPENSUBST DS    0H\n         ICM   R1,15,FIRSTKEY      If no keyword PCE built\n         BNZ   PEGOTKEY            then\n         ST    R4,FIRSTKEY          make this the one\nPEGOTKEY DS    0H\n         L     R15,PWADDR          Get address of start of PCE\n         L     R0,FIRSTKEY         Load offset of first key/or/etc.PCE\n         SR    R0,R15              Convert to offset\n         STH   R0,4(,R15)          Set offset in IKJPARM PCE\n         LA    R4,1(,R4)           Bump past this PCE\n         LR    R0,R4\n         S     R0,PWADDR           Convert to offset\n         ST    R0,PCLLEN           Set actual PCL length\n         L     R1,PWADDR           Get address of IKJPARM PCE\n         STH   R0,0(,R1)           IKJPARM +0 (2) Length of PCL\n         ST    R4,QOFF             Save address of where to build\n*                                   unquoted strings\n*\n* Note that unquoted strings won't be built until/unless we assign\n* default values from them after a successful parse of the arguments.\n*\n         EJECT\n*\n* Next steps:  If initial variable specified, use IKJCT441 to get its\n*              value.  Otherwise use REXX call to get at arguments.\n*              Make a command buffer out of this and call IKJPARS.\n*              If parsing successful, go thru each positional and\n*              keyword parameter, getting its value, and assign all\n*              the values using IKJCT441.\n*\n         ICM   R0,15,PVARADDR      Get address of first-arg variable\n         BZ    NOVAR               If none, try REXX arg call\n         ST    R0,CVNAMEA          Set address of variable name\n         L     R0,PVARLEN          Get length of first-arg variable\n         ST    R0,CVNAMEL          Set length of variable name\n         LA    R0,TSVERETR         Return variable value\n*                                  (create variable if doesn't exist)\n         ST    R0,CVENTRY          Set entry code\n         XR    R0,R0\n         ST    R0,CVVALUEA         Address of variable value\n         ST    R0,CVVALUEL         Length of variable value\n         ST    R0,CVTOKEN          Token\n         LA    R14,CVENTRY         Store into IKJCT441 parameter list\n         LA    R15,CVNAMEA\n         LA    R0,CVNAMEL\n         LA    R1,CVVALUEA\n         LA    R2,CVVALUEL\n         LA    R3,CVTOKEN\n         L     R4,CPPLECT          Address of passed ECT        #TSO172\n         STM   R14,R4,CVPARMS                                   #TSO172\n         OI    CVPARM7,X'80'       Set VL bit                   #TSO172\n         LA    R1,CVPARMS          Point to parameter list\n         L     R15,X'10'               Get address of CVT\n         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table\n         L     R15,TSVTVACC-TSVT(,R15) Get address of IKJCT441\n         BALR  R14,R15             Call variable access routine\n         CH    R15,=H'4'           Get return code\n         BNH   GETVAROK            If not 0 or 4, error\n         BAL   R14,ERROR_GETTING_VAR\n         B     FLUSHIT\n         SPACE 1\nNOVAR    DS    0H                  No variable, try REXX arg call\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Invoke the IRXEXCOM routine to fetch the ARG information.           *\n*                                                                     *\n* Reference: TSO/E Version 2 REXX Reference, pp. 240-246              *\n*                                                                     *\n***********************************************************************\n*\n* Build the SHVBLOCK\n*\n* To store the argument value, we try using ARGWA, a 512-byte area\n* that is already part of our workarea, to avoid unnecessary GETMAINs.\n*\n* If that doesn't turn out to be big enough, we'll have to GETMAIN,\n* but it's best to avoid that.\n*\n         XC    SHVBLOCK(SHVBLEN),SHVBLOCK\n         MVI   SHVCODE,SHVPRIV     Fetch private information\n         LA    R1,L'ARGWA\n         ST    R1,SHVBUFL          Length of 'fetch' value buffer\n         LA    R1,ARGWA\n         ST    R1,SHVVALA          Address of value buffer\n         LA    R1,=C'ARG'          Name of thing to be fetched\n         ST    R1,SHVNAMA          Address of variable name\n         LA    R1,3                Length('ARG')\n         ST    R1,SHVNAML          Length of variable name\n         LA    R14,=CL8'IRXEXCOM'  IRXEXCOM parm 1\n         XR    R15,R15             IRXEXCOM parm 2\n         LR    R0,R15              Parm 3 must be same as Parm 2\n         LA    R1,SHVBLOCK         IRXEXCOM parm 4\n         STM   R14,R1,IRPARMS\n         OI    IRPARM4,X'80'\nRETRYIRX DS    0H\n*        XR    R0,R0               Don't specify an environment #TSO162\n         L     R1,CPPLECT          Get passed ECT address       #TSO162\n         L     R0,ECTENVBK-ECT(,R1) Get addr of REXX envir. blk #TSO162\n         LA    R1,IRPARMS          Point to parameter list\n         L     R15,X'10'               Get address of CVT\n         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table\n         L     R15,TSVTEXCO-TSVT(,R15) Get address of IRXEXCOM\n         BALR  R14,R15             Call REXX arg access routine\n         LTR   R15,R15             If rc zero\n         BZ    OKIRX               then OK\n         CH    R15,=Y(SHVTRUNC)    If value was truncated\n         BE    OOPSIRX             then need more room to hold value\n         B     ERROR_IRXEXCOM      Else error\nOOPSIRX  DS    0H                  Not enough room to hold value\n         ICM   R1,15,ARGADDR       Get address of arg buffer\n         BZ    NOARGYET            If nonzero, then...\n         L     R0,ARGLEN           Get length\n         FREEMAIN RC,LV=(0),A=(1)\nNOARGYET DS    0H\n         LA    R0,1024             Increment arg len so far\n         A     R0,ARGLEN\n         ST    R0,ARGLEN\n         ST    R0,SHVBUFL          Reset length of fetch buffer\n         GETMAIN RC,LV=(0),LOC=ANY\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         ST    R1,ARGADDR\n         ST    R1,SHVVALA          Reset address of value buffer\n         B     RETRYIRX            Try again\nOKIRX    DS    0H                  Everything OK\n         MVC   CVVALUEL,SHVVALL    Set length of arg value\n         MVC   CVVALUEA,SHVVALA    Set address of arg value\n         SPACE 1\nGETVAROK DS    0H\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Build a fake command buffer containing the value of the variable,   *\n* for use by IKJPARS.  Format:                                        *\n* ___________________________________________________________________ *\n* |            |       |                                            | *\n* | valuelen+4 | zero  |  value text                                | *\n* |____________|_______|____________________________________________| *\n*                                                                     *\n***********************************************************************\n*\n         LA    R2,4                Get 4 + ...\n         A     R2,CVVALUEL             length of variable value\n         ST    R2,VBUFLEN          Save length\n         GETMAIN RC,LV=(R2),LOC=ANY Get a fake command buffer\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         ST    R1,VBUFADDR         Save address of fake command buffer\n         SLL   R2,16               Make buffer prefix\n         ST    R2,0(,R1)           Store into fake command buffer\n         LA    R2,4(,R1)           Address of fake command buffer text\n         L     R14,CVVALUEA        Address of variable value\n         L     R15,CVVALUEL        Length of variable value\n         LR    R3,R15              Length of fake command buffer text\n         MVCL  R2,R14              Move variable value to fake buffer\n*\n***********************************************************************\n*                                                                     *\n* Set up to call IKJPARS.                                             *\n*                                                                     *\n***********************************************************************\n*\n         XC    ANSWER,ANSWER       Clear PDL address field\n         MVC   PPLUPT,CPPLUPT      Address of UPT\n         MVC   PPLECT,CPPLECT      Address of ECT\n         LA    R14,ECB             Address of ECB\n         L     R15,PWADDR          Address of the PCL we built\n         LA    R0,ANSWER           Address of PARSE answer area\n         L     R1,VBUFADDR         Address of our fake command buffer\n         STM   R14,R1,PPLECB       Set rest of PPL\n         ST    R9,PPLUWA           User work area = \"DATD\"\n         ST    R9,PPLVEWA          (we don't use verify exit, but...)\n         SPACE 1\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)\n         LTR   R15,R15\n         BNZ   ERROR_PARSE_FAILURE\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Now that PARSE has successfully gotten values for all parameters,   *\n* go through them and retrieve their values, which will be used to    *\n* set variables via IKJCT441.                                         *\n*                                                                     *\n***********************************************************************\n*\n         L     R7,ANSWER           Get address of PDL\n         L     R5,PWADDR           Get address of PCL-et-al work area\n         A     R5,PCLLEN           Bump past PCL part\n         A     R5,QVALLEN          Bump past unquoted-string part\n         LA    R5,3(,R5)           Round up to\n         N     R5,=X'FFFFFFFC'      fullword boundary\n         ST    R5,VUPADDR          Save address of this plist\n*\n* Format of each block of IKJCT441 parameter list:\n*\n*  +00 -> Entry code (TSVEUPDT)\n*  +04 -> Address of variable name\n*  +08 -> Length of variable name\n*  +0C -> Address of variable value\n*  +10 -> Length of variable value\n*  +14 -> Token (zero, not used)\n*  +18 -> ECT                                                   #TSO172\n*  +1C -> Return code from IKJCT441\n*  +20 -> Address of next block of this parameter list or X'80000000'\n*  +24 ... not part of plist, but space to hold the address of value\n*  +28 ... not part of plist, but space to hold the length of value\n*  +2C ... not part of plist, but space to hold the return code\n*  +30 ... not part of plist, but space to hold the address of link\n*\n         XR    R0,R0\n         ST    R0,CVTOKEN\n*        MVC   CVECT,=X'FFFFFFFF'                               #TSO172\n         LA    R15,TSVEUPDT        Entry code = update variable\n         ST    R15,CVENTRY         Set entry code\n         L     R4,POSCOUNT         Get # of positionals\n         A     R4,KEYCOUNT           + # of keywords\n         BZ    NOUPDATE            If no parameters, no updating.\n         L     R15,VUPADDR         Get address of the plist\nBPLOOP   DS    0H\n         LR    R5,R15              Point to this element of parm list\n         LA    R15,CVENTRY\n         ST    R15,X'00'(,R5)      Parameter 1: entry code\n*                                  Set later...\n*        ST       ,X'04'(,R5)      Parameter 2: address of var name\n*                                  Set later...\n*        ST       ,X'08'(,R5)      Parameter 3: length of var name\n         LA    R15,X'24'(,R5)      Value address slot\n         ST    R15,X'0C'(,R5)      Parameter 4: address of var value\n         LA    R15,X'28'(,R5)      Value length slot\n         ST    R15,X'10'(,R5)      Parameter 5: length of var value\n         LA    R15,CVTOKEN         Dummy token\n         ST    R15,X'14'(,R5)      Parameter 6: token (not used)\n*        LA    R15,CVECT           Dummy ECT                    #TSO172\n         L     R15,CPPLECT         Address of passed ECT        #TSO172\n         ST    R15,X'18'(,R5)      Parameter 7: ECT             #TSO172\n         LA    R15,X'2C'(,R5)      Return code slot\n         ST    R15,X'1C'(,R5)      Parameter 8: IKJCT441 return code\n         LA    R15,X'30'(,R5)      Link slot\n         ST    R15,X'20'(,R5)      Parameter 9: next element in list\n         LA    R15,X'34'(,R5)\n         ST    R15,X'30'(,R5)      Address of next plist block\n         OI    X'20'(R5),X'80'     Set VL bit\n         BCT   R4,BPLOOP           Continue\n         L     R0,=X'00000000'     At end,\n         ST    R0,X'30'(,R5)       clear last link pointer in list\n         L     R5,VUPADDR          Point to first plist block again\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Now go through positional parameters, setting things up.            *\n*                                                                     *\n* Format of PDE for a positional parameter (IKJIDENT):                *\n*                                                                     *\n* +0 (4) Pointer to the positional operand                            *\n* +4 (2) Length thereof                                               *\n* +6 (1) Flags                                                        *\n* +7 (1) Reserved                                                     *\n*                                                                     *\n* Meaning of flags:  0... ....  The operand is not present.           *\n*                    1... ....  The operand is present.               *\n*                    .xxx xxxx  Reserved bits.                        *\n*                                                                     *\n***********************************************************************\n*\n         ICM   R8,15,POSCOUNT      Get count of positionals\n         BZ    BPPPLEND            If none, skip\n         L     R2,APOSD            Get address of first positional\nBPPPLOOP DS    0H                  Loop to fill in IKJCT441 plist\n         LA    R15,POSDADDR-POSDDATA(,R2) Get address of param name\n         ST    R15,X'04'(,R5)      Parameter 2: address of var name\n         LA    R15,POSDLEN-POSDDATA(,R2) Get length of param name\n         ST    R15,X'08'(,R5)      Parameter 3: length of var name\n         L     R15,POSDPCEA-POSDDATA(,R2) Get address of PCE\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n*\n* Note: Of course it's impossible for the operand not to be present\n*       under the current implementation.  But a future extension\n*       might make this possible.\n*\n         TM    6(R1),X'80'         If operand is not present,\n         BO    BPPPPRES            then...\n         XR    R14,R14              say it's set to a null value\n         XR    R15,R15              say it's set to a null value\n         B     BPPPSET             else...\nBPPPPRES DS    0H                  (operand is present)\n         L     R14,0(,R1)           get address of value\n         LH    R15,4(,R1)           get length of value\nBPPPSET  DS    0H                  else (operand is present)\n         ST    R14,X'24'(,R5)      Set address of variable value\n         ST    R15,X'28'(,R5)      Set length of variable value\n         L     R5,X'20'(,R5)       Go to\n         L     R5,0(,R5)                 next element of param list\n         LA    R2,POSDDATL(,R2)    Continue\n         BCT   R8,BPPPLOOP          until no more positionals\nBPPPLEND DS    0H                  End loop\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Now go through keyword parameters, setting things up.               *\n*                                                                     *\n* Format of PDE for a keyword parameter (IKJKEYWD):                   *\n*                                                                     *\n* +0 (2) Number (0 if not specified, 1 if specified)                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Format of PDE for a keyword value parameter (IKJIDENT):             *\n*                                                                     *\n* +0 (4) Pointer to the positional operand                            *\n* +4 (2) Length thereof                                               *\n* +6 (1) Flags                                                        *\n* +7 (1) Reserved                                                     *\n*                                                                     *\n* Meaning of flags:  0... ....  The operand is not present.           *\n*                    1... ....  The operand is present.               *\n*                    .xxx xxxx  Reserved bits.                        *\n*                                                                     *\n***********************************************************************\n*\n         ICM   R8,15,KEYCOUNT      Get count of keywords\n         BZ    BPKWLEND            If none, skip\n         L     R2,AKEYD            Get address of first keyword\nBPKWLOOP DS    0H                  Loop to fill in IKJCT441 plist\n         ST    R2,SAVER2           Save register to protect from TRT's\n         LA    R15,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         ST    R15,X'04'(,R5)      Parameter 2: address of var name\n         LA    R15,KEYWORDL-KEYDDATA(,R2) Get length of keyword name\n         ST    R15,X'08'(,R5)      Parameter 3: length of var name\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFDVAL If keyword(value),\n         BO    BPKWDVAL            then process value subfield\n*\n* Keyword without value is set to keyword name if specified, else null\n*\n         L     R15,KEYDPCEA-KEYDDATA(,R2) Get address of PCE\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n         CLC   0(2,R1),=X'0000'    If keyword is not specified,\n         BNE   BPKWWPRS            then...\n         XR    R15,R15              say it's set to a null value\n         ST    R15,X'24'(,R5)       set address of variable value\n         ST    R15,X'28'(,R5)       set length of variable value\n         B     BPKWNEXT            else...\nBPKWWPRS DS    0H                  (operand is present)\n         L     R14,X'04'(,R5)       get address of variable name\n         L     R15,X'08'(,R5)       get length of variable name\n         ST    R14,X'0C'(,R5)      Parameter 4: address of var value\n         ST    R15,X'10'(,R5)      Parameter 5: length of var value\n         B     BPKWNEXT\n         SPACE 1\nBPKWDVAL DS    0H                  Else keyword with a value specified\n*\n* Keyword with value:  If keyword is present, set from value subfield\n* (which must be present according to the PARS rules).  Otherwise,\n* set value from default from XPROC statement, unquoting if needed.\n*\n         L     R15,KEYDPCEA-KEYDDATA(,R2) Get address of PCE\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n         CLC   0(2,R1),=X'0000'    If keyword is not specified,\n         BNE   BPKWVPRS            then...\n         L     R14,KEYDVALA-KEYDDATA(,R2) get address of default value\n         L     R15,KEYDVALL-KEYDDATA(,R2) get length of default value\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFQUOT If value is quoted,\n         BNO   BPKWVSET            then...\n*                                   unquote it\n         LA    R1,1(,R14)          Get address of quoted string + 1\n         LR    R3,R15              Get length of quoted string\n         SH    R3,=H'2'            minus 2 to get length between quotes\n         BZ    BPKWNULL            If '', set variable to null value\n         LR    R15,R1\n         LR    R14,R1              Save address of string input\n         ST    R14,SCANPTR\n         AR    R14,R3              Save address of end of it\n         ST    R14,SCANEPTR\n         L     R14,QOFF            Get where to build unquoted string\n         LA    R0,256              Make a constant value of 256\nBPGOTQL  CR    R3,R0               If length greater than 256\n         BNH   BPGOTQX             then...\n         TRT   0(256,R15),STBLQUOT  scan for \"'\"\n         BNZ   BPGOTQT              If we found it, go. Else\n         MVC   0(256,R14),0(R15)    copy unquoted data to area\n         AR    R14,R0               Increment output pointer by 256\n         AR    R15,R0               Increment input pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    BPGOTQL              Either continue scanning\n         B     BPGOTQE              or, if length zero, finished\nBPGOTQX  DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,BPGQTRT           Scan for \"'\"\n         BNZ   BPGOTQT              If found something, go\n         B     BPGOTQE              else end of string\nBPGOTQT  DS    0H                  Reached \"'\"\n         CLI   1(R1),C''''         Another \"'\" has to follow\n         BNE   0(0)                (else abend)\n         LR    R3,R1               Get length we just scanned\n         SR    R3,R15\n         EX    R3,BPGQMVC          Move data so far (R15 -> it)\nBPGQNMV  DS    0H                  (including quote, so no BCTR)\n         LA    R14,1(R14,R3)       Bump past it and following quote\n         LA    R15,2(,R1)          Bump to location past \"''\"\n         L     R3,SCANEPTR\n         SR    R3,R15              R3 := length remaining to scan\n         BP    BPGOTQL             If something left, continue scan\nBPGOTQE  DS    0H                  End of quoted string\n         L     R3,SCANEPTR\n         SR    R3,R15              Get length remaining to move\n         BZ    BPGENMV             If zero, skip move\n         EX    R3,BPGQMVC          Move data so far (R15 -> it)\nBPGENMV  DS    0H                  (including quote, so no BCTR)\n         LA    R14,0(R14,R3)       Bump past it\n         LR    R15,R14\n         S     R15,QOFF            Get length of unquoted string\n         L     R1,QOFF             Get address of unquoted string\n         ST    R14,QOFF            Update where to build next string\n         LR    R14,R1\n         B     BPKWDSET            Set address and length of string\nBPKWVSET DS    0H                  else (operand is present)\n         ST    R14,X'24'(,R5)      Set address of variable value\n         ST    R15,X'28'(,R5)      Set length of variable value\n         B     BPKWNEXT\nBPKWVPRS DS    0H                  (operand is present)\n         L     R15,KEYSUBOF-KEYDDATA(,R2) Get where subfield offset is\n         LH    R15,0(,R15)         Get offset+1 of IKJSUBF PCE\n         LA    R15,2(,R15)         Bump to associated IKJIDENT PCE\n         A     R15,PWADDR          Convert to address of subfield\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n*\n* Note: Of course it's impossible for the operand not to be present\n*       under the current implementation.  But a future extension\n*       might make this possible.\n*\n         TM    6(R1),X'80'         If operand is not present,\n         BO    BPKWDPRS            then...\nBPKWNULL DS    0H\n         XR    R14,R14              say it's set to a null value\n         XR    R15,R15              say it's set to a null value\n         B     BPKWDSET            else...\nBPKWDPRS DS    0H                  (operand is present)\n         L     R14,0(,R1)           get address of value\n         LH    R15,4(,R1)           get length of value\nBPKWDSET DS    0H                  else (operand is present)\n         ST    R14,X'24'(,R5)      Set address of variable value\n         ST    R15,X'28'(,R5)      Set length of variable value\nBPKWNEXT DS    0H                  Continue\n         L     R5,X'20'(,R5)       Go to\n         L     R5,0(,R5)                 next element of param list\n         L     R2,SAVER2           Restore register clobbered by TRT\n         LA    R2,KEYDDATL(,R2)    Continue\n         BCT   R8,BPKWLOOP          until no more positionals\nBPKWLEND DS    0H                  End loop\n*\n* Now call IKJCT441 to do all the variable updates.\n*\n         L     R1,VUPADDR          Point to parameter list\n         L     R15,X'10'               Get address of CVT\n         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table\n         L     R15,TSVTVACC-TSVT(,R15) Get address of IKJCT441\n         BALR  R14,R15             Call variable access routine\n         L     R5,VUPADDR\nRCLOOP   DS    0H\n         LA    R5,0(,R5)           Clear VL bit if any\n         LTR   R5,R5\n         BZ    RCEND\n         L     R15,X'2C'(,R5)      Get return code set by IKJCT441\n         CH    R15,=H'4'           If return code\n         BNH   RCNEXT              If not 0 or 4, error\n         BAL   R14,ERROR_PUTTING_VAR\n         OI    FLAGS,FLAGPUTE\nRCNEXT   L     R5,X'20'(,R5)       Go to\n         L     R5,0(,R5)                 next element of param list\n         B     RCLOOP\nRCEND    DS    0H\n         TM    FLAGS,FLAGPUTE      If a variable update error,\n         BO    FLUSHIT             then flush\n         SPACE 1\nNOUPDATE DS    0H                  Here if no call to IKJCT441 needed\n         SPACE 1\n         B     RETURN0             Everything fine, return code(0)\n         EJECT\n*\nTRTPOSCT TRT   0(*-*,R3),NUMTBL    Executed: scan word for numerics\nPACKIT   PACK  DOUBLE(8),0(*-*,R3) Executed: convert word to decimal\nVERIFYP  TRT   0(*-*,R14),VERTBL   Executed: verify syntax of parameter\nMVCWORD  MVC   0(*-*,R1),0(R14)    Executed: move parameter to wordarea\nUPWORD   TR    0(*-*,R1),UPTBL     Executed: translate to uppercase\nCOMPWORD CLC   0(*-*,R1),0(R14)    Executed: compare parameters\nMVCTOPCE MVC   0(*-*,R4),0(R1)     Executed: move parameter name to PCE\nBPGQTRT  TRT   0(*-*,R15),STBLQUOT Executed: scan for \"'\" mark\nBPGQMVC  MVC   0(*-*,R14),0(R15)   Executed: copy unquoted data to area\n*\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Various error conditions.                                           *\n*                                                                     *\n***********************************************************************\n*\nERROR_GETTING_VAR DS 0H\n         ST    R14,E44114          Save return register\n         ST    R15,RC441           Save IKJCT441 return code\n         L     R2,CVNAMEL          Length of variable name\n         L     R3,CVNAMEA          Address of variable name\n         ERROR MSG_GETTING_VAR,FLUSH=NO\n         B     ERROR441\n         SPACE 1\nERROR_PUTTING_VAR DS 0H\n         ST    R14,E44114          Save return register\n         ST    R15,RC441           Save IKJCT441 return code\n         L     R2,X'08'(,R5)       -> Length of variable name\n         L     R2,0(,R2)           Length of variable name\n         L     R3,X'04'(,R5)       -> Address of variable name\n         L     R3,0(,R3)           Address of variable name\n         ERROR MSG_PUTTING_VAR,FLUSH=NO\n******** B     ERROR441\n         SPACE 1\nERROR441 DS    0H\n         XR    R2,R2               No additional information for...\n         XR    R3,R3\n         L     R4,RC441            Load IKJCT441 return code\n         CH    R4,=H'81'           Check IKJCT441 return code\n         BH    ERROR441_MISC       > 81\n         BE    ERROR441_RC81       = 81\n         B     *(R4)               Else branch based on return code\n         B     ERROR441_MISC       04: Variable cannot be rescanned\n*                                  (not treated as an error here)\n         B     ERROR441_RC08       08: Variable is a CLIST BIF\n         B     ERROR441_RC12       12: Variable is a CLIST label\n         B     ERROR441_RC16       16: Variable is unmodifiable\n         B     ERROR441_MISC       20: n/a\n         B     ERROR441_RC24       24: Variable is a CLIST subprocedure\n         B     ERROR441_MISC       28: n/a\n         B     ERROR441_RC32       32: GETMAIN/FREEMAIN failure\n         B     ERROR441_RC36       36: Variable length is invalid\n         B     ERROR441_RC40       40: Not in CLIST or REXX environment\n         B     ERROR441_MISC       44: invalid entry code\n         B     ERROR441_MISC       48: n/a\n         B     ERROR441_MISC       52: n/a\n         B     ERROR441_MISC       56: n/a\n         B     ERROR441_MISC       60: n/a\n         B     ERROR441_MISC       64: n/a\n         B     ERROR441_MISC       68: n/a\n         B     ERROR441_MISC       72: n/a\n         B     ERROR441_RC76       76: Variable is undefined &SYSX...\n         B     ERROR441_RC80       80: Variable name invalid for REXX\nERROR441_RC08 ERROR MSG_IKJCT441_RC08,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC12 ERROR MSG_IKJCT441_RC12,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC16 ERROR MSG_IKJCT441_RC16,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC24 ERROR MSG_IKJCT441_RC24,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC32 ERROR MSG_IKJCT441_RC32,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC36 ERROR MSG_IKJCT441_RC36,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC40 ERROR MSG_IKJCT441_RC40,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC76 ERROR MSG_IKJCT441_RC76,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC80 ERROR MSG_IKJCT441_RC80,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC81 ERROR MSG_IKJCT441_RC81,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_MISC DS 0H\n         CVD   R4,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         LA    R2,2                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_IKJCT441_RC,FLUSH=NO\n         L     R14,E44114\n         BR    R14\n         SPACE 1\nNOOPERANDS DS  0H                  No input variable\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_OPERANDS\n         SPACE 1\nNOPOSCOUNT DS  0H                  No count of positional parameters\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_POS_COUNT\n         SPACE 1\nBADPOSCOUNT DS 0H                  Bad count of positional parameters\n         LA    R2,1(,R4)           Get length of bad data\n         ERROR MSG_BAD_POS_COUNT\n         SPACE 1\nERROR_NO_WANT_LP DS 0H             Left parenthesis found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_LP\n         SPACE 1\nERROR_NO_WANT_RP DS 0H             Right parenthesis found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_RP\n         SPACE 1\nERROR_NO_WANT_QS DS 0H             Quoted string found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_QS\n         SPACE 1\nERROR_NO_WANT_SL DS 0H             Slash found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_SL\n         SPACE 1\nPPMISSING DS   0H                  Positional parm not found, expected\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_TOO_FEW_PPARMS\n         SPACE 1\nERROR_PARM_TOO_LONG DS 0H\n         LA    R2,252              Display only up to maximum length\n         LR    R3,R1               Address of offending parameter\n         ERROR MSG_PARM_TOO_LONG\n         SPACE 1\nERROR_PARM_INVALID DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_PARM_INVALID\n         SPACE 1\nERROR_PARM_DUPLICATE DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_PARM_DUPLICATE\n         SPACE 1\nERROR_OPT_TOO_LONG DS 0H\n         LA    R2,L'OPTION         Display only up to maximum length\n         LR    R3,R1               Address of offending parameter\n         ERROR MSG_OPT_TOO_LONG\n         SPACE 1\nERROR_OPT_INVALID DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_OPT_INVALID\n         SPACE 1\nERROR_OPT_POS_ONLY DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_OPT_POS_ONLY\n         SPACE 1\nERROR_ASIS_NEEDS_VAL DS 0H\n         L     R3,KEYWORDA-KEYDDATA(,R2)\n         L     R2,KEYWORDL-KEYDDATA(,R2)\n         ERROR MSG_ASIS_NEEDS_VAL\n         SPACE 1\nERROR_PP_WITH_LP DS 0H             Positional parm with left paren\n         ERROR MSG_PP_WITH_LP\n         SPACE 1\nERROR_FIRST_ARG DS 0H              Bad first argument\n         LR    R2,R4               Length of offending parameter\n         ERROR MSG_VAR_TOO_LONG\n         SPACE 1\nERROR_IRXEXCOM DS 0H               IRXEXCOM failed\n         C     R15,=F'-2'          Insufficient storage?\n         BE    GETMAIN_FAILURE\n         C     R15,=F'-1'          No valid REXX environment?\n         BE    ERROR_REXX_REQUIRED\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(3),DOUBLE(8)\n         OI    DOUBLE+2,X'F0'\n         LA    R2,3                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_IRXEXCOM_FAIL\n         SPACE 1\nERROR_REXX_REQUIRED DS 0H\n         XR    R2,R2\n         XR    R3,R3\n         ERROR MSG_REXX_REQUIRED\nERROR_PARSE_FAILURE DS 0H          IKJPARS failed\n         CH    R15,=H'4'\n         BE    FLUSHIT\n         CH    R15,=H'20'\n         BE    FLUSHIT\n         CH    R15,=H'32'\n         BE    FLUSHIT\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         LA    R2,2                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_PARSE_FAILURE\n         SPACE 1\nGETMAIN_FAILURE DS 0H              Insufficient storage\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_GETMAIN_FAIL\n         SPACE 1\nKVERROR  DS    0H                  This should never happen\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_KV_ERROR\n         SPACE 1\nFLUSHIT  DS    0H                  Return in failure\n         SPACE 1\n         TCLEARQ INPUT             Flush terminal input\n         MVC   FLUSH(LENFLUSH),MFLUSH Set up STACK list form\n         XC    ECB,ECB             Clear ECB and flush the input stack\n         STACK PARM=FLUSH,MF=(E,IOPL)\n         LTR   R15,R15             If STACK failed,\n         BZ    RETURN12            then...\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         LA    R2,2                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_STACK_ERROR,FLUSH=NO\nRETURN12 DS    0H\n         LA    R2,12               Set return code to 12\n         B     RETURN\n         SPACE 1\nRETURN0  DS    0H                  Return with code 0\n         XR    R2,R2               Set return code to zero\n******** B     RETURN\n         SPACE 1\nRETURN   DS    0H                  R2 contains return code\n         SPACE 1\n         ICM   R1,15,PWADDR        If there was a parse work area\n         BZ    NOFREEPW            then free it\n         L     R0,PWLEN\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEPW DS    0H\n         SPACE 1\n         ICM   R1,15,VBUFADDR      If there was a fake command buffer\n         BZ    NOFREEVBUF          then free it\n         L     R0,VBUFLEN\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEVBUF DS  0H\n         SPACE 1\n         ICM   R1,15,ARGADDR       If there was an arg buffer\n         BZ    NOFREEARG           then free it\n         L     R0,ARGLEN           Get length\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEARG DS   0H\n         SPACE 1\n         ICM   R1,15,AKEYD         If there was a keyword/value area\n         BZ    NOFREEKEYD          then free it\n         L     R0,LKEYD\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEKEYD DS  0H\n         SPACE 1\n         ICM   R1,15,APOSD         If there was a pos parm area,\n         BZ    NOFREEPOSD          then free it\n         L     R0,LPOSD\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEPOSD DS  0H\n         SPACE 1\n         IKJRLSA ANSWER            Free IKJPARS storage if any\n         SPACE 1\n         L     R0,DATDLEN          Get length of work area\n         LR    R1,R13              Get address of work area\n         L     R13,4(,R13)         Unchain save area\n         ST    R2,16(,R13)         Store return code in save area\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* Subroutines                                                         *\n***********************************************************************\n         EJECT\nDOOPTS   DS    0H                  Process options following \"/\"\n         SPACE 1\n         ST    R14,DOOPT14         Save return address\n         TM    FLAGS,FLAGPOSD+FLAGKEYD Must be processing either a\n         BZ    ERROR_NO_WANT_SL    positional or a keyword\n*\n* Process the option following the slash.\n*\n         BAL   R14,SCAN            Scan for option name\n         B     DOOPTRET            None, skip\n         B     OPTNAME             Unquoted name, process\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     ERROR_NO_WANT_LP    \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     ERROR_NO_WANT_SL    \"/\" found\n         SPACE 1\nOPTNAME  DS    0H                  Option name found\n*\n* Validate option name and process it.\n*\n         CH    R2,=Y(L'OPTION)     If too long\n         BH    ERROR_OPT_TOO_LONG  then error\n         MVI   OPTION,C' '         Clear option field to blanks\n         MVC   OPTION+1(L'OPTION-1),OPTION\n         LR    R14,R1              Address\n         LR    R15,R2              Length\n         BCTR  R15,0               Reduce length for execute\n         LA    R1,OPTION           Point to place to move option name\n         EX    R15,MVCWORD         Move option name to option area\n         EX    R15,UPWORD          Translate to uppercase\n*\n* Time to process the options\n*\n         TM    FLAGS,FLAGPOSD      If currently processing positional\n         BO    DOOPTP              then check positional options\n         B     DOOPTK              else check keyword options\n         SPACE 1\nDOOPTP   DS    0H\n         L     R1,LASTAREA         Point to current PP area\n******** CLC   =C'OPTIONAL ',OPTION\n******** BE    DOOPTP_OPTIONAL\n         CLC   =C'ASIS ',OPTION\n         BE    DOOPTP_ASIS\n         CLC   =C'QUOTABLE ',OPTION\n         BE    DOOPTP_CHAR\n         B     ERROR_OPT_INVALID   All other options are bad, error\n         SPACE 1\nDOOPTP_OPTIONAL DS 0H\n         OI    POSDFLGS-POSDDATA(R1),POSDOPT\n         B     DOOPTRET\n         SPACE 1\nDOOPTP_ASIS     DS 0H\n         OI    POSDFLGS-POSDDATA(R1),POSDASIS\n         B     DOOPTRET\n         SPACE 1\nDOOPTP_CHAR     DS 0H\n         OI    POSDFLGS-POSDDATA(R1),POSDCHAR\n         B     DOOPTRET\n         SPACE 1\nDOOPTK   DS    0H\n         L     R1,LASTAREA         Point to current KV area\n         CLC   =C'ASIS ',OPTION\n         BE    DOOPTK_ASIS\n         CLC   =C'QUOTABLE ',OPTION\n         BE    ERROR_OPT_POS_ONLY\n         B     ERROR_OPT_INVALID   All other options are bad, error\n         SPACE 1\nDOOPTK_ASIS    DS 0H\n         OI    KEYFLAGS-KEYDDATA(R1),KEYFASIS\n         B     DOOPTRET\n         SPACE 1\nDOOPTRET DS    0H\n         L     R14,DOOPT14\n         BR    R14\n         EJECT\nSCAN     DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine scans the command buffer for operands.  It returns the *\n* address of the next operand in R1 and its length in R2 (when there  *\n* are no more operands, R1 and R2 are zeroed).  The operand may be a  *\n* name, a number, a parenthesis, or a quoted string. If it's a quoted *\n* string, it will be returned as is, quotes and all.                  *\n*                                                                     *\n* Return is as follows:                                               *\n*                                                                     *\n* To return address + 0  ... no value found                           *\n* To return address + 4  ... unquoted string found                    *\n* To return address + 8  ... quoted string found                      *\n* To return address + 12 ... left parenthesis found                   *\n* To return address + 16 ... right parenthesis found                  *\n*                                                                     *\n* SCANPTR -> area to scan; SCANEPTR -> end thereof                    *\n*                                                                     *\n***********************************************************************\n*\n         L     R1,SCANPTR          Point to data to scan\n         XR    R2,R2               Clear TRT register\n         L     R3,SCANEPTR         Point to end of data to scan\n         SR    R3,R1               Get length of data to scan\n         LA    R0,256              Set up constant 256\n         LTR   R3,R3               If length is zero\n         BZ    SCANEND             then finished, return no value\nSCANLOOP DS    0H                  Do TRT for remaining length\n         CR    R3,R0               If length greater than 256\n         BNH   SCANLEFF            then...\n         TRT   0(256,R1),STBL0      scan for important characters\n         BNZ   SCANGOT1             If we found something, process it\n         AR    R1,R0                Else increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    SCANLOOP             Either continue scanning\n         B     SCANEND              or exit (no value), length now zero\nSCANLEFF DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,SCANTRT           Scan for important characters\n         BNZ   SCANGOT1             If we found something, process it\n******** B     SCANEND              If none found, exit in failure\nSCANEND  DS    0H                  Reached end of data\n         XR    R1,R1               Clear scanning registers\n         XR    R2,R2\n         BR    R14                 Return with no value\nSCANGOT1 DS    0H                  R1 -> something we found\n         L     R3,SCANEPTR\n         SR    R3,R1               R3 := length remaining to scan\n         B     *(R2)               R2 tells what kind it is\n         B     GOTWORD             4:  Found nonblank\n         B     GOTLP               8:  Found (\n         B     GOTRP               12: Found )\n         B     GOTSLASH            16: Found /\n         B     GOTQUOTE            20: Found '\n         SPACE 1\nGOTWORD  DS    0H                  Found a nonblank (word)\n*                                  R1 -> it, R3 = length to scan\n*\n* Scan for end-of-word\n*\n         LR    R15,R1              Save address of the word\nGOTWORDL CR    R3,R0               If length greater than 256\n         BNH   GOTWORDX            then...\n         TRT   0(256,R1),STBLWORD   scan for important characters\n         BNZ   GOTWORDT             If we found it, go. Else\n         AR    R1,R0                Increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    GOTWORDL             Either continue scanning\n         B     GOTWORDE             or go if length zero\nGOTWORDX DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,GOTWTRT           Scan for important characters\n         BNZ   GOTWORDT             If found something, go\n         L     R1,SCANEPTR          Else end of text = end of word\n         B     GOTWORDE\nGOTWORDT L     R3,SCANEPTR         R3 := length remaining to scan\n         SR    R3,R1               R1 -> character\n         B     *(R2)               Branch depending on R2\n         B     GOTWORDE            4:  Found whitespace, end of word\n         B     GOTWLP              8:  Found (\n         B     GOTWRP              12: Found )\n         B     GOTWS               16: Found /\n         SPACE 1\nGOTWORDE DS    0H                  Found whitespace or end of word\n         LR    R2,R1               Set length of word found\n         SR    R2,R15\n         ST    R1,SCANPTR          Set scan pointer for next scan\n         LR    R1,R15              Set pointer to found item\n         B     4(,R14)             Return to caller with unquoted word\nGOTWLP   DS    0H                  Found \"(\" in word\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BZ    GOTWORDE            If was zero, not nested, end of word\n         LA    R2,1(,R2)           Increment it\n         ST    R2,PARCOUNT\n         B     GOTWNEXT            Else process as constituent char\nGOTWRP   DS    0H                  Found a right parenthesis \")\"\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BZ    GOTWORDE            If was zero, not nested, end of word\n         BCTR  R2,0                Decrement count\n         ST    R2,PARCOUNT\n         LTR   R2,R2\n         BZ    GOTWORDE            If now zero, not nested, end of word\n         B     GOTWNEXT            Else process as constituent char\nGOTWS    DS    0H                  Found a slash \"/\"\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BNZ   GOTWNEXT            If inside (), treat as constituent\n         B     GOTWORDE            Else treat as end of word\n         SPACE 1\nGOTWNEXT LA    R1,1(,R1)           Bump text pointer\n         BCT   R3,GOTWORDL         Decrement count, scan if nonzero\n         B     GOTWORDE            end of word\n         SPACE 1\nGOTLP    DS    0H                  Found a left parenthesis \"(\"\n*                                  R1 -> it, R3 = length to scan\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BNZ   GOTWORD             If count was nonzero, start of word\n         LA    R2,1(,R2)           Increment it\n         ST    R2,PARCOUNT\n         LA    R2,1                Else set length to 1\n         LA    R15,1(,R1)          Set pointer past it\n         ST    R15,SCANPTR         Update scan pointer\n         B     12(,R14)            Return single left parenthesis\n         SPACE 1\nGOTRP    DS    0H                  Found a right parenthesis \")\"\n*                                  R1 -> it, R3 = length to scan\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BZ    SCANRETP            If was zero, not nested, return \")\"\n         BCTR  R2,0                Decrement count\n         ST    R2,PARCOUNT\n         LTR   R2,R2\n         BNZ   GOTWORD             If now nonzero, part of word\nSCANRETP DS    0H                  Return the parenthesis\n         LA    R2,1                Set length to 1\n         LA    R15,1(,R1)          Set pointer past it\n         ST    R15,SCANPTR         Update scan pointer\n         B     16(,R14)            Return single right parenthesis\n         SPACE 1\nGOTQUOTE DS    0H                  Found a single quote \"'\"\n*                                  R1 -> it, R3 = length to scan\n         LR    R15,R1              Save address of the quoted string\n         LA    R1,1(,R1)           Bump past initial quote\n         BCT   R3,GOTQL            Decrement length to scan\n         B     ERRQUOTE            If nothing left, error\nGOTQL    CR    R3,R0               If length greater than 256\n         BNH   GOTQX               then...\n         TRT   0(256,R1),STBLQUOT   scan for \"'\"\n         BNZ   GOTQT                If we found it, go. Else\n         AR    R1,R0                Increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    GOTQL                Either continue scanning\n         B     ERRQUOTE             or, if length zero, error\nGOTQX    DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,GOTQTRT           Scan for \"'\"\n         BNZ   GOTQT                If found something, go\n         B     ERRQUOTE             Else error\nGOTQT    DS    0H                  Reached \"'\"\n         L     R3,SCANEPTR\n         SR    R3,R1               R3 := length remaining to scan\n         BNP   GOTQE               If zero, it's the ending quote\n         CLI   1(R1),C''''         If not \"''\"\n         BNE   GOTQE               then it's the ending quote\n         LA    R1,2(,R1)           Else bump past \"''\"\n         SH    R3,=H'2'            Decrement scan length\n         BP    GOTQL               If something left, continue scan\n         B     ERRQUOTE            Else error\nGOTQE    DS    0H                  End of quoted string\n         LA    R1,1(,R1)           Bump past final quote mark\n         LR    R2,R1               Set length of string including \"'\"s\n         SR    R2,R15\n         ST    R1,SCANPTR          Set scan pointer for next scan\n         LR    R1,R15              Set pointer to found item\n         B     8(,R14)             Return quoted string to caller\n         SPACE 1\nGOTSLASH DS    0H                  Found a slash \"/\"\n*                                  R1 -> it, R3 = length to scan\n         CH    R3,=H'2'            If not enough room for \"/*\"\n         BL    GOTSL               then treat as real slash\n         CLI   1(R1),C'*'          If not \"/*\"\n         BNE   GOTSL               then treat as real slash\n         LA    R1,2(,R1)           Else start of comment: bump text ptr\n         SH    R3,=H'2'            Decrement length to scan\n         BNP   SCANEND             If nothing left, end of text\nGOTCOMML CR    R3,R0               If length greater than 256\n         BNH   GOTCOMMX            then...\n         TRT   0(256,R1),STBLCOMM   scan for \"*\"\n         BNZ   GOTCOMME             If we found it, go. Else\n         AR    R1,R0                Increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    GOTCOMML             Either continue scanning\n         B     SCANEND              or, if length zero, end of text\nGOTCOMMX DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,GOTCTRT           Scan for \"*\"\n         BNZ   GOTCOMME             If found something, go\n         B     SCANEND              Else end of text\nGOTCOMME DS    0H                   Reached an \"*\"\n         L     R3,SCANEPTR\n         SR    R3,R1               R3 := length remaining to scan\n         CH    R3,=H'2'            If not enough room for \"*/\"\n         BL    GOTCOMMC            then continue scanning for it\n         CLI   1(R1),C'/'          If not \"*/\"\n         BNE   GOTCOMMC            then continue scanning for it\n         LA    R1,2(,R1)           Else bump past \"*/\"\n         SH    R3,=H'2'            Decrement scan length\n         BP    SCANLOOP            If something left, continue scan\n         B     SCANEND             Else end of text\nGOTCOMMC DS    0H                  \"*\" but no \"/\"\n         LA    R1,1(,R1)           Bump past \"*\"\n         BCT   R3,GOTCOMML         Decrement length, continue if nzero\n         B     SCANEND             Else end of text\nGOTSL    DS    0H                  Found a slash \"/\" without a \"*\"\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BNZ   GOTWORD             If inside (), treat as constituent\nRETSLASH DS    0H                  Else treat as single slash \"/\"\n         LA    R2,1                Set length to 1\n         LA    R15,1(,R1)          Set pointer past it\n         ST    R15,SCANPTR         Update scan pointer\n         B     20(,R14)            Return single slash\n         SPACE 1\nERRQUOTE DS    0H                  Mismatched quotes\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_QUOTE_ERROR\n         SPACE 1\nSCANTRT  TRT   0(*-*,R1),STBL0      (Executed instruction)\nGOTWTRT  TRT   0(*-*,R1),STBLWORD   (Executed instruction)\nGOTCTRT  TRT   0(*-*,R1),STBLCOMM   (Executed instruction)\nGOTQTRT  TRT   0(*-*,R1),STBLQUOT   (Executed instruction)\n         SPACE 1\nSTBL0    DC    256YL1(4)           Table to scan for good stuff\n         ORG   STBL0+C' '          Blank\n         DC    YL1(0)              is whitespace\n         ORG   STBL0+C','          Comma\n         DC    YL1(0)              is whitespace\n         ORG   STBL0+X'05'         Tab\n         DC    YL1(0)              is whitespace\n         ORG   STBL0+C'('          Left parenthesis\n         DC    YL1(8)              is special\n         ORG   STBL0+C')'          Right parenthesis\n         DC    YL1(12)             is special\n         ORG   STBL0+C'/'          Slash\n         DC    YL1(16)             might be part of /*\n         ORG   STBL0+C''''         Quote\n         DC    YL1(20)             is special\n         ORG   ,\n         SPACE 1\nSTBLWORD DC    256YL1(0)           Table to scan for end of word\n         ORG   STBLWORD+C' '       Blank\n         DC    YL1(4)              is whitespace\n         ORG   STBLWORD+C','       Comma\n         DC    YL1(4)              is whitespace\n         ORG   STBLWORD+X'05'      Tab\n         DC    YL1(4)              is whitespace\n         ORG   STBLWORD+C'('       Left parenthesis\n         DC    YL1(8)              is special\n         ORG   STBLWORD+C')'       Right parenthesis\n         DC    YL1(12)             is special\n         ORG   STBLWORD+C'/'       Slash\n         DC    YL1(16)             might be part of /*\n         ORG   ,\n         SPACE 1\nSTBLCOMM DC    256YL1(0)           Table to scan for \"*/\"\n         ORG   STBLCOMM+C'*'\n         DC    1YL1(1)\n         ORG   ,\n         SPACE 1\nSTBLQUOT DC    256YL1(0)           Table to scan for \"'\"\n         ORG   STBLQUOT+C''''\n         DC    1YL1(1)\n         ORG   ,\nVERTBL   DC    256YL1(1)           Table to verify parameter syntax\n         ORG   VERTBL+C'_'         Underscore is valid (?)\n         DC    YL1(0)               valid?\n         ORG   VERTBL+C'@'         National character is valid (?)\n         DC    YL1(0)\n         ORG   VERTBL+C'#'         National character is valid (?)\n         DC    YL1(0)\n         ORG   VERTBL+C'$'         National character is valid (?)\n         DC    YL1(0)\n         ORG   VERTBL+C'a'         Lower case alphabetics are valid\n         DC    9YL1(0)\n         ORG   VERTBL+C'j'\n         DC    9YL1(0)\n         ORG   VERTBL+C's'\n         DC    8YL1(0)\n         ORG   VERTBL+C'A'         Upper case alphabetics are valid\n         DC    9YL1(0)\n         ORG   VERTBL+C'J'\n         DC    9YL1(0)\n         ORG   VERTBL+C'S'\n         DC    8YL1(0)\n         ORG   VERTBL+C'0'         Numerics are valid (except 1st pos)\n         DC    10YL1(0)\n         ORG   ,\nUPTBL    DC    256YL1(*-UPTBL)     Table to translate to uppercase\n         ORG   UPTBL+C'a'\n         DC    C'ABCDEFGHI'\n         ORG   UPTBL+C'j'\n         DC    C'JKLMNOPQR'\n         ORG   UPTBL+C's'\n         DC    C'STUVWXYZ'\n         ORG   ,\n         EJECT\nPUTLINE  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine displays messages to the TSO user using the TSO        *\n* PUTLINE service routine.  At entry R1 contains the address of the   *\n* message to be displayed, and R0 contains the length of the message. *\n* R3 points to additional data to be displayed, and R2 is its length. *\n* If R1 is zero, the message has already been built in the workarea   *\n* MSGWA.  The message is assumed to begin with a message ID unless    *\n* the first character is blank, in which case the initial blank is    *\n* stripped off by PUTLINE anyhow.                                     *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,PUTL14          Save return register\n         LTR   R15,R0              Load length value\n         BNP   PUTLRET             If zero, don't do anything\n         BCTR  R15,0               Else reduce length for execute\n         LTR   R1,R1               If R1 is zero,\n         BZ    PUTIT               then message already set up.\n         EX    R15,MVCPUT          Else move message to work area\n         LTR   R2,R2               If additional data,\n         BZ    PUTIT               then\n         LA    R1,MSGWA+1(R15)      Point to end of message\n         CH    R2,=H'256'           (Use max length of 256)\n         BNH   *+8\n         LA    R2,256\n         BCTR  R2,0                 Reduce data length for execute\n         EX    R2,MVCPUT2           Move additional data to work area\n         LA    R15,1(R15,R2)        Add length of data to msg length\nPUTIT    DS    0H\n         LA    R15,5(,R15)         Restore length + 4 for header\n         SLL   R15,16              Shift length into left half of hdr\n         STCM  R15,15,MSGHDR       Put zeroes into right half of hdr\nPUTLINE_RETRY DS 0H\n         XC    ECB,ECB             Clear ECB\n         PUTLINE PARM=PTLIST,                                          X\n               MF=(E,IOPL),                                            X\n               OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15             If PUTLINE OK\n         BZ    PUTLRET             then return\n         CH    R15,=H'8'           Else if attention interrupt\n         BE    PUTLRET             then OK\n         CH    R15,=H'12'          Else if pending 2nd level message\n         BE    PUTL12              then OK\nPUTERROR DS    0H                  Else PUTLINE error\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         MVC   MSGWA+1(L'MSG_PUTLINE_FAILURE1),MSG_PUTLINE_FAILURE1\n         MVC   MSGWA+1+L'MSG_PUTLINE_FAILURE1(2),DOUBLE\n         MVC   MSGWA+1+L'MSG_PUTLINE_FAILURE1+2(L'MSG_PUTLINE_FAILURE2)X\n               ,MSG_PUTLINE_FAILURE2\n         TPUT  MSGWA+1,L'MSG_PUTLINE_FAILURE1+2+L'MSG_PUTLINE_FAILURE2\n         LA    R1,MSGWA\n         LH    R0,MSGHDR\n         SH    R0,=H'4'\n         TPUT  (1),(0),R           Try to display original message\nPUTLRET  L     R14,PUTL14          Restore return register\n         BR    R14                 Return\n*\nPUTL12   DS    0H                  Try putting out pending 2nd level ms\n         XC    ECB,ECB             Clear ecb\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(0,TERM,SINGLE,INFOR)\n         B     PUTLINE_RETRY\n*\nMVCPUT   MVC   MSGWA(*-*),0(R1)    Executed\nMVCPUT2  MVC   0(*-*,R1),0(R3)     Executed\n         EJECT\nMFLUSH   STACK MF=L,DELETE=ALL\nLENFLUSH EQU   *-MFLUSH\n*\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nLENPUTL  EQU   *-MPTLIST\n*\n         EJECT\n         LTORG\n         EJECT\n***********************************************************************\n* Messages                                                            *\n***********************************************************************\n         SPACE 1\nMSG_NO_OPERANDS    DC C'XPROC001 No operands specified.'\nMSG_REXX_REQUIRED  DC C'XPROC002 Not in REXX: input variable required.'\nMSG_NO_POS_COUNT   DC C'XPROC003 Missing positional parameter count.'\nMSG_BAD_POS_COUNT  DC C'XPROC004 Invalid positional parameter count: '\nMSG_QUOTE_ERROR    DC C'XPROC005 Missing end quote.'\nMSG_NO_WANT_LP     DC C'XPROC006 \"(\" found where not expected.'\nMSG_NO_WANT_RP     DC C'XPROC007 \")\" found where not expected.'\nMSG_NO_WANT_QS     DC C'XPROC008 Quoted string in invalid position.'\nMSG_TOO_FEW_PPARMS DC C'XPROC009 Fewer positional parms than expected.'\nMSG_PP_WITH_LP     DC C'XPROC010 Value not allowed on positional: '\nMSG_PARM_TOO_LONG  DC C'XPROC011 Parameter name too long (> 255): '\nMSG_PARM_INVALID   DC C'XPROC012 Invalid syntax in parameter name: '\nMSG_PARM_DUPLICATE DC C'XPROC013 Duplicate parameter name: '\nMSG_EXTRANEOUS     DC C'XPROC014 Extraneous data ignored in value: '\nMSG_VAR_TOO_LONG   DC C'XPROC015 Variable name too long (> 256): '\nMSG_GETTING_VAR    DC C'XPROC016 Error accessing value of variable: '\nMSG_PUTTING_VAR    DC C'XPROC017 Error storing value of variable: '\nMSG_IKJCT441_RC    DC C'XPROC018 IKJCT441 return code is: '\nMSG_PARSE_FAILURE  DC C'XPROC019 PARSE service routine failure, code: '\nMSG_GETMAIN_FAIL   DC C'XPROC020 Not enough main storage to execute.'\nMSG_IRXEXCOM_FAIL  DC C'XPROC021 IRXEXCOM failure, error code: '\nMSG_STACK_ERROR    DC C'XPROC022 STACK service routine failure, code: '\nMSG_NO_WANT_SL     DC C'XPROC023 \"/\" found where not expected.'\nMSG_OPT_TOO_LONG   DC C'XPROC024 Option name too long: '\nMSG_OPT_INVALID    DC C'XPROC025 Invalid option name: '\nMSG_ASIS_NEEDS_VAL DC C'XPROC026 ASIS invalid with valueless keyword: '\nMSG_OPT_POS_ONLY   DC C'XPROC027 Option valid only for positional: '\n*\nMSG_KV_ERROR       DC C'XPROC999 Internal error in keyword value scan.'\n*\nMSG_PUTLINE_FAILURE1 DC C'*** XPROC: PUTLINE error code '\nMSG_PUTLINE_FAILURE2 DC C' trying to issue the following message:'\n*\nISMSG    DC    C'*** XPROC ignoring slash after this parameter: ' dummy\n         SPACE 1\n         EJECT\n***********************************************************************\n* Constants                                                           *\n***********************************************************************\n         SPACE 1\nKEYDINCR DC    A(100*KEYDDATL)     Initial & increment key area length\n         SPACE 1\nNUMTBL   DC    256YL1(1)           Table to validate numerics\n         ORG   NUMTBL+C'0'\n         DC    10YL1(0)\n         ORG   ,\n         EJECT\nMSG_IKJCT441_RC08 DC C'XPROC508 Variable is a CLIST built-in function.'\nMSG_IKJCT441_RC12 DC C'XPROC512 Variable is a CLIST label.'\nMSG_IKJCT441_RC16 DC C'XPROC516 CLIST variable cannot be updated.'\nMSG_IKJCT441_RC24 DC C'XPROC524 Variable is a CLIST subprocedure.'\nMSG_IKJCT441_RC32 DC C'XPROC532 GETMAIN or FREEMAIN storage failure.'\nMSG_IKJCT441_RC36 DC C'XPROC536 Variable name or value too long.'\nMSG_IKJCT441_RC40 DC C'XPROC540 No valid CLIST or REXX environment.'\nMSG_IKJCT441_RC76 DC C'XPROC576 Undefined &&SYSX CLIST variable.'\nMSG_IKJCT441_RC80 DC C'XPROC580 Variable name invalid for REXX.'\nMSG_IKJCT441_RC81 DC C'XPROC581 Internal REXX routine failure.'\n         EJECT\n***********************************************************************\n* Work area                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   Dynamically acquired work area\n         SPACE 1\nSAVEAREA DS    18F                 OS save area\nSAVE2    DS    18F                 Save area for PARSE exit routines\nDOUBLE   DS    D                   Conversion work area\nDATDLEN  DS    F                   Length of this work area\nPUTL14   DS    F                   Return register save\nE44114   DS    F                   Return register save\nDOOPT14  DS    F                   Return register save\nSAVER2   DS    A                   Save for TRT register\nMYBASES  DS    2A                  Base regs for IKJPARS exit routines\nSCANRES  DS    2A                  Used to save output from SCAN\nWORDPTR  DS    A                   Address of next slot for word copy\nPWADDR   DS    A                   Address of IKJPARS PCL area\nPWLEN    DS    F                   Length of IKJPARS PCL area\nPCLLEN   DS    F                   Actual length of the IKJPARS PCL\nQOFF     DS    A                   Address of quoted-value-string area\nQVALLEN  DS    F                   Length of quoted-value-string area\nVUPADDR  DS    F                   Address of IKJCT441 update parm list\nVUPLEN   DS    F                   Length of IKJCT441 update parm list\nPDLLEN   DS    F                   Length of the IKJPARS PDL\nVBUFADDR DS    A                   Address of fake command buffer\nVBUFLEN  DS    A                   Length of fake command buffer\nARGADDR  DS    A                   Address of ARG buffer\nARGLEN   DS    F                   Length of ARG buffer\nSCANPTR  DS    A                   Scanning pointer\nSCANEPTR DS    A                   Scanning end pointer\nPARCOUNT DS    F                   Parenthesis count\nPVARADDR DS    A                   Address of input variable name\nPVARLEN  DS    F                   Length of input variable name\nPOSCOUNT DS    F                   Positional parameter count\nKEYCOUNT DS    F                   Keyword count\nLASTAREA DS    A                   Address of last pos or key area\nLASTADDR DS    A                   Address of last processed thing\nLASTLEN  DS    F                   Length of last processed thing\nAPOSD    DS    A                   Address of positional parm area\nLPOSD    DS    A                   Length of positional parm area\nAKEYD    DS    A                   Address of keyword/value area\nLKEYD    DS    A                   Length of keyword/value area\nAKEYE    DS    A                   Address of end of keyword/value area\nFIRSTKEY DS    A                   Address of first IKJKEYWD PCE\nSUBTOSET DS    A                   Address of previous IKJSUBF PCE\nFLAGS    DS    X                   Flags\nFLAGPUTE EQU   B'10000000'         1 = error putting variable values\nFLAGPOSD EQU   B'01000000'         1 = currently processing positionals\nFLAGKEYD EQU   B'00100000'         1 = currently processing keywords\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n*\nECB      DS    F                   ECB for TSO routines\n*\nOLD      DS    0F                  PUTLINE output line descriptor\nOLDF1    DS    F'1'                Number of message segments\nOLDMSG   DS    A(*-*)              Address of the first message segment\n*\nMSGHDR   DS    F                   PUTLINE message header\nMSGWA    DS    CL512               PUTLINE message work area\nARGWA    DS    CL512               ARG message work area\n*\nFLUSH    STACK MF=L,DELETE=ALL\n*\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n*\nCPPL     DS    0A\n***********************************************************************\n*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *\n*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *\n***********************************************************************\n*\nCPPLCBUF DS    A        PTR TO COMMAND BUFFER\nCPPLUPT  DS    A        PTR TO UPT\nCPPLPSCB DS    A        PTR TO PSCB\nCPPLECT  DS    A        PTR TO ECT\n*\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n*\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n*\nPPL      DS    0A\n***********************************************************************\n*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *\n*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *\n***********************************************************************\n         SPACE\nPPLUPT   DS    A        PTR TO UPT\nPPLECT   DS    A        PTR TO ECT\nPPLECB   DS    A        PTR TO CP'S ECB\nPPLPCL   DS    A        PTR TO PCL\nPPLANS   DS    A        PTR TO ANS PLACE\nPPLCBUF  DS    A        PTR TO CMD BUFFER\nPPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)\nPPLVEWA  DS    A        PTR TO USER WORK AREA FOR VERIFY EXITS\n*\nANSWER   DS    F                   ANSWER AREA FOR PARSE\n         SPACE 1\nCVPARMS  DS    0F                  Variable access facility parm list\nCVPARM1  DS    A                   Parameter 1: entry code\nCVPARM2  DS    A                   Parameter 2: address of var name\nCVPARM3  DS    A                   Parameter 3: length of var name\nCVPARM4  DS    A                   Parameter 4: address of var value\nCVPARM5  DS    A                   Parameter 5: length of var value\nCVPARM6  DS    A                   Parameter 6: token (not used)\nCVPARM7  DS    A                   Parameter 7: ECT             #TSO172\n*\nCVENTRY  DS    A                   Entry code\nCVNAMEA  DS    A                   Address of variable name\nCVNAMEL  DS    A                   Length of variable name\nCVVALUEA DS    A                   Address of variable value\nCVVALUEL DS    A                   Length of variable value\nCVTOKEN  DS    A                   Token (not used)\n* CVECT  DS    A                   ECT (not used)               #TSO172\n*\nRC441    DS    F                   Return code from IKJCT441\n         SPACE 1\n         SPACE 1\nIRPARMS  DS    0F                  IRXEXCOM parameter list\nIRPARM1  DS    A                   Parameter 1: CL8'IRXEXCOM'\nIRPARM2  DS    A                   Parameter 2: same as parameter 3\nIRPARM3  DS    A                   Parameter 3: same as parameter 2\nIRPARM4  DS    A                   Parameter 4: SHVBLOCK\n*\n***********************************************************************\n*                                                                     *\n* Copied from 'SYS1.MACLIB(IRXSHVB)'.                                 *\n*                                                                     *\n***********************************************************************\n*\nSHVBLOCK DS    0D                     SHARED VARIABLE REQUEST BLOCK\nSHVNEXT  DS  A                        Chain pointer to next SHVBLOCK\nSHVUSER  DS  F                        Used during \"FETCH NEXT\"\n*                                      Contains length of buffer\n*                                      pointed to by SHVNAMA\nSHVCODES DS  0F\nSHVCODE  DS  CL1                      Function code - indicates type\n*                                      of variable access request\nSHVRET   DS  XL1                      Return codes\n         DS  H'0'                     Reserved (should be 0)\nSHVBUFL  DS  F                        Length of fetch value buffer\nSHVNAMA  DS  A                        Address of variable name\nSHVNAML  DS  F                        Length of variable name\nSHVVALA  DS  A                        Address of value buffer\nSHVVALL  DS  F                        Length of value buffer\n*                                      (Set on fetch)\nSHVBLEN  EQU *-SHVBLOCK               Length of SHVBLOCK\n         SPACE 1\n**********************************************************************/\n*   SHARED VARIABLE REQUEST BLOCK - function codes                   */\n**********************************************************************/\n         SPACE 1\nSHVFETCH EQU   C'F'            Copy value of shared variable\nSHVSTORE EQU   C'S'            Set variable from given value\nSHVDROPV EQU   C'D'            Drop variable\nSHVSYFET EQU   C'f'            Symbolic name retrieve\nSHVSYSET EQU   C's'            Symbolic name set\nSHVSYDRO EQU   C'd'            Symbolic name drop\nSHVNEXTV EQU   C'N'            Fetch \"next\" variable\nSHVPRIV  EQU   C'P'            Fetch private information\n         SPACE 1\n**********************************************************************/\n*        SHARED VARIABLE REQUEST BLOCK - return codes (SHVRET)       */\n**********************************************************************/\n        SPACE 1\nSHVCLEAN EQU   X'00'           Execution was OK\nSHVNEWV  EQU   X'01'           Variable did not exist\nSHVLVAR  EQU   X'02'           Last variable transferred (\"N\")\nSHVTRUNC EQU   X'04'           Truncation occurred for \"Fetch\"\nSHVBADN  EQU   X'08'           Invalid variable name\nSHVBADV  EQU   X'10'           Invalid value specified\nSHVBADF  EQU   X'80'           Invalid function code (SHVCODE)\n         SPACE 1\n**********************************************************************/\n*        R15 return codes                                            */\n**********************************************************************/\n         SPACE 1\nSHVRCOK  EQU    0              Entire Plist chain processed\nSHVRCINV EQU   -1              Invalid entry conditions\nSHVRCIST EQU   -2              Insufficient storage available\n         SPACE\n*\nPVAR     DS    CL256               Area to build input variable name\nOPTION   DS    CL16                Area to build option name\n         SPACE 1\nSIZDATD  EQU   *-DATD              Length of fixed part of work area\n         SPACE 1\nWORDCOPY EQU   *                   Area to put copies of keyword names\n         EJECT\nPOSDDATA DSECT ,                   Info on positional parameter specs\n         SPACE 1\n*                                  (POSCOUNT) occurrences of...\n*\nPOSDADDR DS    A                   Address of positional parameter name\nPOSDLEN  DS    A                   Length of positional parameter name\nPOSDPCEA DS    A                   Address of PCE for this parameter\nPOSDPCEL DS    A                   Length of PCE for this parameter\nPOSDMAXL DS    A                   Maximum length for prompting message\nPOSDFLGS DS    X                   Flags\nPOSDOPT  EQU   B'10000000'          1 = parameter is optional\nPOSDCHAR EQU   B'01000000'          1 = value is possibly-quoted string\nPOSDASIS EQU   B'00100000'          1 = value is to be processed asis\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n         DS    0D                  Round to doubleword length\n         SPACE 1\nPOSDDATL EQU   *-POSDDATA          Length of an occurrence\n         EJECT\nKEYDDATA DSECT ,                   Info on keyword/value specs\n         SPACE 1\n*                                  some # of occurrences of...\n*\nKEYWORDA DS    A                   Address of keyword\nKEYWORDL DS    A                   Length of keyword\nKEYDVALA DS    A                   Address of keyword's default value\nKEYDVALL DS    A                   Length of keyword's default value\nKEYDPCEA DS    A                   Address of PCE for this parameter\nKEYDPCEL DS    A                   Length of PCE for this parameter\nKEYDMAXL DS    A                   Maximum length for prompting message\nKEYSUBOF DS    A                   Where to store subfield offset\nKEYFLAGS DS    X                   Flags\nKEYFDVAL EQU   B'10000000'          1 = a default value was specified\nKEYFQUOT EQU   B'01000000'          1 = default value is quoted string\nKEYFASIS EQU   B'00100000'          1 = value is to be processed asis\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n         DS    0D                  Round to doubleword length\n         SPACE 1\nKEYDDATL EQU   *-KEYDDATA          Length of an occurrence\n         EJECT\n***********************************************************************\n* Macro expansions                                                    *\n***********************************************************************\n         SPACE 1\n         IKJTSVT\n         SPACE 1                                                #TSO162\n         IKJECT ,                                               #TSO162\n         SPACE 1\n         CVT   DSECT=YES\n         END\n./ ADD NAME=XWRITENR\n         TITLE 'XWRITENR copyright notice'\n***********************************************************************\n*                                                                     *\n*   Copyright (c) 1989 The Charles Stark Draper Laboratory, Inc.      *\n*                                                                     *\n*   This program is provided on an \"as is\" basis.  It may be freely   *\n*   distributed as long as it is not offered for commercial sale,     *\n*   and as long as this copyright notice is included.                 *\n*                                                                     *\n***********************************************************************\n         TITLE 'XWRITENR - REXX external function to simulate WRITENR'\nXWRITENR CSECT\nXWRITENR AMODE ANY\nXWRITENR RMODE ANY\n         SPACE\n***********************************************************************\n*\n* Syntax:  call XWRITENR \"anything at all\"\n*\n***********************************************************************\n*                                                                *\n* Input:       (R1) = address of IRXEFPL parameter list:         *\n*                                                                *\n*              Offset:                                           *\n*               00 = Reserved                                    *\n*               04 = Reserved                                    *\n*               08 = Reserved                                    *\n*               0C = Reserved                                    *\n*               10 = Address of the parsed argument list         *\n*               14 = Address of the address of the EVALBLOCK     *\n*                                                                *\n******************************************************************\n*                                                                *\n* Output:      R15 = return code from PUTLINE                    *\n*                                                                *\n******************************************************************\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SAVE  (14,12),,XWRITENR_&SYSDATE._&SYSTIME\n         BALR  R12,0\n         USING *,R12\n         SPACE\n         L     R2,16(,R1)          R2 = address of parsed argument list\n         L     R6,20(,R1)          R6 = address of address of EVALBLOCK\n         L     R6,0(,R6)           R6 = address of EVALBLOCK\n         L     R4,4(,R2)           R4 = length of message\n         L     R5,0(,R2)           R5 = address of text of message\n         C     R5,=X'FFFFFFFF'     If number of arguments not 1\n         BE    ERROR               then error\n         L     R0,8(,R2)\n         C     R0,=X'FFFFFFFF'     If number of arguments not 1\n         BNE   ERROR               then error\n         LTR   R15,R4              If message length is zero\n         BZ    RETURN              then return code(zero)\n         LA    R0,DYSIZE           Get size of dynamic area w/o message\n         AR    R0,R4               Add length of message\n         GETMAIN R,LV=(0)          Get dynamic storage area\n         SPACE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DYNAM,R13\n         SPACE\nLENOK    DS    0H\n         CH    R4,=H'256'          If message is 256 chars or less\n         BH    MOVELONG            then...\n         LR    R14,R4\n         BCTR  R14,0                decrement length for move\n         EX    R14,MOVEMSG          Move message to buffer\n         B     MSGMOVED            else...\nMOVELONG DS    0H\n         LA    R0,PUTBUF+4         Address of message destination\n         LR    R1,R4               Length of message destination\n         LR    R14,R5              Address of message source\n         LR    R15,R4              Length of message source\n         MVCL  R0,R14              Move message to buffer\nMSGMOVED DS    0H\n         LA    R14,4(,R4)         Add length of header\n         SLL   R14,16             Shift: 1st HWD = hdr, 2nd = no 2ndary\n         ST    R14,PUTBUF         Put in first 2 halfwords in header\n         SPACE\n         LA    R1,IOPLSP           Set up IOPL\n         USING IOPL,R1\n         SPACE\n         USING PSA,0\n         L     R8,PSATOLD           GET TCB ADDRESS\n         USING TCB,R8\n         L     R8,TCBJSCB           GET JSCB ADDRESS\n         USING IEZJSCB,R8\n         L     R8,JSCBACT           GET ADDRESS OF ACTIVE JSCB\n         L     R8,JSCBPSCB          GET ADDRESS OF PSCB\n         USING PSCB,R8\n         MVC   IOPLUPT,PSCBUPT      PUT UPT ADDRESS IN IOPL\n         L     R8,PSCBRLGB          GET ADDR OF RELOGON BUFFER\n         USING RLGB,R8\n         MVC   IOPLECT,RLGBECT      PUT ADDRESS OF ECT IN IOPL\n         SPACE\n         SR    R0,R0\n         ST    R0,ECB              Zero out ECB\n         ST    R0,IOPLIOPB         Zero out IOPL parm block address\n         LA    R0,ECB\n         ST    R0,IOPLECB          Finish up IOPL\n         MVC   PUTBLK(LPUTBLK),PUTMAST     Build PUTLINE MF=L\n         DROP  R1\n         EJECT\n         PUTLINE PARM=PUTBLK,OUTPUT=(PUTBUF,TERM,SINGLE,DATA),         +\n               TERMPUT=(ASIS),                                         +\n               MF=(E,(1))\n         EJECT\nENDIT    LR    R3,R15              Save return code\n         LA    R0,2\n         ST    R0,8(,R6)           Set EVLEN (in EVALBLOCK) to length\n         CVD   R3,DOUBLE           Return code\n         UNPK  16(2,R6),DOUBLE     Generate 2 digits\n         OI    17(R6),X'F0'\n         CLI   16(R6),C'0'         If first digit is 0\n         BNE   NOTZ                then\n         MVC   16(1,R6),17(R6)      make it a 1-digit number\n         MVI   17(R6),C' '\n         LA    R0,1                 set length to 1\n         ST    R0,8(,R6)            set EVLEN (in EVALBLOCK) to length\nNOTZ     DS    0H\n         LA    R0,DYSIZE           Get length of storage w/o message\n         AR    R0,R4               Add length of message\n         LA    R1,DYNAM            Get address of storage\n         L     R13,4(0,R13)\n         FREEMAIN R,LV=(0),A=(1)\nRETURN   DS    0H\n         RETURN (14,12),T,RC=0\n         SPACE 2\nERROR    DS    0H                  Here if wrong # of arguments\n         LA    R0,2\n         ST    R0,8(,R6)           Set EVLEN (in EVALBLOCK) to length\n         MVC   16(2,R6),=C'-2'     Return value\n         B     RETURN\n         SPACE 2\nMOVEMSG  MVC   PUTBUF+4(0),0(R5)\n         EJECT\nPUTMAST  PUTLINE MF=L\n         EJECT\nDYNAM    DSECT\n         SPACE\nSAVEAREA DS    9D\nDOUBLE   DS    D          Work area for conversions\n         SPACE\nPUTBLK   PUTLINE MF=L\nLPUTBLK  EQU   *-PUTBLK\n         SPACE\nIOPLSP   DS    4F        INPUT OUTPUT PARAMETER BLOCK\nECB      DS    F\n         SPACE\nPUTBUF   DS    F          MESSAGE HEADER\n         SPACE\n*                                  (Actual message buffer variable)\n         SPACE\nDYSIZE   EQU   *-DYNAM             Length of dynamic area w/o msg buf\n         EJECT\n*\n*  STORAGE DEFINITIONS:\n*\n         SPACE\n         IKJIOPL\n         SPACE\n         IKJCPPL\n         SPACE\n         IKJUPT\n         SPACE\n         IKJECT\n         SPACE\n         IKJPSCB\n         EJECT ,\n         IHAPSA\n         EJECT ,\n         IKJTCB\n         EJECT ,\n         IEZJSCB\n         EJECT ,\n         IKJRLGB\n         EJECT\n         SPACE 5\n         END\n./ ENDUP\n?!\n//HELP     EXEC MDLOAD,TRK1='5',TRK2='1',TO='HELP'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=XPROC\n***********************************************************************\n*                                                                     *\n* Copyright (c) 1989, 1992 The Charles Stark Draper Laboratory, Inc.  *\n*                                                                     *\n*  This program is provided on an \"as is\" basis. It may be freely     *\n*  distributed as long as it is not offered for commercial sale,      *\n*  nd as long as this copyright notice is included.                   *\n*                                                                     *\n***********************************************************************\n*\n* XPROC 04/13/92 - SEB1525 - Version 2 - /quotable option added\n*\n)F FUNCTION -\n\n The XPROC command parses an argument string into positional and/or\n keyword parameters, similarly to the PROC statement of a CLIST.\n However, XPROC can be used inside a REXX exec to parse the argument\n to the exec, or inside a CLIST or REXX exec to process the value of\n a variable as if it were an argument string.\n\n The values of the parameters specified on the XPROC command cause the\n corresponding REXX or CLIST variables to be set, as they would in a\n CLIST PROC statement.\n\n The rules for entering parameters to be processed by the XPROC command\n are identical to those of the CLIST PROC statement - except that XPROC\n supports extensions to the CLIST PROC syntax by means of options\n preceded by the slash (\"/\") character.\n\n For more information on PROC syntax, consult a TSO/E CLIST manual,\n or use the local Draper command XHELPC PROC to view help for PROC.\n\n Notes: As for any TSO command, it is best to enclose the entire\n       XPROC command in \"double quotes\" when using it from REXX.\n       This includes the variable names.\n\n       When XPROC is used, prompting is not available by default\n       (unlike the PROC statement of a CLIST).  Therefore, it is\n       advisable to precede the call to XPROC with a statement that\n       activates prompting, e.g.\n\n       CALL PROMPT \"ON\"  /* for REXX  */\n       CONTROL PROMPT    /* for CLIST */\n\n       Also, if there is an error in the XPROC command, or the parsing\n       of the argument string fails, a REXX exec (or a CLIST with\n       CONTROL NOFLUSH active) will NOT be flushed, but will continue\n       to execute (with none of the parameters set).  Therefore, you\n       should check the value of RC (for REXX) or &LASTCC (for CLIST)\n       afterwards and EXIT if it is not zero.\n\n)X SYNTAX -\n\n XPROC  {input-variable}\n        positional-number\n        {positional-parameter{/option...} ...}\n        {keyword-parameter{/option...}{({default-value})}{/option...}}\n\n        The number of positional-parameters must be equal to the\n        value of positional-number (which must be a number).\n\n Required: positional-number\n\n Note that the syntax of XPROC is exactly identical to that of\n the PROC statement of CLIST language, except for the optional\n \"input-variable\" and the \"/option\" feature.\n\n Examples:\n\n  The following examples assume a REXX environment:\n\n  Example 1: Define one positional parameter (DATASET),\n             no keyword parameters:\n\n       \"XPROC 1 DATASET\"\n\n  Example 2: Define no positional parameters, and one keyword\n             parameter (TESTING) which has a null default value:\n\n       \"XPROC 0 TESTING\"\n\n  Example 3: Define a positional parameter (LIBRARY), one keyword\n             parameter (TRACE) which has a null default value, and\n             one (SYSOUT) which has the default value \"A\":\n\n       \"XPROC 1 LIBRARY TRACE SYSOUT(A)\"\n\n  Example 4: Define three positional parameters (LIBRARY, TYPE and\n             MEMBER) and a keyword (OWNER) with a default value of\n             the user's TSO prefix.  Note how we allow REXX to\n             generate the desired default value so it appears in\n             the XPROC command at execution time:\n\n       \"XPROC 3 LIBRARY TYPE MEMBER OWNER('\"SYSVAR(SYSPREF)\"')\"\n\n  Example 5: Define a positional parameter (NAME) and one keyword\n             parameter (TITLE) which has a null default value, and\n             one (SUBJECT) which has the default value \"None\".\n             The values of all three parameters will be processed\n             as is with respect to case.\n\n       XPROC 1 NAME/ASIS TITLE/ASIS() SUBJECT(None)/ASIS\n\n  The following examples work under REXX or CLIST (but be sure to\n  enclose the command in \"double quotes\" under REXX):\n\n  Example 6: Define a positional parameter (LIBRARY), one keyword\n             parameter (TRACE) which has a null default value, and\n             one (SYSOUT) which has the default value \"A\".  The\n             argument string to be parsed will be taken from the\n             value of the variable \"SYSDVAL\".\n\n       XPROC SYSDVAL 1 LIBRARY TRACE SYSOUT(A)\n\n  Example 7: Define three positional parameters (LIBRARY, TYPE and\n             MEMBER), and a keyword (MARK) with a default value of\n             the current time.  Note how we allow REXX to generate\n             the desired default value so it appears in the XPROC\n             command at execution time.  The argument string to be\n             parsed will be taken from the value of the variable\n             \"STRING\".\n\n       \"XPROC STRING 3 LIBRARY TYPE MEMBER MARK('\"TIME()\"')\"\n\n             Under CLIST, this could be coded as:\n\n       XPROC STRING 3 LIBRARY TYPE MEMBER MARK('&SYSTIME')\n\n             but note that &SYSTIME gets resolved BEFORE the XPROC\n             command executes.  This is the only type of situation\n             where an \"&\" is appropriate.\n\n)O OPERANDS -\n\n))input-variable\n\n   the NAME of a variable from which the argument string to be parsed\n   is to be extracted.  The name must conform to the rules for CLIST or\n   REXX variable names.  The specified variable must be set to the\n   argument string to be processed (no command name included) before\n   XPROC is invoked.\n\n   The input-variable name may be omitted in a REXX exec ONLY, in which\n   case the arguments to the REXX exec are accessed.  This provides the\n   same capability that the PROC statement of a CLIST would.\n\n))positional-number\n\n   a number (0 or greater) which specifies the number of positional\n   parameters that follow.  This is required.  If there are no\n   positional parameters, specify a 0.\n\n))positional-parameter\n\n   A variable name consisting of alphameric and national characters,\n   of which the first cannot be numeric.  The length of this name must\n   be between 1 and 252 for CLISTs, and between 1 and 250 for REXX.\n   Underscores may be part of the name.\n\n   Note: Unlike the CLIST PROC statement, XPROC does not accept\n   ampersands in parameter names.  Ampersands in an XPROC command will\n   cause normal symbolic substitution in CLISTS; they will cause errors\n   under REXX.\n\n))keyword-parameter\n\n   A variable name consisting of alphameric and national characters,\n   of which the first cannot be numeric.  The length of this name must\n   be between 1 and 252 for CLISTs, and between 1 and 250 for REXX.\n   A default value in parentheses may optionally follow the parameter;\n   if there is no default value, the keyword takes on its own name as\n   a value if given by the caller, and a null string otherwise.\n\n   Note: Unlike the CLIST PROC statement, XPROC does not accept\n   ampersands (\"&\") in parameter names.  Ampersands in an XPROC command\n   will cause normal symbolic substitution in CLISTS; they will cause\n   errors under REXX.\n\n))default-value\n\n   Any character string, including the null string.  If it is present,\n   it must follow a valid keyword parameter and be enclosed in\n   parentheses (the right parenthesis may be omitted if this is at the\n   end of the command).  The value may be quoted (with single quotes,\n   with two quotes representing one) or unquoted; however, if it\n   contains any special characters (blanks, unbalanced parentheses,\n   etc.), it must be quoted.\n\n   If the caller provides an alternate value for the associated\n   keyword, the keyword takes on the that value; otherwise it takes on\n   the default value specified by XPROC.  Note that although () may be\n   specified in XPROC for a null string, a caller must type ('') to get\n   the same result.\n\n))option\n\n   Processing options may be associated with positional or keyword\n   parameters by specifying their names following the parameter name\n   delimited by a slash.  For example, assuming positional parameter\n   name PP and keyword parameter name KP, and option name OP1 and OP2,\n   the following are possible:\n\n   PP/OP1\n   KP/OP1\n   KP/OP1(default)\n   KP(default)/OP1\n   PP/OP1/OP2\n   KP/OP1(default)/OP2\n\n   The supported options at this time are ASIS and QUOTABLE.\n\n))ASIS\n\n   If the ASIS option is associated with a positional or keyword\n   parameter that takes a value, the value specified by the user\n   for that parameter is processed in case-retention mode.  In\n   other words, any lower-case characters present in the value\n   are kept as is.  This overrides the default behavior, which\n   converts all parameter values to uppercase (the only behavior\n   available via the PROC statement of CLIST).\n\n   The ASIS option is not valid for keyword parameters that do\n   not take a value (i.e. evaluate to themselves or null).\n\n   Note that default values in the XPROC prototype are always\n   processed asis, regardless of the presence of this option.\n\n   Examples: XPROC 1 NAME/ASIS\n             XPROC 0 TITLE/ASIS(default)\n             XPROC 0 TITLE(default)/ASIS\n\n))QUOTABLE\n\n   If the QUOTABLE option is associated with a positional parameter,\n   the value specified by the user for that parameter may be entered\n   as a quoted string.  In other words, embedded blanks or other\n   special characters may be entered if the string is enclosed in\n   single quotes by the user.  The quotes do not become part of the\n   resulting value; to pass in quotes, the user must provide doubled\n   quotes, similar to the way quotes are specified for keyword values.\n   This overrides the default behavior, which takes a\n   blank-or-comma-delimited string as the value of the positional\n   parameter, without honoring quotes specially.\n\n   Thus, you may define a CLIST or REXX exec that takes a syntax like:\n\n     MYCLIST 'hi there' 'how are you'\n\n   and have the strings entered as positional parameters.\n\n   The QUOTABLE option is valid only for positional parameters,\n   not keyword parameters.\n\n   Examples: XPROC 1 NAME/QUOTABLE\n             XPROC 3 NAME/ASIS/QUOTABLE ADDRESS/QUOTABLE CITY/ASIS\n\n./ ADD NAME=XWRITENR\n)F  XWRITENR is a REXX external routine that functions like the WRITENR\n statement of CLIST language.  In other words, it writes the evaluated\n <expression> to the TSO terminal, without a carriage return.  This is\n available in TSO/E environments only.\n\n XWRITENR must be invoked via the REXX CALL instruction, in which case\n it places a return code (normally 0) in the RESULT variable.  If\n XWRITENR is invoked as a REXX function, it returns the return code\n as the value.  Exactly one argument must be specified; otherwise\n a return code of -2 is returned.\n\n In general, a call to XWRITENR should be followed by a statement\n that requests terminal input (PULL, PARSE PULL, or PARSE EXTERNAL).\n\n)X Syntax:\n            CALL XWRITENR <expression>\n\n Note:  Some hex control characters may be used in <expression> to\n        produce certain effects:\n\n  '24'x at the end of <expression> causes the keyboard to unlock\n  following the message; anything typed in the field where the\n  cursor is positioned is NOT DISPLAYED.  A PULL or PARSE EXTERNAL\n  instruction will pick up the entered data.  This is useful for\n  password prompts.\n\n  '15'x at the end of <expression> acts as a \"new line\" character,\n  so that the cursor is moved to the beginning of the next line.\n  In other words, this makes XWRITENR behave like SAY.  Normally\n  this is not useful, but it may be useful in conjunction with\n  3270 data stream orders.\n\n  Some 3270 data stream commands ('11'x for SBA, '1D'x for SF) may\n  be embedded in <expression>.  USE THESE WITH CAUTION!  If the\n  expression you want to display might contain invalid characters,\n  use TRANSLATE() to remove them before attempting to display with\n  XWRITENR, or use SAY instead.\n\n)O\n Example:\n\n  call xwritenr \"Enter name:\"\n  parse pull name\n  /* Would display: Enter name: _\n     where _ represents the cursor */\n\n  call xwritenr \"Enter password:\" || '24'X\n  parse pull password\n  /* Would display: Enter password: _\n     where _ represents the cursor.\n     The password would be entered in a print-inhibited input field. */\n\n./ ENDUP\n?!\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDIS": {"ttr": 29445, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x00\\x08\\x8f\\x01\\x00\\x08\\x8f\\x18\"\\x0f\\xe2\\x0f\\xe3\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-03-28T00:00:00", "modifydate": "2000-03-28T18:22:00", "lines": 4066, "newlines": 4067, "modlines": 0, "user": "SEB"}, "text": "//JOBNAME JOB ACCOUNT,'NAME'\n//*------------------------------------------------------------------*/\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1988    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis. All warranties,   */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed. Such modifications should  */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*------------------------------------------------------------------*/\n//*\n//*    XDIS - 370/XA Disassembler\n//*\n//*\n//* Author: Steve Bacher <seb@draper.com>\n//*\n//* Date: 13 Jul 1993\n//*\n//*-------------------------------------------------------------------\n//*\n//* This job creates the distribution libraries (PDS's).\n//*\n//* Run this JCL to create the PDS's, after customizing to suit.\n//* (Obviously, put in a good JOB statement first.)\n//* To customize the JCL, change the defaults on the //MDLOAD PROC\n//* statement to your liking, particularly the PREFIX default.\n//* You might also want to change the final qualifiers of the PDS's\n//* created - to do this, find the // EXEC MDLOAD statements and\n//* change the value of the TO parameter.\n//*\n//* See the $$README file (of the CNTL PDS, first in this stream)\n//* for the rest of the installation instructions.\n//*\n//MDLOAD PROC CLS='*',BS='6160',U='3380',V='',\n//      TRK1='30',TRK2='10',DIR='35',RLSE='RLSE',\n//      PREFIX='SYS8.XDIS.INSTALL.'\n//*\n//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=&CLS\n//SYSUT2 DD DISP=(NEW,CATLG,DELETE),DSN=&PREFIX.&TO,\n//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=&BS),\n//  SPACE=(TRK,(&TRK1,&TRK2,&DIR),&RLSE),UNIT=&U,VOL=SER=&V\n//*\n//  PEND\n//*\n//CNTL     EXEC MDLOAD,TRK1='5',TRK2='1',TO='CNTL'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=$$README\n\n------------------------------------------------------------------------\n\n  Copyright (c) 1991, 1993 The Charles Stark Draper Laboratory, Inc.\n\n  This code is provided on an \"as is\" basis.  It may be freely\n  distributed as long as it is not offered for commercial sale,\n  and as long as this copyright notice is included.\n\n------------------------------------------------------------------------\n\nContents of this distribution:\n\nLibrary    Name       Description\n\nCNTL       $$README   This README file\nCNTL       CLDIS      JCL to compile and link the disassembler\nCNTL       RUNDIS     Sample JCL to run the disassembler in batch\nCLIST      DISASM     CLIST to invoke the disassembler from READY mode\nCLIST      DISASMSP   CLIST to invoke the disassembler ISPF dialog\nPANEL      XDISASM    ISPF panel for the disassembler\nPANEL      TXDISAS*   ISPF tutorial panels\nHELP       DISASM     HELP for the DISASM clist\nPLI        XDIS       PL/1 source code\n\nPrerequisites:\n\nPL/1 Release 1.4 or higher\n\nDirections:\n\nCompile the XDIS PL/1 source and link it into a load library of\nyour choice.\n\nCustomize the DISASM clist.  Mainly, change the name of the library from\nwhich XDIS is called to match the name of the library where you put the\ncompiled executable XDIS load module.\n\nCopy the DISASM CLIST and HELP into the appropriate system CLIST and\nHELP libraries.  You may change the name if you wish, but be sure to\nmodify the HELP file to reflect the new name if you do.\n\nIf you want to use the ISPF dialog interface:\n\n Copy the DISASMSP CLIST into the appropriate system CLIST library.\n Change the name of the library as you did for the DISASM clist.\n If you change the name of the CLIST to something else, be sure to\n modify it accordingly.\n\n Copy the panels from the panel library into the appropriate system\n ISPF panel (ISPPLIB) library.  Note that this distribution does not\n make use of LIBDEF, so unless you feel like doing some major CLIST\n hacking, you are best off installing the panels where they belong.\n You may want to add a SELECT option to one of your local option menus\n to reference CMD(DISASMSP) - or whatever you end up calling it.\n\n./ ADD NAME=CLDIS\nThis file has not yet been created, sorry.\nUse whatever PL/1 compile and link JCL is available on your system.\n./ ADD NAME=RUNDIS\n//********************************************************************\n//*\n//* Procedure to run Disassembler\n//*\n//* PARM values for the D.PARM DD control statement:\n//*\n//*  ESA = 'Y' / 'N'  ... whether to use the MVS/ESA instruction set\n//*  XA  = 'Y' / 'N'  ... whether to use the MVS/XA instruction set\n//*  SP1 = 'Y' / 'N'  ... whether to use the MVS/SP1.3 cross memory\n//*                       and other new instructions\n//*  VF  = 'Y' / 'N'  ... whether to use the 3090 Vector instructions\n//*  ESD = 'Y' / 'N'  ... whether to print a listing of the composite\n//*                       external symbol dictionary (CESD) entries\n//*                       for the load module\n//*  INCREMENT = number / 1000 ... sequence number increment for\n//*                                generated source records\n//*  OPSCAN = number / 32 ... the maximum number of instructions to be\n//*                       scanned in a pass through a section of code\n//*                       to determine whether it consists of machine\n//*                       instructions or data (this represents a\n//*                       limit - scans are terminated by branch\n//*                       instructions, relocatable address constants\n//*                       or other known points in any case).\n//*\n//* The default values are the second alternatives shown above.\n//*\n//********************************************************************\n//DISASM   PROC LOADLIB=,MODULE=,CSECT=,OUTSRC=\n//*\n//*  LOADLIB - library containing load module to be disassembled\n//*  MODULE  - name of load module containing csect to be disassembled\n//*  CSECT   - name of control section to be disassembled\n//*  OUTSRC  - name of data set to contain output \"source deck\"\n//*\n//S0       EXEC PGM=IEFBR14\n//DDSRC    DD   DSN=&OUTSRC,DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,1)\n//*\n//D        EXEC PGM=XDIS,PARM='REPORT,ISA(32K)/&CSECT'\n//STEPLIB  DD   DSN=PROGLIB.CALL.LOAD,DISP=SHR  <== change to your lib\n//SYSPRINT DD   SYSOUT=*\n//PLIDUMP  DD   DUMMY\n//DISPRINT DD   SYSOUT=*\n//DISLOAD  DD   DISP=SHR,DSN=&LOADLIB(&MODULE)\n//DISPUNCH DD   DISP=(NEW,CATLG,KEEP),DSN=&OUTSRC,UNIT=SYSDA,\n//         SPACE=(6160,(25,25),RLSE)\n//DISPARM  DD   DDNAME=PARM\n//         PEND\n//*\n//*\n//DISEXEC  EXEC DISASM,\n//         LOADLIB='MY.LOAD.LIB',\n//         MODULE=MYLMOD,\n//         CSECT=MYSECT,\n//         OUTSRC='MYID.NEW.SOURCE.ASM'\n//*\n//* Uncomment the following if you don't need a source deck.\n//*\n//* D.DISPUNCH DD DUMMY,DISP=(NEW,DELETE,DELETE)\n//*\n//* Required.  Defaults shown in this example:\n//*\n//D.PARM     DD *\n ESA='N',XA='N',SP1='N',VF='N',ESD='N',OPSCAN=32;\n/*\n./ ENDUP\n?!\n//CLIST    EXEC MDLOAD,TRK1='5',TRK2='1',TO='CLIST'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=DISASM\nPROC 3 LIBRARY MEMBER CSECT +\n       XA NOXA SP1 NOSP1 ESD NOESD INCREMENT() OPSCAN() +\n       ESA NOESA VF NOVF +\n       VOLUME() +\n       PRINT(&CSECT.) OUTPUT(&PRINT..DISLIST) PUNCH() XTRACE\n\n/**********************************************************************/\n/*                                                                    */\n/* CLIST syntax:                                                      */\n/*                                                                    */\n/* DISASM 'userid.load.library' lmod_name csect_name                  */\n/*                                                                    */\n/* Optional keywords:                                                 */\n/*                                                                    */\n/* ESA - recognize MVS/ESA opcodes (default = NOESA)                  */\n/* XA - recognize MVS/XA opcodes (default = NOXA)                     */\n/* VF - recognize vector opcodes (default = NOVF)                     */\n/* SP1 - recognize MVS/SP1 cross-memory opcodes (default = NOSP1)     */\n/* ESD - print external symbol dictionary (default = NOESD)           */\n/* INCREMENT(nnn) - sequence number increment (I know, who cares)     */\n/* OPSCAN(nn) - default 32, see comments in source for explanation    */\n/* VOLUME() - if library is not cataloged                             */\n/* PRINT() - name of output listing dataset (.DISLIST appended)       */\n/* OUTPUT() - name of output listing dataset (.DISLIST NOT appended)  */\n/* PUNCH() - name of output source deck (none if omitted)             */\n/* XTRACE - for CLIST debugging                                       */\n/*                                                                    */\n/* Note: Change name of library to one of your own choosing below.    */\n/*                                                                    */\n/**********************************************************************/\n\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n\nIF      &XA&NOXA   = XA     THEN SET XA  = &STR(XA='Y')\nELSE IF &XA&NOXA   = NOXA   THEN SET XA  = &STR(XA='N')\nELSE                             SET XA  =\n\nIF      &ESA&NOESA = ESA    THEN SET ESA = &STR(ESA='Y')\nELSE IF &ESA&NOESA = NOESA  THEN SET ESA = &STR(ESA='N')\nELSE                             SET ESA =\n\nIF      &VF&NOVF   = VF     THEN SET VF  = &STR(VF='Y')\nELSE IF &VF&NOVF   = NOVF   THEN SET VF  = &STR(VF='N')\nELSE                             SET VF  =\n\nIF      &SP1&NOSP1 = SP1    THEN SET SP1 = &STR(SP1='Y')\nELSE IF &SP1&NOSP1 = NOSP1  THEN SET SP1 = &STR(SP1='N')\nELSE                             SET SP1 =\n\nIF      &ESD&NOESD = ESD    THEN SET ESD = &STR(ESD='Y')\nELSE IF &ESD&NOESD = NOESD  THEN SET ESD = &STR(ESD='N')\nELSE                             SET ESD =\n\nIF &STR(&INCREMENT) \u00ac= THEN SET INCREMENT = &STR(INCREMENT=&INCREMENT)\nIF &STR(&OPSCAN)    \u00ac= THEN SET OPSCAN    = &STR(OPSCAN=&OPSCAN)\n\nIF &SUBSTR(1,&LIBRARY) \u00ac= ' THEN SET LIBRARY = &STR(&SYSPREF..&LIBRARY)\nELSE SET LIBRARY = &SUBSTR(2:&LENGTH(&STR(&LIBRARY))-1,&LIBRARY)\n\nIF &STR(&VOLUME) \u00ac= THEN SET VOLUME = VOL(&STR(&VOLUME))\nELSE SET VOLUME =\n\nIF &STR(&PRINT)   = &STR(*) THEN SET OUTPUT = &STR(*)\nIF &STR(&OUTPUT) \u00ac= &STR(*) THEN DO\n IF &XTRACE = THEN CONTROL NOMSG\n DELETE &OUTPUT\n CONTROL MSG\n ALLOC DA(&OUTPUT) T SP(50 50) REL REU\nEND\nALLOC F(DISPRINT)      REU DA(&OUTPUT)\nALLOC F(SYSPRINT)      REU DA(*)\nALLOC F(DISLOAD)   SHR REU DA('&LIBRARY(&MEMBER)') &VOLUME\n/*\nIF &STR(&PUNCH) \u00ac= THEN DO\n IF &XTRACE = THEN CONTROL NOMSG\n DELETE &PUNCH\n CONTROL MSG\n ALLOC DA(&PUNCH) T SP(50 50) REL REU\n ALLOC F(DISPUNCH)     REU DA(&PUNCH)\nEND\nELSE ALLOC F(DISPUNCH) REU DUMMY\n/*\nIF &STR(&ESA&XA&VF&SP1&ESD&INCREMENT&OPSCAN) \u00ac= THEN DO\n SET FILES = DISPARM DISPRINT DISLOAD DISPUNCH\n ALLOC     F(DISPARM)  BL(80) SP(1) DEL REU\n OPENFILE    DISPARM   O\n SET         DISPARM = &STR(&ESA,&XA,&VF,&SP1,&ESD,&INCREMENT,&OPSCAN;)\n PUTFILE     DISPARM\n CLOSFILE    DISPARM\nEND\nELSE DO\n SET FILES = DISPRINT DISLOAD DISPUNCH\n IF &XTRACE = THEN CONTROL NOMSG\n FREE F(DISPARM)\n CONTROL MSG\nEND\n\nCALL 'PROGLIB.CALL.LOAD(XDIS)' 'NR,ISA(32K)/&CSECT'\n\nFREE F(&FILES)\nIF &STR(&OUTPUT) \u00ac= &STR(*) THEN DO\n WRITE OUTPUT LISTING IS &OUTPUT..\nEND\nIF &STR(&PUNCH) \u00ac= THEN +\n WRITE SOURCE DECK GENERATED IN &PUNCH..\n./ ADD NAME=DISASMSP\nPROC 0 LIB() XTRACE\n/**********************************************************************\n/*                                                                    *\n/* DISASSEMBLER - CLIST to interface to ISPF dialog                   *\n/*                                                                    *\n/* Note: No LIBDEF is done.  Panels are expected to be in the         *\n/*       ISPPLIB concatenation already.                               *\n/*                                                                    *\n/**********************************************************************\n\n/* Customize the following lines for your installation. */\n\nSET DEFAULTLIB = PROGLIB.CALL.LOAD\nSET THISCLIST  = DISASMSP\n\n/* End customization. */\n\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOFLUSH NOCAPS\nIF &SYSISPF \u00ac= ACTIVE THEN DO\n ISPF CMD(&THISCLIST) NEWAPPL(ISR)\n EXIT\nEND\nIF &STR(&LIB) = THEN SET LIB = &STR(&DEFAULTLIB)\nSET FIRST = 1\nCONTROL NOFLUSH\nSET CURSOR = XDILIB\nREPEAT:ISPEXEC CONTROL DISPLAY REFRESH\nISPEXEC DISPLAY PANEL(XDISASM) CURSOR(&CURSOR)\nIF &LASTCC NE 0 THEN EXIT\nIF &XTRACE = XTRACE THEN ISPEXEC CONTROL DISPLAY LINE\nSET CURSOR = XDILIB\nIF &NRSTR(&XDIVOL) \u00ac= THEN SET VOL = &NRSTR(VOL(&XDIVOL))\nELSE SET VOL =\n/*\nIF      &XDIESA    = Y      THEN SET ESA = &STR(ESA='Y')\nELSE IF &XDIESA    = N      THEN SET ESA = &STR(ESA='N')\nELSE +\n                                 SET ESA =\n/*\nIF      &XDIXA     = Y      THEN SET XA  = &STR(XA='Y')\nELSE IF &XDIXA     = N      THEN SET XA  = &STR(XA='N')\nELSE +\n                                 SET XA  =\n/*\nIF      &XDIVF     = Y      THEN SET VF  = &STR(VF='Y')\nELSE IF &XDIVF     = N      THEN SET VF  = &STR(VF='N')\nELSE +\n                                 SET VF  =\n/*\nIF      &XDISP1    = Y      THEN SET SP1 = &STR(SP1='Y')\nELSE IF &XDISP1    = N   1  THEN SET SP1 = &STR(SP1='N')\nELSE +\n                                 SET SP1 =\n/*\nIF      &XDIESD    = Y      THEN SET ESD = &STR(ESD='Y')\nELSE IF &XDIESD    = N      THEN SET ESD = &STR(ESD='N')\nELSE +\n                                 SET ESD =\n/*\nIF &STR(&XDISEQ) \u00ac= THEN SET INCREMENT = &STR(INCREMENT=&XDISEQ)\nELSE SET INCREMENT =\nIF &STR(&XDIOPS) \u00ac= THEN SET OPSCAN    = &STR(OPSCAN=&XDIOPS)\nELSE SET OPSCAN =\n/*\nIF &SUBSTR(1,&XDILIB) \u00ac= ' THEN SET LIBRARY = &STR(&SYSPREF..&XDILIB)\nELSE SET LIBRARY = &SUBSTR(2:&LENGTH(&STR(&XDILIB))-1,&XDILIB)\n/*\nIF &STR(&XDIVOL) \u00ac= THEN SET VOLUME = VOL(&STR(&XDIVOL))\nELSE DO\n SET VOLUME =\n SET STATUS = SYSDSN('&LIBRARY(&XDILMN)')\n IF &STR(&STATUS) \u00ac= OK THEN DO\n  SET ZERRSM   = &STR()\n  SET ZERRLM   = &STR(Cannot use '&LIBRARY(&XDILMN)' - &STATUS)\n  SET ZERRALRM = YES\n  SET ZERRHM   = &STR(*)\n  ISPEXEC SETMSG MSG(ISRZ002)\n  SET CURSOR = XDILMN\n  GOTO REPEAT\n END\n ELSE IF &CHKCC \u00ac= 0 THEN DO\n  SET CURSOR = XDILIB\n  GOTO REPEAT\n END\nEND\n/*\nIF &SYSDSN(&XDIPRT) = &STR(DATASET NOT FOUND) THEN DO\n ALLOC DA(&XDIPRT) RECFM(V B A) LRECL(155) BLKSIZE(6233) +\n       SPACE(14 10) BLOCK(6233)\n IF &LASTCC > 0 THEN GOTO REPEAT\nEND\nALLOC F(DISPRINT)      REU DA(&XDIPRT)\nIF &LASTCC \u00ac= 0 THEN GOTO REPEAT\nALLOC F(SYSPRINT)      REU DA(*)\nIF &LASTCC \u00ac= 0 THEN GOTO REPEAT\nALLOC F(DISLOAD)   SHR REU DA('&LIBRARY(&XDILMN)') &VOLUME\nIF &LASTCC \u00ac= 0 THEN GOTO REPEAT\n/*\nIF &STR(&XDIPCH) \u00ac= THEN DO\n IF &SYSDSN(&XDIPCH) = &STR(DATASET NOT FOUND) THEN DO\n  ALLOC DA(&XDIPCH) RECFM(F B) LRECL(80) BLKSIZE(6160) +\n        SPACE(25 25) BLOCK(6160)\n  IF &LASTCC > 0 THEN GOTO REPEAT\n END\n ALLOC F(DISPUNCH)     REU DA(&XDIPCH)\n IF &LASTCC \u00ac= 0 THEN GOTO REPEAT\nEND\nELSE DO\n ALLOC F(DISPUNCH) REU DUMMY\n IF &LASTCC \u00ac= 0 THEN GOTO REPEAT\nEND\n/*\nIF &STR(&ESA&XA&VF&SP1&ESD&INCREMENT&OPSCAN) \u00ac= THEN DO\n SET FILES = DISPARM DISPRINT DISLOAD DISPUNCH\n ALLOC     F(DISPARM)  BL(80) SP(1) DEL REU\n IF &LASTCC \u00ac= 0 THEN GOTO REPEAT\n OPENFILE    DISPARM   O\n SET         DISPARM = &STR(&ESA,&XA,&VF,&SP1,&ESD,&INCREMENT,&OPSCAN;)\n PUTFILE     DISPARM\n CLOSFILE    DISPARM\nEND\nELSE DO\n SET FILES = DISPRINT DISLOAD DISPUNCH\n IF &XTRACE = THEN CONTROL NOMSG\n FREE      F(DISPARM)\n CONTROL   MSG\nEND\n/*\nCALL '&LIB(XDIS)' 'NR,ISA(32K),NOSTAE,NOSPIE/&XDICSN'\n/*\nFREE F(&FILES)\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC BROWSE DATASET(&XDIPRT)\nIF &LASTCC \u00ac= 0 THEN ISPEXEC DISPLAY PANEL(ISPTERM)\nIF &STR(&XDIPCH) \u00ac= THEN DO\n ISPEXEC EDIT DATASET(&XDIPCH)\n IF &LASTCC > 4 THEN ISPEXEC DISPLAY PANEL(ISPTERM)\nEND\nGOTO REPEAT\n./ ENDUP\n?!\n//HELP     EXEC MDLOAD,TRK1='5',TRK2='1',TO='HELP'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=DISASM\n)F Function -\n\n   This utility disassembles an assembler language program in load\n   module format, producing a pseudo-assembly listing and, optionally,\n   a source program deck.  The pseudo-assembly listing may optionally\n   include an external symbol dictionary listing for the entire load\n   module, although only one control section within that load module\n   may be disassembled in one invocation.\n\n   NOTE:\n\n   Many software vendors, most prominently IBM, have established\n   restrictions on installations regarding disassembly of their code.\n   Much object code is proprietary; other code is protected by\n   licensing agreements or laws.  Unauthorized disassembly of\n   IBM or other vendor object code may be a violation of corporate\n   rules, punishable by fines or other legal recourse.\n   Use this facility ONLY to assist in the reconstruction of\n   lost in-house source modules, or for emergency debugging purposes.\n\n)X Syntax -\n\n   DISASM     'library'\n              'member'\n              'csect'\n              VOLUME('volume serial')\n              PRINT('qualifier')\n              OUTPUT('data set name')\n              PUNCH('data set name')\n              INCREMENT('number')\n              OPSCAN('number')\n              ESA / NOESA\n              XA / NOXA\n              VF / NOVF\n              SP1 / NOSP1\n              ESD / NOESD\n\n   Required:  'library'\n              'member'\n              'csect'\n\n   Defaults:  VOLUME    defaults to null\n              PRINT     defaults to csect name\n              OUTPUT    defaults to prefix.&PRINT..DISLIST\n              PUNCH     defaults to null\n              INCREMENT defaults to the disassembler's internal value\n                        (currently 1000)\n              OPSCAN    defaults to the disassembler's internal value\n                        (currently 32)\n              ESA/NOESA defaults to the disassembler's internal value\n                        (currently NOESA)\n              XA/NOXA   defaults to the disassembler's internal value\n                        (currently NOXA)\n              VF/NOVF   defaults to the disassembler's internal value\n                        (currently NOVF)\n              SP1/NOSP1 defaults to the disassembler's internal value\n                        (currently NOSP1)\n              ESD/NOESD defaults to the disassembler's internal value\n                        (currently NOESD)\n\n)O Operands -\n\n)P'library'      - the name of the load library that contains the load\n                   module with the CSECT to be disassembled.\n\n)P'member'       - the name (1 to 8 characters) of the load module\n                   containing the control section to be disassembled.\n\n)P'csect'        - the control section name to be disassembled.\n\n))VOLUME         - the volume containing the load library specified by\n                   the third positional, if it is not cataloged.\n\n))PRINT          - the middle qualifier (1-8 characters) of the output\n                   data set created to contain the pseudo-assembly\n                   listing (this will be ignored if you use the OUTPUT\n                   keyword).  Default is the csect name.\n\n))OUTPUT         - the name of the data set created to contain the\n                   pseudo-assembly listing (overrides anything which\n                   was specified via the PRINT keyword).  Default is\n                   'prefix.printname.DISLIST', where \"printname\" is\n                   the value of the PRINT keyword, whose default is\n                   the csect name.\n\n))PUNCH          - the name of the data set created to contain the\n                   reconstructed source program.  If this operand is\n                   omitted, no source file is created.\n\n))INCREMENT      - a value used to generate sequence numbers.  The\n                   default is the disassembler's internal default\n                   value (currently 1000).\n\n))OPSCAN         - the maximum number of instructions to be scanned in\n                   a pass through a section of code to determine\n                   whether it consists of machine instructions or data.\n                   This represents a maximum limit; instruction scans\n                   are terminated by branch opcodes, relocatable\n                   address constants, or other points in the code known\n                   to be data.\n                   Default is the disassembler's internal default\n                   value (currently 32).\n\n))ESA            - If ESA is specified, the MVS/ESA instruction set is\n                   used.  This is defined to include the CFC and UPT\n                   op codes as well.\n\n))NOESA          - If NOESA is specified, the MVS/ESA instruction set\n                   is not used; ESA opcodes are treated as data,\n                   including the CFC and UPT opcodes.  At the present\n                   time this is the disassembler's default option.\n\n))XA             - If XA is specified, the MVS/XA instruction set is\n                   used.\n\n))NOXA           - If NOXA is specified, the MVS/XA instruction set is\n                   not used; XA opcodes are treated as data, including\n                   the BAS and BASR opcodes.  At the present time this\n                   is the disassembler's default option.\n\n))VF             - If VF is specified, the Vector Facility instruction\n                   operation codes are recognized.  Specification of\n                   this option forces XA mode.\n\n))NOVF           - If NOVF is specified, the Vector Facility\n                   instruction operation codes are treated as data.\n                   At the present time this is the disassembler's\n                   default option.\n\n))SP1            - If SP1 is specified, the MVS/SP1.3 cross memory\n                   operation codes are recognized.\n\n))NOSP1          - If NOSP1 is specified, the MVS/SP1.3 cross memory\n                   operation codes are treated as data.  At the present\n                   time this is the disassembler's default option.\n\n))ESD            - If ESD is specified, a composite external symbol\n                   dictionary listing is printed with the pseudo-\n                   assembly listing.  Note that this will include all\n                   control section names, external references, etc.\n                   in the load module, even though only the control\n                   section specified by the second positional is being\n                   disassembled.\n\n))NOESD          - .If NOESD is specified, the disassembler will not\n                   print a composite external symbol dictionary map.\n                   This is the disassembler's default operation.\n\n./ ENDUP\n?!\n//PANEL    EXEC MDLOAD,TRK1='5',TRK2='1',TO='PANEL'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=XDISASM\n)ATTR\n | TYPE(TEXT) COLOR(TURQ)\n \u009f TYPE(TEXT) COLOR(PINK) HILITE(BLINK)\n \\ TYPE(TEXT) COLOR(YELLOW)\n \u009f TYPE(TEXT) COLOR(YELLOW) HILITE(USCORE)\n ~ TYPE(TEXT) COLOR(PINK) INTENS(HIGH)\n)BODY\n%----------------------- DISASSEMBLER\n------------------------------------------\n%COMMAND ===>_ZCMD\n+\n+  %Library name    ==>_XDILIB                                        +\n+  %Volume serial   ==>_XDIVOL+ (If not cataloged)\n+\n+  %Load module name     ===>_XDILMN  +\n+  %Control section name ===>_XDICSN  +\n+\n+ %Listing dataset name   ===>_XDIPRT\n+ %Source deck (optional) ===>_XDIPCH\n+\n|MVS/ESA operation codes?       ==>_Z  |List external symbols?     ==>_Z  +\n|MVS/XA operation codes?        ==>_Z  |\n|Vector facility opcodes?       ==>_Z  |           \"OPSCAN\" value\n==>_XDIOPS  +\n|Cross memory services opcodes? ==>_Z  |\n+\n\u009fWARNING:\\IBM has repeatedly stated that disassembly of IBM object code is a\n         \u009fVIOLATION\\of IBM rules and may be punishable by fines and/or other\n         \\legal means.  Use this option with discretion, preferably on\nNON-IBM\n         \\code ONLY.  This option is meant to assist in the reconstruction\nof\n         \\old in-house lost source code, and is NOT INTENDED to be used to\n         \\compromise the integrity of IBM or other software vendors.\n)INIT\n   .ZVARS = '(XDIESA XDIESD XDIXA XDIVF XDISP1)'\n   .HELP = TXDISASM\n   &XDIESA = TRANS(&XDIESA Y,YES N,NO *,NO)\n   &XDIXA  = TRANS(&XDIXA  Y,YES N,NO *,NO)\n   &XDISP1 = TRANS(&XDISP1 Y,YES N,NO *,NO)\n   &XDIVF  = TRANS(&XDIVF  Y,YES N,NO *,NO)\n   &XDIESD = TRANS(&XDIESD Y,YES N,NO *,NO)\n   &XDISEQ = TRANS(&XDISEQ ' ',1000 *,*)\n   &XDIOPS = TRANS(&XDIOPS ' ',32   *,*)\n   &XDIPRT = ''\n   /* Set listing name for tutorial panel TXDISAS1 */\n   IF (&XDIPRT = '')\n    IF (&XDICSN \u00ac= '')\n     &XDITPR = '''&ZPREFIX..&XDICSN..DISLIST'''\n    IF (&XDICSN = '')\n     IF (&XDILMN \u00ac= '')\n      &XDITPR = '''&ZPREFIX..&XDILMN..DISLIST'''\n     IF (&XDILMN = '')\n      &XDITPR = '''&ZPREFIX..DISLIST'''\n)PROC\n   IF (&XDIPRT = '')\n    IF (&XDICSN \u00ac= '')\n     &XDIPRT = '''&ZPREFIX..&XDICSN..DISLIST'''\n    IF (&XDICSN = '')\n     IF (&XDILMN \u00ac= '')\n      &XDIPRT = '''&ZPREFIX..&XDILMN..DISLIST'''\n     IF (&XDILMN = '')\n      &XDIPRT = '''&ZPREFIX..DISLIST'''\n   IF(&ZCMD \u00ac= '') .MSG=ISPZ001\n   VER(&XDILIB NB DSNAME)\n   VER(&XDILMN NB NAME  )\n   VER(&XDICSN NB       )\n   IF (&XDIPRT = '')\n    IF (&XDICSN \u00ac= '')\n     &XDIPRT = '''&ZPREFIX..&XDICSN..DISLIST'''\n    IF (&XDICSN = '')\n     IF (&XDILMN \u00ac= '')\n      &XDIPRT = '''&ZPREFIX..&XDILMN..DISLIST'''\n     IF (&XDILMN = '')\n      &XDIPRT = '''&ZPREFIX..DISLIST'''\n   VER(&XDIPRT    DSNAME)\n   VER(&XDIPCH    DSNAME)\n   &XDIESA = TRUNC(&XDIESA,1)\n   VER(&XDIESA    LIST Y,N)\n   &XDIXA = TRUNC(&XDIXA,1)\n   VER(&XDIXA     LIST Y,N)\n   &XDISP1 = TRUNC(&XDISP1,1)\n   VER(&XDISP1    LIST Y,N)\n   &XDIVF = TRUNC(&XDIVF,1)\n   VER(&XDIVF     LIST Y,N)\n   &XDIESD = TRUNC(&XDIESD,1)\n   VER(&XDIESD    LIST Y,N)\n   VER(&XDISEQ    RANGE 1 99999)\n   VER(&XDIOPS    RANGE 0 99999)\n   VPUT (XDILIB XDIVOL XDILMN XDICSN\n         XDIESA XDIXA XDISP1 XDIVF XDIESD XDISEQ XDIOPS) PROFILE\n)END\n./ ADD NAME=TXDISASM\n%TUTORIAL -------------- DISASSEMBLER\n------------------------------------------\n%SELECTION ===>_ZCMD\n+\n\n%  *** WARNING!!! *** IBM CORPORATION HAS REPEATEDLY STATED THAT\n%  DISASSEMBLY OF IBM OBJECT CODE IS A VIOLATION OF IBM RULES AND\n%  MAY BE PUNISHABLE BY FINES AND/OR OTHER LEGAL MEANS.  USE THIS\n%  DISASSEMBLER WITH DISCRETION, PREFERABLY ON NON-IBM CODE.  THIS\n%  TOOL IS MEANT TO ASSIST IN THE RECONSTRUCTION OF OLD IN-HOUSE\n%  LOST SOURCE CODE, AND IS NOT INTENDED TO BE USED TO COMPROMISE\n%  THE INTEGRITY OF IBM OR OTHER SOFTWARE VENDORS.\n\n+  This facility disassembles a machine language program in load\n   module format, producing a pseudo-assembly listing and, optionally,\n   a source program deck.  The pseudo-assembly listing may optionally\n   include an external symbol dictionary listing for the entire load\n   module, although only one control section within that load module\n   may be disassembled in one invocation.\n\n   You will be placed into BROWSE on the output pseudo-assembly listing,\n   and subsequently into EDIT on the generated source deck if you\n   requested one.\n\n   Press ENTER to continue with the tutorial.\n\n)PROC\n &ZSEL  = TXDISAS1\n)END\n./ ADD NAME=TXDISAS1\n%TUTORIAL -------------- DISASSEMBLER - OPTIONS\n--------------------------------\n%SELECTION ===>_ZCMD\n+\n\n%Library name         -+is the name of the load library that contains the\nload\n                        load module with the CSECT to be disassembled.\n%Volume serial        -+the volume containing the load library specified by\n                        \"Library name\", if it is not cataloged.\n\n%Load module name     -+the name (1 to 8 characters) of the load module\n                        containing the control section to be disassembled.\n%Control section name -+the name of the CSECT to be disassembled.\n\n%Listing dataset name -+the name of the output data set created to contain\nthe\n                        pseudo-assembly listing.  If this field is left\nblank,\n                        the name will consist of your TSO prefix plus the\ncsect\n                        name plus the final qualifier DISLIST.\n                        ...i.e.: %&XDITPR\n%Source deck          -+the name of the assembler-type source data set\ncreated\n                        to contain the reconstructed source program.  If\nthis\n                        field is left blank, no source deck is created.\n\n Press ENTER for explanations of the disassembler%options.+\n\n)PROC\n &ZCONT = TXDISAS2\n)END\n./ ADD NAME=TXDISAS2\n%TUTORIAL -------------- DISASSEMBLER - OPTIONS\n--------------------------------\n%SELECTION ===>_ZCMD\n+\n\n%MVS/XA operation codes? -+If you say YES, the MVS/XA instruction set is\n                           recognized, including BASSM, BSM, and the new\n                           subchannel I/O instructions.\n\n                          %Note:+If the control section being disassembled\nhas\n                           AMODE and RMODE information associated with it,\nAMODE\n                           and RMODE instructions will be generated; this\nholds\n                           regardless of how the XA option was specified.\n\n%Cross memory services opcodes? -+If you say YES, the MVS/SP1.3 cross memory\n                                  operation codes are recognized (PC, PT,\netc.).\n\n%List external symbols? -+If you say YES, a composite external symbol\ndictionary\n                          listing is printed with the pseudo-assembly\nlisting.\n                          Note that this will include all control section\nnames,\n                          external references, etc. in the load module.\n\n Press ENTER to see the rest of the options explicated.\n)PROC\n &ZCONT = TXDISAS3\n)END\n./ ADD NAME=TXDISAS3\n%TUTORIAL -------------- DISASSEMBLER - OPTIONS\n--------------------------------\n%SELECTION ===>_ZCMD\n+\n\n%MVS/ESA operation codes? -+If you say YES, the MVS/ESA operation codes will\nbe\n                            recognized by the disassembler.\n\n%Vector facility opcodes? -+If you say YES, the 3090 Vector Facility\noperation\n                            codes will be recognized by the disassembler.\n\n%\"OPSCAN\" value  -+the maximum number of instructions to be scanned in a\npass\n                   through a section of code to determine whether it\nconsists of\n                   machine instructions or data.  This represents a maximum\n                   limit; instruction scans are terminated by branch\nopcodes,\n                   relocatable address constants, or other points in the\ncode\n                   known to be data.  The default value is 32.\n\n)PROC\n)END\nremoved - not useful...\n%Sequence number increment -+a value used to generate sequence numbers in\nthe\n                             source deck.  The default is 1000.\n\n./ ENDUP\n?!\n//PLI      EXEC MDLOAD,TRK1='10',TRK2='1',TO='PLI'\n//SYSIN    DD   DATA,DLM='?!'\n./ ADD NAME=XDIS\n*PROCESS OPT(TIME);\n XDIS: Proc (PARM) options(main) reorder; /* Disassembler for XA */\n\n /*******************************************************************/\n /*                                                                 */\n /* Copyright (c) 1988 The Charles Stark Draper Laboratory, Inc.    */\n /*                                                                 */\n /* This program is provided on an \"as is\" basis.  It may be freely */\n /* distributed as long as it is not offered for commercial sale,   */\n /* and as long as this copyright notice is included.               */\n /*                                                                 */\n /* Warning:  Use of this program on licensed object code from IBM  */\n /* or other software vendors may be subject to criminal or other   */\n /* penalties.  Consult your customer representative for the facts. */\n /*                                                                 */\n /*******************************************************************/\n\n /********************************************************************/\n /*                                                                  */\n /* Change activity:                                                 */\n /*                                                                  */\n /* 05/17/89 - Support for EXTRN + A(xxx+nnn) constant specs.        */\n /* 12/15/89 - Fixed bug with 0C4 with data at end of module.        */\n /* 12/19/89 - Handles complexly relocatable A(EXTRN2-EXTRN1) adcons.*/\n /* 12/26/89 - ESA support.                                          */\n /*                                                                  */\n /********************************************************************/\n\n Dcl\n     PARM                               char(100) var;\n\n Dcl\n     COPYRIGHT_NOTICE_AND_DISCLAIMER (9) char(64) static init(\n   'Copyright (c) 1988 The Charles Stark Draper Laboratory, Inc.',\n   '',\n   'This program is provided on an \"as is\" basis.  It may be freely',\n   'distributed as long as it is not offered for commercial sale,',\n   'and as long as this copyright notice is included.',\n   '',\n   'Warning:  Use of this program on licensed object code from IBM',\n   'or other software vendors may be subject to criminal or other',\n   'penalties.  Consult your customer representative for the facts.'\n                                              );\n\n Dcl\n     LOAD_PTR                    static ptr       init(Null),\n     CESD_PTR                    static ptr       init(Null),\n     CONTROL_PTR                 static ptr       init(Null),\n     RLD_PTR                     static ptr       init(Null),\n     RLD_SUB_PTR                 static ptr       init(Null),\n     TEXT_PTR                    static ptr       init(Null),\n     TEMP_PTR                    static ptr       init(Null),\n     END_PTR                     static ptr       init(Null),\n     OP_PTR                      static ptr       init(Null),\n     RETCODE                     static fixed(31) bin init(0),\n     CSECT_OFFSET                static fixed(31) bin init(0),\n     CSECT_LENGTH                static fixed(31) bin init(0),\n     TEXT_MOVE_OFFSET            static fixed(31) bin init(0),\n     TEXT_MOVE_SOURCE            static fixed(31) bin init(0),\n     TEXT_MOVE_LENGTH            static fixed(31) bin init(0),\n     BLOCK_LENGTH                static fixed(31) bin init(0),\n     IOFF                        static fixed(31) bin,\n     SAVE_IOFF                   static fixed(31) bin,\n     ILEN                        static fixed(31) bin,\n     I                           static fixed(31) bin,\n     J                           static fixed(31) bin,\n     K                           static fixed(31) bin,\n     L                           static fixed(31) bin,\n     PAGENUM                     static fixed(31) bin init(0),\n     CESD_ESDID                  static fixed(15) bin init(0),\n     ESDID                       static fixed(15) bin init(0),\n     OP_INDEX                    static fixed(15) bin,\n     OP_INDEX_LIMIT              static fixed(15) bin,\n     1 MISC_FLAGS      unaligned static,\n       2 DLOAD_EOF                      bit(1)    init('0'B),\n       2 PUNCH                          bit(1)    init('0'B),\n       2 TEXT                           bit(1)    init('0'B),\n       2 LAST_TEXT                      bit(1)    init('0'B),\n       2 MOVE_TEXT                      bit(1)    init('0'B),\n       2 GOT_SEGTAB                     bit(1)    init('0'B),\n       2 VALID_INST                     bit(1)    init('0'B),\n       2 VALID_CHAIN                    bit(1)    init('0'B),\n       2 RECOGNIZED_INST                bit(1)    init('0'B),\n       2 XA_MODULE                      bit(1)    init('0'B),\n       2 PRIVATE_CODE                   bit(1)    init('0'B),\n\n     ESD_ID                      static char(4),\n     ESD_ADDR                    static char(6),\n     ESD_LEN                     static char(6),\n     ESD_LDID                    static char(4),\n     ESD_FLAGS                   static char(2),\n\n     TYPE                        static char(1),\n     CONDITION_CODE              static char(1)   init(' '),\n     OPERATION                   static char(5),\n     MNEMONIC_OPER               static char(5) var,\n     MNEMONIC_STRING             static char(4)   init('    '),\n     AMODE                       static char(3)   init('   '),\n     RMODE                       static char(3)   init('   '),\n     CSECT_NAME                  static char(8)   init(' '),\n     CSECT_LABEL                 static char(8)   init(' '),\n     NAME9                       static char(9)   init(' '),\n     NAME                               char(8) def NAME9 pos(1),\n     OPERANDS                    static char(64) var,\n     IMAGE                       static char(64) var,\n     TRANS_ARRAY (16) static char(16)   init((15)(16)' ',\n                                             '0123456789ABCDEF'),\n     TRANS_TABLE             char(256)  def TRANS_ARRAY,\n\n     SYSDATE                     static char(6),\n     TODAY                       static char(8),\n\n /********************************************************************\n    The following are fields that may be modified by \"get data\"\n    style specifications on the DISPARM file.  Meanings are:\n\n     ESA = 'Y' / 'N'  ... whether to use the MVS/ESA instruction set\n     XA  = 'Y' / 'N'  ... whether to use the MVS/XA instruction set\n     SP1 = 'Y' / 'N'  ... whether to use the MVS/SP1.3 cross memory\n                          and other new instructions\n     VF  = 'Y' / 'N'  ... whether to use the 3090 Vector instructions\n     ESD = 'Y' / 'N'  ... whether to print a listing of the composite\n                          external symbol dictionary (CESD) entries\n                          for the load module\n     INCREMENT = number / 1000 ... sequence number increment for\n                                   generated source records\n     OPSCAN = number / 32 ... the maximum number of instructions to be\n                          scanned in a pass through a section of code\n                          to determine whether it consists of machine\n                          instructions or data (this represents a\n                          limit - scans are terminated by branch\n                          instructions, relocatable address constants\n                          or other known points in any case).\n\n    The default values are the second alternatives shown above.\n\n   *******************************************************************/\n\n     ESA                         static char(1) init('N'),\n     XA                          static char(1) init('N'),\n     SP1                         static char(1) init('N'),\n     VF                          static char(1) init('N'),\n     ESD                         static char(1) init('N'),\n     INCREMENT                   static fixed (7) dec init(1000),\n     OPSCAN                      static fixed(31) bin init(32),\n\n   /*Dummy based variables used as \"templates\" for data manipulation*/\n\n     N                           based  fixed(31) bin,\n     ADCON2                      based  fixed(15) bin,\n     ADCON3                      based  bit(24),\n     ADCON4                      based  fixed(31) bin,\n\n   /* Tables which define MVS operation codes and their attributes  */\n\n     OP_CODE_LOOKUP (0:255) static fixed(15) bin init(\n\n   999,180,999,999,  1,  2,  3,  4,  5,  6,  7,172,173,170,  8,  9,\n    10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\n    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\n    58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,171, 71, 72,\n    73,181,999,999, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\n    86,999,999,999,999,999,999, 87, 88, 89, 90, 91, 92, 93, 94, 95,\n    96,999,999,999,999,999,999,999, 97, 98, 99,100,101,102,103,104,\n   105,999,106,999,107,108,109,110,111,112,113,114,115,116,117,118,\n   119,120,121,122,123,124,125,126,127,174,182,183,128,129,130,131,\n   999,999,999,999,176,177,178,999,999,999,999,999,132,133,134,135,\n   999,136,137,999,999,999,138,139,999,999,140,141,999,142,143,144,\n   999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,\n   999,145,146,147,148,149,150,151,999,166,167,168,152,153,154,155,\n   999,999,999,999,179,169,999,999,175,999,999,999,999,999,999,999,\n   156,157,158,159,999,999,999,999,160,161,162,163,164,165,999,999),\n\n /********************************************************************/\n /*                                                                  */\n /* OP_TABLE format is as follows:                                   */\n /*                                                                  */\n /*  OP_NAME - 5 characters - the assembler mnemonic (opcode).       */\n /*                                                                  */\n /*  OP_FORMAT - 3 characters - the instruction format (RR,RS,etc).  */\n /*                                                                  */\n /*  OP_AUX - 1 character - an index into a table of op codes for    */\n /*                         the extended op codes (B2, etc.).        */\n /*                         Note that OP_AUX is mutually exclusive   */\n /*                         with all the other fields.               */\n /*                                                                  */\n /*  OP_TYPE - 1 character - if not blank, means the following:      */\n /*                                                                  */\n /*            \"B\" - this is a branch instruction with special       */\n /*                  mnemonics based on condition code (BC, BCR).    */\n /*                                                                  */\n /*            \"C\" - the immediate data in the instruction is        */\n /*                  probably character data and should be           */\n /*                  formatted as such (e.g. for MVI and CLI).       */\n /*                                                                  */\n /*            \"P\" - privileged instruction                          */\n /*                  or                                              */\n /*                  semiprivileged instruction                      */\n /*                                                                  */\n /*  OP_CC   - 1 character - what the instruction does to the        */\n /*                          condition code.  This is used to        */\n /*                          determine what mnemonic to use when     */\n /*                          disassembling a subsequent BC or BCR.   */\n /*                                                                  */\n /*           blank - no effect on condition code.                   */\n /*                                                                  */\n /*            \"A\" - arithmetic (BZ, BM, BP, BO)                     */\n /*                                                                  */\n /*            \"C\" - comparison (BE, BL, BH)                         */\n /*                                                                  */\n /*            \"D\" - affects the condition code but no mnemonics     */\n /*                  are defined.  Includes instructions like BAL    */\n /*                  which go off and cause random code to execute.  */\n /*                                                                  */\n /*            \"Z\" - zero/nonzero (BZ)                               */\n /*                                                                  */\n /*                                                                  */\n /*  OP_SPEC - 1 character - additional information determining if   */\n /*                          this is a valid op code.  If this is    */\n /*                          non-blank, certain fields of the        */\n /*                          instruction are checked for values      */\n /*                          which they must contain for it to be    */\n /*                          valid - otherwise it must be data.      */\n /*                                                                  */\n /* The following conventions apply herein for nibble descriptions:  */\n /*                                                                  */\n /* . - any value from 0-F is valid.                                 */\n /* 0 - the nibble must contain 0.                                   */\n /* E - the nibble must be even.                                     */\n /* D - the nibble must contain 0, 2, 4, or 6 (floating-point reg).  */\n /* Q - the nibble must contain 0 or 4 (extended-precision float).   */\n /*                                                                  */\n /*                                                                  */\n /*   \"C\" - ..0.....  MC                                             */\n /*   \"D\" - ..QQ      AXR, etc.                                      */\n /*   \"E\" - ..DD      ADR, etc.                                      */\n /*   \"F\" - ..D.....  AD, etc.                                       */\n /*   \"G\" - ..Q.....  MXD                                            */\n /*   \"H\" - ..QD      MXDR                                           */\n /*   \"L\" - ..EE....  MVCL, CLCL, CDS                                */\n /*   \"M\" - ..E.....  MR, DR, M, D                                   */\n /*   \"N\" - ....0000  IPK, PTLB, CSCH, HSCH, SAL, RSCH, RCHP, etc.   */\n /*   \"S\" - ..00....  SSM, LPSW, TS, TCH                             */\n /*   \"X\" - ....00.0  IAC, SSAR, EPAR, ESAR, MSTA                    */\n /*   \"Y\" - ....00..  IPTE, IPM, IVSK, PT, ISKE, RRBE, SSKE, etc.    */\n /*   \"1\" - ...0....  SPM, SRL, SLL, SRA, SLA                        */\n /*   \"2\" - ..E0....  SRDL, SLDL, SRDA, SLDA                         */\n /*                                                                  */\n /********************************************************************/\n\n   1 OP_TABLE      based(OP_PTR),\n     2 OP_NAME     char(5),\n     2 OP_FORMAT   char(3),\n     2 OP_AUX      char(1),\n     2 OP_TYPE     char(1),\n     2 OP_CC       char(1),\n     2 OP_SPEC     char(1),\n\n   1 OP_TABLE_ENTRIES static,\n     2 OP_TABLE001 char(12) init('SPM  SPM   1'),\n     2 OP_TABLE002 char(12) init('BALR RR   D '),\n     2 OP_TABLE003 char(12) init('BCTR RR     '),\n     2 OP_TABLE004 char(12) init('BCR  RR  B  '),\n     2 OP_TABLE005 char(12) init('SSK  RR  P  '),\n     2 OP_TABLE006 char(12) init('ISK  RR  P  '),\n     2 OP_TABLE007 char(12) init('SVC  I      '),\n     2 OP_TABLE008 char(12) init('MVCL RR   CL'),\n     2 OP_TABLE009 char(12) init('CLCL RR   CL'),\n     2 OP_TABLE010 char(12) init('LPR  RR   A '),\n     2 OP_TABLE011 char(12) init('LNR  RR   A '),\n     2 OP_TABLE012 char(12) init('LTR  RR   A '),\n     2 OP_TABLE013 char(12) init('LCR  RR   A '),\n     2 OP_TABLE014 char(12) init('NR   RR   Z '),\n     2 OP_TABLE015 char(12) init('CLR  RR   C '),\n     2 OP_TABLE016 char(12) init('OR   RR   Z '),\n     2 OP_TABLE017 char(12) init('XR   RR   Z '),\n     2 OP_TABLE018 char(12) init('LR   RR     '),\n     2 OP_TABLE019 char(12) init('CR   RR   C '),\n     2 OP_TABLE020 char(12) init('AR   RR   A '),\n     2 OP_TABLE021 char(12) init('SR   RR   A '),\n     2 OP_TABLE022 char(12) init('MR   RR    M'),\n     2 OP_TABLE023 char(12) init('DR   RR    M'),\n     2 OP_TABLE024 char(12) init('ALR  RR   D '),\n     2 OP_TABLE025 char(12) init('SLR  RR   D '),\n     2 OP_TABLE026 char(12) init('LPDR RR  FAE'),\n     2 OP_TABLE027 char(12) init('LNDR RR  FAE'),\n     2 OP_TABLE028 char(12) init('LTDR RR  FAE'),\n     2 OP_TABLE029 char(12) init('LCDR RR  FAE'),\n     2 OP_TABLE030 char(12) init('HDR  RR  F E'),\n     2 OP_TABLE031 char(12) init('LRDR RR  F E'),\n     2 OP_TABLE032 char(12) init('MXR  RR  F D'),\n     2 OP_TABLE033 char(12) init('MXDR RR  F H'),\n     2 OP_TABLE034 char(12) init('LDR  RR  F E'),\n     2 OP_TABLE035 char(12) init('CDR  RR  FCE'),\n     2 OP_TABLE036 char(12) init('ADR  RR  FAE'),\n     2 OP_TABLE037 char(12) init('SDR  RR  FAE'),\n     2 OP_TABLE038 char(12) init('MDR  RR  F E'),\n     2 OP_TABLE039 char(12) init('DDR  RR  F E'),\n     2 OP_TABLE040 char(12) init('AWR  RR  FAE'),\n     2 OP_TABLE041 char(12) init('SWR  RR  FAE'),\n     2 OP_TABLE042 char(12) init('LPER RR  FAE'),\n     2 OP_TABLE043 char(12) init('LNER RR  FAE'),\n     2 OP_TABLE044 char(12) init('LTER RR  FAE'),\n     2 OP_TABLE045 char(12) init('LCER RR  FAE'),\n     2 OP_TABLE046 char(12) init('HER  RR  F E'),\n     2 OP_TABLE047 char(12) init('LRER RR  F E'),\n     2 OP_TABLE048 char(12) init('AXR  RR  FAD'),\n     2 OP_TABLE049 char(12) init('SXR  RR  FAD'),\n     2 OP_TABLE050 char(12) init('LER  RR  F E'),\n     2 OP_TABLE051 char(12) init('CER  RR  FCE'),\n     2 OP_TABLE052 char(12) init('AER  RR  FAE'),\n     2 OP_TABLE053 char(12) init('SER  RR  FAE'),\n     2 OP_TABLE054 char(12) init('MER  RR  F E'),\n     2 OP_TABLE055 char(12) init('DER  RR  F E'),\n     2 OP_TABLE056 char(12) init('AUR  RR  FAE'),\n     2 OP_TABLE057 char(12) init('SUR  RR  FAE'),\n     2 OP_TABLE058 char(12) init('STH  RX     '),\n     2 OP_TABLE059 char(12) init('LA   RX     '),\n     2 OP_TABLE060 char(12) init('STC  RX     '),\n     2 OP_TABLE061 char(12) init('IC   RX     '),\n     2 OP_TABLE062 char(12) init('EX   RX   D '),\n     2 OP_TABLE063 char(12) init('BAL  RX   D '),\n     2 OP_TABLE064 char(12) init('BCT  RX     '),\n     2 OP_TABLE065 char(12) init('BC   RX  B  '),\n     2 OP_TABLE066 char(12) init('LH   RX     '),\n     2 OP_TABLE067 char(12) init('CH   RX   C '),\n     2 OP_TABLE068 char(12) init('AH   RX   A '),\n     2 OP_TABLE069 char(12) init('SH   RX   A '),\n     2 OP_TABLE070 char(12) init('MH   RX     '),\n     2 OP_TABLE071 char(12) init('CVD  RX     '),\n     2 OP_TABLE072 char(12) init('CVB  RX     '),\n     2 OP_TABLE073 char(12) init('ST   RX     '),\n     2 OP_TABLE074 char(12) init('N    RX   Z '),\n     2 OP_TABLE075 char(12) init('CL   RX   C '),\n     2 OP_TABLE076 char(12) init('O    RX   Z '),\n     2 OP_TABLE077 char(12) init('X    RX   Z '),\n     2 OP_TABLE078 char(12) init('L    RX     '),\n     2 OP_TABLE079 char(12) init('C    RX   C '),\n     2 OP_TABLE080 char(12) init('A    RX   A '),\n     2 OP_TABLE081 char(12) init('S    RX   A '),\n     2 OP_TABLE082 char(12) init('M    RX    M'),\n     2 OP_TABLE083 char(12) init('D    RX    M'),\n     2 OP_TABLE084 char(12) init('AL   RX   D '),\n     2 OP_TABLE085 char(12) init('SL   RX   D '),\n     2 OP_TABLE086 char(12) init('STD  RX  F F'),\n     2 OP_TABLE087 char(12) init('MXD  RX  F G'),\n     2 OP_TABLE088 char(12) init('LD   RX  F F'),\n     2 OP_TABLE089 char(12) init('CD   RX  FCF'),\n     2 OP_TABLE090 char(12) init('AD   RX  FAF'),\n     2 OP_TABLE091 char(12) init('SD   RX  FAF'),\n     2 OP_TABLE092 char(12) init('MD   RX  F F'),\n     2 OP_TABLE093 char(12) init('DD   RX  F F'),\n     2 OP_TABLE094 char(12) init('AW   RX  FAF'),\n     2 OP_TABLE095 char(12) init('SW   RX  FAF'),\n     2 OP_TABLE096 char(12) init('STE  RX  F F'),\n     2 OP_TABLE097 char(12) init('LE   RX  F F'),\n     2 OP_TABLE098 char(12) init('CE   RX  FCF'),\n     2 OP_TABLE099 char(12) init('AE   RX  FAF'),\n     2 OP_TABLE100 char(12) init('SE   RX  FAF'),\n     2 OP_TABLE101 char(12) init('ME   RX  F F'),\n     2 OP_TABLE102 char(12) init('DE   RX  F F'),\n     2 OP_TABLE103 char(12) init('AU   RX  FAF'),\n     2 OP_TABLE104 char(12) init('SU   RX  FAF'),\n     2 OP_TABLE105 char(12) init('SSM  S   P S'),\n     2 OP_TABLE106 char(12) init('LPSW S   PDS'),\n     2 OP_TABLE107 char(12) init('WRD  SI  P  '),\n     2 OP_TABLE108 char(12) init('RDD  SI  P  '),\n     2 OP_TABLE109 char(12) init('BXH  RS     '),\n     2 OP_TABLE110 char(12) init('BXLE RS     '),\n     2 OP_TABLE111 char(12) init('SRL  RSS  A1'),\n     2 OP_TABLE112 char(12) init('SLL  RSS  A1'),\n     2 OP_TABLE113 char(12) init('SRA  RSS  A1'),\n     2 OP_TABLE114 char(12) init('SLA  RSS  A1'),\n     2 OP_TABLE115 char(12) init('SRDL RSS  A2'),\n     2 OP_TABLE116 char(12) init('SLDL RSS  A2'),\n     2 OP_TABLE117 char(12) init('SRDA RSS  A2'),\n     2 OP_TABLE118 char(12) init('SLDA RSS  A2'),\n     2 OP_TABLE119 char(12) init('STM  RS     '),\n     2 OP_TABLE120 char(12) init('TM   SI   A '),\n     2 OP_TABLE121 char(12) init('MVI  SI  C  '),\n     2 OP_TABLE122 char(12) init('TS   S    DS'),\n     2 OP_TABLE123 char(12) init('NI   SI   Z '),\n     2 OP_TABLE124 char(12) init('CLI  SI  CC '),\n     2 OP_TABLE125 char(12) init('OI   SI   Z '),\n     2 OP_TABLE126 char(12) init('XI   SI   Z '),\n     2 OP_TABLE127 char(12) init('LM   RS     '),\n     2 OP_TABLE128 char(12) init('        1   '), /* 9Cxxxxxx */\n     2 OP_TABLE129 char(12) init('        2   '), /* 9Dxxxxxx */\n     2 OP_TABLE130 char(12) init('        3   '), /* 9Exxxxxx */\n     2 OP_TABLE131 char(12) init('TCH  S   PDS'),\n     2 OP_TABLE132 char(12) init('STNSMSI  P  '),\n     2 OP_TABLE133 char(12) init('STOSMSI  P  '),\n     2 OP_TABLE134 char(12) init('SIGP RS  PD '),\n     2 OP_TABLE135 char(12) init('MC   SI    C'),\n     2 OP_TABLE136 char(12) init('LRA  RX  PD '),\n     2 OP_TABLE137 char(12) init('        4   '), /* B2xxxxxx */\n     2 OP_TABLE138 char(12) init('STCTLRS  P  '),\n     2 OP_TABLE139 char(12) init('LCTL RS  P  '),\n     2 OP_TABLE140 char(12) init('CS   RS   D '),\n     2 OP_TABLE141 char(12) init('CDS  RS   DL'),\n     2 OP_TABLE142 char(12) init('CLM  RS   C '),\n     2 OP_TABLE143 char(12) init('STCM RS     '),\n     2 OP_TABLE144 char(12) init('ICM  RS   A '),\n     2 OP_TABLE145 char(12) init('MVN  SS1    '),\n     2 OP_TABLE146 char(12) init('MVC  SS1    '),\n     2 OP_TABLE147 char(12) init('MVZ  SS1    '),\n     2 OP_TABLE148 char(12) init('NC   SS1  Z '),\n     2 OP_TABLE149 char(12) init('CLC  SS1  C '),\n     2 OP_TABLE150 char(12) init('OC   SS1  Z '),\n     2 OP_TABLE151 char(12) init('XC   SS1  Z '),\n     2 OP_TABLE152 char(12) init('TR   SS1    '),\n     2 OP_TABLE153 char(12) init('TRT  SS1  D '),\n     2 OP_TABLE154 char(12) init('ED   SS1  A '),\n     2 OP_TABLE155 char(12) init('EDMK SS1  A '),\n     2 OP_TABLE156 char(12) init('SRP  SS3  A '),\n     2 OP_TABLE157 char(12) init('MVO  SS2    '),\n     2 OP_TABLE158 char(12) init('PACK SS2    '),\n     2 OP_TABLE159 char(12) init('UNPK SS2    '),\n     2 OP_TABLE160 char(12) init('ZAP  SS2  A '),\n     2 OP_TABLE161 char(12) init('CP   SS2  C '),\n     2 OP_TABLE162 char(12) init('AP   SS2  A '),\n     2 OP_TABLE163 char(12) init('SP   SS2  A '),\n     2 OP_TABLE164 char(12) init('MP   SS2    '),\n     2 OP_TABLE165 char(12) init('DP   SS2    '),\n     2 OP_TABLE166 char(12) init('MVCK SS4  D '),\n     2 OP_TABLE167 char(12) init('MVCP SS4  D '),\n     2 OP_TABLE168 char(12) init('MVCS SS4  D '),\n     2 OP_TABLE169 char(12) init('        5   '), /* E5xxxxxxxxxx */\n     2 OP_TABLE170 char(12) init('BASR RR     '),\n     2 OP_TABLE171 char(12) init('BAS  RX     '),\n     2 OP_TABLE172 char(12) init('BSM  RR   D '),\n     2 OP_TABLE173 char(12) init('BASSMRR   D '),\n     2 OP_TABLE174 char(12) init('TRACERS  P  '),\n     2 OP_TABLE175 char(12) init('MVCINSS1    '),\n     2 OP_TABLE176 char(12) init('        6   '), /* A4xxxxxx */\n     2 OP_TABLE177 char(12) init('        7   '), /* A5xxxxxx */\n     2 OP_TABLE178 char(12) init('        8   '), /* A6xxxxxx */\n     2 OP_TABLE179 char(12) init('        9   '), /* E4xxxxxxxxxx */\n     2 OP_TABLE180 char(12) init('        0   '), /* 01xx */\n     2 OP_TABLE181 char(12) init('LAE  RX     '),\n     2 OP_TABLE182 char(12) init('LAM  RS     '),\n     2 OP_TABLE183 char(12) init('STAM RS     '),\n\n   1 OP_TABLE0 (183) char(12) def OP_TABLE_ENTRIES,\n\n   1 AUX_OP_ARRAY (0:255) char(12) based,\n\n   1 AUX_OP_TABLE0_ENTRIES static, /* for op code 01 */\n     2 AUX_OP0_TABLE00 char(12) init('            '),\n     2 AUX_OP0_TABLE01 char(12) init('PR   N    D '),\n     2 AUX_OP0_TABLE02 char(12) init('UPT  N    D '),\n\n   1 AUX_OP_TABLE0 (0:2) char(12) def AUX_OP_TABLE0_ENTRIES,\n\n   1 AUX_OP_TABLE1_ENTRIES static, /* for op code 9C */\n     2 AUX_OP1_TABLE00  char(12) init('SIO  S   PD '),\n     2 AUX_OP1_TABLE01  char(12) init('SIOF S   PD '),\n\n   1 AUX_OP_TABLE1 (0:1) char(12) def AUX_OP_TABLE1_ENTRIES,\n\n   1 AUX_OP_TABLE2_ENTRIES static, /* for op code 9D */\n     2 AUX_OP1_TABLE00  char(12) init('TIO  S   PD '),\n     2 AUX_OP1_TABLE01  char(12) init('CLRIOS   PD '),\n\n   1 AUX_OP_TABLE2 (0:1) char(12) def AUX_OP_TABLE2_ENTRIES,\n\n   1 AUX_OP_TABLE3_ENTRIES static, /* for op code 9E */\n     2 AUX_OP1_TABLE00  char(12) init('HIO  S   PD '),\n     2 AUX_OP1_TABLE01  char(12) init('HDV  S   PD '),\n\n   1 AUX_OP_TABLE3 (0:1) char(12) def AUX_OP_TABLE3_ENTRIES,\n\n   1 AUX_OP_TABLE4_ENTRIES static, /* for op code B2 */\n     2 AUX_OP1_TABLE00  char(12) init('CONCSS   P  '),\n     2 AUX_OP1_TABLE01  char(12) init('DISCSS   P  '),\n     2 AUX_OP1_TABLE02  char(12) init('STIDPS   P  '),\n     2 AUX_OP1_TABLE03  char(12) init('STIDCS   PD '),\n     2 AUX_OP1_TABLE04  char(12) init('SCK  S   PD '),\n     2 AUX_OP1_TABLE05  char(12) init('STCK S      '),\n     2 AUX_OP1_TABLE06  char(12) init('SCKC S   P  '),\n     2 AUX_OP1_TABLE07  char(12) init('STCKCS   P  '),\n     2 AUX_OP1_TABLE08  char(12) init('SPT  S   P  '),\n     2 AUX_OP1_TABLE09  char(12) init('STPT S   P  '),\n     2 AUX_OP1_TABLE0A  char(12) init('SPKA S   P  '),\n     2 AUX_OP1_TABLE0B  char(12) init('IPK  N   P N'),\n     2 AUX_OP1_TABLE0C  char(12) init('            '),\n     2 AUX_OP1_TABLE0D  char(12) init('PTLB N   P N'),\n     2 AUX_OP1_TABLE0E  char(12) init('            '),\n     2 AUX_OP1_TABLE0F  char(12) init('            '),\n     2 AUX_OP1_TABLE10  char(12) init('SPX  S   P  '),\n     2 AUX_OP1_TABLE11  char(12) init('STPX S   P  '),\n     2 AUX_OP1_TABLE12  char(12) init('STAP S   P  '),\n     2 AUX_OP1_TABLE13  char(12) init('RRB  S   PD '),\n     2 AUX_OP1_TABLE14  char(12) init('            '),\n     2 AUX_OP1_TABLE15  char(12) init('            '),\n     2 AUX_OP1_TABLE16  char(12) init('            '),\n     2 AUX_OP1_TABLE17  char(12) init('            '),\n     2 AUX_OP1_TABLE18  char(12) init('PC   S      '),\n     2 AUX_OP1_TABLE19  char(12) init('SAC  S      '),\n     2 AUX_OP1_TABLE1A  char(12) init('CFC  S      '),\n     2 AUX_OP1_TABLE1B  char(12) init('            '),\n     2 AUX_OP1_TABLE1C  char(12) init('            '),\n     2 AUX_OP1_TABLE1D  char(12) init('            '),\n     2 AUX_OP1_TABLE1E  char(12) init('            '),\n     2 AUX_OP1_TABLE1F  char(12) init('            '),\n     2 AUX_OP1_TABLE20  char(12) init('            '),\n     2 AUX_OP1_TABLE21  char(12) init('IPTE RR2   Y'),\n     2 AUX_OP1_TABLE22  char(12) init('IPM  RR1   Y'),\n     2 AUX_OP1_TABLE23  char(12) init('IVSK RR2   Y'),\n     2 AUX_OP1_TABLE24  char(12) init('IAC  RR1  DX'),\n     2 AUX_OP1_TABLE25  char(12) init('SSAR RR1   X'),\n     2 AUX_OP1_TABLE26  char(12) init('EPAR RR1   X'),\n     2 AUX_OP1_TABLE27  char(12) init('ESAR RR1   X'),\n     2 AUX_OP1_TABLE28  char(12) init('PT   RR2   Y'),\n     2 AUX_OP1_TABLE29  char(12) init('ISKE RR2   Y'),\n     2 AUX_OP1_TABLE2A  char(12) init('RRBE RR2 PDY'),\n     2 AUX_OP1_TABLE2B  char(12) init('SSKE RR2 P Y'),\n     2 AUX_OP1_TABLE2C  char(12) init('TB   RR2 PDY'),\n     2 AUX_OP1_TABLE2D  char(12) init('DXR  RR2 F Y'),\n     2 AUX_OP1_TABLE2E  char(12) init('            '),\n     2 AUX_OP1_TABLE2F  char(12) init('            '),\n     2 AUX_OP1_TABLE30  char(12) init('CSCH N   PDN'),\n     2 AUX_OP1_TABLE31  char(12) init('HSCH N   PDN'),\n     2 AUX_OP1_TABLE32  char(12) init('MSCH S   PD '),\n     2 AUX_OP1_TABLE33  char(12) init('SSCH S   PD '),\n     2 AUX_OP1_TABLE34  char(12) init('STSCHS   PD '),\n     2 AUX_OP1_TABLE35  char(12) init('TSCH S   PD '),\n     2 AUX_OP1_TABLE36  char(12) init('TPI  S   PD '),\n     2 AUX_OP1_TABLE37  char(12) init('SAL  N   P N'),\n     2 AUX_OP1_TABLE38  char(12) init('RSCH N   PDN'),\n     2 AUX_OP1_TABLE39  char(12) init('STCRWS   PD '),\n     2 AUX_OP1_TABLE3A  char(12) init('STCPSS   P  '),\n     2 AUX_OP1_TABLE3B  char(12) init('RCHP N   PDN'),\n     2 AUX_OP1_TABLE3C  char(12) init('SCHM N   P N'),\n     2 AUX_OP1_TABLE3D  char(12) init('            '),\n     2 AUX_OP1_TABLE3E  char(12) init('            '),\n     2 AUX_OP1_TABLE3F  char(12) init('            '),\n     2 AUX_OP1_TABLE40  char(12) init('BAKR RR2  DY'),\n     2 AUX_OP1_TABLE41  char(12) init('            '),\n     2 AUX_OP1_TABLE42  char(12) init('            '),\n     2 AUX_OP1_TABLE43  char(12) init('            '),\n     2 AUX_OP1_TABLE44  char(12) init('            '),\n     2 AUX_OP1_TABLE45  char(12) init('            '),\n     2 AUX_OP1_TABLE46  char(12) init('STURARR2   Y'),\n     2 AUX_OP1_TABLE47  char(12) init('MSTA RR1   X'),\n     2 AUX_OP1_TABLE48  char(12) init('PALB N     N'),\n     2 AUX_OP1_TABLE49  char(12) init('EREG RR2   Y'),\n     2 AUX_OP1_TABLE4A  char(12) init('ESTA RR2  DY'),\n     2 AUX_OP1_TABLE4B  char(12) init('LURA RR2   Y'),\n     2 AUX_OP1_TABLE4C  char(12) init('TAR  RR2  DY'),\n     2 AUX_OP1_TABLE4D  char(12) init('CPYA RR2   Y'),\n     2 AUX_OP1_TABLE4E  char(12) init('SAR  RR2   Y'),\n     2 AUX_OP1_TABLE4F  char(12) init('EAR  RR2   Y'),\n\n   1 AUX_OP_TABLE4 (0:60) char(12) def AUX_OP_TABLE4_ENTRIES,\n\n   1 AUX_OP_TABLE5_ENTRIES static, /* for op code E5 */\n     2 AUX_OP5_TABLE00  char(12) init('LASP SSE PD '),\n     2 AUX_OP5_TABLE01  char(12) init('TPROTSSE PD '),\n     2 AUX_OP5_TABLE02  char(12) init('            '),\n     2 AUX_OP5_TABLE03  char(12) init('            '),\n     2 AUX_OP5_TABLE04  char(12) init('            '),\n     2 AUX_OP5_TABLE05  char(12) init('            '),\n     2 AUX_OP5_TABLE06  char(12) init('            '),\n     2 AUX_OP5_TABLE07  char(12) init('            '),\n     2 AUX_OP5_TABLE08  char(12) init('            '),\n     2 AUX_OP5_TABLE09  char(12) init('            '),\n     2 AUX_OP5_TABLE0A  char(12) init('            '),\n     2 AUX_OP5_TABLE0B  char(12) init('            '),\n     2 AUX_OP5_TABLE0C  char(12) init('            '),\n     2 AUX_OP5_TABLE0D  char(12) init('            '),\n     2 AUX_OP5_TABLE0E  char(12) init('MVCSKSSE    '),\n     2 AUX_OP5_TABLE0F  char(12) init('MVCDKSSE    '),\n\n   1 AUX_OP_TABLE5 (0:15) char(12) def AUX_OP_TABLE5_ENTRIES,\n\n   1 AUX_OP_TABLE6_ENTRIES static, /* for op code A4 */\n     2 AUX_OP6_TABLE00 char(12) init('VAE  VST    '),\n     2 AUX_OP6_TABLE01 char(12) init('VSE  VST    '),\n     2 AUX_OP6_TABLE02 char(12) init('VME  VST    '),\n     2 AUX_OP6_TABLE03 char(12) init('VDE  VST    '),\n     2 AUX_OP6_TABLE04 char(12) init('VMAE VST    '),\n     2 AUX_OP6_TABLE05 char(12) init('VMSE VST    '),\n     2 AUX_OP6_TABLE06 char(12) init('VMCE VST    '),\n     2 AUX_OP6_TABLE07 char(12) init('VACE VS3    '),\n     2 AUX_OP6_TABLE08 char(12) init('VCE  VST    '),\n     2 AUX_OP6_TABLE09 char(12) init('VL   VS3    '),\n     2 AUX_OP6_TABLE0A char(12) init('VLM  VS3    '), /* also VLME  */\n     2 AUX_OP6_TABLE0B char(12) init('VLY  VS3    '), /* also VLYE  */\n     2 AUX_OP6_TABLE0C char(12) init('            '),\n     2 AUX_OP6_TABLE0D char(12) init('VST  VS3    '), /* also VSTE  */\n     2 AUX_OP6_TABLE0E char(12) init('VSTM VS3    '), /* also VSTME */\n     2 AUX_OP6_TABLE0F char(12) init('VSTK VS3    '), /* also VSTKE */\n     2 AUX_OP6_TABLE10 char(12) init('VAD  VST    '),\n     2 AUX_OP6_TABLE11 char(12) init('VSD  VST    '),\n     2 AUX_OP6_TABLE12 char(12) init('VMD  VST    '),\n     2 AUX_OP6_TABLE13 char(12) init('VDD  VST    '),\n     2 AUX_OP6_TABLE14 char(12) init('VMAD VST    '),\n     2 AUX_OP6_TABLE15 char(12) init('VMSD VST    '),\n     2 AUX_OP6_TABLE16 char(12) init('VMCD VST    '),\n     2 AUX_OP6_TABLE17 char(12) init('VACD VS3    '),\n     2 AUX_OP6_TABLE18 char(12) init('VCD  VST    '),\n     2 AUX_OP6_TABLE19 char(12) init('VLD  VS3    '),\n     2 AUX_OP6_TABLE1A char(12) init('VLMD VS3    '),\n     2 AUX_OP6_TABLE1B char(12) init('VLYD VS3    '),\n     2 AUX_OP6_TABLE1C char(12) init('            '),\n     2 AUX_OP6_TABLE1D char(12) init('VSTD VS3    '),\n     2 AUX_OP6_TABLE1E char(12) init('VSTMDVS3    '),\n     2 AUX_OP6_TABLE1F char(12) init('VSTKDVS3    '),\n     2 AUX_OP6_TABLE20 char(12) init('VA   VST    '),\n     2 AUX_OP6_TABLE21 char(12) init('VS   VST    '),\n     2 AUX_OP6_TABLE22 char(12) init('VM   VST    '),\n     2 AUX_OP6_TABLE23 char(12) init('            '),\n     2 AUX_OP6_TABLE24 char(12) init('VN   VST    '),\n     2 AUX_OP6_TABLE25 char(12) init('VO   VST    '),\n     2 AUX_OP6_TABLE26 char(12) init('VX   VST    '),\n     2 AUX_OP6_TABLE27 char(12) init('            '),\n     2 AUX_OP6_TABLE28 char(12) init('VC   VST    '),\n     2 AUX_OP6_TABLE29 char(12) init('VLH  VS3    '),\n     2 AUX_OP6_TABLE2A char(12) init('VLINTVS3    '),\n     2 AUX_OP6_TABLE2B char(12) init('            '),\n     2 AUX_OP6_TABLE2C char(12) init('            '),\n     2 AUX_OP6_TABLE2D char(12) init('VSTH VS3    '),\n     2 AUX_OP6_TABLE2E char(12) init('            '),\n     2 AUX_OP6_TABLE2F char(12) init('            '),\n     2 AUX_OP6_TABLE30 char(12) init('            '),\n     2 AUX_OP6_TABLE31 char(12) init('            '),\n     2 AUX_OP6_TABLE32 char(12) init('            '),\n     2 AUX_OP6_TABLE33 char(12) init('            '),\n     2 AUX_OP6_TABLE34 char(12) init('            '),\n     2 AUX_OP6_TABLE35 char(12) init('            '),\n     2 AUX_OP6_TABLE36 char(12) init('            '),\n     2 AUX_OP6_TABLE37 char(12) init('            '),\n     2 AUX_OP6_TABLE38 char(12) init('            '),\n     2 AUX_OP6_TABLE39 char(12) init('            '),\n     2 AUX_OP6_TABLE3A char(12) init('            '),\n     2 AUX_OP6_TABLE3B char(12) init('            '),\n     2 AUX_OP6_TABLE3C char(12) init('            '),\n     2 AUX_OP6_TABLE3D char(12) init('            '),\n     2 AUX_OP6_TABLE3E char(12) init('            '),\n     2 AUX_OP6_TABLE3F char(12) init('            '),\n     2 AUX_OP6_TABLE40 char(12) init('            '),\n     2 AUX_OP6_TABLE41 char(12) init('            '),\n     2 AUX_OP6_TABLE42 char(12) init('            '),\n     2 AUX_OP6_TABLE43 char(12) init('            '),\n     2 AUX_OP6_TABLE44 char(12) init('            '),\n     2 AUX_OP6_TABLE45 char(12) init('            '),\n     2 AUX_OP6_TABLE46 char(12) init('            '),\n     2 AUX_OP6_TABLE47 char(12) init('            '),\n     2 AUX_OP6_TABLE48 char(12) init('            '),\n     2 AUX_OP6_TABLE49 char(12) init('            '),\n     2 AUX_OP6_TABLE4A char(12) init('            '),\n     2 AUX_OP6_TABLE4B char(12) init('            '),\n     2 AUX_OP6_TABLE4C char(12) init('            '),\n     2 AUX_OP6_TABLE4D char(12) init('            '),\n     2 AUX_OP6_TABLE4E char(12) init('            '),\n     2 AUX_OP6_TABLE4F char(12) init('            '),\n     2 AUX_OP6_TABLE50 char(12) init('            '),\n     2 AUX_OP6_TABLE51 char(12) init('            '),\n     2 AUX_OP6_TABLE52 char(12) init('            '),\n     2 AUX_OP6_TABLE53 char(12) init('            '),\n     2 AUX_OP6_TABLE54 char(12) init('            '),\n     2 AUX_OP6_TABLE55 char(12) init('            '),\n     2 AUX_OP6_TABLE56 char(12) init('            '),\n     2 AUX_OP6_TABLE57 char(12) init('            '),\n     2 AUX_OP6_TABLE58 char(12) init('            '),\n     2 AUX_OP6_TABLE59 char(12) init('            '),\n     2 AUX_OP6_TABLE5A char(12) init('            '),\n     2 AUX_OP6_TABLE5B char(12) init('            '),\n     2 AUX_OP6_TABLE5C char(12) init('            '),\n     2 AUX_OP6_TABLE5D char(12) init('            '),\n     2 AUX_OP6_TABLE5E char(12) init('            '),\n     2 AUX_OP6_TABLE5F char(12) init('            '),\n     2 AUX_OP6_TABLE60 char(12) init('            '),\n     2 AUX_OP6_TABLE61 char(12) init('            '),\n     2 AUX_OP6_TABLE62 char(12) init('            '),\n     2 AUX_OP6_TABLE63 char(12) init('            '),\n     2 AUX_OP6_TABLE64 char(12) init('            '),\n     2 AUX_OP6_TABLE65 char(12) init('            '),\n     2 AUX_OP6_TABLE66 char(12) init('            '),\n     2 AUX_OP6_TABLE67 char(12) init('            '),\n     2 AUX_OP6_TABLE68 char(12) init('            '),\n     2 AUX_OP6_TABLE69 char(12) init('            '),\n     2 AUX_OP6_TABLE6A char(12) init('            '),\n     2 AUX_OP6_TABLE6B char(12) init('            '),\n     2 AUX_OP6_TABLE6C char(12) init('            '),\n     2 AUX_OP6_TABLE6D char(12) init('            '),\n     2 AUX_OP6_TABLE6E char(12) init('            '),\n     2 AUX_OP6_TABLE6F char(12) init('            '),\n     2 AUX_OP6_TABLE70 char(12) init('            '),\n     2 AUX_OP6_TABLE71 char(12) init('            '),\n     2 AUX_OP6_TABLE72 char(12) init('            '),\n     2 AUX_OP6_TABLE73 char(12) init('            '),\n     2 AUX_OP6_TABLE74 char(12) init('            '),\n     2 AUX_OP6_TABLE75 char(12) init('            '),\n     2 AUX_OP6_TABLE76 char(12) init('            '),\n     2 AUX_OP6_TABLE77 char(12) init('            '),\n     2 AUX_OP6_TABLE78 char(12) init('            '),\n     2 AUX_OP6_TABLE79 char(12) init('            '),\n     2 AUX_OP6_TABLE7A char(12) init('            '),\n     2 AUX_OP6_TABLE7B char(12) init('            '),\n     2 AUX_OP6_TABLE7C char(12) init('            '),\n     2 AUX_OP6_TABLE7D char(12) init('            '),\n     2 AUX_OP6_TABLE7E char(12) init('            '),\n     2 AUX_OP6_TABLE7F char(12) init('            '),\n     2 AUX_OP6_TABLE80 char(12) init('VAES QST    '),\n     2 AUX_OP6_TABLE81 char(12) init('VSES QST    '),\n     2 AUX_OP6_TABLE82 char(12) init('VMES QST    '),\n     2 AUX_OP6_TABLE83 char(12) init('VDES QST    '),\n     2 AUX_OP6_TABLE84 char(12) init('VMAESQST    '),\n     2 AUX_OP6_TABLE85 char(12) init('VMSESQST    '),\n     2 AUX_OP6_TABLE86 char(12) init('            '),\n     2 AUX_OP6_TABLE87 char(12) init('            '),\n     2 AUX_OP6_TABLE88 char(12) init('VCES QST    '),\n     2 AUX_OP6_TABLE89 char(12) init('            '),\n     2 AUX_OP6_TABLE8A char(12) init('            '),\n     2 AUX_OP6_TABLE8B char(12) init('            '),\n     2 AUX_OP6_TABLE8C char(12) init('            '),\n     2 AUX_OP6_TABLE8D char(12) init('            '),\n     2 AUX_OP6_TABLE8E char(12) init('            '),\n     2 AUX_OP6_TABLE8F char(12) init('            '),\n     2 AUX_OP6_TABLE90 char(12) init('VADS QST    '),\n     2 AUX_OP6_TABLE91 char(12) init('VSDS QST    '),\n     2 AUX_OP6_TABLE92 char(12) init('VMDS QST    '),\n     2 AUX_OP6_TABLE93 char(12) init('VDDS QST    '),\n     2 AUX_OP6_TABLE94 char(12) init('VMADSQST    '),\n     2 AUX_OP6_TABLE95 char(12) init('VMSDSQST    '),\n     2 AUX_OP6_TABLE96 char(12) init('            '),\n     2 AUX_OP6_TABLE97 char(12) init('            '),\n     2 AUX_OP6_TABLE98 char(12) init('VCDS QST    '),\n     2 AUX_OP6_TABLE99 char(12) init('            '),\n     2 AUX_OP6_TABLE9A char(12) init('            '),\n     2 AUX_OP6_TABLE9B char(12) init('            '),\n     2 AUX_OP6_TABLE9C char(12) init('            '),\n     2 AUX_OP6_TABLE9D char(12) init('            '),\n     2 AUX_OP6_TABLE9E char(12) init('            '),\n     2 AUX_OP6_TABLE9F char(12) init('            '),\n     2 AUX_OP6_TABLEA0 char(12) init('VAS  QST    '),\n     2 AUX_OP6_TABLEA1 char(12) init('VSS  QST    '),\n     2 AUX_OP6_TABLEA2 char(12) init('VMS  QST    '),\n     2 AUX_OP6_TABLEA3 char(12) init('            '),\n     2 AUX_OP6_TABLEA4 char(12) init('VNS  QST    '),\n     2 AUX_OP6_TABLEA5 char(12) init('VOS  QST    '),\n     2 AUX_OP6_TABLEA6 char(12) init('VXS  QST    '),\n     2 AUX_OP6_TABLEA7 char(12) init('            '),\n     2 AUX_OP6_TABLEA8 char(12) init('VCS  QST    '),\n\n   1 AUX_OP_TABLE6 (0:168) char(12) def AUX_OP_TABLE6_ENTRIES,\n\n   1 AUX_OP_TABLE7_ENTRIES static, /* for op code A5 */\n     2 AUX_OP7_TABLE00 char(12) init('VAER VV     '),\n     2 AUX_OP7_TABLE01 char(12) init('VSER VV     '),\n     2 AUX_OP7_TABLE02 char(12) init('VMER VV     '),\n     2 AUX_OP7_TABLE03 char(12) init('VDER VV     '),\n     2 AUX_OP7_TABLE04 char(12) init('            '),\n     2 AUX_OP7_TABLE05 char(12) init('            '),\n     2 AUX_OP7_TABLE06 char(12) init('VMCERVV     '),\n     2 AUX_OP7_TABLE07 char(12) init('VACERVV2    '),\n     2 AUX_OP7_TABLE08 char(12) init('VCER VV     '),\n     2 AUX_OP7_TABLE09 char(12) init('VLR  VV2    '), /* also VLER  */\n     2 AUX_OP7_TABLE0A char(12) init('VLMR VV2    '), /* also VLMER */\n     2 AUX_OP7_TABLE0B char(12) init('VLZR VV1    '), /* also VLZER */\n     2 AUX_OP7_TABLE0C char(12) init('            '),\n     2 AUX_OP7_TABLE0D char(12) init('            '),\n     2 AUX_OP7_TABLE0E char(12) init('            '),\n     2 AUX_OP7_TABLE0F char(12) init('            '),\n     2 AUX_OP7_TABLE10 char(12) init('VADR VV     '),\n     2 AUX_OP7_TABLE11 char(12) init('VSDR VV     '),\n     2 AUX_OP7_TABLE12 char(12) init('VMDR VV     '),\n     2 AUX_OP7_TABLE13 char(12) init('VDDR VV     '),\n     2 AUX_OP7_TABLE14 char(12) init('            '),\n     2 AUX_OP7_TABLE15 char(12) init('            '),\n     2 AUX_OP7_TABLE16 char(12) init('VMCDRVV     '),\n     2 AUX_OP7_TABLE17 char(12) init('VACDRVV2    '),\n     2 AUX_OP7_TABLE18 char(12) init('VCDR VV     '),\n     2 AUX_OP7_TABLE19 char(12) init('VLDR VV2    '),\n     2 AUX_OP7_TABLE1A char(12) init('VLMDRVV2    '),\n     2 AUX_OP7_TABLE1B char(12) init('VLZDRVV1    '),\n     2 AUX_OP7_TABLE1C char(12) init('            '),\n     2 AUX_OP7_TABLE1D char(12) init('            '),\n     2 AUX_OP7_TABLE1E char(12) init('            '),\n     2 AUX_OP7_TABLE1F char(12) init('            '),\n     2 AUX_OP7_TABLE20 char(12) init('VAR  VV     '),\n     2 AUX_OP7_TABLE21 char(12) init('VSR  VV     '),\n     2 AUX_OP7_TABLE22 char(12) init('VMR  VV     '),\n     2 AUX_OP7_TABLE23 char(12) init('            '),\n     2 AUX_OP7_TABLE24 char(12) init('VNR  VV     '),\n     2 AUX_OP7_TABLE25 char(12) init('VOR  VV     '),\n     2 AUX_OP7_TABLE26 char(12) init('VXR  VV     '),\n     2 AUX_OP7_TABLE27 char(12) init('            '),\n     2 AUX_OP7_TABLE28 char(12) init('VCR  VV     '),\n     2 AUX_OP7_TABLE29 char(12) init('            '),\n     2 AUX_OP7_TABLE2A char(12) init('            '),\n     2 AUX_OP7_TABLE2B char(12) init('            '),\n     2 AUX_OP7_TABLE2C char(12) init('            '),\n     2 AUX_OP7_TABLE2D char(12) init('            '),\n     2 AUX_OP7_TABLE2E char(12) init('            '),\n     2 AUX_OP7_TABLE2F char(12) init('            '),\n     2 AUX_OP7_TABLE30 char(12) init('            '),\n     2 AUX_OP7_TABLE31 char(12) init('            '),\n     2 AUX_OP7_TABLE32 char(12) init('            '),\n     2 AUX_OP7_TABLE33 char(12) init('            '),\n     2 AUX_OP7_TABLE34 char(12) init('            '),\n     2 AUX_OP7_TABLE35 char(12) init('            '),\n     2 AUX_OP7_TABLE36 char(12) init('            '),\n     2 AUX_OP7_TABLE37 char(12) init('            '),\n     2 AUX_OP7_TABLE38 char(12) init('            '),\n     2 AUX_OP7_TABLE39 char(12) init('            '),\n     2 AUX_OP7_TABLE3A char(12) init('            '),\n     2 AUX_OP7_TABLE3B char(12) init('            '),\n     2 AUX_OP7_TABLE3C char(12) init('            '),\n     2 AUX_OP7_TABLE3D char(12) init('            '),\n     2 AUX_OP7_TABLE3E char(12) init('            '),\n     2 AUX_OP7_TABLE3F char(12) init('            '),\n     2 AUX_OP7_TABLE40 char(12) init('VLPERVV2    '),\n     2 AUX_OP7_TABLE41 char(12) init('VLNERVV2    '),\n     2 AUX_OP7_TABLE42 char(12) init('VLCERVV2    '),\n     2 AUX_OP7_TABLE43 char(12) init('            '),\n     2 AUX_OP7_TABLE44 char(12) init('            '),\n     2 AUX_OP7_TABLE45 char(12) init('            '),\n     2 AUX_OP7_TABLE46 char(12) init('            '),\n     2 AUX_OP7_TABLE47 char(12) init('            '),\n     2 AUX_OP7_TABLE48 char(12) init('            '),\n     2 AUX_OP7_TABLE49 char(12) init('            '),\n     2 AUX_OP7_TABLE4A char(12) init('            '),\n     2 AUX_OP7_TABLE4B char(12) init('            '),\n     2 AUX_OP7_TABLE4C char(12) init('            '),\n     2 AUX_OP7_TABLE4D char(12) init('            '),\n     2 AUX_OP7_TABLE4E char(12) init('            '),\n     2 AUX_OP7_TABLE4F char(12) init('            '),\n     2 AUX_OP7_TABLE50 char(12) init('VLPDRVV2    '),\n     2 AUX_OP7_TABLE51 char(12) init('VLNDRVV2    '),\n     2 AUX_OP7_TABLE52 char(12) init('VLCDRVV2    '),\n     2 AUX_OP7_TABLE53 char(12) init('            '),\n     2 AUX_OP7_TABLE54 char(12) init('            '),\n     2 AUX_OP7_TABLE55 char(12) init('            '),\n     2 AUX_OP7_TABLE56 char(12) init('            '),\n     2 AUX_OP7_TABLE57 char(12) init('            '),\n     2 AUX_OP7_TABLE58 char(12) init('            '),\n     2 AUX_OP7_TABLE59 char(12) init('            '),\n     2 AUX_OP7_TABLE5A char(12) init('            '),\n     2 AUX_OP7_TABLE5B char(12) init('            '),\n     2 AUX_OP7_TABLE5C char(12) init('            '),\n     2 AUX_OP7_TABLE5D char(12) init('            '),\n     2 AUX_OP7_TABLE5E char(12) init('            '),\n     2 AUX_OP7_TABLE5F char(12) init('            '),\n     2 AUX_OP7_TABLE60 char(12) init('VLPR VV2    '),\n     2 AUX_OP7_TABLE61 char(12) init('VLNR VV2    '),\n     2 AUX_OP7_TABLE62 char(12) init('VLCR VV2    '),\n     2 AUX_OP7_TABLE63 char(12) init('            '),\n     2 AUX_OP7_TABLE64 char(12) init('            '),\n     2 AUX_OP7_TABLE65 char(12) init('            '),\n     2 AUX_OP7_TABLE66 char(12) init('            '),\n     2 AUX_OP7_TABLE67 char(12) init('            '),\n     2 AUX_OP7_TABLE68 char(12) init('            '),\n     2 AUX_OP7_TABLE69 char(12) init('            '),\n     2 AUX_OP7_TABLE6A char(12) init('            '),\n     2 AUX_OP7_TABLE6B char(12) init('            '),\n     2 AUX_OP7_TABLE6C char(12) init('            '),\n     2 AUX_OP7_TABLE6D char(12) init('            '),\n     2 AUX_OP7_TABLE6E char(12) init('            '),\n     2 AUX_OP7_TABLE6F char(12) init('            '),\n     2 AUX_OP7_TABLE70 char(12) init('            '),\n     2 AUX_OP7_TABLE71 char(12) init('            '),\n     2 AUX_OP7_TABLE72 char(12) init('            '),\n     2 AUX_OP7_TABLE73 char(12) init('            '),\n     2 AUX_OP7_TABLE74 char(12) init('            '),\n     2 AUX_OP7_TABLE75 char(12) init('            '),\n     2 AUX_OP7_TABLE76 char(12) init('            '),\n     2 AUX_OP7_TABLE77 char(12) init('            '),\n     2 AUX_OP7_TABLE78 char(12) init('            '),\n     2 AUX_OP7_TABLE79 char(12) init('            '),\n     2 AUX_OP7_TABLE7A char(12) init('            '),\n     2 AUX_OP7_TABLE7B char(12) init('            '),\n     2 AUX_OP7_TABLE7C char(12) init('            '),\n     2 AUX_OP7_TABLE7D char(12) init('            '),\n     2 AUX_OP7_TABLE7E char(12) init('            '),\n     2 AUX_OP7_TABLE7F char(12) init('            '),\n     2 AUX_OP7_TABLE80 char(12) init('VAEQ QV     '),\n     2 AUX_OP7_TABLE81 char(12) init('VSEQ QV     '),\n     2 AUX_OP7_TABLE82 char(12) init('VMEQ QV     '),\n     2 AUX_OP7_TABLE83 char(12) init('VDEQ QV     '),\n     2 AUX_OP7_TABLE84 char(12) init('VMAEQQV     '),\n     2 AUX_OP7_TABLE85 char(12) init('VMSEQQV     '),\n     2 AUX_OP7_TABLE86 char(12) init('            '),\n     2 AUX_OP7_TABLE87 char(12) init('            '),\n     2 AUX_OP7_TABLE88 char(12) init('VCEQ QV     '),\n     2 AUX_OP7_TABLE89 char(12) init('VLEQ QV2    '),\n     2 AUX_OP7_TABLE8A char(12) init('VLMEQQV2    '),\n     2 AUX_OP7_TABLE8B char(12) init('            '),\n     2 AUX_OP7_TABLE8C char(12) init('            '),\n     2 AUX_OP7_TABLE8D char(12) init('            '),\n     2 AUX_OP7_TABLE8E char(12) init('            '),\n     2 AUX_OP7_TABLE8F char(12) init('            '),\n     2 AUX_OP7_TABLE90 char(12) init('VADQ QV     '),\n     2 AUX_OP7_TABLE91 char(12) init('VSDQ QV     '),\n     2 AUX_OP7_TABLE92 char(12) init('VMDQ QV     '),\n     2 AUX_OP7_TABLE93 char(12) init('VDDQ QV     '),\n     2 AUX_OP7_TABLE94 char(12) init('VMADQQV     '),\n     2 AUX_OP7_TABLE95 char(12) init('VMSDQQV     '),\n     2 AUX_OP7_TABLE96 char(12) init('            '),\n     2 AUX_OP7_TABLE97 char(12) init('            '),\n     2 AUX_OP7_TABLE98 char(12) init('VCDQ QV     '),\n     2 AUX_OP7_TABLE99 char(12) init('VLDQ QV2    '),\n     2 AUX_OP7_TABLE9A char(12) init('VLMDQQV2    '),\n     2 AUX_OP7_TABLE9B char(12) init('            '),\n     2 AUX_OP7_TABLE9C char(12) init('            '),\n     2 AUX_OP7_TABLE9D char(12) init('            '),\n     2 AUX_OP7_TABLE9E char(12) init('            '),\n     2 AUX_OP7_TABLE9F char(12) init('            '),\n     2 AUX_OP7_TABLEA0 char(12) init('VAQ  QV     '),\n     2 AUX_OP7_TABLEA1 char(12) init('VSQ  QV     '),\n     2 AUX_OP7_TABLEA2 char(12) init('VMQ  QV     '),\n     2 AUX_OP7_TABLEA3 char(12) init('            '),\n     2 AUX_OP7_TABLEA4 char(12) init('VNQ  QV     '),\n     2 AUX_OP7_TABLEA5 char(12) init('VOQ  QV     '),\n     2 AUX_OP7_TABLEA6 char(12) init('VXQ  QV     '),\n     2 AUX_OP7_TABLEA7 char(12) init('            '),\n     2 AUX_OP7_TABLEA8 char(12) init('VCQ  QV     '),\n     2 AUX_OP7_TABLEA9 char(12) init('VLQ  QV2    '),\n     2 AUX_OP7_TABLEAA char(12) init('VLMQ QV2    '),\n\n   1 AUX_OP_TABLE7 (0:170) char(12) def AUX_OP_TABLE7_ENTRIES,\n\n   1 AUX_OP_TABLE8_ENTRIES static, /* for op code A6 */\n     2 AUX_OP8_TABLE00 char(12) init('VMXSEVR     '),\n     2 AUX_OP8_TABLE01 char(12) init('VMNSEVR     '),\n     2 AUX_OP8_TABLE02 char(12) init('VMXAEVR     '),\n     2 AUX_OP8_TABLE03 char(12) init('            '),\n     2 AUX_OP8_TABLE04 char(12) init('            '),\n     2 AUX_OP8_TABLE05 char(12) init('            '),\n     2 AUX_OP8_TABLE06 char(12) init('            '),\n     2 AUX_OP8_TABLE07 char(12) init('            '),\n     2 AUX_OP8_TABLE08 char(12) init('VLELEVR     '),\n     2 AUX_OP8_TABLE09 char(12) init('VXELEVR     '),\n     2 AUX_OP8_TABLE0A char(12) init('            '),\n     2 AUX_OP8_TABLE0B char(12) init('            '),\n     2 AUX_OP8_TABLE0C char(12) init('            '),\n     2 AUX_OP8_TABLE0D char(12) init('            '),\n     2 AUX_OP8_TABLE0E char(12) init('            '),\n     2 AUX_OP8_TABLE0F char(12) init('            '),\n     2 AUX_OP8_TABLE10 char(12) init('VMXSDVR     '),\n     2 AUX_OP8_TABLE11 char(12) init('VMNSDVR     '),\n     2 AUX_OP8_TABLE12 char(12) init('VMXADVR     '),\n     2 AUX_OP8_TABLE13 char(12) init('            '),\n     2 AUX_OP8_TABLE14 char(12) init('            '),\n     2 AUX_OP8_TABLE15 char(12) init('            '),\n     2 AUX_OP8_TABLE16 char(12) init('            '),\n     2 AUX_OP8_TABLE17 char(12) init('            '),\n     2 AUX_OP8_TABLE18 char(12) init('VLELDVR     '),\n     2 AUX_OP8_TABLE19 char(12) init('VXELDVR     '),\n     2 AUX_OP8_TABLE1A char(12) init('VSPSDVR2    '),\n     2 AUX_OP8_TABLE1B char(12) init('VZPSDVR1    '),\n     2 AUX_OP8_TABLE1C char(12) init('            '),\n     2 AUX_OP8_TABLE1D char(12) init('            '),\n     2 AUX_OP8_TABLE1E char(12) init('            '),\n     2 AUX_OP8_TABLE1F char(12) init('            '),\n     2 AUX_OP8_TABLE20 char(12) init('            '),\n     2 AUX_OP8_TABLE21 char(12) init('            '),\n     2 AUX_OP8_TABLE22 char(12) init('            '),\n     2 AUX_OP8_TABLE23 char(12) init('            '),\n     2 AUX_OP8_TABLE24 char(12) init('            '),\n     2 AUX_OP8_TABLE25 char(12) init('            '),\n     2 AUX_OP8_TABLE26 char(12) init('            '),\n     2 AUX_OP8_TABLE27 char(12) init('            '),\n     2 AUX_OP8_TABLE28 char(12) init('VLEL VR     '),\n     2 AUX_OP8_TABLE29 char(12) init('VXEL VR     '),\n     2 AUX_OP8_TABLE2A char(12) init('            '),\n     2 AUX_OP8_TABLE2B char(12) init('            '),\n     2 AUX_OP8_TABLE2C char(12) init('            '),\n     2 AUX_OP8_TABLE2D char(12) init('            '),\n     2 AUX_OP8_TABLE2E char(12) init('            '),\n     2 AUX_OP8_TABLE2F char(12) init('            '),\n     2 AUX_OP8_TABLE30 char(12) init('            '),\n     2 AUX_OP8_TABLE31 char(12) init('            '),\n     2 AUX_OP8_TABLE32 char(12) init('            '),\n     2 AUX_OP8_TABLE33 char(12) init('            '),\n     2 AUX_OP8_TABLE34 char(12) init('            '),\n     2 AUX_OP8_TABLE35 char(12) init('            '),\n     2 AUX_OP8_TABLE36 char(12) init('            '),\n     2 AUX_OP8_TABLE37 char(12) init('            '),\n     2 AUX_OP8_TABLE38 char(12) init('            '),\n     2 AUX_OP8_TABLE39 char(12) init('            '),\n     2 AUX_OP8_TABLE3A char(12) init('            '),\n     2 AUX_OP8_TABLE3B char(12) init('            '),\n     2 AUX_OP8_TABLE3C char(12) init('            '),\n     2 AUX_OP8_TABLE3D char(12) init('            '),\n     2 AUX_OP8_TABLE3E char(12) init('            '),\n     2 AUX_OP8_TABLE3F char(12) init('            '),\n     2 AUX_OP8_TABLE40 char(12) init('VTVM RRZ    '),\n     2 AUX_OP8_TABLE41 char(12) init('VCVM RRZ    '),\n     2 AUX_OP8_TABLE42 char(12) init('VCZVMRRE    '),\n     2 AUX_OP8_TABLE43 char(12) init('VCOVMRRE    '),\n     2 AUX_OP8_TABLE44 char(12) init('VXVC RRE    '),\n     2 AUX_OP8_TABLE45 char(12) init('VLVCURRE    '),\n     2 AUX_OP8_TABLE46 char(12) init('VXVMMRRE    '),\n     2 AUX_OP8_TABLE47 char(12) init('            '),\n     2 AUX_OP8_TABLE48 char(12) init('VRRS RRE    '),\n     2 AUX_OP8_TABLE49 char(12) init('VRSVCRRE    '),\n     2 AUX_OP8_TABLE4A char(12) init('VRSV RRE    '),\n     2 AUX_OP8_TABLE4B char(12) init('            '),\n     2 AUX_OP8_TABLE4C char(12) init('            '),\n     2 AUX_OP8_TABLE4D char(12) init('            '),\n     2 AUX_OP8_TABLE4E char(12) init('            '),\n     2 AUX_OP8_TABLE4F char(12) init('            '),\n     2 AUX_OP8_TABLE50 char(12) init('            '),\n     2 AUX_OP8_TABLE51 char(12) init('            '),\n     2 AUX_OP8_TABLE52 char(12) init('            '),\n     2 AUX_OP8_TABLE53 char(12) init('            '),\n     2 AUX_OP8_TABLE54 char(12) init('            '),\n     2 AUX_OP8_TABLE55 char(12) init('            '),\n     2 AUX_OP8_TABLE56 char(12) init('            '),\n     2 AUX_OP8_TABLE57 char(12) init('            '),\n     2 AUX_OP8_TABLE58 char(12) init('            '),\n     2 AUX_OP8_TABLE59 char(12) init('            '),\n     2 AUX_OP8_TABLE5A char(12) init('            '),\n     2 AUX_OP8_TABLE5B char(12) init('            '),\n     2 AUX_OP8_TABLE5C char(12) init('            '),\n     2 AUX_OP8_TABLE5D char(12) init('            '),\n     2 AUX_OP8_TABLE5E char(12) init('            '),\n     2 AUX_OP8_TABLE5F char(12) init('            '),\n     2 AUX_OP8_TABLE60 char(12) init('            '),\n     2 AUX_OP8_TABLE61 char(12) init('            '),\n     2 AUX_OP8_TABLE62 char(12) init('            '),\n     2 AUX_OP8_TABLE63 char(12) init('            '),\n     2 AUX_OP8_TABLE64 char(12) init('            '),\n     2 AUX_OP8_TABLE65 char(12) init('            '),\n     2 AUX_OP8_TABLE66 char(12) init('            '),\n     2 AUX_OP8_TABLE67 char(12) init('            '),\n     2 AUX_OP8_TABLE68 char(12) init('            '),\n     2 AUX_OP8_TABLE69 char(12) init('            '),\n     2 AUX_OP8_TABLE6A char(12) init('            '),\n     2 AUX_OP8_TABLE6B char(12) init('            '),\n     2 AUX_OP8_TABLE6C char(12) init('            '),\n     2 AUX_OP8_TABLE6D char(12) init('            '),\n     2 AUX_OP8_TABLE6E char(12) init('            '),\n     2 AUX_OP8_TABLE6F char(12) init('            '),\n     2 AUX_OP8_TABLE70 char(12) init('            '),\n     2 AUX_OP8_TABLE71 char(12) init('            '),\n     2 AUX_OP8_TABLE72 char(12) init('            '),\n     2 AUX_OP8_TABLE73 char(12) init('            '),\n     2 AUX_OP8_TABLE74 char(12) init('            '),\n     2 AUX_OP8_TABLE75 char(12) init('            '),\n     2 AUX_OP8_TABLE76 char(12) init('            '),\n     2 AUX_OP8_TABLE77 char(12) init('            '),\n     2 AUX_OP8_TABLE78 char(12) init('            '),\n     2 AUX_OP8_TABLE79 char(12) init('            '),\n     2 AUX_OP8_TABLE7A char(12) init('            '),\n     2 AUX_OP8_TABLE7B char(12) init('            '),\n     2 AUX_OP8_TABLE7C char(12) init('            '),\n     2 AUX_OP8_TABLE7D char(12) init('            '),\n     2 AUX_OP8_TABLE7E char(12) init('            '),\n     2 AUX_OP8_TABLE7F char(12) init('            '),\n     2 AUX_OP8_TABLE80 char(12) init('VLVM VS     '),\n     2 AUX_OP8_TABLE81 char(12) init('VLCVMVS     '),\n     2 AUX_OP8_TABLE82 char(12) init('VSTVMVS     '),\n     2 AUX_OP8_TABLE83 char(12) init('            '),\n     2 AUX_OP8_TABLE84 char(12) init('VNVM VS     '),\n     2 AUX_OP8_TABLE85 char(12) init('VOVM VS     '),\n     2 AUX_OP8_TABLE86 char(12) init('VXVM VS     '),\n     2 AUX_OP8_TABLE87 char(12) init('            '),\n     2 AUX_OP8_TABLE88 char(12) init('            '),\n     2 AUX_OP8_TABLE89 char(12) init('            '),\n     2 AUX_OP8_TABLE8A char(12) init('            '),\n     2 AUX_OP8_TABLE8B char(12) init('            '),\n     2 AUX_OP8_TABLE8C char(12) init('            '),\n     2 AUX_OP8_TABLE8D char(12) init('            '),\n     2 AUX_OP8_TABLE8E char(12) init('            '),\n     2 AUX_OP8_TABLE8F char(12) init('            '),\n     2 AUX_OP8_TABLE90 char(12) init('            '),\n     2 AUX_OP8_TABLE91 char(12) init('            '),\n     2 AUX_OP8_TABLE92 char(12) init('            '),\n     2 AUX_OP8_TABLE93 char(12) init('            '),\n     2 AUX_OP8_TABLE94 char(12) init('            '),\n     2 AUX_OP8_TABLE95 char(12) init('            '),\n     2 AUX_OP8_TABLE96 char(12) init('            '),\n     2 AUX_OP8_TABLE97 char(12) init('            '),\n     2 AUX_OP8_TABLE98 char(12) init('            '),\n     2 AUX_OP8_TABLE99 char(12) init('            '),\n     2 AUX_OP8_TABLE9A char(12) init('            '),\n     2 AUX_OP8_TABLE9B char(12) init('            '),\n     2 AUX_OP8_TABLE9C char(12) init('            '),\n     2 AUX_OP8_TABLE9D char(12) init('            '),\n     2 AUX_OP8_TABLE9E char(12) init('            '),\n     2 AUX_OP8_TABLE9F char(12) init('            '),\n     2 AUX_OP8_TABLEA0 char(12) init('            '),\n     2 AUX_OP8_TABLEA1 char(12) init('            '),\n     2 AUX_OP8_TABLEA2 char(12) init('            '),\n     2 AUX_OP8_TABLEA3 char(12) init('            '),\n     2 AUX_OP8_TABLEA4 char(12) init('            '),\n     2 AUX_OP8_TABLEA5 char(12) init('            '),\n     2 AUX_OP8_TABLEA6 char(12) init('            '),\n     2 AUX_OP8_TABLEA7 char(12) init('            '),\n     2 AUX_OP8_TABLEA8 char(12) init('            '),\n     2 AUX_OP8_TABLEA9 char(12) init('            '),\n     2 AUX_OP8_TABLEAA char(12) init('            '),\n     2 AUX_OP8_TABLEAB char(12) init('            '),\n     2 AUX_OP8_TABLEAC char(12) init('            '),\n     2 AUX_OP8_TABLEAD char(12) init('            '),\n     2 AUX_OP8_TABLEAE char(12) init('            '),\n     2 AUX_OP8_TABLEAF char(12) init('            '),\n     2 AUX_OP8_TABLEB0 char(12) init('            '),\n     2 AUX_OP8_TABLEB1 char(12) init('            '),\n     2 AUX_OP8_TABLEB2 char(12) init('            '),\n     2 AUX_OP8_TABLEB3 char(12) init('            '),\n     2 AUX_OP8_TABLEB4 char(12) init('            '),\n     2 AUX_OP8_TABLEB5 char(12) init('            '),\n     2 AUX_OP8_TABLEB6 char(12) init('            '),\n     2 AUX_OP8_TABLEB7 char(12) init('            '),\n     2 AUX_OP8_TABLEB8 char(12) init('            '),\n     2 AUX_OP8_TABLEB9 char(12) init('            '),\n     2 AUX_OP8_TABLEBA char(12) init('            '),\n     2 AUX_OP8_TABLEBB char(12) init('            '),\n     2 AUX_OP8_TABLEBC char(12) init('            '),\n     2 AUX_OP8_TABLEBD char(12) init('            '),\n     2 AUX_OP8_TABLEBE char(12) init('            '),\n     2 AUX_OP8_TABLEBF char(12) init('            '),\n     2 AUX_OP8_TABLEC0 char(12) init('VSRSVSV     '),\n     2 AUX_OP8_TABLEC1 char(12) init('VMRSVSV     '),\n     2 AUX_OP8_TABLEC2 char(12) init('VSRRSSV     '),\n     2 AUX_OP8_TABLEC3 char(12) init('VMRRSSV     '),\n     2 AUX_OP8_TABLEC4 char(12) init('VLVCASV     '),\n     2 AUX_OP8_TABLEC5 char(12) init('VRCL SV     '),\n     2 AUX_OP8_TABLEC6 char(12) init('VSVMMSV     '),\n     2 AUX_OP8_TABLEC7 char(12) init('            '),\n     2 AUX_OP8_TABLEC8 char(12) init('VSTVPSV     '),\n     2 AUX_OP8_TABLEC9 char(12) init('            '),\n     2 AUX_OP8_TABLECA char(12) init('VACSVSV     '),\n     2 AUX_OP8_TABLECB char(12) init('VACRSSV     '),\n\n   1 AUX_OP_TABLE8 (0:203) char(12) def AUX_OP_TABLE8_ENTRIES,\n\n   1 AUX_OP_TABLE9_ENTRIES static, /* for op code E4 */\n     2 AUX_OP9_TABLE00 char(12) init('VLI  RSE    '), /* also VLIE  */\n     2 AUX_OP9_TABLE01 char(12) init('VSTI RSE    '), /* also VSTIE */\n     2 AUX_OP9_TABLE02 char(12) init('            '),\n     2 AUX_OP9_TABLE03 char(12) init('            '),\n     2 AUX_OP9_TABLE04 char(12) init('            '),\n     2 AUX_OP9_TABLE05 char(12) init('            '),\n     2 AUX_OP9_TABLE06 char(12) init('            '),\n     2 AUX_OP9_TABLE07 char(12) init('            '),\n     2 AUX_OP9_TABLE08 char(12) init('            '),\n     2 AUX_OP9_TABLE09 char(12) init('            '),\n     2 AUX_OP9_TABLE0A char(12) init('            '),\n     2 AUX_OP9_TABLE0B char(12) init('            '),\n     2 AUX_OP9_TABLE0C char(12) init('            '),\n     2 AUX_OP9_TABLE0D char(12) init('            '),\n     2 AUX_OP9_TABLE0E char(12) init('            '),\n     2 AUX_OP9_TABLE0F char(12) init('            '),\n     2 AUX_OP9_TABLE10 char(12) init('VLID RSE    '),\n     2 AUX_OP9_TABLE11 char(12) init('VSTIDRSE    '),\n     2 AUX_OP9_TABLE12 char(12) init('            '),\n     2 AUX_OP9_TABLE13 char(12) init('            '),\n     2 AUX_OP9_TABLE14 char(12) init('            '),\n     2 AUX_OP9_TABLE15 char(12) init('            '),\n     2 AUX_OP9_TABLE16 char(12) init('            '),\n     2 AUX_OP9_TABLE17 char(12) init('            '),\n     2 AUX_OP9_TABLE18 char(12) init('            '),\n     2 AUX_OP9_TABLE19 char(12) init('            '),\n     2 AUX_OP9_TABLE1A char(12) init('            '),\n     2 AUX_OP9_TABLE1B char(12) init('            '),\n     2 AUX_OP9_TABLE1C char(12) init('            '),\n     2 AUX_OP9_TABLE1D char(12) init('            '),\n     2 AUX_OP9_TABLE1E char(12) init('            '),\n     2 AUX_OP9_TABLE1F char(12) init('            '),\n     2 AUX_OP9_TABLE20 char(12) init('            '),\n     2 AUX_OP9_TABLE21 char(12) init('            '),\n     2 AUX_OP9_TABLE22 char(12) init('            '),\n     2 AUX_OP9_TABLE23 char(12) init('            '),\n     2 AUX_OP9_TABLE24 char(12) init('VSRL RSE    '),\n     2 AUX_OP9_TABLE25 char(12) init('VSLL RSE    '),\n     2 AUX_OP9_TABLE26 char(12) init('            '),\n     2 AUX_OP9_TABLE27 char(12) init('            '),\n     2 AUX_OP9_TABLE28 char(12) init('VLBIXRSE    '),\n\n   1 AUX_OP_TABLE9 (0:40) char(12) def AUX_OP_TABLE9_ENTRIES,\n\n     AUX_OP_TABLE_PTR (0:9)   static  ptr,\n     AUX_OP_TABLE_DIM (0:9)   static  fixed(15) bin,\n\n     DLOAD                       file   record input env(U),\n     DISPARM                     file   input,\n     DPRINT                      file   print,\n     DPUNCH                      file   record output env(F\n                                                      recsize(80)\n                                                      blksize(6160));\n\n Dcl\n     TEXT_BUFFER                        char(*) ctl;\n\n Dcl\n     1 LOAD_RECORD       aligned based(LOAD_PTR),\n       2 LOAD_TYPE       unaligned,\n         3 LOAD_IDR                     bit(1),\n         3 LOAD_SYM                     bit(1),\n         3 LOAD_CESD                    bit(1),\n         3 LOAD_SCATTER                 bit(1),\n         3 LOAD_END_OF_MODULE           bit(1),\n         3 LOAD_END_OF_SEGMENT          bit(1),\n         3 LOAD_RLD                     bit(1),\n         3 LOAD_CONTROL                 bit(1);\n Dcl\n     1 CESD_RECORD       aligned based(LOAD_PTR),\n       2 CESD_PREFIX,\n         3 CESD_IDENTIFICATION          bit(8),\n         3 CESD_FORMERLY_SPARE unaligned,\n           4 CESD_XA                    bit(1),\n           4 CESD_SPARE                 bit(23),\n         3 CESD_FIRST_ESDID             fixed(15) bin,\n         3 CESD_COUNT                   fixed(15) bin,\n       2 CESD_DATA                      char(16),\n\n     1 CESD_ENTRY        aligned based(CESD_PTR),\n       2 CESD_NAME                      char(8),\n       2 CESD_TYPE                      bit(8),\n       2 CESD_ADDRESS                   bit(24),\n       2 CESD_SEGMENT                   bit(8),\n       2 CESD_LENGTH                    bit(24), /* ID when labelref */\n\n     1 CESD_ENTRY2       aligned based(CESD_PTR),\n       2 CESD_NAME2                     char(8),\n       2 CESD_TYPE2    unaligned,\n         3 CESD_TYPE_BITS           (8) bit(1),\n       2 CESD_ADDRESS2                  bit(24),\n       2 CESD_SEGMENT2 unaligned,\n         3 CESD_XA_RESERVED             bit(4),\n         3 CESD_XA_RSECT                bit(1),\n         3 CESD_XA_RMODE                bit(1),\n         3 CESD_XA_AMODE                bit(2),\n       2 CESD_LENGTH2,\n         3 CESD_XA_LENGTH_FILLER        char(1),\n         3 CESD_XA_IDREF                fixed(15) bin,\n\n     1 CONTROL_RECORD    aligned based(LOAD_PTR),\n       2 CONTROL_PREFIX,\n         3 CONTROL_IDENTIFICATION       bit(8),\n         3 CONTROL_SPARE                bit(24),\n         3 CONTROL_CONTROL_COUNT        fixed(15) bin,\n         3 CONTROL_RLD_COUNT            fixed(15) bin,\n         3 CONTROL_CCW,\n           4 CONTROL_CCW_FLAGS1         bit(8),\n           4 CONTROL_CCW_ADDRESS        bit(24),\n           4 CONTROL_CCW_FLAGS2         bit(16),\n           4 CONTROL_CCW_LENGTH         fixed(15) bin,\n       2 CONTROL_DATA                   char(240),\n\n     1 CONTROL_ENTRY     aligned based(CONTROL_PTR),\n       2 CONTROL_ESDID                  fixed(15) bin,\n       2 CONTROL_LENGTH                 fixed(15) bin,\n\n     1 TEXT_RECORD        aligned based(LOAD_PTR),\n       2 TEXT_DATA                      char(32760),\n\n     1 RLD_RECORD        aligned based(LOAD_PTR),\n       2 RLD_PREFIX,\n         3 RLD_IDENTIFICATION           bit(8),\n         3 RLD_SPARE                    bit(24),\n         3 RLD_CONTROL_COUNT            fixed(15) bin,\n         3 RLD_RLD_COUNT                fixed(15) bin,\n         3 RLD_CCW                      char(8),\n       2 RLD_DATA                       char(240),\n\n     1 RLD_ENTRY         aligned based(RLD_PTR),\n       2 RLD_RELOCATION_POINTER         fixed(15) bin,\n       2 RLD_POSITION_POINTER           fixed(15) bin,\n       2 RLD_SUBDATA                    char(240),\n\n     1 RLD_SUBENTRY      aligned based(RLD_SUB_PTR),\n       2 RLD_FLAG      unaligned,\n         3 RLD_TYPE                     bit(4),\n         3 RLD_LENGTH                   bit(2),\n         3 RLD_NEGATIVE                 bit(1),\n         3 RLD_SAME_RP                  bit(1),\n       2 RLD_ADDRESS                    bit(24),\n\n     1 QUEUE             aligned static,\n       2 FIRST                          ptr init(Null),\n       2 LAST                           ptr init(Null),\n       2 MOST_RECENT                    ptr init(Null),\n\n     1 CEQ            like QUEUE static, /* ESD entry queue */\n     1 RAQ            like QUEUE static, /* RLD entry queue */\n     1 SPQ            like QUEUE static, /* start point queue */\n     1 LQ             like QUEUE static, /* label queue */\n     1 IQ             like QUEUE static, /* instruction queue */\n\n     CEQP                        static ptr,\n     RAQP                        static ptr,\n     SPQP                        static ptr,\n     LQP                         static ptr,\n     IQP                         static ptr,\n\n     1 CEQE                      based(CEQP),  /* ESD entry element */\n       2 CEQE_NEXT                      ptr,\n       2 CEQE_PREV                      ptr,\n       2 CEQE_ESDID                     fixed(31) bin, /* argument */\n       2 CEQE_NAME                      char(8),\n       2 CEQE_ADDRESS                   fixed(31) bin,\n       2 CEQE_LENGTH                    fixed(31) bin,\n       2 CEQE_IDREF                     fixed(31) bin, /* LR only */\n       2 CEQE_TYPE                      char(2),\n       2 CEQE_FLAGS                     bit(8),\n\n     1 RAQE                      based(RAQP),  /* RLD entry element */\n       2 RAQE_NEXT                      ptr,\n       2 RAQE_PREV                      ptr,\n       2 RAQE_ADDRESS                   fixed(31) bin, /* argument */\n       2 RAQE_LENGTH                    fixed(31) bin,\n       2 RAQE_RELOCATION                fixed(31) bin,\n       2 RAQE_NAME                      char(8),\n       2 RAQE_TYPE                      char(1),\n       2 RAQE_FLAGS,\n         3 RAQE_FLAGS_BITS unaligned,\n           4 RAQE_NEGATIVE              bit(1),\n           4 RAQE_UNRESOLVED            bit(1),\n           4 RAQE_FLAG3                 bit(1),\n           4 RAQE_FLAG4                 bit(1),\n           4 RAQE_FLAG5                 bit(1),\n           4 RAQE_FLAG6                 bit(1),\n           4 RAQE_FLAG7                 bit(1),\n           4 RAQE_FLAG8                 bit(1),\n\n     1 LQE                       based(LQP),   /* Label element */\n       2 LQE_NEXT                       ptr,\n       2 LQE_PREV                       ptr,\n       2 LQE_ADDRESS                    fixed(31) bin, /* argument */\n       2 LQE_NAME                       char(8),\n       2 LQE_FLAGS,\n         3 LQE_FLAGS_BITS unaligned,\n           4 LQE_ENTRY                  bit(1), /* entry (RLD LR)    */\n           4 LQE_CSECT                  bit(1), /* name of csect     */\n           4 LQE_GENERATED              bit(1), /* generated name    */\n           4 LQE_SYM                    bit(1), /* from symbol table */\n           4 LQE_FLAG5                  bit(1),\n           4 LQE_FLAG6                  bit(1),\n           4 LQE_FLAG7                  bit(1),\n           4 LQE_FLAG8                  bit(1),\n\n     1 SPQE                      based(SPQP),  /* Restart point */\n       2 SPQE_NEXT                      ptr,\n       2 SPQE_PREV                      ptr,\n       2 SPQE_ADDRESS                   fixed(31) bin, /* argument */\n       2 SPQE_LENGTH                    fixed(31) bin,\n       2 SPQE_RELOCATION                fixed(31) bin,\n       2 SPQE_LABEL                     char(8),\n       2 SPQE_NAME                      char(8),\n       2 SPQE_NAME2                     char(8),\n       2 SPQE_TYPE                      char(1),\n       2 SPQE_TYPE2                     char(1),\n       2 SPQE_FLAGS,\n         3 SPQE_FLAGS_BITS unaligned,\n           4 SPQE_EOM                   bit(1),/* end of csect       */\n           4 SPQE_COMPLEX               bit(1),/* complex relocation */\n           4 SPQE_ENTRY                 bit(1),/* external entry     */\n           4 SPQE_RLD                   bit(1),/* relocated address  */\n           4 SPQE_RLDEND                bit(1),/* end of reloc addr  */\n           4 SPQE_TOP                   bit(1),/* beginning of csect */\n           4 SPQE_FLOW                  bit(1),/* known good opcodes */\n           4 SPQE_RESERVED              bit(1),/* reserved           */\n\n     1 SP             static,\n       2 SP_NEXT                        ptr,\n       2 SP_PREV                        ptr,\n       2 SP_ADDRESS                     fixed(31) bin, /* argument */\n       2 SP_LENGTH                      fixed(31) bin,\n       2 SP_RELOCATION                  fixed(31) bin,\n       2 SP_LABEL                       char(8),\n       2 SP_NAME                        char(8),\n       2 SP_NAME2                       char(8),\n       2 SP_TYPE                        char(1),\n       2 SP_TYPE2                       char(1),\n       2 SP_FLAGS,\n         3 SP_FLAGS_BITS unaligned,\n           4 SP_EOM                     bit(1),/* end of csect       */\n           4 SP_COMPLEX                 bit(1),/* complex relocation */\n           4 SP_ENTRY                   bit(1),/* external entry     */\n           4 SP_RLD                     bit(1),/* relocated address  */\n           4 SP_RLDEND                  bit(1),/* end of reloc addr  */\n           4 SP_TOP                     bit(1),/* beginning of csect */\n           4 SP_FLOW                    bit(1),/* known good opcodes */\n           4 SP_RESERVED                bit(1),/* reserved           */\n\n     IPTR                        static ptr,\n     SAVE_IPTR                   static ptr,\n\n     1 INSTRUCTION_CHAR                 char(64) based(IPTR),\n     1 INSTRUCTION_BITS                 bit(48)  based(IPTR),\n\n     1 INSTRUCTION     unaligned based(IPTR),\n       2 OPCODE                         bit(8),\n       2 SUBOPCODE                      bit(8),\n\n     1 BRANCH_INST     unaligned based(IPTR),\n       2 BRANCH_OPCODE                  bit(8),\n       2 CONDMASK                       bit(4),\n\n /********************************************************************/\n /*                                                                  */\n /* The following operation code formats are defined:                */\n /*                                                                  */\n /*          _____________________________                           */\n /*  I      |           |                 |                          */\n /*         | Op Code   | Immediate Data  |                          */\n /*         |___________|_________________|                          */\n /*         0           8                16                          */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  N      |                             |                      |   */\n /*         | Op Code (2 bytes)           | //////////////////// |   */\n /*         |_____________________________|______________________|   */\n /*         0                            16                     32   */\n /*                                                                  */\n /*          _____________________________                           */\n /*  RR     |           |        |        |                          */\n /*         | Op Code   |   R1   |   R2   |                          */\n /*         |___________|________|________|                          */\n /*         0           8       12       16                          */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  RR1    |           |                 |          |     |     |   */\n /*         | Op Code   | Sub-opcode      | //////// | R1  | /// |   */\n /*         |___________|_________________|__________|_____|_____|   */\n /*         0           8                16         24    28    32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  RR2    |           |                 |          |     |     |   */\n /*         | Op Code   | Sub-opcode      | //////// | R1  | R2  |   */\n /*         |___________|_________________|__________|_____|_____|   */\n /*         0           8                16         24    28    32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  RS     |           |        |        |      |               |   */\n /*         | Op Code   |   R1   |   R3   |  B2  |  D2           |   */\n /*         |___________|________|________|______|_______________|   */\n /*         0           8       12       16     20              32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  RSS    |           |        |        |      |               |   */\n /*         | Op Code   |   R1   | ////// |  B2  |  D2           |   */\n /*         |___________|________|________|______|_______________|   */\n /*         0           8       12       16     20              32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  RX     |           |        |        |      |               |   */\n /*         | Op Code   |   R1   |  X2    |  B2  |  D2           |   */\n /*         |___________|________|________|______|_______________|   */\n /*         0           8       12       16     20              32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  S      |           |                 |      |               |   */\n /*         | Op Code   | /////////////// |  B1  |  D1           |   */\n /*         |___________|_________________|______|_______________|   */\n /*         0           8                16     20              32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  SI     |           |                 |      |               |   */\n /*         | Op Code   | Immediate Data  |  B1  |  D1           |   */\n /*         |___________|_________________|______|_______________|   */\n /*         0           8                16     20              32   */\n /*                                                                  */\n /*          _____________________________                           */\n /*  SPM    |           |        |        |                          */\n /*         | Op Code   |   R1   | ////// |                          */\n /*         |___________|________|________|                          */\n /*         0           8       12       16                          */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  SSE    |        |         |    |            |    |            | */\n /*         | Opcode | Subop   | B1 |  D1        | B2 |  D2        | */\n /*         |________|_________|____|____________|____|____________| */\n /*         0        8       16   20           32   36           48  */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  SS1    |        |         |    |            |    |            | */\n /*         | Opcode |  L1     | B1 |  D1        | B2 |  D2        | */\n /*         |________|_________|____|____________|____|____________| */\n /*         0        8       16   20           32   36           48  */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  SS2    |        |    |    |    |            |    |            | */\n /*         | Opcode | L1 | L2 | B1 |  D1        | B2 |  D2        | */\n /*         |________|____|____|____|____________|____|____________| */\n /*         0        8   12  16   20           32   36           48  */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  SS3    |        |    |    |    |            |    |            | */\n /*         | Opcode | L1 | I3 | B1 |  D1        | B2 |  D2        | */\n /*         |________|____|____|____|____________|____|____________| */\n /*         0        8   12  16   20           32   36           48  */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  SS4    |        |    |    |    |            |    |            | */\n /*         | Opcode | R1 | I3 | B1 |  D1        | B2 |  D2        | */\n /*         |________|____|____|____|____________|____|____________| */\n /*         0        8   12  16   20           32   36           48  */\n /*                                                                  */\n /*                                                                  */\n /*                                                                  */\n /* ...and, for the new vector instructions:                         */\n /*                                                                  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  QST    |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | QR3  | RT2  | VR1  | RS2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  QV     |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | QR3  | //// | VR1  | VR2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  QV2    |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | QR2  | //// | VR1  | //// |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VST    |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | VR3  | RT2  | VR1  | RS2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VS3    |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | //// | RT2  | VR1  | RS2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VV     |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | VR3  | //// | VR1  | VR2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VV1    |           '             |             |      |      |  */\n /*         | Op Code   ' Sub-opcode  | /////////// | VR1  | //// |  */\n /*         |___________'_____________|_____________|______|______|  */\n /*         0           8            16            24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VV2    |           '             |             |      |      |  */\n /*         | Op Code   ' Sub-opcode  | /////////// | VR1  | VR2  |  */\n /*         |___________'_____________|_____________|______|______|  */\n /*         0           8            16            24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  RRE    |           '             |             |      |      |  */\n /*         | Op Code   ' Sub-opcode  | /////////// | GR1  | //// |  */\n /*         |___________'_____________|_____________|______|______|  */\n /*         0           8            16            24     28     32  */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  RSE    |        '         |    |    |    |    |    |          | */\n /*         | Opcode ' Sub-op. | R3 |////| VR1|////| B2 |    D2    | */\n /*         |________'_________|____|____|____|____|____|__________| */\n /*         0        8       16   20   24   28   32   36         48  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  SV     |           '             |      |                    |  */\n /*         | Op Code   ' Sub-opcode  |  B2  |        D2          |  */\n /*         |___________'_____________|______|____________________|  */\n /*         0           8            16     20                   32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VR     |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | QR3  | //// | VR1  | GR2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VR1    |           '             |             |      |      |  */\n /*         | Op Code   ' Sub-opcode  | /////////// | VR1  | //// |  */\n /*         |___________'_____________|_____________|______|______|  */\n /*         0           8            16            24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VR2    |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | FR2  | //// | VR1  | //// |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VS     |           '             |                    |      |  */\n /*         | Op Code   ' Sub-opcode  |    ////////////    | RS2  |  */\n /*         |___________'_____________|____________________|______|  */\n /*         0           8            16                   28     32  */\n /*                                                                  */\n /*                                                                  */\n /********************************************************************/\n\n     1 RR_INSTRUCTION  aligned based(IPTR),\n       2 RR_OPCODE     bit(8),\n       2 RR_REGISTERS  unaligned,\n         3 RR_R1       bit(4),\n         3 RR_R2       bit(4),\n\n     1 RR_FLOAT_INST   aligned based(IPTR),\n       2 RR_FLOATCODE  bit(8),\n       2 RR_FLOATREGS  bit(8),\n\n     1 I_INSTRUCTION   aligned based(IPTR),\n       2 I_OPCODE      bit(8),\n       2 I_I           bit(8),\n\n     1 RX_INSTRUCTION  aligned based(IPTR),\n       2 RX_OPCODE     bit(8),\n       2 RX_REGISTERS  unaligned,\n         3 RX_R1       bit(4),\n         3 RX_X2       bit(4),\n       2 RX_B2D2       char(2),\n\n     1 S_INSTRUCTION   aligned based(IPTR),\n       2 S_OPCODE      bit(8),\n       2 S_ZEROES      bit(8),\n       2 S_B2D2        char(2),\n\n     1 N_INSTRUCTION   aligned based(IPTR),\n       2 N_OPCODE      bit(16),\n       2 N_ZEROES,\n         3 N_ZEROES1   bit(8),\n         3 N_ZEROES2   bit(8),\n\n     1 RS_INSTRUCTION  aligned based(IPTR),\n       2 RS_OPCODE     bit(8),\n       2 RS_REGISTERS  unaligned,\n         3 RS_R1       bit(4),\n         3 RS_R3       bit(4),\n       2 RS_B2D2       char(2),\n\n     1 SI_INSTRUCTION  aligned based(IPTR),\n       2 SI_OPCODE     bit(8),\n       2 SI_I2         char(1),\n       2 SI_B1D1       char(2),\n\n     1 SS1_INSTRUCTION aligned based(IPTR),\n       2 SS1_OPCODE    bit(8),\n       2 SS1_L1        bit(8),\n       2 SS1_B1D1      char(2),\n       2 SS1_B2D2      char(2),\n\n     1 SS2_INSTRUCTION aligned based(IPTR),\n       2 SS2_OPCODE    bit(8),\n       2 SS2_LENGTHS   unaligned,\n         3 SS2_L1      bit(4),\n         3 SS2_L2      bit(4),\n       2 SS2_B1D1      char(2),\n       2 SS2_B2D2      char(2),\n\n     1 SS3_INSTRUCTION aligned based(IPTR),\n       2 SS3_OPCODE    bit(8),\n       2 SS3_LENGTHS   unaligned,\n         3 SS3_L1      bit(4),\n         3 SS3_I3      bit(4),\n       2 SS3_B1D1      char(2),\n       2 SS3_B2D2      char(2),\n\n     1 SS4_INSTRUCTION aligned based(IPTR),\n       2 SS4_OPCODE    bit(8),\n       2 SS4_REGS      unaligned,\n         3 SS4_R1      bit(4),\n         3 SS4_I3      bit(4),\n       2 SS4_B1D1      char(2),\n       2 SS4_B2D2      char(2),\n\n     1 RR1_INSTRUCTION aligned based(IPTR),\n       2 RR1_OPCODE    bit(8),\n       2 RR1_SUBOP     bit(8),\n       2 RR1_ZEROES1   bit(8),\n       2 RR1_REGISTERS unaligned,\n         3 RR1_R1      bit(4),\n         3 RR1_ZEROES2 bit(4),\n\n     1 RR2_INSTRUCTION aligned based(IPTR),\n       2 RR2_OPCODE    bit(8),\n       2 RR2_SUBOP     bit(8),\n       2 RR2_ZEROES    bit(8),\n       2 RR2_REGISTERS unaligned,\n         3 RR2_R1      bit(4),\n         3 RR2_R2      bit(4),\n\n     1 SSE_INSTRUCTION aligned based(IPTR),\n       2 SSE_OPCODE    bit(8),\n       2 SSE_SUBOP     bit(8),\n       2 SSE_B1D1      char(2),\n       2 SSE_B2D2      char(2),\n\n     1 QST_INSTRUCTION aligned based(IPTR),\n       2 QST_OPCODE    bit(8),\n       2 QST_SUBOP     bit(8),\n       2 QST_REGISTERS unaligned,\n         3 QST_QR3     bit(4),\n         3 QST_RT2     bit(4),\n         3 QST_VR1     bit(4),\n         3 QST_RS2     bit(4),\n\n     1 QV_INSTRUCTION  aligned based(IPTR),\n       2 QV_OPCODE     bit(8),\n       2 QV_SUBOP      bit(8),\n       2 QV_REGISTERS  unaligned,\n         3 QV_QR3      bit(4),\n         3 QV_ZEROES   bit(4),\n         3 QV_VR1      bit(4),\n         3 QV_VR2      bit(4),\n\n     1 QV2_INSTRUCTION  aligned based(IPTR),\n       2 QV2_OPCODE     bit(8),\n       2 QV2_SUBOP      bit(8),\n       2 QV2_REGISTERS  unaligned,\n         3 QV2_QR2      bit(4),\n         3 QV2_ZEROES1  bit(4),\n         3 QV2_VR1      bit(4),\n         3 QV2_ZEROES2  bit(4),\n\n     1 VST_INSTRUCTION aligned based(IPTR),\n       2 VST_OPCODE    bit(8),\n       2 VST_SUBOP     bit(8),\n       2 VST_REGISTERS unaligned,\n         3 VST_VR3     bit(4),\n         3 VST_RT2     bit(4),\n         3 VST_VR1     bit(4),\n         3 VST_RS2     bit(4),\n\n     1 VS3_INSTRUCTION aligned based(IPTR),\n       2 VS3_OPCODE    bit(8),\n       2 VS3_SUBOP     bit(8),\n       2 VS3_REGISTERS unaligned,\n         3 VS3_ZEROES  bit(4),\n         3 VS3_RT2     bit(4),\n         3 VS3_VR1     bit(4),\n         3 VS3_RS2     bit(4),\n\n     1 VV_INSTRUCTION  aligned based(IPTR),\n       2 VV_OPCODE     bit(8),\n       2 VV_SUBOP      bit(8),\n       2 VV_REGISTERS  unaligned,\n         3 VV_VR3      bit(4),\n         3 VV_ZEROES   bit(4),\n         3 VV_VR1      bit(4),\n         3 VV_VR2      bit(4),\n\n     1 VV1_INSTRUCTION  aligned based(IPTR),\n       2 VV1_OPCODE     bit(8),\n       2 VV1_SUBOP      bit(8),\n       2 VV1_REGISTERS  unaligned,\n         3 VV1_ZEROES1  bit(8),\n         3 VV1_VR1      bit(4),\n         3 VV1_ZEROES2  bit(4),\n\n     1 VV2_INSTRUCTION  aligned based(IPTR),\n       2 VV2_OPCODE     bit(8),\n       2 VV2_SUBOP      bit(8),\n       2 VV2_REGISTERS  unaligned,\n         3 VV2_ZEROES   bit(8),\n         3 VV2_VR1      bit(4),\n         3 VV2_VR2      bit(4),\n\n     1 RRE_INSTRUCTION aligned based(IPTR),\n       2 RRE_OPCODE    bit(8),\n       2 RRE_SUBOP     bit(8),\n       2 RRE_REGISTERS unaligned,\n         3 RRE_ZEROES1 bit(8),\n         3 RRE_GR1     bit(4),\n         3 RRE_ZEROES2 bit(4),\n\n     1 RSE_INSTRUCTION aligned based(IPTR),\n       2 RSE_OPCODE    bit(8),\n       2 RSE_SUBOP     bit(8),\n       2 RSE_REGISTERS unaligned,\n         3 RSE_R3      bit(4),\n         3 RSE_ZEROES1 bit(4),\n         3 RSE_VR1     bit(4),\n         3 RSE_ZEROES2 bit(4),\n         3 RSE_B2D2    char(2),\n\n     1 SV_INSTRUCTION  aligned based(IPTR),\n       2 SV_OPCODE     bit(8),\n       2 SV_SUBOP      bit(8),\n       2 SV_B1D1       char(2),\n\n     1 VR_INSTRUCTION  aligned based(IPTR),\n       2 VR_OPCODE     bit(8),\n       2 VR_SUBOP      bit(8),\n       2 VR_REGISTERS  unaligned,\n         3 VR_QR3      bit(4),\n         3 VR_ZEROES   bit(4),\n         3 VR_VR1      bit(4),\n         3 VR_GR2      bit(4),\n\n     1 VR1_INSTRUCTION  aligned based(IPTR),\n       2 VR1_OPCODE     bit(8),\n       2 VR1_SUBOP      bit(8),\n       2 VR1_REGISTERS  unaligned,\n         3 VR1_ZEROES1  bit(8),\n         3 VR1_VR1      bit(4),\n         3 VR1_ZEROES2  bit(4),\n\n     1 VR2_INSTRUCTION  aligned based(IPTR),\n       2 VR2_OPCODE     bit(8),\n       2 VR2_SUBOP      bit(8),\n       2 VR2_REGISTERS  unaligned,\n         3 VR2_FR2      bit(4),\n         3 VR2_ZEROES1  bit(4),\n         3 VR2_VR1      bit(4),\n         3 VR2_ZEROES2  bit(4),\n\n     1 VS_INSTRUCTION  aligned based(IPTR),\n       2 VS_OPCODE     bit(8),\n       2 VS_SUBOP      bit(8),\n       2 VS_REGISTERS  unaligned,\n         3 VS_ZEROES   bit(12),\n         3 VS_RS1      bit(4),\n\n     INVLMOD                     condition,\n\n     (Date,Null,PLIDUMP,PLIRETC,Time,\n      Addr,Allocation,Dim,Hbound,High,Index,Lbound,Length,Low,\n      Max,Min,Mod,Repeat,String,Substr,Translate,Verify,Unspec)\n                                 builtin,\n     PLIXOPT            external static char(2) var init('NR');\n\n /*******************************************************************/\n1\n On Endfile(DLOAD)\n   DLOAD_EOF = '1'B;\n\n On Undefinedfile(DLOAD) begin;\n   Put file(DPRINT) edit('XDIS0002S File DISLOAD unavailable')\n                          (Skip(3),A);\n   Put file(DPRINT) edit('XDIS0003S Processing cannot continue')\n                          (Skip(1),A);\n   Call PLIRETC(16);\n   Stop;\n End;\n\n On Undefinedfile(DPUNCH) begin;\n   Put file(DPRINT) edit('XDIS0004W File DISPUNCH unavailable')\n                          (Skip(3),A);\n   Put file(DPRINT)\n      edit('XDIS0005W Processing continues without a PUNCH file')\n                          (Skip(1),A);\n   PUNCH = '0'B;\n End;\n\n On Undefinedfile(DISPARM)\n   Goto NO_DISPARM;\n\n On Name(DISPARM) begin;\n   Put file(DPRINT)\n      edit('XDIS0010W Unrecognized parameter ignored in DISPARM input')\n                          (Skip(3),A);\n End;\n\n On Condition(INVLMOD) begin;\n   Put file(DPRINT)\n   edit('XDIS0007S Invalid load module - processing terminated')\n                          (Skip(3),A);\n   Call PLIRETC(12);\n   Stop;\n\n End;\n\n /*******************************************************************/\n1\n AUX_OP_TABLE_PTR(0) = Addr(AUX_OP_TABLE0);\n AUX_OP_TABLE_PTR(1) = Addr(AUX_OP_TABLE1);\n AUX_OP_TABLE_PTR(2) = Addr(AUX_OP_TABLE2);\n AUX_OP_TABLE_PTR(3) = Addr(AUX_OP_TABLE3);\n AUX_OP_TABLE_PTR(4) = Addr(AUX_OP_TABLE4);\n AUX_OP_TABLE_PTR(5) = Addr(AUX_OP_TABLE5);\n AUX_OP_TABLE_PTR(6) = Addr(AUX_OP_TABLE6);\n AUX_OP_TABLE_PTR(7) = Addr(AUX_OP_TABLE7);\n AUX_OP_TABLE_PTR(8) = Addr(AUX_OP_TABLE8);\n AUX_OP_TABLE_PTR(9) = Addr(AUX_OP_TABLE9);\n AUX_OP_TABLE_DIM(0) = Hbound(AUX_OP_TABLE0,1);\n AUX_OP_TABLE_DIM(1) = Hbound(AUX_OP_TABLE1,1);\n AUX_OP_TABLE_DIM(2) = Hbound(AUX_OP_TABLE2,1);\n AUX_OP_TABLE_DIM(3) = Hbound(AUX_OP_TABLE3,1);\n AUX_OP_TABLE_DIM(4) = Hbound(AUX_OP_TABLE4,1);\n AUX_OP_TABLE_DIM(5) = Hbound(AUX_OP_TABLE5,1);\n AUX_OP_TABLE_DIM(6) = Hbound(AUX_OP_TABLE6,1);\n AUX_OP_TABLE_DIM(7) = Hbound(AUX_OP_TABLE7,1);\n AUX_OP_TABLE_DIM(8) = Hbound(AUX_OP_TABLE8,1);\n AUX_OP_TABLE_DIM(9) = Hbound(AUX_OP_TABLE9,1);\n\n /*******************************************************************/\n\n Open file(DPRINT) title('DISPRINT') linesize(150),\n      file(DLOAD)  title('DISLOAD');\n\n Put file(DPRINT) skip(2);\n Do I = 1 to Hbound(COPYRIGHT_NOTICE_AND_DISCLAIMER,1);\n  Put file(DPRINT) skip(1)\n      edit(COPYRIGHT_NOTICE_AND_DISCLAIMER(I)) (A);\n End;\n Put file(DPRINT) skip(3);\n\n CSECT_NAME = PARM;\n\n If CSECT_NAME = '' then do;\n   Put file(DPRINT)\n       edit(\n 'XDIS0006I No control section specified, CESD entries will be listed')\n           (Skip(2),A);\n   ESD = 'Y';\n End;\n\n Else do;\n  Get file(DISPARM) data(ESA,XA,SP1,VF,ESD,INCREMENT,OPSCAN);\n  Unspec(ESA) = Unspec(ESA) | '01000000'B;\n  Unspec(XA)  = Unspec(XA)  | '01000000'B;\n  Unspec(SP1) = Unspec(SP1) | '01000000'B;\n  Unspec(VF)  = Unspec(VF)  | '01000000'B;\n  Unspec(ESD) = Unspec(ESD) | '01000000'B;\n  If  ESA \u00ac= 'Y' then ESA = 'N';\n  If  XA  \u00ac= 'Y' then XA  = 'N';\n  If  SP1 \u00ac= 'Y' then SP1 = 'N';\n  If  VF  \u00ac= 'Y' then VF  = 'N';\n  If  ESD \u00ac= 'Y' then ESD = 'N';\n\n  If ESA = 'Y' then XA  = 'Y';\n  If VF  = 'Y' then XA  = 'Y';\n  If XA  = 'Y' then SP1 = 'Y';\n\n End;\n\n NO_DISPARM:\n\n If ESA = 'Y' then do;\n                       OP_INDEX_LIMIT = 183; /* but what about VF? */\n                       AUX_OP_TABLE_DIM(4) = 79; /* B24F */\n                       AUX_OP_TABLE_DIM(5) = 15; /* E50F */\n End;\n Else if VF  = 'Y' then do;\n                       OP_INDEX_LIMIT = 179;\n                       AUX_OP_TABLE_DIM(4) = 60; /* B23C */\n                       AUX_OP_TABLE_DIM(5) =  1; /* E501 */\n End;\n Else if XA  = 'Y' then do;\n                       OP_INDEX_LIMIT = 175;\n                       AUX_OP_TABLE_DIM(4) = 60; /* B23C */\n                       AUX_OP_TABLE_DIM(5) =  1; /* E501 */\n End;\n Else if SP1 = 'Y' then do;\n                       OP_INDEX_LIMIT = 169;\n                       AUX_OP_TABLE_DIM(4) = 44; /* B22C */\n                       AUX_OP_TABLE_DIM(5) =  1; /* E501 */\n End;\n Else do;\n                       OP_INDEX_LIMIT = 165;\n                       AUX_OP_TABLE_DIM(4) = 19; /* B213 */\n                    /* AUX_OP_TABLE_DIM(5) irrelevant    */\n End;\n\n If ESA \u00ac= 'Y' then do;\n   AUX_OP1_TABLE1A = '';   /* no CFC unless ESA, just like UPT */\n End;\n Else If ESA = 'Y' & VF = 'N' then do;\n   OP_TABLE176 = '';\n   OP_TABLE177 = '';\n   OP_TABLE178 = '';\n   OP_TABLE179 = '';\n End;\n\n READ_LOAD: Do while (\u00ac DLOAD_EOF);\n\n   Read file(DLOAD) set(LOAD_PTR);\n\n   If DLOAD_EOF then Leave READ_LOAD;\n\n   If TEXT then do;\n     Call PROCESS_TEXT;\n     TEXT = '0'B;\n     If LAST_TEXT then DLOAD_EOF = '1'B;\n   End;\n\n   Else do;\n\n     If LOAD_END_OF_MODULE then LAST_TEXT = '1'B;\n\n     If LOAD_CESD then do;\n       If LOAD_SYM | LOAD_CONTROL | LOAD_RLD then\n         Signal condition(INVLMOD);\n       Call PROCESS_CESD;\n     End;\n\n     If LOAD_SYM then do;\n       If LOAD_CONTROL | LOAD_RLD then\n         Signal condition(INVLMOD);\n     End;\n\n     If LOAD_CONTROL then do;\n       TEXT = '1'B;\n       Call PROCESS_CONTROL;\n     End;\n\n     If LOAD_RLD then do;\n       Call PROCESS_RLD;\n     End;\n\n   End;\n\n End READ_LOAD;\n\n Close file(DLOAD);\n\n /* Now...set up start point queue entries. */\n\n /* Add a start point entry for the physical end of the csect. */\n Call ADD_START_POINT (CSECT_LENGTH);\n SPQE_EOM = '1'B;\n\n /* Create a start point for the beginning of the module. */\n Call ADD_START_POINT (0);\n SPQE_LABEL = CSECT_NAME;\n SPQE_TOP = '1'B;\n\n Do CEQP = CEQ.FIRST repeat CEQE_NEXT while (CEQP \u00ac= Null);\n   If CEQE_TYPE = 'LR' & CEQE_IDREF = ESDID then do;\n    /* For each label reference in our csect (i.e. entry point name) */\n    /* create a start point and a label element */\n     Call ADD_START_POINT (CEQE_ADDRESS - CSECT_OFFSET);\n     SPQE_LABEL = CEQE_NAME;\n     SPQE_ENTRY = '1'B;\n     If CEQE_NAME \u00ac= CSECT_NAME then do;\n       Allocate LQE set(LQP);\n       LQE_ADDRESS = SPQE_ADDRESS;\n       LQE_NAME = CEQE_NAME;\n       String(LQE_FLAGS) = '00000000'B;\n       LQE_ENTRY = '1'B;\n       Call INSERT(LQP,Addr(LQ));\n     End;\n   End;\n End;\n\n Do RAQP = RAQ.FIRST repeat RAQE_NEXT while (RAQP \u00ac= Null);\n   /* For each relocated addr in our csect, create a start point */\n   /* If already an entry, assume a label entry and modify it. */\n   Call ADD_START_POINT (RAQE_ADDRESS);\n   SPQE_RLD = '1'B;\n   /* If this is a negative value, this must be a complexly\n      relocatable address constant, and there must be 2 entries\n      with the same address (the existing one will be updated). */\n   If RAQE_NEGATIVE then do;\n    SPQE_NAME2 = RAQE_NAME;\n    SPQE_TYPE2 = RAQE_TYPE;\n    SPQE_RLD = '1'B;\n    SPQE_COMPLEX = '1'B;\n   End;\n   Else do;\n    SPQE_LENGTH = RAQE_LENGTH;\n    SPQE_RELOCATION = RAQE_RELOCATION;\n    SPQE_NAME = RAQE_NAME;\n    SPQE_TYPE = RAQE_TYPE;\n    SPQE_RLD = '1'B;\n   End;\n   /* Do the same to mark the end of each relocated address      */\n   /* If already an entry, assume a label entry and modify it. */\n   Call ADD_START_POINT (RAQE_ADDRESS + RAQE_LENGTH);\n   SPQE_RLDEND = '1'B;\n End;\n\n /* Free the ESD queue and display entries if requested */\n\n If ESD = 'Y' then do;\n   On ENDPAGE(DPRINT) begin;\n     PAGENUM = PAGENUM + 1;\n     Put file(DPRINT) page\n         edit(CSECT_NAME,' - COMPOSITE EXTERNAL SYMBOL DICTIONARY',\n              'PAGE ',NUMOUT(PAGENUM))\n             (X(18),A(8),A,X(40),A,A(5));\n     Put file(DPRINT) skip(3)\n         list('SYMBOL   TYPE  ID   ADDR  LENGTH LRID FLAGS');\n     Put file(DPRINT) skip(2);\n   End;\n   Signal ENDPAGE(DPRINT);\n End;\n Do CEQP = CEQ.FIRST repeat TEMP_PTR while (CEQP \u00ac= Null);\n   If ESD = 'Y' then do;\n     ESD_ID   = Substr(HEXNUM(CEQE_ESDID),5,4);\n     ESD_LEN  = '';\n     Unspec(ESD_LDID) = Unspec('    ');\n     Unspec(ESD_FLAGS) = Unspec('  ');\n     If CEQE_TYPE = 'ER' |\n        CEQE_TYPE = 'NL' |\n        CEQE_TYPE = 'WX' then\n       ESD_ADDR = '';\n     Else do;\n       ESD_ADDR = Substr(HEXNUM(CEQE_ADDRESS),3,6);\n       If CEQE_TYPE = 'LR' then\n         ESD_LDID = Substr(HEXNUM(CEQE_IDREF),5,4);\n       Else\n         ESD_LEN  = Substr(HEXNUM(CEQE_LENGTH),3,6);\n     End;\n     If CEQE_TYPE = 'SD' |\n        CEQE_TYPE = 'PC' then\n       ESD_FLAGS = Substr(HEXNUM(CEQE_FLAGS),7,2);\n     Put file(DPRINT)\n         list(CEQE_NAME||'  '||CEQE_TYPE||'  '||ESD_ID  ||' '  ||\n              ESD_ADDR ||' ' ||ESD_LEN  ||' ' ||ESD_LDID||'   '||\n              ESD_FLAGS);\n     Put file(DPRINT) skip(1);\n   End;\n   TEMP_PTR = CEQE_NEXT;\n   Free CEQE;\n End;\n\n /* Free the RLD queue */\n\n Do RAQP = RAQ.FIRST repeat TEMP_PTR while (RAQP \u00ac= Null);\n   TEMP_PTR = RAQE_NEXT;\n   Free RAQE;\n End;\n\n If CSECT_NAME = '' then do;\n   RETCODE = 4;\n   Goto FIN;\n End;\n\n If CSECT_LENGTH = 0 then do;\n   Put file(DPRINT) skip(2)\n       list('XDIS0008E Requested control section '||CSECT_NAME||\n       ' not found in load module');\n   RETCODE = 12;\n   Goto FIN;\n End;\n Else if CSECT_LENGTH < 0 then do;\n   Put file(DPRINT) skip(2)\n       list('XDIS0011E Requested control section '||CSECT_NAME||\n       ' unresolved in load module');\n   RETCODE = 12;\n   Goto FIN;\n End;\n\n PUNCH = '1'B; /* set to '0'B if undefined file occurs */\n\n Open file(DPUNCH) title('DISPUNCH');\n\n IOFF = 0;\n\n SYSDATE = Date;\n TODAY = Substr(SYSDATE,3,2)||'/'||Substr(SYSDATE,5,2)||'/'||\n         Substr(SYSDATE,1,2);\n\n Call OUTPUT('','TITLE',\n             ''''||CSECT_NAME||' - source generated by XDIS on '||\n             TODAY||'''');\n\n If PRIVATE_CODE then CSECT_LABEL = '';\n Else CSECT_LABEL = CSECT_NAME;\n\n Call OUTPUT(CSECT_LABEL,'CSECT','');\n\n If AMODE \u00ac= '   ' then Call OUTPUT(CSECT_LABEL,'AMODE',AMODE);\n If RMODE \u00ac= '   ' then Call OUTPUT(CSECT_LABEL,'RMODE',RMODE);\n\n DOIT_LOOP:Do while (SPQ.FIRST \u00ac= Null);\n\n   SPQP = SPQ.FIRST;\n   SP = SPQE;\n   Call DELETE(SPQP,Addr(SPQ));\n   If SP_EOM then Leave DOIT_LOOP;\n\n   BLOCK_LENGTH = SP_NEXT->SPQE_ADDRESS - SP_ADDRESS;\n   IOFF = SP_ADDRESS;\n   Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n\n   Do LQP = Locate(Addr(LQ),IOFF) repeat LQE_NEXT\n            while (LQP \u00ac= Null & LQE_ADDRESS = IOFF);\n     If LQE_ENTRY then\n       Call OUTPUT('        ','ENTRY',LQE_NAME);\n     Call OUTPUT (LQE_NAME,'EQU  ','*');\n     SP_LABEL = '';\n   End;\n\n   If SP_LABEL = CSECT_NAME then SP_LABEL = '';\n\n   If SP_RLD then do;\n     CONDITION_CODE = ' ';\n     VALID_INST = '0'B;\n     RECOGNIZED_INST = '0'B;\n     NAME = SP_NAME;\n     ILEN = SP_LENGTH;\n     IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));\n     Select (ILEN);\n       When (2) I = IPTR->ADCON2 - SP_RELOCATION;\n       When (3) I = IPTR->ADCON3 - SP_RELOCATION;\n       When (4) I = IPTR->ADCON4 - SP_RELOCATION;\n       Otherwise;\n     End;\n     If SP_TYPE = 'Q' then\n       Call OUTPUT(SP_LABEL,'DS   ','QL'||NUMOUT(ILEN));\n     Else do;\n       TYPE = SP_TYPE;\n       If TYPE = 'W' then do;\n        TYPE = 'A';\n        Call OUTPUT_XTRN ('WXTRN',SP_NAME);\n       End;\n       Else if TYPE = 'X' then do;\n        TYPE = 'A';\n        Call OUTPUT_XTRN ('EXTRN',SP_NAME);\n       End;\n       If SP_TYPE2 = 'W' then do;\n        Call OUTPUT_XTRN ('WXTRN',SP_NAME2);\n       End;\n       Else if SP_TYPE2 = 'X' then do;\n        Call OUTPUT_XTRN ('EXTRN',SP_NAME2);\n       End;\n\n       If ILEN = 4 & Mod(IOFF,4) = 0 then\n        OPERANDS = TYPE || '(' ||\n                   Substr(NAME9,1,Index(NAME9,' ')-1);\n       Else\n        OPERANDS = TYPE || 'L' || NUMOUT(ILEN) || '(' ||\n                   Substr(NAME9,1,Index(NAME9,' ')-1);\n       If SP_COMPLEX then do;\n        NAME = SP_NAME2;\n        OPERANDS = OPERANDS || '-' ||\n                   Substr(NAME9,1,Index(NAME9,' ')-1);\n       End;\n       If I = 0 then OPERANDS = OPERANDS || ')';\n       Else if I = -2147483648 then /* XA pointer-defined linkage */\n        OPERANDS = OPERANDS || '+X''80000000'')';\n       Else if I < 0 then do;\n        If I < -2130706432 then do; /* 80000000 thru 80ffffff */\n         Unspec(I) = Unspec(I) & '01111111111111111111111111111111'B;\n         OPERANDS = OPERANDS || '+' || NUMOUT(I) || '+X''80000000'')';\n        End;\n        Else do; /* 81000000 thru 8fffffff */\n         OPERANDS = OPERANDS || '-' || NUMOUT(-I) || ')';\n        End;\n       End;\n       Else OPERANDS = OPERANDS || '+' || NUMOUT(I) || ')';\n       Call OUTPUT(SP_LABEL,'DC   ',OPERANDS);\n     End;\n     SP_LABEL = '';\n   End;\n\n   Else\n   OTHER_THAN_RLD:Do;\n     If SP_FLOW then VALID_INST = '1'B;\n     Else\n     DETERMINE_IF_FLOW:Do;\n       SAVE_IOFF = IOFF;\n       SAVE_IPTR = IPTR;\n       VALID_CHAIN = '0'B;\n       FIND_GOOD_OPCODE_CHAIN:\n       Do I = 0 to BLOCK_LENGTH/2*2-1 by 2 until(VALID_CHAIN);\n         VALID_CHAIN = '1'B;\n         J = BLOCK_LENGTH - I;\n         IOFF = SAVE_IOFF + I;\n         RUN_OPCODE_CHAIN:\n         Do K = 1 to OPSCAN while (VALID_CHAIN);\n           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n           If IOFF = SAVE_IOFF + BLOCK_LENGTH then do;\n             If SPQ.FIRST->SPQE_RLD |\n                SPQ.FIRST->SPQE_ENTRY /* added 12/19/89 */ |\n                SPQ.FIRST->SPQE_EOM then VALID_CHAIN = '0'B;\n             Leave RUN_OPCODE_CHAIN;\n           End;\n           Else if IOFF > SAVE_IOFF + BLOCK_LENGTH then\n             VALID_CHAIN = '0'B;\n           Else do;\n             TEMP_PTR = OP_CODE_LOCATOR(IPTR,J);\n             If TEMP_PTR = Null then do;\n               VALID_CHAIN = '0'B;\n               Leave RUN_OPCODE_CHAIN;\n             End;\n             L = OPLENGTH(IPTR);\n             If I \u00ac= 0 & K = 1 & Verify(Substr(INSTRUCTION_CHAR,1,L),\n               'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$') = 0 then\n               VALID_CHAIN = '0'B;\n             Else if VALID_BRANCH_CODE(IPTR,J) then do;\n               IOFF = IOFF + L;\n               Leave RUN_OPCODE_CHAIN;\n             End;\n             Else do;\n               IOFF = IOFF + L;\n               J = J - L;\n             End;\n           End;\n         End RUN_OPCODE_CHAIN;\n       End FIND_GOOD_OPCODE_CHAIN;\n       If VALID_CHAIN then do;\n         Call ADD_START_POINT (IOFF);\n         If I \u00ac= 0 then do;\n           VALID_INST = '0'B;\n           Call ADD_START_POINT (SAVE_IOFF + I);\n           SPQE_FLOW = '1'B;\n         End;\n         Else do;\n           VALID_INST = '1'B;\n           SP_FLOW = '1'B;\n         End;\n       End;\n       Else do;\n         VALID_INST = '0'B;\n         SP_FLOW = '0'B;\n       End;\n       IPTR = SAVE_IPTR;\n       IOFF = SAVE_IOFF;\n     End DETERMINE_IF_FLOW;\n\n     BLOCK_LENGTH = SPQ.FIRST->SPQE_ADDRESS - SP_ADDRESS;\n     DO_A_BUNCH:\n     Do while (BLOCK_LENGTH > 0);\n       Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n       If VALID_INST then do;\n         ILEN = OPLENGTH(IPTR);\n         If ILEN > BLOCK_LENGTH then do;\n           VALID_INST = '0'B;\n           ILEN = BLOCK_LENGTH;\n         End;\n         IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));\n         RECOGNIZED_INST = VALID_INST;\n           /*******************************************************/\n         OP_PTR = OP_CODE_LOCATOR(IPTR,(BLOCK_LENGTH));\n         If OP_PTR = Null then do;\n           Call OUTPUT(SP_LABEL,'DC   ','X'''||IMAGE||'''');\n           CONDITION_CODE = ' ';\n         End;\n         Else GENERATE_INSTRUCTION:do;\n\n           OPERATION = OP_NAME;\n           Select (OP_FORMAT);\n             When ('RR ') do;\n               OPERANDS = NUMOUT((RR_R1))||','||NUMOUT((RR_R2));\n             End;\n             When ('I  ') do;\n               OPERANDS = NUMOUT((I_I));\n             End;\n             When ('SPM') do;\n               OPERANDS = NUMOUT((RR_R1));\n             End;\n             When ('RX ') do;\n               OPERANDS = NUMOUT((RX_R1)) || ',' ||\n                          GEN_EFF_ADDR(RX_B2D2,(RX_X2),'I');\n             End;\n             When ('S  ') do;\n               OPERANDS = GEN_EFF_ADDR(S_B2D2,0,' ');\n             End;\n             When ('N  ') do;\n               OPERANDS = '';\n             End;\n             When ('RS ') do;\n               OPERANDS = NUMOUT((RS_R1))||','||NUMOUT(RS_R3)||','||\n                          GEN_EFF_ADDR(RS_B2D2,0,' ');\n             End;\n             When ('RSS') do;\n               OPERANDS = NUMOUT((RS_R1)) || ',' ||\n                          GEN_EFF_ADDR(RS_B2D2,0,'S');\n             End;\n             When ('SI ') do;\n               If OP_TYPE = 'C' & Verify(SI_I2,\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$%*()-+=,./') = 0\n               then\n               OPERANDS = GEN_EFF_ADDR(SI_B1D1,0,' ') || ',' ||\n                          'C'''||SI_I2 ||'''';\n               Else\n               OPERANDS = GEN_EFF_ADDR(SI_B1D1,0,' ') || ',' ||\n                          'X'''||HEXOUT(SI_I2)||'''';\n             End;\n             When ('SS1') do;\n               OPERANDS = GEN_EFF_ADDR(SS1_B1D1,(SS1_L1),'L') || ',' ||\n                          GEN_EFF_ADDR(SS1_B2D2,0,' ');\n             End;\n             When ('SS2') do;\n               OPERANDS = GEN_EFF_ADDR(SS2_B1D1,(SS2_L1),'L') || ',' ||\n                          GEN_EFF_ADDR(SS2_B2D2,(SS2_L2),'L');\n             End;\n             When ('SS3') do;\n               OPERANDS = GEN_EFF_ADDR(SS3_B1D1,(SS3_L1),'L') || ',' ||\n                          GEN_EFF_ADDR(SS3_B2D2,0,'S')        || ',' ||\n                          NUMOUT((SS3_I3));\n             End;\n             When ('SS4') do;\n               OPERANDS = GEN_EFF_ADDR(SS4_B1D1,(SS4_R1),'M') || ',' ||\n                          GEN_EFF_ADDR(SS4_B2D2,0,'S')        || ',' ||\n                          NUMOUT((SS4_I3));\n             End;\n             When ('RR1') do;\n               OPERANDS = NUMOUT((RR1_R1));\n             End;\n             When ('RR2') do;\n               OPERANDS = NUMOUT((RR2_R1))||','||NUMOUT((RR2_R2));\n             End;\n             When ('SSE') do;\n               OPERANDS = GEN_EFF_ADDR(SSE_B1D1,0,' ') || ',' ||\n                          GEN_EFF_ADDR(SSE_B2D2,0,' ');\n             End;\n             When ('QST') do;\n               OPERANDS = NUMOUT((QST_VR1)) || ',' ||\n                          NUMOUT((QST_QR3)) || ',' ||\n                          NUMOUT((QST_RS2)) || '(' ||\n                          NUMOUT((QST_RT2)) || ')';\n             End;\n             When ('QV ') do;\n               OPERANDS = NUMOUT((QV_VR1)) || ',' ||\n                          NUMOUT((QV_QR3)) || ',' ||\n                          NUMOUT((QV_VR2));\n             End;\n             When ('QV2') do;\n               OPERANDS = NUMOUT((QV2_VR1)) || ',' ||\n                          NUMOUT((QV2_QR2));\n             End;\n             When ('VST') do;\n               OPERANDS = NUMOUT((VST_VR1)) || ',' ||\n                          NUMOUT((VST_VR3)) || ',' ||\n                          NUMOUT((VST_RS2)) || '(' ||\n                          NUMOUT((VST_RT2)) || ')';\n             End;\n             When ('VS3') do;\n               OPERANDS = NUMOUT((VS3_VR1)) || ',' ||\n                          NUMOUT((VS3_RS2)) || '(' ||\n                          NUMOUT((VS3_RT2)) || ')';\n             End;\n             When ('VV ') do;\n               OPERANDS = NUMOUT((VV_VR1)) || ',' ||\n                          NUMOUT((VV_VR3)) || ',' ||\n                          NUMOUT((VV_VR2));\n             End;\n             When ('VV1') do;\n               OPERANDS = NUMOUT((VV1_VR1));\n             End;\n             When ('VV2') do;\n               OPERANDS = NUMOUT((VV2_VR1)) || ',' ||\n                          NUMOUT((VV2_VR2));\n             End;\n             When ('RRE') do;\n               OPERANDS = NUMOUT((RRE_GR1));\n             End;\n             When ('RRZ') do;\n               OPERANDS = '';\n             End;\n             When ('RSE') do;\n               OPERANDS = NUMOUT((RSE_VR1)) || ',' ||\n                          NUMOUT((RSE_R3))  || ',' ||\n                          GEN_EFF_ADDR(RSE_B2D2,0,' ');\n             End;\n             When ('SV ') do;\n               OPERANDS = GEN_EFF_ADDR(SV_B1D1,0,' ');\n             End;\n             When ('VR ') do;\n               OPERANDS = NUMOUT((VR_VR1)) || ',' ||\n                          NUMOUT((VR_QR3)) || ',' ||\n                          NUMOUT((VR_GR2));\n             End;\n             When ('VR1') do;\n               OPERANDS = NUMOUT((VR1_VR1));\n             End;\n             When ('VR2') do;\n               OPERANDS = NUMOUT((VR2_VR1)) || ',' ||\n                          NUMOUT((VR2_FR2));\n             End;\n             When ('VS ') do;\n               OPERANDS = NUMOUT((VS_RS1));\n             End;\n             Otherwise\n               RECOGNIZED_INST = '0'B;\n           End;\n           If (RECOGNIZED_INST) & (OP_TYPE = 'B') then\n           PROCESS_MNEMONIC:do;\n             MNEMONIC_OPER = '?';\n             Select (CONDITION_CODE);\n               When ('A')\n                 MNEMONIC_STRING = 'ZMPO';\n               When ('C')\n                 MNEMONIC_STRING = 'ELH?';\n               When ('Z')\n                 MNEMONIC_STRING = 'Z???';\n               Otherwise\n                 MNEMONIC_STRING = '????';\n             End;\n             Select(CONDMASK);\n               When ('0000'B)\n                 MNEMONIC_OPER = 'NOP';\n               When ('1111'B)\n                 MNEMONIC_OPER = 'B';\n               When ('1000'B)\n                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,1,1);\n               When ('0100'B)\n                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,2,1);\n               When ('0010'B)\n                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,3,1);\n               When ('0001'B)\n                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,4,1);\n               When ('0111'B)\n                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,1,1);\n               When ('1011'B)\n                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,2,1);\n               When ('1101'B)\n                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,3,1);\n               When ('1110'B)\n                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,4,1);\n               Otherwise\n                 MNEMONIC_OPER = '?';\n             End;\n             If Index(MNEMONIC_OPER,'?') = 0 then do;\n               If OP_FORMAT = 'RR ' then do;\n                 MNEMONIC_OPER = MNEMONIC_OPER || 'R';\n                 OPERANDS = NUMOUT((RR_R2));\n               End;\n               Else do;\n                 OPERANDS = GEN_EFF_ADDR(RX_B2D2,(RX_X2),'I');\n               End;\n               OPERATION = MNEMONIC_OPER;\n             End;\n           End PROCESS_MNEMONIC;\n           If RECOGNIZED_INST then\n             Call OUTPUT(SP_LABEL,OPERATION,OPERANDS);\n           Else\n             Call OUTPUT(SP_LABEL,'DC   ','X'''||IMAGE||'''');\n           If OP_CC \u00ac= ' ' then CONDITION_CODE = OP_CC;\n         End GENERATE_INSTRUCTION;\n         SP_LABEL = '';\n         BLOCK_LENGTH = BLOCK_LENGTH - ILEN;\n         IOFF = IOFF + ILEN;\n       End;\n       Else NOT_INSTRUCTIONS:do;\n         RECOGNIZED_INST = '0'B;\n         CONDITION_CODE = ' ';\n         PROCESS_DEECEES: Do while (BLOCK_LENGTH > 0);\n           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n           K = Min(32,BLOCK_LENGTH);\n           ILEN = Verify(Substr(INSTRUCTION_CHAR,1,K),\n             'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$%*()-+=,./');\n           If ILEN = 0 then ILEN = K;\n           Else ILEN = ILEN - 1;\n           If ILEN \u00ac= 0 then do;\n             IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));\n             Call OUTPUT(SP_LABEL,'DC   ','C'''||\n                         Substr(INSTRUCTION_CHAR,1,ILEN)||'''');\n             SP_LABEL = '';\n           End;\n           BLOCK_LENGTH = BLOCK_LENGTH - ILEN;\n           IOFF = IOFF + ILEN;\n           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n           K = Min(8,BLOCK_LENGTH);\n           Do ILEN = 1 to K while (Index(\n             'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$%*()-+=,./',\n              Substr(INSTRUCTION_CHAR,ILEN,1)) = 0);\n           End;\n           ILEN = ILEN - 1;\n           If ILEN \u00ac= 0 then do;\n             IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));\n             Call OUTPUT(SP_LABEL,'DC   ','X'''||IMAGE||'''');\n             SP_LABEL = '';\n           End;\n           BLOCK_LENGTH = BLOCK_LENGTH - ILEN;\n           IOFF = IOFF + ILEN;\n           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n         End PROCESS_DEECEES;\n       End NOT_INSTRUCTIONS;\n     End DO_A_BUNCH;\n   End OTHER_THAN_RLD;\n\n End DOIT_LOOP;\n\n Call OUTPUT('        ','END  ','');\n\n FIN:\n\n If RETCODE \u00ac= 0 then\n   Put file(DPRINT) skip(2)\n     list('XDIS0001I Processing terminated, highest return code is ' ||\n     NUMOUT(RETCODE));\n\n If PUNCH then Close file(DPUNCH);\n Close file(DPRINT);\n\n Call PLIRETC(RETCODE);\n\n Return;\n\n /*******************************************************************/\n1\n OUTPUT_XTRN: Proc(XTRN,NAME);\n\n  Dcl XTRN              char (5),\n      NAME              char (8);\n  Dcl (NP,NEWP)         ptr;\n  Dcl NAMELIST_PTR      static ptr init(Null());\n  Dcl 1 NAMELIST based,\n        2 NAMELIST_NEXT ptr,\n        2 NAMELIST_NAME char(8);\n\n  /* See if NAME is already on the list. */\n  Do NP = NAMELIST_PTR repeat (NP->NAMELIST_NEXT)\n                       while  (NP \u00ac= Null());\n   If NP->NAMELIST_NAME = NAME then return; /* don't generate stmt */\n  End;\n  Allocate NAMELIST set(NEWP);\n  NEWP->NAMELIST_NEXT = NAMELIST_PTR;\n  NEWP->NAMELIST_NAME = NAME;\n  NAMELIST_PTR = NEWP;\n  Call OUTPUT ('        ',XTRN,NAME);\n\n End OUTPUT_XTRN;\n\n /*******************************************************************/\n1\n OUTPUT:Proc(LABEL,OPERATION,OPERANDS) reorder;\n\n Dcl LABEL              char  (8),\n     OPERATION          char  (5),\n     OPERANDS           char (56) var,\n     LOC8        static char(8),\n     LOC                char(6) def LOC8 pos(3),\n     RE_LOC8     static char(8),\n     RE_LOC             char(6) def RE_LOC8 pos(3),\n     LINE        static char (80),\n     OBJECT_DUMP static char (16),\n     IMAGE_TEMP  static char (12),\n     CURRENT_STATEMENT_NUMBER\n                 static fixed (5) dec init(0),\n     STMTNO             pic '99999',\n     SEQNUM      static fixed (8) dec init(0),\n     SEQUENCE           pic   '99999999' def LINE pos(73),\n     HEADING     static char(48) var init('');\n\n LOC8 = HEXNUM(IOFF);\n RE_LOC8 = HEXNUM(IOFF+CSECT_OFFSET);\n\n If OPERATION = 'END  '\n  | OPERATION = 'ENTRY'\n  | OPERATION = 'TITLE'\n  | OPERATION = 'WXTRN'\n  | OPERATION = 'EXTRN'\n  | OPERATION = 'AMODE'\n  | OPERATION = 'RMODE'\n                        then do;\n   LOC = '';\n   RE_LOC = '';\n   OBJECT_DUMP = '';\n End;\n Else if OPERATION = 'EQU  '\n       | OPERATION = 'CSECT'\n                             then do;\n   OBJECT_DUMP = '';\n End;\n Else if RECOGNIZED_INST then do;\n   IMAGE_TEMP = IMAGE;\n   OBJECT_DUMP = Substr(IMAGE_TEMP,1,4)||' '||Substr(IMAGE_TEMP,5,4)||\n                 ' '|| Substr(IMAGE_TEMP,9,4);\n End;\n Else do;\n   OBJECT_DUMP = Substr(IMAGE,1,Min(16,Length(IMAGE)));\n End;\n\n LINE = LABEL||' '||OPERATION||' '||OPERANDS;\n SEQNUM = SEQNUM + INCREMENT;\n SEQUENCE = SEQNUM;\n CURRENT_STATEMENT_NUMBER = CURRENT_STATEMENT_NUMBER + 1;\n STMTNO = CURRENT_STATEMENT_NUMBER;\n\n If PUNCH then\n   Write file(DPUNCH) from(LINE);\n\n On ENDPAGE(DPRINT) begin;\n   PAGENUM = PAGENUM + 1;\n   Put file(DPRINT) page edit(HEADING,'PAGE ',NUMOUT(PAGENUM))\n                             (X(18),A,X(47),A,A(5));\n   Put file(DPRINT) skip(3)\n   list('LM-LOC CS-LOC  OBJECT CODE         STMT   SOURCE STATEMENT');\n   Put file(DPRINT) skip(2);\n End;\n\n If OPERATION = 'TITLE' then do;\n   Get string(OPERANDS) list(HEADING);\n   Signal ENDPAGE(DPRINT);\n End;\n\n Else Put file(DPRINT) /* skip(1) */\n   list(RE_LOC||' '||LOC||'  '||OBJECT_DUMP||'   '||STMTNO||' '||LINE);\n\n End OUTPUT;\n\n /*******************************************************************/\n1\n OPLENGTH: Proc(IPTR) returns(fixed(15) bin) reorder;\n\n Dcl IPTR   ptr,\n     RETURN_VALUE static fixed(15) bin,\n     OPCODE_BITS bit(8) based(IPTR);\n\n Select (OPCODE_BITS & '11000000'B);\n   When ('00000000'B) RETURN_VALUE = 2;\n   When ('11000000'B) RETURN_VALUE = 6;\n   Otherwise          RETURN_VALUE = 4;\n End;\n\n Return(RETURN_VALUE);\n\n End OPLENGTH;\n\n /*******************************************************************/\n1\n OP_CODE_LOCATOR: Proc(IPTR,J) returns(ptr) reorder;\n\n Dcl IPTR              ptr,\n     J                 fixed(15) bin,\n     SAVE_AUX9  static pic '9',\n     SAVE_AUX          char(1) def SAVE_AUX9,\n     AUX        static fixed(15) bin,\n     RETURN_PTR static ptr,\n     1 OPCODE  aligned based(IPTR),\n       2 OPCODE1       bit(8),\n       2 OPCODE2       bit(8);\n\n If J < OPLENGTH(IPTR) then Return(Null);  /* bug fixed 12/15/89 */\n\n   OP_INDEX = OP_CODE_LOOKUP(OPCODE1);\n   If OP_INDEX > OP_INDEX_LIMIT then Return(Null);\n   OP_PTR = Addr(OP_TABLE0(OP_INDEX));\n   If OP_AUX \u00ac= ' ' then do;\n     SAVE_AUX = OP_AUX;\n     AUX = SAVE_AUX9;\n     OP_INDEX = OPCODE2;\n     If OP_INDEX > AUX_OP_TABLE_DIM(AUX) then Return(Null);\n     OP_PTR = Addr(AUX_OP_TABLE_PTR(AUX)->AUX_OP_ARRAY(OP_INDEX));\n   End;\n   RETURN_PTR = OP_PTR;\n   Select (OP_SPEC);\n     When (' ') do;\n     End;\n     When ('E') do;\n       If ((RR_FLOATREGS & '10011001'B) \u00ac= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('D') do;\n       If ((RR_FLOATREGS & '10111011'B) \u00ac= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('F') do;\n       If ((RR_FLOATREGS & '10010000'B) \u00ac= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('G') do;\n       If ((RR_FLOATREGS & '10110000'B) \u00ac= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('H') do;\n       If ((RR_FLOATREGS & '10111001'B) \u00ac= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('M') do;\n       If (Substr(RR_R1,4,1)) then\n         RETURN_PTR = Null;\n     End;\n     When ('L') do;\n       If (Substr(RR_R1,4,1) | Substr(RR_R2,4,1)) then\n         RETURN_PTR = Null;\n     End;\n     When ('S') do;\n       If ((S_ZEROES) \u00ac= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('N') do;\n       If ((N_ZEROES1) \u00ac= '00000000'B) |\n          ((N_ZEROES2) \u00ac= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('1') do;\n       If ((RS_R3) \u00ac= '0000'B) then RETURN_PTR = Null;\n     End;\n     When ('2') do;\n       If ((RR_FLOATREGS & '00011111'B) \u00ac= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('C') do;\n       If ((Unspec(SI_I2) & '11110000'B) \u00ac= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('X') do;\n       If ((RR1_ZEROES1) \u00ac= '00000000'B) |\n          ((RR1_ZEROES2) \u00ac= '0000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('Y') do;\n       If ((RR2_ZEROES) \u00ac= '00000000'B) then RETURN_PTR = Null;\n     End;\n     Otherwise do;\n       RETURN_PTR = Null;\n     End;\n   End;\n\n Return (RETURN_PTR);\n\n End OP_CODE_LOCATOR;\n\n /*******************************************************************/\n1\n VALID_BRANCH_CODE: Proc(IPTR,REMAINING_LENGTH) returns(bit(1)) reorder;\n\n Dcl IPTR                 ptr,\n     REMAINING_LENGTH     fixed(15) bin,\n     RETURN_VALUE  static bit(1),\n     OPDATA               char(6) based(IPTR),\n     DOUBLEOPCODE         bit(16) based(IPTR),\n     1 OPCODE            aligned  based(IPTR),\n       2 OPCODE1          bit(8),\n       2 OPCODE2          bit(8),\n     1 BRANCHOPCODES     aligned  based(IPTR),\n       2 BRANCHOPCODE     bit(8),\n       2 BRANCHSTUFF   unaligned,\n         3 BRANCHMASK     bit(4),\n         3 BRANCHREG      bit(4);\n\n If REMAINING_LENGTH < OPLENGTH(IPTR) then RETURN_VALUE = '0'B;\n\n Else if (\n    ((OPCODE1) = '01000101'B)           /* 45 - BAL                */ |\n    ((OPCODE1) = '01001101'B)           /* 4D - BAS                */ |\n    ((OPCODE1) = '00001011'B)           /* 0B - BSM                */ |\n    ((OPCODE1) = '00001100'B)           /* 0C - BASSM              */ |\n    (((OPCODE1)='00000101'B) & ((BRANCHREG) \u00ac='0000'B)) /* 05 BALR */ |\n    (((OPCODE1)='00001101'B) & ((BRANCHREG) \u00ac='0000'B)) /* 0D BASR */ |\n    (((OPCODE1)='00000111'B) & ((BRANCHMASK)\u00ac='0000'B)) /* 07 BCR  */ |\n    (((OPCODE1)='01000111'B) & ((BRANCHMASK)\u00ac='0000'B)) /* 47 BC   */ |\n    ((DOUBLEOPCODE) = '0000101000000011'B)   /*  0A03 - EXIT       */ |\n    ((DOUBLEOPCODE) = '0000101000000111'B)   /*  0A07 - XCTL       */ |\n    ((DOUBLEOPCODE) = '0000101000001101'B)   /*  0A0D - ABEND      */ |\n    ((DOUBLEOPCODE) = '1000001000000000'B)   /*  8200 - LPSW       */ |\n    ((DOUBLEOPCODE) = '0000000100000001'B)   /*  0101 - PR         */ |\n    (((DOUBLEOPCODE)='1011001001000000'B) & ((BRANCHREG)\u00ac='0000'B))\n                                             /*  B240 - BAKR       */\n                  ) then RETURN_VALUE = '1'B;\n Else RETURN_VALUE = '0'B;\n\n Return (RETURN_VALUE);\n\n End VALID_BRANCH_CODE;\n\n /*******************************************************************/\n1\n GEN_EFF_ADDR: Proc (SCON,R3,FLAG) returns(char(32) var) reorder;\n\n Dcl SCON              char(2),\n     R3                fixed(31) bin,\n     FLAG              char(1),\n     SYMBOL     static char(32) var,\n     BASEANDDISPLACEMENT static bit(16),\n     1 B2D2            def BASEANDDISPLACEMENT,\n       2 B2D2UN unaligned,\n         3 B2          bit(4),\n         3 D2          bit(12),\n     BASEREG    static fixed(31) bin,\n     BASE       static char(16) var,\n     DISPL      static char(16) var,\n     DISPL_TEMP static fixed(15) bin;\n\n BASEANDDISPLACEMENT = Unspec(SCON);\n BASEREG  = (B2);\n BASE     = NUMOUT((BASEREG));\n Unspec(DISPL_TEMP) = BASEANDDISPLACEMENT & '0000111111111111'B;\n DISPL    = NUMOUT((DISPL_TEMP));\n\n Select (FLAG);\n   When ('I') do;\n     If BASEREG = 0 & R3 = 0 then SYMBOL = DISPL;\n     Else if BASEREG = 0 then SYMBOL = DISPL || '(' ||NUMOUT(R3)|| ')';\n     Else if R3 = 0      then SYMBOL = DISPL || '(,'|| BASE     || ')';\n     Else SYMBOL = DISPL || '(' ||NUMOUT(R3) || ',' || BASE     || ')';\n   End;\n   When ('L') do;\n     SYMBOL = DISPL || '(' || NUMOUT(R3+1) || ',' || BASE || ')' ;\n   End;\n   When ('M') do;\n     SYMBOL = DISPL || '(' || NUMOUT(R3) || ',' || BASE || ')' ;\n   End;\n   When ('S') do;\n     If BASEREG = 0 then SYMBOL = DISPL;\n     Else SYMBOL = DISPL || '(' || BASE || ')' ;\n   End;\n   Otherwise do;\n     SYMBOL = DISPL || '(' || BASE || ')' ;\n   End;\n End;\n\n Return (SYMBOL);\n\n End GEN_EFF_ADDR;\n\n /*******************************************************************/\n1\n ADD_START_POINT: Proc (ADDRESS) reorder;\n\n Dcl ADDRESS fixed(31) bin;\n\n SPQP = LOCATE (Addr(SPQ),ADDRESS);\n If SPQP = Null then do;\n   Allocate SPQE set(SPQP);\n   SPQE_ADDRESS     = ADDRESS;\n   SPQE_LENGTH      = 0;\n   SPQE_RELOCATION  = 0;\n   SPQE_LABEL       = '';\n   SPQE_NAME        = '';\n   SPQE_NAME2       = '';\n   SPQE_TYPE        = '';\n   SPQE_TYPE2       = '';\n   String(SPQE_FLAGS) = '00000000'B;\n   Call INSERT (SPQP,Addr(SPQ));\n End;\n\n SPQ.MOST_RECENT = SPQP;\n\n Return;\n\n End ADD_START_POINT;\n\n /*******************************************************************/\n1\n PROCESS_CESD: Proc;\n\n CESD_ESDID = CESD_FIRST_ESDID;\n\n XA_MODULE = (CESD_XA);\n\n Addr(CESD_PTR)->N = Addr(LOAD_PTR)->N + 8; /* Bump past CESD_PREFIX */\n Addr(END_PTR)->N = Addr(CESD_PTR)->N + CESD_COUNT;\n\n LOOP_CESD: Do while (Addr(CESD_PTR)->N < Addr(END_PTR)->N);\n\n   Allocate CEQE set(CEQP);  /* Create a CESD queue entry */\n   CEQE_ESDID = CESD_ESDID;\n   CEQE_NAME = CESD_NAME;\n   CEQE_ADDRESS = CESD_ADDRESS;\n   CEQE_LENGTH = CESD_LENGTH;\n   CEQE_IDREF = 0;\n   CEQE_FLAGS = CESD_SEGMENT;\n\n   Select (CESD_TYPE & '00001111'B);\n\n     When ('00000000'B) do;  /* Section definition */\n       CEQE_TYPE = 'SD';\n     End;\n\n     When ('00000011'B) do;  /* Label reference */\n       CEQE_TYPE = 'LR';\n       CEQE_IDREF = CESD_XA_IDREF;\n     End;\n\n     When ('00000100'B) do;  /* Private code    */\n       If \u00ac CESD_TYPE_BITS(4) then do;\n         CEQE_NAME = '$PRIVATE';\n         PRIVATE_CODE = '1'B;\n       End;\n       CEQE_TYPE = 'PC';\n     End;\n\n     When ('00000101'B) do;  /* Common          */\n       CEQE_TYPE = 'CM';\n     End;\n\n     When ('00000110'B) do;  /* Pseudo register */\n       CEQE_TYPE = 'PR';\n     End;\n\n     When ('00000111'B) do;  /* Null            */\n       CEQE_TYPE = 'NL';\n     End;\n\n     When ('00000010'B) do;  /* External reference      */\n       CEQE_TYPE = 'ER';\n     End;\n\n     When ('00001010'B) do;  /* Weak external reference */\n       CEQE_TYPE = 'WX';\n     End;\n\n     Otherwise do;\n       CEQE_TYPE = '??';\n       Put file(DPRINT) skip(1)\n             list('XDIS0009S Invalid CESD entry type '|| CESD_TYPE);\n     End;\n\n   End;\n\n   If CSECT_NAME = CEQE_NAME & Index('SD PC ER WX',CEQE_TYPE) \u00ac= 0\n      then do; /* Establish our csect */\n     ESDID = CESD_ESDID;\n     If CEQE_TYPE = 'ER' | CEQE_TYPE = 'WX' then do;\n       CSECT_LENGTH = -1;\n     End;\n     Else do;\n       CSECT_LENGTH = CESD_LENGTH;\n       CSECT_OFFSET = CESD_ADDRESS;\n       If ((XA_MODULE) & (CESD_SEGMENT \u00ac= '00000000'B)) then do;\n         If CESD_XA_RMODE then RMODE = 'ANY';\n         Else                  RMODE = '24 ';\n         Select ((CESD_SEGMENT & '00000011'B));\n           When ('00000010'B)  AMODE = '31 ';\n           When ('00000011'B)  AMODE = 'ANY';\n           Otherwise           AMODE = '24 ';\n         End;\n       End;\n     End;\n   End;\n\n   Call INSERT(CEQP,Addr(CEQ));  /*  Add CESD entry to queue */\n\n   CESD_ESDID = CESD_ESDID + 1;\n   Addr(CESD_PTR)->N = Addr(CESD_PTR)->N + Length(CESD_DATA);\n\n End LOOP_CESD;\n\n End PROCESS_CESD;\n\n /*******************************************************************/\n1\n PROCESS_CONTROL: Proc;\n\n MOVE_TEXT = '0'B;\n Addr(CONTROL_PTR)->N = Addr(LOAD_PTR)->N + 16 /* Length of prefix */\n                        + CONTROL_RLD_COUNT;  /* in case combo rec */\n Addr(END_PTR)->N = Addr(CONTROL_PTR)->N + CONTROL_CONTROL_COUNT;\n CONTROL_FIND_CSECT:\n Do while(Addr(CONTROL_PTR)->N < Addr(END_PTR)->N);\n   If CONTROL_ESDID = ESDID then do;\n     If TEXT_PTR = Null then do;\n       Allocate TEXT_BUFFER char(((CSECT_LENGTH+7)/8)*8);\n       TEXT_PTR = Addr(TEXT_BUFFER);\n     End;\n     TEXT_MOVE_OFFSET = Max(0, CONTROL_CCW_ADDRESS - CSECT_OFFSET);\n     TEXT_MOVE_SOURCE = Max(0, CSECT_OFFSET - CONTROL_CCW_ADDRESS);\n     TEXT_MOVE_LENGTH = CONTROL_LENGTH;\n     MOVE_TEXT = '1'B;\n     Leave CONTROL_FIND_CSECT;\n   End;\n  Addr(CONTROL_PTR)->N = Addr(CONTROL_PTR)->N + 4;\n End CONTROL_FIND_CSECT;\n\n End PROCESS_CONTROL;\n\n /*******************************************************************/\n1\n PROCESS_TEXT: Proc;\n\n If MOVE_TEXT then do;\n\n   Substr(TEXT_BUFFER,TEXT_MOVE_OFFSET+1,TEXT_MOVE_LENGTH) =\n     Substr(TEXT_DATA,TEXT_MOVE_SOURCE+1,TEXT_MOVE_LENGTH);\n\n End;\n\n End PROCESS_TEXT;\n\n /*******************************************************************/\n1\n PROCESS_RLD: Proc;\n\n Addr(RLD_PTR)->N = Addr(LOAD_PTR)->N + 16 /* Length of RLD_PREFIX */;\n Addr(END_PTR)->N = Addr(RLD_PTR)->N + RLD_RLD_COUNT;\n LOOP_RLD: Do while (Addr(RLD_PTR)->N < Addr(END_PTR)->N);\n\n   PROCESS_RLD_SUBENTRIES:\n   Do Addr(RLD_SUB_PTR)->N = Addr(RLD_PTR)->N + 4\n                             repeat Addr(RLD_SUB_PTR)->N + 4;\n     If RLD_POSITION_POINTER = ESDID then do;\n       Allocate RAQE set(RAQP);\n       RAQE_ADDRESS = RLD_ADDRESS - CSECT_OFFSET;\n       RAQE_LENGTH = RLD_LENGTH+1;\n       TEMP_PTR = LOCATE(Addr(CEQ),RLD_RELOCATION_POINTER);\n       If TEMP_PTR = Null then do;\n         RAQE_NAME = '';\n         RAQE_RELOCATION = 0;\n       End;\n       Else do;\n         RAQE_NAME = TEMP_PTR->CEQE_NAME;\n         RAQE_RELOCATION = TEMP_PTR->CEQE_ADDRESS;\n       End;\n       String(RAQE_FLAGS) = '00000000'B;\n       If RLD_NEGATIVE then RAQE_NEGATIVE = '1'B;\n       RAQE_UNRESOLVED = (Substr(RLD_TYPE,1,1));\n       RAQE_TYPE = Substr('AVPQ    AV      ',RLD_TYPE+1,1);\n       If RAQE_TYPE = 'A' then do;\n        If TEMP_PTR->CEQE_TYPE = 'WX' then RAQE_TYPE = 'W';\n        Else if TEMP_PTR->CEQE_TYPE = 'ER' then RAQE_TYPE = 'X';\n       End;\n       Call INSERT(RAQP,Addr(RAQ));\n     End;\n     If \u00ac RLD_SAME_RP then Leave PROCESS_RLD_SUBENTRIES;\n   End PROCESS_RLD_SUBENTRIES;\n\n   Addr(RLD_PTR)->N = Addr(RLD_SUB_PTR)->N + 4;\n\n End LOOP_RLD;\n\n End PROCESS_RLD;\n\n /*******************************************************************/\n1\n INSERT: Proc(E_PTR,Q_PTR) reorder;\n\n /* This subroutine inserts an element into a queue. */\n\n Dcl (E_PTR, Q_PTR) ptr,\n     P                    static ptr,\n     1 Q     like QUEUE          based(Q_PTR),\n     1 E                         based(E_PTR),\n       2 E_NEXT                  ptr,\n       2 E_PREV                  ptr,\n       2 E_ARG                   fixed(31) bin;\n\n P = Q.MOST_RECENT;\n If P \u00ac= Null &\n    E_ARG >= P->E_ARG &\n    (P->E_NEXT = Null | P->E_NEXT->E_ARG > E_ARG)\n   then;\n Else do P = Q.LAST repeat P->E_PREV while (P \u00ac= Null);\n   If E_ARG >= P->E_ARG &\n      (P->E_NEXT = Null | P->E_NEXT->E_ARG > E_ARG)\n     then Leave;\n End;\n E_PREV = P;\n If P \u00ac= Null then do;  /* not at top of queue */\n   E_NEXT = P->E_NEXT;\n   P->E_NEXT = E_PTR;\n End;\n Else do;               /* top of queue */\n   E_NEXT = Q.FIRST;\n   Q.FIRST = E_PTR;\n End;\n If E_NEXT = Null then Q.LAST = E_PTR;\n Else E_NEXT->E_PREV = E_PTR;\n\n End INSERT;\n\n /*******************************************************************/\n1\n DELETE: Proc(E_PTR,Q_PTR) reorder;\n\n /* This subroutine deletes an element from a queue. */\n\n Dcl (E_PTR, Q_PTR) ptr,\n     1 Q     like QUEUE          based(Q_PTR),\n     1 E                         based(E_PTR),\n       2 E_NEXT                  ptr,\n       2 E_PREV                  ptr;\n\n If E_PREV = Null then Q.FIRST = E_NEXT;\n Else E_PREV->E_NEXT = E_NEXT;\n\n If E_NEXT = Null then Q.LAST = E_PREV;\n Else E_NEXT->E_PREV = E_PREV;\n\n Free E;\n\n End DELETE;\n\n /*******************************************************************/\n1\n LOCATE: Proc(Q_PTR,ARG) returns(ptr) reorder;\n\n /* This subroutine locates an element in a queue. */\n\n Dcl (Q_PTR) ptr,\n     ARG    fixed(31) bin,\n     P                    static ptr,\n     1 Q     like QUEUE          based(Q_PTR),\n     1 E                         based(P),\n       2 E_NEXT                  ptr,\n       2 E_PREV                  ptr,\n       2 E_ARG                   fixed(31) bin;\n\n Do P = Q.FIRST repeat E_NEXT while (P \u00ac= Null);\n   If E_ARG = ARG then Leave;\n End;\n\n Q.MOST_RECENT = P;  /* Set ptr for easy access to element */\n\n Return(P);\n\n End LOCATE;\n\n /*******************************************************************/\n1\n NUMOUT: Proc(N) returns(char(14) var) reorder;\n\n Dcl N              fixed(31) bin,\n     N_CHAR  static char(14),\n     N_CHAR_VAR     char(14) var;\n\n N_CHAR = N;\n\n N_CHAR_VAR = Substr(N_CHAR,Verify(N_CHAR,' '));\n\n Return (N_CHAR_VAR);\n\n End NUMOUT;\n\n /*******************************************************************/\n1\n HEXNUM:Proc(NUMBER) returns(char(8)) reorder;\n\n /* This subroutine takes a binary fullword and returns the\n    character representation of the hexadecimal data therein. */\n\n Dcl NUMBER               fixed(31) bin,\n     PACKED_DATA   static fixed(9) dec,\n     PACKED_FOUR_BYTES    fixed(31) bin unaligned based,\n     HEXUNPACKED9  static pic '(9)9',\n     HEXSTRING            char(8)   def HEXUNPACKED9;\n\n Addr(PACKED_DATA)->PACKED_FOUR_BYTES = NUMBER;\n HEXUNPACKED9 = PACKED_DATA;\n HEXSTRING = Translate(HEXSTRING,TRANS_TABLE);\n\n Return(HEXSTRING);\n\n End HEXNUM;\n\n /*******************************************************************/\n1\n HEXOUT:Proc(INPUT) returns(char(1024) var) reorder;\n\n /* This subroutine takes a character string and returns the\n    character representation of the hexadecimal data therein. */\n\n Dcl INPUT                   char(*)    var,\n     PACKEDVALUE      static fixed (9)  dec unaligned,\n     HEXVALUE         based  char  (4)      unaligned,\n     HEXUNPACKED9     static pic '(9)9',\n     HEXDATA                 char(9)    def HEXUNPACKED9,\n     I                static fixed(15)  bin,\n     HEXSTRING               char(2*Length(INPUT)+4) var init('');\n\n Do I = 1 to Length(INPUT) by 4;\n\n   Addr(PACKEDVALUE)->HEXVALUE = Substr(INPUT,I);\n   HEXUNPACKED9 = PACKEDVALUE;\n   HEXSTRING = HEXSTRING || Translate(Substr(HEXDATA,1,8),TRANS_TABLE);\n\n End;\n\n Return(Substr(HEXSTRING,1,2*Length(INPUT)));\n\n End HEXOUT;\n\n /*******************************************************************/\n\n End XDIS;\n\n./ ENDUP\n?!\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDIS$$": {"ttr": 30986, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x08\\x8f\\x01\\x00\\x08\\x8f\\x18\\x14\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-03-28T00:00:00", "modifydate": "2000-03-28T18:14:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SBGOLOB"}, "text": "You were at the latest SHARE, weren't you?\n\nDid you happen to catch any talks about the assembler or the\ndisassembler?  Somehow the topic of disassemblers came up on the ASM370\nlist (I still call it that), and no less than John Erhman asked me\nabout mine.  So I'd like to know what, if anything, was said at SHARE\nabout disassemblers.\n\nIt also occurs to me that somehow my XDIS got lost in all the moving\nthings over from various dying FTP sites to the CBT tape.  I suppose I\nshould try to get it on there, but there are already two disassemblers\nthere, and it seems that at least one of them may have borrowed heavily\nfrom mine.\n\n - seb\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XDISNOTE": {"ttr": 30988, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x00\\x08\\x8f\\x01\\x00\\x08\\x8f\\x18\\x17\\x00\\x16\\x00\\x0f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-03-28T00:00:00", "modifydate": "2000-03-28T18:17:00", "lines": 22, "newlines": 15, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: Try this transmission\nDate: Tue, 28 Mar 2000 14:13:42 -0500 (EST)\nFrom: \"Stephen E. Bacher\" <seb@draper.com>\nTo: sbgolob@attglobal.net\n\nOK, I'm just going to mail the entire thing at once.\nI FTP'd it from MVS to my Unix box, so there should\nbe no problems with the character set.\n\nIf you still get circumflexes instead of lazy L's, just\ndo a global change.  Same for broken vs. solid vertical bars.\n\n - seb\n\n--------------------------------------------------------------\n\nNote:  After uploading to MVS, I did a global change\n\n    x'6a' to x'4f'      and      x'b0' to x'5f'\n\n - sbg\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XPROCA": {"ttr": 30990, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x02\\x01o\\x01\\x02\\x01o\\t\\x00\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-16T00:00:00", "modifydate": "2002-01-16T09:00:27", "lines": 18, "newlines": 18, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: XPROC\nDate: Tue, 15 Jan 2002 14:20:33 -0500 (EST)\nFrom: \"Stephen E. Bacher\" <seb@draper.com>\nTo: sbgolob@attglobal.net\n\nHi Sam,\n\nSteve McGinty of NCR just found a bug in XPROC and also\nfixed it.  I've just updated it with the fix (it's a\ncouple of lines here and there, nothing big), and I'd\nlike to send it to you to update the CBT file 431 with.\n\nHere's the new source.\n\nThanks for all your work.\n\n - seb\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XRXVARS": {"ttr": 31233, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x07o\\x01\\x00\\x07o\\x17Q\\x00\\xf6\\x00\\xf6\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-03-16T00:00:00", "modifydate": "2000-03-16T17:51:00", "lines": 246, "newlines": 246, "modlines": 0, "user": "SBGOLOB"}, "text": "*\n***********************************************************************\n*                                                                     *\n* XRXVARS - Author: Stephen E. Bacher 18 September 1989               *\n*                                                                     *\n***********************************************************************\n*\n***********************************************************************\n*\n*  This routine returns the names of all current REXX variables and\n*  queues them on the REXX data stack.  The names are selected based\n*  on a prefix given in the parameter field.\n*\n*  Particularly useful if a stem (varname.) is given as the argument.\n*\n*  Invocation:  CALL 'wherever.load(XRXVARS)' 'variable-prefix'\n*\n***********************************************************************\n         PRINT NOGEN\nXRXVARS  CSECT\nXRXVARS  AMODE 31\nXRXVARS  RMODE ANY\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12),,XRXVARS_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XRXVARS,R12\n         LR    R2,R1               Save parameter address\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R1,8(,R13)\n         ST    R13,4(,R1)\n         LR    R13,R1\n         USING DATD,R13\n         MVI   FLAGS,0             Random initializations\n         L     R4,0(,R2)           Get address of parm string\n         LH    R3,0(,R4)           R3 = length of parm\n         LA    R4,2(,R4)           R4 = address of parm\n         LOAD  EP=IRXSTK                Get address of IRXSTK routine\n         ST    R0,@IRXSTK               Save it\n         LOAD  EP=IRXEXCOM              Get address of IRXEXCOM routine\n         ST    R0,@IRXEXCO              Save it\n*\n***********************************************************************\n*                                                                     *\n* Invoke the IRXEXCOM routine to retrieve all variable names.         *\n*                                                                     *\n* Reference: TSO/E Version 2 REXX Reference, pp. 240-246              *\n*                                                                     *\n***********************************************************************\n*\n* Build the SHVBLOCK\n*\n* To store the argument value, we try using ARGWA, a 512-byte area\n* that is already part of our workarea, to avoid unnecessary GETMAINs.\n*\n* If that doesn't turn out to be big enough, we'll have to GETMAIN,\n* but it's best to avoid that.\n*\nCONTINUE DS    0H\n         XC    VARNAME(L'VARNAME),VARNAME\n         XC    SHVBLOCK(SHVBLEN),SHVBLOCK\n         MVI   SHVCODE,SHVNEXTV    Fetch \"next\" variable\n         LA    R1,L'VARNAME\n         ST    R1,SHVUSER          Length of name buffer\n         LA    R1,VARNAME\n         ST    R1,SHVNAMA          Address of name buffer\n         LA    R1,1\n         ST    R1,SHVBUFL          Length of dummy value buffer\n         LA    R1,DUMBUF\n         ST    R1,SHVVALA          Address of dummy value buffer\n*                 SHVNAML will contain the length of the name returned\n         LA    R14,=CL8'IRXEXCOM'  IRXEXCOM parm 1\n         XR    R15,R15             IRXEXCOM parm 2\n         LR    R0,R15              Parm 3 must be same as Parm 2\n         LA    R1,SHVBLOCK         IRXEXCOM parm 4\n         STM   R14,R1,IRPARMS\n         OI    IRPARM4,X'80'\n         XR    R0,R0               Don't specify an environment block\n         L     R15,@IRXEXCO        Get address of IRXEXCOM\n         LA    R1,IRPARMS          Point to parameter list\n         BALR  R14,R15             Call REXX arg access routine\n         LTR   R15,R15             Check RC\n         BM    BADEXCOM\n         TM    SHVRET,SHVLVAR      If no more variables\n         BO    ENDIT               then finished\n*\n* Compare variable prefix here...\n*\n         LTR   R15,R3\n         BZ    QUEUEIT             If no prefix given, accept all\n         BCTR  R15,0               Else reduce length for execute\n         EX    R15,CLCNAME         If prefix doesn't match\n         BNE   CONTINUE            then continue\nQUEUEIT  DS    0H\n*\n* Queue line onto REXX data stack\n*\n         MVC   IRFUNCT,=CL8'QUEUE'\n         LA    R1,VARNAME\n         ST    R1,IRSTRADR\n         L     R1,SHVNAML\n         ST    R1,IRSTRLEN\n         XR    R1,R1\n         ST    R1,IRRETCD\n         LA    R14,IRFUNCT\n         LA    R15,IRSTRADR\n         LA    R0,IRSTRLEN\n         LA    R1,IRRETCD\n         STM   R14,R1,IRPARMS\n         OI    IRPARM4,X'80'\n         XR    R0,R0               Don't specify an environment block\n         LA    R1,IRPARMS          Point to parameter list\n         L     R15,@IRXSTK         Get address of IRXSTK\n         BALR  R14,R15             Call REXX stack access routi ne\n         LTR   R15,R15             Check rc\n         BNZ   BADSTK\nSTACKOK  DS    0H                  R15 = 0\n         B     CONTINUE\n         SPACE 1\nENDIT    DS    0H\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        Store return code in save area\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         SPACE 1\nERROR    DS    0H\n         L     R15,=F'-1'          Load error code\n         B     ENDIT\n         SPACE 1\nBADEXCOM DS    0H\n         LA    R1,1111             U1111 for error in IRXEXCOM\n         ABEND (1)\n         SPACE 1\nBADSTK   DS    0H\n         LR    R1,R15              Make abend code the return code\n         ABEND (1)\n         SPACE 1\n         EJECT\nCLCNAME  CLC   0(*-*,R4),VARNAME   Executed: compare variable prefix\n         EJECT\nDATD     DSECT\nSAVEAREA DS    18F\n@IRXSTK  DS    A                   Address of REXX stack routine\n@IRXEXCO DS    A                   Address of REXX access routine\nFLAGS    DC    X'00'               Flags\n*        EQU   B'10000000'          Reserved\n*        EQU   B'01000000'          Reserved\n*        EQU   B'00100000'          Reserved\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n*\nVARNAME  DS    CL256               Area where variable name is returned\nDUMBUF   DS    CL1                 We don't care about the value\n*\nIRPARMS  DS    0A                  Parameter list for IRX routines\nIRPARM1  DS    A                   Address of parameter 1\nIRPARM2  DS    A                   Address of parameter 2\nIRPARM3  DS    A                   Address of parameter 3\nIRPARM4  DS    A                   Address of parameter 4\n*                                  Parameters used by IRXSTK\nIRFUNCT  DS    CL8                 Parameter 1: function to perform\nIRSTRADR DS    CL8                 Parameter 2: address of string\nIRSTRLEN DS    CL8                 Parameter 3: length of string\nIRRETCD  DS    CL8                 Parameter 4: return code\n*                                  Parameters used by IRXEXCOM\n*\n***********************************************************************\n*                                                                     *\n* Copied from 'SYS1.MACLIB(IRXSHVB)'.                                 *\n*                                                                     *\n***********************************************************************\n*\nSHVBLOCK DS    0D                     SHARED VARIABLE REQUEST BLOCK\nSHVNEXT  DS  A                        Chain pointer to next SHVBLOCK\nSHVUSER  DS  F                        Used during \"FETCH NEXT\"\n*                                      Contains length of buffer\n*                                      pointed to by SHVNAMA\nSHVCODES DS  0F\nSHVCODE  DS  CL1                      Function code - indicates type\n*                                      of variable access request\nSHVRET   DS  XL1                      Return codes\n         DS  H'0'                     Reserved (should be 0)\nSHVBUFL  DS  F                        Length of fetch value buffer\nSHVNAMA  DS  A                        Address of variable name\nSHVNAML  DS  F                        Length of variable name\nSHVVALA  DS  A                        Address of value buffer\nSHVVALL  DS  F                        Length of value buffer\n*                                      (Set on fetch)\nSHVBLEN  EQU *-SHVBLOCK               Length of SHVBLOCK\n         SPACE 1\n**********************************************************************/\n*   SHARED VARIABLE REQUEST BLOCK - function codes                   */\n**********************************************************************/\n         SPACE 1\nSHVFETCH EQU   C'F'            Copy value of shared variable\nSHVSTORE EQU   C'S'            Set variable from given value\nSHVDROPV EQU   C'D'            Drop variable\nSHVSYFET EQU   C'f'            Symbolic name retrieve\nSHVSYSET EQU   C's'            Symbolic name set\nSHVSYDRO EQU   C'd'            Symbolic name drop\nSHVNEXTV EQU   C'N'            Fetch \"next\" variable\nSHVPRIV  EQU   C'P'            Fetch private information\n         SPACE 1\n**********************************************************************/\n*        SHARED VARIABLE REQUEST BLOCK - return codes (SHVRET)       */\n**********************************************************************/\n        SPACE 1\nSHVCLEAN EQU   X'00'           Execution was OK\nSHVNEWV  EQU   X'01'           Variable did not exist\nSHVLVAR  EQU   X'02'           Last variable transferred (\"N\")\nSHVTRUNC EQU   X'04'           Truncation occurred for \"Fetch\"\nSHVBADN  EQU   X'08'           Invalid variable name\nSHVBADV  EQU   X'10'           Invalid value specified\nSHVBADF  EQU   X'80'           Invalid function code (SHVCODE)\n         SPACE 1\n**********************************************************************/\n*        R15 return codes                                            */\n**********************************************************************/\n         SPACE 1\nSHVRCOK  EQU    0              Entire Plist chain processed\nSHVRCINV EQU   -1              Invalid entry conditions\nSHVRCIST EQU   -2              Insufficient storage available\n         SPACE 1\nSIZDATD  EQU   *-DATD\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XRXVARS#": {"ttr": 31238, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x00\\x07o\\x01\\x00\\x07o\\x185\\x00&\\x00\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-03-16T00:00:00", "modifydate": "2000-03-16T18:35:00", "lines": 38, "newlines": 22, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: XRXVARS -- who wrote it?\nDate: Sat, 11 Mar 2000 21:11:19 EST\nFrom: \"D.J. Glazier\" <RexxTime@AOL.COM>\n\nHello,\n\nI downloaded an ASM program XRXVARS which places all active REXX\nvariables into the STACK.  It is great, but I lost the originator of\nthis program.  Does anyone know who wrote this program?\n\nThank you,\n\nDonald J. Glazier I.\n\n ------------------------------------------------------------------\n\n\"D.J. Glazier\" wrote:\n\n> I downloaded an ASM program XRXVARS which places all active\n> REXX variables into the STACK.  It is great, but I lost the\n> originator of this program.  Does anyone know who wrote this\n> program?\n\nMark Zelden wrote:\n\n>Did you search the archives? I just did and came up with\n>Stephen E. Bacher - posted to this list on 12/14/1999.\n\n\"D.J. Glazier\" wrote:\n\n>A million thanks!!!\n\n\nWow - I didn't even remember I put that out there.  Maybe I should\ncontribute that one to the CBT tape...\n\n        - seb\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XR991214": {"ttr": 31240, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x00\\x07o\\x01\\x00\\x07o\\x18)\\x00_\\x01L\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-03-16T00:00:00", "modifydate": "2000-03-16T18:29:00", "lines": 95, "newlines": 332, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: TSO-REXX Digest - 13 Dec 1999 to 14 Dec 1999 (#1999-205)\nDate: Wed, 15 Dec 1999 00:00:53 -0500\nFrom: Automatic digest processor <LISTSERV@VM.MARIST.EDU>\nReply-To: TSO REXX Discussion List <TSO-REXX@VM.MARIST.EDU>\nTo: Recipients of TSO-REXX digests <TSO-REXX@VM.MARIST.EDU>\n\nThere are 4 messages totalling 323 lines in this issue.\n\nTopics of the day:\n\n  1. Obtaining a list of variables set (4)\n\n    ---------------------------------------------------------------------\nSubject: Obtaining a list of variables set\nDate: Mon, 13 Dec 1999 20:07:26 -0800\nFrom: Jon Perryman <jon.perryman@WORLDNET.ATT.NET>\n\nDoes anyone know how get a list of rexx variables that have been set?\n\nThanks, Jon Perryman.\n\n    ---------------------------------------------------------------------\n\nSubject: Re: Obtaining a list of variables set\nDate: Mon, 13 Dec 1999 23:54:01 -0500\nFrom: Doug Nadel <somebody@MINDSPRING.COM>\n\nOn Mon, 13 Dec 1999 20:07:26 -0800, \"Jon Perryman\"\n<jon.perryman@worldnet.att.net> wrote:\n\n>Does anyone know how get a list of rexx variables that have been set?\n>\n>Thanks, Jon Perryman.\n>\n\nYou can write a small asm program to call the rexx service interface\nto get them.  If no one has one I'm sure I can dig one up.  I suspect\nGilbert has one somewhere, though.\n\nDoug Nadel\n----------------------------------------\nISPF & OS/390 Tools & Toys page:\nhttp://www.mindspring.com/~somebody/\n\n    ---------------------------------------------------------------------\n\nSubject: Re: Obtaining a list of variables set\nDate: Tue, 14 Dec 1999 08:55:02 -0500\nFrom: \"Stephen E. Bacher\" <seb@DRAPER.COM>\n\nHere's a program that does it.   (Text of the XRXVARS program follows)\n\n - seb\n            (See member XRXVARS in this pds.)\n\n    ---------------------------------------------------------------------\n\nSubject: Re: Obtaining a list of variables set\nDate: Tue, 14 Dec 1999 10:04:38 -0500\nFrom: \"Metz, Seymour\" <smetz@NSF.GOV>\n\nYou can't do it from within REXX, but it's fairly simple to write an\nassembler routine to extract the names and pass them back to the caller.\n\nShmuel (Seymour J.) Metz\n\n> -----Original Message-----\n> From: Jon Perryman [SMTP:jon.perryman@WORLDNET.ATT.NET]\n> Sent: Monday, December 13, 1999 11:07 PM\n> To:   TSO-REXX@VM.MARIST.EDU\n> Subject:      Obtaining a list of variables set\n>\n> Does anyone know how get a list of rexx variables that have been set?\n\n    ---------------------------------------------------------------------\n\nSubject: Re: Obtaining a list of variables set\nDate: Tue, 14 Dec 1999 10:18:23 -0500\nFrom: Gilbert Saint-flour <gsf@IBM.NET>\n\nOn 13 Dec 1999 at 23:54, Doug Nadel <somebody@MINDSPRING.COM> said:\n\n>>Does anyone know how get a list of rexx variables that have been set?\n\n>You can write a small asm program to call the rexx service\n>interface to get them.  If no one has one I'm sure I can dig one\n>up.  I suspect Gilbert has one somewhere, though.\n\nActually, I don't think I do.  There is a REXX exec called VARS in\nmy file on the CBT tape but it has nothing to do with REXX\nvariables: it retrieves shared and profile variables from wherever\nit can find them in ISPF control blocks.\n\n Gilbert Saint-flour\n http://members.home.net/gsf/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT431/FILE431.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT431", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}