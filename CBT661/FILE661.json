{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012545000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE661.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE661.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x0c'", "DS1TRBAL": "b'\\x1e\\x8c'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xb6\\x00\\x00\\x04\\xb6\\x00\\x04\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\x08?\\x01\\x06\\x08?\\x17(\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-03-24T00:00:00", "modifydate": "2006-03-24T17:28:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-472"}, "text": "REGULAR CBT TAPE - VERSION 472    FILE:  661\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT472.FILE661\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 13 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,550 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/24/06    17:28:40    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00D\\x01\\x04\\x02\\x9f\\x01\\x06\\x07O\\x12Q\\x009\\x00\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd4\\xf4@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-01-29T00:00:00", "modifydate": "2006-03-15T12:51:44", "lines": 57, "newlines": 21, "modlines": 0, "user": "SYSPM4"}, "text": "*--$$README-----------------------------------------------------------*\n\n   HOTRDR documentation:\n\n   The HOTRDR routine was written to submit JCL members for batch\n   processing to the internal reader from multiple PDS libaraies.\n   I have use it as a started task to submit batch jobs during IPL time\n   and through the daily workload processing by the operations staff.\n\n   Mulitple symbolic PDS libaraies (LRECL=80) may be concatenated on\n   the PDS DD statement.  PDS libraries with a large block sizes work\n   best and reduce the I/O activity (BLKSIZE=27920).  I have 6 large\n   PDS libraries concatenated in our HOTRDR procedure currently and\n   have no idea what the limit would be, we are currently at z/OS V1.6\n\n   The JCL member name to be submitted is passed to the HOTRDR routine\n   through the PARM field.  The first occurance of the JCL member name\n   found in the PDS concatenation is the member submitted.  To avoid\n   multiple JCL member names in the concatenation list we use a member\n   naming convention based on the task to be performed, the first 3\n   characters of the member name, i.e. SYS for a systems task, BKU for\n   a backup job, ADP for an application job, etc.\n\n   The HOTRDR routine is written in IBM assembler (ASMA90) and uses\n   the BSAM access method and macros FIND, READ, and CHECK.  See the\n   source code comments for additional information on macro usage.\n\n   The source library contains the following:\n\n   $$README - this member.\n   $CLEAR - a macro to clear fields to a specified fill character. If\n            LONG is specified a MVCL instruction is generated.\n   $EX    - a macro used to generate EX instructions on the fly.\n   ASMARDR - the JCL procedure to assemble and link the HOTDRDR source.\n   CONVERT - a macro to convert HEX fields to printable characters. I\n            use this macro to print return and reason codes.\n   ESAENTRY - a macro for conventional assembly routine entry and\n            obtaining a save/work area.  Handy for rentrant code.\n   ESAEXIT - a macro used in conjunction with the ESAENTRY macro to do\n            save/work area clean-up and assembly routine exiting.\n   HOTRDR - the assembly source code for the HOTRDR routine.\n   PARMS  - a macro to handle the passing of parm fields.\n   WTOL   - a macro to issue WTO messages with variable fields within\n          the message.\n\n   Note:  Some of these macros are old and have not been revised over\n          the years I've used them.  Most of them are downward\n          compatable with earlier version of OS/390 (MVS).\n\n   Author:\n   Peter McFarland\n   ADP Tax & Financial Services\n   San Diego, CA. 92127\n   (858) 385-2718\n   peter_mcfarland@adp.com\n\n*--$$README-----------------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CLEAR": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x00\\x92\\t\\x8f\\x01\\x06\\x07O\\x129\\x00\\x1c\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd4\\xf4@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1992-04-07T00:00:00", "modifydate": "2006-03-15T12:39:27", "lines": 28, "newlines": 26, "modlines": 0, "user": "SYSPM4"}, "text": "         MACRO\n.*       THIS MACRO IS USED TO CLEAR A FIELD TO THE SPECIFIED FILL\n.*       VALUE,  THE DEFAULT IS BLANKS, X'40'.\n         $CLEAR &FLD,&LEN,&TYPE,&FILL=C' '\n         LCLC  &L\n&L       SETC  'L'''\n         AIF   ('&TYPE' EQ 'LONG').DO_MVCL\n         MVI   &FLD,&FILL\n         MVC   &FLD+1(&L&FLD-1),&FLD\n         MEXIT\n.DO_MVCL ANOP\n         AIF   ('&FLD'(1,1) EQ '(').REG0\n         LA    R0,&FLD                 AREA ADDRESS\n         AGO   .OK0\n.REG0    ANOP\n         AIF   ('&FLD' EQ '(R0)').OK0\n         LR    R0,&FLD(1)              AREA ADDRESS\n.OK0     ANOP\n         AIF   ('&LEN'(1,1) EQ '(').REG1\n         LA    R1,&LEN                 AREA LENGTH\n         AGO   .OK1\n.REG1    ANOP\n         AIF   ('&LEN' EQ '(R1)').OK1\n         LR    R1,&LEN(1)              AREA LENGTH\n.OK1     ANOP\n         SLR   R15,R15                 NO OPERAND 2 / FILL =0\n         MVCL  R0,R14                  ZERO OUT AREA\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$EX": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x04\\x01_\\x01\\x06\\x07O\\x12F\\x00H\\x00G\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd4\\xf4@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-01-15T00:00:00", "modifydate": "2006-03-15T12:46:46", "lines": 72, "newlines": 71, "modlines": 0, "user": "SYSPM4"}, "text": "         MACRO\n         $EX   &REG,&INST\n.*--------------------------------------------------------------------*\n.*\n.*  THIS MACRO WILL GENERATE AN EXECUTE INSTRUCTION, AND THEN TABLE\n.*  FOR LATER USE THE EXECUTED INSTRUCTION WHICH IS OF THE FORM:\n.*      (EXINST,OP1,OP2,OP3)                                   05/15/83\n.*\n.*  THE EXECUTED INSTRUCTIONS ARE GENERATED WHEN &REG IS 'GENERATE'\n.*  TAURUS SOFTWARE CONSULTANTS - PETER MCFARLAND CONSULTANT\n.*\n.*--------------------------------------------------------------------*\n         GBLA  &$EX#  COUNT OF SAVED EXECUTED INSTRUCTIONS\n         GBLC  &$EXIN(50)  SAVED INSTRUCTION OPCODES\n         GBLC  &$EXOP(50)  SAVED INSTRUCTION OPERANDS\n         GBLC  &$EXCS(50)  SAVED INSTRUCTION CSECTS\n         LCLA  &M,&N  INTERNAL WORK VARIABLES\n         LCLC  &OPCOD,&OPNDS,&CSAVE\n         AIF   ('&REG' EQ 'GENERATE').GEN EXECUTED INSTRUCTIONS\n         AIF   (T'&REG NE 'O').RSPEC\n         MNOTE 8,'REGISTER INVALID'\n         MEXIT\n.*\n.RSPEC   ANOP\n         AIF   (N'&INST GE 3).INSTS                           05/15/83\n         MNOTE 8,'INSTRUCTION INVALID'\n         MEXIT\n.*\n.INSTS   ANOP\n&OPCOD   SETC  '&INST(1)'                                     05/15/83\n&M       SETA  K'&INST-K'&INST(1)-3 LENGTH WITHOUT OPCODE AND PARENS5/\n&OPNDS   SETC  '&INST'(K'&INST(1)+3,&M) EXTRACT OPERANDS      05/15/83\n&N       SETA  1\n.DUPTEST ANOP\n         AIF   (&N GT &$EX#).NOK\n         AIF  ('&$EXIN(&N)' EQ '&OPCOD' AND '&$EXOP(&N)' EQ '&OPNDS'   +\n               AND '&$EXCS(&N)' EQ '&SYSECT').GENEX\n&N       SETA  &N+1\n         AIF   (&N LE 50).DUPTEST\n         MNOTE 8,'INSTRUCTION DUPLICATED'\n         MEXIT\n.*\n.NOK     ANOP\n.*             NO DUPLICATE FOUND, SO ADD THIS INSTRUCTION TO TABLE\n&$EXIN(&N) SETC '&OPCOD'\n&$EXOP(&N) SETC '&OPNDS'\n&$EXCS(&N) SETC '&SYSECT'\n&$EX#      SETA &N\n.GENEX   ANOP\n         EX    &REG,@@EX&N\n         MEXIT\n.*\n.*\n.*   THIS PORTION IS USED TO GENERATE THE SAVED EXECUTED INSTRUCTIONS\n.*\n.*\n.GEN     ANOP\n&CSAVE   SETC  '&SYSECT'\n&N       SETA  1\n.GENXT   ANOP\n         AIF   (&N GT &$EX#).EXIT\n         AIF   ('&CSAVE' EQ '&$EXCS(&N)').NOCSCT\n&CSAVE   SETC  '&$EXCS(&N)'\n&CSAVE   CSECT\n.NOCSCT  ANOP\n@@EX&N   &$EXIN(&N)  &$EXOP(&N)\n&N       SETA  &N+1\n         AGO   .GENXT\n.EXIT    ANOP\n&$EX#    SETA  0\n&SYSECT  CSECT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE661": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\x08?\\x01\\x06\\x08?\\x17(\\x00J\\x00J\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-03-24T00:00:00", "modifydate": "2006-03-24T17:28:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "CBT-472"}, "text": "//***FILE 661 is from Peter McFarland and contains his HOTRDR       *   FILE 661\n//*           package to submit jobs to the internal reader from    *   FILE 661\n//*           pds libraries.  More detailed documentation of the    *   FILE 661\n//*           package follows:                                      *   FILE 661\n//*                                                                 *   FILE 661\n//*             Author:                                             *   FILE 661\n//*             Peter McFarland                                     *   FILE 661\n//*             ADP Tax & Financial Services                        *   FILE 661\n//*             San Diego, CA. 92127                                *   FILE 661\n//*             (858) 385-2718                                      *   FILE 661\n//*             peter_mcfarland@adp.com                             *   FILE 661\n//*                                                                 *   FILE 661\n//*     HOTRDR documentation:                                       *   FILE 661\n//*                                                                 *   FILE 661\n//*     The HOTRDR routine was written to submit JCL members        *   FILE 661\n//*     for batch processing to the internal reader from            *   FILE 661\n//*     multiple PDS libaraies.  We use it as a started task        *   FILE 661\n//*     to submit batch jobs during IPL time and through the        *   FILE 661\n//*     daily workload processing by the operations staff.          *   FILE 661\n//*                                                                 *   FILE 661\n//*     Mulitple symbolic PDS libaraies (LRECL=80) may be           *   FILE 661\n//*     concatenated on the PDS DD statement.  PDS libraries        *   FILE 661\n//*     with a large block sizes work best and reduce the I/O       *   FILE 661\n//*     activity (BLKSIZE=27920).  I have 6 large PDS               *   FILE 661\n//*     libraries concatenated in our HOTRDR procedure              *   FILE 661\n//*     currently and have no idea what the limit would be (we      *   FILE 661\n//*     are currently at z/OS 1.2).                                 *   FILE 661\n//*                                                                 *   FILE 661\n//*     The JCL member name to be submitted is passed to the        *   FILE 661\n//*     HOTRDR routine through the PARM field.  The first           *   FILE 661\n//*     occurance of the JCL member name found in the PDS           *   FILE 661\n//*     concatenation is the member submitted.  To avoid            *   FILE 661\n//*     multiple JCL member names in the concatenation list we      *   FILE 661\n//*     use a member naming convention based on the task to be      *   FILE 661\n//*     performed, the first 3 characters of the member name,       *   FILE 661\n//*     i.e. SYS for a systems task, BKU for a backup job, ADP      *   FILE 661\n//*     for an application job, etc.                                *   FILE 661\n//*                                                                 *   FILE 661\n//*     The HOTRDR routine is written in IBM assembler              *   FILE 661\n//*     (ASMA90) and uses the BSAM access method and macros         *   FILE 661\n//*     FIND, READ, and CHECK.  See the source code comments        *   FILE 661\n//*     for additional information on macro usage.                  *   FILE 661\n//*                                                                 *   FILE 661\n//*     The source library contains the following:                  *   FILE 661\n//*                                                                 *   FILE 661\n//*     $$README - this member.                                     *   FILE 661\n//*     $CLEAR   - a macro to clear fields to a specified fill      *   FILE 661\n//*                character. If LONG is specified a MVCL           *   FILE 661\n//*                instruction is generated.                        *   FILE 661\n//*     $EX      - a macro used to generate EX instructions on      *   FILE 661\n//*                the fly.                                         *   FILE 661\n//*     ASMARDR  - the JCL procedure to assemble and link the       *   FILE 661\n//*                HOTDRDR source.                                  *   FILE 661\n//*     CONVERT  - a macro to convert HEX fields to printable       *   FILE 661\n//*                characters. I use this macro to print            *   FILE 661\n//*                return and reason codes.                         *   FILE 661\n//*     ESAENTRY - a macro for conventional assembly routine        *   FILE 661\n//*                entry and obtaining a save/work area.            *   FILE 661\n//*                Handy for rentrant code.                         *   FILE 661\n//*     ESAEXIT  - a macro used in conjunction with the             *   FILE 661\n//*                ESAENTRY macro to do save/work area              *   FILE 661\n//*                clean-up and assembly routine exiting.           *   FILE 661\n//*     HOTRDR   - the assembly source code for the HOTRDR          *   FILE 661\n//*                routine.                                         *   FILE 661\n//*     PARMS    - a macro to handle the passing of parm            *   FILE 661\n//*                fields.                                          *   FILE 661\n//*     WTOL     - a macro to issue WTO messages with variable      *   FILE 661\n//*                fields within the message.                       *   FILE 661\n//*                                                                 *   FILE 661\n//*     Note:  Some of these macros are old and have not been       *   FILE 661\n//*            revised over the years I've used them.  Most of      *   FILE 661\n//*            them are downward compatable with earlier            *   FILE 661\n//*            version of OS/390 (MVS).                             *   FILE 661\n//*                                                                 *   FILE 661\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMARDR": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x04\\x02\\x1f\\x01\\x04\\x02\\x1f\\x14V\\x00\\x1a\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd4\\xf4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-01-21T00:00:00", "modifydate": "2004-01-21T14:56:25", "lines": 26, "newlines": 33, "modlines": 0, "user": "SYSPM4"}, "text": "//SYSASMHR JOB (SYS,0000),'HOTRDR BUILD',NOTIFY=&SYSUID,\n//         CLASS=S,MSGLEVEL=(2,0),MSGCLASS=T,\n//         TIME=30,PERFORM=7,REGION=4M,\n//         USER=,GROUP=,PASSWORD=                             /*RACF*/\n//ASMA     PROC MEMBER=WHATEVER\n//ASM      EXEC PGM=ASMA90,\n//  PARM='NODECK,XREF(SHORT),USING(NOLIMIT,MAP,WARN(8))'\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYSPM4.HOTRDR.SRC,DISP=SHR  /* HOTRDR MACRO LIB */\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),UNIT=VIO,\n//             DCB=BUFNO=1\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=VIO,\n//             DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//SYSIN    DD  DSN=SYSPM4.HOTRDR.SRC(&MEMBER),DISP=SHR  /* SOURCE LIB\n//LKED     EXEC PGM=HEWL,COND=(4,LT,ASM),\n//     PARM='MAP,LET,LIST,NCAL,AC(1)'\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=VIO,\n//             DCB=BUFNO=1\n//SYSLMOD  DD  DSN=SYSPM4.ASM.LINKLIB(&MEMBER),DISP=SHR  /* LINK LIB\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//  PEND\n//  EXEC  ASMA,MEMBER=HOTRDR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONVERT": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x03\\x00\\x92'o\\x01\\x06\\x07O\\x12H\\x00\\x1c\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd4\\xf4@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-10-02T00:00:00", "modifydate": "2006-03-15T12:48:03", "lines": 28, "newlines": 27, "modlines": 0, "user": "SYSPM4"}, "text": "         MACRO\n         CONVERT  &REG\n         LCLC  &GNAME\n         GBLB  &@@@CNVT\n&GNAME   SETC  'TSC'.'&SYSNDX'\n.*>>>>         CONVERT HEX CHARACTERS TO PRINTABLE FORMAT.....   $PMCF*\n.*>>>>         REGISTER FORMAT IS AS FOLLOWS;                         *\n.*>>>>         FIRST REGISTER POINTS TO THE RECEIVING FIELD           *\n.*>>>>         SECOND REGISTER POINTS TO THE HEX FIELD                *\n.*>>>>         THIRD REGISTER CONTAINS THE LENGTH OF HEX CHARACTERS   *\n.*>>>>         TO BE CONVERTED.                                  $PMCF*\n.*       TAURUS SOFTWARE CONSULTANTS - PETER MCFARLAND CONSULTANT\n&GNAME.A DS    0H                 CONVERT HEX TO PRINTABLE CHARS.\n         MVO   0(2,&REG(1)),0(1,&REG(2)) ADJUST OFFSET\n         MVN   1(1,&REG(1)),0(&REG(2)) SET NUMERIC CHAR.\n         NI    1(&REG(1)),X'0F'        FLIP UNWANTED BITS OFF\n         TR    0(2,&REG(1)),@@@CNVRT   TRANSLATE THE BYTE\n         LA    &REG(1),2(0,&REG(1))    BUMP UP\n         LA    &REG(2),1(0,&REG(2))      THE REGISTERS.\n         BCT   &REG(3),&GNAME.A        CONVERT AGAIN IF REG. NZERO\n         AIF   (&@@@CNVT).NOTABL       SKIP TRAN-TABLE AND BRANCH\n.*                                     IF WE ALREADY HAVE ONE\n&@@@CNVT SETB  1\n         B     &GNAME.B                BRANCH AROUND TR TABLE\n@@@CNVRT DC    C'0123456789ABCDEF'     CHARACTER STRING FOR TR INST.\n&GNAME.B DS    0H\n.NOTABL  ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ESAENTRY": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00D\\x00\\x92\\t\\x8f\\x01\\x06\\x07O\\x12E\\x00x\\x00k\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd4\\xf4@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1992-04-07T00:00:00", "modifydate": "2006-03-15T12:45:44", "lines": 120, "newlines": 107, "modlines": 0, "user": "SYSPM4"}, "text": "         MACRO\n&NAME    ESAENTRY &PAR0=R10,&PAR1=R11,                                 +\n               &SAVE=ALL,&BASEREGS=1,&WORKLEN=,&SP=3\n.*\n.* ESAENTRY USED IN CONJUNCTION WITH THE ESAEXIT MACRO, 06/27/89/$PMCF\n.* Change Log: Added lower case eyecatcher & equates.   03/12/97/$PMCF\n.* (TM)  TAURUS SOFTWARE CONSULTANTS - PETER MCFARLAND CONSULTANT\n.*\n         GBLC  &WRKLEN                 GETMAIN LENGTH\n         GBLC  &SPOOL                  SUBPOOL\n&NAME    CSECT\n         USING &NAME,R15               ESTABLISH TEMP. ADDRESSING\n         B     MSTART                  BRANCH AROUND IDENTFIERS\n         DC    AL1(MODIDL)             ID LENGTH\nMODID    DC    C' &NAME  '             MODULE NAME\n         DC    C'&SYSDATE '            ASSEMBLY DATE\n         DC    C'&SYSTIME '            ASSEMBLY TIME\n         DC  C'Copyright (C) 1988-2099, Taurus Software Consultants,'\n         DC  C' All Rights Reserved.'\nMODIDL   EQU   *-MODID                 GENERATE ID LENGTH\n*\n         PRINT NOGEN\n.*             Register Equates\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n.*             Equates\nZERO     EQU   0\nONE      EQU   1\nNOT      EQU   X'FF'\nD0       EQU   0\nD4       EQU   4\nD8       EQU   8\nD12      EQU   12\nD16      EQU   16\nD20      EQU   20\nD24      EQU   24\nD28      EQU   28\n         PRINT GEN\n.* SAVE=ALL                    SAVE REGISTERS R14,R15,R0-R12\n.* SAVE=R14                    SAVE REGISTER R14 IN R13\n.*\nMSTART   DS    0H\n         AIF   ('&SAVE' NE 'ALL').SVCHK1\n         STM   R14,R12,12(R13)         SAVE REGISTERS\n         AGO   .PARM\n.*\n.SVCHK1  ANOP\n         AIF   ('&SAVE' NE 'R14').SVERR\n         LR    R13,R14                 SAVE REGISTER R14\n         AGO   .PARM\n.*\n.SVERR   ANOP\n         MNOTE 8,'SAVE PARAMETER INVALID'\n         MEXIT\n.*\n.* PARM=REG                    SAVE PARM REGISTER (R1)\n.*\n.PARM    ANOP\n         LR    &PAR0,R0                SAVE PARM REGISTER R0\n         LR    &PAR1,R1                SAVE PARM REGISTER R1\n         LR    R12,R15                 LOAD BASE REGISTER\n         DROP  R15                     DROP TEMP. ADDRESSING\n         AIF   ('&BASEREGS' EQ '1').BASE1\n         AIF   ('&BASEREGS' EQ '2').BASE2\n         AIF   ('&BASEREGS' EQ '3').BASE3\n         MNOTE 8,'BASEREGS PARAMETER INVALID'\n         MEXIT\n.BASE1   ANOP\n         USING &NAME,R12               ESTABLISH PERM. ADDRESSING\n         AGO   .BASEX\n.BASE2   ANOP\n         LA    R11,4095(R12)\n         LA    R11,1(R11)\n         USING &NAME,R12,R11           ESTABLISH PERM. ADDRESSING\n         AGO   .BASEX\n.BASE3   ANOP\n         LA    R11,4095(R12)\n         LA    R11,1(R11)\n         LA    R10,4095(R11)\n         LA    R10,1(R10)\n         USING &NAME,R12,R11,R10       ESTABLISH PERM. ADDRESSING\n.BASEX   ANOP\n&WRKLEN  SETC  '72'\n&SPOOL   SETC  '&SP'\n         AIF   ('&SAVE' EQ 'R14').EXIT\n         AIF   (T'&WORKLEN EQ 'O').GET72\n&WRKLEN  SETC  '&WORKLEN'\n*        STORAGE OBTAIN,LENGTH=&WORKLEN,SP=&SPOOL,BNDRY=PAGE\n         STORAGE OBTAIN,LENGTH=&WORKLEN,SP=&SPOOL,BNDRY=PAGE\n         AGO   .CHAIN\n.GET72   ANOP\n*        STORAGE OBTAIN,LENGTH=72,SP=&SPOOL     GETMAIN SAVE AREA\n         STORAGE OBTAIN,LENGTH=72,SP=&SPOOL     GETMAIN SAVE AREA\n.CHAIN   ANOP\n         XC    0(72,R1),0(R1)          CLEAR SAVE AREA\n         ST    R13,4(,R1)              SAVE REGISTER R13\n         ST    R1,8(,R13)              CHAIN SAVE AREAS\n         LR    R13,R1                  USE NEW SAVE AREA\n         AIF   (T'&WORKLEN EQ 'O').EXIT\n         LA    R0,72(,R1)              WORK AREA ADDRESS\n         LA    R1,&WORKLEN-72          WORK AREA LENGTH\n         SLR   R15,R15                 NO OPERAND 2 / FILL =0\n         MVCL  R0,R14                  ZERO OUT WORK AREA\n.*\n.EXIT    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ESAEXIT": {"ttr": 535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00(\\x00\\x92\\t\\x8f\\x01\\x06\\x07O\\x12C\\x00\\x18\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd4\\xf4@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-04-07T00:00:00", "modifydate": "2006-03-15T12:43:28", "lines": 24, "newlines": 23, "modlines": 0, "user": "SYSPM4"}, "text": "         MACRO\n&NAME    ESAEXIT &RC=\n.*\n.* ESAEXIT USED IN CONJUNCTION WITH THE ESAENTRY MACRO, 06/27/89/$PMCF\n.* (TM)  TAURUS SOFTWARE CONSULTANTS - PETER MCFARLAND CONSULTANT\n.*\n         GBLC  &WRKLEN                           GETMAIN LENGTH\n         GBLC  &SPOOL                            SUBPOOL\n         AIF   ('&RC'(1,1) EQ '(').RCREG         REGISTER SPECIFIED ?\n         LA    R15,&RC                           LOAD RETURN CODE\n         AGO   .RCOK\n.RCREG   ANOP\n         AIF   ('&RC' EQ '(R15)').RCOK           R15 SPECIFIED ?\n         LR    R15,&RC(1)                        LOAD RETURN CODE\n.RCOK    ANOP\n         L     R2,4(,R13)                        --> Previous savearea\n         ST    R15,D16(,R2)                      Save RETURN CODE\n         LR    R1,R13                            --> of area to free.\n*        STORAGE RELEASE,LENGTH=&WRKLEN,ADDR=(1),SP=&SPOOL\n         STORAGE RELEASE,LENGTH=&WRKLEN,ADDR=(1),SP=&SPOOL\n         LR    R13,R2                            Load R13 for LM\n         LM    R14,R12,12(R13)                   Restore Callers REGS\n         BR    R14                               Return to Caller ...\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HOTRDR": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x06\\x07O\\x01\\x06\\x07O\\x12V\\x01\\xbf\\x01\\xbf\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd4\\xf4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-03-15T00:00:00", "modifydate": "2006-03-15T12:56:10", "lines": 447, "newlines": 447, "modlines": 0, "user": "SYSPM4"}, "text": "HOTRDR   TITLE '* HOTRDR Version 2.1.0 '\n*--------+---------+---------+---------+---------+---------+----------*\n*                                                                     *\n* HOTRDR - An internal reader routine to handle multiple PDS files    *\n*          concatenated to the same DD name, PDS.  JCL member to be   *\n*          submitted to the Internal Reader is passed through the     *\n*          PARM field.  JCL member is located with the FIND macro     *\n*          after OPEN processing is completed.  The BPAM access       *\n*          method will position the subsequent READ macro request     *\n*          to the TTR of the JCL member.  The BLKSIZE of the first    *\n*          PDS is used as the size of the buffer used for the READ    *\n*          operation.  The records are de-blocked in the buffer and   *\n*          submitted to the Internal Reader via a QSAM PUT macro.     *\n*          All non-blank records are submitted to the Internal Reader *\n*          and written to SYSPRINT for inspection.                    *\n*                                                                     *\n* Modified for ADP Tax and Financial Services, May 10, 2003.          *\n* Original Developer - Peter McFarland, June 6, 1994.                 *\n*                                                                     *\n*--------+---------+---------+---------+---------+---------+----------*\n* Disclammer                                                          *\n*                                                                     *\n*     This program is developed on a non-restrictive basis and        *\n*     is of general interest submitted for unrestricted distribution. *\n*     The end user is expected to make the final evaluation as to the *\n*     usefullness in their own environment.                           *\n*                                                                     *\n*     I make no warranty, expressed or implied, including but not     *\n*     limited to, the warranties or merchantability and fitness for a *\n*     particular purpose as to the function or performance of this    *\n*     program.                                                        *\n*                                                                     *\n*     Acceptance and use of this program constitutes a release from   *\n*     any liability of ADP for any problems of the use of this        *\n*     program that may be caused at the user's installation.          *\n*                                                                     *\n*     Users are invited to sumbit suggestions or error documentation  *\n*     to me, however, no promise can be made that such suggestions    *\n*     will be implemented or errors corrected.  Sumbit comments to:   *\n*              Peter McFarland                                        *\n*              P. O. Box 94                                           *\n*              Woodacre, CA. 94973                                    *\n*              (415) 488-4576                                         *\n*       email: zzsprm0@sbcglobal.net                                  *\n*                                                                     *\n*     This program is made available WITHOUT CHARGE OR consideration  *\n*     Recipients are free to make this program available to others in *\n*     a like manner.  It may not be sold.                             *\n*                                                                     *\n*--------+---------+---------+---------+---------+---------+----------*\n* Sample JCL -                                                        *\n*                                                                     *\n*    //HOTRDR    EXEC  PGM=HOTRDR,PARM='IEFBR14'                      *\n*    //STEPLIB   DD  DSN=YOUR.APFAUTH.LINKLIB,DISP=SHR                *\n*    //SYSPRINT  DD  SYSOUT=*                                         *\n*    //INTRDR    DD  SYSOUT=(A,INTRDR)                                *\n*    //SYSUDUMP  DD  SYSOUT=*                                         *\n*    //PDS       DD  DISP=SHR,DSN=PROD.JOBLIB                         *\n*    //          DD  DISP=SHR,DSN=PROD.SYSTEMS.JOBLIB                 *\n*    //          DD  DISP=SHR,DSN=SYSPM4.ASM.SAMPLIB                  *\n*                                                                     *\n* Note:  A large BLKSIZE works best and reduces READ operations.      *\n*        R9 is the addr. of the PDS DCB for the life of the task.     *\n*        Must run AMODE/RMODE 24 because of the BPAM access method.   *\n*                                                                     *\n*--------+---------+---------+---------+---------+---------+----------*\n*\nHOTRDR   AMODE 24\nHOTRDR   RMODE 24\nHOTRDR   ESAENTRY PAR0=R10,PAR1=R11,BASEREGS=1,WORKLEN=HOTRWAL,SP=3\n*\n         USING HOTRWA,R13         Map local work area\n         $CLEAR HOTRWTOL          to blanks\n         $CLEAR PRINT_BUF         to blanks\n         $CLEAR PARMDATA          to blanks\n         PARMS PARMDATA           Get the PARM data passed\n         LTR   R1,R1              any parm data ?\n         BZ    NO_PARM_DATA       zeros, RC = 8\n         CL    R1,=F'8'           parm data <> 8 char ?\n         BH    BAD_PARM_LEN       RC = 8\n         ST    R1,PARMLEN         save the length for later\n         LA    R1,DCB_TABLE       Where the PDS DCBs are kept\n         BAL   R14,TIOT_SEARCH    Do the TIOT search.\n         TM    SW,GOT_PDS_DCB+GOT_INTRDR+GOT_SYSPRINT all present ?\n         BZ    MISSING_DCBS       no, exit with WTO and RC=12\n         OPEN  (INTRDR,OUTPUT,SYSPRINT,OUTPUT)  open our files\n         OI    SW,OUT_OPEN        say we opened our output DCBs\n*\n         LA    R9,PDS             R9 = ptr to PDS DCB for processing\n         BAL   R14,OPEN_SEARCH    Do OPEN DCB processing for PDS\n         TM    SW,MEM_FOUND       did we find a member ?\n         BO    READ_MEMBER        yes, read it and send it off.\n*                                 else, no member was found\n         B     NO_MEMBER          clean-up and exit for now.\n*\nNO_MORE_DCBS DS 0H\n         TM    SW,OPEN_DONE       did we open any DCBs ?\n         BZ    DO_FREE            no, skip close processing\n         CLOSE ((9))              close out the DCB\nDO_FREE  DS    0H\n         ICM   R1,B'1111',BLOCKAD  any buffer ptr to free storage\n         BZ    MAIN_EXIT          no, just exit\n         L     R0,BLOCKSIZ        get the buffer size\n         FREEMAIN R,LV=(0),A=(1)  free the buffer\n*\nMAIN_EXIT DS   0H\n         TM    SW,OUT_OPEN        did we open our output DCBs ?\n         BZ    SET_RC             no, just exit.\n         CLOSE (INTRDR,,SYSPRINT)  close our output files\nSET_RC   DS    0H\n         LH    R15,RETCODE        set a return code\n         ESAEXIT RC=(R15)\n*\nREAD_MEMBER DS 0H\n*--------------------------------------------------------------------*\n*  Read a block and deblock it into locical records to be written    *\n*  to the internal reader for submission to JES2.  Write each record *\n*  to SYSPRINT also for inspection.                                  *\n*--------------------------------------------------------------------*\n         USING IHADCB,R9          DCBD mapping\n         L     R4,BLOCKAD         get ptr to our buffer\n         READ  DECBPDS,SF,(9),(4),'S' read a block\n         CHECK DECBPDS            check the DECB\n         SLR   R1,R1\n         LH    R1,DCBBLKSI        get blksize from open DCB\n         L     R2,DECBPDS+16      get record iob address\n         SH    R1,14(R2)          Subtract residual count\n         LA    R1,0(R1,R4)        point to end of buffer\n         ST    R1,STOPAD          save end ptr\n         ST    R4,LRECAD          save the current record ptr\n         LR    R6,R4\n         SLR   R5,R5\n         LH    R5,DCBLRECL        get lrecl from open DCB\n         CH    R5,=H'80'          are we lrecl=80 ?\n         BNE   BAD_PDS_FORMAT\n         B     REC_MOVER\n*                                 Deblock input\nNXTLRECL DS    0H\n         L     R6,LRECAD\n         AH    R6,DCBLRECL        add lrecl from open DCB\n         C     R6,STOPAD\n         BNL   READ_MEMBER\n         ST    R6,LRECAD\n         LH    R5,DCBLRECL        get lrecl from open DCB\n*\nREC_MOVER DS   0H\n         PUT   INTRDR,(6)         send a record to INTRDR\n         $CLEAR PRINT_BUF         clear the print buffer\n         TM    SW,PASS_ONE        been through here once ?\n         BO    SKIP_HDR           yes, skip printing a header\n         LA    R1,PRINT_BUF\n         USING PRINTHDR,R1\n         MVC   JOB,WTOJOBN        Build a header line w/job name\n         MVC   DSN,DSNAME          data set name\n         MVC   MEM,MEMNAME          member name\n         MVC   VOL,VOLNO             and volume serial\n         DROP  R1\n         PUT   SYSPRINT,PRINT_BUF\n         OI    SW,PASS_ONE        say we've been through here\n         $CLEAR PRINT_BUF         clear the print buffer\nSKIP_HDR DS    0H\n         MVC   PRINT_BUF+1(80),0(R6)  write it to sysprint\n         PUT   SYSPRINT,PRINT_BUF\nSKIP_LOOP DS   0H\n         LA    R6,80(,R6)\n         CL    R6,STOPAD          at the end ?\n         BNL   READ_MEMBER\n         CLC   =CL80' ',0(R6)\n         BE    SKIP_LOOP\n         B     REC_MOVER\n*\nENDPDS   DS    0H\n         L     R0,BLOCKSIZ        use the blksize for buffer size\n         L     R1,BLOCKAD         buffer ptr to free storage\n         FREEMAIN R,LV=(0),A=(1)  free the buffer\n         CLOSE ((9))              close out the PDS\n         PUT   SYSPRINT,=CL133' **** END OF MEMBER SUBMITTED ****'\n         SLR   R15,R15\n         STH   R15,RETCODE\n         B     MAIN_EXIT          we're done\n*\nOPEN_SEARCH DS 0H                 Check the DCB for member passed\n*--------------------------------------------------------------------*\n*  Open the PDS DCB and check it for correct processing. Then see if\n*  we can find the member to be submitted to the internal reader.\n*--------+-----+------------------+----------------------------------*\n         ST    R14,SAVER14        save our return ptr\n         LA    R15,ENDPDS         setup EODAD\n         ST    R15,DCBEODAD         processing\n         OPEN  ((9),INPUT)        open the DCB\n         TM    DCBOFLGS,DCBOFOPN  did DCB open ?\n         BZ    DCB_NOT_OK         No, bad DCB - skip it\n         TM    DCBDSORG,DCBDSGPO  Is it Partitioned\n         BZ    DCB_NOT_OK         No, not a PDS - skip it\n         TM    DCBRECFM,DCBRECF   Is it fixed block ?\n         BO    ACQVS              yes, continue\nDCB_NOT_OK DS  0H\n         OI    SW,BAD_DCBD        indicate we cannot process DCB\n         CLOSE ((9))              close DCB\n         B     BAD_PDS_FORMAT\n*\nACQVS    DS    0H\n         SLR   R0,R0\n         LH    R0,DCBBLKSI        use the blksize for buffer size\n         ST    R0,BLOCKSIZ        size of GETMAIN area\n         GETMAIN R,LV=(0)\n         ST    R1,BLOCKAD         save it for later\n         OI    SW,OPEN_DONE       flip the switch\n         L     R2,44(,R9)         DEB pointer\n         L     R2,32(,R2)         UCB pointer\n         MVC   VOLNO,28(R2)       save the volume serial of PDS\n         LA    R1,WORKAREA        build RDJFCB parms\n         ST    R1,BUFPTR\n         MVI   BUFPTR,X'87'\n         LA    R1,BUFPTR\n         ST    R1,DCBEXLST\n         RDJFCB ((9))             get the JFCB for PDS DCB\n         MVC   DSNAME,WORKAREA    save the DSN of this PDS\n         FIND  ((9)),PARMDATA,D   see if our member is there\n         STH   R15,RETCODE        save the return code\n         STH   R0,RESCODE         save the reason code\n         LTR   R15,R15            found it ?\n         BZ    FOUND_MEMBER       yes, setup for read\n*                                 RC = 4, name not found - R0 = 0\n*                                 RC = 8, perm I/O error - R0 = 0\n         CLOSE ((9))              close out the PDS DCB\n         NI    SW,NOT-OPEN_DONE   flip the switch off\n         SLR   R15,R15\n         LH    R15,RETCODE        reset return code\n         B     OPEN_EXIT          and continue\nFOUND_MEMBER DS 0H\n         OI    SW,MEM_FOUND       flip the switch\n         MVC   MEMNAME,PARMDATA   indicate we found the member\n         SLR   R15,R15            with a RC = 0\n         STH   R15,RETCODE\nOPEN_EXIT DS   0H\n         L     R14,SAVER14        were done\n         BR    R14\n         DROP  R9\n*\nTIOT_SEARCH DS 0H\n*--------------------------------------------------------------------*\n*  Go down through the TIOTs and match up the DD names with our\n*  DCBs coded internally.  If no match is found for any of our DCBs\n*  issue a message and quit.\n*--------+-----+------------------+----------------------------------*\n         ST    R14,SAVER14        save return address\n         LA    R2,TIOTADDR        where to put the TIOT ptr\n         EXTRACT (2),'S',FIELDS=TIOT   get our TIOT ptr.\n         L     R1,TIOTADDR\n         USING TIOT1,R1           TIOT mapping\n         LA    R2,TIOENTRY        R2 = First DD entry in the list\n         MVC   WTOJOBN,TIOCNJOB   save off the jobname for WTOs\n         LA    R3,DCB_TABLE       work from the top\n         L     R9,DCB_TABLE       Start with the 1st DCB\n         USING IHADCB,R9          DCBD mapping\n*\nTIOTLOOP DS    0H\n         CLC   0(4,R2),=XL4'00'   end of TIOT?\n         BE    TIOT_DONE          yes, we're done\n         CLC   4(8,R2),DCBDDNAM   match on DD name ?\n         BE    DDNAME_HIT         yes, check the next one\n         SLR   R5,R5\n         IC    R5,0(,R2)          R5 = length of TIOT DD entry\n         LA    R2,0(R5,R2)        R2 = Next DD entry\n         B     TIOTLOOP           Go check it out.\n*\nDDNAME_HIT DS  0H\n         CLC   DCBDDNAM,=CL8'PDS '\n         BNE   CHK_INTRDR\n         OI    SW,GOT_PDS_DCB\n         B     TIOT_DONE\nCHK_INTRDR DS  0H\n         CLC   DCBDDNAM,=CL8'INTRDR '\n         BNE   CHK_SYSPRINT\n         OI    SW,GOT_INTRDR\n         B     TIOT_DONE\nCHK_SYSPRINT DS 0H\n         CLC   DCBDDNAM,=CL8'SYSPRINT'\n         BNE   TIOT_DONE\n         OI    SW,GOT_SYSPRINT\n*\nTIOT_DONE DS  0H\n         LA    R3,4(0,R3)         Select next DCB to process\n         ICM   R9,B'1111',0(R3)   any DCB ptr left ?\n         BZ    TIOTS_EXIT         None - no more DCBs to check\n         LA    R2,TIOENTRY        R2 = First DD entry in the list\n         B     TIOTLOOP           and continue\n*\nTIOTS_EXIT DS  0H\n         L     R14,SAVER14        get return address\n         BR    R14                exit sub-routine\n*\n*        SYNAD ROUTINE\n*\nPDSIOER  DS    0H\n         SYNADAF ACSMETH=BSAM\n         MVC   SYNADMS2+1(132),8(R1)     save the error msg.\n         MVC   SYNADMS1+65(44),DSNAME    get the dsname\n         PUT   SYSPRINT,SYNADMS1\n         PUT   SYSPRINT,SYNADMS2\n         SYNADRLS\n         B     NO_MORE_DCBS       go clean-up and exit\n         DROP  R1                 done with TIOT base\n         DROP  R9                 give up any DCB addressability\n*\n*--------ERROR MESSAGES AND NON-ZERO RETURN CODES---------------------*\n*\nNO_PARM_DATA DS 0H\n         LA    R15,4\n         STH   R15,RETCODE\n         WTO   '*-*-*HOTRDR - Parm field not specified. Return code=4'\n         B     MAIN_EXIT          exit sub-routine\n*\nBAD_PARM_LEN DS 0H\n         LA    R15,4\n         STH   R15,RETCODE\n      WTO  '*-*-*HOTRDR - Parm field greater than 8 characters. Return +\n               code=4'\n         B     MAIN_EXIT          exit sub-routine\n*\nBAD_PDS_FORMAT DS 0H\n         LA    R15,8\n         STH   R15,RETCODE\n        WTO  '*-*-*HOTRDR - PDS not RECFM=FB,LRECL=80. Return code=8'\n         B     NO_MORE_DCBS       exit sub-routine\n*\nNO_MEMBER DS   0H\n         LA    R15,8\n         STH   R15,RETCODE\n         MVC   NOMWTO+8+17(8),PARMDATA   plug in the member name\nNOMWTO   WTO   '*HOTRDR - Member XXXXXXXX not found. Retrun code=8'\n         B     NO_MORE_DCBS       exit sub-routine\n*\nMISSING_DCBS DS 0H\n         LA    R15,16\n         STH   R15,RETCODE\n         WTO   '*HOTRDR - Missing DCBs to process. Return code=12. Chec+\n               k DD names supplied.'\n         B     NO_MORE_DCBS       exit sub-routine\n*\nUNKOWN_ERR DS  0H\n         LA    R15,16\n         STH   R15,RETCODE\n         WTO   '*HOTRDR - Unknown error occured, Return code=16. Contac+\n               t System Support.'\n         B     NO_MORE_DCBS       exit sub-routine\n*\nFIND_ERR DS    0H\n         BAL   R14,THE_CONVERTER\nFINDERR  WTOL  '*HOTRDR - BLDL-FIND Failure, Retrun code=',            +\n               (CVTWORK,4),' Reason code=',(CVTWORK2,4),MF=(G,HOTRWTOL)\n         B     NO_MORE_DCBS       exit sub-routine\n*\nTHE_CONVERTER DS 0H\n         ST    R14,SAVER14\n         LA    R2,RETCODE         return code set.\n         LA    R3,CVTWORK         where to convert it\n         LA    R4,2               the number of bytes\n         CONVERT (R3,R2,R4)       make it print-able\n*\n         LA    R2,RESCODE         reason code set\n         LA    R3,CVTWORK2        where to convert it\n         LA    R4,2               the number of bytes\n         CONVERT (R3,R2,R4)       make it print-able\n         L     R14,SAVER14\n         BR    R14\n*\n*--------CONSTANTS, EXECUTED INST. AND WORK AREAS---------------------*\n*\n         DS    0D\nFOXES    DC    F'-1'              mask table marker\n*\nDCB_TABLE DS   0H                 Table of all the DCBs\n         DC    A(PDS)\n         DC    A(INTRDR)\n         DC    A(SYSPRINT)\n         DC    F'0'               zeros mark the end\n*\n         PUSH  PRINT\n         PRINT NOGEN\nPDS      DCB   DSORG=PO,MACRF=R,LRECL=80,RECFM=FB,DDNAME=PDS,          X\n               SYNAD=PDSIOER\nINTRDR   DCB   DSORG=PS,MACRF=(PM),LRECL=80,RECFM=FB,DDNAME=INTRDR\nSYSPRINT DCB   DSORG=PS,MACRF=(PM),LRECL=133,RECFM=FB,DDNAME=SYSPRINT\n         POP  PRINT\nSYNADMS1 DC    CL133' * * * I/O ERROR OCCURRED READING DIRECTORY OF PDS1\n               .* * * DSNAME='\nSYNADMS2 DC    CL133' '\n         LTORG\n*\nHOTRWA   DSECT 0\nSAVE     DS    18F            Standard save area for DCB data mgnt.\nRETCODE  DS    H              any return code\nRESCODE  DS    H              any reason code(s)\nSAVER1   DS    F              a place to save R1\nSAVER14  DS    F              a place to save R14\nTIOTADDR DS    F              ptr to TIOT\nFINDAREA DS    D\nLRECAD   DS    F              current record ptr\nSTOPAD   DS    F              end of the buffer\nBLOCKSIZ DS    F              length of buffer for reads\nBLOCKAD  DS    F              ptr to blksize buffer for reads\nPARMLEN  DS    F              PARM data length\nCVTWORK  DS    CL4            CONVERT macro work area\nCVTWORK2 DS    CL4            CONVERT macro work area\nPARMDATA DS    CL8            PARM data passed\nWTOJOBN  DS    CL8            Our JOB name\nBUFPTR   DS    X,AL3          X'87',AL3(WORKAREA)\nSW       DS    X              internal switches\nPASS_ONE  EQU  X'80'            first pass through\nOPEN_DONE EQU  X'40'            we have open DCB for PDS\nMEM_FOUND EQU  X'20'            we found the member\nOUT_OPEN  EQU  X'10'            we opened out output DCBs\nBAD_DCBD  EQU  X'08'            DCB not FB, PDS, or failed OPEN\nGOT_PDS_DCB EQU X'04'           PDS DDNAME present\nGOT_INTRDR  EQU X'02'           INTRDR DDNAME present\nGOT_SYSPRINT EQU X'01'          SYSPRINT DDNAME present\n         DS    0D             align on dlbl-wd boundry\nWORKAREA DS    CL256          RDJFCB work area\n         DS    CL80           some fudge filler\nDSNAME   DS    CL44           DSN of current PDS\nMEMNAME  DS    CL8            member name found\nVOLNO    DS    CL6            VOLUME where DSN lives\n         DS    0F             align WTO buffer on FL-WD\nHOTRWTOL DS    CL128          message buffer\nPRINT_BUF DS   CL133          print buffer\nHOTRWAL  EQU   *-HOTRWA\n*\nPRINTHDR DSECT 0\n         DS    CL2\nJOB      DS    CL8\n         DS    CL2\nDSN      DS    CL44\n         DS    CL2\nMEM      DS    CL8\n         DS    CL2\nVOL      DS    CL6\n*\n         IEFTIOT1\n*\nJFCBMAP  DSECT 0\n         IEFJFCBN LIST=YES\n*\n         DCBD  DSORG=BS,DEVD=DA\n*\n         END   HOTRDR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HOTRDR13": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00G\\x01\\x03\\x13/\\x01\\x04\\x02\\x1f\\x148\\x01\\x90\\x01m\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd4\\xf4@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2003-05-12T00:00:00", "modifydate": "2004-01-21T14:38:47", "lines": 400, "newlines": 365, "modlines": 0, "user": "SYSPM4"}, "text": "HOTRDR   TITLE '* HOTRDR Version 2.1.0 '\n*--------+---------+---------+---------+---------+---------+----------*\n*                                                                     *\n* HOTRDR - An internal reader routine to handle multiple PDS files    *\n*          concatenated to the same DD name, PDS.  JCL member to be   *\n*          submitted to the Internal Reader is passed through the     *\n*          PARM field.  JCL member is located with the FIND macro     *\n*          after OPEN processing is completed.  The BPAM access       *\n*          method will position the subsequent READ macro request     *\n*          to the TTR of the JCL member.  The BLKSIZE of the first    *\n*          PDS is used as the size of the buffer used for the READ    *\n*          operation.  The records are de-blocked in the buffer and   *\n*          submitted to the Internal Reader via a QSAM PUT macro.     *\n*          All non-blank records are submitted to the Internal Reader *\n*          and written to SYSPRINT for inspection.                    *\n*                                                                     *\n* Original Developer - Peter McFarland, June 6, 1994.                 *\n* Modified for ADP Tax and Financial Services, May 10, 2003.          *\n*                                                                     *\n* Sample JCL -                                                        *\n*                                                                     *\n*    //HOTRDR    EXEC  PGM=HOTRDR,PARM='IEFBR14'                      *\n*    //STEPLIB   DD  DSN=SYSPM4.ASM.LINKLIB,DISP=SHR                  *\n*    //SYSPRINT  DD  SYSOUT=*                                         *\n*    //INTRDR    DD  SYSOUT=(A,INTRDR)                                *\n*    //SYSUDUMP  DD  SYSOUT=*                                         *\n*    //PDS       DD  DISP=SHR,DSN=SYSPM4.ASM.SAMPLIB                  *\n*    //          DD  DISP=SHR,DSN=ADP.JOBLIB                          *\n*    //          DD  DISP=SHR,DSN=ADP.SYSTEMS.JOBLIB                  *\n*                                                                     *\n* Note:  A large BLKSIZE works best and reduces READ operations.      *\n*        R9 is the addr. of the PDS DCB for the life of the task.     *\n*        Must run AMODE/RMODE 24 because of the BPAM access method.   *\n*                                                                     *\n*--------+---------+---------+---------+---------+---------+----------*\n*\nHOTRDR   AMODE 24\nHOTRDR   RMODE 24\nHOTRDR   ADPENTRY PAR0=R10,PAR1=R11,BASEREGS=1,WORKLEN=HOTRWAL,SP=3\n*\n         USING HOTRWA,R13         Map local work area\n         $CLEAR HOTRWTOL          to blanks\n         $CLEAR PRINT_BUF         to blanks\n         $CLEAR PARMDATA          to blanks\n         PARMS PARMDATA           Get the PARM data passed\n         LTR   R1,R1              any parm data ?\n         BZ    NO_PARM_DATA       zeros, RC = 8\n         CL    R1,=F'8'           parm data <> 8 char ?\n         BH    BAD_PARM_LEN       RC = 8\n         ST    R1,PARMLEN         save the length for later\n         LA    R1,DCB_TABLE       Where the PDS DCBs are kept\n         BAL   R14,TIOT_SEARCH    Do the TIOT search.\n         TM    SW,GOT_PDS_DCB+GOT_INTRDR+GOT_SYSPRINT all present ?\n         BZ    MISSING_DCBS       no, exit with WTO and RC=12\n         OPEN  (INTRDR,OUTPUT,SYSPRINT,OUTPUT)  open our files\n         OI    SW,OUT_OPEN        say we opened our output DCBs\n*\n         LA    R9,PDS             R9 = ptr to PDS DCB for processing\n         BAL   R14,OPEN_SEARCH    Do OPEN DCB processing for PDS\n         TM    SW,MEM_FOUND       did we find a member ?\n         BO    READ_MEMBER        yes, read it and send it off.\n*                                 else, no member was found\n         B     NO_MEMBER          clean-up and exit for now.\n*\nNO_MORE_DCBS DS 0H\n         TM    SW,OPEN_DONE       did we open any DCBs ?\n         BZ    DO_FREE            no, skip close processing\n         CLOSE ((9))              close out the DCB\nDO_FREE  DS    0H\n         ICM   R1,B'1111',BLOCKAD  any buffer ptr to free storage\n         BZ    MAIN_EXIT          no, just exit\n         L     R0,BLOCKSIZ        get the buffer size\n         FREEMAIN R,LV=(0),A=(1)  free the buffer\n*\nMAIN_EXIT DS   0H\n         TM    SW,OUT_OPEN        did we open our output DCBs ?\n         BZ    SET_RC             no, just exit.\n         CLOSE (INTRDR,,SYSPRINT)  close our output files\nSET_RC   DS    0H\n         LH    R15,RETCODE        set a return code\n         ADPEXIT RC=(R15)\n*\nREAD_MEMBER DS 0H\n*--------------------------------------------------------------------*\n*  Read a block and deblock it into locical records to be written    *\n*  to the internal reader for submission to JES2.  Write each record *\n*  to SYSPRINT also for inspection.                                  *\n*--------------------------------------------------------------------*\n         USING IHADCB,R9          DCBD mapping\n         L     R4,BLOCKAD         get ptr to our buffer\n         READ  DECBPDS,SF,(9),(4)  read a block\n         CHECK DECBPDS            check the DECB\n         L     R3,DECBPDS+16      get record ptr word\n         LH    R5,DCBBLKSI        get blksize from open DCB\n         SH    R5,14(R3)          Subtract residual count\n         LA    R5,0(R5,R4)        point to end of buffer\n         ST    R5,STOPAD          save end ptr\n         ST    R4,LRECAD          save the current record ptr\n         LR    R6,R4\n         SLR   R5,R5\n         LH    R5,DCBLRECL        get lrecl from open DCB\n         CH    R5,=H'80'          are we lrecl=80 ?\n         BNE   BAD_PDS_FORMAT\n         B     REC_MOVER\n*                                 Deblock input\nNXTLRECL DS    0H\n         L     R6,LRECAD\n         AH    R6,DCBLRECL        add lrecl from open DCB\n         C     R6,STOPAD\n         BNL   READ_MEMBER\n         ST    R6,LRECAD\n         LH    R5,DCBLRECL        get lrecl from open DCB\n*\nREC_MOVER DS   0H\n         PUT   INTRDR,(6)         send a record to INTRDR\n         $CLEAR PRINT_BUF         clear the print buffer\n         TM    SW,PASS_ONE        been through here once ?\n         BO    SKIP_HDR           yes, skip printing a header\n         LA    R1,PRINT_BUF\n         USING PRINTHDR,R1\n         MVC   JOB,WTOJOBN        Build a header line w/job name\n         MVC   DSN,DSNAME          data set name\n         MVC   MEM,MEMNAME          member name\n         MVC   VOL,VOLNO             and volume serial\n         DROP  R1\n         PUT   SYSPRINT,PRINT_BUF\n         OI    SW,PASS_ONE        say we've been through here\n         $CLEAR PRINT_BUF         clear the print buffer\nSKIP_HDR DS    0H\n         MVC   PRINT_BUF+1(80),0(R6)  write it to sysprint\n         PUT   SYSPRINT,PRINT_BUF\nSKIP_LOOP DS   0H\n         LA    R6,80(,R6)\n         CL    R6,STOPAD          at the end ?\n         BNL   READ_MEMBER\n         CLC   =CL80' ',0(R6)\n         BE    SKIP_LOOP\n         B     REC_MOVER\n*\nENDPDS   DS    0H\n         L     R0,BLOCKSIZ        use the blksize for buffer size\n         L     R1,BLOCKAD         buffer ptr to free storage\n         FREEMAIN R,LV=(0),A=(1)  free the buffer\n         CLOSE ((9))              close out the PDS\n         PUT   SYSPRINT,=CL133' **** END OF MEMBER SUBMITTED ****'\n         SLR   R15,R15\n         STH   R15,RETCODE\n         B     MAIN_EXIT          we're done\n*\nOPEN_SEARCH DS 0H                 Check the DCB for member passed\n*--------------------------------------------------------------------*\n*  Open the PDS DCB and check it for correct processing. Then see if\n*  we can find the member to be submitted to the internal reader.\n*--------+-----+------------------+----------------------------------*\n         ST    R14,SAVER14        save our return ptr\n         LA    R15,ENDPDS         setup EODAD\n         ST    R15,DCBEODAD         processing\n         OPEN  ((9),INPUT)        open the DCB\n         TM    DCBOFLGS,DCBOFOPN  did DCB open ?\n         BZ    DCB_NOT_OK         No, bad DCB - skip it\n         TM    DCBDSORG,DCBDSGPO  Is it Partitioned\n         BZ    DCB_NOT_OK         No, not a PDS - skip it\n         TM    DCBRECFM,DCBRECF   Is it fixed block ?\n         BO    ACQVS              yes, continue\nDCB_NOT_OK DS  0H\n         OI    SW,BAD_DCBD        indicate we cannot process DCB\n         CLOSE ((9))              close DCB\n         B     BAD_PDS_FORMAT\n*\nACQVS    DS    0H\n         SLR   R0,R0\n         LH    R0,DCBBLKSI        use the blksize for buffer size\n         ST    R0,BLOCKSIZ        size of GETMAIN area\n         GETMAIN R,LV=(0)\n         ST    R1,BLOCKAD         save it for later\n         OI    SW,OPEN_DONE       flip the switch\n         L     R2,44(,R9)         DEB pointer\n         L     R2,32(,R2)         UCB pointer\n         MVC   VOLNO,28(R2)       save the volume serial of PDS\n         LA    R1,WORKAREA        build RDJFCB parms\n         ST    R1,BUFPTR\n         MVI   BUFPTR,X'87'\n         LA    R1,BUFPTR\n         ST    R1,DCBEXLST\n         RDJFCB ((9))             get the JFCB for PDS DCB\n         MVC   DSNAME,WORKAREA    save the DSN of this PDS\n         FIND  ((9)),PARMDATA,D   see if our member is there\n         STH   R15,RETCODE        save the return code\n         STH   R0,RESCODE         save the reason code\n         LTR   R15,R15            found it ?\n         BZ    FOUND_MEMBER       yes, setup for read\n*                                 RC = 4, name not found - R0 = 0\n*                                 RC = 8, perm I/O error - R0 = 0\n         CLOSE ((9))              close out the PDS DCB\n         NI    SW,NOT-OPEN_DONE   flip the switch off\n         SLR   R15,R15\n         LH    R15,RETCODE        reset return code\n         B     OPEN_EXIT          and continue\nFOUND_MEMBER DS 0H\n         OI    SW,MEM_FOUND       flip the switch\n         MVC   MEMNAME,PARMDATA   indicate we found the member\n         SLR   R15,R15            with a RC = 0\n         STH   R15,RETCODE\nOPEN_EXIT DS   0H\n         L     R14,SAVER14        were done\n         BR    R14\n         DROP  R9\n*\nTIOT_SEARCH DS 0H\n*--------------------------------------------------------------------*\n*  Go down through the TIOTs and match up the DD names with our\n*  DCBs coded internally.  If no match is found for any of our DCBs\n*  issue a message and quit.\n*--------+-----+------------------+----------------------------------*\n         ST    R14,SAVER14        save return address\n         LA    R2,TIOTADDR        where to put the TIOT ptr\n         EXTRACT (2),'S',FIELDS=TIOT   get our TIOT ptr.\n         L     R1,TIOTADDR\n         USING TIOT1,R1           TIOT mapping\n         LA    R2,TIOENTRY        R2 = First DD entry in the list\n         MVC   WTOJOBN,TIOCNJOB   save off the jobname for WTOs\n         LA    R3,DCB_TABLE       work from the top\n         L     R9,DCB_TABLE       Start with the 1st DCB\n         USING IHADCB,R9          DCBD mapping\n*\nTIOTLOOP DS    0H\n         CLC   0(4,R2),=XL4'00'   end of TIOT?\n         BE    TIOT_DONE          yes, we're done\n         CLC   4(8,R2),DCBDDNAM   match on DD name ?\n         BE    DDNAME_HIT         yes, check the next one\n         SLR   R5,R5\n         IC    R5,0(,R2)          R5 = length of TIOT DD entry\n         LA    R2,0(R5,R2)        R2 = Next DD entry\n         B     TIOTLOOP           Go check it out.\n*\nDDNAME_HIT DS  0H\n         CLC   DCBDDNAM,=CL8'PDS '\n         BNE   CHK_INTRDR\n         OI    SW,GOT_PDS_DCB\n         B     TIOT_DONE\nCHK_INTRDR DS  0H\n         CLC   DCBDDNAM,=CL8'INTRDR '\n         BNE   CHK_SYSPRINT\n         OI    SW,GOT_INTRDR\n         B     TIOT_DONE\nCHK_SYSPRINT DS 0H\n         CLC   DCBDDNAM,=CL8'SYSPRINT'\n         BNE   TIOT_DONE\n         OI    SW,GOT_SYSPRINT\n*\nTIOT_DONE DS  0H\n         LA    R3,4(0,R3)         Select next DCB to process\n         ICM   R9,B'1111',0(R3)   any DCB ptr left ?\n         BZ    TIOTS_EXIT         None - no more DCBs to check\n         LA    R2,TIOENTRY        R2 = First DD entry in the list\n         B     TIOTLOOP           and continue\n*\nTIOTS_EXIT DS  0H\n         L     R14,SAVER14        get return address\n         BR    R14                exit sub-routine\n         DROP  R1                 done with TIOT base\n         DROP  R9                 give up any DCB addressability\n*\n*--------ERROR MESSAGES AND NON-ZERO RETURN CODES---------------------*\n*\nNO_PARM_DATA DS 0H\n         LA    R15,4\n         STH   R15,RETCODE\n         WTO   '*HOTRDR - Parm field not specified. Return code=4'\n         B     MAIN_EXIT          exit sub-routine\n*\nBAD_PARM_LEN DS 0H\n         LA    R15,4\n         STH   R15,RETCODE\n         WTO   '*HOTRDR - Parm field greater than 8 characters. Return +\n               code=4'\n         B     MAIN_EXIT          exit sub-routine\n*\nBAD_PDS_FORMAT DS 0H\n         LA    R15,8\n         STH   R15,RETCODE\n         WTO   '*HOTRDR - PDS not RECFM=FB,LRECL=80. Return code=8'\n         B     NO_MORE_DCBS       exit sub-routine\n*\nNO_MEMBER DS   0H\n         LA    R15,8\n         STH   R15,RETCODE\n         MVC   NOMWTO+8+17(8),PARMDATA   plug in the member name\nNOMWTO   WTO   '*HOTRDR - Member XXXXXXXX not found. Retrun code=8'\n         B     NO_MORE_DCBS       exit sub-routine\n*\nMISSING_DCBS DS 0H\n         LA    R15,16\n         STH   R15,RETCODE\n         WTO   '*HOTRDR - Missing DCBs to process. Return code=12. Chec+\n               k DD names supplied.'\n         B     NO_MORE_DCBS       exit sub-routine\n*\nUNKOWN_ERR DS  0H\n         LA    R15,16\n         STH   R15,RETCODE\n         WTO   '*HOTRDR - Unknown error occured, Return code=16. Contac+\n               t System Support.'\n         B     NO_MORE_DCBS       exit sub-routine\n*\nFIND_ERR DS    0H\n         BAL   R14,THE_CONVERTER\nFINDERR  WTOL  '*HOTRDR - BLDL-FIND Failure, Retrun code=',            +\n               (CVTWORK,4),' Reason code=',(CVTWORK2,4),MF=(G,HOTRWTOL)\n         B     NO_MORE_DCBS       exit sub-routine\n*\nTHE_CONVERTER DS 0H\n         ST    R14,SAVER14\n         LA    R2,RETCODE         return code set.\n         LA    R3,CVTWORK         where to convert it\n         LA    R4,2               the number of bytes\n         CONVERT (R3,R2,R4)       make it print-able\n*\n         LA    R2,RESCODE         reason code set\n         LA    R3,CVTWORK2        where to convert it\n         LA    R4,2               the number of bytes\n         CONVERT (R3,R2,R4)       make it print-able\n         L     R14,SAVER14\n         BR    R14\n*\n*--------CONSTANTS, EXECUTED INST. AND WORK AREAS---------------------*\n*\n         DS    0D\nFOXES    DC    F'-1'              mask table marker\n*\nDCB_TABLE DS   0H                 Table of all the DCBs\n         DC    A(PDS)\n         DC    A(INTRDR)\n         DC    A(SYSPRINT)\n         DC    F'0'               zeros mark the end\n*\n         PUSH  PRINT\n         PRINT NOGEN\nPDS      DCB   DSORG=PO,MACRF=R,LRECL=80,RECFM=FB,DDNAME=PDS\nINTRDR   DCB   DSORG=PS,MACRF=(PM),LRECL=80,RECFM=FB,DDNAME=INTRDR\nSYSPRINT DCB   DSORG=PS,MACRF=(PM),LRECL=133,RECFM=FB,DDNAME=SYSPRINT\n         POP  PRINT\n         LTORG\n*\nHOTRWA   DSECT 0\nSAVE     DS    18F            Standard save area for DCB data mgnt.\nRETCODE  DS    H              any return code\nRESCODE  DS    H              any reason code(s)\nSAVER1   DS    F              a place to save R1\nSAVER14  DS    F              a place to save R14\nTIOTADDR DS    F              ptr to TIOT\nFINDAREA DS    D\nLRECAD   DS    F              current record ptr\nSTOPAD   DS    F              end of the buffer\nBLOCKSIZ DS    F              length of buffer for reads\nBLOCKAD  DS    F              ptr to blksize buffer for reads\nPARMLEN  DS    F              PARM data length\nCVTWORK  DS    CL4            CONVERT macro work area\nCVTWORK2 DS    CL4            CONVERT macro work area\nPARMDATA DS    CL8            PARM data passed\nWTOJOBN  DS    CL8            Our JOB name\nBUFPTR   DS    X,AL3          X'87',AL3(WORKAREA)\nSW       DS    X              internal switches\nPASS_ONE  EQU  X'80'            first pass through\nOPEN_DONE EQU  X'40'            we have open DCB for PDS\nMEM_FOUND EQU  X'20'            we found the member\nOUT_OPEN  EQU  X'10'            we opened out output DCBs\nBAD_DCBD  EQU  X'08'            DCB not FB, PDS, or failed OPEN\nGOT_PDS_DCB EQU X'04'           PDS DDNAME present\nGOT_INTRDR  EQU X'02'           INTRDR DDNAME present\nGOT_SYSPRINT EQU X'01'          SYSPRINT DDNAME present\n         DS    0D             align on dlbl-wd boundry\nWORKAREA DS    CL256          RDJFCB work area\n         DS    CL80           some fudge filler\nDSNAME   DS    CL44           DSN of current PDS\nMEMNAME  DS    CL8            member name found\nVOLNO    DS    CL6            VOLUME where DSN lives\n         DS    0F             align WTO buffer on FL-WD\nHOTRWTOL DS    CL128          message buffer\nPRINT_BUF DS   CL133          print buffer\nHOTRWAL  EQU   *-HOTRWA\n*\nPRINTHDR DSECT 0\n         DS    CL2\nJOB      DS    CL8\n         DS    CL2\nDSN      DS    CL44\n         DS    CL2\nMEM      DS    CL8\n         DS    CL2\nVOL      DS    CL6\n*\n         IEFTIOT1\n*\nJFCBMAP  DSECT 0\n         IEFJFCBN LIST=YES\n*\n         DCBD  DSORG=BS,DEVD=DA\n*\n         END   HOTRDR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PARMS": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00)\\x00\\x910O\\x01\\x06\\x07O\\x12A\\x00\\x1d\\x00>\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd4\\xf4@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1991-10-31T00:00:00", "modifydate": "2006-03-15T12:41:29", "lines": 29, "newlines": 62, "modlines": 0, "user": "SYSPM4"}, "text": "         MACRO\n&NAME    PARMS &SAVER\n.*\n&GNAME   SETC  'TSC'.'&SYSNDX'\n.*--------------------------------------------------------------------*\n.*       THIS CASUAL MACRO (PARMS) MOVES THE PARM DATA INTO A GIVEN   *\n.*       AREA SPECIFIED BY THE USER.  IF NO PARM FIELD IS SUPPLIED,   *\n.*       REGISTER 1 IS CLEARED TO ZERO.  OTHERWISE, R1 CONTAINS THE   *\n.*       THE LENGTH OF THE PARM DATA PASSED.                          *\n.* (TM)  TAURUS SOFTWARE CONSULTANTS - PETER MCFARLAND CONSULTANT     *\n.*--------------------------------------------------------------------*\n         L     15,4(,13)               ==> TO PREVIOUS SAVE AREA\n         L     1,24(,15)               RE-LOAD R1 FORM SAVE AREA\n         L     1,0(1)                  LOAD PARM ==>\n         CLC   0(2,1),=H'0'            PARM OMITTED ?\n         BE    &GNAME.X                YES, JUST EXIT W/R1 = 0\n         SLR   14,14                   CLEAR WORK REGISTER\n         LH    14,0(1)                 LOAD PARM COUNT\n         LA    15,2(1)                 LOAD PARM ==>\n         LR    1,14                    SAVE PARM LENGTH FOR USER\n         BCTR  14,0                    MINUS ONE FOR MVC INST.\n         EX    14,&GNAME.A             MOVE IN THE PARM DATA\n         B     &GNAME.Z                ALL DONE\n*\n&GNAME.A MVC   &SAVER.(0),0(15)        EXECUTED INST.\n&GNAME.X DS    0H\n         SLR   1,1                     ZERO R1, NO PARM\n&GNAME.Z DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTOL": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x04\\x02\\x1f\\x01\\x06\\x07O\\x12B\\x00\\xe9\\x00\\xea\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd4\\xf4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-01-21T00:00:00", "modifydate": "2006-03-15T12:42:46", "lines": 233, "newlines": 234, "modlines": 0, "user": "SYSPM4"}, "text": "         MACRO\n&NAME    WTOL  &ROUTCDE=,&MF=I,&DESC=,&MODE=WTO\n.*--------------------------------------------------------------------*\n.*\n.*       THIS MACRO IS USED TO GENERATE WTO MESSAGES WITH LABELS\n.*       ON FIELDS WITHIN THE MESSAGE THAT THE USER WISHES TO MODIFY.\n.*       THE FORMATS OF THE MACRO ARE...\n.*\n.*                      WTOL MF=(E,ADR)\n.*                          - OR -\n.*    LABEL WTOL 'TEXT1',(LABEL1,NN),'TEXT2',(LABEL2,NN),MF=(G,ADR)\n.*                          - OR -\n.*    LABEL WTOL 'TEXT1',(LABEL1,NN),'TEXT2',(LABEL2,NN),MF=L\n.*                          - OR -\n.*    LABEL WTOL 'TEXT1',(LABEL1,NN,'F'),'TEXT2',(LABEL2,NN,'F'),MF=L\n.*\n.*  ===> WHERE..... NN IS THE LENGTH OF THE LABELED FIELD\n.*            ..... F IS THE FILL CHARACTER DEFAULTING TO BLANKS\n.*            ..... ROUTCDE, DESC, MF=E, AND MF=L ARE SUPPORTED\n.*\n.*  ===> NOTE ..... MF=E IS SUPPORTED DIRECTLY BY WTO\n.*            ..... MF=G IS SUPPORTED FOR USE IN REENTRANT CODE.\n.*                  THE LABEL FIELDS ARE DSECT REFERENCES. THE\n.*                  ADDRESS SPECIFIED MUST POINT TO A GETMAIN AREA.\n.*\n.*            VALIDITY CHECK MODE PARAMETER\n.*\n.*       THE MODE PARAMETER ALLOWS THE USE OF THIS MACRO\n.*       TO GENERATE LISTS OR IN-LINE CODE FOR THE\n.*       COMMANDS (SVC 34), OR WTL (SVC 36).\n.*       IF MODE=COMMAND OR MODE=WTL ARE SPECIFIED, THE\n.*       ROUTING AND DESCRIPTOR OPERANDS ARE INVALID.\n.*\n.*       COPYRIGHT (C) 1989, TAURUS SOFTWARE CONSULTANTS\n.*\n.*       CHANGE LOG:\n.*             06/12/89, PMCF ADDED MF=(G,ADR) SUPPORT.\n.*--------------------------------------------------------------------*\n         LCLA  &LISTN,&N,&SVC,&V#,&VL#\n         LCLB  &B(16),&D(16),&WTO,&COMM,&LOG,&MFG,&TSO\n         LCLC  &GNAME,&LAB,&DE(2),&VARS(16),&L,&TEMP,&XNAM\n         GBLB  &@@CONVT\n.*\n         AIF  ('&MF(1)' NE 'E').NOTE\n&NAME    WTO  &SYSLIST(1),ROUTCDE=&ROUTCDE,DESC=&DESC,MF=&MF\n         MEXIT\n.NOTE    ANOP\n&WTO     SETB ('&MODE' EQ 'WTO')\n&COMM    SETB ('&MODE' EQ 'COMMAND')\n&LOG     SETB ('&MODE' EQ 'LOG')\n&TSO     SETB ('&MODE' EQ 'TSO')\n         AIF  (&WTO OR &COMM OR &LOG OR &TSO).MODEOK1\n         AGO   .E0\n.MODEOK1 ANOP\n         AIF   (NOT &WTO AND                                           X\n               ('&ROUTCDE' NE '' OR '&DESC' NE '')).E6\n         AIF   (NOT &WTO).NOTWTO\n&SVC     SETA  35\n         AGO   .SVCSET\n.NOTWTO  ANOP\n         AIF   (NOT &COMM).NOTCMD\n&SVC     SETA  34\n         AGO   .SVCSET\n.NOTCMD  ANOP\n         AIF   (NOT &LOG).NOTLOG\n&SVC     SETA  36\n         AGO   .SVCSET\n.NOTLOG  ANOP\n         AIF   (NOT &TSO).NOTTSO\n&SVC     SETA  93\n         AGO   .SVCSET\n.NOTTSO  ANOP\n.SVCSET  ANOP\n.*\n.*       VALIDITY CHECK KEYWORD PARAMETERS\n.*\n&LISTN   SETA  1\n&XNAM    SETC  '&NAME'\n         AIF   ('&MF' EQ 'I' OR '&NAME' NE '').NAMESET\n         AIF   (NOT &MFG).E1\n&XNAM    SETC  '&GNAME.E'\n.NAMESET ANOP\n         AIF   (N'&SYSLIST EQ 0).E2\n         AIF   ('&ROUTCDE' EQ '').NORTE1\n.*\n.*       VALIDITY CHECK ROUTCDE AND SET VALUE\n.*\n.RTELOO  ANOP\n&N       SETA  &ROUTCDE(&LISTN)\n         AIF   (&N LT 1 OR &N GT 16).E3\n&B(&N)   SETB  1\n&LISTN   SETA  &LISTN+1\n         AIF   (N'&ROUTCDE GE &LISTN).RTELOO\n.NORTE1  ANOP\n.*\n.*       VALIDITY CHECK DECSRIPTOR CODES AND SET VALUES\n.*\n         AIF   ('&DESC' EQ '').NODESC\n&LISTN   SETA  1\n.DESLOO  ANOP\n&N       SETA  &DESC(&LISTN)\n         AIF   (&N LT 1 OR &N GT 16).E5\n&D(&N)   SETB  1\n&LISTN   SETA  &LISTN+1\n         AIF   (N'&DESC GE &LISTN).DESLOO\n.NODESC  ANOP\n.*\n.*       VALIDATE MF=(G,ADR)\n.*\n         AIF   ('&MF(1)' NE 'G').NOTG\n         AIF   (N'&MF NE 2).E7\n&MFG     SETB  1\n.NOTG    ANOP\n.*\n.*       GENERATE INLINE MESSAGE LENGTH AND FLAGS FIELD\n.*\n&GNAME   SETC  '$TS'.'&SYSNDX'\n         AIF   ('&MF' EQ 'L').MFL\n         CNOP  0,4                 ALIGN LIST\n         AIF   (NOT &COMM).NOTCOMM\n         SLR   R0,R0               CONSOLE ID\n.NOTCOMM ANOP\n         AIF   (NOT &MFG).NOTRENT\n&XNAM    BAL   1,&GNAME.B\n         AGO   .MFLRTN\n.NOTRENT ANOP\n&XNAM    BAL   1,&GNAME.D\n         AGO   .MFLRTN\n.MFL     ANOP\n&XNAM    DS    0F                  ALIGN MESSAGE\n.MFLRTN  ANOP\n         DC    AL2(&GNAME.A-*)  MESSAGE LENGTH\n         AIF   ('&ROUTCDE' EQ '' AND '&DESC' EQ '').NOMCS\n         DC    B'1000000000000000' MCS FLAGS\n         AGO   .R1\n.NOMCS   ANOP\n         DC    AL2(0)              NO MCS FLAGS\n.R1      ANOP\n.*\n.*       GENERATE MESSAGE TEXT AND LABEL VARIABLE FIELDS\n.*\n&LISTN   SETA  1\n&V#      SETA  0\n.XPAND   AIF   (N'&SYSLIST(&LISTN) EQ 1).CONST\n         AIF   (N'&SYSLIST(&LISTN) GT 3).E4\n         AIF   (NOT &MFG).ULAB\n&LAB     SETC  '&GNAME'.'&V#'\n&V#      SETA  &V#+1\n&VARS(&V#)  SETC  '&SYSLIST(&LISTN,1)'\n         AGO   .LABSET\n.ULAB    ANOP\n&LAB     SETC  '&SYSLIST(&LISTN,1)'\n.LABSET  ANOP\n         AIF   ('&SYSLIST(&LISTN,3)' EQ '').NULLC\n&LAB     DC    CL&SYSLIST(&LISTN,2).&SYSLIST(&LISTN,3)\n         AGO   .CEND\n.NULLC   ANOP\n&LAB     DC    CL&SYSLIST(&LISTN,2).' '\n         AGO   .CEND\n.CONST   ANOP\n         DC    C&SYSLIST(&LISTN)\n.CEND    ANOP\n&LISTN   SETA  &LISTN+1\n         AIF   (N'&SYSLIST GE &LISTN).XPAND\n&GNAME.A EQU   *\n.*\n.*       GENERATE DESCRIPTOR AND ROUTING CODE FIELDS\n.*\n         AIF   ('&ROUTCDE' EQ '' AND '&DESC' EQ '').NORTE2\n&DE(1)   SETC  '&D(1)&D(2)&D(3)&D(4)&D(5)&D(6)&D(7)&D(8)'\n&DE(2)   SETC  '&D(9)&D(10)&D(11)&D(12)&D(13)&D(14)&D(15)&D(16)'\n         DC    B'&DE(1).&DE(2)'    DESCRIPTOR CODES\n&DE(1)   SETC  '&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)'\n&DE(2)   SETC  '&B(9)&B(10)&B(11)&B(12)&B(13)&B(14)&B(15)&B(16)'\n         DC    B'&DE(1).&DE(2)'    ROUTING CODES\n.NORTE2  ANOP\n         AIF   ('&MF' EQ 'L').NOSVC\n         AIF   (NOT &MFG).SVC\n&GNAME.C DC    AL2(*-&XNAM-5)\n&GNAME.B DS    0H\n         ST    R2,12(,R13)\n         IHBINNRA &MF(2)\n         LA    R15,&XNAM+4\n         ICM   R14,B'0011',&GNAME.C\n        $EX    R14,(MVC,0(0,R1),0(R15))\n&VL#     SETA  0\n&L       SETC  'L'''\n.CONSTLOOP ANOP\n         LA    R15,&GNAME.&VL#-&XNAM-4\n         LA    R15,0(R15,R1)\n         LA    R14,&L&GNAME.&VL#-1\n&TEMP    SETC  '&VARS(&VL#+1)'\n         AIF   ('&TEMP'(1,1) EQ '(').VREG\n         LA    R2,&TEMP\n         AGO   .VEX\n.VREG    ANOP\n         LR    R2,&TEMP\n.VEX     ANOP\n        $EX    R14,(MVC,0(0,R15),0(R2))\n&VL#     SETA  &VL#+1\n         AIF   (&VL# LT &V#).CONSTLOOP\n         L     R2,12(,R13)             RESTORE WORK REGISTER\n.SVC     ANOP\n         DS    0H                      ALIGN AFTER LIST\n         AIF   (NOT &TSO).DOSVC\n         LH    0,0(,R1)                LENGTH OF TEXT\n         LA    R1,4(,R1)               --> TO TEXT FIELD\n.DOSVC   ANOP\n&GNAME.D SVC   &SVC                    ISSUE REQUESTED SVC\n         AIF   (&@@CONVT).NOSVC        SKIP THE NEXT INST.\n.*                                     IF WE HAVE ONE ALREADY\n&@@CONVT SETB  1\n         B     &GNAME.E\n        $EX    GENERATE\n&GNAME.E DS    0H\n.NOSVC   ANOP\n         MEXIT\n.E0      MNOTE 8,'MODE PARAMETER INVALID.'\n         MEXIT\n.E1      MNOTE 8,'NAME PARAMETER REQUIRED'\n         MEXIT\n.E2      MNOTE 8,'MESSAGE OPERAND REQUIRED'\n         MEXIT\n.E3      MNOTE 8,'INVALID ROUTE CODE PARAMETER'\n         MEXIT\n.E4      MNOTE 8,'INVALID LABEL RELATED PARAMETER'\n         MEXIT\n.E5      MNOTE 8,'DESCRIPTOR CODE INVALID'\n         MEXIT\n.E6      MNOTE 8,'ROUTCDE AND/OR DESC INVALID WITH MODE'\n         MEXIT\n.E7      MNOTE 8,'FORMAT INVALID, MUST BE MF=(G,ADR) OR MF=(G,(REG))'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT661/FILE661.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT661", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}