{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013325000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE895.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE895.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x03'", "DS1TRBAL": "b'\\xb2\\xc4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x08\\x81\\x00\\x0b\\x08\\x82\\x00\\x05\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x002\\x01 !\\x0f\\x01 !\\x0f\"5\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-07-28T00:00:00", "modifydate": "2020-07-28T22:35:32", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  895\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE895\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 21 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,173 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/28/20    22:35:32    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x13#\\x0f\\x01\\x13#\\x0f\\x14\\x16\\x00#\\x00#\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-18T00:00:00", "modifydate": "2013-08-18T14:16:18", "lines": 35, "newlines": 35, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  CBT Tape File 183\nFrom:     \"Rainer Nowak\" <rainer_nowak@gmx.de>\nDate:     8/17/2013 4:08 PM\nTo:       sbgolob@cbttape.org\n\nHello Mr. Golob,\n\nFor many years the CBT tape has been a great help for me. Usually\nI used the programs 'as is', but now a colleague wants a way to\nshow him all the stem variables in a REXX exec.  OK, there's\nSTEMEDIT in CBT tape file 183, but this can only be used for stem\nvariables like a.1, a.2 and so on.  One big advantage of REXX is,\nthat you can use stem variables in the way like a. =0;do i=1 to\nwords(text);j=WORD(text,i);a.j=a.j+1;end . So you can count how\nmany times a word is used in a text.  For such stem variables you\ncan't use STEMEDIT.  So I changed STEMEDIT to VIEW and EDIT all\nvariables in a REXX exec.  You'll find the changed source in the\nzip file I attached to this eMail.\n\nThere are also two edit macros to be used with STEMEDIT.  Call\nSTEMEMCB at the beginning of the edit session to change all '00'x\nin blanks and shift the '=' to the left.  At the end of the edit\nsession STEMEMCE should be called to end up the lines with '00'x.\nI've also changed TALLY to work under z/OS 1.13.  I know you don't\nneed TALLY anymore, because DSLIST now can do this for you.  But\nthe idea behind TALLY is, to find the ISPF table used by DSLIST\nand use it for your own needs.  So I wrote DSL as an example, how\nto use this table.  In DSL you can exclude Datasets from the list,\nflip between excluded and visible and do HSM RECALL for all\nvisible Datasets.  I hope these programs will be a help for someone.\n\nThank you for your help and work for so many years.\n\nRainer Nowak\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 520, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x00 9\\x01\\x17\\x08\\x0f\\x01\\x17\\x08\\x0f\\x00\\x08\\x00.\\x00.\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2\\x00\\x00\\x00\\x00.\\x00\\x00\\x00.\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.00", "flags": 32, "createdate": "2017-03-21T00:00:00", "modifydate": "2017-03-21T00:08:39", "lines": 46, "newlines": 46, "modlines": 0, "user": "SBGOLOB\u0000"}, "text": "Subject:  CBT tape File 895 - some new stuff\nFrom:     \"Rainer Nowak\" <rainer_nowak@gmx.de>\nDate:     3/15/2017 5:00 PM\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHello Sam,\n\nToday I send you a zip file for CBT Tape File 895 with all the\nsources, even they haven't changed.\n\nTALLY, STEMEMCB and STEMEMCE haven't changed.  In STEMEDIT I only\nchanged ISPLINK\u00a7 to ISPLINKA to prevent the ASCII/EBCDIC\nconversion problem. DSL has been changed to use the ISPF service\nQTABOPEN for finding the open ISPF tables. TALLY can be changed\nthe same way, but for sentimental reasons I haven't done it.\n\nNew are IS, CICSSUBS, IMSSUBS and MQSUBS. IMSSUBS and MQSUBS\nbased on an article from Antonio Luis Salcedo Freidel in Xephon -\nDB2 update #124 February 2003 page 22ff: ISPF dialog to obtain a\nlist of DB2 subsystems but here the active IMS and MQ systems on\nthe lpar are listed. For MQ it's similar to DB2, but for IMS it's\nvery different to find the information.\n\nCICSSUBS list the CICS systems on the lpar, it is also an example\nof how to find the program entry in a program object.  IS is an\nold CLIST which can be used like this:\n\n//SET1 SET ENV=TEST\n//TEST1 EXEC PGM=IKJEFT1A,\n// PARM='IS &ENV EQ PROD'\n//SYSTSPRT DD SYSOUT=*\n//SYSPROC DD DISP=SHR,DSN=YOUR.CLIST.DSN\n//SYSTSIN DD DUMMY\n//* RC = 4\n//TEST2 EXEC PGM=IKJEFT1A,\n// PARM='IS &ENV EQ TEST'\n//SYSTSPRT DD SYSOUT=*\n//SYSPROC DD DISP=SHR,DSN=YOUR.CLIST.DSN\n//SYSTSIN DD DUMMY\n//* RC = 0\n\nI hope you're doing fine.\n\nBest regards\nRainer\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE03": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01 !\\x0f\\x01 !\\x0f\"4\\x004\\x004\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-07-28T00:00:00", "modifydate": "2020-07-28T22:34:52", "lines": 52, "newlines": 52, "modlines": 0, "user": "SBGOLOB"}, "text": "Hello Sam,\nI hope you're well and Corona hasn't got you.\n\n3 years ago Lionel B. Dyck sent me a TSO help file for STEMEDIT.\nSo here is an update of CBT File 895 including this XMIT of a PO\nhelp file as member TSOHELP.  I've added 3 REXX, one ALOCHELP is\nto allocate a help file before the SYSHELP allocation, the second\nILIBS shows the concatination of libs under the ISPF DD names (so\nif you use LIBDEF for ISPPLIB, you will see this libs under\nISPPLIB),the third one OLDS is one I hope no one will ever need\nit, it shows LSN (Log sequence number) errors in an IMS OLDS\n(OnlineLogDataSet). IMSSUBS won't work after applying some PTfs\nin V14, so I changed this.  An assembler program STEMOUT is added\n(just a striped down STEMEDIT for batch).\n\nMaybe you can help me with a problem:\n\nI installed the HDISASM load modules from the CBT file 885.  I\ncall it in a REXX with CALL 'dsn(HDISASM)' and  sometimes I\nget an S0C4 abend. The abend is always at this point:\n\nThe next sequential instruction to be executed in program HDISASM2 was at\n\n displacement 00000B98.\n       00000B90  92C33453      MVI     1107(R3),195\n       00000B94  A7F4FFAB      BRC     15,*-170\nNSI==> 00000B98  EB016FFCFF55  CLIY    -4(R6),1\n       00000B9E  A774000B      BRC     7,*+22\n\nThis is in the source code:\n         JNZ   CCSHX1                  BRANCH IF HEXI STRING       \u00a731C\n         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE\n         J     CCONCAT                 GO COMPLETE\nCCSHX1   CLIY  -4(R6),1                LBLLEN = 1 ?                \u00a731C\n         JNE   CCSHX2                  BRANCH IF LBLLEN NE 1       \u00a731A\n         TRT   0(1,R7),MIXCTRAN        CHECK 1 BYTE IS CHAR STRING \u00a731A\n\nR6  points to the beginning of the Label table. I don't\nunderstand -4(R6), this will point to the length of the previous\nlabel.  I think it must be 16(R6). Or should R6 always point to\nthe next label.\n\nI can't change it, because the macros in SYS1.MACLIB don't work\nwith the JUMP commands in this assembler program. It has to be\nrewritten to relative adressing or the macros have to be changed.\nIn file 885 it looks like you had compiled the program, so maybe\nyou can publish the macros you used.\n\n\nBest regards and stay healthy,\nRainer\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE895": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00%\\x01 !\\x0f\\x01 !\\x0f\"5\\x00P\\x00P\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-07-28T00:00:00", "modifydate": "2020-07-28T22:35:25", "lines": 80, "newlines": 80, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 895 is from Rainer Nowak and contains some modifications  *   FILE 895\n//*           to Gilbert Saint-flour's STEMEDIT program as well as  *   FILE 895\n//*           some other things that are related.                   *   FILE 895\n//*                                                                 *   FILE 895\n//*           Please refer to CBT File 183 for Gilbert              *   FILE 895\n//*           Saint-flour's materials.                              *   FILE 895\n//*                                                                 *   FILE 895\n//*           email:  rainer_nowak@gmx.de                           *   FILE 895\n//*                                                                 *   FILE 895\n//*                   Description of Contents                       *   FILE 895\n//*                   ----------- -- --------                       *   FILE 895\n//*                                                                 *   FILE 895\n//*     For many years the CBT tape has been a great help for       *   FILE 895\n//*     me. Usually I used the programs 'as is', but now a          *   FILE 895\n//*     colleague wants a way to show him all the stem variables    *   FILE 895\n//*     in a REXX exec.  OK, there's STEMEDIT in CBT tape file      *   FILE 895\n//*     183, but this can only be used for stem variables like      *   FILE 895\n//*     a.1, a.2 and so on.  One big advantage of REXX is, that     *   FILE 895\n//*     you can use stem variables in the way like a. =0;do i=1     *   FILE 895\n//*     to words(text);j=WORD(text,i);a.j=a.j+1;end . So you can    *   FILE 895\n//*     count how many times a word is used in a text.  For such    *   FILE 895\n//*     stem variables you can't use STEMEDIT.  So I changed        *   FILE 895\n//*     STEMEDIT to VIEW and EDIT all variables in a REXX exec.     *   FILE 895\n//*     You'll find the changed source in this file.                *   FILE 895\n//*                                                                 *   FILE 895\n//*     There are also two edit macros to be used with              *   FILE 895\n//*     STEMEDIT.  Call STEMEMCB at the beginning of the edit       *   FILE 895\n//*     session to change all '00'x in blanks and shift the '='     *   FILE 895\n//*     to the left.  At the end of the edit session STEMEMCE       *   FILE 895\n//*     should be called to end up the lines with '00'x.            *   FILE 895\n//*                                                                 *   FILE 895\n//*     I've also changed TALLY to work under z/OS 1.13.  I know    *   FILE 895\n//*     you don't need TALLY anymore, because DSLIST now can do     *   FILE 895\n//*     this for you.  But the idea behind TALLY is, to find        *   FILE 895\n//*     the ISPF table used by DSLIST and use it for your own       *   FILE 895\n//*     needs.  So I wrote DSL as an example, how to use this       *   FILE 895\n//*     table.  In DSL you can exclude Datasets from the list,      *   FILE 895\n//*     flip between excluded and visible and do HSM RECALL for     *   FILE 895\n//*     all visible Datasets.  I hope these programs will be a      *   FILE 895\n//*     help for someone.                                           *   FILE 895\n//*                                                                 *   FILE 895\n//*     CICSSUBS, IMSSUBS and MQSUBS list the active CICS, IMS      *   FILE 895\n//*     and MQ systems on the lpar. For DB2 please have a look at   *   FILE 895\n//*     DB2 update #124 February 2003, page 22ff.                   *   FILE 895\n//*                                                                 *   FILE 895\n//*     IS is a little CLIST to be used like this:                  *   FILE 895\n//*     //SET1 SET ENV=TEST                                         *   FILE 895\n//*     //TEST1 EXEC PGM=IKJEFT1A,                                  *   FILE 895\n//*     // PARM='IS &ENV EQ PROD'                                   *   FILE 895\n//*     //SYSTSPRT DD SYSOUT=*                                      *   FILE 895\n//*     //SYSPROC DD DISP=SHR,DSN=YOUR.CLIST.DSN                    *   FILE 895\n//*     //SYSTSIN DD DUMMY                                          *   FILE 895\n//*     //* RC = 4                                                  *   FILE 895\n//*     //TEST2 EXEC PGM=IKJEFT1A,                                  *   FILE 895\n//*     // PARM='IS &ENV EQ TEST'                                   *   FILE 895\n//*     //SYSTSPRT DD SYSOUT=*                                      *   FILE 895\n//*     //SYSPROC DD DISP=SHR,DSN=YOUR.CLIST.DSN                    *   FILE 895\n//*     //SYSTSIN DD DUMMY                                          *   FILE 895\n//*     //* RC = 0                                                  *   FILE 895\n//*                                                                 *   FILE 895\n//*     Lionel B. Dyck send me a TSO help for STEMEDIT. I put       *   FILE 895\n//*     this XMIT of a PO SYSHELP dataset to member TSOHELP.        *   FILE 895\n//*                                                                 *   FILE 895\n//*     To allocate a SYSHELP dataset before the existing           *   FILE 895\n//*     allocation I put a REXX to do it in ALOCHELP, the name      *   FILE 895\n//*     of the dataset should be given as parm.                     *   FILE 895\n//*                                                                 *   FILE 895\n//*     ILIBS is a REXX to show the concatination of datasets       *   FILE 895\n//*     under the ISPF dd names including the datasets concatinated *   FILE 895\n//*     with LIBDEF.                                                *   FILE 895\n//*                                                                 *   FILE 895\n//*     OLDS is a REXX I hope noone will ever need it. It shows     *   FILE 895\n//*     IMS LogSequenceNumber errors in an OLDS. It can be used in  *   FILE 895\n//*     3.4 DSLIST.                                                 *   FILE 895\n//*                                                                 *   FILE 895\n//*     STEMOUT is a shortened STEMEDIT, just to write all vars     *   FILE 895\n//*     to a dataset, while you run the REXX in batch.              *   FILE 895\n//*                                                                 *   FILE 895\n//*     Rainer Nowak                                                *   FILE 895\n//*                                                                 *   FILE 895\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALOCHELP": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01\\x17\\x15/\\x01\\x17\\x15/\"\\x00\\x00\\\\\\x00\\\\\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-06-01T00:00:00", "modifydate": "2017-06-01T22:00:41", "lines": 92, "newlines": 92, "modlines": 0, "user": "RNOWAK"}, "text": "/* REXX **************************************************************/\n/* MEMBER : ALOCHELP                                                 */\n/* DESCRIPTION:                                                      */\n/* Allocate the dataset userid.HELP          or the dataset given as */\n/* parm as file SYSHELP.                                             */\n/*********************************************************************/\nARG help_dsn\nSIGNAL ON ERROR\n\nDDNAME = SYSHELP\nBLANK = ' '\nDSLIST= ' '\nDA = NO\nX=OUTTRAP(SYSOUTLINE.)\nADDRESS TSO \"LISTALC STATUS\"\nX=OUTTRAP(OFF)\nL = 1\nLINES = SYSOUTLINE.0\nDO WHILE L <= LINES\n   LINE = SYSOUTLINE.L\n   ZW = LEFT(LINE,1)\n   IF ZW = BLANK THEN\n      DO\n      DD = SUBSTR(LINE||'             ',3,8)\n      DD = DD\n      IF DD = DDNAME THEN\n         DO\n         DA = YES\n         LL = L\n         END\n      END\n   L = L + 1\n   END\nIF help_dsn = '' THEN DO\n   help_dsn = Userid()||'.HELP'\nEND\nDSN = \"'\"help_dsn\"'\"\nTESTDSN = help_dsn\nIF DA = NO THEN DO\n   SAY ' DD 'DDNAME' NOT ALLOCATED, ALLOCATING 'DSN' TO 'DDNAME\n   ADDRESS TSO \"ALLOCATE F(\"DDNAME\") DSN(\"DSN\") SHR\"\n   CC = RC\n   IF CC \u00ac= 0 THEN DO\n      SAY 'ALLOCATION FOR 'DSN' FAILED, RC='CC\n      EXIT 4\n      END\n   EXIT 0\n   END\nI = 0\nNDD = NO\nDO WHILE NDD = NO\n   LL = LL - 1\n   I = I + 1\n   SAVEDSN.I = SYSOUTLINE.LL\n   LL = LL + 3\n   IF LL > SYSOUTLINE.0 THEN NDD = YES\n   ELSE DO\n      LINE = SYSOUTLINE.LL\n      LINEDD = SUBSTR(LINE||'             ',3,8)\n      LINEDD = LINEDD\n      IF LINEDD \u00ac= BLANK THEN NDD = YES\n      END\n   END\nII = 1\nDO WHILE II <= I\n   DSNAME = SAVEDSN.II\n   IF DSNAME = TESTDSN THEN DO\n      EXIT 0\n      END\n   DSNAME = \"'\"||DSNAME||\"'\"\n   DSLIST = DSLIST||\"      \"||DSNAME\n   II = II + 1\n   END\n\"FREE F(\"DDNAME\")\"\n\"ALLOC F(\"DDNAME\") DA(\"DSN\" \"DSLIST\") SHR\"\nCC = RC\nIF CC \u00ac= 0 THEN DO\n   SAY 'ALLOCATION FAILED'\n   SAY 'RESTORING OLD ALLOCATION'\n   \"ALLOC F(\"DDNAME\") DA(\"DSLIST\") SHR REUSE\"\n   EXIT 4\n   END\nSAY \"SYSHELP '\"help_dsn\"' ALLOCATED\"\nEXIT 0\n\n/*********************************************************************/\n/* subroutines                                                       */\n/*********************************************************************/\nERROR:\n say 'REXX error' rc 'in line' sigl\n say \"SOURCELINE\"(sigl)\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CICSSUBS": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00S\\x01\\x17\\x08\\x0f\\x01  O\\x174\\x01o\\x01o\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-03-21T00:00:00", "modifydate": "2020-07-22T17:34:53", "lines": 367, "newlines": 367, "modlines": 0, "user": "RNOWAK"}, "text": "/* REXX **************************************************************/\n/* CICSSUBS                                                          */\n/* Find all running CICS systems on this LPAR                        */\n/* Rainer Nowak, 2015                                                */\n/*********************************************************************/\nnumeric digits 10\n/* init variables                                                    */\ncicsprog = 'DFHSIP'              /* CICS Main program                */\nascb. = 'NO'\napf. = ''\napf.0 = 0\nenq. = ''\npanz = 0\nascb_output = 'NO'\n\n/* main program                                                      */\nCALL find_ascb                         /* search all running jobs    */\nCALL search_apf                        /* search all APF datasets    */\nIF apf.0 = 0 THEN DO\n   SAY 'No APF-datasets with 'cicsprog' found.'\n   EXIT(8)\nEND\nCALL find_enqueue              /* any enqueues on this datasets?     */\nSAY 'Possible active CICS SDFHAUTH datasets'\nSAY '======================================'\nSAY ' '\nSAY 'System: 'MVSVAR('SYSNAME')\nSAY ' '\nDO i = 1 TO apf.0\n   SAY 'Dataset: 'apf.i\n   SAY 'Version: 'cics_ver(apf.i)\n   if enq.i.0 = 0 then do\n      SAY '   No Jobs/STCs found'\n      SAY ' '\n   end\n   else do\n    SAY '   Jobname  S/J Stepname Procstep UserID'\n    DO j = 1 TO enq.i.0\n     job = enq.i.j.1\n     if ascb.job.1 = 'YES' then do\n      SAY '   'job' 'ascb.job.3' 'ascb.job.4' 'ascb.job.5' 'ascb.job.6\n     end\n    END\n    SAY enq.i.89.3\n    SAY  ' '\n   end\nEND\nIF panz > 0 THEN DO\n  SAY \"Following datasets can't be checked for \"cicsprog\" because\"\n  SAY \"you don't have READ permission:\"\n  DO i = 1 TO panz\n     SAY p_noRead.i\n  END\n  SAY ' '\nEND\nIF ascb_output = 'YES' THEN DO\n  SAY 'More ENQUEUES than can displayed, so here are all ASCB:'\n  SAY ' '\n  SAY '   Jobname  S/J Stepname Procstep UserID'\n  DO i = 1 TO p_ascb.0\n     SAY p_ascb.i\n  END\nEND\nEXIT\n\n/* Subroutines                                                       */\nfind_ascb:\nCVT    = STORAGE(10,4)                         /* ADDR CVT           */\nDCVT   = C2D(CVT)                              /* CONVERT TO DECIMAL */\nDASVT  = PTR(DCVT+556,4)                       /* ADDR ASVT          */\nASCNT  = PTR(DASVT+516,4)                      /* ADDR ASCBCNT       */\naanz = 0\nDO I     = 1 TO ASCNT\n   ASCB  = STORAGE(C2X(D2C(DASVT+524+I*4)),4)  /* ADDR ASCB FROM ASVT*/\n   IF   ABBREV(C2X(ASCB),'80')  = 1            /* IS IT VALID?       */\n        THEN ITERATE                           /* NO, LEAVE FOR NEXT */\n   ELSE IF   STORAGE(C2X(ASCB),4) /= 'ASCB'    /* IS IT ALLOCATED?   */\n             THEN ITERATE                      /* NO, LEAVE FOR NEXT */\n   DASCB = C2D(ASCB)                           /* CONVERT TO DECIMAL */\n   TSB   = STG(DASCB+60,4)                     /* LOAD TSB ADDRESS   */\n   IF    TSB /= '00000000'X  THEN              /* ANY ADDR IN THERE  */\n         TYPE = 'TSO'                          /* YES, ITS A TSO     */\n   ELSE  TYPE = 'STC'                          /* NO, ASSUME STC     */\n   UID   = STG(DASCB+172,4)                    /* LOAD ASCBJOBI ADDR */\n   IF    C2X(UID) = 00000000 THEN              /* IS THERE AN ADDR?  */\n         UID = STG(DASCB+176,4)                /* NO, MUST BE A STC  */\n   ELSE  TYPE = 'JOB'                          /* YES, MAKE TYPE JOB */\n   UID   = STORAGE(C2X(UID),8)                 /* GET JOB/STC NAME   */\n   DCSCB = PTR(DASCB+X2D(38),4)                /* LOAD CSCB ADDRESS  */\n   STEPN = STG(DCSCB+16,8)                     /* GET STEP NAME      */\n   PROCN = STG(dcscb+32,8)                     /* GET PROCSTEP NAME  */\n   DOUCB = PTR(DASCB+X2D(90),4)                /* LOAD CSCB ADDRESS  */\n   USER  = STG(doucb+208,8)\n   if ascb.UID.1 = 'YES' then do\n      ascb.UID.2 = ascb.UID.2 + 1\n   end\n   else do\n      ascb.UID.1 = 'YES'                       /* Job exist          */\n      ascb.UID.2 = 1                           /* how often exist job*/\n      ascb.UID.3 = TYPE                        /* STC/TSO/JOB        */\n      ascb.UID.4 = STEPN                       /* STEPNAME           */\n      ascb.UID.5 = PROCN                       /* PROCSTEP NAME      */\n      ascb.UID.6 = USER                        /* USERID             */\n      aanz = aanz + 1\n      p_ascb.aanz = '   'UID' 'TYPE' 'STEPN' 'PROCN' 'USER\n   end\n   p_ascb.0 = aanz\nEND\nRETURN\nsearch_apf:\nADDRESS TSO\npref = SYSVAR(SYSPREF)\n\"profile noprefix\"\nCTR = 0\nCVT    = STORAGE(10,4)\nDCVT   = C2D(CVT)\nADDR1  = STG(DCVT+484,4)\nCADDR1 = C2X(ADDR1)\nIF CADDR1 = 7FFFF001 THEN DO\n   CVT = STORAGE(10,4)                /* POINT TO CVT                */\n   CVTADR   = C2X(STORAGE(10,4))      /* CONVERT OFFSET 16 TO HEX    */\n   CVTDEC   = X2D(CVTADR)             /* DECMALIZE PTR               */\n   CVTDEC   = CVTDEC - 29             /* GET ADDRESS OF CVT PREFIX   */\n   CVTPFX   = D2X(CVTDEC,8)           /* CONVERT TO HEX              */\n   CVTPROD  = STORAGE(CVTPFX,4)       /* EBCDIC FORMAT OF SP LEVEL   */\n   CVTECVT  = 140             /* X'008C' - OFFSET INTO CVT FOR ECVT  */\n   ECVTCSVT  = 228            /* X'00E4' - OFFSET INTO ECVT FOR CSVT */\n   CSVTAPFA = 12              /* X'000C' - OFFSET INTO CSVT FOR APFA */\n   APFAAPHT = 8               /* X'0009' - OFFSET INTO APFA FOR APHT */\n   ECVT = STORAGE(D2X(C2D(CVT)+CVTECVT),4)          /* POINT TO ECVT */\n   CSVT = STORAGE(D2X(C2D(ECVT)+ECVTCSVT),4)        /* POINT TO CSVT */\n   APFA = STORAGE(D2X(C2D(CSVT)+CSVTAPFA),4)        /* POINT TO APFA */\n   APHT = STORAGE(D2X(C2D(APFA)+APFAAPHT),4)        /* POINT TO APHT */\n   DO WHILE APHTNEXT ^= ('00000000'X)\n      I = ctr + 1\n      CKSMS = STORAGE(D2X(C2D(APHT)+4),1)\n      IF  BITAND(CKSMS,'80'x) = '80'x THEN DO      /*  SMS dataset ? */\n         VOL.I = '*SMS* '                          /* SMS control    */\n      END\n      ELSE DO\n         VOL.I = STORAGE(D2X(C2D(APHT)+68),6)      /* PRINT VOLSER   */\n      END\n      DSN.I = STORAGE(D2X(C2D(APHT)+24),44)        /* GET DSN        */\n      APHTNEXT = STORAGE(D2X(C2D(APHT)+8),4)    /* POINT TO NEXT APHT*/\n      APHT     = APHTNEXT                       /* REFERENCE NEW ONE */\n      CTR      = CTR + 1                        /* ADD TO COUNTER    */\n      PARSE UPPER VAR VOL.I VOL.I ' '\n      PARSE UPPER VAR DSN.I DSN.I ' '\n      if SUBSTR(DSN.I,2) = 'YS1.LINKLIB' then DSN.I = 'SYS1.LINKLIB'\n      IF APHTNEXT = ('00000000'X) THEN DO\n         VOL.0 = ctr\n         DSN.0 = ctr\n      END\n   END\nEND\nELSE DO\n   DATA   = STORAGE(CADDR1,2)\n   NUMENT = SUBSTR(DATA,1,2)\n   DNUMENT = C2D(NUMENT)\n   LEN    = (DNUMENT * 51) + 2\n   DATA   = STORAGE(CADDR1,LEN)\n   START  = 3\n   DO I = 1 TO DNUMENT\n      LEN = SUBSTR(DATA,START,1)\n      DLEN1 = C2D(LEN)\n      DLEN2 = DLEN1 - 6\n      VOL.I = SUBSTR(DATA,START+1,6)\n      DSN.I = SUBSTR(DATA,START+7,DLEN2)\n      START = START + 1 + DLEN1\n      PARSE UPPER VAR VOL.I VOL.I ' '\n      PARSE UPPER VAR DSN.I DSN.I ' '\n      if SUBSTR(DSN.I,2) = 'YS1.LINKLIB' then DSN.I = 'SYS1.LINKLIB'\n   END\n   VOL.0 = DNUMENT\n   DSN.0 = DNUMENT\nEND\ndo i = 1 to DSN.0\n   APFDSN = DSN.i\n   IF llq(APFDSN) = 'SDFHAUTH' THEN DO\n      msgval = MSG('OFF')\n      retcode = LISTDSI(\"'\"APFDSN\"' SMSINFO NORECALL\")\n      msgval = MSG(msgval)\n      IF sysreason = 9 THEN DO   /* dataset migrated   */\n         NOP\n      END\n      ELSE DO\n         anz = apf.0\n         anz = anz + 1\n         apf.0 = anz\n         apf.anz = APFDSN\n      END\n   END\nend\nADDRESS TSO\nif pref = '' then \"profile noprefix\"\nelse \"profile prefix(\"pref\")\"\nRETURN\nfind_enqueue:\nADDRESS ISPEXEC\n\"CONTROL ERRORS CANCEL\"\ndo i = 1 to apf.0\n   eqdsn = apf.i\n   eqdsn = STRIP(''eqdsn'',,\"'\")\n   major = '*'\n   minor = eqdsn\n   \"QUERYENQ TABLE(WUECENQ) QNAME(MAJOR) RNAME(MINOR)\"\n   qrc = RC\n   tbl = 'WUECENQ'\n   IF qrc < 5 THEN DO\n      ADDRESS ISPEXEC\n      'TBTOP' tbl\n      IF rc>0 THEN DO\n         ZEDLMSG=\"TBTOP failed for table\" tbl \"RC=\"rc\n         \"ISPEXEC SETMSG MSG(ISRZ001)\"\n         EXIT 8\n      END\n      rows=0                                       /* Init counters */\n      DO FOREVER\n        'TBSKIP' tbl                               /* NEXT ROW      */\n        IF rc>0 THEN LEAVE\n        'TBGET' tbl                                /* SET VARIABLES */\n        IF rc>0 THEN LEAVE\n        rows=rows+1                                /* count rows    */\n        enq.i.0 = rows\n        enq.i.rows.1 = LEFT(ZENJOB,8,' ')\n        enq.i.rows.2 = ZENSYST\n      END\n      'TBEND' tbl\n   END\n   IF qrc = 8 | qrc = 10 THEN DO             /* No ENQ held         */\n      enq.i.0 = 0\n   END\n   IF qrc = 4 THEN DO              /* Too many enqueues             */\n      enq.i.89.3 = 'More ENQUEUES exist.'\n      ascb_output = 'YES'\n   END\nend\nRETURN\ncics_ver:\narg dsn\nADDRESS TSO\npref = SYSVAR(SYSPREF)\n\"profile noprefix\"\nver = '???'\nretcode = LISTDSI(\"'\"dsn\"' SMSINFO NORECALL\")\n\"ispexec DSINFO DATASET('\"dsn\"')\"\naa = RACAUTH(dsn,'READ')\nIF aa = 1 THEN DO\n   cc = 0                /* Returncode                            */\n   l. = 0\n   in. = ''\n   IDLIB=''\n   \"ISPEXEC LMINIT DATAID(IDLIB) DATASET('\"dsn\"')\"\n   \"ISPEXEC LMOPEN DATAID(\"IDLIB\")\"\n   \"ISPEXEC LMMFIND DATAID(\"IDLIB\") MEMBER(\"cicsprog\") STATS(NO)\"\n   cmdLMGET=\"ISPEXEC LMGET DATAID(\"IDLIB\") MODE(INVAR) DATALOC(EXEREC)\",\n            \"DATALEN(EXELEN) MAXLEN(32760)\"\n   rcLMGET=0\n   vi=0\n   do while rcLMGET=0\n       cmdLMGET; rcLMGET=rc\n       if rcLMGET=0 then do\n        vi=vi+1\n        in.vi=exerec\n        l.vi=exelen\n       end\n     if rcLMGET>=8 /*eof*/ then cmdLMGET\n   end\n   in.0=vi\n   \"ISPEXEC LMCLOSE DATAID(\"IDLIB\")\"\n   \"ISPEXEC LMFREE DATAID(\"IDLIB\")\"\n   IF ZDSDSNT <> 'LIBRARY' THEN DO\n      DO j= 1 TO in.0\n         IF LEFT(in.j,8) = '*DFHCICS' THEN DO\n            ver = SUBSTR(in.j,14,4)' = 'SUBSTR(in.j,78,12)\n            j = in.0 + 1\n         END\n      END\n   END\n   ELSE DO  /* read first 100 chars of program in a program object  */\n     l = LENGTH(in.1)       /* length of row, normaly 4096          */\n     eyecatcher = SUBSTR(in.1,1,8)\n     IF eyecatcher = 'IEWPLMH ' THEN DO\n        /* Offset of PMAR:                                          */\n        opmar = x2d(c2x(SUBSTR(in.1,53,4)))\n        /* Offset of program entry in PMAR:                         */\n        opment = opmar + 44\n        zs = O2ZS(opment,l)\n        z = WORD(zs,1) + 0\n        s = WORD(zs,2) + 0\n        oentry = x2d(c2x(SUBSTR(in.z,s,4)))\n        zs = O2ZS(oentry,l)\n        z = WORD(zs,1) + 0\n        s = WORD(zs,2) + 0\n        if l - s >= 99 then do\n           pganf = SUBSTR(in.z,s,100)\n        end\n        else do\n           rl = (l - s) +1\n           pganf = SUBSTR(in.z,s,rl)\n           zr = z +1\n           pganf = pganf||SUBSTR(in.zr,1,100-rl)\n        end\n        ver = SUBSTR(pganf,14,4)' = 'SUBSTR(pganf,78,12)\n     END\n     ELSE DO\n        ver = '???'\n     END\n   END\nEND\nELSE DO\n   ver = '???'\nEND\nADDRESS TSO\nif pref = '' then \"profile noprefix\"\nelse \"profile prefix(\"pref\")\"\nRETURN ver\n/*-------------------------------------------------------------*/\nPTR: RETURN C2D(STORAGE(D2X(ARG(1)),ARG(2)))\n/*-------------------------------------------------------------*/\nSTG: RETURN STORAGE(D2X(ARG(1)),ARG(2))\n/*-------------------------------------------------------------*/\n/* ================================================================= */\nLLQ: PROCEDURE\nARG dsn\ndsn = STRIP(dsn,'B',' ')\nllq = SUBSTR(dsn,LASTPOS('.',dsn)+1)\nRETURN llq\n/* O2ZS   - calculate row (z) and column (s) from offset            */\nO2ZS: PROCEDURE\nARG offset,l\nz = offset % l\nz = z + 1\ns = offset // l\ns = s + 1\nRETURN z' 's\n\n/********************************************************************/\nRACAUTH: PROCEDURE\nARG dsn,wacc\nw = POS(wacc,'NONE READ UPDATE CONTROL ALTER')\nIF w = 0 THEN DO\n   SAY 'WRONG PARM IN RACAUTH: 'wacc\n   EXIT 8\nEND\ndsn = \"'\"dsn\"'\"\nx=OUTTRAP(\"ldsn.\")\nADDRESS TSO \"LISTDSD DATASET(\"dsn\") GENERIC ALL\"\nx=OUTTRAP(\"OFF\")\nacc = 'NONE'\nIF LEFT(ldsn.15,11) = 'YOUR ACCESS' THEN DO\n   acc = WORD(ldsn.17,1)\nEND\nELSE DO\n   do i=1 to ldsn.0\n      IF LEFT(ldsn.i,11) = 'YOUR ACCESS' THEN DO\n         j = i + 2\n         acc = WORD(ldsn.j,1)\n         i = ldsn.0 + 1\n      END\n   end\nEND\nh = POS(acc,'NONE READ UPDATE CONTROL ALTER')\nIF h >= w THEN erg = 1\nELSE erg = 0\nRETURN erg\n/********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSL": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00)\\x01\\x17\\x08\\x0f\\x01  O\\x175\\x01T\\x01T\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-03-21T00:00:00", "modifydate": "2020-07-22T17:35:29", "lines": 340, "newlines": 340, "modlines": 0, "user": "RNOWAK"}, "text": "/* REXX **************************************************************/\n/* MEMBER : DSL                                                      */\n/*                                                                   */\n/* DESCRIPTION:                                                      */\n/* REXX to work with the DSLIST (=3.4).                              */\n/* Must be called from within DSLIST.                                */\n/* To fill up all fields in the DSLIST panel, you must scroll to the */\n/* left (or right) and to the bottom.                                */\n/* %DSL X parm=value : eXclude Datasets from the list. parm can be   */\n/*                     EXT (for extents), ORG, RECFM, LRECL, BLKSIZ  */\n/*                     (for which the value must match) and CAT, VOL,*/\n/*                     CDATE, EDATE, RDATE, DSN (for which value only*/\n/*                     needs to be included). Always all matching    */\n/*                     datasets will be excluded.                    */\n/*                                                                   */\n/* %DSL FLIP         : like FLIP in the editor you flip between      */\n/*                     excluded and visible.                         */\n/*                                                                   */\n/* %DSL HR           : HSM RECALL will be send for all visible       */\n/*                     migrated datasets. This is just an example    */\n/*                     how to work with the DSLIST table.            */\n/*                                                                   */\n/* Example: Exclude all PDS  %DSL X ORG=PO                           */\n/*                                                                   */\n/* AUTHOR : Rainer Nowak                                             */\n/* DATE   : 30.05.2013                                               */\n/* UPDATE : 23.02.2015                                               */\n/*                                                                   */\n/*********************************************************************/\nARG p1 p2\nSELECT\n   WHEN p1 = 'X' THEN CALL Wue_DSL_X\n   WHEN p1 = 'HR' THEN CALL Wue_DSLHR\n   WHEN p1 = 'FLIP' THEN CALL Wue_DSL_Flip\n   OTHERWISE DO\n    SAY 'WRONG PARM. ONLY X, HR OR FLIP ARE ALLOWED.'\n   END\nEND\nEXIT\n/* ================================================================= */\n/* === Subroutins ================================================== */\n/* ================================================================= */\n\n/* ================================================================= */\n/* Pointer function                                                  */\n/* ================================================================= */\nPTR: RETURN C2D(STORAGE(D2X(ARG(1)),ARG(2)))\n/* ================================================================= */\n/* Routine to search all open tables - the heart of this REXX        */\n/* ================================================================= */\n/* get_OTab                                                          */\n/* search the open tables of this ISPF screen.                       */\n/*                                                                   */\n/* The table of 3.4 has the name DSLnnnnn with variables:            */\n/* ZUDSNS       ZUSIZE       ZUUS         ZUCDATE      ZUEDATE       */\n/* ZURDATE      ZUDVOL       ZUDMVOL      ZUDEVICE     ZUCDAT2       */\n/* ZUEDAT2      ZURDAT2      ZUORG        ZUX          ZURECFM       */\n/* ZULRECL      ZUBLKSIZ     ZUSTAT       ZUDSPACU     ZULMSG        */\n/* ZULOCVOL     ZUOBTATT     ZUOBTSPC     ZUOBTDAT     ZUDXSTAT      */\n/* ZULCMDL      ZUD20V       ZUDVOL7      ZUCATNAM     ZUSIZEX       */\n/* ZUXX         ZUOVF        ZUGFLAG      ZUEATR                     */\n/* ================================================================= */\nget_OTab:\n/* get all open tables            */\n\"ISPEXEC QTABOPEN LIST(myvar)\"\notnr = 0\notab.0 = otnr\ndo i = 1 to myvar0\n   INTERPRET 'tab = myvar'i\n   \"ISPEXEC TBSTATS \"tab\" STATUS2(stat)\"\n   if stat > 1 & stat <= 5 then do  /* table is open in this screen? */\n      otnr = otnr + 1\n      otab.0 = otnr\n      otab.otnr = tab\n   end\nend\n/* Status2:\n1 table is not open in this logical screen\n2 table is open in NOWRITE mode in this logical screen\n3 table is open in WRITE mode in this logical screen\n4 table is open in SHARED NOWRITE mode in this logical screen\n5 table is open in SHARED WRITE mode in this logical screen\n*/\nRETURN\n/* ================================================================= */\n/* Routine to exclude datasets from the list                         */\n/* ================================================================= */\nWue_DSL_X:\nCALL get_OTab\nif otab.0 > 0 then do\n   tbl = ''\n   do i = 1 to otab.0\n      if LEFT(otab.i,3) = 'DSL' then do\n         tbl = otab.i\n         i = otab.0 + 1\n      end\n   end\n   if LEFT(tbl,3) = 'DSL' then do\n      CALL X_parm\n      IF parm = 'NIX' THEN DO\n         \"ISPEXEC SETMSG MSG(ISRZ001)\"\n         EXIT\n      END\n      ADDRESS ISPEXEC\n      'CONTROL ERRORS RETURN'\n      'TBTOP' tbl\n      IF rc>0 THEN DO\n         ZEDLMSG=\"TBTOP failed for table\" tbl \"RC=\"rc\n         \"ISPEXEC SETMSG MSG(ISRZ001)\"\n         EXIT 8\n      END\n      rows=0;processed=0                           /* Init counters */\n      DO FOREVER\n        'TBSKIP' tbl                               /* NEXT ROW      */\n         IF rc>0 THEN LEAVE\n         'TBGET' tbl                               /* SET VARIABLES */\n         IF rc>0 THEN LEAVE\n         rows=rows+1                               /* count rows    */\n         IF zudxstat = 'N' THEN DO\n            IF parm = 'ALL' THEN DO\n               zudxstat = 'Y'\n               'TBPUT' tbl                         /* PUT VARIABLES */\n               IF RC = 0 THEN processed=processed + 1\n            END\n            ELSE DO\n             IF match = 'IN' THEN DO\n               IF POS(matchvalue,VALUE(parm)) > 0 THEN DO\n                  zudxstat = 'Y'\n                  'TBPUT' tbl                      /* PUT VARIABLES */\n                  IF RC = 0 THEN processed=processed + 1\n               END\n             END\n             ELSE DO\n               IF VALUE(parm) = matchvalue THEN DO\n                  zudxstat = 'Y'\n                  'TBPUT' tbl                      /* PUT VARIABLES */\n                  IF RC = 0 THEN processed=processed + 1\n               END\n             END\n            END\n         END\n      END\n      ZEDLMSG=\"EXCLUDE for \"processed\" of \"rows\" datasets performed.\"\n      IF processed = 0 THEN DO\n         ZEDLMSG=ZEDLMSG||\" Use LEFT and DOWN to fill up the fields|\"\n      END\n      ZEDSMSG=\"EXCLUDE performed||\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      \"ISPEXEC CONTROL NONDISPL ENTER\" /* skip one ENTER         */\n   end\n   else do\n      ZEDLMSG=\"DSL X must be called in DSLIST (=3.4).\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      EXIT 8\n   end\nend\nelse do\n   ADDRESS ISPEXEC\n   ZMSG000S = 'No open tables'\n   ZMSG000L = 'No open tables can be found.'\n   \"SETMSG MSG(ISPZ000)\"\nend\nRETURN\n/* ================================================================= */\n/* Routine to validate parm=value in DSL X parm=value                */\n/* ================================================================= */\nX_parm:\nIF p2 = '' THEN DO\n   parm = 'ALL'\nEND\nELSE DO\n   PARSE VAR p2 parm '=' matchvalue\n   match = 'IN'\n   SELECT\n      WHEN parm = 'VOL' THEN DO   /* Volser                          */\n         parm = 'ZUDVOL7'\n      END\n      WHEN parm = 'EXT' THEN DO   /* Extents                         */\n         parm = 'ZUX'\n         match = 'EQ'\n      END\n      WHEN parm = 'ORG' THEN DO   /* Dataset organisation            */\n         parm = 'ZUORG'\n         match = 'EQ'\n      END\n      WHEN parm = 'RECFM' THEN DO   /* Recordformat                  */\n         parm = 'ZURECFM'\n         match = 'EQ'\n      END\n      WHEN parm = 'LRECL' THEN DO   /* Recordlength                  */\n         parm = 'ZULRECL'\n         match = 'EQ'\n      END\n      WHEN parm = 'BLKSIZ' THEN DO   /* Blocksize                    */\n         parm = 'ZUBLKSIZ'\n         match = 'EQ'\n      END\n      WHEN parm = 'CAT' THEN parm = 'ZUCATNAM'   /* Catalogname      */\n      WHEN parm = 'CDATE' THEN parm = 'ZUCDATE'  /* Creation Date    */\n      WHEN parm = 'EDATE' THEN parm = 'ZUEDATE'  /* Expiration Date  */\n      WHEN parm = 'RDATE' THEN parm = 'ZURDATE'  /* Last Reference   */\n      WHEN parm = 'DSN' THEN parm = 'ZUDSNS'     /* Dataset name     */\n      OTHERWISE DO\n         ZEDLMSG=\"Wrong Parm :\"parm\n         parm = 'NIX'\n      END\n   END\nEND\nRETURN\n/* ================================================================= */\n/* Routine to flip between excluded and visible                      */\n/* ================================================================= */\nWue_DSL_Flip:\nCALL get_OTab\nif otab.0 > 0 then do\n   tbl = ''\n   do i = 1 to otab.0\n      if LEFT(otab.i,3) = 'DSL' then do\n         tbl = otab.i\n         i = otab.0 + 1\n      end\n   end\n   if LEFT(tbl,3) = 'DSL' then do\n      ADDRESS ISPEXEC\n      'CONTROL ERRORS RETURN'\n      'TBTOP' tbl\n      IF rc>0 THEN DO\n         ZEDLMSG=\"TBTOP failed for table\" tbl \"RC=\"rc\n         \"ISPEXEC SETMSG MSG(ISRZ001)\"\n         EXIT 8\n      END\n      rows=0;processed=0                           /* Init counters */\n      DO FOREVER\n        'TBSKIP' tbl                               /* NEXT ROW      */\n         IF rc>0 THEN LEAVE\n         'TBGET' tbl                               /* SET VARIABLES */\n         IF rc>0 THEN LEAVE\n         rows=rows+1                               /* count rows    */\n         IF zudxstat = 'N' THEN DO\n            zudxstat = 'Y'\n         END\n         ELSE DO\n            zudxstat = 'N'\n         END\n         'TBPUT' tbl                               /* PUT VARIABLES */\n         IF RC = 0 THEN processed=processed + 1\n      END\n      ZEDLMSG=\"FLIP for \"processed\" of \"rows\" datasets performed.\"\n      ZEDSMSG=\"FLIP performed||\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      \"ISPEXEC CONTROL NONDISPL ENTER\" /* skip one ENTER             */\n   end\n   else do\n      ZEDLMSG=\"DSL FLIP must be called in DSLIST (=3.4).\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      EXIT 8\n   end\nend\nelse do\n   ADDRESS ISPEXEC\n   ZMSG000S = 'No open tables'\n   ZMSG000L = 'No open tables can be found.'\n   \"SETMSG MSG(ISPZ000)\"\nend\nRETURN\n/* ================================================================= */\n/* Routine to RECALL a list of datasets                              */\n/* ================================================================= */\nWue_DSLHR:\nCALL get_OTab\nif otab.0 > 0 then do\n   tbl = ''\n   do i = 1 to otab.0\n      if LEFT(otab.i,3) = 'DSL' then do\n         tbl = otab.i\n         i = otab.0 + 1\n      end\n   end\n   if LEFT(tbl,3) = 'DSL' then do\n      ADDRESS ISPEXEC\n      'CONTROL ERRORS RETURN'\n      'TBTOP' tbl\n      IF rc>0 THEN DO\n         ZEDLMSG=\"TBTOP failed for table\" tbl \"RC=\"rc\n         \"ISPEXEC SETMSG MSG(ISRZ001)\"\n         EXIT 8\n      END\n      rows=0;processed=0                           /* Init counters */\n      DO FOREVER\n        'TBSKIP' tbl                               /* NEXT ROW      */\n         IF rc>0 THEN LEAVE\n         'TBGET' tbl                               /* SET VARIABLES */\n         IF rc>0 THEN LEAVE\n         rows=rows+1                               /* count rows    */\n         IF LEFT(zudvol7,6) = 'MIGRAT' & zudxstat = 'N' THEN DO\n            dsn = STRIP(zudsns,'B',' ')\n            ret = Wue_HR_Func(dsn)\n            IF ret = 9 THEN DO\n               say \"Dataset \"dsn\" is not migrated.\"\n            END\n            processed=processed + 1\n         END\n      END\n      ZEDLMSG=\"RECALL for \"processed\" of \"rows\" datasets was send.\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n   end\n   else do\n      ZEDLMSG=\"DSL HR must be called in DSLIST (=3.4).\"\n      \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      EXIT 8\n   end\nend\nelse do\n   ADDRESS ISPEXEC\n   ZMSG000S = 'No open tables'\n   ZMSG000L = 'No open tables can be found.'\n   \"SETMSG MSG(ISPZ000)\"\nend\nRETURN\n/* ================================================================= */\n/* Function to send HRECALL for one dataset                          */\n/* ================================================================= */\nWue_HR_Func:\nPROCEDURE\nARG dsn\npref = SYSVAR(SYSPREF)\nADDRESS TSO\n\"profile noprefix\"\nretcode = LISTDSI(\"'\"dsn\"' DIRECTORY SMSINFO NORECALL\")\nif SYSREASON = 9 then do   /* dataset migrated */\n   \"HRECALL ('\"dsn\"') NOWAIT\"\n   ret = RC\nend\nelse do\n   ret = 9\nEND\nADDRESS TSO\nif pref = '' then \"profile noprefix\"\nelse \"profile prefix(\"pref\")\"\nreturn ret\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ILIBS": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x01\\x17\\x15/\\x01\\x19\\x00\\x8f\\x128\\x01a\\x01F\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-06-01T00:00:00", "modifydate": "2019-01-08T12:38:27", "lines": 353, "newlines": 326, "modlines": 0, "user": "RNOWAK"}, "text": "/* REXX */\n/*********************************************************************/\n/*    SHOW current libs for the ISPF DD-names.                       */\n/*********************************************************************/\nfrog = \"FROG1\"\naddress \"TSO\"\n\"ALLOC DD(\"frog\") UNIT(VIO) DSORG(PS) LRECL(80) BLKSIZE(644)\",\n              \"SPACE(10,1) TRACKS  RECFM(V,B) NEW\"\nd1='//* Datasets now available under the DD-Names:'\ndummy2 = Sachma(frog,d1)\ndummy = WUESDD('ISPPLIB')\nIF WORDS(dummy) > 0 THEN DO\n j = WORDS(dummy)\n d1='//ISPPLIB  DD DISP=SHR,DSN='||STRIP(WORD(dummy,1),\"B\",\"'\")\n dummy2 = Sachma(frog,d1)\n i = 1\n DO WHILE i < j\n  i = i + 1\n  d1='//         DD DISP=SHR,DSN='||STRIP(WORD(dummy,i),\"B\",\"'\")\n  dummy2 = Sachma(frog,d1)\n END\nEND\nELSE DO\n d1='//ISPPLIB  DD DUMMY'\n dummy2 = Sachma(frog,d1)\nEND\ndummy = WUESDD('ISPMLIB')\nIF WORDS(dummy) > 0 THEN DO\n j = WORDS(dummy)\n d1='//ISPMLIB  DD DISP=SHR,DSN='||STRIP(WORD(dummy,1),\"B\",\"'\")\n dummy2 = Sachma(frog,d1)\n i = 1\n DO WHILE i < j\n  i = i + 1\n  d1='//         DD DISP=SHR,DSN='||STRIP(WORD(dummy,i),\"B\",\"'\")\n  dummy2 = Sachma(frog,d1)\n END\nEND\nELSE DO\n d1='//ISPMLIB  DD DUMMY'\n dummy2 = Sachma(frog,d1)\nEND\ndummy = WUESDD('ISPSLIB')\nIF WORDS(dummy) > 0 THEN DO\n j = WORDS(dummy)\n d1='//ISPSLIB  DD DISP=SHR,DSN='||STRIP(WORD(dummy,1),\"B\",\"'\")\n dummy2 = Sachma(frog,d1)\n i = 1\n DO WHILE i < j\n  i = i + 1\n  d1='//         DD DISP=SHR,DSN='||STRIP(WORD(dummy,i),\"B\",\"'\")\n  dummy2 = Sachma(frog,d1)\n END\nEND\nELSE DO\n d1='//ISPSLIB  DD DUMMY'\n dummy2 = Sachma(frog,d1)\nEND\ndummy = WUESDD('ISPTLIB')\nIF WORDS(dummy) > 0 THEN DO\n j = WORDS(dummy)\n d1='//ISPTLIB  DD DISP=SHR,DSN='||STRIP(WORD(dummy,1),\"B\",\"'\")\n dummy2 = Sachma(frog,d1)\n i = 1\n DO WHILE i < j\n  i = i + 1\n  d1='//         DD DISP=SHR,DSN='||STRIP(WORD(dummy,i),\"B\",\"'\")\n  dummy2 = Sachma(frog,d1)\n END\nEND\nELSE DO\n d1='//ISPTLIB  DD DUMMY'\n dummy2 = Sachma(frog,d1)\nEND\ndummy = WUESDD('ISPLLIB')\nIF WORDS(dummy) > 0 THEN DO\n j = WORDS(dummy)\n d1='//ISPLLIB  DD DISP=SHR,DSN='||STRIP(WORD(dummy,1),\"B\",\"'\")\n dummy2 = Sachma(frog,d1)\n i = 1\n DO WHILE i < j\n  i = i + 1\n  d1='//         DD DISP=SHR,DSN='||STRIP(WORD(dummy,i),\"B\",\"'\")\n  dummy2 = Sachma(frog,d1)\n END\nEND\nELSE DO\n d1='//ISPLLIB  DD DUMMY'\n dummy2 = Sachma(frog,d1)\nEND\ndummy = WUESDD('ISPTABL')\nIF WORDS(dummy) > 0 THEN DO\n j = WORDS(dummy)\n d1='//ISPTABL  DD DISP=SHR,DSN='||STRIP(WORD(dummy,1),\"B\",\"'\")\n dummy2 = Sachma(frog,d1)\n i = 1\n DO WHILE i < j\n  i = i + 1\n  d1='//         DD DISP=SHR,DSN='||STRIP(WORD(dummy,i),\"B\",\"'\")\n  dummy2 = Sachma(frog,d1)\n END\nEND\nELSE DO\n d1='//ISPTABL  DD DUMMY'\n dummy2 = Sachma(frog,d1)\nEND\ndummy = WUESDD('SYSPROC')\nIF WORDS(dummy) > 0 THEN DO\n j = WORDS(dummy)\n d1='//SYSPROC  DD DISP=SHR,DSN='||STRIP(WORD(dummy,1),\"B\",\"'\")\n dummy2 = Sachma(frog,d1)\n i = 1\n DO WHILE i < j\n  i = i + 1\n  d1='//         DD DISP=SHR,DSN='||STRIP(WORD(dummy,i),\"B\",\"'\")\n  dummy2 = Sachma(frog,d1)\n END\nEND\nELSE DO\n d1='//SYSPROC  DD DUMMY'\n dummy2 = Sachma(frog,d1)\nEND\ndummy = WUESDD('SYSEXEC')\nIF WORDS(dummy) > 0 THEN DO\n j = WORDS(dummy)\n d1='//SYSEXEC  DD DISP=SHR,DSN='||STRIP(WORD(dummy,1),\"B\",\"'\")\n dummy2 = Sachma(frog,d1)\n i = 1\n DO WHILE i < j\n  i = i + 1\n  d1='//         DD DISP=SHR,DSN='||STRIP(WORD(dummy,i),\"B\",\"'\")\n  dummy2 = Sachma(frog,d1)\n END\nEND\nELSE DO\n d1='//SYSEXEC  DD DUMMY'\n dummy2 = Sachma(frog,d1)\nEND\n\"EXECIO 0 DISKW \"frog\" (FINIS\"\n\"ISPEXEC  LMINIT DATAID(ID) DDNAME(\"frog\")\"\n\"ISPEXEC  EDIT DATAID(\"ID\")\"\n\"FREE DD(\"frog\")\"\nEXIT\n/* ================================================================= */\n/*-------------------------------------------------------------------*/\n/* Sachma - Write in dataset                                         */\n/*-------------------------------------------------------------------*/\nSachma: PROCEDURE\nparse arg dd,text\npush text\nAddress TSO \"EXECIO 1 DISKW\" DD \"(\"\niorec = rc\nRETURN iorec\n/* ================================================================= */\n/*********************************************************************/\n/* WUESDD                                                            */\n/* DESCRIPTION:                                                      */\n/*    Function to return the current available datasets under the    */\n/*    given DD-name, incl. LIBDEFed datasets.                        */\n/* AUTHOR : R. Nowak                                                 */\n/*********************************************************************/\nWUESDD: PROCEDURE\nARG DDName\nIF DDName = '' THEN DO\n   SAY 'Wrong call of WUESDD. DD='DDName\n   EXIT 8\nEND\nlibd = check_DD(DDName)\n/* if libd = 1 (ddname is libdef-able) then user-dd has to be searched\nfirst, then libdef and at last the dd allocation, else only dd\nallocation has to be searched.                                       */\nSELECT  /* libd                                                      */\n  WHEN libd = 0 THEN DO\n   DSN_List = DD_DSNs(DDName)\n  END\n  WHEN libd = 1 THEN DO\n   SELECT\n      WHEN DDName = 'ISPFILE' THEN usrdd = 'ISPFILU'\n      WHEN DDName = 'ISPTABL' THEN usrdd = 'ISPTABU'\n      OTHERWISE DO\n         usrdd = LEFT(DDName,4)||'USR'\n      END\n   END    /* SELECT                                                 */\n   DSN_List = DD_DSNs(usrdd)\n   TYPvar = ''\n   IDvar = ''\n   /* QLIBDEF get RC=0 if LIBDEF-datsets exist and are stored in    */\n   /* var ID, RC=4 : no LIBDEF                                      */\n   /* Typ can be: DATASET, EXCLDATA, LIBRARY or EXCLLIBR.           */\n   \"ISPEXEC QLIBDEF \"DDName\" TYPE(TYPvar) ID(IDvar)\"\n   retcode = rc\n   SELECT\n      WHEN retcode = 0 THEN DO\n         SELECT  /* TYPvar                                          */\n            WHEN TYPvar = 'DATASET' | TYPvar = 'EXCLDATA' THEN DO\n               IDvar = translate(IDvar,' ',',')\n               LD_List = IDvar\n            END\n            WHEN TYPvar = 'LIBRARY' | TYPvar = 'EXCLLIBR' THEN DO\n               LD_List = DD_DSNs(IDvar)\n            END\n            OTHERWISE DO\n               LD_List = ''\n            END\n         END    /* SELECT TYPvar                                    */\n      END\n      WHEN retcode = 4 THEN DO\n         LD_List = ''\n      END\n      OTHERWISE DO\n         SAY 'ERROR in QLIBDEF |'\n         EXIT retcode\n      END\n   END     /* SELECT                                                 */\n   DSN_List = DSN_List||\"      \"||LD_List\n   DSN_List = DSN_List||\"      \"||DD_DSNs(DDName)\n  END\n  WHEN libd = 2 THEN DO\n   DSN_List = ALT_DD('CLIST')\n  END\n  WHEN libd = 3 THEN DO\n   DSN_List = ALT_DD('EXEC')\n  END\n  OTHERWISE DSN_List = ''\nEND     /* SELECT libd                                               */\nRETURN DSN_List\n/*********************************************************************/\n/* Subroutines                                                       */\n/*********************************************************************/\ncheck_DD: PROCEDURE\n/*********************************************************************/\n/* check_dd                                                          */\n/* Output is 1 if DD-name is LIBDEF-able, 2 if DD-name is SYSPROC,   */\n/* 3 if DD-name is SYSEXEC, otherwise 0.                             */\n/*********************************************************************/\nARG dd_name\nldef='ISPFILE ISPILIB ISPLLIB ISPMLIB ISPPLIB ISPSLIB ISPTABL ISPTLIB'\nIF WORDPOS(dd_name,ldef) > 0 THEN ret = 1\nELSE DO\n   IF dd_name = 'SYSPROC' THEN ret = 2\n   ELSE DO\n      IF dd_name = 'SYSEXEC' THEN ret = 3\n      ELSE ret = 0\n   END\nEND\nRETURN ret\n/*-------------------------------------------------------------------*/\nDD_DSNs: PROCEDURE\n/*********************************************************************/\n/* DD_DSNs                                                           */\n/* Returns the names of the under this dd-name allocated datasets    */\n/* in one string.                                                    */\n/*********************************************************************/\narg dd_name\nmsgval = MSG('OFF')\ndummy = outtrap('SYSOUTLINE.',10000)\nADDRESS TSO \"LISTALC STATUS\"\ndummy = outtrap('off')\nmsgval = MSG(msgval)\nDSLIST= ' '\nBLANK = ' '\nL = 1\nLINES = SYSOUTLINE.0\nDO WHILE L <= LINES\n   LINE = SYSOUTLINE.L\n   ZW = LEFT(LINE,1)\n   IF ZW = BLANK THEN DO\n      DD = SUBSTR(LINE||'             ',3,8)\n      DD = STRIP(DD,'B',' ')\n      IF DD = dd_name THEN DO\n         DA = YES\n         LL = L\n      END\n   END\n   L = L + 1\nEND\nIF DA = YES THEN DO\n   I = 0\n   NDD = NO\n   DO WHILE NDD = NO\n      LL = LL - 1\n      I = I + 1\n      SAVEDSN.I = SYSOUTLINE.LL\n      LL = LL + 3\n      IF LL > SYSOUTLINE.0 THEN NDD = YES\n      ELSE DO\n         LINE = SYSOUTLINE.LL\n         LINEDD = SUBSTR(LINE||'             ',3,8)\n         LINEDD = LINEDD\n         IF LINEDD \u00ac= BLANK THEN NDD = YES\n      END\n   END\n   II = 1\n   DO WHILE II <= I\n      DSNAME = SAVEDSN.II\n      DSNAME = \"'\"||DSNAME||\"'\"\n      DSLIST = DSLIST||\"      \"||DSNAME\n      II = II + 1\n   END\nEND\nELSE DO\n   DSLIST = \"\"\nEND\nRETURN DSLIST\n/*-------------------------------------------------------------------*/\nALT_DD:\nARG typ\ndummy = outtrap('LINES.',10000)\naddress \"TSO\"\n\"ALTLIB DISPLAY\"\ndummy = outtrap('off')\nausgabe = ''\nalt_typ = ''\nDO i=1 TO LINES.0\n   IF LEFT(LINES.i,3) = 'IKJ' THEN DO\n      PARSE VAR LINES.i msg d1 d2 .\n      if d1 = 'Stacked' then do\n         if typ = alt_typ then do\n            PARSE VAR LINES.i d1 '=' ddn .\n            ausgabe = ausgabe||' '||DD_DSNs(ddn)\n         end\n      end\n      else alt_typ = d2\n      IF POS(typ,LINES.i) > 0 THEN DO\n         PARSE VAR LINES.i d1 '=' ddn .\n         ausgabe = ausgabe||' '||DD_DSNs(ddn)\n      END\n   END\n   ELSE DO\n      PARSE VAR LINES.i d1 d2 .\n      if d1 = 'Stacked' then do\n         if typ = alt_typ then do\n            PARSE VAR LINES.i d1 '=' ddn .\n            ausgabe = ausgabe||' '||DD_DSNs(ddn)\n         end\n      end\n      else alt_typ = d2\n      IF POS(typ,LINES.i) > 0 THEN DO\n         PARSE VAR LINES.i d1 '=' ddn .\n         ausgabe = ausgabe||' '||DD_DSNs(ddn)\n      END\n   END\nEND\nRETURN ausgabe\n/*\nOutput from ALTLIB DISPLAY:\nIKJ79322I Current search order (by DDNAME) is:\nIKJ79324I User-level CLIST        DDNAME=SYSUPROC\nIKJ79326I Application-level CLIST DDNAME=SYS00094\nIKJ79321I                 Stacked DDNAME=SYS00226\nIKJ79327I System-level EXEC       DDNAME=SYSEXEC\nIKJ79328I System-level CLIST      DDNAME=SYSPROC\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IMSSUBS": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x17\\x08\\x0f\\x01  O\\x173\\x00\\xc9\\x00\\xc7\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-03-21T00:00:00", "modifydate": "2020-07-22T17:33:02", "lines": 201, "newlines": 199, "modlines": 0, "user": "RNOWAK"}, "text": "/* REXX *************************************************************/\n/********************************************************************/\n/* Build list of active IMS subsystems.                             */\n/* This is based on an article by                                   */\n/* Antonio Luis Salcedo Freidel                                     */\n/* Xephon - DB2 update #124 February 2003                           */\n/* page 22ff: ISPF dialog to obtain a list of DB2 subsystems        */\n/********************************************************************/\n/********************************************************************/\n/* Build a list of   active IMS subsystems.                         */\n/********************************************************************/\nNumeric Digits 256                  /* this must be at top of REXX. */\nCVTADDR = Get_Stor('10'x)      /* get communications vector address */\nSYSID = Strip(Get_Stor(CVTADDR,'154'x,8)) /* get MVS system id.     */\nd1 = 'Active IMS Systems on 'SYSID' :'\nsay d1\n/*------------------------------------------------------------------*/\n/* Traverse the list of subsystems known to JES.                    */\n/* JESCT = CVT+x'128' = Pointer to the JESCT                        */\n/* JESCT points to first SSCT which chains to next SSCT             */\n/*------------------------------------------------------------------*/\nJCTADDR = Get_Stor(CVTADDR,'128'x)   /* JES job control table block */\nSSCTADDR = Get_Stor(JCTADDR,24)      /* Address of first SSCT block */\nDO WHILE C2D(SSCTADDR) <> 0\n   /*---------------------------------------------------------------*/\n   /* get information from the SSCT control block.                  */\n   /*---------------------------------------------------------------*/\n   SUBSYS = Get_Stor(SSCTADDR,'8'x)      /* get the Subsystem name. */\n   ERLYADDR= Get_Stor(SSCTADDR,20)       /* get ERLY block address. */\n   SSVTADDR= Get_Stor(SSCTADDR,16)       /* get SSVT block address. */\n   SSU2ADDR= Get_Stor(SSCTADDR,28)       /* get SSU2 block address. */\n   /*---------------------------------------------------------------*/\n   /* get information from the ERLY control block.                  */\n   /*---------------------------------------------------------------*/\n   IF C2D(SSVTADDR)<>0 & C2D(ERLYADDR)<>0 & C2D(SSU2ADDR)=0 THEN DO\n    EYEC= Get_Stor(ERLYADDR,0,4)\n/*  IF C2X(EYEC) = 'F5000014' THEN DO                               */\n/* PTF in IMS V14 change this to 'F5000018                          */\n    IF LEFT(C2X(EYEC),6) = 'F50000' THEN DO\n     ZWADDR= Get_Stor(ERLYADDR,16)\n     EYEC2= Get_Stor(ZWADDR,0,4)\n     IF EYEC2 = 'SSCT' THEN DO\n      ZW2ADDR= Get_Stor(ZWADDR,20)\n      EYEC3= Get_Stor(ZW2ADDR,0,8)\n      if EYEC3 = 'SSCTEXT ' THEN DO\n         naddr= Get_Stor(ZW2ADDR,16)\n         neye1= Get_Stor(naddr,0,8)\n         neye2= Get_Stor(naddr,40,8)\n         if neye1 = 'DFSXSSCT' then do\n            STCNAME = neye2\n         end\n         else do\n            STCNAME = '        '\n         end\n         SSCDADDR= Get_Stor(ZW2ADDR,8)\n         if C2D(SSCDADDR) = 0 then do\n            NOP\n         end\n         else do\n            /* Get information from SSCD                            */\n            /* SSCD is descriped in IMS.SDFSMAC(SSCD)               */\n            SSCDEYE = Get_Stor(SSCDADDR,'0'x,4)\n            IMSID = Get_Stor(SSCDADDR,'1C'x,4)\n            IMSS1 = Get_Stor(SSCDADDR,'10'x,1)\n            IMSS2 = Get_Stor(SSCDADDR,'11'x,1)\n            IMSV1 = Get_Stor(SSCDADDR,'14'x,1)\n            IMSV2 = Get_Stor(SSCDADDR,'15'x,1)\n            IMSF1 = Get_Stor(SSCDADDR,'30'x,1)\n            IMSF2 = Get_Stor(SSCDADDR,'31'x,1)\n            IMSF3 = Get_Stor(SSCDADDR,'32'x,1)\n            IMSF4 = Get_Stor(SSCDADDR,'33'x,1)\n            IF SSCDEYE = 'SSCD' THEN DO\n               d1 = 'SubSysID: '||SUBSYS||'  hex: '||C2X(SUBSYS)\n               say d1\n               d1 = ' STCname: '||STCNAME\n               SAY d1\n               imsver = C2X(IMSV1)'.'C2X(IMSV2)\n               crc = IMSS2\n               i_ss = C2X(IMSS1)\n               i_f1 = C2X(IMSF1)\n               i_f2 = C2X(IMSF2)\n               i_f3 = C2X(IMSF3)\n               i_f4 = C2X(IMSF4)\n               SELECT\n                WHEN BITAND(X2B(i_ss),X2B('80'))='10000000' THEN DO\n                   ss1 = 'DBCTL SUBSYSTEM '\n                END\n                WHEN BITAND(X2B(i_ss),X2B('40'))='01000000' THEN DO\n                   ss1 = 'DCCTL SUBSYSTEM '\n                END\n                WHEN BITAND(X2B(i_ss),X2B('20'))='00100000' THEN DO\n                   ss1 = 'FDR SUBSYSTEM '\n                END\n                OTHERWISE ss1 = ''\n               END\n               SELECT\n                WHEN BITAND(X2B(i_ss),X2B('08'))='00001000' THEN DO\n                   ss2 = '/ DCCTL BATCH REGION'\n                END\n                WHEN BITAND(X2B(i_ss),X2B('04'))='00000100' THEN DO\n                   ss2 = '/ CTL REGION RESTART MODE'\n                END\n                WHEN BITAND(X2B(i_ss),X2B('02'))='00000010' THEN DO\n                   ss2 = '/ CTL REG INIT - AWAITING CMD'\n                END\n                WHEN BITAND(X2B(i_ss),X2B('01'))='00000001' THEN DO\n                   ss2 = '/ CTL REGION INITIALIZATION MODE'\n                END\n                OTHERWISE ss2 = ''\n               END\n               SELECT\n                WHEN BITAND(X2B(i_f1),X2B('0F'))='00000011' THEN DO\n                   if1 = 'BATCH SYSTEM (DB) '\n                END\n                WHEN BITAND(X2B(i_f1),X2B('0F'))='00000000' THEN DO\n                   if1 = 'ONLINE SYSTEM (DB/DC) '\n                END\n                OTHERWISE if1 = ''\n               END\n               SELECT\n                WHEN BITAND(X2B(i_f1),X2B('F0'))='10000000' THEN DO\n                   if1 = if1'DBRC REGION'\n                END\n                WHEN BITAND(X2B(i_f1),X2B('F0'))='01000000' THEN DO\n                   if1 = if1'DL/I REGION'\n                END\n                OTHERWISE if1 = if1''\n               END\n               if4 = ''\n               IF BITAND(X2B(i_f4),X2B('80'))='10000000' THEN DO\n                   if4 = if4'IRLM PRESENT '\n               END\n               IF BITAND(X2B(i_f4),X2B('40'))='01000000' THEN DO\n                   if4 = if4'DBRC PRESENT FOR BATCH DEFAULT '\n               END\n               IF BITAND(X2B(i_f4),X2B('20'))='00100000' THEN DO\n                   if4 = if4'IMS/FPE INSTALLED '\n               END\n               IF BITAND(X2B(i_f4),X2B('10'))='00010000' THEN DO\n                   if4 = if4'NO DBRC OVER RIDE ALLOWED '\n               END\n               IF BITAND(X2B(i_f4),X2B('08'))='00001000' THEN DO\n                   if4 = if4'LOCAL STORAGE OPTION SELECTED '\n               END\n               IF BITAND(X2B(i_f4),X2B('04'))='00000100' THEN DO\n                   if4 = if4'CROSS MEMORY LSO SELECTED '\n               END\n               IF BITAND(X2B(i_f4),X2B('02'))='00000010' THEN DO\n                   if4 = if4'DL/I SAS SELECTED '\n               END\n               IF BITAND(X2B(i_f4),X2B('01'))='00000001' THEN DO\n                   if4 = if4'IMS CRC REGISTRATION SUCCESS '\n               END\n               d1 =' IMSID: '||IMSID||' Ver: 'imsver||' CMDRecChar: '||crc\n               say d1\n               if if1 <> '' then do\n                  d1 = ' 'if1\n                  say d1\n               end\n               if if4 <> '' then do\n                  d1 = ' 'if4\n                  say d1\n               end\n               if ss1||ss2 <> '' then do\n                  d1 = ' 'ss1||ss2\n                  say d1\n               end\n               d1 = ' '\n               say d1\n            END\n         end\n      end\n     END\n    END\n   END\n   /*---------------------------------------------------------------*/\n   /* get address of next SSCT control block in the chain.          */\n   /* if the address is not zeroes, then there is another SSCT.     */\n   /*---------------------------------------------------------------*/\n   SSCTADDR = Get_Stor(SSCTADDR,'4'x)          /* Next one in chain */\nEND\nexit\n/* ================================================================= */\nGet_Stor: PROCEDURE\n/*------------------------------------------------------------------*/\n/* This procedure will extract data using the MVS Storage           */\n/* REXX function. Input arguments will be:                          */\n/* 1) Storage_Pointer or Literal, ie CVTPTR or '10'x, or 16 (like   */\n/*    '10'x)                                                        */\n/* 2) Offset in hex or dec (number), ie 'FF'x or 256 or D2C(256)    */\n/* 3) Length of returned data in decimal, ie 256                    */\n/* NOTE \u00fb ensure that a 'NUMERIC DIGITS 256' is at                  */\n/* the beginning of the calling REXX program.                       */\n/*------------------------------------------------------------------*/\nParse Arg AREA,OFFSET,LENG\nIf Arg(2,'O') Then OFFSET=0\nIf Arg(3,'O') Then LENG=4\nIf DataType(AREA) = 'CHAR' Then AREA = C2D(AREA)\nIf DataType(OFFSET) = 'CHAR' Then OFFSET = C2D(OFFSET)\nReturn Storage((D2X(AREA+OFFSET)),LENG)\n/* ================================================================= */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IS": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x17\\x08\\x0f\\x01\\x17\\x08\\x0f\\x00$\\x00\\n\\x00\\n\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-03-21T00:00:00", "modifydate": "2017-03-21T00:24:22", "lines": 10, "newlines": 10, "modlines": 0, "user": "RNOWAK"}, "text": "PROC 3 PARM1 OPERATOR PARM2\nIF &PARM1 &OPERATOR &PARM2 THEN DO\n   SET RETCODE = 0\n   WRITE &PARM1 &OPERATOR &PARM2\nEND\nELSE DO\n   SET RETCODE = 4\n   WRITE &PARM1 &OPERATOR &PARM2  IS NOT TRUE\nEND\nEXIT CODE(&RETCODE)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MQSUBS": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x17\\x08\\x0f\\x01  O\\x176\\x00U\\x00U\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-03-21T00:00:00", "modifydate": "2020-07-22T17:36:02", "lines": 85, "newlines": 85, "modlines": 0, "user": "RNOWAK"}, "text": "/* REXX *************************************************************/\n/********************************************************************/\n/* REXX to list active MQ subsystems on the LPAR.                   */\n/* written by R. Nowak in 2015                                      */\n/* This REXX based on an article from                               */\n/* Antonio Luis Salcedo Freidel                                     */\n/* Xephon - DB2 update #124 February 2003                           */\n/* page 22ff: ISPF dialog to obtain a list of DB2 subsystems        */\n/* The ERLY control block is not documented, so use is of own       */\n/* risk.                                                            */\n/********************************************************************/\n/********************************************************************/\n/* Build a list of active MQ subsystems.                            */\n/********************************************************************/\nNumeric Digits 256                  /* this must be at top of REXX. */\nCVTADDR = Get_Stor('10'x)      /* get communications vector address */\nSYSID = Strip(Get_Stor(CVTADDR,'154'x,8)) /* get MVS system id.     */\nd1 = 'Active MQ Systems on 'SYSID' :'\nsay d1\n/*------------------------------------------------------------------*/\n/* Traverse the list of subsystems known to JES.                    */\n/* JESCT = CVT+x'128' = Pointer to the JESCT                        */\n/* JESCT points to first SSCT which chains to next SSCT             */\n/*------------------------------------------------------------------*/\nJCTADDR = Get_Stor(CVTADDR,'128'x)   /* JES job control table block */\nSSCTADDR = Get_Stor(JCTADDR,24)      /* Address of first SSCT block */\nDO WHILE C2D(SSCTADDR) <> 0\n   /*---------------------------------------------------------------*/\n   /* get information from the SSCT control block.                  */\n   /*---------------------------------------------------------------*/\n   SUBSYS = Get_Stor(SSCTADDR,'8'x)      /* get the Subsystem name. */\n   ERLYADDR= Get_Stor(SSCTADDR,20)       /* get ERLY block address. */\n   /*---------------------------------------------------------------*/\n   /* get information from the ERLY control block.                  */\n   /*---------------------------------------------------------------*/\n   ERLYEYEC= Get_Stor(ERLYADDR,4)   /* get literal ERLY eye catcher */\n   ERLYMODN= Get_Stor(ERLYADDR,84,8) /*get name of module associated*/\n   STCNAME= Get_Stor(ERLYADDR,12,8)  /*get name of master proc      */\n   CMDPREF= Get_Stor(ERLYADDR,102,8) /*get name of command prefix ??*/\n   CSQ3SSI1= Get_Stor(ERLYADDR,28)       /* get CSQ3SSI1   address. */\n                                    /* SCSQAUTH(CSQ3SSGP) offset 28 */\n   /*---------------------------------------------------------------*/\n   /* verify that it is an ERLY block and it is for MQ.             */\n   /*---------------------------------------------------------------*/\n   if ERLYEYEC = 'ERLY' & ERLYMODN = 'CSQ3EPX ' THEN DO\n      /*------------------------------------------------------------*/\n      /* If the CSQ3SSI1 address is zeroes, then MQ  is not active. */\n      /*------------------------------------------------------------*/\n      if (C2D(CSQ3SSI1) = 0) then do\n         NOP\n      end\n      else do\n         d1 = ' SubSysID: '||SUBSYS||'  MasterProc: '||STCNAME\n         d1 = d1||'  CMD-Prefix: '||STRIP(CMDPREF,'T','00'x)\n         say d1\n         d1 = ' '\n         say d1\n      end\n   end\n   /*---------------------------------------------------------------*/\n   /* get address of next SSCT control block in the chain.          */\n   /* if the address is not zeroes, then there is another SSCT.     */\n   /*---------------------------------------------------------------*/\n   SSCTADDR = Get_Stor(SSCTADDR,'4'x)          /* Next one in chain */\nEND\nexit\n/* ================================================================ */\nGet_Stor: PROCEDURE\n/*------------------------------------------------------------------*/\n/* This procedure will extract data using the MVS Storage           */\n/* REXX function. Input arguments will be:                          */\n/* 1) Storage_Pointer or Literal, ie CVTPTR or '10'x, or 16 (like   */\n/*    '10'x)                                                        */\n/* 2) Offset in hex or dec (number), ie 'FF'x or 256 or D2C(256)    */\n/* 3) Length of returned data in decimal, ie 256                    */\n/* NOTE : ensure that a 'NUMERIC DIGITS 256' is at                  */\n/* the beginning of the calling REXX program.                       */\n/*------------------------------------------------------------------*/\nParse Arg AREA,OFFSET,LENG\nIf Arg(2,'O') Then OFFSET=0\nIf Arg(3,'O') Then LENG=4\nIf DataType(AREA) = 'CHAR' Then AREA = C2D(AREA)\nIf DataType(OFFSET) = 'CHAR' Then OFFSET = C2D(OFFSET)\nReturn Storage((D2X(AREA+OFFSET)),LENG)\n/* ================================================================ */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OLDS": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x17\\x15?\\x01\\x17\\x15?\\x17\\x05\\x00\\xc7\\x00\\xc7\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-06-02T00:00:00", "modifydate": "2017-06-02T17:05:28", "lines": 199, "newlines": 199, "modlines": 0, "user": "RNOWAK"}, "text": "/* REXX **************************************************************/\n/* OLDS                                                              */\n/* List LogSequenceNumber errors in IMS OLDS.                        */\n/*                                                                   */\n/* Rainer Nowak                                                      */\n/*                                                                   */\n/* For length of date/time and LSN have a look at:                   */\n/* IMS.SDFSMAC(DFSLOGRC)                                             */\n/* logrc_suffix          DSECT                                       */\n/*********************************************************************/\nARG dsn\ndsn= STRIP(dsn,'B',\"'\")\nIF dsn = '' | dsn = 'DSN' THEN DO\n   SAY 'You have to name the dataset:'\n   pull dsn\n   dsn = strip(dsn)\n   dsn= STRIP(dsn,'B',\"'\")\nEND\nNUMERIC DIGITS 20                            /* allow up to 2**64    */\nleap_seconds = 0\n\"ALLOC DD(FROG) UNIT(VIO) DSORG(PS) LRECL(80) BLKSIZE(644)\",\n           \"SPACE(10,1) TRACKS  RECFM(V,B) NEW\"\n\"ALLOC DD(IN) DA('\"dsn\"') SHR\"\nSAY 'SLOW REXX WORKING'\nt1= COPIES('=',72)\neof = 'no'\nerr = 0\ni = 0\n\"NEWSTACK\"\nDO while eof ='no'\n   \"EXECIO 1 DISKR IN\"\n   if rc = 2 then do\n      eof ='yes'\n      \"EXECIO 0 DISKR  IN (FINIS\"\n   end\n   else do\n      PARSE       PULL pgmz\n      i = i + 1\n      if i = 1 then do\n         lsnc = RIGHT(pgmz,8)\n         lsnx = C2X(lsnc)\n         lsnd = X2D(lsnx)\n         oldlsn = lsnx\n         expected = lsnd + 1\n         expectedx = D2X(expected,16)\n         d1= 'First record'\n         dummy2 = Sachma('FROG',d1)\n         tl = RIGHT(pgmz,16)\n         ti = LEFT(tl,8)\n         dt = STCKE(ti)\n         d1= 'Date/Time (GMT): 'dt'   LSN: 'lsnx\n         dummy2 = Sachma('FROG',d1)\n      end\n      else do\n         lsnc = RIGHT(pgmz,8)\n         lsnx = C2X(lsnc)\n         lsnd = X2D(lsnx)\n         if lsnd <> expected then do\n            err = err + 1\n            dummy2 = Sachma('FROG',t1)\n            d1= 'Record with LSN error'\n            dummy2 = Sachma('FROG',d1)\n            d1= 'Record number:    'i\n            dummy2 = Sachma('FROG',d1)\n            tl = RIGHT(pgmz,16)\n            ti = LEFT(tl,8)\n            dt = STCKE(ti)\n            d1= 'Date/Time (GMT): 'dt\n            dummy2 = Sachma('FROG',d1)\n            d1= 'prev. LSN: 'oldlsn\n            dummy2 = Sachma('FROG',d1)\n            d1= 'act. LSN : 'lsnx\n            dummy2 = Sachma('FROG',d1)\n            d1= 'expected : 'expectedx\n            dummy2 = Sachma('FROG',d1)\n            dummy2 = Sachhex('FROG',pgmz)\n            SAY 'ERROR: 'err' in record 'i\n            if err >= 5 then do\n               eof = 'yes'\n               d1= 'Abend after 5 errors|'\n               dummy2 = Sachma('FROG',d1)\n            end\n         end\n         oldlsn = lsnx\n         expected = expected + 1\n         expectedx = D2X(expected,16)\n      end\n   END\nEND\ndummy2 = Sachma('FROG',t1)\nd1= 'Last record'\ndummy2 = Sachma('FROG',d1)\ntl = RIGHT(pgmz,16)\nti = LEFT(tl,8)\ndt = STCKE(ti)\nd1= 'Date/Time (GMT): 'dt'   LSN: 'lsnx\ndummy2 = Sachma('FROG',d1)\nif err = 0 then a = 'No ' ; else a = err||' '\nd1= a||'errors in 'i' records'\ndummy2 = Sachma('FROG',d1)\n\"DELSTACK\"\n\"FREE FILE(IN)\"\n\"EXECIO 0 DISKW FROG (FINIS\"\n\"ISPEXEC  LMINIT DATAID(ID) DDNAME(FROG)\"\n\"ISPEXEC  EDIT DATAID(\"ID\")\"\n\"FREE DD(FROG)\"\nexit\n\n/*-------------------------------------------------------------------*/\n/* *********** Subroutines ***************************************** */\n/*-------------------------------------------------------------------*/\n/*-------------------------------------------------------------------*/\n/* Sachma - Output in dataset                                        */\n/*-------------------------------------------------------------------*/\nSachma: PROCEDURE\nparse arg dd,text\niorec = 0\ntr = text\ndo while LENGTH(tr) > 72\n   ta = LEFT(tr,72)\n   tr = SUBSTR(tr,73)\n   push ta\n   Address TSO \"EXECIO 1 DISKW\" DD \"(\"\n   iorec = max(rc,iorec)\nend\npush tr\nAddress TSO \"EXECIO 1 DISKW\" DD \"(\"\niorec = max(rc,iorec)\nRETURN iorec\n/*-------------------------------------------------------------------*/\n/* Sachhex - Hex output in dataset                                   */\n/*-------------------------------------------------------------------*/\nSachhex: PROCEDURE\nparse arg dd,txt\niorec = 0\ntr = txt\ndo while LENGTH(tr) > 72\n   ta = LEFT(tr,72)\n   tr = SUBSTR(tr,73)\n   d1='' ; d2='' ; d3='' ; lentxt = LENGTH(ta)\n   tz= COPIES('-',LENGTH(ta))\n   DO j = 1 to lentxt\n      tchar= SUBSTR(ta,j,1)\n      xtchar = c2x(tchar)\n      d1= d1||tchar\n      d2= d2||LEFT(xtchar,1)\n      d3= d3||RIGHT(xtchar,1)\n   END\n   push tz\n   push d3\n   push d2\n   push d1\n   Address TSO \"EXECIO 4 DISKW\" dd \"(\"\n   iorec = max(rc,iorec)\nend\nd1='' ; d2='' ; d3='' ; lentxt = LENGTH(tr)\ntz= COPIES('-',LENGTH(tr))\nDO j = 1 to lentxt\n   tchar= SUBSTR(tr,j,1)\n   xtchar = c2x(tchar)\n   d1= d1||tchar\n   d2= d2||LEFT(xtchar,1)\n   d3= d3||RIGHT(xtchar,1)\nEND\npush tz\npush d3\npush d2\npush d1\nAddress TSO \"EXECIO 4 DISKW\" dd \"(\"\niorec = max(rc,iorec)\nRETURN iorec\nSTCKE: PROCEDURE EXPOSE leap_seconds\n/* Convert date and time from STCK format.                          */\n/* Bit position 51 of the clock is incremented every millisecond    */\nPARSE ARG s_time\nS=c2x(s_time)\nS = X2D(LEFT(S,13))\nsek = s % 1000000\nmsek = s // 1000000\nerg = S2DTE(sek)'.'msek\nRETURN erg\n\nS2DTE:\nPROCEDURE EXPOSE leap_seconds\n  /* Function                                                  */\n  /* Convert whole number of seconds until 1.1.1900 to date    */\n  /* and time. STCK time                                       */\nARG ss\nss = TRUNC(ss) - leap_seconds\nminu = ss%60\nsek = RIGHT(ss//60,2,'0')\nstdu = minu%60\ntagu = stdu%24\nstd = RIGHT(stdu//24,2,'0')\nminu = RIGHT(minu//60,2,'0')\ntag = RIGHT(DATE('N',tagu+DATE('B','19000101','S'),'B'),11,'0')\nerg = tag\" \"STD\":\"MINU\":\"SEK\nRETURN erg\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMEDID": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x161/\\x01\\x161/\\x170\\x00\\xc2\\x00\\xc2\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2016-11-07T17:30:41", "lines": 194, "newlines": 194, "modlines": 0, "user": "SYSLBD"}, "text": "STEMEDIT.DOC\n\nMany times when writing an ISPF dialog in REXX there is a need to\npresent data to the user. The lazy way is to use the say command,\nor write code to write the data to a dataset and then invoke an\nISPF service to Browse, Edit, or View it.  If the data is only\ntemporary then a better option would be to use the data that\nresides in a REXX STEM and that is what STEMEDIT is designed to do.\n\n=====================================================================\n\n\nSTEMEDIT ISPF REXX Command\n\nThe STEMEDIT routine can be invoked by a REXX EXEC to display the\ncontents of stem variables using the ISPF BRIF, VIIF or EDIT\nservices.  STEMEDIT is a nice complement to the REXX OUTTRAP\nfunction, when it is used in the ISPF/PDF environment.\n\nSTEMEDIT can also PULL lines from the data stack instead of using\nstem variables.  This only works with EDIT or VIEW, i.e. not with\nBROWSE.\n\nThe author is Gilbert Saint-Flour and the code is available on the\nCBT TAPE (www.cbttape.org) as a great example of the z/OS Open Source\ncommunity.  (File 183)\n\nThe syntax is:\n\n   CALL STEMEDIT  service,\n                  stemname\n                  <,firstelem>\n                  <,stemcount>\n                  <,title>\n                  <,panel>\n                  <,lrecl>\n                  <,recfm>\n                  <,profile>\n                  <,varl>\n\nParameters:\n\n  SERVICE\n\n  This argument must be coded as 'BROWSE', 'VIEW' or 'EDIT'.  It\n  indicates which of the BRIF, VIIF or EDIF services will be used\n  for display.\n\n  If the BROWSE service is requested, the user can enter the V\n  commands on the BROWSE screen to switch to VIEW.  This allows the\n  data to be saved using CREATE/REPLACE, CUT or ROUTE.\n\n  STEMNAME\n\n  The stem of the family of variables to display.  The combined\n  lengths of the stemname argument and the largest subscript (plus\n  the period, if specified) cannot exceed 80 characters.  If\n  stemname is a true REXX stem, code a period as the last character.\n  If you do not specify the period, the subscripts will be\n  concatenated to the stem name without an intervening period.  For\n  example, if you specify a stemname of \"ABC.\", STEMEDIT will look\n  for variables of the form \"ABC.1\", \"ABC.2\", etc. If you specify a\n  stemname of \"XYZ\" (no period), STEMEDIT will look for variables of\n  the form \"XYZ1\", \"XYZ2\", etc.\n\n  If the service is coded as \"VIEW\" or \"EDIT\" and stemname is\n  omitted, STEMEDIT PULLs lines from the stack.\n\n  If the service is coded as \"VIEW\" or \"EDIT\" the stemname can be\n  coded as \"*\", which will display all variables in the REXX\n  variable pool.  Variable names will be shown with 39 characters,\n  except you code varl as \"L\", showing variable names with 255\n  characters. If variable name is longer, it will be abbreviated to\n  38 or 254 characters and suffixed with \"*\". Last variable is\n  always the contents of VARNAME from this program.  If the service\n  is coded as \"EDIT\" and stemname is coded as \"*\", variables can be\n  edited. It must be coded with variable name beginning in column 1,\n  some blanks end with \"=\" and immediately followed by the value,\n  which must be ended with \"00\"x. You can also drop a variable or a\n  stem by coding \"DROP variablename\" at the beginning of the line\n  and end it with \"00\"x.  Variable name can have a length up to 250.\n\n  FIRSTELEM\n\n  The element of the pseudo-array to begin the display on.  The\n  default value is element 1.\n\n  STEMCOUNT\n\n  The number of elements to display.  If you do not specify\n  stemcount, STEMEDIT will display variables beginning with\n  firstelem, and continuing until an un-initialized variable is\n  found (i.e., a variable which has its name for a value).\n\n  TITLE\n\n  An arbitrary character string which identifies the data which is\n  being displayed.  The maximum length of this string is 54\n  characters.\n\n  PANEL\n\n  A 1 to 8 character name of the panel member to use for the\n  display.  The default panel is ISRBROBA for BROWSE and ISREDDE2\n  for VIEW and EDIT.\n\n  LRECL\n\n  The record length that should be passed to the BRIF, VIIF or EDIF\n  services.  The default value is 255.\n\n  RECFM\n\n  The record format that should be passed to the BRIF, VIIF or EDIF\n  services.  Possible values are F, FA, FM, V, VA, VM, or U.  The\n  default value is V.\n\n  PROFILE\n\n  The 8-char name of the profile that should be used by VIIF and\n  EDIF when the VIEW or EDIT services are requested.  The default\n  value is TEXT.\n\n  VARL\n\n  Form of the variable list, if varname is *.  Can be S for short\n  (=39 char) or L for long (=255 char) varnames.\n\nEXAMPLES\n\n    Call the STEMEDIT routine to display the output of the\n    TSO \"LISTCAT\" command.  The variables to display\n    begin with the characters \"LINE.\":\n\n       CALL OUTTRAP 'LINE.'\n       \"LISTCAT\"\n       CALL STEMEDIT 'BROWSE','LINE.',,,'List Catalog'\n\n    QUEUE JCL to the data stack and call the STEMEDIT\n    routine to VIEW it:\n\n       \"MAKEBUF\"\n       QUEUE '//MYJOB JOB 12345,CLASS=A'\n       QUEUE '//STEP2 EXEC PGM=IEFBR14'\n       CALL STEMEDIT 'VIEW',,,,'Sample JCL'\n       \"DROPBUF\"\n\nRETURN CODES\n\n    The STEMEDIT function returns a return code that indicates\n    whether the display worked.  The returned value is\n    contained in the RC special variable.\n\n    The following STEMEDIT return code values are possible:\n\n    0    The display was successful.\n\n    4    There were no stems matching the description given in\n         stemname (BROWSE).  The data was not modified (EDIT).\n\n    8    Option incompatible with requested service.\n\n    12   Invalid Service requested.\n\n    16   BRIF, VIIF or EDIF failed.\n\nUSAGE NOTES\n\n    The EDIT service only works with a stem variable.  If the\n    data is modified by the user, STEMEDIT DROPs the stem\n    variable, sets stem.0 to the number of records written,\n    copies records to the stem.1 through stem.n where n is\n    equal to the value of the stem.0 variable, and sets the\n    RC variable to 0.  If the data is not modified by the\n    user, STEMEDIT sets the RC variable to 4.\n\nCOMPATIBILITY\n\n    STEMEDIT has been designed to be compatible with\n    the STEMDISP function of the REXXTOOLS product from\n    Open Software Technologies, with the following\n    exceptions:\n\n    1. STEMEDIT supports the BROWSE, VIEW and EDIT services\n       (STEMDISP only supports BROWSE).\n\n    2. If stemcount is not specified, STEMEDIT scans\n       variables until an uninitialized variable is found.\n       (STEMDISP stops after 100000 variables).\n\n    3. STEMEDIT has the ability to retrieve data from a\n       stem variable or the data stack (STEMDISP can only\n       retrieve data from a stem variable).\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMEDIH": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x16%\\x9f\\x01\\x16%\\x9f\\x06X\\x00\\xbe\\x00\\xb9\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2016-09-15T00:00:00", "modifydate": "2016-09-15T06:58:00", "lines": 190, "newlines": 185, "modlines": 0, "user": "SYSLBD"}, "text": ")F Function\n\n This assembler sub-routine can be invoked by a REXX EXEC to\n display the contents of stem variables using the ISPF BRIF,\n VIIF or EDIT services.  STEMEDIT is a nice complement to\n the REXX OUTTRAP function, when it is used in the ISPF/PDF\n environment.\n\n STEMEDIT can also PULL lines from the data stack instead of\n using stem variables.  This only works with EDIT or VIEW,\n i.e. not with BROWSE.\n\n STEMEDIT can be used to view or edit all variables.\n Together with \"TRACE ?R\" STEMEDIT can be used for debugging\n your REXX programs.\n\n AUTHOR = Gilbert Saint-Flour <carlos\u00bagsf-soft.com>\n          http://gsf-soft.com/Freeware/\n\n)X Syntax\n   CALL STEMEDIT  service,\n                  stemname\n                  <,firstelem>\n                  <,stemcount>\n                  <,title>\n                  <,panel>\n                  <,lrecl>\n                  <,recfm>\n                  <,profile>\n                  <,varl>\n\n)O Arguments\n\n))SERVICE\n\n  This argument must be coded as 'BROWSE', 'VIEW' or 'EDIT'.\n  It indicates which of the BRIF, VIIF or EDIF services will\n  be used for display.\n\n  If the BROWSE service is requested, the user can enter the\n  V commands on the BROWSE screen to switch to VIEW.  This\n  allows the data to be saved using CREATE/REPLACE, CUT or\n  ROUTE.\n\n))STEMNAME\n\n  The stem of the family of variables to display.  The\n  combined lengths of the stemname argument and the largest\n  subscript (plus the period, if specified) cannot exceed 80\n  characters.  If stemname is a true REXX stem, code a\n  period as the last character.  If you do not specify the\n  period, the subscripts will be concatenated to the stem\n  name without an intervening period.  For example, if you\n  specify a stemname of \"ABC.\", STEMEDIT will look for\n  variables of the form \"ABC.1\", \"ABC.2\", etc. If you\n  specify a stemname of \"XYZ\" (no period), STEMEDIT will\n  look for variables of the form \"XYZ1\", \"XYZ2\", etc.\n\n  If the service is coded as \"VIEW\" or \"EDIT\" and stemname\n  is omitted, STEMEDIT PULLs lines from the stack.\n\n  If the service is coded as \"VIEW\" or \"EDIT\" the stemname\n  can be coded as \"*\", which will display all variables in\n  the REXX variable pool. Variable names will be shown with\n  39 characters, except you code varl as \"L\", showing\n  variable names with 255 characters. If variable name is\n  longer, it will be abbreviated to 38 or 254 characters and\n  suffixed with \"*\". Last variable is always the contents of\n  VARNAME from this program.  If the service is coded as\n  \"EDIT\" and stemname is coded as \"*\", variables can be\n  edited. It must be coded with variable name beginning in\n  column 1, some blanks end with \"=\" and immediately\n  followed by the value, which must be ended with \"00\"x. You\n  can also drop a variable or a stem by coding \"DROP\n  variablename\" at the beginning of the line and end it with\n  \"00\"x.  Variable name can have a length up to 250.\n\n))FIRSTELEM\n\n  The element of the pseudo-array to begin the display on.\n  The default value is element 1.\n\n))STEMCOUNT\n\n  The number of elements to display.  If you do not specify\n  stemcount, STEMEDIT will display variables beginning with\n  firstelem, and continuing until an un-initialized variable\n  is found (i.e., a variable which has its name for a\n  value).\n\n))TITLE\n\n  An arbitrary character string which identifies the data\n  which is being displayed.  The maximum length of this\n  string is 54 characters.\n\n))PANEL\n\n  A 1 to 8 character name of the panel member to use for the\n  display.  The default panel is ISRBROBA for BROWSE and\n  ISREDDE2 for VIEW and EDIT.\n\n))LRECL\n\n  The record length that should be passed to the BRIF, VIIF\n  or EDIF services.  The default value is 255.\n\n))RECFM\n\n  The record format that should be passed to the BRIF, VIIF\n  or EDIF services.  Possible values are F, FA, FM, V, VA,\n  VM, or U.  The default value is V.\n\n))PROFILE\n\n  The 8-char name of the profile that should be used by VIIF\n  and EDIF when the VIEW or EDIT services are requested.\n  The default value is TEXT.\n\n))VARL\n\n  Form of the variable list, if varname is *.  Can be S for\n  short (=39 char) or L for long (=255 char) varnames.\n\n)Examples\n\n    Call the STEMEDIT routine to display the output of the\n    TSO \"LISTCAT\" command.  The variables to display\n    begin with the characters \"LINE.\":\n\n       CALL OUTTRAP 'LINE.'\n       \"LISTCAT\"\n       CALL STEMEDIT 'BROWSE','LINE.',,,'List Catalog'\n\n    QUEUE JCL to the data stack and call the STEMEDIT\n    routine to VIEW it:\n\n       \"MAKEBUF\"\n       QUEUE '//MYJOB JOB 12345,CLASS=A'\n       QUEUE '//STEP2 EXEC PGM=IEFBR14'\n       CALL STEMEDIT 'VIEW',,,,'Sample JCL'\n       \"DROPBUF\"\n\n)Return Codes\n\n    The STEMEDIT function returns a return code that indicates\n    whether the display worked.  The returned value is\n    contained in the RC special variable.\n\n    The following STEMEDIT return code values are possible:\n\n    0    The display was successful.\n\n    4    There were no stems matching the description given in\n         stemname (BROWSE).  The data was not modified (EDIT).\n\n    8    Option incompatible with requested service.\n\n    12   Invalid Service requested.\n\n    16   BRIF, VIIF or EDIF failed.\n\n)Usage Notes\n\n    The EDIT service only works with a stem variable.  If the\n    data is modified by the user, STEMEDIT DROPs the stem\n    variable, sets stem.0 to the number of records written,\n    copies records to the stem.1 through stem.n where n is\n    equal to the value of the stem.0 variable, and sets the\n    RC variable to 0.  If the data is not modified by the\n    user, STEMEDIT sets the RC variable to 4.\n\n)Compatibility\n\n    STEMEDIT has been designed to be compatible with\n    the STEMDISP function of the REXXTOOLS product from\n    Open Software Technologies, with the following\n    exceptions:\n\n    1. STEMEDIT supports the BROWSE, VIEW and EDIT services\n       (STEMDISP only supports BROWSE).\n\n    2. If stemcount is not specified, STEMEDIT scans\n       variables until an uninitialized variable is found.\n       (STEMDISP stops after 100000 variables).\n\n    3. STEMEDIT has the ability to retrieve data from a\n       stem variable or the data stack (STEMDISP can only\n       retrieve data from a stem variable).\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMEDIT": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x18\\x01\\x17\\x08\\x0f\\x01\\x17\\x12\\x7f\"C\\x04\\xeb\\x04\\xdc\\x00\\x12\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-03-21T00:00:00", "modifydate": "2017-05-07T22:43:18", "lines": 1259, "newlines": 1244, "modlines": 18, "user": "RNOWAK"}, "text": "//GILBERTV JOB (ACCT#),STEMEDIT,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = STEMEDIT                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Display REXX Stem Variables using BRIF or VIIF.  *\n*                                                                     *\n* STATUS = R209                                                       *\n*                                                                     *\n* FUNCTION = This assembler sub-routine can be invoked by a REXX      *\n*            EXEC to display the contents of stem variables using     *\n*            the ISPF BRIF, VIIF or EDIT services.  STEMEDIT is       *\n*            a nice complement to the REXX OUTTRAP function,          *\n*            when it is used in the ISPF/PDF environment.             *\n*                                                                     *\n*            STEMEDIT can also PULL lines from the data stack         *\n*            instead of using stem variables.  This only works        *\n*            with EDIT or VIEW, i.e. not with BROWSE.                 *\n*                                                                     *\n* R208       STEMEDIT can be used to view or edit all variables.      *\n* R208       Together with \"TRACE ?R\" STEMEDIT can be used for        *\n* R208       debugging your REXX programs.                            *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos\u00bagsf-soft.com>                  *\n*          http://gsf-soft.com/Freeware/                              *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: OS/390 R10 or z/OS                                 *\n*                  ISPF/PDF V3 (or above)                             *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* SYNTAX  =  See below                                                *\n*                                                                     *\n*    CALL STEMEDIT  service,                                          *\n*                   stemname                                          *\n*                   <,firstelem>                                      *\n*                   <,stemcount>                                      *\n*                   <,title>                                          *\n*                   <,panel>                                          *\n*                   <,lrecl>                                          *\n*                   <,recfm>                                          *\n*                   <,profile>                                        *\n* R208              <,varl>                                           *\n*                                                                     *\n*    Arguments:                                                       *\n*                                                                     *\n*         service   This argument must be coded as 'BROWSE', 'VIEW'   *\n*                   or 'EDIT'.  It indicates which of the BRIF,       *\n*                   VIIF or EDIF services will be used for display.   *\n*                                                                     *\n*                   If the BROWSE service is requested, the user can  *\n*                   enter the V commands on the BROWSE screen to      *\n*                   switch to VIEW.  This allows the data to be       *\n*                   saved using CREATE/REPLACE, CUT or ROUTE.         *\n*                                                                     *\n*         stemname  the stem of the family of variables to display.   *\n*                   The combined lengths of the stemname argument     *\n*                   and the largest subscript (plus the period, if    *\n*                   specified) cannot exceed 80 characters.           *\n*                   If stemname is a true REXX stem, code a period    *\n*                   as the last character.  If you do not specify     *\n*                   the period, the subscripts will be concatenated   *\n*                   to the stem name without an intervening period.   *\n*                   For example, if you specify a stemname of \"ABC.\", *\n*                   STEMEDIT will look for variables of the form      *\n*                   \"ABC.1\", \"ABC.2\", etc. If you specify a stemname  *\n*                   of \"XYZ\" (no period), STEMEDIT will look for      *\n*                   variables of the form \"XYZ1\", \"XYZ2\", etc.        *\n*                                                                     *\n*                   If the service is coded as \"VIEW\" or \"EDIT\" and   *\n*                   stemname is omitted, STEMEDIT PULLs lines from    *\n*                   the stack.                                        *\n* R208              If the service is coded as \"VIEW\" or \"EDIT\"       *\n* R208              stemname can be coded as \"*\", which will display  *\n* R208              all variables in the REXX variable pool. Variable *\n* R208              names will be shown with 39 characters, except you*\n* R208              code varl as \"L\", showing variable names with 255 *\n* R208              characters. If variable name is longer, it will   *\n* R208              be abbreviated to 38 or 254 characters and        *\n* R208              suffixed with \"*\". Last variable is always the    *\n* R208              contents of VARNAME from this program.            *\n* R208              If the service is coded as \"EDIT\" and stemname    *\n* R208              is coded as \"*\", variables can be edited. It must *\n* R208              be coded with variable name beginning in colume   *\n* R208              1, some blanks endet with \"=\" and immediately     *\n* R208              followed by the value, which must be ended with   *\n* R208              \"00\"x. You can also drop a variable or a stem     *\n* R208              by coding \"DROP variablename\" at the beginning    *\n* R208              of the line and end it with \"00\"x.                *\n* R208              Variable name can have a length up to 250.        *\n*                                                                     *\n*         firstelem the element of the pseudo-array to begin the      *\n*                   display on.  The default value is element 1.      *\n*                                                                     *\n*         stemcount the number of elements to display.                *\n*                   If you do not specify stemcount, STEMEDIT will    *\n*                   display variables beginning with firstelem, and   *\n*                   continuing until an un-initialized variable is    *\n*                   found (i.e., a variable which has its name for    *\n*                   a value).                                         *\n*                                                                     *\n*         title     an arbitrary character string which identifies    *\n*                   the data which is being displayed.  The maximum   *\n*                   length of this string is 54 characters.           *\n*                                                                     *\n*         panel     a 1 to 8 character name of the panel member       *\n*                   to use for the display.                           *\n*                   The default panel is ISRBROBA for BROWSE          *\n*                   and ISREDDE2 for VIEW and EDIT.                   *\n*                                                                     *\n*         lrecl     the record length that should be passed to        *\n*                   the BRIF, VIIF or EDIF services.                  *\n*                   The default value is 255.                         *\n*                                                                     *\n*         recfm     the record format that should be passed to        *\n*                   the BRIF, VIIF or EDIF services.                  *\n*                   Possible values are F, FA, FM, V, VA, VM, or U.   *\n*                   The default value is V.                           *\n*                                                                     *\n*         profile   the 8-char name of the profile that should be     *\n*                   used by VIIF and EDIF when the VIEW or EDIT       *\n*                   services are requested.                           *\n*                   The default value is TEXT.                        *\n*                                                                     *\n* R208    varl      form of the variable list, if varname is *.       *\n* R208              Can be S for short (=39 char) or L for long       *\n* R208              (=255 char) varnames.                             *\n*                                                                     *\n*    Examples:                                                        *\n*                                                                     *\n*         Call the STEMEDIT routine to display the output of the      *\n*         TSO \"LISTCAT\" command.  The variables to display            *\n*         begin with the characters \"LINE.\":                          *\n*                                                                     *\n*            CALL OUTTRAP 'LINE.'                                     *\n*            \"LISTCAT\"                                                *\n*            CALL STEMEDIT 'BROWSE','LINE.',,,'List Catalog'          *\n*                                                                     *\n*         QUEUE JCL to the data stack and call the STEMEDIT           *\n*         routine to VIEW it:                                         *\n*                                                                     *\n*            \"MAKEBUF\"                                                *\n*            QUEUE '//MYJOB JOB 12345,CLASS=A'                        *\n*            QUEUE '//STEP2 EXEC PGM=IEFBR14'                         *\n*            CALL STEMEDIT 'VIEW',,,,'Sample JCL'                     *\n*            \"DROPBUF\"                                                *\n*                                                                     *\n* RETURN-CODES = See below                                            *\n*                                                                     *\n*        The STEMEDIT function returns a return code that indicates   *\n*        whether the display worked.  The returned value is           *\n*        contained in the RC special variable.                        *\n*                                                                     *\n*        The following STEMEDIT return code values are possible:      *\n*                                                                     *\n*        0    The display was successful.                             *\n*                                                                     *\n*        4    There were no stems matching the description given in   *\n*             stemname (BROWSE).  The data was not modified (EDIT).   *\n*                                                                     *\n*        8    Option incompatible with requested service.             *\n*                                                                     *\n*        12   Invalid Service requested.                              *\n*                                                                     *\n*        16   BRIF, VIIF or EDIF failed.                              *\n*                                                                     *\n* USAGE NOTES = See below                                             *\n*                                                                     *\n*        The EDIT service only works with a stem variable.            *\n*        If the data is modified by the user, STEMEDIT DROPs the      *\n*        stem variable, sets stem.0 to the number of records          *\n*        written, copies records to the stem.1 through stem.n         *\n*        where n is equal to the value of the stem.0 variable,        *\n*        and sets the RC variable to 0.  If the data is not           *\n*        modified by the user, STEMEDIT sets the RC variable to 4.    *\n*                                                                     *\n* COMPATIBILITY                                                       *\n*                                                                     *\n*        STEMEDIT has been designed to be compatible with             *\n*        the STEMDISP function of the REXXTOOLS product from          *\n*        Open Software Technologies, with the following               *\n*        exceptions:                                                  *\n*                                                                     *\n*        1. STEMEDIT supports the BROWSE, VIEW and EDIT services      *\n*           (STEMDISP only supports BROWSE).                          *\n*                                                                     *\n*        2. If stemcount is not specified, STEMEDIT scans             *\n*           variables until an unitialised variable is found.         *\n*           (STEMDISP stops after 100000 variables).                  *\n*                                                                     *\n*        3. STEMEDIT has the ability to retrieve data from a          *\n*           stem variable or the data stack (STEMDISP can only        *\n*           retrieve data from a stem variable).                      *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 100 Initial release                                            1995 *\n* 101 Fix S0C4 in RDRTNE                                         1996 *\n* 102 VIEW support via EDIF                                           *\n* 103 Convert 2nd argument to uppercase (variable name)               *\n*     Add support for 3rd and 4th arguments                           *\n* 104 Change module name from STEMDISP to STEMVIEW               1997 *\n*     Punch ' ALIAS STEMDISP ' for compatibility with REXXTOOLS       *\n*     Change name of EDIT function to VIEW                            *\n*     Issue CONTROL DISPLAY REFRESH before BROWSE/EDIT                *\n*     Pass address of environment block to IRXEXCOM                   *\n* 105 PULL data from the stack when no variable name specified        *\n*     Prompt user before saving data in VIEW mode                     *\n*     LRECL can be specified in 7th argument                          *\n*     Check for missing parms to prevent S0C4                         *\n*     Replace STRING macro with in-line code                          *\n*     Accept SHVTRUNC as valid RC from IRXEXCOM                       *\n* 106 Truncate Title                                                  *\n* 107 E or V command switches from BROWSE to VIEW                1999 *\n* 108 Set ZVMODET='VIEW' to show VIEW instead of EDIT on ISREDDEx     *\n*     Add recfm and profile parameters for VIEW                       *\n*     Display error message after BRIF/EDIF failure                   *\n*     Display STEMVIEW Arguments Syntax if not invoked from REXX      *\n* 201 Program name changed from STEMVIEW to STEMEDIT             2002 *\n*     Use VIIF instead of EDIF (OS/390 R10 and z/OS)                  *\n*     Add EDIT function for stem variables                            *\n*     Maximum length of variable name increased to 255                *\n*     Maximum length of data line increased to 32760                  *\n* 202 Set default LRECL to 255                                   2003 *\n* 203 Force default panel names - ISRBROBA/ISREDDE2              2009 *\n*     Use SAVE3 in RDRTNE and WRITERTN                                *\n*     Move LINE fld to own DSECT                                      *\n*     When invoked for BROWSE and user issues V or E :                *\n*     1. Issue CONTROL DISPLAY SAVE/RESTORE                           *\n*     2. Clear Panel Name                                             *\n* 204 Change X'40' to X'41' (NBSP) in TITLE                           *\n* 205 Add support for ISPF V3                                         *\n*     Replace LINK macro with ISPLINK                                 *\n* 206 Check for empty records in RDRTN84                         2010 *\n* 207 VIIF only supported in ISPF V5 and above                        *\n*                                                                     *\n* 208 List all Variables, stemname=*                       2013 R208  *\n*     Remove ORG instruction from R206 (this had made STEMCOUNT R208  *\n*     to an LASTELEMENT)                                        R208  *\n*     Change at label RDRTN88 to prevent display of empty lines R208  *\n*     when BROWSE is invoked with first element specified.      R208  *\n*     EDIT of variables.                                        R208  *\n* 208_2 Just changed ISPLINK@ to ISPLINKA to prevent       2017 R208  *\n*       ASCII/EBCDIC translation problems.                      R208  *\n* 209 Modification by Lionel B. Dyck                       2017 *lbd* *\n*     I found a 'bug' in STEMEDIT when using the rexx bpxwunix        *\n*     function to return the results of omvs commands to a stem.      *\n*     The results displayed were truncated and I discovered that      *\n*     there was a stem with a null value. I opened a PMR and was      *\n*     told that is by design to return the data exactly the way       *\n*     it is in the USS file or command results. The issue is that     *\n*     STEMEDIT stopped when it encountered a null stem value (as      *\n*     does EXECIO) so I make a small modification that I'd like       *\n*     to share - I've been using this for about a year with no        *\n*     adverse impact.                                                 *\n*                                                                     *\n&REL     SETC  'R209'                                                 *\n***********************************************************************\n         PUNCH ' ALIAS STEMDISP (compatibility with REXXTOOLS) '\n         PUNCH ' ALIAS STEMVIEW (compatibility with STEMVIEW) '\nSTEMEDIT CSECT\nSTEMEDIT RMODE 24                      For TPUT\nSTEMEDIT AMODE 31\n&D       SETC  '&SYSDATE'(7,2)'-'.'&SYSDATE'(1,2)'-'.'&SYSDATE'(4,2)\n         SAVE  (14,12),,'GSF Utilities - STEMEDIT &REL - 20&D &SYSTIME'\n         LR    R12,R15\n         USING STEMEDIT,R12\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ALLOCATE DYNAMIC STORAGE                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         GETMAIN RU,LV=DYNAML,         Allocate Dynamic Storage Area   X\n               LOC=BELOW,              24-bit address for TPUT         X\n               BNDRY=PAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LA    R14,72(,R1)             CLEAR WORKING STORAGE\n         LA    R15,DYNAML-72           CLEAR WORKING STORAGE\n         SLR   R1,R1                   CLEAR WORKING STORAGE\n         MVCL  R14,R0                  CLEAR WORKING STORAGE\n         LM    R13,R1,8(R13)           SET R13, RELOAD R1\n         USING DYNAM,R13\n         STM   R15,R1,R15R0R1          save regs for cmd rtne\n         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST\n         MVI   BLANKS,C' '             a bunch of blanks\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n         MVC   TITLE,BLANKS            default title\n         MVC   PANEL_NAME,BLANKS       default panel name\n         MVI   STEMCOUNT,1             default count: X'01000000'\n         GETMAIN RU,LV=L'LINE+256,     Alloc Dynamic Storage Area  R208X\n               BNDRY=PAGE\n         STM   R0,R1,LINE_LEN_ADDR     Save length/address\n         LR    R9,R1                   Copy A(LINE)\n         USING LINE_DSECT,R9\n*---------------------------------------------------------------------*\n*                                                                     *\n*        BUILD THE SHVBLOCK                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         MVI   SHVCODE,SHVFETCH        FETCH VARIABLE\n         LH    R0,=Y(L'LINE)           LENGTH OF 'FETCH' VALUE BUFFER\n         ST    R0,SHVBUFL              LENGTH OF 'FETCH' VALUE BUFFER\n         LA    R0,255                  default lrecl for BRIF/VIIF/EDIF\n         ST    R0,LRECL                default lrecl for BRIF/VIIF/EDIF\n         MVC   RECFM,=C'V '            default RECFM is V\n         MVC   PROFILE_NAME,=CL8'TEXT' default profile name\n         LA    R0,LINE                 ADDRESS OF VALUE BUFFER\n         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER\n         LA    R0,VARNAME              ADDRESS OF VARIABLE NAME\n         ST    R0,SHVNAMA              ADDRESS OF VARIABLE NAME\n         L     R15,ADDR_OF_ENVBLOCK    Environment block\n         CLC   =C'ENVBLOCK',0(R15)     Invoked from REXX?\n         BNE   NOREXX                  no, quit\n         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)\n         L     R15,IRXEXCOM-IRXEXTE(,R15)          A(IRXEXCOM)\n         L     R0,ADDR_OF_ENVBLOCK     ENVIRONMENT BLOCK\n         LA    R1,IRXEXCOM_PARM        parm list\n         STM   R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         LA    R14,=C'IRXEXCOM'        Shared Variable Routine\n         SLR   R15,R15                 PARM2=0\n         SLR   R0,R0                   PARM3=0\n         LA    R1,SHVBLOCK             PARM4\n         STM   R14,R1,IRXEXCOM_PARM    build parm list for IRXEXCOM\n         OI    IRXEXCOM_PARM+12,X'80'  VL=1\n*---------------------------------------------------------------------*\n         MACRO                                                    macro\n&NAME    ISPLINK &OPRNDS,&ERRET=                                  macro\n         GBLB  &IHBSWA                                            macro\n&IHBSWA  SETB  1                       VL=1                       macro\n&NAME    LA    R1,PARMLIST             parm list                  macro\n         IHBOPLST ,&OPRNDS,MF=(E,(1))                             macro\n         L     R15,ISPLINKA            ISPLINK bootstrap\n         BALR  R14,R15                 invoke ISPLINK\n         AIF   (T'&ERRET EQ 'O').MEND                             macro\n         LTR   R15,R15                 Any error?\n         BNZ   &ERRET                  yes, jump\n.MEND    MEND                                                     macro\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PROCESS ARGUMENTS                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LOAD  EP=ISPLINK              preload ISPLINK\n         ST    R0,ISPLINKA             A(ISPLINK)\n         LA    R0,L'ZENVIR\n         ST    R0,DWD\n         ISPLINK ($VCOPY,$ZENVIR,DWD,ZENVIR,$MOVE)\n*\n* Set VAR1 to Blank for further compares                           R208\n         MVI   VAR1,C' '                                           R208\n* Set VARL to 'S' for further compares                             R208\n         MVI   VARL,C'S'                                           R208\n*\n         LM    R2,R3,8*1-8(R11)        1st ARG (BROWSE/EDIT)\n         LTR   R3,R3                   service specified?\n         BNP   ARG1N                   no, error\n         CH    R3,=AL2(L'SERVICE)      name too long?\n         BH    ARG1N                   yes, error\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   SERVICE(*-*),0(R2)      move string\n         EX    R3,*-6                  execute MVC\n         OC    SERVICE,BLANKS          convert to uppercase\n*\n         CLI   ZENVIR+5,C'4'           ISPF V4 or above ?\n         BL    ARG1G                   no, keep blank panel name\n         MVC   PANEL_NAME,=C'ISRBROBA' default panel name (BROWSE)\nARG1G    EQU   *\n         CLC   =C'BROWSE',SERVICE      BROWSE?\n         BE    ARG1X                   yes, exit\n         CLI   ZENVIR+5,C'4'           ISPF V4 or above ?\n         BL    ARG1J                   no, keep blank panel name\n         MVC   PANEL_NAME,=C'ISREDDE2' default panel name (VIEW/EDIT)\nARG1J    EQU   *\n         CLC   =C'VIEW  ',SERVICE      VIEW?\n         BE    ARG1X                   yes, exit\n         CLC   =C'EDIT  ',SERVICE      EDIT?\n         BE    ARG1X                   yes, exit\nARG1N    EQU   *                       bad service specified\n         B     EXIT12                  no service, exit with RC=12\nARG1X    EQU   *\n*\n         LM    R2,R3,8*2-8(R11)        2ND ARG (VAR NAME)\n         STM   R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LTR   R3,R3                   stemname specified?\n         BNP   ARG2N                   no, jump\n         MVC   VAR1,0(R2)              first char of varname       R208\n         OI    0(R2),X'40'             convert to uppercase\n         LA    R2,1(,R2)               convert to uppercase\n         BCT   R3,*-8                  convert to uppercase\n         CLI   VAR1,C'*'               is varname '*' ?            R208\n         BE    ARG2RN                  yes, go to ARG2RN           R208\n         B     ARG2X\nARG2N    EQU   *                       no stemname specified\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?\n         BE    EXIT8                   yes, exit with RC=8\n         CLI   SERVICE,C'E'            SERVICE=EDIT?\n         BE    EXIT8                   yes, exit with RC=8\n         LA    R14,=CL8'PULL'          FUNCTION\n         LA    R15,SHVVALA             ADDRESS OF DATA RETURNED\n         LA    R0,SHVVALL              LENGTH OF DATA RETURNED\n         LA    R1,VALUE                VALUE RETURNED BY IRXSTK\n         LA    R2,ADDR_OF_ENVBLOCK     Environment block\n         LA    R3,RETCODE              RETURN CODE\n         STM   R14,R3,IRXSTK_PARM      BUILD PARM LIST\n         OI    IRXSTK_PARM+20,X'80'    BUILD PARM LIST\n         B     ARG2X                   Jump over ARG2RN            R208\nARG2RN   EQU   *                                                   R208\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?             R208\n         BE    EXIT8                   yes, exit with RC=8         R208\n         MVI   SHVCODE,SHVNEXTV        FETCH NEXT VARIABLE         R208\nARG2X    EQU   *\n*\n         LM    R2,R3,8*3-8(R11)        3rd ARG (first element)\n         LTR   R3,R3                   zero length?\n         BZ    ARG3X                   yes, jump\n         BM    ARG10X                  eof, exit                   R208\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         BCTR  R0,0                    relative to zero\n         ST    R0,CURRECNO             save it for later\nARG3X    EQU   *\n*\n         LM    R2,R3,8*4-8(R11)        4th ARG (stem count)\n         LTR   R3,R3                   zero length?\n         BZ    ARG4X                   yes, jump\n         BM    ARG10X                  eof, exit                   R208\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         AL    R0,CURRECNO             add origin\n*        ORG   *-4                                                 R208\n         ST    R0,STEMCOUNT            save it for later\nARG4X    EQU   *\n*\n         LM    R2,R3,8*5-8(R11)        5TH ARG (TITLE)\n         LTR   R3,R3                   zero length?\n         BZ    ARG5X                   yes, jump\n         BM    ARG10X                  eof, exit                   R208\n         LA    R1,TITLE                start of output area\n         CH    R3,=Y(L'TITLE)          title too long?\n         BNH   ARG5M                   no, jump\n         LH    R3,=Y(L'TITLE)          yes, truncate it\n*LOOP\nARG5M    MVC   0(1,R1),0(R2)           move one character\n         CLI   0(R1),X'40'             X'40' -> X'41' (NBSP)\n         BNE   *+8                     X'40' -> X'41' (NBSP)\n         MVI   0(R1),X'41'             X'40' -> X'41' (NBSP)\n         LA    R1,1(,R1)               next output char\n         LA    R2,1(,R2)               next input char\n         BCT   R3,ARG5M                move title, one char at a time\n*ENDLOOP\nARG5X    EQU   *\n*\n         LM    R2,R3,8*6-8(R11)        6TH ARG (PANEL)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG6X                   no, jump\n         BM    ARG10X                  eof, exit                   R208\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   PANEL_NAME(*-*),0(R2)   move string\n         EX    R3,*-6                  execute MVC\nARG6X    EQU   *\n*\n         LM    R2,R3,8*7-8(R11)        7th ARG (lrecl)\n         LTR   R3,R3                   zero length?\n         BZ    ARG7X                   yes, jump\n         BM    ARG10X                  eof, exit                   R208\n         BCTR  R3,0                    decrement\n         PACK  DWD,0(,R2)              *executed*\n         EX    R3,*-6                  pack the value\n         CVB   R0,DWD                  make it binary\n         ST    R0,LRECL                save it for later\n         CH    R0,=Y(L'LINE)           lrecl too big?\n         BH    EXIT8                   yes, exit with RC=8\nARG7X    EQU   *\n*\n         LM    R2,R3,8*8-8(R11)        8TH ARG (recfm)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG8X                   no, jump\n         BM    ARG10X                  eof, exit                   R208\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?\n         BE    EXIT8                   yes, exit with RC=8\n         CH    R3,=Y(L'RECFM)          too long?\n         BH    EXIT8                   yes, exit with RC=8\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   RECFM(*-*),0(R2)        move string\n         EX    R3,*-6                  execute MVC\n         OC    RECFM,BLANKS            upper-case\nARG8X    EQU   *\n*\n         LM    R2,R3,8*9-8(R11)        9TH ARG (profile)\n         LTR   R2,R2                   SPECIFIED?\n         BZ    ARG9X                   no, jump\n         BM    ARG10X                  eof, exit                   R208\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?\n         BE    EXIT8                   yes, exit with RC=8\n         CH    R3,=Y(L'PROFILE_NAME)   too long?\n         BH    EXIT8                   yes, exit with RC=8\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   PROFILE_NAME(*-*),0(R2) move string\n         EX    R3,*-6                  execute MVC\n*\nARG9X    EQU   *                       S or L                      R208\n*                                                                  R208\n         LM    R2,R3,8*10-8(R11)       10TH ARG (S or L)           R208\n         LTR   R2,R2                   SPECIFIED?                  R208\n         BZ    ARG10X                  no, jump                    R208\n         BM    ARG10X                  eof, exit                   R208\n         CLI   SERVICE,C'B'            SERVICE=BROWSE?             R208\n         BE    EXIT8                   yes, exit with RC=8         R208\n         MVC   VARL,0(R2)              first char of varlistform   R208\n         OC    VARL,BLANKS             convert to uppercase        R208\n*\nARG10X   EQU   *                       end of arg list             R208\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Invoke BRIF, VIIF or EDIF Services                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         ISPLINK ($CONTROL,$ERRORS,$RETURN) CONTROL ERRORS RETURN\n         ISPLINK ($CONTROL,$DISPLAY,$REFRESH) CONTROL DISPLAY REFRESH\n         LA    R0,SAVE2                PARM FOR READ ROUTINE\n         ST    R0,SAVE2                PARM FOR READ ROUTINE\n         LA    R2,RDRTNE               READ ROUTINE\n         LA    R3,CMDRTNE              COMMAND ROUTINE\n         LA    R4,WRITERTN             WRITE ROUTINE\n         STM   R2,R4,RDCMDWR+0         READ,CMD,WRITE\n         CLI   SERVICE,C'V'            SERVICE=VIEW?\n         BE    VIIF                    yes, jump\n         CLI   SERVICE,C'E'            SERVICE=EDIT?\n         BE    EDIF                    yes, jump\n         ISPLINK (=C'BRIF',            ISPF SERVICE                    X\n               TITLE,                  DSNAME                          X\n               RECFM,                  RECFM                           X\n               LRECL,                  LRECL                           X\n               RDCMDWR+0,              READ ROUTINE                    X\n               RDCMDWR+4,              COMMAND ROUTINE                 X\n               SAVE2,                  PARM FOR READ ROUTINE           X\n               PANEL_NAME)             PANEL (ISRBROBF/ISRBROBA)\n         CH    R15,=H'12'              empty data set?\n         BNE   GOBACK                  no, jump\n         LA    R7,4                    yes, RC=4 \"no data to browse\"\n         B     GOBACK40\nVIIF     EQU   *\n         CLI   ZENVIR+5,C'5'           ISPF V5 or above ?\n         BL    EDIF                    no, use EDIF instead of VIIF\n         ISPLINK (=C'VIIF',            ISPF SERVICE                    X\n               TITLE,                  DSNAME                          X\n               PROFILE_NAME,           PROFILE NAME                    X\n               RECFM,                  RECFM                           X\n               LRECL,                  LRECL                           X\n               RDCMDWR+0,              READ ROUTINE                    X\n               0,                      COMMAND EXIT                    X\n               SAVE2,                  PARM FOR READ ROUTINE           X\n               0,                      Edit Length                     X\n               PANEL_NAME)             PANEL (ISREDDE2/ISREDDE3)\n         B     GOBACK\nEDIF     EQU   *\n         ISPLINK (=C'EDIF',            ISPF SERVICE                    X\n               TITLE,                  DSNAME                          X\n               PROFILE_NAME,           PROFILE NAME                    X\n               RECFM,                  RECFM                           X\n               LRECL,                  LRECL                           X\n               RDCMDWR+0,              READ ROUTINE                    X\n               RDCMDWR+8,              WRITE ROUTINE                   X\n               0,                      COMMAND EXIT                    X\n               SAVE2,                  PARM FOR READ ROUTINE           X\n               0,                      Edit Length                     X\n               PANEL_NAME)             PANEL (ISREDDE2/ISREDDE3)\n         LTR   R7,R15                  OK?\n         BZ    GOBACK40                yes, jump\n         CH    R7,=H'4'                Data Modified?\n         BE    GOBACK40                no, exit with RC=4\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set return code                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOBACK   EQU   *\n         LTR   R7,R15                  OK?\n         BZ    GOBACK40                yes, jump\n         CH    R7,=H'4'                Severe error in BRIF/VIIF/EDIF?\n         BH    GOBACK16                yes, RC=16\n         SLR   R7,R7                   no, RC=0\n         B     GOBACK40\n*\n*        BRIF/VIIF/EDIF error: display error message\n*\nGOBACK16 LA    R7,1000(,R7)            RC=10nn: rc nn from BRIF/VIIF\n         LA    R0,L'ZERRMSG            max length\n         ST    R0,DWD                  max length\n         ISPLINK ($VCOPY,$ZERRMSG,DWD,ZERRMSG,$MOVE),                  X\n               ERRET=GOBACK40          No MSG, skip SETMSG\n         ISPLINK ($SETMSG,ZERRMSG)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Pass return code in RC variable                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOBACK40 EQU   *\n         LA    R0,WORK80               ADDRESS OF VALUE BUFFER\n         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER\n         CVD   R7,DWD                  convert to decimal\n         OI    DWD+7,15                convert to decimal\n         UNPK  WORK80(5),DWD           convert to decimal\n         LA    R15,5                   LENGTH OF VARIABLE NAME\n         ST    R15,SHVVALL             length\n         MVC   VARNAME(2),=C'RC'       variable name\n         LA    R15,2                   LENGTH OF VARIABLE NAME\n         ST    R15,SHVNAML             LENGTH OF VARIABLE NAME\n         LA    R0,VARNAME              ADDRESS OF VARIABLE NAME    R208\n         ST    R0,SHVNAMA              ADDRESS OF VARIABLE NAME    R208\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- Store REXX variable \"RC\"\n         SLR   R7,R7                   RC=0\n         B     EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        STEMEDIT was not invoked from a REXX exec                    *\n*        Display argument syntax using TPUT                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nNOREXX   EQU   *\n         TPUT  SYNTAXMSG,L'SYNTAXMSG   display syntax\n         LA    R7,20                   RC=20\n         B     EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CLEAN-UP AND EXIT                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nEXIT8    LA    R7,8                    RC=8 Option incompat w/service\n         B     EXIT\nEXIT12   LA    R7,12                   RC=12 Invalid Service\n*\nEXIT     LM    R0,R1,LINE_LEN_ADDR     Load length/address\n         FREEMAIN RU,LV=(R0),A=(R1)    Free Dynamic Storage Area\n         LR    R1,R13                  A(DYNAM)\n         L     R13,4(,R13)\n         FREEMAIN RU,LV=DYNAML,A=(R1)  Free Dynamic Storage Area\n         LR    R15,R7                  pass return code\n         RETURN (14,12),RC=(15)\n         DROP\n***********************************************************************\n*                                                                     *\n*        BRIF Command Routine                                         *\n*                                                                     *\n*        This routine is invoked by BRIF each time a command is       *\n*        entered on the BROWSE screen.  If the user enters the E      *\n*        or V command, then STEMEDIT reinvokes itself with VIEW       *\n*        instead of BROWSE.                                           *\n*                                                                     *\n***********************************************************************\nCMDRTNE  SAVE  (14,12),,*\n         LR    R12,R15\n         USING CMDRTNE,R12\n         LR    R14,R13                 CALLER'S SAVE AREA\n         L     R13,04(,R1)             PTR TO DIALOG DATA AREA\n         L     R13,0(,R13)             A(SAVE2)\n         ST    R14,4(,R13)             CHAIN SAVE AREAS\n         ST    R13,8(,R14)             CHAIN SAVE AREAS\n         USING SAVE2,R13\n         L     R6,00(,R1)              Function Code\n         L     R9,LINE_LEN_ADDR+4      A(LINE)\n         USING LINE_DSECT,R9\n         CLC   =F'20',0(R6)            UNKNOWN COMMAND?\n         BNE   CMDRTNE4                NO, EXIT\n         LA    R0,L'WORK80             max length of variable\n         ST    R0,DWD                  max length of variable\n         ISPLINK ($VCOPY,$ZCMD,DWD,WORK80,$MOVE)\n         OC    WORK80(2),BLANKS        upper-case\n         CLC   =C'E ',WORK80           ZCMD=\"E\" ?\n         BE    CMDRTNE7                yes, do it\n         CLC   =C'V ',WORK80           ZCMD=\"V\" ?\n         BE    CMDRTNE7                yes, do it\nCMDRTNE4 L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=4           ISPF will process the command\n*\n*        Invoke VIEW when user enters V or E during BROWSE display\n*\nCMDRTNE7 EQU   *\n         ISPLINK ($CONTROL,$DISPLAY,$SAVE) CONTROL DISPLAY SAVE\n*\n         LM    R15,R1,R15R0R1          restore regs at entry\n         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST\n         LA    R2,$VIEW                service=VIEW\n         LA    R3,L'$VIEW              length\n         STM   R2,R3,0(R11)            update service name\n         SLR   R2,R2                   R2=0\n         SLR   R3,R3                   R3=0\n         STM   R2,R3,8*6-8(R11)        6TH ARG (PANEL)\n         BALR  R14,R15              <- re-invoke myself for VIEW\n*\n         ISPLINK ($CONTROL,$DISPLAY,$RESTORE) CONTROL DISPLAY RESTORE\n*\n         L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=0           command processed\n         DROP\n***********************************************************************\n*                                                                     *\n*        BRIF/VIIF READ Routine                                       *\n*                                                                     *\n*        This routine is invoked by BRIF and VIIF to                  *\n*        return the address of a record.                              *\n*                                                                     *\n***********************************************************************\nRDRTNE   SAVE  (14,12),,*\n         LR    R12,R15\n         USING RDRTNE,R12\n         LR    R14,R13                 CALLER'S SAVE AREA\n         L     R13,12(,R1)             PTR TO DIALOG DATA AREA\n         L     R13,0(,R13)             A(SAVE2)\n         LA    R13,SAVE3-SAVE2(,R13)   A(SAVE3)\n         ST    R14,4(,R13)             CHAIN SAVE AREAS\n         ST    R13,8(,R14)             CHAIN SAVE AREAS\n         USING SAVE3,R13\n         L     R6,00(,R1)              RECORD DATA READ\n         L     R7,04(,R1)              LENGTH\n         LTR   R7,R7                   * test for zero length     *lbd*\n         BNZ   RDRTNENZ                * not zero                 *lbd*\n         LA    R7,1                    * set to length of 1       *lbd*\nRDRTNENZ EQU   *                                                  *lbd*\n         L     R4,08(,R1)              RELATIVE RECORD NUMBER\n         L     R9,LINE_LEN_ADDR+4      A(LINE)\n         USING LINE_DSECT,R9\n         CLI   SERVICE,C'V'            VIIF?\n         BE    RDRTNE06                YES, JUMP\n         CLI   SERVICE,C'E'            EDIF?\n         BE    RDRTNE06                YES, JUMP\n         L     R5,0(,R4)               LINE NUMBER REQUESTED BY BRIF\n         AL    R5,CURRECNO             add first element (4th arg)\n         B     RDRTNE07\nRDRTNE06 EQU   *\n         LA    R5,1                    NEXT LINE FOR EDIT\n         AL    R5,CURRECNO             RECORD NUMBER\n         ST    R5,CURRECNO             RECORD NUMBER\nRDRTNE07 EQU   *\n*\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         CL    R5,STEMCOUNT            end reached?\n         BH    RDRTN79                 yes, exit with RC=8\n         CLI   SHVRET,SHVLVAR          last variable to fetch?     R208\n         BE    RDRTN79                 yes, exit with RC=8         R208\n*\n*        Retrieve value of current variable\n*\n         BAL   R14,FETCHVAR         <- retrieve stemmed variable\n         CLI   SHVRET,SHVCLEAN         OK?\n         BE    RDRTN70                 yes, pass line to BRIF\n         CLI   SHVRET,SHVTRUNC         truncated value?\n         BE    RDRTN70                 yes, pass line to BRIF\n         CLI   SHVRET,SHVNEWV          this variable exists?\n         BE    RDRTN80                 NO, EXIT\n*\n*        If IRXEXCOM fails, display R15 and SHVRET values.\n*\n         MVC   LINE(L'VARNAME),VARNAME move variable name\n         L     R1,SHVNAML              length of variable name\n         LA    R2,LINE(R1)             length of variable name\n         MVC   0(5,R2),=C' R15='       move literal\n         CVD   R15,DWD                 save return code\n         OI    DWD+7,15                convert to decimal\n         UNPK  5(3,R2),DWD             move return code: R15=008\n         MVC   8(8,R2),=C',SHVRET='    move literal\n         UNPK  16(3,R2),SHVRET(2)      hex display\n         TR    16(2,R2),HEXTAB-240     hex display\n         LA    R15,18(,R1)             data length\n         ST    R15,SHVVALL             length\n*\n*        Return value of variable\n*\nRDRTN70  L     R0,SHVVALA              DATA ADDRESS\n         L     R1,SHVVALL              DATA LENGTH\n         CLI   VAR1,C'*'               Fetch all vars?             R208\n         BNE   RDRTN72                 No, jump over next lines    R208\n         CLI   VARL,C'L'               Show long var name?         R208\n         BE    RDRTN71L                yes, jump over next lines   R208\n         MVI   LVARN,C' '              Clear LVARN                 R208\n         MVC   LVARN+1(39),LVARN                                   R208\n         L     R3,SHVNAML              length of variable name     R208\n         CL    R3,=F'39'               var name longer than 39?    R208\n         BH    RDRTN71                 if longer jump              R208\n         BCTR  R3,0                    prepare \"EX\"                R208\n         MVC   LVARN(*-*),VARNAME      move variable name          R208\n         EX    R3,*-6                  execute MVC                 R208\n         B     RDRTN71E                                            R208\nRDRTN71  EQU   *                                                   R208\n         MVC   LVARN(38),VARNAME       move variable name          R208\n         MVI   LVARN+38,C'*'           move * to end of var name   R208\nRDRTN71E EQU   *                                                   R208\n         MVI   LVARN+39,C'='           move = after var name       R208\n         LA    R3,40                   R3=40                       R208\n         LA    R14,LINE                \"to\" address                R208\n         L     R15,LRECL               \"to\" length                 R208\n         SR    R15,R3                  length - 40                 R208\n         MVCL  R14,R0                  move data to LINE           R208\n         LA    R0,LINEA                DATA ADDRESS incl. varname  R208\n         L     R1,LRECL                DATA LENGTH                 R208\n         B     RDRTN72                 jump over next lines        R208\nRDRTN71L EQU   *                                                   R208\n         MVI   LVARNL,C' '             Clear LVARNL                R208\n         MVC   LVARNL+1(255),LVARNL                                R208\n         L     R3,SHVNAML              length of variable name     R208\n         CL    R3,=F'255'              var name longer than 255?   R208\n         BH    RDRTN71M                if longer jump              R208\n         BCTR  R3,0                    prepare \"EX\"                R208\n         MVC   LVARNL(*-*),VARNAME     move variable name          R208\n         EX    R3,*-6                  execute MVC                 R208\n         B     RDRTN71N                                            R208\nRDRTN71M EQU   *                                                   R208\n         MVC   LVARNL(254),VARNAME     move variable name          R208\n         MVI   LVARNL+254,C'*'         move * to end of var name   R208\nRDRTN71N EQU   *                                                   R208\n         MVI   LVARNL+255,C'='         move = after var name       R208\n         LA    R3,256                  R3=256                      R208\n         LA    R14,LINE                \"to\" address                R208\n         L     R15,LRECL               \"to\" length                 R208\n         SR    R15,R3                  length - 256                R208\n         MVCL  R14,R0                  move data to LINE           R208\n         LA    R0,LINEAL               DATA ADDRESS incl. varname  R208\n         L     R1,LRECL                DATA LENGTH                 R208\nRDRTN72  EQU   *                                                   R208\n         CLI   RECFM,C'F'              RECFM=F?\n         BNE   RDRTN74                 no, jump\n         CL    R1,LRECL                needs padding?\n         BNL   RDRTN74                 no, jump\n         LA    R14,LINE                \"to\" address\n         L     R15,LRECL               \"to\" length\n         ICM   R1,B'1000',BLANKS       padding\n         MVCL  R14,R0                  move data to LINE\n         LA    R0,LINE                 DATA ADDRESS\n         L     R1,LRECL                DATA LENGTH\nRDRTN74  EQU   *\n         ST    R0,0(,R6)               PASS DATA ADDRESS\n         ST    R1,0(,R7)               PASS DATA LENGTH\n         ST    R5,LASTLINE             CURRENT LINE NUMBER\n         L     R13,4(,R13)             BRIF SAVE AREA\n         RETURN (14,12),RC=0           GOBACK TO EDIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Scan variables to find the highest one                       *\n*                                                                     *\n*        This section determines the number of the last line and      *\n*        passes it to BRIF/VIIF/EDIF along with the EOF indicator.    *\n*                                                                     *\n*---------------------------------------------------------------------*\nRDRTN79  L     R5,STEMCOUNT            eof\n         B     RDRTN81\nRDRTN80  BCTR  R5,0                    previous line\nRDRTN81  EQU   *\n         CL    R5,LASTLINE             was good?\n         BE    RDRTN88                 yes, exit\n         L     R5,LASTLINE             previous line\n*loop\nRDRTN84  LA    R5,1(,R5)               BUMP LINE NUMBER\n         CL    R5,STEMCOUNT            end reached?\n         BH    RDRTN87                 yes, exit with RC=8\n         CLI   SHVRET,SHVLVAR          last variable to fetch?     R208\n         BE    RDRTN87                 yes, exit with RC=8         R208\n         BAL   R14,FETCHVAR         <- retrieve stemmed variable\n*check for empty variable generally created with:  stem. = ' '\n         OC    SHVVALL,SHVVALL         length=0 ?\n         BZ    RDRTN87                 yes, exit\n         CLI   SHVRET,SHVCLEAN         OK?\n         BE    RDRTN84                 yes, try next variable\n*endloop\nRDRTN87  BCTR  R5,0                    previous line\n         ST    R5,LASTLINE             save number of last line\n*RDRTN88  ST    R5,0(,R4)               LAST LINE\n*         L     R13,4(,R13)             BRIF SAVE AREA\n*         RETURN (14,12),RC=8           GOBACK TO BRIF (EOF)\nRDRTN88  EQU   *                                                   R208\n         CLI   SERVICE,C'V'            VIIF?                       R208\n         BE    RDRTN88V                YES, JUMP                   R208\n         CLI   SERVICE,C'E'            EDIF?                       R208\n         BE    RDRTN88V                YES, JUMP                   R208\n         S     R5,CURRECNO             subtract 4th arg            R208\nRDRTN88V EQU   *                                                   R208\n         ST    R5,0(,R4)               # of lines to display       R208\n         L     R13,4(,R13)             BRIF SAVE AREA              R208\n         RETURN (14,12),RC=8           GOBACK TO BRIF (EOF)        R208\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Fetch value of a variable                                    *\n*                                                                     *\n*        1. build variable name by concatenating the stem name        *\n*           (such as \"LINE.\") to the sequence number in R5            *\n*        2. pass control to IRXEXCOM                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nFETCHVAR LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LTR   R3,R3                   variable name specified?\n         BNP   FETCHV50                no, PULL from stack\n         CLI   VAR1,C'*'               Read all variables?         R208\n         BE    FETCHV40                yes jump to FETCHV40        R208\n         LR    R0,R5                   seqno\n         BAL   R15,BLDVARNM         <- build variable name\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BR    R15                     FETCH VARIABLE\n*\nFETCHV40 EQU   *                                                   R208\n         LA    R0,255                                              R208\n         ST    R0,SHVUSER              Length of varname buffer    R208\n         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME     R208\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)  R208\n         BR    R15                     FETCH VARIABLE              R208\n*\n*        PULL an element from the data stack\n*\nFETCHV50 LR    R2,R14                  save return address\n         L     R15,ADDR_OF_ENVBLOCK    Environment block\n         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)\n         L     R15,IRXSTK-IRXEXTE(,R15) STACK MANAGER\n         LA    R1,IRXSTK_PARM          PARM LIST\n         BALR  R14,R15              <- CALL IRXSTK\n         LTR   R15,R15                 EOF yet?\n         BZR   R2                      no, goback\n         MVI   SHVRET,SHVNEWV          yes, simulate EOF\n         BR    R2                      and goback\n         DROP\nHEXTAB   DC    C'0123456789ABCDEF'\n***********************************************************************\n*                                                                     *\n*        Write Routine (SERVICE=EDIT)                                 *\n*                                                                     *\n***********************************************************************\nWRITERTN SAVE  (14,12),,*\n         LR    R12,R15\n         USING WRITERTN,R12\n         LR    R14,R13                 CALLER'S SAVE AREA\n         L     R13,16(,R1)             PTR TO DIALOG DATA AREA\n         L     R13,0(,R13)             A(SAVE2)\n         LA    R13,SAVE3-SAVE2(,R13)   A(SAVE3)\n         ST    R14,4(,R13)             CHAIN SAVE AREAS\n         ST    R13,8(,R14)             CHAIN SAVE AREAS\n         USING SAVE3,R13\n         L     R6,00(,R1)              RECORD DATA\n         L     R7,04(,R1)              LENGTH\n         L     R4,08(,R1)              SOURCE/CHANGE BITS\n         L     R5,12(,R1)              REQUEST CODE\n*              REQ=0                   write next record\n*              REQ=1                   first write request\n*              REQ=2                   last write request\n*              REQ=3                   first and last write request\n*              REQ=4                   no record to write (all deleted)\n*\n         L     R9,LINE_LEN_ADDR+4      A(LINE)\n         USING LINE_DSECT,R9\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         L     R5,0(,R5)               request code\n         CH    R5,=H'0'                write next record\n         BE    WRTRTN40                yes, skip DROPVAR\n         CH    R5,=H'2'                write last record\n         BE    WRTRTN40                yes, skip DROPVAR\n         CLI   VAR1,C'*'               Fetch all vars?             R208\n         BE    WRTRTN40                yes, skip DROPVAR           R208\n*\n*        First time only: DROP stem. variables\n*\nDROPVAR  LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         ST    R3,SHVNAML              LENGTH OF VARIABLE NAME\n         MVI   SHVCODE,SHVDROPV        DROP STEM VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- DROP STEM VARIABLE\n*\n*        Write current record to stem.nnn\n*\nWRTRTN40 CH    R5,=H'4'                any record to write?\n         BE    WRTRTN80                no, exit\n         MVC   SHVVALA,0(R6)           Record ADDRESS\n         MVC   SHVVALL,0(R7)           Record LENGTH\n         LA    R0,1                    count output records\n         AL    R0,WRTLINUM             count output records\n         ST    R0,WRTLINUM             count output records\n         CLI   VAR1,C'*'               Fetch all vars?             R208\n         BE    WRTRTN90                                            R208\n         BAL   R15,BLDVARNM         <- build variable name\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- STORE VARIABLE\n*\n*        Last record only: set stem.0 to the number of records written\n*\nWRTRTN80 EQU   *\n         CH    R5,=H'2'                last record ?\n         BL    WRTRTN99                no, exit\n         CLI   VAR1,C'*'               Fetch all vars?             R208\n         BE    WRTRTN99                yes, exit                   R208\n         L     R0,WRTLINUM             count output records\n         CVD   R0,DWD                  seqno\n         OI    DWD+7,15\n         UNPK  LINE(8),DWD             99999999\n         LA    R0,LINE                 unpack 7 digits\n         ST    R0,SHVVALA              Value addr\n         LA    R0,8                    Value length\n         ST    R0,SHVVALL              Value length\n         LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LA    R0,1(,R3)               add one byte for \"0\"\n         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME\n         LA    R14,VARNAME             \"to\" addr\n         LR    R15,R3                  \"to\" length\n         MVCL  R14,R2                  move stem.\n         MVI   0(R14),C'0'             append a \"0\" : stem.0\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- STORE stem.0 VARIABLE\n         B     WRTRTN99                END                         R208\n*                                                                  R208\nWRTRTN90 EQU   *                                                   R208\n         LA    R14,LINE                \"to\" address                R208\n         L     R15,LRECL               \"to\" length                 R208\n         L     R6,SHVVALA              get value address           R208\n         L     R7,SHVVALL              get value length            R208\n         MVCL  R14,R6                  move data to LINE           R208\n         LA    R14,LINE                address of LINE             R208\n         L     R7,SHVVALL              repair R7 after MVCL        R208\n         LR    R15,R7                                              R208\n         MVI   TAB,X'00'               fill up TAB with '00'x      R208\n         MVC   TAB+1(L'TAB-1),TAB                                  R208\n         MVI   TAB+92,X'04'            '*'                         R208\n         XR    R2,R2                   R2 = 0                      R208\n         BCTR  R15,0                   prepare \"EX\"                R208\n         TRT   LINE(*-*),TAB           find '*'                    R208\n         EX    R15,*-6                 execute TRT                 R208\n         BZ    WRTRN90A                no '*', jump                R208\n         SLR   R1,R14                  position of '*'             R208\n         ST    R1,POSST                store position              R208\n         B     WRTRN90B                jump                        R208\nWRTRN90A LR    R1,R7                   max position                R208\n         ST    R1,POSST                store position              R208\nWRTRN90B MVI   TAB+92,X'00'            clear TAB                   R208\n         MVI   TAB+64,X'04'            ' '                         R208\n         XR    R2,R2                   R2 = 0                      R208\n         TRT   LINE(*-*),TAB           find ' '                    R208\n         EX    R15,*-6                 execute TRT                 R208\n         BZ    WRTRN90C                no ' ', jump                R208\n         SLR   R1,R14                  position of ' '             R208\n         ST    R1,POSBL                store position              R208\n         B     WRTRN90D                jump                        R208\nWRTRN90C LR    R1,R7                   max position                R208\n         ST    R1,POSBL                store position              R208\nWRTRN90D MVI   TAB+64,X'00'            clear TAB                   R208\n         MVI   TAB+0,X'04'             '00'x                       R208\n         XR    R2,R2                   R2 = 0                      R208\n         TRT   LINE(*-*),TAB           find '00'x                  R208\n         EX    R15,*-6                 execute TRT                 R208\n         BZ    WRTRN90E                no '00', jump               R208\n         SLR   R1,R14                  position of '00'x           R208\n         ST    R1,POS00                store position              R208\n         B     WRTRN90F                jump                        R208\nWRTRN90E LR    R1,R7                   max position                R208\n         ST    R1,POS00                store position              R208\nWRTRN90F MVI   TAB+0,X'00'             clear TAB                   R208\n         MVI   TAB+126,X'04'           '='                         R208\n         XR    R2,R2                   R2 = 0                      R208\n         TRT   LINE(*-*),TAB           find '='                    R208\n         EX    R15,*-6                 execute TRT                 R208\n         BZ    WRTRN90G                no '=', DROP var?           R208\n         SLR   R1,R14                  position of '='             R208\n         ST    R1,POSEQ                store position              R208\n         B     WRTRN90H                jump                        R208\nWRTRN90G EQU   *                       DROP var                    R208\n         CL    R7,POSST                '*' in line?                R208\n         BH    WRTRTN99                yes - jump back to EDIF     R208\n         LR    R2,R14                  convert to uppercase        R208\n         L     R3,LRECL                convert to uppercase        R208\n         OI    0(R2),X'40'             convert to uppercase        R208\n         LA    R2,1(,R2)               convert to uppercase        R208\n         BCT   R3,*-8                  convert to uppercase        R208\n         CLC   LINE(5),=C'DROP '       DROP a variable?            R208\n         BNE   WRTRTN99                no - jump back to EDIF      R208\n         LA    R1,5                    R1 = 5                      R208\n         LR    R2,R14                  R2 = Address of LINE        R208\n         AR    R2,R1                   Start of var name           R208\n         ST    R2,SHVNAMA              ADDRESS OF VARIABLE NAME    R208\n         L     R2,POS00                end of variable name        R208\n         SLR   R2,R1                   R2 = R2 - 5                 R208\n         ST    R2,SHVNAML              LENGTH OF VARIABLE NAME     R208\n         LA    R1,250                  max length of var name      R208\n         CR    R2,R1                   name too long?              R208\n         BH    WRTRTN99                yes, goback to EDIF         R208\n         MVI   SHVCODE,SHVDROPV        DROP VARIABLE               R208\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)  R208\n         BALR  R14,R15              <- DROP VARIABLE               R208\n         B     WRTRTN99                jump back to EDIF           R208\nWRTRN90H EQU   *                       SET var                     R208\n         CLC   POSST,POSEQ             '*' before '=' ?            R208\n         BL    WRTRTN99                yes - jump back to EDIF     R208\n         CLC   POSBL,POSEQ             ' ' before '=' ?            R208\n         BL    WRTRN90I                yes - jump over next libes  R208\n         ST    R14,SHVNAMA             ADDRESS OF VARIABLE NAME    R208\n         L     R1,POSEQ                POS of '=' is var length    R208\n         ST    R1,SHVNAML              set var length              R208\n         B     WRTRN90J                jump over next lines        R208\nWRTRN90I ST    R14,SHVNAMA             ADDRESS OF VARIABLE NAME    R208\n         L     R1,POSBL                POS of ' ' is var length    R208\n         ST    R1,SHVNAML              set var length              R208\nWRTRN90J L     R1,POSEQ                R1 = pos of '='             R208\n         L     R2,POS00                R2 = End of line            R208\n         SLR   R2,R1                   R2 = R2 - R1                R208\n         ST    R2,SHVVALL              set value length            R208\n         LA    R1,1(,R1)               R1 = R1 + 1                 R208\n         AR    R1,R14                  R1 = R1 + address of line   R208\n         ST    R1,SHVVALA              Convert variable name to    R208\n         L     R2,SHVNAMA              uppercase                   R208\n         L     R3,SHVNAML              convert to uppercase        R208\n         LA    R1,250                  max length of var name      R208\n         CR    R3,R1                   name too long?              R208\n         BH    WRTRTN99                yes, goback to EDIF         R208\n         OI    0(R2),X'40'             convert to uppercase        R208\n         LA    R2,1(,R2)               convert to uppercase        R208\n         BCT   R3,*-8                  convert to uppercase        R208\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE              R208\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)  R208\n         BALR  R14,R15              <- STORE VARIABLE              R208\n         B     WRTRTN99                jump back to EDIF           R208\n*\nWRTRTN99 L     R13,4(,R13)             EDIF SAVE AREA\n         RETURN (14,12),RC=0           GOBACK TO BRIF (EOF)\n         DROP  R12\n***********************************************************************\n*                                                                     *\n*        Build Variable Name                                          *\n*                                                                     *\n***********************************************************************\nBLDVARNM CVD   R0,DWD                  seqno\n         BALR  R2,0                 <- local base\n         MVC   LINE(8),=X'4020202020202020'-*(R2)\n         LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)\n         LA    R0,VARNAME              \"to\" addr\n         LR    R1,R3                   \"to\" length\n         MVCL  R0,R2                   move stem name \"LINE.\"\n         EDMK  LINE(8),DWD+4           unpack 7 digits\n         LR    R2,R1                   addr of 1st non-zero byte\n         LA    R3,LINE+8               calc length\n         SLR   R3,R2                   calc length\n         LR    R1,R3                   \"to\" length\n         MVCL  R0,R2                   move seq number\n         LA    R1,VARNAME              \"to\" addr\n         SLR   R0,R1                   calc length of variable name\n         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME\n         BR    R15                     GOBACK\n***********************************************************************\n*                                                                     *\n*        CONSTANTS                                                    *\n*                                                                     *\n***********************************************************************\n$CONTROL DC    C'CONTROL '\n$ERRORS  DC    C'ERRORS '\n$RETURN  DC    C'RETURN '\n$DISPLAY DC    C'DISPLAY '\n$REFRESH DC    C'REFRESH '\n$VCOPY   DC    C'VCOPY '\n$VERASE  DC    C'VERASE '\n$SETMSG  DC    C'SETMSG '\n$VDEFINE DC    C'VDEFINE '\n$ZERRMSG DC    C'ZERRMSG '\n$ZENVIR  DC    C'ZENVIR '\n$SAVE    DC    C'SAVE '\n$RESTORE DC    C'RESTORE '\n$ZCMD    DC    C'ZCMD '\n$VIEW    DC    C'VIEW '\n$MOVE    DC    C'MOVE '\nSYNTAXMSG DC     C'Syntax: CALL STEMEDIT service<,stemname><,firstelem>X\n               <,stemcount><,title><,panel><,lrecl><,recfm><,profile>'\n***********************************************************************\n*                                                                     *\n*        Dynamic Storage Area - LOC=BELOW                             *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     MAIN-LINE\nSAVE2    DS    18F                     Save area for cmd rtne\nSAVE3    DS    18F                     Save area for read/write rtnes\n*\nDWD      DS    D                       work area for CVB/CVD\nR15R0R1  DS    A(R15,R0,R1)            regs at entry to STEMEDIT\nISPLINKA DS    V(ISPLINK)              ISPF INTERFACE\nADDR_OF_ENVBLOCK EQU R15R0R1+4,4,C'A'  ENVIRONMENT BLOCK\nPANEL_NAME DS  C'ISRBROBA'             PANEL (6th arg)\nTITLE    DS    CL54                    Title\nSERVICE  DS    C'BROWSE'               ISPF Service (\"B\" or \"V\" or \"E\")\nRECFM    DS    C'V '                   record format\nPROFILE_NAME DS CL8'TEXT'              profile name for EDIF/VIIF\nSTEMNAME DS    A,F                     ADDR/LEN OF STEM NAME (2nd arg)\nCURRECNO DS    F                       first element (3rd arg)\nSTEMCOUNT DS   F                       number of variables (4th arg)\nLRECL    DS    F                       record length (7th arg)\nLASTLINE DS    F                       last line number\nWRTLINUM DS    F                       line number for write rtne\nLINE_LEN_ADDR DS F,A(LINE_DSECT)       length and address of LINE fld\nPARMLIST DS    12F                     EDIF/BRIF/VIIF Parm List\nRDCMDWR  DS    A(RDRTNE,CMDRTNE,WRITERTN) READ/CMD/WRITE Routines\nIRXEXCOM_REGS DS A(R15,R0,R1)          IRXEXCOM\nIRXEXCOM_PARM DS 4A                    IRXEXCOM\nIRXSTK_PARM DS 6A                      IRXSTK\nDYNAM_SHVB DS  XL(SHVBLEN)             SHVB (IRXEXCOM)\nRETCODE  DS    F                       RETURN CODE\nVALUE    DS    F                       VALUE RETURNED BY FUNCTION\nVARNAME  DS    CL255                   variable name\nVAR1     DS    CL1                     VARNAME first character     R208\nVARL     DS    CL1                     Form of var-list S or L     R208\nPOSEQ    DS    F                       position of '='             R208\nPOSBL    DS    F                       position of ' '             R208\nPOS00    DS    F                       position of '00'x           R208\nPOSST    DS    F                       position of '*'             R208\nZENVIR   DS    CL32'ISPF 3.2'          CURRENT ISPF LEVEL\nZERRMSG  DS    CL8                     error message\nWORK80   DS    CL80                    work area\nBLANKS   DS    CL256                   a bunch of blanks\nTAB      DS    XL256                   table for TRT               R208\nDYNAML   EQU   *-DYNAM\n*\nLINE_DSECT DSECT                       RMODE=31\nLINEAL   DS    0CL33016                Line in * output, long varn R208\nLVARNL   DS    CL216                   Long varname in * output    R208\nLINEA    DS    0CL32800                Line in * output            R208\nLVARN    DS    CL40                    Varname in * output         R208\nLINE     DS    CL32760\n*\n         PRINT NOGEN\n         IRXEFPL DSECT=YES             External Function Parm List\n         IRXENVB                       Environment Block\n         IRXEXTE                       External Function Entry Points\n         IRXSHVB                       Shared REXX Variable Req Block\n         YREGS                         Register Equates (R0-R15)\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM='LIST,MAP,RENT,REFR'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=GILBERT.FILE183.LOAD(STEMEDIT),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMEMCB": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x13#\\x0f\\x01\\x13#\\x0f\\x14\\x10\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-18T00:00:00", "modifydate": "2013-08-18T14:10:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "RNOWAK"}, "text": "/* Rexx **************************************************************/\n/* Edit Macro for STEMEDIT 'EDIT','*'                                */\n/* Call this macro at the beginning of the edit session to change    */\n/* all '00'x in blanks and shift the '=' to the left.                */\n/* At the end of the edit session STEMEMCE should be called to end   */\n/* up the lines with '00'x                                           */\n/*********************************************************************/\n\"ISREDIT MACRO\"\n\"ISREDIT CHANGE '00'X '40'X ALL\"\nDO UNTIL RC > 0\n   \"ISREDIT CHANGE '  =' ' =' ALL\"\nEND\n\"ISREDIT MEND\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMEMCE": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x13#\\x0f\\x01  O\\x176\\x00\\x16\\x00\\x16\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-08-18T00:00:00", "modifydate": "2020-07-22T17:36:18", "lines": 22, "newlines": 22, "modlines": 0, "user": "RNOWAK"}, "text": "/* Rexx **************************************************************/\n/* Edit Macro for STEMEDIT 'EDIT','*'                                */\n/* Call this macro at the end of the edit session to end up the      */\n/* lines with '00'x.                                                 */\n/*********************************************************************/\n\"ISREDIT MACRO\"\n\"ISREDIT (n) = LINENUM .ZLAST\"\nDO i=1 to n\n  \"ISREDIT (currline) =LINE \"i\n  if POS('00'x,currline) = 0 then do\n     l = LENGTH(currline)\n     c = SUBSTR(currline,l,1)\n     DO WHILE c = ' '\n        l = l - 1\n        c = SUBSTR(currline,l,1)\n     END\n     currline = LEFT(currline,l) || '00'x || SUBSTR(currline,l+2)\n     \"ISREDIT LINE \"i\" = '\"currline\"'\"\n  end\nEND\n\"ISREDIT MEND\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMOUT": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x19\\x00\\x8f\\x01\\x19\\x00\\x8f\\x14\\x07\\x01>\\x01>\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-01-08T00:00:00", "modifydate": "2019-01-08T14:07:59", "lines": 318, "newlines": 318, "modlines": 0, "user": "RNOWAK"}, "text": "//GILBERTV JOB (ACCT#),STEMOUT,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = STEMOUT                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = Write REXX Variables to Dataset.                 *\n*                                                                     *\n* STATUS = R100                                                       *\n*                                                                     *\n* FUNCTION = This assembler sub-routine can be invoked by a REXX      *\n*            EXEC to write the REXX variables to a dataset. Dataset   *\n*            must be PS, FB, 1024 and allocated to DD-name STEMOUT.   *\n*            STEMOUT is supposed to be used in batch. In ISPF you     *\n*            can use STEMEDIT.                                        *\n*                                                                     *\n* AUTHOR = Rainer Nowak                                               *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: OS/390 R10 or z/OS                                 *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    ATTRIBUTES =              RMODE ANY, AMODE 31,                   *\n*                 PROBLEM STATE, KEY 8                                *\n*                 APF AUTHORIZATION: NONE                             *\n*                                                                     *\n* SYNTAX  =  See below                                                *\n*                                                                     *\n*    CALL STEMOUT                                                     *\n*                                                                     *\n*    Arguments:     none                                              *\n*                                                                     *\n*                                                                     *\n* RETURN-CODES = See below                                            *\n*                                                                     *\n*        The STEMOUT  function returns a return code that indicates   *\n*        whether the display worked.  The returned value is           *\n*        contained in the RC special variable.                        *\n*                                                                     *\n*        The following STEMOUT  return code values are possible:      *\n*                                                                     *\n*        0    The display was successful.                             *\n*                                                                     *\n*        16                            .                              *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* 100 Initial release                                            2019 *\n*                                                                     *\n&REL     SETC  'R100'                                                 *\n***********************************************************************\nSTEMOUT  CSECT\nSTEMOUT  RMODE 24                      For PUT\nSTEMOUT  AMODE 31\n&D       SETC  '&SYSDATE'(7,2)'-'.'&SYSDATE'(1,2)'-'.'&SYSDATE'(4,2)\n         SAVE  (14,12),,'STEMOUT &REL - 20&D &SYSTIME'\n         LR    R12,R15\n         USING STEMOUT,R12\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ALLOCATE DYNAMIC STORAGE                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         GETMAIN RU,LV=DYNAML,         Allocate Dynamic Storage Area   X\n               LOC=BELOW,              24-bit address for PUT          X\n               BNDRY=PAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LA    R14,72(,R1)             CLEAR WORKING STORAGE\n         LA    R15,DYNAML-72           CLEAR WORKING STORAGE\n         SLR   R1,R1                   CLEAR WORKING STORAGE\n         MVCL  R14,R0                  CLEAR WORKING STORAGE\n         LM    R13,R1,8(R13)           SET R13, RELOAD R1\n         USING DYNAM,R13\n         STM   R15,R1,R15R0R1          save regs for cmd rtne\n         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST\n         MVI   BLANKS,C' '             a bunch of blanks\n         MVC   BLANKS+1(L'BLANKS-1),BLANKS\n         MVI   STEMCOUNT,1             default count: X'01000000'\n         GETMAIN RU,LV=L'LINE+256,     Alloc Dynamic Storage Area      X\n               BNDRY=PAGE\n         STM   R0,R1,LINE_LEN_ADDR     Save length/address\n         LR    R9,R1                   Copy A(LINE)\n         USING LINE_DSECT,R9\n*---------------------------------------------------------------------*\n*                                                                     *\n*        BUILD THE SHVBLOCK                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LA    R10,DYNAM_SHVB\n         USING SHVBLOCK,R10\n         MVI   SHVCODE,SHVNEXTV        FETCH NEXT VARIABLE\n         LH    R0,=Y(L'LINE)           LENGTH OF 'FETCH' VALUE BUFFER\n         ST    R0,SHVBUFL              LENGTH OF 'FETCH' VALUE BUFFER\n         LA    R0,1024                 default lrecl\n         ST    R0,LRECL                default lrecl\n         MVC   RECFM,=C'FB'            default RECFM is F\n         LA    R0,LINE                 ADDRESS OF VALUE BUFFER\n         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER\n         LA    R0,VARNAME              ADDRESS OF VARIABLE NAME\n         ST    R0,SHVNAMA              ADDRESS OF VARIABLE NAME\n         L     R15,ADDR_OF_ENVBLOCK    Environment block\n         CLC   =C'ENVBLOCK',0(R15)     Invoked from REXX?\n         BNE   NOREXX                  no, quit\n         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)\n         L     R15,IRXEXCOM-IRXEXTE(,R15)          A(IRXEXCOM)\n         L     R0,ADDR_OF_ENVBLOCK     ENVIRONMENT BLOCK\n         LA    R1,IRXEXCOM_PARM        parm list\n         STM   R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         LA    R14,=C'IRXEXCOM'        Shared Variable Routine\n         SLR   R15,R15                 PARM2=0\n         SLR   R0,R0                   PARM3=0\n         LA    R1,SHVBLOCK             PARM4\n         STM   R14,R1,IRXEXCOM_PARM    build parm list for IRXEXCOM\n         OI    IRXEXCOM_PARM+12,X'80'  VL=1\n*---------------------------------------------------------------------*\n*        OPEN DATASET                                                 *\n*---------------------------------------------------------------------*\n         OPEN  MF=(E,XOPEN),MODE=24\n*\n         MVI   LVARNL,C' '             Clear LVARNL\n         MVC   LVARNL+1(255),LVARNL\n         MVI   LVARNL+256,C' '             Clear LVARNL\n         MVC   LVARNL+257(255),LVARNL\n         MVI   LVARNL+512,C' '             Clear LVARNL\n         MVC   LVARNL+513(255),LVARNL\n         MVI   LVARNL+768,C' '             Clear LVARNL\n         MVC   LVARNL+769(255),LVARNL\n         MVC   LINEAL(L'TITLE),TITLE   default title\n         PUT   OUTDAT,LINEAL\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Invoke IRXEXCOM                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         CLI   SHVRET,SHVLVAR          last variable to fetch?\n         BE    GOBACK                  yes, exit\n*loop\nRDRTN84  EQU   *\n         CLI   SHVRET,SHVLVAR          last variable to fetch?\n         BE    GOBACK                  yes, exit\n         BAL   R14,FETCHVAR         <- retrieve stemmed variable\n*check for empty variable generally created with:  stem. = ' '\n*        OC    SHVVALL,SHVVALL         length=0 ?\n*        BZ    GOBACK                  yes, exit\n         CLI   SHVRET,SHVCLEAN         OK?\n         BNE   GOBACK\nRDRTN70  L     R0,SHVVALA              DATA ADDRESS\n         L     R1,SHVVALL              DATA LENGTH\n         MVI   LVARNL,C' '             Clear LVARNL\n         MVC   LVARNL+1(255),LVARNL\n         L     R3,SHVNAML              length of variable name\n         CL    R3,=F'255'              var name longer than 255?\n         BH    RDRTN71M                if longer jump\n         BCTR  R3,0                    prepare \"EX\"\n         MVC   LVARNL(*-*),VARNAME     move variable name\n         EX    R3,*-6                  execute MVC\n         B     RDRTN71N\nRDRTN71M EQU   *\n         MVC   LVARNL(254),VARNAME     move variable name\n         MVI   LVARNL+254,C'*'         move * to end of var name\nRDRTN71N EQU   *\n         MVI   LVARNL+255,C'='         move = after var name\n         LA    R3,256                  R3=256\n         LA    R14,LINE                \"to\" address\n         L     R15,LRECL               \"to\" length\n         SR    R15,R3                  length - 256\n         ICM   R1,B'1000',BLANKS       padding\n         MVCL  R14,R0                  move data to LINE\nRDRTN74  EQU   *\n         PUT   OUTDAT,LINEAL\n         B     RDRTN84                 try next variable\n*endloop\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set return code                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOBACK   EQU   *\n         LTR   R7,R15                  OK?\n         BZ    GOBACK40                yes, jump\n         CH    R7,=H'4'                Severe error?\n         BH    GOBACK16                yes, RC=16\n         SLR   R7,R7                   no, RC=0\n         B     GOBACK40\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Pass return code in RC variable                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOBACK16 LA    R7,16\nGOBACK40 EQU   *\n         LA    R0,WORK80               ADDRESS OF VALUE BUFFER\n         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER\n         CVD   R7,DWD                  convert to decimal\n         OI    DWD+7,15                convert to decimal\n         UNPK  WORK80(5),DWD           convert to decimal\n         LA    R15,5                   LENGTH OF VARIABLE NAME\n         ST    R15,SHVVALL             length\n         MVC   VARNAME(2),=C'RC'       variable name\n         LA    R15,2                   LENGTH OF VARIABLE NAME\n         ST    R15,SHVNAML             LENGTH OF VARIABLE NAME\n         LA    R0,VARNAME              ADDRESS OF VARIABLE NAME\n         ST    R0,SHVNAMA              ADDRESS OF VARIABLE NAME\n         MVI   SHVCODE,SHVSTORE        STORE VARIABLE\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BALR  R14,R15              <- Store REXX variable \"RC\"\n         SLR   R7,R7                   RC=0\n         CLOSE MF=(E,XCLOSE),MODE=24\n         B     EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        STEMOUT  was not invoked from a REXX exec                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nNOREXX   EQU   *\n         LA    R7,20                   RC=20\n         B     EXIT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CLEAN-UP AND EXIT                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nEXIT     LM    R0,R1,LINE_LEN_ADDR     Load length/address\n         FREEMAIN RU,LV=(R0),A=(R1)    Free Dynamic Storage Area\n         LR    R1,R13                  A(DYNAM)\n         L     R13,4(,R13)\n         FREEMAIN RU,LV=DYNAML,A=(R1)  Free Dynamic Storage Area\n         LR    R15,R7                  pass return code\n         RETURN (14,12),RC=(15)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Fetch value of a variable                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\nFETCHVAR EQU   *\n         LA    R0,255\n         ST    R0,SHVUSER              Length of varname buffer\n         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME\n         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)\n         BR    R15                     FETCH VARIABLE\n         DROP\n***********************************************************************\n*                                                                     *\n*        CONSTANTS                                                    *\n*                                                                     *\n***********************************************************************\nHEXTAB   DC    C'0123456789ABCDEF'\nXOPEN    OPEN  (OUTDAT,(OUTPUT)),MODE=24,MF=L\nXCLOSE   CLOSE (OUTDAT),MODE=24,MF=L\nTITLE    DC    C'****** REXX Variables *****' Title\n         EJECT\n******************************************************************\n*         ----- D A T E I - D E F I N I T I O N -----            *\n******************************************************************\nOUTDAT   DCB   DDNAME=STEMOUT,DSORG=PS,MACRF=(PM),                     +\n               LRECL=1024,BLKSIZE=30720,                               +\n               RECFM=FB\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Dynamic Storage Area - LOC=BELOW                             *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     MAIN-LINE\nSAVE2    DS    18F                     Save area for cmd rtne\nSAVE3    DS    18F                     Save area for read/write rtnes\n*\nDWD      DS    D                       work area for CVB/CVD\nR15R0R1  DS    A(R15,R0,R1)            regs at entry to STEMOUT\nADDR_OF_ENVBLOCK EQU R15R0R1+4,4,C'A'  ENVIRONMENT BLOCK\nRECFM    DS    C'FB'                   record format\nCURRECNO DS    F                       first element (3rd arg)\nSTEMCOUNT DS   F                       number of variables (4th arg)\nLRECL    DS    F                       record length (7th arg)\nLINE_LEN_ADDR DS F,A(LINE_DSECT)       length and address of LINE fld\nIRXEXCOM_REGS DS A(R15,R0,R1)          IRXEXCOM\nIRXEXCOM_PARM DS 4A                    IRXEXCOM\nIRXSTK_PARM DS 6A                      IRXSTK\nDYNAM_SHVB DS  XL(SHVBLEN)             SHVB (IRXEXCOM)\nRETCODE  DS    F                       RETURN CODE\nVALUE    DS    F                       VALUE RETURNED BY FUNCTION\nVARNAME  DS    CL255                   variable name\nZERRMSG  DS    CL8                     error message\nWORK80   DS    CL80                    work area\nBLANKS   DS    CL256                   a bunch of blanks\nDYNAML   EQU   *-DYNAM\n*\nLINE_DSECT DSECT                       RMODE=31\nLINEAL   DS    0CL1024                 Line\nLVARNL   DS    CL256                   varname\nLINE     DS    CL768\n*\n         PRINT NOGEN\n         IRXEFPL DSECT=YES             External Function Parm List\n         IRXENVB                       Environment Block\n         IRXEXTE                       External Function Entry Points\n         IRXSHVB                       Shared REXX Variable Req Block\n         YREGS                         Register Equates (R0-R15)\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200\n//*\n//LKED    EXEC PGM=IEWL,PARM='LIST,MAP,RENT,REFR'\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=GILBERT.FILE183.LOAD(STEMOUT),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TALLY": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00S\\x01\\x13#\\x0f\\x01  O\\x176\\x00d\\x00d\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-08-18T00:00:00", "modifydate": "2020-07-22T17:36:53", "lines": 100, "newlines": 100, "modlines": 0, "user": "RNOWAK"}, "text": "/*---------------------------------------------------------------REXX-*\u00de\n|*                                                                    *|\n|* MODULE NAME = TALLY                                                *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Tallies tracks on DSLIST panel.                 *|\n|*                                                                    *|\n|* STATUS = R103                                                      *|\n|*                                                                    *|\n|* FUNCTION = Display the total number of tracks used up by the       *|\n|*            data sets currently displayed on the Data Set List      *|\n|*            panel (ISPF 3.4).  Requires that the size information   *|\n|*            for all the data sets be previously obtained from the   *|\n|*            VTOC, for example with a SORT SIZE command.             *|\n|*                                                                    *|\n|* AUTHOR   =  Gilbert Saint-Flour <carlos\u00bagsf-soft.com>              *|\n|*             http://gsf-soft.com/Freeware/                          *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                ISPF V3, V4, V5 or V6                               *|\n|*                                                                    *|\n|* SYNTAX   =  TALLY                                                  *|\n|*                                                                    *|\n|*             Must be issued while on the DSLIST panel, either       *|\n|*             as a line command (on any line) or as TSO %TALLY.      *|\n|*                                                                    *|\n|* CHANGE LOG                                                         *|\n|*                                                                    *|\n|*101 When DTA+016=0, get DSB addr from DTA+044                       *|\n|*102 Stop using DTB in ISPF 5.9 and above                Ron.Hesketh *|\n|*103 Changed for ISPF above V5.9                        Rainer Nowak *|\n|*                                                                    *|\n\u00de*--------------------------------------------------------------------*/\nADDRESS 'ISPEXEC'\ntcb    = PTR(540)               /* TCB (EXEC command)    PSATOLD  */\ntcb    = PTR(tcb+132)           /* TCB (ISPTASK)         TCBOTC   */\nfsa    = PTR(tcb+112)           /* first save area       TCBFSA   */\nr1     = PTR(fsa+24)            /* ISPTASK's R1                   */\ntld    = PTR(r1)                /* TLD address                    */\ndta    = PTR(tld+076)           /* DTA address                    */\ntbl    = STORAGE(D2X(dta+12),8) /* Name of temp table    DSL12345 */\n\"VGET ZENVIR\"                   /* Retrieve ISPF Version          */\nIF LEFT(Zenvir,8) < 'ISPF 5.9' THEN DO\n  dtb    = PTR(dta+016)           /* DTB address                  */\n  IF dtb=0 THEN\n    dtb  = PTR(dta+044)           /* OPEN Table Chain             */\n  IF STORAGE(D2X(dtb),3) /= 'DTB' THEN DO\n    SAY 'Error: Table name could not be located (DTB)' zenvir\n    EXIT 12\n    END\n  tbl  = STORAGE(D2X(dtb+6),8)  /* Name of temp table    DSL12345 */\n  END\nELSE DO                         /* ISPF >= 5.9                    */\n   start = dta + 196            /* Address of first table name    */\n   finished = 'NO'\n   otnr = 0\n   DO UNTIL finished = 'YES'\n      tbl = STORAGE(D2X(start),8) /* Name of table */\n      if C2X(LEFT(tbl,1)) = '00' then do\n         finished = 'YES'\n      end\n      else do\n         if LEFT(tbl,3) = 'DSL' then do\n            otnr = otnr + 1\n            finished = 'YES'\n         end\n         start = start + 12\n      end\n   END\n   IF otnr = 0 THEN DO\n    SAY 'Error: Table name could not be located' zenvir\n    EXIT 12\n    END\nEND\n\n'CONTROL ERRORS RETURN'\n'TBTOP' tbl\n  IF rc>0 THEN DO\n    SAY 'TBTOP failed for table' tbl 'RC='rc\n    EXIT\n  END\n\ntally=0;rows=0;processed=0;zusize=0   /* Init counters */\nDO FOREVER\n  'TBSKIP' tbl                        /* NEXT ROW      */\n  IF rc>0 THEN LEAVE\n  'TBGET' tbl                         /* SET VARIABLES */\n  IF rc>0 THEN LEAVE\n  rows=rows+1                         /* count rows    */\n  IF zusize = '' THEN ITERATE         /* ignore migrated data sets */\n  tally=tally+zusize                  /* tally file size */\n  processed=processed+1               /* count processed data sets */\nEND\nZMSG000S = tally 'Tracks'\nZMSG000L = 'Total Data sets:' rows,\n           ' Data sets processed:' processed,\n           ' Total tracks:' tally\n\"SETMSG MSG(ISPZ000)\"\nEXIT\n\nPTR: RETURN C2D(STORAGE(D2X(ARG(1)),4))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOHELP": {"ttr": 2062, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x17\\x15/\\x01\\x17\\x15/\"\\x12\\x00\\xcc\\x00\\xcc\\x00\\x00\\xd9\\xd5\\xd6\\xe6\\xc1\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-06-01T00:00:00", "modifydate": "2017-06-01T22:12:32", "lines": 204, "newlines": 204, "modlines": 0, "user": "RNOWAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT895/FILE895.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT895", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}